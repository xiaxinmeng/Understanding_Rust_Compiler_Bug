{"sha": "94471a56634ca1595f2da0bb6fda1a817df95325", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ0NzFhNTY2MzRjYTE1OTVmMmRhMGJiNmZkYTFhODE3ZGY5NTMyNQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2010-09-07T19:03:41Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-09-07T19:03:41Z"}, "message": "re PR fortran/45186 (Gfortran 4.5.0 emits wrong linenumbers)\n\n2010-09-07  Tobias Burnus <burnus@net-b.de>\n\n        PR fortran/45186\n        * trans-array.c (gfc_conv_descriptor_data_get,\n        gfc_conv_descriptor_data_set, gfc_conv_descriptor_data_addr,\n        gfc_conv_descriptor_offset, gfc_conv_descriptor_dtype,\n        gfc_conv_descriptor_dimension, gfc_conv_descriptor_stride,\n        gfc_conv_descriptor_lbound, gfc_conv_descriptor_ubound,\n        gfc_conv_shift_descriptor_lbound,\n        gfc_set_loop_bounds_from_array_spec,\n        gfc_trans_allocate_array_storage, gfc_trans_create_temp_array,\n        gfc_conv_array_transpose, gfc_get_iteration_count,\n        gfc_grow_array, gfc_trans_array_ctor_element,\n        gfc_trans_array_constructor_subarray,\n        gfc_trans_array_constructor_value,\n        constant_array_constructor_loop_size,\n        gfc_trans_array_constructor,\n        gfc_set_vector_loop_bounds, gfc_trans_array_bound_check,\n        gfc_conv_array_index_offset, gfc_conv_scalarized_array_ref,\n        gfc_conv_array_ref, gfc_trans_preloop_setup,\n        gfc_trans_scalarized_loop_end, gfc_conv_ss_startstride,\n        gfc_conv_loop_setup, gfc_conv_array_extent_dim,\n        gfc_conv_descriptor_size, gfc_array_init_size,\n        gfc_array_allocate, gfc_array_deallocate,\n        gfc_trans_array_bounds, gfc_trans_auto_array_allocation,\n        gfc_trans_dummy_array_bias, gfc_get_dataptr_offset,\n        get_array_charlen, gfc_conv_expr_descriptor,\n        array_parameter_size, gfc_conv_array_parameter,\n        gfc_trans_dealloc_allocated, get_full_array_size,\n        duplicate_allocatable,\n        structure_alloc_comps): Change fold_build[0-9] to\n        fold_build[0-9]_loc.\n        (duplicate_allocatable, structure_alloc_comps,\n        gfc_duplicate_allocatable): Add space after function name.\n\nFrom-SVN: r163964", "tree": {"sha": "3cb3d95d9dcd75f4b319a7ef223c76f636d85a67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3cb3d95d9dcd75f4b319a7ef223c76f636d85a67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94471a56634ca1595f2da0bb6fda1a817df95325", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94471a56634ca1595f2da0bb6fda1a817df95325", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94471a56634ca1595f2da0bb6fda1a817df95325", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94471a56634ca1595f2da0bb6fda1a817df95325/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c811b2a5880a9b56451162099b48bc32c37c4022", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c811b2a5880a9b56451162099b48bc32c37c4022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c811b2a5880a9b56451162099b48bc32c37c4022"}], "stats": {"total": 818, "additions": 489, "deletions": 329}, "files": [{"sha": "b04109062876802e8ae12f52f77bf41d9486fdc7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94471a56634ca1595f2da0bb6fda1a817df95325/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94471a56634ca1595f2da0bb6fda1a817df95325/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=94471a56634ca1595f2da0bb6fda1a817df95325", "patch": "@@ -1,3 +1,37 @@\n+2010-09-07  Tobias Burnus <burnus@net-b.de>\n+\n+\tPR fortran/45186\n+\t* trans-array.c (gfc_conv_descriptor_data_get,\n+\tgfc_conv_descriptor_data_set, gfc_conv_descriptor_data_addr,\n+\tgfc_conv_descriptor_offset, gfc_conv_descriptor_dtype,\n+\tgfc_conv_descriptor_dimension, gfc_conv_descriptor_stride,\n+\tgfc_conv_descriptor_lbound, gfc_conv_descriptor_ubound,\n+\tgfc_conv_shift_descriptor_lbound,\n+\tgfc_set_loop_bounds_from_array_spec,\n+\tgfc_trans_allocate_array_storage, gfc_trans_create_temp_array,\n+\tgfc_conv_array_transpose, gfc_get_iteration_count,\n+\tgfc_grow_array, gfc_trans_array_ctor_element,\n+\tgfc_trans_array_constructor_subarray,\n+\tgfc_trans_array_constructor_value,\n+\tconstant_array_constructor_loop_size, gfc_trans_array_constructor,\n+\tgfc_set_vector_loop_bounds, gfc_trans_array_bound_check,\n+\tgfc_conv_array_index_offset, gfc_conv_scalarized_array_ref,\n+\tgfc_conv_array_ref, gfc_trans_preloop_setup,\n+\tgfc_trans_scalarized_loop_end, gfc_conv_ss_startstride,\n+\tgfc_conv_loop_setup, gfc_conv_array_extent_dim,\n+\tgfc_conv_descriptor_size, gfc_array_init_size,\n+\tgfc_array_allocate, gfc_array_deallocate,\n+\tgfc_trans_array_bounds, gfc_trans_auto_array_allocation,\n+\tgfc_trans_dummy_array_bias, gfc_get_dataptr_offset,\n+\tget_array_charlen, gfc_conv_expr_descriptor,\n+\tarray_parameter_size, gfc_conv_array_parameter,\n+\tgfc_trans_dealloc_allocated, get_full_array_size,\n+\tduplicate_allocatable,\n+\tstructure_alloc_comps): Change fold_build[0-9] to\n+\tfold_build[0-9]_loc.\n+\t(duplicate_allocatable, structure_alloc_comps,\n+\tgfc_duplicate_allocatable): Add space after function name.\n+\n 2010-09-07  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans-stmt.c (gfc_trans_character_select): Be conversion-safe while"}, {"sha": "0cb5b1e938b6862cbbdff65f62641d5af51e2ec9", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 455, "deletions": 329, "changes": 784, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94471a56634ca1595f2da0bb6fda1a817df95325/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94471a56634ca1595f2da0bb6fda1a817df95325/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=94471a56634ca1595f2da0bb6fda1a817df95325", "patch": "@@ -147,7 +147,8 @@ gfc_conv_descriptor_data_get (tree desc)\n   field = TYPE_FIELDS (type);\n   gcc_assert (DATA_FIELD == 0);\n \n-  t = fold_build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n+  t = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field), desc,\n+\t\t       field, NULL_TREE);\n   t = fold_convert (GFC_TYPE_ARRAY_DATAPTR_TYPE (type), t);\n \n   return t;\n@@ -172,7 +173,8 @@ gfc_conv_descriptor_data_set (stmtblock_t *block, tree desc, tree value)\n   field = TYPE_FIELDS (type);\n   gcc_assert (DATA_FIELD == 0);\n \n-  t = fold_build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n+  t = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field), desc,\n+\t\t       field, NULL_TREE);\n   gfc_add_modify (block, t, fold_convert (TREE_TYPE (field), value));\n }\n \n@@ -191,7 +193,8 @@ gfc_conv_descriptor_data_addr (tree desc)\n   field = TYPE_FIELDS (type);\n   gcc_assert (DATA_FIELD == 0);\n \n-  t = fold_build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n+  t = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field), desc,\n+\t\t       field, NULL_TREE);\n   return gfc_build_addr_expr (NULL_TREE, t);\n }\n \n@@ -207,8 +210,8 @@ gfc_conv_descriptor_offset (tree desc)\n   field = gfc_advance_chain (TYPE_FIELDS (type), OFFSET_FIELD);\n   gcc_assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  return fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n-\t\t      desc, field, NULL_TREE);\n+  return fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t  desc, field, NULL_TREE);\n }\n \n tree\n@@ -238,8 +241,8 @@ gfc_conv_descriptor_dtype (tree desc)\n   field = gfc_advance_chain (TYPE_FIELDS (type), DTYPE_FIELD);\n   gcc_assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  return fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n-\t\t      desc, field, NULL_TREE);\n+  return fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t  desc, field, NULL_TREE);\n }\n \n static tree\n@@ -257,8 +260,8 @@ gfc_conv_descriptor_dimension (tree desc, tree dim)\n \t  && TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (field))) == RECORD_TYPE);\n \n-  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n-\t\t     desc, field, NULL_TREE);\n+  tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t desc, field, NULL_TREE);\n   tmp = gfc_build_array_ref (tmp, dim, NULL);\n   return tmp;\n }\n@@ -274,8 +277,8 @@ gfc_conv_descriptor_stride (tree desc, tree dim)\n   field = gfc_advance_chain (field, STRIDE_SUBFIELD);\n   gcc_assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n-\t\t     tmp, field, NULL_TREE);\n+  tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t tmp, field, NULL_TREE);\n   return tmp;\n }\n \n@@ -312,8 +315,8 @@ gfc_conv_descriptor_lbound (tree desc, tree dim)\n   field = gfc_advance_chain (field, LBOUND_SUBFIELD);\n   gcc_assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n-\t\t     tmp, field, NULL_TREE);\n+  tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t tmp, field, NULL_TREE);\n   return tmp;\n }\n \n@@ -342,8 +345,8 @@ gfc_conv_descriptor_ubound (tree desc, tree dim)\n   field = gfc_advance_chain (field, UBOUND_SUBFIELD);\n   gcc_assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n-\t\t     tmp, field, NULL_TREE);\n+  tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t tmp, field, NULL_TREE);\n   return tmp;\n }\n \n@@ -400,14 +403,18 @@ gfc_conv_shift_descriptor_lbound (stmtblock_t* block, tree desc,\n   stride = gfc_conv_descriptor_stride_get (desc, gfc_rank_cst[dim]);\n \n   /* Get difference (new - old) by which to shift stuff.  */\n-  diff = fold_build2 (MINUS_EXPR, gfc_array_index_type, new_lbound, lbound);\n+  diff = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t  new_lbound, lbound);\n \n   /* Shift ubound and offset accordingly.  This has to be done before\n      updating the lbound, as they depend on the lbound expression!  */\n-  ubound = fold_build2 (PLUS_EXPR, gfc_array_index_type, ubound, diff);\n+  ubound = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t    ubound, diff);\n   gfc_conv_descriptor_ubound_set (block, desc, gfc_rank_cst[dim], ubound);\n-  offs_diff = fold_build2 (MULT_EXPR, gfc_array_index_type, diff, stride);\n-  offs = fold_build2 (MINUS_EXPR, gfc_array_index_type, offs, offs_diff);\n+  offs_diff = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t       diff, stride);\n+  offs = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t  offs, offs_diff);\n   gfc_conv_descriptor_offset_set (block, desc, offs);\n \n   /* Finally set lbound to value we want.  */\n@@ -575,7 +582,8 @@ gfc_set_loop_bounds_from_array_spec (gfc_interface_mapping * mapping,\n \t    upper = fold_convert (gfc_array_index_type, tmpse.expr);\n \n \t    /* Set the upper bound of the loop to UPPER - LOWER.  */\n-\t    tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, upper, lower);\n+\t    tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t   gfc_array_index_type, upper, lower);\n \t    tmp = gfc_evaluate_now (tmp, &se->pre);\n \t    se->loop->to[n] = tmp;\n \t  }\n@@ -621,8 +629,8 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n       if (onstack)\n \t{\n \t  /* Make a temporary variable to hold the data.  */\n-\t  tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (nelem), nelem,\n-\t\t\t     gfc_index_one_node);\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR, TREE_TYPE (nelem),\n+\t\t\t\t nelem, gfc_index_one_node);\n \t  tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node,\n \t\t\t\t  tmp);\n \t  tmp = build_array_type (gfc_get_element_type (TREE_TYPE (desc)),\n@@ -673,8 +681,9 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n \t      tmp = gfc_build_memcpy_call (packed, source_data, size);\n \t      gfc_add_expr_to_block (&do_copying, tmp);\n \n-\t      was_packed = fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t\t\tpacked, source_data);\n+\t      was_packed = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t\t\t    boolean_type_node, packed,\n+\t\t\t\t\t    source_data);\n \t      tmp = gfc_finish_block (&do_copying);\n \t      tmp = build3_v (COND_EXPR, was_packed, tmp,\n \t\t\t      build_empty_stmt (input_location));\n@@ -743,8 +752,8 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n       n = loop->order[dim];\n       /* Callee allocated arrays may not have a known bound yet.  */\n       if (loop->to[n])\n-\tloop->to[n] = gfc_evaluate_now (fold_build2 (MINUS_EXPR,\n-\t\t\t\t\tgfc_array_index_type,\n+\tloop->to[n] = gfc_evaluate_now (fold_build2_loc (input_location,\n+\t\t\t\t\tMINUS_EXPR, gfc_array_index_type,\n \t\t\t\t\tloop->to[n], loop->from[n]), pre);\n       loop->from[n] = gfc_index_zero_node;\n \n@@ -801,7 +810,7 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n \t{\n \t  /* For a callee allocated array express the loop bounds in terms\n \t     of the descriptor fields.  */\n-\t  tmp = fold_build2 (\n+\t  tmp = fold_build2_loc (input_location,\n \t\tMINUS_EXPR, gfc_array_index_type,\n \t\tgfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[dim]),\n \t\tgfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[dim]));\n@@ -818,20 +827,22 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n       gfc_conv_descriptor_ubound_set (pre, desc, gfc_rank_cst[dim],\n \t\t\t\t      loop->to[n]);\n \n-      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t loop->to[n], gfc_index_one_node);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     loop->to[n], gfc_index_one_node);\n \n       /* Check whether the size for this dimension is negative.  */\n-      cond = fold_build2 (LE_EXPR, boolean_type_node, tmp,\n-\t\t\t  gfc_index_zero_node);\n+      cond = fold_build2_loc (input_location, LE_EXPR, boolean_type_node, tmp,\n+\t\t\t      gfc_index_zero_node);\n       cond = gfc_evaluate_now (cond, pre);\n \n       if (n == 0)\n \tor_expr = cond;\n       else\n-\tor_expr = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, or_expr, cond);\n+\tor_expr = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t\t   boolean_type_node, or_expr, cond);\n \n-      size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, tmp);\n+      size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t      size, tmp);\n       size = gfc_evaluate_now (size, pre);\n     }\n \n@@ -841,11 +852,12 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n     {\n       /* If or_expr is true, then the extent in at least one\n \t dimension is zero and the size is set to zero.  */\n-      size = fold_build3 (COND_EXPR, gfc_array_index_type,\n-\t\t\t  or_expr, gfc_index_zero_node, size);\n+      size = fold_build3_loc (input_location, COND_EXPR, gfc_array_index_type,\n+\t\t\t      or_expr, gfc_index_zero_node, size);\n \n       nelem = size;\n-      size = fold_build2 (MULT_EXPR, gfc_array_index_type, size,\n+      size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\tsize,\n \t\tfold_convert (gfc_array_index_type,\n \t\t\t      TYPE_SIZE_UNIT (gfc_get_element_type (type))));\n     }\n@@ -929,7 +941,7 @@ gfc_conv_array_transpose (gfc_se * se, gfc_expr * expr)\n         {\n \t  gcc_assert (integer_zerop (loop->from[n]));\n \t  loop->to[n] =\n-\t    fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t    fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n \t\t\t gfc_conv_descriptor_ubound_get (dest, dest_index),\n \t\t\t gfc_conv_descriptor_lbound_get (dest, dest_index));\n         }\n@@ -965,10 +977,12 @@ gfc_get_iteration_count (tree start, tree end, tree step)\n   tree type;\n \n   type = TREE_TYPE (step);\n-  tmp = fold_build2 (MINUS_EXPR, type, end, start);\n-  tmp = fold_build2 (FLOOR_DIV_EXPR, type, tmp, step);\n-  tmp = fold_build2 (PLUS_EXPR, type, tmp, build_int_cst (type, 1));\n-  tmp = fold_build2 (MAX_EXPR, type, tmp, build_int_cst (type, 0));\n+  tmp = fold_build2_loc (input_location, MINUS_EXPR, type, end, start);\n+  tmp = fold_build2_loc (input_location, FLOOR_DIV_EXPR, type, tmp, step);\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, type, tmp,\n+\t\t\t build_int_cst (type, 1));\n+  tmp = fold_build2_loc (input_location, MAX_EXPR, type, tmp,\n+\t\t\t build_int_cst (type, 0));\n   return fold_convert (gfc_array_index_type, tmp);\n }\n \n@@ -989,19 +1003,20 @@ gfc_grow_array (stmtblock_t * pblock, tree desc, tree extra)\n   ubound = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[0]);\n \n   /* Add EXTRA to the upper bound.  */\n-  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type, ubound, extra);\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t ubound, extra);\n   gfc_conv_descriptor_ubound_set (pblock, desc, gfc_rank_cst[0], tmp);\n \n   /* Get the value of the current data pointer.  */\n   arg0 = gfc_conv_descriptor_data_get (desc);\n \n   /* Calculate the new array size.  */\n   size = TYPE_SIZE_UNIT (gfc_get_element_type (TREE_TYPE (desc)));\n-  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t     ubound, gfc_index_one_node);\n-  arg1 = fold_build2 (MULT_EXPR, size_type_node,\n-\t\t       fold_convert (size_type_node, tmp),\n-\t\t       fold_convert (size_type_node, size));\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t ubound, gfc_index_one_node);\n+  arg1 = fold_build2_loc (input_location, MULT_EXPR, size_type_node,\n+\t\t\t  fold_convert (size_type_node, tmp),\n+\t\t\t  fold_convert (size_type_node, size));\n \n   /* Call the realloc() function.  */\n   tmp = gfc_call_realloc (pblock, arg0, arg1);\n@@ -1132,7 +1147,8 @@ gfc_trans_array_ctor_element (stmtblock_t * pblock, tree desc,\n \n       esize = size_in_bytes (gfc_get_element_type (TREE_TYPE (desc)));\n       esize = fold_convert (gfc_charlen_type_node, esize);\n-      esize = fold_build2 (TRUNC_DIV_EXPR, gfc_charlen_type_node, esize,\n+      esize = fold_build2_loc (input_location, TRUNC_DIV_EXPR,\n+\t\t\t   gfc_charlen_type_node, esize,\n \t\t\t   build_int_cst (gfc_charlen_type_node,\n \t\t\t\t\t  gfc_character_kinds[i].bit_size / 8));\n \n@@ -1164,8 +1180,9 @@ gfc_trans_array_ctor_element (stmtblock_t * pblock, tree desc,\n \t    {\n \t      /* Verify that all constructor elements are of the same\n \t\t length.  */\n-\t      tree cond = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t       first_len_val, se->string_length);\n+\t      tree cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t\t   boolean_type_node, first_len_val,\n+\t\t\t\t\t   se->string_length);\n \t      gfc_trans_runtime_check\n \t\t(true, false, cond, &se->pre, &expr->where,\n \t\t \"Different CHARACTER lengths (%ld/%ld) in array constructor\",\n@@ -1230,7 +1247,8 @@ gfc_trans_array_constructor_subarray (stmtblock_t * pblock,\n \t{\n \t  tmp = gfc_get_iteration_count (loop.from[n], loop.to[n],\n \t\t\t\t\t gfc_index_one_node);\n-\t  size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, tmp);\n+\t  size = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t  gfc_array_index_type, size, tmp);\n \t}\n \n       /* Grow the constructed array by SIZE elements.  */\n@@ -1247,8 +1265,8 @@ gfc_trans_array_constructor_subarray (stmtblock_t * pblock,\n   gcc_assert (se.ss == gfc_ss_terminator);\n \n   /* Increment the offset.  */\n-  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t     *poffset, gfc_index_one_node);\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t *poffset, gfc_index_one_node);\n   gfc_add_modify (&body, *poffset, tmp);\n \n   /* Finish the loop.  */\n@@ -1337,8 +1355,9 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t      gfc_trans_array_ctor_element (&body, desc, *poffset,\n \t\t\t\t\t    &se, c->expr);\n \n-\t      *poffset = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t      *poffset, gfc_index_one_node);\n+\t      *poffset = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\t  gfc_array_index_type,\n+\t\t\t\t\t  *poffset, gfc_index_one_node);\n \t    }\n \t  else\n \t    {\n@@ -1406,8 +1425,8 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t\t\t\t     tmp, init, bound);\n \t      gfc_add_expr_to_block (&body, tmp);\n \n-\t      *poffset = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t      *poffset,\n+\t      *poffset = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t      gfc_array_index_type, *poffset,\n \t\t\t\t      build_int_cst (gfc_array_index_type, n));\n \t    }\n \t  if (!INTEGER_CST_P (*poffset))\n@@ -1471,7 +1490,8 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t      tmp2 = gfc_conv_mpz_to_tree (size, gfc_index_integer_kind);\n \n \t      /* Grow the array by TMP * TMP2 elements.  */\n-\t      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, tmp, tmp2);\n+\t      tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t     gfc_array_index_type, tmp, tmp2);\n \t      gfc_grow_array (&implied_do_block, desc, tmp);\n \t    }\n \n@@ -1482,13 +1502,14 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t  /* Generate the exit condition.  Depending on the sign of\n \t     the step variable we have to generate the correct\n \t     comparison.  */\n-\t  tmp = fold_build2 (GT_EXPR, boolean_type_node, step, \n-\t\t\t     build_int_cst (TREE_TYPE (step), 0));\n-\t  cond = fold_build3 (COND_EXPR, boolean_type_node, tmp,\n-\t\t\t      fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t\t\t   shadow_loopvar, end),\n-\t\t\t      fold_build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t\t   shadow_loopvar, end));\n+\t  tmp = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t\t\t\t step, build_int_cst (TREE_TYPE (step), 0));\n+\t  cond = fold_build3_loc (input_location, COND_EXPR,\n+\t\t      boolean_type_node, tmp,\n+\t\t      fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t       boolean_type_node, shadow_loopvar, end),\n+\t\t      fold_build2_loc (input_location, LT_EXPR,\n+\t\t\t\t       boolean_type_node, shadow_loopvar, end));\n \t  tmp = build1_v (GOTO_EXPR, exit_label);\n \t  TREE_USED (exit_label) = 1;\n \t  tmp = build3_v (COND_EXPR, cond, tmp,\n@@ -1499,7 +1520,9 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t  gfc_add_expr_to_block (&body, loopbody);\n \n \t  /* Increase loop variable by step.  */\n-\t  tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (shadow_loopvar), shadow_loopvar, step);\n+\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t TREE_TYPE (shadow_loopvar), shadow_loopvar,\n+\t\t\t\t step);\n \t  gfc_add_modify (&body, shadow_loopvar, tmp);\n \n \t  /* Finish the loop.  */\n@@ -1830,14 +1853,16 @@ constant_array_constructor_loop_size (gfc_loopinfo * loop)\n \t  /* Only allow nonzero \"from\" in one-dimensional arrays.  */\n \t  if (loop->dimen != 1)\n \t    return NULL_TREE;\n-\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t     loop->to[i], loop->from[i]);\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t loop->to[i], loop->from[i]);\n \t}\n       else\n \ttmp = loop->to[i];\n-      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t tmp, gfc_index_one_node);\n-      size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, tmp);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     tmp, gfc_index_one_node);\n+      size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t      size, tmp);\n     }\n \n   return size;\n@@ -1929,8 +1954,9 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss, locus * where)\n \tloop->from[n] = gfc_index_zero_node;\n \tloop->to[n] = gfc_conv_mpz_to_tree (ss->expr->shape [n],\n \t\t\t\t\t    gfc_index_integer_kind);\n-\tloop->to[n] = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t   loop->to[n], gfc_index_one_node);\n+\tloop->to[n] = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t  \t       gfc_array_index_type,\n+\t\t\t\t       loop->to[n], gfc_index_one_node);\n       }\n     }\n \n@@ -2034,7 +2060,8 @@ gfc_set_vector_loop_bounds (gfc_loopinfo * loop, gfc_ss_info * info)\n \t  gfc_init_se (&se, NULL);\n \t  desc = info->subscript[dim]->data.info.descriptor;\n \t  zero = gfc_rank_cst[0];\n-\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t     gfc_array_index_type,\n \t\t\t     gfc_conv_descriptor_ubound_get (desc, zero),\n \t\t\t     gfc_conv_descriptor_lbound_get (desc, zero));\n \t  tmp = gfc_evaluate_now (tmp, &loop->pre);\n@@ -2391,12 +2418,14 @@ gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n,\n \tasprintf (&msg, \"Index '%%ld' of dimension %d \"\n \t\t  \"outside of expected range (%%ld:%%ld)\", n+1);\n \n-      fault = fold_build2 (LT_EXPR, boolean_type_node, index, tmp_lo);\n+      fault = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t       index, tmp_lo);\n       gfc_trans_runtime_check (true, false, fault, &se->pre, where, msg,\n \t\t\t       fold_convert (long_integer_type_node, index),\n \t\t\t       fold_convert (long_integer_type_node, tmp_lo),\n \t\t\t       fold_convert (long_integer_type_node, tmp_up));\n-      fault = fold_build2 (GT_EXPR, boolean_type_node, index, tmp_up);\n+      fault = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t\t\t       index, tmp_up);\n       gfc_trans_runtime_check (true, false, fault, &se->pre, where, msg,\n \t\t\t       fold_convert (long_integer_type_node, index),\n \t\t\t       fold_convert (long_integer_type_node, tmp_lo),\n@@ -2414,7 +2443,8 @@ gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n,\n \tasprintf (&msg, \"Index '%%ld' of dimension %d \"\n \t\t  \"below lower bound of %%ld\", n+1);\n \n-      fault = fold_build2 (LT_EXPR, boolean_type_node, index, tmp_lo);\n+      fault = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t       index, tmp_lo);\n       gfc_trans_runtime_check (true, false, fault, &se->pre, where, msg,\n \t\t\t       fold_convert (long_integer_type_node, index),\n \t\t\t       fold_convert (long_integer_type_node, tmp_lo));\n@@ -2463,12 +2493,14 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n \t  desc = info->subscript[dim]->data.info.descriptor;\n \n \t  /* Get a zero-based index into the vector.  */\n-\t  index = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t       se->loop->loopvar[i], se->loop->from[i]);\n+\t  index = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t   gfc_array_index_type,\n+\t\t\t\t   se->loop->loopvar[i], se->loop->from[i]);\n \n \t  /* Multiply the index by the stride.  */\n-\t  index = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t       index, gfc_conv_array_stride (desc, 0));\n+\t  index = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t   gfc_array_index_type,\n+\t\t\t\t   index, gfc_conv_array_stride (desc, 0));\n \n \t  /* Read the vector to get an index into info->descriptor.  */\n \t  data = build_fold_indirect_ref_loc (input_location,\n@@ -2491,11 +2523,13 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n \t  /* Multiply the loop variable by the stride and delta.  */\n \t  index = se->loop->loopvar[i];\n \t  if (!integer_onep (info->stride[dim]))\n-\t    index = fold_build2 (MULT_EXPR, gfc_array_index_type, index,\n-\t\t\t\t info->stride[dim]);\n+\t    index = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t     gfc_array_index_type, index,\n+\t\t\t\t     info->stride[dim]);\n \t  if (!integer_zerop (info->delta[dim]))\n-\t    index = fold_build2 (PLUS_EXPR, gfc_array_index_type, index,\n-\t\t\t\t info->delta[dim]);\n+\t    index = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t     gfc_array_index_type, index,\n+\t\t\t\t     info->delta[dim]);\n \t  break;\n \n \tdefault:\n@@ -2508,13 +2542,14 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n       gcc_assert (se->loop);\n       index = se->loop->loopvar[se->loop->order[i]];\n       if (!integer_zerop (info->delta[dim]))\n-\tindex = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     index, info->delta[dim]);\n+\tindex = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, index, info->delta[dim]);\n     }\n \n   /* Multiply by the stride.  */\n   if (!integer_onep (stride))\n-    index = fold_build2 (MULT_EXPR, gfc_array_index_type, index, stride);\n+    index = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t     index, stride);\n \n   return index;\n }\n@@ -2542,7 +2577,8 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n   /* Add the offset for this dimension to the stored offset for all other\n      dimensions.  */\n   if (!integer_zerop (info->offset))\n-    index = fold_build2 (PLUS_EXPR, gfc_array_index_type, index, info->offset);\n+    index = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     index, info->offset);\n \n   if (se->ss->expr && is_subref_array (se->ss->expr))\n     decl = se->ss->expr->symtree->n.sym->backend_decl;\n@@ -2621,8 +2657,8 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n \t      tmp = tmpse.expr;\n \t    }\n \n-\t  cond = fold_build2 (LT_EXPR, boolean_type_node, \n-\t\t\t      indexse.expr, tmp);\n+\t  cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, \n+\t\t\t\t  indexse.expr, tmp);\n \t  asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n \t\t    \"below lower bound of %%ld\", n+1, sym->name);\n \t  gfc_trans_runtime_check (true, false, cond, &se->pre, where, msg,\n@@ -2645,8 +2681,8 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n \t\t  tmp = tmpse.expr;\n \t\t}\n \n-\t      cond = fold_build2 (GT_EXPR, boolean_type_node, \n-\t\t\t\t  indexse.expr, tmp);\n+\t      cond = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t      boolean_type_node, indexse.expr, tmp);\n \t      asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n \t\t\t\"above upper bound of %%ld\", n+1, sym->name);\n \t      gfc_trans_runtime_check (true, false, cond, &se->pre, where, msg,\n@@ -2659,16 +2695,18 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n \n       /* Multiply the index by the stride.  */\n       stride = gfc_conv_array_stride (se->expr, n);\n-      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, indexse.expr,\n-\t\t\t stride);\n+      tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t     indexse.expr, stride);\n \n       /* And add it to the total.  */\n-      index = fold_build2 (PLUS_EXPR, gfc_array_index_type, index, tmp);\n+      index = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t       gfc_array_index_type, index, tmp);\n     }\n \n   tmp = gfc_conv_array_offset (se->expr);\n   if (!integer_zerop (tmp))\n-    index = fold_build2 (PLUS_EXPR, gfc_array_index_type, index, tmp);\n+    index = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t     gfc_array_index_type, index, tmp);\n \n   /* Access the calculated element.  */\n   tmp = gfc_conv_array_data (se->expr);\n@@ -2729,8 +2767,9 @@ gfc_trans_preloop_setup (gfc_loopinfo * loop, int dim, int flag,\n \t\t\t\t\t\t       stride);\n \t\t  gfc_add_block_to_block (pblock, &se.pre);\n \n-\t\t  info->offset = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t\t      info->offset, index);\n+\t\t  info->offset = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\t\t  gfc_array_index_type,\n+\t\t\t\t\t\t  info->offset, index);\n \t\t  info->offset = gfc_evaluate_now (info->offset, pblock);\n \t\t}\n \n@@ -2768,8 +2807,9 @@ gfc_trans_preloop_setup (gfc_loopinfo * loop, int dim, int flag,\n \t  index = gfc_conv_array_index_offset (&se, info, info->dim[i], i,\n \t\t\t\t\t       ar, stride);\n \t  gfc_add_block_to_block (pblock, &se.pre);\n-\t  info->offset = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t      info->offset, index);\n+\t  info->offset = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\t  gfc_array_index_type, info->offset,\n+\t\t\t\t\t  index);\n \t  info->offset = gfc_evaluate_now (info->offset, pblock);\n \t}\n \n@@ -2869,7 +2909,7 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n       /* Increment the loopvar.  */\n       tmp = build2 (PLUS_EXPR, gfc_array_index_type,\n \t  loop->loopvar[n], gfc_index_one_node);\n-      TREE_VEC_ELT (incr, 0) = fold_build2 (MODIFY_EXPR,\n+      TREE_VEC_ELT (incr, 0) = fold_build2_loc (input_location, MODIFY_EXPR,\n \t  void_type_node, loop->loopvar[n], tmp);\n       OMP_FOR_INCR (stmt) = incr;\n \n@@ -2900,7 +2940,7 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n       gfc_init_block (&block);\n \n       /* The exit condition.  */\n-      cond = fold_build2 (reverse_loop ? LT_EXPR : GT_EXPR,\n+      cond = fold_build2_loc (input_location, reverse_loop ? LT_EXPR : GT_EXPR,\n \t\t\t  boolean_type_node, loop->loopvar[n], loop->to[n]);\n       tmp = build1_v (GOTO_EXPR, exit_label);\n       TREE_USED (exit_label) = 1;\n@@ -2911,9 +2951,10 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n       gfc_add_expr_to_block (&block, loopbody);\n \n       /* Increment the loopvar.  */\n-      tmp = fold_build2 (reverse_loop ? MINUS_EXPR : PLUS_EXPR,\n-\t\t\t gfc_array_index_type, loop->loopvar[n],\n-\t\t\t gfc_index_one_node);\n+      tmp = fold_build2_loc (input_location,\n+\t\t\t     reverse_loop ? MINUS_EXPR : PLUS_EXPR,\n+\t\t\t     gfc_array_index_type, loop->loopvar[n],\n+\t\t\t     gfc_index_one_node);\n \n       gfc_add_modify (&block, loop->loopvar[n], tmp);\n \n@@ -3230,8 +3271,8 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\tcheck_upper = true;\n \n \t      /* Zero stride is not allowed.  */\n-\t      tmp = fold_build2 (EQ_EXPR, boolean_type_node, info->stride[dim],\n-\t\t\t\t gfc_index_zero_node);\n+\t      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t     info->stride[dim], gfc_index_zero_node);\n \t      asprintf (&msg, \"Zero stride is not allowed, for dimension %d \"\n \t\t\t\"of array '%s'\", dim + 1, ss->expr->symtree->name);\n \t      gfc_trans_runtime_check (true, false, tmp, &inner,\n@@ -3252,36 +3293,44 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \n \t      /* non_zerosized is true when the selected range is not\n \t\t empty.  */\n-\t      stride_pos = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t\t\tinfo->stride[dim], gfc_index_zero_node);\n-\t      tmp = fold_build2 (LE_EXPR, boolean_type_node, info->start[dim],\n-\t\t\t\t end);\n-\t      stride_pos = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t\tstride_pos, tmp);\n-\n-\t      stride_neg = fold_build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t\tinfo->stride[dim], gfc_index_zero_node);\n-\t      tmp = fold_build2 (GE_EXPR, boolean_type_node, info->start[dim],\n-\t\t\t\t end);\n-\t      stride_neg = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t\tstride_neg, tmp);\n-\t      non_zerosized = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t\t\t   stride_pos, stride_neg);\n+\t      stride_pos = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t\tboolean_type_node, info->stride[dim],\n+\t\t\t\t\tgfc_index_zero_node);\n+\t      tmp = fold_build2_loc (input_location, LE_EXPR, boolean_type_node,\n+\t\t\t\t     info->start[dim], end);\n+\t      stride_pos = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\t\t    boolean_type_node, stride_pos, tmp);\n+\n+\t      stride_neg = fold_build2_loc (input_location, LT_EXPR,\n+\t\t\t\t     boolean_type_node,\n+\t\t\t\t     info->stride[dim], gfc_index_zero_node);\n+\t      tmp = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n+\t\t\t\t     info->start[dim], end);\n+\t      stride_neg = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\t\t    boolean_type_node,\n+\t\t\t\t\t    stride_neg, tmp);\n+\t      non_zerosized = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t\t\t       boolean_type_node,\n+\t\t\t\t\t       stride_pos, stride_neg);\n \n \t      /* Check the start of the range against the lower and upper\n \t\t bounds of the array, if the range is not empty. \n \t         If upper bound is present, include both bounds in the \n \t\t error message.  */\n \t      if (check_upper)\n \t\t{\n-\t\t  tmp = fold_build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t     info->start[dim], lbound);\n-\t\t  tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t     non_zerosized, tmp);\n-\t\t  tmp2 = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t\t      info->start[dim], ubound);\n-\t\t  tmp2 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t      non_zerosized, tmp2);\n+\t\t  tmp = fold_build2_loc (input_location, LT_EXPR,\n+\t\t\t\t\t boolean_type_node,\n+\t\t\t\t\t info->start[dim], lbound);\n+\t\t  tmp = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\t\t boolean_type_node,\n+\t\t\t\t\t non_zerosized, tmp);\n+\t\t  tmp2 = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t\t  boolean_type_node,\n+\t\t\t\t\t  info->start[dim], ubound);\n+\t\t  tmp2 = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\t\t  boolean_type_node,\n+\t\t\t\t\t  non_zerosized, tmp2);\n \t\t  asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n \t\t\t    \"outside of expected range (%%ld:%%ld)\",\n \t\t\t    dim + 1, ss->expr->symtree->name);\n@@ -3299,10 +3348,11 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t}\n \t      else\n \t\t{\n-\t\t  tmp = fold_build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t     info->start[dim], lbound);\n-\t\t  tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t     non_zerosized, tmp);\n+\t\t  tmp = fold_build2_loc (input_location, LT_EXPR,\n+\t\t\t\t\t boolean_type_node,\n+\t\t\t\t\t info->start[dim], lbound);\n+\t\t  tmp = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\t\t boolean_type_node, non_zerosized, tmp);\n \t\t  asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n \t\t\t    \"below lower bound of %%ld\",\n \t\t\t    dim + 1, ss->expr->symtree->name);\n@@ -3317,20 +3367,24 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t necessarily \"end\" (think 0:5:3, which doesn't contain 5)\n \t\t and check it against both lower and upper bounds.  */\n \n-\t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, end,\n-\t\t\t\t  info->start[dim]);\n-\t      tmp = fold_build2 (TRUNC_MOD_EXPR, gfc_array_index_type, tmp,\n-\t\t\t\t  info->stride[dim]);\n-\t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, end,\n-\t\t\t\t  tmp);\n-\t      tmp2 = fold_build2 (LT_EXPR, boolean_type_node, tmp, lbound);\n-\t      tmp2 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t non_zerosized, tmp2);\n+\t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t     gfc_array_index_type, end,\n+\t\t\t\t     info->start[dim]);\n+\t      tmp = fold_build2_loc (input_location, TRUNC_MOD_EXPR,\n+\t\t\t\t     gfc_array_index_type, tmp,\n+\t\t\t\t     info->stride[dim]);\n+\t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t     gfc_array_index_type, end, tmp);\n+\t      tmp2 = fold_build2_loc (input_location, LT_EXPR,\n+\t\t\t\t      boolean_type_node, tmp, lbound);\n+\t      tmp2 = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\t      boolean_type_node, non_zerosized, tmp2);\n \t      if (check_upper)\n \t\t{\n-\t\t  tmp3 = fold_build2 (GT_EXPR, boolean_type_node, tmp, ubound);\n-\t\t  tmp3 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t      non_zerosized, tmp3);\n+\t\t  tmp3 = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t\t  boolean_type_node, tmp, ubound);\n+\t\t  tmp3 = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\t\t  boolean_type_node, non_zerosized, tmp3);\n \t\t  asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n \t\t\t    \"outside of expected range (%%ld:%%ld)\",\n \t\t\t    dim + 1, ss->expr->symtree->name);\n@@ -3359,19 +3413,24 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t}\n \n \t      /* Check the section sizes match.  */\n-\t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, end,\n-\t\t\t\t info->start[dim]);\n-\t      tmp = fold_build2 (FLOOR_DIV_EXPR, gfc_array_index_type, tmp,\n-\t\t\t\t info->stride[dim]);\n-\t      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t gfc_index_one_node, tmp);\n-\t      tmp = fold_build2 (MAX_EXPR, gfc_array_index_type, tmp,\n-\t\t\t\t build_int_cst (gfc_array_index_type, 0));\n+\t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t     gfc_array_index_type, end,\n+\t\t\t\t     info->start[dim]);\n+\t      tmp = fold_build2_loc (input_location, FLOOR_DIV_EXPR,\n+\t\t\t\t     gfc_array_index_type, tmp,\n+\t\t\t\t     info->stride[dim]);\n+\t      tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t     gfc_array_index_type,\n+\t\t\t\t     gfc_index_one_node, tmp);\n+\t      tmp = fold_build2_loc (input_location, MAX_EXPR,\n+\t\t\t\t     gfc_array_index_type, tmp,\n+\t\t\t\t     build_int_cst (gfc_array_index_type, 0));\n \t      /* We remember the size of the first section, and check all the\n \t\t others against this.  */\n \t      if (size[n])\n \t\t{\n-\t\t  tmp3 = fold_build2 (NE_EXPR, boolean_type_node, tmp, size[n]);\n+\t\t  tmp3 = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t\t  boolean_type_node, tmp, size[n]);\n \t\t  asprintf (&msg, \"Array bound mismatch for dimension %d \"\n \t\t\t    \"of array '%s' (%%ld/%%ld)\",\n \t\t\t    dim + 1, ss->expr->symtree->name);\n@@ -3690,10 +3749,12 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t  /* To = from + (size - 1) * stride.  */\n \t  tmp = gfc_conv_mpz_to_tree (i, gfc_index_integer_kind);\n \t  if (!integer_onep (info->stride[dim]))\n-\t    tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t       tmp, info->stride[dim]);\n-\t  loop->to[n] = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t     loop->from[n], tmp);\n+\t    tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t   gfc_array_index_type, tmp,\n+\t\t\t\t   info->stride[dim]);\n+\t  loop->to[n] = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\t gfc_array_index_type,\n+\t\t\t\t\t loop->from[n], tmp);\n \t}\n       else\n \t{\n@@ -3733,12 +3794,13 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t     with start = 0, this simplifies to\n \t     last = end / step;\n \t     for (i = 0; i<=last; i++){...};  */\n-\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t     loop->to[n], loop->from[n]);\n-\t  tmp = fold_build2 (FLOOR_DIV_EXPR, gfc_array_index_type,\n-\t\t\t     tmp, info->stride[dim]);\n-\t  tmp = fold_build2 (MAX_EXPR, gfc_array_index_type, tmp,\n-\t\t\t     build_int_cst (gfc_array_index_type, -1));\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type, loop->to[n],\n+\t\t\t\t loop->from[n]);\n+\t  tmp = fold_build2_loc (input_location, FLOOR_DIV_EXPR,\n+\t\t\t\t gfc_array_index_type, tmp, info->stride[dim]);\n+\t  tmp = fold_build2_loc (input_location, MAX_EXPR, gfc_array_index_type,\n+\t\t\t\t tmp, build_int_cst (gfc_array_index_type, -1));\n \t  loop->to[n] = gfc_evaluate_now (tmp, &loop->pre);\n \t  /* Make the loop variable start at 0.  */\n \t  loop->from[n] = gfc_index_zero_node;\n@@ -3803,12 +3865,14 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t\t First multiply by the stride.  */\n \t      tmp = loop->from[n];\n \t      if (!integer_onep (info->stride[dim]))\n-\t\ttmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\t   tmp, info->stride[dim]);\n+\t\ttmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t       gfc_array_index_type,\n+\t\t\t\t       tmp, info->stride[dim]);\n \n \t      /* Then subtract this from our starting value.  */\n-\t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t info->start[dim], tmp);\n+\t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t     gfc_array_index_type,\n+\t\t\t\t     info->start[dim], tmp);\n \n \t      info->delta[dim] = gfc_evaluate_now (tmp, &loop->pre);\n \t    }\n@@ -3829,17 +3893,21 @@ gfc_conv_array_extent_dim (tree lbound, tree ubound, tree* or_expr)\n   tree cond;\n \n   /* Calculate (ubound - lbound + 1).  */\n-  res = fold_build2 (MINUS_EXPR, gfc_array_index_type, ubound, lbound);\n-  res = fold_build2 (PLUS_EXPR, gfc_array_index_type, res, gfc_index_one_node);\n+  res = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t ubound, lbound);\n+  res = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type, res,\n+\t\t\t gfc_index_one_node);\n \n   /* Check whether the size for this dimension is negative.  */\n-  cond = fold_build2 (LE_EXPR, boolean_type_node, res, gfc_index_zero_node);\n-  res = fold_build3 (COND_EXPR, gfc_array_index_type, cond,\n-\t\t      gfc_index_zero_node, res);\n+  cond = fold_build2_loc (input_location, LE_EXPR, boolean_type_node, res,\n+\t\t\t  gfc_index_zero_node);\n+  res = fold_build3_loc (input_location, COND_EXPR, gfc_array_index_type, cond,\n+\t\t\t gfc_index_zero_node, res);\n \n   /* Build OR expression.  */\n   if (or_expr)\n-    *or_expr = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, *or_expr, cond);\n+    *or_expr = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t\tboolean_type_node, *or_expr, cond);\n \n   return res;\n }\n@@ -3866,7 +3934,8 @@ gfc_conv_descriptor_size (tree desc, int rank)\n       ubound = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[dim]);\n \n       extent = gfc_conv_array_extent_dim (lbound, ubound, NULL);\n-      res = fold_build2 (MULT_EXPR, gfc_array_index_type, res, extent);\n+      res = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t     res, extent);\n     }\n \n   return res;\n@@ -3958,8 +4027,10 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n       conv_lbound = se.expr;\n \n       /* Work out the offset for this component.  */\n-      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, se.expr, stride);\n-      offset = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp);\n+      tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t     se.expr, stride);\n+      offset = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\tgfc_array_index_type, offset, tmp);\n \n       /* Set upper bound.  */\n       gfc_init_se (&se, NULL);\n@@ -3979,7 +4050,8 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n       size = gfc_conv_array_extent_dim (conv_lbound, conv_ubound, &or_expr);\n \n       /* Multiply the stride by the number of elements in this dimension.  */\n-      stride = fold_build2 (MULT_EXPR, gfc_array_index_type, stride, size);\n+      stride = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\tgfc_array_index_type, stride, size);\n       stride = gfc_evaluate_now (stride, pblock);\n     }\n \n@@ -4024,8 +4096,8 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n   /* The stride is the number of elements in the array, so multiply by the\n      size of an element to get the total size.  */\n   tmp = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n-  size = fold_build2 (MULT_EXPR, gfc_array_index_type, stride,\n-\t\t      fold_convert (gfc_array_index_type, tmp));\n+  size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t  stride, fold_convert (gfc_array_index_type, tmp));\n \n   if (poffset != NULL)\n     {\n@@ -4146,7 +4218,8 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n     tmp = gfc_allocate_array_with_status (&se->pre, pointer, size, pstat, expr);\n   else\n     tmp = gfc_allocate_with_status (&se->pre, size, pstat);\n-  tmp = fold_build2 (MODIFY_EXPR, void_type_node, pointer, tmp);\n+  tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node, pointer,\n+\t\t\t tmp);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   gfc_conv_descriptor_offset_set (&se->pre, se->expr, offset);\n@@ -4184,8 +4257,8 @@ gfc_array_deallocate (tree descriptor, tree pstat, gfc_expr* expr)\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Zero the data pointer.  */\n-  tmp = fold_build2 (MODIFY_EXPR, void_type_node,\n-\t\t     var, build_int_cst (TREE_TYPE (var), 0));\n+  tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t\t var, build_int_cst (TREE_TYPE (var), 0));\n   gfc_add_expr_to_block (&block, tmp);\n \n   return gfc_finish_block (&block);\n@@ -4338,8 +4411,10 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n           gfc_add_modify (pblock, ubound, se.expr);\n         }\n       /* The offset of this dimension.  offset = offset - lbound * stride.  */\n-      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, lbound, size);\n-      offset = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp);\n+      tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t     lbound, size);\n+      offset = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\toffset, tmp);\n \n       /* The size of this dimension, and the stride of the next.  */\n       if (dim + 1 < as->rank)\n@@ -4350,21 +4425,25 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n       if (ubound != NULL_TREE && !(stride && INTEGER_CST_P (stride)))\n         {\n           /* Calculate stride = size * (ubound + 1 - lbound).  */\n-          tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t     gfc_index_one_node, lbound);\n-          tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type, ubound, tmp);\n-          tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, size, tmp);\n+          tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t gfc_index_one_node, lbound);\n+          tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, ubound, tmp);\n+          tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t gfc_array_index_type, size, tmp);\n           if (stride)\n             gfc_add_modify (pblock, stride, tmp);\n           else\n             stride = gfc_evaluate_now (tmp, pblock);\n \n \t  /* Make sure that negative size arrays are translated\n \t     to being zero size.  */\n-\t  tmp = fold_build2 (GE_EXPR, boolean_type_node,\n-\t\t\t     stride, gfc_index_zero_node);\n-\t  tmp = fold_build3 (COND_EXPR, gfc_array_index_type, tmp,\n-\t\t\t     stride, gfc_index_zero_node);\n+\t  tmp = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n+\t\t\t\t stride, gfc_index_zero_node);\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t gfc_array_index_type, tmp,\n+\t\t\t\t stride, gfc_index_zero_node);\n \t  gfc_add_modify (pblock, stride, tmp);\n         }\n \n@@ -4413,7 +4492,7 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym,\n \n       /* Emit a DECL_EXPR for this variable, which will cause the\n \t gimplifier to allocate storage, and all that good stuff.  */\n-      tmp = fold_build1 (DECL_EXPR, TREE_TYPE (decl), decl);\n+      tmp = fold_build1_loc (input_location, DECL_EXPR, TREE_TYPE (decl), decl);\n       gfc_add_expr_to_block (&init, tmp);\n     }\n \n@@ -4448,8 +4527,8 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym,\n   /* The size is the number of elements in the array, so multiply by the\n      size of an element to get the total size.  */\n   tmp = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n-  size = fold_build2 (MULT_EXPR, gfc_array_index_type, size,\n-\t\t      fold_convert (gfc_array_index_type, tmp));\n+  size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t  size, fold_convert (gfc_array_index_type, tmp));\n \n   /* Allocate memory to hold the data.  */\n   tmp = gfc_call_malloc (&init, TREE_TYPE (decl), size);\n@@ -4600,7 +4679,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n       partial = gfc_create_var (boolean_type_node, \"partial\");\n       TREE_USED (partial) = 1;\n       tmp = gfc_conv_descriptor_stride_get (dumdesc, gfc_rank_cst[0]);\n-      tmp = fold_build2 (EQ_EXPR, boolean_type_node, tmp, gfc_index_one_node);\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, tmp,\n+\t\t\t     gfc_index_one_node);\n       gfc_add_modify (&init, partial, tmp);\n     }\n   else\n@@ -4614,10 +4694,10 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n       stride = gfc_conv_descriptor_stride_get (dumdesc, gfc_rank_cst[0]);\n       stride = gfc_evaluate_now (stride, &init);\n \n-      tmp = fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t stride, gfc_index_zero_node);\n-      tmp = fold_build3 (COND_EXPR, gfc_array_index_type, tmp,\n-\t\t\t gfc_index_one_node, stride);\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t     stride, gfc_index_zero_node);\n+      tmp = fold_build3_loc (input_location, COND_EXPR, gfc_array_index_type,\n+\t\t\t     tmp, gfc_index_one_node, stride);\n       stride = GFC_TYPE_ARRAY_STRIDE (type, 0);\n       gfc_add_modify (&init, stride, tmp);\n \n@@ -4649,8 +4729,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n   if (stmt_packed != NULL_TREE && stmt_unpacked != NULL_TREE)\n     {\n       /* Don't repack unknown shape arrays when the first stride is 1.  */\n-      tmp = fold_build3 (COND_EXPR, TREE_TYPE (stmt_packed),\n-\t\t\t partial, stmt_packed, stmt_unpacked);\n+      tmp = fold_build3_loc (input_location, COND_EXPR, TREE_TYPE (stmt_packed),\n+\t\t\t     partial, stmt_packed, stmt_unpacked);\n     }\n   else\n     tmp = stmt_packed != NULL_TREE ? stmt_packed : stmt_unpacked;\n@@ -4705,17 +4785,19 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n \t      char * msg;\n \t      tree temp;\n \n-\t      temp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t  ubound, lbound);\n-\t      temp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t  gfc_index_one_node, temp);\n-\n-\t      stride2 = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t     dubound, dlbound);\n-\t      stride2 = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t     gfc_index_one_node, stride2);\n-\n-\t      tmp = fold_build2 (NE_EXPR, gfc_array_index_type, temp, stride2);\n+\t      temp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t      gfc_array_index_type, ubound, lbound);\n+\t      temp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t      gfc_array_index_type,\n+\t\t\t\t      gfc_index_one_node, temp);\n+\t      stride2 = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t\t gfc_array_index_type, dubound,\n+\t\t\t\t\t dlbound);\n+\t      stride2 = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\t gfc_array_index_type,\n+\t\t\t\t\t gfc_index_one_node, stride2);\n+\t      tmp = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t     gfc_array_index_type, temp, stride2);\n \t      asprintf (&msg, \"Dimension %d of array '%s' has extent \"\n \t\t\t\"%%ld instead of %%ld\", n+1, sym->name);\n \n@@ -4730,14 +4812,17 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n \t{\n \t  /* For assumed shape arrays move the upper bound by the same amount\n \t     as the lower bound.  */\n-\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t     dubound, dlbound);\n-\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type, tmp, lbound);\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type, dubound, dlbound);\n+\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, tmp, lbound);\n \t  gfc_add_modify (&init, ubound, tmp);\n \t}\n       /* The offset of this dimension.  offset = offset - lbound * stride.  */\n-      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, lbound, stride);\n-      offset = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp);\n+      tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t     lbound, stride);\n+      offset = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\tgfc_array_index_type, offset, tmp);\n \n       /* The size of this dimension, and the stride of the next.  */\n       if (n + 1 < sym->as->rank)\n@@ -4756,19 +4841,21 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n \t      else\n \t\t{\n \t\t  /* Calculate stride = size * (ubound + 1 - lbound).  */\n-\t\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t     gfc_index_one_node, lbound);\n-\t\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t     ubound, tmp);\n-\t\t  size = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\t      size, tmp);\n+\t\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t\t gfc_array_index_type,\n+\t\t\t\t\t gfc_index_one_node, lbound);\n+\t\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\t gfc_array_index_type, ubound, tmp);\n+\t\t  size = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t\t  gfc_array_index_type, size, tmp);\n \t\t  stmt_packed = size;\n \t\t}\n \n \t      /* Assign the stride.  */\n \t      if (stmt_packed != NULL_TREE && stmt_unpacked != NULL_TREE)\n-\t\ttmp = fold_build3 (COND_EXPR, gfc_array_index_type, partial,\n-\t\t\t\t   stmt_unpacked, stmt_packed);\n+\t\ttmp = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t       gfc_array_index_type, partial,\n+\t\t\t\t       stmt_unpacked, stmt_packed);\n \t      else\n \t\ttmp = (stmt_packed != NULL_TREE) ? stmt_packed : stmt_unpacked;\n \t      gfc_add_modify (&init, stride, tmp);\n@@ -4781,12 +4868,15 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n \t  if (stride && !INTEGER_CST_P (stride))\n \t    {\n \t      /* Calculate size = stride * (ubound + 1 - lbound).  */\n-\t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t gfc_index_one_node, lbound);\n-\t      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t ubound, tmp);\n-\t      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\t GFC_TYPE_ARRAY_STRIDE (type, n), tmp);\n+\t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t     gfc_array_index_type,\n+\t\t\t\t     gfc_index_one_node, lbound);\n+\t      tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t     gfc_array_index_type,\n+\t\t\t\t     ubound, tmp);\n+\t      tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t     gfc_array_index_type,\n+\t\t\t\t     GFC_TYPE_ARRAY_STRIDE (type, n), tmp);\n \t      gfc_add_modify (&init, stride, tmp);\n \t    }\n \t}\n@@ -4837,7 +4927,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n       /* Only do the cleanup if the array was repacked.  */\n       tmp = build_fold_indirect_ref_loc (input_location, dumdesc);\n       tmp = gfc_conv_descriptor_data_get (tmp);\n-      tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp, tmpdesc);\n+      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t     tmp, tmpdesc);\n       stmtCleanup = build3_v (COND_EXPR, tmp, stmtCleanup,\n \t\t\t      build_empty_stmt (input_location));\n \n@@ -4904,8 +4995,9 @@ gfc_get_dataptr_offset (stmtblock_t *block, tree parm, tree desc, tree offset,\n \t    case REF_COMPONENT:\n \t      field = ref->u.c.component->backend_decl;\n \t      gcc_assert (field && TREE_CODE (field) == FIELD_DECL);\n-\t      tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n-\t\t\t\t tmp, field, NULL_TREE);\n+\t      tmp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t     TREE_TYPE (field),\n+\t\t\t\t     tmp, field, NULL_TREE);\n \t      break;\n \n \t    case REF_SUBSTRING:\n@@ -4935,18 +5027,25 @@ gfc_get_dataptr_offset (stmtblock_t *block, tree parm, tree desc, tree offset,\n \t\t  gfc_init_se (&start, NULL);\n \t\t  gfc_conv_expr_type (&start, ref->u.ar.as->lower[n], gfc_array_index_type);\n \t\t  jtmp = gfc_evaluate_now (start.expr, block);\n-\t\t  itmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, itmp, jtmp);\n-\t\t  itmp = fold_build2 (MULT_EXPR, gfc_array_index_type, itmp, stride);\n-\t\t  index = fold_build2 (PLUS_EXPR, gfc_array_index_type, itmp, index);\n+\t\t  itmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t\t  gfc_array_index_type, itmp, jtmp);\n+\t\t  itmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t\t  gfc_array_index_type, itmp, stride);\n+\t\t  index = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\t  gfc_array_index_type, itmp, index);\n \t\t  index = gfc_evaluate_now (index, block);\n \n \t\t  /* Update the stride.  */\n \t\t  gfc_init_se (&start, NULL);\n \t\t  gfc_conv_expr_type (&start, ref->u.ar.as->upper[n], gfc_array_index_type);\n-\t\t  itmp =  fold_build2 (MINUS_EXPR, gfc_array_index_type, start.expr, jtmp);\n-\t\t  itmp =  fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t       gfc_index_one_node, itmp);\n-\t\t  stride =  fold_build2 (MULT_EXPR, gfc_array_index_type, stride, itmp);\n+\t\t  itmp =  fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t\t   gfc_array_index_type, start.expr,\n+\t\t\t\t\t   jtmp);\n+\t\t  itmp =  fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\t   gfc_array_index_type,\n+\t\t\t\t\t   gfc_index_one_node, itmp);\n+\t\t  stride =  fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t\t     gfc_array_index_type, stride, itmp);\n \t\t  stride = gfc_evaluate_now (stride, block);\n \t\t}\n \n@@ -5010,7 +5109,8 @@ get_array_charlen (gfc_expr *expr, gfc_se *se)\n \t  /* Add the string lengths and assign them to the expression\n \t     string length backend declaration.  */\n \t  gfc_add_modify (&se->pre, expr->ts.u.cl->backend_decl,\n-\t\t\t  fold_build2 (PLUS_EXPR, gfc_charlen_type_node,\n+\t\t\t  fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\tgfc_charlen_type_node,\n \t\t\t\texpr->value.op.op1->ts.u.cl->backend_decl,\n \t\t\t\texpr->value.op.op2->ts.u.cl->backend_decl));\n \t}\n@@ -5051,8 +5151,9 @@ get_array_charlen (gfc_expr *expr, gfc_se *se)\n       gfc_add_block_to_block (&se->pre, &tse.pre);\n       gfc_add_block_to_block (&se->post, &tse.post);\n       tse.expr = fold_convert (gfc_charlen_type_node, tse.expr);\n-      tse.expr = fold_build2 (MAX_EXPR, gfc_charlen_type_node, tse.expr,\n-\t\t\t      build_int_cst (gfc_charlen_type_node, 0));\n+      tse.expr = fold_build2_loc (input_location, MAX_EXPR,\n+\t\t\t\t  gfc_charlen_type_node, tse.expr,\n+\t\t\t\t  build_int_cst (gfc_charlen_type_node, 0));\n       expr->ts.u.cl->backend_decl = tse.expr;\n       gfc_free_interface_mapping (&mapping);\n       break;\n@@ -5416,10 +5517,12 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t    }\n \n \t  tmp = gfc_conv_array_lbound (desc, n);\n-\t  tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (tmp), start, tmp);\n-\n-\t  tmp = fold_build2 (MULT_EXPR, TREE_TYPE (tmp), tmp, stride);\n-\t  offset = fold_build2 (PLUS_EXPR, TREE_TYPE (tmp), offset, tmp);\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR, TREE_TYPE (tmp),\n+\t\t\t\t start, tmp);\n+\t  tmp = fold_build2_loc (input_location, MULT_EXPR, TREE_TYPE (tmp),\n+\t\t\t\t tmp, stride);\n+\t  offset = fold_build2_loc (input_location, PLUS_EXPR, TREE_TYPE (tmp),\n+\t\t\t\t    offset, tmp);\n \n \t  if (info->ref\n \t      && info->ref->u.ar.dimen_type[n] == DIMEN_ELEMENT)\n@@ -5443,9 +5546,11 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t          || info->ref->u.ar.type != AR_FULL)\n \t      && !integer_onep (from))\n \t    {\n-\t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t gfc_index_one_node, from);\n-\t      to = fold_build2 (PLUS_EXPR, gfc_array_index_type, to, tmp);\n+\t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t     gfc_array_index_type, gfc_index_one_node,\n+\t\t\t\t     from);\n+\t      to = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t    gfc_array_index_type, to, tmp);\n \t      from = gfc_index_one_node;\n \t    }\n \t  gfc_conv_descriptor_lbound_set (&loop.pre, parm,\n@@ -5457,25 +5562,27 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \n \t  /* Multiply the stride by the section stride to get the\n \t     total stride.  */\n-\t  stride = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\tstride, info->stride[n]);\n+\t  stride = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t    gfc_array_index_type,\n+\t\t\t\t    stride, info->stride[n]);\n \n \t  if (se->direct_byref\n \t      && info->ref\n \t      && info->ref->u.ar.type != AR_FULL)\n \t    {\n-\t      base = fold_build2 (MINUS_EXPR, TREE_TYPE (base),\n-\t\t\t\t  base, stride);\n+\t      base = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t      TREE_TYPE (base), base, stride);\n \t    }\n \t  else if (GFC_ARRAY_TYPE_P (TREE_TYPE (desc)))\n \t    {\n \t      tmp = gfc_conv_array_lbound (desc, n);\n-\t      tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (base),\n-\t\t\t\t tmp, loop.from[dim]);\n-\t      tmp = fold_build2 (MULT_EXPR, TREE_TYPE (base),\n-\t\t\t\t tmp, gfc_conv_array_stride (desc, n));\n-\t      base = fold_build2 (PLUS_EXPR, TREE_TYPE (base),\n-\t\t\t\t  tmp, base);\n+\t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t     TREE_TYPE (base), tmp, loop.from[dim]);\n+\t      tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t     TREE_TYPE (base), tmp,\n+\t\t\t\t     gfc_conv_array_stride (desc, n));\n+\t      base = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t     TREE_TYPE (base), tmp, base);\n \t    }\n \n \t  /* Store the new stride.  */\n@@ -5542,15 +5649,16 @@ array_parameter_size (tree desc, gfc_expr *expr, tree *size)\n       tree ubound = gfc_conv_descriptor_ubound_get (desc, gfc_index_zero_node);\n       tree lbound = gfc_conv_descriptor_lbound_get (desc, gfc_index_zero_node);\n \n-      *size = fold_build2 (MINUS_EXPR, gfc_array_index_type, ubound, lbound);\n-      *size = fold_build2 (PLUS_EXPR, gfc_array_index_type, *size,\n-\t\t\t   gfc_index_one_node);\n-      *size = fold_build2 (MAX_EXPR, gfc_array_index_type, *size,\n-\t\t\t   gfc_index_zero_node);\n+      *size = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t       gfc_array_index_type, ubound, lbound);\n+      *size = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t       *size, gfc_index_one_node);\n+      *size = fold_build2_loc (input_location, MAX_EXPR, gfc_array_index_type,\n+\t\t\t       *size, gfc_index_zero_node);\n     }\n   elem = TYPE_SIZE_UNIT (gfc_get_element_type (TREE_TYPE (desc)));\n-  *size = fold_build2 (MULT_EXPR, gfc_array_index_type, *size,\n-\t\t       fold_convert (gfc_array_index_type, elem));\n+  *size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t   *size, fold_convert (gfc_array_index_type, elem));\n }\n \n /* Convert an array for passing as an actual parameter.  */\n@@ -5755,8 +5863,9 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n \t  origptr = gfc_create_var (pvoid_type_node, \"origptr\");\n \t  tmp = build_fold_indirect_ref_loc (input_location, desc);\n \t  tmp = gfc_conv_array_data (tmp);\n-\t  tmp = fold_build2 (MODIFY_EXPR, TREE_TYPE (origptr), origptr,\n-\t\t\t     fold_convert (TREE_TYPE (origptr), tmp));\n+\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t TREE_TYPE (origptr), origptr,\n+\t\t\t\t fold_convert (TREE_TYPE (origptr), tmp));\n \t  gfc_add_expr_to_block (&se->pre, tmp);\n \t}\n \n@@ -5806,12 +5915,13 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n \t  tmp = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t desc);\n \t  tmp = gfc_conv_array_data (tmp);\n-\t  tmp = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t     fold_convert (TREE_TYPE (tmp), ptr), tmp);\n+\t  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t fold_convert (TREE_TYPE (tmp), ptr), tmp);\n \n \t  if (fsym && fsym->attr.optional && sym && sym->attr.optional)\n-\t    tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t       gfc_conv_expr_present (sym), tmp);\n+\t    tmp = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\t   boolean_type_node,\n+\t\t\t\t   gfc_conv_expr_present (sym), tmp);\n \n \t  gfc_trans_runtime_check (false, true, tmp, &se->pre,\n \t\t\t\t   &expr->where, msg);\n@@ -5840,12 +5950,13 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n       tmp = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t     desc);\n       tmp = gfc_conv_array_data (tmp);\n-      tmp = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t fold_convert (TREE_TYPE (tmp), ptr), tmp);\n+      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t     fold_convert (TREE_TYPE (tmp), ptr), tmp);\n \n       if (fsym && fsym->attr.optional && sym && sym->attr.optional)\n-\ttmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t   gfc_conv_expr_present (sym), tmp);\n+\ttmp = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t       boolean_type_node,\n+\t\t\t       gfc_conv_expr_present (sym), tmp);\n \n       tmp = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt (input_location));\n \n@@ -5887,8 +5998,8 @@ gfc_trans_dealloc_allocated (tree descriptor)\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Zero the data pointer.  */\n-  tmp = fold_build2 (MODIFY_EXPR, void_type_node,\n-\t\t     var, build_int_cst (TREE_TYPE (var), 0));\n+  tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t\t var, build_int_cst (TREE_TYPE (var), 0));\n   gfc_add_expr_to_block (&block, tmp);\n \n   return gfc_finish_block (&block);\n@@ -5906,13 +6017,15 @@ get_full_array_size (stmtblock_t *block, tree decl, int rank)\n   idx = gfc_rank_cst[rank - 1];\n   nelems = gfc_conv_descriptor_ubound_get (decl, idx);\n   tmp = gfc_conv_descriptor_lbound_get (decl, idx);\n-  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, nelems, tmp);\n-  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t     tmp, gfc_index_one_node);\n+  tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t nelems, tmp);\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t tmp, gfc_index_one_node);\n   tmp = gfc_evaluate_now (tmp, block);\n \n   nelems = gfc_conv_descriptor_stride_get (decl, idx);\n-  tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, nelems, tmp);\n+  tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t nelems, tmp);\n   return gfc_evaluate_now (tmp, block);\n }\n \n@@ -5921,8 +6034,8 @@ get_full_array_size (stmtblock_t *block, tree decl, int rank)\n    If no_malloc is set, only the copy is done.  */\n \n static tree\n-duplicate_allocatable(tree dest, tree src, tree type, int rank,\n-\t\t      bool no_malloc)\n+duplicate_allocatable (tree dest, tree src, tree type, int rank,\n+\t\t       bool no_malloc)\n {\n   tree tmp;\n   tree size;\n@@ -5938,7 +6051,7 @@ duplicate_allocatable(tree dest, tree src, tree type, int rank,\n   if (rank == 0)\n     {\n       tmp = null_pointer_node;\n-      tmp = fold_build2 (MODIFY_EXPR, type, dest, tmp);\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, type, dest, tmp);\n       gfc_add_expr_to_block (&block, tmp);\n       null_data = gfc_finish_block (&block);\n \n@@ -5947,8 +6060,8 @@ duplicate_allocatable(tree dest, tree src, tree type, int rank,\n       if (!no_malloc)\n \t{\n \t  tmp = gfc_call_malloc (&block, type, size);\n-\t  tmp = fold_build2 (MODIFY_EXPR, void_type_node, dest,\n-\t\t\t     fold_convert (type, tmp));\n+\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t\t\t dest, fold_convert (type, tmp));\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n \n@@ -5965,7 +6078,8 @@ duplicate_allocatable(tree dest, tree src, tree type, int rank,\n       nelems = get_full_array_size (&block, src, rank);\n       tmp = fold_convert (gfc_array_index_type,\n \t\t\t  TYPE_SIZE_UNIT (gfc_get_element_type (type)));\n-      size = fold_build2 (MULT_EXPR, gfc_array_index_type, nelems, tmp);\n+      size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t      nelems, tmp);\n       if (!no_malloc)\n \t{\n \t  tmp = TREE_TYPE (gfc_conv_descriptor_data_get (src));\n@@ -5992,8 +6106,8 @@ duplicate_allocatable(tree dest, tree src, tree type, int rank,\n     null_cond = gfc_conv_descriptor_data_get (src);\n \n   null_cond = convert (pvoid_type_node, null_cond);\n-  null_cond = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t   null_cond, null_pointer_node);\n+  null_cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t       null_cond, null_pointer_node);\n   return build3_v (COND_EXPR, null_cond, tmp, null_data);\n }\n \n@@ -6003,7 +6117,7 @@ duplicate_allocatable(tree dest, tree src, tree type, int rank,\n tree\n gfc_duplicate_allocatable (tree dest, tree src, tree type, int rank)\n {\n-  return duplicate_allocatable(dest, src, type, rank, false);\n+  return duplicate_allocatable (dest, src, type, rank, false);\n }\n \n \n@@ -6012,7 +6126,7 @@ gfc_duplicate_allocatable (tree dest, tree src, tree type, int rank)\n tree\n gfc_copy_allocatable_data (tree dest, tree src, tree type, int rank)\n {\n-  return duplicate_allocatable(dest, src, type, rank, true);\n+  return duplicate_allocatable (dest, src, type, rank, true);\n }\n \n \n@@ -6072,12 +6186,14 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t     is a full array reference, we only need the descriptor\n \t     information from dimension = rank.  */\n \t  tmp = get_full_array_size (&fnblock, decl, rank);\n-\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t     tmp, gfc_index_one_node);\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type, tmp,\n+\t\t\t\t gfc_index_one_node);\n \n \t  null_cond = gfc_conv_descriptor_data_get (decl);\n-\t  null_cond = fold_build2 (NE_EXPR, boolean_type_node, null_cond,\n-\t\t\t\t   build_int_cst (TREE_TYPE (null_cond), 0));\n+\t  null_cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t       boolean_type_node, null_cond,\n+\t\t\t\t       build_int_cst (TREE_TYPE (null_cond), 0));\n \t}\n       else\n \t{\n@@ -6153,8 +6269,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t     components.  */\n \t  if (cmp_has_alloc_comps && !c->attr.pointer)\n \t    {\n-\t      comp = fold_build3 (COMPONENT_REF, ctype,\n-\t\t\t\t  decl, cdecl, NULL_TREE);\n+\t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t      decl, cdecl, NULL_TREE);\n \t      rank = c->as ? c->as->rank : 0;\n \t      tmp = structure_alloc_comps (c->ts.u.derived, comp, NULL_TREE,\n \t\t\t\t\t   rank, purpose);\n@@ -6163,38 +6279,42 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n \t  if (c->attr.allocatable && c->attr.dimension)\n \t    {\n-\t      comp = fold_build3 (COMPONENT_REF, ctype,\n-\t\t\t\t  decl, cdecl, NULL_TREE);\n+\t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t      decl, cdecl, NULL_TREE);\n \t      tmp = gfc_trans_dealloc_allocated (comp);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n \t  else if (c->attr.allocatable)\n \t    {\n \t      /* Allocatable scalar components.  */\n-\t      comp = fold_build3 (COMPONENT_REF, ctype, decl, cdecl, NULL_TREE);\n+\t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t      decl, cdecl, NULL_TREE);\n \n \t      tmp = gfc_deallocate_with_status (comp, NULL_TREE, true, NULL);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \n-\t      tmp = fold_build2 (MODIFY_EXPR, void_type_node, comp,\n-\t\t\t\t build_int_cst (TREE_TYPE (comp), 0));\n+\t      tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t     void_type_node, comp,\n+\t\t\t\t     build_int_cst (TREE_TYPE (comp), 0));\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n \t  else if (c->ts.type == BT_CLASS && CLASS_DATA (c)->attr.allocatable)\n \t    {\n \t      /* Allocatable scalar CLASS components.  */\n-\t      comp = fold_build3 (COMPONENT_REF, ctype, decl, cdecl, NULL_TREE);\n+\t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t      decl, cdecl, NULL_TREE);\n \t      \n \t      /* Add reference to '$data' component.  */\n \t      tmp = CLASS_DATA (c)->backend_decl;\n-\t      comp = fold_build3 (COMPONENT_REF, TREE_TYPE (tmp),\n-\t\t\t\t  comp, tmp, NULL_TREE);\n+\t      comp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t      TREE_TYPE (tmp), comp, tmp, NULL_TREE);\n \n \t      tmp = gfc_deallocate_with_status (comp, NULL_TREE, true, NULL);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \n-\t      tmp = fold_build2 (MODIFY_EXPR, void_type_node, comp,\n-\t\t\t\t build_int_cst (TREE_TYPE (comp), 0));\n+\t      tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t     void_type_node, comp,\n+\t\t\t\t     build_int_cst (TREE_TYPE (comp), 0));\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n \t  break;\n@@ -6204,34 +6324,38 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t    continue;\n \t  else if (c->attr.allocatable && c->attr.dimension)\n \t    {\n-\t      comp = fold_build3 (COMPONENT_REF, ctype,\n-\t\t\t\t  decl, cdecl, NULL_TREE);\n+\t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t      decl, cdecl, NULL_TREE);\n \t      gfc_conv_descriptor_data_set (&fnblock, comp, null_pointer_node);\n \t    }\n \t  else if (c->attr.allocatable)\n \t    {\n \t      /* Allocatable scalar components.  */\n-\t      comp = fold_build3 (COMPONENT_REF, ctype, decl, cdecl, NULL_TREE);\n-\t      tmp = fold_build2 (MODIFY_EXPR, void_type_node, comp,\n-\t\t\t\t build_int_cst (TREE_TYPE (comp), 0));\n+\t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t      decl, cdecl, NULL_TREE);\n+\t      tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t     void_type_node, comp,\n+\t\t\t\t     build_int_cst (TREE_TYPE (comp), 0));\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n \t  else if (c->ts.type == BT_CLASS && CLASS_DATA (c)->attr.allocatable)\n \t    {\n \t      /* Allocatable scalar CLASS components.  */\n-\t      comp = fold_build3 (COMPONENT_REF, ctype, decl, cdecl, NULL_TREE);\n+\t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t      decl, cdecl, NULL_TREE);\n \t      /* Add reference to '$data' component.  */\n \t      tmp = CLASS_DATA (c)->backend_decl;\n-\t      comp = fold_build3 (COMPONENT_REF, TREE_TYPE (tmp),\n-\t\t\t\t  comp, tmp, NULL_TREE);\n-\t      tmp = fold_build2 (MODIFY_EXPR, void_type_node, comp,\n-\t\t\t\t build_int_cst (TREE_TYPE (comp), 0));\n+\t      comp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t      TREE_TYPE (tmp), comp, tmp, NULL_TREE);\n+\t      tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t     void_type_node, comp,\n+\t\t\t\t     build_int_cst (TREE_TYPE (comp), 0));\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n           else if (cmp_has_alloc_comps)\n \t    {\n-\t      comp = fold_build3 (COMPONENT_REF, ctype,\n-\t\t\t\t  decl, cdecl, NULL_TREE);\n+\t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t      decl, cdecl, NULL_TREE);\n \t      rank = c->as ? c->as->rank : 0;\n \t      tmp = structure_alloc_comps (c->ts.u.derived, comp, NULL_TREE,\n \t\t\t\t\t   rank, purpose);\n@@ -6244,14 +6368,16 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t    continue;\n \n \t  /* We need source and destination components.  */\n-\t  comp = fold_build3 (COMPONENT_REF, ctype, decl, cdecl, NULL_TREE);\n-\t  dcmp = fold_build3 (COMPONENT_REF, ctype, dest, cdecl, NULL_TREE);\n+\t  comp = fold_build3_loc (input_location, COMPONENT_REF, ctype, decl,\n+\t\t\t\t  cdecl, NULL_TREE);\n+\t  dcmp = fold_build3_loc (input_location, COMPONENT_REF, ctype, dest,\n+\t\t\t\t  cdecl, NULL_TREE);\n \t  dcmp = fold_convert (TREE_TYPE (comp), dcmp);\n \n \t  if (c->attr.allocatable && !cmp_has_alloc_comps)\n \t    {\n \t      rank = c->as ? c->as->rank : 0;\n-\t      tmp = gfc_duplicate_allocatable(dcmp, comp, ctype, rank);\n+\t      tmp = gfc_duplicate_allocatable (dcmp, comp, ctype, rank);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n "}]}