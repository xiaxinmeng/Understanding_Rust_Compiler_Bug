{"sha": "873f8c1e6df94a9dcbfbe69f06538e3e45ba151d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODczZjhjMWU2ZGY5NGE5ZGNiZmJlNjlmMDY1MzhlM2U0NWJhMTUxZA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-09-29T23:10:54Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-09-29T23:13:55Z"}, "message": "Correct and improve -Wnonnull for calls to functions with VLA arguments (PR middle-end/97188).\n\nResolves:\nPR middle-end/97188 - ICE passing a null VLA to a function expecting at least one element\n\ngcc/ChangeLog:\n\n\tPR middle-end/97188\n\t* calls.c (maybe_warn_rdwr_sizes): Simplify warning messages.\n\tCorrect handling of VLA argumments.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/97188\n\t* gcc.dg/Wstringop-overflow-23.c: Adjust text of expected warnings.\n\t* gcc.dg/Wnonnull-4.c: New test.", "tree": {"sha": "9c7680bda586670d728244c647851453b47c059b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c7680bda586670d728244c647851453b47c059b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/873f8c1e6df94a9dcbfbe69f06538e3e45ba151d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/873f8c1e6df94a9dcbfbe69f06538e3e45ba151d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/873f8c1e6df94a9dcbfbe69f06538e3e45ba151d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/873f8c1e6df94a9dcbfbe69f06538e3e45ba151d/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "969baf03acd8124345617cea125b148568c7370a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/969baf03acd8124345617cea125b148568c7370a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/969baf03acd8124345617cea125b148568c7370a"}], "stats": {"total": 300, "additions": 261, "deletions": 39}, "files": [{"sha": "ed4363811c8248171579f8f392b9347497eeab85", "filename": "gcc/calls.c", "status": "modified", "additions": 80, "deletions": 35, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/873f8c1e6df94a9dcbfbe69f06538e3e45ba151d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/873f8c1e6df94a9dcbfbe69f06538e3e45ba151d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=873f8c1e6df94a9dcbfbe69f06538e3e45ba151d", "patch": "@@ -17,6 +17,7 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+#define INCLUDE_STRING\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -1924,7 +1925,10 @@ static void\n maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n {\n   auto_diagnostic_group adg;\n-  bool warned = false;\n+\n+  /* Set if a warning has been issued for any argument (used to decide\n+     whether to emit an informational note at the end).  */\n+  bool any_warned = false;\n \n   /* A string describing the attributes that the warnings issued by this\n      function apply to.  Used to print one informational note per function\n@@ -1974,27 +1978,60 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n       else\n \taccess_size = rwm->get (sizidx)->size;\n \n-      bool warned = false;\n+      /* Format the value or range to avoid an explosion of messages.  */\n+      char sizstr[80];\n+      tree sizrng[2] = { size_zero_node, build_all_ones_cst (sizetype) };\n+      if (get_size_range (access_size, sizrng, true))\n+\t{\n+\t  const char *s0 = print_generic_expr_to_str (sizrng[0]);\n+\t  if (tree_int_cst_equal (sizrng[0], sizrng[1]))\n+\t    {\n+\t      gcc_checking_assert (strlen (s0) < sizeof sizstr);\n+\t      strcpy (sizstr, s0);\n+\t    }\n+\t  else\n+\t    {\n+\t      const char *s1 = print_generic_expr_to_str (sizrng[1]);\n+\t      gcc_checking_assert (strlen (s0) + strlen (s1)\n+\t\t\t\t   < sizeof sizstr - 4);\n+\t      sprintf (sizstr, \"[%s, %s]\", s0, s1);\n+\t    }\n+\t}\n+      else\n+\t*sizstr = '\\0';\n+\n+      /* Set if a warning has been issued for the current argument.  */\n+      bool arg_warned = false;\n       location_t loc = EXPR_LOCATION (exp);\n       tree ptr = access.second.ptr;\n-      tree sizrng[2] = { size_zero_node, build_all_ones_cst (sizetype) };\n-      if (get_size_range (access_size, sizrng, true)\n+      if (*sizstr\n \t  && tree_int_cst_sgn (sizrng[0]) < 0\n \t  && tree_int_cst_sgn (sizrng[1]) < 0)\n \t{\n \t  /* Warn about negative sizes.  */\n-\t  if (tree_int_cst_equal (sizrng[0], sizrng[1]))\n-\t    warned = warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t\t \"%Kargument %i value %E is negative\",\n-\t\t\t\t exp, sizidx + 1, access_size);\n+\t  if (access.second.internal_p)\n+\t    {\n+\t      const std::string argtypestr\n+\t\t= access.second.array_as_string (ptrtype);\n+\n+\t      arg_warned = warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t\t       \"%Kbound argument %i value %s is \"\n+\t\t\t\t       \"negative for a variable length array \"\n+\t\t\t\t       \"argument %i of type %s\",\n+\t\t\t\t       exp, sizidx + 1, sizstr,\n+\t\t\t\t       ptridx + 1, argtypestr.c_str ());\n+\t    }\n \t  else\n-\t    warned = warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t\t \"%Kargument %i range [%E, %E] is negative\",\n-\t\t\t\t exp, sizidx + 1, sizrng[0], sizrng[1]);\n-\t  if (warned)\n+\t    arg_warned = warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t\t     \"%Kargument %i value %s is negative\",\n+\t\t\t\t     exp, sizidx + 1, sizstr);\n+\n+\t  if (arg_warned)\n \t    {\n \t      append_attrname (access, attrstr, sizeof attrstr);\n-\t      /* Avoid warning again for the same attribute.  */\n+\t      /* Remember a warning has been issued and avoid warning\n+\t\t again below for the same attribute.  */\n+\t      any_warned = true;\n \t      continue;\n \t    }\n \t}\n@@ -2006,7 +2043,6 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n \t      /* Multiply ACCESS_SIZE by the size of the type the pointer\n \t\t argument points to.  If it's incomplete the size is used\n \t\t as is.  */\n-\t      access_size = NULL_TREE;\n \t      if (tree argsize = TYPE_SIZE_UNIT (argtype))\n \t\tif (TREE_CODE (argsize) == INTEGER_CST)\n \t\t  {\n@@ -2028,35 +2064,44 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n \t\t different from also declaring the pointer argument with\n \t\t attribute nonnull when the function accepts null pointers\n \t\t only when the corresponding size is zero.  */\n-\t      if (tree_int_cst_equal (sizrng[0], sizrng[1]))\n-\t\twarned = warning_at (loc, OPT_Wnonnull,\n-\t\t\t\t     \"%Kargument %i is null but \"\n-\t\t\t\t     \"the corresponding size argument %i \"\n-\t\t\t\t     \"value is %E\",\n-\t\t\t\t     exp, ptridx + 1, sizidx + 1, access_size);\n+\t      if (access.second.internal_p)\n+\t\t{\n+\t\t  const std::string argtypestr\n+\t\t    = access.second.array_as_string (ptrtype);\n+\n+\t\t  arg_warned = warning_at (loc, OPT_Wnonnull,\n+\t\t\t\t\t   \"%Kargument %i of variable length \"\n+\t\t\t\t\t   \"array %s is null but \"\n+\t\t\t\t\t   \"the corresponding bound argument \"\n+\t\t\t\t\t   \"%i value is %s\",\n+\t\t\t\t\t   exp, sizidx + 1, argtypestr.c_str (),\n+\t\t\t\t\t   ptridx + 1, sizstr);\n+\t\t}\n \t      else\n-\t\twarned = warning_at (loc, OPT_Wnonnull,\n-\t\t\t\t     \"%Kargument %i is null but \"\n-\t\t\t\t     \"the corresponding size argument %i \"\n-\t\t\t\t     \"range is [%E, %E]\",\n-\t\t\t\t     exp, ptridx + 1, sizidx + 1,\n-\t\t\t\t     sizrng[0], sizrng[1]);\n+\t\targ_warned = warning_at (loc, OPT_Wnonnull,\n+\t\t\t\t\t \"%Kargument %i is null but \"\n+\t\t\t\t\t \"the corresponding size argument \"\n+\t\t\t\t\t \"%i value is %s\",\n+\t\t\t\t\t exp, ptridx + 1, sizidx + 1,\n+\t\t\t\t\t sizstr);\n \t    }\n \t  else if (access_size && access.second.static_p)\n \t    {\n \t      /* Warn about null pointers for [static N] array arguments\n \t\t but do not warn for ordinary (i.e., nonstatic) arrays.  */\n-\t      warned = warning_at (loc, OPT_Wnonnull,\n-\t\t\t\t   \"%Kargument %i to %<%T[static %E]%> null \"\n-\t\t\t\t   \"where non-null expected\",\n-\t\t\t\t   exp, ptridx + 1, argtype,\n-\t\t\t\t   sizrng[0]);\n+\t      arg_warned = warning_at (loc, OPT_Wnonnull,\n+\t\t\t\t       \"%Kargument %i to %<%T[static %E]%> \"\n+\t\t\t\t       \"is null where non-null expected\",\n+\t\t\t\t       exp, ptridx + 1, argtype,\n+\t\t\t\t       access_size);\n \t    }\n \n-\t  if (warned)\n+\t  if (arg_warned)\n \t    {\n \t      append_attrname (access, attrstr, sizeof attrstr);\n-\t      /* Avoid warning again for the same attribute.  */\n+\t      /* Remember a warning has been issued and avoid warning\n+\t\t again below for the same attribute.  */\n+\t      any_warned = true;\n \t      continue;\n \t    }\n \t}\n@@ -2101,7 +2146,7 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n \n       if (TREE_NO_WARNING (exp))\n \t{\n-\t  warned = true;\n+\t  any_warned = true;\n \n \t  if (access.second.internal_p)\n \t    inform (loc, \"referencing argument %u of type %qT\",\n@@ -2124,7 +2169,7 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n \t\t\"in a call with type %qT and attribute %qs\",\n \t\tfntype, attrstr);\n     }\n-  else if (warned)\n+  else if (any_warned)\n     {\n       if (fndecl)\n \tinform (DECL_SOURCE_LOCATION (fndecl),"}, {"sha": "180a40d46065f85982a2d282fb10a339b26a1a97", "filename": "gcc/testsuite/gcc.dg/Wnonnull-4.c", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/873f8c1e6df94a9dcbfbe69f06538e3e45ba151d/gcc%2Ftestsuite%2Fgcc.dg%2FWnonnull-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/873f8c1e6df94a9dcbfbe69f06538e3e45ba151d/gcc%2Ftestsuite%2Fgcc.dg%2FWnonnull-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWnonnull-4.c?ref=873f8c1e6df94a9dcbfbe69f06538e3e45ba151d", "patch": "@@ -0,0 +1,173 @@\n+/* PR middle-end/97188 - ICE passing a null VLA to a function expecting\n+   at least one element\n+   { dg-do compile }\n+   { dg-options \"-O -Wall -ftrack-macro-expansion=0\" } */\n+\n+#define INT_MAX   __INT_MAX__\n+#define INT_MIN   (-INT_MAX - 1)\n+\n+/* Exercise passing nul to a one-dimensional VLA argument.  */\n+\n+void test_fca_n (int r_m1)\n+{\n+  extern void fca_n (int n, char[n]);  // { dg-message \"in a call to function 'fca_n'\" \"note\" }\n+\n+#define T(n) fca_n (n, 0)\n+\n+  int min = INT_MIN;\n+  int max = INT_MAX;\n+  if (r_m1 >= 0)\n+    r_m1 = -1;\n+\n+  // Verify negative bounds.\n+  T (min);          // { dg-warning \"bound argument 1 value -\\\\d+ is negative for a variable length array argument 2 of type 'char\\\\\\[n]'\" }\n+  T (r_m1);         // { dg-warning \"bound argument 1 value \\\\\\[-\\\\d+, -1] is negative for a variable length array argument 2 of type 'char\\\\\\[n]\" }\n+  T ( -1);          // { dg-warning \"bound argument 1 value -1 is negative for a variable length array argument 2 of type 'char\\\\\\[n]\" }\n+\n+  T (  0);\n+\n+  // Verify positive bounds.\n+  T (  1);          // { dg-warning \"argument 1 of variable length array 'char\\\\\\[n]' is null but the corresponding bound argument 2 value is 1\" }\n+  T (  9);          // { dg-warning \"argument 1 of variable length array 'char\\\\\\[n]' is null but the corresponding bound argument 2 value is 9\" }\n+  T (max);          // { dg-warning \"argument 1 of variable length array 'char\\\\\\[n]' is null but the corresponding bound argument 2 value is \\\\d+\" }\n+}\n+\n+\n+/* Exercise passing nul to an array with unspecified bound of VLAs.  */\n+\n+void test_fsa_x_n (int r_m1)\n+{\n+  extern void fsa_x_n (int n, short[][n]);   // { dg-message \"in a call to function 'fsa_x_n'\" \"note\" }\n+\n+#undef T\n+#define T(n) fsa_x_n (n, 0)\n+\n+  int min = INT_MIN;\n+  int max = INT_MAX;\n+  if (r_m1 >= 0)\n+    r_m1 = -1;\n+\n+  // Verify negative bounds.\n+  T (min);          // { dg-warning \"bound argument 1 value -\\\\d+ is negative for a variable length array argument 2 of type 'short int\\\\\\[]\\\\\\[n]'\" }\n+  T (r_m1);         // { dg-warning \"bound argument 1 value \\\\\\[-\\\\d+, -1] is negative for a variable length array argument 2 of type 'short int\\\\\\[]\\\\\\[n]\" }\n+  T ( -1);          // { dg-warning \"bound argument 1 value -1 is negative for a variable length array argument 2 of type 'short int\\\\\\[]\\\\\\[n]\" }\n+\n+  T (  0);\n+\n+  // Verify positive bounds.\n+  T (  1);          // { dg-warning \"argument 1 of variable length array 'short int\\\\\\[]\\\\\\[n]' is null but the corresponding bound argument 2 value is 1\" }\n+  T (  9);          // { dg-warning \"argument 1 of variable length array 'short int\\\\\\[]\\\\\\[n]' is null but the corresponding bound argument 2 value is 9\" }\n+  T (max);          // { dg-warning \"argument 1 of variable length array 'short int\\\\\\[]\\\\\\[n]' is null but the corresponding bound argument 2 value is \\\\d+\" }\n+}\n+\n+\n+/* Exercise passing nul to an array of a single VLA.  */\n+\n+void test_fia_1_n (int r_m1)\n+{\n+  extern void fia_1_n (int n, int[1][n]);  // { dg-message \"in a call to function 'fia_1_n'\" \"note\" }\n+\n+#undef T\n+#define T(n) fia_1_n (n, 0)\n+\n+  int min = INT_MIN;\n+  int max = INT_MAX;\n+  if (r_m1 >= 0)\n+    r_m1 = -1;\n+\n+  // Verify negative bounds.\n+  T (min);          // { dg-warning \"bound argument 1 value -\\\\d+ is negative for a variable length array argument 2 of type 'int\\\\\\[1]\\\\\\[n]'\" }\n+  T (r_m1);         // { dg-warning \"bound argument 1 value \\\\\\[-\\\\d+, -1] is negative for a variable length array argument 2 of type 'int\\\\\\[1]\\\\\\[n]\" }\n+  T ( -1);          // { dg-warning \"bound argument 1 value -1 is negative for a variable length array argument 2 of type 'int\\\\\\[1]\\\\\\[n]\" }\n+\n+  T (  0);\n+\n+  // Verify positive bounds.\n+  T (  1);          // { dg-warning \"argument 1 of variable length array 'int\\\\\\[1]\\\\\\[n]' is null but the corresponding bound argument 2 value is 1\" }\n+  T (  9);          // { dg-warning \"argument 1 of variable length array 'int\\\\\\[1]\\\\\\[n]' is null but the corresponding bound argument 2 value is 9\" }\n+  T (max);          // { dg-warning \"argument 1 of variable length array 'int\\\\\\[1]\\\\\\[n]' is null but the corresponding bound argument 2 value is \\\\d+\" }\n+}\n+\n+\n+/* Exercise passing nul to an array of three VLAs.  */\n+\n+void test_fla_3_n (int r_m1)\n+{\n+  extern void fla_3_n (int n, long[3][n]);  // { dg-message \"in a call to function 'fla_3_n'\" \"note\" }\n+\n+#undef T\n+#define T(n) fla_3_n (n, 0)\n+\n+  int min = INT_MIN;\n+  int max = INT_MAX;\n+  if (r_m1 >= 0)\n+    r_m1 = -1;\n+\n+  // Verify negative bounds.\n+  T (min);          // { dg-warning \"bound argument 1 value -\\\\d+ is negative for a variable length array argument 2 of type 'long int\\\\\\[3]\\\\\\[n]'\" }\n+  T (r_m1);         // { dg-warning \"bound argument 1 value \\\\\\[-\\\\d+, -1] is negative for a variable length array argument 2 of type 'long int\\\\\\[3]\\\\\\[n]\" }\n+  T ( -1);          // { dg-warning \"bound argument 1 value -1 is negative for a variable length array argument 2 of type 'long int\\\\\\[3]\\\\\\[n]\" }\n+\n+  T (  0);\n+\n+  // Verify positive bounds.\n+  T (  1);          // { dg-warning \"argument 1 of variable length array 'long int\\\\\\[3]\\\\\\[n]' is null but the corresponding bound argument 2 value is 1\" }\n+  T (  9);          // { dg-warning \"argument 1 of variable length array 'long int\\\\\\[3]\\\\\\[n]' is null but the corresponding bound argument 2 value is 9\" }\n+  T (max);          // { dg-warning \"argument 1 of variable length array 'long int\\\\\\[3]\\\\\\[n]' is null but the corresponding bound argument 2 value is \\\\d+\" }\n+}\n+\n+\n+/* Exercise passing nul to a VLA of five-element arrays.  */\n+\n+void test_fda_n_5 (int r_m1)\n+{\n+  extern void fda_n_5 (int n, double[n][5]);// { dg-message \"in a call to function 'fda_n_5'\" \"note\" }\n+\n+#undef T\n+#define T(n) fda_n_5 (n, 0)\n+\n+  int min = INT_MIN;\n+  int max = INT_MAX;\n+  if (r_m1 >= 0)\n+    r_m1 = -1;\n+\n+  // Verify negative bounds.\n+  T (min);          // { dg-warning \"bound argument 1 value -\\\\d+ is negative for a variable length array argument 2 of type 'double\\\\\\[n]\\\\\\[5]'\" }\n+  T (r_m1);         // { dg-warning \"bound argument 1 value \\\\\\[-\\\\d+, -1] is negative for a variable length array argument 2 of type 'double\\\\\\[n]\\\\\\[5]\" }\n+  T ( -1);          // { dg-warning \"bound argument 1 value -1 is negative for a variable length array argument 2 of type 'double\\\\\\[n]\\\\\\[5]\" }\n+\n+  T (  0);\n+\n+  // Verify positive bounds.\n+  T (  1);          // { dg-warning \"argument 1 of variable length array 'double\\\\\\[n]\\\\\\[5]' is null but the corresponding bound argument 2 value is 1\" }\n+  T (  9);          // { dg-warning \"argument 1 of variable length array 'double\\\\\\[n]\\\\\\[5]' is null but the corresponding bound argument 2 value is 9\" }\n+  T (max);          // { dg-warning \"argument 1 of variable length array 'double\\\\\\[n]\\\\\\[5]' is null but the corresponding bound argument 2 value is \\\\d+\" }\n+}\n+\n+\n+/* Exercise passing nul to a two-dimensional VLA.  */\n+\n+void test_fca_n_n (int r_m1)\n+{\n+  extern void fca_n_n (int n, char[n][n]);  // { dg-message \"in a call to function 'fca_n_n'\" \"note\" }\n+\n+#undef T\n+#define T(n) fca_n_n (n, 0)\n+\n+  int min = INT_MIN;\n+  int max = INT_MAX;\n+  if (r_m1 >= 0)\n+    r_m1 = -1;\n+\n+  // Verify negative bounds.\n+  T (min);          // { dg-warning \"bound argument 1 value -\\\\d+ is negative for a variable length array argument 2 of type 'char\\\\\\[n]\\\\\\[n]'\" }\n+  T (r_m1);         // { dg-warning \"bound argument 1 value \\\\\\[-\\\\d+, -1] is negative for a variable length array argument 2 of type 'char\\\\\\[n]\\\\\\[n]\" }\n+  T ( -1);          // { dg-warning \"bound argument 1 value -1 is negative for a variable length array argument 2 of type 'char\\\\\\[n]\\\\\\[n]\" }\n+\n+  T (  0);\n+\n+  // Verify positive bounds.\n+  T (  1);          // { dg-warning \"argument 1 of variable length array 'char\\\\\\[n]\\\\\\[n]' is null but the corresponding bound argument 2 value is 1\" }\n+  T (  9);          // { dg-warning \"argument 1 of variable length array 'char\\\\\\[n]\\\\\\[n]' is null but the corresponding bound argument 2 value is 9\" }\n+  T (max);          // { dg-warning \"argument 1 of variable length array 'char\\\\\\[n]\\\\\\[n]' is null but the corresponding bound argument 2 value is \\\\d+\" }\n+}"}, {"sha": "0da916ad993c9dc42f48b35f552f3b568f521fc8", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-23.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/873f8c1e6df94a9dcbfbe69f06538e3e45ba151d/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/873f8c1e6df94a9dcbfbe69f06538e3e45ba151d/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-23.c?ref=873f8c1e6df94a9dcbfbe69f06538e3e45ba151d", "patch": "@@ -40,7 +40,11 @@ void test_rd2_1 (void)\n \n   {\n     void *null = 0;\n-    rd2_1 (SR (1, 2), null);    // { dg-warning \"argument 2 is null but the corresponding size argument 1 range is \\\\\\[1, 2]\" }\n+    /* Ideally the message would say \"range\" for a range and \"value\"\n+       for a singular value but using the same reduces the complexity\n+       of the code and keeps down the number of messages that need to\n+       be translated, withot sacrificing (too much) clarity.  */\n+    rd2_1 (SR (1, 2), null);    // { dg-warning \"argument 2 is null but the corresponding size argument 1 range|value is \\\\\\[1, 2]\" }\n   }\n }\n \n@@ -59,7 +63,7 @@ void test_wr3_1 (void)\n \n   void *null = 0;\n \n-  wr3_1 (SR (1, 2), 1, null);   // { dg-warning \"argument 3 is null but the corresponding size argument 1 range is \\\\\\[1, 2]\" }\n+  wr3_1 (SR (1, 2), 1, null);   // { dg-warning \"argument 3 is null but the corresponding size argument 1 range|value is \\\\\\[1, 2]\" }\n }\n \n \n@@ -71,7 +75,7 @@ void test_wrd2_1 (int n)\n   wr2_1 (0, 0);\n   wr2_1 (SR (-1, 1), 0);\n   wr2_1 (SR (0, 1), 0);\n-  wr2_1 (SR (1, 2), 0);         // { dg-warning \"argument 2 is null but the corresponding size argument 1 range is \\\\\\[1, 2]\" }\n+  wr2_1 (SR (1, 2), 0);         // { dg-warning \"argument 2 is null but the corresponding size argument 1 range|value is \\\\\\[1, 2]\" }\n \n   /* This should probably be diagnosed but to avoid false positives\n      caused by jump threading and such it would have to be done\n@@ -127,7 +131,7 @@ void test_rd1_3_wr2_4 (const void *s, void *d, int n1, int n2)\n   rd1_3_wr2_4 (s, d, -1, 2);    // { dg-warning \"argument 3 value -1 is negative\" }\n \n   const int ir_min_m1 = SR (INT_MIN, -1);\n-  rd1_3_wr2_4 (s, d, ir_min_m1, 2);   // { dg-warning \"argument 3 range \\\\\\[-\\[0-9\\]+, -1] is negative\" }\n+  rd1_3_wr2_4 (s, d, ir_min_m1, 2);   // { dg-warning \"argument 3 range|value \\\\\\[-\\[0-9\\]+, -1] is negative\" }\n \n   rd1_3_wr2_4 (s, d, SR (-1, 0), 2);\n   rd1_3_wr2_4 (s, d, SR (INT_MIN, INT_MAX), 2);"}]}