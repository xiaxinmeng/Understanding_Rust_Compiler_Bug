{"sha": "f791702956d022ee147a0f87534f4f3ebb74b572", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc5MTcwMjk1NmQwMjJlZTE0N2EwZjg3NTM0ZjRmM2ViYjc0YjU3Mg==", "commit": {"author": {"name": "Evgeny Stupachenko", "email": "evstupac@gmail.com", "date": "2014-06-18T07:46:18Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-06-18T07:46:18Z"}, "message": "re PR tree-optimization/52252 (An opportunity for x86 gcc vectorizer (gain up to 3 times))\n\ngcc/\n\t* config/i386/i386.c (ix86_reassociation_width): Add alternative for\n\tvector case.\n\t* config/i386/i386.h (TARGET_VECTOR_PARALLEL_EXECUTION): New.\n\t* config/i386/x86-tune.def (X86_TUNE_VECTOR_PARALLEL_EXECUTION): New.\n\t* tree-vect-data-refs.c (vect_shift_permute_load_chain): New.\n\tIntroduces alternative way of loads group permutaions.\n\t(vect_transform_grouped_load): Try alternative way of permutations.\n\ngcc/testsuite/\n\tPR tree-optimization/52252\n\t* gcc.target/i386/pr52252-atom.c: Test on loads group of size 3.\n\t* gcc.target/i386/pr52252-core.c: Ditto.\n\n\tPR tree-optimization/61403\n\t* gcc.target/i386/pr61403.c: Test on loads and stores group of size 3.\n\nFrom-SVN: r211769", "tree": {"sha": "28cbde5f2df4453f929eea8f65b8e6be0303d012", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28cbde5f2df4453f929eea8f65b8e6be0303d012"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f791702956d022ee147a0f87534f4f3ebb74b572", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f791702956d022ee147a0f87534f4f3ebb74b572", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f791702956d022ee147a0f87534f4f3ebb74b572", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f791702956d022ee147a0f87534f4f3ebb74b572/comments", "author": {"login": "evstupac", "id": 38332307, "node_id": "MDQ6VXNlcjM4MzMyMzA3", "avatar_url": "https://avatars.githubusercontent.com/u/38332307?v=4", "gravatar_id": "", "url": "https://api.github.com/users/evstupac", "html_url": "https://github.com/evstupac", "followers_url": "https://api.github.com/users/evstupac/followers", "following_url": "https://api.github.com/users/evstupac/following{/other_user}", "gists_url": "https://api.github.com/users/evstupac/gists{/gist_id}", "starred_url": "https://api.github.com/users/evstupac/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/evstupac/subscriptions", "organizations_url": "https://api.github.com/users/evstupac/orgs", "repos_url": "https://api.github.com/users/evstupac/repos", "events_url": "https://api.github.com/users/evstupac/events{/privacy}", "received_events_url": "https://api.github.com/users/evstupac/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f014c65363d0b8a52807e55c4bda620c57440a4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f014c65363d0b8a52807e55c4bda620c57440a4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f014c65363d0b8a52807e55c4bda620c57440a4d"}], "stats": {"total": 472, "additions": 471, "deletions": 1}, "files": [{"sha": "93955b3465b93d7866ef4d247b9379151df29f15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f791702956d022ee147a0f87534f4f3ebb74b572/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f791702956d022ee147a0f87534f4f3ebb74b572/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f791702956d022ee147a0f87534f4f3ebb74b572", "patch": "@@ -1,3 +1,13 @@\n+2014-06-18  Evgeny Stupachenko  <evstupac@gmail.com>\n+\n+\t* config/i386/i386.c (ix86_reassociation_width): Add alternative for\n+\tvector case.\n+\t* config/i386/i386.h (TARGET_VECTOR_PARALLEL_EXECUTION): New.\n+\t* config/i386/x86-tune.def (X86_TUNE_VECTOR_PARALLEL_EXECUTION): New.\n+\t* tree-vect-data-refs.c (vect_shift_permute_load_chain): New.\n+\tIntroduces alternative way of loads group permutaions.\n+\t(vect_transform_grouped_load): Try alternative way of permutations.\n+\n 2014-06-18  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gimplify.c (omp_notice_variable): If n is non-NULL"}, {"sha": "8046c67c5555f2608b71320b12d5099cb1ca723e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f791702956d022ee147a0f87534f4f3ebb74b572/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f791702956d022ee147a0f87534f4f3ebb74b572/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f791702956d022ee147a0f87534f4f3ebb74b572", "patch": "@@ -46429,6 +46429,16 @@ ix86_reassociation_width (unsigned int opc ATTRIBUTE_UNUSED,\n {\n   int res = 1;\n \n+  /* Vector part.  */\n+  if (VECTOR_MODE_P (mode))\n+    {\n+      if (TARGET_VECTOR_PARALLEL_EXECUTION)\n+\treturn 2;\n+      else\n+\treturn 1;\n+    }\n+\n+  /* Scalar part.  */\n   if (INTEGRAL_MODE_P (mode) && TARGET_REASSOC_INT_TO_PARALLEL)\n     res = 2;\n   else if (FLOAT_MODE_P (mode) && TARGET_REASSOC_FP_TO_PARALLEL)"}, {"sha": "9e3ef9424c392a10a6674c8f9b608aae5a7f6cd9", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f791702956d022ee147a0f87534f4f3ebb74b572/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f791702956d022ee147a0f87534f4f3ebb74b572/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=f791702956d022ee147a0f87534f4f3ebb74b572", "patch": "@@ -433,6 +433,8 @@ extern unsigned char ix86_tune_features[X86_TUNE_LAST];\n \tix86_tune_features[X86_TUNE_USE_VECTOR_CONVERTS]\n #define TARGET_SLOW_PSHUFB \\\n \tix86_tune_features[X86_TUNE_SLOW_PSHUFB]\n+#define TARGET_VECTOR_PARALLEL_EXECUTION \\\n+\tix86_tune_features[X86_TUNE_VECTOR_PARALLEL_EXECUTION]\n #define TARGET_FUSE_CMP_AND_BRANCH_32 \\\n \tix86_tune_features[X86_TUNE_FUSE_CMP_AND_BRANCH_32]\n #define TARGET_FUSE_CMP_AND_BRANCH_64 \\"}, {"sha": "cb44dc3120cc2c120e3c5f2edc9ad5707d9ee577", "filename": "gcc/config/i386/x86-tune.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f791702956d022ee147a0f87534f4f3ebb74b572/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f791702956d022ee147a0f87534f4f3ebb74b572/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune.def?ref=f791702956d022ee147a0f87534f4f3ebb74b572", "patch": "@@ -390,6 +390,11 @@ DEF_TUNE (X86_TUNE_USE_VECTOR_CONVERTS, \"use_vector_converts\", m_AMDFAM10)\n DEF_TUNE (X86_TUNE_SLOW_PSHUFB, \"slow_pshufb\",\n           m_BONNELL | m_SILVERMONT | m_INTEL)\n \n+/* X86_TUNE_VECTOR_PARALLEL_EXECUTION: Indicates tunings with ability to\n+   execute 2 or more vector instructions in parallel.  */\n+DEF_TUNE (X86_TUNE_VECTOR_PARALLEL_EXECUTION, \"vec_parallel\",\n+          m_NEHALEM | m_SANDYBRIDGE | m_HASWELL)\n+\n /*****************************************************************************/\n /* AVX instruction selection tuning (some of SSE flags affects AVX, too)     */\n /*****************************************************************************/"}, {"sha": "cb2984d8e94efc5f857f08812824718876c13e93", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f791702956d022ee147a0f87534f4f3ebb74b572/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f791702956d022ee147a0f87534f4f3ebb74b572/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f791702956d022ee147a0f87534f4f3ebb74b572", "patch": "@@ -1,3 +1,12 @@\n+2014-06-18  Evgeny Stupachenko  <evstupac@gmail.com>\n+\n+\tPR tree-optimization/52252\n+\t* gcc.target/i386/pr52252-atom.c: Test on loads group of size 3.\n+\t* gcc.target/i386/pr52252-core.c: Ditto.\n+\n+\tPR tree-optimization/61403\n+\t* gcc.target/i386/pr61403.c: Test on loads and stores group of size 3.\n+\n 2014-06-18  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gfortran.dg/gomp/declare-simd-1.f90: New test."}, {"sha": "715b4594382647d0834addcaf8ac2fb5c854e67c", "filename": "gcc/testsuite/gcc.target/i386/pr52252-atom.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f791702956d022ee147a0f87534f4f3ebb74b572/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr52252-atom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f791702956d022ee147a0f87534f4f3ebb74b572/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr52252-atom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr52252-atom.c?ref=f791702956d022ee147a0f87534f4f3ebb74b572", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target ssse3 } */\n+/* { dg-options \"-O2 -ftree-vectorize -mssse3 -mtune=slm\" } */\n+#define byte unsigned char\n+\n+void\n+matrix_mul (byte *in, byte *out, int size)\n+{\n+  int i;\n+  for (i = 0; i < size; i++)\n+    {\n+      byte in0 = in[0];\n+      byte in1 = in[1];\n+      byte in2 = in[2];\n+      byte out0, out1, out2, out3;\n+      out0 = in0 + in1;\n+      out1 = in0 + in2;\n+      out2 = in1 + in2;\n+      out3 = in0 + in1 + in2;\n+      out[0] = out0;\n+      out[1] = out1;\n+      out[2] = out2;\n+      out[3] = out3;\n+      in += 3;\n+      out += 4;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler \"palignr\" } } */"}, {"sha": "ac857a5fe7e0fa3a2c37084449f141e1c51fea6c", "filename": "gcc/testsuite/gcc.target/i386/pr52252-core.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f791702956d022ee147a0f87534f4f3ebb74b572/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr52252-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f791702956d022ee147a0f87534f4f3ebb74b572/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr52252-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr52252-core.c?ref=f791702956d022ee147a0f87534f4f3ebb74b572", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target ssse3 } */\n+/* { dg-options \"-O2 -ftree-vectorize -mssse3 -mtune=corei7\" } */\n+#define byte unsigned char\n+\n+void\n+matrix_mul (byte *in, byte *out, int size)\n+{\n+  int i;\n+  for (i = 0; i < size; i++)\n+    {\n+      byte in0 = in[0];\n+      byte in1 = in[1];\n+      byte in2 = in[2];\n+      byte out0, out1, out2, out3;\n+      out0 = in0 + in1;\n+      out1 = in0 + in2;\n+      out2 = in1 + in2;\n+      out3 = in0 + in1 + in2;\n+      out[0] = out0;\n+      out[1] = out1;\n+      out[2] = out2;\n+      out[3] = out3;\n+      in += 3;\n+      out += 4;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler \"pshufb\" } } */"}, {"sha": "84cc5c5c80a211b4852cc9162f7e3268b8bc38a2", "filename": "gcc/testsuite/gcc.target/i386/pr61403.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f791702956d022ee147a0f87534f4f3ebb74b572/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr61403.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f791702956d022ee147a0f87534f4f3ebb74b572/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr61403.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr61403.c?ref=f791702956d022ee147a0f87534f4f3ebb74b572", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target sse4 } */\n+/* { dg-options \"-O2 -ffast-math -ftree-vectorize -msse4.2 -mtune=corei7\" } */\n+\n+#include <math.h>\n+\n+struct XYZ\n+{\n+  float x;\n+  float y;\n+  float z;\n+};\n+\n+void\n+norm (struct XYZ *in, struct XYZ *out, int size)\n+{\n+  int i;\n+  for (i = 0; i < size; ++i)\n+    {\n+      float n = sqrt (in[i].x * in[i].x + in[i].y * in[i].y + in[i].z * in[i].z);\n+      out[i].x = in[i].x / n;\n+      out[i].y = in[i].y / n;\n+      out[i].z = in[i].z / n;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler \"blend\" } } */"}, {"sha": "d5cd9eca2fe11eb165230ed637c37281fd3bc5d7", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 350, "deletions": 1, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f791702956d022ee147a0f87534f4f3ebb74b572/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f791702956d022ee147a0f87534f4f3ebb74b572/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=f791702956d022ee147a0f87534f4f3ebb74b572", "patch": "@@ -5209,6 +5209,346 @@ vect_permute_load_chain (vec<tree> dr_chain,\n     }\n }\n \n+/* Function vect_shift_permute_load_chain.\n+\n+   Given a chain of loads in DR_CHAIN of LENGTH 2 or 3, generate\n+   sequence of stmts to reorder the input data accordingly.\n+   Return the final references for loads in RESULT_CHAIN.\n+   Return true if successed, false otherwise.\n+\n+   E.g., LENGTH is 3 and the scalar type is short, i.e., VF is 8.\n+   The input is 3 vectors each containing 8 elements.  We assign a\n+   number to each element, the input sequence is:\n+\n+   1st vec:   0  1  2  3  4  5  6  7\n+   2nd vec:   8  9 10 11 12 13 14 15\n+   3rd vec:  16 17 18 19 20 21 22 23\n+\n+   The output sequence should be:\n+\n+   1st vec:  0 3 6  9 12 15 18 21\n+   2nd vec:  1 4 7 10 13 16 19 22\n+   3rd vec:  2 5 8 11 14 17 20 23\n+\n+   We use 3 shuffle instructions and 3 * 3 - 1 shifts to create such output.\n+\n+   First we shuffle all 3 vectors to get correct elements order:\n+\n+   1st vec:  ( 0  3  6) ( 1  4  7) ( 2  5)\n+   2nd vec:  ( 8 11 14) ( 9 12 15) (10 13)\n+   3rd vec:  (16 19 22) (17 20 23) (18 21)\n+\n+   Next we unite and shift vector 3 times:\n+\n+   1st step:\n+     shift right by 6 the concatenation of:\n+     \"1st vec\" and  \"2nd vec\"\n+       ( 0  3  6) ( 1  4  7) |( 2  5) _ ( 8 11 14) ( 9 12 15)| (10 13)\n+     \"2nd vec\" and  \"3rd vec\"\n+       ( 8 11 14) ( 9 12 15) |(10 13) _ (16 19 22) (17 20 23)| (18 21)\n+     \"3rd vec\" and  \"1st vec\"\n+       (16 19 22) (17 20 23) |(18 21) _ ( 0  3  6) ( 1  4  7)| ( 2  5)\n+\t\t\t     | New vectors                   |\n+\n+     So that now new vectors are:\n+\n+     1st vec:  ( 2  5) ( 8 11 14) ( 9 12 15)\n+     2nd vec:  (10 13) (16 19 22) (17 20 23)\n+     3rd vec:  (18 21) ( 0  3  6) ( 1  4  7)\n+\n+   2nd step:\n+     shift right by 5 the concatenation of:\n+     \"1st vec\" and  \"3rd vec\"\n+       ( 2  5) ( 8 11 14) |( 9 12 15) _ (18 21) ( 0  3  6)| ( 1  4  7)\n+     \"2nd vec\" and  \"1st vec\"\n+       (10 13) (16 19 22) |(17 20 23) _ ( 2  5) ( 8 11 14)| ( 9 12 15)\n+     \"3rd vec\" and  \"2nd vec\"\n+       (18 21) ( 0  3  6) |( 1  4  7) _ (10 13) (16 19 22)| (17 20 23)\n+\t\t\t  | New vectors                   |\n+\n+     So that now new vectors are:\n+\n+     1st vec:  ( 9 12 15) (18 21) ( 0  3  6)\n+     2nd vec:  (17 20 23) ( 2  5) ( 8 11 14)\n+     3rd vec:  ( 1  4  7) (10 13) (16 19 22) READY\n+\n+   3rd step:\n+     shift right by 5 the concatenation of:\n+     \"1st vec\" and  \"1st vec\"\n+       ( 9 12 15) (18 21) |( 0  3  6) _ ( 9 12 15) (18 21)| ( 0  3  6)\n+     shift right by 3 the concatenation of:\n+     \"2nd vec\" and  \"2nd vec\"\n+               (17 20 23) |( 2  5) ( 8 11 14) _ (17 20 23)| ( 2  5) ( 8 11 14)\n+\t\t\t  | New vectors                   |\n+\n+     So that now all vectors are READY:\n+     1st vec:  ( 0  3  6) ( 9 12 15) (18 21)\n+     2nd vec:  ( 2  5) ( 8 11 14) (17 20 23)\n+     3rd vec:  ( 1  4  7) (10 13) (16 19 22)\n+\n+   This algorithm is faster than one in vect_permute_load_chain if:\n+     1.  \"shift of a concatination\" is faster than general permutation.\n+\t This is usually so.\n+     2.  The TARGET machine can't execute vector instructions in parallel.\n+\t This is because each step of the algorithm depends on previous.\n+\t The algorithm in vect_permute_load_chain is much more parallel.\n+\n+   The algorithm is applicable only for LOAD CHAIN LENGTH less than VF.\n+*/\n+\n+static bool\n+vect_shift_permute_load_chain (vec<tree> dr_chain,\n+\t\t\t       unsigned int length,\n+\t\t\t       gimple stmt,\n+\t\t\t       gimple_stmt_iterator *gsi,\n+\t\t\t       vec<tree> *result_chain)\n+{\n+  tree vect[3], vect_shift[3], data_ref, first_vect, second_vect;\n+  tree perm2_mask1, perm2_mask2, perm3_mask;\n+  tree select_mask, shift1_mask, shift2_mask, shift3_mask, shift4_mask;\n+  gimple perm_stmt;\n+\n+  tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n+  unsigned int i;\n+  unsigned nelt = TYPE_VECTOR_SUBPARTS (vectype);\n+  unsigned char *sel = XALLOCAVEC (unsigned char, nelt);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+\n+  result_chain->quick_grow (length);\n+  memcpy (result_chain->address (), dr_chain.address (),\n+\t  length * sizeof (tree));\n+\n+  if (length == 2 && LOOP_VINFO_VECT_FACTOR (loop_vinfo) > 4)\n+    {\n+      for (i = 0; i < nelt / 2; ++i)\n+\tsel[i] = i * 2;\n+      for (i = 0; i < nelt / 2; ++i)\n+\tsel[nelt / 2 + i] = i * 2 + 1;\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"shuffle of 2 fields structure is not \\\n+\t\t\t      supported by target\\n\");\n+\t  return false;\n+\t}\n+      perm2_mask1 = vect_gen_perm_mask (vectype, sel);\n+      gcc_assert (perm2_mask1 != NULL);\n+\n+      for (i = 0; i < nelt / 2; ++i)\n+\tsel[i] = i * 2 + 1;\n+      for (i = 0; i < nelt / 2; ++i)\n+\tsel[nelt / 2 + i] = i * 2;\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"shuffle of 2 fields structure is not \\\n+\t\t\t      supported by target\\n\");\n+\t  return false;\n+\t}\n+      perm2_mask2 = vect_gen_perm_mask (vectype, sel);\n+      gcc_assert (perm2_mask2 != NULL);\n+\n+      /* Generating permutation constant to shift all elements.\n+\t For vector length 8 it is {4 5 6 7 8 9 10 11}.  */\n+      for (i = 0; i < nelt; i++)\n+\tsel[i] = nelt / 2 + i;\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"shift permutation is not supported by target\\n\");\n+\t  return false;\n+\t}\n+      shift1_mask = vect_gen_perm_mask (vectype, sel);\n+      gcc_assert (shift1_mask != NULL);\n+\n+      /* Generating permutation constant to select vector from 2.\n+\t For vector length 8 it is {0 1 2 3 12 13 14 15}.  */\n+      for (i = 0; i < nelt / 2; i++)\n+\tsel[i] = i;\n+      for (i = nelt / 2; i < nelt; i++)\n+\tsel[i] = nelt + i;\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"select is not supported by target\\n\");\n+\t  return false;\n+\t}\n+      select_mask = vect_gen_perm_mask (vectype, sel);\n+      gcc_assert (select_mask != NULL);\n+\n+      first_vect = dr_chain[0];\n+      second_vect = dr_chain[1];\n+\n+      data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shuffle2\");\n+      perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n+\t\t\t\t\t\tfirst_vect, first_vect,\n+\t\t\t\t\t\tperm2_mask1);\n+      vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+      vect[0] = data_ref;\n+\n+      data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shuffle2\");\n+      perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n+\t\t\t\t\t\tsecond_vect, second_vect,\n+\t\t\t\t\t\tperm2_mask2);\n+      vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+      vect[1] = data_ref;\n+\n+      data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shift\");\n+      perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n+\t\t\t\t\t\tvect[0], vect[1],\n+\t\t\t\t\t\tshift1_mask);\n+      vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+      (*result_chain)[1] = data_ref;\n+\n+      data_ref = make_temp_ssa_name (vectype, NULL, \"vect_select\");\n+      perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n+\t\t\t\t\t\tvect[0], vect[1],\n+\t\t\t\t\t\tselect_mask);\n+      vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+      (*result_chain)[0] = data_ref;\n+\n+      return true;\n+    }\n+  if (length == 3 && LOOP_VINFO_VECT_FACTOR (loop_vinfo) > 2)\n+    {\n+      unsigned int k = 0, l = 0;\n+\n+      /* Generating permutation constant to get all elements in rigth order.\n+\t For vector length 8 it is {0 3 6 1 4 7 2 5}.  */\n+      for (i = 0; i < nelt; i++)\n+\t{\n+\t  if (3 * k + (l % 3) >= nelt)\n+\t    {\n+\t      k = 0;\n+\t      l += (3 - (nelt % 3));\n+\t    }\n+\t  sel[i] = 3 * k + (l % 3);\n+\t  k++;\n+\t}\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"shuffle of 3 fields structure is not \\\n+\t\t\t      supported by target\\n\");\n+\t  return false;\n+\t}\n+      perm3_mask = vect_gen_perm_mask (vectype, sel);\n+      gcc_assert (perm3_mask != NULL);\n+\n+      /* Generating permutation constant to shift all elements.\n+\t For vector length 8 it is {6 7 8 9 10 11 12 13}.  */\n+      for (i = 0; i < nelt; i++)\n+\tsel[i] = 2 * (nelt / 3) + (nelt % 3) + i;\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"shift permutation is not supported by target\\n\");\n+\t  return false;\n+\t}\n+      shift1_mask = vect_gen_perm_mask (vectype, sel);\n+      gcc_assert (shift1_mask != NULL);\n+\n+      /* Generating permutation constant to shift all elements.\n+\t For vector length 8 it is {5 6 7 8 9 10 11 12}.  */\n+      for (i = 0; i < nelt; i++)\n+\tsel[i] = 2 * (nelt / 3) + 1 + i;\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"shift permutation is not supported by target\\n\");\n+\t  return false;\n+\t}\n+      shift2_mask = vect_gen_perm_mask (vectype, sel);\n+      gcc_assert (shift2_mask != NULL);\n+\n+      /* Generating permutation constant to shift all elements.\n+\t For vector length 8 it is {3 4 5 6 7 8 9 10}.  */\n+      for (i = 0; i < nelt; i++)\n+\tsel[i] = (nelt / 3) + (nelt % 3) / 2 + i;\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"shift permutation is not supported by target\\n\");\n+\t  return false;\n+\t}\n+      shift3_mask = vect_gen_perm_mask (vectype, sel);\n+      gcc_assert (shift3_mask != NULL);\n+\n+      /* Generating permutation constant to shift all elements.\n+\t For vector length 8 it is {5 6 7 8 9 10 11 12}.  */\n+      for (i = 0; i < nelt; i++)\n+\tsel[i] = 2 * (nelt / 3) + (nelt % 3) / 2 + i;\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"shift permutation is not supported by target\\n\");\n+\t  return false;\n+\t}\n+      shift4_mask = vect_gen_perm_mask (vectype, sel);\n+      gcc_assert (shift4_mask != NULL);\n+\n+      for (k = 0; k < 3; k++)\n+\t{\n+\t  data_ref = make_temp_ssa_name (vectype, NULL, \"vect_suffle3\");\n+\t  perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n+\t\t\t\t\t\t    dr_chain[k], dr_chain[k],\n+\t\t\t\t\t\t    perm3_mask);\n+\t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+\t  vect[k] = data_ref;\n+\t}\n+\n+      for (k = 0; k < 3; k++)\n+\t{\n+\t  data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shift1\");\n+\t  perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n+\t\t\t\t\t\t    vect[k % 3],\n+\t\t\t\t\t\t    vect[(k + 1) % 3],\n+\t\t\t\t\t\t    shift1_mask);\n+\t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+\t  vect_shift[k] = data_ref;\n+\t}\n+\n+      for (k = 0; k < 3; k++)\n+\t{\n+\t  data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shift2\");\n+\t  perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n+\t\t\t\t\t\t    vect_shift[(4 - k) % 3],\n+\t\t\t\t\t\t    vect_shift[(3 - k) % 3],\n+\t\t\t\t\t\t    shift2_mask);\n+\t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+\t  vect[k] = data_ref;\n+\t}\n+\n+      (*result_chain)[3 - (nelt % 3)] = vect[2];\n+\n+      data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shift3\");\n+      perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n+\t\t\t\t\t\tvect[0], vect[0],\n+\t\t\t\t\t\tshift3_mask);\n+      vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+      (*result_chain)[nelt % 3] = data_ref;\n+\n+      data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shift4\");\n+      perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n+\t\t\t\t\t\tvect[1], vect[1],\n+\t\t\t\t\t\tshift4_mask);\n+      vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+      (*result_chain)[0] = data_ref;\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Function vect_transform_grouped_load.\n \n    Given a chain of input interleaved data-refs (in DR_CHAIN), build statements\n@@ -5220,13 +5560,22 @@ void\n vect_transform_grouped_load (gimple stmt, vec<tree> dr_chain, int size,\n \t\t\t     gimple_stmt_iterator *gsi)\n {\n+  enum machine_mode mode;\n   vec<tree> result_chain = vNULL;\n \n   /* DR_CHAIN contains input data-refs that are a part of the interleaving.\n      RESULT_CHAIN is the output of vect_permute_load_chain, it contains permuted\n      vectors, that are ready for vector computation.  */\n   result_chain.create (size);\n-  vect_permute_load_chain (dr_chain, size, stmt, gsi, &result_chain);\n+\n+  /* If reassociation width for vector type is 2 or greater target machine can\n+     execute 2 or more vector instructions in parallel.  Otherwise try to\n+     get chain for loads group using vect_shift_permute_load_chain.  */\n+  mode = TYPE_MODE (STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt)));\n+  if (targetm.sched.reassociation_width (VEC_PERM_EXPR, mode) > 1\n+      || !vect_shift_permute_load_chain (dr_chain, size, stmt,\n+\t\t\t\t\t gsi, &result_chain))\n+    vect_permute_load_chain (dr_chain, size, stmt, gsi, &result_chain);\n   vect_record_grouped_load_vectors (stmt, result_chain);\n   result_chain.release ();\n }"}]}