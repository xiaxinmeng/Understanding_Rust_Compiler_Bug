{"sha": "197463ae905f0ce7c8dbeb298531a71855ac973e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk3NDYzYWU5MDVmMGNlN2M4ZGJlYjI5ODUzMWE3MTg1NWFjOTczZQ==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm@polyomino.org.uk", "date": "2004-07-25T09:12:21Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-07-25T09:12:21Z"}, "message": "c-typeck.c (digest_init): Don't allow arrays of signed or unsigned variants of wchar_t to be initialized...\n\n\t* c-typeck.c (digest_init): Don't allow arrays of signed or\n\tunsigned variants of wchar_t to be initialized by wide string\n\tconstants.  Do allow arrays of enumerated types compatible with\n\twchar_t to be initialized by wide string constants.  Refine tests\n\tdistinguishing wide and narrow strings and arrays.  Give specific\n\terror for arrays of other integer types initialized by string\n\tconstants.\n\t(output_init_element, process_init_element): Check for\n\tINTEGRAL_TYPE_P rather than just for INTEGER_TYPE when\n\tinitializing with string constants.\n\ntestsuite:\n\t* gcc.dg/init-string-2.c: New test.\n\nFrom-SVN: r85146", "tree": {"sha": "679b0177e461b3f53a6306601674dd0b3935125b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/679b0177e461b3f53a6306601674dd0b3935125b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/197463ae905f0ce7c8dbeb298531a71855ac973e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/197463ae905f0ce7c8dbeb298531a71855ac973e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/197463ae905f0ce7c8dbeb298531a71855ac973e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/197463ae905f0ce7c8dbeb298531a71855ac973e/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b785f485ecfa4a4685e30b3385b701159726f4a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b785f485ecfa4a4685e30b3385b701159726f4a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b785f485ecfa4a4685e30b3385b701159726f4a3"}], "stats": {"total": 121, "additions": 102, "deletions": 19}, "files": [{"sha": "c5df482fb738d04453b5e5225a76395d85d50809", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197463ae905f0ce7c8dbeb298531a71855ac973e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197463ae905f0ce7c8dbeb298531a71855ac973e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=197463ae905f0ce7c8dbeb298531a71855ac973e", "patch": "@@ -1,3 +1,16 @@\n+2004-07-25  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* c-typeck.c (digest_init): Don't allow arrays of signed or\n+\tunsigned variants of wchar_t to be initialized by wide string\n+\tconstants.  Do allow arrays of enumerated types compatible with\n+\twchar_t to be initialized by wide string constants.  Refine tests\n+\tdistinguishing wide and narrow strings and arrays.  Give specific\n+\terror for arrays of other integer types initialized by string\n+\tconstants.\n+\t(output_init_element, process_init_element): Check for\n+\tINTEGRAL_TYPE_P rather than just for INTEGER_TYPE when\n+\tinitializing with string constants.\n+\n 2004-07-25  Richard Henderson  <rth@redhat.com>\n \n \t* c-decl.c (start_function): Set DECL_ARTIFICIAL and DECL_IGNORED_P"}, {"sha": "2ed3c379a0fe71073c468c0ce75db95da0df548c", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197463ae905f0ce7c8dbeb298531a71855ac973e/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197463ae905f0ce7c8dbeb298531a71855ac973e/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=197463ae905f0ce7c8dbeb298531a71855ac973e", "patch": "@@ -3930,37 +3930,41 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n   /* Initialization of an array of chars from a string constant\n      optionally enclosed in braces.  */\n \n-  if (code == ARRAY_TYPE)\n+  if (code == ARRAY_TYPE && inside_init\n+      && TREE_CODE (inside_init) == STRING_CST)\n     {\n       tree typ1 = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n-      if ((typ1 == char_type_node\n-\t   || typ1 == signed_char_type_node\n-\t   || typ1 == unsigned_char_type_node\n-\t   || typ1 == unsigned_wchar_type_node\n-\t   || typ1 == signed_wchar_type_node)\n-\t  && ((inside_init && TREE_CODE (inside_init) == STRING_CST)))\n+      /* Note that an array could be both an array of character type\n+\t and an array of wchar_t if wchar_t is signed char or unsigned\n+\t char.  */\n+      bool char_array = (typ1 == char_type_node\n+\t\t\t || typ1 == signed_char_type_node\n+\t\t\t || typ1 == unsigned_char_type_node);\n+      bool wchar_array = !!comptypes (typ1, wchar_type_node);\n+      if (char_array || wchar_array)\n \t{\n \t  struct c_expr expr;\n+\t  bool char_string;\n \t  expr.value = inside_init;\n \t  expr.original_code = (strict_string ? STRING_CST : ERROR_MARK);\n \t  maybe_warn_string_init (type, expr);\n \n+\t  char_string\n+\t    = (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (inside_init)))\n+\t       == char_type_node);\n+\n \t  if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (inside_init)),\n \t\t\t TYPE_MAIN_VARIANT (type)))\n \t    return inside_init;\n \n-\t  if ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (inside_init)))\n-\t       != char_type_node)\n-\t      && TYPE_PRECISION (typ1) == TYPE_PRECISION (char_type_node))\n+\t  if (!wchar_array && !char_string)\n \t    {\n \t      error_init (\"char-array initialized from wide string\");\n \t      return error_mark_node;\n \t    }\n-\t  if ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (inside_init)))\n-\t       == char_type_node)\n-\t      && TYPE_PRECISION (typ1) != TYPE_PRECISION (char_type_node))\n+\t  if (char_string && !char_array)\n \t    {\n-\t      error_init (\"int-array initialized from non-wide string\");\n+\t      error_init (\"wchar_t-array initialized from non-wide string\");\n \t      return error_mark_node;\n \t    }\n \n@@ -3982,6 +3986,12 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n \n \t  return inside_init;\n \t}\n+      else if (INTEGRAL_TYPE_P (typ1))\n+\t{\n+\t  error_init (\"array of inappropriate type initialized \"\n+\t\t      \"from string constant\");\n+\t  return error_mark_node;\n+\t}\n     }\n \n   /* Build a VECTOR_CST from a *constant* vector constructor.  If the\n@@ -5476,7 +5486,7 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n       || (TREE_CODE (TREE_TYPE (value)) == ARRAY_TYPE\n \t  && !(TREE_CODE (value) == STRING_CST\n \t       && TREE_CODE (type) == ARRAY_TYPE\n-\t       && TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE)\n+\t       && INTEGRAL_TYPE_P (TREE_TYPE (type)))\n \t  && !comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (value)),\n \t\t\t TYPE_MAIN_VARIANT (type))))\n     value = default_conversion (value);\n@@ -5776,7 +5786,7 @@ process_init_element (struct c_expr value)\n   if (string_flag\n       && constructor_type\n       && TREE_CODE (constructor_type) == ARRAY_TYPE\n-      && TREE_CODE (TREE_TYPE (constructor_type)) == INTEGER_TYPE\n+      && INTEGRAL_TYPE_P (TREE_TYPE (constructor_type))\n       && integer_zerop (constructor_unfilled_index))\n     {\n       if (constructor_stack->replacement_value.value)\n@@ -5855,7 +5865,7 @@ process_init_element (struct c_expr value)\n \t  /* Accept a string constant to initialize a subarray.  */\n \t  if (value.value != 0\n \t      && fieldcode == ARRAY_TYPE\n-\t      && TREE_CODE (TREE_TYPE (fieldtype)) == INTEGER_TYPE\n+\t      && INTEGRAL_TYPE_P (TREE_TYPE (fieldtype))\n \t      && string_flag)\n \t    value.value = orig_value;\n \t  /* Otherwise, if we have come to a subaggregate,\n@@ -5943,7 +5953,7 @@ process_init_element (struct c_expr value)\n \t  /* Accept a string constant to initialize a subarray.  */\n \t  if (value.value != 0\n \t      && fieldcode == ARRAY_TYPE\n-\t      && TREE_CODE (TREE_TYPE (fieldtype)) == INTEGER_TYPE\n+\t      && INTEGRAL_TYPE_P (TREE_TYPE (fieldtype))\n \t      && string_flag)\n \t    value.value = orig_value;\n \t  /* Otherwise, if we have come to a subaggregate,\n@@ -5983,7 +5993,7 @@ process_init_element (struct c_expr value)\n \t  /* Accept a string constant to initialize a subarray.  */\n \t  if (value.value != 0\n \t      && eltcode == ARRAY_TYPE\n-\t      && TREE_CODE (TREE_TYPE (elttype)) == INTEGER_TYPE\n+\t      && INTEGRAL_TYPE_P (TREE_TYPE (elttype))\n \t      && string_flag)\n \t    value.value = orig_value;\n \t  /* Otherwise, if we have come to a subaggregate,"}, {"sha": "7b0d645b8a3fb8de41aaf4deb76de96a50d5aa20", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197463ae905f0ce7c8dbeb298531a71855ac973e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197463ae905f0ce7c8dbeb298531a71855ac973e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=197463ae905f0ce7c8dbeb298531a71855ac973e", "patch": "@@ -1,3 +1,7 @@\n+2004-07-25  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* gcc.dg/init-string-2.c: New test.\n+\n 2004-07-24  Zack Weinberg  <zack@codesourcery.com>\n \n \tPR 16684"}, {"sha": "828897b3ca9f840f5dff7aea7b38fd366997021a", "filename": "gcc/testsuite/gcc.dg/init-string-2.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197463ae905f0ce7c8dbeb298531a71855ac973e/gcc%2Ftestsuite%2Fgcc.dg%2Finit-string-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197463ae905f0ce7c8dbeb298531a71855ac973e/gcc%2Ftestsuite%2Fgcc.dg%2Finit-string-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Finit-string-2.c?ref=197463ae905f0ce7c8dbeb298531a71855ac973e", "patch": "@@ -0,0 +1,56 @@\n+/* Character arrays but not arrays of compatible enum type may be\n+   initialized by narrow string literals.  Arrays of type compatible\n+   with wchar_t, including compatible enums, may be initialized by\n+   wide string literals.  Use -fshort-enums -fshort-wchar so the\n+   relevant circumstances can be obtained portably; may still fail if\n+   char, short and int do not all have distinct precisions.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -pedantic-errors -fshort-enums -fshort-wchar\" } */\n+\n+#include <limits.h>\n+#include <stddef.h>\n+\n+typedef enum { schar_min = SCHAR_MIN, schar_max = SCHAR_MAX } schar;\n+typedef enum { uchar_max = UCHAR_MAX } uchar;\n+typedef enum { shrt_min = SHRT_MIN, shrt_max = SHRT_MAX } sshrt;\n+typedef enum { ushrt_max = USHRT_MAX } ushrt;\n+\n+char a0[] = \"foo\";\n+const signed char a2[4] = \"foo\";\n+volatile unsigned char a3[3] = \"foo\";\n+wchar_t a4[] = L\"foo\";\n+const wchar_t a5[3] = L\"foo\";\n+volatile ushrt a6[] = L\"foo\";\n+\n+schar a7[] = \"foo\"; /* { dg-error \"string constant\" \"a7\" } */\n+uchar a8[] = \"foo\"; /* { dg-error \"string constant\" \"a8\" } */\n+const schar a9[] = \"foo\"; /* { dg-error \"string constant\" \"a9\" } */\n+short a10[] = L\"foo\"; /* { dg-error \"string constant\" \"a10\" } */\n+const sshrt a11[] = L\"foo\"; /* { dg-error \"string constant\" \"a11\" } */\n+char a12[] = L\"foo\"; /* { dg-error \"from wide string\" \"a12\" } */\n+wchar_t a13[] = \"foo\"; /* { dg-error \"non-wide string\" \"a13\" } */\n+\n+char b0[] = { \"foo\" };\n+const signed char b2[4] = { \"foo\" };\n+volatile unsigned char b3[3] = { \"foo\" };\n+wchar_t b4[] = { L\"foo\" };\n+const wchar_t b5[3] = { L\"foo\" };\n+volatile ushrt b6[] = { L\"foo\" };\n+\n+schar b7[] = { \"foo\" }; /* { dg-error \"string constant\" \"b7\" } */\n+uchar b8[] = { \"foo\" }; /* { dg-error \"string constant\" \"b8\" } */\n+const schar b9[] = { \"foo\" }; /* { dg-error \"string constant\" \"b9\" } */\n+short b10[] = { L\"foo\" }; /* { dg-error \"string constant\" \"b10\" } */\n+const sshrt b11[] = { L\"foo\" }; /* { dg-error \"string constant\" \"b11\" } */\n+char b12[] = { L\"foo\" }; /* { dg-error \"from wide string\" \"b12\" } */\n+wchar_t b13[] = { \"foo\" }; /* { dg-error \"non-wide string\" \"b13\" } */\n+\n+struct s { signed char a[10]; int b; ushrt c[10]; };\n+\n+struct s c = { \"foo\", 0, L\"bar\" };\n+struct s d = { .c = L\"bar\", .a = \"foo\" };\n+\n+ushrt *e = (ushrt [7]){ L\"bar\" };\n+\n+wchar_t f[5][5] = { L\"foo\", L\"bar\" };\n+ushrt g[5][5] = { L\"foo\", L\"bar\" };"}]}