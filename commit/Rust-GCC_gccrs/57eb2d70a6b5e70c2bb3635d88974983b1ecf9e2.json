{"sha": "57eb2d70a6b5e70c2bb3635d88974983b1ecf9e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdlYjJkNzBhNmI1ZTcwYzJiYjM2MzVkODg5NzQ5ODNiMWVjZjllMg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-09-18T18:27:44Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-09-18T18:27:44Z"}, "message": "Move diagnostic_show_locus and friends out into a new source file\n\ngcc/ChangeLog:\n\t* Makefile.in (OBJS-libcommon): Add diagnostic-show-locus.o.\n\t* diagnostic.c (adjust_line): Move to diagnostic-show-locus.c.\n\t(diagnostic_show_locus): Likewise.\n\t(diagnostic_print_caret_line): Likewise.\n\t* diagnostic-show-locus.c: New file.\n\nFrom-SVN: r227915", "tree": {"sha": "8eca66b6e10f1f96b3d49a6713fb5c38b0ba88f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8eca66b6e10f1f96b3d49a6713fb5c38b0ba88f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57eb2d70a6b5e70c2bb3635d88974983b1ecf9e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57eb2d70a6b5e70c2bb3635d88974983b1ecf9e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57eb2d70a6b5e70c2bb3635d88974983b1ecf9e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57eb2d70a6b5e70c2bb3635d88974983b1ecf9e2/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "54f0c25b302b081f8fa90766586a684325cb6102", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54f0c25b302b081f8fa90766586a684325cb6102", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54f0c25b302b081f8fa90766586a684325cb6102"}], "stats": {"total": 306, "additions": 176, "deletions": 130}, "files": [{"sha": "830ce8cbe12449acc348c9d2995e37504bd76c87", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57eb2d70a6b5e70c2bb3635d88974983b1ecf9e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57eb2d70a6b5e70c2bb3635d88974983b1ecf9e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57eb2d70a6b5e70c2bb3635d88974983b1ecf9e2", "patch": "@@ -1,3 +1,11 @@\n+2015-09-18  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (OBJS-libcommon): Add diagnostic-show-locus.o.\n+\t* diagnostic.c (adjust_line): Move to diagnostic-show-locus.c.\n+\t(diagnostic_show_locus): Likewise.\n+\t(diagnostic_print_caret_line): Likewise.\n+\t* diagnostic-show-locus.c: New file.\n+\n 2015-09-18  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* dwarf2out.c (switch_to_eh_frame_section): Add ATTRIBUTE_UNUSED to"}, {"sha": "009c745a0c864ac0cf97c197eb330a4006637e3a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57eb2d70a6b5e70c2bb3635d88974983b1ecf9e2/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57eb2d70a6b5e70c2bb3635d88974983b1ecf9e2/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=57eb2d70a6b5e70c2bb3635d88974983b1ecf9e2", "patch": "@@ -1516,7 +1516,8 @@ OBJS = \\\n \n # Objects in libcommon.a, potentially used by all host binaries and with\n # no target dependencies.\n-OBJS-libcommon = diagnostic.o diagnostic-color.o pretty-print.o intl.o \\\n+OBJS-libcommon = diagnostic.o diagnostic-color.o diagnostic-show-locus.o \\\n+\tpretty-print.o intl.o \\\n \tvec.o input.o version.o hash-table.o ggc-none.o memory-block.o\n \n # Objects in libcommon-target.a, used by drivers and by the core"}, {"sha": "147a2b8b71d48f6cdbf81ab73954a39014e23c05", "filename": "gcc/diagnostic-show-locus.c", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57eb2d70a6b5e70c2bb3635d88974983b1ecf9e2/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57eb2d70a6b5e70c2bb3635d88974983b1ecf9e2/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=57eb2d70a6b5e70c2bb3635d88974983b1ecf9e2", "patch": "@@ -0,0 +1,166 @@\n+/* Diagnostic subroutines for printing source-code\n+   Copyright (C) 1999-2015 Free Software Foundation, Inc.\n+   Contributed by Gabriel Dos Reis <gdr@codesourcery.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"version.h\"\n+#include \"demangle.h\"\n+#include \"intl.h\"\n+#include \"backtrace.h\"\n+#include \"diagnostic.h\"\n+#include \"diagnostic-color.h\"\n+\n+#ifdef HAVE_TERMIOS_H\n+# include <termios.h>\n+#endif\n+\n+#ifdef GWINSZ_IN_SYS_IOCTL\n+# include <sys/ioctl.h>\n+#endif\n+\n+/* If LINE is longer than MAX_WIDTH, and COLUMN is not smaller than\n+   MAX_WIDTH by some margin, then adjust the start of the line such\n+   that the COLUMN is smaller than MAX_WIDTH minus the margin.  The\n+   margin is either CARET_LINE_MARGIN characters or the difference\n+   between the column and the length of the line, whatever is smaller.\n+   The length of LINE is given by LINE_WIDTH.  */\n+static const char *\n+adjust_line (const char *line, int line_width,\n+\t     int max_width, int *column_p)\n+{\n+  int right_margin = CARET_LINE_MARGIN;\n+  int column = *column_p;\n+\n+  gcc_checking_assert (line_width >= column);\n+  right_margin = MIN (line_width - column, right_margin);\n+  right_margin = max_width - right_margin;\n+  if (line_width >= max_width && column > right_margin)\n+    {\n+      line += column - right_margin;\n+      *column_p = right_margin;\n+    }\n+  return line;\n+}\n+\n+/* Print the physical source line corresponding to the location of\n+   this diagnostic, and a caret indicating the precise column.  This\n+   function only prints two caret characters if the two locations\n+   given by DIAGNOSTIC are on the same line according to\n+   diagnostic_same_line().  */\n+void\n+diagnostic_show_locus (diagnostic_context * context,\n+\t\t       const diagnostic_info *diagnostic)\n+{\n+  if (!context->show_caret\n+      || diagnostic_location (diagnostic, 0) <= BUILTINS_LOCATION\n+      || diagnostic_location (diagnostic, 0) == context->last_location)\n+    return;\n+\n+  context->last_location = diagnostic_location (diagnostic, 0);\n+  expanded_location s0 = diagnostic_expand_location (diagnostic, 0);\n+  expanded_location s1 = { };\n+  /* Zero-initialized. This is checked later by diagnostic_print_caret_line.  */\n+\n+  if (diagnostic_location (diagnostic, 1) > BUILTINS_LOCATION)\n+    s1 = diagnostic_expand_location (diagnostic, 1);\n+\n+  diagnostic_print_caret_line (context, s0, s1,\n+\t\t\t       context->caret_chars[0],\n+\t\t\t       context->caret_chars[1]);\n+}\n+\n+/* Print (part) of the source line given by xloc1 with caret1 pointing\n+   at the column.  If xloc2.column != 0 and it fits within the same\n+   line as xloc1 according to diagnostic_same_line (), then caret2 is\n+   printed at xloc2.colum.  Otherwise, the caller has to set up things\n+   to print a second caret line for xloc2.  */\n+void\n+diagnostic_print_caret_line (diagnostic_context * context,\n+\t\t\t     expanded_location xloc1,\n+\t\t\t     expanded_location xloc2,\n+\t\t\t     char caret1, char caret2)\n+{\n+  if (!diagnostic_same_line (context, xloc1, xloc2))\n+    /* This will mean ignore xloc2.  */\n+    xloc2.column = 0;\n+  else if (xloc1.column == xloc2.column)\n+    xloc2.column++;\n+\n+  int cmax = MAX (xloc1.column, xloc2.column);\n+  int line_width;\n+  const char *line = location_get_source_line (xloc1.file, xloc1.line,\n+\t\t\t\t\t       &line_width);\n+  if (line == NULL || cmax > line_width)\n+    return;\n+\n+  /* Center the interesting part of the source line to fit in\n+     max_width, and adjust all columns accordingly.  */\n+  int max_width = context->caret_max_width;\n+  int offset = (int) cmax;\n+  line = adjust_line (line, line_width, max_width, &offset);\n+  offset -= cmax;\n+  cmax += offset;\n+  xloc1.column += offset;\n+  if (xloc2.column)\n+    xloc2.column += offset;\n+\n+  /* Print the source line.  */\n+  pp_newline (context->printer);\n+  const char *saved_prefix = pp_get_prefix (context->printer);\n+  pp_set_prefix (context->printer, NULL);\n+  pp_space (context->printer);\n+  while (max_width > 0 && line_width > 0)\n+    {\n+      char c = *line == '\\t' ? ' ' : *line;\n+      if (c == '\\0')\n+\tc = ' ';\n+      pp_character (context->printer, c);\n+      max_width--;\n+      line_width--;\n+      line++;\n+    }\n+  pp_newline (context->printer);\n+\n+  /* Print the caret under the line.  */\n+  const char *caret_cs, *caret_ce;\n+  caret_cs = colorize_start (pp_show_color (context->printer), \"caret\");\n+  caret_ce = colorize_stop (pp_show_color (context->printer));\n+  int cmin = xloc2.column\n+    ? MIN (xloc1.column, xloc2.column) : xloc1.column;\n+  int caret_min = cmin == xloc1.column ? caret1 : caret2;\n+  int caret_max = cmin == xloc1.column ? caret2 : caret1;\n+\n+  /* cmin is >= 1, but we indent with an extra space at the start like\n+     we did above.  */\n+  int i;\n+  for (i = 0; i < cmin; i++)\n+    pp_space (context->printer);\n+  pp_printf (context->printer, \"%s%c%s\", caret_cs, caret_min, caret_ce);\n+\n+  if (xloc2.column)\n+    {\n+      for (i++; i < cmax; i++)\n+\tpp_space (context->printer);\n+      pp_printf (context->printer, \"%s%c%s\", caret_cs, caret_max, caret_ce);\n+    }\n+  pp_set_prefix (context->printer, saved_prefix);\n+  pp_needs_newline (context->printer) = true;\n+}"}, {"sha": "831859a6c634c7c00f330540ec0a6ba49022beb0", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57eb2d70a6b5e70c2bb3635d88974983b1ecf9e2/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57eb2d70a6b5e70c2bb3635d88974983b1ecf9e2/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=57eb2d70a6b5e70c2bb3635d88974983b1ecf9e2", "patch": "@@ -307,135 +307,6 @@ diagnostic_build_prefix (diagnostic_context *context,\n \t\t\t     locus_ce, text_cs, text, text_ce));\n }\n \n-/* If LINE is longer than MAX_WIDTH, and COLUMN is not smaller than\n-   MAX_WIDTH by some margin, then adjust the start of the line such\n-   that the COLUMN is smaller than MAX_WIDTH minus the margin.  The\n-   margin is either CARET_LINE_MARGIN characters or the difference\n-   between the column and the length of the line, whatever is smaller.\n-   The length of LINE is given by LINE_WIDTH.  */\n-static const char *\n-adjust_line (const char *line, int line_width,\n-\t     int max_width, int *column_p)\n-{\n-  int right_margin = CARET_LINE_MARGIN;\n-  int column = *column_p;\n-\n-  gcc_checking_assert (line_width >= column);\n-  right_margin = MIN (line_width - column, right_margin);\n-  right_margin = max_width - right_margin;\n-  if (line_width >= max_width && column > right_margin)\n-    {\n-      line += column - right_margin;\n-      *column_p = right_margin;\n-    }\n-  return line;\n-}\n-\n-/* Print the physical source line corresponding to the location of\n-   this diagnostic, and a caret indicating the precise column.  This\n-   function only prints two caret characters if the two locations\n-   given by DIAGNOSTIC are on the same line according to\n-   diagnostic_same_line().  */\n-void\n-diagnostic_show_locus (diagnostic_context * context,\n-\t\t       const diagnostic_info *diagnostic)\n-{\n-  if (!context->show_caret\n-      || diagnostic_location (diagnostic, 0) <= BUILTINS_LOCATION\n-      || diagnostic_location (diagnostic, 0) == context->last_location)\n-    return;\n-\n-  context->last_location = diagnostic_location (diagnostic, 0);\n-  expanded_location s0 = diagnostic_expand_location (diagnostic, 0);\n-  expanded_location s1 = { }; \n-  /* Zero-initialized. This is checked later by diagnostic_print_caret_line.  */\n-\n-  if (diagnostic_location (diagnostic, 1) > BUILTINS_LOCATION)\n-    s1 = diagnostic_expand_location (diagnostic, 1);\n-\n-  diagnostic_print_caret_line (context, s0, s1,\n-\t\t\t       context->caret_chars[0],\n-\t\t\t       context->caret_chars[1]);\n-}\n-\n-/* Print (part) of the source line given by xloc1 with caret1 pointing\n-   at the column.  If xloc2.column != 0 and it fits within the same\n-   line as xloc1 according to diagnostic_same_line (), then caret2 is\n-   printed at xloc2.colum.  Otherwise, the caller has to set up things\n-   to print a second caret line for xloc2.  */\n-void\n-diagnostic_print_caret_line (diagnostic_context * context,\n-\t\t\t     expanded_location xloc1,\n-\t\t\t     expanded_location xloc2,\n-\t\t\t     char caret1, char caret2)\n-{\n-  if (!diagnostic_same_line (context, xloc1, xloc2))\n-    /* This will mean ignore xloc2.  */\n-    xloc2.column = 0;\n-  else if (xloc1.column == xloc2.column)\n-    xloc2.column++;\n-  \n-  int cmax = MAX (xloc1.column, xloc2.column);\n-  int line_width;\n-  const char *line = location_get_source_line (xloc1.file, xloc1.line,\n-\t\t\t\t\t       &line_width);\n-  if (line == NULL || cmax > line_width)\n-    return;\n-\n-  /* Center the interesting part of the source line to fit in\n-     max_width, and adjust all columns accordingly.  */\n-  int max_width = context->caret_max_width;\n-  int offset = (int) cmax;\n-  line = adjust_line (line, line_width, max_width, &offset);\n-  offset -= cmax;\n-  cmax += offset;\n-  xloc1.column += offset;\n-  if (xloc2.column)\n-    xloc2.column += offset;\n-\n-  /* Print the source line.  */\n-  pp_newline (context->printer);\n-  const char *saved_prefix = pp_get_prefix (context->printer);\n-  pp_set_prefix (context->printer, NULL);\n-  pp_space (context->printer);\n-  while (max_width > 0 && line_width > 0)\n-    {\n-      char c = *line == '\\t' ? ' ' : *line;\n-      if (c == '\\0')\n-\tc = ' ';\n-      pp_character (context->printer, c);\n-      max_width--;\n-      line_width--;\n-      line++;\n-    }\n-  pp_newline (context->printer);\n-\n-  /* Print the caret under the line.  */\n-  const char *caret_cs, *caret_ce;\n-  caret_cs = colorize_start (pp_show_color (context->printer), \"caret\");\n-  caret_ce = colorize_stop (pp_show_color (context->printer));\n-  int cmin = xloc2.column \n-    ? MIN (xloc1.column, xloc2.column) : xloc1.column;\n-  int caret_min = cmin == xloc1.column ? caret1 : caret2;\n-  int caret_max = cmin == xloc1.column ? caret2 : caret1;\n-\n-  /* cmin is >= 1, but we indent with an extra space at the start like\n-     we did above.  */\n-  int i;\n-  for (i = 0; i < cmin; i++)\n-    pp_space (context->printer);\n-  pp_printf (context->printer, \"%s%c%s\", caret_cs, caret_min, caret_ce);\n-\n-  if (xloc2.column)\n-    {\n-      for (i++; i < cmax; i++)\n-\tpp_space (context->printer);\n-      pp_printf (context->printer, \"%s%c%s\", caret_cs, caret_max, caret_ce);\n-    }\n-  pp_set_prefix (context->printer, saved_prefix);\n-  pp_needs_newline (context->printer) = true;\n-}\n-\n /* Functions at which to stop the backtrace print.  It's not\n    particularly helpful to print the callers of these functions.  */\n "}]}