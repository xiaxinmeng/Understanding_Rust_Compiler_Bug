{"sha": "9577319f92093cc58c718a8cbf806e3ee505e52e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU3NzMxOWY5MjA5M2NjNThjNzE4YThjYmY4MDZlM2VlNTA1ZTUyZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-04-17T15:29:46Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-04-17T15:29:46Z"}, "message": "decl2.c (lang_decode_option): -fnew-abi implies -fvtable-thunks.\n\n\t* decl2.c (lang_decode_option): -fnew-abi implies -fvtable-thunks.\n\t* typeck.c (comp_target_types): Tweak pedantic case.\n\t(comp_target_parms): Tweak pedantic case.  Clean up somewhat.\n\tReturn -1 or 1 instead of 1 or 2.\n\t(compparms): Remove STRICT handling.\n\t* typeck.c (comp_target_types): Handle references like pointers.\n\t(comp_target_parms): Note that return code from comp_target_types\n\tcan be negative to indicate failure.\n\nFrom-SVN: r19268", "tree": {"sha": "c3ff8d9a4748a33553f5b392148ee77867404117", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3ff8d9a4748a33553f5b392148ee77867404117"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9577319f92093cc58c718a8cbf806e3ee505e52e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9577319f92093cc58c718a8cbf806e3ee505e52e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9577319f92093cc58c718a8cbf806e3ee505e52e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9577319f92093cc58c718a8cbf806e3ee505e52e/comments", "author": null, "committer": null, "parents": [{"sha": "77e6b0eb6094880a5989fbd87a09fc772f73f575", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77e6b0eb6094880a5989fbd87a09fc772f73f575", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77e6b0eb6094880a5989fbd87a09fc772f73f575"}], "stats": {"total": 149, "additions": 64, "deletions": 85}, "files": [{"sha": "d15bc1acf0eddda9ec4acde8fa65147f6062d079", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9577319f92093cc58c718a8cbf806e3ee505e52e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9577319f92093cc58c718a8cbf806e3ee505e52e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9577319f92093cc58c718a8cbf806e3ee505e52e", "patch": "@@ -1,3 +1,18 @@\n+Fri Apr 17 14:30:45 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c (lang_decode_option): -fnew-abi implies -fvtable-thunks.\n+\n+\t* typeck.c (comp_target_types): Tweak pedantic case.\n+\t(comp_target_parms): Tweak pedantic case.  Clean up somewhat.\n+\tReturn -1 or 1 instead of 1 or 2.\n+\t(compparms): Remove STRICT handling.\n+\n+Fri Apr 17 14:04:16 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* typeck.c (comp_target_types): Handle references like pointers.\n+\t(comp_target_parms): Note that return code from comp_target_types\n+\tcan be negative to indicate failure.\n+\n Fri Apr 17 09:10:52 1998  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>\n \n \t* Make-lang.in (c++.all.build): Don't depend on $(DEMANGLER_PROG),\n@@ -51,15 +66,15 @@ Fri Apr 17 00:45:12 1998  Mark Mitchell  <mmitchell@usa.net>\n \t* typeck2.c (process_init_constructor): Don't strip cv-qualifiers\n \twhen doing initializations.\n \n+\t* pt.c (unify): Use comptypes to compare type args.\n+\n Fri Apr 17 00:24:22 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (duplicate_decls): Fix check for when it's safe to free\n \tthe new decl.\n \n \t* pt.c (mangle_class_name_for_template): Don't pass a typedef type\n \tto type_as_string.\n-\tFrom Mark Mitchell:\n-\t(unify): Use comptypes to compare type args.\n \n Thu Apr 16 17:47:30 1998  Jeffrey A Law  (law@cygnus.com)\n "}, {"sha": "8f0c95499f275d1ca647edb1cc099ae574ef0f6e", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9577319f92093cc58c718a8cbf806e3ee505e52e/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9577319f92093cc58c718a8cbf806e3ee505e52e/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9577319f92093cc58c718a8cbf806e3ee505e52e", "patch": "@@ -571,6 +571,7 @@ lang_decode_option (p)\n \t{\n \t  flag_new_abi = 1;\n \t  flag_do_squangling = 1;\n+\t  flag_vtable_thunks = 1;\n \t}\n       else if (!strcmp (p, \"no-new-abi\"))\n \t{"}, {"sha": "de021ea6c2a9c52dc6b3b3efd822e4a8b27d77c6", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 46, "deletions": 83, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9577319f92093cc58c718a8cbf806e3ee505e52e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9577319f92093cc58c718a8cbf806e3ee505e52e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9577319f92093cc58c718a8cbf806e3ee505e52e", "patch": "@@ -877,7 +877,10 @@ comptypes (type1, type2, strict)\n \n    NPTRS is the number of pointers we can strip off and keep cool.\n    This is used to permit (for aggr A, aggr B) A, B* to convert to A*,\n-   but to not permit B** to convert to A**.  */\n+   but to not permit B** to convert to A**.\n+\n+   This should go away.  Callers should use can_convert or something\n+   similar instead.  (jason 17 Apr 1997)  */\n \n int\n comp_target_types (ttl, ttr, nptrs)\n@@ -892,12 +895,13 @@ comp_target_types (ttl, ttr, nptrs)\n   if (TREE_CODE (ttr) != TREE_CODE (ttl))\n     return 0;\n \n-  if (TREE_CODE (ttr) == POINTER_TYPE)\n+  if (TREE_CODE (ttr) == POINTER_TYPE\n+      || (TREE_CODE (ttr) == REFERENCE_TYPE))\n     {\n       ttl = TREE_TYPE (ttl);\n       ttr = TREE_TYPE (ttr);\n \n-      if (nptrs > 0)\n+      if (nptrs > 0 && TREE_CODE (ttr) == POINTER_TYPE)\n \t{\n \t  if (TREE_CODE (ttl) == UNKNOWN_TYPE\n \t      || TREE_CODE (ttr) == UNKNOWN_TYPE)\n@@ -949,27 +953,23 @@ comp_target_types (ttl, ttr, nptrs)\n       }\n     }\n \n-  if (TREE_CODE (ttr) == REFERENCE_TYPE)\n-    return comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), nptrs);\n   if (TREE_CODE (ttr) == ARRAY_TYPE)\n     return comp_array_types (comp_target_types, ttl, ttr, 0);\n   else if (TREE_CODE (ttr) == FUNCTION_TYPE || TREE_CODE (ttr) == METHOD_TYPE)\n     {\n-      if (comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), -1))\n-\tswitch (comp_target_parms (TYPE_ARG_TYPES (ttl),\n-\t\t\t\t   TYPE_ARG_TYPES (ttr), 1))\n-\t  {\n-\t  case 0:\n+      if (pedantic)\n+\t{\n+\t  if (comptypes (TREE_TYPE (ttl), TREE_TYPE (ttr), 1) == 0)\n \t    return 0;\n-\t  case 1:\n-\t    return 1;\n-\t  case 2:\n-\t    return -1;\n-\t  default:\n-\t    my_friendly_abort (112);\n-\t  }\n+\t}\n       else\n-\treturn 0;\n+\t{\n+\t  if (comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), -1) == 0)\n+\t    return 0;\n+\t}\n+\n+      return comp_target_parms (TYPE_ARG_TYPES (ttl),\n+\t\t\t\tTYPE_ARG_TYPES (ttr), 1);\n     }\n   /* for C++ */\n   else if (TREE_CODE (ttr) == OFFSET_TYPE)\n@@ -1059,9 +1059,9 @@ common_base_type (tt1, tt2)\n    If either list is empty, we win.\n    Otherwise, the two lists must be equivalent, element by element.\n \n-   C++: See comment above about TYPE1, TYPE2, STRICT.\n-   If STRICT == 3, it means checking is strict, but do not compare\n-   default parameter values.  */\n+   C++: See comment above about TYPE1, TYPE2.\n+\n+   STRICT is no longer used.  */\n \n int\n compparms (parms1, parms2, strict)\n@@ -1073,42 +1073,30 @@ compparms (parms1, parms2, strict)\n   /* An unspecified parmlist matches any specified parmlist\n      whose argument types don't need default promotions.  */\n \n-  if (strict <= 0 && t1 == 0)\n-\treturn self_promoting_args_p (t2);\n-  if (strict < 0 && t2 == 0)\n-\treturn self_promoting_args_p (t1);\n-\n   while (1)\n     {\n       if (t1 == 0 && t2 == 0)\n \treturn 1;\n       /* If one parmlist is shorter than the other,\n-\t they fail to match, unless STRICT is <= 0.  */\n+\t they fail to match.  */\n       if (t1 == 0 || t2 == 0)\n-\t{\n-\t  if (strict > 0)\n-\t    return 0;\n-\t  if (strict < 0)\n-\t    return 1;\n-\t  if (strict == 0)\n-\t    return t1 && TREE_PURPOSE (t1);\n-\t}\n-      if (! comptypes (TREE_VALUE (t2), TREE_VALUE (t1), strict))\n-\t{\n-\t  if (strict > 0)\n-\t    return 0;\n-\t  if (strict == 0)\n-\t    return t2 == void_list_node && TREE_PURPOSE (t1);\n-\t  return TREE_PURPOSE (t1) || TREE_PURPOSE (t2);\n-\t}\n+\treturn 0;\n+      if (! comptypes (TREE_VALUE (t2), TREE_VALUE (t1), 1))\n+\treturn 0;\n \n       t1 = TREE_CHAIN (t1);\n       t2 = TREE_CHAIN (t2);\n     }\n }\n \n /* This really wants return whether or not parameter type lists\n-   would make their owning functions assignment compatible or not.  */\n+   would make their owning functions assignment compatible or not.\n+\n+   The return value is like for comp_target_types.\n+\n+   This should go away, possibly with the exception of the empty parmlist\n+   conversion; there are no conversions between function types in C++.\n+   (jason 17 Apr 1997)  */\n \n static int\n comp_target_parms (parms1, parms2, strict)\n@@ -1118,9 +1106,9 @@ comp_target_parms (parms1, parms2, strict)\n   register tree t1 = parms1, t2 = parms2;\n   int warn_contravariance = 0;\n \n-  /* An unspecified parmlist matches any specified parmlist\n-     whose argument types don't need default promotions.\n-     @@@ see 13.3.3 for a counterexample...  */\n+  /* In C, an unspecified parmlist matches any specified parmlist\n+     whose argument types don't need default promotions.  This is not\n+     true for C++, but let's do it anyway for unfixed headers.  */\n \n   if (t1 == 0 && t2 != 0)\n     {\n@@ -1147,9 +1135,12 @@ comp_target_parms (parms1, parms2, strict)\n \t}\n       p1 = TREE_VALUE (t1);\n       p2 = TREE_VALUE (t2);\n-      if (p1 == p2)\n+      if (comptypes (p1, p2, 1))\n \tcontinue;\n \n+      if (pedantic)\n+\treturn 0;\n+\n       if ((TREE_CODE (p1) == POINTER_TYPE && TREE_CODE (p2) == POINTER_TYPE)\n \t  || (TREE_CODE (p1) == REFERENCE_TYPE\n \t      && TREE_CODE (p2) == REFERENCE_TYPE))\n@@ -1170,52 +1161,24 @@ comp_target_parms (parms1, parms2, strict)\n \t    }\n \t  if (IS_AGGR_TYPE (TREE_TYPE (p1)))\n \t    {\n-\t      if (comptypes (p2, p1, 0) == 0)\n-\t\t{\n-\t\t  if (comptypes (p1, p2, 0) != 0)\n-\t\t    warn_contravariance = 1;\n-\t\t  else\n-\t\t    return 0;\n-\t\t}\n-\t      continue;\n+\t      if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (p1)),\n+\t\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (p2)), 1) == 0)\n+\t\treturn 0;\n \t    }\n \t}\n       /* Note backwards order due to contravariance.  */\n-      if (comp_target_types (p2, p1, 1) == 0)\n+      if (comp_target_types (p2, p1, 1) <= 0)\n \t{\n-\t  if (comp_target_types (p1, p2, 1))\n+\t  if (comp_target_types (p1, p2, 1) > 0)\n \t    {\n \t      warn_contravariance = 1;\n \t      continue;\n \t    }\n \t  if (strict != 0)\n \t    return 0;\n \t}\n-      /* Target types are compatible--just make sure that if\n-\t we use parameter lists, that they are ok as well.  */\n-      if (TREE_CODE (p1) == FUNCTION_TYPE || TREE_CODE (p1) == METHOD_TYPE)\n-\tswitch (comp_target_parms (TYPE_ARG_TYPES (p1),\n-\t\t\t\t   TYPE_ARG_TYPES (p2),\n-\t\t\t\t   strict))\n-\t  {\n-\t  case 0:\n-\t    return 0;\n-\t  case 1:\n-\t    break;\n-\t  case 2:\n-\t    warn_contravariance = 1;\n-\t  }\n-\n-      if (TREE_PURPOSE (t1) && TREE_PURPOSE (t2))\n-\t{\n-\t  int cmp = simple_cst_equal (TREE_PURPOSE (t1), TREE_PURPOSE (t2));\n-\t  if (cmp < 0)\n-\t    my_friendly_abort (114);\n-\t  if (cmp == 0)\n-\t    return 0;\n-\t}\n     }\n-  return 1 + warn_contravariance;\n+  return warn_contravariance ? -1 : 1;\n }\n \n /* Return 1 if PARMS specifies a fixed number of parameters\n@@ -6876,7 +6839,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n     {\n       tree ttl = TYPE_PTRMEMFUNC_FN_TYPE (type);\n       tree ttr = (TREE_CODE (rhstype) == POINTER_TYPE ? rhstype\n-\t\t    : TYPE_PTRMEMFUNC_FN_TYPE (type));\n+\t\t  : TYPE_PTRMEMFUNC_FN_TYPE (rhstype));\n       int ctt = comp_target_types (ttl, ttr, 1);\n \n       if (ctt < 0)"}]}