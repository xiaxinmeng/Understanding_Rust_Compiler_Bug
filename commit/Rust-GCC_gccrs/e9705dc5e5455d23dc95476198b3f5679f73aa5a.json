{"sha": "e9705dc5e5455d23dc95476198b3f5679f73aa5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk3MDVkYzVlNTQ1NWQyM2RjOTU0NzYxOThiM2Y1Njc5ZjczYWE1YQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2007-10-06T11:43:56Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2007-10-06T11:43:56Z"}, "message": "re PR tree-optimization/33572 (wrong code with -O)\n\ngcc/ChangeLog:\nPR tree-optimization/33572\n* tree-cfg.c (verify_stmts): Check for missing PHI defs.\n* tree-inline.c (update_ssa_across_eh_edges): Renamed to...\n(update_ssa_across_abnormal_edges): ... this.  Set slots in the\nreturn PHI node.\n(copy_edges_for_bb): Handle nonlocal label edges.\n(make_nonlocal_label_edges): Deleted.\n(optimize_inline_calls): Don't call it.\ngcc/testsuite/ChangeLog:\nPR tree-optimization/33572\n* g++.dg/torture/pr33572.C: New.\n\nFrom-SVN: r129051", "tree": {"sha": "1cd6bcc5b4ac6c6236e9743d63e7db677cea72c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cd6bcc5b4ac6c6236e9743d63e7db677cea72c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9705dc5e5455d23dc95476198b3f5679f73aa5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9705dc5e5455d23dc95476198b3f5679f73aa5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9705dc5e5455d23dc95476198b3f5679f73aa5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9705dc5e5455d23dc95476198b3f5679f73aa5a/comments", "author": null, "committer": null, "parents": [{"sha": "ac5ba373739e0fbfd2385e5fa427629ce328e718", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac5ba373739e0fbfd2385e5fa427629ce328e718", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac5ba373739e0fbfd2385e5fa427629ce328e718"}], "stats": {"total": 185, "additions": 112, "deletions": 73}, "files": [{"sha": "db4e33e8873e1ea912c5793ac19da2abf28bf1de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9705dc5e5455d23dc95476198b3f5679f73aa5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9705dc5e5455d23dc95476198b3f5679f73aa5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9705dc5e5455d23dc95476198b3f5679f73aa5a", "patch": "@@ -1,3 +1,14 @@\n+2007-10-06  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR tree-optimization/33572\n+\t* tree-cfg.c (verify_stmts): Check for missing PHI defs.\n+\t* tree-inline.c (update_ssa_across_eh_edges): Renamed to...\n+\t(update_ssa_across_abnormal_edges): ... this.  Set slots in the\n+\treturn PHI node.\n+\t(copy_edges_for_bb): Handle nonlocal label edges.\n+\t(make_nonlocal_label_edges): Deleted.\n+\t(optimize_inline_calls): Don't call it.\n+\n 2007-10-05  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* gthr-single.h: Revert last change."}, {"sha": "5ce628947e585383e32fedaaf491bf387501d58f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9705dc5e5455d23dc95476198b3f5679f73aa5a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9705dc5e5455d23dc95476198b3f5679f73aa5a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e9705dc5e5455d23dc95476198b3f5679f73aa5a", "patch": "@@ -1,3 +1,8 @@\n+2007-10-06  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR tree-optimization/33572\n+\t* g++.dg/torture/pr33572.C: New.\n+\n 2007-10-06  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n \n \tPR fortran/25076"}, {"sha": "27557cd13b8d1efe39135b89a926347e40837623", "filename": "gcc/testsuite/g++.dg/torture/pr33572.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9705dc5e5455d23dc95476198b3f5679f73aa5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr33572.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9705dc5e5455d23dc95476198b3f5679f73aa5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr33572.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr33572.C?ref=e9705dc5e5455d23dc95476198b3f5679f73aa5a", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do run }\n+namespace __gnu_cxx {\n+\ttemplate<bool> struct __pool {\n+\t\tvoid _M_reclaim_block(char* p, unsigned long bytes);\n+\t};\n+}\n+\n+struct vector {\n+\t~vector() { deallocate(0); }\n+\tvoid deallocate(int* p) {\n+\t\tif (p) {\n+\t\t\tstatic __gnu_cxx::__pool<true> pool;\n+\t\t\tpool._M_reclaim_block((char*)0, 0);\n+\t\t}\n+\t}\n+};\n+\n+struct Foo { virtual void f() { } };\n+\n+struct auto_ptr {\n+\tFoo* ptr;\n+\tauto_ptr() : ptr(0) { }\n+\t~auto_ptr() { delete ptr; }\n+\tFoo* release() { Foo* tmp = ptr; ptr = 0; return tmp; }\n+\tvoid reset(Foo* p) { ptr = p; }\n+};\n+\n+int main(int argc, char**) {\n+\tauto_ptr foo;\n+\tif (argc) {\n+\t\tfoo.reset(new Foo());\n+\t} else {\n+\t\tvector v;\n+\t}\n+\tFoo* p = foo.release();\n+\tp->f();\n+}"}, {"sha": "dd817adcbba088eb669822fa5f3c6d27874a6205", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9705dc5e5455d23dc95476198b3f5679f73aa5a/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9705dc5e5455d23dc95476198b3f5679f73aa5a/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=e9705dc5e5455d23dc95476198b3f5679f73aa5a", "patch": "@@ -4279,11 +4279,18 @@ verify_stmts (void)\n \t      tree t = PHI_ARG_DEF (phi, i);\n \t      tree addr;\n \n+\t      if (!t)\n+\t\t{\n+\t\t  error (\"missing PHI def\");\n+\t\t  debug_generic_stmt (phi);\n+\t\t  err |= true;\n+\t\t  continue;\n+\t\t}\n \t      /* Addressable variables do have SSA_NAMEs but they\n \t\t are not considered gimple values.  */\n-\t      if (TREE_CODE (t) != SSA_NAME\n-\t\t  && TREE_CODE (t) != FUNCTION_DECL\n-\t\t  && !is_gimple_val (t))\n+\t      else if (TREE_CODE (t) != SSA_NAME\n+\t\t       && TREE_CODE (t) != FUNCTION_DECL\n+\t\t       && !is_gimple_val (t))\n \t\t{\n \t\t  error (\"PHI def is not a GIMPLE value\");\n \t\t  debug_generic_stmt (phi);"}, {"sha": "88c615861b47471fe591c6e810720e30a6b29d60", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 49, "deletions": 70, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9705dc5e5455d23dc95476198b3f5679f73aa5a/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9705dc5e5455d23dc95476198b3f5679f73aa5a/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=e9705dc5e5455d23dc95476198b3f5679f73aa5a", "patch": "@@ -1009,16 +1009,19 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale, int count_scal\n    across EH edges from basic block within inlined functions destinating\n    to landing pads in function we inline into.\n \n-   The function mark PHI_RESULT of such PHI nodes for renaming; it is\n-   safe the EH edges are abnormal and SSA_NAME_OCCURS_IN_ABNORMAL_PHI\n-   must be set.  This means, that there will be no overlapping live ranges\n+   The function fills in PHI_RESULTs of such PHI nodes if they refer\n+   to gimple regs.  Otherwise, the function mark PHI_RESULT of such\n+   PHI nodes for renaming.  For non-gimple regs, renaming is safe: the\n+   EH edges are abnormal and SSA_NAME_OCCURS_IN_ABNORMAL_PHI must be\n+   set, and this means that there will be no overlapping live ranges\n    for the underlying symbol.\n \n    This might change in future if we allow redirecting of EH edges and\n    we might want to change way build CFG pre-inlining to include\n    all the possible edges then.  */\n static void\n-update_ssa_across_eh_edges (basic_block bb)\n+update_ssa_across_abnormal_edges (basic_block bb, basic_block ret_bb,\n+\t\t\t\t  bool can_throw, bool nonlocal_goto)\n {\n   edge e;\n   edge_iterator ei;\n@@ -1029,13 +1032,35 @@ update_ssa_across_eh_edges (basic_block bb)\n       {\n \ttree phi;\n \n-\tgcc_assert (e->flags & EDGE_EH);\n+\tgcc_assert (e->flags & EDGE_ABNORMAL);\n+\tif (!nonlocal_goto)\n+\t  gcc_assert (e->flags & EDGE_EH);\n+\tif (!can_throw)\n+\t  gcc_assert (!(e->flags & EDGE_EH));\n \tfor (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n \t  {\n+\t    edge re;\n+\n+\t    /* There shouldn't be any PHI nodes in the ENTRY_BLOCK.  */\n+\t    gcc_assert (!e->dest->aux);\n+\n \t    gcc_assert (SSA_NAME_OCCURS_IN_ABNORMAL_PHI\n \t\t\t(PHI_RESULT (phi)));\n-\t    mark_sym_for_renaming\n-\t      (SSA_NAME_VAR (PHI_RESULT (phi)));\n+\n+\t    if (!is_gimple_reg (PHI_RESULT (phi)))\n+\t      {\n+\t\tmark_sym_for_renaming\n+\t\t  (SSA_NAME_VAR (PHI_RESULT (phi)));\n+\t\tcontinue;\n+\t      }\n+\n+\t    re = find_edge (ret_bb, e->dest);\n+\t    gcc_assert (re);\n+\t    gcc_assert ((re->flags & (EDGE_EH | EDGE_ABNORMAL))\n+\t\t\t== (e->flags & (EDGE_EH | EDGE_ABNORMAL)));\n+\n+\t    SET_USE (PHI_ARG_DEF_PTR_FROM_EDGE (phi, e),\n+\t\t     USE_FROM_PTR (PHI_ARG_DEF_PTR_FROM_EDGE (phi, re)));\n \t  }\n       }\n }\n@@ -1044,7 +1069,7 @@ update_ssa_across_eh_edges (basic_block bb)\n    accordingly.  Edges will be taken care of later.  Assume aux\n    pointers to point to the copies of each BB.  */\n static void\n-copy_edges_for_bb (basic_block bb, int count_scale)\n+copy_edges_for_bb (basic_block bb, int count_scale, basic_block ret_bb)\n {\n   basic_block new_bb = (basic_block) bb->aux;\n   edge_iterator ei;\n@@ -1076,6 +1101,7 @@ copy_edges_for_bb (basic_block bb, int count_scale)\n   for (bsi = bsi_start (new_bb); !bsi_end_p (bsi);)\n     {\n       tree copy_stmt;\n+      bool can_throw, nonlocal_goto;\n \n       copy_stmt = bsi_stmt (bsi);\n       update_stmt (copy_stmt);\n@@ -1096,7 +1122,10 @@ copy_edges_for_bb (basic_block bb, int count_scale)\n          into a COMPONENT_REF which doesn't.  If the copy\n          can throw, the original could also throw.  */\n \n-      if (tree_can_throw_internal (copy_stmt))\n+      can_throw = tree_can_throw_internal (copy_stmt);\n+      nonlocal_goto = tree_can_make_abnormal_goto (copy_stmt);\n+\n+      if (can_throw || nonlocal_goto)\n \t{\n \t  if (!bsi_end_p (bsi))\n \t    /* Note that bb's predecessor edges aren't necessarily\n@@ -1108,12 +1137,18 @@ copy_edges_for_bb (basic_block bb, int count_scale)\n \t      new_bb->aux = e->src->aux;\n \t      bsi = bsi_start (new_bb);\n \t    }\n+\t}\n \n-           make_eh_edges (copy_stmt);\n+      if (can_throw)\n+\tmake_eh_edges (copy_stmt);\n \n-\t   if (gimple_in_ssa_p (cfun))\n-\t     update_ssa_across_eh_edges (bb_for_stmt (copy_stmt));\n-\t}\n+      if (nonlocal_goto)\n+\tmake_abnormal_goto_edges (bb_for_stmt (copy_stmt), true);\n+\n+      if ((can_throw || nonlocal_goto)\n+\t  && gimple_in_ssa_p (cfun))\n+\tupdate_ssa_across_abnormal_edges (bb_for_stmt (copy_stmt), ret_bb,\n+\t\t\t\t\t  can_throw, nonlocal_goto);\n     }\n }\n \n@@ -1285,7 +1320,7 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency,\n   last = last_basic_block;\n   /* Now that we've duplicated the blocks, duplicate their edges.  */\n   FOR_ALL_BB_FN (bb, cfun_to_copy)\n-    copy_edges_for_bb (bb, count_scale);\n+    copy_edges_for_bb (bb, count_scale, exit_block_map);\n   if (gimple_in_ssa_p (cfun))\n     FOR_ALL_BB_FN (bb, cfun_to_copy)\n       copy_phis_for_bb (bb, id);\n@@ -2803,60 +2838,6 @@ has_abnormal_outgoing_edge_p (basic_block bb)\n   return false;\n }\n \n-/* When a block from the inlined function contains a call with side-effects\n-   in the middle gets inlined in a function with non-locals labels, the call\n-   becomes a potential non-local goto so we need to add appropriate edge.  */\n-\n-static void\n-make_nonlocal_label_edges (void)\n-{\n-  block_stmt_iterator bsi;\n-  basic_block bb;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\t{\n-\t  tree stmt = bsi_stmt (bsi);\n-\t  if (tree_can_make_abnormal_goto (stmt))\n-\t    {\n-\t      if (stmt == bsi_stmt (bsi_last (bb)))\n-\t\t{\n-\t\t  if (!has_abnormal_outgoing_edge_p (bb))\n-\t\t    make_abnormal_goto_edges (bb, true);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  edge e = split_block (bb, stmt);\n-\t\t  bb = e->src;\n-\t\t  make_abnormal_goto_edges (bb, true);\n-\t\t}\n-\t      break;\n-\t    }\n-\n-\t  /* Update PHIs on nonlocal goto receivers we (possibly)\n-\t     just created new edges into.  */\n-\t  if (TREE_CODE (stmt) == LABEL_EXPR\n-\t      && gimple_in_ssa_p (cfun))\n-\t    {\n-\t      tree target = LABEL_EXPR_LABEL (stmt);\n-\t      if (DECL_NONLOCAL (target))\n-\t\t{\n-\t\t  tree phi;\n-\n-\t\t  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\t\t    {\n-\t\t      gcc_assert (SSA_NAME_OCCURS_IN_ABNORMAL_PHI\n-\t\t\t\t  (PHI_RESULT (phi)));\n-\t\t      mark_sym_for_renaming\n-\t\t\t(SSA_NAME_VAR (PHI_RESULT (phi)));\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n /* Expand calls to inline functions in the body of FN.  */\n \n unsigned int\n@@ -2935,8 +2916,6 @@ optimize_inline_calls (tree fn)\n   cgraph_node_remove_callees (id.dst_node);\n \n   fold_cond_expr_cond ();\n-  if (current_function_has_nonlocal_label)\n-    make_nonlocal_label_edges ();\n   /* It would be nice to check SSA/CFG/statement consistency here, but it is\n      not possible yet - the IPA passes might make various functions to not\n      throw and they don't care to proactively update local EH info.  This is"}]}