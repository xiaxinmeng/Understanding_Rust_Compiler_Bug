{"sha": "9d79aec3134c59555a81daef276e5cde380688e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ3OWFlYzMxMzRjNTk1NTVhODFkYWVmMjc2ZTVjZGUzODA2ODhlNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-11-06T03:32:55Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-11-06T03:32:55Z"}, "message": "re PR c++/41703 (Problems with SFINAE. Source works at gcc 3.4.6 but fails at 4.2.1 and 4.5.0.20091008)\n\n\tPR c++/41703\n\t* pt.c (check_undeduced_parms): New subroutine of...\n\t(more_specialized_fn): ...here.  Undeduced template parms can make\n\ta template less specialized than another.\n\nFrom-SVN: r153957", "tree": {"sha": "fef46d72721d47157bad5b830e2fe179d600ead6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fef46d72721d47157bad5b830e2fe179d600ead6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d79aec3134c59555a81daef276e5cde380688e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d79aec3134c59555a81daef276e5cde380688e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d79aec3134c59555a81daef276e5cde380688e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d79aec3134c59555a81daef276e5cde380688e6/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "57201d0267c5c660c7d66373b968a61566583bdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57201d0267c5c660c7d66373b968a61566583bdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57201d0267c5c660c7d66373b968a61566583bdd"}], "stats": {"total": 159, "additions": 132, "deletions": 27}, "files": [{"sha": "a2d44dce186db9977e72f2b668b8321713e267e8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d79aec3134c59555a81daef276e5cde380688e6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d79aec3134c59555a81daef276e5cde380688e6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9d79aec3134c59555a81daef276e5cde380688e6", "patch": "@@ -1,3 +1,10 @@\n+2009-11-05  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/41703\n+\t* pt.c (check_undeduced_parms): New subroutine of...\n+\t(more_specialized_fn): ...here.  Undeduced template parms can make\n+\ta template less specialized than another.\n+\n 2009-11-04  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/39413"}, {"sha": "74273eb5e780198117e25aefd6d2bde43e93680c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 89, "deletions": 27, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d79aec3134c59555a81daef276e5cde380688e6/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d79aec3134c59555a81daef276e5cde380688e6/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9d79aec3134c59555a81daef276e5cde380688e6", "patch": "@@ -14854,6 +14854,35 @@ mark_decl_instantiated (tree result, int extern_p)\n   DECL_INTERFACE_KNOWN (result) = 1;\n }\n \n+/* Subroutine of more_specialized_fn: check whether TARGS is missing any\n+   important template arguments.  If any are missing, we check whether\n+   they're important by using error_mark_node for substituting into any\n+   args that were used for partial ordering (the ones between ARGS and END)\n+   and seeing if it bubbles up.  */\n+\n+static bool\n+check_undeduced_parms (tree targs, tree args, tree end)\n+{\n+  bool found = false;\n+  int i;\n+  for (i = TREE_VEC_LENGTH (targs) - 1; i >= 0; --i)\n+    if (TREE_VEC_ELT (targs, i) == NULL_TREE)\n+      {\n+\tfound = true;\n+\tTREE_VEC_ELT (targs, i) = error_mark_node;\n+      }\n+  if (found)\n+    {\n+      for (; args != end; args = TREE_CHAIN (args))\n+\t{\n+\t  tree substed = tsubst (TREE_VALUE (args), targs, tf_none, NULL_TREE);\n+\t  if (substed == error_mark_node)\n+\t    return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Given two function templates PAT1 and PAT2, return:\n \n    1 if PAT1 is more specialized than PAT2 as described in [temp.func.order].\n@@ -14877,8 +14906,12 @@ mark_decl_instantiated (tree result, int extern_p)\n    neither is more cv-qualified, they both are equal).  Unlike regular\n    deduction, after all the arguments have been deduced in this way,\n    we do *not* verify the deduced template argument values can be\n-   substituted into non-deduced contexts, nor do we have to verify\n-   that all template arguments have been deduced.  */\n+   substituted into non-deduced contexts.\n+\n+   The logic can be a bit confusing here, because we look at deduce1 and\n+   targs1 to see if pat2 is at least as specialized, and vice versa; if we\n+   can find template arguments for pat1 to make arg1 look like arg2, that\n+   means that arg2 is at least as specialized as arg1.  */\n \n int\n more_specialized_fn (tree pat1, tree pat2, int len)\n@@ -14891,8 +14924,9 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n   tree tparms2 = DECL_INNERMOST_TEMPLATE_PARMS (pat2);\n   tree args1 = TYPE_ARG_TYPES (TREE_TYPE (decl1));\n   tree args2 = TYPE_ARG_TYPES (TREE_TYPE (decl2));\n-  int better1 = 0;\n-  int better2 = 0;\n+  tree origs1, origs2;\n+  bool lose1 = false;\n+  bool lose2 = false;\n \n   /* Remove the this parameter from non-static member functions.  If\n      one is a non-static member function and the other is not a static\n@@ -14931,6 +14965,9 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n \n   processing_template_decl++;\n \n+  origs1 = args1;\n+  origs2 = args2;\n+\n   while (len--\n \t /* Stop when an ellipsis is seen.  */\n \t && args1 != NULL_TREE && args2 != NULL_TREE)\n@@ -15065,28 +15102,37 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n           deduce2 = !unify (tparms2, targs2, arg2, arg1, UNIFY_ALLOW_NONE);\n         }\n \n+      /* If we couldn't deduce arguments for tparms1 to make arg1 match\n+\t arg2, then arg2 is not as specialized as arg1.  */\n       if (!deduce1)\n-\tbetter2 = -1;\n+\tlose2 = true;\n       if (!deduce2)\n-\tbetter1 = -1;\n-      if (better1 < 0 && better2 < 0)\n-\t/* We've failed to deduce something in either direction.\n-\t   These must be unordered.  */\n-\tbreak;\n-\n-      if (deduce1 && deduce2 && quals1 >= 0 && quals2 >= 0)\n+\tlose1 = true;\n+\n+      /* \"If, for a given type, deduction succeeds in both directions\n+\t (i.e., the types are identical after the transformations above)\n+\t and if the type from the argument template is more cv-qualified\n+\t than the type from the parameter template (as described above)\n+\t that type is considered to be more specialized than the other. If\n+\t neither type is more cv-qualified than the other then neither type\n+\t is more specialized than the other.\"\n+\n+         We check same_type_p explicitly because deduction can also succeed\n+         in both directions when there is a nondeduced context.  */\n+      if (deduce1 && deduce2\n+\t  && quals1 != quals2 && quals1 >= 0 && quals2 >= 0\n+\t  && same_type_p (arg1, arg2))\n \t{\n-\t  /* Deduces in both directions, see if quals can\n-\t     disambiguate.  Pretend the worse one failed to deduce. */\n \t  if ((quals1 & quals2) == quals2)\n-\t    deduce1 = 0;\n+\t    lose2 = true;\n \t  if ((quals1 & quals2) == quals1)\n-\t    deduce2 = 0;\n+\t    lose1 = true;\n \t}\n-      if (deduce1 && !deduce2 && !better2)\n-\tbetter2 = 1;\n-      if (deduce2 && !deduce1 && !better1)\n-\tbetter1 = 1;\n+\n+      if (lose1 && lose2)\n+\t/* We've failed to deduce something in either direction.\n+\t   These must be unordered.  */\n+\tbreak;\n \n       if (TREE_CODE (arg1) == TYPE_PACK_EXPANSION\n           || TREE_CODE (arg2) == TYPE_PACK_EXPANSION)\n@@ -15098,22 +15144,38 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n       args2 = TREE_CHAIN (args2);\n     }\n \n+  /* \"In most cases, all template parameters must have values in order for\n+     deduction to succeed, but for partial ordering purposes a template\n+     parameter may remain without a value provided it is not used in the\n+     types being used for partial ordering.\"\n+\n+     Thus, if we are missing any of the targs1 we need to substitute into\n+     origs1, then pat2 is not as specialized as pat1.  This can happen when\n+     there is a nondeduced context.  */\n+  if (!lose2 && check_undeduced_parms (targs1, origs1, args1))\n+    lose2 = true;\n+  if (!lose1 && check_undeduced_parms (targs2, origs2, args2))\n+    lose1 = true;\n+\n   processing_template_decl--;\n \n   /* All things being equal, if the next argument is a pack expansion\n      for one function but not for the other, prefer the\n-     non-variadic function.  */\n-  if ((better1 > 0) - (better2 > 0) == 0\n+     non-variadic function.  FIXME this is bogus; see c++/41958.  */\n+  if (lose1 == lose2\n       && args1 && TREE_VALUE (args1)\n       && args2 && TREE_VALUE (args2))\n     {\n-      if (TREE_CODE (TREE_VALUE (args1)) == TYPE_PACK_EXPANSION)\n-        return TREE_CODE (TREE_VALUE (args2)) == TYPE_PACK_EXPANSION ? 0 : -1;\n-      else if (TREE_CODE (TREE_VALUE (args2)) == TYPE_PACK_EXPANSION)\n-        return 1;\n+      lose1 = TREE_CODE (TREE_VALUE (args1)) == TYPE_PACK_EXPANSION;\n+      lose2 = TREE_CODE (TREE_VALUE (args2)) == TYPE_PACK_EXPANSION;\n     }\n \n-  return (better1 > 0) - (better2 > 0);\n+  if (lose1 == lose2)\n+    return 0;\n+  else if (!lose1)\n+    return 1;\n+  else\n+    return -1;\n }\n \n /* Determine which of two partial specializations is more specialized."}, {"sha": "6454237a5945a2daafbf23287144d284d7b7c139", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d79aec3134c59555a81daef276e5cde380688e6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d79aec3134c59555a81daef276e5cde380688e6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9d79aec3134c59555a81daef276e5cde380688e6", "patch": "@@ -1,3 +1,8 @@\n+2009-11-05  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/41703\n+\t* g++.dg/template/partial6.C: New.\n+\n 2009-11-05  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/41556"}, {"sha": "80bbfe3c138fd420b148754a60fd73d4cb3c7330", "filename": "gcc/testsuite/g++.dg/template/partial6.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d79aec3134c59555a81daef276e5cde380688e6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d79aec3134c59555a81daef276e5cde380688e6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial6.C?ref=9d79aec3134c59555a81daef276e5cde380688e6", "patch": "@@ -0,0 +1,31 @@\n+// PR c++/41703\n+// The second GetAllSize template is more specialized because even though\n+// deduction on each parameter type succeeds, we never get a template\n+// argument for its X to make it match the first template.\n+\n+template <typename T, int (T::*)() const>\n+struct TSizeEnabler\n+{\n+    typedef T TClass;\n+};\n+\n+template <typename X>\n+int\n+GetAllSize(const X &Var)\n+{ return sizeof(Var); }\n+\n+template <typename X>\n+int\n+GetAllSize(const typename TSizeEnabler<X, &X::func>::TClass &Var)\n+{ return Var.func(); }\n+\n+struct H\n+{\n+    int func() const;\n+};\n+\n+int main()\n+{\n+    H b;\n+    return GetAllSize< H >(b);\n+}"}]}