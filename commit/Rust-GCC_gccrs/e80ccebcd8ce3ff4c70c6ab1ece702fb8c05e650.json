{"sha": "e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgwY2NlYmNkOGNlM2ZmNGM3MGM2YWIxZWNlNzAyZmI4YzA1ZTY1MA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-05-31T05:29:47Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-05-31T05:29:47Z"}, "message": "regs.h (move_table, [...]): Move these definitions and associated target_globals fields to...\n\ngcc/\n\t* regs.h (move_table, move_cost, may_move_in_cost, may_move_out_cost):\n\tMove these definitions and associated target_globals fields to...\n\t* ira-int.h: ...here.\n\t* rtl.h (init_move_cost): Delete.\n\t* reginfo.c (last_mode_for_init_move_cost, init_move_cost): Move to...\n\t* ira.c: ...here, making the latter static.\n\nFrom-SVN: r188043", "tree": {"sha": "243e533413d830b4129023fa294344aacd454c3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/243e533413d830b4129023fa294344aacd454c3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bac1c6a4f9c836cb7fe0a8b3faad9bcafbf0d6ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bac1c6a4f9c836cb7fe0a8b3faad9bcafbf0d6ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bac1c6a4f9c836cb7fe0a8b3faad9bcafbf0d6ba"}], "stats": {"total": 280, "additions": 142, "deletions": 138}, "files": [{"sha": "1db6942bfc213fb68fae44b91773c8a99ed09b65", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650", "patch": "@@ -1,3 +1,12 @@\n+2012-05-31  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* regs.h (move_table, move_cost, may_move_in_cost, may_move_out_cost):\n+\tMove these definitions and associated target_globals fields to...\n+\t* ira-int.h: ...here.\n+\t* rtl.h (init_move_cost): Delete.\n+\t* reginfo.c (last_mode_for_init_move_cost, init_move_cost): Move to...\n+\t* ira.c: ...here, making the latter static.\n+\n 2012-05-31  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* ira-costs.c (copy_cost): Use ira_init_register_move_cost_if_necessary"}, {"sha": "1b68c2fda40a201ad823ab710f1f7bcb9e10a5a1", "filename": "gcc/ira-int.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650", "patch": "@@ -75,6 +75,8 @@ DEF_VEC_ALLOC_P(ira_copy_t, heap);\n /* Typedef for pointer to the subsequent structure.  */\n typedef struct ira_loop_tree_node *ira_loop_tree_node_t;\n \n+typedef unsigned short move_table[N_REG_CLASSES];\n+\n /* In general case, IRA is a regional allocator.  The regions are\n    nested and form a tree.  Currently regions are natural loops.  The\n    following structure describes loop tree node (representing basic\n@@ -767,6 +769,21 @@ struct target_ira_int {\n   HARD_REG_SET (x_ira_reg_mode_hard_regset\n \t\t[FIRST_PSEUDO_REGISTER][NUM_MACHINE_MODES]);\n \n+  /* Maximum cost of moving from a register in one class to a register\n+     in another class.  Based on TARGET_REGISTER_MOVE_COST.  */\n+  move_table *x_move_cost[MAX_MACHINE_MODE];\n+\n+  /* Similar, but here we don't have to move if the first index is a\n+     subset of the second so in that case the cost is zero.  */\n+  move_table *x_may_move_in_cost[MAX_MACHINE_MODE];\n+\n+  /* Similar, but here we don't have to move if the first index is a\n+     superset of the second so in that case the cost is zero.  */\n+  move_table *x_may_move_out_cost[MAX_MACHINE_MODE];\n+\n+  /* Keep track of the last mode we initialized move costs for.  */\n+  int x_last_mode_for_init_move_cost;\n+\n   /* Array based on TARGET_REGISTER_MOVE_COST.  Don't use\n      ira_register_move_cost directly.  Use function of\n      ira_get_may_move_cost instead.  */\n@@ -888,6 +905,12 @@ extern struct target_ira_int *this_target_ira_int;\n \n #define ira_reg_mode_hard_regset \\\n   (this_target_ira_int->x_ira_reg_mode_hard_regset)\n+#define move_cost \\\n+  (this_target_ira_int->x_move_cost)\n+#define may_move_in_cost \\\n+  (this_target_ira_int->x_may_move_in_cost)\n+#define may_move_out_cost \\\n+  (this_target_ira_int->x_may_move_out_cost)\n #define ira_register_move_cost \\\n   (this_target_ira_int->x_ira_register_move_cost)\n #define ira_max_memory_move_cost \\"}, {"sha": "f141712dcaa5537021313c55de0add2cd13107b6", "filename": "gcc/ira.c", "status": "modified", "additions": 110, "deletions": 2, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650", "patch": "@@ -423,6 +423,8 @@ HARD_REG_SET eliminable_regset;\n /* Temporary hard reg set used for a different calculation.  */\n static HARD_REG_SET temp_hard_regset;\n \n+#define last_mode_for_init_move_cost \\\n+  (this_target_ira_int->x_last_mode_for_init_move_cost)\n \f\n \n /* The function sets up the map IRA_REG_MODE_HARD_REGSET.  */\n@@ -1455,8 +1457,96 @@ clarify_prohibited_class_mode_regs (void)\n \t      }\n \t}\n }\n-\n \f\n+/* Initialize may_move_cost and friends for mode M.  */\n+\n+static void\n+init_move_cost (enum machine_mode m)\n+{\n+  static unsigned short last_move_cost[N_REG_CLASSES][N_REG_CLASSES];\n+  bool all_match = true;\n+  unsigned int i, j;\n+\n+  gcc_assert (have_regs_of_mode[m]);\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    if (contains_reg_of_mode[i][m])\n+      for (j = 0; j < N_REG_CLASSES; j++)\n+\t{\n+\t  int cost;\n+\t  if (!contains_reg_of_mode[j][m])\n+\t    cost = 65535;\n+\t  else\n+\t    {\n+\t      cost = register_move_cost (m, (enum reg_class) i,\n+\t\t\t\t\t (enum reg_class) j);\n+\t      gcc_assert (cost < 65535);\n+\t    }\n+\t  all_match &= (last_move_cost[i][j] == cost);\n+\t  last_move_cost[i][j] = cost;\n+\t}\n+  if (all_match && last_mode_for_init_move_cost != -1)\n+    {\n+      move_cost[m] = move_cost[last_mode_for_init_move_cost];\n+      may_move_in_cost[m] = may_move_in_cost[last_mode_for_init_move_cost];\n+      may_move_out_cost[m] = may_move_out_cost[last_mode_for_init_move_cost];\n+      return;\n+    }\n+  last_mode_for_init_move_cost = m;\n+  move_cost[m] = (move_table *)xmalloc (sizeof (move_table)\n+\t\t\t\t\t* N_REG_CLASSES);\n+  may_move_in_cost[m] = (move_table *)xmalloc (sizeof (move_table)\n+\t\t\t\t\t       * N_REG_CLASSES);\n+  may_move_out_cost[m] = (move_table *)xmalloc (sizeof (move_table)\n+\t\t\t\t\t        * N_REG_CLASSES);\n+  for (i = 0; i < N_REG_CLASSES; i++)\n+    if (contains_reg_of_mode[i][m])\n+      for (j = 0; j < N_REG_CLASSES; j++)\n+\t{\n+\t  int cost;\n+\t  enum reg_class *p1, *p2;\n+\n+\t  if (last_move_cost[i][j] == 65535)\n+\t    {\n+\t      move_cost[m][i][j] = 65535;\n+\t      may_move_in_cost[m][i][j] = 65535;\n+\t      may_move_out_cost[m][i][j] = 65535;\n+\t    }\n+\t  else\n+\t    {\n+\t      cost = last_move_cost[i][j];\n+\n+\t      for (p2 = &reg_class_subclasses[j][0];\n+\t\t   *p2 != LIM_REG_CLASSES; p2++)\n+\t\tif (*p2 != i && contains_reg_of_mode[*p2][m])\n+\t\t  cost = MAX (cost, move_cost[m][i][*p2]);\n+\n+\t      for (p1 = &reg_class_subclasses[i][0];\n+\t\t   *p1 != LIM_REG_CLASSES; p1++)\n+\t\tif (*p1 != j && contains_reg_of_mode[*p1][m])\n+\t\t  cost = MAX (cost, move_cost[m][*p1][j]);\n+\n+\t      gcc_assert (cost <= 65535);\n+\t      move_cost[m][i][j] = cost;\n+\n+\t      if (reg_class_subset_p ((enum reg_class) i, (enum reg_class) j))\n+\t\tmay_move_in_cost[m][i][j] = 0;\n+\t      else\n+\t\tmay_move_in_cost[m][i][j] = cost;\n+\n+\t      if (reg_class_subset_p ((enum reg_class) j, (enum reg_class) i))\n+\t\tmay_move_out_cost[m][i][j] = 0;\n+\t      else\n+\t\tmay_move_out_cost[m][i][j] = cost;\n+\t    }\n+\t}\n+    else\n+      for (j = 0; j < N_REG_CLASSES; j++)\n+\t{\n+\t  move_cost[m][i][j] = 65535;\n+\t  may_move_in_cost[m][i][j] = 65535;\n+\t  may_move_out_cost[m][i][j] = 65535;\n+\t}\n+}\n \n /* Allocate and initialize IRA_REGISTER_MOVE_COST,\n    IRA_MAX_REGISTER_MOVE_COST, IRA_MAY_MOVE_IN_COST,\n@@ -1577,8 +1667,26 @@ ira_init_once (void)\n static void\n free_register_move_costs (void)\n {\n-  int mode;\n+  int mode, i;\n \n+  /* Reset move_cost and friends, making sure we only free shared\n+     table entries once.  */\n+  for (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n+    if (move_cost[mode])\n+      {\n+\tfor (i = 0; i < mode && move_cost[i] != move_cost[mode]; i++)\n+\t  ;\n+\tif (i == mode)\n+\t  {\n+\t    free (move_cost[mode]);\n+\t    free (may_move_in_cost[mode]);\n+\t    free (may_move_out_cost[mode]);\n+\t  }\n+      }\n+  memset (move_cost, 0, sizeof move_cost);\n+  memset (may_move_in_cost, 0, sizeof may_move_in_cost);\n+  memset (may_move_out_cost, 0, sizeof may_move_out_cost);\n+  last_mode_for_init_move_cost = -1;\n   for (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n     {\n       free (ira_max_register_move_cost[mode]);"}, {"sha": "4fa0d04ce9c80707d3fb51471cc3600f4fcb335f", "filename": "gcc/reginfo.c", "status": "modified", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650", "patch": "@@ -122,9 +122,6 @@ static const char *const initial_reg_names[] = REGISTER_NAMES;\n /* Array containing all of the register class names.  */\n const char * reg_class_names[] = REG_CLASS_NAMES;\n \n-#define last_mode_for_init_move_cost \\\n-  (this_target_regs->x_last_mode_for_init_move_cost)\n-\n /* No more global register variables may be declared; true once\n    reginfo has been initialized.  */\n static int no_global_reg_vars = 0;\n@@ -197,95 +194,6 @@ init_reg_sets (void)\n   SET_HARD_REG_SET (operand_reg_set);\n }\n \n-/* Initialize may_move_cost and friends for mode M.  */\n-void\n-init_move_cost (enum machine_mode m)\n-{\n-  static unsigned short last_move_cost[N_REG_CLASSES][N_REG_CLASSES];\n-  bool all_match = true;\n-  unsigned int i, j;\n-\n-  gcc_assert (have_regs_of_mode[m]);\n-  for (i = 0; i < N_REG_CLASSES; i++)\n-    if (contains_reg_of_mode[i][m])\n-      for (j = 0; j < N_REG_CLASSES; j++)\n-\t{\n-\t  int cost;\n-\t  if (!contains_reg_of_mode[j][m])\n-\t    cost = 65535;\n-\t  else\n-\t    {\n-\t      cost = register_move_cost (m, (enum reg_class) i,\n-\t\t\t\t\t (enum reg_class) j);\n-\t      gcc_assert (cost < 65535);\n-\t    }\n-\t  all_match &= (last_move_cost[i][j] == cost);\n-\t  last_move_cost[i][j] = cost;\n-\t}\n-  if (all_match && last_mode_for_init_move_cost != -1)\n-    {\n-      move_cost[m] = move_cost[last_mode_for_init_move_cost];\n-      may_move_in_cost[m] = may_move_in_cost[last_mode_for_init_move_cost];\n-      may_move_out_cost[m] = may_move_out_cost[last_mode_for_init_move_cost];\n-      return;\n-    }\n-  last_mode_for_init_move_cost = m;\n-  move_cost[m] = (move_table *)xmalloc (sizeof (move_table)\n-\t\t\t\t\t* N_REG_CLASSES);\n-  may_move_in_cost[m] = (move_table *)xmalloc (sizeof (move_table)\n-\t\t\t\t\t       * N_REG_CLASSES);\n-  may_move_out_cost[m] = (move_table *)xmalloc (sizeof (move_table)\n-\t\t\t\t\t        * N_REG_CLASSES);\n-  for (i = 0; i < N_REG_CLASSES; i++)\n-    if (contains_reg_of_mode[i][m])\n-      for (j = 0; j < N_REG_CLASSES; j++)\n-\t{\n-\t  int cost;\n-\t  enum reg_class *p1, *p2;\n-\n-\t  if (last_move_cost[i][j] == 65535)\n-\t    {\n-\t      move_cost[m][i][j] = 65535;\n-\t      may_move_in_cost[m][i][j] = 65535;\n-\t      may_move_out_cost[m][i][j] = 65535;\n-\t    }\n-\t  else\n-\t    {\n-\t      cost = last_move_cost[i][j];\n-\n-\t      for (p2 = &reg_class_subclasses[j][0];\n-\t\t   *p2 != LIM_REG_CLASSES; p2++)\n-\t\tif (*p2 != i && contains_reg_of_mode[*p2][m])\n-\t\t  cost = MAX (cost, move_cost[m][i][*p2]);\n-\n-\t      for (p1 = &reg_class_subclasses[i][0];\n-\t\t   *p1 != LIM_REG_CLASSES; p1++)\n-\t\tif (*p1 != j && contains_reg_of_mode[*p1][m])\n-\t\t  cost = MAX (cost, move_cost[m][*p1][j]);\n-\n-\t      gcc_assert (cost <= 65535);\n-\t      move_cost[m][i][j] = cost;\n-\n-\t      if (reg_class_subset_p ((enum reg_class) i, (enum reg_class) j))\n-\t\tmay_move_in_cost[m][i][j] = 0;\n-\t      else\n-\t\tmay_move_in_cost[m][i][j] = cost;\n-\n-\t      if (reg_class_subset_p ((enum reg_class) j, (enum reg_class) i))\n-\t\tmay_move_out_cost[m][i][j] = 0;\n-\t      else\n-\t\tmay_move_out_cost[m][i][j] = cost;\n-\t    }\n-\t}\n-    else\n-      for (j = 0; j < N_REG_CLASSES; j++)\n-\t{\n-\t  move_cost[m][i][j] = 65535;\n-\t  may_move_in_cost[m][i][j] = 65535;\n-\t  may_move_out_cost[m][i][j] = 65535;\n-\t}\n-}\n-\n /* We need to save copies of some of the register information which\n    can be munged by command-line switches so we can restore it during\n    subsequent back-end reinitialization.  */\n@@ -575,25 +483,6 @@ init_reg_sets_1 (void)\n \t     have_regs_of_mode [m] = 1;\n \t  }\n      }\n-\n-  /* Reset move_cost and friends, making sure we only free shared\n-     table entries once.  */\n-  for (i = 0; i < MAX_MACHINE_MODE; i++)\n-    if (move_cost[i])\n-      {\n-\tfor (j = 0; j < i && move_cost[i] != move_cost[j]; j++)\n-\t  ;\n-\tif (i == j)\n-\t  {\n-\t    free (move_cost[i]);\n-\t    free (may_move_in_cost[i]);\n-\t    free (may_move_out_cost[i]);\n-\t  }\n-      }\n-  memset (move_cost, 0, sizeof move_cost);\n-  memset (may_move_in_cost, 0, sizeof may_move_in_cost);\n-  memset (may_move_out_cost, 0, sizeof may_move_out_cost);\n-  last_mode_for_init_move_cost = -1;\n }\n \n /* Compute the table of register modes."}, {"sha": "24f410c6b07e6d7e368aff472733d3c937e3384c", "filename": "gcc/regs.h", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650", "patch": "@@ -240,8 +240,6 @@ extern int caller_save_needed;\n #define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE) 0\n #endif\n \n-typedef unsigned short move_table[N_REG_CLASSES];\n-\n /* Target-dependent globals.  */\n struct target_regs {\n   /* For each starting hard register, the number of consecutive hard\n@@ -261,21 +259,6 @@ struct target_regs {\n   /* 1 if the corresponding class contains a register of the given mode.  */\n   char x_contains_reg_of_mode[N_REG_CLASSES][MAX_MACHINE_MODE];\n \n-  /* Maximum cost of moving from a register in one class to a register\n-     in another class.  Based on TARGET_REGISTER_MOVE_COST.  */\n-  move_table *x_move_cost[MAX_MACHINE_MODE];\n-\n-  /* Similar, but here we don't have to move if the first index is a\n-     subset of the second so in that case the cost is zero.  */\n-  move_table *x_may_move_in_cost[MAX_MACHINE_MODE];\n-\n-  /* Similar, but here we don't have to move if the first index is a\n-     superset of the second so in that case the cost is zero.  */\n-  move_table *x_may_move_out_cost[MAX_MACHINE_MODE];\n-\n-  /* Keep track of the last mode we initialized move costs for.  */\n-  int x_last_mode_for_init_move_cost;\n-\n   /* Record for each mode whether we can move a register directly to or\n      from an object of that mode in memory.  If we can't, we won't try\n      to use that mode directly when accessing a field of that mode.  */\n@@ -301,12 +284,6 @@ extern struct target_regs *this_target_regs;\n   (this_target_regs->x_have_regs_of_mode)\n #define contains_reg_of_mode \\\n   (this_target_regs->x_contains_reg_of_mode)\n-#define move_cost \\\n-  (this_target_regs->x_move_cost)\n-#define may_move_in_cost \\\n-  (this_target_regs->x_may_move_in_cost)\n-#define may_move_out_cost \\\n-  (this_target_regs->x_may_move_out_cost)\n #define direct_load \\\n   (this_target_regs->x_direct_load)\n #define direct_store \\"}, {"sha": "1d71971335a0d2f75510a1671a96baeb092508dd", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e80ccebcd8ce3ff4c70c6ab1ece702fb8c05e650", "patch": "@@ -2044,8 +2044,6 @@ extern rtx remove_free_EXPR_LIST_node (rtx *);\n \n /* reginfo.c */\n \n-/* Initialize may_move_cost and friends for mode M.  */\n-extern void init_move_cost (enum machine_mode);\n /* Resize reg info.  */\n extern bool resize_reg_info (void);\n /* Free up register info memory.  */"}]}