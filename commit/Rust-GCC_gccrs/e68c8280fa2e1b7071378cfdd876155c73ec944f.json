{"sha": "e68c8280fa2e1b7071378cfdd876155c73ec944f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY4YzgyODBmYTJlMWI3MDcxMzc4Y2ZkZDg3NjE1NWM3M2VjOTQ0Zg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-07-30T19:15:29Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-08-17T23:28:42Z"}, "message": "Abstract tracing routines into a class.\n\nGeneralize range tracing into a class and integrae it with gimple_ranger.\nRemove the old derived trace_ranger class.\n\n\t* Makefile.in (OBJS): Add gimple-range-trace.o.\n\t* gimple-range-cache.h (enable_new_values): Remove unused prototype.\n\t* gimple-range-fold.cc: Adjust headers.\n\t* gimple-range-trace.cc: New.\n\t* gimple-range-trace.h: New.\n\t* gimple-range.cc (gimple_ranger::gimple_ranger): Enable tracer.\n\t(gimple_ranger::range_of_expr): Add tracing.\n\t(gimple_ranger::range_on_entry): Ditto.\n\t(gimple_ranger::range_on_exit): Ditto.\n\t(gimple_ranger::range_on_edge): Ditto.\n\t(gimple_ranger::fold_range_internal): Ditto.\n\t(gimple_ranger::dump_bb): Do not calculate edge range twice.\n\t(trace_ranger::*): Remove.\n\t(enable_ranger): Never create a trace_ranger.\n\t(debug_seed_ranger): Move to gimple-range-trace.cc.\n\t(dump_ranger): Ditto.\n\t(debug_ranger): Ditto.\n\t* gimple-range.h: Include gimple-range-trace.h.\n\t(range_on_entry, range_on_exit): No longer virtual.\n\t(class trace_ranger): Remove.\n\t(DEBUG_RANGE_CACHE): Move to gimple-range-trace.h.", "tree": {"sha": "0ae12a1714e30ae84386e81130f2902117bf71bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ae12a1714e30ae84386e81130f2902117bf71bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e68c8280fa2e1b7071378cfdd876155c73ec944f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e68c8280fa2e1b7071378cfdd876155c73ec944f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e68c8280fa2e1b7071378cfdd876155c73ec944f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e68c8280fa2e1b7071378cfdd876155c73ec944f/comments", "author": null, "committer": null, "parents": [{"sha": "b48d4e6818674898f90d9358378c127511ef0f9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48d4e6818674898f90d9358378c127511ef0f9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b48d4e6818674898f90d9358378c127511ef0f9f"}], "stats": {"total": 703, "additions": 377, "deletions": 326}, "files": [{"sha": "9714fcaac37f5e11d75467d995f8b618c9c99088", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68c8280fa2e1b7071378cfdd876155c73ec944f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68c8280fa2e1b7071378cfdd876155c73ec944f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e68c8280fa2e1b7071378cfdd876155c73ec944f", "patch": "@@ -1406,6 +1406,7 @@ OBJS = \\\n \tgimple-range-edge.o \\\n \tgimple-range-fold.o \\\n \tgimple-range-gori.o \\\n+\tgimple-range-trace.o \\\n \tgimple-ssa-backprop.o \\\n \tgimple-ssa-evrp.o \\\n \tgimple-ssa-evrp-analyze.o \\"}, {"sha": "3b55673fd29aa32b9fd6430f60de19b7ac92d939", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68c8280fa2e1b7071378cfdd876155c73ec944f/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68c8280fa2e1b7071378cfdd876155c73ec944f/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=e68c8280fa2e1b7071378cfdd876155c73ec944f", "patch": "@@ -103,7 +103,6 @@ class ranger_cache : public range_query\n   bool get_non_stale_global_range (irange &r, tree name);\n   void set_global_range (tree name, const irange &r);\n \n-  bool enable_new_values (bool state);\n   non_null_ref m_non_null;\n   gori_compute m_gori;\n "}, {"sha": "94dd042721e70b61c8ab750efc392f50e87fb034", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68c8280fa2e1b7071378cfdd876155c73ec944f/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68c8280fa2e1b7071378cfdd876155c73ec944f/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=e68c8280fa2e1b7071378cfdd876155c73ec944f", "patch": "@@ -42,9 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"range.h\"\n #include \"value-query.h\"\n #include \"range-op.h\"\n-#include \"gimple-range-fold.h\"\n-#include \"gimple-range-edge.h\"\n-#include \"gimple-range-gori.h\"\n+#include \"gimple-range.h\"\n // Construct a fur_source, and set the m_query field.\n \n fur_source::fur_source (range_query *q)"}, {"sha": "1feb978e9284486f22c3418447472344a068bb70", "filename": "gcc/gimple-range-trace.cc", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68c8280fa2e1b7071378cfdd876155c73ec944f/gcc%2Fgimple-range-trace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68c8280fa2e1b7071378cfdd876155c73ec944f/gcc%2Fgimple-range-trace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-trace.cc?ref=e68c8280fa2e1b7071378cfdd876155c73ec944f", "patch": "@@ -0,0 +1,206 @@\n+/* Code for GIMPLE range trace and debugging related routines.\n+   Copyright (C) 2019-2021 Free Software Foundation, Inc.\n+   Contributed by Andrew MacLeod <amacleod@redhat.com>\n+   and Aldy Hernandez <aldyh@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"ssa.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree-cfg.h\"\n+#include \"fold-const.h\"\n+#include \"tree-cfg.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"gimple-range.h\"\n+\n+\n+// Breakpoint to trap at a specific index.  From GDB, this provides a simple\n+// place to put a breakpoint to stop at a given trace line.\n+// ie.  b range_tracer::breakpoint if index == 45678\n+\n+void\n+range_tracer::breakpoint (unsigned index ATTRIBUTE_UNUSED)\n+{\n+}\n+\n+// Construct a range_tracer with component NAME.\n+\n+range_tracer::range_tracer (const char *name)\n+{\n+  gcc_checking_assert (strlen(name) < name_len -1);\n+  strcpy (component, name);\n+  indent = 0;\n+  tracing = false;\n+}\n+\n+// This routine does the initial line spacing/indenting for a trace.\n+// If BLANKS is false, then IDX is printed, otherwise spaces.\n+\n+void\n+range_tracer::print_prefix (unsigned idx, bool blanks)\n+{\n+  // Print counter index as well as INDENT spaces.\n+  if (!blanks)\n+    fprintf (dump_file, \"%-7u \", idx);\n+  else\n+    fprintf (dump_file, \"        \");\n+  fprintf (dump_file, \"%s \", component);\n+  unsigned x;\n+  for (x = 0; x< indent; x++)\n+    fputc (' ', dump_file);\n+\n+}\n+// If dumping, return the next call index and print the prefix for the next\n+// output line.  If not, retrurn 0.\n+// Counter is static to monotonically increase across the compilation unit.\n+\n+unsigned\n+range_tracer::do_header (const char *str)\n+{\n+  static unsigned trace_count = 0;\n+\n+  unsigned idx = ++trace_count;\n+  print_prefix (idx, false);\n+  fprintf (dump_file, \"%s\", str);\n+  indent += bump;\n+  breakpoint (idx);\n+  return idx;\n+}\n+\n+// Print a line without starting or ending a trace.\n+\n+void\n+range_tracer::print (unsigned counter, const char *str)\n+{\n+  print_prefix (counter, true);\n+  fprintf (dump_file, \"%s\", str);\n+}\n+\n+// End a trace and print the CALLER, NAME, and RESULT and range R,\n+\n+void\n+range_tracer::trailer (unsigned counter, const char *caller, bool result,\n+\t\t      tree name, const irange &r)\n+{\n+  gcc_checking_assert (tracing && counter != 0);\n+\n+  indent -= bump;\n+  print_prefix (counter, true);\n+  fputs(result ? \"TRUE : \" : \"FALSE : \", dump_file);\n+  fprintf (dump_file, \"(%u) \", counter);\n+  fputs (caller, dump_file);\n+  fputs (\" (\",dump_file);\n+  if (name)\n+    print_generic_expr (dump_file, name, TDF_SLIM);\n+  fputs (\") \",dump_file);\n+  if (result)\n+    {\n+      r.dump (dump_file);\n+      fputc('\\n', dump_file);\n+    }\n+  else\n+    fputc('\\n', dump_file);\n+}\n+\n+// =========================================\n+// Debugging helpers.\n+// =========================================\n+\n+// Query all statements in the IL to precalculate computable ranges in RANGER.\n+\n+static DEBUG_FUNCTION void\n+debug_seed_ranger (gimple_ranger &ranger)\n+{\n+  // Recalculate SCEV to make sure the dump lists everything.\n+  if (scev_initialized_p ())\n+    {\n+      scev_finalize ();\n+      scev_initialize ();\n+    }\n+\n+  basic_block bb;\n+  int_range_max r;\n+  gimple_stmt_iterator gsi;\n+  FOR_EACH_BB_FN (bb, cfun)\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+\tgimple *stmt = gsi_stmt (gsi);\n+\n+\tif (is_gimple_debug (stmt))\n+\t  continue;\n+\n+\tranger.range_of_stmt (r, stmt);\n+      }\n+}\n+\n+// Dump all that ranger knows for the current function.\n+\n+DEBUG_FUNCTION void\n+dump_ranger (FILE *out)\n+{\n+  gimple_ranger ranger;\n+  debug_seed_ranger (ranger);\n+  ranger.dump (out);\n+}\n+\n+DEBUG_FUNCTION void\n+debug_ranger ()\n+{\n+  dump_ranger (stderr);\n+}\n+\n+// Dump all that ranger knows on a path of BBs.\n+//\n+// Note that the blocks are in reverse order, thus the exit block is\n+// path[0].\n+\n+DEBUG_FUNCTION void\n+dump_ranger (FILE *dump_file, const vec<basic_block> &path)\n+{\n+  if (path.length () == 0)\n+    {\n+      fprintf (dump_file, \"empty\\n\");\n+      return;\n+    }\n+\n+  gimple_ranger ranger;\n+  debug_seed_ranger (ranger);\n+\n+  unsigned i = path.length ();\n+  do\n+    {\n+      i--;\n+      ranger.dump_bb (dump_file, path[i]);\n+    }\n+  while (i > 0);\n+}\n+\n+DEBUG_FUNCTION void\n+debug_ranger (const vec<basic_block> &path)\n+{\n+  dump_ranger (stderr, path);\n+}\n+\n+#include \"gimple-range-tests.cc\""}, {"sha": "6f89fcccf4fa33b46f3658789bb578b54f27d445", "filename": "gcc/gimple-range-trace.h", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68c8280fa2e1b7071378cfdd876155c73ec944f/gcc%2Fgimple-range-trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68c8280fa2e1b7071378cfdd876155c73ec944f/gcc%2Fgimple-range-trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-trace.h?ref=e68c8280fa2e1b7071378cfdd876155c73ec944f", "patch": "@@ -0,0 +1,64 @@\n+/* Header file for the GIMPLE range tracing/debugging facilties.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+   Contributed by Andrew MacLeod <amacleod@redhat.com>\n+   and Aldy Hernandez <aldyh@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GIMPLE_RANGE_TRACE_H\n+#define GCC_GIMPLE_RANGE_TRACE_H\n+\n+// This class manages range tracing for the ranger and gori components.\n+// Tracing will provide a unique integer index whenever a new trace\n+// is started. This can be used to identify where a calculation has gone wrong.\n+\n+class range_tracer\n+{\n+public:\n+  range_tracer (const char *name = \"\");\n+  unsigned header (const char *str);\n+  void trailer (unsigned counter, const char *caller, bool result, tree name,\n+\t\tconst irange &r);\n+  void print (unsigned counter, const char *str);\n+  inline void enable_trace () { tracing = true; }\n+  inline void disable_trace () { tracing = false; }\n+  virtual void breakpoint (unsigned index);\n+private:\n+  unsigned do_header (const char *str);\n+  void print_prefix (unsigned idx, bool blanks);\n+  static const unsigned bump = 2;\n+  unsigned indent;\n+  static const unsigned name_len = 100;\n+  char component[name_len];\n+  bool tracing;\n+};\n+\n+\n+// If tracing is enabled, start a new trace header, returning the trace index.\n+// Otherwise return 0.\n+\n+inline unsigned\n+range_tracer::header (const char *str)\n+{\n+  if (tracing)\n+    return do_header (str);\n+  return 0;\n+}\n+\n+#define DEBUG_RANGE_CACHE (dump_file && (param_evrp_mode & EVRP_MODE_DEBUG))\n+\n+#endif // GCC_GIMPLE_RANGE_TRACE_H"}, {"sha": "60b7d3a59cd74c0ad121817cb8aef57ff76f5b7a", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 101, "deletions": 292, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68c8280fa2e1b7071378cfdd876155c73ec944f/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68c8280fa2e1b7071378cfdd876155c73ec944f/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=e68c8280fa2e1b7071378cfdd876155c73ec944f", "patch": "@@ -35,46 +35,61 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"gimple-range.h\"\n \n-gimple_ranger::gimple_ranger ()\n+gimple_ranger::gimple_ranger () : tracer (\"\")\n {\n   // If the cache has a relation oracle, use it.\n   m_oracle = m_cache.oracle ();\n+  if (dump_file && (param_evrp_mode & EVRP_MODE_TRACE))\n+    tracer.enable_trace ();\n }\n \n bool\n gimple_ranger::range_of_expr (irange &r, tree expr, gimple *stmt)\n {\n+  unsigned idx;\n   if (!gimple_range_ssa_p (expr))\n     return get_tree_range (r, expr, stmt);\n \n+  if ((idx = tracer.header (\"range_of_expr(\")))\n+    {\n+      print_generic_expr (dump_file, expr, TDF_SLIM);\n+      fputs (\")\", dump_file);\n+      if (stmt)\n+\t{\n+\t  fputs (\" at stmt \", dump_file);\n+\t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+\t}\n+      else\n+\tfputs (\"\\n\", dump_file);\n+    }\n+\n   // If there is no statement, just get the global value.\n   if (!stmt)\n     {\n       if (!m_cache.get_global_range (r, expr))\n         r = gimple_range_global (expr);\n-      return true;\n     }\n-\n   // For a debug stmt, pick the best value currently available, do not\n   // trigger new value calculations.  PR 100781.\n-  if (is_gimple_debug (stmt))\n+  else if (is_gimple_debug (stmt))\n+    m_cache.range_of_expr (r, expr, stmt);\n+  else\n     {\n-      m_cache.range_of_expr (r, expr, stmt);\n-      return true;\n-    }\n-  basic_block bb = gimple_bb (stmt);\n-  gimple *def_stmt = SSA_NAME_DEF_STMT (expr);\n+      basic_block bb = gimple_bb (stmt);\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (expr);\n \n-  // If name is defined in this block, try to get an range from S.\n-  if (def_stmt && gimple_bb (def_stmt) == bb)\n-    {\n-      range_of_stmt (r, def_stmt, expr);\n-      m_cache.m_non_null.adjust_range (r, expr, bb, true);\n+      // If name is defined in this block, try to get an range from S.\n+      if (def_stmt && gimple_bb (def_stmt) == bb)\n+\t{\n+\t  range_of_stmt (r, def_stmt, expr);\n+\t  m_cache.m_non_null.adjust_range (r, expr, bb, true);\n+\t}\n+      // Otherwise OP comes from outside this block, use range on entry.\n+      else\n+\trange_on_entry (r, bb, expr);\n     }\n-  else\n-    // Otherwise OP comes from outside this block, use range on entry.\n-    range_on_entry (r, bb, expr);\n-\n+  if (idx)\n+    tracer.trailer (idx, \"range_of_expr\", true, expr, r);\n   return true;\n }\n \n@@ -86,6 +101,13 @@ gimple_ranger::range_on_entry (irange &r, basic_block bb, tree name)\n   int_range_max entry_range;\n   gcc_checking_assert (gimple_range_ssa_p (name));\n \n+  unsigned idx;\n+  if ((idx = tracer.header (\"range_on_entry (\")))\n+    {\n+      print_generic_expr (dump_file, name, TDF_SLIM);\n+      fprintf (dump_file, \") to BB %d\\n\", bb->index);\n+    }\n+\n   // Start with any known range\n   range_of_stmt (r, SSA_NAME_DEF_STMT (name), name);\n \n@@ -94,6 +116,9 @@ gimple_ranger::range_on_entry (irange &r, basic_block bb, tree name)\n     r.intersect (entry_range);\n \n   m_cache.m_non_null.adjust_range (r, name, bb, true);\n+\n+  if (idx)\n+    tracer.trailer (idx, \"range_on_entry\", true, name, r);\n }\n \n // Calculate the range for NAME at the end of block BB and return it in R.\n@@ -106,6 +131,13 @@ gimple_ranger::range_on_exit (irange &r, basic_block bb, tree name)\n   gcc_checking_assert (bb != EXIT_BLOCK_PTR_FOR_FN (cfun));\n   gcc_checking_assert (gimple_range_ssa_p (name));\n \n+  unsigned idx;\n+  if ((idx = tracer.header (\"range_on_exit (\")))\n+    {\n+      print_generic_expr (dump_file, name, TDF_SLIM);\n+      fprintf (dump_file, \") from BB %d\\n\", bb->index);\n+    }\n+\n   gimple *s = SSA_NAME_DEF_STMT (name);\n   basic_block def_bb = gimple_bb (s);\n   // If this is not the definition block, get the range on the last stmt in\n@@ -119,6 +151,9 @@ gimple_ranger::range_on_exit (irange &r, basic_block bb, tree name)\n     range_on_entry (r, bb, name);\n   gcc_checking_assert (r.undefined_p ()\n \t\t       || range_compatible_p (r.type (), TREE_TYPE (name)));\n+  \n+  if (idx)\n+    tracer.trailer (idx, \"range_on_exit\", true, name, r);\n }\n \n // Calculate a range for NAME on edge E and return it in R.\n@@ -133,6 +168,13 @@ gimple_ranger::range_on_edge (irange &r, edge e, tree name)\n   if (!gimple_range_ssa_p (name))\n     return range_of_expr (r, name);\n \n+  unsigned idx;\n+  if ((idx = tracer.header (\"range_on_edge (\")))\n+    {\n+      print_generic_expr (dump_file, name, TDF_SLIM);\n+      fprintf (dump_file, \") on edge %d->%d\\n\", e->src->index, e->dest->index);\n+    }\n+\n   range_on_exit (r, e->src, name);\n   gcc_checking_assert  (r.undefined_p ()\n \t\t\t|| range_compatible_p (r.type(), TREE_TYPE (name)));\n@@ -141,6 +183,8 @@ gimple_ranger::range_on_edge (irange &r, edge e, tree name)\n   if (m_cache.range_on_edge (edge_range, e, name))\n     r.intersect (edge_range);\n \n+  if (idx)\n+    tracer.trailer (idx, \"range_on_edge\", true, name, r);\n   return true;\n }\n \n@@ -163,33 +207,50 @@ gimple_ranger::fold_range_internal (irange &r, gimple *s, tree name)\n bool\n gimple_ranger::range_of_stmt (irange &r, gimple *s, tree name)\n {\n+  bool res;\n   r.set_undefined ();\n \n+  unsigned idx;\n+  if ((idx = tracer.header (\"range_of_stmt (\")))\n+    {\n+      if (name)\n+\tprint_generic_expr (dump_file, name, TDF_SLIM);\n+      fputs (\") at stmt \", dump_file);\n+      print_gimple_stmt (dump_file, s, 0, TDF_SLIM);\n+    }\n+\n   if (!name)\n     name = gimple_get_lhs (s);\n \n   // If no name, simply call the base routine.\n   if (!name)\n-    return fold_range_internal (r, s, NULL_TREE);\n-\n-  if (!gimple_range_ssa_p (name))\n-    return false;\n-\n+    res = fold_range_internal (r, s, NULL_TREE);\n+  else if (!gimple_range_ssa_p (name))\n+    res = false;\n   // Check if the stmt has already been processed, and is not stale.\n-  if (m_cache.get_non_stale_global_range (r, name))\n-    return true;\n-\n-  // Otherwise calculate a new value.\n-  int_range_max tmp;\n-  fold_range_internal (tmp, s, name);\n-\n-  // Combine the new value with the old value.  This is required because\n-  // the way value propagation works, when the IL changes on the fly we\n-  // can sometimes get different results.  See PR 97741.\n-  r.intersect (tmp);\n-  m_cache.set_global_range (name, r);\n+  else if (m_cache.get_non_stale_global_range (r, name))\n+    {\n+      if (idx)\n+\ttracer.trailer (idx, \" cached\", true, name, r);\n+      return true;\n+    }\n+  else\n+    {\n+      // Otherwise calculate a new value.\n+      int_range_max tmp;\n+      fold_range_internal (tmp, s, name);\n+\n+      // Combine the new value with the old value.  This is required because\n+      // the way value propagation works, when the IL changes on the fly we\n+      // can sometimes get different results.  See PR 97741.\n+      r.intersect (tmp);\n+      m_cache.set_global_range (name, r);\n+      res = true;\n+    }\n \n-  return true;\n+  if (idx)\n+    tracer.trailer (idx, \"range_of_stmt\", res, name, r);\n+  return res;\n }\n \n // This routine will export whatever global ranges are known to GCC\n@@ -243,7 +304,7 @@ gimple_ranger::dump_bb (FILE *f, basic_block bb)\n   unsigned x;\n   edge_iterator ei;\n   edge e;\n-  int_range_max range;\n+  int_range_max range, tmp_range;\n   fprintf (f, \"\\n=========== BB %d ============\\n\", bb->index);\n   m_cache.dump_bb (f, bb);\n \n@@ -282,10 +343,9 @@ gimple_ranger::dump_bb (FILE *f, basic_block bb)\n \t      // the on entry cache for either end of the edge is\n \t      // set.\n \t      if ((s && bb == gimple_bb (s)) ||\n-\t\t  m_cache.block_range (range, bb, name, false) ||\n-\t\t  m_cache.block_range (range, e->dest, name, false))\n+\t\t  m_cache.block_range (tmp_range, bb, name, false) ||\n+\t\t  m_cache.block_range (tmp_range, e->dest, name, false))\n \t\t{\n-\t\t  m_cache.range_on_edge (range, e, name);\n \t\t  if (!range.varying_p ())\n \t\t    {\n \t\t      fprintf (f, \"%d->%d \", e->src->index,\n@@ -321,182 +381,12 @@ gimple_ranger::dump (FILE *f)\n   m_cache.dump (f);\n }\n \n-// trace_ranger implementation.\n-\n-\n-trace_ranger::trace_ranger ()\n-{\n-  indent = 0;\n-  trace_count = 0;\n-}\n-\n-// If dumping, return true and print the prefix for the next output line.\n-\n-bool\n-trace_ranger::dumping (unsigned counter, bool trailing)\n-{\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      // Print counter index as well as INDENT spaces.\n-      if (!trailing)\n-\tfprintf (dump_file, \" %-7u \", counter);\n-      else\n-\tfprintf (dump_file, \"         \");\n-      unsigned x;\n-      for (x = 0; x< indent; x++)\n-\tfputc (' ', dump_file);\n-      return true;\n-    }\n-  return false;\n-}\n-\n-// After calling a routine, if dumping, print the CALLER, NAME, and RESULT,\n-// returning RESULT.\n-\n-bool\n-trace_ranger::trailer (unsigned counter, const char *caller, bool result,\n-\t\t       tree name, const irange &r)\n-{\n-  if (dumping (counter, true))\n-    {\n-      indent -= bump;\n-      fputs(result ? \"TRUE : \" : \"FALSE : \", dump_file);\n-      fprintf (dump_file, \"(%u) \", counter);\n-      fputs (caller, dump_file);\n-      fputs (\" (\",dump_file);\n-      if (name)\n-\tprint_generic_expr (dump_file, name, TDF_SLIM);\n-      fputs (\") \",dump_file);\n-      if (result)\n-\t{\n-\t  r.dump (dump_file);\n-\t  fputc('\\n', dump_file);\n-\t}\n-      else\n-\tfputc('\\n', dump_file);\n-      // Marks the end of a request.\n-      if (indent == 0)\n-\tfputc('\\n', dump_file);\n-    }\n-  return result;\n-}\n-\n-// Tracing version of range_on_edge.  Call it with printing wrappers.\n-\n-bool\n-trace_ranger::range_on_edge (irange &r, edge e, tree name)\n-{\n-  unsigned idx = ++trace_count;\n-  if (dumping (idx))\n-    {\n-      fprintf (dump_file, \"range_on_edge (\");\n-      print_generic_expr (dump_file, name, TDF_SLIM);\n-      fprintf (dump_file, \") on edge %d->%d\\n\", e->src->index, e->dest->index);\n-      indent += bump;\n-    }\n-\n-  bool res = gimple_ranger::range_on_edge (r, e, name);\n-  trailer (idx, \"range_on_edge\", true, name, r);\n-  return res;\n-}\n-\n-// Tracing version of range_on_entry.  Call it with printing wrappers.\n-\n-void\n-trace_ranger::range_on_entry (irange &r, basic_block bb, tree name)\n-{\n-  unsigned idx = ++trace_count;\n-  if (dumping (idx))\n-    {\n-      fprintf (dump_file, \"range_on_entry (\");\n-      print_generic_expr (dump_file, name, TDF_SLIM);\n-      fprintf (dump_file, \") to BB %d\\n\", bb->index);\n-      indent += bump;\n-    }\n-\n-  gimple_ranger::range_on_entry (r, bb, name);\n-\n-  trailer (idx, \"range_on_entry\", true, name, r);\n-}\n-\n-// Tracing version of range_on_exit.  Call it with printing wrappers.\n-\n-void\n-trace_ranger::range_on_exit (irange &r, basic_block bb, tree name)\n-{\n-  unsigned idx = ++trace_count;\n-  if (dumping (idx))\n-    {\n-      fprintf (dump_file, \"range_on_exit (\");\n-      print_generic_expr (dump_file, name, TDF_SLIM);\n-      fprintf (dump_file, \") from BB %d\\n\", bb->index);\n-      indent += bump;\n-    }\n-\n-  gimple_ranger::range_on_exit (r, bb, name);\n-\n-  trailer (idx, \"range_on_exit\", true, name, r);\n-}\n-\n-// Tracing version of range_of_stmt.  Call it with printing wrappers.\n-\n-bool\n-trace_ranger::range_of_stmt (irange &r, gimple *s, tree name)\n-{\n-  bool res;\n-  unsigned idx = ++trace_count;\n-  if (dumping (idx))\n-    {\n-      fprintf (dump_file, \"range_of_stmt (\");\n-      if (name)\n-\tprint_generic_expr (dump_file, name, TDF_SLIM);\n-      fputs (\") at stmt \", dump_file);\n-      print_gimple_stmt (dump_file, s, 0, TDF_SLIM);\n-      indent += bump;\n-    }\n-\n-  res = gimple_ranger::range_of_stmt (r, s, name);\n-\n-  return trailer (idx, \"range_of_stmt\", res, name, r);\n-}\n-\n-// Tracing version of range_of_expr.  Call it with printing wrappers.\n-\n-bool\n-trace_ranger::range_of_expr (irange &r, tree name, gimple *s)\n-{\n-  bool res;\n-  unsigned idx = ++trace_count;\n-  if (dumping (idx))\n-    {\n-      fprintf (dump_file, \"range_of_expr(\");\n-      print_generic_expr (dump_file, name, TDF_SLIM);\n-      fputs (\")\", dump_file);\n-      if (s)\n-\t{\n-\t  fputs (\" at stmt \", dump_file);\n-\t  print_gimple_stmt (dump_file, s, 0, TDF_SLIM);\n-\t}\n-      else\n-\tfputs (\"\\n\", dump_file);\n-      indent += bump;\n-    }\n-\n-  res = gimple_ranger::range_of_expr (r, name, s);\n-\n-  return trailer (idx, \"range_of_expr\", res, name, r);\n-}\n-\n gimple_ranger *\n enable_ranger (struct function *fun)\n {\n   gimple_ranger *r;\n \n-  if (param_evrp_mode & EVRP_MODE_TRACE)\n-    r = new trace_ranger;\n-  else\n-    r = new gimple_ranger;\n-\n+  r = new gimple_ranger;\n   fun->x_range_query = r;\n \n   return r;\n@@ -509,84 +399,3 @@ disable_ranger (struct function *fun)\n \n   fun->x_range_query = &global_ranges;\n }\n-\n-// =========================================\n-// Debugging helpers.\n-// =========================================\n-\n-// Query all statements in the IL to precalculate computable ranges in RANGER.\n-\n-static DEBUG_FUNCTION void\n-debug_seed_ranger (gimple_ranger &ranger)\n-{\n-  // Recalculate SCEV to make sure the dump lists everything.\n-  if (scev_initialized_p ())\n-    {\n-      scev_finalize ();\n-      scev_initialize ();\n-    }\n-\n-  basic_block bb;\n-  int_range_max r;\n-  gimple_stmt_iterator gsi;\n-  FOR_EACH_BB_FN (bb, cfun)\n-    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-      {\n-\tgimple *stmt = gsi_stmt (gsi);\n-\n-\tif (is_gimple_debug (stmt))\n-\t  continue;\n-\n-\tranger.range_of_stmt (r, stmt);\n-      }\n-}\n-\n-// Dump all that ranger knows for the current function.\n-\n-DEBUG_FUNCTION void\n-dump_ranger (FILE *out)\n-{\n-  gimple_ranger ranger;\n-  debug_seed_ranger (ranger);\n-  ranger.dump (out);\n-}\n-\n-DEBUG_FUNCTION void\n-debug_ranger ()\n-{\n-  dump_ranger (stderr);\n-}\n-\n-// Dump all that ranger knows on a path of BBs.\n-//\n-// Note that the blocks are in reverse order, thus the exit block is\n-// path[0].\n-\n-DEBUG_FUNCTION void\n-dump_ranger (FILE *dump_file, const vec<basic_block> &path)\n-{\n-  if (path.length () == 0)\n-    {\n-      fprintf (dump_file, \"empty\\n\");\n-      return;\n-    }\n-\n-  gimple_ranger ranger;\n-  debug_seed_ranger (ranger);\n-\n-  unsigned i = path.length ();\n-  do\n-    {\n-      i--;\n-      ranger.dump_bb (dump_file, path[i]);\n-    }\n-  while (i > 0);\n-}\n-\n-DEBUG_FUNCTION void\n-debug_ranger (const vec<basic_block> &path)\n-{\n-  dump_ranger (stderr, path);\n-}\n-\n-#include \"gimple-range-tests.cc\""}, {"sha": "41845b14fd6395e1aac5ecb1bb0dbc4e5718a42b", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 4, "deletions": 30, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e68c8280fa2e1b7071378cfdd876155c73ec944f/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e68c8280fa2e1b7071378cfdd876155c73ec944f/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=e68c8280fa2e1b7071378cfdd876155c73ec944f", "patch": "@@ -22,10 +22,10 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_GIMPLE_RANGE_H\n #define GCC_GIMPLE_RANGE_H\n \n-\n #include \"range.h\"\n #include \"value-query.h\"\n #include \"range-op.h\"\n+#include \"gimple-range-trace.h\"\n #include \"gimple-range-edge.h\"\n #include \"gimple-range-fold.h\"\n #include \"gimple-range-gori.h\"\n@@ -43,51 +43,25 @@ along with GCC; see the file COPYING3.  If not see\n // type is not supported, then false is returned.  Non-statement\n // related methods return whatever the current global value is.\n \n-\n class gimple_ranger : public range_query\n {\n public:\n   gimple_ranger ();\n   virtual bool range_of_stmt (irange &r, gimple *, tree name = NULL) OVERRIDE;\n   virtual bool range_of_expr (irange &r, tree name, gimple * = NULL) OVERRIDE;\n   virtual bool range_on_edge (irange &r, edge e, tree name) OVERRIDE;\n-  virtual void range_on_entry (irange &r, basic_block bb, tree name);\n-  virtual void range_on_exit (irange &r, basic_block bb, tree name);\n+  void range_on_entry (irange &r, basic_block bb, tree name);\n+  void range_on_exit (irange &r, basic_block bb, tree name);\n   void export_global_ranges ();\n   inline gori_compute &gori ()  { return m_cache.m_gori; }\n   virtual void dump (FILE *f) OVERRIDE;\n   void dump_bb (FILE *f, basic_block bb);\n protected:\n   bool fold_range_internal (irange &r, gimple *s, tree name);\n   ranger_cache m_cache;\n+  range_tracer tracer;\n };\n \n-\n-// This class overloads the ranger routines to provide tracing facilties\n-// Entry and exit values to each of the APIs is placed in the dumpfile.\n-\n-class trace_ranger : public gimple_ranger\n-{\n-public:\n-  trace_ranger ();\n-  virtual bool range_of_stmt (irange &r, gimple *s, tree name = NULL_TREE);\n-  virtual bool range_of_expr (irange &r, tree name, gimple *s = NULL);\n-  virtual bool range_on_edge (irange &r, edge e, tree name);\n-  virtual void range_on_entry (irange &r, basic_block bb, tree name);\n-  virtual void range_on_exit (irange &r, basic_block bb, tree name);\n-private:\n-  static const unsigned bump = 2;\n-  unsigned indent;\n-  unsigned trace_count;\t\t// Current trace index count.\n-\n-  bool dumping (unsigned counter, bool trailing = false);\n-  bool trailer (unsigned counter, const char *caller, bool result, tree name,\n-\t\tconst irange &r);\n-};\n-\n-// Flag to enable debugging the various internal Caches.\n-#define DEBUG_RANGE_CACHE (dump_file && (param_evrp_mode & EVRP_MODE_DEBUG))\n-\n extern gimple_ranger *enable_ranger (struct function *);\n extern void disable_ranger (struct function *);\n "}]}