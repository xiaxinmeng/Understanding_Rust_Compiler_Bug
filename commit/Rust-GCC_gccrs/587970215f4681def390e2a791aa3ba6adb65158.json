{"sha": "587970215f4681def390e2a791aa3ba6adb65158", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg3OTcwMjE1ZjQ2ODFkZWYzOTBlMmE3OTFhYTNiYTZhZGI2NTE1OA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@gmail.com", "date": "2020-04-22T06:27:54Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-04-22T06:27:54Z"}, "message": "c++: reject scalar array initialization with nullptr [PR94510]\n\nThe change committed to GCC 9 to allow string literals as template arguments\ncaused the compiler to prune away, and thus miss diagnosing, conversion from\nnullptr to int in an array initializer.  After looking at various approaches\nto improving the pruning, we realized that the only place the pruning is\nnecessary is in the mangler.\n\ngcc/cp/ChangeLog\n2020-04-22  Martin Sebor  <msebor@redhat.com>\n\t    Jason Merrill  <jason@redhat.com>\n\n\tPR c++/94510\n\t* decl.c (reshape_init_array_1): Avoid stripping redundant trailing\n\tzero initializers...\n\t* mangle.c (write_expression): ...and handle them here even for\n\tpointers to members by calling zero_init_expr_p.\n\t* cp-tree.h (zero_init_expr_p): Declare.\n\t* tree.c (zero_init_expr_p): Define.\n\t(type_initializer_zero_p): Remove.\n\t* pt.c (tparm_obj_values): New hash_map.\n\t(get_template_parm_object): Store to it.\n\t(tparm_object_argument): New.\n\ngcc/testsuite/ChangeLog\n2020-04-22  Martin Sebor  <msebor@redhat.com>\n\n\tPR c++/94510\n\t* g++.dg/init/array58.C: New test.\n\t* g++.dg/init/array59.C: New test.\n\t* g++.dg/cpp2a/nontype-class34.C: New test.\n\t* g++.dg/cpp2a/nontype-class35.C: New test.", "tree": {"sha": "7fa9b0fe0ce7efd2a32648ee5a9accf301858ea5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fa9b0fe0ce7efd2a32648ee5a9accf301858ea5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/587970215f4681def390e2a791aa3ba6adb65158", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/587970215f4681def390e2a791aa3ba6adb65158", "html_url": "https://github.com/Rust-GCC/gccrs/commit/587970215f4681def390e2a791aa3ba6adb65158", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/587970215f4681def390e2a791aa3ba6adb65158/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fe9eaaa083b6cc032cbd3ad1286b1dd73ccdf54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fe9eaaa083b6cc032cbd3ad1286b1dd73ccdf54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fe9eaaa083b6cc032cbd3ad1286b1dd73ccdf54"}], "stats": {"total": 482, "additions": 333, "deletions": 149}, "files": [{"sha": "640e4948130ec42493946c75f215c424a9e237e8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=587970215f4681def390e2a791aa3ba6adb65158", "patch": "@@ -1,3 +1,18 @@\n+2020-04-22  Martin Sebor  <msebor@redhat.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/94510\n+\t* decl.c (reshape_init_array_1): Avoid stripping redundant trailing\n+\tzero initializers...\n+\t* mangle.c (write_expression): ...and handle them here even for\n+\tpointers to members by calling zero_init_expr_p.\n+\t* cp-tree.h (zero_init_expr_p): Declare.\n+\t* tree.c (zero_init_expr_p): Define.\n+\t(type_initializer_zero_p): Remove.\n+\t* pt.c (tparm_obj_values): New hash_map.\n+\t(get_template_parm_object): Store to it.\n+\t(tparm_object_argument): New.\n+\n 2020-04-22  Patrick Palka  <ppalka@redhat.com>\n \n \tPR c++/67825"}, {"sha": "924c0b9c79076711b0a8fb45db9eb67f9d0fd8d8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=587970215f4681def390e2a791aa3ba6adb65158", "patch": "@@ -7001,6 +7001,7 @@ enum { nt_opaque = false, nt_transparent = true };\n extern tree alias_template_specialization_p     (const_tree, bool);\n extern tree dependent_alias_template_spec_p     (const_tree, bool);\n extern bool template_parm_object_p\t\t(const_tree);\n+extern tree tparm_object_argument\t\t(tree);\n extern bool explicit_class_specialization_p     (tree);\n extern bool push_tinst_level                    (tree);\n extern bool push_tinst_level_loc                (tree, location_t);\n@@ -7375,6 +7376,7 @@ extern bool type_has_nontrivial_copy_init\t(const_tree);\n extern void maybe_warn_parm_abi\t\t\t(tree, location_t);\n extern bool class_tmpl_impl_spec_p\t\t(const_tree);\n extern int zero_init_p\t\t\t\t(const_tree);\n+extern bool zero_init_expr_p\t\t\t(tree);\n extern bool check_abi_tag_redeclaration\t\t(const_tree, const_tree,\n \t\t\t\t\t\t const_tree);\n extern bool check_abi_tag_args\t\t\t(tree, tree);\n@@ -7492,11 +7494,6 @@ extern tree cxx_copy_lang_qualifiers\t\t(const_tree, const_tree);\n \n extern void cxx_print_statistics\t\t(void);\n extern bool maybe_warn_zero_as_null_pointer_constant (tree, location_t);\n-/* Analogous to initializer_zerop but also examines the type for\n-   which the initializer is being used.  Unlike initializer_zerop,\n-   considers empty strings to be zero initializers for arrays and\n-   non-zero for pointers.  */\n-extern bool type_initializer_zero_p\t\t(tree, tree);\n \n /* in ptree.c */\n extern void cxx_print_xnode\t\t\t(FILE *, tree, int);"}, {"sha": "c8c2f080763de2f12c37a0696e0ba4792f90a5c8", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=587970215f4681def390e2a791aa3ba6adb65158", "patch": "@@ -6038,9 +6038,6 @@ reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d,\n \tmax_index_cst = tree_to_uhwi (fold_convert (size_type_node, max_index));\n     }\n \n-  /* Set to the index of the last element with a non-zero initializer.\n-     Zero initializers for elements past this one can be dropped.  */\n-  unsigned HOST_WIDE_INT last_nonzero = -1;\n   /* Loop until there are no more initializers.  */\n   for (index = 0;\n        d->cur != d->end && (!sized_array_p || index <= max_index_cst);\n@@ -6067,50 +6064,11 @@ reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d,\n       if (!TREE_CONSTANT (elt_init))\n \tTREE_CONSTANT (new_init) = false;\n \n-      /* Pointers initialized to strings must be treated as non-zero\n-\t even if the string is empty.  */\n-      tree init_type = TREE_TYPE (elt_init);\n-      if (POINTER_TYPE_P (elt_type) != POINTER_TYPE_P (init_type)\n-\t  || !type_initializer_zero_p (elt_type, elt_init))\n-\tlast_nonzero = index;\n-\n       /* This can happen with an invalid initializer (c++/54501).  */\n       if (d->cur == old_cur && !sized_array_p)\n \tbreak;\n     }\n \n-  if (sized_array_p && trivial_type_p (elt_type))\n-    {\n-      /* Strip trailing zero-initializers from an array of a trivial\n-\t type of known size.  They are redundant and get in the way\n-\t of telling them apart from those with implicit zero value.  */\n-      unsigned HOST_WIDE_INT nelts = CONSTRUCTOR_NELTS (new_init);\n-      if (last_nonzero > nelts)\n-\tnelts = 0;\n-      else if (last_nonzero < nelts - 1)\n-\tnelts = last_nonzero + 1;\n-\n-      /* Sharing a stripped constructor can get in the way of\n-\t overload resolution.  E.g., initializing a class from\n-\t {{0}} might be invalid while initializing the same class\n-\t from {{}} might be valid.  */\n-      if (reuse && nelts < CONSTRUCTOR_NELTS (new_init))\n-\t{\n-\t  vec<constructor_elt, va_gc> *v;\n-\t  vec_alloc (v, nelts);\n-\t  for (unsigned int i = 0; i < nelts; i++)\n-\t    {\n-\t      constructor_elt elt = *CONSTRUCTOR_ELT (new_init, i);\n-\t      if (TREE_CODE (elt.value) == CONSTRUCTOR)\n-\t\telt.value = unshare_constructor (elt.value);\n-\t      v->quick_push (elt);\n-\t    }\n-\t  new_init = build_constructor (TREE_TYPE (new_init), v);\n-\t}\n-      else\n-\tvec_safe_truncate (CONSTRUCTOR_ELTS (new_init), nelts);\n-    }\n-\n   return new_init;\n }\n "}, {"sha": "090fb529a98507ce24f8d1b02de456f3dcc4b8d8", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=587970215f4681def390e2a791aa3ba6adb65158", "patch": "@@ -3176,7 +3176,8 @@ write_expression (tree expr)\n \t  write_type (etype);\n \t}\n \n-      if (!initializer_zerop (expr) || !trivial_type_p (etype))\n+      bool nontriv = !trivial_type_p (etype);\n+      if (nontriv || !zero_init_expr_p (expr))\n \t{\n \t  /* Convert braced initializer lists to STRING_CSTs so that\n \t     A<\"Foo\"> mangles the same as A<{'F', 'o', 'o', 0}> while\n@@ -3187,19 +3188,22 @@ write_expression (tree expr)\n \t  if (TREE_CODE (expr) == CONSTRUCTOR)\n \t    {\n \t      vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (expr);\n-\t      unsigned last_nonzero = -1, i;\n+\t      unsigned last_nonzero = UINT_MAX, i;\n \t      tree val;\n \n-\t      FOR_EACH_CONSTRUCTOR_VALUE (elts, i, val)\n-\t\tif (!initializer_zerop (val))\n-\t\t  last_nonzero = i;\n+\t      if (!nontriv)\n+\t\tFOR_EACH_CONSTRUCTOR_VALUE (elts, i, val)\n+\t\t  if (!zero_init_expr_p (val))\n+\t\t    last_nonzero = i;\n \n-\t      FOR_EACH_CONSTRUCTOR_VALUE (elts, i, val)\n-\t\t{\n-\t\t  if (i > last_nonzero)\n-\t\t    break;\n-\t\t  write_expression (val);\n-\t\t}\n+\t      if (nontriv || last_nonzero != UINT_MAX)\n+\t\tFOR_EACH_CONSTRUCTOR_VALUE (elts, i, val)\n+\t\t  {\n+\t\t    if (i > last_nonzero)\n+\t\t      break;\n+\t\t    /* FIXME handle RANGE_EXPR */\n+\t\t    write_expression (val);\n+\t\t  }\n \t    }\n \t  else\n \t    {\n@@ -3525,7 +3529,7 @@ write_template_arg (tree node)\n \n   if (template_parm_object_p (node))\n     /* We want to mangle the argument, not the var we stored it in.  */\n-    node = DECL_INITIAL (node);\n+    node = tparm_object_argument (node);\n \n   /* Strip a conversion added by convert_nontype_argument.  */\n   if (TREE_CODE (node) == IMPLICIT_CONV_EXPR)"}, {"sha": "7bf249cee5ce494ef863e3f38706d46f728c3eb5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=587970215f4681def390e2a791aa3ba6adb65158", "patch": "@@ -7006,6 +7006,11 @@ invalid_tparm_referent_p (tree type, tree expr, tsubst_flags_t complain)\n \n }\n \n+/* The template arguments corresponding to template parameter objects of types\n+   that contain pointers to members.  */\n+\n+static GTY(()) hash_map<tree, tree> *tparm_obj_values;\n+\n /* Return a VAR_DECL for the C++20 template parameter object corresponding to\n    template argument EXPR.  */\n \n@@ -7039,10 +7044,32 @@ get_template_parm_object (tree expr, tsubst_flags_t complain)\n   SET_DECL_ASSEMBLER_NAME (decl, name);\n   DECL_CONTEXT (decl) = global_namespace;\n   comdat_linkage (decl);\n+\n+  if (!zero_init_p (type))\n+    {\n+      /* If EXPR contains any PTRMEM_CST, they will get clobbered by\n+\t lower_var_init before we're done mangling.  So store the original\n+\t value elsewhere.  */\n+      tree copy = unshare_constructor (expr);\n+      hash_map_safe_put<hm_ggc> (tparm_obj_values, decl, copy);\n+    }\n+\n   pushdecl_top_level_and_finish (decl, expr);\n+\n   return decl;\n }\n \n+/* Return the actual template argument corresponding to template parameter\n+   object VAR.  */\n+\n+tree\n+tparm_object_argument (tree var)\n+{\n+  if (zero_init_p (TREE_TYPE (var)))\n+    return DECL_INITIAL (var);\n+  return *(tparm_obj_values->get (var));\n+}\n+\n /* Attempt to convert the non-type template parameter EXPR to the\n    indicated TYPE.  If the conversion is successful, return the\n    converted value.  If the conversion is unsuccessful, return"}, {"sha": "090c565c093436f0d462c0fb7f4b9226f36ecca4", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 27, "deletions": 70, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=587970215f4681def390e2a791aa3ba6adb65158", "patch": "@@ -4478,6 +4478,33 @@ zero_init_p (const_tree t)\n   return 1;\n }\n \n+/* Returns true if the expression or initializer T is the result of\n+   zero-initialization for its type, taking pointers to members\n+   into consideration.  */\n+\n+bool\n+zero_init_expr_p (tree t)\n+{\n+  tree type = TREE_TYPE (t);\n+  if (!type || dependent_type_p (type))\n+    return false;\n+  if (zero_init_p (type))\n+    return initializer_zerop (t);\n+  if (TYPE_PTRMEM_P (type))\n+    return null_member_pointer_value_p (t);\n+  if (TREE_CODE (t) == CONSTRUCTOR\n+      && CP_AGGREGATE_TYPE_P (type))\n+    {\n+      tree elt_init;\n+      unsigned HOST_WIDE_INT i;\n+      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (t), i, elt_init)\n+\tif (!zero_init_expr_p (elt_init))\n+\t  return false;\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* True IFF T is a C++20 structural type (P1907R1) that can be used as a\n    non-type template parameter.  If EXPLAIN, explain why not.  */\n \n@@ -5746,76 +5773,6 @@ maybe_warn_zero_as_null_pointer_constant (tree expr, location_t loc)\n   return false;\n }\n \f\n-/* Given an initializer INIT for a TYPE, return true if INIT is zero\n-   so that it can be replaced by value initialization.  This function\n-   distinguishes betwen empty strings as initializers for arrays and\n-   for pointers (which make it return false).  */\n-\n-bool\n-type_initializer_zero_p (tree type, tree init)\n-{\n-  if (type == error_mark_node || init == error_mark_node)\n-    return false;\n-\n-  STRIP_NOPS (init);\n-\n-  if (POINTER_TYPE_P (type))\n-    return TREE_CODE (init) != STRING_CST && initializer_zerop (init);\n-\n-  if (TREE_CODE (init) != CONSTRUCTOR)\n-    {\n-      /* A class can only be initialized by a non-class type if it has\n-\t a ctor that converts from that type.  Such classes are excluded\n-\t since their semantics are unknown.  */\n-      if (RECORD_OR_UNION_TYPE_P (type)\n-\t  && !RECORD_OR_UNION_TYPE_P (TREE_TYPE (init)))\n-\treturn false;\n-      return initializer_zerop (init);\n-    }\n-\n-  if (TREE_CODE (type) == ARRAY_TYPE)\n-    {\n-      tree elt_type = TREE_TYPE (type);\n-      elt_type = TYPE_MAIN_VARIANT (elt_type);\n-      if (elt_type == char_type_node)\n-\treturn initializer_zerop (init);\n-\n-      tree elt_init;\n-      unsigned HOST_WIDE_INT i;\n-      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), i, elt_init)\n-\tif (!type_initializer_zero_p (elt_type, elt_init))\n-\t  return false;\n-      return true;\n-    }\n-\n-  if (TREE_CODE (type) != RECORD_TYPE)\n-    return initializer_zerop (init);\n-\n-  if (TYPE_NON_AGGREGATE_CLASS (type))\n-    return false;\n-\n-  tree fld = TYPE_FIELDS (type);\n-\n-  tree fld_init;\n-  unsigned HOST_WIDE_INT i;\n-  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), i, fld_init)\n-    {\n-      fld = next_initializable_field (fld);\n-      if (!fld)\n-\treturn true;\n-\n-      tree fldtype = TREE_TYPE (fld);\n-      if (!type_initializer_zero_p (fldtype, fld_init))\n-\treturn false;\n-\n-      fld = DECL_CHAIN (fld);\n-      if (!fld)\n-\tbreak;\n-    }\n-\n-  return true;\n-}\n-\f\n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n /* Complain that some language-specific thing hanging off a tree\n    node has been accessed improperly.  */"}, {"sha": "921f81e9a8872d26693fde80b45d4c8f918ae350", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=587970215f4681def390e2a791aa3ba6adb65158", "patch": "@@ -1,3 +1,11 @@\n+2020-04-22  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/94510\n+\t* g++.dg/init/array58.C: New test.\n+\t* g++.dg/init/array59.C: New test.\n+\t* g++.dg/cpp2a/nontype-class34.C: New test.\n+\t* g++.dg/cpp2a/nontype-class35.C: New test.\n+\n 2020-04-22  Patrick Palka  <ppalka@redhat.com>\n \n \tPR c++/67825"}, {"sha": "308865bd2c6f55712432a0b8cdf3c98e6d2a9f4f", "filename": "gcc/testsuite/g++.dg/abi/mangle72.C", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle72.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle72.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle72.C?ref=587970215f4681def390e2a791aa3ba6adb65158", "patch": "@@ -24,56 +24,50 @@ struct B { padm_t a[2]; };\n template <B> struct Y { };\n \n void g__ (Y<B{{ }}>) { }\n-// { dg-final { scan-assembler \"_Z3g__1YIXtl1BtlA2_M1AA2_iLS3_0EEEEE\" } }\n+// { dg-final { scan-assembler \"_Z3g__1YIXtl1BEEE\" } }\n \n void g0_ (Y<B{{ 0 }}>) { }\n-// { dg-final { scan-assembler \"_Z3g0_1YIXtl1BtlA2_M1AA2_iLS3_0EEEEE\" } }\n+// { dg-final { scan-assembler \"_Z3g0_1YIXtl1BEEE\" } }\n \n void g00 (Y<B{{ 0, 0 }}>) { }\n-// { dg-final { scan-assembler \"_Z3g001YIXtl1BtlA2_M1AA2_iLS3_0EEEEE\" } }\n+// { dg-final { scan-assembler \"_Z3g001YIXtl1BEEE\" } }\n \n void g0x (Y<B{{ 0, &A::a }}>) { }\n-// FIXME: This needs to mangle differently from g00.  The space at\n-// the end is intentional to make the directive fail so that the xfail\n-// can be reminder to change this once the mangling is fixed.\n-// { dg-final { scan-assembler \"_Z3g0x1YIXtl1BtlA2_M1AA2_iLS3_0EEEEE \" { xfail *-*-* } } }\n+// { dg-final { scan-assembler \"_Z3g0x1YIXtl1BtlA2_M1AA2_iLS3_0EadL_ZNS1_1aEEEEEE\" } }\n \n void gx_ (Y<B{{ &A::a }}>) { }\n-// { dg-final { scan-assembler \"_Z3gx_1YIXtl1BtlA2_M1AA2_iLS3_0ELS3_0EEEEE\" } }\n+// { dg-final { scan-assembler \"_Z3gx_1YIXtl1BtlA2_M1AA2_iadL_ZNS1_1aEEEEEE\" } }\n \n \n struct C { padm_t a[3]; };\n template <C> struct Z { };\n \n void h___ (Z<C{{ }}>) { }\n-// { dg-final { scan-assembler \"_Z4h___1ZIXtl1CtlA3_M1AA2_iLS3_0EEEEE\" } }\n+// { dg-final { scan-assembler \"_Z4h___1ZIXtl1CEEE\" } }\n \n void h0__ (Z<C{{ 0 }}>) { }\n-// { dg-final { scan-assembler \"_Z4h0__1ZIXtl1CtlA3_M1AA2_iLS3_0EEEEE\" } }\n+// { dg-final { scan-assembler \"_Z4h0__1ZIXtl1CEEE\" } }\n \n void h00_ (Z<C{{ 0, 0 }}>) { }\n-// { dg-final { scan-assembler \"_Z4h00_1ZIXtl1CtlA3_M1AA2_iLS3_0EEEEE\" } }\n+// { dg-final { scan-assembler \"_Z4h00_1ZIXtl1CEEE\" } }\n \n void h000 (Z<C{{ 0, 0, 0 }}>) { }\n-// { dg-final { scan-assembler \"_Z4h0001ZIXtl1CtlA3_M1AA2_iLS3_0EEEEE\" } }\n+// { dg-final { scan-assembler \"_Z4h0001ZIXtl1CEEE\" } }\n \n void h00x (Z<C{{ 0, 0, &A::a }}>) { }\n-// FIXME: This needs to mangle differently from hx0_ and hx__.\n-// { dg-final { scan-assembler \"_Z4h00x1ZIXtl1CtlA3_M1AA2_iLS3_0ELS3_0EEEEE \" { xfail *-*-*} } }\n+// { dg-final { scan-assembler \"_Z4h00x1ZIXtl1CtlA3_M1AA2_iLS3_0ELS3_0EadL_ZNS1_1aEEEEEE\" } }\n \n void h0x0 (Z<C{{ 0, &A::a, 0 }}>) { }\n-// { dg-final { scan-assembler \"_Z4h0x01ZIXtl1CtlA3_M1AA2_iLS3_0ELS3_0ELS3_0EEEEE\" } }\n+// { dg-final { scan-assembler \"_Z4h0x01ZIXtl1CtlA3_M1AA2_iLS3_0EadL_ZNS1_1aEEEEEE\" } }\n \n void h0x_ (Z<C{{ 0, &A::a }}>) { }\n-// { dg-final { scan-assembler \"_Z4h0x_1ZIXtl1CtlA3_M1AA2_iLS3_0ELS3_0ELS3_0EEEEE\" } }\n+// { dg-final { scan-assembler \"_Z4h0x_1ZIXtl1CtlA3_M1AA2_iLS3_0EadL_ZNS1_1aEEEEEE\" } }\n \n void hx0_ (Z<C{{ &A::a, 0 }}>) { }\n-// FIXME: This needs to mangle differently from h00x and hx__.\n-// { dg-final { scan-assembler \"_Z4hx0_1ZIXtl1CtlA3_M1AA2_iLS3_0ELS3_0EEEEE \" { xfail *-*-*} } }\n+// { dg-final { scan-assembler \"_Z4hx0_1ZIXtl1CtlA3_M1AA2_iadL_ZNS1_1aEEEEEE\" } }\n \n void hx__ (Z<C{{ &A::a }}>) { }\n-// FIXME: This needs to mangle differently from h00x and hx0_.\n-// { dg-final { scan-assembler \"_Z4hx__1ZIXtl1CtlA3_M1AA2_iLS3_0ELS3_0EEEEE \" { xfail *-*-* } } }\n+// { dg-final { scan-assembler \"_Z4hx__1ZIXtl1CtlA3_M1AA2_iadL_ZNS1_1aEEEEEE\" } }\n \n \n // Exercise arrays of pointers to function members."}, {"sha": "1c1e23c10a87c4dc57a209ad2c77d5ae2a47c7a2", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class36.C", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class36.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class36.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class36.C?ref=587970215f4681def390e2a791aa3ba6adb65158", "patch": "@@ -0,0 +1,76 @@\n+/* PR c++/94510 - nullptr_t implicitly cast to zero twice in std::array\n+   { dg-do compile { target c++2a } }\n+   { dg-options \"-Wall\" } */\n+\n+struct A { int i; int f (); };\n+typedef int A::*MemPtr;\n+typedef int (A::*MemFuncPtr)();\n+\n+struct B { MemPtr a[3]; MemFuncPtr b[3]; };\n+\n+static const constexpr MemPtr mp0 = { 0 };\n+static const constexpr MemPtr mpn = { nullptr };\n+static const constexpr MemPtr mp_ = { };\n+static const constexpr MemPtr mpi = { &A::i };\n+\n+template <B> struct X { };\n+\n+typedef X<B{ }>                               XB;\n+typedef X<B{ 0 }>                             XB;\n+typedef X<B{{ 0 }}>                           XB;\n+typedef X<B{{ MemPtr{ }}}>                    XB;\n+typedef X<B{{ MemPtr{ 0 }}}>                  XB;\n+typedef X<B{{ MemPtr () }}>                   XB;\n+typedef X<B{{ MemPtr{ nullptr }}}>            XB;\n+typedef X<B{{ mp_ }}>                         XB;\n+typedef X<B{{ mpn }}>                         XB;\n+typedef X<B{{ mp0 }}>                         XB;\n+\n+typedef X<B{ mpi }>                           XBp;\n+typedef X<B{ mpi, 0 }>                        XBp;\n+typedef X<B{{ mpi, 0 }}>                      XBp;\n+typedef X<B{{ mpi, MemPtr{ }}}>               XBp;\n+typedef X<B{{ mpi, MemPtr{ 0 }}}>             XBp;\n+typedef X<B{{ mpi, MemPtr () }}>              XBp;\n+typedef X<B{{ mpi, MemPtr{ nullptr }}}>       XBp;\n+typedef X<B{{ mpi, mp_ }}>                    XBp;\n+typedef X<B{{ mpi, mpn }}>                    XBp;\n+typedef X<B{{ mpi, mp0 }}>                    XBp;\n+\n+typedef X<B{ mpi, mpi }>                      XBpp;\n+typedef X<B{ mpi, mpi, 0 }>                   XBpp;\n+typedef X<B{{ mpi, mpi, 0 }}>                 XBpp;\n+typedef X<B{{ mpi, mpi, MemPtr{ }}}>          XBpp;\n+typedef X<B{{ mpi, mpi, MemPtr{ 0 }}}>        XBpp;\n+typedef X<B{{ mpi, mpi, MemPtr () }}>         XBpp;\n+typedef X<B{{ mpi, mpi, MemPtr{ nullptr }}}>  XBpp;\n+typedef X<B{{ mpi, mpi, mp_ }}>               XBpp;\n+typedef X<B{{ mpi, mpi, mpn }}>               XBpp;\n+typedef X<B{{ mpi, mpi, mp0 }}>               XBpp;\n+\n+typedef X<B{ 0, mpi }>                        XB0p;\n+typedef X<B{ nullptr, mpi, 0 }>               XB0p;\n+typedef X<B{ mp0, mpi, 0 }>                   XB0p;\n+\n+typedef X<B{ 0, 0, mpi }>                     XB00p;\n+typedef X<B{ 0, nullptr, mpi }>               XB00p;\n+typedef X<B{ nullptr, 0, mpi }>               XB00p;\n+typedef X<B{ nullptr, nullptr, mpi }>         XB00p;\n+typedef X<B{ MemPtr{ }, MemPtr{ }, mpi }>     XB00p;\n+typedef X<B{ mp0, MemPtr{ }, mpi }>           XB00p;\n+typedef X<B{ mpn, mpn, mpi }>                 XB00p;\n+typedef X<B{ mpn, mp_, mpi }>                 XB00p;  // { dg-bogus \"conflicting declaration\" \"pr94568\" { xfail *-*-* } }\n+\n+static const constexpr MemFuncPtr mfp0 = { 0 };\n+static const constexpr MemFuncPtr mfpn = { nullptr };\n+static const constexpr MemFuncPtr mfp_ = { };\n+\n+typedef X<B{{ }, { }}>                        XB;\n+typedef X<B{{ }, { 0 }}>                      XB;\n+typedef X<B{{ }, { MemFuncPtr{ }}}>           XB;\n+typedef X<B{{ }, { MemFuncPtr{ 0 }}}>         XB;\n+typedef X<B{{ }, { MemFuncPtr () }}>          XB;\n+typedef X<B{{ }, { MemFuncPtr{ nullptr }}}>   XB;\n+typedef X<B{{ }, { mfp_ }}>                   XB;\n+typedef X<B{{ }, { mfpn }}>                   XB;\n+typedef X<B{{ }, { mfp0 }}>                   XB;"}, {"sha": "5649fa2e6dc180dd3c1dfed9b537f4dcfb27b9a0", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class37.C", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class37.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class37.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class37.C?ref=587970215f4681def390e2a791aa3ba6adb65158", "patch": "@@ -0,0 +1,80 @@\n+/* PR c++/94510 - nullptr_t implicitly cast to zero twice in std::array\n+   { dg-do compile { target c++2a } }\n+   { dg-options \"-Wall\" } */\n+\n+struct A { char a[4]; };\n+template <A> struct B { };\n+\n+constexpr const char c0{ };\n+constexpr const char c1{ 1 };\n+\n+typedef B<A{ }>                     BA;\n+typedef B<A{ { } }>                 BA;\n+typedef B<A{ { 0 } }>               BA;\n+typedef B<A{ { c0 } }>              BA;\n+typedef B<A{ { 0, 0 } }>            BA;\n+typedef B<A{ { 0, 0, 0 } }>         BA;\n+typedef B<A{ { 0, 0, 0, 0 } }>      BA;\n+typedef B<A{ { c0, c0, c0 } }>      BA;\n+typedef B<A{ { c0, c0, c0, c0 } }>  BA;\n+typedef B<A{ \"\" }>                  BA;\n+typedef B<A{ \"\\0\" }>                BA;\n+typedef B<A{ \"\\0\\0\" }>              BA;\n+typedef B<A{ \"\\0\\0\\0\" }>            BA;\n+\n+typedef B<A{ 1 }>                   BA1;\n+typedef B<A{ { 1 } }>               BA1;\n+typedef B<A{ { 1, 0 } }>            BA1;\n+typedef B<A{ { 1, 0, 0 } }>         BA1;\n+typedef B<A{ { 1, 0, 0, 0 } }>      BA1;\n+typedef B<A{ { c1 } }>              BA1;\n+typedef B<A{ { c1, c0 } }>          BA1;\n+typedef B<A{ { c1, c0, c0 } }>      BA1;\n+typedef B<A{ { c1, c0, c0, c0 } }>  BA1;\n+typedef B<A{ \"\\1\" }>                BA1;\n+typedef B<A{ \"\\1\\0\" }>              BA1;\n+typedef B<A{ \"\\1\\0\\0\" }>            BA1;\n+\n+typedef B<A{ 0, 1 }>                BA01;\n+typedef B<A{ { 0, 1 } }>            BA01;\n+typedef B<A{ { 0, 1, 0 } }>         BA01;\n+typedef B<A{ { 0, 1, 0, 0 } }>      BA01;\n+typedef B<A{ { c0, c1 } }>          BA01;\n+typedef B<A{ { c0, c1, c0 } }>      BA01;\n+typedef B<A{ { c0, c1, c0, c0 } }>  BA01;\n+typedef B<A{ \"\\0\\1\" }>              BA01;\n+typedef B<A{ \"\\0\\1\\0\" }>            BA01;\n+\n+\n+struct C { int a[4]; };\n+template <C> struct D { };\n+\n+constexpr const int i0{ };\n+\n+typedef D<C{ }>                     DC;\n+typedef D<C{ { } }>                 DC;\n+typedef D<C{ { 0 } }>               DC;\n+typedef D<C{ { 0, 0 } }>            DC;\n+typedef D<C{ { 0, 0, 0 } }>         DC;\n+typedef D<C{ { 0, 0, 0, 0 } }>      DC;\n+typedef D<C{ { i0 } }>              DC;\n+typedef D<C{ { i0, i0 } }>          DC;\n+typedef D<C{ { i0, i0, i0 } }>      DC;\n+typedef D<C{ { i0, i0, i0, i0 } }>  DC;\n+\n+\n+constexpr const int i1{ 1 };\n+\n+typedef D<C{ 1 }>                   DC1;\n+typedef D<C{ { 1 } }>               DC1;\n+typedef D<C{ { 1, 0 } }>            DC1;\n+typedef D<C{ { 1, 0, 0 } }>         DC1;\n+typedef D<C{ { 1, 0, 0, 0 } }>      DC1;\n+typedef D<C{ { i1, i0, i0, i0 } }>  DC1;\n+\n+typedef D<C{ 0, 1 }>                DC01;\n+typedef D<C{ { 0, 1 } }>            DC01;\n+typedef D<C{ { 0, 1, 0 } }>         DC01;\n+typedef D<C{ { 0, 1, 0, 0 } }>      DC01;\n+typedef D<C{ { 0, i1, 0, 0 } }>     DC01;\n+typedef D<C{ { i0, i1, i0, i0 } }>  DC01;   // { dg-bogus \"conflicting declaration\" \"pr94567\" { xfail *-*-* } }"}, {"sha": "70e86445c07af9f7f6ad2992f7f1bbe3982f0fa8", "filename": "gcc/testsuite/g++.dg/init/array58.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray58.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray58.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray58.C?ref=587970215f4681def390e2a791aa3ba6adb65158", "patch": "@@ -0,0 +1,26 @@\n+/* PR c++/94510 - nullptr_t implicitly cast to zero twice in std::array\n+   { dg-do compile } */\n+\n+int ia1[2] = { (void*)0 };              // { dg-error \"invalid conversion from 'void\\\\\\*'\" }\n+int ia2[2] = { (void*)0, 0 };           // { dg-error \"invalid conversion from 'void\\\\\\*'\" }\n+int ia3[] = { (void*)0, 0 };            // { dg-error \"invalid conversion from 'void\\\\\\*'\" }\n+\n+int ia4[2] = { __null };                // { dg-warning \"\\\\\\[-Wconversion-null\" }\n+int ia5[2] = { __null, 0 };             // { dg-warning \"\\\\\\[-Wconversion-null\" }\n+int ia6[] = { __null, 0 };              // { dg-warning \"\\\\\\[-Wconversion-null\" }\n+\n+\n+const char ca1[2] = { (char*)0, 0 };    // { dg-error \"invalid conversion from 'char\\\\\\*'\" }\n+\n+const char ca2[2] = { __null, 0 };      // { dg-warning \"\\\\\\[-Wconversion-null\" }\n+\n+\n+typedef void Func ();\n+const char ca6[2] = { (Func*)0, 0 };    // { dg-error \"invalid conversion from 'void \\\\\\(\\\\\\*\\\\\\)\\\\\\(\\\\\\)' to 'char'\" }\n+\n+struct S;\n+typedef int S::*MemPtr;\n+typedef int (S::*MemFuncPtr)();\n+\n+const char ca4[2] = { (MemPtr)0, 0 };   // { dg-error \"cannot convert 'MemPtr' \" }\n+const char ca5[2] = { (MemFuncPtr)0, 0 };   // { dg-error \"cannot convert 'int \\\\\\(S::\\\\\\*\\\\\\)\\\\\\(\\\\\\)' \"  }"}, {"sha": "e8680de945680fb07132a5d6708ae238a65074b5", "filename": "gcc/testsuite/g++.dg/init/array59.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray59.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/587970215f4681def390e2a791aa3ba6adb65158/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray59.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray59.C?ref=587970215f4681def390e2a791aa3ba6adb65158", "patch": "@@ -0,0 +1,42 @@\n+/* PR c++/94510 - nullptr_t implicitly cast to zero twice in std::array\n+   { dg-do compile { target c++11 } } */\n+\n+namespace std {\n+typedef __typeof__ (nullptr) nullptr_t;\n+}\n+\n+int ia1[2] = { nullptr };                 // { dg-error \"cannot convert 'std::nullptr_t' to 'int'\" }\n+int ia2[2] = { nullptr, 0 };              // { dg-error \"cannot convert 'std::nullptr_t' to 'int'\" }\n+int ia3[] = { nullptr, 0 };               // { dg-error \"cannot convert 'std::nullptr_t' to 'int'\" }\n+\n+int ia4[2] = { (std::nullptr_t)0 };      // { dg-error \"cannot convert 'std::nullptr_t' to 'int'\" }\n+int ia5[2] = { (std::nullptr_t)0, 0 };   // { dg-error \"cannot convert 'std::nullptr_t' to 'int'\" }\n+int ia6[] = { (std::nullptr_t)0, 0 };    // { dg-error \"cannot convert 'std::nullptr_t' to 'int'\" }\n+\n+\n+const char ca1[2] = { nullptr, 0 };       // { dg-error \"cannot convert 'std::nullptr_t' to 'const char'\" }\n+\n+const char ca2[2] = { (char*)nullptr, 0 };// { dg-error \"invalid conversion from 'char\\\\\\*' to 'char'\" }\n+\n+const char ca3[2] = { std::nullptr_t () };// { dg-error \"cannot convert 'std::nullptr_t'\" }\n+\n+/* Verify that arrays of member pointers can be initialized by a literal\n+   zero as well as nullptr.  */\n+\n+struct S { };\n+typedef int S::*MemPtr;\n+typedef int (S::*MemFuncPtr)();\n+\n+MemPtr mp1[3] = { 0, nullptr, (MemPtr)0 };\n+MemPtr mp2[3] = { 0, std::nullptr_t (), MemPtr () };\n+\n+MemPtr mp3[3] = { 0, (void*)0 };          // { dg-error \"cannot convert 'void\\\\\\*' to 'MemPtr' \" }\n+MemPtr mp4[3] = { 0, (S*)0 };             // { dg-error \"cannot convert 'S\\\\\\*' to 'MemPtr' \" }\n+MemPtr mp5[3] = { 0, S () };              // { dg-error \"cannot convert 'S' to 'MemPtr' \" }\n+\n+MemFuncPtr mfp1[3] = { 0, nullptr, (MemFuncPtr)0 };\n+MemFuncPtr mfp2[3] = { 0, std::nullptr_t (), MemFuncPtr () };\n+\n+MemFuncPtr mfp3[3] = { 0, (void*)0 };     // { dg-error \"cannot convert 'void\\\\\\*' to 'MemFuncPtr' \" }\n+MemFuncPtr mfp4[3] = { 0, (S*)0 };        // { dg-error \"cannot convert 'S\\\\\\*' to 'MemFuncPtr' \" }\n+MemFuncPtr mfp5[3] = { 0, S () };         // { dg-error \"cannot convert 'S' to 'MemFuncPtr' \" }"}]}