{"sha": "f760c0c77fe350616da9dbeaea16442b0acfb09c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc2MGMwYzc3ZmUzNTA2MTZkYTlkYmVhZWExNjQ0MmIwYWNmYjA5Yw==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2020-01-03T12:56:46Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2020-01-03T12:56:46Z"}, "message": "Fortran] OpenMP/OpenACC \u2013 fix more issues with OPTIONAL\n\n        gcc/fortran/\n        * trans-openmp.c (gfc_omp_check_optional_argument): Always return a\n        Boolean expression; handle unallocated/disassociated actual arguments\n        as absent if passed to nonallocatable/nonpointer dummy array arguments.\n        (gfc_build_cond_assign): Change to assume a Boolean expr not a pointer.\n        (gfc_omp_finish_clause, gfc_trans_omp_clauses): Assign NULL to generated\n        array-data variable if the argument is absent. Simplify code as\n        'present' is now a Boolean expression.\n\n        libgomp/\n        * testsuite/libgomp.fortran/optional-map.f90: Add test for\n        unallocated/disassociated actual arguments to nonallocatable/nonpointer\n        dummy arguments; those are/shall be regarded as absent arguments.\n        * testsuite/libgomp.fortran/use_device_ptr-optional-2.f90: Ditto.\n        * testsuite/libgomp.fortran/use_device_ptr-optional-3.f90: New.\n\nFrom-SVN: r279858", "tree": {"sha": "6d9177cabdabfbd46270c97e91ab854a7ac61223", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d9177cabdabfbd46270c97e91ab854a7ac61223"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f760c0c77fe350616da9dbeaea16442b0acfb09c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f760c0c77fe350616da9dbeaea16442b0acfb09c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f760c0c77fe350616da9dbeaea16442b0acfb09c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f760c0c77fe350616da9dbeaea16442b0acfb09c/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1609beddb1bac416456743dff136b486f54a572c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1609beddb1bac416456743dff136b486f54a572c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1609beddb1bac416456743dff136b486f54a572c"}], "stats": {"total": 299, "additions": 260, "deletions": 39}, "files": [{"sha": "19397d6535376942cdcddd4176b112dccc21d1fb", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f760c0c77fe350616da9dbeaea16442b0acfb09c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f760c0c77fe350616da9dbeaea16442b0acfb09c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f760c0c77fe350616da9dbeaea16442b0acfb09c", "patch": "@@ -1,3 +1,13 @@\n+2020-01-03  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\t* trans-openmp.c (gfc_omp_check_optional_argument): Always return a\n+\tBoolean expression; handle unallocated/disassociated actual arguments\n+\tas absent if passed to nonallocatable/nonpointer dummy array arguments.\n+\t(gfc_build_cond_assign): Change to assume a Boolean expr not a pointer.\n+\t(gfc_omp_finish_clause, gfc_trans_omp_clauses): Assign NULL to generated\n+\tarray-data variable if the argument is absent. Simplify code as\n+\t'present' is now a Boolean expression.\n+\n 2020-01-03  Tobias Burnus  <tobias@codesourcery.com>\n \n \tPR fortran/92994"}, {"sha": "918af74bbf69dfbf33a9cd9e8fd4dfb2c7ce794b", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 78, "deletions": 39, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f760c0c77fe350616da9dbeaea16442b0acfb09c/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f760c0c77fe350616da9dbeaea16442b0acfb09c/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=f760c0c77fe350616da9dbeaea16442b0acfb09c", "patch": "@@ -90,11 +90,16 @@ gfc_omp_check_optional_argument (tree decl, bool for_present_check)\n   if (!DECL_LANG_SPECIFIC (decl))\n     return NULL_TREE;\n \n+  bool is_array_type = false;\n+\n   /* For assumed-shape arrays, a local decl with arg->data is used.  */\n   if (TREE_CODE (decl) != PARM_DECL\n       && (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl))\n \t  || GFC_ARRAY_TYPE_P (TREE_TYPE (decl))))\n-    decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n+    {\n+      is_array_type = true;\n+      decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n+    }\n \n   if (TREE_CODE (decl) != PARM_DECL\n       || !DECL_LANG_SPECIFIC (decl)\n@@ -126,7 +131,23 @@ gfc_omp_check_optional_argument (tree decl, bool for_present_check)\n       return decl;\n     }\n \n-  return decl;\n+  tree cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t       decl, null_pointer_node);\n+\n+  /* Fortran regards unallocated allocatables/disassociated pointer which\n+     are passed to a nonallocatable, nonpointer argument as not associated;\n+     cf. F2018, 15.5.2.12, Paragraph 1.  */\n+  if (is_array_type)\n+    {\n+      tree cond2 = build_fold_indirect_ref_loc (input_location, decl);\n+      cond2 = gfc_conv_array_data (cond2);\n+      cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t       cond2, null_pointer_node);\n+      cond = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n+\t\t\t      boolean_type_node, cond, cond2);\n+    }\n+\n+  return cond;\n }\n \n \n@@ -1192,7 +1213,7 @@ gfc_build_cond_assign (stmtblock_t *block, tree val, tree cond_val,\n \t\t       tree then_b, tree else_val)\n {\n   stmtblock_t cond_block;\n-  tree cond, else_b = NULL_TREE;\n+  tree else_b = NULL_TREE;\n   tree val_ty = TREE_TYPE (val);\n \n   if (else_val)\n@@ -1201,15 +1222,9 @@ gfc_build_cond_assign (stmtblock_t *block, tree val, tree cond_val,\n       gfc_add_modify (&cond_block, val, fold_convert (val_ty, else_val));\n       else_b = gfc_finish_block (&cond_block);\n     }\n-  cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t  logical_type_node,\n-\t\t\t  cond_val, null_pointer_node);\n   gfc_add_expr_to_block (block,\n-\t\t\t build3_loc (input_location,\n-\t\t\t\t     COND_EXPR,\n-\t\t\t\t     void_type_node,\n-\t\t\t\t     cond, then_b,\n-\t\t\t\t     else_b));\n+\t\t\t build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t     cond_val, then_b, else_b));\n }\n \n /* Build a conditional expression in BLOCK, returning a temporary\n@@ -1260,8 +1275,7 @@ gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n     }\n \n   tree c2 = NULL_TREE, c3 = NULL_TREE, c4 = NULL_TREE;\n-  tree present = (gfc_omp_is_optional_argument (decl)\n-\t\t  ? gfc_omp_check_optional_argument (decl, true) : NULL_TREE);\n+  tree present = gfc_omp_check_optional_argument (decl, true);\n   if (POINTER_TYPE_P (TREE_TYPE (decl)))\n     {\n       if (!gfc_omp_privatize_by_reference (decl)\n@@ -1271,6 +1285,23 @@ gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n \t  && !GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (decl))))\n \treturn;\n       tree orig_decl = decl;\n+\n+      /* For nonallocatable, nonpointer arrays, a temporary variable is\n+\t generated, but this one is only defined if the variable is present;\n+\t hence, we now set it to NULL to avoid accessing undefined variables.\n+\t We cannot use a temporary variable here as otherwise the replacement\n+\t of the variables in omp-low.c will not work.  */\n+      if (present && GFC_ARRAY_TYPE_P (TREE_TYPE (decl)))\n+\t{\n+\t  tree tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t      void_type_node, decl, null_pointer_node);\n+\t  tree cond = fold_build1_loc (input_location, TRUTH_NOT_EXPR,\n+\t\t\t\t       boolean_type_node, present);\n+\t  tmp = build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t    cond, tmp, NULL_TREE);\n+\t  gimplify_and_add (tmp, pre_p);\n+\t}\n+\n       c4 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n       OMP_CLAUSE_SET_MAP_KIND (c4, GOMP_MAP_POINTER);\n       OMP_CLAUSE_DECL (c4) = decl;\n@@ -1378,10 +1409,8 @@ gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n \t\t\t\t  boolean_type_node, tem, null_pointer_node);\n \t  if (present)\n \t    {\n-\t      tem = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n-\t\t\t\t     present, null_pointer_node);\n \t      cond = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n-\t\t\t\t      boolean_type_node, tem, cond);\n+\t\t\t\t      boolean_type_node, present, cond);\n \t    }\n \t  gfc_add_expr_to_block (&block, build3_loc (input_location, COND_EXPR,\n \t\t\t\t\t\t     void_type_node, cond,\n@@ -2468,9 +2497,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\tTREE_ADDRESSABLE (decl) = 1;\n \t      if (n->expr == NULL || n->expr->ref->u.ar.type == AR_FULL)\n \t\t{\n-\t\t  tree present = (gfc_omp_is_optional_argument (decl)\n-\t\t\t\t  ? gfc_omp_check_optional_argument (decl, true)\n-\t\t\t\t  : NULL_TREE);\n+\t\t  tree present = gfc_omp_check_optional_argument (decl, true);\n \t\t  if (n->sym->ts.type == BT_CLASS)\n \t\t    {\n \t\t      tree type = TREE_TYPE (decl);\n@@ -2509,6 +2536,30 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t       || n->sym->ts.type == BT_DERIVED))\n \t\t    {\n \t\t      tree orig_decl = decl;\n+\n+\t\t      /* For nonallocatable, nonpointer arrays, a temporary\n+\t\t\t variable is generated, but this one is only defined if\n+\t\t\t the variable is present; hence, we now set it to NULL\n+\t\t\t to avoid accessing undefined variables.  We cannot use\n+\t\t\t a temporary variable here as otherwise the replacement\n+\t\t\t of the variables in omp-low.c will not work.  */\n+\t\t      if (present && GFC_ARRAY_TYPE_P (TREE_TYPE (decl)))\n+\t\t\t{\n+\t\t\t  tree tmp = fold_build2_loc (input_location,\n+\t\t\t\t\t\t      MODIFY_EXPR,\n+\t\t\t\t\t\t      void_type_node, decl,\n+\t\t\t\t\t\t      null_pointer_node);\n+\t\t\t  tree cond = fold_build1_loc (input_location,\n+\t\t\t\t\t\t       TRUTH_NOT_EXPR,\n+\t\t\t\t\t\t       boolean_type_node,\n+\t\t\t\t\t\t       present);\n+\t\t\t  gfc_add_expr_to_block (block,\n+\t\t\t\t\t\t build3_loc (input_location,\n+\t\t\t\t\t\t\t     COND_EXPR,\n+\t\t\t\t\t\t\t     void_type_node,\n+\t\t\t\t\t\t\t     cond, tmp,\n+\t\t\t\t\t\t\t     NULL_TREE));\n+\t\t\t}\n \t\t      node4 = build_omp_clause (input_location,\n \t\t\t\t\t\tOMP_CLAUSE_MAP);\n \t\t      OMP_CLAUSE_SET_MAP_KIND (node4, GOMP_MAP_POINTER);\n@@ -2588,17 +2639,10 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t\t\t\t  boolean_type_node,\n \t\t\t\t\t\t  tem, null_pointer_node);\n \t\t\t  if (present)\n-\t\t\t    {\n-\t\t\t      tree tmp = fold_build2_loc (input_location,\n-\t\t\t\t\t\t\t  NE_EXPR,\n-\t\t\t\t\t\t\t  boolean_type_node,\n-\t\t\t\t\t\t\t  present,\n-\t\t\t\t\t\t\t  null_pointer_node);\n-\t\t\t      cond = fold_build2_loc (input_location,\n-\t\t\t\t\t\t      TRUTH_ANDIF_EXPR,\n-\t\t\t\t\t\t      boolean_type_node,\n-\t\t\t\t\t\t      tmp, cond);\n-\t\t\t    }\n+\t\t\t    cond = fold_build2_loc (input_location,\n+\t\t\t\t\t\t    TRUTH_ANDIF_EXPR,\n+\t\t\t\t\t\t    boolean_type_node,\n+\t\t\t\t\t\t    present, cond);\n \t\t\t  gfc_add_expr_to_block (block,\n \t\t\t\t\t\t build3_loc (input_location,\n \t\t\t\t\t\t\t     COND_EXPR,\n@@ -2617,16 +2661,11 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t    {\n \t\t\t      tree var = gfc_create_var (gfc_array_index_type,\n \t\t\t\t\t\t\t NULL);\n-\t\t\t      tree cond = fold_build2_loc (input_location,\n-\t\t\t\t\t\t\t   NE_EXPR,\n-\t\t\t\t\t\t\t   boolean_type_node,\n-\t\t\t\t\t\t\t   present,\n-\t\t\t\t\t\t\t   null_pointer_node);\n \t\t\t      gfc_add_modify (&cond_block, var, size);\n-\t\t\t      cond = build3_loc (input_location, COND_EXPR,\n-\t\t\t\t\t\t void_type_node, cond,\n-\t\t\t\t\t\t gfc_finish_block (&cond_block),\n-\t\t\t\t\t\t NULL_TREE);\n+\t\t\t      tree cond_body = gfc_finish_block (&cond_block);\n+\t\t\t      tree cond = build3_loc (input_location, COND_EXPR,\n+\t\t\t\t\t\t      void_type_node, present,\n+\t\t\t\t\t\t      cond_body, NULL_TREE);\n \t\t\t      gfc_add_expr_to_block (block, cond);\n \t\t\t      OMP_CLAUSE_SIZE (node) = var;\n \t\t\t    }"}, {"sha": "a204585d7b81f7136531641bd5ef3a9f0ae1bd1c", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f760c0c77fe350616da9dbeaea16442b0acfb09c/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f760c0c77fe350616da9dbeaea16442b0acfb09c/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=f760c0c77fe350616da9dbeaea16442b0acfb09c", "patch": "@@ -1,3 +1,11 @@\n+2020-01-03  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\t* testsuite/libgomp.fortran/optional-map.f90: Add test for\n+\tunallocated/disassociated actual arguments to nonallocatable/nonpointer\n+\tdummy arguments; those are/shall be regarded as absent arguments.\n+\t* testsuite/libgomp.fortran/use_device_ptr-optional-2.f90: Ditto.\n+\t* testsuite/libgomp.fortran/use_device_ptr-optional-3.f90: New.\n+\n 2020-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "b06efcc90d1042db6a0afe4559a95a89ca0428dd", "filename": "libgomp/testsuite/libgomp.fortran/optional-map.f90", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f760c0c77fe350616da9dbeaea16442b0acfb09c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Foptional-map.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f760c0c77fe350616da9dbeaea16442b0acfb09c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Foptional-map.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Foptional-map.f90?ref=f760c0c77fe350616da9dbeaea16442b0acfb09c", "patch": "@@ -1,11 +1,24 @@\n ! { dg-do run }\n !\n implicit none (type, external)\n+integer, allocatable :: a_ii, a_ival, a_iarr(:)\n+integer, pointer :: p_ii, p_ival, p_iarr(:)\n+\n+nullify (p_ii, p_ival, p_iarr)\n+\n call sub()\n call sub2()\n call call_present_1()\n call call_present_2()\n \n+! unallocated/disassociated actual arguments to nonallocatable, nonpointer\n+! dummy arguments are regarded as absent\n+! Skipping 'ival' dummy argument due to PR fortran/92887\n+call sub(ii=a_ii, iarr=a_iarr)\n+call sub(ii=p_ii, iarr=p_iarr)\n+call sub2(ii=a_ii, iarr=a_iarr)\n+call sub2(ii=p_ii, iarr=p_iarr)\n+\n contains\n \n subroutine call_present_1()"}, {"sha": "641ebd98962a6daf621750efd449ab79ecb0efe7", "filename": "libgomp/testsuite/libgomp.fortran/use_device_ptr-optional-2.f90", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f760c0c77fe350616da9dbeaea16442b0acfb09c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_ptr-optional-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f760c0c77fe350616da9dbeaea16442b0acfb09c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_ptr-optional-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_ptr-optional-2.f90?ref=f760c0c77fe350616da9dbeaea16442b0acfb09c", "patch": "@@ -3,8 +3,19 @@\n program main\n  use iso_c_binding, only: c_ptr, c_loc, c_associated\n  implicit none (type, external)\n+ integer, allocatable :: a_w, a_x(:)\n+ integer, pointer :: p_w, p_x(:)\n+\n+ nullify (p_w, p_x)\n  call foo()\n+\n+ ! unallocated/disassociated actual arguments to nonallocatable, nonpointer\n+ ! dummy arguments are regarded as absent\n+ call foo (w=a_w, x=a_x)\n+ call foo (w=p_w, x=p_x)\n+\n contains\n+\n   subroutine foo(v, w, x, y, z, cptr, cptr_in)\n     integer, target, optional, value :: v\n     integer, target, optional :: w"}, {"sha": "f2e1a60757f910c6a6d72afccef5aa9a4cf7a05d", "filename": "libgomp/testsuite/libgomp.fortran/use_device_ptr-optional-3.f90", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f760c0c77fe350616da9dbeaea16442b0acfb09c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_ptr-optional-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f760c0c77fe350616da9dbeaea16442b0acfb09c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_ptr-optional-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_ptr-optional-3.f90?ref=f760c0c77fe350616da9dbeaea16442b0acfb09c", "patch": "@@ -0,0 +1,140 @@\n+! Check whether absent optional arguments are properly\n+! handled with use_device_{addr,ptr}.\n+program main\n+  use iso_c_binding, only: c_ptr, c_loc, c_associated, c_f_pointer\n+  implicit none (type, external)\n+\n+  integer, target :: u\n+  integer, target :: v\n+  integer, target :: w\n+  integer, target :: x(4)\n+  integer, target, allocatable :: y\n+  integer, target, allocatable :: z(:)\n+  type(c_ptr), target :: cptr\n+  type(c_ptr), target :: cptr_in\n+  integer :: dummy\n+\n+  u = 42\n+  v = 5\n+  w = 7\n+  x = [3,4,6,2]\n+  y = 88\n+  z = [1,2,3]\n+\n+  !$omp target enter data map(to:u)\n+  !$omp target data map(to:dummy) use_device_addr(u)\n+   cptr_in = c_loc(u) ! Has to be outside 'foo' due to 'intent(in)'\n+  !$omp end target data\n+\n+  call foo (u, v, w, x, y, z, cptr, cptr_in)\n+  deallocate (y, z)\n+contains\n+  subroutine foo (u, v, w, x, y, z, cptr, cptr_in)\n+    integer, target, optional, value :: v\n+    integer, target, optional :: u, w\n+    integer, target, optional :: x(:)\n+    integer, target, optional, allocatable :: y\n+    integer, target, optional, allocatable :: z(:)\n+    type(c_ptr), target, optional, value :: cptr\n+    type(c_ptr), target, optional, value, intent(in) :: cptr_in\n+    integer :: d\n+\n+    type(c_ptr) :: p_u, p_v, p_w, p_x, p_y, p_z, p_cptr, p_cptr_in\n+\n+    !$omp target enter data map(to:w, x, y, z)\n+    !$omp target data map(dummy) use_device_addr(x)\n+      cptr = c_loc(x)\n+    !$omp end target data\n+\n+    ! Need to map per-VALUE arguments, if present\n+    if (present(v)) then\n+      !$omp target enter data map(to:v)\n+    else\n+      stop 1\n+    end if\n+    if (present(cptr)) then\n+      !$omp target enter data map(to:cptr)\n+    else\n+      stop 2\n+    end if\n+    if (present(cptr_in)) then\n+      !$omp target enter data map(to:cptr_in)\n+    else\n+      stop 3\n+    end if\n+\n+    !$omp target data map(d) use_device_addr(u, v, w, x, y, z)\n+    !$omp target data map(d) use_device_addr(cptr, cptr_in)\n+      if (.not. present(u)) stop 10\n+      if (.not. present(v)) stop 11\n+      if (.not. present(w)) stop 12\n+      if (.not. present(x)) stop 13\n+      if (.not. present(y)) stop 14\n+      if (.not. present(z)) stop 15\n+      if (.not. present(cptr)) stop 16\n+      if (.not. present(cptr_in)) stop 17\n+      p_u = c_loc(u)\n+      p_v = c_loc(v)\n+      p_w = c_loc(w)\n+      p_x = c_loc(x)\n+      p_y = c_loc(y)\n+      p_z = c_loc(z)\n+      p_cptr = c_loc(cptr)\n+      p_cptr_in = c_loc(cptr_in)\n+    !$omp end target data\n+    !$omp end target data\n+    call check(p_u, p_v, p_w, p_x, p_y, p_z, p_cptr, p_cptr_in, size(x), size(z))\n+  end subroutine foo\n+\n+  subroutine check(p_u, p_v, p_w, p_x, p_y, p_z, p_cptr, p_cptr_in, Nx, Nz)\n+    type(c_ptr), value :: p_u, p_v, p_w, p_x, p_y, p_z, p_cptr, p_cptr_in\n+    integer, value :: Nx, Nz\n+    integer, pointer :: c_u(:), c_v(:), c_w(:), c_x(:), c_y(:), c_z(:)\n+    type(c_ptr), pointer :: c_cptr(:), c_cptr_in(:)\n+\n+    ! As is_device_ptr does not handle scalars, we map them to a size-1 array\n+    call c_f_pointer(p_u, c_u, shape=[1])\n+    call c_f_pointer(p_v, c_v, shape=[1])\n+    call c_f_pointer(p_w, c_w, shape=[1])\n+    call c_f_pointer(p_x, c_x, shape=[Nx])\n+    call c_f_pointer(p_y, c_y, shape=[1])\n+    call c_f_pointer(p_z, c_z, shape=[Nz])\n+    call c_f_pointer(p_cptr, c_cptr, shape=[1])\n+    call c_f_pointer(p_cptr_in, c_cptr_in, shape=[1])\n+    call run_target(c_u, c_v, c_w, c_x, c_y, c_z, c_cptr, c_cptr_in, Nx, Nz)\n+  end subroutine check\n+\n+  subroutine run_target(c_u, c_v, c_w, c_x, c_y, c_z, c_cptr, c_cptr_in, Nx, Nz)\n+    integer, target :: c_u(:), c_v(:), c_w(:), c_x(:), c_y(:), c_z(:)\n+    type(c_ptr) :: c_cptr(:), c_cptr_in(:)\n+    integer, value :: Nx, Nz\n+    !$omp target is_device_ptr(c_u, c_v, c_w, c_x, c_y, c_z, c_cptr, c_cptr_in) map(to:Nx, Nz)\n+      call target_fn(c_u(1), c_v(1), c_w(1), c_x, c_y(1), c_z, c_cptr(1), c_cptr_in(1), Nx, Nz)\n+    !$omp end target\n+  end subroutine run_target\n+\n+  subroutine target_fn(c_u, c_v, c_w, c_x, c_y, c_z, c_cptr, c_cptr_in, Nx, Nz)\n+    !$omp declare target\n+    integer, target :: c_u, c_v, c_w, c_x(:), c_y, c_z(:)\n+    type(c_ptr), value :: c_cptr, c_cptr_in\n+    integer, value :: Nx, Nz\n+    integer, pointer :: u, x(:)\n+    if (c_u /= 42) stop 30\n+    if (c_v /= 5) stop 31\n+    if (c_w /= 7) stop 32\n+    if (Nx /= 4) stop 33\n+    if (any (c_x /= [3,4,6,2])) stop 34\n+    if (c_y /= 88) stop 35\n+    if (Nz /= 3) stop 36\n+    if (any (c_z /= [1,2,3])) stop 37\n+    if (.not. c_associated (c_cptr)) stop 38\n+    if (.not. c_associated (c_cptr_in)) stop 39\n+    if (.not. c_associated (c_cptr, c_loc(c_x))) stop 40\n+    if (.not. c_associated (c_cptr_in, c_loc(c_u))) stop 41\n+    call c_f_pointer(c_cptr_in, u)\n+    call c_f_pointer(c_cptr, x, shape=[Nx])\n+    if (u /= c_u .or. u /= 42)  stop 42\n+    if (any (x /= c_x))  stop 43\n+    if (any (x /= [3,4,6,2]))  stop 44\n+  end subroutine target_fn\n+end program main"}]}