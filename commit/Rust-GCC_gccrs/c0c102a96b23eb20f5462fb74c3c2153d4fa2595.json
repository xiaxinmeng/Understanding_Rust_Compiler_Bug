{"sha": "c0c102a96b23eb20f5462fb74c3c2153d4fa2595", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBjMTAyYTk2YjIzZWIyMGY1NDYyZmI3NGMzYzIxNTNkNGZhMjU5NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-01-10T15:39:55Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-01-10T15:39:55Z"}, "message": "i386.c (ix86_fp_compare_code_to_integer, [...]): new functions.\n\n\n\t* i386.c (ix86_fp_compare_code_to_integer, ix86_fp_comparison_codes):\n\tnew functions.\n\t(ix86_expand_fp_compare): Make trivial use of new infrastructure.\n\nFrom-SVN: r38868", "tree": {"sha": "5d1e61dfc6c37209104199d358efdaeccbca302f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d1e61dfc6c37209104199d358efdaeccbca302f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0c102a96b23eb20f5462fb74c3c2153d4fa2595", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0c102a96b23eb20f5462fb74c3c2153d4fa2595", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0c102a96b23eb20f5462fb74c3c2153d4fa2595", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0c102a96b23eb20f5462fb74c3c2153d4fa2595/comments", "author": null, "committer": null, "parents": [{"sha": "fd3f43e7a5cf39dcb1baff29957f9690a570c41e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd3f43e7a5cf39dcb1baff29957f9690a570c41e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd3f43e7a5cf39dcb1baff29957f9690a570c41e"}], "stats": {"total": 256, "additions": 185, "deletions": 71}, "files": [{"sha": "f324a4562f2852627fb28df472f47036c2c6ebba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0c102a96b23eb20f5462fb74c3c2153d4fa2595/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0c102a96b23eb20f5462fb74c3c2153d4fa2595/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0c102a96b23eb20f5462fb74c3c2153d4fa2595", "patch": "@@ -1,3 +1,9 @@\n+Wed Jan 10 16:38:31 MET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (ix86_fp_compare_code_to_integer, ix86_fp_comparison_codes):\n+\tnew functions.\n+\t(ix86_expand_fp_compare): Make trivial use of new infrastructure.\n+\n 2001-01-10  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.c (arm_init_builtins): Temporarily disable xscale builtins."}, {"sha": "49a88820b9b366920966065927dec6704ff35dec", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 179, "deletions": 71, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0c102a96b23eb20f5462fb74c3c2153d4fa2595/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0c102a96b23eb20f5462fb74c3c2153d4fa2595/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c0c102a96b23eb20f5462fb74c3c2153d4fa2595", "patch": "@@ -194,7 +194,7 @@ const int x86_use_q_reg = m_PENT | m_PPRO | m_K6;\n const int x86_use_any_reg = m_486;\n const int x86_cmove = m_PPRO | m_ATHLON;\n const int x86_deep_branch = m_PPRO | m_K6 | m_ATHLON;\n-const int x86_use_sahf = m_PPRO | m_K6 | m_ATHLON;\n+const int x86_use_sahf = m_PPRO | m_K6;\n const int x86_partial_reg_stall = m_PPRO;\n const int x86_use_loop = m_K6;\n const int x86_use_fiop = ~(m_PPRO | m_ATHLON | m_PENT);\n@@ -434,6 +434,11 @@ static rtx ix86_expand_unop_builtin PARAMS ((enum insn_code, tree, rtx, int));\n static rtx ix86_expand_binop_builtin PARAMS ((enum insn_code, tree, rtx));\n static rtx ix86_expand_store_builtin PARAMS ((enum insn_code, tree, int));\n static rtx safe_vector_operand PARAMS ((rtx, enum machine_mode));\n+static enum rtx_code ix86_fp_compare_code_to_integer PARAMS ((enum rtx_code));\n+static void ix86_fp_comparison_codes PARAMS ((enum rtx_code code,\n+\t\t\t\t\t      enum rtx_code *,\n+\t\t\t\t\t      enum rtx_code *,\n+\t\t\t\t\t      enum rtx_code *));\n \f\n /* Sometimes certain combinations of command options do not make\n    sense on a particular target machine.  You can define a macro\n@@ -4814,6 +4819,107 @@ ix86_prepare_fp_compare_args (code, pop0, pop1)\n   return code;\n }\n \n+/* Convert comparison codes we use to represent FP comparison to integer\n+   code that will result in proper branch.  Return UNKNOWN if no such code\n+   is available.  */\n+static enum rtx_code\n+ix86_fp_compare_code_to_integer (code)\n+     enum rtx_code code;\n+{\n+  switch (code)\n+    {\n+    case GT:\n+      return GTU;\n+    case GE:\n+      return GEU;\n+    case ORDERED:\n+    case UNORDERED:\n+      return code;\n+      break;\n+    case UNEQ:\n+      return EQ;\n+      break;\n+    case UNLT:\n+      return LTU;\n+      break;\n+    case UNLE:\n+      return LEU;\n+      break;\n+    case LTGT:\n+      return NE;\n+      break;\n+    default:\n+      return UNKNOWN;\n+    }\n+}\n+\n+/* Split comparison code CODE into comparisons we can do using branch\n+   instructions.  BYPASS_CODE is comparison code for branch that will\n+   branch around FIRST_CODE and SECOND_CODE.  If some of branches\n+   is not required, set value to NIL.\n+   We never require more than two branches.  */\n+static void\n+ix86_fp_comparison_codes (code, bypass_code, first_code, second_code)\n+     enum rtx_code code, *bypass_code, *first_code, *second_code;\n+{\n+  *first_code = code;\n+  *bypass_code = NIL;\n+  *second_code = NIL;\n+\n+  /* The fcomi comparison sets flags as follows:\n+\n+     cmp    ZF PF CF\n+     >      0  0  0\n+     <      0  0  1\n+     =      1  0  0\n+     un     1  1  1 */\n+\n+  switch (code)\n+    {\n+    case GT:\t\t\t/* GTU - CF=0 & ZF=0 */\n+    case GE:\t\t\t/* GEU - CF=0 */\n+    case ORDERED:\t\t/* PF=0 */\n+    case UNORDERED:\t\t/* PF=1 */\n+    case UNEQ:\t\t\t/* EQ - ZF=1 */\n+    case UNLT:\t\t\t/* LTU - CF=1 */\n+    case UNLE:\t\t\t/* LEU - CF=1 | ZF=1 */\n+    case LTGT:\t\t\t/* EQ - ZF=0 */\n+      break;\n+    case LT:\t\t\t/* LTU - CF=1 - fails on unordered */\n+      *first_code = UNLT;\n+      *bypass_code = UNORDERED;\n+      break;\n+    case LE:\t\t\t/* LEU - CF=1 | ZF=1 - fails on unordered */\n+      *first_code = UNLE;\n+      *bypass_code = UNORDERED;\n+      break;\n+    case EQ:\t\t\t/* EQ - ZF=1 - fails on unordered */\n+      *first_code = UNEQ;\n+      *bypass_code = UNORDERED;\n+      break;\n+    case NE:\t\t\t/* NE - ZF=0 - fails on unordered */\n+      *first_code = LTGT;\n+      *second_code = UNORDERED;\n+      break;\n+    case UNGE:\t\t\t/* GEU - CF=0 - fails on unordered */\n+      *first_code = GE;\n+      *second_code = UNORDERED;\n+      break;\n+    case UNGT:\t\t\t/* GTU - CF=0 & ZF=0 - fails on unordered */\n+      *first_code = GT;\n+      *second_code = UNORDERED;\n+      break;\n+    default:\n+      abort ();\n+    }\n+  if (!TARGET_IEEE_FP)\n+    {\n+      *second_code = NIL;\n+      *bypass_code = NIL;\n+    }\n+}\n+\n+\n /* Generate insn patterns to do a floating point compare of OPERANDS.  */\n \n rtx\n@@ -4822,28 +4928,42 @@ ix86_expand_fp_compare (code, op0, op1, scratch)\n      rtx op0, op1, scratch;\n {\n   enum machine_mode fpcmp_mode, intcmp_mode;\n-  rtx tmp;\n+  rtx tmp, tmp2;\n+  enum rtx_code bypass_code, first_code, second_code;\n \n   fpcmp_mode = ix86_fp_compare_mode (code);\n   code = ix86_prepare_fp_compare_args (code, &op0, &op1);\n \n+  ix86_fp_comparison_codes (code, &bypass_code, &first_code, &second_code);\n+\n   /* %%% fcomi is probably always faster, even when dealing with memory,\n      since compare-and-branch would be three insns instead of four.  */\n-  if (ix86_use_fcomi_compare (code))\n+  if (bypass_code == NIL && second_code == NIL \n+      && (TARGET_CMOVE || TARGET_USE_SAHF || optimize_size))\n     {\n-      tmp = gen_rtx_COMPARE (fpcmp_mode, op0, op1);\n-      tmp = gen_rtx_SET (VOIDmode, gen_rtx_REG (fpcmp_mode, FLAGS_REG), tmp);\n-      emit_insn (tmp);\n+      do_sahf:\n+      if (TARGET_CMOVE)\n+\t{\n+\t  tmp = gen_rtx_COMPARE (fpcmp_mode, op0, op1);\n+\t  tmp = gen_rtx_SET (VOIDmode, gen_rtx_REG (fpcmp_mode, FLAGS_REG),\n+\t\t\t     tmp);\n+\t  emit_insn (tmp);\n+\t}\n+      else\n+\t{\n+\t  tmp = gen_rtx_COMPARE (fpcmp_mode, op0, op1);\n+\t  tmp2 = gen_rtx_UNSPEC (HImode, gen_rtvec (1, tmp), 9);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, scratch, tmp2));\n+\t  emit_insn (gen_x86_sahf_1 (scratch));\n+\t}\n \n       /* The FP codes work out to act like unsigned.  */\n-      code = unsigned_comparison (code);\n+      code = ix86_fp_compare_code_to_integer (first_code);\n       intcmp_mode = CCmode;\n     }\n   else\n     {\n       /* Sadness wrt reg-stack pops killing fpsr -- gotta get fnstsw first.  */\n-\n-      rtx tmp2;\n       tmp = gen_rtx_COMPARE (fpcmp_mode, op0, op1);\n       tmp2 = gen_rtx_UNSPEC (HImode, gen_rtvec (1, tmp), 9);\n       emit_insn (gen_rtx_SET (VOIDmode, scratch, tmp2));\n@@ -4857,72 +4977,60 @@ ix86_expand_fp_compare (code, op0, op1, scratch)\n \t     smaller.  On Pentium, sahf is non-pairable while test is UV\n \t     pairable.  */\n \n-\t  if (TARGET_USE_SAHF || optimize_size)\n-\t    {\n-\t    do_sahf:\n-\t      emit_insn (gen_x86_sahf_1 (scratch));\n-\n-\t      /* The FP codes work out to act like unsigned.  */\n-\t      code = unsigned_comparison (code);\n-\t      intcmp_mode = CCmode;\n-\t    }\n-\t  else\n-\t    {\n-\t      /*\n-\t       * The numbers below correspond to the bits of the FPSW in AH.\n-\t       * C3, C2, and C0 are in bits 0x40, 0x4, and 0x01 respectively.\n-\t       *\n-\t       *    cmp    C3 C2 C0\n-\t       *    >      0  0  0\n-\t       *    <      0  0  1\n-\t       *    =      1  0  0\n-\t       *    un     1  1  1\n-\t       */\n+\t  /*\n+\t   * The numbers below correspond to the bits of the FPSW in AH.\n+\t   * C3, C2, and C0 are in bits 0x40, 0x4, and 0x01 respectively.\n+\t   *\n+\t   *    cmp    C3 C2 C0\n+\t   *    >      0  0  0\n+\t   *    <      0  0  1\n+\t   *    =      1  0  0\n+\t   *    un     1  1  1\n+\t   */\n \n-\t      int mask;\n+\t  int mask;\n \n-\t      switch (code)\n-\t\t{\n-\t\tcase GT:\n-\t\t  mask = 0x41;\n-\t\t  code = EQ;\n-\t\t  break;\n-\t\tcase LT:\n-\t\t  mask = 0x01;\n-\t\t  code = NE;\n-\t\t  break;\n-\t\tcase GE:\n-\t\t  /* We'd have to use `xorb 1,ah; andb 0x41,ah', so it's\n-\t\t     faster in all cases to just fall back on sahf.  */\n-\t\t  goto do_sahf;\n-\t\tcase LE:\n-\t\t  mask = 0x41;\n-\t\t  code = NE;\n-\t\t  break;\n-\t\tcase EQ:\n-\t\t  mask = 0x40;\n-\t\t  code = NE;\n-\t\t  break;\n-\t\tcase NE:\n-\t\t  mask = 0x40;\n-\t\t  code = EQ;\n-\t\t  break;\n-\t\tcase UNORDERED:\n-\t\t  mask = 0x04;\n-\t\t  code = NE;\n-\t\t  break;\n-\t\tcase ORDERED:\n-\t\t  mask = 0x04;\n-\t\t  code = EQ;\n-\t\t  break;\n-\n-\t\tdefault:\n-\t\t  abort ();\n-\t\t}\n+\t  switch (code)\n+\t    {\n+\t    case GT:\n+\t      mask = 0x41;\n+\t      code = EQ;\n+\t      break;\n+\t    case LT:\n+\t      mask = 0x01;\n+\t      code = NE;\n+\t      break;\n+\t    case GE:\n+\t      /* We'd have to use `xorb 1,ah; andb 0x41,ah', so it's\n+\t\t faster in all cases to just fall back on sahf.  */\n+\t      goto do_sahf;\n+\t    case LE:\n+\t      mask = 0x41;\n+\t      code = NE;\n+\t      break;\n+\t    case EQ:\n+\t      mask = 0x40;\n+\t      code = NE;\n+\t      break;\n+\t    case NE:\n+\t      mask = 0x40;\n+\t      code = EQ;\n+\t      break;\n+\t    case UNORDERED:\n+\t      mask = 0x04;\n+\t      code = NE;\n+\t      break;\n+\t    case ORDERED:\n+\t      mask = 0x04;\n+\t      code = EQ;\n+\t      break;\n \n-\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (mask)));\n-\t      intcmp_mode = CCNOmode;\n+\t    default:\n+\t      abort ();\n \t    }\n+\n+\t  emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (mask)));\n+\t  intcmp_mode = CCNOmode;\n \t}\n       else\n \t{"}]}