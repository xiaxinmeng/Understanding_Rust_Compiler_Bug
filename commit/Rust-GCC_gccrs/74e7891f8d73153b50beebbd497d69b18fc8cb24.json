{"sha": "74e7891f8d73153b50beebbd497d69b18fc8cb24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRlNzg5MWY4ZDczMTUzYjUwYmVlYmJkNDk3ZDY5YjE4ZmM4Y2IyNA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2010-06-22T07:26:02Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-22T07:26:02Z"}, "message": "g-expect-vms.adb, [...]: Minor reformatting.\n\n2010-06-22  Robert Dewar  <dewar@adacore.com>\n\n\t* g-expect-vms.adb, sem_res.adb: Minor reformatting.\n\t* exp_aggr.adb: Minor comment changes and reformatting.\n\t* sem_eval.adb (Find_Universal_Operator_Type): Put in proper alpha order\n\t* sem_util.ads: Add some missing pragma Inline's (efficiency issue only)\n\nFrom-SVN: r161139", "tree": {"sha": "622fd4753d7fcd2fe9b6e230fa034027b2f43b97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/622fd4753d7fcd2fe9b6e230fa034027b2f43b97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74e7891f8d73153b50beebbd497d69b18fc8cb24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74e7891f8d73153b50beebbd497d69b18fc8cb24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74e7891f8d73153b50beebbd497d69b18fc8cb24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74e7891f8d73153b50beebbd497d69b18fc8cb24/comments", "author": null, "committer": null, "parents": [{"sha": "cf49bd32328f107c91df2fb7d92e1292b35f00ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf49bd32328f107c91df2fb7d92e1292b35f00ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf49bd32328f107c91df2fb7d92e1292b35f00ee"}], "stats": {"total": 295, "additions": 154, "deletions": 141}, "files": [{"sha": "bc310e38c51fb0238e6841f4c9167651ef23ba7b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74e7891f8d73153b50beebbd497d69b18fc8cb24/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74e7891f8d73153b50beebbd497d69b18fc8cb24/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=74e7891f8d73153b50beebbd497d69b18fc8cb24", "patch": "@@ -1,3 +1,10 @@\n+2010-06-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* g-expect-vms.adb, sem_res.adb: Minor reformatting.\n+\t* exp_aggr.adb: Minor comment changes and reformatting.\n+\t* sem_eval.adb (Find_Universal_Operator_Type): Put in proper alpha order\n+\t* sem_util.ads: Add some missing pragma Inline's (efficiency issue only)\n+\n 2010-06-22  Thomas Quinot  <quinot@adacore.com>\n \n \t* sem_util.adb (Build_Actual_Subtype): Record original expression in"}, {"sha": "9345da2f56bff252561436300f50fa0d83791342", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74e7891f8d73153b50beebbd497d69b18fc8cb24/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74e7891f8d73153b50beebbd497d69b18fc8cb24/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=74e7891f8d73153b50beebbd497d69b18fc8cb24", "patch": "@@ -176,8 +176,9 @@ package body Exp_Aggr is\n    --  Very large static aggregates present problems to the back-end, and are\n    --  transformed into assignments and loops. This function verifies that the\n    --  total number of components of an aggregate is acceptable for rewriting\n-   --  into a purely positional static form. It is called prior to calling\n-   --  Flatten.\n+   --  into a purely positional static form. Aggr_Size_OK must be called before\n+   --  calling Flatten.\n+   --\n    --  This function also detects and warns about one-component aggregates that\n    --  appear in a non-static context. Even if the component value is static,\n    --  such an aggregate must be expanded into an assignment."}, {"sha": "4d1a770822aec85bccf3a8283f342040b87dd8fa", "filename": "gcc/ada/g-expect-vms.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74e7891f8d73153b50beebbd497d69b18fc8cb24/gcc%2Fada%2Fg-expect-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74e7891f8d73153b50beebbd497d69b18fc8cb24/gcc%2Fada%2Fg-expect-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-expect-vms.adb?ref=74e7891f8d73153b50beebbd497d69b18fc8cb24", "patch": "@@ -524,6 +524,7 @@ package body GNAT.Expect is\n \n       for J in Descriptors'Range loop\n          Descriptors (J) := Regexps (J).Descriptor;\n+\n          if Descriptors (J) /= null then\n             Reinitialize_Buffer (Regexps (J).Descriptor.all);\n          end if;\n@@ -775,7 +776,8 @@ package body GNAT.Expect is\n    ------------------------\n \n    function First_Dead_Process\n-     (Regexp : Multiprocess_Regexp_Array) return Natural is\n+     (Regexp : Multiprocess_Regexp_Array) return Natural\n+   is\n    begin\n       for R in Regexp'Range loop\n          if Regexp (R).Descriptor /= null"}, {"sha": "11fba8e7a3a539844bdf4387c98f8ce07b133240", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 135, "deletions": 135, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74e7891f8d73153b50beebbd497d69b18fc8cb24/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74e7891f8d73153b50beebbd497d69b18fc8cb24/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=74e7891f8d73153b50beebbd497d69b18fc8cb24", "patch": "@@ -3763,6 +3763,141 @@ package body Sem_Eval is\n       end if;\n    end Expr_Value_S;\n \n+   ----------------------------------\n+   -- Find_Universal_Operator_Type --\n+   ----------------------------------\n+\n+   function Find_Universal_Operator_Type (N : Node_Id) return Entity_Id is\n+      PN     : constant Node_Id := Parent (N);\n+      Call   : constant Node_Id := Original_Node (N);\n+      Is_Int : constant Boolean := Is_Integer_Type (Etype (N));\n+\n+      Is_Fix : constant Boolean :=\n+                 Nkind (N) in N_Binary_Op\n+                   and then Nkind (Right_Opnd (N)) /= Nkind (Left_Opnd (N));\n+      --  A mixed-mode operation in this context indicates the presence of\n+      --  fixed-point type in the designated package.\n+\n+      Is_Relational : constant Boolean := Etype (N) = Standard_Boolean;\n+      --  Case where N is a relational (or membership) operator (else it is an\n+      --  arithmetic one).\n+\n+      In_Membership : constant Boolean :=\n+                        Nkind (PN) in N_Membership_Test\n+                          and then\n+                        Nkind (Right_Opnd (PN)) = N_Range\n+                          and then\n+                        Is_Universal_Numeric_Type (Etype (Left_Opnd (PN)))\n+                          and then\n+                        Is_Universal_Numeric_Type\n+                          (Etype (Low_Bound (Right_Opnd (PN))))\n+                          and then\n+                        Is_Universal_Numeric_Type\n+                          (Etype (High_Bound (Right_Opnd (PN))));\n+      --  Case where N is part of a membership test with a universal range\n+\n+      E      : Entity_Id;\n+      Pack   : Entity_Id;\n+      Typ1   : Entity_Id := Empty;\n+      Priv_E : Entity_Id;\n+\n+      function Is_Mixed_Mode_Operand (Op : Node_Id) return Boolean;\n+      --  Check whether one operand is a mixed-mode operation that requires\n+      --  the presence of a fixed-point type. Given that all operands are\n+      --  universal and have been constant-folded, retrieve the original\n+      --  function call.\n+\n+      ---------------------------\n+      -- Is_Mixed_Mode_Operand --\n+      ---------------------------\n+\n+      function Is_Mixed_Mode_Operand (Op : Node_Id) return Boolean is\n+      begin\n+         return Nkind (Original_Node (Op)) = N_Function_Call\n+           and then Present (Next_Actual (First_Actual (Original_Node (Op))))\n+           and then Etype (First_Actual (Original_Node (Op))) /=\n+                    Etype (Next_Actual (First_Actual (Original_Node (Op))));\n+      end Is_Mixed_Mode_Operand;\n+\n+   begin\n+      if Nkind (Call) /= N_Function_Call\n+        or else Nkind (Name (Call)) /= N_Expanded_Name\n+      then\n+         return Empty;\n+\n+      --  There are two cases where the context does not imply the type of the\n+      --  operands: either the universal expression appears in a type\n+      --  type conversion, or we are in the case of a predefined relational\n+      --  operator, where the context type is always Boolean.\n+\n+      elsif Nkind (Parent (N)) = N_Type_Conversion\n+              or else\n+            Is_Relational\n+              or else\n+            In_Membership\n+      then\n+         Pack := Entity (Prefix (Name (Call)));\n+\n+         --  If the prefix is a package declared elsewhere, iterate over\n+         --  its visible entities, otherwise iterate over all declarations\n+         --  in the designated scope.\n+\n+         if Ekind (Pack) = E_Package\n+           and then not In_Open_Scopes (Pack)\n+         then\n+            Priv_E := First_Private_Entity (Pack);\n+         else\n+            Priv_E := Empty;\n+         end if;\n+\n+         Typ1 := Empty;\n+         E := First_Entity (Pack);\n+         while Present (E) and then E /= Priv_E loop\n+            if Is_Numeric_Type (E)\n+              and then Nkind (Parent (E)) /= N_Subtype_Declaration\n+              and then Comes_From_Source (E)\n+              and then Is_Integer_Type (E) = Is_Int\n+              and then\n+                (Nkind (N) in N_Unary_Op\n+                  or else Is_Relational\n+                  or else Is_Fixed_Point_Type (E) = Is_Fix)\n+            then\n+               if No (Typ1) then\n+                  Typ1 := E;\n+\n+                  --  Before emitting an error, check for the presence of a\n+                  --  mixed-mode operation that specifies a fixed point type.\n+\n+               elsif Is_Relational\n+                 and then\n+                   (Is_Mixed_Mode_Operand (Left_Opnd (N))\n+                    or else Is_Mixed_Mode_Operand (Right_Opnd (N)))\n+                 and then Is_Fixed_Point_Type (E) /= Is_Fixed_Point_Type (Typ1)\n+\n+               then\n+                  if Is_Fixed_Point_Type (E) then\n+                     Typ1 := E;\n+                  end if;\n+\n+               else\n+                  --  More than one type of the proper class declared in P\n+\n+                  Error_Msg_N (\"ambiguous operation\", N);\n+                  Error_Msg_Sloc := Sloc (Typ1);\n+                  Error_Msg_N (\"\\possible interpretation (inherited)#\", N);\n+                  Error_Msg_Sloc := Sloc (E);\n+                  Error_Msg_N (\"\\possible interpretation (inherited)#\", N);\n+                  return Empty;\n+               end if;\n+            end if;\n+\n+            Next_Entity (E);\n+         end loop;\n+      end if;\n+\n+      return Typ1;\n+   end Find_Universal_Operator_Type;\n+\n    --------------------------\n    -- Flag_Non_Static_Expr --\n    --------------------------\n@@ -4761,141 +4896,6 @@ package body Sem_Eval is\n       end if;\n    end Test;\n \n-   ----------------------------------\n-   -- Find_Universal_Operator_Type --\n-   ----------------------------------\n-\n-   function Find_Universal_Operator_Type (N : Node_Id) return Entity_Id is\n-      PN     : constant Node_Id := Parent (N);\n-      Call   : constant Node_Id := Original_Node (N);\n-      Is_Int : constant Boolean := Is_Integer_Type (Etype (N));\n-\n-      Is_Fix : constant Boolean :=\n-                 Nkind (N) in N_Binary_Op\n-                   and then Nkind (Right_Opnd (N)) /= Nkind (Left_Opnd (N));\n-      --  A mixed-mode operation in this context indicates the presence of\n-      --  fixed-point type in the designated package.\n-\n-      Is_Relational : constant Boolean := Etype (N) = Standard_Boolean;\n-      --  Case where N is a relational (or membership) operator (else it is an\n-      --  arithmetic one).\n-\n-      In_Membership : constant Boolean :=\n-                        Nkind (PN) in N_Membership_Test\n-                          and then\n-                        Nkind (Right_Opnd (PN)) = N_Range\n-                          and then\n-                        Is_Universal_Numeric_Type (Etype (Left_Opnd (PN)))\n-                          and then\n-                        Is_Universal_Numeric_Type\n-                          (Etype (Low_Bound (Right_Opnd (PN))))\n-                          and then\n-                        Is_Universal_Numeric_Type\n-                          (Etype (High_Bound (Right_Opnd (PN))));\n-      --  Case where N is part of a membership test with a universal range\n-\n-      E      : Entity_Id;\n-      Pack   : Entity_Id;\n-      Typ1   : Entity_Id := Empty;\n-      Priv_E : Entity_Id;\n-\n-      function Is_Mixed_Mode_Operand (Op : Node_Id) return Boolean;\n-      --  Check whether one operand is a mixed-mode operation that requires\n-      --  the presence of a fixed-point type. Given that all operands are\n-      --  universal and have been constant-folded, retrieve the original\n-      --  function call.\n-\n-      ---------------------------\n-      -- Is_Mixed_Mode_Operand --\n-      ---------------------------\n-\n-      function Is_Mixed_Mode_Operand (Op : Node_Id) return Boolean is\n-      begin\n-         return Nkind (Original_Node (Op)) = N_Function_Call\n-           and then Present (Next_Actual (First_Actual (Original_Node (Op))))\n-           and then Etype (First_Actual (Original_Node (Op))) /=\n-                    Etype (Next_Actual (First_Actual (Original_Node (Op))));\n-      end Is_Mixed_Mode_Operand;\n-\n-   begin\n-      if Nkind (Call) /= N_Function_Call\n-        or else Nkind (Name (Call)) /= N_Expanded_Name\n-      then\n-         return Empty;\n-\n-      --  There are two cases where the context does not imply the type of the\n-      --  operands: either the universal expression appears in a type\n-      --  type conversion, or we are in the case of a predefined relational\n-      --  operator, where the context type is always Boolean.\n-\n-      elsif Nkind (Parent (N)) = N_Type_Conversion\n-              or else\n-            Is_Relational\n-              or else\n-            In_Membership\n-      then\n-         Pack := Entity (Prefix (Name (Call)));\n-\n-         --  If the prefix is a package declared elsewhere, iterate over\n-         --  its visible entities, otherwise iterate over all declarations\n-         --  in the designated scope.\n-\n-         if Ekind (Pack) = E_Package\n-           and then not In_Open_Scopes (Pack)\n-         then\n-            Priv_E := First_Private_Entity (Pack);\n-         else\n-            Priv_E := Empty;\n-         end if;\n-\n-         Typ1 := Empty;\n-         E := First_Entity (Pack);\n-         while Present (E) and then E /= Priv_E loop\n-            if Is_Numeric_Type (E)\n-              and then Nkind (Parent (E)) /= N_Subtype_Declaration\n-              and then Comes_From_Source (E)\n-              and then Is_Integer_Type (E) = Is_Int\n-              and then\n-                (Nkind (N) in N_Unary_Op\n-                  or else Is_Relational\n-                  or else Is_Fixed_Point_Type (E) = Is_Fix)\n-            then\n-               if No (Typ1) then\n-                  Typ1 := E;\n-\n-                  --  Before emitting an error, check for the presence of a\n-                  --  mixed-mode operation that specifies a fixed point type.\n-\n-               elsif Is_Relational\n-                 and then\n-                   (Is_Mixed_Mode_Operand (Left_Opnd (N))\n-                    or else Is_Mixed_Mode_Operand (Right_Opnd (N)))\n-                 and then Is_Fixed_Point_Type (E) /= Is_Fixed_Point_Type (Typ1)\n-\n-               then\n-                  if Is_Fixed_Point_Type (E) then\n-                     Typ1 := E;\n-                  end if;\n-\n-               else\n-                  --  More than one type of the proper class declared in P\n-\n-                  Error_Msg_N (\"ambiguous operation\", N);\n-                  Error_Msg_Sloc := Sloc (Typ1);\n-                  Error_Msg_N (\"\\possible interpretation (inherited)#\", N);\n-                  Error_Msg_Sloc := Sloc (E);\n-                  Error_Msg_N (\"\\possible interpretation (inherited)#\", N);\n-                  return Empty;\n-               end if;\n-            end if;\n-\n-            Next_Entity (E);\n-         end loop;\n-      end if;\n-\n-      return Typ1;\n-   end Find_Universal_Operator_Type;\n-\n    ---------------------------------\n    -- Test_Expression_Is_Foldable --\n    ---------------------------------"}, {"sha": "c3be8b53368085ad37765e09579f97efffa2d66f", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74e7891f8d73153b50beebbd497d69b18fc8cb24/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74e7891f8d73153b50beebbd497d69b18fc8cb24/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=74e7891f8d73153b50beebbd497d69b18fc8cb24", "patch": "@@ -5083,13 +5083,15 @@ package body Sem_Res is\n                            Expressions => Parameter_Associations (N));\n                   end if;\n \n+                  --  Preserve the parenthesis count of the node\n+\n+                  Set_Paren_Count (Index_Node, Paren_Count (N));\n+\n                   --  Since we are correcting a node classification error made\n                   --  by the parser, we call Replace rather than Rewrite.\n-                  --  Preserve the parenthesis count of the node, for use by\n-                  --  tools.\n \n-                  Set_Paren_Count (Index_Node, Paren_Count (N));\n                   Replace (N, Index_Node);\n+\n                   Set_Etype (Prefix (N), Ret_Type);\n                   Set_Etype (N, Typ);\n                   Resolve_Indexed_Component (N, Typ);"}, {"sha": "2720b4e1232231d0ae9b5cba6023c7beb1455810", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74e7891f8d73153b50beebbd497d69b18fc8cb24/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74e7891f8d73153b50beebbd497d69b18fc8cb24/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=74e7891f8d73153b50beebbd497d69b18fc8cb24", "patch": "@@ -801,6 +801,7 @@ package Sem_Util is\n    --  function simply tests if it is True (i.e. non-zero)\n \n    function Is_Universal_Numeric_Type (T : Entity_Id) return Boolean;\n+   pragma Inline (Is_Universal_Numeric_Type);\n    --  True if T is Universal_Integer or Universal_Real\n \n    function Is_Value_Type (T : Entity_Id) return Boolean;"}]}