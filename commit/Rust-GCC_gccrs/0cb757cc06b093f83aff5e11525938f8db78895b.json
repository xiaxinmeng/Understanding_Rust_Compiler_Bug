{"sha": "0cb757cc06b093f83aff5e11525938f8db78895b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNiNzU3Y2MwNmIwOTNmODNhZmY1ZTExNTI1OTM4ZjhkYjc4ODk1Yg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2005-05-10T18:28:31Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-05-10T18:28:31Z"}, "message": "javaprims.h: Updated.\n\n\t* gcj/javaprims.h: Updated.\n\t* java/lang/String.java (String(StringBuilder)): New constructor.\n\t* java/lang/natStringBuilder.cc: New file.\n\t* java/lang/StringBuilder.java: New file.\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (core_java_source_files): Added StringBuilder.java.\n\t(nat_source_files): Added natStringBuilder.cc.\n\nFrom-SVN: r99535", "tree": {"sha": "aad8a7f3fb8054aaa963068393ed6f36908bfee5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aad8a7f3fb8054aaa963068393ed6f36908bfee5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0cb757cc06b093f83aff5e11525938f8db78895b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cb757cc06b093f83aff5e11525938f8db78895b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cb757cc06b093f83aff5e11525938f8db78895b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cb757cc06b093f83aff5e11525938f8db78895b/comments", "author": null, "committer": null, "parents": [{"sha": "aeddae499f6b6e02aa8f30f63e18cde5d4cf26a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeddae499f6b6e02aa8f30f63e18cde5d4cf26a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aeddae499f6b6e02aa8f30f63e18cde5d4cf26a4"}], "stats": {"total": 1031, "additions": 1018, "deletions": 13}, "files": [{"sha": "1ba485b91b25dbf10c754d11c58a69d3d3fb07d1", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cb757cc06b093f83aff5e11525938f8db78895b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cb757cc06b093f83aff5e11525938f8db78895b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=0cb757cc06b093f83aff5e11525938f8db78895b", "patch": "@@ -1,3 +1,13 @@\n+2005-05-10  Tom Tromey  <tromey@redhat.com>\n+\n+\t* gcj/javaprims.h: Updated.\n+\t* java/lang/String.java (String(StringBuilder)): New constructor.\n+\t* java/lang/natStringBuilder.cc: New file.\n+\t* java/lang/StringBuilder.java: New file.\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (core_java_source_files): Added StringBuilder.java.\n+\t(nat_source_files): Added natStringBuilder.cc.\n+\n 2005-05-10  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR java/21436"}, {"sha": "124bfe23a6b9a6817ae3e639430dca66859a2244", "filename": "libjava/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cb757cc06b093f83aff5e11525938f8db78895b/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cb757cc06b093f83aff5e11525938f8db78895b/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=0cb757cc06b093f83aff5e11525938f8db78895b", "patch": "@@ -2931,6 +2931,7 @@ java/lang/StackTraceElement.java \\\n java/lang/StrictMath.java \\\n java/lang/String.java \\\n java/lang/StringBuffer.java \\\n+java/lang/StringBuilder.java \\\n java/lang/StringIndexOutOfBoundsException.java \\\n java/lang/System.java \\\n java/lang/Thread.java \\\n@@ -3926,6 +3927,7 @@ java/lang/natObject.cc \\\n java/lang/natRuntime.cc\t\\\n java/lang/natString.cc \\\n java/lang/natStringBuffer.cc \\\n+java/lang/natStringBuilder.cc \\\n java/lang/natSystem.cc \\\n java/lang/natThread.cc \\\n java/lang/natVMClassLoader.cc \\"}, {"sha": "966dab73a9873d6267a3a9b055b6075167d87c5a", "filename": "libjava/Makefile.in", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cb757cc06b093f83aff5e11525938f8db78895b/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cb757cc06b093f83aff5e11525938f8db78895b/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=0cb757cc06b093f83aff5e11525938f8db78895b", "patch": "@@ -264,8 +264,8 @@ am__libgcj0_convenience_la_SOURCES_DIST = prims.cc jni.cc exception.cc \\\n \tjava/lang/natFloat.cc java/lang/natMath.cc \\\n \tjava/lang/natObject.cc java/lang/natRuntime.cc \\\n \tjava/lang/natString.cc java/lang/natStringBuffer.cc \\\n-\tjava/lang/natSystem.cc java/lang/natThread.cc \\\n-\tjava/lang/natVMClassLoader.cc \\\n+\tjava/lang/natStringBuilder.cc java/lang/natSystem.cc \\\n+\tjava/lang/natThread.cc java/lang/natVMClassLoader.cc \\\n \tjava/lang/natVMSecurityManager.cc java/lang/natVMThrowable.cc \\\n \tjava/lang/ref/natReference.cc java/lang/reflect/natArray.cc \\\n \tjava/lang/reflect/natConstructor.cc \\\n@@ -337,6 +337,7 @@ am__libgcj0_convenience_la_SOURCES_DIST = prims.cc jni.cc exception.cc \\\n \tjava/lang/StackOverflowError.java \\\n \tjava/lang/StackTraceElement.java java/lang/StrictMath.java \\\n \tjava/lang/String.java java/lang/StringBuffer.java \\\n+\tjava/lang/StringBuilder.java \\\n \tjava/lang/StringIndexOutOfBoundsException.java \\\n \tjava/lang/System.java java/lang/Thread.java \\\n \tjava/lang/ThreadDeath.java java/lang/ThreadGroup.java \\\n@@ -2312,8 +2313,8 @@ am__objects_5 = gnu/classpath/natSystemProperties.lo \\\n \tjava/lang/natFloat.lo java/lang/natMath.lo \\\n \tjava/lang/natObject.lo java/lang/natRuntime.lo \\\n \tjava/lang/natString.lo java/lang/natStringBuffer.lo \\\n-\tjava/lang/natSystem.lo java/lang/natThread.lo \\\n-\tjava/lang/natVMClassLoader.lo \\\n+\tjava/lang/natStringBuilder.lo java/lang/natSystem.lo \\\n+\tjava/lang/natThread.lo java/lang/natVMClassLoader.lo \\\n \tjava/lang/natVMSecurityManager.lo java/lang/natVMThrowable.lo \\\n \tjava/lang/ref/natReference.lo java/lang/reflect/natArray.lo \\\n \tjava/lang/reflect/natConstructor.lo \\\n@@ -2381,7 +2382,7 @@ am__objects_8 = java/lang/AbstractMethodError.lo \\\n \tjava/lang/SecurityManager.lo java/lang/Short.lo \\\n \tjava/lang/StackOverflowError.lo java/lang/StackTraceElement.lo \\\n \tjava/lang/StrictMath.lo java/lang/String.lo \\\n-\tjava/lang/StringBuffer.lo \\\n+\tjava/lang/StringBuffer.lo java/lang/StringBuilder.lo \\\n \tjava/lang/StringIndexOutOfBoundsException.lo \\\n \tjava/lang/System.lo java/lang/Thread.lo \\\n \tjava/lang/ThreadDeath.lo java/lang/ThreadGroup.lo \\\n@@ -6735,6 +6736,7 @@ java/lang/StackTraceElement.java \\\n java/lang/StrictMath.java \\\n java/lang/String.java \\\n java/lang/StringBuffer.java \\\n+java/lang/StringBuilder.java \\\n java/lang/StringIndexOutOfBoundsException.java \\\n java/lang/System.java \\\n java/lang/Thread.java \\\n@@ -7719,6 +7721,7 @@ java/lang/natObject.cc \\\n java/lang/natRuntime.cc\t\\\n java/lang/natString.cc \\\n java/lang/natStringBuffer.cc \\\n+java/lang/natStringBuilder.cc \\\n java/lang/natSystem.cc \\\n java/lang/natThread.cc \\\n java/lang/natVMClassLoader.cc \\\n@@ -8369,6 +8372,8 @@ java/lang/natString.lo: java/lang/$(am__dirstamp) \\\n \tjava/lang/$(DEPDIR)/$(am__dirstamp)\n java/lang/natStringBuffer.lo: java/lang/$(am__dirstamp) \\\n \tjava/lang/$(DEPDIR)/$(am__dirstamp)\n+java/lang/natStringBuilder.lo: java/lang/$(am__dirstamp) \\\n+\tjava/lang/$(DEPDIR)/$(am__dirstamp)\n java/lang/natSystem.lo: java/lang/$(am__dirstamp) \\\n \tjava/lang/$(DEPDIR)/$(am__dirstamp)\n java/lang/natThread.lo: java/lang/$(am__dirstamp) \\\n@@ -8676,6 +8681,8 @@ java/lang/String.lo: java/lang/$(am__dirstamp) \\\n \tjava/lang/$(DEPDIR)/$(am__dirstamp)\n java/lang/StringBuffer.lo: java/lang/$(am__dirstamp) \\\n \tjava/lang/$(DEPDIR)/$(am__dirstamp)\n+java/lang/StringBuilder.lo: java/lang/$(am__dirstamp) \\\n+\tjava/lang/$(DEPDIR)/$(am__dirstamp)\n java/lang/StringIndexOutOfBoundsException.lo:  \\\n \tjava/lang/$(am__dirstamp) java/lang/$(DEPDIR)/$(am__dirstamp)\n java/lang/System.lo: java/lang/$(am__dirstamp) \\\n@@ -17174,6 +17181,8 @@ mostlyclean-compile:\n \t-rm -f java/lang/String.lo\n \t-rm -f java/lang/StringBuffer.$(OBJEXT)\n \t-rm -f java/lang/StringBuffer.lo\n+\t-rm -f java/lang/StringBuilder.$(OBJEXT)\n+\t-rm -f java/lang/StringBuilder.lo\n \t-rm -f java/lang/StringIndexOutOfBoundsException.$(OBJEXT)\n \t-rm -f java/lang/StringIndexOutOfBoundsException.lo\n \t-rm -f java/lang/System.$(OBJEXT)\n@@ -17266,6 +17275,8 @@ mostlyclean-compile:\n \t-rm -f java/lang/natString.lo\n \t-rm -f java/lang/natStringBuffer.$(OBJEXT)\n \t-rm -f java/lang/natStringBuffer.lo\n+\t-rm -f java/lang/natStringBuilder.$(OBJEXT)\n+\t-rm -f java/lang/natStringBuilder.lo\n \t-rm -f java/lang/natSystem.$(OBJEXT)\n \t-rm -f java/lang/natSystem.lo\n \t-rm -f java/lang/natThread.$(OBJEXT)\n@@ -21174,6 +21185,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/StrictMath.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/String.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/StringBuffer.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/StringBuilder.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/StringIndexOutOfBoundsException.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/System.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/Thread.Plo@am__quote@\n@@ -21220,6 +21232,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/natRuntime.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/natString.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/natStringBuffer.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/natStringBuilder.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/natSystem.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/natThread.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/natVMClassLoader.Plo@am__quote@"}, {"sha": "99fc7a3b345562d1747ae3f30471c0fde8e3f42c", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cb757cc06b093f83aff5e11525938f8db78895b/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cb757cc06b093f83aff5e11525938f8db78895b/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=0cb757cc06b093f83aff5e11525938f8db78895b", "patch": "@@ -1,7 +1,7 @@\n // javaprims.h - Main external header file for libgcj.  -*- c++ -*-\n \n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n    Free Software Foundation\n \n    This file is part of libgcj.\n@@ -78,24 +78,24 @@ extern \"Java\"\n       class IOException;\n       class InputStream;\n       class InputStreamReader;\n-      class InterfaceComparator;\n       class InterruptedIOException;\n       class InvalidClassException;\n       class InvalidObjectException;\n       class LineNumberInputStream;\n       class LineNumberReader;\n-      class MemberComparator;\n-      class MyIOException;\n       class NotActiveException;\n       class NotSerializableException;\n       class ObjectInput;\n       class ObjectInputStream;\n       class ObjectInputStream$GetField;\n+      class ObjectInputStream$ValidatorAndPriority;\n       class ObjectInputValidation;\n       class ObjectOutput;\n       class ObjectOutputStream;\n       class ObjectOutputStream$PutField;\n       class ObjectStreamClass;\n+      class ObjectStreamClass$InterfaceComparator;\n+      class ObjectStreamClass$MemberComparator;\n       class ObjectStreamConstants;\n       class ObjectStreamException;\n       class ObjectStreamField;\n@@ -124,7 +124,6 @@ extern \"Java\"\n       class UTFDataFormatException;\n       class UnsupportedEncodingException;\n       class VMObjectStreamClass;\n-      class ValidatorAndPriority;\n       class WriteAbortedException;\n       class Writer;\n     }\n@@ -204,13 +203,15 @@ extern \"Java\"\n       class String;\n       class String$CaseInsensitiveComparator;\n       class StringBuffer;\n+      class StringBuilder;\n       class StringIndexOutOfBoundsException;\n       class System;\n       class Thread;\n       class ThreadDeath;\n       class ThreadGroup;\n       class ThreadLocal;\n       class Throwable;\n+      class Throwable$StaticData;\n       class UnknownError;\n       class UnsatisfiedLinkError;\n       class UnsupportedClassVersionError;\n@@ -256,6 +257,8 @@ extern \"Java\"\n     {\n       class AbstractCollection;\n       class AbstractList;\n+      class AbstractList$RandomAccessSubList;\n+      class AbstractList$SubList;\n       class AbstractMap;\n       class AbstractMap$BasicMapEntry;\n       class AbstractSequentialList;\n@@ -342,7 +345,6 @@ extern \"Java\"\n       class PropertyResourceBundle;\n       class Random;\n       class RandomAccess;\n-      class RandomAccessSubList;\n       class ResourceBundle;\n       class ResourceBundle$BundleKey;\n       class Set;\n@@ -351,7 +353,6 @@ extern \"Java\"\n       class SortedSet;\n       class Stack;\n       class StringTokenizer;\n-      class SubList;\n       class TimeZone;\n       class Timer;\n       class Timer$Scheduler;\n@@ -376,6 +377,7 @@ extern \"Java\"\n         class JarEntry;\n         class JarException;\n         class JarFile;\n+        class JarFile$EntryInputStream;\n         class JarFile$JarEnumeration;\n         class JarInputStream;\n         class JarOutputStream;"}, {"sha": "bc69ead7163d04714eea7da5dd6dc12538e25237", "filename": "libjava/java/lang/String.java", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cb757cc06b093f83aff5e11525938f8db78895b/libjava%2Fjava%2Flang%2FString.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cb757cc06b093f83aff5e11525938f8db78895b/libjava%2Fjava%2Flang%2FString.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FString.java?ref=0cb757cc06b093f83aff5e11525938f8db78895b", "patch": "@@ -1,5 +1,5 @@\n /* String.java -- immutable character sequences; the object of string literals\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n    Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -397,6 +397,18 @@ public String(StringBuffer buffer)\n       }\n   }\n \n+  /**\n+   * Creates a new String using the character sequence represented by\n+   * the StringBuilder. Subsequent changes to buf do not affect the String.\n+   *\n+   * @param buffer StringBuilder to copy\n+   * @throws NullPointerException if buffer is null\n+   */\n+  public String(StringBuilder buffer)\n+  {\n+    this(buffer.value, 0, buffer.count);\n+  }\n+\n   /**\n    * Special constructor which can share an array when safe to do so.\n    *"}, {"sha": "4f121e7edf92df39696a72cf746ea28833bcaec3", "filename": "libjava/java/lang/StringBuilder.java", "status": "added", "additions": 937, "deletions": 0, "changes": 937, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cb757cc06b093f83aff5e11525938f8db78895b/libjava%2Fjava%2Flang%2FStringBuilder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cb757cc06b093f83aff5e11525938f8db78895b/libjava%2Fjava%2Flang%2FStringBuilder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FStringBuilder.java?ref=0cb757cc06b093f83aff5e11525938f8db78895b", "patch": "@@ -0,0 +1,937 @@\n+/* StringBuilder.java -- Unsynchronized growable strings\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+   Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.lang;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * <code>StringBuilder</code> represents a changeable <code>String</code>.\n+ * It provides the operations required to modify the\n+ * <code>StringBuilder</code>, including insert, replace, delete, append,\n+ * and reverse. It like <code>StringBuffer</code>, but is not\n+ * synchronized.  It is ideal for use when it is known that the\n+ * object will only be used from a single thread.\n+ *\n+ * <p><code>StringBuilder</code>s are variable-length in nature, so even if\n+ * you initialize them to a certain size, they can still grow larger than\n+ * that. <em>Capacity</em> indicates the number of characters the\n+ * <code>StringBuilder</code> can have in it before it has to grow (growing\n+ * the char array is an expensive operation involving <code>new</code>).\n+ *\n+ * <p>Incidentally, compilers often implement the String operator \"+\"\n+ * by using a <code>StringBuilder</code> operation:<br>\n+ * <code>a + b</code><br>\n+ * is the same as<br>\n+ * <code>new StringBuilder().append(a).append(b).toString()</code>.\n+ *\n+ * <p>Classpath's StringBuilder is capable of sharing memory with Strings for\n+ * efficiency.  This will help when a StringBuilder is converted to a String\n+ * and the StringBuilder is not changed after that (quite common when\n+ * performing string concatenation).\n+ *\n+ * @author Paul Fisher\n+ * @author John Keiser\n+ * @author Tom Tromey\n+ * @author Eric Blake (ebb9@email.byu.edu)\n+ * @see String\n+ * @see StringBuffer\n+ *\n+ * @since 1.5\n+ */\n+// FIX15: Implement Appendable when co-variant methods are available\n+public final class StringBuilder\n+  implements Serializable, CharSequence\n+{\n+  // Implementation note: if you change this class, you usually will\n+  // want to change StringBuffer as well.\n+\n+  /**\n+   * For compatability with Sun's JDK\n+   */\n+  private static final long serialVersionUID = 4383685877147921099L;\n+\n+  /**\n+   * Index of next available character (and thus the size of the current\n+   * string contents).  Note that this has permissions set this way so that\n+   * String can get the value.\n+   *\n+   * @serial the number of characters in the buffer\n+   */\n+  int count;\n+\n+  /**\n+   * The buffer.  Note that this has permissions set this way so that String\n+   * can get the value.\n+   *\n+   * @serial the buffer\n+   */\n+  char[] value;\n+\n+  /**\n+   * The default capacity of a buffer.\n+   */\n+  private static final int DEFAULT_CAPACITY = 16;\n+\n+  /**\n+   * Create a new StringBuilder with default capacity 16.\n+   */\n+  public StringBuilder()\n+  {\n+    this(DEFAULT_CAPACITY);\n+  }\n+\n+  /**\n+   * Create an empty <code>StringBuilder</code> with the specified initial\n+   * capacity.\n+   *\n+   * @param capacity the initial capacity\n+   * @throws NegativeArraySizeException if capacity is negative\n+   */\n+  public StringBuilder(int capacity)\n+  {\n+    value = new char[capacity];\n+  }\n+\n+  /**\n+   * Create a new <code>StringBuilder</code> with the characters in the\n+   * specified <code>String</code>. Initial capacity will be the size of the\n+   * String plus 16.\n+   *\n+   * @param str the <code>String</code> to convert\n+   * @throws NullPointerException if str is null\n+   */\n+  public StringBuilder(String str)\n+  {\n+    // Unfortunately, because the size is 16 larger, we cannot share.\n+    count = str.count;\n+    value = new char[count + DEFAULT_CAPACITY];\n+    str.getChars(0, count, value, 0);\n+  }\n+\n+  /**\n+   * Create a new <code>StringBuilder</code> with the characters in the\n+   * specified <code>CharSequence</code>. Initial capacity will be the\n+   * length of the sequence plus 16; if the sequence reports a length\n+   * less than or equal to 0, then the initial capacity will be 16.\n+   *\n+   * @param seq the initializing <code>CharSequence</code>\n+   * @throws NullPointerException if str is null\n+   */\n+  public StringBuilder(CharSequence seq)\n+  {\n+    int len = seq.length();\n+    count = len <= 0 ? 0 : len;\n+    value = new char[count + DEFAULT_CAPACITY];\n+    for (int i = 0; i < len; ++i)\n+      value[i] = seq.charAt(i);\n+  }\n+\n+  /**\n+   * Get the length of the <code>String</code> this <code>StringBuilder</code>\n+   * would create. Not to be confused with the <em>capacity</em> of the\n+   * <code>StringBuilder</code>.\n+   *\n+   * @return the length of this <code>StringBuilder</code>\n+   * @see #capacity()\n+   * @see #setLength(int)\n+   */\n+  public int length()\n+  {\n+    return count;\n+  }\n+\n+  /**\n+   * Get the total number of characters this <code>StringBuilder</code> can\n+   * support before it must be grown.  Not to be confused with <em>length</em>.\n+   *\n+   * @return the capacity of this <code>StringBuilder</code>\n+   * @see #length()\n+   * @see #ensureCapacity(int)\n+   */\n+  public int capacity()\n+  {\n+    return value.length;\n+  }\n+\n+  /**\n+   * Increase the capacity of this <code>StringBuilder</code>. This will\n+   * ensure that an expensive growing operation will not occur until\n+   * <code>minimumCapacity</code> is reached. The buffer is grown to the\n+   * larger of <code>minimumCapacity</code> and\n+   * <code>capacity() * 2 + 2</code>, if it is not already large enough.\n+   *\n+   * @param minimumCapacity the new capacity\n+   * @see #capacity()\n+   */\n+  public void ensureCapacity(int minimumCapacity)\n+  {\n+    if (minimumCapacity > value.length)\n+      {\n+        int max = value.length * 2 + 2;\n+        minimumCapacity = (minimumCapacity < max ? max : minimumCapacity);\n+        char[] nb = new char[minimumCapacity];\n+        System.arraycopy(value, 0, nb, 0, count);\n+        value = nb;\n+      }\n+  }\n+\n+  /**\n+   * Set the length of this StringBuilder. If the new length is greater than\n+   * the current length, all the new characters are set to '\\0'. If the new\n+   * length is less than the current length, the first <code>newLength</code>\n+   * characters of the old array will be preserved, and the remaining\n+   * characters are truncated.\n+   *\n+   * @param newLength the new length\n+   * @throws IndexOutOfBoundsException if the new length is negative\n+   *         (while unspecified, this is a StringIndexOutOfBoundsException)\n+   * @see #length()\n+   */\n+  public void setLength(int newLength)\n+  {\n+    if (newLength < 0)\n+      throw new StringIndexOutOfBoundsException(newLength);\n+\n+    int valueLength = value.length;\n+\n+    /* Always call ensureCapacity in order to preserve copy-on-write\n+       semantics.  */\n+    ensureCapacity(newLength);\n+\n+    if (newLength < valueLength)\n+      {\n+        /* If the StringBuilder's value just grew, then we know that\n+           value is newly allocated and the region between count and\n+           newLength is filled with '\\0'.  */\n+\tcount = newLength;\n+      }\n+    else\n+      {\n+\t/* The StringBuilder's value doesn't need to grow.  However,\n+\t   we should clear out any cruft that may exist.  */\n+\twhile (count < newLength)\n+          value[count++] = '\\0';\n+      }\n+  }\n+\n+  /**\n+   * Get the character at the specified index.\n+   *\n+   * @param index the index of the character to get, starting at 0\n+   * @return the character at the specified index\n+   * @throws IndexOutOfBoundsException if index is negative or &gt;= length()\n+   *         (while unspecified, this is a StringIndexOutOfBoundsException)\n+   */\n+  public char charAt(int index)\n+  {\n+    if (index < 0 || index >= count)\n+      throw new StringIndexOutOfBoundsException(index);\n+    return value[index];\n+  }\n+\n+  /**\n+   * Get the specified array of characters. <code>srcOffset - srcEnd</code>\n+   * characters will be copied into the array you pass in.\n+   *\n+   * @param srcOffset the index to start copying from (inclusive)\n+   * @param srcEnd the index to stop copying from (exclusive)\n+   * @param dst the array to copy into\n+   * @param dstOffset the index to start copying into\n+   * @throws NullPointerException if dst is null\n+   * @throws IndexOutOfBoundsException if any source or target indices are\n+   *         out of range (while unspecified, source problems cause a\n+   *         StringIndexOutOfBoundsException, and dest problems cause an\n+   *         ArrayIndexOutOfBoundsException)\n+   * @see System#arraycopy(Object, int, Object, int, int)\n+   */\n+  public void getChars(int srcOffset, int srcEnd,\n+\t\t       char[] dst, int dstOffset)\n+  {\n+    if (srcOffset < 0 || srcEnd > count || srcEnd < srcOffset)\n+      throw new StringIndexOutOfBoundsException();\n+    System.arraycopy(value, srcOffset, dst, dstOffset, srcEnd - srcOffset);\n+  }\n+\n+  /**\n+   * Set the character at the specified index.\n+   *\n+   * @param index the index of the character to set starting at 0\n+   * @param ch the value to set that character to\n+   * @throws IndexOutOfBoundsException if index is negative or &gt;= length()\n+   *         (while unspecified, this is a StringIndexOutOfBoundsException)\n+   */\n+  public void setCharAt(int index, char ch)\n+  {\n+    if (index < 0 || index >= count)\n+      throw new StringIndexOutOfBoundsException(index);\n+    // Call ensureCapacity to enforce copy-on-write.\n+    ensureCapacity(count);\n+    value[index] = ch;\n+  }\n+\n+  /**\n+   * Append the <code>String</code> value of the argument to this\n+   * <code>StringBuilder</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param obj the <code>Object</code> to convert and append\n+   * @return this <code>StringBuilder</code>\n+   * @see String#valueOf(Object)\n+   * @see #append(String)\n+   */\n+  public StringBuilder append(Object obj)\n+  {\n+    return append(obj == null ? \"null\" : obj.toString());\n+  }\n+\n+  /**\n+   * Append the <code>String</code> to this <code>StringBuilder</code>. If\n+   * str is null, the String \"null\" is appended.\n+   *\n+   * @param str the <code>String</code> to append\n+   * @return this <code>StringBuilder</code>\n+   */\n+  public StringBuilder append(String str)\n+  {\n+    if (str == null)\n+      str = \"null\";\n+    int len = str.count;\n+    ensureCapacity(count + len);\n+    str.getChars(0, len, value, count);\n+    count += len;\n+    return this;\n+  }\n+\n+  /**\n+   * Append the <code>StringBuilder</code> value of the argument to this\n+   * <code>StringBuilder</code>. This behaves the same as\n+   * <code>append((Object) stringBuffer)</code>, except it is more efficient.\n+   *\n+   * @param stringBuffer the <code>StringBuilder</code> to convert and append\n+   * @return this <code>StringBuilder</code>\n+   * @see #append(Object)\n+   */\n+  public StringBuilder append(StringBuffer stringBuffer)\n+  {\n+    if (stringBuffer == null)\n+      return append(\"null\");\n+    synchronized (stringBuffer)\n+      {\n+\tint len = stringBuffer.count;\n+\tensureCapacity(count + len);\n+\tSystem.arraycopy(stringBuffer.value, 0, value, count, len);\n+\tcount += len;\n+      }\n+    return this;\n+  }\n+\n+  /**\n+   * Append the <code>char</code> array to this <code>StringBuilder</code>.\n+   * This is similar (but more efficient) than\n+   * <code>append(new String(data))</code>, except in the case of null.\n+   *\n+   * @param data the <code>char[]</code> to append\n+   * @return this <code>StringBuilder</code>\n+   * @throws NullPointerException if <code>str</code> is <code>null</code>\n+   * @see #append(char[], int, int)\n+   */\n+  public StringBuilder append(char[] data)\n+  {\n+    return append(data, 0, data.length);\n+  }\n+\n+  /**\n+   * Append part of the <code>char</code> array to this\n+   * <code>StringBuilder</code>. This is similar (but more efficient) than\n+   * <code>append(new String(data, offset, count))</code>, except in the case\n+   * of null.\n+   *\n+   * @param data the <code>char[]</code> to append\n+   * @param offset the start location in <code>str</code>\n+   * @param count the number of characters to get from <code>str</code>\n+   * @return this <code>StringBuilder</code>\n+   * @throws NullPointerException if <code>str</code> is <code>null</code>\n+   * @throws IndexOutOfBoundsException if offset or count is out of range\n+   *         (while unspecified, this is a StringIndexOutOfBoundsException)\n+   */\n+  public StringBuilder append(char[] data, int offset, int count)\n+  {\n+    if (offset < 0 || count < 0 || offset > data.length - count)\n+      throw new StringIndexOutOfBoundsException();\n+    ensureCapacity(this.count + count);\n+    System.arraycopy(data, offset, value, this.count, count);\n+    this.count += count;\n+    return this;\n+  }\n+\n+  /**\n+   * Append the <code>String</code> value of the argument to this\n+   * <code>StringBuilder</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param bool the <code>boolean</code> to convert and append\n+   * @return this <code>StringBuilder</code>\n+   * @see String#valueOf(boolean)\n+   */\n+  public StringBuilder append(boolean bool)\n+  {\n+    return append(bool ? \"true\" : \"false\");\n+  }\n+\n+  /**\n+   * Append the <code>char</code> to this <code>StringBuilder</code>.\n+   *\n+   * @param ch the <code>char</code> to append\n+   * @return this <code>StringBuilder</code>\n+   */\n+  public StringBuilder append(char ch)\n+  {\n+    ensureCapacity(count + 1);\n+    value[count++] = ch;\n+    return this;\n+  }\n+\n+  /**\n+   * Append the characters in the <code>CharSequence</code> to this\n+   * buffer.\n+   *\n+   * @param seq the <code>CharSequence</code> providing the characters\n+   * @return this <code>StringBuilder</code>\n+   */\n+  public StringBuilder append(CharSequence seq)\n+  {\n+    return append(seq, 0, seq.length());\n+  }\n+\n+  /**\n+   * Append some characters from the <code>CharSequence</code> to this\n+   * buffer.  If the argument is null, the four characters \"null\" are\n+   * appended.\n+   *\n+   * @param seq the <code>CharSequence</code> providing the characters\n+   * @param start the starting index\n+   * @param end one past the final index\n+   * @return this <code>StringBuilder</code>\n+   */\n+  public StringBuilder append(CharSequence seq, int start,\n+\t\t\t      int end)\n+  {\n+    if (seq == null)\n+      return append(\"null\");\n+    if (end - start > 0)\n+      {\n+\tensureCapacity(count + end - start);\n+\tfor (; start < end; ++start)\n+\t  value[count++] = seq.charAt(start);\n+      }\n+    return this;\n+  }\n+\n+  /**\n+   * Append the <code>String</code> value of the argument to this\n+   * <code>StringBuilder</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param inum the <code>int</code> to convert and append\n+   * @return this <code>StringBuilder</code>\n+   * @see String#valueOf(int)\n+   */\n+  // FIXME: this is native in libgcj in StringBuffer.\n+  public StringBuilder append(int inum)\n+  {\n+    return append(String.valueOf(inum));\n+  }\n+\n+  /**\n+   * Append the <code>String</code> value of the argument to this\n+   * <code>StringBuilder</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param lnum the <code>long</code> to convert and append\n+   * @return this <code>StringBuilder</code>\n+   * @see String#valueOf(long)\n+   */\n+  public StringBuilder append(long lnum)\n+  {\n+    return append(Long.toString(lnum, 10));\n+  }\n+\n+  /**\n+   * Append the <code>String</code> value of the argument to this\n+   * <code>StringBuilder</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param fnum the <code>float</code> to convert and append\n+   * @return this <code>StringBuilder</code>\n+   * @see String#valueOf(float)\n+   */\n+  public StringBuilder append(float fnum)\n+  {\n+    return append(Float.toString(fnum));\n+  }\n+\n+  /**\n+   * Append the <code>String</code> value of the argument to this\n+   * <code>StringBuilder</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param dnum the <code>double</code> to convert and append\n+   * @return this <code>StringBuilder</code>\n+   * @see String#valueOf(double)\n+   */\n+  public StringBuilder append(double dnum)\n+  {\n+    return append(Double.toString(dnum));\n+  }\n+\n+  /**\n+   * Delete characters from this <code>StringBuilder</code>.\n+   * <code>delete(10, 12)</code> will delete 10 and 11, but not 12. It is\n+   * harmless for end to be larger than length().\n+   *\n+   * @param start the first character to delete\n+   * @param end the index after the last character to delete\n+   * @return this <code>StringBuilder</code>\n+   * @throws StringIndexOutOfBoundsException if start or end are out of bounds\n+   */\n+  public StringBuilder delete(int start, int end)\n+  {\n+    if (start < 0 || start > count || start > end)\n+      throw new StringIndexOutOfBoundsException(start);\n+    if (end > count)\n+      end = count;\n+    // This will unshare if required.\n+    ensureCapacity(count);\n+    if (count - end != 0)\n+      System.arraycopy(value, end, value, start, count - end);\n+    count -= end - start;\n+    return this;\n+  }\n+\n+  /**\n+   * Delete a character from this <code>StringBuilder</code>.\n+   *\n+   * @param index the index of the character to delete\n+   * @return this <code>StringBuilder</code>\n+   * @throws StringIndexOutOfBoundsException if index is out of bounds\n+   */\n+  public StringBuilder deleteCharAt(int index)\n+  {\n+    return delete(index, index + 1);\n+  }\n+\n+  /**\n+   * Replace characters between index <code>start</code> (inclusive) and\n+   * <code>end</code> (exclusive) with <code>str</code>. If <code>end</code>\n+   * is larger than the size of this StringBuilder, all characters after\n+   * <code>start</code> are replaced.\n+   *\n+   * @param start the beginning index of characters to delete (inclusive)\n+   * @param end the ending index of characters to delete (exclusive)\n+   * @param str the new <code>String</code> to insert\n+   * @return this <code>StringBuilder</code>\n+   * @throws StringIndexOutOfBoundsException if start or end are out of bounds\n+   * @throws NullPointerException if str is null\n+   */\n+  public StringBuilder replace(int start, int end, String str)\n+  {\n+    if (start < 0 || start > count || start > end)\n+      throw new StringIndexOutOfBoundsException(start);\n+\n+    int len = str.count;\n+    // Calculate the difference in 'count' after the replace.\n+    int delta = len - (end > count ? count : end) + start;\n+    ensureCapacity(count + delta);\n+\n+    if (delta != 0 && end < count)\n+      System.arraycopy(value, end, value, end + delta, count - end);\n+\n+    str.getChars(0, len, value, start);\n+    count += delta;\n+    return this;\n+  }\n+\n+  /**\n+   * Creates a substring of this StringBuilder, starting at a specified index\n+   * and ending at the end of this StringBuilder.\n+   *\n+   * @param beginIndex index to start substring (base 0)\n+   * @return new String which is a substring of this StringBuilder\n+   * @throws StringIndexOutOfBoundsException if beginIndex is out of bounds\n+   * @see #substring(int, int)\n+   */\n+  public String substring(int beginIndex)\n+  {\n+    return substring(beginIndex, count);\n+  }\n+\n+  /**\n+   * Creates a substring of this StringBuilder, starting at a specified index\n+   * and ending at one character before a specified index. This is implemented\n+   * the same as <code>substring(beginIndex, endIndex)</code>, to satisfy\n+   * the CharSequence interface.\n+   *\n+   * @param beginIndex index to start at (inclusive, base 0)\n+   * @param endIndex index to end at (exclusive)\n+   * @return new String which is a substring of this StringBuilder\n+   * @throws IndexOutOfBoundsException if beginIndex or endIndex is out of\n+   *         bounds\n+   * @see #substring(int, int)\n+   */\n+  public CharSequence subSequence(int beginIndex, int endIndex)\n+  {\n+    return substring(beginIndex, endIndex);\n+  }\n+\n+  /**\n+   * Creates a substring of this StringBuilder, starting at a specified index\n+   * and ending at one character before a specified index.\n+   *\n+   * @param beginIndex index to start at (inclusive, base 0)\n+   * @param endIndex index to end at (exclusive)\n+   * @return new String which is a substring of this StringBuilder\n+   * @throws StringIndexOutOfBoundsException if beginIndex or endIndex is out\n+   *         of bounds\n+   */\n+  public String substring(int beginIndex, int endIndex)\n+  {\n+    int len = endIndex - beginIndex;\n+    if (beginIndex < 0 || endIndex > count || endIndex < beginIndex)\n+      throw new StringIndexOutOfBoundsException();\n+    if (len == 0)\n+      return \"\";\n+    return new String(value, beginIndex, len);\n+  }\n+\n+  /**\n+   * Insert a subarray of the <code>char[]</code> argument into this\n+   * <code>StringBuilder</code>.\n+   *\n+   * @param offset the place to insert in this buffer\n+   * @param str the <code>char[]</code> to insert\n+   * @param str_offset the index in <code>str</code> to start inserting from\n+   * @param len the number of characters to insert\n+   * @return this <code>StringBuilder</code>\n+   * @throws NullPointerException if <code>str</code> is <code>null</code>\n+   * @throws StringIndexOutOfBoundsException if any index is out of bounds\n+   */\n+  public StringBuilder insert(int offset,\n+\t\t\t      char[] str, int str_offset, int len)\n+  {\n+    if (offset < 0 || offset > count || len < 0\n+        || str_offset < 0 || str_offset > str.length - len)\n+      throw new StringIndexOutOfBoundsException();\n+    ensureCapacity(count + len);\n+    System.arraycopy(value, offset, value, offset + len, count - offset);\n+    System.arraycopy(str, str_offset, value, offset, len);\n+    count += len;\n+    return this;\n+  }\n+\n+  /**\n+   * Insert the <code>String</code> value of the argument into this\n+   * <code>StringBuilder</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param offset the place to insert in this buffer\n+   * @param obj the <code>Object</code> to convert and insert\n+   * @return this <code>StringBuilder</code>\n+   * @exception StringIndexOutOfBoundsException if offset is out of bounds\n+   * @see String#valueOf(Object)\n+   */\n+  public StringBuilder insert(int offset, Object obj)\n+  {\n+    return insert(offset, obj == null ? \"null\" : obj.toString());\n+  }\n+\n+  /**\n+   * Insert the <code>String</code> argument into this\n+   * <code>StringBuilder</code>. If str is null, the String \"null\" is used\n+   * instead.\n+   *\n+   * @param offset the place to insert in this buffer\n+   * @param str the <code>String</code> to insert\n+   * @return this <code>StringBuilder</code>\n+   * @throws StringIndexOutOfBoundsException if offset is out of bounds\n+   */\n+  public StringBuilder insert(int offset, String str)\n+  {\n+    if (offset < 0 || offset > count)\n+      throw new StringIndexOutOfBoundsException(offset);\n+    if (str == null)\n+      str = \"null\";\n+    int len = str.count;\n+    ensureCapacity(count + len);\n+    System.arraycopy(value, offset, value, offset + len, count - offset);\n+    str.getChars(0, len, value, offset);\n+    count += len;\n+    return this;\n+  }\n+\n+  /**\n+   * Insert the <code>char[]</code> argument into this\n+   * <code>StringBuilder</code>.\n+   *\n+   * @param offset the place to insert in this buffer\n+   * @param data the <code>char[]</code> to insert\n+   * @return this <code>StringBuilder</code>\n+   * @throws NullPointerException if <code>data</code> is <code>null</code>\n+   * @throws StringIndexOutOfBoundsException if offset is out of bounds\n+   * @see #insert(int, char[], int, int)\n+   */\n+  public StringBuilder insert(int offset, char[] data)\n+  {\n+    return insert(offset, data, 0, data.length);\n+  }\n+\n+  /**\n+   * Insert the <code>String</code> value of the argument into this\n+   * <code>StringBuilder</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param offset the place to insert in this buffer\n+   * @param bool the <code>boolean</code> to convert and insert\n+   * @return this <code>StringBuilder</code>\n+   * @throws StringIndexOutOfBoundsException if offset is out of bounds\n+   * @see String#valueOf(boolean)\n+   */\n+  public StringBuilder insert(int offset, boolean bool)\n+  {\n+    return insert(offset, bool ? \"true\" : \"false\");\n+  }\n+\n+  /**\n+   * Insert the <code>char</code> argument into this <code>StringBuilder</code>.\n+   *\n+   * @param offset the place to insert in this buffer\n+   * @param ch the <code>char</code> to insert\n+   * @return this <code>StringBuilder</code>\n+   * @throws StringIndexOutOfBoundsException if offset is out of bounds\n+   */\n+  public StringBuilder insert(int offset, char ch)\n+  {\n+    if (offset < 0 || offset > count)\n+      throw new StringIndexOutOfBoundsException(offset);\n+    ensureCapacity(count + 1);\n+    System.arraycopy(value, offset, value, offset + 1, count - offset);\n+    value[offset] = ch;\n+    count++;\n+    return this;\n+  }\n+\n+  /**\n+   * Insert the <code>String</code> value of the argument into this\n+   * <code>StringBuilder</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param offset the place to insert in this buffer\n+   * @param inum the <code>int</code> to convert and insert\n+   * @return this <code>StringBuilder</code>\n+   * @throws StringIndexOutOfBoundsException if offset is out of bounds\n+   * @see String#valueOf(int)\n+   */\n+  public StringBuilder insert(int offset, int inum)\n+  {\n+    return insert(offset, String.valueOf(inum));\n+  }\n+\n+  /**\n+   * Insert the <code>String</code> value of the argument into this\n+   * <code>StringBuilder</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param offset the place to insert in this buffer\n+   * @param lnum the <code>long</code> to convert and insert\n+   * @return this <code>StringBuilder</code>\n+   * @throws StringIndexOutOfBoundsException if offset is out of bounds\n+   * @see String#valueOf(long)\n+   */\n+  public StringBuilder insert(int offset, long lnum)\n+  {\n+    return insert(offset, Long.toString(lnum, 10));\n+  }\n+\n+  /**\n+   * Insert the <code>String</code> value of the argument into this\n+   * <code>StringBuilder</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param offset the place to insert in this buffer\n+   * @param fnum the <code>float</code> to convert and insert\n+   * @return this <code>StringBuilder</code>\n+   * @throws StringIndexOutOfBoundsException if offset is out of bounds\n+   * @see String#valueOf(float)\n+   */\n+  public StringBuilder insert(int offset, float fnum)\n+  {\n+    return insert(offset, Float.toString(fnum));\n+  }\n+\n+  /**\n+   * Insert the <code>String</code> value of the argument into this\n+   * <code>StringBuilder</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param offset the place to insert in this buffer\n+   * @param dnum the <code>double</code> to convert and insert\n+   * @return this <code>StringBuilder</code>\n+   * @throws StringIndexOutOfBoundsException if offset is out of bounds\n+   * @see String#valueOf(double)\n+   */\n+  public StringBuilder insert(int offset, double dnum)\n+  {\n+    return insert(offset, Double.toString(dnum));\n+  }\n+\n+  /**\n+   * Finds the first instance of a substring in this StringBuilder.\n+   *\n+   * @param str String to find\n+   * @return location (base 0) of the String, or -1 if not found\n+   * @throws NullPointerException if str is null\n+   * @see #indexOf(String, int)\n+   */\n+  public int indexOf(String str)\n+  {\n+    return indexOf(str, 0);\n+  }\n+\n+  /**\n+   * Finds the first instance of a String in this StringBuilder, starting at\n+   * a given index.  If starting index is less than 0, the search starts at\n+   * the beginning of this String.  If the starting index is greater than the\n+   * length of this String, or the substring is not found, -1 is returned.\n+   *\n+   * @param str String to find\n+   * @param fromIndex index to start the search\n+   * @return location (base 0) of the String, or -1 if not found\n+   * @throws NullPointerException if str is null\n+   */\n+  public int indexOf(String str, int fromIndex)\n+  {\n+    if (fromIndex < 0)\n+      fromIndex = 0;\n+    int limit = count - str.count;\n+    for ( ; fromIndex <= limit; fromIndex++)\n+      if (regionMatches(fromIndex, str))\n+        return fromIndex;\n+    return -1;\n+  }\n+\n+  /**\n+   * Finds the last instance of a substring in this StringBuilder.\n+   *\n+   * @param str String to find\n+   * @return location (base 0) of the String, or -1 if not found\n+   * @throws NullPointerException if str is null\n+   * @see #lastIndexOf(String, int)\n+   */\n+  public int lastIndexOf(String str)\n+  {\n+    return lastIndexOf(str, count - str.count);\n+  }\n+\n+  /**\n+   * Finds the last instance of a String in this StringBuilder, starting at a\n+   * given index.  If starting index is greater than the maximum valid index,\n+   * then the search begins at the end of this String.  If the starting index\n+   * is less than zero, or the substring is not found, -1 is returned.\n+   *\n+   * @param str String to find\n+   * @param fromIndex index to start the search\n+   * @return location (base 0) of the String, or -1 if not found\n+   * @throws NullPointerException if str is null\n+   */\n+  public int lastIndexOf(String str, int fromIndex)\n+  {\n+    fromIndex = Math.min(fromIndex, count - str.count);\n+    for ( ; fromIndex >= 0; fromIndex--)\n+      if (regionMatches(fromIndex, str))\n+        return fromIndex;\n+    return -1;\n+  }\n+\n+  /**\n+   * Reverse the characters in this StringBuilder. The same sequence of\n+   * characters exists, but in the reverse index ordering.\n+   *\n+   * @return this <code>StringBuilder</code>\n+   */\n+  public StringBuilder reverse()\n+  {\n+    // Call ensureCapacity to enforce copy-on-write.\n+    ensureCapacity(count);\n+    for (int i = count >> 1, j = count - i; --i >= 0; ++j)\n+      {\n+        char c = value[i];\n+        value[i] = value[j];\n+        value[j] = c;\n+      }\n+    return this;\n+  }\n+\n+  /**\n+   * Convert this <code>StringBuilder</code> to a <code>String</code>. The\n+   * String is composed of the characters currently in this StringBuilder. Note\n+   * that the result is a copy, and that future modifications to this buffer\n+   * do not affect the String.\n+   *\n+   * @return the characters in this StringBuilder\n+   */\n+  public String toString()\n+  {\n+    return new String(this);\n+  }\n+\n+  /**\n+   * Predicate which determines if a substring of this matches another String\n+   * starting at a specified offset for each String and continuing for a\n+   * specified length. This is more efficient than creating a String to call\n+   * indexOf on.\n+   *\n+   * @param toffset index to start comparison at for this String\n+   * @param other non-null String to compare to region of this\n+   * @return true if regions match, false otherwise\n+   * @see #indexOf(String, int)\n+   * @see #lastIndexOf(String, int)\n+   * @see String#regionMatches(boolean, int, String, int, int)\n+   */\n+  // GCJ LOCAL: Native to access String internals properly.\n+  private native boolean regionMatches(int toffset, String other);\n+}"}, {"sha": "e2c8c29f6e3974c4b7f8dbbbcbdee728abb25caa", "filename": "libjava/java/lang/natStringBuilder.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cb757cc06b093f83aff5e11525938f8db78895b/libjava%2Fjava%2Flang%2FnatStringBuilder.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cb757cc06b093f83aff5e11525938f8db78895b/libjava%2Fjava%2Flang%2FnatStringBuilder.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatStringBuilder.cc?ref=0cb757cc06b093f83aff5e11525938f8db78895b", "patch": "@@ -0,0 +1,29 @@\n+// Native methods for StringBuilder.\n+\n+/* Copyright (C) 2005  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+#include <gcj/cni.h>\n+#include <java/lang/StringBuilder.h>\n+#include <java/lang/String.h>\n+\n+jboolean\n+java::lang::StringBuilder::regionMatches(jint offset, jstring other)\n+{\n+  int len = other->count;\n+  int index = 0;\n+  jchar *sc = elements (value);\n+  jchar *oc = _Jv_GetStringChars (other);\n+  while (--len >= 0)\n+    {\n+      if (sc[offset++] != oc[index++])\n+\treturn false;\n+    }\n+  return true;\n+}"}]}