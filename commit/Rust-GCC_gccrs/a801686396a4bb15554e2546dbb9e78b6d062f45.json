{"sha": "a801686396a4bb15554e2546dbb9e78b6d062f45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgwMTY4NjM5NmE0YmIxNTU1NGUyNTQ2ZGJiOWU3OGI2ZDA2MmY0NQ==", "commit": {"author": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-09-26T05:52:43Z"}, "committer": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-09-26T05:52:43Z"}, "message": "cppcharset.c, cpphash.h: Rename 'struct strbuf' to 'struct _cpp_strbuf'.\n\n\t* cppcharset.c, cpphash.h: Rename 'struct strbuf' to\n\t'struct _cpp_strbuf'.\n\nFrom-SVN: r71814", "tree": {"sha": "45aeac4fd465d9c40f4d5508b210bc3b3cf87cfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45aeac4fd465d9c40f4d5508b210bc3b3cf87cfc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a801686396a4bb15554e2546dbb9e78b6d062f45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a801686396a4bb15554e2546dbb9e78b6d062f45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a801686396a4bb15554e2546dbb9e78b6d062f45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a801686396a4bb15554e2546dbb9e78b6d062f45/comments", "author": null, "committer": null, "parents": [{"sha": "a805d35f0082f129b739e86681498ff4fc198e8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a805d35f0082f129b739e86681498ff4fc198e8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a805d35f0082f129b739e86681498ff4fc198e8c"}], "stats": {"total": 39, "additions": 22, "deletions": 17}, "files": [{"sha": "0051408dee0cced075a4d26611406e28941e6753", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a801686396a4bb15554e2546dbb9e78b6d062f45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a801686396a4bb15554e2546dbb9e78b6d062f45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a801686396a4bb15554e2546dbb9e78b6d062f45", "patch": "@@ -1,5 +1,8 @@\n 2003-09-25  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n+\t* cppcharset.c, cpphash.h: Rename 'struct strbuf' to\n+\t'struct _cpp_strbuf'.\n+\n \t* config/i386/netbsd-elf.h, config/i386/netbsd64.h,\n \tconfig/i386/netware.h, config/i386/nto.h, config/i386/openbsd.h,\n \tconfig/i386/pentium.md, config/i386/pmmintrin.h, config/i386/ppro.md,"}, {"sha": "a9424086031860f4be19dd48a8ddd9fa6602d21f", "filename": "gcc/cppcharset.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a801686396a4bb15554e2546dbb9e78b6d062f45/gcc%2Fcppcharset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a801686396a4bb15554e2546dbb9e78b6d062f45/gcc%2Fcppcharset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppcharset.c?ref=a801686396a4bb15554e2546dbb9e78b6d062f45", "patch": "@@ -92,7 +92,9 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #endif\n \n /* This structure is used for a resizable string buffer throughout.  */\n-struct strbuf\n+/* Don't call it strbuf, as that conflicts with unistd.h on systems\n+   such as DYNIX/ptx where unistd.h includes stropts.h. */\n+struct _cpp_strbuf\n {\n   uchar *text;\n   size_t asize;\n@@ -451,7 +453,7 @@ one_utf16_to_utf8 (iconv_t bigend, const uchar **inbufp, size_t *inbytesleftp,\n static inline bool\n conversion_loop (int (*const one_conversion)(iconv_t, const uchar **, size_t *,\n \t\t\t\t\t     uchar **, size_t *),\n-\t\t iconv_t cd, const uchar *from, size_t flen, struct strbuf *to)\n+\t\t iconv_t cd, const uchar *from, size_t flen, struct _cpp_strbuf *to)\n {\n   const uchar *inbuf;\n   uchar *outbuf;\n@@ -492,7 +494,7 @@ conversion_loop (int (*const one_conversion)(iconv_t, const uchar **, size_t *,\n /* These functions convert entire strings between character sets.\n    They all have the signature\n \n-   bool (*)(iconv_t cd, const uchar *from, size_t flen, struct strbuf *to);\n+   bool (*)(iconv_t cd, const uchar *from, size_t flen, struct _cpp_strbuf *to);\n \n    The input string FROM is converted as specified by the function\n    name plus the iconv descriptor CD (which may be fake), and the\n@@ -501,36 +503,36 @@ conversion_loop (int (*const one_conversion)(iconv_t, const uchar **, size_t *,\n /* These four use the custom conversion code above.  */\n static bool\n convert_utf8_utf16 (iconv_t cd, const uchar *from, size_t flen,\n-\t\t    struct strbuf *to)\n+\t\t    struct _cpp_strbuf *to)\n {\n   return conversion_loop (one_utf8_to_utf16, cd, from, flen, to);\n }\n \n static bool\n convert_utf8_utf32 (iconv_t cd, const uchar *from, size_t flen,\n-\t\t    struct strbuf *to)\n+\t\t    struct _cpp_strbuf *to)\n {\n   return conversion_loop (one_utf8_to_utf32, cd, from, flen, to);\n }\n \n static bool\n convert_utf16_utf8 (iconv_t cd, const uchar *from, size_t flen,\n-\t\t    struct strbuf *to)\n+\t\t    struct _cpp_strbuf *to)\n {\n   return conversion_loop (one_utf16_to_utf8, cd, from, flen, to);\n }\n \n static bool\n convert_utf32_utf8 (iconv_t cd, const uchar *from, size_t flen,\n-\t\t    struct strbuf *to)\n+\t\t    struct _cpp_strbuf *to)\n {\n   return conversion_loop (one_utf32_to_utf8, cd, from, flen, to);\n }\n \n /* Identity conversion, used when we have no alternative.  */\n static bool\n convert_no_conversion (iconv_t cd ATTRIBUTE_UNUSED,\n-\t\t       const uchar *from, size_t flen, struct strbuf *to)\n+\t\t       const uchar *from, size_t flen, struct _cpp_strbuf *to)\n {\n   if (to->len + flen > to->asize)\n     {\n@@ -547,7 +549,7 @@ convert_no_conversion (iconv_t cd ATTRIBUTE_UNUSED,\n #if HAVE_ICONV\n static bool\n convert_using_iconv (iconv_t cd, const uchar *from, size_t flen,\n-\t\t     struct strbuf *to)\n+\t\t     struct _cpp_strbuf *to)\n {\n   ICONV_CONST char *inbuf;\n   char *outbuf;\n@@ -873,7 +875,7 @@ _cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr,\n \n static const uchar *\n convert_ucn (cpp_reader *pfile, const uchar *from, const uchar *limit,\n-\t     struct strbuf *tbuf, bool wide)\n+\t     struct _cpp_strbuf *tbuf, bool wide)\n {\n   cppchar_t ucn;\n   uchar buf[6];\n@@ -900,7 +902,7 @@ convert_ucn (cpp_reader *pfile, const uchar *from, const uchar *limit,\n \n static void\n emit_numeric_escape (cpp_reader *pfile, cppchar_t n,\n-\t\t     struct strbuf *tbuf, bool wide)\n+\t\t     struct _cpp_strbuf *tbuf, bool wide)\n {\n   if (wide)\n     {\n@@ -948,7 +950,7 @@ emit_numeric_escape (cpp_reader *pfile, cppchar_t n,\n    number.  You can, e.g. generate surrogate pairs this way.  */\n static const uchar *\n convert_hex (cpp_reader *pfile, const uchar *from, const uchar *limit,\n-\t     struct strbuf *tbuf, bool wide)\n+\t     struct _cpp_strbuf *tbuf, bool wide)\n {\n   cppchar_t c, n = 0, overflow = 0;\n   int digits_found = 0;\n@@ -999,7 +1001,7 @@ convert_hex (cpp_reader *pfile, const uchar *from, const uchar *limit,\n    number.  */\n static const uchar *\n convert_oct (cpp_reader *pfile, const uchar *from, const uchar *limit,\n-\t     struct strbuf *tbuf, bool wide)\n+\t     struct _cpp_strbuf *tbuf, bool wide)\n {\n   size_t count = 0;\n   cppchar_t c, n = 0;\n@@ -1036,7 +1038,7 @@ convert_oct (cpp_reader *pfile, const uchar *from, const uchar *limit,\n    pointer.  Handles all relevant diagnostics.  */\n static const uchar *\n convert_escape (cpp_reader *pfile, const uchar *from, const uchar *limit,\n-\t\tstruct strbuf *tbuf, bool wide)\n+\t\tstruct _cpp_strbuf *tbuf, bool wide)\n {\n   /* Values of \\a \\b \\e \\f \\n \\r \\t \\v respectively.  */\n #if HOST_CHARSET == HOST_CHARSET_ASCII\n@@ -1128,7 +1130,7 @@ bool\n cpp_interpret_string (cpp_reader *pfile, const cpp_string *from, size_t count,\n \t\t      cpp_string *to, bool wide)\n {\n-  struct strbuf tbuf;\n+  struct _cpp_strbuf tbuf;\n   const uchar *p, *base, *limit;\n   size_t i;\n   struct cset_converter cvt"}, {"sha": "89124b5334bc5eeed1c1f984fc3fd050f36a3ada", "filename": "gcc/cpphash.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a801686396a4bb15554e2546dbb9e78b6d062f45/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a801686396a4bb15554e2546dbb9e78b6d062f45/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=a801686396a4bb15554e2546dbb9e78b6d062f45", "patch": "@@ -35,10 +35,10 @@ typedef int iconv_t;  /* dummy */\n struct directive;\t\t/* Deliberately incomplete.  */\n struct pending_option;\n struct op;\n-struct strbuf;\n+struct _cpp_strbuf;\n \n typedef bool (*convert_f) (iconv_t, const unsigned char *, size_t,\n-\t\t\t   struct strbuf *);\n+\t\t\t   struct _cpp_strbuf *);\n struct cset_converter\n {\n   convert_f func;"}]}