{"sha": "8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGEzNmEwY2NkODRkNzNlOGJmYjU5ODliZTE1MTA1MzZiNzNiOWRmOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-05-27T13:09:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-05-27T13:09:26Z"}, "message": "[multiple changes]\n\n2004-05-27  Vincent Celier  <celier@gnat.com>\n\n\t* vms_data.ads: Add new GNAT PRETTY qualifiers /NO_BACKUP and\n\tCOMMENTS_LAYOUT=UNTOUCHED\n\n\t* symbols-vms.adb, symbols-vms-alpha.adb: Renamed symbols-vms.adb to\n\tsymbols-vms-alpha.adb\n\n2004-05-27  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* sem.ads: Clarify documentation on checks suppression.\n\n\t* einfo.ads (Is_Known_Non_Null): Minor comment typo fix and rephrasing.\n\n2004-05-27  Ed Schonberg  <schonberg@gnat.com>\n\n\t* sem_util.adb (Is_Descendent_Of): Examine properly all ancestors in\n\tthe case of multiple derivations.\n\t(Is_Object_Reference): For a selected component, verify that the prefix\n\tis itself an object and not a value.\n\n\t* sem_ch12.adb (Same_Instantiated_Constant): New name for\n\tSame_Instantiated_Entity.\n\t(Same_Instantiated_Variable): Subsidiary to\n\tCheck_Formal_Package_Instance, to recognize actuals for in-out generic\n\tformals that are obtained from a previous formal package.\n\t(Instantiate_Subprogram_Body): Emit proper error when\n\tgenerating code and the proper body of a stub is missing.\n\n\t* sem_ch4.adb (Remove_Address_Interpretations): If the operation still\n\thas a universal interpretation, do the disambiguation here.\n\n\t* exp_ch4.adb (Expand_N_Type_Conversion,\n\tExpand_N_Unchecked_Type_Conversion): Special handling when target type\n\tis Address, to avoid typing anomalies when Address is a visible integer\n\ttype.\n\n\t* exp_ch6.adb (Expand_N_Subprogram_Body): Use Is_Descendent_Of_Address\n\tto determine whether a subprogram should not be marked Pure, even when\n\tdeclared in a pure package.\n\n2004-05-27  Jose Ruiz  <ruiz@act-europe.fr>\n\n\t* gnat_ugn.texi: Replace pragma Ravenscar by pragma Profile.\n\n\t* gnat_rm.texi: Replace Max_Entry_Queue_Depth by Max_Entry_Queue_Length\n\tDocument No_Dynamic_Attachment, that supersedes No_Dynamic_Interrupts.\n\tUpdate the documentation about the Ravenscar profile, following the\n\tdefinition found in AI-249.\n\n\t* sem_prag.adb: Use FIFO_Within_Priorities and Ceiling_Locking when\n\tsetting the Profile (Ravenscar). This must be done in addition to\n\tsetting the required restrictions.\n\n\t* rtsfind.ads: Add the set of operations defined in package\n\tAda.Interrupts.\n\n\t* exp_ch6.adb: Check whether we are violating the No_Dynamic_Attachment\n\trestriction.\n\n2004-05-27  Eric Botcazou  <ebotcazou@act-europe.fr>\n\n\tlang-specs.h: Always require -c or -S and always redirect to /dev/null\n\tif -gnatc or -gnats is passed.\n\n2004-05-27  Hristian Kirtchev  <kirtchev@gnat.com>\n\n\t* sem_prag.adb (Sig_Flags): A Pragma_Unchecked_Union does not count as\n\ta significant reference. Warnings are now properly emitted when a\n\tdiscriminated type is not referenced.\n\n\t* lib-xref.adb (Generate_Reference): A deferred constant completion,\n\trecord representation clause or record type discriminant does not\n\tproduce a reference to its corresponding entity. Warnings are now\n\tproperly emitted when deferred constants and record types are not\n\treferenced.\n\n2004-05-27  Geert Bosch  <bosch@gnat.com>\n\n\t* Makefile.in: Use long version of libm routines on ia64 gnu/linux.\n\tFixes ACATS Annex G tests.\n\n2004-05-27  Robert Dewar  <dewar@gnat.com>\n\n\t* rtsfind.adb (RTU_Loaded): Temporary kludge to get past bug of not\n\thandling WITH\n\n2004-05-27  Arnaud Charlet  <charlet@act-europe.fr>\n\n\t* s-interr.adb (Server_Task): Take into account case of early return\n\tfrom sigwait under e.g. linux.\n\n2004-05-27  Sergey Rybin  <rybin@act-europe.fr>\n\n\t* gnat_ugn.texi: Add description for the new gnatpp options:\n\t -rnb - replace the original source without creating its backup copy\n\t -c0 - do not format comments\n\nFrom-SVN: r82324", "tree": {"sha": "117c6dde30102543581aa4da898f72f25fea3aa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/117c6dde30102543581aa4da898f72f25fea3aa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/comments", "author": null, "committer": null, "parents": [{"sha": "062583ea1ced97a69fd5df986dada75c33c940d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/062583ea1ced97a69fd5df986dada75c33c940d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/062583ea1ced97a69fd5df986dada75c33c940d8"}], "stats": {"total": 902, "additions": 633, "deletions": 269}, "files": [{"sha": "f829316f4052840bc2dad201f97bdc1b27a881a6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "patch": "@@ -1,3 +1,101 @@\n+2004-05-27  Vincent Celier  <celier@gnat.com>\n+\n+\t* vms_data.ads: Add new GNAT PRETTY qualifiers /NO_BACKUP and\n+\tCOMMENTS_LAYOUT=UNTOUCHED\n+\n+\t* symbols-vms.adb, symbols-vms-alpha.adb: Renamed symbols-vms.adb to\n+\tsymbols-vms-alpha.adb\n+\n+2004-05-27  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* sem.ads: Clarify documentation on checks suppression.\n+\n+\t* einfo.ads (Is_Known_Non_Null): Minor comment typo fix and rephrasing.\n+\n+2004-05-27  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_util.adb (Is_Descendent_Of): Examine properly all ancestors in\n+\tthe case of multiple derivations.\n+\t(Is_Object_Reference): For a selected component, verify that the prefix\n+\tis itself an object and not a value.\n+\n+\t* sem_ch12.adb (Same_Instantiated_Constant): New name for\n+\tSame_Instantiated_Entity.\n+\t(Same_Instantiated_Variable): Subsidiary to\n+\tCheck_Formal_Package_Instance, to recognize actuals for in-out generic\n+\tformals that are obtained from a previous formal package.\n+\t(Instantiate_Subprogram_Body): Emit proper error when\n+\tgenerating code and the proper body of a stub is missing.\n+\n+\t* sem_ch4.adb (Remove_Address_Interpretations): If the operation still\n+\thas a universal interpretation, do the disambiguation here.\n+\n+\t* exp_ch4.adb (Expand_N_Type_Conversion,\n+\tExpand_N_Unchecked_Type_Conversion): Special handling when target type\n+\tis Address, to avoid typing anomalies when Address is a visible integer\n+\ttype.\n+\n+\t* exp_ch6.adb (Expand_N_Subprogram_Body): Use Is_Descendent_Of_Address\n+\tto determine whether a subprogram should not be marked Pure, even when\n+\tdeclared in a pure package.\n+\n+2004-05-27  Jose Ruiz  <ruiz@act-europe.fr>\n+\n+\t* gnat_ugn.texi: Replace pragma Ravenscar by pragma Profile.\n+\n+\t* gnat_rm.texi: Replace Max_Entry_Queue_Depth by Max_Entry_Queue_Length\n+\tDocument No_Dynamic_Attachment, that supersedes No_Dynamic_Interrupts.\n+\tUpdate the documentation about the Ravenscar profile, following the\n+\tdefinition found in AI-249.\n+\n+\t* sem_prag.adb: Use FIFO_Within_Priorities and Ceiling_Locking when\n+\tsetting the Profile (Ravenscar). This must be done in addition to\n+\tsetting the required restrictions.\n+\n+\t* rtsfind.ads: Add the set of operations defined in package\n+\tAda.Interrupts.\n+\n+\t* exp_ch6.adb: Check whether we are violating the No_Dynamic_Attachment\n+\trestriction.\n+\n+2004-05-27  Eric Botcazou  <ebotcazou@act-europe.fr>\n+\n+\tlang-specs.h: Always require -c or -S and always redirect to /dev/null\n+\tif -gnatc or -gnats is passed.\n+\n+2004-05-27  Hristian Kirtchev  <kirtchev@gnat.com>\n+\n+\t* sem_prag.adb (Sig_Flags): A Pragma_Unchecked_Union does not count as\n+\ta significant reference. Warnings are now properly emitted when a\n+\tdiscriminated type is not referenced.\n+\n+\t* lib-xref.adb (Generate_Reference): A deferred constant completion,\n+\trecord representation clause or record type discriminant does not\n+\tproduce a reference to its corresponding entity. Warnings are now\n+\tproperly emitted when deferred constants and record types are not\n+\treferenced.\n+\n+2004-05-27  Geert Bosch  <bosch@gnat.com>\n+\n+\t* Makefile.in: Use long version of libm routines on ia64 gnu/linux.\n+\tFixes ACATS Annex G tests.\n+\n+2004-05-27  Robert Dewar  <dewar@gnat.com>\n+\n+\t* rtsfind.adb (RTU_Loaded): Temporary kludge to get past bug of not\n+\thandling WITH\n+\n+2004-05-27  Arnaud Charlet  <charlet@act-europe.fr>\n+\n+\t* s-interr.adb (Server_Task): Take into account case of early return\n+\tfrom sigwait under e.g. linux.\n+\n+2004-05-27  Sergey Rybin  <rybin@act-europe.fr>\n+\n+\t* gnat_ugn.texi: Add description for the new gnatpp options:\n+\t -rnb - replace the original source without creating its backup copy\n+\t -c0 - do not format comments\n+\n 2004-05-24  Geert Bosch  <bosch@gnat.com>\n \n \t* a-numaux-x86.adb (Reduce): Reimplement using an approximation of Pi"}, {"sha": "bf691bb3aa28b4b754c854842323996543d9e4fe", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "patch": "@@ -1260,6 +1260,7 @@ endif\n ifeq ($(strip $(filter-out %ia64 linux%,$(arch) $(osys))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-intnam.ads<a-intnam-linux.ads \\\n+  a-numaux.ads<a-numaux-libc-x86.ads \\\n   s-inmaop.adb<s-inmaop-posix.adb \\\n   s-intman.adb<s-intman-posix.adb \\\n   s-osinte.ads<s-osinte-linux.ads \\"}, {"sha": "47685f64639bc400f35bc923b111a99d0339ea98", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "patch": "@@ -1970,12 +1970,12 @@ package Einfo is\n --       Present in all entities. Relevant (and can be set True) only for\n --       objects of an access type. It is set if the object is currently\n --       known to have a non-null value (meaning that no access checks\n---       are needed). The indication can for example3 come from assignment\n+--       are needed). The indication can for example come from assignment\n --       of an access parameter or an allocator.\n --\n --       Note: this flag is set according to the sequential flow of the\n --       program, watching the current value of the variable. However,\n---       this processing can cases of changing the value of an aliased\n+--       this processing can miss cases of changing the value of an aliased\n --       or constant object, so even if this flag is set, it should not\n --       be believed if the variable is aliased or volatile. It would\n --       be a little neater to avoid the flag being set in the first"}, {"sha": "8703e27b27b4816cb21c7ebb097a6375b7338b17", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "patch": "@@ -6221,10 +6221,17 @@ package body Exp_Ch4 is\n \n                --  Reset overflow flag, since the range check will include\n                --  dealing with possible overflow, and generate the check\n+               --  If Address is either source or target type, suppress\n+               --  range check to avoid typing anomalies when it is a visible\n+               --  integer type.\n \n                Set_Do_Overflow_Check (N, False);\n-               Generate_Range_Check\n-                 (Expr, Target_Type, CE_Range_Check_Failed);\n+               if not Is_Descendent_Of_Address (Etype (Expr))\n+                 and then not Is_Descendent_Of_Address (Target_Type)\n+               then\n+                  Generate_Range_Check\n+                    (Expr, Target_Type, CE_Range_Check_Failed);\n+               end if;\n             end if;\n          end;\n       end if;\n@@ -6288,7 +6295,17 @@ package body Exp_Ch4 is\n                Val <= Expr_Value (Type_High_Bound (Target_Type))\n             then\n                Rewrite (N, Make_Integer_Literal (Sloc (N), Val));\n-               Analyze_And_Resolve (N, Target_Type);\n+\n+               --  If Address is the target type, just set the type\n+               --  to avoid a spurious type error on the literal when\n+               --  Address is a visible integer type.\n+\n+               if Is_Descendent_Of_Address (Target_Type) then\n+                  Set_Etype (N, Target_Type);\n+               else\n+                  Analyze_And_Resolve (N, Target_Type);\n+               end if;\n+\n                return;\n             end if;\n          end;"}, {"sha": "b049710f9221432bd5de72156b986da175f68701", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "patch": "@@ -1833,10 +1833,27 @@ package body Exp_Ch6 is\n          Subp := Parent_Subp;\n       end if;\n \n+      --  Check for violation of No_Abort_Statements\n+\n       if Is_RTE (Subp, RE_Abort_Task) then\n          Check_Restriction (No_Abort_Statements, N);\n+\n+      --  Check for violation of No_Dynamic_Attachment\n+\n+      elsif RTU_Loaded (Ada_Interrupts)\n+        and then (Is_RTE (Subp, RE_Is_Reserved)      or else\n+                  Is_RTE (Subp, RE_Is_Attached)      or else\n+                  Is_RTE (Subp, RE_Current_Handler)  or else\n+                  Is_RTE (Subp, RE_Attach_Handler)   or else\n+                  Is_RTE (Subp, RE_Exchange_Handler) or else\n+                  Is_RTE (Subp, RE_Detach_Handler)   or else\n+                  Is_RTE (Subp, RE_Reference))\n+      then\n+         Check_Restriction (No_Dynamic_Attachment, N);\n       end if;\n \n+      --  Deal with case where call is an explicit dereference\n+\n       if Nkind (Name (N)) = N_Explicit_Dereference then\n \n       --  Handle case of access to protected subprogram type\n@@ -3189,7 +3206,7 @@ package body Exp_Ch6 is\n \n          begin\n             while Present (F) loop\n-               if Is_RTE (Root_Type (Etype (F)), RE_Address) then\n+               if Is_Descendent_Of_Address (Etype (F)) then\n                   Set_Is_Pure (Spec_Id, False);\n \n                   if Spec_Id /= Body_Id then"}, {"sha": "17daf35672150ef1b5f803b4f775d4c93c397aa1", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 154, "deletions": 130, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "patch": "@@ -151,10 +151,10 @@ Implementation Defined Pragmas\n * Pragma Obsolescent::\n * Pragma Passive::\n * Pragma Polling::\n+* Pragma Profile (Ravenscar)::\n * Pragma Propagate_Exceptions::\n * Pragma Psect_Object::\n * Pragma Pure_Function::\n-* Pragma Ravenscar::\n * Pragma Restricted_Run_Time::\n * Pragma Restriction_Warnings::\n * Pragma Source_File_Name::\n@@ -641,10 +641,10 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Obsolescent::\n * Pragma Passive::\n * Pragma Polling::\n+* Pragma Profile (Ravenscar)::\n * Pragma Propagate_Exceptions::\n * Pragma Psect_Object::\n * Pragma Pure_Function::\n-* Pragma Ravenscar::\n * Pragma Restricted_Run_Time::\n * Pragma Restriction_Warnings::\n * Pragma Source_File_Name::\n@@ -2804,6 +2804,147 @@ to test for an abort condition.\n Note that polling can also be enabled by use of the @code{-gnatP} switch.  See\n the @cite{GNAT User's Guide} for details.\n \n+@node Pragma Profile (Ravenscar)\n+@unnumberedsec Pragma Profile (Ravenscar)\n+@findex Ravenscar\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Profile (Ravenscar);\n+@end smallexample\n+\n+@noindent\n+A configuration pragma that establishes the following set of configuration\n+pragmas:\n+\n+@table @code\n+@item Task_Dispatching_Policy (FIFO_Within_Priorities)\n+[RM D.2.2] Tasks are dispatched following a preemptive\n+priority-ordered scheduling policy.\n+\n+@item Locking_Policy (Ceiling_Locking)\n+[RM D.3] While tasks and interrupts execute a protected action, they inherit\n+the ceiling priority of the corresponding protected object.\n+@c\n+@c @item Detect_Blocking\n+@c This pragma forces the detection of potentially blocking operations within a\n+@c protected operation, and to raise Program_Error if that happens.\n+@end table\n+@noindent\n+\n+plus the following set of restrictions:\n+\n+@table @code\n+@item Max_Entry_Queue_Length = 1\n+Defines the maximum number of calls that are queued on a (protected) entry.\n+Note that this restrictions is checked at run time. Violation of this\n+restriction results in the raising of Program_Error exception at the point of\n+the call. For the Profile (Ravenscar) the value of Max_Entry_Queue_Length is\n+always 1 and hence no task can be queued on a protected entry.\n+\n+@item Max_Protected_Entries = 1\n+[RM D.7] Specifies the maximum number of entries per protected type. The\n+bounds of every entry family of a protected unit shall be static, or shall be\n+defined by a discriminant of a subtype whose corresponding bound is static.\n+For the Profile (Ravenscar) the value of Max_Protected_Entries is always 1.\n+\n+@item Max_Task_Entries = 0\n+[RM D.7] Specifies the maximum number of entries\n+per task.  The bounds of every entry family\n+of a task unit shall be static, or shall be\n+defined by a discriminant of a subtype whose\n+corresponding bound is static.  A value of zero\n+indicates that no rendezvous are possible.  For\n+the Profile (Ravenscar), the value of Max_Task_Entries is always\n+0 (zero).\n+\n+@item No_Abort_Statements\n+[RM D.7] There are no abort_statements, and there are\n+no calls to Task_Identification.Abort_Task.\n+\n+@item No_Asynchronous_Control\n+[RM D.7] There are no semantic dependences on the package\n+Asynchronous_Task_Control.\n+\n+@item No_Calendar\n+There are no semantic dependencies on the package Ada.Calendar.\n+\n+@item No_Dynamic_Attachment\n+There is no call to any of the operations defined in package Ada.Interrupts\n+(Is_Reserved, Is_Attached, Current_Handler, Attach_Handler, Exchange_Handler,\n+Detach_Handler, and Reference).\n+\n+@item No_Dynamic_Priorities\n+[RM D.7] There are no semantic dependencies on the package Dynamic_Priorities.\n+\n+@item No_Implicit_Heap_Allocations\n+[RM D.7] No constructs are allowed to cause implicit heap allocation.\n+\n+@item No_Local_Protected_Objects\n+Protected objects and access types that designate\n+such objects shall be declared only at library level.\n+\n+@item No_Protected_Type_Allocators\n+There are no allocators for protected types or\n+types containing protected subcomponents.\n+\n+@item No_Relative_Delay\n+There are no delay_relative statements.\n+\n+@item No_Requeue_Statements\n+Requeue statements are not allowed.\n+\n+@item No_Select_Statements\n+There are no select_statements.\n+\n+@item No_Task_Allocators\n+[RM D.7] There are no allocators for task types\n+or types containing task subcomponents.\n+\n+@item No_Task_Attributes_Package\n+There are no semantic dependencies on the Ada.Task_Attributes package.\n+\n+@item No_Task_Hierarchy\n+[RM D.7] All (non-environment) tasks depend\n+directly on the environment task of the partition.\n+\n+@item No_Task_Termination\n+Tasks which terminate are erroneous.\n+\n+@item Simple_Barriers\n+Entry barrier condition expressions shall be either static\n+boolean expressions or boolean objects which are declared in\n+the protected type which contains the entry.\n+@end table\n+\n+@noindent\n+This set of configuration pragmas and restrictions correspond to the\n+definition of the ``Ravenscar Profile'' for limited tasking, devised and\n+published by the @cite{International Real-Time Ada Workshop}, 1997,\n+and whose most recent description is available at\n+@url{ftp://ftp.openravenscar.org/openravenscar/ravenscar00.pdf}.\n+\n+The original definition of the profile was revised at subsequent IRTAW\n+meetings. It has been included in the ISO\n+@cite{Guide for the Use of the Ada Programming Language in High\n+Integrity Systems}, and has been approved by ISO/IEC/SC22/WG9 for inclusion in\n+the next revision of the standard. The formal definition given by\n+the Ada Rapporteur Group (ARG) can be found in two Ada Issues (AI-249 and\n+AI-305) available at\n+@url{http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00249.TXT} and\n+@url{http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00305.TXT}\n+respectively.\n+\n+The above set is a superset of the restrictions provided by pragma\n+@code{Restricted_Run_Time}, it includes six additional restrictions\n+(@code{Simple_Barriers}, @code{No_Select_Statements},\n+@code{No_Calendar}, @code{No_Implicit_Heap_Allocations},\n+@code{No_Relative_Delay} and @code{No_Task_Termination}).  This means\n+that pragma @code{Profile (Ravenscar)}, like the pragma\n+@code{Restricted_Run_Time}, automatically causes the use of a simplified,\n+more efficient version of the tasking run-time system.\n+\n @node Pragma Propagate_Exceptions\n @unnumberedsec Pragma Propagate_Exceptions\n @findex Propagate_Exceptions\n@@ -2914,123 +3055,6 @@ applies to the underlying renamed function.  This can be used to\n disambiguate cases of overloading where some but not all functions\n in a set of overloaded functions are to be designated as pure.\n \n-@node Pragma Ravenscar\n-@unnumberedsec Pragma Ravenscar\n-@findex Ravenscar\n-@noindent\n-Syntax:\n-\n-@smallexample @c ada\n-pragma Ravenscar;\n-@end smallexample\n-\n-@noindent\n-A configuration pragma that establishes the following set of restrictions:\n-\n-@table @code\n-@item No_Abort_Statements\n-[RM D.7] There are no abort_statements, and there are\n-no calls to Task_Identification.Abort_Task.\n-\n-@item No_Select_Statements\n-There are no select_statements.\n-\n-@item No_Task_Hierarchy\n-[RM D.7] All (non-environment) tasks depend\n-directly on the environment task of the partition.\n-\n-@item No_Task_Allocators\n-[RM D.7] There are no allocators for task types\n-or types containing task subcomponents.\n-\n-@item No_Dynamic_Priorities\n-[RM D.7] There are no semantic dependencies on the package Dynamic_Priorities.\n-\n-@item No_Terminate_Alternatives\n-[RM D.7] There are no selective_accepts with terminate_alternatives\n-\n-@item No_Dynamic_Interrupts\n-There are no semantic dependencies on Ada.Interrupts.\n-\n-@item No_Implicit_Heap_Allocations\n-[RM D.7] No constructs are allowed to cause implicit heap allocation\n-\n-@item No_Protected_Type_Allocators\n-There are no allocators for protected types or\n-types containing protected subcomponents.\n-\n-@item No_Local_Protected_Objects\n-Protected objects and access types that designate\n-such objects shall be declared only at library level.\n-\n-@item No_Requeue_Statements\n-Requeue statements are not allowed.\n-\n-@item No_Calendar\n-There are no semantic dependencies on the package Ada.Calendar.\n-\n-@item No_Relative_Delay\n-There are no delay_relative_statements.\n-\n-@item No_Task_Attributes_Package\n-There are no semantic dependencies on the Ada.Task_Attributes package.\n-\n-@item Simple_Barriers\n-Entry barrier condition expressions shall be either static\n-boolean expressions or boolean objects which are declared in\n-the protected type which contains the entry.\n-\n-@item Max_Asynchronous_Select_Nesting = 0\n-[RM D.7] Specifies the maximum dynamic nesting level of asynchronous_selects.\n-A value of zero prevents the use of any asynchronous_select.\n-\n-@item Max_Task_Entries = 0\n-[RM D.7] Specifies the maximum number of entries\n-per task.  The bounds of every entry family\n-of a task unit shall be static, or shall be\n-defined by a discriminant of a subtype whose\n-corresponding bound is static.  A value of zero\n-indicates that no rendezvous are possible.  For\n-the Ravenscar pragma, the value of Max_Task_Entries is always\n-0 (zero).\n-\n-@item Max_Protected_Entries = 1\n-[RM D.7] Specifies the maximum number of entries per\n-protected type.  The bounds of every entry family of\n-a protected unit shall be static, or shall be defined\n-by a discriminant of a subtype whose corresponding\n-bound is static.  For the Ravenscar pragma the value of\n-Max_Protected_Entries is always 1.\n-\n-@item Max_Select_Alternatives = 0\n-[RM D.7] Specifies the maximum number of alternatives in a selective_accept.\n-For the Ravenscar pragma the value is always 0.\n-\n-@item No_Task_Termination\n-Tasks which terminate are erroneous.\n-\n-@item No_Entry_Queue\n-No task can be queued on a protected entry.  Note that this restrictions is\n-checked at run time.  The violation of this restriction generates a\n-Program_Error exception.\n-@end table\n-\n-@noindent\n-This set of restrictions corresponds to the definition of the ``Ravenscar\n-Profile'' for limited tasking, devised and published by the\n-@cite{International Real-Time Ada Workshop}, 1997,\n-and whose most recent description is available at\n-@url{ftp://ftp.openravenscar.org/openravenscar/ravenscar00.pdf}.\n-\n-The above set is a superset of the restrictions provided by pragma\n-@code{Restricted_Run_Time}, it includes five additional restrictions\n-(@code{Simple_Barriers}, @code{No_Select_Statements},\n-@code{No_Calendar},\n-@code{No_Relative_Delay} and @code{No_Task_Termination}).  This means\n-that pragma @code{Ravenscar}, like the pragma @code{Restricted_Run_Time},\n-automatically causes the use of a simplified, more efficient version\n-of the tasking run-time system.\n-\n @node Pragma Restricted_Run_Time\n @unnumberedsec Pragma Restricted_Run_Time\n @findex Restricted_Run_Time\n@@ -3051,7 +3075,7 @@ A configuration pragma that establishes the following set of restrictions:\n @item No_Task_Allocators\n @item No_Dynamic_Priorities\n @item No_Terminate_Alternatives\n-@item No_Dynamic_Interrupts\n+@item No_Dynamic_Attachment\n @item No_Protected_Type_Allocators\n @item No_Local_Protected_Objects\n @item No_Requeue_Statements\n@@ -5984,8 +6008,8 @@ restrictions to produce a more efficient implementation.\n @end cartouche\n GNAT currently takes advantage of these restrictions by providing an optimized\n run time when the Ravenscar profile and the GNAT restricted run time set\n-of restrictions are specified.  See pragma @code{Ravenscar} and pragma\n-@code{Restricted_Run_Time} for more details.\n+of restrictions are specified.  See pragma @code{Profile (Ravenscar)} and\n+pragma @code{Restricted_Run_Time} for more details.\n \n @cindex Time, monotonic\n @unnumberedsec D.8(47-49): Monotonic Time\n@@ -6855,10 +6879,10 @@ for protected types are restricted to either static boolean expressions or\n references to simple boolean variables defined in the private part of the\n protected type.  No other form of entry barriers is permitted.  This is one\n of the restrictions of the Ravenscar profile for limited tasking (see also\n-pragma @code{Ravenscar}).\n+pragma @code{Profile (Ravenscar)}).\n \n-@item Max_Entry_Queue_Depth => Expr\n-@findex Max_Entry_Queue_Depth\n+@item Max_Entry_Queue_Length => Expr\n+@findex Max_Entry_Queue_Length\n This restriction is a declaration that any protected entry compiled in\n the scope of the restriction has at most the specified number of\n tasks waiting on the entry\n@@ -6879,10 +6903,10 @@ from Boolean). This is intended for use in safety critical programs\n where the certification protocol requires the use of short-circuit\n (and then, or else) forms for all composite boolean operations.\n \n-@item No_Dynamic_Interrupts\n-@findex No_Dynamic_Interrupts\n-This restriction ensures at compile time that there is no attempt to\n-dynamically associate interrupts.  Only static association is allowed.\n+@item No_Dynamic_Attachment\n+@findex No_Dynamic_Attachment\n+This restriction ensures that there is no call to any of the operations\n+defined in package Ada.Interrupts.\n \n @item No_Enumeration_Maps\n @findex No_Enumeration_Maps\n@@ -6978,7 +7002,7 @@ on some targets.\n This restriction ensures at compile time no select statements of any kind\n are permitted, that is the keyword @code{select} may not appear.\n This is one of the restrictions of the Ravenscar\n-profile for limited tasking (see also pragma @code{Ravenscar}).\n+profile for limited tasking (see also pragma @code{Profile (Ravenscar)}).\n \n @item No_Standard_Storage_Pools\n @findex No_Standard_Storage_Pools"}, {"sha": "300e96021281acab1c007864d582e741d559d374", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "patch": "@@ -9995,9 +9995,9 @@ recognized by @code{GNAT}:\n    Long_Float\n    Normalize_Scalars\n    Polling\n+   Profile\n    Propagate_Exceptions\n    Queuing_Policy\n-   Ravenscar\n    Restricted_Run_Time\n    Restrictions\n    Reviewable\n@@ -14647,6 +14647,9 @@ on their effect.\n \n @table @option\n @cindex @option{^-c@var{n}^/COMMENTS_LAYOUT^} (@command{gnatpp})\n+@item ^-c0^/COMMENTS_LAYOUT=UNTOUCHED^\n+All the comments remain unchanged\n+\n @item ^-c1^/COMMENTS_LAYOUT=DEFAULT^\n GNAT-style comment line indentation (this is the default).\n \n@@ -14680,7 +14683,8 @@ stops.\n @noindent\n The @option{-c1} and @option{-c2} switches are incompatible.\n The @option{-c3} and @option{-c4} switches are compatible with each other and\n-also with @option{-c1} and @option{-c2}.\n+also with @option{-c1} and @option{-c2}. The @option{-c0} switch disables all\n+the other comment formatting switches.\n \n The @option{-l1}, @option{-l2}, and @option{-l3} switches are incompatible.\n @end ifclear\n@@ -14827,6 +14831,11 @@ reading or processing the input file.\n @cindex @option{^-rf^/OVERRIDING_REPLACE^} (@code{gnatpp})\n Like @option{^-r^/REPLACE^} except that if the file with the specified name\n already exists, it is overwritten.\n+\n+@item ^-rnb^/NO_BACKUP^\n+@cindex @option{^-rnb^/NO_BACKUP^} (@code{gnatpp})\n+Replace the input source file with the reformatted output without\n+creating any backup copy of the input source.\n @end table\n \n @noindent"}, {"sha": "1de5f4e134ed3585ad483a94d8a191a1db4a5b4d", "filename": "gcc/ada/lang-specs.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flang-specs.h?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "patch": "@@ -32,13 +32,12 @@\n   {\"@ada\",\n    \"\\\n  %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n- %{!gnatc*:%{!gnats*:%{!S:%{!c:\\\n-    %eone of -c, -S, -gnatc or -gnats is required for Ada}}}}\\\n+ %{!S:%{!c:%e-c or -S required for Ada}}\\\n  gnat1 %{I*} %{k8:-gnatk8} %{w:-gnatws} %1 %{!Q:-quiet} %{nostdinc*}\\\n     %{nostdlib*}\\\n     -dumpbase %{.adb:%b.adb}%{.ads:%b.ads}%{!.adb:%{!.ads:%b.ada}}\\\n     %{g*} %{O*} %{W*} %{w} %{p} %{pg:-p} %{m*} %{a} %{f*} %{d*}\\\n     %{!S:%{o*:%w%*-gnatO}} \\\n     %i %{S:%W{o*}%{!o*:-o %b.s}} \\\n-    %{!S:%{gnatc*|gnats*: -o %j}} \\\n+    %{gnatc*|gnats*: -o %j} \\\n     %{!gnatc*:%{!gnats*:%(invoke_as)}}\", 0, 0, 0},"}, {"sha": "1f271e89c21c49459ac1a6efaed41a777e4c0409", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "patch": "@@ -269,6 +269,27 @@ package body Lib.Xref is\n          then\n             null;\n \n+         --  Constant completion does not count as a reference\n+\n+         elsif Typ = 'c'\n+           and then Ekind (E) = E_Constant\n+         then\n+            null;\n+\n+         --  Record representation clause does not count as a reference\n+\n+         elsif Nkind (N) = N_Identifier\n+           and then Nkind (Parent (N)) = N_Record_Representation_Clause\n+         then\n+            null;\n+\n+         --  Discriminants do not need to produce a reference to record type\n+\n+         elsif Typ = 'd'\n+           and then Nkind (Parent (N)) = N_Discriminant_Specification\n+         then\n+            null;\n+\n          --  Any other occurrence counts as referencing the entity\n \n          else"}, {"sha": "720ad257a83b669b04870e1a9324755043a7a337", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "patch": "@@ -147,8 +147,8 @@ package body Rtsfind is\n       Use_Setting : Boolean := False);\n    --  Load the unit whose Id is given if not already loaded. The unit is\n    --  loaded, analyzed, and added to the WITH list, and the entry in\n-   --  RT_Unit_Table is updated to reflect the load. The second parameter\n-   --  indicates the initial setting for the Is_Potentially_Use_Visible\n+   --  RT_Unit_Table is updated to reflect the load. Use_Setting is used\n+   --  to indicate the initial setting for the Is_Potentially_Use_Visible\n    --  flag of the entity for the loaded unit (if it is indeed loaded).\n    --  A value of False means nothing special need be done. A value of\n    --  True indicates that this flag must be set to True. It is needed\n@@ -1052,7 +1052,9 @@ package body Rtsfind is\n \n    function RTU_Loaded (U : RTU_Id) return Boolean is\n    begin\n-      return Present (RT_Unit_Table (U).Entity);\n+      return True and Present (RT_Unit_Table (U).Entity);\n+      --  Temp kludge, return True, deals with bug of loading unit with\n+      --  WITH not being registered as a proper rtsfind load ???\n    end RTU_Loaded;\n \n    --------------------"}, {"sha": "0ec821cceba1b486066554d9b2b04ce89f63c75f", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "patch": "@@ -450,6 +450,13 @@ package Rtsfind is\n      RE_List_Controller,                 -- Ada.Finalization.List_Controller\n \n      RE_Interrupt_ID,                    -- Ada.Interrupts\n+     RE_Is_Reserved,                     -- Ada.Interrupts\n+     RE_Is_Attached,                     -- Ada.Interrupts\n+     RE_Current_Handler,                 -- Ada.Interrupts\n+     RE_Attach_Handler,                  -- Ada.Interrupts\n+     RE_Exchange_Handler,                -- Ada.Interrupts\n+     RE_Detach_Handler,                  -- Ada.Interrupts\n+     RE_Reference,                       -- Ada.Interrupts\n \n      RE_Names,                           -- Ada.Interupts.Names\n \n@@ -1522,6 +1529,13 @@ package Rtsfind is\n      RE_List_Controller                  => Ada_Finalization_List_Controller,\n \n      RE_Interrupt_ID                     => Ada_Interrupts,\n+     RE_Is_Reserved                      => Ada_Interrupts,\n+     RE_Is_Attached                      => Ada_Interrupts,\n+     RE_Current_Handler                  => Ada_Interrupts,\n+     RE_Attach_Handler                   => Ada_Interrupts,\n+     RE_Exchange_Handler                 => Ada_Interrupts,\n+     RE_Detach_Handler                   => Ada_Interrupts,\n+     RE_Reference                        => Ada_Interrupts,\n \n      RE_Names                            => Ada_Interrupts_Names,\n "}, {"sha": "5210c9eee7ac6363807bd15690387a02f12da7b9", "filename": "gcc/ada/s-interr.adb", "status": "modified", "additions": 79, "deletions": 72, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fs-interr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fs-interr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr.adb?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "patch": "@@ -305,17 +305,16 @@ package body System.Interrupts is\n    -- Bind_Interrupt_To_Entry --\n    -----------------------------\n \n-   --  This procedure raises a Program_Error if it tries to\n-   --  bind an interrupt to which an Entry or a Procedure is\n-   --  already bound.\n+   --  This procedure raises a Program_Error if it tries to bind an\n+   --  interrupt to which an Entry or a Procedure is already bound.\n \n    procedure Bind_Interrupt_To_Entry\n      (T       : Task_Id;\n       E       : Task_Entry_Index;\n       Int_Ref : System.Address)\n    is\n       Interrupt   : constant Interrupt_ID :=\n-        Interrupt_ID (Storage_Elements.To_Integer (Int_Ref));\n+                      Interrupt_ID (Storage_Elements.To_Integer (Int_Ref));\n \n    begin\n       if Is_Reserved (Interrupt) then\n@@ -324,7 +323,6 @@ package body System.Interrupts is\n       end if;\n \n       Interrupt_Manager.Bind_Interrupt_To_Entry (T, E, Interrupt);\n-\n    end Bind_Interrupt_To_Entry;\n \n    ---------------------\n@@ -383,7 +381,6 @@ package body System.Interrupts is\n       end if;\n \n       Interrupt_Manager.Detach_Handler (Interrupt, Static);\n-\n    end Detach_Handler;\n \n    ------------------------------\n@@ -404,8 +401,8 @@ package body System.Interrupts is\n    --  previous handler's binding status (ie. do not care if it is a\n    --  dynamic or static handler).\n \n-   --  This option is needed so that during the finalization of a PO, we\n-   --  can detach handlers attached through pragma Attach_Handler.\n+   --  This option is needed so that during the finalization of a PO,\n+   --  we can detach handlers attached through pragma Attach_Handler.\n \n    procedure Exchange_Handler\n      (Old_Handler : out Parameterless_Handler;\n@@ -421,12 +418,11 @@ package body System.Interrupts is\n \n       Interrupt_Manager.Exchange_Handler\n         (Old_Handler, New_Handler, Interrupt, Static);\n-\n    end Exchange_Handler;\n \n-   ----------------\n-   --  Finalize  --\n-   ----------------\n+   --------------\n+   -- Finalize --\n+   --------------\n \n    procedure Finalize (Object : in out Static_Interrupt_Protection) is\n    begin\n@@ -451,7 +447,7 @@ package body System.Interrupts is\n    -- Has_Interrupt_Or_Attach_Handler --\n    -------------------------------------\n \n-   --  Need comments as to why these always return True\n+   --  Need comments as to why these always return True ???\n \n    function Has_Interrupt_Or_Attach_Handler\n      (Object : access Dynamic_Interrupt_Protection) return Boolean\n@@ -602,7 +598,6 @@ package body System.Interrupts is\n       end loop;\n \n       return False;\n-\n    end Is_Registered;\n \n    -----------------\n@@ -804,7 +799,6 @@ package body System.Interrupts is\n          else\n             IMOP.Install_Default_Action (IMNG.Interrupt_ID (Interrupt));\n          end if;\n-\n       end Unbind_Handler;\n \n       --------------------------------\n@@ -832,6 +826,7 @@ package body System.Interrupts is\n          --  status of the current_Handler.\n \n          if not Static and then User_Handler (Interrupt).Static then\n+\n             --  Tries to detach a static Interrupt Handler.\n             --  raise a program error.\n \n@@ -854,7 +849,6 @@ package body System.Interrupts is\n          if Old_Handler /= null then\n             Unbind_Handler (Interrupt);\n          end if;\n-\n       end Unprotected_Detach_Handler;\n \n       ----------------------------------\n@@ -866,7 +860,8 @@ package body System.Interrupts is\n          New_Handler : Parameterless_Handler;\n          Interrupt   : Interrupt_ID;\n          Static      : Boolean;\n-         Restoration : Boolean := False) is\n+         Restoration : Boolean := False)\n+      is\n       begin\n          if User_Entry (Interrupt).T /= Null_Task then\n \n@@ -951,7 +946,6 @@ package body System.Interrupts is\n          if Old_Handler = null then\n             Bind_Handler (Interrupt);\n          end if;\n-\n       end Unprotected_Exchange_Handler;\n \n    --  Start of processing for Interrupt_Manager\n@@ -1081,6 +1075,7 @@ package body System.Interrupts is\n                   --  Place Task_Id info in Server_ID array.\n \n                   if Server_ID (Interrupt) = Null_Task then\n+\n                      --  When a new Server_Task is created, it should have its\n                      --  signal mask set to the All_Tasks_Mask.\n \n@@ -1100,6 +1095,7 @@ package body System.Interrupts is\n                   for J in Interrupt_ID'Range loop\n                      if not Is_Reserved (J) then\n                         if User_Entry (J).T = T then\n+\n                            --  The interrupt should no longer be ingnored if\n                            --  it was ever ignored.\n \n@@ -1111,7 +1107,7 @@ package body System.Interrupts is\n                      end if;\n                   end loop;\n \n-                  --  Indicate in ATCB that no Interrupt Entries are attached.\n+                  --  Indicate in ATCB that no Interrupt Entries are attached\n \n                   T.Interrupt_Entry := False;\n                end Detach_Interrupt_Entries;\n@@ -1133,10 +1129,10 @@ package body System.Interrupts is\n                   if User_Handler (Interrupt).H /= null\n                     or else  User_Entry (Interrupt).T /= Null_Task\n                   then\n-                     --  This is the case where the Server_Task is waiting on\n-                     --  \"sigwait.\" Wake it up by sending an\n-                     --  Abort_Task_Interrupt so that the Server_Task waits on\n-                     --  Cond.\n+                     --  This is the case where the Server_Task is waiting\n+                     --  on \"sigwait.\" Wake it up by sending an\n+                     --  Abort_Task_Interrupt so that the Server_Task\n+                     --  waits on Cond.\n \n                      POP.Abort_Task (Server_ID (Interrupt));\n \n@@ -1166,6 +1162,7 @@ package body System.Interrupts is\n                   then\n                      --  No handler is attached. Unmask the Interrupt so that\n                      --  the default action can be carried out.\n+\n                      IMOP.Thread_Unblock_Interrupt\n                        (IMNG.Interrupt_ID (Interrupt));\n \n@@ -1174,6 +1171,7 @@ package body System.Interrupts is\n                      --  since it was being blocked and an Interrupt Hander or\n                      --  an Entry was there. Wake it up and let it change\n                      --  it place of waiting according to its new state.\n+\n                      POP.Wakeup (Server_ID (Interrupt),\n                        Interrupt_Server_Blocked_Interrupt_Sleep);\n                   end if;\n@@ -1356,69 +1354,78 @@ package body System.Interrupts is\n                POP.Write_Lock (Self_ID);\n \n             else\n-               pragma Assert (Ret_Interrupt = Interrupt);\n-\n                if Single_Lock then\n                   POP.Lock_RTS;\n                end if;\n \n                POP.Write_Lock (Self_ID);\n \n-               --  Even though we have received an Interrupt the status may\n-               --  have changed already before we got the Self_ID lock above.\n-               --  Therefore we make sure a Handler or an Entry is still\n-               --  there and make appropriate call.\n-               --  If there is no calls to make we need to regenerate the\n-               --  Interrupt in order not to lose it.\n+               if Ret_Interrupt /= Interrupt then\n \n-               if User_Handler (Interrupt).H /= null then\n-                  Tmp_Handler := User_Handler (Interrupt).H;\n+                  --  On some systems (e.g. recent linux kernels), sigwait\n+                  --  may return unexpectedly (with errno set to EINTR).\n \n-                  --  RTS calls should not be made with self being locked.\n+                  null;\n \n-                  POP.Unlock (Self_ID);\n+               else\n+                  --  Even though we have received an Interrupt the status may\n+                  --  have changed already before we got the Self_ID lock above\n+                  --  Therefore we make sure a Handler or an Entry is still\n+                  --  there and make appropriate call.\n \n-                  if Single_Lock then\n-                     POP.Unlock_RTS;\n-                  end if;\n+                  --  If there is no calls to make we need to regenerate the\n+                  --  Interrupt in order not to lose it.\n \n-                  Tmp_Handler.all;\n+                  if User_Handler (Interrupt).H /= null then\n+                     Tmp_Handler := User_Handler (Interrupt).H;\n \n-                  if Single_Lock then\n-                     POP.Lock_RTS;\n-                  end if;\n+                     --  RTS calls should not be made with self being locked.\n \n-                  POP.Write_Lock (Self_ID);\n+                     POP.Unlock (Self_ID);\n \n-               elsif User_Entry (Interrupt).T /= Null_Task then\n-                  Tmp_ID := User_Entry (Interrupt).T;\n-                  Tmp_Entry_Index := User_Entry (Interrupt).E;\n+                     if Single_Lock then\n+                        POP.Unlock_RTS;\n+                     end if;\n \n-                  --  RTS calls should not be made with self being locked.\n+                     Tmp_Handler.all;\n \n-                  if Single_Lock then\n-                     POP.Unlock_RTS;\n-                  end if;\n+                     if Single_Lock then\n+                        POP.Lock_RTS;\n+                     end if;\n \n-                  POP.Unlock (Self_ID);\n+                     POP.Write_Lock (Self_ID);\n \n-                  System.Tasking.Rendezvous.Call_Simple\n-                    (Tmp_ID, Tmp_Entry_Index, System.Null_Address);\n+                  elsif User_Entry (Interrupt).T /= Null_Task then\n+                     Tmp_ID := User_Entry (Interrupt).T;\n+                     Tmp_Entry_Index := User_Entry (Interrupt).E;\n \n-                  POP.Write_Lock (Self_ID);\n+                     --  RTS calls should not be made with self being locked.\n \n-                  if Single_Lock then\n-                     POP.Lock_RTS;\n-                  end if;\n+                     if Single_Lock then\n+                        POP.Unlock_RTS;\n+                     end if;\n \n-               else\n-                  --  This is a situation that this task wake up\n-                  --  receiving an Interrupt and before it get the lock\n-                  --  the Interrupt is blocked. We do not\n-                  --  want to lose the interrupt in this case so that\n-                  --  regenerate the Interrupt to process level;\n+                     POP.Unlock (Self_ID);\n+\n+                     System.Tasking.Rendezvous.Call_Simple\n+                       (Tmp_ID, Tmp_Entry_Index, System.Null_Address);\n \n-                  IMOP.Interrupt_Self_Process (IMNG.Interrupt_ID (Interrupt));\n+                     POP.Write_Lock (Self_ID);\n+\n+                     if Single_Lock then\n+                        POP.Lock_RTS;\n+                     end if;\n+\n+                  else\n+                     --  This is a situation that this task wakes up receiving\n+                     --  an Interrupt and before it gets the lock the Interrupt\n+                     --  is blocked. We do not want to lose the interrupt in\n+                     --  this case so we regenerate the Interrupt to process\n+                     --  level.\n+\n+                     IMOP.Interrupt_Self_Process\n+                       (IMNG.Interrupt_ID (Interrupt));\n+                  end if;\n                end if;\n             end if;\n          end if;\n@@ -1433,30 +1440,30 @@ package body System.Interrupts is\n \n          --  Undefer abort here to allow a window for this task\n          --  to be aborted  at the time of system shutdown.\n+\n       end loop;\n    end Server_Task;\n \n --  Elaboration code for package System.Interrupts\n \n begin\n-\n    --  Get Interrupt_Manager's ID so that Abort_Interrupt can be sent.\n \n    Interrupt_Manager_ID := To_System (Interrupt_Manager'Identity);\n \n-   --  During the elaboration of this package body we want RTS to\n-   --  inherit the interrupt mask from the Environment Task.\n+   --  During the elaboration of this package body we want the RTS\n+   --  to inherit the interrupt mask from the Environment Task.\n \n-   --  The Environment Task should have gotten its mask from\n+   --  The environment task should have gotten its mask from\n    --  the enclosing process during the RTS start up. (See\n-   --  in s-inmaop.adb). Pass the Interrupt_Mask of the Environment\n-   --  task to the Interrupt_Manager.\n+   --  processing in s-inmaop.adb). Pass the Interrupt_Mask\n+   --  of the environment task to the Interrupt_Manager.\n \n    --  Note : At this point we know that all tasks (including\n    --  RTS internal servers) are masked for non-reserved signals\n    --  (see s-taprop.adb). Only the Interrupt_Manager will have\n-   --  masks set up differently inheriting the original Environment\n-   --  Task's mask.\n+   --  masks set up differently inheriting the original environment\n+   --  task's mask.\n \n    Interrupt_Manager.Initialize (IMOP.Environment_Mask);\n end System.Interrupts;"}, {"sha": "1524cbf97e64064980bf7944f1dfd3b7b642c794", "filename": "gcc/ada/sem.ads", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fsem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fsem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.ads?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -347,20 +347,22 @@ package Sem is\n    -- Handling of Check Suppression --\n    -----------------------------------\n \n-   --  There are two kinds of suppress checks, scope based suppress checks\n-   --  (from initial command line arguments, or from Suppress pragmas not\n-   --  including an entity name). The scope based suppress checks are recorded\n+   --  There are two kinds of suppress checks: scope based suppress checks,\n+   --  and entity based suppress checks.\n+\n+   --  Scope based suppress chems (from initial command line arguments,\n+   --  or from Suppress pragmas not including an entity name) are recorded\n    --  in the Sem.Supress variable, and all that is necessary is to save the\n    --  state of this variable on scope entry, and restore it on scope exit.\n \n-   --  The other kind of suppress check is entity based suppress checks, from\n-   --  Suppress pragmas giving an Entity_Id. These are handled as follows. If\n-   --  a suppress or unsuppress pragma is encountered for a given entity, then\n-   --  the flag Checks_May_Be_Suppressed is set in the entity and an entry is\n-   --  made in either the Local_Entity_Suppress table (case of pragma that\n-   --  appears in other than a package spec), or in the Global_Entity_Suppress\n-   --  table (case of pragma that appears in a package spec, which is by the\n-   --  rule of RM 11.5(7) applicable throughout the life of the entity).\n+   --  Entity based suppress checks, from Suppress pragmas giving an Entity_Id,\n+   --  are handled as follows. If a suppress or unsuppress pragma is\n+   --  encountered for a given entity, then the flag Checks_May_Be_Suppressed\n+   --  is set in the entity and an entry is made in either the\n+   --  Local_Entity_Suppress table (case of pragma that appears in other than\n+   --  a package spec), or in the Global_Entity_Suppress table (case of pragma\n+   --  that appears in a package spec, which is by the rule of RM 11.5(7)\n+   --  applicable throughout the life of the entity).\n \n    --  If the Checks_May_Be_Suppressed flag is set in an entity then the\n    --  procedure is to search first the local and then the global suppress"}, {"sha": "6d4e25d2d7fccf92b4950ca852e04f15209fc561", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 66, "deletions": 18, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "patch": "@@ -3636,12 +3636,17 @@ package body Sem_Ch12 is\n       --  Common error routine for mismatch between the parameters of\n       --  the actual instance and those of the formal package.\n \n-      function Same_Instantiated_Entity (E1, E2 : Entity_Id) return Boolean;\n+      function Same_Instantiated_Constant (E1, E2 : Entity_Id) return Boolean;\n       --  The formal may come from a nested formal package, and the actual\n       --  may have been constant-folded. To determine whether the two denote\n       --  the same entity we may have to traverse several definitions to\n       --  recover the ultimate entity that they refer to.\n \n+      function Same_Instantiated_Variable (E1, E2 : Entity_Id) return Boolean;\n+      --  Similarly, if the formal comes from a nested formal package, the\n+      --  actual may designate the formal through multiple renamings, which\n+      --  have to be followed to determine the original variable in question.\n+\n       --------------------\n       -- Check_Mismatch --\n       --------------------\n@@ -3655,13 +3660,14 @@ package body Sem_Ch12 is\n          end if;\n       end Check_Mismatch;\n \n-      ------------------------------\n-      -- Same_Instantiated_Entity --\n-      ------------------------------\n+      --------------------------------\n+      -- Same_Instantiated_Constant --\n+      --------------------------------\n \n-      function Same_Instantiated_Entity (E1, E2 : Entity_Id) return Boolean is\n+      function Same_Instantiated_Constant\n+        (E1, E2 : Entity_Id) return Boolean\n+      is\n          Ent : Entity_Id;\n-\n       begin\n          Ent := E2;\n          while Present (Ent) loop\n@@ -3689,7 +3695,43 @@ package body Sem_Ch12 is\n          end loop;\n \n          return False;\n-      end Same_Instantiated_Entity;\n+      end Same_Instantiated_Constant;\n+\n+      --------------------------------\n+      -- Same_Instantiated_Variable --\n+      --------------------------------\n+\n+      function Same_Instantiated_Variable\n+        (E1, E2 : Entity_Id) return Boolean\n+      is\n+         function Original_Entity (E : Entity_Id) return Entity_Id;\n+         --  Follow chain of renamings to the ultimate ancestor.\n+\n+         ---------------------\n+         -- Original_Entity --\n+         ---------------------\n+\n+         function Original_Entity (E : Entity_Id) return Entity_Id is\n+            Orig : Entity_Id;\n+\n+         begin\n+            Orig := E;\n+            while Nkind (Parent (Orig)) = N_Object_Renaming_Declaration\n+              and then Present (Renamed_Object (Orig))\n+              and then Is_Entity_Name (Renamed_Object (Orig))\n+            loop\n+               Orig := Entity (Renamed_Object (Orig));\n+            end loop;\n+\n+            return Orig;\n+         end Original_Entity;\n+\n+      --  Start of processing for Same_Instantiated_Variable\n+\n+      begin\n+         return Ekind (E1) = Ekind (E2)\n+           and then Original_Entity (E1) = Original_Entity (E2);\n+      end Same_Instantiated_Variable;\n \n    --  Start of processing for Check_Formal_Package_Instance\n \n@@ -3768,13 +3810,10 @@ package body Sem_Ch12 is\n                if Is_Entity_Name (Expr2) then\n                   if Entity (Expr1) = Entity (Expr2) then\n                      null;\n-\n-                  elsif\n-                    Same_Instantiated_Entity (Entity (Expr1), Entity (Expr2))\n-                  then\n-                     null;\n                   else\n-                     Check_Mismatch (True);\n+                     Check_Mismatch\n+                       (not Same_Instantiated_Constant\n+                         (Entity (Expr1), Entity (Expr2)));\n                   end if;\n                else\n                   Check_Mismatch (True);\n@@ -3783,7 +3822,7 @@ package body Sem_Ch12 is\n             elsif Is_Entity_Name (Original_Node (Expr1))\n               and then Is_Entity_Name (Expr2)\n             and then\n-              Same_Instantiated_Entity\n+              Same_Instantiated_Constant\n                 (Entity (Original_Node (Expr1)), Entity (Expr2))\n             then\n                null;\n@@ -3795,9 +3834,10 @@ package body Sem_Ch12 is\n                Check_Mismatch (True);\n             end if;\n \n-         elsif Ekind (E1) = E_Variable\n-           or else Ekind (E1) = E_Package\n-         then\n+         elsif Ekind (E1) = E_Variable then\n+            Check_Mismatch (not Same_Instantiated_Variable (E1, E2));\n+\n+         elsif Ekind (E1) = E_Package then\n             Check_Mismatch\n               (Ekind (E1) /= Ekind (E2)\n                 or else Renamed_Object (E1) /= Renamed_Object (E2));\n@@ -7350,7 +7390,15 @@ package body Sem_Ch12 is\n          if Nkind (Gen_Body) = N_Subprogram_Body_Stub then\n \n             --  Either body is not present, or context is non-expanding, as\n-            --  when compiling a subunit. Mark the instance as completed.\n+            --  when compiling a subunit. Mark the instance as completed, and\n+            --  diagnose a missing body when needed.\n+\n+            if Expander_Active\n+              and then Operating_Mode = Generate_Code\n+            then\n+               Error_Msg_N\n+                 (\"missing proper body for instantiation\", Gen_Body);\n+            end if;\n \n             Set_Has_Completion (Anon_Id);\n             return;"}, {"sha": "48169d94f12dc5be3d13cbc2d8cf0842c90a5719", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "patch": "@@ -4361,6 +4361,7 @@ package body Sem_Ch4 is\n       --  truly hidden.\n \n       type Operand_Position is (First_Op, Second_Op);\n+      Univ_Type : constant Entity_Id := Universal_Interpretation (N);\n \n       procedure Remove_Address_Interpretations (Op : Operand_Position);\n       --  Ambiguities may arise when the operands are literal and the\n@@ -4451,6 +4452,25 @@ package body Sem_Ch4 is\n                            Remove_Interp (I);\n                         end if;\n \n+                        Get_Next_Interp (I, It);\n+                     end loop;\n+\n+                  elsif Is_Overloaded (N)\n+                    and then Present (Univ_Type)\n+                  then\n+                     --  If both operands have a universal interpretation,\n+                     --  select the predefined operator and discard others.\n+\n+                     Get_First_Interp (N, I, It);\n+\n+                     while Present (It.Nam) loop\n+                        if Scope (It.Nam) = Standard_Standard then\n+                           Set_Etype (N, Univ_Type);\n+                           Set_Entity (N, It.Nam);\n+                           Set_Is_Overloaded (N, False);\n+                           exit;\n+                        end if;\n+\n                         Get_Next_Interp (I, It);\n                      end loop;\n                   end if;"}, {"sha": "a48a6ca0479fabaec4ab5d348707d7f1559399e9", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 79, "deletions": 8, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "patch": "@@ -561,6 +561,12 @@ package body Sem_Prag is\n       --  argument has the right form then the Mechanism field of Ent is\n       --  set appropriately.\n \n+      procedure Set_Ravenscar_Profile (N : Node_Id);\n+      --  Activate the set of configuration pragmas and restrictions that\n+      --  make up the Ravenscar Profile. N is the corresponding pragma\n+      --  node, which is used for error messages on any constructs\n+      --  that violate the profile.\n+\n       --------------------------\n       -- Check_Ada_83_Warning --\n       --------------------------\n@@ -3257,17 +3263,17 @@ package body Sem_Prag is\n          Val   : Uint;\n \n          procedure Set_Warning (R : All_Restrictions);\n-         --  If this is a Restriction_Warnings pragma, set warning flag,\n-         --  otherwise flag gets cleared.\n+         --  If this is a Restriction_Warnings pragma, set warning flag\n \n          -----------------\n          -- Set_Warning --\n          -----------------\n \n          procedure Set_Warning (R : All_Restrictions) is\n          begin\n-            Restriction_Warnings (R) :=\n-              Prag_Id = Pragma_Restriction_Warnings;\n+            if Prag_Id = Pragma_Restriction_Warnings then\n+               Restriction_Warnings (R) := True;\n+            end if;\n          end Set_Warning;\n \n       --  Start of processing for Process_Restrictions_Or_Restriction_Warnings\n@@ -3821,6 +3827,70 @@ package body Sem_Prag is\n \n       end Set_Mechanism_Value;\n \n+      ---------------------------\n+      -- Set_Ravenscar_Profile --\n+      ---------------------------\n+\n+      --  The tasks to be done here are\n+\n+      --    Set required policies\n+\n+      --      pragma Task_Dispatching_Policy (FIFO_Within_Priorities)\n+      --      pragma Locking_Policy (Ceiling_Locking)\n+\n+      --    Set Detect_Blocking mode ???\n+\n+      --    Set required restrictions (see Restrict.Set_Ravenscar for details)\n+\n+      procedure Set_Ravenscar_Profile (N : Node_Id) is\n+      begin\n+         --  pragma Task_Dispatching_Policy (FIFO_Within_Priorities)\n+\n+         if Task_Dispatching_Policy /= ' '\n+           and then Task_Dispatching_Policy /= 'F'\n+         then\n+            Error_Msg_Sloc := Task_Dispatching_Policy_Sloc;\n+            Error_Pragma (\"Profile (Ravenscar) incompatible with policy#\");\n+\n+         --  Set the FIFO_Within_Priorities policy, but always\n+         --  preserve System_Location since we like the error\n+         --  message with the run time name.\n+\n+         else\n+            Task_Dispatching_Policy := 'F';\n+\n+            if Task_Dispatching_Policy_Sloc /= System_Location then\n+               Task_Dispatching_Policy_Sloc := Loc;\n+            end if;\n+         end if;\n+\n+         --  pragma Locking_Policy (Ceiling_Locking)\n+\n+         if Locking_Policy /= ' '\n+           and then Locking_Policy /= 'C'\n+         then\n+            Error_Msg_Sloc := Locking_Policy_Sloc;\n+            Error_Pragma (\"Profile (Ravenscar) incompatible with policy#\");\n+\n+         --  Set the Ceiling_Locking policy, but always preserve\n+         --  System_Location since we like the error message with the\n+         --  run time name.\n+\n+         else\n+            Locking_Policy := 'C';\n+\n+            if Locking_Policy_Sloc /= System_Location then\n+               Locking_Policy_Sloc := Loc;\n+            end if;\n+         end if;\n+\n+         --  ??? Detect_Blocking\n+\n+         --  Set the corresponding restrictions\n+\n+         Set_Ravenscar (N);\n+      end Set_Ravenscar_Profile;\n+\n    --  Start of processing for Analyze_Pragma\n \n    begin\n@@ -8005,13 +8075,12 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n             Check_Valid_Configuration_Pragma;\n             Check_No_Identifiers;\n-            Set_Ravenscar (N);\n \n             declare\n                Argx : constant Node_Id := Get_Pragma_Arg (Arg1);\n             begin\n                if Chars (Argx) = Name_Ravenscar then\n-                  Set_Ravenscar (N);\n+                  Set_Ravenscar_Profile (N);\n                else\n                   Error_Pragma_Arg (\"& is not a valid profile\", Argx);\n                end if;\n@@ -8481,7 +8550,7 @@ package body Sem_Prag is\n             GNAT_Pragma;\n             Check_Arg_Count (0);\n             Check_Valid_Configuration_Pragma;\n-            Set_Ravenscar (N);\n+            Set_Ravenscar_Profile (N);\n \n          -------------------------\n          -- Restricted_Run_Time --\n@@ -9950,6 +10019,7 @@ package body Sem_Prag is\n    --  Start of prorcessing for Is_Config_Static_String\n \n    begin\n+\n       Name_Len := 0;\n       return Add_Config_Static_String (Arg);\n    end Is_Config_Static_String;\n@@ -9965,6 +10035,7 @@ package body Sem_Prag is\n    --  indicates that appearence in that parameter position is significant.\n \n    Sig_Flags : constant array (Pragma_Id) of Int :=\n+\n      (Pragma_AST_Entry                    => -1,\n       Pragma_Abort_Defer                  => -1,\n       Pragma_Ada_83                       => -1,\n@@ -10095,7 +10166,7 @@ package body Sem_Prag is\n       Pragma_Thread_Body                  => +2,\n       Pragma_Time_Slice                   => -1,\n       Pragma_Title                        => -1,\n-      Pragma_Unchecked_Union              => -1,\n+      Pragma_Unchecked_Union              =>  0,\n       Pragma_Unimplemented_Unit           => -1,\n       Pragma_Universal_Data               => -1,\n       Pragma_Unreferenced                 => -1,"}, {"sha": "446a834bed518787635b27f4eebf96f0226e71a1", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "patch": "@@ -3456,7 +3456,9 @@ package body Sem_Util is\n \n             --  Done if no more derivations to check\n \n-            elsif T = T1 then\n+            elsif T = T1\n+              or else T = Etyp\n+            then\n                return False;\n \n             --  Following test catches error cases resulting from prev errors\n@@ -3471,11 +3473,7 @@ package body Sem_Util is\n                return False;\n             end if;\n \n-            --  Return if no further entries to check\n-\n-            if T = Base_Type (T1) or else T = T1 then\n-               return False;\n-            end if;\n+            T := Base_Type (Etyp);\n          end loop;\n       end if;\n \n@@ -3927,7 +3925,9 @@ package body Sem_Util is\n                return Attribute_Name (N) = Name_Input;\n \n             when N_Selected_Component =>\n-               return Is_Object_Reference (Selector_Name (N));\n+               return\n+                 Is_Object_Reference (Selector_Name (N))\n+                   and then Is_Object_Reference (Prefix (N));\n \n             when N_Explicit_Dereference =>\n                return True;"}, {"sha": "c623e42b383a7a1dfff1a5384752791e0e007805", "filename": "gcc/ada/symbols-vms-alpha.adb", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fsymbols-vms-alpha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fsymbols-vms-alpha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsymbols-vms-alpha.adb?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "previous_filename": "gcc/ada/symbols-vms.adb"}, {"sha": "df0211d226b765d90eb61f0d41c87f8819336351", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a36a0ccd84d73e8bfb5989be1510536b73b9df9/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=8a36a0ccd84d73e8bfb5989be1510536b73b9df9", "patch": "@@ -4246,6 +4246,8 @@ package VMS_Data is\n    --      UPPER_CASE\n \n    S_Pretty_Comments  : aliased constant S := \"/COMMENTS_LAYOUT=\"          &\n+                                              \"UNTOUCHED \"                 &\n+                                                 \"-c0 \"                    &\n                                               \"DEFAULT \"                   &\n                                                  \"-c1 \"                    &\n                                               \"STANDARD_INDENT \"           &\n@@ -4256,17 +4258,20 @@ package VMS_Data is\n                                                  \"-c4\";\n    --        /COMMENTS_LAYOUT[=layout-option, layout-option, ...]\n    --\n-   --   Set the comment layout. By default, comments use the GNAT style comment\n-   --   line indentation.\n-   --   layout-option may be one of the following:\n+   --   Set the comment layout. By default, comments use the GNAT style\n+   --   comment line indentation.\n    --\n+   --   layout-option is be one of the following:\n+   --\n+   --     UNTOUCHED\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd All the comments remain unchanged\n    --     DEFAULT (D)         GNAT style comment line indentation\n    --     STANDARD_INDENT     Standard comment line indentation\n    --     GNAT_BEGINNING      GNAT style comment beginning\n    --     REFORMAT            Reformat comment blocks\n    --\n    --     All combinations of layout options are allowed, except for DEFAULT\n-   --     and STANDARD_INDENT which are mutually exclusive.\n+   --     and STANDARD_INDENT which are mutually exclusive, and also if\n+   --     UNTOUCHED is specified, this must be the only option.\n    --\n    --     The difference between \"GNAT style comment line indentation\" and\n    --     \"standard comment line indentation\" is the following: for standard\n@@ -4492,6 +4497,13 @@ package VMS_Data is\n    --\n    --      MIXED_CASE        Names are in mixed case.\n \n+   S_Pretty_No_Backup : aliased constant S := \"/NO_BACKUP \"               &\n+                                                 \"-rnb\";\n+   --        /REPLACE_NO_BACKUP\n+   --\n+   --   Replace the argument source with the pretty-printed source without\n+   --   creating any backup copy of the argument source.\n+\n    S_Pretty_No_Labels : aliased constant S := \"/NO_MISSED_LABELS \"         &\n                                                  \"-e\";\n    --        /NO_MISSED_LABELS\n@@ -4533,17 +4545,18 @@ package VMS_Data is\n                                               \"LOWER_CASE \"                &\n                                                  \"-pL \"                    &\n                                               \"UPPER_CASE \"                &\n-      --        /PRAGMA_CASING[=pragma-option]\n+                                                 \"-pU\";\n+   --        /PRAGMA_CASING[=pragma-option]\n    --\n    --   Set the case of pragma identifiers. The default is Mixed case.\n    --   pragma-option may be one of the following:\n    --\n    --      MIXED_CASE (D)\n    --      LOWER_CASE\n    --      UPPER_CASE\n-                                              \"-pU\";\n-   S_Pretty_Project   : aliased constant S := \"/PROJECT_FILE=<\"               &\n-                                            \"-P>\";\n+\n+   S_Pretty_Project   : aliased constant S := \"/PROJECT_FILE=<\"            &\n+                                                \"-P>\";\n    --        /PROJECT_FILE=filename\n    --\n    --   Specifies the main project file to be used. The project files rooted\n@@ -4621,6 +4634,7 @@ package VMS_Data is\n       S_Pretty_Maxind    'Access,\n       S_Pretty_Mess      'Access,\n       S_Pretty_Names     'Access,\n+      S_Pretty_No_Backup 'Access,\n       S_Pretty_No_Labels 'Access,\n       S_Pretty_Notabs    'Access,\n       S_Pretty_Output    'Access,"}]}