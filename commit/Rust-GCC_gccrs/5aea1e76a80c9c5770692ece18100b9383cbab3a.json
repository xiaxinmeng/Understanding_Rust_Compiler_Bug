{"sha": "5aea1e76a80c9c5770692ece18100b9383cbab3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFlYTFlNzZhODBjOWM1NzcwNjkyZWNlMTgxMDBiOTM4M2NiYWIzYQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "ulrich.weigand@linaro.org", "date": "2012-07-30T14:39:32Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2012-07-30T14:39:32Z"}, "message": "target.def (vector_alignment): New target hook.\n\nChangeLog:\n\n\t* target.def (vector_alignment): New target hook.\n\t* doc/tm.texi.in (TARGET_VECTOR_ALIGNMENT): Document new hook.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.c (default_vector_alignment): New function.\n\t* targhooks.h (default_vector_alignment): Add prototype.\n\t* stor-layout.c (layout_type): Use targetm.vector_alignment.\n\t* config/arm/arm.c (arm_vector_alignment): New function.\n\t(TARGET_VECTOR_ALIGNMENT): Define.\n\n\t* tree-vect-data-refs.c (vect_update_misalignment_for_peel): Use\n\tvector type alignment instead of size.\n\t* tree-vect-loop-manip.c (vect_do_peeling_for_loop_bound): Use\n\telement type size directly instead of computing it from alignment.\n\tFix variable naming and comment.\n\ntestsuite/ChangeLog:\n\n\t* lib/target-supports.exp\n\t(check_effective_target_vect_natural_alignment): New function.\n\t* gcc.dg/align-2.c: Only run on targets with natural alignment\n\tof vector types.\n\t* gcc.dg/vect/slp-25.c: Adjust tests for targets without natural\n\talignment of vector types.\n\nCo-Authored-By: Richard Earnshaw <rearnsha@arm.com>\n\nFrom-SVN: r189974", "tree": {"sha": "dc5799dbc1af4d3d79e2dbe5b4f3915b5afa6052", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc5799dbc1af4d3d79e2dbe5b4f3915b5afa6052"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5aea1e76a80c9c5770692ece18100b9383cbab3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aea1e76a80c9c5770692ece18100b9383cbab3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5aea1e76a80c9c5770692ece18100b9383cbab3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aea1e76a80c9c5770692ece18100b9383cbab3a/comments", "author": null, "committer": null, "parents": [{"sha": "4c340b5dfa736102f1fc50f3a4f2ba685708c7ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c340b5dfa736102f1fc50f3a4f2ba685708c7ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c340b5dfa736102f1fc50f3a4f2ba685708c7ff"}], "stats": {"total": 125, "additions": 113, "deletions": 12}, "files": [{"sha": "2b5385f4e5240d4cd70b1f54dcaca1595166e1e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5aea1e76a80c9c5770692ece18100b9383cbab3a", "patch": "@@ -1,3 +1,21 @@\n+2012-07-30  Ulrich Weigand  <ulrich.weigand@linaro.org>\n+\t    Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* target.def (vector_alignment): New target hook.\n+\t* doc/tm.texi.in (TARGET_VECTOR_ALIGNMENT): Document new hook.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.c (default_vector_alignment): New function.\n+\t* targhooks.h (default_vector_alignment): Add prototype.\n+\t* stor-layout.c (layout_type): Use targetm.vector_alignment.\n+\t* config/arm/arm.c (arm_vector_alignment): New function.\n+\t(TARGET_VECTOR_ALIGNMENT): Define.\n+\n+\t* tree-vect-data-refs.c (vect_update_misalignment_for_peel): Use\n+\tvector type alignment instead of size.\n+\t* tree-vect-loop-manip.c (vect_do_peeling_for_loop_bound): Use\n+\telement type size directly instead of computing it from alignment.\n+\tFix variable naming and comment.\n+\n 2012-07-30  Kirill Yukhin  <kirill.yukhin@intel.com>\n \t    Michael Zolotukhin  <michael.v.zolotukhin@intel.com>\n "}, {"sha": "701ab4cfe2d9540798e430377cf8de2f5beb3ccb", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5aea1e76a80c9c5770692ece18100b9383cbab3a", "patch": "@@ -255,6 +255,7 @@ static bool arm_array_mode_supported_p (enum machine_mode,\n \t\t\t\t\tunsigned HOST_WIDE_INT);\n static enum machine_mode arm_preferred_simd_mode (enum machine_mode);\n static bool arm_class_likely_spilled_p (reg_class_t);\n+static HOST_WIDE_INT arm_vector_alignment (const_tree type);\n static bool arm_vector_alignment_reachable (const_tree type, bool is_packed);\n static bool arm_builtin_support_vector_misalignment (enum machine_mode mode,\n \t\t\t\t\t\t     const_tree type,\n@@ -606,6 +607,9 @@ static const struct attribute_spec arm_attribute_table[] =\n #undef TARGET_CLASS_LIKELY_SPILLED_P\n #define TARGET_CLASS_LIKELY_SPILLED_P arm_class_likely_spilled_p\n \n+#undef TARGET_VECTOR_ALIGNMENT\n+#define TARGET_VECTOR_ALIGNMENT arm_vector_alignment\n+\n #undef TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE\n #define TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE \\\n   arm_vector_alignment_reachable\n@@ -25063,6 +25067,18 @@ arm_have_conditional_execution (void)\n   return !TARGET_THUMB1;\n }\n \n+/* The AAPCS sets the maximum alignment of a vector to 64 bits.  */\n+static HOST_WIDE_INT\n+arm_vector_alignment (const_tree type)\n+{\n+  HOST_WIDE_INT align = tree_low_cst (TYPE_SIZE (type), 0);\n+\n+  if (TARGET_AAPCS_BASED)\n+    align = MIN (align, 64);\n+\n+  return align;\n+}\n+\n static unsigned int\n arm_autovectorize_vector_sizes (void)\n {"}, {"sha": "0f8d43a9ae02b0207ae803cde852233b7e817d03", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=5aea1e76a80c9c5770692ece18100b9383cbab3a", "patch": "@@ -1107,6 +1107,14 @@ make it all fit in fewer cache lines.\n If the value of this macro has a type, it should be an unsigned type.\n @end defmac\n \n+@deftypefn {Target Hook} HOST_WIDE_INT TARGET_VECTOR_ALIGNMENT (const_tree @var{type})\n+This hook can be used to define the alignment for a vector of type\n+@var{type}, in order to comply with a platform ABI.  The default is to\n+require natural alignment for vector types.  The alignment returned by\n+this hook must be a power-of-two multiple of the default alignment of\n+the vector element type.\n+@end deftypefn\n+\n @defmac STACK_SLOT_ALIGNMENT (@var{type}, @var{mode}, @var{basic-align})\n If defined, a C expression to compute the alignment for stack slot.\n @var{type} is the data type, @var{mode} is the widest mode available,"}, {"sha": "8deaf69146c28f3b9c4b5690a41555174dbf2841", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=5aea1e76a80c9c5770692ece18100b9383cbab3a", "patch": "@@ -1091,6 +1091,8 @@ make it all fit in fewer cache lines.\n If the value of this macro has a type, it should be an unsigned type.\n @end defmac\n \n+@hook TARGET_VECTOR_ALIGNMENT\n+\n @defmac STACK_SLOT_ALIGNMENT (@var{type}, @var{mode}, @var{basic-align})\n If defined, a C expression to compute the alignment for stack slot.\n @var{type} is the data type, @var{mode} is the widest mode available,"}, {"sha": "ddec141a0c9104fff1daf8fa1074b03104f268a9", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=5aea1e76a80c9c5770692ece18100b9383cbab3a", "patch": "@@ -2131,9 +2131,17 @@ layout_type (tree type)\n \tTYPE_SIZE (type) = int_const_binop (MULT_EXPR, TYPE_SIZE (innertype),\n \t\t\t\t\t    bitsize_int (nunits));\n \n-\t/* Always naturally align vectors.  This prevents ABI changes\n-\t   depending on whether or not native vector modes are supported.  */\n-\tTYPE_ALIGN (type) = tree_low_cst (TYPE_SIZE (type), 0);\n+\t/* For vector types, we do not default to the mode's alignment.\n+\t   Instead, query a target hook, defaulting to natural alignment.\n+\t   This prevents ABI changes depending on whether or not native\n+\t   vector modes are supported.  */\n+\tTYPE_ALIGN (type) = targetm.vector_alignment (type);\n+\n+\t/* However, if the underlying mode requires a bigger alignment than\n+\t   what the target hook provides, we cannot use the mode.  For now,\n+\t   simply reject that case.  */\n+\tgcc_assert (TYPE_ALIGN (type)\n+\t\t    >= GET_MODE_ALIGNMENT (TYPE_MODE (type)));\n         break;\n       }\n "}, {"sha": "5ac6d48681b544a5c792f845ff9707f41a425b72", "filename": "gcc/target.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=5aea1e76a80c9c5770692ece18100b9383cbab3a", "patch": "@@ -1664,6 +1664,16 @@ DEFHOOK\n  bool, (enum machine_mode mode),\n  hook_bool_mode_false)\n \n+DEFHOOK\n+(vector_alignment,\n+ \"This hook can be used to define the alignment for a vector of type\\n\\\n+@var{type}, in order to comply with a platform ABI.  The default is to\\n\\\n+require natural alignment for vector types.  The alignment returned by\\n\\\n+this hook must be a power-of-two multiple of the default alignment of\\n\\\n+the vector element type.\",\n+ HOST_WIDE_INT, (const_tree type),\n+ default_vector_alignment)\n+\n /* True if we should try to use a scalar mode to represent an array,\n    overriding the usual MAX_FIXED_MODE limit.  */\n DEFHOOK"}, {"sha": "1703aad9c969121fb302f84c9c07f2ddabd339f2", "filename": "gcc/targhooks.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=5aea1e76a80c9c5770692ece18100b9383cbab3a", "patch": "@@ -945,6 +945,13 @@ tree default_mangle_decl_assembler_name (tree decl ATTRIBUTE_UNUSED,\n    return id;\n }\n \n+/* Default to natural alignment for vector types.  */\n+HOST_WIDE_INT\n+default_vector_alignment (const_tree type)\n+{\n+  return tree_low_cst (TYPE_SIZE (type), 0);\n+}\n+\n bool\n default_builtin_vector_alignment_reachable (const_tree type, bool is_packed)\n {"}, {"sha": "f1cc403f070dfd8dcf703ad209cd86f997df2fdb", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=5aea1e76a80c9c5770692ece18100b9383cbab3a", "patch": "@@ -83,6 +83,8 @@ extern int default_builtin_vectorization_cost (enum vect_cost_for_stmt, tree, in\n \n extern tree default_builtin_reciprocal (unsigned int, bool, bool);\n \n+extern HOST_WIDE_INT default_vector_alignment (const_tree);\n+\n extern bool default_builtin_vector_alignment_reachable (const_tree, bool);\n extern bool\n default_builtin_support_vector_misalignment (enum machine_mode mode,"}, {"sha": "442aa3fda958f0db5676cb3fde0955457f49f1cb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5aea1e76a80c9c5770692ece18100b9383cbab3a", "patch": "@@ -1,3 +1,12 @@\n+2012-07-30  Ulrich Weigand  <ulrich.weigand@linaro.org>\n+\n+\t* lib/target-supports.exp\n+\t(check_effective_target_vect_natural_alignment): New function.\n+\t* gcc.dg/align-2.c: Only run on targets with natural alignment\n+\tof vector types.\n+\t* gcc.dg/vect/slp-25.c: Adjust tests for targets without natural\n+\talignment of vector types.\n+\n 2012-07-30  Kirill Yukhin  <kirill.yukhin@intel.com>\n \t    Michael Zolotukhin  <michael.v.zolotukhin@intel.com>\n "}, {"sha": "2001a153bac47dc58f43769ed27a7f1c14b56710", "filename": "gcc/testsuite/gcc.dg/align-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Ftestsuite%2Fgcc.dg%2Falign-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Ftestsuite%2Fgcc.dg%2Falign-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Falign-2.c?ref=5aea1e76a80c9c5770692ece18100b9383cbab3a", "patch": "@@ -1,5 +1,5 @@\n /* PR 17962 */\n-/* { dg-do compile } */\n+/* { dg-do compile { target vect_natural_alignment } } */\n /* { dg-options \"\" } */\n \n typedef float v4 __attribute__((vector_size(sizeof(float)*4)));"}, {"sha": "e5e5e3bdfa6b172cb6a9c9d1a9f6a04d2e669fe1", "filename": "gcc/testsuite/gcc.dg/vect/slp-25.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-25.c?ref=5aea1e76a80c9c5770692ece18100b9383cbab3a", "patch": "@@ -56,5 +56,5 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\"  } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail { vect_no_align } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail { vect_no_align || { ! vect_natural_alignment } } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "0dc5815edcfa62f3c34e67b67067bc924f4c29ed", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=5aea1e76a80c9c5770692ece18100b9383cbab3a", "patch": "@@ -3387,6 +3387,26 @@ proc check_effective_target_natural_alignment_64 { } {\n     return $et_natural_alignment_64_saved\n }\n \n+# Return 1 if all vector types are naturally aligned (aligned to their\n+# type-size), 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_natural_alignment { } {\n+    global et_vect_natural_alignment\n+\n+    if [info exists et_vect_natural_alignment_saved] {\n+        verbose \"check_effective_target_vect_natural_alignment: using cached result\" 2\n+    } else {\n+        set et_vect_natural_alignment_saved 1\n+        if { [check_effective_target_arm_eabi] } {\n+            set et_vect_natural_alignment_saved 0\n+        }\n+    }\n+    verbose \"check_effective_target_vect_natural_alignment: returning $et_vect_natural_alignment_saved\" 2\n+    return $et_vect_natural_alignment_saved\n+}\n+\n # Return 1 if vector alignment (for types of size 32 bit or less) is reachable, 0 otherwise.\n #\n # This won't change for different subtargets so cache the result."}, {"sha": "fe6e40e7926c6a810b2fb9cb39f490e474c7cacb", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=5aea1e76a80c9c5770692ece18100b9383cbab3a", "patch": "@@ -1059,7 +1059,7 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n       int misal = DR_MISALIGNMENT (dr);\n       tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n       misal += negative ? -npeel * dr_size : npeel * dr_size;\n-      misal &= GET_MODE_SIZE (TYPE_MODE (vectype)) - 1;\n+      misal &= (TYPE_ALIGN (vectype) / BITS_PER_UNIT) - 1;\n       SET_DR_MISALIGNMENT (dr, misal);\n       return;\n     }"}, {"sha": "0008116f069c81725a7b58ce4754cf4a2e2d7f40", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aea1e76a80c9c5770692ece18100b9383cbab3a/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=5aea1e76a80c9c5770692ece18100b9383cbab3a", "patch": "@@ -1937,7 +1937,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n    If the misalignment of DR is known at compile time:\n      addr_mis = int mis = DR_MISALIGNMENT (dr);\n    Else, compute address misalignment in bytes:\n-     addr_mis = addr & (vectype_size - 1)\n+     addr_mis = addr & (vectype_align - 1)\n \n    prolog_niters = min (LOOP_NITERS, ((VF - addr_mis/elem_size)&(VF-1))/step)\n \n@@ -1991,9 +1991,10 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n       tree start_addr = vect_create_addr_base_for_vector_ref (dr_stmt,\n \t\t\t\t\t\t&new_stmts, offset, loop);\n       tree type = unsigned_type_for (TREE_TYPE (start_addr));\n-      tree vectype_size_minus_1 = build_int_cst (type, vectype_align - 1);\n-      tree elem_size_log =\n-        build_int_cst (type, exact_log2 (vectype_align/nelements));\n+      tree vectype_align_minus_1 = build_int_cst (type, vectype_align - 1);\n+      HOST_WIDE_INT elem_size =\n+                int_cst_value (TYPE_SIZE_UNIT (TREE_TYPE (vectype)));\n+      tree elem_size_log = build_int_cst (type, exact_log2 (elem_size));\n       tree nelements_minus_1 = build_int_cst (type, nelements - 1);\n       tree nelements_tree = build_int_cst (type, nelements);\n       tree byte_misalign;\n@@ -2002,10 +2003,10 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n       new_bb = gsi_insert_seq_on_edge_immediate (pe, new_stmts);\n       gcc_assert (!new_bb);\n \n-      /* Create:  byte_misalign = addr & (vectype_size - 1)  */\n+      /* Create:  byte_misalign = addr & (vectype_align - 1)  */\n       byte_misalign =\n         fold_build2 (BIT_AND_EXPR, type, fold_convert (type, start_addr), \n-                     vectype_size_minus_1);\n+                     vectype_align_minus_1);\n \n       /* Create:  elem_misalign = byte_misalign / element_size  */\n       elem_misalign ="}]}