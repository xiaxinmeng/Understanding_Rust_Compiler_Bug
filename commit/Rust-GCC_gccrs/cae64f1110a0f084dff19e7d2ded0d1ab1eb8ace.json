{"sha": "cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FlNjRmMTExMGEwZjA4NGRmZjE5ZTdkMmRlZDBkMWFiMWViOGFjZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-23T09:06:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-23T09:06:42Z"}, "message": "[multiple changes]\n\n2013-04-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Dependency_Clause): Update all calls to\n\tAnalyze_Input_Output.\n\t(Analyze_Input_List): Update all calls to Analyze_Input_Output.\n\t(Analyze_Input_Output): Add formal parameter Self_Ref along with\n\tcomment on its usage. Update all calls to Analyze_Input_Output.\n\t(Analyze_Pragma): Add new local variable Self_Ref to capture\n\tthe presence of a self-referential dependency clause. Update\n\tall calls to Analyze_Input_Output.\n\t(Check_Mode): Add formal parameter Self_Ref along with comment on its\n\tusage. Verify the legality of a self-referential output.\n\n2013-04-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch6.adb: Add predicate checks on by-copy parameter.\n\n2013-04-23  Vincent Celier  <celier@adacore.com>\n\n\t* a-envvar.adb, a-envvar.ads (Value): New.\n\nFrom-SVN: r198177", "tree": {"sha": "9e1f925e7ff7c7ca3cfef2696f7f506eb198c68d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e1f925e7ff7c7ca3cfef2696f7f506eb198c68d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace/comments", "author": null, "committer": null, "parents": [{"sha": "08c52234765066a487d3341f0f4797dbcff83bfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08c52234765066a487d3341f0f4797dbcff83bfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08c52234765066a487d3341f0f4797dbcff83bfd"}], "stats": {"total": 150, "additions": 119, "deletions": 31}, "files": [{"sha": "633ac557214bead9444c27ce1fc5e385e60a1fa3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace", "patch": "@@ -1,3 +1,24 @@\n+2013-04-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Dependency_Clause): Update all calls to\n+\tAnalyze_Input_Output.\n+\t(Analyze_Input_List): Update all calls to Analyze_Input_Output.\n+\t(Analyze_Input_Output): Add formal parameter Self_Ref along with\n+\tcomment on its usage. Update all calls to Analyze_Input_Output.\n+\t(Analyze_Pragma): Add new local variable Self_Ref to capture\n+\tthe presence of a self-referential dependency clause. Update\n+\tall calls to Analyze_Input_Output.\n+\t(Check_Mode): Add formal parameter Self_Ref along with comment on its\n+\tusage. Verify the legality of a self-referential output.\n+\n+2013-04-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch6.adb: Add predicate checks on by-copy parameter.\n+\n+2013-04-23  Vincent Celier  <celier@adacore.com>\n+\n+\t* a-envvar.adb, a-envvar.ads (Value): New.\n+\n 2013-04-22  Yannick Moy  <moy@adacore.com>\n \n \t* exp_prag.adb (Expand_Pragma_Loop_Variant): Rewrite pragma as"}, {"sha": "1b1f425cca6deddfda94da8e06744615954d27d8", "filename": "gcc/ada/a-envvar.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace/gcc%2Fada%2Fa-envvar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace/gcc%2Fada%2Fa-envvar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-envvar.adb?ref=cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---            Copyright (C) 2009-2012, Free Software Foundation, Inc.       --\n+--         Copyright (C) 2009-2013, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -223,4 +223,13 @@ package body Ada.Environment_Variables is\n       end if;\n    end Value;\n \n+   function Value (Name : String; Default : String) return String is\n+   begin\n+      if Exists (Name) then\n+         return Value (Name);\n+\n+      else\n+         return Default;\n+      end if;\n+   end Value;\n end Ada.Environment_Variables;"}, {"sha": "dd160fcf47cc3c1239b9661a125810e76249b8d7", "filename": "gcc/ada/a-envvar.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace/gcc%2Fada%2Fa-envvar.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace/gcc%2Fada%2Fa-envvar.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-envvar.ads?ref=cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace", "patch": "@@ -23,6 +23,11 @@ package Ada.Environment_Variables is\n    --  Constraint_Error is propagated. If the execution environment does not\n    --  support environment variables, then Program_Error is propagated.\n \n+   function Value (Name : String; Default : String) return String;\n+   --  If the external execution environment supports environment variables and\n+   --  an environment variable with the given name currently exists, then Value\n+   --  returns its value; otherwise, it returns Default.\n+\n    function Exists (Name : String) return Boolean;\n    --  If the external execution environment supports environment variables and\n    --  an environment variable with the given name currently exists, then"}, {"sha": "11c440b0f419c324a79c87bd7eb9e5392ed2e734", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n@@ -1707,8 +1708,22 @@ package body Exp_Ch6 is\n             --  function, so it must be done explicitly after the call. Ditto\n             --  if the actual is an entity of a predicated subtype.\n \n-            if Is_By_Reference_Type (E_Formal)\n-              and then Has_Predicates (E_Actual)\n+            --  The rule refers to by-reference types, but a check is needed\n+            --  for by-copy types as well. That check is subsumed by the rule\n+            --  for subtype conversion on assignment, but we can generate the\n+            --  required check now.\n+\n+            --  Note that this is needed only if the subtype of the actual has\n+            --  an explicit predicate aspect, not if it inherits them from a\n+            --  base type or ancestor. The check is also superfluous if the\n+            --  subtype is elaborated before the body of the subprogram, but\n+            --  this is harder to verify, and there may be a redundant check.\n+\n+            if (Present (Find_Aspect (E_Actual, Aspect_Predicate))\n+              or else Present\n+                (Find_Aspect (E_Actual, Aspect_Dynamic_Predicate))\n+              or else Present\n+                (Find_Aspect (E_Actual, Aspect_Static_Predicate)))\n               and then not Is_Init_Proc (Subp)\n             then\n                if Is_Derived_Type (E_Actual)"}, {"sha": "2deeb8f141012b56154c37e77b72647eac7f0eea", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 66, "deletions": 28, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=cae64f1110a0f084dff19e7d2ded0d1ab1eb8ace", "patch": "@@ -9346,10 +9346,14 @@ package body Sem_Prag is\n             procedure Check_Mode\n               (Item     : Node_Id;\n                Item_Id  : Entity_Id;\n-               Is_Input : Boolean);\n+               Is_Input : Boolean;\n+               Self_Ref : Boolean);\n             --  Ensure that an item has a proper \"in\", \"in out\" or \"out\" mode\n             --  depending on its function. If this is not the case, emit an\n-            --  error.\n+            --  error. Item and Item_Id denote the attributes of an item. Flag\n+            --  Is_Input should be set when item comes from an input list.\n+            --  Flag Self_Ref should be set when the item is an output and the\n+            --  dependency clause has operator \"+\".\n \n             procedure Check_Usage\n               (Subp_List : Elist_Id;\n@@ -9382,16 +9386,19 @@ package body Sem_Prag is\n                procedure Analyze_Input_Output\n                  (Item      : Node_Id;\n                   Is_Input  : Boolean;\n+                  Self_Ref  : Boolean;\n                   Top_Level : Boolean;\n                   Seen      : in out Elist_Id;\n                   Null_Seen : in out Boolean);\n                --  Verify the legality of a single input or output item. Flag\n                --  Is_Input should be set whenever Item is an input, False when\n-               --  it denotes an output. Flag Top_Level should be set whenever\n-               --  Item appears immediately within an input or output list.\n-               --  Seen is a collection of all abstract states, variables and\n-               --  formals processed so far. Flag Null_Seen denotes whether a\n-               --  null input or output has been encountered.\n+               --  it denotes an output. Flag Self_Ref should be set when the\n+               --  item is an output and the dependency clause has a \"+\". Flag\n+               --  Top_Level should be set whenever Item appears immediately\n+               --  within an input or output list. Seen is a collection of all\n+               --  abstract states, variables and formals processed so far.\n+               --  Flag Null_Seen denotes whether a null input or output has\n+               --  been encountered.\n \n                ------------------------\n                -- Analyze_Input_List --\n@@ -9421,6 +9428,7 @@ package body Sem_Prag is\n                            Analyze_Input_Output\n                              (Item      => Input,\n                               Is_Input  => True,\n+                              Self_Ref  => False,\n                               Top_Level => False,\n                               Seen      => Inputs_Seen,\n                               Null_Seen => Null_Input_Seen);\n@@ -9439,6 +9447,7 @@ package body Sem_Prag is\n                      Analyze_Input_Output\n                        (Item      => Inputs,\n                         Is_Input  => True,\n+                        Self_Ref  => False,\n                         Top_Level => False,\n                         Seen      => Inputs_Seen,\n                         Null_Seen => Null_Input_Seen);\n@@ -9462,6 +9471,7 @@ package body Sem_Prag is\n                procedure Analyze_Input_Output\n                  (Item      : Node_Id;\n                   Is_Input  : Boolean;\n+                  Self_Ref  : Boolean;\n                   Top_Level : Boolean;\n                   Seen      : in out Elist_Id;\n                   Null_Seen : in out Boolean)\n@@ -9490,6 +9500,7 @@ package body Sem_Prag is\n                            Analyze_Input_Output\n                              (Item      => Grouped,\n                               Is_Input  => Is_Input,\n+                              Self_Ref  => Self_Ref,\n                               Top_Level => False,\n                               Seen      => Seen,\n                               Null_Seen => Null_Seen);\n@@ -9576,7 +9587,7 @@ package body Sem_Prag is\n                            --  Ensure that the item is of the correct mode\n                            --  depending on its function.\n \n-                           Check_Mode (Item, Item_Id, Is_Input);\n+                           Check_Mode (Item, Item_Id, Is_Input, Self_Ref);\n \n                            --  Detect multiple uses of the same state, variable\n                            --  or formal parameter. If this is not the case,\n@@ -9631,19 +9642,32 @@ package body Sem_Prag is\n \n                --  Local variables\n \n-               Inputs : Node_Id;\n-               Output : Node_Id;\n+               Inputs   : Node_Id;\n+               Output   : Node_Id;\n+               Self_Ref : Boolean;\n \n             --  Start of processing for Analyze_Dependency_Clause\n \n             begin\n+               Inputs   := Expression (Clause);\n+               Self_Ref := False;\n+\n+               --  An input list with a self-dependency appears as operator \"+\"\n+               --  where the actuals inputs are the right operand.\n+\n+               if Nkind (Inputs) = N_Op_Plus then\n+                  Inputs   := Right_Opnd (Inputs);\n+                  Self_Ref := True;\n+               end if;\n+\n                --  Process the output_list of a dependency_clause\n \n                Output := First (Choices (Clause));\n                while Present (Output) loop\n                   Analyze_Input_Output\n                     (Item      => Output,\n                      Is_Input  => False,\n+                     Self_Ref  => Self_Ref,\n                      Top_Level => True,\n                      Seen      => Outputs_Seen,\n                      Null_Seen => Null_Output_Seen);\n@@ -9653,15 +9677,6 @@ package body Sem_Prag is\n \n                --  Process the input_list of a dependency_clause\n \n-               Inputs := Expression (Clause);\n-\n-               --  An input list with a self-dependency appears as operator \"+\"\n-               --  where the actuals inputs are the right operand.\n-\n-               if Nkind (Inputs) = N_Op_Plus then\n-                  Inputs := Right_Opnd (Inputs);\n-               end if;\n-\n                Analyze_Input_List (Inputs);\n             end Analyze_Dependency_Clause;\n \n@@ -9717,9 +9732,12 @@ package body Sem_Prag is\n             procedure Check_Mode\n               (Item     : Node_Id;\n                Item_Id  : Entity_Id;\n-               Is_Input : Boolean)\n+               Is_Input : Boolean;\n+               Self_Ref : Boolean)\n             is\n             begin\n+               --  Input\n+\n                if Is_Input then\n                   if Ekind (Item_Id) = E_Out_Parameter\n                     or else (Global_Seen\n@@ -9729,17 +9747,37 @@ package body Sem_Prag is\n                        (\"item & must have mode in or in out\", Item, Item_Id);\n                   end if;\n \n-               --  Output\n+               --  Self-referential output\n \n-               else\n-                  if Ekind (Item_Id) = E_In_Parameter\n-                    or else\n-                      (Global_Seen\n-                         and then not Appears_In (Subp_Outputs, Item_Id))\n-                  then\n+               elsif Self_Ref then\n+\n+                  --  A self-referential state or variable must appear in both\n+                  --  input and output lists of a subprogram.\n+\n+                  if Ekind_In (Item_Id, E_Abstract_State, E_Variable) then\n+                     if Global_Seen\n+                       and then not Appears_In (Subp_Inputs, Item_Id)\n+                     then\n+                        Error_Msg_NE\n+                          (\"item & must have mode in out\", Item, Item_Id);\n+                     end if;\n+\n+                  --  Self-referential parameter\n+\n+                  elsif Ekind (Item_Id) /= E_In_Out_Parameter then\n                      Error_Msg_NE\n-                       (\"item & must have mode out or in out\", Item, Item_Id);\n+                       (\"item & must have mode in out\", Item, Item_Id);\n                   end if;\n+\n+               --  Regular output\n+\n+               elsif Ekind (Item_Id) = E_In_Parameter\n+                 or else\n+                   (Global_Seen\n+                      and then not Appears_In (Subp_Outputs, Item_Id))\n+               then\n+                  Error_Msg_NE\n+                    (\"item & must have mode out or in out\", Item, Item_Id);\n                end if;\n             end Check_Mode;\n "}]}