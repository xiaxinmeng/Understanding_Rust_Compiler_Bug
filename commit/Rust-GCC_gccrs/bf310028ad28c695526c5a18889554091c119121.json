{"sha": "bf310028ad28c695526c5a18889554091c119121", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYzMTAwMjhhZDI4YzY5NTUyNmM1YTE4ODg5NTU0MDkxYzExOTEyMQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2004-02-08T12:11:25Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2004-02-08T12:11:25Z"}, "message": "ffi.c (ffi_prep_cif_machdep <FFI_LINUX64>): Correct long double function return and long double arg handling.\n\n\t* src/powerpc/ffi.c (ffi_prep_cif_machdep <FFI_LINUX64>): Correct\n\tlong double function return and long double arg handling.\n\t(ffi_closure_helper_LINUX64): Formatting.  Delete unused \"ng\" var.\n\tUse \"end_pfr\" instead of \"nf\".  Correct long double handling.\n\tLocalise \"temp\".\n\t* src/powerpc/linux64.S (ffi_call_LINUX64): Save f2 long double\n\treturn value.\n\t* src/powerpc/linux64_closure.S (ffi_closure_LINUX64): Allocate\n\tspace for long double return value.  Adjust stack frame and offsets.\n\tLoad f2 long double return.\n\nFrom-SVN: r77481", "tree": {"sha": "13eca59b65bb8ca2f2431721d63ecd9b8b7fc507", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13eca59b65bb8ca2f2431721d63ecd9b8b7fc507"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf310028ad28c695526c5a18889554091c119121", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf310028ad28c695526c5a18889554091c119121", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf310028ad28c695526c5a18889554091c119121", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf310028ad28c695526c5a18889554091c119121/comments", "author": null, "committer": null, "parents": [{"sha": "ec1dbfca7d9beef0e17532d8e8ad1f415ac2b30e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec1dbfca7d9beef0e17532d8e8ad1f415ac2b30e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec1dbfca7d9beef0e17532d8e8ad1f415ac2b30e"}], "stats": {"total": 192, "additions": 110, "deletions": 82}, "files": [{"sha": "4d931c9d58ee01028af35f4eb2fdabda2d7800e4", "filename": "libffi/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf310028ad28c695526c5a18889554091c119121/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf310028ad28c695526c5a18889554091c119121/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=bf310028ad28c695526c5a18889554091c119121", "patch": "@@ -1,3 +1,16 @@\n+2004-02-08  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* src/powerpc/ffi.c (ffi_prep_cif_machdep <FFI_LINUX64>): Correct\n+\tlong double function return and long double arg handling.\n+\t(ffi_closure_helper_LINUX64): Formatting.  Delete unused \"ng\" var.\n+\tUse \"end_pfr\" instead of \"nf\".  Correct long double handling.\n+\tLocalise \"temp\".\n+\t* src/powerpc/linux64.S (ffi_call_LINUX64): Save f2 long double\n+\treturn value.\n+\t* src/powerpc/linux64_closure.S (ffi_closure_LINUX64): Allocate\n+\tspace for long double return value.  Adjust stack frame and offsets.\n+\tLoad f2 long double return.\n+\n 2004-02-07  Alan Modra  <amodra@bigpond.net.au>\n \n \t* src/types.c: Use 16 byte long double for POWERPC64."}, {"sha": "a2fb2d2e89de5d94c08566c939417fd16b09ed3c", "filename": "libffi/src/powerpc/ffi.c", "status": "modified", "additions": 62, "deletions": 48, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf310028ad28c695526c5a18889554091c119121/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf310028ad28c695526c5a18889554091c119121/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi.c?ref=bf310028ad28c695526c5a18889554091c119121", "patch": "@@ -446,6 +446,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   int fparg_count = 0, intarg_count = 0;\n   unsigned flags = 0;\n   unsigned struct_copy_size = 0;\n+  unsigned type = cif->rtype->type;\n \n   if (cif->abi != FFI_LINUX64)\n     {    \n@@ -468,6 +469,11 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \n       /* Space for the mandatory parm save area and general registers.  */\n       bytes += 2 * NUM_GPR_ARG_REGISTERS64 * sizeof(long);\n+\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+      if (type == FFI_TYPE_LONGDOUBLE)\n+\ttype = FFI_TYPE_DOUBLE;\n+#endif\n     }\n \n   /* Return value handling.  The rules for SYSV are as follows:\n@@ -480,9 +486,9 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n        are allocated space and a pointer is passed as the first argument.\n      For LINUX64:\n      - integer values in gpr3;\n-     - Structures/Unions and long double by reference;\n-     - Single/double FP values in fpr1.  */\n-  switch (cif->rtype->type)\n+     - Structures/Unions by reference;\n+     - Single/double FP values in fpr1, long double in fpr1,fpr2.  */\n+  switch (type)\n     {\n     case FFI_TYPE_DOUBLE:\n       flags |= FLAG_RETURNS_64BITS;\n@@ -581,16 +587,19 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n       {\n \tswitch ((*ptr)->type)\n \t  {\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\t  case FFI_TYPE_LONGDOUBLE:\n+\t    fparg_count += 2;\n+\t    intarg_count += 2;\n+\t    break;\n+#endif\n \t  case FFI_TYPE_FLOAT:\n \t  case FFI_TYPE_DOUBLE:\n \t    fparg_count++;\n \t    intarg_count++;\n \t    break;\n \n \t  case FFI_TYPE_STRUCT:\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\t  case FFI_TYPE_LONGDOUBLE:\n-#endif\n \t    intarg_count += ((*ptr)->size + 7) / 8;\n \t    break;\n \n@@ -863,7 +872,7 @@ ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue,\n              pst++;\n           }\n \t  break;\n-\t\n+\n \tcase FFI_TYPE_STRUCT:\n \t  /* Structs are passed by reference. The address will appear in a \n \t     gpr if it is one of the first 8 arguments.  */\n@@ -965,34 +974,28 @@ int hidden ffi_closure_helper_LINUX64 (ffi_closure*, void*, unsigned long*,\n \t\t\t\t       ffi_dblfl*);\n \n int hidden\n-ffi_closure_helper_LINUX64 (ffi_closure* closure, void * rvalue, \n-            unsigned long * pst, ffi_dblfl * pfr)\n+ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue, \n+\t\t\t    unsigned long *pst, ffi_dblfl *pfr)\n {\n   /* rvalue is the pointer to space for return value in closure assembly */\n   /* pst is the pointer to parameter save area\n      (r3-r10 are stored into its first 8 slots by ffi_closure_LINUX64) */\n   /* pfr is the pointer to where f1-f13 are stored in ffi_closure_LINUX64 */\n \n-  void **          avalue;\n-  ffi_type **      arg_types;\n-  long             i, avn;\n-  long             nf;   /* number of floating registers already used */\n-  long             ng;   /* number of general registers already used */\n-  ffi_cif *        cif; \n-  double           temp; \n+  void **avalue;\n+  ffi_type **arg_types;\n+  long i, avn;\n+  ffi_cif *cif; \n+  ffi_dblfl *end_pfr = pfr + NUM_FPR_ARG_REGISTERS64;\n \n   cif = closure->cif;\n-  avalue = alloca(cif->nargs * sizeof(void *));\n-\n-  nf = 0;\n-  ng = 0;\n+  avalue = alloca (cif->nargs * sizeof (void *));\n \n   /* Copy the caller's structure return value address so that the closure\n      returns the data directly to the caller.  */\n   if (cif->rtype->type == FFI_TYPE_STRUCT)\n     {\n       rvalue = (void *) *pst;\n-      ng++;\n       pst++;\n     }\n \n@@ -1008,43 +1011,35 @@ ffi_closure_helper_LINUX64 (ffi_closure* closure, void * rvalue,\n \tcase FFI_TYPE_SINT8:\n \tcase FFI_TYPE_UINT8:\n \t  avalue[i] = (char *) pst + 7;\n-\t  ng++;\n \t  pst++;\n \t  break;\n            \n \tcase FFI_TYPE_SINT16:\n \tcase FFI_TYPE_UINT16:\n \t  avalue[i] = (char *) pst + 6;\n-\t  ng++;\n \t  pst++;\n \t  break;\n \n \tcase FFI_TYPE_SINT32:\n \tcase FFI_TYPE_UINT32:\n \t  avalue[i] = (char *) pst + 4;\n-\t  ng++;\n \t  pst++;\n \t  break;\n \n \tcase FFI_TYPE_SINT64:\n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_POINTER:\n \t  avalue[i] = pst;\n-\t  ng++;\n \t  pst++;\n \t  break;\n \n \tcase FFI_TYPE_STRUCT:\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\tcase FFI_TYPE_LONGDOUBLE:\n-#endif\n \t  /* Structures with size less than eight bytes are passed\n \t     left-padded.  */\n \t  if (arg_types[i]->size < 8)\n \t    avalue[i] = (char *) pst + 8 - arg_types[i]->size;\n \t  else\n \t    avalue[i] = pst;\n-\t  ng += (arg_types[i]->size + 7) / 8;\n \t  pst += (arg_types[i]->size + 7) / 8;\n \t  break;\n \n@@ -1056,34 +1051,54 @@ ffi_closure_helper_LINUX64 (ffi_closure* closure, void * rvalue,\n \n           /* there are 13 64bit floating point registers */\n \n-          if (nf < NUM_FPR_ARG_REGISTERS64) {\n-             temp = pfr->d;\n-             pfr->f = (float)temp;\n-             avalue[i] = pfr;\n-             pfr++;\n-          } else {\n-\t     avalue[i] = pst;\n-          }\n-          nf++;\n-\t  ng++;\n+          if (pfr < end_pfr)\n+\t    {\n+\t      double temp = pfr->d;\n+\t      pfr->f = (float) temp;\n+\t      avalue[i] = pfr;\n+\t      pfr++;\n+\t    }\n+\t  else\n+\t    avalue[i] = pst;\n \t  pst++;\n \t  break;\n \n \tcase FFI_TYPE_DOUBLE:\n \t  /* On the outgoing stack all values are aligned to 8 */\n           /* there are 13 64bit floating point registers */\n \n-          if (nf < NUM_FPR_ARG_REGISTERS64) {\n-\t     avalue[i] = pfr;\n-             pfr++;\n-          } else {\n-\t     avalue[i] = pst;\n-          }\n-          nf++;\n-\t  ng++;\n+\t  if (pfr < end_pfr)\n+\t    {\n+\t      avalue[i] = pfr;\n+\t      pfr++;\n+\t    }\n+\t  else\n+\t    avalue[i] = pst;\n \t  pst++;\n \t  break;\n \n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  if (prf + 1 < end_pfr)\n+\t    {\n+\t      avalue[i] = pfr;\n+\t      pfr += 2;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (pfr < end_pfr)\n+\t\t{\n+\t\t  /* Passed partly in f13 and partly on the stack.\n+\t\t     Move it all to the stack.  */\n+\t\t  *pst = *(unsigned long *) pfr;\n+\t\t  pfr++;\n+\t\t}\n+\t      avalue[i] = pst;\n+\t    }\n+\t  pst += 2;\n+\t  break;\n+#endif\n+\n \tdefault:\n \t  FFI_ASSERT(0);\n \t}\n@@ -1096,5 +1111,4 @@ ffi_closure_helper_LINUX64 (ffi_closure* closure, void * rvalue,\n \n   /* Tell ffi_closure_LINUX64 how to perform return type promotions.  */\n   return cif->rtype->type;\n-\n }"}, {"sha": "11cf926ba38fe19c0b55362dcc1aadd84b24c436", "filename": "libffi/src/powerpc/linux64.S", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf310028ad28c695526c5a18889554091c119121/libffi%2Fsrc%2Fpowerpc%2Flinux64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf310028ad28c695526c5a18889554091c119121/libffi%2Fsrc%2Fpowerpc%2Flinux64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Flinux64.S?ref=bf310028ad28c695526c5a18889554091c119121", "patch": "@@ -122,6 +122,7 @@ ffi_call_LINUX64:\n .Lfp_return_value:\n \tbf\t28, .Lfloat_return_value\n \tstfd\t%f1, 0(%r30)\n+\tstfd\t%f2, 8(%r30)\t/* It might be a long double */\n \tb\t.Ldone_return_value\n .Lfloat_return_value:\n \tstfs\t%f1, 0(%r30)"}, {"sha": "fa331dbe8fb4280fbe77c561ef06d42cd2f06391", "filename": "libffi/src/powerpc/linux64_closure.S", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf310028ad28c695526c5a18889554091c119121/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf310028ad28c695526c5a18889554091c119121/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S?ref=bf310028ad28c695526c5a18889554091c119121", "patch": "@@ -30,24 +30,24 @@ ffi_closure_LINUX64:\n \tstd\t%r0, 16(%r1)\n \n \t# mandatory 48 bytes special reg save area + 64 bytes parm save area\n-\t# + 8 bytes retval area + 13*8 bytes fpr save area\n-\tstdu\t%r1, -224(%r1)\n+\t# + 16 bytes retval area + 13*8 bytes fpr save area + round to 16\n+\tstdu\t%r1, -240(%r1)\n .LCFI0:\n \n \t# next save fpr 1 to fpr 13\n-\tstfd  %f1, 120+(0*8)(%r1)\n-\tstfd  %f2, 120+(1*8)(%r1)\n-\tstfd  %f3, 120+(2*8)(%r1)\n-\tstfd  %f4, 120+(3*8)(%r1)\n-\tstfd  %f5, 120+(4*8)(%r1)\n-\tstfd  %f6, 120+(5*8)(%r1)\n-\tstfd  %f7, 120+(6*8)(%r1)\n-\tstfd  %f8, 120+(7*8)(%r1)\n-\tstfd  %f9, 120+(8*8)(%r1)\n-\tstfd  %f10, 120+(9*8)(%r1)\n-\tstfd  %f11, 120+(10*8)(%r1)\n-\tstfd  %f12, 120+(11*8)(%r1)\n-\tstfd  %f13, 120+(12*8)(%r1)\n+\tstfd  %f1, 128+(0*8)(%r1)\n+\tstfd  %f2, 128+(1*8)(%r1)\n+\tstfd  %f3, 128+(2*8)(%r1)\n+\tstfd  %f4, 128+(3*8)(%r1)\n+\tstfd  %f5, 128+(4*8)(%r1)\n+\tstfd  %f6, 128+(5*8)(%r1)\n+\tstfd  %f7, 128+(6*8)(%r1)\n+\tstfd  %f8, 128+(7*8)(%r1)\n+\tstfd  %f9, 128+(8*8)(%r1)\n+\tstfd  %f10, 128+(9*8)(%r1)\n+\tstfd  %f11, 128+(10*8)(%r1)\n+\tstfd  %f12, 128+(11*8)(%r1)\n+\tstfd  %f13, 128+(12*8)(%r1)\n \n \t# set up registers for the routine that actually does the work\n \t# get the context pointer from the trampoline\n@@ -58,10 +58,10 @@ ffi_closure_LINUX64:\n \n \t# now load up the pointer to the parameter save area\n \t# in the previous frame\n-\taddi %r5, %r1, 224 + 48\n+\taddi %r5, %r1, 240 + 48\n \n \t# now load up the pointer to the saved fpr registers */\n-\taddi %r6, %r1, 120\n+\taddi %r6, %r1, 128\n \n \t# make the call\n \tbl .ffi_closure_helper_LINUX64\n@@ -76,7 +76,7 @@ ffi_closure_LINUX64:\n \tmflr %r4\t\t# move address of .Lret to r4\n \tsldi %r3, %r3, 4\t# now multiply return type by 16\n \taddi %r4, %r4, .Lret_type0 - .Lret\n-\tld %r0, 224+16(%r1)\n+\tld %r0, 240+16(%r1)\n \tadd %r3, %r3, %r4\t# add contents of table to table address\n \tmtctr %r3\n \tbctr\t\t\t# jump to it\n@@ -89,33 +89,33 @@ ffi_closure_LINUX64:\n .Lret_type0:\n # case FFI_TYPE_VOID\n \tmtlr %r0\n-\taddi %r1, %r1, 224\n+\taddi %r1, %r1, 240\n \tblr\n \tnop\n # case FFI_TYPE_INT\n \tlwa %r3, 112+4(%r1)\n \tmtlr %r0\n-\taddi %r1, %r1, 224\n+\taddi %r1, %r1, 240\n \tblr\n # case FFI_TYPE_FLOAT\n \tlfs %f1, 112+0(%r1)\n \tmtlr %r0\n-\taddi %r1, %r1, 224\n+\taddi %r1, %r1, 240\n \tblr\n # case FFI_TYPE_DOUBLE\n \tlfd %f1, 112+0(%r1)\n \tmtlr %r0\n-\taddi %r1, %r1, 224\n+\taddi %r1, %r1, 240\n \tblr\n # case FFI_TYPE_LONGDOUBLE\n \tlfd %f1, 112+0(%r1)\n \tmtlr %r0\n-\taddi %r1, %r1, 224\n-\tblr\n+\tlfd %f2, 112+8(%r1)\n+\tb .Lfinish\n # case FFI_TYPE_UINT8\n \tlbz %r3, 112+7(%r1)\n \tmtlr %r0\n-\taddi %r1, %r1, 224\n+\taddi %r1, %r1, 240\n \tblr\n # case FFI_TYPE_SINT8\n \tlbz %r3, 112+7(%r1)\n@@ -126,42 +126,42 @@ ffi_closure_LINUX64:\n \tlhz %r3, 112+6(%r1)\n \tmtlr %r0\n .Lfinish:\n-\taddi %r1, %r1, 224\n+\taddi %r1, %r1, 240\n \tblr\n # case FFI_TYPE_SINT16\n \tlha %r3, 112+6(%r1)\n \tmtlr %r0\n-\taddi %r1, %r1, 224\n+\taddi %r1, %r1, 240\n \tblr\n # case FFI_TYPE_UINT32\n \tlwz %r3, 112+4(%r1)\n \tmtlr %r0\n-\taddi %r1, %r1, 224\n+\taddi %r1, %r1, 240\n \tblr\n # case FFI_TYPE_SINT32\n \tlwa %r3, 112+4(%r1)\n \tmtlr %r0\n-\taddi %r1, %r1, 224\n+\taddi %r1, %r1, 240\n \tblr\n # case FFI_TYPE_UINT64\n \tld %r3, 112+0(%r1)\n \tmtlr %r0\n-\taddi %r1, %r1, 224\n+\taddi %r1, %r1, 240\n \tblr\n # case FFI_TYPE_SINT64\n \tld %r3, 112+0(%r1)\n \tmtlr %r0\n-\taddi %r1, %r1, 224\n+\taddi %r1, %r1, 240\n \tblr\n # case FFI_TYPE_STRUCT\n \tmtlr %r0\n-\taddi %r1, %r1, 224\n+\taddi %r1, %r1, 240\n \tblr\n \tnop\n # case FFI_TYPE_POINTER\n \tld %r3, 112+0(%r1)\n \tmtlr %r0\n-\taddi %r1, %r1, 224\n+\taddi %r1, %r1, 240\n \tblr\n # esac\n .LFE1:\n@@ -196,7 +196,7 @@ ffi_closure_LINUX64:\n \t.byte\t0x2\t # DW_CFA_advance_loc1\n \t.byte\t.LCFI0-.LFB1\n \t.byte\t0xe\t # DW_CFA_def_cfa_offset\n-\t.uleb128 224\n+\t.uleb128 240\n \t.byte\t0x11\t # DW_CFA_offset_extended_sf\n \t.uleb128 0x41\n \t.sleb128 -2"}]}