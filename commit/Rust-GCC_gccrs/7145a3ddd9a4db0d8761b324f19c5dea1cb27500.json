{"sha": "7145a3ddd9a4db0d8761b324f19c5dea1cb27500", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE0NWEzZGRkOWE0ZGIwZDg3NjFiMzI0ZjE5YzVkZWExY2IyNzUwMA==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2001-11-28T00:02:04Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2001-11-28T00:02:04Z"}, "message": "explanations.html: New section, empty for now.\n\n2001-11-27  Phil Edwards  <pme@gcc.gnu.org>\n\n\t* docs/html/explanations.html:  New section, empty for now.\n\t* docs/html/17_intro/howto.html:  Cleanup.  Move unrelated link...\n\t* docs/html/23_containers/howto.html:  ...to here.  Break up and\n\trewrap threading discussion to emphasize warning.  Move malloc text...\n\t* docs/html/ext/howto.html:  ...to here.  New section.  Describe\n\tallocators and __USE_MALLOC effects.\n\t* docs/html/ext/sgiexts.html:  Mention their code.\n\nFrom-SVN: r47391", "tree": {"sha": "edd46291ce0abe50beaa3c1a5eb61f32eae672d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/edd46291ce0abe50beaa3c1a5eb61f32eae672d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7145a3ddd9a4db0d8761b324f19c5dea1cb27500", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7145a3ddd9a4db0d8761b324f19c5dea1cb27500", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7145a3ddd9a4db0d8761b324f19c5dea1cb27500", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7145a3ddd9a4db0d8761b324f19c5dea1cb27500/comments", "author": null, "committer": null, "parents": [{"sha": "8a63621fe525f28c16a490a51f976165a0009784", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a63621fe525f28c16a490a51f976165a0009784", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a63621fe525f28c16a490a51f976165a0009784"}], "stats": {"total": 260, "additions": 236, "deletions": 24}, "files": [{"sha": "0f58b3cf82b57ddc5a30610df219f364793dfff6", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7145a3ddd9a4db0d8761b324f19c5dea1cb27500/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7145a3ddd9a4db0d8761b324f19c5dea1cb27500/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7145a3ddd9a4db0d8761b324f19c5dea1cb27500", "patch": "@@ -1,3 +1,13 @@\n+2001-11-27  Phil Edwards  <pme@gcc.gnu.org>\n+\n+\t* docs/html/explanations.html:  New section, empty for now.\n+\t* docs/html/17_intro/howto.html:  Cleanup.  Move unrelated link...\n+\t* docs/html/23_containers/howto.html:  ...to here.  Break up and\n+\trewrap threading discussion to emphasize warning.  Move malloc text...\n+\t* docs/html/ext/howto.html:  ...to here.  New section.  Describe\n+\tallocators and __USE_MALLOC effects.\n+\t* docs/html/ext/sgiexts.html:  Mention their code.\n+\n 2001-11-24  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* docs/doxygen/maint.cfg.in, docs/doxygen/user.cfg.in,"}, {"sha": "abbeb814d506af16b170b5fa0315bb285d026396", "filename": "libstdc++-v3/docs/html/17_intro/howto.html", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7145a3ddd9a4db0d8761b324f19c5dea1cb27500/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7145a3ddd9a4db0d8761b324f19c5dea1cb27500/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fhowto.html?ref=7145a3ddd9a4db0d8761b324f19c5dea1cb27500", "patch": "@@ -74,7 +74,7 @@ <h2><a name=\"3\">The Standard C++ library and multithreading</a></h2>\n    </p>\n    <p>All normal disclaimers aside, multithreaded C++ application are\n       only supported when libstdc++ and all user code was built with\n-      compilers which report (via <em>gcc/g++ -v</em>) the same thread\n+      compilers which report (via <code> gcc/g++ -v </code>) the same thread\n       model and that model is not <em>single</em>.  As long as your\n       final application is actually single-threaded, then it should be\n       safe to mix user code built with a thread model of\n@@ -89,7 +89,7 @@ <h2><a name=\"3\">The Standard C++ library and multithreading</a></h2>\n    </p>\n    <p>When you link a multithreaded application, you will probably\n       need to add a library or flag to g++.  This is a very\n-      non-standardized area of gcc across ports.  Some ports support a\n+      non-standardized area of GCC across ports.  Some ports support a\n       special flag (the spelling isn't even standardized yet) to add\n       all required macros to a compilation (if any such flags are\n       required then you must provide the flag for all compilations not\n@@ -135,9 +135,6 @@ <h2><a name=\"3\">The Standard C++ library and multithreading</a></h2>\n         This message</a> inspired a recent updating of issues with threading\n         and the SGI STL library.  It also contains some example\n         POSIX-multithreaded STL code.\n-        <li><a href=\"http://gcc.gnu.org/ml/libstdc++/2001-05/msg00136.html\">\n-        Here</a> is an early analysis of why __USE_MALLOC should be disabled\n-        for the 3.0 release of libstdc++.</a>\n       </ul>\n       (A large selection of links to older messages has been removed; many\n       of the messages from 1999 were lost in a disk crash, and the few"}, {"sha": "7684bcab5ae2281b3c87a5796189cb13842f7d7e", "filename": "libstdc++-v3/docs/html/23_containers/howto.html", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7145a3ddd9a4db0d8761b324f19c5dea1cb27500/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F23_containers%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7145a3ddd9a4db0d8761b324f19c5dea1cb27500/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F23_containers%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F23_containers%2Fhowto.html?ref=7145a3ddd9a4db0d8761b324f19c5dea1cb27500", "patch": "@@ -244,37 +244,45 @@ <h2><a name=\"3\">Containers and multithreading</a></h2>\n    </p>\n    <p>The STL implementation is currently configured to use the\n       high-speed caching memory allocator.  If you absolutely think\n-      you must change this on a global basis for your platform to\n-      better support multi-threading, then please consult all\n-      commentary in include/bits/c++config.  (Explicit warning since\n-      so many people post after getting confused while attempting\n-      this:) Adding -D__USE_MALLOC on the command line is not a good\n-      idea.  Related to threading or otherwise, the current\n-      recommendation is that users not add any macro defines on the\n-      command line to enable features out of libstdc++-v3.  There is\n+      you must change this on a global basis for your platform to better\n+      support multi-threading, then please consult all commentary in\n+      include/bits/stl_alloc.h and the allocators link below.\n+      <blockquote>\n+      <p>(Explicit warning since so many people get confused while\n+      attempting this:)\n+      </p>\n+      <p><strong>Adding -D__USE_MALLOC on the command\n+      line is almost certainly a bad idea.</strong>  Memory efficiency is\n+      almost guaranteed to suffer as a result; this is\n+      <a href=\"http://gcc.gnu.org/ml/libstdc++/2001-05/msg00136.html\">why\n+      we disabled it for 3.0 in the first place</a>.\n+      </p>\n+      <p>Related to threading or otherwise, the current recommendation is\n+      that users not add any macro defines on the command line to remove or\n+      otherwise disable features of libstdc++-v3.  There is\n       no condition under which it will help you without causing other\n       issues to perhaps raise up (possible linkage/ABI problems).  In\n       particular, __USE_MALLOC should only be added to a libstdc++-v3\n       configuration file, include/bits/c++config (where such user\n       action is cautioned against), and the entire library should be\n       rebuilt.  If you do not, then you might be violating the\n       one-definition rule of C/C++ and you might cause yourself untold\n-      problems.  If you find any platform where gcc reports a\n-      threading model other than single and where libstdc++-v3 builds\n+      problems.\n+      </p>\n+      </blockquote>\n+      If you find any platform where gcc reports a\n+      threading model other than single, and where libstdc++-v3 builds\n       a buggy container allocator when used with threads unless you\n       define __USE_MALLOC, we want to hear about it ASAP.  In the\n       past, correctness was the main reason people were led to believe\n       that they should define __USE_MALLOC when using threads.\n    </p>\n-   <p>There is a better way (not standardized yet): It is possible to\n+   <p>There is a better way (not standardized yet):  It is possible to\n       force the malloc-based allocator on a per-case-basis for some\n       application code.  The library team generally believes that this\n       is a better way to tune an application for high-speed using this\n-      implementation of the STL.  Here is one possible example\n-      displaying the forcing of the malloc-based allocator over the\n-      typically higher-speed default allocator:\n-      <pre>\n-      std::list &lt;my_type, std::__malloc_alloc_template&lt;0&gt; &gt;  my_malloc_based_list;</pre>\n+      implementation of the STL.  There is\n+      <a href=\"../ext/howto.html#3\">more information on allocators here</a>.\n    </p>\n    <p>Return <a href=\"#top\">to top of page</a> or\n       <a href=\"../faq/index.html\">to the FAQ</a>."}, {"sha": "164a5a1cf8e2cf7885c1ec4a22e25d808e292be1", "filename": "libstdc++-v3/docs/html/explanations.html", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7145a3ddd9a4db0d8761b324f19c5dea1cb27500/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fexplanations.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7145a3ddd9a4db0d8761b324f19c5dea1cb27500/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fexplanations.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fexplanations.html?ref=7145a3ddd9a4db0d8761b324f19c5dea1cb27500", "patch": "@@ -61,6 +61,15 @@ <h1 class=\"centered\"><a name=\"top\">Explanatory notes about libstdc++-v3\n </p>\n \n \n+<hr>\n+<a name=\"alloc\"><h3>Internal Allocators</h3></a>\n+<p>\n+</p>\n+<p>Return <a href=\"#top\">to the top of the page</a> or\n+   <a href=\"http://gcc.gnu.org/libstdc++/\">to the homepage</a>.\n+</p>\n+\n+\n <!-- ####################################################### -->\n \n <hr>"}, {"sha": "53c29498d0010beaf395cdff03d1b987920b5ee7", "filename": "libstdc++-v3/docs/html/ext/howto.html", "status": "modified", "additions": 187, "deletions": 2, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7145a3ddd9a4db0d8761b324f19c5dea1cb27500/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7145a3ddd9a4db0d8761b324f19c5dea1cb27500/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html?ref=7145a3ddd9a4db0d8761b324f19c5dea1cb27500", "patch": "@@ -143,8 +143,193 @@ <h2><a name=\"2\">Added members and types</a></h2>\n \n <hr>\n <h2><a name=\"3\">Allocators</a></h2>\n-   <p>This will be blank for a while.  It will describe all of the different\n-      memory allocators, most inherited from SGI's code.  Input is solicited.\n+   <p>Thread-safety, space efficiency, high speed, portability... this is a\n+      mess.  Where to begin?\n+   </p>\n+   <h3>The Rules</h3>\n+   <p>The C++ standard only gives a few directives in this area:\n+     <ul>\n+     <li>When you add elements to a container, and the container must allocate\n+         more memory to hold them, the container makes the request via its\n+         <code>Allocator</code> template parameter.  This includes adding\n+         char's to the string class, which acts as a regular STL container\n+         in this respect.\n+     <li>The default <code>Allocator</code> of every container-of-T is\n+         <code>std::allocator&lt;T&gt;</code>.\n+     <li>The interface of the <code>allocator&lt;T&gt;</code> class is\n+         extremely simple.  It has about 20 public declarations (nested\n+         typedefs, member functions, etc), but the two which concern us most\n+         are:\n+         <pre>\n+      T*    allocate   (size_type n, const void* hint = 0);\n+      void  deallocate (T* p, size_type n);</pre>\n+         (This is a simplicifcation; the real signatures use nested typedefs.)\n+         The <code>&quot;n&quot;</code> arguments in both those functions is a\n+         <em>count</em> of the number of T's to allocate space for,\n+         <em>not their total size</em>.\n+     <li>&quot;The storage is obtained by calling\n+         <code>::operator new(size_t)</code>, but it is unspecified when or\n+         how often this function is called.  The use of <code>hint</code>\n+         is unspecified, but intended as an aid to locality if an\n+         implementation so desires.&quot; [20.4.1.1]/6\n+     </ul>\n+   </p>\n+   <h3>Problems and Possibilities</h3>\n+   <p>The easiest way of fulfilling the requirements is to call operator new\n+      each time a container needs memory, and to call operator delete each\n+      time the container releases memory.  <strong>BUT</strong>\n+      <a href=\"http://gcc.gnu.org/ml/libstdc++/2001-05/msg00105.html\">this\n+      method is horribly slow</a>.\n+   </p>\n+   <p>Or we can keep old memory around, and reuse it in a pool to save time.\n+      The old libstdc++-v2 used a memory pool, and so do we.  As of 3.0,\n+      <a href=\"http://gcc.gnu.org/ml/libstdc++/2001-05/msg00136.html\">it's\n+      on by default</a>.  The pool is shared among all the containers in the\n+      program:  when your program's std::vector&lt;int&gt; gets cut in half\n+      and frees a bunch of its storage, that memory can be reused by the\n+      private std::list&lt;WonkyWidget&gt; brought in from a KDE library\n+      that you linked against.  And we don't have to call operator's new and\n+      delete to pass the memory on, ether, which is a speed bonus.\n+      <strong>BUT</strong>...\n+   </p>\n+   <p>What about threads?  No problem:  in a threadsafe environment, the\n+      memory pool is manipulated atomically, so you can grow a container in\n+      one thread and shrink it in another, etc.  <strong>BUT</strong> what\n+      if threads in libstdc++-v3 aren't set up properly?\n+      <a href=\"../faq/index.html#5_6\">That's been answered already</a>.\n+   </p>\n+   <p><strong>BUT</strong> what if you want to use your own allocator?  What\n+      if you plan on using a runtime-loadable version of malloc() which uses\n+      shared telepathic anonymous mmap'd sections serializable over a\n+      network, so that memory requests <em>should</em> go through malloc?\n+      And what if you need to debug it?\n+   </p>\n+   <p>Well then:\n+   </p>\n+   <h3>Available allocators in namespace std</h3>\n+   <p>First I'll describe the situation as it exists for the code which will\n+      be released in GCC 3.1.  This situation is extremely fluid.  Then I'll\n+      describe the differences for 3.0.x, which will not change much in\n+      this respect.\n+   </p>\n+   <p>As a general rule of thumb, users are not allowed to use names which\n+      begin with an underscore.  This means that to be portable between\n+      compilers, none of the following may be used in your program directly.\n+      (If you decide to be unportable, then you're free do do what you want,\n+      but it's not our fault if stuff breaks.)  They are presented here for\n+      information for maintainers and contributors in addition to users, but\n+      we will probably make them available for users in 3.1 somehow.\n+   </p>\n+   <p>These classes are always available:\n+     <ul>\n+     <li><code>__new_alloc</code> simply wraps <code>::operator new</code>\n+         and <code>::operator delete</code>.\n+     <li><code>__malloc_alloc_template&lt;int inst&gt;</code> simply wraps\n+         <code>malloc</code> and <code>free</code>.  There is also a hook\n+         for an out-of-memory handler (for new/delete this is taken care of\n+         elsewhere).  The <code>inst</code> parameter is described below.\n+         This class was called <code>malloc_alloc</code> in earlier versions.\n+     <li><code>allocator&lt;T&gt;</code> has already been described; it is\n+         The Standard Allocator for instances of T.  It uses the internal\n+         <code>__alloc</code> typedef (see below) to satisy its requests.\n+     <li><code>__simple_alloc&lt;T,A&gt;</code> is a wrapper around another\n+         allocator, A, which itself is an allocator for instances of T.\n+         This is primarily used in an internal &quot;allocator traits&quot;\n+         class which helps encapsulate the different styles of allocators.\n+     <li><code>__debug_alloc&lt;A&gt;</code> is also a wrapper around an\n+         arbitrary allocator A.  It passes on slightly increased size\n+         requests to A, and uses the extra memory to store size information.\n+         When a pointer is passed to <code>deallocate()</code>, the stored\n+         size is checked, and assert() is used to guarantee they match.\n+     <li><code>__allocator&lt;T,A&gt;</code> is an adaptor.  Many of these\n+         allocator classes have a consistent yet non-standard interface.\n+         Such classes can be changed to a conforming interface with this\n+         wrapper:  <code>__allocator&lt;T, __alloc&gt;</code> is thus the\n+         same as <code>allocator&lt;T&gt;</code>.\n+     </ul>\n+   </p>\n+   <p>An internal typedef, <code> __mem_interface </code>, is defined to be\n+      <code>__new_alloc</code> by default.\n+   </p>\n+   <p>Normally,\n+      <code> __default_alloc_template&lt;bool thr, int inst&gt; </code>\n+      is also available.  This is the high-speed pool, called the default\n+      node allocator.  The reusable memory is shared among identical\n+      instantiations of\n+      this type.  It calls through <code>__mem_interface</code> to obtain\n+      new memory when its lists run out.  If a client container requests a\n+      block larger than a certain threshold size, then the pool is bypassed,\n+      and the allocate/deallocate request is passed to\n+      <code>__mem_interface</code> directly.\n+   </p>\n+   <p>Its <code>inst</code> parameter is described below.  The\n+      <code>thr</code> boolean determines whether the pool should be\n+      manipulated atomically or not.  Two typedefs are provided:\n+      <code>__alloc</code> is defined as this node allocator with thr=true,\n+      and therefore is threadsafe, while <code>__single_client_alloc</code>\n+      defines thr=false, and is slightly faster but unsafe for multiple\n+      threads.\n+   </p>\n+   <p>(Note that the GCC thread abstraction layer allows us to provide safe\n+      zero-overhead stubs for the threading routines, if threads were\n+      disabled at configuration time.  In this situation,\n+      <code>__alloc</code> should not be noticably slower than\n+      <code>__single_client_alloc</code>.)\n+   </p>\n+   <h3>A cannon to swat a fly:<code>  __USE_MALLOC</code></h3>\n+   <p>If you've already read <a href=\"../23_containers/howto.html#3\">this\n+      advice</a> and decided to define this macro, then the situation changes\n+      thusly:\n+     <ol>\n+     <li><code>__mem_interface</code>, and\n+     <li><code>__alloc</code>, and\n+     <li><code>__single_client_alloc</code> are all typedef'd to\n+         <code>__malloc_alloc_template</code>.\n+     <li><code>__default_alloc_template</code> is no longer available.\n+         At all.  Anywhere.  <!-- might change? -->\n+     </ol>\n+   </p>\n+   <h3>Writing your own allocators</h3>\n+   <p>Depending on your application (a specific program, a generic library,\n+      etc), allocator classes tend to be one of two styles:  &quot;SGI&quot;\n+      or &quot;standard&quot;.  See the comments in stl_alloc.h for more\n+      information on this crucial difference.\n+   </p>\n+   <p>At the bottom of that header is a helper type,\n+      <code>_Alloc_traits</code>, and various specializations of it.  This\n+      allows the container classes to make possible compile-time\n+      optimizations based on features of the allocator.  You should provide\n+      a specialization of this type for your allocator (doing so takes only\n+      two or three statements).\n+   </p>\n+   <h3>Using non-default allocators</h3>\n+   <p>You can specify different memory management schemes on a per-container\n+      basis, by overriding the default <code>Allocator</code> template\n+      parameter.  For example, an easy\n+      (but nonportable)\n+      method of specifying that only malloc/free should be used instead of\n+      the default node allocator is:\n+      <pre>\n+    std::list &lt;my_type, std::__malloc_alloc_template&lt;0&gt; &gt;  my_malloc_based_list;</pre>\n+      Likewise, a debugging form of whichever allocator is currently in use:\n+      <pre>\n+    std::deque &lt;my_type, std::__debug_alloc&lt;std::__alloc&gt; &gt;  debug_deque;</pre>\n+   </p>\n+   <h3><code>inst</code></h3>\n+   <p>The <code>__malloc_alloc_template</code> and\n+      <code>__default_alloc_template</code> classes take an integer parameter,\n+      called inst here.  This number is completely unused.\n+   </p>\n+   <p>  More soon.\n+   </p>\n+   <p>\n+   </p>\n+   <h3>3.0.x</h3>\n+   <p>I don't even remember.  More soon.\n+   </p>\n+   <p>\n+   </p>\n+   <p>\n    </p>\n    <p>Return <a href=\"#top\">to top of page</a> or\n       <a href=\"../faq/index.html\">to the FAQ</a>."}, {"sha": "674ffacc766593ad47ebb9d4aa3cb1358f3ebf4b", "filename": "libstdc++-v3/docs/html/ext/sgiexts.html", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7145a3ddd9a4db0d8761b324f19c5dea1cb27500/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fsgiexts.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7145a3ddd9a4db0d8761b324f19c5dea1cb27500/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fsgiexts.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fsgiexts.html?ref=7145a3ddd9a4db0d8761b324f19c5dea1cb27500", "patch": "@@ -25,7 +25,7 @@ <h1 class=\"centered\"><a name=\"top\">SGI extensions to the library in\n    for a description).  Not every chapter may have extensions, and the\n    extensions may come and go.  Also, this page is incomplete because the\n    author is pressed for time.  Check back often; the latest change was on\n-   $Date: 2001/10/11 18:41:47 $ (UTC).\n+   $Date: 2001/11/23 16:29:01 $ (UTC).\n </p>\n \n <p>Descriptions range from the scanty to the verbose.  You should also check\n@@ -60,6 +60,9 @@ <h1 class=\"centered\"><a name=\"top\">SGI extensions to the library in\n   <li>mem_fun adaptor helpers mem_fun1 and mem_fun1_ref are provided for\n       backwards compatibility.\n </ul></p>\n+<p>20.4.1 can use several different allocators; they are described on the\n+   main extensions page.\n+</p>\n <p>20.4.3 is extended with a special version of\n    <code>get_temporary_buffer</code> taking a second argument.  The argument\n    is a pointer, which is ignored, but can be used to specify the template"}]}