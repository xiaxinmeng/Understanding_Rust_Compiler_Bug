{"sha": "58c42dc28354d5857a5d905d505127eb5624111f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThjNDJkYzI4MzU0ZDU4NTdhNWQ5MDVkNTA1MTI3ZWI1NjI0MTExZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-06-28T10:34:42Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-06-28T10:34:42Z"}, "message": "Use vector API for vbase list.\n\n\t* cp-tree.h: Include vec.h\n\t(DEF_VEC_P (tree)): New type.\n\t(struct lang_type_class): Change vbase's member type.\n\t(binfo_for_vbase): Declare.\n\t* class.c (determine_primary_base, base_derived_from,\n\tupdate_vtable_entry_for_fn, walk_subobject_offsets, end_of_class,\n\twarn_about_ambiguous_bases, dfs_accumulate_vtbl_inits,\n\tbuild_vtbl_initializer): Adjust.\n\t* decl.c (xref_basetypes): Adjust, accumulate upper bound of\n\tvbases.\n\t* init.c (sort_mem_initializers, expand_member_init,\n\tpush_base_cleanups): Adjust.\n\t* method.c (do_build_copy_constructor): Adjust.\n\t* search.c (get_pure_virtuals, copied_binfo, original_binfo): Adjust.\n\t(binfo_for_vbase): New.\n\t* tree.c (copy_base_binfos): Adjust.\n\nFrom-SVN: r83770", "tree": {"sha": "e397d9901439f8fe52024801150452e232238cd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e397d9901439f8fe52024801150452e232238cd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58c42dc28354d5857a5d905d505127eb5624111f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58c42dc28354d5857a5d905d505127eb5624111f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58c42dc28354d5857a5d905d505127eb5624111f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58c42dc28354d5857a5d905d505127eb5624111f/comments", "author": null, "committer": null, "parents": [{"sha": "ada5515102b96672d758a0263e6d16584ad8f58c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ada5515102b96672d758a0263e6d16584ad8f58c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ada5515102b96672d758a0263e6d16584ad8f58c"}], "stats": {"total": 236, "additions": 125, "deletions": 111}, "files": [{"sha": "14527cadeb62fd4d91602cb431f366c23f4a2ad2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c42dc28354d5857a5d905d505127eb5624111f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c42dc28354d5857a5d905d505127eb5624111f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=58c42dc28354d5857a5d905d505127eb5624111f", "patch": "@@ -1,3 +1,23 @@\n+2004-06-28  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tUse vector API for vbase list.\n+\t* cp-tree.h: Include vec.h\n+\t(DEF_VEC_P (tree)): New type.\n+\t(struct lang_type_class): Change vbase's member type.\n+\t(binfo_for_vbase): Declare.\n+\t* class.c (determine_primary_base, base_derived_from,\n+\tupdate_vtable_entry_for_fn, walk_subobject_offsets, end_of_class,\n+\twarn_about_ambiguous_bases, dfs_accumulate_vtbl_inits,\n+\tbuild_vtbl_initializer): Adjust.\n+\t* decl.c (xref_basetypes): Adjust, accumulate upper bound of\n+\tvbases.\n+\t* init.c (sort_mem_initializers, expand_member_init,\n+\tpush_base_cleanups): Adjust.\n+\t* method.c (do_build_copy_constructor): Adjust.\n+\t* search.c (get_pure_virtuals, copied_binfo, original_binfo): Adjust.\n+\t(binfo_for_vbase): New.\n+\t* tree.c (copy_base_binfos): Adjust.\n+\n 2004-06-28  Mark Mitchell  <mark@codesourcery.com>\n \n \t* parser.c (cp_parser_set_decl_spec_type): Fix thinko."}, {"sha": "8f188c494b980432d731be1406df8a2881d1487d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 42, "deletions": 51, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c42dc28354d5857a5d905d505127eb5624111f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c42dc28354d5857a5d905d505127eb5624111f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=58c42dc28354d5857a5d905d505127eb5624111f", "patch": "@@ -1344,9 +1344,9 @@ set_primary_base (tree t, tree binfo)\n static void\n determine_primary_base (tree t)\n {\n-  int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n-  tree vbases;\n+  unsigned i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n   tree type_binfo;\n+  tree vbase_binfo;\n \n   /* If there are no baseclasses, there is certainly no primary base.  */\n   if (n_baseclasses == 0)\n@@ -1394,29 +1394,26 @@ determine_primary_base (tree t)\n \n   /* Find the indirect primary bases - those virtual bases which are primary\n      bases of something else in this hierarchy.  */\n-  for (vbases = CLASSTYPE_VBASECLASSES (t);\n-       vbases;\n-       vbases = TREE_CHAIN (vbases)) \n+  for (i = 0; (vbase_binfo = VEC_iterate\n+\t       (tree, CLASSTYPE_VBASECLASSES (t), i)); i++)\n     {\n-      tree vbase_binfo = TREE_VALUE (vbases);\n+      unsigned j;\n \n-      /* See if this virtual base is an indirect primary base.  To be so,\n-         it must be a primary base within the hierarchy of one of our\n-         direct bases.  */\n-      for (i = 0; i < n_baseclasses; ++i) \n+      /* See if this virtual base is an indirect primary base.  To be\n+         so, it must be a primary base within the hierarchy of one of\n+         our direct bases.  */\n+      for (j = 0; j != n_baseclasses; ++j) \n \t{\n-\t  tree basetype = TYPE_BINFO_BASETYPE (t, i);\n-\t  tree v;\n-\n-\t  for (v = CLASSTYPE_VBASECLASSES (basetype); \n-\t       v; \n-\t       v = TREE_CHAIN (v))\n+\t  unsigned k;\n+\t  tree base_vbase_binfo;\n+\t  tree basetype = TYPE_BINFO_BASETYPE (t, j);\n+\t  \n+\t  for (k = 0; (base_vbase_binfo = VEC_iterate\n+\t\t       (tree, CLASSTYPE_VBASECLASSES (basetype), k)); k++)\n \t    {\n-\t      tree base_vbase = TREE_VALUE (v);\n-\t      \n-\t      if (BINFO_PRIMARY_P (base_vbase)\n-\t\t  && same_type_p (BINFO_TYPE (base_vbase),\n-\t                          BINFO_TYPE (vbase_binfo)))\n+\t      if (BINFO_PRIMARY_P (base_vbase_binfo)\n+\t\t  && same_type_p (BINFO_TYPE (base_vbase_binfo),\n+\t\t\t\t  BINFO_TYPE (vbase_binfo)))\n \t\t{\n \t\t  BINFO_INDIRECT_PRIMARY_P (vbase_binfo) = 1;\n \t\t  break;\n@@ -1923,9 +1920,8 @@ base_derived_from (tree derived, tree base)\n \t/* If we meet a virtual base, we can't follow the inheritance\n \t   any more.  See if the complete type of DERIVED contains\n \t   such a virtual base.  */\n-\treturn purpose_member (BINFO_TYPE (probe),\n-\t\t\t       CLASSTYPE_VBASECLASSES (BINFO_TYPE (derived)))\n-\t  != NULL_TREE;\n+\treturn (binfo_for_vbase (BINFO_TYPE (probe), BINFO_TYPE (derived))\n+\t\t!= NULL_TREE);\n     }\n   return false;\n }\n@@ -2169,10 +2165,8 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n \t/* Find the equivalent binfo within the return type of the\n \t   overriding function. We will want the vbase offset from\n \t   there.  */\n-\tvirtual_offset =\n-\t  TREE_VALUE (purpose_member\n-\t\t      (BINFO_TYPE (virtual_offset),\n-\t\t       CLASSTYPE_VBASECLASSES (TREE_TYPE (over_return))));\n+\tvirtual_offset = binfo_for_vbase (BINFO_TYPE (virtual_offset),\n+\t\t\t\t\t  TREE_TYPE (over_return));\n       else if (!same_type_p (TREE_TYPE (over_return),\n \t\t\t     TREE_TYPE (base_return)))\n \t{\n@@ -3314,21 +3308,19 @@ walk_subobject_offsets (tree type,\n \t    return r;\n \t}\n \n-      if (abi_version_at_least (2))\n+      if (abi_version_at_least (2) && CLASSTYPE_VBASECLASSES (type))\n \t{\n-\t  tree vbase;\n+\t  unsigned ix;\n \n \t  /* Iterate through the virtual base classes of TYPE.  In G++\n \t     3.2, we included virtual bases in the direct base class\n \t     loop above, which results in incorrect results; the\n \t     correct offsets for virtual bases are only known when\n \t     working with the most derived type.  */\n \t  if (vbases_p)\n-\t    for (vbase = CLASSTYPE_VBASECLASSES (type);\n-\t\t vbase;\n-\t\t vbase = TREE_CHAIN (vbase))\n+\t    for (ix = 0; (binfo = VEC_iterate\n+\t\t\t  (tree, CLASSTYPE_VBASECLASSES (type), ix)); ix++)\n \t      {\n-\t\tbinfo = TREE_VALUE (vbase);\n \t\tr = walk_subobject_offsets (binfo,\n \t\t\t\t\t    f,\n \t\t\t\t\t    size_binop (PLUS_EXPR,\n@@ -3345,7 +3337,8 @@ walk_subobject_offsets (tree type,\n \t      /* We still have to walk the primary base, if it is\n \t\t virtual.  (If it is non-virtual, then it was walked\n \t\t above.)  */\n-\t      vbase = get_primary_binfo (type_binfo);\n+\t      tree vbase = get_primary_binfo (type_binfo);\n+\t      \n \t      if (vbase && TREE_VIA_VIRTUAL (vbase)\n \t\t  && BINFO_PRIMARY_BASE_OF (vbase) == type_binfo)\n \t\t{\n@@ -4525,11 +4518,10 @@ end_of_class (tree t, int include_virtuals_p)\n \n   /* G++ 3.2 did not check indirect virtual bases.  */\n   if (abi_version_at_least (2) && include_virtuals_p)\n-    for (binfo = CLASSTYPE_VBASECLASSES (t); \n-\t binfo; \n-\t binfo = TREE_CHAIN (binfo))\n+    for (i = 0; (binfo = VEC_iterate\n+\t\t (tree, CLASSTYPE_VBASECLASSES (t), i)); i++)\n       {\n-\toffset = end_of_base (TREE_VALUE (binfo));\n+\toffset = end_of_base (binfo);\n \tif (INT_CST_LT_UNSIGNED (result, offset))\n \t  result = offset;\n       }\n@@ -4551,8 +4543,8 @@ static void\n warn_about_ambiguous_bases (tree t)\n {\n   int i;\n-  tree vbases;\n   tree basetype;\n+  tree binfo;\n \n   /* Check direct bases.  */\n   for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); ++i)\n@@ -4566,11 +4558,10 @@ warn_about_ambiguous_bases (tree t)\n \n   /* Check for ambiguous virtual bases.  */\n   if (extra_warnings)\n-    for (vbases = CLASSTYPE_VBASECLASSES (t); \n-\t vbases; \n-\t vbases = TREE_CHAIN (vbases))\n+    for (i = 0; (binfo = VEC_iterate\n+\t\t (tree, CLASSTYPE_VBASECLASSES (t), i)); i++)\n       {\n-\tbasetype = BINFO_TYPE (TREE_VALUE (vbases));\n+\tbasetype = BINFO_TYPE (binfo);\n \t\n \tif (!lookup_base (t, basetype, ba_ignore | ba_quiet, NULL))\n \t  warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n@@ -7272,8 +7263,7 @@ dfs_accumulate_vtbl_inits (tree binfo,\n \t either case, we share our vtable with LAST, i.e. the\n \t derived-most base within B of which we are a primary.  */\n       if (b == rtti_binfo\n-\t  || (b && purpose_member (BINFO_TYPE (b),\n-\t\t\t\t   CLASSTYPE_VBASECLASSES (BINFO_TYPE (rtti_binfo)))))\n+\t  || (b && binfo_for_vbase (BINFO_TYPE (b), BINFO_TYPE (rtti_binfo))))\n \t/* Just set our BINFO_VTABLE to point to LAST, as we may not have\n \t   set LAST's BINFO_VTABLE yet.  We'll extract the actual vptr in\n \t   binfo_ctor_vtable after everything's been set up.  */\n@@ -7351,8 +7341,9 @@ build_vtbl_initializer (tree binfo,\n {\n   tree v, b;\n   tree vfun_inits;\n-  tree vbase;\n   vtbl_init_data vid;\n+  unsigned ix;\n+  tree vbinfo;\n \n   /* Initialize VID.  */\n   memset (&vid, 0, sizeof (vid));\n@@ -7375,12 +7366,12 @@ build_vtbl_initializer (tree binfo,\n   VARRAY_TREE_INIT (vid.fns, 32, \"fns\");\n   /* Add the vcall and vbase offset entries.  */\n   build_vcall_and_vbase_vtbl_entries (binfo, &vid);\n+  \n   /* Clear BINFO_VTABLE_PATH_MARKED; it's set by\n      build_vbase_offset_vtbl_entries.  */\n-  for (vbase = CLASSTYPE_VBASECLASSES (t); \n-       vbase; \n-       vbase = TREE_CHAIN (vbase))\n-    BINFO_VTABLE_PATH_MARKED (TREE_VALUE (vbase)) = 0;\n+  for (ix = 0; (vbinfo = VEC_iterate\n+\t\t(tree, CLASSTYPE_VBASECLASSES (t), ix)); ix++)\n+    BINFO_VTABLE_PATH_MARKED (vbinfo) = 0;\n \n   /* If the target requires padding between data entries, add that now.  */\n   if (TARGET_VTABLE_DATA_ENTRY_DISTANCE > 1)"}, {"sha": "c2a943e9066c8ef6c3347374df7e704a1cd7907d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c42dc28354d5857a5d905d505127eb5624111f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c42dc28354d5857a5d905d505127eb5624111f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=58c42dc28354d5857a5d905d505127eb5624111f", "patch": "@@ -27,8 +27,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"function.h\"\n #include \"hashtab.h\"\n #include \"splay-tree.h\"\n+#include \"vec.h\"\n #include \"varray.h\"\n-\n #include \"c-common.h\"\n #include \"name-lookup.h\"\n \n@@ -1017,6 +1017,8 @@ struct lang_type_header GTY(())\n   BOOL_BITFIELD has_const_assign_ref : 1;\n };\n \n+DEF_VEC_P (tree);\n+\n /* This structure provides additional information above and beyond\n    what is provide in the ordinary tree_type.  In the past, we used it\n    for the types of class types, template parameters types, typename\n@@ -1087,7 +1089,7 @@ struct lang_type_class GTY(())\n   tree vcall_indices;\n   tree vtables;\n   tree typeinfo_var;\n-  tree vbases;\n+  VEC (tree) *vbases;\n   binding_table nested_udts;\n   tree as_base;\n   tree pure_virtuals;\n@@ -1305,7 +1307,7 @@ struct lang_type GTY(())\n #define CLASSTYPE_PRIMARY_BINFO(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->primary_base)\n \n-/* A chain of BINFOs for the direct and indirect virtual base classes\n+/* A vector of BINFOs for the direct and indirect virtual base classes\n    that this type uses in a post-order depth-first left-to-right\n    order.  (In other words, these bases appear in the order that they\n    should be initialized.)  */\n@@ -4121,6 +4123,7 @@ extern tree context_for_name_lookup\t\t(tree);\n extern tree lookup_conversions\t\t\t(tree);\n extern tree binfo_for_vtable\t\t\t(tree);\n extern tree binfo_from_vbase\t\t\t(tree);\n+extern tree binfo_for_vbase\t\t\t(tree, tree);\n extern tree look_for_overrides_here\t\t(tree, tree);\n extern int check_final_overrider\t\t(tree, tree);\n extern tree dfs_walk                            (tree,"}, {"sha": "11616c02dfcf7156503f411b6c7ccd2c1eada8e9", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c42dc28354d5857a5d905d505127eb5624111f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c42dc28354d5857a5d905d505127eb5624111f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=58c42dc28354d5857a5d905d505127eb5624111f", "patch": "@@ -9044,7 +9044,7 @@ xref_basetypes (tree ref, tree base_list)\n   /* In the declaration `A : X, Y, ... Z' we mark all the types\n      (A, X, Y, ..., Z) so we can check for duplicates.  */\n   tree *basep;\n-\n+  unsigned max_vbases = 0;\n   int i;\n   enum tag_types tag_code;\n \n@@ -9093,6 +9093,8 @@ xref_basetypes (tree ref, tree base_list)\n \t  tree basetype = TREE_VALUE (base_list);\n \t  tree base_binfo;\n \t  \n+\t  if (via_virtual)\n+\t    max_vbases++;\n \t  if (access == access_default_node)\n \t    /* The base of a derived struct is public by default.  */\n \t    access = (tag_code == class_type\n@@ -9169,13 +9171,17 @@ xref_basetypes (tree ref, tree base_list)\n \t     \t base as well.  */\n \t      TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref)\n \t\t|= TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (basetype);\n+\t      max_vbases += VEC_length\n+\t\t(tree, CLASSTYPE_VBASECLASSES (basetype));\n \t    }\n \t  i++;\n \t}\n       if (i)\n \tTREE_VEC_LENGTH (accesses) = TREE_VEC_LENGTH (binfos) = i;\n       else\n \tBINFO_BASEACCESSES (binfo) = BINFO_BASETYPES (binfo) = NULL_TREE;\n+      if (max_vbases)\n+\tCLASSTYPE_VBASECLASSES (ref) = VEC_alloc (tree, max_vbases);\n       \n       if (i > 1)\n \t{\n@@ -9189,7 +9195,6 @@ xref_basetypes (tree ref, tree base_list)\n   /* Copy the base binfos, collect the virtual bases and set the\n      inheritance order chain.  */\n   copy_base_binfos (TYPE_BINFO (ref), ref, NULL_TREE);\n-  CLASSTYPE_VBASECLASSES (ref) = nreverse (CLASSTYPE_VBASECLASSES (ref));\n \n   if (TYPE_FOR_JAVA (ref))\n     {"}, {"sha": "c96e14d8070b620213a14140f494aa4b75a8a23e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c42dc28354d5857a5d905d505127eb5624111f/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c42dc28354d5857a5d905d505127eb5624111f/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=58c42dc28354d5857a5d905d505127eb5624111f", "patch": "@@ -468,9 +468,12 @@ sort_mem_initializers (tree t, tree mem_inits)\n      TREE_VALUE will be the constructor arguments, or NULL if no\n      explicit initialization was provided.  */\n   sorted_inits = NULL_TREE;\n+  \n   /* Process the virtual bases.  */\n-  for (base = CLASSTYPE_VBASECLASSES (t); base; base = TREE_CHAIN (base))\n-    sorted_inits = tree_cons (TREE_VALUE (base), NULL_TREE, sorted_inits);\n+  for (i = 0; (base = VEC_iterate\n+\t       (tree, CLASSTYPE_VBASECLASSES (t), i)); i++)\n+    sorted_inits = tree_cons (base, NULL_TREE, sorted_inits);\n+  \n   /* Process the direct bases.  */\n   for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); ++i)\n     {\n@@ -988,13 +991,7 @@ expand_member_init (tree name)\n       /* Look for a virtual base -- unless the direct base is itself\n \t virtual.  */\n       if (!direct_binfo || !TREE_VIA_VIRTUAL (direct_binfo))\n-\t{\n-\t  virtual_binfo \n-\t    = purpose_member (basetype,\n-\t\t\t      CLASSTYPE_VBASECLASSES (current_class_type));\n-\t  if (virtual_binfo)\n-\t    virtual_binfo = TREE_VALUE (virtual_binfo);\n-\t}\n+\tvirtual_binfo = binfo_for_vbase (basetype, current_class_type);\n \n       /* [class.base.init]\n \t \n@@ -2874,27 +2871,23 @@ push_base_cleanups (void)\n   /* Run destructors for all virtual baseclasses.  */\n   if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n     {\n-      tree vbases;\n       tree cond = (condition_conversion\n \t\t   (build (BIT_AND_EXPR, integer_type_node,\n \t\t\t   current_in_charge_parm,\n \t\t\t   integer_two_node)));\n \n-      vbases = CLASSTYPE_VBASECLASSES (current_class_type);\n-      /* The CLASSTYPE_VBASECLASSES list is in initialization\n+      /* The CLASSTYPE_VBASECLASSES vector is in initialization\n \t order, which is also the right order for pushing cleanups.  */\n-      for (; vbases;\n-\t   vbases = TREE_CHAIN (vbases))\n+      for (i = 0; (binfos = VEC_iterate\n+\t\t   (tree, CLASSTYPE_VBASECLASSES (current_class_type), i));\n+\t   i++)\n \t{\n-\t  tree vbase = TREE_VALUE (vbases);\n-\t  tree base_type = BINFO_TYPE (vbase);\n-\n-\t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (base_type))\n+\t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (BINFO_TYPE (binfos)))\n \t    {\n \t      expr = build_special_member_call (current_class_ref, \n \t\t\t\t\t\tbase_dtor_identifier,\n \t\t\t\t\t\tNULL_TREE,\n-\t\t\t\t\t\tvbase,\n+\t\t\t\t\t\tbinfos,\n \t\t\t\t\t\t(LOOKUP_NORMAL \n \t\t\t\t\t\t | LOOKUP_NONVIRTUAL));\n \t      expr = build (COND_EXPR, void_type_node, cond,\n@@ -2948,17 +2941,19 @@ push_base_cleanups (void)\n tree\n build_vbase_delete (tree type, tree decl)\n {\n-  tree vbases = CLASSTYPE_VBASECLASSES (type);\n+  unsigned ix;\n+  tree binfo;\n   tree result;\n   tree addr = build_unary_op (ADDR_EXPR, decl, 0);\n \n   my_friendly_assert (addr != error_mark_node, 222);\n \n-  for (result = convert_to_void (integer_zero_node, NULL);\n-       vbases; vbases = TREE_CHAIN (vbases))\n+  result = convert_to_void (integer_zero_node, NULL);\n+  for (ix = 0; (binfo = VEC_iterate\n+\t\t(tree, CLASSTYPE_VBASECLASSES (type), ix)); ix++)\n     {\n       tree base_addr = convert_force\n-\t(build_pointer_type (BINFO_TYPE (TREE_VALUE (vbases))), addr, 0);\n+\t(build_pointer_type (BINFO_TYPE (binfo)), addr, 0);\n       tree base_delete = build_delete\n \t(TREE_TYPE (base_addr), base_addr, sfk_base_destructor,\n \t LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 0);"}, {"sha": "774f8c0dff1272efb80b70205baf8ea8a43b70a6", "filename": "gcc/cp/method.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c42dc28354d5857a5d905d505127eb5624111f/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c42dc28354d5857a5d905d505127eb5624111f/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=58c42dc28354d5857a5d905d505127eb5624111f", "patch": "@@ -523,17 +523,17 @@ do_build_copy_constructor (tree fndecl)\n       tree member_init_list = NULL_TREE;\n       int cvquals = cp_type_quals (TREE_TYPE (parm));\n       int i;\n+      tree binfo;\n \n       /* Initialize all the base-classes with the parameter converted\n \t to their type so that we get their copy constructor and not\n \t another constructor that takes current_class_type.  We must\n \t deal with the binfo's directly as a direct base might be\n \t inaccessible due to ambiguity.  */\n-      for (t = CLASSTYPE_VBASECLASSES (current_class_type); t;\n-\t   t = TREE_CHAIN (t))\n+      for (i = 0; (binfo = VEC_iterate\n+\t\t   (tree, CLASSTYPE_VBASECLASSES (current_class_type), i));\n+\t   i++)\n \t{\n-\t  tree binfo = TREE_VALUE (t);\n-\t  \n \t  member_init_list \n \t    = tree_cons (binfo,\n \t\t\t build_tree_list (NULL_TREE,"}, {"sha": "4bf87a3a73d1bac98862bb02b8bb9d29140a1517", "filename": "gcc/cp/search.c", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c42dc28354d5857a5d905d505127eb5624111f/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c42dc28354d5857a5d905d505127eb5624111f/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=58c42dc28354d5857a5d905d505127eb5624111f", "patch": "@@ -1921,7 +1921,8 @@ dfs_get_pure_virtuals (tree binfo, void *data)\n void\n get_pure_virtuals (tree type)\n {\n-  tree vbases;\n+  unsigned ix;\n+  tree binfo;\n \n   /* Clear the CLASSTYPE_PURE_VIRTUALS list; whatever is already there\n      is going to be overridden.  */\n@@ -1938,14 +1939,12 @@ get_pure_virtuals (tree type)\n   /* Put the pure virtuals in dfs order.  */\n   CLASSTYPE_PURE_VIRTUALS (type) = nreverse (CLASSTYPE_PURE_VIRTUALS (type));\n \n-  for (vbases = CLASSTYPE_VBASECLASSES (type); \n-       vbases; \n-       vbases = TREE_CHAIN (vbases))\n+  for (ix = 0; (binfo = VEC_iterate\n+\t\t(tree, CLASSTYPE_VBASECLASSES (type), ix)); ix++)\n     {\n       tree virtuals;\n-\n-      for (virtuals = BINFO_VIRTUALS (TREE_VALUE (vbases));\n-\t   virtuals;\n+      \n+      for (virtuals = BINFO_VIRTUALS (binfo); virtuals;\n \t   virtuals = TREE_CHAIN (virtuals))\n \t{\n \t  tree base_fndecl = BV_FN (virtuals);\n@@ -2532,10 +2531,8 @@ copied_binfo (tree binfo, tree here)\n       for (t = here; BINFO_INHERITANCE_CHAIN (t);\n \t   t = BINFO_INHERITANCE_CHAIN (t))\n \tcontinue;\n-      \n-      result = purpose_member (BINFO_TYPE (binfo),\n-\t\t\t       CLASSTYPE_VBASECLASSES (BINFO_TYPE (t)));\n-      result = TREE_VALUE (result);\n+\n+      result = binfo_for_vbase (BINFO_TYPE (binfo), BINFO_TYPE (t));\n     }\n   else if (BINFO_INHERITANCE_CHAIN (binfo))\n     {\n@@ -2566,6 +2563,19 @@ copied_binfo (tree binfo, tree here)\n   return result;\n }\n \n+tree\n+binfo_for_vbase (tree base, tree t)\n+{\n+  unsigned ix;\n+  tree binfo;\n+  \n+  for (ix = 0; (binfo = VEC_iterate\n+\t\t(tree, CLASSTYPE_VBASECLASSES (t), ix)); ix++)\n+    if (BINFO_TYPE (binfo) == base)\n+      return binfo;\n+  return NULL;\n+}\n+\n /* BINFO is some base binfo of HERE, within some other\n    hierarchy. Return the equivalent binfo, but in the hierarchy\n    dominated by HERE.  This is the inverse of copied_binfo.  If BINFO\n@@ -2579,12 +2589,9 @@ original_binfo (tree binfo, tree here)\n   if (BINFO_TYPE (binfo) == BINFO_TYPE (here))\n     result = here;\n   else if (TREE_VIA_VIRTUAL (binfo))\n-    {\n-      result = purpose_member (BINFO_TYPE (binfo),\n-\t\t\t       CLASSTYPE_VBASECLASSES (BINFO_TYPE (here)));\n-      if (result)\n-\tresult = TREE_VALUE (result);\n-    }\n+    result = (CLASSTYPE_VBASECLASSES (BINFO_TYPE (here))\n+\t      ? binfo_for_vbase (BINFO_TYPE (binfo), BINFO_TYPE (here))\n+\t      : NULL_TREE);\n   else if (BINFO_INHERITANCE_CHAIN (binfo))\n     {\n       tree base_binfos;"}, {"sha": "8ef808ce3b1882d411a758f0e8c0ec929469f5e0", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c42dc28354d5857a5d905d505127eb5624111f/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c42dc28354d5857a5d905d505127eb5624111f/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=58c42dc28354d5857a5d905d505127eb5624111f", "patch": "@@ -571,8 +571,8 @@ canonical_type_variant (tree t)\n    derived TYPE. PREV is the previous binfo, whose TREE_CHAIN we make\n    point to this binfo. We return the last BINFO created.\n \n-   The CLASSTYPE_VBASECLASSES list of T is constructed in reverse\n-   order (pre-order, depth-first, right-to-left). You must nreverse it.\n+   The CLASSTYPE_VBASECLASSES vector of T is constructed in the correct\n+   order.\n \n    The BINFO_INHERITANCE of a virtual base class points to the binfo\n    og the most derived type.\n@@ -613,12 +613,7 @@ copy_base_binfos (tree binfo, tree t, tree prev)\n \t  BINFO_DEPENDENT_BASE_P (new_binfo) = 1;\n \t}\n       else if (TREE_VIA_VIRTUAL (base_binfo))\n-\t{\n-\t  new_binfo = purpose_member (BINFO_TYPE (base_binfo),\n-\t\t\t\t      CLASSTYPE_VBASECLASSES (t));\n-\t  if (new_binfo)\n-\t    new_binfo = TREE_VALUE (new_binfo);\n-\t}\n+\tnew_binfo = binfo_for_vbase (BINFO_TYPE (base_binfo), t);\n       \n       if (!new_binfo)\n \t{\n@@ -628,9 +623,7 @@ copy_base_binfos (tree binfo, tree t, tree prev)\n \t  prev = copy_base_binfos (new_binfo, t, prev);\n \t  if (TREE_VIA_VIRTUAL (base_binfo))\n \t    {\n-\t      CLASSTYPE_VBASECLASSES (t)\n-\t\t= tree_cons (BINFO_TYPE (new_binfo), new_binfo,\n-\t\t\t     CLASSTYPE_VBASECLASSES (t));\n+\t      VEC_quick_push (tree, CLASSTYPE_VBASECLASSES (t), new_binfo);\n \t      TREE_VIA_VIRTUAL (new_binfo) = 1;\n \t      BINFO_INHERITANCE_CHAIN (new_binfo) = TYPE_BINFO (t);\n \t    }"}]}