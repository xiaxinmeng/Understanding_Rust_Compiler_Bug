{"sha": "93f82d608075a6d97a8064550286cb059d730667", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNmODJkNjA4MDc1YTZkOTdhODA2NDU1MDI4NmNiMDU5ZDczMDY2Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-03-20T00:49:13Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-03-20T00:49:13Z"}, "message": "except.c (current_function_has_exception_handlers): New.\n\n        * except.c (current_function_has_exception_handlers): New.\n        * except.h: Declare it.\n        * sibcall.c (optimize_sibling_and_tail_recursive_call): Use it.\n        Combine tests that disable all sibcalls for the function.\n\nFrom-SVN: r51054", "tree": {"sha": "8fe10615c6c1ebde7f73b98b8f2e1d6797bb0b38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fe10615c6c1ebde7f73b98b8f2e1d6797bb0b38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93f82d608075a6d97a8064550286cb059d730667", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93f82d608075a6d97a8064550286cb059d730667", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93f82d608075a6d97a8064550286cb059d730667", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93f82d608075a6d97a8064550286cb059d730667/comments", "author": null, "committer": null, "parents": [{"sha": "ed4fbfa016afc1ea8e340e2370416fd2ca9c21c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed4fbfa016afc1ea8e340e2370416fd2ca9c21c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed4fbfa016afc1ea8e340e2370416fd2ca9c21c6"}], "stats": {"total": 44, "additions": 37, "deletions": 7}, "files": [{"sha": "cd732d7c1a2a28d272670cce346cdbe013a15ce1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f82d608075a6d97a8064550286cb059d730667/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f82d608075a6d97a8064550286cb059d730667/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93f82d608075a6d97a8064550286cb059d730667", "patch": "@@ -1,3 +1,10 @@\n+2002-03-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* except.c (current_function_has_exception_handlers): New.\n+\t* except.h: Declare it.\n+\t* sibcall.c (optimize_sibling_and_tail_recursive_call): Use it.\n+\tCombine tests that disable all sibcalls for the function.\n+\n 2002-03-19  Olivier Hainque  <hainque@act-europe.fr>\n \n \t* varasm.c (output_constant_def): Don't call ENCODE_SECTION_INFO"}, {"sha": "fa92368ec8d4465805a8e6b91ee47802f46b8fb1", "filename": "gcc/except.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f82d608075a6d97a8064550286cb059d730667/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f82d608075a6d97a8064550286cb059d730667/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=93f82d608075a6d97a8064550286cb059d730667", "patch": "@@ -1401,6 +1401,23 @@ find_exception_handler_labels ()\n   exception_handler_labels = list;\n }\n \n+bool\n+current_function_has_exception_handlers ()\n+{\n+  int i;\n+\n+  for (i = cfun->eh->last_region_number; i > 0; --i)\n+    {\n+      struct eh_region *region = cfun->eh->region_array[i];\n+\n+      if (! region || region->region_number != i)\n+\tcontinue;\n+      if (region->type != ERT_THROW)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n \f\n static struct eh_region *\n duplicate_eh_region_1 (o, map)"}, {"sha": "27dc7143f6c03c7cec31e99b3ad78bafd130d6e5", "filename": "gcc/except.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f82d608075a6d97a8064550286cb059d730667/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f82d608075a6d97a8064550286cb059d730667/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=93f82d608075a6d97a8064550286cb059d730667", "patch": "@@ -120,6 +120,7 @@ extern void maybe_remove_eh_handler\t\tPARAMS ((rtx));\n extern void convert_from_eh_region_ranges\tPARAMS ((void));\n extern void convert_to_eh_region_ranges\t\tPARAMS ((void));\n extern void find_exception_handler_labels\tPARAMS ((void));\n+extern bool current_function_has_exception_handlers PARAMS ((void));\n extern void output_function_exception_table\tPARAMS ((void));\n \n extern void expand_builtin_unwind_init\t\tPARAMS ((void));"}, {"sha": "5a7997cb0387aaedc12bfadedc1e1fa011b12c89", "filename": "gcc/sibcall.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f82d608075a6d97a8064550286cb059d730667/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f82d608075a6d97a8064550286cb059d730667/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=93f82d608075a6d97a8064550286cb059d730667", "patch": "@@ -572,7 +572,7 @@ optimize_sibling_and_tail_recursive_calls ()\n {\n   rtx insn, insns;\n   basic_block alternate_exit = EXIT_BLOCK_PTR;\n-  int current_function_uses_addressof;\n+  bool no_sibcalls_this_function = false;\n   int successful_sibling_call = 0;\n   int replaced_call_placeholder = 0;\n   edge e;\n@@ -595,6 +595,12 @@ optimize_sibling_and_tail_recursive_calls ()\n   if (n_basic_blocks == 0)\n     return;\n \n+  /* If we are using sjlj exceptions, we may need to add a call to \n+     _Unwind_SjLj_Unregister at exit of the function.  Which means\n+     that we cannot do any sibcall transformations.  */\n+  if (USING_SJLJ_EXCEPTIONS && current_function_has_exception_handlers ())\n+    no_sibcalls_this_function = true;\n+\n   return_value_pseudo = NULL_RTX;\n \n   /* Find the exit block.\n@@ -655,7 +661,7 @@ optimize_sibling_and_tail_recursive_calls ()\n \n   /* If the function uses ADDRESSOF, we can't (easily) determine\n      at this point if the value will end up on the stack.  */\n-  current_function_uses_addressof = sequence_uses_addressof (insns);\n+  no_sibcalls_this_function |= sequence_uses_addressof (insns);\n \n   /* Walk the insn chain and find any CALL_PLACEHOLDER insns.  We need to\n      select one of the insn sequences attached to each CALL_PLACEHOLDER.\n@@ -685,11 +691,10 @@ optimize_sibling_and_tail_recursive_calls ()\n \n \t  /* See if there are any reasons we can't perform either sibling or\n \t     tail call optimizations.  We must be careful with stack slots\n-\t     which are live at potential optimization sites.  ??? The first\n-\t     test is overly conservative and should be replaced.  */\n-\t  if (frame_offset\n-\t      /* Can't take address of local var if used by recursive call.  */\n-\t      || current_function_uses_addressof\n+\t     which are live at potential optimization sites.  */\n+\t  if (no_sibcalls_this_function\n+\t      /* ??? Overly conservative.  */\n+\t      || frame_offset\n \t      /* Any function that calls setjmp might have longjmp called from\n \t\t any called function.  ??? We really should represent this\n \t\t properly in the CFG so that this needn't be special cased.  */"}]}