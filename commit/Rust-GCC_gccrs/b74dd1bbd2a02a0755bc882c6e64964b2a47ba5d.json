{"sha": "b74dd1bbd2a02a0755bc882c6e64964b2a47ba5d", "node_id": "C_kwDOANBUbNoAKGI3NGRkMWJiZDJhMDJhMDc1NWJjODgyYzZlNjQ5NjRiMmE0N2JhNWQ", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-11-06T12:05:39Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-11-08T14:17:14Z"}, "message": "Use bit-CCP in range-ops.\n\nAfter Jakub and Richi's suggestion of using the same representation\nfor tracking known bits as we do in CCP, I took a peek at the code and\nrealized there's a plethora of bit-tracking code there that we could\nbe sharing with range-ops.  For example, the multiplication\noptimizations are way better than what I had cobbled together.  For\nthat matter, our maybe nonzero tracking as a whole has a lot of room\nfor improvement.  Being the lazy ass that I am, I think we should just\nuse one code base (CCP's).\n\nThis patch provides a thin wrapper for converting the irange maybe\nnonzero bits to what CCP requires, and uses that to call into\nbit_value_binop().  I have so far converted the MULT_EXPR range-op\nentry to use it, as the DIV_EXPR entry we have gets a case CCP doesn't\nget so I'd like to contribute the enhancement to CCP before converting\nover.\n\nI'd like to use this approach with the dozen or so tree_code's that\nare handled in CCP, thus saving us from having to implement any of\nthem :).\n\nEarly next season I'd like to change irange's internal representation\nto a pair of value / mask, and start tracking all known bits.  This\nties in nicely with our plan for tracking known set bits.\n\nPerhaps if the stars align, we could merge the bit twiddling in CCP\ninto range-ops and have a central repository for it.  That is, once we\nmake the switch to wide-ints, and assuming there are no performance\nissues.  Note that range-ops is our lowest level abstraction.\ni.e. it's just the math, there's no GORI or ranger, or even the\nconcept of a symbolic or SSA.\n\ngcc/ChangeLog:\n\n\t* range-op.cc (irange_to_masked_value): New.\n\t(update_known_bitmask): New.\n\t(operator_mult::fold_range): Call update_known_bitmask.", "tree": {"sha": "e370ae531c043421fde6d528f95e6a99d3e0c5dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e370ae531c043421fde6d528f95e6a99d3e0c5dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b74dd1bbd2a02a0755bc882c6e64964b2a47ba5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b74dd1bbd2a02a0755bc882c6e64964b2a47ba5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b74dd1bbd2a02a0755bc882c6e64964b2a47ba5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b74dd1bbd2a02a0755bc882c6e64964b2a47ba5d/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ca912b46e0eb45ebefeb0eda4c28afe1513d272", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ca912b46e0eb45ebefeb0eda4c28afe1513d272", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ca912b46e0eb45ebefeb0eda4c28afe1513d272"}], "stats": {"total": 64, "additions": 49, "deletions": 15}, "files": [{"sha": "846931ddcae5a96e7fd222705df0110aea246cd3", "filename": "gcc/range-op.cc", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b74dd1bbd2a02a0755bc882c6e64964b2a47ba5d/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b74dd1bbd2a02a0755bc882c6e64964b2a47ba5d/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=b74dd1bbd2a02a0755bc882c6e64964b2a47ba5d", "patch": "@@ -46,6 +46,54 @@ along with GCC; see the file COPYING3.  If not see\n #include \"wide-int.h\"\n #include \"value-relation.h\"\n #include \"range-op.h\"\n+#include \"tree-ssa-ccp.h\"\n+\n+// Convert irange bitmasks into a VALUE MASK pair suitable for calling CCP.\n+\n+static void\n+irange_to_masked_value (const irange &r, widest_int &value, widest_int &mask)\n+{\n+  if (r.singleton_p ())\n+    {\n+      mask = 0;\n+      value = widest_int::from (r.lower_bound (), TYPE_SIGN (r.type ()));\n+    }\n+  else\n+    {\n+      mask = widest_int::from (r.get_nonzero_bits (), TYPE_SIGN (r.type ()));\n+      value = 0;\n+    }\n+}\n+\n+// Update the known bitmasks in R when applying the operation CODE to\n+// LH and RH.\n+\n+static void\n+update_known_bitmask (irange &r, tree_code code,\n+\t\t      const irange &lh, const irange &rh)\n+{\n+  if (r.undefined_p () || lh.undefined_p () || rh.undefined_p ())\n+    return;\n+\n+  widest_int value, mask, lh_mask, rh_mask, lh_value, rh_value;\n+  tree type = r.type ();\n+  signop sign = TYPE_SIGN (type);\n+  int prec = TYPE_PRECISION (type);\n+  signop lh_sign = TYPE_SIGN (lh.type ());\n+  signop rh_sign = TYPE_SIGN (rh.type ());\n+  int lh_prec = TYPE_PRECISION (lh.type ());\n+  int rh_prec = TYPE_PRECISION (rh.type ());\n+\n+  irange_to_masked_value (lh, lh_value, lh_mask);\n+  irange_to_masked_value (rh, rh_value, rh_mask);\n+  bit_value_binop (code, sign, prec, &value, &mask,\n+\t\t   lh_sign, lh_prec, lh_value, lh_mask,\n+\t\t   rh_sign, rh_prec, rh_value, rh_mask);\n+\n+  int_range<2> tmp (type);\n+  tmp.set_nonzero_bits (value | mask);\n+  r.intersect (tmp);\n+}\n \n // Return the upper limit for a type.\n \n@@ -1775,21 +1823,7 @@ operator_mult::fold_range (irange &r, tree type,\n   if (!cross_product_operator::fold_range (r, type, lh, rh, trio))\n     return false;\n \n-  if (lh.undefined_p ())\n-    return true;\n-\n-  tree t;\n-  if (rh.singleton_p (&t))\n-    {\n-      wide_int w = wi::to_wide (t);\n-      int shift = wi::exact_log2 (w);\n-      if (shift != -1)\n-\t{\n-\t  wide_int nz = lh.get_nonzero_bits ();\n-\t  nz = wi::lshift (nz, shift);\n-\t  r.set_nonzero_bits (nz);\n-\t}\n-    }\n+  update_known_bitmask (r, MULT_EXPR, lh, rh);\n   return true;\n }\n "}]}