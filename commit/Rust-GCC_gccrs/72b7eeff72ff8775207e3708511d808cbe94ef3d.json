{"sha": "72b7eeff72ff8775207e3708511d808cbe94ef3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJiN2VlZmY3MmZmODc3NTIwN2UzNzA4NTExZDgwOGNiZTk0ZWYzZA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-12-19T06:51:14Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-12-19T06:51:14Z"}, "message": "76th Cygnus<->FSF merge\n\nFrom-SVN: r10815", "tree": {"sha": "44f132baadba7e87b171112daeea334c32f37dc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44f132baadba7e87b171112daeea334c32f37dc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72b7eeff72ff8775207e3708511d808cbe94ef3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72b7eeff72ff8775207e3708511d808cbe94ef3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72b7eeff72ff8775207e3708511d808cbe94ef3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72b7eeff72ff8775207e3708511d808cbe94ef3d/comments", "author": null, "committer": null, "parents": [{"sha": "f82da7d270d2bf27905b338f28622c3546ad9306", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f82da7d270d2bf27905b338f28622c3546ad9306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f82da7d270d2bf27905b338f28622c3546ad9306"}], "stats": {"total": 1595, "additions": 1163, "deletions": 432}, "files": [{"sha": "bfa05f6189fdef10903bbdcb8f9b970dd60309e9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 443, "deletions": 103, "changes": 546, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -1,3 +1,336 @@\n+Mon Dec 18 15:51:33 1995  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cp-tree.h, decl2.c (flag_weak): New flag to control the use of\n+ \tweak symbols.\t\n+\t* lang-options.h: Add -f{no-,}weak.\n+\t* decl.c (init_decl_processing): If the target does not support weak\n+\tsymbols, don't use them.\n+\t* decl2.c, pt.c: s/SUPPORTS_WEAK/flag_weak/.\n+\n+Sun Dec 17 21:13:23 1995  Rusty Russell  <rusty@adelaide.maptek.com.au>\n+\n+\t* init.c (expand_member_init): warning for base init after members.\n+\n+Sun Dec 17 22:06:56 1995  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* tree.c (tree_copy_lang_decl_for_deferred_output): Handle\n+\tCONST_DECLs correctly.\n+\n+Fri Dec 15 15:32:18 1995  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cvt.c (build_expr_type_conversion): Don't convert to a reference\n+\ttype.\n+\n+Thu Dec 14 16:05:58 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* method.c (report_type_mismatch): Improve wording for volatile\n+\tmismatches.\n+\n+Thu Dec 14 14:16:26 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* init.c (expand_aggr_init_1): Use expand_aggr_init_1 instead of\n+ \texpand_assignment, as the later doesn't handle things that have\n+\tcopy constructors well.  The compiler would do bitwise copying,\n+\tinstead of ctor calling in some cases.\n+\n+Wed Dec 13 17:05:54 PST 1995  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* g++.c (my_strerror): Return \"cannot access\" if errno is 0.\n+\t(pfatal_with_name, perror_exec): Don't assume that\n+\tthe returned value from my_strerror contains no '%'s.\n+\t(concat): Remove.\n+\t(sys_nerror): Declare only if HAVE_STRERROR is not defined.\n+\n+Wed Dec 13 16:22:38 1995  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\tLose CLASSTYPE_METHODS/DECL_NEXT_METHOD chain; make\n+\tTYPE_METHODS/TREE_CHAIN mean what they used to.\t\n+\t* decl2.c (constructor_name_full): Refer to CLASSTYPE_METHOD_VEC\n+\tinstead of TYPE_METHODS.\n+\t* decl.c (duplicate_decls): Lose references to DECL_NEXT_METHOD.\n+\t* tree.c (tree_copy_lang_decl_for_deferred_output): Ditto.\n+\t* cp-tree.h (CLASSTYPE_METHODS): Lose.\n+\t(CLASSTYPE_METHOD_VEC): Point to lang_spec->methods instead of\n+\tTYPE_METHODS.\n+\t(struct lang_decl): Lose next_method field.\n+\t(DECL_NEXT_METHOD): Lose.\n+\t* class.c (finish_struct_methods): Don't mess with TYPE_METHODS.\n+\t(finish_struct): Just use TYPE_METHODS; we don't need fn_fields\n+\tanymore.\n+\t(finish_struct_methods): Don't mess with the TREE_CHAINs in\n+\tfn_fields.\n+\n+\t* search.c (add_conversions): Don't use TREE_CHAIN to traverse method\n+\tvector.\n+\n+\t* call.c (build_method_call): Synthesize here even when not inlining.\n+\t* typeck.c (build_function_call_real): Ditto.\n+\n+Wed Dec 13 15:02:39 1995  Ian Lance Taylor  <ian@cygnus.com>\n+\n+\t* cp/lex.c (check_newline): If DBX_DEBUGGING_INFO and write_symbols\n+\t== DBX_DEBUG, call dbxout_start_new_source_file and\n+\tdbxout_resume_previous_source_file when appropriate.\n+\n+Tue Dec 12 20:38:55 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (start_anon_func): Push to the top level.\n+\t(end_anon_func): Pop from the top level.\n+\n+Mon Dec 11 18:56:14 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cp-tree.h (build_cleanup): New routine to build cleanups.\n+\t* decl.c (expand_static_init): Use build_cleanup to build a cleanup\n+\tcall at ctor time and use atexit to run it later.\n+\t* decl2.c (build_cleanup): New routine, taken from finish_file.\n+\t(finish_file): Use build_cleanup instead, and don't put function\n+\tlocal statics in global dtor list.\n+\t\n+Wed Dec  6 14:34:29 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_throw): Ensure that we have cleanups, if we try\n+\tand expand cleanups.\n+\n+Wed Dec  6 11:48:21 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_throw): Add logic to manage dynamic cleanups for\n+\tthe EH object.\n+\t(expand_end_catch_block): Use the magic of expand_goto, instead of\n+\temit_jump so that we get the cleanup for any catch clause parameter\n+\tand the cleanup for the exception object.  Update to reflect label\n+\tchanges.\n+\t(push_eh_cleanup): New routine to register a cleanup for an\n+\texception object.\n+ \t(empty_fndecl): Used to default cleanup actions to\n+\tnothing.\n+\t(init_exception_processing): Setup empty_fndecl.  Setup\n+\tsaved_cleanup.\n+\t(expand_start_catch_block): Update to reflect label changes.  Call\n+\tpush_eh_object to register the cleanup for the EH object.\n+\t(start_anon_func): New routine to start building lambda expressions\n+\tfrom trees.\n+\t(end_anon_func): New routine to end them.\n+\t(struct labelNode): Change so that we can use tree labels, or rtx\n+\tlabels.\n+\t(saved_cleanup): Object to check for dynamic cleanups for the\n+\texception handling object.\n+\t(push_label_entry): Change so that we can use tree labels, or rtx\n+\tlabels.\n+\t(pop_label_entry): Ditto.\n+\t(top_label_entry): Ditto.\n+\t(expand_start_all_catch): Use tree label instead of rtx label, so\n+\tthat we can get the magic of expand_goto.\n+\t(expand_end_all_catch): Update to reflect label changes.\n+\n+\t* class.c (build_vfn_ref): Remove building_cleanup logic, as we now\n+\tuse UNSAVE_EXPRs.\n+\ttypeck.c (get_member_function_from_ptrfunc): Remove remnants of\n+\tbuilding_cleanup logic, as we now use UNSAVE_EXPRs.\n+\t* cp-tree.h (unsave_expr): Declare it.\n+\t* decl.c (building_cleanup): Remove.\n+\t(maybe_build_cleanup): Remove building_cleanup logic, and use\n+\tUNSAVE_EXPR instead.\n+\n+Sun Dec  3 01:34:58 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* gc.c (build_t_desc): Update error message to say <typeinfo>.\n+\n+Thu Nov 30 12:30:05 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl.c (pushdecl): Only warn about shadowing a local variable if\n+\twarn_shadow is true.\n+\n+Sun Nov 26 16:06:55 1995  Rusty Russell  <rusty@adelaide.maptek.com.au>\n+\n+\t* typeck.c (build_binary_op_nodefault): Added warning about\n+\tcomparisons between different enum types with -Wall, unless\n+\t-fenum-int-equiv set.\n+\n+Wed Nov 22 15:44:02 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* class.c (finish_struct_1): Skip down to the inner type in\n+\tmultidimensional arrays.  Ensures ctors will be made for types that\n+\tneed constructing.\n+\n+Wed Nov 22 14:19:22 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (last_dtor_insn): New to track the last compiler generated\n+\tinsn in a dtor.\n+\t(store_parm_decls): Set it.\n+\t(finish_function): Use it to see if the dtor is empty.  Avoid doing\n+\tvtable setup all the time, if we can.\n+\t(struct cp_function): Add last_dtor_insn.\n+\t(push_cp_function_context): Save it.\n+\t(pop_cp_function_context): Restore it.\n+\n+Wed Nov 22 11:52:19 1995  Paul Russell  <Rusty.Russell@adelaide.maptek.com.au>\n+\n+\t* typeck.c (build_unary_op): Set TREE_NO_UNUSED_WARNING to avoid\n+ \twarnings.\n+\n+Tue Nov 21 17:15:23 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (expand_target_expr): Make sure targets get put into the\n+\tcurrent temp_slot_level, so that the free_temp_slots call will reuse\n+\tthem.\n+\n+Tue Nov 21 13:32:03 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* class.c (finish_struct_1): Delay delta fixups for virtual bases\n+\tuntil after we have done the hard virtuals, to avoid a bogus `every\n+\tvirtual function must have a unique final overrider' for virtual\n+\tfunctions that are only overridden by hard virtuals.\n+\n+Thu Nov  9 13:35:30 1995  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (do_function_instantiation): Don't try to find a file-scope\n+ \ttemplate for a member function.\n+\n+Tue Nov 14 06:20:35 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* g++.c (main): Add handling of -nodefaultlibs.\n+\n+Mon Nov 13 15:45:34 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cp-tree.h (INDIRECT_BIND): Add a way for the frontend to\n+\tdistinguish between direct bindings of reference variables, and\n+\tindirect bindings of reference variables.\n+\t* cvt.c (build_up_reference): Use it.\n+\t* typeck.c (convert_arguments): Use it to indicate this is an\n+\tindirect binding.\n+\t* decl.c (cp_finish_decl): Ensure that we reuse stack slots as fast\n+\tas they are unused.\n+\t(expand_static_init): Diotto.\n+\t(cplus_expand_expr_stmt): Ditto.\n+\t* decl2.c (finish_file): Ditto.\n+\t* init.c (perform_member_init): Ditto.\n+\t(emit_base_init): Ditto.\n+\t(expand_aggr_vbase_init_1): Ditto.\n+\n+Fri Nov 10 09:19:31 1995  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* tree.c (tree_copy_lang_decl_for_deferred_output): Handle\n+\tcopying of DECL_ARGUMENTS field.\n+\t(tree_copy_lang_type_for_deferred_output): Handle disgusting\n+\tre-use of TYPE_LANG_SPECIFIC for pointer to member function\n+\ttype nodes.\n+\n+Fri Nov 10 09:18:09 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl.c (push_namespace): Rewrite to use build_lang_decl, so we\n+\tget a DECL_LANG_SPECIFIC node.\n+\t* cp-tree.h (lang_decl_flags): Add new member `level'.\n+\t(NAMESPACE_LEVEL): Don't use decl.arguments, instead use the\n+\tdecl_flags level member.\n+\n+Mon Nov  6 18:36:13 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* call.c (build_method_call): Make sure instance has a\n+\tTYPE_LANG_SPECIFIC node before we dive into it.  \n+\n+Sat Nov  4 20:01:52 1995  Jason Molenda  (crash@phydeaux.cygnus.com)\n+\n+\t* method.c (make_thunk): use TREE_SET_CODE to set thunk's tree code.\n+\n+Thu Nov  2 17:56:57 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (duplicate_decls): When smashing decls, smash staticness in\n+\tthe usual way.\n+\n+Thu Nov  2 16:44:02 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (poplevel): Handle the merging of subblocks of cleanups\n+\twhen finishing blocks that have already been created (usually due to\n+\tthe fixup goto code).  Fixes bad debugging information.\n+\n+Wed Nov  1 12:33:53 1995  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* method.c (hack_identifier): Don't abort when we get a TREE_LIST\n+\tthat's not a list of overloaded functions.\n+\n+Wed Nov  1 11:38:58 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl2.c (mark_vtable_entries): Check DECL_LANG_SPECIFIC on fn\n+\tbefore trying to use DECL_ABSTRACT_VIRTUAL_P.\n+\n+Tue Oct 31 11:56:55 1995  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c (mark_used): New function for hooking into setting of\n+\tTREE_USED on decls.\n+\t* call.c (build_method_call): Use it.\n+\t* class.c (instantiate_type): Ditto.\n+\t* init.c (build_offset_ref): Ditto.  Don't call assemble_external\n+\tfor all like-named functions.\n+\t* method.c (hack_identifier): Ditto.\n+\t(emit_thunk): Don't call assemble_external.\n+\t(make_thunk): Create thunk as a FUNCTION_DECL so that it\n+\tgets the right mode and ENCODE_SECTION_INFO works.\n+\t\n+\t* parse.y: Use mark_used.  Pass operator names to do_identifier.\n+\t* lex.c (do_identifier): Handle operator names.\n+\n+\t* decl2.c (grokclassfn): Tweak __in_chrg attributes.\n+\n+Thu Oct 26 20:58:59 1995  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* cp/tree.c (tree_copy_lang_decl_for_deferred_output): Handle\n+\tFIELD_DECLs and VAR_DECLs correctly.\n+\n+Thu Oct 26 16:45:58 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* errfn.c: Include stdio.h.\n+\t(cp_sprintf): Take out decl of sprintf, and cast sprintf to errorfn*.\n+\n+Wed Oct 25 18:58:41 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck2.c (digest_init): Always convert initializers to the\n+\tright type.\n+\n+Wed Oct 25 13:25:24 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* init.c (member_init_ok_or_else): Don't allow member initializers\n+\tfor indirect members, as it is invalid.\n+\n+Wed Oct 25 11:35:28 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl.c (grokdeclarator): Don't allow `friend signed ()'.\n+\n+Fri Oct 20 10:30:59 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* parse.y (for.init.statement): Catch compound statements inside for\n+\tinitializations, if we're being pedantic.\n+\n+Fri Oct 20 10:03:42 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (lookup_tag): Return NULL_TREE if we don't find what we are\n+\tlooking for.\n+\n+Thu Oct 19 14:26:10 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* error.c (dump_expr): Don't core dump when a boolean expression is\n+\tused as a default argument.\n+\n+Thu Oct 19 10:36:30 1995  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* class.c (finish_struct_bits): Check aggregate_value_p instead of\n+ \tRETURN_IN_MEMORY.\n+\n+Wed Oct 18 18:12:32 1995  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* class.c (finish_struct_bits): Also set TREE_ADDRESSABLE on a\n+\tBLKmode type that would otherwise be returned in registers.\n+\n+Mon Oct 16 12:32:19 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* g++.c (WITHLIBC): New macro.\n+\t(main): Declare saw_libc.  Use WITHLIBC if `-lc' was used; set\n+\tsaw_libc and pass it at the end if it was set.\n+\n+Wed Oct 11 16:30:34 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* parse.y (fn.def1): Call split_specs_attrs in\n+\tdeclmods notype_declarator case.\n+\n Mon Nov 20 14:06:28 1995  Mike Stump  <mrs@cygnus.com>\n \n \t* Version 2.7.2 released.\n@@ -811,10 +1144,6 @@ Wed Jul  5 14:05:04 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>\n \t* typeck.c (comptypes, case OFFSET_REF): If either offset basetype\n \tis a TEMPLATE_TYPE_PARM, give a match.\n \n-Mon Jul  3 15:17:20 1995  Steve Chamberlain  <sac@slash.cygnus.com>\n-\n-\t* g++.c (sys/file.h): Remove change of Jun 28.\n-\n Fri Jun 30 15:42:57 1995  Mike Stump  <mrs@cygnus.com>\n \n \t* method.c (build_overload_value): Handle encoding of null pointer\n@@ -862,12 +1191,6 @@ Thu Jun 29 03:43:55 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \t* decl.c (revert_static_member_fn): But only if DECL_ARGUMENTS is\n \tset.\n \n-Wed Jun 28 23:34:58 1995  Steve Chamberlain  <sac@slash.cygnus.com>\n-\n-\t* g++.c (pfatal_with_name):  Use my_strerror to get error\n-\tstring.\n-\t(sys/file.h): Include if HAVE_FILE_H defined.\n-\n Wed Jun 28 18:39:03 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n \t* decl.c (revert_static_member_fn): Also remove 'this' from\n@@ -985,14 +1308,8 @@ Fri Jun 16 13:20:38 1995  Mike Stump  <mrs@cygnus.com>\n \t* decl.c (get_unique_name): New routine to name unnamed namespaces.\n \t(push_namespace): Use get_unique_name for naming unnamed namespaces.\n \n-Fri Jun 16 15:07:29 1995  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)\n-\n-\t* Make-lang.in (DEMANGLER_PROG): Add LIBS.\n-\n Thu Jun 15 15:00:41 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n-\t* decl.c (define_function): Don't set DECL_INTERFACE_KNOWN.\n-\n \t* parse.y: Call cplus_decl_attributes with prefix_attributes where\n \tappropriate.\n \n@@ -1037,23 +1354,6 @@ Thu Jun  8 15:44:38 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \t* gc.c (build_dynamic_cast): Build up a reference to a parameter of\n \taggregate type.\n \n-Wed Jun  7 20:00:31 1995  Mike Stump  <mrs@cygnus.com>\n-\n-\t* *.[chy]: Change all callers of finish_decl to cp_finish_decl.\n-\t* decl.c (finish_decl): New routine to handle call backs from the\n-\tmid end (declare_hidden_char_array).\n-\n-Wed Jun  7 19:02:50 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n-\n-\t* decl.c (start_function): Handle setting C_C_D here.\n-\t(set_C_C_D): Removed.\n-\t(struct saved_scope): Remove class_decl.\n-\t(push_to_top_level): Don't save current_class_decl.\n-\t(pop_from_top_level): Don't restore current_class_decl or C_C_D.\n-\t(struct cp_function): Add C_C_D.\n-\t(push_cp_function_context): Save C_C_D.\n-\t(pop_cp_function_context): Restore C_C_D.\n-\n Wed Jun  7 15:31:57 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n \n \t* init.c (build_vec_delete): Resolve an offset ref before we try to\n@@ -1155,29 +1455,6 @@ Mon Jun  5 11:20:34 1995  Gerald Baumgartner  (gb@alexander.cs.purdue.edu)\n \tto tag and delta, respectively.\n \t(build_signature_method_call): Ditto.  Use above variables.\n \n-Fri Jun  2 11:05:58 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n-\n-\t* decl.c (set_C_C_D): New function.  suspend_momentary before\n-\tbuilding C_C_D.\n-\t(pop_from_top_level): Call it.\n-\t(start_function): Ditto.\n-\t(pop_cp_function_context): Ditto.\n-\n-\t* class.c, cp-tree.h, decl.c, decl2.c, parse.y: Lose all references\n-\tto current_vtable_decl, CLASSTYPE_INST_VAR and CLASSTYPE_VTBL_PTR.\n-\n-\t* decl.c (push_cp_function_context): Save current_class_decl.\n-\t(pop_cp_function_context): Restore current_class_decl and set C_C_D.\n-\t(pop_from_top_level): Don't use CLASSTYPE_INST_VAR to set C_C_D.\n-\t(start_function): Ditto.\n-\n-\t* class.c (popclass): Don't mess with current_class_decl,\n-\tcurrent_vtable_decl, or C_C_D.\n-\n-Mon May 29 12:45:10 1995  Paul Eggert  <eggert@twinsun.com>\n-\n-\t* Make-lang.in (c++.mostlyclean): Remove $(DEMANGLER_PROG).\n-\n Thu Jun  1 17:03:51 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n \t* decl.c (lookup_name_real): Don't try to look anything up in an\n@@ -1209,6 +1486,58 @@ Wed May 31 11:39:43 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \treference type.\n \t(build_indirect_ref): Fix check for *&.\n \n+Fri Jun 16 06:54:03 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* Version 2.7.0 released.\n+\n+Fri Jun 16 15:07:29 1995  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)\n+\n+\t* Make-lang.in (DEMANGLER_PROG): Add LIBS.\n+\n+Thu Jun 15 15:00:41 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (define_function): Don't set DECL_INTERFACE_KNOWN.\n+\n+Wed Jun  7 20:00:31 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* *.[chy]: Change all callers of finish_decl to cp_finish_decl.\n+\t* decl.c (finish_decl): New routine to handle call backs from the\n+\tmid end (declare_hidden_char_array).\n+\n+Wed Jun  7 19:02:50 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (start_function): Handle setting C_C_D here.\n+\t(set_C_C_D): Removed.\n+\t(struct saved_scope): Remove class_decl.\n+\t(push_to_top_level): Don't save current_class_decl.\n+\t(pop_from_top_level): Don't restore current_class_decl or C_C_D.\n+\t(struct cp_function): Add C_C_D.\n+\t(push_cp_function_context): Save C_C_D.\n+\t(pop_cp_function_context): Restore C_C_D.\n+\n+Fri Jun  2 11:05:58 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (set_C_C_D): New function.  suspend_momentary before\n+\tbuilding C_C_D.\n+\t(pop_from_top_level): Call it.\n+\t(start_function): Ditto.\n+\t(pop_cp_function_context): Ditto.\n+\n+\t* class.c, cp-tree.h, decl.c, decl2.c, parse.y: Lose all references\n+\tto current_vtable_decl, CLASSTYPE_INST_VAR and CLASSTYPE_VTBL_PTR.\n+\n+\t* decl.c (push_cp_function_context): Save current_class_decl.\n+\t(pop_cp_function_context): Restore current_class_decl and set C_C_D.\n+\t(pop_from_top_level): Don't use CLASSTYPE_INST_VAR to set C_C_D.\n+\t(start_function): Ditto.\n+\n+\t* class.c (popclass): Don't mess with current_class_decl,\n+\tcurrent_vtable_decl, or C_C_D.\n+\n+Mon May 29 12:45:10 1995  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* Make-lang.in (c++.mostlyclean): Remove $(DEMANGLER_PROG).\n+\n Wed May 24 15:55:18 1995  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)\n \n \t* decl.c (duplicate_decls): Check simple_cst_equal result against 0.\n@@ -3366,11 +3695,6 @@ Mon Jan  9 18:16:23 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \t(pushdecl): Set the nested typename if the decl doesn't have one,\n \trather than if the type's canonical decl doesn't have one.\n \n-Mon Jan  9 16:48:16 1995  Steve Chamberlain  (sac@jonny.cygnus.com)\n-\n-\t* typeck.c (pointer_int_sum):  Use offset size when calculating\n-\tindex expression.\n-\n Mon Jan  9 03:44:33 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n \t* typeck.c (convert_for_assignment): Complain about contravariance\n@@ -3778,11 +4102,6 @@ Thu Nov 17 20:11:24 1994  Doug Evans  <dje@cygnus.com>\n \t(c++.install-man): Use program_transform_name on g++.1.\n \t(c++.uninstall): Likewise.\n \n-Thu Nov  3 18:48:19 1994  Paul Eggert  <eggert@twinsun.com>\n-\n-\t* Makefile.in (spew.o, lex.o, pt.o):\n-\tDepend on $(srcdir)/parse.h, not parse.h.\n-\n Mon Nov 28 13:53:03 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* parse.y (THROW): Fix precedence of throw expressions.\n@@ -3833,43 +4152,6 @@ Thu Nov 17 15:30:50 1994  Mike Stump  <mrs@cygnus.com>\n \tto add support for explicit, namespace, typename, and using, support\n \tfor the rest is already in.\n \n-Thu Nov 17 10:56:50 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n-\n-\t* typeck2.c (build_m_component_ref): Check the basetype of the\n-\tmember pointer against the main variant of the object type.\n-\n-Mon Nov 14 14:21:52 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n-\n-\t* cvt.c (convert_to_reference): Make sure that the original expr\n-\tgets its type back when converting a reference.\n-\n-\t* method.c (build_overload_name): Clear numeric_outputed_need_bar here.\n-\t(build_decl_overload): Instead of here.\n-\n-Tue Nov  8 17:11:24 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n-\n-\t* cvt.c (cp_convert): Don't build a TARGET_EXPR if we're not in a\n-\tfunction.\n-\n-\t* typeck.c (convert_for_initialization): Handle initialization from\n-\ta TARGET_EXPR.\n-\n-Sun Nov  6 01:34:24 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n-\n-\t* pt.c (lookup_nested_type_by_name): Fix list-walking logic.\n-\t(tsubst): When replacing a TEMPLATE_TYPE_PARM, propagate\n-\tTYPE_READONLY and TYPE_VOLATILE from the argument.\n-\t(unify): When unifying with a TEMPLATE_TYPE_PARM, remove cv-quals\n-\tpresent in parm from arg.\n-\t(type_unification): Strip REFERENCE_TYPE from the argument type.\n-\t(unify): Don't strip REFERENCE_TYPE from the argument type.\n-\n-Sat Nov  5 22:42:15 1994  Greg McGary  (gkm@magilla.cichlid.com)\n-\n-\t* pt.c (do_type_instantiation): Check to see if there's a\n-\tIDENTIFIER_TEMPLATE on a class before calling\n-\tinstantiate_member_templates().\n-\n Fri Nov  4 19:04:18 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* gc.c (get_bad_cast_node): New routine to support compile time\n@@ -3964,6 +4246,60 @@ Tue Oct 25 13:37:41 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n \t* call.c (convert_harshness): Check for TREE_UNSIGNED differences\n \tafter checking for integral conversions.\n \n+Wed Nov 30 19:13:50 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* Version 2.6.3 released.\n+\n+Thu Nov 17 10:56:50 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck2.c (build_m_component_ref): Check the basetype of the\n+\tmember pointer against the main variant of the object type.\n+\n+Mon Nov 14 14:21:52 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* cvt.c (convert_to_reference): Make sure that the original expr\n+\tgets its type back when converting a reference.\n+\n+\t* method.c (build_overload_name): Clear numeric_outputed_need_bar here.\n+\t(build_decl_overload): Instead of here.\n+\n+Tue Nov  8 17:11:24 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* cvt.c (cp_convert): Don't build a TARGET_EXPR if we're not in a\n+\tfunction.\n+\n+\t* typeck.c (convert_for_initialization): Handle initialization from\n+\ta TARGET_EXPR.\n+\n+Sun Nov  6 01:34:24 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n+\n+\t* pt.c (lookup_nested_type_by_name): Fix list-walking logic.\n+\t(tsubst): When replacing a TEMPLATE_TYPE_PARM, propagate\n+\tTYPE_READONLY and TYPE_VOLATILE from the argument.\n+\t(unify): When unifying with a TEMPLATE_TYPE_PARM, remove cv-quals\n+\tpresent in parm from arg.\n+\t(type_unification): Strip REFERENCE_TYPE from the argument type.\n+\t(unify): Don't strip REFERENCE_TYPE from the argument type.\n+\n+Sat Nov  5 22:42:15 1994  Greg McGary  (gkm@magilla.cichlid.com)\n+\n+\t* pt.c (do_type_instantiation): Check to see if there's a\n+\tIDENTIFIER_TEMPLATE on a class before calling\n+\tinstantiate_member_templates().\n+\n+Sat Nov 12 06:35:42 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* Version 2.6.2 released.\n+\n+Thu Nov  3 18:48:19 1994  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* Makefile.in (spew.o, lex.o, pt.o):\n+\tDepend on $(srcdir)/parse.h, not parse.h.\n+\n+Tue Nov  1 19:19:41 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* Version 2.6.1 released.\n+\n Sun Oct 23 13:19:55 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n \n \t* decl2.c: Declare flag_access_control.\n@@ -4946,6 +5282,10 @@ Tue Jul 19 17:55:37 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* call.c (build_method_call): Accept using a typedef name (or\n \ttemplate type parameter) for explicit destructor calls.\n \n+Thu Jul 14 09:42:23 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* Version 2.6.0 released.\n+\n Wed Jul 13 03:57:54 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* method.c (hack_identifier): Put back old code so lists of"}, {"sha": "973deaa38d1011c492866c449037ffc1f1b2c4f7", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -1658,6 +1658,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n     }\n   /* We already know whether it's needed or not for vec delete.  */\n   else if (name == ansi_opname[(int) VEC_DELETE_EXPR]\n+\t   && TYPE_LANG_SPECIFIC (TREE_TYPE (instance))\n \t   && ! TYPE_VEC_DELETE_TAKES_SIZE (TREE_TYPE (instance)))\n     TREE_CHAIN (parms) = NULL_TREE;\n \n@@ -2464,17 +2465,13 @@ build_method_call (instance, name, parms, basetype_path, flags)\n     return build_signature_method_call (basetype, instance, function, parms);\n \n   function = DECL_MAIN_VARIANT (function);\n-  /* Declare external function if necessary. */\n-  assemble_external (function);\n+  mark_used (function);\n \n-#if 1\n   /* Is it a synthesized method that needs to be synthesized?  */\n-  if (DECL_ARTIFICIAL (function) && ! flag_no_inline\n-      && ! DECL_INITIAL (function)\n+  if (DECL_ARTIFICIAL (function) && ! DECL_INITIAL (function)\n       /* Kludge: don't synthesize for default args.  */\n       && current_function_decl)\n     synthesize_method (function);\n-#endif\n \n   if (pedantic && DECL_THIS_INLINE (function) && ! DECL_ARTIFICIAL (function)\n        && ! DECL_INITIAL (function) && ! DECL_PENDING_INLINE_INFO (function))\n@@ -2670,7 +2667,6 @@ build_method_call (instance, name, parms, basetype_path, flags)\n     if (TREE_CODE (function) == FUNCTION_DECL)\n       {\n \tis_constructor = DECL_CONSTRUCTOR_P (function);\n-\tTREE_USED (function) = 1;\n \tfunction = default_conversion (function);\n       }\n     else"}, {"sha": "fc25b1a9781a8efcc547a6284e0c31620b3ed09f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 59, "deletions": 48, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -424,7 +424,6 @@ build_vfn_ref (ptr_to_instptr, instance, idx)\n      tree *ptr_to_instptr, instance;\n      tree idx;\n {\n-  extern int building_cleanup;\n   tree vtbl, aref;\n   tree basetype = TREE_TYPE (instance);\n \n@@ -481,7 +480,7 @@ build_vfn_ref (ptr_to_instptr, instance, idx)\n \n   /* Save the intermediate result in a SAVE_EXPR so we don't have to\n      compute each component of the virtual function pointer twice.  */ \n-  if (!building_cleanup && TREE_CODE (aref) == INDIRECT_REF)\n+  if (TREE_CODE (aref) == INDIRECT_REF)\n     TREE_OPERAND (aref, 0) = save_expr (TREE_OPERAND (aref, 0));\n \n   if (flag_vtable_thunks)\n@@ -1720,8 +1719,14 @@ finish_struct_bits (t, max_has_virtual)\n   /* If this type has a copy constructor, force its mode to be BLKmode, and\n      force its TREE_ADDRESSABLE bit to be nonzero.  This will cause it to\n      be passed by invisible reference and prevent it from being returned in\n-     a register.  */\n-  if (! TYPE_HAS_TRIVIAL_INIT_REF (t))\n+     a register.\n+\n+     Also do this if the class has BLKmode but can still be returned in\n+     registers, since function_cannot_inline_p won't let us inline\n+     functions returning such a type.  This affects the HP-PA.  */\n+  if (! TYPE_HAS_TRIVIAL_INIT_REF (t)\n+      || (TYPE_MODE (t) == BLKmode && ! aggregate_value_p (t)\n+\t  && CLASSTYPE_NON_AGGREGATE (t)))\n     {\n       tree variants;\n       if (TREE_CODE (TYPE_NAME (t)) == TYPE_DECL)\n@@ -1812,15 +1817,14 @@ grow_method (fn, method_vec_ptr)\n    us to reduce search time in places like `build_method_call' to\n    consider only reasonably likely functions.  */\n \n-static tree\n+tree\n finish_struct_methods (t, fn_fields, nonprivate_method)\n      tree t;\n      tree fn_fields;\n      int nonprivate_method;\n {\n   tree method_vec;\n-  tree save_fn_fields = tree_cons (NULL_TREE, NULL_TREE, fn_fields);\n-  tree lastp;\n+  tree save_fn_fields = fn_fields;\n   tree name = constructor_name (t);\n   int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n \n@@ -1837,7 +1841,7 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n   /* First fill in entry 0 with the constructors, and the next few with\n      type conversion operators (if any).  */\n \n-  for (lastp = save_fn_fields; fn_fields; fn_fields = TREE_CHAIN (lastp))\n+  for (; fn_fields; fn_fields = TREE_CHAIN (fn_fields))\n     {\n       tree fn_name = DECL_NAME (fn_fields);\n       if (fn_name == NULL_TREE)\n@@ -1887,26 +1891,17 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \n \t  grow_method (fn_fields, &method_vec);\n \t}\n-      else\n-\t{\n-\t  lastp = fn_fields;\n-\t  continue;\n-\t}\n-\n-      TREE_CHAIN (lastp) = TREE_CHAIN (fn_fields);\n-      TREE_CHAIN (fn_fields) = NULL_TREE;\n     }\n \n-  fn_fields = TREE_CHAIN (save_fn_fields);\n-  while (fn_fields)\n+  fn_fields = save_fn_fields;\n+  for (; fn_fields; fn_fields = TREE_CHAIN (fn_fields))\n     {\n-      tree nextp;\n       tree fn_name = DECL_NAME (fn_fields);\n       if (fn_name == NULL_TREE)\n \tfn_name = name;\n \n-      nextp = TREE_CHAIN (fn_fields);\n-      TREE_CHAIN (fn_fields) = NULL_TREE;\n+      if (fn_name == name || IDENTIFIER_TYPENAME_P (fn_name))\n+\tcontinue;\n \n       if (fn_name == ansi_opname[(int) MODIFY_EXPR])\n \t{\n@@ -1922,7 +1917,6 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \t}\n \n       grow_method (fn_fields, &method_vec);\n-      fn_fields = nextp;\n     }\n \n   TREE_VEC_LENGTH (method_vec) = (tree *)obstack_next_free (&class_obstack)\n@@ -2005,6 +1999,7 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \tobstack_free (current_obstack, baselink_vec);\n     }\n \n+#if 0\n   /* Now add the methods to the TYPE_METHODS of T, arranged in a chain.  */\n   {\n     tree x, last_x = NULL_TREE;\n@@ -2040,6 +2035,7 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n   }\n \n   TYPE_METHODS (t) = method_vec;\n+#endif\n \n   return method_vec;\n }\n@@ -2765,7 +2761,7 @@ finish_struct_1 (t, warn_anon)\n   tree name = TYPE_IDENTIFIER (t);\n   enum tree_code code = TREE_CODE (t);\n   tree fields = TYPE_FIELDS (t);\n-  tree fn_fields = CLASSTYPE_METHODS (t);\n+  tree fn_fields = TYPE_METHODS (t);\n   tree x, last_x, method_vec;\n   int needs_virtual_dtor;\n   int all_virtual;\n@@ -2920,7 +2916,7 @@ finish_struct_1 (t, warn_anon)\n   else\n     all_virtual = 0;\n \n-  for (x = CLASSTYPE_METHODS (t); x; x = TREE_CHAIN (x))\n+  for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n     {\n       GNU_xref_member (current_class_name, x);\n \n@@ -3197,7 +3193,7 @@ finish_struct_1 (t, warn_anon)\n \t{\n \t  tree type = TREE_TYPE (x);\n \n-\t  if (TREE_CODE (type) == ARRAY_TYPE)\n+\t  while (TREE_CODE (type) == ARRAY_TYPE)\n \t    type = TREE_TYPE (type);\n \n \t  if (TYPE_LANG_SPECIFIC (type) && ! ANON_UNION_P (x)\n@@ -3681,19 +3677,6 @@ finish_struct_1 (t, warn_anon)\n \t      }\n \t  }\n \t}\n-\n-      /* Now fixup any virtual function entries from virtual bases\n-\t that have different deltas.  */\n-      vbases = CLASSTYPE_VBASECLASSES (t);\n-      while (vbases)\n-\t{\n-\t  /* We might be able to shorten the amount of work we do by\n-\t     only doing this for vtables that come from virtual bases\n-\t     that have differing offsets, but don't want to miss any\n-\t     entries.  */\n-\t  fixup_vtable_deltas (vbases, 1, t);\n-\t  vbases = TREE_CHAIN (vbases);\n-\t}\n     }\n \n   /* Set up the DECL_FIELD_BITPOS of the vfield if we need to, as we\n@@ -3736,6 +3719,27 @@ finish_struct_1 (t, warn_anon)\n \t\t\t  TREE_VALUE (pending_hard_virtuals));\n       pending_hard_virtuals = TREE_CHAIN (pending_hard_virtuals);\n     }\n+  \n+  if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n+    {\n+      tree vbases;\n+      /* Now fixup any virtual function entries from virtual bases\n+\t that have different deltas.  This has to come after we do the\n+\t pending hard virtuals, as we might have a function that comes\n+\t from multiple virtual base instances that is only overridden\n+\t by a hard virtual above.  */\n+      vbases = CLASSTYPE_VBASECLASSES (t);\n+      while (vbases)\n+\t{\n+\t  /* We might be able to shorten the amount of work we do by\n+\t     only doing this for vtables that come from virtual bases\n+\t     that have differing offsets, but don't want to miss any\n+\t     entries.  */\n+\t  fixup_vtable_deltas (vbases, 1, t);\n+\t  vbases = TREE_CHAIN (vbases);\n+\t}\n+    }\n+\n   doing_hard_virtuals = 0;\n \n   /* Under our model of GC, every C++ class gets its own virtual\n@@ -4045,8 +4049,8 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n      tree list_of_fieldlists;\n      int warn_anon;\n {\n-  tree fields = NULL_TREE, fn_fields, *tail;\n-  tree *tail_user_methods = &CLASSTYPE_METHODS (t);\n+  tree fields = NULL_TREE;\n+  tree *tail = &TYPE_METHODS (t);\n   tree name = TYPE_NAME (t);\n   tree x, last_x = NULL_TREE;\n   enum access_type access;\n@@ -4071,7 +4075,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   if (IS_SIGNATURE (t))\n     append_signature_fields (list_of_fieldlists);\n \n-  tail = &fn_fields;\n   if (last_x && list_of_fieldlists)\n     TREE_CHAIN (last_x) = TREE_VALUE (list_of_fieldlists);\n \n@@ -4130,11 +4133,9 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t    {\n \t      if (last_x)\n \t\tTREE_CHAIN (last_x) = TREE_CHAIN (x);\n-\t      /* Link x onto end of fn_fields and CLASSTYPE_METHODS. */\n+\t      /* Link x onto end of TYPE_METHODS. */\n \t      *tail = x;\n \t      tail = &TREE_CHAIN (x);\n-\t      *tail_user_methods = x;\n-\t      tail_user_methods = &DECL_NEXT_METHOD (x);\n \t      continue;\n \t    }\n \n@@ -4167,12 +4168,12 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n     }\n \n   *tail = NULL_TREE;\n-  *tail_user_methods = NULL_TREE;\n   TYPE_FIELDS (t) = fields;\n \n   if (0 && processing_template_defn)\n     {\n-      CLASSTYPE_METHOD_VEC (t) = finish_struct_methods (t, fn_fields, 1);\n+      CLASSTYPE_METHOD_VEC (t)\n+\t= finish_struct_methods (t, TYPE_METHODS (t), 1);\n       return t;\n     }\n   else\n@@ -4671,6 +4672,7 @@ instantiate_type (lhstype, rhs, complain)\n \t\t  return error_mark_node;\n \t\treturn build_vfn_ref (&base_ptr, base, DECL_VINDEX (function));\n \t      }\n+\t    mark_used (function);\n \t    return function;\n \t  }\n \n@@ -4687,6 +4689,7 @@ instantiate_type (lhstype, rhs, complain)\n \tif (field)\n \t  {\n \t    TREE_OPERAND (rhs, 1) = field;\n+\t    mark_used (field);\n \t    return rhs;\n \t  }\n \n@@ -4760,7 +4763,10 @@ instantiate_type (lhstype, rhs, complain)\n \t      if (! comptypes (lhstype, TREE_TYPE (elem), 1))\n \t\telem = DECL_CHAIN (elem);\n \t      else\n-\t\treturn elem;\n+\t\t{\n+\t\t  mark_used (elem);\n+\t\t  return elem;\n+\t\t}\n \n \t    /* No exact match found, look for a compatible template.  */\n \t    {\n@@ -4815,6 +4821,7 @@ instantiate_type (lhstype, rhs, complain)\n \t\t      }\n \t\t    return error_mark_node;\n \t\t  }\n+\t\tmark_used (save_elem);\n \t\treturn save_elem;\n \t      }\n \t    if (complain)\n@@ -4848,7 +4855,10 @@ instantiate_type (lhstype, rhs, complain)\n \t    elem = TREE_VALUE (baselink);\n \t    while (elem)\n \t      if (comptypes (lhstype, TREE_TYPE (elem), 1))\n-\t\treturn elem;\n+\t\t{\n+\t\t  mark_used (elem);\n+\t\t  return elem;\n+\t\t}\n \t      else\n \t\telem = DECL_CHAIN (elem);\n \t  }\n@@ -4874,6 +4884,7 @@ instantiate_type (lhstype, rhs, complain)\n \t\t      error (\"ambiguous overload for overloaded method requested\");\n \t\t    return error_mark_node;\n \t\t  }\n+\t\tmark_used (save_elem);\n \t\treturn save_elem;\n \t      }\n \t    name = DECL_NAME (TREE_VALUE (rhs));"}, {"sha": "ddea5755751da193a172ea2005fcd5ac8fdd4f86", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -636,10 +636,6 @@ struct lang_type\n /* The is the VAR_DECL that contains NODE's rtti.  */\n #define CLASSTYPE_RTTI(NODE) (TYPE_LANG_SPECIFIC(NODE)->rtti)\n \n-/* List of all explicit methods (chained using DECL_NEXT_METHOD),\n-   in order they were parsed. */\n-#define CLASSTYPE_METHODS(NODE) (TYPE_LANG_SPECIFIC(NODE)->methods)\n-\n /* Nonzero means that this _CLASSTYPE node overloads operator().  */\n #define TYPE_OVERLOADS_CALL_EXPR(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_call_overloaded)\n \n@@ -660,7 +656,7 @@ struct lang_type\n #define TYPE_USES_VIRTUAL_BASECLASSES(NODE) (TREE_LANG_FLAG_3(NODE))\n \n /* List of lists of member functions defined in this class.  */\n-#define CLASSTYPE_METHOD_VEC(NODE) TYPE_METHODS(NODE)\n+#define CLASSTYPE_METHOD_VEC(NODE) (TYPE_LANG_SPECIFIC(NODE)->methods)\n \n /* The first type conversion operator in the class (the others can be\n    searched with TREE_CHAIN), or the first non-constructor function if\n@@ -924,7 +920,7 @@ struct lang_type\n #define TYPE_RAISES_EXCEPTIONS(NODE) TYPE_NONCOPIED_PARTS (NODE)\n \n /* The binding level associated with the namespace. */\n-#define NAMESPACE_LEVEL(NODE) ((NODE)->decl.arguments)\n+#define NAMESPACE_LEVEL(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.level)\n \f\n struct lang_decl_flags\n {\n@@ -960,6 +956,7 @@ struct lang_decl_flags\n   tree access;\n   tree context;\n   tree memfunc_pointer_to;\n+  struct binding_level *level;\n };\n \n struct lang_decl\n@@ -969,7 +966,6 @@ struct lang_decl\n   struct template_info *template_info;\n   tree main_decl_variant;\n   struct pending_inline *pending_inline_info;\n-  tree next_method;\n   tree chain;\n };\n \n@@ -1068,9 +1064,6 @@ struct lang_decl\n #define DECL_CHAIN(NODE) (TREE_CHAIN (NODE))\n #endif\n \n-/* Next method in CLASSTYPE_METHODS list. */\n-#define DECL_NEXT_METHOD(NODE) (DECL_LANG_SPECIFIC(NODE)->next_method)\n-\n /* In a VAR_DECL for a variable declared in a for statement,\n    this is the shadowed variable. */\n #define DECL_SHADOWED_FOR_VAR(NODE) DECL_RESULT(NODE)\n@@ -1401,6 +1394,9 @@ extern int flag_new_for_scope;\n #define UPT_TEMPLATE(NODE)      TREE_PURPOSE(TYPE_VALUES(NODE))\n #define UPT_PARMS(NODE)         TREE_VALUE(TYPE_VALUES(NODE))\n \n+#define builtin_function(NAME, TYPE, CODE, LIBNAME) \\\n+  define_function (NAME, TYPE, CODE, (void (*)())pushdecl, LIBNAME)\n+\n /* An enumeration of the kind of tags that C++ accepts.  */\n enum tag_types { record_type, class_type, union_type, enum_type,\n \t\t   signature_type };\n@@ -1809,6 +1805,12 @@ extern int flag_alt_external_templates;\n \n extern int flag_implicit_templates;\n \n+/* Nonzero if we want to emit defined symbols with common-like linkage as\n+   weak symbols where possible, in order to conform to C++ semantics.\n+   Otherwise, emit them as local symbols.  */\n+\n+extern int flag_weak;\n+\n /* Current end of entries in the gc obstack for stack pointer variables.  */\n \n extern int current_function_obstack_index;\n@@ -1844,6 +1846,9 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n    LOOKUP_HAS_IN_CHARGE means that the \"in charge\" variable is already\n      in the parameter list.\n    LOOKUP_ONLYCONVERTING means that non-conversion constructors are not tried.\n+   INDIRECT_BIND means that if a temporary is created, it should be created so\n+     that it lives only as long as WITH_CLEANUP_EXPRs live, else if a temporary\n+     is created then it should live as long as the current variable bindings.\n    LOOKUP_SPECULATIVELY means return NULL_TREE if we cannot find what we are\n      after.  Note, LOOKUP_COMPLAIN is checked and error messages printed\n      before LOOKUP_SPECULATIVELY is checked.\n@@ -1860,7 +1865,7 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n #define LOOKUP_HAS_IN_CHARGE (32)\n #define LOOKUP_SPECULATIVELY (64)\n #define LOOKUP_ONLYCONVERTING (128)\n-/* 256 is free */\n+#define INDIRECT_BIND (256)\n #define LOOKUP_NO_CONVERSION (512)\n #define LOOKUP_DESTRUCTOR (512)\n \n@@ -2131,6 +2136,8 @@ extern void init_exception_processing\t\tPROTO((void));\n extern void expand_builtin_throw\t\tPROTO((void));\n extern void expand_start_eh_spec\t\tPROTO((void));\n extern void expand_end_eh_spec\t\t\tPROTO((tree));\n+extern tree build_cleanup\t\t\tPROTO((tree));\n+extern tree start_anon_func\t\t\tPROTO((void));\n \n /* in expr.c */\n /* skip cplus_expand_expr */\n@@ -2395,6 +2402,7 @@ extern tree array_type_nelts_total\t\tPROTO((tree));\n extern tree array_type_nelts_top\t\tPROTO((tree));\n extern tree break_out_target_exprs\t\tPROTO((tree));\n extern tree build_unsave_expr\t\t\tPROTO((tree));\n+extern tree unsave_expr\t\t\t\tPROTO((tree));\n extern int cp_expand_decl_cleanup\t\tPROTO((tree, tree));\n \n /* in typeck.c */"}, {"sha": "a4e28ff583d06bcbd722b6b2b59488763831b30e", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -311,6 +311,7 @@ convert_to_pointer_force (type, expr)\n    value we have to begin with is in ARG.\n \n    FLAGS controls how we manage access checking.\n+   INDIRECT_BIND in FLAGS controls how any temporarys are generated.\n    CHECKCONST controls if we report error messages on const subversion.  */\n static tree\n build_up_reference (type, arg, flags, checkconst)\n@@ -589,7 +590,15 @@ build_up_reference (type, arg, flags, checkconst)\n     {\n       tree temp;\n \n-      if (TREE_CODE (targ) == CALL_EXPR && IS_AGGR_TYPE (argtype))\n+      if (flags&INDIRECT_BIND)\n+\t{\n+\t  tree slot = build (VAR_DECL, argtype);\n+\t  layout_decl (slot, 0);\n+\t  rval = build (TARGET_EXPR, argtype, slot, arg, 0);\n+\t  rval = build1 (ADDR_EXPR, type, rval);\n+\t  goto done;\n+\t}\n+      else if (TREE_CODE (targ) == CALL_EXPR && IS_AGGR_TYPE (argtype))\n \t{\n \t  temp = build_cplus_new (argtype, targ, 1);\n \t  if (TREE_CODE (temp) == WITH_CLEANUP_EXPR)\n@@ -1634,8 +1643,13 @@ build_expr_type_conversion (desires, expr, complain)\n     }\n \n   if (winner)\n-    return build_type_conversion_1 (TREE_VALUE (winner), basetype, expr,\n-\t\t\t\t    TREE_PURPOSE (winner), 1);\n+    {\n+      tree type = TREE_VALUE (winner);\n+      if (TREE_CODE (type) == REFERENCE_TYPE)\n+\ttype = TREE_TYPE (type);\n+      return build_type_conversion_1 (type, basetype, expr,\n+\t\t\t\t      TREE_PURPOSE (winner), 1);\n+    }\n \n   return NULL_TREE;\n }"}, {"sha": "f639140bfee2138a4474e96781f5bfb9c8aae06d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 179, "deletions": 58, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -38,6 +38,7 @@ Boston, MA 02111-1307, USA.  */\n #include <sys/types.h>\n #include <signal.h>\n #include \"obstack.h\"\n+#include \"defaults.h\"\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n@@ -267,6 +268,11 @@ tree vtbl_type_node;\n \n tree dtor_label;\n \n+/* In a destructor, the last insn emitted after the start of the\n+   function and the parms.  */\n+\n+rtx last_dtor_insn;\n+\n /* In a constructor, the point at which we are ready to return\n    the pointer to the initialized object.  */\n \n@@ -1092,15 +1098,30 @@ poplevel (keep, reverse, functionbody)\n     block = make_node (BLOCK);\n   if (block != NULL_TREE)\n     {\n-      BLOCK_VARS (block) = decls;\n-      BLOCK_TYPE_TAGS (block) = tags;\n-      BLOCK_SUBBLOCKS (block) = subblocks;\n-      /* If we created the block earlier on, and we are just diddling it now,\n-\t then it already should have a proper BLOCK_END_NOTE value associated\n-\t with it, so avoid trashing that.  Otherwise, for a new block, install\n-\t a new BLOCK_END_NOTE value.  */\n-      if (! block_previously_created)\n-\tremember_end_note (block);\n+      if (block_previously_created)\n+\t{\n+\t  if (decls || tags || subblocks)\n+\t    {\n+\t      if (BLOCK_VARS (block) || BLOCK_TYPE_TAGS (block) || BLOCK_SUBBLOCKS (block))\n+\t\t{\n+\t\t  warning (\"internal compiler error: debugging info corrupted\");\n+\t\t}\n+\t      BLOCK_VARS (block) = decls;\n+\t      BLOCK_TYPE_TAGS (block) = tags;\n+\t      /* Recover from too many blocks by chaining them together. */\n+\t      BLOCK_SUBBLOCKS (block) = chainon (BLOCK_SUBBLOCKS (block), subblocks);\n+\t    }\n+\t  /* If we created the block earlier on, and we are just diddling it now, then\n+\t     it already should have a proper BLOCK_END_NOTE value associated with it.  */\n+\t}\n+      else\n+\t{\n+\t  BLOCK_VARS (block) = decls;\n+\t  BLOCK_TYPE_TAGS (block) = tags;\n+\t  BLOCK_SUBBLOCKS (block) = subblocks;\n+\t  /* Otherwise, for a new block, install a new BLOCK_END_NOTE value.  */\n+\t  remember_end_note (block);\n+\t}\n     }\n \n   /* In each subblock, record that this is its superior.  */\n@@ -1700,20 +1721,19 @@ push_namespace (name)\n   extern tree current_namespace;\n   tree old_id = get_namespace_id ();\n   char *buf;\n-  tree d = make_node (NAMESPACE_DECL);\n+  tree d;\n \n   if (! name)\n     {\n       /* Create a truly ugly name! */\n       name = get_unique_name ();\n     }\n \n-  DECL_NAME (d) = name;\n-  DECL_ASSEMBLER_NAME (d) = name;\n-  /* pushdecl wants to check the size of it to see if it is incomplete... */\n-  TREE_TYPE (d) = void_type_node;\n+  d = build_lang_decl (NAMESPACE_DECL, name, void_type_node);\n+\n   /* Mark them as external, so redeclaration_error_message doesn't think\n      they are duplicates. */\n+\n   DECL_EXTERNAL (d) = 1;\n   d = pushdecl (d);\n \n@@ -1722,12 +1742,10 @@ push_namespace (name)\n       /* This is new for this compilation unit.  */\n       pushlevel (0);\n       declare_namespace_level ();\n-      NAMESPACE_LEVEL (d) = (tree)current_binding_level;\n+      NAMESPACE_LEVEL (d) = current_binding_level;\n     }\n   else\n-    {\n-      resume_level ((struct binding_level*)NAMESPACE_LEVEL (d));\n-    }\n+    resume_level (NAMESPACE_LEVEL (d));\n \n   /* This code is just is bit old now... */ \n   current_namespace = tree_cons (NULL_TREE, name, current_namespace);\n@@ -2400,8 +2418,20 @@ decls_match (newdecl, olddecl)\n \ttypes_match = TREE_TYPE (newdecl) == NULL_TREE;\n       else if (TREE_TYPE (newdecl) == NULL_TREE)\n \ttypes_match = 0;\n+      /* Qualifiers must match, and they may be present on either, the type\n+\t or the decl.  */\n+      else if ((TREE_READONLY (newdecl)\n+\t\t|| TYPE_READONLY (TREE_TYPE (newdecl)))\n+\t       == (TREE_READONLY (olddecl)\n+\t\t   || TYPE_READONLY (TREE_TYPE (olddecl)))\n+\t       && (TREE_THIS_VOLATILE (newdecl)\n+\t\t    || TYPE_VOLATILE (TREE_TYPE (newdecl)))\n+\t\t   == (TREE_THIS_VOLATILE (olddecl)\n+\t\t       || TYPE_VOLATILE (TREE_TYPE (olddecl))))\n+\ttypes_match = comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (newdecl)),\n+\t\t\t\t TYPE_MAIN_VARIANT (TREE_TYPE (olddecl)), 1);\n       else\n-\ttypes_match = comptypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl), 1);\n+\ttypes_match = 0;\n     }\n \n   return types_match;\n@@ -2722,8 +2752,6 @@ duplicate_decls (newdecl, olddecl)\n \tDECL_CLASS_CONTEXT (newdecl) = DECL_CLASS_CONTEXT (olddecl);\n       if (DECL_CHAIN (newdecl) == NULL_TREE)\n \tDECL_CHAIN (newdecl) = DECL_CHAIN (olddecl);\n-      if (DECL_NEXT_METHOD (newdecl) == NULL_TREE)\n-\tDECL_NEXT_METHOD (newdecl) = DECL_NEXT_METHOD (olddecl);\n       if (DECL_PENDING_INLINE_INFO (newdecl) == (struct pending_inline *)0)\n \tDECL_PENDING_INLINE_INFO (newdecl) = DECL_PENDING_INLINE_INFO (olddecl);\n       DECL_STATIC_CONSTRUCTOR (newdecl) |= DECL_STATIC_CONSTRUCTOR (olddecl);\n@@ -2888,7 +2916,7 @@ duplicate_decls (newdecl, olddecl)\n \n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n-      DECL_C_STATIC (newdecl) = DECL_C_STATIC (olddecl);\n+      DECL_C_STATIC (newdecl) |= DECL_C_STATIC (olddecl);\n       DECL_INTERFACE_KNOWN (newdecl) |= DECL_INTERFACE_KNOWN (olddecl);\n       DECL_NOT_REALLY_EXTERN (newdecl) |= DECL_NOT_REALLY_EXTERN (olddecl);\n     }\n@@ -3379,7 +3407,7 @@ pushdecl (x)\n \t      if (b->parm_flag == 1)\n \t\tcp_error (\"declaration of `%#D' shadows a parameter\", name);\n \t    }\n-\t  else if (oldlocal != NULL_TREE && b->is_for_scope\n+\t  else if (warn_shadow && oldlocal != NULL_TREE && b->is_for_scope\n \t\t   && !DECL_DEAD_FOR_LOCAL (oldlocal))\n \t    {\n \t      warning (\"variable `%s' shadows local\",\n@@ -4173,6 +4201,7 @@ lookup_tag (form, name, binding_level, thislevel_only)\n \t\t    /* Definition isn't the kind we were looking for.  */\n \t\t    cp_error (\"`%#D' redeclared as %C\", TREE_VALUE (tail),\n \t\t\t      form);\n+\t\t    return NULL_TREE;\n \t\t  }\n \t\treturn TREE_VALUE (tail);\n \t      }\n@@ -4208,6 +4237,7 @@ lookup_tag (form, name, binding_level, thislevel_only)\n \t\t\t\t{\n \t\t\t\t  cp_error (\"`%#D' redeclared as %C in class scope\",\n \t\t\t\t\t    TREE_VALUE (tail), form);\n+\t\t\t\t  return NULL_TREE;\n \t\t\t\t}\n \t\t\t      return TREE_VALUE (tail);\n \t\t\t    }\n@@ -4690,9 +4720,6 @@ push_overloaded_decl_1 (x)\n   push_overloaded_decl (x, 0);\n }\n \n-#define builtin_function(NAME, TYPE, CODE, LIBNAME) \\\n-  define_function (NAME, TYPE, CODE, (void (*)())pushdecl, LIBNAME)\n-\n #ifdef __GNUC__\n __inline\n #endif\n@@ -5230,21 +5257,21 @@ init_decl_processing ()\n #if 0\n   /* Support for these has not been written in either expand_builtin\n      or build_function_call.  */\n-  builtin_function (\"__builtin_div\", default_ftype, BUILT_IN_DIV, 0);\n-  builtin_function (\"__builtin_ldiv\", default_ftype, BUILT_IN_LDIV, 0);\n+  builtin_function (\"__builtin_div\", default_ftype, BUILT_IN_DIV, NULL_PTR);\n+  builtin_function (\"__builtin_ldiv\", default_ftype, BUILT_IN_LDIV, NULL_PTR);\n   builtin_function (\"__builtin_ffloor\", double_ftype_double, BUILT_IN_FFLOOR,\n-\t\t    0);\n-  builtin_function (\"__builtin_fceil\", double_ftype_double, BUILT_IN_FCEIL, 0);\n+\t\t    NULL_PTR);\n+  builtin_function (\"__builtin_fceil\", double_ftype_double, BUILT_IN_FCEIL, NULL_PTR);\n   builtin_function (\"__builtin_fmod\", double_ftype_double_double,\n-\t\t    BUILT_IN_FMOD, 0);\n+\t\t    BUILT_IN_FMOD, NULL_PTR);\n   builtin_function (\"__builtin_frem\", double_ftype_double_double,\n-\t\t    BUILT_IN_FREM, 0);\n+\t\t    BUILT_IN_FREM, NULL_PTR);\n   builtin_function (\"__builtin_memset\", ptr_ftype_ptr_int_int, BUILT_IN_MEMSET,\n-\t\t    0);\n+\t\t    NULL_PTR);\n   builtin_function (\"__builtin_getexp\", double_ftype_double, BUILT_IN_GETEXP,\n-\t\t    0);\n+\t\t    NULL_PTR);\n   builtin_function (\"__builtin_getman\", double_ftype_double, BUILT_IN_GETMAN,\n-\t\t    0);\n+\t\t    NULL_PTR);\n #endif\n \n   /* C++ extensions */\n@@ -5299,7 +5326,7 @@ init_decl_processing ()\n      real gc code.  */\n   if (flag_gc)\n     {\n-      builtin_function (\"__gc_main\", default_function_type, NOT_BUILT_IN, 0);\n+      builtin_function (\"__gc_main\", default_function_type, NOT_BUILT_IN, NULL_PTR);\n       pushdecl (lookup_name (get_identifier (\"__gc_main\"), 0));\n     }\n \n@@ -5553,6 +5580,8 @@ init_decl_processing ()\n     }\n   if (flag_cadillac)\n     init_cadillac ();\n+  if (! SUPPORTS_WEAK)\n+    flag_weak = 0;\n \n   /* Create the global bindings for __FUNCTION__ and __PRETTY_FUNCTION__.  */\n   declare_function_name ();\n@@ -6819,7 +6848,11 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t}\n       else if (! toplev)\n \t{\n+\t  extern int temp_slot_level;\n+\t  extern int target_temp_slot_level;\n \t  tree old_cleanups = cleanups_this_call;\n+\t  int old_temp_level = target_temp_slot_level;\n+\n \t  /* This is a declared decl which must live until the\n \t     end of the binding contour.  It may need a cleanup.  */\n \n@@ -6854,6 +6887,10 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t\t}\n \t    }\n \n+\t  push_temp_slots ();\n+\t  push_temp_slots ();\n+\t  target_temp_slot_level = temp_slot_level;\n+\n \t  if (DECL_SIZE (decl) && type != error_mark_node)\n \t    {\n \t      /* Compute and store the initial value.  */\n@@ -6883,6 +6920,9 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t    }\n \t  /* Cleanup any temporaries needed for the initial value.  */\n \t  expand_cleanups_to (old_cleanups);\n+\t  pop_temp_slots ();\n+\t  pop_temp_slots ();\n+\t  target_temp_slot_level = old_temp_level;\n \t}\n     finish_end0:\n \n@@ -6961,7 +7001,6 @@ expand_static_init (decl, init)\n      tree init;\n {\n   tree oldstatic = value_member (decl, static_aggregates);\n-  tree old_cleanups;\n \n   if (oldstatic)\n     {\n@@ -6973,6 +7012,11 @@ expand_static_init (decl, init)\n       /* Emit code to perform this initialization but once.  */\n       tree temp;\n \n+      extern int temp_slot_level;\n+      extern int target_temp_slot_level;\n+      tree old_cleanups;\n+      int old_temp_level;\n+\n       /* Remember this information until end of file. */\n       push_obstacks (&permanent_obstack, &permanent_obstack);\n \n@@ -6982,6 +7026,11 @@ expand_static_init (decl, init)\n       expand_start_cond (build_binary_op (EQ_EXPR, temp,\n \t\t\t\t\t  integer_zero_node, 1), 0);\n       old_cleanups = cleanups_this_call;\n+      old_temp_level = target_temp_slot_level;\n+      push_temp_slots ();\n+      push_temp_slots ();\n+      target_temp_slot_level = temp_slot_level;\n+\n       expand_assignment (temp, integer_one_node, 0, 0);\n       if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl))\n \t  || (init && TREE_CODE (init) == TREE_LIST))\n@@ -6994,6 +7043,44 @@ expand_static_init (decl, init)\n \n       /* Cleanup any temporaries needed for the initial value.  */\n       expand_cleanups_to (old_cleanups);\n+      pop_temp_slots ();\n+      pop_temp_slots ();\n+      target_temp_slot_level = old_temp_level;\n+\n+      if (TYPE_NEEDS_DESTRUCTOR (TREE_TYPE (decl)))\n+\t{\n+\t  tree cleanup, fcall;\n+\t  static tree Atexit = 0;\n+\t  if (Atexit == 0)\n+\t    {\n+\t      tree atexit_fndecl, PFV, pfvlist;\n+\t      /* Remember this information until end of file. */\n+\t      push_obstacks (&permanent_obstack, &permanent_obstack);\n+\t      PFV = build_pointer_type (build_function_type\n+\t\t\t\t\t(void_type_node, void_list_node));\n+\n+\t      pfvlist = tree_cons (NULL_TREE, PFV, void_list_node);\n+\n+\t      push_lang_context (lang_name_c);\n+\t      atexit_fndecl = \n+\t\tbuiltin_function (\"atexit\",\n+\t\t\t\t  build_function_type (void_type_node,\n+\t\t\t\t\t\t       pfvlist),\n+\t\t\t\t  NOT_BUILT_IN, NULL_PTR);\n+\t      Atexit = default_conversion (atexit_fndecl);\n+\t      pop_lang_context ();\n+\t      pop_obstacks ();\n+\t    }\n+\t      \n+\t  cleanup = start_anon_func ();\n+\t  expand_expr_stmt (build_cleanup (decl));\n+\t  end_anon_func ();\n+\t  mark_addressable (cleanup);\n+\t  cleanup = build_unary_op (ADDR_EXPR, cleanup, 0);\n+\t  fcall = build_function_call (Atexit, tree_cons (NULL_TREE, cleanup, NULL_TREE));\n+\t  expand_expr_stmt (fcall);\n+\t}\n+\n       expand_end_cond ();\n       if (TYPE_NEEDS_DESTRUCTOR (TREE_TYPE (decl)))\n \t{\n@@ -9439,6 +9526,15 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t  {\n \t    int publicp = 0;\n \n+\t    /* We catch the others as conflicts with the builtin\n+\t       typedefs.  */\n+\t    if (friendp && declarator == ridpointers[(int) RID_SIGNED])\n+\t      {\n+\t\tcp_error (\"function `%D' cannot be declared friend\",\n+\t\t\t  declarator);\n+\t\tfriendp = 0;\n+\t      }\n+\n \t    if (friendp == 0)\n \t      {\n \t\tif (ctype == NULL_TREE)\n@@ -11667,6 +11763,7 @@ store_parm_decls ()\n       if (insns)\n \tstore_in_parms (insns);\n     }\n+  last_dtor_insn = get_last_insn ();\n }\n \n /* Bind a name and initialization to the return value of\n@@ -11793,6 +11890,7 @@ finish_function (lineno, call_poplevel, nested)\n       tree in_charge_node = lookup_name (in_charge_identifier, 0);\n       tree virtual_size;\n       int ok_to_optimize_dtor = 0;\n+      int empty_dtor = get_last_insn () == last_dtor_insn;\n \n       if (current_function_assigns_this)\n \tcond = build (NE_EXPR, boolean_type_node,\n@@ -11805,7 +11903,7 @@ finish_function (lineno, call_poplevel, nested)\n \t     whether `this' is NULL in some cases.  */\n \t  if ((flag_this_is_variable & 1) == 0)\n \t    ok_to_optimize_dtor = 1;\n-\t  else if (get_last_insn () == get_first_nonparm_insn ())\n+\t  else if (empty_dtor)\n \t    ok_to_optimize_dtor\n \t      = (n_baseclasses == 0\n \t\t || (n_baseclasses == 1\n@@ -11926,12 +12024,25 @@ finish_function (lineno, call_poplevel, nested)\n \n       start_sequence ();\n \n-      /* Make all virtual function table pointers in non-virtual base\n-\t classes point to CURRENT_CLASS_TYPE's virtual function\n-\t tables.  */\n-      expand_direct_vtbls_init (binfo, binfo, 1, 0, current_class_decl);\n-      if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n-\texpand_indirect_vtbls_init (binfo, C_C_D, current_class_decl, 0);\n+      /* If the dtor is empty, and we know there is not possible way we could\n+\t use any vtable entries, before they are possibly set by a base class\n+\t dtor, we don't have to setup the vtables, as we know that any base\n+\t class dtoring will set up any vtables it needs.  We avoid MI,\n+\t because one base class dtor can do a virtual dispatch to an\n+\t overridden function that would need to have a non-related vtable set\n+\t up, we cannot avoid setting up vtables in that case.  We could\n+\t change this to see if there is just one vtable.  */\n+      if (! empty_dtor || TYPE_USES_COMPLEX_INHERITANCE (current_class_type))\n+\t{\n+\t  /* Make all virtual function table pointers in non-virtual base\n+\t     classes point to CURRENT_CLASS_TYPE's virtual function\n+\t     tables.  */\n+\t  expand_direct_vtbls_init (binfo, binfo, 1, 0, current_class_decl);\n+\n+\t  if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n+\t    expand_indirect_vtbls_init (binfo, C_C_D, current_class_decl, 0);\n+\t}\n+\n       if (! ok_to_optimize_dtor)\n \t{\n \t  cond = build_binary_op (NE_EXPR,\n@@ -12490,15 +12601,6 @@ hack_incomplete_structures (type)\n     }\n }\n \n-/* Nonzero if presently building a cleanup.  Needed because\n-   SAVE_EXPRs are not the right things to use inside of cleanups.\n-   They are only ever evaluated once, where the cleanup\n-   might be evaluated several times.  In this case, a later evaluation\n-   of the cleanup might fill in the SAVE_EXPR_RTL, and it will\n-   not be valid for an earlier cleanup.  */\n-\n-int building_cleanup;\n-\n /* If DECL is of a type which needs a cleanup, build that cleanup here.\n    We don't build cleanups if just going for syntax checking, since\n    fixup_cleanups does not know how to not handle them.\n@@ -12514,8 +12616,6 @@ maybe_build_cleanup (decl)\n     {\n       int temp = 0, flags = LOOKUP_NORMAL|LOOKUP_DESTRUCTOR;\n       tree rval;\n-      int old_building_cleanup = building_cleanup;\n-      building_cleanup = 1;\n \n       if (TREE_CODE (decl) != PARM_DECL)\n \ttemp = suspend_momentary ();\n@@ -12540,11 +12640,12 @@ maybe_build_cleanup (decl)\n \trval = build_compound_expr (tree_cons (NULL_TREE, rval,\n \t\t\t\t\t       build_tree_list (NULL_TREE, build_vbase_delete (type, decl))));\n \n+      /* Since this is a cleanup, UNSAVE it now.  */\n+      rval = unsave_expr (rval);\n+\n       if (TREE_CODE (decl) != PARM_DECL)\n \tresume_momentary (temp);\n \n-      building_cleanup = old_building_cleanup;\n-\n       return rval;\n     }\n   return 0;\n@@ -12563,6 +12664,14 @@ void\n cplus_expand_expr_stmt (exp)\n      tree exp;\n {\n+  extern int temp_slot_level;\n+  extern int target_temp_slot_level; \n+  tree old_cleanups = cleanups_this_call;\n+  int old_temp_level = target_temp_slot_level;\n+  push_temp_slots ();\n+  push_temp_slots ();\n+  target_temp_slot_level = temp_slot_level;\n+\n   if (TREE_TYPE (exp) == unknown_type_node)\n     {\n       if (TREE_CODE (exp) == ADDR_EXPR || TREE_CODE (exp) == TREE_LIST)\n@@ -12590,7 +12699,16 @@ cplus_expand_expr_stmt (exp)\n \n   /* Clean up any pending cleanups.  This happens when a function call\n      returns a cleanup-needing value that nobody uses.  */\n-  expand_cleanups_to (NULL_TREE);\n+  expand_cleanups_to (old_cleanups);\n+  pop_temp_slots ();\n+  pop_temp_slots ();\n+  target_temp_slot_level = old_temp_level;\n+  /* There might something left from building the trees.  */\n+  if (cleanups_this_call)\n+    {\n+      expand_cleanups_to (NULL_TREE);\n+    }\n+  free_temp_slots ();\n }\n \n /* When a stmt has been parsed, this function is called.\n@@ -12679,6 +12797,7 @@ struct cp_function\n   tree shadowed_labels;\n   tree ctor_label;\n   tree dtor_label;\n+  rtx last_dtor_insn;\n   tree protect_list;\n   tree base_init_list;\n   tree member_init_list;\n@@ -12717,6 +12836,7 @@ push_cp_function_context (context)\n   p->binding_level = current_binding_level;\n   p->ctor_label = ctor_label;\n   p->dtor_label = dtor_label;\n+  p->last_dtor_insn = last_dtor_insn;\n   p->assigns_this = current_function_assigns_this;\n   p->just_assigned_this = current_function_just_assigned_this;\n   p->parms_stored = current_function_parms_stored;\n@@ -12768,6 +12888,7 @@ pop_cp_function_context (context)\n   current_binding_level = p->binding_level;\n   ctor_label = p->ctor_label;\n   dtor_label = p->dtor_label;\n+  last_dtor_insn = p->last_dtor_insn;\n   protect_list = p->protect_list;\n   current_function_assigns_this = p->assigns_this;\n   current_function_just_assigned_this = p->just_assigned_this;"}, {"sha": "437247f7a2100f5c621b187e955bffdda82603cf", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 70, "deletions": 52, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -36,7 +36,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"decl.h\"\n #include \"lex.h\"\n #include \"output.h\"\n-#include \"defaults.h\"\n \n extern tree get_file_function_name ();\n extern tree cleanups_this_call;\n@@ -369,6 +368,12 @@ int flag_check_new;\n \n int flag_new_for_scope = 1;\n \n+/* Nonzero if we want to emit defined symbols with common-like linkage as\n+   weak symbols where possible, in order to conform to C++ semantics.\n+   Otherwise, emit them as local symbols.  */\n+\n+int flag_weak = 1;\n+\n /* Table of language-dependent -f options.\n    STRING is the option name.  VARIABLE is the address of the variable.\n    ON_VALUE is the value to store in VARIABLE\n@@ -416,7 +421,8 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"operator-names\", &flag_operator_names, 1},\n   {\"check-new\", &flag_check_new, 1},\n   {\"repo\", &flag_use_repository, 1},\n-  {\"for-scope\", &flag_new_for_scope, 2}\n+  {\"for-scope\", &flag_new_for_scope, 2},\n+  {\"weak\", &flag_weak, 1}\n };\n \n /* Decode the string P as a language-specific option.\n@@ -906,7 +912,7 @@ grokclassfn (ctype, cname, function, flags, quals)\n \t      /* Mark the artificial `__in_chrg' parameter as \"artificial\".  */\n \t      SET_DECL_ARTIFICIAL (parm);\n \t      DECL_ARG_TYPE (parm) = integer_type_node;\n-\t      DECL_REGISTER (parm) = 1;\n+\t      TREE_READONLY (parm) = 1;\n \t      TREE_CHAIN (parm) = last_function_parms;\n \t      last_function_parms = parm;\n \t    }\n@@ -948,18 +954,11 @@ grokclassfn (ctype, cname, function, flags, quals)\n       buf[len] = '\\0';\n       strcat (buf, dbuf);\n       DECL_ASSEMBLER_NAME (function) = get_identifier (buf);\n-      parm = build_decl (PARM_DECL, in_charge_identifier, const_integer_type);\n+      parm = build_decl (PARM_DECL, in_charge_identifier, integer_type_node);\n       /* Mark the artificial `__in_chrg' parameter as \"artificial\".  */\n       SET_DECL_ARTIFICIAL (parm);\n-      TREE_USED (parm) = 1;\n-#if 0\n-      /* We don't need to mark the __in_chrg parameter itself as `const'\n- \t since its type is already `const int'.  In fact we MUST NOT mark\n- \t it as `const' cuz that will screw up the debug info (causing it\n- \t to say that the type of __in_chrg is `const const int').  */\n       TREE_READONLY (parm) = 1;\n-#endif\n-      DECL_ARG_TYPE (parm) = const_integer_type;\n+      DECL_ARG_TYPE (parm) = integer_type_node;\n       /* This is the same chain as DECL_ARGUMENTS (...).  */\n       TREE_CHAIN (last_function_parms) = parm;\n \n@@ -2030,7 +2029,7 @@ constructor_name_full (thing)\n   if (IS_AGGR_TYPE_CODE (TREE_CODE (thing)))\n     {\n       if (TYPE_WAS_ANONYMOUS (thing) && TYPE_HAS_CONSTRUCTOR (thing))\n-\tthing = DECL_NAME (TREE_VEC_ELT (TYPE_METHODS (thing), 0));\n+\tthing = DECL_NAME (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (thing), 0));\n       else\n \tthing = TYPE_NAME (thing);\n     }\n@@ -2479,6 +2478,8 @@ coerce_delete_type (type)\n   return type;\n }\n \f\n+extern tree abort_fndecl;\n+\n static void\n mark_vtable_entries (decl)\n      tree decl;\n@@ -2489,16 +2490,12 @@ mark_vtable_entries (decl)\n \n   for (; entries; entries = TREE_CHAIN (entries))\n     {\n-      tree fnaddr = FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (entries));\n+      tree fnaddr = (flag_vtable_thunks ? TREE_VALUE (entries) \n+\t\t     : FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (entries)));\n       tree fn = TREE_OPERAND (fnaddr, 0);\n       TREE_ADDRESSABLE (fn) = 1;\n-      if (DECL_ABSTRACT_VIRTUAL_P (fn))\n-\t{\n-\t  extern tree abort_fndecl;\n-\t  if (flag_vtable_thunks)\n-\t    fnaddr = TREE_VALUE (entries);\n-\t  TREE_OPERAND (fnaddr, 0) = fn = abort_fndecl;\n-\t}\n+      if (DECL_LANG_SPECIFIC (fn) && DECL_ABSTRACT_VIRTUAL_P (fn))\n+\tTREE_OPERAND (fnaddr, 0) = fn = abort_fndecl;\n       assemble_external (fn);\n     }\n }\n@@ -2541,8 +2538,8 @@ import_export_vtable (decl, type, final)\n       if (! found && ! final)\n \t{\n \t  tree method;\n-\t  for (method = CLASSTYPE_METHODS (type); method != NULL_TREE;\n-\t       method = DECL_NEXT_METHOD (method))\n+\t  for (method = TYPE_METHODS (type); method != NULL_TREE;\n+\t       method = TREE_CHAIN (method))\n \t    if (DECL_VINDEX (method) != NULL_TREE\n \t\t&& ! DECL_THIS_INLINE (method)\n \t\t&& ! DECL_ABSTRACT_VIRTUAL_P (method))\n@@ -2558,7 +2555,7 @@ import_export_vtable (decl, type, final)\n \t  if (TREE_PUBLIC (decl))\n \t    cp_error (\"all virtual functions redeclared inline\");\n #endif\n-\t  if (SUPPORTS_WEAK)\n+\t  if (flag_weak)\n \t    DECL_WEAK (decl) = 1;\n \t  else\n \t    TREE_PUBLIC (decl) = 0;\n@@ -2597,8 +2594,8 @@ finish_prevtable_vardecl (prev, vars)\n       && ! CLASSTYPE_TEMPLATE_INSTANTIATION (ctype))\n     {\n       tree method;\n-      for (method = CLASSTYPE_METHODS (ctype); method != NULL_TREE;\n-\t   method = DECL_NEXT_METHOD (method))\n+      for (method = TYPE_METHODS (ctype); method != NULL_TREE;\n+\t   method = TREE_CHAIN (method))\n \t{\n \t  if (DECL_VINDEX (method) != NULL_TREE\n \t      && !DECL_THIS_INLINE (method)\n@@ -2782,7 +2779,7 @@ import_export_inline (decl)\n     {\n       if (DECL_IMPLICIT_INSTANTIATION (decl) && flag_implicit_templates)\n \t{\n-\t  if (SUPPORTS_WEAK)\n+\t  if (flag_weak)\n \t    DECL_WEAK (decl) = 1;\n \t  else\n \t    TREE_PUBLIC (decl) = 0;\n@@ -2799,21 +2796,41 @@ import_export_inline (decl)\n \t    = ! (CLASSTYPE_INTERFACE_ONLY (ctype)\n \t\t || (DECL_THIS_INLINE (decl) && ! flag_implement_inlines));\n \t}\n-      else if (SUPPORTS_WEAK)\n+      else if (flag_weak)\n \tDECL_WEAK (decl) = 1;\n       else\n \tTREE_PUBLIC (decl) = 0;\n     }\n   else if (DECL_C_STATIC (decl))\n     TREE_PUBLIC (decl) = 0;\n-  else if (SUPPORTS_WEAK)\n+  else if (flag_weak)\n     DECL_WEAK (decl) = 1;\n   else\n     TREE_PUBLIC (decl) = 0;\n \n   DECL_INTERFACE_KNOWN (decl) = 1;\n }\n \n+tree\n+build_cleanup (decl)\n+     tree decl;\n+{\n+  tree temp;\n+  tree type = TREE_TYPE (decl);\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    temp = decl;\n+  else\n+    {\n+      mark_addressable (decl);\n+      temp = build1 (ADDR_EXPR, build_pointer_type (type), decl);\n+    }\n+  temp = build_delete (TREE_TYPE (temp), temp,\n+\t\t       integer_two_node,\n+\t\t       LOOKUP_NORMAL|LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n+  return temp;\n+}\n+\n extern int parse_time, varconst_time;\n \n #define TIMEVAR(VAR, BODY)    \\\n@@ -2895,14 +2912,12 @@ finish_file ()\n     {\n       tree decl = TREE_VALUE (vars);\n       tree type = TREE_TYPE (decl);\n-      if (TYPE_NEEDS_DESTRUCTOR (type))\n+      if (TYPE_NEEDS_DESTRUCTOR (type) && ! TREE_STATIC (vars))\n \t{\n \t  needs_cleaning = 1;\n-\t  needs_messing_up = 1;\n \t  break;\n \t}\n-      else\n-\tneeds_messing_up |= TYPE_NEEDS_CONSTRUCTING (type);\n+\n       vars = TREE_CHAIN (vars);\n     }\n \n@@ -2930,23 +2945,10 @@ finish_file ()\n       tree type = TREE_TYPE (decl);\n       tree temp = TREE_PURPOSE (vars);\n \n-      if (TYPE_NEEDS_DESTRUCTOR (type))\n+      if (TYPE_NEEDS_DESTRUCTOR (type) && ! TREE_STATIC (vars))\n \t{\n-\t  if (TREE_STATIC (vars))\n-\t    expand_start_cond (build_binary_op (NE_EXPR, temp, integer_zero_node, 1), 0);\n-\t  if (TREE_CODE (type) == ARRAY_TYPE)\n-\t    temp = decl;\n-\t  else\n-\t    {\n-\t      mark_addressable (decl);\n-\t      temp = build1 (ADDR_EXPR, build_pointer_type (type), decl);\n-\t    }\n-\t  temp = build_delete (TREE_TYPE (temp), temp,\n-\t\t\t       integer_two_node, LOOKUP_NORMAL|LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n+\t  temp = build_cleanup (decl);\n \t  expand_expr_stmt (temp);\n-\n-\t  if (TREE_STATIC (vars))\n-\t    expand_end_cond ();\n \t}\n     }\n \n@@ -2987,9 +2989,15 @@ finish_file ()\n \n       while (vars)\n \t{\n+\t  extern int temp_slot_level;\n+\t  extern int target_temp_slot_level; \n \t  tree decl = TREE_VALUE (vars);\n \t  tree init = TREE_PURPOSE (vars);\n \t  tree old_cleanups = cleanups_this_call;\n+\t  int old_temp_level = target_temp_slot_level;\n+\t  push_temp_slots ();\n+\t  push_temp_slots ();\n+\t  target_temp_slot_level = temp_slot_level;\n \n \t  /* If this was a static attribute within some function's scope,\n \t     then don't initialize it here.  Also, don't bother\n@@ -3024,7 +3032,6 @@ finish_file ()\n \t\t\t\t\t\tTREE_VEC_ELT (init, 1),\n \t\t\t\t\t\tTREE_VEC_ELT (init, 2), 0),\n \t\t\t       const0_rtx, VOIDmode, 0);\n-\t\t  free_temp_slots ();\n \t\t}\n \t      else\n \t\texpand_assignment (decl, init, 0, 0);\n@@ -3037,14 +3044,12 @@ finish_file ()\n \t\t{\n \t\t  /* a `new' expression at top level.  */\n \t\t  expand_expr (decl, const0_rtx, VOIDmode, 0);\n-\t\t  free_temp_slots ();\n \t\t  if (TREE_CODE (init) == TREE_VEC)\n \t\t    {\n \t\t      expand_expr (expand_vec_init (decl, TREE_VEC_ELT (init, 0),\n \t\t\t\t\t\t    TREE_VEC_ELT (init, 1),\n \t\t\t\t\t\t    TREE_VEC_ELT (init, 2), 0),\n \t\t\t\t   const0_rtx, VOIDmode, 0);\n-\t\t      free_temp_slots ();\n \t\t    }\n \t\t  else\n \t\t    expand_aggr_init (build_indirect_ref (decl, NULL_PTR), init, 0, 0);\n@@ -3053,9 +3058,14 @@ finish_file ()\n \t  else if (decl == error_mark_node)\n \t    ;\n \t  else my_friendly_abort (22);\n-\t  vars = TREE_CHAIN (vars);\n+\n \t  /* Cleanup any temporaries needed for the initial value.  */\n \t  expand_cleanups_to (old_cleanups);\n+\t  pop_temp_slots ();\n+\t  pop_temp_slots ();\n+\t  target_temp_slot_level = old_temp_level;\n+\n+\t  vars = TREE_CHAIN (vars);\n \t}\n \n       for (; static_ctors; static_ctors = TREE_CHAIN (static_ctors))\n@@ -3509,3 +3519,11 @@ check_default_args (x)\n \t}\n     }\n }\n+\n+void\n+mark_used (decl)\n+     tree decl;\n+{\n+  TREE_USED (decl) = 1;\n+  assemble_external (decl);\n+}"}, {"sha": "4da07fa40dca022f2665ee4fb363481377417ffc", "filename": "gcc/cp/errfn.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Ferrfn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Ferrfn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferrfn.c?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -21,6 +21,7 @@ Boston, MA 02111-1307, USA.  */\n    \n #include \"config.h\"\n #include \"tree.h\"\n+#include <stdio.h>\n #include <ctype.h>\n \n /* cp_printer is the type of a function which converts an argument into\n@@ -195,8 +196,7 @@ cp_sprintf (format, arglist)\n      char *format;\n      arglist_dcl\n {\n-  extern errorfn sprintf;\n-  cp_thing (sprintf, 0, format, arglist);\n+  cp_thing ((errorfn *) sprintf, 0, format, arglist);\n }\n \n void"}, {"sha": "c6653e730b0a24209b0b017b4482f3fb98a1a5aa", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -950,12 +950,12 @@ dump_expr (t, nop)\n \t  }\n \telse if (type == boolean_type_node)\n \t  {\n-\t    if (t == boolean_false_node)\n+\t    if (t == boolean_false_node\n+\t\t|| (TREE_INT_CST_LOW (t) == 0\n+\t\t    && TREE_INT_CST_HIGH (t) == 0))\n \t      OB_PUTS (\"false\");\n \t    else if (t == boolean_true_node)\n \t      OB_PUTS (\"true\");\n-\t    else\n-\t      my_friendly_abort (366);\n \t  }\n \telse if (type == char_type_node)\n \t  {"}, {"sha": "88587f0acf92823278dba51af9990504f4e5bf26", "filename": "gcc/cp/except.c", "status": "modified", "additions": 165, "deletions": 51, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -264,6 +264,8 @@ static tree Unwind;\n /* holds a ready to emit call to \"terminate ()\".  */\n static tree TerminateFunctionCall;\n \n+static tree empty_fndecl;\n+\n /* ====================================================================== */\n \n \n@@ -275,7 +277,10 @@ static tree TerminateFunctionCall;\n /* =================================================================== */\n \n struct labelNode {\n-  rtx label;\n+  union {\n+    rtx rlabel;\n+    tree tlabel;\n+  } u;\n   struct labelNode *chain;\n };\n \n@@ -319,6 +324,8 @@ tree saved_pc;\n tree saved_throw_type;\n /* Holds the value being thrown.  */\n tree saved_throw_value;\n+/* Holds the cleanup for the value being thrown.  */\n+tree saved_cleanup;\n \n int throw_used;\n \n@@ -339,9 +346,9 @@ static rtx push_eh_entry\t\tPROTO((struct ehStack *stack));\n static struct ehEntry *dequeue_eh_entry\tPROTO((struct ehQueue *queue));\n static void new_eh_queue\t\tPROTO((struct ehQueue *queue));\n static void new_eh_stack\t\tPROTO((struct ehStack *stack));\n-static void push_label_entry\t\tPROTO((struct labelNode **labelstack, rtx label));\n+static void push_label_entry\t\tPROTO((struct labelNode **labelstack, rtx rlabel, tree tlabel));\n static rtx pop_label_entry\t\tPROTO((struct labelNode **labelstack));\n-static rtx top_label_entry\t\tPROTO((struct labelNode **labelstack));\n+static tree top_label_entry\t\tPROTO((struct labelNode **labelstack));\n static struct ehEntry *copy_eh_entry\tPROTO((struct ehEntry *entry));\n \n \n@@ -351,13 +358,17 @@ static struct ehEntry *copy_eh_entry\tPROTO((struct ehEntry *entry));\n    ========================================================================= */\n \n static void\n-push_label_entry (labelstack, label)\n+push_label_entry (labelstack, rlabel, tlabel)\n      struct labelNode **labelstack;\n-     rtx label;\n+     rtx rlabel;\n+     tree tlabel;\n {\n   struct labelNode *newnode=(struct labelNode*)xmalloc (sizeof (struct labelNode));\n \n-  newnode->label = label;\n+  if (rlabel)\n+    newnode->u.rlabel = rlabel;\n+  else\n+    newnode->u.tlabel = tlabel;\n   newnode->chain = *labelstack;\n   *labelstack = newnode;\n }\n@@ -372,20 +383,20 @@ pop_label_entry (labelstack)\n   if (! *labelstack) return NULL_RTX;\n \n   tempnode = *labelstack;\n-  label = tempnode->label;\n+  label = tempnode->u.rlabel;\n   *labelstack = (*labelstack)->chain;\n   free (tempnode);\n \n   return label;\n }\n \n-static rtx\n+static tree\n top_label_entry (labelstack)\n      struct labelNode **labelstack;\n {\n-  if (! *labelstack) return NULL_RTX;\n+  if (! *labelstack) return NULL_TREE;\n \n-  return (*labelstack)->label;\n+  return (*labelstack)->u.tlabel;\n }\n \n /* Push to permanent obstack for rtl generation.\n@@ -623,41 +634,39 @@ init_exception_processing ()\n   push_lang_context (lang_name_c);\n \n   catch_match_fndecl =\n-    define_function (flag_rtti\n-\t\t     ? \"__throw_type_match_rtti\"\n-\t\t     : \"__throw_type_match\",\n-\t\t     build_function_type (ptr_type_node,\n-\t\t\t\t\t  tree_cons (NULL_TREE, ptr_type_node,\n-\t\t\t\t\t\t     tree_cons (NULL_TREE, ptr_type_node,\n-\t\t\t\t\t\t\t\ttree_cons (NULL_TREE, ptr_type_node,\n-\t\t\t\t\t\t\t\t\t   void_list_node)))),\n-\t\t     NOT_BUILT_IN,\n-\t\t     pushdecl,\n-\t\t     0);\n+    builtin_function (flag_rtti\n+\t\t      ? \"__throw_type_match_rtti\"\n+\t\t      : \"__throw_type_match\",\n+\t\t      build_function_type (ptr_type_node,\n+\t\t\t\t\t   tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t\t\t\t      tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t\t\t\t\t\t tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t\t\t\t\t\t\t    void_list_node)))),\n+\t\t      NOT_BUILT_IN, NULL_PTR);\n   find_first_exception_match_fndecl =\n-    define_function (\"__find_first_exception_table_match\",\n-\t\t     build_function_type (ptr_type_node,\n-\t\t\t\t\t  tree_cons (NULL_TREE, ptr_type_node,\n-\t\t\t\t\t\t     void_list_node)),\n-\t\t     NOT_BUILT_IN,\n-\t\t     pushdecl,\n-\t\t     0);\n+    builtin_function (\"__find_first_exception_table_match\",\n+\t\t      build_function_type (ptr_type_node,\n+\t\t\t\t\t   tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t\t\t\t      void_list_node)),\n+\t\t      NOT_BUILT_IN, NULL_PTR);\n   unwind_fndecl =\n-    define_function (\"__unwind_function\",\n-\t\t     build_function_type (void_type_node,\n-\t\t\t\t\t  tree_cons (NULL_TREE, ptr_type_node,\n-\t\t\t\t\t\t     void_list_node)),\n-\t\t     NOT_BUILT_IN,\n-\t\t     pushdecl,\n-\t\t     0);\n+    builtin_function (\"__unwind_function\",\n+\t\t      build_function_type (void_type_node,\n+\t\t\t\t\t   tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t\t\t\t      void_list_node)),\n+\t\t      NOT_BUILT_IN, NULL_PTR);\n   throw_fndecl =\n-    define_function (\"__throw\",\n-\t\t     build_function_type (void_type_node, void_list_node),\n-\t\t     NOT_BUILT_IN,\n-\t\t     pushdecl,\n-\t\t     0);\n+    builtin_function (\"__throw\",\n+\t\t      build_function_type (void_type_node, void_list_node),\n+\t\t      NOT_BUILT_IN, NULL_PTR);\n   DECL_EXTERNAL (throw_fndecl) = 0;\n   TREE_PUBLIC (throw_fndecl) = 0;\n+  empty_fndecl =\n+    builtin_function (\"__empty\",\n+\t\t      build_function_type (void_type_node, void_list_node),\n+\t\t      NOT_BUILT_IN, NULL_PTR);\n+  DECL_EXTERNAL (empty_fndecl) = 1;\n+  TREE_PUBLIC (empty_fndecl) = 1;\n \n   Unexpected = default_conversion (unexpected_fndecl);\n   Terminate = default_conversion (terminate_fndecl);\n@@ -697,6 +706,14 @@ init_exception_processing ()\n   DECL_COMMON (d) = 1;\n   cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n   saved_throw_value = lookup_name (get_identifier (\"__eh_value\"), 0);\n+\n+  declspecs = tree_cons (NULL_TREE, get_identifier (\"void\"), NULL_TREE);\n+  d = build_parse_node (INDIRECT_REF, get_identifier (\"__eh_cleanup\"));\n+  d = build_parse_node (CALL_EXPR, d, void_list_node, NULL_TREE);\n+  d = start_decl (d, declspecs, 0, NULL_TREE);\n+  DECL_COMMON (d) = 1;\n+  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n+  saved_cleanup = lookup_name (get_identifier (\"__eh_cleanup\"), 0);\n }\n \n /* call this to begin a block of unwind protection (ie: when an object is\n@@ -759,17 +776,17 @@ void\n expand_start_all_catch ()\n {\n   struct ehEntry *entry;\n-  rtx label;\n+  tree label;\n \n   if (! doing_eh (1))\n     return;\n \n   emit_line_note (input_filename, lineno);\n-  label = gen_label_rtx ();\n+  label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n \n   /* The label for the exception handling block we will save.  This is\n      Lresume, in the documention.  */\n-  emit_label (label);\n+  expand_label (label);\n   \n   /* Put in something that takes up space, as otherwise the end\n      address for the EH region could have the exact same address as\n@@ -778,7 +795,7 @@ expand_start_all_catch ()\n      region.  */\n   emit_insn (gen_nop ());\n \n-  push_label_entry (&caught_return_label_stack, label);\n+  push_label_entry (&caught_return_label_stack, NULL_RTX, label);\n \n   /* Start a new sequence for all the catch blocks.  We will add this\n      to the gloabl sequence catch_clauses, when we have completed all\n@@ -821,7 +838,7 @@ expand_end_all_catch ()\n      documentation.  */\n   expand_internal_throw (gen_rtx (LABEL_REF,\n \t\t\t\t  Pmode,\n-\t\t\t\t  top_label_entry (&caught_return_label_stack)));\n+\t\t\t\t  DECL_RTL (top_label_entry (&caught_return_label_stack))));\n \n   /* Now we have the complete catch sequence.  */\n   new_catch_clause = get_insns ();\n@@ -884,6 +901,21 @@ build_eh_type (exp)\n   return build_eh_type_type (TREE_TYPE (exp));\n }\n \n+/* This routine creates the cleanup for the exception handling object.  */\n+void\n+push_eh_cleanup ()\n+{\n+  /* All cleanups must last longer than normal.  */\n+  int yes = suspend_momentary ();\n+\n+  /* Arrange to do a dynamically scoped cleanup upon exit from this region.  */\n+  tree cleanup = build_function_call (saved_cleanup, NULL_TREE);\n+  cp_expand_decl_cleanup (NULL_TREE, cleanup);\n+\n+  resume_momentary (yes);\n+}\n+\n+\n /* call this to start a catch block. Typename is the typename, and identifier\n    is the variable to place the object in or NULL if the variable doesn't\n    matter.  If typename is NULL, that means its a \"catch (...)\" or catch\n@@ -897,6 +929,7 @@ expand_start_catch_block (declspecs, declarator)\n   rtx protect_label_rtx;\n   tree decl = NULL_TREE;\n   tree init;\n+  tree cleanup;\n \n   if (! doing_eh (1))\n     return;\n@@ -909,8 +942,8 @@ expand_start_catch_block (declspecs, declarator)\n   push_rtl_perm ();\n   protect_label_rtx = gen_label_rtx ();\n   pop_rtl_from_perm ();\n-  push_label_entry (&false_label_stack, false_label_rtx);\n-  push_label_entry (&false_label_stack, protect_label_rtx);\n+  push_label_entry (&false_label_stack, false_label_rtx, NULL_TREE);\n+  push_label_entry (&false_label_stack, protect_label_rtx, NULL_TREE);\n \n   if (declspecs)\n     {\n@@ -952,6 +985,8 @@ expand_start_catch_block (declspecs, declarator)\n       /* if it returned FALSE, jump over the catch block, else fall into it */\n       emit_jump_insn (gen_beq (false_label_rtx));\n \n+      push_eh_cleanup ();\n+\n       init = convert_from_reference (save_expr (make_tree (init_type, call_rtx)));\n \n       /* Do we need the below two lines? */\n@@ -962,6 +997,8 @@ expand_start_catch_block (declspecs, declarator)\n     }\n   else\n     {\n+      push_eh_cleanup ();\n+\n       /* Fall into the catch all section. */\n     }\n \n@@ -1024,7 +1061,7 @@ void expand_end_catch_block ()\n   /* fall to outside the try statement when done executing handler and\n      we fall off end of handler.  This is jump Lresume in the\n      documentation.  */\n-  emit_jump (top_label_entry (&caught_return_label_stack));\n+  expand_goto (top_label_entry (&caught_return_label_stack));\n \n   /* We end the rethrow protection region as soon as we hit a label. */\n   end_protect_label_rtx = expand_leftover_cleanups ();\n@@ -1039,7 +1076,7 @@ void expand_end_catch_block ()\n   emit_label (entry.exception_handler_label);\n   expand_internal_throw (gen_rtx (LABEL_REF,\n \t\t\t\t  Pmode,\n-\t\t\t\t  top_label_entry (&caught_return_label_stack)));\n+\t\t\t\t  DECL_RTL (top_label_entry (&caught_return_label_stack))));\n \n   /* No associated finalization.  */\n   entry.finalization = NULL_TREE;\n@@ -1487,6 +1524,51 @@ expand_exception_blocks ()\n   emit_insns (insns);\n }\n \n+tree\n+start_anon_func ()\n+{\n+  static int counter = 0;\n+  char name[32];\n+  tree params;\n+  tree t;\n+\n+  push_cp_function_context (NULL_TREE);\n+  push_to_top_level ();\n+\n+  /* No need to mangle this.  */\n+  push_lang_context (lang_name_c);\n+\n+  params = void_list_node;\n+  /* tcf stands for throw clean funciton.  */\n+  sprintf (name, \"__tcf_%d\", counter++);\n+  t = build_parse_node (CALL_EXPR, get_identifier (name), params, NULL_TREE);\n+  start_function (decl_tree_cons (NULL_TREE, get_identifier (\"static\"),\n+\t\t\t\t  void_list_node),\n+\t\t  t, NULL_TREE, NULL_TREE, 0);\n+  store_parm_decls ();\n+  pushlevel (0);\n+  clear_last_expr ();\n+  push_momentary ();\n+  expand_start_bindings (0);\n+  emit_line_note (input_filename, lineno);\n+\n+  pop_lang_context ();\n+\n+  return current_function_decl;\n+}\n+\n+void\n+end_anon_func ()\n+{\n+  expand_end_bindings (getdecls(), 1, 0);\n+  poplevel (1, 0, 0);\n+  pop_momentary ();\n+\n+  finish_function (lineno, 0, 0);\n+\n+  pop_from_top_level ();\n+  pop_cp_function_context (NULL_TREE);\n+}\n \n /* call this to expand a throw statement.  This follows the following\n    algorithm:\n@@ -1515,7 +1597,7 @@ expand_throw (exp)\n   if (exp)\n     {\n       tree throw_type;\n-      tree e;\n+      tree cleanup = empty_fndecl, e;\n \n       /* throw expression */\n       /* First, decay it. */\n@@ -1528,6 +1610,8 @@ expand_throw (exp)\n \t}\n       else\n \t{\n+\t  rtx cleanup_insns;\n+\t  tree object;\n \t  /* Make a copy of the thrown object.  WP 15.1.5  */\n \t  exp = build_new (NULL_TREE, TREE_TYPE (exp),\n \t\t\t   build_tree_list (NULL_TREE, exp),\n@@ -1536,14 +1620,44 @@ expand_throw (exp)\n \t  if (exp == error_mark_node)\n \t    error (\"  in thrown expression\");\n \n-\t  throw_type = build_eh_type (build_indirect_ref (exp, NULL_PTR));\n+\t  object = build_indirect_ref (exp, NULL_PTR);\n+\t  throw_type = build_eh_type (object);\n+\n+\t  start_sequence ();\n+\t  object = build_reinterpret_cast (TREE_TYPE (exp), saved_throw_value);\n+\t  object = build_indirect_ref (object, NULL_PTR);\n+\t  cleanup = maybe_build_cleanup (object);\n+\t  if (cleanup)\n+\t    expand_expr (cleanup, const0_rtx, VOIDmode, 0);\n+\t  cleanup_insns = get_insns ();\n+\t  end_sequence ();\n+\n+\t  if (cleanup && cleanup_insns)\n+\t    {\n+\t      cleanup = start_anon_func ();\n+\n+\t      expand_expr (maybe_build_cleanup (object), const0_rtx, VOIDmode, 0);\n+\n+\t      end_anon_func ();\n+\n+\t      mark_addressable (cleanup);\n+\t    }\n+\t  else\n+\t    {\n+\t      cleanup = empty_fndecl;\n+\t    }\n \t}\n \n       e = build_modify_expr (saved_throw_type, NOP_EXPR, throw_type);\n       expand_expr (e, const0_rtx, VOIDmode, 0);\n+\n       e = build_modify_expr (saved_throw_value, NOP_EXPR, exp);\n       e = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (e), e);\n       expand_expr (e, const0_rtx, VOIDmode, 0);\n+\n+      cleanup = build_unary_op (ADDR_EXPR, cleanup, 0);\n+      cleanup = build_modify_expr (saved_cleanup, NOP_EXPR, cleanup);\n+      expand_expr (cleanup, const0_rtx, VOIDmode, 0);\n     }\n   else\n     {"}, {"sha": "2c795bbe839d1690e554e2b3d91e79df288e94ea", "filename": "gcc/cp/init.c", "status": "modified", "additions": 74, "deletions": 22, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -43,6 +43,8 @@ Boston, MA 02111-1307, USA.  */\n    line.  Perhaps this was not intended.  */\n tree current_base_init_list, current_member_init_list;\n \n+extern tree cleanups_this_call;\n+\n void emit_base_init ();\n void check_base_init ();\n static void expand_aggr_vbase_init ();\n@@ -160,6 +162,13 @@ perform_member_init (member, name, init, explicit, protect_list)\n {\n   tree decl;\n   tree type = TREE_TYPE (member);\n+  extern int temp_slot_level;\n+  extern int target_temp_slot_level; \n+  tree old_cleanups = cleanups_this_call;\n+  int old_temp_level = target_temp_slot_level;\n+  push_temp_slots ();\n+  push_temp_slots ();\n+  target_temp_slot_level = temp_slot_level;\n \n   if (TYPE_NEEDS_CONSTRUCTING (type)\n       || (init && TYPE_HAS_CONSTRUCTOR (type)))\n@@ -219,7 +228,16 @@ perform_member_init (member, name, init, explicit, protect_list)\n \t  expand_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n \t}\n     }\n-  expand_cleanups_to (NULL_TREE);\n+  expand_cleanups_to (old_cleanups);\n+  pop_temp_slots ();\n+  pop_temp_slots ();\n+  target_temp_slot_level = old_temp_level;\n+  /* There might something left from building the trees.  */\n+  if (cleanups_this_call)\n+    {\n+      expand_cleanups_to (NULL_TREE);\n+    }\n+  free_temp_slots ();\n \n   if (TYPE_NEEDS_DESTRUCTOR (type))\n     {\n@@ -577,11 +595,28 @@ emit_base_init (t, immediately)\n \n       if (init != void_list_node)\n \t{\n+\t  extern int temp_slot_level;\n+\t  extern int target_temp_slot_level; \n+\t  tree old_cleanups = cleanups_this_call;\n+\t  int old_temp_level = target_temp_slot_level;\n+\t  push_temp_slots ();\n+\t  push_temp_slots ();\n+\t  target_temp_slot_level = temp_slot_level;\n+\n \t  member = convert_pointer_to_real (base_binfo, current_class_decl);\n \t  expand_aggr_init_1 (base_binfo, 0,\n \t\t\t      build_indirect_ref (member, NULL_PTR), init,\n \t\t\t      BINFO_OFFSET_ZEROP (base_binfo), LOOKUP_NORMAL);\n-\t  expand_cleanups_to (NULL_TREE);\n+\t  expand_cleanups_to (old_cleanups);\n+\t  pop_temp_slots ();\n+\t  pop_temp_slots ();\n+\t  target_temp_slot_level = old_temp_level;\n+\t  /* There might something left from building the trees.  */\n+\t  if (cleanups_this_call)\n+\t    {\n+\t      expand_cleanups_to (NULL_TREE);\n+\t    }\n+\t  free_temp_slots ();\n \t}\n \n       if (TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (base_binfo)))\n@@ -749,11 +784,30 @@ expand_aggr_vbase_init_1 (binfo, exp, addr, init_list)\n {\n   tree init = purpose_member (binfo, init_list);\n   tree ref = build_indirect_ref (addr, NULL_PTR);\n+\n+  extern int temp_slot_level;\n+  extern int target_temp_slot_level; \n+  tree old_cleanups = cleanups_this_call;\n+  int old_temp_level = target_temp_slot_level;\n+  push_temp_slots ();\n+  push_temp_slots ();\n+  target_temp_slot_level = temp_slot_level;\n+\n   if (init)\n     init = TREE_VALUE (init);\n   /* Call constructors, but don't set up vtables.  */\n   expand_aggr_init_1 (binfo, exp, ref, init, 0, LOOKUP_COMPLAIN);\n-  expand_cleanups_to (NULL_TREE);\n+\n+  expand_cleanups_to (old_cleanups);\n+  pop_temp_slots ();\n+  pop_temp_slots ();\n+  target_temp_slot_level = old_temp_level;\n+  /* There might something left from building the trees.  */\n+  if (cleanups_this_call)\n+    {\n+      expand_cleanups_to (NULL_TREE);\n+    }\n+  free_temp_slots ();\n }\n \n /* Initialize this object's virtual base class pointers.  This must be\n@@ -818,8 +872,7 @@ do_member_init (s_id, name, init)\n /* Function to give error message if member initialization specification\n    is erroneous.  FIELD is the member we decided to initialize.\n    TYPE is the type for which the initialization is being performed.\n-   FIELD must be a member of TYPE, or the base type from which FIELD\n-   comes must not need a constructor.\n+   FIELD must be a member of TYPE.\n    \n    MEMBER_NAME is the name of the member.  */\n \n@@ -831,23 +884,12 @@ member_init_ok_or_else (field, type, member_name)\n {\n   if (field == error_mark_node)\n     return 0;\n-  if (field == NULL_TREE)\n+  if (field == NULL_TREE || DECL_CONTEXT (field) != type)\n     {\n       cp_error (\"class `%T' does not have any field named `%s'\", type,\n \t\tmember_name);\n       return 0;\n     }\n-  if (DECL_CONTEXT (field) != type\n-      && TYPE_NEEDS_CONSTRUCTING (DECL_CONTEXT (field)))\n-    {\n-      if (current_function_decl && DECL_CONSTRUCTOR_P (current_function_decl))\n-\tcp_error (\"initialization of `%D' inside constructor for `%T'\",\n-\t\t  field, type);\n-      else\n-\tcp_error (\"member `%D' comes from base class needing constructor\",\n-\t\t  field);\n-      return 0;\n-    }\n   if (TREE_STATIC (field))\n     {\n       cp_error (\"field `%#D' is static; only point of initialization is its declaration\",\n@@ -960,6 +1002,12 @@ expand_member_init (exp, name, init)\n \t      return;\n \t    }\n \n+\t  if (warn_reorder && current_member_init_list)\n+\t    {\n+\t      warning (\"base initializer for `%s'\", IDENTIFIER_POINTER (name));\n+\t      warning (\"   will be re-ordered to precede member initializations\");\n+\t    }\n+\n \t  base_init = build_tree_list (name, init);\n \t  TREE_TYPE (base_init) = basetype;\n \t  current_base_init_list = chainon (current_base_init_list, base_init);\n@@ -1354,12 +1402,15 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t\t}\n \t      else\n \t\t{\n+#if 0\n+\t\t  /* This causes testcase return2.C to fail.  */\n \t\t  init = TREE_OPERAND (init, 1);\n \t\t  init = build (CALL_EXPR, init_type,\n \t\t\t\tTREE_OPERAND (init, 0), TREE_OPERAND (init, 1), 0);\n \t\t  TREE_SIDE_EFFECTS (init) = 1;\n \t\t    if (init_list)\n \t\t      TREE_VALUE (init_list) = init;\n+#endif\n \t\t}\n \t    }\n \n@@ -1508,7 +1559,7 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t\t    cp_error (\"ambiguity between conversion to `%T' and constructor\",\n \t\t\t      type);\n \t\t  else\n-\t\t    expand_assignment (exp, rval, 0, 0);\n+\t\t    expand_aggr_init_1 (binfo, true_exp, exp, rval, alias_this, flags);\n \t\t  return;\n \t\t}\n \t    }\n@@ -1920,7 +1971,7 @@ build_offset_ref (cname, name)\n       if (TREE_CODE (t) == TYPE_DECL || TREE_CODE (t) == VAR_DECL\n \t  || TREE_CODE (t) == CONST_DECL)\n \t{\n-\t  TREE_USED (t) = 1;\n+\t  mark_used (t);\n \t  return t;\n \t}\n       if (TREE_CODE (t) == FIELD_DECL)\n@@ -2010,7 +2061,7 @@ build_offset_ref (cname, name)\n \t\t  error (\"in this context\");\n \t\t  return error_mark_node;\n \t\t}\n-\t      assemble_external (t);\n+\t      mark_used (t);\n \t      return build (OFFSET_REF, TREE_TYPE (t), decl, t);\n \t    }\n \n@@ -2037,8 +2088,10 @@ build_offset_ref (cname, name)\n \t\t  || ! allocation_temporary_p ()))\n \t    fnfields = copy_list (fnfields);\n \n+#if 0\n \t  for (t = TREE_VALUE (fnfields); t; t = DECL_CHAIN (t))\n \t    assemble_external (t);\n+#endif\n \n \t  t = build_tree_list (error_mark_node, fnfields);\n \t  TREE_TYPE (t) = build_offset_type (type, unknown_type_node);\n@@ -2070,8 +2123,7 @@ build_offset_ref (cname, name)\n      values can be returned without further ado.  */\n   if (TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == CONST_DECL)\n     {\n-      assemble_external (t);\n-      TREE_USED (t) = 1;\n+      mark_used (t);\n       return t;\n     }\n "}, {"sha": "2766c1bfb549e9d086bebebb16d128849237bcb4", "filename": "gcc/cp/lang-options.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-options.h?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -86,6 +86,8 @@ Boston, MA 02111-1307, USA.  */\n   \"-fno-this-is-variable\",\n   \"-fvtable-thunks\",\n   \"-fno-vtable-thunks\",\n+  \"-fweak\",\n+  \"-fno-weak\",\n   \"-fxref\",\n   \"-fno-xref\",\n "}, {"sha": "779593356f505a35e1480653aa5877ac7e980a55", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -883,24 +883,29 @@ yyprint (file, yychar, yylval)\n static int *reduce_count;\n int *token_count;\n \n+#if 0\n #define REDUCE_LENGTH (sizeof (yyr2) / sizeof (yyr2[0]))\n #define TOKEN_LENGTH (256 + sizeof (yytname) / sizeof (yytname[0]))\n+#endif\n \n int *\n init_parse ()\n {\n #ifdef GATHER_STATISTICS\n+#ifdef REDUCE_LENGTH\n   reduce_count = (int *)malloc (sizeof (int) * (REDUCE_LENGTH + 1));\n   bzero (reduce_count, sizeof (int) * (REDUCE_LENGTH + 1));\n   reduce_count += 1;\n   token_count = (int *)malloc (sizeof (int) * (TOKEN_LENGTH + 1));\n   bzero (token_count, sizeof (int) * (TOKEN_LENGTH + 1));\n   token_count += 1;\n+#endif\n #endif\n   return token_count;\n }\n \n #ifdef GATHER_STATISTICS\n+#ifdef REDUCE_LENGTH\n void\n yyhook (yyn)\n      int yyn;\n@@ -922,11 +927,13 @@ token_cmp (p, q)\n   return token_count[*q] - token_count[*p];\n }\n #endif\n+#endif\n \n void\n print_parse_statistics ()\n {\n #ifdef GATHER_STATISTICS\n+#ifdef REDUCE_LENGTH\n #if YYDEBUG != 0\n   int i;\n   int maxlen = REDUCE_LENGTH;\n@@ -969,6 +976,7 @@ print_parse_statistics ()\n   fprintf (stderr, \"\\n\");\n #endif\n #endif\n+#endif\n }\n \n /* Sets the value of the 'yydebug' variable to VALUE.\n@@ -2590,6 +2598,10 @@ check_newline ()\n \t      p->name = input_filename;\n \t      input_file_stack = p;\n \t      input_file_stack_tick++;\n+#ifdef DBX_DEBUGGING_INFO\n+\t      if (write_symbols == DBX_DEBUG)\n+\t\tdbxout_start_new_source_file (input_filename);\n+#endif\n #ifdef DWARF_DEBUGGING_INFO\n \t      if (debug_info_level == DINFO_LEVEL_VERBOSE\n \t\t  && write_symbols == DWARF_DEBUG)\n@@ -2627,6 +2639,10 @@ check_newline ()\n \t\t  input_file_stack = p->next;\n \t\t  free (p);\n \t\t  input_file_stack_tick++;\n+#ifdef DBX_DEBUGGING_INFO\n+\t\t  if (write_symbols == DBX_DEBUG)\n+\t\t    dbxout_resume_previous_source_file ();\n+#endif\n #ifdef DWARF_DEBUGGING_INFO\n \t\t  if (debug_info_level == DINFO_LEVEL_VERBOSE\n \t\t      && write_symbols == DWARF_DEBUG)\n@@ -2872,6 +2888,9 @@ do_identifier (token)\n {\n   register tree id = lastiddecl;\n \n+  if (IDENTIFIER_OPNAME_P (token))\n+    id = lookup_name (token, 0);\n+\n   if (yychar == YYEMPTY)\n     yychar = yylex ();\n   /* Scope class declarations before global\n@@ -2920,7 +2939,14 @@ do_identifier (token)\n \t  if (id && id != error_mark_node && TREE_TYPE (id) == error_mark_node)\n \t    return id;\n \t}\n-      if (yychar == '(' || yychar == LEFT_RIGHT)\n+\n+      if (IDENTIFIER_OPNAME_P (token))\n+\t{\n+\t  if (token != ansi_opname[ERROR_MARK])\n+\t    cp_error (\"operator %O not defined\", token);\n+\t  id = error_mark_node;\n+\t}\n+      else if (yychar == '(' || yychar == LEFT_RIGHT)\n \t{\n \t  id = implicitly_declare (token);\n \t}\n@@ -4360,7 +4386,9 @@ real_yylex ()\n done:\n /*  yylloc.last_line = lineno; */\n #ifdef GATHER_STATISTICS\n+#ifdef REDUCE_LENGTH\n   token_count[value] += 1;\n+#endif\n #endif\n \n   return value;"}, {"sha": "d50ea90d6a905bcd670f3069caed23dbae616a2f", "filename": "gcc/cp/method.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -178,8 +178,13 @@ report_type_mismatch (cp, parmtypes, name_kind)\n       /* Happens when the implicit object parameter is rejected.  */\n       my_friendly_assert (! TYPE_READONLY (TREE_TYPE (TREE_VALUE (parmtypes))),\n \t\t\t  241);\n-      cp_error (\"call to non-const %s `%#D' with const object\",\n-\t\tname_kind, cp->function);\n+      if (TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (TREE_VALUE (parmtypes))))\n+\t  && ! TYPE_VOLATILE (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (cp->function))))))\n+\tcp_error (\"call to non-volatile %s `%#D' with volatile object\",\n+\t\t  name_kind, cp->function);\n+      else\n+\tcp_error (\"call to non-const %s `%#D' with const object\",\n+\t\t  name_kind, cp->function);\n       return;\n     }\n \n@@ -1547,6 +1552,7 @@ hack_identifier (value, name, yychar)\n \n   if (really_overloaded_fn (value))\n     {\n+#if 0\n       tree t = get_first_fn (value);\n       for (; t; t = DECL_CHAIN (t))\n \t{\n@@ -1556,22 +1562,20 @@ hack_identifier (value, name, yychar)\n \t  assemble_external (t);\n \t  TREE_USED (t) = 1;\n \t}\n+#endif\n     }\n   else if (TREE_CODE (value) == TREE_LIST)\n     {\n+      /* Ambiguous reference to base members, possibly other cases?.  */\n       tree t = value;\n       while (t && TREE_CODE (t) == TREE_LIST)\n \t{\n-\t  assemble_external (TREE_VALUE (t));\n-\t  TREE_USED (t) = 1;\n+\t  mark_used (TREE_VALUE (t));\n \t  t = TREE_CHAIN (t);\n \t}\n     }\n   else\n-    {\n-      assemble_external (value);\n-      TREE_USED (value) = 1;\n-    }\n+    mark_used (value);\n \n   if (TREE_CODE_CLASS (TREE_CODE (value)) == 'd' && DECL_NONLOCAL (value))\n     {\n@@ -1800,14 +1804,17 @@ make_thunk (function, delta)\n     }\n   if (thunk == NULL_TREE)\n     {\n-      thunk = build_decl (THUNK_DECL, thunk_id, TREE_TYPE (func_decl));\n+      thunk = build_decl (FUNCTION_DECL, thunk_id, TREE_TYPE (func_decl));\n       DECL_RESULT (thunk)\n \t= build_decl (RESULT_DECL, 0, TYPE_MAIN_VARIANT (TREE_TYPE (vtable_entry_type)));\n       TREE_READONLY (thunk) = TYPE_READONLY (TREE_TYPE (vtable_entry_type));\n       TREE_THIS_VOLATILE (thunk) = TYPE_VOLATILE (TREE_TYPE (vtable_entry_type));\n       make_function_rtl (thunk);\n+      TREE_SET_CODE (thunk, THUNK_DECL);\n       DECL_INITIAL (thunk) = function;\n       THUNK_DELTA (thunk) = delta;\n+      DECL_EXTERNAL (thunk) = 1;\n+      TREE_PUBLIC (thunk) = 1;\n       /* So that finish_file can write out any thunks that need to be: */\n       pushdecl_top_level (thunk);\n     }\n@@ -1845,16 +1852,11 @@ emit_thunk (thunk_fndecl)\n \n   TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n \n-  if (TREE_PUBLIC (function))\n-    {\n-      TREE_PUBLIC (thunk_fndecl) = 1;\n-      if (DECL_EXTERNAL (function))\n-\t{\n-\t  DECL_EXTERNAL (thunk_fndecl) = 1;\n-\t  assemble_external (thunk_fndecl);\n-\t  return;\n-\t}\n-    }\n+  if (! TREE_PUBLIC (function))\n+    TREE_PUBLIC (thunk_fndecl) = 0;\n+  if (DECL_EXTERNAL (function))\n+    return;\n+  DECL_EXTERNAL (thunk_fndecl) = 0;\n \n   decl_printable_name = thunk_printable_name;\n   if (current_function_decl)"}, {"sha": "d36624adc6b32352fd4cefb475072b86fe163d76", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -661,8 +661,9 @@ fn.def1:\n \t\t  reinit_parse_for_function ();\n \t\t  $$ = NULL_TREE; }\n \t| declmods notype_declarator exception_specification_opt\n-\t\t{ tree specs = strip_attrs ($1);\n-\t\t  if (! start_function (specs, $2, $3, NULL_TREE, 0))\n+\t\t{ tree specs, attrs;\n+\t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  if (! start_function (specs, $2, $3, attrs, 0))\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function ();\n \t\t  $$ = NULL_TREE; }\n@@ -1306,18 +1307,6 @@ primary:\n \t\t{\n \t\t  if (TREE_CODE ($$) == BIT_NOT_EXPR)\n \t\t    $$ = build_x_unary_op (BIT_NOT_EXPR, TREE_OPERAND ($$, 0));\n-\t\t  else if (IDENTIFIER_OPNAME_P ($$))\n-\t\t    {\n-\t\t      tree op = $$;\n-\t\t      $$ = lookup_name (op, 0);\n-\t\t      if ($$ == NULL_TREE)\n-\t\t\t{\n-\t\t\t  if (op != ansi_opname[ERROR_MARK])\n-\t\t\t    error (\"operator %s not defined\",\n-\t\t\t\t   operator_name_string (op));\n-\t\t\t  $$ = error_mark_node;\n-\t\t\t}\n-\t\t    }\n \t\t  else\n \t\t    $$ = do_identifier ($$);\n \t\t}\t\t\n@@ -1531,10 +1520,9 @@ primary:\n \t\t  else\n \t\t    {\n \t\t      if (TREE_CODE ($$) == ADDR_EXPR)\n-\t\t\tassemble_external (TREE_OPERAND ($$, 0));\n+\t\t\tmark_used (TREE_OPERAND ($$, 0));\n \t\t      else\n-\t\t\tassemble_external ($$);\n-\t\t      TREE_USED ($$) = 1;\n+\t\t\tmark_used ($$);\n \t\t    }\n \t\t  if (TREE_CODE ($$) == CONST_DECL)\n \t\t    {\n@@ -3545,6 +3533,9 @@ for.init.statement:\n \t\t{ if ($1) cplus_expand_expr_stmt ($1); }\n \t| decl\n \t| '{' compstmtend\n+\t\t{ if (pedantic)\n+\t\t    pedwarn (\"ANSI C++ forbids compound statements inside for initializations\");\n+\t\t}\n \t;\n \n /* Either a type-qualifier or nothing.  First thing in an `asm' statement.  */"}, {"sha": "b80bff0b9252417351596dd3fe1ded080f480208", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -2400,7 +2400,7 @@ do_pending_expansions ()\n       if (i->interface == 1)\n \t/* OK, it was an implicit instantiation.  */\n \t{\n-\t  if (SUPPORTS_WEAK)\n+\t  if (flag_weak)\n \t    DECL_WEAK (t) = 1;\n \t  else\n \t    TREE_PUBLIC (t) = 0;\n@@ -2533,6 +2533,8 @@ do_function_instantiation (declspecs, declarator, storage)\n       fn = IDENTIFIER_GLOBAL_VALUE (name),\n       fn && DECL_TEMPLATE_INSTANTIATION (fn))\n     result = fn;\n+  else if (fn && DECL_CONTEXT (fn))\n+    ;\n   else if (name = DECL_NAME (decl), fn = IDENTIFIER_GLOBAL_VALUE (name), fn)\n     {\n       for (fn = get_first_fn (fn); fn; fn = DECL_CHAIN (fn))"}, {"sha": "14b8d0135bc074cc49222a6b90e69bfc4e8efa33", "filename": "gcc/cp/search.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -3507,11 +3507,17 @@ static void\n add_conversions (binfo)\n      tree binfo;\n {\n-  tree tmp = CLASSTYPE_FIRST_CONVERSION (BINFO_TYPE (binfo));\n-  for (; tmp && IDENTIFIER_TYPENAME_P (DECL_NAME (tmp));\n-       tmp = TREE_CHAIN (tmp))\n-    conversions = tree_cons (DECL_NAME (tmp), TREE_TYPE (TREE_TYPE (tmp)),\n-\t\t\t     conversions);\n+  int i;\n+  tree vec = CLASSTYPE_METHOD_VEC (BINFO_TYPE (binfo));\n+\n+  for (i = 1; i < TREE_VEC_LENGTH (vec); ++i)\n+    {\n+      tree tmp = TREE_VEC_ELT (vec, i);\n+      if (! IDENTIFIER_TYPENAME_P (DECL_NAME (tmp)))\n+\tbreak;\n+      conversions = tree_cons (DECL_NAME (tmp), TREE_TYPE (TREE_TYPE (tmp)),\n+\t\t\t       conversions);\n+    }\n }\n \n tree"}, {"sha": "3cb6d79a57f56710804d58ae890ce32f08296fef", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 45, "deletions": 18, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -1766,7 +1766,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t\t  my_friendly_assert (datum != error_mark_node, 310);\n \t\t\t  fndecl = build_vfn_ref (&addr, datum, DECL_VINDEX (fndecl));\n \t\t\t}\n-\t\t      assemble_external (fndecl);\n+\t\t      mark_used (fndecl);\n \t\t      return fndecl;\n \t\t    }\n \t\t  if (access == access_protected)\n@@ -1781,8 +1781,10 @@ build_component_ref (datum, component, basetype_path, protect)\n                      not matter unless we're actually calling the function.  */\n \t\t  tree t;\n \n+#if 0\n \t\t  for (t = TREE_VALUE (fndecls); t; t = DECL_CHAIN (t))\n \t\t    assemble_external (t);\n+#endif\n \n \t\t  t = build_tree_list (error_mark_node, fndecls);\n \t\t  TREE_TYPE (t) = build_offset_type (basetype,\n@@ -1809,9 +1811,10 @@ build_component_ref (datum, component, basetype_path, protect)\n \t      cp_error (\"invalid use of type decl `%#D' as expression\", field);\n \t      return error_mark_node;\n \t    }\n- \t  if (DECL_RTL (field) != 0)\n-\t    assemble_external (field);\n-\t  TREE_USED (field) = 1;\n+\t  else if (DECL_RTL (field) != 0)\n+\t    mark_used (field);\n+\t  else\n+\t    TREE_USED (field) = 1;\n \t  return field;\n \t}\n     }\n@@ -2347,7 +2350,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \n \t  /* Save the intermediate result in a SAVE_EXPR so we don't have to\n \t     compute each component of the virtual function pointer twice.  */ \n-\t  if (/* !building_cleanup && */ TREE_CODE (aref) == INDIRECT_REF)\n+\t  if (TREE_CODE (aref) == INDIRECT_REF)\n \t    TREE_OPERAND (aref, 0) = save_expr (TREE_OPERAND (aref, 0));\n       \n \t  delta = build_binary_op (PLUS_EXPR,\n@@ -2400,7 +2403,7 @@ build_function_call_real (function, params, require_complete, flags)\n       GNU_xref_call (current_function_decl,\n \t\t     IDENTIFIER_POINTER (name ? name\n \t\t\t\t\t : TYPE_IDENTIFIER (DECL_CLASS_CONTEXT (function))));\n-      assemble_external (function);\n+      mark_used (function);\n       fndecl = function;\n \n       /* Convert anything with function type to a pointer-to-function.  */\n@@ -2426,8 +2429,7 @@ build_function_call_real (function, params, require_complete, flags)\n       if (DECL_INLINE (function))\n \t{\n \t  /* Is it a synthesized method that needs to be synthesized?  */\n-\t  if (DECL_ARTIFICIAL (function) && ! flag_no_inline\n-\t      && ! DECL_INITIAL (function)\n+\t  if (DECL_ARTIFICIAL (function) && ! DECL_INITIAL (function)\n \t      /* Kludge: don't synthesize for default args.  */\n \t      && current_function_decl)\n \t    synthesize_method (function);\n@@ -2438,11 +2440,7 @@ build_function_call_real (function, params, require_complete, flags)\n \t  function = build1 (ADDR_EXPR, build_pointer_type (fntype), function);\n \t}\n       else\n-\t{\n-\t  assemble_external (function);\n-\t  TREE_USED (function) = 1;\n-\t  function = default_conversion (function);\n-\t}\n+\tfunction = default_conversion (function);\n     }\n   else\n     {\n@@ -2718,7 +2716,8 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n \t\ttype = integer_type_node;\n #endif\n-\t      parmval = convert_for_initialization (return_loc, type, val, flags,\n+\t      parmval = convert_for_initialization (return_loc, type, val,\n+\t\t\t\t\t\t    flags|INDIRECT_BIND,\n \t\t\t\t\t\t    \"argument passing\", fndecl, i);\n #ifdef PROMOTE_PROTOTYPES\n \t      if ((TREE_CODE (type) == INTEGER_TYPE\n@@ -3554,6 +3553,17 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  tree primop0 = get_narrower (op0, &unsignedp0);\n \t  tree primop1 = get_narrower (op1, &unsignedp1);\n \n+\t  /* Check for comparison of different enum types. */\n+\t  if (flag_int_enum_equivalence == 0 \n+\t      && TREE_CODE (TREE_TYPE (orig_op0)) == ENUMERAL_TYPE \n+\t      && TREE_CODE (TREE_TYPE (orig_op1)) == ENUMERAL_TYPE \n+\t      && TYPE_MAIN_VARIANT (TREE_TYPE (orig_op0))\n+\t         != TYPE_MAIN_VARIANT (TREE_TYPE (orig_op1)))\n+\t    {\n+\t      cp_warning (\"comparison between `%#T' and `%#T'\", \n+\t\t\t  TREE_TYPE (orig_op0), TREE_TYPE (orig_op1));\n+\t    }\n+\n \t  /* Give warnings for comparisons between signed and unsigned\n \t     quantities that may fail.  */\n \t  /* Do the checking based on the original operand trees, so that\n@@ -4068,7 +4078,7 @@ build_unary_op (code, xarg, noconvert)\n \t  case FIX_ROUND_EXPR:\n \t  case FIX_CEIL_EXPR:\n \t    {\n-\t      tree incremented, modify, value;\n+\t      tree incremented, modify, value, compound;\n \t      if (! lvalue_p (arg) && pedantic)\n \t\tpedwarn (\"cast to non-reference type used as lvalue\");\n \t      arg = stabilize_reference (arg);\n@@ -4081,8 +4091,13 @@ build_unary_op (code, xarg, noconvert)\n \t\t\t\t    ? PLUS_EXPR : MINUS_EXPR),\n \t\t\t\t   argtype, value, inc);\n \t      TREE_SIDE_EFFECTS (incremented) = 1;\n+\n \t      modify = build_modify_expr (arg, NOP_EXPR, incremented);\n-\t      return build (COMPOUND_EXPR, TREE_TYPE (arg), modify, value);\n+\t      compound = build (COMPOUND_EXPR, TREE_TYPE (arg), modify, value);\n+\n+\t      /* Eliminate warning about unused result of + or -. */\n+\t      TREE_NO_UNUSED_WARNING (compound) = 1;\n+\t      return compound;\n \t    }\n \t  }\n \n@@ -4549,8 +4564,6 @@ mark_addressable (exp)\n \tTREE_ADDRESSABLE (x) = 1;\n \tTREE_USED (x) = 1;\n \tTREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (x)) = 1;\n-\tif (asm_out_file)\n-\t  assemble_external (x);\n \treturn 1;\n \n       default:\n@@ -5563,9 +5576,19 @@ tree\n expand_target_expr (t)\n      tree t;\n {\n+  extern int temp_slot_level;\n+  extern int target_temp_slot_level;\n+  int old_temp_level = target_temp_slot_level;\n+\n   tree xval = make_node (RTL_EXPR);\n   rtx rtxval;\n \n+  /* Any TARGET_EXPR temps live only as long as the outer temp level.\n+     Since they are preserved in this new inner level, we know they\n+     will make it into the outer level.  */\n+  push_temp_slots ();\n+  target_temp_slot_level = temp_slot_level;\n+\n   do_pending_stack_adjust ();\n   start_sequence_for_rtl_expr (xval);\n   emit_note (0, -1);\n@@ -5576,6 +5599,10 @@ expand_target_expr (t)\n   end_sequence ();\n   RTL_EXPR_RTL (xval) = rtxval;\n   TREE_TYPE (xval) = TREE_TYPE (t);\n+\n+  pop_temp_slots ();\n+  target_temp_slot_level = old_temp_level;\n+\n   return xval;\n }\n "}, {"sha": "02ac42d38e8c029458356c454d5a65d3608af956", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b7eeff72ff8775207e3708511d808cbe94ef3d/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=72b7eeff72ff8775207e3708511d808cbe94ef3d", "patch": "@@ -569,8 +569,6 @@ store_init_value (decl, init)\n       if (TREE_CODE (init) == CONSTRUCTOR)\n \t{\n \t  tree field;\n-\t  tree funcs;\n-\t  int func;\n \n \t  /* Check that we're really an aggregate as ARM 8.4.1 defines it.  */\n \t  if (CLASSTYPE_N_BASECLASSES (type))\n@@ -588,16 +586,11 @@ store_init_value (decl, init)\n \t\tcp_error_at (\"initializer list construction invalid for `%D'\", decl);\n \t\tcp_error_at (\"due to non-public access of member `%D'\", field);\n \t      }\n-\t  funcs = TYPE_METHODS (type);\n-\t  if (funcs)\n-\t    for (func = 0; func < TREE_VEC_LENGTH (funcs); func++)\n+\t  for (field = TYPE_METHODS (type); field; field = TREE_CHAIN (field))\n+\t    if (TREE_PRIVATE (field) || TREE_PROTECTED (field))\n \t      {\n-\t\tfield = TREE_VEC_ELT (funcs, func);\n-\t\tif (field && (TREE_PRIVATE (field) || TREE_PROTECTED (field)))\n-\t\t  {\n-\t\t    cp_error_at (\"initializer list construction invalid for `%D'\", decl);\n-\t\t    cp_error_at (\"due to non-public access of member `%D'\", field);\n-\t\t  }\n+\t\tcp_error_at (\"initializer list construction invalid for `%D'\", decl);\n+\t\tcp_error_at (\"due to non-public access of member `%D'\", field);\n \t      }\n \t}\n #endif\n@@ -894,10 +887,16 @@ digest_init (type, init, tail)\n \treturn process_init_constructor (type, init, (tree *)0);\n       else if (TYPE_NON_AGGREGATE_CLASS (type))\n \t{\n+#if 0\n+\t  /* This isn't true.  */\n \t  /* This can only be reached when caller is initializing\n \t     ARRAY_TYPE.  In that case, we don't want to convert\n \t     INIT to TYPE.  We will let `expand_vec_init' do it.  */\n \t  return init;\n+#else\n+\t  return convert_for_initialization (0, type, init, LOOKUP_NORMAL,\n+\t\t\t\t\t     \"initialization\", NULL_TREE, 0);\n+#endif\n \t}\n       else if (tail != 0)\n \t{"}]}