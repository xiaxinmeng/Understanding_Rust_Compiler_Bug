{"sha": "0cf686948bf515dcfcc47314ab75fda468fe7357", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNmNjg2OTQ4YmY1MTVkY2ZjYzQ3MzE0YWI3NWZkYTQ2OGZlNzM1Nw==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2013-10-07T12:56:08Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2013-10-07T12:56:08Z"}, "message": "vector.md (mov<mode>): Emit permuted move sequences for LE VSX loads and stores at expand time.\n\ngcc:\n\n2013-10-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* config/rs6000/vector.md (mov<mode>): Emit permuted move\n\tsequences for LE VSX loads and stores at expand time.\n\t* config/rs6000/rs6000-protos.h (rs6000_emit_le_vsx_move): New\n\tprototype.\n\t* config/rs6000/rs6000.c (rs6000_const_vec): New.\n\t(rs6000_gen_le_vsx_permute): New.\n\t(rs6000_gen_le_vsx_load): New.\n\t(rs6000_gen_le_vsx_store): New.\n\t(rs6000_gen_le_vsx_move): New.\n\t* config/rs6000/vsx.md (*vsx_le_perm_load_v2di): New.\n\t(*vsx_le_perm_load_v4si): New.\n\t(*vsx_le_perm_load_v8hi): New.\n\t(*vsx_le_perm_load_v16qi): New.\n\t(*vsx_le_perm_store_v2di): New.\n\t(*vsx_le_perm_store_v4si): New.\n\t(*vsx_le_perm_store_v8hi): New.\n\t(*vsx_le_perm_store_v16qi): New.\n\t(*vsx_xxpermdi2_le_<mode>): New.\n\t(*vsx_xxpermdi4_le_<mode>): New.\n\t(*vsx_xxpermdi8_le_V8HI): New.\n\t(*vsx_xxpermdi16_le_V16QI): New.\n\t(*vsx_lxvd2x2_le_<mode>): New.\n\t(*vsx_lxvd2x4_le_<mode>): New.\n\t(*vsx_lxvd2x8_le_V8HI): New.\n\t(*vsx_lxvd2x16_le_V16QI): New.\n\t(*vsx_stxvd2x2_le_<mode>): New.\n\t(*vsx_stxvd2x4_le_<mode>): New.\n\t(*vsx_stxvd2x8_le_V8HI): New.\n\t(*vsx_stxvd2x16_le_V16QI): New.\n\ngcc/testsuite:\n\n2013-10-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/pr43154.c: Skip for ppc64 little endian.\n\t* gcc.target/powerpc/fusion.c: Likewise.\n\nFrom-SVN: r203246", "tree": {"sha": "14595a844d5fc43affc70a293b8c1cb0dac38a02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14595a844d5fc43affc70a293b8c1cb0dac38a02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0cf686948bf515dcfcc47314ab75fda468fe7357", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cf686948bf515dcfcc47314ab75fda468fe7357", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cf686948bf515dcfcc47314ab75fda468fe7357", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cf686948bf515dcfcc47314ab75fda468fe7357/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9520e1eb27fbd088852a4800bdccdd7ecf1054dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9520e1eb27fbd088852a4800bdccdd7ecf1054dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9520e1eb27fbd088852a4800bdccdd7ecf1054dd"}], "stats": {"total": 531, "additions": 530, "deletions": 1}, "files": [{"sha": "f025d8319685aeea16c86b9e28dde0d78c239b9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cf686948bf515dcfcc47314ab75fda468fe7357/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cf686948bf515dcfcc47314ab75fda468fe7357/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0cf686948bf515dcfcc47314ab75fda468fe7357", "patch": "@@ -1,3 +1,35 @@\n+2013-10-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/vector.md (mov<mode>): Emit permuted move\n+\tsequences for LE VSX loads and stores at expand time.\n+\t* config/rs6000/rs6000-protos.h (rs6000_emit_le_vsx_move): New\n+\tprototype.\n+\t* config/rs6000/rs6000.c (rs6000_const_vec): New.\n+\t(rs6000_gen_le_vsx_permute): New.\n+\t(rs6000_gen_le_vsx_load): New.\n+\t(rs6000_gen_le_vsx_store): New.\n+\t(rs6000_gen_le_vsx_move): New.\n+\t* config/rs6000/vsx.md (*vsx_le_perm_load_v2di): New.\n+\t(*vsx_le_perm_load_v4si): New.\n+\t(*vsx_le_perm_load_v8hi): New.\n+\t(*vsx_le_perm_load_v16qi): New.\n+\t(*vsx_le_perm_store_v2di): New.\n+\t(*vsx_le_perm_store_v4si): New.\n+\t(*vsx_le_perm_store_v8hi): New.\n+\t(*vsx_le_perm_store_v16qi): New.\n+\t(*vsx_xxpermdi2_le_<mode>): New.\n+\t(*vsx_xxpermdi4_le_<mode>): New.\n+\t(*vsx_xxpermdi8_le_V8HI): New.\n+\t(*vsx_xxpermdi16_le_V16QI): New.\n+\t(*vsx_lxvd2x2_le_<mode>): New.\n+\t(*vsx_lxvd2x4_le_<mode>): New.\n+\t(*vsx_lxvd2x8_le_V8HI): New.\n+\t(*vsx_lxvd2x16_le_V16QI): New.\n+\t(*vsx_stxvd2x2_le_<mode>): New.\n+\t(*vsx_stxvd2x4_le_<mode>): New.\n+\t(*vsx_stxvd2x8_le_V8HI): New.\n+\t(*vsx_stxvd2x16_le_V16QI): New.\n+\n 2013-10-07  Renlin Li  <Renlin.Li@arm.com>\n \n \t* config/arm/arm-cores.def (cortex-a53): Use cortex tuning."}, {"sha": "9aa9429b83c546fa29b189164f9f974c8c3c07cd", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cf686948bf515dcfcc47314ab75fda468fe7357/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cf686948bf515dcfcc47314ab75fda468fe7357/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=0cf686948bf515dcfcc47314ab75fda468fe7357", "patch": "@@ -122,6 +122,7 @@ extern rtx rs6000_longcall_ref (rtx);\n extern void rs6000_fatal_bad_address (rtx);\n extern rtx create_TOC_reference (rtx, rtx);\n extern void rs6000_split_multireg_move (rtx, rtx);\n+extern void rs6000_emit_le_vsx_move (rtx, rtx, enum machine_mode);\n extern void rs6000_emit_move (rtx, rtx, enum machine_mode);\n extern rtx rs6000_secondary_memory_needed_rtx (enum machine_mode);\n extern rtx (*rs6000_legitimize_reload_address_ptr) (rtx, enum machine_mode,"}, {"sha": "a2028e2c33c5fa6f2decd6282dfc347b620652c2", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cf686948bf515dcfcc47314ab75fda468fe7357/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cf686948bf515dcfcc47314ab75fda468fe7357/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0cf686948bf515dcfcc47314ab75fda468fe7357", "patch": "@@ -7665,6 +7665,106 @@ rs6000_eliminate_indexed_memrefs (rtx operands[2])\n \t\t\t       copy_addr_to_reg (XEXP (operands[1], 0)));\n }\n \n+/* Generate a vector of constants to permute MODE for a little-endian\n+   storage operation by swapping the two halves of a vector.  */\n+static rtvec\n+rs6000_const_vec (enum machine_mode mode)\n+{\n+  int i, subparts;\n+  rtvec v;\n+\n+  switch (mode)\n+    {\n+    case V2DFmode:\n+    case V2DImode:\n+      subparts = 2;\n+      break;\n+    case V4SFmode:\n+    case V4SImode:\n+      subparts = 4;\n+      break;\n+    case V8HImode:\n+      subparts = 8;\n+      break;\n+    case V16QImode:\n+      subparts = 16;\n+      break;\n+    default:\n+      gcc_unreachable();\n+    }\n+\n+  v = rtvec_alloc (subparts);\n+\n+  for (i = 0; i < subparts / 2; ++i)\n+    RTVEC_ELT (v, i) = gen_rtx_CONST_INT (DImode, i + subparts / 2);\n+  for (i = subparts / 2; i < subparts; ++i)\n+    RTVEC_ELT (v, i) = gen_rtx_CONST_INT (DImode, i - subparts / 2);\n+\n+  return v;\n+}\n+\n+/* Generate a permute rtx that represents an lxvd2x, stxvd2x, or xxpermdi\n+   for a VSX load or store operation.  */\n+rtx\n+rs6000_gen_le_vsx_permute (rtx source, enum machine_mode mode)\n+{\n+  rtx par = gen_rtx_PARALLEL (VOIDmode, rs6000_const_vec (mode));\n+  return gen_rtx_VEC_SELECT (mode, source, par);\n+}\n+\n+/* Emit a little-endian load from vector memory location SOURCE to VSX\n+   register DEST in mode MODE.  The load is done with two permuting\n+   insn's that represent an lxvd2x and xxpermdi.  */\n+void\n+rs6000_emit_le_vsx_load (rtx dest, rtx source, enum machine_mode mode)\n+{\n+  rtx tmp = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (dest) : dest;\n+  rtx permute_mem = rs6000_gen_le_vsx_permute (source, mode);\n+  rtx permute_reg = rs6000_gen_le_vsx_permute (tmp, mode);\n+  emit_insn (gen_rtx_SET (VOIDmode, tmp, permute_mem));\n+  emit_insn (gen_rtx_SET (VOIDmode, dest, permute_reg));\n+}\n+\n+/* Emit a little-endian store to vector memory location DEST from VSX\n+   register SOURCE in mode MODE.  The store is done with two permuting\n+   insn's that represent an xxpermdi and an stxvd2x.  */\n+void\n+rs6000_emit_le_vsx_store (rtx dest, rtx source, enum machine_mode mode)\n+{\n+  rtx tmp = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (source) : source;\n+  rtx permute_src = rs6000_gen_le_vsx_permute (source, mode);\n+  rtx permute_tmp = rs6000_gen_le_vsx_permute (tmp, mode);\n+  emit_insn (gen_rtx_SET (VOIDmode, tmp, permute_src));\n+  emit_insn (gen_rtx_SET (VOIDmode, dest, permute_tmp));\n+}\n+\n+/* Emit a sequence representing a little-endian VSX load or store,\n+   moving data from SOURCE to DEST in mode MODE.  This is done\n+   separately from rs6000_emit_move to ensure it is called only\n+   during expand.  LE VSX loads and stores introduced later are\n+   handled with a split.  The expand-time RTL generation allows\n+   us to optimize away redundant pairs of register-permutes.  */\n+void\n+rs6000_emit_le_vsx_move (rtx dest, rtx source, enum machine_mode mode)\n+{\n+  gcc_assert (!BYTES_BIG_ENDIAN\n+\t      && VECTOR_MEM_VSX_P (mode)\n+\t      && mode != TImode\n+\t      && (MEM_P (source) ^ MEM_P (dest)));\n+\n+  if (MEM_P (source))\n+    {\n+      gcc_assert (REG_P (dest));\n+      rs6000_emit_le_vsx_load (dest, source, mode);\n+    }\n+  else\n+    {\n+      if (!REG_P (source))\n+\tsource = force_reg (mode, source);\n+      rs6000_emit_le_vsx_store (dest, source, mode);\n+    }\n+}\n+\n /* Emit a move from SOURCE to DEST in mode MODE.  */\n void\n rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)"}, {"sha": "cbb1f4f8e7246a6c142fa2503d3729a65189e5b3", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cf686948bf515dcfcc47314ab75fda468fe7357/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cf686948bf515dcfcc47314ab75fda468fe7357/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=0cf686948bf515dcfcc47314ab75fda468fe7357", "patch": "@@ -88,7 +88,8 @@\n \t\t\t\t (smax \"smax\")])\n \n \f\n-;; Vector move instructions.\n+;; Vector move instructions.  Little-endian VSX loads and stores require\n+;; special handling to circumvent \"element endianness.\"\n (define_expand \"mov<mode>\"\n   [(set (match_operand:VEC_M 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:VEC_M 1 \"any_operand\" \"\"))]\n@@ -104,6 +105,15 @@\n \t       && !vlogical_operand (operands[1], <MODE>mode))\n \toperands[1] = force_reg (<MODE>mode, operands[1]);\n     }\n+  if (!BYTES_BIG_ENDIAN\n+      && VECTOR_MEM_VSX_P (<MODE>mode)\n+      && <MODE>mode != TImode\n+      && (memory_operand (operands[0], <MODE>mode)\n+          ^ memory_operand (operands[1], <MODE>mode)))\n+    {\n+      rs6000_emit_le_vsx_move (operands[0], operands[1], <MODE>mode);\n+      DONE;\n+    }\n })\n \n ;; Generic vector floating point load/store instructions.  These will match"}, {"sha": "517fac66be35c6739cea57c06428523d94afd447", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cf686948bf515dcfcc47314ab75fda468fe7357/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cf686948bf515dcfcc47314ab75fda468fe7357/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=0cf686948bf515dcfcc47314ab75fda468fe7357", "patch": "@@ -216,6 +216,238 @@\n   ])\n \n ;; VSX moves\n+\n+;; The patterns for LE permuted loads and stores come before the general\n+;; VSX moves so they match first.\n+(define_insn_and_split \"*vsx_le_perm_load_v2di\"\n+  [(set (match_operand:V2DI 0 \"vsx_register_operand\" \"=wa\")\n+        (match_operand:V2DI 1 \"memory_operand\" \"Z\"))]\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  \"#\"\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  [(set (match_dup 2)\n+        (vec_select:V2DI\n+          (match_dup 1)\n+          (parallel [(const_int 1) (const_int 0)])))\n+   (set (match_dup 0)\n+        (vec_select:V2DI\n+          (match_dup 2)\n+          (parallel [(const_int 1) (const_int 0)])))]\n+  \"\n+{\n+  operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[0])\n+                                       : operands[0];\n+}\n+  \"\n+  [(set_attr \"type\" \"vecload\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn_and_split \"*vsx_le_perm_load_v4si\"\n+  [(set (match_operand:V4SI 0 \"vsx_register_operand\" \"=wa\")\n+        (match_operand:V4SI 1 \"memory_operand\" \"Z\"))]\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  \"#\"\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  [(set (match_dup 2)\n+        (vec_select:V4SI\n+          (match_dup 1)\n+          (parallel [(const_int 2) (const_int 3)\n+                     (const_int 0) (const_int 1)])))\n+   (set (match_dup 0)\n+        (vec_select:V4SI\n+          (match_dup 2)\n+          (parallel [(const_int 2) (const_int 3)\n+                     (const_int 0) (const_int 1)])))]\n+  \"\n+{\n+  operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[0])\n+                                       : operands[0];\n+}\n+  \"\n+  [(set_attr \"type\" \"vecload\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn_and_split \"*vsx_le_perm_load_v8hi\"\n+  [(set (match_operand:V8HI 0 \"vsx_register_operand\" \"=wa\")\n+        (match_operand:V8HI 1 \"memory_operand\" \"Z\"))]\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  \"#\"\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  [(set (match_dup 2)\n+        (vec_select:V8HI\n+          (match_dup 1)\n+          (parallel [(const_int 4) (const_int 5)\n+                     (const_int 6) (const_int 7)\n+                     (const_int 0) (const_int 1)\n+                     (const_int 2) (const_int 3)])))\n+   (set (match_dup 0)\n+        (vec_select:V8HI\n+          (match_dup 2)\n+          (parallel [(const_int 4) (const_int 5)\n+                     (const_int 6) (const_int 7)\n+                     (const_int 0) (const_int 1)\n+                     (const_int 2) (const_int 3)])))]\n+  \"\n+{\n+  operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[0])\n+                                       : operands[0];\n+}\n+  \"\n+  [(set_attr \"type\" \"vecload\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn_and_split \"*vsx_le_perm_load_v16qi\"\n+  [(set (match_operand:V16QI 0 \"vsx_register_operand\" \"=wa\")\n+        (match_operand:V16QI 1 \"memory_operand\" \"Z\"))]\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  \"#\"\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  [(set (match_dup 2)\n+        (vec_select:V16QI\n+          (match_dup 1)\n+          (parallel [(const_int 8) (const_int 9)\n+                     (const_int 10) (const_int 11)\n+                     (const_int 12) (const_int 13)\n+                     (const_int 14) (const_int 15)\n+                     (const_int 0) (const_int 1)\n+                     (const_int 2) (const_int 3)\n+                     (const_int 4) (const_int 5)\n+                     (const_int 6) (const_int 7)])))\n+   (set (match_dup 0)\n+        (vec_select:V16QI\n+          (match_dup 2)\n+          (parallel [(const_int 8) (const_int 9)\n+                     (const_int 10) (const_int 11)\n+                     (const_int 12) (const_int 13)\n+                     (const_int 14) (const_int 15)\n+                     (const_int 0) (const_int 1)\n+                     (const_int 2) (const_int 3)\n+                     (const_int 4) (const_int 5)\n+                     (const_int 6) (const_int 7)])))]\n+  \"\n+{\n+  operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[0])\n+                                       : operands[0];\n+}\n+  \"\n+  [(set_attr \"type\" \"vecload\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn_and_split \"*vsx_le_perm_store_v2di\"\n+  [(set (match_operand:V2DI 0 \"memory_operand\" \"=Z\")\n+        (match_operand:V2DI 1 \"vsx_register_operand\" \"+wa\"))]\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  \"#\"\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  [(set (match_dup 2)\n+        (vec_select:V2DI\n+          (match_dup 1)\n+          (parallel [(const_int 1) (const_int 0)])))\n+   (set (match_dup 0)\n+        (vec_select:V2DI\n+          (match_dup 2)\n+          (parallel [(const_int 1) (const_int 0)])))]\n+  \"\n+{\n+  operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[1]) \n+                                       : operands[1];\n+}\n+  \"\n+  [(set_attr \"type\" \"vecstore\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn_and_split \"*vsx_le_perm_store_v4si\"\n+  [(set (match_operand:V4SI 0 \"memory_operand\" \"=Z\")\n+        (match_operand:V4SI 1 \"vsx_register_operand\" \"+wa\"))]\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  \"#\"\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  [(set (match_dup 2)\n+        (vec_select:V4SI\n+          (match_dup 1)\n+          (parallel [(const_int 2) (const_int 3)\n+\t             (const_int 0) (const_int 1)])))\n+   (set (match_dup 0)\n+        (vec_select:V4SI\n+          (match_dup 2)\n+          (parallel [(const_int 2) (const_int 3)\n+\t             (const_int 0) (const_int 1)])))]\n+  \"\n+{\n+  operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[1]) \n+                                       : operands[1];\n+}\n+  \"\n+  [(set_attr \"type\" \"vecstore\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn_and_split \"*vsx_le_perm_store_v8hi\"\n+  [(set (match_operand:V8HI 0 \"memory_operand\" \"=Z\")\n+        (match_operand:V8HI 1 \"vsx_register_operand\" \"+wa\"))]\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  \"#\"\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  [(set (match_dup 2)\n+        (vec_select:V8HI\n+          (match_dup 1)\n+          (parallel [(const_int 4) (const_int 5)\n+                     (const_int 6) (const_int 7)\n+                     (const_int 0) (const_int 1)\n+                     (const_int 2) (const_int 3)])))\n+   (set (match_dup 0)\n+        (vec_select:V8HI\n+          (match_dup 2)\n+          (parallel [(const_int 4) (const_int 5)\n+                     (const_int 6) (const_int 7)\n+                     (const_int 0) (const_int 1)\n+                     (const_int 2) (const_int 3)])))]\n+  \"\n+{\n+  operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[1]) \n+                                       : operands[1];\n+}\n+  \"\n+  [(set_attr \"type\" \"vecstore\")\n+   (set_attr \"length\" \"8\")])\n+\n+(define_insn_and_split \"*vsx_le_perm_store_v16qi\"\n+  [(set (match_operand:V16QI 0 \"memory_operand\" \"=Z\")\n+        (match_operand:V16QI 1 \"vsx_register_operand\" \"+wa\"))]\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  \"#\"\n+  \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n+  [(set (match_dup 2)\n+        (vec_select:V16QI\n+          (match_dup 1)\n+          (parallel [(const_int 8) (const_int 9)\n+                     (const_int 10) (const_int 11)\n+                     (const_int 12) (const_int 13)\n+                     (const_int 14) (const_int 15)\n+                     (const_int 0) (const_int 1)\n+                     (const_int 2) (const_int 3)\n+                     (const_int 4) (const_int 5)\n+                     (const_int 6) (const_int 7)])))\n+   (set (match_dup 0)\n+        (vec_select:V16QI\n+          (match_dup 2)\n+          (parallel [(const_int 8) (const_int 9)\n+                     (const_int 10) (const_int 11)\n+                     (const_int 12) (const_int 13)\n+                     (const_int 14) (const_int 15)\n+                     (const_int 0) (const_int 1)\n+                     (const_int 2) (const_int 3)\n+                     (const_int 4) (const_int 5)\n+                     (const_int 6) (const_int 7)])))]\n+  \"\n+{\n+  operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[1]) \n+                                       : operands[1];\n+}\n+  \"\n+  [(set_attr \"type\" \"vecstore\")\n+   (set_attr \"length\" \"8\")])\n+\n+\n (define_insn \"*vsx_mov<mode>\"\n   [(set (match_operand:VSX_M 0 \"nonimmediate_operand\" \"=Z,<VSr>,<VSr>,?Z,?wa,?wa,wQ,?&r,??Y,??r,??r,<VSr>,?wa,*r,v,wZ, v\")\n \t(match_operand:VSX_M 1 \"input_operand\" \"<VSr>,Z,<VSr>,wa,Z,wa,r,wQ,r,Y,r,j,j,j,W,v,wZ\"))]\n@@ -978,6 +1210,153 @@\n   \"xxpermdi %x0,%x1,%x2,0\"\n   [(set_attr \"type\" \"vecperm\")])\n \n+;; xxpermdi for little endian loads and stores.  We need several of\n+;; these since the form of the PARALLEL differs by mode.\n+(define_insn \"*vsx_xxpermdi2_le_<mode>\"\n+  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wa\")\n+        (vec_select:VSX_D\n+          (match_operand:VSX_D 1 \"vsx_register_operand\" \"wa\")\n+          (parallel [(const_int 1) (const_int 0)])))]\n+  \"!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"xxpermdi %x0,%x1,%x1,2\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"*vsx_xxpermdi4_le_<mode>\"\n+  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=wa\")\n+        (vec_select:VSX_W\n+          (match_operand:VSX_W 1 \"vsx_register_operand\" \"wa\")\n+          (parallel [(const_int 2) (const_int 3)\n+                     (const_int 0) (const_int 1)])))]\n+  \"!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"xxpermdi %x0,%x1,%x1,2\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"*vsx_xxpermdi8_le_V8HI\"\n+  [(set (match_operand:V8HI 0 \"vsx_register_operand\" \"=wa\")\n+        (vec_select:V8HI\n+          (match_operand:V8HI 1 \"vsx_register_operand\" \"wa\")\n+          (parallel [(const_int 4) (const_int 5)\n+                     (const_int 6) (const_int 7)\n+                     (const_int 0) (const_int 1)\n+                     (const_int 2) (const_int 3)])))]\n+  \"!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (V8HImode)\"\n+  \"xxpermdi %x0,%x1,%x1,2\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"*vsx_xxpermdi16_le_V16QI\"\n+  [(set (match_operand:V16QI 0 \"vsx_register_operand\" \"=wa\")\n+        (vec_select:V16QI\n+          (match_operand:V16QI 1 \"vsx_register_operand\" \"wa\")\n+          (parallel [(const_int 8) (const_int 9)\n+                     (const_int 10) (const_int 11)\n+                     (const_int 12) (const_int 13)\n+                     (const_int 14) (const_int 15)\n+                     (const_int 0) (const_int 1)\n+                     (const_int 2) (const_int 3)\n+                     (const_int 4) (const_int 5)\n+                     (const_int 6) (const_int 7)])))]\n+  \"!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (V16QImode)\"\n+  \"xxpermdi %x0,%x1,%x1,2\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+;; lxvd2x for little endian loads.  We need several of\n+;; these since the form of the PARALLEL differs by mode.\n+(define_insn \"*vsx_lxvd2x2_le_<mode>\"\n+  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wa\")\n+        (vec_select:VSX_D\n+          (match_operand:VSX_D 1 \"memory_operand\" \"Z\")\n+          (parallel [(const_int 1) (const_int 0)])))]\n+  \"!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"lxvd2x %x0,%y1\"\n+  [(set_attr \"type\" \"vecload\")])\n+\n+(define_insn \"*vsx_lxvd2x4_le_<mode>\"\n+  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=wa\")\n+        (vec_select:VSX_W\n+          (match_operand:VSX_W 1 \"memory_operand\" \"Z\")\n+          (parallel [(const_int 2) (const_int 3)\n+                     (const_int 0) (const_int 1)])))]\n+  \"!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"lxvd2x %x0,%y1\"\n+  [(set_attr \"type\" \"vecload\")])\n+\n+(define_insn \"*vsx_lxvd2x8_le_V8HI\"\n+  [(set (match_operand:V8HI 0 \"vsx_register_operand\" \"=wa\")\n+        (vec_select:V8HI\n+          (match_operand:V8HI 1 \"memory_operand\" \"Z\")\n+          (parallel [(const_int 4) (const_int 5)\n+                     (const_int 6) (const_int 7)\n+                     (const_int 0) (const_int 1)\n+                     (const_int 2) (const_int 3)])))]\n+  \"!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (V8HImode)\"\n+  \"lxvd2x %x0,%y1\"\n+  [(set_attr \"type\" \"vecload\")])\n+\n+(define_insn \"*vsx_lxvd2x16_le_V16QI\"\n+  [(set (match_operand:V16QI 0 \"vsx_register_operand\" \"=wa\")\n+        (vec_select:V16QI\n+          (match_operand:V16QI 1 \"memory_operand\" \"Z\")\n+          (parallel [(const_int 8) (const_int 9)\n+                     (const_int 10) (const_int 11)\n+                     (const_int 12) (const_int 13)\n+                     (const_int 14) (const_int 15)\n+                     (const_int 0) (const_int 1)\n+                     (const_int 2) (const_int 3)\n+                     (const_int 4) (const_int 5)\n+                     (const_int 6) (const_int 7)])))]\n+  \"!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (V16QImode)\"\n+  \"lxvd2x %x0,%y1\"\n+  [(set_attr \"type\" \"vecload\")])\n+\n+;; stxvd2x for little endian stores.  We need several of\n+;; these since the form of the PARALLEL differs by mode.\n+(define_insn \"*vsx_stxvd2x2_le_<mode>\"\n+  [(set (match_operand:VSX_D 0 \"memory_operand\" \"=Z\")\n+        (vec_select:VSX_D\n+          (match_operand:VSX_D 1 \"vsx_register_operand\" \"wa\")\n+          (parallel [(const_int 1) (const_int 0)])))]\n+  \"!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"stxvd2x %x1,%y0\"\n+  [(set_attr \"type\" \"vecstore\")])\n+\n+(define_insn \"*vsx_stxvd2x4_le_<mode>\"\n+  [(set (match_operand:VSX_W 0 \"memory_operand\" \"=Z\")\n+        (vec_select:VSX_W\n+          (match_operand:VSX_W 1 \"vsx_register_operand\" \"wa\")\n+          (parallel [(const_int 2) (const_int 3)\n+                     (const_int 0) (const_int 1)])))]\n+  \"!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"stxvd2x %x1,%y0\"\n+  [(set_attr \"type\" \"vecstore\")])\n+\n+(define_insn \"*vsx_stxvd2x8_le_V8HI\"\n+  [(set (match_operand:V8HI 0 \"memory_operand\" \"=Z\")\n+        (vec_select:V8HI\n+          (match_operand:V8HI 1 \"vsx_register_operand\" \"wa\")\n+          (parallel [(const_int 4) (const_int 5)\n+                     (const_int 6) (const_int 7)\n+                     (const_int 0) (const_int 1)\n+                     (const_int 2) (const_int 3)])))]\n+  \"!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (V8HImode)\"\n+  \"stxvd2x %x1,%y0\"\n+  [(set_attr \"type\" \"vecstore\")])\n+\n+(define_insn \"*vsx_stxvd2x16_le_V16QI\"\n+  [(set (match_operand:V16QI 0 \"memory_operand\" \"=Z\")\n+        (vec_select:V16QI\n+          (match_operand:V16QI 1 \"vsx_register_operand\" \"wa\")\n+          (parallel [(const_int 8) (const_int 9)\n+                     (const_int 10) (const_int 11)\n+                     (const_int 12) (const_int 13)\n+                     (const_int 14) (const_int 15)\n+                     (const_int 0) (const_int 1)\n+                     (const_int 2) (const_int 3)\n+                     (const_int 4) (const_int 5)\n+                     (const_int 6) (const_int 7)])))]\n+  \"!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (V16QImode)\"\n+  \"stxvd2x %x1,%y0\"\n+  [(set_attr \"type\" \"vecstore\")])\n+\n ;; Set the element of a V2DI/VD2F mode\n (define_insn \"vsx_set_<mode>\"\n   [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wd,?wa\")"}, {"sha": "60242b648f40cf8f572a84628a49b06f82f76838", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cf686948bf515dcfcc47314ab75fda468fe7357/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cf686948bf515dcfcc47314ab75fda468fe7357/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0cf686948bf515dcfcc47314ab75fda468fe7357", "patch": "@@ -1,3 +1,8 @@\n+2013-10-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/pr43154.c: Skip for ppc64 little endian.\n+\t* gcc.target/powerpc/fusion.c: Likewise.\n+\n 2013-10-07  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* gcc.target/s390/htm-nofloat-2.c: New testcase."}, {"sha": "60e635972c477a15d76bc66ec6d6291e5fefcc7d", "filename": "gcc/testsuite/gcc.target/powerpc/fusion.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cf686948bf515dcfcc47314ab75fda468fe7357/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cf686948bf515dcfcc47314ab75fda468fe7357/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion.c?ref=0cf686948bf515dcfcc47314ab75fda468fe7357", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do compile { target { powerpc*-*-* } } } */\n /* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*le-*-* } { \"*\" } { \"\" } } */\n /* { dg-require-effective-target powerpc_p8vector_ok } */\n /* { dg-options \"-mcpu=power7 -mtune=power8 -O3\" } */\n "}, {"sha": "eb1919743b5cb8b8b175b641a0f89bacf60a9908", "filename": "gcc/testsuite/gcc.target/powerpc/pr43154.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cf686948bf515dcfcc47314ab75fda468fe7357/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr43154.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cf686948bf515dcfcc47314ab75fda468fe7357/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr43154.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr43154.c?ref=0cf686948bf515dcfcc47314ab75fda468fe7357", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do compile { target { powerpc*-*-* } } } */\n /* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*le-*-* } { \"*\" } { \"\" } } */\n /* { dg-require-effective-target powerpc_vsx_ok } */\n /* { dg-options \"-O2 -mcpu=power7\" } */\n "}]}