{"sha": "5afe5d2d4485638a63fa23f456eb6942f2e5bd38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFmZTVkMmQ0NDg1NjM4YTYzZmEyM2Y0NTZlYjY5NDJmMmU1YmQzOA==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2013-04-24T13:15:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-24T13:15:27Z"}, "message": "exp_ch6.adb: Remove with and use clause for Sem_Prag.\n\n2013-04-24  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch6.adb: Remove with and use clause for Sem_Prag.\n\t(Freeze_Subprogram): Call Analyze_Subprogram_Contract to analyze\n\tthe contract of a subprogram.\n\t* sem_ch3.adb: Remove with and use clause for Sem_Prag.\n\t(Analyze_Declarations): Call Analyze_Subprogram_Contract to\n\tanalyze the contract of a subprogram.\n\t* sem_ch6.adb (Analyze_Subprogram_Contract): New routine.\n\t(Check_Subprogram_Contract): Removed.\n\t* sem_ch6.ads (Analyze_Subprogram_Contract): New routine.\n\t(Check_Subprogram_Contract): Removed.\n\t(Expand_Contract_Cases): Add a guard against malformed contract cases.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Call\n\tDecorate_Delayed_Aspect_And_Pragma to decorate aspects\n\tContract_Cases, Depends and Global. Reimplement the analysis of\n\taspect Contract_Cases.\n\t(Decorate_Delayed_Aspect_And_Pragma): New routine.\n\t* sem_prag.adb (Analyze_Contract_Cases_In_Decl_Part): New routine.\n\t(Analyze_CTC_In_Decl_Part): Removed.\n\t(Analyze_Pragma): Reimplement the analysis of pragma Contract_Cases.\n\t(Analyze_Test_Case_In_Decl_Part): New routine.\n\t(Find_Related_Subprogram): New routine.\n\t(Requires_Profile_Installation): Add new formal Prag. Update\n\tthe logic to take into account the origin of the pragma.\n\t* sem_prag.ads (Analyze_Contract_Cases_In_Decl_Part): New routine.\n\t(Analyze_CTC_In_Decl_Part): Removed.\n\t(Analyze_Test_Case_In_Decl_Part): New routine.\n\nFrom-SVN: r198227", "tree": {"sha": "ca637ecaa92b39893b465fad03a54cfe9788db99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca637ecaa92b39893b465fad03a54cfe9788db99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5afe5d2d4485638a63fa23f456eb6942f2e5bd38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5afe5d2d4485638a63fa23f456eb6942f2e5bd38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5afe5d2d4485638a63fa23f456eb6942f2e5bd38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5afe5d2d4485638a63fa23f456eb6942f2e5bd38/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f1c80977503ef50a812c3545c9b902fd65c086eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1c80977503ef50a812c3545c9b902fd65c086eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1c80977503ef50a812c3545c9b902fd65c086eb"}], "stats": {"total": 1368, "additions": 610, "deletions": 758}, "files": [{"sha": "93955a03843cb66f11f7ed651a25c80a81e7c423", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5afe5d2d4485638a63fa23f456eb6942f2e5bd38/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5afe5d2d4485638a63fa23f456eb6942f2e5bd38/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5afe5d2d4485638a63fa23f456eb6942f2e5bd38", "patch": "@@ -1,3 +1,32 @@\n+2013-04-24  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch6.adb: Remove with and use clause for Sem_Prag.\n+\t(Freeze_Subprogram): Call Analyze_Subprogram_Contract to analyze\n+\tthe contract of a subprogram.\n+\t* sem_ch3.adb: Remove with and use clause for Sem_Prag.\n+\t(Analyze_Declarations): Call Analyze_Subprogram_Contract to\n+\tanalyze the contract of a subprogram.\n+\t* sem_ch6.adb (Analyze_Subprogram_Contract): New routine.\n+\t(Check_Subprogram_Contract): Removed.\n+\t* sem_ch6.ads (Analyze_Subprogram_Contract): New routine.\n+\t(Check_Subprogram_Contract): Removed.\n+\t(Expand_Contract_Cases): Add a guard against malformed contract cases.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Call\n+\tDecorate_Delayed_Aspect_And_Pragma to decorate aspects\n+\tContract_Cases, Depends and Global. Reimplement the analysis of\n+\taspect Contract_Cases.\n+\t(Decorate_Delayed_Aspect_And_Pragma): New routine.\n+\t* sem_prag.adb (Analyze_Contract_Cases_In_Decl_Part): New routine.\n+\t(Analyze_CTC_In_Decl_Part): Removed.\n+\t(Analyze_Pragma): Reimplement the analysis of pragma Contract_Cases.\n+\t(Analyze_Test_Case_In_Decl_Part): New routine.\n+\t(Find_Related_Subprogram): New routine.\n+\t(Requires_Profile_Installation): Add new formal Prag. Update\n+\tthe logic to take into account the origin of the pragma.\n+\t* sem_prag.ads (Analyze_Contract_Cases_In_Decl_Part): New routine.\n+\t(Analyze_CTC_In_Decl_Part): Removed.\n+\t(Analyze_Test_Case_In_Decl_Part): New routine.\n+\n 2013-04-24  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_prag.adb (Process_Convention): Move Stdcall tests to"}, {"sha": "bd6bb705bc82063821725106fb974dc797f2d75c", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5afe5d2d4485638a63fa23f456eb6942f2e5bd38/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5afe5d2d4485638a63fa23f456eb6942f2e5bd38/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=5afe5d2d4485638a63fa23f456eb6942f2e5bd38", "patch": "@@ -67,7 +67,6 @@ with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n with Sem_Eval; use Sem_Eval;\n with Sem_Mech; use Sem_Mech;\n-with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n with Sem_SCIL; use Sem_SCIL;\n with Sem_Util; use Sem_Util;\n@@ -8304,31 +8303,7 @@ package body Exp_Ch6 is\n       if Nkind (Parent (Subp)) = N_Procedure_Specification\n         and then Null_Present (Parent (Subp))\n       then\n-         declare\n-            Prag : Node_Id;\n-\n-         begin\n-            --  Analyze all pre- and post-conditions\n-\n-            Prag := Pre_Post_Conditions (Contract (Subp));\n-            while Present (Prag) loop\n-               Analyze_PPC_In_Decl_Part (Prag, Subp);\n-               Prag := Next_Pragma (Prag);\n-            end loop;\n-\n-            --  Analyze classification aspects Depends and Global\n-\n-            Prag := Classifications (Contract (Subp));\n-            while Present (Prag) loop\n-               if Pragma_Name (Prag) = Name_Depends then\n-                  Analyze_Depends_In_Decl_Part (Prag);\n-               else\n-                  Analyze_Global_In_Decl_Part (Prag);\n-               end if;\n-\n-               Prag := Next_Pragma (Prag);\n-            end loop;\n-         end;\n+         Analyze_Subprogram_Contract (Subp);\n       end if;\n    end Freeze_Subprogram;\n "}, {"sha": "30aa61eaf9cbfe5b288e91beb2a9abad9e36299c", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 32, "deletions": 91, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5afe5d2d4485638a63fa23f456eb6942f2e5bd38/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5afe5d2d4485638a63fa23f456eb6942f2e5bd38/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=5afe5d2d4485638a63fa23f456eb6942f2e5bd38", "patch": "@@ -925,11 +925,33 @@ package body Sem_Ch13 is\n    -----------------------------------\n \n    procedure Analyze_Aspect_Specifications (N : Node_Id; E : Entity_Id) is\n+      procedure Decorate_Delayed_Aspect_And_Pragma\n+        (Asp  : Node_Id;\n+         Prag : Node_Id);\n+      --  Establish the linkages between a delayed aspect and its corresponding\n+      --  pragma. Set all delay-related flags on both constructs.\n+\n       procedure Insert_Delayed_Pragma (Prag : Node_Id);\n       --  Insert a postcondition-like pragma into the tree depending on the\n-      --  context. Prag one of the following: Pre, Post, Depends or Global.\n+      --  context. Prag must denote one of the following: Pre, Post, Depends,\n+      --  Global or Contract_Cases.\n+\n+      ----------------------------------------\n+      -- Decorate_Delayed_Aspect_And_Pragma --\n+      ----------------------------------------\n \n-      --  Why not also Contract_Cases ???\n+      procedure Decorate_Delayed_Aspect_And_Pragma\n+        (Asp  : Node_Id;\n+         Prag : Node_Id)\n+      is\n+      begin\n+         Set_Aspect_Rep_Item           (Asp, Prag);\n+         Set_Corresponding_Aspect      (Prag, Asp);\n+         Set_From_Aspect_Specification (Prag);\n+         Set_Is_Delayed_Aspect         (Prag);\n+         Set_Is_Delayed_Aspect         (Asp);\n+         Set_Parent                    (Prag, Asp);\n+      end Decorate_Delayed_Aspect_And_Pragma;\n \n       ---------------------------\n       -- Insert_Delayed_Pragma --\n@@ -1605,15 +1627,7 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Depends);\n \n-                  --  Decorate the aspect and pragma\n-\n-                  Set_Aspect_Rep_Item           (Aspect, Aitem);\n-                  Set_Corresponding_Aspect      (Aitem, Aspect);\n-                  Set_From_Aspect_Specification (Aitem);\n-                  Set_Is_Delayed_Aspect         (Aitem);\n-                  Set_Is_Delayed_Aspect         (Aspect);\n-                  Set_Parent                    (Aitem, Aspect);\n-\n+                  Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n                   Insert_Delayed_Pragma (Aitem);\n                   goto Continue;\n \n@@ -1631,15 +1645,7 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Global);\n \n-                  --  Decorate the aspect and pragma\n-\n-                  Set_Aspect_Rep_Item           (Aspect, Aitem);\n-                  Set_Corresponding_Aspect      (Aitem, Aspect);\n-                  Set_From_Aspect_Specification (Aitem);\n-                  Set_Is_Delayed_Aspect         (Aitem);\n-                  Set_Is_Delayed_Aspect         (Aspect);\n-                  Set_Parent                    (Aitem, Aspect);\n-\n+                  Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n                   Insert_Delayed_Pragma (Aitem);\n                   goto Continue;\n \n@@ -1739,7 +1745,7 @@ package body Sem_Ch13 is\n                --  required pragma placement. The processing for the pragmas\n                --  takes care of the required delay.\n \n-               when Pre_Post_Aspects => declare\n+               when Pre_Post_Aspects => Pre_Post : declare\n                   Pname : Name_Id;\n \n                begin\n@@ -1816,7 +1822,7 @@ package body Sem_Ch13 is\n \n                   Insert_Delayed_Pragma (Aitem);\n                   goto Continue;\n-               end;\n+               end Pre_Post;\n \n                --  Test_Case\n \n@@ -1889,79 +1895,16 @@ package body Sem_Ch13 is\n \n                --  Contract_Cases\n \n-               when Aspect_Contract_Cases => Contract_Cases : declare\n-                  Case_Guard  : Node_Id;\n-                  Extra       : Node_Id;\n-                  Others_Seen : Boolean := False;\n-                  Post_Case   : Node_Id;\n-\n-               begin\n-                  if Nkind (Parent (N)) = N_Compilation_Unit then\n-                     Error_Msg_Name_1 := Nam;\n-                     Error_Msg_N (\"incorrect placement of aspect `%`\", E);\n-                     goto Continue;\n-                  end if;\n-\n-                  if Nkind (Expr) /= N_Aggregate then\n-                     Error_Msg_Name_1 := Nam;\n-                     Error_Msg_NE\n-                       (\"wrong syntax for aspect `%` for &\", Id, E);\n-                     goto Continue;\n-                  end if;\n-\n-                  --  Verify the legality of individual post cases\n-\n-                  Post_Case := First (Component_Associations (Expr));\n-                  while Present (Post_Case) loop\n-                     if Nkind (Post_Case) /= N_Component_Association then\n-                        Error_Msg_N (\"wrong syntax in post case\", Post_Case);\n-                        goto Continue;\n-                     end if;\n-\n-                     --  Each post case must have exactly one case guard\n-\n-                     Case_Guard := First (Choices (Post_Case));\n-                     Extra      := Next (Case_Guard);\n-\n-                     if Present (Extra) then\n-                        Error_Msg_N\n-                          (\"post case may have only one case guard\", Extra);\n-                        goto Continue;\n-                     end if;\n-\n-                     --  Check the placement of \"others\" (if available)\n-\n-                     if Nkind (Case_Guard) = N_Others_Choice then\n-                        if Others_Seen then\n-                           Error_Msg_Name_1 := Nam;\n-                           Error_Msg_N\n-                             (\"only one others choice allowed in aspect %\",\n-                              Case_Guard);\n-                           goto Continue;\n-                        else\n-                           Others_Seen := True;\n-                        end if;\n-\n-                     elsif Others_Seen then\n-                        Error_Msg_Name_1 := Nam;\n-                        Error_Msg_N\n-                          (\"others must be the last choice in aspect %\", N);\n-                        goto Continue;\n-                     end if;\n-\n-                     Next (Post_Case);\n-                  end loop;\n-\n-                  --  Transform the aspect into a pragma\n-\n+               when Aspect_Contract_Cases =>\n                   Make_Aitem_Pragma\n                     (Pragma_Argument_Associations => New_List (\n                        Make_Pragma_Argument_Association (Loc,\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Nam);\n \n-                  Delay_Required := False;\n-               end Contract_Cases;\n+                  Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n+                  Insert_Delayed_Pragma (Aitem);\n+                  goto Continue;\n \n                --  Case 5: Special handling for aspects with an optional\n                --  boolean argument.\n@@ -1970,8 +1913,6 @@ package body Sem_Ch13 is\n                --  generated yet because the evaluation of the boolean needs\n                --  to be delayed till the freeze point.\n \n-               --  Boolwn_Aspects\n-\n                when Boolean_Aspects      |\n                     Library_Unit_Aspects =>\n "}, {"sha": "ac53a767b0e3fe8dbc95d97e74173290ecab7045", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 12, "deletions": 47, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5afe5d2d4485638a63fa23f456eb6942f2e5bd38/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5afe5d2d4485638a63fa23f456eb6942f2e5bd38/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=5afe5d2d4485638a63fa23f456eb6942f2e5bd38", "patch": "@@ -64,7 +64,6 @@ with Sem_Dist; use Sem_Dist;\n with Sem_Elim; use Sem_Elim;\n with Sem_Eval; use Sem_Eval;\n with Sem_Mech; use Sem_Mech;\n-with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n with Sem_Smem; use Sem_Smem;\n with Sem_Type; use Sem_Type;\n@@ -2181,59 +2180,25 @@ package body Sem_Ch3 is\n          D := Next_Node;\n       end loop;\n \n-      --  One more thing to do, we need to scan the declarations to check\n-      --  for any precondition/postcondition pragmas (Pre/Post aspects have\n-      --  by this stage been converted into corresponding pragmas). It is\n-      --  at this point that we analyze the expressions in such pragmas,\n-      --  to implement the delayed visibility requirement.\n+      --  One more thing to do, we need to scan the declarations to check for\n+      --  any precondition/postcondition pragmas (Pre/Post aspects have by this\n+      --  stage been converted into corresponding pragmas). It is at this point\n+      --  that we analyze the expressions in such pragmas, to implement the\n+      --  delayed visibility requirement.\n \n       declare\n-         Decl : Node_Id;\n-         Spec : Node_Id;\n-         Sent : Entity_Id;\n-         Prag : Node_Id;\n+         Decl      : Node_Id;\n+         Subp_Decl : Node_Id;\n+         Subp_Id   : Entity_Id;\n \n       begin\n          Decl := First (L);\n          while Present (Decl) loop\n-            if Nkind (Original_Node (Decl)) = N_Subprogram_Declaration then\n-               Spec := Specification (Original_Node (Decl));\n-               Sent := Defining_Unit_Name (Spec);\n+            Subp_Decl := Original_Node (Decl);\n \n-               --  Analyze preconditions and postconditions\n-\n-               Prag := Pre_Post_Conditions (Contract (Sent));\n-               while Present (Prag) loop\n-                  Analyze_PPC_In_Decl_Part (Prag, Sent);\n-                  Prag := Next_Pragma (Prag);\n-               end loop;\n-\n-               --  Analyze contract-cases and test-cases\n-\n-               Prag := Contract_Test_Cases (Contract (Sent));\n-               while Present (Prag) loop\n-                  Analyze_CTC_In_Decl_Part (Prag, Sent);\n-                  Prag := Next_Pragma (Prag);\n-               end loop;\n-\n-               --  Analyze classification pragmas\n-\n-               Prag := Classifications (Contract (Sent));\n-               while Present (Prag) loop\n-                  if Pragma_Name (Prag) = Name_Depends then\n-                     Analyze_Depends_In_Decl_Part (Prag);\n-                  else\n-                     pragma Assert (Pragma_Name (Prag) = Name_Global);\n-                     Analyze_Global_In_Decl_Part (Prag);\n-                  end if;\n-\n-                  Prag := Next_Pragma (Prag);\n-               end loop;\n-\n-               --  At this point, entities have been attached to identifiers.\n-               --  This is required to be able to detect suspicious contracts.\n-\n-               Check_Subprogram_Contract (Sent);\n+            if Nkind (Subp_Decl) = N_Subprogram_Declaration then\n+               Subp_Id := Defining_Unit_Name (Specification (Subp_Decl));\n+               Analyze_Subprogram_Contract (Subp_Id);\n             end if;\n \n             Next (Decl);"}, {"sha": "385076b5693bc368152fd32dc60088fc489fc561", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 283, "deletions": 340, "changes": 623, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5afe5d2d4485638a63fa23f456eb6942f2e5bd38/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5afe5d2d4485638a63fa23f456eb6942f2e5bd38/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=5afe5d2d4485638a63fa23f456eb6942f2e5bd38", "patch": "@@ -3320,6 +3320,281 @@ package body Sem_Ch6 is\n       end;\n    end Analyze_Subprogram_Body_Helper;\n \n+   ---------------------------------\n+   -- Analyze_Subprogram_Contract --\n+   ---------------------------------\n+\n+   procedure Analyze_Subprogram_Contract (Subp : Entity_Id) is\n+      Result_Seen : Boolean := False;\n+      --  A flag which keeps track of whether at least one postcondition or\n+      --  contract-case mentions attribute 'Result (set True if so).\n+\n+      procedure Check_Result_And_Post_State\n+        (Prag      : Node_Id;\n+         Error_Nod : in out Node_Id);\n+      --  Determine whether pragma Prag mentions attribute 'Result and whether\n+      --  the pragma contains an expression that evaluates differently in pre-\n+      --  and post-state. Prag is a postcondition or a contract-cases pragma.\n+      --  Error_Nod denotes the proper error node.\n+\n+      ---------------------------------\n+      -- Check_Result_And_Post_State --\n+      ---------------------------------\n+\n+      procedure Check_Result_And_Post_State\n+        (Prag      : Node_Id;\n+         Error_Nod : in out Node_Id)\n+      is\n+         procedure Check_Expression (Expr : Node_Id);\n+         --  Perform the 'Result and post-state checks on a given expression\n+\n+         function Is_Function_Result (N : Node_Id) return Traverse_Result;\n+         --  Attempt to find attribute 'Result in a subtree denoted by N\n+\n+         function Is_Trivial_Boolean (N : Node_Id) return Boolean;\n+         --  Determine whether source node N denotes \"True\" or \"False\"\n+\n+         function Mentions_Post_State (N : Node_Id) return Boolean;\n+         --  Determine whether a subtree denoted by N mentions any construct\n+         --  that denotes a post-state.\n+\n+         procedure Check_Function_Result is\n+           new Traverse_Proc (Is_Function_Result);\n+\n+         ----------------------\n+         -- Check_Expression --\n+         ----------------------\n+\n+         procedure Check_Expression (Expr : Node_Id) is\n+         begin\n+            if not Is_Trivial_Boolean (Expr) then\n+               Check_Function_Result (Expr);\n+\n+               if not Mentions_Post_State (Expr) then\n+                  if Pragma_Name (Prag) = Name_Contract_Cases then\n+                     Error_Msg_N\n+                       (\"contract case refers only to pre-state?T?\", Expr);\n+                  else\n+                     Error_Msg_N\n+                       (\"postcondition refers only to pre-state?T?\", Prag);\n+                  end if;\n+               end if;\n+            end if;\n+         end Check_Expression;\n+\n+         ------------------------\n+         -- Is_Function_Result --\n+         ------------------------\n+\n+         function Is_Function_Result (N : Node_Id) return Traverse_Result is\n+         begin\n+            if Nkind (N) = N_Attribute_Reference\n+              and then Attribute_Name (N) = Name_Result\n+            then\n+               Result_Seen := True;\n+               return Abandon;\n+\n+            --  Continue the traversal\n+\n+            else\n+               return OK;\n+            end if;\n+         end Is_Function_Result;\n+\n+         ------------------------\n+         -- Is_Trivial_Boolean --\n+         ------------------------\n+\n+         function Is_Trivial_Boolean (N : Node_Id) return Boolean is\n+         begin\n+            return\n+              Comes_From_Source (N)\n+                and then Is_Entity_Name (N)\n+                and then (Entity (N) = Standard_True\n+                            or else Entity (N) = Standard_False);\n+         end Is_Trivial_Boolean;\n+\n+         -------------------------\n+         -- Mentions_Post_State --\n+         -------------------------\n+\n+         function Mentions_Post_State (N : Node_Id) return Boolean is\n+            Post_State_Seen : Boolean := False;\n+\n+            function Is_Post_State (N : Node_Id) return Traverse_Result;\n+            --  Attempt to find a construct that denotes a post-state. If this\n+            --  is the case, set flag Post_State_Seen.\n+\n+            -------------------\n+            -- Is_Post_State --\n+            -------------------\n+\n+            function Is_Post_State (N : Node_Id) return Traverse_Result is\n+               Ent : Entity_Id;\n+\n+            begin\n+               if Nkind_In (N, N_Explicit_Dereference, N_Function_Call) then\n+                  Post_State_Seen := True;\n+                  return Abandon;\n+\n+               elsif Nkind_In (N, N_Expanded_Name, N_Identifier) then\n+                  Ent := Entity (N);\n+\n+                  if No (Ent) or else Ekind (Ent) in Assignable_Kind then\n+                     Post_State_Seen := True;\n+                     return Abandon;\n+                  end if;\n+\n+               elsif Nkind (N) = N_Attribute_Reference then\n+                  if Attribute_Name (N) = Name_Old then\n+                     return Skip;\n+                  elsif Attribute_Name (N) = Name_Result then\n+                     Post_State_Seen := True;\n+                     return Abandon;\n+                  end if;\n+               end if;\n+\n+               return OK;\n+            end Is_Post_State;\n+\n+            procedure Find_Post_State is new Traverse_Proc (Is_Post_State);\n+\n+         --  Start of processing for Mentions_Post_State\n+\n+         begin\n+            Find_Post_State (N);\n+            return Post_State_Seen;\n+         end Mentions_Post_State;\n+\n+         --  Local variables\n+\n+         Expr  : constant Node_Id :=\n+                   Expression (First (Pragma_Argument_Associations (Prag)));\n+         Nam   : constant Name_Id := Pragma_Name (Prag);\n+         CCase : Node_Id;\n+\n+      --  Start of processing for Check_Result_And_Post_State\n+\n+      begin\n+         if No (Error_Nod) then\n+            Error_Nod := Prag;\n+         end if;\n+\n+         --  Examine all consequences\n+\n+         if Nam = Name_Contract_Cases then\n+            CCase := First (Component_Associations (Expr));\n+            while Present (CCase) loop\n+               Check_Expression (Expression (CCase));\n+\n+               Next (CCase);\n+            end loop;\n+\n+         --  Examine the expression of a postcondition\n+\n+         else\n+            pragma Assert (Nam = Name_Postcondition);\n+            Check_Expression (Expr);\n+         end if;\n+      end Check_Result_And_Post_State;\n+\n+      --  Local variables\n+\n+      Items       : constant Node_Id := Contract (Subp);\n+      Error_CCase : Node_Id;\n+      Error_Post  : Node_Id;\n+      Prag        : Node_Id;\n+\n+   --  Start of processing for Analyze_Subprogram_Contract\n+\n+   begin\n+      Error_CCase := Empty;\n+      Error_Post  := Empty;\n+\n+      if Present (Items) then\n+\n+         --  Analyze pre- and postconditions\n+\n+         Prag := Pre_Post_Conditions (Items);\n+         while Present (Prag) loop\n+            Analyze_PPC_In_Decl_Part (Prag, Subp);\n+\n+            --  Verify whether a postcondition mentions attribute 'Result and\n+            --  its expression introduces a post-state.\n+\n+            if Warn_On_Suspicious_Contract\n+              and then Pragma_Name (Prag) = Name_Postcondition\n+            then\n+               Check_Result_And_Post_State (Prag, Error_Post);\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+\n+         --  Analyze contract-cases and test-cases\n+\n+         Prag := Contract_Test_Cases (Items);\n+         while Present (Prag) loop\n+            if Pragma_Name (Prag) = Name_Contract_Cases then\n+               Analyze_Contract_Cases_In_Decl_Part (Prag);\n+\n+               --  Verify whether contract-cases mention attribute 'Result and\n+               --  its expression introduces a post-state. Perform the check\n+               --  only when the pragma is legal.\n+\n+               if Warn_On_Suspicious_Contract\n+                 and then not Error_Posted (Prag)\n+               then\n+                  Check_Result_And_Post_State (Prag, Error_CCase);\n+               end if;\n+\n+            else\n+               pragma Assert (Pragma_Name (Prag) = Name_Test_Case);\n+               Analyze_Test_Case_In_Decl_Part (Prag, Subp);\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+\n+         --  Analyze classification pragmas\n+\n+         Prag := Classifications (Contract (Subp));\n+         while Present (Prag) loop\n+            if Pragma_Name (Prag) = Name_Depends then\n+               Analyze_Depends_In_Decl_Part (Prag);\n+            else\n+               pragma Assert (Pragma_Name (Prag) = Name_Global);\n+               Analyze_Global_In_Decl_Part (Prag);\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+      end if;\n+\n+      --  Emit an error when none of the postconditions or contract-cases\n+      --  mention attribute 'Result in the context of a function.\n+\n+      if Warn_On_Suspicious_Contract\n+        and then Ekind_In (Subp, E_Function, E_Generic_Function)\n+        and then not Result_Seen\n+      then\n+         if Present (Error_Post) and then Present (Error_CCase) then\n+            Error_Msg_N\n+              (\"neither function postcondition nor contract cases mention \"\n+               & \"result?T?\", Error_Post);\n+\n+         elsif Present (Error_Post) then\n+            Error_Msg_N\n+              (\"function postcondition does not mention result?T?\",\n+               Error_Post);\n+\n+         elsif Present (Error_CCase) then\n+            Error_Msg_N\n+              (\"contract cases do not mention result?T?\", Error_CCase);\n+         end if;\n+      end if;\n+   end Analyze_Subprogram_Contract;\n+\n    ------------------------------------\n    -- Analyze_Subprogram_Declaration --\n    ------------------------------------\n@@ -7035,344 +7310,6 @@ package body Sem_Ch6 is\n       end if;\n    end Check_Returns;\n \n-   -------------------------------\n-   -- Check_Subprogram_Contract --\n-   -------------------------------\n-\n-   procedure Check_Subprogram_Contract (Spec_Id : Entity_Id) is\n-\n-      --  Code is currently commented out as, in some cases, it causes crashes\n-      --  because Direct_Primitive_Operations is not available for a private\n-      --  type. This may cause more warnings to be issued than necessary. See\n-      --  below for the intended use of this variable. ???\n-\n---        Inherited : constant Subprogram_List :=\n---                      Inherited_Subprograms (Spec_Id);\n---        --  List of subprograms inherited by this subprogram\n-\n-      --  We ignore postconditions \"True\" or \"False\" and contract-cases which\n-      --  have similar consequence expressions, which we call \"trivial\", when\n-      --  issuing warnings, since these postconditions and contract-cases\n-      --  purposedly ignore the post-state.\n-\n-      Last_Postcondition : Node_Id := Empty;\n-      --  Last non-trivial postcondition on the subprogram, or else Empty if\n-      --  either no non-trivial postcondition or only inherited postconditions.\n-\n-      Last_Contract_Cases : Node_Id := Empty;\n-      --  Last non-trivial contract-cases on the subprogram, or else Empty\n-\n-      Attribute_Result_Mentioned : Boolean := False;\n-      --  True if 'Result used in a non-trivial postcondition or contract-cases\n-\n-      No_Warning_On_Some_Postcondition : Boolean := False;\n-      --  True if there is a non-trivial postcondition or contract-cases\n-      --  without a corresponding warning.\n-\n-      Post_State_Mentioned : Boolean := False;\n-      --  True if expression mentioned in a postcondition or contract-cases\n-      --  can have a different value in the post-state than in the pre-state.\n-\n-      function Check_Attr_Result (N : Node_Id) return Traverse_Result;\n-      --  Check if N is a reference to the attribute 'Result, and if so set\n-      --  Attribute_Result_Mentioned and return Abandon. Otherwise return OK.\n-\n-      function Check_Post_State (N : Node_Id) return Traverse_Result;\n-      --  Check whether the value of evaluating N can be different in the\n-      --  post-state, compared to the same evaluation in the pre-state, and\n-      --  if so set Post_State_Mentioned and return Abandon. Return Skip on\n-      --  reference to attribute 'Old, in order to ignore its prefix, which\n-      --  is precisely evaluated in the pre-state. Otherwise return OK.\n-\n-      function Is_Trivial_Post_Or_Ensures (N : Node_Id) return Boolean;\n-      --  Return True if node N is trivially \"True\" or \"False\", and it comes\n-      --  from source. In particular, nodes that are statically known \"True\" or\n-      --  \"False\" by the compiler but not written as such in source code are\n-      --  not considered as trivial.\n-\n-      procedure Process_Contract_Cases (Spec : Node_Id);\n-      --  This processes the Contract_Test_Cases from Spec, processing any\n-      --  contract case from the list. The caller has checked that list\n-      --  Contract_Test_Cases is non-Empty.\n-\n-      procedure Process_Post_Conditions (Spec : Node_Id; Class : Boolean);\n-      --  This processes the Pre_Post_Conditions from Spec, processing any\n-      --  postcondition from the list. If Class is True, then only\n-      --  postconditions marked with Class_Present are considered. The\n-      --  caller has checked that Pre_Post_Conditions is non-Empty.\n-\n-      function Find_Attribute_Result is new Traverse_Func (Check_Attr_Result);\n-\n-      function Find_Post_State is new Traverse_Func (Check_Post_State);\n-\n-      -----------------------\n-      -- Check_Attr_Result --\n-      -----------------------\n-\n-      function Check_Attr_Result (N : Node_Id) return Traverse_Result is\n-      begin\n-         if Nkind (N) = N_Attribute_Reference\n-           and then Get_Attribute_Id (Attribute_Name (N)) = Attribute_Result\n-         then\n-            Attribute_Result_Mentioned := True;\n-            return Abandon;\n-         else\n-            return OK;\n-         end if;\n-      end Check_Attr_Result;\n-\n-      ----------------------\n-      -- Check_Post_State --\n-      ----------------------\n-\n-      function Check_Post_State (N : Node_Id) return Traverse_Result is\n-         Found : Boolean := False;\n-\n-      begin\n-         case Nkind (N) is\n-            when N_Function_Call        |\n-                 N_Explicit_Dereference =>\n-               Found := True;\n-\n-            when N_Identifier    |\n-                 N_Expanded_Name =>\n-\n-               declare\n-                  E : constant Entity_Id := Entity (N);\n-\n-               begin\n-                  --  ???Quantified expressions get analyzed later, so E can\n-                  --  be empty at this point. In this case, we suppress the\n-                  --  warning, just in case E is assignable. It seems better to\n-                  --  have false negatives than false positives. At some point,\n-                  --  we should make the warning more accurate, either by\n-                  --  analyzing quantified expressions earlier, or moving\n-                  --  this processing later.\n-\n-                  if No (E)\n-                    or else\n-                      (Is_Entity_Name (N)\n-                        and then Ekind (E) in Assignable_Kind)\n-                  then\n-                     Found := True;\n-                  end if;\n-               end;\n-\n-            when N_Attribute_Reference =>\n-               case Get_Attribute_Id (Attribute_Name (N)) is\n-                  when Attribute_Old =>\n-                     return Skip;\n-                  when Attribute_Result =>\n-                     Found := True;\n-                  when others =>\n-                     null;\n-               end case;\n-\n-            when others =>\n-               null;\n-         end case;\n-\n-         if Found then\n-            Post_State_Mentioned := True;\n-            return Abandon;\n-         else\n-            return OK;\n-         end if;\n-      end Check_Post_State;\n-\n-      --------------------------------\n-      -- Is_Trivial_Post_Or_Ensures --\n-      --------------------------------\n-\n-      function Is_Trivial_Post_Or_Ensures (N : Node_Id) return Boolean is\n-      begin\n-         return Is_Entity_Name (N)\n-           and then (Entity (N) = Standard_True\n-                       or else\n-                     Entity (N) = Standard_False)\n-           and then Comes_From_Source (N);\n-      end Is_Trivial_Post_Or_Ensures;\n-\n-      ----------------------------\n-      -- Process_Contract_Cases --\n-      ----------------------------\n-\n-      procedure Process_Contract_Cases (Spec : Node_Id) is\n-         Prag       : Node_Id;\n-         Aggr       : Node_Id;\n-         Conseq     : Node_Id;\n-         Post_Case  : Node_Id;\n-\n-         Ignored : Traverse_Final_Result;\n-         pragma Unreferenced (Ignored);\n-\n-      begin\n-         Prag := Contract_Test_Cases (Contract (Spec));\n-         loop\n-            if Pragma_Name (Prag) = Name_Contract_Cases then\n-               Aggr :=\n-                 Expression (First (Pragma_Argument_Associations (Prag)));\n-\n-               Post_Case := First (Component_Associations (Aggr));\n-               while Present (Post_Case) loop\n-                  Conseq := Expression (Post_Case);\n-\n-                  --  Ignore trivial contract-cases when consequence is \"True\"\n-                  --  or \"False\".\n-\n-                  if not Is_Trivial_Post_Or_Ensures (Conseq) then\n-                     Last_Contract_Cases := Prag;\n-\n-                     --  For functions, look for presence of 'Result in\n-                     --  consequence expression.\n-\n-                     if Ekind_In (Spec_Id, E_Function, E_Generic_Function) then\n-                        Ignored := Find_Attribute_Result (Conseq);\n-                     end if;\n-\n-                     --  For each individual case, look for presence of an\n-                     --  expression that could be evaluated differently in\n-                     --  post-state.\n-\n-                     Post_State_Mentioned := False;\n-                     Ignored := Find_Post_State (Conseq);\n-\n-                     if Post_State_Mentioned then\n-                        No_Warning_On_Some_Postcondition := True;\n-                     else\n-                        Error_Msg_N\n-                          (\"contract case refers only to pre-state?T?\",\n-                           Conseq);\n-                     end if;\n-                  end if;\n-\n-                  Next (Post_Case);\n-               end loop;\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-            exit when No (Prag);\n-         end loop;\n-      end Process_Contract_Cases;\n-\n-      -----------------------------\n-      -- Process_Post_Conditions --\n-      -----------------------------\n-\n-      procedure Process_Post_Conditions\n-        (Spec  : Node_Id;\n-         Class : Boolean)\n-      is\n-         Prag    : Node_Id;\n-         Arg     : Node_Id;\n-         Ignored : Traverse_Final_Result;\n-         pragma Unreferenced (Ignored);\n-\n-      begin\n-         Prag := Pre_Post_Conditions (Contract (Spec));\n-         loop\n-            Arg := First (Pragma_Argument_Associations (Prag));\n-\n-            --  Ignore trivial postcondition of \"True\" or \"False\"\n-\n-            if Pragma_Name (Prag) = Name_Postcondition\n-              and then not Is_Trivial_Post_Or_Ensures (Expression (Arg))\n-            then\n-               --  Since pre- and post-conditions are listed in reverse order,\n-               --  the first postcondition in the list is last in the source.\n-\n-               if not Class and then No (Last_Postcondition) then\n-                  Last_Postcondition := Prag;\n-               end if;\n-\n-               --  For functions, look for presence of 'Result in postcondition\n-\n-               if Ekind_In (Spec_Id, E_Function, E_Generic_Function) then\n-                  Ignored := Find_Attribute_Result (Arg);\n-               end if;\n-\n-               --  For each individual non-inherited postcondition, look\n-               --  for presence of an expression that could be evaluated\n-               --  differently in post-state.\n-\n-               if not Class then\n-                  Post_State_Mentioned := False;\n-                  Ignored := Find_Post_State (Arg);\n-\n-                  if Post_State_Mentioned then\n-                     No_Warning_On_Some_Postcondition := True;\n-                  else\n-                     Error_Msg_N\n-                       (\"postcondition refers only to pre-state?T?\", Prag);\n-                  end if;\n-               end if;\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-            exit when No (Prag);\n-         end loop;\n-      end Process_Post_Conditions;\n-\n-   --  Start of processing for Check_Subprogram_Contract\n-\n-   begin\n-      if not Warn_On_Suspicious_Contract then\n-         return;\n-      end if;\n-\n-      --  Process spec postconditions\n-\n-      if Present (Pre_Post_Conditions (Contract (Spec_Id))) then\n-         Process_Post_Conditions (Spec_Id, Class => False);\n-      end if;\n-\n-      --  Process inherited postconditions\n-\n-      --  Code is currently commented out as, in some cases, it causes crashes\n-      --  because Direct_Primitive_Operations is not available for a private\n-      --  type. This may cause more warnings to be issued than necessary. ???\n-\n---        for J in Inherited'Range loop\n---           if Present (Pre_Post_Conditions (Contract (Inherited (J)))) then\n---              Process_Post_Conditions (Inherited (J), Class => True);\n---           end if;\n---        end loop;\n-\n-      --  Process contract cases\n-\n-      if Present (Contract_Test_Cases (Contract (Spec_Id))) then\n-         Process_Contract_Cases (Spec_Id);\n-      end if;\n-\n-      --  Issue warning for functions whose postcondition does not mention\n-      --  'Result after all postconditions have been processed, and provided\n-      --  all postconditions do not already get a warning that they only refer\n-      --  to pre-state.\n-\n-      if Ekind_In (Spec_Id, E_Function, E_Generic_Function)\n-        and then (Present (Last_Postcondition)\n-                   or else Present (Last_Contract_Cases))\n-        and then not Attribute_Result_Mentioned\n-        and then No_Warning_On_Some_Postcondition\n-      then\n-         if Present (Last_Postcondition) then\n-            if Present (Last_Contract_Cases) then\n-               Error_Msg_N\n-                 (\"neither function postcondition nor \"\n-                  & \"contract cases mention result?T?\", Last_Postcondition);\n-\n-            else\n-               Error_Msg_N\n-                 (\"function postcondition does not mention result?T?\",\n-                  Last_Postcondition);\n-            end if;\n-         else\n-            Error_Msg_N\n-              (\"contract cases do not mention result?T?\", Last_Contract_Cases);\n-         end if;\n-      end if;\n-   end Check_Subprogram_Contract;\n-\n    ----------------------------\n    -- Check_Subprogram_Order --\n    ----------------------------\n@@ -11578,8 +11515,6 @@ package body Sem_Ch6 is\n                            Expression (First\n                              (Pragma_Argument_Associations (CCs)));\n          Decls         : constant List_Id := Declarations (N);\n-         Multiple_PCs  : constant Boolean :=\n-                           List_Length (Component_Associations (Aggr)) > 1;\n          Case_Guard    : Node_Id;\n          CG_Checks     : Node_Id;\n          CG_Stmts      : List_Id;\n@@ -11589,6 +11524,7 @@ package body Sem_Ch6 is\n          Error_Decls   : List_Id;\n          Flag          : Entity_Id;\n          Msg_Str       : Entity_Id;\n+         Multiple_PCs  : Boolean;\n          Others_Flag   : Entity_Id := Empty;\n          Post_Case     : Node_Id;\n \n@@ -11600,8 +11536,15 @@ package body Sem_Ch6 is\n \n          if Is_Ignored (CCs) then\n             return;\n+\n+         --  Guard against malformed contract cases\n+\n+         elsif Nkind (Aggr) /= N_Aggregate then\n+            return;\n          end if;\n \n+         Multiple_PCs := List_Length (Component_Associations (Aggr)) > 1;\n+\n          --  Create the counter which tracks the number of case guards that\n          --  evaluate to True.\n "}, {"sha": "0799adc184965fa8b211ace6e86f48cfd768bb63", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5afe5d2d4485638a63fa23f456eb6942f2e5bd38/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5afe5d2d4485638a63fa23f456eb6942f2e5bd38/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=5afe5d2d4485638a63fa23f456eb6942f2e5bd38", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,6 +46,10 @@ package Sem_Ch6 is\n    procedure Analyze_Subprogram_Declaration          (N : Node_Id);\n    procedure Analyze_Subprogram_Body                 (N : Node_Id);\n \n+   procedure Analyze_Subprogram_Contract (Subp : Entity_Id);\n+   --  Analyze all delayed aspects chained on the contract of subprogram Subp\n+   --  as if they appeared at the end of a declarative region.\n+\n    function Analyze_Subprogram_Specification (N : Node_Id) return Entity_Id;\n    --  Analyze subprogram specification in both subprogram declarations\n    --  and body declarations. Returns the defining entity for the\n@@ -139,10 +143,6 @@ package Sem_Ch6 is\n    --  type-conformant subprogram that becomes hidden by the new subprogram.\n    --  Is_Primitive indicates whether the subprogram is primitive.\n \n-   procedure Check_Subprogram_Contract (Spec_Id : Entity_Id);\n-   --  Spec_Id is the spec entity for a subprogram. This routine issues\n-   --  warnings on suspicious contracts if Warn_On_Suspicious_Contract is set.\n-\n    procedure Check_Subtype_Conformant\n      (New_Id                   : Entity_Id;\n       Old_Id                   : Entity_Id;"}, {"sha": "9339d490c974d8a52463b9e58e3f20e103096bf0", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 238, "deletions": 242, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5afe5d2d4485638a63fa23f456eb6942f2e5bd38/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5afe5d2d4485638a63fa23f456eb6942f2e5bd38/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=5afe5d2d4485638a63fa23f456eb6942f2e5bd38", "patch": "@@ -181,6 +181,13 @@ package body Sem_Prag is\n    --  to Uppercase or Lowercase, then a new string literal with appropriate\n    --  casing is constructed.\n \n+   function Find_Related_Subprogram\n+     (Prag             : Node_Id;\n+      Check_Duplicates : Boolean := False) return Node_Id;\n+   --  Find the declaration of the related subprogram subject to pragma Prag.\n+   --  If flag Check_Duplicates is set, the routine emits errors concerning\n+   --  duplicate pragmas.\n+\n    function Get_Base_Subprogram (Def_Id : Entity_Id) return Entity_Id;\n    --  If Def_Id refers to a renamed subprogram, then the base subprogram (the\n    --  original one, following the renaming chain) is returned. Otherwise the\n@@ -213,10 +220,12 @@ package body Sem_Prag is\n    --  pragma in the source program, a breakpoint on rv catches this place in\n    --  the source, allowing convenient stepping to the point of interest.\n \n-   function Requires_Profile_Installation (Subp : Node_Id) return Boolean;\n+   function Requires_Profile_Installation\n+     (Prag : Node_Id;\n+      Subp : Node_Id) return Boolean;\n    --  Subsidiary routine to the analysis of pragma Depends and pragma Global.\n    --  Determine whether the profile of subprogram Subp must be installed into\n-   --  visibility to access its formals.\n+   --  visibility to access its formals from pragma Prag.\n \n    procedure Set_Unit_Name (N : Node_Id; With_Item : Node_Id);\n    --  Place semantic information on the argument of an Elaborate/Elaborate_All\n@@ -282,80 +291,122 @@ package body Sem_Prag is\n       end if;\n    end Adjust_External_Name_Case;\n \n-   ------------------------------\n-   -- Analyze_CTC_In_Decl_Part --\n-   ------------------------------\n+   -----------------------------------------\n+   -- Analyze_Contract_Cases_In_Decl_Part --\n+   -----------------------------------------\n \n-   procedure Analyze_CTC_In_Decl_Part (N : Node_Id; S : Entity_Id) is\n+   procedure Analyze_Contract_Cases_In_Decl_Part (N : Node_Id) is\n+      Others_Seen : Boolean := False;\n \n-      procedure Analyze_Contract_Cases (Aggr : Node_Id);\n-      --  Pre-analyze the guard and consequence expressions of a Contract_Cases\n-      --  pragma/aspect aggregate expression.\n+      procedure Analyze_Contract_Case (CCase : Node_Id);\n+      --  Verify the legality of a single contract case\n \n-      ----------------------------\n-      -- Analyze_Contract_Cases --\n-      ----------------------------\n+      ---------------------------\n+      -- Analyze_Contract_Case --\n+      ---------------------------\n \n-      procedure Analyze_Contract_Cases (Aggr : Node_Id) is\n-         Case_Guard : Node_Id;\n-         Conseq     : Node_Id;\n-         Post_Case  : Node_Id;\n+      procedure Analyze_Contract_Case (CCase : Node_Id) is\n+         Case_Guard  : Node_Id;\n+         Conseq      : Node_Id;\n+         Extra_Guard : Node_Id;\n \n       begin\n-         Post_Case := First (Component_Associations (Aggr));\n-         while Present (Post_Case) loop\n-            Case_Guard := First (Choices (Post_Case));\n-            Conseq     := Expression (Post_Case);\n+         if Nkind (CCase) = N_Component_Association then\n+            Case_Guard := First (Choices (CCase));\n+            Conseq     := Expression (CCase);\n+\n+            --  Each contract case must have exactly one case guard\n \n-            --  Preanalyze the boolean expression, we treat this as a spec\n-            --  expression (i.e. similar to a default expression).\n+            Extra_Guard := Next (Case_Guard);\n+\n+            if Present (Extra_Guard) then\n+               Error_Msg_N\n+                 (\"contract case may have only one case guard\", Extra_Guard);\n+            end if;\n+\n+            --  Check the placement of \"others\" (if available)\n+\n+            if Nkind (Case_Guard) = N_Others_Choice then\n+               if Others_Seen then\n+                  Error_Msg_N\n+                    (\"only one others choice allowed in aspect Contract_Cases\",\n+                     Case_Guard);\n+               else\n+                  Others_Seen := True;\n+               end if;\n+\n+            elsif Others_Seen then\n+               Error_Msg_N\n+                 (\"others must be the last choice in aspect Contract_Cases\",\n+                  N);\n+            end if;\n+\n+            --  Preanalyze the case guard and consequence\n \n             if Nkind (Case_Guard) /= N_Others_Choice then\n                Preanalyze_Assert_Expression (Case_Guard, Standard_Boolean);\n             end if;\n \n             Preanalyze_Assert_Expression (Conseq, Standard_Boolean);\n \n-            Next (Post_Case);\n-         end loop;\n-      end Analyze_Contract_Cases;\n+         --  The contract case is malformed\n \n-   --  Start of processing for Analyze_CTC_In_Decl_Part\n+         else\n+            Error_Msg_N (\"wrong syntax in contract case\", CCase);\n+         end if;\n+      end Analyze_Contract_Case;\n+\n+      --  Local variables\n+\n+      Arg1      : constant Node_Id := First (Pragma_Argument_Associations (N));\n+      All_Cases : Node_Id;\n+      CCase     : Node_Id;\n+      Subp_Decl : Node_Id;\n+      Subp_Id   : Entity_Id;\n+\n+   --  Start of processing for Analyze_Contract_Cases_In_Decl_Part\n \n    begin\n-      --  Install formals and push subprogram spec onto scope stack so that we\n-      --  can see the formals from the pragma.\n+      Set_Analyzed (N);\n \n-      Push_Scope (S);\n-      Install_Formals (S);\n+      Subp_Decl := Find_Related_Subprogram (N);\n+      Subp_Id   := Defining_Unit_Name (Specification (Subp_Decl));\n+      All_Cases := Expression (Arg1);\n \n-      --  Preanalyze the boolean expressions, we treat these as spec\n-      --  expressions (i.e. similar to a default expression).\n+      --  Multiple contract cases appear in aggregate form\n \n-      if Pragma_Name (N) = Name_Test_Case then\n-         Preanalyze_CTC_Args\n-           (N,\n-            Get_Requires_From_CTC_Pragma (N),\n-            Get_Ensures_From_CTC_Pragma (N));\n+      if Nkind (All_Cases) = N_Aggregate then\n+         if No (Component_Associations (All_Cases)) then\n+            Error_Msg_N (\"wrong syntax for aspect Contract_Cases\", N);\n \n-      else\n-         pragma Assert (Pragma_Name (N) = Name_Contract_Cases);\n-         Analyze_Contract_Cases\n-           (Expression (First (Pragma_Argument_Associations (N))));\n+         --  Individual contract cases appear as component associations\n \n-         --  In ASIS mode, for a pragma generated from a source aspect, also\n-         --  analyze the original aspect expression.\n+         else\n+            --  Ensure that the formal parameters are visible when analyzing\n+            --  all clauses. This falls out of the general rule of aspects\n+            --  pertaining to subprogram declarations. Skip the installation\n+            --  for subprogram bodies because the formals are already visible.\n \n-         if ASIS_Mode and then Present (Corresponding_Aspect (N)) then\n-            Analyze_Contract_Cases (Expression (Corresponding_Aspect (N)));\n-         end if;\n-      end if;\n+            if Requires_Profile_Installation (N, Subp_Decl) then\n+               Push_Scope (Subp_Id);\n+               Install_Formals (Subp_Id);\n+            end if;\n \n-      --  Remove the subprogram from the scope stack now that the pre-analysis\n-      --  of the expressions in the contract case or test case is done.\n+            CCase := First (Component_Associations (All_Cases));\n+            while Present (CCase) loop\n+               Analyze_Contract_Case (CCase);\n+               Next (CCase);\n+            end loop;\n \n-      End_Scope;\n-   end Analyze_CTC_In_Decl_Part;\n+            if Requires_Profile_Installation (N, Subp_Decl) then\n+               End_Scope;\n+            end if;\n+         end if;\n+\n+      else\n+         Error_Msg_N (\"wrong syntax for aspect Contract_Cases\", N);\n+      end if;\n+   end Analyze_Contract_Cases_In_Decl_Part;\n \n    ----------------------------------\n    -- Analyze_Depends_In_Decl_Part --\n@@ -1358,7 +1409,7 @@ package body Sem_Prag is\n          --  to subprogram declarations. Skip the installation for subprogram\n          --  bodies because the formals are already visible.\n \n-         if Requires_Profile_Installation (Subp_Decl) then\n+         if Requires_Profile_Installation (N, Subp_Decl) then\n             Push_Scope (Subp_Id);\n             Install_Formals (Subp_Id);\n          end if;\n@@ -1389,7 +1440,7 @@ package body Sem_Prag is\n             Next (Clause);\n          end loop;\n \n-         if Requires_Profile_Installation (Subp_Decl) then\n+         if Requires_Profile_Installation (N, Subp_Decl) then\n             End_Scope;\n          end if;\n \n@@ -1713,14 +1764,14 @@ package body Sem_Prag is\n          --  item. This falls out of the general rule of aspects pertaining to\n          --  subprogram declarations.\n \n-         if Requires_Profile_Installation (Subp_Decl) then\n+         if Requires_Profile_Installation (N, Subp_Decl) then\n             Push_Scope (Subp_Id);\n             Install_Formals (Subp_Id);\n          end if;\n \n          Analyze_Global_List (List);\n \n-         if Requires_Profile_Installation (Subp_Decl) then\n+         if Requires_Profile_Installation (N, Subp_Decl) then\n             End_Scope;\n          end if;\n       end if;\n@@ -10049,204 +10100,46 @@ package body Sem_Prag is\n          --  CONSEQUENCE ::= boolean_EXPRESSION\n \n          when Pragma_Contract_Cases => Contract_Cases : declare\n-            Others_Seen : Boolean := False;\n-\n-            procedure Analyze_Contract_Case (Contract_Case : Node_Id);\n-            --  Verify the legality of a single contract case\n-\n-            procedure Chain_Contract_Cases (Subp_Id : Entity_Id);\n-            --  Chain pragma Contract_Cases to the contract of a subprogram.\n-            --  Subp_Id is the related subprogram.\n-\n-            ---------------------------\n-            -- Analyze_Contract_Case --\n-            ---------------------------\n-\n-            procedure Analyze_Contract_Case (Contract_Case : Node_Id) is\n-               Case_Guard  : Node_Id;\n-               Extra_Guard : Node_Id;\n-\n-            begin\n-               if Nkind (Contract_Case) = N_Component_Association then\n-                  Case_Guard := First (Choices (Contract_Case));\n-\n-                  --  Each contract case must have exactly on case guard\n-\n-                  Extra_Guard := Next (Case_Guard);\n-\n-                  if Present (Extra_Guard) then\n-                     Error_Pragma_Arg\n-                       (\"contract case may have only one case guard\",\n-                        Extra_Guard);\n-                  end if;\n-\n-                  --  Check the placement of \"others\" (if available)\n-\n-                  if Nkind (Case_Guard) = N_Others_Choice then\n-                     if Others_Seen then\n-                        Error_Pragma_Arg\n-                          (\"only one others choice allowed in pragma %\",\n-                           Case_Guard);\n-                     else\n-                        Others_Seen := True;\n-                     end if;\n-\n-                  elsif Others_Seen then\n-                     Error_Pragma_Arg\n-                       (\"others must be the last choice in pragma %\", N);\n-                  end if;\n-\n-               --  The contract case is malformed\n-\n-               else\n-                  Error_Pragma_Arg\n-                    (\"wrong syntax in contract case\", Contract_Case);\n-               end if;\n-            end Analyze_Contract_Case;\n-\n-            --------------------------\n-            -- Chain_Contract_Cases --\n-            --------------------------\n-\n-            procedure Chain_Contract_Cases (Subp_Id : Entity_Id) is\n-               CTC : Node_Id;\n-\n-            begin\n-               Check_Duplicate_Pragma (Subp_Id);\n-               CTC := Contract_Test_Cases (Contract (Subp_Id));\n-               while Present (CTC) loop\n-                  if Chars (Pragma_Identifier (CTC)) = Pname then\n-                     Error_Msg_Name_1 := Pname;\n-                     Error_Msg_Sloc   := Sloc (CTC);\n-\n-                     if From_Aspect_Specification (CTC) then\n-                        Error_Msg_NE\n-                          (\"aspect% for & previously given#\", N, Subp_Id);\n-                     else\n-                        Error_Msg_NE\n-                          (\"pragma% for & duplicates pragma#\", N, Subp_Id);\n-                     end if;\n-\n-                     raise Pragma_Exit;\n-                  end if;\n-\n-                  CTC := Next_Pragma (CTC);\n-               end loop;\n-\n-               --  Prepend pragma Contract_Cases to the contract\n-\n-               Add_Contract_Item (N, Subp_Id);\n-            end Chain_Contract_Cases;\n-\n-            --  Local variables\n-\n-            Context       : constant Node_Id := Parent (N);\n-            All_Cases     : Node_Id;\n-            Decl          : Node_Id;\n-            Contract_Case : Node_Id;\n-            Subp_Decl     : Node_Id;\n-            Subp_Id       : Entity_Id;\n-\n-         --  Start of processing for Contract_Cases\n+            Subp_Decl : Node_Id;\n+            Subp_Id   : Entity_Id;\n \n          begin\n             GNAT_Pragma;\n+            S14_Pragma;\n             Check_Arg_Count (1);\n \n-            --  Check the placement of the pragma\n+            --  Ensure the proper placement of the pragma. Contract_Cases must\n+            --  be associated with a subprogram declaration or a body that acts\n+            --  as a spec.\n+\n+            Subp_Decl := Find_Related_Subprogram (N, Check_Duplicates => True);\n \n-            if not Is_List_Member (N) then\n+            if Nkind (Subp_Decl) /= N_Subprogram_Declaration\n+              and then (Nkind (Subp_Decl) /= N_Subprogram_Body\n+                         or else not Acts_As_Spec (Subp_Decl))\n+            then\n                Pragma_Misplaced;\n+               return;\n             end if;\n \n-            --  Aspect/pragma Contract_Cases may be associated with a library\n-            --  level subprogram.\n-\n-            if Nkind (Context) = N_Compilation_Unit_Aux then\n-               Subp_Decl := Unit (Parent (Context));\n-\n-               if not Nkind_In (Subp_Decl, N_Generic_Subprogram_Declaration,\n-                                           N_Subprogram_Declaration)\n-               then\n-                  Pragma_Misplaced;\n-               end if;\n-\n-               Subp_Id := Defining_Unit_Name (Specification (Subp_Decl));\n-\n-            --  The aspect/pragma appears in a subprogram body. The placement\n-            --  is legal when the body acts as a spec.\n-\n-            elsif Nkind (Context) = N_Subprogram_Body then\n-               Subp_Id := Defining_Unit_Name (Specification (Context));\n-\n-               if not Acts_As_Spec (Context) then\n-                  Error_Pragma\n-                    (\"pragma % may not appear in a subprogram body that acts \"\n-                     & \"as completion\");\n-               end if;\n-\n-            --  Nested subprogram case, the aspect/pragma must apply to the\n-            --  subprogram spec.\n-\n-            else\n-               Decl := N;\n-               while Present (Prev (Decl)) loop\n-                  Decl := Prev (Decl);\n-\n-                  if Nkind (Decl) in N_Generic_Declaration then\n-                     Subp_Decl := Decl;\n-                  else\n-                     Subp_Decl := Original_Node (Decl);\n-                  end if;\n-\n-                  --  Skip prior pragmas\n-\n-                  if Nkind (Subp_Decl) = N_Pragma then\n-                     null;\n-\n-                  --  Skip internally generated code\n-\n-                  elsif not Comes_From_Source (Subp_Decl) then\n-                     null;\n-\n-                  --  We have found the related subprogram\n-\n-                  elsif Nkind_In (Subp_Decl, N_Generic_Subprogram_Declaration,\n-                                             N_Subprogram_Declaration)\n-                  then\n-                     exit;\n-\n-                  else\n-                     Pragma_Misplaced;\n-                  end if;\n-               end loop;\n-\n-               Subp_Id := Defining_Unit_Name (Specification (Subp_Decl));\n-            end if;\n+            Subp_Id := Defining_Unit_Name (Specification (Subp_Decl));\n \n-            All_Cases := Expression (Arg1);\n+            --  The pragma is analyzed at the end of the declarative part which\n+            --  contains the related subprogram. Reset the analyzed flag.\n \n-            --  Multiple contract cases appear in aggregate form\n+            Set_Analyzed (N, False);\n \n-            if Nkind (All_Cases) = N_Aggregate then\n-               if No (Component_Associations (All_Cases)) then\n-                  Error_Pragma (\"wrong syntax for pragma %\");\n+            --  When the aspect/pragma appears on a subprogram body, perform\n+            --  the full analysis now.\n \n-               --  Individual contract cases appear as component associations\n+            if Nkind (Subp_Decl) = N_Subprogram_Body then\n+               Analyze_Contract_Cases_In_Decl_Part (N);\n \n-               else\n-                  Contract_Case := First (Component_Associations (All_Cases));\n-                  while Present (Contract_Case) loop\n-                     Analyze_Contract_Case (Contract_Case);\n+            --  Chain the pragma on the contract for further processing\n \n-                     Next (Contract_Case);\n-                  end loop;\n-               end if;\n             else\n-               Error_Pragma (\"wrong syntax for pragma %\");\n+               Add_Contract_Item (N, Subp_Id);\n             end if;\n-\n-            Chain_Contract_Cases (Subp_Id);\n          end Contract_Cases;\n \n          ----------------\n@@ -18013,6 +17906,34 @@ package body Sem_Prag is\n       when Pragma_Exit => null;\n    end Analyze_Pragma;\n \n+   ------------------------------------\n+   -- Analyze_Test_Case_In_Decl_Part --\n+   ------------------------------------\n+\n+   procedure Analyze_Test_Case_In_Decl_Part (N : Node_Id; S : Entity_Id) is\n+   begin\n+      --  Install formals and push subprogram spec onto scope stack so that we\n+      --  can see the formals from the pragma.\n+\n+      Push_Scope (S);\n+      Install_Formals (S);\n+\n+      --  Preanalyze the boolean expressions, we treat these as spec\n+      --  expressions (i.e. similar to a default expression).\n+\n+      if Pragma_Name (N) = Name_Test_Case then\n+         Preanalyze_CTC_Args\n+           (N,\n+            Get_Requires_From_CTC_Pragma (N),\n+            Get_Ensures_From_CTC_Pragma (N));\n+      end if;\n+\n+      --  Remove the subprogram from the scope stack now that the pre-analysis\n+      --  of the expressions in the contract case or test case is done.\n+\n+      End_Scope;\n+   end Analyze_Test_Case_In_Decl_Part;\n+\n    ----------------\n    -- Check_Kind --\n    ----------------\n@@ -18136,6 +18057,75 @@ package body Sem_Prag is\n                                       Name_Priority_Specific_Dispatching);\n    end Delay_Config_Pragma_Analyze;\n \n+   -----------------------------\n+   -- Find_Related_Subprogram --\n+   -----------------------------\n+\n+   function Find_Related_Subprogram\n+     (Prag             : Node_Id;\n+      Check_Duplicates : Boolean := False) return Node_Id\n+   is\n+      Context   : constant Node_Id := Parent (Prag);\n+      Nam       : constant Name_Id := Pragma_Name (Prag);\n+      Decl      : Node_Id;\n+      Subp_Decl : Node_Id;\n+\n+   begin\n+      --  The pragma is a byproduct of an aspect\n+\n+      if Present (Corresponding_Aspect (Prag)) then\n+         Subp_Decl := Parent (Corresponding_Aspect (Prag));\n+\n+      --  The pragma is associated with a library-level subprogram\n+\n+      elsif Nkind (Context) = N_Compilation_Unit_Aux then\n+         Subp_Decl := Unit (Parent (Context));\n+\n+      --  The pragma appears inside the declarative part of a subprogram body\n+\n+      elsif Nkind (Context) = N_Subprogram_Body then\n+         Subp_Decl := Context;\n+\n+      --  The pragma appears someplace after its related subprogram. Inspect\n+      --  all previous declarations for a suitable candidate.\n+\n+      else\n+         Decl      := Prag;\n+         Subp_Decl := Empty;\n+         while Present (Prev (Decl)) loop\n+            Decl := Prev (Decl);\n+\n+            if Nkind (Decl) in N_Generic_Declaration then\n+               Subp_Decl := Decl;\n+            else\n+               Subp_Decl := Original_Node (Decl);\n+            end if;\n+\n+            --  Skip prior pragmas\n+\n+            if Nkind (Subp_Decl) = N_Pragma then\n+               if Check_Duplicates and then Pragma_Name (Subp_Decl) = Nam then\n+                  Error_Msg_Name_1 := Nam;\n+                  Error_Msg_Sloc   := Sloc (Subp_Decl);\n+                  Error_Msg_N (\"pragma % duplicates pragma declared #\", Prag);\n+               end if;\n+\n+            --  Skip internally generated code\n+\n+            elsif not Comes_From_Source (Subp_Decl) then\n+               null;\n+\n+            --  The nearest preceding declaration is the related subprogram\n+\n+            else\n+               exit;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      return Subp_Decl;\n+   end Find_Related_Subprogram;\n+\n    -------------------------\n    -- Get_Base_Subprogram --\n    -------------------------\n@@ -18855,7 +18845,10 @@ package body Sem_Prag is\n    -- Requires_Profile_Installation --\n    -----------------------------------\n \n-   function Requires_Profile_Installation (Subp : Node_Id) return Boolean is\n+   function Requires_Profile_Installation\n+     (Prag : Node_Id;\n+      Subp : Node_Id) return Boolean\n+   is\n    begin\n       --  When aspects Depends and Global are associated with a subprogram\n       --  declaration, their corresponding pragmas are analyzed at the end of\n@@ -18868,12 +18861,15 @@ package body Sem_Prag is\n       --  When aspects Depends and Global are associated with a subprogram body\n       --  which is also a compilation unit, their corresponding pragmas appear\n       --  in the Pragmas_After list. The Pragmas_After collection is analyzed\n-      --  out of context and the formals must be installed in visibility.\n+      --  out of context and the formals must be installed in visibility. This\n+      --  does not apply when the pragma is a source construct.\n \n-      elsif Nkind (Subp) = N_Subprogram_Body\n-        and then Nkind (Parent (Subp)) = N_Compilation_Unit\n-      then\n-         return True;\n+      elsif Nkind (Subp) = N_Subprogram_Body then\n+         if Nkind (Parent (Subp)) = N_Compilation_Unit then\n+            return Present (Corresponding_Aspect (Prag));\n+         else\n+            return False;\n+         end if;\n \n       --  In all other cases the two corresponding pragmas are analyzed in\n       --  context and the formals are already visibile."}, {"sha": "3b8a3bcbc8940330c6ec6a5238dc6e802d611373", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5afe5d2d4485638a63fa23f456eb6942f2e5bd38/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5afe5d2d4485638a63fa23f456eb6942f2e5bd38/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=5afe5d2d4485638a63fa23f456eb6942f2e5bd38", "patch": "@@ -38,13 +38,8 @@ package Sem_Prag is\n    procedure Analyze_Pragma (N : Node_Id);\n    --  Analyze procedure for pragma reference node N\n \n-   procedure Analyze_CTC_In_Decl_Part (N : Node_Id; S : Entity_Id);\n-   --  Special analyze routine for contract-case and test-case pragmas that\n-   --  appears within a declarative part where the pragma is associated with\n-   --  a subprogram specification. N is the pragma node, and S is the entity\n-   --  for the related subprogram. This procedure does a preanalysis of the\n-   --  expressions in the pragma as \"spec expressions\" (see section in Sem\n-   --  \"Handling of Default and Per-Object Expressions...\").\n+   procedure Analyze_Contract_Cases_In_Decl_Part (N : Node_Id);\n+   --  Perform full analysis and expansion of delayed pragma Contract_Cases\n \n    procedure Analyze_Depends_In_Decl_Part (N : Node_Id);\n    --  Perform full analysis of delayed pragma Depends\n@@ -60,6 +55,14 @@ package Sem_Prag is\n    --  of the expressions in the pragma as \"spec expressions\" (see section\n    --  in Sem \"Handling of Default and Per-Object Expressions...\").\n \n+   procedure Analyze_Test_Case_In_Decl_Part (N : Node_Id; S : Entity_Id);\n+   --  Special analyze routine for contract-case and test-case pragmas that\n+   --  appears within a declarative part where the pragma is associated with\n+   --  a subprogram specification. N is the pragma node, and S is the entity\n+   --  for the related subprogram. This procedure does a preanalysis of the\n+   --  expressions in the pragma as \"spec expressions\" (see section in Sem\n+   --  \"Handling of Default and Per-Object Expressions...\").\n+\n    function Check_Kind (Nam : Name_Id) return Name_Id;\n    --  This function is used in connection with pragmas Assert, Check,\n    --  and assertion aspects and pragmas, to determine if Check pragmas"}]}