{"sha": "b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc4MDI3ZDFhM2Y5YThmZGYzMzg2ZTI0ZGNmZDY2NzkwMDZkZDE1NA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-10-18T00:19:17Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-10-18T00:19:17Z"}, "message": "read-md.c: Move various state to within class rtx_reader\n\ngcc/ChangeLog:\n\t* genattrtab.c (attr_string): Use rtx_reader_ptr for call to\n\tcopy_md_ptr_loc.\n\t(gen_attr): Use rtx_reader_ptr for lookup_enum_type call.\n\t(write_test_expr): Use rtx_reader_ptr for calls to\n\tfprint_c_condition.\n\t(write_attr_value): Likewise.\n\t* genconditions.c (write_one_condition): Use rtx_reader_ptr for\n\tcall to print_md_ptr_loc.\n\t(write_one_condition): Likewise for calls to print_c_condition.\n\t* genconstants.c: Include \"statistics.h\" and \"vec.h\".\n\t(main): Update for conversion to member functions.\n\t* genemit.c (emit_c_code): Use rtx_reader_ptr for\n\tcall to print_md_ptr_loc.\n\t* genenums.c: Include \"statistics.h\" and \"vec.h\".\n\t(main): Update for conversion of traverse_enum_types to a method.\n\t* genmddeps.c: Include \"statistics.h\" and \"vec.h\".\n\t* genoutput.c (process_template): Use rtx_reader_ptr for call to\n\tprint_md_ptr_loc.\n\t* genpreds.c (write_predicate_subfunction): Likewise.\n\t(write_predicate_expr): Likewise for calls to print_c_condition.\n\t* genrecog.c (print_test): Likewise.\n\t* gensupport.c (process_rtx): Likewise for calls to\n\tcopy_md_ptr_loc and join_c_conditions.\n\t(alter_test_for_insn): Likewise for call to join_c_conditions.\n\t(process_substs_on_one_elem): Likewise.\n\t(gen_mnemonic_setattr): Update for move of string_obstack to a\n\tfield of rtx_reader.\n\t(mnemonic_htab_callback): Likewise.  Fix formatting.\n\t(gen_mnemonic_attr): Likewise.\n\t* gentarget-def.c (def_target_insn): Use rtx_reader_ptr for calls\n\tto print_c_condition.\n\t* read-md.c: Include \"statistics.h\" and \"vec.h\".\n\t(string_obstack): Convert this global to field \"m_string_obstack\"\n\tof class rtx_reader.\n\t(ptr_locs): Likewise, as \"m_ptr_locs\".\n\t(ptr_loc_obstack): Likewise, as \"m_ptr_loc_obstack\".\n\t(joined_conditions): Likewise, as \"m_joined_conditions\".\n\t(joined_conditions_obstack): Likewise, as \"m_joined_conditions_obstack\".\n\t(md_constants): Likewise, as \"m_md_constants\".\n\t(enum_types): Likewise, as \"m_enum_types\".\n\t(set_md_ptr_loc): Convert to...\n\t(rtx_reader::set_md_ptr_loc): ...member function.\n\t(get_md_ptr_loc): Convert to...\n\t(rtx_reader::get_md_ptr_loc): ...member function.\n\t(copy_md_ptr_loc): Convert to...\n\t(rtx_reader::copy_md_ptr_loc): ...member function.\n\t(fprint_md_ptr_loc): Convert to...\n\t(rtx_reader::fprint_md_ptr_loc): ...member function.\n\t(print_md_ptr_loc): Convert to...\n\t(rtx_reader::print_md_ptr_loc): ...member function.\n\t(join_c_conditions): Convert to...\n\t(rtx_reader::join_c_conditions): ...member function.\n\t(fprint_c_condition): Convert to...\n\t(rtx_reader::fprint_c_condition): ...member function.\n\t(print_c_condition): Convert to...\n\t(rtx_reader::print_c_condition): ...member function.\n\t(read_name): Convert to...\n\t(rtx_reader::read_name): ...member function.\n\t(read_escape): Convert to...\n\t(rtx_reader::read_escape): ...member function.\n\t(read_quoted_string): Convert to...\n\t(rtx_reader::read_quoted_string): ...member function.\n\t(read_braced_string): Convert to...\n\t(rtx_reader::read_braced_string): ...member function.\n\t(read_string): Convert to...\n\t(rtx_reader::read_string): ...member function.\n\t(read_skip_construct): Convert to...\n\t(rtx_reader::read_skip_construct): ...member function.\n\t(handle_constants): Convert to...\n\t(rtx_reader::handle_constants): ...member function.\n\t(traverse_md_constants): Convert to...\n\t(rtx_reader::traverse_md_constants): ...member function.\n\t(handle_enum): Convert to...\n\t(rtx_reader::handle_enum): ...member function.\n\t(lookup_enum_type): Convert to...\n\t(rtx_reader::lookup_enum_type): ...member function.\n\t(traverse_enum_types): Convert to...\n\t(rtx_reader::traverse_enum_types): ...member function.\n\t(rtx_reader::rtx_reader): Move initializations\n\tof various former global data from rtx_reader::read_md_files to\n\there, as fields, along with the call to unlock_std_streams.\n\t(rtx_reader::~rtx_reader): Clean up m_base_dir, and clean up\n\tthe new fields.\n\t(rtx_reader::read_md_files): Move initializations of various\n\tglobal data from here to the ctor.\n\t* read-md.h (read_name): Convert to...\n\t(rtx_reader::read_name): ...member function.\n\t(rtx_reader::read_escape): New method decl.\n\t(read_quoted_string): Convert to...\n\t(rtx_reader::read_quoted_string): ...member function.\n\t(rtx_reader::read_braced_string): New method decl.\n\t(read_string): Convert to...\n\t(rtx_reader::read_string): ...member function.\n\t(rtx_reader::read_skip_construct): New method decl.\n\t(rtx_reader::set_md_ptr_loc): New method decl.\n\t(rtx_reader::get_md_ptr_loc): New method decl.\n\t(copy_md_ptr_loc): Convert to...\n\t(rtx_reader::copy_md_ptr_loc): ...member function.\n\t(fprint_md_ptr_loc): Convert to...\n\t(rtx_reader::fprint_md_ptr_loc): ...member function.\n\t(print_md_ptr_loc): Convert to...\n\t(rtx_reader::print_md_ptr_loc): ...member function.\n\t(rtx_reader::lookup_enum_type): New method decl.\n\t(rtx_reader::traverse_enum_types): New method decl.\n\t(rtx_reader::handle_constants): New method decl.\n\t(traverse_md_constants): Convert to...\n\t(rtx_reader::traverse_md_constants): ...member function.\n\t(rtx_reader::handle_enum): New method decl.\n\t(rtx_reader::join_c_conditions): New method decl.\n\t(fprint_c_condition): Convert to...\n\t(rtx_reader::fprint_c_condition): ...member function.\n\t(print_c_condition): Convert to...\n\t(rtx_reader::print_c_condition): ...member function.\n\t(rtx_reader::apply_iterator_to_string): New method decl.\n\t(rtx_reader::copy_rtx_for_iterators): New method decl.\n\t(rtx_reader::read_conditions): New method decl.\n\t(rtx_reader::record_potential_iterator_use): New method decl.\n\t(rtx_reader::read_mapping): New method decl.\n\t(rtx_reader::read_rtx): New method decl.\n\t(rtx_reader::read_rtx_code): New method decl.\n\t(rtx_reader::read_rtx_operand): New method decl.\n\t(rtx_reader::read_nested_rtx): New method decl.\n\t(rtx_reader::read_rtx_variadic): New method decl.\n\t(rtx_reader::get_string_obstack): New method.\n\t(rtx_reader::get_md_constants): New method.\n\t(string_obstack): Convert global variable decl to...\n\t(rtx_reader::m_string_obstack): ...this new field.\n\t(rtx_reader::m_ptr_locs): New field.\n\t(rtx_reader::m_ptr_loc_obstack): New field.\n\t(rtx_reader::m_joined_conditions): New field.\n\t(rtx_reader::m_joined_conditions_obstack): New field.\n\t(rtx_reader::m_md_constants): New field.\n\t(rtx_reader::m_enum_types): New field.\n\t* read-rtl.c (apply_iterator_to_string): Convert to...\n\t(rtx_reader::apply_iterator_to_string): ...member function.\n\t(copy_rtx_for_iterators): Convert to...\n\t(rtx_reader::copy_rtx_for_iterators): ...member function.\n\t(add_condition_to_string): Use rtx_reader_ptr for\n\tcalls join_c_conditions.\n\t(apply_iterators): Use rtx_reader_ptr for calls to\n\tjoin_c_conditions and copy_rtx_for_iterators.\n\t(read_conditions): Convert to...\n\t(rtx_reader::read_conditions): ...member function.\n\t(record_potential_iterator_use): Convert to...\n\t(rtx_reader::record_potential_iterator_use): ...member function.\n\t(read_mapping): Convert to...\n\t(rtx_reader::read_mapping): ...member function.\n\t(read_subst_mapping): Use rtx_reader_ptr for read_string call.\n\t(read_rtx): Convert to...\n\t(rtx_reader::read_rtx): ...member function.\n\t(read_rtx_code): Convert to...\n\t(rtx_reader::read_rtx_code): ...member function.\n\t(read_rtx_operand): Convert to...\n\t(rtx_reader::read_rtx_operand): ...member function.  Update for move\n\tof string_obstack to a field.\n\t(read_nested_rtx): Convert to..\n\t(rtx_reader::read_nested_rtx): ...member function.\n\t(read_rtx_variadic): Convert to..\n\t(rtx_reader::read_rtx_variadic): ...member function.\n\nFrom-SVN: r241293", "tree": {"sha": "a410a1eb6efa653792b4500a10e0449b5a96b937", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a410a1eb6efa653792b4500a10e0449b5a96b937"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b0ce21917da6fa41e693bba287e9e680342d06bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0ce21917da6fa41e693bba287e9e680342d06bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0ce21917da6fa41e693bba287e9e680342d06bd"}], "stats": {"total": 591, "additions": 405, "deletions": 186}, "files": [{"sha": "84e773046b5d76aa92d260ebab499dfc99eeef60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "patch": "@@ -1,3 +1,165 @@\n+2016-10-18  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* genattrtab.c (attr_string): Use rtx_reader_ptr for call to\n+\tcopy_md_ptr_loc.\n+\t(gen_attr): Use rtx_reader_ptr for lookup_enum_type call.\n+\t(write_test_expr): Use rtx_reader_ptr for calls to\n+\tfprint_c_condition.\n+\t(write_attr_value): Likewise.\n+\t* genconditions.c (write_one_condition): Use rtx_reader_ptr for\n+\tcall to print_md_ptr_loc.\n+\t(write_one_condition): Likewise for calls to print_c_condition.\n+\t* genconstants.c: Include \"statistics.h\" and \"vec.h\".\n+\t(main): Update for conversion to member functions.\n+\t* genemit.c (emit_c_code): Use rtx_reader_ptr for\n+\tcall to print_md_ptr_loc.\n+\t* genenums.c: Include \"statistics.h\" and \"vec.h\".\n+\t(main): Update for conversion of traverse_enum_types to a method.\n+\t* genmddeps.c: Include \"statistics.h\" and \"vec.h\".\n+\t* genoutput.c (process_template): Use rtx_reader_ptr for call to\n+\tprint_md_ptr_loc.\n+\t* genpreds.c (write_predicate_subfunction): Likewise.\n+\t(write_predicate_expr): Likewise for calls to print_c_condition.\n+\t* genrecog.c (print_test): Likewise.\n+\t* gensupport.c (process_rtx): Likewise for calls to\n+\tcopy_md_ptr_loc and join_c_conditions.\n+\t(alter_test_for_insn): Likewise for call to join_c_conditions.\n+\t(process_substs_on_one_elem): Likewise.\n+\t(gen_mnemonic_setattr): Update for move of string_obstack to a\n+\tfield of rtx_reader.\n+\t(mnemonic_htab_callback): Likewise.  Fix formatting.\n+\t(gen_mnemonic_attr): Likewise.\n+\t* gentarget-def.c (def_target_insn): Use rtx_reader_ptr for calls\n+\tto print_c_condition.\n+\t* read-md.c: Include \"statistics.h\" and \"vec.h\".\n+\t(string_obstack): Convert this global to field \"m_string_obstack\"\n+\tof class rtx_reader.\n+\t(ptr_locs): Likewise, as \"m_ptr_locs\".\n+\t(ptr_loc_obstack): Likewise, as \"m_ptr_loc_obstack\".\n+\t(joined_conditions): Likewise, as \"m_joined_conditions\".\n+\t(joined_conditions_obstack): Likewise, as \"m_joined_conditions_obstack\".\n+\t(md_constants): Likewise, as \"m_md_constants\".\n+\t(enum_types): Likewise, as \"m_enum_types\".\n+\t(set_md_ptr_loc): Convert to...\n+\t(rtx_reader::set_md_ptr_loc): ...member function.\n+\t(get_md_ptr_loc): Convert to...\n+\t(rtx_reader::get_md_ptr_loc): ...member function.\n+\t(copy_md_ptr_loc): Convert to...\n+\t(rtx_reader::copy_md_ptr_loc): ...member function.\n+\t(fprint_md_ptr_loc): Convert to...\n+\t(rtx_reader::fprint_md_ptr_loc): ...member function.\n+\t(print_md_ptr_loc): Convert to...\n+\t(rtx_reader::print_md_ptr_loc): ...member function.\n+\t(join_c_conditions): Convert to...\n+\t(rtx_reader::join_c_conditions): ...member function.\n+\t(fprint_c_condition): Convert to...\n+\t(rtx_reader::fprint_c_condition): ...member function.\n+\t(print_c_condition): Convert to...\n+\t(rtx_reader::print_c_condition): ...member function.\n+\t(read_name): Convert to...\n+\t(rtx_reader::read_name): ...member function.\n+\t(read_escape): Convert to...\n+\t(rtx_reader::read_escape): ...member function.\n+\t(read_quoted_string): Convert to...\n+\t(rtx_reader::read_quoted_string): ...member function.\n+\t(read_braced_string): Convert to...\n+\t(rtx_reader::read_braced_string): ...member function.\n+\t(read_string): Convert to...\n+\t(rtx_reader::read_string): ...member function.\n+\t(read_skip_construct): Convert to...\n+\t(rtx_reader::read_skip_construct): ...member function.\n+\t(handle_constants): Convert to...\n+\t(rtx_reader::handle_constants): ...member function.\n+\t(traverse_md_constants): Convert to...\n+\t(rtx_reader::traverse_md_constants): ...member function.\n+\t(handle_enum): Convert to...\n+\t(rtx_reader::handle_enum): ...member function.\n+\t(lookup_enum_type): Convert to...\n+\t(rtx_reader::lookup_enum_type): ...member function.\n+\t(traverse_enum_types): Convert to...\n+\t(rtx_reader::traverse_enum_types): ...member function.\n+\t(rtx_reader::rtx_reader): Move initializations\n+\tof various former global data from rtx_reader::read_md_files to\n+\there, as fields, along with the call to unlock_std_streams.\n+\t(rtx_reader::~rtx_reader): Clean up m_base_dir, and clean up\n+\tthe new fields.\n+\t(rtx_reader::read_md_files): Move initializations of various\n+\tglobal data from here to the ctor.\n+\t* read-md.h (read_name): Convert to...\n+\t(rtx_reader::read_name): ...member function.\n+\t(rtx_reader::read_escape): New method decl.\n+\t(read_quoted_string): Convert to...\n+\t(rtx_reader::read_quoted_string): ...member function.\n+\t(rtx_reader::read_braced_string): New method decl.\n+\t(read_string): Convert to...\n+\t(rtx_reader::read_string): ...member function.\n+\t(rtx_reader::read_skip_construct): New method decl.\n+\t(rtx_reader::set_md_ptr_loc): New method decl.\n+\t(rtx_reader::get_md_ptr_loc): New method decl.\n+\t(copy_md_ptr_loc): Convert to...\n+\t(rtx_reader::copy_md_ptr_loc): ...member function.\n+\t(fprint_md_ptr_loc): Convert to...\n+\t(rtx_reader::fprint_md_ptr_loc): ...member function.\n+\t(print_md_ptr_loc): Convert to...\n+\t(rtx_reader::print_md_ptr_loc): ...member function.\n+\t(rtx_reader::lookup_enum_type): New method decl.\n+\t(rtx_reader::traverse_enum_types): New method decl.\n+\t(rtx_reader::handle_constants): New method decl.\n+\t(traverse_md_constants): Convert to...\n+\t(rtx_reader::traverse_md_constants): ...member function.\n+\t(rtx_reader::handle_enum): New method decl.\n+\t(rtx_reader::join_c_conditions): New method decl.\n+\t(fprint_c_condition): Convert to...\n+\t(rtx_reader::fprint_c_condition): ...member function.\n+\t(print_c_condition): Convert to...\n+\t(rtx_reader::print_c_condition): ...member function.\n+\t(rtx_reader::apply_iterator_to_string): New method decl.\n+\t(rtx_reader::copy_rtx_for_iterators): New method decl.\n+\t(rtx_reader::read_conditions): New method decl.\n+\t(rtx_reader::record_potential_iterator_use): New method decl.\n+\t(rtx_reader::read_mapping): New method decl.\n+\t(rtx_reader::read_rtx): New method decl.\n+\t(rtx_reader::read_rtx_code): New method decl.\n+\t(rtx_reader::read_rtx_operand): New method decl.\n+\t(rtx_reader::read_nested_rtx): New method decl.\n+\t(rtx_reader::read_rtx_variadic): New method decl.\n+\t(rtx_reader::get_string_obstack): New method.\n+\t(rtx_reader::get_md_constants): New method.\n+\t(string_obstack): Convert global variable decl to...\n+\t(rtx_reader::m_string_obstack): ...this new field.\n+\t(rtx_reader::m_ptr_locs): New field.\n+\t(rtx_reader::m_ptr_loc_obstack): New field.\n+\t(rtx_reader::m_joined_conditions): New field.\n+\t(rtx_reader::m_joined_conditions_obstack): New field.\n+\t(rtx_reader::m_md_constants): New field.\n+\t(rtx_reader::m_enum_types): New field.\n+\t* read-rtl.c (apply_iterator_to_string): Convert to...\n+\t(rtx_reader::apply_iterator_to_string): ...member function.\n+\t(copy_rtx_for_iterators): Convert to...\n+\t(rtx_reader::copy_rtx_for_iterators): ...member function.\n+\t(add_condition_to_string): Use rtx_reader_ptr for\n+\tcalls join_c_conditions.\n+\t(apply_iterators): Use rtx_reader_ptr for calls to\n+\tjoin_c_conditions and copy_rtx_for_iterators.\n+\t(read_conditions): Convert to...\n+\t(rtx_reader::read_conditions): ...member function.\n+\t(record_potential_iterator_use): Convert to...\n+\t(rtx_reader::record_potential_iterator_use): ...member function.\n+\t(read_mapping): Convert to...\n+\t(rtx_reader::read_mapping): ...member function.\n+\t(read_subst_mapping): Use rtx_reader_ptr for read_string call.\n+\t(read_rtx): Convert to...\n+\t(rtx_reader::read_rtx): ...member function.\n+\t(read_rtx_code): Convert to...\n+\t(rtx_reader::read_rtx_code): ...member function.\n+\t(read_rtx_operand): Convert to...\n+\t(rtx_reader::read_rtx_operand): ...member function.  Update for move\n+\tof string_obstack to a field.\n+\t(read_nested_rtx): Convert to..\n+\t(rtx_reader::read_nested_rtx): ...member function.\n+\t(read_rtx_variadic): Convert to..\n+\t(rtx_reader::read_rtx_variadic): ...member function.\n+\n 2016-10-18  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \t* tree-vrp.c (get_value_range): Check get_ptr_nonnull."}, {"sha": "ddce1357f1059569a4dc07f80dbde4bca7c08795", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "patch": "@@ -630,7 +630,7 @@ attr_string (const char *str, int len)\n   memcpy (new_str, str, len);\n   new_str[len] = '\\0';\n   attr_hash_add_string (hashcode, new_str);\n-  copy_md_ptr_loc (new_str, str);\n+  rtx_reader_ptr->copy_md_ptr_loc (new_str, str);\n \n   return new_str;\t\t\t/* Return the new string.  */\n }\n@@ -3157,7 +3157,7 @@ gen_attr (md_rtx_info *info)\n   if (GET_CODE (def) == DEFINE_ENUM_ATTR)\n     {\n       attr->enum_name = XSTR (def, 1);\n-      et = lookup_enum_type (XSTR (def, 1));\n+      et = rtx_reader_ptr->lookup_enum_type (XSTR (def, 1));\n       if (!et || !et->md_p)\n \terror_at (info->loc, \"No define_enum called `%s' defined\",\n \t\t  attr->name);\n@@ -3768,14 +3768,14 @@ write_test_expr (FILE *outf, rtx exp, unsigned int attrs_cached, int flags,\n       break;\n \n     case MATCH_TEST:\n-      fprint_c_condition (outf, XSTR (exp, 0));\n+      rtx_reader_ptr->fprint_c_condition (outf, XSTR (exp, 0));\n       if (flags & FLG_BITWISE)\n \tfprintf (outf, \" != 0\");\n       break;\n \n     /* A random C expression.  */\n     case SYMBOL_REF:\n-      fprint_c_condition (outf, XSTR (exp, 0));\n+      rtx_reader_ptr->fprint_c_condition (outf, XSTR (exp, 0));\n       break;\n \n     /* The address of the branch target.  */\n@@ -4365,7 +4365,7 @@ write_attr_value (FILE *outf, struct attr_desc *attr, rtx value)\n       break;\n \n     case SYMBOL_REF:\n-      fprint_c_condition (outf, XSTR (value, 0));\n+      rtx_reader_ptr->fprint_c_condition (outf, XSTR (value, 0));\n       break;\n \n     case ATTR:"}, {"sha": "63e078478f02fdf62ee6b007c37c74793e482563", "filename": "gcc/genconditions.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgenconditions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgenconditions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconditions.c?ref=b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "patch": "@@ -124,7 +124,7 @@ write_one_condition (void **slot, void * ARG_UNUSED (dummy))\n   const struct c_test *test = * (const struct c_test **) slot;\n   const char *p;\n \n-  print_md_ptr_loc (test->expr);\n+  rtx_reader_ptr->print_md_ptr_loc (test->expr);\n   fputs (\"  { \\\"\", stdout);\n   for (p = test->expr; *p; p++)\n     {\n@@ -139,9 +139,9 @@ write_one_condition (void **slot, void * ARG_UNUSED (dummy))\n     }\n \n   fputs (\"\\\",\\n    __builtin_constant_p \", stdout);\n-  print_c_condition (test->expr);\n+  rtx_reader_ptr->print_c_condition (test->expr);\n   fputs (\"\\n    ? (int) \", stdout);\n-  print_c_condition (test->expr);\n+  rtx_reader_ptr->print_c_condition (test->expr);\n   fputs (\"\\n    : -1 },\\n\", stdout);\n   return 1;\n }"}, {"sha": "bfc6d07bec459850cd898d2b9908fa4dcc1d2f7e", "filename": "gcc/genconstants.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgenconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgenconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconstants.c?ref=b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "patch": "@@ -28,6 +28,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"errors.h\"\n+#include \"statistics.h\"\n+#include \"vec.h\"\n #include \"read-md.h\"\n \n /* Called via traverse_md_constants; emit a #define for\n@@ -91,8 +93,8 @@ main (int argc, const char **argv)\n   puts (\"#ifndef GCC_INSN_CONSTANTS_H\");\n   puts (\"#define GCC_INSN_CONSTANTS_H\\n\");\n \n-  traverse_md_constants (print_md_constant, 0);\n-  traverse_enum_types (print_enum_type, 0);\n+  reader.traverse_md_constants (print_md_constant, 0);\n+  reader.traverse_enum_types (print_enum_type, 0);\n \n   puts (\"\\n#endif /* GCC_INSN_CONSTANTS_H */\");\n "}, {"sha": "3cf71c7c5c47c7428aff84090b3f317a686fae13", "filename": "gcc/genemit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "patch": "@@ -302,7 +302,7 @@ emit_c_code (const char *code, bool can_fail_p, const char *name)\n   printf (\"#define DONE return (_val = get_insns (),\"\n \t  \"end_sequence (), _val)\\n\");\n \n-  print_md_ptr_loc (code);\n+  rtx_reader_ptr->print_md_ptr_loc (code);\n   printf (\"%s\\n\", code);\n \n   printf (\"#undef DONE\\n\");"}, {"sha": "2dc98ce8805943ba94a6aee400ea9d8e901a7c87", "filename": "gcc/genenums.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgenenums.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgenenums.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenenums.c?ref=b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "patch": "@@ -21,6 +21,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"errors.h\"\n+#include \"statistics.h\"\n+#include \"vec.h\"\n #include \"read-md.h\"\n \n /* Called via traverse_enum_types.  Emit an enum definition for\n@@ -59,7 +61,7 @@ main (int argc, const char **argv)\n   puts (\"#include \\\"system.h\\\"\\n\");\n   puts (\"#include \\\"insn-constants.h\\\"\\n\");\n \n-  traverse_enum_types (print_enum_type, 0);\n+  reader.traverse_enum_types (print_enum_type, 0);\n \n   if (ferror (stdout) || fflush (stdout) || fclose (stdout))\n     return FATAL_EXIT_CODE;"}, {"sha": "f97020fd1f004a751fc858629ec845fc10b16844", "filename": "gcc/genmddeps.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgenmddeps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgenmddeps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmddeps.c?ref=b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "patch": "@@ -19,6 +19,8 @@\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"errors.h\"\n+#include \"statistics.h\"\n+#include \"vec.h\"\n #include \"read-md.h\"\n \n "}, {"sha": "fd36c0427feb8afa045566d83f0f63b0c2dba4d4", "filename": "gcc/genoutput.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "patch": "@@ -631,7 +631,7 @@ process_template (struct data *d, const char *template_code)\n       printf (\"output_%d (rtx *operands ATTRIBUTE_UNUSED, rtx_insn *insn ATTRIBUTE_UNUSED)\\n\",\n \t      d->code_number);\n       puts (\"{\");\n-      print_md_ptr_loc (template_code);\n+      rtx_reader_ptr->print_md_ptr_loc (template_code);\n       puts (template_code + 1);\n       puts (\"}\");\n     }"}, {"sha": "c5d597c9cb3b6d0e4a9eca79716f2c22fbdd3140", "filename": "gcc/genpreds.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "patch": "@@ -154,7 +154,7 @@ write_predicate_subfunction (struct pred_data *p)\n   printf (\"static inline int\\n\"\n \t  \"%s_1 (rtx op, machine_mode mode ATTRIBUTE_UNUSED)\\n\",\n \t  p->name);\n-  print_md_ptr_loc (p->c_block);\n+  rtx_reader_ptr->print_md_ptr_loc (p->c_block);\n   if (p->c_block[0] == '{')\n     fputs (p->c_block, stdout);\n   else\n@@ -538,7 +538,7 @@ write_predicate_expr (rtx exp)\n       break;\n \n     case MATCH_TEST:\n-      print_c_condition (XSTR (exp, 0));\n+      rtx_reader_ptr->print_c_condition (XSTR (exp, 0));\n       break;\n \n     default:"}, {"sha": "4277a9c920350060cf6053893ef29ba820159e08", "filename": "gcc/genrecog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "patch": "@@ -4659,7 +4659,7 @@ print_test (output_state *os, const rtx_test &test, bool is_param,\n       gcc_assert (!is_param && value == 1);\n       if (invert_p)\n \tprintf (\"!\");\n-      print_c_condition (test.u.string);\n+      rtx_reader_ptr->print_c_condition (test.u.string);\n       break;\n \n     case rtx_test::ACCEPT:"}, {"sha": "c49ad6f55b74891bbbec6067e54d45880f856243", "filename": "gcc/gensupport.c", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "patch": "@@ -551,8 +551,9 @@ process_rtx (rtx desc, file_location loc)\n \tsplit_cond = XSTR (desc, 4);\n \tif (split_cond[0] == '&' && split_cond[1] == '&')\n \t  {\n-\t    copy_md_ptr_loc (split_cond + 2, split_cond);\n-\t    split_cond = join_c_conditions (XSTR (desc, 2), split_cond + 2);\n+\t    rtx_reader_ptr->copy_md_ptr_loc (split_cond + 2, split_cond);\n+\t    split_cond = rtx_reader_ptr->join_c_conditions (XSTR (desc, 2),\n+\t\t\t\t\t\t\t    split_cond + 2);\n \t  }\n \tXSTR (split, 1) = split_cond;\n \tXVEC (split, 2) = XVEC (desc, 5);\n@@ -1262,8 +1263,8 @@ static const char *\n alter_test_for_insn (struct queue_elem *ce_elem,\n \t\t     struct queue_elem *insn_elem)\n {\n-  return join_c_conditions (XSTR (ce_elem->data, 1),\n-\t\t\t    XSTR (insn_elem->data, 2));\n+  return rtx_reader_ptr->join_c_conditions (XSTR (ce_elem->data, 1),\n+\t\t\t\t\t    XSTR (insn_elem->data, 2));\n }\n \n /* Modify VAL, which is an attribute expression for the \"enabled\" attribute,\n@@ -1871,8 +1872,9 @@ process_substs_on_one_elem (struct queue_elem *elem,\n \n       /* Recalculate condition, joining conditions from original and\n \t DEFINE_SUBST input patterns.  */\n-      XSTR (elem->data, 2) = join_c_conditions (XSTR (subst_elem->data, 2),\n-\t\t\t\t\t\tXSTR (elem->data, 2));\n+      XSTR (elem->data, 2)\n+\t= rtx_reader_ptr->join_c_conditions (XSTR (subst_elem->data, 2),\n+\t\t\t\t\t     XSTR (elem->data, 2));\n       /* Mark that subst was applied by changing attribute from \"yes\"\n \t to \"no\".  */\n       change_subst_attribute (elem, subst_elem, subst_false);\n@@ -2299,6 +2301,7 @@ gen_mnemonic_setattr (htab_t mnemonic_htab, rtx insn)\n   rtx set_attr;\n   char *attr_name;\n   rtvec new_vec;\n+  struct obstack *string_obstack = rtx_reader_ptr->get_string_obstack ();\n \n   template_code = XTMPL (insn, 3);\n \n@@ -2324,13 +2327,13 @@ gen_mnemonic_setattr (htab_t mnemonic_htab, rtx insn)\n \t  sp = ep + 1;\n \n       if (i > 0)\n-\tobstack_1grow (&string_obstack, ',');\n+\tobstack_1grow (string_obstack, ',');\n \n       while (cp < sp && ((*cp >= '0' && *cp <= '9')\n \t\t\t || (*cp >= 'a' && *cp <= 'z')))\n \n \t{\n-\t  obstack_1grow (&string_obstack, *cp);\n+\t  obstack_1grow (string_obstack, *cp);\n \t  cp++;\n \t  size++;\n \t}\n@@ -2341,7 +2344,7 @@ gen_mnemonic_setattr (htab_t mnemonic_htab, rtx insn)\n \t    {\n \t      /* Don't set a value if there are more than one\n \t\t instruction in the string.  */\n-\t      obstack_blank_fast (&string_obstack, -size);\n+\t      obstack_blank_fast (string_obstack, -size);\n \t      size = 0;\n \n \t      cp = sp;\n@@ -2350,22 +2353,22 @@ gen_mnemonic_setattr (htab_t mnemonic_htab, rtx insn)\n \t  cp++;\n \t}\n       if (size == 0)\n-\tobstack_1grow (&string_obstack, '*');\n+\tobstack_1grow (string_obstack, '*');\n       else\n \tadd_mnemonic_string (mnemonic_htab,\n-\t\t\t     (char *) obstack_next_free (&string_obstack) - size,\n+\t\t\t     (char *) obstack_next_free (string_obstack) - size,\n \t\t\t     size);\n       i++;\n     }\n \n   /* An insn definition might emit an empty string.  */\n-  if (obstack_object_size (&string_obstack) == 0)\n+  if (obstack_object_size (string_obstack) == 0)\n     return;\n \n-  obstack_1grow (&string_obstack, '\\0');\n+  obstack_1grow (string_obstack, '\\0');\n \n   set_attr = rtx_alloc (SET_ATTR);\n-  XSTR (set_attr, 1) = XOBFINISH (&string_obstack, char *);\n+  XSTR (set_attr, 1) = XOBFINISH (string_obstack, char *);\n   attr_name = XNEWVAR (char, strlen (MNEMONIC_ATTR_NAME) + 1);\n   strcpy (attr_name, MNEMONIC_ATTR_NAME);\n   XSTR (set_attr, 0) = attr_name;\n@@ -2388,8 +2391,10 @@ gen_mnemonic_setattr (htab_t mnemonic_htab, rtx insn)\n static int\n mnemonic_htab_callback (void **slot, void *info ATTRIBUTE_UNUSED)\n {\n-  obstack_grow (&string_obstack, (char*)*slot, strlen ((char*)*slot));\n-  obstack_1grow (&string_obstack, ',');\n+  struct obstack *string_obstack = rtx_reader_ptr->get_string_obstack ();\n+\n+  obstack_grow (string_obstack, (char*) *slot, strlen ((char*) *slot));\n+  obstack_1grow (string_obstack, ',');\n   return 1;\n }\n \n@@ -2407,6 +2412,7 @@ gen_mnemonic_attr (void)\n   htab_t mnemonic_htab;\n   const char *str, *p;\n   int i;\n+  struct obstack *string_obstack = rtx_reader_ptr->get_string_obstack ();\n \n   if (have_error)\n     return;\n@@ -2470,8 +2476,8 @@ gen_mnemonic_attr (void)\n   htab_traverse (mnemonic_htab, mnemonic_htab_callback, NULL);\n \n   /* Replace the last ',' with the zero end character.  */\n-  *((char *)obstack_next_free (&string_obstack) - 1) = '\\0';\n-  XSTR (mnemonic_attr, 1) = XOBFINISH (&string_obstack, char *);\n+  *((char *) obstack_next_free (string_obstack) - 1) = '\\0';\n+  XSTR (mnemonic_attr, 1) = XOBFINISH (string_obstack, char *);\n }\n \n /* Check if there are DEFINE_ATTRs with the same name.  */"}, {"sha": "cf4b16634650dc0b43b4eaa39dfbd2689dc912af", "filename": "gcc/gentarget-def.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgentarget-def.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fgentarget-def.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgentarget-def.c?ref=b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "patch": "@@ -191,7 +191,7 @@ def_target_insn (const char *name, const char *prototype)\n \t      printf (\"target_have_%s (void)\\n\", name);\n \t      printf (\"{\\n\");\n \t      printf (\"  return \");\n-\t      print_c_condition (test);\n+\t      rtx_reader_ptr->print_c_condition (test);\n \t      printf (\";\\n\");\n \t      printf (\"}\\n\");\n \t    }"}, {"sha": "6fe26000eb5db5995b59e0ba5e5f77bcefa970b3", "filename": "gcc/read-md.c", "status": "modified", "additions": 94, "deletions": 101, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fread-md.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fread-md.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.c?ref=b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "patch": "@@ -21,6 +21,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"errors.h\"\n+#include \"statistics.h\"\n+#include \"vec.h\"\n #include \"read-md.h\"\n \n /* Associates PTR (which can be a string, etc.) with the file location\n@@ -31,25 +33,6 @@ struct ptr_loc {\n   int lineno;\n };\n \n-/* Obstack used for allocating MD strings.  */\n-struct obstack string_obstack;\n-\n-/* A table of ptr_locs, hashed on the PTR field.  */\n-static htab_t ptr_locs;\n-\n-/* An obstack for the above.  Plain xmalloc is a bit heavyweight for a\n-   small structure like ptr_loc.  */\n-static struct obstack ptr_loc_obstack;\n-\n-/* A hash table of triples (A, B, C), where each of A, B and C is a condition\n-   and A is equivalent to \"B && C\".  This is used to keep track of the source\n-   of conditions that are made up of separate MD strings (such as the split\n-   condition of a define_insn_and_split).  */\n-static htab_t joined_conditions;\n-\n-/* An obstack for allocating joined_conditions entries.  */\n-static struct obstack joined_conditions_obstack;\n-\n /* This callback will be invoked whenever an md include directive is\n    processed.  To be used for creation of the dependency file.  */\n void (*include_callback) (const char *);\n@@ -58,13 +41,6 @@ void (*include_callback) (const char *);\n \n rtx_reader *rtx_reader_ptr;\n \n-/* A table of md_constant structures, hashed by name.  Null if no\n-   constant expansion should occur.  */\n-static htab_t md_constants;\n-\n-/* A table of enum_type structures, hashed by name.  */\n-static htab_t enum_types;\n-\n /* Given an object that starts with a char * name field, return a hash\n    code for its name.  */\n \n@@ -102,32 +78,32 @@ leading_ptr_eq_p (const void *def1, const void *def2)\n \n /* Associate PTR with the file position given by FILENAME and LINENO.  */\n \n-static void\n-set_md_ptr_loc (const void *ptr, const char *filename, int lineno)\n+void\n+rtx_reader::set_md_ptr_loc (const void *ptr, const char *filename, int lineno)\n {\n   struct ptr_loc *loc;\n \n-  loc = (struct ptr_loc *) obstack_alloc (&ptr_loc_obstack,\n+  loc = (struct ptr_loc *) obstack_alloc (&m_ptr_loc_obstack,\n \t\t\t\t\t  sizeof (struct ptr_loc));\n   loc->ptr = ptr;\n   loc->filename = filename;\n   loc->lineno = lineno;\n-  *htab_find_slot (ptr_locs, loc, INSERT) = loc;\n+  *htab_find_slot (m_ptr_locs, loc, INSERT) = loc;\n }\n \n /* Return the position associated with pointer PTR.  Return null if no\n    position was set.  */\n \n-static const struct ptr_loc *\n-get_md_ptr_loc (const void *ptr)\n+const struct ptr_loc *\n+rtx_reader::get_md_ptr_loc (const void *ptr)\n {\n-  return (const struct ptr_loc *) htab_find (ptr_locs, &ptr);\n+  return (const struct ptr_loc *) htab_find (m_ptr_locs, &ptr);\n }\n \n /* Associate NEW_PTR with the same file position as OLD_PTR.  */\n \n void\n-copy_md_ptr_loc (const void *new_ptr, const void *old_ptr)\n+rtx_reader::copy_md_ptr_loc (const void *new_ptr, const void *old_ptr)\n {\n   const struct ptr_loc *loc = get_md_ptr_loc (old_ptr);\n   if (loc != 0)\n@@ -138,7 +114,7 @@ copy_md_ptr_loc (const void *new_ptr, const void *old_ptr)\n    directive for it to OUTF.  */\n \n void\n-fprint_md_ptr_loc (FILE *outf, const void *ptr)\n+rtx_reader::fprint_md_ptr_loc (FILE *outf, const void *ptr)\n {\n   const struct ptr_loc *loc = get_md_ptr_loc (ptr);\n   if (loc != 0)\n@@ -147,7 +123,7 @@ fprint_md_ptr_loc (FILE *outf, const void *ptr)\n \n /* Special fprint_md_ptr_loc for writing to STDOUT.  */\n void\n-print_md_ptr_loc (const void *ptr)\n+rtx_reader::print_md_ptr_loc (const void *ptr)\n {\n   fprint_md_ptr_loc (stdout, ptr);\n }\n@@ -156,7 +132,7 @@ print_md_ptr_loc (const void *ptr)\n    may be null or empty.  */\n \n const char *\n-join_c_conditions (const char *cond1, const char *cond2)\n+rtx_reader::join_c_conditions (const char *cond1, const char *cond2)\n {\n   char *result;\n   const void **entry;\n@@ -171,11 +147,11 @@ join_c_conditions (const char *cond1, const char *cond2)\n     return cond1;\n \n   result = concat (\"(\", cond1, \") && (\", cond2, \")\", NULL);\n-  obstack_ptr_grow (&joined_conditions_obstack, result);\n-  obstack_ptr_grow (&joined_conditions_obstack, cond1);\n-  obstack_ptr_grow (&joined_conditions_obstack, cond2);\n-  entry = XOBFINISH (&joined_conditions_obstack, const void **);\n-  *htab_find_slot (joined_conditions, entry, INSERT) = entry;\n+  obstack_ptr_grow (&m_joined_conditions_obstack, result);\n+  obstack_ptr_grow (&m_joined_conditions_obstack, cond1);\n+  obstack_ptr_grow (&m_joined_conditions_obstack, cond2);\n+  entry = XOBFINISH (&m_joined_conditions_obstack, const void **);\n+  *htab_find_slot (m_joined_conditions, entry, INSERT) = entry;\n   return result;\n }\n \n@@ -185,9 +161,9 @@ join_c_conditions (const char *cond1, const char *cond2)\n    directive for COND if its original file position is known.  */\n \n void\n-fprint_c_condition (FILE *outf, const char *cond)\n+rtx_reader::fprint_c_condition (FILE *outf, const char *cond)\n {\n-  const char **halves = (const char **) htab_find (joined_conditions, &cond);\n+  const char **halves = (const char **) htab_find (m_joined_conditions, &cond);\n   if (halves != 0)\n     {\n       fprintf (outf, \"(\");\n@@ -207,7 +183,7 @@ fprint_c_condition (FILE *outf, const char *cond)\n /* Special fprint_c_condition for writing to STDOUT.  */\n \n void\n-print_c_condition (const char *cond)\n+rtx_reader::print_c_condition (const char *cond)\n {\n   fprint_c_condition (stdout, cond);\n }\n@@ -414,7 +390,7 @@ rtx_reader::unread_char (int ch)\n    punctuation chars of rtx printed syntax.  */\n \n void\n-read_name (struct md_name *name)\n+rtx_reader::read_name (struct md_name *name)\n {\n   int c;\n   size_t i;\n@@ -458,7 +434,7 @@ read_name (struct md_name *name)\n   name->buffer[i] = 0;\n   name->string = name->buffer;\n \n-  if (md_constants)\n+  if (m_md_constants)\n     {\n       /* Do constant expansion.  */\n       struct md_constant *def;\n@@ -468,7 +444,7 @@ read_name (struct md_name *name)\n \t  struct md_constant tmp_def;\n \n \t  tmp_def.name = name->string;\n-\t  def = (struct md_constant *) htab_find (md_constants, &tmp_def);\n+\t  def = (struct md_constant *) htab_find (m_md_constants, &tmp_def);\n \t  if (def)\n \t    name->string = def->value;\n \t}\n@@ -479,8 +455,8 @@ read_name (struct md_name *name)\n /* Subroutine of the string readers.  Handles backslash escapes.\n    Caller has read the backslash, but not placed it into the obstack.  */\n \n-static void\n-read_escape (void)\n+void\n+rtx_reader::read_escape ()\n {\n   int c = read_char ();\n \n@@ -508,32 +484,32 @@ read_escape (void)\n     case 'a': case 'b': case 'f': case 'n': case 'r': case 't': case 'v':\n     case '0': case '1': case '2': case '3': case '4': case '5': case '6':\n     case '7': case 'x':\n-      obstack_1grow (&string_obstack, '\\\\');\n+      obstack_1grow (&m_string_obstack, '\\\\');\n       break;\n \n       /* \\; makes stuff for a C string constant containing\n \t newline and tab.  */\n     case ';':\n-      obstack_grow (&string_obstack, \"\\\\n\\\\t\", 4);\n+      obstack_grow (&m_string_obstack, \"\\\\n\\\\t\", 4);\n       return;\n \n       /* pass anything else through, but issue a warning.  */\n     default:\n       fprintf (stderr, \"%s:%d: warning: unrecognized escape \\\\%c\\n\",\n-\t       rtx_reader_ptr->get_filename (), rtx_reader_ptr->get_lineno (),\n+\t       get_filename (), get_lineno (),\n \t       c);\n-      obstack_1grow (&string_obstack, '\\\\');\n+      obstack_1grow (&m_string_obstack, '\\\\');\n       break;\n     }\n \n-  obstack_1grow (&string_obstack, c);\n+  obstack_1grow (&m_string_obstack, c);\n }\n \n /* Read a double-quoted string onto the obstack.  Caller has scanned\n    the leading quote.  */\n \n char *\n-read_quoted_string (void)\n+rtx_reader::read_quoted_string ()\n {\n   int c;\n \n@@ -548,25 +524,25 @@ read_quoted_string (void)\n       else if (c == '\"' || c == EOF)\n \tbreak;\n \n-      obstack_1grow (&string_obstack, c);\n+      obstack_1grow (&m_string_obstack, c);\n     }\n \n-  obstack_1grow (&string_obstack, 0);\n-  return XOBFINISH (&string_obstack, char *);\n+  obstack_1grow (&m_string_obstack, 0);\n+  return XOBFINISH (&m_string_obstack, char *);\n }\n \n /* Read a braced string (a la Tcl) onto the string obstack.  Caller\n    has scanned the leading brace.  Note that unlike quoted strings,\n    the outermost braces _are_ included in the string constant.  */\n \n-static char *\n-read_braced_string (void)\n+char *\n+rtx_reader::read_braced_string ()\n {\n   int c;\n   int brace_depth = 1;  /* caller-processed */\n-  unsigned long starting_read_md_lineno = rtx_reader_ptr->get_lineno ();\n+  unsigned long starting_read_md_lineno = get_lineno ();\n \n-  obstack_1grow (&string_obstack, '{');\n+  obstack_1grow (&m_string_obstack, '{');\n   while (brace_depth)\n     {\n       c = read_char (); /* Read the string  */\n@@ -585,19 +561,19 @@ read_braced_string (void)\n \t  (\"missing closing } for opening brace on line %lu\",\n \t   starting_read_md_lineno);\n \n-      obstack_1grow (&string_obstack, c);\n+      obstack_1grow (&m_string_obstack, c);\n     }\n \n-  obstack_1grow (&string_obstack, 0);\n-  return XOBFINISH (&string_obstack, char *);\n+  obstack_1grow (&m_string_obstack, 0);\n+  return XOBFINISH (&m_string_obstack, char *);\n }\n \n /* Read some kind of string constant.  This is the high-level routine\n    used by read_rtx.  It handles surrounding parentheses, leading star,\n    and dispatch to the appropriate string constant reader.  */\n \n char *\n-read_string (int star_if_braced)\n+rtx_reader::read_string (int star_if_braced)\n {\n   char *stringbuf;\n   int saw_paren = 0;\n@@ -610,13 +586,13 @@ read_string (int star_if_braced)\n       c = read_skip_spaces ();\n     }\n \n-  old_lineno = rtx_reader_ptr->get_lineno ();\n+  old_lineno = get_lineno ();\n   if (c == '\"')\n     stringbuf = read_quoted_string ();\n   else if (c == '{')\n     {\n       if (star_if_braced)\n-\tobstack_1grow (&string_obstack, '*');\n+\tobstack_1grow (&m_string_obstack, '*');\n       stringbuf = read_braced_string ();\n     }\n   else\n@@ -625,15 +601,15 @@ read_string (int star_if_braced)\n   if (saw_paren)\n     require_char_ws (')');\n \n-  set_md_ptr_loc (stringbuf, rtx_reader_ptr->get_filename (), old_lineno);\n+  set_md_ptr_loc (stringbuf, get_filename (), old_lineno);\n   return stringbuf;\n }\n \n /* Skip the rest of a construct that started at line LINENO and that\n    is currently nested by DEPTH levels of parentheses.  */\n \n-static void\n-read_skip_construct (int depth, file_location loc)\n+void\n+rtx_reader::read_skip_construct (int depth, file_location loc)\n {\n   struct md_name name;\n   int c;\n@@ -774,17 +750,17 @@ add_constant (htab_t defs, char *name, char *value,\n /* Process a define_constants directive, starting with the optional space\n    after the \"define_constants\".  */\n \n-static void\n-handle_constants (void)\n+void\n+rtx_reader::handle_constants ()\n {\n   int c;\n   htab_t defs;\n \n   require_char_ws ('[');\n \n   /* Disable constant expansion during definition processing.  */\n-  defs = md_constants;\n-  md_constants = 0;\n+  defs = m_md_constants;\n+  m_md_constants = 0;\n   while ( (c = read_skip_spaces ()) != ']')\n     {\n       struct md_name name, value;\n@@ -798,17 +774,17 @@ handle_constants (void)\n \n       require_char_ws (')');\n     }\n-  md_constants = defs;\n+  m_md_constants = defs;\n }\n \n /* For every constant definition, call CALLBACK with two arguments:\n    a pointer a pointer to the constant definition and INFO.\n    Stop when CALLBACK returns zero.  */\n \n void\n-traverse_md_constants (htab_trav callback, void *info)\n+rtx_reader::traverse_md_constants (htab_trav callback, void *info)\n {\n-  htab_traverse (md_constants, callback, info);\n+  htab_traverse (get_md_constants (), callback, info);\n }\n \n /* Return a malloc()ed decimal string that represents number NUMBER.  */\n@@ -828,8 +804,8 @@ md_decimal_string (int number)\n    number on which the directive started and MD_P is true if the\n    directive is a define_enum rather than a define_c_enum.  */\n \n-static void\n-handle_enum (file_location loc, bool md_p)\n+void\n+rtx_reader::handle_enum (file_location loc, bool md_p)\n {\n   char *enum_name, *value_name;\n   struct md_name name;\n@@ -839,7 +815,7 @@ handle_enum (file_location loc, bool md_p)\n   int c;\n \n   enum_name = read_string (false);\n-  slot = htab_find_slot (enum_types, &enum_name, INSERT);\n+  slot = htab_find_slot (m_enum_types, &enum_name, INSERT);\n   if (*slot)\n     {\n       def = (struct enum_type *) *slot;\n@@ -883,7 +859,7 @@ handle_enum (file_location loc, bool md_p)\n \t  value_name = xstrdup (name.string);\n \t  ev->name = value_name;\n \t}\n-      ev->def = add_constant (md_constants, value_name,\n+      ev->def = add_constant (get_md_constants (), value_name,\n \t\t\t      md_decimal_string (def->num_values), def);\n \n       *def->tail_ptr = ev;\n@@ -895,19 +871,19 @@ handle_enum (file_location loc, bool md_p)\n /* Try to find the definition of the given enum.  Return null on failure.  */\n \n struct enum_type *\n-lookup_enum_type (const char *name)\n+rtx_reader::lookup_enum_type (const char *name)\n {\n-  return (struct enum_type *) htab_find (enum_types, &name);\n+  return (struct enum_type *) htab_find (m_enum_types, &name);\n }\n \n /* For every enum definition, call CALLBACK with two arguments:\n    a pointer to the constant definition and INFO.  Stop when CALLBACK\n    returns zero.  */\n \n void\n-traverse_enum_types (htab_trav callback, void *info)\n+rtx_reader::traverse_enum_types (htab_trav callback, void *info)\n {\n-  htab_traverse (enum_types, callback, info);\n+  htab_traverse (m_enum_types, callback, info);\n }\n \n \n@@ -925,12 +901,43 @@ rtx_reader::rtx_reader ()\n {\n   /* Set the global singleton pointer.  */\n   rtx_reader_ptr = this;\n+\n+  obstack_init (&m_string_obstack);\n+\n+  m_ptr_locs = htab_create (161, leading_ptr_hash, leading_ptr_eq_p, 0);\n+  obstack_init (&m_ptr_loc_obstack);\n+\n+  m_joined_conditions = htab_create (161, leading_ptr_hash, leading_ptr_eq_p, 0);\n+  obstack_init (&m_joined_conditions_obstack);\n+\n+  m_md_constants = htab_create (31, leading_string_hash,\n+\t\t\t\tleading_string_eq_p, (htab_del) 0);\n+\n+  m_enum_types = htab_create (31, leading_string_hash,\n+\t\t\t      leading_string_eq_p, (htab_del) 0);\n+\n+  /* Unlock the stdio streams.  */\n+  unlock_std_streams ();\n }\n \n /* rtx_reader's destructor.  */\n \n rtx_reader::~rtx_reader ()\n {\n+  free (m_base_dir);\n+\n+  htab_delete (m_enum_types);\n+\n+  htab_delete (m_md_constants);\n+\n+  obstack_free (&m_joined_conditions_obstack, NULL);\n+  htab_delete (m_joined_conditions);\n+\n+  obstack_free (&m_ptr_loc_obstack, NULL);\n+  htab_delete (m_ptr_locs);\n+\n+  obstack_free (&m_string_obstack, NULL);\n+\n   /* Clear the global singleton pointer.  */\n   rtx_reader_ptr = NULL;\n }\n@@ -1105,20 +1112,6 @@ rtx_reader::read_md_files (int argc, const char **argv,\n   bool already_read_stdin;\n   int num_files;\n \n-  /* Initialize global data.  */\n-  obstack_init (&string_obstack);\n-  ptr_locs = htab_create (161, leading_ptr_hash, leading_ptr_eq_p, 0);\n-  obstack_init (&ptr_loc_obstack);\n-  joined_conditions = htab_create (161, leading_ptr_hash, leading_ptr_eq_p, 0);\n-  obstack_init (&joined_conditions_obstack);\n-  md_constants = htab_create (31, leading_string_hash,\n-\t\t\t      leading_string_eq_p, (htab_del) 0);\n-  enum_types = htab_create (31, leading_string_hash,\n-\t\t\t    leading_string_eq_p, (htab_del) 0);\n-\n-  /* Unlock the stdio streams.  */\n-  unlock_std_streams ();\n-\n   /* First we loop over all the options.  */\n   for (i = 1; i < argc; i++)\n     if (argv[i][0] == '-')"}, {"sha": "996b514976f190f604e93340c96c5e3f20881968", "filename": "gcc/read-md.h", "status": "modified", "additions": 66, "deletions": 10, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fread-md.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fread-md.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.h?ref=b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "patch": "@@ -107,14 +107,54 @@ class rtx_reader\n \n   file_location get_current_location () const;\n \n+  /* Defined in read-md.c.  */\n   int read_char (void);\n   void unread_char (int ch);\n+  void read_name (struct md_name *name);\n+  void read_escape ();\n+  char *read_quoted_string ();\n+  char *read_braced_string ();\n+  char *read_string (int star_if_braced);\n+  void read_skip_construct (int depth, file_location loc);\n+\n+  void set_md_ptr_loc (const void *ptr, const char *filename, int lineno);\n+  const struct ptr_loc *get_md_ptr_loc (const void *ptr);\n+  void copy_md_ptr_loc (const void *new_ptr, const void *old_ptr);\n+  void fprint_md_ptr_loc (FILE *outf, const void *ptr);\n+  void print_md_ptr_loc (const void *ptr);\n+\n+  struct enum_type *lookup_enum_type (const char *name);\n+  void traverse_enum_types (htab_trav callback, void *info);\n+\n+  void handle_constants ();\n+  void traverse_md_constants (htab_trav callback, void *info);\n+  void handle_enum (file_location loc, bool md_p);\n+\n+  const char *join_c_conditions (const char *cond1, const char *cond2);\n+  void fprint_c_condition (FILE *outf, const char *cond);\n+  void print_c_condition (const char *cond);\n+\n+  /* Defined in read-rtl.c.  */\n+  const char *apply_iterator_to_string (const char *string);\n+  rtx copy_rtx_for_iterators (rtx original);\n+  void read_conditions ();\n+  void record_potential_iterator_use (struct iterator_group *group,\n+\t\t\t\t      void *ptr, const char *name);\n+  struct mapping *read_mapping (struct iterator_group *group, htab_t table);\n+  bool read_rtx (const char *rtx_name, vec<rtx> *rtxen);\n+  rtx read_rtx_code (const char *code_name);\n+  void read_rtx_operand (rtx return_rtx, int idx);\n+  rtx read_nested_rtx ();\n+  rtx read_rtx_variadic (rtx form);\n \n   const char *get_top_level_filename () const { return m_toplevel_fname; }\n   const char *get_filename () const { return m_read_md_filename; }\n   int get_lineno () const { return m_read_md_lineno; }\n   int get_colno () const { return m_read_md_colno; }\n \n+  struct obstack *get_string_obstack () { return &m_string_obstack; }\n+  htab_t get_md_constants () { return m_md_constants; }\n+\n  private:\n   /* A singly-linked list of filenames.  */\n   struct file_name_list {\n@@ -159,6 +199,32 @@ class rtx_reader\n \n   /* A pointer to the null terminator of the md include chain.  */\n   file_name_list **m_last_dir_md_include_ptr;\n+\n+  /* Obstack used for allocating MD strings.  */\n+  struct obstack m_string_obstack;\n+\n+  /* A table of ptr_locs, hashed on the PTR field.  */\n+  htab_t m_ptr_locs;\n+\n+  /* An obstack for the above.  Plain xmalloc is a bit heavyweight for a\n+     small structure like ptr_loc.  */\n+  struct obstack m_ptr_loc_obstack;\n+\n+  /* A hash table of triples (A, B, C), where each of A, B and C is a condition\n+     and A is equivalent to \"B && C\".  This is used to keep track of the source\n+     of conditions that are made up of separate MD strings (such as the split\n+     condition of a define_insn_and_split).  */\n+  htab_t m_joined_conditions;\n+\n+  /* An obstack for allocating joined_conditions entries.  */\n+  struct obstack m_joined_conditions_obstack;\n+\n+  /* A table of md_constant structures, hashed by name.  Null if no\n+     constant expansion should occur.  */\n+  htab_t m_md_constants;\n+\n+  /* A table of enum_type structures, hashed by name.  */\n+  htab_t m_enum_types;\n };\n \n /* Global singleton.  */\n@@ -175,7 +241,6 @@ class noop_reader : public rtx_reader\n   void handle_unknown_directive (file_location, const char *);\n };\n \n-extern struct obstack string_obstack;\n extern void (*include_callback) (const char *);\n \n /* Read the next character from the MD file.  */\n@@ -196,12 +261,7 @@ unread_char (int ch)\n \n extern hashval_t leading_string_hash (const void *);\n extern int leading_string_eq_p (const void *, const void *);\n-extern void copy_md_ptr_loc (const void *, const void *);\n-extern void print_md_ptr_loc (const void *);\n-extern void fprint_md_ptr_loc (FILE *, const void *);\n extern const char *join_c_conditions (const char *, const char *);\n-extern void print_c_condition (const char *);\n-extern void fprint_c_condition (FILE *, const char *);\n extern void message_at (file_location, const char *, ...) ATTRIBUTE_PRINTF_2;\n extern void error_at (file_location, const char *, ...) ATTRIBUTE_PRINTF_2;\n extern void fatal_at (file_location, const char *, ...) ATTRIBUTE_PRINTF_2;\n@@ -210,13 +270,9 @@ extern void fatal_with_file_and_line (const char *, ...)\n extern void fatal_expected_char (int, int) ATTRIBUTE_NORETURN;\n extern int read_skip_spaces (void);\n extern void require_char_ws (char expected);\n-extern void read_name (struct md_name *);\n-extern char *read_quoted_string (void);\n-extern char *read_string (int);\n extern int n_comma_elts (const char *);\n extern const char *scan_comma_elt (const char **);\n extern void upcase_string (char *);\n-extern void traverse_md_constants (htab_trav, void *);\n extern void traverse_enum_types (htab_trav, void *);\n extern struct enum_type *lookup_enum_type (const char *);\n "}, {"sha": "7a2021a3a23c016e2e4948ce64ab915bd6db5fc7", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78027d1a3f9a8fdf3386e24dcfd6679006dd154/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=b78027d1a3f9a8fdf3386e24dcfd6679006dd154", "patch": "@@ -106,10 +106,6 @@ htab_t subst_attr_to_iter_map = NULL;\n const char *current_iterator_name;\n \n static void validate_const_int (const char *);\n-static rtx read_rtx_code (const char *);\n-static void read_rtx_operand (rtx, int);\n-static rtx read_nested_rtx (void);\n-static rtx read_rtx_variadic (rtx);\n \n /* The mode and code iterator structures.  */\n static struct iterator_group modes, codes, ints, substs;\n@@ -329,8 +325,8 @@ map_attr_string (const char *p)\n /* Apply the current iterator values to STRING.  Return the new string\n    if any changes were needed, otherwise return STRING itself.  */\n \n-static const char *\n-apply_iterator_to_string (const char *string)\n+const char *\n+rtx_reader::apply_iterator_to_string (const char *string)\n {\n   char *base, *copy, *p, *start, *end;\n   struct map_value *v;\n@@ -351,14 +347,14 @@ apply_iterator_to_string (const char *string)\n \n       /* Add everything between the last copied byte and the '<',\n \t then add in the attribute value.  */\n-      obstack_grow (&string_obstack, base, start - base);\n-      obstack_grow (&string_obstack, v->string, strlen (v->string));\n+      obstack_grow (&m_string_obstack, base, start - base);\n+      obstack_grow (&m_string_obstack, v->string, strlen (v->string));\n       base = end + 1;\n     }\n   if (base != copy)\n     {\n-      obstack_grow (&string_obstack, base, strlen (base) + 1);\n-      copy = XOBFINISH (&string_obstack, char *);\n+      obstack_grow (&m_string_obstack, base, strlen (base) + 1);\n+      copy = XOBFINISH (&m_string_obstack, char *);\n       copy_md_ptr_loc (copy, string);\n       return copy;\n     }\n@@ -368,8 +364,8 @@ apply_iterator_to_string (const char *string)\n /* Return a deep copy of X, substituting the current iterator\n    values into any strings.  */\n \n-static rtx\n-copy_rtx_for_iterators (rtx original)\n+rtx\n+rtx_reader::copy_rtx_for_iterators (rtx original)\n {\n   const char *format_ptr, *p;\n   int i, j;\n@@ -428,7 +424,7 @@ add_condition_to_string (const char *original, const char *extra)\n {\n   if (original != 0 && original[0] == '&' && original[1] == '&')\n     return original;\n-  return join_c_conditions (original, extra);\n+  return rtx_reader_ptr->join_c_conditions (original, extra);\n }\n \n /* Like add_condition, but applied to all conditions in rtx X.  */\n@@ -543,10 +539,10 @@ apply_iterators (rtx original, vec<rtx> *queue)\n \t    continue;\n \t  v = iuse->iterator->current_value;\n \t  iuse->iterator->group->apply_iterator (iuse->ptr, v->number);\n-\t  condition = join_c_conditions (condition, v->string);\n+\t  condition = rtx_reader_ptr->join_c_conditions (condition, v->string);\n \t}\n       apply_attribute_uses ();\n-      x = copy_rtx_for_iterators (original);\n+      x = rtx_reader_ptr->copy_rtx_for_iterators (original);\n       add_condition_to_rtx (x, condition);\n \n       /* We apply subst iterator after RTL-template is copied, as during\n@@ -738,8 +734,8 @@ atoll (const char *p)\n    generated by (the program generated by) genconditions.c, and\n    slipped in at the beginning of the sequence of MD files read by\n    most of the other generators.  */\n-static void\n-read_conditions (void)\n+void\n+rtx_reader::read_conditions ()\n {\n   int c;\n \n@@ -837,9 +833,9 @@ record_attribute_use (struct iterator_group *group, void *ptr,\n    for group GROUP.  PTR is the value to pass to GROUP's apply_iterator\n    callback.  */\n \n-static void\n-record_potential_iterator_use (struct iterator_group *group, void *ptr,\n-\t\t\t       const char *name)\n+void\n+rtx_reader::record_potential_iterator_use (struct iterator_group *group,\n+\t\t\t\t\t   void *ptr, const char *name)\n {\n   struct mapping *m;\n   size_t len;\n@@ -849,8 +845,8 @@ record_potential_iterator_use (struct iterator_group *group, void *ptr,\n     {\n       /* Copy the attribute string into permanent storage, without the\n \t angle brackets around it.  */\n-      obstack_grow0 (&string_obstack, name + 1, len - 2);\n-      record_attribute_use (group, ptr, XOBFINISH (&string_obstack, char *));\n+      obstack_grow0 (&m_string_obstack, name + 1, len - 2);\n+      record_attribute_use (group, ptr, XOBFINISH (&m_string_obstack, char *));\n     }\n   else\n     {\n@@ -872,8 +868,8 @@ record_potential_iterator_use (struct iterator_group *group, void *ptr,\n    Represent the declaration as a \"mapping\" structure; add it to TABLE\n    (which belongs to GROUP) and return it.  */\n \n-static struct mapping *\n-read_mapping (struct iterator_group *group, htab_t table)\n+struct mapping *\n+rtx_reader::read_mapping (struct iterator_group *group, htab_t table)\n {\n   struct md_name name;\n   struct mapping *m;\n@@ -974,7 +970,7 @@ read_subst_mapping (htab_t subst_iters_table, htab_t subst_attrs_table,\n   int i;\n \n   for (i = 0; i < 4; i++)\n-    attr_operands[i] = read_string (false);\n+    attr_operands[i] = rtx_reader_ptr->read_string (false);\n \n   add_define_subst_attr (attr_operands, queue);\n \n@@ -1019,7 +1015,7 @@ check_code_iterator (struct mapping *iterator)\n    store the list of rtxes as an EXPR_LIST in *X.  */\n \n bool\n-read_rtx (const char *rtx_name, vec<rtx> *rtxen)\n+rtx_reader::read_rtx (const char *rtx_name, vec<rtx> *rtxen)\n {\n   static bool initialized = false;\n \n@@ -1087,8 +1083,8 @@ read_rtx (const char *rtx_name, vec<rtx> *rtxen)\n    either an rtx code or a code iterator.  Parse the rest of the rtx and\n    return it.  */\n \n-static rtx\n-read_rtx_code (const char *code_name)\n+rtx\n+rtx_reader::read_rtx_code (const char *code_name)\n {\n   RTX_CODE code;\n   struct mapping *iterator;\n@@ -1200,8 +1196,8 @@ read_rtx_code (const char *code_name)\n    based on the corresponding format character within GET_RTX_FORMAT\n    for the GET_CODE (RETURN_RTX).  */\n \n-static void\n-read_rtx_operand (rtx return_rtx, int idx)\n+void\n+rtx_reader::read_rtx_operand (rtx return_rtx, int idx)\n {\n   RTX_CODE code = GET_CODE (return_rtx);\n   const char *format_ptr = GET_RTX_FORMAT (code);\n@@ -1304,17 +1300,17 @@ read_rtx_operand (rtx return_rtx, int idx)\n \t\t|| GET_CODE (return_rtx) == DEFINE_INSN_AND_SPLIT))\n \t  {\n \t    char line_name[20];\n-\t    const char *read_md_filename = rtx_reader_ptr->get_filename ();\n+\t    const char *read_md_filename = get_filename ();\n \t    const char *fn = (read_md_filename ? read_md_filename : \"rtx\");\n \t    const char *slash;\n \t    for (slash = fn; *slash; slash ++)\n \t      if (*slash == '/' || *slash == '\\\\' || *slash == ':')\n \t\tfn = slash + 1;\n-\t    obstack_1grow (&string_obstack, '*');\n-\t    obstack_grow (&string_obstack, fn, strlen (fn));\n-\t    sprintf (line_name, \":%d\", rtx_reader_ptr->get_lineno ());\n-\t    obstack_grow (&string_obstack, line_name, strlen (line_name)+1);\n-\t    stringbuf = XOBFINISH (&string_obstack, char *);\n+\t    obstack_1grow (&m_string_obstack, '*');\n+\t    obstack_grow (&m_string_obstack, fn, strlen (fn));\n+\t    sprintf (line_name, \":%d\", get_lineno ());\n+\t    obstack_grow (&m_string_obstack, line_name, strlen (line_name)+1);\n+\t    stringbuf = XOBFINISH (&m_string_obstack, char *);\n \t  }\n \n \t/* Find attr-names in the string.  */\n@@ -1402,8 +1398,8 @@ read_rtx_operand (rtx return_rtx, int idx)\n \n /* Read a nested rtx construct from the MD file and return it.  */\n \n-static rtx\n-read_nested_rtx (void)\n+rtx\n+rtx_reader::read_nested_rtx ()\n {\n   struct md_name name;\n   rtx return_rtx;\n@@ -1427,8 +1423,8 @@ read_nested_rtx (void)\n    When called, FORM is (thing x1 x2), and the file position\n    is just past the leading parenthesis of x3.  Only works\n    for THINGs which are dyadic expressions, e.g. AND, IOR.  */\n-static rtx\n-read_rtx_variadic (rtx form)\n+rtx\n+rtx_reader::read_rtx_variadic (rtx form)\n {\n   char c = '(';\n   rtx p = form, q;"}]}