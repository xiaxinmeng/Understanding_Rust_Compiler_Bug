{"sha": "57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdlODRmMTg0MGMzZGEyYzVjNzNkNWMyZjgxYTliOTIyOTU3YTI3Yg==", "commit": {"author": {"name": "Adrian Straetling", "email": "straetling@de.ibm.com", "date": "2005-06-28T19:56:23Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2005-06-28T19:56:23Z"}, "message": "builtins.c: (expand_builtin_memset): Rewrite to support 'set_storage_via_setmem'.\n\n2006-06-28  Adrian Straetling  <straetling@de.ibm.com>\n\n\t* builtins.c: (expand_builtin_memset): Rewrite to support\n\t'set_storage_via_setmem'.\n\t* expr.c: (enum insn_code setmem_optab): Define.\n\t(enum insn_code clrmem_optab): Remove.\n\t(set_storage_via_setmem): New function.\n\t(clear_storage_via_setmem): Remove.\n\t(clear_storage): Replace call to \"clear_storage_via_clrmem\" with\n\t\"set_storage_via_setmem\".\n\t* expr.h: (set_storage_via_setmem): Declare.\n\t(CLEAR_RATIO): Redefine using HAVE_setmemM.\n\t* optabs.h: (enum insn_code setmem_optab): Declare.\n\t(enum insn_code clrmem_optab): Remove.\n\t* optabs.c: (init_optabs): Initialize setmem_optab.\n\t(enum insn_code clrmem_optab): Remove.\n\t* genopinit.c: (otabs): Likewise.\n\t* doc/md.texi: Document new standard pattern 'setmem'. Remove\n\t  'clrmem'.\n\t* config/alpha/alpha.c: (alpha_expand_block_clear): Adjust\n\t'operands' ordering.\n\t* config/frv/frv.c: (frv_expand_block_clear): Likewise.\n\t* config/rs6000/rs6000.c: (expand_block_clear): Likewise.\n\t* config/alpha/alpha.md: (\"clrmemqi\", \"clrmemdi\"): Rename to \"setmemM\".\n\tFAIL on operands[2]!=const0_rtx. Adjust 'operands' ordering.\n\t* config/avr/avr.md: (\"clrmemhi\"): Likewise.\n\t* config/frv/frv.md: (\"clrmemsi\"): Likewise.\n\t* config/i386/i386.md: (\"clrmemsi\", \"clrmemdi\"): Likewise.\n\t* config/pa/pa.md: (\"clrmemsi\", \"clrmemdi\"): Likewise.\n\t* config/rs6000/rs6000.md: (\"clrmemsi\"): Likewise.\n\t* config/s390/s390.md: (\"clrmem<mode>\"): Likewise.\n\nFrom-SVN: r101386", "tree": {"sha": "1c07634d50dcd55dcccb73af6219e12082ada423", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c07634d50dcd55dcccb73af6219e12082ada423"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/comments", "author": null, "committer": null, "parents": [{"sha": "617a1b714435a270ccf699c4c6e17767088e2242", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617a1b714435a270ccf699c4c6e17767088e2242", "html_url": "https://github.com/Rust-GCC/gccrs/commit/617a1b714435a270ccf699c4c6e17767088e2242"}], "stats": {"total": 390, "additions": 237, "deletions": 153}, "files": [{"sha": "225451d70f81982a9c3338d5e1749ce33c119d60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "patch": "@@ -1,3 +1,35 @@\n+2006-06-28  Adrian Straetling  <straetling@de.ibm.com>\n+\n+\t* builtins.c: (expand_builtin_memset): Rewrite to support\n+\t'set_storage_via_setmem'.\n+\t* expr.c: (enum insn_code setmem_optab): Define.\n+\t(enum insn_code clrmem_optab): Remove.\n+\t(set_storage_via_setmem): New function.\n+\t(clear_storage_via_setmem): Remove.\n+\t(clear_storage): Replace call to \"clear_storage_via_clrmem\" with\n+\t\"set_storage_via_setmem\".\n+\t* expr.h: (set_storage_via_setmem): Declare.\n+\t(CLEAR_RATIO): Redefine using HAVE_setmemM.\n+\t* optabs.h: (enum insn_code setmem_optab): Declare.\n+\t(enum insn_code clrmem_optab): Remove.\n+\t* optabs.c: (init_optabs): Initialize setmem_optab.\n+\t(enum insn_code clrmem_optab): Remove.\n+\t* genopinit.c: (otabs): Likewise.\n+\t* doc/md.texi: Document new standard pattern 'setmem'. Remove\n+\t  'clrmem'.\n+\t* config/alpha/alpha.c: (alpha_expand_block_clear): Adjust\n+\t'operands' ordering.\n+\t* config/frv/frv.c: (frv_expand_block_clear): Likewise.\n+\t* config/rs6000/rs6000.c: (expand_block_clear): Likewise.\n+\t* config/alpha/alpha.md: (\"clrmemqi\", \"clrmemdi\"): Rename to \"setmemM\".\n+\tFAIL on operands[2]!=const0_rtx. Adjust 'operands' ordering.\n+\t* config/avr/avr.md: (\"clrmemhi\"): Likewise.\n+\t* config/frv/frv.md: (\"clrmemsi\"): Likewise.\n+\t* config/i386/i386.md: (\"clrmemsi\", \"clrmemdi\"): Likewise.\n+\t* config/pa/pa.md: (\"clrmemsi\", \"clrmemdi\"): Likewise.\n+\t* config/rs6000/rs6000.md: (\"clrmemsi\"): Likewise.\n+\t* config/s390/s390.md: (\"clrmem<mode>\"): Likewise.\n+\n 2005-06-28  Paul Brook  <paul@codesourcery.com>\n \n \t* Makefile.in: Set and use UNWIND_H.  Install as unwind.h."}, {"sha": "f308f530c354336575955dbb6353f7355bdcf11e", "filename": "gcc/builtins.c", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "patch": "@@ -3335,33 +3335,34 @@ expand_builtin_memset (tree arglist, rtx target, enum machine_mode mode,\n \t  return expand_expr (dest, target, mode, EXPAND_NORMAL);\n \t}\n \n+      len_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n+      dest_mem = get_memory_rtx (dest);\n+\n       if (TREE_CODE (val) != INTEGER_CST)\n \t{\n \t  rtx val_rtx;\n \n-\t  if (!host_integerp (len, 1))\n-\t    return 0;\n-\n-\t  if (optimize_size && tree_low_cst (len, 1) > 1)\n-\t    return 0;\n+\t  val = fold_build1 (CONVERT_EXPR, unsigned_char_type_node, val);\n+\t  val_rtx = expand_expr (val, NULL_RTX, VOIDmode, 0);\n \n \t  /* Assume that we can memset by pieces if we can store the\n \t   * the coefficients by pieces (in the required modes).\n \t   * We can't pass builtin_memset_gen_str as that emits RTL.  */\n \t  c = 1;\n-\t  if (!can_store_by_pieces (tree_low_cst (len, 1),\n-\t\t\t\t    builtin_memset_read_str,\n-\t\t\t\t    &c, dest_align))\n+\t  if (host_integerp (len, 1)\n+\t      && !(optimize_size && tree_low_cst (len, 1) > 1)\n+\t      && can_store_by_pieces (tree_low_cst (len, 1),\n+\t\t\t\t      builtin_memset_read_str, &c, dest_align))\n+\t    {\n+\t      val_rtx = force_reg (TYPE_MODE (unsigned_char_type_node), \n+\t\t\t\t   val_rtx);\n+\t      store_by_pieces (dest_mem, tree_low_cst (len, 1),\n+\t\t\t       builtin_memset_gen_str, val_rtx, dest_align, 0);\n+\t    }\n+\t  else if (!set_storage_via_setmem(dest_mem, len_rtx, val_rtx, \n+\t\t\t\t\t   dest_align))\n \t    return 0;\n \n-\t  val = fold_build1 (CONVERT_EXPR, unsigned_char_type_node, val);\n-\t  val_rtx = expand_expr (val, NULL_RTX, VOIDmode, 0);\n-\t  val_rtx = force_reg (TYPE_MODE (unsigned_char_type_node),\n-\t\t\t       val_rtx);\n-\t  dest_mem = get_memory_rtx (dest);\n-\t  store_by_pieces (dest_mem, tree_low_cst (len, 1),\n-\t\t\t   builtin_memset_gen_str,\n-\t\t\t   val_rtx, dest_align, 0);\n \t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n \t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n \t  return dest_mem;\n@@ -3372,25 +3373,21 @@ expand_builtin_memset (tree arglist, rtx target, enum machine_mode mode,\n \n       if (c)\n \t{\n-\t  if (!host_integerp (len, 1))\n-\t    return 0;\n-\t  if (!can_store_by_pieces (tree_low_cst (len, 1),\n-\t\t\t\t    builtin_memset_read_str, &c,\n-\t\t\t\t    dest_align))\n+\t  if (host_integerp (len, 1)\n+\t      && !(optimize_size && tree_low_cst (len, 1) > 1)\n+\t      && can_store_by_pieces (tree_low_cst (len, 1),\n+\t\t\t\t      builtin_memset_read_str, &c, dest_align))\n+\t    store_by_pieces (dest_mem, tree_low_cst (len, 1),\n+\t\t\t     builtin_memset_read_str, &c, dest_align, 0);\n+\t  else if (!set_storage_via_setmem (dest_mem, len_rtx, GEN_INT (c),\n+\t\t\t\t\t    dest_align))\n \t    return 0;\n \n-\t  dest_mem = get_memory_rtx (dest);\n-\t  store_by_pieces (dest_mem, tree_low_cst (len, 1),\n-\t\t\t   builtin_memset_read_str,\n-\t\t\t   &c, dest_align, 0);\n \t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n \t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n \t  return dest_mem;\n \t}\n \n-      len_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n-\n-      dest_mem = get_memory_rtx (dest);\n       set_mem_align (dest_mem, dest_align);\n       dest_addr = clear_storage (dest_mem, len_rtx,\n \t\t\t\t CALL_EXPR_TAILCALL (orig_exp)"}, {"sha": "daba49d40605fbe49c9d0abafceefa7392e7bd0b", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "patch": "@@ -4069,7 +4069,7 @@ int\n alpha_expand_block_clear (rtx operands[])\n {\n   rtx bytes_rtx\t= operands[1];\n-  rtx align_rtx = operands[2];\n+  rtx align_rtx = operands[3];\n   HOST_WIDE_INT orig_bytes = INTVAL (bytes_rtx);\n   HOST_WIDE_INT bytes = orig_bytes;\n   HOST_WIDE_INT align = INTVAL (align_rtx) * BITS_PER_UNIT;"}, {"sha": "157e8caf2d65101b6ecd43a28e3dca00db2cdd15", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "patch": "@@ -6552,34 +6552,42 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"28\")])\n \n-(define_expand \"clrmemqi\"\n+(define_expand \"setmemqi\"\n   [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n-\t\t   (const_int 0))\n+\t\t   (match_operand 2 \"const_int_operand\" \"\"))\n \t      (use (match_operand:DI 1 \"immediate_operand\" \"\"))\n-\t      (use (match_operand:DI 2 \"immediate_operand\" \"\"))])]\n+\t      (use (match_operand:DI 3 \"immediate_operand\" \"\"))])]\n   \"\"\n {\n+  /* If value to set is not zero, use the library routine.  */\n+  if (operands[2] != const0_rtx)\n+    FAIL;\n+\n   if (alpha_expand_block_clear (operands))\n     DONE;\n   else\n     FAIL;\n })\n \n-(define_expand \"clrmemdi\"\n+(define_expand \"setmemdi\"\n   [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n-\t\t   (const_int 0))\n+\t\t   (match_operand 2 \"const_int_operand\" \"\"))\n \t      (use (match_operand:DI 1 \"immediate_operand\" \"\"))\n-\t      (use (match_operand:DI 2 \"immediate_operand\" \"\"))\n-\t      (use (match_dup 3))\n+\t      (use (match_operand:DI 3 \"immediate_operand\" \"\"))\n+\t      (use (match_dup 4))\n \t      (clobber (reg:DI 25))\n \t      (clobber (reg:DI 16))\n \t      (clobber (reg:DI 17))\n \t      (clobber (reg:DI 26))\n \t      (clobber (reg:DI 27))])]\n   \"TARGET_ABI_OPEN_VMS\"\n {\n-  operands[3] = gen_rtx_SYMBOL_REF (Pmode, \"OTS$ZERO\");\n-  alpha_need_linkage (XSTR (operands[3], 0), 0);\n+  /* If value to set is not zero, use the library routine.  */\n+  if (operands[2] != const0_rtx)\n+    FAIL;\n+\n+  operands[4] = gen_rtx_SYMBOL_REF (Pmode, \"OTS$ZERO\");\n+  alpha_need_linkage (XSTR (operands[4], 0), 0);\n })\n \n (define_insn \"*clrmemdi_1\""}, {"sha": "59d35f050e1a56c3ee3a8bda7911b1aba38350b6", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "patch": "@@ -410,28 +410,32 @@\n   DONE;\n }\")\n \n-;; =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0 =0\n-;; memset (%0, 0, %1)\n+;; =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2 =%2\n+;; memset (%0, %2, %1)\n \n-(define_expand \"clrmemhi\"\n+(define_expand \"setmemhi\"\n   [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n-\t\t   (const_int 0))\n+ \t\t   (match_operand 2 \"const_int_operand\" \"\"))\n \t      (use (match_operand:HI 1 \"const_int_operand\" \"\"))\n-\t      (use (match_operand:HI 2 \"const_int_operand\" \"n\"))\n-\t      (clobber (match_scratch:HI 3 \"\"))\n-\t      (clobber (match_dup 4))])]\n+\t      (use (match_operand:HI 3 \"const_int_operand\" \"n\"))\n+\t      (clobber (match_scratch:HI 4 \"\"))\n+\t      (clobber (match_dup 5))])]\n   \"\"\n   \"{\n   rtx addr0;\n   int cnt8;\n   enum machine_mode mode;\n \n+  /* If value to set is not zero, use the library routine.  */\n+  if (operands[2] != const0_rtx)\n+    FAIL;\n+\n   if (GET_CODE (operands[1]) != CONST_INT)\n     FAIL;\n \n   cnt8 = byte_immediate_operand (operands[1], GET_MODE (operands[1]));\n   mode = cnt8 ? QImode : HImode;\n-  operands[4] = gen_rtx_SCRATCH (mode);\n+  operands[5] = gen_rtx_SCRATCH (mode);\n   operands[1] = copy_to_mode_reg (mode,\n                                   gen_int_mode (INTVAL (operands[1]), mode));\n   addr0 = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));"}, {"sha": "67bb11e9cd75cb9e3bc478a25f14d914bba89c0a", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "patch": "@@ -2298,14 +2298,14 @@ frv_expand_block_move (rtx operands[])\n \n    operands[0] is the destination\n    operands[1] is the length\n-   operands[2] is the alignment */\n+   operands[3] is the alignment */\n \n int\n frv_expand_block_clear (rtx operands[])\n {\n   rtx orig_dest = operands[0];\n   rtx bytes_rtx\t= operands[1];\n-  rtx align_rtx = operands[2];\n+  rtx align_rtx = operands[3];\n   int constp\t= (GET_CODE (bytes_rtx) == CONST_INT);\n   int align;\n   int bytes;"}, {"sha": "b8c37c51ed33c89bb2ae2ed8cffe11000407c280", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "patch": "@@ -2139,19 +2139,24 @@\n     FAIL;\n }\")\n \n-;; String/block clear insn.\n+;; String/block set insn.\n ;; Argument 0 is the destination\n ;; Argument 1 is the length\n-;; Argument 2 is the alignment\n+;; Argument 2 is the byte value -- ignore any value but zero\n+;; Argument 3 is the alignment\n \n-(define_expand \"clrmemsi\"\n+(define_expand \"setmemsi\"\n   [(parallel [(set (match_operand:BLK 0 \"\" \"\")\n-\t\t   (const_int 0))\n+\t\t   (match_operand 2 \"\" \"\"))\n \t      (use (match_operand:SI 1 \"\" \"\"))\n-\t      (use (match_operand:SI 2 \"\" \"\"))])]\n+\t      (use (match_operand:SI 3 \"\" \"\"))])]\n   \"\"\n   \"\n {\n+  /* If value to set is not zero, use the library routine.  */\n+  if (operands[2] != const0_rtx)\n+    FAIL;\n+\n   if (frv_expand_block_clear (operands))\n     DONE;\n   else"}, {"sha": "84be8f97509cd7a666954e1deab947c2643d52b7", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "patch": "@@ -17182,25 +17182,35 @@\n    (set_attr \"memory\" \"both\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_expand \"clrmemsi\"\n+(define_expand \"setmemsi\"\n    [(use (match_operand:BLK 0 \"memory_operand\" \"\"))\n     (use (match_operand:SI 1 \"nonmemory_operand\" \"\"))\n-    (use (match_operand 2 \"const_int_operand\" \"\"))]\n+    (use (match_operand 2 \"const_int_operand\" \"\"))\n+    (use (match_operand 3 \"const_int_operand\" \"\"))]\n   \"\"\n {\n- if (ix86_expand_clrmem (operands[0], operands[1], operands[2]))\n+ /* If value to set is not zero, use the library routine.  */\n+ if (operands[2] != const0_rtx)\n+   FAIL;\n+\n+ if (ix86_expand_clrmem (operands[0], operands[1], operands[3]))\n    DONE;\n  else\n    FAIL;\n })\n \n-(define_expand \"clrmemdi\"\n+(define_expand \"setmemdi\"\n    [(use (match_operand:BLK 0 \"memory_operand\" \"\"))\n     (use (match_operand:DI 1 \"nonmemory_operand\" \"\"))\n-    (use (match_operand 2 \"const_int_operand\" \"\"))]\n+    (use (match_operand 2 \"const_int_operand\" \"\"))\n+    (use (match_operand 3 \"const_int_operand\" \"\"))]\n   \"TARGET_64BIT\"\n {\n- if (ix86_expand_clrmem (operands[0], operands[1], operands[2]))\n+ /* If value to set is not zero, use the library routine.  */\n+ if (operands[2] != const0_rtx)\n+   FAIL;\n+\n+ if (ix86_expand_clrmem (operands[0], operands[1], operands[3]))\n    DONE;\n  else\n    FAIL;"}, {"sha": "de5b75b022bf0bac222a444d9358b35466a27fd4", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "patch": "@@ -3518,24 +3518,28 @@\n   \"* return output_block_move (operands, !which_alternative);\"\n   [(set_attr \"type\" \"multi,multi\")])\n \n-(define_expand \"clrmemsi\"\n+(define_expand \"setmemsi\"\n   [(parallel [(set (match_operand:BLK 0 \"\" \"\")\n-\t\t   (const_int 0))\n-\t      (clobber (match_dup 3))\n+\t\t   (match_operand 2 \"const_int_operand\" \"\"))\n \t      (clobber (match_dup 4))\n+\t      (clobber (match_dup 5))\n \t      (use (match_operand:SI 1 \"arith_operand\" \"\"))\n-\t      (use (match_operand:SI 2 \"const_int_operand\" \"\"))])]\n+\t      (use (match_operand:SI 3 \"const_int_operand\" \"\"))])]\n   \"!TARGET_64BIT && optimize > 0\"\n   \"\n {\n   int size, align;\n \n+  /* If value to set is not zero, use the library routine.  */\n+  if (operands[2] != const0_rtx)\n+    FAIL;\n+\n   /* Undetermined size, use the library routine.  */\n   if (GET_CODE (operands[1]) != CONST_INT)\n     FAIL;\n \n   size = INTVAL (operands[1]);\n-  align = INTVAL (operands[2]);\n+  align = INTVAL (operands[3]);\n   align = align > 4 ? 4 : align;\n \n   /* If size/alignment is large, then use the library routines.  */\n@@ -3550,8 +3554,8 @@\n   operands[0]\n     = replace_equiv_address (operands[0],\n \t\t\t     copy_to_mode_reg (SImode, XEXP (operands[0], 0)));\n-  operands[3] = gen_reg_rtx (SImode);\n   operands[4] = gen_reg_rtx (SImode);\n+  operands[5] = gen_reg_rtx (SImode);\n }\")\n \n (define_insn \"clrmemsi_prereload\"\n@@ -3628,24 +3632,28 @@\n   \"* return output_block_clear (operands, !which_alternative);\"\n   [(set_attr \"type\" \"multi,multi\")])\n \n-(define_expand \"clrmemdi\"\n+(define_expand \"setmemdi\"\n   [(parallel [(set (match_operand:BLK 0 \"\" \"\")\n-\t\t   (const_int 0))\n-\t      (clobber (match_dup 3))\n+\t\t   (match_operand 2 \"const_int_operand\" \"\"))\n \t      (clobber (match_dup 4))\n+\t      (clobber (match_dup 5))\n \t      (use (match_operand:DI 1 \"arith_operand\" \"\"))\n-\t      (use (match_operand:DI 2 \"const_int_operand\" \"\"))])]\n+\t      (use (match_operand:DI 3 \"const_int_operand\" \"\"))])]\n   \"TARGET_64BIT && optimize > 0\"\n   \"\n {\n   int size, align;\n \n+  /* If value to set is not zero, use the library routine.  */\n+  if (operands[2] != const0_rtx)\n+    FAIL;\n+\n   /* Undetermined size, use the library routine.  */\n   if (GET_CODE (operands[1]) != CONST_INT)\n     FAIL;\n \n   size = INTVAL (operands[1]);\n-  align = INTVAL (operands[2]);\n+  align = INTVAL (operands[3]);\n   align = align > 8 ? 8 : align;\n \n   /* If size/alignment is large, then use the library routines.  */\n@@ -3660,8 +3668,8 @@\n   operands[0]\n     = replace_equiv_address (operands[0],\n \t\t\t     copy_to_mode_reg (DImode, XEXP (operands[0], 0)));\n-  operands[3] = gen_reg_rtx (DImode);\n   operands[4] = gen_reg_rtx (DImode);\n+  operands[5] = gen_reg_rtx (DImode);\n }\")\n \n (define_insn \"clrmemdi_prereload\""}, {"sha": "5bc8ccfdada5141a7504f2362a0a6bf4b485d2ad", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "patch": "@@ -8588,14 +8588,14 @@ rs6000_init_libfuncs (void)\n \n    operands[0] is the destination\n    operands[1] is the length\n-   operands[2] is the alignment */\n+   operands[3] is the alignment */\n \n int\n expand_block_clear (rtx operands[])\n {\n   rtx orig_dest = operands[0];\n   rtx bytes_rtx\t= operands[1];\n-  rtx align_rtx = operands[2];\n+  rtx align_rtx = operands[3];\n   bool constp\t= (GET_CODE (bytes_rtx) == CONST_INT);\n   HOST_WIDE_INT align;\n   HOST_WIDE_INT bytes;"}, {"sha": "9cde35a0787a8f7bf6a795a864bebff1eed95a9c", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "patch": "@@ -8613,14 +8613,18 @@\n   \"{stsi|stswi} %2,%1,%O0\"\n   [(set_attr \"type\" \"store\")])\n \f\n-(define_expand \"clrmemsi\"\n+(define_expand \"setmemsi\"\n   [(parallel [(set (match_operand:BLK 0 \"\" \"\")\n-\t\t   (const_int 0))\n+\t\t   (match_operand 2 \"const_int_operand\" \"\" \"\"))\n \t      (use (match_operand:SI 1 \"\" \"\"))\n-\t      (use (match_operand:SI 2 \"\" \"\"))])]\n+\t      (use (match_operand:SI 3 \"\" \"\"))])]\n   \"\"\n   \"\n {\n+  /* If value to set is not zero, use the library routine.  */\n+  if (operand[2] != const0_rtx)\n+    FAIL;\n+\n   if (expand_block_clear (operands))\n     DONE;\n   else"}, {"sha": "8a3e1a41810e16b97c502c8ec2b7092df61f54fc", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "patch": "@@ -1919,16 +1919,23 @@\n    (set_attr \"type\" \"vs\")])\n \n ;\n-; clrmemM instruction pattern(s).\n+; setmemM instruction pattern(s).\n ;\n \n-(define_expand \"clrmem<mode>\"\n+(define_expand \"setmem<mode>\"\n   [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n-        (const_int 0))\n+        (match_operand 2 \"const_int_operand\" \"\"))\n    (use (match_operand:GPR 1 \"general_operand\" \"\"))\n-   (match_operand 2 \"\" \"\")]\n+   (match_operand 3 \"\" \"\")]\n   \"\"\n-  \"s390_expand_clrmem (operands[0], operands[1]); DONE;\")\n+{\n+  /* If value to set is not zero, use the library routine.  */\n+  if (operands[2] != const0_rtx) \n+    FAIL;\n+\n+  s390_expand_clrmem (operands[0], operands[1]); \n+  DONE;\n+})\n \n ; Clear a block that is up to 256 bytes in length.\n ; The block length is taken as (operands[1] % 256) + 1."}, {"sha": "a44c34c3d2c3114dd24ade6496b198f3614b1286", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "patch": "@@ -3253,19 +3253,21 @@ destination and source strings are operands 1 and 2, and both are\n the expansion of this pattern should store in operand 0 the address in\n which the @code{NUL} terminator was stored in the destination string.\n \n-@cindex @code{clrmem@var{m}} instruction pattern\n-@item @samp{clrmem@var{m}}\n-Block clear instruction.  The destination string is the first operand,\n+@cindex @code{setmem@var{m}} instruction pattern\n+@item @samp{setmem@var{m}}\n+Block set instruction.  The destination string is the first operand,\n given as a @code{mem:BLK} whose address is in mode @code{Pmode}.  The\n-number of bytes to clear is the second operand, in mode @var{m}.  See\n+number of bytes to set is the second operand, in mode @var{m}.  The value to\n+initialize the memory with is the third operand. Targets that only support the\n+clearing of memory should reject any value that is not the constant 0.  See\n @samp{movmem@var{m}} for a discussion of the choice of mode.\n \n-The third operand is the known alignment of the destination, in the form\n+The fourth operand is the known alignment of the destination, in the form\n of a @code{const_int} rtx.  Thus, if the compiler knows that the\n destination is word-aligned, it may provide the value 4 for this\n operand.\n \n-The use for multiple @code{clrmem@var{m}} is as for @code{movmem@var{m}}.\n+The use for multiple @code{setmem@var{m}} is as for @code{movmem@var{m}}.\n \n @cindex @code{cmpstr@var{m}} instruction pattern\n @item @samp{cmpstr@var{m}}"}, {"sha": "b9bba08f7f445af168498d1de4fde89dc75a5540", "filename": "gcc/expr.c", "status": "modified", "additions": 64, "deletions": 60, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "patch": "@@ -134,7 +134,6 @@ static void clear_by_pieces (rtx, unsigned HOST_WIDE_INT, unsigned int);\n static void store_by_pieces_1 (struct store_by_pieces *, unsigned int);\n static void store_by_pieces_2 (rtx (*) (rtx, ...), enum machine_mode,\n \t\t\t       struct store_by_pieces *);\n-static bool clear_storage_via_clrmem (rtx, rtx, unsigned);\n static rtx clear_storage_via_libcall (rtx, rtx, bool);\n static tree clear_storage_libcall_fn (int);\n static rtx compress_float_constant (rtx, rtx);\n@@ -200,8 +199,8 @@ static bool float_extend_from_mem[NUM_MACHINE_MODES][NUM_MACHINE_MODES];\n /* This array records the insn_code of insns to perform block moves.  */\n enum insn_code movmem_optab[NUM_MACHINE_MODES];\n \n-/* This array records the insn_code of insns to perform block clears.  */\n-enum insn_code clrmem_optab[NUM_MACHINE_MODES];\n+/* This array records the insn_code of insns to perform block sets.  */\n+enum insn_code setmem_optab[NUM_MACHINE_MODES];\n \n /* These arrays record the insn_code of two different kinds of insns\n    to perform block compares.  */\n@@ -2478,7 +2477,7 @@ clear_storage (rtx object, rtx size, enum block_op_methods method)\n   if (GET_CODE (size) == CONST_INT\n       && CLEAR_BY_PIECES_P (INTVAL (size), align))\n     clear_by_pieces (object, INTVAL (size), align);\n-  else if (clear_storage_via_clrmem (object, size, align))\n+  else if (set_storage_via_setmem (object, size, const0_rtx, align))\n     ;\n   else\n     return clear_storage_via_libcall (object, size,\n@@ -2487,62 +2486,6 @@ clear_storage (rtx object, rtx size, enum block_op_methods method)\n   return NULL;\n }\n \n-/* A subroutine of clear_storage.  Expand a clrmem pattern;\n-   return true if successful.  */\n-\n-static bool\n-clear_storage_via_clrmem (rtx object, rtx size, unsigned int align)\n-{\n-  /* Try the most limited insn first, because there's no point\n-     including more than one in the machine description unless\n-     the more limited one has some advantage.  */\n-\n-  rtx opalign = GEN_INT (align / BITS_PER_UNIT);\n-  enum machine_mode mode;\n-\n-  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n-    {\n-      enum insn_code code = clrmem_optab[(int) mode];\n-      insn_operand_predicate_fn pred;\n-\n-      if (code != CODE_FOR_nothing\n-\t  /* We don't need MODE to be narrower than\n-\t     BITS_PER_HOST_WIDE_INT here because if SIZE is less than\n-\t     the mode mask, as it is returned by the macro, it will\n-\t     definitely be less than the actual mode mask.  */\n-\t  && ((GET_CODE (size) == CONST_INT\n-\t       && ((unsigned HOST_WIDE_INT) INTVAL (size)\n-\t\t   <= (GET_MODE_MASK (mode) >> 1)))\n-\t      || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD)\n-\t  && ((pred = insn_data[(int) code].operand[0].predicate) == 0\n-\t      || (*pred) (object, BLKmode))\n-\t  && ((pred = insn_data[(int) code].operand[2].predicate) == 0\n-\t      || (*pred) (opalign, VOIDmode)))\n-\t{\n-\t  rtx op1;\n-\t  rtx last = get_last_insn ();\n-\t  rtx pat;\n-\n-\t  op1 = convert_to_mode (mode, size, 1);\n-\t  pred = insn_data[(int) code].operand[1].predicate;\n-\t  if (pred != 0 && ! (*pred) (op1, mode))\n-\t    op1 = copy_to_mode_reg (mode, op1);\n-\n-\t  pat = GEN_FCN ((int) code) (object, op1, opalign);\n-\t  if (pat)\n-\t    {\n-\t      emit_insn (pat);\n-\t      return true;\n-\t    }\n-\t  else\n-\t    delete_insns_since (last);\n-\t}\n-    }\n-\n-  return false;\n-}\n-\n /* A subroutine of clear_storage.  Expand a call to memset.\n    Return the return value of memset, 0 otherwise.  */\n \n@@ -2635,6 +2578,67 @@ clear_storage_libcall_fn (int for_call)\n \n   return block_clear_fn;\n }\n+\f\n+/* Expand a setmem pattern; return true if successful.  */\n+\n+bool\n+set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align)\n+{\n+  /* Try the most limited insn first, because there's no point\n+     including more than one in the machine description unless\n+     the more limited one has some advantage.  */\n+\n+  rtx opalign = GEN_INT (align / BITS_PER_UNIT);\n+  enum machine_mode mode;\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    {\n+      enum insn_code code = setmem_optab[(int) mode];\n+      insn_operand_predicate_fn pred;\n+\n+      if (code != CODE_FOR_nothing\n+\t  /* We don't need MODE to be narrower than\n+\t     BITS_PER_HOST_WIDE_INT here because if SIZE is less than\n+\t     the mode mask, as it is returned by the macro, it will\n+\t     definitely be less than the actual mode mask.  */\n+\t  && ((GET_CODE (size) == CONST_INT\n+\t       && ((unsigned HOST_WIDE_INT) INTVAL (size)\n+\t\t   <= (GET_MODE_MASK (mode) >> 1)))\n+\t      || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD)\n+\t  && ((pred = insn_data[(int) code].operand[0].predicate) == 0\n+\t      || (*pred) (object, BLKmode))\n+\t  && ((pred = insn_data[(int) code].operand[3].predicate) == 0\n+\t      || (*pred) (opalign, VOIDmode)))\n+\t{\n+\t  rtx opsize,opchar;\n+\t  rtx last = get_last_insn ();\n+\t  rtx pat;\n+\n+\t  opsize = convert_to_mode (mode, size, 1);\n+\t  pred = insn_data[(int) code].operand[1].predicate;\n+\t  if (pred != 0 && ! (*pred) (opsize, mode))\n+\t    opsize = copy_to_mode_reg (mode, opsize);\n+\t  \n+\t  opchar = convert_to_mode (mode, val, 1);\n+\t  pred = insn_data[(int) code].operand[2].predicate;\n+\t  if (pred != 0 && ! (*pred) (opchar, mode))\n+\t    opchar = copy_to_mode_reg (mode, opchar);\n+\n+\t  pat = GEN_FCN ((int) code) (object, opsize, opchar, opalign);\n+\t  if (pat)\n+\t    {\n+\t      emit_insn (pat);\n+\t      return true;\n+\t    }\n+\t  else\n+\t    delete_insns_since (last);\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n \f\n /* Write to one of the components of the complex value CPLX.  Write VAL to\n    the real part if IMAG_P is false, and the imaginary part if its true.  */"}, {"sha": "31c43c087d2943e5c008e9e2bcf7142d844f8c6a", "filename": "gcc/expr.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "patch": "@@ -75,10 +75,10 @@ enum expand_modifier {EXPAND_NORMAL = 0, EXPAND_STACK_PARM, EXPAND_SUM,\n #endif\n \n /* If a clear memory operation would take CLEAR_RATIO or more simple\n-   move-instruction sequences, we will do a clrmem or libcall instead.  */\n+   move-instruction sequences, we will do a setmem or libcall instead.  */\n \n #ifndef CLEAR_RATIO\n-#if defined (HAVE_clrmemqi) || defined (HAVE_clrmemhi) || defined (HAVE_clrmemsi) || defined (HAVE_clrmemdi) || defined (HAVE_clrmemti)\n+#if defined (HAVE_setmemqi) || defined (HAVE_setmemhi) || defined (HAVE_setmemsi) || defined (HAVE_setmemdi) || defined (HAVE_setmemti)\n #define CLEAR_RATIO 2\n #else\n /* If we are optimizing for space, cut down the default clear ratio.  */\n@@ -423,6 +423,9 @@ extern void use_group_regs (rtx *, rtx);\n    If OBJECT has BLKmode, SIZE is its length in bytes.  */\n extern rtx clear_storage (rtx, rtx, enum block_op_methods);\n \n+/* Expand a setmem pattern; return true if successful.  */\n+extern bool set_storage_via_setmem (rtx, rtx, rtx, unsigned int);\n+\n /* Determine whether the LEN bytes can be moved by using several move\n    instructions.  Return nonzero if a call to move_by_pieces should\n    succeed.  */"}, {"sha": "409ed08903ba2a16e9bda6bb5291c520da3d092f", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "patch": "@@ -168,9 +168,9 @@ static const char * const optabs[] =\n   \"reload_in_optab[$A] = CODE_FOR_$(reload_in$a$)\",\n   \"reload_out_optab[$A] = CODE_FOR_$(reload_out$a$)\",\n   \"movmem_optab[$A] = CODE_FOR_$(movmem$a$)\",\n-  \"clrmem_optab[$A] = CODE_FOR_$(clrmem$a$)\",\n   \"cmpstr_optab[$A] = CODE_FOR_$(cmpstr$a$)\",\n   \"cmpmem_optab[$A] = CODE_FOR_$(cmpmem$a$)\",\n+  \"setmem_optab[$A] = CODE_FOR_$(setmem$a$)\",\n   \"sync_add_optab[$A] = CODE_FOR_$(sync_add$I$a$)\",\n   \"sync_sub_optab[$A] = CODE_FOR_$(sync_sub$I$a$)\",\n   \"sync_ior_optab[$A] = CODE_FOR_$(sync_ior$I$a$)\","}, {"sha": "2ed499e441fd63aeef4265bf95e2ea5eb5daeff0", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "patch": "@@ -5162,9 +5162,9 @@ init_optabs (void)\n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n     {\n       movmem_optab[i] = CODE_FOR_nothing;\n-      clrmem_optab[i] = CODE_FOR_nothing;\n       cmpstr_optab[i] = CODE_FOR_nothing;\n       cmpmem_optab[i] = CODE_FOR_nothing;\n+      setmem_optab[i] = CODE_FOR_nothing;\n \n       sync_add_optab[i] = CODE_FOR_nothing;\n       sync_sub_optab[i] = CODE_FOR_nothing;"}, {"sha": "bba0a5ce82117cbe255e3e9ac3580a3d60f59798", "filename": "gcc/optabs.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e84f1840c3da2c5c73d5c2f81a9b922957a27b/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=57e84f1840c3da2c5c73d5c2f81a9b922957a27b", "patch": "@@ -444,8 +444,8 @@ extern enum insn_code vcondu_gen_code[NUM_MACHINE_MODES];\n /* This array records the insn_code of insns to perform block moves.  */\n extern enum insn_code movmem_optab[NUM_MACHINE_MODES];\n \n-/* This array records the insn_code of insns to perform block clears.  */\n-extern enum insn_code clrmem_optab[NUM_MACHINE_MODES];\n+/* This array records the insn_code of insns to perform block sets.  */\n+extern enum insn_code setmem_optab[NUM_MACHINE_MODES];\n \n /* These arrays record the insn_code of two different kinds of insns\n    to perform block compares.  */"}]}