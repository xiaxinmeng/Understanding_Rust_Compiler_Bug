{"sha": "e9b0dd2afe7a9e8a3033340dfa26ec606930eef5", "node_id": "C_kwDOANBUbNoAKGU5YjBkZDJhZmU3YTllOGEzMDMzMzQwZGZhMjZlYzYwNjkzMGVlZjU", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-08-31T12:41:04Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-01T11:19:07Z"}, "message": "Add signbit property to frange to better model signed zeros.\n\nAs discussed here:\n\n\thttps://gcc.gnu.org/pipermail/gcc-patches/2022-August/600656.html\n\nThis adds an frange property to keep track of the sign bit.  We keep\nit updated at all times, but we don't use it make any decisions when\n!HONOR_SIGNED_ZEROS.\n\nWith this property we can now query the range for the appropriate sign\nwith frange::get_signbit ().  Possible values are yes, no, and unknown.\n\ngcc/ChangeLog:\n\n\t* range-op-float.cc (foperator_equal::op1_range): Do not copy sign\n\tbit.\n\t(foperator_not_equal::op1_range): Same.\n\t* value-query.cc (range_query::get_tree_range): Set sign bit.\n\t* value-range-pretty-print.cc (vrange_printer::visit): Dump sign bit.\n\t* value-range.cc (frange::set_signbit): New.\n\t(frange::set): Adjust for sign bit.\n\t(frange::normalize_kind): Same.\n\t(frange::union_): Remove useless comment.\n\t(frange::intersect): Same.\n\t(frange::contains_p): Adjust for sign bit.\n\t(frange::singleton_p): Same.\n\t(frange::verify_range): Same.\n\t(range_tests_signbit): New tests.\n\t(range_tests_floats): Call range_tests_signbit.\n\t* value-range.h (class frange_props): Add signbit\n\t(class frange): Same.", "tree": {"sha": "5ba1ceb1e6770c9f6e9de27184b2cfe91741b5e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ba1ceb1e6770c9f6e9de27184b2cfe91741b5e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9b0dd2afe7a9e8a3033340dfa26ec606930eef5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9b0dd2afe7a9e8a3033340dfa26ec606930eef5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9b0dd2afe7a9e8a3033340dfa26ec606930eef5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9b0dd2afe7a9e8a3033340dfa26ec606930eef5/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e1b1222af5e5346df9431df817f2e7dca01bee6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e1b1222af5e5346df9431df817f2e7dca01bee6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e1b1222af5e5346df9431df817f2e7dca01bee6"}], "stats": {"total": 238, "additions": 204, "deletions": 34}, "files": [{"sha": "2f1af4055c3fd52087a604977f67cc649cdbcfaa", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b0dd2afe7a9e8a3033340dfa26ec606930eef5/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b0dd2afe7a9e8a3033340dfa26ec606930eef5/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=e9b0dd2afe7a9e8a3033340dfa26ec606930eef5", "patch": "@@ -361,6 +361,9 @@ foperator_equal::op1_range (frange &r, tree type,\n     case BRS_TRUE:\n       // If it's true, the result is the same as OP2.\n       r = op2;\n+      // Make sure we don't copy the sign bit if we may have a zero.\n+      if (HONOR_SIGNED_ZEROS (type) && r.contains_p (build_zero_cst (type)))\n+\tr.set_signbit (fp_prop::VARYING);\n       // The TRUE side of op1 == op2 implies op1 is !NAN.\n       r.set_nan (fp_prop::NO);\n       break;\n@@ -462,6 +465,9 @@ foperator_not_equal::op1_range (frange &r, tree type,\n     case BRS_FALSE:\n       // If it's false, the result is the same as OP2.\n       r = op2;\n+      // Make sure we don't copy the sign bit if we may have a zero.\n+      if (HONOR_SIGNED_ZEROS (type) && r.contains_p (build_zero_cst (type)))\n+\tr.set_signbit (fp_prop::VARYING);\n       // The FALSE side of op1 != op2 implies op1 is !NAN.\n       r.set_nan (fp_prop::NO);\n       break;"}, {"sha": "201f679a36ea38692f860352bea5283b1666a924", "filename": "gcc/value-query.cc", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b0dd2afe7a9e8a3033340dfa26ec606930eef5/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b0dd2afe7a9e8a3033340dfa26ec606930eef5/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=e9b0dd2afe7a9e8a3033340dfa26ec606930eef5", "patch": "@@ -217,14 +217,25 @@ range_query::get_tree_range (vrange &r, tree expr, gimple *stmt)\n       return true;\n \n     case REAL_CST:\n-      if (TREE_OVERFLOW_P (expr))\n-\texpr = drop_tree_overflow (expr);\n-      r.set (expr, expr);\n-      if (real_isnan (TREE_REAL_CST_PTR (expr)))\n-\tas_a <frange> (r).set_nan (fp_prop::YES);\n-      else\n-\tas_a <frange> (r).set_nan (fp_prop::NO);\n-      return true;\n+      {\n+\tif (TREE_OVERFLOW_P (expr))\n+\t  expr = drop_tree_overflow (expr);\n+\n+\tfrange &f = as_a <frange> (r);\n+\tf.set (expr, expr);\n+\n+\t// Singletons from the tree world have known properties.\n+\tREAL_VALUE_TYPE *rv = TREE_REAL_CST_PTR (expr);\n+\tif (real_isnan (rv))\n+\t  f.set_nan (fp_prop::YES);\n+\telse\n+\t  f.set_nan (fp_prop::NO);\n+\tif (real_isneg (rv))\n+\t  f.set_signbit (fp_prop::YES);\n+\telse\n+\t  f.set_signbit (fp_prop::NO);\n+\treturn true;\n+      }\n \n     case SSA_NAME:\n       gimple_range_global (r, expr);"}, {"sha": "93e18d3c1b6339828db14b58fd3ec5a6e5b538a8", "filename": "gcc/value-range-pretty-print.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b0dd2afe7a9e8a3033340dfa26ec606930eef5/gcc%2Fvalue-range-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b0dd2afe7a9e8a3033340dfa26ec606930eef5/gcc%2Fvalue-range-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-pretty-print.cc?ref=e9b0dd2afe7a9e8a3033340dfa26ec606930eef5", "patch": "@@ -146,6 +146,7 @@ vrange_printer::visit (const frange &r) const\n   pp_string (pp, \"] \");\n \n   print_frange_prop (\"NAN\", r.get_nan ());\n+  print_frange_prop (\"SIGN\", r.get_signbit ());\n }\n \n // Print the FP properties in an frange."}, {"sha": "71581b2c54d041a8ea43cc0edd857233a4373e22", "filename": "gcc/value-range.cc", "status": "modified", "additions": 174, "deletions": 26, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b0dd2afe7a9e8a3033340dfa26ec606930eef5/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b0dd2afe7a9e8a3033340dfa26ec606930eef5/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=e9b0dd2afe7a9e8a3033340dfa26ec606930eef5", "patch": "@@ -288,6 +288,58 @@ frange::set_nan (fp_prop::kind k)\n \n   m_props.set_nan (k);\n   normalize_kind ();\n+  if (flag_checking)\n+    verify_range ();\n+}\n+\n+// Set the SIGNBIT property.  Adjust the range if appropriate.\n+\n+void\n+frange::set_signbit (fp_prop::kind k)\n+{\n+  gcc_checking_assert (m_type);\n+\n+  // No additional adjustments are needed for a NAN.\n+  if (get_nan ().yes_p ())\n+    {\n+      m_props.set_signbit (k);\n+      return;\n+    }\n+  // Ignore sign changes when they're set correctly.\n+  if (real_less (&m_max, &dconst0))\n+    {\n+      gcc_checking_assert (get_signbit ().yes_p ());\n+      return;\n+    }\n+  if (real_less (&dconst0, &m_min))\n+    {\n+      gcc_checking_assert (get_signbit ().no_p ());\n+      return;\n+    }\n+  // Adjust the range depending on the sign bit.\n+  if (k == fp_prop::YES)\n+    {\n+      // Crop the range to [-INF, 0].\n+      REAL_VALUE_TYPE min;\n+      real_inf (&min, 1);\n+      frange crop (m_type, min, dconst0);\n+      intersect (crop);\n+      m_props.set_signbit (fp_prop::YES);\n+    }\n+  else if (k == fp_prop::NO)\n+    {\n+      // Crop the range to [0, +INF].\n+      REAL_VALUE_TYPE max;\n+      real_inf (&max, 0);\n+      frange crop (m_type, dconst0, max);\n+      intersect (crop);\n+      m_props.set_signbit (fp_prop::NO);\n+    }\n+  else\n+    m_props.set_signbit (fp_prop::VARYING);\n+\n+  if (flag_checking)\n+    verify_range ();\n }\n \n // Setter for franges.\n@@ -329,6 +381,12 @@ frange::set (tree min, tree max, value_range_kind kind)\n   else if (!HONOR_NANS (m_type))\n     m_props.nan_set_no ();\n \n+  // Set SIGNBIT property for positive and negative ranges.\n+  if (real_less (&m_max, &dconst0))\n+    m_props.signbit_set_yes ();\n+  else if (real_less (&dconst0, &m_min))\n+    m_props.signbit_set_no ();\n+\n   // Check for swapped ranges.\n   gcc_checking_assert (is_nan || tree_compare (LE_EXPR, min, max));\n \n@@ -360,7 +418,7 @@ bool\n frange::normalize_kind ()\n {\n   // Undefined is viral.\n-  if (m_props.nan_undefined_p ())\n+  if (m_props.nan_undefined_p () || m_props.signbit_undefined_p ())\n     {\n       set_undefined ();\n       return true;\n@@ -438,13 +496,6 @@ frange::union_ (const vrange &v)\n     }\n \n   bool changed = m_props.union_ (r.m_props);\n-\n-  // Note: for the combination of zeros that differ in sign we keep\n-  // the endpoints untouched.  This means that for -0.0 U +0.0, the\n-  // result will be -0.0.  Ultimately this doesn't matter, because we\n-  // keep singleton zeros ambiguous throughout to avoid propagating\n-  // them.  See frange::singleton_p().\n-\n   if (real_less (&r.m_min, &m_min))\n     {\n       m_min = r.m_min;\n@@ -484,12 +535,6 @@ frange::intersect (const vrange &v)\n \n   bool changed = m_props.intersect (r.m_props);\n \n-  // Note: for the combination of zeros that differ in sign we keep\n-  // the endpoints untouched.  This means that for -0.0 ^ +0.0, the\n-  // result will be -0.0.  Ultimately this doesn't matter, because we\n-  // keep singleton zeros ambiguous throughout to avoid propagating\n-  // them.  See frange::singleton_p().\n-\n   if (real_less (&m_min, &r.m_min))\n     {\n       m_min = r.m_min;\n@@ -563,26 +608,51 @@ frange::contains_p (tree cst) const\n \n   gcc_checking_assert (m_kind == VR_RANGE);\n \n-  return (real_compare (GE_EXPR, TREE_REAL_CST_PTR (cst), &m_min)\n-\t  && real_compare (LE_EXPR, TREE_REAL_CST_PTR (cst), &m_max));\n+  const REAL_VALUE_TYPE *rv = TREE_REAL_CST_PTR (cst);\n+  if (real_compare (GE_EXPR, rv, &m_min)\n+      && real_compare (LE_EXPR, rv, &m_max))\n+    {\n+      if (HONOR_SIGNED_ZEROS (m_type) && real_iszero (rv))\n+\t{\n+\t  if (get_signbit ().yes_p ())\n+\t    return real_isneg (rv);\n+\t  else if (get_signbit ().no_p ())\n+\t    return !real_isneg (rv);\n+\t  else\n+\t    return true;\n+\t}\n+      return true;\n+    }\n+  return false;\n }\n \n // If range is a singleton, place it in RESULT and return TRUE.  If\n // RESULT is NULL, just return TRUE.\n //\n-// A NAN can never be a singleton, and neither can a 0.0 if we're\n-// honoring signed zeros because we have no way of telling which zero\n-// it is.\n+// A NAN can never be a singleton.\n \n bool\n frange::singleton_p (tree *result) const\n {\n   if (m_kind == VR_RANGE && real_identical (&m_min, &m_max))\n     {\n-      // If we're honoring signed zeros, fail because we don't know\n-      // which zero we have.  This avoids propagating the wrong zero.\n+      // Return the appropriate zero if known.\n       if (HONOR_SIGNED_ZEROS (m_type) && zero_p ())\n-\treturn false;\n+\t{\n+\t  if (get_signbit ().no_p ())\n+\t    {\n+\t      if (result)\n+\t\t*result = build_real (m_type, dconst0);\n+\t      return true;\n+\t    }\n+\t  if (get_signbit ().yes_p ())\n+\t    {\n+\t      if (result)\n+\t\t*result = build_real (m_type, real_value_negate (&dconst0));\n+\t      return true;\n+\t    }\n+\t  return false;\n+\t}\n \n       // Return false for any singleton that may be a NAN.\n       if (HONOR_NANS (m_type) && !get_nan ().no_p ())\n@@ -639,6 +709,14 @@ frange::verify_range ()\n       gcc_checking_assert (real_isnan (&m_min));\n       gcc_checking_assert (real_isnan (&m_max));\n     }\n+  else\n+    {\n+      // Make sure the signbit and range agree.\n+      if (m_props.get_signbit ().yes_p ())\n+\tgcc_checking_assert (real_compare (LE_EXPR, &m_max, &dconst0));\n+      else if (m_props.get_signbit ().no_p ())\n+\tgcc_checking_assert (real_compare (GE_EXPR, &m_min, &dconst0));\n+    }\n \n   // If all the properties are clear, we better not span the entire\n   // domain, because that would make us varying.\n@@ -3605,16 +3683,85 @@ range_tests_signed_zeros ()\n   tree neg_zero = fold_build1 (NEGATE_EXPR, float_type_node, zero);\n   frange r0, r1;\n \n-  // ?? If -0.0 == +0.0, then a range of [-0.0, -0.0] should\n-  // contain +0.0 and vice versa.  We probably need a property to\n-  // track signed zeros in the frange like we do for NAN, to\n-  // properly model all this.\n+  // Since -0.0 == +0.0, a range of [-0.0, -0.0] should contain +0.0\n+  // and vice versa.\n   r0 = frange (zero, zero);\n   r1 = frange (neg_zero, neg_zero);\n   ASSERT_TRUE (r0.contains_p (zero));\n   ASSERT_TRUE (r0.contains_p (neg_zero));\n   ASSERT_TRUE (r1.contains_p (zero));\n   ASSERT_TRUE (r1.contains_p (neg_zero));\n+\n+  // Test contains_p() when we know the sign of the zero.\n+  r0 = frange(zero, zero);\n+  r0.set_signbit (fp_prop::NO);\n+  ASSERT_TRUE (r0.contains_p (zero));\n+  ASSERT_FALSE (r0.contains_p (neg_zero));\n+  r0.set_signbit (fp_prop::YES);\n+  ASSERT_TRUE (r0.contains_p (neg_zero));\n+  ASSERT_FALSE (r0.contains_p (zero));\n+\n+  // The intersection of zeros that differ in sign is the empty set.\n+  r0 = frange (zero, zero);\n+  r0.set_signbit (fp_prop::YES);\n+  r1 = frange (zero, zero);\n+  r1.set_signbit (fp_prop::NO);\n+  r0.intersect (r1);\n+  ASSERT_TRUE (r0.undefined_p ());\n+\n+  // The union of zeros that differ in sign is a zero with unknown sign.\n+  r0 = frange (zero, zero);\n+  r0.set_signbit (fp_prop::NO);\n+  r1 = frange (zero, zero);\n+  r1.set_signbit (fp_prop::YES);\n+  r0.union_ (r1);\n+  ASSERT_TRUE (r0.zero_p () && r0.get_signbit ().varying_p ());\n+}\n+\n+static void\n+range_tests_signbit ()\n+{\n+  frange r0, r1;\n+\n+  // Setting the signbit drops the range to [-INF, 0].\n+  r0.set_varying (float_type_node);\n+  r0.set_signbit (fp_prop::YES);\n+  ASSERT_TRUE (real_isinf (&r0.lower_bound (), 1));\n+  ASSERT_TRUE (real_iszero (&r0.upper_bound ()));\n+\n+  // Setting the signbit for [-5, 10] crops the range to [-5, 0] with\n+  // the signbit property set.\n+  r0 = frange_float (\"-5\", \"10\");\n+  r0.set_signbit (fp_prop::YES);\n+  ASSERT_TRUE (r0.get_signbit ().yes_p ());\n+  r1 = frange_float (\"-5\", \"0\");\n+  ASSERT_TRUE (real_identical (&r0.lower_bound (), &r1.lower_bound ()));\n+  ASSERT_TRUE (real_identical (&r0.upper_bound (), &r1.upper_bound ()));\n+\n+  // Negative numbers should have the SIGNBIT set.\n+  r0 = frange_float (\"-5\", \"-1\");\n+  ASSERT_TRUE (r0.get_signbit ().yes_p ());\n+  // Positive numbers should have the SIGNBIT clear.\n+  r0 = frange_float (\"1\", \"10\");\n+  ASSERT_TRUE (r0.get_signbit ().no_p ());\n+  // Numbers containing zero should have an unknown SIGNBIT.\n+  r0 = frange_float (\"0\", \"10\");\n+  ASSERT_TRUE (r0.get_signbit ().varying_p ());\n+  // Numbers spanning both positive and negative should have an\n+  // unknown SIGNBIT.\n+  r0 = frange_float (\"-10\", \"10\");\n+  ASSERT_TRUE (r0.get_signbit ().varying_p ());\n+  r0.set_varying (float_type_node);\n+  ASSERT_TRUE (r0.get_signbit ().varying_p ());\n+\n+  // Ignore signbit changes when the sign bit is obviously known from\n+  // the range.\n+  r0 = frange_float (\"5\", \"10\");\n+  r0.set_signbit (fp_prop::VARYING);\n+  ASSERT_TRUE (r0.get_signbit ().no_p ());\n+  r0 = frange_float (\"-5\", \"-1\");\n+  r0.set_signbit (fp_prop::NO);\n+  ASSERT_TRUE (r0.get_signbit ().yes_p ());\n }\n \n static void\n@@ -3623,6 +3770,7 @@ range_tests_floats ()\n   frange r0, r1;\n \n   range_tests_nan ();\n+  range_tests_signbit ();\n \n   if (HONOR_SIGNED_ZEROS (float_type_node))\n     range_tests_signed_zeros ();"}, {"sha": "3767bd1731483bbc81109ce447ede8f9c136ae23", "filename": "gcc/value-range.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b0dd2afe7a9e8a3033340dfa26ec606930eef5/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b0dd2afe7a9e8a3033340dfa26ec606930eef5/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=e9b0dd2afe7a9e8a3033340dfa26ec606930eef5", "patch": "@@ -314,10 +314,12 @@ class frange_props\n   bool intersect (const frange_props &other);\n   bool operator== (const frange_props &other) const;\n   FP_PROP_ACCESSOR(nan)\n+  FP_PROP_ACCESSOR(signbit)\n private:\n   union {\n     struct {\n       unsigned char nan : 2;\n+      unsigned char signbit : 2;\n     } bits;\n     unsigned char bytes;\n   } u;\n@@ -364,6 +366,8 @@ class frange : public vrange\n   // Accessors for FP properties.\n   fp_prop get_nan () const { return m_props.get_nan (); }\n   void set_nan (fp_prop::kind f);\n+  fp_prop get_signbit () const { return m_props.get_signbit (); }\n+  void set_signbit (fp_prop::kind);\n private:\n   void verify_range ();\n   bool normalize_kind ();"}]}