{"sha": "d0ab8cd3f394c84e9584437a03b329eb7834437c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBhYjhjZDNmMzk0Yzg0ZTk1ODQ0MzdhMDNiMzI5ZWI3ODM0NDM3Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-03T01:35:35Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-03T01:35:35Z"}, "message": "(reg_sign_bit_copies): New variable.\n\n(combine_instructions): Initialize it.\n(set_significant): Set it.\n(try_combine): Set subst_low_cuid immediately before calling `subst' to\nthe INSN_CUID of the lowest insn involved in the call.   Change XOR with\nout-of-range constant to (not (xor ...)).\nCall both split_insns and find_split_point; pass extra parm to\nfind_split_point.\nRecord I2DEST's value if I2 now sets it; similarly for I1DEST.\n(find_split_point): Add new arg INSN.\nIf AND'ing with a large single-bit constant and we only care about\nequality with zero, replace with bit extraction.\nMake two shifts for ZERO_EXTRACTs unless very narrow.\n(subst): Move RESTART label earlier.\nIf we have a simple operation applied to IF_THEN_ELSE, move the operation\ninside the two arms.\n(subst, case SUBREG): Use force_to_mode.\n(subst, case NOT): Change (not (xor X C)) to (xor X ~C).\n(subst, case NEG): Remove (neg (abs X)); redundant.\nConvert (neg (xor A 1)) to (plus A -1) if A is known to be 0 or 1.\n(subst, case IF_THEN_ELSE): Simplify if an arm contains a register being\ntested by substiting the known value.\nPut constant integer in last arm if can reverse comparison.\n(subst, case SET): Use gen_lowpart_for_combine.\n(subst, case AND): Make IF_THEN_ELSE when appropriate.\n(subst, case IOR): (ior A C) can sometimes be just C.\n(subst, case XOR): Go back and restart when canonicalizing.\n(subst, case ABS): Use num_sign_bit_copies.\n(make_extraction): Call force_to_mode.\n(make_compound_operation): Look at optabs rather that explicitly checking\nfor operations and assuming we have SImode.\nHandle (ashiftrt (OP (ashift foo C1) C3) C2).\n(force_to_mode): Only change mode of arithmetic if optab says we have\noperation in that mode.\nRemove unneeded ASHIFTRT; add handling for IF_THEN_ELSE.\n(significant_bits, case NEG): Call num_sign_bit_copies.\n(significant_bits, case ABS, case [US]{MIN,MAX}, IF_THEN_ELSE): New.\n(num_sign_bit_copies): New function.\n(simplify_shift_const): Remove ASHIFTRT if value is known -1 or 0.\nUse num_sign_bit_copies to simplify (ashiftrt (ashift ...) ...)\nand (ashiftrt (neg ...) ...).\nRemove now redundant case when VAROP is a PLUS.\n(simplify_comparison): If A is known to be -1 or 0, A != -1 is A == 0.\nSimplify unsigned tests that really check the sign bit.\n(simplify_comparison, case ASHIFTRT): Convert to LSHIFTRT if equality\ncomparison with zero.\n(get_last_value): Check if the desired register is set in the\ninsn before the one whose INSN_CUID is subst_low_cuid.\n\nFrom-SVN: r1746", "tree": {"sha": "23395680e7907a8f2888dc377cdea6caeb1c6006", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23395680e7907a8f2888dc377cdea6caeb1c6006"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0ab8cd3f394c84e9584437a03b329eb7834437c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0ab8cd3f394c84e9584437a03b329eb7834437c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0ab8cd3f394c84e9584437a03b329eb7834437c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0ab8cd3f394c84e9584437a03b329eb7834437c/comments", "author": null, "committer": null, "parents": [{"sha": "cda0ec81ab3814cc678b1784f16ce2b6f3c886a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cda0ec81ab3814cc678b1784f16ce2b6f3c886a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cda0ec81ab3814cc678b1784f16ce2b6f3c886a5"}], "stats": {"total": 1009, "additions": 800, "deletions": 209}, "files": [{"sha": "df682f4f90cdc8fde4348a4748d7d36598344b77", "filename": "gcc/combine.c", "status": "modified", "additions": 800, "deletions": 209, "changes": 1009, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0ab8cd3f394c84e9584437a03b329eb7834437c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0ab8cd3f394c84e9584437a03b329eb7834437c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=d0ab8cd3f394c84e9584437a03b329eb7834437c", "patch": "@@ -256,8 +256,13 @@ static HOST_WIDE_INT *reg_significant;\n \n static enum machine_mode significant_mode;\n \n-/* Nonzero when reg_significant can be safely used.  It is zero while\n-   computing reg_significant.  This prevents propagating values based\n+/* Nonzero if we know that a register has some leading bits that are always\n+   equal to the sign bit.  */\n+\n+static char *reg_sign_bit_copies;\n+\n+/* Nonzero when reg_significant and reg_sign_bit_copies can be safely used.\n+   It is zero while computing them.  This prevents propagating values based\n    on previously set values, which can be incorrect if a variable\n    is modified in a loop.  */\n \n@@ -365,6 +370,7 @@ static rtx make_compound_operation ();\n static rtx apply_distributive_law ();\n static rtx simplify_and_const_int ();\n static unsigned HOST_WIDE_INT significant_bits ();\n+static int num_sign_bit_copies ();\n static int merge_outer_ops ();\n static rtx simplify_shift_const ();\n static int recog_for_combine ();\n@@ -405,13 +411,15 @@ combine_instructions (f, nregs)\n   reg_last_set_label = (short *) alloca (nregs * sizeof (short));\n   reg_last_set_invalid = (char *) alloca (nregs * sizeof (char));\n   reg_significant = (HOST_WIDE_INT *) alloca (nregs * sizeof (HOST_WIDE_INT));\n+  reg_sign_bit_copies = (char *) alloca (nregs * sizeof (char));\n \n   bzero (reg_last_death, nregs * sizeof (rtx));\n   bzero (reg_last_set, nregs * sizeof (rtx));\n   bzero (reg_last_set_value, nregs * sizeof (rtx));\n   bzero (reg_last_set_table_tick, nregs * sizeof (short));\n   bzero (reg_last_set_invalid, nregs * sizeof (char));\n   bzero (reg_significant, nregs * sizeof (HOST_WIDE_INT));\n+  bzero (reg_sign_bit_copies, nregs * sizeof (char));\n \n   init_recog_no_volatile ();\n \n@@ -563,13 +571,19 @@ combine_instructions (f, nregs)\n \n    If we are setting only a portion of X and we can't figure out what\n    portion, assume all bits will be used since we don't know what will\n-   be happening.  */\n+   be happening.\n+\n+   Similarly, set how many bits of X are known to be copies of the sign bit\n+   at all locations in the function.  This is the smallest number implied \n+   by any set of X.  */\n \n static void\n set_significant (x, set)\n      rtx x;\n      rtx set;\n {\n+  int num;\n+\n   if (GET_CODE (x) == REG\n       && REGNO (x) >= FIRST_PSEUDO_REGISTER\n       && reg_n_sets[REGNO (x)] > 1\n@@ -583,10 +597,19 @@ set_significant (x, set)\n \t simple assignment.  */\n       set = expand_field_assignment (set);\n       if (SET_DEST (set) == x)\n-\treg_significant[REGNO (x)]\n-\t  |= significant_bits (SET_SRC (set), significant_mode);\n+\t{\n+\t  reg_significant[REGNO (x)]\n+\t    |= significant_bits (SET_SRC (set), significant_mode);\n+\t  num = num_sign_bit_copies (SET_SRC (set), GET_MODE (x));\n+\t  if (reg_sign_bit_copies[REGNO (x)] == 0\n+\t      || reg_sign_bit_copies[REGNO (x)] > num)\n+\t    reg_sign_bit_copies[REGNO (x)] = num;\n+\t}\n       else\n-\treg_significant[REGNO (x)] = GET_MODE_MASK (GET_MODE (x));\n+\t{\n+\t  reg_significant[REGNO (x)] = GET_MODE_MASK (GET_MODE (x));\n+\t  reg_sign_bit_copies[REGNO (x)] = 0;\n+\t}\n     }\n }\n \f\n@@ -1236,7 +1259,6 @@ try_combine (i3, i2, i1)\n   maxreg = max_reg_num ();\n \n   subst_insn = i3;\n-  subst_low_cuid = i1 ? INSN_CUID (i1) : INSN_CUID (i2);\n \n   /* It is possible that the source of I2 or I1 may be performing an\n      unneeded operation, such as a ZERO_EXTEND of something that is known\n@@ -1258,9 +1280,15 @@ try_combine (i3, i2, i1)\n \t The cases that we are interested in here do not involve the few\n \t cases were is_replaced is checked.  */\n       if (i1)\n-\ti1src = subst (i1src, pc_rtx, pc_rtx, 0, 0);\n+\t{\n+\t  subst_low_cuid = INSN_CUID (i1);\n+\t  i1src = subst (i1src, pc_rtx, pc_rtx, 0, 0);\n+\t}\n       else\n-\ti2src = subst (i2src, pc_rtx, pc_rtx, 0, 0);\n+\t{\n+\t  subst_low_cuid = INSN_CUID (i2);\n+\t  i2src = subst (i2src, pc_rtx, pc_rtx, 0, 0);\n+\t}\n \n       previous_num_undos = undobuf.num_undo;\n     }\n@@ -1333,6 +1361,7 @@ try_combine (i3, i2, i1)\n \t need to make a unique copy of I2SRC each time we substitute it\n \t to avoid self-referential rtl.  */\n \n+      subst_low_cuid = INSN_CUID (i2);\n       newpat = subst (PATTERN (i3), i2dest, i2src, 0,\n \t\t      ! i1_feeds_i3 && i1dest_in_i1src);\n       previous_num_undos = undobuf.num_undo;\n@@ -1358,6 +1387,7 @@ try_combine (i3, i2, i1)\n \t}\n \n       n_occurrences = 0;\n+      subst_low_cuid = INSN_CUID (i1);\n       newpat = subst (newpat, i1dest, i1src, 0, 0);\n       previous_num_undos = undobuf.num_undo;\n     }\n@@ -1465,6 +1495,32 @@ try_combine (i3, i2, i1)\n       insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n     }\n \n+  /* See if this is an XOR.  If so, perhaps the problem is that the\n+     constant is out of range.  Replace it with a complemented XOR with\n+     a complemented constant; it might be in range.  */\n+\n+  else if (insn_code_number < 0 && GET_CODE (newpat) == SET\n+\t   && GET_CODE (SET_SRC (newpat)) == XOR\n+\t   && GET_CODE (XEXP (SET_SRC (newpat), 1)) == CONST_INT\n+\t   && ((temp = simplify_unary_operation (NOT,\n+\t\t\t\t\t\t GET_MODE (SET_SRC (newpat)),\n+\t\t\t\t\t\t XEXP (SET_SRC (newpat), 1),\n+\t\t\t\t\t\t GET_MODE (SET_SRC (newpat))))\n+\t       != 0))\n+    {\n+      enum machine_mode i_mode = GET_MODE (SET_SRC (newpat));\n+      rtx pat\n+\t= gen_rtx_combine (SET, VOIDmode, SET_DEST (newpat),\n+\t\t\t   gen_unary (NOT, i_mode,\n+\t\t\t\t      gen_binary (XOR, i_mode,\n+\t\t\t\t\t\t  XEXP (SET_SRC (newpat), 0),\n+\t\t\t\t\t\t  temp)));\n+\n+      insn_code_number = recog_for_combine (&pat, i3, &new_i3_notes);\n+      if (insn_code_number >= 0)\n+\tnewpat = pat;\n+    }\n+\t\t\t\t\t\t\t\n   /* If we were combining three insns and the result is a simple SET\n      with no ASM_OPERANDS that wasn't recognized, try to split it into two\n      insns.  There are two ways to do this.  It can be split using a \n@@ -1509,8 +1565,8 @@ try_combine (i3, i2, i1)\n \t      || ! use_crosses_set_p (PATTERN (XVECEXP (m_split, 0, 0)),\n \t\t\t\t      INSN_CUID (i2))))\n \t{\n+\t  rtx newi3pat = PATTERN (XVECEXP (m_split, 0, 1));\n \t  newi2pat = PATTERN (XVECEXP (m_split, 0, 0));\n-\t  newpat = PATTERN (XVECEXP (m_split, 0, 1));\n \n \t  /* In case we changed the mode of I2DEST, replace it in the\n \t     pseudo-register table here.  We can't do it above in case this\n@@ -1523,6 +1579,9 @@ try_combine (i3, i2, i1)\n \t  if (i2_code_number >= 0)\n \t    insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n \n+\t  if (insn_code_number >= 0)\n+\t    newpat = newi3pat;\n+\n \t  /* It is possible that both insns now set the destination of I3.\n \t     If so, we must show an extra use of it and update\n \t     reg_significant.  */\n@@ -1540,7 +1599,7 @@ try_combine (i3, i2, i1)\n       /* If we can split it and use I2DEST, go ahead and see if that\n \t helps things be recognized.  Verify that none of the registers\n \t are set between I2 and I3.  */\n-      else if ((split = find_split_point (&newpat)) != 0\n+      if (insn_code_number < 0 && (split = find_split_point (&newpat, i3)) != 0\n #ifdef HAVE_cc0\n \t  && GET_CODE (i2dest) == REG\n #endif\n@@ -1882,6 +1941,7 @@ try_combine (i3, i2, i1)\n \n     /* If I3DEST was used in I3SRC, it really died in I3.  We may need to\n        put a REG_DEAD note for it somewhere.  Similarly for I2 and I1.  */\n+\n     if (i3dest_killed)\n       distribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i3dest_killed, NULL_RTX),\n \t\t\tNULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n@@ -1919,13 +1979,23 @@ try_combine (i3, i2, i1)\n \n     if (GET_CODE (i2dest) == REG)\n       {\n-\t/* The insn that previously set this register doesn't exist, and\n-\t   this life of the register may not exist either.  Show that\n-\t   we don't know its value any more.  If we don't do this and\n-\t   I2 set the register to a value that depended on its old\n+\trtx link;\n+\trtx i2_insn = 0, i2_val = 0, set;\n+\n+\t/* The insn that used to set this register doesn't exist, and\n+\t   this life of the register may not exist either.  See if one of\n+\t   I3's links points to an insn that sets I2DEST.  If it does, \n+\t   that is now the last known value for I2DEST. If we don't update\n+\t   this and I2 set the register to a value that depended on its old\n \t   contents, we will get confused.  If this insn is used, thing\n \t   will be set correctly in combine_instructions.  */\n-\trecord_value_for_reg (i2dest, NULL_RTX, NULL_RTX);\n+\n+\tfor (link = LOG_LINKS (i3); link; link = XEXP (link, 1))\n+\t  if ((set = single_set (XEXP (link, 0))) != 0\n+\t      && rtx_equal_p (i2dest, SET_DEST (set)))\n+\t    i2_insn = XEXP (link, 0), i2_val = SET_SRC (set);\n+\n+\trecord_value_for_reg (i2dest, i2_insn, i2_val);\n \n \t/* If the reg formerly set in I2 died only once and that was in I3,\n \t   zero its use count so it won't make `reload' do any work.  */\n@@ -1942,7 +2012,16 @@ try_combine (i3, i2, i1)\n \n     if (i1 && GET_CODE (i1dest) == REG)\n       {\n-\trecord_value_for_reg (i1dest, NULL_RTX, NULL_RTX);\n+\trtx link;\n+\trtx i1_insn = 0, i1_val = 0, set;\n+\n+\tfor (link = LOG_LINKS (i3); link; link = XEXP (link, 1))\n+\t  if ((set = single_set (XEXP (link, 0))) != 0\n+\t      && rtx_equal_p (i1dest, SET_DEST (set)))\n+\t    i1_insn = XEXP (link, 0), i1_val = SET_SRC (set);\n+\n+\trecord_value_for_reg (i1dest, i1_insn, i1_val);\n+\n \tregno = REGNO (i1dest);\n \tif (! added_sets_1)\n \t  {\n@@ -1984,14 +2063,16 @@ undo_all ()\n }\n \f\n /* Find the innermost point within the rtx at LOC, possibly LOC itself,\n-   where we have an arithmetic expression and return that point.\n+   where we have an arithmetic expression and return that point.  LOC will\n+   be inside INSN.\n \n    try_combine will call this function to see if an insn can be split into\n    two insns.  */\n \n static rtx *\n-find_split_point (loc)\n+find_split_point (loc, insn)\n      rtx *loc;\n+     rtx insn;\n {\n   rtx x = *loc;\n   enum rtx_code code = GET_CODE (x);\n@@ -2009,7 +2090,7 @@ find_split_point (loc)\n       if (GET_CODE (SUBREG_REG (x)) == MEM)\n \treturn loc;\n #endif\n-      return find_split_point (&SUBREG_REG (x));\n+      return find_split_point (&SUBREG_REG (x), insn);\n \n     case MEM:\n #ifdef HAVE_lo_sum\n@@ -2029,7 +2110,7 @@ find_split_point (loc)\n       /* If we have a PLUS whose second operand is a constant and the\n \t address is not valid, perhaps will can split it up using\n \t the machine-specific way to split large constants.  We use\n-\t the first pseudo-reg (one of the virtual regs) as a placeholder;\n+\t the first psuedo-reg (one of the virtual regs) as a placeholder;\n \t it will not remain in the result.  */\n       if (GET_CODE (XEXP (x, 0)) == PLUS\n \t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n@@ -2098,7 +2179,7 @@ find_split_point (loc)\n #endif\n \n       /* See if we can split SET_SRC as it stands.  */\n-      split = find_split_point (&SET_SRC (x));\n+      split = find_split_point (&SET_SRC (x), insn);\n       if (split && split != &SET_SRC (x))\n \treturn split;\n \n@@ -2139,7 +2220,7 @@ find_split_point (loc)\n \n \t  SUBST (SET_DEST (x), dest);\n \n-\t  split = find_split_point (&SET_SRC (x));\n+\t  split = find_split_point (&SET_SRC (x), insn);\n \t  if (split && split != &SET_SRC (x))\n \t    return split;\n \t}\n@@ -2150,6 +2231,33 @@ find_split_point (loc)\n \n       switch (code)\n \t{\n+\tcase AND:\n+\t  /* If we are AND'ing with a large constant that is only a single\n+\t     bit and the result is only being used in a context where we\n+\t     need to know if it is zero or non-zero, replace it with a bit\n+\t     extraction.  This will avoid the large constant, which might\n+\t     have taken more than one insn to make.  If the constant were\n+\t     not a valid argument to the AND but took only one insn to make,\n+\t     this is no worse, but if it took more than one insn, it will\n+\t     be better.  */\n+\n+\t  if (GET_CODE (XEXP (SET_SRC (x), 1)) == CONST_INT\n+\t      && GET_CODE (XEXP (SET_SRC (x), 0)) == REG\n+\t      && (pos = exact_log2 (INTVAL (XEXP (SET_SRC (x), 1)))) >= 7\n+\t      && GET_CODE (SET_DEST (x)) == REG\n+\t      && (split = find_single_use (SET_DEST (x), insn, NULL_PTR)) != 0\n+\t      && (GET_CODE (*split) == EQ || GET_CODE (*split) == NE)\n+\t      && XEXP (*split, 0) == SET_DEST (x)\n+\t      && XEXP (*split, 1) == const0_rtx)\n+\t    {\n+\t      SUBST (SET_SRC (x),\n+\t\t     make_extraction (GET_MODE (SET_DEST (x)),\n+\t\t\t\t      XEXP (SET_SRC (x), 0),\n+\t\t\t\t      pos, NULL_RTX, 1, 1, 0, 0));\n+\t      return find_split_point (loc, insn);\n+\t    }\n+\t  break;\n+\n \tcase SIGN_EXTEND:\n \t  inner = XEXP (SET_SRC (x), 0);\n \t  pos = 0;\n@@ -2178,7 +2286,13 @@ find_split_point (loc)\n \t{\n \t  enum machine_mode mode = GET_MODE (SET_SRC (x));\n \n-\t  if (unsignedp && len < HOST_BITS_PER_WIDE_INT)\n+\t  /* For unsigned, we have a choice of a shift followed by an\n+\t     AND or two shifts.  Use two shifts for field sizes where the\n+\t     constant might be too large.  We assume here that we can\n+\t     always at least get 8-bit constants in an AND insn, which is\n+\t     true for every current RISC.  */\n+\n+\t  if (unsignedp && len <= 8)\n \t    {\n \t      SUBST (SET_SRC (x),\n \t\t     gen_rtx_combine\n@@ -2188,22 +2302,22 @@ find_split_point (loc)\n \t\t\t\t       GEN_INT (pos)),\n \t\t      GEN_INT (((HOST_WIDE_INT) 1 << len) - 1)));\n \n-\t      split = find_split_point (&SET_SRC (x));\n+\t      split = find_split_point (&SET_SRC (x), insn);\n \t      if (split && split != &SET_SRC (x))\n \t\treturn split;\n \t    }\n \t  else\n \t    {\n \t      SUBST (SET_SRC (x),\n \t\t     gen_rtx_combine\n-\t\t     (ASHIFTRT, mode,\n+\t\t     (unsignedp ? LSHIFTRT : ASHIFTRT, mode,\n \t\t      gen_rtx_combine (ASHIFT, mode,\n \t\t\t\t       gen_lowpart_for_combine (mode, inner),\n \t\t\t\t       GEN_INT (GET_MODE_BITSIZE (mode)\n \t\t\t\t\t\t- len - pos)),\n \t\t      GEN_INT (GET_MODE_BITSIZE (mode) - len)));\n \n-\t      split = find_split_point (&SET_SRC (x));\n+\t      split = find_split_point (&SET_SRC (x), insn);\n \t      if (split && split != &SET_SRC (x))\n \t\treturn split;\n \t    }\n@@ -2249,7 +2363,7 @@ find_split_point (loc)\n \t\t\t\t\t\t   GET_MODE (x),\n \t\t\t\t\t\t   XEXP (XEXP (x, 0), 0),\n \t\t\t\t\t\t   XEXP (XEXP (x, 1), 0))));\n-\t  return find_split_point (loc);\n+\t  return find_split_point (loc, insn);\n \t}\n \n       /* Many RISC machines have a large set of logical insns.  If the\n@@ -2269,14 +2383,14 @@ find_split_point (loc)\n     {\n     case 'b':\t\t\t/* This is ZERO_EXTRACT and SIGN_EXTRACT.  */\n     case '3':\n-      split = find_split_point (&XEXP (x, 2));\n+      split = find_split_point (&XEXP (x, 2), insn);\n       if (split)\n \treturn split;\n       /* ... fall through ... */\n     case '2':\n     case 'c':\n     case '<':\n-      split = find_split_point (&XEXP (x, 1));\n+      split = find_split_point (&XEXP (x, 1), insn);\n       if (split)\n \treturn split;\n       /* ... fall through ... */\n@@ -2286,7 +2400,7 @@ find_split_point (loc)\n       if (GET_CODE (x) != AND && GET_CODE (XEXP (x, 0)) == AND)\n \treturn &XEXP (x, 0);\n \n-      split = find_split_point (&XEXP (x, 0));\n+      split = find_split_point (&XEXP (x, 0), insn);\n       if (split)\n \treturn split;\n       return loc;\n@@ -2464,6 +2578,14 @@ subst (x, from, to, in_dest, unique_copy)\n \t}\n     }\n \n+  /* We come back to here if we have replaced the expression with one of\n+     a different code and it is likely that further simplification will be\n+     possible.  */\n+\n+ restart:\n+\n+  code = GET_CODE (x);\n+\n   /* If this is a commutative operation, put a constant last and a complex\n      expression first.  We don't need to do this for comparisons here.  */\n   if (GET_RTX_CLASS (code) == 'c'\n@@ -2479,6 +2601,41 @@ subst (x, from, to, in_dest, unique_copy)\n       SUBST (XEXP (x, 1), temp);\n     }\n \n+  /* If this is a simple operation applied to an IF_THEN_ELSE, try \n+     applying it to the arms of the IF_THEN_ELSE.  This often simplifies\n+     things.  Don't deal with operations that change modes here.  */\n+\n+  if ((GET_RTX_CLASS (code) == '2' || GET_RTX_CLASS (code) == 'c')\n+      && GET_CODE (XEXP (x, 0)) == IF_THEN_ELSE)\n+    {\n+      SUBST (XEXP (XEXP (x, 0), 1),\n+\t     subst (gen_binary (code, mode, XEXP (XEXP (x, 0), 1),\n+\t\t\t\tXEXP (x, 1)),\n+\t\t    pc_rtx, pc_rtx, 0));\n+      SUBST (XEXP (XEXP (x, 0), 2),\n+\t     subst (gen_binary (code, mode, XEXP (XEXP (x, 0), 2),\n+\t\t\t\tXEXP (x, 1)),\n+\t\t    pc_rtx, pc_rtx, 0));\n+\n+      x = XEXP (x, 0);\n+      goto restart;\n+    }\n+\n+  else if (GET_RTX_CLASS (code) == '1'\n+\t   && GET_CODE (XEXP (x, 0)) == IF_THEN_ELSE\n+\t   && GET_MODE (XEXP (x, 0)) == mode)\n+    {\n+      SUBST (XEXP (XEXP (x, 0), 1),\n+\t     subst (gen_unary (code, mode, XEXP (XEXP (x, 0), 1)),\n+\t\t    pc_rtx, pc_rtx, 0));\n+      SUBST (XEXP (XEXP (x, 0), 2),\n+\t     subst (gen_unary (code, mode, XEXP (XEXP (x, 0), 2)),\n+\t\t    pc_rtx, pc_rtx, 0));\n+\n+      x = XEXP (x, 0);\n+      goto restart;\n+    }\n+\n   /* Try to fold this expression in case we have constants that weren't\n      present before.  */\n   temp = 0;\n@@ -2508,21 +2665,13 @@ subst (x, from, to, in_dest, unique_copy)\n     }\n \n   if (temp)\n-    x = temp;\n-\n-  /* We come back to here if we have replaced the expression with one of\n-     a different code and it is likely that further simplification will be\n-     possible.  */\n-\n- restart:\n+    x = temp, code = GET_CODE (temp);\n \n   /* If we have restarted more than 4 times, we are probably looping, so\n      give up.  */\n   if (++n_restarts > 4)\n     return x;\n \n-  code = GET_CODE (x);\n-\n   /* First see if we can apply the inverse distributive law.  */\n   if (code == PLUS || code == MINUS || code == IOR || code == XOR)\n     {\n@@ -2678,24 +2827,12 @@ subst (x, from, to, in_dest, unique_copy)\n \n       /* If we are narrowing the object, we need to see if we can simplify\n \t the expression for the object knowing that we only need the\n-\t low-order bits.  We do this by computing an AND of the object\n-\t with only the bits we care about.  That will produce any needed\n-\t simplifications.  If the resulting computation is just the\n-\t AND with the significant bits, our operand is the first operand\n-\t of the AND.  Otherwise, it is the resulting expression.  */\n+\t low-order bits.  */\n+\n       if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))\n-\t  && subreg_lowpart_p (x)\n-\t  && (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x)))\n-\t      <= HOST_BITS_PER_WIDE_INT))\n-\t{\n-\t  temp = simplify_and_const_int (NULL_RTX, GET_MODE (SUBREG_REG (x)),\n-\t\t\t\t\t SUBREG_REG (x), GET_MODE_MASK (mode));\n-\t  if (GET_CODE (temp) == AND && GET_CODE (XEXP (temp, 1)) == CONST_INT\n-\t      && INTVAL (XEXP (temp, 1)) == GET_MODE_MASK (mode))\n-\t    temp = XEXP (temp, 0);\n-\t  return gen_lowpart_for_combine (mode, temp);\n-\t}\n-\t\n+\t  && subreg_lowpart_p (x))\n+\treturn force_to_mode (SUBREG_REG (x), mode, GET_MODE_BITSIZE (mode),\n+\t\t\t      NULL_RTX);\n       break;\n \n     case NOT:\n@@ -2714,6 +2851,17 @@ subst (x, from, to, in_dest, unique_copy)\n \t  goto restart;\n \t}\n \n+      /* (not (xor X C)) for C constant is (xor X D) with D = ~ C.  */\n+      if (GET_CODE (XEXP (x, 0)) == XOR\n+\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+\t  && (temp = simplify_unary_operation (NOT, mode,\n+\t\t\t\t\t       XEXP (XEXP (x, 0), 1),\n+\t\t\t\t\t       mode)) != 0)\n+\t{\n+\t  SUBST (XEXP (XEXP (x, 0), 1), temp);\n+\t  return XEXP (x, 0);\n+\t}\n+\t      \n       /* (not (ashift 1 X)) is (rotate ~1 X).  We used to do this for operands\n \t other than 1, but that is not valid.  We could do a similar\n \t simplification for (not (lshiftrt C X)) where C is just the sign bit,\n@@ -2802,23 +2950,6 @@ subst (x, from, to, in_dest, unique_copy)\n \t  goto restart;\n  \t}\n \n-      /* (neg (abs X)) is X if X is a value known to be either -1 or 0.  */\n-      if (GET_CODE (XEXP (x, 0)) == ABS\n-\t  && ((GET_CODE (XEXP (XEXP (x, 0), 0)) == SIGN_EXTRACT\n-\t       && XEXP (XEXP (XEXP (x, 0), 0), 1) == const1_rtx)\n-\t      || (GET_CODE (XEXP (XEXP (x, 0), 0)) == ASHIFTRT\n-\t\t  && GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 1)) == CONST_INT\n-\t\t  && (INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1))\n-\t\t      == GET_MODE_BITSIZE (mode) - 1))\n-\t      || ((temp = get_last_value (XEXP (XEXP (x, 0), 0))) != 0\n-\t\t  && ((GET_CODE (temp) == SIGN_EXTRACT\n-\t\t       && XEXP (temp, 1) == const1_rtx)\n-\t\t      || (GET_CODE (temp) == ASHIFTRT\n-\t\t\t  && GET_CODE (XEXP (temp, 1)) == CONST_INT\n-\t\t\t  && (INTVAL (XEXP (temp, 1))\n-\t\t\t      == GET_MODE_BITSIZE (mode) - 1))))))\n- \treturn XEXP (XEXP (x, 0), 0);\n-\n       /* (neg (minus X Y)) can become (minus Y X).  */\n       if (GET_CODE (XEXP (x, 0)) == MINUS\n \t  && (GET_MODE_CLASS (mode) != MODE_FLOAT\n@@ -2830,6 +2961,14 @@ subst (x, from, to, in_dest, unique_copy)\n \t  goto restart;\n \t}\n \n+      /* (neg (xor A 1)) is (plus A -1) if A is known to be either 0 or 1. */\n+      if (GET_CODE (XEXP (x, 0)) == XOR && XEXP (XEXP (x, 0), 1) == const1_rtx\n+\t  && significant_bits (XEXP (XEXP (x, 0), 0), mode) == 1)\n+\t{\n+\t  x = gen_binary (PLUS, mode, XEXP (XEXP (x, 0), 0), constm1_rtx);\n+\t  goto restart;\n+\t}\n+\n       /* NEG commutes with ASHIFT since it is multiplication.  Only do this\n \t if we can then eliminate the NEG (e.g.,\n \t if the operand is a constant).  */\n@@ -3162,20 +3301,65 @@ subst (x, from, to, in_dest, unique_copy)\n       break;\n \t  \n     case IF_THEN_ELSE:\n+      /* If we are testing a register for equality see if that register is\n+\t used in one of the arms.  If so, and we know something about its\n+\t value in that arm, try to simplify it.  */\n+\n+      if ((GET_CODE (XEXP (x, 0)) == EQ || GET_CODE (XEXP (x, 0)) == NE)\n+\t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG)\n+\t{\n+\t  /* Get the value being compared and the value it has on the equal\n+\t     branch.  */\n+\t  HOST_WIDE_INT sig;\n+\t  rtx from = XEXP (XEXP (x, 0), 0);\n+\t  rtx val_if_eq = XEXP (XEXP (x, 0), 1);\n+\t  rtx val_if_ne = from;\n+\t  int is_eq = (GET_CODE (XEXP (x, 0)) == EQ);\n+\n+\t  /* If we are comparing against zero and the expressiond being tested\n+\t     has only a single significant bit, that is it's value when it is \n+\t     not equal to zero.  Simplilarly if it is known to be -1 or 0.  */\n+\n+\t  if (val_if_eq == const0_rtx\n+\t      && exact_log2 (sig = significant_bits (from,\n+\t\t\t\t\t\t     GET_MODE (from))) >= 0)\n+\t    val_if_ne = GEN_INT (sig);\n+\t  else if (val_if_eq == const0_rtx\n+\t\t   && (num_sign_bit_copies (from, GET_MODE (from))\n+\t\t       == GET_MODE_BITSIZE (GET_MODE (from))))\n+\t    val_if_ne = constm1_rtx;\n+\n+\t  /* Now simplify an arm if we know the value of the register\n+\t     in the branch and it is used in the arm.  Be carefull due to\n+\t     the potential of locally-shared RTL.  */\n+\n+\t  if ((is_eq || val_if_ne != from)\n+\t      && reg_mentioned_p (from, XEXP (x, 1)))\n+\t    SUBST (XEXP (x, 1), subst (copy_rtx (XEXP (x, 1)), from,\n+\t\t\t\t       is_eq ? val_if_eq : val_if_ne, 0));\n+\n+\t  if ((! is_eq || val_if_ne != from)\n+\t      && reg_mentioned_p (from, XEXP (x, 2)))\n+\t    SUBST (XEXP (x, 2), subst (XEXP (x, 2), from,\n+\t\t\t\t       is_eq ? val_if_ne : val_if_eq, 0));\n+\t}\n+      \n       /* If we have (if_then_else FOO (pc) (label_ref BAR)) and FOO can be\n \t reversed, do so to avoid needing two sets of patterns for\n-\t subtract-and-branch insns.  */\n-      if (XEXP (x, 1) == pc_rtx\n+\t subtract-and-branch insns.  Similarly if we have a constant in that\n+\t position.  */\n+      if ((XEXP (x, 1) == pc_rtx || GET_CODE (XEXP (x, 1)) == CONST_INT)\n \t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n \t  && reversible_comparison_p (XEXP (x, 0)))\n \t{\n \t  SUBST (XEXP (x, 0),\n-\t\t gen_rtx_combine (reverse_condition (GET_CODE (XEXP (x, 0))),\n-\t\t\t\t  GET_MODE (XEXP (x, 0)),\n-\t\t\t\t  XEXP (XEXP (x, 0), 0),\n-\t\t\t\t  XEXP (XEXP (x, 0), 1)));\n+\t\t gen_binary (reverse_condition (GET_CODE (XEXP (x, 0))),\n+\t\t\t     GET_MODE (XEXP (x, 0)),\n+\t\t\t     XEXP (XEXP (x, 0), 0), XEXP (XEXP (x, 0), 1)));\n+\n+\t  temp = XEXP (x, 1);\n \t  SUBST (XEXP (x, 1), XEXP (x, 2));\n-\t  SUBST (XEXP (x, 2), pc_rtx);\n+\t  SUBST (XEXP (x, 2), temp);\n \t}\n       break;\n \t  \n@@ -3360,17 +3544,9 @@ subst (x, from, to, in_dest, unique_copy)\n \t      || (GET_CODE (SET_DEST (x)) == SUBREG\n \t\t  && GET_CODE (SUBREG_REG (SET_DEST (x))) == REG)))\n \t{\n-\t  /* Get the object that will be the SUBREG_REG of the\n-\t     SUBREG we are making.  Note that SUBREG_WORD will always\n-\t     be zero because this will either be a paradoxical SUBREG\n-\t     or a SUBREG with the same number of words on the outside and\n-\t     inside.  */\n-\t  rtx object = (GET_CODE (SET_DEST (x)) == REG ? SET_DEST (x)\n-\t\t\t: SUBREG_REG (SET_DEST (x)));\n-\n \t  SUBST (SET_DEST (x),\n-\t\t gen_rtx (SUBREG, GET_MODE (SUBREG_REG (SET_SRC (x))),\n-\t\t\t  object, 0));\n+\t\t gen_lowpart_for_combine (GET_MODE (SUBREG_REG (SET_SRC (x))),\n+\t\t\t\t\t  SET_DEST (x)));\n \t  SUBST (SET_SRC (x), SUBREG_REG (SET_SRC (x)));\n \t}\n \n@@ -3465,7 +3641,30 @@ subst (x, from, to, in_dest, unique_copy)\n \t  goto restart;\n \t}\n \n-      /* In the follow group of tests (and those in case IOR below),\n+      /* If we have (and A B) with A not an object but that is known to\n+\t be -1 or 0, this is equivalent to the expression\n+\t (if_then_else (ne A (const_int 0)) B (const_int 0))\n+\t We make this conversion because it may allow further\n+\t simplifications and then allow use of conditional move insns.  */\n+\n+      if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) != 'o'\n+\t  && ! (GET_CODE (XEXP (x, 0)) == SUBREG\n+\t\t&& GET_RTX_CLASS (GET_CODE (SUBREG_REG (XEXP (x, 0)))) == 'o')\n+\t  && (num_sign_bit_copies (XEXP (x, 0), GET_MODE (XEXP (x, 0)))\n+\t      == GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))))\n+\t{\n+\t  rtx op0 = XEXP (x, 0);\n+\t  rtx op1 = const0_rtx;\n+\t  enum rtx_code comp_code\n+\t    = simplify_comparison (NE, &op0, &op1);\n+\n+\t  x =  gen_rtx_combine (IF_THEN_ELSE, mode,\n+\t\t\t\tgen_binary (comp_code, VOIDmode, op0, op1),\n+\t\t\t\tXEXP (x, 1), const0_rtx);\n+\t  goto restart;\n+\t}\n+\n+      /* In the following group of tests (and those in case IOR below),\n \t we start with some combination of logical operations and apply\n \t the distributive law followed by the inverse distributive law.\n \t Most of the time, this results in no change.  However, if some of\n@@ -3533,6 +3732,12 @@ subst (x, from, to, in_dest, unique_copy)\n       break;\n \n     case IOR:\n+      /* (ior A C) is C if all significant bits of A are on in C.  */\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && (significant_bits (XEXP (x, 0), mode)\n+\t      & ~ INTVAL (XEXP (x, 1))) == 0)\n+\treturn XEXP (x, 1);\n+\n       /* Convert (A & B) | A to A.  */\n       if (GET_CODE (XEXP (x, 0)) == AND\n \t  && (rtx_equal_p (XEXP (XEXP (x, 0), 0), XEXP (x, 1))\n@@ -3613,8 +3818,11 @@ subst (x, from, to, in_dest, unique_copy)\n \t    SUBST (XEXP (x, 1), XEXP (XEXP (x, 1), 0));\n \t  }\n \telse if (num_negated == 1)\n-\t  return gen_rtx_combine (NOT, mode,\n-\t\t\t  gen_rtx_combine (XOR, mode, in1, in2));\n+\t  {\n+\t    x =  gen_unary (NOT, mode,\n+\t\t\t    gen_binary (XOR, mode, in1, in2));\n+\t    goto restart;\n+\t  }\n       }\n \n       /* Convert (xor (and A B) B) to (and (not A) B).  The latter may\n@@ -3682,18 +3890,7 @@ subst (x, from, to, in_dest, unique_copy)\n \n \n       /* If operand is known to be only -1 or 0, convert ABS to NEG.  */\n-      if ((GET_CODE (XEXP (x, 0)) == SIGN_EXTRACT\n-\t   && XEXP (XEXP (x, 0), 1) == const1_rtx)\n-\t  || (GET_CODE (XEXP (x, 0)) == ASHIFTRT\n-\t      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-\t      && INTVAL (XEXP (XEXP (x, 0), 1)) == GET_MODE_BITSIZE (mode) - 1)\n-\t  || ((temp = get_last_value (XEXP (x, 0))) != 0\n-\t      && ((GET_CODE (temp) == SIGN_EXTRACT\n-\t\t   && XEXP (temp, 1) == const1_rtx)\n-\t\t  || (GET_CODE (temp) == ASHIFTRT\n-\t\t      && GET_CODE (XEXP (temp, 1)) == CONST_INT\n-\t\t      && (INTVAL (XEXP (temp, 1))\n-\t\t\t  == GET_MODE_BITSIZE (mode) - 1)))))\n+      if (num_sign_bit_copies (XEXP (x, 0), mode) == GET_MODE_BITSIZE (mode))\n \t{\n \t  x = gen_rtx_combine (NEG, mode, XEXP (x, 0));\n \t  goto restart;\n@@ -4095,7 +4292,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t\t\t   / UNITS_PER_WORD))\n \t\t       : 0);\n       else\n-\tnew = gen_lowpart_for_combine (tmode, inner);\n+\tnew = force_to_mode (inner, tmode, len, NULL_RTX);\n \n       /* If this extraction is going into the destination of a SET, \n \t make a STRICT_LOW_PART unless we made a MEM.  */\n@@ -4114,7 +4311,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t\t\t\t mode, new));\n     }\n \n-  /* Unless this is in a COMPARE or we have a funny memory reference,\n+  /* Unless this isin a COMPARE or we have a funny memory reference,\n      don't do anything with field extracts starting at the low-order\n      bit since they are simple AND operations.  */\n   if (pos == 0 && ! in_dest && ! in_compare && ! spans_byte)\n@@ -4232,7 +4429,10 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \n   /* If INNER is not memory, we can always get it into the proper mode. */\n   else if (GET_CODE (inner) != MEM)\n-    inner = gen_lowpart_for_combine (extraction_mode, inner);\n+    inner = force_to_mode (inner, extraction_mode,\n+\t\t\t   (pos < 0 ? GET_MODE_BITSIZE (extraction_mode)\n+\t\t\t    : len + pos),\n+\t\t\t   NULL_RTX);\n \n   /* Adjust mode of POS_RTX, if needed.  If we want a wider mode, we\n      have to zero extend.  Otherwise, we can just use a SUBREG.  */\n@@ -4283,7 +4483,7 @@ make_compound_operation (x, in_code)\n   enum machine_mode mode = GET_MODE (x);\n   int mode_width = GET_MODE_BITSIZE (mode);\n   enum rtx_code next_code;\n-  int i;\n+  int i, count;\n   rtx new = 0;\n   char *fmt;\n \n@@ -4353,17 +4553,9 @@ make_compound_operation (x, in_code)\n       /* On machines without logical shifts, if the operand of the AND is\n \t a logical shift and our mask turns off all the propagated sign\n \t bits, we can replace the logical shift with an arithmetic shift.  */\n-      else if (\n-#ifdef HAVE_ashrsi3\n-\t       HAVE_ashrsi3\n-#else\n-\t       0\n-#endif\n-#ifdef HAVE_lshrsi3\n-\t       && ! HAVE_lshrsi3\n-#else\n-\t       && 1\n-#endif\n+      else if (ashr_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing\n+\t       && (lshr_optab->handlers[(int) mode].insn_code\n+\t\t   == CODE_FOR_nothing)\n \t       && GET_CODE (XEXP (x, 0)) == LSHIFTRT\n \t       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n \t       && INTVAL (XEXP (XEXP (x, 0), 1)) >= 0\n@@ -4398,17 +4590,8 @@ make_compound_operation (x, in_code)\n     case LSHIFTRT:\n       /* If the sign bit is known to be zero, replace this with an\n \t arithmetic shift.  */\n-      if (\n-#ifdef HAVE_ashrsi3\n-\t  HAVE_ashrsi3\n-#else\n-\t  0\n-#endif\n-#ifdef HAVE_lshrsi3\n-\t  && ! HAVE_lshrsi3\n-#else\n-\t  && 1\n-#endif\n+      if (ashr_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing\n+\t  && lshr_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing\n \t  && mode_width <= HOST_BITS_PER_WIDE_INT\n \t  && (significant_bits (XEXP (x, 0), mode)\n \t      & (1 << (mode_width - 1))) == 0)\n@@ -4431,6 +4614,37 @@ make_compound_operation (x, in_code)\n \t\t\t\t- INTVAL (XEXP (XEXP (x, 0), 1))),\n \t\t\t       NULL_RTX, mode_width - INTVAL (XEXP (x, 1)),\n \t\t\t       code == LSHIFTRT, 0, in_code == COMPARE);\n+\n+      /* Similarly if we have (ashifrt (OP (ashift foo C1) C3) C2).  In these\n+\t cases, we are better off returning a SIGN_EXTEND of the operation.  */\n+\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && (GET_CODE (XEXP (x, 0)) == IOR || GET_CODE (XEXP (x, 0)) == AND\n+\t      || GET_CODE (XEXP (x, 0)) == XOR\n+\t      || GET_CODE (XEXP (x, 0)) == PLUS)\n+\t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == ASHIFT\n+\t  && GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 1)) == CONST_INT\n+\t  && INTVAL (XEXP (x, 1)) >= INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1))\n+\t  && INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1)) < HOST_BITS_PER_WIDE_INT\n+\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+\t  && (INTVAL (XEXP (XEXP (x, 0), 1))\n+\t      & (((HOST_WIDE_INT) 1\n+\t\t  << INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1))) - 1)) == 0)\n+\t{\n+\t  HOST_WIDE_INT newop1\n+\t    = (INTVAL (XEXP (XEXP (x, 0), 1))\n+\t       >> INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1)));\n+\n+\t  new = make_extraction (mode,\n+\t\t\t\t gen_binary (GET_CODE (XEXP (x, 0)), mode,\n+\t\t\t\t\t     XEXP (XEXP (XEXP (x, 0), 0), 0),\n+\t\t\t\t\t     GEN_INT (newop1)),\n+\t\t\t\t (INTVAL (XEXP (x, 1))\n+\t\t\t\t  - INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1))),\n+\t\t\t\t NULL_RTX, mode_width - INTVAL (XEXP (x, 1)),\n+\t\t\t\t code == LSHIFTRT, 0, in_code == COMPARE);\n+\t}\n+\n       break;\n     }\n \n@@ -4495,6 +4709,7 @@ force_to_mode (x, mode, bits, reg)\n      rtx reg;\n {\n   enum rtx_code code = GET_CODE (x);\n+  enum machine_mode op_mode = mode;\n \n   /* If X is narrower than MODE or if BITS is larger than the size of MODE,\n      just get X in the proper mode.  */\n@@ -4551,7 +4766,13 @@ force_to_mode (x, mode, bits, reg)\n \t  if (bits < HOST_BITS_PER_WIDE_INT)\n \t    mask &= ((HOST_WIDE_INT) 1 << bits) - 1;\n \n-\t  x = simplify_and_const_int (x, mode, op, mask);\n+\t  /* If we have no AND in MODE, use the original mode for the\n+\t     operation.  */\n+\n+\t  if (and_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing)\n+\t    op_mode = GET_MODE (x);\n+\n+\t  x = simplify_and_const_int (x, op_mode, op, mask);\n \n \t  /* If X is still an AND, see if it is an AND with a mask that\n \t     is just some low-order bits.  If so, and it is BITS wide (it\n@@ -4561,7 +4782,8 @@ force_to_mode (x, mode, bits, reg)\n \t      && bits < HOST_BITS_PER_WIDE_INT\n \t      && INTVAL (XEXP (x, 1)) == ((HOST_WIDE_INT) 1 << bits) - 1)\n \t    x = XEXP (x, 0);\n-\t  return x;\n+\n+\t  break;\n \t}\n \n       /* ... fall through ... */\n@@ -4572,11 +4794,30 @@ force_to_mode (x, mode, bits, reg)\n     case IOR:\n     case XOR:\n       /* For most binary operations, just propagate into the operation and\n-\t change the mode.  */\n-\n-      return gen_binary (code, mode,\n-\t\t\t force_to_mode (XEXP (x, 0), mode, bits, reg),\n-\t\t\t force_to_mode (XEXP (x, 1), mode, bits, reg));\n+\t change the mode if we have an operation of that mode.  */\n+\n+      if ((code == PLUS\n+\t   && add_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing)\n+\t  || (code == MINUS\n+\t      && sub_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing)\n+\t  || (code == MULT && (smul_optab->handlers[(int) mode].insn_code\n+\t\t\t       == CODE_FOR_nothing))\n+\t  || (code == IOR\n+\t      && ior_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing)\n+\t  || (code == XOR && (xor_optab->handlers[(int) mode].insn_code\n+\t\t\t      == CODE_FOR_nothing)))\n+\top_mode = GET_MODE (x);\n+\n+      x = gen_binary (code, op_mode,\n+\t\t      gen_lowpart_for_combine (op_mode,\n+\t\t\t\t\t       force_to_mode (XEXP (x, 0),\n+\t\t\t\t\t\t\t      mode, bits,\n+\t\t\t\t\t\t\t      reg)),\n+\t\t      gen_lowpart_for_combine (op_mode,\n+\t\t\t\t\t       force_to_mode (XEXP (x, 1),\n+\t\t\t\t\t\t\t      mode, bits,\n+\t\t\t\t\t\t\t      reg)));\n+      break;\n \n     case ASHIFT:\n     case LSHIFT:\n@@ -4587,9 +4828,19 @@ force_to_mode (x, mode, bits, reg)\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT && INTVAL (XEXP (x, 1)) < bits)\n \tbits -= INTVAL (XEXP (x, 1));\n \n-      return gen_binary (code, mode,\n-\t\t\t force_to_mode (XEXP (x, 0), mode, bits, reg),\n-\t\t\t XEXP (x, 1));\n+      if ((code == ASHIFT\n+\t   && ashl_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing)\n+\t  || (code == LSHIFT && (lshl_optab->handlers[(int) mode].insn_code\n+\t\t\t\t == CODE_FOR_nothing)))\n+\top_mode = GET_MODE (x);\n+\n+      x =  gen_binary (code, op_mode,\n+\t\t       gen_lowpart_for_combine (op_mode,\n+\t\t\t\t\t\tforce_to_mode (XEXP (x, 0),\n+\t\t\t\t\t\t\t       mode, bits,\n+\t\t\t\t\t\t\t       reg)),\n+\t\t       XEXP (x, 1));\n+      break;\n \n     case LSHIFTRT:\n       /* Here we can only do something if the shift count is a constant and\n@@ -4598,20 +4849,63 @@ force_to_mode (x, mode, bits, reg)\n \n       if (GET_CODE (XEXP (x, 1)) == CONST_INT\n \t  && INTVAL (XEXP (x, 1)) + bits <= GET_MODE_BITSIZE (mode))\n-\treturn gen_binary (LSHIFTRT, mode,\n-\t\t\t   force_to_mode (XEXP (x, 0), mode,\n-\t\t\t\t\t  bits + INTVAL (XEXP (x, 1)), reg),\n-\t\t\t   XEXP (x, 1));\n+\t{\n+\t  rtx inner = force_to_mode (XEXP (x, 0), mode,\n+\t\t\t\t     bits + INTVAL (XEXP (x, 1)), reg);\n+\n+\t  if (lshr_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing)\n+\t    op_mode = GET_MODE (x);\n+\n+\t  x = gen_binary (LSHIFTRT, op_mode,\n+\t\t\t  gen_lowpart_for_combine (op_mode, inner),\n+\t\t\t  XEXP (x, 1));\n+\t}\n+      break;\n+\n+    case ASHIFTRT:\n+      /* If this is a sign-extension operation that just affects bits\n+\t we don't care about, remove it.  */\n+\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && INTVAL (XEXP (x, 1)) >= 0\n+\t  && INTVAL (XEXP (x, 1)) <= GET_MODE_BITSIZE (GET_MODE (x)) - bits\n+\t  && GET_CODE (XEXP (x, 0)) == ASHIFT\n+\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+\t  && INTVAL (XEXP (XEXP (x, 0), 1)) == INTVAL (XEXP (x, 1)))\n+\treturn force_to_mode (XEXP (XEXP (x, 0), 0), mode, bits, reg);\n       break;\n \n     case NEG:\n     case NOT:\n+      if ((code == NEG\n+\t   && neg_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing)\n+\t  || (code == NOT && (one_cmpl_optab->handlers[(int) mode].insn_code\n+\t\t\t      == CODE_FOR_nothing)))\n+\top_mode = GET_MODE (x);\n+\n       /* Handle these similarly to the way we handle most binary operations. */\n-      return gen_unary (code, mode,\n-\t\t\tforce_to_mode (XEXP (x, 0), mode, bits, reg));\n+      x = gen_unary (code, op_mode,\n+\t\t     gen_lowpart_for_combine (op_mode,\n+\t\t\t\t\t      force_to_mode (XEXP (x, 0), mode,\n+\t\t\t\t\t\t\t     bits, reg)));\n+      break;\n+\n+    case IF_THEN_ELSE:\n+      /* We have no way of knowing if the IF_THEN_ELSE can itself be\n+\t written in a narrower mode.  We play it safe and do not do so.  */\n+\n+      SUBST (XEXP (x, 1),\n+\t     gen_lowpart_for_combine (GET_MODE (x),\n+\t\t\t\t      force_to_mode (XEXP (x, 1), mode,\n+\t\t\t\t\t\t     bits, reg)));\n+      SUBST (XEXP (x, 2),\n+\t     gen_lowpart_for_combine (GET_MODE (x),\n+\t\t\t\t      force_to_mode (XEXP (x, 2), mode,\n+\t\t\t\t\t\t     bits, reg)));\n+      break;\n     }\n \n-  /* Otherwise, just do the operation canonically.  */\n+  /* Ensure we return a value of the proper mode.  */\n   return gen_lowpart_for_combine (mode, x);\n }\n \f\n@@ -5243,17 +5537,20 @@ significant_bits (x, mode)\n       break;\n #endif\n \n-#if STORE_FLAG_VALUE == -1\n     case NEG:\n-      if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-\t  || ((tem = get_last_value (XEXP (x, 0))) != 0\n-\t      && GET_RTX_CLASS (GET_CODE (tem)) == '<'))\n+      if (num_sign_bit_copies (XEXP (x, 0), GET_MODE (x))\n+\t  == GET_MODE_BITSIZE (GET_MODE (x)))\n \tsignificant = 1;\n \n       if (GET_MODE_SIZE (GET_MODE (x)) < mode_width)\n \tsignificant |= (GET_MODE_MASK (mode) & ~ GET_MODE_MASK (GET_MODE (x)));\n       break;\n-#endif\n+\n+    case ABS:\n+      if (num_sign_bit_copies (XEXP (x, 0), GET_MODE (x))\n+\t  == GET_MODE_BITSIZE (GET_MODE (x)))\n+\tsignificant = 1;\n+      break;\n \n     case TRUNCATE:\n       significant &= (significant_bits (XEXP (x, 0), mode)\n@@ -5289,8 +5586,8 @@ significant_bits (x, mode)\n \t\t      & significant_bits (XEXP (x, 1), mode));\n       break;\n \n-    case XOR:\n-    case IOR:\n+    case XOR:   case IOR:\n+    case UMIN:  case UMAX:  case SMIN:  case SMAX:\n       significant &= (significant_bits (XEXP (x, 0), mode)\n \t\t      | significant_bits (XEXP (x, 1), mode));\n       break;\n@@ -5434,11 +5731,236 @@ significant_bits (x, mode)\n       /* This is at most the number of bits in the mode.  */\n       significant = ((HOST_WIDE_INT) 1 << (floor_log2 (mode_width) + 1)) - 1;\n       break;\n+\n+    case IF_THEN_ELSE:\n+      significant &= (significant_bits (XEXP (x, 1), mode)\n+\t\t      | significant_bits (XEXP (x, 2), mode));\n+      break;\n     }\n \n   return significant;\n }\n \f\n+/* Return the number of bits at the high-order end of X that are known to\n+   be equal to the sign bit.  This number will always be between 1 and\n+   the number of bits in the mode of X.  MODE is the mode to be used\n+   if X is VOIDmode.  */\n+\n+static int\n+num_sign_bit_copies (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  int bitwidth;\n+  int num0, num1, result;\n+  unsigned HOST_WIDE_INT sig;\n+  rtx tem;\n+\n+  /* If we weren't given a mode, use the mode of X.  If the mode is still\n+     VOIDmode, we don't know anything.  */\n+\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (x);\n+\n+  if (mode == VOIDmode)\n+    return 0;\n+\n+  bitwidth = GET_MODE_BITSIZE (mode);\n+\n+  switch (code)\n+    {\n+    case REG:\n+      if (significant_valid && reg_sign_bit_copies[REGNO (x)] != 0)\n+\treturn reg_sign_bit_copies[REGNO (x)];\n+\n+      tem =  get_last_value (x);\n+      if (tem != 0)\n+\treturn num_sign_bit_copies (tem, mode);\n+      break;\n+\n+    case CONST_INT:\n+      /* If the constant is negative, take its 1's complement and remask.\n+\t Then see how many zero bits we have.  */\n+      sig = INTVAL (x) & GET_MODE_MASK (mode);\n+      if (sig & ((HOST_WIDE_INT) 1 << (bitwidth - 1)))\n+\tsig = (~ sig) & GET_MODE_MASK (mode);\n+\n+      return (sig == 0 ? bitwidth : bitwidth - floor_log2 (sig) - 1);\n+\n+    case SUBREG:\n+      /* For a smaller object, just ignore the high bits. */\n+      if (bitwidth <= GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x))))\n+\t{\n+\t  num0 = num_sign_bit_copies (SUBREG_REG (x), VOIDmode);\n+\t  return MAX (1, (num0\n+\t\t\t  - (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x)))\n+\t\t\t     - bitwidth)));\n+\t}\n+      break;\n+\n+    case SIGN_EXTRACT:\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\treturn MAX (1, bitwidth - INTVAL (XEXP (x, 1)));\n+      break;\n+\n+    case SIGN_EXTEND: \n+      return (bitwidth - GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n+\t      + num_sign_bit_copies (XEXP (x, 0), VOIDmode));\n+\n+    case TRUNCATE:\n+      /* For a smaller object, just ignore the high bits. */\n+      num0 = num_sign_bit_copies (XEXP (x, 0), VOIDmode);\n+      return MAX (1, (num0 - (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n+\t\t\t      - bitwidth)));\n+\n+    case NOT:\n+      return num_sign_bit_copies (XEXP (x, 0), mode);\n+\n+    case ROTATE:       case ROTATERT:\n+      /* If we are rotating left by a number of bits less than the number\n+\t of sign bit copies, we can just subtract that amount from the\n+\t number.  */\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && INTVAL (XEXP (x, 1)) >= 0 && INTVAL (XEXP (x, 1)) < bitwidth)\n+\t{\n+\t  num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n+\t  return MAX (1, num0 - (code == ROTATE ? INTVAL (XEXP (x, 1))\n+\t\t\t\t : bitwidth - INTVAL (XEXP (x, 1))));\n+\t}\n+      break;\n+\n+    case NEG:\n+      /* In general, this subtracts one sign bit copy.  But if the value\n+\t is known to be positive, the number of sign bit copies is the\n+\t same as that of the input.  Finally, if the input has just one\n+\t significant bit, all the bits are copies of the sign bit.  */\n+      sig = significant_bits (XEXP (x, 0), mode);\n+      if (sig == 1)\n+\treturn bitwidth;\n+\n+      num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n+      if (num0 > 1\n+\t  && (((HOST_WIDE_INT) 1 << (bitwidth - 1)) & sig))\n+\tnum0--;\n+\n+      return num0;\n+\n+    case IOR:   case AND:   case XOR:\n+    case SMIN:  case SMAX:  case UMIN:  case UMAX:\n+      /* Logical operations will preserve the number of sign-bit copies.\n+\t MIN and MAX operations always return one of the operands.  */\n+      num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n+      num1 = num_sign_bit_copies (XEXP (x, 1), mode);\n+      return MIN (num0, num1);\n+\n+    case PLUS:  case MINUS:\n+      /* For addition and subtraction, we can have a 1-bit carry.  However,\n+\t if we are subtracting 1 from a positive number, there will not\n+\t be such a carry.  Furthermore, if the positive number is known to\n+\t be 0 or 1, we know the result is either -1 or 0.  */\n+\n+      if (code == PLUS && XEXP (x, 1) == constm1_rtx)\n+\t{\n+\t  sig = significant_bits (XEXP (x, 0), mode);\n+\t  if ((((HOST_WIDE_INT) 1 << (bitwidth - 1)) & sig) == 0)\n+\t    return (sig == 1 || sig == 0 ? bitwidth\n+\t\t    : bitwidth - floor_log2 (sig));\n+\t}\n+\n+      num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n+      num1 = num_sign_bit_copies (XEXP (x, 1), mode);\n+      return MAX (1, MIN (num0, num1) - 1);\n+      \n+    case MULT:\n+      /* The number of bits of the product is the sum of the number of\n+\t bits of both terms.  However, unless one of the terms if known\n+\t to be positive, we must allow for an additional bit since negating\n+\t a negative number can remove one sign bit copy.  */\n+\n+      num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n+      num1 = num_sign_bit_copies (XEXP (x, 1), mode);\n+\n+      result = bitwidth - (bitwidth - num0) - (bitwidth - num1);\n+      if (result > 0\n+\t  && ((significant_bits (XEXP (x, 0), mode)\n+\t       & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n+\t  && (significant_bits (XEXP (x, 1), mode)\n+\t      & ((HOST_WIDE_INT) 1 << (bitwidth - 1)) != 0))\n+\tresult--;\n+\n+      return MAX (1, result);\n+\n+    case UDIV:\n+      /* The result must be <= the first operand.  */\n+      return num_sign_bit_copies (XEXP (x, 0), mode);\n+\n+    case UMOD:\n+      /* The result must be <= the scond operand.  */\n+      return num_sign_bit_copies (XEXP (x, 1), mode);\n+\n+    case DIV:\n+      /* Similar to unsigned division, except that we have to worry about\n+\t the case where the divisor is negative, in which case we have\n+\t to add 1.  */\n+      result = num_sign_bit_copies (XEXP (x, 0), mode);\n+      if (result > 1\n+\t  && (significant_bits (XEXP (x, 1), mode)\n+\t      & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n+\tresult --;\n+\n+      return result;\n+\n+    case MOD:\n+      result = num_sign_bit_copies (XEXP (x, 1), mode);\n+      if (result > 1\n+\t  && (significant_bits (XEXP (x, 1), mode)\n+\t      & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n+\tresult --;\n+\n+      return result;\n+\n+    case ASHIFTRT:\n+      /* Shifts by a constant add to the number of bits equal to the\n+\t sign bit.  */\n+      num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && INTVAL (XEXP (x, 1)) > 0)\n+\tnum0 = MIN (bitwidth, num0 + INTVAL (XEXP (x, 1)));\n+\n+      return num0;\n+\n+    case ASHIFT:\n+    case LSHIFT:\n+      /* Left shifts destroy copies.  */\n+      if (GET_CODE (XEXP (x, 1)) != CONST_INT\n+\t  || INTVAL (XEXP (x, 1)) < 0\n+\t  || INTVAL (XEXP (x, 1)) >= bitwidth)\n+\treturn 1;\n+\n+      num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n+      return MAX (1, num0 - INTVAL (XEXP (x, 1)));\n+\n+    case IF_THEN_ELSE:\n+      num0 = num_sign_bit_copies (XEXP (x, 1), mode);\n+      num1 = num_sign_bit_copies (XEXP (x, 2), mode);\n+      return MIN (num0, num1);\n+\n+#if STORE_FLAG_VALUE == -1\n+    case EQ:  case NE:  case GE:  case GT:  case LE:  case LT:\n+    case GEU: case GTU: case LEU: case LTU:\n+      return bitwidth;\n+#endif\n+    }\n+\n+  /* If we haven't been able to figure it out by one of the above rules,\n+     see if some of the high-order bits are known to be zero.  If so,\n+     count those bits and return one less than that amount.  */\n+\n+  sig = significant_bits (x, mode);\n+  return sig == GET_MODE_MASK (mode) ? 1 : bitwidth - floor_log2 (sig) - 1;\n+}\n+\f\n /* This function is called from `simplify_shift_const' to merge two\n    outer operations.  Specifically, we have already found that we need\n    to perform operation *POP0 with constant *PCONST0 at the outermost\n@@ -5667,6 +6189,16 @@ simplify_shift_const (x, code, result_mode, varop, count)\n       else if (count < 0)\n \tabort ();\n \n+      /* An arithmetic right shift of a quantity known to be -1 or 0\n+\t is a no-op.  */\n+      if (code == ASHIFTRT\n+\t  && (num_sign_bit_copies (varop, shift_mode)\n+\t      == GET_MODE_BITSIZE (shift_mode)))\n+\t{\n+\t  count = 0;\n+\t  break;\n+\t}\n+\n       /* We simplify the tests below and elsewhere by converting\n \t ASHIFTRT to LSHIFTRT if we know the sign bit is clear.\n \t `make_compound_operation' will convert it to a ASHIFTRT for\n@@ -5842,42 +6374,23 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t\t  continue;\n \t\t}\n \t      \n-\t      /* If this was (ashiftrt (ashift foo C1) C2) and we know\n-\t\t something about FOO's previous value, we may be able to\n-\t\t optimize this even though the code below can't handle this\n-\t\t case.\n-\n-\t\t If FOO has J high-order bits equal to the sign bit with\n-\t\t J > C1, then we can convert this to either an ASHIFT or\n-\t\t a ASHIFTRT depending on the two counts. \n+\t      /* If this was (ashiftrt (ashift foo C1) C2) and FOO has more\n+\t\t than C1 high-order bits equal to the sign bit, we can convert\n+\t\t this to either an ASHIFT or a ASHIFTRT depending on the\n+\t\t two counts. \n \n \t\t We cannot do this if VAROP's mode is not SHIFT_MODE.  */\n \n \t      if (code == ASHIFTRT && first_code == ASHIFT\n \t\t  && GET_MODE (varop) == shift_mode\n-\t\t  && (inner = get_last_value (XEXP (varop, 0))) != 0)\n+\t\t  && (num_sign_bit_copies (XEXP (varop, 0), shift_mode)\n+\t\t      > first_count))\n \t\t{\n-\t\t  if ((GET_CODE (inner) == CONST_INT\n-\t\t       && (((INTVAL (inner)\n-\t\t\t     >> (HOST_BITS_PER_WIDE_INT - (first_count + 1)))\n-\t\t\t    == 0)\n-\t\t\t   || ((INTVAL (inner)\n-\t\t\t\t>> (HOST_BITS_PER_WIDE_INT - (first_count + 1)))\n-\t\t\t       == -1)))\n-\t\t      || (GET_CODE (inner) == SIGN_EXTEND\n-\t\t\t  && ((GET_MODE_BITSIZE (GET_MODE (inner))\n-\t\t\t       - GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (inner))))\n-\t\t\t      >= first_count))\n-\t\t      || (GET_CODE (inner) == ASHIFTRT\n-\t\t\t  && GET_CODE (XEXP (inner, 1)) == CONST_INT\n-\t\t\t  && INTVAL (XEXP (inner, 1)) >= first_count))\n-\t\t    {\n-\t\t      count -= first_count;\n-\t\t      if (count < 0)\n-\t\t\tcount = - count, code = ASHIFT;\n-\t\t      varop = XEXP (varop, 0);\n-\t\t      continue;\n-\t\t    }\n+\t\t  count -= first_count;\n+\t\t  if (count < 0)\n+\t\t    count = - count, code = ASHIFT;\n+\t\t  varop = XEXP (varop, 0);\n+\t\t  continue;\n \t\t}\n \n \t      /* There are some cases we can't do.  If CODE is ASHIFTRT,\n@@ -6062,11 +6575,12 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t  break;\n \n \tcase NEG:\n-\t  /* If we are doing an arithmetic right shift of something known\n-\t     to be -1 or 0, we don't need the shift.  */\n-\t  if (code == ASHIFTRT\n+\t  /* (lshiftrt (neg A) C) where A is either 0 or 1 and C is one less\n+\t     than the number of bits in the mode is equivalent to A.  */\n+\t  if (code == LSHIFTRT && count == GET_MODE_BITSIZE (result_mode) - 1\n \t      && significant_bits (XEXP (varop, 0), result_mode) == 1)\n \t    {\n+\t      varop = XEXP (varop, 0);\n \t      count = 0;\n \t      continue;\n \t    }\n@@ -6084,17 +6598,9 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t  break;\n \n \tcase PLUS:\n-\t  /* Similar to case above.  If X is 0 or 1 then X - 1 is -1 or 0.  */\n-\t  if (XEXP (varop, 1) == constm1_rtx && code == ASHIFTRT\n-\t      && significant_bits (XEXP (varop, 0), result_mode) == 1)\n-\t    {\n-\t      count = 0;\n-\t      continue;\n-\t    }\n-\n-\t  /* If we have the same operands as above but we are shifting the\n-\t     sign bit into the low-order bit, we are exclusive-or'ing\n-\t     the operand of the PLUS with a one.  */\n+\t  /* (lshiftrt (plus A -1) C) where A is either 0 or 1 and C\n+\t     is one less than the number of bits in the mode is\n+\t     equivalent to (xor A 1).  */\n \t  if (code == LSHIFTRT && count == GET_MODE_BITSIZE (result_mode) - 1\n \t      && XEXP (varop, 1) == constm1_rtx\n \t      && significant_bits (XEXP (varop, 0), result_mode) == 1\n@@ -6710,6 +7216,18 @@ simplify_comparison (code, pop0, pop1)\n \t  op1 = const0_rtx, const_op = 0;\n \t}\n \n+      /* Similarly, if we are comparing a value known to be either -1 or\n+\t 0 with -1, change it to the opposite comparison against zero.  */\n+\n+      if (const_op == -1\n+\t  && (code == EQ || code == NE || code == GT || code == LE\n+\t      || code == GEU || code == LTU)\n+\t  && num_sign_bit_copies (op0, mode) == mode_width)\n+\t{\n+\t  code = (code == EQ || code == LE || code == GEU ? NE : EQ);\n+\t  op1 = const0_rtx, const_op = 0;\n+\t}\n+\n       /* Do some canonicalizations based on the comparison code.  We prefer\n \t comparisons against zero and then prefer equality comparisons.  \n \t If we can reduce the size of a constant, we will do that too.  */\n@@ -6785,13 +7303,28 @@ simplify_comparison (code, pop0, pop1)\n \t      code = LEU;\n \t      /* ... fall through ... */\n \t    }\n+\n+\t  /* (unsigned) < 0x80000000 is equivalent to >= 0.  */\n+\t  else if (const_op == (HOST_WIDE_INT) 1 << (mode_width - 1))\n+\t    {\n+\t      const_op = 0, op1 = const0_rtx;\n+\t      code = GE;\n+\t      break;\n+\t    }\n \t  else\n \t    break;\n \n \tcase LEU:\n \t  /* unsigned <= 0 is equivalent to == 0 */\n \t  if (const_op == 0)\n \t    code = EQ;\n+\n+\t  /* (unsigned) <= 0x7fffffff is equivalent to >= 0. */\n+\t  else if (const_op == ((HOST_WIDE_INT) 1 << (mode_width - 1)) - 1)\n+\t    {\n+\t      const_op = 0, op1 = const0_rtx;\n+\t      code = GE;\n+\t    }\n \t  break;\n \n \tcase GEU:\n@@ -6803,13 +7336,27 @@ simplify_comparison (code, pop0, pop1)\n \t      code = GTU;\n \t      /* ... fall through ... */\n \t    }\n+\n+\t  /* (unsigned) >= 0x80000000 is equivalent to < 0.  */\n+\t  else if (const_op == (HOST_WIDE_INT) 1 << (mode_width - 1))\n+\t    {\n+\t      const_op = 0, op1 = const0_rtx;\n+\t      code = LT;\n+\t    }\n \t  else\n \t    break;\n \n \tcase GTU:\n \t  /* unsigned > 0 is equivalent to != 0 */\n \t  if (const_op == 0)\n \t    code = NE;\n+\n+\t  /* (unsigned) > 0x7fffffff is equivalent to < 0.  */\n+\t  else if (const_op == ((HOST_WIDE_INT) 1 << (mode_width - 1)) - 1)\n+\t    {\n+\t      const_op = 0, op1 = const0_rtx;\n+\t      code = LT;\n+\t    }\n \t  break;\n \t}\n \n@@ -7243,6 +7790,17 @@ simplify_comparison (code, pop0, pop1)\n \t  break;\n \n \tcase ASHIFTRT:\n+\t  /* If this is an equality comparison with zero, we can do this\n+\t     as a logical shift, which might be much simpler.  */\n+\t  if (equality_comparison_p && const_op == 0\n+\t      && GET_CODE (XEXP (op0, 1)) == CONST_INT)\n+\t    {\n+\t      op0 = simplify_shift_const (NULL_RTX, LSHIFTRT, mode,\n+\t\t\t\t\t  XEXP (op0, 0),\n+\t\t\t\t\t  INTVAL (XEXP (op0, 1)));\n+\t      continue;\n+\t    }\n+\n \t  /* If OP0 is a sign extension and CODE is not an unsigned comparison,\n \t     do the comparison in a narrower mode.  */\n \t  if (! unsigned_comparison_p\n@@ -7530,10 +8088,9 @@ record_dead_and_set_regs_1 (dest, setter)\n \t       && GET_CODE (SET_DEST (setter)) == SUBREG\n \t       && SUBREG_REG (SET_DEST (setter)) == dest\n \t       && subreg_lowpart_p (SET_DEST (setter)))\n-\trecord_value_for_reg\n-\t  (dest, record_dead_insn,\n-\t   gen_lowpart_for_combine (GET_MODE (SET_DEST (setter)),\n-\t\t\t\t    SET_SRC (setter)));\n+\trecord_value_for_reg (dest, record_dead_insn,\n+\t\t\t      gen_lowpart_for_combine (GET_MODE (dest),\n+\t\t\t\t\t\t       SET_SRC (setter)));\n       else\n \trecord_value_for_reg (dest, record_dead_insn, NULL_RTX);\n     }\n@@ -7652,16 +8209,50 @@ get_last_value (x)\n   regno = REGNO (x);\n   value = reg_last_set_value[regno];\n \n-  /* If we don't have a value, it isn't for this basic block, or if it was\n-     set in a later insn that the ones we are processing, return 0.  */\n+  /* If we don't have a value or if it isn't for this basic block, return 0. */\n \n   if (value == 0\n       || (reg_n_sets[regno] != 1\n-\t  && (reg_last_set_label[regno] != label_tick\n-\t      || INSN_CUID (reg_last_set[regno]) >= subst_low_cuid)))\n+\t  && (reg_last_set_label[regno] != label_tick)))\n     return 0;\n \n-  /* If the value has all its register valid, return it.  */\n+  /* If the value was set in a later insn that the ones we are processing,\n+     we can't use it, but make a quick check to see if the previous insn\n+     set it to something.  This is commonly the case when the same pseudo\n+     is used by repeated insns.  */\n+\n+  if (reg_n_sets[regno] != 1\n+      && INSN_CUID (reg_last_set[regno]) >= subst_low_cuid)\n+    {\n+      rtx insn, set;\n+\n+      for (insn = prev_active_insn (subst_insn);\n+\t   insn && INSN_CUID (insn) >= subst_low_cuid;\n+\t   insn = prev_active_insn (insn))\n+\t;\n+\n+      if (insn\n+\t  && (set = single_set (insn)) != 0\n+\t  && rtx_equal_p (SET_DEST (set), x))\n+\t{\n+\t  value = SET_SRC (set);\n+\n+\t  /* Make sure that VALUE doesn't reference X.  Replace any\n+\t     expliit references with a CLOBBER.  If there are any remaining\n+\t     references (rare), don't use the value.  */\n+\n+\t  if (reg_mentioned_p (x, value))\n+\t    value = replace_rtx (copy_rtx (value), x,\n+\t\t\t\t gen_rtx (CLOBBER, GET_MODE (x), const0_rtx));\n+\n+\t  if (reg_overlap_mentioned_p (x, value))\n+\t    return 0;\n+\t}\n+      else\n+\treturn 0;\n+    }\n+\n+  /* If the value has all its registers valid, return it.  */\n   if (get_last_value_validate (&value, reg_last_set_label[regno], 0))\n     return value;\n "}]}