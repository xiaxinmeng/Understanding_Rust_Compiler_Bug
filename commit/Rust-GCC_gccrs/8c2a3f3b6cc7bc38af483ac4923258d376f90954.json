{"sha": "8c2a3f3b6cc7bc38af483ac4923258d376f90954", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMyYTNmM2I2Y2M3YmMzOGFmNDgzYWM0OTIzMjU4ZDM3NmY5MDk1NA==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-04-11T11:35:32Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-04-11T11:35:32Z"}, "message": "re PR target/50751 (SH Target: Displacement addressing does not work for QImode and HImode)\n\n\tPR target/50751\n\t* config/sh/sh-protos.h (sh_legitimate_index_p): Add new arguments\n\tconsider_sh2a and allow_zero.\n\t* config/sh/sh.c (sh_legitimate_index_p): Likewise.\n\t(disp_addr_displacement): New function.\n\t(sh_address_cost): Use disp_addr_displacement function instead\n\tof DISP_ADDR_OFFSET.\n\t(sh_legitimate_address_p): Adapt to changed\n\tsh_legitimate_index_p declaration.\n\t(sh_find_mov_disp_adjust): Remove HImode check.\n\t(sh_secondary_reload): Add HImode case.  Use satisfies_constraint_Sdd,\n\tdisp_addr_displacement and max_mov_insn_displacement.\n\t(max_mov_insn_displacement): Remove HImode check.\n\t* config/sh/sh.h (CONST_OK_FOR_K04, CONST_OK_FOR_K12, \n\tDISP_ADDR_P, DISP_ADDR_OFFSET): Remove.\n\t* config/sh/constraints.md (K05, K13): New constraints.\n\t(K12): Correct comment.\n\t(Sdd): Do not use DISP_ADDR_P macro.\n\t(Snd, Sbw): Use satisfies_constraint_Sdd.\n\t* config/sh/sh.md (extendhisi2): Remove constraints from expander.\n\t(*extendhisi2_compact, movhi_i): Remove.\n\t(*extendhisi2_compact_reg, *extendhisi2_compact_mem_disp,\n\t*extendhisi2_compact_mem_disp, *extendhisi2_compact_snd,\n\t*movhi_reg_reg, *movhi_store_mem_disp05, *movhi_store_mem_disp13,\n\t*movhi_load_mem_disp, *movhi_load_mem_disp, *movhi): New insns.\n\t(*extendqisi2_compact_mem_disp, *extendqisi2_compact_mem_disp,\n\t*movqi_store_mem_disp04, *movqi_store_mem_disp12, *movqi_load_mem_disp,\n\t*movqi_load_mem_disp): Use sh_legitimate_index_p instead of\n\tCONST_OK_FOR_Kxx.\n\tAdd new peepholes for HImode displacement addressing.\n\nFrom-SVN: r186311", "tree": {"sha": "07b8b694f4fd16b55292cb37ed731c28edfb17ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07b8b694f4fd16b55292cb37ed731c28edfb17ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c2a3f3b6cc7bc38af483ac4923258d376f90954", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c2a3f3b6cc7bc38af483ac4923258d376f90954", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c2a3f3b6cc7bc38af483ac4923258d376f90954", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c2a3f3b6cc7bc38af483ac4923258d376f90954/comments", "author": null, "committer": null, "parents": [{"sha": "b16212bd3c3ecd421c09c3a632b43ec68674b6bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b16212bd3c3ecd421c09c3a632b43ec68674b6bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b16212bd3c3ecd421c09c3a632b43ec68674b6bf"}], "stats": {"total": 388, "additions": 276, "deletions": 112}, "files": [{"sha": "f45615709b2adb5dd03c593a4f40b1f99a5c582d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c2a3f3b6cc7bc38af483ac4923258d376f90954/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c2a3f3b6cc7bc38af483ac4923258d376f90954/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c2a3f3b6cc7bc38af483ac4923258d376f90954", "patch": "@@ -1,3 +1,36 @@\n+2012-04-11  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/50751\n+\t* config/sh/sh-protos.h (sh_legitimate_index_p): Add new arguments\n+\tconsider_sh2a and allow_zero.\n+\t* config/sh/sh.c (sh_legitimate_index_p): Likewise.\n+\t(disp_addr_displacement): New function.\n+\t(sh_address_cost): Use disp_addr_displacement function instead\n+\tof DISP_ADDR_OFFSET.\n+\t(sh_legitimate_address_p): Adapt to changed\n+\tsh_legitimate_index_p declaration.\n+\t(sh_find_mov_disp_adjust): Remove HImode check.\n+\t(sh_secondary_reload): Add HImode case.  Use satisfies_constraint_Sdd,\n+\tdisp_addr_displacement and max_mov_insn_displacement.\n+\t(max_mov_insn_displacement): Remove HImode check.\n+\t* config/sh/sh.h (CONST_OK_FOR_K04, CONST_OK_FOR_K12, \n+\tDISP_ADDR_P, DISP_ADDR_OFFSET): Remove.\n+\t* config/sh/constraints.md (K05, K13): New constraints.\n+\t(K12): Correct comment.\n+\t(Sdd): Do not use DISP_ADDR_P macro.\n+\t(Snd, Sbw): Use satisfies_constraint_Sdd.\n+\t* config/sh/sh.md (extendhisi2): Remove constraints from expander.\n+\t(*extendhisi2_compact, movhi_i): Remove.\n+\t(*extendhisi2_compact_reg, *extendhisi2_compact_mem_disp,\n+\t*extendhisi2_compact_mem_disp, *extendhisi2_compact_snd,\n+\t*movhi_reg_reg, *movhi_store_mem_disp05, *movhi_store_mem_disp13,\n+\t*movhi_load_mem_disp, *movhi_load_mem_disp, *movhi): New insns.\n+\t(*extendqisi2_compact_mem_disp, *extendqisi2_compact_mem_disp,\n+\t*movqi_store_mem_disp04, *movqi_store_mem_disp12, *movqi_load_mem_disp,\n+\t*movqi_load_mem_disp): Use sh_legitimate_index_p instead of\n+\tCONST_OK_FOR_Kxx.\n+\tAdd new peepholes for HImode displacement addressing.\n+\n 2012-04-11  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* config/sh/sh.h (SIDI_OFF): Remove."}, {"sha": "6c9bc5ecc95df71630fe722507076289356beb21", "filename": "gcc/config/sh/constraints.md", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c2a3f3b6cc7bc38af483ac4923258d376f90954/gcc%2Fconfig%2Fsh%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c2a3f3b6cc7bc38af483ac4923258d376f90954/gcc%2Fconfig%2Fsh%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fconstraints.md?ref=8c2a3f3b6cc7bc38af483ac4923258d376f90954", "patch": "@@ -145,16 +145,28 @@\n   (and (match_code \"const_int\")\n        (match_test \"ival >= 0 && ival <= 15\")))\n \n+(define_constraint \"K05\"\n+  \"An unsigned 5-bit constant, as used in mov.w displacement addressing.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 31\")))\n+\n (define_constraint \"K08\"\n   \"An unsigned 8-bit constant, as used in and, or, etc.\"\n   (and (match_code \"const_int\")\n        (match_test \"ival >= 0 && ival <= 255\")))\n  \n (define_constraint \"K12\"\n-  \"An unsigned 12-bit constant, as used in SH2A 12-bit displacement addressing.\"\n+  \"An unsigned 12-bit constant, as used in SH2A 12-bit mov.b displacement\n+   addressing.\"\n   (and (match_code \"const_int\")\n        (match_test \"ival >= 0 && ival <= 4095\")))\n \n+(define_constraint \"K13\"\n+  \"An unsigned 13-bit constant, as used in SH2A 12-bit mov.w displacement\n+   addressing.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 8191\")))\n+\n (define_constraint \"K16\"\n   \"An unsigned 16-bit constant, as used in SHmedia shori.\"\n   (and (match_code \"const_int\")\n@@ -262,22 +274,24 @@\n   (and (match_test \"memory_operand (op, GET_MODE (op))\")\n        (match_test \"GET_CODE (XEXP (op, 0)) != PLUS\")))\n \n+(define_memory_constraint \"Sdd\"\n+  \"A memory reference that uses displacement addressing.\"\n+  (and (match_test \"MEM_P (op) && GET_CODE (XEXP (op, 0)) == PLUS\")\n+       (match_test \"REG_P (XEXP (XEXP (op, 0), 0))\")\n+       (match_test \"CONST_INT_P (XEXP (XEXP (op, 0), 1))\")))\n+\n+(define_memory_constraint \"Snd\"\n+  \"A memory reference that excludes displacement addressing.\"\n+  (match_test \"! satisfies_constraint_Sdd (op)\"))\n+\n (define_memory_constraint \"Sbv\"\n   \"A memory reference, as used in SH2A bclr.b, bset.b, etc.\"\n   (and (match_test \"MEM_P (op) && GET_MODE (op) == QImode\")\n        (match_test \"REG_P (XEXP (op, 0))\")))\n \n (define_memory_constraint \"Sbw\"\n   \"A memory reference, as used in SH2A bclr.b, bset.b, etc.\"\n-  (and (match_test \"MEM_P (op) && GET_MODE (op) == QImode\")\n-       (match_test \"GET_CODE (XEXP (op, 0)) == PLUS\")\n-       (match_test \"REG_P (XEXP (XEXP (op, 0), 0))\")\n+  (and (match_test \"satisfies_constraint_Sdd (op)\")\n+       (match_test \"GET_MODE (op) == QImode\")\n        (match_test \"satisfies_constraint_K12 (XEXP (XEXP (op, 0), 1))\")))\n \n-(define_memory_constraint \"Snd\"\n-  \"A memory reference that excludes displacement addressing.\"\n-  (match_test \"! DISP_ADDR_P (op)\"))\n-\n-(define_memory_constraint \"Sdd\"\n-  \"A memory reference that uses displacement addressing.\"\n-  (match_test \"DISP_ADDR_P (op)\"))"}, {"sha": "c6d0d464f08c847e7cd5fa034c3b159ada4071b5", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c2a3f3b6cc7bc38af483ac4923258d376f90954/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c2a3f3b6cc7bc38af483ac4923258d376f90954/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=8c2a3f3b6cc7bc38af483ac4923258d376f90954", "patch": "@@ -404,7 +404,7 @@\n       if (GET_CODE (x) == PLUS\n \t  && REG_P (XEXP (x, 0))\n \t  && CONST_INT_P (XEXP (x, 1)))\n-\treturn sh_legitimate_index_p (mode, XEXP (x, 1));\n+\treturn sh_legitimate_index_p (mode, XEXP (x, 1), TARGET_SH2A, false);\n     }\n \n   if (TARGET_SHMEDIA\n@@ -466,7 +466,7 @@\n       if (GET_CODE (x) == PLUS\n \t  && REG_P (XEXP (x, 0))\n \t  && CONST_INT_P (XEXP (x, 1)))\n-\treturn sh_legitimate_index_p (mode, XEXP (x, 1));\n+\treturn sh_legitimate_index_p (mode, XEXP (x, 1), TARGET_SH2A, false);\n     }\n \n   return general_operand (op, mode);"}, {"sha": "cb9ad0f203ff42e001564518f3209da42f2750ce", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c2a3f3b6cc7bc38af483ac4923258d376f90954/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c2a3f3b6cc7bc38af483ac4923258d376f90954/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=8c2a3f3b6cc7bc38af483ac4923258d376f90954", "patch": "@@ -56,7 +56,7 @@ extern int sh_loop_align (rtx);\n extern bool fp_zero_operand (rtx);\n extern bool fp_one_operand (rtx);\n extern rtx get_fpscr_rtx (void);\n-extern bool sh_legitimate_index_p (enum machine_mode, rtx);\n+extern bool sh_legitimate_index_p (enum machine_mode, rtx, bool, bool);\n extern bool sh_legitimize_reload_address (rtx *, enum machine_mode, int, int);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n extern bool nonpic_symbol_mentioned_p (rtx);"}, {"sha": "e7e1945d1575e12f38a55ed4689235142a85ee76", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c2a3f3b6cc7bc38af483ac4923258d376f90954/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c2a3f3b6cc7bc38af483ac4923258d376f90954/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=8c2a3f3b6cc7bc38af483ac4923258d376f90954", "patch": "@@ -304,6 +304,7 @@ static bool sh_legitimate_constant_p (enum machine_mode, rtx);\n static int mov_insn_size (enum machine_mode, bool);\n static int max_mov_insn_displacement (enum machine_mode, bool);\n static int mov_insn_alignment_mask (enum machine_mode, bool);\n+static HOST_WIDE_INT disp_addr_displacement (rtx);\n \n static void sh_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;\n \f\n@@ -3160,11 +3161,6 @@ max_mov_insn_displacement (enum machine_mode mode, bool consider_sh2a)\n      scale the max. displacement value accordingly.  */\n   const int disp_scale = consider_sh2a ? (4095 / 15) : 1;\n \n-  /* FIXME: HImode with displacement addressing is not supported yet.\n-     Make it purposefully fail for now.  */\n-  if (mode == HImode)\n-    return 0;\n-\n   /* SH2A supports FPU move insns with 12 bit displacements.\n      Other variants to do not support any kind of displacements for\n      FPU move insns.  */\n@@ -3194,15 +3190,24 @@ mov_insn_alignment_mask (enum machine_mode mode, bool consider_sh2a)\n   return mov_insn_sz > 0 ? (mov_insn_sz - 1) : 0;\n }\n \n+/* Return the displacement value of a displacement address.  */\n+\n+static inline HOST_WIDE_INT\n+disp_addr_displacement (rtx x)\n+{\n+  gcc_assert (satisfies_constraint_Sdd (x));\n+  return INTVAL (XEXP (XEXP (x, 0), 1));\n+}\n+\n /* Compute the cost of an address.  */\n \n static int\n sh_address_cost (rtx x, bool speed ATTRIBUTE_UNUSED)\n {\n   /* 'reg + disp' addressing.  */\n-  if (DISP_ADDR_P (x))\n+  if (satisfies_constraint_Sdd (x))\n     {\n-      const HOST_WIDE_INT offset = DISP_ADDR_OFFSET (x);\n+      const HOST_WIDE_INT offset = disp_addr_displacement (x);\n       const enum machine_mode mode = GET_MODE (x);\n \n       /* The displacement would fit into a 2 byte move insn.  */\n@@ -9665,7 +9670,8 @@ sh_insn_length_adjustment (rtx insn)\n    with MODE.  */\n \n bool\n-sh_legitimate_index_p (enum machine_mode mode, rtx op)\n+sh_legitimate_index_p (enum machine_mode mode, rtx op, bool consider_sh2a,\n+\t\t       bool allow_zero)\n {\n   if (! CONST_INT_P (op))\n     return false;\n@@ -9686,15 +9692,15 @@ sh_legitimate_index_p (enum machine_mode mode, rtx op)\n   else\n     {\n       const HOST_WIDE_INT offset = INTVAL (op);\n-      const int max_disp = max_mov_insn_displacement (mode, TARGET_SH2A);\n-      const int align_mask = mov_insn_alignment_mask (mode, TARGET_SH2A);\n+      const int max_disp = max_mov_insn_displacement (mode, consider_sh2a);\n+      const int align_mask = mov_insn_alignment_mask (mode, consider_sh2a);\n \n       /* If the mode does not support any displacement always return false.\n \t Even though an index of '0' is actually always valid, it will cause\n \t troubles when e.g. a DFmode move is split into two SFmode moves,\n \t where one SFmode move will have index '0' and the other move will\n \t have index '4'.  */\n-       if (max_disp < 1)\n+       if (!allow_zero && max_disp < 1)\n \treturn false;\n \n       return offset >= 0 && offset <= max_disp && (offset & align_mask) == 0;\n@@ -9728,7 +9734,7 @@ sh_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n \n       if (GET_MODE_SIZE (mode) <= 8\n \t  && MAYBE_BASE_REGISTER_RTX_P (xop0, strict)\n-\t  && sh_legitimate_index_p (mode, xop1))\n+\t  && sh_legitimate_index_p (mode, xop1, TARGET_SH2A, false))\n \treturn true;\n \n       if ((ALLOW_INDEXED_ADDRESS || GET_MODE (x) == DImode\n@@ -9875,11 +9881,6 @@ sh_find_mov_disp_adjust (enum machine_mode mode, HOST_WIDE_INT offset)\n   if (mode_sz < 1 || mode_sz > 8 || max_disp < 1)\n     return res;\n \n-  /* FIXME: HImode with displacement addressing is not supported yet.\n-     Make it purposefully fail for now.  */\n-  if (mov_insn_sz == 2)\n-    return res;\n-\n   /* Keeps the previous behavior for QImode displacement addressing.\n      This just decides how the offset is re-based.  Removing this special\n      case will result in slightly bigger code on average, but it's not that\n@@ -12566,12 +12567,14 @@ sh_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n   if (rclass == FPUL_REGS && true_regnum (x) == -1)\n     return GENERAL_REGS;\n \n-  /* Force mov.b displacement addressing insn to use R0 as the other operand.\n+  /* Force mov.b / mov.w displacement addressing insn to use R0 as\n+     the other operand.\n      On SH2A could also just leave it alone here, which would result in a\n      4 byte move insn being generated instead.  However, for this to work\n      the insns must have the appropriate alternatives.  */\n-  if (mode == QImode && rclass != R0_REGS\n-      && DISP_ADDR_P (x) && DISP_ADDR_OFFSET (x) < 16)\n+  if ((mode == QImode || mode == HImode) && rclass != R0_REGS\n+      && satisfies_constraint_Sdd (x)\n+      && disp_addr_displacement (x) <= max_mov_insn_displacement (mode, false))\n     return R0_REGS;\n \n   /* When reload is trying to address a QImode or HImode subreg on the stack, "}, {"sha": "1ee0d017a983c35ecfccb68ec3b686beaac4aca6", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c2a3f3b6cc7bc38af483ac4923258d376f90954/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c2a3f3b6cc7bc38af483ac4923258d376f90954/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=8c2a3f3b6cc7bc38af483ac4923258d376f90954", "patch": "@@ -1210,24 +1210,12 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n   ((HOST_BITS_PER_WIDE_INT >= 64 && (VALUE) == (HOST_WIDE_INT) 0xffffffff) \\\n    || (HOST_BITS_PER_WIDE_INT >= 64 && (VALUE) == (HOST_WIDE_INT) -1 << 32))\n \n-#define CONST_OK_FOR_K04(VALUE) (((HOST_WIDE_INT)(VALUE))>= 0 \\\n-\t\t\t\t && ((HOST_WIDE_INT)(VALUE)) <= 15)\n-\n #define CONST_OK_FOR_K08(VALUE) (((HOST_WIDE_INT)(VALUE))>= 0 \\\n \t\t\t\t && ((HOST_WIDE_INT)(VALUE)) <= 255)\n \n-#define CONST_OK_FOR_K12(VALUE) (((HOST_WIDE_INT)(VALUE))>= 0 \\\n-\t\t\t\t && ((HOST_WIDE_INT)(VALUE)) <= 4095)\n-\n #define ZERO_EXTRACT_ANDMASK(EXTRACT_SZ_RTX, EXTRACT_POS_RTX)\\\n   (((1 << INTVAL (EXTRACT_SZ_RTX)) - 1) << INTVAL (EXTRACT_POS_RTX))\n \n-#define DISP_ADDR_P(X) (MEM_P (X) && GET_CODE (XEXP (X, 0)) == PLUS \\\n-\t\t\t && REG_P (XEXP (XEXP (X, 0), 0)) \\\n-\t\t\t && CONST_INT_P (XEXP (XEXP (X, 0), 1)))\n-\n-#define DISP_ADDR_OFFSET(X) (INTVAL (XEXP (XEXP (X, 0), 1)))\n-\n #if 0\n #define SECONDARY_INOUT_RELOAD_CLASS(CLASS,MODE,X,ELSE) \\\n   ((((REGCLASS_HAS_FP_REG (CLASS) \t\t\t\t\t\\"}, {"sha": "45a5edf6ad7b4f0919d5cfdb7fa0c309605ce199", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 192, "deletions": 66, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c2a3f3b6cc7bc38af483ac4923258d376f90954/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c2a3f3b6cc7bc38af483ac4923258d376f90954/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=8c2a3f3b6cc7bc38af483ac4923258d376f90954", "patch": "@@ -4743,20 +4743,18 @@ label:\n     operands[1] = XEXP (operands[1], 0);\n })\n \n+;; FIXME: Maybe fold HImode and QImode stuff with mode iterator?\n (define_expand \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"general_extend_operand\" \"r,m\")))]\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t(sign_extend:SI (match_operand:HI 1 \"general_extend_operand\" \"\")))]\n   \"\"\n   \"\")\n \n-(define_insn \"*extendhisi2_compact\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"general_movsrc_operand\" \"r,m\")))]\n-  \"TARGET_SH1\"\n-  \"@\n-\texts.w\t%1,%0\n-\tmov.w\t%1,%0\"\n-  [(set_attr \"type\" \"arith,load\")])\n+(define_expand \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t(sign_extend:SI (match_operand:QI 1 \"general_extend_operand\" \"\")))]\n+  \"\"\n+  \"\")\n \n (define_insn \"*extendhisi2_media\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -4786,12 +4784,6 @@ label:\n \t\t\t   subreg_lowpart_offset (SImode, GET_MODE (op1)));\n })\n \n-(define_expand \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n-\t(sign_extend:SI (match_operand:QI 1 \"general_extend_operand\" \"\")))]\n-  \"\"\n-  \"\")\n-\n (define_insn \"*extendqisi2_compact_reg\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,r\")\n \t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"r,t\")))]\n@@ -4801,43 +4793,85 @@ label:\n \tmovt\t%0\"\n   [(set_attr \"type\" \"arith,arith\")])\n \n+(define_insn \"*extendhisi2_compact_reg\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"r,t\")))]\n+  \"TARGET_SH1\"\n+  \"@\n+\texts.w\t%1,%0\n+\tmovt\t%0\"\n+  [(set_attr \"type\" \"arith,arith\")])\n+\n ;; FIXME: Fold non-SH2A and SH2A alternatives with \"enabled\" attribute.\n ;; See movqi insns.\n (define_insn \"*extendqisi2_compact_mem_disp\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=z,r\")\n \t(sign_extend:SI\n \t (mem:QI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%r,r\")\n \t\t\t  (match_operand:SI 2 \"const_int_operand\" \"K04,N\")))))]\n-  \"TARGET_SH1 && ! TARGET_SH2A && CONST_OK_FOR_K04 (INTVAL (operands[2]))\"\n+  \"TARGET_SH1 && ! TARGET_SH2A\n+   && sh_legitimate_index_p (QImode, operands[2], false, true)\"\n   \"@\n \tmov.b\t@(%O2,%1),%0\n \tmov.b\t@%1,%0\"\n   [(set_attr \"type\" \"load\")])\n \n+(define_insn \"*extendhisi2_compact_mem_disp\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=z,r\")\n+\t(sign_extend:SI\n+\t (mem:HI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%r,r\")\n+\t\t\t  (match_operand:SI 2 \"const_int_operand\" \"K05,N\")))))]\n+  \"TARGET_SH1 && ! TARGET_SH2A\n+   && sh_legitimate_index_p (HImode, operands[2], false, true)\"\n+  \"@\n+\tmov.w\t@(%O2,%1),%0\n+\tmov.w\t@%1,%0\"\n+  [(set_attr \"type\" \"load\")])\n+\n (define_insn \"*extendqisi2_compact_mem_disp\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=z,r,r\")\n \t(sign_extend:SI\n \t (mem:QI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%r,r,r\")\n \t\t\t  (match_operand:SI 2 \"const_int_operand\" \"K04,N,K12\")))))]\n-  \"TARGET_SH2A\n-   && (CONST_OK_FOR_K04 (INTVAL (operands[2]))\n-       || (CONST_OK_FOR_K12 (INTVAL (operands[2]))))\"\n+  \"TARGET_SH2A && sh_legitimate_index_p (QImode, operands[2], true, true)\"\n   \"@\n \tmov.b\t@(%O2,%1),%0\n \tmov.b\t@%1,%0\n \tmov.b\t@(%O2,%1),%0\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"2,2,4\")])\n \n-;; This will take care of other QImode addressing modes than displacement\n-;; addressing.\n+(define_insn \"*extendhisi2_compact_mem_disp\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=z,r,r\")\n+\t(sign_extend:SI\n+\t (mem:HI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%r,r,r\")\n+\t\t\t  (match_operand:SI 2 \"const_int_operand\" \"K05,N,K13\")))))]\n+  \"TARGET_SH2A && sh_legitimate_index_p (HImode, operands[2], true, true)\"\n+  \"@\n+\tmov.w\t@(%O2,%1),%0\n+\tmov.w\t@%1,%0\n+\tmov.w\t@(%O2,%1),%0\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"2,2,4\")])\n+\n+;; The *_snd patterns will take care of other QImode/HImode addressing\n+;; modes than displacement addressing.  They must be defined _after_ the\n+;; displacement addressing patterns.  Otherwise the displacement addressing\n+;; patterns will not be picked.\n (define_insn \"*extendqisi2_compact_snd\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(sign_extend:SI (match_operand:QI 1 \"movsrc_no_disp_mem_operand\" \"Snd\")))]\n   \"TARGET_SH1\"\n   \"mov.b\t%1,%0\"\n   [(set_attr \"type\" \"load\")])\n \n+(define_insn \"*extendhisi2_compact_snd\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"movsrc_no_disp_mem_operand\" \"Snd\")))]\n+  \"TARGET_SH1\"\n+  \"mov.w\t%1,%0\"\n+  [(set_attr \"type\" \"load\")])\n+\n (define_insn \"*extendqisi2_media\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(sign_extend:SI (match_operand:QI 1 \"general_extend_operand\" \"r,m\")))]\n@@ -5416,6 +5450,14 @@ label:\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_movdst_operand\" \"\")\n+\t(match_operand:HI 1 \"general_movsrc_operand\" \"\"))]\n+  \"\"\n+{\n+  prepare_move_operands (operands, HImode);\n+})\n+\n (define_expand \"movqi\"\n   [(set (match_operand:QI 0 \"general_operand\" \"\")\n \t(match_operand:QI 1 \"general_operand\" \"\"))]\n@@ -5431,6 +5473,7 @@ label:\n ;; With the movqi_reg_reg being specified before movqi it will be intially \n ;; picked to load/store regs.  If the regs regs are on the stack reload will\n ;; try other insns and not stick to movqi_reg_reg.\n+;; The same applies to the movhi variants.\n (define_insn \"*movqi_reg_reg\"\n   [(set (match_operand:QI 0 \"arith_reg_dest\"   \"=r,r\")\n \t(match_operand:QI 1 \"register_operand\" \"r,t\"))]\n@@ -5440,51 +5483,101 @@ label:\n \tmovt\t%0\"\n   [(set_attr \"type\" \"move,arith\")])\n \n+(define_insn \"*movhi_reg_reg\"\n+  [(set (match_operand:HI 0 \"arith_reg_dest\"   \"=r,r\")\n+\t(match_operand:HI 1 \"register_operand\" \"r,t\"))]\n+  \"TARGET_SH1\"\n+  \"@\n+\tmov\t%1,%0\n+\tmovt\t%0\"\n+  [(set_attr \"type\" \"move,arith\")])\n+\n ;; FIXME: The non-SH2A and SH2A variants should be combined by adding\n ;; \"enabled\" attribute as it is done in other targets.\n (define_insn \"*movqi_store_mem_disp04\"\n   [(set (mem:QI (plus:SI (match_operand:SI 0 \"arith_reg_operand\" \"%r,r\")\n \t\t\t (match_operand:SI 1 \"const_int_operand\" \"K04,N\")))\n \t(match_operand:QI 2 \"arith_reg_operand\" \"z,r\"))]\n-  \"TARGET_SH1 && CONST_OK_FOR_K04 (INTVAL (operands[1]))\"\n+  \"TARGET_SH1 && sh_legitimate_index_p (QImode, operands[1], false, true)\"\n   \"@\n \tmov.b\t%2,@(%O1,%0)\n \tmov.b\t%2,@%0\"\n   [(set_attr \"type\" \"store\")])\n \n+(define_insn \"*movhi_store_mem_disp05\"\n+  [(set (mem:HI (plus:SI (match_operand:SI 0 \"arith_reg_operand\" \"%r,r\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"K05,N\")))\n+\t(match_operand:HI 2 \"arith_reg_operand\" \"z,r\"))]\n+  \"TARGET_SH1 && sh_legitimate_index_p (HImode, operands[1], false, true)\"\n+  \"@\n+\tmov.w\t%2,@(%O1,%0)\n+\tmov.w\t%2,@%0\"\n+  [(set_attr \"type\" \"store\")])\n+\n (define_insn \"*movqi_store_mem_disp12\"\n   [(set (mem:QI (plus:SI (match_operand:SI 0 \"arith_reg_operand\" \"%r\")\n \t\t\t (match_operand:SI 1 \"const_int_operand\" \"K12\")))\n \t(match_operand:QI 2 \"arith_reg_operand\" \"r\"))]\n-  \"TARGET_SH2A && CONST_OK_FOR_K12 (INTVAL (operands[1]))\"\n+  \"TARGET_SH2A && sh_legitimate_index_p (QImode, operands[1], true, true)\"\n   \"mov.b\t%2,@(%O1,%0)\"\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"4\")])\n \n+(define_insn \"*movhi_store_mem_disp13\"\n+  [(set (mem:HI (plus:SI (match_operand:SI 0 \"arith_reg_operand\" \"%r\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"K13\")))\n+\t(match_operand:HI 2 \"arith_reg_operand\" \"r\"))]\n+  \"TARGET_SH2A && sh_legitimate_index_p (HImode, operands[1], true, true)\"\n+  \"mov.w\t%2,@(%O1,%0)\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"*movqi_load_mem_disp\"\n   [(set (match_operand:QI 0 \"arith_reg_dest\" \"=z,r\")\n \t(mem:QI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%r,r\")\n \t\t\t (match_operand:SI 2 \"const_int_operand\" \"K04,N\"))))]\n-  \"TARGET_SH1 && ! TARGET_SH2A && CONST_OK_FOR_K04 (INTVAL (operands[2]))\"\n+  \"TARGET_SH1 && ! TARGET_SH2A\n+   && sh_legitimate_index_p (QImode, operands[2], false, true)\"\n   \"@\n \tmov.b\t@(%O2,%1),%0\n \tmov.b\t@%1,%0\"\n   [(set_attr \"type\" \"load\")])\n \n+(define_insn \"*movhi_load_mem_disp\"\n+  [(set (match_operand:HI 0 \"arith_reg_dest\" \"=z,r\")\n+\t(mem:HI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%r,r\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"K05,N\"))))]\n+  \"TARGET_SH1 && ! TARGET_SH2A\n+   && sh_legitimate_index_p (HImode, operands[2], false, true)\"\n+  \"@\n+\tmov.w\t@(%O2,%1),%0\n+\tmov.w\t@%1,%0\"\n+  [(set_attr \"type\" \"load\")])\n+\n (define_insn \"*movqi_load_mem_disp\"\n   [(set (match_operand:QI 0 \"arith_reg_dest\" \"=z,r,r\")\n \t(mem:QI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%r,r,r\")\n \t\t\t (match_operand:SI 2 \"const_int_operand\" \"K04,N,K12\"))))]\n-  \"TARGET_SH2A\n-   && (CONST_OK_FOR_K04 (INTVAL (operands[2]))\n-       || CONST_OK_FOR_K12 (INTVAL (operands[2])))\"\n+  \"TARGET_SH2A && sh_legitimate_index_p (QImode, operands[2], true, true)\"\n   \"@\n \tmov.b\t@(%O2,%1),%0\n \tmov.b\t@%1,%0\n \tmov.b\t@(%O2,%1),%0\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"2,2,4\")])\n \n+(define_insn \"*movhi_load_mem_disp\"\n+  [(set (match_operand:HI 0 \"arith_reg_dest\" \"=z,r,r\")\n+\t(mem:HI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%r,r,r\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"K05,N,K13\"))))]\n+  \"TARGET_SH2A && sh_legitimate_index_p (HImode, operands[2], true, true)\"\n+  \"@\n+\tmov.w\t@(%O2,%1),%0\n+\tmov.w\t@%1,%0\n+\tmov.w\t@(%O2,%1),%0\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"2,2,4\")])\n+\n ;; The m constraints basically allow any kind of addresses to be used with any\n ;; source/target register as the other operand.  This is not true for \n ;; displacement addressing modes on anything but SH2A.  That's why the\n@@ -5503,6 +5596,21 @@ label:\n \tlds\t%1,%0\"\n  [(set_attr \"type\" \"movi8,load,store,prget,prset\")])\n \n+(define_insn \"*movhi\"\n+  [(set (match_operand:HI 0 \"general_movdst_operand\" \"=r,r,r,m,r,l\")\n+\t(match_operand:HI 1 \"general_movsrc_operand\"  \"Q,i,m,r,l,r\"))]\n+  \"TARGET_SH1\n+   && (arith_reg_operand (operands[0], HImode)\n+       || arith_reg_operand (operands[1], HImode))\"\n+  \"@\n+\tmov.w\t%1,%0\n+\tmov\t%1,%0\n+\tmov.w\t%1,%0\n+\tmov.w\t%1,%0\n+\tsts\t%1,%0\n+\tlds\t%1,%0\"\n+ [(set_attr \"type\" \"pcload,movi8,load,store,prget,prset\")])\n+\n (define_insn \"*movqi_media\"\n   [(set (match_operand:QI 0 \"general_movdst_operand\" \"=r,r,r,m\")\n \t(match_operand:QI 1 \"general_movsrc_operand\" \"r,I16Css,m,rZ\"))]\n@@ -5535,28 +5643,6 @@ label:\n   operands[3] = gen_rtx_REG (DImode, REGNO (operands[2]));\n })\n \n-;; When storing r0, we have to avoid reg+reg addressing.\n-(define_insn \"movhi_i\"\n-  [(set (match_operand:HI 0 \"general_movdst_operand\"   \"=r,r,r,r,m,r,l,r\")\n-\t(match_operand:HI 1 \"general_movsrc_operand\" \"Q,rI08,m,t,r,l,r,i\"))]\n-  \"TARGET_SH1\n-   && (arith_reg_operand (operands[0], HImode)\n-       || arith_reg_operand (operands[1], HImode))\n-   && (!MEM_P (operands[0])\n-       || GET_CODE (XEXP (operands[0], 0)) != PLUS\n-       || !REG_P (XEXP (XEXP (operands[0], 0), 1))\n-       || ! refers_to_regno_p (R0_REG, R0_REG + 1, operands[1], (rtx *)0))\"\n-  \"@\n-\tmov.w\t%1,%0\n-\tmov\t%1,%0\n-\tmov.w\t%1,%0\n-\tmovt\t%0\n-\tmov.w\t%1,%0\n-\tsts\t%1,%0\n-\tlds\t%1,%0\n-\tfake\t%1,%0\"\n-  [(set_attr \"type\" \"pcload,move,load,move,store,move,move,pcload\")])\n-\n (define_insn \"*movhi_media\"\n   [(set (match_operand:HI 0 \"general_movdst_operand\"     \"=r,r,r,r,m\")\n \t(match_operand:HI 1 \"general_movsrc_operand\" \"r,I16Css,n,m,rZ\"))]\n@@ -5582,14 +5668,6 @@ label:\n    && ! satisfies_constraint_I16 (operands[1])\"\n   [(set (subreg:DI (match_dup 0) 0) (match_dup 1))])\n \n-(define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"general_movdst_operand\" \"\")\n-\t(match_operand:HI 1 \"general_movsrc_operand\"  \"\"))]\n-  \"\"\n-{\n-  prepare_move_operands (operands, HImode);\n-})\n-\n (define_expand \"reload_inhi\"\n   [(set (match_operand:SI 2 \"\" \"=&r\")\n \t(match_operand:HI 1 \"inqhi_operand\" \"\"))\n@@ -11538,10 +11616,10 @@ label:\n \n ;; Fold sequence:\n ;;\tmov #54,r0\n-;;\tmov.b @(r0,r15),r0\n+;;\tmov.{b,w} @(r0,r15),r0\n ;;\tmov r0,r3\n ;; into:\n-;;\tmov.b @(54,r15),r3\n+;;\tmov.{b,w} @(54,r15),r3\n ;;\n (define_peephole2\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n@@ -11553,17 +11631,33 @@ label:\n    (set (match_operand:QI 4 \"arith_reg_dest\" \"\")\n \t(match_operand:QI 5 \"arith_reg_operand\" \"\"))]\n   \"TARGET_SH2A\n-   && CONST_OK_FOR_K12 (INTVAL (operands[1]))\n+   && sh_legitimate_index_p (QImode, operands[1], true, true)\n    && REGNO (operands[2]) == REGNO (operands[5])\n    && peep2_reg_dead_p (3, operands[5])\"\n   [(set (match_dup 4) (mem:QI (plus:SI (match_dup 3) (match_dup 1))))]\n   \"\")\n \n+(define_peephole2\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t(match_operand:SI 1 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 2 \"arith_reg_dest\" \"\")\n+\t(sign_extend:SI\n+\t (mem:HI (plus:SI (match_dup 0)\n+\t\t\t  (match_operand:SI 3 \"arith_reg_operand\" \"\")))))\n+   (set (match_operand:HI 4 \"arith_reg_dest\" \"\")\n+\t(match_operand:HI 5 \"arith_reg_operand\" \"\"))]\n+  \"TARGET_SH2A\n+   && sh_legitimate_index_p (HImode, operands[1], true, true)\n+   && REGNO (operands[2]) == REGNO (operands[5])\n+   && peep2_reg_dead_p (3, operands[5])\"\n+  [(set (match_dup 4) (mem:HI (plus:SI (match_dup 3) (match_dup 1))))]\n+  \"\")\n+\n ;; Fold sequence:\n ;;\tmov #54,r0\n-;;\tmov.b @(r0,r15),r1\n+;;\tmov.{b,w} @(r0,r15),r1\n ;; into:\n-;;\tmov.b @(54,r15),r1\n+;;\tmov.{b,w} @(54,r15),r1\n ;;\n (define_peephole2\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n@@ -11573,19 +11667,37 @@ label:\n \t (mem:QI (plus:SI (match_dup 0)\n \t\t\t  (match_operand:SI 3 \"arith_reg_operand\" \"\")))))]\n   \"TARGET_SH2A\n-   && CONST_OK_FOR_K12 (INTVAL (operands[1]))\n+   && sh_legitimate_index_p (QImode, operands[1], true, true)\n    && (peep2_reg_dead_p (2, operands[0])\n        || REGNO (operands[0]) == REGNO (operands[2]))\"\n   [(set (match_dup 2)\n \t(sign_extend:SI (mem:QI (plus:SI (match_dup 3) (match_dup 1)))))]\n   \"\")\n \n+(define_peephole2\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t(match_operand:SI 1 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 2 \"arith_reg_dest\" \"\")\n+\t (sign_extend:SI\n+\t (mem:HI (plus:SI (match_dup 0)\n+\t\t\t  (match_operand:SI 3 \"arith_reg_operand\" \"\")))))]\n+  \"TARGET_SH2A\n+   && sh_legitimate_index_p (HImode, operands[1], true, true)\n+   && (peep2_reg_dead_p (2, operands[0])\n+       || REGNO (operands[0]) == REGNO (operands[2]))\"\n+  [(set (match_dup 2)\n+\t(sign_extend:SI (mem:HI (plus:SI (match_dup 3) (match_dup 1)))))]\n+  \"\")\n+\n ;; Fold sequence:\n-;;\tmov.b @(r0,r15),r0\n+;;\tmov.{b,w} @(r0,r15),r0\n ;;\tmov r0,r3\n ;; into:\n-;;\tmov.b @(r0,r15),r3\n+;;\tmov.{b,w} @(r0,r15),r3\n ;;\n+;; This can happen when initially a displacement address is picked, where\n+;; the destination reg is fixed to r0, and then the address is transformed\n+;; into 'r0 + reg'.\n (define_peephole2\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n \t(sign_extend:SI\n@@ -11600,6 +11712,20 @@ label:\n \t(mem:QI (plus:SI (match_dup 1) (match_dup 2))))]\n   \"\")\n \n+(define_peephole2\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t(sign_extend:SI\n+\t (mem:HI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t\t  (match_operand:SI 2 \"arith_reg_operand\" \"\")))))\n+   (set (match_operand:HI 3 \"arith_reg_dest\" \"\")\n+\t(match_operand:HI 4 \"arith_reg_operand\" \"\"))]\n+  \"TARGET_SH1\n+   && REGNO (operands[0]) == REGNO (operands[4])\n+   && peep2_reg_dead_p (2, operands[0])\"\n+  [(set (match_dup 3)\n+\t(mem:HI (plus:SI (match_dup 1) (match_dup 2))))]\n+  \"\")\n+\n ;; These convert sequences such as `mov #k,r0; add r15,r0; mov.l @r0,rn'\n ;; to `mov #k,r0; mov.l @(r0,r15),rn'.  These sequences are generated by\n ;; reload when the constant is too large for a reg+offset address."}]}