{"sha": "8e3a4869029faad868154af6869caad476ffdcb7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUzYTQ4NjkwMjlmYWFkODY4MTU0YWY2ODY5Y2FhZDQ3NmZmZGNiNw==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2012-12-21T21:20:48Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2012-12-21T21:20:48Z"}, "message": "re PR inline-asm/55775 (ICE when building pari)\n\n2012-12-21  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR middle-end/55775\n\t* lra-assigns.c (improve_inheritance): Do nothing after\n\tLRA_MAX_INHERITANCE_PASSES pass.\n\t* lra-constraints.c (MAX_CONSTRAINT_ITERATION_NUMBER): Rename to\n\tLRA_MAX_CONSTRAINT_ITERATION_NUMBER.  Move to lra-int.h.\n\t(MAX_INHERITANCE_PASSES): Rename to LRA_MAX_INHERITANCE_PASSES.\n\tMove to lra-int.h.\n\t* lra-int.h (LRA_MAX_CONSTRAINT_ITERATION_NUMBER): Move from\n\tlra-constraints.c.\n\t(LRA_MAX_INHERITANCE_PASSES): Ditto.\n\n2012-12-21  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR middle-end/55775\n\t* gcc.target/i386/pr55775.c: New test.\n\nFrom-SVN: r194680", "tree": {"sha": "710b9ff07f324f4591594dc3249e961c1dbf9d4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/710b9ff07f324f4591594dc3249e961c1dbf9d4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e3a4869029faad868154af6869caad476ffdcb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e3a4869029faad868154af6869caad476ffdcb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e3a4869029faad868154af6869caad476ffdcb7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e3a4869029faad868154af6869caad476ffdcb7/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a0edd35cf6cbcb81d95afcd8f8c9d2ac539d0314", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0edd35cf6cbcb81d95afcd8f8c9d2ac539d0314", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0edd35cf6cbcb81d95afcd8f8c9d2ac539d0314"}], "stats": {"total": 122, "additions": 99, "deletions": 23}, "files": [{"sha": "8f0bc886dd469da9b4557ce08b8a63e7026db1fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3a4869029faad868154af6869caad476ffdcb7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3a4869029faad868154af6869caad476ffdcb7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e3a4869029faad868154af6869caad476ffdcb7", "patch": "@@ -1,3 +1,16 @@\n+2012-12-21  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR middle-end/55775\n+\t* lra-assigns.c (improve_inheritance): Do nothing after\n+\tLRA_MAX_INHERITANCE_PASSES pass.\n+\t* lra-constraints.c (MAX_CONSTRAINT_ITERATION_NUMBER): Rename to\n+\tLRA_MAX_CONSTRAINT_ITERATION_NUMBER.  Move to lra-int.h.\n+\t(MAX_INHERITANCE_PASSES): Rename to LRA_MAX_INHERITANCE_PASSES.\n+\tMove to lra-int.h.\n+\t* lra-int.h (LRA_MAX_CONSTRAINT_ITERATION_NUMBER): Move from\n+\tlra-constraints.c.\n+\t(LRA_MAX_INHERITANCE_PASSES): Ditto.\n+\n 2012-12-21  Steve Ellcey  <sellcey@mips.com>\n \n \tPR bootstrap/54128"}, {"sha": "12d58cca6095bc494c607dace121c4d98b0ee28d", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3a4869029faad868154af6869caad476ffdcb7/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3a4869029faad868154af6869caad476ffdcb7/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=8e3a4869029faad868154af6869caad476ffdcb7", "patch": "@@ -1084,6 +1084,8 @@ improve_inheritance (bitmap changed_pseudos)\n   lra_copy_t cp, next_cp;\n   bitmap_iterator bi;\n \n+  if (lra_inheritance_iter > LRA_MAX_INHERITANCE_PASSES)\n+    return;\n   n = 0;\n   EXECUTE_IF_SET_IN_BITMAP (&lra_inheritance_pseudos, 0, k, bi)\n     if (reg_renumber[k] >= 0 && lra_reg_info[k].nrefs != 0)"}, {"sha": "f6c6c89b8582ab6cfe56acdca312a623e4946bf4", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3a4869029faad868154af6869caad476ffdcb7/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3a4869029faad868154af6869caad476ffdcb7/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=8e3a4869029faad868154af6869caad476ffdcb7", "patch": "@@ -3201,10 +3201,6 @@ loc_equivalence_callback (rtx loc, const_rtx, void *)\n   return NULL_RTX;\n }\n \n-/* Maximum allowed number of constraint pass iterations after the last\n-   spill pass.\tIt is for preventing LRA cycling in a bug case.\t */\n-#define MAX_CONSTRAINT_ITERATION_NUMBER 30\n-\n /* Maximum number of generated reload insns per an insn.  It is for\n    preventing this pass cycling in a bug case.\t*/\n #define MAX_RELOAD_INSNS_NUMBER LRA_MAX_INSN_RELOADS\n@@ -3328,10 +3324,10 @@ lra_constraints (bool first_p)\n     fprintf (lra_dump_file, \"\\n********** Local #%d: **********\\n\\n\",\n \t     lra_constraint_iter);\n   lra_constraint_iter_after_spill++;\n-  if (lra_constraint_iter_after_spill > MAX_CONSTRAINT_ITERATION_NUMBER)\n+  if (lra_constraint_iter_after_spill > LRA_MAX_CONSTRAINT_ITERATION_NUMBER)\n     internal_error\n       (\"Maximum number of LRA constraint passes is achieved (%d)\\n\",\n-       MAX_CONSTRAINT_ITERATION_NUMBER);\n+       LRA_MAX_CONSTRAINT_ITERATION_NUMBER);\n   changed_p = false;\n   lra_risky_transformations_p = false;\n   new_insn_uid_start = get_max_uid ();\n@@ -4698,21 +4694,6 @@ inherit_in_ebb (rtx head, rtx tail)\n   return change_p;\n }\n \n-/* The maximal number of inheritance/split passes in LRA.  It should\n-   be more 1 in order to perform caller saves transformations and much\n-   less MAX_CONSTRAINT_ITERATION_NUMBER to prevent LRA to do as many\n-   as permitted constraint passes in some complicated cases.  The\n-   first inheritance/split pass has a biggest impact on generated code\n-   quality.  Each subsequent affects generated code in less degree.\n-   For example, the 3rd pass does not change generated SPEC2000 code\n-   at all on x86-64.  */\n-#define MAX_INHERITANCE_PASSES 2\n-\n-#if MAX_INHERITANCE_PASSES <= 0 \\\n-    || MAX_INHERITANCE_PASSES >= MAX_CONSTRAINT_ITERATION_NUMBER - 8\n-#error wrong MAX_INHERITANCE_PASSES value\n-#endif\n-\n /* This value affects EBB forming.  If probability of edge from EBB to\n    a BB is not greater than the following value, we don't add the BB\n    to EBB.  */\n@@ -4730,7 +4711,7 @@ lra_inheritance (void)\n   edge e;\n \n   lra_inheritance_iter++;\n-  if (lra_inheritance_iter > MAX_INHERITANCE_PASSES)\n+  if (lra_inheritance_iter > LRA_MAX_INHERITANCE_PASSES)\n     return;\n   timevar_push (TV_LRA_INHERITANCE);\n   if (lra_dump_file != NULL)\n@@ -5000,7 +4981,7 @@ lra_undo_inheritance (void)\n   bool change_p;\n \n   lra_undo_inheritance_iter++;\n-  if (lra_undo_inheritance_iter > MAX_INHERITANCE_PASSES)\n+  if (lra_undo_inheritance_iter > LRA_MAX_INHERITANCE_PASSES)\n     return false;\n   if (lra_dump_file != NULL)\n     fprintf (lra_dump_file,"}, {"sha": "064722936baea769a1b619ebf2933a4de7403d2c", "filename": "gcc/lra-int.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3a4869029faad868154af6869caad476ffdcb7/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3a4869029faad868154af6869caad476ffdcb7/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=8e3a4869029faad868154af6869caad476ffdcb7", "patch": "@@ -249,6 +249,25 @@ typedef struct lra_insn_recog_data *lra_insn_recog_data_t;\n #define LRA_LOSER_COST_FACTOR 6\n #define LRA_MAX_REJECT 600\n \n+/* Maximum allowed number of constraint pass iterations after the last\n+   spill pass.\tIt is for preventing LRA cycling in a bug case.\t */\n+#define LRA_MAX_CONSTRAINT_ITERATION_NUMBER 30\n+\n+/* The maximal number of inheritance/split passes in LRA.  It should\n+   be more 1 in order to perform caller saves transformations and much\n+   less MAX_CONSTRAINT_ITERATION_NUMBER to prevent LRA to do as many\n+   as permitted constraint passes in some complicated cases.  The\n+   first inheritance/split pass has a biggest impact on generated code\n+   quality.  Each subsequent affects generated code in less degree.\n+   For example, the 3rd pass does not change generated SPEC2000 code\n+   at all on x86-64.  */\n+#define LRA_MAX_INHERITANCE_PASSES 2\n+\n+#if LRA_MAX_INHERITANCE_PASSES <= 0 \\\n+    || LRA_MAX_INHERITANCE_PASSES >= LRA_MAX_CONSTRAINT_ITERATION_NUMBER - 8\n+#error wrong LRA_MAX_INHERITANCE_PASSES value\n+#endif\n+\n /* lra.c: */\n \n extern FILE *lra_dump_file;"}, {"sha": "cfbece022a915c4d535b68e227dfa1fba55115bd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3a4869029faad868154af6869caad476ffdcb7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3a4869029faad868154af6869caad476ffdcb7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e3a4869029faad868154af6869caad476ffdcb7", "patch": "@@ -1,3 +1,8 @@\n+2012-12-21  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR middle-end/55775\n+\t* gcc.target/i386/pr55775.c: New test.\n+\n 2012-12-21  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* gcc.dg/pthread-init-2.c (dg-options): Define _XOPEN_SOURCE=500"}, {"sha": "1902f688324d50929afcd02c5867db4c7100df25", "filename": "gcc/testsuite/gcc.target/i386/pr55775.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e3a4869029faad868154af6869caad476ffdcb7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr55775.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e3a4869029faad868154af6869caad476ffdcb7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr55775.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr55775.c?ref=8e3a4869029faad868154af6869caad476ffdcb7", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1\" } */\n+\n+int *ptr;\n+int *fn1 (int *);\n+int fn2 (int, int);\n+int fn3 (void);\n+int fn4 (int);\n+\n+static int\n+foo (int x, int y, int z)\n+{\n+  int b;\n+  asm (\"\" : \"=a\" (b), \"=&d\" (x) : \"0\" (y), \"1\" (x), \"mr\" (z));\n+  return x;\n+}\n+\n+static int\n+bar (int x, int y)\n+{\n+  int a;\n+  if (!y)\n+    {\n+      for (a = 0; a <= (x >> 1); )\n+\t;\n+      a = foo (y, fn2 (2, x), x);\n+      if (x)\n+\ta = x;\n+      return a;\n+    }\n+}\n+\n+static int\n+baz (int x, int y)\n+{\n+  int *a = ptr;\n+  int t, xk1 = fn3 (), xk = x * xk1;\n+  for (t = 0; t < xk; t += xk1)\n+    {\n+      if (fn4 (a[2]))\n+\treturn -y;\n+      a = fn1 (a);\n+    }\n+  return 0;\n+}\n+\n+void\n+test (int x, long y, int z)\n+{\n+  int a = fn3 ();\n+  int b;\n+  int c = bar (x, z);\n+  for (b = 0; b <= y; b++)\n+    c = baz (x, c);\n+  fn2 (c, a);\n+}"}]}