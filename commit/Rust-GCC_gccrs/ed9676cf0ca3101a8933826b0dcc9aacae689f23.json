{"sha": "ed9676cf0ca3101a8933826b0dcc9aacae689f23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ5Njc2Y2YwY2EzMTAxYTg5MzM4MjZiMGRjYzlhYWNhZTY4OWYyMw==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2004-04-30T16:40:22Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-04-30T16:40:22Z"}, "message": "s390-protos.h (s390_emit_epilogue): Parameter added.\n\n2004-04-29  Andreas Krebbel  <krebbel1@de.ibm.com>\n\nChangeLog:\n\n\t* config/s390/s390-protos.h (s390_emit_epilogue): Parameter added.\n\t(s390_emit_call): New function prototype added.\n\t(s390_tls_get_offset): Function removed.\n\t* config/s390/s390.c (s390_function_ok_for_sibcall,\n\ts390_call_saved_register_used_p): New functions.\n\t(TARGET_FUNCTION_OK_FOR_SIBCALL): Definition of target macro added.\n\t(s390_tls_get_offset): Function merged into s390_emit_tls_call_insn.\n\t(s390_emit_tls_call_insn): New function.\n\t(legitimize_tls_address): Call s390_emit_tls_call_insn instead of\n\temit_call_insn.\n\t(s390_emit_prologue): Use s390_emit_call instead of emit_call_insn.\n\t(s390_emit_epilogue): Like s390_emit_prologue. Parameter for sibcalls\n\tadded.\n\t* config/s390/s390.h (SIBCALL_REGNUM): New macro representing the\n\tregister number used to hold the target address for sibcalls.\n\t* config/s390/s390.md (\"sibcall\", \"sibcall_value\", \"sibcall_epilogue\"):\n\tNew expanders.\n\t(\"*sibcall_br\", \"*sibcall_brc\", \"*sibcall_brcl\", \"*sibcall_value_br\",\n\t\"*sibcall_value_brc\", \"*sibcall_value_brcl\"): New insns.\n\t(\"call_exp\", \"call_value_exp\", \"call_value_tls\", \"call_value_tls_exp\"):\n\tExpanders removed.\n\t(\"call\", \"call_value\"): Call s390_emit_call to emit the call patterns.\n\t(\"*bras\", \"*brasl\", \"*bras_r\", \"*brasl_r\", \"*bras_tls\", \"*brasl_tls\",\n\t\"*basr\", \"*basr_r\", \"*basr_tls\"): Added constraint: !SIBLING_CALL_P.\n\t(\"epilogue\"): Changed the call to s390_emit_epilogue to use the\n\tnew parameter.\n\ntestsuite/ChangeLog:\n\n\t* gcc.dg/sibcall-3.c: Delete s390 from expected fail list.\n\t* gcc.dg/sibcall-4.c: Likewise.\n\t* gcc.dg/sibcall-6.c: Enable s390 as test platform.\n\nFrom-SVN: r81347", "tree": {"sha": "85d7ec3dbeb3f7fe0c9024b8cf3ba9c9f770ed24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85d7ec3dbeb3f7fe0c9024b8cf3ba9c9f770ed24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed9676cf0ca3101a8933826b0dcc9aacae689f23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed9676cf0ca3101a8933826b0dcc9aacae689f23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed9676cf0ca3101a8933826b0dcc9aacae689f23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed9676cf0ca3101a8933826b0dcc9aacae689f23/comments", "author": null, "committer": null, "parents": [{"sha": "1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ae58c30e27a46925523033fe3f5aa20f7b6b4d0"}], "stats": {"total": 589, "additions": 385, "deletions": 204}, "files": [{"sha": "4ef6b7eb4b085f3fa5a5906e91ef4a4fe9ca4486", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9676cf0ca3101a8933826b0dcc9aacae689f23/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9676cf0ca3101a8933826b0dcc9aacae689f23/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed9676cf0ca3101a8933826b0dcc9aacae689f23", "patch": "@@ -1,3 +1,32 @@\n+2004-04-29  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* config/s390/s390-protos.h (s390_emit_epilogue): Parameter added.\n+\t(s390_emit_call): New function prototype added.\n+\t(s390_tls_get_offset): Function removed.\n+\t* config/s390/s390.c (s390_function_ok_for_sibcall,\n+\ts390_call_saved_register_used_p): New functions.\n+\t(TARGET_FUNCTION_OK_FOR_SIBCALL): Definition of target macro added.\n+\t(s390_tls_get_offset): Function merged into s390_emit_tls_call_insn.\n+\t(s390_emit_tls_call_insn): New function.\n+\t(legitimize_tls_address): Call s390_emit_tls_call_insn instead of\n+\temit_call_insn.\n+\t(s390_emit_prologue): Use s390_emit_call instead of emit_call_insn.\n+\t(s390_emit_epilogue): Like s390_emit_prologue. Parameter for sibcalls \n+\tadded.\n+\t* config/s390/s390.h (SIBCALL_REGNUM): New macro representing the \n+\tregister number used to hold the target address for sibcalls.\n+\t* config/s390/s390.md (\"sibcall\", \"sibcall_value\", \"sibcall_epilogue\"):\n+\tNew expanders.\n+\t(\"*sibcall_br\", \"*sibcall_brc\", \"*sibcall_brcl\", \"*sibcall_value_br\", \n+\t\"*sibcall_value_brc\", \"*sibcall_value_brcl\"): New insns.\n+\t(\"call_exp\", \"call_value_exp\", \"call_value_tls\", \"call_value_tls_exp\"): \n+\tExpanders removed.\n+\t(\"call\", \"call_value\"): Call s390_emit_call to emit the call patterns.\n+\t(\"*bras\", \"*brasl\", \"*bras_r\", \"*brasl_r\", \"*bras_tls\", \"*brasl_tls\", \n+\t\"*basr\", \"*basr_r\", \"*basr_tls\"): Added constraint: !SIBLING_CALL_P.\n+\t(\"epilogue\"): Changed the call to s390_emit_epilogue to use the\n+\tnew parameter.\n+\n 2004-04-30  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* bb-reorder.c, c-opts.c, cfglayout.c, cgraph.c, cgraphunit.c,"}, {"sha": "a42dd20ab33638e465d85c38c6d0504b5d04b7c6", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9676cf0ca3101a8933826b0dcc9aacae689f23/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9676cf0ca3101a8933826b0dcc9aacae689f23/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=ed9676cf0ca3101a8933826b0dcc9aacae689f23", "patch": "@@ -26,7 +26,7 @@ extern void override_options (void);\n extern HOST_WIDE_INT s390_arg_frame_offset (void);\n extern void s390_load_got (int);\n extern void s390_emit_prologue (void);\n-extern void s390_emit_epilogue (void);\n+extern void s390_emit_epilogue (bool);\n extern void s390_function_profiler (FILE *, int);\n \n #ifdef RTX_CODE\n@@ -53,7 +53,6 @@ extern int s390_alc_comparison (rtx op, enum machine_mode mode);\n extern int s390_slb_comparison (rtx op, enum machine_mode mode);\n extern int symbolic_reference_mentioned_p (rtx);\n extern int tls_symbolic_reference_mentioned_p (rtx);\n-extern rtx s390_tls_get_offset (void);\n extern int legitimate_la_operand_p (rtx);\n extern int preferred_la_operand_p (rtx);\n extern int legitimate_pic_operand_p (rtx);\n@@ -77,6 +76,7 @@ extern void s390_expand_movstr (rtx, rtx, rtx);\n extern void s390_expand_clrstr (rtx, rtx);\n extern void s390_expand_cmpmem (rtx, rtx, rtx, rtx);\n extern rtx s390_return_addr_rtx (int, rtx);\n+extern rtx s390_emit_call (rtx, rtx, rtx, rtx);\n \n extern bool s390_output_addr_const_extra (FILE*, rtx);\n extern void print_operand_address (FILE *, rtx);"}, {"sha": "35dca944d77cdfce0b214b551f7613ac3f3241b6", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 233, "deletions": 47, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9676cf0ca3101a8933826b0dcc9aacae689f23/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9676cf0ca3101a8933826b0dcc9aacae689f23/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=ed9676cf0ca3101a8933826b0dcc9aacae689f23", "patch": "@@ -78,6 +78,8 @@ static int s390_address_cost (rtx);\n static void s390_reorg (void);\n static bool s390_valid_pointer_mode (enum machine_mode);\n static tree s390_build_builtin_va_list (void);\n+static bool s390_function_ok_for_sibcall (tree, tree);\n+static bool s390_call_saved_register_used (tree);\n \n #undef  TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n@@ -151,6 +153,9 @@ static tree s390_build_builtin_va_list (void);\n #undef TARGET_PROMOTE_FUNCTION_RETURN\n #define TARGET_PROMOTE_FUNCTION_RETURN hook_bool_tree_true\n \n+#undef TARGET_FUNCTION_OK_FOR_SIBCALL\n+#define TARGET_FUNCTION_OK_FOR_SIBCALL s390_function_ok_for_sibcall\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n extern int reload_completed;\n@@ -2610,16 +2615,29 @@ get_thread_pointer (void)\n   return tp;\n }\n \n-/* Construct the SYMBOL_REF for the tls_get_offset function.  */\n+/* Emit a tls call insn. The call target is the SYMBOL_REF stored\n+   in s390_tls_symbol which always refers to __tls_get_offset.\n+   The returned offset is written to RESULT_REG and an USE rtx is\n+   generated for TLS_CALL.  */\n \n static GTY(()) rtx s390_tls_symbol;\n-rtx\n-s390_tls_get_offset (void)\n+\n+static void\n+s390_emit_tls_call_insn (rtx result_reg, rtx tls_call)\n {\n+  rtx insn;\n+  \n+  if (!flag_pic)\n+    abort ();\n+\n   if (!s390_tls_symbol)\n     s390_tls_symbol = gen_rtx_SYMBOL_REF (Pmode, \"__tls_get_offset\");\n \n-  return s390_tls_symbol;\n+  insn = s390_emit_call (s390_tls_symbol, tls_call, result_reg, \n+\t\t\t gen_rtx_REG (Pmode, RETURN_REGNUM)); \n+\n+  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), result_reg);\n+  CONST_OR_PURE_CALL_P (insn) = 1;\n }\n \n /* ADDR contains a thread-local SYMBOL_REF.  Generate code to compute\n@@ -2640,7 +2658,7 @@ legitimize_tls_address (rtx addr, rtx reg)\n \tnew = gen_rtx_CONST (Pmode, tls_call);\n \tnew = force_const_mem (Pmode, new);\n \temit_move_insn (r2, new);\n-\temit_call_insn (gen_call_value_tls (r2, tls_call));\n+\ts390_emit_tls_call_insn (r2, tls_call);\n \tinsn = get_insns ();\n \tend_sequence ();\n \n@@ -2663,7 +2681,7 @@ legitimize_tls_address (rtx addr, rtx reg)\n \tnew = gen_rtx_CONST (Pmode, tls_call);\n \tnew = force_const_mem (Pmode, new);\n \temit_move_insn (r2, new);\n-\temit_call_insn (gen_call_value_tls (r2, tls_call));\n+\ts390_emit_tls_call_insn (r2, tls_call);\n \tinsn = get_insns ();\n \tend_sequence ();\n \n@@ -5668,15 +5686,8 @@ s390_emit_prologue (void)\n \t algorithms located at the branch target.\n \n \t This must use register 1.  */\n-      rtx addr;\n-      rtx unkn;\n-      rtx link;\n-\n-      addr = GEN_INT (0xfe0);\n-      unkn = CONST0_RTX (SImode);\n-      link = gen_rtx_REG (Pmode, 1);\n-\n-      emit_call_insn (gen_call_exp (gen_rtx_MEM (QImode, addr), unkn, link));\n+      s390_emit_call (GEN_INT (0xfe0), NULL_RTX, NULL_RTX, \n+\t\t      gen_rtx_REG (Pmode, 1));\n \n       /* Emit a blockage here so that all code\n \t lies between the profiling mechanisms.  */\n@@ -5687,7 +5698,7 @@ s390_emit_prologue (void)\n /* Expand the epilogue into a bunch of separate insns.  */\n \n void\n-s390_emit_epilogue (void)\n+s390_emit_epilogue (bool sibcall)\n {\n   rtx frame_pointer, return_reg;\n   int area_bottom, area_top, offset = 0;\n@@ -5703,19 +5714,12 @@ s390_emit_epilogue (void)\n \n \t This must use register 1.  */\n \n-      rtx addr;\n-      rtx unkn;\n-      rtx link;\n-\n-      addr = GEN_INT (0xfe6);\n-      unkn = CONST0_RTX (SImode);\n-      link = gen_rtx_REG (Pmode, 1);\n-\n       /* Emit a blockage here so that all code\n          lies between the profiling mechanisms.  */\n       emit_insn (gen_blockage ());\n \n-      emit_call_insn (gen_call_exp (gen_rtx_MEM (QImode, addr), unkn, link));\n+      s390_emit_call (GEN_INT (0xfe6), NULL_RTX, NULL_RTX, \n+\t\t      gen_rtx_REG (Pmode, 1));\n     }\n \n   /* Check whether to use frame or stack pointer for restore.  */\n@@ -5847,23 +5851,26 @@ s390_emit_epilogue (void)\n \t    }\n \t}\n \n-      /* Fetch return address from stack before load multiple,\n-\t this will do good for scheduling.  */\n-\n-      if (cfun->machine->save_return_addr_p\n-\t  || (cfun->machine->first_restore_gpr < BASE_REGISTER\n-\t      && cfun->machine->last_save_gpr > RETURN_REGNUM))\n+      if (! sibcall)\n \t{\n-\t  int return_regnum = find_unused_clobbered_reg();\n-\t  if (!return_regnum)\n-\t    return_regnum = 4;\n-\t  return_reg = gen_rtx_REG (Pmode, return_regnum);\n-\n-\t  addr = plus_constant (frame_pointer,\n-\t\t\t\toffset + RETURN_REGNUM * UNITS_PER_WORD);\n-\t  addr = gen_rtx_MEM (Pmode, addr);\n-\t  set_mem_alias_set (addr, s390_sr_alias_set);\n-\t  emit_move_insn (return_reg, addr);\n+\t  /* Fetch return address from stack before load multiple,\n+\t     this will do good for scheduling.  */\n+\t  \n+\t  if (cfun->machine->save_return_addr_p\n+\t      || (cfun->machine->first_restore_gpr < BASE_REGISTER\n+\t\t  && cfun->machine->last_save_gpr > RETURN_REGNUM))\n+\t    {\n+\t      int return_regnum = find_unused_clobbered_reg();\n+\t      if (!return_regnum)\n+\t\treturn_regnum = 4;\n+\t      return_reg = gen_rtx_REG (Pmode, return_regnum);\n+\t      \n+\t      addr = plus_constant (frame_pointer,\n+\t\t\t\t    offset + RETURN_REGNUM * UNITS_PER_WORD);\n+\t      addr = gen_rtx_MEM (Pmode, addr);\n+\t      set_mem_alias_set (addr, s390_sr_alias_set);\n+\t      emit_move_insn (return_reg, addr);\n+\t    }\n \t}\n \n       /* ??? As references to the base register are not made\n@@ -5878,13 +5885,17 @@ s390_emit_epilogue (void)\n       emit_insn (insn);\n     }\n \n-  /* Return to caller.  */\n-\n-  p = rtvec_alloc (2);\n+  if (! sibcall)\n+    {\n \n-  RTVEC_ELT (p, 0) = gen_rtx_RETURN (VOIDmode);\n-  RTVEC_ELT (p, 1) = gen_rtx_USE (VOIDmode, return_reg);\n-  emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, p));\n+      /* Return to caller.  */\n+      \n+      p = rtvec_alloc (2);\n+      \n+      RTVEC_ELT (p, 0) = gen_rtx_RETURN (VOIDmode);\n+      RTVEC_ELT (p, 1) = gen_rtx_USE (VOIDmode, return_reg);\n+      emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, p));\n+    }\n }\n \n \n@@ -6999,4 +7010,179 @@ s390_init_machine_status (void)\n   return ggc_alloc_cleared (sizeof (struct machine_function));\n }\n \n+/* Checks whether the given ARGUMENT_LIST would use a caller\n+   saved register.  This is used to decide whether sibling call\n+   optimization could be performed on the respective function\n+   call.  */\n+\n+static bool\n+s390_call_saved_register_used (tree argument_list)\n+{\n+  CUMULATIVE_ARGS cum;\n+  tree parameter;\n+  enum machine_mode mode;\n+  tree type;\n+  rtx parm_rtx;\n+  int reg;\n+\n+  INIT_CUMULATIVE_ARGS (cum, NULL, NULL, 0, 0);\n+\n+  while (argument_list)\n+    {\n+      parameter = TREE_VALUE (argument_list);\n+      argument_list = TREE_CHAIN (argument_list);\n+\n+      if (!parameter)\n+\tabort();\n+\n+      /* For an undeclared variable passed as parameter we will get\n+\t an ERROR_MARK node here.  */\n+      if (TREE_CODE (parameter) == ERROR_MARK)\n+\treturn true;\n+\n+      if (! (type = TREE_TYPE (parameter)))\n+\tabort();\n+      \n+      if (! (mode = TYPE_MODE (TREE_TYPE (parameter))))\n+\tabort();\n+\n+      if (s390_function_arg_pass_by_reference (mode, type))\n+ \t{\n+ \t  mode = Pmode;\n+ \t  type = build_pointer_type (type);\n+ \t}\n+      \n+       parm_rtx = s390_function_arg (&cum, mode, type, 0);\n+\n+       s390_function_arg_advance (&cum, mode, type, 0);\n+ \n+       if (parm_rtx && REG_P (parm_rtx))\n+\t {\n+\t   for (reg = 0;\n+\t\treg < HARD_REGNO_NREGS (REGNO (parm_rtx), GET_MODE (parm_rtx)); \n+\t\treg++)\n+\t     if (! call_used_regs[reg + REGNO (parm_rtx)])\n+\t       return true;\n+\t }\n+    }\n+  return false;\n+}\n+\n+/* Return true if the given call expression can be \n+   turned into a sibling call.  \n+   DECL holds the declaration of the function to be called whereas\n+   EXP is the call expression itself.  */\n+   \n+static bool\n+s390_function_ok_for_sibcall (tree decl, tree exp)\n+{\n+  /* The TPF epilogue uses register 1.  */\n+  if (TARGET_TPF)\n+    return false;\n+\n+  /* The 31 bit PLT code uses register 12 (GOT pointer - caller saved) \n+     which would have to be restored before the sibcall.  */\n+  if (!TARGET_64BIT && flag_pic && decl && TREE_PUBLIC (decl))\n+    return false;\n+\n+  /* Register 6 on s390 is available as an argument register but unfortunately\n+     \"caller saved\". This makes functions needing this register for arguments\n+     not suitable for sibcalls.  */ \n+  if (TREE_OPERAND (exp, 1)\n+      && s390_call_saved_register_used (TREE_OPERAND (exp, 1)))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* This function is used by the call expanders of the machine description. \n+   It emits the call insn itself together with the necessary operations \n+   to adjust the target address and returns the emitted insn.\n+   ADDR_LOCATION is the target address rtx\n+   TLS_CALL the location of the thread-local symbol\n+   RESULT_REG the register where the result of the call should be stored\n+   RETADDR_REG the register where the return address should be stored\n+               If this parameter is NULL_RTX the call is considered\n+               to be a sibling call.  */\n+\n+rtx\n+s390_emit_call (rtx addr_location, rtx tls_call, rtx result_reg, \n+\t\trtx retaddr_reg)\n+{\n+  bool plt_call = false;\n+  rtx insn;\n+  rtx call;\n+  rtx clobber;\n+  rtvec vec;\n+\n+  /* Direct function calls need special treatment.  */\n+  if (GET_CODE (addr_location) == SYMBOL_REF)\n+    {\n+      /* When calling a global routine in PIC mode, we must\n+         replace the symbol itself with the PLT stub.  */\n+      if (flag_pic && !SYMBOL_REF_LOCAL_P (addr_location))\n+        {\n+\t  addr_location = gen_rtx_UNSPEC (Pmode, \n+\t\t\t\t\t  gen_rtvec (1, addr_location), \n+\t\t\t\t\t  UNSPEC_PLT);\n+\t  addr_location = gen_rtx_CONST (Pmode, addr_location);\n+\t  plt_call = true;\n+        }\n+      \n+      /* Unless we can use the bras(l) insn, force the\n+         routine address into a register.  */\n+      if (!TARGET_SMALL_EXEC && !TARGET_CPU_ZARCH)\n+        {\n+\t  if (flag_pic)\n+\t    addr_location = legitimize_pic_address (addr_location, 0);\n+\t  else\n+\t    addr_location = force_reg (Pmode, addr_location);\n+\t}\n+    } \n+\n+  /* If it is already an indirect call or the code above moved the\n+     SYMBOL_REF to somewhere else make sure the address can be found in \n+     register 1.  */\n+  if (retaddr_reg == NULL_RTX\n+      && GET_CODE (addr_location) != SYMBOL_REF\n+      && !plt_call)\n+    {\n+      emit_move_insn (gen_rtx_REG (Pmode, SIBCALL_REGNUM), addr_location);\n+      addr_location = gen_rtx_REG (Pmode, SIBCALL_REGNUM);\n+    }\n+  \n+  addr_location = gen_rtx_MEM (QImode, addr_location);\n+  call = gen_rtx_CALL (VOIDmode, addr_location, const0_rtx);\n+\n+  if (result_reg != NULL_RTX)\n+    call = gen_rtx_SET (VOIDmode, result_reg, call);\n+    \n+  if (retaddr_reg != NULL_RTX)\n+    {\n+      clobber = gen_rtx_CLOBBER (VOIDmode, retaddr_reg);\n+\n+      if (tls_call != NULL_RTX)\n+\tvec = gen_rtvec (3, call, clobber, \n+\t\t\t gen_rtx_USE (VOIDmode, tls_call));\n+      else\n+\tvec = gen_rtvec (2, call, clobber);\n+\n+      call = gen_rtx_PARALLEL (VOIDmode, vec);\n+    }\n+\n+  insn = emit_call_insn (call);\n+ \n+  /* 31-bit PLT stubs and tls calls use the GOT register implicitly.  */\n+  if ((!TARGET_64BIT && plt_call) || tls_call != NULL_RTX)\n+    {\n+      /* s390_function_ok_for_sibcall should \n+\t have denied sibcalls in this case.  */\n+      if (retaddr_reg == NULL_RTX)\n+\tabort ();\n+      \n+      use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n+    }\n+  return insn;\n+}\n+\n #include \"gt-s390.h\""}, {"sha": "0c4f2b381b099f788457723f781f1662c943f8e1", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9676cf0ca3101a8933826b0dcc9aacae689f23/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9676cf0ca3101a8933826b0dcc9aacae689f23/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=ed9676cf0ca3101a8933826b0dcc9aacae689f23", "patch": "@@ -299,6 +299,7 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n #define CC_REG_P(X)\t\t(REG_P (X) && CC_REGNO_P (REGNO (X)))\n #define FRAME_REG_P(X)\t\t(REG_P (X) && FRAME_REGNO_P (REGNO (X)))\n \n+#define SIBCALL_REGNUM 1\n #define BASE_REGISTER 13\n #define RETURN_REGNUM 14\n #define CC_REGNUM 33"}, {"sha": "30a7b8d7329ff179c8b3258ff6cc67ed7720ceec", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 111, "deletions": 152, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9676cf0ca3101a8933826b0dcc9aacae689f23/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9676cf0ca3101a8933826b0dcc9aacae689f23/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=ed9676cf0ca3101a8933826b0dcc9aacae689f23", "patch": "@@ -6970,71 +6970,111 @@\n   [(set_attr \"type\"    \"none\")\n    (set_attr \"length\"  \"0\")])\n \n-\n-\n ;\n-; call instruction pattern(s).\n+; sibcall patterns\n ;\n \n-(define_expand \"call\"\n+(define_expand \"sibcall\"\n   [(call (match_operand 0 \"\" \"\")\n-         (match_operand 1 \"\" \"\"))\n-   (use (match_operand 2 \"\" \"\"))]\n+\t (match_operand 1 \"\" \"\"))]\n   \"\"\n {\n-  bool plt_call = false;\n-  rtx insn;\n-\n-  /* Direct function calls need special treatment.  */\n-  if (GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n-    {\n-      rtx sym = XEXP (operands[0], 0);\n+  s390_emit_call (XEXP (operands[0], 0), NULL_RTX, NULL_RTX, NULL_RTX);\n+  DONE;\n+})\n \n-      /* When calling a global routine in PIC mode, we must\n-         replace the symbol itself with the PLT stub.  */\n-      if (flag_pic && !SYMBOL_REF_LOCAL_P (sym))\n-        {\n-          sym = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym), UNSPEC_PLT);\n-          sym = gen_rtx_CONST (Pmode, sym);\n-\t  plt_call = true;\n-        }\n+(define_insn \"*sibcall_br\"\n+  [(call (mem:QI (reg 1))\n+         (match_operand 0 \"const_int_operand\" \"n\"))]\n+  \"SIBLING_CALL_P (insn) \n+   && GET_MODE (XEXP (XEXP (PATTERN (insn), 0), 0)) == Pmode\"\n+  \"br\\t%%r1\"\n+  [(set_attr \"op_type\" \"RR\")\n+   (set_attr \"type\"  \"branch\")\n+   (set_attr \"atype\" \"agen\")])\n \n-      /* Unless we can use the bras(l) insn, force the\n-         routine address into a register.  */\n-      if (!TARGET_SMALL_EXEC && !TARGET_CPU_ZARCH)\n-\t{\n-\t  if (flag_pic)\n-\t    sym = legitimize_pic_address (sym, 0);\n-\t  else\n-\t    sym = force_reg (Pmode, sym);\n-\t}\n+(define_insn \"*sibcall_brc\"\n+  [(call (mem:QI (match_operand 0 \"bras_sym_operand\" \"X\"))\n+         (match_operand 1 \"const_int_operand\" \"n\"))]\n+  \"SIBLING_CALL_P (insn) && TARGET_SMALL_EXEC\"\n+  \"j\\t%0\"\n+  [(set_attr \"op_type\" \"RI\")\n+   (set_attr \"type\"    \"branch\")])\n \n-      operands[0] = gen_rtx_MEM (QImode, sym);\n-    }\n+(define_insn \"*sibcall_brcl\"\n+  [(call (mem:QI (match_operand 0 \"bras_sym_operand\" \"X\"))\n+         (match_operand 1 \"const_int_operand\" \"n\"))]\n+  \"SIBLING_CALL_P (insn) && TARGET_CPU_ZARCH\"\n+  \"jg\\t%0\"\n+  [(set_attr \"op_type\" \"RIL\")\n+   (set_attr \"type\"    \"branch\")])\n \n-  /* Emit insn.  */\n-  insn = emit_call_insn (gen_call_exp (operands[0], operands[1],\n-  \t\t\t\t       gen_rtx_REG (Pmode, RETURN_REGNUM)));\n+;\n+; sibcall_value patterns\n+;\n \n-  /* 31-bit PLT stubs use the GOT register implicitly.  */\n-  if (!TARGET_64BIT && plt_call)\n-    use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n-  \n+(define_expand \"sibcall_value\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (match_operand 1 \"\" \"\")\n+\t      (match_operand 2 \"\" \"\")))]\n+  \"\"\n+{\n+  s390_emit_call (XEXP (operands[1], 0), NULL_RTX, operands[0], NULL_RTX);\n   DONE;\n })\n \n-(define_expand \"call_exp\"\n-  [(parallel [(call (match_operand 0 \"\" \"\")\n-                    (match_operand 1 \"\" \"\"))\n-              (clobber (match_operand 2 \"\" \"\"))])]\n+(define_insn \"*sibcall_value_br\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (reg 1))\n+\t      (match_operand 1 \"const_int_operand\" \"n\")))]\n+  \"SIBLING_CALL_P (insn) \n+   && GET_MODE (XEXP (XEXP (XEXP (PATTERN (insn), 1), 0), 0)) == Pmode\"\n+  \"br\\t%%r1\"\n+  [(set_attr \"op_type\" \"RR\")\n+   (set_attr \"type\"  \"branch\")\n+   (set_attr \"atype\" \"agen\")])\n+\n+(define_insn \"*sibcall_value_brc\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand 1 \"bras_sym_operand\" \"X\"))\n+\t      (match_operand 2 \"const_int_operand\" \"n\")))]\n+  \"SIBLING_CALL_P (insn) && TARGET_SMALL_EXEC\"\n+  \"j\\t%1\"\n+  [(set_attr \"op_type\" \"RI\")\n+   (set_attr \"type\"    \"branch\")])\n+\n+(define_insn \"*sibcall_value_brcl\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand 1 \"bras_sym_operand\" \"X\"))\n+\t      (match_operand 2 \"const_int_operand\" \"n\")))]\n+  \"SIBLING_CALL_P (insn) && TARGET_CPU_ZARCH\"\n+  \"jg\\t%1\"\n+  [(set_attr \"op_type\" \"RIL\")\n+   (set_attr \"type\"    \"branch\")])\n+\n+\n+;\n+; call instruction pattern(s).\n+;\n+\n+(define_expand \"call\"\n+  [(call (match_operand 0 \"\" \"\")\n+         (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))]\n   \"\"\n-  \"\")\n+{\n+  s390_emit_call (XEXP (operands[0], 0), NULL_RTX, NULL_RTX, \n+\t\t  gen_rtx_REG (Pmode, RETURN_REGNUM));\n+  DONE;\n+})\n \n (define_insn \"*bras\"\n   [(call (mem:QI (match_operand 0 \"bras_sym_operand\" \"X\"))\n          (match_operand 1 \"const_int_operand\" \"n\"))\n    (clobber (match_operand 2 \"register_operand\" \"=r\"))]\n-  \"TARGET_SMALL_EXEC && GET_MODE (operands[2]) == Pmode\"\n+  \"!SIBLING_CALL_P (insn) \n+   && TARGET_SMALL_EXEC \n+   && GET_MODE (operands[2]) == Pmode\"\n   \"bras\\t%2,%0\"\n   [(set_attr \"op_type\" \"RI\")\n    (set_attr \"type\"    \"jsr\")])\n@@ -7043,7 +7083,9 @@\n   [(call (mem:QI (match_operand 0 \"bras_sym_operand\" \"X\"))\n          (match_operand 1 \"const_int_operand\" \"n\"))\n    (clobber (match_operand 2 \"register_operand\" \"=r\"))]\n-  \"TARGET_CPU_ZARCH && GET_MODE (operands[2]) == Pmode\"\n+  \"!SIBLING_CALL_P (insn) \n+   && TARGET_CPU_ZARCH \n+   && GET_MODE (operands[2]) == Pmode\"\n   \"brasl\\t%2,%0\"\n   [(set_attr \"op_type\" \"RIL\")\n    (set_attr \"type\"    \"jsr\")])\n@@ -7052,7 +7094,7 @@\n   [(call (mem:QI (match_operand 0 \"address_operand\" \"U\"))\n          (match_operand 1 \"const_int_operand\" \"n\"))\n    (clobber (match_operand 2 \"register_operand\" \"=r\"))]\n-  \"GET_MODE (operands[2]) == Pmode\"\n+  \"!SIBLING_CALL_P (insn) && GET_MODE (operands[2]) == Pmode\"\n {\n   if (get_attr_op_type (insn) == OP_TYPE_RR)\n     return \"basr\\t%2,%0\";\n@@ -7076,62 +7118,19 @@\n    (use (match_operand 3 \"\" \"\"))]\n   \"\"\n {\n-  bool plt_call = false;\n-  rtx insn;\n-\n-  /* Direct function calls need special treatment.  */\n-  if (GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n-    {\n-      rtx sym = XEXP (operands[1], 0);\n-\n-      /* When calling a global routine in PIC mode, we must\n-         replace the symbol itself with the PLT stub.  */\n-      if (flag_pic && !SYMBOL_REF_LOCAL_P (sym))\n-        {\n-          sym = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym), UNSPEC_PLT);\n-          sym = gen_rtx_CONST (Pmode, sym);\n-\t  plt_call = true;\n-        }\n-\n-      /* Unless we can use the bras(l) insn, force the\n-         routine address into a register.  */\n-      if (!TARGET_SMALL_EXEC && !TARGET_CPU_ZARCH)\n-        {\n-\t  if (flag_pic)\n-\t    sym = legitimize_pic_address (sym, 0);\n-\t  else\n-\t    sym = force_reg (Pmode, sym);\n-        }\n-\n-      operands[1] = gen_rtx_MEM (QImode, sym);\n-    }\n-\n-  /* Emit insn.  */\n-  insn = emit_call_insn (\n-\t    gen_call_value_exp (operands[0], operands[1], operands[2],\n-  \t\t\t\tgen_rtx_REG (Pmode, RETURN_REGNUM)));\n-\n-  /* 31-bit PLT stubs use the GOT register implicitly.  */\n-  if (!TARGET_64BIT && plt_call)\n-    use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n-  \n+  s390_emit_call (XEXP (operands[1], 0), NULL_RTX, operands[0], \n+\t\t  gen_rtx_REG (Pmode, RETURN_REGNUM));\n   DONE;\n })\n \n-(define_expand \"call_value_exp\"\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n-                   (call (match_operand 1 \"\" \"\")\n-                         (match_operand 2 \"\" \"\")))\n-              (clobber (match_operand 3 \"\" \"\"))])]\n-  \"\"\n-  \"\")\n-\n (define_insn \"*bras_r\"\n   [(set (match_operand 0 \"\" \"\")\n         (call (mem:QI (match_operand 1 \"bras_sym_operand\" \"X\"))\n               (match_operand:SI 2 \"const_int_operand\" \"n\")))\n    (clobber (match_operand 3 \"register_operand\" \"=r\"))]\n-  \"TARGET_SMALL_EXEC && GET_MODE (operands[3]) == Pmode\"\n+  \"!SIBLING_CALL_P (insn) \n+   && TARGET_SMALL_EXEC \n+   && GET_MODE (operands[3]) == Pmode\"\n   \"bras\\t%3,%1\"\n   [(set_attr \"op_type\" \"RI\")\n    (set_attr \"type\"    \"jsr\")])\n@@ -7141,7 +7140,9 @@\n         (call (mem:QI (match_operand 1 \"bras_sym_operand\" \"X\"))\n               (match_operand 2 \"const_int_operand\" \"n\")))\n    (clobber (match_operand 3 \"register_operand\" \"=r\"))]\n-  \"TARGET_CPU_ZARCH && GET_MODE (operands[3]) == Pmode\"\n+  \"!SIBLING_CALL_P (insn) \n+   && TARGET_CPU_ZARCH \n+   && GET_MODE (operands[3]) == Pmode\"\n   \"brasl\\t%3,%1\"\n   [(set_attr \"op_type\" \"RIL\")\n    (set_attr \"type\"    \"jsr\")])\n@@ -7151,7 +7152,7 @@\n         (call (mem:QI (match_operand 1 \"address_operand\" \"U\"))\n               (match_operand 2 \"const_int_operand\" \"n\")))\n    (clobber (match_operand 3 \"register_operand\" \"=r\"))]\n-  \"GET_MODE (operands[3]) == Pmode\"\n+  \"!SIBLING_CALL_P (insn) && GET_MODE (operands[3]) == Pmode\"\n {\n   if (get_attr_op_type (insn) == OP_TYPE_RR)\n     return \"basr\\t%3,%1\";\n@@ -7229,64 +7230,15 @@\n    ly\\t%0,%1%J2\"\n   [(set_attr \"op_type\" \"RX,RXY\")])\n \n-(define_expand \"call_value_tls\"\n-  [(set (match_operand 0 \"\" \"\")\n-        (call (const_int 0) (const_int 0)))\n-   (use (match_operand 1 \"\" \"\"))]\n-  \"\"\n-{\n-  rtx insn, sym;\n-\n-  if (!flag_pic)\n-    abort ();\n-\n-  sym = s390_tls_get_offset ();\n-  sym = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym), UNSPEC_PLT);\n-  sym = gen_rtx_CONST (Pmode, sym);\n-\n-  /* Unless we can use the bras(l) insn, force the\n-     routine address into a register.  */\n-  if (!TARGET_SMALL_EXEC && !TARGET_CPU_ZARCH)\n-    {\n-      if (flag_pic)\n-\tsym = legitimize_pic_address (sym, 0);\n-      else\n-\tsym = force_reg (Pmode, sym);\n-    }\n-\n-  sym = gen_rtx_MEM (QImode, sym);\n-\n-  /* Emit insn.  */\n-  insn = emit_call_insn (\n-\t    gen_call_value_tls_exp (operands[0], sym, const0_rtx,\n-  \t\t\t\t    gen_rtx_REG (Pmode, RETURN_REGNUM),\n-\t\t\t\t    operands[1]));\n-\n-  /* The calling convention of __tls_get_offset uses the\n-     GOT register implicitly.  */\n-  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n-  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), operands[0]);\n-  CONST_OR_PURE_CALL_P (insn) = 1;\n-\n-  DONE;\n-})\n-\n-(define_expand \"call_value_tls_exp\"\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n-                   (call (match_operand 1 \"\" \"\")\n-                         (match_operand 2 \"\" \"\")))\n-              (clobber (match_operand 3 \"\" \"\"))\n-\t      (use (match_operand 4 \"\" \"\"))])]\n-  \"\"\n-  \"\")\n-\n (define_insn \"*bras_tls\"\n   [(set (match_operand 0 \"\" \"\")\n         (call (mem:QI (match_operand 1 \"bras_sym_operand\" \"X\"))\n               (match_operand 2 \"const_int_operand\" \"n\")))\n    (clobber (match_operand 3 \"register_operand\" \"=r\"))\n    (use (match_operand 4 \"\" \"\"))]\n-  \"TARGET_SMALL_EXEC && GET_MODE (operands[3]) == Pmode\"\n+  \"!SIBLING_CALL_P (insn) \n+   && TARGET_SMALL_EXEC \n+   && GET_MODE (operands[3]) == Pmode\"\n   \"bras\\t%3,%1%J4\"\n   [(set_attr \"op_type\" \"RI\")\n    (set_attr \"type\"    \"jsr\")])\n@@ -7297,7 +7249,9 @@\n               (match_operand 2 \"const_int_operand\" \"n\")))\n    (clobber (match_operand 3 \"register_operand\" \"=r\"))\n    (use (match_operand 4 \"\" \"\"))]\n-  \"TARGET_CPU_ZARCH && GET_MODE (operands[3]) == Pmode\"\n+  \"!SIBLING_CALL_P (insn) \n+   && TARGET_CPU_ZARCH \n+   && GET_MODE (operands[3]) == Pmode\"\n   \"brasl\\t%3,%1%J4\"\n   [(set_attr \"op_type\" \"RIL\")\n    (set_attr \"type\"    \"jsr\")])\n@@ -7308,7 +7262,7 @@\n               (match_operand 2 \"const_int_operand\" \"n\")))\n    (clobber (match_operand 3 \"register_operand\" \"=r\"))\n    (use (match_operand 4 \"\" \"\"))]\n-  \"GET_MODE (operands[3]) == Pmode\"\n+  \"!SIBLING_CALL_P (insn) && GET_MODE (operands[3]) == Pmode\"\n {\n   if (get_attr_op_type (insn) == OP_TYPE_RR)\n     return \"basr\\t%3,%1%J4\";\n@@ -7571,7 +7525,12 @@\n (define_expand \"epilogue\"\n   [(use (const_int 1))]\n   \"\"\n-  \"s390_emit_epilogue (); DONE;\")\n+  \"s390_emit_epilogue (false); DONE;\")\n+\n+(define_expand \"sibcall_epilogue\"\n+  [(use (const_int 0))]\n+  \"\"\n+  \"s390_emit_epilogue (true); DONE;\")\n \n (define_insn \"*return\"\n   [(return)"}, {"sha": "6b13596625c12842e453a845f0bbb434a0a8a1fa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9676cf0ca3101a8933826b0dcc9aacae689f23/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9676cf0ca3101a8933826b0dcc9aacae689f23/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ed9676cf0ca3101a8933826b0dcc9aacae689f23", "patch": "@@ -1,3 +1,9 @@\n+2004-04-29  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* gcc.dg/sibcall-3.c: Delete s390 from expected fail list.\n+\t* gcc.dg/sibcall-4.c: Likewise.\n+\t* gcc.dg/sibcall-6.c: Enable s390 as test platform.\n+\n 2004-04-30  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* gcc.c-torture/execute/20040331-1.c: Don't use too wide a"}, {"sha": "e61110f0c41b1aef87972f430095b8039a057b66", "filename": "gcc/testsuite/gcc.dg/sibcall-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9676cf0ca3101a8933826b0dcc9aacae689f23/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9676cf0ca3101a8933826b0dcc9aacae689f23/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-3.c?ref=ed9676cf0ca3101a8933826b0dcc9aacae689f23", "patch": "@@ -5,7 +5,7 @@\n    Copyright (C) 2002 Free Software Foundation Inc.\n    Contributed by Hans-Peter Nilsson  <hp@bitrange.com>  */\n \n-/* { dg-do run { xfail arc-*-* avr-*-* c4x-*-* cris-*-* h8300-*-* ip2k-*-* m32r-*-* m68hc1?-*-* m681?-*-* m680*-*-* m68k-*-* mcore-*-* mips*-*-* mn10300-*-* ns32k-*-* s390*-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa-*-* } } */\n+/* { dg-do run { xfail arc-*-* avr-*-* c4x-*-* cris-*-* h8300-*-* ip2k-*-* m32r-*-* m68hc1?-*-* m681?-*-* m680*-*-* m68k-*-* mcore-*-* mips*-*-* mn10300-*-* ns32k-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa-*-* } } */\n /* { dg-options \"-O2 -foptimize-sibling-calls\" } */\n \n /* The option -foptimize-sibling-calls is the default, but serves as"}, {"sha": "9674e75bd9c0c9ab7be129b68625fb5014b34276", "filename": "gcc/testsuite/gcc.dg/sibcall-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9676cf0ca3101a8933826b0dcc9aacae689f23/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9676cf0ca3101a8933826b0dcc9aacae689f23/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-4.c?ref=ed9676cf0ca3101a8933826b0dcc9aacae689f23", "patch": "@@ -5,7 +5,7 @@\n    Copyright (C) 2002 Free Software Foundation Inc.\n    Contributed by Hans-Peter Nilsson  <hp@bitrange.com>  */\n \n-/* { dg-do run { xfail arc-*-* avr-*-* c4x-*-* cris-*-* h8300-*-* ip2k-*-* m32r-*-* m68hc1?-*-* m681?-*-* m680*-*-* m68k-*-* mcore-*-* mips*-*-* mn10300-*-* ns32k-*-* s390*-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa-*-* } } */\n+/* { dg-do run { xfail arc-*-* avr-*-* c4x-*-* cris-*-* h8300-*-* ip2k-*-* m32r-*-* m68hc1?-*-* m681?-*-* m680*-*-* m68k-*-* mcore-*-* mips*-*-* mn10300-*-* ns32k-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa-*-* } } */\n /* { dg-options \"-O2 -foptimize-sibling-calls\" } */\n \n /* The option -foptimize-sibling-calls is the default, but serves as"}, {"sha": "4b0d299f5b784f5060471812c7fb3a658ce68536", "filename": "gcc/testsuite/gcc.dg/sibcall-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9676cf0ca3101a8933826b0dcc9aacae689f23/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9676cf0ca3101a8933826b0dcc9aacae689f23/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-6.c?ref=ed9676cf0ca3101a8933826b0dcc9aacae689f23", "patch": "@@ -6,7 +6,7 @@\n    Copyright (C) 2002 Free Software Foundation Inc.\n    Contributed by Andreas Bauer <baueran@in.tum.de>  */\n \n-/* { dg-do run { target i?86-*-* x86_64-*-*} } */\n+/* { dg-do run { target i?86-*-* s390*-*-* x86_64-*-*} } */\n /* { dg-options \"-O2 -foptimize-sibling-calls\" } */\n \n int foo (int);"}]}