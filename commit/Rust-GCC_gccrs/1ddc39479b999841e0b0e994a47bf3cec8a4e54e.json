{"sha": "1ddc39479b999841e0b0e994a47bf3cec8a4e54e", "node_id": "C_kwDOANBUbNoAKDFkZGMzOTQ3OWI5OTk4NDFlMGIwZTk5NGE0N2JmM2NlYzhhNGU1NGU", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2021-10-15T22:23:34Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-10-25T15:07:21Z"}, "message": "[Ada] Relax INOX restrictions when casing on composite value.\n\ngcc/ada/\n\n\t* sem_case.adb (Composite_Case_Ops.Box_Value_Required): A new\n\tfunction which takes a component type and returns a Boolean.\n\tReturns True for the cases which were formerly forbidden as\n\tcomponents (these checks were formerly performed in the\n\tnow-deleted procedure\n\tCheck_Composite_Case_Selector.Check_Component_Subtype).\n\t(Composite_Case_Ops.Normalized_Case_Expr_Type): Hoist this\n\tfunction out of the Array_Case_Ops package because it has been\n\tgeneralized to also do the analogous thing in the case of a\n\tdiscriminated type.\n\t(Composite_Case_Ops.Scalar_Part_Count): Return 0 if\n\tBox_Value_Required returns True for the given type/subtype.\n\t(Composite_Case_Ops.Choice_Analysis.Choice_Analysis.Component_Bounds_Info.\n\tTraverse_Discrete_Parts): Return without doing anything if\n\tBox_Value_Required returns True for the given type/subtype.\n\t(Composite_Case_Ops.Choice_Analysis.Parse_Choice.Traverse_Choice):\n\tIf Box_Value_Required yields True for a given component type,\n\tthen check that the value of that component in a choice\n\texpression is indeed a box (in which case the component is\n\tignored).\n\t* doc/gnat_rm/implementation_defined_pragmas.rst: Update\n\tdocumentation.\n\t* gnat_rm.texi: Regenerate.", "tree": {"sha": "f5241de8be61a6b3038b7123cd9a077ae642b99a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5241de8be61a6b3038b7123cd9a077ae642b99a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ddc39479b999841e0b0e994a47bf3cec8a4e54e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ddc39479b999841e0b0e994a47bf3cec8a4e54e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ddc39479b999841e0b0e994a47bf3cec8a4e54e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ddc39479b999841e0b0e994a47bf3cec8a4e54e/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bada6e9751abd00fe9b1bd1d7fcfa073042e4dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bada6e9751abd00fe9b1bd1d7fcfa073042e4dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bada6e9751abd00fe9b1bd1d7fcfa073042e4dd"}], "stats": {"total": 332, "additions": 189, "deletions": 143}, "files": [{"sha": "768dd668e57b4acd576c9d56143135b7a468a17a", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ddc39479b999841e0b0e994a47bf3cec8a4e54e/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ddc39479b999841e0b0e994a47bf3cec8a4e54e/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=1ddc39479b999841e0b0e994a47bf3cec8a4e54e", "patch": "@@ -2268,9 +2268,24 @@ of GNAT specific extensions are recognized as follows:\n   set shall be a proper subset of the second (and the later alternative\n   will not be executed if the earlier alternative \"matches\"). All possible\n   values of the composite type shall be covered. The composite type of the\n-  selector shall be a nonlimited untagged (but possibly discriminated)\n-  record type, all of whose subcomponent subtypes are either static discrete\n-  subtypes or record types that meet the same restrictions.\n+  selector shall be an array or record type that is neither limited\n+  class-wide.\n+\n+  If a subcomponent's subtype does not meet certain restrictions, then\n+  the only value that can be specified for that subcomponent in a case\n+  choice expression is a \"box\" component association (which matches all\n+  possible values for the subcomponent). This restriction applies if\n+\n+  - the component subtype is not a record, array, or discrete type; or\n+\n+  - the component subtype is subject to a non-static constraint or\n+    has a predicate; or\n+\n+  - the component type is an enumeration type that is subject to an\n+    enumeration representation clause; or\n+\n+  - the component type is a multidimensional array type or an\n+    array type with a nonstatic index subtype.\n \n   Support for casing on arrays (and on records that contain arrays) is\n   currently subject to some restrictions. Non-positional"}, {"sha": "129da895e09f3bb25cf3e2b0920dc26737d51165", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ddc39479b999841e0b0e994a47bf3cec8a4e54e/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ddc39479b999841e0b0e994a47bf3cec8a4e54e/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=1ddc39479b999841e0b0e994a47bf3cec8a4e54e", "patch": "@@ -21,7 +21,7 @@\n \n @copying\n @quotation\n-GNAT Reference Manual , Sep 28, 2021\n+GNAT Reference Manual , Oct 25, 2021\n \n AdaCore\n \n@@ -3707,9 +3707,32 @@ overlaps the corresponding set of a later alternative, then the first\n set shall be a proper subset of the second (and the later alternative\n will not be executed if the earlier alternative \u201cmatches\u201d). All possible\n values of the composite type shall be covered. The composite type of the\n-selector shall be a nonlimited untagged (but possibly discriminated)\n-record type, all of whose subcomponent subtypes are either static discrete\n-subtypes or record types that meet the same restrictions.\n+selector shall be an array or record type that is neither limited\n+class-wide.\n+\n+If a subcomponent\u2019s subtype does not meet certain restrictions, then\n+the only value that can be specified for that subcomponent in a case\n+choice expression is a \u201cbox\u201d component association (which matches all\n+possible values for the subcomponent). This restriction applies if\n+\n+\n+@itemize -\n+\n+@item \n+the component subtype is not a record, array, or discrete type; or\n+\n+@item \n+the component subtype is subject to a non-static constraint or\n+has a predicate; or\n+\n+@item \n+the component type is an enumeration type that is subject to an\n+enumeration representation clause; or\n+\n+@item \n+the component type is a multidimensional array type or an\n+array type with a nonstatic index subtype.\n+@end itemize\n \n Support for casing on arrays (and on records that contain arrays) is\n currently subject to some restrictions. Non-positional"}, {"sha": "1bd267016d96b2f8495eff3cfd760fa645b2b3fb", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 144, "deletions": 136, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ddc39479b999841e0b0e994a47bf3cec8a4e54e/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ddc39479b999841e0b0e994a47bf3cec8a4e54e/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=1ddc39479b999841e0b0e994a47bf3cec8a4e54e", "patch": "@@ -106,10 +106,26 @@ package body Sem_Case is\n \n    package Composite_Case_Ops is\n \n+      function Box_Value_Required (Subtyp : Entity_Id) return Boolean;\n+      --  If result is True, then the only allowed value (in a choice\n+      --  aggregate) for a component of this (sub)type is a box. This rule\n+      --  means that such a component can be ignored in case alternative\n+      --  selection. This in turn implies that it is ok if the component\n+      --  type doesn't meet the usual restrictions, such as not being an\n+      --  access/task/protected type, since nobody is going to look\n+      --  at it.\n+\n       function Choice_Count (Alternatives : List_Id) return Nat;\n       --  The sum of the number of choices for each alternative in the given\n       --  list.\n \n+      function Normalized_Case_Expr_Type\n+        (Case_Statement : Node_Id) return Entity_Id;\n+      --  Usually returns the Etype of the selector expression of the\n+      --  case statement. However, in the case of a constrained composite\n+      --  subtype with a nonstatic constraint, returns the unconstrained\n+      --  base type.\n+\n       function Scalar_Part_Count (Subtyp : Entity_Id) return Nat;\n       --  Given the composite type Subtyp of a case selector, returns the\n       --  number of scalar parts in an object of this type. This is the\n@@ -119,13 +135,6 @@ package body Sem_Case is\n          function Array_Choice_Length (Choice : Node_Id) return Nat;\n          --  Given a choice expression of an array type, returns its length.\n \n-         function Normalized_Case_Expr_Type\n-           (Case_Statement : Node_Id) return Entity_Id;\n-         --  Usually returns the Etype of the selector expression of the\n-         --  case statement. However, in the case of a constrained array\n-         --  subtype with a nonstatic constraint, returns the unconstrained\n-         --  array base type.\n-\n          function Unconstrained_Array_Effective_Length\n            (Array_Type : Entity_Id; Case_Statement : Node_Id) return Nat;\n          --  If the nominal subtype of the case selector is unconstrained,\n@@ -1164,6 +1173,54 @@ package body Sem_Case is\n          return UI_To_Int (Len);\n       end Static_Array_Length;\n \n+      ------------------------\n+      -- Box_Value_Required --\n+      ------------------------\n+\n+      function Box_Value_Required (Subtyp : Entity_Id) return Boolean is\n+         --  Some of these restrictions will be relaxed eventually, but best\n+         --  to initially err in the direction of being too restrictive.\n+      begin\n+         if Has_Predicates (Subtyp) then\n+            return True;\n+         elsif Is_Discrete_Type (Subtyp) then\n+            if not Is_Static_Subtype (Subtyp) then\n+               return True;\n+            elsif Is_Enumeration_Type (Subtyp)\n+               and then Has_Enumeration_Rep_Clause (Subtyp)\n+               --  Maybe enumeration rep clauses can be ignored here?\n+            then\n+               return True;\n+            end if;\n+         elsif Is_Array_Type (Subtyp) then\n+            if Number_Dimensions (Subtyp) /= 1 then\n+               return True;\n+            elsif not Is_Constrained (Subtyp) then\n+               if not Is_Static_Subtype (Etype (First_Index (Subtyp))) then\n+                  return True;\n+               end if;\n+            elsif not Is_OK_Static_Range (First_Index (Subtyp)) then\n+               return True;\n+            end if;\n+         elsif Is_Record_Type (Subtyp) then\n+            if Has_Discriminants (Subtyp)\n+              and then Is_Constrained (Subtyp)\n+              and then not Has_Static_Discriminant_Constraint (Subtyp)\n+            then\n+               --  Perhaps treat differently the case where Subtyp is the\n+               --  subtype of the top-level selector expression, as opposed\n+               --  to the subtype of some subcomponent thereof.\n+               return True;\n+            end if;\n+         else\n+            --  Return True for any type that is not a discrete type,\n+            --  a record type, or an array type.\n+            return True;\n+         end if;\n+\n+         return False;\n+      end Box_Value_Required;\n+\n       ------------------\n       -- Choice_Count --\n       ------------------\n@@ -1179,13 +1236,45 @@ package body Sem_Case is\n          return Result;\n       end Choice_Count;\n \n+      -------------------------------\n+      -- Normalized_Case_Expr_Type --\n+      -------------------------------\n+\n+      function Normalized_Case_Expr_Type\n+        (Case_Statement : Node_Id) return Entity_Id\n+      is\n+         Unnormalized : constant Entity_Id :=\n+           Etype (Expression (Case_Statement));\n+\n+         Is_Dynamically_Constrained_Array : constant Boolean :=\n+           Is_Array_Type (Unnormalized)\n+             and then Is_Constrained (Unnormalized)\n+             and then not Has_Static_Array_Bounds (Unnormalized);\n+\n+         Is_Dynamically_Constrained_Record : constant Boolean :=\n+           Is_Record_Type (Unnormalized)\n+             and then Has_Discriminants (Unnormalized)\n+             and then Is_Constrained (Unnormalized)\n+             and then not Has_Static_Discriminant_Constraint (Unnormalized);\n+      begin\n+         if Is_Dynamically_Constrained_Array\n+           or Is_Dynamically_Constrained_Record\n+         then\n+            return Base_Type (Unnormalized);\n+         else\n+            return Unnormalized;\n+         end if;\n+      end Normalized_Case_Expr_Type;\n+\n       -----------------------\n       -- Scalar_Part_Count --\n       -----------------------\n \n       function Scalar_Part_Count (Subtyp : Entity_Id) return Nat is\n       begin\n-         if Is_Scalar_Type (Subtyp) then\n+         if Box_Value_Required (Subtyp) then\n+            return 0; -- component does not participate in case selection\n+         elsif Is_Scalar_Type (Subtyp) then\n             return 1;\n          elsif Is_Array_Type (Subtyp) then\n             return Static_Array_Length (Subtyp)\n@@ -1203,8 +1292,8 @@ package body Sem_Case is\n                return Result;\n             end;\n          else\n-            pragma Assert (False);\n-            raise Program_Error;\n+            pragma Assert (Serious_Errors_Detected > 0);\n+            return 0;\n          end if;\n       end Scalar_Part_Count;\n \n@@ -1255,29 +1344,9 @@ package body Sem_Case is\n             return 0;\n          end Array_Choice_Length;\n \n-         -------------------------------\n-         -- Normalized_Case_Expr_Type --\n-         -------------------------------\n-\n-         function Normalized_Case_Expr_Type\n-           (Case_Statement : Node_Id) return Entity_Id\n-         is\n-            Unnormalized : constant Entity_Id :=\n-              Etype (Expression (Case_Statement));\n-         begin\n-            if Is_Array_Type (Unnormalized)\n-              and then Is_Constrained (Unnormalized)\n-              and then not Has_Static_Array_Bounds (Unnormalized)\n-            then\n-               return Base_Type (Unnormalized);\n-            else\n-               return Unnormalized;\n-            end if;\n-         end Normalized_Case_Expr_Type;\n-\n-      ------------------------------------------\n+         ------------------------------------------\n          -- Unconstrained_Array_Effective_Length --\n-      ------------------------------------------\n+         ------------------------------------------\n \n          function Unconstrained_Array_Effective_Length\n            (Array_Type : Entity_Id; Case_Statement : Node_Id) return Nat\n@@ -1374,6 +1443,10 @@ package body Sem_Case is\n \n             procedure Traverse_Discrete_Parts (Subtyp : Entity_Id) is\n             begin\n+               if Box_Value_Required (Subtyp) then\n+                  return;\n+               end if;\n+\n                if Is_Discrete_Type (Subtyp) then\n                   Update_Result\n                     ((Low  => Expr_Value (Type_Low_Bound (Subtyp)),\n@@ -1668,13 +1741,32 @@ package body Sem_Case is\n                               end loop;\n                            end;\n \n-                           if Box_Present (Comp_Assoc) then\n-                              --  Box matches all values\n-                              Update_Result_For_Full_Coverage\n-                                (Etype (First (Choices (Comp_Assoc))));\n-                           else\n-                              Traverse_Choice (Expression (Comp_Assoc));\n-                           end if;\n+                           declare\n+                              Comp_Type : constant Entity_Id :=\n+                                Etype (First (Choices (Comp_Assoc)));\n+                           begin\n+                              if Box_Value_Required (Comp_Type) then\n+                                 --  This component is not allowed to\n+                                 --  influence which alternative is\n+                                 --  chosen; case choice must be box.\n+                                 --\n+                                 --  For example, component might be\n+                                 --  of a real type or of an access type\n+                                 --  or of a non-static discrete subtype.\n+                                 if not Box_Present (Comp_Assoc) then\n+                                    Error_Msg_N\n+                                      (\"Non-box case choice component value\" &\n+                                         \" of unsupported type/subtype\",\n+                                       Expression (Comp_Assoc));\n+                                 end if;\n+                              elsif Box_Present (Comp_Assoc) then\n+                                 --  Box matches all values\n+                                 Update_Result_For_Full_Coverage\n+                                   (Etype (First (Choices (Comp_Assoc))));\n+                              else\n+                                 Traverse_Choice (Expression (Comp_Assoc));\n+                              end if;\n+                           end;\n \n                            if Binding_Chars (Comp_Assoc) /= No_Name\n                            then\n@@ -1702,9 +1794,19 @@ package body Sem_Case is\n                              Next_Component_Or_Discriminant (Comp_From_Type);\n                         end loop;\n \n-                        pragma Assert\n-                          (Nat (Next_Part - Saved_Next_Part)\n-                           = Scalar_Part_Count (Etype (Expr)));\n+                        declare\n+                           Expr_Type : Entity_Id := Etype (Expr);\n+                        begin\n+                           if Has_Discriminants (Expr_Type) then\n+                              --  Avoid nonstatic choice expr types,\n+                              --  for which Scalar_Part_Count returns 0.\n+                              Expr_Type := Base_Type (Expr_Type);\n+                           end if;\n+\n+                           pragma Assert\n+                             (Nat (Next_Part - Saved_Next_Part)\n+                               = Scalar_Part_Count (Expr_Type));\n+                        end;\n                      end;\n                   elsif Is_Array_Type (Etype (Expr)) then\n                      if Is_Non_Empty_List (Component_Associations (Expr)) then\n@@ -3256,108 +3358,14 @@ package body Sem_Case is\n          -----------------------------------\n \n          procedure Check_Composite_Case_Selector is\n-            --  Some of these restrictions will be relaxed eventually, but best\n-            --  to initially err in the direction of being too restrictive.\n-\n-            procedure Check_Component_Subtype (Subtyp : Entity_Id);\n-            --  Recursively traverse subcomponent types to perform checks.\n-\n-            -----------------------------\n-            -- Check_Component_Subtype --\n-            -----------------------------\n-\n-            procedure Check_Component_Subtype (Subtyp : Entity_Id) is\n-            begin\n-               if Has_Predicates (Subtyp) then\n-                  Error_Msg_N\n-                     (\"subtype of case selector (or subcomponent thereof) \" &\n-                      \"has predicate\", N);\n-               elsif Is_Discrete_Type (Subtyp) then\n-                  if not Is_Static_Subtype (Subtyp) then\n-                     Error_Msg_N\n-                       (\"discrete subtype of selector subcomponent is not \" &\n-                        \"a static subtype\", N);\n-                  elsif Is_Enumeration_Type (Subtyp)\n-                    and then Has_Enumeration_Rep_Clause (Subtyp)\n-                  then\n-                     Error_Msg_N\n-                       (\"enumeration type of selector subcomponent has \" &\n-                        \"an enumeration representation clause\", N);\n-                  end if;\n-               elsif Is_Array_Type (Subtyp) then\n-                  if Number_Dimensions (Subtyp) /= 1 then\n-                     Error_Msg_N\n-                       (\"dimensionality of array type of case selector (or \" &\n-                        \"subcomponent thereof) is greater than 1\", N);\n-\n-                  elsif not Is_Constrained (Subtyp) then\n-                     if not Is_Static_Subtype\n-                              (Etype (First_Index (Subtyp)))\n-                     then\n-                        Error_Msg_N\n-                          (\"Unconstrained array subtype of case selector\" &\n-                           \" has nonstatic index subtype\", N);\n-                     end if;\n-\n-                  elsif not Is_OK_Static_Range (First_Index (Subtyp)) then\n-                     Error_Msg_N\n-                       (\"array subtype of case selector (or \" &\n-                        \"subcomponent thereof) has nonstatic constraint\", N);\n-                  end if;\n-                  Check_Component_Subtype (Component_Type (Subtyp));\n-               elsif Is_Record_Type (Subtyp) then\n-\n-                  if Has_Discriminants (Subtyp)\n-                    and then Is_Constrained (Subtyp)\n-                    and then not Has_Static_Discriminant_Constraint (Subtyp)\n-                  then\n-                     --  We are only disallowing nonstatic constraints for\n-                     --  subcomponent subtypes, not for the subtype of the\n-                     --  expression we are casing on. This test could be\n-                     --  implemented via an Is_Recursive_Call parameter if\n-                     --  that seems preferable.\n-\n-                     if Subtyp /= Check_Choices.Subtyp then\n-                        Error_Msg_N\n-                          (\"constrained discriminated subtype of case \" &\n-                           \"selector subcomponent has nonstatic \" &\n-                           \"constraint\", N);\n-                     end if;\n-                  end if;\n-\n-                  declare\n-                     Comp : Entity_Id :=\n-                       First_Component_Or_Discriminant (Base_Type (Subtyp));\n-                  begin\n-                     while Present (Comp) loop\n-                        Check_Component_Subtype (Etype (Comp));\n-                        Next_Component_Or_Discriminant (Comp);\n-                     end loop;\n-                  end;\n-               else\n-                  Error_Msg_N\n-                    (\"type of case selector (or subcomponent thereof) is \" &\n-                     \"not a discrete type, a record type, or an array type\",\n-                     N);\n-               end if;\n-            end Check_Component_Subtype;\n-\n          begin\n             if not Is_Composite_Type (Subtyp) then\n                Error_Msg_N\n                  (\"case selector type neither discrete nor composite\", N);\n-\n             elsif Is_Limited_Type (Subtyp) then\n                Error_Msg_N (\"case selector type is limited\", N);\n-\n             elsif Is_Class_Wide_Type (Subtyp) then\n                Error_Msg_N (\"case selector type is class-wide\", N);\n-\n-            elsif Needs_Finalization (Subtyp) then\n-               Error_Msg_N (\"case selector type requires finalization\", N);\n-\n-            else\n-               Check_Component_Subtype (Subtyp);\n             end if;\n          end Check_Composite_Case_Selector;\n "}]}