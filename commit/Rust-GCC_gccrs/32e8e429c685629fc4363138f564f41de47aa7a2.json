{"sha": "32e8e429c685629fc4363138f564f41de47aa7a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJlOGU0MjljNjg1NjI5ZmM0MzYzMTM4ZjU2NGY0MWRlNDdhYTdhMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-31T14:25:30Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-31T14:25:30Z"}, "message": "[32/46] Use stmt_vec_info in function interfaces (part 2)\n\nThis second part handles the mechanical change from a gimple stmt\nargument to a stmt_vec_info argument.  It updates the function\ncomments if they referred to the argument by name, but it doesn't\ntry to retrofit mentions to other functions.\n\n2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (nested_in_vect_loop_p): Move further down\n\tfile and take a stmt_vec_info instead of a gimple stmt.\n\t(supportable_widening_operation, vect_finish_replace_stmt)\n\t(vect_finish_stmt_generation, vect_get_store_rhs)\n\t(vect_get_vec_def_for_operand_1, vect_get_vec_def_for_operand)\n\t(vect_get_vec_defs, vect_init_vector, vect_transform_stmt)\n\t(vect_remove_stores, vect_analyze_stmt, vectorizable_condition)\n\t(vect_get_smallest_scalar_type, vect_check_gather_scatter)\n\t(vect_create_data_ref_ptr, bump_vector_ptr)\n\t(vect_permute_store_chain, vect_setup_realignment)\n\t(vect_transform_grouped_load, vect_record_grouped_load_vectors)\n\t(vect_create_addr_base_for_vector_ref, vectorizable_live_operation)\n\t(vectorizable_reduction, vectorizable_induction)\n\t(get_initial_def_for_reduction, is_simple_and_all_uses_invariant)\n\t(vect_get_place_in_interleaving_chain): Take stmt_vec_infos rather\n\tthan gimple stmts as arguments.\n\t* tree-vect-data-refs.c (vect_get_smallest_scalar_type)\n\t(vect_preserves_scalar_order_p, vect_slp_analyze_node_dependences)\n\t(can_group_stmts_p, vect_check_gather_scatter)\n\t(vect_create_addr_base_for_vector_ref, vect_create_data_ref_ptr)\n\t(bump_vector_ptr, vect_permute_store_chain, vect_setup_realignment)\n\t(vect_permute_load_chain, vect_shift_permute_load_chain)\n\t(vect_transform_grouped_load)\n\t(vect_record_grouped_load_vectors): Likewise.\n\t* tree-vect-loop.c (vect_fixup_reduc_chain)\n\t(get_initial_def_for_reduction, vect_create_epilog_for_reduction)\n\t(vectorize_fold_left_reduction, is_nonwrapping_integer_induction)\n\t(vectorizable_reduction, vectorizable_induction)\n\t(vectorizable_live_operation, vect_loop_kill_debug_uses): Likewise.\n\t* tree-vect-patterns.c (type_conversion_p, adjust_bool_stmts)\n\t(vect_get_load_store_mask): Likewise.\n\t* tree-vect-slp.c (vect_get_place_in_interleaving_chain)\n\t(vect_analyze_slp_instance, vect_mask_constant_operand_p): Likewise.\n\t* tree-vect-stmts.c (vect_mark_relevant)\n\t(is_simple_and_all_uses_invariant)\n\t(exist_non_indexing_operands_for_use_p, process_use)\n\t(vect_init_vector_1, vect_init_vector, vect_get_vec_def_for_operand_1)\n\t(vect_get_vec_def_for_operand, vect_get_vec_defs)\n\t(vect_finish_stmt_generation_1, vect_finish_replace_stmt)\n\t(vect_finish_stmt_generation, vect_truncate_gather_scatter_offset)\n\t(compare_step_with_zero, vect_get_store_rhs, get_group_load_store_type)\n\t(get_negative_load_store_type, get_load_store_type)\n\t(vect_check_load_store_mask, vect_check_store_rhs)\n\t(vect_build_gather_load_calls, vect_get_strided_load_store_ops)\n\t(vectorizable_bswap, vectorizable_call, vectorizable_simd_clone_call)\n\t(vect_create_vectorized_demotion_stmts, vectorizable_conversion)\n\t(vectorizable_assignment, vectorizable_shift, vectorizable_operation)\n\t(get_group_alias_ptr_type, vectorizable_store, hoist_defs_of_uses)\n\t(vectorizable_load, vectorizable_condition, vectorizable_comparison)\n\t(vect_analyze_stmt, vect_transform_stmt, vect_remove_stores)\n\t(supportable_widening_operation): Likewise.\n\nFrom-SVN: r263147", "tree": {"sha": "b7c03a32cfb597accb320bfb44bed8c476b1faaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7c03a32cfb597accb320bfb44bed8c476b1faaa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32e8e429c685629fc4363138f564f41de47aa7a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32e8e429c685629fc4363138f564f41de47aa7a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32e8e429c685629fc4363138f564f41de47aa7a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32e8e429c685629fc4363138f564f41de47aa7a2/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "825702749aee7017548db2075cf225a6ed2e3ca8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/825702749aee7017548db2075cf225a6ed2e3ca8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/825702749aee7017548db2075cf225a6ed2e3ca8"}], "stats": {"total": 741, "additions": 382, "deletions": 359}, "files": [{"sha": "ea675977431706be40a3bfe99703c9457c776cfd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32e8e429c685629fc4363138f564f41de47aa7a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32e8e429c685629fc4363138f564f41de47aa7a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32e8e429c685629fc4363138f564f41de47aa7a2", "patch": "@@ -1,3 +1,57 @@\n+2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (nested_in_vect_loop_p): Move further down\n+\tfile and take a stmt_vec_info instead of a gimple stmt.\n+\t(supportable_widening_operation, vect_finish_replace_stmt)\n+\t(vect_finish_stmt_generation, vect_get_store_rhs)\n+\t(vect_get_vec_def_for_operand_1, vect_get_vec_def_for_operand)\n+\t(vect_get_vec_defs, vect_init_vector, vect_transform_stmt)\n+\t(vect_remove_stores, vect_analyze_stmt, vectorizable_condition)\n+\t(vect_get_smallest_scalar_type, vect_check_gather_scatter)\n+\t(vect_create_data_ref_ptr, bump_vector_ptr)\n+\t(vect_permute_store_chain, vect_setup_realignment)\n+\t(vect_transform_grouped_load, vect_record_grouped_load_vectors)\n+\t(vect_create_addr_base_for_vector_ref, vectorizable_live_operation)\n+\t(vectorizable_reduction, vectorizable_induction)\n+\t(get_initial_def_for_reduction, is_simple_and_all_uses_invariant)\n+\t(vect_get_place_in_interleaving_chain): Take stmt_vec_infos rather\n+\tthan gimple stmts as arguments.\n+\t* tree-vect-data-refs.c (vect_get_smallest_scalar_type)\n+\t(vect_preserves_scalar_order_p, vect_slp_analyze_node_dependences)\n+\t(can_group_stmts_p, vect_check_gather_scatter)\n+\t(vect_create_addr_base_for_vector_ref, vect_create_data_ref_ptr)\n+\t(bump_vector_ptr, vect_permute_store_chain, vect_setup_realignment)\n+\t(vect_permute_load_chain, vect_shift_permute_load_chain)\n+\t(vect_transform_grouped_load)\n+\t(vect_record_grouped_load_vectors): Likewise.\n+\t* tree-vect-loop.c (vect_fixup_reduc_chain)\n+\t(get_initial_def_for_reduction, vect_create_epilog_for_reduction)\n+\t(vectorize_fold_left_reduction, is_nonwrapping_integer_induction)\n+\t(vectorizable_reduction, vectorizable_induction)\n+\t(vectorizable_live_operation, vect_loop_kill_debug_uses): Likewise.\n+\t* tree-vect-patterns.c (type_conversion_p, adjust_bool_stmts)\n+\t(vect_get_load_store_mask): Likewise.\n+\t* tree-vect-slp.c (vect_get_place_in_interleaving_chain)\n+\t(vect_analyze_slp_instance, vect_mask_constant_operand_p): Likewise.\n+\t* tree-vect-stmts.c (vect_mark_relevant)\n+\t(is_simple_and_all_uses_invariant)\n+\t(exist_non_indexing_operands_for_use_p, process_use)\n+\t(vect_init_vector_1, vect_init_vector, vect_get_vec_def_for_operand_1)\n+\t(vect_get_vec_def_for_operand, vect_get_vec_defs)\n+\t(vect_finish_stmt_generation_1, vect_finish_replace_stmt)\n+\t(vect_finish_stmt_generation, vect_truncate_gather_scatter_offset)\n+\t(compare_step_with_zero, vect_get_store_rhs, get_group_load_store_type)\n+\t(get_negative_load_store_type, get_load_store_type)\n+\t(vect_check_load_store_mask, vect_check_store_rhs)\n+\t(vect_build_gather_load_calls, vect_get_strided_load_store_ops)\n+\t(vectorizable_bswap, vectorizable_call, vectorizable_simd_clone_call)\n+\t(vect_create_vectorized_demotion_stmts, vectorizable_conversion)\n+\t(vectorizable_assignment, vectorizable_shift, vectorizable_operation)\n+\t(get_group_alias_ptr_type, vectorizable_store, hoist_defs_of_uses)\n+\t(vectorizable_load, vectorizable_condition, vectorizable_comparison)\n+\t(vect_analyze_stmt, vect_transform_stmt, vect_remove_stores)\n+\t(supportable_widening_operation): Likewise.\n+\n 2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-data-refs.c (vect_describe_gather_scatter_call): Take"}, {"sha": "5a36d098e49b0bc1cd9868d6e81062746d5dfc1f", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 52, "deletions": 62, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32e8e429c685629fc4363138f564f41de47aa7a2/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32e8e429c685629fc4363138f564f41de47aa7a2/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=32e8e429c685629fc4363138f564f41de47aa7a2", "patch": "@@ -99,7 +99,7 @@ vect_lanes_optab_supported_p (const char *name, convert_optab optab,\n }\n \n \n-/* Return the smallest scalar part of STMT.\n+/* Return the smallest scalar part of STMT_INFO.\n    This is used to determine the vectype of the stmt.  We generally set the\n    vectype according to the type of the result (lhs).  For stmts whose\n    result-type is different than the type of the arguments (e.g., demotion,\n@@ -117,10 +117,11 @@ vect_lanes_optab_supported_p (const char *name, convert_optab optab,\n    types.  */\n \n tree\n-vect_get_smallest_scalar_type (gimple *stmt, HOST_WIDE_INT *lhs_size_unit,\n-                               HOST_WIDE_INT *rhs_size_unit)\n+vect_get_smallest_scalar_type (stmt_vec_info stmt_info,\n+\t\t\t       HOST_WIDE_INT *lhs_size_unit,\n+\t\t\t       HOST_WIDE_INT *rhs_size_unit)\n {\n-  tree scalar_type = gimple_expr_type (stmt);\n+  tree scalar_type = gimple_expr_type (stmt_info->stmt);\n   HOST_WIDE_INT lhs, rhs;\n \n   /* During the analysis phase, this function is called on arbitrary\n@@ -130,7 +131,7 @@ vect_get_smallest_scalar_type (gimple *stmt, HOST_WIDE_INT *lhs_size_unit,\n \n   lhs = rhs = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (scalar_type));\n \n-  gassign *assign = dyn_cast <gassign *> (stmt);\n+  gassign *assign = dyn_cast <gassign *> (stmt_info->stmt);\n   if (assign\n       && (gimple_assign_cast_p (assign)\n \t  || gimple_assign_rhs_code (assign) == DOT_PROD_EXPR\n@@ -191,16 +192,14 @@ vect_check_nonzero_value (loop_vec_info loop_vinfo, tree value)\n   LOOP_VINFO_CHECK_NONZERO (loop_vinfo).safe_push (value);\n }\n \n-/* Return true if we know that the order of vectorized STMT_A and\n-   vectorized STMT_B will be the same as the order of STMT_A and STMT_B.\n-   At least one of the statements is a write.  */\n+/* Return true if we know that the order of vectorized STMTINFO_A and\n+   vectorized STMTINFO_B will be the same as the order of STMTINFO_A and\n+   STMTINFO_B.  At least one of the statements is a write.  */\n \n static bool\n-vect_preserves_scalar_order_p (gimple *stmt_a, gimple *stmt_b)\n+vect_preserves_scalar_order_p (stmt_vec_info stmtinfo_a,\n+\t\t\t       stmt_vec_info stmtinfo_b)\n {\n-  stmt_vec_info stmtinfo_a = vinfo_for_stmt (stmt_a);\n-  stmt_vec_info stmtinfo_b = vinfo_for_stmt (stmt_b);\n-\n   /* Single statements are always kept in their original order.  */\n   if (!STMT_VINFO_GROUPED_ACCESS (stmtinfo_a)\n       && !STMT_VINFO_GROUPED_ACCESS (stmtinfo_b))\n@@ -666,7 +665,7 @@ vect_slp_analyze_data_ref_dependence (struct data_dependence_relation *ddr)\n static bool\n vect_slp_analyze_node_dependences (slp_instance instance, slp_tree node,\n \t\t\t\t   vec<stmt_vec_info> stores,\n-\t\t\t\t   gimple *last_store)\n+\t\t\t\t   stmt_vec_info last_store_info)\n {\n   /* This walks over all stmts involved in the SLP load/store done\n      in NODE verifying we can sink them up to the last stmt in the\n@@ -712,7 +711,7 @@ vect_slp_analyze_node_dependences (slp_instance instance, slp_tree node,\n \t     been sunk to (and we verify if we can do that as well).  */\n \t  if (gimple_visited_p (stmt))\n \t    {\n-\t      if (stmt_info != last_store)\n+\t      if (stmt_info != last_store_info)\n \t\tcontinue;\n \t      unsigned i;\n \t      stmt_vec_info store_info;\n@@ -2843,20 +2842,20 @@ strip_conversion (tree op)\n   return gimple_assign_rhs1 (stmt);\n }\n \n-/* Return true if vectorizable_* routines can handle statements STMT1\n-   and STMT2 being in a single group.  */\n+/* Return true if vectorizable_* routines can handle statements STMT1_INFO\n+   and STMT2_INFO being in a single group.  */\n \n static bool\n-can_group_stmts_p (gimple *stmt1, gimple *stmt2)\n+can_group_stmts_p (stmt_vec_info stmt1_info, stmt_vec_info stmt2_info)\n {\n-  if (gimple_assign_single_p (stmt1))\n-    return gimple_assign_single_p (stmt2);\n+  if (gimple_assign_single_p (stmt1_info->stmt))\n+    return gimple_assign_single_p (stmt2_info->stmt);\n \n-  gcall *call1 = dyn_cast <gcall *> (stmt1);\n+  gcall *call1 = dyn_cast <gcall *> (stmt1_info->stmt);\n   if (call1 && gimple_call_internal_p (call1))\n     {\n       /* Check for two masked loads or two masked stores.  */\n-      gcall *call2 = dyn_cast <gcall *> (stmt2);\n+      gcall *call2 = dyn_cast <gcall *> (stmt2_info->stmt);\n       if (!call2 || !gimple_call_internal_p (call2))\n \treturn false;\n       internal_fn ifn = gimple_call_internal_fn (call1);\n@@ -3643,17 +3642,16 @@ vect_describe_gather_scatter_call (stmt_vec_info stmt_info,\n   info->memory_type = TREE_TYPE (DR_REF (dr));\n }\n \n-/* Return true if a non-affine read or write in STMT is suitable for a\n+/* Return true if a non-affine read or write in STMT_INFO is suitable for a\n    gather load or scatter store.  Describe the operation in *INFO if so.  */\n \n bool\n-vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo,\n+vect_check_gather_scatter (stmt_vec_info stmt_info, loop_vec_info loop_vinfo,\n \t\t\t   gather_scatter_info *info)\n {\n   HOST_WIDE_INT scale = 1;\n   poly_int64 pbitpos, pbitsize;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   tree offtype = NULL_TREE;\n   tree decl = NULL_TREE, base, off;\n@@ -4473,7 +4471,7 @@ vect_duplicate_ssa_name_ptr_info (tree name, data_reference *dr)\n    that will be accessed for a data reference.\n \n    Input:\n-   STMT: The statement containing the data reference.\n+   STMT_INFO: The statement containing the data reference.\n    NEW_STMT_LIST: Must be initialized to NULL_TREE or a statement list.\n    OFFSET: Optional. If supplied, it is be added to the initial address.\n    LOOP:    Specify relative to which loop-nest should the address be computed.\n@@ -4502,12 +4500,11 @@ vect_duplicate_ssa_name_ptr_info (tree name, data_reference *dr)\n    FORNOW: We are only handling array accesses with step 1.  */\n \n tree\n-vect_create_addr_base_for_vector_ref (gimple *stmt,\n+vect_create_addr_base_for_vector_ref (stmt_vec_info stmt_info,\n \t\t\t\t      gimple_seq *new_stmt_list,\n \t\t\t\t      tree offset,\n \t\t\t\t      tree byte_offset)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   const char *base_name;\n   tree addr_base;\n@@ -4588,26 +4585,26 @@ vect_create_addr_base_for_vector_ref (gimple *stmt,\n /* Function vect_create_data_ref_ptr.\n \n    Create a new pointer-to-AGGR_TYPE variable (ap), that points to the first\n-   location accessed in the loop by STMT, along with the def-use update\n+   location accessed in the loop by STMT_INFO, along with the def-use update\n    chain to appropriately advance the pointer through the loop iterations.\n    Also set aliasing information for the pointer.  This pointer is used by\n    the callers to this function to create a memory reference expression for\n    vector load/store access.\n \n    Input:\n-   1. STMT: a stmt that references memory. Expected to be of the form\n+   1. STMT_INFO: a stmt that references memory. Expected to be of the form\n          GIMPLE_ASSIGN <name, data-ref> or\n \t GIMPLE_ASSIGN <data-ref, name>.\n    2. AGGR_TYPE: the type of the reference, which should be either a vector\n         or an array.\n    3. AT_LOOP: the loop where the vector memref is to be created.\n    4. OFFSET (optional): an offset to be added to the initial address accessed\n-        by the data-ref in STMT.\n+\tby the data-ref in STMT_INFO.\n    5. BSI: location where the new stmts are to be placed if there is no loop\n    6. ONLY_INIT: indicate if ap is to be updated in the loop, or remain\n         pointing to the initial address.\n    7. BYTE_OFFSET (optional, defaults to NULL): a byte offset to be added\n-\tto the initial address accessed by the data-ref in STMT.  This is\n+\tto the initial address accessed by the data-ref in STMT_INFO.  This is\n \tsimilar to OFFSET, but OFFSET is counted in elements, while BYTE_OFFSET\n \tin bytes.\n    8. IV_STEP (optional, defaults to NULL): the amount that should be added\n@@ -4643,14 +4640,13 @@ vect_create_addr_base_for_vector_ref (gimple *stmt,\n    4. Return the pointer.  */\n \n tree\n-vect_create_data_ref_ptr (gimple *stmt, tree aggr_type, struct loop *at_loop,\n-\t\t\t  tree offset, tree *initial_address,\n-\t\t\t  gimple_stmt_iterator *gsi, gimple **ptr_incr,\n-\t\t\t  bool only_init, bool *inv_p, tree byte_offset,\n-\t\t\t  tree iv_step)\n+vect_create_data_ref_ptr (stmt_vec_info stmt_info, tree aggr_type,\n+\t\t\t  struct loop *at_loop, tree offset,\n+\t\t\t  tree *initial_address, gimple_stmt_iterator *gsi,\n+\t\t\t  gimple **ptr_incr, bool only_init, bool *inv_p,\n+\t\t\t  tree byte_offset, tree iv_step)\n {\n   const char *base_name;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = NULL;\n   bool nested_in_vect_loop = false;\n@@ -4905,7 +4901,7 @@ vect_create_data_ref_ptr (gimple *stmt, tree aggr_type, struct loop *at_loop,\n \t      the loop.  The increment amount across iterations is expected\n \t      to be vector_size.\n    BSI - location where the new update stmt is to be placed.\n-   STMT - the original scalar memory-access stmt that is being vectorized.\n+   STMT_INFO - the original scalar memory-access stmt that is being vectorized.\n    BUMP - optional. The offset by which to bump the pointer. If not given,\n \t  the offset is assumed to be vector_size.\n \n@@ -4915,9 +4911,8 @@ vect_create_data_ref_ptr (gimple *stmt, tree aggr_type, struct loop *at_loop,\n \n tree\n bump_vector_ptr (tree dataref_ptr, gimple *ptr_incr, gimple_stmt_iterator *gsi,\n-\t\t gimple *stmt, tree bump)\n+\t\t stmt_vec_info stmt_info, tree bump)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree update = TYPE_SIZE_UNIT (vectype);\n@@ -5217,11 +5212,10 @@ vect_store_lanes_supported (tree vectype, unsigned HOST_WIDE_INT count,\n void\n vect_permute_store_chain (vec<tree> dr_chain,\n \t\t\t  unsigned int length,\n-\t\t\t  gimple *stmt,\n+\t\t\t  stmt_vec_info stmt_info,\n \t\t\t  gimple_stmt_iterator *gsi,\n \t\t\t  vec<tree> *result_chain)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vect1, vect2, high, low;\n   gimple *perm_stmt;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n@@ -5368,12 +5362,12 @@ vect_permute_store_chain (vec<tree> dr_chain,\n    dr_explicit_realign_optimized.\n \n    The code above sets up a new (vector) pointer, pointing to the first\n-   location accessed by STMT, and a \"floor-aligned\" load using that pointer.\n-   It also generates code to compute the \"realignment-token\" (if the relevant\n-   target hook was defined), and creates a phi-node at the loop-header bb\n-   whose arguments are the result of the prolog-load (created by this\n-   function) and the result of a load that takes place in the loop (to be\n-   created by the caller to this function).\n+   location accessed by STMT_INFO, and a \"floor-aligned\" load using that\n+   pointer.  It also generates code to compute the \"realignment-token\"\n+   (if the relevant target hook was defined), and creates a phi-node at the\n+   loop-header bb whose arguments are the result of the prolog-load (created\n+   by this function) and the result of a load that takes place in the loop\n+   (to be created by the caller to this function).\n \n    For the case of dr_explicit_realign_optimized:\n    The caller to this function uses the phi-result (msq) to create the\n@@ -5392,8 +5386,8 @@ vect_permute_store_chain (vec<tree> dr_chain,\n       result = realign_load (msq, lsq, realignment_token);\n \n    Input:\n-   STMT - (scalar) load stmt to be vectorized. This load accesses\n-          a memory location that may be unaligned.\n+   STMT_INFO - (scalar) load stmt to be vectorized. This load accesses\n+\t       a memory location that may be unaligned.\n    BSI - place where new code is to be inserted.\n    ALIGNMENT_SUPPORT_SCHEME - which of the two misalignment handling schemes\n \t\t\t      is used.\n@@ -5404,13 +5398,12 @@ vect_permute_store_chain (vec<tree> dr_chain,\n    Return value - the result of the loop-header phi node.  */\n \n tree\n-vect_setup_realignment (gimple *stmt, gimple_stmt_iterator *gsi,\n+vect_setup_realignment (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n                         tree *realignment_token,\n \t\t\tenum dr_alignment_support alignment_support_scheme,\n \t\t\ttree init_addr,\n \t\t\tstruct loop **at_loop)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n@@ -5839,11 +5832,10 @@ vect_load_lanes_supported (tree vectype, unsigned HOST_WIDE_INT count,\n static void\n vect_permute_load_chain (vec<tree> dr_chain,\n \t\t\t unsigned int length,\n-\t\t\t gimple *stmt,\n+\t\t\t stmt_vec_info stmt_info,\n \t\t\t gimple_stmt_iterator *gsi,\n \t\t\t vec<tree> *result_chain)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree data_ref, first_vect, second_vect;\n   tree perm_mask_even, perm_mask_odd;\n   tree perm3_mask_low, perm3_mask_high;\n@@ -6043,11 +6035,10 @@ vect_permute_load_chain (vec<tree> dr_chain,\n static bool\n vect_shift_permute_load_chain (vec<tree> dr_chain,\n \t\t\t       unsigned int length,\n-\t\t\t       gimple *stmt,\n+\t\t\t       stmt_vec_info stmt_info,\n \t\t\t       gimple_stmt_iterator *gsi,\n \t\t\t       vec<tree> *result_chain)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vect[3], vect_shift[3], data_ref, first_vect, second_vect;\n   tree perm2_mask1, perm2_mask2, perm3_mask;\n   tree select_mask, shift1_mask, shift2_mask, shift3_mask, shift4_mask;\n@@ -6311,10 +6302,9 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n */\n \n void\n-vect_transform_grouped_load (gimple *stmt, vec<tree> dr_chain, int size,\n-\t\t\t     gimple_stmt_iterator *gsi)\n+vect_transform_grouped_load (stmt_vec_info stmt_info, vec<tree> dr_chain,\n+\t\t\t     int size, gimple_stmt_iterator *gsi)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   machine_mode mode;\n   vec<tree> result_chain = vNULL;\n \n@@ -6337,13 +6327,13 @@ vect_transform_grouped_load (gimple *stmt, vec<tree> dr_chain, int size,\n }\n \n /* RESULT_CHAIN contains the output of a group of grouped loads that were\n-   generated as part of the vectorization of STMT.  Assign the statement\n+   generated as part of the vectorization of STMT_INFO.  Assign the statement\n    for each vector to the associated scalar statement.  */\n \n void\n-vect_record_grouped_load_vectors (gimple *stmt, vec<tree> result_chain)\n+vect_record_grouped_load_vectors (stmt_vec_info stmt_info,\n+\t\t\t\t  vec<tree> result_chain)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   vec_info *vinfo = stmt_info->vinfo;\n   stmt_vec_info first_stmt_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n   unsigned int i, gap_count;"}, {"sha": "7fe8442e52291fa03237a96247ffcbd7f28250db", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 52, "deletions": 53, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32e8e429c685629fc4363138f564f41de47aa7a2/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32e8e429c685629fc4363138f564f41de47aa7a2/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=32e8e429c685629fc4363138f564f41de47aa7a2", "patch": "@@ -648,12 +648,12 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n     vect_analyze_scalar_cycles_1 (loop_vinfo, loop->inner);\n }\n \n-/* Transfer group and reduction information from STMT to its pattern stmt.  */\n+/* Transfer group and reduction information from STMT_INFO to its\n+   pattern stmt.  */\n \n static void\n-vect_fixup_reduc_chain (gimple *stmt)\n+vect_fixup_reduc_chain (stmt_vec_info stmt_info)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   stmt_vec_info firstp = STMT_VINFO_RELATED_STMT (stmt_info);\n   stmt_vec_info stmtp;\n   gcc_assert (!REDUC_GROUP_FIRST_ELEMENT (firstp)\n@@ -3998,15 +3998,15 @@ vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies,\n /* Function get_initial_def_for_reduction\n \n    Input:\n-   STMT - a stmt that performs a reduction operation in the loop.\n+   STMT_VINFO - a stmt that performs a reduction operation in the loop.\n    INIT_VAL - the initial value of the reduction variable\n \n    Output:\n    ADJUSTMENT_DEF - a tree that holds a value to be added to the final result\n         of the reduction (used for adjusting the epilog - see below).\n-   Return a vector variable, initialized according to the operation that STMT\n-        performs. This vector will be used as the initial value of the\n-        vector of partial results.\n+   Return a vector variable, initialized according to the operation that\n+\tSTMT_VINFO performs. This vector will be used as the initial value\n+\tof the vector of partial results.\n \n    Option1 (adjust in epilog): Initialize the vector as follows:\n      add/bit or/xor:    [0,0,...,0,0]\n@@ -4027,7 +4027,7 @@ vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies,\n    for (i=0;i<n;i++)\n      s = s + a[i];\n \n-   STMT is 's = s + a[i]', and the reduction variable is 's'.\n+   STMT_VINFO is 's = s + a[i]', and the reduction variable is 's'.\n    For a vector of 4 units, we want to return either [0,0,0,init_val],\n    or [0,0,0,0] and let the caller know that it needs to adjust\n    the result at the end by 'init_val'.\n@@ -4039,10 +4039,9 @@ vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies,\n    A cost model should help decide between these two schemes.  */\n \n tree\n-get_initial_def_for_reduction (gimple *stmt, tree init_val,\n+get_initial_def_for_reduction (stmt_vec_info stmt_vinfo, tree init_val,\n                                tree *adjustment_def)\n {\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree scalar_type = TREE_TYPE (init_val);\n@@ -4321,7 +4320,7 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n   \n    VECT_DEFS is list of vector of partial results, i.e., the lhs's of vector \n      reduction statements. \n-   STMT is the scalar reduction stmt that is being vectorized.\n+   STMT_INFO is the scalar reduction stmt that is being vectorized.\n    NCOPIES is > 1 in case the vectorization factor (VF) is bigger than the\n      number of elements that we can fit in a vectype (nunits).  In this case\n      we have to generate more than one vector stmt - i.e - we need to \"unroll\"\n@@ -4334,7 +4333,7 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n      statement that is defined by REDUCTION_PHI.\n    DOUBLE_REDUC is TRUE if double reduction phi nodes should be handled.\n    SLP_NODE is an SLP node containing a group of reduction statements. The \n-     first one in this group is STMT.\n+     first one in this group is STMT_INFO.\n    INDUC_VAL is for INTEGER_INDUC_COND_REDUCTION the value to use for the case\n      when the COND_EXPR is never true in the loop.  For MAX_EXPR, it needs to\n      be smaller than any value of the IV in the loop, for MIN_EXPR larger than\n@@ -4359,8 +4358,8 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n \n         loop:\n           vec_def = phi <null, null>            # REDUCTION_PHI\n-          VECT_DEF = vector_stmt                # vectorized form of STMT\n-          s_loop = scalar_stmt                  # (scalar) STMT\n+          VECT_DEF = vector_stmt                # vectorized form of STMT_INFO\n+          s_loop = scalar_stmt                  # (scalar) STMT_INFO\n         loop_exit:\n           s_out0 = phi <s_loop>                 # (scalar) EXIT_PHI\n           use <s_out0>\n@@ -4370,8 +4369,8 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n \n         loop:\n           vec_def = phi <vec_init, VECT_DEF>    # REDUCTION_PHI\n-          VECT_DEF = vector_stmt                # vectorized form of STMT\n-          s_loop = scalar_stmt                  # (scalar) STMT\n+          VECT_DEF = vector_stmt                # vectorized form of STMT_INFO\n+          s_loop = scalar_stmt                  # (scalar) STMT_INFO\n         loop_exit:\n           s_out0 = phi <s_loop>                 # (scalar) EXIT_PHI\n           v_out1 = phi <VECT_DEF>               # NEW_EXIT_PHI\n@@ -4383,7 +4382,8 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n */\n \n static void\n-vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n+vect_create_epilog_for_reduction (vec<tree> vect_defs,\n+\t\t\t\t  stmt_vec_info stmt_info,\n \t\t\t\t  gimple *reduc_def_stmt,\n \t\t\t\t  int ncopies, internal_fn reduc_fn,\n \t\t\t\t  vec<stmt_vec_info> reduction_phis,\n@@ -4393,7 +4393,6 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t\t\t\t  tree induc_val, enum tree_code induc_code,\n \t\t\t\t  tree neutral_op)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   stmt_vec_info prev_phi_info;\n   tree vectype;\n   machine_mode mode;\n@@ -5816,24 +5815,24 @@ vect_expand_fold_left (gimple_stmt_iterator *gsi, tree scalar_dest,\n   return lhs;\n }\n \n-/* Perform an in-order reduction (FOLD_LEFT_REDUCTION).  STMT is the\n+/* Perform an in-order reduction (FOLD_LEFT_REDUCTION).  STMT_INFO is the\n    statement that sets the live-out value.  REDUC_DEF_STMT is the phi\n-   statement.  CODE is the operation performed by STMT and OPS are\n+   statement.  CODE is the operation performed by STMT_INFO and OPS are\n    its scalar operands.  REDUC_INDEX is the index of the operand in\n    OPS that is set by REDUC_DEF_STMT.  REDUC_FN is the function that\n    implements in-order reduction, or IFN_LAST if we should open-code it.\n    VECTYPE_IN is the type of the vector input.  MASKS specifies the masks\n    that should be used to control the operation in a fully-masked loop.  */\n \n static bool\n-vectorize_fold_left_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n+vectorize_fold_left_reduction (stmt_vec_info stmt_info,\n+\t\t\t       gimple_stmt_iterator *gsi,\n \t\t\t       stmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t\t       gimple *reduc_def_stmt,\n \t\t\t       tree_code code, internal_fn reduc_fn,\n \t\t\t       tree ops[3], tree vectype_in,\n \t\t\t       int reduc_index, vec_loop_masks *masks)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n@@ -5962,16 +5961,16 @@ vectorize_fold_left_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n /* Function is_nonwrapping_integer_induction.\n \n-   Check if STMT (which is part of loop LOOP) both increments and\n+   Check if STMT_VINO (which is part of loop LOOP) both increments and\n    does not cause overflow.  */\n \n static bool\n-is_nonwrapping_integer_induction (gimple *stmt, struct loop *loop)\n+is_nonwrapping_integer_induction (stmt_vec_info stmt_vinfo, struct loop *loop)\n {\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n+  gphi *phi = as_a <gphi *> (stmt_vinfo->stmt);\n   tree base = STMT_VINFO_LOOP_PHI_EVOLUTION_BASE_UNCHANGED (stmt_vinfo);\n   tree step = STMT_VINFO_LOOP_PHI_EVOLUTION_PART (stmt_vinfo);\n-  tree lhs_type = TREE_TYPE (gimple_phi_result (stmt));\n+  tree lhs_type = TREE_TYPE (gimple_phi_result (phi));\n   widest_int ni, max_loop_value, lhs_max;\n   wi::overflow_type overflow = wi::OVF_NONE;\n \n@@ -6004,17 +6003,18 @@ is_nonwrapping_integer_induction (gimple *stmt, struct loop *loop)\n \n /* Function vectorizable_reduction.\n \n-   Check if STMT performs a reduction operation that can be vectorized.\n-   If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n+   Check if STMT_INFO performs a reduction operation that can be vectorized.\n+   If VEC_STMT is also passed, vectorize STMT_INFO: create a vectorized\n    stmt to replace it, put it in VEC_STMT, and insert it at GSI.\n-   Return FALSE if not a vectorizable STMT, TRUE otherwise.\n+   Return true if STMT_INFO is vectorizable in this way.\n \n    This function also handles reduction idioms (patterns) that have been\n-   recognized in advance during vect_pattern_recog.  In this case, STMT may be\n-   of this form:\n+   recognized in advance during vect_pattern_recog.  In this case, STMT_INFO\n+   may be of this form:\n      X = pattern_expr (arg0, arg1, ..., X)\n-   and it's STMT_VINFO_RELATED_STMT points to the last stmt in the original\n-   sequence that had been detected and replaced by the pattern-stmt (STMT).\n+   and its STMT_VINFO_RELATED_STMT points to the last stmt in the original\n+   sequence that had been detected and replaced by the pattern-stmt\n+   (STMT_INFO).\n \n    This function also handles reduction of condition expressions, for example:\n      for (int i = 0; i < N; i++)\n@@ -6026,9 +6026,9 @@ is_nonwrapping_integer_induction (gimple *stmt, struct loop *loop)\n    index into the vector of results.\n \n    In some cases of reduction patterns, the type of the reduction variable X is\n-   different than the type of the other arguments of STMT.\n-   In such cases, the vectype that is used when transforming STMT into a vector\n-   stmt is different than the vectype that is used to determine the\n+   different than the type of the other arguments of STMT_INFO.\n+   In such cases, the vectype that is used when transforming STMT_INFO into\n+   a vector stmt is different than the vectype that is used to determine the\n    vectorization factor, because it consists of a different number of elements\n    than the actual number of elements that are being operated upon in parallel.\n \n@@ -6052,14 +6052,13 @@ is_nonwrapping_integer_induction (gimple *stmt, struct loop *loop)\n    does *NOT* necessarily hold for reduction patterns.  */\n \n bool\n-vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n+vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\tstmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t\tslp_instance slp_node_instance,\n \t\t\tstmt_vector_for_cost *cost_vec)\n {\n   tree vec_dest;\n   tree scalar_dest;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n   tree vectype_in = NULL_TREE;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n@@ -6247,7 +6246,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n         inside the loop body. The last operand is the reduction variable,\n         which is defined by the loop-header-phi.  */\n \n-  gcc_assert (is_gimple_assign (stmt));\n+  gassign *stmt = as_a <gassign *> (stmt_info->stmt);\n \n   /* Flatten RHS.  */\n   switch (get_gimple_rhs_class (gimple_assign_rhs_code (stmt)))\n@@ -7240,18 +7239,17 @@ vect_worthwhile_without_simd_p (vec_info *vinfo, tree_code code)\n \n /* Function vectorizable_induction\n \n-   Check if PHI performs an induction computation that can be vectorized.\n+   Check if STMT_INFO performs an induction computation that can be vectorized.\n    If VEC_STMT is also passed, vectorize the induction PHI: create a vectorized\n    phi to replace it, put it in VEC_STMT, and add it to the same basic block.\n-   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+   Return true if STMT_INFO is vectorizable in this way.  */\n \n bool\n-vectorizable_induction (gimple *phi,\n+vectorizable_induction (stmt_vec_info stmt_info,\n \t\t\tgimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n \t\t\tstmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t\tstmt_vector_for_cost *cost_vec)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (phi);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   unsigned ncopies;\n@@ -7276,9 +7274,9 @@ vectorizable_induction (gimple *phi,\n   edge latch_e;\n   tree loop_arg;\n   gimple_stmt_iterator si;\n-  basic_block bb = gimple_bb (phi);\n \n-  if (gimple_code (phi) != GIMPLE_PHI)\n+  gphi *phi = dyn_cast <gphi *> (stmt_info->stmt);\n+  if (!phi)\n     return false;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n@@ -7426,6 +7424,7 @@ vectorizable_induction (gimple *phi,\n     }\n \n   /* Find the first insertion point in the BB.  */\n+  basic_block bb = gimple_bb (phi);\n   si = gsi_after_labels (bb);\n \n   /* For SLP induction we have to generate several IVs as for example\n@@ -7791,17 +7790,16 @@ vectorizable_induction (gimple *phi,\n \n /* Function vectorizable_live_operation.\n \n-   STMT computes a value that is used outside the loop.  Check if\n+   STMT_INFO computes a value that is used outside the loop.  Check if\n    it can be supported.  */\n \n bool\n-vectorizable_live_operation (gimple *stmt,\n+vectorizable_live_operation (stmt_vec_info stmt_info,\n \t\t\t     gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n \t\t\t     slp_tree slp_node, int slp_index,\n \t\t\t     stmt_vec_info *vec_stmt,\n \t\t\t     stmt_vector_for_cost *)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   imm_use_iterator imm_iter;\n@@ -7908,8 +7906,9 @@ vectorizable_live_operation (gimple *stmt,\n     }\n \n   /* If stmt has a related stmt, then use that for getting the lhs.  */\n-  if (is_pattern_stmt_p (stmt_info))\n-    stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n+  gimple *stmt = (is_pattern_stmt_p (stmt_info)\n+\t\t  ? STMT_VINFO_RELATED_STMT (stmt_info)->stmt\n+\t\t  : stmt_info->stmt);\n \n   lhs = (is_a <gphi *> (stmt)) ? gimple_phi_result (stmt)\n \t: gimple_get_lhs (stmt);\n@@ -8010,17 +8009,17 @@ vectorizable_live_operation (gimple *stmt,\n   return true;\n }\n \n-/* Kill any debug uses outside LOOP of SSA names defined in STMT.  */\n+/* Kill any debug uses outside LOOP of SSA names defined in STMT_INFO.  */\n \n static void\n-vect_loop_kill_debug_uses (struct loop *loop, gimple *stmt)\n+vect_loop_kill_debug_uses (struct loop *loop, stmt_vec_info stmt_info)\n {\n   ssa_op_iter op_iter;\n   imm_use_iterator imm_iter;\n   def_operand_p def_p;\n   gimple *ustmt;\n \n-  FOR_EACH_PHI_OR_STMT_DEF (def_p, stmt, op_iter, SSA_OP_DEF)\n+  FOR_EACH_PHI_OR_STMT_DEF (def_p, stmt_info->stmt, op_iter, SSA_OP_DEF)\n     {\n       FOR_EACH_IMM_USE_STMT (ustmt, imm_iter, DEF_FROM_PTR (def_p))\n \t{"}, {"sha": "72785c882a46b7c06940f6c9561af7cb3513a40a", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32e8e429c685629fc4363138f564f41de47aa7a2/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32e8e429c685629fc4363138f564f41de47aa7a2/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=32e8e429c685629fc4363138f564f41de47aa7a2", "patch": "@@ -236,22 +236,20 @@ vect_get_internal_def (vec_info *vinfo, tree op)\n   return NULL;\n }\n \n-/* Check whether NAME, an ssa-name used in USE_STMT,\n+/* Check whether NAME, an ssa-name used in STMT_VINFO,\n    is a result of a type promotion, such that:\n      DEF_STMT: NAME = NOP (name0)\n    If CHECK_SIGN is TRUE, check that either both types are signed or both are\n    unsigned.  */\n \n static bool\n-type_conversion_p (tree name, gimple *use_stmt, bool check_sign,\n+type_conversion_p (tree name, stmt_vec_info stmt_vinfo, bool check_sign,\n \t\t   tree *orig_type, gimple **def_stmt, bool *promotion)\n {\n-  stmt_vec_info stmt_vinfo;\n   tree type = TREE_TYPE (name);\n   tree oprnd0;\n   enum vect_def_type dt;\n \n-  stmt_vinfo = vinfo_for_stmt (use_stmt);\n   stmt_vec_info def_stmt_info;\n   if (!vect_is_simple_use (name, stmt_vinfo->vinfo, &dt, &def_stmt_info,\n \t\t\t   def_stmt))\n@@ -3498,15 +3496,13 @@ sort_after_uid (const void *p1, const void *p2)\n }\n \n /* Create pattern stmts for all stmts participating in the bool pattern\n-   specified by BOOL_STMT_SET and its root STMT with the desired type\n+   specified by BOOL_STMT_SET and its root STMT_INFO with the desired type\n    OUT_TYPE.  Return the def of the pattern root.  */\n \n static tree\n adjust_bool_stmts (hash_set <gimple *> &bool_stmt_set,\n-\t\t   tree out_type, gimple *stmt)\n+\t\t   tree out_type, stmt_vec_info stmt_info)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-\n   /* Gather original stmts in the bool pattern in their order of appearance\n      in the IL.  */\n   auto_vec<gimple *> bool_stmts (bool_stmt_set.elements ());\n@@ -4126,19 +4122,19 @@ vect_recog_mask_conversion_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n   return pattern_stmt;\n }\n \n-/* STMT is a load or store.  If the load or store is conditional, return\n+/* STMT_INFO is a load or store.  If the load or store is conditional, return\n    the boolean condition under which it occurs, otherwise return null.  */\n \n static tree\n-vect_get_load_store_mask (gimple *stmt)\n+vect_get_load_store_mask (stmt_vec_info stmt_info)\n {\n-  if (gassign *def_assign = dyn_cast <gassign *> (stmt))\n+  if (gassign *def_assign = dyn_cast <gassign *> (stmt_info->stmt))\n     {\n       gcc_assert (gimple_assign_single_p (def_assign));\n       return NULL_TREE;\n     }\n \n-  if (gcall *def_call = dyn_cast <gcall *> (stmt))\n+  if (gcall *def_call = dyn_cast <gcall *> (stmt_info->stmt))\n     {\n       internal_fn ifn = gimple_call_internal_fn (def_call);\n       int mask_index = internal_fn_mask_index (ifn);"}, {"sha": "d3c44bca40649038e8a8cecf6db33d7382e91ca3", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32e8e429c685629fc4363138f564f41de47aa7a2/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32e8e429c685629fc4363138f564f41de47aa7a2/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=32e8e429c685629fc4363138f564f41de47aa7a2", "patch": "@@ -195,14 +195,14 @@ vect_free_oprnd_info (vec<slp_oprnd_info> &oprnds_info)\n }\n \n \n-/* Find the place of the data-ref in STMT in the interleaving chain that starts\n-   from FIRST_STMT.  Return -1 if the data-ref is not a part of the chain.  */\n+/* Find the place of the data-ref in STMT_INFO in the interleaving chain\n+   that starts from FIRST_STMT_INFO.  Return -1 if the data-ref is not a part\n+   of the chain.  */\n \n int\n-vect_get_place_in_interleaving_chain (gimple *stmt, gimple *first_stmt)\n+vect_get_place_in_interleaving_chain (stmt_vec_info stmt_info,\n+\t\t\t\t      stmt_vec_info first_stmt_info)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  stmt_vec_info first_stmt_info = vinfo_for_stmt (first_stmt);\n   stmt_vec_info next_stmt_info = first_stmt_info;\n   int result = 0;\n \n@@ -1918,9 +1918,8 @@ calculate_unrolling_factor (poly_uint64 nunits, unsigned int group_size)\n \n static bool\n vect_analyze_slp_instance (vec_info *vinfo,\n-\t\t\t   gimple *stmt, unsigned max_tree_size)\n+\t\t\t   stmt_vec_info stmt_info, unsigned max_tree_size)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   slp_instance new_instance;\n   slp_tree node;\n   unsigned int group_size;\n@@ -3118,20 +3117,20 @@ vect_slp_bb (basic_block bb)\n \n \n /* Return 1 if vector type of boolean constant which is OPNUM\n-   operand in statement STMT is a boolean vector.  */\n+   operand in statement STMT_VINFO is a boolean vector.  */\n \n static bool\n-vect_mask_constant_operand_p (gimple *stmt, int opnum)\n+vect_mask_constant_operand_p (stmt_vec_info stmt_vinfo, int opnum)\n {\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n-  enum tree_code code = gimple_expr_code (stmt);\n+  enum tree_code code = gimple_expr_code (stmt_vinfo->stmt);\n   tree op, vectype;\n   enum vect_def_type dt;\n \n   /* For comparison and COND_EXPR type is chosen depending\n      on the other comparison operand.  */\n   if (TREE_CODE_CLASS (code) == tcc_comparison)\n     {\n+      gassign *stmt = as_a <gassign *> (stmt_vinfo->stmt);\n       if (opnum)\n \top = gimple_assign_rhs1 (stmt);\n       else\n@@ -3145,6 +3144,7 @@ vect_mask_constant_operand_p (gimple *stmt, int opnum)\n \n   if (code == COND_EXPR)\n     {\n+      gassign *stmt = as_a <gassign *> (stmt_vinfo->stmt);\n       tree cond = gimple_assign_rhs1 (stmt);\n \n       if (TREE_CODE (cond) == SSA_NAME)"}, {"sha": "cc3c36ed429c8aaf964bab4045ab2a7cedb9d329", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 168, "deletions": 184, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32e8e429c685629fc4363138f564f41de47aa7a2/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32e8e429c685629fc4363138f564f41de47aa7a2/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=32e8e429c685629fc4363138f564f41de47aa7a2", "patch": "@@ -192,13 +192,12 @@ vect_clobber_variable (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \n /* Function vect_mark_relevant.\n \n-   Mark STMT as \"relevant for vectorization\" and add it to WORKLIST.  */\n+   Mark STMT_INFO as \"relevant for vectorization\" and add it to WORKLIST.  */\n \n static void\n-vect_mark_relevant (vec<stmt_vec_info> *worklist, gimple *stmt,\n+vect_mark_relevant (vec<stmt_vec_info> *worklist, stmt_vec_info stmt_info,\n \t\t    enum vect_relevant relevant, bool live_p)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   enum vect_relevant save_relevant = STMT_VINFO_RELEVANT (stmt_info);\n   bool save_live_p = STMT_VINFO_LIVE_P (stmt_info);\n \n@@ -229,7 +228,6 @@ vect_mark_relevant (vec<stmt_vec_info> *worklist, gimple *stmt,\n       gcc_assert (STMT_VINFO_RELATED_STMT (stmt_info) == old_stmt_info);\n       save_relevant = STMT_VINFO_RELEVANT (stmt_info);\n       save_live_p = STMT_VINFO_LIVE_P (stmt_info);\n-      stmt = stmt_info->stmt;\n     }\n \n   STMT_VINFO_LIVE_P (stmt_info) |= live_p;\n@@ -251,15 +249,17 @@ vect_mark_relevant (vec<stmt_vec_info> *worklist, gimple *stmt,\n \n /* Function is_simple_and_all_uses_invariant\n \n-   Return true if STMT is simple and all uses of it are invariant.  */\n+   Return true if STMT_INFO is simple and all uses of it are invariant.  */\n \n bool\n-is_simple_and_all_uses_invariant (gimple *stmt, loop_vec_info loop_vinfo)\n+is_simple_and_all_uses_invariant (stmt_vec_info stmt_info,\n+\t\t\t\t  loop_vec_info loop_vinfo)\n {\n   tree op;\n   ssa_op_iter iter;\n \n-  if (!is_gimple_assign (stmt))\n+  gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt);\n+  if (!stmt)\n     return false;\n \n   FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n@@ -361,14 +361,13 @@ vect_stmt_relevant_p (stmt_vec_info stmt_info, loop_vec_info loop_vinfo,\n \n /* Function exist_non_indexing_operands_for_use_p\n \n-   USE is one of the uses attached to STMT.  Check if USE is\n-   used in STMT for anything other than indexing an array.  */\n+   USE is one of the uses attached to STMT_INFO.  Check if USE is\n+   used in STMT_INFO for anything other than indexing an array.  */\n \n static bool\n-exist_non_indexing_operands_for_use_p (tree use, gimple *stmt)\n+exist_non_indexing_operands_for_use_p (tree use, stmt_vec_info stmt_info)\n {\n   tree operand;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n \n   /* USE corresponds to some operand in STMT.  If there is no data\n      reference in STMT, then any operand that corresponds to USE\n@@ -428,7 +427,7 @@ exist_non_indexing_operands_for_use_p (tree use, gimple *stmt)\n    Function process_use.\n \n    Inputs:\n-   - a USE in STMT in a loop represented by LOOP_VINFO\n+   - a USE in STMT_VINFO in a loop represented by LOOP_VINFO\n    - RELEVANT - enum value to be set in the STMT_VINFO of the stmt\n      that defined USE.  This is done by calling mark_relevant and passing it\n      the WORKLIST (to add DEF_STMT to the WORKLIST in case it is relevant).\n@@ -438,25 +437,24 @@ exist_non_indexing_operands_for_use_p (tree use, gimple *stmt)\n    Outputs:\n    Generally, LIVE_P and RELEVANT are used to define the liveness and\n    relevance info of the DEF_STMT of this USE:\n-       STMT_VINFO_LIVE_P (DEF_STMT_info) <-- live_p\n-       STMT_VINFO_RELEVANT (DEF_STMT_info) <-- relevant\n+       STMT_VINFO_LIVE_P (DEF_stmt_vinfo) <-- live_p\n+       STMT_VINFO_RELEVANT (DEF_stmt_vinfo) <-- relevant\n    Exceptions:\n    - case 1: If USE is used only for address computations (e.g. array indexing),\n    which does not need to be directly vectorized, then the liveness/relevance\n    of the respective DEF_STMT is left unchanged.\n-   - case 2: If STMT is a reduction phi and DEF_STMT is a reduction stmt, we\n-   skip DEF_STMT cause it had already been processed.\n-   - case 3: If DEF_STMT and STMT are in different nests, then  \"relevant\" will\n-   be modified accordingly.\n+   - case 2: If STMT_VINFO is a reduction phi and DEF_STMT is a reduction stmt,\n+   we skip DEF_STMT cause it had already been processed.\n+   - case 3: If DEF_STMT and STMT_VINFO are in different nests, then\n+   \"relevant\" will be modified accordingly.\n \n    Return true if everything is as expected. Return false otherwise.  */\n \n static bool\n-process_use (gimple *stmt, tree use, loop_vec_info loop_vinfo,\n+process_use (stmt_vec_info stmt_vinfo, tree use, loop_vec_info loop_vinfo,\n \t     enum vect_relevant relevant, vec<stmt_vec_info> *worklist,\n \t     bool force)\n {\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n   stmt_vec_info dstmt_vinfo;\n   basic_block bb, def_bb;\n   enum vect_def_type dt;\n@@ -1342,12 +1340,12 @@ vect_get_load_cost (stmt_vec_info stmt_info, int ncopies,\n }\n \n /* Insert the new stmt NEW_STMT at *GSI or at the appropriate place in\n-   the loop preheader for the vectorized stmt STMT.  */\n+   the loop preheader for the vectorized stmt STMT_VINFO.  */\n \n static void\n-vect_init_vector_1 (gimple *stmt, gimple *new_stmt, gimple_stmt_iterator *gsi)\n+vect_init_vector_1 (stmt_vec_info stmt_vinfo, gimple *new_stmt,\n+\t\t    gimple_stmt_iterator *gsi)\n {\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n   if (gsi)\n     vect_finish_stmt_generation (stmt_vinfo, new_stmt, gsi);\n   else\n@@ -1396,12 +1394,12 @@ vect_init_vector_1 (gimple *stmt, gimple *new_stmt, gimple_stmt_iterator *gsi)\n    Place the initialization at BSI if it is not NULL.  Otherwise, place the\n    initialization at the loop preheader.\n    Return the DEF of INIT_STMT.\n-   It will be used in the vectorization of STMT.  */\n+   It will be used in the vectorization of STMT_INFO.  */\n \n tree\n-vect_init_vector (gimple *stmt, tree val, tree type, gimple_stmt_iterator *gsi)\n+vect_init_vector (stmt_vec_info stmt_info, tree val, tree type,\n+\t\t  gimple_stmt_iterator *gsi)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   gimple *init_stmt;\n   tree new_temp;\n \n@@ -1456,15 +1454,15 @@ vect_init_vector (gimple *stmt, tree val, tree type, gimple_stmt_iterator *gsi)\n \n /* Function vect_get_vec_def_for_operand_1.\n \n-   For a defining stmt DEF_STMT of a scalar stmt, return a vector def with type\n-   DT that will be used in the vectorized stmt.  */\n+   For a defining stmt DEF_STMT_INFO of a scalar stmt, return a vector def\n+   with type DT that will be used in the vectorized stmt.  */\n \n tree\n-vect_get_vec_def_for_operand_1 (gimple *def_stmt, enum vect_def_type dt)\n+vect_get_vec_def_for_operand_1 (stmt_vec_info def_stmt_info,\n+\t\t\t\tenum vect_def_type dt)\n {\n   tree vec_oprnd;\n   stmt_vec_info vec_stmt_info;\n-  stmt_vec_info def_stmt_info = NULL;\n \n   switch (dt)\n     {\n@@ -1478,8 +1476,6 @@ vect_get_vec_def_for_operand_1 (gimple *def_stmt, enum vect_def_type dt)\n     case vect_internal_def:\n       {\n         /* Get the def from the vectorized stmt.  */\n-        def_stmt_info = vinfo_for_stmt (def_stmt);\n-\n \tvec_stmt_info = STMT_VINFO_VEC_STMT (def_stmt_info);\n \t/* Get vectorized pattern statement.  */\n \tif (!vec_stmt_info\n@@ -1501,10 +1497,9 @@ vect_get_vec_def_for_operand_1 (gimple *def_stmt, enum vect_def_type dt)\n     case vect_nested_cycle:\n     case vect_induction_def:\n       {\n-\tgcc_assert (gimple_code (def_stmt) == GIMPLE_PHI);\n+\tgcc_assert (gimple_code (def_stmt_info->stmt) == GIMPLE_PHI);\n \n \t/* Get the def from the vectorized stmt.  */\n-\tdef_stmt_info = vinfo_for_stmt (def_stmt);\n \tvec_stmt_info = STMT_VINFO_VEC_STMT (def_stmt_info);\n \tif (gphi *phi = dyn_cast <gphi *> (vec_stmt_info->stmt))\n \t  vec_oprnd = PHI_RESULT (phi);\n@@ -1521,8 +1516,8 @@ vect_get_vec_def_for_operand_1 (gimple *def_stmt, enum vect_def_type dt)\n \n /* Function vect_get_vec_def_for_operand.\n \n-   OP is an operand in STMT.  This function returns a (vector) def that will be\n-   used in the vectorized stmt for STMT.\n+   OP is an operand in STMT_VINFO.  This function returns a (vector) def\n+   that will be used in the vectorized stmt for STMT_VINFO.\n \n    In the case that OP is an SSA_NAME which is defined in the loop, then\n    STMT_VINFO_VEC_STMT of the defining stmt holds the relevant def.\n@@ -1532,12 +1527,11 @@ vect_get_vec_def_for_operand_1 (gimple *def_stmt, enum vect_def_type dt)\n    vector invariant.  */\n \n tree\n-vect_get_vec_def_for_operand (tree op, gimple *stmt, tree vectype)\n+vect_get_vec_def_for_operand (tree op, stmt_vec_info stmt_vinfo, tree vectype)\n {\n   gimple *def_stmt;\n   enum vect_def_type dt;\n   bool is_simple_use;\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n \n   if (dump_enabled_p ())\n@@ -1683,12 +1677,11 @@ vect_get_vec_defs_for_stmt_copy (enum vect_def_type *dt,\n /* Get vectorized definitions for OP0 and OP1.  */\n \n void\n-vect_get_vec_defs (tree op0, tree op1, gimple *stmt,\n+vect_get_vec_defs (tree op0, tree op1, stmt_vec_info stmt_info,\n \t\t   vec<tree> *vec_oprnds0,\n \t\t   vec<tree> *vec_oprnds1,\n \t\t   slp_tree slp_node)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   if (slp_node)\n     {\n       int nops = (op1 == NULL_TREE) ? 1 : 2;\n@@ -1727,9 +1720,8 @@ vect_get_vec_defs (tree op0, tree op1, gimple *stmt,\n    statement and create and return a stmt_vec_info for it.  */\n \n static stmt_vec_info\n-vect_finish_stmt_generation_1 (gimple *stmt, gimple *vec_stmt)\n+vect_finish_stmt_generation_1 (stmt_vec_info stmt_info, gimple *vec_stmt)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   vec_info *vinfo = stmt_info->vinfo;\n \n   stmt_vec_info vec_stmt_info = vinfo->add_stmt (vec_stmt);\n@@ -1752,14 +1744,13 @@ vect_finish_stmt_generation_1 (gimple *stmt, gimple *vec_stmt)\n   return vec_stmt_info;\n }\n \n-/* Replace the scalar statement STMT with a new vector statement VEC_STMT,\n-   which sets the same scalar result as STMT did.  Create and return a\n+/* Replace the scalar statement STMT_INFO with a new vector statement VEC_STMT,\n+   which sets the same scalar result as STMT_INFO did.  Create and return a\n    stmt_vec_info for VEC_STMT.  */\n \n stmt_vec_info\n-vect_finish_replace_stmt (gimple *stmt, gimple *vec_stmt)\n+vect_finish_replace_stmt (stmt_vec_info stmt_info, gimple *vec_stmt)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   gcc_assert (gimple_get_lhs (stmt_info->stmt) == gimple_get_lhs (vec_stmt));\n \n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt_info->stmt);\n@@ -1768,14 +1759,13 @@ vect_finish_replace_stmt (gimple *stmt, gimple *vec_stmt)\n   return vect_finish_stmt_generation_1 (stmt_info, vec_stmt);\n }\n \n-/* Add VEC_STMT to the vectorized implementation of STMT and insert it\n+/* Add VEC_STMT to the vectorized implementation of STMT_INFO and insert it\n    before *GSI.  Create and return a stmt_vec_info for VEC_STMT.  */\n \n stmt_vec_info\n-vect_finish_stmt_generation (gimple *stmt, gimple *vec_stmt,\n+vect_finish_stmt_generation (stmt_vec_info stmt_info, gimple *vec_stmt,\n \t\t\t     gimple_stmt_iterator *gsi)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   gcc_assert (gimple_code (stmt_info->stmt) != GIMPLE_LABEL);\n \n   if (!gsi_end_p (*gsi)\n@@ -1976,22 +1966,21 @@ prepare_load_store_mask (tree mask_type, tree loop_mask, tree vec_mask,\n }\n \n /* Determine whether we can use a gather load or scatter store to vectorize\n-   strided load or store STMT by truncating the current offset to a smaller\n-   width.  We need to be able to construct an offset vector:\n+   strided load or store STMT_INFO by truncating the current offset to a\n+   smaller width.  We need to be able to construct an offset vector:\n \n      { 0, X, X*2, X*3, ... }\n \n-   without loss of precision, where X is STMT's DR_STEP.\n+   without loss of precision, where X is STMT_INFO's DR_STEP.\n \n    Return true if this is possible, describing the gather load or scatter\n    store in GS_INFO.  MASKED_P is true if the load or store is conditional.  */\n \n static bool\n-vect_truncate_gather_scatter_offset (gimple *stmt, loop_vec_info loop_vinfo,\n-\t\t\t\t     bool masked_p,\n+vect_truncate_gather_scatter_offset (stmt_vec_info stmt_info,\n+\t\t\t\t     loop_vec_info loop_vinfo, bool masked_p,\n \t\t\t\t     gather_scatter_info *gs_info)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   tree step = DR_STEP (dr);\n   if (TREE_CODE (step) != INTEGER_CST)\n@@ -2112,14 +2101,13 @@ vect_use_strided_gather_scatters_p (stmt_vec_info stmt_info,\n   return true;\n }\n \n-/* STMT is a non-strided load or store, meaning that it accesses\n+/* STMT_INFO is a non-strided load or store, meaning that it accesses\n    elements with a known constant step.  Return -1 if that step\n    is negative, 0 if it is zero, and 1 if it is greater than zero.  */\n \n static int\n-compare_step_with_zero (gimple *stmt)\n+compare_step_with_zero (stmt_vec_info stmt_info)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   return tree_int_cst_compare (vect_dr_behavior (dr)->step,\n \t\t\t       size_zero_node);\n@@ -2144,29 +2132,29 @@ perm_mask_for_reverse (tree vectype)\n   return vect_gen_perm_mask_checked (vectype, indices);\n }\n \n-/* STMT is either a masked or unconditional store.  Return the value\n+/* STMT_INFO is either a masked or unconditional store.  Return the value\n    being stored.  */\n \n tree\n-vect_get_store_rhs (gimple *stmt)\n+vect_get_store_rhs (stmt_vec_info stmt_info)\n {\n-  if (gassign *assign = dyn_cast <gassign *> (stmt))\n+  if (gassign *assign = dyn_cast <gassign *> (stmt_info->stmt))\n     {\n       gcc_assert (gimple_assign_single_p (assign));\n       return gimple_assign_rhs1 (assign);\n     }\n-  if (gcall *call = dyn_cast <gcall *> (stmt))\n+  if (gcall *call = dyn_cast <gcall *> (stmt_info->stmt))\n     {\n       internal_fn ifn = gimple_call_internal_fn (call);\n       int index = internal_fn_stored_value_index (ifn);\n       gcc_assert (index >= 0);\n-      return gimple_call_arg (stmt, index);\n+      return gimple_call_arg (call, index);\n     }\n   gcc_unreachable ();\n }\n \n /* A subroutine of get_load_store_type, with a subset of the same\n-   arguments.  Handle the case where STMT is part of a grouped load\n+   arguments.  Handle the case where STMT_INFO is part of a grouped load\n    or store.\n \n    For stores, the statements in the group are all consecutive\n@@ -2175,12 +2163,11 @@ vect_get_store_rhs (gimple *stmt)\n    as well as at the end.  */\n \n static bool\n-get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n+get_group_load_store_type (stmt_vec_info stmt_info, tree vectype, bool slp,\n \t\t\t   bool masked_p, vec_load_store_type vls_type,\n \t\t\t   vect_memory_access_type *memory_access_type,\n \t\t\t   gather_scatter_info *gs_info)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   vec_info *vinfo = stmt_info->vinfo;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = loop_vinfo ? LOOP_VINFO_LOOP (loop_vinfo) : NULL;\n@@ -2350,15 +2337,14 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n }\n \n /* A subroutine of get_load_store_type, with a subset of the same\n-   arguments.  Handle the case where STMT is a load or store that\n+   arguments.  Handle the case where STMT_INFO is a load or store that\n    accesses consecutive elements with a negative step.  */\n \n static vect_memory_access_type\n-get_negative_load_store_type (gimple *stmt, tree vectype,\n+get_negative_load_store_type (stmt_vec_info stmt_info, tree vectype,\n \t\t\t      vec_load_store_type vls_type,\n \t\t\t      unsigned int ncopies)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   dr_alignment_support alignment_support_scheme;\n \n@@ -2400,7 +2386,7 @@ get_negative_load_store_type (gimple *stmt, tree vectype,\n   return VMAT_CONTIGUOUS_REVERSE;\n }\n \n-/* Analyze load or store statement STMT of type VLS_TYPE.  Return true\n+/* Analyze load or store statement STMT_INFO of type VLS_TYPE.  Return true\n    if there is a memory access type that the vectorized form can use,\n    storing it in *MEMORY_ACCESS_TYPE if so.  If we decide to use gathers\n    or scatters, fill in GS_INFO accordingly.\n@@ -2411,12 +2397,12 @@ get_negative_load_store_type (gimple *stmt, tree vectype,\n    NCOPIES is the number of vector statements that will be needed.  */\n \n static bool\n-get_load_store_type (gimple *stmt, tree vectype, bool slp, bool masked_p,\n-\t\t     vec_load_store_type vls_type, unsigned int ncopies,\n+get_load_store_type (stmt_vec_info stmt_info, tree vectype, bool slp,\n+\t\t     bool masked_p, vec_load_store_type vls_type,\n+\t\t     unsigned int ncopies,\n \t\t     vect_memory_access_type *memory_access_type,\n \t\t     gather_scatter_info *gs_info)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   vec_info *vinfo = stmt_info->vinfo;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n@@ -2496,12 +2482,12 @@ get_load_store_type (gimple *stmt, tree vectype, bool slp, bool masked_p,\n }\n \n /* Return true if boolean argument MASK is suitable for vectorizing\n-   conditional load or store STMT.  When returning true, store the type\n+   conditional load or store STMT_INFO.  When returning true, store the type\n    of the definition in *MASK_DT_OUT and the type of the vectorized mask\n    in *MASK_VECTYPE_OUT.  */\n \n static bool\n-vect_check_load_store_mask (gimple *stmt, tree mask,\n+vect_check_load_store_mask (stmt_vec_info stmt_info, tree mask,\n \t\t\t    vect_def_type *mask_dt_out,\n \t\t\t    tree *mask_vectype_out)\n {\n@@ -2521,7 +2507,6 @@ vect_check_load_store_mask (gimple *stmt, tree mask,\n       return false;\n     }\n \n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   enum vect_def_type mask_dt;\n   tree mask_vectype;\n   if (!vect_is_simple_use (mask, stmt_info->vinfo, &mask_dt, &mask_vectype))\n@@ -2566,13 +2551,14 @@ vect_check_load_store_mask (gimple *stmt, tree mask,\n }\n \n /* Return true if stored value RHS is suitable for vectorizing store\n-   statement STMT.  When returning true, store the type of the\n+   statement STMT_INFO.  When returning true, store the type of the\n    definition in *RHS_DT_OUT, the type of the vectorized store value in\n    *RHS_VECTYPE_OUT and the type of the store in *VLS_TYPE_OUT.  */\n \n static bool\n-vect_check_store_rhs (gimple *stmt, tree rhs, vect_def_type *rhs_dt_out,\n-\t\t      tree *rhs_vectype_out, vec_load_store_type *vls_type_out)\n+vect_check_store_rhs (stmt_vec_info stmt_info, tree rhs,\n+\t\t      vect_def_type *rhs_dt_out, tree *rhs_vectype_out,\n+\t\t      vec_load_store_type *vls_type_out)\n {\n   /* In the case this is a store from a constant make sure\n      native_encode_expr can handle it.  */\n@@ -2584,7 +2570,6 @@ vect_check_store_rhs (gimple *stmt, tree rhs, vect_def_type *rhs_dt_out,\n       return false;\n     }\n \n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   enum vect_def_type rhs_dt;\n   tree rhs_vectype;\n   if (!vect_is_simple_use (rhs, stmt_info->vinfo, &rhs_dt, &rhs_vectype))\n@@ -2666,18 +2651,19 @@ vect_build_zero_merge_argument (stmt_vec_info stmt_info, tree vectype)\n   return vect_init_vector (stmt_info, merge, vectype, NULL);\n }\n \n-/* Build a gather load call while vectorizing STMT.  Insert new instructions\n-   before GSI and add them to VEC_STMT.  GS_INFO describes the gather load\n-   operation.  If the load is conditional, MASK is the unvectorized\n-   condition and MASK_DT is its definition type, otherwise MASK is null.  */\n+/* Build a gather load call while vectorizing STMT_INFO.  Insert new\n+   instructions before GSI and add them to VEC_STMT.  GS_INFO describes\n+   the gather load operation.  If the load is conditional, MASK is the\n+   unvectorized condition and MASK_DT is its definition type, otherwise\n+   MASK is null.  */\n \n static void\n-vect_build_gather_load_calls (gimple *stmt, gimple_stmt_iterator *gsi,\n+vect_build_gather_load_calls (stmt_vec_info stmt_info,\n+\t\t\t      gimple_stmt_iterator *gsi,\n \t\t\t      stmt_vec_info *vec_stmt,\n-\t\t\t      gather_scatter_info *gs_info, tree mask,\n-\t\t\t      vect_def_type mask_dt)\n+\t\t\t      gather_scatter_info *gs_info,\n+\t\t\t      tree mask, vect_def_type mask_dt)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n@@ -2897,19 +2883,19 @@ vect_get_gather_scatter_ops (struct loop *loop, stmt_vec_info stmt_info,\n \n /* Prepare to implement a grouped or strided load or store using\n    the gather load or scatter store operation described by GS_INFO.\n-   STMT is the load or store statement.\n+   STMT_INFO is the load or store statement.\n \n    Set *DATAREF_BUMP to the amount that should be added to the base\n    address after each copy of the vectorized statement.  Set *VEC_OFFSET\n    to an invariant offset vector in which element I has the value\n    I * DR_STEP / SCALE.  */\n \n static void\n-vect_get_strided_load_store_ops (gimple *stmt, loop_vec_info loop_vinfo,\n+vect_get_strided_load_store_ops (stmt_vec_info stmt_info,\n+\t\t\t\t loop_vec_info loop_vinfo,\n \t\t\t\t gather_scatter_info *gs_info,\n \t\t\t\t tree *dataref_bump, tree *vec_offset)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n@@ -2963,13 +2949,13 @@ vect_get_data_ptr_increment (data_reference *dr, tree aggr_type,\n /* Check and perform vectorization of BUILT_IN_BSWAP{16,32,64}.  */\n \n static bool\n-vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n+vectorizable_bswap (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t    stmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t    tree vectype_in, enum vect_def_type *dt,\n \t\t    stmt_vector_for_cost *cost_vec)\n {\n   tree op, vectype;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  gcall *stmt = as_a <gcall *> (stmt_info->stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   unsigned ncopies;\n   unsigned HOST_WIDE_INT nunits, num_bytes;\n@@ -3103,13 +3089,13 @@ simple_integer_narrowing (tree vectype_out, tree vectype_in,\n \n /* Function vectorizable_call.\n \n-   Check if GS performs a function call that can be vectorized.\n-   If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n-   stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n-   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+   Check if STMT_INFO performs a function call that can be vectorized.\n+   If VEC_STMT is also passed, vectorize STMT_INFO: create a vectorized\n+   stmt to replace it, put it in VEC_STMT, and insert it at GSI.\n+   Return true if STMT_INFO is vectorizable in this way.  */\n \n static bool\n-vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi,\n+vectorizable_call (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t   stmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t   stmt_vector_for_cost *cost_vec)\n {\n@@ -3118,7 +3104,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi,\n   tree scalar_dest;\n   tree op;\n   tree vec_oprnd0 = NULL_TREE, vec_oprnd1 = NULL_TREE;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (gs), prev_stmt_info;\n+  stmt_vec_info prev_stmt_info;\n   tree vectype_out, vectype_in;\n   poly_uint64 nunits_in;\n   poly_uint64 nunits_out;\n@@ -3747,22 +3733,23 @@ simd_clone_subparts (tree vectype)\n \n /* Function vectorizable_simd_clone_call.\n \n-   Check if STMT performs a function call that can be vectorized\n+   Check if STMT_INFO performs a function call that can be vectorized\n    by calling a simd clone of the function.\n-   If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n-   stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n-   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+   If VEC_STMT is also passed, vectorize STMT_INFO: create a vectorized\n+   stmt to replace it, put it in VEC_STMT, and insert it at GSI.\n+   Return true if STMT_INFO is vectorizable in this way.  */\n \n static bool\n-vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n+vectorizable_simd_clone_call (stmt_vec_info stmt_info,\n+\t\t\t      gimple_stmt_iterator *gsi,\n \t\t\t      stmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t\t      stmt_vector_for_cost *)\n {\n   tree vec_dest;\n   tree scalar_dest;\n   tree op, type;\n   tree vec_oprnd0 = NULL_TREE;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt), prev_stmt_info;\n+  stmt_vec_info prev_stmt_info;\n   tree vectype;\n   unsigned int nunits;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n@@ -3778,7 +3765,8 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n   vec<constructor_elt, va_gc> *ret_ctor_elts = NULL;\n \n   /* Is STMT a vectorizable call?   */\n-  if (!is_gimple_call (stmt))\n+  gcall *stmt = dyn_cast <gcall *> (stmt_info->stmt);\n+  if (!stmt)\n     return false;\n \n   fndecl = gimple_call_fndecl (stmt);\n@@ -4487,15 +4475,15 @@ vect_get_loop_based_defs (tree *oprnd, stmt_vec_info stmt_info,\n \n static void\n vect_create_vectorized_demotion_stmts (vec<tree> *vec_oprnds,\n-\t\t\t\t       int multi_step_cvt, gimple *stmt,\n+\t\t\t\t       int multi_step_cvt,\n+\t\t\t\t       stmt_vec_info stmt_info,\n \t\t\t\t       vec<tree> vec_dsts,\n \t\t\t\t       gimple_stmt_iterator *gsi,\n \t\t\t\t       slp_tree slp_node, enum tree_code code,\n \t\t\t\t       stmt_vec_info *prev_stmt_info)\n {\n   unsigned int i;\n   tree vop0, vop1, new_tmp, vec_dest;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n \n   vec_dest = vec_dsts.pop ();\n \n@@ -4606,21 +4594,20 @@ vect_create_vectorized_promotion_stmts (vec<tree> *vec_oprnds0,\n }\n \n \n-/* Check if STMT performs a conversion operation, that can be vectorized.\n-   If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n+/* Check if STMT_INFO performs a conversion operation that can be vectorized.\n+   If VEC_STMT is also passed, vectorize STMT_INFO: create a vectorized\n    stmt to replace it, put it in VEC_STMT, and insert it at GSI.\n-   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+   Return true if STMT_INFO is vectorizable in this way.  */\n \n static bool\n-vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n+vectorizable_conversion (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t stmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t\t stmt_vector_for_cost *cost_vec)\n {\n   tree vec_dest;\n   tree scalar_dest;\n   tree op0, op1 = NULL_TREE;\n   tree vec_oprnd0 = NULL_TREE, vec_oprnd1 = NULL_TREE;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   enum tree_code code, code1 = ERROR_MARK, code2 = ERROR_MARK;\n   enum tree_code codecvt1 = ERROR_MARK, codecvt2 = ERROR_MARK;\n@@ -4655,7 +4642,8 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n       && ! vec_stmt)\n     return false;\n \n-  if (!is_gimple_assign (stmt))\n+  gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt);\n+  if (!stmt)\n     return false;\n \n   if (TREE_CODE (gimple_assign_lhs (stmt)) != SSA_NAME)\n@@ -5220,20 +5208,19 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n \n /* Function vectorizable_assignment.\n \n-   Check if STMT performs an assignment (copy) that can be vectorized.\n-   If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n-   stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n-   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+   Check if STMT_INFO performs an assignment (copy) that can be vectorized.\n+   If VEC_STMT is also passed, vectorize the STMT_INFO: create a vectorized\n+   stmt to replace it, put it in VEC_STMT, and insert it at GSI.\n+   Return true if STMT_INFO is vectorizable in this way.  */\n \n static bool\n-vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n+vectorizable_assignment (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t stmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t\t stmt_vector_for_cost *cost_vec)\n {\n   tree vec_dest;\n   tree scalar_dest;\n   tree op;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   tree new_temp;\n   enum vect_def_type dt[1] = {vect_unknown_def_type};\n@@ -5256,7 +5243,8 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   /* Is vectorizable assignment?  */\n-  if (!is_gimple_assign (stmt))\n+  gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt);\n+  if (!stmt)\n     return false;\n \n   scalar_dest = gimple_assign_lhs (stmt);\n@@ -5422,21 +5410,20 @@ vect_supportable_shift (enum tree_code code, tree scalar_type)\n \n /* Function vectorizable_shift.\n \n-   Check if STMT performs a shift operation that can be vectorized.\n-   If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n-   stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n-   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+   Check if STMT_INFO performs a shift operation that can be vectorized.\n+   If VEC_STMT is also passed, vectorize the STMT_INFO: create a vectorized\n+   stmt to replace it, put it in VEC_STMT, and insert it at GSI.\n+   Return true if STMT_INFO is vectorizable in this way.  */\n \n static bool\n-vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n+vectorizable_shift (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t    stmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t    stmt_vector_for_cost *cost_vec)\n {\n   tree vec_dest;\n   tree scalar_dest;\n   tree op0, op1 = NULL;\n   tree vec_oprnd1 = NULL_TREE;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   enum tree_code code;\n@@ -5470,7 +5457,8 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   /* Is STMT a vectorizable binary/unary operation?   */\n-  if (!is_gimple_assign (stmt))\n+  gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt);\n+  if (!stmt)\n     return false;\n \n   if (TREE_CODE (gimple_assign_lhs (stmt)) != SSA_NAME)\n@@ -5789,21 +5777,20 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n \n /* Function vectorizable_operation.\n \n-   Check if STMT performs a binary, unary or ternary operation that can\n+   Check if STMT_INFO performs a binary, unary or ternary operation that can\n    be vectorized.\n-   If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n-   stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n-   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+   If VEC_STMT is also passed, vectorize STMT_INFO: create a vectorized\n+   stmt to replace it, put it in VEC_STMT, and insert it at GSI.\n+   Return true if STMT_INFO is vectorizable in this way.  */\n \n static bool\n-vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n+vectorizable_operation (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\tstmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t\tstmt_vector_for_cost *cost_vec)\n {\n   tree vec_dest;\n   tree scalar_dest;\n   tree op0, op1 = NULL_TREE, op2 = NULL_TREE;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   enum tree_code code, orig_code;\n@@ -5836,7 +5823,8 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   /* Is STMT a vectorizable binary/unary operation?   */\n-  if (!is_gimple_assign (stmt))\n+  gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt);\n+  if (!stmt)\n     return false;\n \n   if (TREE_CODE (gimple_assign_lhs (stmt)) != SSA_NAME)\n@@ -6215,12 +6203,11 @@ ensure_base_align (struct data_reference *dr)\n \n /* Function get_group_alias_ptr_type.\n \n-   Return the alias type for the group starting at FIRST_STMT.  */\n+   Return the alias type for the group starting at FIRST_STMT_INFO.  */\n \n static tree\n-get_group_alias_ptr_type (gimple *first_stmt)\n+get_group_alias_ptr_type (stmt_vec_info first_stmt_info)\n {\n-  stmt_vec_info first_stmt_info = vinfo_for_stmt (first_stmt);\n   struct data_reference *first_dr, *next_dr;\n \n   first_dr = STMT_VINFO_DATA_REF (first_stmt_info);\n@@ -6244,21 +6231,20 @@ get_group_alias_ptr_type (gimple *first_stmt)\n \n /* Function vectorizable_store.\n \n-   Check if STMT defines a non scalar data-ref (array/pointer/structure) that\n-   can be vectorized.\n-   If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n-   stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n-   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+   Check if STMT_INFO defines a non scalar data-ref (array/pointer/structure)\n+   that can be vectorized.\n+   If VEC_STMT is also passed, vectorize STMT_INFO: create a vectorized\n+   stmt to replace it, put it in VEC_STMT, and insert it at GSI.\n+   Return true if STMT_INFO is vectorizable in this way.  */\n \n static bool\n-vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi,\n+vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t    stmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t    stmt_vector_for_cost *cost_vec)\n {\n   tree data_ref;\n   tree op;\n   tree vec_oprnd = NULL_TREE;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr = NULL;\n   tree elem_type;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n@@ -7350,19 +7336,19 @@ permute_vec_elements (tree x, tree y, tree mask_vec, stmt_vec_info stmt_info,\n   return data_ref;\n }\n \n-/* Hoist the definitions of all SSA uses on STMT out of the loop LOOP,\n+/* Hoist the definitions of all SSA uses on STMT_INFO out of the loop LOOP,\n    inserting them on the loops preheader edge.  Returns true if we\n-   were successful in doing so (and thus STMT can be moved then),\n+   were successful in doing so (and thus STMT_INFO can be moved then),\n    otherwise returns false.  */\n \n static bool\n-hoist_defs_of_uses (gimple *stmt, struct loop *loop)\n+hoist_defs_of_uses (stmt_vec_info stmt_info, struct loop *loop)\n {\n   ssa_op_iter i;\n   tree op;\n   bool any = false;\n \n-  FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_USE)\n+  FOR_EACH_SSA_TREE_OPERAND (op, stmt_info->stmt, i, SSA_OP_USE)\n     {\n       gimple *def_stmt = SSA_NAME_DEF_STMT (op);\n       if (!gimple_nop_p (def_stmt)\n@@ -7390,7 +7376,7 @@ hoist_defs_of_uses (gimple *stmt, struct loop *loop)\n   if (!any)\n     return true;\n \n-  FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_USE)\n+  FOR_EACH_SSA_TREE_OPERAND (op, stmt_info->stmt, i, SSA_OP_USE)\n     {\n       gimple *def_stmt = SSA_NAME_DEF_STMT (op);\n       if (!gimple_nop_p (def_stmt)\n@@ -7407,26 +7393,25 @@ hoist_defs_of_uses (gimple *stmt, struct loop *loop)\n \n /* vectorizable_load.\n \n-   Check if STMT reads a non scalar data-ref (array/pointer/structure) that\n-   can be vectorized.\n-   If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n-   stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n-   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+   Check if STMT_INFO reads a non scalar data-ref (array/pointer/structure)\n+   that can be vectorized.\n+   If VEC_STMT is also passed, vectorize STMT_INFO: create a vectorized\n+   stmt to replace it, put it in VEC_STMT, and insert it at GSI.\n+   Return true if STMT_INFO is vectorizable in this way.  */\n \n static bool\n-vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi,\n+vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t   stmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t   slp_instance slp_node_instance,\n \t\t   stmt_vector_for_cost *cost_vec)\n {\n   tree scalar_dest;\n   tree vec_dest = NULL;\n   tree data_ref = NULL;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   stmt_vec_info prev_stmt_info;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = NULL;\n-  struct loop *containing_loop = (gimple_bb (stmt))->loop_father;\n+  struct loop *containing_loop = gimple_bb (stmt_info->stmt)->loop_father;\n   bool nested_in_vect_loop = false;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr = NULL;\n   tree elem_type;\n@@ -8532,6 +8517,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t      && !nested_in_vect_loop\n \t\t      && hoist_defs_of_uses (stmt_info, loop))\n \t\t    {\n+\t\t      gassign *stmt = as_a <gassign *> (stmt_info->stmt);\n \t\t      if (dump_enabled_p ())\n \t\t\t{\n \t\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n@@ -8730,19 +8716,19 @@ vect_is_simple_cond (tree cond, vec_info *vinfo,\n \n /* vectorizable_condition.\n \n-   Check if STMT is conditional modify expression that can be vectorized.\n-   If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n+   Check if STMT_INFO is conditional modify expression that can be vectorized.\n+   If VEC_STMT is also passed, vectorize STMT_INFO: create a vectorized\n    stmt using VEC_COND_EXPR  to replace it, put it in VEC_STMT, and insert it\n    at GSI.\n \n-   When STMT is vectorized as nested cycle, REDUC_DEF is the vector variable\n-   to be used at REDUC_INDEX (in then clause if REDUC_INDEX is 1, and in\n-   else clause if it is 2).\n+   When STMT_INFO is vectorized as a nested cycle, REDUC_DEF is the vector\n+   variable to be used at REDUC_INDEX (in then clause if REDUC_INDEX is 1,\n+   and in else clause if it is 2).\n \n-   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+   Return true if STMT_INFO is vectorizable in this way.  */\n \n bool\n-vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n+vectorizable_condition (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\tstmt_vec_info *vec_stmt, tree reduc_def,\n \t\t\tint reduc_index, slp_tree slp_node,\n \t\t\tstmt_vector_for_cost *cost_vec)\n@@ -8751,7 +8737,6 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree vec_dest = NULL_TREE;\n   tree cond_expr, cond_expr0 = NULL_TREE, cond_expr1 = NULL_TREE;\n   tree then_clause, else_clause;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree comp_vectype = NULL_TREE;\n   tree vec_cond_lhs = NULL_TREE, vec_cond_rhs = NULL_TREE;\n   tree vec_then_clause = NULL_TREE, vec_else_clause = NULL_TREE;\n@@ -8800,7 +8785,8 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n     }\n \n   /* Is vectorizable conditional operation?  */\n-  if (!is_gimple_assign (stmt))\n+  gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt);\n+  if (!stmt)\n     return false;\n \n   code = gimple_assign_rhs_code (stmt);\n@@ -9138,19 +9124,18 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n \n /* vectorizable_comparison.\n \n-   Check if STMT is comparison expression that can be vectorized.\n-   If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n+   Check if STMT_INFO is comparison expression that can be vectorized.\n+   If VEC_STMT is also passed, vectorize STMT_INFO: create a vectorized\n    comparison, put it in VEC_STMT, and insert it at GSI.\n \n-   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+   Return true if STMT_INFO is vectorizable in this way.  */\n \n static bool\n-vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n+vectorizable_comparison (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t stmt_vec_info *vec_stmt, tree reduc_def,\n \t\t\t slp_tree slp_node, stmt_vector_for_cost *cost_vec)\n {\n   tree lhs, rhs1, rhs2;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype1 = NULL_TREE, vectype2 = NULL_TREE;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree vec_rhs1 = NULL_TREE, vec_rhs2 = NULL_TREE;\n@@ -9197,7 +9182,8 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n       return false;\n     }\n \n-  if (!is_gimple_assign (stmt))\n+  gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt);\n+  if (!stmt)\n     return false;\n \n   code = gimple_assign_rhs_code (stmt);\n@@ -9446,10 +9432,10 @@ can_vectorize_live_stmts (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n /* Make sure the statement is vectorizable.  */\n \n bool\n-vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n-\t\t   slp_instance node_instance, stmt_vector_for_cost *cost_vec)\n+vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n+\t\t   slp_tree node, slp_instance node_instance,\n+\t\t   stmt_vector_for_cost *cost_vec)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   vec_info *vinfo = stmt_info->vinfo;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   enum vect_relevant relevance = STMT_VINFO_RELEVANT (stmt_info);\n@@ -9525,7 +9511,6 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n \t      || STMT_VINFO_LIVE_P (pattern_stmt_info)))\n         {\n           /* Analyze PATTERN_STMT instead of the original stmt.  */\n-\t  stmt = pattern_stmt_info->stmt;\n \t  stmt_info = pattern_stmt_info;\n           if (dump_enabled_p ())\n             {\n@@ -9682,14 +9667,13 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n \n /* Function vect_transform_stmt.\n \n-   Create a vectorized stmt to replace STMT, and insert it at BSI.  */\n+   Create a vectorized stmt to replace STMT_INFO, and insert it at BSI.  */\n \n bool\n-vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n+vect_transform_stmt (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t     bool *grouped_store, slp_tree slp_node,\n                      slp_instance slp_node_instance)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   vec_info *vinfo = stmt_info->vinfo;\n   bool is_store = false;\n   stmt_vec_info vec_stmt = NULL;\n@@ -9703,6 +9687,7 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t        (LOOP_VINFO_LOOP (STMT_VINFO_LOOP_VINFO (stmt_info)),\n \t\t\t stmt_info));\n \n+  gimple *stmt = stmt_info->stmt;\n   switch (STMT_VINFO_TYPE (stmt_info))\n     {\n     case type_demotion_vec_info_type:\n@@ -9861,9 +9846,9 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n    stmt_vec_info.  */\n \n void\n-vect_remove_stores (gimple *first_stmt)\n+vect_remove_stores (stmt_vec_info first_stmt_info)\n {\n-  stmt_vec_info next_stmt_info = vinfo_for_stmt (first_stmt);\n+  stmt_vec_info next_stmt_info = first_stmt_info;\n   gimple_stmt_iterator next_si;\n \n   while (next_stmt_info)\n@@ -10329,13 +10314,12 @@ vect_is_simple_use (tree operand, vec_info *vinfo, enum vect_def_type *dt,\n    widening operation (short in the above example).  */\n \n bool\n-supportable_widening_operation (enum tree_code code, gimple *stmt,\n+supportable_widening_operation (enum tree_code code, stmt_vec_info stmt_info,\n \t\t\t\ttree vectype_out, tree vectype_in,\n                                 enum tree_code *code1, enum tree_code *code2,\n                                 int *multi_step_cvt,\n                                 vec<tree> *interm_types)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *vect_loop = NULL;\n   machine_mode vec_mode;"}, {"sha": "8a0ca0a492547a39eba67a63f71053753ba78272", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32e8e429c685629fc4363138f564f41de47aa7a2/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32e8e429c685629fc4363138f564f41de47aa7a2/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=32e8e429c685629fc4363138f564f41de47aa7a2", "patch": "@@ -627,13 +627,6 @@ loop_vec_info_for_loop (struct loop *loop)\n   return (loop_vec_info) loop->aux;\n }\n \n-static inline bool\n-nested_in_vect_loop_p (struct loop *loop, gimple *stmt)\n-{\n-  return (loop->inner\n-          && (loop->inner == (gimple_bb (stmt))->loop_father));\n-}\n-\n typedef struct _bb_vec_info : public vec_info\n {\n   _bb_vec_info (gimple_stmt_iterator, gimple_stmt_iterator, vec_info_shared *);\n@@ -1119,6 +1112,13 @@ set_vinfo_for_stmt (gimple *stmt, stmt_vec_info info)\n     }\n }\n \n+static inline bool\n+nested_in_vect_loop_p (struct loop *loop, stmt_vec_info stmt_info)\n+{\n+  return (loop->inner\n+\t  && (loop->inner == (gimple_bb (stmt_info->stmt))->loop_father));\n+}\n+\n /* Return the earlier statement between STMT1_INFO and STMT2_INFO.  */\n \n static inline stmt_vec_info\n@@ -1493,8 +1493,8 @@ extern bool vect_is_simple_use (tree, vec_info *, enum vect_def_type *,\n extern bool vect_is_simple_use (tree, vec_info *, enum vect_def_type *,\n \t\t\t\ttree *, stmt_vec_info * = NULL,\n \t\t\t\tgimple ** = NULL);\n-extern bool supportable_widening_operation (enum tree_code, gimple *, tree,\n-\t\t\t\t\t    tree, enum tree_code *,\n+extern bool supportable_widening_operation (enum tree_code, stmt_vec_info,\n+\t\t\t\t\t    tree, tree, enum tree_code *,\n \t\t\t\t\t    enum tree_code *, int *,\n \t\t\t\t\t    vec<tree> *);\n extern bool supportable_narrowing_operation (enum tree_code, tree, tree,\n@@ -1505,26 +1505,26 @@ extern void free_stmt_vec_info (gimple *stmt);\n extern unsigned record_stmt_cost (stmt_vector_for_cost *, int,\n \t\t\t\t  enum vect_cost_for_stmt, stmt_vec_info,\n \t\t\t\t  int, enum vect_cost_model_location);\n-extern stmt_vec_info vect_finish_replace_stmt (gimple *, gimple *);\n-extern stmt_vec_info vect_finish_stmt_generation (gimple *, gimple *,\n+extern stmt_vec_info vect_finish_replace_stmt (stmt_vec_info, gimple *);\n+extern stmt_vec_info vect_finish_stmt_generation (stmt_vec_info, gimple *,\n \t\t\t\t\t\t  gimple_stmt_iterator *);\n extern bool vect_mark_stmts_to_be_vectorized (loop_vec_info);\n-extern tree vect_get_store_rhs (gimple *);\n-extern tree vect_get_vec_def_for_operand_1 (gimple *, enum vect_def_type);\n-extern tree vect_get_vec_def_for_operand (tree, gimple *, tree = NULL);\n-extern void vect_get_vec_defs (tree, tree, gimple *, vec<tree> *,\n+extern tree vect_get_store_rhs (stmt_vec_info);\n+extern tree vect_get_vec_def_for_operand_1 (stmt_vec_info, enum vect_def_type);\n+extern tree vect_get_vec_def_for_operand (tree, stmt_vec_info, tree = NULL);\n+extern void vect_get_vec_defs (tree, tree, stmt_vec_info, vec<tree> *,\n \t\t\t       vec<tree> *, slp_tree);\n extern void vect_get_vec_defs_for_stmt_copy (enum vect_def_type *,\n \t\t\t\t\t     vec<tree> *, vec<tree> *);\n-extern tree vect_init_vector (gimple *, tree, tree,\n+extern tree vect_init_vector (stmt_vec_info, tree, tree,\n                               gimple_stmt_iterator *);\n extern tree vect_get_vec_def_for_stmt_copy (enum vect_def_type, tree);\n-extern bool vect_transform_stmt (gimple *, gimple_stmt_iterator *,\n+extern bool vect_transform_stmt (stmt_vec_info, gimple_stmt_iterator *,\n                                  bool *, slp_tree, slp_instance);\n-extern void vect_remove_stores (gimple *);\n-extern bool vect_analyze_stmt (gimple *, bool *, slp_tree, slp_instance,\n+extern void vect_remove_stores (stmt_vec_info);\n+extern bool vect_analyze_stmt (stmt_vec_info, bool *, slp_tree, slp_instance,\n \t\t\t       stmt_vector_for_cost *);\n-extern bool vectorizable_condition (gimple *, gimple_stmt_iterator *,\n+extern bool vectorizable_condition (stmt_vec_info, gimple_stmt_iterator *,\n \t\t\t\t    stmt_vec_info *, tree, int, slp_tree,\n \t\t\t\t    stmt_vector_for_cost *);\n extern void vect_get_load_cost (stmt_vec_info, int, bool,\n@@ -1546,7 +1546,7 @@ extern tree vect_get_mask_type_for_stmt (stmt_vec_info);\n extern bool vect_can_force_dr_alignment_p (const_tree, unsigned int);\n extern enum dr_alignment_support vect_supportable_dr_alignment\n                                            (struct data_reference *, bool);\n-extern tree vect_get_smallest_scalar_type (gimple *, HOST_WIDE_INT *,\n+extern tree vect_get_smallest_scalar_type (stmt_vec_info, HOST_WIDE_INT *,\n                                            HOST_WIDE_INT *);\n extern bool vect_analyze_data_ref_dependences (loop_vec_info, unsigned int *);\n extern bool vect_slp_analyze_instance_dependence (slp_instance);\n@@ -1558,36 +1558,36 @@ extern bool vect_analyze_data_ref_accesses (vec_info *);\n extern bool vect_prune_runtime_alias_test_list (loop_vec_info);\n extern bool vect_gather_scatter_fn_p (bool, bool, tree, tree, unsigned int,\n \t\t\t\t      signop, int, internal_fn *, tree *);\n-extern bool vect_check_gather_scatter (gimple *, loop_vec_info,\n+extern bool vect_check_gather_scatter (stmt_vec_info, loop_vec_info,\n \t\t\t\t       gather_scatter_info *);\n extern bool vect_find_stmt_data_reference (loop_p, gimple *,\n \t\t\t\t\t   vec<data_reference_p> *);\n extern bool vect_analyze_data_refs (vec_info *, poly_uint64 *);\n extern void vect_record_base_alignments (vec_info *);\n-extern tree vect_create_data_ref_ptr (gimple *, tree, struct loop *, tree,\n+extern tree vect_create_data_ref_ptr (stmt_vec_info, tree, struct loop *, tree,\n \t\t\t\t      tree *, gimple_stmt_iterator *,\n \t\t\t\t      gimple **, bool, bool *,\n \t\t\t\t      tree = NULL_TREE, tree = NULL_TREE);\n-extern tree bump_vector_ptr (tree, gimple *, gimple_stmt_iterator *, gimple *,\n-\t\t\t     tree);\n+extern tree bump_vector_ptr (tree, gimple *, gimple_stmt_iterator *,\n+\t\t\t     stmt_vec_info, tree);\n extern void vect_copy_ref_info (tree, tree);\n extern tree vect_create_destination_var (tree, tree);\n extern bool vect_grouped_store_supported (tree, unsigned HOST_WIDE_INT);\n extern bool vect_store_lanes_supported (tree, unsigned HOST_WIDE_INT, bool);\n extern bool vect_grouped_load_supported (tree, bool, unsigned HOST_WIDE_INT);\n extern bool vect_load_lanes_supported (tree, unsigned HOST_WIDE_INT, bool);\n-extern void vect_permute_store_chain (vec<tree> ,unsigned int, gimple *,\n+extern void vect_permute_store_chain (vec<tree> ,unsigned int, stmt_vec_info,\n                                     gimple_stmt_iterator *, vec<tree> *);\n-extern tree vect_setup_realignment (gimple *, gimple_stmt_iterator *, tree *,\n-                                    enum dr_alignment_support, tree,\n+extern tree vect_setup_realignment (stmt_vec_info, gimple_stmt_iterator *,\n+\t\t\t\t    tree *, enum dr_alignment_support, tree,\n                                     struct loop **);\n-extern void vect_transform_grouped_load (gimple *, vec<tree> , int,\n+extern void vect_transform_grouped_load (stmt_vec_info, vec<tree> , int,\n                                          gimple_stmt_iterator *);\n-extern void vect_record_grouped_load_vectors (gimple *, vec<tree> );\n+extern void vect_record_grouped_load_vectors (stmt_vec_info, vec<tree>);\n extern tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);\n extern tree vect_get_new_ssa_name (tree, enum vect_var_kind,\n \t\t\t\t   const char * = NULL);\n-extern tree vect_create_addr_base_for_vector_ref (gimple *, gimple_seq *,\n+extern tree vect_create_addr_base_for_vector_ref (stmt_vec_info, gimple_seq *,\n \t\t\t\t\t\t  tree, tree = NULL_TREE);\n \n /* In tree-vect-loop.c.  */\n@@ -1613,16 +1613,16 @@ extern tree vect_get_loop_mask (gimple_stmt_iterator *, vec_loop_masks *,\n /* Drive for loop transformation stage.  */\n extern struct loop *vect_transform_loop (loop_vec_info);\n extern loop_vec_info vect_analyze_loop_form (struct loop *, vec_info_shared *);\n-extern bool vectorizable_live_operation (gimple *, gimple_stmt_iterator *,\n+extern bool vectorizable_live_operation (stmt_vec_info, gimple_stmt_iterator *,\n \t\t\t\t\t slp_tree, int, stmt_vec_info *,\n \t\t\t\t\t stmt_vector_for_cost *);\n-extern bool vectorizable_reduction (gimple *, gimple_stmt_iterator *,\n+extern bool vectorizable_reduction (stmt_vec_info, gimple_stmt_iterator *,\n \t\t\t\t    stmt_vec_info *, slp_tree, slp_instance,\n \t\t\t\t    stmt_vector_for_cost *);\n-extern bool vectorizable_induction (gimple *, gimple_stmt_iterator *,\n+extern bool vectorizable_induction (stmt_vec_info, gimple_stmt_iterator *,\n \t\t\t\t    stmt_vec_info *, slp_tree,\n \t\t\t\t    stmt_vector_for_cost *);\n-extern tree get_initial_def_for_reduction (gimple *, tree, tree *);\n+extern tree get_initial_def_for_reduction (stmt_vec_info, tree, tree *);\n extern bool vect_worthwhile_without_simd_p (vec_info *, tree_code);\n extern int vect_get_known_peeling_cost (loop_vec_info, int, int *,\n \t\t\t\t\tstmt_vector_for_cost *,\n@@ -1643,13 +1643,13 @@ extern void vect_detect_hybrid_slp (loop_vec_info);\n extern void vect_get_slp_defs (vec<tree> , slp_tree, vec<vec<tree> > *);\n extern bool vect_slp_bb (basic_block);\n extern stmt_vec_info vect_find_last_scalar_stmt_in_slp (slp_tree);\n-extern bool is_simple_and_all_uses_invariant (gimple *, loop_vec_info);\n+extern bool is_simple_and_all_uses_invariant (stmt_vec_info, loop_vec_info);\n extern bool can_duplicate_and_interleave_p (unsigned int, machine_mode,\n \t\t\t\t\t    unsigned int * = NULL,\n \t\t\t\t\t    tree * = NULL, tree * = NULL);\n extern void duplicate_and_interleave (gimple_seq *, tree, vec<tree>,\n \t\t\t\t      unsigned int, vec<tree> &);\n-extern int vect_get_place_in_interleaving_chain (gimple *, gimple *);\n+extern int vect_get_place_in_interleaving_chain (stmt_vec_info, stmt_vec_info);\n \n /* In tree-vect-patterns.c.  */\n /* Pattern recognition functions."}]}