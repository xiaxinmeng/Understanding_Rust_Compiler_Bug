{"sha": "f36a6110263bacbc5abf68435e3c5c3c46d532e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM2YTYxMTAyNjNiYWNiYzVhYmY2ODQzNWUzYzVjM2M0NmQ1MzJlNw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1993-10-07T21:35:55Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1993-10-07T21:35:55Z"}, "message": "Change to even newer profiling calling sequence.\n\nFrom-SVN: r5665", "tree": {"sha": "0b8cc3edf7da45b8cff2137d2a0282d8b4293988", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b8cc3edf7da45b8cff2137d2a0282d8b4293988"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f36a6110263bacbc5abf68435e3c5c3c46d532e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f36a6110263bacbc5abf68435e3c5c3c46d532e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f36a6110263bacbc5abf68435e3c5c3c46d532e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f36a6110263bacbc5abf68435e3c5c3c46d532e7/comments", "author": null, "committer": null, "parents": [{"sha": "638b724c5f6a875f384226036191a490eb961cfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/638b724c5f6a875f384226036191a490eb961cfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/638b724c5f6a875f384226036191a490eb961cfc"}], "stats": {"total": 153, "additions": 107, "deletions": 46}, "files": [{"sha": "524b541b5aa91587fd1774a3a2c23410010f4af3", "filename": "gcc/config/i386/osfrose.h", "status": "modified", "additions": 107, "deletions": 46, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f36a6110263bacbc5abf68435e3c5c3c46d532e7/gcc%2Fconfig%2Fi386%2Fosfrose.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f36a6110263bacbc5abf68435e3c5c3c46d532e7/gcc%2Fconfig%2Fi386%2Fosfrose.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosfrose.h?ref=f36a6110263bacbc5abf68435e3c5c3c46d532e7", "patch": "@@ -36,7 +36,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define MASK_NO_IDENT\t\t0x08000000\t/* suppress .ident */\n #define MASK_NO_UNDERSCORES\t0x04000000\t/* suppress leading _ */\n #define MASK_LARGE_ALIGN\t0x02000000\t/* align to >word boundaries */\n-#define MASK_MCOUNT\t\t0x01000000\t/* profiling uses mcount */\n+#define MASK_NO_MCOUNT\t\t0x01000000\t/* profiling uses mcount_ptr */\n \n #define TARGET_HALF_PIC\t\t(target_flags & MASK_HALF_PIC)\n #define TARGET_DEBUG\t\t(target_flags & MASK_HALF_PIC_DEBUG)\n@@ -46,7 +46,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define TARGET_IDENT\t\t((target_flags & MASK_NO_IDENT) == 0)\n #define TARGET_UNDERSCORES\t((target_flags & MASK_NO_UNDERSCORES) == 0)\n #define TARGET_LARGE_ALIGN\t(target_flags & MASK_LARGE_ALIGN)\n-#define TARGET_MCOUNT\t\t(target_flags & MASK_MCOUNT)\n+#define TARGET_MCOUNT\t\t((target_flags & MASK_NO_MCOUNT) == 0)\n \n #undef\tSUBTARGET_SWITCHES\n #define SUBTARGET_SWITCHES \\\n@@ -62,8 +62,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n      { \"no-underscores\", MASK_NO_UNDERSCORES},\t\t\t\t\\\n      { \"large-align\",\t MASK_LARGE_ALIGN},\t\t\t\t\\\n      { \"no-large-align\",-MASK_LARGE_ALIGN},\t\t\t\t\\\n-     { \"mcount\",\t MASK_MCOUNT},\t\t\t\t\t\\\n-     { \"no-mcount\",\t-MASK_MCOUNT},\n+     { \"mcount\",\t-MASK_NO_MCOUNT},\t\t\t\t\\\n+     { \"no-mcount\",\t MASK_NO_MCOUNT},\n \n /* OSF/rose uses stabs, not dwarf.  */\n #define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n@@ -152,67 +152,128 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* Temporarily turn off long double being 96 bits.  */\n #undef LONG_DOUBLE_TYPE_SIZE\n \n-#undef  FUNCTION_PROFILER\n-#define FUNCTION_PROFILER(FILE, LABELNO)\t\t\t\t\\\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.\n+\n+   We override it here to allow for the new profiling code to go before\n+   the prologue and the old mcount code to go after the prologue (and\n+   after %ebx has been set up for ELF shared library support).  */\n+\n+#define OSF_PROFILE_BEFORE_PROLOGUE\t\t\t\t\t\\\n+  (!TARGET_MCOUNT\t\t\t\t\t\t\t\\\n+   && !current_function_needs_context\t\t\t\t\t\\\n+   && (!flag_pic\t\t\t\t\t\t\t\\\n+       || !frame_pointer_needed\t\t\t\t\t\t\\\n+       || (!current_function_uses_pic_offset_table\t\t\t\\\n+\t   && !current_function_uses_const_pool)))\n+\n+#undef\tFUNCTION_PROLOGUE\n+#define FUNCTION_PROLOGUE(FILE, SIZE)\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n-    if (TARGET_MCOUNT && flag_pic)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tleal %sP%d@GOTOFF(%%ebx),%%edx\\n\",\t\t\\\n-\t\t LPREFIX, LABELNO);\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tcall *_mcount@GOT(%%ebx)\\n\");\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n+    char *prefix = (TARGET_UNDERSCORES) ? \"_\" : \"\";\t\t\t\\\n+    char *lprefix = LPREFIX;\t\t\t\t\t\t\\\n+    int labelno = profile_label_no;\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    /* Note that OSF/rose blew it in terms of calling mcount, since\t\\\n-       OSF/rose prepends a leading underscore, but mcount's doesn't.\t\\\n-       OSF/elf fixes this by not prepending leading underscores.  */\t\\\n-    else if (TARGET_MCOUNT)\t\t\t\t\t\t\\\n+    if (profile_flag && OSF_PROFILE_BEFORE_PROLOGUE)\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tmovl $%sP%d,%%edx\\n\", LPREFIX, LABELNO);\t\\\n-\tfprintf (FILE, \"\\tcall _mcount\\n\");\t\t\t\t\\\n+\tif (!flag_pic)\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tleal %sP%d,%%edx\\n\", lprefix, labelno);\t\\\n+\t    fprintf (FILE, \"\\tcall *%s_mcount_ptr\\n\", prefix);\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    static int call_no = 0;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tcall %sPc%d\\n\", lprefix, call_no);\t\\\n+\t    fprintf (FILE, \"%sPc%d:\\tpopl %%eax\\n\", lprefix, call_no);\t\\\n+\t    fprintf (FILE, \"\\taddl $_GLOBAL_OFFSET_TABLE_+[.-%sPc%d],%%eax\\n\", \\\n+\t\t     lprefix, call_no++);\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tleal $%sP%d@GOTOFF(%%eax),%%edx\\n\",\t\\\n+\t\t     lprefix, labelno);\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tmovl %s_mcount_ptr@GOT(%%eax),%%eax\\n\",\t\\\n+\t\t     prefix);\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tcall *%%eax\\n\");\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n+    function_prologue (FILE, SIZE);\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+/* A C statement or compound statement to output to FILE some assembler code to\n+   call the profiling subroutine `mcount'.  Before calling, the assembler code\n+   must load the address of a counter variable into a register where `mcount'\n+   expects to find the address.  The name of this variable is `LP' followed by\n+   the number LABELNO, so you would generate the name using `LP%d' in a\n+   `fprintf'.\n+ \n+   The details of how the address should be passed to `mcount' are determined\n+   by your operating system environment, not by GNU CC.  To figure them out,\n+   compile a small program for profiling using the system's installed C\n+   compiler and look at the assembler code that results. */\n+\n+#undef  FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE, LABELNO)\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (!OSF_PROFILE_BEFORE_PROLOGUE)\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-\tchar *underscore = (TARGET_UNDERSCORES) ? \"_\" : \"\";\t\t\\\n-\tchar *func = IDENTIFIER_POINTER (DECL_NAME (current_function_decl)); \\\n+\tchar *prefix = (TARGET_UNDERSCORES) ? \"_\" : \"\";\t\t\t\\\n+\tchar *lprefix = LPREFIX;\t\t\t\t\t\\\n+\tint labelno = LABELNO;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t/* Note that OSF/rose blew it in terms of calling mcount,\t\\\n+\t   since OSF/rose prepends a leading underscore, but mcount's\t\\\n+\t   doesn't.  At present, we keep this kludge for ELF as well\t\\\n+\t   to allow old kernels to build profiling.  */\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (flag_pic\t\t\t\t\t\t\t\\\n+\t    && !current_function_uses_pic_offset_table\t\t\t\\\n+\t    && !current_function_uses_const_pool)\t\t\t\\\n+\t  abort ();\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-\tif (flag_pic)\t\t\t\t\t\t\t\\\n+\tif (TARGET_MCOUNT && flag_pic)\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tmovl %s_real_mcount@GOT(%%ebx),%%eax)\\n\",\t\\\n-\t\t     underscore);\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tmovl (%%eax),%%eax\\n\");\t\t\t\\\n+\t    fprintf (FILE, \"\\tleal %sP%d@GOTOFF(%%ebx),%%edx\\n\",\t\\\n+\t\t     lprefix, labelno);\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tcall *%smcount@GOT(%%ebx)\\n\", prefix);\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\tmovl %s_real_mcount,%%eax\\n\", underscore);\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tcmpl $0,%%eax\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tje 1f\\n\");\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-\tif (flag_omit_frame_pointer)\t\t\t\t\t\\\n-\t  abort ();\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\tmovl 4(%%ebp),%%ecx\\n\");\t\t\t\\\n+\telse if (TARGET_MCOUNT)\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tmovl $%sP%d,%%edx\\n\", lprefix, labelno);\t\\\n+\t    fprintf (FILE, \"\\tcall %smcount\\n\", prefix);\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-\tif (flag_pic)\t\t\t\t\t\t\t\\\n+\telse if (flag_pic && frame_pointer_needed)\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tleal %sP%d@GOTOFF(%%ebx),%%edx\\n\",\t\\\n-\t\t     LPREFIX, LABELNO);\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tpushl %%edx\\n\");\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tpushl %%ecx\\n\");\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tleal $%s%s@GOTOFF(%%ebx),%%ecx\\n\",\t\\\n-\t\t     underscore, func);\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tmovl 4(%%ebp),%%ecx\\n\");\t\t\t\\\n \t    fprintf (FILE, \"\\tpushl %%ecx\\n\");\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tleal $%sP%d@GOTOFF(%%ebx),%%edx\\n\",\t\\\n+\t\t     lprefix, labelno);\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tmovl _mcount_ptr@GOT(%%eax),%%eax\\n\");\t\\\n+\t    fprintf (FILE, \"\\tcall *%%eax\\n\");\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tpopl %%eax\\n\");\t\t\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\telse if (frame_pointer_needed)\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tpushl $%sP%d\\n\", LPREFIX, LABELNO);\t\\\n+\t    fprintf (FILE, \"\\tmovl 4(%%ebp),%%ecx\\n\");\t\t\t\\\n \t    fprintf (FILE, \"\\tpushl %%ecx\\n\");\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tpushl $%s%s\\n\", underscore, func);\t\\\n+\t    fprintf (FILE, \"\\tleal $%sP%d,%%edx\\n\", lprefix, labelno);\t\\\n+\t    fprintf (FILE, \"\\tcall *_mcount_ptr\\n\");\t\t\t\\\n+\t    fprintf (FILE, \"\\tpopl %%eax\\n\");\t\t\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tcall *%%eax\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\taddl $12,%%esp\\n1:\\n\");\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)"}]}