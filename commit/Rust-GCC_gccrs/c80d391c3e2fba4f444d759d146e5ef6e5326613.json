{"sha": "c80d391c3e2fba4f444d759d146e5ef6e5326613", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzgwZDM5MWMzZTJmYmE0ZjQ0NGQ3NTlkMTQ2ZTVlZjZlNTMyNjYxMw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@airs.com", "date": "2005-03-07T21:07:48Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2005-03-07T21:07:48Z"}, "message": "mpw-config.in: Remove.\n\n\t* mpw-config.in: Remove.\n\t* mpw-make.sed: Remove.\n\t* mpw.c: Remove.\n\t* Makefile.in (CFILES): Remove pex-mpw.c.\n\t(CONFIGURED_OFILES): Remove pex-mpw.o.\n\t(mpw.o, pex-mpw.o): Remove targets.\n\t* maint-tool (undoc): Remove reference to mpw.c.\n\nFrom-SVN: r96043", "tree": {"sha": "443085bbef26bd8a5219872ec29de40632ee43a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/443085bbef26bd8a5219872ec29de40632ee43a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c80d391c3e2fba4f444d759d146e5ef6e5326613", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c80d391c3e2fba4f444d759d146e5ef6e5326613", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c80d391c3e2fba4f444d759d146e5ef6e5326613", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c80d391c3e2fba4f444d759d146e5ef6e5326613/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f8b151be7017b7fd6e422875210ba5f406e4abe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f8b151be7017b7fd6e422875210ba5f406e4abe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f8b151be7017b7fd6e422875210ba5f406e4abe"}], "stats": {"total": 1257, "additions": 12, "deletions": 1245}, "files": [{"sha": "bbd4b51e8b04f6986433801b198dcb1a6e8fcf95", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d391c3e2fba4f444d759d146e5ef6e5326613/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d391c3e2fba4f444d759d146e5ef6e5326613/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=c80d391c3e2fba4f444d759d146e5ef6e5326613", "patch": "@@ -1,3 +1,13 @@\n+2005-03-07  Ian Lance Taylor  <ian@airs.com>\n+\n+\t* mpw-config.in: Remove.\n+\t* mpw-make.sed: Remove.\n+\t* mpw.c: Remove.\n+\t* Makefile.in (CFILES): Remove pex-mpw.c.\n+\t(CONFIGURED_OFILES): Remove pex-mpw.o.\n+\t(mpw.o, pex-mpw.o): Remove targets.\n+\t* maint-tool (undoc): Remove reference to mpw.c.\n+\n 2005-03-06  DJ Delorie  <dj@redhat.com>\n \n \t* configure.ac (target_header_dir): vfork is a stub under djgpp."}, {"sha": "2dc4e7aa3c6193a719292d4d226c639c66f91b95", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d391c3e2fba4f444d759d146e5ef6e5326613/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d391c3e2fba4f444d759d146e5ef6e5326613/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=c80d391c3e2fba4f444d759d146e5ef6e5326613", "patch": "@@ -142,7 +142,7 @@ CFILES = alloca.c argv.c asprintf.c atexit.c\t\t\t\t\\\n \t mempcpy.c memset.c mkstemps.c\t\t\t\t\t\\\n \tobjalloc.c obstack.c\t\t\t\t\t\t\\\n \tpartition.c\t\t\t\t\t\t\t\\\n-\t pex-djgpp.c pex-mpw.c pex-msdos.c pex-os2.c\t\t\t\\\n+\t pex-djgpp.c pex-msdos.c pex-os2.c\t\t\t\t\\\n \t pex-unix.c pex-win32.c\t\t\t\t\t\t\\\n          physmem.c putenv.c\t\t\t\t\t\t\\\n \trandom.c regex.c rename.c rindex.c\t\t\t\t\\\n@@ -188,7 +188,7 @@ CONFIGURED_OFILES = ./asprintf.o ./atexit.o\t\t\t\t\\\n \t./index.o ./insque.o\t\t\t\t\t\t\\\n \t./memchr.o ./memcmp.o ./memcpy.o ./memmove.o ./mempcpy.o\t\\\n \t ./memset.o ./mkstemps.o\t\t\t\t\t\\\n-\t./pex-djgpp.o ./pex-mpw.o ./pex-msdos.o ./pex-os2.o\t\t\\\n+\t./pex-djgpp.o ./pex-msdos.o ./pex-os2.o\t\t\t\\\n \t ./pex-unix.o ./pex-win32.o\t\t\t\t\t\\\n \t ./putenv.o\t\t\t\t\t\t\t\\\n \t./random.o ./rename.o ./rindex.o\t\t\t\t\\\n@@ -717,12 +717,6 @@ $(CONFIGURED_OFILES): stamp-picdir\n \telse true; fi\n \t$(COMPILE.c) $(srcdir)/mkstemps.c $(OUTPUT_OPTION)\n \n-./mpw.o: $(srcdir)/mpw.c\n-\tif [ x\"$(PICFLAG)\" != x ]; then \\\n-\t  $(COMPILE.c) $(PICFLAG) $(srcdir)/mpw.c -o pic/$@; \\\n-\telse true; fi\n-\t$(COMPILE.c) $(srcdir)/mpw.c $(OUTPUT_OPTION)\n-\n ./msdos.o: $(srcdir)/msdos.c\n \tif [ x\"$(PICFLAG)\" != x ]; then \\\n \t  $(COMPILE.c) $(PICFLAG) $(srcdir)/msdos.c -o pic/$@; \\\n@@ -756,13 +750,6 @@ $(CONFIGURED_OFILES): stamp-picdir\n \telse true; fi\n \t$(COMPILE.c) $(srcdir)/pex-djgpp.c $(OUTPUT_OPTION)\n \n-./pex-mpw.o: $(srcdir)/pex-mpw.c config.h $(INCDIR)/ansidecl.h \\\n-\t$(INCDIR)/libiberty.h $(srcdir)/pex-common.h\n-\tif [ x\"$(PICFLAG)\" != x ]; then \\\n-\t  $(COMPILE.c) $(PICFLAG) $(srcdir)/pex-mpw.c -o pic/$@; \\\n-\telse true; fi\n-\t$(COMPILE.c) $(srcdir)/pex-mpw.c $(OUTPUT_OPTION)\n-\n ./pex-msdos.o: $(srcdir)/pex-msdos.c config.h $(INCDIR)/ansidecl.h \\\n \t$(INCDIR)/libiberty.h $(srcdir)/pex-common.h \\\n \t$(INCDIR)/safe-ctype.h"}, {"sha": "47fcd70ae6475c2cb1f6587bf336c16293afcf6e", "filename": "libiberty/maint-tool", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80d391c3e2fba4f444d759d146e5ef6e5326613/libiberty%2Fmaint-tool", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80d391c3e2fba4f444d759d146e5ef6e5326613/libiberty%2Fmaint-tool", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmaint-tool?ref=c80d391c3e2fba4f444d759d146e5ef6e5326613", "patch": "@@ -145,7 +145,6 @@ sub undoc {\n \t    next unless /^\\# *define/;\n \t    s/\\# *define *//;\n \t}\n-\tnext if $filename =~ /mpw\\.c/;\n \n \ts/ VPARAMS//;\n \ts/ *\\177.*//;"}, {"sha": "2a21802148d62c1f88738117f39039d73e50b4fc", "filename": "libiberty/mpw-config.in", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f8b151be7017b7fd6e422875210ba5f406e4abe/libiberty%2Fmpw-config.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f8b151be7017b7fd6e422875210ba5f406e4abe/libiberty%2Fmpw-config.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmpw-config.in?ref=7f8b151be7017b7fd6e422875210ba5f406e4abe", "patch": "@@ -1,7 +0,0 @@\n-# MPW configuration fragment for libiberty.\n-\n-Echo '/* config.h.  Generated by mpw-configure.  */'\t > \"{o}\"config.new\n-\n-MoveIfChange \"{o}\"config.new \"{o}\"config.h\n-\n-"}, {"sha": "6f2a5e77b2bd15dde5b683a1bf93eed97ace6535", "filename": "libiberty/mpw-make.sed", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f8b151be7017b7fd6e422875210ba5f406e4abe/libiberty%2Fmpw-make.sed", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f8b151be7017b7fd6e422875210ba5f406e4abe/libiberty%2Fmpw-make.sed", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmpw-make.sed?ref=7f8b151be7017b7fd6e422875210ba5f406e4abe", "patch": "@@ -1,51 +0,0 @@\n-# Sed commands to finish translating libiberty's Unix makefile to MPW syntax.\n-\n-# Comment out a useless thing.\n-/^\\.always\\./s/^/#/\n-\n-# Replace the auto-generated list with the list of what we know we need.\n-s/`cat needed-list`/\"{o}\"alloca.c.o \"{o}\"bcopy.c.o \"{o}\"getpagesize.c.o \"{o}\"insque.c.o \"{o}\"mpw.c.o \"{o}\"strcasecmp.c.o \"{o}\"strdup.c.o \"{o}\"strncasecmp.c.o/\n-\n-# Paste in some desirable definitions.\n-# The default rule here completely replaces the tricky stuff in the Unix\n-# Makefile.in.\n-/^###$/a\\\n-\\\n-HDEFINES = -d NEED_sys_siglist -d NEED_sys_errlist -d NEED_basename -d NEED_strcasecmp -d NEED_strncasecmp\\\n-INCLUDES = -i : -i {INCDIR}: -i {INCDIR}:mpw: -i ::extra-include: -i \"{s}\"\\\n-\\\n-.c.o \\\\Option-f .c\\\n-\t{CC} @DASH_C_FLAG@ {DepDir}{Default}.c {LIBCFLAGS} {INCLUDES} {HDEFINES} @SEGMENT_FLAG({Default})@ -o {TargDir}{Default}.c.o\\\n-\n-# Remove dependency on needed-list, which we don't use.\n-/DO_ALSO =/s/needed-list//\n-\n-/INCDIR=/s/\"{srcdir}\"{MULTISRCTOP}::/\"{topsrcdir}\"/\n-\n-# Whack out the COMPILE.c trickiness.\n-/^COMPILE.c /,/^$/d\n-\n-# Remove the multido trickiness from the \"all\" target.\n-/^all \\\\Option-f/,/^$/c\\\n-all \\\\Option-f {TARGETLIB}\\\n-\n-\n-# Remove the RULE1/RULE2 crud.\n-/if \\[/,/fi/d\n-/^RULE1 =/,/RULE2 =/d\n-/RULE2/s/RULE2/TARGETLIB/\n-\n-# Don't want fdmatch ever.\n-s/ \"{o}\"fdmatch.c.o//\n-\n-# Fix paths to generated files.\n-/config.h/s/\"{s}\"config.h/\"{o}\"config.h/\n-\n-# Whack out config rebuild rules.\n-/^\"{o}\"config.h \\\\Option-f/,/^$/d\n-\n-\n-\n-\n-\n-"}, {"sha": "ca3ae412d25c1612f33138a47d7737a88ddcf39f", "filename": "libiberty/mpw.c", "status": "removed", "additions": 0, "deletions": 1010, "changes": 1010, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f8b151be7017b7fd6e422875210ba5f406e4abe/libiberty%2Fmpw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f8b151be7017b7fd6e422875210ba5f406e4abe/libiberty%2Fmpw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmpw.c?ref=7f8b151be7017b7fd6e422875210ba5f406e4abe", "patch": "@@ -1,1010 +0,0 @@\n-/* MPW-Unix compatibility library.\n-   Copyright (C) 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n-\n-This file is part of the libiberty library.\n-Libiberty is free software; you can redistribute it and/or\n-modify it under the terms of the GNU Library General Public\n-License as published by the Free Software Foundation; either\n-version 2 of the License, or (at your option) any later version.\n-\n-Libiberty is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-Library General Public License for more details.\n-\n-You should have received a copy of the GNU Library General Public\n-License along with libiberty; see the file COPYING.LIB.  If\n-not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* This should only be compiled and linked under MPW. */\n-\n-#include \"mpw.h\"\n-\n-#include <stdlib.h>\n-\n-#ifndef USE_MW_HEADERS\n-#include <sys/time.h>\n-#include <sys/resource.h>\n-#endif\n-\n-#include <Types.h>\n-#include <Files.h>\n-\n-#include <Timer.h>\n-\n-/* Initialize to 0 at first, then set to errno_max() later.  */\n-\n-int sys_nerr = 0;\n-\n-/* Debug flag for pathname hacking.  Set this to one and rebuild. */\n-\n-int DebugPI = -1;\n-\n-void\n-mpwify_filename(char *unixname, char *macname)\n-{\n-  int i, j;\n-\n-  /* (should truncate 255 chars from end of name, not beginning) */\n-  if (strlen (unixname) > 255)\n-    {\n-      fprintf (stderr, \"Pathname \\\"%s\\\" is too long for Macs, truncating\\n\",\n-\t       unixname);\n-    }\n-  j = 0;\n-  /* If you're going to end up with one or more colons in the middle of a\n-     path after an all-Unix relative path is translated, you must add a\n-     colon on the front, so that the first component is not thought to be\n-     a disk name.  */\n-  if (unixname[0] != '/' && ! strchr (unixname, ':') && strchr (unixname, '/'))\n-    {\n-      macname[j++] = ':';\n-    }\n-  for (i = 0; unixname[i] != '\\0' && i < 255; ++i)\n-    {\n-      if (i == 0 && unixname[i] == '/')\n-\t{\n-\t  if (strncmp (unixname, \"/tmp/\", 5) == 0)\n-\t    {\n-\t      /* A temporary name, make a more Mac-flavored tmpname. */\n-\t      /* A better choice would be {Boot}Trash:foo, but\n-\t\t that would require being able to identify the\n-\t\t boot disk's and trashcan's name.  Another option\n-\t\t would be to have an env var, so user can point it\n-\t\t at a ramdisk. */\n-\t      macname[j++] = ':';\n-\t      macname[j++] = 't';\n-\t      macname[j++] = 'm';\n-\t      macname[j++] = 'p';\n-\t      macname[j++] = '_';\n-\t      i += 4;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Don't copy the leading slash. */\n-\t    }\n-\t}\n-      else if (unixname[i] == ':' && unixname[i+1] == '/')\n-\t{\n-\t  macname[j++] = ':';\n-\t  i += 1;\n-\t}\n-      else if (unixname[i] == '.' && unixname[i+1] == '/')\n-\t{\n-\t  macname[j++] = ':';\n-\t  i += 1;\n-\t}\n-      else if (unixname[i] == '.' && unixname[i+1] == '.' && unixname[i+2] == '/')\n-\t{\n-\t  macname[j++] = ':';\n-\t  macname[j++] = ':';\n-\t  i += 2;\n-\t}\n-      else if (unixname[i] == '/')\n-\t{\n-\t  macname[j++] = ':';\n-\t}\n-      else\n-\t{\n-\t  macname[j++] = unixname[i];\n-\t}\n-    }\n-  macname[j] = '\\0';\n-  /* Allow for getting the debug flag from an env var; quite useful. */\n-  if (DebugPI < 0)\n-    DebugPI = (*(getenv (\"DEBUG_PATHNAMES\")) == '1' ? 1 : 0);\n-  if (DebugPI)\n-    {\n-      fprintf (stderr, \"# Made \\\"%s\\\"\\n\", unixname);\n-      fprintf (stderr, \"# into \\\"%s\\\"\\n\", macname);\n-    }\n-}\n-\n-/* MPW-flavored basename finder. */\n-\n-char *\n-mpw_basename (name)\n-  char *name;\n-{\n-  char *base = name;\n-\n-  while (*name)\n-    {\n-      if (*name++ == ':')\n-\t{\n-\t  base = name;\n-\t}\n-    }\n-  return base;\n-}\n-\n-/* Mixed MPW/Unix basename finder.  This can be led astray by\n-   filenames with slashes in them and come up with a basename that\n-   either corresponds to no file or (worse) to some other file, so\n-   should only be tried if other methods of finding a file via a\n-   basename have failed.  */\n-\n-char *\n-mpw_mixed_basename (name)\n-  char *name;\n-{\n-  char *base = name;\n-\n-  while (*name)\n-    {\n-      if (*name == '/' || *name == ':')\n-\t{\n-\t  base = name + 1;\n-\t}\n-      ++name;\n-    }\n-  return base;\n-}\n-\n-/* This function is fopen() modified to create files that are type TEXT\n-   or 'BIN ', and always of type 'MPS '.  */\n-\n-FILE *\n-mpw_fopen (char *name, char *mode)\n-{\n-#undef fopen\n-  int errnum;\n-  FILE *fp;\n-  char tmpname[256];\n-\n-  mpwify_filename (name, tmpname);\n-  PROGRESS (1);\n-  fp = fopen (tmpname, mode);\n-  errnum = errno;\n-\n-  /* If writing, need to set type and creator usefully. */\n-  if (strchr (mode, 'w'))\n-    {\n-      char *pname = (char *) malloc (strlen (tmpname) + 2);\n-      OSErr e;\n-      struct FInfo fi;\n-\n-      pname[0] = strlen (tmpname);\n-      strcpy (pname+1, tmpname);\n-\t\n-      e = GetFInfo ((ConstStr255Param) pname, 0, &fi);\n-      /* should do spiffier error handling */\n-      if (e != 0)\n-\tfprintf(stderr, \"GetFInfo returns %d\\n\", e);\n-      if (strchr (mode, 'b'))\n-\t{\n-\t  fi.fdType = (OSType) 'BIN ';\n-\t}\n-      else\n-\t{\n-\t  fi.fdType = (OSType) 'TEXT';\n-\t}\n-      fi.fdCreator = (OSType) 'MPS ';\n-      e = SetFInfo ((ConstStr255Param) pname, 0, &fi);\n-      if (e != 0)\n-\tfprintf(stderr, \"SetFInfo returns %d\\n\", e);\n-      free (pname);\n-    }\n-  if (fp == NULL)\n-    errno = errnum;\n-  return fp;\n-}\n-\n-/* This is a version of fseek() modified to fill the file with zeros\n-   if seeking past the end of it.  */\n-\n-#define ZEROBLKSIZE 4096\n-\n-char zeros[ZEROBLKSIZE];\n-\n-int\n-mpw_fseek (FILE *fp, int offset, int whence)\n-{\n-#undef fseek\n-  int cursize, numleft;\n-\n-  PROGRESS (1);\n-  if (whence == SEEK_SET)\n-    {\n-      fseek (fp, 0, SEEK_END);\n-      cursize = ftell (fp);\n-      if (offset > cursize)\n-\t{\n-\t  numleft = offset - cursize;\n-\t  while (numleft > ZEROBLKSIZE)\n-\t    {\n-\t      /* This might fail, should check for that. */\n-\t      PROGRESS (1);\n-\t      fwrite (zeros, 1, ZEROBLKSIZE, fp);\n-\t      numleft -= ZEROBLKSIZE;\n-\t    }\n-\t  PROGRESS (1);\n-\t  fwrite (zeros, 1, numleft, fp);\n-\t  fflush (fp);\n-\t}\n-    }\n-  return fseek (fp, offset, whence);\n-}\n-\n-int\n-mpw_fread (char *ptr, int size, int nitems, FILE *stream)\n-{\n-#undef fread\n-  int rslt;\n-\n-  PROGRESS (1);\n-  rslt = fread (ptr, size, nitems, stream);\n-  PROGRESS (1);\n-  return rslt;\n-}\n-\n-int\n-mpw_fwrite (char *ptr, int size, int nitems, FILE *stream)\n-{\n-#undef fwrite\n-  int rslt;\n-\n-  PROGRESS (1);\n-  rslt = fwrite (ptr, size, nitems, stream);\n-  PROGRESS (1);\n-  return rslt;\n-}\n-\n-int\n-link ()\n-{\n-  fprintf (stderr, \"link not available!\\n\");\n-  mpw_abort ();\n-}\n-\n-int\n-fork ()\n-{\n-  fprintf (stderr, \"fork not available!\\n\");\n-  mpw_abort ();\n-}\n-\n-int\n-vfork ()\n-{\n-  fprintf (stderr, \"vfork not available!\\n\");\n-  mpw_abort ();\n-  return (-1);\n-}\n-\n-int\n-pipe (int *fd)\n-{\n-  fprintf (stderr, \"pipe not available!\\n\");\n-  mpw_abort ();\n-  return (-1);\n-}\n-\n-#ifndef USE_MW_HEADERS\n-int\n-execvp (char *file, char **argv)\n-{\n-  fprintf (stderr, \"execvp not available!\\n\");\n-  mpw_abort ();\n-  return (-1);\n-}\n-\n-int\n-execv (char *path, char **argv)\n-{\n-  fprintf (stderr, \"execv not available!\\n\");\n-  mpw_abort ();\n-  return (-1);\n-}\n-#endif\n-\n-int\n-kill (int pid, int sig)\n-{\n-  fprintf (stderr, \"kill not available!\\n\");\n-  mpw_abort ();\n-  return (-1);\n-}\n-\n-int\n-wait (int *status)\n-{\n-  *status = 0;\n-  return 0;\n-}\n-\n-#ifndef USE_MW_HEADERS\n-int\n-sleep (int seconds)\n-{\n-  unsigned long start_time, now;\n-\n-  time (&start_time);\n-\n-  while (1)\n-    {\n-      PROGRESS (1);\n-      time (&now);\n-      if (now > start_time + seconds)\n-\treturn 0;\n-    }\n-}\n-#endif\n-\n-void\n-putenv (char *str)\n-{\n-  /* The GCC driver calls this to do things for collect2, but we\n-     don't care about collect2. */\n-}\n-\n-int\n-chmod (char *path, int mode)\n-{\n-  /* Pretend it was all OK. */\n-  return 0;\n-}\n-\n-#ifndef USE_MW_HEADERS\n-int\n-getuid ()\n-{\n-  /* One value is as good as another... */\n-  return 0;\n-}\n-\n-int\n-getgid ()\n-{\n-  /* One value is as good as another... */\n-  return 0;\n-}\n-#endif\n-\n-/* Instead of coredumping, which is not a normal Mac facility, we\n-   drop into Macsbug.  If we then \"g\" from Macsbug, the program will\n-   exit cleanly. */\n-\n-void\n-mpw_abort ()\n-{\n-  /* Make sure no output still buffered up, then zap into MacsBug. */\n-  fflush(stdout);\n-  fflush(stderr);\n-  printf(\"## Abort! ##\\n\");\n-#ifdef MPW_SADE\n-  SysError(8005);\n-#else \n-  Debugger();\n-#endif\n-  /* \"g\" in MacsBug will then cause a regular error exit. */\n-  exit (1);\n-}\n-\n-/* Imitation getrusage based on the ANSI clock() function. */\n-\n-int\n-getrusage (int who, struct rusage *rusage)\n-{\n-  int clk = clock ();\n-\n-#if 0\n-  rusage->ru_utime.tv_sec = clk / CLOCKS_PER_SEC;\n-  rusage->ru_utime.tv_usec = ((clk * 1000) / CLOCKS_PER_SEC) * 1000;\n-  rusage->ru_stime.tv_sec = 0;\n-  rusage->ru_stime.tv_usec = 0;\n-#endif\n-}\n-\n-int\n-sbrk ()\n-{\n-  return 0;\n-}\n-\n-#ifndef USE_MW_HEADERS\n-int\n-isatty (int fd)\n-{\n-  return 0;\n-}\n-\n-/* This is inherited from Timothy Murray's Posix library. */\n-\n-#include \"utime.h\"\n-\n-int\n-utime (char *filename, struct utimbuf *times)\n-{\n-  CInfoPBRec cipbr;\n-  HFileInfo *fpb = (HFileInfo *) &cipbr;\n-  DirInfo *dpb = (DirInfo *) &cipbr;\n-  unsigned char pname[256];\n-  short err;\n-  \n-  strcpy ((char *) pname, filename);\n-  c2pstr (pname);\n-\n-  dpb->ioDrDirID = 0L;\n-  fpb->ioNamePtr = pname;\n-  fpb->ioVRefNum = 0;\n-  fpb->ioFDirIndex = 0;\n-  fpb->ioFVersNum = 0;\n-  err = PBGetCatInfo (&cipbr, 0);\n-  if (err != noErr) {\n-    errno = ENOENT;\n-    return -1;\n-  }\n-  dpb->ioDrDirID = 0L;\n-  fpb->ioFlMdDat = times->modtime;\n-  fpb->ioFlCrDat = times->actime;\n-  err = PBSetCatInfo (&cipbr, 0);\n-  if (err != noErr) {\n-    errno = EACCES;\n-    return -1;\n-  }\n-  return 0;\n-}\n-\n-int\n-mkdir (char *path, int mode)\n-{\n-  errno = ENOSYS;\n-  return -1;\n-}\n-\n-int\n-rmdir ()\n-{\n-  errno = ENOSYS;\n-  return -1;\n-}\n-#endif\n-\n-chown ()\n-{\n-  errno = ENOSYS;\n-  return -1;\n-}\n-\n-char *myenviron[] = {NULL};\n-\n-char **environ = myenviron;\n-\n-#ifndef USE_MW_HEADERS\n-\n-/* Minimal 'stat' emulation: tells directories from files and\n-   gives length and mtime.\n-\n-   Derived from code written by Guido van Rossum, CWI, Amsterdam\n-   and placed by him in the public domain.  */\n-\n-extern int __uid, __gid;\n-\n-int __uid = 0;\n-int __gid = 0;\n-\n-/* Bits in ioFlAttrib: */\n-#define LOCKBIT\t(1<<0)\t\t/* File locked */\n-#define DIRBIT\t(1<<4)\t\t/* It's a directory */\n-\n-/* Macified \"stat\" in which filename is given relative to a directory,\n-   specified by long DirID.  */\n-\n-static int\n-_stat (char *name, long dirid, struct stat *buf)\n-{\n-  CInfoPBRec cipbr;\n-  HFileInfo *fpb = (HFileInfo*) &cipbr;\n-  DirInfo *dpb = (DirInfo*) &cipbr;\n-  Str255 pname;\n-  short err;\n-\n-  /* Make a temp copy of the name and pascalize. */\n-  strcpy ((char *) pname, name);\n-  c2pstr (pname);\n-  \n-  cipbr.dirInfo.ioDrDirID = dirid;\n-  cipbr.hFileInfo.ioNamePtr = pname;\n-  cipbr.hFileInfo.ioVRefNum = 0;\n-  cipbr.hFileInfo.ioFDirIndex = 0;\n-  cipbr.hFileInfo.ioFVersNum = 0;\n-  err = PBGetCatInfo (&cipbr, 0);\n-  if (err != noErr)\n-    {\n-      errno = ENOENT;\n-      return -1;\n-    }\n-  /* Mac files are readable if they can be accessed at all. */\n-  buf->st_mode = 0444;\n-  /* Mark unlocked files as writeable. */\n-  if (!(fpb->ioFlAttrib & LOCKBIT))\n-    buf->st_mode |= 0222;\n-  if (fpb->ioFlAttrib & DIRBIT)\n-    {\n-      /* Mark directories as \"executable\". */\n-      buf->st_mode |= 0111 | S_IFDIR;\n-      buf->st_size = dpb->ioDrNmFls;\n-      buf->st_rsize = 0;\n-    }\n-  else\n-    {\n-      buf->st_mode |= S_IFREG;\n-      /* Mark apps as \"executable\". */\n-      if (fpb->ioFlFndrInfo.fdType == 'APPL')\n-\tbuf->st_mode |= 0111;\n-      /* Fill in the sizes of data and resource forks. */\n-      buf->st_size = fpb->ioFlLgLen;\n-      buf->st_rsize = fpb->ioFlRLgLen;\n-    }\n-  /* Fill in various times. */\n-  buf->st_atime = fpb->ioFlCrDat;\n-  buf->st_mtime = fpb->ioFlMdDat;\n-  buf->st_ctime = fpb->ioFlCrDat;\n-  /* Set up an imitation inode number. */\n-  buf->st_ino = (unsigned short) fpb->ioDirID;\n-  /* Set up an imitation device. */\n-  GetVRefNum (buf->st_ino, &buf->st_dev);\n-  buf->st_uid = __uid;\n-  buf->st_gid = __gid;\n-/*  buf->st_FlFndrInfo = fpb->ioFlFndrInfo;  */\n-  return 0;\n-}\n-\n-/* stat() sets up an empty dirid. */\n-\n-int\n-stat (char *path, struct stat *buf)\n-{\n-  long rslt, errnum;\n-  char tmpname[256];\n-\n-  mpwify_filename (path, tmpname);\n-  if (DebugPI)\n-    fprintf (stderr, \"# stat (%s, %x)\", tmpname, buf);\n-  PROGRESS (1);\n-  rslt = _stat (tmpname, 0L, buf);\n-  errnum = errno;\n-  if (DebugPI)\n-    {\n-      fprintf (stderr, \" -> %d\", rslt);\n-      if (rslt != 0)\n-\tfprintf (stderr, \" (errno is %d)\", errnum);\n-      fprintf (stderr, \"\\n\");\n-      fflush (stderr);\n-    }\n-  if (rslt != 0)\n-    errno = errnum;\n-  return rslt;\n-}\n-\n-int\n-fstat (int fd, struct stat *buf)\n-{\n-  FCBPBRec fcb;\n-  FILE *fp;\n-  Str255 pathname;\n-  long dirid = 0L, temp;\n-  long rslt, errnum;\n-  short err;\n-\n-  if (DebugPI < 0)\n-    DebugPI = (*(getenv (\"DEBUG_PATHNAMES\")) == '1' ? 1 : 0);\n-  if (DebugPI)\n-    fprintf (stderr, \"# fstat (%d, %x)\", fd, buf);\n-  PROGRESS (1);\n-  pathname[0] = 0;\n-#ifdef FIOFNAME\n-  /* Use an MPW-specific ioctl to get the pathname associated with\n-     the file descriptor.  */\n-  ioctl (fd, FIOFNAME, (long *) pathname); \n-#else\n-  you lose\n-#endif\n-  if (DebugPI)\n-    fprintf (stderr, \" (name is %s)\", pathname);\n-  dirid = 0L /* fcb.ioFCBParID */ ;\n-  rslt = _stat ((char *) pathname, dirid, buf);\n-  errnum = errno;\n-  if (DebugPI)\n-    {\n-      fprintf (stderr, \" -> %d\", rslt);\n-      if (rslt != 0)\n-\tfprintf (stderr, \" (errno is %d)\", errnum);\n-      fprintf (stderr, \"\\n\");\n-      fflush (stderr);\n-    }\n-  if (rslt != 0)\n-    errno = errnum;\n-  return rslt;\n-}\n-\n-#endif /* n USE_MW_HEADERS */\n-\n-chdir ()\n-{\n-  errno = ENOSYS;\n-  return (-1);\n-}\n-\n-char *\n-getcwd (char *buf, int size)\n-{\n-  if (buf == NULL)\n-    buf = (char *) malloc (size);\n-  strcpy(buf, \":\");\n-  return buf;\n-}\n-\n-/* This should probably be more elaborate for MPW. */\n-\n-char *\n-getpwd ()\n-{\n-  return \":\";\n-}\n-\n-int\n-mpw_open (char *filename, int arg2, int arg3)\n-{\n-#undef open\n-  int fd, errnum = 0;\n-  char tmpname[256];\n-\n-  mpwify_filename (filename, tmpname);\n-  fd = open (tmpname, arg2);\n-  errnum = errno;\n-\n-  if (DebugPI)\n-    {\n-      fprintf (stderr, \"# open (%s, %d, %d)\", tmpname, arg2, arg3);\n-      fprintf (stderr, \" -> %d\", fd);\n-      if (fd == -1)\n-\tfprintf (stderr, \" (errno is %d)\", errnum);\n-      fprintf (stderr, \"\\n\");\n-    }\n-  if (fd == -1)\n-    errno = errnum;\n-  return fd;\n-}\n-\n-int\n-mpw_access (char *filename, unsigned int cmd)\n-{\n-#undef access\n-\n-  int rslt, errnum = 0;\n-  struct stat st;\n-  char tmpname[256];\n-\n-  mpwify_filename (filename, tmpname);\n-  if (cmd & R_OK || cmd & X_OK)\n-    {\n-      rslt = stat (tmpname, &st);\n-      errnum = errno;\n-      if (rslt >= 0)\n-\t{\n-\t  if ((((st.st_mode & 004) == 0) && (cmd & R_OK))\n-\t      || (((st.st_mode & 002) == 0) && (cmd & W_OK))\n-\t      || (((st.st_mode & 001) == 0) && (cmd & X_OK)))\n-\t    {\n-\t      rslt = -1;\n-\t      errnum = EACCES;\n-\t    }\n-\t}\n-    }\n-  if (DebugPI)\n-    {\n-      fprintf (stderr, \"# mpw_access (%s, %d)\", tmpname, cmd);\n-      fprintf (stderr, \" -> %d\", rslt);\n-      if (rslt != 0)\n-\tfprintf (stderr, \" (errno is %d)\", errnum);\n-      fprintf (stderr, \"\\n\");\n-    }\n-  if (rslt != 0)\n-    errno = errnum;\n-  return rslt;\n-}\n-\n-/* The MPW library creat() has no mode argument. */\n-\n-int\n-mpw_creat (char *path, /* mode_t */ int mode)\n-{\n-#undef creat\n-\n-#ifdef USE_MW_HEADERS\n-  return creat (path, mode);\n-#else\n-  return creat (path);\n-#endif\n-}\n-\n-/* This is a hack to get control in an MPW tool before it crashes the\n-   machine.  */\n-\n-mpw_special_init (name)\n-     char *name;\n-{\n-  if (strstr (name, \"DEBUG\"))\n-    DebugStr(\"\\pat beginning of program\");\n-}\n-\n-static int current_umask;\n-\n-int\n-umask(int mask)\n-{\n-  int oldmask = current_umask;\n-\n-  current_umask = mask;\n-  return oldmask;\n-}\n-\n-/* Cursor-spinning stuff that includes metering of spin rate and delays.  */\n-\n-/* Nonzero when cursor spinning has been set up properly.  */\n-\n-int cursor_inited;\n-\n-/* Nonzero if spin should be measured and excessive delays reported.  */\n-\n-int measure_spin;\n-\n-/* Nonzero if spin histogram and rate data should be written out.  */\n-\n-int dump_spin_data;\n-\n-long warning_threshold = 400000;\n-\n-long bucket_size = 1024;\n-\n-long bucket_power = 10;\n-\n-long numbuckets = 300;\n-\n-int *delay_counts;\n-\n-int overflow_count;\n-\n-char *current_progress;\n-\n-static UnsignedWide last_microseconds;\n-\n-static char *last_spin_file = \"\";\n-\n-static int last_spin_line;\n-\n-void\n-warn_if_spin_delay (char *file, int line)\n-{\n-  long diff, ix;\n-  UnsignedWide now;\n-\n-  Microseconds(&now);\n-\n-  diff = now.lo - last_microseconds.lo;\n-\n-  if (diff > warning_threshold)\n-    fprintf (stderr, \"# %s: %ld.%06ld sec delay getting from %s:%d to %s:%d\\n\",\n-\t     (current_progress ? current_progress : \"\"),\n-\t     diff / 1000000, diff % 1000000,\n-\t     last_spin_file, last_spin_line, file, line);\n-  if (dump_spin_data)\n-    {\n-      if (diff >= 0)\n-\t{\n-\t  ix = diff >> bucket_power;\n-\t  if (ix >= 0 && ix < numbuckets && delay_counts != NULL)\n-\t    ++delay_counts[ix];\n-\t  else\n-\t    ++overflow_count;\n-\t}\n-      else\n-\tfprintf (stderr, \"raw diff is %ld (?)\\n\", diff);\n-    }\n-}\n-\n-void\n-record_for_spin_delay (char *file, int line)\n-{\n-  Microseconds (&last_microseconds);\n-  last_spin_file = file;\n-  last_spin_line = line;\n-}\n-\n-void\n-mpw_start_progress (char *str, int n, char *file, int line)\n-{\n-  int i;\n-  char *measure, *threshold;\n-\n-  if (!cursor_inited)\n-    {\n-      InitCursorCtl (nil);\n-      cursor_inited = 1;\n-      record_for_spin_delay (file, line);\n-      measure = getenv (\"MEASURE_SPIN\");\n-      if (measure != NULL && measure[0] != '\\0')\n-\t{\n-\t  measure_spin = 1;\n-\t  if (strcmp (measure, \"all\") == 0)\n-\t    dump_spin_data = 1;\n-\t}\n-      threshold = getenv (\"SPIN_WARN_THRESHOLD\");\n-      if (threshold != NULL && threshold[0] != '\\0')\n-\twarning_threshold = atol (threshold);\n-      if (dump_spin_data)\n-\t{\n-\t  if (delay_counts == NULL)\n-\t    delay_counts = (int *) malloc (numbuckets * sizeof (int));\n-\t  for (i = 0; i < numbuckets; ++i)\n-\t    delay_counts[i] = 0;\n-\t  overflow_count = 0;\n-\t}\n-    }\n-  current_progress = str;\n-\n-  sys_nerr = errno_max ();\n-\n-  mpw_special_init (str);\n-}\n-\n-void\n-mpw_progress (int n)\n-{\n-  SpinCursor (32);\n-}\n-\n-void\n-mpw_progress_measured (int n, char *file, int line)\n-{\n-  if (measure_spin)\n-    warn_if_spin_delay (file, line);\n-  SpinCursor (32);\n-  if (measure_spin)\n-    record_for_spin_delay (file, line);\n-}\n-\n-void\n-mpw_end_progress (char *str, char *file, int line)\n-{\n-  long i, delay, count = 0, sum = 0, avgdelay, spinrate;\n-  long curpower = 0, curgroup = 0;\n-\n-  /* Warn if it's been a while since the last spin.  */\n-  if (measure_spin)\n-    warn_if_spin_delay (file, line);\n-\n-  /* Dump all the nonzero delay counts and an approximation of the delay.  */\n-  if (dump_spin_data && delay_counts != NULL)\n-    {\n-      for (i = 0; i < numbuckets; ++i)\n-\t{\n-\t  delay = (i + 1) * bucket_size;\n-\t  sum += delay_counts[i] * (i + 1);\n-\t  count += delay_counts[i];\n-\t  if (delay <= (1 << curpower))\n-\t    {\n-\t      curgroup += delay_counts[i];\n-\t    }\n-\t  else\n-\t    {\n-\t      if (curgroup > 0)\n-\t\tfprintf (stderr,\n-\t\t\t \"# %s: %d delays between %ld.%06ld and %ld.%06ld sec\\n\",\n-\t\t\t (str ? str : \"\"),\n-\t\t\t curgroup,\n-\t\t\t (1 << curpower) / 1000000,\n-\t\t\t (1 << curpower) % 1000000,\n-\t\t\t (1 << (curpower + 1)) / 1000000,\n-\t\t\t (1 << (curpower + 1)) % 1000000);\n-\t      ++curpower;\n-\t      curgroup = 0;\n-\t    }\n-\t}\n-      if (count > 0)\n-\t{\n-\t  avgdelay = (sum * bucket_size) / count;\n-\t  spinrate = 1000000 / avgdelay;\n-\t  fprintf (stderr, \"# %s: Average spin rate is %d times/sec\\n\",\n-\t\t   (str ? str : \"\"), spinrate);\n-\t}\n-    }\n-}\n-\n-#ifdef PROGRESS_TEST\n-\n-/* Test program.  */\n-\n-main ()\n-{\n-  int i, j;\n-  double x = 1.0, y = 2.4;\n-  long start = Microseconds (), tm;  FIXME\n-\n-  START_PROGRESS (\"hi\", 0);\n-\n-  for (i = 0; i < 1000; ++i)\n-    {\n-      PROGRESS (1);\n-\n-      for (j = 0; j < (i * 100); ++j)\n-\t{\n-\t  x += (x * y) / j;\n-\t}\n-    }\n-  \n-  END_PROGRESS (\"hi\");\n-  \n-  tm = Microseconds () - start;\n-\n-  printf (\"Total time is %d.%d secs\\n\", tm / 1000000, tm % 1000000);\n-}\n-\n-#endif\n-\n-#ifdef USE_MW_HEADERS\n-/* Empty definitions for Metrowerks' SIOUX console library. */\n-\n-#ifndef __CONSOLE__\n-#include <console.h>\n-#endif\n-\n-short\n-InstallConsole(short fd)\n-{\n-#pragma unused (fd)\n-\treturn 0;\n-}\n-\n-void\n-RemoveConsole(void)\n-{\n-}\n-\n-long\n-WriteCharsToConsole(char *buf, long n)\n-{\n-#pragma unused (buf, n)\n-\treturn 0;\n-}\n-\n-long ReadCharsFromConsole(char *buf, long n)\n-{\n-#pragma unused (buf, n)\n-\treturn 0;\n-}\n-\n-extern char *\n-__ttyname(long fd)\n-{\n-\tstatic char *__devicename = \"null device\";\n-\n-\tif (fd >= 0 && fd <= 2)\n-\t  return (__devicename);\n-\treturn NULL;\n-}\n-\n-#endif"}, {"sha": "9a8879c9b271e30201e698abe5e75104bf2453a9", "filename": "libiberty/pex-mpw.c", "status": "removed", "additions": 0, "deletions": 161, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f8b151be7017b7fd6e422875210ba5f406e4abe/libiberty%2Fpex-mpw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f8b151be7017b7fd6e422875210ba5f406e4abe/libiberty%2Fpex-mpw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-mpw.c?ref=7f8b151be7017b7fd6e422875210ba5f406e4abe", "patch": "@@ -1,161 +0,0 @@\n-/* Utilities to execute a program in a subprocess (possibly linked by pipes\n-   with other subprocesses), and wait for it.  MPW specialization.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003\n-   Free Software Foundation, Inc.\n-\n-This file is part of the libiberty library.\n-Libiberty is free software; you can redistribute it and/or\n-modify it under the terms of the GNU Library General Public\n-License as published by the Free Software Foundation; either\n-version 2 of the License, or (at your option) any later version.\n-\n-Libiberty is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-Library General Public License for more details.\n-\n-You should have received a copy of the GNU Library General Public\n-License along with libiberty; see the file COPYING.LIB.  If not,\n-write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"pex-common.h\"\n-\n-#include <stdio.h>\n-#ifdef HAVE_STRING_H\n-#include <string.h>\n-#endif\n-\n-/* MPW pexecute doesn't actually run anything; instead, it writes out\n-   script commands that, when run, will do the actual executing.\n-\n-   For example, in GCC's case, GCC will write out several script commands:\n-\n-   cpp ...\n-   cc1 ...\n-   as ...\n-   ld ...\n-\n-   and then exit.  None of the above programs will have run yet.  The task\n-   that called GCC will then execute the script and cause cpp,etc. to run.\n-   The caller must invoke pfinish before calling exit.  This adds\n-   the finishing touches to the generated script.  */\n-\n-static int first_time = 1;\n-\n-extern void mpwify_filename PARAMS ((const char *, char *));\n-\n-int\n-pexecute (program, argv, this_pname, temp_base, errmsg_fmt, errmsg_arg, flags)\n-     const char *program;\n-     char * const *argv;\n-     const char *this_pname;\n-     const char *temp_base;\n-     char **errmsg_fmt, **errmsg_arg;\n-     int flags;\n-{\n-  char tmpprogram[255];\n-  char *cp, *tmpname;\n-  int i;\n-\n-  mpwify_filename (program, tmpprogram);\n-  if (first_time)\n-    {\n-      printf (\"Set Failed 0\\n\");\n-      first_time = 0;\n-    }\n-\n-  fputs (\"If {Failed} == 0\\n\", stdout);\n-  /* If being verbose, output a copy of the command.  It should be\n-     accurate enough and escaped enough to be \"clickable\".  */\n-  if (flags & PEXECUTE_VERBOSE)\n-    {\n-      fputs (\"\\tEcho \", stdout);\n-      fputc ('\\'', stdout);\n-      fputs (tmpprogram, stdout);\n-      fputc ('\\'', stdout);\n-      fputc (' ', stdout);\n-      for (i=1; argv[i]; i++)\n-\t{\n-\t  fputc ('\\'', stdout);\n-\t  /* See if we have an argument that needs fixing.  */\n-\t  if (strchr(argv[i], '/'))\n-\t    {\n-\t      tmpname = (char *) xmalloc (256);\n-\t      mpwify_filename (argv[i], tmpname);\n-\t      argv[i] = tmpname;\n-\t    }\n-\t  for (cp = argv[i]; *cp; cp++)\n-\t    {\n-\t      /* Write an Option-d escape char in front of special chars.  */\n-\t      if (strchr(\"'+\", *cp))\n-\t\tfputc ('\\266', stdout);\n-\t      fputc (*cp, stdout);\n-\t    }\n-\t  fputc ('\\'', stdout);\n-\t  fputc (' ', stdout);\n-\t}\n-      fputs (\"\\n\", stdout);\n-    }\n-  fputs (\"\\t\", stdout);\n-  fputs (tmpprogram, stdout);\n-  fputc (' ', stdout);\n-\n-  for (i=1; argv[i]; i++)\n-    {\n-      /* See if we have an argument that needs fixing.  */\n-      if (strchr(argv[i], '/'))\n-\t{\n-\t  tmpname = (char *) xmalloc (256);\n-\t  mpwify_filename (argv[i], tmpname);\n-\t  argv[i] = tmpname;\n-\t}\n-      if (strchr (argv[i], ' '))\n-\tfputc ('\\'', stdout);\n-      for (cp = argv[i]; *cp; cp++)\n-\t{\n-\t  /* Write an Option-d escape char in front of special chars.  */\n-\t  if (strchr(\"'+\", *cp))\n-\t    fputc ('\\266', stdout);\n-\t  fputc (*cp, stdout);\n-\t}\n-      if (strchr (argv[i], ' '))\n-\tfputc ('\\'', stdout);\n-      fputc (' ', stdout);\n-    }\n-\n-  fputs (\"\\n\", stdout);\n-\n-  /* Output commands that arrange to clean up and exit if a failure occurs.\n-     We have to be careful to collect the status from the program that was\n-     run, rather than some other script command.  Also, we don't exit\n-     immediately, since necessary cleanups are at the end of the script.  */\n-  fputs (\"\\tSet TmpStatus {Status}\\n\", stdout);\n-  fputs (\"\\tIf {TmpStatus} != 0\\n\", stdout);\n-  fputs (\"\\t\\tSet Failed {TmpStatus}\\n\", stdout);\n-  fputs (\"\\tEnd\\n\", stdout);\n-  fputs (\"End\\n\", stdout);\n-\n-  /* We're just composing a script, can't fail here.  */\n-  return 0;\n-}\n-\n-int\n-pwait (pid, status, flags)\n-     int pid;\n-     int *status;\n-     int flags;\n-{\n-  *status = 0;\n-  return 0;\n-}\n-\n-/* Write out commands that will exit with the correct error code\n-   if something in the script failed.  */\n-\n-void\n-pfinish ()\n-{\n-  printf (\"\\tExit \\\"{Failed}\\\"\\n\");\n-}\n-"}]}