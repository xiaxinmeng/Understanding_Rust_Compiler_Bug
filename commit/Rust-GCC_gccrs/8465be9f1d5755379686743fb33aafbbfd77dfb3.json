{"sha": "8465be9f1d5755379686743fb33aafbbfd77dfb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ2NWJlOWYxZDU3NTUzNzk2ODY3NDNmYjMzYWFmYmJmZDc3ZGZiMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-05-30T18:36:24Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-05-30T18:36:24Z"}, "message": "asan_test.C: Add -std=c++11 and -DSANITIZER_USE_DEJAGNU_GTEST=1 to dg-options...\n\n\t* g++.dg/asan/asan_test.C: Add -std=c++11 and\n\t-DSANITIZER_USE_DEJAGNU_GTEST=1 to dg-options, remove\n\t-DASAN_USE_DEJAGNU_GTEST=1.\n\t* g++.dg/asan/asan_mem_test.cc: Updated from upstream\n\tr209283.\n\t* g++.dg/asan/asan_oob_test.cc: Likewise.\n\t* g++.dg/asan/sanitizer_test_utils.h: Likewise.\n\t* g++.dg/asan/asan_str_test.cc: Likewise.\n\t* g++.dg/asan/asan_test_utils.h: Likewise.\n\t* g++.dg/asan/sanitizer_test_config.h: Likewise.\n\t* g++.dg/asan/asan_test.cc: Likewise.  Allow size 12\n\tfor long double.\n\t* g++.dg/asan/sanitizer_pthread_wrappers.h: New file.\n\tImported from upstream r209283.\n\t* g++.dg/asan/asan_test_config.h: Likewise.\n\nFrom-SVN: r211090", "tree": {"sha": "8752ab8d1f279d735cb36726fce0740b6b0d79df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8752ab8d1f279d735cb36726fce0740b6b0d79df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8465be9f1d5755379686743fb33aafbbfd77dfb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8465be9f1d5755379686743fb33aafbbfd77dfb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8465be9f1d5755379686743fb33aafbbfd77dfb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8465be9f1d5755379686743fb33aafbbfd77dfb3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cb1059220855b72e5e0576c0389304dc114ba587", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb1059220855b72e5e0576c0389304dc114ba587", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb1059220855b72e5e0576c0389304dc114ba587"}], "stats": {"total": 657, "additions": 468, "deletions": 189}, "files": [{"sha": "8beaf53879cce94ddba0a9dce1feac1cc17fa3f4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8465be9f1d5755379686743fb33aafbbfd77dfb3", "patch": "@@ -1,3 +1,21 @@\n+2014-05-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* g++.dg/asan/asan_test.C: Add -std=c++11 and\n+\t-DSANITIZER_USE_DEJAGNU_GTEST=1 to dg-options, remove\n+\t-DASAN_USE_DEJAGNU_GTEST=1.\n+\t* g++.dg/asan/asan_mem_test.cc: Updated from upstream\n+\tr209283.\n+\t* g++.dg/asan/asan_oob_test.cc: Likewise.\n+\t* g++.dg/asan/sanitizer_test_utils.h: Likewise.\n+\t* g++.dg/asan/asan_str_test.cc: Likewise.\n+\t* g++.dg/asan/asan_test_utils.h: Likewise.\n+\t* g++.dg/asan/sanitizer_test_config.h: Likewise.\n+\t* g++.dg/asan/asan_test.cc: Likewise.  Allow size 12\n+\tfor long double.\n+\t* g++.dg/asan/sanitizer_pthread_wrappers.h: New file.\n+\tImported from upstream r209283.\n+\t* g++.dg/asan/asan_test_config.h: Likewise.\n+\n 2014-05-30  Ian Lance Taylor  <iant@google.com>\n \n \t* gcc.target/i386/pause-2.c: New test."}, {"sha": "5fc4af7e9e31350ab8fd7c1174d4b484be25a280", "filename": "gcc/testsuite/g++.dg/asan/asan_mem_test.cc", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_mem_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_mem_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_mem_test.cc?ref=8465be9f1d5755379686743fb33aafbbfd77dfb3", "patch": "@@ -74,27 +74,28 @@ TEST(AddressSanitizer, MemSetOOBTest) {\n // Strictly speaking we are not guaranteed to find such two pointers,\n // but given the structure of asan's allocator we will.\n static bool AllocateTwoAdjacentArrays(char **x1, char **x2, size_t size) {\n-  vector<char *> v;\n+  vector<uintptr_t> v;\n   bool res = false;\n   for (size_t i = 0; i < 1000U && !res; i++) {\n-    v.push_back(new char[size]);\n+    v.push_back(reinterpret_cast<uintptr_t>(new char[size]));\n     if (i == 0) continue;\n     sort(v.begin(), v.end());\n     for (size_t j = 1; j < v.size(); j++) {\n       assert(v[j] > v[j-1]);\n       if ((size_t)(v[j] - v[j-1]) < size * 2) {\n-        *x2 = v[j];\n-        *x1 = v[j-1];\n+        *x2 = reinterpret_cast<char*>(v[j]);\n+        *x1 = reinterpret_cast<char*>(v[j-1]);\n         res = true;\n         break;\n       }\n     }\n   }\n \n   for (size_t i = 0; i < v.size(); i++) {\n-    if (res && v[i] == *x1) continue;\n-    if (res && v[i] == *x2) continue;\n-    delete [] v[i];\n+    char *p = reinterpret_cast<char *>(v[i]);\n+    if (res && p == *x1) continue;\n+    if (res && p == *x2) continue;\n+    delete [] p;\n   }\n   return res;\n }\n@@ -223,6 +224,13 @@ TEST(AddressSanitizer, MemCmpOOBTest) {\n   s1[size - 1] = '\\0';\n   s2[size - 1] = '\\0';\n   EXPECT_DEATH(Ident(memcmp)(s1, s2, size + 1), RightOOBReadMessage(0));\n+\n+  // Even if the buffers differ in the first byte, we still assume that\n+  // memcmp may access the whole buffer and thus reporting the overflow here:\n+  s1[0] = 1;\n+  s2[0] = 123;\n+  EXPECT_DEATH(Ident(memcmp)(s1, s2, size + 1), RightOOBReadMessage(0));\n+\n   free(s1);\n   free(s2);\n }"}, {"sha": "2361dc286d792f9377a6f4f05857a3748906686b", "filename": "gcc/testsuite/g++.dg/asan/asan_oob_test.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_oob_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_oob_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_oob_test.cc?ref=8465be9f1d5755379686743fb33aafbbfd77dfb3", "patch": "@@ -97,7 +97,6 @@ TEST(AddressSanitizer, OOBRightTest) {\n   }\n }\n \n-#if ASAN_ALLOCATOR_VERSION == 2  // Broken with the asan_allocator1\n TEST(AddressSanitizer, LargeOOBRightTest) {\n   size_t large_power_of_two = 1 << 19;\n   for (size_t i = 16; i <= 256; i *= 2) {\n@@ -107,7 +106,6 @@ TEST(AddressSanitizer, LargeOOBRightTest) {\n     delete [] p;\n   }\n }\n-#endif  // ASAN_ALLOCATOR_VERSION == 2\n \n TEST(AddressSanitizer, DISABLED_DemoOOBLeftLow) {\n   oob_test<U1>(10, -1);"}, {"sha": "207de4223161678f3bd0952fc8b5c8147ed6ddc5", "filename": "gcc/testsuite/g++.dg/asan/asan_str_test.cc", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_str_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_str_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_str_test.cc?ref=8465be9f1d5755379686743fb33aafbbfd77dfb3", "patch": "@@ -10,6 +10,10 @@\n //===----------------------------------------------------------------------===//\n #include \"asan_test_utils.h\"\n \n+#if defined(__APPLE__)\n+#include <AvailabilityMacros.h>  // For MAC_OS_X_VERSION_*\n+#endif\n+\n // Used for string functions tests\n static char global_string[] = \"global\";\n static size_t global_string_length = 6;\n@@ -59,7 +63,19 @@ TEST(AddressSanitizer, StrLenOOBTest) {\n   free(heap_string);\n }\n \n-#ifndef __APPLE__\n+TEST(AddressSanitizer, WcsLenTest) {\n+  EXPECT_EQ(0U, wcslen(Ident(L\"\")));\n+  size_t hello_len = 13;\n+  size_t hello_size = (hello_len + 1) * sizeof(wchar_t);\n+  EXPECT_EQ(hello_len, wcslen(Ident(L\"Hello, World!\")));\n+  wchar_t *heap_string = Ident((wchar_t*)malloc(hello_size));\n+  memcpy(heap_string, L\"Hello, World!\", hello_size);\n+  EXPECT_EQ(hello_len, Ident(wcslen(heap_string)));\n+  EXPECT_DEATH(Ident(wcslen(heap_string + 14)), RightOOBReadMessage(0));\n+  free(heap_string);\n+}\n+\n+#if SANITIZER_TEST_HAS_STRNLEN\n TEST(AddressSanitizer, StrNLenOOBTest) {\n   size_t size = Ident(123);\n   char *str = MallocAndMemsetString(size);\n@@ -77,7 +93,7 @@ TEST(AddressSanitizer, StrNLenOOBTest) {\n   EXPECT_DEATH(Ident(strnlen(str, size + 1)), RightOOBReadMessage(0));\n   free(str);\n }\n-#endif\n+#endif  // SANITIZER_TEST_HAS_STRNLEN\n \n TEST(AddressSanitizer, StrDupOOBTest) {\n   size_t size = Ident(42);\n@@ -168,7 +184,7 @@ TEST(AddressSanitizer, StrNCpyOOBTest) {\n typedef char*(*PointerToStrChr1)(const char*, int);\n typedef char*(*PointerToStrChr2)(char*, int);\n \n-USED static void RunStrChrTest(PointerToStrChr1 StrChr) {\n+UNUSED static void RunStrChrTest(PointerToStrChr1 StrChr) {\n   size_t size = Ident(100);\n   char *str = MallocAndMemsetString(size);\n   str[10] = 'q';\n@@ -184,7 +200,7 @@ USED static void RunStrChrTest(PointerToStrChr1 StrChr) {\n   EXPECT_DEATH(Ident(StrChr(str, 'a')), RightOOBReadMessage(0));\n   free(str);\n }\n-USED static void RunStrChrTest(PointerToStrChr2 StrChr) {\n+UNUSED static void RunStrChrTest(PointerToStrChr2 StrChr) {\n   size_t size = Ident(100);\n   char *str = MallocAndMemsetString(size);\n   str[10] = 'q';\n@@ -203,7 +219,9 @@ USED static void RunStrChrTest(PointerToStrChr2 StrChr) {\n \n TEST(AddressSanitizer, StrChrAndIndexOOBTest) {\n   RunStrChrTest(&strchr);\n+#if !defined(_WIN32)  // no index() on Windows.\n   RunStrChrTest(&index);\n+#endif\n }\n \n TEST(AddressSanitizer, StrCmpAndFriendsLogicTest) {\n@@ -226,6 +244,7 @@ TEST(AddressSanitizer, StrCmpAndFriendsLogicTest) {\n   EXPECT_LT(0, strncmp(\"baa\", \"aaa\", 1));\n   EXPECT_LT(0, strncmp(\"zyx\", \"\", 2));\n \n+#if !defined(_WIN32)  // no str[n]casecmp on Windows.\n   // strcasecmp\n   EXPECT_EQ(0, strcasecmp(\"\", \"\"));\n   EXPECT_EQ(0, strcasecmp(\"zzz\", \"zzz\"));\n@@ -245,6 +264,7 @@ TEST(AddressSanitizer, StrCmpAndFriendsLogicTest) {\n   EXPECT_LT(0, strncasecmp(\"xyz\", \"xyy\", 10));\n   EXPECT_LT(0, strncasecmp(\"Baa\", \"aaa\", 1));\n   EXPECT_LT(0, strncasecmp(\"zyx\", \"\", 2));\n+#endif\n \n   // memcmp\n   EXPECT_EQ(0, memcmp(\"a\", \"b\", 0));\n@@ -287,9 +307,11 @@ TEST(AddressSanitizer, StrCmpOOBTest) {\n   RunStrCmpTest(&strcmp);\n }\n \n+#if !defined(_WIN32)  // no str[n]casecmp on Windows.\n TEST(AddressSanitizer, StrCaseCmpOOBTest) {\n   RunStrCmpTest(&strcasecmp);\n }\n+#endif\n \n typedef int(*PointerToStrNCmp)(const char*, const char*, size_t);\n void RunStrNCmpTest(PointerToStrNCmp StrNCmp) {\n@@ -322,9 +344,12 @@ TEST(AddressSanitizer, StrNCmpOOBTest) {\n   RunStrNCmpTest(&strncmp);\n }\n \n+#if !defined(_WIN32)  // no str[n]casecmp on Windows.\n TEST(AddressSanitizer, StrNCaseCmpOOBTest) {\n   RunStrNCmpTest(&strncasecmp);\n }\n+#endif\n+\n TEST(AddressSanitizer, StrCatOOBTest) {\n   // strcat() reads strlen(to) bytes from |to| before concatenating.\n   size_t to_size = Ident(100);\n@@ -506,11 +531,13 @@ void RunAtoiOOBTest(PointerToCallAtoi Atoi) {\n   free(array);\n }\n \n+#if !defined(_WIN32)  // FIXME: Fix and enable on Windows.\n TEST(AddressSanitizer, AtoiAndFriendsOOBTest) {\n   RunAtoiOOBTest(&CallAtoi);\n   RunAtoiOOBTest(&CallAtol);\n   RunAtoiOOBTest(&CallAtoll);\n }\n+#endif\n \n void CallStrtol(const char *nptr, char **endptr, int base) {\n   Ident(strtol(nptr, endptr, base));\n@@ -560,11 +587,13 @@ void RunStrtolOOBTest(PointerToCallStrtol Strtol) {\n   free(array);\n }\n \n+#if !defined(_WIN32)  // FIXME: Fix and enable on Windows.\n TEST(AddressSanitizer, StrtollOOBTest) {\n   RunStrtolOOBTest(&CallStrtoll);\n }\n TEST(AddressSanitizer, StrtolOOBTest) {\n   RunStrtolOOBTest(&CallStrtol);\n }\n+#endif\n \n "}, {"sha": "3cee7150f736a43a4ebd90d21da5e03b4b002691", "filename": "gcc/testsuite/g++.dg/asan/asan_test.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.C?ref=8465be9f1d5755379686743fb33aafbbfd77dfb3", "patch": "@@ -2,7 +2,7 @@\n // { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O2\" } }\n // { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } }\n // { dg-additional-sources \"asan_globals_test-wrapper.cc\" }\n-// { dg-options \"-fsanitize=address -fno-builtin -Wall -Wno-format -Werror -g -DASAN_UAR=0 -DASAN_HAS_EXCEPTIONS=1 -DASAN_HAS_BLACKLIST=0 -DASAN_USE_DEJAGNU_GTEST=1 -lasan -lpthread -ldl\" }\n+// { dg-options \"-std=c++11 -fsanitize=address -fno-builtin -Wall -Wno-format -Werror -g -DASAN_UAR=0 -DASAN_HAS_EXCEPTIONS=1 -DASAN_HAS_BLACKLIST=0 -DSANITIZER_USE_DEJAGNU_GTEST=1 -lasan -lpthread -ldl\" }\n // { dg-additional-options \"-DASAN_NEEDS_SEGV=1\" { target { ! arm*-*-* } } }\n // { dg-additional-options \"-DASAN_LOW_MEMORY=1 -DASAN_NEEDS_SEGV=0\" { target arm*-*-* } }\n // { dg-additional-options \"-DASAN_AVOID_EXPENSIVE_TESTS=1\" { target { ! run_expensive_tests } } }"}, {"sha": "5f2e2c244ddbaa7603c1eeb9975adb4d6ee2e11c", "filename": "gcc/testsuite/g++.dg/asan/asan_test.cc", "status": "modified", "additions": 237, "deletions": 133, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.cc?ref=8465be9f1d5755379686743fb33aafbbfd77dfb3", "patch": "@@ -23,27 +23,10 @@ NOINLINE void *malloc_bbb(size_t size) {\n NOINLINE void *malloc_aaa(size_t size) {\n   void *res = malloc_bbb(size); break_optimization(0); return res;}\n \n-#ifndef __APPLE__\n-NOINLINE void *memalign_fff(size_t alignment, size_t size) {\n-  void *res = memalign/**/(alignment, size); break_optimization(0); return res;}\n-NOINLINE void *memalign_eee(size_t alignment, size_t size) {\n-  void *res = memalign_fff(alignment, size); break_optimization(0); return res;}\n-NOINLINE void *memalign_ddd(size_t alignment, size_t size) {\n-  void *res = memalign_eee(alignment, size); break_optimization(0); return res;}\n-NOINLINE void *memalign_ccc(size_t alignment, size_t size) {\n-  void *res = memalign_ddd(alignment, size); break_optimization(0); return res;}\n-NOINLINE void *memalign_bbb(size_t alignment, size_t size) {\n-  void *res = memalign_ccc(alignment, size); break_optimization(0); return res;}\n-NOINLINE void *memalign_aaa(size_t alignment, size_t size) {\n-  void *res = memalign_bbb(alignment, size); break_optimization(0); return res;}\n-#endif  // __APPLE__\n-\n-\n NOINLINE void free_ccc(void *p) { free(p); break_optimization(0);}\n NOINLINE void free_bbb(void *p) { free_ccc(p); break_optimization(0);}\n NOINLINE void free_aaa(void *p) { free_bbb(p); break_optimization(0);}\n \n-\n template<typename T>\n NOINLINE void uaf_test(int size, int off) {\n   char *p = (char *)malloc_aaa(size);\n@@ -88,19 +71,19 @@ TEST(AddressSanitizer, VariousMallocsTest) {\n   *c = 0;\n   delete c;\n \n-#if !defined(__APPLE__) && !defined(ANDROID) && !defined(__ANDROID__)\n+#if SANITIZER_TEST_HAS_POSIX_MEMALIGN\n   int *pm;\n   int pm_res = posix_memalign((void**)&pm, kPageSize, kPageSize);\n   EXPECT_EQ(0, pm_res);\n   free(pm);\n-#endif\n+#endif  // SANITIZER_TEST_HAS_POSIX_MEMALIGN\n \n-#if !defined(__APPLE__)\n+#if SANITIZER_TEST_HAS_MEMALIGN\n   int *ma = (int*)memalign(kPageSize, kPageSize);\n   EXPECT_EQ(0U, (uintptr_t)ma % kPageSize);\n   ma[123] = 0;\n   free(ma);\n-#endif  // __APPLE__\n+#endif  // SANITIZER_TEST_HAS_MEMALIGN\n }\n \n TEST(AddressSanitizer, CallocTest) {\n@@ -109,13 +92,37 @@ TEST(AddressSanitizer, CallocTest) {\n   free(a);\n }\n \n+TEST(AddressSanitizer, CallocReturnsZeroMem) {\n+  size_t sizes[] = {16, 1000, 10000, 100000, 2100000};\n+  for (size_t s = 0; s < sizeof(sizes)/sizeof(sizes[0]); s++) {\n+    size_t size = sizes[s];\n+    for (size_t iter = 0; iter < 5; iter++) {\n+      char *x = Ident((char*)calloc(1, size));\n+      EXPECT_EQ(x[0], 0);\n+      EXPECT_EQ(x[size - 1], 0);\n+      EXPECT_EQ(x[size / 2], 0);\n+      EXPECT_EQ(x[size / 3], 0);\n+      EXPECT_EQ(x[size / 4], 0);\n+      memset(x, 0x42, size);\n+      free(Ident(x));\n+#if !defined(_WIN32)\n+      // FIXME: OOM on Windows. We should just make this a lit test\n+      // with quarantine size set to 1.\n+      free(Ident(malloc(Ident(1 << 27))));  // Try to drain the quarantine.\n+#endif\n+    }\n+  }\n+}\n+\n+#if !defined(_WIN32)  // No valloc on Windows.\n TEST(AddressSanitizer, VallocTest) {\n   void *a = valloc(100);\n   EXPECT_EQ(0U, (uintptr_t)a % kPageSize);\n   free(a);\n }\n+#endif\n \n-#ifndef __APPLE__\n+#if SANITIZER_TEST_HAS_PVALLOC\n TEST(AddressSanitizer, PvallocTest) {\n   char *a = (char*)pvalloc(kPageSize + 100);\n   EXPECT_EQ(0U, (uintptr_t)a % kPageSize);\n@@ -127,8 +134,10 @@ TEST(AddressSanitizer, PvallocTest) {\n   a[101] = 1;  // we should not report an error here.\n   free(a);\n }\n-#endif  // __APPLE__\n+#endif  // SANITIZER_TEST_HAS_PVALLOC\n \n+#if !defined(_WIN32)\n+// FIXME: Use an equivalent of pthread_setspecific on Windows.\n void *TSDWorker(void *test_key) {\n   if (test_key) {\n     pthread_setspecific(*(pthread_key_t*)test_key, (void*)0xfeedface);\n@@ -158,6 +167,7 @@ TEST(AddressSanitizer, DISABLED_TSDTest) {\n   PTHREAD_JOIN(th, NULL);\n   pthread_key_delete(test_key);\n }\n+#endif\n \n TEST(AddressSanitizer, UAF_char) {\n   const char *uaf_string = \"AddressSanitizer:.*heap-use-after-free\";\n@@ -168,6 +178,36 @@ TEST(AddressSanitizer, UAF_char) {\n   EXPECT_DEATH(uaf_test<U1>(kLargeMalloc, kLargeMalloc / 2), uaf_string);\n }\n \n+TEST(AddressSanitizer, UAF_long_double) {\n+  if (sizeof(long double) == sizeof(double)) return;\n+  long double *p = Ident(new long double[10]);\n+  EXPECT_DEATH(Ident(p)[12] = 0, \"WRITE of size 1[026]\");\n+  EXPECT_DEATH(Ident(p)[0] = Ident(p)[12], \"READ of size 1[026]\");\n+  delete [] Ident(p);\n+}\n+\n+#if !defined(_WIN32)\n+struct Packed5 {\n+  int x;\n+  char c;\n+} __attribute__((packed));\n+#else\n+# pragma pack(push, 1)\n+struct Packed5 {\n+  int x;\n+  char c;\n+};\n+# pragma pack(pop)\n+#endif\n+\n+TEST(AddressSanitizer, UAF_Packed5) {\n+  static_assert(sizeof(Packed5) == 5, \"Please check the keywords used\");\n+  Packed5 *p = Ident(new Packed5[2]);\n+  EXPECT_DEATH(p[0] = p[3], \"READ of size 5\");\n+  EXPECT_DEATH(p[3] = p[0], \"WRITE of size 5\");\n+  delete [] Ident(p);\n+}\n+\n #if ASAN_HAS_BLACKLIST\n TEST(AddressSanitizer, IgnoreTest) {\n   int *x = Ident(new int);\n@@ -244,70 +284,28 @@ TEST(AddressSanitizer, SignalTest) {\n }  // namespace\n #endif\n \n-static void MallocStress(size_t n) {\n-  uint32_t seed = my_rand();\n-  for (size_t iter = 0; iter < 10; iter++) {\n-    vector<void *> vec;\n-    for (size_t i = 0; i < n; i++) {\n-      if ((i % 3) == 0) {\n-        if (vec.empty()) continue;\n-        size_t idx = my_rand_r(&seed) % vec.size();\n-        void *ptr = vec[idx];\n-        vec[idx] = vec.back();\n-        vec.pop_back();\n-        free_aaa(ptr);\n-      } else {\n-        size_t size = my_rand_r(&seed) % 1000 + 1;\n-#ifndef __APPLE__\n-        size_t alignment = 1 << (my_rand_r(&seed) % 7 + 3);\n-        char *ptr = (char*)memalign_aaa(alignment, size);\n-#else\n-        char *ptr = (char*) malloc_aaa(size);\n-#endif\n-        vec.push_back(ptr);\n-        ptr[0] = 0;\n-        ptr[size-1] = 0;\n-        ptr[size/2] = 0;\n-      }\n-    }\n-    for (size_t i = 0; i < vec.size(); i++)\n-      free_aaa(vec[i]);\n-  }\n-}\n-\n-TEST(AddressSanitizer, MallocStressTest) {\n-  MallocStress((ASAN_LOW_MEMORY) ? 20000 : 200000);\n-}\n-\n static void TestLargeMalloc(size_t size) {\n   char buff[1024];\n   sprintf(buff, \"is located 1 bytes to the left of %lu-byte\", (long)size);\n   EXPECT_DEATH(Ident((char*)malloc(size))[-1] = 0, buff);\n }\n \n TEST(AddressSanitizer, LargeMallocTest) {\n-  for (int i = 113; i < (1 << 28); i = i * 2 + 13) {\n+  const int max_size = (SANITIZER_WORDSIZE == 32) ? 1 << 26 : 1 << 28;\n+  for (int i = 113; i < max_size; i = i * 2 + 13) {\n     TestLargeMalloc(i);\n   }\n }\n \n-#if ASAN_LOW_MEMORY != 1\n TEST(AddressSanitizer, HugeMallocTest) {\n-#ifdef __APPLE__\n-  // It was empirically found out that 1215 megabytes is the maximum amount of\n-  // memory available to the process under AddressSanitizer on 32-bit Mac 10.6.\n-  // 32-bit Mac 10.7 gives even less (< 1G).\n-  // (the libSystem malloc() allows allocating up to 2300 megabytes without\n-  // ASan).\n-  size_t n_megs = SANITIZER_WORDSIZE == 32 ? 500 : 4100;\n-#else\n-  size_t n_megs = SANITIZER_WORDSIZE == 32 ? 2600 : 4100;\n-#endif\n-  TestLargeMalloc(n_megs << 20);\n+  if (SANITIZER_WORDSIZE != 64 || ASAN_AVOID_EXPENSIVE_TESTS) return;\n+  size_t n_megs = 4100;\n+  EXPECT_DEATH(Ident((char*)malloc(n_megs << 20))[-1] = 0,\n+               \"is located 1 bytes to the left|\"\n+               \"AddressSanitizer failed to allocate\");\n }\n-#endif\n \n-#ifndef __APPLE__\n+#if SANITIZER_TEST_HAS_MEMALIGN\n void MemalignRun(size_t align, size_t size, int idx) {\n   char *p = (char *)memalign(align, size);\n   Ident(p)[idx] = 0;\n@@ -323,20 +321,7 @@ TEST(AddressSanitizer, memalign) {\n                  \"is located 1 bytes to the right\");\n   }\n }\n-#endif\n-\n-TEST(AddressSanitizer, ThreadedMallocStressTest) {\n-  const int kNumThreads = 4;\n-  const int kNumIterations = (ASAN_LOW_MEMORY) ? 10000 : 100000;\n-  pthread_t t[kNumThreads];\n-  for (int i = 0; i < kNumThreads; i++) {\n-    PTHREAD_CREATE(&t[i], 0, (void* (*)(void *x))MallocStress,\n-        (void*)kNumIterations);\n-  }\n-  for (int i = 0; i < kNumThreads; i++) {\n-    PTHREAD_JOIN(t[i], 0);\n-  }\n-}\n+#endif  // SANITIZER_TEST_HAS_MEMALIGN\n \n void *ManyThreadsWorker(void *a) {\n   for (int iter = 0; iter < 100; iter++) {\n@@ -377,17 +362,30 @@ TEST(AddressSanitizer, ReallocTest) {\n   free(ptr2);\n }\n \n+TEST(AddressSanitizer, ReallocFreedPointerTest) {\n+  void *ptr = Ident(malloc(42));\n+  ASSERT_TRUE(NULL != ptr);\n+  free(ptr);\n+  EXPECT_DEATH(ptr = realloc(ptr, 77), \"attempting double-free\");\n+}\n+\n+TEST(AddressSanitizer, ReallocInvalidPointerTest) {\n+  void *ptr = Ident(malloc(42));\n+  EXPECT_DEATH(ptr = realloc((int*)ptr + 1, 77), \"attempting free.*not malloc\");\n+  free(ptr);\n+}\n+\n TEST(AddressSanitizer, ZeroSizeMallocTest) {\n   // Test that malloc(0) and similar functions don't return NULL.\n   void *ptr = Ident(malloc(0));\n   EXPECT_TRUE(NULL != ptr);\n   free(ptr);\n-#if !defined(__APPLE__) && !defined(ANDROID) && !defined(__ANDROID__)\n+#if SANITIZER_TEST_HAS_POSIX_MEMALIGN\n   int pm_res = posix_memalign(&ptr, 1<<20, 0);\n   EXPECT_EQ(0, pm_res);\n   EXPECT_TRUE(NULL != ptr);\n   free(ptr);\n-#endif\n+#endif  // SANITIZER_TEST_HAS_POSIX_MEMALIGN\n   int *int_ptr = new int[0];\n   int *int_ptr2 = new int[0];\n   EXPECT_TRUE(NULL != int_ptr);\n@@ -397,7 +395,7 @@ TEST(AddressSanitizer, ZeroSizeMallocTest) {\n   delete[] int_ptr2;\n }\n \n-#ifndef __APPLE__\n+#if SANITIZER_TEST_HAS_MALLOC_USABLE_SIZE\n static const char *kMallocUsableSizeErrorMsg =\n   \"AddressSanitizer: attempting to call malloc_usable_size()\";\n \n@@ -413,8 +411,9 @@ TEST(AddressSanitizer, MallocUsableSizeTest) {\n                kMallocUsableSizeErrorMsg);\n   free(array);\n   EXPECT_DEATH(malloc_usable_size(array), kMallocUsableSizeErrorMsg);\n+  delete int_ptr;\n }\n-#endif\n+#endif  // SANITIZER_TEST_HAS_MALLOC_USABLE_SIZE\n \n void WrongFree() {\n   int *x = (int*)malloc(100 * sizeof(int));\n@@ -423,10 +422,14 @@ void WrongFree() {\n   free(x + 1);\n }\n \n+#if !defined(_WIN32)  // FIXME: This should be a lit test.\n TEST(AddressSanitizer, WrongFreeTest) {\n-  EXPECT_DEATH(WrongFree(),\n-               \"ERROR: AddressSanitizer: attempting free.*not malloc\");\n+  EXPECT_DEATH(WrongFree(), ASAN_PCRE_DOTALL\n+               \"ERROR: AddressSanitizer: attempting free.*not malloc\"\n+               \".*is located 4 bytes inside of 400-byte region\"\n+               \".*allocated by thread\");\n }\n+#endif\n \n void DoubleFree() {\n   int *x = (int*)malloc(100 * sizeof(int));\n@@ -437,27 +440,30 @@ void DoubleFree() {\n   abort();\n }\n \n+#if !defined(_WIN32)  // FIXME: This should be a lit test.\n TEST(AddressSanitizer, DoubleFreeTest) {\n   EXPECT_DEATH(DoubleFree(), ASAN_PCRE_DOTALL\n                \"ERROR: AddressSanitizer: attempting double-free\"\n                \".*is located 0 bytes inside of 400-byte region\"\n                \".*freed by thread T0 here\"\n                \".*previously allocated by thread T0 here\");\n }\n+#endif\n \n template<int kSize>\n NOINLINE void SizedStackTest() {\n   char a[kSize];\n   char  *A = Ident((char*)&a);\n+  const char *expected_death = \"AddressSanitizer: stack-buffer-\";\n   for (size_t i = 0; i < kSize; i++)\n     A[i] = i;\n-  EXPECT_DEATH(A[-1] = 0, \"\");\n-  EXPECT_DEATH(A[-20] = 0, \"\");\n-  EXPECT_DEATH(A[-31] = 0, \"\");\n-  EXPECT_DEATH(A[kSize] = 0, \"\");\n-  EXPECT_DEATH(A[kSize + 1] = 0, \"\");\n-  EXPECT_DEATH(A[kSize + 10] = 0, \"\");\n-  EXPECT_DEATH(A[kSize + 31] = 0, \"\");\n+  EXPECT_DEATH(A[-1] = 0, expected_death);\n+  EXPECT_DEATH(A[-5] = 0, expected_death);\n+  EXPECT_DEATH(A[kSize] = 0, expected_death);\n+  EXPECT_DEATH(A[kSize + 1] = 0, expected_death);\n+  EXPECT_DEATH(A[kSize + 5] = 0, expected_death);\n+  if (kSize > 16)\n+    EXPECT_DEATH(A[kSize + 31] = 0, expected_death);\n }\n \n TEST(AddressSanitizer, SimpleStackTest) {\n@@ -478,6 +484,9 @@ TEST(AddressSanitizer, SimpleStackTest) {\n   SizedStackTest<128>();\n }\n \n+#if !defined(_WIN32)\n+// FIXME: It's a bit hard to write multi-line death test expectations\n+// in a portable way.  Anyways, this should just be turned into a lit test.\n TEST(AddressSanitizer, ManyStackObjectsTest) {\n   char XXX[10];\n   char YYY[20];\n@@ -486,6 +495,47 @@ TEST(AddressSanitizer, ManyStackObjectsTest) {\n   Ident(YYY);\n   EXPECT_DEATH(Ident(ZZZ)[-1] = 0, ASAN_PCRE_DOTALL \"XXX.*YYY.*ZZZ\");\n }\n+#endif\n+\n+#if 0  // This test requires online symbolizer.\n+// Moved to lit_tests/stack-oob-frames.cc.\n+// Reenable here once we have online symbolizer by default.\n+NOINLINE static void Frame0(int frame, char *a, char *b, char *c) {\n+  char d[4] = {0};\n+  char *D = Ident(d);\n+  switch (frame) {\n+    case 3: a[5]++; break;\n+    case 2: b[5]++; break;\n+    case 1: c[5]++; break;\n+    case 0: D[5]++; break;\n+  }\n+}\n+NOINLINE static void Frame1(int frame, char *a, char *b) {\n+  char c[4] = {0}; Frame0(frame, a, b, c);\n+  break_optimization(0);\n+}\n+NOINLINE static void Frame2(int frame, char *a) {\n+  char b[4] = {0}; Frame1(frame, a, b);\n+  break_optimization(0);\n+}\n+NOINLINE static void Frame3(int frame) {\n+  char a[4] = {0}; Frame2(frame, a);\n+  break_optimization(0);\n+}\n+\n+TEST(AddressSanitizer, GuiltyStackFrame0Test) {\n+  EXPECT_DEATH(Frame3(0), \"located .*in frame <.*Frame0\");\n+}\n+TEST(AddressSanitizer, GuiltyStackFrame1Test) {\n+  EXPECT_DEATH(Frame3(1), \"located .*in frame <.*Frame1\");\n+}\n+TEST(AddressSanitizer, GuiltyStackFrame2Test) {\n+  EXPECT_DEATH(Frame3(2), \"located .*in frame <.*Frame2\");\n+}\n+TEST(AddressSanitizer, GuiltyStackFrame3Test) {\n+  EXPECT_DEATH(Frame3(3), \"located .*in frame <.*Frame3\");\n+}\n+#endif\n \n NOINLINE void LongJmpFunc1(jmp_buf buf) {\n   // create three red zones for these two stack objects.\n@@ -498,6 +548,24 @@ NOINLINE void LongJmpFunc1(jmp_buf buf) {\n   longjmp(buf, 1);\n }\n \n+NOINLINE void TouchStackFunc() {\n+  int a[100];  // long array will intersect with redzones from LongJmpFunc1.\n+  int *A = Ident(a);\n+  for (int i = 0; i < 100; i++)\n+    A[i] = i*i;\n+}\n+\n+// Test that we handle longjmp and do not report false positives on stack.\n+TEST(AddressSanitizer, LongJmpTest) {\n+  static jmp_buf buf;\n+  if (!setjmp(buf)) {\n+    LongJmpFunc1(buf);\n+  } else {\n+    TouchStackFunc();\n+  }\n+}\n+\n+#if !defined(_WIN32)  // Only basic longjmp is available on Windows.\n NOINLINE void BuiltinLongJmpFunc1(jmp_buf buf) {\n   // create three red zones for these two stack objects.\n   int a;\n@@ -531,25 +599,10 @@ NOINLINE void SigLongJmpFunc1(sigjmp_buf buf) {\n   siglongjmp(buf, 1);\n }\n \n-\n-NOINLINE void TouchStackFunc() {\n-  int a[100];  // long array will intersect with redzones from LongJmpFunc1.\n-  int *A = Ident(a);\n-  for (int i = 0; i < 100; i++)\n-    A[i] = i*i;\n-}\n-\n-// Test that we handle longjmp and do not report fals positives on stack.\n-TEST(AddressSanitizer, LongJmpTest) {\n-  static jmp_buf buf;\n-  if (!setjmp(buf)) {\n-    LongJmpFunc1(buf);\n-  } else {\n-    TouchStackFunc();\n-  }\n-}\n-\n-#if not defined(__ANDROID__)\n+#if !defined(__ANDROID__) && \\\n+    !defined(__powerpc64__) && !defined(__powerpc__)\n+// Does not work on Power:\n+// https://code.google.com/p/address-sanitizer/issues/detail?id=185\n TEST(AddressSanitizer, BuiltinLongJmpTest) {\n   static jmp_buf buf;\n   if (!__builtin_setjmp((void**)buf)) {\n@@ -558,7 +611,8 @@ TEST(AddressSanitizer, BuiltinLongJmpTest) {\n     TouchStackFunc();\n   }\n }\n-#endif  // not defined(__ANDROID__)\n+#endif  // !defined(__ANDROID__) && !defined(__powerpc64__) &&\n+        // !defined(__powerpc__)\n \n TEST(AddressSanitizer, UnderscopeLongJmpTest) {\n   static jmp_buf buf;\n@@ -577,8 +631,10 @@ TEST(AddressSanitizer, SigLongJmpTest) {\n     TouchStackFunc();\n   }\n }\n+#endif\n \n-#ifdef __EXCEPTIONS\n+// FIXME: Why does clang-cl define __EXCEPTIONS?\n+#if defined(__EXCEPTIONS) && !defined(_WIN32)\n NOINLINE void ThrowFunc() {\n   // create three red zones for these two stack objects.\n   int a;\n@@ -626,7 +682,8 @@ TEST(AddressSanitizer, ThreadStackReuseTest) {\n   PTHREAD_JOIN(t, 0);\n }\n \n-#if defined(__i386__) || defined(__x86_64__)\n+#if defined(__i686__) || defined(__x86_64__)\n+#include <emmintrin.h>\n TEST(AddressSanitizer, Store128Test) {\n   char *a = Ident((char*)malloc(Ident(12)));\n   char *p = a;\n@@ -644,11 +701,19 @@ TEST(AddressSanitizer, Store128Test) {\n }\n #endif\n \n+// FIXME: All tests that use this function should be turned into lit tests.\n string RightOOBErrorMessage(int oob_distance, bool is_write) {\n   assert(oob_distance >= 0);\n   char expected_str[100];\n-  sprintf(expected_str, ASAN_PCRE_DOTALL \"%s.*located %d bytes to the right\",\n-          is_write ? \"WRITE\" : \"READ\", oob_distance);\n+  sprintf(expected_str, ASAN_PCRE_DOTALL\n+#if !GTEST_USES_SIMPLE_RE\n+          \"buffer-overflow.*%s.*\"\n+#endif\n+          \"located %d bytes to the right\",\n+#if !GTEST_USES_SIMPLE_RE\n+          is_write ? \"WRITE\" : \"READ\",\n+#endif\n+          oob_distance);\n   return string(expected_str);\n }\n \n@@ -660,11 +725,19 @@ string RightOOBReadMessage(int oob_distance) {\n   return RightOOBErrorMessage(oob_distance, /*is_write*/false);\n }\n \n+// FIXME: All tests that use this function should be turned into lit tests.\n string LeftOOBErrorMessage(int oob_distance, bool is_write) {\n   assert(oob_distance > 0);\n   char expected_str[100];\n-  sprintf(expected_str, ASAN_PCRE_DOTALL \"%s.*located %d bytes to the left\",\n-          is_write ? \"WRITE\" : \"READ\", oob_distance);\n+  sprintf(expected_str,\n+#if !GTEST_USES_SIMPLE_RE\n+          ASAN_PCRE_DOTALL \"%s.*\"\n+#endif\n+          \"located %d bytes to the left\",\n+#if !GTEST_USES_SIMPLE_RE\n+          is_write ? \"WRITE\" : \"READ\",\n+#endif\n+          oob_distance);\n   return string(expected_str);\n }\n \n@@ -818,13 +891,15 @@ void ThreadedTestSpawn() {\n   PTHREAD_JOIN(t, 0);\n }\n \n+#if !defined(_WIN32)  // FIXME: This should be a lit test.\n TEST(AddressSanitizer, ThreadedTest) {\n   EXPECT_DEATH(ThreadedTestSpawn(),\n                ASAN_PCRE_DOTALL\n                \"Thread T.*created\"\n                \".*Thread T.*created\"\n                \".*Thread T.*created\");\n }\n+#endif\n \n void *ThreadedTestFunc(void *unused) {\n   // Check if prctl(PR_SET_NAME) is supported. Return if not.\n@@ -855,7 +930,11 @@ TEST(AddressSanitizer, ShadowGapTest) {\n #if SANITIZER_WORDSIZE == 32\n   char *addr = (char*)0x22000000;\n #else\n+# if defined(__powerpc64__)\n+  char *addr = (char*)0x024000800000;\n+# else\n   char *addr = (char*)0x0000100000080000;\n+# endif\n #endif\n   EXPECT_DEATH(*addr = 1, \"AddressSanitizer: SEGV on unknown\");\n }\n@@ -1015,7 +1094,8 @@ TEST(AddressSanitizer, PthreadExitTest) {\n   }\n }\n \n-#ifdef __EXCEPTIONS\n+// FIXME: Why does clang-cl define __EXCEPTIONS?\n+#if defined(__EXCEPTIONS) && !defined(_WIN32)\n NOINLINE static void StackReuseAndException() {\n   int large_stack[1000];\n   Ident(large_stack);\n@@ -1033,12 +1113,14 @@ TEST(AddressSanitizer, DISABLED_StressStackReuseAndExceptionsTest) {\n }\n #endif\n \n+#if !defined(_WIN32)\n TEST(AddressSanitizer, MlockTest) {\n   EXPECT_EQ(0, mlockall(MCL_CURRENT));\n   EXPECT_EQ(0, mlock((void*)0x12345, 0x5678));\n   EXPECT_EQ(0, munlockall());\n   EXPECT_EQ(0, munlock((void*)0x987, 0x654));\n }\n+#endif\n \n struct LargeStruct {\n   int foo[100];\n@@ -1051,19 +1133,26 @@ TEST(AddressSanitizer, LargeStructCopyTest) {\n   *Ident(&a) = *Ident(&a);\n }\n \n-ATTRIBUTE_NO_ADDRESS_SAFETY_ANALYSIS\n-static void NoAddressSafety() {\n+ATTRIBUTE_NO_SANITIZE_ADDRESS\n+static void NoSanitizeAddress() {\n   char *foo = new char[10];\n   Ident(foo)[10] = 0;\n   delete [] foo;\n }\n \n-TEST(AddressSanitizer, AttributeNoAddressSafetyTest) {\n-  Ident(NoAddressSafety)();\n+TEST(AddressSanitizer, AttributeNoSanitizeAddressTest) {\n+  Ident(NoSanitizeAddress)();\n }\n \n-// It doesn't work on Android, as calls to new/delete go through malloc/free.\n-#if !defined(ANDROID) && !defined(__ANDROID__)\n+// The new/delete/etc mismatch checks don't work on Android,\n+//   as calls to new/delete go through malloc/free.\n+// OS X support is tracked here:\n+//   https://code.google.com/p/address-sanitizer/issues/detail?id=131\n+// Windows support is tracked here:\n+//   https://code.google.com/p/address-sanitizer/issues/detail?id=309\n+#if !defined(ANDROID) && !defined(__ANDROID__) && \\\n+    !defined(__APPLE__) && \\\n+    !defined(_WIN32)\n static string MismatchStr(const string &str) {\n   return string(\"AddressSanitizer: alloc-dealloc-mismatch \\\\(\") + str;\n }\n@@ -1177,3 +1266,18 @@ TEST(AddressSanitizer, LongDoubleNegativeTest) {\n   memcpy(Ident(&a), Ident(&b), sizeof(long double));\n   memcpy(Ident(&c), Ident(&b), sizeof(long double));\n }\n+\n+#if !defined(_WIN32)\n+TEST(AddressSanitizer, pthread_getschedparam) {\n+  int policy;\n+  struct sched_param param;\n+  EXPECT_DEATH(\n+      pthread_getschedparam(pthread_self(), &policy, Ident(&param) + 2),\n+      \"AddressSanitizer: stack-buffer-.*flow\");\n+  EXPECT_DEATH(\n+      pthread_getschedparam(pthread_self(), Ident(&policy) - 1, &param),\n+      \"AddressSanitizer: stack-buffer-.*flow\");\n+  int res = pthread_getschedparam(pthread_self(), &policy, &param);\n+  ASSERT_EQ(0, res);\n+}\n+#endif"}, {"sha": "97b7dd0873ff2c33d2d62f7809672977fff3869e", "filename": "gcc/testsuite/g++.dg/asan/asan_test_config.h", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test_config.h?ref=8465be9f1d5755379686743fb33aafbbfd77dfb3", "patch": "@@ -19,12 +19,6 @@\n #include <string>\n #include <map>\n \n-#if ASAN_USE_DEJAGNU_GTEST\n-# include \"dejagnu-gtest.h\"\n-#else\n-# include \"gtest/gtest.h\"\n-#endif\n-\n using std::string;\n using std::vector;\n using std::map;\n@@ -42,11 +36,11 @@ using std::map;\n #endif\n \n #ifndef ASAN_NEEDS_SEGV\n-# error \"please define ASAN_NEEDS_SEGV\"\n-#endif\n-\n-#ifndef ASAN_LOW_MEMORY\n-# define ASAN_LOW_MEMORY 0\n+# if defined(_WIN32)\n+#  define ASAN_NEEDS_SEGV 0\n+# else\n+#  define ASAN_NEEDS_SEGV 1\n+# endif\n #endif\n \n #ifndef ASAN_AVOID_EXPENSIVE_TESTS"}, {"sha": "f5281a6a9e3c999311cd028c8c4f12228f49e482", "filename": "gcc/testsuite/g++.dg/asan/asan_test_utils.h", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test_utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test_utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test_utils.h?ref=8465be9f1d5755379686743fb33aafbbfd77dfb3", "patch": "@@ -12,24 +12,28 @@\n #ifndef ASAN_TEST_UTILS_H\n #define ASAN_TEST_UTILS_H\n \n-#if !defined(ASAN_EXTERNAL_TEST_CONFIG)\n+#if !defined(SANITIZER_EXTERNAL_TEST_CONFIG)\n # define INCLUDED_FROM_ASAN_TEST_UTILS_H\n # include \"asan_test_config.h\"\n # undef INCLUDED_FROM_ASAN_TEST_UTILS_H\n #endif\n \n #include \"sanitizer_test_utils.h\"\n+#include \"sanitizer_pthread_wrappers.h\"\n+\n #include <stdio.h>\n #include <signal.h>\n #include <stdlib.h>\n #include <string.h>\n-#include <strings.h>\n-#include <pthread.h>\n #include <stdint.h>\n-#include <setjmp.h>\n #include <assert.h>\n #include <algorithm>\n-#include <sys/mman.h>\n+\n+#if !defined(_WIN32)\n+# include <strings.h>\n+# include <sys/mman.h>\n+# include <setjmp.h>\n+#endif\n \n #ifdef __linux__\n # include <sys/prctl.h>\n@@ -39,18 +43,10 @@\n #include <unistd.h>\n #endif\n \n-#if defined(__i386__) || defined(__x86_64__)\n-#include <emmintrin.h>\n-#endif\n-\n-#ifndef __APPLE__\n+#if !defined(__APPLE__) && !defined(__FreeBSD__)\n #include <malloc.h>\n #endif\n \n-// Check that pthread_create/pthread_join return success.\n-#define PTHREAD_CREATE(a, b, c, d) ASSERT_EQ(0, pthread_create(a, b, c, d))\n-#define PTHREAD_JOIN(a, b) ASSERT_EQ(0, pthread_join(a, b))\n-\n #if ASAN_HAS_EXCEPTIONS\n # define ASAN_THROW(x) throw (x)\n #else"}, {"sha": "2e71ecbb333c24ec0b1440d4cd7c28d9e6d1ba43", "filename": "gcc/testsuite/g++.dg/asan/sanitizer_pthread_wrappers.h", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fsanitizer_pthread_wrappers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fsanitizer_pthread_wrappers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fsanitizer_pthread_wrappers.h?ref=8465be9f1d5755379686743fb33aafbbfd77dfb3", "patch": "@@ -0,0 +1,64 @@\n+//===-- sanitizer_pthread_wrappers.h ----------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of *Sanitizer runtime.\n+// It provides handy wrappers for thread manipulation, that:\n+//  a) assert on any failure rather than returning an error code\n+//  b) defines pthread-like interface on platforms where where <pthread.h>\n+//     is not supplied by default.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_PTHREAD_WRAPPERS_H\n+#define SANITIZER_PTHREAD_WRAPPERS_H\n+\n+#include \"sanitizer_test_utils.h\"\n+\n+#if !defined(_WIN32)\n+# include <pthread.h>\n+// Simply forward the arguments and check that the pthread functions succeed.\n+# define PTHREAD_CREATE(a, b, c, d) ASSERT_EQ(0, pthread_create(a, b, c, d))\n+# define PTHREAD_JOIN(a, b) ASSERT_EQ(0, pthread_join(a, b))\n+#else\n+typedef HANDLE pthread_t;\n+\n+struct PthreadHelperCreateThreadInfo {\n+  void *(*start_routine)(void *);\n+  void *arg;\n+};\n+\n+inline DWORD WINAPI PthreadHelperThreadProc(void *arg) {\n+  PthreadHelperCreateThreadInfo *start_data =\n+      reinterpret_cast<PthreadHelperCreateThreadInfo*>(arg);\n+  void *ret = (start_data->start_routine)(start_data->arg);\n+  delete start_data;\n+  return (DWORD)ret;\n+}\n+\n+inline void PTHREAD_CREATE(pthread_t *thread, void *attr,\n+                           void *(*start_routine)(void *), void *arg) {\n+  ASSERT_EQ(0, attr) << \"Thread attributes are not supported yet.\";\n+  PthreadHelperCreateThreadInfo *data = new PthreadHelperCreateThreadInfo;\n+  data->start_routine = start_routine;\n+  data->arg = arg;\n+  *thread = CreateThread(0, 0, PthreadHelperThreadProc, data, 0, 0);\n+  ASSERT_NE(nullptr, *thread) << \"Failed to create a thread.\";\n+}\n+\n+inline void PTHREAD_JOIN(pthread_t thread, void **value_ptr) {\n+  ASSERT_EQ(0, value_ptr) << \"Nonzero value_ptr is not supported yet.\";\n+  ASSERT_EQ(WAIT_OBJECT_0, WaitForSingleObject(thread, INFINITE));\n+  ASSERT_NE(0, CloseHandle(thread));\n+}\n+\n+inline void pthread_exit(void *retval) {\n+  ASSERT_EQ(0, retval) << \"Nonzero retval is not supported yet.\";\n+  ExitThread((DWORD)retval);\n+}\n+#endif  // _WIN32\n+\n+#endif  // SANITIZER_PTHREAD_WRAPPERS_H"}, {"sha": "a819a4097a9fdb7ab70e1270520712ba3e9aa7d8", "filename": "gcc/testsuite/g++.dg/asan/sanitizer_test_config.h", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fsanitizer_test_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fsanitizer_test_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fsanitizer_test_config.h?ref=8465be9f1d5755379686743fb33aafbbfd77dfb3", "patch": "@@ -0,0 +1,28 @@\n+//===-- sanitizer_test_config.h ---------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of *Sanitizer runtime.\n+//\n+//===----------------------------------------------------------------------===//\n+#if !defined(INCLUDED_FROM_SANITIZER_TEST_UTILS_H)\n+# error \"This file should be included into sanitizer_test_utils.h only\"\n+#endif\n+\n+#ifndef SANITIZER_TEST_CONFIG_H\n+#define SANITIZER_TEST_CONFIG_H\n+\n+#include <vector>\n+#include <string>\n+#include <map>\n+\n+#if SANITIZER_USE_DEJAGNU_GTEST\n+# include \"dejagnu-gtest.h\"\n+#else\n+# include \"gtest/gtest.h\"\n+#endif\n+\n+#endif  // SANITIZER_TEST_CONFIG_H"}, {"sha": "b118de1d3461b30b0ddb0929a71011d88ce1a6ba", "filename": "gcc/testsuite/g++.dg/asan/sanitizer_test_utils.h", "status": "modified", "additions": 57, "deletions": 17, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fsanitizer_test_utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8465be9f1d5755379686743fb33aafbbfd77dfb3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fsanitizer_test_utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fsanitizer_test_utils.h?ref=8465be9f1d5755379686743fb33aafbbfd77dfb3", "patch": "@@ -14,32 +14,47 @@\n #define SANITIZER_TEST_UTILS_H\n \n #if defined(_WIN32)\n-typedef unsigned __int8  uint8_t;\n-typedef unsigned __int16 uint16_t;\n-typedef unsigned __int32 uint32_t;\n-typedef unsigned __int64 uint64_t;\n-typedef __int8           int8_t;\n-typedef __int16          int16_t;\n-typedef __int32          int32_t;\n-typedef __int64          int64_t;\n+// <windows.h> should always be the first include on Windows.\n+# include <windows.h>\n+// MSVS headers define max/min as macros, so std::max/min gets crazy.\n+# undef max\n+# undef min\n+#endif\n+\n+#if !defined(SANITIZER_EXTERNAL_TEST_CONFIG)\n+# define INCLUDED_FROM_SANITIZER_TEST_UTILS_H\n+# include \"sanitizer_test_config.h\"\n+# undef INCLUDED_FROM_SANITIZER_TEST_UTILS_H\n+#endif\n+\n+#include <stdint.h>\n+\n+#if defined(_MSC_VER)\n # define NOINLINE __declspec(noinline)\n-# define USED\n-#else  // defined(_WIN32)\n+#else  // defined(_MSC_VER)\n # define NOINLINE __attribute__((noinline))\n+#endif  // defined(_MSC_VER)\n+\n+#if !defined(_MSC_VER) || defined(__clang__)\n+# define UNUSED __attribute__((unused))\n # define USED __attribute__((used))\n-#include <stdint.h>\n-#endif  // defined(_WIN32)\n+#else\n+# define UNUSED\n+# define USED\n+#endif\n \n #if !defined(__has_feature)\n #define __has_feature(x) 0\n #endif\n \n-#if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)\n-# define ATTRIBUTE_NO_ADDRESS_SAFETY_ANALYSIS \\\n+#ifndef ATTRIBUTE_NO_SANITIZE_ADDRESS\n+# if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)\n+#  define ATTRIBUTE_NO_SANITIZE_ADDRESS \\\n     __attribute__((no_sanitize_address))\n-#else\n-# define ATTRIBUTE_NO_ADDRESS_SAFETY_ANALYSIS\n-#endif\n+# else\n+#  define ATTRIBUTE_NO_SANITIZE_ADDRESS\n+# endif\n+#endif  // ATTRIBUTE_NO_SANITIZE_ADDRESS\n \n #if __LP64__ || defined(_WIN64)\n #  define SANITIZER_WORDSIZE 64\n@@ -49,7 +64,9 @@ typedef __int64          int64_t;\n \n // Make the compiler thinks that something is going on there.\n inline void break_optimization(void *arg) {\n+#if !defined(_WIN32) || defined(__clang__)\n   __asm__ __volatile__(\"\" : : \"r\" (arg) : \"memory\");\n+#endif\n }\n \n // This function returns its parameter but in such a way that compiler\n@@ -74,5 +91,28 @@ static inline uint32_t my_rand() {\n   return my_rand_r(&global_seed);\n }\n \n+// Set availability of platform-specific functions.\n+\n+#if !defined(__APPLE__) && !defined(ANDROID) && !defined(__ANDROID__) && !defined(_WIN32)\n+# define SANITIZER_TEST_HAS_POSIX_MEMALIGN 1\n+#else\n+# define SANITIZER_TEST_HAS_POSIX_MEMALIGN 0\n+#endif\n+\n+#if !defined(__APPLE__) && !defined(__FreeBSD__) && !defined(_WIN32)\n+# define SANITIZER_TEST_HAS_MEMALIGN 1\n+# define SANITIZER_TEST_HAS_PVALLOC 1\n+# define SANITIZER_TEST_HAS_MALLOC_USABLE_SIZE 1\n+#else\n+# define SANITIZER_TEST_HAS_MEMALIGN 0\n+# define SANITIZER_TEST_HAS_PVALLOC 0\n+# define SANITIZER_TEST_HAS_MALLOC_USABLE_SIZE 0\n+#endif\n+\n+#if !defined(__APPLE__)\n+# define SANITIZER_TEST_HAS_STRNLEN 1\n+#else\n+# define SANITIZER_TEST_HAS_STRNLEN 0\n+#endif\n \n #endif  // SANITIZER_TEST_UTILS_H"}]}