{"sha": "056775650ac086fb069e00415bf262e22f7579c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU2Nzc1NjUwYWMwODZmYjA2OWUwMDQxNWJmMjYyZTIyZjc1NzljNQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-12-04T08:23:40Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-12-04T08:23:40Z"}, "message": "re PR tree-optimization/88315 (SAD and DOT_PROD SLP reductions with initial value != 0 create wrong code)\n\n2018-12-04  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/88315\n\t* tree-vect-loop.c (get_initial_defs_for_reduction): Simplify\n\tand fix initialization vector for SAD and DOT_PROD SLP reductions.\n\n\t* gcc.dg/vect/slp-reduc-sad.c: Adjust to provide non-trivial\n\tinitial value.\n\nFrom-SVN: r266771", "tree": {"sha": "3778a07ed12e95342c549c938b887ca48a910c6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3778a07ed12e95342c549c938b887ca48a910c6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/056775650ac086fb069e00415bf262e22f7579c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/056775650ac086fb069e00415bf262e22f7579c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/056775650ac086fb069e00415bf262e22f7579c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/056775650ac086fb069e00415bf262e22f7579c5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4b8caa08fec515d6484de0af239bb3069c975ed3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b8caa08fec515d6484de0af239bb3069c975ed3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b8caa08fec515d6484de0af239bb3069c975ed3"}], "stats": {"total": 183, "additions": 77, "deletions": 106}, "files": [{"sha": "335caf63854043fb88fa4f00761759ff8e1e1af2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/056775650ac086fb069e00415bf262e22f7579c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/056775650ac086fb069e00415bf262e22f7579c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=056775650ac086fb069e00415bf262e22f7579c5", "patch": "@@ -1,3 +1,9 @@\n+2018-12-04  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/88315\n+\t* tree-vect-loop.c (get_initial_defs_for_reduction): Simplify\n+\tand fix initialization vector for SAD and DOT_PROD SLP reductions.\n+\n 2018-12-03  Sandra Loosemore  <sandra@codesourcery.com>\n \n \tPR c/59039"}, {"sha": "edd24f2e83415c8bba1474373153afa21e8a0b1a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/056775650ac086fb069e00415bf262e22f7579c5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/056775650ac086fb069e00415bf262e22f7579c5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=056775650ac086fb069e00415bf262e22f7579c5", "patch": "@@ -1,3 +1,9 @@\n+2018-12-04  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/88315\n+\t* gcc.dg/vect/slp-reduc-sad.c: Adjust to provide non-trivial\n+\tinitial value.\n+\n 2018-12-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/64242"}, {"sha": "5f7a3e09f60cec6c4559d5ddf648f6954febbd1a", "filename": "gcc/testsuite/gcc.dg/vect/slp-reduc-sad.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/056775650ac086fb069e00415bf262e22f7579c5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-sad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/056775650ac086fb069e00415bf262e22f7579c5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-sad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-reduc-sad.c?ref=056775650ac086fb069e00415bf262e22f7579c5", "patch": "@@ -12,7 +12,7 @@ extern void abort (void);\n int __attribute__((noinline,noclone))\n foo (uint8_t *pix1, uint8_t *pix2, int i_stride_pix2)\n {\n-  int i_sum = 0;\n+  int i_sum = 5;\n   for( int y = 0; y < 16; y++ )\n     {\n       i_sum += abs ( pix1[0] - pix2[0] );\n@@ -52,7 +52,7 @@ main ()\n       __asm__ volatile (\"\");\n     }\n \n-  if (foo (X, Y, 16) != 32512)\n+  if (foo (X, Y, 16) != 32512 + 5)\n     abort ();\n \n   return 0;"}, {"sha": "fa926f4ebb5b4307b1b4e614056e5ba9bf2f4c9a", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 63, "deletions": 104, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/056775650ac086fb069e00415bf262e22f7579c5/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/056775650ac086fb069e00415bf262e22f7579c5/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=056775650ac086fb069e00415bf262e22f7579c5", "patch": "@@ -4100,12 +4100,8 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n   unsigned HOST_WIDE_INT nunits;\n   unsigned j, number_of_places_left_in_vector;\n   tree vector_type;\n-  tree vop;\n-  int group_size = stmts.length ();\n-  unsigned int vec_num, i;\n-  unsigned number_of_copies = 1;\n-  vec<tree> voprnds;\n-  voprnds.create (number_of_vectors);\n+  unsigned int group_size = stmts.length ();\n+  unsigned int i;\n   struct loop *loop;\n   auto_vec<tree, 16> permute_results;\n \n@@ -4138,115 +4134,78 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n   if (!TYPE_VECTOR_SUBPARTS (vector_type).is_constant (&nunits))\n     nunits = group_size;\n \n-  number_of_copies = nunits * number_of_vectors / group_size;\n-\n   number_of_places_left_in_vector = nunits;\n   bool constant_p = true;\n   tree_vector_builder elts (vector_type, nunits, 1);\n   elts.quick_grow (nunits);\n-  for (j = 0; j < number_of_copies; j++)\n+  for (j = 0; j < nunits * number_of_vectors; ++j)\n     {\n-      for (i = group_size - 1; stmts.iterate (i, &stmt_vinfo); i--)\n-        {\n-\t  tree op;\n-\t  /* Get the def before the loop.  In reduction chain we have only\n-\t     one initial value.  */\n-\t  if ((j != (number_of_copies - 1)\n-\t       || (reduc_chain && i != 0))\n-\t      && neutral_op)\n-\t    op = neutral_op;\n-\t  else\n-\t    op = PHI_ARG_DEF_FROM_EDGE (stmt_vinfo->stmt, pe);\n+      tree op;\n+      i = j % group_size;\n+      stmt_vinfo = stmts[i];\n \n-          /* Create 'vect_ = {op0,op1,...,opn}'.  */\n-          number_of_places_left_in_vector--;\n-\t  elts[number_of_places_left_in_vector] = op;\n-\t  if (!CONSTANT_CLASS_P (op))\n-\t    constant_p = false;\n+      /* Get the def before the loop.  In reduction chain we have only\n+\t one initial value.  Else we have as many as PHIs in the group.  */\n+      if (reduc_chain)\n+\top = j != 0 ? neutral_op : PHI_ARG_DEF_FROM_EDGE (stmt_vinfo->stmt, pe);\n+      else if (((vec_oprnds->length () + 1) * nunits\n+\t\t- number_of_places_left_in_vector >= group_size)\n+\t       && neutral_op)\n+\top = neutral_op;\n+      else\n+\top = PHI_ARG_DEF_FROM_EDGE (stmt_vinfo->stmt, pe);\n \n-          if (number_of_places_left_in_vector == 0)\n-            {\n-\t      gimple_seq ctor_seq = NULL;\n-\t      tree init;\n-\t      if (constant_p && !neutral_op\n-\t\t  ? multiple_p (TYPE_VECTOR_SUBPARTS (vector_type), nunits)\n-\t\t  : known_eq (TYPE_VECTOR_SUBPARTS (vector_type), nunits))\n-\t\t/* Build the vector directly from ELTS.  */\n-\t\tinit = gimple_build_vector (&ctor_seq, &elts);\n-\t      else if (neutral_op)\n-\t\t{\n-\t\t  /* Build a vector of the neutral value and shift the\n-\t\t     other elements into place.  */\n-\t\t  init = gimple_build_vector_from_val (&ctor_seq, vector_type,\n-\t\t\t\t\t\t       neutral_op);\n-\t\t  int k = nunits;\n-\t\t  while (k > 0 && elts[k - 1] == neutral_op)\n-\t\t    k -= 1;\n-\t\t  while (k > 0)\n-\t\t    {\n-\t\t      k -= 1;\n-\t\t      init = gimple_build (&ctor_seq, CFN_VEC_SHL_INSERT,\n-\t\t\t\t\t   vector_type, init, elts[k]);\n-\t\t    }\n-\t\t}\n-\t      else\n+      /* Create 'vect_ = {op0,op1,...,opn}'.  */\n+      number_of_places_left_in_vector--;\n+      elts[nunits - number_of_places_left_in_vector - 1] = op;\n+      if (!CONSTANT_CLASS_P (op))\n+\tconstant_p = false;\n+\n+      if (number_of_places_left_in_vector == 0)\n+\t{\n+\t  gimple_seq ctor_seq = NULL;\n+\t  tree init;\n+\t  if (constant_p && !neutral_op\n+\t      ? multiple_p (TYPE_VECTOR_SUBPARTS (vector_type), nunits)\n+\t      : known_eq (TYPE_VECTOR_SUBPARTS (vector_type), nunits))\n+\t    /* Build the vector directly from ELTS.  */\n+\t    init = gimple_build_vector (&ctor_seq, &elts);\n+\t  else if (neutral_op)\n+\t    {\n+\t      /* Build a vector of the neutral value and shift the\n+\t\t other elements into place.  */\n+\t      init = gimple_build_vector_from_val (&ctor_seq, vector_type,\n+\t\t\t\t\t\t   neutral_op);\n+\t      int k = nunits;\n+\t      while (k > 0 && elts[k - 1] == neutral_op)\n+\t\tk -= 1;\n+\t      while (k > 0)\n \t\t{\n-\t\t  /* First time round, duplicate ELTS to fill the\n-\t\t     required number of vectors, then cherry pick the\n-\t\t     appropriate result for each iteration.  */\n-\t\t  if (vec_oprnds->is_empty ())\n-\t\t    duplicate_and_interleave (&ctor_seq, vector_type, elts,\n-\t\t\t\t\t      number_of_vectors,\n-\t\t\t\t\t      permute_results);\n-\t\t  init = permute_results[number_of_vectors - j - 1];\n+\t\t  k -= 1;\n+\t\t  init = gimple_build (&ctor_seq, CFN_VEC_SHL_INSERT,\n+\t\t\t\t       vector_type, init, elts[k]);\n \t\t}\n-\t      if (ctor_seq != NULL)\n-\t\tgsi_insert_seq_on_edge_immediate (pe, ctor_seq);\n-\t      voprnds.quick_push (init);\n-\n-              number_of_places_left_in_vector = nunits;\n-\t      elts.new_vector (vector_type, nunits, 1);\n-\t      elts.quick_grow (nunits);\n-\t      constant_p = true;\n-            }\n-        }\n-    }\n-\n-  /* Since the vectors are created in the reverse order, we should invert\n-     them.  */\n-  vec_num = voprnds.length ();\n-  for (j = vec_num; j != 0; j--)\n-    {\n-      vop = voprnds[j - 1];\n-      vec_oprnds->quick_push (vop);\n-    }\n-\n-  voprnds.release ();\n-\n-  /* In case that VF is greater than the unrolling factor needed for the SLP\n-     group of stmts, NUMBER_OF_VECTORS to be created is greater than\n-     NUMBER_OF_SCALARS/NUNITS or NUNITS/NUMBER_OF_SCALARS, and hence we have\n-     to replicate the vectors.  */\n-  tree neutral_vec = NULL;\n-  while (number_of_vectors > vec_oprnds->length ())\n-    {\n-      if (neutral_op)\n-        {\n-          if (!neutral_vec)\n+\t    }\n+\t  else\n \t    {\n-\t      gimple_seq ctor_seq = NULL;\n-\t      neutral_vec = gimple_build_vector_from_val\n-\t\t(&ctor_seq, vector_type, neutral_op);\n-\t      if (ctor_seq != NULL)\n-\t\tgsi_insert_seq_on_edge_immediate (pe, ctor_seq);\n+\t      /* First time round, duplicate ELTS to fill the\n+\t\t required number of vectors, then cherry pick the\n+\t\t appropriate result for each iteration.  */\n+\t      if (vec_oprnds->is_empty ())\n+\t\tduplicate_and_interleave (&ctor_seq, vector_type, elts,\n+\t\t\t\t\t  number_of_vectors,\n+\t\t\t\t\t  permute_results);\n+\t      init = permute_results[number_of_vectors - j - 1];\n \t    }\n-          vec_oprnds->quick_push (neutral_vec);\n-        }\n-      else\n-        {\n-          for (i = 0; vec_oprnds->iterate (i, &vop) && i < vec_num; i++)\n-            vec_oprnds->quick_push (vop);\n-        }\n+\t  if (ctor_seq != NULL)\n+\t    gsi_insert_seq_on_edge_immediate (pe, ctor_seq);\n+\t  vec_oprnds->quick_push (init);\n+\n+\t  number_of_places_left_in_vector = nunits;\n+\t  elts.new_vector (vector_type, nunits, 1);\n+\t  elts.quick_grow (nunits);\n+\t  constant_p = true;\n+\t}\n     }\n }\n "}]}