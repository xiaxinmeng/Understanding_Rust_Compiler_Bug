{"sha": "4b0f6ee8b58dedc18192933e35f81b2b71d44fe7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIwZjZlZThiNThkZWRjMTgxOTI5MzNlMzVmODFiMmI3MWQ0NGZlNw==", "commit": {"author": {"name": "Joffrey Huguet", "email": "huguet@adacore.com", "date": "2019-08-14T09:52:58Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-08-14T09:52:58Z"}, "message": "[Ada] Improve performance of Containers.Functional_Base\n\nThis patch modifies the implementation of Functional_Base to damp the\ncost of its subprograms at runtime in specific cases. Instead of copying\nthe entire underlying array to create a new container, containers can\nshare the same Array_Base attribute. Performance on common use cases of\nformal and functional containers is improved with this patch.\n\n2019-08-14  Joffrey Huguet  <huguet@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/a-cofuba.ads: Add a Length attribute to type\n\tContainer. Add a type Array_Base which replaces the previous\n\tElements attribute of Container.\n\t(Content_Init): New subprogram. It is used to initialize the\n\tBase attribute of Container.\n\t* libgnat/a-cofuba.adb (Resize): New subprogram. It is used to\n\tresize the underlying array of a container if necessary.\n\t(=, <=, Find, Get, Intersection, Length, Num_Overlaps, Set,\n\tUnion): Update to match changes in type declarations.\n\t(Add): Modify body to damp the time and space cost in a specific\n\tcase.\n\t(Content_Init): New subprogram. It is used to initialize the\n\tBase attribute of Container.\n\t(Remove): Modify body to damp the time and space cost in a\n\tspecific case.\n\nFrom-SVN: r274474", "tree": {"sha": "bbb97fab40b6429d3c36b9ea1850eba416b81cf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbb97fab40b6429d3c36b9ea1850eba416b81cf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b0f6ee8b58dedc18192933e35f81b2b71d44fe7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b0f6ee8b58dedc18192933e35f81b2b71d44fe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b0f6ee8b58dedc18192933e35f81b2b71d44fe7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b0f6ee8b58dedc18192933e35f81b2b71d44fe7/comments", "author": {"login": "joffreyhuguet", "id": 36951399, "node_id": "MDQ6VXNlcjM2OTUxMzk5", "avatar_url": "https://avatars.githubusercontent.com/u/36951399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joffreyhuguet", "html_url": "https://github.com/joffreyhuguet", "followers_url": "https://api.github.com/users/joffreyhuguet/followers", "following_url": "https://api.github.com/users/joffreyhuguet/following{/other_user}", "gists_url": "https://api.github.com/users/joffreyhuguet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joffreyhuguet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joffreyhuguet/subscriptions", "organizations_url": "https://api.github.com/users/joffreyhuguet/orgs", "repos_url": "https://api.github.com/users/joffreyhuguet/repos", "events_url": "https://api.github.com/users/joffreyhuguet/events{/privacy}", "received_events_url": "https://api.github.com/users/joffreyhuguet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ff0889eb4d7f34270a6cddb3351fe8ee4fc9bbe0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff0889eb4d7f34270a6cddb3351fe8ee4fc9bbe0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff0889eb4d7f34270a6cddb3351fe8ee4fc9bbe0"}], "stats": {"total": 214, "additions": 160, "deletions": 54}, "files": [{"sha": "2c4e0269e83d87fe078030ebcad95146fade26b4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0f6ee8b58dedc18192933e35f81b2b71d44fe7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0f6ee8b58dedc18192933e35f81b2b71d44fe7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4b0f6ee8b58dedc18192933e35f81b2b71d44fe7", "patch": "@@ -1,3 +1,21 @@\n+2019-08-14  Joffrey Huguet  <huguet@adacore.com>\n+\n+\t* libgnat/a-cofuba.ads: Add a Length attribute to type\n+\tContainer. Add a type Array_Base which replaces the previous\n+\tElements attribute of Container.\n+\t(Content_Init): New subprogram. It is used to initialize the\n+\tBase attribute of Container.\n+\t* libgnat/a-cofuba.adb (Resize): New subprogram. It is used to\n+\tresize the underlying array of a container if necessary.\n+\t(=, <=, Find, Get, Intersection, Length, Num_Overlaps, Set,\n+\tUnion): Update to match changes in type declarations.\n+\t(Add): Modify body to damp the time and space cost in a specific\n+\tcase.\n+\t(Content_Init): New subprogram. It is used to initialize the\n+\tBase attribute of Container.\n+\t(Remove): Modify body to damp the time and space cost in a\n+\tspecific case.\n+\n 2019-08-14  Bob Duff  <duff@adacore.com>\n \n \t* sem_ch13.adb (Get_Alignment_Value): Return 1 for Alignment 0,"}, {"sha": "5c5f48813a91a8ec175018f351368ba879340f45", "filename": "gcc/ada/libgnat/a-cofuba.adb", "status": "modified", "additions": 127, "deletions": 52, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0f6ee8b58dedc18192933e35f81b2b71d44fe7/gcc%2Fada%2Flibgnat%2Fa-cofuba.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0f6ee8b58dedc18192933e35f81b2b71d44fe7/gcc%2Fada%2Flibgnat%2Fa-cofuba.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuba.adb?ref=4b0f6ee8b58dedc18192933e35f81b2b71d44fe7", "patch": "@@ -30,6 +30,7 @@\n ------------------------------------------------------------------------------\n \n pragma Ada_2012;\n+with Ada.Unchecked_Deallocation;\n \n package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n \n@@ -47,18 +48,22 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n    --  Search a container C for an element equal to E.all, returning the\n    --  position in the underlying array.\n \n+   procedure Resize (Base : Array_Base_Access);\n+   --  Resize the underlying array if needed so that it can contain one more\n+   --  element.\n+\n    ---------\n    -- \"=\" --\n    ---------\n \n    function \"=\" (C1 : Container; C2 : Container) return Boolean is\n    begin\n-      if C1.Elements'Length /= C2.Elements'Length then\n+      if C1.Length /= C2.Length then\n          return False;\n       end if;\n \n-      for I in C1.Elements'Range loop\n-         if C1.Elements (I).all /= C2.Elements (I).all then\n+      for I in 1 .. C1.Length loop\n+         if C1.Base.Elements (I).all /= C2.Base.Elements (I).all then\n             return False;\n          end if;\n       end loop;\n@@ -72,8 +77,8 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n \n    function \"<=\" (C1 : Container; C2 : Container) return Boolean is\n    begin\n-      for I in C1.Elements'Range loop\n-         if Find (C2, C1.Elements (I)) = 0 then\n+      for I in 1 .. C1.Length loop\n+         if Find (C2, C1.Base.Elements (I)) = 0 then\n             return False;\n          end if;\n       end loop;\n@@ -90,31 +95,58 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n       I : Index_Type;\n       E : Element_Type) return Container\n    is\n-      A : constant Element_Array_Access :=\n-            new Element_Array'(1 .. C.Elements'Last + 1 => <>);\n-      P : Count_Type := 0;\n-\n    begin\n-      for J in 1 .. C.Elements'Last + 1 loop\n-         if J /= To_Count (I) then\n-            P := P + 1;\n-            A (J) := C.Elements (P);\n-         else\n-            A (J) := new Element_Type'(E);\n-         end if;\n-      end loop;\n-\n-      return Container'(Elements => A);\n+      if To_Count (I) = C.Length + 1 and then C.Length = C.Base.Max_Length then\n+         Resize (C.Base);\n+         C.Base.Max_Length := C.Base.Max_Length + 1;\n+         C.Base.Elements (C.Base.Max_Length) := new Element_Type'(E);\n+\n+         return Container'(Length => C.Base.Max_Length, Base => C.Base);\n+      else\n+         declare\n+            A : constant Array_Base_Access := Content_Init (C.Length);\n+            P : Count_Type := 0;\n+         begin\n+            A.Max_Length := C.Length + 1;\n+            for J in 1 .. C.Length + 1 loop\n+               if J /= To_Count (I) then\n+                  P := P + 1;\n+                  A.Elements (J) := C.Base.Elements (P);\n+               else\n+                  A.Elements (J) := new Element_Type'(E);\n+               end if;\n+            end loop;\n+\n+            return Container'(Length => A.Max_Length,\n+                              Base   => A);\n+         end;\n+      end if;\n    end Add;\n \n+   ------------------\n+   -- Content_Init --\n+   ------------------\n+\n+   function Content_Init (L : Count_Type := 0) return Array_Base_Access\n+   is\n+      Max_Init : constant Count_Type := 100;\n+      Size     : constant Count_Type :=\n+        (if L < Count_Type'Last - Max_Init then L + Max_Init\n+         else Count_Type'Last);\n+      Elements : constant Element_Array_Access :=\n+        new Element_Array'(1 .. Size => <>);\n+   begin\n+      return new Array_Base'(Max_Length => 0, Elements => Elements);\n+   end Content_Init;\n+\n    ----------\n    -- Find --\n    ----------\n \n    function Find (C : Container; E : access Element_Type) return Count_Type is\n    begin\n-      for I in C.Elements'Range loop\n-         if C.Elements (I).all = E.all then\n+      for I in 1 .. C.Length loop\n+         if C.Base.Elements (I).all = E.all then\n             return I;\n          end if;\n       end loop;\n@@ -130,34 +162,34 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n    ---------\n \n    function Get (C : Container; I : Index_Type) return Element_Type is\n-     (C.Elements (To_Count (I)).all);\n+     (C.Base.Elements (To_Count (I)).all);\n \n    ------------------\n    -- Intersection --\n    ------------------\n \n    function Intersection (C1 : Container; C2 : Container) return Container is\n-      A : constant Element_Array_Access :=\n-            new Element_Array'(1 .. Num_Overlaps (C1, C2) => <>);\n+      L : constant Count_Type := Num_Overlaps (C1, C2);\n+      A : constant Array_Base_Access := Content_Init (L);\n       P : Count_Type := 0;\n \n    begin\n-      for I in C1.Elements'Range loop\n-         if Find (C2, C1.Elements (I)) > 0 then\n+      A.Max_Length := L;\n+      for I in 1 .. C1.Length loop\n+         if Find (C2, C1.Base.Elements (I)) > 0 then\n             P := P + 1;\n-            A (P) := C1.Elements (I);\n+            A.Elements (P) := C1.Base.Elements (I);\n          end if;\n       end loop;\n \n-      return Container'(Elements => A);\n+      return Container'(Length => P, Base => A);\n    end Intersection;\n \n    ------------\n    -- Length --\n    ------------\n \n-   function Length (C : Container) return Count_Type is (C.Elements'Length);\n-\n+   function Length (C : Container) return Count_Type is (C.Length);\n    ---------------------\n    -- Num_Overlaps --\n    ---------------------\n@@ -166,8 +198,8 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n       P : Count_Type := 0;\n \n    begin\n-      for I in C1.Elements'Range loop\n-         if Find (C2, C1.Elements (I)) > 0 then\n+      for I in 1 .. C1.Length loop\n+         if Find (C2, C1.Base.Elements (I)) > 0 then\n             P := P + 1;\n          end if;\n       end loop;\n@@ -180,20 +212,60 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n    ------------\n \n    function Remove (C : Container; I : Index_Type) return Container is\n-      A : constant Element_Array_Access :=\n-            new Element_Array'(1 .. C.Elements'Last - 1 => <>);\n-      P : Count_Type := 0;\n+   begin\n+      if To_Count (I) = C.Length then\n+         return Container'(Length => C.Length - 1, Base => C.Base);\n+      else\n+         declare\n+            A : constant Array_Base_Access := Content_Init (C.Length - 1);\n+            P : Count_Type := 0;\n+         begin\n+            A.Max_Length := C.Length - 1;\n+            for J in 1 .. C.Length loop\n+               if J /= To_Count (I) then\n+                  P := P + 1;\n+                  A.Elements (P) := C.Base.Elements (J);\n+               end if;\n+            end loop;\n+\n+            return Container'(Length => C.Length - 1, Base => A);\n+         end;\n+      end if;\n+   end Remove;\n+\n+   ------------\n+   -- Resize --\n+   ------------\n \n+   procedure Resize (Base : Array_Base_Access) is\n    begin\n-      for J in C.Elements'Range loop\n-         if J /= To_Count (I) then\n-            P := P + 1;\n-            A (P) := C.Elements (J);\n-         end if;\n-      end loop;\n+      if Base.Max_Length < Base.Elements'Length then\n+         return;\n+      end if;\n \n-      return Container'(Elements => A);\n-   end Remove;\n+      pragma Assert (Base.Max_Length = Base.Elements'Length);\n+\n+      if Base.Max_Length = Count_Type'Last then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         procedure Finalize is new Ada.Unchecked_Deallocation\n+           (Object => Element_Array,\n+            Name   => Element_Array_Access_Base);\n+\n+         New_Length : constant Positive_Count_Type :=\n+           (if Base.Max_Length > Count_Type'Last / 2 then Count_Type'Last\n+            else 2 * Base.Max_Length);\n+         Elements   : constant Element_Array_Access :=\n+           new Element_Array (1 .. New_Length);\n+         Old_Elmts  : Element_Array_Access_Base := Base.Elements;\n+      begin\n+         Elements (1 .. Base.Max_Length) := Base.Elements.all;\n+         Base.Elements := Elements;\n+         Finalize (Old_Elmts);\n+      end;\n+   end Resize;\n \n    ---------\n    -- Set --\n@@ -205,10 +277,13 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n       E : Element_Type) return Container\n    is\n       Result : constant Container :=\n-                 Container'(Elements => new Element_Array'(C.Elements.all));\n+                 Container'(Length => C.Length,\n+                            Base => Content_Init (C.Length));\n \n    begin\n-      Result.Elements (To_Count (I)) := new Element_Type'(E);\n+      Result.Base.Max_Length := C.Length;\n+      Result.Base.Elements (1 .. C.Length) := C.Base.Elements (1 .. C.Length);\n+      Result.Base.Elements (To_Count (I)) := new Element_Type'(E);\n       return Result;\n    end Set;\n \n@@ -230,20 +305,20 @@ package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n \n       declare\n          L : constant Count_Type := Length (C1) - N + Length (C2);\n-         A : constant Element_Array_Access :=\n-               new Element_Array'\n-                     (C1.Elements.all & (Length (C1) + 1 .. L => <>));\n+         A : constant Array_Base_Access := Content_Init (L);\n          P : Count_Type := Length (C1);\n \n       begin\n-         for I in C2.Elements'Range loop\n-            if Find (C1, C2.Elements (I)) = 0 then\n+         A.Max_Length := L;\n+         A.Elements (1 .. C1.Length) := C1.Base.Elements (1 .. C1.Length);\n+         for I in 1 .. C2.Length loop\n+            if Find (C1, C2.Base.Elements (I)) = 0 then\n                P := P + 1;\n-               A (P) := C2.Elements (I);\n+               A.Elements (P) := C2.Base.Elements (I);\n             end if;\n          end loop;\n \n-         return Container'(Elements => A);\n+         return Container'(Length => L, Base => A);\n       end;\n    end Union;\n "}, {"sha": "b693baaf52f9c74544d8e68549083d9da76bf77b", "filename": "gcc/ada/libgnat/a-cofuba.ads", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b0f6ee8b58dedc18192933e35f81b2b71d44fe7/gcc%2Fada%2Flibgnat%2Fa-cofuba.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b0f6ee8b58dedc18192933e35f81b2b71d44fe7/gcc%2Fada%2Flibgnat%2Fa-cofuba.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuba.ads?ref=4b0f6ee8b58dedc18192933e35f81b2b71d44fe7", "patch": "@@ -105,13 +105,26 @@ private\n    type Element_Array is\n      array (Positive_Count_Type range <>) of Element_Access;\n \n-   type Element_Array_Access is not null access Element_Array;\n+   type Element_Array_Access_Base is access Element_Array;\n+\n+   subtype Element_Array_Access is not null Element_Array_Access_Base;\n \n    Empty_Element_Array_Access : constant Element_Array_Access :=\n      new Element_Array'(1 .. 0 => null);\n \n+   type Array_Base is record\n+     Max_Length : Count_Type;\n+     Elements   : Element_Array_Access;\n+   end record;\n+\n+   type Array_Base_Access is not null access Array_Base;\n+\n+   function Content_Init (L : Count_Type := 0) return Array_Base_Access;\n+   --  Used to initialize the content of an array base with length L\n+\n    type Container is record\n-      Elements : Element_Array_Access := Empty_Element_Array_Access;\n+      Length : Count_Type := 0;\n+      Base   : Array_Base_Access := Content_Init;\n    end record;\n \n end Ada.Containers.Functional_Base;"}]}