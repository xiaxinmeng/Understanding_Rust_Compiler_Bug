{"sha": "c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVlODhiMzk5YzUyNmRiYjdhYjJiYzZiNGZkYmMwZTgxMDBmYTNkOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2010-06-10T20:21:44Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2010-06-10T20:21:44Z"}, "message": "read-md.h (read_md_file): Declare.\n\ngcc/\n\t* read-md.h (read_md_file): Declare.\n\t(read_char, unread_char): New functions.\n\t(fatal_with_file_and_line, fatal_expected_char, read_skip_spaces)\n\t(read_quoted_string, read_string): Remove FILE * argument.\n\t* read-md.c (read_md_file): New variable.\n\t(read_md_filename, read_md_lineno): Update comments and remove\n\tunnecessary initialization.\n\t(fatal_with_file_and_line, fatal_expected_char, read_skip_spaces)\n\t(read_escape, read_quoted_string, read_braced_string, read_string):\n\tRemove FILE * argument.  Update calls accordingly, using read_char\n\tand unread_char instead of getc and ungetc.\n\t* rtl.h (read_rtx): Remove FILE * argument.\n\t* read-rtl.c (iterator_group): Remove FILE * argument from\n\t\"find_builtin\".\n\t(iterator_traverse_data): Remove \"infile\" field.\n\t(find_mode, find_code, apply_mode_maps, apply_iterator_to_rtx)\n\t(add_mapping, read_name, read_constants, read_conditions)\n\t(validate_const_int, find_iterator, read_mapping, check_code_iterator)\n\t(read_rtx, read_rtx_1, read_rtx_variadic): Remove FILE * argument.\n\tRemove file arguments from all calls, using read_char and unread_char\n\tinstead of getc and ungetc.\n\t* gensupport.c (process_include): Preserve read_md_file around\n\tthe include.  Set read_md_file to the handle of the included file.\n\tUpdate call to read_rtx.\n\t(init_md_reader_args_cb): Set read_md_file to the handle of the file\n\tand remove local FILE *.  Update calls to read_rtx.\n\nFrom-SVN: r160572", "tree": {"sha": "cf86a2e45130a51690d5994f074ff828e9d308ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf86a2e45130a51690d5994f074ff828e9d308ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d2a3ce4e3374de54b231d98bd78613c8dc18d9a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2a3ce4e3374de54b231d98bd78613c8dc18d9a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2a3ce4e3374de54b231d98bd78613c8dc18d9a4"}], "stats": {"total": 476, "additions": 255, "deletions": 221}, "files": [{"sha": "26aafe8f8ea9c8723e1d5dee528d472e44168e22", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9", "patch": "@@ -1,3 +1,32 @@\n+2010-06-10  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* read-md.h (read_md_file): Declare.\n+\t(read_char, unread_char): New functions.\n+\t(fatal_with_file_and_line, fatal_expected_char, read_skip_spaces)\n+\t(read_quoted_string, read_string): Remove FILE * argument.\n+\t* read-md.c (read_md_file): New variable.\n+\t(read_md_filename, read_md_lineno): Update comments and remove\n+\tunnecessary initialization.\n+\t(fatal_with_file_and_line, fatal_expected_char, read_skip_spaces)\n+\t(read_escape, read_quoted_string, read_braced_string, read_string):\n+\tRemove FILE * argument.  Update calls accordingly, using read_char\n+\tand unread_char instead of getc and ungetc.\n+\t* rtl.h (read_rtx): Remove FILE * argument.\n+\t* read-rtl.c (iterator_group): Remove FILE * argument from\n+\t\"find_builtin\".\n+\t(iterator_traverse_data): Remove \"infile\" field.\n+\t(find_mode, find_code, apply_mode_maps, apply_iterator_to_rtx)\n+\t(add_mapping, read_name, read_constants, read_conditions)\n+\t(validate_const_int, find_iterator, read_mapping, check_code_iterator)\n+\t(read_rtx, read_rtx_1, read_rtx_variadic): Remove FILE * argument.\n+\tRemove file arguments from all calls, using read_char and unread_char\n+\tinstead of getc and ungetc.\n+\t* gensupport.c (process_include): Preserve read_md_file around\n+\tthe include.  Set read_md_file to the handle of the included file.\n+\tUpdate call to read_rtx.\n+\t(init_md_reader_args_cb): Set read_md_file to the handle of the file\n+\tand remove local FILE *.  Update calls to read_rtx.\n+\n 2010-06-10  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* read-md.h (read_rtx_lineno): Rename to..."}, {"sha": "061376f55ea7b55c5e310f816b2e5f2ef52c5168", "filename": "gcc/gensupport.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9", "patch": "@@ -194,7 +194,7 @@ process_include (rtx desc, int lineno)\n   const char *old_filename;\n   int old_lineno;\n   char *pathname;\n-  FILE *input_file;\n+  FILE *input_file, *old_file;\n \n   /* If specified file name is absolute, skip the include stack.  */\n   if (! IS_ABSOLUTE_PATH (filename))\n@@ -231,21 +231,24 @@ process_include (rtx desc, int lineno)\n   /* Save old cursor; setup new for the new file.  Note that \"lineno\" the\n      argument to this function is the beginning of the include statement,\n      while read_md_lineno has already been advanced.  */\n+  old_file = read_md_file;\n   old_filename = read_md_filename;\n   old_lineno = read_md_lineno;\n+  read_md_file = input_file;\n   read_md_filename = pathname;\n   read_md_lineno = 1;\n \n   if (include_callback)\n     include_callback (pathname);\n \n   /* Read the entire file.  */\n-  while (read_rtx (input_file, &desc, &lineno))\n+  while (read_rtx (&desc, &lineno))\n     process_rtx (desc, lineno);\n \n   /* Do not free pathname.  It is attached to the various rtx queue\n      elements.  */\n \n+  read_md_file = old_file;\n   read_md_filename = old_filename;\n   read_md_lineno = old_lineno;\n \n@@ -902,7 +905,6 @@ save_string (const char *s, int len)\n int\n init_md_reader_args_cb (int argc, char **argv, bool (*parse_opt)(const char *))\n {\n-  FILE *input_file;\n   int c, i, lineno;\n   char *lastsl;\n   rtx desc;\n@@ -988,14 +990,14 @@ init_md_reader_args_cb (int argc, char **argv, bool (*parse_opt)(const char *))\n \t\tfatal (\"cannot read standard input twice\");\n \n \t      base_dir = NULL;\n+\t      read_md_file = stdin;\n \t      read_md_filename = in_fname = \"<stdin>\";\n \t      read_md_lineno = 1;\n-\t      input_file = stdin;\n \t      already_read_stdin = true;\n \n-\t      while (read_rtx (input_file, &desc, &lineno))\n+\t      while (read_rtx (&desc, &lineno))\n \t\tprocess_rtx (desc, lineno);\n-\t      fclose (input_file);\n+\t      fclose (read_md_file);\n \t      continue;\n \t    }\n \t  else if (argv[i][1] == '-' && argv[i][2] == '\\0')\n@@ -1018,32 +1020,32 @@ init_md_reader_args_cb (int argc, char **argv, bool (*parse_opt)(const char *))\n       else\n \tbase_dir = NULL;\n \n-      read_md_filename = in_fname;\n-      read_md_lineno = 1;\n-      input_file = fopen (in_fname, \"r\");\n-      if (input_file == 0)\n+      read_md_file = fopen (in_fname, \"r\");\n+      if (read_md_file == 0)\n \t{\n \t  perror (in_fname);\n \t  return FATAL_EXIT_CODE;\n \t}\n+      read_md_filename = in_fname;\n+      read_md_lineno = 1;\n \n-      while (read_rtx (input_file, &desc, &lineno))\n+      while (read_rtx (&desc, &lineno))\n \tprocess_rtx (desc, lineno);\n-      fclose (input_file);\n+      fclose (read_md_file);\n     }\n \n   /* If we get to this point without having seen any files to process,\n      read standard input now.  */\n   if (!in_fname)\n     {\n       base_dir = NULL;\n+      read_md_file = stdin;\n       read_md_filename = in_fname = \"<stdin>\";\n       read_md_lineno = 1;\n-      input_file = stdin;\n \n-      while (read_rtx (input_file, &desc, &lineno))\n+      while (read_rtx (&desc, &lineno))\n \tprocess_rtx (desc, lineno);\n-      fclose (input_file);\n+      fclose (read_md_file);\n     }\n \n   /* Process define_cond_exec patterns.  */"}, {"sha": "a8c0d5c251e17ea990b77b5ccbbfde029ceeb1c3", "filename": "gcc/read-md.c", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9/gcc%2Fread-md.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9/gcc%2Fread-md.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.c?ref=c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9", "patch": "@@ -52,11 +52,14 @@ static htab_t joined_conditions;\n /* An obstack for allocating joined_conditions entries.  */\n static struct obstack joined_conditions_obstack;\n \n-/* The current line number for the file.  */\n-int read_md_lineno = 1;\n+/* The file we are reading.  */\n+FILE *read_md_file;\n \n-/* The filename for error reporting.  */\n-const char *read_md_filename = \"<unknown>\";\n+/* The filename of READ_MD_FILE.  */\n+const char *read_md_filename;\n+\n+/* The current line number in READ_MD_FILE.  */\n+int read_md_lineno;\n \n /* Return a hash value for the pointer pointed to by DEF.  */\n \n@@ -189,10 +192,10 @@ message_with_line (int lineno, const char *msg, ...)\n }\n \n /* A printf-like function for reporting an error against the current\n-   position in the MD file, which is associated with INFILE.  */\n+   position in the MD file.  */\n \n void\n-fatal_with_file_and_line (FILE *infile, const char *msg, ...)\n+fatal_with_file_and_line (const char *msg, ...)\n {\n   char context[64];\n   size_t i;\n@@ -208,7 +211,7 @@ fatal_with_file_and_line (FILE *infile, const char *msg, ...)\n   /* Gather some following context.  */\n   for (i = 0; i < sizeof (context)-1; ++i)\n     {\n-      c = getc (infile);\n+      c = read_char ();\n       if (c == EOF)\n \tbreak;\n       if (c == '\\r' || c == '\\n')\n@@ -225,31 +228,30 @@ fatal_with_file_and_line (FILE *infile, const char *msg, ...)\n }\n \n /* Report that we found character ACTUAL when we expected to find\n-   character EXPECTED.  INFILE is the file handle associated\n-   with the current file.  */\n+   character EXPECTED.  */\n \n void\n-fatal_expected_char (FILE *infile, int expected, int actual)\n+fatal_expected_char (int expected, int actual)\n {\n   if (actual == EOF)\n-    fatal_with_file_and_line (infile, \"expected character `%c', found EOF\",\n+    fatal_with_file_and_line (\"expected character `%c', found EOF\",\n \t\t\t      expected);\n   else\n-    fatal_with_file_and_line (infile, \"expected character `%c', found `%c'\",\n+    fatal_with_file_and_line (\"expected character `%c', found `%c'\",\n \t\t\t      expected, actual);\n }\n \n-/* Read chars from INFILE until a non-whitespace char and return that.\n+/* Read chars from the MD file until a non-whitespace char and return that.\n    Comments, both Lisp style and C style, are treated as whitespace.  */\n \n int\n-read_skip_spaces (FILE *infile)\n+read_skip_spaces (void)\n {\n   int c;\n \n   while (1)\n     {\n-      c = getc (infile);\n+      c = read_char ();\n       switch (c)\n \t{\n \tcase '\\n':\n@@ -261,20 +263,20 @@ read_skip_spaces (FILE *infile)\n \n \tcase ';':\n \t  do\n-\t    c = getc (infile);\n+\t    c = read_char ();\n \t  while (c != '\\n' && c != EOF);\n \t  read_md_lineno++;\n \t  break;\n \n \tcase '/':\n \t  {\n \t    int prevc;\n-\t    c = getc (infile);\n+\t    c = read_char ();\n \t    if (c != '*')\n-\t      fatal_expected_char (infile, '*', c);\n+\t      fatal_expected_char ('*', c);\n \n \t    prevc = 0;\n-\t    while ((c = getc (infile)) && c != EOF)\n+\t    while ((c = read_char ()) && c != EOF)\n \t      {\n \t\tif (c == '\\n')\n \t\t   read_md_lineno++;\n@@ -295,9 +297,9 @@ read_skip_spaces (FILE *infile)\n    Caller has read the backslash, but not placed it into the obstack.  */\n \n static void\n-read_escape (FILE *infile)\n+read_escape (void)\n {\n-  int c = getc (infile);\n+  int c = read_char ();\n \n   switch (c)\n     {\n@@ -348,18 +350,18 @@ read_escape (FILE *infile)\n    the leading quote.  */\n \n char *\n-read_quoted_string (FILE *infile)\n+read_quoted_string (void)\n {\n   int c;\n \n   while (1)\n     {\n-      c = getc (infile); /* Read the string  */\n+      c = read_char (); /* Read the string  */\n       if (c == '\\n')\n \tread_md_lineno++;\n       else if (c == '\\\\')\n \t{\n-\t  read_escape (infile);\n+\t  read_escape ();\n \t  continue;\n \t}\n       else if (c == '\"' || c == EOF)\n@@ -377,7 +379,7 @@ read_quoted_string (FILE *infile)\n    the outermost braces _are_ included in the string constant.  */\n \n static char *\n-read_braced_string (FILE *infile)\n+read_braced_string (void)\n {\n   int c;\n   int brace_depth = 1;  /* caller-processed */\n@@ -386,7 +388,7 @@ read_braced_string (FILE *infile)\n   obstack_1grow (&string_obstack, '{');\n   while (brace_depth)\n     {\n-      c = getc (infile); /* Read the string  */\n+      c = read_char (); /* Read the string  */\n \n       if (c == '\\n')\n \tread_md_lineno++;\n@@ -396,12 +398,12 @@ read_braced_string (FILE *infile)\n \tbrace_depth--;\n       else if (c == '\\\\')\n \t{\n-\t  read_escape (infile);\n+\t  read_escape ();\n \t  continue;\n \t}\n       else if (c == EOF)\n \tfatal_with_file_and_line\n-\t  (infile, \"missing closing } for opening brace on line %lu\",\n+\t  (\"missing closing } for opening brace on line %lu\",\n \t   starting_read_md_lineno);\n \n       obstack_1grow (&string_obstack, c);\n@@ -416,36 +418,36 @@ read_braced_string (FILE *infile)\n    and dispatch to the appropriate string constant reader.  */\n \n char *\n-read_string (FILE *infile, int star_if_braced)\n+read_string (int star_if_braced)\n {\n   char *stringbuf;\n   int saw_paren = 0;\n   int c, old_lineno;\n \n-  c = read_skip_spaces (infile);\n+  c = read_skip_spaces ();\n   if (c == '(')\n     {\n       saw_paren = 1;\n-      c = read_skip_spaces (infile);\n+      c = read_skip_spaces ();\n     }\n \n   old_lineno = read_md_lineno;\n   if (c == '\"')\n-    stringbuf = read_quoted_string (infile);\n+    stringbuf = read_quoted_string ();\n   else if (c == '{')\n     {\n       if (star_if_braced)\n \tobstack_1grow (&string_obstack, '*');\n-      stringbuf = read_braced_string (infile);\n+      stringbuf = read_braced_string ();\n     }\n   else\n-    fatal_with_file_and_line (infile, \"expected `\\\"' or `{', found `%c'\", c);\n+    fatal_with_file_and_line (\"expected `\\\"' or `{', found `%c'\", c);\n \n   if (saw_paren)\n     {\n-      c = read_skip_spaces (infile);\n+      c = read_skip_spaces ();\n       if (c != ')')\n-\tfatal_expected_char (infile, ')', c);\n+\tfatal_expected_char (')', c);\n     }\n \n   set_md_ptr_loc (stringbuf, read_md_filename, old_lineno);"}, {"sha": "a11d9113e4c4538d7cfdb40799873a6b37906a66", "filename": "gcc/read-md.h", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9/gcc%2Fread-md.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9/gcc%2Fread-md.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.h?ref=c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9", "patch": "@@ -21,21 +21,38 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"obstack.h\"\n \n+extern FILE *read_md_file;\n extern int read_md_lineno;\n extern const char *read_md_filename;\n extern struct obstack string_obstack;\n \n+/* Read the next character from the MD file.  */\n+\n+static inline int\n+read_char (void)\n+{\n+  return getc (read_md_file);\n+}\n+\n+/* Put back CH, which was the last character read from the MD file.  */\n+\n+static inline void\n+unread_char (int ch)\n+{\n+  ungetc (ch, read_md_file);\n+}\n+\n extern void copy_md_ptr_loc (const void *, const void *);\n extern void print_md_ptr_loc (const void *);\n extern const char *join_c_conditions (const char *, const char *);\n extern void print_c_condition (const char *);\n extern void message_with_line (int, const char *, ...) ATTRIBUTE_PRINTF_2;\n-extern void fatal_with_file_and_line (FILE *, const char *, ...)\n-  ATTRIBUTE_PRINTF_2 ATTRIBUTE_NORETURN;\n-extern void fatal_expected_char (FILE *, int, int) ATTRIBUTE_NORETURN;\n-extern int read_skip_spaces (FILE *);\n-extern char *read_quoted_string (FILE *);\n-extern char *read_string (FILE *, int);\n+extern void fatal_with_file_and_line (const char *, ...)\n+  ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n+extern void fatal_expected_char (int, int) ATTRIBUTE_NORETURN;\n+extern int read_skip_spaces (void);\n+extern char *read_quoted_string (void);\n+extern char *read_string (int);\n extern int n_comma_elts (const char *);\n extern const char *scan_comma_elt (const char **);\n extern void init_md_reader (void);"}, {"sha": "9d564c77511a4639999d5bdb71c2e5d10b427b9e", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 147, "deletions": 163, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9", "patch": "@@ -70,8 +70,8 @@ struct iterator_group {\n   int num_builtins;\n \n   /* Treat the given string as the name of a standard mode or code and\n-     return its integer value.  Use the given file for error reporting.  */\n-  int (*find_builtin) (const char *, FILE *);\n+     return its integer value.  */\n+  int (*find_builtin) (const char *);\n \n   /* Return true if the given rtx uses the given mode or code.  */\n   bool (*uses_iterator_p) (rtx, int);\n@@ -87,8 +87,6 @@ struct iterator_traverse_data {\n   rtx queue;\n   /* Attributes seen for modes.  */\n   struct map_value *mode_maps;\n-  /* Input file.  */\n-  FILE *infile;\n   /* The last unknown attribute used as a mode.  */\n   const char *unknown_mode_attr;\n };\n@@ -98,35 +96,35 @@ struct iterator_traverse_data {\n #define BELLWETHER_CODE(CODE) \\\n   ((CODE) < NUM_RTX_CODE ? CODE : bellwether_codes[CODE - NUM_RTX_CODE])\n \n-static int find_mode (const char *, FILE *);\n+static int find_mode (const char *);\n static bool uses_mode_iterator_p (rtx, int);\n static void apply_mode_iterator (rtx, int);\n-static int find_code (const char *, FILE *);\n+static int find_code (const char *);\n static bool uses_code_iterator_p (rtx, int);\n static void apply_code_iterator (rtx, int);\n static const char *apply_iterator_to_string (const char *, struct mapping *, int);\n static rtx apply_iterator_to_rtx (rtx, struct mapping *, int,\n-\t\t\t\t  struct map_value *, FILE *, const char **);\n+\t\t\t\t  struct map_value *, const char **);\n static bool uses_iterator_p (rtx, struct mapping *);\n static const char *add_condition_to_string (const char *, const char *);\n static void add_condition_to_rtx (rtx, const char *);\n static int apply_iterator_traverse (void **, void *);\n static struct mapping *add_mapping (struct iterator_group *, htab_t t,\n-\t\t\t\t    const char *, FILE *);\n+\t\t\t\t    const char *);\n static struct map_value **add_map_value (struct map_value **,\n \t\t\t\t\t int, const char *);\n static void initialize_iterators (void);\n-static void read_name (char *, FILE *);\n+static void read_name (char *);\n static hashval_t def_hash (const void *);\n static int def_name_eq_p (const void *, const void *);\n-static void read_constants (FILE *infile, char *tmp_char);\n-static void read_conditions (FILE *infile, char *tmp_char);\n-static void validate_const_int (FILE *, const char *);\n-static int find_iterator (struct iterator_group *, const char *, FILE *);\n-static struct mapping *read_mapping (struct iterator_group *, htab_t, FILE *);\n-static void check_code_iterator (struct mapping *, FILE *);\n-static rtx read_rtx_1 (FILE *, struct map_value **);\n-static rtx read_rtx_variadic (FILE *, struct map_value **, rtx);\n+static void read_constants (char *tmp_char);\n+static void read_conditions (char *tmp_char);\n+static void validate_const_int (const char *);\n+static int find_iterator (struct iterator_group *, const char *);\n+static struct mapping *read_mapping (struct iterator_group *, htab_t);\n+static void check_code_iterator (struct mapping *);\n+static rtx read_rtx_1 (struct map_value **);\n+static rtx read_rtx_variadic (struct map_value **, rtx);\n \n /* The mode and code iterator structures.  */\n static struct iterator_group modes, codes;\n@@ -137,15 +135,15 @@ static enum rtx_code *bellwether_codes;\n /* Implementations of the iterator_group callbacks for modes.  */\n \n static int\n-find_mode (const char *name, FILE *infile)\n+find_mode (const char *name)\n {\n   int i;\n \n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n     if (strcmp (GET_MODE_NAME (i), name) == 0)\n       return i;\n \n-  fatal_with_file_and_line (infile, \"unknown mode `%s'\", name);\n+  fatal_with_file_and_line (\"unknown mode `%s'\", name);\n }\n \n static bool\n@@ -163,15 +161,15 @@ apply_mode_iterator (rtx x, int mode)\n /* Implementations of the iterator_group callbacks for codes.  */\n \n static int\n-find_code (const char *name, FILE *infile)\n+find_code (const char *name)\n {\n   int i;\n \n   for (i = 0; i < NUM_RTX_CODE; i++)\n     if (strcmp (GET_RTX_NAME (i), name) == 0)\n       return i;\n \n-  fatal_with_file_and_line (infile, \"unknown rtx code `%s'\", name);\n+  fatal_with_file_and_line (\"unknown rtx code `%s'\", name);\n }\n \n static bool\n@@ -252,13 +250,12 @@ mode_attr_index (struct map_value **mode_maps, const char *string)\n /* Apply MODE_MAPS to the top level of X, expanding cases where an\n    attribute is used for a mode.  ITERATOR is the current iterator we are\n    expanding, and VALUE is the value to which we are expanding it.\n-   INFILE is used for error messages.  This sets *UNKNOWN to true if\n-   we find a mode attribute which has not yet been defined, and does\n-   not change it otherwise.  */\n+   This sets *UNKNOWN to true if we find a mode attribute which has not\n+   yet been defined, and does not change it otherwise.  */\n \n static void\n apply_mode_maps (rtx x, struct map_value *mode_maps, struct mapping *iterator,\n-\t\t int value, FILE *infile, const char **unknown)\n+\t\t int value, const char **unknown)\n {\n   unsigned int offset;\n   int indx;\n@@ -277,7 +274,7 @@ apply_mode_maps (rtx x, struct map_value *mode_maps, struct mapping *iterator,\n \n \t  v = map_attr_string (pm->string, iterator, value);\n \t  if (v)\n-\t    PUT_MODE (x, (enum machine_mode) find_mode (v->string, infile));\n+\t    PUT_MODE (x, (enum machine_mode) find_mode (v->string));\n \t  else\n \t    *unknown = pm->string;\n \t  return;\n@@ -327,13 +324,12 @@ apply_iterator_to_string (const char *string, struct mapping *iterator, int valu\n \n /* Return a copy of ORIGINAL in which all uses of ITERATOR have been\n    replaced by VALUE.  MODE_MAPS holds information about attribute\n-   strings used for modes.  INFILE is used for error messages.  This\n-   sets *UNKNOWN_MODE_ATTR to the value of an unknown mode attribute,\n-   and does not change it otherwise.  */\n+   strings used for modes.  This sets *UNKNOWN_MODE_ATTR to the value of\n+   an unknown mode attribute, and does not change it otherwise.  */\n \n static rtx\n apply_iterator_to_rtx (rtx original, struct mapping *iterator, int value,\n-\t\t       struct map_value *mode_maps, FILE *infile,\n+\t\t       struct map_value *mode_maps,\n \t\t       const char **unknown_mode_attr)\n {\n   struct iterator_group *group;\n@@ -356,7 +352,7 @@ apply_iterator_to_rtx (rtx original, struct mapping *iterator, int value,\n     group->apply_iterator (x, value);\n \n   if (mode_maps)\n-    apply_mode_maps (x, mode_maps, iterator, value, infile, unknown_mode_attr);\n+    apply_mode_maps (x, mode_maps, iterator, value, unknown_mode_attr);\n \n   /* Change each string and recursively change each rtx.  */\n   format_ptr = GET_RTX_FORMAT (bellwether_code);\n@@ -374,8 +370,7 @@ apply_iterator_to_rtx (rtx original, struct mapping *iterator, int value,\n \n       case 'e':\n \tXEXP (x, i) = apply_iterator_to_rtx (XEXP (x, i), iterator, value,\n-\t\t\t\t\t     mode_maps, infile,\n-\t\t\t\t\t     unknown_mode_attr);\n+\t\t\t\t\t     mode_maps, unknown_mode_attr);\n \tbreak;\n \n       case 'V':\n@@ -386,7 +381,6 @@ apply_iterator_to_rtx (rtx original, struct mapping *iterator, int value,\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n \t      XVECEXP (x, i, j) = apply_iterator_to_rtx (XVECEXP (original, i, j),\n \t\t\t\t\t\t\t iterator, value, mode_maps,\n-\t\t\t\t\t\t\t infile,\n \t\t\t\t\t\t\t unknown_mode_attr);\n \t  }\n \tbreak;\n@@ -505,7 +499,7 @@ apply_iterator_traverse (void **slot, void *data)\n \tfor (v = iterator->values; v != 0; v = v->next)\n \t  {\n \t    x = apply_iterator_to_rtx (original, iterator, v->number,\n-\t\t\t\t       mtd->mode_maps, mtd->infile,\n+\t\t\t\t       mtd->mode_maps,\n \t\t\t\t       &mtd->unknown_mode_attr);\n \t    add_condition_to_rtx (x, v->string);\n \t    if (v != iterator->values)\n@@ -524,12 +518,10 @@ apply_iterator_traverse (void **slot, void *data)\n }\n \n /* Add a new \"mapping\" structure to hashtable TABLE.  NAME is the name\n-   of the mapping, GROUP is the group to which it belongs, and INFILE\n-   is the file that defined the mapping.  */\n+   of the mapping and GROUP is the group to which it belongs.  */\n \n static struct mapping *\n-add_mapping (struct iterator_group *group, htab_t table,\n-\t     const char *name, FILE *infile)\n+add_mapping (struct iterator_group *group, htab_t table, const char *name)\n {\n   struct mapping *m;\n   void **slot;\n@@ -542,7 +534,7 @@ add_mapping (struct iterator_group *group, htab_t table,\n \n   slot = htab_find_slot (table, m, INSERT);\n   if (*slot != 0)\n-    fatal_with_file_and_line (infile, \"`%s' already defined\", name);\n+    fatal_with_file_and_line (\"`%s' already defined\", name);\n \n   *slot = m;\n   return m;\n@@ -590,8 +582,8 @@ initialize_iterators (void)\n   codes.uses_iterator_p = uses_code_iterator_p;\n   codes.apply_iterator = apply_code_iterator;\n \n-  lower = add_mapping (&modes, modes.attrs, \"mode\", 0);\n-  upper = add_mapping (&modes, modes.attrs, \"MODE\", 0);\n+  lower = add_mapping (&modes, modes.attrs, \"mode\");\n+  upper = add_mapping (&modes, modes.attrs, \"MODE\");\n   lower_ptr = &lower->values;\n   upper_ptr = &upper->values;\n   for (i = 0; i < MAX_MACHINE_MODE; i++)\n@@ -604,8 +596,8 @@ initialize_iterators (void)\n       lower_ptr = add_map_value (lower_ptr, i, copy);\n     }\n \n-  lower = add_mapping (&codes, codes.attrs, \"code\", 0);\n-  upper = add_mapping (&codes, codes.attrs, \"CODE\", 0);\n+  lower = add_mapping (&codes, codes.attrs, \"code\");\n+  upper = add_mapping (&codes, codes.attrs, \"CODE\");\n   lower_ptr = &lower->values;\n   upper_ptr = &upper->values;\n   for (i = 0; i < NUM_RTX_CODE; i++)\n@@ -623,12 +615,12 @@ initialize_iterators (void)\n    It is terminated by any of the punctuation chars of rtx printed syntax.  */\n \n static void\n-read_name (char *str, FILE *infile)\n+read_name (char *str)\n {\n   char *p;\n   int c;\n \n-  c = read_skip_spaces (infile);\n+  c = read_skip_spaces ();\n \n   p = str;\n   while (1)\n@@ -638,14 +630,14 @@ read_name (char *str, FILE *infile)\n       if (c == ':' || c == ')' || c == ']' || c == '\"' || c == '/'\n \t  || c == '(' || c == '[')\n \t{\n-\t  ungetc (c, infile);\n+\t  unread_char (c);\n \t  break;\n \t}\n       *p++ = c;\n-      c = getc (infile);\n+      c = read_char ();\n     }\n   if (p == str)\n-    fatal_with_file_and_line (infile, \"missing name or number\");\n+    fatal_with_file_and_line (\"missing name or number\");\n   if (c == '\\n')\n     read_md_lineno++;\n \n@@ -731,39 +723,37 @@ def_name_eq_p (const void *def1, const void *def2)\n \t\t   *(const char *const *) def2);\n }\n \n-/* INFILE is a FILE pointer to read text from.  TMP_CHAR is a buffer suitable\n-   to read a name or number into.  Process a define_constants directive,\n-   starting with the optional space after the \"define_constants\".  */\n+/* TMP_CHAR is a buffer suitable to read a name or number into.  Process\n+   a define_constants directive, starting with the optional space after\n+   the \"define_constants\".  */\n static void\n-read_constants (FILE *infile, char *tmp_char)\n+read_constants (char *tmp_char)\n {\n   int c;\n   htab_t defs;\n \n-  c = read_skip_spaces (infile);\n+  c = read_skip_spaces ();\n   if (c != '[')\n-    fatal_expected_char (infile, '[', c);\n+    fatal_expected_char ('[', c);\n   defs = md_constants;\n   if (! defs)\n     defs = htab_create (32, def_hash, def_name_eq_p, (htab_del) 0);\n   /* Disable constant expansion during definition processing.  */\n   md_constants = 0;\n-  while ( (c = read_skip_spaces (infile)) != ']')\n+  while ( (c = read_skip_spaces ()) != ']')\n     {\n       struct md_constant *def;\n       void **entry_ptr;\n \n       if (c != '(')\n-\tfatal_expected_char (infile, '(', c);\n+\tfatal_expected_char ('(', c);\n       def = XNEW (struct md_constant);\n       def->name = tmp_char;\n-      read_name (tmp_char, infile);\n+      read_name (tmp_char);\n       entry_ptr = htab_find_slot (defs, def, INSERT);\n       if (! *entry_ptr)\n \tdef->name = xstrdup (tmp_char);\n-      c = read_skip_spaces (infile);\n-      ungetc (c, infile);\n-      read_name (tmp_char, infile);\n+      read_name (tmp_char);\n       if (! *entry_ptr)\n \t{\n \t  def->value = xstrdup (tmp_char);\n@@ -773,18 +763,17 @@ read_constants (FILE *infile, char *tmp_char)\n \t{\n \t  def = (struct md_constant *) *entry_ptr;\n \t  if (strcmp (def->value, tmp_char))\n-\t    fatal_with_file_and_line (infile,\n-\t\t\t\t      \"redefinition of %s, was %s, now %s\",\n+\t    fatal_with_file_and_line (\"redefinition of %s, was %s, now %s\",\n \t\t\t\t      def->name, def->value, tmp_char);\n \t}\n-      c = read_skip_spaces (infile);\n+      c = read_skip_spaces ();\n       if (c != ')')\n-\tfatal_expected_char (infile, ')', c);\n+\tfatal_expected_char (')', c);\n     }\n   md_constants = defs;\n-  c = read_skip_spaces (infile);\n+  c = read_skip_spaces ();\n   if (c != ')')\n-    fatal_expected_char (infile, ')', c);\n+    fatal_expected_char (')', c);\n }\n \n /* For every constant definition, call CALLBACK with two arguments:\n@@ -797,9 +786,8 @@ traverse_md_constants (htab_trav callback, void *info)\n     htab_traverse (md_constants, callback, info);\n }\n \f\n-/* INFILE is a FILE pointer to read text from.  TMP_CHAR is a buffer\n-   suitable to read a name or number into.  Process a\n-   define_conditions directive, starting with the optional space after\n+/* TMP_CHAR is a buffer suitable to read a name or number into.  Process\n+   a define_conditions directive, starting with the optional space after\n    the \"define_conditions\".  The directive looks like this:\n \n      (define_conditions [\n@@ -813,44 +801,44 @@ traverse_md_constants (htab_trav callback, void *info)\n    slipped in at the beginning of the sequence of MD files read by\n    most of the other generators.  */\n static void\n-read_conditions (FILE *infile, char *tmp_char)\n+read_conditions (char *tmp_char)\n {\n   int c;\n \n-  c = read_skip_spaces (infile);\n+  c = read_skip_spaces ();\n   if (c != '[')\n-    fatal_expected_char (infile, '[', c);\n+    fatal_expected_char ('[', c);\n \n-  while ( (c = read_skip_spaces (infile)) != ']')\n+  while ( (c = read_skip_spaces ()) != ']')\n     {\n       char *expr;\n       int value;\n \n       if (c != '(')\n-\tfatal_expected_char (infile, '(', c);\n+\tfatal_expected_char ('(', c);\n \n-      read_name (tmp_char, infile);\n-      validate_const_int (infile, tmp_char);\n+      read_name (tmp_char);\n+      validate_const_int (tmp_char);\n       value = atoi (tmp_char);\n \n-      c = read_skip_spaces (infile);\n+      c = read_skip_spaces ();\n       if (c != '\"')\n-\tfatal_expected_char (infile, '\"', c);\n-      expr = read_quoted_string (infile);\n+\tfatal_expected_char ('\"', c);\n+      expr = read_quoted_string ();\n \n-      c = read_skip_spaces (infile);\n+      c = read_skip_spaces ();\n       if (c != ')')\n-\tfatal_expected_char (infile, ')', c);\n+\tfatal_expected_char (')', c);\n \n       add_c_test (expr, value);\n     }\n-  c = read_skip_spaces (infile);\n+  c = read_skip_spaces ();\n   if (c != ')')\n-    fatal_expected_char (infile, ')', c);\n+    fatal_expected_char (')', c);\n }\n \n static void\n-validate_const_int (FILE *infile, const char *string)\n+validate_const_int (const char *string)\n {\n   const char *cp;\n   int valid = 1;\n@@ -866,35 +854,35 @@ validate_const_int (FILE *infile, const char *string)\n     if (! ISDIGIT (*cp))\n       valid = 0;\n   if (!valid)\n-    fatal_with_file_and_line (infile, \"invalid decimal constant \\\"%s\\\"\\n\", string);\n+    fatal_with_file_and_line (\"invalid decimal constant \\\"%s\\\"\\n\", string);\n }\n \n /* Search GROUP for a mode or code called NAME and return its numerical\n-   identifier.  INFILE is the file that contained NAME.  */\n+   identifier.  */\n \n static int\n-find_iterator (struct iterator_group *group, const char *name, FILE *infile)\n+find_iterator (struct iterator_group *group, const char *name)\n {\n   struct mapping *m;\n \n   m = (struct mapping *) htab_find (group->iterators, &name);\n   if (m != 0)\n     return m->index + group->num_builtins;\n-  return group->find_builtin (name, infile);\n+  return group->find_builtin (name);\n }\n \n /* Finish reading a declaration of the form:\n \n        (define... <name> [<value1> ... <valuen>])\n \n-   from INFILE, where each <valuei> is either a bare symbol name or a\n+   from the MD file, where each <valuei> is either a bare symbol name or a\n    \"(<name> <string>)\" pair.  The \"(define...\" part has already been read.\n \n    Represent the declaration as a \"mapping\" structure; add it to TABLE\n    (which belongs to GROUP) and return it.  */\n \n static struct mapping *\n-read_mapping (struct iterator_group *group, htab_t table, FILE *infile)\n+read_mapping (struct iterator_group *group, htab_t table)\n {\n   char tmp_char[256];\n   struct mapping *m;\n@@ -903,44 +891,44 @@ read_mapping (struct iterator_group *group, htab_t table, FILE *infile)\n   int number, c;\n \n   /* Read the mapping name and create a structure for it.  */\n-  read_name (tmp_char, infile);\n-  m = add_mapping (group, table, tmp_char, infile);\n+  read_name (tmp_char);\n+  m = add_mapping (group, table, tmp_char);\n \n-  c = read_skip_spaces (infile);\n+  c = read_skip_spaces ();\n   if (c != '[')\n-    fatal_expected_char (infile, '[', c);\n+    fatal_expected_char ('[', c);\n \n   /* Read each value.  */\n   end_ptr = &m->values;\n-  c = read_skip_spaces (infile);\n+  c = read_skip_spaces ();\n   do\n     {\n       if (c != '(')\n \t{\n \t  /* A bare symbol name that is implicitly paired to an\n \t     empty string.  */\n-\t  ungetc (c, infile);\n-\t  read_name (tmp_char, infile);\n+\t  unread_char (c);\n+\t  read_name (tmp_char);\n \t  string = \"\";\n \t}\n       else\n \t{\n \t  /* A \"(name string)\" pair.  */\n-\t  read_name (tmp_char, infile);\n-\t  string = read_string (infile, false);\n-\t  c = read_skip_spaces (infile);\n+\t  read_name (tmp_char);\n+\t  string = read_string (false);\n+\t  c = read_skip_spaces ();\n \t  if (c != ')')\n-\t    fatal_expected_char (infile, ')', c);\n+\t    fatal_expected_char (')', c);\n \t}\n-      number = group->find_builtin (tmp_char, infile);\n+      number = group->find_builtin (tmp_char);\n       end_ptr = add_map_value (end_ptr, number, string);\n-      c = read_skip_spaces (infile);\n+      c = read_skip_spaces ();\n     }\n   while (c != ']');\n \n-  c = read_skip_spaces (infile);\n+  c = read_skip_spaces ();\n   if (c != ')')\n-    fatal_expected_char (infile, ')', c);\n+    fatal_expected_char (')', c);\n \n   return m;\n }\n@@ -949,32 +937,32 @@ read_mapping (struct iterator_group *group, htab_t table, FILE *infile)\n    same format.  Initialize the iterator's entry in bellwether_codes.  */\n \n static void\n-check_code_iterator (struct mapping *iterator, FILE *infile)\n+check_code_iterator (struct mapping *iterator)\n {\n   struct map_value *v;\n   enum rtx_code bellwether;\n \n   bellwether = (enum rtx_code) iterator->values->number;\n   for (v = iterator->values->next; v != 0; v = v->next)\n     if (strcmp (GET_RTX_FORMAT (bellwether), GET_RTX_FORMAT (v->number)) != 0)\n-      fatal_with_file_and_line (infile, \"code iterator `%s' combines \"\n+      fatal_with_file_and_line (\"code iterator `%s' combines \"\n \t\t\t\t\"different rtx formats\", iterator->name);\n \n   bellwether_codes = XRESIZEVEC (enum rtx_code, bellwether_codes,\n \t\t\t\t iterator->index + 1);\n   bellwether_codes[iterator->index] = bellwether;\n }\n \n-/* Read an rtx in printed representation from INFILE and store its\n-   core representation in *X.  Also store the line number of the\n+/* Read an rtx in printed representation from the MD file and store\n+   its core representation in *X.  Also store the line number of the\n    opening '(' in *LINENO.  Return true on success or false if the\n    end of file has been reached.\n \n    read_rtx is not used in the compiler proper, but rather in\n    the utilities gen*.c that construct C code from machine descriptions.  */\n \n bool\n-read_rtx (FILE *infile, rtx *x, int *lineno)\n+read_rtx (rtx *x, int *lineno)\n {\n   static rtx queue_head, queue_next;\n   static int queue_lineno;\n@@ -994,14 +982,14 @@ read_rtx (FILE *infile, rtx *x, int *lineno)\n       struct iterator_traverse_data mtd;\n       rtx from_file;\n \n-      c = read_skip_spaces (infile);\n+      c = read_skip_spaces ();\n       if (c == EOF)\n \treturn false;\n-      ungetc (c, infile);\n+      unread_char (c);\n \n       queue_lineno = read_md_lineno;\n       mode_maps = 0;\n-      from_file = read_rtx_1 (infile, &mode_maps);\n+      from_file = read_rtx_1 (&mode_maps);\n       if (from_file == 0)\n \treturn false;  /* This confuses a top level (nil) with end of\n \t\t\t  file, but a top level (nil) would have\n@@ -1013,13 +1001,11 @@ read_rtx (FILE *infile, rtx *x, int *lineno)\n \n       mtd.queue = queue_next;\n       mtd.mode_maps = mode_maps;\n-      mtd.infile = infile;\n       mtd.unknown_mode_attr = mode_maps ? mode_maps->string : NULL;\n       htab_traverse (modes.iterators, apply_iterator_traverse, &mtd);\n       htab_traverse (codes.iterators, apply_iterator_traverse, &mtd);\n       if (mtd.unknown_mode_attr)\n-\tfatal_with_file_and_line (infile,\n-\t\t\t\t  \"undefined attribute '%s' used for mode\",\n+\tfatal_with_file_and_line (\"undefined attribute '%s' used for mode\",\n \t\t\t\t  mtd.unknown_mode_attr);\n     }\n \n@@ -1030,11 +1016,11 @@ read_rtx (FILE *infile, rtx *x, int *lineno)\n   return true;\n }\n \n-/* Subroutine of read_rtx that reads one construct from INFILE but\n+/* Subroutine of read_rtx that reads one construct from the MD file but\n    doesn't apply any iterators.  */\n \n static rtx\n-read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n+read_rtx_1 (struct map_value **mode_maps)\n {\n   int i;\n   RTX_CODE real_code, bellwether_code;\n@@ -1056,55 +1042,54 @@ read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n     };\n \n  again:\n-  c = read_skip_spaces (infile); /* Should be open paren.  */\n+  c = read_skip_spaces (); /* Should be open paren.  */\n \n   if (c == EOF)\n     return 0;\n \n   if (c != '(')\n-    fatal_expected_char (infile, '(', c);\n+    fatal_expected_char ('(', c);\n \n-  read_name (tmp_char, infile);\n+  read_name (tmp_char);\n   if (strcmp (tmp_char, \"nil\") == 0)\n     {\n       /* (nil) stands for an expression that isn't there.  */\n-      c = read_skip_spaces (infile);\n+      c = read_skip_spaces ();\n       if (c != ')')\n-\tfatal_expected_char (infile, ')', c);\n+\tfatal_expected_char (')', c);\n       return 0;\n     }\n   if (strcmp (tmp_char, \"define_constants\") == 0)\n     {\n-      read_constants (infile, tmp_char);\n+      read_constants (tmp_char);\n       goto again;\n     }\n   if (strcmp (tmp_char, \"define_conditions\") == 0)\n     {\n-      read_conditions (infile, tmp_char);\n+      read_conditions (tmp_char);\n       goto again;\n     }\n   if (strcmp (tmp_char, \"define_mode_attr\") == 0)\n     {\n-      read_mapping (&modes, modes.attrs, infile);\n+      read_mapping (&modes, modes.attrs);\n       goto again;\n     }\n   if (strcmp (tmp_char, \"define_mode_iterator\") == 0)\n     {\n-      read_mapping (&modes, modes.iterators, infile);\n+      read_mapping (&modes, modes.iterators);\n       goto again;\n     }\n   if (strcmp (tmp_char, \"define_code_attr\") == 0)\n     {\n-      read_mapping (&codes, codes.attrs, infile);\n+      read_mapping (&codes, codes.attrs);\n       goto again;\n     }\n   if (strcmp (tmp_char, \"define_code_iterator\") == 0)\n     {\n-      check_code_iterator (read_mapping (&codes, codes.iterators, infile),\n-\t\t\t   infile);\n+      check_code_iterator (read_mapping (&codes, codes.iterators));\n       goto again;\n     }\n-  real_code = (enum rtx_code) find_iterator (&codes, tmp_char, infile);\n+  real_code = (enum rtx_code) find_iterator (&codes, tmp_char);\n   bellwether_code = BELLWETHER_CODE (real_code);\n \n   /* If we end up with an insn expression then we free this space below.  */\n@@ -1115,22 +1100,22 @@ read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n   /* If what follows is `: mode ', read it and\n      store the mode in the rtx.  */\n \n-  i = read_skip_spaces (infile);\n+  i = read_skip_spaces ();\n   if (i == ':')\n     {\n       unsigned int mode;\n \n-      read_name (tmp_char, infile);\n+      read_name (tmp_char);\n       if (tmp_char[0] != '<' || tmp_char[strlen (tmp_char) - 1] != '>')\n-\tmode = find_iterator (&modes, tmp_char, infile);\n+\tmode = find_iterator (&modes, tmp_char);\n       else\n \tmode = mode_attr_index (mode_maps, tmp_char);\n       PUT_MODE (return_rtx, (enum machine_mode) mode);\n       if (GET_MODE (return_rtx) != mode)\n-\tfatal_with_file_and_line (infile, \"mode too large\");\n+\tfatal_with_file_and_line (\"mode too large\");\n     }\n   else\n-    ungetc (i, infile);\n+    unread_char (i);\n \n   for (i = 0; format_ptr[i] != 0; i++)\n     switch (format_ptr[i])\n@@ -1142,14 +1127,14 @@ read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n \n       case 'e':\n       case 'u':\n-\tXEXP (return_rtx, i) = read_rtx_1 (infile, mode_maps);\n+\tXEXP (return_rtx, i) = read_rtx_1 (mode_maps);\n \tbreak;\n \n       case 'V':\n \t/* 'V' is an optional vector: if a closeparen follows,\n \t   just store NULL for this element.  */\n-\tc = read_skip_spaces (infile);\n-\tungetc (c, infile);\n+\tc = read_skip_spaces ();\n+\tunread_char (c);\n \tif (c == ')')\n \t  {\n \t    XVEC (return_rtx, i) = 0;\n@@ -1164,19 +1149,19 @@ read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n \t  int list_counter = 0;\n \t  rtvec return_vec = NULL_RTVEC;\n \n-\t  c = read_skip_spaces (infile);\n+\t  c = read_skip_spaces ();\n \t  if (c != '[')\n-\t    fatal_expected_char (infile, '[', c);\n+\t    fatal_expected_char ('[', c);\n \n \t  /* Add expressions to a list, while keeping a count.  */\n \t  obstack_init (&vector_stack);\n-\t  while ((c = read_skip_spaces (infile)) && c != ']')\n+\t  while ((c = read_skip_spaces ()) && c != ']')\n \t    {\n \t      if (c == EOF)\n-\t\tfatal_expected_char (infile, ']', c);\n-\t      ungetc (c, infile);\n+\t\tfatal_expected_char (']', c);\n+\t      unread_char (c);\n \t      list_counter++;\n-\t      obstack_ptr_grow (&vector_stack, read_rtx_1 (infile, mode_maps));\n+\t      obstack_ptr_grow (&vector_stack, read_rtx_1 (mode_maps));\n \t    }\n \t  if (list_counter > 0)\n \t    {\n@@ -1185,8 +1170,7 @@ read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n \t\t      list_counter * sizeof (rtx));\n \t    }\n \t  else if (format_ptr[i] == 'E')\n-\t    fatal_with_file_and_line (infile,\n-\t\t\t\t      \"vector must have at least one element\");\n+\t    fatal_with_file_and_line (\"vector must have at least one element\");\n \t  XVEC (return_rtx, i) = return_vec;\n \t  obstack_free (&vector_stack, NULL);\n \t  /* close bracket gotten */\n@@ -1200,8 +1184,8 @@ read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n \t  char *stringbuf;\n \t  int star_if_braced;\n \n-\t  c = read_skip_spaces (infile);\n-\t  ungetc (c, infile);\n+\t  c = read_skip_spaces ();\n+\t  unread_char (c);\n \t  if (c == ')')\n \t    {\n \t      /* 'S' fields are optional and should be NULL if no string\n@@ -1217,7 +1201,7 @@ read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n \t     written with a brace block instead of a string constant.  */\n \t  star_if_braced = (format_ptr[i] == 'T');\n \n-\t  stringbuf = read_string (infile, star_if_braced);\n+\t  stringbuf = read_string (star_if_braced);\n \n \t  /* For insn patterns, we want to provide a default name\n \t     based on the file and line, like \"*foo.md:12\", if the\n@@ -1249,8 +1233,8 @@ read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n \tbreak;\n \n       case 'w':\n-\tread_name (tmp_char, infile);\n-\tvalidate_const_int (infile, tmp_char);\n+\tread_name (tmp_char);\n+\tvalidate_const_int (tmp_char);\n #if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n \ttmp_wide = atoi (tmp_char);\n #else\n@@ -1271,8 +1255,8 @@ read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n \n       case 'i':\n       case 'n':\n-\tread_name (tmp_char, infile);\n-\tvalidate_const_int (infile, tmp_char);\n+\tread_name (tmp_char);\n+\tvalidate_const_int (tmp_char);\n \ttmp_int = atoi (tmp_char);\n \tXINT (return_rtx, i) = tmp_int;\n \tbreak;\n@@ -1281,16 +1265,16 @@ read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n \tgcc_unreachable ();\n       }\n \n-  c = read_skip_spaces (infile);\n+  c = read_skip_spaces ();\n   if (c != ')')\n     {\n       /* Syntactic sugar for AND and IOR, allowing Lisp-like\n \t arbitrary number of arguments for them.  */\n       if (c == '(' && (GET_CODE (return_rtx) == AND\n \t\t       || GET_CODE (return_rtx) == IOR))\n-\treturn read_rtx_variadic (infile, mode_maps, return_rtx);\n+\treturn read_rtx_variadic (mode_maps, return_rtx);\n       else\n-\tfatal_expected_char (infile, ')', c);\n+\tfatal_expected_char (')', c);\n     }\n \n   return return_rtx;\n@@ -1303,29 +1287,29 @@ read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n    is just past the leading parenthesis of x3.  Only works\n    for THINGs which are dyadic expressions, e.g. AND, IOR.  */\n static rtx\n-read_rtx_variadic (FILE *infile, struct map_value **mode_maps, rtx form)\n+read_rtx_variadic (struct map_value **mode_maps, rtx form)\n {\n   char c = '(';\n   rtx p = form, q;\n \n   do\n     {\n-      ungetc (c, infile);\n+      unread_char (c);\n \n       q = rtx_alloc (GET_CODE (p));\n       PUT_MODE (q, GET_MODE (p));\n \n       XEXP (q, 0) = XEXP (p, 1);\n-      XEXP (q, 1) = read_rtx_1 (infile, mode_maps);\n+      XEXP (q, 1) = read_rtx_1 (mode_maps);\n \n       XEXP (p, 1) = q;\n       p = q;\n-      c = read_skip_spaces (infile);\n+      c = read_skip_spaces ();\n     }\n   while (c == '(');\n \n   if (c != ')')\n-    fatal_expected_char (infile, ')', c);\n+    fatal_expected_char (')', c);\n \n   return form;\n }"}, {"sha": "1ed8f73ebcfc09d8b60579579de73be35d2c2c9e", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=c5e88b399c526dbb7ab2bc6b4fdbc0e8100fa3d9", "patch": "@@ -2361,7 +2361,7 @@ extern void traverse_md_constants (int (*) (void **, void *), void *);\n struct md_constant { char *name, *value; };\n \n /* In read-rtl.c */\n-extern bool read_rtx (FILE *, rtx *, int *);\n+extern bool read_rtx (rtx *, int *);\n \n /* In alias.c */\n extern rtx canon_rtx (rtx);"}]}