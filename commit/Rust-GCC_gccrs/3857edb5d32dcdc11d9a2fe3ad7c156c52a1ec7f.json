{"sha": "3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg1N2VkYjVkMzJkY2RjMTFkOWEyZmUzYWQ3YzE1NmM1MmExZWM3Zg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-03-11T22:46:37Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-03-11T22:46:37Z"}, "message": "analyzer: new implementation of shortest feasible path [PR96374]\n\nThe analyzer builds an exploded graph of (point,state) pairs and when\nit finds a problem, records a diagnostic at the relevant exploded node.\nOnce it has finished exploring the graph, the analyzer needs to generate\nthe shortest feasible path through the graph to each diagnostic's node.\nThis is used:\n- for rejecting diagnostics that are infeasible (due to impossible sets\n  of constraints),\n- for use in determining which diagnostic to use in each deduplication\n  set (the one with the shortest path), and\n- for building checker_paths for the \"winning\" diagnostics, giving a\n  list of events\n\nPrior to this patch the analyzer simply found the shortest path to the\nnode, and then checked it for feasibility, which could lead to falsely\nrejecting diagnostics: \"the shortest path, if feasible\" is not the same\nas \"the shortest feasible path\" (PR analyzer/96374).\nAn example is PR analyzer/93355, where this issue causes the analyzer\nto fail to emit a leak warning for a missing fclose on an error-handling\npath in intl/localealias.c.\n\nThis patch implements a new algorithm for finding the shortest feasible\npath to an exploded node: instead of simply finding the shortest path,\nthe new algorithm uses a worklist to iteratively build a tree of path\nprefixes, which are feasible paths by construction, until a path to the\ntarget node is found.  The worklist is prioritized, so that the first\nfeasible path discovered is the shortest possible feasible path.  The\nalgorithm continues trying paths until the target node is reached or a\nlimit is exceeded, in which case the diagnostic is treated as being\ninfeasible (which could still be a false negative, but is much less\nlikely to happen than before).  Iteratively building a tree of paths\nallows for work to be reused, and the tree can be dumped in .dot form\n(via a new -fdump-analyzer-feasibility option), making it much easier to\ndebug compared to other approaches I tried.\n\nDoing so fixes the missing leak warning for PR analyzer/93355 and\nvarious other test cases.\n\nTesting:\n- I manually verified that the behavior is determistic using 50 builds\n  of pr93355-localealias.c.  All dumps were identical.\n- I manually verified that it still builds with --disable-analyzer.\n- Lightly tested with valgrind; no additional issues.\n- Lightly performance tested, showing a slight speed regression to the\n  analyzer relative to before the patch, but correctness for this issue\n  is more important than the slight performance hit for the analyzer.\n\ngcc/ChangeLog:\n\tPR analyzer/96374\n\t* Makefile.in (ANALYZER_OBJS): Add analyzer/feasible-graph.o and\n\tanalyzer/trimmed-graph.o.\n\t* doc/analyzer.texi (Analyzer Paths): Rewrite description of\n\tfeasibility checking to reflect new implementation.\n\t* doc/invoke.texi (-fdump-analyzer-feasibility): Document new\n\toption.\n\t* shortest-paths.h (shortest_paths::get_shortest_distance): New.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/96374\n\t* analyzer.opt (-param=analyzer-max-infeasible-edges=): New param.\n\t(fdump-analyzer-feasibility): New flag.\n\t* diagnostic-manager.cc: Include \"analyzer/trimmed-graph.h\" and\n\t\"analyzer/feasible-graph.h\".\n\t(epath_finder::epath_finder): Convert m_sep to a pointer and\n\tonly create it if !flag_analyzer_feasibility.\n\t(epath_finder::~epath_finder): New.\n\t(epath_finder::m_sep): Convert to a pointer.\n\t(epath_finder::get_best_epath): Add param \"diag_idx\" and use it\n\twhen logging.  Rather than finding the shortest path and then\n\tchecking feasibility, instead use explore_feasible_paths unless\n\t!flag_analyzer_feasibility, in which case simply use the shortest\n\tpath, and note if it is infeasible.  Update for m_sep becoming a\n\tpointer.\n\t(class feasible_worklist): New.\n\t(epath_finder::explore_feasible_paths): New.\n\t(epath_finder::process_worklist_item): New.\n\t(class dump_eg_with_shortest_path): New.\n\t(epath_finder::dump_trimmed_graph): New.\n\t(epath_finder::dump_feasible_graph): New.\n\t(saved_diagnostic::saved_diagnostic): Add \"idx\" param, using it\n\ton new field m_idx.\n\t(saved_diagnostic::to_json): Dump m_idx.\n\t(saved_diagnostic::calc_best_epath): Pass m_idx to get_best_epath.\n\tRemove assertion that m_problem was set when m_best_epath is NULL.\n\t(diagnostic_manager::add_diagnostic): Pass an index when created\n\tsaved_diagnostic instances.\n\t* diagnostic-manager.h (saved_diagnostic::saved_diagnostic): Add\n\t\"idx\" param.\n\t(saved_diagnostic::get_index): New accessor.\n\t(saved_diagnostic::m_idx): New field.\n\t* engine.cc (exploded_node::dump_dot): Call args.dump_extra_info.\n\tMove code to...\n\t(exploded_node::dump_processed_stmts): ...this new function and...\n\t(exploded_node::dump_saved_diagnostics): ...this new function.\n\tAdd index of each diagnostic.\n\t(exploded_edge::dump_dot):  Move bulk of code to...\n\t(exploded_edge::dump_dot_label): ...this new function.\n\t* exploded-graph.h (eg_traits::dump_args_t::dump_extra_info): New\n\tvfunc.\n\t(exploded_node::dump_processed_stmts): New decl.\n\t(exploded_node::dump_saved_diagnostics): New decl.\n\t(exploded_edge::dump_dot_label): New decl.\n\t* feasible-graph.cc: New file.\n\t* feasible-graph.h: New file.\n\t* trimmed-graph.cc: New file.\n\t* trimmed-graph.h: New file.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/96374\n\t* gcc.dg/analyzer/dot-output.c: Add -fdump-analyzer-feasibility\n\tto options.\n\t* gcc.dg/analyzer/feasibility-1.c (test_6): Remove xfail.\n\t(test_7): New.\n\t* gcc.dg/analyzer/pr93355-localealias-feasibility-2.c: Remove xfail.\n\t* gcc.dg/analyzer/pr93355-localealias-feasibility-3.c: Remove xfails.\n\t* gcc.dg/analyzer/pr93355-localealias-feasibility.c: Remove\n\t-fno-analyzer-feasibility from options.\n\t* gcc.dg/analyzer/pr93355-localealias.c: Likewise.\n\t* gcc.dg/analyzer/unknown-fns-4.c: Remove xfail.", "tree": {"sha": "dee3fd5ec072bc0fa3f1b00586b8ab0db4e95aa5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dee3fd5ec072bc0fa3f1b00586b8ab0db4e95aa5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e33e5b042a6a830c40cee3d0a925bc49dcfe069", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e33e5b042a6a830c40cee3d0a925bc49dcfe069", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e33e5b042a6a830c40cee3d0a925bc49dcfe069"}], "stats": {"total": 1472, "additions": 1366, "deletions": 106}, "files": [{"sha": "8a5fb3fd99c1ab850631d2ccb9f3466170b81b40", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -1254,6 +1254,7 @@ ANALYZER_OBJS = \\\n \tanalyzer/constraint-manager.o \\\n \tanalyzer/diagnostic-manager.o \\\n \tanalyzer/engine.o \\\n+\tanalyzer/feasible-graph.o \\\n \tanalyzer/function-set.o \\\n \tanalyzer/pending-diagnostic.o \\\n \tanalyzer/program-point.o \\\n@@ -1273,7 +1274,8 @@ ANALYZER_OBJS = \\\n \tanalyzer/state-purge.o \\\n \tanalyzer/store.o \\\n \tanalyzer/supergraph.o \\\n-\tanalyzer/svalue.o\n+\tanalyzer/svalue.o \\\n+\tanalyzer/trimmed-graph.o\n \n # Language-independent object files.\n # We put the *-match.o and insn-*.o files first so that a parallel make"}, {"sha": "dd34495abd5371f24a3df99db26fa658a3226c8c", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -34,6 +34,10 @@ The maximum number of exploded nodes per program point within the analyzer, befo\n Common Joined UInteger Var(param_analyzer_max_constraints) Init(20) Param\n The maximum number of constraints per state.\n \n+-param=analyzer-max-infeasible-edges=\n+Common Joined UInteger Var(param_analyzer_max_infeasible_edges) Init(10) Param\n+The maximum number of infeasible edges to reject before declaring a diagnostic as infeasible.\n+\n -param=analyzer-max-recursion-depth=\n Common Joined UInteger Var(param_analyzer_max_recursion_depth) Init(2) Param\n The maximum number of times a callsite can appear in a call stack within the analyzer, before terminating analysis of a call that would recurse deeper.\n@@ -206,6 +210,10 @@ fdump-analyzer-exploded-nodes-3\n Common RejectNegative Var(flag_dump_analyzer_exploded_nodes_3)\n Dump a textual representation of the exploded graph to SRCFILE.eg-ID.txt.\n \n+fdump-analyzer-feasibility\n+Common RejectNegative Var(flag_dump_analyzer_feasibility)\n+Dump various analyzer internals to SRCFILE.*.fg.dot and SRCFILE.*.tg.dot.\n+\n fdump-analyzer-json\n Common RejectNegative Var(flag_dump_analyzer_json)\n Dump analyzer-specific data to a SRCFILE.analyzer.json.gz file."}, {"sha": "1a3535cfeb17b0fce661cf04838df77708e78139", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 450, "deletions": 40, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -57,13 +57,17 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/supergraph.h\"\n #include \"analyzer/program-state.h\"\n #include \"analyzer/exploded-graph.h\"\n+#include \"analyzer/trimmed-graph.h\"\n+#include \"analyzer/feasible-graph.h\"\n #include \"analyzer/checker-path.h\"\n #include \"analyzer/reachability.h\"\n \n #if ENABLE_ANALYZER\n \n namespace ana {\n \n+class feasible_worklist;\n+\n /* State for finding the shortest feasible exploded_path for a\n    saved_diagnostic.\n    This is shared between all diagnostics, so that we avoid repeating work.  */\n@@ -73,19 +77,42 @@ class epath_finder\n public:\n   epath_finder (const exploded_graph &eg)\n   : m_eg (eg),\n-    m_sep (eg, eg.get_origin (), SPS_FROM_GIVEN_ORIGIN)\n+    m_sep (NULL)\n   {\n+    /* This is shared by all diagnostics, but only needed if\n+       !flag_analyzer_feasibility.  */\n+    if (!flag_analyzer_feasibility)\n+      m_sep = new shortest_exploded_paths (eg, eg.get_origin (),\n+\t\t\t\t\t   SPS_FROM_GIVEN_ORIGIN);\n   }\n \n+  ~epath_finder () { delete m_sep; }\n+\n   logger *get_logger () const { return m_eg.get_logger (); }\n \n-  exploded_path *get_best_epath (const exploded_node *enode,\n-\t\t\t\t const char *desc,\n+  exploded_path *get_best_epath (const exploded_node *target_enode,\n+\t\t\t\t const char *desc, unsigned diag_idx,\n \t\t\t\t feasibility_problem **out_problem);\n \n private:\n+  exploded_path *explore_feasible_paths (const exploded_node *target_enode,\n+\t\t\t\t\t const char *desc, unsigned diag_idx);\n+  bool process_worklist_item (feasible_worklist *worklist,\n+\t\t\t      const trimmed_graph &tg,\n+\t\t\t      feasible_graph *fg,\n+\t\t\t      const exploded_node *target_enode,\n+\t\t\t      unsigned diag_idx,\n+\t\t\t      exploded_path **out_best_path) const;\n+  void dump_trimmed_graph (const exploded_node *target_enode,\n+\t\t\t   const char *desc, unsigned diag_idx,\n+\t\t\t   const trimmed_graph &tg,\n+\t\t\t   const shortest_paths<eg_traits, exploded_path> &sep);\n+  void dump_feasible_graph (const exploded_node *target_enode,\n+\t\t\t    const char *desc, unsigned diag_idx,\n+\t\t\t    const feasible_graph &fg);\n+\n   const exploded_graph &m_eg;\n-  shortest_exploded_paths m_sep;\n+  shortest_exploded_paths *m_sep;\n };\n \n /* class epath_finder.  */\n@@ -100,66 +127,448 @@ class epath_finder\n    If flag_analyzer_feasibility is false, then simply return the\n    shortest path.\n \n-   Use DESC when logging.\n+   Use DESC and DIAG_IDX when logging.\n \n-   Write any feasiblity_problem to *OUT_PROBLEM.  */\n+   Write any feasibility_problem to *OUT_PROBLEM.  */\n \n exploded_path *\n epath_finder::get_best_epath (const exploded_node *enode,\n-\t\t\t      const char *desc,\n+\t\t\t      const char *desc, unsigned diag_idx,\n \t\t\t      feasibility_problem **out_problem)\n {\n   logger *logger = get_logger ();\n   LOG_SCOPE (logger);\n \n   unsigned snode_idx = enode->get_supernode ()->m_index;\n   if (logger)\n-    logger->log (\"considering %qs at EN: %i, SN: %i\",\n-\t\t desc, enode->m_index, snode_idx);\n+    logger->log (\"considering %qs at EN: %i, SN: %i (sd: %i)\",\n+\t\t desc, enode->m_index, snode_idx, diag_idx);\n \n   /* State-merging means that not every path in the egraph corresponds\n      to a feasible one w.r.t. states.\n \n      We want to find the shortest feasible path from the origin to ENODE\n-     in the egraph.\n+     in the egraph.  */\n \n-     As a crude approximation to this, we find the shortest path, and\n-     determine if it is feasible.  This could introduce false negatives,\n-     as there could be longer feasible paths within the egraph.\n-     (PR analyzer/96374).  */\n-\n-  exploded_path *epath = new exploded_path (m_sep.get_shortest_path (enode));\n-  if (epath->feasible_p (logger, out_problem, m_eg.get_engine (), &m_eg))\n+  if (flag_analyzer_feasibility)\n     {\n+      /* Attempt to find the shortest feasible path using feasible_graph.  */\n       if (logger)\n-\tlogger->log (\"accepting %qs at EN: %i, SN: %i with feasible path\",\n-\t\t     desc, enode->m_index,\n-\t\t     snode_idx);\n+\tlogger->log (\"trying to find shortest feasible path\");\n+      if (exploded_path *epath = explore_feasible_paths (enode, desc, diag_idx))\n+\t{\n+\t  if (logger)\n+\t    logger->log (\"accepting %qs at EN: %i, SN: %i (sd: %i)\"\n+\t\t\t \" with feasible path (length: %i)\",\n+\t\t\t desc, enode->m_index, snode_idx, diag_idx,\n+\t\t\t epath->length ());\n+\t  return epath;\n+\t}\n+      else\n+\t{\n+\t  if (logger)\n+\t    logger->log (\"rejecting %qs at EN: %i, SN: %i (sd: %i)\"\n+\t\t\t \" due to not finding feasible path\",\n+\t\t\t desc, enode->m_index, snode_idx, diag_idx);\n+\t  return NULL;\n+\t}\n     }\n   else\n     {\n-      if (flag_analyzer_feasibility)\n+      /* As a crude approximation to shortest feasible path, simply find\n+\t the shortest path, and note whether it is feasible.\n+\t There could be longer feasible paths within the egraph, so this\n+\t approach would lead to diagnostics being falsely rejected\n+\t (PR analyzer/96374).  */\n+      if (logger)\n+\tlogger->log (\"trying to find shortest path ignoring feasibility\");\n+      gcc_assert (m_sep);\n+      exploded_path *epath\n+\t= new exploded_path (m_sep->get_shortest_path (enode));\n+      if (epath->feasible_p (logger, out_problem, m_eg.get_engine (), &m_eg))\n \t{\n \t  if (logger)\n-\t    logger->log (\"rejecting %qs at EN: %i, SN: %i\"\n-\t\t\t \" due to infeasible path\",\n-\t\t\t desc, enode->m_index,\n-\t\t\t snode_idx);\n-\t  delete epath;\n-\t  return NULL;\n+\t    logger->log (\"accepting %qs at EN: %i, SN: %i (sn: %i)\"\n+\t\t\t \" with feasible path (length: %i)\",\n+\t\t\t desc, enode->m_index, snode_idx, diag_idx,\n+\t\t\t epath->length ());\n \t}\n       else\n \t{\n \t  if (logger)\n-\t    logger->log (\"accepting %qs at EN: %i, SN: %i\"\n+\t    logger->log (\"accepting %qs at EN: %i, SN: %i (sn: %i) (length: %i)\"\n \t\t\t \" despite infeasible path (due to %qs)\",\n-\t\t\t desc, enode->m_index,\n-\t\t\t snode_idx,\n+\t\t\t desc, enode->m_index, snode_idx, diag_idx,\n+\t\t\t epath->length (),\n \t\t\t \"-fno-analyzer-feasibility\");\n \t}\n+      return epath;\n+    }\n+}\n+\n+/* A class for managing the worklist of feasible_nodes in\n+   epath_finder::explore_feasible_paths, prioritizing them\n+   so that shorter paths appear earlier in the queue.  */\n+\n+class feasible_worklist\n+{\n+public:\n+  feasible_worklist (const shortest_paths<eg_traits, exploded_path> &sep)\n+  : m_queue (key_t (*this, NULL)),\n+    m_sep (sep)\n+  {\n+  }\n+\n+  feasible_node *take_next () { return m_queue.extract_min (); }\n+\n+  void add_node (feasible_node *fnode)\n+  {\n+    m_queue.insert (key_t (*this, fnode), fnode);\n+  }\n+\n+private:\n+  struct key_t\n+  {\n+    key_t (const feasible_worklist &w, feasible_node *fnode)\n+    : m_worklist (w), m_fnode (fnode)\n+    {}\n+\n+    bool operator< (const key_t &other) const\n+    {\n+      return cmp (*this, other) < 0;\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return cmp (*this, other) == 0;\n+    }\n+\n+    bool operator> (const key_t &other) const\n+    {\n+      return !(*this == other || *this < other);\n+    }\n+\n+  private:\n+    static int cmp (const key_t &ka, const key_t &kb)\n+    {\n+      /* Choose the node for which if the remaining path were feasible,\n+\t it would be the shortest path (summing the length of the\n+\t known-feasible path so far with that of the remaining\n+\t possibly-feasible path).  */\n+      int ca = ka.m_worklist.get_estimated_cost (ka.m_fnode);\n+      int cb = kb.m_worklist.get_estimated_cost (kb.m_fnode);\n+      return ca - cb;\n+    }\n+\n+    const feasible_worklist &m_worklist;\n+    feasible_node *m_fnode;\n+  };\n+\n+  /* Get the estimated length of a path involving FNODE from\n+     the origin to the target enode.\n+     Sum the length of the known-feasible path so far with\n+     that of the remaining possibly-feasible path.  */\n+\n+  int get_estimated_cost (const feasible_node *fnode) const\n+  {\n+    unsigned length_so_far = fnode->get_path_length ();\n+    int shortest_remaining_path\n+      = m_sep.get_shortest_distance (fnode->get_inner_node ());\n+\n+    gcc_assert (shortest_remaining_path >= 0);\n+    /* This should be true since we're only exploring nodes within\n+       the trimmed graph (and we anticipate it being much smaller\n+       than this, and thus not overflowing the sum).  */\n+    gcc_assert (shortest_remaining_path < INT_MAX);\n+\n+    return length_so_far + shortest_remaining_path;\n+  }\n+\n+  /* Priority queue, backed by a fibonacci_heap.  */\n+  typedef fibonacci_heap<key_t, feasible_node> queue_t;\n+  queue_t m_queue;\n+  const shortest_paths<eg_traits, exploded_path> &m_sep;\n+};\n+\n+/* Attempt to find the shortest feasible path from the origin to\n+   TARGET_ENODE by iteratively building a feasible_graph, in which\n+   every path to a feasible_node is feasible by construction.\n+\n+   We effectively explore the tree of feasible paths in order of shortest\n+   path until we either find a feasible path to TARGET_ENODE, or hit\n+   a limit and give up.\n+\n+   Preliminaries:\n+   - Find the shortest path from each node to the TARGET_ENODE (without\n+   checking feasibility), so that we can prioritize our worklist.\n+   - Construct a trimmed_graph: the subset of nodes/edges that\n+   are on a path that eventually reaches TARGET_ENODE.  We will only need\n+   to consider these when considering the shortest feasible path.\n+\n+   Build a feasible_graph, in which every path to a feasible_node\n+   is feasible by construction.\n+   We use a worklist to flatten the exploration into an iteration.\n+   Starting at the origin, find feasible out-edges within the trimmed graph.\n+   At each stage, choose the node for which if the remaining path were feasible,\n+   it would be the shortest path (summing the length of the known-feasible path\n+   so far with that of the remaining possibly-feasible path).\n+   This way, the first feasible path we find to TARGET_ENODE is the shortest.\n+   We start by trying the shortest possible path, but if that fails,\n+   we explore progressively longer paths, eventually trying iterations through\n+   loops.  The exploration is captured in the feasible_graph, which can be\n+   dumped as a .dot file to visualize the exploration.  The indices of the\n+   feasible_nodes show the order in which they were created.\n+\n+   This is something of a brute-force approach, but the trimmed_graph\n+   hopefully keeps the complexity manageable.\n+\n+   Terminate with failure when the number of infeasible edges exceeds\n+   a threshold (--param=analyzer-max-infeasible-edges=).\n+   This is guaranteed to eventually lead to terminatation, as\n+   we can't keep creating feasible nodes without eventually\n+   either reaching an infeasible edge, or reaching the\n+   TARGET_ENODE.  Specifically, there can't be a cycle of\n+   feasible edges that doesn't reach the target_enode without\n+   an out-edge that either fails feasibility or gets closer\n+   to the TARGET_ENODE: on each iteration we are either:\n+   - effectively getting closer to the TARGET_ENODE (which can't\n+     continue forever without reaching the target), or\n+   - getting monotonically closer to the termination threshold.  */\n+\n+exploded_path *\n+epath_finder::explore_feasible_paths (const exploded_node *target_enode,\n+\t\t\t\t      const char *desc, unsigned diag_idx)\n+{\n+  logger *logger = get_logger ();\n+  LOG_SCOPE (logger);\n+\n+  /* Determine the shortest path to TARGET_ENODE from each node in\n+     the exploded graph.  */\n+  shortest_paths<eg_traits, exploded_path> sep\n+    (m_eg, target_enode, SPS_TO_GIVEN_TARGET);\n+\n+  /* Construct a trimmed_graph: the subset of nodes/edges that\n+     are on a path that eventually reaches TARGET_ENODE.\n+     We only need to consider these when considering the shortest\n+     feasible path.  */\n+  trimmed_graph tg (m_eg, target_enode);\n+\n+  if (flag_dump_analyzer_feasibility)\n+    dump_trimmed_graph (target_enode, desc, diag_idx, tg, sep);\n+\n+  feasible_graph fg;\n+  feasible_worklist worklist (sep);\n+\n+  /* Populate the worklist with the origin node.  */\n+  {\n+    feasibility_state init_state (m_eg.get_engine ()->get_model_manager (),\n+\t\t\t\t  m_eg.get_supergraph ());\n+    feasible_node *origin = fg.add_node (m_eg.get_origin (), init_state, 0);\n+    worklist.add_node (origin);\n+  }\n+\n+  /* Iteratively explore the tree of feasible paths in order of shortest\n+     path until we either find a feasible path to TARGET_ENODE, or hit\n+     a limit.  */\n+\n+  /* Set this if we find a feasible path to TARGET_ENODE.  */\n+  exploded_path *best_path = NULL;\n+\n+  while (process_worklist_item (&worklist, tg, &fg, target_enode, diag_idx,\n+\t\t\t\t&best_path))\n+    {\n+      /* Empty; the work is done within process_worklist_item.  */\n     }\n \n-  return epath;\n+  if (logger)\n+    {\n+      logger->log (\"tg for sd: %i:\", diag_idx);\n+      logger->inc_indent ();\n+      tg.log_stats (logger);\n+      logger->dec_indent ();\n+\n+      logger->log (\"fg for sd: %i:\", diag_idx);\n+      logger->inc_indent ();\n+      fg.log_stats (logger);\n+      logger->dec_indent ();\n+    }\n+\n+  /* Dump the feasible_graph.  */\n+  if (flag_dump_analyzer_feasibility)\n+    dump_feasible_graph (target_enode, desc, diag_idx, fg);\n+\n+  return best_path;\n+}\n+\n+/* Process the next item in WORKLIST, potentially adding new items\n+   based on feasible out-edges, and extending FG accordingly.\n+   Use TG to ignore out-edges that don't lead to TARGET_ENODE.\n+   Return true if the worklist processing should continue.\n+   Return false if the processing of the worklist should stop\n+   (either due to reaching TARGET_ENODE, or hitting a limit).\n+   Write to *OUT_BEST_PATH if stopping due to finding a feasible path\n+   to TARGET_ENODE.  */\n+\n+bool\n+epath_finder::process_worklist_item (feasible_worklist *worklist,\n+\t\t\t\t     const trimmed_graph &tg,\n+\t\t\t\t     feasible_graph *fg,\n+\t\t\t\t     const exploded_node *target_enode,\n+\t\t\t\t     unsigned diag_idx,\n+\t\t\t\t     exploded_path **out_best_path) const\n+{\n+  logger *logger = get_logger ();\n+\n+  feasible_node *fnode = worklist->take_next ();\n+  if (!fnode)\n+    {\n+      if (logger)\n+\tlogger->log (\"drained worklist for sd: %i\"\n+\t\t     \" without finding feasible path\",\n+\t\t     diag_idx);\n+      return false;\n+    }\n+\n+  log_scope s (logger, \"fg worklist item\",\n+\t       \"considering FN: %i (EN: %i) for sd: %i\",\n+\t       fnode->get_index (), fnode->get_inner_node ()->m_index,\n+\t       diag_idx);\n+\n+  /* Iterate through all out-edges from this item.  */\n+  unsigned i;\n+  exploded_edge *succ_eedge;\n+  FOR_EACH_VEC_ELT (fnode->get_inner_node ()->m_succs, i, succ_eedge)\n+    {\n+      log_scope s (logger, \"edge\", \"considering edge: EN:%i -> EN:%i\",\n+\t\t   succ_eedge->m_src->m_index,\n+\t\t   succ_eedge->m_dest->m_index);\n+      /* Reject edges that aren't in the trimmed graph.  */\n+      if (!tg.contains_p (succ_eedge))\n+\t{\n+\t  if (logger)\n+\t    logger->log (\"rejecting: not in trimmed graph\");\n+\t  continue;\n+\t}\n+\n+      feasibility_state succ_state (fnode->get_state ());\n+      rejected_constraint *rc = NULL;\n+      if (succ_state.maybe_update_for_edge (logger, succ_eedge, &rc))\n+\t{\n+\t  gcc_assert (rc == NULL);\n+\t  feasible_node *succ_fnode\n+\t    = fg->add_node (succ_eedge->m_dest,\n+\t\t\t    succ_state,\n+\t\t\t    fnode->get_path_length () + 1);\n+\t  if (logger)\n+\t    logger->log (\"accepting as FN: %i\", succ_fnode->get_index ());\n+\t  fg->add_edge (new feasible_edge (fnode, succ_fnode, succ_eedge));\n+\n+\t  /* Have we reached TARGET_ENODE?  */\n+\t  if (succ_fnode->get_inner_node () == target_enode)\n+\t    {\n+\t      if (logger)\n+\t\tlogger->log (\"success: got feasible path to EN: %i (sd: %i)\"\n+\t\t\t     \" (length: %i)\",\n+\t\t\t     target_enode->m_index, diag_idx,\n+\t\t\t     succ_fnode->get_path_length ());\n+\t      *out_best_path = fg->make_epath (succ_fnode);\n+\t      /* Success: stop the worklist iteration.  */\n+\t      return false;\n+\t    }\n+\t  else\n+\t    worklist->add_node (succ_fnode);\n+\t}\n+      else\n+\t{\n+\t  if (logger)\n+\t    logger->log (\"infeasible\");\n+\t  gcc_assert (rc);\n+\t  fg->add_feasibility_problem (fnode,\n+\t\t\t\t       succ_eedge,\n+\t\t\t\t       *rc);\n+\t  delete rc;\n+\n+\t  /* Give up if there have been too many infeasible edges.  */\n+\t  if (fg->get_num_infeasible ()\n+\t      > (unsigned)param_analyzer_max_infeasible_edges)\n+\t    {\n+\t      if (logger)\n+\t\tlogger->log (\"too many infeasible edges (%i); giving up\",\n+\t\t\t     fg->get_num_infeasible ());\n+\t      return false;\n+\t    }\n+\t}\n+    }\n+\n+  /* Continue the worklist iteration.  */\n+  return true;\n+}\n+\n+/* Helper class for epath_finder::dump_trimmed_graph\n+   to dump extra per-node information.\n+   Use SEP to add the length of the shortest path from each\n+   node to the target node to each node's dump.  */\n+\n+class dump_eg_with_shortest_path : public eg_traits::dump_args_t\n+{\n+public:\n+  dump_eg_with_shortest_path\n+    (const exploded_graph &eg,\n+     const shortest_paths<eg_traits, exploded_path> &sep)\n+  : dump_args_t (eg),\n+    m_sep (sep)\n+  {\n+  }\n+\n+  void dump_extra_info (const exploded_node *enode,\n+\t\t\tpretty_printer *pp) const FINAL OVERRIDE\n+  {\n+    pp_printf (pp, \"sp: %i\", m_sep.get_shortest_path (enode).length ());\n+    pp_newline (pp);\n+  }\n+\n+private:\n+  const shortest_paths<eg_traits, exploded_path> &m_sep;\n+};\n+\n+/* Dump TG to \"BASE_NAME.DESC.DIAG_IDX.to-enN.tg.dot\",\n+   annotating each node with the length of the shortest path\n+   from that node to TARGET_ENODE (using SEP).  */\n+\n+void\n+epath_finder::\n+dump_trimmed_graph (const exploded_node *target_enode,\n+\t\t    const char *desc, unsigned diag_idx,\n+\t\t    const trimmed_graph &tg,\n+\t\t    const shortest_paths<eg_traits, exploded_path> &sep)\n+{\n+  auto_timevar tv (TV_ANALYZER_DUMP);\n+  dump_eg_with_shortest_path inner_args (m_eg, sep);\n+  trimmed_graph::dump_args_t args (inner_args);\n+  pretty_printer pp;\n+  pp_printf (&pp, \"%s.%s.%i.to-en%i.tg.dot\",\n+\t     dump_base_name, desc, diag_idx, target_enode->m_index);\n+  char *filename = xstrdup (pp_formatted_text (&pp));\n+  tg.dump_dot (filename, NULL, args);\n+  free (filename);\n+}\n+\n+/* Dump FG to \"BASE_NAME.DESC.DIAG_IDX.to-enN.fg.dot\".  */\n+\n+void\n+epath_finder::dump_feasible_graph (const exploded_node *target_enode,\n+\t\t\t\t   const char *desc, unsigned diag_idx,\n+\t\t\t\t   const feasible_graph &fg)\n+{\n+  auto_timevar tv (TV_ANALYZER_DUMP);\n+  exploded_graph::dump_args_t inner_args (m_eg);\n+  feasible_graph::dump_args_t args (inner_args);\n+  pretty_printer pp;\n+  pp_printf (&pp, \"%s.%s.%i.to-en%i.fg.dot\",\n+\t     dump_base_name, desc, diag_idx, target_enode->m_index);\n+  char *filename = xstrdup (pp_formatted_text (&pp));\n+  fg.dump_dot (filename, NULL, args);\n+  free (filename);\n }\n \n /* class saved_diagnostic.  */\n@@ -174,13 +583,15 @@ saved_diagnostic::saved_diagnostic (const state_machine *sm,\n \t\t\t\t    tree var,\n \t\t\t\t    const svalue *sval,\n \t\t\t\t    state_machine::state_t state,\n-\t\t\t\t    pending_diagnostic *d)\n+\t\t\t\t    pending_diagnostic *d,\n+\t\t\t\t    unsigned idx)\n : m_sm (sm), m_enode (enode), m_snode (snode), m_stmt (stmt),\n  /* stmt_finder could be on-stack; we want our own copy that can\n     outlive that.  */\n   m_stmt_finder (stmt_finder ? stmt_finder->clone () : NULL),\n   m_var (var), m_sval (sval), m_state (state),\n   m_d (d), m_trailing_eedge (NULL),\n+  m_idx (idx),\n   m_best_epath (NULL), m_problem (NULL)\n {\n   gcc_assert (m_stmt || m_stmt_finder);\n@@ -221,7 +632,8 @@ saved_diagnostic::operator== (const saved_diagnostic &other) const\n     \"sval\": optional str,\n     \"state\": optional str,\n     \"path_length\": optional int,\n-    \"pending_diagnostic\": str}.  */\n+    \"pending_diagnostic\": str,\n+    \"idx\": int}.  */\n \n json::object *\n saved_diagnostic::to_json () const\n@@ -239,6 +651,7 @@ saved_diagnostic::to_json () const\n   if (m_best_epath)\n     sd_obj->set (\"path_length\", new json::integer_number (get_epath_length ()));\n   sd_obj->set (\"pending_diagnostic\", new json::string (m_d->get_kind ()));\n+  sd_obj->set (\"idx\", new json::integer_number (m_idx));\n \n   /* We're not yet JSONifying the following fields:\n      const gimple *m_stmt;\n@@ -267,15 +680,12 @@ saved_diagnostic::calc_best_epath (epath_finder *pf)\n   delete m_problem;\n   m_problem = NULL;\n \n-  m_best_epath = pf->get_best_epath (m_enode, m_d->get_kind (),\n+  m_best_epath = pf->get_best_epath (m_enode, m_d->get_kind (), m_idx,\n \t\t\t\t     &m_problem);\n \n   /* Handle failure to find a feasible path.  */\n   if (m_best_epath == NULL)\n-    {\n-      gcc_assert (m_problem);\n-      return false;\n-    }\n+    return false;\n \n   gcc_assert (m_best_epath);\n   if (m_stmt == NULL)\n@@ -395,11 +805,11 @@ diagnostic_manager::add_diagnostic (const state_machine *sm,\n \n   saved_diagnostic *sd\n     = new saved_diagnostic (sm, enode, snode, stmt, finder, var, sval,\n-\t\t\t    state, d);\n+\t\t\t    state, d, m_saved_diagnostics.length ());\n   m_saved_diagnostics.safe_push (sd);\n   if (get_logger ())\n     log (\"adding saved diagnostic %i at SN %i: %qs\",\n-\t m_saved_diagnostics.length () - 1,\n+\t sd->get_index (),\n \t snode->m_index, d->get_kind ());\n }\n "}, {"sha": "14549779549fa0de1d3916ee5a559783e2fad1b9", "filename": "gcc/analyzer/diagnostic-manager.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.h?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -36,7 +36,8 @@ class saved_diagnostic\n \t\t    stmt_finder *stmt_finder,\n \t\t    tree var, const svalue *sval,\n \t\t    state_machine::state_t state,\n-\t\t    pending_diagnostic *d);\n+\t\t    pending_diagnostic *d,\n+\t\t    unsigned idx);\n   ~saved_diagnostic ();\n \n   bool operator== (const saved_diagnostic &other) const;\n@@ -55,6 +56,8 @@ class saved_diagnostic\n   void add_duplicate (saved_diagnostic *other);\n   unsigned get_num_dupes () const { return m_duplicates.length (); }\n \n+  unsigned get_index () const { return m_idx; }\n+\n   //private:\n   const state_machine *m_sm;\n   const exploded_node *m_enode;\n@@ -70,6 +73,7 @@ class saved_diagnostic\n private:\n   DISABLE_COPY_AND_ASSIGN (saved_diagnostic);\n \n+  unsigned m_idx;\n   exploded_path *m_best_epath; // owned\n   feasibility_problem *m_problem; // owned\n "}, {"sha": "5792c14284776941d539d0ec1d5f17a14fe67168", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 63, "deletions": 36, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -946,48 +946,62 @@ exploded_node::dump_dot (graphviz_out *gv, const dump_args_t &args) const\n       state.dump_to_pp (ext_state, false, true, pp);\n       pp_newline (pp);\n \n-      /* Show any stmts that were processed within this enode,\n-\t and their index within the supernode.  */\n-      if (m_num_processed_stmts > 0)\n-\t{\n-\t  const program_point &point = get_point ();\n-\t  gcc_assert (point.get_kind () == PK_BEFORE_STMT);\n-\t  const supernode *snode = get_supernode ();\n-\t  const unsigned int point_stmt_idx = point.get_stmt_idx ();\n-\n-\t  pp_printf (pp, \"stmts: %i\", m_num_processed_stmts);\n-\t  pp_newline (pp);\n-\t  for (unsigned i = 0; i < m_num_processed_stmts; i++)\n-\t    {\n-\t      const unsigned int idx_within_snode = point_stmt_idx + i;\n-\t      const gimple *stmt = snode->m_stmts[idx_within_snode];\n-\t      pp_printf (pp, \"  %i: \", idx_within_snode);\n-\t      pp_gimple_stmt_1 (pp, stmt, 0, (dump_flags_t)0);\n-\t      pp_newline (pp);\n-\t    }\n-\t}\n+      dump_processed_stmts (pp);\n     }\n \n-  /* Dump any saved_diagnostics at this enode.  */\n-  {\n-    const diagnostic_manager &dm = args.m_eg.get_diagnostic_manager ();\n-    for (unsigned i = 0; i < dm.get_num_diagnostics (); i++)\n-      {\n-\tconst saved_diagnostic *sd = dm.get_saved_diagnostic (i);\n-\tif (sd->m_enode == this)\n-\t  {\n-\t    pp_printf (pp, \"DIAGNOSTIC: %s\", sd->m_d->get_kind ());\n-\t    pp_newline (pp);\n-\t  }\n-      }\n-  }\n+  dump_saved_diagnostics (pp, args.m_eg.get_diagnostic_manager ());\n+\n+  args.dump_extra_info (this, pp);\n \n   pp_write_text_as_dot_label_to_stream (pp, /*for_record=*/true);\n \n   pp_string (pp, \"\\\"];\\n\\n\");\n   pp_flush (pp);\n }\n \n+/* Show any stmts that were processed within this enode,\n+   and their index within the supernode.  */\n+void\n+exploded_node::dump_processed_stmts (pretty_printer *pp) const\n+{\n+  if (m_num_processed_stmts > 0)\n+    {\n+      const program_point &point = get_point ();\n+      gcc_assert (point.get_kind () == PK_BEFORE_STMT);\n+      const supernode *snode = get_supernode ();\n+      const unsigned int point_stmt_idx = point.get_stmt_idx ();\n+\n+      pp_printf (pp, \"stmts: %i\", m_num_processed_stmts);\n+      pp_newline (pp);\n+      for (unsigned i = 0; i < m_num_processed_stmts; i++)\n+\t{\n+\t  const unsigned int idx_within_snode = point_stmt_idx + i;\n+\t  const gimple *stmt = snode->m_stmts[idx_within_snode];\n+\t  pp_printf (pp, \"  %i: \", idx_within_snode);\n+\t  pp_gimple_stmt_1 (pp, stmt, 0, (dump_flags_t)0);\n+\t  pp_newline (pp);\n+\t}\n+    }\n+}\n+\n+/* Dump any saved_diagnostics at this enode to PP.  */\n+\n+void\n+exploded_node::dump_saved_diagnostics (pretty_printer *pp,\n+\t\t\t\t       const diagnostic_manager &dm) const\n+{\n+  for (unsigned i = 0; i < dm.get_num_diagnostics (); i++)\n+    {\n+      const saved_diagnostic *sd = dm.get_saved_diagnostic (i);\n+      if (sd->m_enode == this)\n+\t{\n+\t  pp_printf (pp, \"DIAGNOSTIC: %s (sd: %i)\",\n+\t\t     sd->m_d->get_kind (), sd->get_index ());\n+\t  pp_newline (pp);\n+\t}\n+    }\n+}\n+\n /* Dump this to PP in a form suitable for use as an id in .dot output.  */\n \n void\n@@ -1639,6 +1653,18 @@ exploded_edge::dump_dot (graphviz_out *gv, const dump_args_t &) const\n {\n   pretty_printer *pp = gv->get_pp ();\n \n+  m_src->dump_dot_id (pp);\n+  pp_string (pp, \" -> \");\n+  m_dest->dump_dot_id (pp);\n+  dump_dot_label (pp);\n+}\n+\n+/* Second half of exploded_edge::dump_dot.  This is split out\n+   for use by trimmed_graph::dump_dot and base_feasible_edge::dump_dot.  */\n+\n+void\n+exploded_edge::dump_dot_label (pretty_printer *pp) const\n+{\n   const char *style = \"\\\"solid,bold\\\"\";\n   const char *color = \"black\";\n   int weight = 10;\n@@ -1669,9 +1695,6 @@ exploded_edge::dump_dot (graphviz_out *gv, const dump_args_t &) const\n       style = \"\\\"dotted\\\"\";\n     }\n \n-  m_src->dump_dot_id (pp);\n-  pp_string (pp, \" -> \");\n-  m_dest->dump_dot_id (pp);\n   pp_printf (pp,\n \t     (\" [style=%s, color=%s, weight=%d, constraint=%s,\"\n \t      \" headlabel=\\\"\"),\n@@ -3352,6 +3375,10 @@ exploded_graph::to_json () const\n   return egraph_obj;\n }\n \n+/* class exploded_path.  */\n+\n+/* Copy ctor.  */\n+\n exploded_path::exploded_path (const exploded_path &other)\n : m_edges (other.m_edges.length ())\n {"}, {"sha": "deb739f55727e832cd2bbedf37011ec19809ce85", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -135,6 +135,9 @@ struct eg_traits\n \n     bool show_enode_details_p (const exploded_node &enode) const;\n \n+    virtual void\n+    dump_extra_info (const exploded_node *, pretty_printer *) const {}\n+\n     const exploded_graph &m_eg;\n   };\n   typedef exploded_cluster cluster_t;\n@@ -182,6 +185,10 @@ class exploded_node : public dnode<eg_traits>\n   void dump (FILE *fp, const extrinsic_state &ext_state) const;\n   void dump (const extrinsic_state &ext_state) const;\n \n+  void dump_processed_stmts (pretty_printer *pp) const;\n+  void dump_saved_diagnostics (pretty_printer *pp,\n+\t\t\t       const diagnostic_manager &dm) const;\n+\n   json::object *to_json (const extrinsic_state &ext_state) const;\n \n   /* The result of on_stmt.  */\n@@ -311,6 +318,7 @@ class exploded_edge : public dedge<eg_traits>\n   ~exploded_edge ();\n   void dump_dot (graphviz_out *gv, const dump_args_t &args)\n     const FINAL OVERRIDE;\n+  void dump_dot_label (pretty_printer *pp) const;\n \n   json::object *to_json () const;\n "}, {"sha": "bb409d61dd223413d8cc085298de225339e5b865", "filename": "gcc/analyzer/feasible-graph.cc", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fanalyzer%2Ffeasible-graph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fanalyzer%2Ffeasible-graph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Ffeasible-graph.cc?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -0,0 +1,235 @@\n+/* A graph for exploring trees of feasible paths through the egraph.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"pretty-print.h\"\n+#include \"gcc-rich-location.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"function.h\"\n+#include \"diagnostic-core.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"diagnostic-path.h\"\n+#include \"alloc-pool.h\"\n+#include \"fibonacci_heap.h\"\n+#include \"shortest-paths.h\"\n+#include \"sbitmap.h\"\n+#include \"bitmap.h\"\n+#include \"tristate.h\"\n+#include \"selftest.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"json.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+#include \"analyzer/diagnostic-manager.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/constraint-manager.h\"\n+#include \"cfg.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"cgraph.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"analyzer/program-state.h\"\n+#include \"analyzer/exploded-graph.h\"\n+#include \"analyzer/feasible-graph.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* class base_feasible_node : public dnode<fg_traits>.  */\n+\n+/* Print an id to PP for this node suitable for use in .dot dumps.  */\n+\n+void\n+base_feasible_node::dump_dot_id (pretty_printer *pp) const\n+{\n+  pp_printf (pp, \"fnode_%i\", m_index);\n+}\n+\n+/* class feasible_node : public base_feasible_node.  */\n+\n+/* Implementation of dump_dot vfunc for feasible_node.  */\n+\n+void\n+feasible_node::dump_dot (graphviz_out *gv,\n+\t\t\tconst dump_args_t &args) const\n+{\n+  pretty_printer *pp = gv->get_pp ();\n+\n+  dump_dot_id (pp);\n+  pp_printf (pp, \" [shape=none,margin=0,style=filled,fillcolor=%s,label=\\\"\",\n+\t     m_inner_node->get_dot_fillcolor ());\n+  pp_write_text_to_stream (pp);\n+\n+  pp_printf (pp, \"FN: %i (EN: %i); len=%i\", m_index, m_inner_node->m_index,\n+\t     m_path_length);\n+  pp_newline (pp);\n+\n+  format f (true);\n+  m_inner_node->get_point ().print (pp, f);\n+  pp_newline (pp);\n+\n+  /* Show the model at this point along expansion of the feasible path,\n+     rather than the model within the enode.  */\n+  m_state.get_model ().dump_to_pp (pp, true, true);\n+  pp_newline (pp);\n+\n+  m_inner_node->dump_processed_stmts (pp);\n+  m_inner_node->dump_saved_diagnostics\n+    (pp, args.m_inner_args.m_eg.get_diagnostic_manager ());\n+\n+  pp_write_text_as_dot_label_to_stream (pp, /*for_record=*/true);\n+\n+  pp_string (pp, \"\\\"];\\n\\n\");\n+  pp_flush (pp);\n+}\n+\n+/* Implementation of dump_dot vfunc for infeasible_node.\n+   In particular, show the rejected constraint.  */\n+\n+void\n+infeasible_node::dump_dot (graphviz_out *gv,\n+\t\t\t   const dump_args_t &) const\n+{\n+  pretty_printer *pp = gv->get_pp ();\n+\n+  dump_dot_id (pp);\n+  pp_printf (pp, \" [shape=none,margin=0,style=filled,fillcolor=%s,label=\\\"\",\n+\t     m_inner_node->get_dot_fillcolor ());\n+  pp_write_text_to_stream (pp);\n+\n+  pp_printf (pp, \"infeasible edge to EN: %i\", m_inner_node->m_index);\n+  pp_newline (pp);\n+\n+  pp_string (pp, \"rejected constraint:\");\n+  pp_newline (pp);\n+  m_rc.dump_to_pp (pp);\n+\n+  pp_write_text_as_dot_label_to_stream (pp, /*for_record=*/true);\n+\n+  pp_string (pp, \"\\\"];\\n\\n\");\n+  pp_flush (pp);\n+}\n+\n+/* class base_feasible_edge : public dedge<fg_traits>.  */\n+\n+/* Implementation of dump_dot vfunc for base_easible_edge.  */\n+\n+void\n+base_feasible_edge::dump_dot (graphviz_out *gv, const dump_args_t &) const\n+{\n+  pretty_printer *pp = gv->get_pp ();\n+\n+  m_src->dump_dot_id (pp);\n+  pp_string (pp, \" -> \");\n+  m_dest->dump_dot_id (pp);\n+\n+  m_inner_edge->dump_dot_label (pp);\n+}\n+\n+/* class feasible_graph : public digraph <fg_traits>.  */\n+\n+/* Ctor for feasible_graph.  */\n+\n+feasible_graph::feasible_graph ()\n+: m_num_infeasible (0)\n+{\n+}\n+\n+/* Add a feasible_node to this graph for ENODE, STATE with the\n+   given PATH_LENGTH. */\n+\n+feasible_node *\n+feasible_graph::add_node (const exploded_node *enode,\n+\t\t\t  const feasibility_state &state,\n+\t\t\t  unsigned path_length)\n+{\n+  /* We don't attempt get_or_create here.  */\n+  feasible_node *fnode = new feasible_node (enode, m_nodes.length (),\n+\t\t\t\t\t    state, path_length);\n+  digraph<fg_traits>::add_node (fnode);\n+  return fnode;\n+}\n+\n+/* Add an infeasible_node to this graph and an infeasible_edge connecting\n+   to it from SRC_FNODE, capturing a failure of RC along EEDGE.  */\n+\n+void\n+feasible_graph::add_feasibility_problem (feasible_node *src_fnode,\n+\t\t\t\t\t const exploded_edge *eedge,\n+\t\t\t\t\t const rejected_constraint &rc)\n+{\n+  infeasible_node *dst_fnode\n+    = new infeasible_node (eedge->m_dest, m_nodes.length (), rc);\n+  digraph<fg_traits>::add_node (dst_fnode);\n+  add_edge (new infeasible_edge (src_fnode, dst_fnode, eedge));\n+  m_num_infeasible++;\n+}\n+\n+/* Make an exploded_path from the origin to FNODE's exploded_node,\n+   following the edges in the feasible_graph.  */\n+\n+exploded_path *\n+feasible_graph::make_epath (feasible_node *fnode) const\n+{\n+  exploded_path *epath = new exploded_path ();\n+\n+  /* FG is actually a tree.  Built the path backwards, by walking\n+     backwards from FNODE until we reach the origin.  */\n+  while (fnode->get_inner_node ()->m_index != 0)\n+    {\n+      gcc_assert (fnode->m_preds.length () == 1);\n+      feasible_edge *pred_fedge\n+\t= static_cast <feasible_edge *> (fnode->m_preds[0]);\n+      epath->m_edges.safe_push (pred_fedge->get_inner_edge ());\n+      fnode = static_cast <feasible_node *> (pred_fedge->m_src);\n+    }\n+\n+  /* Now reverse it.  */\n+  epath->m_edges.reverse ();\n+\n+  return epath;\n+}\n+\n+/* Dump stats about this graph to LOGGER.  */\n+\n+void\n+feasible_graph::log_stats (logger *logger) const\n+{\n+  logger->log (\"#nodes: %i\", m_nodes.length ());\n+  logger->log (\"#edges: %i\", m_edges.length ());\n+  logger->log (\"#feasible nodes: %i\", m_nodes.length () - m_num_infeasible);\n+  logger->log (\"#feasible edges: %i\", m_edges.length () - m_num_infeasible);\n+  logger->log (\"#infeasible nodes/edges: %i\", m_num_infeasible);\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "5a580f4b9254a89f21d6d1a408179ae64e4ad1e4", "filename": "gcc/analyzer/feasible-graph.h", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fanalyzer%2Ffeasible-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fanalyzer%2Ffeasible-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Ffeasible-graph.h?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -0,0 +1,213 @@\n+/* A graph for exploring trees of feasible paths through the egraph.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_FEASIBLE_GRAPH_H\n+#define GCC_ANALYZER_FEASIBLE_GRAPH_H\n+\n+namespace ana {\n+\n+/* Forward decls.  */\n+\n+class base_feasible_node;\n+  class feasible_node;\n+  class infeasible_node;\n+class base_feasible_edge;\n+  class feasible_edge;\n+  class infeasible_edge;\n+class feasible_graph;\n+class feasible_cluster;\n+\n+/* A traits class for feasible_graph.  */\n+\n+struct fg_traits\n+{\n+  typedef base_feasible_node node_t;\n+  typedef base_feasible_edge edge_t;\n+  typedef feasible_graph graph_t;\n+  struct dump_args_t\n+  {\n+    typedef typename eg_traits::dump_args_t inner_args_t;\n+\n+    dump_args_t (const inner_args_t &inner_args)\n+    : m_inner_args (inner_args)\n+    {\n+    }\n+\n+    const inner_args_t &m_inner_args;\n+  };\n+  typedef feasible_cluster cluster_t;\n+};\n+\n+/* Base class of node within a feasible_graph.\n+   There can be 0 or more base_feasible_nodes per exploded_node.  */\n+\n+class base_feasible_node : public dnode<fg_traits>\n+{\n+ public:\n+  void dump_dot_id (pretty_printer *pp) const;\n+\n+  const exploded_node *get_inner_node () const { return m_inner_node; }\n+  unsigned get_index () const { return m_index; }\n+\n+ protected:\n+  base_feasible_node (const exploded_node *inner_node, unsigned index)\n+  : m_inner_node (inner_node), m_index (index)\n+  {}\n+\n+  const exploded_node *m_inner_node;\n+  unsigned m_index;\n+};\n+\n+/* Subclass of base_feasible_node for a node that is reachable via a\n+   feasible path, with a particular state.  */\n+\n+class feasible_node : public base_feasible_node\n+{\n+public:\n+  feasible_node (const exploded_node *inner_node, unsigned index,\n+\t\t const feasibility_state &state,\n+\t\t unsigned path_length)\n+  : base_feasible_node (inner_node, index),\n+    m_state (state),\n+    m_path_length (path_length)\n+  {\n+  }\n+\n+  void dump_dot (graphviz_out *gv,\n+\t\t const dump_args_t &args) const FINAL OVERRIDE;\n+\n+  const feasibility_state &get_state () const { return m_state; }\n+  const region_model &get_model () const { return m_state.get_model (); }\n+  const auto_sbitmap &get_snodes_visited () const\n+  {\n+    return m_state.get_snodes_visited ();\n+  }\n+\n+  unsigned get_path_length () const { return m_path_length; }\n+\n+private:\n+  feasibility_state m_state;\n+  unsigned m_path_length;\n+};\n+\n+/* Subclass of base_feasible_node for a node that requires following\n+   an infeasible edge to reach (and thus terminating this part of the\n+   exploration).  */\n+\n+class infeasible_node : public base_feasible_node\n+{\n+public:\n+  infeasible_node (const exploded_node *inner_node, unsigned index,\n+\t\t   const rejected_constraint &rc)\n+  : base_feasible_node (inner_node, index),\n+    m_rc (rc)\n+  {\n+  }\n+\n+  void dump_dot (graphviz_out *gv,\n+\t\t const dump_args_t &args) const FINAL OVERRIDE;\n+\n+private:\n+  rejected_constraint m_rc;\n+};\n+\n+/* Base class of edge within a feasible_graph.  */\n+\n+class base_feasible_edge : public dedge<fg_traits>\n+{\n+ public:\n+  void dump_dot (graphviz_out *gv,\n+\t\t const dump_args_t &args) const FINAL OVERRIDE;\n+\n+  const exploded_edge *get_inner_edge () const { return m_inner_edge; }\n+\n+ protected:\n+  base_feasible_edge (base_feasible_node *src, base_feasible_node *dest,\n+\t\t      const exploded_edge *inner_edge)\n+  : dedge<fg_traits> (src, dest), m_inner_edge (inner_edge)\n+  {\n+  }\n+\n+  const exploded_edge *m_inner_edge;\n+};\n+\n+/* Subclass of base_feasible_edge for connecting two feasible_nodes.  */\n+\n+class feasible_edge : public base_feasible_edge\n+{\n+ public:\n+  feasible_edge (feasible_node *src, feasible_node *dest,\n+\t\t const exploded_edge *inner_edge)\n+  : base_feasible_edge (src, dest, inner_edge)\n+  {\n+  }\n+};\n+\n+/* Subclass of base_feasible_edge for connecting a feasible_node\n+   to an infeasible_node (and thus terminating this part of the\n+   exploration).  */\n+\n+class infeasible_edge : public base_feasible_edge\n+{\n+ public:\n+  infeasible_edge (feasible_node *src, infeasible_node *dest,\n+\t\t   const exploded_edge *inner_edge)\n+  : base_feasible_edge (src, dest, inner_edge)\n+  {\n+  }\n+};\n+\n+/* A digraph subclass for exploring trees of feasible paths through\n+   the egraph.  This is actually a tree.\n+\n+   The paths within the graph of feasible_nodes express feasible paths\n+   through the graph, and it also captures known infeasible edges,\n+   which is invaluable for debugging.  */\n+\n+class feasible_graph : public digraph <fg_traits>\n+{\n+ public:\n+  feasible_graph ();\n+\n+  feasible_node *add_node (const exploded_node *enode,\n+\t\t\t   const feasibility_state &state,\n+\t\t\t   unsigned path_length);\n+\n+  void add_feasibility_problem (feasible_node *src_fnode,\n+\t\t\t\tconst exploded_edge *eedge,\n+\t\t\t\tconst rejected_constraint &rc);\n+\n+  exploded_path *make_epath (feasible_node *fnode) const;\n+\n+  unsigned get_num_infeasible () const { return m_num_infeasible; }\n+\n+  void log_stats (logger *logger) const;\n+\n+private:\n+  unsigned m_num_infeasible;\n+};\n+\n+class feasible_cluster : public cluster <fg_traits>\n+{\n+};\n+\n+} // namespace ana\n+\n+#endif /* GCC_ANALYZER_FEASIBLE_GRAPH_H */"}, {"sha": "2e23a0960b65137880ac8df5f318ffae446c9791", "filename": "gcc/analyzer/trimmed-graph.cc", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fanalyzer%2Ftrimmed-graph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fanalyzer%2Ftrimmed-graph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Ftrimmed-graph.cc?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -0,0 +1,172 @@\n+/* Trimming an exploded graph to a subset of nodes and edges.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"pretty-print.h\"\n+#include \"gcc-rich-location.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"function.h\"\n+#include \"diagnostic-core.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"diagnostic-path.h\"\n+#include \"alloc-pool.h\"\n+#include \"fibonacci_heap.h\"\n+#include \"shortest-paths.h\"\n+#include \"sbitmap.h\"\n+#include \"bitmap.h\"\n+#include \"tristate.h\"\n+#include \"selftest.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"json.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+#include \"analyzer/diagnostic-manager.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/constraint-manager.h\"\n+#include \"cfg.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"cgraph.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"analyzer/program-state.h\"\n+#include \"analyzer/exploded-graph.h\"\n+#include \"analyzer/trimmed-graph.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* class trimmed_node : public dnode<tg_traits>.  */\n+\n+/* Implementation of dump_dot vfunc, delegating to the inner node.  */\n+\n+void\n+trimmed_node::dump_dot (graphviz_out *gv,\n+\t\t\tconst dump_args_t &args) const\n+{\n+  m_inner_node->dump_dot (gv, args.m_inner_args);\n+}\n+\n+/* class trimmed_edge : public dedge<tg_traits>.  */\n+\n+/* trimmed_edge's ctor.  */\n+\n+trimmed_edge::trimmed_edge (trimmed_node *src, trimmed_node *dest,\n+\t\t\t    const exploded_edge *inner_edge)\n+: dedge<tg_traits> (src, dest), m_inner_edge (inner_edge)\n+{\n+}\n+\n+/* Implementation of dump_dot vfunc, delegating to the inner edge.  */\n+\n+void\n+trimmed_edge::dump_dot (graphviz_out *gv, const dump_args_t &args) const\n+{\n+  m_inner_edge->dump_dot (gv, args.m_inner_args);\n+}\n+\n+/* class trimmed_graph : public digraph <tg_traits>.  */\n+\n+/* Ctor for trimmed_graph: construct a graph equivalent to trimming\n+   INNER_GRAPH to all nodes that can reach INNER_DST_NODE.  */\n+\n+trimmed_graph::trimmed_graph (const exploded_graph &inner_graph,\n+\t\t\t      const exploded_node *inner_dst_node)\n+: m_enodes (), m_eedges ()\n+{\n+  /* Determine what subset of nodes and edges to include in the\n+     trimmed graph.\n+     Walk backwards from INNER_DST_NODE, finding nodes that reach it,\n+     iteratively building the set of nodes and edges.  */\n+  auto_vec <const exploded_node *> worklist;\n+  worklist.safe_push (inner_dst_node);\n+  m_enodes.add (inner_dst_node);\n+  while (worklist.length () > 0)\n+    {\n+      const exploded_node *inner_node = worklist.pop ();\n+      exploded_edge *inner_pred;\n+      unsigned i;\n+      FOR_EACH_VEC_ELT (inner_node->m_preds, i, inner_pred)\n+\t{\n+\t  if (!m_enodes.contains (inner_pred->m_src))\n+\t    {\n+\t      worklist.safe_push (inner_pred->m_src);\n+\t      m_enodes.add (inner_pred->m_src);\n+\t    }\n+\t  m_eedges.add (inner_pred);\n+\t}\n+    }\n+\n+  /* Create trimmed nodes for all enodes in the set.  */\n+  {\n+    /* Iterate over the vec rather than the hash_set\n+       to ensure deterministic order.  */\n+    exploded_node *inner_node;\n+    unsigned i;\n+    FOR_EACH_VEC_ELT (inner_graph.m_nodes, i, inner_node)\n+      if (m_enodes.contains (inner_node))\n+\t{\n+\t  trimmed_node *tnode = new trimmed_node (inner_node);\n+\t  add_node (tnode);\n+\t  m_map_from_enode_to_tnode.put (inner_node, tnode);\n+\t}\n+  }\n+\n+  /* Create trimmed edges for all edges in the set.  */\n+  {\n+    /* Iterate over the vec rather than the hash_set\n+       to ensure deterministic order.  */\n+    exploded_edge *inner_edge;\n+    unsigned i;\n+    FOR_EACH_VEC_ELT (inner_graph.m_edges, i, inner_edge)\n+      if (m_eedges.contains (inner_edge))\n+\t{\n+\t  const exploded_node *inner_src = inner_edge->m_src;\n+\t  const exploded_node *inner_dest = inner_edge->m_dest;\n+\t  trimmed_node *tsrc = *m_map_from_enode_to_tnode.get (inner_src);\n+\t  trimmed_node *tdest = *m_map_from_enode_to_tnode.get (inner_dest);\n+\t  trimmed_edge *tedge = new trimmed_edge (tsrc, tdest, inner_edge);\n+\t  add_edge (tedge);\n+\t}\n+  }\n+}\n+\n+/* Dump stats about this graph to LOGGER.  */\n+\n+void\n+trimmed_graph::log_stats (logger *logger) const\n+{\n+  logger->log (\"#nodes: %i\", m_nodes.length ());\n+  logger->log (\"#edges: %i\", m_edges.length ());\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "bfe243a4e1cc05d0828458da526d261cf7058470", "filename": "gcc/analyzer/trimmed-graph.h", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fanalyzer%2Ftrimmed-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fanalyzer%2Ftrimmed-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Ftrimmed-graph.h?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -0,0 +1,122 @@\n+/* Trimming an exploded graph to a subset of nodes and edges.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_TRIMMED_GRAPH_H\n+#define GCC_ANALYZER_TRIMMED_GRAPH_H\n+\n+namespace ana {\n+\n+/* Forward decls.  */\n+\n+class trimmed_node;\n+class trimmed_edge;\n+class trimmed_graph;\n+class trimmed_cluster;\n+\n+/* A traits class for trimming a digraph to a subset of nodes and edges.  */\n+\n+struct tg_traits\n+{\n+  typedef trimmed_node node_t;\n+  typedef trimmed_edge edge_t;\n+  typedef trimmed_graph graph_t;\n+  struct dump_args_t\n+  {\n+    typedef typename eg_traits::dump_args_t inner_args_t;\n+\n+    dump_args_t (const inner_args_t &inner_args)\n+    : m_inner_args (inner_args)\n+    {\n+    }\n+\n+    const inner_args_t &m_inner_args;\n+  };\n+  typedef trimmed_cluster cluster_t;\n+};\n+\n+/* A node within the trimmed_graph, corresponding to an \"inner node\"\n+   within the original exploded_graph.  */\n+\n+class trimmed_node : public dnode<tg_traits>\n+{\n+public:\n+  trimmed_node (const exploded_node *inner_node)\n+  : m_inner_node (inner_node) {}\n+\n+  void dump_dot (graphviz_out *gv,\n+\t\t const dump_args_t &args) const FINAL OVERRIDE;\n+\n+private:\n+  const exploded_node *m_inner_node;\n+};\n+\n+/* An edge within the trimmed_graph, corresponding to an \"inner edge\"\n+   within the original exploded_graph.  */\n+\n+class trimmed_edge : public dedge<tg_traits>\n+{\n+ public:\n+  trimmed_edge (trimmed_node *src, trimmed_node *dest,\n+\t\tconst exploded_edge *inner_edge);\n+\n+  void dump_dot (graphviz_out *gv,\n+\t\t const dump_args_t &args) const FINAL OVERRIDE;\n+\n+ private:\n+  const exploded_edge *m_inner_edge;\n+};\n+\n+/* A digraph for trimming an exploded_graph to the subset of nodes and edges\n+   from which paths reach INNER_DST_NODE (along with a precanned way to print\n+   these in .dot form).  */\n+\n+class trimmed_graph : public digraph <tg_traits>\n+{\n+ public:\n+  trimmed_graph (const exploded_graph &inner_graph,\n+\t\t const exploded_node *inner_dst_node);\n+\n+  bool contains_p (const exploded_edge *eedge) const\n+  {\n+    hash_set <const exploded_edge *> & mut\n+      = const_cast <hash_set <const exploded_edge *> &> (m_eedges);\n+    return mut.contains (eedge);\n+  }\n+\n+  void log_stats (logger *logger) const;\n+\n+ private:\n+  /* The subset of nodes in the inner graph that are in the\n+     trimmed graph.  */\n+  hash_set <const exploded_node *> m_enodes;\n+  /* Likewise for edges.  */\n+  hash_set <const exploded_edge *> m_eedges;\n+\n+  typedef hash_map<const exploded_node *, trimmed_node *> map_t;\n+  map_t m_map_from_enode_to_tnode;\n+};\n+\n+class trimmed_cluster : public cluster <tg_traits>\n+{\n+};\n+\n+} // namespace ana\n+\n+#endif /* GCC_ANALYZER_TRIMMED_GRAPH_H */"}, {"sha": "3f7bcf3c115eea9cf63a8f4e706511d7ae6c0aab", "filename": "gcc/doc/analyzer.texi", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fdoc%2Fanalyzer.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fdoc%2Fanalyzer.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fanalyzer.texi?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -320,22 +320,56 @@ feasible\n @end itemize\n \n Without state-merging, all paths in the exploded graph are feasible\n-(in terms of constraints being satisified).\n+(in terms of constraints being satisfied).\n With state-merging, paths in the exploded graph can be infeasible.\n \n We collate warnings and only emit them for the simplest path\n e.g. for a bug in a utility function, with lots of routes to calling it,\n we only emit the simplest path (which could be intraprocedural, if\n-it can be reproduced without a caller).  We apply a check that\n-each duplicate warning's shortest path is feasible, rejecting any\n-warnings for which the shortest path is infeasible (which could lead to\n-false negatives).  This check can be suppressed (for debugging purposes)\n-using @option{-fno-analyzer-feasibility}.\n-\n-We use the shortest feasible @code{exploded_path} through the\n-@code{exploded_graph} (a list of @code{exploded_edge *}) to build a\n-@code{diagnostic_path} (a list of events for the diagnostic subsystem) -\n-specifically a @code{checker_path}.\n+it can be reproduced without a caller).\n+\n+We thus want to find the shortest feasible path through the exploded\n+graph from the origin to the exploded node at which the diagnostic was\n+saved.  Unfortunately, if we simply find the shortest such path and\n+check if it's feasible we might falsely reject the diagnostic, as there\n+might be a longer path that is feasible.  Examples include the cases\n+where the diagnostic requires us to go at least once around a loop for a\n+later condition to be satisfied, or where for a later condition to be\n+satisfied we need to enter a suite of code that the simpler path skips.\n+\n+We attempt to find the shortest feasible path to each diagnostic by\n+first constructing a ``trimmed graph'' from the exploded graph,\n+containing only those nodes and edges from which there are paths to\n+the target node, and using Dijkstra's algorithm to order the trimmed\n+nodes by minimal distance to the target.\n+\n+We then use a worklist to iteratively build a ``feasible graph''\n+(actually a tree), capturing the pertinent state along each path, in\n+which every path to a ``feasible node'' is feasible by construction,\n+restricting ourselves to the trimmed graph to ensure we stay on target,\n+and ordering the worklist so that the first feasible path we find to the\n+target node is the shortest possible path.  Hence we start by trying the\n+shortest possible path, but if that fails, we explore progressively\n+longer paths, eventually trying iterations through loops.  The\n+exploration is captured in the feasible_graph, which can be dumped as a\n+.dot file via @option{-fdump-analyzer-feasibility} to visualize the\n+exploration.  The indices of the feasible nodes show the order in which\n+they were created.  We effectively explore the tree of feasible paths in\n+order of shortest path until we either find a feasible path to the\n+target node, or hit a limit and give up.\n+\n+This is something of a brute-force approach, but the trimmed graph\n+hopefully keeps the complexity manageable.\n+\n+This algorithm can be disabled (for debugging purposes) via\n+@option{-fno-analyzer-feasibility}, which simply uses the shortest path,\n+and notes if it is infeasible.\n+\n+The above gives us a shortest feasible @code{exploded_path} through the\n+@code{exploded_graph} (a list of @code{exploded_edge *}).  We use this\n+@code{exploded_path} to build a @code{diagnostic_path} (a list of\n+@strong{events} for the diagnostic subsystem) - specifically a\n+@code{checker_path}.\n \n Having built the @code{checker_path}, we prune it to try to eliminate\n events that aren't relevant, to minimize how much the user has to read."}, {"sha": "4a3c1e2fa0f29ceff853086ee5503d01fb339f88", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -424,6 +424,7 @@ Objective-C and Objective-C++ Dialects}.\n -fdump-analyzer-exploded-nodes @gol\n -fdump-analyzer-exploded-nodes-2 @gol\n -fdump-analyzer-exploded-nodes-3 @gol\n+-fdump-analyzer-feasibility @gol\n -fdump-analyzer-json @gol\n -fdump-analyzer-state-purge @gol\n -fdump-analyzer-supergraph @gol\n@@ -9566,6 +9567,13 @@ Dump a textual representation of the ``exploded graph'' to\n one dump file per node, to @file{@var{file}.eg-@var{id}.txt}.\n This is typically a large number of dump files.\n \n+@item -fdump-analyzer-feasibility\n+@opindex dump-analyzer-feasibility\n+Dump internal details about the analyzer's search for feasible paths.\n+The details are written in a form suitable for viewing with GraphViz\n+to filenames of the form @file{@var{file}.*.fg.dot} and\n+@file{@var{file}.*.tg.dot}.\n+\n @item -fdump-analyzer-json\n @opindex fdump-analyzer-json\n Dump a compressed JSON representation of analyzer internals to"}, {"sha": "f544d7d456df2ff88d03a2b7c13ec5e7782c9a17", "filename": "gcc/shortest-paths.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fshortest-paths.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Fshortest-paths.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshortest-paths.h?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -57,6 +57,7 @@ class shortest_paths\n \t\t  enum shortest_path_sense sense);\n \n   path_t get_shortest_path (const node_t *other_node) const;\n+  int get_shortest_distance (const node_t *other_node) const;\n \n private:\n   const graph_t &m_graph;\n@@ -199,4 +200,16 @@ get_shortest_path (const node_t *other_node) const\n   return result;\n }\n \n+/* Get the shortest distance...\n+   SPS_FROM_GIVEN_ORIGIN: ...from given origin node to OTHER_NODE\n+   SPS_TO_GIVEN_TARGET: ...from OTHER_NODE to given target node.  */\n+\n+template <typename GraphTraits, typename Path_t>\n+inline int\n+shortest_paths<GraphTraits, Path_t>::\n+get_shortest_distance (const node_t *other_node) const\n+{\n+  return m_dist[other_node->m_index];\n+}\n+\n #endif /* GCC_SHORTEST_PATHS_H */"}, {"sha": "03405cdf4a0963ee2ad9130eb647995df144a776", "filename": "gcc/testsuite/gcc.dg/analyzer/dot-output.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdot-output.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdot-output.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdot-output.c?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -2,7 +2,7 @@\n    by .dot.  */\n \n /* { dg-require-dot \"\" } */\n-/* { dg-additional-options \"-fdump-analyzer-callgraph -fdump-analyzer-exploded-graph -fdump-analyzer-state-purge -fdump-analyzer-supergraph\" } */\n+/* { dg-additional-options \"-fdump-analyzer-callgraph -fdump-analyzer-exploded-graph -fdump-analyzer-state-purge -fdump-analyzer-supergraph -fdump-analyzer-feasibility\" } */\n \n #include <stdlib.h>\n "}, {"sha": "83ec1cab58be8ae79685f0f5728de6bc55758bb4", "filename": "gcc/testsuite/gcc.dg/analyzer/feasibility-1.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffeasibility-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffeasibility-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffeasibility-1.c?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -55,8 +55,7 @@ int test_6 (int a, int b)\n     {\n       if (!problem)\n \tproblem = 2;\n-      __analyzer_dump_path (); /* { dg-message \"path\" \"\" { xfail *-*-* } } */\n-      /* XFAIL is PR analyzer/96374.  */\n+      __analyzer_dump_path (); /* { dg-message \"path\" } */\n     }\n   return problem;\n }\n@@ -86,3 +85,16 @@ int test_6a (int a, int b, void *ptr)\n     }\n   return problem;\n }\n+\n+/* After state-merging, the shortest path skips the loop,\n+   but the shortest feasible path enters it.  */\n+\n+void test_7 (int n)\n+{\n+  int entered_loop = 0;\n+  int i;\n+  for (i = 0; i < n; i++)\n+    entered_loop = 1;\n+  if (entered_loop)\n+    __analyzer_dump_path (); /* { dg-message \"path\" } */\n+}"}, {"sha": "148429768cd6334abd72de29c7d552035c563955", "filename": "gcc/testsuite/gcc.dg/analyzer/pr93355-localealias-feasibility-2.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias-feasibility-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias-feasibility-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias-feasibility-2.c?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -25,7 +25,5 @@ _nl_expand_alias (void)\n     ++locale_alias_path;\n \n   if (start < locale_alias_path)\n-    __analyzer_dump_path (); /* { dg-message \"path\" \"\" { xfail *-*-* } } */\n-  /* XFAIL: PR analyzer/96374\n-     Use -fno-analyzer-feasibility to see the path.  */\n+    __analyzer_dump_path (); /* { dg-message \"path\" } */\n }"}, {"sha": "50d338855bcb2f16f6e39513b5e38bdbaa31d81c", "filename": "gcc/testsuite/gcc.dg/analyzer/pr93355-localealias-feasibility-3.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias-feasibility-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias-feasibility-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias-feasibility-3.c?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -41,9 +41,7 @@ read_alias_file (const char *fname, char *cp)\n {\n   FILE *fp;\n \n-  fp = fopen (fname, \"r\"); /* { dg-message \"opened here\" \"\" { xfail *-*-* } } */\n-  /* XFAIL: PR analyzer/96374\n-     Use -fno-analyzer-feasibility to see the path.  */\n+  fp = fopen (fname, \"r\"); /* { dg-message \"opened here\" } */\n   if (fp == NULL)\n     return 0;\n \n@@ -54,9 +52,7 @@ read_alias_file (const char *fname, char *cp)\n     ++cp;\n \n   if (cp[0] != '\\0')\n-    return 42; /* { dg-warning \"leak of FILE 'fp'\" \"\" { xfail *-*-* } } */\n-  /* XFAIL: PR analyzer/96374\n-     Use -fno-analyzer-feasibility to see the path.  */\n+    return 42; /* { dg-warning \"leak of FILE 'fp'\" } */\n \n   fclose(fp);\n "}, {"sha": "1a34d05174ac64de09b376886ef99aefee45a93f", "filename": "gcc/testsuite/gcc.dg/analyzer/pr93355-localealias-feasibility.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias-feasibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias-feasibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias-feasibility.c?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -3,8 +3,6 @@\n    Adapted from intl/localealias.c, with all #includes removed.  */\n \n /* { dg-do \"compile\" } */\n-/* { dg-additional-options \"-fno-analyzer-feasibility\" } */\n-/* TODO: remove the need for this option.  */\n \n /* Handle aliases for locale names.\n    Copyright (C) 1995-1999, 2000-2001, 2003 Free Software Foundation, Inc."}, {"sha": "88d0fc1fe43f3cd3fc30bf6d7a913cdf5f59eca0", "filename": "gcc/testsuite/gcc.dg/analyzer/pr93355-localealias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias.c?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -3,8 +3,8 @@\n    Adapted from intl/localealias.c, with all #includes removed.  */\n \n /* { dg-do \"compile\" } */\n-/* { dg-additional-options \"-Wno-analyzer-too-complex -fno-analyzer-feasibility\" } */\n-/* TODO: remove the need for these options.  */\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+/* TODO: remove the need for this option.  */\n /* { dg-require-effective-target alloca } */\n \n /* Handle aliases for locale names."}, {"sha": "bd1ab1e5476160091753cff62dd2ba9f7063d080", "filename": "gcc/testsuite/gcc.dg/analyzer/unknown-fns-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funknown-fns-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funknown-fns-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funknown-fns-4.c?ref=3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "patch": "@@ -10,6 +10,6 @@ void test (void)\n \tgot = 1;\n       else\n \tif (got)\n-\t  __analyzer_dump_path (); /* { dg-message \"path\" \"\" { xfail *-*-* } } */\n+\t  __analyzer_dump_path (); /* { dg-message \"path\" } */\n     }\n }"}]}