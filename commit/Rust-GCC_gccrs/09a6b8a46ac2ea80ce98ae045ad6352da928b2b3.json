{"sha": "09a6b8a46ac2ea80ce98ae045ad6352da928b2b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDlhNmI4YTQ2YWMyZWE4MGNlOThhZTA0NWFkNjM1MmRhOTI4YjJiMw==", "commit": {"author": {"name": "Danny Smith", "email": "dannysmith@users.sourceforge.net", "date": "2009-10-07T02:57:21Z"}, "committer": {"name": "Danny Smith", "email": "dannysmith@gcc.gnu.org", "date": "2009-10-07T02:57:21Z"}, "message": "re PR target/41512 (dllexport broken on cygwin)\n\n\tPR target/41512\n\t* config/i386/winnt.c (i386_pe_determine_dllexport_p): Don't propagate\n\tdllexport to class members here.\n\t(i386_pe_determine_dllimport_p): Only check static class data for\n\tdefinition.\n\t(i386_pe_encode_section_info): Don't recheck DECL_DLLIMPORT_P.\n\t* config/i386/winnt-cxx.c (i386_pe_type_dllimport_p): Only check\n\tfunctions for vague linkage.\n\t(i386_pe_type_dllexport_p): Fix formatting.\n\t(maybe_add_dllexport) New function.\n\t(i386_pe_adjust_class_at_definition): Use it to propagate dllexport\n\tto class members.\n\nFrom-SVN: r152511", "tree": {"sha": "63f4df3174db5442106145ab1bfe4b9b8f7528c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63f4df3174db5442106145ab1bfe4b9b8f7528c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09a6b8a46ac2ea80ce98ae045ad6352da928b2b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09a6b8a46ac2ea80ce98ae045ad6352da928b2b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09a6b8a46ac2ea80ce98ae045ad6352da928b2b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09a6b8a46ac2ea80ce98ae045ad6352da928b2b3/comments", "author": null, "committer": null, "parents": [{"sha": "e4f512b710b5be1435c26bcca4030a65dada5a4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4f512b710b5be1435c26bcca4030a65dada5a4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4f512b710b5be1435c26bcca4030a65dada5a4b"}], "stats": {"total": 215, "additions": 121, "deletions": 94}, "files": [{"sha": "98e91f68a5524457fdd26056bb4c77acf5d349ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09a6b8a46ac2ea80ce98ae045ad6352da928b2b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09a6b8a46ac2ea80ce98ae045ad6352da928b2b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09a6b8a46ac2ea80ce98ae045ad6352da928b2b3", "patch": "@@ -1,4 +1,20 @@\n-2009-10-07  Ben Elliston  <bje@au.ibm.com>\n+\n+2009-10-07  Danny Smith  <dannysmith@users.sourceforge.net>\n+\n+\tPR target/41512\n+\t* config/i386/winnt.c (i386_pe_determine_dllexport_p): Don't propagate\n+\tdllexport to class members here.\n+\t(i386_pe_determine_dllimport_p): Only check static class data for\n+\tdefinition.\n+\t(i386_pe_encode_section_info): Don't recheck DECL_DLLIMPORT_P.\n+\t* config/i386/winnt-cxx.c (i386_pe_type_dllimport_p): Only check\n+\tfunctions for vague linkage.\n+\t(i386_pe_type_dllexport_p): Fix formatting.\n+\t(maybe_add_dllexport) New function.\n+\t(i386_pe_adjust_class_at_definition): Use it to propagate dllexport\n+\tto class members.\n+\t\n+\t2009-10-07  Ben Elliston  <bje@au.ibm.com>\n \n \t* config/rs6000/a2.md: Remove duplicated lines.\n "}, {"sha": "48518adc765f5e44104304b65a82ff78240eb9b4", "filename": "gcc/config/i386/winnt-cxx.c", "status": "modified", "additions": 91, "deletions": 69, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09a6b8a46ac2ea80ce98ae045ad6352da928b2b3/gcc%2Fconfig%2Fi386%2Fwinnt-cxx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09a6b8a46ac2ea80ce98ae045ad6352da928b2b3/gcc%2Fconfig%2Fi386%2Fwinnt-cxx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt-cxx.c?ref=09a6b8a46ac2ea80ce98ae045ad6352da928b2b3", "patch": "@@ -1,7 +1,6 @@\n /* Target support for C++ classes on Windows.\n    Contributed by Danny Smith (dannysmith@users.sourceforge.net)\n-   Copyright (C) 2005, 2007\n-   Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2007, 2009  Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -28,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hard-reg-set.h\"\n #include \"output.h\"\n #include \"tree.h\"\n-#include \"cp/cp-tree.h\" /* this is why we're a separate module */\n+#include \"cp/cp-tree.h\" /* This is why we're a separate module.  */\n #include \"flags.h\"\n #include \"tm_p.h\"\n #include \"toplev.h\"\n@@ -52,49 +51,44 @@ i386_pe_type_dllimport_p (tree decl)\n \t  || DECL_TEMPLATE_INSTANTIATION (decl)\n \t  || DECL_ARTIFICIAL (decl)))\n     return false;\n-\n-\n-  /* Don't mark defined functions as dllimport.  This code will only be\n-     reached if we see a non-inline function defined out-of-class.  */\n-  else if (TREE_CODE (decl) ==  FUNCTION_DECL\n-\t   && (DECL_INITIAL (decl)))\n-    return false;\n-\n-  /*  Don't allow definitions of static data members in dllimport class,\n-      If vtable data is marked as DECL_EXTERNAL, import it; otherwise just\n-      ignore the class attribute.  */\n-  else if (TREE_CODE (decl) == VAR_DECL\n-\t   && TREE_STATIC (decl) && TREE_PUBLIC (decl)\n-\t   && !DECL_EXTERNAL (decl))\n-    {\n-      if (!DECL_VIRTUAL_P (decl))\n-\t  error (\"definition of static data member %q+D of \"\n-\t         \"dllimport'd class\", decl);\n-      return false;\n-    }\n-\n+  \n+  /* Overrides of the class dllimport decls by out-of-class definitions are \n+     handled by tree.c:merge_dllimport_decl_attributes.   */\n   return true;\n }\n \n-\n bool\n i386_pe_type_dllexport_p (tree decl)\n {\n-   gcc_assert (TREE_CODE (decl) == VAR_DECL \n-               || TREE_CODE (decl) == FUNCTION_DECL);\n-   /* Avoid exporting compiler-generated default dtors and copy ctors.\n-      The only artificial methods that need to be exported are virtual\n-      and non-virtual thunks.  */\n-   if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE\n-       && DECL_ARTIFICIAL (decl) && !DECL_THUNK_P (decl))\n-     return false;\n-   return true;\n+  gcc_assert (TREE_CODE (decl) == VAR_DECL \n+              || TREE_CODE (decl) == FUNCTION_DECL);\n+\n+  /* Avoid exporting compiler-generated default dtors and copy ctors.\n+     The only artificial methods that need to be exported are virtual\n+     and non-virtual thunks.  */\n+  if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE\n+      && DECL_ARTIFICIAL (decl) && !DECL_THUNK_P (decl))\n+    return false;\n+  return true;\n }\n \n static inline void maybe_add_dllimport (tree decl) \n {\n   if (i386_pe_type_dllimport_p (decl))\n-    DECL_DLLIMPORT_P (decl) = 1;   \n+    DECL_DLLIMPORT_P (decl) = 1;\n+}\n+\n+static inline void maybe_add_dllexport (tree decl) \n+{\n+  if (i386_pe_type_dllexport_p (decl))\n+    {   \n+      tree decl_attrs = DECL_ATTRIBUTES (decl);\n+      if (lookup_attribute (\"dllexport\", decl_attrs) != NULL_TREE)\n+\t/* Already done.  */\n+\treturn;\n+      DECL_ATTRIBUTES (decl) = tree_cons (get_identifier (\"dllexport\"),\n+\t\t\t\t\t  NULL_TREE, decl_attrs);\n+    }\n }\n \n void\n@@ -103,41 +97,69 @@ i386_pe_adjust_class_at_definition (tree t)\n   tree member;\n \n   gcc_assert (CLASS_TYPE_P (t));\n+ \n+ \n+  if (lookup_attribute (\"dllexport\", TYPE_ATTRIBUTES (t)) != NULL_TREE)\n+    {\n+      /* Check static VAR_DECL's.  */\n+      for (member = TYPE_FIELDS (t); member; member = TREE_CHAIN (member))\n+\tif (TREE_CODE (member) == VAR_DECL)     \n+\t  maybe_add_dllexport (member);\n+    \n+      /* Check FUNCTION_DECL's.  */\n+      for (member = TYPE_METHODS (t); member;  member = TREE_CHAIN (member))\n+\tif (TREE_CODE (member) == FUNCTION_DECL)\n+\t  {\n+\t    tree thunk;\n+\t    maybe_add_dllexport (member);\n+\t  \n+\t    /* Also add the attribute to its thunks.  */\n+\t    for (thunk = DECL_THUNKS (member); thunk;\n+\t\t thunk = TREE_CHAIN (thunk))\n+\t      maybe_add_dllexport (thunk);\n+\t}\n+      /* Check vtables  */\n+      for (member = CLASSTYPE_VTABLES (t); member;  member = TREE_CHAIN (member))\n+\tif (TREE_CODE (member) == VAR_DECL) \n+\t  maybe_add_dllexport (member);\n+    }\n \n- /* We only look at dllimport.  The only thing that dllexport does is\n-    add stuff to a '.drectiv' section at end-of-file, so no need to do\n-    anything for dllexport'd classes until we generate RTL. */  \n-  if (lookup_attribute (\"dllimport\", TYPE_ATTRIBUTES (t)) == NULL_TREE)\n-    return;\n-\n-  /* We don't actually add the attribute to the decl, just set the flag\n-     that signals that the address of this symbol is not a compile-time\n-     constant.   Any subsequent out-of-class declaration of members wil\n-     cause the DECL_DLLIMPORT_P flag to be unset.\n-     (See  tree.c: merge_dllimport_decl_attributes).\n-     That is just right since out-of class declarations can only be a\n-     definition.  We recheck the class members  at RTL generation to\n-     emit warnings if this has happened.  Definition of static data member\n-     of dllimport'd class always causes an error (as per MS compiler).\n-  */\n-\n-  /* Check static VAR_DECL's.  */\n-  for (member = TYPE_FIELDS (t); member; member = TREE_CHAIN (member))\n-    if (TREE_CODE (member) == VAR_DECL)     \n-      maybe_add_dllimport (member);\n+  else if (lookup_attribute (\"dllimport\", TYPE_ATTRIBUTES (t)) != NULL_TREE)\n+    {\n+      /* We don't actually add the attribute to the decl, just set the flag\n+\t that signals that the address of this symbol is not a compile-time\n+\t constant.   Any subsequent out-of-class declaration of members wil\n+\t cause the DECL_DLLIMPORT_P flag to be unset.\n+\t (See  tree.c: merge_dllimport_decl_attributes).\n+\t That is just right since out-of class declarations can only be a\n+\t definition.   */\n+\n+      /* Check static VAR_DECL's.  */\n+      for (member = TYPE_FIELDS (t); member; member = TREE_CHAIN (member))\n+\tif (TREE_CODE (member) == VAR_DECL)     \n+\t  maybe_add_dllimport (member);\n     \n-  /* Check FUNCTION_DECL's.  */\n-  for (member = TYPE_METHODS (t); member;  member = TREE_CHAIN (member))\n-    if (TREE_CODE (member) == FUNCTION_DECL)\n-      maybe_add_dllimport (member);\n+      /* Check FUNCTION_DECL's.  */\n+      for (member = TYPE_METHODS (t); member;  member = TREE_CHAIN (member))\n+\tif (TREE_CODE (member) == FUNCTION_DECL)\n+\t  {\n+\t    tree thunk;\n+\t    maybe_add_dllimport (member);\n+\t  \n+\t    /* Also add the attribute to its thunks.  */\n+\t    for (thunk = DECL_THUNKS (member); thunk;\n+\t\t thunk = TREE_CHAIN (thunk))\n+\t      maybe_add_dllimport (thunk);\n+\t }\n  \n-  /* Check vtables  */\n-  for (member = CLASSTYPE_VTABLES (t); member;  member = TREE_CHAIN (member))\n-    if (TREE_CODE (member) == VAR_DECL) \n-      maybe_add_dllimport (member);\n-\n-/* We leave typeinfo tables alone.  We can't mark TI objects as\n-     dllimport, since the address of a secondary VTT may be needed\n-     for static initialization of a primary VTT.  VTT's  of\n-     dllimport'd classes should always be link-once COMDAT.  */ \n+      /* Check vtables  */\n+      for (member = CLASSTYPE_VTABLES (t); member;  member = TREE_CHAIN (member))\n+\tif (TREE_CODE (member) == VAR_DECL) \n+\t  maybe_add_dllimport (member);\n+\n+      /* We leave typeinfo tables alone.  We can't mark TI objects as\n+\tdllimport, since the address of a secondary VTT may be needed\n+\tfor static initialization of a primary VTT.  VTT's  of\n+\tdllimport'd classes should always be link-once COMDAT.  */ \n+    }\n }"}, {"sha": "f8dcaa9673af4c87738fb704a86508890f75c7fb", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09a6b8a46ac2ea80ce98ae045ad6352da928b2b3/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09a6b8a46ac2ea80ce98ae045ad6352da928b2b3/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=09a6b8a46ac2ea80ce98ae045ad6352da928b2b3", "patch": "@@ -102,8 +102,6 @@ associated_type (tree decl)\n static bool\n i386_pe_determine_dllexport_p (tree decl)\n {\n-  tree assoc;\n-\n   if (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != FUNCTION_DECL)\n     return false;\n \n@@ -114,11 +112,6 @@ i386_pe_determine_dllexport_p (tree decl)\n   if (lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (decl)))\n     return true;\n \n-  /* Also mark class members of exported classes with dllexport.  */\n-  assoc = associated_type (decl);\n-  if (assoc && lookup_attribute (\"dllexport\", TYPE_ATTRIBUTES (assoc)))\n-    return i386_pe_type_dllexport_p (decl);\n-\n   return false;\n }\n \n@@ -132,18 +125,23 @@ i386_pe_determine_dllimport_p (tree decl)\n   if (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != FUNCTION_DECL)\n     return false;\n \n-  /* Lookup the attribute in addition to checking the DECL_DLLIMPORT_P flag.\n-     We may need to override an earlier decision.  */\n   if (DECL_DLLIMPORT_P (decl))\n     return true;\n \n   /* The DECL_DLLIMPORT_P flag was set for decls in the class definition\n      by  targetm.cxx.adjust_class_at_definition.  Check again to emit\n-     warnings if the class attribute has been overridden by an\n-     out-of-class definition.  */\n+     error message if the class attribute has been overridden by an\n+     out-of-class definition of static data.  */\n   assoc = associated_type (decl);\n-  if (assoc && lookup_attribute (\"dllimport\", TYPE_ATTRIBUTES (assoc)))\n-    return i386_pe_type_dllimport_p (decl);\n+  if (assoc && lookup_attribute (\"dllimport\", TYPE_ATTRIBUTES (assoc))\n+      && TREE_CODE (decl) == VAR_DECL\n+      && TREE_STATIC (decl) && TREE_PUBLIC (decl)\n+      && !DECL_EXTERNAL (decl)\n+      /* vtable's are linkonce constants, so defining a vtable is not\n+\t an error as long as we don't try to import it too.  */\n+      && !DECL_VIRTUAL_P (decl))\n+\terror (\"definition of static data member %q+D of \"\n+\t       \"dllimport'd class\", decl);\n \n   return false;\n }\n@@ -308,17 +306,8 @@ i386_pe_encode_section_info (tree decl, rtx rtl, int first)\n   if (i386_pe_determine_dllexport_p (decl))\n     flags |= SYMBOL_FLAG_DLLEXPORT;\n   else if (i386_pe_determine_dllimport_p (decl))\n-    {\n-      flags |= SYMBOL_FLAG_DLLIMPORT;\n-      /* If we went through the associated_type path, this won't already\n-\t be set.  Though, frankly, this seems wrong, and should be fixed\n-\t elsewhere.  */\n-      if (!DECL_DLLIMPORT_P (decl))\n-\t{\n-\t  DECL_DLLIMPORT_P (decl) = 1;\n-\t  flags &= ~SYMBOL_FLAG_LOCAL;\n-\t}\n-    }\n+    flags |= SYMBOL_FLAG_DLLIMPORT;\n+ \n   SYMBOL_REF_FLAGS (symbol) = flags;\n }\n "}]}