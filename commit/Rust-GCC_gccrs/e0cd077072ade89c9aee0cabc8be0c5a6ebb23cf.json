{"sha": "e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBjZDA3NzA3MmFkZTg5YzlhZWUwY2FiYzhiZTBjNWE2ZWJiMjNjZg==", "commit": {"author": {"name": "John Carr", "email": "jfc@mit.edu", "date": "1998-06-17T16:14:09Z"}, "committer": {"name": "John Carr", "email": "jfc@gcc.gnu.org", "date": "1998-06-17T16:14:09Z"}, "message": "haifa-sched.c (haifa_classify_insn): TRAP_IF is risky.\n\n\t* haifa-sched.c (haifa_classify_insn): TRAP_IF is risky.\n\t(sched_analyze_2): Allow scheduling TRAP_IF.\n\t* reorg.c (mark_referenced_resources): Examine operands of TRAP_IF.\n\t* rtl.h (TRAP_CODE): New macro.\n\t* rtl.def (TRAP_IF): Change second operand type to rtx.\n\t* optabs.c (gen_cond_trap): New function.\n\t(init_traps): New function.\n\t(init_optabs): Call init_traps.\n\t* expr.h: Declare gen_cond_trap.\n\t* jump.c (jump_optimize): Optimize jumps to and around traps.\n\t* sparc.md: Define trap instructions.\n\t* rs6000.md: Define trap instructions.\n\t* rs6000.c (print_operand): New code 'V' for trap condition.\n\t(trap_comparison_operator): New function.\n\t* m88k.md: Update use of TRAP_IF.\n\t* tree.h (enum built_in_function): New function code BUILT_IN_TRAP.\n\t* c-decl.c (init_decl_processing): New builtin __builtin_trap.\n\t* expr.c (expand_builtin): Handle BUILT_IN_TRAP.\n\t* expr.c (expand_builtin): Error if __builtin_longjmp second argument\n\tis not 1.\n\nFrom-SVN: r20543", "tree": {"sha": "bc08309af18e3e3b81d9dde6d23a1abd41673ffe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc08309af18e3e3b81d9dde6d23a1abd41673ffe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/comments", "author": {"login": "VoxSciurorum", "id": 60116679, "node_id": "MDQ6VXNlcjYwMTE2Njc5", "avatar_url": "https://avatars.githubusercontent.com/u/60116679?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VoxSciurorum", "html_url": "https://github.com/VoxSciurorum", "followers_url": "https://api.github.com/users/VoxSciurorum/followers", "following_url": "https://api.github.com/users/VoxSciurorum/following{/other_user}", "gists_url": "https://api.github.com/users/VoxSciurorum/gists{/gist_id}", "starred_url": "https://api.github.com/users/VoxSciurorum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VoxSciurorum/subscriptions", "organizations_url": "https://api.github.com/users/VoxSciurorum/orgs", "repos_url": "https://api.github.com/users/VoxSciurorum/repos", "events_url": "https://api.github.com/users/VoxSciurorum/events{/privacy}", "received_events_url": "https://api.github.com/users/VoxSciurorum/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4fdf79cb6764f8c57b4c4deaabd6131850535263", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fdf79cb6764f8c57b4c4deaabd6131850535263", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fdf79cb6764f8c57b4c4deaabd6131850535263"}], "stats": {"total": 315, "additions": 308, "deletions": 7}, "files": [{"sha": "6f58a02765a6ff7364f54f5daeb3b3e215ba07dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "patch": "@@ -1,3 +1,36 @@\n+Wed Jun 17 19:05:03 1998  John Carr  <jfc@mit.edu>\n+\n+\t* haifa-sched.c (haifa_classify_insn): TRAP_IF is risky.\n+\t(sched_analyze_2): Allow scheduling TRAP_IF.\n+\n+\t* reorg.c (mark_referenced_resources): Examine operands of TRAP_IF.\n+\n+\t* rtl.h (TRAP_CODE): New macro.\n+\n+\t* rtl.def (TRAP_IF): Change second operand type to rtx.\n+\n+\t* optabs.c (gen_cond_trap): New function.\n+\t(init_traps): New function.\n+\t(init_optabs): Call init_traps.\n+\t* expr.h: Declare gen_cond_trap.\n+\n+\t* jump.c (jump_optimize): Optimize jumps to and around traps.\n+\n+\t* sparc.md: Define trap instructions.\n+\n+\t* rs6000.md: Define trap instructions.\n+\t* rs6000.c (print_operand): New code 'V' for trap condition.\n+\t(trap_comparison_operator): New function.\n+\n+\t* m88k.md: Update use of TRAP_IF.\n+\n+\t* tree.h (enum built_in_function): New function code BUILT_IN_TRAP.\n+\t* c-decl.c (init_decl_processing): New builtin __builtin_trap.\n+\t* expr.c (expand_builtin): Handle BUILT_IN_TRAP.\n+\n+\t* expr.c (expand_builtin): Error if __builtin_longjmp second argument\n+\tis not 1.\n+\n Wed Jun 17 15:20:00 PDT 1998  Catherine Moore  <clm@cygnus.com>\n \n          * reload1.c (spill_hard_reg):  Check mode of register when"}, {"sha": "62768e3ef68be20423bcf9629cd56f2ab892e373", "filename": "gcc/c-decl.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "patch": "@@ -3425,6 +3425,9 @@ init_decl_processing ()\n \t\t\t\t\t   integer_type_node,\n \t\t\t\t\t   endlink))),\n \t\t    BUILT_IN_LONGJMP, NULL_PTR);\n+  builtin_function (\"__builtin_trap\",\n+\t\t    build_function_type (void_type_node, endlink),\n+\t\t    BUILT_IN_TRAP, NULL_PTR);\n \n   /* In an ANSI C program, it is okay to supply built-in meanings\n      for these functions, since applications cannot validly use them"}, {"sha": "c94e6fd82ae867b6d5c33b14c40cc95ac75698cd", "filename": "gcc/config/m88k/m88k.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Fconfig%2Fm88k%2Fm88k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Fconfig%2Fm88k%2Fm88k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.md?ref=e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "patch": "@@ -2810,7 +2810,7 @@\n \n ;; Division by 0 trap\n (define_insn \"trap_divide_by_zero\"\n-  [(trap_if (const_int 1) 503)]\n+  [(trap_if (const_int 1) (const_int 503))]\n   \"\"\n   \"tb0 0,%#r0,503\"\n   [(set_attr \"type\" \"weird\")])\n@@ -2822,7 +2822,7 @@\n \t\t\t  (const_int 0))\n \t\t      (pc)\n \t\t      (match_operand 1 \"\" \"\")))\n-   (trap_if (const_int 1) 503)]\n+   (trap_if (const_int 1) (const_int 503))]\n   \"\"\n   \"\n {\n@@ -3451,14 +3451,14 @@\n (define_insn \"tbnd\"\n   [(trap_if (gtu (match_operand:SI 0 \"register_operand\" \"r\")\n \t\t (match_operand:SI 1 \"arith_operand\" \"rI\"))\n-\t    7)]\n+\t    (const_int 7))]\n   \"\"\n   \"tbnd %r0,%1\"\n   [(set_attr \"type\" \"weird\")])\n \n ;; Just in case the optimizer decides to fold away the test.\n (define_insn \"\"\n-  [(trap_if (const_int 1) 7)]\n+  [(trap_if (const_int 1) (const_int 7))]\n   \"\"\n   \"tbnd %#r31,0\"\n   [(set_attr \"type\" \"weird\")])"}, {"sha": "464a5551b0bcfb25ed82bf40deae9732a5293a5f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "patch": "@@ -2046,6 +2046,17 @@ scc_comparison_operator (op, mode)\n \n   return 1;\n }\n+\n+int\n+trap_comparison_operator (op, mode)\n+    rtx op;\n+    enum machine_mode mode;\n+{\n+  if (mode != VOIDmode && mode != GET_MODE (op))\n+    return 0;\n+  return (GET_RTX_CLASS (GET_CODE (op)) == '<'\n+          || GET_CODE (op) == EQ || GET_CODE (op) == NE);\n+}\n \f\n /* Return 1 if ANDOP is a mask that has no bits on that are not in the\n    mask required to convert the result of a rotate insn into a shift\n@@ -2924,6 +2935,45 @@ print_operand (file, x, code)\n \tputc ('u', file);\n       return;\n \n+    case 'V':\n+      /* Print the trap code for this operand.  */\n+      switch (GET_CODE (x))\n+\t{\n+\tcase EQ:\n+\t  fputs (\"eq\", file);   /* 4 */\n+\t  break;\n+\tcase NE:\n+\t  fputs (\"ne\", file);   /* 24 */\n+\t  break;\n+\tcase LT:\n+\t  fputs (\"lt\", file);   /* 16 */\n+\t  break;\n+\tcase LE:\n+\t  fputs (\"le\", file);   /* 20 */\n+\t  break;\n+\tcase GT:\n+\t  fputs (\"gt\", file);   /* 8 */\n+\t  break;\n+\tcase GE:\n+\t  fputs (\"ge\", file);   /* 12 */\n+\t  break;\n+\tcase LTU:\n+\t  fputs (\"llt\", file);  /* 2 */\n+\t  break;\n+\tcase LEU:\n+\t  fputs (\"lle\", file);  /* 6 */\n+\t  break;\n+\tcase GTU:\n+\t  fputs (\"lgt\", file);  /* 1 */\n+\t  break;\n+\tcase GEU:\n+\t  fputs (\"lge\", file);  /* 5 */\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+\n     case 'w':\n       /* If constant, low-order 16 bits of constant, signed.  Otherwise, write\n \t normally.  */"}, {"sha": "05ee92f9efac17555785d0fd5ea8c7c8c4d4ead3", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "patch": "@@ -9991,3 +9991,25 @@\n   \"\n { operands[7] = gen_rtx (GET_CODE (operands[2]), VOIDmode, operands[3],\n \t\t\t const0_rtx); }\")\n+\f\n+(define_insn \"trap\"\n+  [(trap_if (const_int 1) (const_int 0))]\n+  \"\"\n+  \"{t 31,0,0|trap}\")\n+\n+(define_expand \"conditional_trap\"\n+  [(trap_if (match_operator 0 \"trap_comparison_operator\"\n+\t\t\t    [(match_dup 2) (match_dup 3)])\n+\t    (match_operand 1 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"if (rs6000_compare_fp_p || operands[1] != const0_rtx) FAIL;\n+   operands[2] = rs6000_compare_op0;\n+   operands[3] = rs6000_compare_op1;\")\n+\n+(define_insn \"\"\n+  [(trap_if (match_operator 0 \"trap_comparison_operator\"\n+                            [(match_operand:SI 1 \"register_operand\" \"r\")\n+                             (match_operand:SI 2 \"reg_or_short_operand\" \"rI\")])\n+\t    (const_int 0))]\n+  \"\"\n+  \"t%V0%I2 %1,%2\")"}, {"sha": "f4018492d963f8a8fd955d3486c11dc9c6f00ade", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "patch": "@@ -6674,3 +6674,33 @@ if (! TARGET_ARCH64)\n   [(unspec_volatile [(const_int 0)] 4)]\n   \"flag_pic\"\n   \"\")\n+\f\n+(define_insn \"trap\"\n+  [(trap_if (const_int 1) (const_int 5))]\n+  \"\"\n+  \"ta 5\"\n+  [(set_attr \"type\" \"misc\")])\n+\n+(define_expand \"conditional_trap\"\n+  [(trap_if (match_operator 0 \"noov_compare_op\"\n+\t\t\t    [(match_dup 2) (match_dup 3)])\n+\t    (match_operand:SI 1 \"arith_operand\" \"\"))]\n+  \"\"\n+  \"operands[2] = gen_compare_reg (GET_CODE (operands[0]),\n+\t\t\t\t  sparc_compare_op0, sparc_compare_op1);\n+   operands[3] = const0_rtx;\")\n+\n+(define_insn \"\"\n+  [(trap_if (match_operator 0 \"noov_compare_op\" [(reg:CC 100) (const_int 0)])\n+\t    (match_operand:SI 1 \"arith_operand\" \"rM\"))]\n+  \"\"\n+  \"t%C0 %1\"\n+  [(set_attr \"type\" \"misc\")])\n+\n+(define_insn \"\"\n+  [(trap_if (match_operator 0 \"noov_compare_op\" [(reg:CCX 100) (const_int 0)])\n+\t    (match_operand:SI 1 \"arith_operand\" \"rM\"))]\n+  \"TARGET_V9\"\n+  \"t%C0 %%xcc,%1\"\n+  [(set_attr \"type\" \"misc\")])\n+"}, {"sha": "aff3dd104c70397cccb0833bbc6af7dbe4f00efd", "filename": "gcc/expr.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "patch": "@@ -8973,10 +8973,27 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t\t\t\t      VOIDmode, 0);\n \t  rtx value = expand_expr (TREE_VALUE (TREE_CHAIN (arglist)),\n \t\t\t\t   NULL_RTX, VOIDmode, 0);\n+\n+\t  if (value != const1_rtx)\n+\t    {\n+\t      error (\"__builtin_longjmp second argument must be 1\");\n+\t      return const0_rtx;\n+\t    }\n+\n \t  expand_builtin_longjmp (buf_addr, value);\n \t  return const0_rtx;\n \t}\n \n+    case BUILT_IN_TRAP:\n+#ifdef HAVE_trap\n+      if (HAVE_trap)\n+\temit_insn (gen_trap ());\n+      else\n+#endif\n+\terror (\"__builtin_trap not supported by this target\");\n+      emit_barrier ();\n+      return const0_rtx;\n+\n       /* Various hooks for the DWARF 2 __throw routine.  */\n     case BUILT_IN_UNWIND_INIT:\n       expand_builtin_unwind_init ();"}, {"sha": "f75828f212aab7a28a6f29e3e525eada693ffcf0", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "patch": "@@ -671,6 +671,9 @@ extern rtx emit_store_flag_force PROTO((rtx, enum rtx_code, rtx, rtx,\n \n /* Given a JUMP_INSN, return a description of the test being made.  */\n extern rtx get_condition PROTO((rtx, rtx *));\n+\n+/* Generate a conditional trap instruction.  */\n+extern rtx gen_cond_trap PROTO((enum rtx_code, rtx, rtx, rtx));\n \f\n /* Functions from expr.c:  */\n "}, {"sha": "2416a83fc1dcc6d32c3971c1becac299eeeb9483", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "patch": "@@ -2629,6 +2629,10 @@ haifa_classify_insn (insn)\n \t      tmp_class =\n \t\tWORST_CLASS (tmp_class,\n \t\t\t   may_trap_exp (SET_SRC (XVECEXP (pat, 0, i)), 0));\n+\t      break;\n+\t    case TRAP_IF:\n+\t      tmp_class = TRAP_RISKY;\n+\t      break;\n \t    default:;\n \t    }\n \t  insn_class = WORST_CLASS (insn_class, tmp_class);\n@@ -2654,6 +2658,10 @@ haifa_classify_insn (insn)\n \t  tmp_class =\n \t    WORST_CLASS (tmp_class,\n \t\t\t may_trap_exp (SET_SRC (pat), 0));\n+\t  break;\n+\tcase TRAP_IF:\n+\t  tmp_class = TRAP_RISKY;\n+\t  break;\n \tdefault:;\n \t}\n       insn_class = tmp_class;\n@@ -3560,10 +3568,14 @@ sched_analyze_2 (x, insn)\n \treturn;\n       }\n \n+    /* Force pending stores to memory in case a trap handler needs them.  */\n+    case TRAP_IF:\n+      flush_pending_lists (insn, 1);\n+      break;\n+\n     case ASM_OPERANDS:\n     case ASM_INPUT:\n     case UNSPEC_VOLATILE:\n-    case TRAP_IF:\n       {\n \trtx u;\n "}, {"sha": "9feb99efa289dc14b961f894b3784ea0960d6a61", "filename": "gcc/jump.c", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "patch": "@@ -1892,6 +1892,80 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t  continue;\n \t\t}\n \t    }\n+#ifdef HAVE_trap\n+\t  /* Detect a conditional jump jumping over an unconditional trap.  */\n+\t  else if (HAVE_trap\n+\t\t   && this_is_condjump && ! this_is_simplejump\n+\t\t   && reallabelprev != 0\n+\t\t   && GET_CODE (reallabelprev) == INSN\n+\t\t   && GET_CODE (PATTERN (reallabelprev)) == TRAP_IF\n+\t\t   && TRAP_CONDITION (PATTERN (reallabelprev)) == const_true_rtx\n+\t\t   && prev_active_insn (reallabelprev) == insn\n+\t\t   && no_labels_between_p (insn, reallabelprev)\n+\t\t   && (temp2 = get_condition (insn, &temp4))\n+\t\t   && can_reverse_comparison_p (temp2, insn))\n+\t    {\n+\t      rtx new = gen_cond_trap (reverse_condition (GET_CODE (temp2)),\n+\t\t\t\t       XEXP (temp2, 0), XEXP (temp2, 1),\n+\t\t\t\t       TRAP_CODE (PATTERN (reallabelprev)));\n+\n+\t      if (new)\n+\t\t{\n+\t\t  emit_insn_before (new, temp4);\n+\t\t  delete_insn (reallabelprev);\n+\t\t  delete_jump (insn);\n+\t\t  changed = 1;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  /* Detect a jump jumping to an unconditional trap.  */\n+\t  else if (HAVE_trap && this_is_condjump\n+\t\t   && (temp = next_active_insn (JUMP_LABEL (insn)))\n+\t\t   && GET_CODE (temp) == INSN\n+\t\t   && GET_CODE (PATTERN (temp)) == TRAP_IF\n+\t\t   && (this_is_simplejump\n+\t\t       || (temp2 = get_condition (insn, &temp4))))\n+\t    {\n+\t      rtx tc = TRAP_CONDITION (PATTERN (temp));\n+\n+\t      if (tc == const_true_rtx\n+\t\t  || (! this_is_simplejump && rtx_equal_p (temp2, tc)))\n+\t\t{\n+\t\t  rtx new;\n+\t\t  /* Replace an unconditional jump to a trap with a trap.  */\n+\t\t  if (this_is_simplejump)\n+\t\t    {\n+\t\t      emit_barrier_after (emit_insn_before (gen_trap (), insn));\n+\t\t      delete_jump (insn);\n+\t\t      changed = 1;\n+\t\t      continue;\n+\t\t    }\n+\t\t  new = gen_cond_trap (GET_CODE (temp2), XEXP (temp2, 0),\n+\t\t\t\t       XEXP (temp2, 1),\n+\t\t\t\t       TRAP_CODE (PATTERN (temp)));\n+\t\t  if (new)\n+\t\t    {\n+\t\t      emit_insn_before (new, temp4);\n+\t\t      delete_jump (insn);\n+\t\t      changed = 1;\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t      /* If the trap condition and jump condition are mutually\n+\t\t exclusive, redirect the jump to the following insn.  */\n+\t      else if (GET_RTX_CLASS (GET_CODE (tc)) == '<'\n+\t\t       && ! this_is_simplejump\n+\t\t       && swap_condition (GET_CODE (temp2)) == GET_CODE (tc)\n+\t\t       && rtx_equal_p (XEXP (tc, 0), XEXP (temp2, 0))\n+\t\t       && rtx_equal_p (XEXP (tc, 1), XEXP (temp2, 1))\n+\t\t       && redirect_jump (insn, get_label_after (temp)))\n+\t\t{\n+\t\t  changed = 1;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+#endif\n+\n \t  /* Detect a conditional jump jumping over an unconditional jump.  */\n \n \t  else if ((this_is_condjump || this_is_condjump_in_parallel)"}, {"sha": "8a2697b4fe951cde8f4aa3e6c89e951f0ae0b35c", "filename": "gcc/optabs.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "patch": "@@ -246,6 +246,7 @@ static optab init_optab\tPROTO((enum rtx_code));\n static void init_libfuncs PROTO((optab, int, int, char *, int));\n static void init_integral_libfuncs PROTO((optab, char *, int));\n static void init_floating_libfuncs PROTO((optab, char *, int));\n+static void init_traps PROTO((void));\n \f\n /* Add a REG_EQUAL note to the last insn in SEQ.  TARGET is being set to\n    the result of operation CODE applied to OP0 (and OP1 if it is a binary\n@@ -4380,6 +4381,10 @@ init_optabs ()\n   chkr_check_exec_libfunc = gen_rtx (SYMBOL_REF, VOIDmode, \"chkr_check_exec\");\n   chkr_check_str_libfunc = gen_rtx (SYMBOL_REF, VOIDmode, \"chkr_check_str\");\n \n+#ifdef HAVE_conditional_trap\n+  init_traps ();\n+#endif\n+\n #ifdef INIT_TARGET_OPTABS\n   /* Allow the target to add more libcalls or rename some, etc.  */\n   INIT_TARGET_OPTABS;\n@@ -4402,3 +4407,50 @@ ldexp(x,n)\n   return x;\n }\n #endif /* BROKEN_LDEXP */\n+\f\n+#ifdef HAVE_conditional_trap\n+/* The insn generating function can not take an rtx_code argument.\n+   TRAP_RTX is used as an rtx argument.  Its code is replaced with\n+   the code to be used in the trap insn and all other fields are\n+   ignored.\n+\n+   ??? Will need to change to support garbage collection.  */\n+static rtx trap_rtx;\n+\n+static void\n+init_traps ()\n+{\n+  if (HAVE_conditional_trap)\n+    trap_rtx = gen_rtx_fmt_ee (EQ, VOIDmode, NULL_RTX, NULL_RTX);\n+}\n+#endif\n+\n+/* Generate insns to trap with code TCODE if OP1 and OP2 satisfy condition\n+   CODE.  Return 0 on failure.  */\n+\n+rtx\n+gen_cond_trap (code, op1, op2, tcode)\n+     enum rtx_code code;\n+     rtx op1, op2, tcode;\n+{\n+  enum machine_mode mode = GET_MODE (op1);\n+  enum insn_code icode;\n+\n+  if (mode == VOIDmode)\n+    return 0;\n+\n+#ifdef HAVE_conditional_trap\n+  if (HAVE_conditional_trap\n+      && cmp_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+    {\n+      rtx insn;\n+      emit_insn (GEN_FCN (cmp_optab->handlers[(int) mode].insn_code) (op1, op2));\n+      PUT_CODE (trap_rtx, code);\n+      insn = gen_conditional_trap (trap_rtx, tcode);\n+      if (insn)\n+\treturn insn;\n+    }\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "7370a356dc4e80ce80183ea567a93d6be0242bf9", "filename": "gcc/reorg.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "patch": "@@ -340,11 +340,14 @@ mark_referenced_resources (x, res, include_delayed_effects)\n \n     case UNSPEC_VOLATILE:\n     case ASM_INPUT:\n-    case TRAP_IF:\n       /* Traditional asm's are always volatile.  */\n       res->volatil = 1;\n       return;\n \n+    case TRAP_IF:\n+      res->volatil = 1;\n+      break;\n+\n     case ASM_OPERANDS:\n       res->volatil = MEM_VOLATILE_P (x);\n "}, {"sha": "e219e87c0422a21384aafe671b21f36f9a78a348", "filename": "gcc/rtl.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "patch": "@@ -506,7 +506,7 @@ DEF_RTL_EXPR(RETURN, \"return\", \"\", 'x')\n    Operand 1 is the condition.\n    Operand 2 is the trap code.\n    For an unconditional trap, make the condition (const_int 1).  */\n-DEF_RTL_EXPR(TRAP_IF, \"trap_if\", \"ei\", 'x')\n+DEF_RTL_EXPR(TRAP_IF, \"trap_if\", \"ee\", 'x')\n \n /* ----------------------------------------------------------------------\n    Primitive values for use in expressions."}, {"sha": "a9946cacc8247749f0446ac481bd96b7c987187b", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "patch": "@@ -596,6 +596,7 @@ extern char *note_insn_name[];\n \n /* For a TRAP_IF rtx, TRAP_CONDITION is an expression.  */\n #define TRAP_CONDITION(RTX) ((RTX)->fld[0].rtx)\n+#define TRAP_CODE(RTX) (RTX)->fld[1].rtx\n \n /* 1 in a SYMBOL_REF if it addresses this function's constants pool.  */\n #define CONSTANT_POOL_ADDRESS_P(RTX) ((RTX)->unchanging)"}, {"sha": "62b316874907eca05c446ea5fe8d9f13027c8fdc", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e0cd077072ade89c9aee0cabc8be0c5a6ebb23cf", "patch": "@@ -107,6 +107,7 @@ enum built_in_function\n   BUILT_IN_RETURN,\n   BUILT_IN_SETJMP,\n   BUILT_IN_LONGJMP,\n+  BUILT_IN_TRAP,\n \n   /* Various hooks for the DWARF 2 __throw routine.  */\n   BUILT_IN_FP, BUILT_IN_SP,"}]}