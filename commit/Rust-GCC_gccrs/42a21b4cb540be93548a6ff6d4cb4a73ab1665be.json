{"sha": "42a21b4cb540be93548a6ff6d4cb4a73ab1665be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJhMjFiNGNiNTQwYmU5MzU0OGE2ZmY2ZDRjYjRhNzNhYjE2NjViZQ==", "commit": {"author": {"name": "David Edelsohn", "email": "dje.gcc@gmail.com", "date": "2021-03-14T19:09:21Z"}, "committer": {"name": "David Edelsohn", "email": "dje.gcc@gmail.com", "date": "2021-03-26T23:56:12Z"}, "message": "aix: ABI struct alignment (PR99557)\n\nThe AIX power alignment rules apply the natural alignment of the\n\"first member\" if it is of a floating-point data type (or is an aggregate\nwhose recursively \"first\" member or element is such a type). The alignment\nassociated with these types for subsequent members use an alignment value\nwhere the floating-point data type is considered to have 4-byte alignment.\n\nGCC had been stripping array type but had not recursively looked\nwithin structs and unions.  This also applies to classes and\nsubclasses and, therefore, becomes more prominent with C++.\n\nFor example,\n\nstruct A {\n  double x[2];\n  int y;\n};\nstruct B {\n  int i;\n  struct A a;\n};\n\nstruct A has double-word alignment for the bare type, but\nword alignment and offset within struct B despite the alignment of\nstruct A.  If struct A were the first member of struct B, struct B\nwould have double-word alignment.  One must search for the innermost\nfirst member to increase the alignment if double and then search for\nthe innermost first member to reduce the alignment if the TYPE had\ndouble-word alignment solely because the innermost first member was\ndouble.\n\nThis patch recursively looks through the first member to apply the\ndouble-word alignment to the struct / union as a whole and to apply\nthe word alignment to the struct or union as a member within a struct\nor union.\n\nThis is an ABI change for GCC on AIX, but GCC on AIX had not correctly\nimplemented the AIX ABI and had not been compatible with the IBM XL\ncompiler.\n\nBootstrapped on powerpc-ibm-aix7.2.3.0.\n\ngcc/ChangeLog:\n\n\t* config/rs6000/aix.h (ADJUST_FIELD_ALIGN): Call function.\n\t* config/rs6000/rs6000-protos.h (rs6000_special_adjust_field_align):\n\tDeclare.\n\t* config/rs6000/rs6000.c (rs6000_special_adjust_field_align): New.\n\t(rs6000_special_round_type_align): Recursively check innermost first\n\tfield.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/powerpc/pr99557.c: New.", "tree": {"sha": "c2bc50b613ad33db76a0db5a0dd76f4897212640", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2bc50b613ad33db76a0db5a0dd76f4897212640"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42a21b4cb540be93548a6ff6d4cb4a73ab1665be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42a21b4cb540be93548a6ff6d4cb4a73ab1665be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42a21b4cb540be93548a6ff6d4cb4a73ab1665be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42a21b4cb540be93548a6ff6d4cb4a73ab1665be/comments", "author": {"login": "edelsohn", "id": 667700, "node_id": "MDQ6VXNlcjY2NzcwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/667700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edelsohn", "html_url": "https://github.com/edelsohn", "followers_url": "https://api.github.com/users/edelsohn/followers", "following_url": "https://api.github.com/users/edelsohn/following{/other_user}", "gists_url": "https://api.github.com/users/edelsohn/gists{/gist_id}", "starred_url": "https://api.github.com/users/edelsohn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edelsohn/subscriptions", "organizations_url": "https://api.github.com/users/edelsohn/orgs", "repos_url": "https://api.github.com/users/edelsohn/repos", "events_url": "https://api.github.com/users/edelsohn/events{/privacy}", "received_events_url": "https://api.github.com/users/edelsohn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edelsohn", "id": 667700, "node_id": "MDQ6VXNlcjY2NzcwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/667700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edelsohn", "html_url": "https://github.com/edelsohn", "followers_url": "https://api.github.com/users/edelsohn/followers", "following_url": "https://api.github.com/users/edelsohn/following{/other_user}", "gists_url": "https://api.github.com/users/edelsohn/gists{/gist_id}", "starred_url": "https://api.github.com/users/edelsohn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edelsohn/subscriptions", "organizations_url": "https://api.github.com/users/edelsohn/orgs", "repos_url": "https://api.github.com/users/edelsohn/repos", "events_url": "https://api.github.com/users/edelsohn/events{/privacy}", "received_events_url": "https://api.github.com/users/edelsohn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cdfc98a9981768c475fabf069ba4d3e460deb2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cdfc98a9981768c475fabf069ba4d3e460deb2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cdfc98a9981768c475fabf069ba4d3e460deb2a"}], "stats": {"total": 149, "additions": 130, "deletions": 19}, "files": [{"sha": "7fccb31307bbd4098d00f62f66d304800598863e", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a21b4cb540be93548a6ff6d4cb4a73ab1665be/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a21b4cb540be93548a6ff6d4cb4a73ab1665be/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=42a21b4cb540be93548a6ff6d4cb4a73ab1665be", "patch": "@@ -223,10 +223,8 @@\n /* This now supports a natural alignment mode.  */\n /* AIX word-aligns FP doubles but doubleword-aligns 64-bit ints.  */\n #define ADJUST_FIELD_ALIGN(FIELD, TYPE, COMPUTED) \\\n-  ((TARGET_ALIGN_NATURAL == 0\t\t\t\t\t\t\\\n-    && (TYPE_MODE (strip_array_types (TYPE)) == DFmode\t\t\t\\\n-\t|| TYPE_MODE (strip_array_types (TYPE)) == DCmode))\t\t\\\n-   ? MIN ((COMPUTED), 32)\t\t\t\t\t\t\\\n+  (TARGET_ALIGN_NATURAL == 0\t\t\t\t\t\t\\\n+   ? rs6000_special_adjust_field_align (TYPE, COMPUTED)\t\t\t\\\n    : (COMPUTED))\n \n /* AIX increases natural record alignment to doubleword if the first"}, {"sha": "c44fd3d02638be6844f8f760984c6ea0876e931e", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a21b4cb540be93548a6ff6d4cb4a73ab1665be/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a21b4cb540be93548a6ff6d4cb4a73ab1665be/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=42a21b4cb540be93548a6ff6d4cb4a73ab1665be", "patch": "@@ -227,6 +227,7 @@ address_is_prefixed (rtx addr,\n #ifdef TREE_CODE\n extern unsigned int rs6000_data_alignment (tree, unsigned int, enum data_align);\n extern bool rs6000_special_adjust_field_align_p (tree, unsigned int);\n+extern unsigned int rs6000_special_adjust_field_align (tree, unsigned int);\n extern unsigned int rs6000_special_round_type_align (tree, unsigned int,\n \t\t\t\t\t\t     unsigned int);\n extern unsigned int darwin_rs6000_special_round_type_align (tree, unsigned int,"}, {"sha": "fd2b0b5280c8206efc36bce1e6521321e93954bb", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 74, "deletions": 15, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a21b4cb540be93548a6ff6d4cb4a73ab1665be/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a21b4cb540be93548a6ff6d4cb4a73ab1665be/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=42a21b4cb540be93548a6ff6d4cb4a73ab1665be", "patch": "@@ -7853,32 +7853,91 @@ rs6000_special_adjust_field_align_p (tree type, unsigned int computed)\n   return false;\n }\n \n-/* AIX increases natural record alignment to doubleword if the first\n-   field is an FP double while the FP fields remain word aligned.  */\n+/* AIX word-aligns FP doubles but doubleword-aligns 64-bit ints.  */\n+\n+unsigned int\n+rs6000_special_adjust_field_align (tree type, unsigned int computed)\n+{\n+  if (computed <= 32)\n+    return computed;\n+\n+  /* Strip initial arrays.  */\n+  while (TREE_CODE (type) == ARRAY_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  /* If RECORD or UNION, recursively find the first field. */\n+  while (AGGREGATE_TYPE_P (type))\n+    {\n+      tree field = TYPE_FIELDS (type);\n+\n+      /* Skip all non field decls */\n+      while (field != NULL\n+\t     && (TREE_CODE (field) != FIELD_DECL\n+\t\t || DECL_FIELD_ABI_IGNORED (field)))\n+\tfield = DECL_CHAIN (field);\n+\n+      if (! field)\n+\tbreak;\n+\n+      /* A packed field does not contribute any extra alignment.  */\n+      if (DECL_PACKED (field))\n+\treturn computed;\n+\n+      type = TREE_TYPE (field);\n+\n+      /* Strip arrays.  */\n+      while (TREE_CODE (type) == ARRAY_TYPE)\n+\ttype = TREE_TYPE (type);\n+    }\n+\n+  if (! AGGREGATE_TYPE_P (type) && type != error_mark_node\n+      && (TYPE_MODE (type) == DFmode || TYPE_MODE (type) == DCmode))\n+    computed = MIN (computed, 32);\n+\n+  return computed;\n+}\n+\n+/* AIX increases natural record alignment to doubleword if the innermost first\n+   field is an FP double while the FP fields remain word aligned.\n+   Only called if TYPE initially is a RECORD or UNION.  */\n \n unsigned int\n rs6000_special_round_type_align (tree type, unsigned int computed,\n \t\t\t\t unsigned int specified)\n {\n   unsigned int align = MAX (computed, specified);\n-  tree field = TYPE_FIELDS (type);\n \n-  /* Skip all non field decls */\n-  while (field != NULL\n-\t && (TREE_CODE (field) != FIELD_DECL\n-\t     || DECL_FIELD_ABI_IGNORED (field)))\n-    field = DECL_CHAIN (field);\n+  if (TYPE_PACKED (type) || align >= 64)\n+    return align;\n \n-  if (field != NULL && field != type)\n+  /* If RECORD or UNION, recursively find the first field. */\n+  do\n     {\n+      tree field = TYPE_FIELDS (type);\n+\n+      /* Skip all non field decls */\n+      while (field != NULL\n+\t     && (TREE_CODE (field) != FIELD_DECL\n+\t\t || DECL_FIELD_ABI_IGNORED (field)))\n+\tfield = DECL_CHAIN (field);\n+\n+      if (! field)\n+\tbreak;\n+\n+      /* A packed field does not contribute any extra alignment.  */\n+      if (DECL_PACKED (field))\n+\treturn align;\n+\n       type = TREE_TYPE (field);\n+\n+      /* Strip arrays.  */\n       while (TREE_CODE (type) == ARRAY_TYPE)\n \ttype = TREE_TYPE (type);\n+    } while (AGGREGATE_TYPE_P (type));\n \n-      if (type != error_mark_node\n-\t  && (TYPE_MODE (type) == DFmode || TYPE_MODE (type) == DCmode))\n-\talign = MAX (align, 64);\n-    }\n+  if (! AGGREGATE_TYPE_P (type) && type != error_mark_node\n+      && (TYPE_MODE (type) == DFmode || TYPE_MODE (type) == DCmode))\n+    align = MAX (align, 64);\n \n   return align;\n }\n@@ -10576,7 +10635,7 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n     case E_OOmode:\n     case E_XOmode:\n       if (CONST_INT_P (operands[1]) && INTVAL (operands[1]) != 0)\n-\terror (\"%qs is an opaque type, and you can't set it to other values.\",\n+\terror (\"%qs is an opaque type, and you cannot set it to other values\",\n \t       (mode == OOmode) ? \"__vector_pair\" : \"__vector_quad\");\n       break;\n \n@@ -20049,7 +20108,7 @@ rs6000_handle_altivec_attribute (tree *node,\n   else if (TREE_CODE (type) == COMPLEX_TYPE)\n     error (\"use of %<complex%> in AltiVec types is invalid\");\n   else if (DECIMAL_FLOAT_MODE_P (mode))\n-    error (\"use of decimal floating point types in AltiVec types is invalid\");\n+    error (\"use of decimal floating-point types in AltiVec types is invalid\");\n   else if (!TARGET_VSX)\n     {\n       if (type == long_unsigned_type_node || type == long_integer_type_node)"}, {"sha": "e0f8b2432ac505e165e293073b1acf26caeef660", "filename": "gcc/testsuite/gcc.target/powerpc/pr99557.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a21b4cb540be93548a6ff6d4cb4a73ab1665be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr99557.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a21b4cb540be93548a6ff6d4cb4a73ab1665be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr99557.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr99557.c?ref=42a21b4cb540be93548a6ff6d4cb4a73ab1665be", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do run { target { powerpc*-ibm-aix* } } } */\n+/* { dg-options \"\" } */\n+\n+void abort (void);\n+\n+struct A {\n+  double x[2];\n+  int y;\n+};\n+\n+struct B {\n+  int i;\n+  struct A a;\n+};\n+\n+struct N {\n+  double d[2];\n+};\n+\n+struct S {\n+  struct N n;\n+  float f;\n+};\n+\n+struct T {\n+  char c;\n+  struct S s;\n+};\n+\n+int main() {   \n+  if (__alignof(struct A) != 8)\n+    abort();\n+\n+  if (__alignof(struct B) != 4)\n+    abort();\n+\n+  if (__builtin_offsetof(struct B, a) != 4)\n+    abort();\n+\n+  if (__alignof(struct N) != 8)\n+    abort();\n+\n+  if (__alignof(struct S) != 8)\n+    abort();\n+\n+  if (__alignof(struct T) != 4)\n+    abort();\n+\n+  if (__builtin_offsetof(struct T, s) != 4)\n+    abort();\n+\n+  return 0;\n+}"}]}