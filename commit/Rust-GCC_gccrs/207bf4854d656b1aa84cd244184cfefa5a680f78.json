{"sha": "207bf4854d656b1aa84cd244184cfefa5a680f78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA3YmY0ODU0ZDY1NmIxYWE4NGNkMjQ0MTg0Y2ZlZmE1YTY4MGY3OA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2001-11-06T12:39:36Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-11-06T12:39:36Z"}, "message": "re PR c/461 (non-lvalue arrays)\n\n\t* c-common.c (c_expand_expr_stmt): Apply default conversions to\n\tnon-lvalue arrays if C99.\n\t* c-typeck.c (default_conversion): Split out code handling\n\tarray-to-pointer and function-to-pointer conversions into a\n\tseparate default_function_array_conversion function.\n\t(default_function_array_conversion): New function.  Keep track of\n\twhether any NON_LVALUE_EXPRs were stripped.  Return non-lvalue\n\tarrays unchanged outside C99 mode instead of giving an error for\n\tthem.\n\t(build_component_ref): Use pedantic_non_lvalue when handling\n\tCOMPOUND_EXPR.  Don't handle COND_EXPR specially.\n\t(convert_arguments): Use default_function_array_conversion.\n\t(build_unary_op): For ADDR_EXPR, take a flag indicating whether\n\tnon-lvalues are OK.\n\t(unary_complex_lvalue): Likewise.\n\t(internal_build_compound_expr): Use\n\tdefault_function_array_conversion.  Apply default conversions to\n\tfunction in compound expression.\n\t(build_c_cast, build_modify_expr, digest_init, build_asm_stmt):\n\tUse default_function_array_conversion.\n\t* doc/extend.texi: Update documentation of subscripting non-lvalue\n\tarrays.\n\tFixes PR c/461.\n\ntestsuite:\n\t* gcc.dg/c90-array-lval-1.c, gcc.dg/c90-array-lval-2.c,\n\tgcc.dg/c99-array-lval-1.c, gcc.dg/c99-array-lval-2.c: Remove\n\tXFAILs.  Adjust expected error texts.\n\t* gcc.c-torture/compile/20011106-1.c,\n\tgcc.c-torture/compile/20011106-2.c, gcc.dg/c90-array-lval-3.c,\n\tgcc.dg/c90-array-lval-4.c, gcc.dg/c90-array-lval-5.c,\n\tgcc.dg/c99-array-lval-3.c, gcc.dg/c99-array-lval-4.c,\n\tgcc.dg/c99-array-lval-5.c: New tests.\n\nFrom-SVN: r46805", "tree": {"sha": "c32872a1f39f18b63b6c13f757df788f6cd41cae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c32872a1f39f18b63b6c13f757df788f6cd41cae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/207bf4854d656b1aa84cd244184cfefa5a680f78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/207bf4854d656b1aa84cd244184cfefa5a680f78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/207bf4854d656b1aa84cd244184cfefa5a680f78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/207bf4854d656b1aa84cd244184cfefa5a680f78/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25cece2fbdf4b3d4122d1e49b77ef9d144c02a57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25cece2fbdf4b3d4122d1e49b77ef9d144c02a57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25cece2fbdf4b3d4122d1e49b77ef9d144c02a57"}], "stats": {"total": 505, "additions": 381, "deletions": 124}, "files": [{"sha": "823e3804656453764e9ed58814a1d6a369748f10", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=207bf4854d656b1aa84cd244184cfefa5a680f78", "patch": "@@ -1,3 +1,29 @@\n+2001-11-06  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* c-common.c (c_expand_expr_stmt): Apply default conversions to\n+\tnon-lvalue arrays if C99.\n+\t* c-typeck.c (default_conversion): Split out code handling\n+\tarray-to-pointer and function-to-pointer conversions into a\n+\tseparate default_function_array_conversion function.\n+\t(default_function_array_conversion): New function.  Keep track of\n+\twhether any NON_LVALUE_EXPRs were stripped.  Return non-lvalue\n+\tarrays unchanged outside C99 mode instead of giving an error for\n+\tthem.\n+\t(build_component_ref): Use pedantic_non_lvalue when handling\n+\tCOMPOUND_EXPR.  Don't handle COND_EXPR specially.\n+\t(convert_arguments): Use default_function_array_conversion.\n+\t(build_unary_op): For ADDR_EXPR, take a flag indicating whether\n+\tnon-lvalues are OK.\n+\t(unary_complex_lvalue): Likewise.\n+\t(internal_build_compound_expr): Use\n+\tdefault_function_array_conversion.  Apply default conversions to\n+\tfunction in compound expression.\n+\t(build_c_cast, build_modify_expr, digest_init, build_asm_stmt):\n+\tUse default_function_array_conversion.\n+\t* doc/extend.texi: Update documentation of subscripting non-lvalue\n+\tarrays.\n+\tFixes PR c/461.\n+\n 2001-11-05  Zack Weinberg  <zack@codesourcery.com>\n \n \t* aclocal.m4: (AM_WITH_NLS): Don't look at ALL_LINGUAS."}, {"sha": "312060d433be2cea139ef91f88f82c897e300363", "filename": "gcc/c-common.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=207bf4854d656b1aa84cd244184cfefa5a680f78", "patch": "@@ -1181,7 +1181,8 @@ c_expand_expr_stmt (expr)\n {\n   /* Do default conversion if safe and possibly important,\n      in case within ({...}).  */\n-  if ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE && lvalue_p (expr))\n+  if ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE\n+       && (flag_isoc99 || lvalue_p (expr)))\n       || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE)\n     expr = default_conversion (expr);\n "}, {"sha": "e3e541bb45b248451b3fea72bb165471d6178734", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 156, "deletions": 113, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=207bf4854d656b1aa84cd244184cfefa5a680f78", "patch": "@@ -55,11 +55,12 @@ static int comp_target_types\t\tPARAMS ((tree, tree));\n static int function_types_compatible_p\tPARAMS ((tree, tree));\n static int type_lists_compatible_p\tPARAMS ((tree, tree));\n static tree decl_constant_value_for_broken_optimization PARAMS ((tree));\n+static tree default_function_array_conversion\tPARAMS ((tree));\n static tree lookup_field\t\tPARAMS ((tree, tree));\n static tree convert_arguments\t\tPARAMS ((tree, tree, tree, tree));\n static tree pointer_int_sum\t\tPARAMS ((enum tree_code, tree, tree));\n static tree pointer_diff\t\tPARAMS ((tree, tree));\n-static tree unary_complex_lvalue\tPARAMS ((enum tree_code, tree));\n+static tree unary_complex_lvalue\tPARAMS ((enum tree_code, tree, int));\n static void pedantic_lvalue_warning\tPARAMS ((enum tree_code));\n static tree internal_build_compound_expr PARAMS ((tree, int));\n static tree convert_for_assignment\tPARAMS ((tree, tree, const char *,\n@@ -838,6 +839,110 @@ decl_constant_value_for_broken_optimization (decl)\n     return decl_constant_value (decl);\n }\n \n+\n+/* Perform the default conversion of arrays and functions to pointers.\n+   Return the result of converting EXP.  For any other expression, just\n+   return EXP.  */\n+\n+static tree\n+default_function_array_conversion (exp)\n+     tree exp;\n+{\n+  tree orig_exp;\n+  tree type = TREE_TYPE (exp);\n+  enum tree_code code = TREE_CODE (type);\n+  int not_lvalue = 0;\n+\n+  /* Strip NON_LVALUE_EXPRs and no-op conversions, since we aren't using as\n+     an lvalue. \n+\n+     Do not use STRIP_NOPS here!  It will remove conversions from pointer\n+     to integer and cause infinite recursion.  */\n+  orig_exp = exp;\n+  while (TREE_CODE (exp) == NON_LVALUE_EXPR\n+\t || (TREE_CODE (exp) == NOP_EXPR\n+\t     && TREE_TYPE (TREE_OPERAND (exp, 0)) == TREE_TYPE (exp)))\n+    {\n+      if (TREE_CODE (exp) == NON_LVALUE_EXPR)\n+\tnot_lvalue = 1;\n+      exp = TREE_OPERAND (exp, 0);\n+    }\n+\n+  /* Preserve the original expression code.  */\n+  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (exp))))\n+    C_SET_EXP_ORIGINAL_CODE (exp, C_EXP_ORIGINAL_CODE (orig_exp));\n+\n+  if (code == FUNCTION_TYPE)\n+    {\n+      return build_unary_op (ADDR_EXPR, exp, 0);\n+    }\n+  if (code == ARRAY_TYPE)\n+    {\n+      tree adr;\n+      tree restype = TREE_TYPE (type);\n+      tree ptrtype;\n+      int constp = 0;\n+      int volatilep = 0;\n+      int lvalue_array_p;\n+\n+      if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'r' || DECL_P (exp))\n+\t{\n+\t  constp = TREE_READONLY (exp);\n+\t  volatilep = TREE_THIS_VOLATILE (exp);\n+\t}\n+\n+      if (TYPE_QUALS (type) || constp || volatilep)\n+\trestype \n+\t  = c_build_qualified_type (restype,\n+\t\t\t\t    TYPE_QUALS (type) \n+\t\t\t\t    | (constp * TYPE_QUAL_CONST)\n+\t\t\t\t    | (volatilep * TYPE_QUAL_VOLATILE));\n+\n+      if (TREE_CODE (exp) == INDIRECT_REF)\n+\treturn convert (TYPE_POINTER_TO (restype),\n+\t\t\tTREE_OPERAND (exp, 0));\n+\n+      if (TREE_CODE (exp) == COMPOUND_EXPR)\n+\t{\n+\t  tree op1 = default_conversion (TREE_OPERAND (exp, 1));\n+\t  return build (COMPOUND_EXPR, TREE_TYPE (op1),\n+\t\t\tTREE_OPERAND (exp, 0), op1);\n+\t}\n+\n+      lvalue_array_p = !not_lvalue && lvalue_p (exp);\n+      if (!flag_isoc99 && !lvalue_array_p\n+\t  && !(TREE_CODE (exp) == CONSTRUCTOR && TREE_STATIC (exp)))\n+\t{\n+\t  /* Before C99, non-lvalue arrays do not decay to pointers.\n+\t     Normally, using such an array would be invalid; but it can\n+\t     be used correctly inside sizeof or as a statement expression.\n+\t     Thus, do not give an error here; an error will result later.  */\n+\t  return exp;\n+\t}\n+\n+      ptrtype = build_pointer_type (restype);\n+\n+      if (TREE_CODE (exp) == VAR_DECL)\n+\t{\n+\t  /* ??? This is not really quite correct\n+\t     in that the type of the operand of ADDR_EXPR\n+\t     is not the target type of the type of the ADDR_EXPR itself.\n+\t     Question is, can this lossage be avoided?  */\n+\t  adr = build1 (ADDR_EXPR, ptrtype, exp);\n+\t  if (mark_addressable (exp) == 0)\n+\t    return error_mark_node;\n+\t  TREE_CONSTANT (adr) = staticp (exp);\n+\t  TREE_SIDE_EFFECTS (adr) = 0;   /* Default would be, same as EXP.  */\n+\t  return adr;\n+\t}\n+      /* This way is better for a COMPONENT_REF since it can\n+\t simplify the offset for a component.  */\n+      adr = build_unary_op (ADDR_EXPR, exp, 1);\n+      return convert (ptrtype, adr);\n+    }\n+  return exp;\n+}\n+\n /* Perform default promotions for C data used in expressions.\n    Arrays and functions are converted to pointers;\n    enumeral types or short or char, to int.\n@@ -851,6 +956,9 @@ default_conversion (exp)\n   tree type = TREE_TYPE (exp);\n   enum tree_code code = TREE_CODE (type);\n \n+  if (code == FUNCTION_TYPE || code == ARRAY_TYPE)\n+    return default_function_array_conversion (exp);\n+\n   /* Constants can be used directly unless they're not loadable.  */\n   if (TREE_CODE (exp) == CONST_DECL)\n     exp = DECL_INITIAL (exp);\n@@ -924,69 +1032,6 @@ default_conversion (exp)\n       error (\"void value not ignored as it ought to be\");\n       return error_mark_node;\n     }\n-  if (code == FUNCTION_TYPE)\n-    {\n-      return build_unary_op (ADDR_EXPR, exp, 0);\n-    }\n-  if (code == ARRAY_TYPE)\n-    {\n-      tree adr;\n-      tree restype = TREE_TYPE (type);\n-      tree ptrtype;\n-      int constp = 0;\n-      int volatilep = 0;\n-\n-      if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'r' || DECL_P (exp))\n-\t{\n-\t  constp = TREE_READONLY (exp);\n-\t  volatilep = TREE_THIS_VOLATILE (exp);\n-\t}\n-\n-      if (TYPE_QUALS (type) || constp || volatilep)\n-\trestype \n-\t  = c_build_qualified_type (restype,\n-\t\t\t\t    TYPE_QUALS (type) \n-\t\t\t\t    | (constp * TYPE_QUAL_CONST)\n-\t\t\t\t    | (volatilep * TYPE_QUAL_VOLATILE));\n-\n-      if (TREE_CODE (exp) == INDIRECT_REF)\n-\treturn convert (TYPE_POINTER_TO (restype),\n-\t\t\tTREE_OPERAND (exp, 0));\n-\n-      if (TREE_CODE (exp) == COMPOUND_EXPR)\n-\t{\n-\t  tree op1 = default_conversion (TREE_OPERAND (exp, 1));\n-\t  return build (COMPOUND_EXPR, TREE_TYPE (op1),\n-\t\t\tTREE_OPERAND (exp, 0), op1);\n-\t}\n-\n-      if (! lvalue_p (exp)\n-\t  && ! (TREE_CODE (exp) == CONSTRUCTOR && TREE_STATIC (exp)))\n-\t{\n-\t  error (\"invalid use of non-lvalue array\");\n-\t  return error_mark_node;\n-\t}\n-\n-      ptrtype = build_pointer_type (restype);\n-\n-      if (TREE_CODE (exp) == VAR_DECL)\n-\t{\n-\t  /* ??? This is not really quite correct\n-\t     in that the type of the operand of ADDR_EXPR\n-\t     is not the target type of the type of the ADDR_EXPR itself.\n-\t     Question is, can this lossage be avoided?  */\n-\t  adr = build1 (ADDR_EXPR, ptrtype, exp);\n-\t  if (mark_addressable (exp) == 0)\n-\t    return error_mark_node;\n-\t  TREE_CONSTANT (adr) = staticp (exp);\n-\t  TREE_SIDE_EFFECTS (adr) = 0;   /* Default would be, same as EXP.  */\n-\t  return adr;\n-\t}\n-      /* This way is better for a COMPONENT_REF since it can\n-\t simplify the offset for a component.  */\n-      adr = build_unary_op (ADDR_EXPR, exp, 1);\n-      return convert (ptrtype, adr);\n-    }\n   return exp;\n }\n \f\n@@ -1098,22 +1143,22 @@ build_component_ref (datum, component)\n   tree field = NULL;\n   tree ref;\n \n-  /* If DATUM is a COMPOUND_EXPR or COND_EXPR, move our reference inside it\n-     unless we are not to support things not strictly ANSI.  */\n+  /* If DATUM is a COMPOUND_EXPR, move our reference inside it.\n+     If pedantic ensure that the arguments are not lvalues; otherwise,\n+     if the component is an array, it would wrongly decay to a pointer in\n+     C89 mode.\n+     We cannot do this with a COND_EXPR, because in a conditional expression\n+     the default promotions are applied to both sides, and this would yield\n+     the wrong type of the result; for example, if the components have\n+     type \"char\".  */\n   switch (TREE_CODE (datum))\n     {\n     case COMPOUND_EXPR:\n       {\n \ttree value = build_component_ref (TREE_OPERAND (datum, 1), component);\n \treturn build (COMPOUND_EXPR, TREE_TYPE (value),\n-\t\t      TREE_OPERAND (datum, 0), value);\n+\t\t      TREE_OPERAND (datum, 0), pedantic_non_lvalue (value));\n       }\n-    case COND_EXPR:\n-      return build_conditional_expr\n-\t(TREE_OPERAND (datum, 0),\n-\t build_component_ref (TREE_OPERAND (datum, 1), component),\n-\t build_component_ref (TREE_OPERAND (datum, 2), component));\n-\n     default:\n       break;\n     }\n@@ -1586,9 +1631,7 @@ convert_arguments (typelist, values, name, fundecl)\n       if (TREE_CODE (val) == NON_LVALUE_EXPR)\n \tval = TREE_OPERAND (val, 0);\n \n-      if (TREE_CODE (TREE_TYPE (val)) == ARRAY_TYPE\n-\t  || TREE_CODE (TREE_TYPE (val)) == FUNCTION_TYPE)\n-\tval = default_conversion (val);\n+      val = default_function_array_conversion (val);\n \n       val = require_complete_type (val);\n \n@@ -2771,20 +2814,25 @@ pointer_diff (op0, op1)\n \f\n /* Construct and perhaps optimize a tree representation\n    for a unary operation.  CODE, a tree_code, specifies the operation\n-   and XARG is the operand.  NOCONVERT nonzero suppresses\n-   the default promotions (such as from short to int).  */\n+   and XARG is the operand.\n+   For any CODE other than ADDR_EXPR, FLAG nonzero suppresses\n+   the default promotions (such as from short to int).\n+   For ADDR_EXPR, the default promotions are not applied; FLAG nonzero\n+   allows non-lvalues; this is only used to handle conversion of non-lvalue\n+   arrays to pointers in C99.  */\n \n tree\n-build_unary_op (code, xarg, noconvert)\n+build_unary_op (code, xarg, flag)\n      enum tree_code code;\n      tree xarg;\n-     int noconvert;\n+     int flag;\n {\n   /* No default_conversion here.  It causes trouble for ADDR_EXPR.  */\n   tree arg = xarg;\n   tree argtype = 0;\n   enum tree_code typecode = TREE_CODE (TREE_TYPE (arg));\n   tree val;\n+  int noconvert = flag;\n \n   if (typecode == ERROR_MARK)\n     return error_mark_node;\n@@ -2898,7 +2946,7 @@ build_unary_op (code, xarg, noconvert)\n       /* Handle complex lvalues (when permitted)\n \t by reduction to simpler cases.  */\n \n-      val = unary_complex_lvalue (code, arg);\n+      val = unary_complex_lvalue (code, arg, 0);\n       if (val != 0)\n \treturn val;\n \n@@ -3045,8 +3093,7 @@ build_unary_op (code, xarg, noconvert)\n       }\n \n     case ADDR_EXPR:\n-      /* Note that this operation never does default_conversion\n-\t regardless of NOCONVERT.  */\n+      /* Note that this operation never does default_conversion.  */\n \n       /* Let &* cancel out to simplify resulting code.  */\n       if (TREE_CODE (arg) == INDIRECT_REF)\n@@ -3068,7 +3115,7 @@ build_unary_op (code, xarg, noconvert)\n \n       /* Handle complex lvalues (when permitted)\n \t by reduction to simpler cases.  */\n-      val = unary_complex_lvalue (code, arg);\n+      val = unary_complex_lvalue (code, arg, flag);\n       if (val != 0)\n \treturn val;\n \n@@ -3099,8 +3146,8 @@ build_unary_op (code, xarg, noconvert)\n       if (TREE_CODE (arg) == CONSTRUCTOR && TREE_CONSTANT (arg))\n \t;\n       /* Anything not already handled and not a true memory reference\n-\t is an error.  */\n-      else if (typecode != FUNCTION_TYPE\n+\t or a non-lvalue array is an error.  */\n+      else if (typecode != FUNCTION_TYPE && !flag\n \t       && !lvalue_or_else (arg, \"invalid lvalue in unary `&'\"))\n \treturn error_mark_node;\n \n@@ -3129,7 +3176,7 @@ build_unary_op (code, xarg, noconvert)\n \t  {\n \t    tree field = TREE_OPERAND (arg, 1);\n \n-\t    addr = build_unary_op (ADDR_EXPR, TREE_OPERAND (arg, 0), 0);\n+\t    addr = build_unary_op (ADDR_EXPR, TREE_OPERAND (arg, 0), flag);\n \n \t    if (DECL_C_BIT_FIELD (field))\n \t      {\n@@ -3248,14 +3295,17 @@ lvalue_or_else (ref, msgid)\n \n /* Apply unary lvalue-demanding operator CODE to the expression ARG\n    for certain kinds of expressions which are not really lvalues\n-   but which we can accept as lvalues.\n+   but which we can accept as lvalues.  If FLAG is nonzero, then\n+   non-lvalues are OK since we may be converting a non-lvalue array to\n+   a pointer in C99.\n \n    If ARG is not a kind of expression we can handle, return zero.  */\n    \n static tree\n-unary_complex_lvalue (code, arg)\n+unary_complex_lvalue (code, arg, flag)\n      enum tree_code code;\n      tree arg;\n+     int flag;\n {\n   /* Handle (a, b) used as an \"lvalue\".  */\n   if (TREE_CODE (arg) == COMPOUND_EXPR)\n@@ -3264,7 +3314,7 @@ unary_complex_lvalue (code, arg)\n \n       /* If this returns a function type, it isn't really being used as\n \t an lvalue, so don't issue a warning about it.  */\n-      if (TREE_CODE (TREE_TYPE (arg)) != FUNCTION_TYPE)\n+      if (TREE_CODE (TREE_TYPE (arg)) != FUNCTION_TYPE && !flag)\n \tpedantic_lvalue_warning (COMPOUND_EXPR);\n \n       return build (COMPOUND_EXPR, TREE_TYPE (real_result),\n@@ -3274,14 +3324,15 @@ unary_complex_lvalue (code, arg)\n   /* Handle (a ? b : c) used as an \"lvalue\".  */\n   if (TREE_CODE (arg) == COND_EXPR)\n     {\n-      pedantic_lvalue_warning (COND_EXPR);\n-      if (TREE_CODE (TREE_TYPE (arg)) != FUNCTION_TYPE)\n+      if (!flag)\n+\tpedantic_lvalue_warning (COND_EXPR);\n+      if (TREE_CODE (TREE_TYPE (arg)) != FUNCTION_TYPE && !flag)\n \tpedantic_lvalue_warning (COMPOUND_EXPR);\n \n       return (build_conditional_expr\n \t      (TREE_OPERAND (arg, 0),\n-\t       build_unary_op (code, TREE_OPERAND (arg, 1), 0),\n-\t       build_unary_op (code, TREE_OPERAND (arg, 2), 0)));\n+\t       build_unary_op (code, TREE_OPERAND (arg, 1), flag),\n+\t       build_unary_op (code, TREE_OPERAND (arg, 2), flag)));\n     }\n \n   return 0;\n@@ -3616,9 +3667,11 @@ internal_build_compound_expr (list, first_p)\n \n   if (TREE_CHAIN (list) == 0)\n     {\n-      /* Convert arrays to pointers when there really is a comma operator.  */\n-      if (!first_p && TREE_CODE (TREE_TYPE (TREE_VALUE (list))) == ARRAY_TYPE)\n-\tTREE_VALUE (list) = default_conversion (TREE_VALUE (list));\n+      /* Convert arrays and functions to pointers when there\n+\t really is a comma operator.  */\n+      if (!first_p)\n+\tTREE_VALUE (list)\n+\t  = default_function_array_conversion (TREE_VALUE (list));\n \n #if 0 /* If something inside inhibited lvalueness, we should not override.  */\n       /* Consider (x, y+0), which is not an lvalue since y+0 is not.  */\n@@ -3705,9 +3758,7 @@ build_c_cast (type, expr)\n   else if (TREE_CODE (type) == UNION_TYPE)\n     {\n       tree field;\n-      if (TREE_CODE (TREE_TYPE (value)) == ARRAY_TYPE\n-\t  || TREE_CODE (TREE_TYPE (value)) == FUNCTION_TYPE)\n-\tvalue = default_conversion (value);\n+      value = default_function_array_conversion (value);\n \n       for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n \tif (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (field)),\n@@ -3750,9 +3801,7 @@ build_c_cast (type, expr)\n \n       /* Convert functions and arrays to pointers,\n \t but don't convert any other types.  */\n-      if (TREE_CODE (TREE_TYPE (value)) == FUNCTION_TYPE\n-\t  || TREE_CODE (TREE_TYPE (value)) == ARRAY_TYPE)\n-\tvalue = default_conversion (value);\n+      value = default_function_array_conversion (value);\n       otype = TREE_TYPE (value);\n \n       /* Optionally warn about potentially worrisome casts.  */\n@@ -3952,9 +4001,7 @@ build_modify_expr (lhs, modifycode, rhs)\n     case FIX_FLOOR_EXPR:\n     case FIX_ROUND_EXPR:\n     case FIX_CEIL_EXPR:\n-      if (TREE_CODE (TREE_TYPE (newrhs)) == ARRAY_TYPE\n-\t  || TREE_CODE (TREE_TYPE (newrhs)) == FUNCTION_TYPE)\n-\tnewrhs = default_conversion (newrhs);\n+      newrhs = default_function_array_conversion (newrhs);\n       {\n \ttree inner_lhs = TREE_OPERAND (lhs, 0);\n \ttree result;\n@@ -4734,10 +4781,8 @@ digest_init (type, init, require_constant, constructor_constant)\n \t      && comptypes (TREE_TYPE (TREE_TYPE (inside_init)),\n \t\t\t    TREE_TYPE (type)))))\n     {\n-      if (code == POINTER_TYPE\n-\t  && (TREE_CODE (TREE_TYPE (inside_init)) == ARRAY_TYPE\n-\t      || TREE_CODE (TREE_TYPE (inside_init)) == FUNCTION_TYPE))\n-\tinside_init = default_conversion (inside_init);\n+      if (code == POINTER_TYPE)\n+\tinside_init = default_function_array_conversion (inside_init);\n       else if (code == ARRAY_TYPE && TREE_CODE (inside_init) != STRING_CST\n \t       && TREE_CODE (inside_init) != CONSTRUCTOR)\n \t{\n@@ -6862,9 +6907,7 @@ build_asm_stmt (cv_qualifier, string, outputs, inputs, clobbers)\n      Don't do this for other types as it would screw up operands\n      expected to be in memory.  */\n   for (tail = inputs; tail; tail = TREE_CHAIN (tail))\n-    if (TREE_CODE (TREE_TYPE (TREE_VALUE (tail))) == ARRAY_TYPE\n-\t|| TREE_CODE (TREE_TYPE (TREE_VALUE (tail))) == FUNCTION_TYPE)\n-      TREE_VALUE (tail) = default_conversion (TREE_VALUE (tail));\n+    TREE_VALUE (tail) = default_function_array_conversion (TREE_VALUE (tail));\n \n   return add_stmt (build_stmt (ASM_STMT, cv_qualifier, string,\n \t\t\t       outputs, inputs, clobbers));"}, {"sha": "5461caeacfb5b8e9ebe5fdbdb6eb932602cab013", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=207bf4854d656b1aa84cd244184cfefa5a680f78", "patch": "@@ -1540,10 +1540,12 @@ removed.\n @cindex arrays, non-lvalue\n \n @cindex subscripting and function values\n-Subscripting is allowed on arrays that are not lvalues, even though the\n-unary @samp{&} operator is not.  (In ISO C99, both are allowed (though\n-the array may not be used after the next sequence point), but this ISO\n-C99 feature is not yet fully supported in GCC@.)  For example,\n+In ISO C99, arrays that are not lvalues still decay to pointers, and\n+may be subscripted, although they may not be modified or used after\n+the next sequence point and the unary @samp{&} operator may not be\n+applied to them.  As an extension, GCC allows such arrays to be\n+subscripted in C89 mode, though otherwise they do not decay to\n+pointers outside C99 mode.  For example,\n this is valid in GNU C though not valid in C89:\n \n @example"}, {"sha": "d11a53d18b5d5d34aec88361d496bd4a80bc6400", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=207bf4854d656b1aa84cd244184cfefa5a680f78", "patch": "@@ -1,3 +1,14 @@\n+2001-11-06  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* gcc.dg/c90-array-lval-1.c, gcc.dg/c90-array-lval-2.c,\n+\tgcc.dg/c99-array-lval-1.c, gcc.dg/c99-array-lval-2.c: Remove\n+\tXFAILs.  Adjust expected error texts.\n+\t* gcc.c-torture/compile/20011106-1.c,\n+\tgcc.c-torture/compile/20011106-2.c, gcc.dg/c90-array-lval-3.c,\n+\tgcc.dg/c90-array-lval-4.c, gcc.dg/c90-array-lval-5.c,\n+\tgcc.dg/c99-array-lval-3.c, gcc.dg/c99-array-lval-4.c,\n+\tgcc.dg/c99-array-lval-5.c: New tests.\n+\n 2001-11-05  Neil Booth  <neil@cat.daikokuya.demon.co.uk>\n \n \t* gcc.dg/cpp/defined.c: Update."}, {"sha": "9363780a65a69aa4fafccc2300a38869ccbfe830", "filename": "gcc/testsuite/gcc.c-torture/compile/20011106-1.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20011106-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20011106-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20011106-1.c?ref=207bf4854d656b1aa84cd244184cfefa5a680f78", "patch": "@@ -0,0 +1,7 @@\n+/* Test that functions passed to the comma operator are correctly converted\n+   to pointers.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk>.  */\n+\n+void foo (void);\n+void (*fp) (void);\n+char x[sizeof (1, foo) == sizeof (fp) ? 1 : -1];"}, {"sha": "358f9d2ed492ac0a708f8a3bcb958df5c5c7350c", "filename": "gcc/testsuite/gcc.c-torture/compile/20011106-2.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20011106-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20011106-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20011106-2.c?ref=207bf4854d656b1aa84cd244184cfefa5a680f78", "patch": "@@ -0,0 +1,7 @@\n+/* Test the the type of a component of a conditional expression between\n+   two structures is correct.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk>.  */\n+\n+struct s { char c; } a, b;\n+int c;\n+char x[sizeof ((c ? a : b).c) == 1 ? 1 : -1];"}, {"sha": "69655c83508ee7245bf85fb34384754dfbea45a6", "filename": "gcc/testsuite/gcc.dg/c90-array-lval-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-array-lval-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-array-lval-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-array-lval-1.c?ref=207bf4854d656b1aa84cd244184cfefa5a680f78", "patch": "@@ -16,6 +16,6 @@ bar (void)\n   (foo ()).c + 1; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n }\n /* { dg-error \"non-lvalue\" \"array not decaying to lvalue\" { target *-*-* } 14 }\n-   { dg-error \"non-lvalue\" \"array not decaying to lvalue\" { target *-*-* } 15 }\n-   { dg-error \"non-lvalue\" \"array not decaying to lvalue\" { target *-*-* } 16 }\n+   { dg-error \"non-lvalue|incompatible\" \"array not decaying to lvalue\" { target *-*-* } 15 }\n+   { dg-error \"non-lvalue|invalid\" \"array not decaying to lvalue\" { target *-*-* } 16 }\n */"}, {"sha": "9f261e05e9617030215b384ae01b6bf5a345b9a5", "filename": "gcc/testsuite/gcc.dg/c90-array-lval-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-array-lval-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-array-lval-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-array-lval-2.c?ref=207bf4854d656b1aa84cd244184cfefa5a680f78", "patch": "@@ -17,4 +17,4 @@ ASSERT (r, sizeof ((foo ()).c) == 17);\n /* The non-lvalue array does not decay to a pointer, so the comma expression\n    has (non-lvalue) array type.\n */\n-ASSERT (s, sizeof (0, (foo ()).c) == 17); /* { dg-bogus \"array\" \"bad non-lvalue array handling\" { xfail *-*-* } } */\n+ASSERT (s, sizeof (0, (foo ()).c) == 17); /* { dg-bogus \"array\" \"bad non-lvalue array handling\" } */"}, {"sha": "192a05f62c11c9191437f00f2d56ebea22e3614a", "filename": "gcc/testsuite/gcc.dg/c90-array-lval-3.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-array-lval-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-array-lval-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-array-lval-3.c?ref=207bf4854d656b1aa84cd244184cfefa5a680f78", "patch": "@@ -0,0 +1,34 @@\n+/* Test for non-lvalue arrays decaying to pointers: in C99 only.\n+   Test various ways of producing non-lvalue arrays.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic-errors\" } */\n+\n+struct s { char c[1]; };\n+struct s a, b, c;\n+int d;\n+\n+void\n+bar (void)\n+{\n+  char *t;\n+  (d ? b : c).c[0]; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  (d, b).c[0]; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  (a = b).c[0]; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  t = (d ? b : c).c; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  t = (d, b).c; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  t = (a = b).c; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  (d ? b : c).c + 1; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  (d, b).c + 1; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  (a = b).c + 1; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+}\n+/* { dg-error \"non-lvalue\" \"array not decaying to lvalue\" { target *-*-* } 15 }\n+   { dg-error \"non-lvalue\" \"array not decaying to lvalue\" { target *-*-* } 16 }\n+   { dg-error \"non-lvalue\" \"array not decaying to lvalue\" { target *-*-* } 17 }\n+   { dg-error \"non-lvalue|incompatible\" \"array not decaying to lvalue\" { target *-*-* } 18 }\n+   { dg-error \"non-lvalue|incompatible\" \"array not decaying to lvalue\" { target *-*-* } 19 }\n+   { dg-error \"non-lvalue|incompatible\" \"array not decaying to lvalue\" { target *-*-* } 20 }\n+   { dg-error \"non-lvalue|invalid\" \"array not decaying to lvalue\" { target *-*-* } 21 }\n+   { dg-error \"non-lvalue|invalid\" \"array not decaying to lvalue\" { target *-*-* } 22 }\n+   { dg-error \"non-lvalue|invalid\" \"array not decaying to lvalue\" { target *-*-* } 23 }\n+*/"}, {"sha": "1f9cb1455eaf09ea82ea1b648a9345eef408d4dc", "filename": "gcc/testsuite/gcc.dg/c90-array-lval-4.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-array-lval-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-array-lval-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-array-lval-4.c?ref=207bf4854d656b1aa84cd244184cfefa5a680f78", "patch": "@@ -0,0 +1,26 @@\n+/* Test for non-lvalue arrays decaying to pointers: in C99 only.\n+   Test various ways of producing non-lvalue arrays.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic-errors\" } */\n+\n+struct s { char c[17]; };\n+\n+struct s x;\n+\n+struct s a, b, c;\n+int d;\n+\n+#define ASSERT(v, a)\tchar v[((a) ? 1 : -1)]\n+\n+ASSERT (p, sizeof (x.c) == 17);\n+ASSERT (q, sizeof (0, x.c) == sizeof (char *));\n+ASSERT (r0, sizeof ((d ? b : c).c) == 17);\n+ASSERT (r1, sizeof ((d, b).c) == 17);\n+ASSERT (r2, sizeof ((a = b).c) == 17);\n+/* The non-lvalue array does not decay to a pointer, so the comma expression\n+   has (non-lvalue) array type.\n+*/\n+ASSERT (s0, sizeof (0, (d ? b : c).c) == 17); /* { dg-bogus \"array\" \"bad non-lvalue array handling\" } */\n+ASSERT (s0, sizeof (0, (d, b).c) == 17); /* { dg-bogus \"array\" \"bad non-lvalue array handling\" } */\n+ASSERT (s0, sizeof (0, (a = b).c) == 17); /* { dg-bogus \"array\" \"bad non-lvalue array handling\" } */"}, {"sha": "c218a4dae679b20a1481dc62d1d5d220bdc66cd1", "filename": "gcc/testsuite/gcc.dg/c90-array-lval-5.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-array-lval-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-array-lval-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-array-lval-5.c?ref=207bf4854d656b1aa84cd244184cfefa5a680f78", "patch": "@@ -0,0 +1,26 @@\n+/* Test for non-lvalue arrays: test that the unary '&' operator is not\n+   allowed on them, for both C90 and C99.  */\n+\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic-errors\" } */\n+\n+struct s { char c[1]; };\n+\n+extern struct s foo (void);\n+struct s a, b, c;\n+int d;\n+\n+void\n+bar (void)\n+{\n+  &((foo ()).c); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  &((d ? b : c).c); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  &((d, b).c); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  &((a = b).c); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+}\n+/* { dg-error \"lvalue\" \"bad address-of\" { target *-*-* } 17 }\n+   { dg-error \"lvalue\" \"bad address-of\" { target *-*-* } 18 }\n+   { dg-error \"lvalue\" \"bad address-of\" { target *-*-* } 19 }\n+   { dg-error \"lvalue\" \"bad address-of\" { target *-*-* } 20 }\n+*/"}, {"sha": "c0fccc813a8d82e95f53c1cbac8aa5a295da3a01", "filename": "gcc/testsuite/gcc.dg/c99-array-lval-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-array-lval-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-array-lval-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-array-lval-1.c?ref=207bf4854d656b1aa84cd244184cfefa5a680f78", "patch": "@@ -12,6 +12,6 @@ bar (void)\n {\n   char *t;\n   (foo ()).c[0]; /* { dg-bogus \"non-lvalue\" \"array not decaying to lvalue\" } */\n-  t = (foo ()).c; /* { dg-bogus \"non-lvalue\" \"array not decaying to lvalue\" { xfail *-*-* } } */\n-  (foo ()).c + 1; /* { dg-bogus \"non-lvalue\" \"array not decaying to lvalue\" { xfail *-*-* } } */\n+  t = (foo ()).c; /* { dg-bogus \"non-lvalue\" \"array not decaying to lvalue\" } */\n+  (foo ()).c + 1; /* { dg-bogus \"non-lvalue\" \"array not decaying to lvalue\" } */\n }"}, {"sha": "894ff957a302735261fe620b307dca6f52305b1c", "filename": "gcc/testsuite/gcc.dg/c99-array-lval-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-array-lval-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-array-lval-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-array-lval-2.c?ref=207bf4854d656b1aa84cd244184cfefa5a680f78", "patch": "@@ -15,4 +15,4 @@ ASSERT (p, sizeof (x.c) == 17);\n ASSERT (q, sizeof (0, x.c) == sizeof (char *));\n ASSERT (r, sizeof ((foo ()).c) == 17);\n /* The non-lvalue array decays to a pointer in C99.  */\n-ASSERT (s, sizeof (0, (foo ()).c) == sizeof (char *)); /* { dg-bogus \"array\" \"bad non-lvalue array handling\" { xfail *-*-* } } */\n+ASSERT (s, sizeof (0, (foo ()).c) == sizeof (char *)); /* { dg-bogus \"array\" \"bad non-lvalue array handling\" } */"}, {"sha": "a12a9600bf9b9edb899d252f36b19e8dd9f81363", "filename": "gcc/testsuite/gcc.dg/c99-array-lval-3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-array-lval-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-array-lval-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-array-lval-3.c?ref=207bf4854d656b1aa84cd244184cfefa5a680f78", "patch": "@@ -0,0 +1,24 @@\n+/* Test for non-lvalue arrays decaying to pointers: in C99 only.\n+   Test various ways of producing non-lvalue arrays.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+\n+struct s { char c[1]; };\n+struct s a, b, c;\n+int d;\n+\n+void\n+bar (void)\n+{\n+  char *t;\n+  (d ? b : c).c[0];\n+  (d, b).c[0];\n+  (a = b).c[0];\n+  t = (d ? b : c).c;\n+  t = (d, b).c;\n+  t = (a = b).c;\n+  (d ? b : c).c + 1;\n+  (d, b).c + 1;\n+  (a = b).c + 1;\n+}"}, {"sha": "259ce9214535cd0c0a475c7a452f4b1ee93716db", "filename": "gcc/testsuite/gcc.dg/c99-array-lval-4.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-array-lval-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-array-lval-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-array-lval-4.c?ref=207bf4854d656b1aa84cd244184cfefa5a680f78", "patch": "@@ -0,0 +1,24 @@\n+/* Test for non-lvalue arrays decaying to pointers: in C99 only.\n+   Test various ways of producing non-lvalue arrays.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+\n+struct s { char c[17]; };\n+\n+struct s x;\n+\n+struct s a, b, c;\n+int d;\n+\n+#define ASSERT(v, a)\tchar v[((a) ? 1 : -1)]\n+\n+ASSERT (p, sizeof (x.c) == 17);\n+ASSERT (q, sizeof (0, x.c) == sizeof (char *));\n+ASSERT (r0, sizeof ((d ? b : c).c) == 17);\n+ASSERT (r1, sizeof ((d, b).c) == 17);\n+ASSERT (r2, sizeof ((a = b).c) == 17);\n+/* The non-lvalue array decays to a pointer in C99.  */\n+ASSERT (s0, sizeof (0, (d ? b : c).c) == sizeof (char *)); /* { dg-bogus \"array\" \"bad non-lvalue array handling\" } */\n+ASSERT (s0, sizeof (0, (d, b).c) == sizeof (char *)); /* { dg-bogus \"array\" \"bad non-lvalue array handling\" } */\n+ASSERT (s0, sizeof (0, (a = b).c) == sizeof (char *)); /* { dg-bogus \"array\" \"bad non-lvalue array handling\" } */"}, {"sha": "57e806d97d530923ac16bc2cd8d87cac9bf5efe2", "filename": "gcc/testsuite/gcc.dg/c99-array-lval-5.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-array-lval-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/207bf4854d656b1aa84cd244184cfefa5a680f78/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-array-lval-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-array-lval-5.c?ref=207bf4854d656b1aa84cd244184cfefa5a680f78", "patch": "@@ -0,0 +1,26 @@\n+/* Test for non-lvalue arrays: test that the unary '&' operator is not\n+   allowed on them, for both C90 and C99.  */\n+\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+\n+struct s { char c[1]; };\n+\n+extern struct s foo (void);\n+struct s a, b, c;\n+int d;\n+\n+void\n+bar (void)\n+{\n+  &((foo ()).c); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  &((d ? b : c).c); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  &((d, b).c); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+  &((a = b).c); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n+}\n+/* { dg-error \"lvalue\" \"bad address-of\" { target *-*-* } 17 }\n+   { dg-error \"lvalue\" \"bad address-of\" { target *-*-* } 18 }\n+   { dg-error \"lvalue\" \"bad address-of\" { target *-*-* } 19 }\n+   { dg-error \"lvalue\" \"bad address-of\" { target *-*-* } 20 }\n+*/"}]}