{"sha": "b8f7ff76d6f0b7fdffc314a19425423606b5e296", "node_id": "C_kwDOANBUbNoAKGI4ZjdmZjc2ZDZmMGI3ZmRmZmMzMTRhMTk0MjU0MjM2MDZiNWUyOTY", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-11-09T12:56:43Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-12-12T22:51:12Z"}, "message": "Replace gnu::unique_ptr with std::unique_ptr\n\nNow that GCC is compiled as C++11 there is no need to keep the C++03\nimplementation of gnu::unique_ptr.\n\nThis removes the unique-ptr.h header and replaces it with <memory> in\nsystem.h, and changes the INCLUDE_UNIQUE_PTR macro to INCLUDE_MEMORY.\nUses of gnu::unique_ptr and gnu::move can be replaced with\nstd::unique_ptr and std::move. There are no uses of unique_xmalloc_ptr\nor xmalloc_deleter in GCC.\n\ngcc/analyzer/ChangeLog:\n\n\t* engine.cc: Define INCLUDE_MEMORY instead of INCLUDE_UNIQUE_PTR.\n\ngcc/c-family/ChangeLog:\n\n\t* known-headers.cc: Define INCLUDE_MEMORY instead of\n\tINCLUDE_UNIQUE_PTR.\n\t* name-hint.h: Likewise.\n\t(class name_hint): Use std::unique_ptr instead of gnu::unique_ptr.\n\ngcc/c/ChangeLog:\n\n\t* c-decl.c: Define INCLUDE_MEMORY instead of INCLUDE_UNIQUE_PTR.\n\t* c-parser.c: Likewise.\n\ngcc/cp/ChangeLog:\n\n\t* error.c: Define INCLUDE_MEMORY instead of\n\tINCLUDE_UNIQUE_PTR.\n\t* lex.c: Likewise.\n\t* name-lookup.c: Likewise.\n\t(class namespace_limit_reached): Use std::unique_ptr instead of\n\tgnu::unique_ptr.\n\t(suggest_alternatives_for): Use std::move instead of gnu::move.\n\t(suggest_alternatives_in_other_namespaces): Likewise.\n\t* parser.c: Define INCLUDE_MEMORY instead of INCLUDE_UNIQUE_PTR.\n\ngcc/ChangeLog:\n\n\t* Makefile.in: Remove unique-ptr-tests.o.\n\t* selftest-run-tests.c (selftest::run_tests): Remove\n\tunique_ptr_tests_cc_tests.\n\t* selftest.h (unique_ptr_tests_cc_tests): Remove.\n\t* system.h: Check INCLUDE_MEMORY instead of INCLUDE_UNIQUE_PTR\n\tand include <memory> instead of \"unique-ptr.h\".\n\t* unique-ptr-tests.cc: Removed.\n\ninclude/ChangeLog:\n\n\t* unique-ptr.h: Removed.", "tree": {"sha": "f19438f2a2a95503d4336e9c74de3912f6c896c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f19438f2a2a95503d4336e9c74de3912f6c896c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8f7ff76d6f0b7fdffc314a19425423606b5e296", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8f7ff76d6f0b7fdffc314a19425423606b5e296", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8f7ff76d6f0b7fdffc314a19425423606b5e296", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8f7ff76d6f0b7fdffc314a19425423606b5e296/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef"}], "stats": {"total": 688, "additions": 21, "deletions": 667}, "files": [{"sha": "3e0cb47945ea2941c5a1e6fcd65378fa824d3dbe", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b8f7ff76d6f0b7fdffc314a19425423606b5e296", "patch": "@@ -1699,7 +1699,6 @@ OBJS = \\\n \ttree.o \\\n \ttristate.o \\\n \ttyped-splay-tree.o \\\n-\tunique-ptr-tests.o \\\n \tvaltrack.o \\\n \tvalue-pointer-equiv.o \\\n \tvalue-query.o \\"}, {"sha": "4aa246c7ad57240ced64d596d32839ae3c84119a", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=b8f7ff76d6f0b7fdffc314a19425423606b5e296", "patch": "@@ -19,7 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n-#define INCLUDE_UNIQUE_PTR\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\""}, {"sha": "572cca177fab45a433d96310d68bde504a68bbbd", "filename": "gcc/c-family/known-headers.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fc-family%2Fknown-headers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fc-family%2Fknown-headers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fknown-headers.cc?ref=b8f7ff76d6f0b7fdffc314a19425423606b5e296", "patch": "@@ -18,7 +18,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n-#define INCLUDE_UNIQUE_PTR\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"c-family/c-common.h\""}, {"sha": "3141552ea59e79489a27c23e7bc6dba8e34c69a2", "filename": "gcc/c-family/name-hint.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fc-family%2Fname-hint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fc-family%2Fname-hint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fname-hint.h?ref=b8f7ff76d6f0b7fdffc314a19425423606b5e296", "patch": "@@ -20,12 +20,12 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_NAME_HINT_H\n #define GCC_NAME_HINT_H\n \n-/* This header uses gnu::unique_ptr, but unique-ptr.h can't be directly\n+/* This header uses std::unique_ptr, but <memory> can't be directly\n    included due to issues with macros.  Hence it must be included from\n-   system.h by defining INCLUDE_UNIQUE_PTR in any source file using it.  */\n+   system.h by defining INCLUDE_MEMORY in any source file using it.  */\n \n-#ifndef GNU_UNIQUE_PTR_H\n-# error \"You must define INCLUDE_UNIQUE_PTR before including system.h to use name-hint.h\"\n+#ifndef INCLUDE_MEMORY\n+# error \"You must define INCLUDE_MEMORY before including system.h to use name-hint.h\"\n #endif\n \n enum lookup_name_fuzzy_kind {\n@@ -106,7 +106,7 @@ class name_hint\n \n   /* Take ownership of this name_hint's deferred_diagnostic, for use\n      in chaining up deferred diagnostics.  */\n-  gnu::unique_ptr<deferred_diagnostic> take_deferred () { return move (m_deferred); }\n+  std::unique_ptr<deferred_diagnostic> take_deferred () { return move (m_deferred); }\n \n   /* Call this on a name_hint if the corresponding warning was not emitted,\n      in which case we should also not emit the deferred_diagnostic.  */\n@@ -119,7 +119,7 @@ class name_hint\n \n private:\n   const char *m_suggestion;\n-  gnu::unique_ptr<deferred_diagnostic> m_deferred;\n+  std::unique_ptr<deferred_diagnostic> m_deferred;\n };\n \n extern name_hint lookup_name_fuzzy (tree, enum lookup_name_fuzzy_kind,"}, {"sha": "4b5481ce8f4fb21c4de873c923306f37695619e4", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=b8f7ff76d6f0b7fdffc314a19425423606b5e296", "patch": "@@ -26,7 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"config.h\"\n #define INCLUDE_STRING\n-#define INCLUDE_UNIQUE_PTR\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"target.h\""}, {"sha": "e25df4f26d6631f7f67580e6184042c1a3c81fc4", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=b8f7ff76d6f0b7fdffc314a19425423606b5e296", "patch": "@@ -36,7 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n    location rather than implicitly using input_location.  */\n \n #include \"config.h\"\n-#define INCLUDE_UNIQUE_PTR\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"target.h\""}, {"sha": "323643d1e6f5d2fbccffbcc5868789f96e728890", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=b8f7ff76d6f0b7fdffc314a19425423606b5e296", "patch": "@@ -19,7 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"config.h\"\n /* For use with name_hint.  */\n-#define INCLUDE_UNIQUE_PTR\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"cp-tree.h\""}, {"sha": "06de6cfe3b38dbf12e1a7d25efd70b5ca5a23eb8", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=b8f7ff76d6f0b7fdffc314a19425423606b5e296", "patch": "@@ -23,7 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"config.h\"\n /* For use with name_hint.  */\n-#define INCLUDE_UNIQUE_PTR\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"cp-tree.h\""}, {"sha": "6b5e434959587abfff4e8e6bfb0aa55841e68923", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=b8f7ff76d6f0b7fdffc314a19425423606b5e296", "patch": "@@ -19,7 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n-#define INCLUDE_UNIQUE_PTR\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"cp-tree.h\"\n@@ -6340,7 +6340,7 @@ class namespace_limit_reached : public deferred_diagnostic\n {\n  public:\n   namespace_limit_reached (location_t loc, unsigned limit, tree name,\n-\t\t\t   gnu::unique_ptr<deferred_diagnostic> wrapped)\n+\t\t\t   std::unique_ptr<deferred_diagnostic> wrapped)\n   : deferred_diagnostic (loc),\n     m_limit (limit), m_name (name),\n     m_wrapped (move (wrapped))\n@@ -6360,7 +6360,7 @@ class namespace_limit_reached : public deferred_diagnostic\n  private:\n   unsigned m_limit;\n   tree m_name;\n-  gnu::unique_ptr<deferred_diagnostic> m_wrapped;\n+  std::unique_ptr<deferred_diagnostic> m_wrapped;\n };\n \n /* Subclass of deferred_diagnostic, for use when issuing a single suggestion.\n@@ -6604,7 +6604,7 @@ suggest_alternatives_for (location_t location, tree name,\n   if (!result)\n     result = suggest_alternatives_for_1 (location, name, suggest_misspellings);\n \n-  return ns_hints.maybe_decorate_with_limit (gnu::move (result));\n+  return ns_hints.maybe_decorate_with_limit (std::move (result));\n }\n \n /* The second half of suggest_alternatives_for, for when no exact matches\n@@ -6649,7 +6649,7 @@ suggest_alternatives_in_other_namespaces (location_t location, tree name)\n \n   name_hint result = ns_hints.convert_candidates_to_name_hint ();\n \n-  return ns_hints.maybe_decorate_with_limit (gnu::move (result));\n+  return ns_hints.maybe_decorate_with_limit (std::move (result));\n }\n \n /* A well-known name within the C++ standard library, returned by"}, {"sha": "52225d46d4ee1e7082cab5f3a000be50fa1aa349", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b8f7ff76d6f0b7fdffc314a19425423606b5e296", "patch": "@@ -19,7 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n-#define INCLUDE_UNIQUE_PTR\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"cp-tree.h\""}, {"sha": "8eb1239b59c71ed2f10ada87462d82fbfc401d57", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=b8f7ff76d6f0b7fdffc314a19425423606b5e296", "patch": "@@ -71,7 +71,6 @@ selftest::run_tests ()\n   sreal_c_tests ();\n   fibonacci_heap_c_tests ();\n   typed_splay_tree_c_tests ();\n-  unique_ptr_tests_cc_tests ();\n   opt_proposer_c_tests ();\n   opts_c_tests ();\n   json_cc_tests ();"}, {"sha": "e6c7fc35afa8f6fe7eb7df36464a3c03277e607c", "filename": "gcc/selftest.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=b8f7ff76d6f0b7fdffc314a19425423606b5e296", "patch": "@@ -262,7 +262,6 @@ extern void tree_cfg_c_tests ();\n extern void tree_diagnostic_path_cc_tests ();\n extern void tristate_cc_tests ();\n extern void typed_splay_tree_c_tests ();\n-extern void unique_ptr_tests_cc_tests ();\n extern void vec_c_tests ();\n extern void vec_perm_indices_c_tests ();\n extern void wide_int_cc_tests ();"}, {"sha": "2cd201743c3f39978612a24c4387b06eda49b261", "filename": "gcc/system.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f7ff76d6f0b7fdffc314a19425423606b5e296/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=b8f7ff76d6f0b7fdffc314a19425423606b5e296", "patch": "@@ -737,12 +737,10 @@ extern int vsnprintf (char *, size_t, const char *, va_list);\n \n /* Some of the headers included by <memory> can use \"abort\" within a\n    namespace, e.g. \"_VSTD::abort();\", which fails after we use the\n-   preprocessor to redefine \"abort\" as \"fancy_abort\" below.\n-   Given that unique-ptr.h can use \"free\", we need to do this after \"free\"\n-   is declared but before \"abort\" is overridden.  */\n+   preprocessor to redefine \"abort\" as \"fancy_abort\" below.  */\n \n-#ifdef INCLUDE_UNIQUE_PTR\n-# include \"unique-ptr.h\"\n+#ifdef INCLUDE_MEMORY\n+# include <memory>\n #endif\n \n #ifdef INCLUDE_MALLOC_H"}, {"sha": "975dd57398e3887ff74fb32ed04327fb69d2a648", "filename": "gcc/unique-ptr-tests.cc", "status": "removed", "additions": 0, "deletions": 236, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Funique-ptr-tests.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/gcc%2Funique-ptr-tests.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funique-ptr-tests.cc?ref=0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "patch": "@@ -1,236 +0,0 @@\n-/* Unit tests for unique-ptr.h.\n-   Copyright (C) 2017-2021 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#define INCLUDE_UNIQUE_PTR\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"selftest.h\"\n-\n-#if CHECKING_P\n-\n-namespace selftest {\n-\n-namespace {\n-\n-/* A class for counting ctor and dtor invocations.  */\n-\n-class stats\n-{\n-public:\n-  stats () : ctor_count (0), dtor_count (0) {}\n-\n-  int ctor_count;\n-  int dtor_count;\n-};\n-\n-/* A class that uses \"stats\" to track its ctor and dtor invocations.  */\n-\n-class foo\n-{\n-public:\n-  foo (stats &s) : m_s (s) { ++m_s.ctor_count; }\n-  ~foo () { ++m_s.dtor_count; }\n-\n-  int example_method () const { return 42; }\n-\n-private:\n-  foo (const foo&);\n-  foo & operator= (const foo &);\n-\n-private:\n-  stats &m_s;\n-};\n-\n-/* A struct for testing unique_ptr<T[]>.  */\n-\n-class has_default_ctor\n-{\n-public:\n-  has_default_ctor () : m_field (42) {}\n-  int m_field;\n-};\n-\n-/* A dummy struct for testing unique_xmalloc_ptr.  */\n-\n-struct dummy\n-{\n-  int field;\n-};\n-\n-} // anonymous namespace\n-\n-/* Verify that the default ctor inits ptrs to NULL.  */\n-\n-static void\n-test_null_ptr ()\n-{\n-  gnu::unique_ptr<void *> p;\n-  ASSERT_EQ (NULL, p);\n-\n-  gnu::unique_xmalloc_ptr<void *> q;\n-  ASSERT_EQ (NULL, q);\n-}\n-\n-/* Verify that deletion happens when a unique_ptr goes out of scope.  */\n-\n-static void\n-test_implicit_deletion ()\n-{\n-  stats s;\n-  ASSERT_EQ (0, s.ctor_count);\n-  ASSERT_EQ (0, s.dtor_count);\n-\n-  {\n-    gnu::unique_ptr<foo> f (new foo (s));\n-    ASSERT_NE (NULL, f);\n-    ASSERT_EQ (1, s.ctor_count);\n-    ASSERT_EQ (0, s.dtor_count);\n-  }\n-\n-  /* Verify that the foo was implicitly deleted.  */\n-  ASSERT_EQ (1, s.ctor_count);\n-  ASSERT_EQ (1, s.dtor_count);\n-}\n-\n-/* Verify that we can assign to a NULL unique_ptr.  */\n-\n-static void\n-test_overwrite_of_null ()\n-{\n-  stats s;\n-  ASSERT_EQ (0, s.ctor_count);\n-  ASSERT_EQ (0, s.dtor_count);\n-\n-  {\n-    gnu::unique_ptr<foo> f;\n-    ASSERT_EQ (NULL, f);\n-    ASSERT_EQ (0, s.ctor_count);\n-    ASSERT_EQ (0, s.dtor_count);\n-\n-    /* Overwrite with a non-NULL value.  */\n-    f = gnu::unique_ptr<foo> (new foo (s));\n-    ASSERT_EQ (1, s.ctor_count);\n-    ASSERT_EQ (0, s.dtor_count);\n-  }\n-\n-  /* Verify that the foo is implicitly deleted.  */\n-  ASSERT_EQ (1, s.ctor_count);\n-  ASSERT_EQ (1, s.dtor_count);\n-}\n-\n-/* Verify that we can assign to a non-NULL unique_ptr.  */\n-\n-static void\n-test_overwrite_of_non_null ()\n-{\n-  stats s;\n-  ASSERT_EQ (0, s.ctor_count);\n-  ASSERT_EQ (0, s.dtor_count);\n-\n-  {\n-    gnu::unique_ptr<foo> f (new foo (s));\n-    ASSERT_NE (NULL, f);\n-    ASSERT_EQ (1, s.ctor_count);\n-    ASSERT_EQ (0, s.dtor_count);\n-\n-    /* Overwrite with a different value.  */\n-    f = gnu::unique_ptr<foo> (new foo (s));\n-    ASSERT_EQ (2, s.ctor_count);\n-    ASSERT_EQ (1, s.dtor_count);\n-  }\n-\n-  /* Verify that the 2nd foo was implicitly deleted.  */\n-  ASSERT_EQ (2, s.ctor_count);\n-  ASSERT_EQ (2, s.dtor_count);\n-}\n-\n-/* Verify that unique_ptr's overloaded ops work.  */\n-\n-static void\n-test_overloaded_ops ()\n-{\n-  stats s;\n-  gnu::unique_ptr<foo> f (new foo (s));\n-  ASSERT_EQ (42, f->example_method ());\n-  ASSERT_EQ (42, (*f).example_method ());\n-  ASSERT_EQ (f, f);\n-  ASSERT_NE (NULL, f.get ());\n-\n-  gnu::unique_ptr<foo> g (new foo (s));\n-  ASSERT_NE (f, g);\n-}\n-\n-/* Verify that the gnu::unique_ptr specialization for T[] works.  */\n-\n-static void\n-test_array_new ()\n-{\n-  const int num = 10;\n-  gnu::unique_ptr<has_default_ctor[]> p (new has_default_ctor[num]);\n-  ASSERT_NE (NULL, p.get ());\n-  /* Verify that operator[] works, and that the default ctor was called\n-     on each element.  */\n-  for (int i = 0; i < num; i++)\n-    ASSERT_EQ (42, p[i].m_field);\n-}\n-\n-/* Verify that gnu::unique_xmalloc_ptr works.  */\n-\n-static void\n-test_xmalloc ()\n-{\n-  gnu::unique_xmalloc_ptr<dummy> p (XNEW (dummy));\n-  ASSERT_NE (NULL, p.get ());\n-}\n-\n-/* Verify the gnu::unique_xmalloc_ptr specialization for T[].  */\n-\n-static void\n-test_xmalloc_array ()\n-{\n-  const int num = 10;\n-  gnu::unique_xmalloc_ptr<dummy[]> p (XNEWVEC (dummy, num));\n-  ASSERT_NE (NULL, p.get ());\n-\n-  /* Verify that operator[] works.  */\n-  for (int i = 0; i < num; i++)\n-    p[i].field = 42;\n-  for (int i = 0; i < num; i++)\n-    ASSERT_EQ (42, p[i].field);\n-}\n-\n-/* Run all of the selftests within this file.  */\n-\n-void\n-unique_ptr_tests_cc_tests ()\n-{\n-  test_null_ptr ();\n-  test_implicit_deletion ();\n-  test_overwrite_of_null ();\n-  test_overwrite_of_non_null ();\n-  test_overloaded_ops ();\n-  test_array_new ();\n-  test_xmalloc ();\n-  test_xmalloc_array ();\n-}\n-\n-} // namespace selftest\n-\n-#endif /* #if CHECKING_P */"}, {"sha": "d1b2ba5b62d76a898d5988aa812a6c2b221e11bb", "filename": "include/unique-ptr.h", "status": "removed", "additions": 0, "deletions": 405, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/include%2Funique-ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b52083ea2c2dd9897031fdc3802a68fd4aa45ef/include%2Funique-ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Funique-ptr.h?ref=0b52083ea2c2dd9897031fdc3802a68fd4aa45ef", "patch": "@@ -1,405 +0,0 @@\n-/* gnu::unique_ptr, a simple std::unique_ptr replacement for C++03.\n-\n-   Copyright (C) 2007-2021 Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-/* gnu::unique_ptr defines a C++ owning smart pointer that exposes a\n-   subset of the std::unique_ptr API.\n-\n-   In fact, when compiled with a C++11 compiler, gnu::unique_ptr\n-   actually _is_ std::unique_ptr.  When compiled with a C++03 compiler\n-   OTOH, it's an hand coded std::unique_ptr emulation that assumes\n-   code is correct and doesn't try to be too smart.\n-\n-   This supports custom deleters, but not _stateful_ deleters, so you\n-   can't use those in C++11 mode either.  Only the managed pointer is\n-   stored in the smart pointer.  That could be changed; it simply\n-   wasn't found necessary.\n-\n-   At the end of the file you'll find a gnu::unique_ptr partial\n-   specialization that uses a custom (stateless) deleter:\n-   gnu::unique_xmalloc_ptr.  That is used to manage pointers to\n-   objects allocated with xmalloc.\n-\n-   The C++03 version was originally based on GCC 7.0's std::auto_ptr\n-   and then heavily customized to behave more like C++11's\n-   std::unique_ptr, but at this point, it no longer shares much at all\n-   with the original file.  But, that's the history and the reason for\n-   the copyright's starting year.\n-\n-   The C++03 version lets you shoot yourself in the foot, since\n-   similarly to std::auto_ptr, the copy constructor and assignment\n-   operators actually move.  Also, in the name of simplicity, no\n-   effort is spent on using SFINAE to prevent invalid conversions,\n-   etc.  This is not really a problem, because the goal here is to\n-   allow code that would be correct using std::unique_ptr to be\n-   equally correct in C++03 mode, and, just as efficient.  If client\n-   code compiles correctly with a C++11 (or newer) compiler, we know\n-   we're not doing anything invalid by mistake.\n-\n-   Usage notes:\n-\n-   - Putting gnu::unique_ptr in standard containers is not supported,\n-     since C++03 containers are not move-aware (and our emulation\n-     relies on copy actually moving).\n-\n-   - Since there's no nullptr in C++03, gnu::unique_ptr allows\n-     implicit initialization and assignment from NULL instead.\n-\n-   - To check whether there's an associated managed object, all these\n-     work as expected:\n-\n-      if (ptr)\n-      if (!ptr)\n-      if (ptr != NULL)\n-      if (ptr == NULL)\n-      if (NULL != ptr)\n-      if (NULL == ptr)\n-*/\n-\n-#ifndef GNU_UNIQUE_PTR_H\n-#define GNU_UNIQUE_PTR_H 1\n-\n-#if __cplusplus >= 201103\n-# include <memory>\n-#endif\n-\n-namespace gnu\n-{\n-\n-#if __cplusplus >= 201103\n-\n-/* In C++11 mode, all we need is import the standard\n-   std::unique_ptr.  */\n-template<typename T> using unique_ptr = std::unique_ptr<T>;\n-\n-/* Pull in move as well.  */\n-using std::move;\n-\n-#else /* C++11 */\n-\n-/* Default destruction policy used by gnu::unique_ptr when no deleter\n-   is specified.  Uses delete.  */\n-\n-template<typename T>\n-struct default_delete\n-{\n-  void operator () (T *ptr) const { delete ptr; }\n-};\n-\n-/* Specialization for arrays.  Uses delete[].  */\n-\n-template<typename T>\n-struct default_delete<T[]>\n-{\n-  void operator () (T *ptr) const { delete [] ptr; }\n-};\n-\n-namespace detail\n-{\n-/* Type used to support implicit construction from NULL:\n-\n-     gnu::unique_ptr<foo> func (....)\n-     {\n-     return NULL;\n-     }\n-\n-   and assignment from NULL:\n-\n-     gnu::unique_ptr<foo> ptr (....);\n-     ...\n-     ptr = NULL;\n-\n-  It is intentionally not defined anywhere.  */\n-struct nullptr_t;\n-\n-/* Base class of our unique_ptr emulation.  Contains code common to\n-   both unique_ptr<T, D> and unique_ptr<T[], D>.  */\n-\n-template<typename T, typename D>\n-class unique_ptr_base\n-{\n-public:\n-  typedef T *pointer;\n-  typedef T element_type;\n-  typedef D deleter_type;\n-\n-  /* Takes ownership of a pointer.  P is a pointer to an object of\n-     element_type type.  Defaults to NULL.  */\n-  explicit unique_ptr_base (element_type *p = NULL) throw () : m_ptr (p) {}\n-\n-  /* The \"move\" constructor.  Really a copy constructor that actually\n-     moves.  Even though std::unique_ptr is not copyable, our little\n-     simpler emulation allows it, because:\n-\n-       - There are no rvalue references in C++03.  Our move emulation\n-       instead relies on copy/assignment moving, like std::auto_ptr.\n-       - RVO/NRVO requires an accessible copy constructor\n-  */\n-  unique_ptr_base (const unique_ptr_base &other) throw ()\n-    : m_ptr (const_cast<unique_ptr_base &> (other).release ()) {}\n-\n-  /* Converting \"move\" constructor.  Really an lvalue ref converting\n-     constructor that actually moves.  This allows constructs such as:\n-\n-      unique_ptr<Derived> func_returning_unique_ptr (.....);\n-      ...\n-      unique_ptr<Base> ptr = func_returning_unique_ptr (.....);\n-  */\n-  template<typename T1, typename D1>\n-  unique_ptr_base (const unique_ptr_base<T1, D1> &other) throw ()\n-    : m_ptr (const_cast<unique_ptr_base<T1, D1> &> (other).release ()) {}\n-\n-  /* The \"move\" assignment operator.  Really an lvalue ref copy\n-     assignment operator that actually moves.  See comments above.  */\n-  unique_ptr_base &operator= (const unique_ptr_base &other) throw ()\n-  {\n-    reset (const_cast<unique_ptr_base &> (other).release ());\n-    return *this;\n-  }\n-\n-  /* Converting \"move\" assignment.  Really an lvalue ref converting\n-     copy assignment operator that moves.  See comments above.  */\n-  template<typename T1, typename D1>\n-  unique_ptr_base &operator= (const unique_ptr_base<T1, D1> &other) throw ()\n-  {\n-    reset (const_cast<unique_ptr_base<T1, D1> &> (other).release ());\n-    return *this;\n-  }\n-\n-  /* std::unique_ptr does not allow assignment, except from nullptr.\n-     nullptr doesn't exist in C++03, so we allow assignment from NULL\n-     instead [ptr = NULL;].\n-  */\n-  unique_ptr_base &operator= (detail::nullptr_t *) throw ()\n-  {\n-    reset ();\n-    return *this;\n-  }\n-\n-  ~unique_ptr_base () { call_deleter (); }\n-\n-  /* \"explicit operator bool ()\" emulation using the safe bool\n-     idiom.  */\n-private:\n-  typedef void (unique_ptr_base::*explicit_operator_bool) () const;\n-  void this_type_does_not_support_comparisons () const {}\n-\n-public:\n-  operator explicit_operator_bool () const\n-  {\n-    return (m_ptr != NULL\n-\t    ? &unique_ptr_base::this_type_does_not_support_comparisons\n-\t    : 0);\n-  }\n-\n-  element_type *get () const throw () { return m_ptr; }\n-\n-  element_type *release () throw ()\n-  {\n-    pointer tmp = m_ptr;\n-    m_ptr = NULL;\n-    return tmp;\n-  }\n-\n-  void reset (element_type *p = NULL) throw ()\n-  {\n-    if (p != m_ptr)\n-      {\n-\tcall_deleter ();\n-\tm_ptr = p;\n-      }\n-  }\n-\n-private:\n-\n-  /* Call the deleter.  Note we assume the deleter is \"stateless\".  */\n-  void call_deleter ()\n-  {\n-    D d;\n-\n-    d (m_ptr);\n-  }\n-\n-  element_type *m_ptr;\n-};\n-\n-} /* namespace detail */\n-\n-/* Macro used to create a unique_ptr_base \"partial specialization\" --\n-   a subclass that uses a specific deleter.  Basically this re-defines\n-   the necessary constructors.  This is necessary because C++03\n-   doesn't support inheriting constructors with \"using\".  While at it,\n-   we inherit the assignment operator.  TYPE is the name of the type\n-   being defined.  Assumes that 'base_type' is a typedef of the\n-   baseclass TYPE is inheriting from.  */\n-#define DEFINE_GNU_UNIQUE_PTR(TYPE)\t\t\t\t\t\t\\\n-public:\t\t\t\t\t\t\t\t\t\\\n-  explicit TYPE (T *p = NULL) throw ()\t\t\t\t\t\\\n-    : base_type (p) {}\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  TYPE (const TYPE &other) throw () : base_type (other) {}\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  TYPE (detail::nullptr_t *) throw () : base_type (NULL) {}\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  template<typename T1, typename D1>\t\t\t\t\t\\\n-  TYPE (const detail::unique_ptr_base<T1, D1> &other) throw ()\t\t\\\n-    : base_type (other) {}\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  using base_type::operator=;\n-\n-/* Define single-object gnu::unique_ptr.  */\n-\n-template <typename T, typename D = default_delete<T> >\n-class unique_ptr : public detail::unique_ptr_base<T, D>\n-{\n-  typedef detail::unique_ptr_base<T, D> base_type;\n-\n-  DEFINE_GNU_UNIQUE_PTR (unique_ptr)\n-\n-public:\n-  /* Dereferencing.  */\n-  T &operator* () const throw () { return *this->get (); }\n-  T *operator-> () const throw () { return this->get (); }\n-};\n-\n-/* Define gnu::unique_ptr specialization for T[].  */\n-\n-template <typename T, typename D>\n-class unique_ptr<T[], D> : public detail::unique_ptr_base<T, D>\n-{\n-  typedef detail::unique_ptr_base<T, D> base_type;\n-\n-  DEFINE_GNU_UNIQUE_PTR (unique_ptr)\n-\n-public:\n-  /* Indexing operator.  */\n-  T &operator[] (size_t i) const { return this->get ()[i]; }\n-};\n-\n-/* Comparison operators.  */\n-\n-template <typename T, typename D,\n-\t  typename U, typename E>\n-inline bool\n-operator== (const detail::unique_ptr_base<T, D> &x,\n-\t    const detail::unique_ptr_base<U, E> &y)\n-{ return x.get() == y.get(); }\n-\n-template <typename T, typename D,\n-\t  typename U, typename E>\n-inline bool\n-operator!= (const detail::unique_ptr_base<T, D> &x,\n-\t    const detail::unique_ptr_base<U, E> &y)\n-{ return x.get() != y.get(); }\n-\n-template<typename T, typename D,\n-\t typename U, typename E>\n-inline bool\n-operator< (const detail::unique_ptr_base<T, D> &x,\n-\t   const detail::unique_ptr_base<U, E> &y)\n-{ return x.get() < y.get (); }\n-\n-template<typename T, typename D,\n-\t typename U, typename E>\n-inline bool\n-operator<= (const detail::unique_ptr_base<T, D> &x,\n-\t    const detail::unique_ptr_base<U, E> &y)\n-{ return !(y < x); }\n-\n-template<typename T, typename D,\n-\t typename U, typename E>\n-inline bool\n-operator> (const detail::unique_ptr_base<T, D> &x,\n-\t   const detail::unique_ptr_base<U, E> &y)\n-{ return y < x; }\n-\n-template<typename T, typename D,\n-\t typename U, typename E>\n-inline bool\n-operator>= (const detail::unique_ptr_base<T, D> &x,\n-\t    const detail::unique_ptr_base<U, E> &y)\n-{ return !(x < y); }\n-\n-/* std::move \"emulation\".  This is as simple as it can be -- no\n-   attempt is made to emulate rvalue references.  This relies on T\n-   having move semantics like std::auto_ptr.\n-   I.e., copy/assignment actually moves.  */\n-\n-template<typename T>\n-const T&\n-move (T& v)\n-{\n-  return v;\n-}\n-\n-#endif /* C++11 */\n-\n-/* Define gnu::unique_xmalloc_ptr, a gnu::unique_ptr that manages\n-   xmalloc'ed memory.  */\n-\n-/* The deleter for gnu::unique_xmalloc_ptr.  Uses free.  */\n-template <typename T>\n-struct xmalloc_deleter\n-{\n-  void operator() (T *ptr) const { free (ptr); }\n-};\n-\n-/* Same, for arrays.  */\n-template <typename T>\n-struct xmalloc_deleter<T[]>\n-{\n-  void operator() (T *ptr) const { free (ptr); }\n-};\n-\n-#if __cplusplus >= 201103\n-\n-/* In C++11, we just import the standard unique_ptr to our namespace\n-   with a custom deleter.  */\n-\n-template<typename T> using unique_xmalloc_ptr\n-  = std::unique_ptr<T, xmalloc_deleter<T>>;\n-\n-#else /* C++11 */\n-\n-/* In C++03, we don't have template aliases, so we need to define a\n-   subclass instead, and re-define the constructors, because C++03\n-   doesn't support inheriting constructors either.  */\n-\n-template <typename T>\n-class unique_xmalloc_ptr : public unique_ptr<T, xmalloc_deleter<T> >\n-{\n-  typedef unique_ptr<T, xmalloc_deleter<T> > base_type;\n-\n-  DEFINE_GNU_UNIQUE_PTR (unique_xmalloc_ptr)\n-};\n-\n-/* Define gnu::unique_xmalloc_ptr specialization for T[].  */\n-\n-template <typename T>\n-class unique_xmalloc_ptr<T[]> : public unique_ptr<T[], xmalloc_deleter<T[]> >\n-{\n-  typedef unique_ptr<T[], xmalloc_deleter<T[]> > base_type;\n-\n-  DEFINE_GNU_UNIQUE_PTR (unique_xmalloc_ptr)\n-};\n-\n-#endif /* C++11 */\n-\n-} /* namespace gnu */\n-\n-#endif /* GNU_UNIQUE_PTR_H */"}]}