{"sha": "10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTAyNTZjYmU5NWNjYzQzMmZlOWYxYWFiM2M5Y2NkNTQ1ZGM3ODJlZg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-04-05T22:18:03Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-04-05T22:18:03Z"}, "message": "PR fortran/25829 28655\n\n2008-04-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/25829 28655\n\t* gfortran.map: Add new symbol, _gfortran_st_wait.\n\t* libgfortran.h (st_paramter_common): Add new I/O parameters.\n\t* open.c (st_option decimal_opt[], st_option encoding_opt[],\n\tst_option round_opt[], st_option sign_opt[], st_option async_opt[]): New\n\tparameter option arrays. (edit_modes): Add checks for new parameters.\n\t(new_unit): Likewise. (st_open): Likewise.\n\t* list_read.c (CASE_SEPERATORS): Add ';' as a valid separator.\n\t(eat_separator): Handle deimal comma. (read_logical): Fix whitespace.\n\t(parse_real): Handle decimal comma. (read_real): Handle decimal comma.\n\t* read.c (read_a): Use decimal status flag to allow comma in place of a\n\tdecimal point. (read_f): Allow comma as acceptable character in float.\n\tAccording to decimal flag, substitute a period for a comma.\n\t(read_x): If decimal status flag is comma, disable the read_comma flag,\n\tnot allowing comma as a delimiter, an extension otherwise.\n\t* io.h: (unit_decimal, unit_encoding, unit_round, unit_sign,\n\tunit_async): New enumerators. Add all new I/O parameters.\n\t* unix.c (unix_stream, int_stream): Add io_mode\tasychronous I/O\tcontrol.\n\t(move_pos_offset, fd_alloc_w_at): Fix some whitespace.\n\t(fd_sfree): Use new enumerator. (fd_read): Likewise.\n\t(fd_write): Likewise. (fd_close): Fix whitespace.\n\t(fd_open): Use new enumertors. (tempfile, regular_file,\n\topen_external): Fix whitespace. (output_stream, error_stream): Set\n\tmethod. (stream_offset): Fix whitespace.\n\t* transfer.c: (st_option decimal_opt[], sign_opt[], blank_opt[]): New\n\toption arrays. \t(formatted_transfer_scalar): Set sf_read_comma flag\n\tbased on new decimal_status flag. (data_transfer_init): Initialize new\n\tparameters. Add checks for decimal, sign, and blank. (st_wait): New stub.\n\t* format.c: (format_lex): Add format specifiers DP, DC, and D.\n\t(parse_format_list): Parse the new specifiers.\n\t* write.c (write_decimal): Use new sign enumerators to set the sign.\n\t(write_complex): Handle decimal comma and semi-colon separator.\n\t(nml_write_obj): Likewise.\n\t* write_float.def: Revise sign enumerators. (calculate_sign): Use new\n\tsign enumerators. (output_float): Likewise. Use new decimal_status flag\n\tto set the decimal character to a point or a comma.\n\nFrom-SVN: r133943", "tree": {"sha": "f9485223018be46b0b89c551ebd74b08c80fa0cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9485223018be46b0b89c551ebd74b08c80fa0cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/comments", "author": null, "committer": null, "parents": [{"sha": "3d3e20df3616f7999bd607306b378a4861cd8b77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d3e20df3616f7999bd607306b378a4861cd8b77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d3e20df3616f7999bd607306b378a4861cd8b77"}], "stats": {"total": 624, "additions": 519, "deletions": 105}, "files": [{"sha": "7c1a3b1e2ca96051418d5dddb90ee348ff7dc6df", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "patch": "@@ -1,3 +1,42 @@\n+2008-04-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/25829 28655\n+\t* gfortran.map: Add new symbol, _gfortran_st_wait.\n+\t* libgfortran.h (st_paramter_common): Add new I/O parameters.\n+\t* open.c (st_option decimal_opt[], st_option encoding_opt[],\n+\tst_option round_opt[], st_option sign_opt[], st_option async_opt[]): New\n+\tparameter option arrays. (edit_modes): Add checks for new parameters.\n+\t(new_unit): Likewise. (st_open): Likewise.\n+\t* list_read.c (CASE_SEPERATORS): Add ';' as a valid separator.\n+\t(eat_separator): Handle deimal comma. (read_logical): Fix whitespace.\n+\t(parse_real): Handle decimal comma. (read_real): Handle decimal comma.\n+\t* read.c (read_a): Use decimal status flag to allow comma in place of a\n+\tdecimal point. (read_f): Allow comma as acceptable character in float.\n+\tAccording to decimal flag, substitute a period for a comma.\n+\t(read_x): If decimal status flag is comma, disable the read_comma flag,\n+\tnot allowing comma as a delimiter, an extension otherwise.\n+\t* io.h: (unit_decimal, unit_encoding, unit_round, unit_sign,\n+\tunit_async): New enumerators. Add all new I/O parameters.\n+\t* unix.c (unix_stream, int_stream): Add io_mode\tasychronous I/O\tcontrol.\n+\t(move_pos_offset, fd_alloc_w_at): Fix some whitespace.\n+\t(fd_sfree): Use new enumerator. (fd_read): Likewise.\n+\t(fd_write): Likewise. (fd_close): Fix whitespace.\n+\t(fd_open): Use new enumertors. (tempfile, regular_file,\n+\topen_external): Fix whitespace. (output_stream, error_stream): Set\n+\tmethod. (stream_offset): Fix whitespace.\n+\t* transfer.c: (st_option decimal_opt[], sign_opt[], blank_opt[]): New\n+\toption arrays. \t(formatted_transfer_scalar): Set sf_read_comma flag\n+\tbased on new decimal_status flag. (data_transfer_init): Initialize new\n+\tparameters. Add checks for decimal, sign, and blank. (st_wait): New stub.\n+\t* format.c: (format_lex): Add format specifiers DP, DC, and D.\n+\t(parse_format_list): Parse the new specifiers.\n+\t* write.c (write_decimal): Use new sign enumerators to set the sign.\n+\t(write_complex): Handle decimal comma and semi-colon separator.\n+\t(nml_write_obj): Likewise.\n+\t* write_float.def: Revise sign enumerators. (calculate_sign): Use new\n+\tsign enumerators. (output_float): Likewise. Use new decimal_status flag\n+\tto set the decimal character to a point or a comma.\n+\t\n 2008-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR libfortran/32972"}, {"sha": "2d0537246e370ff7449ef8a5edf14a845bcc717e", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "patch": "@@ -1037,6 +1037,7 @@ GFORTRAN_1.1 {\n     _gfortran_erfc_scaled_r8;\n     _gfortran_erfc_scaled_r10;\n     _gfortran_erfc_scaled_r16;\n+    _gfortran_st_wait;\n } GFORTRAN_1.0; \n \n F2C_1.0 {"}, {"sha": "734b633de0667a4ec4c5aaac3412d7ebd16d50ab", "filename": "libgfortran/io/format.c", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Fformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Fformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fformat.c?ref=10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "patch": "@@ -1,6 +1,7 @@\n-/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n+   F2003 I/O support contributed by Jerry DeLisle\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n \n@@ -395,7 +396,6 @@ format_lex (format_data *fmt)\n \t  unget_char (fmt);\n \t  break;\n \t}\n-\n       break;\n \n     case 'G':\n@@ -415,7 +415,19 @@ format_lex (format_data *fmt)\n       break;\n \n     case 'D':\n-      token = FMT_D;\n+      switch (next_char (fmt, 0))\n+\t{\n+\tcase 'P':\n+\t  token = FMT_DP;\n+\t  break;\n+\tcase 'C':\n+\t  token = FMT_DC;\n+\t  break;\n+\tdefault:\n+\t  token = FMT_D;\n+\t  unget_char (fmt);\n+\t  break;\n+\t}\n       break;\n \n     case -1:\n@@ -550,6 +562,11 @@ parse_format_list (st_parameter_dt *dtp)\n       tail->repeat = 1;\n       goto optional_comma;\n \n+    case FMT_DC:\n+    case FMT_DP:\n+      notify_std (&dtp->common, GFC_STD_F2003, \"Fortran 2003: DC or DP \"\n+\t\t  \"descriptor not allowed\");\n+    /* Fall through.  */\n     case FMT_S:\n     case FMT_SS:\n     case FMT_SP:\n@@ -576,6 +593,7 @@ parse_format_list (st_parameter_dt *dtp)\n       notify_std (&dtp->common, GFC_STD_GNU, \"Extension: $ descriptor\");\n       goto between_desc;\n \n+\n     case FMT_T:\n     case FMT_TL:\n     case FMT_TR:"}, {"sha": "ddbd632a64bb75284c44f69cd923d8c7be42f009", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 92, "deletions": 4, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "patch": "@@ -1,6 +1,7 @@\n-/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n+   F2003 I/O support contributed by Jerry DeLisle\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n \n@@ -44,7 +45,6 @@ typedef enum\n }\n bt;\n \n-\n struct st_parameter_dt;\n \n typedef struct stream\n@@ -61,6 +61,9 @@ typedef struct stream\n }\n stream;\n \n+typedef enum\n+{ SYNC_BUFFERED, SYNC_UNBUFFERED, ASYNC }\n+io_mode;\n \n /* Macros for doing file I/O given a stream.  */\n \n@@ -204,6 +207,25 @@ typedef enum\n { PAD_YES, PAD_NO, PAD_UNSPECIFIED }\n unit_pad;\n \n+typedef enum\n+{ DECIMAL_POINT, DECIMAL_COMMA, DECIMAL_UNSPECIFIED }\n+unit_decimal;\n+\n+typedef enum\n+{ ENCODING_UTF8, ENCODING_DEFAULT, ENCODING_UNSPECIFIED }\n+unit_encoding;\n+\n+typedef enum\n+{ ROUND_UP, ROUND_DOWN, ROUND_ZERO, ROUND_NEAREST, ROUND_COMPATIBLE,\n+  ROUND_PROCDEFINED, ROUND_UNSPECIFIED }\n+unit_round;\n+\n+/* NOTE: unit_sign must correspond with the sign_status enumerator in\n+   st_parameter_dt to not break the ABI.  */\n+typedef enum\n+{ SIGN_PROCDEFINED, SIGN_SUPPRESS, SIGN_PLUS, SIGN_UNSPECIFIED }\n+unit_sign;\n+\n typedef enum\n { ADVANCE_YES, ADVANCE_NO, ADVANCE_UNSPECIFIED }\n unit_advance;\n@@ -212,6 +234,10 @@ typedef enum\n {READING, WRITING}\n unit_mode;\n \n+typedef enum\n+{ ASYNC_YES, ASYNC_NO, AYSYNC_UNSPECIFIED }\n+unit_async;\n+\n #define CHARACTER1(name) \\\n \t      char * name; \\\n \t      gfc_charlen_type name ## _len\n@@ -233,6 +259,11 @@ typedef struct\n   CHARACTER1 (delim);\n   CHARACTER2 (pad);\n   CHARACTER1 (convert);\n+  CHARACTER2 (decimal);\n+  CHARACTER1 (encoding);\n+  CHARACTER2 (round);\n+  CHARACTER1 (sign);\n+  CHARACTER2 (asynchronous);\n }\n st_parameter_open;\n \n@@ -275,6 +306,16 @@ st_parameter_filepos;\n #define IOPARM_INQUIRE_HAS_WRITE\t(1 << 28)\n #define IOPARM_INQUIRE_HAS_READWRITE\t(1 << 29)\n #define IOPARM_INQUIRE_HAS_CONVERT\t(1 << 30)\n+#define IOPARM_INQUIRE_HAS_FLAGS2\t(1 << 31)\n+\n+#define IOPARM_INQUIRE_HAS_ASYNCHRONOUS\t(1 << 0)\n+#define IOPARM_INQUIRE_HAS_DECIMAL\t(1 << 1)\n+#define IOPARM_INQUIRE_HAS_ENCODING\t(1 << 2)\n+#define IOPARM_INQUIRE_HAS_PENDING\t(1 << 3)\n+#define IOPARM_INQUIRE_HAS_ROUND\t(1 << 4)\n+#define IOPARM_INQUIRE_HAS_SIGN\t\t(1 << 5)\n+#define IOPARM_INQUIRE_HAS_SIZE\t\t(1 << 6)\n+#define IOPARM_INQUIRE_HAS_ID\t\t(1 << 7)\n \n typedef struct\n {\n@@ -299,6 +340,15 @@ typedef struct\n   CHARACTER1 (write);\n   CHARACTER2 (readwrite);\n   CHARACTER1 (convert);\n+  GFC_INTEGER_4 flags2;\n+  CHARACTER1 (asynchronous);\n+  CHARACTER1 (decimal);\n+  CHARACTER1 (encoding);\n+  CHARACTER1 (pending);\n+  CHARACTER1 (round);\n+  CHARACTER1 (sign);\n+  GFC_INTEGER_4 *size;\n+  GFC_IO_INT id;\n }\n st_parameter_inquire;\n \n@@ -314,6 +364,15 @@ struct format_data;\n #define IOPARM_DT_HAS_ADVANCE\t\t\t(1 << 13)\n #define IOPARM_DT_HAS_INTERNAL_UNIT\t\t(1 << 14)\n #define IOPARM_DT_HAS_NAMELIST_NAME\t\t(1 << 15)\n+#define IOPARM_DT_HAS_ID\t\t\t(1 << 16)\n+#define IOPARM_DT_HAS_POS\t\t\t(1 << 17)\n+#define IOPARM_DT_HAS_ASYNCHRONOUS\t\t(1 << 18)\n+#define IOPARM_DT_HAS_BLANK\t\t\t(1 << 19)\n+#define IOPARM_DT_HAS_DECIMAL\t\t\t(1 << 20)\n+#define IOPARM_DT_HAS_DELIM\t\t\t(1 << 21)\n+#define IOPARM_DT_HAS_PAD\t\t\t(1 << 22)\n+#define IOPARM_DT_HAS_ROUND\t\t\t(1 << 23)\n+#define IOPARM_DT_HAS_SIGN\t\t\t(1 << 24)\n /* Internal use bit.  */\n #define IOPARM_DT_IONML_SET\t\t\t(1 << 31)\n \n@@ -327,6 +386,15 @@ typedef struct st_parameter_dt\n   CHARACTER2 (advance);\n   CHARACTER1 (internal_unit);\n   CHARACTER2 (namelist_name);\n+  GFC_IO_INT *id;\n+  GFC_IO_INT pos;\n+  CHARACTER1 (asynchronous);\n+  CHARACTER2 (blank);\n+  CHARACTER1 (decimal);\n+  CHARACTER2 (delim);\n+  CHARACTER1 (pad);\n+  CHARACTER2 (round);\n+  CHARACTER1 (sign);\n   /* Private part of the structure.  The compiler just needs\n      to reserve enough space.  */\n   union\n@@ -341,7 +409,7 @@ typedef struct st_parameter_dt\n \t  int item_count;\n \t  unit_mode mode;\n \t  unit_blank blank_status;\n-\t  enum {SIGN_S, SIGN_SS, SIGN_SP} sign_status;\n+\t  enum { SIGN_S, SIGN_SS, SIGN_SP } sign_status;\n \t  int scale_factor;\n \t  int max_pos; /* Maximum righthand column written to.  */\n \t  /* Number of skips + spaces to be done for T and X-editing.  */\n@@ -354,6 +422,7 @@ typedef struct st_parameter_dt\n \t       2 if an EOR was encountered due to a 2-bytes marker (CRLF) */\n \t  int sf_seen_eor;\n \t  unit_advance advance_status;\n+\t  unit_decimal decimal_status;\n \n \t  unsigned reversion_flag : 1; /* Format reversion has occurred.  */\n \t  unsigned first_item : 1;\n@@ -422,6 +491,16 @@ extern char check_st_parameter_dt[sizeof (((st_parameter_dt *) 0)->u.pad)\n \t\t\t\t  >= sizeof (((st_parameter_dt *) 0)->u.p)\n \t\t\t\t  ? 1 : -1];\n \n+#define IOPARM_WAIT_HAS_ID\t\t(1 << 7)\n+\n+typedef struct\n+{\n+  st_parameter_common common;\n+  CHARACTER1 (id);\n+}\n+st_parameter_wait;\n+\n+\n #undef CHARACTER1\n #undef CHARACTER2\n \n@@ -436,8 +515,13 @@ typedef struct\n   unit_position position;\n   unit_status status;\n   unit_pad pad;\n+  unit_decimal decimal;\n+  unit_encoding encoding;\n+  unit_round round;\n+  unit_sign sign;\n   unit_convert convert;\n   int has_recl;\n+  unit_async async;\n }\n unit_flags;\n \n@@ -504,7 +588,8 @@ typedef enum\n   FMT_COMMA, FMT_COLON, FMT_SLASH, FMT_DOLLAR, FMT_T, FMT_TR, FMT_TL,\n   FMT_LPAREN, FMT_RPAREN, FMT_X, FMT_S, FMT_SS, FMT_SP, FMT_STRING,\n   FMT_BADSTRING, FMT_P, FMT_I, FMT_B, FMT_BN, FMT_BZ, FMT_O, FMT_Z, FMT_F,\n-  FMT_E, FMT_EN, FMT_ES, FMT_G, FMT_L, FMT_A, FMT_D, FMT_H, FMT_END\n+  FMT_E, FMT_EN, FMT_ES, FMT_G, FMT_L, FMT_A, FMT_D, FMT_H, FMT_END, FMT_DC,\n+  FMT_DP\n }\n format_token;\n \n@@ -748,6 +833,9 @@ internal_proto(next_record);\n extern void reverse_memcpy (void *, const void *, size_t);\n internal_proto (reverse_memcpy);\n \n+extern void st_wait (st_parameter_wait *);\n+export_proto(st_wait);\n+\n /* read.c */\n \n extern void set_integer (void *, GFC_INTEGER_LARGEST, int);"}, {"sha": "ae2eb354d3f4743eaff215fefd44c71baae53fd0", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "patch": "@@ -1,6 +1,8 @@\n-/* Copyright (C) 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    Namelist input contributed by Paul Thomas\n+   F2003 I/O support contributed by Jerry DeLisle\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n \n@@ -52,12 +54,12 @@ Boston, MA 02110-1301, USA.  */\n                       case '5': case '6': case '7': case '8': case '9'\n \n #define CASE_SEPARATORS  case ' ': case ',': case '/': case '\\n': case '\\t': \\\n-                         case '\\r'\n+                         case '\\r': case ';'\n \n /* This macro assumes that we're operating on a variable.  */\n \n #define is_separator(c) (c == '/' ||  c == ',' || c == '\\n' || c == ' ' \\\n-                         || c == '\\t' || c == '\\r')\n+                         || c == '\\t' || c == '\\r' || c == ';')\n \n /* Maximum repeat count.  Less than ten times the maximum signed int32.  */\n \n@@ -323,6 +325,13 @@ eat_separator (st_parameter_dt *dtp)\n   switch (c)\n     {\n     case ',':\n+      if (dtp->u.p.decimal_status == DECIMAL_COMMA)\n+\t{\n+\t  unget_char (dtp, c);\n+\t  break;\n+\t}\n+      /* Fall through.  */\n+    case ';':\n       dtp->u.p.comma_flag = 1;\n       eat_spaces (dtp);\n       break;\n@@ -666,6 +675,7 @@ read_logical (st_parameter_dt *dtp, int length)\n \n       unget_char (dtp, c);\n       break;\n+\n     case '.':\n       c = tolower (next_char (dtp));\n       switch (c)\n@@ -1115,6 +1125,9 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n       c = next_char (dtp);\n     }\n \n+  if (c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+    c = '.';\n+  \n   if (!isdigit (c) && c != '.')\n     {\n       if (c == 'i' || c == 'I' || c == 'n' || c == 'N')\n@@ -1130,6 +1143,8 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n   for (;;)\n     {\n       c = next_char (dtp);\n+      if (c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+\tc = '.';\n       switch (c)\n \t{\n \tCASE_DIGITS:\n@@ -1299,7 +1314,8 @@ read_complex (st_parameter_dt *dtp, int kind, size_t size)\n   else\n     unget_char (dtp, c);\n \n-  if (next_char (dtp) != ',')\n+  if (next_char (dtp)\n+      !=  (dtp->u.p.decimal_status == DECIMAL_POINT ? ',' : ';'))\n     goto bad_complex;\n \n eol_2:\n@@ -1353,6 +1369,8 @@ read_real (st_parameter_dt *dtp, int length)\n   seen_dp = 0;\n \n   c = next_char (dtp);\n+  if (c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+    c = '.';\n   switch (c)\n     {\n     CASE_DIGITS:\n@@ -1388,15 +1406,17 @@ read_real (st_parameter_dt *dtp, int length)\n   for (;;)\n     {\n       c = next_char (dtp);\n+      if (c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+\tc = '.';\n       switch (c)\n \t{\n \tCASE_DIGITS:\n \t  push_char (dtp, c);\n \t  break;\n \n \tcase '.':\n-          if (seen_dp)\n-            goto bad_real;\n+\t  if (seen_dp)\n+\t    goto bad_real;\n \n \t  seen_dp = 1;\n \t  push_char (dtp, c);\n@@ -1420,7 +1440,7 @@ read_real (st_parameter_dt *dtp, int length)\n \t  goto got_repeat;\n \n \tCASE_SEPARATORS:\n-          if (c != '\\n' &&  c != ',' && c != '\\r')\n+          if (c != '\\n' && c != ',' && c != '\\r' && c != ';')\n \t    unget_char (dtp, c);\n \t  goto done;\n \n@@ -1452,6 +1472,9 @@ read_real (st_parameter_dt *dtp, int length)\n       c = next_char (dtp);\n     }\n \n+  if (c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+    c = '.';\n+\n   if (!isdigit (c) && c != '.')\n     {\n       if (c == 'i' || c == 'I' || c == 'n' || c == 'N')\n@@ -1474,6 +1497,8 @@ read_real (st_parameter_dt *dtp, int length)\n   for (;;)\n     {\n       c = next_char (dtp);\n+      if (c == ',' && dtp->u.p.decimal_status == DECIMAL_COMMA)\n+\tc = '.';\n       switch (c)\n \t{\n \tCASE_DIGITS:"}, {"sha": "5259684e8bf39de791bc5fd24dd0d76a4be6fb3e", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 141, "deletions": 1, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "patch": "@@ -1,6 +1,7 @@\n-/* Copyright (C) 2002, 2003, 2004, 2005, 2007\n+/* Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n+   F2003 I/O support contributed by Jerry DeLisle\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n \n@@ -97,6 +98,39 @@ static const st_option pad_opt[] =\n   { NULL, 0}\n };\n \n+static const st_option decimal_opt[] =\n+{\n+  { \"point\", DECIMAL_POINT},\n+  { \"comma\", DECIMAL_COMMA},\n+  { NULL, 0}\n+};\n+\n+static const st_option encoding_opt[] =\n+{\n+  { \"utf-8\", ENCODING_UTF8},\n+  { \"default\", ENCODING_DEFAULT},\n+  { NULL, 0}\n+};\n+\n+static const st_option round_opt[] =\n+{\n+  { \"up\", ROUND_UP},\n+  { \"down\", ROUND_DOWN},\n+  { \"zero\", ROUND_ZERO},\n+  { \"nearest\", ROUND_NEAREST},\n+  { \"compatible\", ROUND_COMPATIBLE},\n+  { \"processor_defined\", ROUND_PROCDEFINED},\n+  { NULL, 0}\n+};\n+\n+static const st_option sign_opt[] =\n+{\n+  { \"plus\", SIGN_PLUS},\n+  { \"suppress\", SIGN_SUPPRESS},\n+  { \"processor_defined\", SIGN_PROCDEFINED},\n+  { NULL, 0}\n+};\n+\n static const st_option convert_opt[] =\n {\n   { \"native\", GFC_CONVERT_NATIVE},\n@@ -106,6 +140,12 @@ static const st_option convert_opt[] =\n   { NULL, 0}\n };\n \n+static const st_option async_opt[] =\n+{\n+  { \"yes\", ASYNC_YES},\n+  { \"no\", ASYNC_NO},\n+  { NULL, 0}\n+};\n \n /* Given a unit, test to see if the file is positioned at the terminal\n    point, and if so, change state from NO_ENDFILE flag to AT_ENDFILE.\n@@ -179,6 +219,26 @@ edit_modes (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)\n \tgenerate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n \t\t\t\"PAD parameter conflicts with UNFORMATTED form in \"\n \t\t\t\"OPEN statement\");\n+\n+      if (flags->decimal != DECIMAL_UNSPECIFIED)\n+\tgenerate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n+\t\t\t\"DECIMAL parameter conflicts with UNFORMATTED form in \"\n+\t\t\t\"OPEN statement\");\n+\n+      if (flags->encoding != ENCODING_UNSPECIFIED)\n+\tgenerate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n+\t\t\t\"ENCODING parameter conflicts with UNFORMATTED form in \"\n+\t\t\t\"OPEN statement\");\n+\n+      if (flags->round != ROUND_UNSPECIFIED)\n+\tgenerate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n+\t\t\t\"ROUND parameter conflicts with UNFORMATTED form in \"\n+\t\t\t\"OPEN statement\");\n+\n+      if (flags->sign != SIGN_UNSPECIFIED)\n+\tgenerate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n+\t\t\t\"SIGN parameter conflicts with UNFORMATTED form in \"\n+\t\t\t\"OPEN statement\");\n     }\n \n   if ((opp->common.flags & IOPARM_LIBRETURN_MASK) == IOPARM_LIBRETURN_OK)\n@@ -190,6 +250,14 @@ edit_modes (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)\n \tu->flags.delim = flags->delim;\n       if (flags->pad != PAD_UNSPECIFIED)\n \tu->flags.pad = flags->pad;\n+      if (flags->decimal != DECIMAL_UNSPECIFIED)\n+\tu->flags.decimal = flags->decimal;\n+      if (flags->encoding != ENCODING_UNSPECIFIED)\n+\tu->flags.encoding = flags->encoding;\n+      if (flags->round != ROUND_UNSPECIFIED)\n+\tu->flags.round = flags->round;\n+      if (flags->sign != SIGN_UNSPECIFIED)\n+\tu->flags.sign = flags->sign;\n     }\n \n   /* Reposition the file if necessary.  */\n@@ -289,6 +357,62 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n \t}\n     }\n \n+  if (flags->decimal == DECIMAL_UNSPECIFIED)\n+    flags->decimal = DECIMAL_POINT;\n+  else\n+    {\n+      if (flags->form == FORM_UNFORMATTED)\n+\t{\n+\t  generate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n+\t\t\t  \"DECIMAL parameter conflicts with UNFORMATTED form \"\n+\t\t\t  \"in OPEN statement\");\n+\t  goto fail;\n+\t}\n+    }\n+\n+  if (flags->encoding == ENCODING_UNSPECIFIED)\n+    flags->encoding = ENCODING_DEFAULT;\n+  else\n+    {\n+      if (flags->form == FORM_UNFORMATTED)\n+\t{\n+\t  generate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n+\t\t\t  \"ENCODING parameter conflicts with UNFORMATTED form in \"\n+\t\t\t  \"OPEN statement\");\n+\t  goto fail;\n+\t}\n+    }\n+\n+  /* NB: the value for ROUND when it's not specified by the user does not\n+         have to be PROCESSOR_DEFINED; the standard says that it is\n+\t processor dependent, and requires that it is one of the\n+\t possible value (see F2003, 9.4.5.13).  */\n+  if (flags->round == ROUND_UNSPECIFIED)\n+    flags->round = ROUND_PROCDEFINED;\n+  else\n+    {\n+      if (flags->form == FORM_UNFORMATTED)\n+\t{\n+\t  generate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n+\t\t\t  \"ROUND parameter conflicts with UNFORMATTED form in \"\n+\t\t\t  \"OPEN statement\");\n+\t  goto fail;\n+\t}\n+    }\n+\n+  if (flags->sign == SIGN_UNSPECIFIED)\n+    flags->sign = SIGN_PROCDEFINED;\n+  else\n+    {\n+      if (flags->form == FORM_UNFORMATTED)\n+\t{\n+\t  generate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n+\t\t\t  \"SIGN parameter conflicts with UNFORMATTED form in \"\n+\t\t\t  \"OPEN statement\");\n+\t  goto fail;\n+\t}\n+    }\n+\n   if (flags->position != POSITION_ASIS && flags->access == ACCESS_DIRECT)\n    {\n      generate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n@@ -607,6 +731,22 @@ st_open (st_parameter_open *opp)\n     find_option (&opp->common, opp->pad, opp->pad_len,\n \t\t pad_opt, \"Bad PAD parameter in OPEN statement\");\n \n+  flags.decimal = !(cf & IOPARM_OPEN_HAS_DECIMAL) ? DECIMAL_UNSPECIFIED :\n+    find_option (&opp->common, opp->decimal, opp->decimal_len,\n+\t\t decimal_opt, \"Bad DECIMAL parameter in OPEN statement\");\n+\n+  flags.encoding = !(cf & IOPARM_OPEN_HAS_ENCODING) ? ENCODING_UNSPECIFIED :\n+    find_option (&opp->common, opp->encoding, opp->encoding_len,\n+\t\t encoding_opt, \"Bad ENCODING parameter in OPEN statement\");\n+\n+  flags.round = !(cf & IOPARM_OPEN_HAS_ROUND) ? ROUND_UNSPECIFIED :\n+    find_option (&opp->common, opp->round, opp->round_len,\n+\t\t round_opt, \"Bad ROUND parameter in OPEN statement\");\n+\n+  flags.sign = !(cf & IOPARM_OPEN_HAS_SIGN) ? SIGN_UNSPECIFIED :\n+    find_option (&opp->common, opp->sign, opp->sign_len,\n+\t\t sign_opt, \"Bad SIGN parameter in OPEN statement\");\n+\n   flags.form = !(cf & IOPARM_OPEN_HAS_FORM) ? FORM_UNSPECIFIED :\n     find_option (&opp->common, opp->form, opp->form_len,\n \t\t form_opt, \"Bad FORM parameter in OPEN statement\");"}, {"sha": "bba377234417536ce0598e2e3db88b24e115fc89", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "patch": "@@ -1,5 +1,6 @@\n-/* Copyright (C) 2002, 2003, 2005, 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2005, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n+   F2003 I/O support contributed by Jerry DeLisle\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n \n@@ -246,7 +247,8 @@ read_a (st_parameter_dt *dtp, const fnode *f, char *p, int length)\n \n   dtp->u.p.sf_read_comma = 0;\n   source = read_block (dtp, &w);\n-  dtp->u.p.sf_read_comma = 1;\n+  dtp->u.p.sf_read_comma =\n+    dtp->u.p.decimal_status == DECIMAL_COMMA ? 0 : 1;\n   if (source == NULL)\n     return;\n   if (w > length)\n@@ -601,7 +603,7 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n   /* A digit, a '.' or a exponent character ('e', 'E', 'd' or 'D')\n      is required at this point */\n \n-  if (!isdigit (*p) && *p != '.' && *p != 'd' && *p != 'D'\n+  if (!isdigit (*p) && *p != '.' && *p != ',' && *p != 'd' && *p != 'D'\n       && *p != 'e' && *p != 'E')\n     goto bad_float;\n \n@@ -614,6 +616,10 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n     {\n       switch (*p)\n \t{\n+\tcase ',':\n+\t  if (dtp->u.p.decimal_status == DECIMAL_COMMA && *p == ',')\n+\t    *p = '.';\n+\t  /* Fall through */\n \tcase '.':\n \t  if (seen_dp)\n \t    goto bad_float;"}, {"sha": "56e93f2a9570675acff84655be54b3a08389114d", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 84, "deletions": 17, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "patch": "@@ -1,7 +1,8 @@\n-/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    Namelist transfer functions contributed by Paul Thomas\n+   F2003 I/O support contributed by Jerry DeLisle\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n \n@@ -93,6 +94,26 @@ static const st_option advance_opt[] = {\n };\n \n \n+static const st_option decimal_opt[] = {\n+  {\"point\", DECIMAL_POINT},\n+  {\"comma\", DECIMAL_COMMA},\n+  {NULL, 0}\n+};\n+\n+\n+static const st_option sign_opt[] = {\n+  {\"plus\", SIGN_SP},\n+  {\"suppress\", SIGN_SS},\n+  {\"processor_defined\", SIGN_S},\n+  {NULL, 0}\n+};\n+\n+static const st_option blank_opt[] = {\n+  {\"null\", BLANK_NULL},\n+  {\"zero\", BLANK_ZERO},\n+  {NULL, 0}\n+};\n+\n typedef enum\n { FORMATTED_SEQUENTIAL, UNFORMATTED_SEQUENTIAL,\n   FORMATTED_DIRECT, UNFORMATTED_DIRECT, FORMATTED_STREAM, UNFORMATTED_STREAM\n@@ -910,7 +931,7 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n   /* Set this flag so that commas in reads cause the read to complete before\n      the entire field has been read.  The next read field will start right after\n      the comma in the stream.  (Set to 0 for character reads).  */\n-  dtp->u.p.sf_read_comma = 1;\n+  dtp->u.p.sf_read_comma = dtp->u.p.decimal_status == DECIMAL_COMMA ? 0 : 1;\n   dtp->u.p.line_buffer = scratch;\n \n   for (;;)\n@@ -923,7 +944,7 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t  next_record (dtp, 0);\n \t}\n \n-      consume_data_flag = 1 ;\n+      consume_data_flag = 1;\n       if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n \tbreak;\n \n@@ -1162,7 +1183,7 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t  break;\n \n \tcase FMT_STRING:\n-\t  consume_data_flag = 0 ;\n+\t  consume_data_flag = 0;\n \t  if (dtp->u.p.mode == READING)\n \t    {\n \t      format_error (dtp, f, \"Constant string in input format\");\n@@ -1278,17 +1299,17 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t  break;\n \n \tcase FMT_S:\n-\t  consume_data_flag = 0 ;\n+\t  consume_data_flag = 0;\n \t  dtp->u.p.sign_status = SIGN_S;\n \t  break;\n \n \tcase FMT_SS:\n-\t  consume_data_flag = 0 ;\n+\t  consume_data_flag = 0;\n \t  dtp->u.p.sign_status = SIGN_SS;\n \t  break;\n \n \tcase FMT_SP:\n-\t  consume_data_flag = 0 ;\n+\t  consume_data_flag = 0;\n \t  dtp->u.p.sign_status = SIGN_SP;\n \t  break;\n \n@@ -1298,22 +1319,32 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t  break;\n \n \tcase FMT_BZ:\n-\t  consume_data_flag = 0 ;\n+\t  consume_data_flag = 0;\n \t  dtp->u.p.blank_status = BLANK_ZERO;\n \t  break;\n \n+\tcase FMT_DC:\n+\t  consume_data_flag = 0;\n+\t  dtp->u.p.decimal_status = DECIMAL_COMMA;\n+\t  break;\n+\n+\tcase FMT_DP:\n+\t  consume_data_flag = 0;\n+\t  dtp->u.p.decimal_status = DECIMAL_POINT;\n+\t  break;\n+\n \tcase FMT_P:\n-\t  consume_data_flag = 0 ;\n+\t  consume_data_flag = 0;\n \t  dtp->u.p.scale_factor = f->u.k;\n \t  break;\n \n \tcase FMT_DOLLAR:\n-\t  consume_data_flag = 0 ;\n+\t  consume_data_flag = 0;\n \t  dtp->u.p.seen_dollar = 1;\n \t  break;\n \n \tcase FMT_SLASH:\n-\t  consume_data_flag = 0 ;\n+\t  consume_data_flag = 0;\n \t  dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n \t  next_record (dtp, 0);\n \t  break;\n@@ -1323,7 +1354,7 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t     particular preventing another / descriptor from being\n \t     processed) unless there is another data item to be\n \t     transferred.  */\n-\t  consume_data_flag = 0 ;\n+\t  consume_data_flag = 0;\n \t  if (n == 0)\n \t    return;\n \t  break;\n@@ -1769,6 +1800,10 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n      u_flags.delim = DELIM_UNSPECIFIED;\n      u_flags.blank = BLANK_UNSPECIFIED;\n      u_flags.pad = PAD_UNSPECIFIED;\n+     u_flags.decimal = DECIMAL_UNSPECIFIED;\n+     u_flags.encoding = ENCODING_UNSPECIFIED;\n+     u_flags.round = ROUND_UNSPECIFIED;\n+     u_flags.sign = SIGN_UNSPECIFIED;\n      u_flags.status = STATUS_UNKNOWN;\n \n      conv = get_unformatted_convert (dtp->common.unit);\n@@ -1958,6 +1993,35 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n   if (dtp->u.p.advance_status == ADVANCE_UNSPECIFIED)\n     dtp->u.p.advance_status = ADVANCE_YES;\n \n+  /* Check the decimal mode.  */\n+\n+  dtp->u.p.decimal_status\n+    = !(cf & IOPARM_DT_HAS_DECIMAL) ? DECIMAL_UNSPECIFIED :\n+      find_option (&dtp->common, dtp->decimal, dtp->decimal_len, decimal_opt,\n+\t\t   \"Bad DECIMAL parameter in data transfer statement\");\n+\n+  if (dtp->u.p.decimal_status == DECIMAL_UNSPECIFIED)\n+    dtp->u.p.decimal_status = dtp->u.p.current_unit->flags.decimal;\n+\n+  /* Check the sign mode. */\n+  dtp->u.p.sign_status\n+    = !(cf & IOPARM_DT_HAS_SIGN) ? SIGN_UNSPECIFIED :\n+      find_option (&dtp->common, dtp->sign, dtp->sign_len, sign_opt,\n+\t\t   \"Bad SIGN parameter in data transfer statement\");\n+  \n+  if (dtp->u.p.sign_status == SIGN_UNSPECIFIED)\n+    dtp->u.p.sign_status = dtp->u.p.current_unit->flags.sign;\n+\n+  /* Check the blank mode.  */\n+  dtp->u.p.blank_status\n+    = !(cf & IOPARM_DT_HAS_BLANK) ? BLANK_UNSPECIFIED :\n+      find_option (&dtp->common, dtp->blank, dtp->blank_len, blank_opt,\n+\t\t   \"Bad BLANK parameter in data transfer statement\");\n+  \n+  if (dtp->u.p.blank_status == BLANK_UNSPECIFIED)\n+    dtp->u.p.blank_status = dtp->u.p.current_unit->flags.blank;\n+ \n+\n   /* Sanity checks on the record number.  */\n   if ((cf & IOPARM_DT_HAS_REC) != 0)\n     {\n@@ -2023,11 +2087,6 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \n   dtp->u.p.current_unit->mode = dtp->u.p.mode;\n \n-  /* Set the initial value of flags.  */\n-\n-  dtp->u.p.blank_status = dtp->u.p.current_unit->flags.blank;\n-  dtp->u.p.sign_status = SIGN_S;\n-  \n   /* Set the maximum position reached from the previous I/O operation.  This\n      could be greater than zero from a previous non-advancing write.  */\n   dtp->u.p.max_pos = dtp->u.p.current_unit->saved_pos;\n@@ -2926,6 +2985,14 @@ st_write_done (st_parameter_dt *dtp)\n   library_end ();\n }\n \n+\n+/* F2003: This is a stub for the runtime portion of the WAIT statement.  */\n+void\n+st_wait (st_parameter_wait *wtp __attribute__((unused)))\n+{\n+}\n+\n+\n /* Receives the scalar information for namelist objects and stores it\n    in a linked list of namelist_info types.  */\n "}, {"sha": "f1928e6ed8a66c61cbbecfcb67cfa54fcff84968", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "patch": "@@ -1,5 +1,6 @@\n-/* Copyright (C) 2002, 2003, 2005, 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2005, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n+   F2003 I/O support contributed by Jerry DeLisle\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n \n@@ -430,6 +431,7 @@ get_internal_unit (st_parameter_dt *dtp)\n   iunit->maxrec=0;\n   iunit->current_record=0;\n   iunit->read_bad = 0;\n+  iunit->endfile = NO_ENDFILE;\n \n   /* Set flags for the internal unit.  */\n \n@@ -438,7 +440,9 @@ get_internal_unit (st_parameter_dt *dtp)\n   iunit->flags.form = FORM_FORMATTED;\n   iunit->flags.pad = PAD_YES;\n   iunit->flags.status = STATUS_UNSPECIFIED;\n-  iunit->endfile = NO_ENDFILE;\n+  iunit->flags.sign = SIGN_SUPPRESS;\n+  iunit->flags.decimal = DECIMAL_POINT;\n+  iunit->flags.encoding = ENCODING_DEFAULT;\n \n   /* Initialize the data transfer parameters.  */\n \n@@ -524,6 +528,9 @@ init_units (void)\n       u->flags.blank = BLANK_NULL;\n       u->flags.pad = PAD_YES;\n       u->flags.position = POSITION_ASIS;\n+      u->flags.sign = SIGN_SUPPRESS;\n+      u->flags.decimal = DECIMAL_POINT;\n+      u->flags.encoding = ENCODING_DEFAULT;\n \n       u->recl = options.default_recl;\n       u->endfile = NO_ENDFILE;\n@@ -547,6 +554,9 @@ init_units (void)\n       u->flags.status = STATUS_OLD;\n       u->flags.blank = BLANK_NULL;\n       u->flags.position = POSITION_ASIS;\n+      u->flags.sign = SIGN_SUPPRESS;\n+      u->flags.decimal = DECIMAL_POINT;\n+      u->flags.encoding = ENCODING_DEFAULT;\n \n       u->recl = options.default_recl;\n       u->endfile = AT_ENDFILE;\n@@ -570,6 +580,9 @@ init_units (void)\n       u->flags.status = STATUS_OLD;\n       u->flags.blank = BLANK_NULL;\n       u->flags.position = POSITION_ASIS;\n+      u->flags.sign = SIGN_SUPPRESS;\n+      u->flags.decimal = DECIMAL_POINT;\n+      u->flags.encoding = ENCODING_DEFAULT;\n \n       u->recl = options.default_recl;\n       u->endfile = AT_ENDFILE;"}, {"sha": "3896f04db61c1fb32accb4e230c3ad8e5420cf78", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "patch": "@@ -1,6 +1,7 @@\n-/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n+   F2003 I/O support contributed by Jerry DeLisle\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n \n@@ -93,8 +94,6 @@ id_from_fd (const int fd)\n \n #endif\n \n-\n-\n #ifndef SSIZE_MAX\n #define SSIZE_MAX SHRT_MAX\n #endif\n@@ -153,7 +152,7 @@ typedef struct\n \n   int special_file;\t\t/* =1 if the fd refers to a special file */\n \n-  int unbuffered;               /* =1 if the stream is not buffered */\n+  io_mode method;\t\t/* Method of stream I/O being used */\n \n   char *buffer;\n   char small_buffer[BUFFER_SIZE];\n@@ -184,7 +183,7 @@ typedef struct\n \n   int special_file;\t\t/* =1 if the fd refers to a special file */\n \n-  int unbuffered;               /* =1 if the stream is not buffered */\n+  io_mode method;\t\t/* Method of stream I/O being used */\n \n   char *buffer;\n }\n@@ -238,15 +237,15 @@ move_pos_offset (stream* st, int pos_off)\n       str->logical_offset += pos_off;\n \n       if (str->dirty_offset + str->ndirty > str->logical_offset)\n-        {\n-          if (str->ndirty + pos_off > 0)\n-            str->ndirty += pos_off;\n-          else\n-            {\n-              str->dirty_offset +=  pos_off + pos_off;\n-              str->ndirty = 0;\n-            }\n-        }\n+\t{\n+\t  if (str->ndirty + pos_off > 0)\n+\t    str->ndirty += pos_off;\n+\t  else\n+\t    {\n+\t      str->dirty_offset +=  pos_off + pos_off;\n+\t      str->ndirty = 0;\n+\t    }\n+\t}\n \n     return pos_off;\n   }\n@@ -615,23 +614,23 @@ fd_alloc_w_at (unix_stream * s, int *len, gfc_offset where)\n       || where > s->dirty_offset + s->ndirty    \n       || s->dirty_offset > where + *len)\n     {  /* Discontiguous blocks, start with a clean buffer.  */  \n-        /* Flush the buffer.  */  \n-       if (s->ndirty != 0)    \n-         fd_flush (s);  \n-       s->dirty_offset = where;  \n-       s->ndirty = *len;\n+\t/* Flush the buffer.  */  \n+      if (s->ndirty != 0)    \n+\tfd_flush (s);  \n+      s->dirty_offset = where;  \n+      s->ndirty = *len;\n     }\n   else\n     {  \n       gfc_offset start;  /* Merge with the existing data.  */  \n       if (where < s->dirty_offset)    \n-        start = where;  \n+\tstart = where;  \n       else    \n-        start = s->dirty_offset;  \n+\tstart = s->dirty_offset;  \n       if (where + *len > s->dirty_offset + s->ndirty)    \n-        s->ndirty = where + *len - start;  \n+\ts->ndirty = where + *len - start;  \n       else    \n-        s->ndirty = s->dirty_offset + s->ndirty - start;  \n+\ts->ndirty = s->dirty_offset + s->ndirty - start;  \n       s->dirty_offset = start;\n     }\n \n@@ -655,7 +654,7 @@ fd_sfree (unix_stream * s)\n {\n   if (s->ndirty != 0 &&\n       (s->buffer != s->small_buffer || options.all_unbuffered ||\n-       s->unbuffered))\n+       s->method == SYNC_UNBUFFERED))\n     return fd_flush (s);\n \n   return SUCCESS;\n@@ -777,7 +776,7 @@ fd_read (unix_stream * s, void * buf, size_t * nbytes)\n   void *p;\n   int tmp, status;\n \n-  if (*nbytes < BUFFER_SIZE && !s->unbuffered)\n+  if (*nbytes < BUFFER_SIZE && s->method == SYNC_BUFFERED)\n     {\n       tmp = *nbytes;\n       p = fd_alloc_r_at (s, &tmp, -1);\n@@ -825,7 +824,7 @@ fd_write (unix_stream * s, const void * buf, size_t * nbytes)\n   void *p;\n   int tmp, status;\n \n-  if (*nbytes < BUFFER_SIZE && !s->unbuffered)\n+  if (*nbytes < BUFFER_SIZE && s->method == SYNC_BUFFERED)\n     {\n       tmp = *nbytes;\n       p = fd_alloc_w_at (s, &tmp, -1);\n@@ -874,7 +873,7 @@ fd_close (unix_stream * s)\n   if (s->fd != STDOUT_FILENO && s->fd != STDERR_FILENO && s->fd != STDIN_FILENO)\n     {\n       if (close (s->fd) < 0)\n-        return FAILURE;\n+\treturn FAILURE;\n     }\n \n   free_mem (s);\n@@ -887,7 +886,9 @@ static void\n fd_open (unix_stream * s)\n {\n   if (isatty (s->fd))\n-    s->unbuffered = 1;\n+    s->method = SYNC_UNBUFFERED;\n+  else\n+    s->method = SYNC_BUFFERED;\n \n   s->st.alloc_r_at = (void *) fd_alloc_r_at;\n   s->st.alloc_w_at = (void *) fd_alloc_w_at;\n@@ -1224,7 +1225,7 @@ tempfile (st_parameter_open *opp)\n     do\n #if defined(HAVE_CRLF) && defined(O_BINARY)\n       fd = open (template, O_RDWR | O_CREAT | O_EXCL | O_BINARY,\n-                 S_IREAD | S_IWRITE);\n+\t\t S_IREAD | S_IWRITE);\n #else\n       fd = open (template, O_RDWR | O_CREAT | O_EXCL, S_IREAD | S_IWRITE);\n #endif\n@@ -1335,21 +1336,21 @@ regular_file (st_parameter_open *opp, unit_flags *flags)\n   if (fd >=0)\n     {\n       flags->action = ACTION_READ;\n-      return fd;               /* success */\n+      return fd;\t\t/* success */\n     }\n   \n   if (errno != EACCES)\n-    return fd;                 /* failure */\n+    return fd;\t\t\t/* failure */\n \n   /* retry for write-only access */\n   rwflag = O_WRONLY;\n   fd = open (path, rwflag | crflag, mode);\n   if (fd >=0)\n     {\n       flags->action = ACTION_WRITE;\n-      return fd;               /* success */\n+      return fd;\t\t/* success */\n     }\n-  return fd;                   /* failure */\n+  return fd;\t\t\t/* failure */\n }\n \n \n@@ -1366,7 +1367,7 @@ open_external (st_parameter_open *opp, unit_flags *flags)\n     {\n       fd = tempfile (opp);\n       if (flags->action == ACTION_UNSPECIFIED)\n-        flags->action = ACTION_READWRITE;\n+\tflags->action = ACTION_READWRITE;\n \n #if HAVE_UNLINK_OPEN_FILE\n       /* We can unlink scratch files now and it will go away when closed. */\n@@ -1431,7 +1432,7 @@ output_stream (void)\n \n   s = fd_to_stream (STDOUT_FILENO, PROT_WRITE);\n   if (options.unbuffered_preconnected)\n-    ((unix_stream *) s)->unbuffered = 1;\n+    ((unix_stream *) s)->method = SYNC_UNBUFFERED;\n   return s;\n }\n \n@@ -1450,7 +1451,7 @@ error_stream (void)\n \n   s = fd_to_stream (STDERR_FILENO, PROT_WRITE);\n   if (options.unbuffered_preconnected)\n-    ((unix_stream *) s)->unbuffered = 1;\n+    ((unix_stream *) s)->method = SYNC_UNBUFFERED;\n   return s;\n }\n \n@@ -2050,13 +2051,13 @@ stream_offset (stream *s)\n       the solution used by f2c.  Each record contains a pair of length\n       markers:\n \n-        Length of record n in bytes\n-        Data of record n\n-        Length of record n in bytes\n+\tLength of record n in bytes\n+\tData of record n\n+\tLength of record n in bytes\n \n-        Length of record n+1 in bytes\n-        Data of record n+1\n-        Length of record n+1 in bytes\n+\tLength of record n+1 in bytes\n+\tData of record n+1\n+\tLength of record n+1 in bytes\n \n      The length is stored at the end of a record to allow backspacing to the\n      previous record.  Between data transfer statements, the file pointer"}, {"sha": "be3c0d7980946a8b089a58e357b221f0f17dc55d", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "patch": "@@ -1,6 +1,8 @@\n-/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    Namelist output contributed by Paul Thomas\n+   F2003 I/O support contributed by Jerry DeLisle\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n \n@@ -361,7 +363,7 @@ write_decimal (st_parameter_dt *dtp, const fnode *f, const char *source,\n   if (n < 0)\n     n = -n;\n \n-  nsign = sign == SIGN_NONE ? 0 : 1;\n+  nsign = sign == S_NONE ? 0 : 1;\n   q = conv (n, itoa_buf, sizeof (itoa_buf));\n \n   digits = strlen (q);\n@@ -395,13 +397,13 @@ write_decimal (st_parameter_dt *dtp, const fnode *f, const char *source,\n \n   switch (sign)\n     {\n-    case SIGN_PLUS:\n+    case S_PLUS:\n       *p++ = '+';\n       break;\n-    case SIGN_MINUS:\n+    case S_MINUS:\n       *p++ = '-';\n       break;\n-    case SIGN_NONE:\n+    case S_NONE:\n       break;\n     }\n \n@@ -729,11 +731,13 @@ write_real (st_parameter_dt *dtp, const char *source, int length)\n static void\n write_complex (st_parameter_dt *dtp, const char *source, int kind, size_t size)\n {\n+  char semi_comma = dtp->u.p.decimal_status == DECIMAL_POINT ? ',' : ';';\n+\n   if (write_char (dtp, '('))\n     return;\n   write_real (dtp, source, kind);\n \n-  if (write_char (dtp, ','))\n+  if (write_char (dtp, semi_comma))\n     return;\n   write_real (dtp, source + size / 2, kind);\n \n@@ -869,6 +873,11 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n   size_t base_var_name_len;\n   size_t tot_len;\n   unit_delim tmp_delim;\n+  \n+  /* Set the character to be used to separate values\n+     to a comma or semi-colon.  */\n+\n+  char semi_comma = dtp->u.p.decimal_status == DECIMAL_POINT ? ',' : ';';\n \n   /* Write namelist variable names in upper case. If a derived type,\n      nothing is output.  If a component, base and base_name are set.  */\n@@ -1075,12 +1084,12 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \t      internal_error (&dtp->common, \"Bad type for namelist write\");\n             }\n \n-\t  /* Reset the leading blank suppression, write a comma and, if 5\n-\t     values have been output, write a newline and advance to column\n-\t     2. Reset the repeat counter.  */\n+\t  /* Reset the leading blank suppression, write a comma (or semi-colon)\n+\t     and, if 5 values have been output, write a newline and advance\n+\t     to column 2. Reset the repeat counter.  */\n \n \t  dtp->u.p.no_leading_blank = 0;\n-\t  write_character (dtp, \",\", 1);\n+\t  write_character (dtp, &semi_comma, 1);\n \t  if (num > 5)\n \t    {\n \t      num = 0;"}, {"sha": "090bd712eb411855d2e14732638d3742f06e32d3", "filename": "libgfortran/io/write_float.def", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Fwrite_float.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Fio%2Fwrite_float.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite_float.def?ref=10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "patch": "@@ -1,6 +1,7 @@\n-/* Copyright (C) 2007 Free Software Foundation, Inc.\n+/* Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    Write float code factoring to this file by Jerry DeLisle   \n+   F2003 I/O support contributed by Jerry DeLisle\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n \n@@ -31,7 +32,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"config.h\"\n \n typedef enum\n-{ SIGN_NONE, SIGN_MINUS, SIGN_PLUS }\n+{ S_NONE, S_MINUS, S_PLUS }\n sign_t;\n \n /* Given a flag that indicates if a value is negative or not, return a\n@@ -40,21 +41,21 @@ sign_t;\n static sign_t\n calculate_sign (st_parameter_dt *dtp, int negative_flag)\n {\n-  sign_t s = SIGN_NONE;\n+  sign_t s = S_NONE;\n \n   if (negative_flag)\n-    s = SIGN_MINUS;\n+    s = S_MINUS;\n   else\n     switch (dtp->u.p.sign_status)\n       {\n-      case SIGN_SP:\n-\ts = SIGN_PLUS;\n+      case SIGN_SP:\t/* Show sign. */\n+\ts = S_PLUS;\n \tbreak;\n-      case SIGN_SS:\n-\ts = SIGN_NONE;\n+      case SIGN_SS:\t/* Suppress sign. */\n+\ts = S_NONE;\n \tbreak;\n-      case SIGN_S:\n-\ts = options.optional_plus ? SIGN_PLUS : SIGN_NONE;\n+      case SIGN_S:\t/* Processor defined. */\n+\ts = options.optional_plus ? S_PLUS : S_NONE;\n \tbreak;\n       }\n \n@@ -336,7 +337,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n \n   /* Pick a field size if none was specified.  */\n   if (w <= 0)\n-    w = nbefore + nzero + nafter + (sign != SIGN_NONE ? 2 : 1);\n+    w = nbefore + nzero + nafter + (sign != S_NONE ? 2 : 1);\n \n   /* Create the ouput buffer.  */\n   out = write_block (dtp, w);\n@@ -362,7 +363,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n \n   /* Work out how much padding is needed.  */\n   nblanks = w - (nbefore + nzero + nafter + edigits + 1);\n-  if (sign != SIGN_NONE)\n+  if (sign != S_NONE)\n     nblanks--;\n \n   /* Check the value fits in the specified field width.  */\n@@ -390,9 +391,9 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n     }\n \n   /* Output the initial sign (if any).  */\n-  if (sign == SIGN_PLUS)\n+  if (sign == S_PLUS)\n     *(out++) = '+';\n-  else if (sign == SIGN_MINUS)\n+  else if (sign == S_MINUS)\n     *(out++) = '-';\n \n   /* Output an optional leading zero.  */\n@@ -421,7 +422,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n       out += nbefore;\n     }\n   /* Output the decimal point.  */\n-  *(out++) = '.';\n+  *(out++) = dtp->u.p.decimal_status == DECIMAL_POINT ? '.' : ',';\n \n   /* Output leading zeros after the decimal point.  */\n   if (nzero > 0)"}, {"sha": "7d329ff311fa3035e882460953d2ae82fd24f25d", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10256cbe95ccc432fe9f1aab3c9ccd545dc782ef/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=10256cbe95ccc432fe9f1aab3c9ccd545dc782ef", "patch": "@@ -1,5 +1,6 @@\n /* Common declarations for all of libgfortran.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>, and\n    Andy Vaught <andy@xena.eas.asu.edu>\n \n@@ -507,6 +508,11 @@ st_parameter_common;\n #define IOPARM_OPEN_HAS_DELIM           (1 << 15)\n #define IOPARM_OPEN_HAS_PAD             (1 << 16)\n #define IOPARM_OPEN_HAS_CONVERT         (1 << 17)\n+#define IOPARM_OPEN_HAS_DECIMAL\t\t(1 << 18)\n+#define IOPARM_OPEN_HAS_ENCODING\t(1 << 19)\n+#define IOPARM_OPEN_HAS_ROUND\t\t(1 << 20)\n+#define IOPARM_OPEN_HAS_SIGN\t\t(1 << 21)\n+#define IOPARM_OPEN_HAS_ASYNCHRONOUS\t(1 << 22)\n \n /* library start function and end macro.  These can be expanded if needed\n    in the future.  cmp is st_parameter_common *cmp  */"}]}