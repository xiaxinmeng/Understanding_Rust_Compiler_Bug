{"sha": "5175cbafd2640d15304558c02e66642aa94e34b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE3NWNiYWZkMjY0MGQxNTMwNDU1OGMwMmU2NjY0MmFhOTRlMzRiNQ==", "commit": {"author": {"name": "Sterling Augustine", "email": "saugustine@google.com", "date": "2012-06-21T18:16:05Z"}, "committer": {"name": "Sterling Augustine", "email": "sterling@gcc.gnu.org", "date": "2012-06-21T18:16:05Z"}, "message": "dwarf2out.c (is_cu_die, [...]): New functions.\n\n2012-06-21   Sterling Augustine  <saugustine@google.com>\n        Cary Coutant  <ccoutant@google.com>\n\n\t* dwarf2out.c (is_cu_die, is_namespace_die, is_class_die,\n\tadd_AT_pubnames, add_enumerator_pubname, want_pubnames): New functions.\n\t(comdat_type_struct): New field 'skeleton_die'.\n\t(breakout_comdat_types): Update it.\n\t(add_pubname): Rework logic.  Call is_class_die, is_cu_die and\n\tis_namespace_die.  Fix minor style violation.  Call want_pubnames.\n\t(add_pubname_string): Call want_pubnames.\n\t(add_pubtype): Rework logic for calculating type name.  Call\n\tis_namespace_die.  Call want_pubnames.\n\t(output_pubnames): Move conditional logic deciding when to produce the\n\tsection from dwarf2out_finish.  Use new skeleton_die field.\n\t(base_type_die): Call add_pubtype.\n\t(gen_enumeration_type_die): Unconditionally call add_pubtype.\n\t(gen_subprogram_die): Adjust calls to add_pubname.\n\t(gen_namespace_die): Call add_pubname_string.\n\t(dwarf2out_finish): Call add_AT_pubnames; Move logic on when to\n\tproduce pubnames and pubtypes sections to output_pubnames.\n\t(common.opt): New option '-gpubnames'.\n\t(invoke.texi): Document it.\n\n\nCo-Authored-By: Cary Coutant <ccoutant@google.com>\n\nFrom-SVN: r188857", "tree": {"sha": "f3fc0a68cad8595bc67a442ce431c2cec84006b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3fc0a68cad8595bc67a442ce431c2cec84006b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5175cbafd2640d15304558c02e66642aa94e34b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5175cbafd2640d15304558c02e66642aa94e34b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5175cbafd2640d15304558c02e66642aa94e34b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5175cbafd2640d15304558c02e66642aa94e34b5/comments", "author": {"login": "Sterling-Augustine", "id": 56981066, "node_id": "MDQ6VXNlcjU2OTgxMDY2", "avatar_url": "https://avatars.githubusercontent.com/u/56981066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sterling-Augustine", "html_url": "https://github.com/Sterling-Augustine", "followers_url": "https://api.github.com/users/Sterling-Augustine/followers", "following_url": "https://api.github.com/users/Sterling-Augustine/following{/other_user}", "gists_url": "https://api.github.com/users/Sterling-Augustine/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sterling-Augustine/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sterling-Augustine/subscriptions", "organizations_url": "https://api.github.com/users/Sterling-Augustine/orgs", "repos_url": "https://api.github.com/users/Sterling-Augustine/repos", "events_url": "https://api.github.com/users/Sterling-Augustine/events{/privacy}", "received_events_url": "https://api.github.com/users/Sterling-Augustine/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8ca92d04e1a0081560a6882c5e8abee899145031", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ca92d04e1a0081560a6882c5e8abee899145031", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ca92d04e1a0081560a6882c5e8abee899145031"}], "stats": {"total": 228, "additions": 165, "deletions": 63}, "files": [{"sha": "baedb0f712dc97a4c5ad1c9ae2951a669244ec29", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5175cbafd2640d15304558c02e66642aa94e34b5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5175cbafd2640d15304558c02e66642aa94e34b5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5175cbafd2640d15304558c02e66642aa94e34b5", "patch": "@@ -1,3 +1,26 @@\n+2012-06-21   Sterling Augustine  <saugustine@google.com>\n+        Cary Coutant  <ccoutant@google.com>\n+\n+\t* dwarf2out.c (is_cu_die, is_namespace_die, is_class_die,\n+\tadd_AT_pubnames, add_enumerator_pubname, want_pubnames): New functions.\n+\t(comdat_type_struct): New field 'skeleton_die'.\n+\t(breakout_comdat_types): Update it.\n+\t(add_pubname): Rework logic.  Call is_class_die, is_cu_die and\n+\tis_namespace_die.  Fix minor style violation.  Call want_pubnames.\n+\t(add_pubname_string): Call want_pubnames.\n+\t(add_pubtype): Rework logic for calculating type name.  Call\n+\tis_namespace_die.  Call want_pubnames.\n+\t(output_pubnames): Move conditional logic deciding when to produce the\n+\tsection from dwarf2out_finish.  Use new skeleton_die field.\n+\t(base_type_die): Call add_pubtype.\n+\t(gen_enumeration_type_die): Unconditionally call add_pubtype.\n+\t(gen_subprogram_die): Adjust calls to add_pubname.\n+\t(gen_namespace_die): Call add_pubname_string.\n+\t(dwarf2out_finish): Call add_AT_pubnames; Move logic on when to\n+\tproduce pubnames and pubtypes sections to output_pubnames.\n+\t(common.opt): New option '-gpubnames'.\n+\t(invoke.texi): Document it.\n+\n 2012-06-21  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* config/m32c/m32c-pragma.c: Remove unnecessary includes."}, {"sha": "ad6db6105701ea9b0069ddb1d032969e49357d77", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5175cbafd2640d15304558c02e66642aa94e34b5/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5175cbafd2640d15304558c02e66642aa94e34b5/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=5175cbafd2640d15304558c02e66642aa94e34b5", "patch": "@@ -2243,6 +2243,14 @@ ggdb\n Common JoinedOrMissing\n Generate debug information in default extended format\n \n+gno-pubnames\n+Common RejectNegative Var(debug_generate_pub_sections, 0) Init(-1)\n+Don't generate DWARF pubnames and pubtypes sections.\n+\n+gpubnames\n+Common RejectNegative Var(debug_generate_pub_sections, 1)\n+Generate DWARF pubnames and pubtypes sections.\n+\n gno-record-gcc-switches\n Common RejectNegative Var(dwarf_record_gcc_switches,0) Init(1)\n Don't record gcc command line switches in DWARF DW_AT_producer."}, {"sha": "387d6922f89f06bcca5a1104932a638b5901fc80", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5175cbafd2640d15304558c02e66642aa94e34b5/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5175cbafd2640d15304558c02e66642aa94e34b5/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=5175cbafd2640d15304558c02e66642aa94e34b5", "patch": "@@ -4795,6 +4795,10 @@ most expressive format available (DWARF 2, stabs, or the native format\n if neither of those are supported), including GDB extensions if at all\n possible.\n \n+@item -gpubnames\n+@opindex gpubnames\n+Generate dwarf .debug_pubnames and .debug_pubtypes sections.\n+\n @item -gstabs\n @opindex gstabs\n Produce debugging information in stabs format (if that is supported),"}, {"sha": "2b9971f1857a75634ada75001c447cb7065ff1ed", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 130, "deletions": 63, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5175cbafd2640d15304558c02e66642aa94e34b5/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5175cbafd2640d15304558c02e66642aa94e34b5/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=5175cbafd2640d15304558c02e66642aa94e34b5", "patch": "@@ -2538,6 +2538,7 @@ typedef struct GTY(()) comdat_type_struct\n {\n   dw_die_ref root_die;\n   dw_die_ref type_die;\n+  dw_die_ref skeleton_die;\n   char signature[DWARF_TYPE_SIGNATURE_SIZE];\n   struct comdat_type_struct *next;\n }\n@@ -3012,6 +3013,7 @@ static void output_comp_unit (dw_die_ref, int);\n static void output_comdat_type_unit (comdat_type_node *);\n static const char *dwarf2_name (tree, int);\n static void add_pubname (tree, dw_die_ref);\n+static void add_enumerator_pubname (const char *, dw_die_ref);\n static void add_pubname_string (const char *, dw_die_ref);\n static void add_pubtype (tree, dw_die_ref);\n static void output_pubnames (VEC (pubname_entry,gc) *);\n@@ -3141,6 +3143,7 @@ static dw_loc_list_ref new_loc_list (dw_loc_descr_ref, const char *,\n \t\t\t\t     const char *, const char *);\n static void output_loc_list (dw_loc_list_ref);\n static char *gen_internal_sym (const char *);\n+static bool want_pubnames (void);\n \n static void prune_unmark_dies (dw_die_ref);\n static void prune_unused_types_mark_generic_parms_dies (dw_die_ref);\n@@ -5981,6 +5984,23 @@ is_unit_die (dw_die_ref c)\n \t       || c->die_tag == DW_TAG_type_unit);\n }\n \n+/* Returns true iff C is a namespace DIE.  */\n+\n+static inline bool\n+is_namespace_die (dw_die_ref c)\n+{\n+  return c && c->die_tag == DW_TAG_namespace;\n+}\n+\n+/* Returns true iff C is a class or structure DIE.  */\n+\n+static inline bool\n+is_class_die (dw_die_ref c)\n+{\n+  return c && (c->die_tag == DW_TAG_class_type\n+               || c->die_tag == DW_TAG_structure_type);\n+}\n+\n static char *\n gen_internal_sym (const char *prefix)\n {\n@@ -6567,6 +6587,7 @@ break_out_comdat_types (dw_die_ref die)\n            declaration into the new type unit DIE, then remove this DIE\n \t   from the main CU (or replace it with a skeleton if necessary).  */\n \treplacement = remove_child_or_replace_with_skeleton (unit, c, prev);\n+\ttype_node->skeleton_die = replacement;\n \n         /* Break out nested types into their own type units.  */\n         break_out_comdat_types (c);\n@@ -8040,6 +8061,27 @@ output_comp_unit (dw_die_ref die, int output_if_empty)\n     }\n }\n \n+/* Whether to generate the DWARF accelerator tables in .debug_pubnames\n+   and .debug_pubtypes.  This is configured per-target, but can be\n+   overridden by the -gpubnames or -gno-pubnames options.  */\n+\n+static inline bool\n+want_pubnames (void)\n+{\n+  return (debug_generate_pub_sections != -1\n+\t  ? debug_generate_pub_sections\n+\t  : targetm.want_debug_pub_sections);\n+}\n+\n+/* Add the DW_AT_GNU_pubnames and DW_AT_GNU_pubtypes attributes.  */\n+\n+static void\n+add_AT_pubnames (dw_die_ref die)\n+{\n+  if (want_pubnames ())\n+    add_AT_flag (die, DW_AT_GNU_pubnames, 1);\n+}\n+\n /* Output a comdat type unit DIE and its children.  */\n \n static void\n@@ -8110,7 +8152,7 @@ dwarf2_name (tree decl, int scope)\n static void\n add_pubname_string (const char *str, dw_die_ref die)\n {\n-  if (targetm.want_debug_pub_sections)\n+  if (want_pubnames ())\n     {\n       pubname_entry e;\n \n@@ -8123,55 +8165,88 @@ add_pubname_string (const char *str, dw_die_ref die)\n static void\n add_pubname (tree decl, dw_die_ref die)\n {\n-  if (targetm.want_debug_pub_sections && TREE_PUBLIC (decl))\n+  if (!want_pubnames ())\n+    return;\n+\n+  if ((TREE_PUBLIC (decl) && !is_class_die (die->die_parent))\n+      || is_cu_die (die->die_parent) || is_namespace_die (die->die_parent))\n     {\n       const char *name = dwarf2_name (decl, 1);\n+\n       if (name)\n \tadd_pubname_string (name, die);\n     }\n }\n \n+/* Add an enumerator to the pubnames section.  */\n+\n+static void\n+add_enumerator_pubname (const char *scope_name, dw_die_ref die)\n+{\n+  pubname_entry e;\n+\n+  gcc_assert (scope_name);\n+  e.name = concat (scope_name, get_AT_string (die, DW_AT_name), NULL);\n+  e.die = die;\n+  VEC_safe_push (pubname_entry, gc, pubname_table, &e);\n+}\n+\n /* Add a new entry to .debug_pubtypes if appropriate.  */\n \n static void\n add_pubtype (tree decl, dw_die_ref die)\n {\n   pubname_entry e;\n \n-  if (!targetm.want_debug_pub_sections)\n+  if (!want_pubnames ())\n     return;\n \n-  e.name = NULL;\n   if ((TREE_PUBLIC (decl)\n-       || is_cu_die (die->die_parent))\n+       || is_cu_die (die->die_parent) || is_namespace_die (die->die_parent))\n       && (die->die_tag == DW_TAG_typedef || COMPLETE_TYPE_P (decl)))\n     {\n-      e.die = die;\n-      if (TYPE_P (decl))\n-\t{\n-\t  if (TYPE_NAME (decl))\n+      tree scope = NULL;\n+      const char *scope_name = \"\";\n+      const char *sep = is_cxx () ? \"::\" : \".\";\n+      const char *name;\n+\n+      scope = TYPE_P (decl) ? TYPE_CONTEXT (decl) : NULL;\n+      if (scope && TREE_CODE (scope) == NAMESPACE_DECL)\n \t    {\n-\t      if (TREE_CODE (TYPE_NAME (decl)) == IDENTIFIER_NODE)\n-\t\te.name = IDENTIFIER_POINTER (TYPE_NAME (decl));\n-\t      else if (TREE_CODE (TYPE_NAME (decl)) == TYPE_DECL\n-\t\t       && DECL_NAME (TYPE_NAME (decl)))\n-\t\te.name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (decl)));\n+          scope_name = lang_hooks.dwarf_name (scope, 1);\n+          if (scope_name != NULL && scope_name[0] != '\\0')\n+            scope_name = concat (scope_name, sep, NULL);\n \t      else\n-\t       e.name = xstrdup ((const char *) get_AT_string (die, DW_AT_name));\n-\t    }\n+            scope_name = \"\";\n \t}\n+\n+      if (TYPE_P (decl))\n+        name = type_tag (decl);\n       else\n-\t{\n-\t  e.name = dwarf2_name (decl, 1);\n-\t  if (e.name)\n-\t    e.name = xstrdup (e.name);\n-\t}\n+        name = lang_hooks.dwarf_name (decl, 1);\n \n       /* If we don't have a name for the type, there's no point in adding\n \t it to the table.  */\n-      if (e.name && e.name[0] != '\\0')\n+      if (name != NULL && name[0] != '\\0')\n+        {\n+          e.die = die;\n+          e.name = concat (scope_name, name, NULL);\n \tVEC_safe_push (pubname_entry, gc, pubtype_table, &e);\n     }\n+\n+      /* Although it might be more consistent to add the pubinfo for the\n+         enumerators as their dies are created, they should only be added if the\n+         enum type meets the criteria above.  So rather than re-check the parent\n+         enum type whenever an enumerator die is created, just output them all\n+         here.  This isn't protected by the name conditional because anonymous\n+         enums don't have names.  */\n+      if (die->die_tag == DW_TAG_enumeration_type)\n+        {\n+          dw_die_ref c;\n+\n+          FOR_EACH_CHILD (die, c, add_enumerator_pubname (scope_name, c));\n+        }\n+    }\n }\n \n /* Output the public names table used to speed up access to externally\n@@ -8184,6 +8259,12 @@ output_pubnames (VEC (pubname_entry, gc) * names)\n   unsigned long pubnames_length = size_of_pubnames (names);\n   pubname_ref pub;\n \n+  if (!want_pubnames () || !info_section_emitted)\n+    return;\n+  if (names == pubname_table)\n+    switch_to_section (debug_pubnames_section);\n+  else\n+    switch_to_section (debug_pubtypes_section);\n   if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n     dw2_asm_output_data (4, 0xffffffff,\n       \"Initial length escape value indicating 64-bit DWARF extension\");\n@@ -8211,8 +8292,23 @@ output_pubnames (VEC (pubname_entry, gc) * names)\n \t  || pub->die->die_offset != 0\n \t  || !flag_eliminate_unused_debug_types)\n \t{\n-\t  dw2_asm_output_data (DWARF_OFFSET_SIZE, pub->die->die_offset,\n-\t\t\t       \"DIE offset\");\n+\t  dw_offset die_offset = pub->die->die_offset;\n+\n+\t  /* If we're putting types in their own .debug_types sections,\n+\t     the .debug_pubtypes table will still point to the compile\n+\t     unit (not the type unit), so we want to use the offset of\n+\t     the skeleton DIE (if there is one).  */\n+\t  if (pub->die->comdat_type_p && names == pubtype_table)\n+\t    {\n+\t      comdat_type_node_ref type_node = pub->die->die_id.die_type_node;\n+\n+\t      if (type_node != NULL)\n+\t        die_offset = (type_node->skeleton_die != NULL\n+\t\t\t      ? type_node->skeleton_die->die_offset\n+\t\t\t      : 0);\n+\t    }\n+\n+\t  dw2_asm_output_data (DWARF_OFFSET_SIZE, die_offset, \"DIE offset\");\n \n \t  dw2_asm_output_nstring (pub->name, -1, \"external name\");\n \t}\n@@ -9097,6 +9193,7 @@ base_type_die (tree type)\n   add_AT_unsigned (base_type_result, DW_AT_byte_size,\n \t\t   int_size_in_bytes (type));\n   add_AT_unsigned (base_type_result, DW_AT_encoding, encoding);\n+  add_pubtype (type, base_type_result);\n \n   return base_type_result;\n }\n@@ -16179,7 +16276,6 @@ gen_enumeration_type_die (tree type, dw_die_ref context_die)\n   else\n     add_AT_flag (type_die, DW_AT_declaration, 1);\n \n-  if (get_AT (type_die, DW_AT_name))\n     add_pubtype (type, type_die);\n \n   return type_die;\n@@ -16843,6 +16939,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t{\n \t  subr_die = new_die (DW_TAG_subprogram, context_die, decl);\n \t  add_AT_specification (subr_die, old_die);\n+          add_pubname (decl, subr_die);\n \t  if (get_AT_file (old_die, DW_AT_decl_file) != file_index)\n \t    add_AT_file (subr_die, DW_AT_decl_file, file_index);\n \t  if (get_AT_unsigned (old_die, DW_AT_decl_line) != (unsigned) s.line)\n@@ -16857,6 +16954,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \tadd_AT_flag (subr_die, DW_AT_external, 1);\n \n       add_name_and_src_coords_attributes (subr_die, decl);\n+      add_pubname (decl, subr_die);\n       if (debug_info_level > DINFO_LEVEL_TERSE)\n \t{\n \t  add_prototyped_attribute (subr_die, TREE_TYPE (decl));\n@@ -16968,7 +17066,6 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n       }\n #endif\n \n-\t  add_pubname (decl, subr_die);\n \t}\n       else\n \t{\n@@ -16989,7 +17086,6 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t  add_ranges_by_labels (subr_die, fde->dw_fde_second_begin,\n \t\t\t\t\tfde->dw_fde_second_end,\n \t\t\t\t\t&range_list_added);\n-\t\t  add_pubname (decl, subr_die);\n \t\t  if (range_list_added)\n \t\t    add_ranges (NULL);\n \t\t}\n@@ -17011,8 +17107,6 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t\t\t fde->dw_fde_begin);\n \t\t  add_AT_lbl_id (subr_die, DW_AT_high_pc,\n \t\t\t\t fde->dw_fde_end);\n-\t\t  /* Add it.   */\n-\t\t  add_pubname (decl, subr_die);\n \n \t\t  /* Build a minimal DIE for the secondary section.  */\n \t\t  seg_die = new_die (DW_TAG_subprogram,\n@@ -17048,7 +17142,6 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t    {\n \t      add_AT_lbl_id (subr_die, DW_AT_low_pc, fde->dw_fde_begin);\n \t      add_AT_lbl_id (subr_die, DW_AT_high_pc, fde->dw_fde_end);\n-\t      add_pubname (decl, subr_die);\n \t    }\n \t}\n \n@@ -19089,6 +19182,8 @@ gen_namespace_die (tree decl, dw_die_ref context_die)\n       add_AT_die_ref (namespace_die, DW_AT_import, origin_die);\n       equate_decl_number_to_die (decl, namespace_die);\n     }\n+  /* Bypass dwarf2_name's check for DECL_NAMELESS.  */\n+  add_pubname_string (lang_hooks.dwarf_name (decl, 1), namespace_die);\n }\n \n /* Generate Dwarf debug information for a decl described by DECL.\n@@ -22364,6 +22459,8 @@ dwarf2out_finish (const char *filename)\n     }\n   htab_delete (comdat_type_table);\n \n+  add_AT_pubnames (comp_unit_die ());\n+\n   /* Output the main compilation unit if non-empty or if .debug_macinfo\n      or .debug_macro will be emitted.  */\n   output_comp_unit (comp_unit_die (), have_macinfo);\n@@ -22387,42 +22484,12 @@ dwarf2out_finish (const char *filename)\n       output_location_lists (comp_unit_die ());\n     }\n \n-  /* Output public names table if necessary.  */\n-  if (!VEC_empty (pubname_entry, pubname_table))\n-    {\n-      gcc_assert (info_section_emitted);\n-      switch_to_section (debug_pubnames_section);\n-      output_pubnames (pubname_table);\n-    }\n-\n-  /* Output public types table if necessary.  */\n+  /* Output public names and types tables if necessary.  */\n+  output_pubnames (pubname_table);\n   /* ??? Only defined by DWARF3, but emitted by Darwin for DWARF2.\n      It shouldn't hurt to emit it always, since pure DWARF2 consumers\n      simply won't look for the section.  */\n-  if (!VEC_empty (pubname_entry, pubtype_table))\n-    {\n-      bool empty = false;\n-      \n-      if (flag_eliminate_unused_debug_types)\n-\t{\n-\t  /* The pubtypes table might be emptied by pruning unused items.  */\n-\t  unsigned i;\n-\t  pubname_ref p;\n-\t  empty = true;\n-\t  FOR_EACH_VEC_ELT (pubname_entry, pubtype_table, i, p)\n-\t    if (p->die->die_offset != 0)\n-\t      {\n-\t\tempty = false;\n-\t\tbreak;\n-\t      }\n-\t}\n-      if (!empty)\n-\t{\n-\t  gcc_assert (info_section_emitted);\n-\t  switch_to_section (debug_pubtypes_section);\n-\t  output_pubnames (pubtype_table);\n-\t}\n-    }\n+  output_pubnames (pubtype_table);\n \n   /* Output the address range information if a CU (.debug_info section)\n      was emitted.  We output an empty table even if we had no functions"}]}