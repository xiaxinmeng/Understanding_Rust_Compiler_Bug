{"sha": "4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ0Y2JjMGU3MmQzYWY4Y2JiOGZjODQ4YThhZWI5MjZiMzEwNGQyNw==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2004-10-21T22:28:29Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2004-10-21T22:28:29Z"}, "message": "config.gcc: Add support for --enable-e500_double.\n\n\t* config.gcc: Add support for --enable-e500_double.\n\n\t* config/rs6000/e500-double.h: New file.\n\n\t* config/rs6000/rs6000.h: Define TARGET_E500_SINGLE and\n\tTARGET_E500_DOUBLE.\n\n\t* config/rs6000/eabi.h: Define TARGET_E500_SINGLE and\n\tTARGET_E500_DOUBLE.\n\n\t* config/rs6000/linuxspe.h: Same.\n\n\t* doc/invoke.texi (Option Summary): Document new options for\n\tmfloat-gprs.\n\t(RS/6000 and PowerPC Options): Same.\n\n\t* config/rs6000/rs6000.c (rs6000_parse_float_gprs_option): New\n\tfunction.\n\t(rs6000_override_options): Use it.  Use\n\tSUB3TARGET_OVERRIDE_OPTIONS.\n\tAdd 8548 to processor_target_table.\n\t(rs6000_legitimate_address): Handle e500 doubles.\n\t(rs6000_legitimize_address): Same.\n\t(rs6000_legitimize_reload_address): Same.\n\t(rs6000_hard_regno_nregs): Same.\n\t(spe_func_has_64bit_regs_p): Same.\n\t(emit_frame_save): Same.\n\t(gen_frame_mem_offset): Same.\n\t(rs6000_dwarf_register_span): Same.\n\t(rs6000_generate_compare): Same.\n\t(easy_fp_constant): Same.\n\t(legitimate_offset_address_p): Same.\n\n\t* config/rs6000/spe.md: (cmdfeq_gpr): New.\n\t(tstdfeq_gpr): New.\n\t(cmpdfgt_gpr): New.\n\t(tstdfgt_gpr): New.\n\t(tstdfgt_gpr): New.\n\t(cmpdflt_gpr): New.\n\t(tstdflt_gpr): New.\n\tAdd new constants.\n\nFrom-SVN: r89416", "tree": {"sha": "3b8f1b01f11e5cca14d59ffac221b3e86cf38e0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b8f1b01f11e5cca14d59ffac221b3e86cf38e0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cbf52bfab354f91e60cebcf3665a2efc88690fbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbf52bfab354f91e60cebcf3665a2efc88690fbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbf52bfab354f91e60cebcf3665a2efc88690fbe"}], "stats": {"total": 317, "additions": 280, "deletions": 37}, "files": [{"sha": "6264a63df161e51f1852ea4215f49c9147ed76c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27", "patch": "@@ -1,3 +1,47 @@\n+2004-10-21  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* config.gcc: Add support for --enable-e500_double.\n+\n+\t* config/rs6000/e500-double.h: New file.\n+\n+\t* config/rs6000/rs6000.h: Define TARGET_E500_SINGLE and\n+\tTARGET_E500_DOUBLE.\n+\n+\t* config/rs6000/eabi.h: Define TARGET_E500_SINGLE and\n+\tTARGET_E500_DOUBLE.\n+\n+\t* config/rs6000/linuxspe.h: Same.\n+\n+\t* doc/invoke.texi (Option Summary): Document new options for\n+\tmfloat-gprs.\n+\t(RS/6000 and PowerPC Options): Same.\n+\n+\t* config/rs6000/rs6000.c (rs6000_parse_float_gprs_option): New\n+\tfunction.\n+\t(rs6000_override_options): Use it.  Use\n+\tSUB3TARGET_OVERRIDE_OPTIONS.\n+\tAdd 8548 to processor_target_table.\n+\t(rs6000_legitimate_address): Handle e500 doubles.\n+\t(rs6000_legitimize_address): Same.\n+\t(rs6000_legitimize_reload_address): Same.\n+\t(rs6000_hard_regno_nregs): Same.\n+\t(spe_func_has_64bit_regs_p): Same.\n+\t(emit_frame_save): Same.\n+\t(gen_frame_mem_offset): Same.\n+\t(rs6000_dwarf_register_span): Same.\n+\t(rs6000_generate_compare): Same.\n+\t(easy_fp_constant): Same.\n+\t(legitimate_offset_address_p): Same.\n+\n+\t* config/rs6000/spe.md: (cmdfeq_gpr): New.\n+\t(tstdfeq_gpr): New.\n+\t(cmpdfgt_gpr): New.\n+\t(tstdfgt_gpr): New.\n+\t(tstdfgt_gpr): New.\n+\t(cmpdflt_gpr): New.\n+\t(tstdflt_gpr): New.\n+\tAdd new constants.\n+\n 2004-10-21  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \t* config/arc/lib1funcs.asm (___umulsidi3): Fix typo."}, {"sha": "c1820ccb8315198171dde876c03ad27dffb3cded", "filename": "gcc/config.gcc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27", "patch": "@@ -2665,6 +2665,11 @@ fi\n \t\tc_target_objs=\"${c_target_objs} rs6000-c.o\"\n \t\tcxx_target_objs=\"${cxx_target_objs} rs6000-c.o\"\n \t\ttmake_file=\"rs6000/t-rs6000 ${tmake_file}\"\n+\n+                if test x$enable_e500_double = xyes\n+                then\n+                        tm_file=\"$tm_file rs6000/e500-double.h\"\n+                fi\n \t\t;;\n \n \tsparc*-*-*)"}, {"sha": "5f0c734762e6c62de68b65a07f4ebddb889629ec", "filename": "gcc/config/rs6000/e500-double.h", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/gcc%2Fconfig%2Frs6000%2Fe500-double.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/gcc%2Fconfig%2Frs6000%2Fe500-double.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fe500-double.h?ref=4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27", "patch": "@@ -0,0 +1,25 @@\n+/* Target definitions for E500 with double precision FP.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez (aldyh@redhat.com).\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the\n+   Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.  */\n+\n+#undef  SUB3TARGET_OVERRIDE_OPTIONS\n+#define SUB3TARGET_OVERRIDE_OPTIONS \\\n+  if (rs6000_float_gprs_string == NULL) \\\n+    rs6000_float_gprs = 2;"}, {"sha": "8de75a6cee26267fb588115dc05ac0f8a78f8f8c", "filename": "gcc/config/rs6000/eabi.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/gcc%2Fconfig%2Frs6000%2Feabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/gcc%2Fconfig%2Frs6000%2Feabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabi.h?ref=4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27", "patch": "@@ -49,9 +49,13 @@\n #undef TARGET_E500\n #undef TARGET_ISEL\n #undef TARGET_FPRS\n+#undef TARGET_E500_SINGLE\n+#undef TARGET_E500_DOUBLE\n \n #define TARGET_SPE_ABI rs6000_spe_abi\n #define TARGET_SPE rs6000_spe\n #define TARGET_E500 (rs6000_cpu == PROCESSOR_PPC8540)\n #define TARGET_ISEL rs6000_isel\n-#define TARGET_FPRS (!rs6000_float_gprs)\n+#define TARGET_FPRS (rs6000_float_gprs == 0)\n+#define TARGET_E500_SINGLE (TARGET_HARD_FLOAT && rs6000_float_gprs == 1)\n+#define TARGET_E500_DOUBLE (TARGET_HARD_FLOAT && rs6000_float_gprs == 2)"}, {"sha": "f4e02ebf624eff418bd858768ce508bf73fdb3d9", "filename": "gcc/config/rs6000/linuxspe.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/gcc%2Fconfig%2Frs6000%2Flinuxspe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/gcc%2Fconfig%2Frs6000%2Flinuxspe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinuxspe.h?ref=4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27", "patch": "@@ -32,12 +32,16 @@\n #undef TARGET_E500\n #undef TARGET_ISEL\n #undef TARGET_FPRS\n+#undef TARGET_E500_SINGLE\n+#undef TARGET_E500_DOUBLE\n \n #define TARGET_SPE_ABI rs6000_spe_abi\n #define TARGET_SPE rs6000_spe\n #define TARGET_E500 (rs6000_cpu == PROCESSOR_PPC8540)\n #define TARGET_ISEL rs6000_isel\n-#define TARGET_FPRS (!rs6000_float_gprs)\n+#define TARGET_FPRS (rs6000_float_gprs == 0)\n+#define TARGET_E500_SINGLE (TARGET_HARD_FLOAT && rs6000_float_gprs == 1)\n+#define TARGET_E500_DOUBLE (TARGET_HARD_FLOAT && rs6000_float_gprs == 2)\n \n #undef  SUBSUBTARGET_OVERRIDE_OPTIONS\n #define SUBSUBTARGET_OVERRIDE_OPTIONS \\"}, {"sha": "6117bdb6b60bb9ed00fd0b8431d99ff2c8fea801", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 109, "deletions": 31, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27", "patch": "@@ -723,6 +723,7 @@ static void rs6000_parse_abi_options (void);\n static void rs6000_parse_alignment_option (void);\n static void rs6000_parse_tls_size_option (void);\n static void rs6000_parse_yes_no_option (const char *, const char *, int *);\n+static void rs6000_parse_float_gprs_option (void);\n static int first_altivec_reg_to_save (void);\n static unsigned int compute_vrsave_mask (void);\n static void compute_save_world_info(rs6000_stack_t *info_ptr);\n@@ -1119,6 +1120,8 @@ rs6000_override_options (const char *default_cpu)\n \t {\"821\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n \t {\"823\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n \t {\"8540\", PROCESSOR_PPC8540, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n+\t /* 8548 has a dummy entry for now.  */\n+\t {\"8548\", PROCESSOR_PPC8540, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n \t {\"860\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n \t {\"970\", PROCESSOR_POWER4,\n \t  POWERPC_7400_MASK | MASK_PPC_GPOPT | MASK_MFCRF | MASK_POWERPC64},\n@@ -1292,14 +1295,14 @@ rs6000_override_options (const char *default_cpu)\n   /* Handle -malign-XXXXX option.  */\n   rs6000_parse_alignment_option ();\n \n+  rs6000_parse_float_gprs_option ();\n+\n   /* Handle generic -mFOO=YES/NO options.  */\n   rs6000_parse_yes_no_option (\"vrsave\", rs6000_altivec_vrsave_string,\n \t\t\t      &rs6000_altivec_vrsave);\n   rs6000_parse_yes_no_option (\"isel\", rs6000_isel_string,\n \t\t\t      &rs6000_isel);\n   rs6000_parse_yes_no_option (\"spe\", rs6000_spe_string, &rs6000_spe);\n-  rs6000_parse_yes_no_option (\"float-gprs\", rs6000_float_gprs_string,\n-\t\t\t      &rs6000_float_gprs);\n \n   /* Handle -mtls-size option.  */\n   rs6000_parse_tls_size_option ();\n@@ -1310,6 +1313,9 @@ rs6000_override_options (const char *default_cpu)\n #ifdef SUBSUBTARGET_OVERRIDE_OPTIONS\n   SUBSUBTARGET_OVERRIDE_OPTIONS;\n #endif\n+#ifdef SUB3TARGET_OVERRIDE_OPTIONS\n+  SUB3TARGET_OVERRIDE_OPTIONS;\n+#endif\n \n   if (TARGET_E500)\n     {\n@@ -1622,6 +1628,23 @@ rs6000_parse_abi_options (void)\n     error (\"unknown ABI specified: '%s'\", rs6000_abi_string);\n }\n \n+/* Handle -mfloat-gprs= options.  */\n+static void\n+rs6000_parse_float_gprs_option (void)\n+{\n+  if (rs6000_float_gprs_string == 0)\n+    return;\n+  else if (! strcmp (rs6000_float_gprs_string, \"yes\")\n+\t   || ! strcmp (rs6000_float_gprs_string, \"single\"))\n+    rs6000_float_gprs = 1;\n+  else if (! strcmp (rs6000_float_gprs_string, \"double\"))\n+    rs6000_float_gprs = 2;\n+  else if (! strcmp (rs6000_float_gprs_string, \"no\"))\n+    rs6000_float_gprs = 0;\n+  else\n+    error (\"invalid option for -mfloat-gprs\");\n+}\n+\n /* Handle -malign-XXXXXX options.  */\n static void\n rs6000_parse_alignment_option (void)\n@@ -2163,7 +2186,7 @@ easy_fp_constant (rtx op, enum machine_mode mode)\n     return 0;\n \n   /* Consider all constants with -msoft-float to be easy.  */\n-  if ((TARGET_SOFT_FLOAT || !TARGET_FPRS)\n+  if ((TARGET_SOFT_FLOAT || TARGET_E500_SINGLE)\n       && mode != DImode)\n     return 1;\n \n@@ -2197,6 +2220,9 @@ easy_fp_constant (rtx op, enum machine_mode mode)\n       long k[2];\n       REAL_VALUE_TYPE rv;\n \n+      if (TARGET_E500_DOUBLE)\n+\treturn 0;\n+\n       REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n       REAL_VALUE_TO_TARGET_DOUBLE (rv, k);\n \n@@ -3173,6 +3199,9 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n       return SPE_CONST_OFFSET_OK (offset);\n \n     case DFmode:\n+      if (TARGET_E500_DOUBLE)\n+\treturn SPE_CONST_OFFSET_OK (offset);\n+\n     case DImode:\n       if (mode == DFmode || !TARGET_POWERPC64)\n \textra = 4;\n@@ -3325,7 +3354,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t   && GET_MODE_NUNITS (mode) == 1\n \t   && ((TARGET_HARD_FLOAT && TARGET_FPRS)\n \t       || TARGET_POWERPC64\n-\t       || (mode != DFmode && mode != TFmode))\n+\t       || ((mode != DFmode || TARGET_E500_DOUBLE) && mode != TFmode))\n \t   && (TARGET_POWERPC64 || mode != DImode)\n \t   && mode != TImode)\n     {\n@@ -3344,7 +3373,8 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       reg = force_reg (Pmode, x);\n       return reg;\n     }\n-  else if (SPE_VECTOR_MODE (mode))\n+  else if (SPE_VECTOR_MODE (mode)\n+\t   || (TARGET_E500_DOUBLE && mode == DFmode))\n     {\n       /* We accept [reg + reg] and [reg + OFFSET].  */\n \n@@ -3388,7 +3418,8 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t   && GET_CODE (x) != CONST_INT\n \t   && GET_CODE (x) != CONST_DOUBLE\n \t   && CONSTANT_P (x)\n-\t   && ((TARGET_HARD_FLOAT && TARGET_FPRS) || mode != DFmode)\n+\t   && ((TARGET_HARD_FLOAT && TARGET_FPRS)\n+\t       || (mode != DFmode || TARGET_E500_DOUBLE))\n \t   && mode != DImode\n \t   && mode != TImode)\n     {\n@@ -3735,6 +3766,7 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n       && REG_MODE_OK_FOR_BASE_P (XEXP (x, 0), mode)\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n       && !SPE_VECTOR_MODE (mode)\n+      && !(TARGET_E500_DOUBLE && mode == DFmode)\n       && !ALTIVEC_VECTOR_MODE (mode))\n     {\n       HOST_WIDE_INT val = INTVAL (XEXP (x, 1));\n@@ -3838,6 +3870,7 @@ rs6000_legitimate_address (enum machine_mode mode, rtx x, int reg_ok_strict)\n   if ((GET_CODE (x) == PRE_INC || GET_CODE (x) == PRE_DEC)\n       && !ALTIVEC_VECTOR_MODE (mode)\n       && !SPE_VECTOR_MODE (mode)\n+      && !(TARGET_E500_DOUBLE && mode == DFmode)\n       && TARGET_UPDATE\n       && legitimate_indirect_address_p (XEXP (x, 0), reg_ok_strict))\n     return 1;\n@@ -3859,7 +3892,7 @@ rs6000_legitimate_address (enum machine_mode mode, rtx x, int reg_ok_strict)\n       && mode != TFmode\n       && ((TARGET_HARD_FLOAT && TARGET_FPRS)\n \t  || TARGET_POWERPC64\n-\t  || (mode != DFmode && mode != TFmode))\n+\t  || ((mode != DFmode || TARGET_E500_DOUBLE) && mode != TFmode))\n       && (TARGET_POWERPC64 || mode != DImode)\n       && legitimate_indexed_address_p (x, reg_ok_strict))\n     return 1;\n@@ -3924,6 +3957,9 @@ rs6000_hard_regno_nregs (int regno, enum machine_mode mode)\n   if (FP_REGNO_P (regno))\n     return (GET_MODE_SIZE (mode) + UNITS_PER_FP_WORD - 1) / UNITS_PER_FP_WORD;\n \n+  if (TARGET_E500_DOUBLE && mode == DFmode)\n+    return 1;\n+\n   if (SPE_SIMD_REGNO_P (regno) && TARGET_SPE && SPE_VECTOR_MODE (mode))\n     return (GET_MODE_SIZE (mode) + UNITS_PER_SPE_WORD - 1) / UNITS_PER_SPE_WORD;\n \n@@ -10864,35 +10900,63 @@ rs6000_generate_compare (enum rtx_code code)\n       && rs6000_compare_fp_p)\n     {\n       rtx cmp, or1, or2, or_result, compare_result2;\n+      enum machine_mode op_mode = GET_MODE (rs6000_compare_op0);\n+\n+      if (op_mode == VOIDmode)\n+\top_mode = GET_MODE (rs6000_compare_op1);\n \n       /* Note: The E500 comparison instructions set the GT bit (x +\n \t 1), on success.  This explains the mess.  */\n \n       switch (code)\n \t{\n \tcase EQ: case UNEQ: case NE: case LTGT:\n-\t  cmp = flag_finite_math_only\n-\t    ? gen_tstsfeq_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t       rs6000_compare_op1)\n-\t    : gen_cmpsfeq_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t       rs6000_compare_op1);\n+\t  if (op_mode == SFmode)\n+\t    cmp = flag_finite_math_only\n+\t      ? gen_tstsfeq_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t rs6000_compare_op1)\n+\t      : gen_cmpsfeq_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t rs6000_compare_op1);\n+\t  else if (op_mode == DFmode)\n+\t    cmp = flag_finite_math_only\n+\t      ? gen_tstdfeq_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t rs6000_compare_op1)\n+\t      : gen_cmpdfeq_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t rs6000_compare_op1);\n+\t  else abort ();\n \t  break;\n \tcase GT: case GTU: case UNGT: case UNGE: case GE: case GEU:\n-\t  cmp = flag_finite_math_only\n-\t    ? gen_tstsfgt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t       rs6000_compare_op1)\n-\t    : gen_cmpsfgt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t       rs6000_compare_op1);\n+\t  if (op_mode == SFmode)\n+\t    cmp = flag_finite_math_only\n+\t      ? gen_tstsfgt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t rs6000_compare_op1)\n+\t      : gen_cmpsfgt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t rs6000_compare_op1);\n+\t  else if (op_mode == DFmode)\n+\t    cmp = flag_finite_math_only\n+\t      ? gen_tstdfgt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t rs6000_compare_op1)\n+\t      : gen_cmpdfgt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t rs6000_compare_op1);\n+\t  else abort ();\n \t  break;\n \tcase LT: case LTU: case UNLT: case UNLE: case LE: case LEU:\n-\t  cmp = flag_finite_math_only\n-\t    ? gen_tstsflt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t       rs6000_compare_op1)\n-\t    : gen_cmpsflt_gpr (compare_result, rs6000_compare_op0,\n-\t\t\t       rs6000_compare_op1);\n+\t  if (op_mode == SFmode)\n+\t    cmp = flag_finite_math_only\n+\t      ? gen_tstsflt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t rs6000_compare_op1)\n+\t      : gen_cmpsflt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t rs6000_compare_op1);\n+\t  else if (op_mode == DFmode)\n+\t    cmp = flag_finite_math_only\n+\t      ? gen_tstdflt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t rs6000_compare_op1)\n+\t      : gen_cmpdflt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t rs6000_compare_op1);\n+\t  else abort ();\n \t  break;\n-\tdefault:\n-\t  abort ();\n+        default:\n+          abort ();\n \t}\n \n       /* Synthesize LE and GE from LT/GT || EQ.  */\n@@ -10915,11 +10979,19 @@ rs6000_generate_compare (enum rtx_code code)\n \t  compare_result2 = gen_reg_rtx (CCFPmode);\n \n \t  /* Do the EQ.  */\n-\t  cmp = flag_finite_math_only\n-\t    ? gen_tstsfeq_gpr (compare_result2, rs6000_compare_op0,\n-\t\t\t       rs6000_compare_op1)\n-\t    : gen_cmpsfeq_gpr (compare_result2, rs6000_compare_op0,\n-\t\t\t       rs6000_compare_op1);\n+\t  if (op_mode == SFmode)\n+\t    cmp = flag_finite_math_only\n+\t      ? gen_tstsfeq_gpr (compare_result2, rs6000_compare_op0,\n+\t\t\t\t rs6000_compare_op1)\n+\t      : gen_cmpsfeq_gpr (compare_result2, rs6000_compare_op0,\n+\t\t\t\t rs6000_compare_op1);\n+\t  else if (op_mode == DFmode)\n+\t    cmp = flag_finite_math_only\n+\t      ? gen_tstdfeq_gpr (compare_result2, rs6000_compare_op0,\n+\t\t\t\t rs6000_compare_op1)\n+\t      : gen_cmpdfeq_gpr (compare_result2, rs6000_compare_op0,\n+\t\t\t\t rs6000_compare_op1);\n+\t  else abort ();\n \t  emit_insn (cmp);\n \n \t  or1 = gen_rtx_GT (SImode, compare_result, const0_rtx);\n@@ -13289,6 +13361,7 @@ emit_frame_save (rtx frame_reg, rtx frame_ptr, enum machine_mode mode,\n \n   /* Some cases that need register indexed addressing.  */\n   if ((TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n+      || (TARGET_E500_DOUBLE && mode == DFmode)\n       || (TARGET_SPE_ABI\n \t  && SPE_VECTOR_MODE (mode)\n \t  && !SPE_CONST_OFFSET_OK (offset)))\n@@ -13328,7 +13401,8 @@ gen_frame_mem_offset (enum machine_mode mode, rtx reg, int offset)\n \n   int_rtx = GEN_INT (offset);\n \n-  if (TARGET_SPE_ABI && SPE_VECTOR_MODE (mode))\n+  if ((TARGET_SPE_ABI && SPE_VECTOR_MODE (mode))\n+      || (TARGET_E500_DOUBLE && mode == DFmode))\n     {\n       offset_rtx = gen_rtx_REG (Pmode, FIXED_SCRATCH);\n       emit_move_insn (offset_rtx, int_rtx);\n@@ -18082,7 +18156,11 @@ rs6000_dwarf_register_span (rtx reg)\n {\n   unsigned regno;\n \n-  if (!TARGET_SPE || !SPE_VECTOR_MODE (GET_MODE (reg)))\n+  if (TARGET_SPE\n+      && (SPE_VECTOR_MODE (GET_MODE (reg))\n+\t  || (TARGET_E500_DOUBLE && GET_MODE (reg) == DFmode)))\n+    ;\n+  else\n     return NULL_RTX;\n \n   regno = REGNO (reg);"}, {"sha": "0a209b674cfa48a0f358b5aa2c0c6bdd8db14315", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27", "patch": "@@ -568,6 +568,8 @@ extern const char *rs6000_warn_altivec_long_switch;\n #define TARGET_E500 0\n #define TARGET_ISEL 0\n #define TARGET_FPRS 1\n+#define TARGET_E500_SINGLE 0\n+#define TARGET_E500_DOUBLE 0\n \n /* Sometimes certain combinations of command options do not make sense\n    on a particular target machine.  You can define a macro"}, {"sha": "6a130021a5b24338f46fdee18142cf2a4199ab18", "filename": "gcc/config/rs6000/spe.md", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/gcc%2Fconfig%2Frs6000%2Fspe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/gcc%2Fconfig%2Frs6000%2Fspe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fspe.md?ref=4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27", "patch": "@@ -21,7 +21,15 @@\n \n (define_constants\n   [(SPE_ACC_REGNO\t111)\n-   (SPEFSCR_REGNO\t112)])\n+   (SPEFSCR_REGNO\t112)\n+\n+   (CMPDFEQ_GPR\t\t1006)\n+   (TSTDFEQ_GPR\t\t1007)\n+   (CMPDFGT_GPR\t\t1008)\n+   (TSTDFGT_GPR\t\t1009)\n+   (CMPDFLT_GPR\t\t1010)\n+   (TSTDFLT_GPR\t\t1011)\n+   ])\n \n (define_insn \"*negsf2_gpr\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=r\")\n@@ -2532,3 +2540,65 @@\n   \"TARGET_HARD_FLOAT && !TARGET_FPRS && flag_unsafe_math_optimizations\"\n   \"efststlt %0,%1,%2\"\n   [(set_attr \"type\" \"veccmpsimple\")])\n+\n+;; Same thing, but for double-precision.\n+\n+(define_insn \"cmpdfeq_gpr\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n+\t(unspec:CCFP\n+\t [(compare:CCFP (match_operand:DF 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"r\"))]\n+\t CMPDFEQ_GPR))]\n+  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && !flag_unsafe_math_optimizations\"\n+  \"efdcmpeq %0,%1,%2\"\n+  [(set_attr \"type\" \"veccmp\")])\n+\n+(define_insn \"tstdfeq_gpr\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n+\t(unspec:CCFP\n+\t [(compare:CCFP (match_operand:DF 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"r\"))]\n+\t TSTDFEQ_GPR))]\n+  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && flag_unsafe_math_optimizations\"\n+  \"efdtsteq %0,%1,%2\"\n+  [(set_attr \"type\" \"veccmpsimple\")])\n+\n+(define_insn \"cmpdfgt_gpr\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n+\t(unspec:CCFP\n+\t [(compare:CCFP (match_operand:DF 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"r\"))]\n+\t CMPDFGT_GPR))]\n+  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && !flag_unsafe_math_optimizations\"\n+  \"efdcmpgt %0,%1,%2\"\n+  [(set_attr \"type\" \"veccmp\")])\n+\n+(define_insn \"tstdfgt_gpr\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n+\t(unspec:CCFP\n+\t [(compare:CCFP (match_operand:DF 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"r\"))]\n+\t TSTDFGT_GPR))]\n+  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && flag_unsafe_math_optimizations\"\n+  \"efdtstgt %0,%1,%2\"\n+  [(set_attr \"type\" \"veccmpsimple\")])\n+\n+(define_insn \"cmpdflt_gpr\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n+\t(unspec:CCFP\n+\t [(compare:CCFP (match_operand:DF 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"r\"))]\n+\t CMPDFLT_GPR))]\n+  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && !flag_unsafe_math_optimizations\"\n+  \"efdcmplt %0,%1,%2\"\n+  [(set_attr \"type\" \"veccmp\")])\n+\n+(define_insn \"tstdflt_gpr\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n+\t(unspec:CCFP\n+\t [(compare:CCFP (match_operand:DF 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t(match_operand:DF 2 \"gpc_reg_operand\" \"r\"))]\n+\t TSTDFLT_GPR))]\n+  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && flag_unsafe_math_optimizations\"\n+  \"efdtstlt %0,%1,%2\"\n+  [(set_attr \"type\" \"veccmpsimple\")])"}, {"sha": "a2b0d83df0cbbb73904f8089b6f98f7dd7c292eb", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=4d4cbc0e72d3af8cbb8fc848a8aeb926b3104d27", "patch": "@@ -616,7 +616,7 @@ See RS/6000 and PowerPC Options.\n -mabi=spe  -mabi=no-spe @gol\n -misel=yes  -misel=no @gol\n -mspe=yes  -mspe=no @gol\n--mfloat-gprs=yes  -mfloat-gprs=no @gol\n+-mfloat-gprs=yes  -mfloat-gprs=no -mfloat-gprs=single -mfloat-gprs=double @gol\n -mprototype  -mno-prototype @gol\n -msim  -mmvme  -mads  -myellowknife  -memb  -msdata @gol\n -msdata=@var{opt}  -mvxworks  -mwindiss  -G @var{num}  -pthread}\n@@ -10279,12 +10279,23 @@ This switch enables or disables the generation of ISEL instructions.\n This switch enables or disables the generation of SPE simd\n instructions.\n \n-@item -mfloat-gprs=@var{yes/no}\n+@item -mfloat-gprs=@var{yes/single/double/no}\n @itemx -mfloat-gprs\n @opindex mfloat-gprs\n This switch enables or disables the generation of floating point\n operations on the general purpose registers for architectures that\n-support it.  This option is currently only available on the MPC8540.\n+support it.\n+\n+The argument @var{yes} or @var{single} enables the use of\n+single-precision floating point operations.\n+\n+The argument @var{double} enables the use of single and\n+double-precision floating point operations.\n+\n+The argument @var{no} disables floating point operations on the\n+general purpose registers.\n+\n+This option is currently only available on the MPC854x.\n \n @item -m32\n @itemx -m64"}]}