{"sha": "f8fb2ea2b17d38518a9ef9c8774bf4adc726e508", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhmYjJlYTJiMTdkMzg1MThhOWVmOWM4Nzc0YmY0YWRjNzI2ZTUwOA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-20T13:14:47Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-22T06:51:24Z"}, "message": "add ctor/dtor to slp_tree\n\nThis adds constructor and destructor to slp_tree factoring common\ncode.  I've not changed the wrappers to overloaded CTORs since\nI hope to use object_allocator<> and am not sure whether that can\nbe done in any fancy way yet.\n\n2020-05-22  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (_slp_tree::_slp_tree): New.\n\t(_slp_tree::~_slp_tree): Likewise.\n\t* tree-vect-slp.c (_slp_tree::_slp_tree): Factor out code\n\tfrom allocators.\n\t(_slp_tree::~_slp_tree): Implement.\n\t(vect_free_slp_tree): Simplify.\n\t(vect_create_new_slp_node): Likewise.  Add nops parameter.\n\t(vect_build_slp_tree_2): Adjust.\n\t(vect_analyze_slp_instance): Likewise.", "tree": {"sha": "8719d1731f942f90809c2834efd508abc4960ac4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8719d1731f942f90809c2834efd508abc4960ac4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8fb2ea2b17d38518a9ef9c8774bf4adc726e508", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8fb2ea2b17d38518a9ef9c8774bf4adc726e508", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8fb2ea2b17d38518a9ef9c8774bf4adc726e508", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8fb2ea2b17d38518a9ef9c8774bf4adc726e508/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc7aee01cd59aeebe3b0a944d97a8f0d05d9d645", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc7aee01cd59aeebe3b0a944d97a8f0d05d9d645", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc7aee01cd59aeebe3b0a944d97a8f0d05d9d645"}], "stats": {"total": 113, "additions": 58, "deletions": 55}, "files": [{"sha": "598163590e5f5c586239d64ccfda35ce0215a291", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8fb2ea2b17d38518a9ef9c8774bf4adc726e508/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8fb2ea2b17d38518a9ef9c8774bf4adc726e508/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8fb2ea2b17d38518a9ef9c8774bf4adc726e508", "patch": "@@ -1,3 +1,15 @@\n+2020-05-22  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (_slp_tree::_slp_tree): New.\n+\t(_slp_tree::~_slp_tree): Likewise.\n+\t* tree-vect-slp.c (_slp_tree::_slp_tree): Factor out code\n+\tfrom allocators.\n+\t(_slp_tree::~_slp_tree): Implement.\n+\t(vect_free_slp_tree): Simplify.\n+\t(vect_create_new_slp_node): Likewise.  Add nops parameter.\n+\t(vect_build_slp_tree_2): Adjust.\n+\t(vect_analyze_slp_instance): Likewise.\n+\n 2020-05-21  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* adjust-alignment.c: Include memmodel.h."}, {"sha": "31ccaf58fc440d0facb02493bc2d97e224ac5577", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 43, "deletions": 55, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8fb2ea2b17d38518a9ef9c8774bf4adc726e508/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8fb2ea2b17d38518a9ef9c8774bf4adc726e508/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=f8fb2ea2b17d38518a9ef9c8774bf4adc726e508", "patch": "@@ -46,6 +46,34 @@ along with GCC; see the file COPYING3.  If not see\n #include \"internal-fn.h\"\n \n \n+/* Initialize a SLP node.  */\n+\n+_slp_tree::_slp_tree ()\n+{\n+  SLP_TREE_SCALAR_STMTS (this) = vNULL;\n+  SLP_TREE_SCALAR_OPS (this) = vNULL;\n+  SLP_TREE_VEC_STMTS (this).create (0);\n+  SLP_TREE_NUMBER_OF_VEC_STMTS (this) = 0;\n+  SLP_TREE_CHILDREN (this) = vNULL;\n+  SLP_TREE_LOAD_PERMUTATION (this) = vNULL;\n+  SLP_TREE_TWO_OPERATORS (this) = false;\n+  SLP_TREE_DEF_TYPE (this) = vect_uninitialized_def;\n+  SLP_TREE_VECTYPE (this) = NULL_TREE;\n+  this->refcnt = 1;\n+  this->max_nunits = 1;\n+}\n+\n+/* Tear down a SLP node.  */\n+\n+_slp_tree::~_slp_tree ()\n+{\n+  SLP_TREE_CHILDREN (this).release ();\n+  SLP_TREE_SCALAR_STMTS (this).release ();\n+  SLP_TREE_SCALAR_OPS (this).release ();\n+  SLP_TREE_VEC_STMTS (this).release ();\n+  SLP_TREE_LOAD_PERMUTATION (this).release ();\n+}\n+\n /* Recursively free the memory allocated for the SLP tree rooted at NODE.\n    FINAL_P is true if we have vectorized the instance or if we have\n    made a final decision not to vectorize the statements in any way.  */\n@@ -76,13 +104,7 @@ vect_free_slp_tree (slp_tree node, bool final_p)\n \t}\n     }\n \n-  SLP_TREE_CHILDREN (node).release ();\n-  SLP_TREE_SCALAR_STMTS (node).release ();\n-  SLP_TREE_SCALAR_OPS (node).release ();\n-  SLP_TREE_VEC_STMTS (node).release ();\n-  SLP_TREE_LOAD_PERMUTATION (node).release ();\n-\n-  free (node);\n+  delete node;\n }\n \n /* Free the memory allocated for the SLP instance.  FINAL_P is true if we\n@@ -101,39 +123,15 @@ vect_free_slp_instance (slp_instance instance, bool final_p)\n /* Create an SLP node for SCALAR_STMTS.  */\n \n static slp_tree\n-vect_create_new_slp_node (vec<stmt_vec_info> scalar_stmts)\n+vect_create_new_slp_node (vec<stmt_vec_info> scalar_stmts, unsigned nops)\n {\n-  slp_tree node;\n-  stmt_vec_info stmt_info = scalar_stmts[0];\n-  unsigned int nops;\n-\n-  if (gcall *stmt = dyn_cast <gcall *> (stmt_info->stmt))\n-    nops = gimple_call_num_args (stmt);\n-  else if (gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt))\n-    {\n-      nops = gimple_num_ops (stmt) - 1;\n-      if (gimple_assign_rhs_code (stmt) == COND_EXPR)\n-\tnops++;\n-    }\n-  else if (is_a <gphi *> (stmt_info->stmt))\n-    nops = 0;\n-  else\n-    return NULL;\n-\n-  node = XNEW (struct _slp_tree);\n+  slp_tree node = new _slp_tree;\n   SLP_TREE_SCALAR_STMTS (node) = scalar_stmts;\n-  SLP_TREE_SCALAR_OPS (node) = vNULL;\n-  SLP_TREE_VEC_STMTS (node).create (0);\n-  SLP_TREE_NUMBER_OF_VEC_STMTS (node) = 0;\n   SLP_TREE_CHILDREN (node).create (nops);\n-  SLP_TREE_LOAD_PERMUTATION (node) = vNULL;\n-  SLP_TREE_TWO_OPERATORS (node) = false;\n   SLP_TREE_DEF_TYPE (node) = vect_internal_def;\n-  SLP_TREE_VECTYPE (node) = NULL_TREE;\n-  node->refcnt = 1;\n-  node->max_nunits = 1;\n \n   unsigned i;\n+  stmt_vec_info stmt_info;\n   FOR_EACH_VEC_ELT (scalar_stmts, i, stmt_info)\n     STMT_VINFO_NUM_SLP_USES (stmt_info)++;\n \n@@ -145,21 +143,9 @@ vect_create_new_slp_node (vec<stmt_vec_info> scalar_stmts)\n static slp_tree\n vect_create_new_slp_node (vec<tree> ops)\n {\n-  slp_tree node;\n-\n-  node = XNEW (struct _slp_tree);\n-  SLP_TREE_SCALAR_STMTS (node) = vNULL;\n+  slp_tree node = new _slp_tree;\n   SLP_TREE_SCALAR_OPS (node) = ops;\n-  SLP_TREE_VEC_STMTS (node).create (0);\n-  SLP_TREE_NUMBER_OF_VEC_STMTS (node) = 0;\n-  SLP_TREE_CHILDREN (node) = vNULL;\n-  SLP_TREE_LOAD_PERMUTATION (node) = vNULL;\n-  SLP_TREE_TWO_OPERATORS (node) = false;\n   SLP_TREE_DEF_TYPE (node) = vect_external_def;\n-  SLP_TREE_VECTYPE (node) = NULL_TREE;\n-  node->refcnt = 1;\n-  node->max_nunits = 1;\n-\n   return node;\n }\n \n@@ -1284,7 +1270,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n       else\n \treturn NULL;\n       (*tree_size)++;\n-      node = vect_create_new_slp_node (stmts);\n+      node = vect_create_new_slp_node (stmts, 0);\n       return node;\n     }\n \n@@ -1309,7 +1295,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t{\n \t  *max_nunits = this_max_nunits;\n \t  (*tree_size)++;\n-\t  node = vect_create_new_slp_node (stmts);\n+\t  node = vect_create_new_slp_node (stmts, 0);\n \t  /* And compute the load permutation.  Whether it is actually\n \t     a permutation depends on the unrolling factor which is\n \t     decided later.  */\n@@ -1450,7 +1436,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"Building vector operands from scalars\\n\");\n \t  this_tree_size++;\n-\t  child = vect_create_new_slp_node (oprnd_info->def_stmts);\n+\t  child = vect_create_new_slp_node (oprnd_info->def_stmts, 0);\n \t  SLP_TREE_DEF_TYPE (child) = vect_external_def;\n \t  SLP_TREE_SCALAR_OPS (child) = oprnd_info->ops;\n \t  children.safe_push (child);\n@@ -1587,7 +1573,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n   *tree_size += this_tree_size + 1;\n   *max_nunits = this_max_nunits;\n \n-  node = vect_create_new_slp_node (stmts);\n+  node = vect_create_new_slp_node (stmts, nops);\n   SLP_TREE_TWO_OPERATORS (node) = two_operators;\n   SLP_TREE_CHILDREN (node).splice (children);\n   return node;\n@@ -1726,9 +1712,12 @@ slp_copy_subtree (slp_tree node, hash_map<slp_tree, slp_tree> &map)\n   if (existed_p)\n     return copy_ref;\n \n-  copy_ref = XNEW (_slp_tree);\n+  copy_ref = new _slp_tree;\n   slp_tree copy = copy_ref;\n-  memcpy (copy, node, sizeof (_slp_tree));\n+  SLP_TREE_DEF_TYPE (copy) = SLP_TREE_DEF_TYPE (node);\n+  SLP_TREE_VECTYPE (copy) = SLP_TREE_VECTYPE (node);\n+  copy->max_nunits = node->max_nunits;\n+  copy->refcnt = 0;\n   if (SLP_TREE_SCALAR_STMTS (node).exists ())\n     {\n       SLP_TREE_SCALAR_STMTS (copy) = SLP_TREE_SCALAR_STMTS (node).copy ();\n@@ -1743,7 +1732,6 @@ slp_copy_subtree (slp_tree node, hash_map<slp_tree, slp_tree> &map)\n   if (SLP_TREE_CHILDREN (node).exists ())\n     SLP_TREE_CHILDREN (copy) = SLP_TREE_CHILDREN (node).copy ();\n   gcc_assert (!SLP_TREE_VEC_STMTS (node).exists ());\n-  copy->refcnt = 0;\n \n   slp_tree child;\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (copy), i, child)\n@@ -2230,7 +2218,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t      scalar_stmts.create (group_size);\n \t      for (unsigned i = 0; i < group_size; ++i)\n \t\tscalar_stmts.quick_push (next_info);\n-\t      slp_tree conv = vect_create_new_slp_node (scalar_stmts);\n+\t      slp_tree conv = vect_create_new_slp_node (scalar_stmts, 1);\n \t      SLP_TREE_CHILDREN (conv).quick_push (node);\n \t      SLP_INSTANCE_TREE (new_instance) = conv;\n \t      /* We also have to fake this conversion stmt as SLP reduction"}, {"sha": "4f506bd5a3453b78571d3e2e35fc9f8679efb0fe", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8fb2ea2b17d38518a9ef9c8774bf4adc726e508/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8fb2ea2b17d38518a9ef9c8774bf4adc726e508/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f8fb2ea2b17d38518a9ef9c8774bf4adc726e508", "patch": "@@ -118,6 +118,9 @@ typedef struct _slp_tree *slp_tree;\n /* A computation tree of an SLP instance.  Each node corresponds to a group of\n    stmts to be packed in a SIMD stmt.  */\n struct _slp_tree {\n+  _slp_tree ();\n+  ~_slp_tree ();\n+\n   /* Nodes that contain def-stmts of this node statements operands.  */\n   vec<slp_tree> children;\n "}]}