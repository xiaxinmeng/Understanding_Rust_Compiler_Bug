{"sha": "4af3b0ea1bcc3096e21fc1687fa78a294b232454", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFmM2IwZWExYmNjMzA5NmUyMWZjMTY4N2ZhNzhhMjk0YjIzMjQ1NA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-05-13T07:04:58Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-05-13T07:04:58Z"}, "message": "Test for not existence of a negative loop (PR gcov-profile/90380).\n\n2019-05-13  Martin Liska  <mliska@suse.cz>\n\n\tPR gcov-profile/90380\n\t* gcov.c (enum loop_type): Remove the enum and\n\tthe operator.\n\t(handle_cycle): Assert that we should not reach\n\ta negative count.\n\t(circuit): Use loop_found instead of a tri-state loop_type.\n\t(get_cycles_count): Do not handle NEGATIVE_LOOP as it can't\n\thappen.\n\nFrom-SVN: r271116", "tree": {"sha": "b430fb0b735ae786397a285b75f1662479c3650f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b430fb0b735ae786397a285b75f1662479c3650f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4af3b0ea1bcc3096e21fc1687fa78a294b232454", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4af3b0ea1bcc3096e21fc1687fa78a294b232454", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4af3b0ea1bcc3096e21fc1687fa78a294b232454", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4af3b0ea1bcc3096e21fc1687fa78a294b232454/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "15f3429d31ccdf5568b1e4c300fbc4d9ca89a36a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15f3429d31ccdf5568b1e4c300fbc4d9ca89a36a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15f3429d31ccdf5568b1e4c300fbc4d9ca89a36a"}], "stats": {"total": 64, "additions": 29, "deletions": 35}, "files": [{"sha": "fa57dfdb8f104f14894b688cbddf5de688690cae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af3b0ea1bcc3096e21fc1687fa78a294b232454/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af3b0ea1bcc3096e21fc1687fa78a294b232454/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4af3b0ea1bcc3096e21fc1687fa78a294b232454", "patch": "@@ -1,3 +1,14 @@\n+2019-05-13  Martin Liska  <mliska@suse.cz>\n+\n+\tPR gcov-profile/90380\n+\t* gcov.c (enum loop_type): Remove the enum and\n+\tthe operator.\n+\t(handle_cycle): Assert that we should not reach\n+\ta negative count.\n+\t(circuit): Use loop_found instead of a tri-state loop_type.\n+\t(get_cycles_count): Do not handle NEGATIVE_LOOP as it can't\n+\thappen.\n+\n 2019-05-12  Iain Sandoe  <iain@sandoe.co.uk>\n \n \tPR target/82920"}, {"sha": "6bcd2b237489e0a15b598116efd42336b6d27d8a", "filename": "gcc/gcov.c", "status": "modified", "additions": 18, "deletions": 35, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af3b0ea1bcc3096e21fc1687fa78a294b232454/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af3b0ea1bcc3096e21fc1687fa78a294b232454/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=4af3b0ea1bcc3096e21fc1687fa78a294b232454", "patch": "@@ -676,27 +676,11 @@ bool function_info::group_line_p (unsigned n, unsigned src_idx)\n typedef vector<arc_info *> arc_vector_t;\n typedef vector<const block_info *> block_vector_t;\n \n-/* Enum with types of loop in CFG.  */\n-\n-enum loop_type\n-{\n-  NO_LOOP = 0,\n-  LOOP = 1,\n-  NEGATIVE_LOOP = 3\n-};\n-\n-/* Loop_type operator that merges two values: A and B.  */\n-\n-inline loop_type& operator |= (loop_type& a, loop_type b)\n-{\n-    return a = static_cast<loop_type> (a | b);\n-}\n-\n /* Handle cycle identified by EDGES, where the function finds minimum cs_count\n    and subtract the value from all counts.  The subtracted value is added\n    to COUNT.  Returns type of loop.  */\n \n-static loop_type\n+static void\n handle_cycle (const arc_vector_t &edges, int64_t &count)\n {\n   /* Find the minimum edge of the cycle, and reduce all nodes in the cycle by\n@@ -712,7 +696,7 @@ handle_cycle (const arc_vector_t &edges, int64_t &count)\n   for (unsigned i = 0; i < edges.size (); i++)\n     edges[i]->cs_count -= cycle_count;\n \n-  return cycle_count < 0 ? NEGATIVE_LOOP : LOOP;\n+  gcc_assert (cycle_count >= 0);\n }\n \n /* Unblock a block U from BLOCKED.  Apart from that, iterate all blocks\n@@ -743,12 +727,12 @@ unblock (const block_info *u, block_vector_t &blocked,\n    blocked by a block.  COUNT is accumulated count of the current LINE.\n    Returns what type of loop it contains.  */\n \n-static loop_type\n+static bool\n circuit (block_info *v, arc_vector_t &path, block_info *start,\n \t block_vector_t &blocked, vector<block_vector_t> &block_lists,\n \t line_info &linfo, int64_t &count)\n {\n-  loop_type result = NO_LOOP;\n+  bool loop_found = false;\n \n   /* Add v to the block list.  */\n   gcc_assert (find (blocked.begin (), blocked.end (), v) == blocked.end ());\n@@ -763,15 +747,19 @@ circuit (block_info *v, arc_vector_t &path, block_info *start,\n \n       path.push_back (arc);\n       if (w == start)\n-\t/* Cycle has been found.  */\n-\tresult |= handle_cycle (path, count);\n+\t{\n+\t  /* Cycle has been found.  */\n+\t  handle_cycle (path, count);\n+\t  loop_found = true;\n+\t}\n       else if (find (blocked.begin (), blocked.end (), w) == blocked.end ())\n-\tresult |= circuit (w, path, start, blocked, block_lists, linfo, count);\n+\tloop_found |= circuit (w, path, start, blocked, block_lists, linfo,\n+\t\t\t       count);\n \n       path.pop_back ();\n     }\n \n-  if (result != NO_LOOP)\n+  if (loop_found)\n     unblock (v, blocked, block_lists);\n   else\n     for (arc_info *arc = v->succ; arc; arc = arc->succ_next)\n@@ -788,37 +776,32 @@ circuit (block_info *v, arc_vector_t &path, block_info *start,\n \t  list.push_back (v);\n       }\n \n-  return result;\n+  return loop_found;\n }\n \n-/* Find cycles for a LINFO.  If HANDLE_NEGATIVE_CYCLES is set and the line\n-   contains a negative loop, then perform the same function once again.  */\n+/* Find cycles for a LINFO.  */\n \n static gcov_type\n-get_cycles_count (line_info &linfo, bool handle_negative_cycles = true)\n+get_cycles_count (line_info &linfo)\n {\n   /* Note that this algorithm works even if blocks aren't in sorted order.\n      Each iteration of the circuit detection is completely independent\n      (except for reducing counts, but that shouldn't matter anyways).\n      Therefore, operating on a permuted order (i.e., non-sorted) only\n      has the effect of permuting the output cycles.  */\n \n-  loop_type result = NO_LOOP;\n+  bool loop_found = false;\n   gcov_type count = 0;\n   for (vector<block_info *>::iterator it = linfo.blocks.begin ();\n        it != linfo.blocks.end (); it++)\n     {\n       arc_vector_t path;\n       block_vector_t blocked;\n       vector<block_vector_t > block_lists;\n-      result |= circuit (*it, path, *it, blocked, block_lists, linfo,\n-\t\t\t count);\n+      loop_found |= circuit (*it, path, *it, blocked, block_lists, linfo,\n+\t\t\t     count);\n     }\n \n-  /* If we have a negative cycle, repeat the find_cycles routine.  */\n-  if (result == NEGATIVE_LOOP && handle_negative_cycles)\n-    count += get_cycles_count (linfo, false);\n-\n   return count;\n }\n "}]}