{"sha": "31a7b755582a7c046b8bd548eb9e38f8a0b3cee0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFhN2I3NTU1ODJhN2MwNDZiOGJkNTQ4ZWI5ZTM4ZjhhMGIzY2VlMA==", "commit": {"author": {"name": "Bryce McKinlay", "email": "mckinlay@redhat.com", "date": "2004-07-11T21:19:47Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2004-07-11T21:19:47Z"}, "message": "re PR awt/16748 (IAA.ImageComponentsTest: Freezes When Window Is Resized)\n\n2004-07-11  Bryce McKinlay  <mckinlay@redhat.com>\n\n\tPR libgcj/16748\n\t* prims.cc (_Jv_CreateJavaVM): Fix comment.\n\t* gnu/gcj/runtime/FinalizerThread.java (init): New. Native.\n\t(finalizerReady): Now native.\n\t(run): Likewise.\n\t(runFinalizers): Removed.\n\t* gnu/gcj/runtime/natFinalizerThread.cc (run): Implement here. Use\n\ta primitive lock, and don't hold it while running the finalizers.\n\t(runFinalizers): Implement. Don't aquire any Java lock.\n\t(finalizerReady): Use lock primitives to signal finalizer thread.\n\nFrom-SVN: r84531", "tree": {"sha": "1eb123e8167930c24b33e77b72e82925706270d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1eb123e8167930c24b33e77b72e82925706270d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31a7b755582a7c046b8bd548eb9e38f8a0b3cee0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31a7b755582a7c046b8bd548eb9e38f8a0b3cee0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31a7b755582a7c046b8bd548eb9e38f8a0b3cee0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31a7b755582a7c046b8bd548eb9e38f8a0b3cee0/comments", "author": null, "committer": null, "parents": [{"sha": "f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6"}], "stats": {"total": 115, "additions": 63, "deletions": 52}, "files": [{"sha": "49773da0b584ea360a1e02424eeac5ddf99b2955", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a7b755582a7c046b8bd548eb9e38f8a0b3cee0/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a7b755582a7c046b8bd548eb9e38f8a0b3cee0/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=31a7b755582a7c046b8bd548eb9e38f8a0b3cee0", "patch": "@@ -1,3 +1,16 @@\n+2004-07-11  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\tPR libgcj/16748\t\n+\t* prims.cc (_Jv_CreateJavaVM): Fix comment.\n+\t* gnu/gcj/runtime/FinalizerThread.java (init): New. Native.\n+\t(finalizerReady): Now native.\n+\t(run): Likewise.\n+\t(runFinalizers): Removed.\n+\t* gnu/gcj/runtime/natFinalizerThread.cc (run): Implement here. Use\n+\ta primitive lock, and don't hold it while running the finalizers.\n+\t(runFinalizers): Implement. Don't aquire any Java lock.\n+\t(finalizerReady): Use lock primitives to signal finalizer thread.\n+\n 2004-07-11  Mark Wielaard  <mark@klomp.org>\n \n \tReported by Roman Kennke <roman@ontographics.com> (bug #9331)"}, {"sha": "c9a917cd264b498e54cfe2bbf284906d096c225f", "filename": "libjava/gnu/gcj/runtime/FinalizerThread.java", "status": "modified", "additions": 7, "deletions": 48, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a7b755582a7c046b8bd548eb9e38f8a0b3cee0/libjava%2Fgnu%2Fgcj%2Fruntime%2FFinalizerThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a7b755582a7c046b8bd548eb9e38f8a0b3cee0/libjava%2Fgnu%2Fgcj%2Fruntime%2FFinalizerThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FFinalizerThread.java?ref=31a7b755582a7c046b8bd548eb9e38f8a0b3cee0", "patch": "@@ -1,6 +1,6 @@\n // FinalizerThread.java -- Thread in which finalizers are run.\n \n-/* Copyright (C) 2001  Free Software Foundation\n+/* Copyright (C) 2001, 2004  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -16,58 +16,17 @@\n  */\n public final class FinalizerThread extends Thread\n {\n-  // Finalizers must be run in a thread with no Java-visible locks\n-  // held.  This qualifies because we don't make the lock visible.\n-  private static final Object lock = new Object ();\n-\n-  // This is true if the finalizer thread started successfully.  It\n-  // might be false if, for instance, there are no threads on the\n-  // current platform.  In this situation we run finalizers in the\n-  // caller's thread.\n-  private static boolean thread_started = false;\n+  private static boolean finalizer_ready;\n \n   public FinalizerThread ()\n   {\n     super (\"LibgcjInternalFinalizerThread\");\n     setDaemon (true);\n+    finalizer_ready = false;\n+    init();\n   }\n \n-  // This is called by the runtime when a finalizer is ready to be\n-  // run.  It simply wakes up the finalizer thread.\n-  public static void finalizerReady ()\n-  {\n-    synchronized (lock)\n-      {\n-\tif (! thread_started)\n-\t  runFinalizers ();\n-\telse\n-\t  lock.notify ();\n-      }\n-  }\n-\n-  // Actually run the finalizers.\n-  private static native void runFinalizers ();\n-\n-  public void run ()\n-  {\n-    // Wait on a lock.  Whenever we wake up, try to invoke the\n-    // finalizers.\n-    synchronized (lock)\n-      {\n-\tthread_started = true;\n-\twhile (true)\n-\t  {\n-\t    try\n-\t      {\n-\t\tlock.wait ();\n-\t      }\n-\t    catch (InterruptedException _)\n-\t      {\n-\t\t// Just ignore it.  It doesn't hurt to run finalizers\n-\t\t// when none are pending.\n-\t      }\n-\t    runFinalizers ();\n-\t  }\n-      }\n-  }\n+  private native void init();\n+  static native void finalizerReady();\n+  public native void run();\n }"}, {"sha": "ec1846baf6acd2c377dad2e0a3867b24fa93d776", "filename": "libjava/gnu/gcj/runtime/natFinalizerThread.cc", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a7b755582a7c046b8bd548eb9e38f8a0b3cee0/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatFinalizerThread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a7b755582a7c046b8bd548eb9e38f8a0b3cee0/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatFinalizerThread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatFinalizerThread.cc?ref=31a7b755582a7c046b8bd548eb9e38f8a0b3cee0", "patch": "@@ -1,6 +1,6 @@\n // natFinalizerThread.cc - Implementation of FinalizerThread native methods.\n \n-/* Copyright (C) 2001  Free Software Foundation\n+/* Copyright (C) 2001, 2004  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -15,8 +15,48 @@ details.  */\n \n #include <gnu/gcj/runtime/FinalizerThread.h>\n \n+#include <java-threads.h>\n+\n+static _Jv_Mutex_t mutex;\n+static _Jv_ConditionVariable_t condition;\n+\n+// Initialize lock & condition variable.\n+void\n+gnu::gcj::runtime::FinalizerThread::init ()\n+{\n+  _Jv_MutexInit (&mutex);\n+  _Jv_CondInit (&condition);\n+}\n+\n+// This is called by the GC when a finalizer is ready to be\n+// run.  It sets a flag and wakes up the finalizer thread. Note\n+// that this MUST NOT aquire any Java lock, as this could result in \n+// the hash synchronization code being re-entered: the synchronization\n+// code itself might need to allocate. See PR 16478.\n void\n-gnu::gcj::runtime::FinalizerThread::runFinalizers ()\n+gnu::gcj::runtime::FinalizerThread::finalizerReady ()\n {\n+#ifdef __JV_NO_THREADS__\n   _Jv_RunFinalizers ();\n+#else\n+  _Jv_MutexLock (&mutex);\n+  finalizer_ready = true;\n+  _Jv_CondNotify (&condition, &mutex);\n+  _Jv_MutexUnlock (&mutex);\n+#endif\n+}\n+\n+// Main loop for the finalizer thread. \n+void\n+gnu::gcj::runtime::FinalizerThread::run ()\n+{\n+  while (true)\n+    {\n+      _Jv_MutexLock (&mutex);\n+      if (! finalizer_ready)\n+\t_Jv_CondWait (&condition, &mutex, 0, 0);\n+      finalizer_ready = false;\n+      _Jv_MutexUnlock (&mutex);\n+      _Jv_RunFinalizers ();\n+    }\n }"}, {"sha": "7aac58497aaa4f00e616e1bac5622917eec6d094", "filename": "libjava/prims.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31a7b755582a7c046b8bd548eb9e38f8a0b3cee0/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31a7b755582a7c046b8bd548eb9e38f8a0b3cee0/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=31a7b755582a7c046b8bd548eb9e38f8a0b3cee0", "patch": "@@ -1008,8 +1008,7 @@ _Jv_CreateJavaVM (void* /*vm_args*/)\n   _Jv_GCInitializeFinalizers (&::gnu::gcj::runtime::FinalizerThread::finalizerReady);\n \n   // Start the GC finalizer thread.  A VirtualMachineError can be\n-  // thrown by the runtime if, say, threads aren't available.  In this\n-  // case finalizers simply won't run.\n+  // thrown by the runtime if, say, threads aren't available.\n   try\n     {\n       using namespace gnu::gcj::runtime;"}]}