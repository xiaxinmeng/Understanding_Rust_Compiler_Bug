{"sha": "d90639476f7769578682cbf34628968a3428ebec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkwNjM5NDc2Zjc3Njk1Nzg2ODJjYmYzNDYyODk2OGEzNDI4ZWJlYw==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2015-06-30T16:40:19Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2015-06-30T16:40:19Z"}, "message": "IA MCU psABI support: GCC changes\n\nThis patch introduces basic IA MCU psABI support into GCC.\n\n\t* configure.ac (ospace_frag): Enable for i?86*-*-elfiamcu\n\ttarget.\n\t* configure: Regenerate.\n\ngcc/\n\n\t* config.gcc: Support i[34567]86-*-elfiamcu target.\n\t* config/i386/iamcu.h: New.\n\t* config/i386/i386.opt: Add -miamcu.\n\t* doc/invoke.texi: Document -miamcu.\n\t* common/config/i386/i386-common.c  (ix86_handle_option): Turn\n\toff x87/MMX/SSE/AVX codegen for -miamcu.\n\t* config/i386/i386-c.c (ix86_target_macros_internal): Define\n\t__iamcu/__iamcu__ for -miamcu.\n\t* config/i386/i386.h (PREFERRED_STACK_BOUNDARY_DEFAULT): Set\n\tto MIN_STACK_BOUNDARY if TARGET_IAMCU is true.\n\t(BIGGEST_ALIGNMENT): Set to 32 if TARGET_IAMCU is true.\n\t* config/i386/i386.c (ix86_option_override_internal): Ignore and\n\twarn -mregparm for Intel MCU.  Turn on -mregparm=3 for Intel\n\tMCU by default.  Default long double to 64-bit for Intel MCU.\n\tTurn on -freg-struct-return for Intel MCU.  Issue an error when\n\t-miamcu is used in 64-bit or x32 mode or if x87, MMX, SSE or\n\tAVX is turned on.\n\t(function_arg_advance_32): Pass value whose size is no larger\n\tthan 8 bytes in registers for Intel MCU.\n\t(function_arg_32): Likewise.\n\t(ix86_return_in_memory): Return value whose size is no larger\n\tthan 8 bytes in registers for Intel MCU.\n\t(iamcu_alignment): New function.\n\t(ix86_data_alignment): Call iamcu_alignment if TARGET_IAMCU is\n\ttrue.\n\t(ix86_local_alignment): Don't increase alignment for Intel MCU.\n\t(x86_field_alignment): Return iamcu_alignment if TARGET_IAMCU is\n\ttrue.\n\nFrom-SVN: r225197", "tree": {"sha": "4b11edb9006a44c882a5134990b54d722da2f220", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b11edb9006a44c882a5134990b54d722da2f220"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d90639476f7769578682cbf34628968a3428ebec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d90639476f7769578682cbf34628968a3428ebec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d90639476f7769578682cbf34628968a3428ebec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d90639476f7769578682cbf34628968a3428ebec/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3db55b2b6d83f9d3406af133e42db688b9379395", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3db55b2b6d83f9d3406af133e42db688b9379395", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3db55b2b6d83f9d3406af133e42db688b9379395"}], "stats": {"total": 228, "additions": 216, "deletions": 12}, "files": [{"sha": "5ef6a7ad0c0b1abf5f3b7cef24907bef4abf883e", "filename": "ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90639476f7769578682cbf34628968a3428ebec/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90639476f7769578682cbf34628968a3428ebec/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=d90639476f7769578682cbf34628968a3428ebec", "patch": "@@ -1,3 +1,9 @@\n+2015-06-30  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* configure.ac (ospace_frag): Enable for i?86*-*-elfiamcu\n+\ttarget.\n+\t* configure: Regenerate.\n+\n 2015-06-23  Ludovic Court\u00e8s  <ludo@gnu.org>\n \n \t* MAINTAINERS (Write After Approval): Add myself."}, {"sha": "82e45f3bd3995053d85fb0ce6ca54f7075080166", "filename": "configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90639476f7769578682cbf34628968a3428ebec/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90639476f7769578682cbf34628968a3428ebec/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=d90639476f7769578682cbf34628968a3428ebec", "patch": "@@ -6914,7 +6914,7 @@ case \"${enable_target_optspace}:${target}\" in\n   :d30v-*)\n     ospace_frag=\"config/mt-d30v\"\n     ;;\n-  :m32r-* | :d10v-* | :fr30-*)\n+  :m32r-* | :d10v-* | :fr30-* | :i?86*-*-elfiamcu)\n     ospace_frag=\"config/mt-ospace\"\n     ;;\n   no:* | :*)"}, {"sha": "dc77a1baeda7e8aa0b89b52158861b780834332b", "filename": "configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90639476f7769578682cbf34628968a3428ebec/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90639476f7769578682cbf34628968a3428ebec/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=d90639476f7769578682cbf34628968a3428ebec", "patch": "@@ -2560,7 +2560,7 @@ case \"${enable_target_optspace}:${target}\" in\n   :d30v-*)\n     ospace_frag=\"config/mt-d30v\"\n     ;;\n-  :m32r-* | :d10v-* | :fr30-*)\n+  :m32r-* | :d10v-* | :fr30-* | :i?86*-*-elfiamcu)\n     ospace_frag=\"config/mt-ospace\"\n     ;;\n   no:* | :*)"}, {"sha": "bd460912172bdde6a44cad91cfc74d416ead8143", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90639476f7769578682cbf34628968a3428ebec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90639476f7769578682cbf34628968a3428ebec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d90639476f7769578682cbf34628968a3428ebec", "patch": "@@ -1,3 +1,34 @@\n+2015-06-30  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* config.gcc: Support i[34567]86-*-elfiamcu target.\n+\t* config/i386/iamcu.h: New.\n+\t* config/i386/i386.opt: Add -miamcu.\n+\t* doc/invoke.texi: Document -miamcu.\n+\t* common/config/i386/i386-common.c  (ix86_handle_option): Turn\n+\toff x87/MMX/SSE/AVX codegen for -miamcu.\n+\t* config/i386/i386-c.c (ix86_target_macros_internal): Define\n+\t__iamcu/__iamcu__ for -miamcu.\n+\t* config/i386/i386.h (PREFERRED_STACK_BOUNDARY_DEFAULT): Set\n+\tto MIN_STACK_BOUNDARY if TARGET_IAMCU is true.\n+\t(BIGGEST_ALIGNMENT): Set to 32 if TARGET_IAMCU is true.\n+\t* config/i386/i386.c (ix86_option_override_internal): Ignore and\n+\twarn -mregparm for Intel MCU.  Turn on -mregparm=3 for Intel\n+\tMCU by default.  Default long double to 64-bit for Intel MCU.\n+\tTurn on -freg-struct-return for Intel MCU.  Issue an error when\n+\t-miamcu is used in 64-bit or x32 mode or if x87, MMX, SSE or\n+\tAVX is turned on.\n+\t(function_arg_advance_32): Pass value whose size is no larger\n+\tthan 8 bytes in registers for Intel MCU.\n+\t(function_arg_32): Likewise.\n+\t(ix86_return_in_memory): Return value whose size is no larger\n+\tthan 8 bytes in registers for Intel MCU.\n+\t(iamcu_alignment): New function.\n+\t(ix86_data_alignment): Call iamcu_alignment if TARGET_IAMCU is\n+\ttrue.\n+\t(ix86_local_alignment): Don't increase alignment for Intel MCU.\n+\t(x86_field_alignment): Return iamcu_alignment if TARGET_IAMCU is\n+\ttrue.\n+\n 2015-06-30  Marek Polacek  <polacek@redhat.com>\n \n \t* match.pd (X - (X / Y) * Y): Use convert1 and convert2.  Convert"}, {"sha": "79b2472dc750973c30a319d1e8c7b9fbfba41b02", "filename": "gcc/common/config/i386/i386-common.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90639476f7769578682cbf34628968a3428ebec/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90639476f7769578682cbf34628968a3428ebec/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c?ref=d90639476f7769578682cbf34628968a3428ebec", "patch": "@@ -223,7 +223,7 @@ along with GCC; see the file COPYING3.  If not see\n \n bool\n ix86_handle_option (struct gcc_options *opts,\n-\t\t    struct gcc_options *opts_set ATTRIBUTE_UNUSED,\n+\t\t    struct gcc_options *opts_set,\n \t\t    const struct cl_decoded_option *decoded,\n \t\t    location_t loc)\n {\n@@ -232,6 +232,20 @@ ix86_handle_option (struct gcc_options *opts,\n \n   switch (code)\n     {\n+    case OPT_miamcu:\n+      if (value)\n+\t{\n+\t  /* Turn off x87/MMX/SSE/AVX codegen for -miamcu.  */\n+\t  opts->x_target_flags &= ~MASK_80387;\n+\t  opts_set->x_target_flags |= MASK_80387;\n+\t  opts->x_ix86_isa_flags &= ~(OPTION_MASK_ISA_MMX_UNSET\n+\t\t\t\t      | OPTION_MASK_ISA_SSE_UNSET);\n+\t  opts->x_ix86_isa_flags_explicit |= (OPTION_MASK_ISA_MMX_UNSET\n+\t\t\t\t\t      | OPTION_MASK_ISA_SSE_UNSET);\n+\n+\t}\n+      return true;\n+\n     case OPT_mmmx:\n       if (value)\n \t{"}, {"sha": "2b3af82be940dae3200681e629b3e4f1ca3b7326", "filename": "gcc/config.gcc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90639476f7769578682cbf34628968a3428ebec/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90639476f7769578682cbf34628968a3428ebec/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=d90639476f7769578682cbf34628968a3428ebec", "patch": "@@ -1389,6 +1389,9 @@ x86_64-*-darwin*)\n \ttmake_file=\"${tmake_file} ${cpu_type}/t-darwin64 t-slibgcc\"\n \ttm_file=\"${tm_file} ${cpu_type}/darwin64.h\"\n \t;;\n+i[34567]86-*-elfiamcu)\n+\ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/iamcu.h\"\n+\t;;\n i[34567]86-*-elf*)\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/i386elf.h\"\n \t;;"}, {"sha": "304ce551d201e09bd5f474825568e61588ddd254", "filename": "gcc/config/i386/i386-c.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90639476f7769578682cbf34628968a3428ebec/gcc%2Fconfig%2Fi386%2Fi386-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90639476f7769578682cbf34628968a3428ebec/gcc%2Fconfig%2Fi386%2Fi386-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.c?ref=d90639476f7769578682cbf34628968a3428ebec", "patch": "@@ -425,6 +425,11 @@ ix86_target_macros_internal (HOST_WIDE_INT isa_flag,\n     def_or_undef (parse_in, \"__CLWB__\");\n   if (isa_flag & OPTION_MASK_ISA_MWAITX)\n     def_or_undef (parse_in, \"__MWAITX__\");\n+  if (TARGET_IAMCU)\n+    {\n+      def_or_undef (parse_in, \"__iamcu\");\n+      def_or_undef (parse_in, \"__iamcu__\");\n+    }\n }\n \n \f"}, {"sha": "7d26e8c2bd00df18fc916619615d605ec85e59e2", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 99, "deletions": 6, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90639476f7769578682cbf34628968a3428ebec/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90639476f7769578682cbf34628968a3428ebec/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d90639476f7769578682cbf34628968a3428ebec", "patch": "@@ -3433,6 +3433,10 @@ ix86_option_override_internal (bool main_args_p,\n \t  || TARGET_16BIT_P (opts->x_ix86_isa_flags))\n \topts->x_ix86_isa_flags &= ~OPTION_MASK_ABI_X32;\n #endif\n+      if (TARGET_64BIT_P (opts->x_ix86_isa_flags)\n+\t  && TARGET_IAMCU_P (opts->x_target_flags))\n+\tsorry (\"Intel MCU psABI isn%'t supported in %s mode\",\n+\t       TARGET_X32_P (opts->x_ix86_isa_flags) ? \"x32\" : \"64-bit\");\n     }\n #endif\n \n@@ -3817,6 +3821,20 @@ ix86_option_override_internal (bool main_args_p,\n   if (TARGET_X32 && (ix86_isa_flags & OPTION_MASK_ISA_MPX))\n     error (\"Intel MPX does not support x32\");\n \n+  if (TARGET_IAMCU_P (opts->x_target_flags))\n+    {\n+      /* Verify that x87/MMX/SSE/AVX is off for -miamcu.  */\n+      if (TARGET_80387_P (opts->x_target_flags))\n+\tsorry (\"X87 FPU isn%'t supported in Intel MCU psABI\");\n+      else if ((opts->x_ix86_isa_flags & (OPTION_MASK_ISA_MMX\n+\t\t\t\t\t  | OPTION_MASK_ISA_SSE\n+\t\t\t\t\t  | OPTION_MASK_ISA_AVX)))\n+\tsorry (\"%s isn%'t supported in Intel MCU psABI\",\n+\t       TARGET_MMX_P (opts->x_ix86_isa_flags)\n+\t       ? \"MMX\"\n+\t       : TARGET_SSE_P (opts->x_ix86_isa_flags) ? \"SSE\" : \"AVX\");\n+    }\n+\n   if (!strcmp (opts->x_ix86_arch_string, \"generic\"))\n     error (\"generic CPU can be used only for %stune=%s %s\",\n \t   prefix, suffix, sw);\n@@ -3904,7 +3922,16 @@ ix86_option_override_internal (bool main_args_p,\n       if (opts->x_flag_asynchronous_unwind_tables == 2)\n \topts->x_flag_asynchronous_unwind_tables = !USE_IX86_FRAME_POINTER;\n       if (opts->x_flag_pcc_struct_return == 2)\n-\topts->x_flag_pcc_struct_return = DEFAULT_PCC_STRUCT_RETURN;\n+\t{\n+\t  /* Intel MCU psABI specifies that -freg-struct-return should\n+\t     be on.  Instead of setting DEFAULT_PCC_STRUCT_RETURN to 1,\n+\t     we check -miamcu so that -freg-struct-return is always\n+\t     turned on if -miamcu is used.  */\n+\t  if (TARGET_IAMCU_P (opts->x_target_flags))\n+\t    opts->x_flag_pcc_struct_return = 0;\n+\t  else\n+\t    opts->x_flag_pcc_struct_return = DEFAULT_PCC_STRUCT_RETURN;\n+\t}\n     }\n \n   ix86_tune_cost = processor_target_table[ix86_tune].cost;\n@@ -3923,14 +3950,17 @@ ix86_option_override_internal (bool main_args_p,\n     {\n       if (TARGET_64BIT_P (opts->x_ix86_isa_flags))\n \twarning (0, \"-mregparm is ignored in 64-bit mode\");\n+      else if (TARGET_IAMCU_P (opts->x_target_flags))\n+\twarning (0, \"-mregparm is ignored for Intel MCU psABI\");\n       if (opts->x_ix86_regparm > REGPARM_MAX)\n \t{\n \t  error (\"-mregparm=%d is not between 0 and %d\",\n \t\t opts->x_ix86_regparm, REGPARM_MAX);\n \t  opts->x_ix86_regparm = 0;\n \t}\n     }\n-  if (TARGET_64BIT_P (opts->x_ix86_isa_flags))\n+  if (TARGET_IAMCU_P (opts->x_target_flags)\n+      || TARGET_64BIT_P (opts->x_ix86_isa_flags))\n     opts->x_ix86_regparm = REGPARM_MAX;\n \n   /* Default align_* from the processor table.  */\n@@ -4334,8 +4364,9 @@ ix86_option_override_internal (bool main_args_p,\n     opts->x_recip_mask &= ~(RECIP_MASK_ALL & ~opts->x_recip_mask_explicit);\n \n   /* Default long double to 64-bit for 32-bit Bionic and to __float128\n-     for 64-bit Bionic.  */\n-  if (TARGET_HAS_BIONIC\n+     for 64-bit Bionic.  Also default long double to 64-bit for Intel\n+     MCU psABI.  */\n+  if ((TARGET_HAS_BIONIC || TARGET_IAMCU)\n       && !(opts_set->x_target_flags\n \t   & (MASK_LONG_DOUBLE_64 | MASK_LONG_DOUBLE_128)))\n     opts->x_target_flags |= (TARGET_64BIT\n@@ -7455,6 +7486,15 @@ function_arg_advance_32 (CUMULATIVE_ARGS *cum, machine_mode mode,\n   int res = 0;\n   bool error_p = NULL;\n \n+  if (TARGET_IAMCU)\n+    {\n+      /* Intel MCU psABI passes scalars and aggregates no larger than 8\n+\t bytes in registers.  */\n+      if (bytes <= 8)\n+\tgoto pass_in_reg;\n+      return res;\n+    }\n+\n   switch (mode)\n     {\n     default:\n@@ -7469,6 +7509,7 @@ function_arg_advance_32 (CUMULATIVE_ARGS *cum, machine_mode mode,\n     case SImode:\n     case HImode:\n     case QImode:\n+pass_in_reg:\n       cum->words += words;\n       cum->nregs -= words;\n       cum->regno += words;\n@@ -7702,6 +7743,15 @@ function_arg_32 (CUMULATIVE_ARGS *cum, machine_mode mode,\n   if (mode == VOIDmode)\n     return constm1_rtx;\n \n+  if (TARGET_IAMCU)\n+    {\n+      /* Intel MCU psABI passes scalars and aggregates no larger than 8\n+\t bytes in registers.  */\n+      if (bytes <= 8)\n+\tgoto pass_in_reg;\n+      return NULL_RTX;\n+    }\n+\n   switch (mode)\n     {\n     default:\n@@ -7715,6 +7765,7 @@ function_arg_32 (CUMULATIVE_ARGS *cum, machine_mode mode,\n     case SImode:\n     case HImode:\n     case QImode:\n+pass_in_reg:\n       if (words <= cum->nregs)\n \t{\n \t  int regno = cum->regno;\n@@ -8561,11 +8612,16 @@ ix86_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n     }\n   else\n     {\n+      size = int_size_in_bytes (type);\n+\n+      /* Intel MCU psABI returns scalars and aggregates no larger than 8\n+\t bytes in registers.  */\n+      if (TARGET_IAMCU)\n+\treturn size > 8;\n+\n       if (mode == BLKmode)\n \treturn true;\n \n-      size = int_size_in_bytes (type);\n-\n       if (MS_AGGREGATE_RETURN && AGGREGATE_TYPE_P (type) && size <= 8)\n \treturn false;\n \n@@ -27334,6 +27390,34 @@ ix86_constant_alignment (tree exp, int align)\n   return align;\n }\n \n+/* Compute the alignment for a variable for Intel MCU psABI.  TYPE is\n+   the data type, and ALIGN is the alignment that the object would\n+   ordinarily have.  */\n+\n+static int\n+iamcu_alignment (tree type, int align)\n+{\n+  enum machine_mode mode;\n+\n+  if (align < 32 || TYPE_USER_ALIGN (type))\n+    return align;\n+\n+  /* Intel MCU psABI specifies scalar types > 4 bytes aligned to 4\n+     bytes.  */\n+  mode = TYPE_MODE (strip_array_types (type));\n+  switch (GET_MODE_CLASS (mode))\n+    {\n+    case MODE_INT:\n+    case MODE_COMPLEX_INT:\n+    case MODE_COMPLEX_FLOAT:\n+    case MODE_FLOAT:\n+    case MODE_DECIMAL_FLOAT:\n+      return 32;\n+    default:\n+      return align;\n+    }\n+}\n+\n /* Compute the alignment for a static variable.\n    TYPE is the data type, and ALIGN is the alignment that\n    the object would ordinarily have.  The value of this function is used\n@@ -27368,6 +27452,9 @@ ix86_data_alignment (tree type, int align, bool opt)\n     case ix86_align_data_type_cacheline: break;\n     }\n \n+  if (TARGET_IAMCU)\n+    align = iamcu_alignment (type, align);\n+\n   if (opt\n       && AGGREGATE_TYPE_P (type)\n       && TYPE_SIZE (type)\n@@ -27477,6 +27564,10 @@ ix86_local_alignment (tree exp, machine_mode mode,\n       return align;\n     }\n \n+  /* Don't increase alignment for Intel MCU psABI.  */\n+  if (TARGET_IAMCU)\n+    return align;\n+\n   /* x86-64 ABI requires arrays greater than 16 bytes to be aligned\n      to 16byte boundary.  Exact wording is:\n \n@@ -43187,6 +43278,8 @@ x86_field_alignment (tree field, int computed)\n \n   if (TARGET_64BIT || TARGET_ALIGN_DOUBLE)\n     return computed;\n+  if (TARGET_IAMCU)\n+    return iamcu_alignment (type, computed);\n   mode = TYPE_MODE (strip_array_types (type));\n   if (mode == DFmode || mode == DCmode\n       || GET_MODE_CLASS (mode) == MODE_INT"}, {"sha": "d710b3d2643b8a0b2589806d02b6b2578a687d1c", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90639476f7769578682cbf34628968a3428ebec/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90639476f7769578682cbf34628968a3428ebec/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=d90639476f7769578682cbf34628968a3428ebec", "patch": "@@ -756,7 +756,8 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n /* It should be MIN_STACK_BOUNDARY.  But we set it to 128 bits for\n    both 32bit and 64bit, to support codes that need 128 bit stack\n    alignment for SSE instructions, but can't realign the stack.  */\n-#define PREFERRED_STACK_BOUNDARY_DEFAULT 128\n+#define PREFERRED_STACK_BOUNDARY_DEFAULT \\\n+  (TARGET_IAMCU ? MIN_STACK_BOUNDARY : 128)\n \n /* 1 if -mstackrealign should be turned on by default.  It will\n    generate an alternate prologue and epilogue that realigns the\n@@ -803,7 +804,7 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n    TARGET_ABSOLUTE_BIGGEST_ALIGNMENT.  */\n \n #define BIGGEST_ALIGNMENT \\\n-  (TARGET_AVX512F ? 512 : (TARGET_AVX ? 256 : 128))\n+  (TARGET_AVX512F ? 512 : (TARGET_AVX ? 256 : (TARGET_IAMCU ? 32 : 128)))\n \n /* Maximum stack alignment.  */\n #define MAX_STACK_ALIGNMENT MAX_OFILE_ALIGNMENT"}, {"sha": "042f3c1ab2002756a22f2f2b6a287e78a0f91a59", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90639476f7769578682cbf34628968a3428ebec/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90639476f7769578682cbf34628968a3428ebec/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=d90639476f7769578682cbf34628968a3428ebec", "patch": "@@ -514,6 +514,10 @@ Clear all tune features\n mdump-tune-features\n Target RejectNegative Var(ix86_dump_tunes) Init(0)\n \n+miamcu\n+Target Report Mask(IAMCU)\n+Generate code that conforms to Intel MCU psABI\n+\n mabi=\n Target RejectNegative Joined Var(ix86_abi) Enum(calling_abi) Init(SYSV_ABI)\n Generate code that conforms to the given ABI"}, {"sha": "a1c83f4dc13b31879b17c7ccaac052170fae1cb0", "filename": "gcc/config/i386/iamcu.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90639476f7769578682cbf34628968a3428ebec/gcc%2Fconfig%2Fi386%2Fiamcu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90639476f7769578682cbf34628968a3428ebec/gcc%2Fconfig%2Fi386%2Fiamcu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fiamcu.h?ref=d90639476f7769578682cbf34628968a3428ebec", "patch": "@@ -0,0 +1,42 @@\n+/* Definitions of target machine for Intel MCU psABI.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Intel MCU has no 80387.  Default to Intel MCU psABI.  */\n+#undef TARGET_SUBTARGET_DEFAULT\n+#define TARGET_SUBTARGET_DEFAULT MASK_IAMCU\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \"--32 -march=iamcu\"\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC \"-m elf_iamcu\"\n+\n+#undef ENDFILE_SPEC\n+#define ENDFILE_SPEC \"\"\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \"crt0.o%s\"\n+\n+#undef LIB_SPEC\n+#define LIB_SPEC \"--start-group -lc -lgloss --end-group\""}, {"sha": "0413106deb07e17e96bd63ab3a3d9db2fa28668a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d90639476f7769578682cbf34628968a3428ebec/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d90639476f7769578682cbf34628968a3428ebec/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d90639476f7769578682cbf34628968a3428ebec", "patch": "@@ -1096,7 +1096,7 @@ See RS/6000 and PowerPC Options.\n -mpc32 -mpc64 -mpc80 -mstackrealign @gol\n -momit-leaf-frame-pointer  -mno-red-zone -mno-tls-direct-seg-refs @gol\n -mcmodel=@var{code-model} -mabi=@var{name} -maddress-mode=@var{mode} @gol\n--m32 -m64 -mx32 -m16 -mlarge-data-threshold=@var{num} @gol\n+-m32 -m64 -mx32 -m16 -miamcu -mlarge-data-threshold=@var{num} @gol\n -msse2avx -mfentry -mrecord-mcount -mnop-mcount -m8bit-idiv @gol\n -mavx256-split-unaligned-load -mavx256-split-unaligned-store @gol\n -malign-data=@var{type} -mstack-protector-guard=@var{guard}}\n@@ -23289,10 +23289,12 @@ on x86-64 processors in 64-bit environments.\n @itemx -m64\n @itemx -mx32\n @itemx -m16\n+@itemx -miamcu\n @opindex m32\n @opindex m64\n @opindex mx32\n @opindex m16\n+@opindex miamcu\n Generate code for a 16-bit, 32-bit or 64-bit environment.\n The @option{-m32} option sets @code{int}, @code{long}, and pointer types\n to 32 bits, and\n@@ -23311,6 +23313,9 @@ The @option{-m16} option is the same as @option{-m32}, except for that\n it outputs the @code{.code16gcc} assembly directive at the beginning of\n the assembly output so that the binary can run in 16-bit mode.\n \n+The @option{-miamcu} option generates code which conforms to Intel MCU\n+psABI.  It requires the @option{-m32} option to be turned on.\n+\n @item -mno-red-zone\n @opindex mno-red-zone\n Do not use a so-called ``red zone'' for x86-64 code.  The red zone is mandated"}]}