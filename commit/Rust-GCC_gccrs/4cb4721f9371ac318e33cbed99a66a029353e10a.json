{"sha": "4cb4721f9371ac318e33cbed99a66a029353e10a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNiNDcyMWY5MzcxYWMzMThlMzNjYmVkOTlhNjZhMDI5MzUzZTEwYQ==", "commit": {"author": {"name": "Marcin Ko\u015bcielnicki", "email": "koriakin@0x04.net", "date": "2016-02-15T10:20:18Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2016-02-15T10:20:18Z"}, "message": "S/390: Add -fsplit-stack support\n\nlibgcc/ChangeLog:\n\n\t* config.host: Use t-stack and t-stack-s390 for s390*-*-linux.\n\t* config/s390/morestack.S: New file.\n\t* config/s390/t-stack-s390: New file.\n\t* generic-morestack.c (__splitstack_find): Add s390-specific code.\n\ngcc/ChangeLog:\n\n\t* common/config/s390/s390-common.c (s390_supports_split_stack):\n\tNew function.\n\t(TARGET_SUPPORTS_SPLIT_STACK): New macro.\n\t* config/s390/s390-protos.h: Add s390_expand_split_stack_prologue.\n\t* config/s390/s390.c (struct machine_function): New field\n\tsplit_stack_varargs_pointer.\n\t(s390_register_info): Mark r12 as clobbered if it'll be used as temp\n\tin s390_emit_prologue.\n\t(s390_emit_prologue): Use r12 as temp if r1 is taken by split-stack\n\tvararg pointer.\n\t(morestack_ref): New global.\n\t(SPLIT_STACK_AVAILABLE): New macro.\n\t(s390_expand_split_stack_prologue): New function.\n\t(s390_live_on_entry): New function.\n\t(s390_va_start): Use split-stack vararg pointer if appropriate.\n\t(s390_asm_file_end): Emit the split-stack note sections.\n\t(TARGET_EXTRA_LIVE_ON_ENTRY): New macro.\n\t* config/s390/s390.md (UNSPEC_STACK_CHECK): New unspec.\n\t(UNSPECV_SPLIT_STACK_CALL): New unspec.\n\t(UNSPECV_SPLIT_STACK_DATA): New unspec.\n\t(split_stack_prologue): New expand.\n\t(split_stack_space_check): New expand.\n\t(split_stack_data): New insn.\n\t(split_stack_call): New expand.\n\t(split_stack_call_*): New insn.\n\t(split_stack_cond_call): New expand.\n\t(split_stack_cond_call_*): New insn.\n\nFrom-SVN: r233421", "tree": {"sha": "633620a331dce10653b1b110b0531b75f5ee2376", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/633620a331dce10653b1b110b0531b75f5ee2376"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cb4721f9371ac318e33cbed99a66a029353e10a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cb4721f9371ac318e33cbed99a66a029353e10a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cb4721f9371ac318e33cbed99a66a029353e10a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cb4721f9371ac318e33cbed99a66a029353e10a/comments", "author": {"login": "mwkmwkmwk", "id": 236399, "node_id": "MDQ6VXNlcjIzNjM5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/236399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mwkmwkmwk", "html_url": "https://github.com/mwkmwkmwk", "followers_url": "https://api.github.com/users/mwkmwkmwk/followers", "following_url": "https://api.github.com/users/mwkmwkmwk/following{/other_user}", "gists_url": "https://api.github.com/users/mwkmwkmwk/gists{/gist_id}", "starred_url": "https://api.github.com/users/mwkmwkmwk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mwkmwkmwk/subscriptions", "organizations_url": "https://api.github.com/users/mwkmwkmwk/orgs", "repos_url": "https://api.github.com/users/mwkmwkmwk/repos", "events_url": "https://api.github.com/users/mwkmwkmwk/events{/privacy}", "received_events_url": "https://api.github.com/users/mwkmwkmwk/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "17a3b967929eb6d344ae73bff4f28efc88c35ca9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17a3b967929eb6d344ae73bff4f28efc88c35ca9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17a3b967929eb6d344ae73bff4f28efc88c35ca9"}], "stats": {"total": 1025, "additions": 1018, "deletions": 7}, "files": [{"sha": "cf178e74baaa54eaba9a7598782082bc99b3ce1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cb4721f9371ac318e33cbed99a66a029353e10a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cb4721f9371ac318e33cbed99a66a029353e10a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4cb4721f9371ac318e33cbed99a66a029353e10a", "patch": "@@ -1,3 +1,33 @@\n+2016-02-15  Marcin Ko\u015bcielnicki  <koriakin@0x04.net>\n+\n+\t* common/config/s390/s390-common.c (s390_supports_split_stack):\n+\tNew function.\n+\t(TARGET_SUPPORTS_SPLIT_STACK): New macro.\n+\t* config/s390/s390-protos.h: Add s390_expand_split_stack_prologue.\n+\t* config/s390/s390.c (struct machine_function): New field\n+\tsplit_stack_varargs_pointer.\n+\t(s390_register_info): Mark r12 as clobbered if it'll be used as temp\n+\tin s390_emit_prologue.\n+\t(s390_emit_prologue): Use r12 as temp if r1 is taken by split-stack\n+\tvararg pointer.\n+\t(morestack_ref): New global.\n+\t(SPLIT_STACK_AVAILABLE): New macro.\n+\t(s390_expand_split_stack_prologue): New function.\n+\t(s390_live_on_entry): New function.\n+\t(s390_va_start): Use split-stack vararg pointer if appropriate.\n+\t(s390_asm_file_end): Emit the split-stack note sections.\n+\t(TARGET_EXTRA_LIVE_ON_ENTRY): New macro.\n+\t* config/s390/s390.md (UNSPEC_STACK_CHECK): New unspec.\n+\t(UNSPECV_SPLIT_STACK_CALL): New unspec.\n+\t(UNSPECV_SPLIT_STACK_DATA): New unspec.\n+\t(split_stack_prologue): New expand.\n+\t(split_stack_space_check): New expand.\n+\t(split_stack_data): New insn.\n+\t(split_stack_call): New expand.\n+\t(split_stack_call_*): New insn.\n+\t(split_stack_cond_call): New expand.\n+\t(split_stack_cond_call_*): New insn.\n+\n 2016-02-15  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/69783"}, {"sha": "1e497e6ad929156e710049a4f359797ece6dd2f3", "filename": "gcc/common/config/s390/s390-common.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cb4721f9371ac318e33cbed99a66a029353e10a/gcc%2Fcommon%2Fconfig%2Fs390%2Fs390-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cb4721f9371ac318e33cbed99a66a029353e10a/gcc%2Fcommon%2Fconfig%2Fs390%2Fs390-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fs390%2Fs390-common.c?ref=4cb4721f9371ac318e33cbed99a66a029353e10a", "patch": "@@ -105,6 +105,17 @@ s390_handle_option (struct gcc_options *opts ATTRIBUTE_UNUSED,\n     }\n }\n \n+/* -fsplit-stack uses a field in the TCB, available with glibc-2.23.\n+   We don't verify it, since earlier versions just have padding at\n+   its place, which works just as well.  */\n+\n+static bool\n+s390_supports_split_stack (bool report ATTRIBUTE_UNUSED,\n+\t\t\t   struct gcc_options *opts ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}\n+\n #undef TARGET_DEFAULT_TARGET_FLAGS\n #define TARGET_DEFAULT_TARGET_FLAGS (TARGET_DEFAULT)\n \n@@ -117,4 +128,7 @@ s390_handle_option (struct gcc_options *opts ATTRIBUTE_UNUSED,\n #undef TARGET_OPTION_INIT_STRUCT\n #define TARGET_OPTION_INIT_STRUCT s390_option_init_struct\n \n+#undef TARGET_SUPPORTS_SPLIT_STACK\n+#define TARGET_SUPPORTS_SPLIT_STACK s390_supports_split_stack\n+\n struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;"}, {"sha": "09032c99d94d2380ac013a6e4b19999c53850b8b", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cb4721f9371ac318e33cbed99a66a029353e10a/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cb4721f9371ac318e33cbed99a66a029353e10a/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=4cb4721f9371ac318e33cbed99a66a029353e10a", "patch": "@@ -42,6 +42,7 @@ extern bool s390_handle_option (struct gcc_options *opts ATTRIBUTE_UNUSED,\n extern HOST_WIDE_INT s390_initial_elimination_offset (int, int);\n extern void s390_emit_prologue (void);\n extern void s390_emit_epilogue (bool);\n+extern void s390_expand_split_stack_prologue (void);\n extern bool s390_can_use_simple_return_insn (void);\n extern bool s390_can_use_return_insn (void);\n extern void s390_function_profiler (FILE *, int);"}, {"sha": "aa82d1c2329511f97d139a96544f6550926686ab", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 209, "deletions": 5, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cb4721f9371ac318e33cbed99a66a029353e10a/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cb4721f9371ac318e33cbed99a66a029353e10a/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=4cb4721f9371ac318e33cbed99a66a029353e10a", "patch": "@@ -428,6 +428,13 @@ struct GTY(()) machine_function\n   /* True if the current function may contain a tbegin clobbering\n      FPRs.  */\n   bool tbegin_p;\n+\n+  /* For -fsplit-stack support: A stack local which holds a pointer to\n+     the stack arguments for a function with a variable number of\n+     arguments.  This is set at the start of the function and is used\n+     to initialize the overflow_arg_area field of the va_list\n+     structure.  */\n+  rtx split_stack_varargs_pointer;\n };\n \n /* Few accessor macros for struct cfun->machine->s390_frame_layout.  */\n@@ -9371,9 +9378,13 @@ s390_register_info ()\n \t  cfun_frame_layout.high_fprs++;\n       }\n \n-  if (flag_pic)\n-    clobbered_regs[PIC_OFFSET_TABLE_REGNUM]\n-      |= !!df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM);\n+  /* Register 12 is used for GOT address, but also as temp in prologue\n+     for split-stack stdarg functions (unless r14 is available).  */\n+  clobbered_regs[12]\n+    |= ((flag_pic && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM))\n+\t|| (flag_split_stack && cfun->stdarg\n+\t    && (crtl->is_leaf || TARGET_TPF_PROFILING\n+\t\t|| has_hard_reg_initial_val (Pmode, RETURN_REGNUM))));\n \n   clobbered_regs[BASE_REGNUM]\n     |= (cfun->machine->base_reg\n@@ -10473,12 +10484,15 @@ s390_emit_prologue (void)\n   int next_fpr = 0;\n \n   /* Choose best register to use for temp use within prologue.\n-     See below for why TPF must use the register 1.  */\n+     TPF with profiling must avoid the register 14 - the tracing function\n+     needs the original contents of r14 to be preserved.  */\n \n   if (!has_hard_reg_initial_val (Pmode, RETURN_REGNUM)\n       && !crtl->is_leaf\n       && !TARGET_TPF_PROFILING)\n     temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n+  else if (flag_split_stack && cfun->stdarg)\n+    temp_reg = gen_rtx_REG (Pmode, 12);\n   else\n     temp_reg = gen_rtx_REG (Pmode, 1);\n \n@@ -10972,6 +10986,166 @@ s300_set_up_by_prologue (hard_reg_set_container *regs)\n     SET_HARD_REG_BIT (regs->set, REGNO (cfun->machine->base_reg));\n }\n \n+/* -fsplit-stack support.  */\n+\n+/* A SYMBOL_REF for __morestack.  */\n+static GTY(()) rtx morestack_ref;\n+\n+/* When using -fsplit-stack, the allocation routines set a field in\n+   the TCB to the bottom of the stack plus this much space, measured\n+   in bytes.  */\n+\n+#define SPLIT_STACK_AVAILABLE 1024\n+\n+/* Emit -fsplit-stack prologue, which goes before the regular function\n+   prologue.  */\n+\n+void\n+s390_expand_split_stack_prologue (void)\n+{\n+  rtx r1, guard, cc = NULL;\n+  rtx_insn *insn;\n+  /* Offset from thread pointer to __private_ss.  */\n+  int psso = TARGET_64BIT ? 0x38 : 0x20;\n+  /* Pointer size in bytes.  */\n+  /* Frame size and argument size - the two parameters to __morestack.  */\n+  HOST_WIDE_INT frame_size = cfun_frame_layout.frame_size;\n+  /* Align argument size to 8 bytes - simplifies __morestack code.  */\n+  HOST_WIDE_INT args_size = crtl->args.size >= 0\n+\t\t\t    ? ((crtl->args.size + 7) & ~7)\n+\t\t\t    : 0;\n+  /* Label to be called by __morestack.  */\n+  rtx_code_label *call_done = NULL;\n+  rtx_code_label *parm_base = NULL;\n+  rtx tmp;\n+\n+  gcc_assert (flag_split_stack && reload_completed);\n+  if (!TARGET_CPU_ZARCH)\n+    {\n+      sorry (\"CPUs older than z900 are not supported for -fsplit-stack\");\n+      return;\n+    }\n+\n+  r1 = gen_rtx_REG (Pmode, 1);\n+\n+  /* If no stack frame will be allocated, don't do anything.  */\n+  if (!frame_size)\n+    {\n+      if (cfun->machine->split_stack_varargs_pointer != NULL_RTX)\n+\t{\n+\t  /* If va_start is used, just use r15.  */\n+\t  emit_move_insn (r1,\n+\t\t\t gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t       GEN_INT (STACK_POINTER_OFFSET)));\n+\n+\t}\n+      return;\n+    }\n+\n+  if (morestack_ref == NULL_RTX)\n+    {\n+      morestack_ref = gen_rtx_SYMBOL_REF (Pmode, \"__morestack\");\n+      SYMBOL_REF_FLAGS (morestack_ref) |= (SYMBOL_FLAG_LOCAL\n+\t\t\t\t\t   | SYMBOL_FLAG_FUNCTION);\n+    }\n+\n+  if (CONST_OK_FOR_K (frame_size) || CONST_OK_FOR_Op (frame_size))\n+    {\n+      /* If frame_size will fit in an add instruction, do a stack space\n+\t check, and only call __morestack if there's not enough space.  */\n+\n+      /* Get thread pointer.  r1 is the only register we can always destroy - r0\n+\t could contain a static chain (and cannot be used to address memory\n+\t anyway), r2-r6 can contain parameters, and r6-r15 are callee-saved.  */\n+      emit_move_insn (r1, gen_rtx_REG (Pmode, TP_REGNUM));\n+      /* Aim at __private_ss.  */\n+      guard = gen_rtx_MEM (Pmode, plus_constant (Pmode, r1, psso));\n+\n+      /* If less that 1kiB used, skip addition and compare directly with\n+\t __private_ss.  */\n+      if (frame_size > SPLIT_STACK_AVAILABLE)\n+\t{\n+\t  emit_move_insn (r1, guard);\n+\t  if (TARGET_64BIT)\n+\t    emit_insn (gen_adddi3 (r1, r1, GEN_INT (frame_size)));\n+\t  else\n+\t    emit_insn (gen_addsi3 (r1, r1, GEN_INT (frame_size)));\n+\t  guard = r1;\n+\t}\n+\n+      /* Compare the (maybe adjusted) guard with the stack pointer.  */\n+      cc = s390_emit_compare (LT, stack_pointer_rtx, guard);\n+    }\n+\n+  call_done = gen_label_rtx ();\n+  parm_base = gen_label_rtx ();\n+\n+  /* Emit the parameter block.  */\n+  tmp = gen_split_stack_data (parm_base, call_done,\n+\t\t\t      GEN_INT (frame_size),\n+\t\t\t      GEN_INT (args_size));\n+  insn = emit_insn (tmp);\n+  add_reg_note (insn, REG_LABEL_OPERAND, call_done);\n+  LABEL_NUSES (call_done)++;\n+  add_reg_note (insn, REG_LABEL_OPERAND, parm_base);\n+  LABEL_NUSES (parm_base)++;\n+\n+  /* %r1 = litbase.  */\n+  insn = emit_move_insn (r1, gen_rtx_LABEL_REF (VOIDmode, parm_base));\n+  add_reg_note (insn, REG_LABEL_OPERAND, parm_base);\n+  LABEL_NUSES (parm_base)++;\n+\n+  /* Now, we need to call __morestack.  It has very special calling\n+     conventions: it preserves param/return/static chain registers for\n+     calling main function body, and looks for its own parameters at %r1. */\n+\n+  if (cc != NULL)\n+    {\n+      tmp = gen_split_stack_cond_call (morestack_ref, cc, call_done);\n+\n+      insn = emit_jump_insn (tmp);\n+      JUMP_LABEL (insn) = call_done;\n+      LABEL_NUSES (call_done)++;\n+\n+      /* Mark the jump as very unlikely to be taken.  */\n+      add_int_reg_note (insn, REG_BR_PROB, REG_BR_PROB_BASE / 100);\n+\n+      if (cfun->machine->split_stack_varargs_pointer != NULL_RTX)\n+\t{\n+\t  /* If va_start is used, and __morestack was not called, just use\n+\t     r15.  */\n+\t  emit_move_insn (r1,\n+\t\t\t gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t       GEN_INT (STACK_POINTER_OFFSET)));\n+\t}\n+    }\n+  else\n+    {\n+      tmp = gen_split_stack_call (morestack_ref, call_done);\n+      insn = emit_jump_insn (tmp);\n+      JUMP_LABEL (insn) = call_done;\n+      LABEL_NUSES (call_done)++;\n+      emit_barrier ();\n+    }\n+\n+  /* __morestack will call us here.  */\n+\n+  emit_label (call_done);\n+}\n+\n+/* We may have to tell the dataflow pass that the split stack prologue\n+   is initializing a register.  */\n+\n+static void\n+s390_live_on_entry (bitmap regs)\n+{\n+  if (cfun->machine->split_stack_varargs_pointer != NULL_RTX)\n+    {\n+      gcc_assert (flag_split_stack);\n+      bitmap_set_bit (regs, 1);\n+    }\n+}\n+\n /* Return true if the function can use simple_return to return outside\n    of a shrink-wrapped region.  At present shrink-wrapping is supported\n    in all cases.  */\n@@ -11574,6 +11748,27 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n \n+  if (flag_split_stack\n+     && (lookup_attribute (\"no_split_stack\", DECL_ATTRIBUTES (cfun->decl))\n+         == NULL)\n+     && cfun->machine->split_stack_varargs_pointer == NULL_RTX)\n+    {\n+      rtx reg;\n+      rtx_insn *seq;\n+\n+      reg = gen_reg_rtx (Pmode);\n+      cfun->machine->split_stack_varargs_pointer = reg;\n+\n+      start_sequence ();\n+      emit_move_insn (reg, gen_rtx_REG (Pmode, 1));\n+      seq = get_insns ();\n+      end_sequence ();\n+\n+      push_topmost_sequence ();\n+      emit_insn_after (seq, entry_of_function ());\n+      pop_topmost_sequence ();\n+    }\n+\n   /* Find the overflow area.\n      FIXME: This currently is too pessimistic when the vector ABI is\n      enabled.  In that case we *always* set up the overflow area\n@@ -11582,7 +11777,10 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n       || n_fpr + cfun->va_list_fpr_size > FP_ARG_NUM_REG\n       || TARGET_VX_ABI)\n     {\n-      t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);\n+      if (cfun->machine->split_stack_varargs_pointer == NULL_RTX)\n+        t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);\n+      else\n+        t = make_tree (TREE_TYPE (ovf), cfun->machine->split_stack_varargs_pointer);\n \n       off = INTVAL (crtl->args.arg_offset_rtx);\n       off = off < 0 ? 0 : off;\n@@ -14502,6 +14700,9 @@ s390_asm_file_end (void)\n \t     s390_vector_abi);\n #endif\n   file_end_indicate_exec_stack ();\n+\n+  if (flag_split_stack)\n+    file_end_indicate_split_stack ();\n }\n \n /* Return true if TYPE is a vector bool type.  */\n@@ -14757,6 +14958,9 @@ s390_invalid_binary_op (int op ATTRIBUTE_UNUSED, const_tree type1, const_tree ty\n #undef TARGET_SET_UP_BY_PROLOGUE\n #define TARGET_SET_UP_BY_PROLOGUE s300_set_up_by_prologue\n \n+#undef TARGET_EXTRA_LIVE_ON_ENTRY\n+#define TARGET_EXTRA_LIVE_ON_ENTRY s390_live_on_entry\n+\n #undef TARGET_USE_BY_PIECES_INFRASTRUCTURE_P\n #define TARGET_USE_BY_PIECES_INFRASTRUCTURE_P \\\n   s390_use_by_pieces_infrastructure_p"}, {"sha": "6f0e172d42c94ce8346557424c2ad18374bf0223", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cb4721f9371ac318e33cbed99a66a029353e10a/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cb4721f9371ac318e33cbed99a66a029353e10a/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=4cb4721f9371ac318e33cbed99a66a029353e10a", "patch": "@@ -114,6 +114,9 @@\n    UNSPEC_SP_SET\n    UNSPEC_SP_TEST\n \n+   ; Split stack support\n+   UNSPEC_STACK_CHECK\n+\n    ; Test Data Class (TDC)\n    UNSPEC_TDC_INSN\n \n@@ -276,6 +279,10 @@\n    ; Set and get floating point control register\n    UNSPECV_SFPC\n    UNSPECV_EFPC\n+\n+   ; Split stack support\n+   UNSPECV_SPLIT_STACK_CALL\n+   UNSPECV_SPLIT_STACK_DATA\n   ])\n \n ;;\n@@ -10909,3 +10916,134 @@\n   \"TARGET_Z13\"\n   \"lcbb\\t%0,%1,%b2\"\n   [(set_attr \"op_type\" \"VRX\")])\n+\n+; Handle -fsplit-stack.\n+\n+(define_expand \"split_stack_prologue\"\n+  [(const_int 0)]\n+  \"\"\n+{\n+  s390_expand_split_stack_prologue ();\n+  DONE;\n+})\n+\n+;; If there are operand 0 bytes available on the stack, jump to\n+;; operand 1.\n+\n+(define_expand \"split_stack_space_check\"\n+  [(set (pc) (if_then_else\n+\t      (ltu (minus (reg 15)\n+\t\t\t  (match_operand 0 \"register_operand\"))\n+\t\t   (unspec [(const_int 0)] UNSPEC_STACK_CHECK))\n+\t      (label_ref (match_operand 1))\n+\t      (pc)))]\n+  \"\"\n+{\n+  /* Offset from thread pointer to __private_ss.  */\n+  int psso = TARGET_64BIT ? 0x38 : 0x20;\n+  rtx tp = s390_get_thread_pointer ();\n+  rtx guard = gen_rtx_MEM (Pmode, plus_constant (Pmode, tp, psso));\n+  rtx reg = gen_reg_rtx (Pmode);\n+  rtx cc;\n+  if (TARGET_64BIT)\n+    emit_insn (gen_subdi3 (reg, stack_pointer_rtx, operands[0]));\n+  else\n+    emit_insn (gen_subsi3 (reg, stack_pointer_rtx, operands[0]));\n+  cc = s390_emit_compare (GT, reg, guard);\n+  s390_emit_jump (operands[1], cc);\n+\n+  DONE;\n+})\n+\n+;; __morestack parameter block for split stack prologue.  Parameters are:\n+;; parameter block label, label to be called by __morestack, frame size,\n+;; stack parameter size.\n+\n+(define_insn \"split_stack_data\"\n+  [(unspec_volatile [(match_operand 0 \"\" \"X\")\n+\t\t     (match_operand 1 \"\" \"X\")\n+\t\t     (match_operand 2 \"const_int_operand\" \"X\")\n+\t\t     (match_operand 3 \"const_int_operand\" \"X\")]\n+\t\t    UNSPECV_SPLIT_STACK_DATA)]\n+  \"TARGET_CPU_ZARCH\"\n+{\n+  switch_to_section (targetm.asm_out.function_rodata_section\n+\t\t (current_function_decl));\n+\n+  if (TARGET_64BIT)\n+    output_asm_insn (\".align\\t8\", operands);\n+  else\n+    output_asm_insn (\".align\\t4\", operands);\n+  (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n+\t\t\t\t     CODE_LABEL_NUMBER (operands[0]));\n+  if (TARGET_64BIT)\n+    {\n+      output_asm_insn (\".quad\\t%2\", operands);\n+      output_asm_insn (\".quad\\t%3\", operands);\n+      output_asm_insn (\".quad\\t%1-%0\", operands);\n+    }\n+  else\n+    {\n+      output_asm_insn (\".long\\t%2\", operands);\n+      output_asm_insn (\".long\\t%3\", operands);\n+      output_asm_insn (\".long\\t%1-%0\", operands);\n+    }\n+\n+  switch_to_section (current_function_section ());\n+  return \"\";\n+}\n+  [(set_attr \"length\" \"0\")])\n+\n+\n+;; A jg with minimal fuss for use in split stack prologue.\n+\n+(define_expand \"split_stack_call\"\n+  [(match_operand 0 \"bras_sym_operand\" \"X\")\n+   (match_operand 1 \"\" \"\")]\n+  \"TARGET_CPU_ZARCH\"\n+{\n+  if (TARGET_64BIT)\n+    emit_jump_insn (gen_split_stack_call_di (operands[0], operands[1]));\n+  else\n+    emit_jump_insn (gen_split_stack_call_si (operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_insn \"split_stack_call_<mode>\"\n+  [(set (pc) (label_ref (match_operand 1 \"\" \"\")))\n+   (set (reg:P 1) (unspec_volatile [(match_operand 0 \"bras_sym_operand\" \"X\")\n+\t\t\t\t    (reg:P 1)]\n+\t\t\t\t   UNSPECV_SPLIT_STACK_CALL))]\n+  \"TARGET_CPU_ZARCH\"\n+  \"jg\\t%0\"\n+  [(set_attr \"op_type\" \"RIL\")\n+   (set_attr \"type\"  \"branch\")])\n+\n+;; Also a conditional one.\n+\n+(define_expand \"split_stack_cond_call\"\n+  [(match_operand 0 \"bras_sym_operand\" \"X\")\n+   (match_operand 1 \"\" \"\")\n+   (match_operand 2 \"\" \"\")]\n+  \"TARGET_CPU_ZARCH\"\n+{\n+  if (TARGET_64BIT)\n+    emit_jump_insn (gen_split_stack_cond_call_di (operands[0], operands[1], operands[2]));\n+  else\n+    emit_jump_insn (gen_split_stack_cond_call_si (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_insn \"split_stack_cond_call_<mode>\"\n+  [(set (pc)\n+\t(if_then_else\n+\t  (match_operand 1 \"\" \"\")\n+\t  (label_ref (match_operand 2 \"\" \"\"))\n+\t  (pc)))\n+   (set (reg:P 1) (unspec_volatile [(match_operand 0 \"bras_sym_operand\" \"X\")\n+\t\t\t\t    (reg:P 1)]\n+\t\t\t\t   UNSPECV_SPLIT_STACK_CALL))]\n+  \"TARGET_CPU_ZARCH\"\n+  \"jg%C1\\t%0\"\n+  [(set_attr \"op_type\" \"RIL\")\n+   (set_attr \"type\"  \"branch\")])"}, {"sha": "80b562caccf3210f59ed34df264019c29663ae7d", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cb4721f9371ac318e33cbed99a66a029353e10a/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cb4721f9371ac318e33cbed99a66a029353e10a/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=4cb4721f9371ac318e33cbed99a66a029353e10a", "patch": "@@ -1,3 +1,10 @@\n+2016-02-15  Marcin Ko\u015bcielnicki  <koriakin@0x04.net>\n+\n+\t* config.host: Use t-stack and t-stack-s390 for s390*-*-linux.\n+\t* config/s390/morestack.S: New file.\n+\t* config/s390/t-stack-s390: New file.\n+\t* generic-morestack.c (__splitstack_find): Add s390-specific code.\n+\n 2016-02-12  Walter Lee  <walt@tilera.com>\n \n \t* config.host (tilegx*-*-linux*): remove ti from"}, {"sha": "ef7dfd02f5d9a35fd36fcb74043d5dd1678aa258", "filename": "libgcc/config.host", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cb4721f9371ac318e33cbed99a66a029353e10a/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cb4721f9371ac318e33cbed99a66a029353e10a/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=4cb4721f9371ac318e33cbed99a66a029353e10a", "patch": "@@ -1114,11 +1114,11 @@ rx-*-elf)\n \ttm_file=\"$tm_file rx/rx-abi.h rx/rx-lib.h\"\n \t;;\n s390-*-linux*)\n-\ttmake_file=\"${tmake_file} s390/t-crtstuff s390/t-linux s390/32/t-floattodi\"\n+\ttmake_file=\"${tmake_file} s390/t-crtstuff s390/t-linux s390/32/t-floattodi t-stack s390/t-stack-s390\"\n \tmd_unwind_header=s390/linux-unwind.h\n \t;;\n s390x-*-linux*)\n-\ttmake_file=\"${tmake_file} s390/t-crtstuff s390/t-linux\"\n+\ttmake_file=\"${tmake_file} s390/t-crtstuff s390/t-linux t-stack s390/t-stack-s390\"\n \tif test \"${host_address}\" = 32; then\n \t   tmake_file=\"${tmake_file} s390/32/t-floattodi\"\n \tfi"}, {"sha": "fa6951badf0fac1bfcc045d6586bb491f553a938", "filename": "libgcc/config/s390/morestack.S", "status": "added", "additions": 611, "deletions": 0, "changes": 611, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cb4721f9371ac318e33cbed99a66a029353e10a/libgcc%2Fconfig%2Fs390%2Fmorestack.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cb4721f9371ac318e33cbed99a66a029353e10a/libgcc%2Fconfig%2Fs390%2Fmorestack.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fs390%2Fmorestack.S?ref=4cb4721f9371ac318e33cbed99a66a029353e10a", "patch": "@@ -0,0 +1,611 @@\n+# s390 support for -fsplit-stack.\n+# Copyright (C) 2015 Free Software Foundation, Inc.\n+# Contributed by Marcin Ko\u015bcielnicki <koriakin@0x04.net>.\n+\n+# This file is part of GCC.\n+\n+# GCC is free software; you can redistribute it and/or modify it under\n+# the terms of the GNU General Public License as published by the Free\n+# Software Foundation; either version 3, or (at your option) any later\n+# version.\n+\n+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Excess space needed to call ld.so resolver for lazy plt\n+# resolution.  Go uses sigaltstack so this doesn't need to\n+# also cover signal frame size.\n+#define BACKOFF 0x1000\n+\n+# The __morestack function.\n+\n+\t.global\t__morestack\n+\t.hidden\t__morestack\n+\n+\t.type\t__morestack,@function\n+\n+__morestack:\n+.LFB1:\n+\t.cfi_startproc\n+\n+\n+#ifndef __s390x__\n+\n+\n+# The 31-bit __morestack function.\n+\n+\t# We use a cleanup to restore the stack guard if an exception\n+\t# is thrown through this code.\n+#ifndef __PIC__\n+\t.cfi_personality 0,__gcc_personality_v0\n+\t.cfi_lsda 0,.LLSDA1\n+#else\n+\t.cfi_personality 0x9b,DW.ref.__gcc_personality_v0\n+\t.cfi_lsda 0x1b,.LLSDA1\n+#endif\n+\n+\tstm\t%r2, %r15, 0x8(%r15)\t# Save %r2-%r15.\n+\t.cfi_offset %r6, -0x48\n+\t.cfi_offset %r7, -0x44\n+\t.cfi_offset %r8, -0x40\n+\t.cfi_offset %r9, -0x3c\n+\t.cfi_offset %r10, -0x38\n+\t.cfi_offset %r11, -0x34\n+\t.cfi_offset %r12, -0x30\n+\t.cfi_offset %r13, -0x2c\n+\t.cfi_offset %r14, -0x28\n+\t.cfi_offset %r15, -0x24\n+\tlr\t%r11, %r15\t\t# Make frame pointer for vararg.\n+\t.cfi_def_cfa_register %r11\n+\tahi\t%r15, -0x60\t\t# 0x60 for standard frame.\n+\tst\t%r11, 0(%r15)\t\t# Save back chain.\n+\tlr\t%r8, %r0\t\t# Save %r0 (static chain).\n+\tlr\t%r10, %r1\t\t# Save %r1 (address of parameter block).\n+\n+\tl\t%r7, 0(%r10)\t\t# Required frame size to %r7\n+\tear\t%r1, %a0\t\t# Extract thread pointer.\n+\tl\t%r1, 0x20(%r1)\t\t# Get stack bounduary\n+\tar\t%r1, %r7\t\t# Stack bounduary + frame size\n+\ta\t%r1, 4(%r10)\t\t# + stack param size\n+\tclr\t%r1, %r15\t\t# Compare with current stack pointer\n+\tjle\t.Lnoalloc\t\t# guard > sp - frame-size: need alloc\n+\n+\tbrasl\t%r14, __morestack_block_signals\n+\n+\t# We abuse one of caller's fpr save slots (which we don't use for fprs)\n+\t# as a local variable.  Not needed here, but done to be consistent with\n+\t# the below use.\n+\tahi\t%r7, BACKOFF\t\t# Bump requested size a bit.\n+\tst\t%r7, 0x40(%r11)\t\t# Stuff frame size on stack.\n+\tla\t%r2, 0x40(%r11)\t\t# Pass its address as parameter.\n+\tla\t%r3, 0x60(%r11)\t\t# Caller's stack parameters.\n+\tl\t%r4, 4(%r10)\t\t# Size of stack parameters.\n+\tbrasl\t%r14, __generic_morestack\n+\n+\tlr\t%r15, %r2\t\t# Switch to the new stack.\n+\tahi\t%r15, -0x60\t\t# Make a stack frame on it.\n+\tst\t%r11, 0(%r15)\t\t# Save back chain.\n+\n+\ts\t%r2, 0x40(%r11)\t\t# The end of stack space.\n+\tahi\t%r2, BACKOFF\t\t# Back off a bit.\n+\tear\t%r1, %a0\t\t# Extract thread pointer.\n+.LEHB0:\n+\tst\t%r2, 0x20(%r1)\t# Save the new stack boundary.\n+\n+\tbrasl\t%r14, __morestack_unblock_signals\n+\n+\tlr\t%r0, %r8\t\t# Static chain.\n+\tlm\t%r2, %r6, 0x8(%r11)\t# Paremeter registers.\n+\n+\t# Third parameter is address of function meat - address of parameter\n+\t# block.\n+\ta\t%r10, 0x8(%r10)\n+\n+\t# Leave vararg pointer in %r1, in case function uses it\n+\tla\t%r1, 0x60(%r11)\n+\n+\t# State of registers:\n+\t# %r0: Static chain from entry.\n+\t# %r1: Vararg pointer.\n+\t# %r2-%r6: Parameters from entry.\n+\t# %r7-%r10: Indeterminate.\n+\t# %r11: Frame pointer (%r15 from entry).\n+\t# %r12-%r13: Indeterminate.\n+\t# %r14: Return address.\n+\t# %r15: Stack pointer.\n+\tbasr\t%r14, %r10\t\t# Call our caller.\n+\n+\tstm\t%r2, %r3, 0x8(%r11)\t# Save return registers.\n+\n+\tbrasl\t%r14, __morestack_block_signals\n+\n+\t# We need a stack slot now, but have no good way to get it - the frame\n+\t# on new stack had to be exactly 0x60 bytes, or stack parameters would\n+\t# be passed wrong.  Abuse fpr save area in caller's frame (we don't\n+\t# save actual fprs).\n+\tla\t%r2, 0x40(%r11)\n+\tbrasl\t%r14, __generic_releasestack\n+\n+\ts\t%r2, 0x40(%r11)\t\t# Subtract available space.\n+\tahi\t%r2, BACKOFF\t\t# Back off a bit.\n+\tear\t%r1, %a0\t\t# Extract thread pointer.\n+.LEHE0:\n+\tst\t%r2, 0x20(%r1)\t# Save the new stack boundary.\n+\n+\t# We need to restore the old stack pointer before unblocking signals.\n+\t# We also need 0x60 bytes for a stack frame.  Since we had a stack\n+\t# frame at this place before the stack switch, there's no need to\n+\t# write the back chain again.\n+\tlr\t%r15, %r11\n+\tahi\t%r15, -0x60\n+\n+\tbrasl\t%r14, __morestack_unblock_signals\n+\n+\tlm\t%r2, %r15, 0x8(%r11)\t# Restore all registers.\n+\t.cfi_remember_state\n+\t.cfi_restore %r15\n+\t.cfi_restore %r14\n+\t.cfi_restore %r13\n+\t.cfi_restore %r12\n+\t.cfi_restore %r11\n+\t.cfi_restore %r10\n+\t.cfi_restore %r9\n+\t.cfi_restore %r8\n+\t.cfi_restore %r7\n+\t.cfi_restore %r6\n+\t.cfi_def_cfa_register %r15\n+\tbr\t%r14\t\t\t# Return to caller's caller.\n+\n+# Executed if no new stack allocation is needed.\n+\n+.Lnoalloc:\n+\t.cfi_restore_state\n+\t# We may need to copy stack parameters.\n+\tl\t%r9, 0x4(%r10)\t\t# Load stack parameter size.\n+\tltr\t%r9, %r9\t\t# And check if it's 0.\n+\tje\t.Lnostackparm\t\t# Skip the copy if not needed.\n+\tsr\t%r15, %r9\t\t# Make space on the stack.\n+\tla\t%r8, 0x60(%r15)\t\t# Destination.\n+\tla\t%r12, 0x60(%r11)\t# Source.\n+\tlr\t%r13, %r9\t\t# Source size.\n+.Lcopy:\n+\tmvcle\t%r8, %r12, 0\t\t# Copy.\n+\tjo\t.Lcopy\n+\n+.Lnostackparm:\n+\t# Third parameter is address of function meat - address of parameter\n+\t# block.\n+\ta\t%r10, 0x8(%r10)\n+\n+\t# Leave vararg pointer in %r1, in case function uses it\n+\tla\t%r1, 0x60(%r11)\n+\n+\t# OK, no stack allocation needed.  We still follow the protocol and\n+\t# call our caller - it doesn't cost much and makes sure vararg works.\n+\t# No need to set any registers here - %r0 and %r2-%r6 weren't modified.\n+\tbasr\t%r14, %r10\t\t# Call our caller.\n+\n+\tlm\t%r6, %r15, 0x18(%r11)\t# Restore all callee-saved registers.\n+\t.cfi_remember_state\n+\t.cfi_restore %r15\n+\t.cfi_restore %r14\n+\t.cfi_restore %r13\n+\t.cfi_restore %r12\n+\t.cfi_restore %r11\n+\t.cfi_restore %r10\n+\t.cfi_restore %r9\n+\t.cfi_restore %r8\n+\t.cfi_restore %r7\n+\t.cfi_restore %r6\n+\t.cfi_def_cfa_register %r15\n+\tbr\t%r14\t\t\t# Return to caller's caller.\n+\n+# This is the cleanup code called by the stack unwinder when unwinding\n+# through the code between .LEHB0 and .LEHE0 above.\n+\n+.L1:\n+\t.cfi_restore_state\n+\tlr\t%r2, %r11\t\t# Stack pointer after resume.\n+\tbrasl\t%r14, __generic_findstack\n+\tlr\t%r3, %r11\t\t# Get the stack pointer.\n+\tsr\t%r3, %r2\t\t# Subtract available space.\n+\tahi\t%r3, BACKOFF\t\t# Back off a bit.\n+\tear\t%r1, %a0\t\t# Extract thread pointer.\n+\tst\t%r3, 0x20(%r1)\t# Save the new stack boundary.\n+\n+\t# We need GOT pointer in %r12 for PLT entry.\n+\tlarl\t%r12,_GLOBAL_OFFSET_TABLE_\n+\tlr\t%r2, %r6\t\t# Exception header.\n+#ifdef __PIC__\n+\tbrasl\t%r14, _Unwind_Resume@PLT\n+#else\n+\tbrasl\t%r14, _Unwind_Resume\n+#endif\n+\n+#else /* defined(__s390x__) */\n+\n+\n+# The 64-bit __morestack function.\n+\n+\t# We use a cleanup to restore the stack guard if an exception\n+\t# is thrown through this code.\n+#ifndef __PIC__\n+\t.cfi_personality 0x3,__gcc_personality_v0\n+\t.cfi_lsda 0x3,.LLSDA1\n+#else\n+\t.cfi_personality 0x9b,DW.ref.__gcc_personality_v0\n+\t.cfi_lsda 0x1b,.LLSDA1\n+#endif\n+\n+\tstmg\t%r2, %r15, 0x10(%r15)\t# Save %r2-%r15.\n+\t.cfi_offset %r6, -0x70\n+\t.cfi_offset %r7, -0x68\n+\t.cfi_offset %r8, -0x60\n+\t.cfi_offset %r9, -0x58\n+\t.cfi_offset %r10, -0x50\n+\t.cfi_offset %r11, -0x48\n+\t.cfi_offset %r12, -0x40\n+\t.cfi_offset %r13, -0x38\n+\t.cfi_offset %r14, -0x30\n+\t.cfi_offset %r15, -0x28\n+\tlgr\t%r11, %r15\t\t# Make frame pointer for vararg.\n+\t.cfi_def_cfa_register %r11\n+\taghi\t%r15, -0xa0\t\t# 0xa0 for standard frame.\n+\tstg\t%r11, 0(%r15)\t\t# Save back chain.\n+\tlgr\t%r8, %r0\t\t# Save %r0 (static chain).\n+\tlgr\t%r10, %r1\t\t# Save %r1 (address of parameter block).\n+\n+\tlg\t%r7, 0(%r10)\t\t# Required frame size to %r7\n+\tear\t%r1, %a0\n+\tsllg\t%r1, %r1, 32\n+\tear\t%r1, %a1\t\t# Extract thread pointer.\n+\tlg\t%r1, 0x38(%r1)\t\t# Get stack bounduary\n+\tagr\t%r1, %r7\t\t# Stack bounduary + frame size\n+\tag\t%r1, 8(%r10)\t\t# + stack param size\n+\tclgr\t%r1, %r15\t\t# Compare with current stack pointer\n+\tjle\t.Lnoalloc\t\t# guard > sp - frame-size: need alloc\n+\n+\tbrasl\t%r14, __morestack_block_signals\n+\n+\t# We abuse one of caller's fpr save slots (which we don't use for fprs)\n+\t# as a local variable.  Not needed here, but done to be consistent with\n+\t# the below use.\n+\taghi\t%r7, BACKOFF\t\t# Bump requested size a bit.\n+\tstg\t%r7, 0x80(%r11)\t\t# Stuff frame size on stack.\n+\tla\t%r2, 0x80(%r11)\t\t# Pass its address as parameter.\n+\tla\t%r3, 0xa0(%r11)\t\t# Caller's stack parameters.\n+\tlg\t%r4, 8(%r10)\t\t# Size of stack parameters.\n+\tbrasl\t%r14, __generic_morestack\n+\n+\tlgr\t%r15, %r2\t\t# Switch to the new stack.\n+\taghi\t%r15, -0xa0\t\t# Make a stack frame on it.\n+\tstg\t%r11, 0(%r15)\t\t# Save back chain.\n+\n+\tsg\t%r2, 0x80(%r11)\t\t# The end of stack space.\n+\taghi\t%r2, BACKOFF\t\t# Back off a bit.\n+\tear\t%r1, %a0\n+\tsllg\t%r1, %r1, 32\n+\tear\t%r1, %a1\t\t# Extract thread pointer.\n+.LEHB0:\n+\tstg\t%r2, 0x38(%r1)\t# Save the new stack boundary.\n+\n+\tbrasl\t%r14, __morestack_unblock_signals\n+\n+\tlgr\t%r0, %r8\t\t# Static chain.\n+\tlmg\t%r2, %r6, 0x10(%r11)\t# Paremeter registers.\n+\n+\t# Third parameter is address of function meat - address of parameter\n+\t# block.\n+\tag\t%r10, 0x10(%r10)\n+\n+\t# Leave vararg pointer in %r1, in case function uses it\n+\tla\t%r1, 0xa0(%r11)\n+\n+\t# State of registers:\n+\t# %r0: Static chain from entry.\n+\t# %r1: Vararg pointer.\n+\t# %r2-%r6: Parameters from entry.\n+\t# %r7-%r10: Indeterminate.\n+\t# %r11: Frame pointer (%r15 from entry).\n+\t# %r12-%r13: Indeterminate.\n+\t# %r14: Return address.\n+\t# %r15: Stack pointer.\n+\tbasr\t%r14, %r10\t\t# Call our caller.\n+\n+\tstg\t%r2, 0x10(%r11)\t\t# Save return register.\n+\n+\tbrasl\t%r14, __morestack_block_signals\n+\n+\t# We need a stack slot now, but have no good way to get it - the frame\n+\t# on new stack had to be exactly 0xa0 bytes, or stack parameters would\n+\t# be passed wrong.  Abuse fpr save area in caller's frame (we don't\n+\t# save actual fprs).\n+\tla\t%r2, 0x80(%r11)\n+\tbrasl\t%r14, __generic_releasestack\n+\n+\tsg\t%r2, 0x80(%r11)\t\t# Subtract available space.\n+\taghi\t%r2, BACKOFF\t\t# Back off a bit.\n+\tear\t%r1, %a0\n+\tsllg\t%r1, %r1, 32\n+\tear\t%r1, %a1\t\t# Extract thread pointer.\n+.LEHE0:\n+\tstg\t%r2, 0x38(%r1)\t# Save the new stack boundary.\n+\n+\t# We need to restore the old stack pointer before unblocking signals.\n+\t# We also need 0xa0 bytes for a stack frame.  Since we had a stack\n+\t# frame at this place before the stack switch, there's no need to\n+\t# write the back chain again.\n+\tlgr\t%r15, %r11\n+\taghi\t%r15, -0xa0\n+\n+\tbrasl\t%r14, __morestack_unblock_signals\n+\n+\tlmg\t%r2, %r15, 0x10(%r11)\t# Restore all registers.\n+\t.cfi_remember_state\n+\t.cfi_restore %r15\n+\t.cfi_restore %r14\n+\t.cfi_restore %r13\n+\t.cfi_restore %r12\n+\t.cfi_restore %r11\n+\t.cfi_restore %r10\n+\t.cfi_restore %r9\n+\t.cfi_restore %r8\n+\t.cfi_restore %r7\n+\t.cfi_restore %r6\n+\t.cfi_def_cfa_register %r15\n+\tbr\t%r14\t\t\t# Return to caller's caller.\n+\n+# Executed if no new stack allocation is needed.\n+\n+.Lnoalloc:\n+\t.cfi_restore_state\n+\t# We may need to copy stack parameters.\n+\tlg\t%r9, 0x8(%r10)\t\t# Load stack parameter size.\n+\tltgr\t%r9, %r9\t\t# Check if it's 0.\n+\tje\t.Lnostackparm\t\t# Skip the copy if not needed.\n+\tsgr\t%r15, %r9\t\t# Make space on the stack.\n+\tla\t%r8, 0xa0(%r15)\t\t# Destination.\n+\tla\t%r12, 0xa0(%r11)\t# Source.\n+\tlgr\t%r13, %r9\t\t# Source size.\n+.Lcopy:\n+\tmvcle\t%r8, %r12, 0\t\t# Copy.\n+\tjo\t.Lcopy\n+\n+.Lnostackparm:\n+\t# Third parameter is address of function meat - address of parameter\n+\t# block.\n+\tag\t%r10, 0x10(%r10)\n+\n+\t# Leave vararg pointer in %r1, in case function uses it\n+\tla\t%r1, 0xa0(%r11)\n+\n+\t# OK, no stack allocation needed.  We still follow the protocol and\n+\t# call our caller - it doesn't cost much and makes sure vararg works.\n+\t# No need to set any registers here - %r0 and %r2-%r6 weren't modified.\n+\tbasr\t%r14, %r10\t\t# Call our caller.\n+\n+\tlmg\t%r6, %r15, 0x30(%r11)\t# Restore all callee-saved registers.\n+\t.cfi_remember_state\n+\t.cfi_restore %r15\n+\t.cfi_restore %r14\n+\t.cfi_restore %r13\n+\t.cfi_restore %r12\n+\t.cfi_restore %r11\n+\t.cfi_restore %r10\n+\t.cfi_restore %r9\n+\t.cfi_restore %r8\n+\t.cfi_restore %r7\n+\t.cfi_restore %r6\n+\t.cfi_def_cfa_register %r15\n+\tbr\t%r14\t\t\t# Return to caller's caller.\n+\n+# This is the cleanup code called by the stack unwinder when unwinding\n+# through the code between .LEHB0 and .LEHE0 above.\n+\n+.L1:\n+\t.cfi_restore_state\n+\tlgr\t%r2, %r11\t\t# Stack pointer after resume.\n+\tbrasl\t%r14, __generic_findstack\n+\tlgr\t%r3, %r11\t\t# Get the stack pointer.\n+\tsgr\t%r3, %r2\t\t# Subtract available space.\n+\taghi\t%r3, BACKOFF\t\t# Back off a bit.\n+\tear\t%r1, %a0\n+\tsllg\t%r1, %r1, 32\n+\tear\t%r1, %a1\t\t# Extract thread pointer.\n+\tstg\t%r3, 0x38(%r1)\t# Save the new stack boundary.\n+\n+\tlgr\t%r2, %r6\t\t# Exception header.\n+#ifdef __PIC__\n+\tbrasl\t%r14, _Unwind_Resume@PLT\n+#else\n+\tbrasl\t%r14, _Unwind_Resume\n+#endif\n+\n+#endif /* defined(__s390x__) */\n+\n+\t.cfi_endproc\n+\t.size\t__morestack, . - __morestack\n+\n+\n+# The exception table.  This tells the personality routine to execute\n+# the exception handler.\n+\n+\t.section\t.gcc_except_table,\"a\",@progbits\n+\t.align\t4\n+.LLSDA1:\n+\t.byte\t0xff\t# @LPStart format (omit)\n+\t.byte\t0xff\t# @TType format (omit)\n+\t.byte\t0x1\t# call-site format (uleb128)\n+\t.uleb128 .LLSDACSE1-.LLSDACSB1\t# Call-site table length\n+.LLSDACSB1:\n+\t.uleb128 .LEHB0-.LFB1\t# region 0 start\n+\t.uleb128 .LEHE0-.LEHB0\t# length\n+\t.uleb128 .L1-.LFB1\t# landing pad\n+\t.uleb128 0\t\t# action\n+.LLSDACSE1:\n+\n+\n+\t.global __gcc_personality_v0\n+#ifdef __PIC__\n+\t# Build a position independent reference to the basic\n+\t# personality function.\n+\t.hidden DW.ref.__gcc_personality_v0\n+\t.weak   DW.ref.__gcc_personality_v0\n+\t.section .data.DW.ref.__gcc_personality_v0,\"awG\",@progbits,DW.ref.__gcc_personality_v0,comdat\n+\t.type\tDW.ref.__gcc_personality_v0, @object\n+DW.ref.__gcc_personality_v0:\n+#ifndef __LP64__\n+\t.align 4\n+\t.size\tDW.ref.__gcc_personality_v0, 4\n+\t.long\t__gcc_personality_v0\n+#else\n+\t.align 8\n+\t.size\tDW.ref.__gcc_personality_v0, 8\n+\t.quad\t__gcc_personality_v0\n+#endif\n+#endif\n+\n+\n+\n+# Initialize the stack test value when the program starts or when a\n+# new thread starts.  We don't know how large the main stack is, so we\n+# guess conservatively.  We might be able to use getrlimit here.\n+\n+\t.text\n+\t.global\t__stack_split_initialize\n+\t.hidden\t__stack_split_initialize\n+\n+\t.type\t__stack_split_initialize, @function\n+\n+__stack_split_initialize:\n+\n+#ifndef __s390x__\n+\n+\tear\t%r1, %a0\n+\tlr\t%r0, %r15\n+\tahi\t%r0, -0x4000\t# We should have at least 16K.\n+\tst\t%r0, 0x20(%r1)\n+\n+\tlr\t%r2, %r15\n+\tlhi\t%r3, 0x4000\n+#ifdef __PIC__\n+\tjg\t__generic_morestack_set_initial_sp@PLT\t# Tail call\n+#else\n+\tjg\t__generic_morestack_set_initial_sp\t# Tail call\n+#endif\n+\n+#else /* defined(__s390x__) */\n+\n+\tear\t%r1, %a0\n+\tsllg\t%r1, %r1, 32\n+\tear\t%r1, %a1\n+\tlgr\t%r0, %r15\n+\taghi\t%r0, -0x4000\t# We should have at least 16K.\n+\tstg\t%r0, 0x38(%r1)\n+\n+\tlgr\t%r2, %r15\n+\tlghi\t%r3, 0x4000\n+#ifdef __PIC__\n+\tjg\t__generic_morestack_set_initial_sp@PLT\t# Tail call\n+#else\n+\tjg\t__generic_morestack_set_initial_sp\t# Tail call\n+#endif\n+\n+#endif /* defined(__s390x__) */\n+\n+\t.size\t__stack_split_initialize, . - __stack_split_initialize\n+\n+# Routines to get and set the guard, for __splitstack_getcontext,\n+# __splitstack_setcontext, and __splitstack_makecontext.\n+\n+# void *__morestack_get_guard (void) returns the current stack guard.\n+\t.text\n+\t.global\t__morestack_get_guard\n+\t.hidden\t__morestack_get_guard\n+\n+\t.type\t__morestack_get_guard,@function\n+\n+__morestack_get_guard:\n+\n+#ifndef __s390x__\n+\tear\t%r1, %a0\n+\tl\t%r2, 0x20(%r1)\n+#else\n+\tear\t%r1, %a0\n+\tsllg\t%r1, %r1, 32\n+\tear\t%r1, %a1\n+\tlg\t%r2, 0x38(%r1)\n+#endif\n+\tbr %r14\n+\n+\t.size\t__morestack_get_guard, . - __morestack_get_guard\n+\n+# void __morestack_set_guard (void *) sets the stack guard.\n+\t.global\t__morestack_set_guard\n+\t.hidden\t__morestack_set_guard\n+\n+\t.type\t__morestack_set_guard,@function\n+\n+__morestack_set_guard:\n+\n+#ifndef __s390x__\n+\tear\t%r1, %a0\n+\tst\t%r2, 0x20(%r1)\n+#else\n+\tear\t%r1, %a0\n+\tsllg\t%r1, %r1, 32\n+\tear\t%r1, %a1\n+\tstg\t%r2, 0x38(%r1)\n+#endif\n+\tbr\t%r14\n+\n+\t.size\t__morestack_set_guard, . - __morestack_set_guard\n+\n+# void *__morestack_make_guard (void *, size_t) returns the stack\n+# guard value for a stack.\n+\t.global\t__morestack_make_guard\n+\t.hidden\t__morestack_make_guard\n+\n+\t.type\t__morestack_make_guard,@function\n+\n+__morestack_make_guard:\n+\n+#ifndef __s390x__\n+\tsr\t%r2, %r3\n+\tahi\t%r2, BACKOFF\n+#else\n+\tsgr\t%r2, %r3\n+\taghi\t%r2, BACKOFF\n+#endif\n+\tbr\t%r14\n+\n+\t.size\t__morestack_make_guard, . - __morestack_make_guard\n+\n+# Make __stack_split_initialize a high priority constructor.\n+\n+\t.section .ctors.65535,\"aw\",@progbits\n+\n+#ifndef __LP64__\n+\t.align\t4\n+\t.long\t__stack_split_initialize\n+\t.long\t__morestack_load_mmap\n+#else\n+\t.align\t8\n+\t.quad\t__stack_split_initialize\n+\t.quad\t__morestack_load_mmap\n+#endif\n+\n+\t.section\t.note.GNU-stack,\"\",@progbits\n+\t.section\t.note.GNU-split-stack,\"\",@progbits\n+\t.section\t.note.GNU-no-split-stack,\"\",@progbits"}, {"sha": "4c959b036de955b873bff4ff43422ed5309e4354", "filename": "libgcc/config/s390/t-stack-s390", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cb4721f9371ac318e33cbed99a66a029353e10a/libgcc%2Fconfig%2Fs390%2Ft-stack-s390", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cb4721f9371ac318e33cbed99a66a029353e10a/libgcc%2Fconfig%2Fs390%2Ft-stack-s390", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fs390%2Ft-stack-s390?ref=4cb4721f9371ac318e33cbed99a66a029353e10a", "patch": "@@ -0,0 +1,2 @@\n+# Makefile fragment to support -fsplit-stack for s390.\n+LIB2ADD_ST += $(srcdir)/config/s390/morestack.S"}, {"sha": "b8eec4e739535d29917373534d18822009e572f5", "filename": "libgcc/generic-morestack.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cb4721f9371ac318e33cbed99a66a029353e10a/libgcc%2Fgeneric-morestack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cb4721f9371ac318e33cbed99a66a029353e10a/libgcc%2Fgeneric-morestack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fgeneric-morestack.c?ref=4cb4721f9371ac318e33cbed99a66a029353e10a", "patch": "@@ -939,6 +939,10 @@ __splitstack_find (void *segment_arg, void *sp, size_t *len,\n #elif defined (__i386__)\n       nsp -= 6 * sizeof (void *);\n #elif defined __powerpc64__\n+#elif defined __s390x__\n+      nsp -= 2 * 160;\n+#elif defined __s390__\n+      nsp -= 2 * 96;\n #else\n #error \"unrecognized target\"\n #endif"}]}