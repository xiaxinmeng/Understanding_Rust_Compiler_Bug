{"sha": "40e02b4a76a59504e2708e7012dddd0eafb9d423", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBlMDJiNGE3NmE1OTUwNGUyNzA4ZTcwMTJkZGRkMGVhZmI5ZDQyMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-02-03T23:53:48Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-02-03T23:53:48Z"}, "message": "alias.c (find_base_term, get_addr): Do not dereference NULL pointer when all VALUE's locations has been invalidated.\n\n\t* alias.c (find_base_term, get_addr):  Do not dereference NULL\n\tpointer when all VALUE's locations has been invalidated.\n\t(rtx_equal_for_memref_p): Simplify checking of VALUEs.\n\nFrom-SVN: r77201", "tree": {"sha": "e424fd93830b970cdf079b0ff3e3a0b50f7ca486", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e424fd93830b970cdf079b0ff3e3a0b50f7ca486"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40e02b4a76a59504e2708e7012dddd0eafb9d423", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40e02b4a76a59504e2708e7012dddd0eafb9d423", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40e02b4a76a59504e2708e7012dddd0eafb9d423", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40e02b4a76a59504e2708e7012dddd0eafb9d423/comments", "author": null, "committer": null, "parents": [{"sha": "1c02f6f2d28a9f8cfe03a0e79356ddec64f8ad8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c02f6f2d28a9f8cfe03a0e79356ddec64f8ad8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c02f6f2d28a9f8cfe03a0e79356ddec64f8ad8f"}], "stats": {"total": 31, "additions": 20, "deletions": 11}, "files": [{"sha": "cdf9076f30a7220087e2548e83e60dd497cbaed0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e02b4a76a59504e2708e7012dddd0eafb9d423/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e02b4a76a59504e2708e7012dddd0eafb9d423/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40e02b4a76a59504e2708e7012dddd0eafb9d423", "patch": "@@ -1,3 +1,9 @@\n+2004-02-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* alias.c (find_base_term, get_addr):  Do not dereference NULL\n+\tpointer when all VALUE's locations has been invalidated.\n+\t(rtx_equal_for_memref_p): Simplify checking of VALUEs.\n+\n 2004-02-03  Wolfgang Bangerth  <bangerth@dealii.org> \n \n \t* doc/invoke.texi (x86 options): Fix spelling/wording."}, {"sha": "f0cfe4cf7a3554482d59b980aea6abe241f751b7", "filename": "gcc/alias.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40e02b4a76a59504e2708e7012dddd0eafb9d423/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40e02b4a76a59504e2708e7012dddd0eafb9d423/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=40e02b4a76a59504e2708e7012dddd0eafb9d423", "patch": "@@ -1139,9 +1139,6 @@ rtx_equal_for_memref_p (rtx x, rtx y)\n   /* Some RTL can be compared without a recursive examination.  */\n   switch (code)\n     {\n-    case VALUE:\n-      return CSELIB_VAL_PTR (x) == CSELIB_VAL_PTR (y);\n-\n     case REG:\n       return REGNO (x) == REGNO (y);\n \n@@ -1151,6 +1148,7 @@ rtx_equal_for_memref_p (rtx x, rtx y)\n     case SYMBOL_REF:\n       return XSTR (x, 0) == XSTR (y, 0);\n \n+    case VALUE:\n     case CONST_INT:\n     case CONST_DOUBLE:\n       /* There's no need to compare the contents of CONST_DOUBLEs or\n@@ -1325,6 +1323,8 @@ find_base_term (rtx x)\n \n     case VALUE:\n       val = CSELIB_VAL_PTR (x);\n+      if (!val)\n+\treturn 0;\n       for (l = val->locs; l; l = l->next)\n \tif ((x = find_base_term (l->loc)) != 0)\n \t  return x;\n@@ -1502,14 +1502,17 @@ get_addr (rtx x)\n   if (GET_CODE (x) != VALUE)\n     return x;\n   v = CSELIB_VAL_PTR (x);\n-  for (l = v->locs; l; l = l->next)\n-    if (CONSTANT_P (l->loc))\n-      return l->loc;\n-  for (l = v->locs; l; l = l->next)\n-    if (GET_CODE (l->loc) != REG && GET_CODE (l->loc) != MEM)\n-      return l->loc;\n-  if (v->locs)\n-    return v->locs->loc;\n+  if (v)\n+    {\n+      for (l = v->locs; l; l = l->next)\n+\tif (CONSTANT_P (l->loc))\n+\t  return l->loc;\n+      for (l = v->locs; l; l = l->next)\n+\tif (GET_CODE (l->loc) != REG && GET_CODE (l->loc) != MEM)\n+\t  return l->loc;\n+      if (v->locs)\n+\treturn v->locs->loc;\n+    }\n   return x;\n }\n "}]}