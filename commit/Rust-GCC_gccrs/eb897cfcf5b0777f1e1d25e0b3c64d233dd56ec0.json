{"sha": "eb897cfcf5b0777f1e1d25e0b3c64d233dd56ec0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI4OTdjZmNmNWIwNzc3ZjFlMWQyNWUwYjNjNjRkMjMzZGQ1NmVjMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2016-05-30T13:25:02Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-05-30T13:25:02Z"}, "message": "tree-ssa-loop-ivcanon.c (try_peel_loop): Correctly set wont_exit for peeled copies...\n\n\t* tree-ssa-loop-ivcanon.c (try_peel_loop): Correctly set wont_exit\n\tfor peeled copies; avoid underflow when updating estimates; correctly\n\tscale loop profile.\n\nFrom-SVN: r236878", "tree": {"sha": "d72e73c8aa02c293d7c033c633958574e92570c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d72e73c8aa02c293d7c033c633958574e92570c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb897cfcf5b0777f1e1d25e0b3c64d233dd56ec0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb897cfcf5b0777f1e1d25e0b3c64d233dd56ec0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb897cfcf5b0777f1e1d25e0b3c64d233dd56ec0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb897cfcf5b0777f1e1d25e0b3c64d233dd56ec0/comments", "author": null, "committer": null, "parents": [{"sha": "5750980942ac1ed0ddb4b42c8089c522509eeca5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5750980942ac1ed0ddb4b42c8089c522509eeca5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5750980942ac1ed0ddb4b42c8089c522509eeca5"}], "stats": {"total": 74, "additions": 63, "deletions": 11}, "files": [{"sha": "82d3683c73dd98d1ee3b4bb505e82539a7063c5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb897cfcf5b0777f1e1d25e0b3c64d233dd56ec0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb897cfcf5b0777f1e1d25e0b3c64d233dd56ec0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb897cfcf5b0777f1e1d25e0b3c64d233dd56ec0", "patch": "@@ -1,3 +1,9 @@\n+2016-05-30  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-ssa-loop-ivcanon.c (try_peel_loop): Correctly set wont_exit\n+\tfor peeled copies; avoid underflow when updating estimates; correctly\n+\tscale loop profile.\n+\n 2016-05-30  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \t* tree-ssa-reassoc.ci (swap_ops_for_binary_stmt): Fix typo from commit"}, {"sha": "4cfdb27bb67071423da1a37f183c0ceafe5bcf9d", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 57, "deletions": 11, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb897cfcf5b0777f1e1d25e0b3c64d233dd56ec0/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb897cfcf5b0777f1e1d25e0b3c64d233dd56ec0/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=eb897cfcf5b0777f1e1d25e0b3c64d233dd56ec0", "patch": "@@ -970,7 +970,9 @@ try_peel_loop (struct loop *loop,\n   if (!flag_peel_loops || PARAM_VALUE (PARAM_MAX_PEEL_TIMES) <= 0)\n     return false;\n \n-  /* Peel only innermost loops.  */\n+  /* Peel only innermost loops.\n+     While the code is perfectly capable of peeling non-innermost loops,\n+     the heuristics would probably need some improvements. */\n   if (loop->inner)\n     {\n       if (dump_file)\n@@ -1029,13 +1031,23 @@ try_peel_loop (struct loop *loop,\n   /* Duplicate possibly eliminating the exits.  */\n   initialize_original_copy_tables ();\n   wont_exit = sbitmap_alloc (npeel + 1);\n-  bitmap_ones (wont_exit);\n-  bitmap_clear_bit (wont_exit, 0);\n+  if (exit && niter\n+      && TREE_CODE (niter) == INTEGER_CST\n+      && wi::leu_p (npeel, wi::to_widest (niter)))\n+    {\n+      bitmap_ones (wont_exit);\n+      if (wi::eq_p (wi::to_widest (niter), npeel))\n+        bitmap_clear_bit (wont_exit, 0);\n+    }\n+  else\n+    {\n+      exit = NULL;\n+      bitmap_clear (wont_exit);\n+    }\n   if (!gimple_duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\t\t\t\t     npeel, wont_exit,\n \t\t\t\t\t     exit, &to_remove,\n-\t\t\t\t\t     DLTHE_FLAG_UPDATE_FREQ\n-\t\t\t\t\t     | DLTHE_FLAG_COMPLETTE_PEEL))\n+\t\t\t\t\t     DLTHE_FLAG_UPDATE_FREQ))\n     {\n       free_original_copy_tables ();\n       free (wont_exit);\n@@ -1053,14 +1065,48 @@ try_peel_loop (struct loop *loop,\n       fprintf (dump_file, \"Peeled loop %d, %i times.\\n\",\n \t       loop->num, (int) npeel);\n     }\n+  if (loop->any_estimate)\n+    {\n+      if (wi::ltu_p (npeel, loop->nb_iterations_estimate))\n+        loop->nb_iterations_estimate -= npeel;\n+      else\n+\tloop->nb_iterations_estimate = 0;\n+    }\n   if (loop->any_upper_bound)\n-    loop->nb_iterations_upper_bound -= npeel;\n+    {\n+      if (wi::ltu_p (npeel, loop->nb_iterations_estimate))\n+        loop->nb_iterations_upper_bound -= npeel;\n+      else\n+        loop->nb_iterations_upper_bound = 0;\n+    }\n   if (loop->any_likely_upper_bound)\n-    loop->nb_iterations_likely_upper_bound -= npeel;\n-  loop->nb_iterations_estimate = 0;\n-  /* Make sure to mark loop cold so we do not try to peel it more.  */\n-  scale_loop_profile (loop, 1, 0);\n-  loop->header->count = 0;\n+    {\n+      if (wi::ltu_p (npeel, loop->nb_iterations_estimate))\n+\tloop->nb_iterations_likely_upper_bound -= npeel;\n+      else\n+\t{\n+\t  loop->any_estimate = true;\n+\t  loop->nb_iterations_estimate = 0;\n+\t  loop->nb_iterations_likely_upper_bound = 0;\n+\t}\n+    }\n+  gcov_type entry_count = 0;\n+  int entry_freq = 0;\n+\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, loop->header->preds)\n+    if (e->src != loop->latch)\n+      {\n+\tentry_count += e->src->count;\n+\tentry_freq += e->src->frequency;\n+\tgcc_assert (!flow_bb_inside_loop_p (loop, e->src));\n+      }\n+  int scale = 1;\n+  if (loop->header->count)\n+    scale = RDIV (entry_count * REG_BR_PROB_BASE, loop->header->count);\n+  else if (loop->header->frequency)\n+    scale = RDIV (entry_freq * REG_BR_PROB_BASE, loop->header->frequency);\n+  scale_loop_profile (loop, scale, 0);\n   return true;\n }\n /* Adds a canonical induction variable to LOOP if suitable."}]}