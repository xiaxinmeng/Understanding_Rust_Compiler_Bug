{"sha": "2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRlZTY5NWJmYzlkOTM4NGFhMThlOWU4YTdmYmM4MjJhMThlNDNjNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-01-06T17:58:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-01-06T17:58:40Z"}, "message": "tree-pass.h (pass_build_cgraph_edges): Declare.\n\n\t* tree-pass.h (pass_build_cgraph_edges): Declare.\n\t* cgraphunit.c (record_refernece): Move to cgraphbuild.c\n\t(visited_nodes): Remove.\n\t(cgraph_create_edges): Move to cgraphbuild.c; rename to\n\tbuild_cgrpah_edges; make visited_nodes local.\n\t(cgraph_process_new_functions): DO not call initialize_inline_failed.\n\t(record_references_in_initializer): Move to cgraphbuild.c\n\t(initialize_inline_failed, rebuild_cgraph_edges,\n\tpass_rebuild_cgraph_edges): Move to cgraphbuild.c.\n\t(verify_cgraph_node): Make visited_nodes local.\n\t(cgraph_analyze_function): Do not call cgraph_create_edges and\n\tinitialize_inline_failed.\n\t(cgraph_expand_function): Do not call cgraph_lower_function;\n\tassert that function is already lowered.\n\t* Makefile.in (cgraphbuild.o): New.\n\t* passes.c (init_optimization_passes): Add pass_build_cgraph_edges\n\tat the end of lowering passes.\n\nFrom-SVN: r120527", "tree": {"sha": "4376eec55302164500ff8b5a68d63b436c80b4c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4376eec55302164500ff8b5a68d63b436c80b4c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6/comments", "author": null, "committer": null, "parents": [{"sha": "dc1f5a111805364e5311333cb2d0e7522034a258", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc1f5a111805364e5311333cb2d0e7522034a258", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc1f5a111805364e5311333cb2d0e7522034a258"}], "stats": {"total": 465, "additions": 265, "deletions": 200}, "files": [{"sha": "74eb580e49ec8ef09c6b8d29b9f3a8fa8dbfe1a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6", "patch": "@@ -1,3 +1,23 @@\n+2007-01-06  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-pass.h (pass_build_cgraph_edges): Declare.\n+\t* cgraphunit.c (record_refernece): Move to cgraphbuild.c\n+\t(visited_nodes): Remove.\n+\t(cgraph_create_edges): Move to cgraphbuild.c; rename to\n+\tbuild_cgrpah_edges; make visited_nodes local.\n+\t(cgraph_process_new_functions): DO not call initialize_inline_failed.\n+\t(record_references_in_initializer): Move to cgraphbuild.c\n+\t(initialize_inline_failed, rebuild_cgraph_edges,\n+\tpass_rebuild_cgraph_edges): Move to cgraphbuild.c.\n+\t(verify_cgraph_node): Make visited_nodes local.\n+\t(cgraph_analyze_function): Do not call cgraph_create_edges and\n+\tinitialize_inline_failed.\n+\t(cgraph_expand_function): Do not call cgraph_lower_function;\n+\tassert that function is already lowered.\n+\t* Makefile.in (cgraphbuild.o): New.\n+\t* passes.c (init_optimization_passes): Add pass_build_cgraph_edges\n+\tat the end of lowering passes.\n+\n 2007-01-06  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* ifcvt.c (cond_move_convert_if_block): New function, code"}, {"sha": "1ec937a9d57013359d4cde9f84d6dc23cf1b5f70", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6", "patch": "@@ -1014,7 +1014,7 @@ OBJS-common = \\\n \n OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) tree-inline.o\t\t   \\\n-  cgraph.o cgraphunit.o tree-nomudflap.o ipa.o ipa-inline.o                \\\n+  cgraph.o cgraphunit.o cgraphbuild.o tree-nomudflap.o ipa.o ipa-inline.o  \\\n   ipa-utils.o ipa-reference.o ipa-pure-const.o ipa-type-escape.o           \\\n   ipa-prop.o ipa-cp.o varpool.o\n \n@@ -2269,6 +2269,9 @@ cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TARGET_H) $(CGRAPH_H) intl.h pointer-set.h $(FUNCTION_H) $(TREE_GIMPLE_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(C_COMMON_H) debug.h $(DIAGNOSTIC_H) \\\n    $(FIBHEAP_H) output.h $(PARAMS_H) $(RTL_H) $(TIMEVAR_H) ipa-prop.h \n+cgraphbuild.o : cgraphbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(TREE_H) langhooks.h $(CGRAPH_H) intl.h pointer-set.h $(TREE_GIMPLE_H) \\\n+   $(TREE_FLOW_H) tree-pass.h \n varpool.o : varpool.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) toplev.h $(FLAGS_H) $(GGC_H) \\\n    $(TARGET_H) $(CGRAPH_H) intl.h pointer-set.h $(FUNCTION_H) $(TREE_GIMPLE_H) \\"}, {"sha": "a2df564aa655bbb3150c4db7eb603ec228eb1342", "filename": "gcc/cgraphbuild.c", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6", "patch": "@@ -0,0 +1,236 @@\n+/* Callgraph construction.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"tree-flow.h\"\n+#include \"langhooks.h\"\n+#include \"pointer-set.h\"\n+#include \"cgraph.h\"\n+#include \"intl.h\"\n+#include \"tree-gimple.h\"\n+#include \"tree-pass.h\"\n+\n+/* Walk tree and record all calls and references to functions/variables.\n+   Called via walk_tree: TP is pointer to tree to be examined.  */\n+\n+static tree\n+record_reference (tree *tp, int *walk_subtrees, void *data)\n+{\n+  tree t = *tp;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case VAR_DECL:\n+      if (TREE_STATIC (t) || DECL_EXTERNAL (t))\n+\t{\n+\t  varpool_mark_needed_node (varpool_node (t));\n+\t  if (lang_hooks.callgraph.analyze_expr)\n+\t    return lang_hooks.callgraph.analyze_expr (tp, walk_subtrees,\n+\t\t\t\t\t\t      data);\n+\t}\n+      break;\n+\n+    case FDESC_EXPR:\n+    case ADDR_EXPR:\n+      if (flag_unit_at_a_time)\n+\t{\n+\t  /* Record dereferences to the functions.  This makes the\n+\t     functions reachable unconditionally.  */\n+\t  tree decl = TREE_OPERAND (*tp, 0);\n+\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t    cgraph_mark_needed_node (cgraph_node (decl));\n+\t}\n+      break;\n+\n+    default:\n+      /* Save some cycles by not walking types and declaration as we\n+\t won't find anything useful there anyway.  */\n+      if (IS_TYPE_OR_DECL_P (*tp))\n+\t{\n+\t  *walk_subtrees = 0;\n+\t  break;\n+\t}\n+\n+      if ((unsigned int) TREE_CODE (t) >= LAST_AND_UNUSED_TREE_CODE)\n+\treturn lang_hooks.callgraph.analyze_expr (tp, walk_subtrees, data);\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Give initial reasons why inlining would fail on all calls from\n+   NODE.  Those get either nullified or usually overwritten by more precise\n+   reason later.  */\n+\n+static void\n+initialize_inline_failed (struct cgraph_node *node)\n+{\n+  struct cgraph_edge *e;\n+\n+  for (e = node->callers; e; e = e->next_caller)\n+    {\n+      gcc_assert (!e->callee->global.inlined_to);\n+      gcc_assert (e->inline_failed);\n+      if (node->local.redefined_extern_inline)\n+\te->inline_failed = N_(\"redefined extern inline functions are not \"\n+\t\t\t   \"considered for inlining\");\n+      else if (!node->local.inlinable)\n+\te->inline_failed = N_(\"function not inlinable\");\n+      else\n+\te->inline_failed = N_(\"function not considered for inlining\");\n+    }\n+}\n+\n+/* Create cgraph edges for function calls.\n+   Also look for functions and variables having addresses taken.  */\n+\n+static unsigned int\n+build_cgraph_edges (void)\n+{\n+  basic_block bb;\n+  struct cgraph_node *node = cgraph_node (current_function_decl);\n+  struct pointer_set_t *visited_nodes = pointer_set_create ();\n+  block_stmt_iterator bsi;\n+  tree step;\n+\n+  /* Create the callgraph edges and record the nodes referenced by the function.\n+     body.  */\n+  FOR_EACH_BB (bb)\n+    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+      {\n+\ttree stmt = bsi_stmt (bsi);\n+\ttree call = get_call_expr_in (stmt);\n+\ttree decl;\n+\n+\tif (call && (decl = get_callee_fndecl (call)))\n+\t  {\n+\t    cgraph_create_edge (node, cgraph_node (decl), stmt,\n+\t\t\t\tbb->count,\n+\t\t\t\tbb->loop_depth);\n+\t    walk_tree (&TREE_OPERAND (call, 1),\n+\t\t       record_reference, node, visited_nodes);\n+\t    if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n+\t      walk_tree (&GIMPLE_STMT_OPERAND (stmt, 0),\n+\t\t\t record_reference, node, visited_nodes);\n+\t  }\n+\telse\n+\t  walk_tree (bsi_stmt_ptr (bsi), record_reference, node, visited_nodes);\n+      }\n+\n+  /* Look for initializers of constant variables and private statics.  */\n+  for (step = cfun->unexpanded_var_list;\n+       step;\n+       step = TREE_CHAIN (step))\n+    {\n+      tree decl = TREE_VALUE (step);\n+      if (TREE_CODE (decl) == VAR_DECL\n+\t  && (TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n+\t  && flag_unit_at_a_time)\n+\tvarpool_finalize_decl (decl);\n+      else if (TREE_CODE (decl) == VAR_DECL && DECL_INITIAL (decl))\n+\twalk_tree (&DECL_INITIAL (decl), record_reference, node, visited_nodes);\n+    }\n+\n+  pointer_set_destroy (visited_nodes);\n+  initialize_inline_failed (node);\n+  return 0;\n+}\n+\n+struct tree_opt_pass pass_build_cgraph_edges =\n+{\n+  NULL,\t\t\t\t\t/* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  build_cgraph_edges,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_cfg,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0,\t\t\t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n+\n+/* Record references to functions and other variables present in the\n+   initial value of DECL, a variable.  */\n+\n+void\n+record_references_in_initializer (tree decl)\n+{\n+  struct pointer_set_t *visited_nodes = pointer_set_create ();\n+  walk_tree (&DECL_INITIAL (decl), record_reference, NULL, visited_nodes);\n+  pointer_set_destroy (visited_nodes);\n+}\n+\n+/* Rebuild cgraph edges for current function node.  This needs to be run after\n+   passes that don't update the cgraph.  */\n+\n+static unsigned int\n+rebuild_cgraph_edges (void)\n+{\n+  basic_block bb;\n+  struct cgraph_node *node = cgraph_node (current_function_decl);\n+  block_stmt_iterator bsi;\n+\n+  cgraph_node_remove_callees (node);\n+\n+  node->count = ENTRY_BLOCK_PTR->count;\n+\n+  FOR_EACH_BB (bb)\n+    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+      {\n+\ttree stmt = bsi_stmt (bsi);\n+\ttree call = get_call_expr_in (stmt);\n+\ttree decl;\n+\n+\tif (call && (decl = get_callee_fndecl (call)))\n+\t  cgraph_create_edge (node, cgraph_node (decl), stmt,\n+\t\t\t      bb->count,\n+\t\t\t      bb->loop_depth);\n+      }\n+  initialize_inline_failed (node);\n+  gcc_assert (!node->global.inlined_to);\n+  return 0;\n+}\n+\n+struct tree_opt_pass pass_rebuild_cgraph_edges =\n+{\n+  NULL,\t\t\t\t\t/* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  rebuild_cgraph_edges,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_cfg,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0,\t\t\t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};"}, {"sha": "e6f9db4a22c0804c1d49602464d99ae4f53a89de", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 3, "deletions": 199, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6", "patch": "@@ -164,16 +164,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n static void cgraph_expand_all_functions (void);\n static void cgraph_mark_functions_to_output (void);\n static void cgraph_expand_function (struct cgraph_node *);\n-static tree record_reference (tree *, int *, void *);\n static void cgraph_output_pending_asms (void);\n static void cgraph_increase_alignment (void);\n-static void initialize_inline_failed (struct cgraph_node *);\n-\n-/* Records tree nodes seen in record_reference.  Simply using\n-   walk_tree_without_duplicates doesn't guarantee each node is visited\n-   once because it gets a new htab upon each recursive call from\n-   record_reference itself.  */\n-static struct pointer_set_t *visited_nodes;\n \n static FILE *cgraph_dump_file;\n \n@@ -311,7 +303,6 @@ cgraph_process_new_functions (void)\n \t  /* Inlining characteristics are maintained by the\n \t     cgraph_mark_inline.  */\n \t  node->global.insns = node->local.self_insns;\n-\t  initialize_inline_failed (node);\n \t  if (flag_really_no_inline && !node->local.disregard_inline_limits)\n \t     node->local.inlinable = 0;\n \t  if ((cgraph_state == CGRAPH_STATE_IPA_SSA\n@@ -495,189 +486,6 @@ cgraph_finalize_function (tree decl, bool nested)\n     do_warn_unused_parameter (decl);\n }\n \n-/* Walk tree and record all calls.  Called via walk_tree.  */\n-static tree\n-record_reference (tree *tp, int *walk_subtrees, void *data)\n-{\n-  tree t = *tp;\n-\n-  switch (TREE_CODE (t))\n-    {\n-    case VAR_DECL:\n-      /* ??? Really, we should mark this decl as *potentially* referenced\n-\t by this function and re-examine whether the decl is actually used\n-\t after rtl has been generated.  */\n-      if (TREE_STATIC (t) || DECL_EXTERNAL (t))\n-\t{\n-\t  varpool_mark_needed_node (varpool_node (t));\n-\t  if (lang_hooks.callgraph.analyze_expr)\n-\t    return lang_hooks.callgraph.analyze_expr (tp, walk_subtrees,\n-\t\t\t\t\t\t      data);\n-\t}\n-      break;\n-\n-    case FDESC_EXPR:\n-    case ADDR_EXPR:\n-      if (flag_unit_at_a_time)\n-\t{\n-\t  /* Record dereferences to the functions.  This makes the\n-\t     functions reachable unconditionally.  */\n-\t  tree decl = TREE_OPERAND (*tp, 0);\n-\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t    cgraph_mark_needed_node (cgraph_node (decl));\n-\t}\n-      break;\n-\n-    default:\n-      /* Save some cycles by not walking types and declaration as we\n-\t won't find anything useful there anyway.  */\n-      if (IS_TYPE_OR_DECL_P (*tp))\n-\t{\n-\t  *walk_subtrees = 0;\n-\t  break;\n-\t}\n-\n-      if ((unsigned int) TREE_CODE (t) >= LAST_AND_UNUSED_TREE_CODE)\n-\treturn lang_hooks.callgraph.analyze_expr (tp, walk_subtrees, data);\n-      break;\n-    }\n-\n-  return NULL;\n-}\n-\n-/* Create cgraph edges for function calls inside BODY from NODE.  */\n-\n-static void\n-cgraph_create_edges (struct cgraph_node *node, tree body)\n-{\n-  basic_block bb;\n-\n-  struct function *this_cfun = DECL_STRUCT_FUNCTION (body);\n-  block_stmt_iterator bsi;\n-  tree step;\n-  visited_nodes = pointer_set_create ();\n-\n-  /* Reach the trees by walking over the CFG, and note the\n-     enclosing basic-blocks in the call edges.  */\n-  FOR_EACH_BB_FN (bb, this_cfun)\n-    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-      {\n-\ttree stmt = bsi_stmt (bsi);\n-\ttree call = get_call_expr_in (stmt);\n-\ttree decl;\n-\n-\tif (call && (decl = get_callee_fndecl (call)))\n-\t  {\n-\t    cgraph_create_edge (node, cgraph_node (decl), stmt,\n-\t\t\t\tbb->count,\n-\t\t\t\tbb->loop_depth);\n-\t    walk_tree (&TREE_OPERAND (call, 1),\n-\t\t       record_reference, node, visited_nodes);\n-\t    if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n-\t      walk_tree (&GIMPLE_STMT_OPERAND (stmt, 0),\n-\t\t\t record_reference, node, visited_nodes);\n-\t  }\n-\telse\n-\t  walk_tree (bsi_stmt_ptr (bsi), record_reference, node, visited_nodes);\n-      }\n-\n-  /* Look for initializers of constant variables and private statics.  */\n-  for (step = DECL_STRUCT_FUNCTION (body)->unexpanded_var_list;\n-       step;\n-       step = TREE_CHAIN (step))\n-    {\n-      tree decl = TREE_VALUE (step);\n-      if (TREE_CODE (decl) == VAR_DECL\n-\t  && (TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n-\t  && flag_unit_at_a_time)\n-\tvarpool_finalize_decl (decl);\n-      else if (TREE_CODE (decl) == VAR_DECL && DECL_INITIAL (decl))\n-\twalk_tree (&DECL_INITIAL (decl), record_reference, node, visited_nodes);\n-    }\n-\n-  pointer_set_destroy (visited_nodes);\n-  visited_nodes = NULL;\n-}\n-\n-void\n-record_references_in_initializer (tree decl)\n-{\n-  visited_nodes = pointer_set_create ();\n-  walk_tree (&DECL_INITIAL (decl), record_reference, NULL, visited_nodes);\n-  pointer_set_destroy (visited_nodes);\n-  visited_nodes = NULL;\n-}\n-\n-\n-/* Give initial reasons why inlining would fail.  Those gets\n-   either NULLified or usually overwritten by more precise reason\n-   later.  */\n-static void\n-initialize_inline_failed (struct cgraph_node *node)\n-{\n-  struct cgraph_edge *e;\n-\n-  for (e = node->callers; e; e = e->next_caller)\n-    {\n-      gcc_assert (!e->callee->global.inlined_to);\n-      gcc_assert (e->inline_failed);\n-      if (node->local.redefined_extern_inline)\n-\te->inline_failed = N_(\"redefined extern inline functions are not \"\n-\t\t\t   \"considered for inlining\");\n-      else if (!node->local.inlinable)\n-\te->inline_failed = N_(\"function not inlinable\");\n-      else\n-\te->inline_failed = N_(\"function not considered for inlining\");\n-    }\n-}\n-\n-/* Rebuild call edges from current function after a passes not aware\n-   of cgraph updating.  */\n-static unsigned int\n-rebuild_cgraph_edges (void)\n-{\n-  basic_block bb;\n-  struct cgraph_node *node = cgraph_node (current_function_decl);\n-  block_stmt_iterator bsi;\n-\n-  cgraph_node_remove_callees (node);\n-\n-  node->count = ENTRY_BLOCK_PTR->count;\n-\n-  FOR_EACH_BB (bb)\n-    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-      {\n-\ttree stmt = bsi_stmt (bsi);\n-\ttree call = get_call_expr_in (stmt);\n-\ttree decl;\n-\n-\tif (call && (decl = get_callee_fndecl (call)))\n-\t  cgraph_create_edge (node, cgraph_node (decl), stmt,\n-\t\t\t      bb->count,\n-\t\t\t      bb->loop_depth);\n-      }\n-  initialize_inline_failed (node);\n-  gcc_assert (!node->global.inlined_to);\n-  return 0;\n-}\n-\n-struct tree_opt_pass pass_rebuild_cgraph_edges =\n-{\n-  NULL,\t\t\t\t\t/* name */\n-  NULL,\t\t\t\t\t/* gate */\n-  rebuild_cgraph_edges,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  0,\t\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0,\t\t\t\t\t/* todo_flags_finish */\n-  0\t\t\t\t\t/* letter */\n-};\n-\n /* Verify cgraph nodes of given cgraph node.  */\n void\n verify_cgraph_node (struct cgraph_node *node)\n@@ -763,7 +571,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t{\n \t  /* The nodes we're interested in are never shared, so walk\n \t     the tree ignoring duplicates.  */\n-\t  visited_nodes = pointer_set_create ();\n+\t  struct pointer_set_t *visited_nodes = pointer_set_create ();\n \t  /* Reach the trees by walking over the CFG, and note the\n \t     enclosing basic-blocks in the call edges.  */\n \t  FOR_EACH_BB_FN (this_block, this_cfun)\n@@ -802,7 +610,6 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t  }\n \t      }\n \t  pointer_set_destroy (visited_nodes);\n-\t  visited_nodes = NULL;\n \t}\n       else\n \t/* No CFG available?!  */\n@@ -867,9 +674,6 @@ cgraph_analyze_function (struct cgraph_node *node)\n   push_cfun (DECL_STRUCT_FUNCTION (decl));\n   cgraph_lower_function (node);\n \n-  /* First kill forward declaration so reverse inlining works properly.  */\n-  cgraph_create_edges (node, decl);\n-\n   node->local.estimated_self_stack_size = estimated_stack_frame_size ();\n   node->global.estimated_stack_size = node->local.estimated_self_stack_size;\n   node->global.stack_frame_offset = 0;\n@@ -879,7 +683,6 @@ cgraph_analyze_function (struct cgraph_node *node)\n   if (node->local.inlinable)\n     node->local.disregard_inline_limits\n       = lang_hooks.tree_inlining.disregard_inline_limits (decl);\n-  initialize_inline_failed (node);\n   if (flag_really_no_inline && !node->local.disregard_inline_limits)\n     node->local.inlinable = 0;\n   /* Inlining characteristics are maintained by the cgraph_mark_inline.  */\n@@ -1167,7 +970,8 @@ cgraph_expand_function (struct cgraph_node *node)\n   if (flag_unit_at_a_time)\n     announce_function (decl);\n \n-  cgraph_lower_function (node);\n+  gcc_assert (node->lowered);\n+  /*cgraph_lower_function (node);*/\n \n   /* Generate RTL for the body of DECL.  */\n   lang_hooks.callgraph.expand_function (decl);"}, {"sha": "91c9f1eff2a1400923b3bb074eb721f4d0ec0535", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6", "patch": "@@ -461,6 +461,7 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_lower_complex_O0);\n   NEXT_PASS (pass_lower_vector);\n   NEXT_PASS (pass_warn_function_return);\n+  NEXT_PASS (pass_build_cgraph_edges);\n   *p = NULL;\n \n   p = &pass_early_local_passes.sub;"}, {"sha": "0cec9d4f993c71b910a4e4955c98a29035a310ad", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=2dee695bfc9d9384aa18e9e8a7fbc822a18e43c6", "patch": "@@ -303,6 +303,7 @@ extern struct tree_opt_pass pass_uncprop;\n extern struct tree_opt_pass pass_return_slot;\n extern struct tree_opt_pass pass_reassoc;\n extern struct tree_opt_pass pass_rebuild_cgraph_edges;\n+extern struct tree_opt_pass pass_build_cgraph_edges;\n extern struct tree_opt_pass pass_reset_cc_flags;\n \n /* IPA Passes */"}]}