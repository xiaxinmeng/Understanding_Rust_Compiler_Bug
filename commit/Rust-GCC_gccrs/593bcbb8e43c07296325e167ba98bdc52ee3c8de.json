{"sha": "593bcbb8e43c07296325e167ba98bdc52ee3c8de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkzYmNiYjhlNDNjMDcyOTYzMjVlMTY3YmE5OGJkYzUyZWUzYzhkZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2013-06-21T00:28:30Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-06-21T00:28:30Z"}, "message": "re PR c++/55149 (capturing VLA in lambda)\n\n\tPR c++/55149\n\t* decl.c (compute_array_index_type): Don't reject VLAs in SFINAE\n\tcontext if we're in C++14 mode.\n\t* tree.c (array_of_runtime_bound_p): Return true for a dependent\n\tbound that is not potentually constant.\n\t* cp-tree.h (DECL_VLA_CAPTURE_P, REFERENCE_VLA_OK): New.\n\t* pt.c (tsubst) [REFERENCE_TYPE]: Check REFERENCE_VLA_OK.\n\t* semantics.c (build_lambda_object): Don't rvalue a VLA capture.\n\t(build_capture_proxy): Set REFERENCE_VLA_OK.\n\t(vla_capture_type): Make it a proper C++ class.\n\t(add_capture): Set DECL_VLA_CAPTURE_P.  Don't pre-digest the\n\tinitializer.\n\nFrom-SVN: r200279", "tree": {"sha": "79e79e7901378ca24afca029f3929fdfbccd7994", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79e79e7901378ca24afca029f3929fdfbccd7994"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/593bcbb8e43c07296325e167ba98bdc52ee3c8de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/593bcbb8e43c07296325e167ba98bdc52ee3c8de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/593bcbb8e43c07296325e167ba98bdc52ee3c8de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/593bcbb8e43c07296325e167ba98bdc52ee3c8de/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8fc95c057c13a936806315026521b505cdbb28c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fc95c057c13a936806315026521b505cdbb28c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fc95c057c13a936806315026521b505cdbb28c9"}], "stats": {"total": 105, "additions": 83, "deletions": 22}, "files": [{"sha": "7f1168e11ef379f7340592a31f9355570dd8efb3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593bcbb8e43c07296325e167ba98bdc52ee3c8de/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593bcbb8e43c07296325e167ba98bdc52ee3c8de/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=593bcbb8e43c07296325e167ba98bdc52ee3c8de", "patch": "@@ -1,5 +1,18 @@\n 2013-06-20  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/55149\n+\t* decl.c (compute_array_index_type): Don't reject VLAs in SFINAE\n+\tcontext if we're in C++14 mode.\n+\t* tree.c (array_of_runtime_bound_p): Return true for a dependent\n+\tbound that is not potentually constant.\n+\t* cp-tree.h (DECL_VLA_CAPTURE_P, REFERENCE_VLA_OK): New.\n+\t* pt.c (tsubst) [REFERENCE_TYPE]: Check REFERENCE_VLA_OK.\n+\t* semantics.c (build_lambda_object): Don't rvalue a VLA capture.\n+\t(build_capture_proxy): Set REFERENCE_VLA_OK.\n+\t(vla_capture_type): Make it a proper C++ class.\n+\t(add_capture): Set DECL_VLA_CAPTURE_P.  Don't pre-digest the\n+\tinitializer.\n+\n \t* decl.c (compute_array_index_type): Use size_one_node.\n \n \t* pt.c (process_partial_specialization): Build a TEMPLATE_DECL for"}, {"sha": "cf54acf0d683e1d95995635451305bb9b2602eb5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593bcbb8e43c07296325e167ba98bdc52ee3c8de/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593bcbb8e43c07296325e167ba98bdc52ee3c8de/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=593bcbb8e43c07296325e167ba98bdc52ee3c8de", "patch": "@@ -126,6 +126,7 @@ c-common.h, not after.\n    5: CLASS_TYPE_P (in RECORD_TYPE and UNION_TYPE)\n       ENUM_FIXED_UNDERLYING_TYPE_P (in ENUMERAL_TYPE)\n       AUTO_IS_DECLTYPE (in TEMPLATE_TYPE_PARM)\n+      REFERENCE_VLA_OK (in REFERENCE_TYPE)\n    6: TYPE_DEPENDENT_P_VALID\n \n    Usage of DECL_LANG_FLAG_?:\n@@ -139,6 +140,7 @@ c-common.h, not after.\n       DECL_MEMBER_TEMPLATE_P (in TEMPLATE_DECL)\n       FUNCTION_PARAMETER_PACK_P (in PARM_DECL)\n       USING_DECL_TYPENAME_P (in USING_DECL)\n+      DECL_VLA_CAPTURE_P (in FIELD_DECL)\n    2: DECL_THIS_EXTERN (in VAR_DECL or FUNCTION_DECL).\n       DECL_IMPLICIT_TYPEDEF_P (in a TYPE_DECL)\n    3: DECL_IN_AGGR_P.\n@@ -2979,6 +2981,11 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n    && (TREE_CODE (TREE_TYPE (TREE_OPERAND ((NODE), 0)))\t\\\n        == REFERENCE_TYPE))\n \n+/* True if NODE is a REFERENCE_TYPE which is OK to instantiate to be a\n+   reference to VLA type, because it's used for VLA capture.  */\n+#define REFERENCE_VLA_OK(NODE) \\\n+  (TYPE_LANG_FLAG_5 (REFERENCE_TYPE_CHECK (NODE)))\n+\n #define NEW_EXPR_USE_GLOBAL(NODE) \\\n   TREE_LANG_FLAG_0 (NEW_EXPR_CHECK (NODE))\n #define DELETE_EXPR_USE_GLOBAL(NODE) \\\n@@ -3616,6 +3623,11 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define DECL_THIS_STATIC(NODE) \\\n   DECL_LANG_FLAG_6 (VAR_FUNCTION_OR_PARM_DECL_CHECK (NODE))\n \n+/* Nonzero for FIELD_DECL node means that this field is a lambda capture\n+   field for an array of runtime bound.  */\n+#define DECL_VLA_CAPTURE_P(NODE) \\\n+  DECL_LANG_FLAG_1 (FIELD_DECL_CHECK (NODE))\n+\n /* Nonzero for FIELD_DECL node means that this field is a base class\n    of the parent object, as opposed to a member field.  */\n #define DECL_FIELD_IS_BASE(NODE) \\"}, {"sha": "225f13122ac9b2702ab0966670fb5d47bacf1204", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593bcbb8e43c07296325e167ba98bdc52ee3c8de/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593bcbb8e43c07296325e167ba98bdc52ee3c8de/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=593bcbb8e43c07296325e167ba98bdc52ee3c8de", "patch": "@@ -8296,7 +8296,8 @@ compute_array_index_type (tree name, tree size, tsubst_flags_t complain)\n   else if (TREE_CONSTANT (size)\n \t   /* We don't allow VLAs at non-function scopes, or during\n \t      tentative template substitution.  */\n-\t   || !at_function_scope_p () || !(complain & tf_error))\n+\t   || !at_function_scope_p ()\n+\t   || (cxx_dialect < cxx1y && !(complain & tf_error)))\n     {\n       if (!(complain & tf_error))\n \treturn error_mark_node;"}, {"sha": "cfabba9e3dd8d63bb7f9063813468712c4d8b33f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593bcbb8e43c07296325e167ba98bdc52ee3c8de/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593bcbb8e43c07296325e167ba98bdc52ee3c8de/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=593bcbb8e43c07296325e167ba98bdc52ee3c8de", "patch": "@@ -11575,7 +11575,9 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  r = cp_build_reference_type (type, TYPE_REF_IS_RVALUE (t));\n \tr = cp_build_qualified_type_real (r, cp_type_quals (t), complain);\n \n-\tif (cxx_dialect >= cxx1y && array_of_runtime_bound_p (type))\n+\tif (cxx_dialect >= cxx1y\n+\t    && !(TREE_CODE (t) == REFERENCE_TYPE && REFERENCE_VLA_OK (t))\n+\t    && array_of_runtime_bound_p (type))\n \t  {\n \t    if (complain & tf_warning_or_error)\n \t      pedwarn"}, {"sha": "135ef74bec0a9645966961ed332b42ccf6080cf5", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593bcbb8e43c07296325e167ba98bdc52ee3c8de/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593bcbb8e43c07296325e167ba98bdc52ee3c8de/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=593bcbb8e43c07296325e167ba98bdc52ee3c8de", "patch": "@@ -9033,6 +9033,7 @@ build_lambda_object (tree lambda_expr)\n       if (TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE)\n \tval = build_array_copy (val);\n       else if (DECL_NORMAL_CAPTURE_P (field)\n+\t       && !DECL_VLA_CAPTURE_P (field)\n \t       && TREE_CODE (TREE_TYPE (field)) != REFERENCE_TYPE)\n \t{\n \t  /* \"the entities that are captured by copy are used to\n@@ -9404,8 +9405,7 @@ build_capture_proxy (tree member)\n \n   type = lambda_proxy_type (object);\n \n-  if (TREE_CODE (type) == RECORD_TYPE\n-      && TYPE_NAME (type) == NULL_TREE)\n+  if (DECL_VLA_CAPTURE_P (member))\n     {\n       /* Rebuild the VLA type from the pointer and maxindex.  */\n       tree field = next_initializable_field (TYPE_FIELDS (type));\n@@ -9414,8 +9414,9 @@ build_capture_proxy (tree member)\n       tree max = build_simple_component_ref (object, field);\n       type = build_array_type (TREE_TYPE (TREE_TYPE (ptr)),\n \t\t\t       build_index_type (max));\n-      object = convert (build_reference_type (type), ptr);\n-      object = convert_from_reference (object);\n+      type = build_reference_type (type);\n+      REFERENCE_VLA_OK (type) = true;\n+      object = convert (type, ptr);\n     }\n \n   var = build_decl (input_location, VAR_DECL, name, type);\n@@ -9446,19 +9447,20 @@ static tree\n vla_capture_type (tree array_type)\n {\n   static tree ptr_id, max_id;\n+  tree type = xref_tag (record_type, make_anon_name (), ts_current, false);\n+  xref_basetypes (type, NULL_TREE);\n+  type = begin_class_definition (type);\n   if (!ptr_id)\n     {\n       ptr_id = get_identifier (\"ptr\");\n       max_id = get_identifier (\"max\");\n     }\n   tree ptrtype = build_pointer_type (TREE_TYPE (array_type));\n-  tree field1 = build_decl (input_location, FIELD_DECL, ptr_id, ptrtype);\n-  tree field2 = build_decl (input_location, FIELD_DECL, max_id, sizetype);\n-  DECL_CHAIN (field2) = field1;\n-  tree type = make_node (RECORD_TYPE);\n-  finish_builtin_struct (type, \"__cap\", field2, NULL_TREE);\n-  TYPE_NAME (type) = NULL_TREE;\n-  return type;\n+  tree field = build_decl (input_location, FIELD_DECL, ptr_id, ptrtype);\n+  finish_member_declaration (field);\n+  field = build_decl (input_location, FIELD_DECL, max_id, sizetype);\n+  finish_member_declaration (field);\n+  return finish_struct (type, NULL_TREE);\n }\n \n /* From an ID and INITIALIZER, create a capture (by reference if\n@@ -9471,13 +9473,15 @@ add_capture (tree lambda, tree id, tree initializer, bool by_reference_p,\n {\n   char *buf;\n   tree type, member, name;\n+  bool vla = false;\n \n   if (TREE_CODE (initializer) == TREE_LIST)\n     initializer = build_x_compound_expr_from_list (initializer, ELK_INIT,\n \t\t\t\t\t\t   tf_warning_or_error);\n   type = lambda_capture_field_type (initializer, explicit_init_p);\n   if (array_of_runtime_bound_p (type))\n     {\n+      vla = true;\n       if (!by_reference_p)\n \terror (\"array of runtime bound cannot be captured by copy, \"\n \t       \"only by reference\");\n@@ -9486,13 +9490,10 @@ add_capture (tree lambda, tree id, tree initializer, bool by_reference_p,\n \t maximum index, and then reconstruct the VLA for the proxy.  */\n       tree elt = cp_build_array_ref (input_location, initializer,\n \t\t\t\t     integer_zero_node, tf_warning_or_error);\n-      tree ctype = vla_capture_type (type);\n-      tree ptr_field = next_initializable_field (TYPE_FIELDS (ctype));\n-      tree nelts_field = next_initializable_field (DECL_CHAIN (ptr_field));\n-      initializer = build_constructor_va (ctype, 2,\n-\t\t\t\t\t  ptr_field, build_address (elt),\n-\t\t\t\t\t  nelts_field, array_type_nelts (type));\n-      type = ctype;\n+      initializer = build_constructor_va (init_list_type_node, 2,\n+\t\t\t\t\t  NULL_TREE, build_address (elt),\n+\t\t\t\t\t  NULL_TREE, array_type_nelts (type));\n+      type = vla_capture_type (type);\n     }\n   else if (variably_modified_type_p (type, NULL_TREE))\n     {\n@@ -9544,6 +9545,7 @@ add_capture (tree lambda, tree id, tree initializer, bool by_reference_p,\n \n   /* Make member variable.  */\n   member = build_lang_decl (FIELD_DECL, name, type);\n+  DECL_VLA_CAPTURE_P (member) = vla;\n \n   if (!explicit_init_p)\n     /* Normal captures are invisible to name lookup but uses are replaced"}, {"sha": "d54d46dbb799bb534822be19eecb20f5b9f68b0b", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593bcbb8e43c07296325e167ba98bdc52ee3c8de/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593bcbb8e43c07296325e167ba98bdc52ee3c8de/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=593bcbb8e43c07296325e167ba98bdc52ee3c8de", "patch": "@@ -884,8 +884,8 @@ array_of_runtime_bound_p (tree t)\n   if (!dom)\n     return false;\n   tree max = TYPE_MAX_VALUE (dom);\n-  return (!value_dependent_expression_p (max)\n-\t  && !TREE_CONSTANT (max));\n+  return (!potential_rvalue_constant_expression (max)\n+\t  || (!value_dependent_expression_p (max) && !TREE_CONSTANT (max)));\n }\n \n /* Return a reference type node referring to TO_TYPE.  If RVAL is"}, {"sha": "6e2031af83b9e7fa07ca696c98d5f4d50b12222a", "filename": "gcc/testsuite/g++.dg/cpp1y/vla8.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/593bcbb8e43c07296325e167ba98bdc52ee3c8de/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/593bcbb8e43c07296325e167ba98bdc52ee3c8de/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvla8.C?ref=593bcbb8e43c07296325e167ba98bdc52ee3c8de", "patch": "@@ -0,0 +1,31 @@\n+// PR c++/55149\n+// { dg-options -std=c++1y }\n+\n+template<unsigned int TA>\n+ struct SA\n+ {\n+   SA (const int & PA);\n+   int nt;\n+ };\n+\n+template<typename TB>\n+ inline void\n+ test(TB aa)\n+ {\n+   ;\n+ }\n+\n+template<unsigned int TA>\n+ inline\n+ SA<TA>::SA(const int & PA)\n+ {\n+   float e[nt];\n+   test([&e](int i, int j){ return e[i] < e[j]; });\n+ }\n+\n+int main()\n+{\n+ int d;\n+ SA<2> iso(d);\n+ return 0;\n+}"}]}