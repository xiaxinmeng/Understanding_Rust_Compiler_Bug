{"sha": "830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMwYmZhNzRiMDgyYzFjZDBkNTU1MGVlNGYwZjQzNjRmNDZmMWEwYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-05-11T07:25:25Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-05-11T07:25:25Z"}, "message": "call.c (add_template_candidate): Adjust for changes to fn_type_unification.\n\n\t* call.c (add_template_candidate): Adjust for changes to\n\tfn_type_unification.\n\t(add_template_candidate_real): Likewise.\n\t(add_template_conv_candidate): Likewise.\n\t(build_user_type_conversion_1): Likewise.\n\t(build_new_function_call): Likewise.\n\t(build_object_call): Likewise.\n\t(build_new_op): Likewise.\n\t(build_new_method_call): Likewise.\n\t* class.c (instantiate_type): Likewise.\n\t* cp-tree.h (unification_kind_t): New type.\n\t(fn_type_unification): Adjust prototype.\n\t(type_unificaiton): Likewise.\n\t* pt.c (UNIFY_ALLOW_NONE): New macro.\n\t(UNIFY_ALLOW_MORE_CV_QUAL): Likewise.\n\t(UNIFY_ALLOW_LESS_CV_QUAL): Likewise.\n\t(UNIFY_ALLOW_DERIVED): Likewise.\n\t(unify): Change prototype.\n\t(maybe_adjust_types_for_deduction): New function.\n\t(check_cv_quals_for_unify): Likewise.\n\t(determine_specialization): Adjust.\n\t(fn_type_unification): Likewise.\n\t(type_unification): Likewise.\n\t(type_unification_real): Likewise.  Use\n\tmaybe_adjust_types_for_deduction.  Fix mishandling of\n\tback-unification of template functions passed as arguments.  Pass\n\tappropriate combination of UNIFY_ALLOW_* to unify.\n\t(unify): Remove unused NTPARMS parameter.  Use\n\tcheck_cv_quals_for_unify.  Remove bogus code that allowed\n\ttoo-generous unification in order to adhere more closely to standard.\n\t(get_bindings_real): Adjust.\n\t(get_class_bindings): Likewise.\n\t* method.c (build_overload_identifier): Only use the innermost\n\ttemplate arguments when mangling.\n\t* pt.c (tsubst_template_argument_vector): New function.\n\t(complete_template_args): Deal with the situation where the\n\textra_args contain more than one level of arguments.\n\t(lookup_template_class): Deal with member template classes, which\n\tmay have more than one level of arguments.\n\t(tsubst): Don't tsbust into the TREE_TYPE of an IDENTIFIER_NODE.\n\tImprove handling of member template classes.  Use\n\tDECL_PRIMARY_TEMPLATE instead of inline expansion.  Use\n\ttsubst_template_argument_vector where appropriate.\n\t(regenerate_decl_from_template): Break out from ...\n\t(instantiate_decl): Here.\n\nFrom-SVN: r19663", "tree": {"sha": "3eb441453df3706bae901aecf80a665eda32abc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3eb441453df3706bae901aecf80a665eda32abc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/comments", "author": null, "committer": null, "parents": [{"sha": "89ad74a33f27c5d1415f86c8331ba8295f6a091f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89ad74a33f27c5d1415f86c8331ba8295f6a091f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89ad74a33f27c5d1415f86c8331ba8295f6a091f"}], "stats": {"total": 845, "additions": 638, "deletions": 207}, "files": [{"sha": "03fae3fe2252ba10fd312b77815731ff396e6104", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a", "patch": "@@ -1,5 +1,52 @@\n Mon May 11 07:16:30 1998  Mark Mitchell  <mmitchell@usa.net>\n \n+\t* call.c (add_template_candidate): Adjust for changes to\n+\tfn_type_unification. \n+\t(add_template_candidate_real): Likewise.\n+\t(add_template_conv_candidate): Likewise.\n+\t(build_user_type_conversion_1): Likewise.\n+\t(build_new_function_call): Likewise.\n+\t(build_object_call): Likewise.\n+\t(build_new_op): Likewise.\n+\t(build_new_method_call): Likewise.\n+\t* class.c (instantiate_type): Likewise.\n+\t* cp-tree.h (unification_kind_t): New type.\n+\t(fn_type_unification): Adjust prototype.\n+\t(type_unificaiton): Likewise.\n+\t* pt.c (UNIFY_ALLOW_NONE): New macro.\n+\t(UNIFY_ALLOW_MORE_CV_QUAL): Likewise.\n+\t(UNIFY_ALLOW_LESS_CV_QUAL): Likewise.\n+\t(UNIFY_ALLOW_DERIVED): Likewise.\n+\t(unify): Change prototype.\n+\t(maybe_adjust_types_for_deduction): New function.\n+\t(check_cv_quals_for_unify): Likewise.\n+\t(determine_specialization): Adjust.\n+\t(fn_type_unification): Likewise.\n+\t(type_unification): Likewise.\n+\t(type_unification_real): Likewise.  Use\n+\tmaybe_adjust_types_for_deduction.  Fix mishandling of\n+\tback-unification of template functions passed as arguments.  Pass\n+\tappropriate combination of UNIFY_ALLOW_* to unify.\n+\t(unify): Remove unused NTPARMS parameter.  Use\n+\tcheck_cv_quals_for_unify.  Remove bogus code that allowed\n+\ttoo-generous unification in order to adhere more closely to standard.\n+\t(get_bindings_real): Adjust.\n+\t(get_class_bindings): Likewise.\n+\n+\t* method.c (build_overload_identifier): Only use the innermost\n+\ttemplate arguments when mangling.\n+\t* pt.c (tsubst_template_argument_vector): New function.\n+\t(complete_template_args): Deal with the situation where the\n+\textra_args contain more than one level of arguments.\n+\t(lookup_template_class): Deal with member template classes, which\n+\tmay have more than one level of arguments.\n+\t(tsubst): Don't tsbust into the TREE_TYPE of an IDENTIFIER_NODE.\n+\tImprove handling of member template classes.  Use\n+\tDECL_PRIMARY_TEMPLATE instead of inline expansion.  Use\n+\ttsubst_template_argument_vector where appropriate.\n+\t(regenerate_decl_from_template): Break out from ...\n+\t(instantiate_decl): Here.\n+\t\n \t* lex.c (yyprint): Remove TYPENAME_ELLIPSIS.\n \t* parse.h: Regenerated.\n \t* parse.c: Really regenerated."}, {"sha": "5eafd87289a4e452277479c39b371057415fdb05", "filename": "gcc/cp/call.c", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a", "patch": "@@ -61,9 +61,11 @@ static tree build_this PROTO((tree));\n static struct z_candidate * splice_viable PROTO((struct z_candidate *));\n static int any_viable PROTO((struct z_candidate *));\n static struct z_candidate * add_template_candidate\n-\tPROTO((struct z_candidate *, tree, tree, tree, tree, int));\n+\tPROTO((struct z_candidate *, tree, tree, tree, tree, int,\n+\t       unification_kind_t));\n static struct z_candidate * add_template_candidate_real\n-\tPROTO((struct z_candidate *, tree, tree, tree, tree, int, tree));\n+\tPROTO((struct z_candidate *, tree, tree, tree, tree, int,\n+\t       tree, unification_kind_t));\n static struct z_candidate * add_template_conv_candidate \n         PROTO((struct z_candidate *, tree, tree, tree, tree));\n static struct z_candidate * add_builtin_candidates\n@@ -1865,11 +1867,12 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n static struct z_candidate*\n add_template_candidate_real (candidates, tmpl, explicit_targs,\n \t\t\t     arglist, return_type, flags,\n-\t\t\t     obj)\n+\t\t\t     obj, strict)\n      struct z_candidate *candidates;\n      tree tmpl, explicit_targs, arglist, return_type;\n      int flags;\n      tree obj;\n+     unification_kind_t strict;\n {\n   int ntparms = DECL_NTPARMS (tmpl);\n   tree targs = make_scratch_vec (ntparms);\n@@ -1878,7 +1881,7 @@ add_template_candidate_real (candidates, tmpl, explicit_targs,\n   tree fn;\n \n   i = fn_type_unification (tmpl, explicit_targs, targs, arglist,\n-\t\t\t   return_type, 0, NULL_TREE); \n+\t\t\t   return_type, strict, NULL_TREE);\n \n   if (i != 0)\n     return candidates;\n@@ -1920,14 +1923,16 @@ add_template_candidate_real (candidates, tmpl, explicit_targs,\n \n static struct z_candidate *\n add_template_candidate (candidates, tmpl, explicit_targs, \n-\t\t\targlist, return_type, flags)\n+\t\t\targlist, return_type, flags, strict)\n      struct z_candidate *candidates;\n      tree tmpl, explicit_targs, arglist, return_type;\n      int flags;\n+     unification_kind_t strict;\n {\n   return \n     add_template_candidate_real (candidates, tmpl, explicit_targs,\n-\t\t\t\t arglist, return_type, flags, NULL_TREE);\n+\t\t\t\t arglist, return_type, flags,\n+\t\t\t\t NULL_TREE, strict);\n }\n \n \n@@ -1938,7 +1943,7 @@ add_template_conv_candidate (candidates, tmpl, obj, arglist, return_type)\n {\n   return \n     add_template_candidate_real (candidates, tmpl, NULL_TREE, arglist,\n-\t\t\t\t return_type, 0, obj);\n+\t\t\t\t return_type, 0, obj, DEDUCE_CONV);\n }\n \n \n@@ -2058,7 +2063,8 @@ build_user_type_conversion_1 (totype, expr, flags)\n \t  templates = scratch_tree_cons (NULL_TREE, ctor, templates);\n \t  candidates = \n \t    add_template_candidate (candidates, ctor,\n-\t\t\t\t    NULL_TREE, args, NULL_TREE, flags);\n+\t\t\t\t    NULL_TREE, args, NULL_TREE, flags,\n+\t\t\t\t    DEDUCE_CALL);\n \t} \n       else \n \tcandidates = add_function_candidate (candidates, ctor,\n@@ -2107,7 +2113,8 @@ build_user_type_conversion_1 (totype, expr, flags)\n \t\ttemplates = scratch_tree_cons (NULL_TREE, fn, templates);\n \t\tcandidates = \n \t\t  add_template_candidate (candidates, fn, NULL_TREE,\n-\t\t\t\t\t  args, totype, flags);\n+\t\t\t\t\t  args, totype, flags,\n+\t\t\t\t\t  DEDUCE_CONV);\n \t      } \n \t    else \n \t      candidates = add_function_candidate (candidates, fn,\n@@ -2261,7 +2268,7 @@ build_new_function_call (fn, args)\n \t      templates = scratch_tree_cons (NULL_TREE, t, templates);\n \t      candidates = add_template_candidate\n \t\t(candidates, t, explicit_targs, args, NULL_TREE,\n-\t\t LOOKUP_NORMAL);  \n+\t\t LOOKUP_NORMAL, DEDUCE_CALL);  \n \t    }\n \t  else if (! template_only)\n \t    candidates = add_function_candidate\n@@ -2346,7 +2353,7 @@ build_object_call (obj, args)\n \t      candidates \n \t\t= add_template_candidate (candidates, fn, NULL_TREE,\n \t\t\t\t\t  mem_args, NULL_TREE, \n-\t\t\t\t\t  LOOKUP_NORMAL);\n+\t\t\t\t\t  LOOKUP_NORMAL, DEDUCE_CALL);\n \t    }\n \t  else\n \t    candidates = add_function_candidate\n@@ -2603,7 +2610,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t  candidates \n \t    = add_template_candidate (candidates, fn, NULL_TREE,\n \t\t\t\t      arglist, TREE_TYPE (fnname),\n-\t\t\t\t      flags); \n+\t\t\t\t      flags, DEDUCE_CALL); \n \t}\n       else\n \tcandidates = add_function_candidate (candidates, fn, arglist, flags);\n@@ -2639,7 +2646,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t      candidates \n \t\t= add_template_candidate (candidates, fn, NULL_TREE,\n \t\t\t\t\t  this_arglist,  TREE_TYPE (fnname),\n-\t\t\t\t\t  flags); \n+\t\t\t\t\t  flags, DEDUCE_CALL); \n \t    }\n \t  else\n \t    candidates = add_function_candidate\n@@ -3591,7 +3598,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n \t      candidates = \n \t\tadd_template_candidate (candidates, t, explicit_targs,\n \t\t\t\t\tthis_arglist,\n-\t\t\t\t\tTREE_TYPE (name), flags); \n+\t\t\t\t\tTREE_TYPE (name), flags, DEDUCE_CALL); \n \t    }\n \t  else if (! template_only)\n \t    candidates = add_function_candidate (candidates, t,"}, {"sha": "17cfe2bf9b4a64e537eb3c60f392a6d9c5418718", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a", "patch": "@@ -5151,7 +5151,7 @@ instantiate_type (lhstype, rhs, complain)\n \t\ti = type_unification\n \t\t  (DECL_INNERMOST_TEMPLATE_PARMS (elem), t,\n \t\t   TYPE_ARG_TYPES (TREE_TYPE (elem)),\n-\t\t   TYPE_ARG_TYPES (lhstype), explicit_targs, 1, 1);\n+\t\t   TYPE_ARG_TYPES (lhstype), explicit_targs, DEDUCE_EXACT, 1);\n \t\tif (i == 0)\n \t\t  {\n \t\t    if (save_elem)"}, {"sha": "e76c85b3e8d8a52c74a72c8a7b1161391df4470d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a", "patch": "@@ -1683,6 +1683,16 @@ extern tree null_node;\n \n /* in pt.c  */\n \n+/* These values are used for the `STRICT' parameter to type_unfication and\n+   fn_type_unification.  Their meanings are described with the\n+   documentation for fn_type_unification.  */\n+\n+typedef enum unification_kind_t {\n+  DEDUCE_CALL,\n+  DEDUCE_CONV,\n+  DEDUCE_EXACT\n+} unification_kind_t;\n+\n extern tree current_template_parms;\n extern HOST_WIDE_INT processing_template_decl;\n extern tree last_tree;\n@@ -2504,8 +2514,8 @@ extern int uses_template_parms\t\t\tPROTO((tree));\n extern tree instantiate_class_template\t\tPROTO((tree));\n extern tree instantiate_template\t\tPROTO((tree, tree));\n extern void overload_template_name\t\tPROTO((tree));\n-extern int fn_type_unification                  PROTO((tree, tree, tree, tree, tree, int, tree));\n-extern int type_unification\t\t\tPROTO((tree, tree, tree, tree, tree, int, int));\n+extern int fn_type_unification                  PROTO((tree, tree, tree, tree, tree, unification_kind_t, tree));\n+extern int type_unification\t\t\tPROTO((tree, tree, tree, tree, tree, unification_kind_t, int));\n struct tinst_level *tinst_for_decl\t\tPROTO((void));\n extern void mark_decl_instantiated\t\tPROTO((tree, int));\n extern int more_specialized\t\t\tPROTO((tree, tree, tree));"}, {"sha": "ef048f3b900923f6c07ed4027b8de5d415b5c5f8", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a", "patch": "@@ -893,7 +893,7 @@ build_overload_identifier (name)\n     {\n       tree template, parmlist, arglist, tname;\n       template = CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (name));\n-      arglist = TREE_VALUE (template);\n+      arglist = innermost_args (TREE_VALUE (template), 0);\n       template = TREE_PURPOSE (template);\n       tname = DECL_NAME (template);\n       parmlist = DECL_INNERMOST_TEMPLATE_PARMS (template);"}, {"sha": "e9e6304b4e6d5e074b368df188dbfcf95488b892", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 483, "deletions": 189, "changes": 672, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a", "patch": "@@ -70,7 +70,12 @@ static tree saved_trees;\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-static int unify PROTO((tree, tree, int, tree, tree, int, int*));\n+#define UNIFY_ALLOW_NONE 0\n+#define UNIFY_ALLOW_MORE_CV_QUAL 1\n+#define UNIFY_ALLOW_LESS_CV_QUAL 2\n+#define UNIFY_ALLOW_DERIVED 4\n+\n+static int unify PROTO((tree, tree, tree, tree, int, int*));\n static void add_pending_template PROTO((tree));\n static int push_tinst_level PROTO((tree));\n static tree classtype_mangled_name PROTO((tree));\n@@ -81,8 +86,10 @@ static tree get_class_bindings PROTO((tree, tree, tree, tree));\n static tree coerce_template_parms PROTO((tree, tree, tree, int, int, int));\n static tree tsubst_enum\tPROTO((tree, tree, tree *));\n static tree add_to_template_args PROTO((tree, tree));\n+static void maybe_adjust_types_for_deduction PROTO((unification_kind_t, tree*,\n+\t\t\t\t\t\t    tree*)); \n static int  type_unification_real PROTO((tree, tree, tree, tree,\n-\t\t\t\t\t int, int, int, int*));\n+\t\t\t\t\t int, unification_kind_t, int, int*));\n static tree complete_template_args PROTO((tree, tree, int));\n static void note_template_header PROTO((int));\n static tree maybe_fold_nontype_arg PROTO((tree));\n@@ -104,6 +111,9 @@ static tree tsubst_friend_class PROTO((tree, tree));\n static tree get_bindings_real PROTO((tree, tree, tree, int));\n static int template_decl_level PROTO((tree));\n static tree maybe_get_template_decl_from_type_decl PROTO((tree));\n+static int check_cv_quals_for_unify PROTO((int, tree, tree));\n+static tree tsubst_template_arg_vector PROTO((tree, tree));\n+static void regenerate_decl_from_template PROTO((tree, tree));\n \n /* Do any processing required when DECL (a member template declaration\n    using TEMPLATE_PARAMETERS as its innermost parameter list) is\n@@ -360,7 +370,7 @@ is_member_template (t)\n }\n \n /* Return a new template argument vector which contains all of ARGS\n-   for all outer templates TYPE is contained in, but has as its \n+   for all outer templates TMPL is contained in, but has as its \n    innermost set of arguments the EXTRA_ARGS.  If UNBOUND_ONLY, we\n    are only interested in unbound template arguments, not arguments from\n    enclosing templates that have been instantiated already.  */\n@@ -373,10 +383,16 @@ complete_template_args (tmpl, extra_args, unbound_only)\n   /* depth is the number of levels of enclosing args we're adding.  */\n   int depth, i;\n   tree args, new_args, spec_args = NULL_TREE;\n-  \n+  int extra_arg_depth;\n+\n   my_friendly_assert (TREE_CODE (tmpl) == TEMPLATE_DECL, 0);\n   my_friendly_assert (TREE_CODE (extra_args) == TREE_VEC, 0);\n \n+  if (TREE_CODE (TREE_VEC_ELT (extra_args, 0)) == TREE_VEC)\n+    extra_arg_depth = TREE_VEC_LENGTH (extra_args);\n+  else\n+    extra_arg_depth = 1;\n+\n   if (DECL_TEMPLATE_INFO (tmpl) && !unbound_only)\n     {\n       /* A specialization of a member template of a template class shows up\n@@ -405,7 +421,7 @@ complete_template_args (tmpl, extra_args, unbound_only)\n \t   template args.  */\n \tdepth = 0;\n \n-      new_args = make_tree_vec (depth + 1 + (!!spec_args));\n+      new_args = make_tree_vec (depth + extra_arg_depth + (!!spec_args));\n \n       if (depth == 1)\n \tTREE_VEC_ELT (new_args, 0) = args;\n@@ -427,7 +443,7 @@ complete_template_args (tmpl, extra_args, unbound_only)\n       if (depth == 0)\n \treturn extra_args;\n \n-      new_args = make_tree_vec (depth + 1);\n+      new_args = make_tree_vec (depth + extra_arg_depth);\n \n       /* If this isn't a member template, extra_args is for the innermost\n \t template class, so skip over it.  */\n@@ -447,10 +463,14 @@ complete_template_args (tmpl, extra_args, unbound_only)\n \t  }\n     }\n \n-  TREE_VEC_ELT (new_args, depth) = extra_args;\n+  if (extra_arg_depth == 1)\n+    TREE_VEC_ELT (new_args, depth++) = extra_args;\n+  else\n+    for (i = 0; i < extra_arg_depth; ++i)\n+      TREE_VEC_ELT (new_args, depth++) = TREE_VEC_ELT (extra_args, i);\n \n   if (spec_args)\n-    TREE_VEC_ELT (new_args, depth + 1) = spec_args;\n+    TREE_VEC_ELT (new_args, depth) = spec_args;\n \n   return new_args;\n }\n@@ -776,7 +796,7 @@ determine_specialization (template_id, decl, targs_out,\n \t\t\t\tNULL_TREE,\n \t\t\t\tNULL_TREE,  \n \t\t\t\ttargs_in,\n-\t\t\t\t1, 1);\n+\t\t\t\tDEDUCE_EXACT, 1);\n       \n \t  if (i == 0) \n \t    /* Unification was successful.  */\n@@ -1814,8 +1834,15 @@ push_template_decl_real (decl, is_friend)\n \t  cp_error (\"  but `%#T' has %d\", ctx, TREE_VEC_LENGTH (t));\n \t}\n     }\n-  /* Get the innermost set of template arguments. */\n-  args = innermost_args (args, 0);\n+  /* Get the innermost set of template arguments.  We don't do this\n+     for a non-template member function of a nested template class\n+     because there we will never get a `partial instantiation' of the\n+     function containing the outer arguments, and so we must save all\n+     of the arguments here.  */\n+  if (TREE_CODE (decl) != FUNCTION_DECL \n+      || template_class_depth (ctx) <= 1\n+      || primary)\n+    args = innermost_args (args, 0);\n \n   DECL_TEMPLATE_RESULT (tmpl) = decl;\n   TREE_TYPE (tmpl) = TREE_TYPE (decl);\n@@ -2904,11 +2931,36 @@ lookup_template_class (d1, arglist, in_decl, context)\n \t   || (TREE_CODE (TYPE_CONTEXT (TREE_TYPE (template))) \n \t       == FUNCTION_DECL))\n     {\n+      tree arglist_for_mangling;\n+\n       parmlist = DECL_INNERMOST_TEMPLATE_PARMS (template);\n \n-      arglist = coerce_template_parms (parmlist, arglist, template,\n-\t\t\t\t       1, 1, 0);\n-      if (arglist == error_mark_node)\n+      if (/* ARGLIST can be NULL_TREE if there are default arguments.  */\n+\t  arglist != NULL_TREE\n+\t  && TREE_CODE (arglist) == TREE_VEC \n+\t  && TREE_VEC_LENGTH (arglist) > 1\n+\t  && list_length (DECL_TEMPLATE_PARMS (template)) > 1)\n+\t{\n+\t  /* We have multiple levels of arguments to coerce, at once.  */\n+\t  tree new_args = \n+\t    make_tree_vec (list_length (DECL_TEMPLATE_PARMS (template)));\n+\t  int i;\n+\t  \n+\t  for (i = TREE_VEC_LENGTH (arglist) - 1, \n+\t\t t = DECL_TEMPLATE_PARMS (template); \n+\t       i >= 0 && t != NULL_TREE;\n+\t       --i, t = TREE_CHAIN (t))\n+\t    TREE_VEC_ELT (new_args, i) =\n+\t      coerce_template_parms (TREE_VALUE (t),\n+\t\t\t\t     TREE_VEC_ELT (arglist, i),\n+\t\t\t\t     template, 1, 1, 0);\n+\t  arglist = new_args;\n+\t}\n+      else\n+\targlist = coerce_template_parms (parmlist, \n+\t\t\t\t\t innermost_args (arglist, 0),\n+\t\t\t\t\t template, 1, 1, 0);\n+     if (arglist == error_mark_node)\n \treturn error_mark_node;\n       if (uses_template_parms (arglist))\n \t{\n@@ -2937,10 +2989,15 @@ lookup_template_class (d1, arglist, in_decl, context)\n \t    }\n \t}\n \n+      if (TREE_CODE (arglist) == TREE_VEC)\n+\targlist_for_mangling = innermost_args (arglist, 0);\n+      else\n+\targlist_for_mangling = arglist;\n+\n       /* FIXME avoid duplication.  */\n       mangled_name = mangle_class_name_for_template (IDENTIFIER_POINTER (d1),\n \t\t\t\t\t\t     parmlist,\n-\t\t\t\t\t\t     arglist,\n+\t\t\t\t\t\t     arglist_for_mangling,\n \t\t\t\t\t\t     id_context);\n       id = get_identifier (mangled_name);\n       IDENTIFIER_TEMPLATE (id) = d1;\n@@ -3875,11 +3932,46 @@ innermost_args (args, is_spec)\n      tree args;\n      int is_spec;\n {\n-  if (TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n+  if (args != NULL_TREE && TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n     return TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1 - is_spec);\n   return args;\n }\n \n+/* Substitute ARGS into the vector of template arguments T.  */\n+\n+tree\n+tsubst_template_arg_vector (t, args)\n+     tree t;\n+     tree args;\n+{\n+  int len = TREE_VEC_LENGTH (t), need_new = 0, i;\n+  tree *elts = (tree *) alloca (len * sizeof (tree));\n+  \n+  bzero ((char *) elts, len * sizeof (tree));\n+  \n+  for (i = 0; i < len; i++)\n+    {\n+      if (TREE_VEC_ELT (t, i) != NULL_TREE\n+\t  && TREE_CODE (TREE_VEC_ELT (t, i)) == TREE_VEC)\n+\telts[i] = tsubst_template_arg_vector (TREE_VEC_ELT (t, i), args);\n+      else\n+\telts[i] = maybe_fold_nontype_arg\n+\t  (tsubst_expr (TREE_VEC_ELT (t, i), args, NULL_TREE));\n+      \n+      if (elts[i] != TREE_VEC_ELT (t, i))\n+\tneed_new = 1;\n+    }\n+  \n+  if (!need_new)\n+    return t;\n+  \n+  t = make_tree_vec (len);\n+  for (i = 0; i < len; i++)\n+    TREE_VEC_ELT (t, i) = elts[i];\n+  \n+  return t;\n+}\n+\n /* Take the tree structure T and replace template parameters used therein\n    with the argument vector ARGS.  IN_DECL is an associated decl for\n    diagnostics.\n@@ -3907,7 +3999,9 @@ tsubst (t, args, in_decl)\n     type = TREE_TYPE (t);\n   if (type == unknown_type_node)\n     my_friendly_abort (42);\n+\n   if (type && TREE_CODE (t) != FUNCTION_DECL\n+      && TREE_CODE (t) != IDENTIFIER_NODE\n       && TREE_CODE (t) != TYPENAME_TYPE\n       && TREE_CODE (t) != TEMPLATE_DECL\n       && TREE_CODE (t) != IDENTIFIER_NODE)\n@@ -3932,14 +4026,33 @@ tsubst (t, args, in_decl)\n \t  tree context;\n \t  tree r;\n \n-\t  context = \n-\t    TYPE_CONTEXT (t) \n-\t    ? tsubst (TYPE_CONTEXT (t), args, in_decl) : NULL_TREE;\n+\t  if (TYPE_CONTEXT (t) != NULL_TREE)\n+\t    {\n+\t      context = tsubst (TYPE_CONTEXT (t), args, in_decl);\n+\t  \n+\t      if (TREE_CODE (context) != FUNCTION_DECL\n+\t\t  && TREE_CODE (context) != NAMESPACE_DECL)\n+\t\t{\n+\t\t  /* For a member class template, we need all the\n+\t\t     template arguments.  */\n+\t\t  if (CLASSTYPE_IS_TEMPLATE (TYPE_CONTEXT (t)))\n+\t\t    argvec = \n+\t\t      add_to_template_args (CLASSTYPE_TI_ARGS (context),\n+\t\t\t\t\t    argvec);\n+\n+\t\t  if (CLASSTYPE_TEMPLATE_INFO (context))\n+\t\t    argvec = \n+\t\t      complete_template_args (CLASSTYPE_TI_TEMPLATE (context),\n+\t\t\t\t\t      argvec, 0);\n+\t\t}\n+\t    }\n+\t  else\n+\t    context = NULL_TREE;\n \n \t  r = lookup_template_class (t, argvec, in_decl, context);\n \n \t  return cp_build_type_variant (r, TYPE_READONLY (t),\n-\t\t\t\tTYPE_VOLATILE (t));\n+\t\t\t\t\tTYPE_VOLATILE (t));\n \t}\n \n       /* else fall through */\n@@ -4208,7 +4321,7 @@ tsubst (t, args, in_decl)\n \t  }\n \n \tif (PRIMARY_TEMPLATE_P (t))\n-\t  TREE_TYPE (DECL_INNERMOST_TEMPLATE_PARMS (tmpl)) = tmpl;\n+\t  DECL_PRIMARY_TEMPLATE (tmpl) = tmpl;\n \n \t/* We don't partially instantiate partial specializations.  */\n \tif (TREE_CODE (decl) == TYPE_DECL)\n@@ -4646,30 +4759,8 @@ tsubst (t, args, in_decl)\n \t}\n \n       /* Otherwise, a vector of template arguments.  */\n-      {\n-\tint len = TREE_VEC_LENGTH (t), need_new = 0, i;\n-\ttree *elts = (tree *) alloca (len * sizeof (tree));\n-\n-\tbzero ((char *) elts, len * sizeof (tree));\n-\n-\tfor (i = 0; i < len; i++)\n-\t  {\n-\t    elts[i] = maybe_fold_nontype_arg\n-\t      (tsubst_expr (TREE_VEC_ELT (t, i), args, in_decl));\n-\n-\t    if (elts[i] != TREE_VEC_ELT (t, i))\n-\t      need_new = 1;\n-\t  }\n-\n-\tif (!need_new)\n-\t  return t;\n+      return tsubst_template_arg_vector (t, args);\n \n-\tt = make_tree_vec (len);\n-\tfor (i = 0; i < len; i++)\n-\t  TREE_VEC_ELT (t, i) = elts[i];\n-\t\n-\treturn t;\n-      }\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n       {\n@@ -5493,7 +5584,7 @@ int\n fn_type_unification (fn, explicit_targs, targs, args, return_type,\n \t\t     strict, extra_fn_arg)\n      tree fn, explicit_targs, targs, args, return_type;\n-     int strict;\n+     unification_kind_t strict;\n      tree extra_fn_arg;\n {\n   int i;\n@@ -5553,22 +5644,37 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n    a function or method parameter of a function template), so don't zero\n    out targs and don't fail on an incomplete match.\n \n-   If STRICT is 1, the match must be exact (for casts of overloaded\n-   addresses, explicit instantiation, and more_specialized).  */\n+   The parameter STRICT is one of:\n+\n+   DEDUCE_CALL: \n+     We are deducing arguments for a function call, as in\n+     [temp.deduct.call].\n+\n+   DEDUCE_CONV:\n+     We are deducing arguments for a conversion function, as in \n+     [temp.deduct.conv].\n+\n+   DEDUCE_EXACT:\n+     We are deducing arguments when calculating the partial\n+     ordering between specializations of function or class\n+     templates, as in [temp.func.order] and [temp.class.order],\n+     when doing an explicit instantiation as in [temp.explicit],\n+     when determiningan explicit specialization as in\n+     [temp.expl.spec], or when taking the address of a function\n+     template, as in [temp.deduct.funcaddr].  */\n \n int\n type_unification (tparms, targs, parms, args, targs_in,\n \t\t  strict, allow_incomplete)\n      tree tparms, targs, parms, args, targs_in;\n-     int strict, allow_incomplete;\n+     unification_kind_t strict;\n+     int allow_incomplete;\n {\n-  int ntparms = TREE_VEC_LENGTH (tparms);\n   tree arg;\n   int* explicit_mask;\n   int i;\n-  int r;\n \n-  for (i = 0; i < ntparms; i++)\n+  for (i = 0; i < TREE_VEC_LENGTH (tparms); i++)\n     TREE_VEC_ELT (targs, i) = NULL_TREE;\n \n   if (targs_in != NULL_TREE)\n@@ -5596,10 +5702,84 @@ type_unification (tparms, targs, parms, args, targs_in,\n   else\n     explicit_mask = 0;\n \n-  r = type_unification_real (tparms, targs, parms, args, 0,\n-\t\t\t     strict, allow_incomplete, explicit_mask); \n+  return \n+    type_unification_real (tparms, targs, parms, args, 0,\n+\t\t\t   strict, allow_incomplete, explicit_mask); \n+}\n+\n+/* Adjust types before performing type deduction, as described in\n+   [temp.deduct.call] and [temp.deduct.conv].  The rules in these two\n+   sections are symmetric.  For calls, the value passed as PARM should\n+   be a parameter to the template function, while ARG should be the\n+   actual argument used in the call.  For conversions, PARM should be\n+   the type required as the result of the conversion, while ARG should\n+   be the return type of the template conversion function.  */\n+\n+void\n+maybe_adjust_types_for_deduction (strict, parm, arg)\n+     unification_kind_t strict;\n+     tree* parm;\n+     tree* arg;\n+{\n+  switch (strict)\n+    {\n+    case DEDUCE_CALL:\n+      break;\n+\n+    case DEDUCE_CONV:\n+      {\n+\t/* Swap PARM and ARG; the handling is precisely symmetric since\n+\t   PARM will initialize ARG rather than vice versa.  */\n+\ttree* temp = parm;\n+\tparm = arg;\n+\targ = temp;\n+\tbreak;\n+      }\n+\n+    case DEDUCE_EXACT:\n+      /* There is nothing to do in this case.  */\n+      return;\n+\n+    default:\n+      my_friendly_abort (0);\n+    }\n \n-  return r;\n+  if (TREE_CODE (*parm) != REFERENCE_TYPE)\n+    {\n+      /* [temp.deduct.call]\n+\t \n+\t If P is not a reference type:\n+\t \n+\t --If A is an array type, the pointer type produced by the\n+\t array-to-pointer standard conversion (_conv.array_) is\n+\t used in place of A for type deduction; otherwise,\n+\t \n+\t --If A is a function type, the pointer type produced by\n+\t the function-to-pointer standard conversion\n+\t (_conv.func_) is used in place of A for type deduction;\n+\t otherwise,\n+\t \n+\t --If A is a cv-qualified type, the top level\n+\t cv-qualifiers of A's type are ignored for type\n+\t deduction.  */\n+      if (TREE_CODE (*arg) == ARRAY_TYPE)\n+\t*arg = build_pointer_type (TREE_TYPE (*arg));\n+      else if (TREE_CODE (*arg) == FUNCTION_TYPE\n+\t  || TREE_CODE (*arg) == METHOD_TYPE)\n+\t*arg = build_pointer_type (*arg);\n+      else\n+\t*arg = TYPE_MAIN_VARIANT (*arg);\n+    }\n+  \n+  /* [temp.deduct.call]\n+     \n+     If P is a cv-qualified type, the top level cv-qualifiers\n+     of P's type are ignored for type deduction.  If P is a\n+     reference type, the type referred to by P is used for\n+     type deduction.  */\n+  *parm = TYPE_MAIN_VARIANT (*parm);\n+  if (TREE_CODE (*parm) == REFERENCE_TYPE)\n+    *parm = TREE_TYPE (*parm);\n }\n \n /* Like type_unfication.  EXPLICIT_MASK, if non-NULL, is an array of\n@@ -5610,12 +5790,15 @@ static int\n type_unification_real (tparms, targs, parms, args, subr,\n \t\t       strict, allow_incomplete, explicit_mask)\n      tree tparms, targs, parms, args;\n-     int subr, strict, allow_incomplete;\n+     int subr;\n+     unification_kind_t strict;\n+     int allow_incomplete;\n      int* explicit_mask;\n {\n   tree parm, arg;\n   int i;\n   int ntparms = TREE_VEC_LENGTH (tparms);\n+  int sub_strict;\n \n   my_friendly_assert (TREE_CODE (tparms) == TREE_VEC, 289);\n   my_friendly_assert (parms == NULL_TREE \n@@ -5626,6 +5809,24 @@ type_unification_real (tparms, targs, parms, args, subr,\n     my_friendly_assert (TREE_CODE (args) == TREE_LIST, 291);\n   my_friendly_assert (ntparms > 0, 292);\n \n+  switch (strict)\n+    {\n+    case DEDUCE_CALL:\n+      sub_strict = UNIFY_ALLOW_MORE_CV_QUAL | UNIFY_ALLOW_DERIVED;\n+      break;\n+      \n+    case DEDUCE_CONV:\n+      sub_strict = UNIFY_ALLOW_LESS_CV_QUAL;\n+      break;\n+\n+    case DEDUCE_EXACT:\n+      sub_strict = UNIFY_ALLOW_NONE;\n+      break;\n+      \n+    default:\n+      my_friendly_abort (0);\n+    }\n+\n   while (parms\n \t && parms != void_list_node\n \t && args\n@@ -5657,7 +5858,7 @@ type_unification_real (tparms, targs, parms, args, subr,\n \t      arg = NULL_TREE;\n \t    }\n \n-\t  if (strict)\n+\t  if (strict == DEDUCE_EXACT)\n \t    {\n \t      if (comptypes (parm, type, 1))\n \t\tcontinue;\n@@ -5683,20 +5884,20 @@ type_unification_real (tparms, targs, parms, args, subr,\n \t  if (TREE_CODE (arg) == OVERLOAD\n \t      && TREE_CODE (OVL_FUNCTION (arg)) == TEMPLATE_DECL)\n \t    {\n-\t      int ntparms;\n \t      tree targs;\n+\t      tree arg_type;\n \n \t      /* Have to back unify here */\n \t      arg = OVL_FUNCTION (arg);\n-\t      ntparms = DECL_NTPARMS (arg);\n-\t      targs = make_scratch_vec (ntparms);\n+\t      targs = make_scratch_vec (DECL_NTPARMS (arg));\n+\t      arg_type = TREE_TYPE (arg);\n+\t      maybe_adjust_types_for_deduction (strict, &parm, &arg_type);\n \t      parm = expr_tree_cons (NULL_TREE, parm, NULL_TREE);\n+\t      arg_type = scratch_tree_cons (NULL_TREE, arg_type, NULL_TREE);\n \t      return \n \t\ttype_unification (DECL_INNERMOST_TEMPLATE_PARMS (arg), \n-\t\t\t\t  targs,\n-\t\t\t\t  TYPE_ARG_TYPES (TREE_TYPE (arg)),\n-\t\t\t\t  parm, NULL_TREE, strict,\n-\t\t\t\t  allow_incomplete); \n+\t\t\t\t  targs, arg_type, parm, NULL_TREE,\n+\t\t\t\t  DEDUCE_EXACT, allow_incomplete); \n \t    }\n \t  arg = TREE_TYPE (arg);\n \t}\n@@ -5707,21 +5908,10 @@ type_unification_real (tparms, targs, parms, args, subr,\n \t  arg = ptr_type_node;\n \t}\n \n-      if (! subr && TREE_CODE (arg) == REFERENCE_TYPE)\n-\targ = TREE_TYPE (arg);\n+      if (!subr)\n+\tmaybe_adjust_types_for_deduction (strict, &parm, &arg);\n \n-      if (! subr && TREE_CODE (parm) != REFERENCE_TYPE)\n-\t{\n-\t  if (TREE_CODE (arg) == FUNCTION_TYPE\n-\t      || TREE_CODE (arg) == METHOD_TYPE)\n-\t    arg = build_pointer_type (arg);\n-\t  else if (TREE_CODE (arg) == ARRAY_TYPE)\n-\t    arg = build_pointer_type (TREE_TYPE (arg));\n-\t  else\n-\t    arg = TYPE_MAIN_VARIANT (arg);\n-\t}\n-\n-      switch (unify (tparms, targs, ntparms, parm, arg, strict,\n+      switch (unify (tparms, targs, parm, arg, sub_strict,\n \t\t     explicit_mask)) \n \t{\n \tcase 0:\n@@ -5771,12 +5961,43 @@ template_decl_level (decl)\n     }\n }\n \n-/* Tail recursion is your friend.  */\n+/* Decide whether ARG can be unified with PARM, considering only the\n+   cv-qualifiers of each type, given STRICT as documented for unify.\n+   Returns non-zero iff the unification is OK on that basis.*/\n \n-static int\n-unify (tparms, targs, ntparms, parm, arg, strict, explicit_mask)\n+int\n+check_cv_quals_for_unify (strict, arg, parm)\n+     int strict;\n+     tree arg;\n+     tree parm;\n+{\n+  return !((!(strict & UNIFY_ALLOW_MORE_CV_QUAL)\n+\t    && (TYPE_READONLY (arg) < TYPE_READONLY (parm)\n+\t\t|| TYPE_VOLATILE (arg) < TYPE_VOLATILE (parm)))\n+\t   || (!(strict & UNIFY_ALLOW_LESS_CV_QUAL)\n+\t       && (TYPE_READONLY (arg) > TYPE_READONLY (parm)\n+\t\t   || TYPE_VOLATILE (arg) > TYPE_VOLATILE (parm))));\n+}\n+\n+/* Takes parameters as for type_unification.  Returns 0 if the\n+   type deduction suceeds, 1 otherwise.  The parameter STRICT is a\n+   bitwise or of the following flags:\n+\n+     UNIFY_ALLOW_NONE:\n+       Require an exact match between PARM and ARG.\n+     UNIFY_ALLOW_MORE_CV_QUAL:\n+       Allow the deduced ARG to be more cv-qualified than ARG.\n+     UNIFY_ALLOW_LESS_CV_QUAL:\n+       Allow the deduced ARG to be less cv-qualified than ARG.\n+     UNIFY_ALLOW_DERIVED:\n+       Allow the deduced ARG to be a template base class of ARG,\n+       or a pointer to a template base class of the type pointed to by\n+       ARG.  */\n+\n+int\n+unify (tparms, targs, parm, arg, strict, explicit_mask)\n      tree tparms, targs, parm, arg;\n-     int ntparms, strict;\n+     int strict;\n      int* explicit_mask;\n {\n   int idx;\n@@ -5801,11 +6022,16 @@ unify (tparms, targs, ntparms, parm, arg, strict, explicit_mask)\n   if (arg == parm && !uses_template_parms (parm))\n     return 0;\n \n-  /* We can't remove cv-quals when strict.  */\n-  if (strict && TREE_CODE (arg) == TREE_CODE (parm)\n+  /* Immediately reject some pairs that won't unify because of\n+     cv-qualification mismatches.  */\n+  if (TREE_CODE (arg) == TREE_CODE (parm)\n       && TREE_CODE_CLASS (TREE_CODE (arg)) == 't'\n-      && (TYPE_READONLY (arg) < TYPE_READONLY (parm)\n-\t  || TYPE_VOLATILE (arg) < TYPE_VOLATILE (parm)))\n+      /* We check the cv-qualifiers when unifying with template type\n+\t parameters below.  We want to allow ARG `const T' to unify with\n+\t PARM `T' for example, when computing which of two templates\n+\t is more specialized, for example.  */\n+      && TREE_CODE (arg) != TEMPLATE_TYPE_PARM\n+      && !check_cv_quals_for_unify (strict, arg, parm))\n     return 1;\n \n   switch (TREE_CODE (parm))\n@@ -5885,8 +6111,9 @@ unify (tparms, targs, ntparms, parm, arg, strict, explicit_mask)\n \n \t\t    /* This argument can be deduced.  */\n \n-\t\t    if (unify (tparms, targs, ntparms, t, \n-\t\t\t       TREE_VEC_ELT (argvec, i), strict, explicit_mask))\n+\t\t    if (unify (tparms, targs, t, \n+\t\t\t       TREE_VEC_ELT (argvec, i), \n+\t\t\t       UNIFY_ALLOW_NONE, explicit_mask))\n \t\t      return 1;\n \t\t  }\n \t      }\n@@ -5895,25 +6122,20 @@ unify (tparms, targs, ntparms, parm, arg, strict, explicit_mask)\n \t}\n       else\n \t{\n-\t  if (strict && (TYPE_READONLY (arg) < TYPE_READONLY (parm)\n-\t\t\t || TYPE_VOLATILE (arg) < TYPE_VOLATILE (parm)))\n+\t  /* If PARM is `const T' and ARG is only `int', we don't have\n+\t     a match unless we are allowing additional qualification.\n+\t     If ARG is `const int' and PARM is just `T' that's OK;\n+\t     that binds `const int' to `T'.  */\n+\t  if (!check_cv_quals_for_unify (strict | UNIFY_ALLOW_LESS_CV_QUAL, \n+\t\t\t\t\t arg, parm))\n \t    return 1;\n \n-#if 0\n-\t  /* Template type parameters cannot contain cv-quals; i.e.\n-\t     template <class T> void f (T& a, T& b) will not generate\n-\t     void f (const int& a, const int& b).  */\n-\t  if (TYPE_READONLY (arg) > TYPE_READONLY (parm)\n-\t      || TYPE_VOLATILE (arg) > TYPE_VOLATILE (parm))\n-\t    return 1;\n-\t  arg = TYPE_MAIN_VARIANT (arg);\n-#else\n-\t  {\n-\t    int constp = TYPE_READONLY (arg) > TYPE_READONLY (parm);\n-\t    int volatilep = TYPE_VOLATILE (arg) > TYPE_VOLATILE (parm);\n-\t    arg = cp_build_type_variant (arg, constp, volatilep);\n-\t  }\n-#endif\n+\t  /* Consider the case where ARG is `const volatile int' and\n+\t     PARM is `const T'.  Then, T should be `volatile int'.  */\n+\t  arg = \n+\t    cp_build_type_variant (arg, \n+\t\t\t\t   TYPE_READONLY (arg) > TYPE_READONLY (parm),\n+\t\t\t\t   TYPE_VOLATILE (arg) > TYPE_VOLATILE (parm));\n \t}\n \n       /* Simple cases: Value already set, does match or doesn't.  */\n@@ -5954,20 +6176,48 @@ unify (tparms, targs, ntparms, parm, arg, strict, explicit_mask)\n       return 0;\n \n     case POINTER_TYPE:\n-      if (TREE_CODE (arg) == RECORD_TYPE && TYPE_PTRMEMFUNC_FLAG (arg))\n-\treturn unify (tparms, targs, ntparms, parm,\n-\t\t      TYPE_PTRMEMFUNC_FN_TYPE (arg), strict, explicit_mask);\n+      {\n+\tint sub_strict;\n \n-      if (TREE_CODE (arg) != POINTER_TYPE)\n-\treturn 1;\n-      return unify (tparms, targs, ntparms, TREE_TYPE (parm), TREE_TYPE (arg),\n-\t\t    strict, explicit_mask);\n+\tif (TREE_CODE (arg) == RECORD_TYPE && TYPE_PTRMEMFUNC_FLAG (arg))\n+\t  return (unify (tparms, targs, parm, \n+\t\t\t TYPE_PTRMEMFUNC_FN_TYPE (arg), strict,\n+\t\t\t explicit_mask)); \n+\t\n+\tif (TREE_CODE (arg) != POINTER_TYPE)\n+\t  return 1;\n+\t\n+\t/* [temp.deduct.call]\n+\n+\t   A can be another pointer or pointer to member type that can\n+\t   be converted to the deduced A via a qualification\n+\t   conversion (_conv.qual_).\n+\n+\t   We pass down STRICT here rather than UNIFY_ALLOW_NONE.\n+\t   This will allow for additional cv-qualification of the\n+\t   pointed-to types if appropriate.  In general, this is a bit\n+\t   too generous; we are only supposed to allow qualification\n+\t   conversions and this method will allow an ARG of char** and\n+\t   a deduced ARG of const char**.  However, overload\n+\t   resolution will subsequently invalidate the candidate, so\n+\t   this is probably OK.  */\n+\tsub_strict = strict;\n+\t\n+\tif (TREE_CODE (TREE_TYPE (arg)) != RECORD_TYPE\n+\t    || TYPE_PTRMEMFUNC_FLAG (TREE_TYPE (arg)))\n+\t  /* The derived-to-base conversion only persists through one\n+\t     level of pointers.  */\n+\t  sub_strict &= ~UNIFY_ALLOW_DERIVED;\n+\n+\treturn unify (tparms, targs, TREE_TYPE (parm), TREE_TYPE\n+\t\t      (arg), sub_strict,  explicit_mask);\n+      }\n \n     case REFERENCE_TYPE:\n-      if (TREE_CODE (arg) == REFERENCE_TYPE)\n-\targ = TREE_TYPE (arg);\n-      return unify (tparms, targs, ntparms, TREE_TYPE (parm), arg,\n-\t\t    strict, explicit_mask);\n+      if (TREE_CODE (arg) != REFERENCE_TYPE)\n+\treturn 1;\n+      return unify (tparms, targs, TREE_TYPE (parm), TREE_TYPE (arg),\n+\t\t    UNIFY_ALLOW_NONE, explicit_mask);\n \n     case ARRAY_TYPE:\n       if (TREE_CODE (arg) != ARRAY_TYPE)\n@@ -5976,11 +6226,11 @@ unify (tparms, targs, ntparms, parm, arg, strict, explicit_mask)\n \t  != (TYPE_DOMAIN (arg) == NULL_TREE))\n \treturn 1;\n       if (TYPE_DOMAIN (parm) != NULL_TREE\n-\t  && unify (tparms, targs, ntparms, TYPE_DOMAIN (parm),\n-\t\t    TYPE_DOMAIN (arg), strict, explicit_mask) != 0)\n+\t  && unify (tparms, targs, TYPE_DOMAIN (parm),\n+\t\t    TYPE_DOMAIN (arg), UNIFY_ALLOW_NONE, explicit_mask) != 0)\n \treturn 1;\n-      return unify (tparms, targs, ntparms, TREE_TYPE (parm), TREE_TYPE (arg),\n-\t\t    strict, explicit_mask);\n+      return unify (tparms, targs, TREE_TYPE (parm), TREE_TYPE (arg),\n+\t\t    UNIFY_ALLOW_NONE, explicit_mask);\n \n     case REAL_TYPE:\n     case COMPLEX_TYPE:\n@@ -5993,16 +6243,20 @@ unify (tparms, targs, ntparms, parm, arg, strict, explicit_mask)\n       if (TREE_CODE (parm) == INTEGER_TYPE)\n \t{\n \t  if (TYPE_MIN_VALUE (parm) && TYPE_MIN_VALUE (arg)\n-\t      && unify (tparms, targs, ntparms, TYPE_MIN_VALUE (parm),\n-\t\t\tTYPE_MIN_VALUE (arg), strict, explicit_mask))\n+\t      && unify (tparms, targs, TYPE_MIN_VALUE (parm),\n+\t\t\tTYPE_MIN_VALUE (arg), UNIFY_ALLOW_NONE, explicit_mask))\n \t    return 1;\n \t  if (TYPE_MAX_VALUE (parm) && TYPE_MAX_VALUE (arg)\n-\t      && unify (tparms, targs, ntparms, TYPE_MAX_VALUE (parm),\n-\t\t\tTYPE_MAX_VALUE (arg), strict, explicit_mask))\n+\t      && unify (tparms, targs, TYPE_MAX_VALUE (parm),\n+\t\t\tTYPE_MAX_VALUE (arg), UNIFY_ALLOW_NONE, explicit_mask))\n \t    return 1;\n \t}\n       else if (TREE_CODE (parm) == REAL_TYPE\n-\t       && TYPE_MAIN_VARIANT (arg) != TYPE_MAIN_VARIANT (parm))\n+\t       /* We use the TYPE_MAIN_VARIANT since we have already\n+\t\t  checked cv-qualification at the top of the\n+\t\t  function.  */\n+\t       && !comptypes (TYPE_MAIN_VARIANT (arg),\n+\t\t\t      TYPE_MAIN_VARIANT (parm), 1))\n \treturn 1;\n \n       /* As far as unification is concerned, this wins.\t Later checks\n@@ -6027,28 +6281,32 @@ unify (tparms, targs, ntparms, parm, arg, strict, explicit_mask)\n \tif (TREE_VEC_LENGTH (parm) != TREE_VEC_LENGTH (arg))\n \t  return 1;\n \tfor (i = TREE_VEC_LENGTH (parm) - 1; i >= 0; i--)\n-\t  if (unify (tparms, targs, ntparms,\n+\t  if (unify (tparms, targs,\n \t\t     TREE_VEC_ELT (parm, i), TREE_VEC_ELT (arg, i),\n-\t\t     strict, explicit_mask))\n+\t\t     UNIFY_ALLOW_NONE, explicit_mask))\n \t    return 1;\n \treturn 0;\n       }\n \n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_FLAG (parm))\n-\treturn unify (tparms, targs, ntparms, TYPE_PTRMEMFUNC_FN_TYPE (parm),\n+\treturn unify (tparms, targs, TYPE_PTRMEMFUNC_FN_TYPE (parm),\n \t\t      arg, strict, explicit_mask);\n \n-      /* Allow trivial conversions.  */\n-      if (TREE_CODE (arg) != RECORD_TYPE\n-\t  || TYPE_READONLY (parm) < TYPE_READONLY (arg)\n-\t  || TYPE_VOLATILE (parm) < TYPE_VOLATILE (arg))\n+      if (TREE_CODE (arg) != RECORD_TYPE)\n \treturn 1;\n-\n+  \n       if (CLASSTYPE_TEMPLATE_INFO (parm) && uses_template_parms (parm))\n \t{\n \t  tree t = NULL_TREE;\n-\t  if (! strict)\n+\t  if (strict & UNIFY_ALLOW_DERIVED)\n+\t    /* [temp.deduct.call]\n+\n+\t       If P is a class, and P has the form template-id, then A\n+\t       can be a derived class of the deduced A.  Likewise, if\n+\t       P is a pointer to a class of the form template-id, A\n+\t       can be a pointer to a derived class pointed to by the\n+\t       deduced A.  */\n \t    t = get_template_base (CLASSTYPE_TI_TEMPLATE (parm), arg);\n \t  else if\n \t    (CLASSTYPE_TEMPLATE_INFO (arg)\n@@ -6057,40 +6315,38 @@ unify (tparms, targs, ntparms, parm, arg, strict, explicit_mask)\n \t  if (! t || t == error_mark_node)\n \t    return 1;\n \n-\t  return unify (tparms, targs, ntparms, CLASSTYPE_TI_ARGS (parm),\n-\t\t\tCLASSTYPE_TI_ARGS (t), strict, explicit_mask);\n+\t  return unify (tparms, targs, CLASSTYPE_TI_ARGS (parm),\n+\t\t\tCLASSTYPE_TI_ARGS (t), UNIFY_ALLOW_NONE,\n+\t\t\texplicit_mask);\n \t}\n-      else if (TYPE_MAIN_VARIANT (parm) != TYPE_MAIN_VARIANT (arg))\n+      else if (!comptypes (TYPE_MAIN_VARIANT (parm),\n+\t\t\t   TYPE_MAIN_VARIANT (arg), 1))\n \treturn 1;\n       return 0;\n \n     case METHOD_TYPE:\n-      if (TREE_CODE (arg) != METHOD_TYPE)\n-\treturn 1;\n-      goto check_args;\n-\n     case FUNCTION_TYPE:\n-      if (TREE_CODE (arg) != FUNCTION_TYPE)\n+      if (TREE_CODE (arg) != TREE_CODE (parm))\n \treturn 1;\n-     check_args:\n-      if (unify (tparms, targs, ntparms, TREE_TYPE (parm),\n-\t\t TREE_TYPE (arg), strict, explicit_mask))\n+\n+      if (unify (tparms, targs, TREE_TYPE (parm),\n+\t\t TREE_TYPE (arg), UNIFY_ALLOW_NONE, explicit_mask))\n \treturn 1;\n       return type_unification_real (tparms, targs, TYPE_ARG_TYPES (parm),\n \t\t\t\t    TYPE_ARG_TYPES (arg), 1, \n-\t\t\t\t    strict, 0, explicit_mask);\n+\t\t\t\t    DEDUCE_EXACT, 0, explicit_mask);\n \n     case OFFSET_TYPE:\n       if (TREE_CODE (arg) != OFFSET_TYPE)\n \treturn 1;\n-      if (unify (tparms, targs, ntparms, TYPE_OFFSET_BASETYPE (parm),\n-\t\t TYPE_OFFSET_BASETYPE (arg), strict, explicit_mask))\n+      if (unify (tparms, targs, TYPE_OFFSET_BASETYPE (parm),\n+\t\t TYPE_OFFSET_BASETYPE (arg), UNIFY_ALLOW_NONE, explicit_mask))\n \treturn 1;\n-      return unify (tparms, targs, ntparms, TREE_TYPE (parm),\n-\t\t    TREE_TYPE (arg), strict, explicit_mask);\n+      return unify (tparms, targs, TREE_TYPE (parm), TREE_TYPE (arg),\n+\t\t    UNIFY_ALLOW_NONE, explicit_mask);\n \n     case CONST_DECL:\n-      if (arg != decl_constant_value (parm))\n+      if (arg != decl_constant_value (parm)) \n \treturn 1;\n       return 0;\n \n@@ -6138,13 +6394,13 @@ unify (tparms, targs, ntparms, parm, arg, strict, explicit_mask)\n \t\t\t\t\t\t integer_type_node,\n \t\t\t\t\t\t arg, t2));\n \n-\t      return unify (tparms, targs, ntparms, t1, t,\n-\t\t\t    strict, explicit_mask);\n+\t      return unify (tparms, targs, t1, t, UNIFY_ALLOW_NONE,\n+\t\t\t    explicit_mask);\n \t    }\n \n \t  if (!IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (tc)))\n \t    /* Good, we mangaged to simplify the exression.  */\n-\t    return unify (tparms, targs, ntparms, t, arg, strict,\n+\t    return unify (tparms, targs, t, arg, UNIFY_ALLOW_NONE,\n \t\t\t  explicit_mask);\n \t  else\n \t    /* Bad, we couldn't simplify this.  Assume it doesn't\n@@ -6282,7 +6538,7 @@ get_bindings_real (fn, decl, explicit_args, check_rettype)\n   i = fn_type_unification (fn, explicit_args, targs, \n \t\t\t   decl_arg_types,\n \t\t\t   TREE_TYPE (TREE_TYPE (decl)),\n-\t\t\t   1,\n+\t\t\t   DEDUCE_EXACT,\n \t\t\t   extra_fn_arg);\n \n   if (i != 0)\n@@ -6335,9 +6591,9 @@ get_class_bindings (tparms, parms, args, outer_args)\n \n   for (i = 0; i < TREE_VEC_LENGTH (parms); ++i)\n     {\n-      switch (unify (tparms, vec, ntparms,\n+      switch (unify (tparms, vec, \n \t\t     TREE_VEC_ELT (parms, i), TREE_VEC_ELT (args, i),\n-\t\t     1, 0))\n+\t\t     UNIFY_ALLOW_NONE, 0))\n \t{\n \tcase 0:\n \t  break;\n@@ -6628,6 +6884,75 @@ do_type_instantiation (t, storage)\n   }\n }\n \n+/* Given a function DECL, which is a specialization of TEMP, modify\n+   DECL to be a re-instantiation of TEMPL with the same template\n+   arguments.\n+\n+   One reason for doing this is a scenario like this:\n+\n+     template <class T>\n+     void f(const T&, int i);\n+\n+     void g() { f(3, 7); }\n+\n+     template <class T>\n+     void f(const T& t, const int i) { }\n+\n+   Note that when the template is first instantiated, with\n+   instantiate_template, the resulting DECL will have no name for the\n+   first parameter, and the wrong type for the second.  So, when we go\n+   to instantiate the DECL, we regenerate it.  */\n+\n+void\n+regenerate_decl_from_template (decl, tmpl)\n+     tree decl;\n+     tree tmpl;\n+{\n+  tree args;\n+  tree save_ti;\n+  tree code_pattern;\n+  tree new_decl;\n+\n+  args = DECL_TI_ARGS (decl);\n+  code_pattern = DECL_TEMPLATE_RESULT (tmpl);\n+\n+  /* Trick tsubst into giving us a new decl.  CODE_PATTERN must be the\n+     most distant ancestor of DECL, since that's the one that will\n+     actually be altered by a redefinition.  */\n+  save_ti = DECL_TEMPLATE_INFO (code_pattern);\n+  DECL_TEMPLATE_INFO (code_pattern) = NULL_TREE;\n+  new_decl = tsubst (code_pattern, args, NULL_TREE);\n+  SET_DECL_IMPLICIT_INSTANTIATION (new_decl);\n+  DECL_TEMPLATE_INFO (code_pattern) = save_ti;\n+\n+  if (TREE_CODE (decl) == VAR_DECL)\n+    {\n+      /* Set up DECL_INITIAL, since tsubst doesn't.  */\n+      pushclass (DECL_CONTEXT (decl), 2);\n+      DECL_INITIAL (new_decl) = \n+\ttsubst_expr (DECL_INITIAL (code_pattern), args, \n+\t\t     DECL_TI_TEMPLATE (decl));\n+      popclass (1);\n+    }\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      /* Convince duplicate_decls to use the DECL_ARGUMENTS from the\n+\t new decl.  */ \n+      DECL_INITIAL (new_decl) = error_mark_node;\n+\n+      if (DECL_TEMPLATE_SPECIALIZATION (new_decl) \n+\t  && !DECL_TEMPLATE_INFO (new_decl))\n+\t/* Set up the information about what is being specialized. */\n+\tDECL_TEMPLATE_INFO (new_decl) = DECL_TEMPLATE_INFO (decl);\n+    }\n+\n+  duplicate_decls (new_decl, decl);\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    DECL_INITIAL (new_decl) = NULL_TREE;\n+}\n+\n /* Produce the definition of D, a _DECL generated from a template.  */\n \n tree\n@@ -6637,7 +6962,7 @@ instantiate_decl (d)\n   tree ti = DECL_TEMPLATE_INFO (d);\n   tree tmpl = TI_TEMPLATE (ti);\n   tree args = TI_ARGS (ti);\n-  tree td, temp;\n+  tree td;\n   tree decl_pattern, code_pattern;\n   tree save_ti;\n   int nested = in_function_p ();\n@@ -6747,38 +7072,7 @@ instantiate_decl (d)\n   lineno = DECL_SOURCE_LINE (d);\n   input_filename = DECL_SOURCE_FILE (d);\n \n-  /* Trick tsubst into giving us a new decl in case the template changed.  */\n-  save_ti = DECL_TEMPLATE_INFO (decl_pattern);\n-  DECL_TEMPLATE_INFO (decl_pattern) = NULL_TREE;\n-  /* decl_pattern has all but one level of template parms bound.  Only pass\n-     in that one level of args.  */\n-  temp = innermost_args (args, DECL_TEMPLATE_SPECIALIZATION (decl_pattern));\n-  td = tsubst (decl_pattern, temp, tmpl);\n-  SET_DECL_IMPLICIT_INSTANTIATION (td);\n-  DECL_TEMPLATE_INFO (decl_pattern) = save_ti;\n-\n-  /* And set up DECL_INITIAL, since tsubst doesn't.  */\n-  if (TREE_CODE (td) == VAR_DECL)\n-    {\n-      pushclass (DECL_CONTEXT (d), 2);\n-      DECL_INITIAL (td) = tsubst_expr (DECL_INITIAL (code_pattern), args,\n-\t\t\t\t       tmpl);\n-      popclass (1);\n-    }\n-\n-  if (TREE_CODE (d) == FUNCTION_DECL)\n-    {\n-      /* Convince duplicate_decls to use the DECL_ARGUMENTS from the\n-\t new decl.  */ \n-      DECL_INITIAL (td) = error_mark_node;\n-\n-      if (DECL_TEMPLATE_SPECIALIZATION (td) && !DECL_TEMPLATE_INFO (td))\n-\t/* Set up the information about what is being specialized. */\n-\tDECL_TEMPLATE_INFO (td) = DECL_TEMPLATE_INFO (d);\n-    }\n-  duplicate_decls (td, d);\n-  if (TREE_CODE (d) == FUNCTION_DECL)\n-    DECL_INITIAL (td) = 0;\n+  regenerate_decl_from_template (d, td);\n \n   if (TREE_CODE (d) == VAR_DECL)\n     {"}, {"sha": "19e433e2f70b69f15497fd55b525118b01d5a692", "filename": "gcc/testsuite/g++.old-deja/g++.pt/conv1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fconv1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fconv1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fconv1.C?ref=830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a", "patch": "@@ -0,0 +1,19 @@\n+// Build don't link:\n+\n+template <class T>\n+struct S1 {};\n+\n+struct S2\n+{\n+  template <class T>\n+  operator S1<T>*();\n+};\n+\n+struct D: public S1<int> {\n+};\n+\n+void f()\n+{\n+  S2 s;\n+  (D*) s; // ERROR - cannot convert\n+}"}, {"sha": "824ee76f0c519df70433622ff8e55a73ac6ad9bf", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memclass9.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass9.C?ref=830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a", "patch": "@@ -0,0 +1,32 @@\n+// Build don't link:\n+\n+template <class T>\n+struct S1\n+{\n+  template <class U>\n+  struct S2\n+  { \n+    S2(U);\n+\n+    void g() \n+      {\n+\tS2<U> s2u (u);\n+      }\n+\n+    U& u;\n+  };\n+\n+  template <class U>\n+  void f(U u)\n+    {\n+      S2<U> s2u(u);\n+      s2u.g();\n+    }\n+};\n+\n+void g()\n+{\n+  S1<int> s1;\n+  s1.f(3.0);\n+}\n+"}, {"sha": "847dc0eda38cbd064e443bb46d784ec63a1f10c3", "filename": "gcc/testsuite/g++.old-deja/g++.pt/unify3.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funify3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funify3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funify3.C?ref=830bfa74b082c1cd0d5550ee4f0f4364f46f1a0a", "patch": "@@ -0,0 +1,22 @@\n+// Build don't link:\n+\n+template <class T1, class T2>\n+struct ComputeBinaryType\n+{\n+};\n+\n+template<class T1>\n+struct ComputeBinaryType<T1, double> {\n+  void g();\n+};\n+\n+template<class T1>\n+struct ComputeBinaryType<T1&, double> {\n+  void h();\n+};\n+\n+void f()\n+{ \n+  ComputeBinaryType<double, double> cb;\n+  cb.g();\n+}"}]}