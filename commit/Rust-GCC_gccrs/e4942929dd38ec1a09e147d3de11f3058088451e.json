{"sha": "e4942929dd38ec1a09e147d3de11f3058088451e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ5NDI5MjlkZDM4ZWMxYTA5ZTE0N2QzZGUxMWYzMDU4MDg4NDUxZQ==", "commit": {"author": {"name": "Paul Koning", "email": "ni1d@arrl.net", "date": "2010-11-21T16:52:36Z"}, "committer": {"name": "Paul Koning", "email": "pkoning@gcc.gnu.org", "date": "2010-11-21T16:52:36Z"}, "message": "pdp11.c (pdp11_legitimate_address_p): New function.\n\n* config/mips/pdp11.c (pdp11_legitimate_address_p): New function.\n* config/mips/pdp11.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n\nFrom-SVN: r167005", "tree": {"sha": "8f73668d4c3dcf13006f58e7c38f8146417b7e2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f73668d4c3dcf13006f58e7c38f8146417b7e2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4942929dd38ec1a09e147d3de11f3058088451e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4942929dd38ec1a09e147d3de11f3058088451e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4942929dd38ec1a09e147d3de11f3058088451e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4942929dd38ec1a09e147d3de11f3058088451e/comments", "author": null, "committer": null, "parents": [{"sha": "7a7e0183baf5a11e2014b2327e4f921a37391578", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a7e0183baf5a11e2014b2327e4f921a37391578", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a7e0183baf5a11e2014b2327e4f921a37391578"}], "stats": {"total": 231, "additions": 118, "deletions": 113}, "files": [{"sha": "09544e1a12e88fe6200a89de75f4d0bb10c09798", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4942929dd38ec1a09e147d3de11f3058088451e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4942929dd38ec1a09e147d3de11f3058088451e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4942929dd38ec1a09e147d3de11f3058088451e", "patch": "@@ -1,3 +1,8 @@\n+2010-11-21  Paul Koning  <ni1d@arrl.net>\n+\n+\t* config/mips/pdp11.c (pdp11_legitimate_address_p): New function.\n+\t* config/mips/pdp11.h (GO_IF_LEGITIMATE_ADDRESS): Delete.\n+\n 2010-11-21  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/mips/mips.c (machine_function): Rename load_label_length to"}, {"sha": "0188dc01b16b3d43ce81f5e919447ccdaed9c55f", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 113, "deletions": 1, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4942929dd38ec1a09e147d3de11f3058088451e/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4942929dd38ec1a09e147d3de11f3058088451e/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=e4942929dd38ec1a09e147d3de11f3058088451e", "patch": "@@ -227,6 +227,9 @@ static const struct default_options pdp11_option_optimization_table[] =\n \n #undef  TARGET_PREFERRED_OUTPUT_RELOAD_CLASS\n #define TARGET_PREFERRED_OUTPUT_RELOAD_CLASS pdp11_preferred_output_reload_class\n+\n+#undef  TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P pdp11_legitimate_address_p\n \f\n /* Implement TARGET_HANDLE_OPTION.  */\n \n@@ -1706,6 +1709,115 @@ pdp11_secondary_memory_needed (reg_class_t c1, reg_class_t c2,\n   return (fromfloat != tofloat);\n }\n \n+/* TARGET_LEGITIMATE_ADDRESS_P recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+*/\n+\n+static bool\n+pdp11_legitimate_address_p (enum machine_mode mode,\n+\t\t\t    rtx operand, bool strict)\n+{\n+    rtx xfoob;\n+\n+    /* accept @#address */\n+    if (CONSTANT_ADDRESS_P (operand))\n+      return true;\n+    \n+    switch (GET_CODE (operand))\n+      {\n+      case REG:\n+\t/* accept (R0) */\n+\treturn !strict || REGNO_OK_FOR_BASE_P (REGNO (operand));\n+    \n+      case PLUS:\n+\t/* accept X(R0) */\n+\treturn GET_CODE (XEXP (operand, 0)) == REG\n+\t  && (!strict || REGNO_OK_FOR_BASE_P (REGNO (XEXP (operand, 0))))\n+\t  && CONSTANT_ADDRESS_P (XEXP (operand, 1));\n+\n+      case PRE_DEC:\n+\t/* accept -(R0) */\n+\treturn GET_CODE (XEXP (operand, 0)) == REG\n+\t  && (!strict || REGNO_OK_FOR_BASE_P (REGNO (XEXP (operand, 0))));\n+\n+      case POST_INC:\n+\t/* accept (R0)+ */\n+\treturn GET_CODE (XEXP (operand, 0)) == REG\n+\t  && (!strict || REGNO_OK_FOR_BASE_P (REGNO (XEXP (operand, 0))));\n+\n+      case PRE_MODIFY:\n+\t/* accept -(SP) -- which uses PRE_MODIFY for byte mode */\n+\treturn GET_CODE (XEXP (operand, 0)) == REG\n+\t  && REGNO (XEXP (operand, 0)) == STACK_POINTER_REGNUM\n+\t  && GET_CODE ((xfoob = XEXP (operand, 1))) == PLUS\n+\t  && GET_CODE (XEXP (xfoob, 0)) == REG\n+\t  && REGNO (XEXP (xfoob, 0)) == STACK_POINTER_REGNUM\n+\t  && CONSTANT_P (XEXP (xfoob, 1))\n+\t  && INTVAL (XEXP (xfoob,1)) == -2;\n+\n+      case POST_MODIFY:\n+\t/* accept (SP)+ -- which uses POST_MODIFY for byte mode */\n+\treturn GET_CODE (XEXP (operand, 0)) == REG\n+\t  && REGNO (XEXP (operand, 0)) == STACK_POINTER_REGNUM\n+\t  && GET_CODE ((xfoob = XEXP (operand, 1))) == PLUS\n+\t  && GET_CODE (XEXP (xfoob, 0)) == REG\n+\t  && REGNO (XEXP (xfoob, 0)) == STACK_POINTER_REGNUM\n+\t  && CONSTANT_P (XEXP (xfoob, 1))\n+\t  && INTVAL (XEXP (xfoob,1)) == 2;\n+\n+      case MEM:\n+\t/* handle another level of indirection ! */\n+\txfoob = XEXP (operand, 0);\n+\n+\t/* (MEM:xx (MEM:xx ())) is not valid for SI, DI and currently\n+\t   also forbidden for float, because we have to handle this \n+\t   in output_move_double and/or output_move_quad() - we could\n+\t   do it, but currently it's not worth it!!! \n+\t   now that DFmode cannot go into CPU register file, \n+\t   maybe I should allow float ... \n+\t   but then I have to handle memory-to-memory moves in movdf ??  */\n+\tif (GET_MODE_BITSIZE(mode) > 16)\n+\t  return false;\n+\n+\t/* accept @address */\n+\tif (CONSTANT_ADDRESS_P (xfoob))\n+\t  return true;\n+\n+\tswitch (GET_CODE (xfoob))\n+\t  {\n+\t  case REG:\n+\t    /* accept @(R0) - which is @0(R0) */\n+\t    return !strict || REGNO_OK_FOR_BASE_P(REGNO (xfoob));\n+\n+\t  case PLUS:\n+\t    /* accept @X(R0) */\n+\t    return GET_CODE (XEXP (xfoob, 0)) == REG\n+\t      && (!strict || REGNO_OK_FOR_BASE_P (REGNO (XEXP (xfoob, 0))))\n+\t      && CONSTANT_ADDRESS_P (XEXP (xfoob, 1));\n+\n+\t  case PRE_DEC:\n+\t    /* accept @-(R0) */\n+\t    return GET_CODE (XEXP (xfoob, 0)) == REG\n+\t      && (!strict || REGNO_OK_FOR_BASE_P (REGNO (XEXP (xfoob, 0))));\n+\n+\t  case POST_INC:\n+\t    /* accept @(R0)+ */\n+\t    return GET_CODE (XEXP (xfoob, 0)) == REG\n+\t      && (!strict || REGNO_OK_FOR_BASE_P (REGNO (XEXP (xfoob, 0))));\n+\n+\t  default:\n+\t    /* anything else is invalid */\n+\t    return false;\n+\t  }\n+\n+      default:\n+\t/* anything else is invalid */\n+\treturn false;\n+      }\n+}\n /* Return the class number of the smallest class containing\n    reg number REGNO.  */\n enum reg_class\n@@ -1919,7 +2031,7 @@ pdp11_libcall_value (enum machine_mode mode,\n static bool\n pdp11_function_value_regno_p (const unsigned int regno)\n {\n-  return (regno == 0) || (TARGET_AC0 && (regno == 8));\n+  return (regno == RETVAL_REGNUM) || (TARGET_AC0 && (regno == AC0_REGNUM));\n }\n \n /* Worker function for TARGET_TRAMPOLINE_INIT."}, {"sha": "b5c644933c41b63628a6a8cc9a1ab1a8c20f6adf", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4942929dd38ec1a09e147d3de11f3058088451e/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4942929dd38ec1a09e147d3de11f3058088451e/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=e4942929dd38ec1a09e147d3de11f3058088451e", "patch": "@@ -499,118 +499,6 @@ extern int may_call_alloca;\n #define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n \n #endif\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-*/\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(mode, operand, ADDR) \\\n-{\t\t\t\t\t\t      \\\n-    rtx xfoob;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* accept (R0) */\t\t\t\t\t\t\t\\\n-    if (GET_CODE (operand) == REG\t\t\t\t\t\\\n-\t&& REG_OK_FOR_BASE_P(operand))\t\t\t\t\t\\\n-      goto ADDR;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* accept @#address */\t\t\t\t\t\t\\\n-    if (CONSTANT_ADDRESS_P (operand))\t\t\t\t\t\\\n-      goto ADDR;\t\t\t\t\t\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-    /* accept X(R0) */\t\t\t\t\t\t\t\\\n-    if (GET_CODE (operand) == PLUS       \t\t\t\t\\\n-\t&& GET_CODE (XEXP (operand, 0)) == REG\t\t\t\t\\\n-\t&& REG_OK_FOR_BASE_P (XEXP (operand, 0))\t\t\t\\\n-\t&& CONSTANT_ADDRESS_P (XEXP (operand, 1)))\t\t\t\\\n-      goto ADDR;\t\t\t\t\t\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-    /* accept -(R0) */\t\t\t\t\t\t\t\\\n-    if (GET_CODE (operand) == PRE_DEC\t\t\t\t\t\\\n-\t&& GET_CODE (XEXP (operand, 0)) == REG\t\t\t\t\\\n-\t&& REG_OK_FOR_BASE_P (XEXP (operand, 0)))\t\t\t\\\n-      goto ADDR;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* accept (R0)+ */\t\t\t\t\t\t\t\\\n-    if (GET_CODE (operand) == POST_INC\t\t\t\t\t\\\n-\t&& GET_CODE (XEXP (operand, 0)) == REG\t\t\t\t\\\n-\t&& REG_OK_FOR_BASE_P (XEXP (operand, 0)))\t\t\t\\\n-      goto ADDR;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* accept -(SP) -- which uses PRE_MODIFY for byte mode */\t\t\\\n-    if (GET_CODE (operand) == PRE_MODIFY\t\t\t\t\\\n-\t&& GET_CODE (XEXP (operand, 0)) == REG\t\t\t\t\\\n-\t&& REGNO (XEXP (operand, 0)) == STACK_POINTER_REGNUM       \t\\\n-\t&& GET_CODE ((xfoob = XEXP (operand, 1))) == PLUS\t\t\\\n-\t&& GET_CODE (XEXP (xfoob, 0)) == REG\t\t\t\t\\\n-\t&& REGNO (XEXP (xfoob, 0)) == STACK_POINTER_REGNUM       \t\\\n-\t&& CONSTANT_P (XEXP (xfoob, 1))                                 \\\n-\t&& INTVAL (XEXP (xfoob,1)) == -2)      \t               \t\t\\\n-      goto ADDR;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* accept (SP)+ -- which uses POST_MODIFY for byte mode */\t\t\\\n-    if (GET_CODE (operand) == POST_MODIFY\t\t\t\t\\\n-\t&& GET_CODE (XEXP (operand, 0)) == REG\t\t\t\t\\\n-\t&& REGNO (XEXP (operand, 0)) == STACK_POINTER_REGNUM       \t\\\n-\t&& GET_CODE ((xfoob = XEXP (operand, 1))) == PLUS\t\t\\\n-\t&& GET_CODE (XEXP (xfoob, 0)) == REG\t\t\t\t\\\n-\t&& REGNO (XEXP (xfoob, 0)) == STACK_POINTER_REGNUM\t\t\\\n-\t&& CONSTANT_P (XEXP (xfoob, 1))                                 \\\n-\t&& INTVAL (XEXP (xfoob,1)) == 2)      \t               \t\t\\\n-      goto ADDR;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-    /* handle another level of indirection ! */\t\t\t\t\\\n-    if (GET_CODE(operand) != MEM)\t\t\t\t\t\\\n-      goto fail;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    xfoob = XEXP (operand, 0);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* (MEM:xx (MEM:xx ())) is not valid for SI, DI and currently */    \\\n-    /* also forbidden for float, because we have to handle this */  \t\\\n-    /* in output_move_double and/or output_move_quad() - we could */   \t\\\n-    /* do it, but currently it's not worth it!!! */\t\t\t\\\n-    /* now that DFmode cannot go into CPU register file, */\t\t\\\n-    /* maybe I should allow float ... */\t\t\t\t\\\n-    /*  but then I have to handle memory-to-memory moves in movdf ?? */ \\\n-\t\t\t\t\t\t\t\t\t\\\n-    if (GET_MODE_BITSIZE(mode) > 16)\t\t\t\t\t\\\n-      goto fail;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* accept @(R0) - which is @0(R0) */\t\t\t\t\\\n-    if (GET_CODE (xfoob) == REG\t\t\t\t\t\t\\\n-\t&& REG_OK_FOR_BASE_P(xfoob))\t\t\t\t\t\\\n-      goto ADDR;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* accept @address */\t\t\t\t\t\t\\\n-    if (CONSTANT_ADDRESS_P (xfoob))\t\t\t\t\t\\\n-      goto ADDR;\t\t\t\t\t\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-    /* accept @X(R0) */\t\t\t\t\t\t\t\\\n-    if (GET_CODE (xfoob) == PLUS       \t\t\t\t\t\\\n-\t&& GET_CODE (XEXP (xfoob, 0)) == REG\t\t\t\t\\\n-\t&& REG_OK_FOR_BASE_P (XEXP (xfoob, 0))\t\t\t\t\\\n-\t&& CONSTANT_ADDRESS_P (XEXP (xfoob, 1)))\t\t\t\\\n-      goto ADDR;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* accept @-(R0) */\t\t\t\t\t\t\t\\\n-    if (GET_CODE (xfoob) == PRE_DEC\t\t\t\t\t\\\n-\t&& GET_CODE (XEXP (xfoob, 0)) == REG\t\t\t\t\\\n-\t&& REG_OK_FOR_BASE_P (XEXP (xfoob, 0)))\t\t\t\t\\\n-      goto ADDR;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* accept @(R0)+ */\t\t\t\t\t\t\t\\\n-    if (GET_CODE (xfoob) == POST_INC\t\t\t\t\t\\\n-\t&& GET_CODE (XEXP (xfoob, 0)) == REG\t\t\t\t\\\n-\t&& REG_OK_FOR_BASE_P (XEXP (xfoob, 0)))\t\t\t\t\\\n-      goto ADDR;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  /* anything else is invalid */\t\t\t\t\t\\\n-  fail: ;\t\t\t\t\t\t\t\t\\\n-}\n-\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */"}]}