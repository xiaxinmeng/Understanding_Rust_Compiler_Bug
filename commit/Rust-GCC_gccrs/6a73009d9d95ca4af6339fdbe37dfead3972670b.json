{"sha": "6a73009d9d95ca4af6339fdbe37dfead3972670b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE3MzAwOWQ5ZDk1Y2E0YWY2MzM5ZmRiZTM3ZGZlYWQzOTcyNjcwYg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1995-11-27T07:55:04Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1995-11-27T07:55:04Z"}, "message": "pa.md (call expanders): For indirect calls, load %r22 with the function's address.\n\n\t* pa.md (call expanders): For indirect calls, load %r22 with the\n\tfunction's address.\n\t(indirect call patterns): No need to copy the call address into\n\t%r22 anymore.\n\n\t* pa.c (output_cbranch): Fix buglet in length handling of\n\tbackwards branches with unfilled delay slots.\n\t(output_bb, output_bvb, output_dbra, output_movb): Likewise.\n\n\t* pa.md: Fix off-by-one error in length computations for all\n\tconditional branch patterns.\n\n\t* pa.h (output_bvb): Declare.\n\t* pa.c (output_bvb): New function to output branch on variable\n\tbit insns.\n\t* pa.md (branch-on-variable-bit): New patterns.\n\n\t* pa.h (TARGET_MILLICODE_LONG_CALLS): Delete swtich and all\n\treferences.\n\t(output_millicode_call): Declare new function\n\t* pa.md (millicode calls): Update length computation to handle\n\tvariable length millicode calls.\n\t(call pattners): Likewise.\n\t(indirect call patterns): Update length compuations and output\n\ttemplates to handle variable length millicode calls.\n\t(plabel_dereference): Likewise.\n\t* pa.c (override_options): Give warnings when incompatable\n\toptions are used.\n\t(output_mul_insn): Call output_millicode_call instead of\n\toutput_call, eliminate last argument to output_millicode_call.\n\t(output_div_insn): Likewise.\n\t(output_mod_insn): Likewise.\n\t(output_call): Rewrite long call code to handle variable length\n\tmillicode calls.  Eliminate support for calling mul, div and mod\n\tmillicode routines.\n\t(output_millicode_call): New function for calling mul, div and mod\n\tmillicode routines.\n\nFrom-SVN: r10610", "tree": {"sha": "e7d6b12bbeabc350bbd62f81748c128c8f5b3b96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7d6b12bbeabc350bbd62f81748c128c8f5b3b96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a73009d9d95ca4af6339fdbe37dfead3972670b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a73009d9d95ca4af6339fdbe37dfead3972670b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a73009d9d95ca4af6339fdbe37dfead3972670b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a73009d9d95ca4af6339fdbe37dfead3972670b/comments", "author": null, "committer": null, "parents": [{"sha": "68944452e4abe12bbef4fa078bf614caa39c85cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68944452e4abe12bbef4fa078bf614caa39c85cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68944452e4abe12bbef4fa078bf614caa39c85cf"}], "stats": {"total": 956, "additions": 765, "deletions": 191}, "files": [{"sha": "6cb9d547b846ebe38dfa6ba5c0891af28c09330d", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 366, "deletions": 62, "changes": 428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a73009d9d95ca4af6339fdbe37dfead3972670b/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a73009d9d95ca4af6339fdbe37dfead3972670b/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=6a73009d9d95ca4af6339fdbe37dfead3972670b", "patch": "@@ -97,6 +97,16 @@ override_options ()\n     {\n       warning (\"Unknown -mschedule= option (%s).\\nValid options are 700, 7100 and 7100LC\\n\", pa_cpu_string);\n     }\n+\n+  if (flag_pic && TARGET_PORTABLE_RUNTIME)\n+    {\n+      warning (\"PIC code generation is not supported in the portable runtime model\\n\");\n+    }\n+\n+  if (flag_pic && TARGET_NO_SPACE_REGS)\n+   {\n+      warning (\"PIC code generation is not compatable with fast indirect calls\\n\");\n+   }\n }\n \n \n@@ -3166,8 +3176,7 @@ output_mul_insn (unsignedp, insn)\n      rtx insn;\n {\n   import_milli (mulI);\n-  return output_call (insn, gen_rtx (SYMBOL_REF, SImode, \"$$mulI\"),\n-\t\t      gen_rtx (REG, SImode, 31));\n+  return output_millicode_call (insn, gen_rtx (SYMBOL_REF, SImode, \"$$mulI\"));\n }\n \n /* Emit the rtl for doing a division by a constant. */\n@@ -3246,14 +3255,14 @@ output_div_insn (operands, unsignedp, insn)\n       if (unsignedp)\n \t{\n \t  sprintf (buf, \"$$divU_%d\", INTVAL (operands[0]));\n-\t  return output_call (insn, gen_rtx (SYMBOL_REF, SImode, buf),\n-\t\t\t      gen_rtx (REG, SImode, 31));\n+\t  return output_millicode_call (insn,\n+\t\t\t\t\tgen_rtx (SYMBOL_REF, SImode, buf));\n \t}\n       else\n \t{\n \t  sprintf (buf, \"$$divI_%d\", INTVAL (operands[0]));\n-\t  return output_call (insn, gen_rtx (SYMBOL_REF, SImode, buf),\n-\t\t\t      gen_rtx (REG, SImode, 31));\n+\t  return output_millicode_call (insn,\n+\t\t\t\t\tgen_rtx (SYMBOL_REF, SImode, buf));\n \t}\n     }\n   /* Divisor isn't a special constant. */\n@@ -3262,14 +3271,14 @@ output_div_insn (operands, unsignedp, insn)\n       if (unsignedp)\n \t{\n \t  import_milli (divU);\n-\t  return output_call (insn, gen_rtx (SYMBOL_REF, SImode, \"$$divU\"),\n-\t\t\t      gen_rtx (REG, SImode, 31));\n+\t  return output_millicode_call (insn,\n+\t\t\t\t\tgen_rtx (SYMBOL_REF, SImode, \"$$divU\"));\n \t}\n       else\n \t{\n \t  import_milli (divI);\n-\t  return output_call (insn, gen_rtx (SYMBOL_REF, SImode, \"$$divI\"),\n-\t\t\t      gen_rtx (REG, SImode, 31));\n+\t  return output_millicode_call (insn,\n+\t\t\t\t\tgen_rtx (SYMBOL_REF, SImode, \"$$divI\"));\n \t}\n     }\n }\n@@ -3284,14 +3293,14 @@ output_mod_insn (unsignedp, insn)\n   if (unsignedp)\n     {\n       import_milli (remU);\n-      return output_call (insn, gen_rtx (SYMBOL_REF, SImode, \"$$remU\"),\n-\t\t\t  gen_rtx (REG, SImode, 31));\n+      return output_millicode_call (insn,\n+\t\t\t\t    gen_rtx (SYMBOL_REF, SImode, \"$$remU\"));\n     }\n   else\n     {\n       import_milli (remI);\n-      return output_call (insn, gen_rtx (SYMBOL_REF, SImode, \"$$remI\"),\n-\t\t\t  gen_rtx (REG, SImode, 31));\n+      return output_millicode_call (insn,\n+\t\t\t\t    gen_rtx (SYMBOL_REF, SImode, \"$$remI\"));\n     }\n }\n \n@@ -3554,7 +3563,7 @@ output_cbranch (operands, nullify, length, negated, insn)\n \t\t && ! forward_branch_p (insn)\n \t\t && insn_addresses\n \t\t && VAL_14_BITS_P (insn_addresses[INSN_UID (JUMP_LABEL (insn))]\n-\t\t\t\t    - insn_addresses[INSN_UID (insn)]))\n+\t\t\t\t    - insn_addresses[INSN_UID (insn)] - 8))\n \t  {\n \t    strcpy (buf, \"com%I2b,\");\n \t    if (negated)\n@@ -3681,7 +3690,7 @@ output_bb (operands, nullify, length, negated, insn, which)\n \t\t && ! forward_branch_p (insn)\n \t\t && insn_addresses\n \t\t && VAL_14_BITS_P (insn_addresses[INSN_UID (JUMP_LABEL (insn))]\n-\t\t\t\t    - insn_addresses[INSN_UID (insn)]))\n+\t\t\t\t    - insn_addresses[INSN_UID (insn)] - 8))\n \t  {\n \t    strcpy (buf, \"bb,\");\n \t    if ((which == 0 && negated)\n@@ -3719,6 +3728,144 @@ output_bb (operands, nullify, length, negated, insn, which)\n   return buf;\n }\n \n+/* This routine handles all the branch-on-variable-bit conditional branch\n+   sequences we might need to generate.  It handles nullification of delay\n+   slots, varying length branches, negated branches and all combinations\n+   of the above.  it returns the appropriate output template to emit the\n+   branch.  */\n+\n+char *\n+output_bvb (operands, nullify, length, negated, insn, which)\n+  rtx *operands;\n+  int nullify, length, negated;\n+  rtx insn;\n+  int which;\n+{\n+  static char buf[100];\n+  int useskip = 0;\n+\n+  /* A conditional branch to the following instruction (eg the delay slot) is\n+     asking for a disaster.  I do not think this can happen as this pattern\n+     is only used when optimizing; jump optimization should eliminate the\n+     jump.  But be prepared just in case.  */\n+\n+  if (next_active_insn (JUMP_LABEL (insn)) == next_active_insn (insn))\n+    return \"\";\n+\n+  /* If this is a long branch with its delay slot unfilled, set `nullify'\n+     as it can nullify the delay slot and save a nop.  */\n+  if (length == 8 && dbr_sequence_length () == 0)\n+    nullify = 1;\n+\n+  /* If this is a short forward conditional branch which did not get\n+     its delay slot filled, the delay slot can still be nullified.  */\n+  if (! nullify && length == 4 && dbr_sequence_length () == 0)\n+    nullify = forward_branch_p (insn);\n+\n+  /* A forward branch over a single nullified insn can be done with a\n+     extrs instruction.  This avoids a single cycle penalty due to\n+     mis-predicted branch if we fall through (branch not taken).  */\n+\n+  if (length == 4\n+      && next_real_insn (insn) != 0\n+      && get_attr_length (next_real_insn (insn)) == 4\n+      && JUMP_LABEL (insn) == next_nonnote_insn (next_real_insn (insn))\n+      && nullify)\n+    useskip = 1;\n+\n+  switch (length)\n+    {\n+\n+      /* All short conditional branches except backwards with an unfilled\n+\t delay slot.  */\n+      case 4:\n+\tif (useskip)\n+\t  strcpy (buf, \"vextrs,\");\n+\telse\n+\t  strcpy (buf, \"bvb,\");\n+\tif ((which == 0 && negated)\n+\t     || (which == 1 && ! negated))\n+\t  strcat (buf, \">=\");\n+\telse\n+\t  strcat (buf, \"<\");\n+\tif (useskip)\n+\t  strcat (buf, \" %0,1,0\");\n+\telse if (nullify && negated)\n+\t  strcat (buf, \",n %0,%3\");\n+\telse if (nullify && ! negated)\n+\t  strcat (buf, \",n %0,%2\");\n+\telse if (! nullify && negated)\n+\t  strcat (buf, \"%0,%3\");\n+\telse if (! nullify && ! negated)\n+\t  strcat (buf, \" %0,%2\");\n+\tbreak;\n+\n+     /* All long conditionals.  Note an short backward branch with an\n+\tunfilled delay slot is treated just like a long backward branch\n+\twith an unfilled delay slot.  */\n+      case 8:\n+\t/* Handle weird backwards branch with a filled delay slot\n+\t   with is nullified.  */\n+\tif (dbr_sequence_length () != 0\n+\t    && ! forward_branch_p (insn)\n+\t    && nullify)\n+\t  {\n+\t    strcpy (buf, \"bvb,\");\n+\t    if ((which == 0 && negated)\n+\t\t|| (which == 1 && ! negated))\n+\t      strcat (buf, \"<\");\n+\t    else\n+\t      strcat (buf, \">=\");\n+\t    if (negated)\n+\t      strcat (buf, \",n %0,.+12\\n\\tbl %3,0\");\n+\t    else\n+\t      strcat (buf, \",n %0,.+12\\n\\tbl %2,0\");\n+\t  }\n+\t/* Handle short backwards branch with an unfilled delay slot.\n+\t   Using a bb;nop rather than extrs;bl saves 1 cycle for both\n+\t   taken and untaken branches.  */\n+\telse if (dbr_sequence_length () == 0\n+\t\t && ! forward_branch_p (insn)\n+\t\t && insn_addresses\n+\t\t && VAL_14_BITS_P (insn_addresses[INSN_UID (JUMP_LABEL (insn))]\n+\t\t\t\t    - insn_addresses[INSN_UID (insn)] - 8))\n+\t  {\n+\t    strcpy (buf, \"bvb,\");\n+\t    if ((which == 0 && negated)\n+\t\t|| (which == 1 && ! negated))\n+\t      strcat (buf, \">=\");\n+\t    else\n+\t      strcat (buf, \"<\");\n+\t    if (negated)\n+\t      strcat (buf, \" %0,%3%#\");\n+\t    else\n+\t      strcat (buf, \" %0,%2%#\");\n+\t  }\n+\telse\n+\t  {\n+\t    strcpy (buf, \"vextrs,\");\n+\t    if ((which == 0 && negated)\n+\t\t|| (which == 1 && ! negated))\n+\t      strcat (buf, \"<\");\n+\t    else\n+\t      strcat (buf, \">=\");\n+\t    if (nullify && negated)\n+\t      strcat (buf, \" %0,1,0\\n\\tbl,n %3,0\");\n+\t    else if (nullify && ! negated)\n+\t      strcat (buf, \" %0,1,0\\n\\tbl,n %2,0\");\n+\t    else if (negated)\n+\t      strcat (buf, \" %0,1,0\\n\\tbl %3,0\");\n+\t    else\n+\t      strcat (buf, \" %0,1,0\\n\\tbl %2,0\");\n+\t  }\n+\tbreak;\n+\n+      default:\n+\tabort();\n+    }\n+  return buf;\n+}\n+\n /* Return the output template for emitting a dbra type insn.\n \n    Note it may perform some output operations on its own before\n@@ -3786,7 +3933,7 @@ output_dbra (operands, insn, which_alternative)\n \t\t   && ! forward_branch_p (insn)\n \t\t   && insn_addresses\n \t\t   && VAL_14_BITS_P (insn_addresses[INSN_UID (JUMP_LABEL (insn))]\n-\t\t\t\t      - insn_addresses[INSN_UID (insn)]))\n+\t\t\t\t      - insn_addresses[INSN_UID (insn)] - 8))\n \t      return \"addib,%C2 %1,%0,%3%#\";\n \n \t  /* Handle normal cases.  */\n@@ -3892,7 +4039,7 @@ output_movb (operands, insn, which_alternative, reverse_comparison)\n \t\t   && ! forward_branch_p (insn)\n \t\t   && insn_addresses\n \t\t   && VAL_14_BITS_P (insn_addresses[INSN_UID (JUMP_LABEL (insn))]\n-\t\t\t\t      - insn_addresses[INSN_UID (insn)]))\n+\t\t\t\t      - insn_addresses[INSN_UID (insn)] - 8))\n \t    return \"movb,%C2 %1,%0,%3%#\";\n \t  /* Handle normal cases.  */\n \t  if (nullify)\n@@ -3928,41 +4075,177 @@ output_movb (operands, insn, which_alternative, reverse_comparison)\n }\n \n \n-/* INSN is either a function call or a millicode call.  It may have an\n-   unconditional jump in its delay slot.\n-\n-   CALL_DEST is the routine we are calling.\n+/* INSN is a millicode call.  It may have an unconditional jump in its delay\n+   slot.\n \n-   RETURN_POINTER is the register which will hold the return address.\n-   %r2 for most calls, %r31 for millicode calls. \n-\n-   When TARGET_MILLICODE_LONG_CALLS is true, then we have to assume\n-   that two instruction sequences must be used to reach the millicode\n-   routines (including dyncall!).  */\n+   CALL_DEST is the routine we are calling.  */\n \n char *\n-output_call (insn, call_dest, return_pointer)\n+output_millicode_call (insn, call_dest)\n   rtx insn;\n   rtx call_dest;\n-  rtx return_pointer;\n-\n {\n   int distance;\n   rtx xoperands[4];\n   rtx seq_insn;\n \n-  /* Handle long millicode calls for mod, div, and mul.  */\n-  if (TARGET_PORTABLE_RUNTIME\n-      || (TARGET_MILLICODE_LONG_CALLS && REGNO (return_pointer) == 31))\n+  /* Handle common case -- empty delay slot or no jump in the delay slot,\n+     and we're sure that the branch will reach the beginning of the $CODE$\n+     subspace.  */\n+  if ((dbr_sequence_length () == 0\n+/* CYGNUS LOCAL mentor6480hack/law */\n+       && (get_attr_length (insn) == 8 || get_attr_length (insn) == 28))\n+/* END CYGNUS LOCAL */\n+      || (dbr_sequence_length () != 0\n+\t  && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN\n+\t  && get_attr_length (insn) == 4))\n     {\n       xoperands[0] = call_dest;\n-      xoperands[1] = return_pointer;\n-      output_asm_insn (\"ldil L%%%0,%%r29\", xoperands);\n-      output_asm_insn (\"ldo R%%%0(%%r29),%%r29\", xoperands);\n-      output_asm_insn (\"blr 0,%r1\\n\\tbv,n 0(%%r29)\\n\\tnop\", xoperands);\n+      output_asm_insn (\"bl %0,%%r31%#\", xoperands);\n       return \"\";\n     }\n \n+  /* This call may not reach the beginning of the $CODE$ subspace.  */\n+  if (get_attr_length (insn) > 4)\n+    {\n+      int delay_insn_deleted = 0;\n+      rtx xoperands[2];\n+      rtx link;\n+\n+      /* We need to emit an inline long-call branch.  */\n+      if (dbr_sequence_length () != 0\n+\t  && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN)\n+\t{\n+\t  /* A non-jump insn in the delay slot.  By definition we can\n+\t     emit this insn before the call.  */\n+\t  final_scan_insn (NEXT_INSN (insn), asm_out_file, optimize, 0, 0);\n+\n+\t  /* Now delete the delay insn.  */\n+\t  PUT_CODE (NEXT_INSN (insn), NOTE);\n+\t  NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n+\t  NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n+\t  delay_insn_deleted = 1;\n+\t}\n+\n+      /* If we're allowed to use be/ble instructions, then this is the\n+\t best sequence to use for a long millicode call.  */\n+      if (TARGET_NO_SPACE_REGS\n+\t  || ! (flag_pic  || TARGET_PORTABLE_RUNTIME))\n+\t{\n+\t  xoperands[0] = call_dest;\n+\t  output_asm_insn (\"ldil L%%%0,%%r31\", xoperands);\n+\t  output_asm_insn (\"ble R%%%0(%%sr4,%%r31)\", xoperands);\n+\t  output_asm_insn (\"nop\", xoperands);\n+\t}\n+      /* Pure portable runtime doesn't allow be/ble; we also don't have\n+\t PIC support int he assembler/linker, so this sequence is needed.  */\n+      else if (TARGET_PORTABLE_RUNTIME)\n+\t{\n+\t  xoperands[0] = call_dest;\n+\t  /* Get the address of our target into %r29. */\n+\t  output_asm_insn (\"ldil L%%%0,%%r29\", xoperands);\n+\t  output_asm_insn (\"ldo R%%%0(%%r29),%%r29\", xoperands);\n+\n+\t  /* Get our return address into %r31.  */\n+\t  output_asm_insn (\"blr 0,%%r31\", xoperands);\n+\n+\t  /* Jump to our target address in %r29.  */\n+\t  output_asm_insn (\"bv,n 0(%%r29)\", xoperands);\n+\n+\t  /* Empty delay slot.  Note this insn gets fetched twice and\n+\t     executed once.  To be safe we use a nop.  */\n+\t  output_asm_insn (\"nop\", xoperands);\n+\t  return \"\";\n+\t}\n+      /* PIC long millicode call sequence.  */\n+      else\n+\t{\n+\t  xoperands[0] = call_dest;\n+\t  xoperands[1] = gen_label_rtx ();\n+\t  /* Get our address + 8 into %r1.  */\n+\t  output_asm_insn (\"bl .+8,%%r1\", xoperands);\n+\n+\t  /* Add %r1 to the offset of our target from the next insn.  */\n+\t  output_asm_insn (\"addil L%%%0-%1,%%r1\", xoperands);\n+\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n+\t\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n+\t  output_asm_insn (\"ldo R%%%0-%1(%%r1),%%r1\", xoperands);\n+\n+\t  /* Get the return address into %r31.  */\n+\t  output_asm_insn (\"blr 0,%%r31\", xoperands);\n+\n+\t  /* Branch to our target which is in %r1.  */\n+\t  output_asm_insn (\"bv,n 0(%%r1)\", xoperands);\n+\n+\t  /* Empty delay slot.  Note this insn gets fetched twice and\n+\t     executed once.  To be safe we use a nop.  */\n+\t  output_asm_insn (\"nop\", xoperands);\n+\t}\n+\n+      /* If we had a jump in the call's delay slot, output it now.  */\n+      if (dbr_sequence_length () != 0\n+\t  && !delay_insn_deleted)\n+\t{\n+\t  xoperands[0] = XEXP (PATTERN (NEXT_INSN (insn)), 1);\n+\t  output_asm_insn (\"b,n %0\", xoperands);\n+\n+\t  /* Now delete the delay insn.  */\n+\t  PUT_CODE (NEXT_INSN (insn), NOTE);\n+\t  NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n+\t  NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n+\t}\n+      return \"\";\n+    }\n+\n+  /* This call has an unconditional jump in its delay slot and the\n+     call is known to reach its target or the beginning of the current\n+     subspace.  */\n+\n+  /* Use the containing sequence insn's address.  */\n+  seq_insn = NEXT_INSN (PREV_INSN (XVECEXP (final_sequence, 0, 0)));\n+\n+  distance = insn_addresses[INSN_UID (JUMP_LABEL (NEXT_INSN (insn)))]\n+\t       - insn_addresses[INSN_UID (seq_insn)] - 8;\n+\n+  /* If the branch was too far away, emit a normal call followed\n+     by a nop, followed by the unconditional branch.\n+\n+     If the branch is close, then adjust %r2 from within the\n+     call's delay slot.  */\n+\n+  xoperands[0] = call_dest;\n+  xoperands[1] = XEXP (PATTERN (NEXT_INSN (insn)), 1);\n+  if (! VAL_14_BITS_P (distance))\n+    output_asm_insn (\"bl %0,%%r31\\n\\tnop\\n\\tbl,n %1,%%r0\", xoperands);\n+  else\n+    {\n+      xoperands[3] = gen_label_rtx ();\n+      output_asm_insn (\"\\n\\tbl %0,%%r31\\n\\tldo %1-%3(%%r31),%%r31\", xoperands);\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n+\t\t\t\t CODE_LABEL_NUMBER (xoperands[3]));\n+    }\n+\n+  /* Delete the jump.  */\n+  PUT_CODE (NEXT_INSN (insn), NOTE);\n+  NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n+  NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n+  return \"\";\n+}\n+\n+/* INSN is either a function call.  It may have an unconditional jump\n+   in its delay slot.\n+\n+   CALL_DEST is the routine we are calling.  */\n+\n+char *\n+output_call (insn, call_dest)\n+  rtx insn;\n+  rtx call_dest;\n+{\n+  int distance;\n+  rtx xoperands[4];\n+  rtx seq_insn;\n+\n   /* Handle common case -- empty delay slot or no jump in the delay slot,\n      and we're sure that the branch will reach the beginning of the $CODE$\n      subspace.  */\n@@ -3973,8 +4256,7 @@ output_call (insn, call_dest, return_pointer)\n \t  && get_attr_length (insn) == 4))\n     {\n       xoperands[0] = call_dest;\n-      xoperands[1] = return_pointer;\n-      output_asm_insn (\"bl %0,%r1%#\", xoperands);\n+      output_asm_insn (\"bl %0,%%r2%#\", xoperands);\n       return \"\";\n     }\n \n@@ -3990,13 +4272,14 @@ output_call (insn, call_dest, return_pointer)\n \t function call well after the parameters have been set up, we\n \t need to make sure any FP args appear in both the integer\n \t and FP registers.  Also, we need move any delay slot insn\n-\t out of the delay slot -- Yuk!  */\n+\t out of the delay slot.  And finally, we can't rely on the linker\n+\t being able to fix the call to $$dyncall!  -- Yuk!.  */\n       if (dbr_sequence_length () != 0\n \t  && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN)\n \t{\n \t  /* A non-jump insn in the delay slot.  By definition we can\n-\t  emit this insn before the call (and in fact before argument\n-\t  relocating.  */\n+\t     emit this insn before the call (and in fact before argument\n+\t     relocating.  */\n \t  final_scan_insn (NEXT_INSN (insn), asm_out_file, optimize, 0, 0);\n \n \t  /* Now delete the delay insn.  */\n@@ -4042,6 +4325,8 @@ output_call (insn, call_dest, return_pointer)\n \t    }\n \t}\n \n+      /* Don't have to worry about TARGET_PORTABLE_RUNTIME here since\n+\t we don't have any direct calls in that case.  */\n       if (flag_pic)\n \t{\n \t  /* We have to load the address of the function using a procedure\n@@ -4050,8 +4335,9 @@ output_call (insn, call_dest, return_pointer)\n \t     have to defer outputting it of course...  Not pretty.  */\n \n \t  xoperands[0] = gen_label_rtx ();\n-\t  output_asm_insn (\"addil LT%%%0,%%r19\\n\\tldw RT%%%0(%%r1),%%r22\",\n-\t\t\t   xoperands);\n+\t  xoperands[1] = gen_label_rtx ();\n+\t  output_asm_insn (\"addil LT%%%0,%%r19\", xoperands);\n+\t  output_asm_insn (\"ldw RT%%%0(%%r1),%%r22\", xoperands);\n \t  output_asm_insn (\"ldw 0(0,%%r22),%%r22\", xoperands);\n \n \t  if (deferred_plabels == 0)\n@@ -4064,25 +4350,42 @@ output_call (insn, call_dest, return_pointer)\n \t  deferred_plabels[n_deferred_plabels].internal_label = xoperands[0];\n \t  deferred_plabels[n_deferred_plabels].symbol = call_dest;\n \t  n_deferred_plabels++;\n+\n+\t  /* Get our address + 8 into %r1.  */\n+\t  output_asm_insn (\"bl .+8,%%r1\", xoperands);\n+\n+\t  /* Add %r1 to the offset of dyncall from the next insn.  */\n+\t  output_asm_insn (\"addil L%%$$dyncall-%1,%%r1\", xoperands);\n+\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n+\t\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n+\t  output_asm_insn (\"ldo R%%$$dyncall-%1(%%r1),%%r1\", xoperands);\n+\n+\t  /* Get the return address into %r31.  */\n+\t  output_asm_insn (\"blr 0,%%r31\", xoperands);\n+\n+\t  /* Branch to our target which is in %r1.  */\n+\t  output_asm_insn (\"bv 0(%%r1)\", xoperands);\n+\n+\t  /* Copy the return address into %r2 also.  */\n+\t  output_asm_insn (\"copy %%r31,%%r2\", xoperands);\n \t}\n       else\n \t{\n-\t  /* Now emit the inline long-call.  */\n+\t  /* No PIC stuff to worry about.  We can use ldil;ble.  */\n \t  xoperands[0] = call_dest;\n-\t  output_asm_insn (\"ldil LP%%%0,%%r22\\n\\tldo RP%%%0(%%r22),%%r22\",\n-\t\t\t   xoperands);\n-\t}\n \n-      /* If TARGET_MILLICODE_LONG_CALLS, then we must use a long-call sequence\n-\t to call dyncall!  */\n-      if (TARGET_MILLICODE_LONG_CALLS)\n-\t{\n-\t  output_asm_insn (\"ldil L%%$$dyncall,%%r31\", xoperands);\n-\t  output_asm_insn (\"ldo R%%$$dyncall(%%r31),%%r31\", xoperands);\n-\t  output_asm_insn (\"blr 0,%%r2\\n\\tbv,n 0(%%r31)\\n\\tnop\", xoperands);\n+\t  /*  Get the address of our target into %r22.  */\n+\t  output_asm_insn (\"ldil LP%%%0,%%r22\", xoperands);\n+\t  output_asm_insn (\"ldo RP%%%0(%%r22),%%r22\", xoperands);\n+\n+\t  /* Get the high part of the  address of $dyncall into %r2, then\n+\t     add in the low part in the branch instruction.  */\n+\t  output_asm_insn (\"ldil L%%$$dyncall,%%r2\", xoperands);\n+\t  output_asm_insn (\"ble  R%%$$dyncall(%%sr4,%%r2)\", xoperands);\n+\n+\t  /* Copy the return pointer into both %r31 and %r2.  */\n+\t  output_asm_insn (\"copy %%r31,%%r2\", xoperands);\n \t}\n-      else\n-\toutput_asm_insn (\"bl $$dyncall,%%r31\\n\\tcopy %%r31,%%r2\", xoperands);\n \n       /* If we had a jump in the call's delay slot, output it now.  */\n       if (dbr_sequence_length () != 0\n@@ -4099,7 +4402,9 @@ output_call (insn, call_dest, return_pointer)\n       return \"\";\n     }\n \n-  /* This call has an unconditional jump in its delay slot.  */\n+  /* This call has an unconditional jump in its delay slot and the\n+     call is known to reach its target or the beginning of the current\n+     subspace.  */\n \n   /* Use the containing sequence insn's address.  */\n   seq_insn = NEXT_INSN (PREV_INSN (XVECEXP (final_sequence, 0, 0)));\n@@ -4115,13 +4420,12 @@ output_call (insn, call_dest, return_pointer)\n \n   xoperands[0] = call_dest;\n   xoperands[1] = XEXP (PATTERN (NEXT_INSN (insn)), 1);\n-  xoperands[2] = return_pointer;\n   if (! VAL_14_BITS_P (distance))\n-    output_asm_insn (\"bl %0,%r2\\n\\tnop\\n\\tbl,n %1,%%r0\", xoperands);\n+    output_asm_insn (\"bl %0,%%r2\\n\\tnop\\n\\tbl,n %1,%%r0\", xoperands);\n   else\n     {\n       xoperands[3] = gen_label_rtx ();\n-      output_asm_insn (\"\\n\\tbl %0,%r2\\n\\tldo %1-%3(%r2),%r2\", xoperands);\n+      output_asm_insn (\"\\n\\tbl %0,%%r2\\n\\tldo %1-%3(%%r2),%%r2\", xoperands);\n       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n \t\t\t\t CODE_LABEL_NUMBER (xoperands[3]));\n     }"}, {"sha": "8705fa3f3cc13569f5ebcb65b04aec196419d566", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a73009d9d95ca4af6339fdbe37dfead3972670b/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a73009d9d95ca4af6339fdbe37dfead3972670b/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=6a73009d9d95ca4af6339fdbe37dfead3972670b", "patch": "@@ -70,25 +70,14 @@ extern int target_flags;\n    never cross a space boundary.  Such assumptions are generally safe for\n    building kernels and statically linked executables.  Code compiled with\n    this option will fail miserably if the executable is dynamically linked\n-   or uses nested functions!  */\n-#define TARGET_FAST_INDIRECT_CALLS (target_flags & 4)\n+   or uses nested functions!\n+\n+   This is also used to trigger agressive unscaled index addressing.  */\n+#define TARGET_NO_SPACE_REGS (target_flags & 4)\n \n /* Allow unconditional jumps in the delay slots of call instructions.  */\n #define TARGET_JUMP_IN_DELAY (target_flags & 8)\n \n-/* In rare cases, a millicode call via \"bl\" can not be turned into\n-   a millicode call using \"ble\" (when SHLIB_INFO subspace is very large).\n-\n-   This option forces just millicode calls to use inline long-calls\n-   This is far more efficient than the old long-call option which forced\n-   every function to be called indirectly (as is still the case for\n-   TARGET_PORTABLE_RUNTIME).\n-\n-   ??? What about simple jumps, they can suffer from the same problem.\n-   Would require significant surgery in pa.md.  */\n-\n-#define TARGET_MILLICODE_LONG_CALLS (target_flags & 16)\n-\n /* Disable indexed addressing modes.  */\n \n #define TARGET_DISABLE_INDEXING (target_flags & 32)\n@@ -125,16 +114,14 @@ extern int target_flags;\n    {\"pa-risc-1-1\", 1},\t\t\\\n    {\"disable-fpregs\", 2},\t\\\n    {\"no-disable-fpregs\", -2},\t\\\n-   {\"fast-indirect-calls\", 4},\t\\\n-   {\"no-fast-indirect-calls\", -4},\\\n+   {\"no-space-regs\", 4},\t\\\n+   {\"space-regs\", -4},\\\n    {\"jump-in-delay\", 8},\t\\\n    {\"no-jump-in-delay\", -8},\t\\\n-   {\"millicode-long-calls\", 16},\\\n-   {\"no-millicode-long-calls\", -16},\\\n    {\"disable-indexing\", 32},\t\\\n    {\"no-disable-indexing\", -32},\\\n-   {\"portable-runtime\", 64+16},\\\n-   {\"no-portable-runtime\", -(64+16)},\\\n+   {\"portable-runtime\", 64},\t\\\n+   {\"no-portable-runtime\", -64},\\\n    {\"gas\", 128},\t\t\\\n    {\"no-gas\", -128},\t\t\\\n    {\"soft-float\", 256},\t\t\\"}, {"sha": "c643089c220cf49b8aa343662e82e8a5878c541f", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 391, "deletions": 108, "changes": 499, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a73009d9d95ca4af6339fdbe37dfead3972670b/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a73009d9d95ca4af6339fdbe37dfead3972670b/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=6a73009d9d95ca4af6339fdbe37dfead3972670b", "patch": "@@ -1154,7 +1154,7 @@\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n     (if_then_else (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8188))\n+\t\t      (const_int 8184))\n            (const_int 4)\n \t   (const_int 8)))])\n \n@@ -1177,7 +1177,7 @@\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n     (if_then_else (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8188))\n+\t\t      (const_int 8184))\n            (const_int 4)\n \t   (const_int 8)))])\n \n@@ -1200,7 +1200,7 @@\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n     (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8188))\n+\t\t      (const_int 8184))\n            (const_int 4)\n \t   (const_int 8)))])\n \n@@ -1222,7 +1222,7 @@\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n     (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8188))\n+\t\t      (const_int 8184))\n            (const_int 4)\n \t   (const_int 8)))])\n \n@@ -1244,7 +1244,7 @@\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n     (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8188))\n+\t\t      (const_int 8184))\n            (const_int 4)\n \t   (const_int 8)))])\n \n@@ -1266,7 +1266,96 @@\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n     (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8188))\n+\t\t      (const_int 8184))\n+           (const_int 4)\n+\t   (const_int 8)))])\n+\n+;; Branch on Variable Bit patterns.\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"register_operand\" \"q\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"*\n+{\n+  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),\n+\t\t     get_attr_length (insn), 0, insn, 0);\n+}\"\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+           (const_int 4)\n+\t   (const_int 8)))])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"register_operand\" \"q\"))\n+\t     (const_int 0))\n+\t (pc)\n+\t (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),\n+\t\t     get_attr_length (insn), 1, insn, 0);\n+}\"\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+           (const_int 4)\n+\t   (const_int 8)))])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"register_operand\" \"q\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"*\n+{\n+  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),\n+\t\t     get_attr_length (insn), 0, insn, 1);\n+}\"\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+           (const_int 4)\n+\t   (const_int 8)))])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 1 \"register_operand\" \"q\"))\n+\t     (const_int 0))\n+\t (pc)\n+\t (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  return output_bvb (operands, INSN_ANNULLED_BRANCH_P (insn),\n+\t\t     get_attr_length (insn), 1, insn, 1);\n+}\"\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n            (const_int 4)\n \t   (const_int 8)))])\n \n@@ -2943,12 +3032,29 @@\n   \"* return output_mul_insn (0, insn);\"\n   [(set_attr \"type\" \"milli\")\n    (set (attr \"length\")\n-     (if_then_else (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-\t\t\t    (const_int 0))\n-\t\t\t(eq (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\")\n-\t\t\t    (const_int 0)))\n-\t\t   (const_int 4)\n-\t\t   (const_int 24)))])\n+     (cond [\n+;; Target (or stub) within reach\n+            (and (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n+                     (const_int 240000))\n+                 (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+                     (const_int 0)))\n+            (const_int 4)\n+\n+;; NO_SPACE_REGS\n+            (ne (symbol_ref \"TARGET_NO_SPACE_REGS\")\n+                (const_int 0))\n+            (const_int 8)\n+\n+;; Out of reach, but not PIC or PORTABLE_RUNTIME\n+;; same as NO_SPACE_REGS code\n+            (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+                     (const_int 0))\n+                 (eq (symbol_ref \"flag_pic\")\n+                     (const_int 0)))\n+            (const_int 8)]\n+\n+;; Out of range and either PIC or PORTABLE_RUNTIME\n+\t  (const_int 24)))])\n \n ;;; Division and mod.\n (define_expand \"divsi3\"\n@@ -2980,12 +3086,29 @@\n    return output_div_insn (operands, 0, insn);\"\n   [(set_attr \"type\" \"milli\")\n    (set (attr \"length\")\n-     (if_then_else (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-\t\t\t    (const_int 0))\n-\t\t\t(eq (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\")\n-\t\t\t    (const_int 0)))\n-\t\t   (const_int 4)\n-\t\t   (const_int 24)))])\n+     (cond [\n+;; Target (or stub) within reach\n+            (and (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n+                     (const_int 240000))\n+                 (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+                     (const_int 0)))\n+            (const_int 4)\n+\n+;; NO_SPACE_REGS\n+            (ne (symbol_ref \"TARGET_NO_SPACE_REGS\")\n+                (const_int 0))\n+            (const_int 8)\n+\n+;; Out of reach, but not PIC or PORTABLE_RUNTIME\n+;; same as NO_SPACE_REGS code\n+            (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+                     (const_int 0))\n+                 (eq (symbol_ref \"flag_pic\")\n+                     (const_int 0)))\n+            (const_int 8)]\n+\n+;; Out of range and either PIC or PORTABLE_RUNTIME\n+\t  (const_int 24)))])\n \n (define_expand \"udivsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n@@ -3016,12 +3139,29 @@\n    return output_div_insn (operands, 1, insn);\"\n   [(set_attr \"type\" \"milli\")\n    (set (attr \"length\")\n-     (if_then_else (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-\t\t\t    (const_int 0))\n-\t\t\t(eq (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\")\n-\t\t\t    (const_int 0)))\n-\t\t   (const_int 4)\n-\t\t   (const_int 24)))])\n+     (cond [\n+;; Target (or stub) within reach\n+            (and (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n+                     (const_int 240000))\n+                 (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+                     (const_int 0)))\n+            (const_int 4)\n+\n+;; NO_SPACE_REGS\n+            (ne (symbol_ref \"TARGET_NO_SPACE_REGS\")\n+                (const_int 0))\n+            (const_int 8)\n+\n+;; Out of reach, but not PIC or PORTABLE_RUNTIME\n+;; same as NO_SPACE_REGS code\n+            (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+                     (const_int 0))\n+                 (eq (symbol_ref \"flag_pic\")\n+                     (const_int 0)))\n+            (const_int 8)]\n+\n+;; Out of range and either PIC or PORTABLE_RUNTIME\n+\t  (const_int 24)))])\n \n (define_expand \"modsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n@@ -3049,12 +3189,29 @@\n   return output_mod_insn (0, insn);\"\n   [(set_attr \"type\" \"milli\")\n    (set (attr \"length\")\n-     (if_then_else (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-\t\t\t    (const_int 0))\n-\t\t\t(eq (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\")\n-\t\t\t    (const_int 0)))\n-\t\t   (const_int 4)\n-\t\t   (const_int 24)))])\n+     (cond [\n+;; Target (or stub) within reach\n+            (and (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n+                     (const_int 240000))\n+                 (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+                     (const_int 0)))\n+            (const_int 4)\n+\n+;; NO_SPACE_REGS\n+            (ne (symbol_ref \"TARGET_NO_SPACE_REGS\")\n+                (const_int 0))\n+            (const_int 8)\n+\n+;; Out of reach, but not PIC or PORTABLE_RUNTIME\n+;; same as NO_SPACE_REGS code\n+            (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+                     (const_int 0))\n+                 (eq (symbol_ref \"flag_pic\")\n+                     (const_int 0)))\n+            (const_int 8)]\n+\n+;; Out of range and either PIC or PORTABLE_RUNTIME\n+\t  (const_int 24)))])\n \n (define_expand \"umodsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n@@ -3082,12 +3239,29 @@\n   return output_mod_insn (1, insn);\"\n   [(set_attr \"type\" \"milli\")\n    (set (attr \"length\")\n-     (if_then_else (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-\t\t\t    (const_int 0))\n-\t\t\t(eq (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\")\n-\t\t\t    (const_int 0)))\n-\t\t   (const_int 4)\n-\t\t   (const_int 24)))])\n+     (cond [\n+;; Target (or stub) within reach\n+            (and (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n+                     (const_int 240000))\n+                 (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+                     (const_int 0)))\n+            (const_int 4)\n+\n+;; NO_SPACE_REGS\n+            (ne (symbol_ref \"TARGET_NO_SPACE_REGS\")\n+                (const_int 0))\n+            (const_int 8)\n+\n+;; Out of reach, but not PIC or PORTABLE_RUNTIME\n+;; same as NO_SPACE_REGS code\n+            (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+                     (const_int 0))\n+                 (eq (symbol_ref \"flag_pic\")\n+                     (const_int 0)))\n+            (const_int 8)]\n+\n+;; Out of range and either PIC or PORTABLE_RUNTIME\n+\t  (const_int 24)))])\n \n ;;- and instructions\n ;; We define DImode `and` so with DImode `not` we can get\n@@ -3738,7 +3912,7 @@\n ;; on whether or not we can add the proper offset to %r2 with an ldo\n ;; instruction.\n \t   (lt (abs (minus (match_dup 0) (plus (pc) (const_int 8))))\n-\t\t    (const_int 8188))\n+\t\t    (const_int 8184))\n            (const_int 4)]\n \t  (const_int 8)))])\n \n@@ -3832,8 +4006,11 @@\n   if (GET_CODE (op) == SYMBOL_REF)\n     call_insn = emit_call_insn (gen_call_internal_symref (op, operands[1]));\n   else\n-    call_insn = emit_call_insn (gen_call_internal_reg (force_reg (SImode, op),\n-\t\t\t\t\t\t       operands[1]));\n+    {\n+      rtx tmpreg = gen_rtx (REG, SImode, 22);\n+      emit_move_insn (tmpreg, force_reg (SImode, op));\n+      call_insn = emit_call_insn (gen_call_internal_reg (operands[1]));\n+    }\n \n   if (flag_pic)\n     {\n@@ -3847,6 +4024,16 @@\n       emit_move_insn (pic_offset_table_rtx,\n \t\t      gen_rtx (REG, SImode, PIC_OFFSET_TABLE_REGNUM_SAVED));\n       emit_insn (gen_rtx (USE, VOIDmode, pic_offset_table_rtx));\n+\n+      /* Gross.  We have to keep the scheduler from moving the restore\n+\t of the PIC register away from the call.  SCHED_GROUP_P is\n+\t supposed to do this, but for some reason the compiler will\n+\t go into an infinite loop when we use that.\n+\n+\t This method (blockage insn) may make worse code (then again\n+\t it may not since calls are nearly blockages anyway), but at\n+\t least it should work.  */\n+      emit_insn (gen_blockage ());\n     }\n   DONE;\n }\")\n@@ -3864,39 +4051,91 @@\n }\"\n   [(set_attr \"type\" \"call\")\n    (set (attr \"length\")\n+;;       If we're sure that we can either reach the target or that the\n+;;\t linker can use a long-branch stub, then the length is 4 bytes.\n+;;\n+;;\t For long-calls the length will be either 52 bytes (non-pic)\n+;;\t or 68 bytes (pic).  */\n+;;\t Else we have to use a long-call;\n       (if_then_else (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n \t\t\t(const_int 240000))\n \t\t    (const_int 4)\n-\t\t    (if_then_else (ne (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\")\n+\t\t    (if_then_else (eq (symbol_ref \"flag_pic\")\n \t\t\t\t      (const_int 0))\n-\t\t\t\t  (const_int 64)\n-\t\t\t\t  (const_int 52))))])\n+\t\t\t\t  (const_int 52)\n+\t\t\t\t  (const_int 68))))])\n \n (define_insn \"call_internal_reg\"\n-  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"r\"))\n-\t (match_operand 1 \"\" \"i\"))\n+  [(call (mem:SI (reg:SI 22))\n+\t (match_operand 0 \"\" \"i\"))\n    (clobber (reg:SI 2))\n    (use (const_int 1))]\n   \"\"\n   \"*\n {\n-  if (TARGET_FAST_INDIRECT_CALLS)\n-    return \\\"ble 0(%%sr4,%r0)\\;copy %%r31,%%r2\\\";\n+  rtx xoperands[2];\n \n-  /* Yuk!  bl may not be able to reach $$dyncall.  */\n-  if (TARGET_PORTABLE_RUNTIME || TARGET_MILLICODE_LONG_CALLS)\n-    return \\\"copy %r0,%%r22\\;ldil L%%$$dyncall,%%r31\\;ldo R%%$$dyncall(%%r31),%%r31\\;blr 0,%%r2\\;bv,n 0(%%r31)\\;nop\\\";\n-  else\n-    return \\\"copy %r0,%%r22\\;.CALL\\\\tARGW0=GR\\;bl $$dyncall,%%r31\\;copy %%r31,%%r2\\\";\n+  /* First the special case for kernels, level 0 systems, etc.  */\n+  if (TARGET_NO_SPACE_REGS)\n+    return \\\"ble 0(%%sr4,%%r22)\\;copy %%r31,%%r2\\\";\n+\n+  /* Now the normal case -- we can reach $$dyncall directly or\n+     we're sure that we can get there via a long-branch stub. \n+\n+     No need to check target flags as the length uniquely identifies\n+     the remaining cases.  */\n+  if (get_attr_length (insn) == 8)\n+    return \\\".CALL\\\\tARGW0=GR\\;bl $$dyncall,%%r31\\;copy %%r31,%%r2\\\";\n+\n+  /* Long millicode call, but we are not generating PIC or portable runtime\n+     code.  */\n+  if (get_attr_length (insn) == 12)\n+    return \\\"CALL\\\\tARGW0=GR\\;ldil L%%$$dyncall,%%r2\\;ble R%%$$dyncall(%%sr4,%%r2)\\;copy %%r31,%%r2\\\";\n+\n+  /* Long millicode call for portable runtime.  */\n+  if (get_attr_length (insn) == 20)\n+    return \\\"ldil L%%$$dyncall,%%r31\\;ldo R%%$$dyncall(%%r31),%%r31\\;blr 0,%%r2\\;bv,n 0(%%r31)\\;nop\\\";\n+\n+  /* If we're generating PIC code.  */\n+  xoperands[0] = operands[0];\n+  xoperands[1] = gen_label_rtx ();\n+  output_asm_insn (\\\"bl .+8,%%r1\\\", xoperands);\n+  output_asm_insn (\\\"addil L%%$$dyncall-%1,%%r1\\\", xoperands);\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n+\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n+  output_asm_insn (\\\"ldo R%%$$dyncall-%1(%%r1),%%r1\\\", xoperands);\n+  output_asm_insn (\\\"blr 0,%%r2\\\", xoperands);\n+  output_asm_insn (\\\"bv,n 0(%%r1)\\\\n\\\\tnop\\\", xoperands);\n+  return \\\"\\\";\n }\"\n   [(set_attr \"type\" \"dyncall\")\n    (set (attr \"length\")\n-     (if_then_else (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-\t\t\t    (const_int 0))\n-\t\t\t(eq (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\")\n-\t\t\t    (const_int 0)))\n-\t\t   (const_int 12)\n-\t\t   (const_int 24)))])\n+     (cond [\n+;; First NO_SPACE_REGS\n+\t    (ne (symbol_ref \"TARGET_NO_SPACE_REGS\")\n+\t\t(const_int 0))\n+\t    (const_int 8)\n+\n+;; Target (or stub) within reach\n+\t    (and (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n+\t\t     (const_int 240000))\n+\t\t (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+\t\t     (const_int 0)))\n+\t    (const_int 8)\n+\n+;; Out of reach, but not PIC or PORTABLE_RUNTIME\n+\t    (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+\t\t     (const_int 0))\n+\t\t (eq (symbol_ref \"flag_pic\")\n+\t\t     (const_int 0)))\n+\t    (const_int 12)\n+\n+\t    (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+\t\t(const_int 0))\n+\t    (const_int 20)]\n+\n+;; Out of range PIC case\n+\t  (const_int 24)))])\n \n (define_expand \"call_value\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n@@ -3924,10 +4163,12 @@\n \t\t\t\t\t\t\t\top,\n \t\t\t\t\t\t\t\toperands[2]));\n   else\n-    call_insn = emit_call_insn (gen_call_value_internal_reg (operands[0],\n-\t\t\t\t\t\t\t     force_reg (SImode, op),\n-\t\t\t\t\t\t\t     operands[2]));\n-\n+    {\n+      rtx tmpreg = gen_rtx (REG, SImode, 22);\n+      emit_move_insn (tmpreg, force_reg (SImode, op));\n+      call_insn = emit_call_insn (gen_call_value_internal_reg (operands[0],\n+\t\t\t\t\t\t\t       operands[2]));\n+    }\n   if (flag_pic)\n     {\n       use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), pic_offset_table_rtx);\n@@ -3950,16 +4191,6 @@\n \t it may not since calls are nearly blockages anyway), but at\n \t least it should work.  */\n       emit_insn (gen_blockage ());\n-\n-      /* Gross.  We have to keep the scheduler from moving the restore\n-\t of the PIC register away from the call.  SCHED_GROUP_P is\n-\t supposed to do this, but for some reason the compiler will\n-\t go into an infinite loop when we use that.\n-\n-\t This method (blockage insn) may make worse code (then again\n-\t it may not since calls are nearly blockages anyway), but at\n-\t least it should work.  */\n-      emit_insn (gen_blockage ());\n     }\n   DONE;\n }\")\n@@ -3979,40 +4210,92 @@\n }\"\n   [(set_attr \"type\" \"call\")\n    (set (attr \"length\")\n+;;       If we're sure that we can either reach the target or that the\n+;;\t linker can use a long-branch stub, then the length is 4 bytes.\n+;;\n+;;\t For long-calls the length will be either 52 bytes (non-pic)\n+;;\t or 68 bytes (pic).  */\n+;;\t Else we have to use a long-call;\n       (if_then_else (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n \t\t\t(const_int 240000))\n \t\t    (const_int 4)\n-\t\t    (if_then_else (ne (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\")\n+\t\t    (if_then_else (eq (symbol_ref \"flag_pic\")\n \t\t\t\t      (const_int 0))\n-\t\t\t\t  (const_int 64)\n-\t\t\t\t  (const_int 52))))])\n+\t\t\t\t  (const_int 52)\n+\t\t\t\t  (const_int 68))))])\n \n (define_insn \"call_value_internal_reg\"\n   [(set (match_operand 0 \"\" \"=rf\")\n-\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t      (match_operand 2 \"\" \"i\")))\n+\t(call (mem:SI (reg:SI 22))\n+\t      (match_operand 1 \"\" \"i\")))\n    (clobber (reg:SI 2))\n    (use (const_int 1))]\n   \"\"\n   \"*\n {\n-  if (TARGET_FAST_INDIRECT_CALLS)\n-    return \\\"ble 0(%%sr4,%r1)\\;copy %%r31,%%r2\\\";\n-\n-  /* Yuk!  bl may not be able to reach $$dyncall.  */\n-  if (TARGET_PORTABLE_RUNTIME || TARGET_MILLICODE_LONG_CALLS)\n-    return \\\"copy %r1,%%r22\\;ldil L%%$$dyncall,%%r31\\;ldo R%%$$dyncall(%%r31),%%r31\\;blr 0,%%r2\\;bv,n 0(%%r31)\\;nop\\\";\n-  else\n-    return \\\"copy %r1,%%r22\\;.CALL\\\\tARGW0=GR\\;bl $$dyncall,%%r31\\;copy %%r31,%%r2\\\";\n+  rtx xoperands[2];\n+\n+  /* First the special case for kernels, level 0 systems, etc.  */\n+  if (TARGET_NO_SPACE_REGS)\n+    return \\\"ble 0(%%sr4,%%r22)\\;copy %%r31,%%r2\\\";\n+\n+  /* Now the normal case -- we can reach $$dyncall directly or\n+     we're sure that we can get there via a long-branch stub. \n+\n+     No need to check target flags as the length uniquely identifies\n+     the remaining cases.  */\n+  if (get_attr_length (insn) == 8)\n+    return \\\".CALL\\\\tARGW0=GR\\;bl $$dyncall,%%r31\\;copy %%r31,%%r2\\\";\n+\n+  /* Long millicode call, but we are not generating PIC or portable runtime\n+     code.  */\n+  if (get_attr_length (insn) == 12)\n+    return \\\".CALL\\\\tARGW0=GR\\;ldil L%%$$dyncall,%%r2\\;ble R%%$$dyncall(%%sr4,%%r2)\\;copy %%r31,%%r2\\\";\n+\n+  /* Long millicode call for portable runtime.  */\n+  if (get_attr_length (insn) == 20)\n+    return \\\"ldil L%%$$dyncall,%%r31\\;ldo R%%$$dyncall(%%r31),%%r31\\;blr 0,%%r2\\;bv,n 0(%%r31)\\;nop\\\";\n+\n+  /* If we're generating PIC code.  */\n+  xoperands[0] = operands[1];\n+  xoperands[1] = gen_label_rtx ();\n+  output_asm_insn (\\\"bl .+8,%%r1\\\", xoperands);\n+  output_asm_insn (\\\"addil L%%$$dyncall-%1,%%r1\\\", xoperands);\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n+\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n+  output_asm_insn (\\\"ldo R%%$$dyncall-%1(%%r1),%%r1\\\", xoperands);\n+  output_asm_insn (\\\"blr 0,%%r2\\\", xoperands);\n+  output_asm_insn (\\\"bv,n 0(%%r1)\\\\n\\\\tnop\\\", xoperands);\n+  return \\\"\\\";\n }\"\n   [(set_attr \"type\" \"dyncall\")\n    (set (attr \"length\")\n-     (if_then_else (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-\t\t\t    (const_int 0))\n-\t\t\t(eq (symbol_ref \"TARGET_MILLICODE_LONG_CALLS\")\n-\t\t\t    (const_int 0)))\n-\t\t   (const_int 12)\n-\t\t   (const_int 24)))])\n+     (cond [\n+;; First NO_SPACE_REGS\n+\t    (ne (symbol_ref \"TARGET_NO_SPACE_REGS\")\n+\t\t(const_int 0))\n+\t    (const_int 8)\n+\n+;; Target (or stub) within reach\n+\t    (and (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n+\t\t     (const_int 240000))\n+\t\t (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+\t\t     (const_int 0)))\n+\t    (const_int 8)\n+\n+;; Out of reach, but not PIC or PORTABLE_RUNTIME\n+\t    (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+\t\t     (const_int 0))\n+\t\t (eq (symbol_ref \"flag_pic\")\n+\t\t     (const_int 0)))\n+\t    (const_int 12)\n+\n+\t    (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+\t\t(const_int 0))\n+\t    (const_int 20)]\n+\n+;; Out of range PIC case\n+\t  (const_int 24)))])\n \n ;; Call subroutine returning any type.\n \n@@ -4153,7 +4436,7 @@\n ;; Short branch has length of 4\n ;; Long branch has length of 8\n \t(if_then_else (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8188))\n+\t\t      (const_int 8184))\n            (const_int 4)\n \t   (const_int 8))\n \n@@ -4163,25 +4446,25 @@\n \t  (if_then_else (lt (match_dup 3) (pc))\n \t    (if_then_else\n \t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 24))))\n-\t\t  (const_int 8188))\n+\t\t  (const_int 8184))\n \t      (const_int 24)\n \t      (const_int 28))\n \t    (if_then_else\n \t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t  (const_int 8188))\n+\t\t  (const_int 8184))\n \t      (const_int 24)\n \t      (const_int 28)))\n ;; Loop counter in memory case.\n ;; Extra goo to deal with additional reload insns.\n \t(if_then_else (lt (match_dup 3) (pc))\n \t  (if_then_else\n \t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))\n-\t\t(const_int 8188))\n+\t\t(const_int 8184))\n \t    (const_int 12)\n \t    (const_int 16))\n \t  (if_then_else\n \t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t(const_int 8188))\n+\t\t(const_int 8184))\n \t    (const_int 12)\n \t    (const_int 16))))))])\n \n@@ -4209,7 +4492,7 @@\n ;; Short branch has length of 4\n ;; Long branch has length of 8\n \t(if_then_else (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8188))\n+\t\t      (const_int 8184))\n            (const_int 4)\n \t   (const_int 8))\n \n@@ -4219,25 +4502,25 @@\n \t  (if_then_else (lt (match_dup 3) (pc))\n \t    (if_then_else\n \t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 24))))\n-\t\t  (const_int 8188))\n+\t\t  (const_int 8184))\n \t      (const_int 24)\n \t      (const_int 28))\n \t    (if_then_else\n \t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t  (const_int 8188))\n+\t\t  (const_int 8184))\n \t      (const_int 24)\n \t      (const_int 28)))\n ;; Loop counter in memory case.\n ;; Extra goo to deal with additional reload insns.\n \t(if_then_else (lt (match_dup 3) (pc))\n \t  (if_then_else\n \t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))\n-\t\t(const_int 8188))\n+\t\t(const_int 8184))\n \t    (const_int 12)\n \t    (const_int 16))\n \t  (if_then_else\n \t    (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t(const_int 8188))\n+\t\t(const_int 8184))\n \t    (const_int 12)\n \t    (const_int 16))))))])\n \n@@ -4260,7 +4543,7 @@\n ;; Short branch has length of 4\n ;; Long branch has length of 8\n \t(if_then_else (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8188))\n+\t\t      (const_int 8184))\n            (const_int 4)\n \t   (const_int 8))\n \n@@ -4270,19 +4553,19 @@\n \t  (if_then_else (lt (match_dup 3) (pc))\n \t    (if_then_else\n \t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))\n-\t\t  (const_int 8188))\n+\t\t  (const_int 8184))\n \t      (const_int 12)\n \t      (const_int 16))\n \t    (if_then_else\n \t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t  (const_int 8188))\n+\t\t  (const_int 8184))\n \t      (const_int 12)\n \t      (const_int 16)))\n ;; Loop counter in memory case.\n ;; Extra goo to deal with additional reload insns.\n \t(if_then_else\n \t  (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t      (const_int 8188))\n+\t      (const_int 8184))\n \t  (const_int 8)\n \t  (const_int 12)))))])\n \n@@ -4306,7 +4589,7 @@\n ;; Short branch has length of 4\n ;; Long branch has length of 8\n \t(if_then_else (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t      (const_int 8188))\n+\t\t      (const_int 8184))\n            (const_int 4)\n \t   (const_int 8))\n \n@@ -4316,19 +4599,19 @@\n \t  (if_then_else (lt (match_dup 3) (pc))\n \t    (if_then_else\n \t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 12))))\n-\t\t  (const_int 8188))\n+\t\t  (const_int 8184))\n \t      (const_int 12)\n \t      (const_int 16))\n \t    (if_then_else\n \t      (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t\t  (const_int 8188))\n+\t\t  (const_int 8184))\n \t      (const_int 12)\n \t      (const_int 16)))\n ;; Loop counter in memory case.\n ;; Extra goo to deal with additional reload insns.\n \t(if_then_else\n \t  (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n-\t      (const_int 8188))\n+\t      (const_int 8184))\n \t  (const_int 8)\n \t  (const_int 12)))))])\n "}]}