{"sha": "152d47df7f625885ae972386c759330cea6b169e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUyZDQ3ZGY3ZjYyNTg4NWFlOTcyMzg2Yzc1OTMzMGNlYTZiMTY5ZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-03-21T22:01:02Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-03-21T22:01:02Z"}, "message": "re PR c++/89767 (ICE with tuple and optimization)\n\n\tPR c++/89767\n\t* parser.c (cp_parser_lambda_introducer): Add ids and first_capture_id\n\tvariables, check for duplicates in this function.\n\t* lambda.c (add_capture): Don't check for duplicates nor use\n\tIDENTIFIER_MARKED.\n\t(register_capture_members): Don't clear IDENTIFIER_MARKED here.\n\n\t* g++.dg/cpp1y/lambda-init18.C: New test.\n\t* g++.dg/cpp1y/lambda-init19.C: New test.\n\t* g++.dg/cpp1y/pr89767.C: New test.\n\nFrom-SVN: r269860", "tree": {"sha": "df1fa2daab768303053a87f6d65572c918d887e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df1fa2daab768303053a87f6d65572c918d887e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/152d47df7f625885ae972386c759330cea6b169e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/152d47df7f625885ae972386c759330cea6b169e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/152d47df7f625885ae972386c759330cea6b169e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/152d47df7f625885ae972386c759330cea6b169e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36a3a7a3726c8b65eeceb6eb4a8946e0cd5650a9"}], "stats": {"total": 145, "additions": 115, "deletions": 30}, "files": [{"sha": "741ad4853529bb08a29300c4d69971af90fea04e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d47df7f625885ae972386c759330cea6b169e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d47df7f625885ae972386c759330cea6b169e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=152d47df7f625885ae972386c759330cea6b169e", "patch": "@@ -1,3 +1,12 @@\n+2019-03-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/89767\n+\t* parser.c (cp_parser_lambda_introducer): Add ids and first_capture_id\n+\tvariables, check for duplicates in this function.\n+\t* lambda.c (add_capture): Don't check for duplicates nor use\n+\tIDENTIFIER_MARKED.\n+\t(register_capture_members): Don't clear IDENTIFIER_MARKED here.\n+\n 2019-03-21  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/89571"}, {"sha": "3e176760ba5c31d3d88fb5416fccab4f240e5e81", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d47df7f625885ae972386c759330cea6b169e/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d47df7f625885ae972386c759330cea6b169e/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=152d47df7f625885ae972386c759330cea6b169e", "patch": "@@ -601,19 +601,6 @@ add_capture (tree lambda, tree id, tree orig_init, bool by_reference_p,\n \t  IDENTIFIER_LENGTH (id) + 1);\n   name = get_identifier (buf);\n \n-  /* If TREE_TYPE isn't set, we're still in the introducer, so check\n-     for duplicates.  */\n-  if (!LAMBDA_EXPR_CLOSURE (lambda))\n-    {\n-      if (IDENTIFIER_MARKED (name))\n-\t{\n-\t  pedwarn (input_location, 0,\n-\t\t   \"already captured %qD in lambda expression\", id);\n-\t  return NULL_TREE;\n-\t}\n-      IDENTIFIER_MARKED (name) = true;\n-    }\n-\n   if (variadic)\n     type = make_pack_expansion (type);\n \n@@ -674,8 +661,6 @@ register_capture_members (tree captures)\n   if (PACK_EXPANSION_P (field))\n     field = PACK_EXPANSION_PATTERN (field);\n \n-  /* We set this in add_capture to avoid duplicates.  */\n-  IDENTIFIER_MARKED (DECL_NAME (field)) = false;\n   finish_member_declaration (field);\n }\n "}, {"sha": "c669e49214f45be90c5bf48c82e14f7d403139a5", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d47df7f625885ae972386c759330cea6b169e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d47df7f625885ae972386c759330cea6b169e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=152d47df7f625885ae972386c759330cea6b169e", "patch": "@@ -10547,6 +10547,8 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n \terror (\"non-local lambda expression cannot have a capture-default\");\n     }\n \n+  hash_set<tree, true> ids;\n+  tree first_capture_id = NULL_TREE;\n   while (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_SQUARE))\n     {\n       cp_token* capture_token;\n@@ -10582,11 +10584,14 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n \t    pedwarn (loc, 0, \"explicit by-copy capture of %<this%> redundant \"\n \t\t     \"with by-copy capture default\");\n \t  cp_lexer_consume_token (parser->lexer);\n-\t  add_capture (lambda_expr,\n-\t\t       /*id=*/this_identifier,\n-\t\t       /*initializer=*/finish_this_expr (),\n-\t\t       /*by_reference_p=*/true,\n-\t\t       explicit_init_p);\n+\t  if (LAMBDA_EXPR_THIS_CAPTURE (lambda_expr))\n+\t    pedwarn (input_location, 0,\n+\t\t     \"already captured %qD in lambda expression\",\n+\t\t     this_identifier);\n+\t  else\n+\t    add_capture (lambda_expr, /*id=*/this_identifier,\n+\t\t\t /*initializer=*/finish_this_expr (),\n+\t\t\t /*by_reference_p=*/true, explicit_init_p);\n \t  continue;\n \t}\n \n@@ -10600,11 +10605,14 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n \t\t\t     \"%<-std=c++17%> or %<-std=gnu++17%>\");\n \t  cp_lexer_consume_token (parser->lexer);\n \t  cp_lexer_consume_token (parser->lexer);\n-\t  add_capture (lambda_expr,\n-\t\t       /*id=*/this_identifier,\n-\t\t       /*initializer=*/finish_this_expr (),\n-\t\t       /*by_reference_p=*/false,\n-\t\t       explicit_init_p);\n+\t  if (LAMBDA_EXPR_THIS_CAPTURE (lambda_expr))\n+\t    pedwarn (input_location, 0,\n+\t\t     \"already captured %qD in lambda expression\",\n+\t\t     this_identifier);\n+\t  else\n+\t    add_capture (lambda_expr, /*id=*/this_identifier,\n+\t\t\t /*initializer=*/finish_this_expr (),\n+\t\t\t /*by_reference_p=*/false, explicit_init_p);\n \t  continue;\n \t}\n \n@@ -10753,11 +10761,28 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n \t\t     \"default\", capture_id);\n \t}\n \n-      add_capture (lambda_expr,\n-\t\t   capture_id,\n-\t\t   capture_init_expr,\n-\t\t   /*by_reference_p=*/capture_kind == BY_REFERENCE,\n-\t\t   explicit_init_p);\n+      /* Check for duplicates.\n+\t Optimize for the zero or one explicit captures cases and only create\n+\t the hash_set after adding second capture.  */\n+      bool found = false;\n+      if (ids.elements ())\n+\tfound = ids.add (capture_id);\n+      else if (first_capture_id == NULL_TREE)\n+\tfirst_capture_id = capture_id;\n+      else if (capture_id == first_capture_id)\n+\tfound = true;\n+      else\n+\t{\n+\t  ids.add (first_capture_id);\n+\t  ids.add (capture_id);\n+\t}\n+      if (found)\n+\tpedwarn (input_location, 0,\n+\t\t \"already captured %qD in lambda expression\", capture_id);\n+      else\n+\tadd_capture (lambda_expr, capture_id, capture_init_expr,\n+\t\t     /*by_reference_p=*/capture_kind == BY_REFERENCE,\n+\t\t     explicit_init_p);\n \n       /* If there is any qualification still in effect, clear it\n \t now; we will be starting fresh with the next capture.  */"}, {"sha": "2334e9736a2342474883da8e316104051da73c13", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d47df7f625885ae972386c759330cea6b169e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d47df7f625885ae972386c759330cea6b169e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=152d47df7f625885ae972386c759330cea6b169e", "patch": "@@ -1,3 +1,10 @@\n+2019-03-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/89767\n+\t* g++.dg/cpp1y/lambda-init18.C: New test.\n+\t* g++.dg/cpp1y/lambda-init19.C: New test.\n+\t* g++.dg/cpp1y/pr89767.C: New test.\n+\n 2019-03-21  Thomas Schwinge  <thomas@codesourcery.com>\n \t    Cesar Philippidis  <cesar@codesourcery.com>\n "}, {"sha": "5a866009e787945d7ac77263b412593067e99113", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-init18.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d47df7f625885ae972386c759330cea6b169e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-init18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d47df7f625885ae972386c759330cea6b169e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-init18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-init18.C?ref=152d47df7f625885ae972386c759330cea6b169e", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/89767\n+// { dg-do compile { target c++14 } }\n+\n+void bar (int);\n+\n+void\n+foo ()\n+{\n+  int x = 0;\n+  auto z = [x, y = [x] { bar (x); }] { y (); bar (x); };\n+  z ();\n+}"}, {"sha": "830ecc03a0849d628c114800156091ea1716d785", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-init19.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d47df7f625885ae972386c759330cea6b169e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-init19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d47df7f625885ae972386c759330cea6b169e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-init19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-init19.C?ref=152d47df7f625885ae972386c759330cea6b169e", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/89767\n+// { dg-do compile { target c++14 } }\n+\n+void bar (int);\n+\n+void\n+foo ()\n+{\n+  int x = 0;\n+  int a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0;\n+  auto z = [x, y = [x] { bar (x); }, x] { y (); bar (x); };\t// { dg-error \"already captured 'x' in lambda expression\" }\n+  auto w = [x, a, b, c, d, y = [x] { bar (x); }, e, f, g, h, x] { y (); bar (x + a + b + c + d + e + f + g + h); };\t// { dg-error \"already captured 'x' in lambda expression\" }\n+  z ();\n+  w ();\n+}"}, {"sha": "108de51926eb1ae98f0c43a2012eb45d899f2f73", "filename": "gcc/testsuite/g++.dg/cpp1y/pr89767.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152d47df7f625885ae972386c759330cea6b169e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr89767.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152d47df7f625885ae972386c759330cea6b169e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr89767.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr89767.C?ref=152d47df7f625885ae972386c759330cea6b169e", "patch": "@@ -0,0 +1,32 @@\n+// PR c++/89767\n+// { dg-do compile { target c++14 } }\n+// { dg-options \"-O2 -Wall\" }\n+\n+template <typename d> struct e { using g = d; };\n+template <typename d, template <typename> class> using h = e<d>;\n+template <typename d, template <typename> class i>\n+using j = typename h<d, i>::g;\n+template <typename c> int k(c);\n+template <typename...> class au;\n+struct l { template <typename c> using m = typename c::f; };\n+struct s : l { using af = j<au<int, int> *, m>; };\n+template <unsigned long, typename> struct o;\n+template <long p, typename c> using q = typename o<p, c>::g;\n+template <typename> struct r;\n+template <typename c> struct r<c *> { typedef c aj; };\n+template <typename ak, typename> struct al { typename r<ak>::aj operator*(); void operator++(); };\n+template <typename am, typename an, typename ao>\n+bool operator!=(al<am, ao>, al<an, ao>);\n+template <unsigned long, typename...> struct ap;\n+template <unsigned long aq, typename ar, typename... as>\n+struct ap<aq, ar, as...> : ap<1, as...> {};\n+template <unsigned long aq, typename ar> struct ap<aq, ar> {};\n+template <typename... at> class au : public ap<0, at...> {};\n+template <unsigned long p, typename ar, typename... as>\n+struct o<p, au<ar, as...>> : o<p - 1, au<as...>> {};\n+template <typename ar, typename... as> struct o<0, au<ar, as...>> { typedef ar g; };\n+template <long p, typename ar> constexpr ar av(ap<p, ar> __t) { return ar (); }\n+template <int p, typename... at> constexpr q<p, au<at...>> aw(au<at...> __t) { av<p>(__t); return q<p, au<at...>> (); }\n+struct bg { typedef s::af af; };\n+struct F { typedef al<bg::af, int> bk; bk begin(); bk end(); };\n+void bo() { int t = 0; F cv; for (auto bp : cv) [t, n = k(aw<1>(bp))] {}; }"}]}