{"sha": "551e193501cebca18c19ed9ede7df7c2ee0bd9a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUxZTE5MzUwMWNlYmNhMThjMTllZDllZGU3ZGY3YzJlZTBiZDlhNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-26T08:08:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-26T08:08:03Z"}, "message": "[multiple changes]\n\n2015-05-26  Gary Dismukes  <dismukes@adacore.com>\n\n\t* einfo.ads, sem_util.adb, sem_ch4.adb: Minor reformatting.\n\n2015-05-26  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_unst.adb, exp_unst.ads: Change to using Subps table index for\n\tmaking AREC entity names unique.\n\n2015-05-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_cat.adb (Has_Stream_Attribute_Definition): If the type\n\thas aspect specifications, examine the corresponding list of\n\trepresentation items to determine whether there is a visible\n\tstream operation. The attribute definition clause generated from\n\tthe aspect will be inserted at the freeze point of the type,\n\twhich may be in the private part and not directly visible,\n\tbut the aspect makes the operation available to a client.\n\nFrom-SVN: r223663", "tree": {"sha": "529415daf1214f9cb6bb79ad644b75095121f187", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/529415daf1214f9cb6bb79ad644b75095121f187"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/551e193501cebca18c19ed9ede7df7c2ee0bd9a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/551e193501cebca18c19ed9ede7df7c2ee0bd9a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/551e193501cebca18c19ed9ede7df7c2ee0bd9a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/551e193501cebca18c19ed9ede7df7c2ee0bd9a6/comments", "author": null, "committer": null, "parents": [{"sha": "07aa5e6fa1e8bbee4a3ba080d449deb24f0d647e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07aa5e6fa1e8bbee4a3ba080d449deb24f0d647e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07aa5e6fa1e8bbee4a3ba080d449deb24f0d647e"}], "stats": {"total": 270, "additions": 156, "deletions": 114}, "files": [{"sha": "ccdf46b54eaee0e73fd96cd161ddf3e4fb4179ba", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/551e193501cebca18c19ed9ede7df7c2ee0bd9a6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/551e193501cebca18c19ed9ede7df7c2ee0bd9a6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=551e193501cebca18c19ed9ede7df7c2ee0bd9a6", "patch": "@@ -1,3 +1,22 @@\n+2015-05-26  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* einfo.ads, sem_util.adb, sem_ch4.adb: Minor reformatting.\n+\n+2015-05-26  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_unst.adb, exp_unst.ads: Change to using Subps table index for\n+\tmaking AREC entity names unique.\n+\n+2015-05-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_cat.adb (Has_Stream_Attribute_Definition): If the type\n+\thas aspect specifications, examine the corresponding list of\n+\trepresentation items to determine whether there is a visible\n+\tstream operation. The attribute definition clause generated from\n+\tthe aspect will be inserted at the freeze point of the type,\n+\twhich may be in the private part and not directly visible,\n+\tbut the aspect makes the operation available to a client.\n+\n 2015-05-26  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_util.adb: Minor code reorganization."}, {"sha": "5a309f914dbb750d50f522ee203064b960864dfa", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/551e193501cebca18c19ed9ede7df7c2ee0bd9a6/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/551e193501cebca18c19ed9ede7df7c2ee0bd9a6/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=551e193501cebca18c19ed9ede7df7c2ee0bd9a6", "patch": "@@ -1756,7 +1756,7 @@ package Einfo is\n --       Object_Size clauses for a given entity.\n \n --    Has_Out_Or_In_Out_Parameter (Flag110)\n---       Present in subprograms, generic subprograms, entries and entry\n+--       Present in subprograms, generic subprograms, entries, and entry\n --       families. Set if they have at least one OUT or IN OUT parameter\n --       (allowed for functions only in Ada 2012).\n "}, {"sha": "c2a72431d34cb5ed130f3ae0e0485b56b37b29f2", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 65, "deletions": 61, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/551e193501cebca18c19ed9ede7df7c2ee0bd9a6/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/551e193501cebca18c19ed9ede7df7c2ee0bd9a6/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=551e193501cebca18c19ed9ede7df7c2ee0bd9a6", "patch": "@@ -124,8 +124,8 @@ package body Exp_Unst is\n    -----------------------\n \n    procedure Unnest_Subprogram (Subp : Entity_Id; Subp_Body : Node_Id) is\n-      function AREC_String (Lev : Pos) return String;\n-      --  Given a level value, 1, 2, ... returns the string AREC, AREC2, ...\n+      function AREC_Name (J : Pos; S : String) return Name_Id;\n+      --  Returns name for string ARECjS, where j is the decimal value of j\n \n       function Enclosing_Subp (Subp : SI_Type) return SI_Type;\n       --  Subp is the index of a subprogram which has a Lev greater than 1.\n@@ -137,34 +137,32 @@ package body Exp_Unst is\n       --  function returns the level of nesting (Subp = 1, subprograms that\n       --  are immediately nested within Subp = 2, etc).\n \n+      function Img_Pos (N : Pos) return String;\n+      --  Return image of N without leading blank\n+\n       function Subp_Index (Sub : Entity_Id) return SI_Type;\n       --  Given the entity for a subprogram, return corresponding Subps index\n \n-      function Suffixed_Name (Ent : Entity_Id) return Name_Id;\n-      --  Given an entity Ent, return its name (Char (Ent)) suffixed with\n-      --  two underscores and the entity number, to ensure a unique name.\n-\n-      function Upref_Name (Ent : Entity_Id; Clist : List_Id) return Name_Id;\n+      function Upref_Name\n+        (Ent   : Entity_Id;\n+         Index : Pos;\n+         Clist : List_Id) return Name_Id;\n       --  This function returns the name to be used in the activation record to\n       --  reference the variable uplevel. Clist is the list of components that\n-      --  have been created in the activation record so far. Normally this is\n-      --  just a copy of the Chars field of the entity. The exception is when\n-      --  the name has already been used, in which case we suffix the name with\n-      --  the entity number to avoid duplication. This happens with declare\n-      --  blocks and generic parameters at least.\n+      --  have been created in the activation record so far. Normally the name\n+      --  is just a copy of the Chars field of the entity. The exception is\n+      --  when the name has already been used, in which case we suffix the name\n+      --  with the index value Index to avoid duplication. This happens with\n+      --  declare blocks and generic parameters at least.\n \n-      -----------------\n-      -- AREC_String --\n-      -----------------\n+      ---------------\n+      -- AREC_Name --\n+      ---------------\n \n-      function AREC_String (Lev : Pos) return String is\n+      function AREC_Name (J : Pos; S : String) return Name_Id is\n       begin\n-         if Lev > 9 then\n-            return AREC_String (Lev / 10) & Character'Val (Lev mod 10 + 48);\n-         else\n-            return \"AREC\" & Character'Val (Lev + 48);\n-         end if;\n-      end AREC_String;\n+         return Name_Find_Str (\"AREC\" & Img_Pos (J) & S);\n+      end AREC_Name;\n \n       --------------------\n       -- Enclosing_Subp --\n@@ -199,6 +197,27 @@ package body Exp_Unst is\n          end loop;\n       end Get_Level;\n \n+      -------------\n+      -- Img_Pos --\n+      -------------\n+\n+      function Img_Pos (N : Pos) return String is\n+         Buf : String (1 .. 20);\n+         Ptr : Natural;\n+         NV  : Nat;\n+\n+      begin\n+         Ptr := Buf'Last;\n+         NV := N;\n+         while NV /= 0 loop\n+            Buf (Ptr) := Character'Val (48 + NV mod 10);\n+            Ptr := Ptr - 1;\n+            NV := NV / 10;\n+         end loop;\n+\n+         return Buf (Ptr + 1 .. Buf'Last);\n+      end Img_Pos;\n+\n       ----------------\n       -- Subp_Index --\n       ----------------\n@@ -209,31 +228,24 @@ package body Exp_Unst is\n          return SI_Type (UI_To_Int (Subps_Index (Sub)));\n       end Subp_Index;\n \n-      -------------------\n-      -- Suffixed_Name --\n-      -------------------\n-\n-      function Suffixed_Name (Ent : Entity_Id) return Name_Id is\n-      begin\n-         Get_Name_String (Chars (Ent));\n-         Add_Str_To_Name_Buffer (\"__\");\n-         Add_Nat_To_Name_Buffer (Nat (Ent));\n-         return Name_Enter;\n-      end Suffixed_Name;\n-\n       ----------------\n       -- Upref_Name --\n       ----------------\n \n-      function Upref_Name (Ent : Entity_Id; Clist : List_Id) return Name_Id is\n+      function Upref_Name\n+        (Ent   : Entity_Id;\n+         Index : Pos;\n+         Clist : List_Id) return Name_Id\n+      is\n          C : Node_Id;\n       begin\n          C := First (Clist);\n          loop\n             if No (C) then\n                return Chars (Ent);\n             elsif Chars (Defining_Identifier (C)) = Chars (Ent) then\n-               return Suffixed_Name (Ent);\n+               return Name_Find_Str\n+                        (Get_Name_String (Chars (Ent)) & Img_Pos (Index));\n             else\n                Next (C);\n             end if;\n@@ -946,40 +958,33 @@ package body Exp_Unst is\n          declare\n             STJ : Subp_Entry renames Subps.Table (J);\n             Loc : constant Source_Ptr := Sloc (STJ.Bod);\n-            ARS : constant String     := AREC_String (STJ.Lev);\n \n          begin\n             --  First we create the ARECnF entity for the additional formal for\n             --  all subprograms which need an activation record passed.\n \n             if STJ.Uplevel_Ref < STJ.Lev then\n                STJ.ARECnF :=\n-                 Make_Defining_Identifier (Loc,\n-                   Chars => Name_Find_Str (AREC_String (STJ.Lev - 1) & \"F\"));\n+                 Make_Defining_Identifier (Loc, Chars => AREC_Name (J, \"F\"));\n             end if;\n \n             --  Define the AREC entities for the activation record if needed\n \n             if STJ.Declares_AREC then\n                STJ.ARECn   :=\n-                 Make_Defining_Identifier (Loc, Name_Find_Str (ARS));\n+                 Make_Defining_Identifier (Loc, AREC_Name (J, \"\"));\n                STJ.ARECnT  :=\n-                 Make_Defining_Identifier (Loc, Name_Find_Str (ARS & \"T\"));\n+                 Make_Defining_Identifier (Loc, AREC_Name (J, \"T\"));\n                STJ.ARECnPT :=\n-                 Make_Defining_Identifier (Loc, Name_Find_Str (ARS & \"PT\"));\n+                 Make_Defining_Identifier (Loc, AREC_Name (J, \"PT\"));\n                STJ.ARECnP  :=\n-                 Make_Defining_Identifier (Loc, Name_Find_Str (ARS & \"P\"));\n+                 Make_Defining_Identifier (Loc, AREC_Name (J, \"P\"));\n \n                --  Define uplink component entity if inner nesting case\n \n                if Present (STJ.ARECnF) then\n-                  declare\n-                     ARS1 : constant String := AREC_String (STJ.Lev - 1);\n-                  begin\n-                     STJ.ARECnU :=\n-                       Make_Defining_Identifier (Loc,\n-                         Chars => Name_Find_Str (ARS1 & \"U\"));\n-                  end;\n+                  STJ.ARECnU :=\n+                    Make_Defining_Identifier (Loc, AREC_Name (J, \"U\"));\n                end if;\n             end if;\n          end;\n@@ -1103,22 +1108,15 @@ package body Exp_Unst is\n                      --  List of new declarations we create\n \n                   begin\n-                     --  Suffix the ARECnT and ARECnPT names to make sure that\n-                     --  they are unique when Cprint moves the declarations to\n-                     --  the outer level.\n-\n-                     Set_Chars (STJ.ARECnT,  Suffixed_Name (STJ.ARECnT));\n-                     Set_Chars (STJ.ARECnPT, Suffixed_Name (STJ.ARECnPT));\n-\n                      --  Build list of component declarations for ARECnT\n \n                      Clist := Empty_List;\n \n                      --  If we are in a subprogram that has a static link that\n                      --  is passed in (as indicated by ARECnF being defined),\n-                     --  then include ARECnU : ARECmPT where m is one less than\n-                     --  the current level and the entity ARECnPT comes from\n-                     --  the enclosing subprogram.\n+                     --  then include ARECnU : ARECmPT where ARECmPT comes from\n+                     --  the level one higher than the current level, and the\n+                     --  entity ARECnPT comes from the enclosing subprogram.\n \n                      if Present (STJ.ARECnF) then\n                         declare\n@@ -1142,14 +1140,20 @@ package body Exp_Unst is\n                            Elmt : Elmt_Id;\n                            Uent : Entity_Id;\n \n+                           Indx : Nat;\n+                           --  1's origin of index in list of elements. This is\n+                           --  used to uniquify names if needed in Upref_Name.\n+\n                         begin\n                            Elmt := First_Elmt (STJ.Uents);\n+                           Indx := 0;\n                            while Present (Elmt) loop\n                               Uent := Node (Elmt);\n+                              Indx := Indx + 1;\n \n                               Comp :=\n                                 Make_Defining_Identifier (Loc,\n-                                  Chars => Upref_Name (Uent, Clist));\n+                                  Chars => Upref_Name (Uent, Indx, Clist));\n \n                               Set_Activation_Record_Component\n                                 (Uent, Comp);"}, {"sha": "084e904b677c91985e786c5e450bb2f894e15468", "filename": "gcc/ada/exp_unst.ads", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/551e193501cebca18c19ed9ede7df7c2ee0bd9a6/gcc%2Fada%2Fexp_unst.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/551e193501cebca18c19ed9ede7df7c2ee0bd9a6/gcc%2Fada%2Fexp_unst.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.ads?ref=551e193501cebca18c19ed9ede7df7c2ee0bd9a6", "patch": "@@ -184,9 +184,9 @@ package Exp_Unst is\n    --   The fields of AREC1 are set at the point the corresponding entity\n    --   is declared (immediately for parameters).\n \n-   --   Note: the 1 in all these names represents the fact that we are at the\n-   --   outer level of nesting. As we will see later, deeper levels of nesting\n-   --   will use AREC2, AREC3, ...\n+   --   Note: the 1 in all these names is a unique index number. Different\n+   --   scopes requiring different ARECnT declarations will have different\n+   --   values of n to ensure uniqueness.\n \n    --   Note: normally the field names in the activation record match the\n    --   name of the entity. An exception is when the entity is declared in\n@@ -294,8 +294,8 @@ package Exp_Unst is\n \n    --    What we do is to always generate a local constant for any dynamic\n    --    bound in a dynamic subtype xx with name xx_FIRST or xx_LAST. The one\n-   --    case where we can skip this is where the bound is For\n-   --    example in the third example above, subtype dynam is expanded as\n+   --    case where we can skip this is where the bound is e.g. in the third\n+   --    example above, subtype dynam is expanded as\n \n    --      dynam_LAST  : constant Integer := y + 3;\n    --      subtype dynam is integer range x .. dynam_LAST;\n@@ -465,8 +465,8 @@ package Exp_Unst is\n    --        return inner1 (x, AREC1P);\n    --     end case4x;\n \n-   --  As can be seen in this example, the level number following AREC in the\n-   --  names avoids any confusion between AREC names at different levels.\n+   --  As can be seen in this example, the index numbers following AREC in the\n+   --  generated names avoid confusion between AREC names at different levels.\n \n    -------------------------\n    -- Name Disambiguation --"}, {"sha": "15fa6ad30115d8ead8b654477109438acf195c86", "filename": "gcc/ada/sem_cat.adb", "status": "modified", "additions": 42, "deletions": 23, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/551e193501cebca18c19ed9ede7df7c2ee0bd9a6/gcc%2Fada%2Fsem_cat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/551e193501cebca18c19ed9ede7df7c2ee0bd9a6/gcc%2Fada%2Fsem_cat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.adb?ref=551e193501cebca18c19ed9ede7df7c2ee0bd9a6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -441,31 +441,35 @@ package body Sem_Cat is\n       At_Any_Place : Boolean := False) return Boolean\n    is\n       Rep_Item  : Node_Id;\n-      Full_Type : Entity_Id := Typ;\n+      Real_Rep  : Node_Id;\n+      --  The stream operation may be specified by an attribute definition\n+      --  clause in the source, or by an aspect that generates such an\n+      --  attribute definition. For an aspect, the generated attribute\n+      --  definition may be placed at the freeze point of the full view of\n+      --  the type, but the aspect specification makes the operation visible\n+      --  to a client wherever the partial view is visible.\n \n    begin\n-      --  In the case of a type derived from a private view, any specified\n-      --  stream attributes will be attached to the derived type's underlying\n-      --  type rather the derived type entity itself (which is itself private).\n-\n-      if Is_Private_Type (Typ)\n-        and then Is_Derived_Type (Typ)\n-        and then Present (Full_View (Typ))\n-      then\n-         Full_Type := Underlying_Type (Typ);\n-      end if;\n-\n       --  We start from the declaration node and then loop until the end of\n       --  the list until we find the requested attribute definition clause.\n       --  In Ada 2005 mode, clauses are ignored if they are not currently\n       --  visible (this is tested using the corresponding Entity, which is\n       --  inserted by the expander at the point where the clause occurs),\n       --  unless At_Any_Place is true.\n \n-      Rep_Item := First_Rep_Item (Full_Type);\n+      Rep_Item := First_Rep_Item (Typ);\n       while Present (Rep_Item) loop\n-         if Nkind (Rep_Item) = N_Attribute_Definition_Clause then\n-            case Chars (Rep_Item) is\n+         Real_Rep := Rep_Item;\n+\n+         --  If the representation item is an aspect specification, retrieve\n+         --  the corresponding pragma or attribute definition.\n+\n+         if Nkind (Rep_Item) = N_Aspect_Specification then\n+            Real_Rep := Aspect_Rep_Item (Rep_Item);\n+         end if;\n+\n+         if Nkind (Real_Rep) = N_Attribute_Definition_Clause then\n+            case Chars (Real_Rep) is\n                when Name_Read =>\n                   exit when Nam = TSS_Stream_Read;\n \n@@ -487,14 +491,29 @@ package body Sem_Cat is\n          Next_Rep_Item (Rep_Item);\n       end loop;\n \n-      --  If At_Any_Place is true, return True if the attribute is available\n-      --  at any place; if it is false, return True only if the attribute is\n-      --  currently visible.\n+      --  If not found, and the type is derived from a private view, check\n+      --  for a stream attribute inherited from parent. Any specified stream\n+      --  attributes will be attached to the derived type's underlying type\n+      --  rather the derived type entity itself (which is itself private).\n+\n+      if No (Rep_Item)\n+        and then Is_Private_Type (Typ)\n+        and then Is_Derived_Type (Typ)\n+        and then Present (Full_View (Typ))\n+      then\n+         return Has_Stream_Attribute_Definition\n+            (Underlying_Type (Typ), Nam, At_Any_Place);\n+\n+      --  Otherwise, if At_Any_Place is true, return True if the attribute is\n+      --  available at any place; if it is false, return True only if the\n+      --  attribute is currently visible.\n \n-      return Present (Rep_Item)\n-        and then (Ada_Version < Ada_2005\n-                   or else At_Any_Place\n-                   or else not Is_Hidden (Entity (Rep_Item)));\n+      else\n+         return Present (Rep_Item)\n+           and then (Ada_Version < Ada_2005\n+                      or else At_Any_Place\n+                      or else not Is_Hidden (Entity (Rep_Item)));\n+      end if;\n    end Has_Stream_Attribute_Definition;\n \n    ----------------------------"}, {"sha": "03fec8b989455d33271f2d61dbe8c9e90540fe8b", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/551e193501cebca18c19ed9ede7df7c2ee0bd9a6/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/551e193501cebca18c19ed9ede7df7c2ee0bd9a6/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=551e193501cebca18c19ed9ede7df7c2ee0bd9a6", "patch": "@@ -916,30 +916,30 @@ package body Sem_Ch4 is\n       ----------------------------\n \n       --  The identification of conflicts in calls to functions with writable\n-      --  actuals is performed in the analysis phase of the frontend to ensure\n+      --  actuals is performed in the analysis phase of the front end to ensure\n       --  that it reports exactly the same errors compiling with and without\n       --  expansion enabled. It is performed in two stages:\n \n-      --    1) When a call to a function with out-mode parameters is found\n-      --       we climb to the outermost enclosing construct which can be\n+      --    1) When a call to a function with out-mode parameters is found,\n+      --       we climb to the outermost enclosing construct that can be\n       --       evaluated in arbitrary order and we mark it with the flag\n       --       Check_Actuals.\n \n-      --    2) When the analysis of the marked node is complete then we\n-      --       traverse its decorated subtree searching for conflicts\n-      --       (see function Sem_Util.Check_Function_Writable_Actuals).\n+      --    2) When the analysis of the marked node is complete, we traverse\n+      --       its decorated subtree searching for conflicts (see function\n+      --       Sem_Util.Check_Function_Writable_Actuals).\n \n-      --  The unique exception to this general rule are aggregates, since\n-      --  their analysis is performed by the frontend in the resolution\n-      --  phase. For aggregates we do not climb to its enclosing construct:\n+      --  The unique exception to this general rule is for aggregates, since\n+      --  their analysis is performed by the front end in the resolution\n+      --  phase. For aggregates we do not climb to their enclosing construct:\n       --  we restrict the analysis to the subexpressions initializing the\n       --  aggregate components.\n \n       --  This implies that the analysis of expressions containing aggregates\n-      --  is not complete since there may be conflicts on writable actuals\n+      --  is not complete, since there may be conflicts on writable actuals\n       --  involving subexpressions of the enclosing logical or arithmetic\n       --  expressions. However, we cannot wait and perform the analysis when\n-      --  the whole subtree is resolved since the subtrees may be transformed\n+      --  the whole subtree is resolved, since the subtrees may be transformed,\n       --  thus adding extra complexity and computation cost to identify and\n       --  report exactly the same errors compiling with and without expansion\n       --  enabled.\n@@ -948,9 +948,9 @@ package body Sem_Ch4 is\n \n          function Is_Arbitrary_Evaluation_Order_Construct\n            (N : Node_Id) return Boolean;\n-         --  Return True if N is an Ada construct which may evaluate in\n-         --  arbitrary order. This function does not cover all the language\n-         --  constructs which can be evaluated in arbitrary order but the\n+         --  Return True if N is an Ada construct which may be evaluated in\n+         --  an arbitrary order. This function does not cover all the language\n+         --  constructs that can be evaluated in arbitrary order, but only the\n          --  subset needed for AI05-0144.\n \n          ---------------------------------------------\n@@ -1003,11 +1003,11 @@ package body Sem_Ch4 is\n                begin\n                   while Present (P) loop\n \n-                     --  For object declarations we can climb to such node from\n+                     --  For object declarations we can climb to the node from\n                      --  its object definition branch or from its initializing\n                      --  expression. We prefer to mark the child node as the\n                      --  outermost construct to avoid adding further complexity\n-                     --  to the routine which will take care later of\n+                     --  to the routine that will later take care of\n                      --  performing the writable actuals check.\n \n                      if Is_Arbitrary_Evaluation_Order_Construct (P)\n@@ -1407,8 +1407,8 @@ package body Sem_Ch4 is\n \n          Check_Writable_Actuals (N);\n \n-         --  If found and the outermost construct which can be evaluated in\n-         --  arbitrary order is precisely this call then check all its\n+         --  If found and the outermost construct that can be evaluated in\n+         --  an arbitrary order is precisely this call, then check all its\n          --  actuals.\n \n          if Check_Actuals (N) then"}, {"sha": "57ec05c5698889abb80d4440f3858135603bd40e", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/551e193501cebca18c19ed9ede7df7c2ee0bd9a6/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/551e193501cebca18c19ed9ede7df7c2ee0bd9a6/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=551e193501cebca18c19ed9ede7df7c2ee0bd9a6", "patch": "@@ -2119,10 +2119,10 @@ package body Sem_Util is\n                then\n                   return Skip;\n \n-               --  For now we skip aggregate discriminants since they require\n+               --  For now we skip aggregate discriminants, since they require\n                --  performing the analysis in two phases to identify conflicts:\n                --  first one analyzing discriminants and second one analyzing\n-               --  the rest of components (since at runtime discriminants are\n+               --  the rest of components (since at run time, discriminants are\n                --  evaluated prior to components): too much computation cost\n                --  to identify a corner case???\n \n@@ -2191,8 +2191,8 @@ package body Sem_Util is\n \n                      --  Report the error on the second occurrence of the\n                      --  identifier. We cannot assume that N is the second\n-                     --  occurrence since traverse_func walks through Field2\n-                     --  last (see comment in the body of traverse_func).\n+                     --  occurrence, since Traverse_Func walks through Field2\n+                     --  last (see comment in the body of Traverse_Func).\n \n                      declare\n                         Elmt : Elmt_Id;"}]}