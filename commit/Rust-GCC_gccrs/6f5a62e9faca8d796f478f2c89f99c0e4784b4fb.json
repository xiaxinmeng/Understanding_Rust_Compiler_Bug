{"sha": "6f5a62e9faca8d796f478f2c89f99c0e4784b4fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY1YTYyZTlmYWNhOGQ3OTZmNDc4ZjJjODlmOTljMGU0Nzg0YjRmYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2009-08-26T20:39:27Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2009-08-26T20:39:27Z"}, "message": "mips-protos.h (mips_output_sync): Declare.\n\ngcc/\n\t* config/mips/mips-protos.h (mips_output_sync): Declare.\n\t(mips_sync_loop_insns): Likewise.\n\t(mips_output_sync_loop): Replace first two parameters with an rtx.\n\t* config/mips/mips.c (mips_multi_member): New structure.\n\t(mips_multi_members): New variable.\n\t(mips_multi_start): New function.\n\t(mips_multi_add): Likewise.\n\t(mips_multi_add_insn): Likewise.\n\t(mips_multi_add_label): Likewise.\n\t(mips_multi_last_index): Likewise.\n\t(mips_multi_copy_insn): Likewise.\n\t(mips_multi_set_operand): Likewise.\n\t(mips_multi_write): Likewise.\n\t(mips_print_operand_punctuation): Remove '%|' and '%-'.\n\t(mips_init_print_operand_punct): Update accordingly.\n\t(mips_start_ll_sc_sync_block): New function.\n\t(mips_end_ll_sc_sync_block): Likewise.\n\t(mips_output_sync): Likewise.\n\t(mips_sync_insn1_template): Likewise.\n\t(mips_sync_insn2_template): Likewise.\n\t(mips_get_sync_operand): Likewise.\n\t(mips_process_sync_loop): Likewise.\n\t(mips_output_sync_loop): Use mips_process_sync_loop.\n\t(mips_sync_loop_insns): New function.\n\t* config/mips/mips.h (MIPS_COMPARE_AND_SWAP): Delete.\n\t(MIPS_COMPARE_AND_SWAP_12): Likewise.\n\t(MIPS_COMPARE_AND_SWAP_12_ZERO_OP): Likewise.\n\t(MIPS_COMPARE_AND_SWAP_12_NONZERO_OP): Likewise.\n\t(MIPS_SYNC_OP, MIPS_SYNC_OP_12): Likewise.\n\t(MIPS_SYNC_OP_12_AND, MIPS_SYNC_OP_12_XOR): Likewise.\n\t(MIPS_SYNC_OLD_OP_12): Likewise.\n\t(MIPS_SYNC_OLD_OP_12_AND, MIPS_SYNC_OLD_OP_12_XOR): Likewise.\n\t(MIPS_SYNC_NEW_OP_12): Likewise.\n\t(MIPS_SYNC_NEW_OP_12_AND, MIPS_SYNC_NEW_OP_12_XOR): Likewise.\n\t(MIPS_SYNC_OLD_OP, MIPS_SYNC_NEW_OP): Likewise.\n\t(MIPS_SYNC_NAND, MIPS_SYNC_OLD_NAND, MIPS_SYNC_NEW_NAND): Likewise.\n\t(MIPS_SYNC_EXCHANGE, MIPS_SYNC_EXCHANGE_12): Likewise.\n\t(MIPS_SYNC_EXCHANGE_12_ZERO_OP): Likewise.\n\t(MIPS_SYNC_EXCHANGE_12_NONZER_OP): Likewise.\n\t* config/mips/mips.md (sync_mem): New attribute.\n\t(sync_oldval, sync_newval, sync_inclusive_mask): Likewise.\n\t(sync_exclusive_mask, sync_required_oldval): Likewise.\n\t(sync_insn1_op2, sync_insn1, sync_insn2): Likewise.\n\t(sync_release_barrier): Likewise.\n\t(length): Handle sync loops.\n\t(sync): Use mips_output_sync.\n\t* config/mips/sync.md (*memory_barrier): Use mips_output_sync.\n\t(sync_compare_and_swap<mode>): Set the new sync_* attributes\n\tand use mips_output_sync_loop.\n\t(compare_and_swap_12, sync_add<mode>, sync_<optab>_12): Likewise.\n\t(sync_old_<optab>_12, sync_new_<optab>_12, sync_nand_12): Likewise.\n\t(sync_old_nand_12, sync_new_nand_12, sync_sub<mode>): Likewise.\n\t(sync_old_add<mode>, sync_old_sub<mode>): Likewise.\n\t(sync_new_add<mode>, sync_new_sub<mode>): Likewise.\n\t(sync_<optab><mode>, sync_old_<optab><mode>): Likewise.\n\t(sync_new_<optab><mode>, sync_nand<mode>): Likewise.\n\t(sync_old_nand<mode>, sync_new_nand<mode>): Likewise.\n\t(sync_lock_test_and_set<mode>, test_and_set_12): Likewise.\n\nFrom-SVN: r151128", "tree": {"sha": "cc70f08cd75198cdbd26275824b5a9e3c0a6d89d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc70f08cd75198cdbd26275824b5a9e3c0a6d89d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f5a62e9faca8d796f478f2c89f99c0e4784b4fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f5a62e9faca8d796f478f2c89f99c0e4784b4fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f5a62e9faca8d796f478f2c89f99c0e4784b4fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f5a62e9faca8d796f478f2c89f99c0e4784b4fb/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "41bc3c4a822b838e38a4b8f1d09c36ec54f40ddc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41bc3c4a822b838e38a4b8f1d09c36ec54f40ddc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41bc3c4a822b838e38a4b8f1d09c36ec54f40ddc"}], "stats": {"total": 1122, "additions": 656, "deletions": 466}, "files": [{"sha": "f6d242b20ecdc0a27957569799466714573b0a39", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5a62e9faca8d796f478f2c89f99c0e4784b4fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5a62e9faca8d796f478f2c89f99c0e4784b4fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f5a62e9faca8d796f478f2c89f99c0e4784b4fb", "patch": "@@ -1,3 +1,64 @@\n+2009-08-26  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* config/mips/mips-protos.h (mips_output_sync): Declare.\n+\t(mips_sync_loop_insns): Likewise.\n+\t(mips_output_sync_loop): Replace first two parameters with an rtx.\n+\t* config/mips/mips.c (mips_multi_member): New structure.\n+\t(mips_multi_members): New variable.\n+\t(mips_multi_start): New function.\n+\t(mips_multi_add): Likewise.\n+\t(mips_multi_add_insn): Likewise.\n+\t(mips_multi_add_label): Likewise.\n+\t(mips_multi_last_index): Likewise.\n+\t(mips_multi_copy_insn): Likewise.\n+\t(mips_multi_set_operand): Likewise.\n+\t(mips_multi_write): Likewise.\n+\t(mips_print_operand_punctuation): Remove '%|' and '%-'.\n+\t(mips_init_print_operand_punct): Update accordingly.\n+\t(mips_start_ll_sc_sync_block): New function.\n+\t(mips_end_ll_sc_sync_block): Likewise.\n+\t(mips_output_sync): Likewise.\n+\t(mips_sync_insn1_template): Likewise.\n+\t(mips_sync_insn2_template): Likewise.\n+\t(mips_get_sync_operand): Likewise.\n+\t(mips_process_sync_loop): Likewise.\n+\t(mips_output_sync_loop): Use mips_process_sync_loop.\n+\t(mips_sync_loop_insns): New function.\n+\t* config/mips/mips.h (MIPS_COMPARE_AND_SWAP): Delete.\n+\t(MIPS_COMPARE_AND_SWAP_12): Likewise.\n+\t(MIPS_COMPARE_AND_SWAP_12_ZERO_OP): Likewise.\n+\t(MIPS_COMPARE_AND_SWAP_12_NONZERO_OP): Likewise.\n+\t(MIPS_SYNC_OP, MIPS_SYNC_OP_12): Likewise.\n+\t(MIPS_SYNC_OP_12_AND, MIPS_SYNC_OP_12_XOR): Likewise.\n+\t(MIPS_SYNC_OLD_OP_12): Likewise.\n+\t(MIPS_SYNC_OLD_OP_12_AND, MIPS_SYNC_OLD_OP_12_XOR): Likewise.\n+\t(MIPS_SYNC_NEW_OP_12): Likewise.\n+\t(MIPS_SYNC_NEW_OP_12_AND, MIPS_SYNC_NEW_OP_12_XOR): Likewise.\n+\t(MIPS_SYNC_OLD_OP, MIPS_SYNC_NEW_OP): Likewise.\n+\t(MIPS_SYNC_NAND, MIPS_SYNC_OLD_NAND, MIPS_SYNC_NEW_NAND): Likewise.\n+\t(MIPS_SYNC_EXCHANGE, MIPS_SYNC_EXCHANGE_12): Likewise.\n+\t(MIPS_SYNC_EXCHANGE_12_ZERO_OP): Likewise.\n+\t(MIPS_SYNC_EXCHANGE_12_NONZER_OP): Likewise.\n+\t* config/mips/mips.md (sync_mem): New attribute.\n+\t(sync_oldval, sync_newval, sync_inclusive_mask): Likewise.\n+\t(sync_exclusive_mask, sync_required_oldval): Likewise.\n+\t(sync_insn1_op2, sync_insn1, sync_insn2): Likewise.\n+\t(sync_release_barrier): Likewise.\n+\t(length): Handle sync loops.\n+\t(sync): Use mips_output_sync.\n+\t* config/mips/sync.md (*memory_barrier): Use mips_output_sync.\n+\t(sync_compare_and_swap<mode>): Set the new sync_* attributes\n+\tand use mips_output_sync_loop.\n+\t(compare_and_swap_12, sync_add<mode>, sync_<optab>_12): Likewise.\n+\t(sync_old_<optab>_12, sync_new_<optab>_12, sync_nand_12): Likewise.\n+\t(sync_old_nand_12, sync_new_nand_12, sync_sub<mode>): Likewise.\n+\t(sync_old_add<mode>, sync_old_sub<mode>): Likewise.\n+\t(sync_new_add<mode>, sync_new_sub<mode>): Likewise.\n+\t(sync_<optab><mode>, sync_old_<optab><mode>): Likewise.\n+\t(sync_new_<optab><mode>, sync_nand<mode>): Likewise.\n+\t(sync_old_nand<mode>, sync_new_nand<mode>): Likewise.\n+\t(sync_lock_test_and_set<mode>, test_and_set_12): Likewise.\n+\n 2009-08-26  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/41163"}, {"sha": "a1e28ce23c6e797e01d19a37c4ad232ccd9c93c5", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5a62e9faca8d796f478f2c89f99c0e4784b4fb/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5a62e9faca8d796f478f2c89f99c0e4784b4fb/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=6f5a62e9faca8d796f478f2c89f99c0e4784b4fb", "patch": "@@ -300,7 +300,9 @@ extern const char *mips_output_load_label (void);\n extern const char *mips_output_conditional_branch (rtx, rtx *, const char *,\n \t\t\t\t\t\t   const char *);\n extern const char *mips_output_order_conditional_branch (rtx, rtx *, bool);\n-extern const char *mips_output_sync_loop (bool, const char *, rtx *);\n+extern const char *mips_output_sync (void);\n+extern const char *mips_output_sync_loop (rtx, rtx *);\n+extern unsigned int mips_sync_loop_insns (rtx, rtx *);\n extern const char *mips_output_division (const char *, rtx *);\n extern unsigned int mips_hard_regno_nregs (int, enum machine_mode);\n extern bool mips_linked_madd_p (rtx, rtx);"}, {"sha": "1e4d8bd8ed5a506ef8807afbe1c938abfb295549", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 393, "deletions": 31, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5a62e9faca8d796f478f2c89f99c0e4784b4fb/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5a62e9faca8d796f478f2c89f99c0e4784b4fb/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=6f5a62e9faca8d796f478f2c89f99c0e4784b4fb", "patch": "@@ -3763,6 +3763,132 @@ mips_address_cost (rtx addr, bool speed ATTRIBUTE_UNUSED)\n   return mips_address_insns (addr, SImode, false);\n }\n \f\n+/* Information about a single instruction in a multi-instruction\n+   asm sequence.  */\n+struct mips_multi_member {\n+  /* True if this is a label, false if it is code.  */\n+  bool is_label_p;\n+\n+  /* The output_asm_insn format of the instruction.  */\n+  const char *format;\n+\n+  /* The operands to the instruction.  */\n+  rtx operands[MAX_RECOG_OPERANDS];\n+};\n+typedef struct mips_multi_member mips_multi_member;\n+\n+/* Vector definitions for the above.  */\n+DEF_VEC_O(mips_multi_member);\n+DEF_VEC_ALLOC_O(mips_multi_member, heap);\n+\n+/* The instructions that make up the current multi-insn sequence.  */\n+static VEC (mips_multi_member, heap) *mips_multi_members;\n+\n+/* How many instructions (as opposed to labels) are in the current\n+   multi-insn sequence.  */\n+static unsigned int mips_multi_num_insns;\n+\n+/* Start a new multi-insn sequence.  */\n+\n+static void\n+mips_multi_start (void)\n+{\n+  VEC_truncate (mips_multi_member, mips_multi_members, 0);\n+  mips_multi_num_insns = 0;\n+}\n+\n+/* Add a new, uninitialized member to the current multi-insn sequence.  */\n+\n+static struct mips_multi_member *\n+mips_multi_add (void)\n+{\n+  return VEC_safe_push (mips_multi_member, heap, mips_multi_members, 0);\n+}\n+\n+/* Add a normal insn with the given asm format to the current multi-insn\n+   sequence.  The other arguments are a null-terminated list of operands.  */\n+\n+static void\n+mips_multi_add_insn (const char *format, ...)\n+{\n+  struct mips_multi_member *member;\n+  va_list ap;\n+  unsigned int i;\n+  rtx op;\n+\n+  member = mips_multi_add ();\n+  member->is_label_p = false;\n+  member->format = format;\n+  va_start (ap, format);\n+  i = 0;\n+  while ((op = va_arg (ap, rtx)))\n+    member->operands[i++] = op;\n+  va_end (ap);\n+  mips_multi_num_insns++;\n+}\n+\n+/* Add the given label definition to the current multi-insn sequence.\n+   The definition should include the colon.  */\n+\n+static void\n+mips_multi_add_label (const char *label)\n+{\n+  struct mips_multi_member *member;\n+\n+  member = mips_multi_add ();\n+  member->is_label_p = true;\n+  member->format = label;\n+}\n+\n+/* Return the index of the last member of the current multi-insn sequence.  */\n+\n+static unsigned int\n+mips_multi_last_index (void)\n+{\n+  return VEC_length (mips_multi_member, mips_multi_members) - 1;\n+}\n+\n+/* Add a copy of an existing instruction to the current multi-insn\n+   sequence.  I is the index of the instruction that should be copied.  */\n+\n+static void\n+mips_multi_copy_insn (unsigned int i)\n+{\n+  struct mips_multi_member *member;\n+\n+  member = mips_multi_add ();\n+  memcpy (member, VEC_index (mips_multi_member, mips_multi_members, i),\n+\t  sizeof (*member));\n+  gcc_assert (!member->is_label_p);\n+}\n+\n+/* Change the operand of an existing instruction in the current\n+   multi-insn sequence.  I is the index of the instruction,\n+   OP is the index of the operand, and X is the new value.  */\n+\n+static void\n+mips_multi_set_operand (unsigned int i, unsigned int op, rtx x)\n+{\n+  VEC_index (mips_multi_member, mips_multi_members, i)->operands[op] = x;\n+}\n+\n+/* Write out the asm code for the current multi-insn sequence.  */\n+\n+static void\n+mips_multi_write (void)\n+{\n+  struct mips_multi_member *member;\n+  unsigned int i;\n+\n+  for (i = 0;\n+       VEC_iterate (mips_multi_member, mips_multi_members, i, member);\n+       i++)\n+    if (member->is_label_p)\n+      fprintf (asm_out_file, \"%s\\n\", member->format);\n+    else\n+      output_asm_insn (member->format, member->operands);\n+}\n+\f\n /* Return one word of double-word value OP, taking into account the fixed\n    endianness of certain registers.  HIGH_P is true to select the high part,\n    false to select the low part.  */\n@@ -7047,8 +7173,6 @@ mips_pop_asm_switch (struct mips_asm_switch *asm_switch)\n    '^'\tPrint the name of the pic call-through register (t9 or $25).\n    '+'\tPrint the name of the gp register (usually gp or $28).\n    '$'\tPrint the name of the stack pointer register (sp or $29).\n-   '|'\tPrint \".set push; .set mips2\" if !ISA_HAS_LL_SC.\n-   '-'\tPrint \".set pop\" under the same conditions for '|'.\n \n    See also mips_init_print_operand_pucnt.  */\n \n@@ -7132,16 +7256,6 @@ mips_print_operand_punctuation (FILE *file, int ch)\n       fputs (reg_names[STACK_POINTER_REGNUM], file);\n       break;\n \n-    case '|':\n-      if (!ISA_HAS_LL_SC)\n-\tfputs (\".set\\tpush\\n\\t.set\\tmips2\\n\\t\", file);\n-      break;\n-\n-    case '-':\n-      if (!ISA_HAS_LL_SC)\n-\tfputs (\"\\n\\t.set\\tpop\", file);\n-      break;\n-\n     default:\n       gcc_unreachable ();\n       break;\n@@ -7155,7 +7269,7 @@ mips_init_print_operand_punct (void)\n {\n   const char *p;\n \n-  for (p = \"()[]<>*#/?~.@^+$|-\"; *p; p++)\n+  for (p = \"()[]<>*#/?~.@^+$\"; *p; p++)\n     mips_print_operand_punct[(unsigned char) *p] = true;\n }\n \n@@ -10808,31 +10922,279 @@ mips_output_order_conditional_branch (rtx insn, rtx *operands, bool inverted_p)\n   return mips_output_conditional_branch (insn, operands, branch[1], branch[0]);\n }\n \f\n-/* Return or emit the assembly code for __sync_*() loop LOOP.  The\n-   loop should support both normal and likely branches, using %? and\n-   %~ where appropriate.  If BARRIER_BEFORE is true a sync sequence is\n-   emitted before the loop.  A sync is always emitted after the loop.\n-   OPERANDS are the insn operands.  */\n+/* Start a block of code that needs access to the LL, SC and SYNC\n+   instructions.  */\n+\n+static void\n+mips_start_ll_sc_sync_block (void)\n+{\n+  if (!ISA_HAS_LL_SC)\n+    {\n+      output_asm_insn (\".set\\tpush\", 0);\n+      output_asm_insn (\".set\\tmips2\", 0);\n+    }\n+}\n+\n+/* End a block started by mips_start_ll_sc_sync_block.  */\n+\n+static void\n+mips_end_ll_sc_sync_block (void)\n+{\n+  if (!ISA_HAS_LL_SC)\n+    output_asm_insn (\".set\\tpop\", 0);\n+}\n+\n+/* Output and/or return the asm template for a sync instruction.  */\n \n const char *\n-mips_output_sync_loop (bool barrier_before,\n-\t\t       const char *loop, rtx *operands)\n+mips_output_sync (void)\n {\n-  if (barrier_before)\n-    output_asm_insn (\"sync\", NULL);\n-  /* Use branch-likely instructions to work around the LL/SC R10000 errata.  */\n-  mips_branch_likely = TARGET_FIX_R10000;\n+  mips_start_ll_sc_sync_block ();\n+  output_asm_insn (\"sync\", 0);\n+  mips_end_ll_sc_sync_block ();\n+  return \"\";\n+}\n \n-  /* If the target needs a sync after the loop, emit the loop now and\n-     return the sync.  */\n+/* Return the asm template associated with sync_insn1 value TYPE.\n+   IS_64BIT_P is true if we want a 64-bit rather than 32-bit operation.  */\n \n-  if (TARGET_SYNC_AFTER_SC)\n+static const char *\n+mips_sync_insn1_template (enum attr_sync_insn1 type, bool is_64bit_p)\n+{\n+  switch (type)\n+    {\n+    case SYNC_INSN1_MOVE:\n+      return \"move\\t%0,%z2\";\n+    case SYNC_INSN1_LI:\n+      return \"li\\t%0,%2\";\n+    case SYNC_INSN1_ADDU:\n+      return is_64bit_p ? \"daddu\\t%0,%1,%z2\" : \"addu\\t%0,%1,%z2\";\n+    case SYNC_INSN1_ADDIU:\n+      return is_64bit_p ? \"daddiu\\t%0,%1,%2\" : \"addiu\\t%0,%1,%2\";\n+    case SYNC_INSN1_SUBU:\n+      return is_64bit_p ? \"dsubu\\t%0,%1,%z2\" : \"subu\\t%0,%1,%z2\";\n+    case SYNC_INSN1_AND:\n+      return \"and\\t%0,%1,%z2\";\n+    case SYNC_INSN1_ANDI:\n+      return \"andi\\t%0,%1,%2\";\n+    case SYNC_INSN1_OR:\n+      return \"or\\t%0,%1,%z2\";\n+    case SYNC_INSN1_ORI:\n+      return \"ori\\t%0,%1,%2\";\n+    case SYNC_INSN1_XOR:\n+      return \"xor\\t%0,%1,%z2\";\n+    case SYNC_INSN1_XORI:\n+      return \"xori\\t%0,%1,%2\";\n+    }\n+  gcc_unreachable ();\n+}\n+\n+/* Return the asm template associated with sync_insn2 value TYPE.  */\n+\n+static const char *\n+mips_sync_insn2_template (enum attr_sync_insn2 type)\n+{\n+  switch (type)\n+    {\n+    case SYNC_INSN2_NOP:\n+      gcc_unreachable ();\n+    case SYNC_INSN2_AND:\n+      return \"and\\t%0,%1,%z2\";\n+    case SYNC_INSN2_XOR:\n+      return \"xor\\t%0,%1,%z2\";\n+    case SYNC_INSN2_NOT:\n+      return \"nor\\t%0,%1,%.\";\n+    }\n+  gcc_unreachable ();\n+}\n+\n+/* OPERANDS are the operands to a sync loop instruction and INDEX is\n+   the value of the one of the sync_* attributes.  Return the operand\n+   referred to by the attribute, or DEFAULT_VALUE if the insn doesn't\n+   have the associated attribute.  */\n+\n+static rtx\n+mips_get_sync_operand (rtx *operands, int index, rtx default_value)\n+{\n+  if (index > 0)\n+    default_value = operands[index - 1];\n+  return default_value;\n+}\n+\n+/* INSN is a sync loop with operands OPERANDS.  Build up a multi-insn\n+   sequence for it.  */\n+\n+static void\n+mips_process_sync_loop (rtx insn, rtx *operands)\n+{\n+  rtx at, mem, oldval, newval, inclusive_mask, exclusive_mask;\n+  rtx required_oldval, insn1_op2, tmp1, tmp2, tmp3;\n+  unsigned int tmp3_insn;\n+  enum attr_sync_insn1 insn1;\n+  enum attr_sync_insn2 insn2;\n+  bool is_64bit_p;\n+\n+  /* Read an operand from the sync_WHAT attribute and store it in\n+     variable WHAT.  DEFAULT is the default value if no attribute\n+     is specified.  */\n+#define READ_OPERAND(WHAT, DEFAULT) \\\n+  WHAT = mips_get_sync_operand (operands, (int) get_attr_sync_##WHAT (insn), \\\n+  \t\t\t\tDEFAULT)\n+\n+  /* Read the memory.  */\n+  READ_OPERAND (mem, 0);\n+  gcc_assert (mem);\n+  is_64bit_p = (GET_MODE_BITSIZE (GET_MODE (mem)) == 64);\n+\n+  /* Read the other attributes.  */\n+  at = gen_rtx_REG (GET_MODE (mem), AT_REGNUM);\n+  READ_OPERAND (oldval, at);\n+  READ_OPERAND (newval, at);\n+  READ_OPERAND (inclusive_mask, 0);\n+  READ_OPERAND (exclusive_mask, 0);\n+  READ_OPERAND (required_oldval, 0);\n+  READ_OPERAND (insn1_op2, 0);\n+  insn1 = get_attr_sync_insn1 (insn);\n+  insn2 = get_attr_sync_insn2 (insn);\n+\n+  mips_multi_start ();\n+\n+  /* Output the release side of the memory barrier.  */\n+  if (get_attr_sync_release_barrier (insn) == SYNC_RELEASE_BARRIER_YES)\n+    mips_multi_add_insn (\"sync\", NULL);\n+\n+  /* Output the branch-back label.  */\n+  mips_multi_add_label (\"1:\");\n+\n+  /* OLDVAL = *MEM.  */\n+  mips_multi_add_insn (is_64bit_p ? \"lld\\t%0,%1\" : \"ll\\t%0,%1\",\n+\t\t       oldval, mem, NULL);\n+\n+  /* if ((OLDVAL & INCLUSIVE_MASK) != REQUIRED_OLDVAL) goto 2.  */\n+  if (required_oldval)\n+    {\n+      if (inclusive_mask == 0)\n+\ttmp1 = oldval;\n+      else\n+\t{\n+\t  gcc_assert (oldval != at);\n+\t  mips_multi_add_insn (\"and\\t%0,%1,%2\",\n+\t\t\t       at, oldval, inclusive_mask, NULL);\n+\t  tmp1 = at;\n+\t}\n+      mips_multi_add_insn (\"bne\\t%0,%z1,2f\", tmp1, required_oldval, NULL);\n+    }\n+\n+  /* $TMP1 = OLDVAL & EXCLUSIVE_MASK.  */\n+  if (exclusive_mask == 0)\n+    tmp1 = const0_rtx;\n+  else\n+    {\n+      gcc_assert (oldval != at);\n+      mips_multi_add_insn (\"and\\t%0,%1,%z2\",\n+\t\t\t   at, oldval, exclusive_mask, NULL);\n+      tmp1 = at;\n+    }\n+\n+  /* $TMP2 = INSN1 (OLDVAL, INSN1_OP2).\n+\n+     We can ignore moves if $TMP4 != INSN1_OP2, since we'll still emit\n+     at least one instruction in that case.  */\n+  if (insn1 == SYNC_INSN1_MOVE\n+      && (tmp1 != const0_rtx || insn2 != SYNC_INSN2_NOP))\n+    tmp2 = insn1_op2;\n+  else\n     {\n-      output_asm_insn (loop, operands);\n-      loop = \"sync\";\n+      mips_multi_add_insn (mips_sync_insn1_template (insn1, is_64bit_p),\n+\t\t\t   newval, oldval, insn1_op2, NULL);\n+      tmp2 = newval;\n     }\n- \n-  return loop;\n+\n+  /* $TMP3 = INSN2 ($TMP2, INCLUSIVE_MASK).  */\n+  if (insn2 == SYNC_INSN2_NOP)\n+    tmp3 = tmp2;\n+  else\n+    {\n+      mips_multi_add_insn (mips_sync_insn2_template (insn2),\n+\t\t\t   newval, tmp2, inclusive_mask, NULL);\n+      tmp3 = newval;\n+    }\n+  tmp3_insn = mips_multi_last_index ();\n+\n+  /* $AT = $TMP1 | $TMP3.  */\n+  if (tmp1 == const0_rtx || tmp3 == const0_rtx)\n+    {\n+      mips_multi_set_operand (tmp3_insn, 0, at);\n+      tmp3 = at;\n+    }\n+  else\n+    {\n+      gcc_assert (tmp1 != tmp3);\n+      mips_multi_add_insn (\"or\\t%0,%1,%2\", at, tmp1, tmp3, NULL);\n+    }\n+\n+  /* if (!commit (*MEM = $AT)) goto 1.\n+\n+     This will sometimes be a delayed branch; see the write code below\n+     for details.  */\n+  mips_multi_add_insn (is_64bit_p ? \"scd\\t%0,%1\" : \"sc\\t%0,%1\", at, mem, NULL);\n+  mips_multi_add_insn (\"beq%?\\t%0,%.,1b\", at, NULL);\n+\n+  /* if (INSN1 != MOVE && INSN1 != LI) NEWVAL = $TMP3 [delay slot].  */\n+  if (insn1 != SYNC_INSN1_MOVE && insn1 != SYNC_INSN1_LI && tmp3 != newval)\n+    {\n+      mips_multi_copy_insn (tmp3_insn);\n+      mips_multi_set_operand (mips_multi_last_index (), 0, newval);\n+    }\n+  else\n+    mips_multi_add_insn (\"nop\", NULL);\n+\n+  /* Output the acquire side of the memory barrier.  */\n+  if (TARGET_SYNC_AFTER_SC)\n+    mips_multi_add_insn (\"sync\", NULL);\n+\n+  /* Output the exit label, if needed.  */\n+  if (required_oldval)\n+    mips_multi_add_label (\"2:\");\n+\n+#undef READ_OPERAND\n+}\n+\n+/* Output and/or return the asm template for sync loop INSN, which has\n+   the operands given by OPERANDS.  */\n+\n+const char *\n+mips_output_sync_loop (rtx insn, rtx *operands)\n+{\n+  mips_process_sync_loop (insn, operands);\n+\n+  /* Use branch-likely instructions to work around the LL/SC R10000\n+     errata.  */\n+  mips_branch_likely = TARGET_FIX_R10000;\n+\n+  mips_push_asm_switch (&mips_noreorder);\n+  mips_push_asm_switch (&mips_nomacro);\n+  mips_push_asm_switch (&mips_noat);\n+  mips_start_ll_sc_sync_block ();\n+\n+  mips_multi_write ();\n+\n+  mips_end_ll_sc_sync_block ();\n+  mips_pop_asm_switch (&mips_noat);\n+  mips_pop_asm_switch (&mips_nomacro);\n+  mips_pop_asm_switch (&mips_noreorder);\n+\n+  return \"\";\n+}\n+\n+/* Return the number of individual instructions in sync loop INSN,\n+   which has the operands given by OPERANDS.  */\n+\n+unsigned int\n+mips_sync_loop_insns (rtx insn, rtx *operands)\n+{\n+  mips_process_sync_loop (insn, operands);\n+  return mips_multi_num_insns;\n }\n \f\n /* Return the assembly code for DIV or DDIV instruction DIVISION, which has"}, {"sha": "352dbd25618b4a59745eb820f5b3d35ebf9a07ff", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 264, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5a62e9faca8d796f478f2c89f99c0e4784b4fb/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5a62e9faca8d796f478f2c89f99c0e4784b4fb/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=6f5a62e9faca8d796f478f2c89f99c0e4784b4fb", "patch": "@@ -3113,270 +3113,6 @@ while (0)\n #define HAVE_AS_TLS 0\n #endif\n \n-/* Return an asm string that atomically:\n-\n-     - Compares memory reference %1 to register %2 and, if they are\n-       equal, changes %1 to %3.\n-\n-     - Sets register %0 to the old value of memory reference %1.\n-\n-   SUFFIX is the suffix that should be added to \"ll\" and \"sc\" instructions\n-   and OP is the instruction that should be used to load %3 into a\n-   register.  */\n-#define MIPS_COMPARE_AND_SWAP(SUFFIX, OP)\t\\\n-  \"%(%<%[%|1:\\tll\" SUFFIX \"\\t%0,%1\\n\"\t\t\\\n-  \"\\tbne\\t%0,%z2,2f\\n\"\t\t\t\t\\\n-  \"\\t\" OP \"\\t%@,%3\\n\"\t\t\t\t\\\n-  \"\\tsc\" SUFFIX \"\\t%@,%1\\n\"\t\t\t\\\n-  \"\\tbeq%?\\t%@,%.,1b\\n\"\t\t\t\t\\\n-  \"\\tnop%-%]%>%)\\n\"\t\t\t\t\\\n-  \"2:\\n\"\n-\n-/* Return an asm string that atomically:\n-\n-     - Given that %2 contains a bit mask and %3 the inverted mask and\n-       that %4 and %5 have already been ANDed with %2.\n-\n-     - Compares the bits in memory reference %1 selected by mask %2 to\n-       register %4 and, if they are equal, changes the selected bits\n-       in memory to %5.\n-\n-     - Sets register %0 to the old value of memory reference %1.\n-\n-    OPS are the instructions needed to OR %5 with %@.  */\n-#define MIPS_COMPARE_AND_SWAP_12(OPS)\t\t\\\n-  \"%(%<%[%|1:\\tll\\t%0,%1\\n\"\t\t\t\\\n-  \"\\tand\\t%@,%0,%2\\n\"\t\t\t\t\\\n-  \"\\tbne\\t%@,%z4,2f\\n\"\t\t\t\t\\\n-  \"\\tand\\t%@,%0,%3\\n\"\t\t\t\t\\\n-  OPS\t\t\t\t\t\t\\\n-  \"\\tsc\\t%@,%1\\n\"\t\t\t\t\\\n-  \"\\tbeq%?\\t%@,%.,1b\\n\"\t\t\t\t\\\n-  \"\\tnop%-%]%>%)\\n\"\t\t\t\t\\\n-  \"2:\\n\"\n-\n-#define MIPS_COMPARE_AND_SWAP_12_ZERO_OP \"\"\n-#define MIPS_COMPARE_AND_SWAP_12_NONZERO_OP \"\\tor\\t%@,%@,%5\\n\"\n-\n-\n-/* Return an asm string that atomically:\n-\n-     - Sets memory reference %0 to %0 INSN %1.\n-\n-   SUFFIX is the suffix that should be added to \"ll\" and \"sc\"\n-   instructions.  */\n-#define MIPS_SYNC_OP(SUFFIX, INSN)\t\t\\\n-  \"%(%<%[%|1:\\tll\" SUFFIX \"\\t%@,%0\\n\"\t\t\\\n-  \"\\t\" INSN \"\\t%@,%@,%1\\n\"\t\t\t\\\n-  \"\\tsc\" SUFFIX \"\\t%@,%0\\n\"\t\t\t\\\n-  \"\\tbeq%?\\t%@,%.,1b\\n\"\t\t\t\t\\\n-  \"\\tnop%-%]%>%)\"\n-\n-/* Return an asm string that atomically:\n-\n-     - Given that %1 contains a bit mask and %2 the inverted mask and\n-       that %3 has already been ANDed with %1.\n-\n-     - Sets the selected bits of memory reference %0 to %0 INSN %3.\n-\n-     - Uses scratch register %4.\n-\n-    AND_OP is an instruction done after INSN to mask INSN's result\n-    with the mask.  For most operations, this is an AND with the\n-    inclusive mask (%1).  For nand operations -- where the result of\n-    INSN is already correctly masked -- it instead performs a bitwise\n-    not.  */\n-#define MIPS_SYNC_OP_12(INSN, AND_OP)\t\t\\\n-  \"%(%<%[%|1:\\tll\\t%4,%0\\n\"\t\t\t\\\n-  \"\\tand\\t%@,%4,%2\\n\"\t\t\t\t\\\n-  \"\\t\" INSN \"\\t%4,%4,%z3\\n\"\t\t\t\\\n-  AND_OP\t\t\t\t\t\\\n-  \"\\tor\\t%@,%@,%4\\n\"\t\t\t\t\\\n-  \"\\tsc\\t%@,%0\\n\"\t\t\t\t\\\n-  \"\\tbeq%?\\t%@,%.,1b\\n\"\t\t\t\t\\\n-  \"\\tnop%-%]%>%)\"\n-\n-#define MIPS_SYNC_OP_12_AND \"\\tand\\t%4,%4,%1\\n\"\n-#define MIPS_SYNC_OP_12_XOR \"\\txor\\t%4,%4,%1\\n\"\n-\n-/* Return an asm string that atomically:\n-\n-     - Given that %2 contains a bit mask and %3 the inverted mask and\n-       that %4 has already been ANDed with %2.\n-\n-     - Sets the selected bits of memory reference %1 to %1 INSN %4.\n-\n-     - Sets %0 to the original value of %1.\n-\n-     - Uses scratch register %5.\n-\n-    AND_OP is an instruction done after INSN to mask INSN's result\n-    with the mask.  For most operations, this is an AND with the\n-    inclusive mask (%1).  For nand operations -- where the result of\n-    INSN is already correctly masked -- it instead performs a bitwise\n-    not.  */\n-#define MIPS_SYNC_OLD_OP_12(INSN, AND_OP)\t\\\n-  \"%(%<%[%|1:\\tll\\t%0,%1\\n\"\t\t\t\\\n-  \"\\tand\\t%@,%0,%3\\n\"\t\t\t\t\\\n-  \"\\t\" INSN \"\\t%5,%0,%z4\\n\"\t\t\t\\\n-  AND_OP\t\t\t\t\t\\\n-  \"\\tor\\t%@,%@,%5\\n\"\t\t\t\t\\\n-  \"\\tsc\\t%@,%1\\n\"\t\t\t\t\\\n-  \"\\tbeq%?\\t%@,%.,1b\\n\"\t\t\t\t\\\n-  \"\\tnop%-%]%>%)\"\n-\n-#define MIPS_SYNC_OLD_OP_12_AND \"\\tand\\t%5,%5,%2\\n\"\n-#define MIPS_SYNC_OLD_OP_12_XOR \"\\txor\\t%5,%5,%2\\n\"\n-\n-/* Return an asm string that atomically:\n-\n-     - Given that %2 contains a bit mask and %3 the inverted mask and\n-       that %4 has already been ANDed with %2.\n-\n-     - Sets the selected bits of memory reference %1 to %1 INSN %4.\n-\n-     - Sets %0 to the new value of %1.\n-\n-    AND_OP is an instruction done after INSN to mask INSN's result\n-    with the mask.  For most operations, this is an AND with the\n-    inclusive mask (%1).  For nand operations -- where the result of\n-    INSN is already correctly masked -- it instead performs a bitwise\n-    not.  */\n-#define MIPS_SYNC_NEW_OP_12(INSN, AND_OP)\t\\\n-  \"%(%<%[%|1:\\tll\\t%0,%1\\n\"\t\t\t\t\\\n-  \"\\tand\\t%@,%0,%3\\n\"\t\t\t\t\\\n-  \"\\t\" INSN \"\\t%0,%0,%z4\\n\"\t\t\t\\\n-  AND_OP\t\t\t\t\t\\\n-  \"\\tor\\t%@,%@,%0\\n\"\t\t\t\t\\\n-  \"\\tsc\\t%@,%1\\n\"\t\t\t\t\\\n-  \"\\tbeq%?\\t%@,%.,1b\\n\"\t\t\t\t\\\n-  \"\\tnop%-%]%>%)\"\n-\n-#define MIPS_SYNC_NEW_OP_12_AND \"\\tand\\t%0,%0,%2\\n\"\n-#define MIPS_SYNC_NEW_OP_12_XOR \"\\txor\\t%0,%0,%2\\n\"\n-\n-/* Return an asm string that atomically:\n-\n-     - Sets memory reference %1 to %1 INSN %2.\n-\n-     - Sets register %0 to the old value of memory reference %1.\n-\n-   SUFFIX is the suffix that should be added to \"ll\" and \"sc\"\n-   instructions.  */\n-#define MIPS_SYNC_OLD_OP(SUFFIX, INSN)\t\t\\\n-  \"%(%<%[%|1:\\tll\" SUFFIX \"\\t%0,%1\\n\"\t\t\\\n-  \"\\t\" INSN \"\\t%@,%0,%2\\n\"\t\t\t\\\n-  \"\\tsc\" SUFFIX \"\\t%@,%1\\n\"\t\t\t\\\n-  \"\\tbeq%?\\t%@,%.,1b\\n\"\t\t\t\t\\\n-  \"\\tnop%-%]%>%)\"\n-\n-/* Return an asm string that atomically:\n-\n-     - Sets memory reference %1 to %1 INSN %2.\n-\n-     - Sets register %0 to the new value of memory reference %1.\n-\n-   SUFFIX is the suffix that should be added to \"ll\" and \"sc\"\n-   instructions.  */\n-#define MIPS_SYNC_NEW_OP(SUFFIX, INSN)\t\t\\\n-  \"%(%<%[%|1:\\tll\" SUFFIX \"\\t%0,%1\\n\"\t\t\\\n-  \"\\t\" INSN \"\\t%@,%0,%2\\n\"\t\t\t\\\n-  \"\\tsc\" SUFFIX \"\\t%@,%1\\n\"\t\t\t\\\n-  \"\\tbeq%?\\t%@,%.,1b%~\\n\"\t\t\t\\\n-  \"\\t\" INSN \"\\t%0,%0,%2%-%]%>%)\"\n-\n-/* Return an asm string that atomically:\n-\n-     - Sets memory reference %0 to ~(%0 AND %1).\n-\n-   SUFFIX is the suffix that should be added to \"ll\" and \"sc\"\n-   instructions.  INSN is the and instruction needed to and a register\n-   with %2.  */\n-#define MIPS_SYNC_NAND(SUFFIX, INSN)\t\t\\\n-  \"%(%<%[%|1:\\tll\" SUFFIX \"\\t%@,%0\\n\"\t\t\\\n-  \"\\t\" INSN \"\\t%@,%@,%1\\n\"\t\t\t\\\n-  \"\\tnor\\t%@,%@,%.\\n\"\t\t\t\t\\\n-  \"\\tsc\" SUFFIX \"\\t%@,%0\\n\"\t\t\t\\\n-  \"\\tbeq%?\\t%@,%.,1b\\n\"\t\t\t\t\\\n-  \"\\tnop%-%]%>%)\"\n-\n-/* Return an asm string that atomically:\n-\n-     - Sets memory reference %1 to ~(%1 AND %2).\n-\n-     - Sets register %0 to the old value of memory reference %1.\n-\n-   SUFFIX is the suffix that should be added to \"ll\" and \"sc\"\n-   instructions.  INSN is the and instruction needed to and a register\n-   with %2.  */\n-#define MIPS_SYNC_OLD_NAND(SUFFIX, INSN)\t\\\n-  \"%(%<%[%|1:\\tll\" SUFFIX \"\\t%0,%1\\n\"\t\t\t\\\n-  \"\\t\" INSN \"\\t%@,%0,%2\\n\"\t\t\t\\\n-  \"\\tnor\\t%@,%@,%.\\n\"\t\t\t\t\\\n-  \"\\tsc\" SUFFIX \"\\t%@,%1\\n\"\t\t\t\\\n-  \"\\tbeq%?\\t%@,%.,1b\\n\"\t\t\t\t\\\n-  \"\\tnop%-%]%>%)\"\n-\n-/* Return an asm string that atomically:\n-\n-     - Sets memory reference %1 to ~(%1 AND %2).\n-\n-     - Sets register %0 to the new value of memory reference %1.\n-\n-   SUFFIX is the suffix that should be added to \"ll\" and \"sc\"\n-   instructions.  INSN is the and instruction needed to and a register\n-   with %2.  */\n-#define MIPS_SYNC_NEW_NAND(SUFFIX, INSN)\t\\\n-  \"%(%<%[%|1:\\tll\" SUFFIX \"\\t%0,%1\\n\"\t\t\t\\\n-  \"\\t\" INSN \"\\t%0,%0,%2\\n\"\t\t\t\\\n-  \"\\tnor\\t%@,%0,%.\\n\"\t\t\t\t\\\n-  \"\\tsc\" SUFFIX \"\\t%@,%1\\n\"\t\t\t\\\n-  \"\\tbeq%?\\t%@,%.,1b%~\\n\"\t\t\t\\\n-  \"\\tnor\\t%0,%0,%.%-%]%>%)\"\n-\n-/* Return an asm string that atomically:\n-\n-     - Sets memory reference %1 to %2.\n-\n-     - Sets register %0 to the old value of memory reference %1.\n-\n-   SUFFIX is the suffix that should be added to \"ll\" and \"sc\"\n-   instructions.  OP is the and instruction that should be used to\n-   load %2 into a register.  */\n-#define MIPS_SYNC_EXCHANGE(SUFFIX, OP)\t\t\\\n-  \"%(%<%[%|\\n\"\t\t\t\t\t\\\n-  \"1:\\tll\" SUFFIX \"\\t%0,%1\\n\"\t\t\t\\\n-  \"\\t\" OP \"\\t%@,%2\\n\"\t\t\t\t\\\n-  \"\\tsc\" SUFFIX \"\\t%@,%1\\n\"\t\t\t\\\n-  \"\\tbeq%?\\t%@,%.,1b\\n\"\t\t\t\t\\\n-  \"\\tnop%-%]%>%)\"\n-\n-/* Return an asm string that atomically:\n-\n-     - Given that %2 contains an inclusive mask, %3 and exclusive mask\n-       and %4 has already been ANDed with the inclusive mask.\n-\n-     - Sets bits selected by the inclusive mask of memory reference %1\n-       to %4.\n-\n-     - Sets register %0 to the old value of memory reference %1.\n-\n-    OPS are the instructions needed to OR %4 with %@.\n-\n-    Operand %2 is unused, but needed as to give the test_and_set_12\n-    insn the five operands expected by the expander.  */\n-#define MIPS_SYNC_EXCHANGE_12(OPS)              \\\n-  \"%(%<%[%|\\n\"\t\t\t\t\t\\\n-  \"1:\\tll\\t%0,%1\\n\"\t\t\t\t\\\n-  \"\\tand\\t%@,%0,%3\\n\"\t\t\t\t\\\n-  OPS\t\t\t\t\t\t\\\n-  \"\\tsc\\t%@,%1\\n\"\t\t\t\t\\\n-  \"\\tbeq%?\\t%@,%.,1b\\n\"\t\t\t\t\\\n-  \"\\tnop%-%]%>%)\"\n-\n-#define MIPS_SYNC_EXCHANGE_12_ZERO_OP \"\"\n-#define MIPS_SYNC_EXCHANGE_12_NONZERO_OP \"\\tor\\t%@,%@,%4\\n\"\n-\n #ifndef USED_FOR_TARGET\n /* Information about \".set noFOO; ...; .set FOO\" blocks.  */\n struct mips_asm_switch {"}, {"sha": "a510e0a7b7445034cf5419bbe7fc65cd85c24d37", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5a62e9faca8d796f478f2c89f99c0e4784b4fb/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5a62e9faca8d796f478f2c89f99c0e4784b4fb/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=6f5a62e9faca8d796f478f2c89f99c0e4784b4fb", "patch": "@@ -449,6 +449,49 @@\n \t\t(const_string \"yes\")\n \t\t(const_string \"no\")))\n \n+;; Attributes describing a sync loop.  These loops have the form:\n+;;\n+;;       if (RELEASE_BARRIER == YES) sync\n+;;    1: OLDVAL = *MEM\n+;;       if ((OLDVAL & INCLUSIVE_MASK) != REQUIRED_OLDVAL) goto 2\n+;;       $TMP1 = OLDVAL & EXCLUSIVE_MASK\n+;;       $TMP2 = INSN1 (OLDVAL, INSN1_OP2)\n+;;       $TMP3 = INSN2 ($TMP2, INCLUSIVE_MASK)\n+;;       $AT |= $TMP1 | $TMP3\n+;;       if (!commit (*MEM = $AT)) goto 1.\n+;;         if (INSN1 != MOVE && INSN1 != LI) NEWVAL = $TMP3 [delay slot]\n+;;       sync\n+;;    2:\n+;;\n+;; where \"$\" values are temporaries and where the other values are\n+;; specified by the attributes below.  Values are specified as operand\n+;; numbers and insns are specified as enums.  If no operand number is\n+;; specified, the following values are used instead:\n+;;\n+;;    - OLDVAL: $AT\n+;;    - NEWVAL: $AT\n+;;    - INCLUSIVE_MASK: -1\n+;;    - REQUIRED_OLDVAL: OLDVAL & INCLUSIVE_MASK\n+;;    - EXCLUSIVE_MASK: 0\n+;;\n+;; MEM and INSN1_OP2 are required.\n+;;\n+;; Ideally, the operand attributes would be integers, with -1 meaning \"none\",\n+;; but the gen* programs don't yet support that.\n+(define_attr \"sync_mem\" \"none,0,1,2,3,4,5\" (const_string \"none\"))\n+(define_attr \"sync_oldval\" \"none,0,1,2,3,4,5\" (const_string \"none\"))\n+(define_attr \"sync_newval\" \"none,0,1,2,3,4,5\" (const_string \"none\"))\n+(define_attr \"sync_inclusive_mask\" \"none,0,1,2,3,4,5\" (const_string \"none\"))\n+(define_attr \"sync_exclusive_mask\" \"none,0,1,2,3,4,5\" (const_string \"none\"))\n+(define_attr \"sync_required_oldval\" \"none,0,1,2,3,4,5\" (const_string \"none\"))\n+(define_attr \"sync_insn1_op2\" \"none,0,1,2,3,4,5\" (const_string \"none\"))\n+(define_attr \"sync_insn1\" \"move,li,addu,addiu,subu,and,andi,or,ori,xor,xori\"\n+  (const_string \"move\"))\n+(define_attr \"sync_insn2\" \"nop,and,xor,not\"\n+  (const_string \"nop\"))\n+(define_attr \"sync_release_barrier\" \"yes,no\"\n+  (const_string \"yes\"))\n+\n ;; Length of instruction in bytes.\n (define_attr \"length\" \"\"\n    (cond [(and (eq_attr \"extended_mips16\" \"yes\")\n@@ -572,6 +615,9 @@\n \n \t  (eq_attr \"type\" \"idiv,idiv3\")\n \t  (symbol_ref \"mips_idiv_insns () * 4\")\n+\n+\t  (not (eq_attr \"sync_mem\" \"none\"))\n+\t  (symbol_ref \"mips_sync_loop_insns (insn, operands) * 4\")\n \t  ] (const_int 4)))\n \n ;; Attribute describing the processor.  This attribute must match exactly\n@@ -4826,7 +4872,7 @@\n (define_insn \"sync\"\n   [(unspec_volatile [(const_int 0)] UNSPEC_SYNC)]\n   \"GENERATE_SYNC\"\n-  \"%|sync%-\")\n+  { return mips_output_sync (); })\n \n (define_insn \"synci\"\n   [(unspec_volatile [(match_operand 0 \"pmode_register_operand\" \"d\")]"}, {"sha": "e28f56c601a9a149ccbb209ec17f8813ec542ccd", "filename": "gcc/config/mips/sync.md", "status": "modified", "additions": 152, "deletions": 169, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5a62e9faca8d796f478f2c89f99c0e4784b4fb/gcc%2Fconfig%2Fmips%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5a62e9faca8d796f478f2c89f99c0e4784b4fb/gcc%2Fconfig%2Fmips%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsync.md?ref=6f5a62e9faca8d796f478f2c89f99c0e4784b4fb", "patch": "@@ -40,7 +40,7 @@\n   [(set (match_operand:BLK 0 \"\" \"\")\n \t(unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))]\n   \"GENERATE_SYNC\"\n-  \"%|sync%-\")\n+  { return mips_output_sync (); })\n \n (define_insn \"sync_compare_and_swap<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n@@ -50,15 +50,12 @@\n \t\t\t      (match_operand:GPR 3 \"arith_operand\" \"I,d\")]\n \t UNSPEC_COMPARE_AND_SWAP))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop;\n-  if (which_alternative == 0)\n-    loop = MIPS_COMPARE_AND_SWAP (\"<d>\", \"li\");\n-  else\n-    loop = MIPS_COMPARE_AND_SWAP (\"<d>\", \"move\");\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"32\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"li,move\")\n+   (set_attr \"sync_oldval\" \"0\")\n+   (set_attr \"sync_mem\" \"1\")\n+   (set_attr \"sync_required_oldval\" \"2\")\n+   (set_attr \"sync_insn1_op2\" \"3\")])\n \n (define_expand \"sync_compare_and_swap<mode>\"\n   [(match_operand:SHORT 0 \"register_operand\")\n@@ -85,15 +82,13 @@\n \t\t\t     (match_operand:SI 5 \"reg_or_0_operand\" \"d,J\")]\n \t\t\t    UNSPEC_COMPARE_AND_SWAP_12))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop;\n-  if (which_alternative == 0)\n-    loop = MIPS_COMPARE_AND_SWAP_12 (MIPS_COMPARE_AND_SWAP_12_NONZERO_OP);\n-  else\n-    loop = MIPS_COMPARE_AND_SWAP_12 (MIPS_COMPARE_AND_SWAP_12_ZERO_OP);\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"40,36\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_oldval\" \"0\")\n+   (set_attr \"sync_mem\" \"1\")\n+   (set_attr \"sync_inclusive_mask\" \"2\")\n+   (set_attr \"sync_exclusive_mask\" \"3\")\n+   (set_attr \"sync_required_oldval\" \"4\")\n+   (set_attr \"sync_insn1_op2\" \"5\")])\n \n (define_insn \"sync_add<mode>\"\n   [(set (match_operand:GPR 0 \"memory_operand\" \"+R,R\")\n@@ -102,15 +97,10 @@\n \t\t     (match_operand:GPR 1 \"arith_operand\" \"I,d\"))]\n \t  UNSPEC_SYNC_OLD_OP))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop;\n-  if (which_alternative == 0)\n-    loop = MIPS_SYNC_OP (\"<d>\", \"<d>addiu\");\n-  else\n-    loop = MIPS_SYNC_OP (\"<d>\", \"<d>addu\");\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"28\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"addiu,addu\")\n+   (set_attr \"sync_mem\" \"0\")\n+   (set_attr \"sync_insn1_op2\" \"1\")])\n \n (define_expand \"sync_<optab><mode>\"\n   [(set (match_operand:SHORT 0 \"memory_operand\")\n@@ -138,11 +128,15 @@\n \t  UNSPEC_SYNC_OLD_OP_12))\n    (clobber (match_scratch:SI 4 \"=&d\"))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop = MIPS_SYNC_OP_12 (\"<insn>\", MIPS_SYNC_OP_12_AND);\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"40\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"<insn>\")\n+   (set_attr \"sync_insn2\" \"and\")\n+   (set_attr \"sync_mem\" \"0\")\n+   (set_attr \"sync_inclusive_mask\" \"1\")\n+   (set_attr \"sync_exclusive_mask\" \"2\")\n+   (set_attr \"sync_insn1_op2\" \"3\")\n+   (set_attr \"sync_oldval\" \"4\")\n+   (set_attr \"sync_newval\" \"4\")])\n \n (define_expand \"sync_old_<optab><mode>\"\n   [(parallel [\n@@ -175,11 +169,15 @@\n \t  UNSPEC_SYNC_OLD_OP_12))\n    (clobber (match_scratch:SI 5 \"=&d\"))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop = MIPS_SYNC_OLD_OP_12 (\"<insn>\", MIPS_SYNC_OLD_OP_12_AND);\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"40\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"<insn>\")\n+   (set_attr \"sync_insn2\" \"and\")\n+   (set_attr \"sync_oldval\" \"0\")\n+   (set_attr \"sync_mem\" \"1\")\n+   (set_attr \"sync_inclusive_mask\" \"2\")\n+   (set_attr \"sync_exclusive_mask\" \"3\")\n+   (set_attr \"sync_insn1_op2\" \"4\")\n+   (set_attr \"sync_newval\" \"5\")])\n \n (define_expand \"sync_new_<optab><mode>\"\n   [(parallel [\n@@ -217,11 +215,15 @@\n \t   (match_dup 3)\n \t   (match_dup 4)] UNSPEC_SYNC_NEW_OP_12))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop = MIPS_SYNC_NEW_OP_12 (\"<insn>\", MIPS_SYNC_NEW_OP_12_AND);\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"40\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"<insn>\")\n+   (set_attr \"sync_insn2\" \"and\")\n+   (set_attr \"sync_oldval\" \"0\")\n+   (set_attr \"sync_newval\" \"0\")\n+   (set_attr \"sync_mem\" \"1\")\n+   (set_attr \"sync_inclusive_mask\" \"2\")\n+   (set_attr \"sync_exclusive_mask\" \"3\")\n+   (set_attr \"sync_insn1_op2\" \"4\")])\n \n (define_expand \"sync_nand<mode>\"\n   [(set (match_operand:SHORT 0 \"memory_operand\")\n@@ -249,11 +251,15 @@\n \t  UNSPEC_SYNC_OLD_OP_12))\n    (clobber (match_scratch:SI 4 \"=&d\"))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop = MIPS_SYNC_OP_12 (\"and\", MIPS_SYNC_OP_12_XOR);\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"40\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"and\")\n+   (set_attr \"sync_insn2\" \"xor\")\n+   (set_attr \"sync_mem\" \"0\")\n+   (set_attr \"sync_inclusive_mask\" \"1\")\n+   (set_attr \"sync_exclusive_mask\" \"2\")\n+   (set_attr \"sync_insn1_op2\" \"3\")\n+   (set_attr \"sync_oldval\" \"4\")\n+   (set_attr \"sync_newval\" \"4\")])\n \n (define_expand \"sync_old_nand<mode>\"\n   [(parallel [\n@@ -284,11 +290,15 @@\n \t  UNSPEC_SYNC_OLD_OP_12))\n    (clobber (match_scratch:SI 5 \"=&d\"))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop = MIPS_SYNC_OLD_OP_12 (\"and\", MIPS_SYNC_OLD_OP_12_XOR);\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"40\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"and\")\n+   (set_attr \"sync_insn2\" \"xor\")\n+   (set_attr \"sync_oldval\" \"0\")\n+   (set_attr \"sync_mem\" \"1\")\n+   (set_attr \"sync_inclusive_mask\" \"2\")\n+   (set_attr \"sync_exclusive_mask\" \"3\")\n+   (set_attr \"sync_insn1_op2\" \"4\")\n+   (set_attr \"sync_newval\" \"5\")])\n \n (define_expand \"sync_new_nand<mode>\"\n   [(parallel [\n@@ -324,24 +334,27 @@\n \t   (match_dup 3)\n \t   (match_dup 4)] UNSPEC_SYNC_NEW_OP_12))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop = MIPS_SYNC_NEW_OP_12 (\"and\", MIPS_SYNC_NEW_OP_12_XOR);\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"40\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"and\")\n+   (set_attr \"sync_insn2\" \"xor\")\n+   (set_attr \"sync_oldval\" \"0\")\n+   (set_attr \"sync_newval\" \"0\")\n+   (set_attr \"sync_mem\" \"1\")\n+   (set_attr \"sync_inclusive_mask\" \"2\")\n+   (set_attr \"sync_exclusive_mask\" \"3\")\n+   (set_attr \"sync_insn1_op2\" \"4\")])\n \n (define_insn \"sync_sub<mode>\"\n   [(set (match_operand:GPR 0 \"memory_operand\" \"+R\")\n \t(unspec_volatile:GPR\n           [(minus:GPR (match_dup 0)\n-\t\t\t      (match_operand:GPR 1 \"register_operand\" \"d\"))]\n+\t\t      (match_operand:GPR 1 \"register_operand\" \"d\"))]\n \t UNSPEC_SYNC_OLD_OP))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop = MIPS_SYNC_OP (\"<d>\", \"<d>subu\");\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"28\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"subu\")\n+   (set_attr \"sync_mem\" \"0\")\n+   (set_attr \"sync_insn1_op2\" \"1\")])\n \n (define_insn \"sync_old_add<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n@@ -352,15 +365,11 @@\n \t\t     (match_operand:GPR 2 \"arith_operand\" \"I,d\"))]\n \t UNSPEC_SYNC_OLD_OP))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop;\n-  if (which_alternative == 0)\n-    loop = MIPS_SYNC_OLD_OP (\"<d>\", \"<d>addiu\");\n-  else\n-    loop = MIPS_SYNC_OLD_OP (\"<d>\", \"<d>addu\");\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"28\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"addiu,addu\")\n+   (set_attr \"sync_oldval\" \"0\")\n+   (set_attr \"sync_mem\" \"1\")\n+   (set_attr \"sync_insn1_op2\" \"2\")])\n \n (define_insn \"sync_old_sub<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d\")\n@@ -371,11 +380,11 @@\n \t\t      (match_operand:GPR 2 \"register_operand\" \"d\"))]\n \t UNSPEC_SYNC_OLD_OP))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop = MIPS_SYNC_OLD_OP (\"<d>\", \"<d>subu\");\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"28\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"subu\")\n+   (set_attr \"sync_oldval\" \"0\")\n+   (set_attr \"sync_mem\" \"1\")\n+   (set_attr \"sync_insn1_op2\" \"2\")])\n \n (define_insn \"sync_new_add<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n@@ -386,15 +395,12 @@\n \t  [(plus:GPR (match_dup 1) (match_dup 2))]\n \t UNSPEC_SYNC_NEW_OP))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop;\n-  if (which_alternative == 0)\n-    loop = MIPS_SYNC_NEW_OP (\"<d>\", \"<d>addiu\");\n-  else\n-    loop = MIPS_SYNC_NEW_OP (\"<d>\", \"<d>addu\");\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"28\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"addiu,addu\")\n+   (set_attr \"sync_oldval\" \"0\")\n+   (set_attr \"sync_newval\" \"0\")\n+   (set_attr \"sync_mem\" \"1\")\n+   (set_attr \"sync_insn1_op2\" \"2\")])\n \n (define_insn \"sync_new_sub<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d\")\n@@ -405,11 +411,12 @@\n \t  [(minus:GPR (match_dup 1) (match_dup 2))]\n \t UNSPEC_SYNC_NEW_OP))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop = MIPS_SYNC_NEW_OP (\"<d>\", \"<d>subu\");\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"28\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"subu\")\n+   (set_attr \"sync_oldval\" \"0\")\n+   (set_attr \"sync_newval\" \"0\")\n+   (set_attr \"sync_mem\" \"1\")\n+   (set_attr \"sync_insn1_op2\" \"2\")])\n \n (define_insn \"sync_<optab><mode>\"\n   [(set (match_operand:GPR 0 \"memory_operand\" \"+R,R\")\n@@ -418,15 +425,10 @@\n \t\t\t      (match_dup 0))]\n \t UNSPEC_SYNC_OLD_OP))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop;\n-  if (which_alternative == 0)\n-    loop = MIPS_SYNC_OP (\"<d>\", \"<immediate_insn>\");\n-  else\n-    loop = MIPS_SYNC_OP (\"<d>\", \"<insn>\");\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"28\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"<immediate_insn>,<insn>\")\n+   (set_attr \"sync_mem\" \"0\")\n+   (set_attr \"sync_insn1_op2\" \"1\")])\n \n (define_insn \"sync_old_<optab><mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n@@ -437,15 +439,11 @@\n \t\t\t    (match_dup 1))]\n \t UNSPEC_SYNC_OLD_OP))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop;\n-  if (which_alternative == 0)\n-    loop = MIPS_SYNC_OLD_OP (\"<d>\", \"<immediate_insn>\");\n-  else\n-    loop = MIPS_SYNC_OLD_OP (\"<d>\", \"<insn>\");\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"28\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"<immediate_insn>,<insn>\")\n+   (set_attr \"sync_oldval\" \"0\")\n+   (set_attr \"sync_mem\" \"1\")\n+   (set_attr \"sync_insn1_op2\" \"2\")])\n \n (define_insn \"sync_new_<optab><mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n@@ -456,30 +454,23 @@\n \t\t\t    (match_dup 1))]\n \t UNSPEC_SYNC_NEW_OP))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop;\n-  if (which_alternative == 0)\n-    loop = MIPS_SYNC_NEW_OP (\"<d>\", \"<immediate_insn>\");\n-  else\n-    loop = MIPS_SYNC_NEW_OP (\"<d>\", \"<insn>\");\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"28\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"<immediate_insn>,<insn>\")\n+   (set_attr \"sync_oldval\" \"0\")\n+   (set_attr \"sync_newval\" \"0\")\n+   (set_attr \"sync_mem\" \"1\")\n+   (set_attr \"sync_insn1_op2\" \"2\")])\n \n (define_insn \"sync_nand<mode>\"\n   [(set (match_operand:GPR 0 \"memory_operand\" \"+R,R\")\n \t(unspec_volatile:GPR [(match_operand:GPR 1 \"uns_arith_operand\" \"K,d\")]\n \t UNSPEC_SYNC_OLD_OP))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop;\n-  if (which_alternative == 0)\n-    loop = MIPS_SYNC_NAND (\"<d>\", \"andi\");\n-  else\n-    loop = MIPS_SYNC_NAND (\"<d>\", \"and\");\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"32\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"andi,and\")\n+   (set_attr \"sync_insn2\" \"not\")\n+   (set_attr \"sync_mem\" \"0\")\n+   (set_attr \"sync_insn1_op2\" \"1\")])\n \n (define_insn \"sync_old_nand<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n@@ -488,15 +479,12 @@\n         (unspec_volatile:GPR [(match_operand:GPR 2 \"uns_arith_operand\" \"K,d\")]\n \t UNSPEC_SYNC_OLD_OP))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop;\n-  if (which_alternative == 0)\n-    loop = MIPS_SYNC_OLD_NAND (\"<d>\", \"andi\");\n-  else\n-    loop = MIPS_SYNC_OLD_NAND (\"<d>\", \"and\");\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"32\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"andi,and\")\n+   (set_attr \"sync_insn2\" \"not\")\n+   (set_attr \"sync_oldval\" \"0\")\n+   (set_attr \"sync_mem\" \"1\")\n+   (set_attr \"sync_insn1_op2\" \"2\")])\n \n (define_insn \"sync_new_nand<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n@@ -505,15 +493,13 @@\n \t(unspec_volatile:GPR [(match_operand:GPR 2 \"uns_arith_operand\" \"K,d\")]\n \t UNSPEC_SYNC_NEW_OP))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop;\n-  if (which_alternative == 0)\n-    loop = MIPS_SYNC_NEW_NAND (\"<d>\", \"andi\");\n-  else\n-    loop = MIPS_SYNC_NEW_NAND (\"<d>\", \"and\");\n-  return mips_output_sync_loop (true, loop, operands);\n-}\n-  [(set_attr \"length\" \"32\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"andi,and\")\n+   (set_attr \"sync_insn2\" \"not\")\n+   (set_attr \"sync_oldval\" \"0\")\n+   (set_attr \"sync_newval\" \"0\")\n+   (set_attr \"sync_mem\" \"1\")\n+   (set_attr \"sync_insn1_op2\" \"2\")])\n \n (define_insn \"sync_lock_test_and_set<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n@@ -522,15 +508,12 @@\n \t(unspec_volatile:GPR [(match_operand:GPR 2 \"arith_operand\" \"I,d\")]\n \t UNSPEC_SYNC_EXCHANGE))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop;\n-  if (which_alternative == 0)\n-    loop = MIPS_SYNC_EXCHANGE (\"<d>\", \"li\");\n-  else\n-    loop = MIPS_SYNC_EXCHANGE (\"<d>\", \"move\");\n-  return mips_output_sync_loop (false, loop, operands);\n-}\n-  [(set_attr \"length\" \"24\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_release_barrier\" \"no\")\n+   (set_attr \"sync_insn1\" \"li,move\")\n+   (set_attr \"sync_oldval\" \"0\")\n+   (set_attr \"sync_mem\" \"1\")\n+   (set_attr \"sync_insn1_op2\" \"2\")])\n \n (define_expand \"sync_lock_test_and_set<mode>\"\n   [(match_operand:SHORT 0 \"register_operand\")\n@@ -546,20 +529,20 @@\n })\n \n (define_insn \"test_and_set_12\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&d,&d\")\n-\t(match_operand:SI 1 \"memory_operand\" \"+R,R\"))\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n+\t(match_operand:SI 1 \"memory_operand\" \"+R\"))\n    (set (match_dup 1)\n-\t(unspec_volatile:SI [(match_operand:SI 2 \"register_operand\" \"d,d\")\n-\t\t\t     (match_operand:SI 3 \"register_operand\" \"d,d\")\n-\t\t\t     (match_operand:SI 4 \"arith_operand\" \"d,J\")]\n+\t(unspec_volatile:SI [(match_operand:SI 2 \"register_operand\" \"d\")\n+\t\t\t     (match_operand:SI 3 \"register_operand\" \"d\")\n+\t\t\t     (match_operand:SI 4 \"arith_operand\" \"dJ\")]\n \t  UNSPEC_SYNC_EXCHANGE_12))]\n   \"GENERATE_LL_SC\"\n-{\n-  const char *loop;\n-  if (which_alternative == 0)\n-    loop = MIPS_SYNC_EXCHANGE_12 (MIPS_SYNC_EXCHANGE_12_NONZERO_OP);\n-  else\n-    loop = MIPS_SYNC_EXCHANGE_12 (MIPS_SYNC_EXCHANGE_12_ZERO_OP);\n-  return mips_output_sync_loop (false, loop, operands);\n-}\n-  [(set_attr \"length\" \"28,24\")])\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_release_barrier\" \"no\")\n+   (set_attr \"sync_oldval\" \"0\")\n+   (set_attr \"sync_mem\" \"1\")\n+   ;; Unused, but needed to give the number of operands expected by\n+   ;; the expander.\n+   (set_attr \"sync_inclusive_mask\" \"2\")\n+   (set_attr \"sync_exclusive_mask\" \"3\")\n+   (set_attr \"sync_insn1_op2\" \"4\")])"}]}