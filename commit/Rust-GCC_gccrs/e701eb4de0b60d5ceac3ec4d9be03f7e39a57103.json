{"sha": "e701eb4de0b60d5ceac3ec4d9be03f7e39a57103", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTcwMWViNGRlMGI2MGQ1Y2VhYzNlYzRkOWJlMDNmN2UzOWE1NzEwMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1997-12-04T09:41:38Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-12-04T09:41:38Z"}, "message": "./:\t* libgcc2.c (__throw): Use __builtin_return_addr instead of __eh_pc.\n\n\t* except.c: Lose outer_context_label_stack.\n \t(expand_eh_region_end): Rethrow from outer_context here.\n\t(expand_fixup_region_end): Let expand_eh_region_end do the rethrow.\n\t(expand_internal_throw): Take no args.\n\t(expand_internal_throw_indirect): Lose.\n\t(expand_leftover_cleanups, expand_start_all_catch): Use expand_rethrow.\n\t(expand_start_all_catch): Start a rethrow region.\n\t(expand_end_all_catch): End it.\n\t(expand_rethrow): New fn.\n\t* except.h: Reflect above changes.\n\ncp/:\t* except.c (expand_end_catch_block): Lose rethrow region.\n\t(expand_start_catch_block): Likewise.\n\t(expand_end_catch_block): Don't expand_leftover_cleanups.\n\nFrom-SVN: r16937", "tree": {"sha": "952b95458e119610c40fb72e6d852f3a40843ba5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/952b95458e119610c40fb72e6d852f3a40843ba5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103/comments", "author": null, "committer": null, "parents": [{"sha": "a1e343dd7a3f537a038c3903264fa41f9c4df29d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1e343dd7a3f537a038c3903264fa41f9c4df29d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1e343dd7a3f537a038c3903264fa41f9c4df29d"}], "stats": {"total": 291, "additions": 109, "deletions": 182}, "files": [{"sha": "c497a759440baedac0bf0e25411a1c0488777d0d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e701eb4de0b60d5ceac3ec4d9be03f7e39a57103", "patch": "@@ -1,3 +1,18 @@\n+Wed Dec  3 12:01:56 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* libgcc2.c (__throw): Use __builtin_return_addr instead of __eh_pc.\n+\t* except.c: Lose outer_context_label_stack.\n+ \t(expand_eh_region_end): Rethrow from outer_context here.\n+\t(expand_fixup_region_end): Let expand_eh_region_end do the rethrow.\n+\t(expand_internal_throw): Take no args.\n+\t(expand_internal_throw_indirect): Lose.\n+\t(expand_leftover_cleanups, expand_start_all_catch): Use expand_rethrow.\n+\t(expand_start_all_catch): Start a rethrow region.\n+\t(expand_end_all_catch): End it.\n+\t(expand_rethrow): New fn.\n+\t* except.h: Reflect above changes.\n+\t* flow.c: Revert change of Nov 27.\n+\n Thu Dec  4 00:24:09 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* i386/t-sol2 (CRTSTUFF_T_CFLAGS): Turn on the optimizer."}, {"sha": "e1fe81241ad5d8c495139c27056ca8b0b627fb0c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e701eb4de0b60d5ceac3ec4d9be03f7e39a57103", "patch": "@@ -280,7 +280,7 @@ LIBGCC2 = libgcc2.a\n #\n # -fexceptions is necessary for eh.o now that the exceptions are\n # the default for g++ only.\n-LIBGCC2_DEBUG_CFLAGS = -g1\n+LIBGCC2_DEBUG_CFLAGS = -g\n LIBGCC2_CFLAGS = -O2 $(LIBGCC2_INCLUDES) $(GCC_CFLAGS) $(TARGET_LIBGCC2_CFLAGS) $(LIBGCC2_DEBUG_CFLAGS) -DIN_LIBGCC2 -D__GCC_FLOAT_NOT_NEEDED -fexceptions @inhibit_libc@ \n \n # Additional options to use when compiling libgcc2.a."}, {"sha": "6b9737d6291a46458c032df08ced82209a2bdb35", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e701eb4de0b60d5ceac3ec4d9be03f7e39a57103", "patch": "@@ -1,3 +1,9 @@\n+Wed Dec  3 20:02:39 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* except.c (expand_end_catch_block): Lose rethrow region.\n+\t(expand_start_catch_block): Likewise.\n+\t(expand_end_catch_block): Don't expand_leftover_cleanups.\n+\n Wed Dec  3 13:24:04 1997  Benjamin Kosnik  <bkoz@rhino.cygnus.com>\n \n \t* pt.c (tsubst): Remove tree_cons call (places redundant info into"}, {"sha": "194c17d5e7f335486ff0f5cebfe4d14dfbe3443e", "filename": "gcc/cp/except.c", "status": "modified", "additions": 6, "deletions": 48, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=e701eb4de0b60d5ceac3ec4d9be03f7e39a57103", "patch": "@@ -185,10 +185,13 @@ static tree Unwind;\n \n    ========================================================================= */\n \n+#ifndef DWARF2_UNWIND_INFO\n /* Holds the pc for doing \"throw\" */\n static tree saved_pc;\n \n extern int throw_used;\n+#endif\n+\n extern rtx catch_clauses;\n extern tree const_ptr_type_node;\n \n@@ -255,12 +258,14 @@ init_exception_processing ()\n \n   pop_lang_context ();\n \n+#ifndef DWARF2_UNWIND_INFO\n   d = build_decl (VAR_DECL, get_identifier (\"__eh_pc\"), ptr_type_node);\n   TREE_PUBLIC (d) = 1;\n   DECL_EXTERNAL (d) = 1;\n   DECL_ARTIFICIAL (d) = 1;\n   cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n   saved_pc = d;\n+#endif\n \n   /* If we use setjmp/longjmp EH, arrange for all cleanup actions to\n      be protected with __terminate.  */\n@@ -520,17 +525,6 @@ expand_start_catch_block (declspecs, declarator)\n   if (! doing_eh (1))\n     return;\n \n-  /* If we are not doing setjmp/longjmp EH, because we are reordered\n-     out of line, we arrange to rethrow in the outer context so as to\n-     skip through the terminate region we are nested in, should we\n-     encounter an exception in the catch handler.  We also need to do\n-     this because we are not physically within the try block, if any,\n-     that contains this catch block.\n-\n-     Matches the end in expand_end_catch_block.  */\n-  if (! exceptions_via_longjmp)\n-    expand_eh_region_start ();\n-\n   /* Create a binding level for the eh_info and the exception object\n      cleanup.  */\n   pushlevel (0);\n@@ -655,36 +649,11 @@ expand_end_catch_block ()\n   expand_end_bindings (getdecls (), kept_level_p (), 0);\n   poplevel (kept_level_p (), 1, 0);\n \n-  if (! exceptions_via_longjmp)\n-    {\n-      /* If we are not doing setjmp/longjmp EH, we need an extra\n-\t region around the whole catch block to skip through the\n-\t terminate region we are nested in.  */\n-\n-      tree t = make_node (RTL_EXPR);\n-      TREE_TYPE (t) = void_type_node;\n-      RTL_EXPR_RTL (t) = const0_rtx;\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      do_pending_stack_adjust ();\n-      start_sequence_for_rtl_expr (t);\n-\n-      expand_internal_throw (outer_context_label_stack->u.rlabel);\n-\n-      do_pending_stack_adjust ();\n-      RTL_EXPR_SEQUENCE (t) = get_insns ();\n-      end_sequence ();\n-\n-      /* For the rethrow region.  */\n-      expand_eh_region_end (t);\n-    }\n-\n   /* Fall to outside the try statement when done executing handler and\n      we fall off end of handler.  This is jump Lresume in the\n      documentation.  */\n   expand_goto (top_label_entry (&caught_return_label_stack));\n \n-  expand_leftover_cleanups ();\n-\n   /* label we emit to jump to if this catch block didn't match.  */\n   /* This the closing } in the `if (eq) {' of the documentation.  */\n   emit_label (pop_label_entry (&false_label_stack));\n@@ -1318,18 +1287,7 @@ expand_throw (exp)\n       expand_expr (exp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n \n-  if (exceptions_via_longjmp)\n-    emit_throw ();\n-  else\n-    {\n-      /* This is the label that represents where in the code we were, when\n-\t we got an exception.  This needs to be updated when we rethrow an\n-\t exception, so that the matching routine knows to search out.  */\n-      label = gen_label_rtx ();\n-      emit_label (label);\n-\n-      expand_internal_throw (label);\n-    }\n+  expand_internal_throw ();\n }\n \n /* Build a throw expression.  */"}, {"sha": "c37f89d9087d4f2add0a6ebf5d8c322800a1f6cc", "filename": "gcc/except.c", "status": "modified", "additions": 74, "deletions": 104, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=e701eb4de0b60d5ceac3ec4d9be03f7e39a57103", "patch": "@@ -417,7 +417,7 @@ int asynchronous_exceptions = 0;\n /* One to protect cleanup actions with a handler that calls\n    __terminate, zero otherwise.  */\n \n-int protect_cleanup_actions_with_terminate = 0;\n+int protect_cleanup_actions_with_terminate;\n \n /* A list of labels used for exception handlers.  Created by\n    find_exception_handler_labels for the optimization passes.  */\n@@ -487,21 +487,20 @@ static tree protect_list;\n \n struct label_node *caught_return_label_stack = NULL;\n \n-/* Keeps track of the label used as the context of a throw to rethrow an\n-   exception to the outer exception region.  */\n-\n-struct label_node *outer_context_label_stack = NULL;\n-\n /* A random data area for the front end's own use.  */\n \n struct label_node *false_label_stack = NULL;\n \n+#ifndef DWARF2_UNWIND_INFO\n /* The rtx and the tree for the saved PC value.  */\n \n rtx eh_saved_pc_rtx;\n tree eh_saved_pc;\n+#endif\n \n rtx expand_builtin_return_addr\tPROTO((enum built_in_function, int, rtx));\n+static void expand_rethrow\tPROTO((rtx));\n+\n \f\n /* Various support routines to manipulate the various data structures\n    used by the exception handling code.  */\n@@ -1097,7 +1096,9 @@ expand_eh_region_end (handler)\n   note = emit_note (NULL_PTR, NOTE_INSN_EH_REGION_END);\n   NOTE_BLOCK_NUMBER (note)\n     = CODE_LABEL_NUMBER (entry->exception_handler_label);\n-  if (exceptions_via_longjmp == 0)\n+  if (exceptions_via_longjmp == 0\n+      /* We share outer_context between regions; only emit it once.  */\n+      && INSN_UID (entry->outer_context) == 0)\n     {\n       rtx label;\n \n@@ -1107,14 +1108,8 @@ expand_eh_region_end (handler)\n       /* Emit a label marking the end of this exception region that\n \t is used for rethrowing into the outer context.  */\n       emit_label (entry->outer_context);\n+      expand_internal_throw ();\n \n-      /* Put in something that takes up space, as otherwise the end\n-\t address for this EH region could have the exact same address as\n-\t its outer region. This would cause us to miss the fact that\n-\t resuming exception handling with this PC value would be inside\n-\t the outer region.  */\n-      emit_insn (gen_nop ());\n-      emit_barrier ();\n       emit_label (label);\n     }\n \n@@ -1159,9 +1154,7 @@ void\n expand_fixup_region_end (cleanup)\n      tree cleanup;\n {\n-  tree t;\n   struct eh_node *node;\n-  int yes;\n \n   if (! doing_eh (0) || exceptions_via_longjmp)\n     return;\n@@ -1174,20 +1167,10 @@ expand_fixup_region_end (cleanup)\n   if (node == 0)\n     abort ();\n \n-  yes = suspend_momentary ();\n-\n-  t = build (RTL_EXPR, void_type_node, NULL_RTX, const0_rtx);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  do_pending_stack_adjust ();\n-  start_sequence_for_rtl_expr (t);\n-  expand_internal_throw (node->entry->outer_context);\n-  do_pending_stack_adjust ();\n-  RTL_EXPR_SEQUENCE (t) = get_insns ();\n-  end_sequence ();\n+  ehstack.top->entry->outer_context = node->entry->outer_context;\n \n-  resume_momentary (yes);\n-\n-  expand_eh_region_end (t);\n+  /* Just rethrow.  size_zero_node is just a NOP.  */\n+  expand_eh_region_end (size_zero_node);\n }\n \n /* If we are using the setjmp/longjmp EH codegen method, we emit a\n@@ -1225,27 +1208,23 @@ emit_throw ()\n   emit_barrier ();\n }\n \n-/* An internal throw with an indirect CONTEXT we want to throw from.\n-   CONTEXT evaluates to the context of the throw.  */\n-\n-static void\n-expand_internal_throw_indirect (context)\n-     rtx context;\n-{\n-  assemble_external (eh_saved_pc);\n-  emit_move_insn (eh_saved_pc_rtx, context);\n-  emit_throw ();\n-}\n-\n-/* An internal throw with a direct CONTEXT we want to throw from.\n-   CONTEXT must be a label; its address will be used as the context of\n-   the throw.  */\n+/* Throw the current exception.  If appropriate, this is done by jumping\n+   to the next handler.  */\n \n void\n-expand_internal_throw (context)\n-     rtx context;\n+expand_internal_throw ()\n {\n-  expand_internal_throw_indirect (gen_rtx (LABEL_REF, Pmode, context));\n+#ifndef DWARF2_UNWIND_INFO\n+  if (! exceptions_via_longjmp)\n+    {\n+      rtx label = gen_label_rtx ();\n+      emit_label (label);\n+      label = gen_rtx (LABEL_REF, Pmode, label);\n+      assemble_external (eh_saved_pc);\n+      emit_move_insn (eh_saved_pc_rtx, label);\n+    }\n+#endif\n+  emit_throw ();\n }\n \n /* Called from expand_exception_blocks and expand_end_catch_block to\n@@ -1284,19 +1263,9 @@ expand_leftover_cleanups ()\n \n       prev = get_last_insn ();\n       if (prev == NULL || GET_CODE (prev) != BARRIER)\n-\t{\n-\t  if (exceptions_via_longjmp)\n-\t    emit_throw ();\n-\t  else\n-\t    {\n-\t      /* The below can be optimized away, and we could just\n-\t\t fall into the next EH handler, if we are certain they\n-\t\t are nested.  */\n-\t      /* Emit code to throw to the outer context if we fall off\n-\t\t the end of the handler.  */\n-\t      expand_internal_throw (entry->outer_context);\n-\t    }\n-\t}\n+\t/* Emit code to throw to the outer context if we fall off\n+\t   the end of the handler.  */\n+\texpand_rethrow (entry->outer_context);\n \n       do_pending_stack_adjust ();\n       free (entry);\n@@ -1325,12 +1294,12 @@ expand_start_all_catch ()\n {\n   struct eh_entry *entry;\n   tree label;\n+  rtx outer_context;\n \n   if (! doing_eh (1))\n     return;\n \n-  push_label_entry (&outer_context_label_stack,\n-\t\t    ehstack.top->entry->outer_context, NULL_TREE);\n+  outer_context = ehstack.top->entry->outer_context;\n \n   /* End the try block.  */\n   expand_eh_region_end (integer_zero_node);\n@@ -1342,16 +1311,6 @@ expand_start_all_catch ()\n      This is Lresume in the documention.  */\n   expand_label (label);\n   \n-  if (exceptions_via_longjmp == 0)\n-    {\n-      /* Put in something that takes up space, as otherwise the end\n-\t address for the EH region could have the exact same address as\n-\t the outer region, causing us to miss the fact that resuming\n-\t exception handling with this PC value would be inside the outer\n-\t region.  */\n-      emit_insn (gen_nop ());\n-    }\n-\n   /* Push the label that points to where normal flow is resumed onto\n      the top of the label stack.  */\n   push_label_entry (&caught_return_label_stack, NULL_RTX, label);\n@@ -1402,25 +1361,24 @@ expand_start_all_catch ()\n \n       prev = get_last_insn ();\n       if (prev == NULL || GET_CODE (prev) != BARRIER)\n-\t{\n-\t  if (exceptions_via_longjmp)\n-\t    emit_throw ();\n-\t  else\n-\t    {\n-\t      /* Code to throw out to outer context when we fall off end\n-\t\t of the handler. We can't do this here for catch blocks,\n-\t\t so it's done in expand_end_all_catch instead.\n-\n-\t\t The below can be optimized away (and we could just fall\n-\t\t into the next EH handler) if we are certain they are\n-\t\t nested.  */\n+\t/* Code to throw out to outer context when we fall off end\n+\t   of the handler. We can't do this here for catch blocks,\n+\t   so it's done in expand_end_all_catch instead.  */\n+\texpand_rethrow (entry->outer_context);\n \n-\t      expand_internal_throw (entry->outer_context);\n-\t    }\n-\t}\n       do_pending_stack_adjust ();\n       free (entry);\n     }\n+\n+  /* If we are not doing setjmp/longjmp EH, because we are reordered\n+     out of line, we arrange to rethrow in the outer context.  We need to\n+     do this because we are not physically within the region, if any, that\n+     logically contains this catch block.  */\n+  if (! exceptions_via_longjmp)\n+    {\n+      expand_eh_region_start ();\n+      ehstack.top->entry->outer_context = outer_context;\n+    }\n }\n \n /* Finish up the catch block.  At this point all the insns for the\n@@ -1432,27 +1390,26 @@ expand_start_all_catch ()\n void\n expand_end_all_catch ()\n {\n-  rtx new_catch_clause;\n+  rtx new_catch_clause, outer_context;\n \n   if (! doing_eh (1))\n     return;\n \n-  if (exceptions_via_longjmp)\n-    emit_throw ();\n-  else\n-    {\n-      /* Code to throw out to outer context, if we fall off end of catch\n-\t handlers.  This is rethrow (Lresume, same id, same obj) in the\n-\t documentation. We use Lresume because we know that it will throw\n-\t to the correct context.\n-\n-\t In other words, if the catch handler doesn't exit or return, we\n-\t do a \"throw\" (using the address of Lresume as the point being\n-\t thrown from) so that the outer EH region can then try to process\n-\t the exception.  */\n+  outer_context = ehstack.top->entry->outer_context;\n+  if (! exceptions_via_longjmp)\n+    /* Finish the rethrow region.  size_zero_node is just a NOP.  */\n+    expand_eh_region_end (size_zero_node);\n+  \n+  /* Code to throw out to outer context, if we fall off end of catch\n+     handlers.  This is rethrow (Lresume, same id, same obj) in the\n+     documentation. We use Lresume because we know that it will throw\n+     to the correct context.\n \n-      expand_internal_throw (outer_context_label_stack->u.rlabel);\n-    }\n+     In other words, if the catch handler doesn't exit or return, we\n+     do a \"throw\" (using the address of Lresume as the point being\n+     thrown from) so that the outer EH region can then try to process\n+     the exception.  */\n+  expand_rethrow (outer_context);\n \n   /* Now we have the complete catch sequence.  */\n   new_catch_clause = get_insns ();\n@@ -1461,7 +1418,6 @@ expand_end_all_catch ()\n   /* This level of catch blocks is done, so set up the successful\n      catch jump label for the next layer of catch blocks.  */\n   pop_label_entry (&caught_return_label_stack);\n-  pop_label_entry (&outer_context_label_stack);\n \n   /* Add the new sequence of catches to the main one for this function.  */\n   push_to_sequence (catch_clauses);\n@@ -1472,6 +1428,18 @@ expand_end_all_catch ()\n   /* Here we fall through into the continuation code.  */\n }\n \n+/* Rethrow from the outer context LABEL.  */\n+\n+static void\n+expand_rethrow (label)\n+     rtx label;\n+{\n+  if (exceptions_via_longjmp)\n+    emit_throw ();\n+  else\n+    emit_jump (label);\n+}\n+\n /* End all the pending exception regions on protect_list. The handlers\n    will be emitted when expand_leftover_cleanups is invoked.  */\n \n@@ -2006,11 +1974,13 @@ init_eh ()\n      current context is saved.  */\n   tree type = build_pointer_type (make_node (VOID_TYPE));\n \n+#ifndef DWARF2_UNWIND_INFO\n   eh_saved_pc = build_decl (VAR_DECL, get_identifier (\"__eh_pc\"), type);\n   DECL_EXTERNAL (eh_saved_pc) = 1;\n   TREE_PUBLIC (eh_saved_pc) = 1;\n   make_decl_rtl (eh_saved_pc, NULL_PTR, 1);\n   eh_saved_pc_rtx = DECL_RTL (eh_saved_pc);\n+#endif\n }\n \n /* Initialize the per-function EH information.  */"}, {"sha": "172bac4d90404421e8655c1be887404c52e849cb", "filename": "gcc/except.h", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=e701eb4de0b60d5ceac3ec4d9be03f7e39a57103", "patch": "@@ -192,10 +192,9 @@ extern void add_partial_entry\t\t\tPROTO((tree handler));\n \n extern void end_protect_partials\t\tPROTO((void));\n \n-/* An internal throw with a direct CONTEXT we want to throw\n-   from. CONTEXT must be a label.  */\n+/* An internal throw.  */\n \n-extern void expand_internal_throw\t\tPROTO((rtx context));\n+extern void expand_internal_throw\t\tPROTO((void));\n \n /* Called from expand_exception_blocks and expand_end_catch_block to\n    expand and pending handlers.  */\n@@ -227,11 +226,6 @@ extern void check_exception_handler_labels\tPROTO((void));\n \n extern struct label_node *caught_return_label_stack;\n \n-/* Keeps track of the label used as the context of a throw to rethrow an\n-   exception to the outer exception region.  */\n-\n-extern struct label_node *outer_context_label_stack;\n-\n /* A random area used for purposes elsewhere.  */\n \n extern struct label_node *false_label_stack;"}, {"sha": "ed66ce7c4ef5e5a56435be887d347bf862e34299", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=e701eb4de0b60d5ceac3ec4d9be03f7e39a57103", "patch": "@@ -472,15 +472,10 @@ find_basic_blocks (f, nonlocal_label_list)\n       /* If we encounter a CALL_INSN, note which exception handler it\n \t might pass control to.\n \n-\t Because we do rethrows by loading the address of a label into\n-\t __eh_pc and throwing, we need to treat labels as potentially\n-\t jumping to exception handlers.\n-\n \t If doing asynchronous exceptions, record the active EH handler\n \t for every insn, since most insns can throw.  */\n       else if (eh_note\n \t       && (asynchronous_exceptions\n-\t\t   || code == CODE_LABEL\n \t\t   || (GET_CODE (insn) == CALL_INSN\n \t\t       && ! find_reg_note (insn, REG_RETVAL, NULL_RTX))))\n \tactive_eh_handler[INSN_UID (insn)] = XEXP (eh_note, 0);\n@@ -574,11 +569,7 @@ find_basic_blocks (f, nonlocal_label_list)\n \t\t\t   associated insns aren't marked dead, so we make\n \t\t\t   the block in question live and create an edge from\n \t\t\t   this insn to the label.  This is not strictly\n-\t\t\t   correct, but it is close enough for now.\n-\n-\t\t\t   We also need to mark the CODE_LABEL as reaching\n-\t\t\t   its exception handler for nested exceptions to\n-\t\t\t   to work.  */\n+\t\t\t   correct, but it is close enough for now.  */\n \t\t\tfor (note = REG_NOTES (insn);\n \t\t\t     note;\n \t\t\t     note = XEXP (note, 1))\n@@ -590,14 +581,6 @@ find_basic_blocks (f, nonlocal_label_list)\n \t\t\t\tmark_label_ref (gen_rtx (LABEL_REF,\n \t\t\t\t\t\t\t VOIDmode, x),\n \t\t\t\t\t\tinsn, 0);\n-\n-\t\t\t\t/* If the CODE_LABEL has an active exception\n-\t\t\t\t   handler, then make an edge to the exception\n-\t\t\t\t   handler from this insn.  */\n-\t\t\t\tif (active_eh_handler[INSN_UID (x)])\n-\t\t\t\t  mark_label_ref (gen_rtx (LABEL_REF, VOIDmode,\n-\t\t\t\t\t\t\t   active_eh_handler[INSN_UID (x)]),\n-\t\t\t\t\t\t  insn, 0);\n \t\t\t      }\n \t\t\t  }\n "}, {"sha": "faa3c14cf2e455205a04df39999ae44f4babcf73", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e701eb4de0b60d5ceac3ec4d9be03f7e39a57103/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=e701eb4de0b60d5ceac3ec4d9be03f7e39a57103", "patch": "@@ -3154,8 +3154,6 @@ __sjpopnthrow ()\n /* This value identifies the place from which an exception is being\n    thrown.  */\n \n-void *__eh_pc;\n-\n #ifdef EH_TABLE_LOOKUP\n \n EH_TABLE_LOOKUP\n@@ -3212,6 +3210,8 @@ find_exception_handler (void *pc, exception_table *table)\n /* Support code for exception handling using inline unwinders or\n    __unwind_function.  */\n \n+void *__eh_pc;\n+\n #ifndef EH_TABLE_LOOKUP\n typedef struct exception_table_node {\n   exception_table *table;\n@@ -3489,7 +3489,7 @@ in_reg_window (int reg, frame_state *udata)\n void\n __throw ()\n {\n-  void *pc, *handler, *retaddr;\n+  void *pc, *handler, *retaddr, *__eh_pc;\n   frame_state ustruct, ustruct2;\n   frame_state *udata = &ustruct;\n   frame_state *sub_udata = &ustruct2;\n@@ -3524,6 +3524,7 @@ __throw ()\n   __builtin_unwind_init ();\n \n   /* Now reset pc to the right throw point.  */\n+  __eh_pc = __builtin_extract_return_addr (__builtin_return_address (0)) - 1;\n   pc = __eh_pc;\n \n   handler = 0;"}]}