{"sha": "35fd3193deafc09568065a6ebec64470e790c6f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVmZDMxOTNkZWFmYzA5NTY4MDY1YTZlYmVjNjQ0NzBlNzkwYzZmOA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-01-23T15:05:49Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-01-23T15:05:49Z"}, "message": "alias.c, [...]: Fix comment typos.\n\n\t* alias.c, c-common.h, c-incpath.c, c-incpath.h, expr.c,\n\tfold-const.c, gimplify.c, params.h, tree-data-ref.c,\n\ttree-if-conv.c, tree-nested.c, tree-outof-ssa.c,\n\ttree-ssa-dom.c, tree-vectorizer.c, tree.def, config/darwin.c,\n\tconfig/freebsd-spec.h, config/arm/arm.h,\n\tconfig/h8300/h8300.md, config/i386/i386.md,\n\tconfig/i386/predicates.md, config/i386/sse.md,\n\tconfig/ia64/ia64.c, config/ip2k/ip2k.c, config/s390/s390.c,\n\tconfig/vax/vax.md: Fix comment typos.  Follow spelling\n\tconventions.\n\nFrom-SVN: r94112", "tree": {"sha": "a47662875339514cf8b46f25d1fe13a255cec8c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a47662875339514cf8b46f25d1fe13a255cec8c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35fd3193deafc09568065a6ebec64470e790c6f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35fd3193deafc09568065a6ebec64470e790c6f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35fd3193deafc09568065a6ebec64470e790c6f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35fd3193deafc09568065a6ebec64470e790c6f8/comments", "author": null, "committer": null, "parents": [{"sha": "e7dc5b4f224051483b5df3bb38bd0c2f1b1147f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7dc5b4f224051483b5df3bb38bd0c2f1b1147f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7dc5b4f224051483b5df3bb38bd0c2f1b1147f1"}], "stats": {"total": 96, "additions": 55, "deletions": 41}, "files": [{"sha": "ce737615e63f1f7660e8234881263a7ec384ffa0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -1,3 +1,16 @@\n+2005-01-23  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* alias.c, c-common.h, c-incpath.c, c-incpath.h, expr.c,\n+\tfold-const.c, gimplify.c, params.h, tree-data-ref.c,\n+\ttree-if-conv.c, tree-nested.c, tree-outof-ssa.c,\n+\ttree-ssa-dom.c, tree-vectorizer.c, tree.def, config/darwin.c,\n+\tconfig/freebsd-spec.h, config/arm/arm.h,\n+\tconfig/h8300/h8300.md, config/i386/i386.md,\n+\tconfig/i386/predicates.md, config/i386/sse.md,\n+\tconfig/ia64/ia64.c, config/ip2k/ip2k.c, config/s390/s390.c,\n+\tconfig/vax/vax.md: Fix comment typos.  Follow spelling\n+\tconventions.\n+\n 2005-01-23  Steven Bosscher  <stevenb@suse.de>\n \n \t* gengtype.c (walk_type): Produce `not equal to' compares for loop"}, {"sha": "a0f77d559a119bca7c49661a2609e2a3c28e3e2c", "filename": "gcc/alias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -1,5 +1,5 @@\n /* Alias analysis for GNU C\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n    Free Software Foundation, Inc.\n    Contributed by John Carr (jfc@mit.edu).\n \n@@ -1882,7 +1882,7 @@ static int\n aliases_everything_p (rtx mem)\n {\n   if (GET_CODE (XEXP (mem, 0)) == AND)\n-    /* If the address is an AND, its very hard to know at what it is\n+    /* If the address is an AND, it's very hard to know at what it is\n        actually pointing.  */\n     return 1;\n "}, {"sha": "1a3f55103fcb9b4b8fa771dc29c53ebe58af6b63", "filename": "gcc/c-common.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for c-common.c.\n    Copyright (C) 1987, 1993, 1994, 1995, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -241,7 +241,7 @@ extern c_language_kind c_language;\n /* Information about a statement tree.  */\n \n struct stmt_tree_s GTY(()) {\n-  /* The current statment list being collected.  */\n+  /* The current statement list being collected.  */\n   tree x_cur_stmt_list;\n \n   /* In C++, Nonzero if we should treat statements as full\n@@ -272,9 +272,9 @@ struct c_language_function GTY(()) {\n   struct stmt_tree_s x_stmt_tree;\n };\n \n-/* When building a statement-tree, this is the current statment list\n+/* When building a statement-tree, this is the current statement list\n    being collected.  It's TREE_CHAIN is a back-pointer to the previous\n-   statment list.  */\n+   statement list.  */\n \n #define cur_stmt_list (current_stmt_tree ()->x_cur_stmt_list)\n "}, {"sha": "62680bda14aa73cd7ae41f11ce61c8813735a916", "filename": "gcc/c-incpath.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fc-incpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fc-incpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-incpath.c?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -1,6 +1,6 @@\n /* Set up combined include path chain for the preprocessor.\n    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n \n    Broken out of cppinit.c and cppfiles.c and rewritten Mar 2003.\n \n@@ -332,7 +332,7 @@ add_path (char *path, int chain, int cxx_aware, bool user_supplied_p)\n \n #if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n   /* Convert all backslashes to slashes.  The native CRT stat()\n-     function does not recognise a directory that ends in a backslash\n+     function does not recognize a directory that ends in a backslash\n      (unless it is a drive root dir, such \"c:\\\").  Forward slashes,\n      trailing or otherwise, cause no problems for stat().  */\n   char* c;"}, {"sha": "57a6f7c2cbba40fe9631b890befcd4864b961e66", "filename": "gcc/c-incpath.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fc-incpath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fc-incpath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-incpath.h?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -1,5 +1,5 @@\n /* Set up combined include path for the preprocessor.\n-   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the"}, {"sha": "5955d3ced66de0bd0f36bb2db837bf79ba675354", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -26,7 +26,7 @@\n #ifndef GCC_ARM_H\n #define GCC_ARM_H\n \n-/* The archetecture define.  */\n+/* The architecture define.  */\n extern char arm_arch_name[];\n \n /* Target CPU builtins.  */"}, {"sha": "de2f6e3e0b694f7cf004dcb5e1370e2d72f4e358", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -142,7 +142,7 @@ machopic_classify_symbol (rtx sym_ref)\n \n /* Indicate when fix-and-continue style code generation is being used\n    and when a reference to data should be indirected so that it can be\n-   rebound in a new translation unit to refernce the original instance\n+   rebound in a new translation unit to reference the original instance\n    of that data.  Symbol names that are for code generation local to\n    the translation unit are bound to the new translation unit;\n    currently this means symbols that begin with L or _OBJC_;"}, {"sha": "820a43fb0b39d08408dd8fd41524132e62c72e9c", "filename": "gcc/config/freebsd-spec.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Ffreebsd-spec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Ffreebsd-spec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffreebsd-spec.h?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -118,7 +118,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* Provide a LIB_SPEC appropriate for FreeBSD.  Just select the appropriate\n    libc, depending on whether we're doing profiling or need threads support.\n-   (simular to the default, except no -lg, and no -p).  */\n+   (similar to the default, except no -lg, and no -p).  */\n \n #ifdef FBSD_NO_THREADS\n #define FBSD_LIB_SPEC \"\t\t\t\t\t\t\t\\"}, {"sha": "ffdd0cc4783b5c921178c704403718e1cb0445df", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -1,6 +1,6 @@\n ;; GCC machine description for Renesas H8/300\n ;; Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-;; 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+;; 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n \n ;;   Contributed by Steve Chamberlain (sac@cygnus.com),\n ;;   Jim Wilson (wilson@cygnus.com), and Doug Evans (dje@cygnus.com).\n@@ -158,7 +158,7 @@\n \t(const_string \"yes\")))\n \n ;; Only allow jumps to have a delay slot if we think they might\n-;; be short enough.  This is just an optimisation: we don't know\n+;; be short enough.  This is just an optimization: we don't know\n ;; for certain whether they will be or not.\n (define_delay (and (eq_attr \"delay_slot\" \"jump\")\n \t\t   (eq (symbol_ref \"get_attr_length (insn)\") (const_int 2)))"}, {"sha": "f96fa9495a3c3d8c16dcd631c28060a54f2856fc", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -17424,7 +17424,7 @@\n   \"(TARGET_80387 && TARGET_CMOVE) || TARGET_SSE_MATH\"\n   \"if (! ix86_expand_fp_movcc (operands)) FAIL; DONE;\")\n \n-;; These versions of min/max are aware of the instruction's behaviour\n+;; These versions of min/max are aware of the instruction's behavior\n ;; wrt -0.0 and NaN inputs.  If we don't care about either, then we\n ;; should have used the smin/smax expanders in the first place.\n (define_insn \"*movsfcc_1_sse_min\"\n@@ -17493,7 +17493,7 @@\n   \"(TARGET_80387 && TARGET_CMOVE) || (TARGET_SSE2 && TARGET_SSE_MATH)\"\n   \"if (! ix86_expand_fp_movcc (operands)) FAIL; DONE;\")\n \n-;; These versions of min/max are aware of the instruction's behaviour\n+;; These versions of min/max are aware of the instruction's behavior\n ;; wrt -0.0 and NaN inputs.  If we don't care about either, then we\n ;; should have used the smin/smax expanders in the first place.\n (define_insn \"*movdfcc_1_sse_min\"\n@@ -17612,7 +17612,7 @@\n    (set_attr \"mode\" \"XF\")])\n \n ;; These versions of the min/max patterns are intentionally ignorant of\n-;; their behaviour wrt -0.0 and NaN (via the commutative operand mark).\n+;; their behavior wrt -0.0 and NaN (via the commutative operand mark).\n ;; Since both the tree-level MAX_EXPR and the rtl-level SMAX operator\n ;; are undefined in this condition, we're certain this is correct.\n "}, {"sha": "66f25058182d3c2dfcef2ef0ad350a6f1f61c034", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -492,7 +492,7 @@\n        (ior (match_operand 0 \"register_no_elim_operand\")\n \t    (match_operand 0 \"memory_operand\"))))\n \n-;; Simiarly, but for tail calls, in which we cannot allow memory references.\n+;; Similarly, but for tail calls, in which we cannot allow memory references.\n (define_predicate \"sibcall_insn_operand\"\n   (ior (match_operand 0 \"constant_call_address_operand\")\n        (match_operand 0 \"register_no_elim_operand\")))"}, {"sha": "e147b71028b74a1b8d266640f7dc6f196bc82fb5", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -3199,7 +3199,7 @@\n \n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n-;; Miscelaneous\n+;; Miscellaneous\n ;;\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n "}, {"sha": "76504c17be786a0158db9bcded23aaf24b9e547e", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -5851,7 +5851,7 @@ static const char *bundle_name [NR_BUNDLES] =\n \n int ia64_final_schedule = 0;\n \n-/* Codes of the corresponding quieryied units: */\n+/* Codes of the corresponding queried units: */\n \n static int _0mii_, _0mmi_, _0mfi_, _0mmf_;\n static int _0bbb_, _0mbb_, _0mib_, _0mmb_, _0mfb_, _0mlx_;"}, {"sha": "70b23d0f755cf795b341e8e19e34688849bb50cd", "filename": "gcc/config/ip2k/ip2k.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Fip2k%2Fip2k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Fip2k%2Fip2k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.c?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -1,6 +1,7 @@\n /* Subroutines used for code generation on Ubicom IP2022\n    Communications Controller.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005\n+   Free Software Foundation, Inc.\n    Contributed by Red Hat, Inc and Ubicom, Inc.\n \n    This file is part of GCC.\n@@ -5245,7 +5246,7 @@ mdr_try_wreg_elim (first_insn)\n #endif /* IP2K_MD_REORG_PASS */\n \n /* We perform a lot of untangling of the RTL within the reorg pass since\n-   the IP2k requires some really bizarre (and really undesireable) things\n+   the IP2k requires some really bizarre (and really undesirable) things\n    to happen in order to guarantee not aborting.  This pass causes several\n    earlier passes to be re-run as it progressively transforms things,\n    making the subsequent runs continue to win.  */"}, {"sha": "f9be9cf0a6fb6dbcc3efe88320dd3ed514369ddf", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -600,7 +600,7 @@ s390_select_ccmode (enum rtx_code code, rtx op0, rtx op1)\n \n  \t/* If constants are involved in an add instruction it is possible to use\n  \t   the resulting cc for comparisons with zero. Knowing the sign of the\n-\t   constant the overflow behaviour gets predictable. e.g.:\n+\t   constant the overflow behavior gets predictable. e.g.:\n  \t     int a, b; if ((b = a + c) > 0)  \n  \t   with c as a constant value: c < 0 -> CCAN and c >= 0 -> CCAP  */\n \tif (GET_CODE (op0) == PLUS && GET_CODE (XEXP (op0, 1)) == CONST_INT"}, {"sha": "b3b8ff6f396fdd2de4af12e3df4f097cb1b079a4", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -1,6 +1,6 @@\n ;; Machine description for GNU compiler, VAX Version\n ;; Copyright (C) 1987, 1988, 1991, 1994, 1995, 1996, 1998, 1999, 2000, 2001,\n-;; 2002, 2004 Free Software Foundation, Inc.\n+;; 2002, 2004, 2005 Free Software Foundation, Inc.\n \n ;; This file is part of GCC.\n \n@@ -2007,7 +2007,7 @@\n })\n \n ;; This insn is a bit of a lier.  It actually falls through if no case\n-;; matches.  But, we prevent that from ever happening by emiting a jump\n+;; matches.  But, we prevent that from ever happening by emitting a jump\n ;; before this, see the define_expand above.\n (define_insn \"casesi1\"\n   [(match_operand:SI 1 \"const_int_operand\" \"n\")"}, {"sha": "ea6f15a10b83a36e0de638e2bc96f212f4d18f2c", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -2732,7 +2732,7 @@ emit_move_change_mode (enum machine_mode new_mode,\n     }\n   else\n     {\n-      /* Note that we do want simplify_subreg's behaviour of validating\n+      /* Note that we do want simplify_subreg's behavior of validating\n \t that the new mode is ok for a hard register.  If we were to use\n \t simplify_gen_subreg, we would create the subreg, but would\n \t probably run into the target not being able to implement it.  */\n@@ -2877,7 +2877,7 @@ emit_move_complex (enum machine_mode mode, rtx x, rtx y)\n   if (push_operand (x, mode))\n     return emit_move_complex_push (mode, x, y);\n \n-  /* For memory to memory moves, optimial behaviour can be had with the\n+  /* For memory to memory moves, optimal behavior can be had with the\n      existing block move logic.  */\n   if (MEM_P (x) && MEM_P (y))\n     {"}, {"sha": "8e8a821938b091aee76129a5c9b918f3fda26b53", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -5392,7 +5392,7 @@ fold_binary_op_with_conditional_arg (enum tree_code code, tree type,\n   tree rhs = NULL_TREE;\n \n   /* This transformation is only worthwhile if we don't have to wrap\n-     arg in a SAVE_EXPR, and the operation can be simplified on atleast\n+     arg in a SAVE_EXPR, and the operation can be simplified on at least\n      one of the branches once its pushed inside the COND_EXPR.  */\n   if (!TREE_CONSTANT (arg))\n     return NULL_TREE;"}, {"sha": "d77a3b36adeea2c45dc0477e045c103b37b3a1e8", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -4243,7 +4243,7 @@ gimplify_type_sizes (tree type, tree *list_p)\n   tree field, t;\n \n   /* Note that we do not check for TYPE_SIZES_GIMPLIFIED already set because\n-     that's not supposed to happen on types where gimplifcation does anything.\n+     that's not supposed to happen on types where gimplification does anything.\n      We should assert that it isn't set, but we can indeed be called multiple\n      times on pointers.  Unfortunately, this includes fat pointers which we\n      can't easily test for.  We could pass TYPE down to gimplify_one_sizepos"}, {"sha": "1f57a0f91a02ced313ac296e67ed4050647f97b9", "filename": "gcc/params.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -52,7 +52,7 @@ typedef struct param_info\n   /* Minimum acceptable value.  */\n   int min_value;\n   \n-  /* Maxiumum acceptable value, if greater than minimum  */\n+  /* Maximum acceptable value, if greater than minimum  */\n   int max_value;\n   \n   /* A short description of the option.  */"}, {"sha": "c6ca75310f8f254ee780de76ba324b096a65d5a8", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -1111,7 +1111,7 @@ compute_overlap_steps_for_affine_univar (int niter, int step_a, int step_b,\n    | y (t, u, v) = {{0, +, 1336}_u, +, 1}_v\n    | z (t, u, v) = {{{0, +, 1}_t, +, 1335}_u, +, 1}_v\n \n-   FORNOW: This is a specialized implementation for a case occuring in\n+   FORNOW: This is a specialized implementation for a case occurring in\n    a common benchmark.  Implement the general algorithm.  */\n \n static void"}, {"sha": "fbcbe1ca5d7f46f7c86f55d1f3d2f9b56648dfbf", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -974,7 +974,7 @@ ifc_temp_var (tree type, tree exp)\n   stmt = build (MODIFY_EXPR, type, var, exp);\n \n   /* Get SSA name for the new variable and set make new statement\n-     its definition statment.  */\n+     its definition statement.  */\n   new_name = make_ssa_name (var, stmt);\n   TREE_OPERAND (stmt, 0) = new_name;\n   SSA_NAME_DEF_STMT (new_name) = stmt;"}, {"sha": "b1ab217340b24b3507fa5113a91f8ee8c1aa9556", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -1,5 +1,5 @@\n /* Nested function decomposition for trees.\n-   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -636,7 +636,7 @@ walk_all_functions (walk_tree_fn callback, struct nesting_info *root)\n   while (root);\n }\n \f\n-/* We have to check for a fairly pathalogical case.  The operands of function\n+/* We have to check for a fairly pathological case.  The operands of function\n    nested function are to be interpreted in the context of the enclosing\n    function.  So if any are variably-sized, they will get remapped when the\n    enclosing function is inlined.  But that remapping would also have to be"}, {"sha": "cfa17043ca6a2111c1d7ea658a2f839d07f681ba", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -2417,7 +2417,7 @@ insert_backedge_copies (void)\n \t\t     start of a loop should be with a COND_EXPR or GOTO_EXPR.\n \t\t     However, better safe than sorry. \n \n-\t\t     If the block ends with a control statment or\n+\t\t     If the block ends with a control statement or\n \t\t     something that might throw, then we have to\n \t\t     insert this assignment before the last\n \t\t     statement.  Else insert it after the last statement.  */"}, {"sha": "b4929494749d39f0fc71ff81ffd068d7766eafd5", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -246,7 +246,7 @@ struct vrp_hash_elt\n    in this basic block.  We use this during finalization to know\n    which variables need their VRP data updated.  */\n \n-/* Stack of SSA_NAMEs which had their values constrainted by operations\n+/* Stack of SSA_NAMEs which had their values constrained by operations\n    in this basic block.  During finalization of this block we use this\n    list to determine which variables need their VRP data updated.\n \n@@ -1255,7 +1255,7 @@ record_equivalences_from_incoming_edge (basic_block bb)\n   basic_block parent;\n   struct edge_info *edge_info;\n \n-  /* If our parent block ended with a control statment, then we may be\n+  /* If our parent block ended with a control statement, then we may be\n      able to record some equivalences based on which outgoing edge from\n      the parent was followed.  */\n   parent = get_immediate_dominator (CDI_DOMINATORS, bb);"}, {"sha": "7b0e3f3a7ae704730a0fce9f27499bc26a048deb", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -2494,7 +2494,7 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       return true;\n     }\n \n-  /** Trasform.  **/\n+  /** Transform.  **/\n   if (vect_debug_details (NULL))\n     fprintf (dump_file, \"transform assignment.\");\n \n@@ -2685,7 +2685,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       return true;\n     }\n \n-  /** Trasform.  **/\n+  /** Transform.  **/\n \n   if (vect_debug_details (NULL))\n     fprintf (dump_file, \"transform store\");\n@@ -2772,7 +2772,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       return true;\n     }\n \n-  /** Trasform.  **/\n+  /** Transform.  **/\n \n   if (vect_debug_details (NULL))\n     fprintf (dump_file, \"transform load.\");"}, {"sha": "9a7c7e0db3bbae93fa2ae083aaabb545ed8fe267", "filename": "gcc/tree.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35fd3193deafc09568065a6ebec64470e790c6f8/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=35fd3193deafc09568065a6ebec64470e790c6f8", "patch": "@@ -487,7 +487,7 @@ DEFTREECODE (TARGET_EXPR, \"target_expr\", tcc_expression, 4)\n    have VOID_TYPE.  The same constraints apply to operand 2.  */\n DEFTREECODE (COND_EXPR, \"cond_expr\", tcc_expression, 3)\n \n-/* Vector conditional expresion. It is like COND_EXPR, but with\n+/* Vector conditional expression. It is like COND_EXPR, but with\n    vector operands.\n \n    A = VEC_COND_EXPR ( X < Y, B, C)"}]}