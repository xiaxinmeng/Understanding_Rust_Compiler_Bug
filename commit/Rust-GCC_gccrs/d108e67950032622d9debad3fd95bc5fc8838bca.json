{"sha": "d108e67950032622d9debad3fd95bc5fc8838bca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDEwOGU2Nzk1MDAzMjYyMmQ5ZGViYWQzZmQ5NWJjNWZjODgzOGJjYQ==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2011-04-09T19:10:45Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2011-04-09T19:10:45Z"}, "message": "expr.c (expand_expr_real_1): Use add_to_hard_reg_set function instead of loop.\n\n\t* expr.c (expand_expr_real_1): Use add_to_hard_reg_set function\n\tinstead of loop.\n\t* sel-sched.c (mark_unavailable_hard_regs): Likewise.\n\t* function.c (record_hard_reg_sets): Likewise.\n\t* ira.c (compute_regs_asm_clobbered): Likewise.\n\t* sched-deps.c (sched_analyze_1): Likewise.\n\t* reload1.c (mark_reload_reg_in_use, choose_reload_regs): Likewise.\n\nFrom-SVN: r172231", "tree": {"sha": "25f13b9423e5b01037286bbf2f8b57fd290f7e28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25f13b9423e5b01037286bbf2f8b57fd290f7e28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d108e67950032622d9debad3fd95bc5fc8838bca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d108e67950032622d9debad3fd95bc5fc8838bca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d108e67950032622d9debad3fd95bc5fc8838bca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d108e67950032622d9debad3fd95bc5fc8838bca/comments", "author": null, "committer": null, "parents": [{"sha": "3411bc59c6a0a9d6d0f6899f1072565a346afacd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3411bc59c6a0a9d6d0f6899f1072565a346afacd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3411bc59c6a0a9d6d0f6899f1072565a346afacd"}], "stats": {"total": 159, "additions": 67, "deletions": 92}, "files": [{"sha": "2ec51f2346c9be52e90743ae6629e30c3ed13efc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d108e67950032622d9debad3fd95bc5fc8838bca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d108e67950032622d9debad3fd95bc5fc8838bca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d108e67950032622d9debad3fd95bc5fc8838bca", "patch": "@@ -1,3 +1,13 @@\n+2011-04-09  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* expr.c (expand_expr_real_1): Use add_to_hard_reg_set function\n+\tinstead of loop.\n+\t* sel-sched.c (mark_unavailable_hard_regs): Likewise.\n+\t* function.c (record_hard_reg_sets): Likewise.\n+\t* ira.c (compute_regs_asm_clobbered): Likewise.\n+\t* sched-deps.c (sched_analyze_1): Likewise.\n+\t* reload1.c (mark_reload_reg_in_use, choose_reload_regs): Likewise.\n+\n 2011-04-09  Xinliang David Li  <davidxl@google.com>\n \n \tPR tree-optimization/PR48484"}, {"sha": "491d2b13e6a843d0187b65751b68dc96fa0071a6", "filename": "gcc/expr.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d108e67950032622d9debad3fd95bc5fc8838bca/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d108e67950032622d9debad3fd95bc5fc8838bca/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d108e67950032622d9debad3fd95bc5fc8838bca", "patch": "@@ -8451,18 +8451,11 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       gcc_assert (decl_rtl);\n       decl_rtl = copy_rtx (decl_rtl);\n       /* Record writes to register variables.  */\n-      if (modifier == EXPAND_WRITE && REG_P (decl_rtl)\n-\t  && REGNO (decl_rtl) < FIRST_PSEUDO_REGISTER)\n-\t{\n-\t    int i = REGNO (decl_rtl);\n-\t    int nregs = hard_regno_nregs[i][GET_MODE (decl_rtl)];\n-\t    while (nregs)\n-\t      {\n-\t\tSET_HARD_REG_BIT (crtl->asm_clobbers, i);\n-\t\ti++;\n-\t\tnregs--;\n-\t      }\n-\t}\n+      if (modifier == EXPAND_WRITE\n+\t  && REG_P (decl_rtl)\n+\t  && HARD_REGISTER_P (decl_rtl))\n+        add_to_hard_reg_set (&crtl->asm_clobbers,\n+\t\t\t     GET_MODE (decl_rtl), REGNO (decl_rtl));\n \n       /* Ensure variable marked as used even if it doesn't go through\n \t a parser.  If it hasn't be used yet, write out an external"}, {"sha": "c292282070ce4ee49bf5235ce0a90497d2f94611", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d108e67950032622d9debad3fd95bc5fc8838bca/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d108e67950032622d9debad3fd95bc5fc8838bca/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d108e67950032622d9debad3fd95bc5fc8838bca", "patch": "@@ -2912,12 +2912,8 @@ static void\n record_hard_reg_sets (rtx x, const_rtx pat ATTRIBUTE_UNUSED, void *data)\n {\n   HARD_REG_SET *pset = (HARD_REG_SET *)data;\n-  if (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER)\n-    {\n-      int nregs = hard_regno_nregs[REGNO (x)][GET_MODE (x)];\n-      while (nregs-- > 0)\n-\tSET_HARD_REG_BIT (*pset, REGNO (x) + nregs);\n-    }\n+  if (REG_P (x) && HARD_REGISTER_P (x))\n+    add_to_hard_reg_set (pset, GET_MODE (x), REGNO (x));\n }\n \n /* A subroutine of assign_parms.  Allocate a pseudo to hold the current"}, {"sha": "719473213c8d07400906f12ac6da9a794586eacd", "filename": "gcc/ira.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d108e67950032622d9debad3fd95bc5fc8838bca/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d108e67950032622d9debad3fd95bc5fc8838bca/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=d108e67950032622d9debad3fd95bc5fc8838bca", "patch": "@@ -1724,16 +1724,10 @@ compute_regs_asm_clobbered (void)\n \t      {\n \t\tdf_ref def = *def_rec;\n \t\tunsigned int dregno = DF_REF_REGNO (def);\n-\t\tif (dregno < FIRST_PSEUDO_REGISTER)\n-\t\t  {\n-\t\t    unsigned int i;\n-\t\t    enum machine_mode mode = GET_MODE (DF_REF_REAL_REG (def));\n-\t\t    unsigned int end = dregno\n-\t\t      + hard_regno_nregs[dregno][mode] - 1;\n-\n-\t\t    for (i = dregno; i <= end; ++i)\n-\t\t      SET_HARD_REG_BIT(crtl->asm_clobbers, i);\n-\t\t  }\n+\t\tif (HARD_REGISTER_NUM_P (dregno))\n+\t\t  add_to_hard_reg_set (&crtl->asm_clobbers,\n+\t\t\t\t       GET_MODE (DF_REF_REAL_REG (def)),\n+\t\t\t\t       dregno);\n \t      }\n \t}\n     }"}, {"sha": "b4f3aec12dd0e836cde01327541525724e7cfdc9", "filename": "gcc/reload1.c", "status": "modified", "additions": 37, "deletions": 47, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d108e67950032622d9debad3fd95bc5fc8838bca/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d108e67950032622d9debad3fd95bc5fc8838bca/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=d108e67950032622d9debad3fd95bc5fc8838bca", "patch": "@@ -4958,60 +4958,54 @@ static void\n mark_reload_reg_in_use (unsigned int regno, int opnum, enum reload_type type,\n \t\t\tenum machine_mode mode)\n {\n-  unsigned int nregs = hard_regno_nregs[regno][mode];\n-  unsigned int i;\n-\n-  for (i = regno; i < nregs + regno; i++)\n+  switch (type)\n     {\n-      switch (type)\n-\t{\n-\tcase RELOAD_OTHER:\n-\t  SET_HARD_REG_BIT (reload_reg_used, i);\n-\t  break;\n-\n-\tcase RELOAD_FOR_INPUT_ADDRESS:\n-\t  SET_HARD_REG_BIT (reload_reg_used_in_input_addr[opnum], i);\n-\t  break;\n+    case RELOAD_OTHER:\n+      add_to_hard_reg_set (&reload_reg_used, mode, regno);\n+      break;\n \n-\tcase RELOAD_FOR_INPADDR_ADDRESS:\n-\t  SET_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[opnum], i);\n-\t  break;\n+    case RELOAD_FOR_INPUT_ADDRESS:\n+      add_to_hard_reg_set (&reload_reg_used_in_input_addr[opnum], mode, regno);\n+      break;\n \n-\tcase RELOAD_FOR_OUTPUT_ADDRESS:\n-\t  SET_HARD_REG_BIT (reload_reg_used_in_output_addr[opnum], i);\n-\t  break;\n+    case RELOAD_FOR_INPADDR_ADDRESS:\n+      add_to_hard_reg_set (&reload_reg_used_in_inpaddr_addr[opnum], mode, regno);\n+      break;\n \n-\tcase RELOAD_FOR_OUTADDR_ADDRESS:\n-\t  SET_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[opnum], i);\n-\t  break;\n+    case RELOAD_FOR_OUTPUT_ADDRESS:\n+      add_to_hard_reg_set (&reload_reg_used_in_output_addr[opnum], mode, regno);\n+      break;\n \n-\tcase RELOAD_FOR_OPERAND_ADDRESS:\n-\t  SET_HARD_REG_BIT (reload_reg_used_in_op_addr, i);\n-\t  break;\n+    case RELOAD_FOR_OUTADDR_ADDRESS:\n+      add_to_hard_reg_set (&reload_reg_used_in_outaddr_addr[opnum], mode, regno);\n+      break;\n \n-\tcase RELOAD_FOR_OPADDR_ADDR:\n-\t  SET_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, i);\n-\t  break;\n+    case RELOAD_FOR_OPERAND_ADDRESS:\n+      add_to_hard_reg_set (&reload_reg_used_in_op_addr, mode, regno);\n+      break;\n \n-\tcase RELOAD_FOR_OTHER_ADDRESS:\n-\t  SET_HARD_REG_BIT (reload_reg_used_in_other_addr, i);\n-\t  break;\n+    case RELOAD_FOR_OPADDR_ADDR:\n+      add_to_hard_reg_set (&reload_reg_used_in_op_addr_reload, mode, regno);\n+      break;\n \n-\tcase RELOAD_FOR_INPUT:\n-\t  SET_HARD_REG_BIT (reload_reg_used_in_input[opnum], i);\n-\t  break;\n+    case RELOAD_FOR_OTHER_ADDRESS:\n+      add_to_hard_reg_set (&reload_reg_used_in_other_addr, mode, regno);\n+      break;\n \n-\tcase RELOAD_FOR_OUTPUT:\n-\t  SET_HARD_REG_BIT (reload_reg_used_in_output[opnum], i);\n-\t  break;\n+    case RELOAD_FOR_INPUT:\n+      add_to_hard_reg_set (&reload_reg_used_in_input[opnum], mode, regno);\n+      break;\n \n-\tcase RELOAD_FOR_INSN:\n-\t  SET_HARD_REG_BIT (reload_reg_used_in_insn, i);\n-\t  break;\n-\t}\n+    case RELOAD_FOR_OUTPUT:\n+      add_to_hard_reg_set (&reload_reg_used_in_output[opnum], mode, regno);\n+      break;\n \n-      SET_HARD_REG_BIT (reload_reg_used_at_all, i);\n+    case RELOAD_FOR_INSN:\n+      add_to_hard_reg_set (&reload_reg_used_in_insn,  mode, regno);\n+      break;\n     }\n+\n+  add_to_hard_reg_set (&reload_reg_used_at_all, mode, regno);\n }\n \n /* Similarly, but show REGNO is no longer in use for a reload.  */\n@@ -6946,11 +6940,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t\t       nregno + nr);\n \n \t  if (i >= 0)\n-\t    {\n-\t      nr = hard_regno_nregs[i][rld[r].mode];\n-\t      while (--nr >= 0)\n-\t\tSET_HARD_REG_BIT (reg_is_output_reload, i + nr);\n-\t    }\n+\t    add_to_hard_reg_set (&reg_is_output_reload, rld[r].mode, i);\n \n \t  gcc_assert (rld[r].when_needed == RELOAD_OTHER\n \t\t      || rld[r].when_needed == RELOAD_FOR_OUTPUT"}, {"sha": "6abef8b9f4db63fba69cd8c136751f311806186b", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d108e67950032622d9debad3fd95bc5fc8838bca/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d108e67950032622d9debad3fd95bc5fc8838bca/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=d108e67950032622d9debad3fd95bc5fc8838bca", "patch": "@@ -1,7 +1,8 @@\n /* Instruction scheduling pass.  This file computes dependencies between\n    instructions.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2011\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,\n    and currently maintained by, Jim Wilson (wilson@cygnus.com)\n@@ -2259,16 +2260,12 @@ sched_analyze_1 (struct deps_desc *deps, rtx x, rtx insn)\n       /* Treat all writes to a stack register as modifying the TOS.  */\n       if (regno >= FIRST_STACK_REG && regno <= LAST_STACK_REG)\n \t{\n-\t  int nregs;\n-\n \t  /* Avoid analyzing the same register twice.  */\n \t  if (regno != FIRST_STACK_REG)\n \t    sched_analyze_reg (deps, FIRST_STACK_REG, mode, code, insn);\n \n-\t  nregs = hard_regno_nregs[FIRST_STACK_REG][mode];\n-\t  while (--nregs >= 0)\n-\t    SET_HARD_REG_BIT (implicit_reg_pending_uses,\n-\t\t\t      FIRST_STACK_REG + nregs);\n+\t  add_to_hard_reg_set (&implicit_reg_pending_uses, mode,\n+\t\t\t       FIRST_STACK_REG);\n \t}\n #endif\n     }"}, {"sha": "8a012acec9d313ab0d1ac5423a3534f7f9a62a76", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d108e67950032622d9debad3fd95bc5fc8838bca/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d108e67950032622d9debad3fd95bc5fc8838bca/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=d108e67950032622d9debad3fd95bc5fc8838bca", "patch": "@@ -1263,17 +1263,12 @@ mark_unavailable_hard_regs (def_t def, struct reg_rename *reg_rename_p,\n      FIXME: it is enough to do this once per all original defs.  */\n   if (frame_pointer_needed)\n     {\n-      int i;\n-\n-      for (i = hard_regno_nregs[FRAME_POINTER_REGNUM][Pmode]; i--;)\n-\tSET_HARD_REG_BIT (reg_rename_p->unavailable_hard_regs,\n-                          FRAME_POINTER_REGNUM + i);\n+      add_to_hard_reg_set (&reg_rename_p->unavailable_hard_regs,\n+\t\t\t   Pmode, FRAME_POINTER_REGNUM);\n \n-#if !HARD_FRAME_POINTER_IS_FRAME_POINTER\n-      for (i = hard_regno_nregs[HARD_FRAME_POINTER_REGNUM][Pmode]; i--;)\n-\tSET_HARD_REG_BIT (reg_rename_p->unavailable_hard_regs,\n-                          HARD_FRAME_POINTER_REGNUM + i);\n-#endif\n+      if (!HARD_FRAME_POINTER_IS_FRAME_POINTER)\n+        add_to_hard_reg_set (&reg_rename_p->unavailable_hard_regs, \n+\t\t\t     Pmode, HARD_FRAME_POINTER_IS_FRAME_POINTER);\n     }\n \n #ifdef STACK_REGS"}]}