{"sha": "89341602bbcb808995932a1f57725a585cd4b1a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkzNDE2MDJiYmNiODA4OTk1OTMyYTFmNTc3MjVhNTg1Y2Q0YjFhNA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2003-11-13T00:25:23Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-11-13T00:25:23Z"}, "message": "debug_mode.html: Update.\n\n\n2003-11-12  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* docs/html/debug_mode.html: Update.\n\t* docs/html/17_intro/TODO: Update.\n\nFrom-SVN: r73525", "tree": {"sha": "31be5cfe69d7e377bbf08bf1e37a3b60368a5fc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31be5cfe69d7e377bbf08bf1e37a3b60368a5fc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89341602bbcb808995932a1f57725a585cd4b1a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89341602bbcb808995932a1f57725a585cd4b1a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89341602bbcb808995932a1f57725a585cd4b1a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89341602bbcb808995932a1f57725a585cd4b1a4/comments", "author": null, "committer": null, "parents": [{"sha": "f1045f1b279649dbb3bd81b3626dcc1692642d7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1045f1b279649dbb3bd81b3626dcc1692642d7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1045f1b279649dbb3bd81b3626dcc1692642d7e"}], "stats": {"total": 285, "additions": 171, "deletions": 114}, "files": [{"sha": "8329b33e855fad6ee1b6adc051c0cc036339e7de", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89341602bbcb808995932a1f57725a585cd4b1a4/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89341602bbcb808995932a1f57725a585cd4b1a4/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=89341602bbcb808995932a1f57725a585cd4b1a4", "patch": "@@ -1,3 +1,8 @@\n+2003-11-12  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* docs/html/debug_mode.html: Update.\n+\t* docs/html/17_intro/TODO: Update.\n+\n 2003-11-12  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* include/bits/c++config: Move using directive..."}, {"sha": "1670f042e283c7c7d18c15c0a693ae666837386c", "filename": "libstdc++-v3/docs/html/17_intro/TODO", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89341602bbcb808995932a1f57725a585cd4b1a4/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2FTODO", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89341602bbcb808995932a1f57725a585cd4b1a4/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2FTODO", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2FTODO?ref=89341602bbcb808995932a1f57725a585cd4b1a4", "patch": "@@ -36,12 +36,18 @@ std::locale\n     functions and and LANG environment variable dependencies.\n \n   - use localedata to implement generic named (non-MT-safe) locales?\n-    Figure out a way to use ICU data, like libjava? Need a generic locale\n-    model that does something besides the \"C\" locale.\n+    Figure out a way to use ICU data, like libjava? Re-package and use\n+    the glibc localedata, even if we aren't on linux? Need a generic\n+    locale model that does something besides the \"C\" locale.\n \n   - make locale::classic() separate from named locale code. This will\n     improve the static linkage situation, but will require new\n-    initialization code.\n+    initialization code. In particular, we need lazy-initialization of\n+    locale::classic(), and maybe the has_facet/use_facet functions for all\n+    the required facets. The end goal is a self-contained\n+    locale_init.cc, or one with transitive closure without the locale\n+    instantiations (locale-inst.cc) or the named locale bits\n+    (localename.cc).\n \n   - Jerry(?)/Paolo(?) work on __float_to_char.\n \n@@ -52,9 +58,9 @@ std::locale\n std::basic_filebuf, 27_io\n \n   - wfilebuf, get variable-encoding working and tested, including\n-    positioning and seeking.\n+    positioning and seeking. (I think this may be done now)\n \n-  - wfilebuf testsuite\n+  - wfilebuf testsuite (getting there...)\n \n   - look ahead for unbuffered io, so know when multiple putc's can be\n     coalesced.\n@@ -90,9 +96,13 @@ testsuite\n \n g++/binutils\n \n-  - compression for wide versions of basic types\n+  - compression for wide versions of basic types, not just narrow\n \n-- get Apple's debug mode, or something with equivalent functionality, in.\n+threads\n+\n+  - create MT abstraction layer for atomicity to pthreads.\n+\n+  - solution for threads + C++.\n \n - audit for places where __builtin_expect can be used.\n \n@@ -157,8 +167,6 @@ sources, with macro-guards. Also, same with the TR.\n \n - add feature-test macros for non-standard extensions\n \n-- create MT abstraction layer for atomicity to pthreads.\n-\n - add MT support for locale, string, istream, ostream\n \n - need to think about doing a .texi or DocBook manual, instead of all"}, {"sha": "15e5af45163477739bd9367f104a8cc3dfc6ddfe", "filename": "libstdc++-v3/docs/html/debug_mode.html", "status": "modified", "additions": 149, "deletions": 105, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89341602bbcb808995932a1f57725a585cd4b1a4/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdebug_mode.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89341602bbcb808995932a1f57725a585cd4b1a4/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdebug_mode.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdebug_mode.html?ref=89341602bbcb808995932a1f57725a585cd4b1a4", "patch": "@@ -5,8 +5,8 @@\n \n <html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n <head>\n-   <meta name=\"AUTHOR\" content=\"dgregor@apple.com (Doug Gregor)\" />\n-   <meta name=\"KEYWORDS\" content=\"libstdc++, libstdc++-v3, GCC, g++, debug\" />\n+   <meta name=\"AUTHOR\" content=\"gregod@cs.rpi.edu (Doug Gregor)\" />\n+   <meta name=\"KEYWORDS\" content=\"C++, GCC, libstdc++, g++, debug\" />\n    <meta name=\"DESCRIPTION\" content=\"Design of the libstdc++ debug mode.\" />\n    <meta name=\"GENERATOR\" content=\"vi and eight fingers\" />\n    <title>Design of the libstdc++ debug mode</title>\n@@ -249,7 +249,7 @@ <h4><a name=\"safe_sequence\">Safe sequences (containers)</a></h4>\n   following basic structure:</p>\n \n <pre>\n-template&lt;typename _Tp, typename _Allocator = std::allocator&lt;_Tp&gt;\n+template&lt;typename _Tp, typename _Allocator = allocator&lt;_Tp&gt;\n   class debug-list :\n     public release-list&lt;_Tp, _Allocator&gt;,\n     public __gnu_debug::_Safe_sequence&lt;debug-list&lt;_Tp, _Allocator&gt; &gt;\n@@ -309,108 +309,144 @@ <h3><a name=\"coexistence\">Release- and debug-mode coexistence</a></h3>\n \n <p>Achieving link- and run-time coexistence is not a trivial\n   implementation task. To achieve this goal we required a small\n-  extension to the GNU C++ compiler (described in the section on\n-  <a href=\"#mixing\">link- and run-time coexistence</a>) and complex\n-  organization of debug- and release-modes. The end result is that we\n-  have achieved per-use recompilation but have had to give up some\n-  checking of the <code>std::basic_string</code> class template\n-  (namely, safe iterators).\n+  extension to the GNU C++ compiler (described in the GCC Manual for\n+  C++ Extensions, see <a href =\n+  http://gcc.gnu.org/onlinedocs/gcc/Strong-Using.html>strong\n+  using</a>), and a complex organization of debug- and\n+  release-modes. The end result is that we have achieved per-use\n+  recompilation but have had to give up some checking of the\n+  <code>std::basic_string</code> class template (namely, safe\n+  iterators).\n \n <h4><a name=\"compile_coexistence\">Compile-time coexistence of release- and\n     debug-mode components</a></h4>\n <p>Both the release-mode components and the debug-mode\n   components need to exist within a single translation unit so that\n   the debug versions can wrap the release versions. However, only one\n   of these components should be user-visible at any particular\n-  time with the standard name, e.g., <code>std::list</code>. In\n-  release mode, we define only the release-mode version of the\n+  time with the standard name, e.g., <code>std::list</code>. </p>\n+\n+<p>In release mode, we define only the release-mode version of the\n   component with its standard name and do not include the debugging\n-  component at all (except, perhaps, in <code>__gnu_debug</code>, if\n-  requested via the separate debugging headers). This method leaves the\n-  behavior of release mode completely unchanged from its behavior\n-  prior to the introduction of the libstdc++ debug mode.</p>\n-\n-<p>In debug mode we include the release-mode container into its\n-  natural namespace but perform renaming to an implementation-defined\n-  name using preprocessor macros. Thus the\n-  release-mode <code>std::list</code> will be renamed\n-  to <code>std::_Release_list</code> during debug mode, and we will\n-  automatically include the debugging version with the\n-  name <code>std::list</code> for users to reference. This method\n-  allows the debug- and release-mode versions of the same component to\n-  coexist at compile-time without causing an unreasonable maintenance\n-  burden.</p>\n+  component at all. The release mode version is defined within the\n+  namespace <code>__gnu_nom</code>, and then associated with namespace\n+  <code>std</code> via a \"strong using\" directive. Minus the\n+  namespace associations, this method leaves the behavior of release\n+  mode completely unchanged from its behavior prior to the\n+  introduction of the libstdc++ debug mode. Here's an example of what\n+  this ends up looking like, in C++.</p>\n+\n+<pre>\n+namespace __gnu_norm\n+{\n+  using namespace std; \n+  \n+  template&lt;typename _Tp, typename _Alloc = allocator&lt;_Tp&gt; &gt;\n+    class list\n+    {\n+      // ...\n+    };\n+} // namespace __gnu_norm\n+\n+namespace std\n+{\n+  using namespace __gnu_norm __attribute__ ((strong));\n+}\n+</pre>\n+  \n+<p>In debug mode we include the release-mode container and also the\n+debug-mode container. The release mode version is defined exactly as\n+before, and the debug-mode container is defined within the namespace\n+<code>__gnu_debug</code>, which is associated with namespace\n+<code>std</code> via a \"strong using\" directive.  This method allows\n+the debug- and release-mode versions of the same component to coexist\n+at compile-time without causing an unreasonable maintenance burden,\n+while minimizing confusion. Again, this boils down to C++ code as\n+follows:</p>\n+\n+<pre>\n+namespace __gnu_norm\n+{\n+  using namespace std; \n+  \n+  template&lt;typename _Tp, typename _Alloc = allocator&lt;_Tp&gt; &gt;\n+    class list\n+    {\n+      // ...\n+    };\n+} // namespace __gnu_norm\n+\n+namespace __gnu_debug\n+{\n+  using namespace std; \n+  \n+  template&lt;typename _Tp, typename _Alloc = allocator&lt;_Tp&gt; &gt;\n+    class list\n+    : public __gnu_norm::list&lt;_Tp, _Alloc&gt;,\n+      public __gnu_debug::_Safe_sequence&lt;list&lt;_Tp, _Alloc&gt; &gt;\n+    {\n+      // ...\n+    };\n+} // namespace __gnu_norm\n+\n+namespace std\n+{\n+  using namespace __gnu_debug __attribute__ ((strong));\n+}\n+</pre>\n \n <h4><a name=\"mixing\">Link- and run-time coexistence of release- and\n     debug-mode components</a></h4>\n-<p>There is a problem with the simple compile-time coexistence\n-  mechanism: if a user compiles some modules with release mode and\n-  some modules with debug mode, the debuggable components will differ\n-  in different translation units, violating the C++ One Definition\n-  Rule (ODR). This violation will likely be detected at link time,\n-  because the sizes of debug-mode containers will differ from the\n-  sizes of release-mode containers, although in some cases (such as\n-  dynamic linking) the error may be detected much later (or not at\n-  all!).</p>\n-\n-<p>Unfortunately, it is not possible to avoid violating the ODR with\n-  most debug mode designs (see the section on <a\n-  href=\"#coexistence_alt\">alternatives for coexistence</a>), so the\n-  philosophy of the libstdc++ debug mode is to acknowledge that there\n-  is an unavoidable ODR violation in this case but to ensure that the\n-  ODR violation does not affect execution. To accomplish this, the\n-  libstdc++ debug mode uses the aforementioned preprocessor renaming\n-  scheme but includes an additional renaming scheme that happens at\n-  compile-time that essentially reverses the preprocessor\n-  renaming <em>from the linker's point of view</em>. Thus, in debug\n-  mode, the release-mode <code>list</code> container is\n-  named <code>std::_Release_list</code> but will be mangled with the\n-  name <code>std::list</code> (as it was in release mode). Similarly,\n-  the debug-mode <code>list</code> is named <code>std::list</code>\n-  (in debug mode) but will be mangled\n-  as <code>std::_Debug_list</code>. Thus the\n-  release-mode <code>list</code> always compiles down to code that\n-  uses the name <code>std::list</code>, and the\n-  debug-mode <code>list</code> always compiles down to code that uses\n-  the name <code>std::_Debug_list</code>, independent of the use of\n-  debug mode. This has several positive effects:</p>\n \n-<ul>\n-  <li>No linking conflicts between debug/release objects: because the\n-  names of the debug- and release-mode containers are different in the\n-  compiled object files, there are no link-time conflicts between the\n-  two.</li>\n-\n-  <li>Release-mode code is shared: the release-mode code can be shared\n-  within a program, even with it is compiled partly in release-mode\n-  and partly in debug-mode, because the release-mode code is unchanged\n-  in name and function. This can decrease the size of mixed\n-  debug/release binaries.</li>\n-\n-  <li>Able to catch <em>most</em> invalid debug/release combinations:\n-  because the names of debug- and release-mode containers are\n-  different in the compiled object files, if a debug/release\n-  interaction cannot occur (e.g., because a container a translation\n-  unit compiled in debug mode is passed to a routine in a translation\n-  unit compiled in release mode) the result will be an undefined\n-  symbol at link time. The undefined symbol occurs because the mangled\n-  name of the definition will contain the release-mode container type\n-  and the mangled name of the reference will contain the debug-mode\n-  container type. However, we cannot detect these collisions if the\n-  only use of the container is in the return type, because the return\n-  type is not part of the mangled name of a function.</li>\n-</ul>\n+<p>Because each component has a distinct and separate release and\n+debug implementation, there are are no issues with link-time\n+coexistence: the separate namespaces result in different mangled\n+names, and thus unique linkage.</p>\n+\n+<p>However, components that are defined and used within the C++\n+standard library itself face additional constraints. For instance,\n+some of the member functions of <code> std::moneypunct</code> return\n+<code>std::basic_string</code>. Normally, this is not a problem, but\n+with a mixed mode standard library that could be using either\n+debug-mode or release-mode <code> basic_string</code> objects, things\n+get more complicated.  As the return value of a function is not\n+encoded into the mangled name, there is no way to specify a\n+release-mode or a debug-mode string. In practice, this results in\n+runtime errors. A simplified example of this problem is as follows.\n+</p>\n+\n+<p> Take this translation unit, compiled in debug-mode: <p>\n+<pre>\n+// -D_GLIBCXX_DEBUG\n+#include <string>\n+\n+std::string test02();\n+ \n+std::string test01()\n+{\n+  return test02();\n+}\n+ \n+int main()\n+{\n+  test01();\n+  return 0;\n+}\n+</pre>\n \n-<p>The new <code>link_name</code> class attribute facilities\n-  renaming. It may be attached to any class type (or any class\n-  template) to override the name of the class used for name\n-  mangling. For instance, a class named <code>bar</code> would\n-  generally mangle as <code>3bar</code>; if the class has\n-  a <code>link_name</code> attribute that specifies the string\n-  \"wibble\", then it would mangle as <code>6wibble</code>.</p>\n+<p> ... and linked to this translation unit, compiled in release mode:</p>\n \n-<p>Note that although we have hidden the ODR violation, it still\n-  exists. For this reason we cannot easily provide safe iterators for\n+<pre>\n+#include <string>\n+ \n+std::string\n+test02()\n+{\n+  return std::string(\"toast\");\n+}\n+</pre>\n+\n+<p> For this reason we cannot easily provide safe iterators for\n   the <code>std::basic_string</code> class template, as it is present\n   throughout the C++ standard library. For instance, locale facets\n   define typedefs that include <code>basic_string</code>: in a mixed\n@@ -445,7 +481,7 @@ <h4><a name=\"mixing\">Link- and run-time coexistence of release- and\n   release-compiled translation units is enormous.</p>\n \n <h4><a name=\"coexistence_alt\">Alternatives for Coexistence</a></h4>\n-<p>The coexistence scheme was chosen over many alternatives,\n+<p>The coexistence scheme above was chosen over many alternatives,\n   including language-only solutions and solutions that also required\n   extensions to the C++ front end. The following is a partial list of\n   solutions, with justifications for our rejection of each.</p>\n@@ -491,19 +527,12 @@ <h4><a name=\"coexistence_alt\">Alternatives for Coexistence</a></h4>\n       declarations disallow specialization. This method fails\n       the <b>correctness</b> criteria.</li>\n \n-  <li><em>Extension: allow template aliasing/renaming</em>: This is\n-    the runner-up to the <code>link_name</code> solution, eliminated\n-    only because it requires more extensive compiler changes\n-    than <code>link_name</code>. In this model, we would define the\n-    debug containers in a different namespace\n-    (e.g., <code>__gnu_debug</code>) and then import them (e.g., with\n-    an extended <code>using</code> declaration that aliases templates,\n-    such as that of <a\n-    href=\"http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1449.pdf\">template\n-    aliases</a> proposal). This solution is workable, and in fact\n-    would be desirable in the long run, but requires a sizeable change\n-    to the C++ compiler front-end that is not within the scope of\n-    this project.</li>\n+  <li><em> Use implementation-specific properties of anonymous\n+    namespaces. </em>\n+    See <a\n+    href=\"http://gcc.gnu.org/ml/libstdc++/2003-08/msg00004.html\"> this post\n+    </a> </li>\n+    This method fails the <b>correctness</b> criteria.</li>\n \n   <li><em>Extension: allow reopening on namespaces</em>: This would\n     allow the debug mode to effectively alias the\n@@ -518,6 +547,21 @@ <h4><a name=\"coexistence_alt\">Alternatives for Coexistence</a></h4>\n     recompilation</b> requirement, because we would only be able to\n     support option (1) or (2).</li>\n   </li>\n+\n+  <li><em>Extension: use link name</em>: This option involves\n+    complicated re-naming between debug-mode and release-mode\n+    components at compile time, and then a g++ extension called <em>\n+    link name </em> to recover the original names at link time. There\n+    are two drawbacks to this approach. One, it's very verbose,\n+    relying on macro renaming at compile time and several levels of\n+    include ordering. Two, ODR issues remained with container member\n+    functions taking no arguments in mixed-mode settings resulting in\n+    equivalent link names, <code> vector::push_back() </code> being\n+    one example. \n+    See <a\n+    href=\"http://gcc.gnu.org/ml/libstdc++/2003-08/msg00177.html\">link\n+    name</a> </li>\n+  </li>\n </ul>\n \n <p>Other options may exist for implementing the debug mode, many of"}]}