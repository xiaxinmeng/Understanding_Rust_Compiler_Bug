{"sha": "33b87152da3942dfc8f34c6447a6bfed307fca0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNiODcxNTJkYTM5NDJkZmM4ZjM0YzY0NDdhNmJmZWQzMDdmY2EwZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-10T14:00:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-10T14:00:07Z"}, "message": "[multiple changes]\n\n2014-10-10  Yannick Moy  <moy@adacore.com>\n\n\t* sem_prag.adb (Analyze_Global_Item): Accept formal objects in Global\n\tcontracts.\n\t* errout.adb, errout.ads (SPARK_Msg_NE): Issue error unless\n\tSPARK_Mode is Off.\n\n2014-10-10  Vadim Godunko  <godunko@adacore.com>\n\n\t* a-stwima.adb (To_Sequence): Compute size of result array.\n\n2014-10-10  Javier Miranda  <miranda@adacore.com>\n\n\t* gnat_ugn.texi (Interfacing with C++ at the Class Level): Update the\n\tsources of the example to avoid a warning when the Ada files are\n\tautomatically generated by the binding generator.\n\n2014-10-10  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb (Resolve_Attribute, case 'Update): Set\n\tDo_Range_Check on the expression of a record component\n\tassociation when needed, as is done for array components, when\n\tthe corresponding type is a scalar type.\n\nFrom-SVN: r216084", "tree": {"sha": "5231ddea3175709f5d3b32358b5c069cb2ef9ef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5231ddea3175709f5d3b32358b5c069cb2ef9ef6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33b87152da3942dfc8f34c6447a6bfed307fca0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33b87152da3942dfc8f34c6447a6bfed307fca0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33b87152da3942dfc8f34c6447a6bfed307fca0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33b87152da3942dfc8f34c6447a6bfed307fca0e/comments", "author": null, "committer": null, "parents": [{"sha": "79904ebc48b0103c5a11dcfb76ee7c37399a213a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79904ebc48b0103c5a11dcfb76ee7c37399a213a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79904ebc48b0103c5a11dcfb76ee7c37399a213a"}], "stats": {"total": 108, "additions": 79, "deletions": 29}, "files": [{"sha": "401751c6e9949dbc844069a4e3bc780b5586d566", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33b87152da3942dfc8f34c6447a6bfed307fca0e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33b87152da3942dfc8f34c6447a6bfed307fca0e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=33b87152da3942dfc8f34c6447a6bfed307fca0e", "patch": "@@ -1,3 +1,27 @@\n+2014-10-10  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Global_Item): Accept formal objects in Global\n+\tcontracts.\n+\t* errout.adb, errout.ads (SPARK_Msg_NE): Issue error unless\n+\tSPARK_Mode is Off.\n+\n+2014-10-10  Vadim Godunko  <godunko@adacore.com>\n+\n+\t* a-stwima.adb (To_Sequence): Compute size of result array.\n+\n+2014-10-10  Javier Miranda  <miranda@adacore.com>\n+\n+\t* gnat_ugn.texi (Interfacing with C++ at the Class Level): Update the\n+\tsources of the example to avoid a warning when the Ada files are\n+\tautomatically generated by the binding generator.\n+\n+2014-10-10  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_attr.adb (Resolve_Attribute, case 'Update): Set\n+\tDo_Range_Check on the expression of a record component\n+\tassociation when needed, as is done for array components, when\n+\tthe corresponding type is a scalar type.\n+\n 2014-10-10  Gary Dismukes  <dismukes@adacore.com>\n \n \t* a-coinho-shared.adb: Minor typo fix."}, {"sha": "c7ab14f4ac4d6bd20274787f11a28b3571edd1e8", "filename": "gcc/ada/a-stwima.adb", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33b87152da3942dfc8f34c6447a6bfed307fca0e/gcc%2Fada%2Fa-stwima.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33b87152da3942dfc8f34c6447a6bfed307fca0e/gcc%2Fada%2Fa-stwima.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stwima.adb?ref=33b87152da3942dfc8f34c6447a6bfed307fca0e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -567,20 +567,25 @@ package body Ada.Strings.Wide_Maps is\n    function To_Sequence\n      (Set : Wide_Character_Set) return Wide_Character_Sequence\n    is\n-      SS : constant Wide_Character_Ranges_Access := Set.Set;\n-\n-      Result : Wide_String (Positive range 1 .. 2 ** 16);\n-      N      : Natural := 0;\n+      SS    : constant Wide_Character_Ranges_Access := Set.Set;\n+      N     : Natural := 0;\n+      Count : Natural := 0;\n \n    begin\n       for J in SS'Range loop\n-         for K in SS (J).Low .. SS (J).High loop\n-            N := N + 1;\n-            Result (N) := K;\n-         end loop;\n+         Count :=\n+           Count + (Wide_Character'Pos (SS (J).High) -\n+                    Wide_Character'Pos (SS (J).Low) + 1);\n       end loop;\n \n-      return Result (1 .. N);\n+      return Result : Wide_String (1 .. Count) do\n+         for J in SS'Range loop\n+            for K in SS (J).Low .. SS (J).High loop\n+               N := N + 1;\n+               Result (N) := K;\n+            end loop;\n+         end loop;\n+      end return;\n    end To_Sequence;\n \n    ------------"}, {"sha": "f26059adbc3b78ff5dcea651ef542df9ef3e68d8", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33b87152da3942dfc8f34c6447a6bfed307fca0e/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33b87152da3942dfc8f34c6447a6bfed307fca0e/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=33b87152da3942dfc8f34c6447a6bfed307fca0e", "patch": "@@ -3153,7 +3153,7 @@ package body Errout is\n       E   : Node_Or_Entity_Id)\n    is\n    begin\n-      if SPARK_Mode = On then\n+      if SPARK_Mode /= Off then\n          Error_Msg_NE (Msg, N, E);\n       end if;\n    end SPARK_Msg_NE;"}, {"sha": "abde9b435ac9a675d1aea0c0938b794026ee7590", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33b87152da3942dfc8f34c6447a6bfed307fca0e/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33b87152da3942dfc8f34c6447a6bfed307fca0e/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=33b87152da3942dfc8f34c6447a6bfed307fca0e", "patch": "@@ -876,9 +876,8 @@ package Errout is\n       N   : Node_Or_Entity_Id;\n       E   : Node_Or_Entity_Id);\n    pragma Inline (SPARK_Msg_NE);\n-   --  Same as Error_Msg_NE, but the error is reported only when SPARK_Mode is\n-   --  \"on\". The routine is inlined because it acts as a simple wrapper.\n-   --  Is it right that this is so different from SPARK_Msg_N???\n+   --  Same as Error_Msg_NE, but the error is suppressed if SPARK_Mode is Off.\n+   --  The routine is inlined because it acts as a simple wrapper.\n \n    ------------------------------------\n    -- Utility Interface for Back End --"}, {"sha": "2c6aabd2ff804233407571d3ec4cf3ff323dff6a", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33b87152da3942dfc8f34c6447a6bfed307fca0e/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33b87152da3942dfc8f34c6447a6bfed307fca0e/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=33b87152da3942dfc8f34c6447a6bfed307fca0e", "patch": "@@ -2960,14 +2960,15 @@ constructors are defined on the C++ side and imported from the Ada\n side, and latter the reverse case.\n \n The root of our derivation will be the @code{Animal} class, with a\n-single private attribute (the @code{Age} of the animal) and two public\n-primitives to set and get the value of this attribute.\n+single private attribute (the @code{Age} of the animal), a constructor,\n+and two public primitives to set and get the value of this attribute.\n \n @smallexample\n @b{class} Animal @{\n  @b{public}:\n    @b{virtual} void Set_Age (int New_Age);\n    @b{virtual} int Age ();\n+   Animal() @{Age_Count = 0;@};\n  @b{private}:\n    int Age_Count;\n @};\n@@ -3013,19 +3014,19 @@ how to import these C++ declarations from the Ada side:\n @smallexample @c ada\n @b{with} Interfaces.C.Strings; @b{use} Interfaces.C.Strings;\n @b{package} Animals @b{is}\n-  @b{type} Carnivore @b{is} interface;\n+  @b{type} Carnivore @b{is} @b{limited} interface;\n   @b{pragma} Convention (C_Plus_Plus, Carnivore);\n   @b{function} Number_Of_Teeth (X : Carnivore)\n      @b{return} Natural @b{is} @b{abstract};\n \n-  @b{type} Domestic @b{is} interface;\n-  @b{pragma} Convention (C_Plus_Plus, Set_Owner);\n+  @b{type} Domestic @b{is} @b{limited} interface;\n+  @b{pragma} Convention (C_Plus_Plus, Domestic);\n   @b{procedure} Set_Owner\n     (X    : @b{in} @b{out} Domestic;\n      Name : Chars_Ptr) @b{is} @b{abstract};\n \n-  @b{type} Animal @b{is} @b{tagged} @b{record}\n-    Age : Natural := 0;\n+  @b{type} Animal @b{is} @b{tagged} @b{limited} @b{record}\n+    Age : Natural;\n   @b{end} @b{record};\n   @b{pragma} Import (C_Plus_Plus, Animal);\n \n@@ -3035,13 +3036,17 @@ how to import these C++ declarations from the Ada side:\n   @b{function} Age (X : Animal) @b{return} Integer;\n   @b{pragma} Import (C_Plus_Plus, Age);\n \n+  @b{function} New_Animal @b{return} Animal;\n+  @b{pragma} CPP_Constructor (New_Animal);\n+  @b{pragma} Import (CPP, New_Animal, \"_ZN6AnimalC1Ev\");\n+\n   @b{type} Dog @b{is} @b{new} Animal @b{and} Carnivore @b{and} Domestic @b{with} @b{record}\n     Tooth_Count : Natural;\n     Owner       : String (1 .. 30);\n   @b{end} @b{record};\n   @b{pragma} Import (C_Plus_Plus, Dog);\n \n-  @b{function} Number_Of_Teeth (A : Dog) @b{return} Integer;\n+  @b{function} Number_Of_Teeth (A : Dog) @b{return} Natural;\n   @b{pragma} Import (C_Plus_Plus, Number_Of_Teeth);\n \n   @b{procedure} Set_Owner (A : @b{in} @b{out} Dog; Name : Chars_Ptr);\n@@ -3100,19 +3105,19 @@ them to C++, using the same hierarchy of our previous example:\n @b{with} Interfaces.C.Strings;\n @b{use} Interfaces.C.Strings;\n @b{package} Animals @b{is}\n-  @b{type} Carnivore @b{is} interface;\n+  @b{type} Carnivore @b{is} @b{limited} interface;\n   @b{pragma} Convention (C_Plus_Plus, Carnivore);\n   @b{function} Number_Of_Teeth (X : Carnivore)\n      @b{return} Natural @b{is} @b{abstract};\n \n-  @b{type} Domestic @b{is} interface;\n-  @b{pragma} Convention (C_Plus_Plus, Set_Owner);\n+  @b{type} Domestic @b{is} @b{limited} interface;\n+  @b{pragma} Convention (C_Plus_Plus, Domestic);\n   @b{procedure} Set_Owner\n     (X    : @b{in} @b{out} Domestic;\n      Name : Chars_Ptr) @b{is} @b{abstract};\n \n   @b{type} Animal @b{is} @b{tagged} @b{record}\n-    Age : Natural := 0;\n+    Age : Natural;\n   @b{end} @b{record};\n   @b{pragma} Convention (C_Plus_Plus, Animal);\n \n@@ -3122,13 +3127,16 @@ them to C++, using the same hierarchy of our previous example:\n   @b{function} Age (X : Animal) @b{return} Integer;\n   @b{pragma} Export (C_Plus_Plus, Age);\n \n+  @b{function} New_Animal @b{return} Animal'Class;\n+  @b{pragma} Export (C_Plus_Plus, New_Animal);\n+\n   @b{type} Dog @b{is} @b{new} Animal @b{and} Carnivore @b{and} Domestic @b{with} @b{record}\n     Tooth_Count : Natural;\n     Owner       : String (1 .. 30);\n   @b{end} @b{record};\n   @b{pragma} Convention (C_Plus_Plus, Dog);\n \n-  @b{function} Number_Of_Teeth (A : Dog) @b{return} Integer;\n+  @b{function} Number_Of_Teeth (A : Dog) @b{return} Natural;\n   @b{pragma} Export (C_Plus_Plus, Number_Of_Teeth);\n \n   @b{procedure} Set_Owner (A : @b{in} @b{out} Dog; Name : Chars_Ptr);\n@@ -3139,7 +3147,8 @@ them to C++, using the same hierarchy of our previous example:\n @b{end} Animals;\n @end smallexample\n \n-Compared with our previous example the only difference is the use of\n+Compared with our previous example the only differences are the use of\n+@code{pragma Convention} (instead of @code{pragma Import}), and the use of\n @code{pragma Export} to indicate to the GNAT compiler that the primitives will\n be available to C++. Thanks to the ABI compatibility, on the C++ side there is\n nothing else to be done; as explained above, the only requirement is that all"}, {"sha": "7906041d08bd02dab9a3194a7f4e2467e8dfbcb7", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33b87152da3942dfc8f34c6447a6bfed307fca0e/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33b87152da3942dfc8f34c6447a6bfed307fca0e/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=33b87152da3942dfc8f34c6447a6bfed307fca0e", "patch": "@@ -11021,13 +11021,21 @@ package body Sem_Attr is\n \n                else\n                   Assoc := First (Component_Associations (Aggr));\n+\n                   while Present (Assoc) loop\n                      Comp := First (Choices (Assoc));\n+                     Expr := Expression (Assoc);\n \n                      if Nkind (Comp) /= N_Others_Choice\n                        and then not Error_Posted (Comp)\n                      then\n-                        Resolve (Expression (Assoc), Etype (Entity (Comp)));\n+                        Resolve (Expr, Etype (Entity (Comp)));\n+\n+                        if Is_Scalar_Type (Etype (Entity (Comp)))\n+                          and then not Is_OK_Static_Expression (Expr)\n+                        then\n+                           Set_Do_Range_Check (Expr);\n+                        end if;\n                      end if;\n \n                      Next (Assoc);"}, {"sha": "ec0441961df8c7a61376df72052273a4245ca990", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33b87152da3942dfc8f34c6447a6bfed307fca0e/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33b87152da3942dfc8f34c6447a6bfed307fca0e/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=33b87152da3942dfc8f34c6447a6bfed307fca0e", "patch": "@@ -1977,6 +1977,11 @@ package body Sem_Prag is\n                elsif Ekind (Item_Id) = E_Constant then\n                   SPARK_Msg_N (\"global item cannot denote a constant\", Item);\n \n+               --  A formal object may act as a global item inside a generic\n+\n+               elsif Is_Formal_Object (Item_Id) then\n+                  null;\n+\n                --  The only legal references are those to abstract states and\n                --  variables (SPARK RM 6.1.4(4)).\n "}]}