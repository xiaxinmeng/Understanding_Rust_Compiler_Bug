{"sha": "fac665b24a55893660c3c7e60fb92037181e8f0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFjNjY1YjI0YTU1ODkzNjYwYzNjN2U2MGZiOTIwMzcxODFlOGYwYw==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2011-12-19T08:15:47Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-12-19T08:15:47Z"}, "message": "check.c (coarray_check): Add class ref if needed.\n\n2011-12-19  Tobias Burnus  <burnus@net-b.de>\n\n        * check.c (coarray_check): Add class ref if needed.\n        * resolve.c (resolve_fl_var_and_proc,\n        resolve_fl_derived0, resolve_symbol): Fix checking\n        for BT_CLASS.\n\n2011-12-19  Tobias Burnus  <burnus@net-b.de>\n\n        * gfortran.dg/coarray_poly_3.f90: New.\n        * coarray/poly_run_1.f90: Enable some previously commented code.\n\nFrom-SVN: r182471", "tree": {"sha": "88e897b8431b8cdd2e0e6cf3dc40728adef39e0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88e897b8431b8cdd2e0e6cf3dc40728adef39e0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fac665b24a55893660c3c7e60fb92037181e8f0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fac665b24a55893660c3c7e60fb92037181e8f0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fac665b24a55893660c3c7e60fb92037181e8f0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fac665b24a55893660c3c7e60fb92037181e8f0c/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "37ef545a763f325576a837b39d5a908c5e5ca1d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37ef545a763f325576a837b39d5a908c5e5ca1d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37ef545a763f325576a837b39d5a908c5e5ca1d9"}], "stats": {"total": 346, "additions": 297, "deletions": 49}, "files": [{"sha": "9d7d7c744efe13aca30a9d49582103d6ab81cb83", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fac665b24a55893660c3c7e60fb92037181e8f0c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fac665b24a55893660c3c7e60fb92037181e8f0c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fac665b24a55893660c3c7e60fb92037181e8f0c", "patch": "@@ -1,3 +1,10 @@\n+2011-12-19  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* check.c (coarray_check): Add class ref if needed.\n+\t* resolve.c (resolve_fl_var_and_proc,\n+\tresolve_fl_derived0, resolve_symbol): Fix checking\n+\tfor BT_CLASS.\n+\n 2011-12-15  Paul Thomas  <pault@gcc.gnu.org>\n \n \t* trans-expr.c (gfc_walk_function_expr): Detect elemental"}, {"sha": "cb6b94f7f18c7fee4d2feb3707d1a94d27d11d54", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fac665b24a55893660c3c7e60fb92037181e8f0c/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fac665b24a55893660c3c7e60fb92037181e8f0c/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=fac665b24a55893660c3c7e60fb92037181e8f0c", "patch": "@@ -206,6 +206,14 @@ double_check (gfc_expr *d, int n)\n static gfc_try\n coarray_check (gfc_expr *e, int n)\n {\n+  if (e->ts.type == BT_CLASS && gfc_expr_attr (e).class_ok\n+\t&& CLASS_DATA (e)->attr.codimension\n+\t&& CLASS_DATA (e)->as->corank)\n+    {\n+      gfc_add_class_array_ref (e);\n+      return SUCCESS;\n+    }\n+\n   if (!gfc_is_coarray (e))\n     {\n       gfc_error (\"Expected coarray variable as '%s' argument to the %s \"\n@@ -240,7 +248,7 @@ logical_array_check (gfc_expr *array, int n)\n static gfc_try\n array_check (gfc_expr *e, int n)\n {\n-  if (e->ts.type == BT_CLASS\n+  if (e->ts.type == BT_CLASS && gfc_expr_attr (e).class_ok\n \t&& CLASS_DATA (e)->attr.dimension\n \t&& CLASS_DATA (e)->as->rank)\n     {"}, {"sha": "5e8371a622b285bd1e54ed613f84a365e26f8bbc", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 95, "deletions": 40, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fac665b24a55893660c3c7e60fb92037181e8f0c/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fac665b24a55893660c3c7e60fb92037181e8f0c/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=fac665b24a55893660c3c7e60fb92037181e8f0c", "patch": "@@ -10070,17 +10070,39 @@ apply_default_init_local (gfc_symbol *sym)\n static gfc_try\n resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n {\n+  gfc_array_spec *as;\n+\n   /* Avoid double diagnostics for function result symbols.  */\n   if ((sym->result || sym->attr.result) && !sym->attr.dummy\n       && (sym->ns != gfc_current_ns))\n     return SUCCESS;\n \n+  if (sym->ts.type == BT_CLASS && sym->attr.class_ok)\n+    as = CLASS_DATA (sym)->as;\n+  else\n+    as = sym->as;\n+\n   /* Constraints on deferred shape variable.  */\n-  if (sym->as == NULL || sym->as->type != AS_DEFERRED)\n+  if (as == NULL || as->type != AS_DEFERRED)\n     {\n-      if (sym->attr.allocatable)\n+      bool pointer, allocatable, dimension;\n+\n+      if (sym->ts.type == BT_CLASS && sym->attr.class_ok)\n \t{\n-\t  if (sym->attr.dimension)\n+\t  pointer = CLASS_DATA (sym)->attr.class_pointer;\n+\t  allocatable = CLASS_DATA (sym)->attr.allocatable;\n+\t  dimension = CLASS_DATA (sym)->attr.dimension;\n+\t}\n+      else\n+\t{\n+\t  pointer = sym->attr.pointer;\n+\t  allocatable = sym->attr.allocatable;\n+\t  dimension = sym->attr.dimension;\n+\t}\n+\n+      if (allocatable)\n+\t{\n+\t  if (dimension)\n \t    {\n \t      gfc_error (\"Allocatable array '%s' at %L must have \"\n \t\t\t \"a deferred shape\", sym->name, &sym->declared_at);\n@@ -10092,7 +10114,7 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n \t    return FAILURE;\n \t}\n \n-      if (sym->attr.pointer && sym->attr.dimension)\n+      if (pointer && dimension)\n \t{\n \t  gfc_error (\"Array pointer '%s' at %L must have a deferred shape\",\n \t\t     sym->name, &sym->declared_at);\n@@ -11430,7 +11452,10 @@ resolve_fl_derived0 (gfc_symbol *sym)\n       return FAILURE;\n     }\n \n-  for (c = sym->components; c != NULL; c = c->next)\n+  c = (sym->attr.is_class) ? sym->components->ts.u.derived->components\n+\t\t\t   : sym->components;\n+\n+  for ( ; c != NULL; c = c->next)\n     {\n       /* See PRs 51550, 47545, 48654, 49050, 51075 - and 45170.  */\n       if (c->ts.type == BT_CHARACTER && c->ts.deferred)\n@@ -11658,13 +11683,21 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t}\n \n       /* Check type-spec if this is not the parent-type component.  */\n-      if ((!sym->attr.extension || c != sym->components) && !sym->attr.vtype\n+      if (((sym->attr.is_class\n+\t    && (!sym->components->ts.u.derived->attr.extension\n+\t\t|| c != sym->components->ts.u.derived->components))\n+\t   || (!sym->attr.is_class\n+\t       && (!sym->attr.extension || c != sym->components)))\n+\t  && !sym->attr.vtype\n \t  && resolve_typespec_used (&c->ts, &c->loc, c->name) == FAILURE)\n \treturn FAILURE;\n \n       /* If this type is an extension, set the accessibility of the parent\n \t component.  */\n-      if (super_type && c == sym->components\n+      if (super_type\n+\t  && ((sym->attr.is_class\n+\t       && c == sym->components->ts.u.derived->components)\n+\t      || (!sym->attr.is_class && c == sym->components))\n \t  && strcmp (super_type->name, c->name) == 0)\n \tc->attr.access = super_type->attr.access;\n       \n@@ -12044,6 +12077,8 @@ resolve_symbol (gfc_symbol *sym)\n   gfc_symtree *this_symtree;\n   gfc_namespace *ns;\n   gfc_component *c;\n+  symbol_attribute class_attr;\n+  gfc_array_spec *as;\n \n   if (sym->attr.flavor == FL_UNKNOWN)\n     {\n@@ -12100,18 +12135,6 @@ resolve_symbol (gfc_symbol *sym)\n       return;\n     }\n \n-\n-  /* F2008, C530. */\n-  if (sym->attr.contiguous\n-      && (!sym->attr.dimension || (sym->as->type != AS_ASSUMED_SHAPE\n-\t\t\t\t   && !sym->attr.pointer)))\n-    {\n-      gfc_error (\"'%s' at %L has the CONTIGUOUS attribute but is not an \"\n-\t\t  \"array pointer or an assumed-shape array\", sym->name,\n-\t\t  &sym->declared_at);\n-      return;\n-    }\n-\n   if (sym->attr.flavor == FL_DERIVED && resolve_fl_derived (sym) == FAILURE)\n     return;\n \n@@ -12137,7 +12160,9 @@ resolve_symbol (gfc_symbol *sym)\n   if (sym->ts.type == BT_UNKNOWN)\n     {\n       if (sym->attr.flavor == FL_VARIABLE || sym->attr.flavor == FL_PARAMETER)\n-\tgfc_set_default_type (sym, 1, NULL);\n+\t{\n+\t  gfc_set_default_type (sym, 1, NULL);\n+\t}\n \n       if (sym->attr.flavor == FL_PROCEDURE && sym->attr.external\n \t  && !sym->attr.function && !sym->attr.subroutine\n@@ -12170,18 +12195,41 @@ resolve_symbol (gfc_symbol *sym)\n   else if (mp_flag && sym->attr.flavor == FL_PROCEDURE && sym->attr.function)\n     gfc_resolve_array_spec (sym->result->as, false);\n \n+  if (sym->ts.type == BT_CLASS && sym->attr.class_ok)\n+    {\n+      as = CLASS_DATA (sym)->as;\n+      class_attr = CLASS_DATA (sym)->attr;\n+      class_attr.pointer = class_attr.class_pointer;\n+    }\n+  else\n+    {\n+      class_attr = sym->attr;\n+      as = sym->as;\n+    }\n+\n+  /* F2008, C530. */\n+  if (sym->attr.contiguous\n+      && (!class_attr.dimension\n+\t  || (as->type != AS_ASSUMED_SHAPE && !class_attr.pointer)))\n+    {\n+      gfc_error (\"'%s' at %L has the CONTIGUOUS attribute but is not an \"\n+\t\t  \"array pointer or an assumed-shape array\", sym->name,\n+\t\t  &sym->declared_at);\n+      return;\n+    }\n+\n   /* Assumed size arrays and assumed shape arrays must be dummy\n      arguments.  Array-spec's of implied-shape should have been resolved to\n      AS_EXPLICIT already.  */\n \n-  if (sym->as)\n+  if (as)\n     {\n-      gcc_assert (sym->as->type != AS_IMPLIED_SHAPE);\n-      if (((sym->as->type == AS_ASSUMED_SIZE && !sym->as->cp_was_assumed)\n-\t   || sym->as->type == AS_ASSUMED_SHAPE)\n+      gcc_assert (as->type != AS_IMPLIED_SHAPE);\n+      if (((as->type == AS_ASSUMED_SIZE && !as->cp_was_assumed)\n+\t   || as->type == AS_ASSUMED_SHAPE)\n \t  && sym->attr.dummy == 0)\n \t{\n-\t  if (sym->as->type == AS_ASSUMED_SIZE)\n+\t  if (as->type == AS_ASSUMED_SIZE)\n \t    gfc_error (\"Assumed size array at %L must be a dummy argument\",\n \t\t       &sym->declared_at);\n \t  else\n@@ -12393,8 +12441,10 @@ resolve_symbol (gfc_symbol *sym)\n     }\n \n   /* F2008, C525.  */\n-  if (((sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.coarray_comp)\n-       || sym->attr.codimension)\n+  if ((((sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.coarray_comp)\n+\t || (sym->ts.type == BT_CLASS && sym->attr.class_ok\n+\t     && CLASS_DATA (sym)->attr.coarray_comp))\n+       || class_attr.codimension)\n       && (sym->attr.result || sym->result == sym))\n     {\n       gfc_error (\"Function result '%s' at %L shall not be a coarray or have \"\n@@ -12412,9 +12462,11 @@ resolve_symbol (gfc_symbol *sym)\n     }\n \n   /* F2008, C525.  */\n-  if (sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.coarray_comp\n-      && (sym->attr.codimension || sym->attr.pointer || sym->attr.dimension\n-\t  || sym->attr.allocatable))\n+  if (((sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.coarray_comp)\n+\t|| (sym->ts.type == BT_CLASS && sym->attr.class_ok\n+\t    && CLASS_DATA (sym)->attr.coarray_comp))\n+      && (class_attr.codimension || class_attr.pointer || class_attr.dimension\n+\t  || class_attr.allocatable))\n     {\n       gfc_error (\"Variable '%s' at %L with coarray component \"\n \t\t \"shall be a nonpointer, nonallocatable scalar\",\n@@ -12423,8 +12475,9 @@ resolve_symbol (gfc_symbol *sym)\n     }\n \n   /* F2008, C526.  The function-result case was handled above.  */\n-  if (sym->attr.codimension\n-      && !(sym->attr.allocatable || sym->attr.dummy || sym->attr.save\n+  if (class_attr.codimension\n+      && !(class_attr.allocatable || sym->attr.dummy || sym->attr.save\n+\t   || sym->attr.select_type_temporary\n \t   || sym->ns->save_all\n \t   || sym->ns->proc_name->attr.flavor == FL_MODULE\n \t   || sym->ns->proc_name->attr.is_main_program\n@@ -12434,25 +12487,27 @@ resolve_symbol (gfc_symbol *sym)\n \t\t \"nor a dummy argument\", sym->name, &sym->declared_at);\n       return;\n     }\n-  /* F2008, C528.  */  /* FIXME: sym->as check due to PR 43412.  */\n-  else if (sym->attr.codimension && !sym->attr.allocatable\n-      && sym->as && sym->as->cotype == AS_DEFERRED)\n+  /* F2008, C528.  */\n+  else if (class_attr.codimension && !sym->attr.select_type_temporary\n+\t   && !class_attr.allocatable && as && as->cotype == AS_DEFERRED)\n     {\n       gfc_error (\"Coarray variable '%s' at %L shall not have codimensions with \"\n \t\t \"deferred shape\", sym->name, &sym->declared_at);\n       return;\n     }\n-  else if (sym->attr.codimension && sym->attr.allocatable\n-      && (sym->as->type != AS_DEFERRED || sym->as->cotype != AS_DEFERRED))\n+  else if (class_attr.codimension && class_attr.allocatable && as\n+\t   && (as->cotype != AS_DEFERRED || as->type != AS_DEFERRED))\n     {\n       gfc_error (\"Allocatable coarray variable '%s' at %L must have \"\n \t\t \"deferred shape\", sym->name, &sym->declared_at);\n       return;\n     }\n \n   /* F2008, C541.  */\n-  if (((sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.coarray_comp)\n-       || (sym->attr.codimension && sym->attr.allocatable))\n+  if ((((sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.coarray_comp)\n+\t|| (sym->ts.type == BT_CLASS && sym->attr.class_ok\n+\t    && CLASS_DATA (sym)->attr.coarray_comp))\n+       || (class_attr.codimension && class_attr.allocatable))\n       && sym->attr.dummy && sym->attr.intent == INTENT_OUT)\n     {\n       gfc_error (\"Variable '%s' at %L is INTENT(OUT) and can thus not be an \"\n@@ -12461,7 +12516,7 @@ resolve_symbol (gfc_symbol *sym)\n       return;\n     }\n \n-  if (sym->attr.codimension && sym->attr.dummy\n+  if (class_attr.codimension && sym->attr.dummy\n       && sym->ns->proc_name && sym->ns->proc_name->attr.is_bind_c)\n     {\n       gfc_error (\"Coarray dummy variable '%s' at %L not allowed in BIND(C) \""}, {"sha": "936ef1ae23347674af96525b7a25ba7e53d526e9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fac665b24a55893660c3c7e60fb92037181e8f0c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fac665b24a55893660c3c7e60fb92037181e8f0c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fac665b24a55893660c3c7e60fb92037181e8f0c", "patch": "@@ -1,3 +1,8 @@\n+2011-12-19  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.dg/coarray_poly_3.f90: New.\n+\t* coarray/poly_run_1.f90: Enable some previously commented code.\n+\n 2011-12-19  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/51489"}, {"sha": "436c1d410fddb8f05063a4ee48269e7110992301", "filename": "gcc/testsuite/gfortran.dg/coarray/poly_run_1.f90", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fac665b24a55893660c3c7e60fb92037181e8f0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fpoly_run_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fac665b24a55893660c3c7e60fb92037181e8f0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fpoly_run_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fpoly_run_1.f90?ref=fac665b24a55893660c3c7e60fb92037181e8f0c", "patch": "@@ -14,7 +14,7 @@\n end if\n if (allocated(A)) i = 5\n call s(A)\n-!call t(A) ! FIXME\n+!call st(A) ! FIXME\n \n contains\n \n@@ -23,21 +23,29 @@ subroutine s(x)\n   if (any (lcobound(x) /= [1, -5])) call abort ()\n   if (num_images() == 1) then\n     if (any (ucobound(x) /= [4, -5])) call abort ()\n-! FIXME: Tree-walking issue?\n-!  else\n-!    if (ucobound(x,dim=1) /= 4) call abort ()\n+  else\n+    if (ucobound(x,dim=1) /= 4) call abort ()\n   end if\n end subroutine s\n \n+subroutine st(x)\n+  class(t) :: x(:)[4,2:*]\n ! FIXME\n-!subroutine st(x)\n-!  class(t),allocatable :: x(:)[:,:]\n !  if (any (lcobound(x) /= [1, 2])) call abort ()\n+!  if (lcobound(x, dim=1) /= 1) call abort ()\n+!  if (lcobound(x, dim=2) /= 2) call abort ()\n+!  if (this_image() == 1) then\n+!     if (any (this_image(x) /= lcobound(x))) call abort ()\n+!     if (this_image(x, dim=1) /= lcobound(x, dim=1)) call abort ()\n+!     if (this_image(x, dim=2) /= lcobound(x, dim=2)) call abort ()\n+!  end if\n !  if (num_images() == 1) then\n-!    if (any (ucobound(x) /= [4, 2])) call abort ()\n+!     if (any (ucobound(x) /= [4, 2])) call abort ()\n+!     if (ucobound(x, dim=1) /= 4) call abort ()\n+!     if (ucobound(x, dim=2) /= 2) call abort ()\n !  else\n !    if (ucobound(x,dim=1) /= 4) call abort ()\n !  end if\n-!end subroutine st\n+end subroutine st\n end\n "}, {"sha": "e6b19ae8937e36406b438e71e7d5a7d2f6917c00", "filename": "gcc/testsuite/gfortran.dg/coarray_poly_3.f90", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fac665b24a55893660c3c7e60fb92037181e8f0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fac665b24a55893660c3c7e60fb92037181e8f0c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_poly_3.f90?ref=fac665b24a55893660c3c7e60fb92037181e8f0c", "patch": "@@ -0,0 +1,165 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+\n+\n+subroutine cont1(x) ! { dg-error \"has the CONTIGUOUS attribute but is not an array pointer or an assumed-shape array\" }\n+  type t\n+  end type t\n+  class(t), contiguous, allocatable :: x(:)\n+end\n+\n+subroutine cont2(x) ! { dg-error \"has the CONTIGUOUS attribute but is not an array pointer or an assumed-shape array\" }\n+  type t\n+  end type t\n+  class(t), contiguous, allocatable :: x(:)[:]\n+end\n+\n+subroutine cont3(x, y)\n+  type t\n+  end type t\n+  class(t), contiguous, pointer :: x(:)\n+  class(t), contiguous :: y(:)\n+end\n+\n+function func() ! { dg-error \"shall not be a coarray or have a coarray component\" }\n+  type t\n+  end type t\n+  class(t), allocatable :: func[*] ! { dg-error \"\"\n+end\n+\n+function func2() ! { dg-error \"must be dummy, allocatable or pointer\" }\n+  type t\n+    integer, allocatable :: caf[:]\n+  end type t\n+  class(t) :: func2a ! { dg-error \"CLASS variable 'func2a' at .1. must be dummy, allocatable or pointer\" }\n+  class(t) :: func2 ! {CLASS variable 'func' at (1) must be dummy, allocatable or pointer\n+end\n+\n+subroutine foo1(x1) ! { dg-error \"Coarray variable 'x1' at .1. shall not have codimensions with deferred shape\" }\n+  type t\n+  end type t\n+  type(t) :: x1(:)[:]\n+end\n+\n+subroutine foo2(x2) ! { dg-error \"Coarray variable 'x2' at .1. shall not have codimensions with deferred shape\" }\n+  type t\n+  end type t\n+  type(t) :: x2[:]\n+end\n+\n+\n+! DITTO FOR CLASS\n+\n+subroutine foo3(x1) ! { dg-error \"Coarray variable 'x1' at .1. shall not have codimensions with deferred shape\" }\n+  type t\n+  end type t\n+  class(t) :: x1(:)[:]\n+end\n+\n+subroutine foo4(x2) ! { dg-error \"Coarray variable 'x2' at .1. shall not have codimensions with deferred shape\" }\n+  type t\n+  end type t\n+  class(t) :: x2[:]\n+end\n+\n+\n+\n+\n+subroutine bar1(y1) ! { dg-error \"Allocatable coarray variable 'y1' at .1. must have deferred shape\" }\n+  type t\n+  end type t\n+  type(t), allocatable :: y1(:)[5:*]\n+end\n+\n+subroutine bar2(y2) ! { dg-error \"Allocatable coarray variable 'y2' at .1. must have deferred shape\" }\n+  type t\n+  end type t\n+  type(t), allocatable :: y2[5:*]\n+end\n+\n+subroutine bar3(z1) ! { dg-error \"Allocatable coarray variable 'z1' at .1. must have deferred shape\" }\n+  type t\n+  end type t\n+  type(t), allocatable :: z1(5)[:]\n+end\n+\n+subroutine bar4(z2) ! { dg-error \"Allocatable array 'z2' at .1. must have a deferred shape\" }\n+  type t\n+  end type t\n+  type(t), allocatable :: z2(5)\n+end subroutine bar4\n+\n+subroutine bar5(z3) ! { dg-error \"Array pointer 'z3' at .1. must have a deferred shape\" }\n+  type t\n+  end type t\n+  type(t), pointer :: z3(5)\n+end subroutine bar5\n+\n+\n+\n+\n+! DITTO FOR CLASS\n+\n+subroutine bar1c(y1) ! { dg-error \"Allocatable coarray variable 'y1' at .1. must have deferred shape\" }\n+  type t\n+  end type t\n+  class(t), allocatable :: y1(:)[5:*]\n+end\n+\n+subroutine bar2c(y2) ! { dg-error \"Allocatable coarray variable 'y2' at .1. must have deferred shape\" }\n+  type t\n+  end type t\n+  class(t), allocatable :: y2[5:*]\n+end\n+\n+subroutine bar3c(z1) ! { dg-error \"Allocatable coarray variable 'z1' at .1. must have deferred shape\" }\n+  type t\n+  end type t\n+  class(t), allocatable :: z1(5)[:]\n+end\n+\n+subroutine bar4c(z2) ! { dg-error \"Allocatable array 'z2' at .1. must have a deferred shape\" }\n+  type t\n+  end type t\n+  class(t), allocatable :: z2(5)\n+end subroutine bar4c\n+\n+subroutine bar5c(z3) ! { dg-error \"Array pointer 'z3' at .1. must have a deferred shape\" }\n+  type t\n+  end type t\n+  class(t), pointer :: z3(5)\n+end subroutine bar5c\n+\n+\n+subroutine sub()\n+  type t\n+  end type\n+  type(t) :: a(5)\n+  class(t), allocatable :: b(:)\n+  call inter(a)\n+  call inter(b)\n+contains\n+  subroutine inter(x)\n+    class(t) :: x(5)\n+  end subroutine inter\n+end subroutine sub\n+\n+subroutine sub2()\n+  type t\n+  end type\n+  type(t) :: a(5)\n+contains\n+  subroutine inter(x)\n+    class(t) :: x(5)\n+  end subroutine inter\n+end subroutine sub2\n+\n+subroutine sub3()\n+  type t\n+  end type\n+contains\n+  subroutine inter2(x) ! { dg-error \"must have a deferred shape\" }\n+    class(t), pointer :: x(5)\n+  end subroutine inter2\n+end subroutine sub3"}]}