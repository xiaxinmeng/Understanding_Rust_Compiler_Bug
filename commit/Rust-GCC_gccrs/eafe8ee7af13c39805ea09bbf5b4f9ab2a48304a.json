{"sha": "eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFmZThlZTdhZjEzYzM5ODA1ZWEwOWJiZjViNGY5YWIyYTQ4MzA0YQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-11-29T22:09:30Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-11-29T22:12:32Z"}, "message": "Handle PHIs in compute_objsize.\n\nPR middle-end/92936 - missing warning on a past-the-end store to a PHI\nPR middle-end/92940 - incorrect offset and size in -Wstringop-overflow for out-of-bounds store into VLA and two offset ranges\nPR middle-end/89428 - missing -Wstringop-overflow on a PHI with variable offset\n\ngcc/ChangeLog:\n\n\tPR middle-end/92936\n\tPR middle-end/92940\n\tPR middle-end/89428\n\t* builtins.c (access_ref::access_ref): Initialize member.\n\t(access_ref::phi): New function.\n\t(access_ref::get_ref): New function.\n\t(access_ref::add_offset): Remove duplicate assignment.\n\t(maybe_warn_for_bound): Add \"maybe\" kind of warning messages.\n\t(warn_for_access): Same.\n\t(inform_access): Rename...\n\t(access_ref::inform_access): ...to this.  Print PHI arguments.  Format\n\toffset the same as size and simplify.  Improve printing of allocation\n\tfunctions and VLAs.\n\t(check_access): Adjust to the above.\n\t(gimple_parm_array_size): Change argument.\n\t(handle_min_max_size): New function.\n\t* builtins.h (class ssa_name_limit_t): Move class here from\n\ttree-ssa-strlen.c.\n\t(struct access_ref): Declare new members.\n\t(gimple_parm_array_size): Change argument.\n\t* tree-ssa-strlen.c (maybe_warn_overflow): Use access_ref and simplify.\n\t(handle_builtin_memcpy): Correct argument passed to maybe_warn_overflow.\n\t(handle_builtin_memset): Same.\n\t(class ssa_name_limit_t): Move class to builtins.{h,c}.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/92936\n\tPR middle-end/92940\n\tPR middle-end/89428\n\t* c-c++-common/Wstringop-overflow-2.c: Adjust text of expected\n\tinformational notes.\n\t* g++.dg/warn/Wstringop-overflow-3.C: Same.\n\t* g++.dg/warn/Wplacement-new-size.C: Remove a test for a no longer\n\tissued warning.\n\t* gcc.dg/Warray-bounds-43.c: Removed unused declarations.\n\t* gcc.dg/Wstringop-overflow-11.c: Remove xfails.\n\t* gcc.dg/Wstringop-overflow-12.c: Same.\n\t* gcc.dg/Wstringop-overflow-17.c: Adjust text of expected messages.\n\t* gcc.dg/Wstringop-overflow-27.c: Same.  Remove xfails.\n\t* gcc.dg/Wstringop-overflow-28.c: Adjust text of expected messages.\n\t* gcc.dg/Wstringop-overflow-29.c: Same.\n\t* gcc.dg/Wstringop-overflow-37.c: Same.\n\t* gcc.dg/Wstringop-overflow-46.c: Same.\n\t* gcc.dg/Wstringop-overflow-47.c: Same.\n\t* gcc.dg/Wstringop-overflow-54.c: Same.\n\t* gcc.dg/warn-strnlen-no-nul.c: Add expected warning.\n\t* gcc.dg/Wstringop-overflow-7.c: New test.\n\t* gcc.dg/Wstringop-overflow-58.c: New test.\n\t* gcc.dg/Wstringop-overflow-59.c: New test.\n\t* gcc.dg/Wstringop-overflow-60.c: New test.\n\t* gcc.dg/Wstringop-overflow-61.c: New test.\n\t* gcc.dg/Wstringop-overflow-62.c: New test.\n\t* gcc.dg/Wstringop-overflow-63.c: New test.\n\t* gcc.dg/Wstringop-overflow-64.c: New test.", "tree": {"sha": "532502ae8d62a6e3ef875f76fe913efdfb146388", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/532502ae8d62a6e3ef875f76fe913efdfb146388"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4dce3b05ec96a5f76adec23dbe92b014f9db8554", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dce3b05ec96a5f76adec23dbe92b014f9db8554", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dce3b05ec96a5f76adec23dbe92b014f9db8554"}], "stats": {"total": 2841, "additions": 2190, "deletions": 651}, "files": [{"sha": "83b0c1c8fd6e319eeeb9f56d5d94ebf6a27c9aad", "filename": "gcc/builtins.c", "status": "modified", "additions": 740, "deletions": 215, "changes": 955, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -185,6 +185,8 @@ static void maybe_emit_sprintf_chk_warning (tree, enum built_in_function);\n static void maybe_emit_free_warning (tree);\n static tree fold_builtin_object_size (tree, tree);\n static bool check_read_access (tree, tree, tree = NULL_TREE, int = 1);\n+static bool compute_objsize (tree, int, access_ref *, ssa_name_limit_t &,\n+\t\t\t     range_query *);\n \n unsigned HOST_WIDE_INT target_newline;\n unsigned HOST_WIDE_INT target_percent;\n@@ -199,7 +201,8 @@ static void expand_builtin_sync_synchronize (void);\n \n access_ref::access_ref (tree bound /* = NULL_TREE */,\n \t\t\tbool minaccess /* = false */)\n-: ref (), eval ([](tree x){ return x; }), trail1special (true), base0 (true)\n+: ref (), eval ([](tree x){ return x; }), trail1special (true), base0 (true),\n+  parmarray ()\n {\n   /* Set to valid.  */\n   offrng[0] = offrng[1] = 0;\n@@ -222,6 +225,175 @@ access_ref::access_ref (tree bound /* = NULL_TREE */,\n     }\n }\n \n+/* Return the PHI node REF refers to or null if it doesn't.  */\n+\n+gphi *\n+access_ref::phi () const\n+{\n+  if (!ref || TREE_CODE (ref) != SSA_NAME)\n+    return NULL;\n+\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (ref);\n+  if (gimple_code (def_stmt) != GIMPLE_PHI)\n+    return NULL;\n+\n+  return as_a <gphi *> (def_stmt);\n+}\n+\n+/* Determine and return the largest object to which *THIS.  If *THIS\n+   refers to a PHI and PREF is nonnull, fill *PREF with the details\n+   of the object determined by compute_objsize(ARG, OSTYPE) for each\n+   PHI argument ARG.  */\n+\n+tree\n+access_ref::get_ref (vec<access_ref> *all_refs,\n+\t\t     access_ref *pref /* = NULL */,\n+\t\t     int ostype /* = 1 */,\n+\t\t     ssa_name_limit_t *psnlim /* = NULL */,\n+\t\t     range_query *rvals /* = NULL */) const\n+{\n+  gphi *phi_stmt = this->phi ();\n+  if (!phi_stmt)\n+    return ref;\n+\n+  /* FIXME: Calling get_ref() with a null PSNLIM is dangerous and might\n+     cause unbounded recursion.  */\n+  ssa_name_limit_t snlim_buf;\n+  if (!psnlim)\n+    psnlim = &snlim_buf;\n+\n+  if (!psnlim->visit_phi (ref))\n+    return NULL_TREE;\n+\n+  /* Reflects the range of offsets of all PHI arguments refer to the same\n+     object (i.e., have the same REF).  */\n+  access_ref same_ref;\n+  /* The conservative result of the PHI reflecting the offset and size\n+     of the largest PHI argument, regardless of whether or not they all\n+     refer to the same object.  */\n+  access_ref phi_ref;\n+  if (pref)\n+    {\n+      phi_ref = *pref;\n+      same_ref = *pref;\n+    }\n+\n+  /* Set if any argument is a function array (or VLA) parameter not\n+     declared [static].  */\n+  bool parmarray = false;\n+  /* The size of the smallest object referenced by the PHI arguments.  */\n+  offset_int minsize = 0;\n+  const offset_int maxobjsize = wi::to_offset (max_object_size ());\n+  /* The offset of the PHI, not reflecting those of its arguments.  */\n+  const offset_int orng[2] = { phi_ref.offrng[0], phi_ref.offrng[1] };\n+\n+  const unsigned nargs = gimple_phi_num_args (phi_stmt);\n+  for (unsigned i = 0; i < nargs; ++i)\n+    {\n+      access_ref phi_arg_ref;\n+      tree arg = gimple_phi_arg_def (phi_stmt, i);\n+      if (!compute_objsize (arg, ostype, &phi_arg_ref, *psnlim, rvals)\n+\t  || phi_arg_ref.sizrng[0] < 0)\n+\t/* A PHI with all null pointer arguments.  */\n+\treturn NULL_TREE;\n+\n+      /* Add PREF's offset to that of the argument.  */\n+      phi_arg_ref.add_offset (orng[0], orng[1]);\n+\n+      if (all_refs)\n+\tall_refs->safe_push (phi_arg_ref);\n+\n+      const bool arg_known_size = (phi_arg_ref.sizrng[0] != 0\n+\t\t\t\t   || phi_arg_ref.sizrng[1] != maxobjsize);\n+\n+      parmarray |= phi_arg_ref.parmarray;\n+\n+      const bool nullp = integer_zerop (arg) && (i || i + 1 < nargs);\n+\n+      if (phi_ref.sizrng[0] < 0)\n+\t{\n+\t  if (!nullp)\n+\t    same_ref = phi_arg_ref;\n+\t  phi_ref = phi_arg_ref;\n+\t  if (arg_known_size)\n+\t    minsize = phi_arg_ref.sizrng[0];\n+\t  continue;\n+\t}\n+\n+      const bool phi_known_size = (phi_ref.sizrng[0] != 0\n+\t\t\t\t   || phi_ref.sizrng[1] != maxobjsize);\n+\n+      if (phi_known_size && phi_arg_ref.sizrng[0] < minsize)\n+\tminsize = phi_arg_ref.sizrng[0];\n+\n+      /* Disregard null pointers in PHIs with two or more arguments.\n+\t TODO: Handle this better!  */\n+      if (nullp)\n+\tcontinue;\n+\n+      /* Determine the amount of remaining space in the argument.  */\n+      offset_int argrem[2];\n+      argrem[1] = phi_arg_ref.size_remaining (argrem);\n+\n+      /* Determine the amount of remaining space computed so far and\n+\t if the remaining space in the argument is more use it instead.  */\n+      offset_int phirem[2];\n+      phirem[1] = phi_ref.size_remaining (phirem);\n+\n+      if (phi_arg_ref.ref != same_ref.ref)\n+\tsame_ref.ref = NULL_TREE;\n+\n+      if (phirem[1] < argrem[1]\n+\t  || (phirem[1] == argrem[1]\n+\t      && phi_ref.sizrng[1] < phi_arg_ref.sizrng[1]))\n+\t/* Use the argument with the most space remaining as the result,\n+\t   or the larger one if the space is equal.  */\n+\tphi_ref = phi_arg_ref;\n+\n+      /* Set SAME_REF.OFFRNG to the maximum range of all arguments.  */\n+      if (phi_arg_ref.offrng[0] < same_ref.offrng[0])\n+\tsame_ref.offrng[0] = phi_arg_ref.offrng[0];\n+      if (same_ref.offrng[1] < phi_arg_ref.offrng[1])\n+\tsame_ref.offrng[1] = phi_arg_ref.offrng[1];\n+    }\n+\n+  if (phi_ref.sizrng[0] < 0)\n+    {\n+      /* Fail if none of the PHI's arguments resulted in updating PHI_REF\n+\t (perhaps because they have all been already visited by prior\n+\t recursive calls).  */\n+      psnlim->leave_phi (ref);\n+      return NULL_TREE;\n+    }\n+\n+  if (!same_ref.ref && same_ref.offrng[0] != 0)\n+    /* Clear BASE0 if not all the arguments refer to the same object and\n+       if not all their offsets are zero-based.  This allows the final\n+       PHI offset to out of bounds for some arguments but not for others\n+       (or negative even of all the arguments are BASE0), which is overly\n+       permissive.  */\n+    phi_ref.base0 = false;\n+\n+  if (same_ref.ref)\n+    phi_ref = same_ref;\n+  else\n+    {\n+      /* Replace the lower bound of the largest argument with the size\n+\t of the smallest argument, and set PARMARRAY if any argument\n+\t was one.  */\n+      phi_ref.sizrng[0] = minsize;\n+      phi_ref.parmarray = parmarray;\n+    }\n+\n+  /* Avoid changing *THIS.  */\n+  if (pref && pref != this)\n+    *pref = phi_ref;\n+\n+  psnlim->leave_phi (ref);\n+\n+  return phi_ref.ref;\n+}\n+\n /* Return the maximum amount of space remaining and if non-null, set\n    argument to the minimum.  */\n \n@@ -318,7 +490,6 @@ void access_ref::add_offset (const offset_int &min, const offset_int &max)\n \t  return;\n \t}\n \n-      offrng[1] = maxoff;\n       offset_int absmax = wi::abs (max);\n       if (offrng[0] < absmax)\n \t{\n@@ -353,6 +524,75 @@ void access_ref::add_offset (const offset_int &min, const offset_int &max)\n     }\n }\n \n+/* Set a bit for the PHI in VISITED and return true if it wasn't\n+   already set.  */\n+\n+bool\n+ssa_name_limit_t::visit_phi (tree ssa_name)\n+{\n+  if (!visited)\n+    visited = BITMAP_ALLOC (NULL);\n+\n+  /* Return false if SSA_NAME has already been visited.  */\n+  return bitmap_set_bit (visited, SSA_NAME_VERSION (ssa_name));\n+}\n+\n+/* Clear a bit for the PHI in VISITED.  */\n+\n+void\n+ssa_name_limit_t::leave_phi (tree ssa_name)\n+{\n+  /* Return false if SSA_NAME has already been visited.  */\n+  bitmap_clear_bit (visited, SSA_NAME_VERSION (ssa_name));\n+}\n+\n+/* Return false if the SSA_NAME chain length counter has reached\n+   the limit, otherwise increment the counter and return true.  */\n+\n+bool\n+ssa_name_limit_t::next ()\n+{\n+  /* Return a negative value to let caller avoid recursing beyond\n+     the specified limit.  */\n+  if (ssa_def_max == 0)\n+    return false;\n+\n+  --ssa_def_max;\n+\n+  return true;\n+}\n+\n+/* If the SSA_NAME has already been \"seen\" return a positive value.\n+   Otherwise add it to VISITED.  If the SSA_NAME limit has been\n+   reached, return a negative value.  Otherwise return zero.  */\n+\n+int\n+ssa_name_limit_t::next_phi (tree ssa_name)\n+{\n+  {\n+    gimple *def_stmt = SSA_NAME_DEF_STMT (ssa_name);\n+    /* Return a positive value if the PHI has already been visited.  */\n+    if (gimple_code (def_stmt) == GIMPLE_PHI\n+\t&& !visit_phi (ssa_name))\n+      return 1;\n+  }\n+\n+  /* Return a negative value to let caller avoid recursing beyond\n+     the specified limit.  */\n+  if (ssa_def_max == 0)\n+    return -1;\n+\n+  --ssa_def_max;\n+\n+  return 0;\n+}\n+\n+ssa_name_limit_t::~ssa_name_limit_t ()\n+{\n+  if (visited)\n+    BITMAP_FREE (visited);\n+}\n+\n /* Return true if NAME starts with __builtin_ or __sync_.  */\n \n static bool\n@@ -3561,51 +3801,77 @@ maybe_warn_for_bound (int opt, location_t loc, tree exp, tree func,\n \n   if (opt == OPT_Wstringop_overread)\n     {\n+      bool maybe = pad && pad->src.phi ();\n+\n       if (tree_int_cst_lt (maxobjsize, bndrng[0]))\n \t{\n \t  if (bndrng[0] == bndrng[1])\n \t    warned = (func\n \t\t      ? warning_at (loc, opt,\n-\t\t\t\t    \"%K%qD specified bound %E \"\n-\t\t\t\t    \"exceeds maximum object size %E\",\n+\t\t\t\t    (maybe\n+\t\t\t\t     ? G_(\"%K%qD specified bound %E may \"\n+\t\t\t\t\t  \"exceed maximum object size %E\")\n+\t\t\t\t     : G_(\"%K%qD specified bound %E \"\n+\t\t\t\t\t  \"exceeds maximum object size %E\")),\n \t\t\t\t    exp, func, bndrng[0], maxobjsize)\n \t\t      : warning_at (loc, opt,\n-\t\t\t\t    \"%Kspecified bound %E \"\n-\t\t\t\t    \"exceeds maximum object size %E\",\n+\t\t\t\t    (maybe\n+\t\t\t\t     ? G_(\"%Kspecified bound %E may \"\n+\t\t\t\t\t  \"exceed maximum object size %E\")\n+\t\t\t\t     : G_(\"%Kspecified bound %E \"\n+\t\t\t\t\t  \"exceeds maximum object size %E\")),\n \t\t\t\t    exp, bndrng[0], maxobjsize));\n \t  else\n \t    warned = (func\n \t\t      ? warning_at (loc, opt,\n-\t\t\t\t    \"%K%qD specified bound [%E, %E] \"\n-\t\t\t\t    \"exceeds maximum object size %E\",\n+\t\t\t\t    (maybe\n+\t\t\t\t     ? G_(\"%K%qD specified bound [%E, %E] may \"\n+\t\t\t\t\t  \"exceed maximum object size %E\")\n+\t\t\t\t     : G_(\"%K%qD specified bound [%E, %E] \"\n+\t\t\t\t\t  \"exceeds maximum object size %E\")),\n \t\t\t\t    exp, func,\n \t\t\t\t    bndrng[0], bndrng[1], maxobjsize)\n \t\t      : warning_at (loc, opt,\n-\t\t\t\t    \"%Kspecified bound [%E, %E] \"\n-\t\t\t\t    \"exceeds maximum object size %E\",\n+\t\t\t\t    (maybe\n+\t\t\t\t     ? G_(\"%Kspecified bound [%E, %E] may \"\n+\t\t\t\t\t  \"exceed maximum object size %E\")\n+\t\t\t\t     : G_(\"%Kspecified bound [%E, %E] \"\n+\t\t\t\t\t  \"exceeds maximum object size %E\")),\n \t\t\t\t    exp, bndrng[0], bndrng[1], maxobjsize));\n \t}\n       else if (!size || tree_int_cst_le (bndrng[0], size))\n \treturn false;\n       else if (tree_int_cst_equal (bndrng[0], bndrng[1]))\n \twarned = (func\n \t\t  ? warning_at (loc, opt,\n-\t\t\t\t\"%K%qD specified bound %E exceeds \"\n-\t\t\t\t\"source size %E\",\n+\t\t\t\t(maybe\n+\t\t\t\t ? G_(\"%K%qD specified bound %E may exceed \"\n+\t\t\t\t      \"source size %E\")\n+\t\t\t\t : G_(\"%K%qD specified bound %E exceeds \"\n+\t\t\t\t      \"source size %E\")),\n \t\t\t\texp, func, bndrng[0], size)\n \t\t  : warning_at (loc, opt,\n-\t\t\t\t\"%Kspecified bound %E exceeds \"\n-\t\t\t\t\"source size %E\",\n+\t\t\t\t(maybe\n+\t\t\t\t ? G_(\"%Kspecified bound %E may exceed \"\n+\t\t\t\t      \"source size %E\")\n+\t\t\t\t : G_(\"%Kspecified bound %E exceeds \"\n+\t\t\t\t      \"source size %E\")),\n \t\t\t\texp, bndrng[0], size));\n       else\n \twarned = (func\n \t\t  ? warning_at (loc, opt,\n-\t\t\t\t\"%K%qD specified bound [%E, %E] exceeds \"\n-\t\t\t\t\"source size %E\",\n+\t\t\t\t(maybe\n+\t\t\t\t ? G_(\"%K%qD specified bound [%E, %E] may \"\n+\t\t\t\t      \"exceed source size %E\")\n+\t\t\t\t : G_(\"%K%qD specified bound [%E, %E] exceeds \"\n+\t\t\t\t      \"source size %E\")),\n \t\t\t\texp, func, bndrng[0], bndrng[1], size)\n \t\t  : warning_at (loc, opt,\n-\t\t\t\t\"%Kspecified bound [%E, %E] exceeds \"\n-\t\t\t\t\"source size %E\",\n+\t\t\t\t(maybe\n+\t\t\t\t ? G_(\"%Kspecified bound [%E, %E] may exceed \"\n+\t\t\t\t      \"source size %E\")\n+\t\t\t\t : G_(\"%Kspecified bound [%E, %E] exceeds \"\n+\t\t\t\t      \"source size %E\")),\n \t\t\t\texp, bndrng[0], bndrng[1], size));\n       if (warned)\n \t{\n@@ -3624,51 +3890,76 @@ maybe_warn_for_bound (int opt, location_t loc, tree exp, tree func,\n       return warned;\n     }\n \n+  bool maybe = pad && pad->dst.phi ();\n   if (tree_int_cst_lt (maxobjsize, bndrng[0]))\n     {\n       if (bndrng[0] == bndrng[1])\n \twarned = (func\n \t\t  ? warning_at (loc, opt,\n-\t\t\t\t\"%K%qD specified size %E \"\n-\t\t\t\t\"exceeds maximum object size %E\",\n+\t\t\t\t(maybe\n+\t\t\t\t ? G_(\"%K%qD specified size %E may \"\n+\t\t\t\t      \"exceed maximum object size %E\")\n+\t\t\t\t : G_(\"%K%qD specified size %E \"\n+\t\t\t\t      \"exceeds maximum object size %E\")),\n \t\t\t\texp, func, bndrng[0], maxobjsize)\n \t\t  : warning_at (loc, opt,\n-\t\t\t\t\"%Kspecified size %E \"\n-\t\t\t\t\"exceeds maximum object size %E\",\n+\t\t\t\t(maybe\n+\t\t\t\t ? G_(\"%Kspecified size %E may exceed \"\n+\t\t\t\t      \"maximum object size %E\")\n+\t\t\t\t : G_(\"%Kspecified size %E exceeds \"\n+\t\t\t\t      \"maximum object size %E\")),\n \t\t\t\texp, bndrng[0], maxobjsize));\n       else\n \twarned = (func\n \t\t  ? warning_at (loc, opt,\n-\t\t\t\t\"%K%qD specified size between %E and %E \"\n-\t\t\t\t\"exceeds maximum object size %E\",\n+\t\t\t\t(maybe\n+\t\t\t\t ? G_(\"%K%qD specified size between %E and %E \"\n+\t\t\t\t      \"may exceed maximum object size %E\")\n+\t\t\t\t : G_(\"%K%qD specified size between %E and %E \"\n+\t\t\t\t      \"exceeds maximum object size %E\")),\n \t\t\t\texp, func,\n \t\t\t\tbndrng[0], bndrng[1], maxobjsize)\n \t\t  : warning_at (loc, opt,\n-\t\t\t\t\"%Kspecified size between %E and %E \"\n-\t\t\t\t\"exceeds maximum object size %E\",\n+\t\t\t\t(maybe\n+\t\t\t\t ? G_(\"%Kspecified size between %E and %E \"\n+\t\t\t\t      \"may exceed maximum object size %E\")\n+\t\t\t\t : G_(\"%Kspecified size between %E and %E \"\n+\t\t\t\t      \"exceeds maximum object size %E\")),\n \t\t\t\texp, bndrng[0], bndrng[1], maxobjsize));\n     }\n   else if (!size || tree_int_cst_le (bndrng[0], size))\n     return false;\n   else if (tree_int_cst_equal (bndrng[0], bndrng[1]))\n     warned = (func\n \t      ? warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t    \"%K%qD specified bound %E exceeds \"\n-\t\t\t    \"destination size %E\",\n+\t\t\t    (maybe\n+\t\t\t     ? G_(\"%K%qD specified bound %E may exceed \"\n+\t\t\t\t  \"destination size %E\")\n+\t\t\t     : G_(\"%K%qD specified bound %E exceeds \"\n+\t\t\t\t  \"destination size %E\")),\n \t\t\t    exp, func, bndrng[0], size)\n \t      : warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t    \"%Kspecified bound %E exceeds \"\n-\t\t\t    \"destination size %E\",\n+\t\t\t    (maybe\n+\t\t\t     ? G_(\"%Kspecified bound %E may exceed \"\n+\t\t\t\t  \"destination size %E\")\n+\t\t\t     : G_(\"%Kspecified bound %E exceeds \"\n+\t\t\t\t  \"destination size %E\")),\n \t\t\t    exp, bndrng[0], size));\n   else\n     warned = (func\n \t      ? warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t    \"%K%qD specified bound [%E, %E] exceeds \"\n-\t\t\t    \"destination size %E\",\n+\t\t\t    (maybe\n+\t\t\t     ? G_(\"%K%qD specified bound [%E, %E] may exceed \"\n+\t\t\t\t  \"destination size %E\")\n+\t\t\t     : G_(\"%K%qD specified bound [%E, %E] exceeds \"\n+\t\t\t\t  \"destination size %E\")),\n \t\t\t    exp, func, bndrng[0], bndrng[1], size)\n \t      : warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t    \"%Kspecified bound [%E, %E] exceeds \"\n-\t\t\t    \"destination size %E\",\n+\t\t\t    (maybe\n+\t\t\t     ? G_(\"%Kspecified bound [%E, %E] exceeds \"\n+\t\t\t\t  \"destination size %E\")\n+\t\t\t     : G_(\"%Kspecified bound [%E, %E] exceeds \"\n+\t\t\t\t  \"destination size %E\")),\n \t\t\t    exp, bndrng[0], bndrng[1], size));\n \n   if (warned)\n@@ -3697,7 +3988,7 @@ maybe_warn_for_bound (int opt, location_t loc, tree exp, tree func,\n \n static bool\n warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n-\t\t tree size, bool write, bool read)\n+\t\t tree size, bool write, bool read, bool maybe)\n {\n   bool warned = false;\n \n@@ -3706,40 +3997,64 @@ warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n       if (tree_int_cst_equal (range[0], range[1]))\n \twarned = (func\n \t\t  ? warning_n (loc, opt, tree_to_uhwi (range[0]),\n-\t\t\t       \"%K%qD accessing %E byte in a region \"\n-\t\t\t       \"of size %E\",\n-\t\t\t       \"%K%qD accessing %E bytes in a region \"\n-\t\t\t       \"of size %E\",\n+\t\t\t       (maybe\n+\t\t\t\t? G_(\"%K%qD may access %E byte in a region \"\n+\t\t\t\t     \"of size %E\")\n+\t\t\t\t: G_(\"%K%qD accessing %E byte in a region \"\n+\t\t\t\t     \"of size %E\")),\n+\t\t\t\t(maybe\n+\t\t\t\t ? G_ (\"%K%qD may access %E bytes in a region \"\n+\t\t\t\t       \"of size %E\")\n+\t\t\t\t : G_ (\"%K%qD accessing %E bytes in a region \"\n+\t\t\t\t       \"of size %E\")),\n \t\t\t       exp, func, range[0], size)\n \t\t  : warning_n (loc, opt, tree_to_uhwi (range[0]),\n-\t\t\t       \"%Kaccessing %E byte in a region \"\n-\t\t\t       \"of size %E\",\n-\t\t\t       \"%Kaccessing %E bytes in a region \"\n-\t\t\t       \"of size %E\",\n+\t\t\t       (maybe\n+\t\t\t\t? G_(\"%Kmay access %E byte in a region \"\n+\t\t\t\t     \"of size %E\")\n+\t\t\t\t: G_(\"%Kaccessing %E byte in a region \"\n+\t\t\t\t     \"of size %E\")),\n+\t\t\t       (maybe\n+\t\t\t\t? G_(\"%Kmay access %E bytes in a region \"\n+\t\t\t\t     \"of size %E\")\n+\t\t\t\t: G_(\"%Kaccessing %E bytes in a region \"\n+\t\t\t\t     \"of size %E\")),\n \t\t\t       exp, range[0], size));\n       else if (tree_int_cst_sign_bit (range[1]))\n \t{\n \t  /* Avoid printing the upper bound if it's invalid.  */\n \t  warned = (func\n \t\t    ? warning_at (loc, opt,\n-\t\t\t\t  \"%K%qD accessing %E or more bytes in \"\n-\t\t\t\t  \"a region of size %E\",\n+\t\t\t\t  (maybe\n+\t\t\t\t   ? G_(\"%K%qD may access %E or more bytes \"\n+\t\t\t\t\t\"in a region of size %E\")\n+\t\t\t\t   : G_(\"%K%qD accessing %E or more bytes \"\n+\t\t\t\t\t\"in a region of size %E\")),\n \t\t\t\t  exp, func, range[0], size)\n \t\t    : warning_at (loc, opt,\n-\t\t\t\t  \"%Kaccessing %E or more bytes in \"\n-\t\t\t\t  \"a region of size %E\",\n+\t\t\t\t  (maybe\n+\t\t\t\t   ? G_(\"%Kmay access %E or more bytes \"\n+\t\t\t\t\t\"in a region of size %E\")\n+\t\t\t\t   : G_(\"%Kaccessing %E or more bytes \"\n+\t\t\t\t\t\"in a region of size %E\")),\n \t\t\t\t  exp, range[0], size));\n \t}\n       else\n \twarned = (func\n \t\t  ? warning_at (loc, opt,\n-\t\t\t\t\"%K%qD accessing between %E and %E bytes \"\n-\t\t\t\t\"in a region of size %E\",\n+\t\t\t\t(maybe\n+\t\t\t\t ? G_(\"%K%qD may access between %E and %E \"\n+\t\t\t\t      \"bytes in a region of size %E\")\n+\t\t\t\t : G_(\"%K%qD accessing between %E and %E \"\n+\t\t\t\t      \"bytes in a region of size %E\")),\n \t\t\t\texp, func, range[0], range[1],\n \t\t\t\tsize)\n \t\t  : warning_at (loc, opt,\n-\t\t\t\t\"%Kaccessing between %E and %E bytes \"\n-\t\t\t\t\"in a region of size %E\",\n+\t\t\t\t(maybe\n+\t\t\t\t ? G_(\"%Kmay access between %E and %E bytes \"\n+\t\t\t\t      \"in a region of size %E\")\n+\t\t\t\t : G_(\"%Kaccessing between %E and %E bytes \"\n+\t\t\t\t      \"in a region of size %E\")),\n \t\t\t\texp, range[0], range[1],\n \t\t\t\tsize));\n       return warned;\n@@ -3750,44 +4065,69 @@ warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n       if (tree_int_cst_equal (range[0], range[1]))\n \twarned = (func\n \t\t  ? warning_n (loc, opt, tree_to_uhwi (range[0]),\n-\t\t\t       \"%K%qD writing %E byte into a region \"\n-\t\t\t       \"of size %E overflows the destination\",\n-\t\t\t       \"%K%qD writing %E bytes into a region \"\n-\t\t\t       \"of size %E overflows the destination\",\n+\t\t\t       (maybe\n+\t\t\t\t? G_(\"%K%qD may write %E byte into a region \"\n+\t\t\t\t     \"of size %E\")\n+\t\t\t\t: G_(\"%K%qD writing %E byte into a region \"\n+\t\t\t\t     \"of size %E overflows the destination\")),\n+\t\t\t       (maybe\n+\t\t\t\t? G_(\"%K%qD may write %E bytes into a region \"\n+\t\t\t\t     \"of size %E\")\n+\t\t\t\t: G_(\"%K%qD writing %E bytes into a region \"\n+\t\t\t\t     \"of size %E overflows the destination\")),\n \t\t\t       exp, func, range[0], size)\n \t\t  : warning_n (loc, opt, tree_to_uhwi (range[0]),\n-\t\t\t       \"%Kwriting %E byte into a region \"\n-\t\t\t       \"of size %E overflows the destination\",\n-\t\t\t       \"%Kwriting %E bytes into a region \"\n-\t\t\t       \"of size %E overflows the destination\",\n+\t\t\t       (maybe\n+\t\t\t\t? G_(\"%Kmay write %E byte into a region \"\n+\t\t\t\t     \"of size %E\")\n+\t\t\t\t: G_(\"%Kwriting %E byte into a region \"\n+\t\t\t\t     \"of size %E overflows the destination\")),\n+\t\t\t       (maybe\n+\t\t\t\t? G_(\"%Kmay write %E bytes into a region \"\n+\t\t\t\t     \"of size %E\")\n+\t\t\t\t: G_(\"%Kwriting %E bytes into a region \"\n+\t\t\t\t     \"of size %E overflows the destination\")),\n \t\t\t       exp, range[0], size));\n       else if (tree_int_cst_sign_bit (range[1]))\n \t{\n \t  /* Avoid printing the upper bound if it's invalid.  */\n \t  warned = (func\n \t\t    ? warning_at (loc, opt,\n-\t\t\t\t  \"%K%qD writing %E or more bytes into \"\n-\t\t\t\t  \"a region of size %E overflows \"\n-\t\t\t\t  \"the destination\",\n+\t\t\t\t  (maybe\n+\t\t\t\t   ? G_(\"%K%qD may write %E or more bytes \"\n+\t\t\t\t\t\"into a region of size %E \"\n+\t\t\t\t\t\"the destination\")\n+\t\t\t\t   : G_(\"%K%qD writing %E or more bytes \"\n+\t\t\t\t\t\"into a region of size %E overflows \"\n+\t\t\t\t\t\"the destination\")),\n \t\t\t\t  exp, func, range[0], size)\n \t\t    : warning_at (loc, opt,\n-\t\t\t\t  \"%Kwriting %E or more bytes into \"\n-\t\t\t\t  \"a region of size %E overflows \"\n-\t\t\t\t  \"the destination\",\n+\t\t\t\t  (maybe\n+\t\t\t\t   ? G_(\"%Kmay write %E or more bytes into \"\n+\t\t\t\t\t\"a region of size %E\")\n+\t\t\t\t   : G_(\"%Kwriting %E or more bytes into \"\n+\t\t\t\t\t\"a region of size %E overflows \"\n+\t\t\t\t\t\"the destination\")),\n \t\t\t\t  exp, range[0], size));\n \t}\n       else\n \twarned = (func\n \t\t  ? warning_at (loc, opt,\n-\t\t\t\t\"%K%qD writing between %E and %E bytes \"\n-\t\t\t\t\"into a region of size %E overflows \"\n-\t\t\t\t\"the destination\",\n+\t\t\t\t(maybe\n+\t\t\t\t ? G_(\"%K%qD may write between %E and %E bytes \"\n+\t\t\t\t      \"into a region of size %E\")\n+\t\t\t\t : G_(\"%K%qD writing between %E and %E bytes \"\n+\t\t\t\t      \"into a region of size %E overflows \"\n+\t\t\t\t      \"the destination\")),\n \t\t\t\texp, func, range[0], range[1],\n \t\t\t\tsize)\n \t\t  : warning_at (loc, opt,\n-\t\t\t\t\"%Kwriting between %E and %E bytes \"\n-\t\t\t\t\"into a region of size %E overflows \"\n-\t\t\t\t\"the destination\",\n+\t\t\t\t(maybe\n+\t\t\t\t ? G_(\"%Kmay write between %E and %E bytes \"\n+\t\t\t\t      \"into a region of size %E\")\n+\t\t\t\t : G_(\"%Kwriting between %E and %E bytes \"\n+\t\t\t\t      \"into a region of size %E overflows \"\n+\t\t\t\t      \"the destination\")),\n \t\t\t\texp, range[0], range[1],\n \t\t\t\tsize));\n       return warned;\n@@ -3799,35 +4139,64 @@ warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n \twarned = (func\n \t\t  ? warning_n (loc, OPT_Wstringop_overread,\n \t\t\t       tree_to_uhwi (range[0]),\n-\t\t\t       \"%K%qD reading %E byte from a region of size %E\",\n-\t\t\t       \"%K%qD reading %E bytes from a region of size %E\",\t\t\t       exp, func, range[0], size)\n+\t\t\t       (maybe\n+\t\t\t\t? G_(\"%K%qD may reade %E byte from a region \"\n+\t\t\t\t     \"of size %E\")\n+\t\t\t\t: G_(\"%K%qD reading %E byte from a region \"\n+\t\t\t\t     \"of size %E\")),\n+\t\t\t       (maybe\n+\t\t\t\t? G_(\"%K%qD may read %E bytes from a region \"\n+\t\t\t\t     \"of size %E\")\n+\t\t\t\t: G_(\"%K%qD reading %E bytes from a region \"\n+\t\t\t\t     \"of size %E\")),\n+\t\t\t       exp, func, range[0], size)\n \t\t  : warning_n (loc, OPT_Wstringop_overread,\n \t\t\t       tree_to_uhwi (range[0]),\n-\t\t\t       \"%Kreading %E byte from a region of size %E\",\n-\t\t\t       \"%Kreading %E bytes from a region of size %E\",\n+\t\t\t       (maybe\n+\t\t\t\t? G_(\"%Kmay read %E byte from a region \"\n+\t\t\t\t     \"of size %E\")\n+\t\t\t\t: G_(\"%Kreading %E byte from a region \"\n+\t\t\t\t     \"of size %E\")),\n+\t\t\t       (maybe\n+\t\t\t\t? G_(\"%Kmay read %E bytes from a region \"\n+\t\t\t\t     \"of size %E\")\n+\t\t\t\t: G_(\"%Kreading %E bytes from a region \"\n+\t\t\t\t     \"of size %E\")),\n \t\t\t       exp, range[0], size));\n       else if (tree_int_cst_sign_bit (range[1]))\n \t{\n \t  /* Avoid printing the upper bound if it's invalid.  */\n \t  warned = (func\n \t\t    ? warning_at (loc, OPT_Wstringop_overread,\n-\t\t\t\t  \"%K%qD reading %E or more bytes from \"\n-\t\t\t\t  \"a region of size %E\",\n+\t\t\t\t  (maybe\n+\t\t\t\t   ? G_(\"%K%qD may read %E or more bytes \"\n+\t\t\t\t\t\"from a region of size %E\")\n+\t\t\t\t   : G_(\"%K%qD reading %E or more bytes \"\n+\t\t\t\t\t\"from a region of size %E\")),\n \t\t\t\t  exp, func, range[0], size)\n \t\t    : warning_at (loc, OPT_Wstringop_overread,\n-\t\t\t\t  \"%Kreading %E or more bytes from a region \"\n-\t\t\t\t  \"of size %E\",\n+\t\t\t\t  (maybe\n+\t\t\t\t   ? G_(\"%Kmay read %E or more bytes \"\n+\t\t\t\t\t\"from a region of size %E\")\n+\t\t\t\t   : G_(\"%Kreading %E or more bytes \"\n+\t\t\t\t\t\"from a region of size %E\")),\n \t\t\t\t  exp, range[0], size));\n \t}\n       else\n \twarned = (func\n \t\t  ? warning_at (loc, OPT_Wstringop_overread,\n-\t\t\t\t\"%K%qD reading between %E and %E bytes from \"\n-\t\t\t\t\"a region of size %E\",\n+\t\t\t\t(maybe\n+\t\t\t\t ? G_(\"%K%qD may read between %E and %E bytes \"\n+\t\t\t\t      \"from a region of size %E\")\n+\t\t\t\t : G_(\"%K%qD reading between %E and %E bytes \"\n+\t\t\t\t      \"from a region of size %E\")),\n \t\t\t\texp, func, range[0], range[1], size)\n \t\t  : warning_at (loc, opt,\n-\t\t\t\t\"%K reading between %E and %E bytes from \"\n-\t\t\t\t\"a region of size %E\",\n+\t\t\t\t(maybe\n+\t\t\t\t ? G_(\"%Kmay read between %E and %E bytes \"\n+\t\t\t\t      \"from a region of size %E\")\n+\t\t\t\t : G_(\"%Kreading between %E and %E bytes \"\n+\t\t\t\t      \"from a region of size %E\")),\n \t\t\t\texp, range[0], range[1], size));\n \n       if (warned)\n@@ -3879,28 +4248,61 @@ warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n   return warned;\n }\n \n-/* Issue an inform message describing the target of an access REF.\n+/* Issue one inform message describing each target of an access REF.\n    WRITE is set for a write access and clear for a read access.  */\n \n-static void\n-inform_access (const access_ref &ref, access_mode mode)\n+void\n+access_ref::inform_access (access_mode mode) const\n {\n-  if (!ref.ref)\n+  const access_ref &aref = *this;\n+  if (!aref.ref)\n     return;\n \n+  if (aref.phi ())\n+    {\n+      /* Set MAXREF to refer to the largest object and fill ALL_REFS\n+\t with data for all objects referenced by the PHI arguments.  */\n+      access_ref maxref;\n+      auto_vec<access_ref> all_refs;\n+      if (!get_ref (&all_refs, &maxref))\n+\treturn;\n+\n+      /* Except for MAXREF, the rest of the arguments' offsets need not\n+\t reflect one added to the PHI itself.  Determine the latter from\n+\t MAXREF on which the result is based.  */\n+      const offset_int orng[] =\n+\t{\n+\t offrng[0] - maxref.offrng[0],\n+\t wi::smax (offrng[1] - maxref.offrng[1], offrng[0]),\n+\t};\n+\n+      /* Add the final PHI's offset to that of each of the arguments\n+\t and recurse to issue an inform message for it.  */\n+      for (unsigned i = 0; i != all_refs.length (); ++i)\n+\t{\n+\t  /* Skip any PHIs; those could lead to infinite recursion.  */\n+\t  if (all_refs[i].phi ())\n+\t    continue;\n+\n+\t  all_refs[i].add_offset (orng[0], orng[1]);\n+\t  all_refs[i].inform_access (mode);\n+\t}\n+      return;\n+    }\n+\n   /* Convert offset range and avoid including a zero range since it\n      isn't necessarily meaningful.  */\n   HOST_WIDE_INT diff_min = tree_to_shwi (TYPE_MIN_VALUE (ptrdiff_type_node));\n   HOST_WIDE_INT diff_max = tree_to_shwi (TYPE_MAX_VALUE (ptrdiff_type_node));\n   HOST_WIDE_INT minoff;\n   HOST_WIDE_INT maxoff = diff_max;\n-  if (wi::fits_shwi_p (ref.offrng[0]))\n-    minoff = ref.offrng[0].to_shwi ();\n+  if (wi::fits_shwi_p (aref.offrng[0]))\n+    minoff = aref.offrng[0].to_shwi ();\n   else\n-    minoff = ref.offrng[0] < 0 ? diff_min : diff_max;\n+    minoff = aref.offrng[0] < 0 ? diff_min : diff_max;\n \n-  if (wi::fits_shwi_p (ref.offrng[1]))\n-    maxoff = ref.offrng[1].to_shwi ();\n+  if (wi::fits_shwi_p (aref.offrng[1]))\n+    maxoff = aref.offrng[1].to_shwi ();\n \n   if (maxoff <= diff_min || maxoff >= diff_max)\n     /* Avoid mentioning an upper bound that's equal to or in excess\n@@ -3910,110 +4312,127 @@ inform_access (const access_ref &ref, access_mode mode)\n   /* Convert size range and always include it since all sizes are\n      meaningful. */\n   unsigned long long minsize = 0, maxsize = 0;\n-  if (wi::fits_shwi_p (ref.sizrng[0])\n-      && wi::fits_shwi_p (ref.sizrng[1]))\n+  if (wi::fits_shwi_p (aref.sizrng[0])\n+      && wi::fits_shwi_p (aref.sizrng[1]))\n     {\n-      minsize = ref.sizrng[0].to_shwi ();\n-      maxsize = ref.sizrng[1].to_shwi ();\n+      minsize = aref.sizrng[0].to_shwi ();\n+      maxsize = aref.sizrng[1].to_shwi ();\n     }\n \n+  /* SIZRNG doesn't necessarily have the same range as the allocation\n+     size determined by gimple_call_alloc_size ().  */\n   char sizestr[80];\n-  location_t loc;\n-  tree allocfn = NULL_TREE;\n-  if (TREE_CODE (ref.ref) == SSA_NAME)\n-    {\n-      gimple *stmt = SSA_NAME_DEF_STMT (ref.ref);\n-      gcc_assert (is_gimple_call (stmt));\n-      loc = gimple_location (stmt);\n-      allocfn = gimple_call_fndecl (stmt);\n-      if (!allocfn)\n-\t/* Handle calls through pointers to functions.  */\n-\tallocfn = gimple_call_fn (stmt);\n-\n-      /* SIZRNG doesn't necessarily have the same range as the allocation\n-\t size determined by gimple_call_alloc_size ().  */\n+  if (minsize == maxsize)\n+    sprintf (sizestr, \"%llu\", minsize);\n+  else\n+    sprintf (sizestr, \"[%llu, %llu]\", minsize, maxsize);\n+\n+  char offstr[80];\n+  if (minoff == 0\n+      && (maxoff == 0 || aref.sizrng[1] <= maxoff))\n+    offstr[0] = '\\0';\n+  else if (minoff == maxoff)\n+    sprintf (offstr, \"%lli\", (long long) minoff);\n+  else\n+    sprintf (offstr, \"[%lli, %lli]\", (long long) minoff, (long long) maxoff);\n \n-      if (minsize == maxsize)\n-\tsprintf (sizestr, \"%llu\", minsize);\n-      else\n-\tsprintf (sizestr, \"[%llu, %llu]\", minsize, maxsize);\n+  location_t loc = UNKNOWN_LOCATION;\n \n+  tree ref = this->ref;\n+  tree allocfn = NULL_TREE;\n+  if (TREE_CODE (ref) == SSA_NAME)\n+    {\n+      gimple *stmt = SSA_NAME_DEF_STMT (ref);\n+      if (is_gimple_call (stmt))\n+\t{\n+\t  loc = gimple_location (stmt);\n+\t  if (gimple_call_builtin_p (stmt, BUILT_IN_ALLOCA_WITH_ALIGN))\n+\t    {\n+\t      /* Strip the SSA_NAME suffix from the variable name and\n+\t\t recreate an identifier with the VLA's original name.  */\n+\t      ref = gimple_call_lhs (stmt);\n+\t      ref = SSA_NAME_IDENTIFIER (ref);\n+\t      const char *id = IDENTIFIER_POINTER (ref);\n+\t      size_t len = strcspn (id, \".$\");\n+\t      if (!len)\n+\t\tlen = strlen (id);\n+\t      ref = get_identifier_with_length (id, len);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Except for VLAs, retrieve the allocation function.  */\n+\t      allocfn = gimple_call_fndecl (stmt);\n+\t      if (!allocfn)\n+\t\tallocfn = gimple_call_fn (stmt);\n+\t      if (TREE_CODE (allocfn) == SSA_NAME)\n+\t\t{\n+\t\t  /* For an ALLOC_CALL via a function pointer make a small\n+\t\t     effort to determine the destination of the pointer.  */\n+\t\t  gimple *def = SSA_NAME_DEF_STMT (allocfn);\n+\t\t  if (gimple_assign_single_p (def))\n+\t\t    {\n+\t\t      tree rhs = gimple_assign_rhs1 (def);\n+\t\t      if (DECL_P (rhs))\n+\t\t\tallocfn = rhs;\n+\t\t      else if (TREE_CODE (rhs) == COMPONENT_REF)\n+\t\t\tallocfn = TREE_OPERAND (rhs, 1);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      else if (gimple_nop_p (stmt))\n+\t/* Handle DECL_PARM below.  */\n+\tref = SSA_NAME_VAR (ref);\n     }\n-  else if (DECL_P (ref.ref))\n-    loc = DECL_SOURCE_LOCATION (ref.ref);\n-  else if (EXPR_P (ref.ref) && EXPR_HAS_LOCATION (ref.ref))\n-    loc = EXPR_LOCATION (ref.ref);\n-  else\n+\n+  if (DECL_P (ref))\n+    loc = DECL_SOURCE_LOCATION (ref);\n+  else if (EXPR_P (ref) && EXPR_HAS_LOCATION (ref))\n+    loc = EXPR_LOCATION (ref);\n+  else if (TREE_CODE (ref) != IDENTIFIER_NODE\n+\t   && TREE_CODE (ref) != SSA_NAME)\n     return;\n \n   if (mode == access_read_write || mode == access_write_only)\n     {\n       if (allocfn == NULL_TREE)\n \t{\n-\t  if (minoff == maxoff)\n-\t    {\n-\t      if (minoff == 0)\n-\t\tinform (loc, \"destination object %qE\", ref.ref);\n-\t      else\n-\t\tinform (loc, \"at offset %wi into destination object %qE\",\n-\t\t\tminoff, ref.ref);\n-\t    }\n+\t  if (*offstr)\n+\t    inform (loc, \"at offset %s into destination object %qE of size %s\",\n+\t\t    offstr, ref, sizestr);\n \t  else\n-\t    inform (loc, \"at offset [%wi, %wi] into destination object %qE\",\n-\t\t    minoff, maxoff, ref.ref);\n+\t    inform (loc, \"destination object %qE of size %s\", ref, sizestr);\n \t  return;\n \t}\n \n-      if (minoff == maxoff)\n-\t{\n-\t  if (minoff == 0)\n-\t    inform (loc, \"destination object of size %s allocated by %qE\",\n-\t\t    sizestr, allocfn);\n-\t  else\n-\t    inform (loc,\n-\t\t    \"at offset %wi into destination object of size %s \"\n-\t\t    \"allocated by %qE\", minoff, sizestr, allocfn);\n-\t}\n-      else\n+      if (*offstr)\n \tinform (loc,\n-\t\t\"at offset [%wi, %wi] into destination object of size %s \"\n-\t\t\"allocated by %qE\",\n-\t\tminoff, maxoff, sizestr, allocfn);\n-\n+\t\t\"at offset %s into destination object of size %s \"\n+\t\t\"allocated by %qE\", offstr, sizestr, allocfn);\n+      else\n+\tinform (loc, \"destination object of size %s allocated by %qE\",\n+\t\tsizestr, allocfn);\n       return;\n     }\n \n-  if (DECL_P (ref.ref))\n+  if (DECL_P (ref))\n     {\n-      if (minoff == maxoff)\n-\t{\n-\t  if (minoff == 0)\n-\t    inform (loc, \"source object %qD\", ref.ref);\n-\t  else\n-\t    inform (loc, \"at offset %wi into source object %qD\",\n-\t\t    minoff, ref.ref);\n-\t}\n+      if (*offstr)\n+\tinform (loc, \"at offset %s into source object %qD of size %s\",\n+\t\toffstr, ref, sizestr);\n       else\n-\tinform (loc, \"at offset [%wi, %wi] into source object %qD\",\n-\t\tminoff, maxoff, ref.ref);\n+\tinform (loc, \"source object %qD of size %s\", ref,  sizestr);\n+\n       return;\n     }\n \n-  if (minoff == maxoff)\n-    {\n-      if (minoff == 0)\n-\tinform (loc, \"source object of size %s allocated by %qE\",\n-\t\tsizestr, allocfn);\n-      else\n-\tinform (loc,\n-\t\t\"at offset %wi into source object of size %s \"\n-\t\t\"allocated by %qE\", minoff, sizestr, allocfn);\n-    }\n-  else\n+  if (*offstr)\n     inform (loc,\n-\t    \"at offset [%wi, %wi] into source object of size %s \"\n-\t    \"allocated by %qE\",\n-\t    minoff, maxoff, sizestr, allocfn);\n+\t    \"at offset %s into source object of size %s allocated by %qE\",\n+\t    offstr, sizestr, allocfn);\n+  else\n+    inform (loc, \"source object of size %s allocated by %qE\",\n+\t    sizestr, allocfn);\n }\n \n /* Helper to set RANGE to the range of BOUND if it's nonnull, bounded\n@@ -4233,17 +4652,18 @@ check_access (tree exp, tree dstwrite,\n \t\t= mode == access_read_only || mode == access_read_write;\n \t      const bool write\n \t\t= mode == access_write_only || mode == access_read_write;\n+\t      const bool maybe = pad && pad->dst.parmarray;\n \t      warned = warn_for_access (loc, func, exp,\n \t\t\t\t\tOPT_Wstringop_overflow_,\n \t\t\t\t\trange, dstsize,\n-\t\t\t\t\twrite, read && !builtin);\n+\t\t\t\t\twrite, read && !builtin, maybe);\n \t    }\n \n \t  if (warned)\n \t    {\n \t      TREE_NO_WARNING (exp) = true;\n \t      if (pad)\n-\t\tinform_access (pad->dst, pad->mode);\n+\t\tpad->dst.inform_access (pad->mode);\n \t    }\n \n \t  /* Return error when an overflow has been detected.  */\n@@ -4326,12 +4746,13 @@ check_access (tree exp, tree dstwrite,\n \n       const bool read\n \t= mode == access_read_only || mode == access_read_write;\n+      const bool maybe = pad && pad->dst.parmarray;\n       if (warn_for_access (loc, func, exp, OPT_Wstringop_overread, range,\n-\t\t\t   slen, false, read))\n+\t\t\t   slen, false, read, maybe))\n \t{\n \t  TREE_NO_WARNING (exp) = true;\n \t  if (pad)\n-\t    inform_access (pad->src, access_read_only);\n+\t    pad->src.inform_access (access_read_only);\n \t}\n       return false;\n     }\n@@ -4463,11 +4884,12 @@ gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n /* For an access to an object referenced to by the function parameter PTR\n    of pointer type, and set RNG[] to the range of sizes of the object\n    obtainedfrom the attribute access specification for the current function.\n+   Set STATIC_ARRAY if the array parameter has been declared [static].\n    Return the function parameter on success and null otherwise.  */\n \n tree\n gimple_parm_array_size (tree ptr, wide_int rng[2],\n-\t\t\trange_query * /* = NULL */)\n+\t\t\tbool *static_array /* = NULL */)\n {\n   /* For a function argument try to determine the byte size of the array\n      from the current function declaratation (e.g., attribute access or\n@@ -4499,6 +4921,9 @@ gimple_parm_array_size (tree ptr, wide_int rng[2],\n   if (warn_array_parameter < 2 && !access->static_p)\n     return NULL_TREE;\n \n+  if (static_array)\n+    *static_array = access->static_p;\n+\n   rng[0] = wi::zero (prec);\n   rng[1] = wi::uhwi (access->minsize, prec);\n   /* Multiply the array bound encoded in the attribute by the size\n@@ -4646,14 +5071,92 @@ gimple_call_return_array (gimple *stmt, offset_int offrng[2],\n   return NULL_TREE;\n }\n \n+/* A helper of compute_objsize() to determine the size from an assignment\n+   statement STMT with the RHS of either MIN_EXPR or MAX_EXPR.  */\n+\n+static bool\n+handle_min_max_size (gimple *stmt, int ostype, access_ref *pref,\n+\t\t     ssa_name_limit_t &snlim, range_query *rvals)\n+{\n+  tree_code code = gimple_assign_rhs_code (stmt);\n+\n+  tree ptr = gimple_assign_rhs1 (stmt);\n+\n+  /* In a valid MAX_/MIN_EXPR both operands must refer to the same array.\n+     Determine the size/offset of each and use the one with more or less\n+     space remaining, respectively.  If either fails, use the information\n+     determined from the other instead, adjusted up or down as appropriate\n+     for the expression.  */\n+  access_ref aref[2] = { *pref, *pref };\n+  if (!compute_objsize (ptr, ostype, &aref[0], snlim, rvals))\n+    {\n+      aref[0].base0 = false;\n+      aref[0].offrng[0] = aref[0].offrng[1] = 0;\n+      aref[0].add_max_offset ();\n+      aref[0].set_max_size_range ();\n+    }\n+\n+  ptr = gimple_assign_rhs2 (stmt);\n+  if (!compute_objsize (ptr, ostype, &aref[1], snlim, rvals))\n+    {\n+      aref[1].base0 = false;\n+      aref[1].offrng[0] = aref[1].offrng[1] = 0;\n+      aref[1].add_max_offset ();\n+      aref[1].set_max_size_range ();\n+    }\n+\n+  if (!aref[0].ref && !aref[1].ref)\n+    /* Fail if the identity of neither argument could be determined.  */\n+    return false;\n+\n+  bool i0 = false;\n+  if (aref[0].ref && aref[0].base0)\n+    {\n+      if (aref[1].ref && aref[1].base0)\n+\t{\n+\t  /* If the object referenced by both arguments has been determined\n+\t     set *PREF to the one with more or less space remainng, whichever\n+\t     is appopriate for CODE.\n+\t     TODO: Indicate when the objects are distinct so it can be\n+\t     diagnosed.  */\n+\t  i0 = code == MAX_EXPR;\n+\t  const bool i1 = !i0;\n+\n+\t  if (aref[i0].size_remaining () < aref[i1].size_remaining ())\n+\t    *pref = aref[i1];\n+\t  else\n+\t    *pref = aref[i0];\n+\t  return true;\n+\t}\n+\n+      /* If only the object referenced by one of the arguments could be\n+\t determined, use it and...  */\n+      *pref = aref[0];\n+      i0 = true;\n+    }\n+  else\n+    *pref = aref[1];\n+\n+  const bool i1 = !i0;\n+  /* ...see if the offset obtained from the other pointer can be used\n+     to tighten up the bound on the offset obtained from the first.  */\n+  if ((code == MAX_EXPR && aref[i1].offrng[1] < aref[i0].offrng[0])\n+      || (code == MIN_EXPR && aref[i0].offrng[0] < aref[i1].offrng[1]))\n+    {\n+      pref->offrng[0] = aref[i0].offrng[0];\n+      pref->offrng[1] = aref[i0].offrng[1];\n+    }\n+  return true;\n+}\n+\n /* Helper to compute the size of the object referenced by the PTR\n    expression which must have pointer type, using Object Size type\n    OSTYPE (only the least significant 2 bits are used).\n    On success, sets PREF->REF to the DECL of the referenced object\n    if it's unique, otherwise to null, PREF->OFFRNG to the range of\n    offsets into it, and PREF->SIZRNG to the range of sizes of\n    the object(s).\n-   VISITED is used to avoid visiting the same PHI operand multiple\n+   SNLIM is used to avoid visiting the same PHI operand multiple\n    times, and, when nonnull, RVALS to determine range information.\n    Returns true on success, false when a meaningful size (or range)\n    cannot be determined.\n@@ -4662,8 +5165,8 @@ gimple_call_return_array (gimple *stmt, offset_int offrng[2],\n    to influence code generation or optimization.  */\n \n static bool\n-compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n-\t\t range_query *rvals)\n+compute_objsize (tree ptr, int ostype, access_ref *pref,\n+\t\t ssa_name_limit_t &snlim, range_query *rvals)\n {\n   STRIP_NOPS (ptr);\n \n@@ -4699,7 +5202,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n   if (code == BIT_FIELD_REF)\n     {\n       tree ref = TREE_OPERAND (ptr, 0);\n-      if (!compute_objsize (ref, ostype, pref, visited, rvals))\n+      if (!compute_objsize (ref, ostype, pref, snlim, rvals))\n \treturn false;\n \n       offset_int off = wi::to_offset (pref->eval (TREE_OPERAND (ptr, 2)));\n@@ -4710,14 +5213,18 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n   if (code == COMPONENT_REF)\n     {\n       tree ref = TREE_OPERAND (ptr, 0);\n+      if (TREE_CODE (TREE_TYPE (ref)) == UNION_TYPE)\n+\t/* In accesses through union types consider the entire unions\n+\t   rather than just their members.  */\n+\tostype = 0;\n       tree field = TREE_OPERAND (ptr, 1);\n \n       if (ostype == 0)\n \t{\n \t  /* In OSTYPE zero (for raw memory functions like memcpy), use\n \t     the maximum size instead if the identity of the enclosing\n \t     object cannot be determined.  */\n-\t  if (!compute_objsize (ref, ostype, pref, visited, rvals))\n+\t  if (!compute_objsize (ref, ostype, pref, snlim, rvals))\n \t    return false;\n \n \t  /* Otherwise, use the size of the enclosing object and add\n@@ -4727,9 +5234,17 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n \t    pref->add_offset (wi::to_offset (offset));\n \t  else\n \t    pref->add_max_offset ();\n+\n+\t  if (!pref->ref)\n+\t    /* REF may have been already set to an SSA_NAME earlier\n+\t       to provide better context for diagnostics.  In that case,\n+\t       leave it unchanged.  */\n+\t    pref->ref = ref;\n \t  return true;\n \t}\n \n+      pref->ref = field;\n+\n       if (!addr && POINTER_TYPE_P (TREE_TYPE (field)))\n \t{\n \t  /* Set maximum size if the reference is to the pointer member\n@@ -4738,8 +5253,6 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n \t  return true;\n \t}\n \n-      pref->ref = field;\n-\n       /* SAM is set for array members that might need special treatment.  */\n       special_array_member sam;\n       tree size = component_ref_size (ptr, &sam);\n@@ -4768,7 +5281,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n     {\n       tree ref = TREE_OPERAND (ptr, 0);\n       tree reftype = TREE_TYPE (ref);\n-      if (code == ARRAY_REF\n+      if (!addr && code == ARRAY_REF\n \t  && TREE_CODE (TREE_TYPE (reftype)) == POINTER_TYPE)\n \t/* Avoid arrays of pointers.  FIXME: Hande pointers to arrays\n \t   of known bound.  */\n@@ -4786,7 +5299,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n \t    return false;\n \t}\n \n-      if (!compute_objsize (ref, ostype, pref, visited, rvals))\n+      if (!compute_objsize (ref, ostype, pref, snlim, rvals))\n \treturn false;\n \n       offset_int orng[2];\n@@ -4852,7 +5365,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n   if (code == TARGET_MEM_REF)\n     {\n       tree ref = TREE_OPERAND (ptr, 0);\n-      if (!compute_objsize (ref, ostype, pref, visited, rvals))\n+      if (!compute_objsize (ref, ostype, pref, snlim, rvals))\n \treturn false;\n \n       /* TODO: Handle remaining operands.  Until then, add maximum offset.  */\n@@ -4879,13 +5392,14 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n   if (code == STRING_CST)\n     {\n       pref->sizrng[0] = pref->sizrng[1] = TREE_STRING_LENGTH (ptr);\n+      pref->ref = ptr;\n       return true;\n     }\n \n   if (code == POINTER_PLUS_EXPR)\n     {\n       tree ref = TREE_OPERAND (ptr, 0);\n-      if (!compute_objsize (ref, ostype, pref, visited, rvals))\n+      if (!compute_objsize (ref, ostype, pref, snlim, rvals))\n \treturn false;\n \n       offset_int orng[2];\n@@ -4900,11 +5414,16 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n   if (code == VIEW_CONVERT_EXPR)\n     {\n       ptr = TREE_OPERAND (ptr, 0);\n-      return compute_objsize (ptr, ostype, pref, visited, rvals);\n+      return compute_objsize (ptr, ostype, pref, snlim, rvals);\n     }\n \n-  if (TREE_CODE (ptr) == SSA_NAME)\n+  if (code == SSA_NAME)\n     {\n+      if (!snlim.next ())\n+\treturn false;\n+\n+      /* Only process an SSA_NAME if the recursion limit has not yet\n+\t been reached.  */\n       gimple *stmt = SSA_NAME_DEF_STMT (ptr);\n       if (is_gimple_call (stmt))\n \t{\n@@ -4933,7 +5452,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n \t      offset_int offrng[2];\n \t      if (tree ret = gimple_call_return_array (stmt, offrng, rvals))\n \t\t{\n-\t\t  if (!compute_objsize (ret, ostype, pref, visited, rvals))\n+\t\t  if (!compute_objsize (ret, ostype, pref, snlim, rvals))\n \t\t    return false;\n \n \t\t  /* Cap OFFRNG[1] to at most the remaining size of\n@@ -4964,8 +5483,10 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n \t     of the array from the current function declaratation\n \t     (e.g., attribute access or related).  */\n \t  wide_int wr[2];\n-\t  if (tree ref = gimple_parm_array_size (ptr, wr, rvals))\n+\t  bool static_array = false;\n+\t  if (tree ref = gimple_parm_array_size (ptr, wr, &static_array))\n \t    {\n+\t      pref->parmarray = !static_array;\n \t      pref->sizrng[0] = offset_int::from (wr[0], UNSIGNED);\n \t      pref->sizrng[1] = offset_int::from (wr[1], UNSIGNED);\n \t      pref->ref = ref;\n@@ -4975,14 +5496,19 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n \t  pref->set_max_size_range ();\n \t  pref->base0 = false;\n \t  pref->ref = ptr;\n-\t  if (tree var = SSA_NAME_VAR (ptr))\n-\t    if (TREE_CODE (var) == PARM_DECL)\n-\t      pref->ref = var;\n-\n \t  return true;\n \t}\n \n-      /* TODO: Handle PHI.  */\n+      if (gimple_code (stmt) == GIMPLE_PHI)\n+\t{\n+\t  pref->ref = ptr;\n+\t  access_ref phi_ref = *pref;\n+\t  if (!pref->get_ref (NULL, &phi_ref, ostype, &snlim, rvals))\n+\t    return false;\n+\t  *pref = phi_ref;\n+\t  pref->ref = ptr;\n+\t  return true;\n+\t}\n \n       if (!is_gimple_assign (stmt))\n \t{\n@@ -4992,21 +5518,22 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n \t     PREF->REF to it.  */\n \t  pref->base0 = false;\n \t  pref->set_max_size_range ();\n-\t  if (tree var = SSA_NAME_VAR (ptr))\n-\t    if (TREE_CODE (var) == PARM_DECL)\n-\t      pref->ref = var;\n+\t  pref->ref = ptr;\n \t  return true;\n \t}\n \n-      ptr = gimple_assign_rhs1 (stmt);\n-\n       tree_code code = gimple_assign_rhs_code (stmt);\n \n+      if (code == MAX_EXPR || code == MIN_EXPR)\n+\treturn handle_min_max_size (stmt, ostype, pref, snlim, rvals);\n+\n+      tree rhs = gimple_assign_rhs1 (stmt);\n+\n       if (code == POINTER_PLUS_EXPR\n-\t  && TREE_CODE (TREE_TYPE (ptr)) == POINTER_TYPE)\n+\t  && TREE_CODE (TREE_TYPE (rhs)) == POINTER_TYPE)\n \t{\n \t  /* Compute the size of the object first. */\n-\t  if (!compute_objsize (ptr, ostype, pref, visited, rvals))\n+\t  if (!compute_objsize (rhs, ostype, pref, snlim, rvals))\n \t    return false;\n \n \t  offset_int orng[2];\n@@ -5018,17 +5545,22 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n \t  return true;\n \t}\n \n-      if (code == ADDR_EXPR)\n-\treturn compute_objsize (ptr, ostype, pref, visited, rvals);\n+      if (code == ADDR_EXPR\n+\t  || code == SSA_NAME)\n+\treturn compute_objsize (rhs, ostype, pref, snlim, rvals);\n \n-      /* This could be an assignment from a nonlocal pointer.  Save PTR\n-\t to mention in diagnostics but otherwise treat it as a pointer\n+      /* (This could also be an assignment from a nonlocal pointer.)  Save\n+\t PTR to mention in diagnostics but otherwise treat it as a pointer\n \t to an unknown object.  */\n-      pref->ref = ptr;\n+      pref->ref = rhs;\n+      pref->base0 = false;\n+      pref->set_max_size_range ();\n+      return true;\n     }\n \n   /* Assume all other expressions point into an unknown object\n      of the maximum valid size.  */\n+  pref->ref = ptr;\n   pref->base0 = false;\n   pref->set_max_size_range ();\n   return true;\n@@ -5041,15 +5573,8 @@ tree\n compute_objsize (tree ptr, int ostype, access_ref *pref,\n \t\t range_query *rvals /* = NULL */)\n {\n-  bitmap visited = NULL;\n-\n-  bool success\n-    = compute_objsize (ptr, ostype, pref, &visited, rvals);\n-\n-  if (visited)\n-    BITMAP_FREE (visited);\n-\n-  if (!success)\n+  ssa_name_limit_t snlim;\n+  if (!compute_objsize (ptr, ostype, pref, snlim, rvals))\n     return NULL_TREE;\n \n   offset_int maxsize = pref->size_remaining ();"}, {"sha": "b00af6272233d9b686e8e87dfaf86ed14e71d02a", "filename": "gcc/builtins.h", "status": "modified", "additions": 61, "deletions": 12, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -153,6 +153,42 @@ extern void warn_string_no_nul (location_t, tree, const char *, tree,\n extern tree unterminated_array (tree, tree * = NULL, bool * = NULL);\n extern bool builtin_with_linkage_p (tree);\n \n+/* Describes recursion limits used by functions that follow use-def\n+   chains of SSA_NAMEs.  */\n+\n+class ssa_name_limit_t\n+{\n+  bitmap visited;         /* Bitmap of visited SSA_NAMEs.  */\n+  unsigned ssa_def_max;   /* Longest chain of SSA_NAMEs to follow.  */\n+\n+  /* Not copyable or assignable.  */\n+  DISABLE_COPY_AND_ASSIGN (ssa_name_limit_t);\n+\n+public:\n+\n+  ssa_name_limit_t ()\n+    : visited (),\n+      ssa_def_max (param_ssa_name_def_chain_limit) { }\n+\n+  /* Set a bit for the PHI in VISITED and return true if it wasn't\n+     already set.  */\n+  bool visit_phi (tree);\n+  /* Clear a bit for the PHI in VISITED.  */\n+  void leave_phi (tree);\n+  /* Return false if the SSA_NAME chain length counter has reached\n+     the limit, otherwise increment the counter and return true.  */\n+  bool next ();\n+\n+  /* If the SSA_NAME has already been \"seen\" return a positive value.\n+     Otherwise add it to VISITED.  If the SSA_NAME limit has been\n+     reached, return a negative value.  Otherwise return zero.  */\n+  int next_phi (tree);\n+\n+  ~ssa_name_limit_t ();\n+};\n+\n+class range_query;\n+\n /* Describes a reference to an object used in an access.  */\n struct access_ref\n {\n@@ -162,17 +198,12 @@ struct access_ref\n      is a constant zero.  */\n   access_ref (tree = NULL_TREE, bool = false);\n \n-  /* Reference to the accessed object(s).  */\n-  tree ref;\n+  /* Return the PHI node REF refers to or null if it doesn't.  */\n+  gphi *phi () const;\n \n-  /* Range of byte offsets into and sizes of the object(s).  */\n-  offset_int offrng[2];\n-  offset_int sizrng[2];\n-  /* Range of the bound of the access: denotes that the access\n-     is at least BNDRNG[0] bytes but no more than BNDRNG[1].\n-     For string functions the size of the actual access is\n-     further constrained by the length of the string.  */\n-  offset_int bndrng[2];\n+  /* Return the object to which REF refers.  */\n+  tree get_ref (vec<access_ref> *, access_ref * = NULL, int = 1,\n+\t\tssa_name_limit_t * = NULL, range_query * = NULL) const;\n \n   /* Return true if OFFRNG is the constant zero.  */\n   bool offset_zero () const\n@@ -211,6 +242,22 @@ struct access_ref\n     add_offset (-maxoff - 1, maxoff);\n   }\n \n+  /* Issue an informational message describing the target of an access\n+     with the given mode.  */\n+  void inform_access (access_mode) const;\n+\n+  /* Reference to the accessed object(s).  */\n+  tree ref;\n+\n+  /* Range of byte offsets into and sizes of the object(s).  */\n+  offset_int offrng[2];\n+  offset_int sizrng[2];\n+  /* Range of the bound of the access: denotes that the access\n+     is at least BNDRNG[0] bytes but no more than BNDRNG[1].\n+     For string functions the size of the actual access is\n+     further constrained by the length of the string.  */\n+  offset_int bndrng[2];\n+\n   /* Used to fold integer expressions when called from front ends.  */\n   tree (*eval)(tree);\n   /* Set if trailing one-element arrays should be treated as flexible\n@@ -219,6 +266,9 @@ struct access_ref\n   /* Set if valid offsets must start at zero (for declared and allocated\n      objects but not for others referenced by pointers).  */\n   bool base0;\n+  /* Set if REF refers to a function array parameter not declared\n+     static.  */\n+  bool parmarray;\n };\n \n /* Describes a pair of references used in an access by built-in\n@@ -242,10 +292,9 @@ struct access_data\n   access_mode mode;\n };\n \n-class range_query;\n extern tree gimple_call_alloc_size (gimple *, wide_int[2] = NULL,\n \t\t\t\t    range_query * = NULL);\n-extern tree gimple_parm_array_size (tree, wide_int[2], range_query * = NULL);\n+extern tree gimple_parm_array_size (tree, wide_int[2], bool * = NULL);\n extern tree compute_objsize (tree, int, access_ref *, range_query * = NULL);\n extern tree compute_objsize (tree, int, tree * = NULL, tree * = NULL,\n \t\t\t     range_query * = NULL);"}, {"sha": "1d79930cd58c202c3dc9199c7738e54f9fbfea35", "filename": "gcc/testsuite/c-c++-common/Wstringop-overflow-2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -10,7 +10,7 @@ void sink (void*);\n struct Ax\n {\n   char n;\n-  char a[];                     // { dg-message \"declared here\" }\n+  char a[];                     // { dg-message \"destination object\" \"note\" }\n };\n \n // Verify warning for a definition with no initializer.\n@@ -91,7 +91,7 @@ void gaxx (void)\n struct A0\n {\n   char n;\n-  char a[0];                    // { dg-message \"declared here\" }\n+  char a[0];                    // { dg-message \"destination object\" \"note\" }\n };\n \n // Verify warning for a definition with no initializer.\n@@ -158,7 +158,7 @@ void ga0x (void)\n struct A1\n {\n   char n;\n-  char a[1];                    // { dg-message \"declared here\" }\n+  char a[1];                    // { dg-message \"destination object\" \"note\" }\n };\n \n // Verify warning for a definition with no initializer.\n@@ -256,7 +256,7 @@ void ga1x (void)\n struct A1i\n {\n   char n;\n-  char a[1];                    // { dg-message \"declared here\" }\n+  char a[1];                    // { dg-message \"destination object\" }\n   char x;\n };\n "}, {"sha": "25325b3f8390333e558354cdba8809c13e83fc57", "filename": "gcc/testsuite/g++.dg/warn/Wplacement-new-size.C", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size.C?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -332,11 +332,11 @@ void test (void *p, int32_t n)\n     new (&uac2.c) int32_t;                  // { dg-warning \"placement\" }\n     new (&uac3.c) int32_t;                  // { dg-warning \"placement\" }\n \n-    // Diagnose the following even though the size of uac4.c could be\n-    // expected to extend to the end of the union (as it is by Built-in\n-    // Object Size and so isn't diagnosed in calls to functions like\n-    // memset(&uac4.c, 0, sizeof(int32_t)) when _FORTIFY_SOURCE is non-zero.  */\n-    new (&uac4.c) int32_t;                  // { dg-warning \"placement\" }\n+    /* The following isn't diagnosed (anymore) for consistency with\n+       the middle end where members of unions are considered to extend\n+       to the end of the enclosing object.\n+       See gcc.dg/Wstringop-overflow-60.c for the middle end test.  */\n+    new (&uac4.c) int32_t;\n \n     new (&uac4.c + 1) int32_t;              // { dg-warning \"placement\" }\n }"}, {"sha": "c68e82a4a58340055427a62d92230db801445af2", "filename": "gcc/testsuite/g++.dg/warn/Wstringop-overflow-3.C", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-3.C?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -12,7 +12,7 @@ void sink (void*);\n struct Ax\n {\n   char n;\n-  char a[];                     // { dg-message \"at offset \\[0-2\\] to object 'Ax::a' declared here\" \"note: flexarray\" }\n+  char a[];                     // { dg-message \"destination object 'Ax::a' of size 0\" \"note: flexarray\" }\n };\n \n // Verify warning for a definition with no initializer.\n@@ -93,7 +93,7 @@ NOIPA void gaxx ()\n struct A0\n {\n   char n;\n-  char a[0];                    // { dg-message \"at offset \\[0-2\\] to object 'A0::a' with size 0 declared here\" \"note: trailing zero-length array\" }\n+  char a[0];                    // { dg-message \"destination object 'A0::a' of size 0\" \"note: trailing zero-length array\" }\n };\n \n // Verify warning for a definition with no initializer.\n@@ -160,7 +160,7 @@ NOIPA void ga0x ()\n struct A1\n {\n   char n;\n-  char a[1];                    // { dg-message \"at offset \\[1-9\\] to object 'A1::a' with size 1 declared here\" \"note: trailing one-element array\" }\n+  char a[1];                    // { dg-message \"at offset \\[1-2\\] into destination object 'A1::a' of size 1\" \"note: trailing one-element array\" }\n };\n \n // Verify warning for a definition with no initializer.\n@@ -234,7 +234,7 @@ NOIPA void ga1x ()\n struct A1i\n {\n   char n;\n-  char a[1];                    // { dg-message \"at offset \\[1-9\\] to object 'A1i::a' with size 1 declared here\" \"note: interior one-element array\" }\n+  char a[1];                    // { dg-message \"at offset \\[1-2\\] into destination object 'A1i::a' of size 1\" \"note: interior one-element array\" }\n   char x;\n };\n \n@@ -307,7 +307,7 @@ NOIPA void ga1ix ()\n struct Bx\n {\n   char n;\n-  char a[];                     // { dg-message \"at offset 0 to object 'Bx::a' declared here\" \"note: flexarray class member\" }\n+  char a[];                     // { dg-message \"destination object 'Bx::a' of size 0\" \"note: flexarray class member\" }\n \n   // Verify the warning for a constant.\n   Bx () { a[0] = 0; }           // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -332,7 +332,7 @@ NOIPA void gbxi (int i)\n struct B0\n {\n   char n;\n-  char a[0];                    // { dg-message \"at offset 0 to object 'B0::a' with size 0 declared here\" \"note: zero-length trailing array class member\" }\n+  char a[0];                    // { dg-message \"destination object 'B0::a' of size 0\" \"note: zero-length trailing array class member\" }\n \n   B0 () { a[0] = 0; }           // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n };\n@@ -348,7 +348,7 @@ NOIPA void gb0 (void)\n struct B1\n {\n   char n;\n-  char a[1];                    // { dg-message \"at offset 1 to object 'B1::a' with size 1 declared here\" \"note: one-element trailing array class member\" }\n+  char a[1];                    // { dg-message \"at offset 1 into destination object 'B1::a' of size 1\" \"note: one-element trailing array class member\" }\n \n   B1 () { a[1] = 0; }           // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n };\n@@ -362,7 +362,7 @@ NOIPA void gb1 (void)\n \n struct B123\n {\n-  char a[123];                  // { dg-message \"at offset 123 to object 'B123::a' with size 123 declared here\" \"note: large trailing array class member\" }\n+  char a[123];                  // { dg-message \"at offset 123 into destination object 'B123::a' of size 123\" \"note: large trailing array class member\" }\n \n   B123 () { a[123] = 0; }       // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n };\n@@ -376,7 +376,7 @@ NOIPA void gb123 (void)\n \n struct B234\n {\n-  char a[234];                  // { dg-message \"at offset 234 to object 'B234::a' with size 234 declared here\" \"note: large trailing array class member\" }\n+  char a[234];                  // { dg-message \"at offset 234 into destination object 'B234::a' of size 234\" \"note: large trailing array class member\" }\n \n   B234 (int i) { a[i] = 0; }    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n };"}, {"sha": "0f521a7250d79b29afcd8ab4058f6730510d2bb3", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-43.c", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-43.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -5,20 +5,9 @@\n \n #define NOIPA __attribute__ ((noipa))\n \n-const char a0[] = \"\";\n-const char a1[] = \"1\";\n-const char a2[] = \"12\";\n-const char a3[] = \"123\";\n-const char a4[] = \"1234\";\n-const char a5[] = \"12345\";\n-const char a6[] = \"123456\";\n-const char a7[] = \"1234567\";\n-const char a8[] = \"12345678\";\n const char a9[] = \"123456789\";\n \n-void f (const char*, ...);\n-\n-int i0, i1, i2, i3, i4, i5, i6, i7, i8;\n+void sink (const char*, ...);\n \n NOIPA int g2 (int i)\n {\n@@ -28,7 +17,7 @@ NOIPA int g2 (int i)\n   const char *p1 = p0 + i;\n   const char *p2 = p1 + i;\n \n-  f (p0, p1, p2);\n+  sink (p0, p1, p2);\n \n   return p2[8];     // { dg-warning \"\\\\\\[-Warray-bounds]\" }\n }\n@@ -42,7 +31,7 @@ NOIPA int g3 (int i)\n   const char *p2 = p1 + i;\n   const char *p3 = p2 + i;\n \n-  f (p0, p1, p2, p3);\n+  sink (p0, p1, p2, p3);\n \n   return p3[7];     // { dg-warning \"\\\\\\[-Warray-bounds]\" }\n }\n@@ -57,7 +46,7 @@ NOIPA int g4 (int i)\n   const char *p3 = p2 + i;\n   const char *p4 = p3 + i;\n \n-  f (p0, p1, p2, p3, p4);\n+  sink (p0, p1, p2, p3, p4);\n \n   return p4[6];     // { dg-warning \"\\\\\\[-Warray-bounds]\" }\n }\n@@ -73,7 +62,7 @@ NOIPA int g5 (int i)\n   const char *p4 = p3 + i;\n   const char *p5 = p4 + i;\n \n-  f (p0, p1, p2, p3, p4, p5);\n+  sink (p0, p1, p2, p3, p4, p5);\n \n   return p5[5];\n }\n@@ -90,7 +79,7 @@ NOIPA int g6 (int i)\n   const char *p5 = p4 + i;\n   const char *p6 = p5 + i;\n \n-  f (p0, p1, p2, p3, p4, p5, p6);\n+  sink (p0, p1, p2, p3, p4, p5, p6);\n \n   return p6[4];\n }\n@@ -108,7 +97,7 @@ NOIPA int g7 (int i)\n   const char *p6 = p5 + i;\n   const char *p7 = p6 + i;\n \n-  f (p0, p1, p2, p3, p4, p5, p6, p7);\n+  sink (p0, p1, p2, p3, p4, p5, p6, p7);\n \n   return p7[3];\n }\n@@ -127,7 +116,7 @@ NOIPA int g8 (int i)\n   const char *p7 = p6 + i;\n   const char *p8 = p7 + i;\n \n-  f (p0, p1, p2, p3, p4, p5, p6, p7, p8);\n+  sink (p0, p1, p2, p3, p4, p5, p6, p7, p8);\n \n   return p8[2];\n }"}, {"sha": "ec3c97e8102526442b1549c4087334269186ccc2", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-11.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-11.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -72,7 +72,7 @@ void test_memset_array_range_cst_off (void)\n {\n   T (SR (-7, 7), 1, 7);\n   T (SR (-1, 1), 1, 7);\n-  T (SR (-1, 1), 1, 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" { xfail *-*-*} } */\n+  T (SR (-1, 1), 1, 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" } */\n   T (SR ( 1, 2), 1, 1);\n   T (SR ( 1, 2), 1, 5);\n \n@@ -147,7 +147,7 @@ void test_memcpy_array_range_cst_off (const void *s)\n {\n   T (SR (-7, 7), 1, 7);\n   T (SR (-1, 1), 1, 7);\n-  T (SR (-1, 1), 1, 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" { xfail *-*-*} } */\n+  T (SR (-1, 1), 1, 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" } */\n   T (SR ( 1, 2), 1, 1);\n   T (SR ( 1, 2), 1, 5);\n \n@@ -224,7 +224,7 @@ void test_strcpy_array_range_cst_off (const char *s)\n {\n   T (SR (-7, 7), 1, 6);\n   T (SR (-1, 1), 1, 6);\n-  T (SR (-1, 1), 1, 8);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" { xfail *-*-*} } */\n+  T (SR (-1, 1), 1, 8);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" } */\n   T (SR ( 1, 2), 1, 0);\n   T (SR ( 1, 2), 1, 1);\n   T (SR ( 1, 2), 1, 4);\n@@ -290,7 +290,7 @@ void test_strncpy_array_range_cst_off (const char *s)\n {\n   T (SR (-7, 7), 1, 7);\n   T (SR (-1, 1), 1, 7);\n-  T (SR (-1, 1), 1, 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" { xfail *-*-*} } */\n+  T (SR (-1, 1), 1, 9);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr89428\" } */\n   T (SR ( 1, 2), 1, 1);\n   T (SR ( 1, 2), 1, 5);\n "}, {"sha": "7c3dc8c0544fc9e9635ac9a031b94b9529de8606", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-12.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-12.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -25,7 +25,9 @@ void test_memcpy_array_cst_range_off (const void *s)\n   T (d + UR (1, 2), 5);\n \n   T (d + UR (0, 1), 6);\n-  T (d + UR (0, 1), 7);       /* { dg-warning \".memcpy. writing 6 bytes into a region of size 5 overflows the destination\" \"pr89428\" { xfail *-*-* } } */\n+  /* The warning below should be \"writing\" but the [0, 1] range\n+     is somehow lost and get_range_info() returns VR_VARYING.  */\n+  T (d + UR (0, 1), 7);       /* { dg-warning \".memcpy. writing 7 bytes into a region of size 6 overflows the destination\" \"pr89428\" { xfail *-*-* } } */\n   T (d + UR (1, 2), 6);       /* { dg-warning \".memcpy. writing 6 bytes into a region of size 5 overflows the destination\" } */\n   T (d + UR (1, 2), 7);       /* { dg-warning \"writing 7 bytes into a region of size 5 \" } */\n \n@@ -48,7 +50,8 @@ void test_memcpy_array_range_range_off (const void *s)\n   char *d = ga7 + UR (0, 1);\n   T (d + SR (-1, 0), 1);\n   T (d + SR (-1, 0), 7);\n-  T (d + SR (-1, 0), 9);       /* { dg-warning \"writing 1 byte into a region of size 0 \" \"pr89350\" { xfail *-*-* } } */\n+  T (d + SR (-1, 0), 8);       /* { dg-warning \"writing 8 bytes into a region of size 7 \" } */\n+  T (d + SR (-1, 0), 9);       /* { dg-warning \"writing 9 bytes into a region of size 7 \" \"pr89350\" } */\n }\n \n "}, {"sha": "9c05d04f90c8df56156957f7cf450b7dda1b984f", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-17.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-17.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -13,7 +13,7 @@ void sink (void*);\n \n void call_copy_n (const char *s)\n {\n-  char a[7];        // { dg-message \"declared here\" }\n+  char a[7];        // { dg-message \"at offset 7 into destination object 'a'\" }\n   copy_n (a, \"1234567\", 7);\n   sink (a);\n }"}, {"sha": "607c27989a3bfcf05ac2cf1f745bcd81ae6d2f8c", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-27.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-27.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -261,8 +261,7 @@ void test_strcpy_warn (const char *s)\n        that the conversion from signed int to size_t doesn't prevent\n        the detection.  */\n     int n = strlen (a);\n-    char *t = (char*)calloc (n, 1);     // { dg-message \"at offset 0 to an object with size 3 allocated by 'calloc' here\" \"calloc note 1\" { xfail *-*-* } }\n-                                        // { dg-message \"at offset 0 to an object with size at most 3 allocated by 'calloc' here\" \"calloc note 2\" { target *-*-* } .-1 }\n+    char *t = (char*)calloc (n, 1);     // { dg-message \"destination object of size 3 allocated by 'calloc'\" \"note\" }\n     strcpy (t, a);                      // { dg-warning \"writing 4 bytes into a region of size (between 0 and )?3 \" }\n \n     sink (t);\n@@ -271,23 +270,22 @@ void test_strcpy_warn (const char *s)\n   {\n     const char a[] = \"1234\";\n     size_t n = strlen (a);\n-    char *t = (char*)malloc (n);        // { dg-message \"at offset 0 to an object with size 4 allocated by 'malloc' here\" \"malloc note 1\" { xfail *-*-* } }\n-                                        // { dg-message \"at offset 0 to an object with size at most 4 allocated by 'malloc' here\" \"malloc note 2\" { target *-*-* } .-1 }\n+    char *t = (char*)malloc (n);        // { dg-message \"destination object of size 4 allocated by 'malloc'\" \"note\" }\n     strcpy (t, a);                      // { dg-warning \"writing 5 bytes into a region of size (between 0 and )?4 \" }\n     sink (t);\n   }\n \n   // Exercise PR middle-end/85484.\n   {\n     size_t len = strlen (s);\n-    char vla[len];                      // { dg-message \"at offset 0 to an object declared here\" \"vla note\" }\n+    char vla[len];                      // { dg-message \"destination object 'vla'\" \"vla note\" }\n     strcpy (vla, s);                    // { dg-warning \"writing one too many bytes into a region of a size that depends on 'strlen'\" }\n     sink (vla);\n   }\n \n   {\n     size_t n = strlen (s);\n-    char *t = (char*)malloc (n);        // { dg-message \"at offset 0 to an object allocated by 'malloc' here\" \"malloc note\" }\n+    char *t = (char*)malloc (n);        // { dg-message \"allocated by 'malloc'\" \"malloc note\" }\n     strcpy (t, s);                      // { dg-warning \"writing one too many bytes into a region of a size that depends on 'strlen'\" }\n     sink (t);\n   }"}, {"sha": "5009fb5763a43365d3e33bc4136fe423f56601d6", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-28.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-28.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -40,27 +40,27 @@ void same_size_and_offset_idx_cst (void)\n     const size_t n = UR (2, 3);\n \n     T (n, n, -4);   // { dg-warning \"writing 1 byte into a region of size 0\" }\n-                    // { dg-message \"at offset \\\\\\[-2, -1] to an object with size between 2 and 3 allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n+                    // { dg-message \"at offset \\\\\\[-2, -1] into destination object of size \\\\\\[2, 3] allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n     T (n, n, -3);\n     T (n, n, -2);\n     T (n, n, -1);\n     T (n, n,  0);\n     T (n, n,  1);   // { dg-warning \"writing 1 byte into a region of size 0\" }\n-                    // { dg-message \"at offset \\\\\\[3, 4] to an object with size between 2 and 3 allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n+                    // { dg-message \"at offset 3 into destination object of size \\\\\\[2, 3] allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n   }\n \n   {\n     const size_t n = UR (3, 4);\n \n     T (n, n, -5);   // { dg-warning \"writing 1 byte into a region of size 0\" }\n-                    // { dg-message \"at offset \\\\\\[-2, -1] to an object with size between 3 and 4 allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n+                    // { dg-message \"at offset \\\\\\[-2, -1] into destination object of size \\\\\\[3, 4] allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n     T (n, n, -4);\n     T (n, n, -3);\n     T (n, n, -2);\n     T (n, n, -1);\n     T (n, n,  0);\n     T (n, n,  1);   // { dg-warning \"writing 1 byte into a region of size 0\" }\n-                    // { dg-message \"at offset \\\\\\[4, 5] to an object with size between 3 and 4 allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n+                    // { dg-message \"at offset 4 into destination object of size \\\\\\[3, 4] allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n   }\n \n   {\n@@ -84,36 +84,36 @@ void different_size_and_offset_idx_cst (void)\n     const size_t i = UR (1, 2);\n \n     T (n, i, -4);   // { dg-warning \"writing 1 byte into a region of size 0\" }\n-                    // { dg-message \"at offset \\\\\\[-3, -2] to an object with size between 2 and 3 allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n+                    // { dg-message \"at offset \\\\\\[-3, -2] into destination object of size \\\\\\[2, 3] allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n     T (n, i, -3);   // { dg-warning \"writing 1 byte into a region of size 0\" }\n-                    // { dg-message \"at offset \\\\\\[-2, -1] to an object with size between 2 and 3 allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n+                    // { dg-message \"at offset \\\\\\[-2, -1] into destination object of size \\\\\\[2, 3] allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n     T (n, i, -2);\n     T (n, i, -1);\n     T (n, i,  0);\n     T (n, i,  1);\n     T (n, i,  2);   // { dg-warning \"writing 1 byte into a region of size 0\" }\n-                    // { dg-message \"at offset \\\\\\[3, 4] to an object with size between 2 and 3 allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n+                    // { dg-message \"at offset 3 into destination object of size \\\\\\[2, 3] allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n   }\n \n   {\n     const size_t n = UR (3, 4);\n     const size_t i = UR (2, 5);\n \n     T (n, i, -6);   // { dg-warning \"writing 1 byte into a region of size 0\" }\n-                    // { dg-message \"at offset \\\\\\[-4, -1] to an object with size between 3 and 4 allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n+                    // { dg-message \"at offset \\\\\\[-4, -2] into destination object of size \\\\\\[3, 4] allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n \n-    /* The offsets -5 and -4 are both necessarily invalid even if the sum\n-       (i - 5) and (i - 4) are (or could be) in bounds because they imply\n-       that the intermediate offset (p + i) is out of bounds.  */\n-    T (n, i, -5);   // { dg-warning \"\" \"intermediate offset\" { xfail *-*-* } }\n-    T (n, i, -4);   // { dg-warning \"\" \"intermediate offset\" { xfail *-*-* } }\n+    /* The offset -5 is necessarily invalid even if the sum (i - 5) is (or\n+       could be) in bounds because it implies that the intermediate offset\n+       (p + i) is out of bounds.  */\n+    T (n, i, -5);   // { dg-warning \"writing 1 byte into a region of size 0 \" }\n+    T (n, i, -4);\n     T (n, i, -3);\n     T (n, i, -2);\n     T (n, i, -1);\n     T (n, i,  0);\n     T (n, i,  1);\n     T (n, i,  2);   // { dg-warning \"writing 1 byte into a region of size 0\" }\n-                    // { dg-message \"at offset \\\\\\[4, 7] to an object with size between 3 and 4 allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n+                    // { dg-message \"at offset 4 into destination object of size \\\\\\[3, 4] allocated by 'alloc1'\" \"note\" { target *-*-* } .-1 }\n   }\n }\n \n@@ -133,11 +133,8 @@ void different_size_and_offset_idx_var (void)\n     T (n, i, SR (       0, 1));\n     T (n, i, SR (       1, 2));\n     T (n, i, SR (       2, 3));\n-    /* The warning is issued below but the offset and the size in\n-       the note are wrong.  See the FIXME in compute_objsize().  */\n     T (n, i, SR (       3, 4));    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n-                                   // { dg-message \"at offset 4 to an object with size between 3 and 4 allocated by 'alloc1'\" \"pr92940 note: offset addition\" { xfail *-*-* } .-1 }\n-                                   // { dg-message \"at offset . to an object with size . allocated by 'alloc1'\" \"note: offset addition\" { target *-*-* } .-2 }\n+                                   // { dg-message \"at offset 4 into destination object of size \\\\\\[3, 4] allocated by 'alloc1'\" \"pr92940 note: offset addition\" { target *-*-* } .-1 }\n  }\n }\n "}, {"sha": "f13abbd7ca0813a3d6f78d7b2a7572a08defda36", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-29.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-29.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -11,7 +11,7 @@ void sink (void*);\n \n void direct_call (void)\n {\n-  char *q = allocfn (0);            // { dg-message \"at offset 0 to an object with size 0 allocated by 'allocfn'\" }\n+  char *q = allocfn (0);            // { dg-message \"object of size 0 allocated by 'allocfn'\" \"note\" }\n   q[0] = 0;                         // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n   sink (q);\n }\n@@ -20,7 +20,7 @@ void direct_call (void)\n void local_ptr_call (void)\n {\n   allocfn_t *ptr = allocfn;\n-  char *q = ptr (1);                // { dg-message \"at offset -1 to an object with size 1 allocated by 'allocfn'\" }\n+  char *q = ptr (1);                // { dg-message \"at offset -1 into destination object of size 1 allocated by 'allocfn'\" \"note\" }\n   q[0] = 0;\n   q[-1] = 0;                        // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n   sink (q);\n@@ -32,7 +32,7 @@ void global_ptr_call (void)\n   extern allocfn_t *ptralloc;\n \n   allocfn_t *ptr = ptralloc;\n-  char *q = ptr (2);               // { dg-message \"at offset 3 to an object with size 2 allocated by 'ptralloc'\" }\n+  char *q = ptr (2);               // { dg-message \"at offset 3 into destination object of size 2 allocated by 'ptralloc'\" \"note\" }\n   q[0] = 0;\n   q[1] = 1;\n   q[3] = 3;                        // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -44,7 +44,7 @@ void global_ptr_array_call (void)\n   extern allocfn_t * (arralloc[]);\n \n   allocfn_t *ptr = arralloc[0];\n-  char *q = ptr (2);               // { dg-message \"at offset 3 to an object with size 2 allocated by 'ptr'\" }\n+  char *q = ptr (2);               // { dg-message \"at offset 3 into destination object of size 2 allocated by 'ptr'\" \"note\" }\n   q[0] = 1;\n   q[1] = 2;\n   q[3] = 3;                        // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n@@ -56,7 +56,7 @@ struct S { allocfn_t *ptralloc; };\n \n void member_ptr_call (struct S *p)\n {\n-  char *q = p->ptralloc (3);       // { dg-message \"at offset 5 to an object with size 3 allocated by 'ptralloc' here\" }\n+  char *q = p->ptralloc (3);       // { dg-message \"at offset 5 into destination object of size 3 allocated by 'ptralloc'\" \"note\" }\n   q[0] = 0;\n   q[1] = 1;\n   q[2] = 2;"}, {"sha": "d9cf32d8784f60b431c1ce705b90e00a5df5eb63", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-37.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-37.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-37.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-37.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -67,7 +67,7 @@ void* warn_malloc_3_5 (const char *s, unsigned n)\n {\n   if (n < 3 || 5 < n)\n     n = 3;\n-  char *p = (char*)malloc (n);          // { dg-message \"at offset 1 into destination object of size \\\\\\[3, 5] allocated by 'malloc'\" }\n+  char *p = (char*)malloc (n);          // { dg-message \"at offset 1 into destination object of size \\\\\\[3, 5] allocated by 'malloc'\" \"note\" }\n   // The size below should be a range like the one above.\n   strncpy (p + 1, s, 5);                // { dg-warning \"writing 5 bytes into a region of size 4 \" }\n   return p;\n@@ -89,7 +89,7 @@ void* warn_usr_alloc_3_5 (UsrAlloc *usr_alloc, const char *s, unsigned n)\n {\n   if (n < 3 || 5 < n)\n     n = 3;\n-  char *p = (char*)usr_alloc (n, 3);    // { dg-message \"at offset 1 into destination object of size \\\\\\[9, 15] allocated by 'usr_alloc'\" }\n+  char *p = (char*)usr_alloc (n, 3);    // { dg-message \"at offset 1 into destination object of size \\\\\\[9, 15] allocated by 'usr_alloc'\" \"note\" }\n   // The size below should be a range like the one above.\n   strncpy (p + 1, s, 15);               // { dg-warning \"writing 15 bytes into a region of size 14 \" }\n   return p;\n@@ -179,67 +179,67 @@ void test_note (const char *s)\n   extern void sink (void*);\n \n   {\n-    char a[1][1][2];                    // { dg-message \"destination object\" }\n+    char a[1][1][2];                    // { dg-message \"destination object\" \"note\" }\n     strncpy (a[0][0], s, 3);            // { dg-warning \"writing 3 bytes into a region of size 2 \" }\n     sink (a);\n   }\n \n   {\n-    char a[1][1][2];                    // { dg-message \"at offset 2 into \" }\n+    char a[1][1][2];                    // { dg-message \"at offset 2 into \" \"note\" }\n     strncpy (a[0][1], s, 3);            // { dg-warning \"writing 3 bytes into a region of size 0 \" }\n     sink (a);\n   }\n \n   {\n-    char a[1][2][2];                    // { dg-message \"destination object\" }\n+    char a[1][2][2];                    // { dg-message \"destination object\" \"note\" }\n     strncpy (a[0][0], s, 3);            // { dg-warning \"writing 3 bytes into a region of size 2 \" }\n     sink (a);\n   }\n \n   {\n-    char a[1][2][2];                    // { dg-message \"at offset 2 into \" }\n+    char a[1][2][2];                    // { dg-message \"at offset 2 into \" \"note\" }\n     strncpy (a[0][1], s, 3);            // { dg-warning \"writing 3 bytes into a region of size 2 \" }\n     sink (a);\n   }\n \n   {\n-    char a[1][2][2];                    // { dg-message \"at offset 4 into \" }\n+    char a[1][2][2];                    // { dg-message \"at offset 4 into \" \"note\" }\n     strncpy (a[1][0], s, 3);            // { dg-warning \"writing 3 bytes into a region of size 0 \" }\n     sink (a);\n   }\n \n   {\n-    char a[2][1][2];                    // { dg-message \"at offset 2 into \" }\n+    char a[2][1][2];                    // { dg-message \"at offset 2 into \" \"note\" }\n     strncpy (a[0][1], s, 3);            // { dg-warning \"writing 3 bytes into a region of size 0 \" }\n     sink (a);\n   }\n \n   {\n-    char a[2][1][2];                    // { dg-message \"at offset 2 into \" }\n+    char a[2][1][2];                    // { dg-message \"at offset 2 into \" \"note\" }\n     strncpy (a[1][0], s, 3);            // { dg-warning \"writing 3 bytes into a region of size 2 \" }\n     sink (a);\n   }\n \n   {\n-    char a[2][2][3];                    // { dg-message \"at offset 9 into \" }\n+    char a[2][2][3];                    // { dg-message \"at offset 9 into \" \"note\" }\n     strncpy (a[1][1], s, 4);            // { dg-warning \"writing 4 bytes into a region of size 3 \" }\n     sink (a);\n   }\n \n   {\n-    char a[2][3][3];                    // { dg-message \"at offset 12 into \" }\n+    char a[2][3][3];                    // { dg-message \"at offset 12 into \" \"note\" }\n     strncpy (a[1][1], s, 5);            // { dg-warning \"writing 5 bytes into a region of size 3 \" }\n     sink (a);\n   }\n \n   {\n-    char a[2][3][3];                    // { dg-message \"at offset 12 into \" }\n+    char a[2][3][3];                    // { dg-message \"at offset 12 into \" \"note\" }\n     strncpy (a[1][1], s, 6);            // { dg-warning \"writing 6 bytes into a region of size 3 \" }\n     sink (a);\n   }\n \n   {\n-    char a[2][3][3];                    // { dg-message \"at offset 15 into \" }\n+    char a[2][3][3];                    // { dg-message \"at offset 15 into \" \"note\" }\n     strncpy (a[1][2], s, 7);            // { dg-warning \"writing 7 bytes into a region of size 3 \" }\n     sink (a);\n   }"}, {"sha": "b126fcbdcaef6d8c4780b65d3ab7b2e20be46ac2", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-46.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-46.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-46.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-46.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -53,7 +53,7 @@ void nowarn_memchr_anti_range_memset_cst (const void *s, size_t n)\n \n void warn_memchr_cst_memset_cst (const void *s)\n {\n-  char *p = malloc (4);                 // { dg-message \"at offset \\\\\\[0, 4] into destination object of size 4 \" \"note\" }\n+  char *p = malloc (4);                 // { dg-message \"destination object of size 4 \" \"note\" }\n   sink (p);\n \n   p = memchr (p, '1', 4);\n@@ -62,7 +62,7 @@ void warn_memchr_cst_memset_cst (const void *s)\n \n void warn_memchr_var_memset_cst (const void *s, unsigned n)\n {\n-  char *p = malloc (4);                 // { dg-message \"at offset \\\\\\[0, 4] into destination object of size 4 \" \"note\" }\n+  char *p = malloc (4);                 // { dg-message \"destination object of size 4 \" \"note\" }\n   sink (p);\n \n   p = memchr (p, '1', n);\n@@ -79,9 +79,9 @@ void warn_memchr_var_memset_range (const void *s, unsigned n)\n      as in the first two notes.  The exact value probably isn't too\n      important. */\n   char *p0 = malloc (UR (5, 7));\n-  // { dg-message \"at offset \\\\\\[0, 7] into destination object of size \\\\\\[5, 7]\" \"note\" { target *-*-* } .-1 }\n-  // { dg-message \"at offset \\\\\\[1, 7] into destination object of size \\\\\\[5, 7]\" \"note\"  { target *-*-* } .-2 }\n-  // { dg-message \"at offset \\\\\\[2, 7] into destination object of size \\\\\\[5, 7]\" \"note\"  { target *-*-* } .-3 }\n+  // { dg-message \": destination object of size \\\\\\[5, 7]\" \"note 1\" { target *-*-* } .-1 }\n+  // { dg-message \"at offset \\\\\\[1, 7] into destination object of size \\\\\\[5, 7]\" \"note 2\"  { target *-*-* } .-2 }\n+  // { dg-message \"at offset \\\\\\[2, 7] into destination object of size \\\\\\[5, 7]\" \"note 3\"  { target *-*-* } .-3 }\n \n   sink (p0);\n   char *p1 = memchr (p0, '1', n);"}, {"sha": "cb2c329aa841554e593fc364c7fde486b4430da0", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-47.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-47.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-47.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-47.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -26,7 +26,7 @@ void nowarn_c32 (char c)\n \n void warn_c32 (char c)\n {\n-  extern char warn_a32[32];   // { dg-message \"at offset 32 to object 'warn_a32' with size 32\" \"note\" }\n+  extern char warn_a32[32];   // { dg-message \"at offset 32 into destination object 'warn_a32' of size 32\" \"note\" }\n \n   void *p = warn_a32 + 1;\n   *(C32*)p = (C32){ c };      // { dg-warning \"writing 1 byte into a region of size 0\" }"}, {"sha": "f5929c9e7d6176160305452fb8468084395e34ff", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-54.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-54.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-54.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-54.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -15,7 +15,7 @@ void sink (void*);\n void char_flexarray_cst_off_cst_size (void)\n {\n   extern struct { char n, a[]; }\n-    caxcc;                              // { dg-message \"at offset \\[1-9\\]\\[0-9\\]+ into destination object 'caxcc'\" }\n+    caxcc;                              // { dg-message \"at offset \\[1-9\\]\\[0-9\\]+ into destination object 'caxcc'\" \"note\" }\n \n   char *p = caxcc.a;\n   size_t idx = DIFF_MAX - 4;\n@@ -38,7 +38,7 @@ void char_flexarray_cst_off_cst_size (void)\n void char_flexarray_var_off_cst_size (ptrdiff_t idx)\n {\n   extern struct { char n, a[]; }\n-    caxvc;                              // { dg-message \"destination object 'caxvc'\" }\n+    caxvc;                              // { dg-message \"destination object 'caxvc'\" \"note\" }\n \n   char *p = caxvc.a;\n \n@@ -55,7 +55,7 @@ void char_flexarray_var_off_cst_size (ptrdiff_t idx)\n void char_flexarray_var_off_var_size (size_t n, ptrdiff_t idx)\n {\n   extern struct { char n, a[]; }\n-    caxvv;                              // { dg-message \"destination object 'caxvv'\" }\n+    caxvv;                              // { dg-message \"destination object 'caxvv'\" \"note\" }\n \n   char *p = caxvv.a;\n \n@@ -76,7 +76,7 @@ void char_flexarray_var_off_var_size (size_t n, ptrdiff_t idx)\n void alloc_array_var_off_cst_size (size_t n, ptrdiff_t idx)\n {\n   struct { char n, a[]; }\n-    *p = __builtin_malloc (n);          // { dg-message \"at offset \\\\d+ into destination object\" }\n+    *p = __builtin_malloc (n);          // { dg-message \"at offset \\\\d+ into destination object\" \"note\" }\n \n   if (idx < DIFF_MAX - 4)\n     idx = DIFF_MAX - 4;\n@@ -91,7 +91,7 @@ void alloc_array_var_off_cst_size (size_t n, ptrdiff_t idx)\n void int_array_cst_off_cst_size (void)\n {\n   extern struct { int n, a[]; }\n-    iaxc;                               // { dg-message \"at offset \\[1-9\\]\\[0-9\\]+ into destination object 'iaxc'\" }\n+    iaxc;                               // { dg-message \"at offset \\[1-9\\]\\[0-9\\]+ into destination object 'iaxc'\" \"note\" }\n \n   int *p = iaxc.a;\n   size_t idx = DIFF_MAX / sizeof *p - 1;"}, {"sha": "b81186cfb942a6dbbdbf733d5bbf2b4a5995bcc9", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-58.c", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-58.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-58.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-58.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -0,0 +1,260 @@\n+/* PR middle-end/92936 - missing warning on a past-the-end store to a PHI\n+   Exercise warnings for writing into one of two or more declared objects.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds -ftrack-macro-expansion=0\" } */\n+\n+#include \"range.h\"\n+\n+#define INT_MAX __INT_MAX__\n+\n+extern void* memset (void*, int, size_t);\n+#define memset(d, c, n) sink (memset (d, c, n))\n+\n+void sink (int, ...);\n+#define sink(...) sink (0, __VA_ARGS__)\n+\n+volatile int cond1, cond2;\n+\n+extern char ca0[0], ca1[1], ca2[2], ca3[3], ca4[4],\n+            ca5[5], ca6[6], ca7[7], ca8[8], ca9[9], cax[];\n+\n+#define CHOOSE_DECL_2(n1, n2)\t\t\t\\\n+  (cond1 ? ca ## n1 : ca ## n2)\n+#define CHOOSE_DECL_3(n1, n2, n3)\t\t\t\\\n+  (cond1 < 0 ? ca ## n1 : 0 < cond1 ? ca ## n2 : ca ## n3)\n+\n+\n+void memset_decl_2 (void)\n+{\n+  {\n+    char *p0_1 = CHOOSE_DECL_2 (0, 1);\n+\n+    memset (p0_1, 0, 0);\n+    /* Writing more than the smallest destination should trigger a \"may\n+       write\" warning if the access is unconditionally reachable from\n+       the block where the pointer to either object is assigned.  */\n+    memset (p0_1, 0, 1);\n+    memset (p0_1, 0, 2);      // { dg-warning \"memset' writing 2 bytes into a region of size 1 \" }\n+    memset (p0_1, 0, 9);      // { dg-warning \"memset' writing 9 bytes into a region of size 1 \" }\n+  }\n+\n+  {\n+    char *p0_x = CHOOSE_DECL_2 (0, x);\n+\n+    memset (p0_x, 0, 0);\n+    memset (p0_x, 0, 1);\n+    memset (p0_x, 0, 2);\n+    memset (p0_x, 0, 9);\n+  }\n+\n+  {\n+    char *p3_5 = CHOOSE_DECL_2 (3, 5);\n+\n+    memset (p3_5, 0, 1);\n+    memset (p3_5, 0, 3);\n+    memset (p3_5, 0, 4);\n+    memset (p3_5, 0, 5);\n+    memset (p3_5, 0, 6);      // { dg-warning \"memset' writing 6 bytes into a region of size 5 \" }\n+  }\n+\n+  {\n+    char *p5_3 = CHOOSE_DECL_2 (5, 3);\n+\n+    memset (p5_3, 0, 3);\n+    memset (p5_3, 0, 4);\n+    memset (p5_3, 0, 5);\n+    memset (p5_3, 0, 6);      // { dg-warning \"memset' writing 6 bytes into a region of size 5 \" }\n+  }\n+\n+  {\n+    char *px_3 = CHOOSE_DECL_2 (x, 3);\n+\n+    memset (px_3, 0, 1);\n+    memset (px_3, 0, 3);\n+    memset (px_3, 0, 4);\n+    memset (px_3, 0, 1234);\n+  }\n+\n+  {\n+    char *p5_x = CHOOSE_DECL_2 (5, x);\n+\n+    memset (p5_x, 0, 1);\n+    memset (p5_x, 0, 5);\n+    memset (p5_x, 0, 6);\n+    memset (p5_x, 0, 1234);\n+  }\n+\n+}\n+\n+\n+void memset_decl_3 (void)\n+{\n+  {\n+    char *p0_1_2 = CHOOSE_DECL_3 (0, 1, 2);\n+    memset (p0_1_2, 0, 0);\n+    memset (p0_1_2, 0, 1);\n+    memset (p0_1_2, 0, 2);\n+    memset (p0_1_2, 0, 3);    // { dg-warning \"memset' writing 3 bytes into a region of size 2 \" }\n+    memset (p0_1_2, 0, 9);    // { dg-warning \"memset' writing 9 bytes into a region of size 2 \" }\n+  }\n+\n+  {\n+    char *p0_2_x = CHOOSE_DECL_3 (0, 2, x);\n+\n+    memset (p0_2_x, 0, 0);\n+    memset (p0_2_x, 0, 1);\n+    memset (p0_2_x, 0, 3);\n+    memset (p0_2_x, 0, 9);\n+  }\n+\n+  {\n+    char *p3_4_5 = CHOOSE_DECL_3 (3, 4, 5);\n+\n+    memset (p3_4_5, 0, 3);\n+    memset (p3_4_5, 0, 4);\n+    memset (p3_4_5, 0, 5);\n+    memset (p3_4_5, 0, 6);    // { dg-warning \"memset' writing 6 bytes into a region of size 5 \" }\n+  }\n+\n+  {\n+    char *p5_3_4 = CHOOSE_DECL_3 (5, 3, 4);\n+\n+    memset (p5_3_4, 0, 3);\n+    memset (p5_3_4, 0, 4);\n+    memset (p5_3_4, 0, 5);\n+    memset (p5_3_4, 0, 6);    // { dg-warning \"memset' writing 6 bytes into a region of size 5 \" }\n+  }\n+\n+  {\n+    char *p9_8_7 = CHOOSE_DECL_3 (9, 8, 7);\n+\n+    memset (p9_8_7, 0, 7);\n+    memset (p9_8_7, 0, 8);\n+    memset (p9_8_7, 0, 9);\n+    memset (p9_8_7, 0, 10);   // { dg-warning \"memset' writing 10 bytes into a region of size 9 \" }\n+  }\n+}\n+\n+\n+/* Verify conditionally writing into one of two objects with the same\n+   size.  */\n+\n+void memset_decl_2_same_size (int i)\n+{\n+  {\n+    char a4_1[4], a4_2[4];\n+    char *p4 = cond1 ? a4_1 : a4_2;\n+\n+    memset (p4, 0, 1);\n+    memset (p4, 0, 2);\n+    memset (p4, 0, 3);\n+    memset (p4, 0, 4);\n+    memset (p4, 0, 5);        // { dg-warning \"memset' writing 5 bytes into a region of size 4\" }\n+  }\n+\n+  {\n+    char a4_1[4];             // { dg-message \"destination object 'a4_1\" \"note\" }\n+    char a4_2[4];             // { dg-message \"destination object 'a4_2\" \"note\" }\n+    char *p4 = cond1 ? a4_1 : a4_2;\n+    char *p4_i = p4 + i;\n+\n+    memset (p4_i, 0, 5);      // { dg-warning \"memset' writing 5 bytes into a region of size 4\" }\n+  }\n+\n+  {\n+    if (i < 1)\n+      i = 1;\n+\n+    char a4_1[4];             // { dg-message \"at offset \\\\\\[1, 4] into destination object 'a4_1\" \"note\" }\n+    char a4_2[4];             // { dg-message \"at offset \\\\\\[1, 4] into destination object 'a4_2\" \"note\" }\n+    char *p4 = cond1 ? a4_1 : a4_2;\n+    char *p4_i = p4 + i;\n+\n+    memset (p4_i, 0, 3);\n+    memset (p4_i, 0, 4);      // { dg-warning \"memset' writing 4 bytes into a region of size 3 \" }\n+  }\n+}\n+\n+\n+void memset_decl_2_off (void)\n+{\n+  int i1 = SR (1, INT_MAX);\n+  int i2 = SR (2, INT_MAX);\n+\n+  {\n+    char a5[5];               // { dg-warning \"at offset [1, 5] into destination object 'a5'\n+    char a7[7];               // { dg-warning \"at offset [2, 7] into destination object 'a7'\n+    char *p5_p1 = a5 + i1;\n+    char *p7_p2 = a7 + i2;\n+    char *p5_7 = cond1 ? p5_p1 : p7_p2;\n+\n+    memset (p5_7, 0, 1);\n+    memset (p5_7, 0, 2);\n+    memset (p5_7, 0, 3);\n+    memset (p5_7, 0, 4);\n+    memset (p5_7, 0, 5);\n+    memset (p5_7, 0, 6);      // { dg-warning \"memset' writing 6 bytes into a region of size 5 \" }\n+  }\n+\n+  int i3 = SR (3, INT_MAX);\n+\n+  {\n+    char a5[5];\n+    // { dg-message \"at offset \\\\\\[3, 5] into destination object 'a5'\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"at offset \\\\\\[2, 5] into destination object 'a5'\" \"note\" { target *-*-* } .-2 }\n+    // { dg-message \"at offset \\\\\\[1, 5] into destination object 'a5'\" \"note\" { target *-*-* } .-3 }\n+    // { dg-message \": destination object 'a5'\" \"note\" { target *-*-* } .-4 }\n+    char a9[9];\n+    // { dg-message \"at offset \\\\\\[4, 9] into destination object 'a9'\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"at offset \\\\\\[3, 9] into destination object 'a9'\" \"note\" { target *-*-* } .-2 }\n+    // { dg-message \"at offset \\\\\\[2, 9] into destination object 'a9'\" \"note\" { target *-*-* } .-3 }\n+    // { dg-message \": destination object 'a9'\" \"note\" { target *-*-* } .-4 }\n+    char *p5_p2 = a5 + i2;    // 3 bytes left\n+    char *p9_p3 = a9 + i3;    // 6 bytes left\n+    char *p =\n+      cond1 ? p5_p2 : p9_p3;  // [3 - 6] bytes left\n+    char *q = p + i1;         // [2 - 5] bytes left\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 3);\n+    memset (q, 0, 4);\n+    memset (q, 0, 5);\n+    memset (q, 0, 6);         // { dg-warning \"memset' writing 6 bytes into a region of size 5\" }\n+\n+    --q;                      // [3 - 6] bytes left\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 3);\n+    memset (q, 0, 4);\n+    memset (q, 0, 5);\n+    memset (q, 0, 6);\n+    memset (q, 0, 7);         // { dg-warning \"memset' writing 7 bytes into a region of size 6\" }\n+\n+    --q;                      // [4 - 7] bytes left\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 3);\n+    memset (q, 0, 4);\n+    memset (q, 0, 5);\n+    memset (q, 0, 6);\n+    memset (q, 0, 7);\n+    memset (q, 0, 8);         // { dg-warning \"memset' writing 8 bytes into a region of size 7\" }\n+\n+    int m1_x = SR (-1, INT_MAX);\n+    int m2_x = SR (-2, INT_MAX);\n+\n+    q += cond2 ? m1_x : m2_x;   // [5 - 9] bytes left\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 3);\n+    memset (q, 0, 4);\n+    memset (q, 0, 5);\n+    memset (q, 0, 6);\n+    memset (q, 0, 7);\n+    memset (q, 0, 8);\n+    memset (q, 0, 9);\n+    memset (q, 0, 10);        // { dg-warning \"memset' writing 10 bytes into a region of size 9\" }\n+  }\n+}"}, {"sha": "c45a92d21e186f0eaa77aa41e45c93b1741696eb", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-59.c", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-59.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-59.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-59.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -0,0 +1,267 @@\n+/* PR middle-end/92936 - missing warning on a past-the-end store to a PHI\n+   Exercise warnings for writing into one of two or more allocated objects.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds -ftrack-macro-expansion=0\" } */\n+\n+#include \"range.h\"\n+\n+#define INT_MAX __INT_MAX__\n+\n+extern void* malloc (size_t);\n+extern void* memset (void*, int, size_t);\n+#define memset(d, c, n) sink (memset (d, c, n))\n+\n+void sink (int, ...);\n+#define sink(...) sink (0, __VA_ARGS__)\n+\n+volatile int cond1, cond2, x;\n+\n+#define CHOOSE_MALLOC_2(n1, n2)\t\t\t\\\n+  (cond1 ? malloc (n1) : malloc (n2))\n+#define CHOOSE_MALLOC_3(n1, n2, n3)\t\t\t\t\t\\\n+  (cond1 < 0 ? malloc (n1) : 0 < cond1 ? malloc (n2) : malloc (n3))\n+\n+\n+void memset_malloc_2 (void)\n+{\n+  {\n+    char *p0_1 = CHOOSE_MALLOC_2 (0, 1);\n+\n+    memset (p0_1, 0, 0);\n+    /* Writing more than the smallest destination should trigger a \"may\n+       write\" warning if the access is unconditionally reachable from\n+       the block where the pointer to either object is assigned.  */\n+    memset (p0_1, 0, 1);\n+    memset (p0_1, 0, 2);      // { dg-warning \"memset' writing 2 bytes into a region of size 1 \" }\n+    memset (p0_1, 0, 9);      // { dg-warning \"memset' writing 9 bytes into a region of size 1 \" }\n+  }\n+\n+  {\n+    char *p0_x = CHOOSE_MALLOC_2 (0, x);\n+\n+    memset (p0_x, 0, 0);\n+    memset (p0_x, 0, 1);\n+    memset (p0_x, 0, 2);\n+    memset (p0_x, 0, 12345);\n+  }\n+\n+  {\n+    char *px_x = CHOOSE_MALLOC_2 (x, x);\n+\n+    memset (px_x, 0, 0);\n+    memset (px_x, 0, 1);\n+    memset (px_x, 0, 2);\n+    memset (px_x, 0, 12345);\n+  }\n+\n+  {\n+    char *p3_5 = CHOOSE_MALLOC_2 (3, 5);\n+\n+    memset (p3_5, 0, 1);\n+    memset (p3_5, 0, 3);\n+    memset (p3_5, 0, 4);\n+    memset (p3_5, 0, 5);\n+    memset (p3_5, 0, 6);      // { dg-warning \"memset' writing 6 bytes into a region of size 5 \" }\n+  }\n+\n+  {\n+    char *p5_3 = CHOOSE_MALLOC_2 (5, 3);\n+\n+    memset (p5_3, 0, 3);\n+    memset (p5_3, 0, 4);\n+    memset (p5_3, 0, 5);\n+    memset (p5_3, 0, 6);      // { dg-warning \"memset' writing 6 bytes into a region of size 5 \" }\n+  }\n+\n+  {\n+    char *px_3 = CHOOSE_MALLOC_2 (x, 3);\n+\n+    memset (px_3, 0, 1);\n+    memset (px_3, 0, 3);\n+    memset (px_3, 0, 4);\n+    memset (px_3, 0, 1234);\n+  }\n+\n+  {\n+    char *p5_x = CHOOSE_MALLOC_2 (5, x);\n+\n+    memset (p5_x, 0, 1);\n+    memset (p5_x, 0, 5);\n+    memset (p5_x, 0, 6);\n+    memset (p5_x, 0, 1234);\n+  }\n+\n+}\n+\n+\n+void memset_malloc_3 (void)\n+{\n+  {\n+    char *p0_1_2 = CHOOSE_MALLOC_3 (0, 1, 2);\n+    memset (p0_1_2, 0, 0);\n+    memset (p0_1_2, 0, 1);\n+    memset (p0_1_2, 0, 2);\n+    memset (p0_1_2, 0, 3);    // { dg-warning \"memset' writing 3 bytes into a region of size 2 \" }\n+    memset (p0_1_2, 0, 9);    // { dg-warning \"memset' writing 9 bytes into a region of size 2 \" }\n+  }\n+\n+  {\n+    char *p0_2_x = CHOOSE_MALLOC_3 (0, 2, x);\n+\n+    memset (p0_2_x, 0, 0);\n+    memset (p0_2_x, 0, 1);\n+    memset (p0_2_x, 0, 3);\n+    memset (p0_2_x, 0, 9);\n+  }\n+\n+  {\n+    char *p3_4_5 = CHOOSE_MALLOC_3 (3, 4, 5);\n+\n+    memset (p3_4_5, 0, 3);\n+    memset (p3_4_5, 0, 4);\n+    memset (p3_4_5, 0, 5);\n+    memset (p3_4_5, 0, 6);    // { dg-warning \"memset' writing 6 bytes into a region of size 5 \" }\n+  }\n+\n+  {\n+    char *p5_3_4 = CHOOSE_MALLOC_3 (5, 3, 4);\n+\n+    memset (p5_3_4, 0, 3);\n+    memset (p5_3_4, 0, 4);\n+    memset (p5_3_4, 0, 5);\n+    memset (p5_3_4, 0, 6);    // { dg-warning \"memset' writing 6 bytes into a region of size 5 \" }\n+  }\n+\n+  {\n+    char *p9_8_7 = CHOOSE_MALLOC_3 (9, 8, 7);\n+\n+    memset (p9_8_7, 0, 7);\n+    memset (p9_8_7, 0, 8);\n+    memset (p9_8_7, 0, 9);\n+    memset (p9_8_7, 0, 10);   // { dg-warning \"memset' writing 10 bytes into a region of size 9 \" }\n+  }\n+}\n+\n+\n+/* Verify conditionally writing into one of two objects with the same\n+   size.  */\n+\n+void memset_malloc_2_same_size (int i)\n+{\n+  {\n+    char a4_1[4], a4_2[4];\n+    char *p4 = cond1 ? a4_1 : a4_2;\n+\n+    memset (p4, 0, 1);\n+    memset (p4, 0, 2);\n+    memset (p4, 0, 3);\n+    memset (p4, 0, 4);\n+    memset (p4, 0, 5);        // { dg-warning \"memset' writing 5 bytes into a region of size 4\" }\n+  }\n+\n+  {\n+    char a4_1[4];             // { dg-message \"destination object 'a4_1\" \"note\" }\n+    char a4_2[4];             // { dg-message \"destination object 'a4_2\" \"note\" }\n+    char *p4 = cond1 ? a4_1 : a4_2;\n+    char *p4_i = p4 + i;\n+\n+    memset (p4_i, 0, 5);      // { dg-warning \"memset' writing 5 bytes into a region of size 4\" }\n+  }\n+\n+  {\n+    if (i < 1)\n+      i = 1;\n+\n+    char a4_1[4];             // { dg-message \"at offset \\\\\\[1, 4] into destination object 'a4_1\" \"note\" }\n+    char a4_2[4];             // { dg-message \"at offset \\\\\\[1, 4] into destination object 'a4_2\" \"note\" }\n+    char *p4 = cond1 ? a4_1 : a4_2;\n+    char *p4_i = p4 + i;\n+\n+    memset (p4_i, 0, 3);\n+    memset (p4_i, 0, 4);      // { dg-warning \"memset' writing 4 bytes into a region of size 3 \" }\n+  }\n+}\n+\n+\n+void memset_malloc_2_off (void)\n+{\n+  int i1 = SR (1, INT_MAX);\n+  int i2 = SR (2, INT_MAX);\n+\n+  {\n+    char a5[5];               // { dg-warning \"at offset [1, 5] into destination object 'a5'\n+    char a7[7];               // { dg-warning \"at offset [2, 7] into destination object 'a7'\n+    char *p5_p1 = a5 + i1;\n+    char *p7_p2 = a7 + i2;\n+    char *p5_7 = cond1 ? p5_p1 : p7_p2;\n+\n+    memset (p5_7, 0, 1);\n+    memset (p5_7, 0, 2);\n+    memset (p5_7, 0, 3);\n+    memset (p5_7, 0, 4);\n+    memset (p5_7, 0, 5);\n+    memset (p5_7, 0, 6);      // { dg-warning \"memset' writing 6 bytes into a region of size 5 \" }\n+  }\n+\n+  int i3 = SR (3, INT_MAX);\n+\n+  {\n+    char a5[5];\n+    // { dg-message \"at offset \\\\\\[3, 5] into destination object 'a5'\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"at offset \\\\\\[2, 5] into destination object 'a5'\" \"note\" { target *-*-* } .-2 }\n+    // { dg-message \"at offset \\\\\\[1, 5] into destination object 'a5'\" \"note\" { target *-*-* } .-3 }\n+    // { dg-message \": destination object 'a5'\" \"note\" { target *-*-* } .-4 }\n+    char a9[9];\n+    // { dg-message \"at offset \\\\\\[4, 9] into destination object 'a9'\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"at offset \\\\\\[3, 9] into destination object 'a9'\" \"note\" { target *-*-* } .-2 }\n+    // { dg-message \"at offset \\\\\\[2, 9] into destination object 'a9'\" \"note\" { target *-*-* } .-3 }\n+    // { dg-message \": destination object 'a9'\" \"note\" { target *-*-* } .-4 }\n+    char *p5_p2 = a5 + i2;    // 3 bytes left\n+    char *p9_p3 = a9 + i3;    // 6 bytes left\n+    char *p =\n+      cond1 ? p5_p2 : p9_p3;  // [3 - 6] bytes left\n+    char *q = p + i1;         // [2 - 5] bytes left\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 3);\n+    memset (q, 0, 4);\n+    memset (q, 0, 5);\n+    memset (q, 0, 6);         // { dg-warning \"memset' writing 6 bytes into a region of size 5\" }\n+\n+    --q;                      // [3 - 6] bytes left\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 3);\n+    memset (q, 0, 4);\n+    memset (q, 0, 5);\n+    memset (q, 0, 6);\n+    memset (q, 0, 7);         // { dg-warning \"memset' writing 7 bytes into a region of size 6\" }\n+\n+    --q;                      // [4 - 7] bytes left\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 3);\n+    memset (q, 0, 4);\n+    memset (q, 0, 5);\n+    memset (q, 0, 6);\n+    memset (q, 0, 7);\n+    memset (q, 0, 8);         // { dg-warning \"memset' writing 8 bytes into a region of size 7\" }\n+\n+    int m1_x = SR (-1, INT_MAX);\n+    int m2_x = SR (-2, INT_MAX);\n+\n+    q += cond2 ? m1_x : m2_x;   // [5 - 9] bytes left\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 3);\n+    memset (q, 0, 4);\n+    memset (q, 0, 5);\n+    memset (q, 0, 6);\n+    memset (q, 0, 7);\n+    memset (q, 0, 8);\n+    memset (q, 0, 9);\n+    memset (q, 0, 10);        // { dg-warning \"memset' writing 10 bytes into a region of size 9\" }\n+  }\n+}"}, {"sha": "8c9de20e9bc6ac4418a377780bc9c8cea59b0f6c", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-60.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-60.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-60.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-60.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -0,0 +1,72 @@\n+/* Test derived from Glibc's getifaddrs_internal.   The code could be\n+   rewritten to avoid the warning for the memcpy call but since unions\n+   are designed to have their members treated as interchangeable there\n+   isn't a whole lot to be gained from issuing one.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void* memcpy (void*, const void*, size_t);\n+\n+struct sockaddr\n+{\n+  short sa_family;\n+  char sa_data[14];\n+};\n+\n+struct in_addr\n+{\n+  int s_addr;\n+};\n+\n+struct in6_addr\n+{\n+  union\n+  {\n+    char __u6_addr8[16];\n+    short __u6_addr16[8];\n+    int __u6_addr32[4];\n+  } __in6_u;\n+};\n+\n+struct sockaddr_in\n+{\n+  short sin_family;\n+  short sin_port;\n+  struct in_addr sin_addr;\n+  unsigned char sin_zero[sizeof (struct sockaddr) -\n+\t\t\t (sizeof (short)) -\n+\t\t\t sizeof (short) -\n+\t\t\t sizeof (struct in_addr)];\n+};\n+\n+struct sockaddr_in6\n+{\n+  short sin6_family;\n+  short sin6_port;\n+  int sin6_flowinfo;\n+  struct in6_addr sin6_addr;\n+  int sin6_scope_id;\n+};\n+\n+union\n+{\n+  struct sockaddr sa;\n+  struct sockaddr_in s4;\n+  struct sockaddr_in6 s6;\n+} u1, u2;\n+\n+struct sockaddr *sa;\n+\n+void test_unconditional (void *p)\n+{\n+  sa = &u1.sa;\n+  memcpy (&((struct sockaddr_in6 *) sa)->sin6_addr, p, 16);\n+}\n+\n+void test_conditional (void *p, int i)\n+{\n+  sa = i ? &u1.sa : &u2.sa;\n+  memcpy (&((struct sockaddr_in6 *) sa)->sin6_addr, p, 16);\n+}"}, {"sha": "7601679fac3d63100ec9f3f52518552d251c3c9a", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-61.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-61.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-61.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-61.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -0,0 +1,88 @@\n+/* { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void* malloc (size_t);\n+void* memcpy (void*, const void*, size_t);\n+size_t strlen (const char *);\n+\n+// Test case reduced from gcc/attribs.c.\n+\n+char* sorted_attr_string (char *argv[])\n+{\n+  size_t n = 0;\n+  unsigned int i;\n+\n+  for (i = 0; argv[i]; ++i)\n+    n += strlen (argv[i]);\n+\n+  char *s = (char*)malloc (n);\n+  n = 0;\n+  for (i = 0; argv[i]; ++i)\n+    {\n+      const char *str = argv[i];\n+      size_t len = strlen (str);\n+      memcpy (s + n, str, len);\n+      n += len + 1;\n+    }\n+\n+  /* Replace \"=,-\" with \"_\".  */\n+  for (i = 0; i < strlen (s); i++)\n+    if (s[i] == '=')\n+      s[i] = '_';             // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n+\n+  return s;\n+}\n+\n+\n+void f (void*);\n+\n+void nowarn_cond_escape (int c, int *x)\n+{\n+  extern char a3[3], a5[5];\n+\n+  char *p;\n+  if (c)\n+    {\n+      p = a3;\n+      *x = 2;\n+   }\n+   else\n+     {\n+       p = a5;\n+       *x = 4;\n+     }\n+\n+  f (p);   // may modify *x\n+\n+  if (*x == 2)\n+    p[2] = 0;\n+  else if (*x == 4)\n+    p[4] = 0;                 // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+void warn_cond_escape (int c, int *x)\n+{\n+  extern char a3_2[3];\n+  extern char a5_2[5];        // { dg-message \"at offset 5 into destination object 'a5_2'\" }\n+\n+  char *p;\n+  if (c)\n+    {\n+      p = a3_2;\n+      *x = 2;\n+   }\n+   else\n+     {\n+       p = a5_2;\n+       *x = 5;\n+     }\n+\n+  f (p);   // may modify *x\n+\n+  if (*x == 2)\n+    p[2] = 0;\n+  else if (*x == 5)\n+    p[5] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}"}, {"sha": "318d9bd1f94a43840c09e01d49457fc3e2f7b3e6", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-62.c", "status": "added", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-62.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-62.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-62.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -0,0 +1,363 @@\n+/* Test for MIN and MAX expressions involving pointers.\n+  { dg-do compile }\n+  { dg-options \"-O2 -Wall -Wno-array-bounds -ftrack-macro-expansion=0\" } */\n+\n+#include \"range.h\"\n+\n+#define INT_MAX __INT_MAX__\n+\n+#define MIN(x, y) ((x) < (y) ? (x) :  (y))\n+#define MAX(x, y) ((x) < (y) ? (y) :  (x))\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void* memset (void*, int, size_t);\n+#define memset(...) sink (memset (__VA_ARGS__))\n+\n+void sink (void*, ...);\n+\n+volatile int cond, vi;\n+char* volatile ptr;\n+\n+void test_min (void)\n+{\n+  const int i1 = SR (1, INT_MAX);\n+  const int i2 = SR (2, INT_MAX);\n+\n+  {\n+    /* Exercise both pointers pointing to a different unknown object plus\n+       positive constant offset.  Since PTR is volatile P1 and P2 cannot\n+       normally be considered to point to the same object.  It can only\n+       be inferred from the MIN expression.  */\n+    char *p1 = ptr + 1;\n+    char *p2 = ptr + 2;\n+\n+    char *q = MIN (p1, p2);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, INT_MAX);\n+    // { dg-warning \"writing 2147483647 bytes into a region of size 2147483646\" \"ilp32\" { target ilp32 } .-1 }\n+    memset (q, 0, DIFF_MAX - 2);\n+    memset (q, 0, DIFF_MAX);\n+    // { dg-warning \"writing 2147483647 bytes into a region of size 2147483646\" \"ilp32\" { target ilp32 } .-1 }\n+    // { dg-warning \"writing 9223372036854775807 bytes into a region of size 9223372036854775806\" \"lp64\" { target lp64 } .-2 }\n+  }\n+\n+  {\n+    /* Exercise both pointers pointing to a different unknown object plus\n+       variable offset.  */\n+    char *p1 = ptr + vi;\n+    char *p2 = ptr + vi;\n+\n+    char *q = MIN (p1, p2);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, INT_MAX);\n+  }\n+\n+  {\n+    /* Exercise both pointers pointing to the same object plus constant\n+       offset.  */\n+    char a2[2];               // { dg-message \"at offset 1 into destination object 'a2' of size 2\" \"note\" }\n+    char *p1 = a2 + 1;\n+    char *p2 = a2 + 2;\n+\n+    char *q = MIN (p1, p2);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);         // { dg-warning \"writing 2 bytes into a region of size 1 \" }\n+  }\n+\n+  {\n+    /* Exercise both pointers pointing to the same object plus offset\n+       in a known range.  */\n+    char a3[3];               // { dg-message \"at offset \\\\\\[1, 3] into destination object 'a3'\" \"note\" }\n+    char *pi = a3 + i1;\n+    char *pj = a3 + i2;\n+\n+    char *q = MIN (pi, pj);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 3);         // { dg-warning \"writing 3 bytes into a region of size 2 \" }\n+  }\n+\n+  {\n+    /* Exercise both pointers pointing to the same object plus variable\n+       offset.  Verify that no offset is mentioned in the note (since\n+       its unknown, printing its full range is unnecessary).  */\n+    char a4[4];               // { dg-message \": destination object 'a4'\" \"note\" }\n+    char *pi = a4 + vi;\n+    char *pj = a4 + vi;\n+\n+    char *q = MIN (pi, pj);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 3);\n+    memset (q, 0, 4);\n+    memset (q, 0, 5);         // { dg-warning \"writing 5 bytes into a region of size 4 \" }\n+  }\n+\n+  {\n+    /* Exercise a pointer pointing to a known object with one pointing\n+       to an unknown object.  */\n+    char a5[5];               // { dg-message \": destination object 'a5'\" \"note\" }\n+    char *p = ptr;\n+    char *q = MIN (p, a5);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 5);\n+    memset (q, 0, 6);         // { dg-warning \"writing 6 bytes into a region of size 5 \" }\n+  }\n+\n+  {\n+    /* Exercise a pointer pointing to a known object plus constant offset\n+       with one pointing to an unknown object.  */\n+    char a6[6];               // { dg-message \": destination object 'a6'\" \"note\" }\n+    char *p1 = ptr;\n+    char *p2 = a6 + 1;\n+    char *q = MIN (p1, p2);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 6);\n+    memset (q, 0, 7);         // { dg-warning \"writing 7 bytes into a region of size 6 \" }\n+  }\n+\n+  {\n+    /* Exercise a pointer pointing to a known object with one pointing\n+       to an unknown object plus constant offset.  */\n+    char a7[7];               // { dg-message \": destination object 'a7'\" \"note\" }\n+    char *p1 = a7;\n+    char *p2 = ptr + 1;\n+    /* Since p1 points to a7[0] it must be less than any pointer to a7\n+       plus positive offset, and so Q == P1.  */\n+    char *q = MIN (p1, p2);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 3);\n+    memset (q, 0, 7);\n+    memset (q, 0, 8);         // { dg-warning \"writing 8 bytes into a region of size 7 \" }\n+  }\n+\n+  {\n+    /* Exercise a pointer pointing to a known object plus constant offset\n+       with one pointing to an unknown object plus a different constant\n+       offset.  */\n+    char a8[8];               // { dg-message \"at offset 1 into destination object 'a8'\" \"note\" }\n+    char *p1 = a8 + 1;\n+    char *p2 = ptr + 2;\n+    /* Since P1 points to A8[1] it must be less than or equal to any\n+       pointer to A8 plus positive offset.  Either way, Q must point\n+       to A8[1].  */\n+    char *q = MIN (p1, p2);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 7);\n+    memset (q, 0, 8);         // { dg-warning \"writing 8 bytes into a region of size 7 \" }\n+  }\n+\n+  {\n+    /* Same as above but with larger offsets.  */\n+    char a9[9];               // { dg-message \"at offset 3 into destination object 'a9'\" \"note\" }\n+    char *p1 = a9 + 3;\n+    char *p2 = ptr + 4;\n+    /* Since P1 points to A9[3] it must be less than or equal to any\n+       pointer anywhere into A9 plus 4, so Q must point to A9[3].  */\n+    char *q = MIN (p1, p2);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 6);\n+    memset (q, 0, 7);         // { dg-warning \"writing 7 bytes into a region of size 6 \" }\n+  }\n+\n+  {\n+    /* Same as above but with the offsets reversed.  */\n+    char a10[10];              // { dg-message \"at offset 5 into destination object 'a10'\" \"note\" }\n+    char *p1 = a10 + 10;\n+    char *p2 = ptr + 5;\n+    /* Since P1 points just past the end of A10 it could be either less\n+       or equal to another pointer anywhere into A10 plus 3 because\n+       the other pointer itself could start at a non-zero offset that's\n+       not reflected in the determined offset).  */\n+    char *q = MIN (p1, p2);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 5);\n+    memset (q, 0, 6);         // { dg-warning \"writing 6 bytes into a region of size 5 \" }\n+  }\n+\n+  {\n+    char a3[3];               // { dg-message \": destination object 'a3'\" \"note\" }\n+    char *p1 = ptr;\n+    char *p2 = a3 + i1;\n+    char *q = MIN (p1, p2);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 3);\n+    memset (q, 0, 4);         // { dg-warning \"writing 4 bytes into a region of size 3 \" }\n+  }\n+}\n+\n+\n+void test_max (void)\n+{\n+  const int i1 = SR (1, INT_MAX);\n+  const int i2 = SR (2, INT_MAX);\n+\n+  {\n+    /* Exercise both pointers pointing to the same object plus constant\n+       offset.  */\n+    char a2[2];               // { dg-message \"at offset 1 into destination object 'a2' of size 2\" \"note\" }\n+    char *pi = a2 + 1;\n+    char *pj = a2 + 2;\n+\n+    char *q = MAX (pi, pj);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);         // { dg-warning \"writing 2 bytes into a region of size 1 \" }\n+  }\n+\n+  {\n+    /* Exercise both pointers pointing to the same object plus offset\n+       in a known range.  */\n+    char a3[3];               // { dg-message \"at offset \\\\\\[1, 3] into destination object 'a3'\" \"note\" }\n+    char *pi = a3 + i1;\n+    char *pj = a3 + i2;\n+\n+    char *q = MAX (pi, pj);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 3);         // { dg-warning \"writing 3 bytes into a region of size 2 \" }\n+  }\n+\n+  {\n+    /* Exercise both pointers pointing to the same object plus variable\n+       offset.  Verify that no offset is mentioned in the note (since\n+       its unknown, printing its full range is unnecessary).  */\n+    char a4[4];               // { dg-message \": destination object 'a4'\" \"note\" }\n+    char *pi = a4 + vi;\n+    char *pj = a4 + vi;\n+\n+    char *q = MAX (pi, pj);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 3);\n+    memset (q, 0, 4);\n+    memset (q, 0, 5);         // { dg-warning \"writing 5 bytes into a region of size 4 \" }\n+  }\n+\n+  {\n+    /* Exercise a pointer pointing to a known object with one pointing\n+       to an unknown object.  */\n+    char a5[5];               // { dg-message \": destination object 'a5'\" \"note\" }\n+    char *p = ptr;\n+    char *q = MAX (p, a5);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 5);\n+    memset (q, 0, 6);         // { dg-warning \"writing 6 bytes into a region of size 5 \" }\n+  }\n+\n+  {\n+    /* Exercise a pointer pointing to a known object plus constant offset\n+       with one pointing to an unknown object.  */\n+    char a6[6];               // { dg-message \"at offset 1 into destination object 'a6'\" \"note\" }\n+    char *p1 = ptr;\n+    char *p2 = a6 + 1;\n+    char *q = MAX (p1, p2);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 5);\n+    memset (q, 0, 6);         // { dg-warning \"writing 6 bytes into a region of size 5 \" }\n+    memset (q, 0, 7);         // { dg-warning \"writing 7 bytes into a region of size 5 \" }\n+  }\n+\n+  {\n+    /* Exercise a pointer pointing to a known object with one pointing\n+       to an unknown object plus constant offset.  */\n+    char a7[7];               // { dg-message \"at offset 1 into destination object 'a7'\" \"note\" }\n+    char *p1 = a7;\n+    char *p2 = ptr + 1;\n+    /* Since p1 points to a7[0] it must be less than any pointer to a7\n+       plus positive offset, and so Q == P2.  */\n+    char *q = MAX (p1, p2);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 6);\n+    memset (q, 0, 7);         // { dg-warning \"writing 7 bytes into a region of size 6 \" }\n+    memset (q, 0, 8);         // { dg-warning \"writing 8 bytes into a region of size 6 \" }\n+  }\n+\n+  {\n+    /* Exercise a pointer pointing to a known object plus constant offset\n+       with one pointing to an unknown object plus a different constant\n+       offset.  */\n+    char a8[8];               // { dg-message \"at offset 2 into destination object 'a8'\" \"note\" }\n+    char *p1 = a8 + 1;\n+    char *p2 = ptr + 2;\n+    /* Since P1 points to A8[1] it must be less than or equal to any\n+       pointer to A8 plus positive offset.  Either way, Q must point\n+       to A8[2].  */\n+    char *q = MAX (p1, p2);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 6);\n+    memset (q, 0, 7);         // { dg-warning \"writing 7 bytes into a region of size 6 \" }\n+    memset (q, 0, 8);         // { dg-warning \"writing 8 bytes into a region of size 6 \" }\n+  }\n+\n+  {\n+    /* Same as above but with larger offsets.  */\n+    char a9[9];               // { dg-message \"at offset 4 into destination object 'a9'\" \"note\" }\n+    char *p1 = a9 + 3;\n+    char *p2 = ptr + 4;\n+    /* Since P1 points to A9[3] it must be less than or equal to any\n+       pointer anywhere into A9 plus 4, so Q must point to A9[4].  */\n+    char *q = MAX (p1, p2);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 5);\n+    memset (q, 0, 6);         // { dg-warning \"writing 6 bytes into a region of size 5 \" }\n+  }\n+\n+  {\n+    /* Same as above but with the offsets reversed.  */\n+    char a10[10];              // { dg-message \"at offset 10 into destination object 'a10'\" \"note\" }\n+    char *p1 = a10 + 10;\n+    char *p2 = ptr + 5;\n+    /* Since P1 points just past the end of A10 it could be either less\n+       or equal to another pointer anywhere into A10 plus 3 because\n+       the other pointer itself could start at a non-zero offset that's\n+       not reflected in the determaxed offset).  */\n+    char *q = MAX (p1, p2);\n+\n+    memset (q, 0, 1);         // { dg-warning \"writing 1 byte into a region of size 0 \" }\n+  }\n+\n+  {\n+    char a11[11];             // { dg-message \"at offset \\\\\\[1, 11] into destination object 'a11'\" \"note\" }\n+    char *p1 = ptr;\n+    char *p2 = a11 + i1;\n+    char *q = MAX (p1, p2);\n+\n+    memset (q, 0, 1);\n+    memset (q, 0, 2);\n+    memset (q, 0, 10);\n+    memset (q, 0, 11);        // { dg-warning \"writing 11 bytes into a region of size 10 \" }\n+  }\n+}\n+"}, {"sha": "c98721dd8c771156b0b50f060e8e6de7048df91e", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-63.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-63.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-63.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-63.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -0,0 +1,33 @@\n+/* PR middle-end/92936 - missing warning on a past-the-end store to a PHI\n+   Test case derived from gcc/opts-common.c.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+char* f (const void*, ...);\n+\n+const char *\n+candidates_list_and_hint (const char *arg, char **str, const char *a[])\n+{\n+  size_t len = 0;\n+  int i;\n+\n+  for (i = 0; a[i]; ++i)\n+    len += __builtin_strlen (a[i]) + 1;\n+\n+  char *p = (char*)__builtin_malloc (len);\n+  *str = p;\n+\n+  for (i = 0; a[i]; ++i)\n+    {\n+      len = __builtin_strlen (a[i]);\n+      __builtin_memcpy (p, a[i], len);\n+      p[len] = ' ';\n+      p += len + 1;\n+    }\n+\n+  p[-1] = '\\0';     // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n+\n+  return f (arg, &a);\n+}"}, {"sha": "88b9d297525435014ba48d841c9766b8a3245309", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-64.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-64.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -0,0 +1,74 @@\n+/* PR middle-end/92936 - missing warning on a past-the-end store to a PHI\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void* malloc (size_t);\n+void* memset (void*, int, size_t);\n+\n+extern char a3[3], a5[5], a9[9];\n+\n+extern int cnd[];\n+\n+void* f2 (void)\n+{\n+  char *p0 = cnd[0] ? a3 : 0;\n+  char *p1 = cnd[1] ? a5 : p0;\n+\n+  return memset (p1, 0, 6);   // { dg-warning \"writing 6 bytes into a region of size 5\" }\n+}\n+\n+void* f3 (void)\n+{\n+  char *p0 = cnd[0] ? a3 : 0;\n+  char *p1 = cnd[1] ? a5 : 0;\n+  char *p2 = cnd[2] ? p0 : p1;\n+\n+  return memset (p2, 0, 6);   // { dg-warning \"writing 6 bytes into a region of size 5\" }\n+}\n+\n+void* f3_2 (void)\n+{\n+  char *p0 = cnd[0] ? a3 : 0;\n+  char *p1 = cnd[1] ? a5 : 0;\n+  char *p2 = cnd[2] ? p1 : p0;\n+\n+  return memset (p2, 0, 6);   // { dg-warning \"writing 6 bytes into a region of size 5\" }\n+}\n+\n+void* f3_3 (void)\n+{\n+  char *p0 = cnd[0] ? a5 : 0;\n+  char *p1 = cnd[1] ? p0 : a5;\n+  char *p2 = cnd[2] ? p1 : p0;\n+\n+  return memset (p2, 0, 6);   // { dg-warning \"writing 6 bytes into a region of size 5\" }\n+}\n+\n+void* f4 (void)\n+{\n+  char *p0 = cnd[0] ? a3 : 0;\n+  char *p1 = cnd[1] ? a5 : 0;\n+  char *p2 = cnd[2] ? p0 : 0;\n+  char *p3 = cnd[3] ? p1 : p2;\n+\n+  return memset (p3, 0, 6);   // { dg-warning \"writing 6 bytes into a region of size 5\" }\n+}\n+\n+void* f9 (void)\n+{\n+  char *p0 = cnd[0] ? a5 : 0;\n+  char *p1 = cnd[1] ? a5 + 1 : 0;\n+  char *p2 = cnd[2] ? a5 + 2 : 0;\n+  char *p3 = cnd[3] ? a5 + 3 : 0;\n+  char *p4 = cnd[4] ? a5 + 4 : 0;\n+\n+  char *p5 = cnd[5] ? p0 : p1;\n+  char *p6 = cnd[6] ? p5 : p2;\n+  char *p7 = cnd[7] ? p6 : p3;\n+  char *p8 = cnd[8] ? p7 : p4;\n+  char *p9 = cnd[9] ? p8 : p5;\n+\n+  return memset (p9, 0, 6);   // { dg-warning \"writing 6 bytes into a region of size 5\" }\n+}"}, {"sha": "cb2addf3af43942db6c29a5d0b4a1a4fc52ed79f", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-7.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-7.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -0,0 +1,124 @@\n+/* Test to verify that --param ssa_name_def_chain_limit can be used to\n+   limit the maximum number of SSA_NAME assignments the warning follows.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds --param ssa-name-def-chain-limit=5\" }  */\n+\n+#define NOIPA __attribute__ ((noipa))\n+\n+void* memset (void*, int, __SIZE_TYPE__);\n+\n+char a9[9];\n+\n+void sink (const char*, ...);\n+\n+NOIPA void g2 (int i)\n+{\n+  if (i < 1) i = 1;\n+\n+  char *p0 = a9;\n+  char *p1 = p0 + i;\n+  char *p2 = p1 + i;\n+\n+  sink (p0, p1, p2);\n+\n+  memset (p2, 0, 8);          // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+NOIPA void g3 (int i)\n+{\n+  if (i < 1) i = 1;\n+\n+  char *p0 = a9;\n+  char *p1 = p0 + i;\n+  char *p2 = p1 + i;\n+  char *p3 = p2 + i;\n+\n+  sink (p0, p1, p2, p3);\n+\n+  memset (p3, 0, 7);          // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+NOIPA void g4 (int i)\n+{\n+  if (i < 1) i = 1;\n+\n+  char *p0 = a9;\n+  char *p1 = p0 + i;\n+  char *p2 = p1 + i;\n+  char *p3 = p2 + i;\n+  char *p4 = p3 + i;\n+\n+  sink (p0, p1, p2, p3, p4);\n+\n+  memset (p4, 0, 6);          // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+NOIPA void g5 (int i)\n+{\n+  if (i < 1) i = 1;\n+\n+  char *p0 = a9;\n+  char *p1 = p0 + i;\n+  char *p2 = p1 + i;\n+  char *p3 = p2 + i;\n+  char *p4 = p3 + i;\n+  char *p5 = p4 + i;\n+\n+  sink (p0, p1, p2, p3, p4, p5);\n+\n+  memset (p5, 0, 5);          // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+NOIPA void g6 (int i)\n+{\n+  if (i < 1) i = 1;\n+\n+  char *p0 = a9;\n+  char *p1 = p0 + i;\n+  char *p2 = p1 + i;\n+  char *p3 = p2 + i;\n+  char *p4 = p3 + i;\n+  char *p5 = p4 + i;\n+  char *p6 = p5 + i;\n+\n+  sink (p0, p1, p2, p3, p4, p5, p6);\n+\n+  memset (p6, 0, 4);\n+}\n+\n+NOIPA void g7 (int i)\n+{\n+  if (i < 1) i = 1;\n+\n+  char *p0 = a9;\n+  char *p1 = p0 + i;\n+  char *p2 = p1 + i;\n+  char *p3 = p2 + i;\n+  char *p4 = p3 + i;\n+  char *p5 = p4 + i;\n+  char *p6 = p5 + i;\n+  char *p7 = p6 + i;\n+\n+  sink (p0, p1, p2, p3, p4, p5, p6, p7);\n+\n+  memset (p7, 0, 4);\n+}\n+\n+NOIPA void g8 (int i)\n+{\n+  if (i < 1) i = 1;\n+\n+  char *p0 = a9;\n+  char *p1 = p0 + i;\n+  char *p2 = p1 + i;\n+  char *p3 = p2 + i;\n+  char *p4 = p3 + i;\n+  char *p5 = p4 + i;\n+  char *p6 = p5 + i;\n+  char *p7 = p6 + i;\n+  char *p8 = p7 + i;\n+\n+  sink (p0, p1, p2, p3, p4, p5, p6, p7, p8);\n+\n+  memset (p8, 0, 2);\n+}"}, {"sha": "2afd2b5feeb351fa54ff8d67cc9c824ec4395297", "filename": "gcc/testsuite/gcc.dg/warn-strnlen-no-nul.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-strnlen-no-nul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-strnlen-no-nul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-strnlen-no-nul.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -143,11 +143,11 @@ T (v0 ? b[1] : \"\", bsz);\n T (v0 ? b[2] : \"\", bsz);\n T (v0 ? b[3] : \"\", bsz);\n \n-T (v0 ? \"\" : b[0], bsz + 1);\n+T (v0 ? \"\" : b[0], bsz + 1);      /* { dg-warning \"bound 6 may exceed source size 5\" } */\n T (v0 ? \"\" : b[1], bsz + 1);\n T (v0 ? \"\" : b[2], bsz + 1);\n T (v0 ? \"\" : b[3], bsz + 1);      /* { dg-warning \"unterminated\" \"pr86937\" { xfail *-*-* } } */\n-T (v0 ? b[0] : \"\", bsz + 1);\n+T (v0 ? b[0] : \"\", bsz + 1);      /* { dg-warning \"bound 6 may exceed source size 5\" } */\n T (v0 ? b[1] : \"\", bsz + 1);\n T (v0 ? b[2] : \"\", bsz + 1);\n T (v0 ? b[3] : \"\", bsz + 1);      /* { dg-warning \"unterminated\" \"pr86937\" { xfail *-*-* } } */\n@@ -185,8 +185,8 @@ T (v0 ? \"1234\" : b[i3], bsz + 1); /* { dg-warning \"unterminated\" \"pr86937\" { xfa\n T (v0 ? b[3] : \"1234\", bsz + 1);  /* { dg-warning \"unterminated\" \"pr86937\" { xfail *-*-* } } */\n T (v0 ? b[i3] : \"1234\", bsz + 1); /* { dg-warning \"unterminated\" \"pr86937\" { xfail *-*-* } } */\n \n-T (v0 ? a : b[3], bsz + 1);       /* { dg-warning \"unterminated\" \"pr86937\" { xfail *-*-* } } */\n-T (v0 ? b[0] : b[2], bsz + 1);\n+T (v0 ? a : b[3], bsz + 1);       /* { dg-warning \"bound 6 may exceed source size 5\" \"pr86937\" { xfail *-*-*} } */\n+T (v0 ? b[0] : b[2], bsz + 1);    /* { dg-warning \"bound 6 may exceed source size 5\" \"pr86937\" } */\n T (v0 ? b[2] : b[3], bsz + 1);    /* { dg-warning \"unterminated\" \"pr86937\" { xfail *-*-* } } */\n T (v0 ? b[3] : b[2], bsz + 1);    /* { dg-warning \"unterminated\" \"pr86937\" { xfail *-*-* } } */\n "}, {"sha": "7e5eab18e651abc3c695f5cc13d2f92431a490c0", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 20, "deletions": 323, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=eafe8ee7af13c39805ea09bbf5b4f9ab2a48304a", "patch": "@@ -1933,6 +1933,8 @@ maybe_warn_overflow (gimple *stmt, tree len,\n       dest = gimple_call_arg (stmt, 0);\n       writefn = gimple_call_fndecl (stmt);\n     }\n+  else\n+    return;\n \n   if (TREE_NO_WARNING (dest))\n     return;\n@@ -1941,148 +1943,22 @@ maybe_warn_overflow (gimple *stmt, tree len,\n      Make sure all operands have the same precision to keep wide_int\n      from ICE'ing.  */\n \n-  /* Convenience constants.  */\n-  const widest_int diff_min\n-    = wi::to_widest (TYPE_MIN_VALUE (ptrdiff_type_node));\n-  const widest_int diff_max\n-    = wi::to_widest (TYPE_MAX_VALUE (ptrdiff_type_node));\n-  const widest_int size_max\n-    = wi::to_widest (TYPE_MAX_VALUE (size_type_node));\n-\n-  /* The offset into the destination object computed below and not\n-     reflected in DESTSIZE.  */\n-  widest_int offrng[2] = { 0, 0 };\n-\n-  if (!si)\n-    {\n-      /* If no destination STRINFO was provided try to get it from\n-\t the DEST argument.  */\n-      tree ref = dest;\n-      if (TREE_CODE (ref) == ARRAY_REF)\n-\t{\n-\t  /* Handle stores to VLAs (represented as\n-\t     ARRAY_REF (MEM_REF (vlaptr, 0), N].  */\n-\t  tree off = TREE_OPERAND (ref, 1);\n-\t  ref = TREE_OPERAND (ref, 0);\n-\t  wide_int rng[2];\n-\t  if (get_range (off, stmt, rng, rvals))\n-\t    {\n-\t      /* Convert offsets to the maximum precision.  */\n-\t      offrng[0] = widest_int::from (rng[0], SIGNED);\n-\t      offrng[1] = widest_int::from (rng[1], SIGNED);\n-\t    }\n-\t  else\n-\t    {\n-\t      offrng[0] = diff_min;\n-\t      offrng[1] = diff_max;\n-\t    }\n-\t}\n-\n-      if (TREE_CODE (ref) == MEM_REF)\n-\t{\n-\t  tree mem_off = TREE_OPERAND (ref, 1);\n-\t  ref = TREE_OPERAND (ref, 0);\n-\t  wide_int rng[2];\n-\t  if (get_range (mem_off, stmt, rng, rvals))\n-\t    {\n-\t      offrng[0] += widest_int::from (rng[0], SIGNED);\n-\t      offrng[1] += widest_int::from (rng[1], SIGNED);\n-\t    }\n-\t  else\n-\t    {\n-\t      offrng[0] = diff_min;\n-\t      offrng[1] = diff_max;\n-\t    }\n-\t}\n-\n-      wide_int rng[2];\n-      if (int idx = get_stridx (ref, rng, rvals))\n-\t{\n-\t  si = get_strinfo (idx);\n-\t  offrng[0] += widest_int::from (rng[0], SIGNED);\n-\t  offrng[1] += widest_int::from (rng[1], SIGNED);\n-\t}\n-    }\n-\n-  /* The allocation call if the destination object was allocated\n-     by one.  */\n-  gimple *alloc_call = NULL;\n-  /* The DECL of the destination object if known and not dynamically\n-     allocated.  */\n-  tree destdecl = NULL_TREE;\n-  /* The offset into the destination object set by compute_objsize\n-     but already reflected in DESTSIZE.  */\n-  tree destoff = NULL_TREE;\n+  access_ref aref;\n   /* The size of the destination region (which is smaller than\n      the destination object for stores at a non-zero offset).  */\n-  tree destsize = NULL_TREE;\n-\n-  /* Compute the range of sizes of the destination object.  The range\n-     is constant for declared objects but may be a range for allocated\n-     objects.  */\n-  widest_int sizrng[2] = { 0, 0 };\n-  if (si)\n-    {\n-      wide_int rng[2];\n-      destsize = gimple_call_alloc_size (si->alloc, rng, rvals);\n-      if (destsize)\n-\t{\n-\t  sizrng[0] = widest_int::from (rng[0], UNSIGNED);\n-\t  sizrng[1] = widest_int::from (rng[1], UNSIGNED);\n-\t}\n-      alloc_call = si->alloc;\n-    }\n-  else\n-    offrng[0] = offrng[1] = 0;\n-\n+  tree destsize = compute_objsize (dest, rawmem ? 0 : 1, &aref, rvals);\n   if (!destsize)\n     {\n-      /* If there is no STRINFO for DEST, fall back on compute_objsize.  */\n-      tree off = NULL_TREE;\n-      destsize = compute_objsize (dest, rawmem ? 0 : 1, &destdecl, &off, rvals);\n-      if (destsize)\n-\t{\n-\t  /* Remember OFF but clear OFFRNG that may have been set above.  */\n-\t  destoff = off;\n-\t  offrng[0] = offrng[1] = 0;\n-\n-\t  if (destdecl && TREE_CODE (destdecl) == SSA_NAME)\n-\t    {\n-\t      gimple *stmt = SSA_NAME_DEF_STMT (destdecl);\n-\t      if (is_gimple_call (stmt))\n-\t\talloc_call = stmt;\n-\t      destdecl = NULL_TREE;\n-\t    }\n-\n-\t  wide_int rng[2];\n-\t  if (get_range (destsize, stmt, rng, rvals))\n-\t    {\n-\t      sizrng[0] = widest_int::from (rng[0], UNSIGNED);\n-\t      sizrng[1] = widest_int::from (rng[1], UNSIGNED);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* On failure, rather than failing, set the maximum range\n-\t\t so that overflow in allocated objects whose size depends\n-\t\t on the strlen of the source can still be diagnosed\n-\t\t below.  */\n-\t      sizrng[0] = 0;\n-\t      sizrng[1] = size_max;\n-\t    }\n-\t}\n+      aref.sizrng[0] = 0;\n+      aref.sizrng[1] = wi::to_offset (max_object_size ());\n     }\n \n-  if (!destsize)\n-    {\n-      sizrng[0] = 0;\n-      sizrng[1] = size_max;\n-    };\n-\n   /* Return early if the DESTSIZE size expression is the same as LEN\n      and the offset into the destination is zero.  This might happen\n      in the case of a pair of malloc and memset calls to allocate\n      an object and clear it as if by calloc.  */\n-  if (destsize == len && !plus_one && offrng[0] == 0 && offrng[0] == offrng[1])\n+  if (destsize == len && !plus_one\n+      && aref.offrng[0] == 0 && aref.offrng[0] == aref.offrng[1])\n     return;\n \n   wide_int rng[2];\n@@ -2100,38 +1976,13 @@ maybe_warn_overflow (gimple *stmt, tree len,\n \n   /* The size of the remaining space in the destination computed\n      as the size of the latter minus the offset into it.  */\n-  widest_int spcrng[2] = { sizrng[0], sizrng[1] };\n-  if (wi::neg_p (offrng[0]) && wi::neg_p (offrng[1]))\n-    {\n-      /* When the offset is negative and the size of the destination\n-\t object unknown there is little to do.\n-\t FIXME: Detect offsets that are necessarily invalid regardless\n-\t of the size of the object.  */\n-      if (!destsize)\n-\treturn;\n-\n-      /* The remaining space is necessarily zero.  */\n-      spcrng[0] = spcrng[1] = 0;\n-    }\n-  else if (wi::neg_p (offrng[0]))\n-    {\n-      /* When the lower bound of the offset is negative but the upper\n-\t bound is not, reduce the upper bound of the remaining space\n-\t by the upper bound of the offset but leave the lower bound\n-\t unchanged.  If that makes the upper bound of the space less\n-\t than the lower bound swap the two.  */\n-      spcrng[1] -= wi::ltu_p (offrng[1], spcrng[1]) ? offrng[1] : spcrng[1];\n-      if (wi::ltu_p (spcrng[1], spcrng[0]))\n-\tstd::swap (spcrng[1], spcrng[0]);\n-    }\n-  else\n-    {\n-      /* When the offset is positive reduce the remaining space by\n-\t the lower bound of the offset or clear it if the offset is\n-\t greater.  */\n-      spcrng[0] -= wi::ltu_p (offrng[0], spcrng[0]) ? offrng[0] : spcrng[0];\n-      spcrng[1] -= wi::ltu_p (offrng[0], spcrng[1]) ? offrng[0] : spcrng[1];\n-    }\n+  widest_int spcrng[2];\n+  {\n+    offset_int remrng[2];\n+    remrng[1] = aref.size_remaining (remrng);\n+    spcrng[0] = remrng[0] == -1 ? 0 : widest_int::from (remrng[0], UNSIGNED);\n+    spcrng[1] = widest_int::from (remrng[1], UNSIGNED);\n+  }\n \n   if (wi::leu_p (lenrng[0], spcrng[0])\n       && wi::leu_p (lenrng[1], spcrng[1]))\n@@ -2233,112 +2084,7 @@ maybe_warn_overflow (gimple *stmt, tree len,\n \n   gimple_set_no_warning (stmt, true);\n \n-  /* If DESTOFF is not null, use it to format the offset value/range.  */\n-  if (destoff)\n-    {\n-      wide_int rng[2];\n-      if (get_range (destoff, stmt, rng))\n-\t{\n-\t  offrng[0] = widest_int::from (rng[0], SIGNED);\n-\t  offrng[1] = widest_int::from (rng[1], SIGNED);\n-\t}\n-      else\n-\toffrng[0] = offrng[1] = 0;\n-    }\n-\n-  /* Format the offset to keep the number of inform calls from growing\n-     out of control.  */\n-  char offstr[64];\n-  if (offrng[0] == offrng[1])\n-    sprintf (offstr, \"%lli\", (long long) offrng[0].to_shwi ());\n-  else\n-    sprintf (offstr, \"[%lli, %lli]\",\n-\t     (long long) offrng[0].to_shwi (), (long long) offrng[1].to_shwi ());\n-\n-  if (destdecl && DECL_P (destdecl))\n-    {\n-      if (tree size = DECL_SIZE_UNIT (destdecl))\n-\tinform (DECL_SOURCE_LOCATION (destdecl),\n-\t\t\"at offset %s to object %qD with size %E declared here\",\n-\t\toffstr, destdecl, size);\n-      else\n-\tinform (DECL_SOURCE_LOCATION (destdecl),\n-\t\t\"at offset %s to object %qD declared here\",\n-\t\toffstr, destdecl);\n-      return;\n-    }\n-\n-  if (!alloc_call)\n-    return;\n-\n-  tree allocfn = gimple_call_fndecl (alloc_call);\n-  if (!allocfn)\n-    {\n-      /* For an ALLOC_CALL via a function pointer make a small effort\n-\t to determine the destination of the pointer.  */\n-      allocfn = gimple_call_fn (alloc_call);\n-      if (TREE_CODE (allocfn) == SSA_NAME)\n-\t{\n-\t  gimple *def = SSA_NAME_DEF_STMT (allocfn);\n-\t  if (gimple_assign_single_p (def))\n-\t    {\n-\t      tree rhs = gimple_assign_rhs1 (def);\n-\t      if (DECL_P (rhs))\n-\t\tallocfn = rhs;\n-\t      else if (TREE_CODE (rhs) == COMPONENT_REF)\n-\t\tallocfn = TREE_OPERAND (rhs, 1);\n-\t    }\n-\t}\n-    }\n-\n-  if (gimple_call_builtin_p (alloc_call, BUILT_IN_ALLOCA_WITH_ALIGN))\n-    {\n-      if (sizrng[0] == sizrng[1])\n-\tinform (gimple_location (alloc_call),\n-\t\t\"at offset %s to an object with size %wu declared here\",\n-\t\toffstr, sizrng[0].to_uhwi ());\n-      else if (sizrng[0] == 0)\n-\t{\n-\t  /* Avoid printing impossible sizes.  */\n-\t  if (wi::ltu_p (sizrng[1], diff_max - 2))\n-\t    inform (gimple_location (alloc_call),\n-\t\t    \"at offset %s to an object with size at most %wu \"\n-\t\t    \"declared here\",\n-\t\t    offstr, sizrng[1].to_uhwi ());\n-\t  else\n-\t    inform (gimple_location (alloc_call),\n-\t\t    \"at offset %s to an object declared here\", offstr);\n-\t}\n-      else\n-\tinform (gimple_location (alloc_call),\n-\t\t\"at offset %s to an object with size between %wu and %wu \"\n-\t\t\"declared here\",\n-\t\toffstr, sizrng[0].to_uhwi (), sizrng[1].to_uhwi ());\n-      return;\n-    }\n-\n-  if (sizrng[0] == sizrng[1])\n-    inform (gimple_location (alloc_call),\n-\t    \"at offset %s to an object with size %wu allocated by %qE here\",\n-\t    offstr, sizrng[0].to_uhwi (), allocfn);\n-  else if (sizrng[0] == 0)\n-    {\n-      /* Avoid printing impossible sizes.  */\n-      if (wi::ltu_p (sizrng[1], diff_max - 2))\n-\tinform (gimple_location (alloc_call),\n-\t\t\"at offset %s to an object with size at most %wu allocated \"\n-\t\t\"by %qD here\",\n-\t\toffstr, sizrng[1].to_uhwi (), allocfn);\n-      else\n-\tinform (gimple_location (alloc_call),\n-\t\t\"at offset %s to an object allocated by %qE here\",\n-\t\toffstr, allocfn);\n-    }\n-  else\n-    inform (gimple_location (alloc_call),\n-\t    \"at offset %s to an object with size between %wu and %wu \"\n-\t    \"allocated by %qE here\",\n-\t    offstr, sizrng[0].to_uhwi (), sizrng[1].to_uhwi (), allocfn);\n+  aref.inform_access (access_write_only);\n }\n \n /* Convenience wrapper for the above.  */\n@@ -3464,7 +3210,7 @@ handle_builtin_memcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi,\n   if (olddsi != NULL\n       && !integer_zerop (len))\n     {\n-      maybe_warn_overflow (stmt, len, rvals, olddsi, false, true);\n+      maybe_warn_overflow (stmt, len, rvals, olddsi, false, false);\n       adjust_last_stmt (olddsi, stmt, false);\n     }\n \n@@ -3931,7 +3677,7 @@ handle_builtin_memset (gimple_stmt_iterator *gsi, bool *zero_write,\n   tree memset_size = gimple_call_arg (memset_stmt, 2);\n \n   /* Check for overflow.  */\n-  maybe_warn_overflow (memset_stmt, memset_size, rvals, NULL, false, true);\n+  maybe_warn_overflow (memset_stmt, memset_size, rvals, NULL, false, false);\n \n   /* Bail when there is no statement associated with the destination\n      (the statement may be null even when SI1->ALLOC is not).  */\n@@ -4593,55 +4339,6 @@ handle_pointer_plus (gimple_stmt_iterator *gsi)\n     }\n }\n \n-/* Describes recursion limits used by count_nonzero_bytes.  */\n-\n-class ssa_name_limit_t\n-{\n-  bitmap visited;         /* Bitmap of visited SSA_NAMEs.  */\n-  unsigned ssa_def_max;   /* Longest chain of SSA_NAMEs to follow.  */\n-\n-  /* Not copyable or assignable.  */\n-  ssa_name_limit_t (ssa_name_limit_t&);\n-  void operator= (ssa_name_limit_t&);\n-\n- public:\n-\n-  ssa_name_limit_t ()\n-    : visited (NULL),\n-    ssa_def_max (param_ssa_name_def_chain_limit) { }\n-\n-  int next_ssa_name (tree);\n-\n-  ~ssa_name_limit_t ()\n-    {\n-      if (visited)\n-\tBITMAP_FREE (visited);\n-    }\n-};\n-\n-/* If the SSA_NAME has already been \"seen\" return a positive value.\n-   Otherwise add it to VISITED.  If the SSA_NAME limit has been\n-   reached, return a negative value.  Otherwise return zero.  */\n-\n-int ssa_name_limit_t::next_ssa_name (tree ssa_name)\n-{\n-  if (!visited)\n-    visited = BITMAP_ALLOC (NULL);\n-\n-  /* Return a positive value if SSA_NAME has already been visited.  */\n-  if (!bitmap_set_bit (visited, SSA_NAME_VERSION (ssa_name)))\n-    return 1;\n-\n-  /* Return a negative value to let caller avoid recursing beyond\n-     the specified limit.  */\n-  if (ssa_def_max == 0)\n-    return -1;\n-\n-  --ssa_def_max;\n-\n-  return 0;\n-}\n-\n static bool\n count_nonzero_bytes_addr (tree, unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n \t\t\t  unsigned [3], bool *, bool *, bool *,\n@@ -4699,7 +4396,7 @@ count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n \t  /* Avoid processing an SSA_NAME that has already been visited\n \t     or if an SSA_NAME limit has been reached.  Indicate success\n \t     if the former and failure if the latter.  */\n-\t  if (int res = snlim.next_ssa_name (exp))\n+\t  if (int res = snlim.next_phi (exp))\n \t    return res > 0;\n \n \t  /* Determine the minimum and maximum from the PHI arguments.  */\n@@ -4934,7 +4631,7 @@ count_nonzero_bytes_addr (tree exp, unsigned HOST_WIDE_INT offset,\n \t  /* Avoid processing an SSA_NAME that has already been visited\n \t     or if an SSA_NAME limit has been reached.  Indicate success\n \t     if the former and failure if the latter.  */\n-\t  if (int res = snlim.next_ssa_name (exp))\n+\t  if (int res = snlim.next_phi (exp))\n \t    return res > 0;\n \n \t  /* Determine the minimum and maximum from the PHI arguments.  */"}]}