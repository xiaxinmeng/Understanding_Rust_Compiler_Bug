{"sha": "8586635cd8c75f3aa096e64953d08f0dfbe6d4f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU4NjYzNWNkOGM3NWYzYWEwOTZlNjQ5NTNkMDhmMGRmYmU2ZDRmNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-08-01T01:44:36Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-08-01T01:44:36Z"}, "message": "Use temporary variables for calls with multiple results.\n\nFrom-SVN: r176998", "tree": {"sha": "b2d4f17d247c5decc45befec37ea433a2a6468ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2d4f17d247c5decc45befec37ea433a2a6468ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8586635cd8c75f3aa096e64953d08f0dfbe6d4f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8586635cd8c75f3aa096e64953d08f0dfbe6d4f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8586635cd8c75f3aa096e64953d08f0dfbe6d4f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8586635cd8c75f3aa096e64953d08f0dfbe6d4f6/comments", "author": null, "committer": null, "parents": [{"sha": "c469244ec0d8b0832ece454041731c7b2ab465db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c469244ec0d8b0832ece454041731c7b2ab465db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c469244ec0d8b0832ece454041731c7b2ab465db"}], "stats": {"total": 894, "additions": 611, "deletions": 283}, "files": [{"sha": "433a6d7d431c87750205468eb7a6c8396f39f099", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 162, "deletions": 62, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8586635cd8c75f3aa096e64953d08f0dfbe6d4f6/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8586635cd8c75f3aa096e64953d08f0dfbe6d4f6/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=8586635cd8c75f3aa096e64953d08f0dfbe6d4f6", "patch": "@@ -926,7 +926,8 @@ Parser_expression::do_type()\n // if necessary.\n \n Expression*\n-Var_expression::do_lower(Gogo* gogo, Named_object* function, int)\n+Var_expression::do_lower(Gogo* gogo, Named_object* function,\n+\t\t\t Statement_inserter* inserter, int)\n {\n   if (this->variable_->is_variable())\n     {\n@@ -935,8 +936,11 @@ Var_expression::do_lower(Gogo* gogo, Named_object* function, int)\n       // reference to a variable which is local to an enclosing\n       // function will be a reference to a field in a closure.\n       if (var->is_global())\n-\tfunction = NULL;\n-      var->lower_init_expression(gogo, function);\n+\t{\n+\t  function = NULL;\n+\t  inserter = NULL;\n+\t}\n+      var->lower_init_expression(gogo, function, inserter);\n     }\n   return this;\n }\n@@ -1061,7 +1065,9 @@ Temporary_reference_expression::do_get_tree(Translate_context* context)\n   // that here by adding a type cast.  We need to use base() to push\n   // the circularity down one level.\n   tree ret = var_to_tree(bvar);\n-  if (POINTER_TYPE_P(TREE_TYPE(ret)) && VOID_TYPE_P(TREE_TYPE(TREE_TYPE(ret))))\n+  if (!this->is_lvalue_\n+      && POINTER_TYPE_P(TREE_TYPE(ret))\n+      && VOID_TYPE_P(TREE_TYPE(TREE_TYPE(ret))))\n     {\n       Btype* type_btype = this->type()->base()->get_backend(context->gogo());\n       tree type_tree = type_to_tree(type_btype);\n@@ -1072,7 +1078,7 @@ Temporary_reference_expression::do_get_tree(Translate_context* context)\n \n // Make a reference to a temporary variable.\n \n-Expression*\n+Temporary_reference_expression*\n Expression::make_temporary_reference(Temporary_statement* statement,\n \t\t\t\t     source_location location)\n {\n@@ -1302,7 +1308,7 @@ Unknown_expression::name() const\n // Lower a reference to an unknown name.\n \n Expression*\n-Unknown_expression::do_lower(Gogo*, Named_object*, int)\n+Unknown_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n {\n   source_location location = this->location();\n   Named_object* no = this->named_object_;\n@@ -2394,7 +2400,7 @@ class Const_expression : public Expression\n   do_traverse(Traverse*);\n \n   Expression*\n-  do_lower(Gogo*, Named_object*, int);\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n \n   bool\n   do_is_constant() const\n@@ -2462,7 +2468,8 @@ Const_expression::do_traverse(Traverse* traverse)\n // predeclared constant iota into an integer value.\n \n Expression*\n-Const_expression::do_lower(Gogo* gogo, Named_object*, int iota_value)\n+Const_expression::do_lower(Gogo* gogo, Named_object*,\n+\t\t\t   Statement_inserter*, int iota_value)\n {\n   if (this->constant_->const_value()->expr()->classification()\n       == EXPRESSION_IOTA)\n@@ -2931,7 +2938,7 @@ class Iota_expression : public Parser_expression\n \n  protected:\n   Expression*\n-  do_lower(Gogo*, Named_object*, int)\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n   { go_unreachable(); }\n \n   // There should only ever be one of these.\n@@ -2988,7 +2995,7 @@ class Type_conversion_expression : public Expression\n   do_traverse(Traverse* traverse);\n \n   Expression*\n-  do_lower(Gogo*, Named_object*, int);\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n \n   bool\n   do_is_constant() const\n@@ -3057,7 +3064,8 @@ Type_conversion_expression::do_traverse(Traverse* traverse)\n // Convert to a constant at lowering time.\n \n Expression*\n-Type_conversion_expression::do_lower(Gogo*, Named_object*, int)\n+Type_conversion_expression::do_lower(Gogo*, Named_object*,\n+\t\t\t\t     Statement_inserter*, int)\n {\n   Type* type = this->type_;\n   Expression* val = this->expr_;\n@@ -3753,7 +3761,7 @@ class Unary_expression : public Expression\n   { return Expression::traverse(&this->expr_, traverse); }\n \n   Expression*\n-  do_lower(Gogo*, Named_object*, int);\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n \n   bool\n   do_is_constant() const;\n@@ -3808,7 +3816,7 @@ class Unary_expression : public Expression\n // instead.\n \n Expression*\n-Unary_expression::do_lower(Gogo*, Named_object*, int)\n+Unary_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n {\n   source_location loc = this->location();\n   Operator op = this->op_;\n@@ -5137,7 +5145,7 @@ Binary_expression::eval_complex(Operator op, Type* left_type,\n // constants.\n \n Expression*\n-Binary_expression::do_lower(Gogo*, Named_object*, int)\n+Binary_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n {\n   source_location location = this->location();\n   Operator op = this->op_;\n@@ -6656,7 +6664,7 @@ class Builtin_call_expression : public Call_expression\n  protected:\n   // This overrides Call_expression::do_lower.\n   Expression*\n-  do_lower(Gogo*, Named_object*, int);\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n \n   bool\n   do_is_constant() const;\n@@ -6864,7 +6872,8 @@ Find_call_expression::expression(Expression** pexpr)\n // specific expressions.  We also convert to a constant if we can.\n \n Expression*\n-Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function, int)\n+Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n+\t\t\t\t  Statement_inserter* inserter, int)\n {\n   if (this->classification() == EXPRESSION_ERROR)\n     return this;\n@@ -6974,7 +6983,7 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function, int)\n \t  this->set_is_error();\n \t  return this;\n \t}\n-      return this->lower_varargs(gogo, function, slice_type, 2);\n+      return this->lower_varargs(gogo, function, inserter, slice_type, 2);\n     }\n \n   return this;\n@@ -8553,9 +8562,10 @@ Call_expression::do_traverse(Traverse* traverse)\n // Lower a call statement.\n \n Expression*\n-Call_expression::do_lower(Gogo* gogo, Named_object* function, int)\n+Call_expression::do_lower(Gogo* gogo, Named_object* function,\n+\t\t\t  Statement_inserter* inserter, int)\n {\n-  // A type case can look like a function call.\n+  // A type cast can look like a function call.\n   if (this->fn_->is_type_expression()\n       && this->args_ != NULL\n       && this->args_->size() == 1)\n@@ -8597,6 +8607,29 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function, int)\n \t}\n     }\n \n+  // If this call returns multiple results, create a temporary\n+  // variable for each result.\n+  size_t rc = this->result_count();\n+  if (rc > 1 && this->results_ == NULL)\n+    {\n+      std::vector<Temporary_statement*>* temps =\n+\tnew std::vector<Temporary_statement*>;\n+      temps->reserve(rc);\n+      const Typed_identifier_list* results =\n+\tthis->fn_->type()->function_type()->results();\n+      for (Typed_identifier_list::const_iterator p = results->begin();\n+\t   p != results->end();\n+\t   ++p)\n+\t{\n+\t  Temporary_statement* temp = Statement::make_temporary(p->type(),\n+\t\t\t\t\t\t\t\tNULL,\n+\t\t\t\t\t\t\t\tp->location());\n+\t  inserter->insert(temp);\n+\t  temps->push_back(temp);\n+\t}\n+      this->results_ = temps;\n+    }\n+\n   // Handle a call to a varargs function by packaging up the extra\n   // parameters.\n   if (this->fn_->type()->function_type() != NULL\n@@ -8606,7 +8639,7 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function, int)\n       const Typed_identifier_list* parameters = fntype->parameters();\n       go_assert(parameters != NULL && !parameters->empty());\n       Type* varargs_type = parameters->back().type();\n-      return this->lower_varargs(gogo, function, varargs_type,\n+      return this->lower_varargs(gogo, function, inserter, varargs_type,\n \t\t\t\t parameters->size());\n     }\n \n@@ -8622,6 +8655,7 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function, int)\n \n Expression*\n Call_expression::lower_varargs(Gogo* gogo, Named_object* function,\n+\t\t\t       Statement_inserter* inserter,\n \t\t\t       Type* varargs_type, size_t param_count)\n {\n   if (this->varargs_are_lowered_)\n@@ -8702,13 +8736,12 @@ Call_expression::lower_varargs(Gogo* gogo, Named_object* function,\n \n   // Lower all the new subexpressions.\n   Expression* ret = this;\n-  gogo->lower_expression(function, &ret);\n+  gogo->lower_expression(function, inserter, &ret);\n   go_assert(ret == this);\n   return ret;\n }\n \n-// Get the function type.  Returns NULL if we don't know the type.  If\n-// this returns NULL, and if_ERROR is true, issues an error.\n+// Get the function type.  This can return NULL in error cases.\n \n Function_type*\n Call_expression::get_function_type() const\n@@ -8729,6 +8762,16 @@ Call_expression::result_count() const\n   return fntype->results()->size();\n }\n \n+// Return the temporary which holds a result.\n+\n+Temporary_statement*\n+Call_expression::result(size_t i) const\n+{\n+  go_assert(this->results_ != NULL\n+\t    && this->results_->size() > i);\n+  return (*this->results_)[i];\n+}\n+\n // Return whether this is a call to the predeclared function recover.\n \n bool\n@@ -8759,6 +8802,21 @@ Call_expression::do_set_recover_arg(Expression*)\n   go_unreachable();\n }\n \n+// We have found an error with this call expression; return true if\n+// we should report it.\n+\n+bool\n+Call_expression::issue_error()\n+{\n+  if (this->issued_error_)\n+    return false;\n+  else\n+    {\n+      this->issued_error_ = true;\n+      return true;\n+    }\n+}\n+\n // Get the type.\n \n Type*\n@@ -8941,15 +8999,12 @@ Call_expression::do_check_types(Gogo*)\n \n // Return whether we have to use a temporary variable to ensure that\n // we evaluate this call expression in order.  If the call returns no\n-// results then it will inevitably be executed last.  If the call\n-// returns more than one result then it will be used with Call_result\n-// expressions.  So we only have to use a temporary variable if the\n-// call returns exactly one result.\n+// results then it will inevitably be executed last.\n \n bool\n Call_expression::do_must_eval_in_order() const\n {\n-  return this->result_count() == 1;\n+  return this->result_count() > 0;\n }\n \n // Get the function and the first argument to use when calling a bound\n@@ -9193,16 +9248,56 @@ Call_expression::do_get_tree(Translate_context* context)\n       ret = build1(NOP_EXPR, rettype, ret);\n     }\n \n-  // If there is more than one result, we will refer to the call\n-  // multiple times.\n-  if (fntype->results() != NULL && fntype->results()->size() > 1)\n-    ret = save_expr(ret);\n+  if (this->results_ != NULL)\n+    ret = this->set_results(context, ret);\n \n   this->tree_ = ret;\n \n   return ret;\n }\n \n+// Set the result variables if this call returns multiple results.\n+\n+tree\n+Call_expression::set_results(Translate_context* context, tree call_tree)\n+{\n+  tree stmt_list = NULL_TREE;\n+\n+  call_tree = save_expr(call_tree);\n+\n+  if (TREE_CODE(TREE_TYPE(call_tree)) != RECORD_TYPE)\n+    {\n+      go_assert(saw_errors());\n+      return call_tree;\n+    }\n+\n+  source_location loc = this->location();\n+  tree field = TYPE_FIELDS(TREE_TYPE(call_tree));\n+  size_t rc = this->result_count();\n+  for (size_t i = 0; i < rc; ++i, field = DECL_CHAIN(field))\n+    {\n+      go_assert(field != NULL_TREE);\n+\n+      Temporary_statement* temp = this->result(i);\n+      Temporary_reference_expression* ref =\n+\tExpression::make_temporary_reference(temp, loc);\n+      ref->set_is_lvalue();\n+      tree temp_tree = ref->get_tree(context);\n+      if (temp_tree == error_mark_node)\n+\tcontinue;\n+\n+      tree val_tree = build3_loc(loc, COMPONENT_REF, TREE_TYPE(field),\n+\t\t\t\t call_tree, field, NULL_TREE);\n+      tree set_tree = build2_loc(loc, MODIFY_EXPR, void_type_node, temp_tree,\n+\t\t\t\t val_tree);\n+\n+      append_to_statement_list(set_tree, &stmt_list);\n+    }\n+  go_assert(field == NULL_TREE);\n+\n+  return save_expr(stmt_list);\n+}\n+\n // Make a call expression.\n \n Call_expression*\n@@ -9292,10 +9387,11 @@ Call_result_expression::do_type()\n       return Type::make_error_type();\n     }\n   const Typed_identifier_list* results = fntype->results();\n-  if (results == NULL)\n+  if (results == NULL || results->size() < 2)\n     {\n-      this->report_error(_(\"number of results does not match \"\n-\t\t\t   \"number of values\"));\n+      if (ce->issue_error())\n+\tthis->report_error(_(\"number of results does not match \"\n+\t\t\t     \"number of values\"));\n       return Type::make_error_type();\n     }\n   Typed_identifier_list::const_iterator pr = results->begin();\n@@ -9307,8 +9403,9 @@ Call_result_expression::do_type()\n     }\n   if (pr == results->end())\n     {\n-      this->report_error(_(\"number of results does not match \"\n-\t\t\t   \"number of values\"));\n+      if (ce->issue_error())\n+\tthis->report_error(_(\"number of results does not match \"\n+\t\t\t     \"number of values\"));\n       return Type::make_error_type();\n     }\n   return pr->type();\n@@ -9332,27 +9429,18 @@ Call_result_expression::do_determine_type(const Type_context*)\n   this->call_->determine_type_no_context();\n }\n \n-// Return the tree.\n+// Return the tree.  We just refer to the temporary set by the call\n+// expression.  We don't do this at lowering time because it makes it\n+// hard to evaluate the call at the right time.\n \n tree\n Call_result_expression::do_get_tree(Translate_context* context)\n {\n-  tree call_tree = this->call_->get_tree(context);\n-  if (call_tree == error_mark_node)\n-    return error_mark_node;\n-  if (TREE_CODE(TREE_TYPE(call_tree)) != RECORD_TYPE)\n-    {\n-      go_assert(saw_errors());\n-      return error_mark_node;\n-    }\n-  tree field = TYPE_FIELDS(TREE_TYPE(call_tree));\n-  for (unsigned int i = 0; i < this->index_; ++i)\n-    {\n-      go_assert(field != NULL_TREE);\n-      field = DECL_CHAIN(field);\n-    }\n-  go_assert(field != NULL_TREE);\n-  return build3(COMPONENT_REF, TREE_TYPE(field), call_tree, field, NULL_TREE);\n+  Call_expression* ce = this->call_->call_expression();\n+  go_assert(ce != NULL);\n+  Temporary_statement* ts = ce->result(this->index_);\n+  Expression* ref = Expression::make_temporary_reference(ts, this->location());\n+  return ref->get_tree(context);\n }\n \n // Make a reference to a single result of a call which returns\n@@ -9383,7 +9471,7 @@ Index_expression::do_traverse(Traverse* traverse)\n // expression into an array index, a string index, or a map index.\n \n Expression*\n-Index_expression::do_lower(Gogo*, Named_object*, int)\n+Index_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n {\n   source_location location = this->location();\n   Expression* left = this->left_;\n@@ -10542,7 +10630,7 @@ class Selector_expression : public Parser_expression\n   { return Expression::traverse(&this->left_, traverse); }\n \n   Expression*\n-  do_lower(Gogo*, Named_object*, int);\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n \n   Expression*\n   do_copy()\n@@ -10565,7 +10653,8 @@ class Selector_expression : public Parser_expression\n // hand side.\n \n Expression*\n-Selector_expression::do_lower(Gogo* gogo, Named_object*, int)\n+Selector_expression::do_lower(Gogo* gogo, Named_object*, Statement_inserter*,\n+\t\t\t      int)\n {\n   Expression* left = this->left_;\n   if (left->is_type_expression())\n@@ -10734,6 +10823,8 @@ Selector_expression::lower_method_expression(Gogo* gogo)\n \t}\n     }\n \n+  gogo->start_block(location);\n+\n   Call_expression* call = Expression::make_call(bm, args,\n \t\t\t\t\t\tmethod_type->is_varargs(),\n \t\t\t\t\t\tlocation);\n@@ -10756,6 +10847,13 @@ Selector_expression::lower_method_expression(Gogo* gogo)\n     }\n   gogo->add_statement(s);\n \n+  Block* b = gogo->finish_block(location);\n+\n+  gogo->add_block(b, location);\n+\n+  // Lower the call in case there are multiple results.\n+  gogo->lower_block(no, b);\n+\n   gogo->finish_function(location);\n \n   return Expression::make_func_reference(no, NULL, location);\n@@ -11860,7 +11958,7 @@ class Composite_literal_expression : public Parser_expression\n   do_traverse(Traverse* traverse);\n \n   Expression*\n-  do_lower(Gogo*, Named_object*, int);\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n \n   Expression*\n   do_copy()\n@@ -11884,7 +11982,7 @@ class Composite_literal_expression : public Parser_expression\n   make_array(Type*, Expression_list*);\n \n   Expression*\n-  lower_map(Gogo*, Named_object*, Type*);\n+  lower_map(Gogo*, Named_object*, Statement_inserter*, Type*);\n \n   // The type of the composite literal.\n   Type* type_;\n@@ -11913,7 +12011,8 @@ Composite_literal_expression::do_traverse(Traverse* traverse)\n // the type.\n \n Expression*\n-Composite_literal_expression::do_lower(Gogo* gogo, Named_object* function, int)\n+Composite_literal_expression::do_lower(Gogo* gogo, Named_object* function,\n+\t\t\t\t       Statement_inserter* inserter, int)\n {\n   Type* type = this->type_;\n \n@@ -11940,7 +12039,7 @@ Composite_literal_expression::do_lower(Gogo* gogo, Named_object* function, int)\n   else if (type->array_type() != NULL)\n     return this->lower_array(type);\n   else if (type->map_type() != NULL)\n-    return this->lower_map(gogo, function, type);\n+    return this->lower_map(gogo, function, inserter, type);\n   else\n     {\n       error_at(this->location(),\n@@ -12244,6 +12343,7 @@ Composite_literal_expression::make_array(Type* type, Expression_list* vals)\n \n Expression*\n Composite_literal_expression::lower_map(Gogo* gogo, Named_object* function,\n+\t\t\t\t\tStatement_inserter* inserter,\n \t\t\t\t\tType* type)\n {\n   source_location location = this->location();\n@@ -12272,7 +12372,7 @@ Composite_literal_expression::lower_map(Gogo* gogo, Named_object* function,\n \t  if ((*p)->unknown_expression() != NULL)\n \t    {\n \t      (*p)->unknown_expression()->clear_is_composite_literal_key();\n-\t      gogo->lower_expression(function, &*p);\n+\t      gogo->lower_expression(function, inserter, &*p);\n \t      go_assert((*p)->is_error_expression());\n \t      return Expression::make_error(location);\n \t    }"}, {"sha": "da31f149ae085c3018efa700cb5b5565dcfb2cb6", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 56, "deletions": 20, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8586635cd8c75f3aa096e64953d08f0dfbe6d4f6/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8586635cd8c75f3aa096e64953d08f0dfbe6d4f6/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=8586635cd8c75f3aa096e64953d08f0dfbe6d4f6", "patch": "@@ -15,6 +15,7 @@\n class Gogo;\n class Translate_context;\n class Traverse;\n+class Statement_inserter;\n class Type;\n struct Type_context;\n class Function_type;\n@@ -128,7 +129,7 @@ class Expression\n   // Make a reference to a temporary variable.  Temporary variables\n   // are always created by a single statement, which is what we use to\n   // refer to them.\n-  static Expression*\n+  static Temporary_reference_expression*\n   make_temporary_reference(Temporary_statement*, source_location);\n \n   // Make a sink expression--a reference to the blank identifier _.\n@@ -521,13 +522,18 @@ class Expression\n   traverse_subexpressions(Traverse*);\n \n   // Lower an expression.  This is called immediately after parsing.\n-  // IOTA_VALUE is the value that we should give to any iota\n-  // expressions.  This function must resolve expressions which could\n-  // not be fully parsed into their final form.  It returns the same\n-  // Expression or a new one.\n+  // FUNCTION is the function we are in; it will be NULL for an\n+  // expression initializing a global variable.  INSERTER may be used\n+  // to insert statements before the statement or initializer\n+  // containing this expression; it is normally used to create\n+  // temporary variables.  IOTA_VALUE is the value that we should give\n+  // to any iota expressions.  This function must resolve expressions\n+  // which could not be fully parsed into their final form.  It\n+  // returns the same Expression or a new one.\n   Expression*\n-  lower(Gogo* gogo, Named_object* function, int iota_value)\n-  { return this->do_lower(gogo, function, iota_value); }\n+  lower(Gogo* gogo, Named_object* function, Statement_inserter* inserter,\n+\tint iota_value)\n+  { return this->do_lower(gogo, function, inserter, iota_value); }\n \n   // Determine the real type of an expression with abstract integer,\n   // floating point, or complex type.  TYPE_CONTEXT describes the\n@@ -636,7 +642,7 @@ class Expression\n \n   // Return a lowered expression.\n   virtual Expression*\n-  do_lower(Gogo*, Named_object*, int)\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n   { return this; }\n \n   // Return whether this is a constant expression.\n@@ -871,7 +877,7 @@ class Parser_expression : public Expression\n \n  protected:\n   virtual Expression*\n-  do_lower(Gogo*, Named_object*, int) = 0;\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int) = 0;\n \n   Type*\n   do_type();\n@@ -906,7 +912,7 @@ class Var_expression : public Expression\n \n  protected:\n   Expression*\n-  do_lower(Gogo*, Named_object*, int);\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n \n   Type*\n   do_type();\n@@ -941,9 +947,15 @@ class Temporary_reference_expression : public Expression\n   Temporary_reference_expression(Temporary_statement* statement,\n \t\t\t\t source_location location)\n     : Expression(EXPRESSION_TEMPORARY_REFERENCE, location),\n-      statement_(statement)\n+      statement_(statement), is_lvalue_(false)\n   { }\n \n+  // Indicate that this reference appears on the left hand side of an\n+  // assignment statement.\n+  void\n+  set_is_lvalue()\n+  { this->is_lvalue_ = true; }\n+\n  protected:\n   Type*\n   do_type();\n@@ -969,6 +981,9 @@ class Temporary_reference_expression : public Expression\n  private:\n   // The statement where the temporary variable is defined.\n   Temporary_statement* statement_;\n+  // Whether this reference appears on the left hand side of an\n+  // assignment statement.\n+  bool is_lvalue_;\n };\n \n // A string expression.\n@@ -1099,7 +1114,7 @@ class Binary_expression : public Expression\n   do_traverse(Traverse* traverse);\n \n   Expression*\n-  do_lower(Gogo*, Named_object*, int);\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n \n   bool\n   do_is_constant() const\n@@ -1156,9 +1171,9 @@ class Call_expression : public Expression\n   Call_expression(Expression* fn, Expression_list* args, bool is_varargs,\n \t\t  source_location location)\n     : Expression(EXPRESSION_CALL, location),\n-      fn_(fn), args_(args), type_(NULL), tree_(NULL), is_varargs_(is_varargs),\n-      varargs_are_lowered_(false), types_are_determined_(false),\n-      is_deferred_(false)\n+      fn_(fn), args_(args), type_(NULL), results_(NULL), tree_(NULL),\n+      is_varargs_(is_varargs), varargs_are_lowered_(false),\n+      types_are_determined_(false), is_deferred_(false), issued_error_(false)\n   { }\n \n   // The function to call.\n@@ -1183,6 +1198,12 @@ class Call_expression : public Expression\n   size_t\n   result_count() const;\n \n+  // Return the temporary variable which holds result I.  This is only\n+  // valid after the expression has been lowered, and is only valid\n+  // for calls which return multiple results.\n+  Temporary_statement*\n+  result(size_t i) const;\n+\n   // Return whether this is a call to the predeclared function\n   // recover.\n   bool\n@@ -1207,12 +1228,17 @@ class Call_expression : public Expression\n   set_is_deferred()\n   { this->is_deferred_ = true; }\n \n+  // We have found an error with this call expression; return true if\n+  // we should report it.\n+  bool\n+  issue_error();\n+\n  protected:\n   int\n   do_traverse(Traverse*);\n \n   virtual Expression*\n-  do_lower(Gogo*, Named_object*, int);\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n \n   void\n   do_discarding_value()\n@@ -1256,8 +1282,8 @@ class Call_expression : public Expression\n \n   // Let a builtin expression lower varargs.\n   Expression*\n-  lower_varargs(Gogo*, Named_object* function, Type* varargs_type,\n-\t\tsize_t param_count);\n+  lower_varargs(Gogo*, Named_object* function, Statement_inserter* inserter,\n+\t\tType* varargs_type, size_t param_count);\n \n   // Let a builtin expression check whether types have been\n   // determined.\n@@ -1276,13 +1302,19 @@ class Call_expression : public Expression\n \t\t\t    Interface_field_reference_expression*,\n \t\t\t    tree*);\n \n+  tree\n+  set_results(Translate_context*, tree);\n+\n   // The function to call.\n   Expression* fn_;\n   // The arguments to pass.  This may be NULL if there are no\n   // arguments.\n   Expression_list* args_;\n   // The type of the expression, to avoid recomputing it.\n   Type* type_;\n+  // The list of temporaries which will hold the results if the\n+  // function returns a tuple.\n+  std::vector<Temporary_statement*>* results_;\n   // The tree for the call, used for a call which returns a tuple.\n   tree tree_;\n   // True if the last argument is a varargs argument (f(a...)).\n@@ -1293,6 +1325,10 @@ class Call_expression : public Expression\n   bool types_are_determined_;\n   // True if the call is an argument to a defer statement.\n   bool is_deferred_;\n+  // True if we reported an error about a mismatch between call\n+  // results and uses.  This is to avoid producing multiple errors\n+  // when there are multiple Call_result_expressions.\n+  bool issued_error_;\n };\n \n // An expression which represents a pointer to a function.\n@@ -1390,7 +1426,7 @@ class Unknown_expression : public Parser_expression\n \n  protected:\n   Expression*\n-  do_lower(Gogo*, Named_object*, int);\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n \n   Expression*\n   do_copy()\n@@ -1425,7 +1461,7 @@ class Index_expression : public Parser_expression\n   do_traverse(Traverse*);\n \n   Expression*\n-  do_lower(Gogo*, Named_object*, int);\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n \n   Expression*\n   do_copy()"}, {"sha": "4aafe412bc5122742f6c1d3f4136747bda0118f3", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 215, "deletions": 127, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8586635cd8c75f3aa096e64953d08f0dfbe6d4f6/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8586635cd8c75f3aa096e64953d08f0dfbe6d4f6/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=8586635cd8c75f3aa096e64953d08f0dfbe6d4f6", "patch": "@@ -1148,9 +1148,13 @@ class Lower_parse_tree : public Traverse\n \t       | traverse_functions\n \t       | traverse_statements\n \t       | traverse_expressions),\n-      gogo_(gogo), function_(function), iota_value_(-1)\n+      gogo_(gogo), function_(function), iota_value_(-1), inserter_()\n   { }\n \n+  void\n+  set_inserter(const Statement_inserter* inserter)\n+  { this->inserter_ = *inserter; }\n+\n   int\n   variable(Named_object*);\n \n@@ -1173,18 +1177,44 @@ class Lower_parse_tree : public Traverse\n   Named_object* function_;\n   // Value to use for the predeclared constant iota.\n   int iota_value_;\n+  // Current statement inserter for use by expressions.\n+  Statement_inserter inserter_;\n };\n \n-// Lower variables.  We handle variables specially to break loops in\n-// which a variable initialization expression refers to itself.  The\n-// loop breaking is in lower_init_expression.\n+// Lower variables.\n \n int\n Lower_parse_tree::variable(Named_object* no)\n {\n-  if (no->is_variable())\n-    no->var_value()->lower_init_expression(this->gogo_, this->function_);\n-  return TRAVERSE_CONTINUE;\n+  if (!no->is_variable())\n+    return TRAVERSE_CONTINUE;\n+\n+  if (no->is_variable() && no->var_value()->is_global())\n+    {\n+      // Global variables can have loops in their initialization\n+      // expressions.  This is handled in lower_init_expression.\n+      no->var_value()->lower_init_expression(this->gogo_, this->function_,\n+\t\t\t\t\t     &this->inserter_);\n+      return TRAVERSE_CONTINUE;\n+    }\n+\n+  // This is a local variable.  We are going to return\n+  // TRAVERSE_SKIP_COMPONENTS here because we want to traverse the\n+  // initialization expression when we reach the variable declaration\n+  // statement.  However, that means that we need to traverse the type\n+  // ourselves.\n+  if (no->var_value()->has_type())\n+    {\n+      Type* type = no->var_value()->type();\n+      if (type != NULL)\n+\t{\n+\t  if (Type::traverse(type, this) == TRAVERSE_EXIT)\n+\t    return TRAVERSE_EXIT;\n+\t}\n+    }\n+  go_assert(!no->var_value()->has_pre_init());\n+\n+  return TRAVERSE_SKIP_COMPONENTS;\n }\n \n // Lower constants.  We handle constants specially so that we can set\n@@ -1238,27 +1268,38 @@ Lower_parse_tree::function(Named_object* no)\n int\n Lower_parse_tree::statement(Block* block, size_t* pindex, Statement* sorig)\n {\n+  Statement_inserter hold_inserter(this->inserter_);\n+  this->inserter_ = Statement_inserter(block, pindex);\n+\n   // Lower the expressions first.\n   int t = sorig->traverse_contents(this);\n   if (t == TRAVERSE_EXIT)\n-    return t;\n+    {\n+      this->inserter_ = hold_inserter;\n+      return t;\n+    }\n \n   // Keep lowering until nothing changes.\n   Statement* s = sorig;\n   while (true)\n     {\n-      Statement* snew = s->lower(this->gogo_, this->function_, block);\n+      Statement* snew = s->lower(this->gogo_, this->function_, block,\n+\t\t\t\t &this->inserter_);\n       if (snew == s)\n \tbreak;\n       s = snew;\n       t = s->traverse_contents(this);\n       if (t == TRAVERSE_EXIT)\n-\treturn t;\n+\t{\n+\t  this->inserter_ = hold_inserter;\n+\t  return t;\n+\t}\n     }\n \n   if (s != sorig)\n     block->replace_statement(*pindex, s);\n \n+  this->inserter_ = hold_inserter;\n   return TRAVERSE_SKIP_COMPONENTS;\n }\n \n@@ -1277,7 +1318,7 @@ Lower_parse_tree::expression(Expression** pexpr)\n     {\n       Expression* e = *pexpr;\n       Expression* enew = e->lower(this->gogo_, this->function_,\n-\t\t\t\t  this->iota_value_);\n+\t\t\t\t  &this->inserter_, this->iota_value_);\n       if (enew == e)\n \tbreak;\n       *pexpr = enew;\n@@ -1304,12 +1345,16 @@ Gogo::lower_block(Named_object* function, Block* block)\n   block->traverse(&lower_parse_tree);\n }\n \n-// Lower an expression.\n+// Lower an expression.  INSERTER may be NULL, in which case the\n+// expression had better not need to create any temporaries.\n \n void\n-Gogo::lower_expression(Named_object* function, Expression** pexpr)\n+Gogo::lower_expression(Named_object* function, Statement_inserter* inserter,\n+\t\t       Expression** pexpr)\n {\n   Lower_parse_tree lower_parse_tree(this, function);\n+  if (inserter != NULL)\n+    lower_parse_tree.set_inserter(inserter);\n   lower_parse_tree.expression(pexpr);\n }\n \n@@ -1951,11 +1996,26 @@ Order_eval::statement(Block* block, size_t* pindex, Statement* s)\n \tbreak;\n \n       source_location loc = (*pexpr)->location();\n-      Temporary_statement* ts = Statement::make_temporary(NULL, *pexpr, loc);\n-      block->insert_statement_before(*pindex, ts);\n-      ++*pindex;\n+      Statement* s;\n+      if ((*pexpr)->call_expression() == NULL\n+\t  || (*pexpr)->call_expression()->result_count() < 2)\n+\t{\n+\t  Temporary_statement* ts = Statement::make_temporary(NULL, *pexpr,\n+\t\t\t\t\t\t\t      loc);\n+\t  s = ts;\n+\t  *pexpr = Expression::make_temporary_reference(ts, loc);\n+\t}\n+      else\n+\t{\n+\t  // A call expression which returns multiple results needs to\n+\t  // be handled specially.  We can't create a temporary\n+\t  // because there is no type to give it.  Any actual uses of\n+\t  // the values will be done via Call_result_expressions.\n+\t  s = Statement::make_statement(*pexpr);\n+\t}\n \n-      *pexpr = Expression::make_temporary_reference(ts, loc);\n+      block->insert_statement_before(*pindex, s);\n+      ++*pindex;\n     }\n \n   if (init != orig_init)\n@@ -1978,7 +2038,7 @@ Order_eval::variable(Named_object* no)\n     return TRAVERSE_CONTINUE;\n \n   Find_eval_ordering find_eval_ordering;\n-  init->traverse_subexpressions(&find_eval_ordering);\n+  Expression::traverse(&init, &find_eval_ordering);\n \n   if (find_eval_ordering.size() <= 1)\n     {\n@@ -1993,9 +2053,22 @@ Order_eval::variable(Named_object* no)\n     {\n       Expression** pexpr = *p;\n       source_location loc = (*pexpr)->location();\n-      Temporary_statement* ts = Statement::make_temporary(NULL, *pexpr, loc);\n-      var->add_preinit_statement(this->gogo_, ts);\n-      *pexpr = Expression::make_temporary_reference(ts, loc);\n+      Statement* s;\n+      if ((*pexpr)->call_expression() == NULL\n+\t  || (*pexpr)->call_expression()->result_count() < 2)\n+\t{\n+\t  Temporary_statement* ts = Statement::make_temporary(NULL, *pexpr,\n+\t\t\t\t\t\t\t      loc);\n+\t  s = ts;\n+\t  *pexpr = Expression::make_temporary_reference(ts, loc);\n+\t}\n+      else\n+\t{\n+\t  // A call expression which returns multiple results needs to\n+\t  // be handled specially.\n+\t  s = Statement::make_statement(*pexpr);\n+\t}\n+      var->add_preinit_statement(this->gogo_, s);\n     }\n \n   return TRAVERSE_SKIP_COMPONENTS;\n@@ -2181,6 +2254,8 @@ Build_recover_thunks::function(Named_object* orig_no)\n     }\n   args->push_back(this->can_recover_arg(location));\n \n+  gogo->start_block(location);\n+\n   Call_expression* call = Expression::make_call(fn, args, false, location);\n \n   Statement* s;\n@@ -2202,6 +2277,13 @@ Build_recover_thunks::function(Named_object* orig_no)\n   s->determine_types();\n   gogo->add_statement(s);\n \n+  Block* b = gogo->finish_block(location);\n+\n+  gogo->add_block(b, location);\n+\n+  // Lower the call in case it returns multiple results.\n+  gogo->lower_block(new_no, b);\n+\n   gogo->finish_function(location);\n \n   // Swap the function bodies and types.\n@@ -3152,78 +3234,64 @@ Block::traverse(Traverse* traverse)\n \t  | Traverse::traverse_expressions\n \t  | Traverse::traverse_types)) != 0)\n     {\n+      const unsigned int e_or_t = (Traverse::traverse_expressions\n+\t\t\t\t   | Traverse::traverse_types);\n+      const unsigned int e_or_t_or_s = (e_or_t\n+\t\t\t\t\t| Traverse::traverse_statements);\n       for (Bindings::const_definitions_iterator pb =\n \t     this->bindings_->begin_definitions();\n \t   pb != this->bindings_->end_definitions();\n \t   ++pb)\n \t{\n+\t  int t = TRAVERSE_CONTINUE;\n \t  switch ((*pb)->classification())\n \t    {\n \t    case Named_object::NAMED_OBJECT_CONST:\n \t      if ((traverse_mask & Traverse::traverse_constants) != 0)\n+\t\tt = traverse->constant(*pb, false);\n+\t      if (t == TRAVERSE_CONTINUE\n+\t\t  && (traverse_mask & e_or_t) != 0)\n \t\t{\n-\t\t  if (traverse->constant(*pb, false) == TRAVERSE_EXIT)\n-\t\t    return TRAVERSE_EXIT;\n-\t\t}\n-\t      if ((traverse_mask & Traverse::traverse_types) != 0\n-\t\t  || (traverse_mask & Traverse::traverse_expressions) != 0)\n-\t\t{\n-\t\t  Type* t = (*pb)->const_value()->type();\n-\t\t  if (t != NULL\n-\t\t      && Type::traverse(t, traverse) == TRAVERSE_EXIT)\n-\t\t    return TRAVERSE_EXIT;\n-\t\t}\n-\t      if ((traverse_mask & Traverse::traverse_expressions) != 0\n-\t\t  || (traverse_mask & Traverse::traverse_types) != 0)\n-\t\t{\n-\t\t  if ((*pb)->const_value()->traverse_expression(traverse)\n-\t\t      == TRAVERSE_EXIT)\n+\t\t  Type* tc = (*pb)->const_value()->type();\n+\t\t  if (tc != NULL\n+\t\t      && Type::traverse(tc, traverse) == TRAVERSE_EXIT)\n \t\t    return TRAVERSE_EXIT;\n+\t\t  t = (*pb)->const_value()->traverse_expression(traverse);\n \t\t}\n \t      break;\n \n \t    case Named_object::NAMED_OBJECT_VAR:\n \t    case Named_object::NAMED_OBJECT_RESULT_VAR:\n \t      if ((traverse_mask & Traverse::traverse_variables) != 0)\n+\t\tt = traverse->variable(*pb);\n+\t      if (t == TRAVERSE_CONTINUE\n+\t\t  && (traverse_mask & e_or_t) != 0)\n \t\t{\n-\t\t  if (traverse->variable(*pb) == TRAVERSE_EXIT)\n-\t\t    return TRAVERSE_EXIT;\n-\t\t}\n-\t      if (((traverse_mask & Traverse::traverse_types) != 0\n-\t\t   || (traverse_mask & Traverse::traverse_expressions) != 0)\n-\t\t  && ((*pb)->is_result_variable()\n-\t\t      || (*pb)->var_value()->has_type()))\n-\t\t{\n-\t\t  Type* t = ((*pb)->is_variable()\n-\t\t\t     ? (*pb)->var_value()->type()\n-\t\t\t     : (*pb)->result_var_value()->type());\n-\t\t  if (t != NULL\n-\t\t      && Type::traverse(t, traverse) == TRAVERSE_EXIT)\n-\t\t    return TRAVERSE_EXIT;\n-\t\t}\n-\t      if ((*pb)->is_variable()\n-\t\t  && ((traverse_mask & Traverse::traverse_expressions) != 0\n-\t\t      || (traverse_mask & Traverse::traverse_types) != 0))\n-\t\t{\n-\t\t  if ((*pb)->var_value()->traverse_expression(traverse)\n-\t\t      == TRAVERSE_EXIT)\n-\t\t    return TRAVERSE_EXIT;\n+\t\t  if ((*pb)->is_result_variable()\n+\t\t      || (*pb)->var_value()->has_type())\n+\t\t    {\n+\t\t      Type* tv = ((*pb)->is_variable()\n+\t\t\t\t  ? (*pb)->var_value()->type()\n+\t\t\t\t  : (*pb)->result_var_value()->type());\n+\t\t      if (tv != NULL\n+\t\t\t  && Type::traverse(tv, traverse) == TRAVERSE_EXIT)\n+\t\t\treturn TRAVERSE_EXIT;\n+\t\t    }\n \t\t}\n+\t      if (t == TRAVERSE_CONTINUE\n+\t\t  && (traverse_mask & e_or_t_or_s) != 0\n+\t\t  && (*pb)->is_variable())\n+\t\tt = (*pb)->var_value()->traverse_expression(traverse,\n+\t\t\t\t\t\t\t    traverse_mask);\n \t      break;\n \n \t    case Named_object::NAMED_OBJECT_FUNC:\n \t    case Named_object::NAMED_OBJECT_FUNC_DECLARATION:\n-\t      // FIXME: Where will nested functions be found?\n \t      go_unreachable();\n \n \t    case Named_object::NAMED_OBJECT_TYPE:\n-\t      if ((traverse_mask & Traverse::traverse_types) != 0\n-\t\t  || (traverse_mask & Traverse::traverse_expressions) != 0)\n-\t\t{\n-\t\t  if (Type::traverse((*pb)->type_value(), traverse)\n-\t\t      == TRAVERSE_EXIT)\n-\t\t    return TRAVERSE_EXIT;\n-\t\t}\n+\t      if ((traverse_mask & e_or_t) != 0)\n+\t\tt = Type::traverse((*pb)->type_value(), traverse);\n \t      break;\n \n \t    case Named_object::NAMED_OBJECT_TYPE_DECLARATION:\n@@ -3237,6 +3305,9 @@ Block::traverse(Traverse* traverse)\n \t    default:\n \t      go_unreachable();\n \t    }\n+\n+\t  if (t == TRAVERSE_EXIT)\n+\t    return TRAVERSE_EXIT;\n \t}\n     }\n \n@@ -3351,14 +3422,17 @@ Variable::Variable(Type* type, Expression* init, bool is_global,\n // Traverse the initializer expression.\n \n int\n-Variable::traverse_expression(Traverse* traverse)\n+Variable::traverse_expression(Traverse* traverse, unsigned int traverse_mask)\n {\n   if (this->preinit_ != NULL)\n     {\n       if (this->preinit_->traverse(traverse) == TRAVERSE_EXIT)\n \treturn TRAVERSE_EXIT;\n     }\n-  if (this->init_ != NULL)\n+  if (this->init_ != NULL\n+      && ((traverse_mask\n+\t   & (Traverse::traverse_expressions | Traverse::traverse_types))\n+\t  != 0))\n     {\n       if (Expression::traverse(&this->init_, traverse) == TRAVERSE_EXIT)\n \treturn TRAVERSE_EXIT;\n@@ -3369,7 +3443,8 @@ Variable::traverse_expression(Traverse* traverse)\n // Lower the initialization expression after parsing is complete.\n \n void\n-Variable::lower_init_expression(Gogo* gogo, Named_object* function)\n+Variable::lower_init_expression(Gogo* gogo, Named_object* function,\n+\t\t\t\tStatement_inserter* inserter)\n {\n   if (this->init_ != NULL && !this->init_is_lowered_)\n     {\n@@ -3381,7 +3456,14 @@ Variable::lower_init_expression(Gogo* gogo, Named_object* function)\n \t}\n       this->seen_ = true;\n \n-      gogo->lower_expression(function, &this->init_);\n+      Statement_inserter global_inserter;\n+      if (this->is_global_)\n+\t{\n+\t  global_inserter = Statement_inserter(gogo, this);\n+\t  inserter = &global_inserter;\n+\t}\n+\n+      gogo->lower_expression(function, inserter, &this->init_);\n \n       this->seen_ = false;\n \n@@ -4508,77 +4590,67 @@ Bindings::traverse(Traverse* traverse, bool is_global)\n \n   // We don't use an iterator because we permit the traversal to add\n   // new global objects.\n+  const unsigned int e_or_t = (Traverse::traverse_expressions\n+\t\t\t       | Traverse::traverse_types);\n+  const unsigned int e_or_t_or_s = (e_or_t\n+\t\t\t\t    | Traverse::traverse_statements);\n   for (size_t i = 0; i < this->named_objects_.size(); ++i)\n     {\n       Named_object* p = this->named_objects_[i];\n+      int t = TRAVERSE_CONTINUE;\n       switch (p->classification())\n \t{\n \tcase Named_object::NAMED_OBJECT_CONST:\n \t  if ((traverse_mask & Traverse::traverse_constants) != 0)\n+\t    t = traverse->constant(p, is_global);\n+\t  if (t == TRAVERSE_CONTINUE\n+\t      && (traverse_mask & e_or_t) != 0)\n \t    {\n-\t      if (traverse->constant(p, is_global) == TRAVERSE_EXIT)\n-\t\treturn TRAVERSE_EXIT;\n-\t    }\n-\t  if ((traverse_mask & Traverse::traverse_types) != 0\n-\t      || (traverse_mask & Traverse::traverse_expressions) != 0)\n-\t    {\n-\t      Type* t = p->const_value()->type();\n-\t      if (t != NULL\n-\t\t  && Type::traverse(t, traverse) == TRAVERSE_EXIT)\n-\t\treturn TRAVERSE_EXIT;\n-\t      if (p->const_value()->traverse_expression(traverse)\n-\t\t  == TRAVERSE_EXIT)\n+\t      Type* tc = p->const_value()->type();\n+\t      if (tc != NULL\n+\t\t  && Type::traverse(tc, traverse) == TRAVERSE_EXIT)\n \t\treturn TRAVERSE_EXIT;\n+\t      t = p->const_value()->traverse_expression(traverse);\n \t    }\n \t  break;\n \n \tcase Named_object::NAMED_OBJECT_VAR:\n \tcase Named_object::NAMED_OBJECT_RESULT_VAR:\n \t  if ((traverse_mask & Traverse::traverse_variables) != 0)\n+\t    t = traverse->variable(p);\n+\t  if (t == TRAVERSE_CONTINUE\n+\t      && (traverse_mask & e_or_t) != 0)\n \t    {\n-\t      if (traverse->variable(p) == TRAVERSE_EXIT)\n-\t\treturn TRAVERSE_EXIT;\n-\t    }\n-\t  if (((traverse_mask & Traverse::traverse_types) != 0\n-\t       || (traverse_mask & Traverse::traverse_expressions) != 0)\n-\t      && (p->is_result_variable()\n-\t\t  || p->var_value()->has_type()))\n-\t    {\n-\t      Type* t = (p->is_variable()\n-\t\t\t ? p->var_value()->type()\n-\t\t\t : p->result_var_value()->type());\n-\t      if (t != NULL\n-\t\t  && Type::traverse(t, traverse) == TRAVERSE_EXIT)\n-\t\treturn TRAVERSE_EXIT;\n-\t    }\n-\t  if (p->is_variable()\n-\t      && ((traverse_mask & Traverse::traverse_types) != 0\n-\t\t  || (traverse_mask & Traverse::traverse_expressions) != 0))\n-\t    {\n-\t      if (p->var_value()->traverse_expression(traverse)\n-\t\t  == TRAVERSE_EXIT)\n-\t\treturn TRAVERSE_EXIT;\n+\t      if (p->is_result_variable()\n+\t\t  || p->var_value()->has_type())\n+\t\t{\n+\t\t  Type* tv = (p->is_variable()\n+\t\t\t      ? p->var_value()->type()\n+\t\t\t      : p->result_var_value()->type());\n+\t\t  if (tv != NULL\n+\t\t      && Type::traverse(tv, traverse) == TRAVERSE_EXIT)\n+\t\t    return TRAVERSE_EXIT;\n+\t\t}\n \t    }\n+\t  if (t == TRAVERSE_CONTINUE\n+\t      && (traverse_mask & e_or_t_or_s) != 0\n+\t      && p->is_variable())\n+\t    t = p->var_value()->traverse_expression(traverse, traverse_mask);\n \t  break;\n \n \tcase Named_object::NAMED_OBJECT_FUNC:\n \t  if ((traverse_mask & Traverse::traverse_functions) != 0)\n-\t    {\n-\t      int t = traverse->function(p);\n-\t      if (t == TRAVERSE_EXIT)\n-\t\treturn TRAVERSE_EXIT;\n-\t      else if (t == TRAVERSE_SKIP_COMPONENTS)\n-\t\tbreak;\n-\t    }\n-\n-\t  if ((traverse_mask\n-\t       & (Traverse::traverse_variables\n-\t\t  | Traverse::traverse_constants\n-\t\t  | Traverse::traverse_functions\n-\t\t  | Traverse::traverse_blocks\n-\t\t  | Traverse::traverse_statements\n-\t\t  | Traverse::traverse_expressions\n-\t\t  | Traverse::traverse_types)) != 0)\n+\t    t = traverse->function(p);\n+\n+\t  if (t == TRAVERSE_CONTINUE\n+\t      && (traverse_mask\n+\t\t  & (Traverse::traverse_variables\n+\t\t     | Traverse::traverse_constants\n+\t\t     | Traverse::traverse_functions\n+\t\t     | Traverse::traverse_blocks\n+\t\t     | Traverse::traverse_statements\n+\t\t     | Traverse::traverse_expressions\n+\t\t     | Traverse::traverse_types)) != 0)\n \t    {\n \t      if (p->func_value()->traverse(traverse) == TRAVERSE_EXIT)\n \t\treturn TRAVERSE_EXIT;\n@@ -4591,12 +4663,8 @@ Bindings::traverse(Traverse* traverse, bool is_global)\n \t  break;\n \n \tcase Named_object::NAMED_OBJECT_TYPE:\n-\t  if ((traverse_mask & Traverse::traverse_types) != 0\n-\t      || (traverse_mask & Traverse::traverse_expressions) != 0)\n-\t    {\n-\t      if (Type::traverse(p->type_value(), traverse) == TRAVERSE_EXIT)\n-\t\treturn TRAVERSE_EXIT;\n-\t    }\n+\t  if ((traverse_mask & e_or_t) != 0)\n+\t    t = Type::traverse(p->type_value(), traverse);\n \t  break;\n \n \tcase Named_object::NAMED_OBJECT_TYPE_DECLARATION:\n@@ -4608,6 +4676,9 @@ Bindings::traverse(Traverse* traverse, bool is_global)\n \tdefault:\n \t  go_unreachable();\n \t}\n+\n+      if (t == TRAVERSE_EXIT)\n+\treturn TRAVERSE_EXIT;\n     }\n \n   return TRAVERSE_CONTINUE;\n@@ -4805,3 +4876,20 @@ Traverse::type(Type*)\n {\n   go_unreachable();\n }\n+\n+// Class Statement_inserter.\n+\n+void\n+Statement_inserter::insert(Statement* s)\n+{\n+  if (this->block_ != NULL)\n+    {\n+      go_assert(this->pindex_ != NULL);\n+      this->block_->insert_statement_before(*this->pindex_, s);\n+      ++*this->pindex_;\n+    }\n+  else if (this->var_ != NULL)\n+    this->var_->add_preinit_statement(this->gogo_, s);\n+  else\n+    go_unreachable();\n+}"}, {"sha": "c9d2971daf58a7750129527165050458aa654c14", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8586635cd8c75f3aa096e64953d08f0dfbe6d4f6/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8586635cd8c75f3aa096e64953d08f0dfbe6d4f6/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=8586635cd8c75f3aa096e64953d08f0dfbe6d4f6", "patch": "@@ -8,6 +8,7 @@\n #define GO_GOGO_H\n \n class Traverse;\n+class Statement_inserter;\n class Type;\n class Type_hash_identical;\n class Type_equal;\n@@ -366,7 +367,7 @@ class Gogo\n \n   // Lower an expression.\n   void\n-  lower_expression(Named_object* function, Expression**);\n+  lower_expression(Named_object* function, Statement_inserter*, Expression**);\n \n   // Lower a constant.\n   void\n@@ -1157,7 +1158,7 @@ class Variable\n \n   // Lower the initialization expression after parsing is complete.\n   void\n-  lower_init_expression(Gogo*, Named_object*);\n+  lower_init_expression(Gogo*, Named_object*, Statement_inserter*);\n \n   // A special case: the init value is used only to determine the\n   // type.  This is used if the variable is defined using := with the\n@@ -1208,7 +1209,7 @@ class Variable\n \n   // Traverse the initializer expression.\n   int\n-  traverse_expression(Traverse*);\n+  traverse_expression(Traverse*, unsigned int traverse_mask);\n \n   // Determine the type of the variable if necessary.\n   void\n@@ -2463,6 +2464,46 @@ class Traverse\n   Expressions_seen* expressions_seen_;\n };\n \n+// A class which makes it easier to insert new statements before the\n+// current statement during a traversal.\n+\n+class Statement_inserter\n+{\n+ public:\n+  // Empty constructor.\n+  Statement_inserter()\n+    : block_(NULL), pindex_(NULL), gogo_(NULL), var_(NULL)\n+  { }\n+\n+  // Constructor for a statement in a block.\n+  Statement_inserter(Block* block, size_t *pindex)\n+    : block_(block), pindex_(pindex), gogo_(NULL), var_(NULL)\n+  { }\n+\n+  // Constructor for a global variable.\n+  Statement_inserter(Gogo* gogo, Variable* var)\n+    : block_(NULL), pindex_(NULL), gogo_(gogo), var_(var)\n+  { go_assert(var->is_global()); }\n+\n+  // We use the default copy constructor and assignment operator.\n+\n+  // Insert S before the statement we are traversing, or before the\n+  // initialization expression of a global variable.\n+  void\n+  insert(Statement* s);\n+\n+ private:\n+  // The block that the statement is in.\n+  Block* block_;\n+  // The index of the statement that we are traversing.\n+  size_t* pindex_;\n+  // The IR, needed when looking at an initializer expression for a\n+  // global variable.\n+  Gogo* gogo_;\n+  // The global variable, when looking at an initializer expression.\n+  Variable* var_;\n+};\n+\n // When translating the gogo IR into the backend data structure, this\n // is the context we pass down the blocks and statements.\n "}, {"sha": "dd2aef6f10a04b8c01111a9065c14f9aeb59a917", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 119, "deletions": 62, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8586635cd8c75f3aa096e64953d08f0dfbe6d4f6/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8586635cd8c75f3aa096e64953d08f0dfbe6d4f6/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=8586635cd8c75f3aa096e64953d08f0dfbe6d4f6", "patch": "@@ -217,6 +217,16 @@ Variable_declaration_statement::do_traverse_assignments(\n   return true;\n }\n \n+// Lower the variable's initialization expression.\n+\n+Statement*\n+Variable_declaration_statement::do_lower(Gogo* gogo, Named_object* function,\n+\t\t\t\t\t Block*, Statement_inserter* inserter)\n+{\n+  this->var_->var_value()->lower_init_expression(gogo, function, inserter);\n+  return this;\n+}\n+\n // Convert a variable declaration to the backend representation.\n \n Bstatement*\n@@ -244,7 +254,7 @@ Variable_declaration_statement::do_get_backend(Translate_context* context)\n   Expression_list* params = new Expression_list();\n   params->push_back(Expression::make_type(var->type(), loc));\n   Expression* call = Expression::make_call(func, params, false, loc);\n-  context->gogo()->lower_expression(context->function(), &call);\n+  context->gogo()->lower_expression(context->function(), NULL, &call);\n   Temporary_statement* temp = Statement::make_temporary(NULL, call, loc);\n   Bstatement* btemp = temp->get_backend(context);\n \n@@ -386,7 +396,7 @@ Temporary_statement::do_get_backend(Translate_context* context)\n     {\n       Expression* init = Expression::make_cast(this->type_, this->init_,\n \t\t\t\t\t       this->location());\n-      context->gogo()->lower_expression(context->function(), &init);\n+      context->gogo()->lower_expression(context->function(), NULL, &init);\n       binit = tree_to_expr(init->get_tree(context));\n     }\n \n@@ -598,7 +608,7 @@ class Assignment_operation_statement : public Statement\n   { go_unreachable(); }\n \n   Statement*\n-  do_lower(Gogo*, Named_object*, Block*);\n+  do_lower(Gogo*, Named_object*, Block*, Statement_inserter*);\n \n   Bstatement*\n   do_get_backend(Translate_context*)\n@@ -628,7 +638,7 @@ Assignment_operation_statement::do_traverse(Traverse* traverse)\n \n Statement*\n Assignment_operation_statement::do_lower(Gogo*, Named_object*,\n-\t\t\t\t\t Block* enclosing)\n+\t\t\t\t\t Block* enclosing, Statement_inserter*)\n {\n   source_location loc = this->location();\n \n@@ -725,7 +735,7 @@ class Tuple_assignment_statement : public Statement\n   { go_unreachable(); }\n \n   Statement*\n-  do_lower(Gogo*, Named_object*, Block*);\n+  do_lower(Gogo*, Named_object*, Block*, Statement_inserter*);\n \n   Bstatement*\n   do_get_backend(Translate_context*)\n@@ -752,7 +762,8 @@ Tuple_assignment_statement::do_traverse(Traverse* traverse)\n // up into a set of single assignments.\n \n Statement*\n-Tuple_assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing)\n+Tuple_assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n+\t\t\t\t     Statement_inserter*)\n {\n   source_location loc = this->location();\n \n@@ -852,7 +863,7 @@ class Tuple_map_assignment_statement : public Statement\n   { go_unreachable(); }\n \n   Statement*\n-  do_lower(Gogo*, Named_object*, Block*);\n+  do_lower(Gogo*, Named_object*, Block*, Statement_inserter*);\n \n   Bstatement*\n   do_get_backend(Translate_context*)\n@@ -882,7 +893,7 @@ Tuple_map_assignment_statement::do_traverse(Traverse* traverse)\n \n Statement*\n Tuple_map_assignment_statement::do_lower(Gogo*, Named_object*,\n-\t\t\t\t\t Block* enclosing)\n+\t\t\t\t\t Block* enclosing, Statement_inserter*)\n {\n   source_location loc = this->location();\n \n@@ -923,14 +934,16 @@ Tuple_map_assignment_statement::do_lower(Gogo*, Named_object*,\n   b->add_statement(present_temp);\n \n   // present_temp = mapaccess2(MAP, &key_temp, &val_temp)\n-  Expression* ref = Expression::make_temporary_reference(key_temp, loc);\n+  Temporary_reference_expression* ref =\n+    Expression::make_temporary_reference(key_temp, loc);\n   Expression* a1 = Expression::make_unary(OPERATOR_AND, ref, loc);\n   ref = Expression::make_temporary_reference(val_temp, loc);\n   Expression* a2 = Expression::make_unary(OPERATOR_AND, ref, loc);\n   Expression* call = Runtime::make_call(Runtime::MAPACCESS2, loc, 3,\n \t\t\t\t\tmap_index->map(), a1, a2);\n \n   ref = Expression::make_temporary_reference(present_temp, loc);\n+  ref->set_is_lvalue();\n   Statement* s = Statement::make_assignment(ref, call, loc);\n   b->add_statement(s);\n \n@@ -979,7 +992,7 @@ class Map_assignment_statement : public Statement\n   { go_unreachable(); }\n \n   Statement*\n-  do_lower(Gogo*, Named_object*, Block*);\n+  do_lower(Gogo*, Named_object*, Block*, Statement_inserter*);\n \n   Bstatement*\n   do_get_backend(Translate_context*)\n@@ -1008,7 +1021,8 @@ Map_assignment_statement::do_traverse(Traverse* traverse)\n // Lower a map assignment to a function call.\n \n Statement*\n-Map_assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing)\n+Map_assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n+\t\t\t\t   Statement_inserter*)\n {\n   source_location loc = this->location();\n \n@@ -1093,7 +1107,7 @@ class Tuple_receive_assignment_statement : public Statement\n   { go_unreachable(); }\n \n   Statement*\n-  do_lower(Gogo*, Named_object*, Block*);\n+  do_lower(Gogo*, Named_object*, Block*, Statement_inserter*);\n \n   Bstatement*\n   do_get_backend(Translate_context*)\n@@ -1125,7 +1139,8 @@ Tuple_receive_assignment_statement::do_traverse(Traverse* traverse)\n \n Statement*\n Tuple_receive_assignment_statement::do_lower(Gogo*, Named_object*,\n-\t\t\t\t\t     Block* enclosing)\n+\t\t\t\t\t     Block* enclosing,\n+\t\t\t\t\t     Statement_inserter*)\n {\n   source_location loc = this->location();\n \n@@ -1160,13 +1175,15 @@ Tuple_receive_assignment_statement::do_lower(Gogo*, Named_object*,\n   b->add_statement(closed_temp);\n \n   // closed_temp = chanrecv[23](channel, &val_temp)\n-  Expression* ref = Expression::make_temporary_reference(val_temp, loc);\n+  Temporary_reference_expression* ref =\n+    Expression::make_temporary_reference(val_temp, loc);\n   Expression* p2 = Expression::make_unary(OPERATOR_AND, ref, loc);\n   Expression* call = Runtime::make_call((this->for_select_\n \t\t\t\t\t ? Runtime::CHANRECV3\n \t\t\t\t\t : Runtime::CHANRECV2),\n \t\t\t\t\tloc, 2, this->channel_, p2);\n   ref = Expression::make_temporary_reference(closed_temp, loc);\n+  ref->set_is_lvalue();\n   Statement* s = Statement::make_assignment(ref, call, loc);\n   b->add_statement(s);\n \n@@ -1217,7 +1234,7 @@ class Tuple_type_guard_assignment_statement : public Statement\n   { go_unreachable(); }\n \n   Statement*\n-  do_lower(Gogo*, Named_object*, Block*);\n+  do_lower(Gogo*, Named_object*, Block*, Statement_inserter*);\n \n   Bstatement*\n   do_get_backend(Translate_context*)\n@@ -1256,7 +1273,8 @@ Tuple_type_guard_assignment_statement::do_traverse(Traverse* traverse)\n \n Statement*\n Tuple_type_guard_assignment_statement::do_lower(Gogo*, Named_object*,\n-\t\t\t\t\t\tBlock* enclosing)\n+\t\t\t\t\t\tBlock* enclosing,\n+\t\t\t\t\t\tStatement_inserter*)\n {\n   source_location loc = this->location();\n \n@@ -1378,6 +1396,10 @@ class Expression_statement : public Statement\n       expr_(expr)\n   { }\n \n+  Expression*\n+  expr()\n+  { return this->expr_; }\n+\n  protected:\n   int\n   do_traverse(Traverse* traverse)\n@@ -1513,7 +1535,7 @@ class Inc_dec_statement : public Statement\n   { go_unreachable(); }\n \n   Statement*\n-  do_lower(Gogo*, Named_object*, Block*);\n+  do_lower(Gogo*, Named_object*, Block*, Statement_inserter*);\n \n   Bstatement*\n   do_get_backend(Translate_context*)\n@@ -1529,7 +1551,7 @@ class Inc_dec_statement : public Statement\n // Lower to += or -=.\n \n Statement*\n-Inc_dec_statement::do_lower(Gogo*, Named_object*, Block*)\n+Inc_dec_statement::do_lower(Gogo*, Named_object*, Block*, Statement_inserter*)\n {\n   source_location loc = this->location();\n \n@@ -2017,6 +2039,8 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name,\n   Named_object* function = gogo->start_function(thunk_name, thunk_type, true,\n \t\t\t\t\t\tlocation);\n \n+  gogo->start_block(location);\n+\n   // For a defer statement, start with a call to\n   // __go_set_defer_retaddr.  */\n   Label* retaddr_label = NULL; \n@@ -2122,26 +2146,10 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name,\n       call_params = NULL;\n     }\n \n-  Expression* call = Expression::make_call(func_to_call, call_params, false,\n-\t\t\t\t\t   location);\n-  // We need to lower in case this is a builtin function.\n-  call = call->lower(gogo, function, -1);\n-  Call_expression* call_ce = call->call_expression();\n-  if (call_ce != NULL && may_call_recover)\n-    call_ce->set_is_deferred();\n-\n+  Call_expression* call = Expression::make_call(func_to_call, call_params,\n+\t\t\t\t\t\tfalse, location);\n   Statement* call_statement = Statement::make_statement(call);\n \n-  // We already ran the determine_types pass, so we need to run it\n-  // just for this statement now.\n-  call_statement->determine_types();\n-\n-  // Sanity check.\n-  call->check_types(gogo);\n-\n-  if (call_ce != NULL && recover_arg != NULL)\n-    call_ce->set_recover_arg(recover_arg);\n-\n   gogo->add_statement(call_statement);\n \n   // If this is a defer statement, the label comes immediately after\n@@ -2155,6 +2163,31 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name,\n       gogo->add_statement(Statement::make_return_statement(vals, location));\n     }\n \n+  Block* b = gogo->finish_block(location);\n+\n+  gogo->add_block(b, location);\n+\n+  gogo->lower_block(function, b);\n+\n+  // We already ran the determine_types pass, so we need to run it\n+  // just for the call statement now.  The other types are known.\n+  call_statement->determine_types();\n+\n+  if (may_call_recover || recover_arg != NULL)\n+    {\n+      // Dig up the call expression, which may have been changed\n+      // during lowering.\n+      go_assert(call_statement->classification() == STATEMENT_EXPRESSION);\n+      Expression_statement* es =\n+\tstatic_cast<Expression_statement*>(call_statement);\n+      Call_expression* ce = es->expr()->call_expression();\n+      go_assert(ce != NULL);\n+      if (may_call_recover)\n+\tce->set_is_deferred();\n+      if (recover_arg != NULL)\n+\tce->set_recover_arg(recover_arg);\n+    }\n+\n   // That is all the thunk has to do.\n   gogo->finish_function(location);\n }\n@@ -2265,7 +2298,8 @@ Return_statement::do_traverse_assignments(Traverse_assignments* tassign)\n // panic/recover work correctly.\n \n Statement*\n-Return_statement::do_lower(Gogo*, Named_object* function, Block* enclosing)\n+Return_statement::do_lower(Gogo*, Named_object* function, Block* enclosing,\n+\t\t\t   Statement_inserter*)\n {\n   if (this->is_lowered_)\n     return this;\n@@ -3305,7 +3339,8 @@ Switch_statement::do_traverse(Traverse* traverse)\n // of if statements.\n \n Statement*\n-Switch_statement::do_lower(Gogo*, Named_object*, Block* enclosing)\n+Switch_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n+\t\t\t   Statement_inserter*)\n {\n   source_location loc = this->location();\n \n@@ -3578,7 +3613,8 @@ Type_switch_statement::do_traverse(Traverse* traverse)\n // equality testing.\n \n Statement*\n-Type_switch_statement::do_lower(Gogo*, Named_object*, Block* enclosing)\n+Type_switch_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n+\t\t\t\tStatement_inserter*)\n {\n   const source_location loc = this->location();\n \n@@ -3629,8 +3665,9 @@ Type_switch_statement::do_lower(Gogo*, Named_object*, Block* enclosing)\n \t\t\t\t\t     ? Runtime::EFACETYPE\n \t\t\t\t\t     : Runtime::IFACETYPE),\n \t\t\t\t\t    loc, 1, ref);\n-      Expression* lhs = Expression::make_temporary_reference(descriptor_temp,\n-\t\t\t\t\t\t\t     loc);\n+      Temporary_reference_expression* lhs =\n+\tExpression::make_temporary_reference(descriptor_temp, loc);\n+      lhs->set_is_lvalue();\n       Statement* s = Statement::make_assignment(lhs, call, loc);\n       b->add_statement(s);\n     }\n@@ -3815,7 +3852,7 @@ Send_statement::do_get_backend(Translate_context* context)\n   call = Runtime::make_call(code, loc, 3, this->channel_, val,\n \t\t\t    Expression::make_boolean(this->for_select_, loc));\n \n-  context->gogo()->lower_expression(context->function(), &call);\n+  context->gogo()->lower_expression(context->function(), NULL, &call);\n   Bexpression* bcall = tree_to_expr(call->get_tree(context));\n   Bstatement* s = context->backend()->expression_statement(bcall);\n \n@@ -4154,7 +4191,7 @@ Select_clauses::get_backend(Translate_context* context,\n \t  Expression* nil2 = nil1->copy();\n \t  Expression* call = Runtime::make_call(Runtime::SELECT, location, 4,\n \t\t\t\t\t\tzero, default_arg, nil1, nil2);\n-\t  context->gogo()->lower_expression(context->function(), &call);\n+\t  context->gogo()->lower_expression(context->function(), NULL, &call);\n \t  Bexpression* bcall = tree_to_expr(call->get_tree(context));\n \t  s = context->backend()->expression_statement(bcall);\n \t}\n@@ -4175,7 +4212,7 @@ Select_clauses::get_backend(Translate_context* context,\n   Expression* chans = Expression::make_composite_literal(chan_array_type, 0,\n \t\t\t\t\t\t\t false, chan_init,\n \t\t\t\t\t\t\t location);\n-  context->gogo()->lower_expression(context->function(), &chans);\n+  context->gogo()->lower_expression(context->function(), NULL, &chans);\n   Temporary_statement* chan_temp = Statement::make_temporary(chan_array_type,\n \t\t\t\t\t\t\t     chans,\n \t\t\t\t\t\t\t     location);\n@@ -4187,7 +4224,7 @@ Select_clauses::get_backend(Translate_context* context,\n \t\t\t\t\t\t\t    0, false,\n \t\t\t\t\t\t\t    is_send_init,\n \t\t\t\t\t\t\t    location);\n-  context->gogo()->lower_expression(context->function(), &is_sends);\n+  context->gogo()->lower_expression(context->function(), NULL, &is_sends);\n   Temporary_statement* is_send_temp =\n     Statement::make_temporary(is_send_array_type, is_sends, location);\n   statements.push_back(is_send_temp->get_backend(context));\n@@ -4213,7 +4250,7 @@ Select_clauses::get_backend(Translate_context* context,\n   Expression* call = Runtime::make_call(Runtime::SELECT, location, 4,\n \t\t\t\t\tecount->copy(), default_arg,\n \t\t\t\t\tchan_arg, is_send_arg);\n-  context->gogo()->lower_expression(context->function(), &call);\n+  context->gogo()->lower_expression(context->function(), NULL, &call);\n   Bexpression* bcall = tree_to_expr(call->get_tree(context));\n \n   std::vector<std::vector<Bexpression*> > cases;\n@@ -4309,7 +4346,7 @@ Select_statement::break_label()\n \n Statement*\n Select_statement::do_lower(Gogo* gogo, Named_object* function,\n-\t\t\t   Block* enclosing)\n+\t\t\t   Block* enclosing, Statement_inserter*)\n {\n   if (this->is_lowered_)\n     return this;\n@@ -4366,7 +4403,8 @@ For_statement::do_traverse(Traverse* traverse)\n // complex statements make it easier to handle garbage collection.\n \n Statement*\n-For_statement::do_lower(Gogo*, Named_object*, Block* enclosing)\n+For_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n+\t\t\tStatement_inserter*)\n {\n   Statement* s;\n   source_location loc = this->location();\n@@ -4497,7 +4535,8 @@ For_range_statement::do_traverse(Traverse* traverse)\n // statements.\n \n Statement*\n-For_range_statement::do_lower(Gogo* gogo, Named_object*, Block* enclosing)\n+For_range_statement::do_lower(Gogo* gogo, Named_object*, Block* enclosing,\n+\t\t\t      Statement_inserter*)\n {\n   Type* range_type = this->range_->type();\n   if (range_type->points_to() != NULL\n@@ -4711,8 +4750,10 @@ For_range_statement::lower_range_array(Gogo* gogo,\n   Expression* zexpr = Expression::make_integer(&zval, NULL, loc);\n   mpz_clear(zval);\n \n-  ref = Expression::make_temporary_reference(index_temp, loc);\n-  Statement* s = Statement::make_assignment(ref, zexpr, loc);\n+  Temporary_reference_expression* tref =\n+    Expression::make_temporary_reference(index_temp, loc);\n+  tref->set_is_lvalue();\n+  Statement* s = Statement::make_assignment(tref, zexpr, loc);\n   init->add_statement(s);\n \n   *pinit = init;\n@@ -4738,8 +4779,9 @@ For_range_statement::lower_range_array(Gogo* gogo,\n       Expression* ref2 = Expression::make_temporary_reference(index_temp, loc);\n       Expression* index = Expression::make_index(ref, ref2, NULL, loc);\n \n-      ref = Expression::make_temporary_reference(value_temp, loc);\n-      s = Statement::make_assignment(ref, index, loc);\n+      tref = Expression::make_temporary_reference(value_temp, loc);\n+      tref->set_is_lvalue();\n+      s = Statement::make_assignment(tref, index, loc);\n \n       iter_init->add_statement(s);\n     }\n@@ -4749,8 +4791,9 @@ For_range_statement::lower_range_array(Gogo* gogo,\n   //   index_temp++\n \n   Block* post = new Block(enclosing, loc);\n-  ref = Expression::make_temporary_reference(index_temp, loc);\n-  s = Statement::make_inc_statement(ref);\n+  tref = Expression::make_temporary_reference(index_temp, loc);\n+  tref->set_is_lvalue();\n+  s = Statement::make_inc_statement(tref);\n   post->add_statement(s);\n   *ppost = post;\n }\n@@ -4798,7 +4841,9 @@ For_range_statement::lower_range_string(Gogo*,\n   mpz_init_set_ui(zval, 0UL);\n   Expression* zexpr = Expression::make_integer(&zval, NULL, loc);\n \n-  Expression* ref = Expression::make_temporary_reference(index_temp, loc);\n+  Temporary_reference_expression* ref =\n+    Expression::make_temporary_reference(index_temp, loc);\n+  ref->set_is_lvalue();\n   Statement* s = Statement::make_assignment(ref, zexpr, loc);\n \n   init->add_statement(s);\n@@ -4829,14 +4874,20 @@ For_range_statement::lower_range_string(Gogo*,\n   if (value_temp == NULL)\n     {\n       ref = Expression::make_temporary_reference(next_index_temp, loc);\n+      ref->set_is_lvalue();\n       s = Statement::make_assignment(ref, call, loc);\n     }\n   else\n     {\n       Expression_list* lhs = new Expression_list();\n-      lhs->push_back(Expression::make_temporary_reference(next_index_temp,\n-\t\t\t\t\t\t\t  loc));\n-      lhs->push_back(Expression::make_temporary_reference(value_temp, loc));\n+\n+      ref = Expression::make_temporary_reference(next_index_temp, loc);\n+      ref->set_is_lvalue();\n+      lhs->push_back(ref);\n+\n+      ref = Expression::make_temporary_reference(value_temp, loc);\n+      ref->set_is_lvalue();\n+      lhs->push_back(ref);\n \n       Expression_list* rhs = new Expression_list();\n       rhs->push_back(Expression::make_call_result(call, 0));\n@@ -4865,7 +4916,9 @@ For_range_statement::lower_range_string(Gogo*,\n \n   Block* post = new Block(enclosing, loc);\n \n-  Expression* lhs = Expression::make_temporary_reference(index_temp, loc);\n+  Temporary_reference_expression* lhs =\n+    Expression::make_temporary_reference(index_temp, loc);\n+  lhs->set_is_lvalue();\n   Expression* rhs = Expression::make_temporary_reference(next_index_temp, loc);\n   s = Statement::make_assignment(lhs, rhs, loc);\n \n@@ -5024,8 +5077,12 @@ For_range_statement::lower_range_channel(Gogo*,\n   iter_init->add_statement(ok_temp);\n \n   Expression* cref = this->make_range_ref(range_object, range_temp, loc);\n-  Expression* iref = Expression::make_temporary_reference(index_temp, loc);\n-  Expression* oref = Expression::make_temporary_reference(ok_temp, loc);\n+  Temporary_reference_expression* iref =\n+    Expression::make_temporary_reference(index_temp, loc);\n+  iref->set_is_lvalue();\n+  Temporary_reference_expression* oref =\n+    Expression::make_temporary_reference(ok_temp, loc);\n+  oref->set_is_lvalue();\n   Statement* s = Statement::make_tuple_receive_assignment(iref, oref, cref,\n \t\t\t\t\t\t\t  false, loc);\n   iter_init->add_statement(s);"}, {"sha": "44241ab115270a4ad047bba525668a2121ea201c", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8586635cd8c75f3aa096e64953d08f0dfbe6d4f6/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8586635cd8c75f3aa096e64953d08f0dfbe6d4f6/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=8586635cd8c75f3aa096e64953d08f0dfbe6d4f6", "patch": "@@ -11,6 +11,7 @@\n \n class Gogo;\n class Traverse;\n+class Statement_inserter;\n class Block;\n class Function;\n class Unnamed_label;\n@@ -290,9 +291,11 @@ class Statement\n   // simplify statements for further processing.  It returns the same\n   // Statement or a new one.  FUNCTION is the function containing this\n   // statement.  BLOCK is the block containing this statement.\n+  // INSERTER can be used to insert new statements before this one.\n   Statement*\n-  lower(Gogo* gogo, Named_object* function, Block* block)\n-  { return this->do_lower(gogo, function, block); }\n+  lower(Gogo* gogo, Named_object* function, Block* block,\n+\tStatement_inserter* inserter)\n+  { return this->do_lower(gogo, function, block, inserter); }\n \n   // Set type information for unnamed constants.\n   void\n@@ -385,7 +388,7 @@ class Statement\n   // Implemented by the child class: lower this statement to a simpler\n   // one.\n   virtual Statement*\n-  do_lower(Gogo*, Named_object*, Block*)\n+  do_lower(Gogo*, Named_object*, Block*, Statement_inserter*)\n   { return this; }\n \n   // Implemented by child class: set type information for unnamed\n@@ -535,6 +538,9 @@ class Variable_declaration_statement : public Statement\n   bool\n   do_traverse_assignments(Traverse_assignments*);\n \n+  Statement*\n+  do_lower(Gogo*, Named_object*, Block*, Statement_inserter*);\n+\n   Bstatement*\n   do_get_backend(Translate_context*);\n \n@@ -566,7 +572,7 @@ class Return_statement : public Statement\n   do_traverse_assignments(Traverse_assignments*);\n \n   Statement*\n-  do_lower(Gogo*, Named_object*, Block*);\n+  do_lower(Gogo*, Named_object*, Block*, Statement_inserter*);\n \n   bool\n   do_may_fall_through() const\n@@ -806,7 +812,7 @@ class Select_statement : public Statement\n   { return this->clauses_->traverse(traverse); }\n \n   Statement*\n-  do_lower(Gogo*, Named_object*, Block*);\n+  do_lower(Gogo*, Named_object*, Block*, Statement_inserter*);\n \n   void\n   do_determine_types()\n@@ -993,7 +999,7 @@ class For_statement : public Statement\n   { go_unreachable(); }\n \n   Statement*\n-  do_lower(Gogo*, Named_object*, Block*);\n+  do_lower(Gogo*, Named_object*, Block*, Statement_inserter*);\n \n   Bstatement*\n   do_get_backend(Translate_context*)\n@@ -1051,7 +1057,7 @@ class For_range_statement : public Statement\n   { go_unreachable(); }\n \n   Statement*\n-  do_lower(Gogo*, Named_object*, Block*);\n+  do_lower(Gogo*, Named_object*, Block*, Statement_inserter*);\n \n   Bstatement*\n   do_get_backend(Translate_context*)\n@@ -1280,7 +1286,7 @@ class Switch_statement : public Statement\n   do_traverse(Traverse*);\n \n   Statement*\n-  do_lower(Gogo*, Named_object*, Block*);\n+  do_lower(Gogo*, Named_object*, Block*, Statement_inserter*);\n \n   Bstatement*\n   do_get_backend(Translate_context*)\n@@ -1426,7 +1432,7 @@ class Type_switch_statement : public Statement\n   do_traverse(Traverse*);\n \n   Statement*\n-  do_lower(Gogo*, Named_object*, Block*);\n+  do_lower(Gogo*, Named_object*, Block*, Statement_inserter*);\n \n   Bstatement*\n   do_get_backend(Translate_context*)"}]}