{"sha": "9eeea7612d055f00ce21fd1442411c838d82b452", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVlZWE3NjEyZDA1NWYwMGNlMjFmZDE0NDI0MTFjODM4ZDgyYjQ1Mg==", "commit": {"author": {"name": "Douglas Gregor", "email": "doug.gregor@gmail.com", "date": "2007-03-10T02:04:13Z"}, "committer": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2007-03-10T02:04:13Z"}, "message": "Makefile.in: Regenerate.\n\n2007-03-09  Douglas Gregor  <doug.gregor@gmail.com>\n\n\t* include/Makefile.in: Regenerate.\n\t* include/tr1/mu_iterate.h: Remove.\n\t* include/tr1/tuple (_Tuple_impl): New.\n\t(tuple): Make variadic, re-implement as shell over _Tuple_impl.\n\t(0-element tuple): Basis case.\n\t(2-element tuple): Handle pair methods.\n\t(__get_helper): Remove.\n\t(tuple_element): Reimplement with variadic templates.\n\t(tuple_size): Ditto.\n\t(get): Ditto.\n\t(operator==): Use variadic templates in the signature.\n\t(operator<): Ditto.\n\t(operator!=): Ditto.\n\t(operator>): Ditto.\n\t(operator<=): Ditto.\n\t(operator>=): Ditto.\n\t(__stripped_tuple_type): Remove; we've inlined its behavior.\n\t(make_tuple): Reimplement with variadic templates.\n\t(tie): Ditto.\n\t* include/tr1/tuple_iterate.h: Remove.\n\t* include/tr1/bind_repeat.h: Remove.\n\t* include/tr1/ref_wrap_iterate.h: Remove.\n\t* include/tr1/bind_iterate.h: Remove.\n\t* include/tr1/functional (_Weak_result_type): Add variadic\n\tpartial specializations.\n\t(result_of): Ditto.\n\t(__invoke): Reimplement using variadic templates.\n\t(reference_wrapper): Reimplement operator() with variadic\n\ttemplates.\n\t(_Maybe_unary_or_binary_function): New.\n\t(_Mem_fn): Implement for member function pointers using variadic\n\ttemplates.\n\t(placeholders): Define 30 placeholders.\n\t(_Index_tuple): New.\n\t(_Build_index_tuple): New.\n\t(_No_tuple_element): New.\n\t(_Safe_tuple_element_impl): New.\n\t(_Safe_tuple_element): New.\n\t(_Mu): Reimplement with variadic templates, use\n\t_Safe_tuple_element instead of tuple_element.\n\t(_Bind): Reimplement with variadic templates and tuples.\n\t(_Bind_result): Ditto.\n\t(bind): Reimplement with variadic templates.\n\t(_Function_handler): Ditto.\n\t(function): Ditto.\n\t* include/tr1/functional_iterate.h: Remove.\n\t* include/tr1/repeat.h: Remove.\n\t* include/Makefile.am: Don't install removed headers.\n\nFrom-SVN: r122790", "tree": {"sha": "30690e87aea8f9da57368712a0ee3c2834912e78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30690e87aea8f9da57368712a0ee3c2834912e78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9eeea7612d055f00ce21fd1442411c838d82b452", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eeea7612d055f00ce21fd1442411c838d82b452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eeea7612d055f00ce21fd1442411c838d82b452", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eeea7612d055f00ce21fd1442411c838d82b452/comments", "author": {"login": "DougGregor", "id": 989428, "node_id": "MDQ6VXNlcjk4OTQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/989428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DougGregor", "html_url": "https://github.com/DougGregor", "followers_url": "https://api.github.com/users/DougGregor/followers", "following_url": "https://api.github.com/users/DougGregor/following{/other_user}", "gists_url": "https://api.github.com/users/DougGregor/gists{/gist_id}", "starred_url": "https://api.github.com/users/DougGregor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DougGregor/subscriptions", "organizations_url": "https://api.github.com/users/DougGregor/orgs", "repos_url": "https://api.github.com/users/DougGregor/repos", "events_url": "https://api.github.com/users/DougGregor/events{/privacy}", "received_events_url": "https://api.github.com/users/DougGregor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d6a85c8dd4854845630569bbec6437170c3bc246", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6a85c8dd4854845630569bbec6437170c3bc246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6a85c8dd4854845630569bbec6437170c3bc246"}], "stats": {"total": 3742, "additions": 1521, "deletions": 2221}, "files": [{"sha": "6402706916e219209a30be95dc56f3842d69468f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eeea7612d055f00ce21fd1442411c838d82b452/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eeea7612d055f00ce21fd1442411c838d82b452/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9eeea7612d055f00ce21fd1442411c838d82b452", "patch": "@@ -1,3 +1,54 @@\n+2007-03-09  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\t* include/Makefile.in: Regenerate.\n+\t* include/tr1/mu_iterate.h: Remove.\n+\t* include/tr1/tuple (_Tuple_impl): New.\n+\t(tuple): Make variadic, re-implement as shell over _Tuple_impl.\n+\t(0-element tuple): Basis case.\n+\t(2-element tuple): Handle pair methods.\n+\t(__get_helper): Remove.\n+\t(tuple_element): Reimplement with variadic templates.\n+\t(tuple_size): Ditto.\n+\t(get): Ditto.\n+\t(operator==): Use variadic templates in the signature.\n+\t(operator<): Ditto.\n+\t(operator!=): Ditto.\n+\t(operator>): Ditto.\n+\t(operator<=): Ditto.\n+\t(operator>=): Ditto.\n+\t(__stripped_tuple_type): Remove; we've inlined its behavior.\n+\t(make_tuple): Reimplement with variadic templates.\n+\t(tie): Ditto.\n+\t* include/tr1/tuple_iterate.h: Remove.\n+\t* include/tr1/bind_repeat.h: Remove.\n+\t* include/tr1/ref_wrap_iterate.h: Remove.\n+\t* include/tr1/bind_iterate.h: Remove.\n+\t* include/tr1/functional (_Weak_result_type): Add variadic\n+\tpartial specializations.\n+\t(result_of): Ditto.\n+\t(__invoke): Reimplement using variadic templates.\n+\t(reference_wrapper): Reimplement operator() with variadic\n+\ttemplates.\n+\t(_Maybe_unary_or_binary_function): New.\n+\t(_Mem_fn): Implement for member function pointers using variadic\n+\ttemplates.\n+\t(placeholders): Define 30 placeholders.\n+\t(_Index_tuple): New.\n+\t(_Build_index_tuple): New.\n+\t(_No_tuple_element): New.\n+\t(_Safe_tuple_element_impl): New.\n+\t(_Safe_tuple_element): New.\n+\t(_Mu): Reimplement with variadic templates, use\n+\t_Safe_tuple_element instead of tuple_element.\n+\t(_Bind): Reimplement with variadic templates and tuples.\n+\t(_Bind_result): Ditto.\n+\t(bind): Reimplement with variadic templates.\n+\t(_Function_handler): Ditto.\n+\t(function): Ditto.\n+\t* include/tr1/functional_iterate.h: Remove.\n+\t* include/tr1/repeat.h: Remove.\n+\t* include/Makefile.am: Don't install removed headers.\n+\t\n 2007-03-06  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/28080 (partial)"}, {"sha": "b5cbc99b8c21cc77ef09a012bb6c8b350479a098", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eeea7612d055f00ce21fd1442411c838d82b452/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eeea7612d055f00ce21fd1442411c838d82b452/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=9eeea7612d055f00ce21fd1442411c838d82b452", "patch": "@@ -532,8 +532,6 @@ tr1_srcdir = ${glibcxx_srcdir}/include/tr1\n tr1_builddir = ./tr1\n tr1_headers = \\\n \t${tr1_srcdir}/array \\\n-\t${tr1_srcdir}/bind_repeat.h \\\n-\t${tr1_srcdir}/bind_iterate.h \\\n \t${tr1_srcdir}/boost_shared_ptr.h \\\n \t${tr1_srcdir}/ccomplex \\\n \t${tr1_srcdir}/cctype \\\n@@ -559,29 +557,23 @@ tr1_headers = \\\n \t${tr1_srcdir}/float.h \\\n \t${tr1_srcdir}/functional \\\n \t${tr1_srcdir}/functional_hash.h \\\n-\t${tr1_srcdir}/functional_iterate.h \\\n \t${tr1_srcdir}/hashtable \\\n \t${tr1_srcdir}/hashtable_policy.h \\\n \t${tr1_srcdir}/inttypes.h \\\n \t${tr1_srcdir}/limits.h \\\n \t${tr1_srcdir}/math.h \\\n \t${tr1_srcdir}/memory \\\n-\t${tr1_srcdir}/mu_iterate.h \\\n \t${tr1_srcdir}/random \\\n \t${tr1_srcdir}/random.tcc \\\n \t${tr1_srcdir}/ref_fwd.h \\\n-\t${tr1_srcdir}/ref_wrap_iterate.h \\\n \t${tr1_srcdir}/regex \\\n-\t${tr1_srcdir}/repeat.h \\\n \t${tr1_srcdir}/stdarg.h \\\n \t${tr1_srcdir}/stdbool.h \\\n \t${tr1_srcdir}/stdint.h \\\n \t${tr1_srcdir}/stdio.h \\\n \t${tr1_srcdir}/stdlib.h \\\n \t${tr1_srcdir}/tgmath.h \\\n \t${tr1_srcdir}/tuple \\\n-\t${tr1_srcdir}/tuple_defs.h \\\n-\t${tr1_srcdir}/tuple_iterate.h \\\n \t${tr1_srcdir}/type_traits \\\n \t${tr1_srcdir}/type_traits_fwd.h \\\n \t${tr1_srcdir}/unordered_set \\"}, {"sha": "93f4d972650d357ee01f1fa0241aa7c7f8325180", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eeea7612d055f00ce21fd1442411c838d82b452/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eeea7612d055f00ce21fd1442411c838d82b452/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=9eeea7612d055f00ce21fd1442411c838d82b452", "patch": "@@ -762,8 +762,6 @@ tr1_srcdir = ${glibcxx_srcdir}/include/tr1\n tr1_builddir = ./tr1\n tr1_headers = \\\n \t${tr1_srcdir}/array \\\n-\t${tr1_srcdir}/bind_repeat.h \\\n-\t${tr1_srcdir}/bind_iterate.h \\\n \t${tr1_srcdir}/boost_shared_ptr.h \\\n \t${tr1_srcdir}/ccomplex \\\n \t${tr1_srcdir}/cctype \\\n@@ -789,29 +787,23 @@ tr1_headers = \\\n \t${tr1_srcdir}/float.h \\\n \t${tr1_srcdir}/functional \\\n \t${tr1_srcdir}/functional_hash.h \\\n-\t${tr1_srcdir}/functional_iterate.h \\\n \t${tr1_srcdir}/hashtable \\\n \t${tr1_srcdir}/hashtable_policy.h \\\n \t${tr1_srcdir}/inttypes.h \\\n \t${tr1_srcdir}/limits.h \\\n \t${tr1_srcdir}/math.h \\\n \t${tr1_srcdir}/memory \\\n-\t${tr1_srcdir}/mu_iterate.h \\\n \t${tr1_srcdir}/random \\\n \t${tr1_srcdir}/random.tcc \\\n \t${tr1_srcdir}/ref_fwd.h \\\n-\t${tr1_srcdir}/ref_wrap_iterate.h \\\n \t${tr1_srcdir}/regex \\\n-\t${tr1_srcdir}/repeat.h \\\n \t${tr1_srcdir}/stdarg.h \\\n \t${tr1_srcdir}/stdbool.h \\\n \t${tr1_srcdir}/stdint.h \\\n \t${tr1_srcdir}/stdio.h \\\n \t${tr1_srcdir}/stdlib.h \\\n \t${tr1_srcdir}/tgmath.h \\\n \t${tr1_srcdir}/tuple \\\n-\t${tr1_srcdir}/tuple_defs.h \\\n-\t${tr1_srcdir}/tuple_iterate.h \\\n \t${tr1_srcdir}/type_traits \\\n \t${tr1_srcdir}/type_traits_fwd.h \\\n \t${tr1_srcdir}/unordered_set \\"}, {"sha": "3de49a77b6c0e7d2db4dabbd4a2d80c6b67e1db2", "filename": "libstdc++-v3/include/tr1/bind_iterate.h", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a85c8dd4854845630569bbec6437170c3bc246/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fbind_iterate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a85c8dd4854845630569bbec6437170c3bc246/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fbind_iterate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fbind_iterate.h?ref=d6a85c8dd4854845630569bbec6437170c3bc246", "patch": "@@ -1,78 +0,0 @@\n-// TR1 functional -*- C++ -*-\n-\n-// Copyright (C) 2005 Free Software Foundation, Inc.\n-// Written by Douglas Gregor <doug.gregor -at- gmail.com>\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file tr1/bind_iterate.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#if _GLIBCXX_BIND_NUM_ARGS > 0\n-template<_GLIBCXX_BIND_TEMPLATE_PARAMS>\n-#endif\n-#ifdef _GLIBCXX_BIND_HAS_RESULT_TYPE\n-result_type\n-#else\n-typename result_of<_Functor(_GLIBCXX_BIND_V_TEMPLATE_ARGS())>::type\n-#endif\n-operator()(_GLIBCXX_BIND_PARAMS)\n-{ return _M_f(_GLIBCXX_BIND_V_ARGS); }\n-\n-#if _GLIBCXX_BIND_NUM_ARGS > 0\n-template<_GLIBCXX_BIND_TEMPLATE_PARAMS>\n-#endif\n-#ifdef _GLIBCXX_BIND_HAS_RESULT_TYPE\n-result_type\n-#else\n-typename result_of<const _Functor(_GLIBCXX_BIND_V_TEMPLATE_ARGS(const))>::type\n-#endif\n-operator()(_GLIBCXX_BIND_PARAMS) const\n-{ return _M_f(_GLIBCXX_BIND_V_ARGS); }\n-\n-#if _GLIBCXX_BIND_NUM_ARGS > 0\n-template<_GLIBCXX_BIND_TEMPLATE_PARAMS>\n-#endif\n-#ifdef _GLIBCXX_BIND_HAS_RESULT_TYPE\n-result_type\n-#else\n-typename result_of<volatile _Functor(_GLIBCXX_BIND_V_TEMPLATE_ARGS(volatile))>::type\n-#endif\n-operator()(_GLIBCXX_BIND_PARAMS) volatile\n-{ return _M_f(_GLIBCXX_BIND_V_ARGS); }\n-\n-#if _GLIBCXX_BIND_NUM_ARGS > 0\n-template<_GLIBCXX_BIND_TEMPLATE_PARAMS>\n-#endif\n-#ifdef _GLIBCXX_BIND_HAS_RESULT_TYPE\n-result_type\n-#else\n-typename result_of<const volatile _Functor(_GLIBCXX_BIND_V_TEMPLATE_ARGS(const volatile))>::type\n-#endif\n-operator()(_GLIBCXX_BIND_PARAMS) const volatile\n-{ return _M_f(_GLIBCXX_BIND_V_ARGS); }"}, {"sha": "8ec29a2283f5dd0b83d5946b62fb0aa76fc697a2", "filename": "libstdc++-v3/include/tr1/bind_repeat.h", "status": "removed", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a85c8dd4854845630569bbec6437170c3bc246/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fbind_repeat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a85c8dd4854845630569bbec6437170c3bc246/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fbind_repeat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fbind_repeat.h?ref=d6a85c8dd4854845630569bbec6437170c3bc246", "patch": "@@ -1,192 +0,0 @@\n-// TR1 code repetition for bind -*- C++ -*-\n-\n-// Copyright (C) 2005 Free Software Foundation, Inc.\n-// Written by Douglas Gregor <doug.gregor -at- gmail.com>\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file tr1/bind_repeat.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#ifndef _GLIBCXX_BIND_REPEAT_HEADER\n-#  error Internal error: _GLIBCXX_BIND_REPEAT_HEADER must be set\n-#endif /* _GLIBCXX_BIND_REPEAT_HEADER */\n-\n-#define _GLIBCXX_BIND_NUM_ARGS 0\n-#define _GLIBCXX_BIND_COMMA\n-#define _GLIBCXX_BIND_TEMPLATE_PARAMS\n-#define _GLIBCXX_BIND_TEMPLATE_ARGS\n-#define _GLIBCXX_BIND_PARAMS\n-#define _GLIBCXX_BIND_ARGS\n-#  include _GLIBCXX_BIND_REPEAT_HEADER\n-#undef _GLIBCXX_BIND_ARGS\n-#undef _GLIBCXX_BIND_PARAMS\n-#undef _GLIBCXX_BIND_TEMPLATE_ARGS\n-#undef _GLIBCXX_BIND_TEMPLATE_PARAMS\n-#undef _GLIBCXX_BIND_COMMA\n-#undef _GLIBCXX_BIND_NUM_ARGS\n-\n-#define _GLIBCXX_BIND_NUM_ARGS 1\n-#define _GLIBCXX_BIND_COMMA ,\n-#define _GLIBCXX_BIND_TEMPLATE_PARAMS typename _U1\n-#define _GLIBCXX_BIND_TEMPLATE_ARGS _U1\n-#define _GLIBCXX_BIND_PARAMS _U1& __u1\n-#define _GLIBCXX_BIND_ARGS __u1\n-#include _GLIBCXX_BIND_REPEAT_HEADER\n-#undef _GLIBCXX_BIND_ARGS\n-#undef _GLIBCXX_BIND_PARAMS\n-#undef _GLIBCXX_BIND_TEMPLATE_ARGS\n-#undef _GLIBCXX_BIND_TEMPLATE_PARAMS\n-#undef _GLIBCXX_BIND_COMMA\n-#undef _GLIBCXX_BIND_NUM_ARGS\n-#define _GLIBCXX_BIND_NUM_ARGS 2\n-#define _GLIBCXX_BIND_COMMA ,\n-#define _GLIBCXX_BIND_TEMPLATE_PARAMS typename _U1, typename _U2\n-#define _GLIBCXX_BIND_TEMPLATE_ARGS _U1, _U2\n-#define _GLIBCXX_BIND_PARAMS _U1& __u1, _U2& __u2\n-#define _GLIBCXX_BIND_ARGS __u1, __u2\n-#include _GLIBCXX_BIND_REPEAT_HEADER\n-#undef _GLIBCXX_BIND_ARGS\n-#undef _GLIBCXX_BIND_PARAMS\n-#undef _GLIBCXX_BIND_TEMPLATE_ARGS\n-#undef _GLIBCXX_BIND_TEMPLATE_PARAMS\n-#undef _GLIBCXX_BIND_COMMA\n-#undef _GLIBCXX_BIND_NUM_ARGS\n-\n-#define _GLIBCXX_BIND_NUM_ARGS 3\n-#define _GLIBCXX_BIND_COMMA ,\n-#define _GLIBCXX_BIND_TEMPLATE_PARAMS typename _U1, typename _U2, typename _U3\n-#define _GLIBCXX_BIND_TEMPLATE_ARGS _U1, _U2, _U3\n-#define _GLIBCXX_BIND_PARAMS _U1& __u1, _U2& __u2, _U3& __u3\n-#define _GLIBCXX_BIND_ARGS __u1, __u2, __u3\n-#include _GLIBCXX_BIND_REPEAT_HEADER\n-#undef _GLIBCXX_BIND_ARGS\n-#undef _GLIBCXX_BIND_PARAMS\n-#undef _GLIBCXX_BIND_TEMPLATE_ARGS\n-#undef _GLIBCXX_BIND_TEMPLATE_PARAMS\n-#undef _GLIBCXX_BIND_COMMA\n-#undef _GLIBCXX_BIND_NUM_ARGS\n-\n-#define _GLIBCXX_BIND_NUM_ARGS 4\n-#define _GLIBCXX_BIND_COMMA ,\n-#define _GLIBCXX_BIND_TEMPLATE_PARAMS typename _U1, typename _U2, typename _U3, typename _U4\n-#define _GLIBCXX_BIND_TEMPLATE_ARGS _U1, _U2, _U3, _U4\n-#define _GLIBCXX_BIND_PARAMS _U1& __u1, _U2& __u2, _U3& __u3, _U4& __u4\n-#define _GLIBCXX_BIND_ARGS __u1, __u2, __u3, __u4\n-#include _GLIBCXX_BIND_REPEAT_HEADER\n-#undef _GLIBCXX_BIND_ARGS\n-#undef _GLIBCXX_BIND_PARAMS\n-#undef _GLIBCXX_BIND_TEMPLATE_ARGS\n-#undef _GLIBCXX_BIND_TEMPLATE_PARAMS\n-#undef _GLIBCXX_BIND_COMMA\n-#undef _GLIBCXX_BIND_NUM_ARGS\n-\n-#define _GLIBCXX_BIND_NUM_ARGS 5\n-#define _GLIBCXX_BIND_COMMA ,\n-#define _GLIBCXX_BIND_TEMPLATE_PARAMS typename _U1, typename _U2, typename _U3, typename _U4, typename _U5\n-#define _GLIBCXX_BIND_TEMPLATE_ARGS _U1, _U2, _U3, _U4, _U5\n-#define _GLIBCXX_BIND_PARAMS _U1& __u1, _U2& __u2, _U3& __u3, _U4& __u4, _U5& __u5\n-#define _GLIBCXX_BIND_ARGS __u1, __u2, __u3, __u4, __u5\n-#include _GLIBCXX_BIND_REPEAT_HEADER\n-#undef _GLIBCXX_BIND_ARGS\n-#undef _GLIBCXX_BIND_PARAMS\n-#undef _GLIBCXX_BIND_TEMPLATE_ARGS\n-#undef _GLIBCXX_BIND_TEMPLATE_PARAMS\n-#undef _GLIBCXX_BIND_COMMA\n-#undef _GLIBCXX_BIND_NUM_ARGS\n-\n-#define _GLIBCXX_BIND_NUM_ARGS 6\n-#define _GLIBCXX_BIND_COMMA ,\n-#define _GLIBCXX_BIND_TEMPLATE_PARAMS typename _U1, typename _U2, typename _U3, typename _U4, typename _U5, typename _U6\n-#define _GLIBCXX_BIND_TEMPLATE_ARGS _U1, _U2, _U3, _U4, _U5, _U6\n-#define _GLIBCXX_BIND_PARAMS _U1& __u1, _U2& __u2, _U3& __u3, _U4& __u4, _U5& __u5, _U6& __u6\n-#define _GLIBCXX_BIND_ARGS __u1, __u2, __u3, __u4, __u5, __u6\n-#include _GLIBCXX_BIND_REPEAT_HEADER\n-#undef _GLIBCXX_BIND_ARGS\n-#undef _GLIBCXX_BIND_PARAMS\n-#undef _GLIBCXX_BIND_TEMPLATE_ARGS\n-#undef _GLIBCXX_BIND_TEMPLATE_PARAMS\n-#undef _GLIBCXX_BIND_COMMA\n-#undef _GLIBCXX_BIND_NUM_ARGS\n-\n-#define _GLIBCXX_BIND_NUM_ARGS 7\n-#define _GLIBCXX_BIND_COMMA ,\n-#define _GLIBCXX_BIND_TEMPLATE_PARAMS typename _U1, typename _U2, typename _U3, typename _U4, typename _U5, typename _U6, typename _U7\n-#define _GLIBCXX_BIND_TEMPLATE_ARGS _U1, _U2, _U3, _U4, _U5, _U6, _U7\n-#define _GLIBCXX_BIND_PARAMS _U1& __u1, _U2& __u2, _U3& __u3, _U4& __u4, _U5& __u5, _U6& __u6, _U7& __u7\n-#define _GLIBCXX_BIND_ARGS __u1, __u2, __u3, __u4, __u5, __u6, __u7\n-#include _GLIBCXX_BIND_REPEAT_HEADER\n-#undef _GLIBCXX_BIND_ARGS\n-#undef _GLIBCXX_BIND_PARAMS\n-#undef _GLIBCXX_BIND_TEMPLATE_ARGS\n-#undef _GLIBCXX_BIND_TEMPLATE_PARAMS\n-#undef _GLIBCXX_BIND_COMMA\n-#undef _GLIBCXX_BIND_NUM_ARGS\n-\n-#define _GLIBCXX_BIND_NUM_ARGS 8\n-#define _GLIBCXX_BIND_COMMA ,\n-#define _GLIBCXX_BIND_TEMPLATE_PARAMS typename _U1, typename _U2, typename _U3, typename _U4, typename _U5, typename _U6, typename _U7, typename _U8\n-#define _GLIBCXX_BIND_TEMPLATE_ARGS _U1, _U2, _U3, _U4, _U5, _U6, _U7, _U8\n-#define _GLIBCXX_BIND_PARAMS _U1& __u1, _U2& __u2, _U3& __u3, _U4& __u4, _U5& __u5, _U6& __u6, _U7& __u7, _U8& __u8\n-#define _GLIBCXX_BIND_ARGS __u1, __u2, __u3, __u4, __u5, __u6, __u7, __u8\n-#include _GLIBCXX_BIND_REPEAT_HEADER\n-#undef _GLIBCXX_BIND_ARGS\n-#undef _GLIBCXX_BIND_PARAMS\n-#undef _GLIBCXX_BIND_TEMPLATE_ARGS\n-#undef _GLIBCXX_BIND_TEMPLATE_PARAMS\n-#undef _GLIBCXX_BIND_COMMA\n-#undef _GLIBCXX_BIND_NUM_ARGS\n-\n-#define _GLIBCXX_BIND_NUM_ARGS 9\n-#define _GLIBCXX_BIND_COMMA ,\n-#define _GLIBCXX_BIND_TEMPLATE_PARAMS typename _U1, typename _U2, typename _U3, typename _U4, typename _U5, typename _U6, typename _U7, typename _U8, typename _U9\n-#define _GLIBCXX_BIND_TEMPLATE_ARGS _U1, _U2, _U3, _U4, _U5, _U6, _U7, _U8, _U9\n-#define _GLIBCXX_BIND_PARAMS _U1& __u1, _U2& __u2, _U3& __u3, _U4& __u4, _U5& __u5, _U6& __u6, _U7& __u7, _U8& __u8, _U9& __u9\n-#define _GLIBCXX_BIND_ARGS __u1, __u2, __u3, __u4, __u5, __u6, __u7, __u8, __u9\n-#include _GLIBCXX_BIND_REPEAT_HEADER\n-#undef _GLIBCXX_BIND_ARGS\n-#undef _GLIBCXX_BIND_PARAMS\n-#undef _GLIBCXX_BIND_TEMPLATE_ARGS\n-#undef _GLIBCXX_BIND_TEMPLATE_PARAMS\n-#undef _GLIBCXX_BIND_COMMA\n-#undef _GLIBCXX_BIND_NUM_ARGS\n-\n-#define _GLIBCXX_BIND_NUM_ARGS 10\n-#define _GLIBCXX_BIND_COMMA ,\n-#define _GLIBCXX_BIND_TEMPLATE_PARAMS typename _U1, typename _U2, typename _U3, typename _U4, typename _U5, typename _U6, typename _U7, typename _U8, typename _U9, typename _U10\n-#define _GLIBCXX_BIND_TEMPLATE_ARGS _U1, _U2, _U3, _U4, _U5, _U6, _U7, _U8, _U9, _U10\n-#define _GLIBCXX_BIND_PARAMS _U1& __u1, _U2& __u2, _U3& __u3, _U4& __u4, _U5& __u5, _U6& __u6, _U7& __u7, _U8& __u8, _U9& __u9, _U10& __u10\n-#define _GLIBCXX_BIND_ARGS __u1, __u2, __u3, __u4, __u5, __u6, __u7, __u8, __u9, __u10\n-#include _GLIBCXX_BIND_REPEAT_HEADER\n-#undef _GLIBCXX_BIND_ARGS\n-#undef _GLIBCXX_BIND_PARAMS\n-#undef _GLIBCXX_BIND_TEMPLATE_ARGS\n-#undef _GLIBCXX_BIND_TEMPLATE_PARAMS\n-#undef _GLIBCXX_BIND_COMMA\n-#undef _GLIBCXX_BIND_NUM_ARGS\n-"}, {"sha": "897d48751ff050738770d21564b53d7e796adb79", "filename": "libstdc++-v3/include/tr1/functional", "status": "modified", "additions": 1191, "deletions": 30, "changes": 1221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eeea7612d055f00ce21fd1442411c838d82b452/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eeea7612d055f00ce21fd1442411c838d82b452/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional?ref=9eeea7612d055f00ce21fd1442411c838d82b452", "patch": "@@ -110,6 +110,83 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n     {\n     };\n \n+  /**\n+   * @if maint\n+   * Retrieve the result type for a function type.\n+   * @endif \n+   */\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(_ArgTypes...)>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Retrieve the result type for a function reference.\n+   * @endif \n+   */\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Retrieve the result type for a function pointer.\n+   * @endif \n+   */\n+  template<typename _Res, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Retrieve result type for a member function pointer.\n+   * @endif maint\n+   */ \n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Retrieve result type for a const member function pointer.\n+   * @endif maint\n+   */ \n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Retrieve result type for a volatile member function pointer.\n+   * @endif maint\n+   */ \n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Retrieve result type for a const volatile member function pointer.\n+   * @endif maint\n+   */ \n+  template<typename _Res, typename _Class, typename... _ArgTypes> \n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)const volatile>\n+    {\n+      typedef _Res result_type;\n+    };\n+\n   /**\n    *  @if maint\n    *  Strip top-level cv-qualifiers from the function object and let\n@@ -144,6 +221,56 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n                 ::template _Result_type<_T1>::type type;\n     };\n \n+  /**\n+   * @if maint\n+   * Determine whether we can determine a result type from @c Functor \n+   * alone.\n+   * @endif\n+   */ \n+  template<typename _Functor, typename... _ArgTypes>\n+    class result_of<_Functor(_ArgTypes...)>\n+      : public _Result_of_impl<\n+                 _Has_result_type<_Weak_result_type<_Functor> >::value,\n+                 _Functor(_ArgTypes...)>\n+    {\n+    };\n+\n+  /**\n+   * @if maint\n+   * We already know the result type for @c Functor; use it.\n+   * @endif\n+   */\n+  template<typename _Functor, typename... _ArgTypes>\n+    struct _Result_of_impl<true, _Functor(_ArgTypes...)>\n+    {\n+      typedef typename _Weak_result_type<_Functor>::result_type type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * We need to compute the result type for this invocation the hard \n+   * way.\n+   * @endif\n+   */\n+  template<typename _Functor, typename... _ArgTypes>\n+    struct _Result_of_impl<false, _Functor(_ArgTypes...)>\n+    {\n+      typedef typename _Functor\n+                ::template result<_Functor(_ArgTypes...)>::type type;\n+    };\n+\n+  /**\n+   * @if maint\n+   * It is unsafe to access ::result when there are zero arguments, so we \n+   * return @c void instead.\n+   * @endif\n+   */\n+  template<typename _Functor>\n+    struct _Result_of_impl<false, _Functor()>\n+    {\n+      typedef void type;\n+    };\n+\n   /**\n    *  @if maint\n    *  Determines if the type _Tp derives from unary_function.\n@@ -201,6 +328,51 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n       typedef _Tp* type;\n     };\n \n+  /**\n+   * @if maint\n+   * Invoke a function object, which may be either a member pointer or a\n+   * function object. The first parameter will tell which.\n+   * @endif\n+   */\n+  template<typename _Functor, typename... _Args>\n+    inline\n+    typename __gnu_cxx::__enable_if<\n+               (!is_member_pointer<_Functor>::value\n+                && !is_function<_Functor>::value\n+                && !is_function<typename remove_pointer<_Functor>::type>::value),\n+               typename result_of<_Functor(_Args...)>::type\n+             >::__type\n+    __invoke(_Functor& __f, _Args&... __args)\n+    {\n+      return __f(__args...);\n+    }\n+\n+  template<typename _Functor, typename... _Args>\n+    inline\n+    typename __gnu_cxx::__enable_if<\n+               (is_member_pointer<_Functor>::value\n+                && !is_function<_Functor>::value\n+                && !is_function<typename remove_pointer<_Functor>::type>::value),\n+               typename result_of<_Functor(_Args...)>::type\n+             >::__type\n+    __invoke(_Functor& __f, _Args&... __args)\n+    {\n+      return mem_fn(__f)(__args...);\n+    }\n+\n+  // To pick up function references (that will become function pointers)\n+  template<typename _Functor, typename... _Args>\n+    inline\n+    typename __gnu_cxx::__enable_if<\n+               (is_pointer<_Functor>::value\n+                && is_function<typename remove_pointer<_Functor>::type>::value),\n+               typename result_of<_Functor(_Args...)>::type\n+             >::__type\n+    __invoke(_Functor __f, _Args&... __args)\n+    {\n+      return __f(__args...);\n+    }\n+\n   /**\n    *  @if maint\n    *  Knowing which of unary_function and binary_function _Tp derives\n@@ -366,9 +538,12 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n       get() const\n       { return *_M_data; }\n \n-#define _GLIBCXX_REPEAT_HEADER <tr1/ref_wrap_iterate.h>\n-#include <tr1/repeat.h>\n-#undef _GLIBCXX_REPEAT_HEADER\n+      template<typename... _Args>\n+      typename result_of<_M_func_type(_Args...)>::type\n+      operator()(_Args&... __args) const\n+      {\n+        return __invoke(get(), __args...);\n+      }\n     };\n \n \n@@ -406,6 +581,216 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n         typedef _Tp& type;\n       };\n \n+  /**\n+   * @if maint\n+   * Derives from @c unary_function or @c binary_function, or perhaps\n+   * nothing, depending on the number of arguments provided. The\n+   * primary template is the basis case, which derives nothing.\n+   * @endif maint\n+   */\n+   template<typename _Res, typename... _ArgTypes> \n+     struct _Maybe_unary_or_binary_function { };\n+\n+  /**\n+   * @if maint\n+   * Derives from @c unary_function, as appropriate.\n+   * @endif\n+   */ \n+   template<typename _Res, typename _T1> \n+     struct _Maybe_unary_or_binary_function<_Res, _T1>\n+      : std::unary_function<_T1, _Res> { };\n+\n+  /**\n+   * @if maint\n+   * Derives from @c binary_function, as appropriate.\n+   * @endif\n+   */ \n+   template<typename _Res, typename _T1, typename _T2> \n+     struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>\n+      : std::binary_function<_T1, _T2, _Res> { };\n+\n+  /**\n+   * @if maint\n+   * Implementation of @c mem_fn for member function pointers.\n+   * @endif\n+   */\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    class _Mem_fn<_Res (_Class::*)(_ArgTypes...)>\n+      : public _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>\n+    {\n+      typedef _Res (_Class::*_Functor)(_ArgTypes...);\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __object, const volatile _Class *, \n+                _ArgTypes... __args) const\n+        { return (__object.*__pmf)(__args...); }\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+        { return ((*__ptr).*__pmf)(__args...); }\n+\n+    public:\n+      typedef _Res result_type;\n+\n+      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+      // Handle objects\n+      _Res operator()(_Class& __object, _ArgTypes... __args) const\n+      { return (__object.*__pmf)(__args...); }\n+\n+      // Handle pointers\n+      _Res operator()(_Class* __object, _ArgTypes... __args) const\n+      { return (__object->*__pmf)(__args...); }\n+\n+      // Handle smart pointers, references and pointers to derived\n+      template<typename _Tp>\n+        _Res operator()(_Tp& __object, _ArgTypes... __args) const\n+        { return _M_call(__object, &__object, __args...); }\n+\n+    private:\n+      _Functor __pmf;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Implementation of @c mem_fn for const member function pointers.\n+   * @endif\n+   */\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const>\n+      : public _Maybe_unary_or_binary_function<_Res, const _Class*, \n+                                               _ArgTypes...>\n+    {\n+      typedef _Res (_Class::*_Functor)(_ArgTypes...) const;\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __object, const volatile _Class *, \n+                _ArgTypes... __args) const\n+        { return (__object.*__pmf)(__args...); }\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+        { return ((*__ptr).*__pmf)(__args...); }\n+\n+    public:\n+      typedef _Res result_type;\n+\n+      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+      // Handle objects\n+      _Res operator()(const _Class& __object, _ArgTypes... __args) const\n+      { return (__object.*__pmf)(__args...); }\n+\n+      // Handle pointers\n+      _Res operator()(const _Class* __object, _ArgTypes... __args) const\n+      { return (__object->*__pmf)(__args...); }\n+\n+      // Handle smart pointers, references and pointers to derived\n+      template<typename _Tp>\n+        _Res operator()(_Tp& __object, _ArgTypes... __args) const\n+        { return _M_call(__object, &__object, __args...); }\n+\n+    private:\n+      _Functor __pmf;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Implementation of @c mem_fn for volatile member function pointers.\n+   * @endif\n+   */\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) volatile>\n+      : public _Maybe_unary_or_binary_function<_Res, volatile _Class*, \n+                                               _ArgTypes...>\n+    {\n+      typedef _Res (_Class::*_Functor)(_ArgTypes...) volatile;\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __object, const volatile _Class *, \n+                _ArgTypes... __args) const\n+        { return (__object.*__pmf)(__args...); }\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+        { return ((*__ptr).*__pmf)(__args...); }\n+\n+    public:\n+      typedef _Res result_type;\n+\n+      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+      // Handle objects\n+      _Res operator()(volatile _Class& __object, _ArgTypes... __args) const\n+      { return (__object.*__pmf)(__args...); }\n+\n+      // Handle pointers\n+      _Res operator()(volatile _Class* __object, _ArgTypes... __args) const\n+      { return (__object->*__pmf)(__args...); }\n+\n+      // Handle smart pointers, references and pointers to derived\n+      template<typename _Tp>\n+        _Res operator()(_Tp& __object, _ArgTypes... __args) const\n+        { return _M_call(__object, &__object, __args...); }\n+\n+    private:\n+      _Functor __pmf;\n+    };\n+\n+  /**\n+   * @if maint\n+   * Implementation of @c mem_fn for const volatile member function pointers.\n+   * @endif\n+   */\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const volatile>\n+      : public _Maybe_unary_or_binary_function<_Res, const volatile _Class*, \n+                                               _ArgTypes...>\n+    {\n+      typedef _Res (_Class::*_Functor)(_ArgTypes...) const volatile;\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __object, const volatile _Class *, \n+                _ArgTypes... __args) const\n+        { return (__object.*__pmf)(__args...); }\n+\n+      template<typename _Tp>\n+        _Res\n+        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+        { return ((*__ptr).*__pmf)(__args...); }\n+\n+    public:\n+      typedef _Res result_type;\n+\n+      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n+\n+      // Handle objects\n+      _Res \n+      operator()(const volatile _Class& __object, _ArgTypes... __args) const\n+      { return (__object.*__pmf)(__args...); }\n+\n+      // Handle pointers\n+      _Res \n+      operator()(const volatile _Class* __object, _ArgTypes... __args) const\n+      { return (__object->*__pmf)(__args...); }\n+\n+      // Handle smart pointers, references and pointers to derived\n+      template<typename _Tp>\n+        _Res operator()(_Tp& __object, _ArgTypes... __args) const\n+        { return _M_call(__object, &__object, __args...); }\n+\n+    private:\n+      _Functor __pmf;\n+    };\n+\n+\n   template<typename _Res, typename _Class>\n   class _Mem_fn<_Res _Class::*>\n   {\n@@ -537,6 +922,41 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n    */\n   template<int _Num> struct _Placeholder { };\n \n+  // Define a large number of placeholders. There is no way to\n+  // simplify this with variadic templates, because we're introducing\n+  // unique names for each.\n+  namespace placeholders { namespace {\n+    _Placeholder<1> _1;\n+    _Placeholder<2> _2;\n+    _Placeholder<3> _3;\n+    _Placeholder<4> _4;\n+    _Placeholder<5> _5;\n+    _Placeholder<6> _6;\n+    _Placeholder<7> _7;\n+    _Placeholder<8> _8;\n+    _Placeholder<9> _9;\n+    _Placeholder<10> _10;\n+    _Placeholder<11> _11;\n+    _Placeholder<12> _12;\n+    _Placeholder<13> _13;\n+    _Placeholder<14> _14;\n+    _Placeholder<15> _15;\n+    _Placeholder<16> _16;\n+    _Placeholder<17> _17;\n+    _Placeholder<18> _18;\n+    _Placeholder<19> _19;\n+    _Placeholder<20> _20;\n+    _Placeholder<21> _21;\n+    _Placeholder<22> _22;\n+    _Placeholder<23> _23;\n+    _Placeholder<24> _24;\n+    _Placeholder<25> _25;\n+    _Placeholder<26> _26;\n+    _Placeholder<27> _27;\n+    _Placeholder<28> _28;\n+    _Placeholder<29> _29;\n+  } }\n+\n   /**\n    *  @if maint\n    *  Partial specialization of is_placeholder that provides the placeholder\n@@ -550,6 +970,79 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n   template<int _Num>\n     const int is_placeholder<_Placeholder<_Num> >::value;\n \n+  /**\n+   * @if maint\n+   * Stores a tuple of indices. Used by bind() to extract the elements\n+   * in a tuple. \n+   * @endif\n+   */\n+  template<int... Indexes>\n+    struct _Index_tuple { };\n+\n+  /**\n+   *  @if maint\n+   *  Builds an _Index_tuple<0, 1, 2, ..., _Num-1>.\n+   *  @endif\n+   */\n+  template<std::size_t _Num, typename _Tuple = _Index_tuple<> >\n+  struct _Build_index_tuple;\n+ \n+  template<std::size_t _Num, int... _Indexes> \n+  struct _Build_index_tuple<_Num, _Index_tuple<_Indexes...> >\n+    : _Build_index_tuple<_Num - 1, \n+                         _Index_tuple<_Indexes..., sizeof...(_Indexes)> >\n+  {\n+  };\n+\n+  template<int... _Indexes>\n+  struct _Build_index_tuple<0, _Index_tuple<_Indexes...> >\n+  {\n+    typedef _Index_tuple<_Indexes...> __type;\n+  };\n+\n+  /** \n+   * @if maint\n+   * Used by _Safe_tuple_element to indicate that there is no tuple\n+   * element at this position.\n+   * @endif\n+   */\n+  struct _No_tuple_element;\n+\n+  /**\n+   * @if maint\n+   * Implementation helper for _Safe_tuple_element. This primary\n+   * template handles the case where it is safe to use @c\n+   * tuple_element.\n+   * @endif\n+   */\n+  template<int __i, typename _Tuple, bool _IsSafe>\n+    struct _Safe_tuple_element_impl\n+      : tuple_element<__i, _Tuple> { };\n+\n+  /**\n+   * @if maint\n+   * Implementation helper for _Safe_tuple_element. This partial\n+   * specialization handles the case where it is not safe to use @c\n+   * tuple_element. We just return @c _No_tuple_element.\n+   * @endif\n+   */\n+  template<int __i, typename _Tuple>\n+    struct _Safe_tuple_element_impl<__i, _Tuple, false>\n+    {\n+      typedef _No_tuple_element type;\n+    };\n+\n+  /**\n+   * Like tuple_element, but returns @c _No_tuple_element when\n+   * tuple_element would return an error.\n+   */\n+ template<int __i, typename _Tuple>\n+   struct _Safe_tuple_element\n+     : _Safe_tuple_element_impl<__i, _Tuple, \n+                                (__i >= 0 && __i < tuple_size<_Tuple>::value)>\n+   {\n+   };\n+\n   /**\n    *  @if maint\n    *  Maps an argument to bind() into an actual argument to the bound\n@@ -603,9 +1096,33 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n     public:\n       template<typename _Signature> class result;\n \n-#define _GLIBCXX_REPEAT_HEADER <tr1/mu_iterate.h>\n-#  include <tr1/repeat.h>\n-#undef _GLIBCXX_REPEAT_HEADER\n+      // Determine the result type when we pass the arguments along. This\n+      // involves passing along the cv-qualifiers placed on _Mu and\n+      // unwrapping the argument bundle.\n+      template<typename _CVMu, typename _CVArg, typename... _Args>\n+      class result<_CVMu(_CVArg, tuple<_Args...>)>\n+        : public result_of<_CVArg(_Args...)> { };\n+\n+      template<typename _CVArg, typename... _Args>\n+      typename result_of<_CVArg(_Args...)>::type\n+      operator()(_CVArg& __arg, const tuple<_Args...>& __tuple)\n+        const volatile\n+      {\n+        // Construct an index tuple and forward to __call\n+        typedef typename _Build_index_tuple<sizeof...(_Args)>::__type _Indexes;\n+        return this->__call(__arg, __tuple, _Indexes());\n+      }     \n+\n+    private:\n+      // Invokes the underlying function object __arg by unpacking all\n+      // of the arguments in the tuple. \n+      template<typename _CVArg, typename... _Args, int... _Indexes>\n+      typename result_of<_CVArg(_Args...)>::type\n+      __call(_CVArg& __arg, const tuple<_Args...>& __tuple,\n+             const _Index_tuple<_Indexes...>&) const volatile\n+      {\n+        return __arg(_GLIBCXX_TR1::get<_Indexes>(__tuple)...);\n+      }\n     };\n \n   /**\n@@ -627,8 +1144,8 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n         // Add a reference, if it hasn't already been done for us.\n         // This allows us to be a little bit sloppy in constructing\n         // the tuple that we pass to result_of<...>.\n-        typedef typename tuple_element<(is_placeholder<_Arg>::value - 1),\n-                                       _Tuple>::type __base_type;\n+        typedef typename _Safe_tuple_element<(is_placeholder<_Arg>::value - 1),\n+                                             _Tuple>::type __base_type;\n \n       public:\n         typedef typename add_reference<__base_type>::type type;\n@@ -700,23 +1217,226 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n    *  Type of the function object returned from bind().\n    *  @endif\n    */\n-   template<typename _Signature>\n-     struct _Bind;\n+  template<typename _Signature>\n+    struct _Bind;\n+\n+   template<typename _Functor, typename... _Bound_args>\n+    class _Bind<_Functor(_Bound_args...)>\n+      : public _Weak_result_type<_Functor>\n+    {\n+      typedef _Bind __self_type;\n+      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type \n+        _Bound_indexes;\n+\n+      _Functor _M_f;\n+      tuple<_Bound_args...> _M_bound_args;\n+\n+      // Call unqualified\n+      template<typename... _Args, int... _Indexes>\n+        typename result_of<\n+                   _Functor(typename result_of<_Mu<_Bound_args> \n+                            (_Bound_args, tuple<_Args...>)>::type...)\n+                 >::type\n+        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>)\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (_GLIBCXX_TR1::get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as const\n+      template<typename... _Args, int... _Indexes>\n+        typename result_of<\n+                   const _Functor(typename result_of<_Mu<_Bound_args> \n+                                    (const _Bound_args, tuple<_Args...>)\n+                                  >::type...)>::type\n+        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>) const\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (_GLIBCXX_TR1::get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as volatile\n+      template<typename... _Args, int... _Indexes>\n+        typename result_of<\n+                   volatile _Functor(typename result_of<_Mu<_Bound_args> \n+                                    (volatile _Bound_args, tuple<_Args...>)\n+                                  >::type...)>::type\n+        __call(const tuple<_Args...>& __args, \n+               _Index_tuple<_Indexes...>) volatile\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (_GLIBCXX_TR1::get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as const volatile\n+      template<typename... _Args, int... _Indexes>\n+        typename result_of<\n+                   const volatile _Functor(typename result_of<_Mu<_Bound_args> \n+                                    (const volatile _Bound_args, \n+                                     tuple<_Args...>)\n+                                  >::type...)>::type\n+        __call(const tuple<_Args...>& __args, \n+               _Index_tuple<_Indexes...>) const volatile\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (_GLIBCXX_TR1::get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+     public:\n+      explicit _Bind(_Functor __f, _Bound_args... __bound_args)\n+        : _M_f(__f), _M_bound_args(__bound_args...) { }\n+\n+      // Call unqualified\n+      template<typename... _Args>\n+        typename result_of<\n+                   _Functor(typename result_of<_Mu<_Bound_args> \n+                            (_Bound_args, tuple<_Args...>)>::type...)\n+                 >::type\n+        operator()(_Args&... __args)\n+        {\n+          return this->__call(_GLIBCXX_TR1::tie(__args...), _Bound_indexes());\n+        }\n+\n+      // Call as const\n+      template<typename... _Args>\n+        typename result_of<\n+                   const _Functor(typename result_of<_Mu<_Bound_args> \n+                            (const _Bound_args, tuple<_Args...>)>::type...)\n+                 >::type\n+        operator()(_Args&... __args) const\n+        {\n+          return this->__call(_GLIBCXX_TR1::tie(__args...), _Bound_indexes());\n+        }\n+\n+\n+      // Call as volatile\n+      template<typename... _Args>\n+        typename result_of<\n+                   volatile _Functor(typename result_of<_Mu<_Bound_args> \n+                            (volatile _Bound_args, tuple<_Args...>)>::type...)\n+                 >::type\n+        operator()(_Args&... __args) volatile\n+        {\n+          return this->__call(_GLIBCXX_TR1::tie(__args...), _Bound_indexes());\n+        }\n+\n+\n+      // Call as const volatile\n+      template<typename... _Args>\n+        typename result_of<\n+                   const volatile _Functor(typename result_of<_Mu<_Bound_args> \n+                            (const volatile _Bound_args, \n+                             tuple<_Args...>)>::type...)\n+                 >::type\n+        operator()(_Args&... __args) const volatile\n+        {\n+          return this->__call(_GLIBCXX_TR1::tie(__args...), _Bound_indexes());\n+        }\n+    };\n \n   /**\n    *  @if maint\n    *  Type of the function object returned from bind<R>().\n    *  @endif\n    */\n-   template<typename _Result, typename _Signature>\n-     struct _Bind_result;\n+  template<typename _Result, typename _Signature>\n+    struct _Bind_result;\n+\n+  template<typename _Result, typename _Functor, typename... _Bound_args>\n+    class _Bind_result<_Result, _Functor(_Bound_args...)>\n+    {\n+      typedef _Bind_result __self_type;\n+      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type \n+        _Bound_indexes;\n+\n+      _Functor _M_f;\n+      tuple<_Bound_args...> _M_bound_args;\n+\n+      // Call unqualified\n+      template<typename... _Args, int... _Indexes>\n+        _Result\n+        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>)\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (_GLIBCXX_TR1::get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as const\n+      template<typename... _Args, int... _Indexes>\n+        _Result\n+        __call(const tuple<_Args...>& __args, _Index_tuple<_Indexes...>) const\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (_GLIBCXX_TR1::get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as volatile\n+      template<typename... _Args, int... _Indexes>\n+        _Result\n+        __call(const tuple<_Args...>& __args, \n+               _Index_tuple<_Indexes...>) volatile\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (_GLIBCXX_TR1::get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+      // Call as const volatile\n+      template<typename... _Args, int... _Indexes>\n+        _Result\n+        __call(const tuple<_Args...>& __args, \n+               _Index_tuple<_Indexes...>) const volatile\n+        {\n+          return _M_f(_Mu<_Bound_args>()\n+                      (_GLIBCXX_TR1::get<_Indexes>(_M_bound_args), __args)...);\n+        }\n+\n+     public:\n+      typedef _Result result_type;\n+\n+      explicit _Bind_result(_Functor __f, _Bound_args... __bound_args)\n+        : _M_f(__f), _M_bound_args(__bound_args...) { }\n+\n+      // Call unqualified\n+      template<typename... _Args>\n+        result_type\n+        operator()(_Args&... __args)\n+        {\n+          return this->__call(_GLIBCXX_TR1::tie(__args...), _Bound_indexes());\n+        }\n+\n+      // Call as const\n+      template<typename... _Args>\n+        result_type\n+        operator()(_Args&... __args) const\n+        {\n+          return this->__call(_GLIBCXX_TR1::tie(__args...), _Bound_indexes());\n+        }\n+\n+\n+      // Call as volatile\n+      template<typename... _Args>\n+        result_type\n+        operator()(_Args&... __args) volatile\n+        {\n+          return this->__call(_GLIBCXX_TR1::tie(__args...), _Bound_indexes());\n+        }\n+\n+\n+      // Call as const volatile\n+      template<typename... _Args>\n+        result_type\n+        operator()(_Args&... __args) const volatile\n+        {\n+          return this->__call(_GLIBCXX_TR1::tie(__args...), _Bound_indexes());\n+        }\n+    };\n \n   /**\n    *  @if maint\n    *  Class template _Bind is always a bind expression.\n    *  @endif\n    */\n-   template<typename _Signature>\n+  template<typename _Signature>\n      struct is_bind_expression<_Bind<_Signature> >\n      { static const bool value = true; };\n \n@@ -728,9 +1448,36 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n    *  Class template _Bind_result is always a bind expression.\n    *  @endif\n    */\n-   template<typename _Result, typename _Signature>\n-     struct is_bind_expression<_Bind_result<_Result, _Signature> >\n-     { static const bool value = true; };\n+  template<typename _Result, typename _Signature>\n+    struct is_bind_expression<_Bind_result<_Result, _Signature> >\n+    {\n+      static const bool value = true;\n+    };\n+\n+  template<typename _Functor, typename... _ArgTypes>\n+    inline\n+    _Bind<typename _Maybe_wrap_member_pointer<_Functor>::type(_ArgTypes...)>\n+    bind(_Functor __f, _ArgTypes... __args)\n+    {\n+      typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n+      typedef typename __maybe_type::type __functor_type;\n+      typedef _Bind<__functor_type(_ArgTypes...)> __result_type;\n+      return __result_type(__maybe_type::__do_wrap(__f), __args...);\n+    } \n+\n+  template<typename _Result, typename _Functor, typename... _ArgTypes>\n+  inline\n+  _Bind_result<_Result,\n+               typename _Maybe_wrap_member_pointer<_Functor>::type\n+                          (_ArgTypes...)>\n+  bind(_Functor __f, _ArgTypes... __args)\n+  {\n+    typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n+    typedef typename __maybe_type::type __functor_type;\n+    typedef _Bind_result<_Result, __functor_type(_ArgTypes...)>\n+      __result_type;\n+    return __result_type(__maybe_type::__do_wrap(__f), __args...);\n+  } \n \n    template<typename _Result, typename _Signature>\n      const bool is_bind_expression<_Bind_result<_Result, _Signature> >::value;\n@@ -829,13 +1576,9 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n     __callable_functor(_Member _Class::* const &__p)\n     { return mem_fn(__p); }\n \n-  template<typename _Signature, typename _Functor>\n-    class _Function_handler;\n-\n   template<typename _Signature>\n     class function;\n \n-\n   /**\n    *  @if maint\n    *  Base class of all polymorphic function object wrappers.\n@@ -1026,6 +1769,434 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n     _Manager_type _M_manager;\n   };\n \n+  template<typename _Signature, typename _Functor>\n+    class _Function_handler;\n+\n+  template<typename _Res, typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<_Res(_ArgTypes...), _Functor>\n+      : public _Function_base::_Base_manager<_Functor>\n+    {\n+      typedef _Function_base::_Base_manager<_Functor> _Base;\n+\n+    public:\n+      static _Res _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        return (*_Base::_M_get_pointer(__functor))(__args...);\n+      }\n+    };\n+\n+  template<typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<void(_ArgTypes...), _Functor>\n+      : public _Function_base::_Base_manager<_Functor>\n+    {\n+      typedef _Function_base::_Base_manager<_Functor> _Base;\n+\n+     public:\n+      static void _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        (*_Base::_M_get_pointer(__functor))(__args...);\n+      }\n+    };\n+\n+  template<typename _Res, typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >\n+      : public _Function_base::_Ref_manager<_Functor>\n+    {\n+      typedef _Function_base::_Ref_manager<_Functor> _Base;\n+\n+     public:\n+      static _Res _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        return \n+          __callable_functor(**_Base::_M_get_pointer(__functor))(__args...);\n+      }\n+    };\n+\n+  template<typename _Functor, typename... _ArgTypes>\n+    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >\n+      : public _Function_base::_Ref_manager<_Functor>\n+    {\n+      typedef _Function_base::_Ref_manager<_Functor> _Base;\n+\n+     public:\n+      static void _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        __callable_functor(**_Base::_M_get_pointer(__functor))(__args...);\n+      }\n+    };\n+\n+  template<typename _Class, typename _Member, typename _Res, \n+           typename... _ArgTypes>\n+    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>\n+      : public _Function_handler<void(_ArgTypes...), _Member _Class::*>\n+    {\n+      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>\n+        _Base;\n+\n+     public:\n+      static _Res _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        return _GLIBCXX_TR1::mem_fn(_Base::_M_get_pointer(__functor)->__value)(__args...);\n+      }\n+    };\n+\n+  template<typename _Class, typename _Member, typename... _ArgTypes>\n+    class _Function_handler<void(_ArgTypes...), _Member _Class::*>\n+      : public _Function_base::_Base_manager<\n+                 _Simple_type_wrapper< _Member _Class::* > >\n+    {\n+      typedef _Member _Class::* _Functor;\n+      typedef _Simple_type_wrapper< _Functor > _Wrapper;\n+      typedef _Function_base::_Base_manager<_Wrapper> _Base;\n+\n+     public:\n+      static bool\n+      _M_manager(_Any_data& __dest, const _Any_data& __source,\n+                 _Manager_operation __op)\n+      {\n+        switch (__op) {\n+        case __get_type_info:\n+          __dest._M_access<const type_info*>() = &typeid(_Functor);\n+          break;\n+\n+        case __get_functor_ptr:\n+          __dest._M_access<_Functor*>() =\n+            &_Base::_M_get_pointer(__source)->__value;\n+          break;\n+\n+        default:\n+          _Base::_M_manager(__dest, __source, __op);\n+        }\n+        return false;\n+      }\n+\n+      static void _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n+      {\n+        _GLIBCXX_TR1::mem_fn(_Base::_M_get_pointer(__functor)->__value)(__args...);\n+      }\n+    };\n+\n+  template<typename _Res, typename... _ArgTypes>\n+  class function<_Res(_ArgTypes...)>\n+    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,\n+      private _Function_base\n+  {\n+    /**\n+     *  @if maint\n+     *  This class is used to implement the safe_bool idiom.\n+     *  @endif\n+     */\n+    struct _Hidden_type\n+    {\n+      _Hidden_type* _M_bool;\n+    };\n+\n+    /**\n+     *  @if maint\n+     *  This typedef is used to implement the safe_bool idiom.\n+     *  @endif\n+     */\n+    typedef _Hidden_type* _Hidden_type::* _Safe_bool;\n+\n+    typedef _Res _Signature_type(_ArgTypes...);\n+\n+    struct _Useless {};\n+\n+   public:\n+    typedef _Res result_type;\n+\n+    // [3.7.2.1] construct/copy/destroy\n+\n+    /**\n+     *  @brief Default construct creates an empty function call wrapper.\n+     *  @post @c !(bool)*this\n+     */\n+    function() : _Function_base() { }\n+\n+    /**\n+     *  @brief Default construct creates an empty function call wrapper.\n+     *  @post @c !(bool)*this\n+     */\n+    function(_M_clear_type*) : _Function_base() { }\n+\n+    /**\n+     *  @brief %Function copy constructor.\n+     *  @param x A %function object with identical call signature.\n+     *  @pre @c (bool)*this == (bool)x\n+     *\n+     *  The newly-created %function contains a copy of the target of @a\n+     *  x (if it has one).\n+     */\n+    function(const function& __x);\n+\n+    /**\n+     *  @brief Builds a %function that targets a copy of the incoming\n+     *  function object.\n+     *  @param f A %function object that is callable with parameters of\n+     *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n+     *  to @c Res.\n+     *\n+     *  The newly-created %function object will target a copy of @a\n+     *  f. If @a f is @c reference_wrapper<F>, then this function\n+     *  object will contain a reference to the function object @c\n+     *  f.get(). If @a f is a NULL function pointer or NULL\n+     *  pointer-to-member, the newly-created object will be empty.\n+     *\n+     *  If @a f is a non-NULL function pointer or an object of type @c\n+     *  reference_wrapper<F>, this function will not throw.\n+     */\n+    template<typename _Functor>\n+      function(_Functor __f,\n+               typename __gnu_cxx::__enable_if<\n+                         !is_integral<_Functor>::value, _Useless>::__type\n+                 = _Useless());\n+\n+    /**\n+     *  @brief %Function assignment operator.\n+     *  @param x A %function with identical call signature.\n+     *  @post @c (bool)*this == (bool)x\n+     *  @returns @c *this\n+     *\n+     *  The target of @a x is copied to @c *this. If @a x has no\n+     *  target, then @c *this will be empty.\n+     *\n+     *  If @a x targets a function pointer or a reference to a function\n+     *  object, then this operation will not throw an exception.\n+     */\n+    function& operator=(const function& __x)\n+      {\n+        function(__x).swap(*this);\n+        return *this;\n+      }\n+\n+    /**\n+     *  @brief %Function assignment to zero.\n+     *  @post @c !(bool)*this\n+     *  @returns @c *this\n+     *\n+     *  The target of @a *this is deallocated, leaving it empty.\n+     */\n+    function& operator=(_M_clear_type*)\n+      {\n+        if (_M_manager) {\n+          _M_manager(_M_functor, _M_functor, __destroy_functor);\n+          _M_manager = 0;\n+          _M_invoker = 0;\n+        }\n+        return *this;\n+      }\n+\n+    /**\n+     *  @brief %Function assignment to a new target.\n+     *  @param f A %function object that is callable with parameters of\n+     *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n+     *  to @c Res.\n+     *  @return @c *this\n+     *\n+     *  This  %function object wrapper will target a copy of @a\n+     *  f. If @a f is @c reference_wrapper<F>, then this function\n+     *  object will contain a reference to the function object @c\n+     *  f.get(). If @a f is a NULL function pointer or NULL\n+     *  pointer-to-member, @c this object will be empty.\n+     *\n+     *  If @a f is a non-NULL function pointer or an object of type @c\n+     *  reference_wrapper<F>, this function will not throw.\n+     */\n+    template<typename _Functor>\n+      typename __gnu_cxx::__enable_if<!is_integral<_Functor>::value,\n+                                      function&>::__type\n+      operator=(_Functor __f)\n+      {\n+        function(__f).swap(*this);\n+        return *this;\n+      }\n+\n+    // [3.7.2.2] function modifiers\n+\n+    /**\n+     *  @brief Swap the targets of two %function objects.\n+     *  @param f A %function with identical call signature.\n+     *\n+     *  Swap the targets of @c this function object and @a f. This\n+     *  function will not throw an exception.\n+     */\n+    void swap(function& __x)\n+    {\n+      _Any_data __old_functor = _M_functor;\n+      _M_functor = __x._M_functor;\n+      __x._M_functor = __old_functor;\n+      _Manager_type __old_manager = _M_manager;\n+      _M_manager = __x._M_manager;\n+      __x._M_manager = __old_manager;\n+      _Invoker_type __old_invoker = _M_invoker;\n+      _M_invoker = __x._M_invoker;\n+      __x._M_invoker = __old_invoker;\n+    }\n+\n+    // [3.7.2.3] function capacity\n+\n+    /**\n+     *  @brief Determine if the %function wrapper has a target.\n+     *\n+     *  @return @c true when this %function object contains a target,\n+     *  or @c false when it is empty.\n+     *\n+     *  This function will not throw an exception.\n+     */\n+    operator _Safe_bool() const\n+      {\n+        if (_M_empty())\n+          {\n+            return 0;\n+          }\n+        else\n+          {\n+            return &_Hidden_type::_M_bool;\n+          }\n+      }\n+\n+    // [3.7.2.4] function invocation\n+\n+    /**\n+     *  @brief Invokes the function targeted by @c *this.\n+     *  @returns the result of the target.\n+     *  @throws bad_function_call when @c !(bool)*this\n+     *\n+     *  The function call operator invokes the target function object\n+     *  stored by @c this.\n+     */\n+    _Res operator()(_ArgTypes... __args) const;\n+\n+    // [3.7.2.5] function target access\n+    /**\n+     *  @brief Determine the type of the target of this function object\n+     *  wrapper.\n+     *\n+     *  @returns the type identifier of the target function object, or\n+     *  @c typeid(void) if @c !(bool)*this.\n+     *\n+     *  This function will not throw an exception.\n+     */\n+    const type_info& target_type() const;\n+\n+    /**\n+     *  @brief Access the stored target function object.\n+     *\n+     *  @return Returns a pointer to the stored target function object,\n+     *  if @c typeid(Functor).equals(target_type()); otherwise, a NULL\n+     *  pointer.\n+     *\n+     * This function will not throw an exception.\n+     */\n+    template<typename _Functor>       _Functor* target();\n+\n+    /**\n+     *  @overload\n+     */\n+    template<typename _Functor> const _Functor* target() const;\n+\n+   private:\n+    // [3.7.2.6] undefined operators\n+    template<typename _Function>\n+      void operator==(const function<_Function>&) const;\n+    template<typename _Function>\n+      void operator!=(const function<_Function>&) const;\n+\n+    typedef _Res (*_Invoker_type)(const _Any_data&, _ArgTypes...);\n+    _Invoker_type _M_invoker;\n+  };\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    function<_Res(_ArgTypes...)>::function(const function& __x)\n+      : _Function_base()\n+    {\n+      if (__x) {\n+        _M_invoker = __x._M_invoker;\n+        _M_manager = __x._M_manager;\n+        __x._M_manager(_M_functor, __x._M_functor, __clone_functor);\n+      }\n+    }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+  template<typename _Functor>\n+    function<_Res(_ArgTypes...)>\n+    ::function(_Functor __f,\n+               typename __gnu_cxx::__enable_if<\n+                         !is_integral<_Functor>::value, _Useless>::__type)\n+      : _Function_base()\n+  {\n+    typedef _Function_handler<_Signature_type, _Functor> _My_handler;\n+    if (_My_handler::_M_not_empty_function(__f)) {\n+      _M_invoker = &_My_handler::_M_invoke;\n+      _M_manager = &_My_handler::_M_manager;\n+      _My_handler::_M_init_functor(_M_functor, __f);\n+    }\n+  }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    _Res function<_Res(_ArgTypes...)>::operator()(_ArgTypes... __args) const\n+    {\n+      if (_M_empty())\n+        {\n+#if __EXCEPTIONS\n+          throw bad_function_call();\n+#else\n+          std::abort();\n+#endif\n+        }\n+      return _M_invoker(_M_functor, __args...);\n+    }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+    const type_info& function<_Res(_ArgTypes...)>::target_type() const\n+    {\n+      if (_M_manager)\n+        {\n+          _Any_data __typeinfo_result;\n+          _M_manager(__typeinfo_result, _M_functor, __get_type_info);\n+          return *__typeinfo_result._M_access<const type_info*>();\n+        }\n+      else\n+        {\n+          return typeid(void);\n+        }\n+    }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+  template<typename _Functor>\n+    _Functor* function<_Res(_ArgTypes...)>::target()\n+    {\n+      if (typeid(_Functor) == target_type() && _M_manager)\n+        {\n+          _Any_data __ptr;\n+          if (_M_manager(__ptr, _M_functor, __get_functor_ptr)\n+              && !is_const<_Functor>::value)\n+            return 0;\n+          else\n+            return __ptr._M_access<_Functor*>();\n+        }\n+      else\n+        {\n+          return 0;\n+        }\n+    }\n+\n+  template<typename _Res, typename... _ArgTypes>\n+  template<typename _Functor>\n+    const _Functor* function<_Res(_ArgTypes...)>::target() const\n+    {\n+      if (typeid(_Functor) == target_type() && _M_manager)\n+        {\n+          _Any_data __ptr;\n+          _M_manager(__ptr, _M_functor, __get_functor_ptr);\n+          return __ptr._M_access<const _Functor*>();\n+        }\n+      else\n+        {\n+          return 0;\n+        }\n+    }\n+\n   // [3.7.2.7] null pointer comparisons\n \n   /**\n@@ -1093,16 +2264,6 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n _GLIBCXX_END_NAMESPACE\n }\n \n-#define _GLIBCXX_JOIN(X,Y) _GLIBCXX_JOIN2( X , Y )\n-#define _GLIBCXX_JOIN2(X,Y) _GLIBCXX_JOIN3(X,Y)\n-#define _GLIBCXX_JOIN3(X,Y) X##Y\n-#define _GLIBCXX_REPEAT_HEADER <tr1/functional_iterate.h>\n-#include <tr1/repeat.h>\n-#undef _GLIBCXX_REPEAT_HEADER\n-#undef _GLIBCXX_JOIN3\n-#undef _GLIBCXX_JOIN2\n-#undef _GLIBCXX_JOIN\n-\n #include <tr1/functional_hash.h>\n \n #endif"}, {"sha": "3772e15c714a2efaf3499e9a32ee9b187ca74d26", "filename": "libstdc++-v3/include/tr1/functional_iterate.h", "status": "removed", "additions": 0, "deletions": 922, "changes": 922, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a85c8dd4854845630569bbec6437170c3bc246/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional_iterate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a85c8dd4854845630569bbec6437170c3bc246/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional_iterate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional_iterate.h?ref=d6a85c8dd4854845630569bbec6437170c3bc246", "patch": "@@ -1,922 +0,0 @@\n-// TR1 functional -*- C++ -*-\n-\n-// Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n-// Written by Douglas Gregor <doug.gregor -at- gmail.com>\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file tr1/functional_iterate.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-template<typename _Res _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-  struct _Weak_result_type_impl<_Res(_GLIBCXX_TEMPLATE_ARGS)>\n-  {\n-    typedef _Res result_type;\n-  };\n-\n-template<typename _Res _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-  struct _Weak_result_type_impl<_Res (&)(_GLIBCXX_TEMPLATE_ARGS)>\n-  {\n-    typedef _Res result_type;\n-  };\n-\n-template<typename _Res _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-  struct _Weak_result_type_impl<_Res (*)(_GLIBCXX_TEMPLATE_ARGS)>\n-  {\n-    typedef _Res result_type;\n-  };\n-\n-#if _GLIBCXX_NUM_ARGS > 0\n-template<typename _Res, typename _Class _GLIBCXX_COMMA_SHIFTED\n-         _GLIBCXX_TEMPLATE_PARAMS_SHIFTED>\n-  struct _Weak_result_type_impl<\n-           _Res (_Class::*)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED)>\n-  {\n-    typedef _Res result_type;\n-  };\n-\n-template<typename _Res, typename _Class _GLIBCXX_COMMA_SHIFTED\n-         _GLIBCXX_TEMPLATE_PARAMS_SHIFTED>\n-  struct _Weak_result_type_impl<\n-           _Res (_Class::*)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED) const>\n-  {\n-    typedef _Res result_type;\n-  };\n-\n-template<typename _Res, typename _Class _GLIBCXX_COMMA_SHIFTED\n-         _GLIBCXX_TEMPLATE_PARAMS_SHIFTED>\n-  struct _Weak_result_type_impl<\n-           _Res (_Class::*)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED) volatile>\n-  {\n-    typedef _Res result_type;\n-  };\n-\n-template<typename _Res, typename _Class _GLIBCXX_COMMA_SHIFTED\n-         _GLIBCXX_TEMPLATE_PARAMS_SHIFTED>\n-  struct _Weak_result_type_impl<\n-           _Res (_Class::*)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED) const volatile>\n-  {\n-    typedef _Res result_type;\n-  };\n-#endif\n-\n-template<typename _Functor _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-  class result_of<_Functor(_GLIBCXX_TEMPLATE_ARGS)>\n-    : public _Result_of_impl<\n-               _Has_result_type<_Weak_result_type<_Functor> >::value,\n-             _Functor(_GLIBCXX_TEMPLATE_ARGS)>\n-  { };\n-\n-template<typename _Functor _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-  struct _Result_of_impl<true, _Functor(_GLIBCXX_TEMPLATE_ARGS)>\n-  {\n-    typedef typename _Weak_result_type<_Functor>::result_type type;\n-  };\n-\n-template<typename _Functor _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-  struct _Result_of_impl<false, _Functor(_GLIBCXX_TEMPLATE_ARGS)>\n-  {\n-#if _GLIBCXX_NUM_ARGS > 0\n-    typedef typename _Functor\n-              ::template result<_Functor(_GLIBCXX_TEMPLATE_ARGS)>::type type;\n-#else\n-    typedef void type;\n-#endif\n-  };\n-\n-/**\n- * @if maint\n- * Invoke a function object, which may be either a member pointer or a\n- * function object. The first parameter will tell which.\n- * @endif\n- */\n-template<typename _Functor _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-  inline\n-  typename __gnu_cxx::__enable_if<(!is_member_pointer<_Functor>::value\n-\t\t\t&& !is_function<_Functor>::value\n-              && !is_function<typename remove_pointer<_Functor>::type>::value),\n-           typename result_of<_Functor(_GLIBCXX_TEMPLATE_ARGS)>::type>::__type\n-  __invoke(_Functor& __f _GLIBCXX_COMMA _GLIBCXX_REF_PARAMS)\n-  {\n-    return __f(_GLIBCXX_ARGS);\n-  }\n-\n-#if _GLIBCXX_NUM_ARGS > 0\n-template<typename _Functor _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-  inline\n-  typename __gnu_cxx::__enable_if<(is_member_pointer<_Functor>::value\n-\t\t\t&& !is_function<_Functor>::value\n-              && !is_function<typename remove_pointer<_Functor>::type>::value),\n-             typename result_of<_Functor(_GLIBCXX_TEMPLATE_ARGS)>::type\n-           >::__type\n-  __invoke(_Functor& __f _GLIBCXX_COMMA _GLIBCXX_REF_PARAMS)\n-  {\n-    return mem_fn(__f)(_GLIBCXX_ARGS);\n-  }\n-#endif\n-\n-// To pick up function references (that will become function pointers)\n-template<typename _Functor _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-  inline\n-  typename __gnu_cxx::__enable_if<(is_pointer<_Functor>::value\n-\t&& is_function<typename remove_pointer<_Functor>::type>::value),\n-             typename result_of<_Functor(_GLIBCXX_TEMPLATE_ARGS)>::type\n-           >::__type\n-  __invoke(_Functor __f _GLIBCXX_COMMA _GLIBCXX_REF_PARAMS)\n-  {\n-    return __f(_GLIBCXX_ARGS);\n-  }\n-\n-/**\n- * @if maint\n- * Implementation of reference_wrapper::operator()\n- * @endif\n-*/\n-#if _GLIBCXX_NUM_ARGS > 0\n-template<typename _Tp>\n-template<_GLIBCXX_TEMPLATE_PARAMS>\n-  typename result_of<\n-   typename reference_wrapper<_Tp>::_M_func_type(_GLIBCXX_TEMPLATE_ARGS)>::type\n-  reference_wrapper<_Tp>::operator()(_GLIBCXX_REF_PARAMS) const\n-  {\n-    return __invoke(get(), _GLIBCXX_ARGS);\n-  }\n-#endif\n-\n-#if _GLIBCXX_NUM_ARGS > 0\n-template<typename _Res, typename _Class _GLIBCXX_COMMA_SHIFTED\n-         _GLIBCXX_TEMPLATE_PARAMS_SHIFTED>\n-  class _Mem_fn<_Res (_Class::*)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED)>\n-#if _GLIBCXX_NUM_ARGS == 1\n-  : public unary_function<_Class*, _Res>\n-#elif _GLIBCXX_NUM_ARGS == 2\n-    : public binary_function<_Class*, _T1, _Res>\n-#endif\n-  {\n-    typedef _Res (_Class::*_Functor)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED);\n-\n-    template<typename _Tp>\n-      _Res\n-      _M_call(_Tp& __object, const volatile _Class * _GLIBCXX_COMMA_SHIFTED\n-              _GLIBCXX_PARAMS_SHIFTED) const\n-      { return (__object.*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n-\n-    template<typename _Tp>\n-      _Res\n-      _M_call(_Tp& __ptr, const volatile void * _GLIBCXX_COMMA_SHIFTED\n-              _GLIBCXX_PARAMS_SHIFTED) const\n-      {  return ((*__ptr).*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n-\n-  public:\n-    typedef _Res result_type;\n-\n-    explicit _Mem_fn(_Functor __pf) : __pmf(__pf) { }\n-\n-    // Handle objects\n-    _Res\n-    operator()(_Class& __object _GLIBCXX_COMMA_SHIFTED\n-               _GLIBCXX_PARAMS_SHIFTED) const\n-    { return (__object.*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n-\n-    // Handle pointers\n-    _Res\n-    operator()(_Class* __object _GLIBCXX_COMMA_SHIFTED\n-               _GLIBCXX_PARAMS_SHIFTED) const\n-    { return (__object->*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n-\n-    // Handle smart pointers, references and pointers to derived\n-    template<typename _Tp>\n-      _Res\n-      operator()(_Tp& __object _GLIBCXX_COMMA_SHIFTED\n-                 _GLIBCXX_PARAMS_SHIFTED) const\n-      {\n-        return _M_call(__object, &__object _GLIBCXX_COMMA_SHIFTED\n-                       _GLIBCXX_ARGS_SHIFTED);\n-      }\n-\n-  private:\n-    _Functor __pmf;\n-  };\n-\n-template<typename _Res, typename _Class _GLIBCXX_COMMA_SHIFTED\n-         _GLIBCXX_TEMPLATE_PARAMS_SHIFTED>\n-  class _Mem_fn<_Res (_Class::*)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED) const>\n-#if _GLIBCXX_NUM_ARGS == 1\n-  : public unary_function<const _Class*, _Res>\n-#elif _GLIBCXX_NUM_ARGS == 2\n-    : public binary_function<const _Class*, _T1, _Res>\n-#endif\n-  {\n-    typedef _Res (_Class::*_Functor)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED) const;\n-\n-     template<typename _Tp>\n-      _Res\n-      _M_call(_Tp& __object, const volatile _Class * _GLIBCXX_COMMA_SHIFTED\n-              _GLIBCXX_PARAMS_SHIFTED) const\n-      { return (__object.*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n-\n-    template<typename _Tp>\n-      _Res\n-      _M_call(_Tp& __ptr, const volatile void * _GLIBCXX_COMMA_SHIFTED\n-              _GLIBCXX_PARAMS_SHIFTED) const\n-      {  return ((*__ptr).*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n-\n-  public:\n-    typedef _Res result_type;\n-\n-    explicit _Mem_fn(_Functor __pf) : __pmf(__pf) { }\n-\n-    // Handle objects\n-    _Res\n-    operator()(const _Class& __object _GLIBCXX_COMMA_SHIFTED\n-               _GLIBCXX_PARAMS_SHIFTED) const\n-    { return (__object.*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n-\n-    // Handle pointers\n-    _Res\n-    operator()(const _Class* __object _GLIBCXX_COMMA_SHIFTED\n-               _GLIBCXX_PARAMS_SHIFTED) const\n-    { return (__object->*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n-\n-    // Handle smart pointers, references and pointers to derived\n-    template<typename _Tp>\n-      _Res\n-      operator()(_Tp& __object _GLIBCXX_COMMA_SHIFTED\n-                 _GLIBCXX_PARAMS_SHIFTED) const\n-      {\n-        return _M_call(__object, &__object _GLIBCXX_COMMA_SHIFTED\n-                       _GLIBCXX_ARGS_SHIFTED);\n-      }\n-\n-  private:\n-    _Functor __pmf;\n-  };\n-\n-template<typename _Res, typename _Class _GLIBCXX_COMMA_SHIFTED\n-         _GLIBCXX_TEMPLATE_PARAMS_SHIFTED>\n-  class _Mem_fn<_Res (_Class::*)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED) volatile>\n-#if _GLIBCXX_NUM_ARGS == 1\n-  : public unary_function<volatile _Class*, _Res>\n-#elif _GLIBCXX_NUM_ARGS == 2\n-    : public binary_function<volatile _Class*, _T1, _Res>\n-#endif\n-  {\n-    typedef _Res (_Class::*_Functor)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED) volatile;\n-\n-    template<typename _Tp>\n-      _Res\n-      _M_call(_Tp& __object, const volatile _Class * _GLIBCXX_COMMA_SHIFTED\n-              _GLIBCXX_PARAMS_SHIFTED) const\n-      { return (__object.*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n-\n-    template<typename _Tp>\n-      _Res\n-      _M_call(_Tp& __ptr, const volatile void * _GLIBCXX_COMMA_SHIFTED\n-              _GLIBCXX_PARAMS_SHIFTED) const\n-      {  return ((*__ptr).*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n-\n-  public:\n-    typedef _Res result_type;\n-\n-    explicit _Mem_fn(_Functor __pf) : __pmf(__pf) { }\n-\n-    // Handle objects\n-    _Res\n-    operator()(volatile _Class& __object _GLIBCXX_COMMA_SHIFTED\n-               _GLIBCXX_PARAMS_SHIFTED) const\n-    { return (__object.*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n-\n-    // Handle pointers\n-    _Res\n-    operator()(volatile _Class* __object _GLIBCXX_COMMA_SHIFTED\n-               _GLIBCXX_PARAMS_SHIFTED) const\n-    { return (__object->*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n-\n-    // Handle smart pointers, references and pointers to derived\n-    template<typename _Tp>\n-      _Res\n-      operator()(_Tp& __object _GLIBCXX_COMMA_SHIFTED\n-                 _GLIBCXX_PARAMS_SHIFTED) const\n-      {\n-        return _M_call(__object, &__object _GLIBCXX_COMMA_SHIFTED\n-                       _GLIBCXX_ARGS_SHIFTED);\n-      }\n-  private:\n-    _Functor __pmf;\n-  };\n-\n-template<typename _Res, typename _Class _GLIBCXX_COMMA_SHIFTED\n-         _GLIBCXX_TEMPLATE_PARAMS_SHIFTED>\n-  class _Mem_fn<_Res(_Class::*)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED) const volatile>\n-#if _GLIBCXX_NUM_ARGS == 1\n-  : public unary_function<const volatile _Class*, _Res>\n-#elif _GLIBCXX_NUM_ARGS == 2\n-    : public binary_function<const volatile _Class*, _T1, _Res>\n-#endif\n-  {\n-    typedef _Res (_Class::*_Functor)(_GLIBCXX_TEMPLATE_ARGS_SHIFTED)\n-              const volatile;\n-\n-    template<typename _Tp>\n-      _Res\n-      _M_call(_Tp& __object, const volatile _Class * _GLIBCXX_COMMA_SHIFTED\n-              _GLIBCXX_PARAMS_SHIFTED) const\n-      { return (__object.*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n-\n-    template<typename _Tp>\n-      _Res\n-      _M_call(_Tp& __ptr, const volatile void * _GLIBCXX_COMMA_SHIFTED\n-              _GLIBCXX_PARAMS_SHIFTED) const\n-      {  return ((*__ptr).*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n-\n-  public:\n-    typedef _Res result_type;\n-\n-    explicit _Mem_fn(_Functor __pf) : __pmf(__pf) { }\n-\n-    // Handle objects\n-    _Res\n-    operator()(const volatile _Class& __object _GLIBCXX_COMMA_SHIFTED\n-               _GLIBCXX_PARAMS_SHIFTED) const\n-    { return (__object.*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n-\n-    // Handle pointers\n-    _Res\n-    operator()(const volatile _Class* __object _GLIBCXX_COMMA_SHIFTED\n-               _GLIBCXX_PARAMS_SHIFTED) const\n-    { return (__object->*__pmf)(_GLIBCXX_ARGS_SHIFTED); }\n-\n-    // Handle smart pointers, references and pointers to derived\n-    template<typename _Tp>\n-      _Res\n-      operator()(_Tp& __object _GLIBCXX_COMMA_SHIFTED\n-                 _GLIBCXX_PARAMS_SHIFTED) const\n-      {\n-        return _M_call(__object, &__object _GLIBCXX_COMMA_SHIFTED\n-                       _GLIBCXX_ARGS_SHIFTED);\n-      }\n-\n-  private:\n-    _Functor __pmf;\n-  };\n-#endif\n-\n-#if _GLIBCXX_NUM_ARGS > 0\n-namespace placeholders\n-{\n-namespace\n-{\n-   _Placeholder<_GLIBCXX_NUM_ARGS> _GLIBCXX_JOIN(_,_GLIBCXX_NUM_ARGS);\n-} // anonymous namespace\n-}\n-#endif\n-\n-template<typename _Functor _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-class _Bind<_Functor(_GLIBCXX_TEMPLATE_ARGS)>\n-  : public _Weak_result_type<_Functor>\n-{\n-  typedef _Bind __self_type;\n-\n-  _Functor _M_f;\n-  _GLIBCXX_BIND_MEMBERS\n-\n- public:\n-#if _GLIBCXX_NUM_ARGS == 0\n-  explicit\n-#endif\n-  _Bind(_Functor __f _GLIBCXX_COMMA _GLIBCXX_PARAMS)\n-    : _M_f(__f) _GLIBCXX_COMMA _GLIBCXX_BIND_MEMBERS_INIT { }\n-\n-#define _GLIBCXX_BIND_REPEAT_HEADER <tr1/bind_iterate.h>\n-#include <tr1/bind_repeat.h>\n-#undef _GLIBCXX_BIND_REPEAT_HEADER\n-};\n-\n-template<typename _Result, typename _Functor\n-         _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-class _Bind_result<_Result, _Functor(_GLIBCXX_TEMPLATE_ARGS)>\n-{\n-  _Functor _M_f;\n-  _GLIBCXX_BIND_MEMBERS\n-\n- public:\n-  typedef _Result result_type;\n-\n-#if _GLIBCXX_NUM_ARGS == 0\n-  explicit\n-#endif\n-  _Bind_result(_Functor __f _GLIBCXX_COMMA _GLIBCXX_PARAMS)\n-    : _M_f(__f) _GLIBCXX_COMMA _GLIBCXX_BIND_MEMBERS_INIT { }\n-\n-#define _GLIBCXX_BIND_REPEAT_HEADER <tr1/bind_iterate.h>\n-#define _GLIBCXX_BIND_HAS_RESULT_TYPE\n-#include <tr1/bind_repeat.h>\n-#undef _GLIBCXX_BIND_HAS_RESULT_TYPE\n-#undef _GLIBCXX_BIND_REPEAT_HEADER\n-};\n-\n-// Handle arbitrary function objects\n-template<typename _Functor _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-inline\n-_Bind<typename _Maybe_wrap_member_pointer<_Functor>::type\n-        (_GLIBCXX_TEMPLATE_ARGS)>\n-bind(_Functor __f _GLIBCXX_COMMA _GLIBCXX_PARAMS)\n-{\n-  typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n-  typedef typename __maybe_type::type __functor_type;\n-  typedef _Bind<__functor_type(_GLIBCXX_TEMPLATE_ARGS)> __result_type;\n-  return __result_type(__maybe_type::__do_wrap(__f)\n-                       _GLIBCXX_COMMA _GLIBCXX_ARGS);\n-}\n-\n-template<typename _Result, typename _Functor\n-         _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-inline\n-_Bind_result<_Result,\n-             typename _Maybe_wrap_member_pointer<_Functor>::type\n-               (_GLIBCXX_TEMPLATE_ARGS)>\n-bind(_Functor __f _GLIBCXX_COMMA _GLIBCXX_PARAMS)\n-{\n-  typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;\n-  typedef typename __maybe_type::type __functor_type;\n-  typedef _Bind_result<_Result, __functor_type(_GLIBCXX_TEMPLATE_ARGS)>\n-    __result_type;\n-  return __result_type(__maybe_type::__do_wrap(__f)\n-                       _GLIBCXX_COMMA _GLIBCXX_ARGS);\n-}\n-\n-template<typename _Res, typename _Functor _GLIBCXX_COMMA\n-         _GLIBCXX_TEMPLATE_PARAMS>\n-class _Function_handler<_Res(_GLIBCXX_TEMPLATE_ARGS), _Functor>\n-  : public _Function_base::_Base_manager<_Functor>\n-{\n-  typedef _Function_base::_Base_manager<_Functor> _Base;\n-\n- public:\n-  static _Res\n-  _M_invoke(const _Any_data& __functor _GLIBCXX_COMMA _GLIBCXX_PARAMS)\n-  {\n-    return (*_Base::_M_get_pointer(__functor))(_GLIBCXX_ARGS);\n-  }\n-};\n-\n-template<typename _Functor _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-class _Function_handler<void(_GLIBCXX_TEMPLATE_ARGS), _Functor>\n-  : public _Function_base::_Base_manager<_Functor>\n-{\n-  typedef _Function_base::_Base_manager<_Functor> _Base;\n-\n- public:\n-  static void\n-  _M_invoke(const _Any_data& __functor _GLIBCXX_COMMA _GLIBCXX_PARAMS)\n-  {\n-    (*_Base::_M_get_pointer(__functor))(_GLIBCXX_ARGS);\n-  }\n-};\n-\n-template<typename _Res, typename _Functor _GLIBCXX_COMMA\n-         _GLIBCXX_TEMPLATE_PARAMS>\n-class _Function_handler<_Res(_GLIBCXX_TEMPLATE_ARGS),\n-                        reference_wrapper<_Functor> >\n-  : public _Function_base::_Ref_manager<_Functor>\n-{\n-  typedef _Function_base::_Ref_manager<_Functor> _Base;\n-\n- public:\n-  static _Res\n-  _M_invoke(const _Any_data& __functor _GLIBCXX_COMMA _GLIBCXX_PARAMS)\n-  {\n-    return __callable_functor(**_Base::_M_get_pointer(__functor))\n-             (_GLIBCXX_ARGS);\n-  }\n-};\n-\n-template<typename _Functor _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-class _Function_handler<void(_GLIBCXX_TEMPLATE_ARGS),\n-                        reference_wrapper<_Functor> >\n-  : public _Function_base::_Ref_manager<_Functor>\n-{\n-  typedef _Function_base::_Ref_manager<_Functor> _Base;\n-\n- public:\n-  static void\n-  _M_invoke(const _Any_data& __functor _GLIBCXX_COMMA _GLIBCXX_PARAMS)\n-  {\n-    __callable_functor(**_Base::_M_get_pointer(__functor))(_GLIBCXX_ARGS);\n-  }\n-};\n-\n-template<typename _Class, typename _Member, typename _Res\n-         _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-class _Function_handler<_Res(_GLIBCXX_TEMPLATE_ARGS), _Member _Class::*>\n-  : public _Function_handler<void(_GLIBCXX_TEMPLATE_ARGS), _Member _Class::*>\n-{\n-  typedef _Function_handler<void(_GLIBCXX_TEMPLATE_ARGS), _Member _Class::*>\n-    _Base;\n-\n- public:\n-  static _Res\n-  _M_invoke(const _Any_data& __functor _GLIBCXX_COMMA _GLIBCXX_PARAMS)\n-  {\n-    return std::_GLIBCXX_TR1::mem_fn(_Base::_M_get_pointer(__functor)->__value)\n-             (_GLIBCXX_ARGS);\n-  }\n-};\n-\n-template<typename _Class, typename _Member\n-         _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-class _Function_handler<void(_GLIBCXX_TEMPLATE_ARGS), _Member _Class::*>\n-  : public _Function_base::_Base_manager<\n-             _Simple_type_wrapper< _Member _Class::* > >\n-{\n-  typedef _Member _Class::* _Functor;\n-  typedef _Simple_type_wrapper< _Functor > _Wrapper;\n-  typedef _Function_base::_Base_manager<_Wrapper> _Base;\n-\n- public:\n-  static bool\n-  _M_manager(_Any_data& __dest, const _Any_data& __source,\n-             _Manager_operation __op)\n-  {\n-    switch (__op) {\n-    case __get_type_info:\n-      __dest._M_access<const type_info*>() = &typeid(_Functor);\n-      break;\n-\n-    case __get_functor_ptr:\n-      __dest._M_access<_Functor*>() =\n-        &_Base::_M_get_pointer(__source)->__value;\n-      break;\n-\n-    default:\n-      _Base::_M_manager(__dest, __source, __op);\n-    }\n-    return false;\n-  }\n-\n-  static void\n-  _M_invoke(const _Any_data& __functor _GLIBCXX_COMMA _GLIBCXX_PARAMS)\n-  {\n-    std::_GLIBCXX_TR1::mem_fn(_Base::_M_get_pointer(__functor)->__value)\n-      (_GLIBCXX_ARGS);\n-  }\n-};\n-\n-template<typename _Res _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-class function<_Res(_GLIBCXX_TEMPLATE_ARGS)>\n-#if _GLIBCXX_NUM_ARGS == 1\n-  : public unary_function<_T1, _Res>, private _Function_base\n-#elif _GLIBCXX_NUM_ARGS == 2\n-  : public binary_function<_T1, _T2, _Res>, private _Function_base\n-#else\n-  : private _Function_base\n-#endif\n-{\n-  /**\n-   *  @if maint\n-   *  This class is used to implement the safe_bool idiom.\n-   *  @endif\n-   */\n-  struct _Hidden_type\n-  {\n-    _Hidden_type* _M_bool;\n-  };\n-\n-  /**\n-   *  @if maint\n-   *  This typedef is used to implement the safe_bool idiom.\n-   *  @endif\n-   */\n-  typedef _Hidden_type* _Hidden_type::* _Safe_bool;\n-\n-  typedef _Res _Signature_type(_GLIBCXX_TEMPLATE_ARGS);\n-\n-  struct _Useless {};\n-\n- public:\n-  typedef _Res result_type;\n-\n-  // [3.7.2.1] construct/copy/destroy\n-\n-  /**\n-   *  @brief Default construct creates an empty function call wrapper.\n-   *  @post @c !(bool)*this\n-   */\n-  function() : _Function_base() { }\n-\n-  /**\n-   *  @brief Default construct creates an empty function call wrapper.\n-   *  @post @c !(bool)*this\n-   */\n-  function(_M_clear_type*) : _Function_base() { }\n-\n-  /**\n-   *  @brief %Function copy constructor.\n-   *  @param x A %function object with identical call signature.\n-   *  @pre @c (bool)*this == (bool)x\n-   *\n-   *  The newly-created %function contains a copy of the target of @a\n-   *  x (if it has one).\n-   */\n-  function(const function& __x);\n-\n-  /**\n-   *  @brief Builds a %function that targets a copy of the incoming\n-   *  function object.\n-   *  @param f A %function object that is callable with parameters of\n-   *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n-   *  to @c Res.\n-   *\n-   *  The newly-created %function object will target a copy of @a\n-   *  f. If @a f is @c reference_wrapper<F>, then this function\n-   *  object will contain a reference to the function object @c\n-   *  f.get(). If @a f is a NULL function pointer or NULL\n-   *  pointer-to-member, the newly-created object will be empty.\n-   *\n-   *  If @a f is a non-NULL function pointer or an object of type @c\n-   *  reference_wrapper<F>, this function will not throw.\n-   */\n-  template<typename _Functor>\n-    function(_Functor __f,\n-             typename __gnu_cxx::__enable_if<!is_integral<_Functor>::value, _Useless>::__type = _Useless());\n-\n-  /**\n-   *  @brief %Function assignment operator.\n-   *  @param x A %function with identical call signature.\n-   *  @post @c (bool)*this == (bool)x\n-   *  @returns @c *this\n-   *\n-   *  The target of @a x is copied to @c *this. If @a x has no\n-   *  target, then @c *this will be empty.\n-   *\n-   *  If @a x targets a function pointer or a reference to a function\n-   *  object, then this operation will not throw an exception.\n-   */\n-  function& operator=(const function& __x)\n-    {\n-      function(__x).swap(*this);\n-      return *this;\n-    }\n-\n-  /**\n-   *  @brief %Function assignment to zero.\n-   *  @post @c !(bool)*this\n-   *  @returns @c *this\n-   *\n-   *  The target of @a *this is deallocated, leaving it empty.\n-   */\n-  function& operator=(_M_clear_type*)\n-    {\n-      if (_M_manager) {\n-        _M_manager(_M_functor, _M_functor, __destroy_functor);\n-        _M_manager = 0;\n-        _M_invoker = 0;\n-      }\n-      return *this;\n-    }\n-\n-  /**\n-   *  @brief %Function assignment to a new target.\n-   *  @param f A %function object that is callable with parameters of\n-   *  type @c T1, @c T2, ..., @c TN and returns a value convertible\n-   *  to @c Res.\n-   *  @return @c *this\n-   *\n-   *  This  %function object wrapper will target a copy of @a\n-   *  f. If @a f is @c reference_wrapper<F>, then this function\n-   *  object will contain a reference to the function object @c\n-   *  f.get(). If @a f is a NULL function pointer or NULL\n-   *  pointer-to-member, @c this object will be empty.\n-   *\n-   *  If @a f is a non-NULL function pointer or an object of type @c\n-   *  reference_wrapper<F>, this function will not throw.\n-   */\n-  template<typename _Functor>\n-    typename __gnu_cxx::__enable_if<!is_integral<_Functor>::value, function&>::__type\n-    operator=(_Functor __f)\n-    {\n-      function(__f).swap(*this);\n-      return *this;\n-    }\n-\n-  // [3.7.2.2] function modifiers\n-\n-  /**\n-   *  @brief Swap the targets of two %function objects.\n-   *  @param f A %function with identical call signature.\n-   *\n-   *  Swap the targets of @c this function object and @a f. This\n-   *  function will not throw an exception.\n-   */\n-  void swap(function& __x)\n-  {\n-    _Any_data __old_functor = _M_functor;\n-    _M_functor = __x._M_functor;\n-    __x._M_functor = __old_functor;\n-    _Manager_type __old_manager = _M_manager;\n-    _M_manager = __x._M_manager;\n-    __x._M_manager = __old_manager;\n-    _Invoker_type __old_invoker = _M_invoker;\n-    _M_invoker = __x._M_invoker;\n-    __x._M_invoker = __old_invoker;\n-  }\n-\n-  // [3.7.2.3] function capacity\n-\n-  /**\n-   *  @brief Determine if the %function wrapper has a target.\n-   *\n-   *  @return @c true when this %function object contains a target,\n-   *  or @c false when it is empty.\n-   *\n-   *  This function will not throw an exception.\n-   */\n-  operator _Safe_bool() const\n-    {\n-      if (_M_empty())\n-        {\n-          return 0;\n-        }\n-      else\n-        {\n-          return &_Hidden_type::_M_bool;\n-        }\n-    }\n-\n-  // [3.7.2.4] function invocation\n-\n-  /**\n-   *  @brief Invokes the function targeted by @c *this.\n-   *  @returns the result of the target.\n-   *  @throws bad_function_call when @c !(bool)*this\n-   *\n-   *  The function call operator invokes the target function object\n-   *  stored by @c this.\n-   */\n-  _Res operator()(_GLIBCXX_PARAMS) const;\n-\n-  // [3.7.2.5] function target access\n-  /**\n-   *  @brief Determine the type of the target of this function object\n-   *  wrapper.\n-   *\n-   *  @returns the type identifier of the target function object, or\n-   *  @c typeid(void) if @c !(bool)*this.\n-   *\n-   *  This function will not throw an exception.\n-   */\n-  const type_info& target_type() const;\n-\n-  /**\n-   *  @brief Access the stored target function object.\n-   *\n-   *  @return Returns a pointer to the stored target function object,\n-   *  if @c typeid(Functor).equals(target_type()); otherwise, a NULL\n-   *  pointer.\n-   *\n-   * This function will not throw an exception.\n-   */\n-  template<typename _Functor>       _Functor* target();\n-\n-  /**\n-   *  @overload\n-   */\n-  template<typename _Functor> const _Functor* target() const;\n-\n- private:\n-  // [3.7.2.6] undefined operators\n-  template<typename _Function>\n-    void operator==(const function<_Function>&) const;\n-  template<typename _Function>\n-    void operator!=(const function<_Function>&) const;\n-\n-  typedef _Res (*_Invoker_type)(const _Any_data& _GLIBCXX_COMMA\n-                                _GLIBCXX_PARAMS);\n-  _Invoker_type _M_invoker;\n-};\n-\n-template<typename _Res _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-  function<_Res(_GLIBCXX_TEMPLATE_ARGS)>::function(const function& __x)\n-    : _Function_base()\n-  {\n-    if (__x) {\n-      _M_invoker = __x._M_invoker;\n-      _M_manager = __x._M_manager;\n-      __x._M_manager(_M_functor, __x._M_functor, __clone_functor);\n-    }\n-  }\n-\n-template<typename _Res _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-template<typename _Functor>\n-  function<_Res(_GLIBCXX_TEMPLATE_ARGS)>\n-  ::function(_Functor __f,\n-        typename __gnu_cxx::__enable_if<!is_integral<_Functor>::value, _Useless>::__type)\n-    : _Function_base()\n-{\n-  typedef _Function_handler<_Signature_type, _Functor> _My_handler;\n-  if (_My_handler::_M_not_empty_function(__f)) {\n-    _M_invoker = &_My_handler::_M_invoke;\n-    _M_manager = &_My_handler::_M_manager;\n-    _My_handler::_M_init_functor(_M_functor, __f);\n-  }\n-}\n-\n-template<typename _Res _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-  _Res\n-  function<_Res(_GLIBCXX_TEMPLATE_ARGS)>::operator()(_GLIBCXX_PARAMS) const\n-  {\n-    if (_M_empty())\n-      {\n-#if __EXCEPTIONS\n-        throw bad_function_call();\n-#else\n-        std::abort();\n-#endif\n-      }\n-    return _M_invoker(_M_functor _GLIBCXX_COMMA _GLIBCXX_ARGS);\n-  }\n-\n-template<typename _Res _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-  const type_info&\n-  function<_Res(_GLIBCXX_TEMPLATE_ARGS)>::target_type() const\n-  {\n-    if (_M_manager)\n-      {\n-        _Any_data __typeinfo_result;\n-        _M_manager(__typeinfo_result, _M_functor, __get_type_info);\n-        return *__typeinfo_result._M_access<const type_info*>();\n-      }\n-    else\n-      {\n-        return typeid(void);\n-      }\n-  }\n-\n-template<typename _Res _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-template<typename _Functor>\n-  _Functor*\n-  function<_Res(_GLIBCXX_TEMPLATE_ARGS)>::target()\n-  {\n-    if (typeid(_Functor) == target_type() && _M_manager)\n-      {\n-        _Any_data __ptr;\n-        if (_M_manager(__ptr, _M_functor, __get_functor_ptr)\n-            && !is_const<_Functor>::value)\n-          return 0;\n-        else\n-          return __ptr._M_access<_Functor*>();\n-      }\n-    else\n-      {\n-        return 0;\n-      }\n-  }\n-\n-template<typename _Res _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-template<typename _Functor>\n-  const _Functor*\n-  function<_Res(_GLIBCXX_TEMPLATE_ARGS)>::target() const\n-  {\n-    if (typeid(_Functor) == target_type() && _M_manager)\n-      {\n-        _Any_data __ptr;\n-        _M_manager(__ptr, _M_functor, __get_functor_ptr);\n-        return __ptr._M_access<const _Functor*>();\n-      }\n-    else\n-      {\n-        return 0;\n-      }\n-  }\n-\n-_GLIBCXX_END_NAMESPACE\n-}"}, {"sha": "abdc724a7d47a8b1fd3547334c5b0c35fdc57718", "filename": "libstdc++-v3/include/tr1/mu_iterate.h", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a85c8dd4854845630569bbec6437170c3bc246/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmu_iterate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a85c8dd4854845630569bbec6437170c3bc246/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmu_iterate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmu_iterate.h?ref=d6a85c8dd4854845630569bbec6437170c3bc246", "patch": "@@ -1,52 +0,0 @@\n-// TR1 functional -*- C++ -*-\n-\n-// Copyright (C) 2005 Free Software Foundation, Inc.\n-// Written by Douglas Gregor <doug.gregor -at- gmail.com>\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file tr1/mu_iterate.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-// Determine the result type when we pass the arguments along. This\n-// involves passing along the cv-qualifiers placed on _Mu and\n-// unwrapping the argument bundle.\n-// @namespace std::tr1\n-// @class std::tr1::_Mu::result\n-template<typename _CVMu, typename _CVArg\n-         _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-class result<_CVMu(_CVArg, tuple<_GLIBCXX_TEMPLATE_ARGS>)>\n-  : public result_of<_CVArg(_GLIBCXX_TEMPLATE_ARGS)> { };\n-\n-template<typename _CVArg _GLIBCXX_COMMA _GLIBCXX_TEMPLATE_PARAMS>\n-typename result_of<_CVArg(_GLIBCXX_TEMPLATE_ARGS)>::type\n-operator()(_CVArg& __arg, const tuple<_GLIBCXX_TEMPLATE_ARGS>& __tuple)\n-  const volatile\n-{\n-  return __arg(_GLIBCXX_MU_GET_TUPLE_ARGS);\n-}"}, {"sha": "7c63d2cf18aa22e912dd9dcc20384a9b08eee967", "filename": "libstdc++-v3/include/tr1/ref_wrap_iterate.h", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a85c8dd4854845630569bbec6437170c3bc246/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fref_wrap_iterate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a85c8dd4854845630569bbec6437170c3bc246/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fref_wrap_iterate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fref_wrap_iterate.h?ref=d6a85c8dd4854845630569bbec6437170c3bc246", "patch": "@@ -1,44 +0,0 @@\n-// TR1 reference_wrapper -*- C++ -*-\n-\n-// Copyright (C) 2005 Free Software Foundation, Inc.\n-// Written by Douglas Gregor <doug.gregor -at- gmail.com>\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file tr1/ref_wrap_iterate.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#if _GLIBCXX_NUM_ARGS > 0\n-template<_GLIBCXX_TEMPLATE_PARAMS>\n-  typename result_of<_M_func_type(_GLIBCXX_TEMPLATE_ARGS)>::type\n-  operator()(_GLIBCXX_REF_PARAMS) const;\n-#else\n-typename result_of<_M_func_type()>::type\n-operator()() const\n-{ return get()(); }\n-#endif"}, {"sha": "9410d71c47f280f33ddd75d139dd95601a5c495b", "filename": "libstdc++-v3/include/tr1/repeat.h", "status": "removed", "additions": 0, "deletions": 677, "changes": 677, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a85c8dd4854845630569bbec6437170c3bc246/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frepeat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a85c8dd4854845630569bbec6437170c3bc246/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frepeat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frepeat.h?ref=d6a85c8dd4854845630569bbec6437170c3bc246", "patch": "@@ -1,677 +0,0 @@\n-// TR1 code repetition -*- C++ -*-\n-\n-// Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n-// Written by Douglas Gregor <doug.gregor -at- gmail.com>\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file tr1/repeat.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#ifndef _GLIBCXX_REPEAT_HEADER\n-#  error Internal error: _GLIBCXX_REPEAT_HEADER must be set\n-#endif /* _GLIBCXX_REPEAT_HEADER */\n-\n-#ifndef _GLIBCXX_TUPLE_ALL_TEMPLATE_PARAMS\n-#  define _GLIBCXX_TUPLE_ALL_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10\n-#  define _GLIBCXX_TUPLE_ALL_TEMPLATE_PARAMS_UNNAMED typename, typename, typename, typename, typename, typename, typename, typename, typename, typename\n-#  define _GLIBCXX_TUPLE_ALL_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10\n-#endif\n-\n-#define _GLIBCXX_NUM_ARGS 0\n-#define _GLIBCXX_COMMA\n-#define _GLIBCXX_TEMPLATE_PARAMS\n-#define _GLIBCXX_TEMPLATE_ARGS\n-#define _GLIBCXX_PARAMS\n-#define _GLIBCXX_REF_PARAMS\n-#define _GLIBCXX_ARGS\n-#define _GLIBCXX_COMMA_SHIFTED\n-#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n-#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n-#define _GLIBCXX_PARAMS_SHIFTED\n-#define _GLIBCXX_ARGS_SHIFTED\n-#define _GLIBCXX_BIND_MEMBERS_INIT\n-#define _GLIBCXX_BIND_MEMBERS\n-#define _GLIBCXX_MU_GET_TUPLE_ARGS\n-#define _GLIBCXX_BIND_V_TEMPLATE_ARGS(_CV)\n-#define _GLIBCXX_BIND_V_ARGS\n-#define _GLIBCXX_TUPLE_ADD_CREF\n-#define _GLIBCXX_TUPLE_COPY_INIT\n-#define _GLIBCXX_TUPLE_ASSIGN\n-#define _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS\n-#define _GLIBCXX_TEMPLATE_ARGS_STRIPPED\n-#define _GLIBCXX_TEMPLATE_PARAMS_U\n-#define _GLIBCXX_TEMPLATE_ARGS_U\n-#define _GLIBCXX_REF_WRAP_PARAMS\n-#define _GLIBCXX_REF_TEMPLATE_ARGS\n-#define _GLIBCXX_NUM_ARGS_PLUS_1 1\n-#define _GLIBCXX_T_NUM_ARGS_PLUS_1 _T1\n-#include _GLIBCXX_REPEAT_HEADER\n-#undef _GLIBCXX_T_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_REF_TEMPLATE_ARGS\n-#undef _GLIBCXX_REF_WRAP_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS_U\n-#undef _GLIBCXX_TEMPLATE_PARAMS_U\n-#undef _GLIBCXX_TEMPLATE_ARGS_STRIPPED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS\n-#undef _GLIBCXX_TUPLE_ASSIGN\n-#undef _GLIBCXX_TUPLE_COPY_INIT\n-#undef _GLIBCXX_TUPLE_ADD_CREF\n-#undef _GLIBCXX_BIND_V_ARGS\n-#undef _GLIBCXX_BIND_V_TEMPLATE_ARGS\n-#undef _GLIBCXX_MU_GET_TUPLE_ARGS\n-#undef _GLIBCXX_BIND_MEMBERS_INIT\n-#undef _GLIBCXX_BIND_MEMBERS\n-#undef _GLIBCXX_ARGS_SHIFTED\n-#undef _GLIBCXX_PARAMS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n-#undef _GLIBCXX_COMMA_SHIFTED\n-#undef _GLIBCXX_ARGS\n-#undef _GLIBCXX_REF_PARAMS\n-#undef _GLIBCXX_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS\n-#undef _GLIBCXX_TEMPLATE_PARAMS\n-#undef _GLIBCXX_COMMA\n-#undef _GLIBCXX_NUM_ARGS\n-\n-#define _GLIBCXX_NUM_ARGS 1\n-#define _GLIBCXX_COMMA ,\n-#define _GLIBCXX_TEMPLATE_PARAMS typename _T1\n-#define _GLIBCXX_TEMPLATE_ARGS _T1\n-#define _GLIBCXX_PARAMS _T1 __a1\n-#define _GLIBCXX_REF_PARAMS _T1& __a1\n-#define _GLIBCXX_ARGS __a1\n-#define _GLIBCXX_COMMA_SHIFTED\n-#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n-#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n-#define _GLIBCXX_PARAMS_SHIFTED\n-#define _GLIBCXX_ARGS_SHIFTED\n-#define _GLIBCXX_BIND_MEMBERS _T1 _M_arg1;\n-#define _GLIBCXX_BIND_MEMBERS_INIT _M_arg1(__a1)\n-#define _GLIBCXX_MU_GET_TUPLE_ARGS ::std::_GLIBCXX_TR1::get<0>(__tuple)\n-#define _GLIBCXX_BIND_V_TEMPLATE_ARGS(_CV) typename result_of<_Mu<_T1> _CV(_T1, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type\n-#define _GLIBCXX_BIND_V_ARGS _Mu<_T1>()(_M_arg1, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS))\n-#define _GLIBCXX_TUPLE_ADD_CREF typename __add_c_ref<_T1>::type __a1\n-#define _GLIBCXX_TUPLE_COPY_INIT _M_arg1(__in._M_arg1)\n-#define _GLIBCXX_TUPLE_ASSIGN _M_arg1 = __in._M_arg1;\n-#define _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS typename _T1 = _NullClass\n-#define _GLIBCXX_TEMPLATE_ARGS_STRIPPED typename __strip_reference_wrapper<_T1>::__type\n-#define _GLIBCXX_TEMPLATE_PARAMS_U typename _U1\n-#define _GLIBCXX_TEMPLATE_ARGS_U _U1\n-#define _GLIBCXX_REF_WRAP_PARAMS ref(__a1)\n-#define _GLIBCXX_REF_TEMPLATE_ARGS _T1&\n-#define _GLIBCXX_NUM_ARGS_PLUS_1 2\n-#define _GLIBCXX_T_NUM_ARGS_PLUS_1 _T2\n-#include _GLIBCXX_REPEAT_HEADER\n-#undef _GLIBCXX_T_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_REF_TEMPLATE_ARGS\n-#undef _GLIBCXX_REF_WRAP_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS_U\n-#undef _GLIBCXX_TEMPLATE_PARAMS_U\n-#undef _GLIBCXX_TEMPLATE_ARGS_STRIPPED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS\n-#undef _GLIBCXX_TUPLE_ASSIGN\n-#undef _GLIBCXX_TUPLE_COPY_INIT\n-#undef _GLIBCXX_TUPLE_ADD_CREF\n-#undef _GLIBCXX_BIND_V_ARGS\n-#undef _GLIBCXX_BIND_V_TEMPLATE_ARGS\n-#undef _GLIBCXX_MU_GET_TUPLE_ARGS\n-#undef _GLIBCXX_BIND_MEMBERS_INIT\n-#undef _GLIBCXX_BIND_MEMBERS\n-#undef _GLIBCXX_ARGS_SHIFTED\n-#undef _GLIBCXX_PARAMS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n-#undef _GLIBCXX_COMMA_SHIFTED\n-#undef _GLIBCXX_ARGS\n-#undef _GLIBCXX_REF_PARAMS\n-#undef _GLIBCXX_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS\n-#undef _GLIBCXX_TEMPLATE_PARAMS\n-#undef _GLIBCXX_COMMA\n-#undef _GLIBCXX_NUM_ARGS\n-\n-#define _GLIBCXX_NUM_ARGS 2\n-#define _GLIBCXX_COMMA ,\n-#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2\n-#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2\n-#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2\n-#define _GLIBCXX_REF_PARAMS _T1& __a1, _T2& __a2\n-#define _GLIBCXX_ARGS __a1, __a2\n-#define _GLIBCXX_COMMA_SHIFTED ,\n-#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1\n-#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1\n-#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1\n-#define _GLIBCXX_ARGS_SHIFTED __a1\n-#define _GLIBCXX_BIND_MEMBERS _T1 _M_arg1; _T2 _M_arg2;\n-#define _GLIBCXX_BIND_MEMBERS_INIT _M_arg1(__a1), _M_arg2(__a2)\n-#define _GLIBCXX_MU_GET_TUPLE_ARGS ::std::_GLIBCXX_TR1::get<0>(__tuple), ::std::_GLIBCXX_TR1::get<1>(__tuple)\n-#define _GLIBCXX_BIND_V_TEMPLATE_ARGS(_CV) typename result_of<_Mu<_T1> _CV(_T1, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T2> _CV(_T2, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type\n-#define _GLIBCXX_BIND_V_ARGS _Mu<_T1>()(_M_arg1, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T2>()(_M_arg2, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS))\n-#define _GLIBCXX_TUPLE_ADD_CREF typename __add_c_ref<_T1>::type __a1, typename __add_c_ref<_T2>::type __a2\n-#define _GLIBCXX_TUPLE_COPY_INIT _M_arg1(__in._M_arg1), _M_arg2(__in._M_arg2)\n-#define _GLIBCXX_TUPLE_ASSIGN _M_arg1 = __in._M_arg1; _M_arg2 = __in._M_arg2;\n-#define _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS typename _T1 = _NullClass, typename _T2 = _NullClass\n-#define _GLIBCXX_TEMPLATE_ARGS_STRIPPED typename __strip_reference_wrapper<_T1>::__type, typename __strip_reference_wrapper<_T2>::__type\n-#define _GLIBCXX_TEMPLATE_PARAMS_U typename _U1, typename _U2\n-#define _GLIBCXX_TEMPLATE_ARGS_U _U1, _U2\n-#define _GLIBCXX_REF_WRAP_PARAMS ref(__a1), ref(__a2)\n-#define _GLIBCXX_REF_TEMPLATE_ARGS _T1&, _T2&\n-#define _GLIBCXX_NUM_ARGS_PLUS_1 3\n-#define _GLIBCXX_T_NUM_ARGS_PLUS_1 _T3\n-#include _GLIBCXX_REPEAT_HEADER\n-#undef _GLIBCXX_T_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_REF_TEMPLATE_ARGS\n-#undef _GLIBCXX_REF_WRAP_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS_U\n-#undef _GLIBCXX_TEMPLATE_PARAMS_U\n-#undef _GLIBCXX_TEMPLATE_ARGS_STRIPPED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS\n-#undef _GLIBCXX_TUPLE_ASSIGN\n-#undef _GLIBCXX_TUPLE_COPY_INIT\n-#undef _GLIBCXX_TUPLE_ADD_CREF\n-#undef _GLIBCXX_BIND_V_ARGS\n-#undef _GLIBCXX_BIND_V_TEMPLATE_ARGS\n-#undef _GLIBCXX_MU_GET_TUPLE_ARGS\n-#undef _GLIBCXX_BIND_MEMBERS_INIT\n-#undef _GLIBCXX_BIND_MEMBERS\n-#undef _GLIBCXX_ARGS_SHIFTED\n-#undef _GLIBCXX_PARAMS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n-#undef _GLIBCXX_COMMA_SHIFTED\n-#undef _GLIBCXX_ARGS\n-#undef _GLIBCXX_REF_PARAMS\n-#undef _GLIBCXX_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS\n-#undef _GLIBCXX_TEMPLATE_PARAMS\n-#undef _GLIBCXX_COMMA\n-#undef _GLIBCXX_NUM_ARGS\n-#define _GLIBCXX_NUM_ARGS 3\n-#define _GLIBCXX_COMMA ,\n-#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3\n-#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3\n-#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3\n-#define _GLIBCXX_REF_PARAMS _T1& __a1, _T2& __a2, _T3& __a3\n-#define _GLIBCXX_ARGS __a1, __a2, __a3\n-#define _GLIBCXX_COMMA_SHIFTED ,\n-#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2\n-#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2\n-#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2\n-#define _GLIBCXX_ARGS_SHIFTED __a1, __a2\n-#define _GLIBCXX_BIND_MEMBERS _T1 _M_arg1; _T2 _M_arg2; _T3 _M_arg3;\n-#define _GLIBCXX_BIND_MEMBERS_INIT _M_arg1(__a1), _M_arg2(__a2), _M_arg3(__a3)\n-#define _GLIBCXX_MU_GET_TUPLE_ARGS ::std::_GLIBCXX_TR1::get<0>(__tuple), ::std::_GLIBCXX_TR1::get<1>(__tuple), ::std::_GLIBCXX_TR1::get<2>(__tuple)\n-#define _GLIBCXX_BIND_V_TEMPLATE_ARGS(_CV) typename result_of<_Mu<_T1> _CV(_T1, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T2> _CV(_T2, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T3> _CV(_T3, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type\n-#define _GLIBCXX_BIND_V_ARGS _Mu<_T1>()(_M_arg1, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T2>()(_M_arg2, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T3>()(_M_arg3, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS))\n-#define _GLIBCXX_TUPLE_ADD_CREF typename __add_c_ref<_T1>::type __a1, typename __add_c_ref<_T2>::type __a2, typename __add_c_ref<_T3>::type __a3\n-#define _GLIBCXX_TUPLE_COPY_INIT _M_arg1(__in._M_arg1), _M_arg2(__in._M_arg2), _M_arg3(__in._M_arg3)\n-#define _GLIBCXX_TUPLE_ASSIGN _M_arg1 = __in._M_arg1; _M_arg2 = __in._M_arg2; _M_arg3 = __in._M_arg3;\n-#define _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS typename _T1 = _NullClass, typename _T2 = _NullClass, typename _T3 = _NullClass\n-#define _GLIBCXX_TEMPLATE_ARGS_STRIPPED typename __strip_reference_wrapper<_T1>::__type, typename __strip_reference_wrapper<_T2>::__type, typename __strip_reference_wrapper<_T3>::__type\n-#define _GLIBCXX_TEMPLATE_PARAMS_U typename _U1, typename _U2, typename _U3\n-#define _GLIBCXX_TEMPLATE_ARGS_U _U1, _U2, _U3\n-#define _GLIBCXX_REF_WRAP_PARAMS ref(__a1), ref(__a2), ref(__a3)\n-#define _GLIBCXX_REF_TEMPLATE_ARGS _T1&, _T2&, _T3&\n-#define _GLIBCXX_NUM_ARGS_PLUS_1 4\n-#define _GLIBCXX_T_NUM_ARGS_PLUS_1 _T4\n-#include _GLIBCXX_REPEAT_HEADER\n-#undef _GLIBCXX_T_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_REF_TEMPLATE_ARGS\n-#undef _GLIBCXX_REF_WRAP_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS_U\n-#undef _GLIBCXX_TEMPLATE_PARAMS_U\n-#undef _GLIBCXX_TEMPLATE_ARGS_STRIPPED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS\n-#undef _GLIBCXX_TUPLE_ASSIGN\n-#undef _GLIBCXX_TUPLE_COPY_INIT\n-#undef _GLIBCXX_TUPLE_ADD_CREF\n-#undef _GLIBCXX_BIND_V_ARGS\n-#undef _GLIBCXX_BIND_V_TEMPLATE_ARGS\n-#undef _GLIBCXX_MU_GET_TUPLE_ARGS\n-#undef _GLIBCXX_BIND_MEMBERS_INIT\n-#undef _GLIBCXX_BIND_MEMBERS\n-#undef _GLIBCXX_ARGS_SHIFTED\n-#undef _GLIBCXX_PARAMS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n-#undef _GLIBCXX_COMMA_SHIFTED\n-#undef _GLIBCXX_ARGS\n-#undef _GLIBCXX_REF_PARAMS\n-#undef _GLIBCXX_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS\n-#undef _GLIBCXX_TEMPLATE_PARAMS\n-#undef _GLIBCXX_COMMA\n-#undef _GLIBCXX_NUM_ARGS\n-#define _GLIBCXX_NUM_ARGS 4\n-#define _GLIBCXX_COMMA ,\n-#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4\n-#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4\n-#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4\n-#define _GLIBCXX_REF_PARAMS _T1& __a1, _T2& __a2, _T3& __a3, _T4& __a4\n-#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4\n-#define _GLIBCXX_COMMA_SHIFTED ,\n-#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3\n-#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3\n-#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3\n-#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3\n-#define _GLIBCXX_BIND_MEMBERS _T1 _M_arg1; _T2 _M_arg2; _T3 _M_arg3; _T4 _M_arg4;\n-#define _GLIBCXX_BIND_MEMBERS_INIT _M_arg1(__a1), _M_arg2(__a2), _M_arg3(__a3), _M_arg4(__a4)\n-#define _GLIBCXX_MU_GET_TUPLE_ARGS ::std::_GLIBCXX_TR1::get<0>(__tuple), ::std::_GLIBCXX_TR1::get<1>(__tuple), ::std::_GLIBCXX_TR1::get<2>(__tuple), ::std::_GLIBCXX_TR1::get<3>(__tuple)\n-#define _GLIBCXX_BIND_V_TEMPLATE_ARGS(_CV) typename result_of<_Mu<_T1> _CV(_T1, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T2> _CV(_T2, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T3> _CV(_T3, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T4> _CV(_T4, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type\n-#define _GLIBCXX_BIND_V_ARGS _Mu<_T1>()(_M_arg1, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T2>()(_M_arg2, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T3>()(_M_arg3, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T4>()(_M_arg4, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS))\n-#define _GLIBCXX_TUPLE_ADD_CREF typename __add_c_ref<_T1>::type __a1, typename __add_c_ref<_T2>::type __a2, typename __add_c_ref<_T3>::type __a3, typename __add_c_ref<_T4>::type __a4\n-#define _GLIBCXX_TUPLE_COPY_INIT _M_arg1(__in._M_arg1), _M_arg2(__in._M_arg2), _M_arg3(__in._M_arg3), _M_arg4(__in._M_arg4)\n-#define _GLIBCXX_TUPLE_ASSIGN _M_arg1 = __in._M_arg1; _M_arg2 = __in._M_arg2; _M_arg3 = __in._M_arg3; _M_arg4 = __in._M_arg4;\n-#define _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS typename _T1 = _NullClass, typename _T2 = _NullClass, typename _T3 = _NullClass, typename _T4 = _NullClass\n-#define _GLIBCXX_TEMPLATE_ARGS_STRIPPED typename __strip_reference_wrapper<_T1>::__type, typename __strip_reference_wrapper<_T2>::__type, typename __strip_reference_wrapper<_T3>::__type, typename __strip_reference_wrapper<_T4>::__type\n-#define _GLIBCXX_TEMPLATE_PARAMS_U typename _U1, typename _U2, typename _U3, typename _U4\n-#define _GLIBCXX_TEMPLATE_ARGS_U _U1, _U2, _U3, _U4\n-#define _GLIBCXX_REF_WRAP_PARAMS ref(__a1), ref(__a2), ref(__a3), ref(__a4)\n-#define _GLIBCXX_REF_TEMPLATE_ARGS _T1&, _T2&, _T3&, _T4&\n-#define _GLIBCXX_NUM_ARGS_PLUS_1 5\n-#define _GLIBCXX_T_NUM_ARGS_PLUS_1 _T5\n-#include _GLIBCXX_REPEAT_HEADER\n-#undef _GLIBCXX_T_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_REF_TEMPLATE_ARGS\n-#undef _GLIBCXX_REF_WRAP_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS_U\n-#undef _GLIBCXX_TEMPLATE_PARAMS_U\n-#undef _GLIBCXX_TEMPLATE_ARGS_STRIPPED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS\n-#undef _GLIBCXX_TUPLE_ASSIGN\n-#undef _GLIBCXX_TUPLE_COPY_INIT\n-#undef _GLIBCXX_TUPLE_ADD_CREF\n-#undef _GLIBCXX_BIND_V_ARGS\n-#undef _GLIBCXX_BIND_V_TEMPLATE_ARGS\n-#undef _GLIBCXX_MU_GET_TUPLE_ARGS\n-#undef _GLIBCXX_BIND_MEMBERS_INIT\n-#undef _GLIBCXX_BIND_MEMBERS\n-#undef _GLIBCXX_ARGS_SHIFTED\n-#undef _GLIBCXX_PARAMS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n-#undef _GLIBCXX_COMMA_SHIFTED\n-#undef _GLIBCXX_ARGS\n-#undef _GLIBCXX_REF_PARAMS\n-#undef _GLIBCXX_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS\n-#undef _GLIBCXX_TEMPLATE_PARAMS\n-#undef _GLIBCXX_COMMA\n-#undef _GLIBCXX_NUM_ARGS\n-#define _GLIBCXX_NUM_ARGS 5\n-#define _GLIBCXX_COMMA ,\n-#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5\n-#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5\n-#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5\n-#define _GLIBCXX_REF_PARAMS _T1& __a1, _T2& __a2, _T3& __a3, _T4& __a4, _T5& __a5\n-#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5\n-#define _GLIBCXX_COMMA_SHIFTED ,\n-#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4\n-#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4\n-#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4\n-#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4\n-#define _GLIBCXX_BIND_MEMBERS _T1 _M_arg1; _T2 _M_arg2; _T3 _M_arg3; _T4 _M_arg4; _T5 _M_arg5;\n-#define _GLIBCXX_BIND_MEMBERS_INIT _M_arg1(__a1), _M_arg2(__a2), _M_arg3(__a3), _M_arg4(__a4), _M_arg5(__a5)\n-#define _GLIBCXX_MU_GET_TUPLE_ARGS ::std::_GLIBCXX_TR1::get<0>(__tuple), ::std::_GLIBCXX_TR1::get<1>(__tuple), ::std::_GLIBCXX_TR1::get<2>(__tuple), ::std::_GLIBCXX_TR1::get<3>(__tuple), ::std::_GLIBCXX_TR1::get<4>(__tuple)\n-#define _GLIBCXX_BIND_V_TEMPLATE_ARGS(_CV) typename result_of<_Mu<_T1> _CV(_T1, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T2> _CV(_T2, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T3> _CV(_T3, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T4> _CV(_T4, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T5> _CV(_T5, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type\n-#define _GLIBCXX_BIND_V_ARGS _Mu<_T1>()(_M_arg1, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T2>()(_M_arg2, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T3>()(_M_arg3, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T4>()(_M_arg4, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T5>()(_M_arg5, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS))\n-#define _GLIBCXX_TUPLE_ADD_CREF typename __add_c_ref<_T1>::type __a1, typename __add_c_ref<_T2>::type __a2, typename __add_c_ref<_T3>::type __a3, typename __add_c_ref<_T4>::type __a4, typename __add_c_ref<_T5>::type __a5\n-#define _GLIBCXX_TUPLE_COPY_INIT _M_arg1(__in._M_arg1), _M_arg2(__in._M_arg2), _M_arg3(__in._M_arg3), _M_arg4(__in._M_arg4), _M_arg5(__in._M_arg5)\n-#define _GLIBCXX_TUPLE_ASSIGN _M_arg1 = __in._M_arg1; _M_arg2 = __in._M_arg2; _M_arg3 = __in._M_arg3; _M_arg4 = __in._M_arg4; _M_arg5 = __in._M_arg5;\n-#define _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS typename _T1 = _NullClass, typename _T2 = _NullClass, typename _T3 = _NullClass, typename _T4 = _NullClass, typename _T5 = _NullClass\n-#define _GLIBCXX_TEMPLATE_ARGS_STRIPPED typename __strip_reference_wrapper<_T1>::__type, typename __strip_reference_wrapper<_T2>::__type, typename __strip_reference_wrapper<_T3>::__type, typename __strip_reference_wrapper<_T4>::__type, typename __strip_reference_wrapper<_T5>::__type\n-#define _GLIBCXX_TEMPLATE_PARAMS_U typename _U1, typename _U2, typename _U3, typename _U4, typename _U5\n-#define _GLIBCXX_TEMPLATE_ARGS_U _U1, _U2, _U3, _U4, _U5\n-#define _GLIBCXX_REF_WRAP_PARAMS ref(__a1), ref(__a2), ref(__a3), ref(__a4), ref(__a5)\n-#define _GLIBCXX_REF_TEMPLATE_ARGS _T1&, _T2&, _T3&, _T4&, _T5&\n-#define _GLIBCXX_NUM_ARGS_PLUS_1 6\n-#define _GLIBCXX_T_NUM_ARGS_PLUS_1 _T6\n-#include _GLIBCXX_REPEAT_HEADER\n-#undef _GLIBCXX_T_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_REF_TEMPLATE_ARGS\n-#undef _GLIBCXX_REF_WRAP_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS_U\n-#undef _GLIBCXX_TEMPLATE_PARAMS_U\n-#undef _GLIBCXX_TEMPLATE_ARGS_STRIPPED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS\n-#undef _GLIBCXX_TUPLE_ASSIGN\n-#undef _GLIBCXX_TUPLE_COPY_INIT\n-#undef _GLIBCXX_TUPLE_ADD_CREF\n-#undef _GLIBCXX_BIND_V_ARGS\n-#undef _GLIBCXX_BIND_V_TEMPLATE_ARGS\n-#undef _GLIBCXX_MU_GET_TUPLE_ARGS\n-#undef _GLIBCXX_BIND_MEMBERS_INIT\n-#undef _GLIBCXX_BIND_MEMBERS\n-#undef _GLIBCXX_ARGS_SHIFTED\n-#undef _GLIBCXX_PARAMS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n-#undef _GLIBCXX_COMMA_SHIFTED\n-#undef _GLIBCXX_ARGS\n-#undef _GLIBCXX_REF_PARAMS\n-#undef _GLIBCXX_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS\n-#undef _GLIBCXX_TEMPLATE_PARAMS\n-#undef _GLIBCXX_COMMA\n-#undef _GLIBCXX_NUM_ARGS\n-#define _GLIBCXX_NUM_ARGS 6\n-#define _GLIBCXX_COMMA ,\n-#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6\n-#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6\n-#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6\n-#define _GLIBCXX_REF_PARAMS _T1& __a1, _T2& __a2, _T3& __a3, _T4& __a4, _T5& __a5, _T6& __a6\n-#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6\n-#define _GLIBCXX_COMMA_SHIFTED ,\n-#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5\n-#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5\n-#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5\n-#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5\n-#define _GLIBCXX_BIND_MEMBERS _T1 _M_arg1; _T2 _M_arg2; _T3 _M_arg3; _T4 _M_arg4; _T5 _M_arg5; _T6 _M_arg6;\n-#define _GLIBCXX_BIND_MEMBERS_INIT _M_arg1(__a1), _M_arg2(__a2), _M_arg3(__a3), _M_arg4(__a4), _M_arg5(__a5), _M_arg6(__a6)\n-#define _GLIBCXX_MU_GET_TUPLE_ARGS ::std::_GLIBCXX_TR1::get<0>(__tuple), ::std::_GLIBCXX_TR1::get<1>(__tuple), ::std::_GLIBCXX_TR1::get<2>(__tuple), ::std::_GLIBCXX_TR1::get<3>(__tuple), ::std::_GLIBCXX_TR1::get<4>(__tuple), ::std::_GLIBCXX_TR1::get<5>(__tuple)\n-#define _GLIBCXX_BIND_V_TEMPLATE_ARGS(_CV) typename result_of<_Mu<_T1> _CV(_T1, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T2> _CV(_T2, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T3> _CV(_T3, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T4> _CV(_T4, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T5> _CV(_T5, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T6> _CV(_T6, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type\n-#define _GLIBCXX_BIND_V_ARGS _Mu<_T1>()(_M_arg1, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T2>()(_M_arg2, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T3>()(_M_arg3, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T4>()(_M_arg4, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T5>()(_M_arg5, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T6>()(_M_arg6, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS))\n-#define _GLIBCXX_TUPLE_ADD_CREF typename __add_c_ref<_T1>::type __a1, typename __add_c_ref<_T2>::type __a2, typename __add_c_ref<_T3>::type __a3, typename __add_c_ref<_T4>::type __a4, typename __add_c_ref<_T5>::type __a5, typename __add_c_ref<_T6>::type __a6\n-#define _GLIBCXX_TUPLE_COPY_INIT _M_arg1(__in._M_arg1), _M_arg2(__in._M_arg2), _M_arg3(__in._M_arg3), _M_arg4(__in._M_arg4), _M_arg5(__in._M_arg5), _M_arg6(__in._M_arg6)\n-#define _GLIBCXX_TUPLE_ASSIGN _M_arg1 = __in._M_arg1; _M_arg2 = __in._M_arg2; _M_arg3 = __in._M_arg3; _M_arg4 = __in._M_arg4; _M_arg5 = __in._M_arg5; _M_arg6 = __in._M_arg6;\n-#define _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS typename _T1 = _NullClass, typename _T2 = _NullClass, typename _T3 = _NullClass, typename _T4 = _NullClass, typename _T5 = _NullClass, typename _T6 = _NullClass\n-#define _GLIBCXX_TEMPLATE_ARGS_STRIPPED typename __strip_reference_wrapper<_T1>::__type, typename __strip_reference_wrapper<_T2>::__type, typename __strip_reference_wrapper<_T3>::__type, typename __strip_reference_wrapper<_T4>::__type, typename __strip_reference_wrapper<_T5>::__type, typename __strip_reference_wrapper<_T6>::__type\n-#define _GLIBCXX_TEMPLATE_PARAMS_U typename _U1, typename _U2, typename _U3, typename _U4, typename _U5, typename _U6\n-#define _GLIBCXX_TEMPLATE_ARGS_U _U1, _U2, _U3, _U4, _U5, _U6\n-#define _GLIBCXX_REF_WRAP_PARAMS ref(__a1), ref(__a2), ref(__a3), ref(__a4), ref(__a5), ref(__a6)\n-#define _GLIBCXX_REF_TEMPLATE_ARGS _T1&, _T2&, _T3&, _T4&, _T5&, _T6&\n-#define _GLIBCXX_NUM_ARGS_PLUS_1 7\n-#define _GLIBCXX_T_NUM_ARGS_PLUS_1 _T7\n-#include _GLIBCXX_REPEAT_HEADER\n-#undef _GLIBCXX_T_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_REF_TEMPLATE_ARGS\n-#undef _GLIBCXX_REF_WRAP_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS_U\n-#undef _GLIBCXX_TEMPLATE_PARAMS_U\n-#undef _GLIBCXX_TEMPLATE_ARGS_STRIPPED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS\n-#undef _GLIBCXX_TUPLE_ASSIGN\n-#undef _GLIBCXX_TUPLE_COPY_INIT\n-#undef _GLIBCXX_TUPLE_ADD_CREF\n-#undef _GLIBCXX_BIND_V_ARGS\n-#undef _GLIBCXX_BIND_V_TEMPLATE_ARGS\n-#undef _GLIBCXX_MU_GET_TUPLE_ARGS\n-#undef _GLIBCXX_BIND_MEMBERS_INIT\n-#undef _GLIBCXX_BIND_MEMBERS\n-#undef _GLIBCXX_ARGS_SHIFTED\n-#undef _GLIBCXX_PARAMS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n-#undef _GLIBCXX_COMMA_SHIFTED\n-#undef _GLIBCXX_ARGS\n-#undef _GLIBCXX_REF_PARAMS\n-#undef _GLIBCXX_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS\n-#undef _GLIBCXX_TEMPLATE_PARAMS\n-#undef _GLIBCXX_COMMA\n-#undef _GLIBCXX_NUM_ARGS\n-#define _GLIBCXX_NUM_ARGS 7\n-#define _GLIBCXX_COMMA ,\n-#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7\n-#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7\n-#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7\n-#define _GLIBCXX_REF_PARAMS _T1& __a1, _T2& __a2, _T3& __a3, _T4& __a4, _T5& __a5, _T6& __a6, _T7& __a7\n-#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6, __a7\n-#define _GLIBCXX_COMMA_SHIFTED ,\n-#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6\n-#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5, _T6\n-#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6\n-#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5, __a6\n-#define _GLIBCXX_BIND_MEMBERS _T1 _M_arg1; _T2 _M_arg2; _T3 _M_arg3; _T4 _M_arg4; _T5 _M_arg5; _T6 _M_arg6; _T7 _M_arg7;\n-#define _GLIBCXX_BIND_MEMBERS_INIT _M_arg1(__a1), _M_arg2(__a2), _M_arg3(__a3), _M_arg4(__a4), _M_arg5(__a5), _M_arg6(__a6), _M_arg7(__a7)\n-#define _GLIBCXX_MU_GET_TUPLE_ARGS ::std::_GLIBCXX_TR1::get<0>(__tuple), ::std::_GLIBCXX_TR1::get<1>(__tuple), ::std::_GLIBCXX_TR1::get<2>(__tuple), ::std::_GLIBCXX_TR1::get<3>(__tuple), ::std::_GLIBCXX_TR1::get<4>(__tuple), ::std::_GLIBCXX_TR1::get<5>(__tuple), ::std::_GLIBCXX_TR1::get<6>(__tuple)\n-#define _GLIBCXX_BIND_V_TEMPLATE_ARGS(_CV) typename result_of<_Mu<_T1> _CV(_T1, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T2> _CV(_T2, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T3> _CV(_T3, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T4> _CV(_T4, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T5> _CV(_T5, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T6> _CV(_T6, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T7> _CV(_T7, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type\n-#define _GLIBCXX_BIND_V_ARGS _Mu<_T1>()(_M_arg1, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T2>()(_M_arg2, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T3>()(_M_arg3, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T4>()(_M_arg4, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T5>()(_M_arg5, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T6>()(_M_arg6, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T7>()(_M_arg7, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS))\n-#define _GLIBCXX_TUPLE_ADD_CREF typename __add_c_ref<_T1>::type __a1, typename __add_c_ref<_T2>::type __a2, typename __add_c_ref<_T3>::type __a3, typename __add_c_ref<_T4>::type __a4, typename __add_c_ref<_T5>::type __a5, typename __add_c_ref<_T6>::type __a6, typename __add_c_ref<_T7>::type __a7\n-#define _GLIBCXX_TUPLE_COPY_INIT _M_arg1(__in._M_arg1), _M_arg2(__in._M_arg2), _M_arg3(__in._M_arg3), _M_arg4(__in._M_arg4), _M_arg5(__in._M_arg5), _M_arg6(__in._M_arg6), _M_arg7(__in._M_arg7)\n-#define _GLIBCXX_TUPLE_ASSIGN _M_arg1 = __in._M_arg1; _M_arg2 = __in._M_arg2; _M_arg3 = __in._M_arg3; _M_arg4 = __in._M_arg4; _M_arg5 = __in._M_arg5; _M_arg6 = __in._M_arg6; _M_arg7 = __in._M_arg7;\n-#define _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS typename _T1 = _NullClass, typename _T2 = _NullClass, typename _T3 = _NullClass, typename _T4 = _NullClass, typename _T5 = _NullClass, typename _T6 = _NullClass, typename _T7 = _NullClass\n-#define _GLIBCXX_TEMPLATE_ARGS_STRIPPED typename __strip_reference_wrapper<_T1>::__type, typename __strip_reference_wrapper<_T2>::__type, typename __strip_reference_wrapper<_T3>::__type, typename __strip_reference_wrapper<_T4>::__type, typename __strip_reference_wrapper<_T5>::__type, typename __strip_reference_wrapper<_T6>::__type, typename __strip_reference_wrapper<_T7>::__type\n-#define _GLIBCXX_TEMPLATE_PARAMS_U typename _U1, typename _U2, typename _U3, typename _U4, typename _U5, typename _U6, typename _U7\n-#define _GLIBCXX_TEMPLATE_ARGS_U _U1, _U2, _U3, _U4, _U5, _U6, _U7\n-#define _GLIBCXX_REF_WRAP_PARAMS ref(__a1), ref(__a2), ref(__a3), ref(__a4), ref(__a5), ref(__a6), ref(__a7)\n-#define _GLIBCXX_REF_TEMPLATE_ARGS _T1&, _T2&, _T3&, _T4&, _T5&, _T6&, _T7&\n-#define _GLIBCXX_NUM_ARGS_PLUS_1 8\n-#define _GLIBCXX_T_NUM_ARGS_PLUS_1 _T8\n-#include _GLIBCXX_REPEAT_HEADER\n-#undef _GLIBCXX_T_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_REF_TEMPLATE_ARGS\n-#undef _GLIBCXX_REF_WRAP_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS_U\n-#undef _GLIBCXX_TEMPLATE_PARAMS_U\n-#undef _GLIBCXX_TEMPLATE_ARGS_STRIPPED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS\n-#undef _GLIBCXX_TUPLE_ASSIGN\n-#undef _GLIBCXX_TUPLE_COPY_INIT\n-#undef _GLIBCXX_TUPLE_ADD_CREF\n-#undef _GLIBCXX_BIND_V_ARGS\n-#undef _GLIBCXX_BIND_V_TEMPLATE_ARGS\n-#undef _GLIBCXX_MU_GET_TUPLE_ARGS\n-#undef _GLIBCXX_BIND_MEMBERS_INIT\n-#undef _GLIBCXX_BIND_MEMBERS\n-#undef _GLIBCXX_ARGS_SHIFTED\n-#undef _GLIBCXX_PARAMS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n-#undef _GLIBCXX_COMMA_SHIFTED\n-#undef _GLIBCXX_ARGS\n-#undef _GLIBCXX_REF_PARAMS\n-#undef _GLIBCXX_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS\n-#undef _GLIBCXX_TEMPLATE_PARAMS\n-#undef _GLIBCXX_COMMA\n-#undef _GLIBCXX_NUM_ARGS\n-#define _GLIBCXX_NUM_ARGS 8\n-#define _GLIBCXX_COMMA ,\n-#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8\n-#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8\n-#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8\n-#define _GLIBCXX_REF_PARAMS _T1& __a1, _T2& __a2, _T3& __a3, _T4& __a4, _T5& __a5, _T6& __a6, _T7& __a7, _T8& __a8\n-#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8\n-#define _GLIBCXX_COMMA_SHIFTED ,\n-#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7\n-#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5, _T6, _T7\n-#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7\n-#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5, __a6, __a7\n-#define _GLIBCXX_BIND_MEMBERS _T1 _M_arg1; _T2 _M_arg2; _T3 _M_arg3; _T4 _M_arg4; _T5 _M_arg5; _T6 _M_arg6; _T7 _M_arg7; _T8 _M_arg8;\n-#define _GLIBCXX_BIND_MEMBERS_INIT _M_arg1(__a1), _M_arg2(__a2), _M_arg3(__a3), _M_arg4(__a4), _M_arg5(__a5), _M_arg6(__a6), _M_arg7(__a7), _M_arg8(__a8)\n-#define _GLIBCXX_MU_GET_TUPLE_ARGS ::std::_GLIBCXX_TR1::get<0>(__tuple), ::std::_GLIBCXX_TR1::get<1>(__tuple), ::std::_GLIBCXX_TR1::get<2>(__tuple), ::std::_GLIBCXX_TR1::get<3>(__tuple), ::std::_GLIBCXX_TR1::get<4>(__tuple), ::std::_GLIBCXX_TR1::get<5>(__tuple), ::std::_GLIBCXX_TR1::get<6>(__tuple), ::std::_GLIBCXX_TR1::get<7>(__tuple)\n-#define _GLIBCXX_BIND_V_TEMPLATE_ARGS(_CV) typename result_of<_Mu<_T1> _CV(_T1, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T2> _CV(_T2, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T3> _CV(_T3, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T4> _CV(_T4, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T5> _CV(_T5, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T6> _CV(_T6, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T7> _CV(_T7, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T8> _CV(_T8, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type\n-#define _GLIBCXX_BIND_V_ARGS _Mu<_T1>()(_M_arg1, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T2>()(_M_arg2, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T3>()(_M_arg3, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T4>()(_M_arg4, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T5>()(_M_arg5, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T6>()(_M_arg6, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T7>()(_M_arg7, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T8>()(_M_arg8, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS))\n-#define _GLIBCXX_TUPLE_ADD_CREF typename __add_c_ref<_T1>::type __a1, typename __add_c_ref<_T2>::type __a2, typename __add_c_ref<_T3>::type __a3, typename __add_c_ref<_T4>::type __a4, typename __add_c_ref<_T5>::type __a5, typename __add_c_ref<_T6>::type __a6, typename __add_c_ref<_T7>::type __a7, typename __add_c_ref<_T8>::type __a8\n-#define _GLIBCXX_TUPLE_COPY_INIT _M_arg1(__in._M_arg1), _M_arg2(__in._M_arg2), _M_arg3(__in._M_arg3), _M_arg4(__in._M_arg4), _M_arg5(__in._M_arg5), _M_arg6(__in._M_arg6), _M_arg7(__in._M_arg7), _M_arg8(__in._M_arg8)\n-#define _GLIBCXX_TUPLE_ASSIGN _M_arg1 = __in._M_arg1; _M_arg2 = __in._M_arg2; _M_arg3 = __in._M_arg3; _M_arg4 = __in._M_arg4; _M_arg5 = __in._M_arg5; _M_arg6 = __in._M_arg6; _M_arg7 = __in._M_arg7; _M_arg8 = __in._M_arg8;\n-#define _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS typename _T1 = _NullClass, typename _T2 = _NullClass, typename _T3 = _NullClass, typename _T4 = _NullClass, typename _T5 = _NullClass, typename _T6 = _NullClass, typename _T7 = _NullClass, typename _T8 = _NullClass\n-#define _GLIBCXX_TEMPLATE_ARGS_STRIPPED typename __strip_reference_wrapper<_T1>::__type, typename __strip_reference_wrapper<_T2>::__type, typename __strip_reference_wrapper<_T3>::__type, typename __strip_reference_wrapper<_T4>::__type, typename __strip_reference_wrapper<_T5>::__type, typename __strip_reference_wrapper<_T6>::__type, typename __strip_reference_wrapper<_T7>::__type, typename __strip_reference_wrapper<_T8>::__type\n-#define _GLIBCXX_TEMPLATE_PARAMS_U typename _U1, typename _U2, typename _U3, typename _U4, typename _U5, typename _U6, typename _U7, typename _U8\n-#define _GLIBCXX_TEMPLATE_ARGS_U _U1, _U2, _U3, _U4, _U5, _U6, _U7, _U8\n-#define _GLIBCXX_REF_WRAP_PARAMS ref(__a1), ref(__a2), ref(__a3), ref(__a4), ref(__a5), ref(__a6), ref(__a7), ref(__a8)\n-#define _GLIBCXX_REF_TEMPLATE_ARGS _T1&, _T2&, _T3&, _T4&, _T5&, _T6&, _T7&, _T8&\n-#define _GLIBCXX_NUM_ARGS_PLUS_1 9\n-#define _GLIBCXX_T_NUM_ARGS_PLUS_1 _T9\n-#include _GLIBCXX_REPEAT_HEADER\n-#undef _GLIBCXX_T_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_REF_TEMPLATE_ARGS\n-#undef _GLIBCXX_REF_WRAP_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS_U\n-#undef _GLIBCXX_TEMPLATE_PARAMS_U\n-#undef _GLIBCXX_TEMPLATE_ARGS_STRIPPED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS\n-#undef _GLIBCXX_TUPLE_ASSIGN\n-#undef _GLIBCXX_TUPLE_COPY_INIT\n-#undef _GLIBCXX_TUPLE_ADD_CREF\n-#undef _GLIBCXX_BIND_V_ARGS\n-#undef _GLIBCXX_BIND_V_TEMPLATE_ARGS\n-#undef _GLIBCXX_MU_GET_TUPLE_ARGS\n-#undef _GLIBCXX_BIND_MEMBERS_INIT\n-#undef _GLIBCXX_BIND_MEMBERS\n-#undef _GLIBCXX_ARGS_SHIFTED\n-#undef _GLIBCXX_PARAMS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n-#undef _GLIBCXX_COMMA_SHIFTED\n-#undef _GLIBCXX_ARGS\n-#undef _GLIBCXX_REF_PARAMS\n-#undef _GLIBCXX_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS\n-#undef _GLIBCXX_TEMPLATE_PARAMS\n-#undef _GLIBCXX_COMMA\n-#undef _GLIBCXX_NUM_ARGS\n-#define _GLIBCXX_NUM_ARGS 9\n-#define _GLIBCXX_COMMA ,\n-#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9\n-#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9\n-#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9\n-#define _GLIBCXX_REF_PARAMS _T1& __a1, _T2& __a2, _T3& __a3, _T4& __a4, _T5& __a5, _T6& __a6, _T7& __a7, _T8& __a8, _T9& __a9\n-#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9\n-#define _GLIBCXX_COMMA_SHIFTED ,\n-#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8\n-#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8\n-#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8\n-#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8\n-#define _GLIBCXX_BIND_MEMBERS _T1 _M_arg1; _T2 _M_arg2; _T3 _M_arg3; _T4 _M_arg4; _T5 _M_arg5; _T6 _M_arg6; _T7 _M_arg7; _T8 _M_arg8; _T9 _M_arg9;\n-#define _GLIBCXX_BIND_MEMBERS_INIT _M_arg1(__a1), _M_arg2(__a2), _M_arg3(__a3), _M_arg4(__a4), _M_arg5(__a5), _M_arg6(__a6), _M_arg7(__a7), _M_arg8(__a8), _M_arg9(__a9)\n-#define _GLIBCXX_MU_GET_TUPLE_ARGS ::std::_GLIBCXX_TR1::get<0>(__tuple), ::std::_GLIBCXX_TR1::get<1>(__tuple), ::std::_GLIBCXX_TR1::get<2>(__tuple), ::std::_GLIBCXX_TR1::get<3>(__tuple), ::std::_GLIBCXX_TR1::get<4>(__tuple), ::std::_GLIBCXX_TR1::get<5>(__tuple), ::std::_GLIBCXX_TR1::get<6>(__tuple), ::std::_GLIBCXX_TR1::get<7>(__tuple), ::std::_GLIBCXX_TR1::get<8>(__tuple)\n-#define _GLIBCXX_BIND_V_TEMPLATE_ARGS(_CV) typename result_of<_Mu<_T1> _CV(_T1, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T2> _CV(_T2, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T3> _CV(_T3, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T4> _CV(_T4, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T5> _CV(_T5, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T6> _CV(_T6, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T7> _CV(_T7, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T8> _CV(_T8, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T9> _CV(_T9, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type\n-#define _GLIBCXX_BIND_V_ARGS _Mu<_T1>()(_M_arg1, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T2>()(_M_arg2, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T3>()(_M_arg3, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T4>()(_M_arg4, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T5>()(_M_arg5, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T6>()(_M_arg6, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T7>()(_M_arg7, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T8>()(_M_arg8, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T9>()(_M_arg9, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS))\n-#define _GLIBCXX_TUPLE_ADD_CREF typename __add_c_ref<_T1>::type __a1, typename __add_c_ref<_T2>::type __a2, typename __add_c_ref<_T3>::type __a3, typename __add_c_ref<_T4>::type __a4, typename __add_c_ref<_T5>::type __a5, typename __add_c_ref<_T6>::type __a6, typename __add_c_ref<_T7>::type __a7, typename __add_c_ref<_T8>::type __a8, typename __add_c_ref<_T9>::type __a9\n-#define _GLIBCXX_TUPLE_COPY_INIT _M_arg1(__in._M_arg1), _M_arg2(__in._M_arg2), _M_arg3(__in._M_arg3), _M_arg4(__in._M_arg4), _M_arg5(__in._M_arg5), _M_arg6(__in._M_arg6), _M_arg7(__in._M_arg7), _M_arg8(__in._M_arg8), _M_arg9(__in._M_arg9)\n-#define _GLIBCXX_TUPLE_ASSIGN _M_arg1 = __in._M_arg1; _M_arg2 = __in._M_arg2; _M_arg3 = __in._M_arg3; _M_arg4 = __in._M_arg4; _M_arg5 = __in._M_arg5; _M_arg6 = __in._M_arg6; _M_arg7 = __in._M_arg7; _M_arg8 = __in._M_arg8; _M_arg9 = __in._M_arg9;\n-#define _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS typename _T1 = _NullClass, typename _T2 = _NullClass, typename _T3 = _NullClass, typename _T4 = _NullClass, typename _T5 = _NullClass, typename _T6 = _NullClass, typename _T7 = _NullClass, typename _T8 = _NullClass, typename _T9 = _NullClass\n-#define _GLIBCXX_TEMPLATE_ARGS_STRIPPED typename __strip_reference_wrapper<_T1>::__type, typename __strip_reference_wrapper<_T2>::__type, typename __strip_reference_wrapper<_T3>::__type, typename __strip_reference_wrapper<_T4>::__type, typename __strip_reference_wrapper<_T5>::__type, typename __strip_reference_wrapper<_T6>::__type, typename __strip_reference_wrapper<_T7>::__type, typename __strip_reference_wrapper<_T8>::__type, typename __strip_reference_wrapper<_T9>::__type\n-#define _GLIBCXX_TEMPLATE_PARAMS_U typename _U1, typename _U2, typename _U3, typename _U4, typename _U5, typename _U6, typename _U7, typename _U8, typename _U9\n-#define _GLIBCXX_TEMPLATE_ARGS_U _U1, _U2, _U3, _U4, _U5, _U6, _U7, _U8, _U9\n-#define _GLIBCXX_REF_WRAP_PARAMS ref(__a1), ref(__a2), ref(__a3), ref(__a4), ref(__a5), ref(__a6), ref(__a7), ref(__a8), ref(__a9)\n-#define _GLIBCXX_REF_TEMPLATE_ARGS _T1&, _T2&, _T3&, _T4&, _T5&, _T6&, _T7&, _T8&, _T9&\n-#define _GLIBCXX_NUM_ARGS_PLUS_1 10\n-#define _GLIBCXX_T_NUM_ARGS_PLUS_1 _T10\n-#include _GLIBCXX_REPEAT_HEADER\n-#undef _GLIBCXX_T_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_REF_TEMPLATE_ARGS\n-#undef _GLIBCXX_REF_WRAP_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS_U\n-#undef _GLIBCXX_TEMPLATE_PARAMS_U\n-#undef _GLIBCXX_TEMPLATE_ARGS_STRIPPED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS\n-#undef _GLIBCXX_TUPLE_ASSIGN\n-#undef _GLIBCXX_TUPLE_COPY_INIT\n-#undef _GLIBCXX_TUPLE_ADD_CREF\n-#undef _GLIBCXX_BIND_V_ARGS\n-#undef _GLIBCXX_BIND_V_TEMPLATE_ARGS\n-#undef _GLIBCXX_MU_GET_TUPLE_ARGS\n-#undef _GLIBCXX_BIND_MEMBERS_INIT\n-#undef _GLIBCXX_BIND_MEMBERS\n-#undef _GLIBCXX_ARGS_SHIFTED\n-#undef _GLIBCXX_PARAMS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n-#undef _GLIBCXX_COMMA_SHIFTED\n-#undef _GLIBCXX_ARGS\n-#undef _GLIBCXX_REF_PARAMS\n-#undef _GLIBCXX_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS\n-#undef _GLIBCXX_TEMPLATE_PARAMS\n-#undef _GLIBCXX_COMMA\n-#undef _GLIBCXX_NUM_ARGS\n-#define _GLIBCXX_LAST_INCLUDE\n-#define _GLIBCXX_NUM_ARGS 10\n-#define _GLIBCXX_COMMA ,\n-#define _GLIBCXX_TEMPLATE_PARAMS typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9, typename _T10\n-#define _GLIBCXX_TEMPLATE_ARGS _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10\n-#define _GLIBCXX_PARAMS _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9, _T10 __a10\n-#define _GLIBCXX_REF_PARAMS _T1& __a1, _T2& __a2, _T3& __a3, _T4& __a4, _T5& __a5, _T6& __a6, _T7& __a7, _T8& __a8, _T9& __a9, _T10& __a10\n-#define _GLIBCXX_ARGS __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9, __a10\n-#define _GLIBCXX_COMMA_SHIFTED ,\n-#define _GLIBCXX_TEMPLATE_PARAMS_SHIFTED typename _T1, typename _T2, typename _T3, typename _T4, typename _T5, typename _T6, typename _T7, typename _T8, typename _T9\n-#define _GLIBCXX_TEMPLATE_ARGS_SHIFTED _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9\n-#define _GLIBCXX_PARAMS_SHIFTED _T1 __a1, _T2 __a2, _T3 __a3, _T4 __a4, _T5 __a5, _T6 __a6, _T7 __a7, _T8 __a8, _T9 __a9\n-#define _GLIBCXX_ARGS_SHIFTED __a1, __a2, __a3, __a4, __a5, __a6, __a7, __a8, __a9\n-#define _GLIBCXX_BIND_MEMBERS _T1 _M_arg1; _T2 _M_arg2; _T3 _M_arg3; _T4 _M_arg4; _T5 _M_arg5; _T6 _M_arg6; _T7 _M_arg7; _T8 _M_arg8; _T9 _M_arg9; _T10 _M_arg10;\n-#define _GLIBCXX_BIND_MEMBERS_INIT _M_arg1(__a1), _M_arg2(__a2), _M_arg3(__a3), _M_arg4(__a4), _M_arg5(__a5), _M_arg6(__a6), _M_arg7(__a7), _M_arg8(__a8), _M_arg9(__a9), _M_arg10(__a10)\n-#define _GLIBCXX_MU_GET_TUPLE_ARGS ::std::_GLIBCXX_TR1::get<0>(__tuple), ::std::_GLIBCXX_TR1::get<1>(__tuple), ::std::_GLIBCXX_TR1::get<2>(__tuple), ::std::_GLIBCXX_TR1::get<3>(__tuple), ::std::_GLIBCXX_TR1::get<4>(__tuple), ::std::_GLIBCXX_TR1::get<5>(__tuple), ::std::_GLIBCXX_TR1::get<6>(__tuple), ::std::_GLIBCXX_TR1::get<7>(__tuple), ::std::_GLIBCXX_TR1::get<8>(__tuple), ::std::_GLIBCXX_TR1::get<9>(__tuple)\n-#define _GLIBCXX_BIND_V_TEMPLATE_ARGS(_CV) typename result_of<_Mu<_T1> _CV(_T1, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T2> _CV(_T2, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T3> _CV(_T3, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T4> _CV(_T4, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T5> _CV(_T5, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T6> _CV(_T6, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T7> _CV(_T7, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T8> _CV(_T8, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T9> _CV(_T9, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type, typename result_of<_Mu<_T10> _CV(_T10, tuple<_GLIBCXX_BIND_TEMPLATE_ARGS>)>::type\n-#define _GLIBCXX_BIND_V_ARGS _Mu<_T1>()(_M_arg1, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T2>()(_M_arg2, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T3>()(_M_arg3, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T4>()(_M_arg4, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T5>()(_M_arg5, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T6>()(_M_arg6, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T7>()(_M_arg7, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T8>()(_M_arg8, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T9>()(_M_arg9, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS)), _Mu<_T10>()(_M_arg10, ::std::_GLIBCXX_TR1::tie(_GLIBCXX_BIND_ARGS))\n-#define _GLIBCXX_TUPLE_ADD_CREF typename __add_c_ref<_T1>::type __a1, typename __add_c_ref<_T2>::type __a2, typename __add_c_ref<_T3>::type __a3, typename __add_c_ref<_T4>::type __a4, typename __add_c_ref<_T5>::type __a5, typename __add_c_ref<_T6>::type __a6, typename __add_c_ref<_T7>::type __a7, typename __add_c_ref<_T8>::type __a8, typename __add_c_ref<_T9>::type __a9, typename __add_c_ref<_T10>::type __a10\n-#define _GLIBCXX_TUPLE_COPY_INIT _M_arg1(__in._M_arg1), _M_arg2(__in._M_arg2), _M_arg3(__in._M_arg3), _M_arg4(__in._M_arg4), _M_arg5(__in._M_arg5), _M_arg6(__in._M_arg6), _M_arg7(__in._M_arg7), _M_arg8(__in._M_arg8), _M_arg9(__in._M_arg9), _M_arg10(__in._M_arg10)\n-#define _GLIBCXX_TUPLE_ASSIGN _M_arg1 = __in._M_arg1; _M_arg2 = __in._M_arg2; _M_arg3 = __in._M_arg3; _M_arg4 = __in._M_arg4; _M_arg5 = __in._M_arg5; _M_arg6 = __in._M_arg6; _M_arg7 = __in._M_arg7; _M_arg8 = __in._M_arg8; _M_arg9 = __in._M_arg9; _M_arg10 = __in._M_arg10;\n-#define _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS typename _T1 = _NullClass, typename _T2 = _NullClass, typename _T3 = _NullClass, typename _T4 = _NullClass, typename _T5 = _NullClass, typename _T6 = _NullClass, typename _T7 = _NullClass, typename _T8 = _NullClass, typename _T9 = _NullClass, typename _T10 = _NullClass\n-#define _GLIBCXX_TEMPLATE_ARGS_STRIPPED typename __strip_reference_wrapper<_T1>::__type, typename __strip_reference_wrapper<_T2>::__type, typename __strip_reference_wrapper<_T3>::__type, typename __strip_reference_wrapper<_T4>::__type, typename __strip_reference_wrapper<_T5>::__type, typename __strip_reference_wrapper<_T6>::__type, typename __strip_reference_wrapper<_T7>::__type, typename __strip_reference_wrapper<_T8>::__type, typename __strip_reference_wrapper<_T9>::__type, typename __strip_reference_wrapper<_T10>::__type\n-#define _GLIBCXX_TEMPLATE_PARAMS_U typename _U1, typename _U2, typename _U3, typename _U4, typename _U5, typename _U6, typename _U7, typename _U8, typename _U9, typename _U10\n-#define _GLIBCXX_TEMPLATE_ARGS_U _U1, _U2, _U3, _U4, _U5, _U6, _U7, _U8, _U9, _U10\n-#define _GLIBCXX_REF_WRAP_PARAMS ref(__a1), ref(__a2), ref(__a3), ref(__a4), ref(__a5), ref(__a6), ref(__a7), ref(__a8), ref(__a9), ref(__a10)\n-#define _GLIBCXX_REF_TEMPLATE_ARGS _T1&, _T2&, _T3&, _T4&, _T5&, _T6&, _T7&, _T8&, _T9&, _T10&\n-#define _GLIBCXX_NUM_ARGS_PLUS_1 11\n-#define _GLIBCXX_T_NUM_ARGS_PLUS_1 _T11\n-#include _GLIBCXX_REPEAT_HEADER\n-#undef _GLIBCXX_T_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_NUM_ARGS_PLUS_1\n-#undef _GLIBCXX_REF_TEMPLATE_ARGS\n-#undef _GLIBCXX_REF_WRAP_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS_U\n-#undef _GLIBCXX_TEMPLATE_PARAMS_U\n-#undef _GLIBCXX_TEMPLATE_ARGS_STRIPPED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_NULL_CLASS\n-#undef _GLIBCXX_TUPLE_ASSIGN\n-#undef _GLIBCXX_TUPLE_COPY_INIT\n-#undef _GLIBCXX_TUPLE_ADD_CREF\n-#undef _GLIBCXX_BIND_V_ARGS\n-#undef _GLIBCXX_BIND_V_TEMPLATE_ARGS\n-#undef _GLIBCXX_MU_GET_TUPLE_ARGS\n-#undef _GLIBCXX_BIND_MEMBERS_INIT\n-#undef _GLIBCXX_BIND_MEMBERS\n-#undef _GLIBCXX_ARGS_SHIFTED\n-#undef _GLIBCXX_PARAMS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_ARGS_SHIFTED\n-#undef _GLIBCXX_TEMPLATE_PARAMS_SHIFTED\n-#undef _GLIBCXX_COMMA_SHIFTED\n-#undef _GLIBCXX_ARGS\n-#undef _GLIBCXX_REF_PARAMS\n-#undef _GLIBCXX_PARAMS\n-#undef _GLIBCXX_TEMPLATE_ARGS\n-#undef _GLIBCXX_TEMPLATE_PARAMS\n-#undef _GLIBCXX_COMMA\n-#undef _GLIBCXX_NUM_ARGS\n-#undef _GLIBCXX_LAST_INCLUDE\n-"}, {"sha": "96ba4b82aa6bcc3445575343c7cce8a32ca9ce13", "filename": "libstdc++-v3/include/tr1/tuple", "status": "modified", "additions": 279, "deletions": 38, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eeea7612d055f00ce21fd1442411c838d82b452/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eeea7612d055f00ce21fd1442411c838d82b452/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple?ref=9eeea7612d055f00ce21fd1442411c838d82b452", "patch": "@@ -32,29 +32,21 @@\n */\n \n // Chris Jefferson <chris@bubblescope.net>\n+// Variadic Templates support by Douglas Gregor <doug.gregor@gmail.com>\n \n #ifndef _TR1_TUPLE\n #define _TR1_TUPLE 1\n \n+#pragma GCC system_header\n+\n #include <tr1/utility>\n #include <tr1/ref_fwd.h>\n+#include <bits/cpp_type_traits.h> // for __enable_if\n \n namespace std\n {\n _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n \n- // An implementation specific class which is used in the tuple class\n- // when the tuple is not maximum possible size.\n- struct _NullClass { };\n-\n- /// Gives the type of the ith element of a given tuple type.\n- template<int __i, typename _Tp>\n-   struct tuple_element;\n-\n- /// Finds the size of a given tuple type.\n- template<typename _Tp>\n-   struct tuple_size;\n-\n  // Adds a const reference to a non-reference type.\n  template<typename _Tp>\n    struct __add_c_ref\n@@ -73,37 +65,220 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n    struct __add_ref<_Tp&>\n    { typedef _Tp& type; };\n \n- // Class used in the implementation of get\n- template<int __i, typename _Tp>\n-   struct __get_helper;\n+/**\n+ * @if maint\n+ * Contains the actual implementation of the @c tuple template, stored\n+ * as a recursive inheritance hierarchy from the first element (most\n+ * derived class) to the last (least derived class). The @c Idx\n+ * parameter gives the 0-based index of the element stored at this\n+ * point in the hierarchy; we use it to implement a constant-time\n+ * get() operation.\n+ * @endif\n+ */\n+ template<int _Idx, typename... _Elements>\n+   struct _Tuple_impl; \n \n- // Returns a const reference to the ith element of a tuple.\n- // Any const or non-const ref elements are returned with their original type.\n+ /**\n+  * @if maint\n+  * Zero-element tuple implementation. This is the basis case for the \n+  * inheritance recursion.\n+  * @endif maint\n+  */\n+ template<int _Idx>\n+   struct _Tuple_impl<_Idx> { };\n \n- // This class helps construct the various comparison operations on tuples\n- template<int __check_equal_size, int __i, int __j, typename _Tp, typename _Up>\n-   struct __tuple_compare;\n+ /**\n+  * @if maint\n+  * Recursive tuple implementation. Here we store the @c Head element\n+  * and derive from a @c Tuple_impl containing the remaining elements\n+  * (which contains the @c Tail).\n+  * @endif\n+  */\n+ template<int _Idx, typename _Head, typename... _Tail>\n+   struct _Tuple_impl<_Idx, _Head, _Tail...>\n+     : public _Tuple_impl<_Idx+1, _Tail...>\n+   {\n+     typedef _Tuple_impl<_Idx+1, _Tail...> _Inherited;\n \n- // Helper which adds a reference to a type when given a reference_wrapper\n- template<typename _Tp>\n-   struct __strip_reference_wrapper\n+     _Head _M_head;\n+\n+     _Inherited&       _M_tail()       { return *this; }\n+     const _Inherited& _M_tail() const { return *this; }\n+\n+     _Tuple_impl() : _Inherited(), _M_head() { }\n+\n+     explicit \n+     _Tuple_impl(typename __add_c_ref<_Head>::type __head,\n+                 typename __add_c_ref<_Tail>::type... __tail)\n+       : _Inherited(__tail...), _M_head(__head) { }\n+\n+     template<typename... _UElements>\n+       _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)\n+         : _Inherited(__in._M_tail()), _M_head(__in._M_head) { }\n+\n+     _Tuple_impl(const _Tuple_impl& __in)\n+       : _Inherited(__in._M_tail()), _M_head(__in._M_head) { }\n+     \n+     template<typename... _UElements>\n+     _Tuple_impl& operator=(const _Tuple_impl<_Idx, _UElements...>& __in)\n+     {\n+       _M_head = __in._M_head;\n+       _M_tail() = __in._M_tail();\n+       return *this;\n+     }\n+\n+     _Tuple_impl& operator=(const _Tuple_impl& __in)\n+     {\n+       _M_head = __in._M_head;\n+       _M_tail() = __in._M_tail();\n+       return *this;\n+     }\n+   };\n+\n+ template<typename... _Elements> \n+   class tuple : public _Tuple_impl<0, _Elements...>\n    {\n-       typedef _Tp __type;\n+     typedef _Tuple_impl<0, _Elements...> _Inherited;\n+\n+   public:\n+     tuple() : _Inherited() { }\n+\n+     explicit\n+     tuple(typename __add_c_ref<_Elements>::type... __elements)\n+       : _Inherited(__elements...) { }\n+\n+     template<typename... _UElements>\n+       tuple(const tuple<_UElements...>& __in)\n+         : _Inherited(__in) { }\n+\n+     tuple(const tuple& __in)\n+         : _Inherited(__in) { }\n+\n+     template<typename... _UElements>\n+       tuple& operator=(const tuple<_UElements...>& __in)\n+       {\n+         static_cast<_Inherited&>(*this) = __in;\n+         return *this;\n+       }\n+\n+     tuple& operator=(const tuple& __in)\n+     {\n+       static_cast<_Inherited&>(*this) = __in;\n+       return *this;\n+     }\n    };\n \n- template<typename _Tp>\n-   struct __strip_reference_wrapper<reference_wrapper<_Tp> >\n+ template<> class tuple<> { };\n+\n+ // 2-element tuple, with construction and assignment from a pair.\n+ template<typename _T1, typename _T2>\n+   class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>\n    {\n-     typedef _Tp& __type;\n+     typedef _Tuple_impl<0, _T1, _T2> _Inherited;\n+\n+   public:\n+     tuple() : _Inherited() { }\n+\n+     explicit\n+     tuple(typename __add_c_ref<_T1>::type __a1,\n+           typename __add_c_ref<_T2>::type __a2)\n+       : _Inherited(__a1, __a2) { }\n+\n+     template<typename _U1, typename _U2>\n+       tuple(const tuple<_U1, _U2>& __in)\n+         : _Inherited(__in) { }\n+\n+     tuple(const tuple& __in)\n+         : _Inherited(__in) { }\n+\n+     template<typename _U1, typename _U2>\n+       tuple(const pair<_U1, _U2>& __in)\n+         : _Inherited(\n+             _Tuple_impl<0, \n+                         typename __add_c_ref<_U1>::type,\n+                         typename __add_c_ref<_U2>::type>(__in.first, \n+                                                          __in.second))\n+       { \n+       }\n+  \n+     template<typename _U1, typename _U2>\n+       tuple& operator=(const tuple<_U1, _U2>& __in)\n+       {\n+         static_cast<_Inherited&>(*this) = __in;\n+         return *this;\n+       }\n+\n+     tuple& operator=(const tuple& __in)\n+     {\n+       static_cast<_Inherited&>(*this) = __in;\n+       return *this;\n+     }\n+\n+     template<typename _U1, typename _U2>\n+       tuple& operator=(const pair<_U1, _U2>& __in)\n+     {\n+       this->_M_head = __in.first;\n+       this->_M_tail()._M_head = __in.second;\n+       return *this;\n+     }\n    };\n \n+\n+ /// Gives the type of the ith element of a given tuple type.\n+ template<int __i, typename _Tp>\n+   struct tuple_element;\n+\n+ /**\n+  * @if maint\n+  * Recursive case for tuple_element: strip off the first element in\n+  * the tuple and retrieve the (i-1)th element of the remaining tuple.\n+  * @endif\n+  */\n+ template<int __i, typename _Head, typename... _Tail>\n+   struct tuple_element<__i, tuple<_Head, _Tail...> >\n+     : tuple_element<__i - 1, tuple<_Tail...> > { };\n+\n+ /**\n+  * @if maint\n+  * Basis case for tuple_element: The first element is the one we're seeking.\n+  * @endif\n+  */\n+ template<typename _Head, typename... _Tail>\n+   struct tuple_element<0, tuple<_Head, _Tail...> >\n+   {\n+     typedef _Head type;\n+   };\n+\n+ /// Finds the size of a given tuple type.\n  template<typename _Tp>\n-   struct __strip_reference_wrapper<const reference_wrapper<_Tp> >\n+   struct tuple_size;\n+\n+  /// @brief class tuple_size\n+ template<typename... _Elements>\n+   struct tuple_size<tuple<_Elements...> >\n    {\n-       typedef _Tp& __type;\n+     static const int value = sizeof...(_Elements);\n    };\n \n-  #include \"tuple_defs.h\"\n+ // Returns a const reference to the ith element of a tuple.\n+ // Any const or non-const ref elements are returned with their original type.\n+ template<int __i, typename _Head, typename... _Tail>\n+   inline typename __add_ref<_Head>::type\n+     get(_Tuple_impl<__i, _Head, _Tail...>& __t)\n+     {\n+       return __t._M_head;\n+     }\n+\n+ template<int __i, typename _Head, typename... _Tail>\n+   inline typename __add_c_ref<_Head>::type\n+     get(const _Tuple_impl<__i, _Head, _Tail...>& __t)\n+     {\n+       return __t._M_head;\n+     }\n+\n+ // This class helps construct the various comparison operations on tuples\n+ template<int __check_equal_size, int __i, int __j, typename _Tp, typename _Up>\n+   struct __tuple_compare;\n \n  template<int __i, int __j, typename _Tp, typename _Up>\n    struct __tuple_compare<0, __i, __j, _Tp, _Up>\n@@ -129,6 +304,80 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n      { return false; }\n    };\n \n+ template<typename... _TElements, typename... _UElements>\n+ bool\n+ operator==(const tuple<_TElements...>& __t, const tuple<_UElements...>& __u)\n+ {\n+   typedef tuple<_TElements...> _Tp;\n+   typedef tuple<_UElements...> _Up;\n+   return __tuple_compare<tuple_size<_Tp>::value - tuple_size<_Tp>::value, 0,\n+                          tuple_size<_Tp>::value, _Tp, _Up>::__eq(__t, __u);\n+ }\n+\n+ template<typename... _TElements, typename... _UElements>\n+ bool\n+ operator<(const tuple<_TElements...>& __t, const tuple<_UElements...>& __u)\n+ {\n+   typedef tuple<_TElements...> _Tp;\n+   typedef tuple<_UElements...> _Up;\n+   return __tuple_compare<tuple_size<_Tp>::value - tuple_size<_Tp>::value, 0,\n+                          tuple_size<_Tp>::value, _Tp, _Up>::__less(__t, __u);\n+ }\n+\n+ template<typename... _TElements, typename... _UElements>\n+ bool\n+ operator!=(const tuple<_TElements...>& __t, const tuple<_UElements...>& __u)\n+ { return !(__t == __u); }\n+\n+ template<typename... _TElements, typename... _UElements>\n+ bool\n+ operator>(const tuple<_TElements...>& __t, const tuple<_UElements...>& __u)\n+ { return __u < __t; }\n+\n+ template<typename... _TElements, typename... _UElements>\n+ bool\n+ operator<=(const tuple<_TElements...>& __t, const tuple<_UElements...>& __u)\n+ { return !(__u < __t); }\n+\n+ template<typename... _TElements, typename... _UElements>\n+ bool\n+ operator>=(const tuple<_TElements...>& __t, const tuple<_UElements...>& __u)\n+ { return !(__t < __u); }\n+\n+ // Helper which adds a reference to a type when given a reference_wrapper\n+ template<typename _Tp>\n+   struct __strip_reference_wrapper\n+   {\n+       typedef _Tp __type;\n+   };\n+\n+ template<typename _Tp>\n+   struct __strip_reference_wrapper<reference_wrapper<_Tp> >\n+   {\n+     typedef _Tp& __type;\n+   };\n+\n+ template<typename _Tp>\n+   struct __strip_reference_wrapper<const reference_wrapper<_Tp> >\n+   {\n+       typedef _Tp& __type;\n+   };\n+\n+  template<typename... _Elements>\n+    inline tuple<typename __strip_reference_wrapper<_Elements>::__type...>\n+    make_tuple(_Elements... __args)\n+    {\n+      typedef tuple<typename __strip_reference_wrapper<_Elements>::__type...>\n+        __result_type;\n+      return __result_type(__args...);\n+    }\n+\n+  template<typename... _Elements>\n+    inline tuple<_Elements&...> tie(_Elements&... __args)\n+    {\n+      return tuple<_Elements&...>(__args...);\n+    }\n+\n  // A class (and instance) which can be used in 'tie' when an element\n  // of a tuple is not required\n  struct swallow_assign\n@@ -148,14 +397,6 @@ _GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n _GLIBCXX_END_NAMESPACE\n }\n \n-#define _GLIBCXX_CAT(x,y) _GLIBCXX_CAT2(x,y)\n-#define _GLIBCXX_CAT2(x,y) x##y\n-#define _SHORT_REPEAT\n-#define _GLIBCXX_REPEAT_HEADER <tr1/tuple_iterate.h>\n-#include <tr1/repeat.h>\n-#undef _GLIBCXX_REPEAT_HEADER\n-#undef _SHORT_REPEAT\n-\n #include <tr1/functional>\n \n #endif"}, {"sha": "4a9e494bad247143310430af06b73f39abdadc73", "filename": "libstdc++-v3/include/tr1/tuple_iterate.h", "status": "removed", "additions": 0, "deletions": 172, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6a85c8dd4854845630569bbec6437170c3bc246/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple_iterate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6a85c8dd4854845630569bbec6437170c3bc246/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple_iterate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple_iterate.h?ref=d6a85c8dd4854845630569bbec6437170c3bc246", "patch": "@@ -1,172 +0,0 @@\n-// class template tuple -*- C++ -*-\n-\n-// Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file tr1/tuple_iterate.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-// Chris Jefferson <chris@bubblescope.net>\n-\n-namespace std\n-{\n-_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n-\n-/// @brief class tuple_size\n-template<_GLIBCXX_TEMPLATE_PARAMS>\n-  struct tuple_size<tuple<_GLIBCXX_TEMPLATE_ARGS> >\n-  { static const int value = _GLIBCXX_NUM_ARGS; };\n-\n-#if _GLIBCXX_NUM_ARGS > 0\n-template<_GLIBCXX_TEMPLATE_PARAMS>\n-  const int tuple_size<tuple<_GLIBCXX_TEMPLATE_ARGS> >::value;\n-#endif\n-\n-template<_GLIBCXX_TEMPLATE_PARAMS>\n-#ifdef _GLIBCXX_LAST_INCLUDE\n-  class tuple\n-#else\n-  class tuple<_GLIBCXX_TEMPLATE_ARGS>\n-#endif\n-  {\n-    _GLIBCXX_BIND_MEMBERS\n-\n-  public:\n-    tuple()\n-    { }\n-\n-#if _GLIBCXX_NUM_ARGS == 2\n-    template<typename _U1, typename _U2>\n-      tuple(const std::pair<_U1, _U2>& __u) :\n-      _M_arg1(__u.first), _M_arg2(__u.second)\n-      { }\n-\n-    template<typename _U1, typename _U2>\n-      tuple&\n-      operator=(const std::pair<_U1, _U2>& __u)\n-      { \n-\t_M_arg1 = __u.first;\n-\t_M_arg2 = __u.second;\n-\treturn *this;\n-      }\n-#endif\n-\n-#if _GLIBCXX_NUM_ARGS > 0\n-    explicit tuple(_GLIBCXX_TUPLE_ADD_CREF) :\n-      _GLIBCXX_BIND_MEMBERS_INIT\n-    { }\n-\n-    template<_GLIBCXX_TEMPLATE_PARAMS_U>\n-      tuple(const tuple<_GLIBCXX_TEMPLATE_ARGS_U>& __in) :\n-      _GLIBCXX_TUPLE_COPY_INIT\n-    { }\n-\n-\n-    template<_GLIBCXX_TEMPLATE_PARAMS_U>\n-      tuple&\n-      operator=(const tuple<_GLIBCXX_TEMPLATE_ARGS_U>& __in)\n-      {\n-        _GLIBCXX_TUPLE_ASSIGN\n-        return *this;\n-      }\n-\n-    tuple(const tuple& __in) :\n-      _GLIBCXX_TUPLE_COPY_INIT\n-    { }\n-\n-#else\n-\n-    tuple(const tuple&)\n-    { }\n-\n-#endif\n-\n-    tuple&\n-    operator=(const tuple& __in __attribute__((__unused__)) )\n-    {\n-      _GLIBCXX_TUPLE_ASSIGN\n-        return *this;\n-    }\n-\n-    template<int __i, typename __Type>\n-      friend class __get_helper;\n-\n-    template<_GLIBCXX_TUPLE_ALL_TEMPLATE_PARAMS_UNNAMED>\n-      friend class tuple;\n-  };\n-\n-#ifndef _GLIBCXX_LAST_INCLUDE\n-\n-template<typename _Tp>\n-    struct __get_helper<_GLIBCXX_NUM_ARGS, _Tp>\n-    {\n-      static typename __add_ref<typename tuple_element<_GLIBCXX_NUM_ARGS,\n-                                                       _Tp>::type>::type\n-      get_value(_Tp& __in)\n-      { return __in._GLIBCXX_CAT(_M_arg,_GLIBCXX_NUM_ARGS_PLUS_1); }\n-\n-      static typename __add_c_ref<typename tuple_element<_GLIBCXX_NUM_ARGS,\n-                                                         _Tp>::type>::type\n-      get_value(const _Tp& __in)\n-      { return __in._GLIBCXX_CAT(_M_arg,_GLIBCXX_NUM_ARGS_PLUS_1); }\n-    };\n-\n-/// @brief class tuple_element\n-template<_GLIBCXX_TUPLE_ALL_TEMPLATE_PARAMS>\n-   struct tuple_element<_GLIBCXX_NUM_ARGS, tuple<_GLIBCXX_TUPLE_ALL_TEMPLATE_ARGS> >\n-  { typedef _GLIBCXX_T_NUM_ARGS_PLUS_1 type; };\n-\n-#endif\n-#if _GLIBCXX_NUM_ARGS == 0\n-\n-tuple<>\n-inline make_tuple()\n-{ return tuple<>(); }\n-\n-tuple<>\n-inline tie()\n-{ return tuple<>(); }\n-#else\n-\n-template<_GLIBCXX_TEMPLATE_PARAMS>\n-  typename __stripped_tuple_type<_GLIBCXX_TEMPLATE_ARGS>::__type\n-  inline make_tuple(_GLIBCXX_PARAMS)\n-  {\n-    return typename __stripped_tuple_type<_GLIBCXX_TEMPLATE_ARGS>::\n-      __type(_GLIBCXX_ARGS);\n-  }\n-\n-template<_GLIBCXX_TEMPLATE_PARAMS>\n-  tuple<_GLIBCXX_REF_TEMPLATE_ARGS>\n-  inline tie(_GLIBCXX_REF_PARAMS)\n-  { return make_tuple(_GLIBCXX_REF_WRAP_PARAMS); }\n-#endif\n-\n-_GLIBCXX_END_NAMESPACE\n-}"}]}