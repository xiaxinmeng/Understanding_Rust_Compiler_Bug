{"sha": "59415997a39850db94ecb3b67ebda2390be45632", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk0MTU5OTdhMzk4NTBkYjk0ZWNiM2I2N2ViZGEyMzkwYmU0NTYzMg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-01-17T21:03:57Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-01-17T21:03:57Z"}, "message": "Makefile.in: Remove rule for ggc-simple.o.\n\n\t* Makefile.in: Remove rule for ggc-simple.o.\n\t* configure.ac: Don't allow ggc-simple to be selected.\n\t* configure: Regenerate.\n\t* ggc-simple.c: Remove.\n\nFrom-SVN: r76058", "tree": {"sha": "63b48fae261bbac6b142021e037dfc2ad2d97f6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63b48fae261bbac6b142021e037dfc2ad2d97f6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59415997a39850db94ecb3b67ebda2390be45632", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59415997a39850db94ecb3b67ebda2390be45632", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59415997a39850db94ecb3b67ebda2390be45632", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59415997a39850db94ecb3b67ebda2390be45632/comments", "author": null, "committer": null, "parents": [{"sha": "95727fb877e650d1d4be5798151a2cde09cd0553", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95727fb877e650d1d4be5798151a2cde09cd0553", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95727fb877e650d1d4be5798151a2cde09cd0553"}], "stats": {"total": 576, "additions": 4, "deletions": 572}, "files": [{"sha": "eab066110fd383db1c0b557b89465f406273ee3e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59415997a39850db94ecb3b67ebda2390be45632/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59415997a39850db94ecb3b67ebda2390be45632/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=59415997a39850db94ecb3b67ebda2390be45632", "patch": "@@ -1459,9 +1459,6 @@ gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) varray.h\n ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GGC_H) \\\n \t$(HASHTAB_H) toplev.h $(PARAMS_H) hosthooks.h\n \n-ggc-simple.o: ggc-simple.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n-\tflags.h $(GGC_H) varray.h $(TIMEVAR_H) $(TM_P_H) $(PARAMS_H)\n-\n ggc-page.o: ggc-page.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n \tflags.h toplev.h $(GGC_H) $(TIMEVAR_H) $(TM_P_H) $(PARAMS_H)\n "}, {"sha": "e703d0831020dbf9f0763ecdc474008726dafc71", "filename": "gcc/configure", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59415997a39850db94ecb3b67ebda2390be45632/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59415997a39850db94ecb3b67ebda2390be45632/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=59415997a39850db94ecb3b67ebda2390be45632", "patch": "@@ -909,7 +909,7 @@ Optional Packages:\n   --with-dwarf2           force the default debug format to be DWARF 2\n   --with-sysroot=DIR Search for usr/lib, usr/include, et al, within DIR.\n   --with-libiconv-prefix=DIR  search for libiconv in DIR/include and DIR/lib\n-  --with-gc={simple,page,zone} choose the garbage collection mechanism to use\n+  --with-gc={page,zone}   choose the garbage collection mechanism to use\n                           with the compiler\n   --with-system-zlib      use installed libz\n   --with-slibdir=DIR      shared libraries in DIR LIBDIR\n@@ -11297,7 +11297,7 @@ fi\n if test \"${with_gc+set}\" = set; then\n   withval=\"$with_gc\"\n   case \"$withval\" in\n-  simple | page | zone)\n+  page | zone)\n     GGC=ggc-$withval\n     ;;\n   *)"}, {"sha": "3c9d1729c4ed31b2307ad6731eb64d8e6681db75", "filename": "gcc/configure.ac", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59415997a39850db94ecb3b67ebda2390be45632/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59415997a39850db94ecb3b67ebda2390be45632/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=59415997a39850db94ecb3b67ebda2390be45632", "patch": "@@ -2710,10 +2710,10 @@ AC_SUBST(gthread_flags)\n \n # Find out what GC implementation we want, or may, use.\n AC_ARG_WITH(gc,\n-[  --with-gc={simple,page,zone} choose the garbage collection mechanism to use\n+[  --with-gc={page,zone}   choose the garbage collection mechanism to use\n                           with the compiler],\n [case \"$withval\" in\n-  simple | page | zone)\n+  page | zone)\n     GGC=ggc-$withval\n     ;;\n   *)"}, {"sha": "2f75021f42dd14d8a476a020a71d35c591051039", "filename": "gcc/ggc-simple.c", "status": "removed", "additions": 0, "deletions": 565, "changes": 565, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95727fb877e650d1d4be5798151a2cde09cd0553/gcc%2Fggc-simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95727fb877e650d1d4be5798151a2cde09cd0553/gcc%2Fggc-simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-simple.c?ref=95727fb877e650d1d4be5798151a2cde09cd0553", "patch": "@@ -1,565 +0,0 @@\n-/* Simple garbage collection for the GNU compiler.\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003\n-   Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING.  If not, write to the Free\n-   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-   02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"tree.h\"\n-#include \"tm_p.h\"\n-#include \"flags.h\"\n-#include \"varray.h\"\n-#include \"ggc.h\"\n-#include \"toplev.h\"\n-#include \"timevar.h\"\n-#include \"params.h\"\n-\n-/* Debugging flags.  */\n-\n-/* Zap memory before freeing to catch dangling pointers.  */\n-#undef GGC_POISON\n-\n-/* Collect statistics on how bushy the search tree is.  */\n-#undef GGC_BALANCE\n-\n-/* Always verify that the to-be-marked memory is collectable.  */\n-#undef GGC_ALWAYS_VERIFY\n-\n-#ifdef ENABLE_GC_CHECKING\n-#define GGC_POISON\n-#define GGC_ALWAYS_VERIFY\n-#endif\n-\n-#ifndef HOST_BITS_PER_PTR\n-#define HOST_BITS_PER_PTR  HOST_BITS_PER_LONG\n-#endif\n-\n-/* We'd like a balanced tree, but we don't really want to pay for the\n-   cost of keeping the tree balanced.  We'll settle for the next best\n-   thing -- nearly balanced.\n-\n-   In this context, the most natural key is the node pointer itself,\n-   but due to the way memory managers work, we'd be virtually certain\n-   to wind up with a completely degenerate straight line.  What's needed\n-   is to make something more variable, and yet predictable, be more\n-   significant in the comparison.\n-\n-   The handiest source of variability is the low bits of the pointer\n-   value itself.  Any sort of bit/byte swap would do, but such machine\n-   specific operations are not handy, and we don't want to put that much\n-   effort into it.  */\n-\n-#define PTR_KEY(p)\t((size_t)p << (HOST_BITS_PER_PTR - 8)\t\t    \\\n-\t\t\t | ((size_t)p & 0xff00) << (HOST_BITS_PER_PTR - 24) \\\n-\t\t\t | (size_t)p >> 16)\n-\n-/* GC'able memory; a node in a binary search tree.  */\n-\n-struct ggc_mem\n-{\n-  /* A combination of the standard left/right nodes, indexable by `<'.  */\n-  struct ggc_mem *sub[2];\n-\n-  unsigned int mark : 1;\n-  unsigned int context : 7;\n-  unsigned int size : 24;\n-\n-  /* Make sure the data is reasonably aligned.  */\n-  union {\n-    HOST_WIDEST_INT i;\n-    long double d;\n-  } u;\n-};\n-\n-static struct globals\n-{\n-  /* Root of the object tree.  */\n-  struct ggc_mem *root;\n-\n-  /* Data bytes currently allocated.  */\n-  size_t allocated;\n-\n-  /* Data objects currently allocated.  */\n-  size_t objects;\n-\n-  /* Data bytes allocated at time of last GC.  */\n-  size_t allocated_last_gc;\n-\n-  /* Current context level.  */\n-  int context;\n-} G;\n-\n-/* Local function prototypes.  */\n-\n-static void tree_insert (struct ggc_mem *);\n-static int tree_lookup (struct ggc_mem *);\n-static void clear_marks (struct ggc_mem *);\n-static void sweep_objs (struct ggc_mem **);\n-static void ggc_pop_context_1 (struct ggc_mem *, int);\n-\n-/* For use from debugger.  */\n-extern void debug_ggc_tree (struct ggc_mem *, int);\n-\n-#ifdef GGC_BALANCE\n-extern void debug_ggc_balance (void);\n-#endif\n-static void tally_leaves (struct ggc_mem *, int, size_t *, size_t *);\n-\n-/* Insert V into the search tree.  */\n-\n-static inline void\n-tree_insert (struct ggc_mem *v)\n-{\n-  size_t v_key = PTR_KEY (v);\n-  struct ggc_mem *p, **pp;\n-\n-  for (pp = &G.root, p = *pp; p ; p = *pp)\n-    {\n-      size_t p_key = PTR_KEY (p);\n-      pp = &p->sub[v_key < p_key];\n-    }\n-  *pp = v;\n-}\n-\n-/* Return true if V is in the tree.  */\n-\n-static inline int\n-tree_lookup (struct ggc_mem *v)\n-{\n-  size_t v_key = PTR_KEY (v);\n-  struct ggc_mem *p = G.root;\n-\n-  while (p)\n-    {\n-      size_t p_key = PTR_KEY (p);\n-      if (p == v)\n-\treturn 1;\n-      p = p->sub[v_key < p_key];\n-    }\n-\n-  return 0;\n-}\n-\n-/* Alloc SIZE bytes of GC'able memory.  If ZERO, clear the memory.  */\n-\n-void *\n-ggc_alloc (size_t size)\n-{\n-  struct ggc_mem *x;\n-\n-  x = xmalloc (offsetof (struct ggc_mem, u) + size);\n-  x->sub[0] = NULL;\n-  x->sub[1] = NULL;\n-  x->mark = 0;\n-  x->context = G.context;\n-  x->size = size;\n-\n-#ifdef GGC_POISON\n-  memset (&x->u, 0xaf, size);\n-#endif\n-\n-  tree_insert (x);\n-  G.allocated += size;\n-  G.objects += 1;\n-\n-  return &x->u;\n-}\n-\n-/* Mark a node.  */\n-\n-int\n-ggc_set_mark (const void *p)\n-{\n-  struct ggc_mem *x;\n-\n-  x = (struct ggc_mem *) ((const char *)p - offsetof (struct ggc_mem, u));\n-#ifdef GGC_ALWAYS_VERIFY\n-  if (! tree_lookup (x))\n-    abort ();\n-#endif\n-\n-  if (x->mark)\n-    return 1;\n-\n-  x->mark = 1;\n-  G.allocated += x->size;\n-  G.objects += 1;\n-\n-  return 0;\n-}\n-\n-/* Return 1 if P has been marked, zero otherwise.  */\n-\n-int\n-ggc_marked_p (const void *p)\n-{\n-  struct ggc_mem *x;\n-\n-  x = (struct ggc_mem *) ((const char *)p - offsetof (struct ggc_mem, u));\n-#ifdef GGC_ALWAYS_VERIFY\n-  if (! tree_lookup (x))\n-    abort ();\n-#endif\n-\n-   return x->mark;\n-}\n-\n-/* Return the size of the gc-able object P.  */\n-\n-size_t\n-ggc_get_size (const void *p)\n-{\n-  struct ggc_mem *x\n-    = (struct ggc_mem *) ((const char *)p - offsetof (struct ggc_mem, u));\n-  return x->size;\n-}\n-\n-/* Unmark all objects.  */\n-\n-static void\n-clear_marks (struct ggc_mem *x)\n-{\n-  x->mark = 0;\n-  if (x->sub[0])\n-    clear_marks (x->sub[0]);\n-  if (x->sub[1])\n-    clear_marks (x->sub[1]);\n-}\n-\n-/* Free all objects in the current context that are not marked.  */\n-\n-static void\n-sweep_objs (struct ggc_mem **root)\n-{\n-  struct ggc_mem *x = *root;\n-  if (!x)\n-    return;\n-\n-  sweep_objs (&x->sub[0]);\n-  sweep_objs (&x->sub[1]);\n-\n-  if (! x->mark && x->context >= G.context)\n-    {\n-      struct ggc_mem *l, *r;\n-\n-      l = x->sub[0];\n-      r = x->sub[1];\n-      if (!l)\n-\t*root = r;\n-      else if (!r)\n-\t*root = l;\n-      else if (!l->sub[1])\n-\t{\n-\t  *root = l;\n-\t  l->sub[1] = r;\n-\t}\n-      else if (!r->sub[0])\n-\t{\n-\t  *root = r;\n-\t  r->sub[0] = l;\n-\t}\n-      else\n-\t{\n-\t  *root = l;\n-\t  do {\n-\t    root = &l->sub[1];\n-\t  } while ((l = *root) != NULL);\n-\t  *root = r;\n-\t}\n-\n-#ifdef GGC_POISON\n-      memset (&x->u, 0xA5, x->size);\n-#endif\n-\n-      free (x);\n-    }\n-}\n-\n-/* The top level mark-and-sweep routine.  */\n-\n-void\n-ggc_collect (void)\n-{\n-  /* Avoid frequent unnecessary work by skipping collection if the\n-     total allocations haven't expanded much since the last\n-     collection.  */\n-  size_t allocated_last_gc =\n-    MAX (G.allocated_last_gc, (size_t)PARAM_VALUE (GGC_MIN_HEAPSIZE) * 1024);\n-\n-  size_t min_expand = allocated_last_gc * PARAM_VALUE (GGC_MIN_EXPAND) / 100;\n-\n-  if (G.allocated < allocated_last_gc + min_expand)\n-    return;\n-\n-#ifdef GGC_BALANCE\n-  debug_ggc_balance ();\n-#endif\n-\n-  timevar_push (TV_GC);\n-  if (!quiet_flag)\n-    fprintf (stderr, \" {GC %luk -> \", (unsigned long)G.allocated / 1024);\n-\n-  G.allocated = 0;\n-  G.objects = 0;\n-\n-  clear_marks (G.root);\n-  ggc_mark_roots ();\n-  sweep_objs (&G.root);\n-\n-  G.allocated_last_gc = G.allocated;\n-\n-  timevar_pop (TV_GC);\n-\n-  if (!quiet_flag)\n-    fprintf (stderr, \"%luk}\", (unsigned long) G.allocated / 1024);\n-\n-#ifdef GGC_BALANCE\n-  debug_ggc_balance ();\n-#endif\n-}\n-\n-/* Called once to initialize the garbage collector.  */\n-\n-void\n-init_ggc (void)\n-{\n-}\n-\n-/* Start a new GGC zone.  */\n-\n-struct alloc_zone *\n-new_ggc_zone (const char *name ATTRIBUTE_UNUSED)\n-{\n-  return NULL;\n-}\n-\n-/* Destroy a GGC zone.  */\n-void\n-destroy_ggc_zone (struct alloc_zone *zone ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-/* Start a new GGC context.  Memory allocated in previous contexts\n-   will not be collected while the new context is active.  */\n-\n-void\n-ggc_push_context (void)\n-{\n-  G.context++;\n-\n-  /* We only allocated 7 bits in the node for the context.  This\n-     should be more than enough.  */\n-  if (G.context >= 128)\n-    abort ();\n-}\n-\n-/* Finish a GC context.  Any uncollected memory in the new context\n-   will be merged with the old context.  */\n-\n-void\n-ggc_pop_context (void)\n-{\n-  G.context--;\n-  if (G.root)\n-    ggc_pop_context_1 (G.root, G.context);\n-}\n-\n-static void\n-ggc_pop_context_1 (struct ggc_mem *x, int c)\n-{\n-  if (x->context > c)\n-    x->context = c;\n-  if (x->sub[0])\n-    ggc_pop_context_1 (x->sub[0], c);\n-  if (x->sub[1])\n-    ggc_pop_context_1 (x->sub[1], c);\n-}\n-\n-/* Dump a tree.  */\n-\n-void\n-debug_ggc_tree (struct ggc_mem *p, int indent)\n-{\n-  int i;\n-\n-  if (!p)\n-    {\n-      fputs (\"(nil)\\n\", stderr);\n-      return;\n-    }\n-\n-  if (p->sub[0])\n-    debug_ggc_tree (p->sub[0], indent + 1);\n-\n-  for (i = 0; i < indent; ++i)\n-    putc (' ', stderr);\n-  fprintf (stderr, \"%lx %p\\n\", (unsigned long)PTR_KEY (p), (void *) p);\n-\n-  if (p->sub[1])\n-    debug_ggc_tree (p->sub[1], indent + 1);\n-}\n-\n-#ifdef GGC_BALANCE\n-/* Collect tree balance metrics  */\n-\n-#include <math.h>\n-\n-void\n-debug_ggc_balance (void)\n-{\n-  size_t nleaf, sumdepth;\n-\n-  nleaf = sumdepth = 0;\n-  tally_leaves (G.root, 0, &nleaf, &sumdepth);\n-\n-  fprintf (stderr, \" {B %.2f,%.1f,%.1f}\",\n-\t   /* In a balanced tree, leaf/node should approach 1/2.  */\n-\t   (float)nleaf / (float)G.objects,\n-\t   /* In a balanced tree, average leaf depth should approach lg(n).  */\n-\t   (float)sumdepth / (float)nleaf,\n-\t   log ((double) G.objects) / M_LN2);\n-}\n-#endif\n-\n-/* Used by debug_ggc_balance, and also by ggc_print_statistics.  */\n-static void\n-tally_leaves (struct ggc_mem *x, int depth, size_t *nleaf, size_t *sumdepth)\n-{\n-  if (! x->sub[0] && !x->sub[1])\n-    {\n-      *nleaf += 1;\n-      *sumdepth += depth;\n-    }\n-  else\n-    {\n-      if (x->sub[0])\n-\ttally_leaves (x->sub[0], depth + 1, nleaf, sumdepth);\n-      if (x->sub[1])\n-\ttally_leaves (x->sub[1], depth + 1, nleaf, sumdepth);\n-    }\n-}\n-\n-#define SCALE(x) ((unsigned long) ((x) < 1024*10 \\\n-\t\t  ? (x) \\\n-\t\t  : ((x) < 1024*1024*10 \\\n-\t\t     ? (x) / 1024 \\\n-\t\t     : (x) / (1024*1024))))\n-#define LABEL(x) ((x) < 1024*10 ? ' ' : ((x) < 1024*1024*10 ? 'k' : 'M'))\n-\n-/* Report on GC memory usage.  */\n-void\n-ggc_print_statistics (void)\n-{\n-  struct ggc_statistics stats;\n-  size_t nleaf = 0, sumdepth = 0;\n-\n-  /* Clear the statistics.  */\n-  memset (&stats, 0, sizeof (stats));\n-\n-  /* Make sure collection will really occur.  */\n-  G.allocated_last_gc = 0;\n-\n-  /* Collect and print the statistics common across collectors.  */\n-  ggc_print_common_statistics (stderr, &stats);\n-\n-  /* Report on tree balancing.  */\n-  tally_leaves (G.root, 0, &nleaf, &sumdepth);\n-\n-  fprintf (stderr, \"\\n\\\n-Total internal data (bytes)\\t%ld%c\\n\\\n-Number of leaves in tree\\t%lu\\n\\\n-Average leaf depth\\t\\t%.1f\\n\",\n-\t   SCALE(G.objects * offsetof (struct ggc_mem, u)),\n-\t   LABEL(G.objects * offsetof (struct ggc_mem, u)),\n-\t   (unsigned long)nleaf, (double)sumdepth / (double)nleaf);\n-\n-  /* Report overall memory usage.  */\n-  fprintf (stderr, \"\\n\\\n-Total objects allocated\\t\\t%ld\\n\\\n-Total memory in GC arena\\t%ld%c\\n\",\n-\t   (unsigned long)G.objects,\n-\t   SCALE(G.allocated), LABEL(G.allocated));\n-}\n-\f\n-struct ggc_pch_data *\n-init_ggc_pch (void)\n-{\n-  sorry (\"Generating PCH files is not supported when using ggc-simple.c\");\n-  /* It could be supported, but the code is not yet written.  */\n-  return NULL;\n-}\n-\n-void\n-ggc_pch_count_object (struct ggc_pch_data *d ATTRIBUTE_UNUSED,\n-\t\t      void *x ATTRIBUTE_UNUSED,\n-\t\t      size_t size ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-size_t\n-ggc_pch_total_size (struct ggc_pch_data *d ATTRIBUTE_UNUSED)\n-{\n-  return 0;\n-}\n-\n-void\n-ggc_pch_this_base (struct ggc_pch_data *d ATTRIBUTE_UNUSED,\n-\t\t   void *base ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-\n-char *\n-ggc_pch_alloc_object (struct ggc_pch_data *d ATTRIBUTE_UNUSED,\n-\t\t      void *x ATTRIBUTE_UNUSED,\n-\t\t      size_t size ATTRIBUTE_UNUSED)\n-{\n-  return NULL;\n-}\n-\n-void\n-ggc_pch_prepare_write (struct ggc_pch_data *d ATTRIBUTE_UNUSED,\n-\t\t       FILE * f ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-void\n-ggc_pch_write_object (struct ggc_pch_data *d ATTRIBUTE_UNUSED,\n-\t\t      FILE *f ATTRIBUTE_UNUSED, void *x ATTRIBUTE_UNUSED,\n-\t\t      void *newx ATTRIBUTE_UNUSED,\n-\t\t      size_t size ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-void\n-ggc_pch_finish (struct ggc_pch_data *d ATTRIBUTE_UNUSED,\n-\t\tFILE *f ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-void\n-ggc_pch_read (FILE *f ATTRIBUTE_UNUSED, void *addr ATTRIBUTE_UNUSED)\n-{\n-  /* This should be impossible, since we won't generate any valid PCH\n-     files for this configuration.  */\n-  abort ();\n-}"}]}