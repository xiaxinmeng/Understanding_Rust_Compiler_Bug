{"sha": "cc4d934fa0d16330f29953d7ad14ff71e15f0d1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M0ZDkzNGZhMGQxNjMzMGYyOTk1M2Q3YWQxNGZmNzFlMTVmMGQxYg==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2012-12-05T11:42:37Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2012-12-05T11:42:37Z"}, "message": "[AARCH64] Add zip{1, 2}, uzp{1, 2}, trn{1, 2} support \nfor vector permute.\n\ngcc/\n\n\t* config/aarch64/aarch64-simd-builtins.def: Add new builtins.\n\t* config/aarch64/aarch64-simd.md (simd_type): Add uzp.\n\t(aarch64_<PERMUTE:perm_insn><PERMUTE:perm_hilo><mode>): New.\n\t* config/aarch64/aarch64.c (aarch64_evpc_trn): New.\n\t(aarch64_evpc_uzp): Likewise.\n\t(aarch64_evpc_zip): Likewise.\n\t(aarch64_expand_vec_perm_const_1): Check for trn, zip, uzp patterns.\n\t* config/aarch64/iterators.md (unspec): Add neccessary unspecs.\n\t(PERMUTE): New.\n\t(perm_insn): Likewise.\n\t(perm_hilo): Likewise.\n\nFrom-SVN: r194219", "tree": {"sha": "8d38b0ce781601cf444ebe58a45a1bb2843aac2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d38b0ce781601cf444ebe58a45a1bb2843aac2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc4d934fa0d16330f29953d7ad14ff71e15f0d1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc4d934fa0d16330f29953d7ad14ff71e15f0d1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc4d934fa0d16330f29953d7ad14ff71e15f0d1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc4d934fa0d16330f29953d7ad14ff71e15f0d1b/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "88b080739aec46faddff05bb6f13fb2886c36aff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88b080739aec46faddff05bb6f13fb2886c36aff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88b080739aec46faddff05bb6f13fb2886c36aff"}], "stats": {"total": 319, "additions": 317, "deletions": 2}, "files": [{"sha": "0ba2ae1822d342963efaa6028999749caa0d5eed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc4d934fa0d16330f29953d7ad14ff71e15f0d1b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc4d934fa0d16330f29953d7ad14ff71e15f0d1b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc4d934fa0d16330f29953d7ad14ff71e15f0d1b", "patch": "@@ -1,3 +1,17 @@\n+2012-12-05  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* config/aarch64/aarch64-simd-builtins.def: Add new builtins.\n+\t* config/aarch64/aarch64-simd.md (simd_type): Add uzp.\n+\t(aarch64_<PERMUTE:perm_insn><PERMUTE:perm_hilo><mode>): New.\n+\t* config/aarch64/aarch64.c (aarch64_evpc_trn): New.\n+\t(aarch64_evpc_uzp): Likewise.\n+\t(aarch64_evpc_zip): Likewise.\n+\t(aarch64_expand_vec_perm_const_1): Check for trn, zip, uzp patterns.\n+\t* config/aarch64/iterators.md (unspec): Add neccessary unspecs.\n+\t(PERMUTE): New.\n+\t(perm_insn): Likewise.\n+\t(perm_hilo): Likewise.\n+\n 2012-12-05  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/aarch64/aarch64-protos.h"}, {"sha": "d441417b00ff084586f441d10960ad1f699e8bdf", "filename": "gcc/config/aarch64/aarch64-simd-builtins.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc4d934fa0d16330f29953d7ad14ff71e15f0d1b/gcc%2Fconfig%2Faarch64%2Faarch64-simd-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc4d934fa0d16330f29953d7ad14ff71e15f0d1b/gcc%2Fconfig%2Faarch64%2Faarch64-simd-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd-builtins.def?ref=cc4d934fa0d16330f29953d7ad14ff71e15f0d1b", "patch": "@@ -224,3 +224,12 @@\n   BUILTIN_VDQF (UNOP, fcvtpu)\n   BUILTIN_VDQF (UNOP, fcvtms)\n   BUILTIN_VDQF (UNOP, fcvtmu)\n+\n+  /* Implemented by\n+     aarch64_<PERMUTE:perm_insn><PERMUTE:perm_hilo><mode>.  */\n+  BUILTIN_VALL (BINOP, zip1)\n+  BUILTIN_VALL (BINOP, zip2)\n+  BUILTIN_VALL (BINOP, uzp1)\n+  BUILTIN_VALL (BINOP, uzp2)\n+  BUILTIN_VALL (BINOP, trn1)\n+  BUILTIN_VALL (BINOP, trn2)"}, {"sha": "febf71d37c464558e6b2cb1a3615314c2b8d71e8", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc4d934fa0d16330f29953d7ad14ff71e15f0d1b/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc4d934fa0d16330f29953d7ad14ff71e15f0d1b/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=cc4d934fa0d16330f29953d7ad14ff71e15f0d1b", "patch": "@@ -128,7 +128,8 @@\n ; simd_store4s          store single structure from one lane for four registers (ST4 [index]).\n ; simd_tbl              table lookup.\n ; simd_trn              transpose.\n-; simd_zip              zip/unzip.\n+; simd_uzp              unzip.\n+; simd_zip              zip.\n \n (define_attr \"simd_type\"\n    \"simd_abd,\\\n@@ -230,6 +231,7 @@\n    simd_store4s,\\\n    simd_tbl,\\\n    simd_trn,\\\n+   simd_uzp,\\\n    simd_zip,\\\n    none\"\n   (const_string \"none\"))\n@@ -3406,6 +3408,17 @@\n   DONE;\n })\n \n+(define_insn \"aarch64_<PERMUTE:perm_insn><PERMUTE:perm_hilo><mode>\"\n+  [(set (match_operand:VALL 0 \"register_operand\" \"=w\")\n+\t(unspec:VALL [(match_operand:VALL 1 \"register_operand\" \"w\")\n+\t\t      (match_operand:VALL 2 \"register_operand\" \"w\")]\n+\t\t       PERMUTE))]\n+  \"TARGET_SIMD\"\n+  \"<PERMUTE:perm_insn><PERMUTE:perm_hilo>\\\\t%0.<Vtype>, %1.<Vtype>, %2.<Vtype>\"\n+  [(set_attr \"simd_type\" \"simd_<PERMUTE:perm_insn>\")\n+   (set_attr \"simd_mode\" \"<MODE>\")]\n+)\n+\n (define_insn \"aarch64_st2<mode>_dreg\"\n   [(set (match_operand:TI 0 \"aarch64_simd_struct_operand\" \"=Utv\")\n \t(unspec:TI [(match_operand:OI 1 \"register_operand\" \"w\")"}, {"sha": "7bc2f6b896a083030ac759b6e52a29658ecb88b2", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 264, "deletions": 1, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc4d934fa0d16330f29953d7ad14ff71e15f0d1b/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc4d934fa0d16330f29953d7ad14ff71e15f0d1b/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=cc4d934fa0d16330f29953d7ad14ff71e15f0d1b", "patch": "@@ -6919,6 +6919,261 @@ aarch64_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel)\n   aarch64_expand_vec_perm_1 (target, op0, op1, sel);\n }\n \n+/* Recognize patterns suitable for the TRN instructions.  */\n+static bool\n+aarch64_evpc_trn (struct expand_vec_perm_d *d)\n+{\n+  unsigned int i, odd, mask, nelt = d->nelt;\n+  rtx out, in0, in1, x;\n+  rtx (*gen) (rtx, rtx, rtx);\n+  enum machine_mode vmode = d->vmode;\n+\n+  if (GET_MODE_UNIT_SIZE (vmode) > 8)\n+    return false;\n+\n+  /* Note that these are little-endian tests.\n+     We correct for big-endian later.  */\n+  if (d->perm[0] == 0)\n+    odd = 0;\n+  else if (d->perm[0] == 1)\n+    odd = 1;\n+  else\n+    return false;\n+  mask = (d->one_vector_p ? nelt - 1 : 2 * nelt - 1);\n+\n+  for (i = 0; i < nelt; i += 2)\n+    {\n+      if (d->perm[i] != i + odd)\n+\treturn false;\n+      if (d->perm[i + 1] != ((i + nelt + odd) & mask))\n+\treturn false;\n+    }\n+\n+  /* Success!  */\n+  if (d->testing_p)\n+    return true;\n+\n+  in0 = d->op0;\n+  in1 = d->op1;\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      x = in0, in0 = in1, in1 = x;\n+      odd = !odd;\n+    }\n+  out = d->target;\n+\n+  if (odd)\n+    {\n+      switch (vmode)\n+\t{\n+\tcase V16QImode: gen = gen_aarch64_trn2v16qi; break;\n+\tcase V8QImode: gen = gen_aarch64_trn2v8qi; break;\n+\tcase V8HImode: gen = gen_aarch64_trn2v8hi; break;\n+\tcase V4HImode: gen = gen_aarch64_trn2v4hi; break;\n+\tcase V4SImode: gen = gen_aarch64_trn2v4si; break;\n+\tcase V2SImode: gen = gen_aarch64_trn2v2si; break;\n+\tcase V2DImode: gen = gen_aarch64_trn2v2di; break;\n+\tcase V4SFmode: gen = gen_aarch64_trn2v4sf; break;\n+\tcase V2SFmode: gen = gen_aarch64_trn2v2sf; break;\n+\tcase V2DFmode: gen = gen_aarch64_trn2v2df; break;\n+\tdefault:\n+\t  return false;\n+\t}\n+    }\n+  else\n+    {\n+      switch (vmode)\n+\t{\n+\tcase V16QImode: gen = gen_aarch64_trn1v16qi; break;\n+\tcase V8QImode: gen = gen_aarch64_trn1v8qi; break;\n+\tcase V8HImode: gen = gen_aarch64_trn1v8hi; break;\n+\tcase V4HImode: gen = gen_aarch64_trn1v4hi; break;\n+\tcase V4SImode: gen = gen_aarch64_trn1v4si; break;\n+\tcase V2SImode: gen = gen_aarch64_trn1v2si; break;\n+\tcase V2DImode: gen = gen_aarch64_trn1v2di; break;\n+\tcase V4SFmode: gen = gen_aarch64_trn1v4sf; break;\n+\tcase V2SFmode: gen = gen_aarch64_trn1v2sf; break;\n+\tcase V2DFmode: gen = gen_aarch64_trn1v2df; break;\n+\tdefault:\n+\t  return false;\n+\t}\n+    }\n+\n+  emit_insn (gen (out, in0, in1));\n+  return true;\n+}\n+\n+/* Recognize patterns suitable for the UZP instructions.  */\n+static bool\n+aarch64_evpc_uzp (struct expand_vec_perm_d *d)\n+{\n+  unsigned int i, odd, mask, nelt = d->nelt;\n+  rtx out, in0, in1, x;\n+  rtx (*gen) (rtx, rtx, rtx);\n+  enum machine_mode vmode = d->vmode;\n+\n+  if (GET_MODE_UNIT_SIZE (vmode) > 8)\n+    return false;\n+\n+  /* Note that these are little-endian tests.\n+     We correct for big-endian later.  */\n+  if (d->perm[0] == 0)\n+    odd = 0;\n+  else if (d->perm[0] == 1)\n+    odd = 1;\n+  else\n+    return false;\n+  mask = (d->one_vector_p ? nelt - 1 : 2 * nelt - 1);\n+\n+  for (i = 0; i < nelt; i++)\n+    {\n+      unsigned elt = (i * 2 + odd) & mask;\n+      if (d->perm[i] != elt)\n+\treturn false;\n+    }\n+\n+  /* Success!  */\n+  if (d->testing_p)\n+    return true;\n+\n+  in0 = d->op0;\n+  in1 = d->op1;\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      x = in0, in0 = in1, in1 = x;\n+      odd = !odd;\n+    }\n+  out = d->target;\n+\n+  if (odd)\n+    {\n+      switch (vmode)\n+\t{\n+\tcase V16QImode: gen = gen_aarch64_uzp2v16qi; break;\n+\tcase V8QImode: gen = gen_aarch64_uzp2v8qi; break;\n+\tcase V8HImode: gen = gen_aarch64_uzp2v8hi; break;\n+\tcase V4HImode: gen = gen_aarch64_uzp2v4hi; break;\n+\tcase V4SImode: gen = gen_aarch64_uzp2v4si; break;\n+\tcase V2SImode: gen = gen_aarch64_uzp2v2si; break;\n+\tcase V2DImode: gen = gen_aarch64_uzp2v2di; break;\n+\tcase V4SFmode: gen = gen_aarch64_uzp2v4sf; break;\n+\tcase V2SFmode: gen = gen_aarch64_uzp2v2sf; break;\n+\tcase V2DFmode: gen = gen_aarch64_uzp2v2df; break;\n+\tdefault:\n+\t  return false;\n+\t}\n+    }\n+  else\n+    {\n+      switch (vmode)\n+\t{\n+\tcase V16QImode: gen = gen_aarch64_uzp1v16qi; break;\n+\tcase V8QImode: gen = gen_aarch64_uzp1v8qi; break;\n+\tcase V8HImode: gen = gen_aarch64_uzp1v8hi; break;\n+\tcase V4HImode: gen = gen_aarch64_uzp1v4hi; break;\n+\tcase V4SImode: gen = gen_aarch64_uzp1v4si; break;\n+\tcase V2SImode: gen = gen_aarch64_uzp1v2si; break;\n+\tcase V2DImode: gen = gen_aarch64_uzp1v2di; break;\n+\tcase V4SFmode: gen = gen_aarch64_uzp1v4sf; break;\n+\tcase V2SFmode: gen = gen_aarch64_uzp1v2sf; break;\n+\tcase V2DFmode: gen = gen_aarch64_uzp1v2df; break;\n+\tdefault:\n+\t  return false;\n+\t}\n+    }\n+\n+  emit_insn (gen (out, in0, in1));\n+  return true;\n+}\n+\n+/* Recognize patterns suitable for the ZIP instructions.  */\n+static bool\n+aarch64_evpc_zip (struct expand_vec_perm_d *d)\n+{\n+  unsigned int i, high, mask, nelt = d->nelt;\n+  rtx out, in0, in1, x;\n+  rtx (*gen) (rtx, rtx, rtx);\n+  enum machine_mode vmode = d->vmode;\n+\n+  if (GET_MODE_UNIT_SIZE (vmode) > 8)\n+    return false;\n+\n+  /* Note that these are little-endian tests.\n+     We correct for big-endian later.  */\n+  high = nelt / 2;\n+  if (d->perm[0] == high)\n+    /* Do Nothing.  */\n+    ;\n+  else if (d->perm[0] == 0)\n+    high = 0;\n+  else\n+    return false;\n+  mask = (d->one_vector_p ? nelt - 1 : 2 * nelt - 1);\n+\n+  for (i = 0; i < nelt / 2; i++)\n+    {\n+      unsigned elt = (i + high) & mask;\n+      if (d->perm[i * 2] != elt)\n+\treturn false;\n+      elt = (elt + nelt) & mask;\n+      if (d->perm[i * 2 + 1] != elt)\n+\treturn false;\n+    }\n+\n+  /* Success!  */\n+  if (d->testing_p)\n+    return true;\n+\n+  in0 = d->op0;\n+  in1 = d->op1;\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      x = in0, in0 = in1, in1 = x;\n+      high = !high;\n+    }\n+  out = d->target;\n+\n+  if (high)\n+    {\n+      switch (vmode)\n+\t{\n+\tcase V16QImode: gen = gen_aarch64_zip2v16qi; break;\n+\tcase V8QImode: gen = gen_aarch64_zip2v8qi; break;\n+\tcase V8HImode: gen = gen_aarch64_zip2v8hi; break;\n+\tcase V4HImode: gen = gen_aarch64_zip2v4hi; break;\n+\tcase V4SImode: gen = gen_aarch64_zip2v4si; break;\n+\tcase V2SImode: gen = gen_aarch64_zip2v2si; break;\n+\tcase V2DImode: gen = gen_aarch64_zip2v2di; break;\n+\tcase V4SFmode: gen = gen_aarch64_zip2v4sf; break;\n+\tcase V2SFmode: gen = gen_aarch64_zip2v2sf; break;\n+\tcase V2DFmode: gen = gen_aarch64_zip2v2df; break;\n+\tdefault:\n+\t  return false;\n+\t}\n+    }\n+  else\n+    {\n+      switch (vmode)\n+\t{\n+\tcase V16QImode: gen = gen_aarch64_zip1v16qi; break;\n+\tcase V8QImode: gen = gen_aarch64_zip1v8qi; break;\n+\tcase V8HImode: gen = gen_aarch64_zip1v8hi; break;\n+\tcase V4HImode: gen = gen_aarch64_zip1v4hi; break;\n+\tcase V4SImode: gen = gen_aarch64_zip1v4si; break;\n+\tcase V2SImode: gen = gen_aarch64_zip1v2si; break;\n+\tcase V2DImode: gen = gen_aarch64_zip1v2di; break;\n+\tcase V4SFmode: gen = gen_aarch64_zip1v4sf; break;\n+\tcase V2SFmode: gen = gen_aarch64_zip1v2sf; break;\n+\tcase V2DFmode: gen = gen_aarch64_zip1v2df; break;\n+\tdefault:\n+\t  return false;\n+\t}\n+    }\n+\n+  emit_insn (gen (out, in0, in1));\n+  return true;\n+}\n+\n static bool\n aarch64_evpc_tbl (struct expand_vec_perm_d *d)\n {\n@@ -6969,7 +7224,15 @@ aarch64_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n     }\n \n   if (TARGET_SIMD)\n-    return aarch64_evpc_tbl (d);\n+    {\n+      if (aarch64_evpc_zip (d))\n+\treturn true;\n+      else if (aarch64_evpc_uzp (d))\n+\treturn true;\n+      else if (aarch64_evpc_trn (d))\n+\treturn true;\n+      return aarch64_evpc_tbl (d);\n+    }\n   return false;\n }\n "}, {"sha": "0eb30f06c04f13bb81fe38d0e1c6fb4f3c3bccc4", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc4d934fa0d16330f29953d7ad14ff71e15f0d1b/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc4d934fa0d16330f29953d7ad14ff71e15f0d1b/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=cc4d934fa0d16330f29953d7ad14ff71e15f0d1b", "patch": "@@ -230,6 +230,12 @@\n     UNSPEC_BSL\t\t; Used in aarch64-simd.md.\n     UNSPEC_TBL\t\t; Used in vector permute patterns.\n     UNSPEC_CONCAT\t; Used in vector permute patterns.\n+    UNSPEC_ZIP1\t\t; Used in vector permute patterns.\n+    UNSPEC_ZIP2\t\t; Used in vector permute patterns.\n+    UNSPEC_UZP1\t\t; Used in vector permute patterns.\n+    UNSPEC_UZP2\t\t; Used in vector permute patterns.\n+    UNSPEC_TRN1\t\t; Used in vector permute patterns.\n+    UNSPEC_TRN2\t\t; Used in vector permute patterns.\n ])\n \n ;; -------------------------------------------------------------------\n@@ -652,6 +658,9 @@\n \n (define_int_iterator VCMP_U [UNSPEC_CMHS UNSPEC_CMHI UNSPEC_CMTST])\n \n+(define_int_iterator PERMUTE [UNSPEC_ZIP1 UNSPEC_ZIP2\n+\t\t\t      UNSPEC_TRN1 UNSPEC_TRN2\n+\t\t\t      UNSPEC_UZP1 UNSPEC_UZP2])\n \n (define_int_iterator FRINT [UNSPEC_FRINTZ UNSPEC_FRINTP UNSPEC_FRINTM\n \t\t\t     UNSPEC_FRINTI UNSPEC_FRINTX UNSPEC_FRINTA])\n@@ -757,3 +766,10 @@\n (define_int_attr fcvt_pattern [(UNSPEC_FRINTZ \"btrunc\") (UNSPEC_FRINTA \"round\")\n \t\t\t       (UNSPEC_FRINTP \"ceil\") (UNSPEC_FRINTM \"floor\")])\n \n+(define_int_attr perm_insn [(UNSPEC_ZIP1 \"zip\") (UNSPEC_ZIP2 \"zip\")\n+\t\t\t    (UNSPEC_TRN1 \"trn\") (UNSPEC_TRN2 \"trn\")\n+\t\t\t    (UNSPEC_UZP1 \"uzp\") (UNSPEC_UZP2 \"uzp\")])\n+\n+(define_int_attr perm_hilo [(UNSPEC_ZIP1 \"1\") (UNSPEC_ZIP2 \"2\")\n+\t\t\t    (UNSPEC_TRN1 \"1\") (UNSPEC_TRN2 \"2\")\n+\t\t\t    (UNSPEC_UZP1 \"1\") (UNSPEC_UZP2 \"2\")])"}]}