{"sha": "c81fc13e34621ae4506ffaae7d3b657aaeb17803", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzgxZmMxM2UzNDYyMWFlNDUwNmZmYWFlN2QzYjY1N2FhZWIxNzgwMw==", "commit": {"author": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "1999-09-28T18:13:58Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "1999-09-28T18:13:58Z"}, "message": "xcoffout.c (xcoffout_declare_function): Add documentation.\n\n\t* xcoffout.c (xcoffout_declare_function): Add documentation.\n\t* rs6000.c (num_insns_constant_wide): Use TARGET_POWERPC64 not\n\tTARGET_64BIT.  Compare constant to -1, not bit pattern.\n\t(easy_fp_constant): Use TARGET_POWERPC64 not TARGET_64BIT.\n\t(expand_block_move): Allow 8 DImode loads for PowerPC64.  Fix\n\tgen_movsi typos.\n\nFrom-SVN: r29697", "tree": {"sha": "a5283426fa9e3f304466e2eada188afb3ae944c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5283426fa9e3f304466e2eada188afb3ae944c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c81fc13e34621ae4506ffaae7d3b657aaeb17803", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c81fc13e34621ae4506ffaae7d3b657aaeb17803", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c81fc13e34621ae4506ffaae7d3b657aaeb17803", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c81fc13e34621ae4506ffaae7d3b657aaeb17803/comments", "author": null, "committer": null, "parents": [{"sha": "628d441075cef98809f0e2f661fb13810b7c85dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/628d441075cef98809f0e2f661fb13810b7c85dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/628d441075cef98809f0e2f661fb13810b7c85dc"}], "stats": {"total": 77, "additions": 47, "deletions": 30}, "files": [{"sha": "34e46329284e46957568b1567325ca165d4903ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81fc13e34621ae4506ffaae7d3b657aaeb17803/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81fc13e34621ae4506ffaae7d3b657aaeb17803/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c81fc13e34621ae4506ffaae7d3b657aaeb17803", "patch": "@@ -1,3 +1,12 @@\n+Tue Sep 28 16:45:40 1999  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* xcoffout.c (xcoffout_declare_function): Add documentation.\n+\t* rs6000.c (num_insns_constant_wide): Use TARGET_POWERPC64 not\n+\tTARGET_64BIT.  Compare constant to -1, not bit pattern.\n+\t(easy_fp_constant): Use TARGET_POWERPC64 not TARGET_64BIT.\n+\t(expand_block_move): Allow 8 DImode loads for PowerPC64.  Fix\n+\tgen_movsi typos.\n+\n Tue Sep 28 16:43:14 1999  Nick Clifton  <nickc@cygnus.com>\n \n \t* dwarf2out.c (add_abstract_origin_attribute): Abort if\n@@ -167,7 +176,7 @@ Fri Sep 24 11:57:06 1999  Geoffrey Keating  <geoffk@cygnus.com>\n \n Thu Sep 23 18:18:55 1999  Mark Mitchell  <mark@codesourcery.com>\n \n-\t* stmt.c (expand_start_bindings): Don't allow cleanup isntructions\n+\t* stmt.c (expand_start_bindings): Don't allow cleanup instructions\n \tto disappear.\n \n Thu Sep 23 18:07:01 1999  Mark Mitchell  <mark@codesourcery.com>"}, {"sha": "df18201969d5fd30af92de001c790d002ca3693b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81fc13e34621ae4506ffaae7d3b657aaeb17803/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81fc13e34621ae4506ffaae7d3b657aaeb17803/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c81fc13e34621ae4506ffaae7d3b657aaeb17803", "patch": "@@ -455,9 +455,9 @@ direct_return ()\n \n       if (info->first_gp_reg_save == 32\n \t  && info->first_fp_reg_save == 64\n-\t  && !info->lr_save_p\n-\t  && !info->cr_save_p\n-\t  && !info->push_p)\n+\t  && ! info->lr_save_p\n+\t  && ! info->cr_save_p\n+\t  && ! info->push_p)\n \treturn 1;\n     }\n \n@@ -676,18 +676,18 @@ num_insns_constant_wide (value)\n     return 1;\n \n #if HOST_BITS_PER_WIDE_INT == 64\n-  else if (TARGET_64BIT)\n+  else if (TARGET_POWERPC64)\n     {\n       HOST_WIDE_INT low  = value & 0xffffffff;\n       HOST_WIDE_INT high = value >> 32;\n \n       if (high == 0 && (low & 0x80000000) == 0)\n \treturn 2;\n \n-      else if (high == 0xffffffff && (low & 0x80000000) != 0)\n+      else if (high == -1 && (low & 0x80000000) != 0)\n \treturn 2;\n \n-      else if (!low)\n+      else if (! low)\n \treturn num_insns_constant_wide (high) + 1;\n \n       else\n@@ -748,8 +748,7 @@ num_insns_constant (op, mode)\n \t  if (high == 0 && (low & 0x80000000) == 0)\n \t    return num_insns_constant_wide (low);\n \n-\t  else if (((high & 0xffffffff) == 0xffffffff)\n-\t\t   && ((low & 0x80000000) != 0))\n+\t  else if (high == -1 && (low & 0x80000000) != 0)\n \t    return num_insns_constant_wide (low);\n \n \t  else if (mask64_operand (op, mode))\n@@ -820,7 +819,7 @@ easy_fp_constant (op, mode)\n     }\n \n   else if (mode == DImode)\n-    return ((TARGET_64BIT\n+    return ((TARGET_POWERPC64\n \t     && GET_CODE (op) == CONST_DOUBLE && CONST_DOUBLE_LOW (op) == 0)\n \t    || (num_insns_constant (op, DImode) <= 2));\n \n@@ -1132,7 +1131,7 @@ current_file_function_operand (op, mode)\n   return (GET_CODE (op) == SYMBOL_REF\n \t  && (SYMBOL_REF_FLAG (op)\n \t      || (op == XEXP (DECL_RTL (current_function_decl), 0)\n-\t          && !DECL_WEAK (current_function_decl))));\n+\t          && ! DECL_WEAK (current_function_decl))));\n }\n \n \n@@ -1549,7 +1548,7 @@ function_arg (cum, mode, type, named)\n \t           && function_arg_boundary (mode, type) == 64) ? 1 : 0;\n       int align_words = cum->words + align;\n \n-      if (!named)\n+      if (! named)\n \treturn NULL_RTX;\n \n       if (type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n@@ -1724,7 +1723,7 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n     }\n \n   set = get_varargs_alias_set ();\n-  if (!no_rtl && first_reg_offset < GP_ARG_NUM_REG)\n+  if (! no_rtl && first_reg_offset < GP_ARG_NUM_REG)\n     {\n       mem = gen_rtx_MEM (BLKmode,\n \t\t         plus_constant (save_area,\n@@ -1742,7 +1741,7 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n \n   /* Save FP registers if needed.  */\n   if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n-      && TARGET_HARD_FLOAT && !no_rtl\n+      && TARGET_HARD_FLOAT && ! no_rtl\n       && next_cum.fregno <= FP_ARG_V4_MAX_REG)\n     {\n       int fregno = next_cum.fregno;\n@@ -2087,13 +2086,19 @@ expand_block_move (operands)\n      then don't generate more than 8 loads.  */\n   if (TARGET_STRING)\n     {\n-      if (bytes > 4*8)\n+      if (bytes > 8*4)\n \treturn 0;\n     }\n   else if (! STRICT_ALIGNMENT)\n     {\n-      if (bytes > 4*8)\n-\treturn 0;\n+      if (TARGET_POWERPC64 && align >= 4)\n+\t{\n+\t  if (bytes > 8*8)\n+\t    return 0;\n+\t}\n+      else\n+\tif (bytes > 8*4)\n+\t  return 0;\n     }\n   else if (bytes > 8*align)\n     return 0;\n@@ -2290,7 +2295,7 @@ expand_block_move (operands)\n \t    {\n \t      move_bytes = 2;\n \t      tmp_reg = gen_reg_rtx (HImode);\n-\t      emit_insn (gen_movsi (tmp_reg,\n+\t      emit_insn (gen_movhi (tmp_reg,\n \t\t\t\t    expand_block_move_mem (HImode,\n \t\t\t\t\t\t\t   src_addr,\n \t\t\t\t\t\t\t   orig_src)));\n@@ -2303,7 +2308,7 @@ expand_block_move (operands)\n \t    {\n \t      move_bytes = 1;\n \t      tmp_reg = gen_reg_rtx (QImode);\n-\t      emit_insn (gen_movsi (tmp_reg,\n+\t      emit_insn (gen_movqi (tmp_reg,\n \t\t\t\t    expand_block_move_mem (QImode,\n \t\t\t\t\t\t\t   src_addr,\n \t\t\t\t\t\t\t   orig_src)));\n@@ -3919,16 +3924,16 @@ rs6000_stack_info ()\n   if (info_ptr->gp_size == 0)\n     info_ptr->gp_save_offset = 0;\n \n-  if (!info_ptr->lr_save_p)\n+  if (! info_ptr->lr_save_p)\n     info_ptr->lr_save_offset = 0;\n \n-  if (!info_ptr->cr_save_p)\n+  if (! info_ptr->cr_save_p)\n     info_ptr->cr_save_offset = 0;\n \n-  if (!info_ptr->toc_save_p)\n+  if (! info_ptr->toc_save_p)\n     info_ptr->toc_save_offset = 0;\n \n-  if (!info_ptr->main_save_p)\n+  if (! info_ptr->main_save_p)\n     info_ptr->main_save_offset = 0;\n \n   return info_ptr;\n@@ -3940,7 +3945,7 @@ debug_stack_info (info)\n {\n   const char *abi_string;\n \n-  if (!info)\n+  if (! info)\n     info = rs6000_stack_info ();\n \n   fprintf (stderr, \"\\nStack information for function %s:\\n\",\n@@ -4080,7 +4085,7 @@ rs6000_output_load_toc_table (file, reg)\n       fprintf (file, \"\\n\");\n \n       /* possibly create the toc section */\n-      if (!toc_initialized)\n+      if (! toc_initialized)\n \t{\n \t  toc_section ();\n \t  function_section (current_function_decl);\n@@ -4339,13 +4344,13 @@ output_prolog (file, size)\n   if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS) \n       && flag_pic == 1 && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n     {\n-      if (!info->lr_save_p)\n+      if (! info->lr_save_p)\n \tasm_fprintf (file, \"\\tmflr %s\\n\", reg_names[0]);\n \n       fputs (\"\\tbl _GLOBAL_OFFSET_TABLE_@local-4\\n\", file);\n       asm_fprintf (file, \"\\tmflr %s\\n\", reg_names[PIC_OFFSET_TABLE_REGNUM]);\n \n-      if (!info->lr_save_p)\n+      if (! info->lr_save_p)\n \tasm_fprintf (file, \"\\tmtlr %s\\n\", reg_names[0]);\n     }\n \n@@ -4459,7 +4464,7 @@ output_prolog (file, size)\n   if (TARGET_TOC && TARGET_MINIMAL_TOC && get_pool_size () != 0)\n     {\n #ifdef USING_SVR4_H\n-      if (!profile_flag)\n+      if (! profile_flag)\n \trs6000_pic_func_labelno = rs6000_pic_labelno;\n #endif\n       rs6000_output_load_toc_table (file, 30);\n@@ -5195,7 +5200,7 @@ output_toc (file, x, labelno)\n      a TOC reference to an unknown section.  Thus, for vtables only,\n      we emit the TOC reference to reference the symbol and not the\n      section.  */\n-  if (!strncmp (\"_vt.\", name, 4))\n+  if (! strncmp (\"_vt.\", name, 4))\n     {\n       RS6000_OUTPUT_BASENAME (file, name);\n       if (offset < 0)\n@@ -5983,7 +5988,7 @@ rs6000_encode_section_info (decl)\n     {\n       rtx sym_ref = XEXP (DECL_RTL (decl), 0);\n       if ((TREE_ASM_WRITTEN (decl) || ! TREE_PUBLIC (decl))\n-          && !DECL_WEAK (decl))\n+          && ! DECL_WEAK (decl))\n \tSYMBOL_REF_FLAG (sym_ref) = 1;\n \n       if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_NT)"}, {"sha": "6ee08ec2fb103aab4a534ad8dc8d80e4583799e5", "filename": "gcc/xcoffout.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81fc13e34621ae4506ffaae7d3b657aaeb17803/gcc%2Fxcoffout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81fc13e34621ae4506ffaae7d3b657aaeb17803/gcc%2Fxcoffout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.c?ref=c81fc13e34621ae4506ffaae7d3b657aaeb17803", "patch": "@@ -485,6 +485,9 @@ xcoffout_declare_function (file, decl, name)\n      file and/or at the wrong line number.  */\n   xcoffout_source_file (file, DECL_SOURCE_FILE (decl), 0);\n   dbxout_symbol (decl, 0);\n+\n+  /* .function NAME, TOP, MAPPING, TYPE, SIZE\n+     16 and 044 are placeholders for backwards compatibility */\n   fprintf (file, \"\\t.function .%s,.%s,16,044,FE..%s-.%s\\n\", n, n, n, n);\n }\n "}]}