{"sha": "e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkzY2E1Y2FkZWI3MWEwNGIyZjhlZjJlYmNiYWRiMmYwMjEzZDg3OA==", "commit": {"author": {"name": "Ramana Radhakrishnan", "email": "ramana.radhakrishnan@arm.com", "date": "2015-06-04T09:19:51Z"}, "committer": {"name": "Ramana Radhakrishnan", "email": "ramana@gcc.gnu.org", "date": "2015-06-04T09:19:51Z"}, "message": "Remove TARGET_RELAXED_ORDERING and optimize for weak memory models.\n\n\nThis patch removes the special casing for targets with relaxed\nmemory ordering and handles guard accesses with equivalent\natomic load acquire operations. In this process we change the\nalgorithm to load the guard variable with an atomic load that\nhas ACQUIRE semantics.\n\nThis then means that on targets which have weak memory models, the\nfast path is inlined and can directly use a load-acquire instruction\nwhere available (and yay! one more hook gone).\n\n2015-06-04  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n\n\tPR c++/66192\n\tPR target/66200\n\t* doc/tm.texi: Regenerate.\n\t* doc/tm.texi.in (TARGET_RELAXED_ORDERING): Delete.\n\t* target.def (TARGET_RELAXED_ORDERING): Likewise.\n\t* config/alpha/alpha.c (TARGET_RELAXED_ORDERING): Likewise.\n\t* config/ia64/ia64.c (TARGET_RELAXED_ORDERING): Likewise.\n\t* config/rs6000/rs6000.c (TARGET_RELAXED_ORDERING): Likewise.\n\t* config/sparc/linux.h (SPARC_RELAXED_ORDERING): Likewise.\n\t* config/sparc/linux64.h (SPARC_RELAXED_ORDERING): Likewise.\n\t* config/sparc/sparc.c (TARGET_RELAXED_ORDERING): Likewise.\n\t* config/sparc/sparc.h (SPARC_RELAXED_ORDERING): Likewise.\n\t* system.h (TARGET_RELAXED_ORDERING): Poison.\n\n2015-06-04  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n\n\tPR c++/66192\n\tPR target/66200\n\t* cp-tree.h (get_guard_cond): Adjust declaration\n\t* decl.c (expand_static_init): Use atomic load acquire\n\tand adjust call to get_guard_cond.\n\t* decl2.c (build_atomic_load_byte): New function.\n\t(get_guard_cond): Handle thread_safety.\n\t(one_static_initialization_or_destruction): Adjust call to\n\tget_guard_cond.\n\nFrom-SVN: r224118", "tree": {"sha": "b1f66152fa773d5b7dac557924b8c752070f198e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1f66152fa773d5b7dac557924b8c752070f198e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/comments", "author": null, "committer": null, "parents": [{"sha": "e2fc719399b507122ef4ea1867cff58e214be912", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2fc719399b507122ef4ea1867cff58e214be912", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2fc719399b507122ef4ea1867cff58e214be912"}], "stats": {"total": 161, "additions": 65, "deletions": 96}, "files": [{"sha": "53d75b1c69f6e8ffecc76b02862e446f0916fdf6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "patch": "@@ -1,3 +1,18 @@\n+2015-06-04  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+\n+\tPR c++/66192\n+\tPR target/66200\n+\t* doc/tm.texi: Regenerate.\n+\t* doc/tm.texi.in (TARGET_RELAXED_ORDERING): Delete.\n+\t* target.def (TARGET_RELAXED_ORDERING): Likewise.\n+\t* config/alpha/alpha.c (TARGET_RELAXED_ORDERING): Likewise.\n+\t* config/ia64/ia64.c (TARGET_RELAXED_ORDERING): Likewise.\n+\t* config/rs6000/rs6000.c (TARGET_RELAXED_ORDERING): Likewise.\n+\t* config/sparc/linux.h (SPARC_RELAXED_ORDERING): Likewise.\n+\t* config/sparc/linux64.h (SPARC_RELAXED_ORDERING): Likewise.\n+\t* config/sparc/sparc.c (TARGET_RELAXED_ORDERING): Likewise.\n+\t* config/sparc/sparc.h (SPARC_RELAXED_ORDERING): Likewise.\n+\n 2015-06-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_override_options): Unconditionally"}, {"sha": "857c9ac77ebb9027d95e657a93d5c4367bfecbd9", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "patch": "@@ -9987,12 +9987,6 @@ alpha_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n #undef TARGET_EXPAND_BUILTIN_VA_START\n #define TARGET_EXPAND_BUILTIN_VA_START alpha_va_start\n \n-/* The Alpha architecture does not require sequential consistency.  See\n-   http://www.cs.umd.edu/~pugh/java/memoryModel/AlphaReordering.html\n-   for an example of how it can be violated in practice.  */\n-#undef TARGET_RELAXED_ORDERING\n-#define TARGET_RELAXED_ORDERING true\n-\n #undef TARGET_OPTION_OVERRIDE\n #define TARGET_OPTION_OVERRIDE alpha_option_override\n "}, {"sha": "45ad97a10a400e090ea31e42b0568cbc629def80", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "patch": "@@ -630,11 +630,6 @@ static const struct attribute_spec ia64_attribute_table[] =\n #define TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P \\\n   ia64_libgcc_floating_mode_supported_p\n \n-/* ia64 architecture manual 4.4.7: ... reads, writes, and flushes may occur\n-   in an order different from the specified program order.  */\n-#undef TARGET_RELAXED_ORDERING\n-#define TARGET_RELAXED_ORDERING true\n-\n #undef TARGET_LEGITIMATE_CONSTANT_P\n #define TARGET_LEGITIMATE_CONSTANT_P ia64_legitimate_constant_p\n #undef TARGET_LEGITIMATE_ADDRESS_P"}, {"sha": "bed53489a61998926d3e1c09dad475a46baa6f09", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "patch": "@@ -1620,17 +1620,6 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #define TARGET_STACK_PROTECT_FAIL rs6000_stack_protect_fail\n #endif\n \n-/* MPC604EUM 3.5.2 Weak Consistency between Multiple Processors\n-   The PowerPC architecture requires only weak consistency among\n-   processors--that is, memory accesses between processors need not be\n-   sequentially consistent and memory accesses among processors can occur\n-   in any order. The ability to order memory accesses weakly provides\n-   opportunities for more efficient use of the system bus. Unless a\n-   dependency exists, the 604e allows read operations to precede store\n-   operations.  */\n-#undef TARGET_RELAXED_ORDERING\n-#define TARGET_RELAXED_ORDERING true\n-\n #ifdef HAVE_AS_TLS\n #undef TARGET_ASM_OUTPUT_DWARF_DTPREL\n #define TARGET_ASM_OUTPUT_DWARF_DTPREL rs6000_output_dwarf_dtprel"}, {"sha": "29763c4bae7ecd6e64ed649ede811a6b051a821d", "filename": "gcc/config/sparc/linux.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fconfig%2Fsparc%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fconfig%2Fsparc%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux.h?ref=e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "patch": "@@ -139,12 +139,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Static stack checking is supported by means of probes.  */\n #define STACK_CHECK_STATIC_BUILTIN 1\n \n-/* Linux currently uses RMO in uniprocessor mode, which is equivalent to\n-   TMO, and TMO in multiprocessor mode.  But they reserve the right to\n-   change their minds.  */\n-#undef SPARC_RELAXED_ORDERING\n-#define SPARC_RELAXED_ORDERING true\n-\n #undef NEED_INDICATE_EXEC_STACK\n #define NEED_INDICATE_EXEC_STACK 1\n "}, {"sha": "efa33fbf77bbb06786711177704d636a3e430069", "filename": "gcc/config/sparc/linux64.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fconfig%2Fsparc%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fconfig%2Fsparc%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux64.h?ref=e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "patch": "@@ -253,12 +253,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Static stack checking is supported by means of probes.  */\n #define STACK_CHECK_STATIC_BUILTIN 1\n \n-/* Linux currently uses RMO in uniprocessor mode, which is equivalent to\n-   TMO, and TMO in multiprocessor mode.  But they reserve the right to\n-   change their minds.  */\n-#undef SPARC_RELAXED_ORDERING\n-#define SPARC_RELAXED_ORDERING true\n-\n #undef NEED_INDICATE_EXEC_STACK\n #define NEED_INDICATE_EXEC_STACK 1\n "}, {"sha": "094287f5c11912da45b1cda4a7332465e029e142", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "patch": "@@ -808,9 +808,6 @@ char sparc_hard_reg_printed[8];\n #define TARGET_ATTRIBUTE_TABLE sparc_attribute_table\n #endif\n \n-#undef TARGET_RELAXED_ORDERING\n-#define TARGET_RELAXED_ORDERING SPARC_RELAXED_ORDERING\n-\n #undef TARGET_OPTION_OVERRIDE\n #define TARGET_OPTION_OVERRIDE sparc_option_override\n "}, {"sha": "72dd18bfdfc9c53c19c701fd8269f8f07db163ad", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "patch": "@@ -106,17 +106,6 @@ extern enum cmodel sparc_cmodel;\n \n #define SPARC_DEFAULT_CMODEL CM_32\n \n-/* The SPARC-V9 architecture defines a relaxed memory ordering model (RMO)\n-   which requires the following macro to be true if enabled.  Prior to V9,\n-   there are no instructions to even talk about memory synchronization.\n-   Note that the UltraSPARC III processors don't implement RMO, unlike the\n-   UltraSPARC II processors.  Niagara, Niagara-2, and Niagara-3 do not\n-   implement RMO either.\n-\n-   Default to false; for example, Solaris never enables RMO, only ever uses\n-   total memory ordering (TMO).  */\n-#define SPARC_RELAXED_ORDERING false\n-\n /* Do not use the .note.GNU-stack convention by default.  */\n #define NEED_INDICATE_EXEC_STACK 0\n "}, {"sha": "83071db733e3a833e721dcf09a61af33c2ef1f94", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "patch": "@@ -1,3 +1,15 @@\n+2015-06-04  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+\n+\tPR c++/66192\n+\tPR target/66200\n+\t* cp-tree.h (get_guard_cond): Adjust declaration\n+\t* decl.c (expand_static_init): Use atomic load acquire\n+\tand adjust call to get_guard_cond.\n+\t* decl2.c (build_atomic_load_byte): New function.\n+\t(get_guard_cond): Handle thread_safety.\n+\t(one_static_initialization_or_destruction): Adjust call to\n+\tget_guard_cond.\n+\n 2015-06-03  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/44282"}, {"sha": "efaf1bd879b5364cbca07d0529ecff132f7ce2eb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "patch": "@@ -5491,7 +5491,7 @@ extern bool mark_used\t\t\t        (tree, tsubst_flags_t);\n extern void finish_static_data_member_decl\t(tree, tree, bool, tree, int);\n extern tree cp_build_parm_decl\t\t\t(tree, tree);\n extern tree get_guard\t\t\t\t(tree);\n-extern tree get_guard_cond\t\t\t(tree);\n+extern tree get_guard_cond\t\t\t(tree, bool);\n extern tree set_guard\t\t\t\t(tree);\n extern tree get_tls_wrapper_fn\t\t\t(tree);\n extern void mark_needed\t\t\t\t(tree);"}, {"sha": "2b57c47904b7b21e578627b2a58cc1bb184819fb", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "patch": "@@ -7227,7 +7227,7 @@ expand_static_init (tree decl, tree init)\n \t looks like:\n \n \t   static <type> guard;\n-\t   if (!guard.first_byte) {\n+\t   if (!__atomic_load (guard.first_byte)) {\n \t     if (__cxa_guard_acquire (&guard)) {\n \t       bool flag = false;\n \t       try {\n@@ -7257,16 +7257,11 @@ expand_static_init (tree decl, tree init)\n       /* Create the guard variable.  */\n       guard = get_guard (decl);\n \n-      /* This optimization isn't safe on targets with relaxed memory\n-\t consistency.  On such targets we force synchronization in\n-\t __cxa_guard_acquire.  */\n-      if (!targetm.relaxed_ordering || !thread_guard)\n-\t{\n-\t  /* Begin the conditional initialization.  */\n-\t  if_stmt = begin_if_stmt ();\n-\t  finish_if_stmt_cond (get_guard_cond (guard), if_stmt);\n-\t  then_clause = begin_compound_stmt (BCS_NO_SCOPE);\n-\t}\n+      /* Begin the conditional initialization.  */\n+      if_stmt = begin_if_stmt ();\n+\n+      finish_if_stmt_cond (get_guard_cond (guard, thread_guard), if_stmt);\n+      then_clause = begin_compound_stmt (BCS_NO_SCOPE);\n \n       if (thread_guard)\n \t{\n@@ -7335,12 +7330,9 @@ expand_static_init (tree decl, tree init)\n \t  finish_if_stmt (inner_if_stmt);\n \t}\n \n-      if (!targetm.relaxed_ordering || !thread_guard)\n-\t{\n-\t  finish_compound_stmt (then_clause);\n-\t  finish_then_clause (if_stmt);\n-\t  finish_if_stmt (if_stmt);\n-\t}\n+      finish_compound_stmt (then_clause);\n+      finish_then_clause (if_stmt);\n+      finish_if_stmt (if_stmt);\n     }\n   else if (DECL_THREAD_LOCAL_P (decl))\n     tls_aggregates = tree_cons (init, decl, tls_aggregates);"}, {"sha": "e733e3498d5cbc2aa99b9e32656c8afb469dd2bb", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "patch": "@@ -3034,6 +3034,27 @@ get_guard (tree decl)\n   return guard;\n }\n \n+/* Return an atomic load of src with the appropriate memory model.  */\n+\n+static tree\n+build_atomic_load_byte (tree src, HOST_WIDE_INT model)\n+{\n+  tree ptr_type = build_pointer_type (char_type_node);\n+  tree mem_model = build_int_cst (integer_type_node, model);\n+  tree t, addr, val;\n+  unsigned int size;\n+  int fncode;\n+\n+  size = tree_to_uhwi (TYPE_SIZE_UNIT (char_type_node));\n+\n+  fncode = BUILT_IN_ATOMIC_LOAD_N + exact_log2 (size) + 1;\n+  t = builtin_decl_implicit ((enum built_in_function) fncode);\n+\n+  addr = build1 (ADDR_EXPR, ptr_type, src);\n+  val = build_call_expr (t, 2, addr, mem_model);\n+  return val;\n+}\n+\n /* Return those bits of the GUARD variable that should be set when the\n    guarded entity is actually initialized.  */\n \n@@ -3060,12 +3081,14 @@ get_guard_bits (tree guard)\n    variable has already been initialized.  */\n \n tree\n-get_guard_cond (tree guard)\n+get_guard_cond (tree guard, bool thread_safe)\n {\n   tree guard_value;\n \n-  /* Check to see if the GUARD is zero.  */\n-  guard = get_guard_bits (guard);\n+  if (!thread_safe)\n+    guard = get_guard_bits (guard);\n+  else\n+    guard = build_atomic_load_byte (guard, MEMMODEL_ACQUIRE);\n \n   /* Mask off all but the low bit.  */\n   if (targetm.cxx.guard_mask_bit ())\n@@ -3681,7 +3704,7 @@ one_static_initialization_or_destruction (tree decl, tree init, bool initp)\n \t  /* When using __cxa_atexit, we never try to destroy\n \t     anything from a static destructor.  */\n \t  gcc_assert (initp);\n-\t  guard_cond = get_guard_cond (guard);\n+\t  guard_cond = get_guard_cond (guard, false);\n \t}\n       /* If we don't have __cxa_atexit, then we will be running\n \t destructors from .fini sections, or their equivalents.  So,"}, {"sha": "a16cd92260bd066edc8881115d945c0f1c327f14", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "patch": "@@ -11395,16 +11395,6 @@ routine for target specific customizations of the system printf\n and scanf formatter settings.\n @end defmac\n \n-@deftypevr {Target Hook} bool TARGET_RELAXED_ORDERING\n-If set to @code{true}, means that the target's memory model does not\n-guarantee that loads which do not depend on one another will access\n-main memory in the order of the instruction stream; if ordering is\n-important, an explicit memory barrier must be used.  This is true of\n-many recent processors which implement a policy of ``relaxed,''\n-``weak,'' or ``release'' memory consistency, such as Alpha, PowerPC,\n-and ia64.  The default is @code{false}.\n-@end deftypevr\n-\n @deftypefn {Target Hook} {const char *} TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN (const_tree @var{typelist}, const_tree @var{funcdecl}, const_tree @var{val})\n If defined, this macro returns the diagnostic message when it is\n illegal to pass argument @var{val} to function @var{funcdecl}"}, {"sha": "93fb41c6879c2b8f87745874cf9a7880ef66b396", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "patch": "@@ -8143,8 +8143,6 @@ routine for target specific customizations of the system printf\n and scanf formatter settings.\n @end defmac\n \n-@hook TARGET_RELAXED_ORDERING\n-\n @hook TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN\n \n @hook TARGET_INVALID_CONVERSION"}, {"sha": "9ca5b5fadd365bd283509de7fcba76da9acfab29", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "patch": "@@ -964,7 +964,7 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n \tTARGET_HANDLE_PRAGMA_EXTERN_PREFIX \\\n \tTARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN \\\n \tTARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD \\\n-\tTARGET_MD_ASM_CLOBBERS\n+\tTARGET_MD_ASM_CLOBBERS TARGET_RELAXED_ORDERING\n \n /* Arrays that were deleted in favor of a functional interface.  */\n  #pragma GCC poison built_in_decls implicit_built_in_decls"}, {"sha": "b606b813360cc04f561f88afe587b3dd1b6dfd0c", "filename": "gcc/target.def", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=e93ca5cadeb71a04b2f8ef2ebcbadb2f0213d878", "patch": "@@ -5785,19 +5785,6 @@ for the primary source file, immediately after printing\\n\\\n this to be done.  The default is false.\",\n  bool, false)\n \n-/* True if the target is allowed to reorder memory accesses unless\n-   synchronization is explicitly requested.  */\n-DEFHOOKPOD\n-(relaxed_ordering,\n- \"If set to @code{true}, means that the target's memory model does not\\n\\\n-guarantee that loads which do not depend on one another will access\\n\\\n-main memory in the order of the instruction stream; if ordering is\\n\\\n-important, an explicit memory barrier must be used.  This is true of\\n\\\n-many recent processors which implement a policy of ``relaxed,''\\n\\\n-``weak,'' or ``release'' memory consistency, such as Alpha, PowerPC,\\n\\\n-and ia64.  The default is @code{false}.\",\n- bool, false)\n-\n /* Returns true if we should generate exception tables for use with the\n    ARM EABI.  The effects the encoding of function exception specifications.  */\n DEFHOOKPOD"}]}