{"sha": "d357720d41be5a06988524d023bc4f0e7cbcc7ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM1NzcyMGQ0MWJlNWEwNjk4ODUyNGQwMjNiYzRmMGU3Y2JjYzdlZA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-13T13:31:01Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-13T13:31:01Z"}, "message": "tree-into-ssa.c (find_idf): Speed up by putting the indexes of basic blocks into work_stack.\n\n\t* tree-into-ssa.c (find_idf): Speed up by putting the indexes\n\tof basic blocks into work_stack.\n\nFrom-SVN: r96367", "tree": {"sha": "45aa8123e100141f92309d1cd58db95f2951da1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45aa8123e100141f92309d1cd58db95f2951da1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d357720d41be5a06988524d023bc4f0e7cbcc7ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d357720d41be5a06988524d023bc4f0e7cbcc7ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d357720d41be5a06988524d023bc4f0e7cbcc7ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d357720d41be5a06988524d023bc4f0e7cbcc7ed/comments", "author": null, "committer": null, "parents": [{"sha": "6bbaec0912db7f78d62640f99ba1782c109b19de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bbaec0912db7f78d62640f99ba1782c109b19de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bbaec0912db7f78d62640f99ba1782c109b19de"}], "stats": {"total": 24, "additions": 13, "deletions": 11}, "files": [{"sha": "227ff5fa402e44d9dd93c72c4da94b1e26e0dc85", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d357720d41be5a06988524d023bc4f0e7cbcc7ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d357720d41be5a06988524d023bc4f0e7cbcc7ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d357720d41be5a06988524d023bc4f0e7cbcc7ed", "patch": "@@ -1,3 +1,8 @@\n+2005-03-13  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* tree-into-ssa.c (find_idf): Speed up by putting the indexes\n+\tof basic blocks into work_stack.\n+\n 2005-03-13  Andy Hutchinson  <HutchinsonAndy@netscape.net>\n \n \tPR target/18251"}, {"sha": "8c58a457dac276a274e782db3501e52b8fec3403", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d357720d41be5a06988524d023bc4f0e7cbcc7ed/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d357720d41be5a06988524d023bc4f0e7cbcc7ed/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=d357720d41be5a06988524d023bc4f0e7cbcc7ed", "patch": "@@ -111,7 +111,7 @@ static htab_t def_blocks;\n static VEC(tree_on_heap) *block_defs_stack;\n \n /* Basic block vectors used in this file ought to be allocated in the heap.  */\n-DEF_VEC_MALLOC_P(basic_block);\n+DEF_VEC_MALLOC_P(int);\n \n /* Global data to attach to the main dominator walk structure.  */\n struct mark_def_sites_global_data\n@@ -503,40 +503,37 @@ find_idf (bitmap def_blocks, bitmap *dfs)\n {\n   bitmap_iterator bi;\n   unsigned bb_index;\n-  VEC(basic_block) *work_stack;\n+  VEC(int) *work_stack;\n   bitmap phi_insertion_points;\n \n-  work_stack = VEC_alloc (basic_block, n_basic_blocks);\n+  work_stack = VEC_alloc (int, n_basic_blocks);\n   phi_insertion_points = BITMAP_ALLOC (NULL);\n \n   /* Seed the work list with all the blocks in DEF_BLOCKS.  */\n   EXECUTE_IF_SET_IN_BITMAP (def_blocks, 0, bb_index, bi)\n-    VEC_safe_push (basic_block, work_stack, BASIC_BLOCK (bb_index));\n+    VEC_safe_push (int, work_stack, bb_index);\n \n   /* Pop a block off the worklist, add every block that appears in\n      the original block's DF that we have not already processed to\n      the worklist.  Iterate until the worklist is empty.   Blocks\n      which are added to the worklist are potential sites for\n      PHI nodes.  */\n-  while (VEC_length (basic_block, work_stack) > 0)\n+  while (VEC_length (int, work_stack) > 0)\n     {\n-      basic_block bb = VEC_pop (basic_block, work_stack);\n-      bb_index = bb->index;\n+      bb_index = VEC_pop (int, work_stack);\n       \n       EXECUTE_IF_AND_COMPL_IN_BITMAP (dfs[bb_index], phi_insertion_points,\n \t\t\t\t      0, bb_index, bi)\n \t{\n-\t  bb = BASIC_BLOCK (bb_index);\n-\n \t  /* Use a safe push because if there is a definition of VAR\n \t     in every basic block, then WORK_STACK may eventually have\n \t     more than N_BASIC_BLOCK entries.  */\n-\t  VEC_safe_push (basic_block, work_stack, bb);\n+\t  VEC_safe_push (int, work_stack, bb_index);\n \t  bitmap_set_bit (phi_insertion_points, bb_index);\n \t}\n     }\n \n-  VEC_free (basic_block, work_stack);\n+  VEC_free (int, work_stack);\n \n   return phi_insertion_points;\n }"}]}