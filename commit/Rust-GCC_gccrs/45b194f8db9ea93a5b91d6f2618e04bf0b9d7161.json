{"sha": "45b194f8db9ea93a5b91d6f2618e04bf0b9d7161", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDViMTk0ZjhkYjllYTkzYTViOTFkNmYyNjE4ZTA0YmYwYjlkNzE2MQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2007-10-17T01:05:50Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2007-10-17T01:05:50Z"}, "message": "rs6000.c (rs6000_emit_epilogue): Correct altivec sp_offset.\n\n\t* config/rs6000/rs6000.c (rs6000_emit_epilogue): Correct\n\taltivec sp_offset.  Rearrange sp_offset assignments to\n\tcorrespond to stack adjustments.  Use frame_reg_rtx for\n\tSPE register restores.  Correct SPE stack adjustment.\n\nFrom-SVN: r129400", "tree": {"sha": "6ebd9ef8fe4743d586a0a179380d95b95c760632", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ebd9ef8fe4743d586a0a179380d95b95c760632"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45b194f8db9ea93a5b91d6f2618e04bf0b9d7161", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45b194f8db9ea93a5b91d6f2618e04bf0b9d7161", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45b194f8db9ea93a5b91d6f2618e04bf0b9d7161", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45b194f8db9ea93a5b91d6f2618e04bf0b9d7161/comments", "author": null, "committer": null, "parents": [{"sha": "07d8d70f3f1a1abf14a66de6b9675bf77152a536", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07d8d70f3f1a1abf14a66de6b9675bf77152a536", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07d8d70f3f1a1abf14a66de6b9675bf77152a536"}], "stats": {"total": 61, "additions": 31, "deletions": 30}, "files": [{"sha": "86eec5309c85c20be68d45ea31fa262d6c3ac8c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45b194f8db9ea93a5b91d6f2618e04bf0b9d7161/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45b194f8db9ea93a5b91d6f2618e04bf0b9d7161/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45b194f8db9ea93a5b91d6f2618e04bf0b9d7161", "patch": "@@ -1,3 +1,10 @@\n+2007-10-17  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* config/rs6000/rs6000.c (rs6000_emit_epilogue): Correct\n+\taltivec sp_offset.  Rearrange sp_offset assignments to\n+\tcorrespond to stack adjustments.  Use frame_reg_rtx for\n+\tSPE register restores.  Correct SPE stack adjustment.\n+\n 2007-10-17  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \t* builtins.c (gimplify_va_arg_expr): Use inform for help message."}, {"sha": "0415e44c5669ea996b30f24f353709ac1411446a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45b194f8db9ea93a5b91d6f2618e04bf0b9d7161/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45b194f8db9ea93a5b91d6f2618e04bf0b9d7161/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=45b194f8db9ea93a5b91d6f2618e04bf0b9d7161", "patch": "@@ -16054,8 +16054,8 @@ rs6000_emit_epilogue (int sibcall)\n       return;\n     }\n \n-  /* Set sp_offset based on the stack push from the prologue.  */\n-  if (info->total_size < 32767)\n+  /* frame_reg_rtx + sp_offset points to the top of this stack frame.  */\n+  if (info->push_p)\n     sp_offset = info->total_size;\n \n   /* Restore AltiVec registers if needed.  */\n@@ -16097,8 +16097,6 @@ rs6000_emit_epilogue (int sibcall)\n       emit_insn (generate_set_vrsave (reg, info, 1));\n     }\n \n-  sp_offset = 0;\n-\n   /* If we have a frame pointer, a call to alloca,  or a large stack\n      frame, restore the old stack pointer using the backchain.  Otherwise,\n      we know what size to update it with.  */\n@@ -16111,20 +16109,18 @@ rs6000_emit_epilogue (int sibcall)\n \n       emit_move_insn (frame_reg_rtx,\n \t\t      gen_rtx_MEM (Pmode, sp_reg_rtx));\n+      sp_offset = 0;\n     }\n-  else if (info->push_p)\n+  else if (info->push_p\n+\t   && DEFAULT_ABI != ABI_V4\n+\t   && !current_function_calls_eh_return)\n     {\n-      if (DEFAULT_ABI == ABI_V4\n-\t  || current_function_calls_eh_return)\n-\tsp_offset = info->total_size;\n-      else\n-\t{\n-\t  emit_insn (TARGET_32BIT\n-\t\t     ? gen_addsi3 (sp_reg_rtx, sp_reg_rtx,\n-\t\t\t\t   GEN_INT (info->total_size))\n-\t\t     : gen_adddi3 (sp_reg_rtx, sp_reg_rtx,\n-\t\t\t\t   GEN_INT (info->total_size)));\n-\t}\n+      emit_insn (TARGET_32BIT\n+\t\t ? gen_addsi3 (sp_reg_rtx, sp_reg_rtx,\n+\t\t\t       GEN_INT (info->total_size))\n+\t\t : gen_adddi3 (sp_reg_rtx, sp_reg_rtx,\n+\t\t\t       GEN_INT (info->total_size)));\n+      sp_offset = 0;\n     }\n \n   /* Get the old lr if we saved it.  */\n@@ -16206,7 +16202,6 @@ rs6000_emit_epilogue (int sibcall)\n            && info->spe_64bit_regs_used != 0\n            && info->first_gp_reg_save != 32)\n     {\n-      rtx spe_save_area_ptr;\n       /* Determine whether we can address all of the registers that need\n          to be saved with an offset from the stack pointer that fits in\n          the small const field for SPE memory instructions.  */\n@@ -16216,20 +16211,21 @@ rs6000_emit_epilogue (int sibcall)\n       int spe_offset;\n \n       if (spe_regs_addressable_via_sp)\n-        {\n-          spe_save_area_ptr = frame_reg_rtx;\n-          spe_offset = info->spe_gp_save_offset + sp_offset;\n-        }\n+\tspe_offset = info->spe_gp_save_offset + sp_offset;\n       else\n         {\n+\t  rtx old_frame_reg_rtx = frame_reg_rtx;\n           /* Make r11 point to the start of the SPE save area.  We worried about\n              not clobbering it when we were saving registers in the prologue.\n              There's no need to worry here because the static chain is passed\n              anew to every function.  */\n-          spe_save_area_ptr = gen_rtx_REG (Pmode, 11);\n-\n-          emit_insn (gen_addsi3 (spe_save_area_ptr, frame_reg_rtx,\n+\t  if (frame_reg_rtx == sp_reg_rtx)\n+\t    frame_reg_rtx = gen_rtx_REG (Pmode, 11);\n+          emit_insn (gen_addsi3 (frame_reg_rtx, old_frame_reg_rtx,\n                                  GEN_INT (info->spe_gp_save_offset + sp_offset)));\n+\t  /* Keep the invariant that frame_reg_rtx + sp_offset points\n+\t     at the top of the stack frame.  */\n+\t  sp_offset = -info->spe_gp_save_offset;\n \n           spe_offset = 0;\n         }\n@@ -16244,7 +16240,7 @@ rs6000_emit_epilogue (int sibcall)\n             gcc_assert (SPE_CONST_OFFSET_OK (spe_offset + reg_size * i));\n \n             offset = GEN_INT (spe_offset + reg_size * i);\n-            addr = gen_rtx_PLUS (Pmode, spe_save_area_ptr, offset);\n+            addr = gen_rtx_PLUS (Pmode, frame_reg_rtx, offset);\n             mem = gen_rtx_MEM (V2SImode, addr);\n \n             emit_move_insn (gen_rtx_REG (reg_mode, info->first_gp_reg_save + i),\n@@ -16336,11 +16332,9 @@ rs6000_emit_epilogue (int sibcall)\n       /* This blockage is needed so that sched doesn't decide to move\n \t the sp change before the register restores.  */\n       rs6000_emit_stack_tie ();\n-      if (TARGET_SPE_ABI\n-          && info->spe_64bit_regs_used != 0\n-          && info->first_gp_reg_save != 32)\n-        emit_insn (gen_addsi3 (sp_reg_rtx, gen_rtx_REG (Pmode, 11),\n-                               GEN_INT (-(info->spe_gp_save_offset + sp_offset))));\n+      if (sp_offset != 0)\n+        emit_insn (gen_addsi3 (sp_reg_rtx, frame_reg_rtx,\n+\t\t\t       GEN_INT (sp_offset)));\n       else\n         emit_move_insn (sp_reg_rtx, frame_reg_rtx);\n     }"}]}