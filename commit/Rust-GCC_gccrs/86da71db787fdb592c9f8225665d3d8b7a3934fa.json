{"sha": "86da71db787fdb592c9f8225665d3d8b7a3934fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZkYTcxZGI3ODdmZGI1OTJjOWY4MjI1NjY1ZDNkOGI3YTM5MzRmYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-07-07T10:10:29Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-07-07T10:10:29Z"}, "message": "trans.c (lvalue_required_p): Remove ALIASED parameter and adjust recursive calls.\n\n\t* gcc-interface/trans.c (lvalue_required_p): Remove ALIASED parameter\n\tand adjust recursive calls.\n\t(Identifier_to_gnu): Adjust calls to lvalue_required_p.\n\t(gnat_to_gnu): Likewise.\n\nFrom-SVN: r262496", "tree": {"sha": "58e7519c5ad63cb72f8fa1f63b60db948b44a218", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58e7519c5ad63cb72f8fa1f63b60db948b44a218"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86da71db787fdb592c9f8225665d3d8b7a3934fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86da71db787fdb592c9f8225665d3d8b7a3934fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86da71db787fdb592c9f8225665d3d8b7a3934fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86da71db787fdb592c9f8225665d3d8b7a3934fa/comments", "author": null, "committer": null, "parents": [{"sha": "718364340fa052641189523e41a5006ba6c9966d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/718364340fa052641189523e41a5006ba6c9966d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/718364340fa052641189523e41a5006ba6c9966d"}], "stats": {"total": 38, "additions": 21, "deletions": 17}, "files": [{"sha": "bc353c5c52fa6ea256605f9d7d7e6d4ffe56dae5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86da71db787fdb592c9f8225665d3d8b7a3934fa/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86da71db787fdb592c9f8225665d3d8b7a3934fa/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=86da71db787fdb592c9f8225665d3d8b7a3934fa", "patch": "@@ -1,3 +1,10 @@\n+2018-07-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (lvalue_required_p): Remove ALIASED parameter\n+\tand adjust recursive calls.\n+\t(Identifier_to_gnu): Adjust calls to lvalue_required_p.\n+\t(gnat_to_gnu): Likewise.\n+\n 2018-07-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_param): Minor tweak."}, {"sha": "e7992e8a9381da23a873f4c241f03177ee2e9389", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86da71db787fdb592c9f8225665d3d8b7a3934fa/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86da71db787fdb592c9f8225665d3d8b7a3934fa/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=86da71db787fdb592c9f8225665d3d8b7a3934fa", "patch": "@@ -246,7 +246,7 @@ static tree maybe_implicit_deref (tree);\n static void set_expr_location_from_node (tree, Node_Id, bool = false);\n static void set_gnu_expr_location_from_node (tree, Node_Id);\n static bool set_end_locus_from_node (tree, Node_Id);\n-static int lvalue_required_p (Node_Id, tree, bool, bool, bool);\n+static int lvalue_required_p (Node_Id, tree, bool, bool);\n static tree build_raise_check (int, enum exception_info_kind);\n static tree create_init_temporary (const char *, tree, tree *, Node_Id);\n \n@@ -806,8 +806,8 @@ lvalue_required_for_attribute_p (Node_Id gnat_node)\n    is the type that will be used for GNAT_NODE in the translated GNU tree.\n    CONSTANT indicates whether the underlying object represented by GNAT_NODE\n    is constant in the Ada sense.  If it is, ADDRESS_OF_CONSTANT indicates\n-   whether its value is the address of a constant and ALIASED whether it is\n-   aliased.  If it isn't, ADDRESS_OF_CONSTANT and ALIASED are ignored.\n+   whether its value is the address of another constant.  If it isn't, then\n+   ADDRESS_OF_CONSTANT is ignored.\n \n    The function climbs up the GNAT tree starting from the node and returns 1\n    upon encountering a node that effectively requires an lvalue downstream.\n@@ -816,7 +816,7 @@ lvalue_required_for_attribute_p (Node_Id gnat_node)\n \n static int\n lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n-\t\t   bool address_of_constant, bool aliased)\n+\t\t   bool address_of_constant)\n {\n   Node_Id gnat_parent = Parent (gnat_node), gnat_temp;\n \n@@ -861,14 +861,12 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n       if (Prefix (gnat_parent) != gnat_node)\n \treturn 0;\n \n-      aliased |= Has_Aliased_Components (Etype (gnat_node));\n       return lvalue_required_p (gnat_parent, gnu_type, constant,\n-\t\t\t\taddress_of_constant, aliased);\n+\t\t\t\taddress_of_constant);\n \n     case N_Selected_Component:\n-      aliased |= Is_Aliased (Entity (Selector_Name (gnat_parent)));\n       return lvalue_required_p (gnat_parent, gnu_type, constant,\n-\t\t\t\taddress_of_constant, aliased);\n+\t\t\t\taddress_of_constant);\n \n     case N_Object_Renaming_Declaration:\n       /* We need to preserve addresses through a renaming.  */\n@@ -908,7 +906,7 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n \t an intermediate conversion that is meant to be purely formal.  */\n      return lvalue_required_p (gnat_parent,\n \t\t\t       get_unpadded_type (Etype (gnat_parent)),\n-\t\t\t       constant, address_of_constant, aliased);\n+\t\t\t       constant, address_of_constant);\n \n     case N_Allocator:\n       /* We should only reach here through the N_Qualified_Expression case.\n@@ -922,7 +920,7 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n       if (constant && address_of_constant)\n \treturn lvalue_required_p (gnat_parent,\n \t\t\t\t  get_unpadded_type (Etype (gnat_parent)),\n-\t\t\t\t  true, false, true);\n+\t\t\t\t  true, false);\n \n       /* ... fall through ... */\n \n@@ -1123,8 +1121,8 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       && !Is_Imported (gnat_temp)\n       && Present (Address_Clause (gnat_temp)))\n     {\n-      require_lvalue = lvalue_required_p (gnat_node, gnu_result_type, true,\n-\t\t\t\t\t  false, Is_Aliased (gnat_temp));\n+      require_lvalue\n+\t= lvalue_required_p (gnat_node, gnu_result_type, true, false);\n       use_constant_initializer = !require_lvalue;\n     }\n \n@@ -1161,7 +1159,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       else if (TREE_CODE (gnu_result) == CONST_DECL\n \t       && !(DECL_CONST_ADDRESS_P (gnu_result)\n \t\t    && lvalue_required_p (gnat_node, gnu_result_type, true,\n-\t\t\t\t\t  true, false)))\n+\t\t\t\t\t  true)))\n \tgnu_result = DECL_INITIAL (gnu_result);\n \n       /* If it's a renaming pointer, get to the renamed object.  */\n@@ -1201,7 +1199,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       if ((!constant_only || address_of_constant) && require_lvalue < 0)\n \trequire_lvalue\n \t  = lvalue_required_p (gnat_node, gnu_result_type, true,\n-\t\t\t       address_of_constant, Is_Aliased (gnat_temp));\n+\t\t\t       address_of_constant);\n \n       /* Finally retrieve the initializer if this is deemed valid.  */\n       if ((constant_only && !address_of_constant) || !require_lvalue)\n@@ -1217,8 +1215,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n     {\n       if (require_lvalue < 0)\n \trequire_lvalue\n-\t  = lvalue_required_p (gnat_node, gnu_result_type, true, false,\n-\t\t\t       Is_Aliased (gnat_temp));\n+\t  = lvalue_required_p (gnat_node, gnu_result_type, true, false);\n       if (!require_lvalue)\n \tgnu_result = fold_constant_decl_in_expr (gnu_result);\n     }\n@@ -7860,7 +7857,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  || kind == N_Indexed_Component\n \t  || kind == N_Selected_Component)\n       && TREE_CODE (get_base_type (gnu_result_type)) == BOOLEAN_TYPE\n-      && !lvalue_required_p (gnat_node, gnu_result_type, false, false, false))\n+      && !lvalue_required_p (gnat_node, gnu_result_type, false, false))\n     {\n       gnu_result\n \t= build_binary_op (NE_EXPR, gnu_result_type,"}]}