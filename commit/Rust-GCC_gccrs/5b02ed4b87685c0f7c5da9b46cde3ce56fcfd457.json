{"sha": "5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIwMmVkNGI4NzY4NWMwZjdjNWRhOWI0NmNkZTNjZTU2ZmNmZDQ1Nw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-06-11T16:15:38Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-06-11T16:17:58Z"}, "message": "[PATCH] PR tree-optimization/96392 Optimize x+0.0 if x is an integer\n\nThe patch implements a missed optimization enhancement.  Under usual\nIEEE rules, x+0.0 can't be simplified to x when x might potentially\nbe an IEEE minus zero (-0.0).  The current logic in the middle-end\nchecks whether the type of x should honor signed zeros, but with this\npatch we introduce tree_expr_maybe_real_minus_zero_p that allows us\nto confirm that the value can't possibly be -0.0, for example, the result\nof a conversion from an integer type, or the result of fabs (or has a\ntype that doesn't honor signed zero).\n\nWhilst modifying match.pd, I also converted some additional folding\ntransformations from \"testing the type\" to \"testing the value\".\n\n2020-06-10  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\tPR tree-optimization/96392\n\t* fold-const.c (fold_real_zero_addition_p): Take both arguments\n\tof the addition or subtraction, not just the zero.  Use this\n\tother argument in tests for signaling NaNs and signed zeros.\n\t(tree_expr_maybe_real_minus_zero_p): New predicate.\n\t* fold-const.h (fold_real_zero_addition_p): Update prototype.\n\t(tree_expr_maybe_real_minus_zero_p): New function prototype.\n\t* match.pd: Update calls to fold_real_zero_addition_p.\n\tReplace HONOR_NANS with tree_expr_maybe_nan_p.\n\tReplace HONOR_SIGNED_ZEROS with tree_expr_maybe_real_minus_zero_p.\n\tReplace HONOR_SNANS with tree_expr_maybe_signaling_nan_p.\n\t* tree-ssa-reassoc.c (eliminate_using_constants): Update\n\tcall to fold_real_zero_addition_p.\n\ngcc/testsuite/ChangeLog\n\tPR tree-optimization/96392\n\t* gcc.dg/pr96392.c: New test.", "tree": {"sha": "5383dd4f566eb945a79017ed6c292af4f627257c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5383dd4f566eb945a79017ed6c292af4f627257c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8b80b8aa3d9a7abbcb59b651ea5e84c2ea12d0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8b80b8aa3d9a7abbcb59b651ea5e84c2ea12d0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8b80b8aa3d9a7abbcb59b651ea5e84c2ea12d0b"}], "stats": {"total": 137, "additions": 108, "deletions": 29}, "files": [{"sha": "95673d24ed0153e49030d7361136ae915bce68bd", "filename": "gcc/fold-const.c", "status": "modified", "additions": 56, "deletions": 14, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457", "patch": "@@ -7127,11 +7127,13 @@ fold_binary_op_with_conditional_arg (location_t loc,\n }\n \n \f\n-/* Subroutine of fold() that checks for the addition of +/- 0.0.\n+/* Subroutine of fold() that checks for the addition of ARG +/- 0.0.\n \n-   If !NEGATE, return true if ADDEND is +/-0.0 and, for all X of type\n-   TYPE, X + ADDEND is the same as X.  If NEGATE, return true if X -\n-   ADDEND is the same as X.\n+   If !NEGATE, return true if ZERO_ARG is +/-0.0 and, for all ARG of\n+   type TYPE, ARG + ZERO_ARG is the same as ARG.  If NEGATE, return true\n+   if ARG - ZERO_ARG is the same as X.\n+\n+   If ARG is NULL, check for any value of type TYPE.\n \n    X + 0 and X - 0 both give X when X is NaN, infinite, or nonzero\n    and finite.  The problematic cases are when X is zero, and its mode\n@@ -7140,13 +7142,14 @@ fold_binary_op_with_conditional_arg (location_t loc,\n    modes, X + 0 is not the same as X because -0 + 0 is 0.  */\n \n bool\n-fold_real_zero_addition_p (const_tree type, const_tree addend, int negate)\n+fold_real_zero_addition_p (const_tree type, const_tree arg,\n+                           const_tree zero_arg, int negate)\n {\n-  if (!real_zerop (addend))\n+  if (!real_zerop (zero_arg))\n     return false;\n \n   /* Don't allow the fold with -fsignaling-nans.  */\n-  if (HONOR_SNANS (type))\n+  if (arg ? tree_expr_maybe_signaling_nan_p (arg) : HONOR_SNANS (type))\n     return false;\n \n   /* Allow the fold if zeros aren't signed, or their sign isn't important.  */\n@@ -7158,19 +7161,20 @@ fold_real_zero_addition_p (const_tree type, const_tree addend, int negate)\n     return false;\n \n   /* In a vector or complex, we would need to check the sign of all zeros.  */\n-  if (TREE_CODE (addend) == VECTOR_CST)\n-    addend = uniform_vector_p (addend);\n-  if (!addend || TREE_CODE (addend) != REAL_CST)\n+  if (TREE_CODE (zero_arg) == VECTOR_CST)\n+    zero_arg = uniform_vector_p (zero_arg);\n+  if (!zero_arg || TREE_CODE (zero_arg) != REAL_CST)\n     return false;\n \n   /* Treat x + -0 as x - 0 and x - -0 as x + 0.  */\n-  if (REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (addend)))\n+  if (REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (zero_arg)))\n     negate = !negate;\n \n   /* The mode has signed zeros, and we have to honor their sign.\n-     In this situation, there is only one case we can return true for.\n-     X - 0 is the same as X with default rounding.  */\n-  return negate;\n+     In this situation, there are only two cases we can return true for.\n+     (i) X - 0 is the same as X with default rounding.\n+     (ii) X + 0 is X when X can't possibly be -0.0.  */\n+  return negate || (arg && !tree_expr_maybe_real_minus_zero_p (arg));\n }\n \n /* Subroutine of match.pd that optimizes comparisons of a division by\n@@ -14375,6 +14379,44 @@ tree_expr_maybe_nan_p (const_tree x)\n     }\n }\n \n+/* Return true if expression X could evaluate to -0.0.\n+   This function returns true if uncertain.  */\n+\n+bool\n+tree_expr_maybe_real_minus_zero_p (const_tree x)\n+{\n+  if (!HONOR_SIGNED_ZEROS (x))\n+    return false;\n+  switch (TREE_CODE (x))\n+    {\n+    case REAL_CST:\n+      return REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (x));\n+    case INTEGER_CST:\n+    case FLOAT_EXPR:\n+    case ABS_EXPR:\n+      return false;\n+    case NON_LVALUE_EXPR:\n+    case SAVE_EXPR:\n+      return tree_expr_maybe_real_minus_zero_p (TREE_OPERAND (x, 0));\n+    case COND_EXPR:\n+      return tree_expr_maybe_real_minus_zero_p (TREE_OPERAND (x, 1))\n+\t     || tree_expr_maybe_real_minus_zero_p (TREE_OPERAND (x, 2));\n+    case CALL_EXPR:\n+      switch (get_call_combined_fn (x))\n+\t{\n+\tCASE_CFN_FABS:\n+\t  return false;\n+\tdefault:\n+\t  break;\n+\t}\n+    default:\n+      break;\n+    }\n+  /* Ideally !(tree_expr_nonzero_p (X) || tree_expr_nonnegative_p (X))\n+   * but currently those predicates require tree and not const_tree.  */\n+  return true;\n+}\n+\n #define tree_expr_nonnegative_warnv_p(X, Y) \\\n   _Pragma (\"GCC error \\\"Use RECURSE for recursive calls\\\"\") 0\n "}, {"sha": "0d8d786381eab63515b859162c1cccda68680d76", "filename": "gcc/fold-const.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457", "patch": "@@ -164,7 +164,8 @@ extern bool integer_valued_real_call_p (combined_fn, tree, tree, int);\n extern bool integer_valued_real_single_p (tree, int);\n extern bool integer_valued_real_p (tree, int = 0);\n \n-extern bool fold_real_zero_addition_p (const_tree, const_tree, int);\n+extern bool fold_real_zero_addition_p (const_tree, const_tree, const_tree,\n+\t\t\t\t       int);\n extern tree combine_comparisons (location_t, enum tree_code, enum tree_code,\n \t\t\t\t enum tree_code, tree, tree, tree);\n extern void debug_fold_checksum (const_tree);\n@@ -195,6 +196,7 @@ extern bool tree_expr_signaling_nan_p (const_tree);\n extern bool tree_expr_maybe_signaling_nan_p (const_tree);\n extern bool tree_expr_nan_p (const_tree);\n extern bool tree_expr_maybe_nan_p (const_tree);\n+extern bool tree_maybe_real_minus_zero_p (const_tree);\n extern tree make_range (tree, int *, tree *, tree *, bool *);\n extern tree make_range_step (location_t, enum tree_code, tree, tree, tree,\n \t\t\t     tree *, tree *, int *, bool *);"}, {"sha": "39fb57ee1f415edf693f254bf9003a46ad59b0c0", "filename": "gcc/match.pd", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457", "patch": "@@ -152,13 +152,13 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n    Likewise if the operands are reversed.  */\n (simplify\n  (plus:c @0 real_zerop@1)\n- (if (fold_real_zero_addition_p (type, @1, 0))\n+ (if (fold_real_zero_addition_p (type, @0, @1, 0))\n   (non_lvalue @0)))\n \n /* See if ARG1 is zero and X - ARG1 reduces to X.  */\n (simplify\n  (minus @0 real_zerop@1)\n- (if (fold_real_zero_addition_p (type, @1, 1))\n+ (if (fold_real_zero_addition_p (type, @0, @1, 1))\n   (non_lvalue @0)))\n \n /* Even if the fold_real_zero_addition_p can't simplify X + 0.0\n@@ -190,7 +190,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n    is volatile.  */\n (simplify\n  (minus @0 @0)\n- (if (!FLOAT_TYPE_P (type) || !HONOR_NANS (type))\n+ (if (!FLOAT_TYPE_P (type) || !tree_expr_maybe_nan_p (@0))\n   { build_zero_cst (type); }))\n (simplify\n  (pointer_diff @@0 @0)\n@@ -206,22 +206,24 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n    negative value by 0 gives -0, not +0.  */\n (simplify\n  (mult @0 real_zerop@1)\n- (if (!HONOR_NANS (type) && !HONOR_SIGNED_ZEROS (type))\n+ (if (!tree_expr_maybe_nan_p (@0)\n+      && !tree_expr_maybe_real_minus_zero_p (@0)\n+      && !tree_expr_maybe_real_minus_zero_p (@1))\n   @1))\n \n /* In IEEE floating point, x*1 is not equivalent to x for snans.\n    Likewise for complex arithmetic with signed zeros.  */\n (simplify\n  (mult @0 real_onep)\n- (if (!HONOR_SNANS (type)\n+ (if (!tree_expr_maybe_signaling_nan_p (@0)\n       && (!HONOR_SIGNED_ZEROS (type)\n           || !COMPLEX_FLOAT_TYPE_P (type)))\n   (non_lvalue @0)))\n \n /* Transform x * -1.0 into -x.  */\n (simplify\n  (mult @0 real_minus_onep)\n-  (if (!HONOR_SNANS (type)\n+  (if (!tree_expr_maybe_signaling_nan_p (@0)\n        && (!HONOR_SIGNED_ZEROS (type)\n            || !COMPLEX_FLOAT_TYPE_P (type)))\n    (negate @0)))\n@@ -259,27 +261,27 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n  /* Transform X * (X <= 0.0 ? 1.0 : -1.0) into -abs(X). */\n  (simplify\n   (mult:c @0 (cond (cmp @0 real_zerop) real_onep@1 real_minus_onep))\n-  (if (!HONOR_NANS (type) && !HONOR_SIGNED_ZEROS (type))\n+  (if (!tree_expr_maybe_nan_p (@0) && !HONOR_SIGNED_ZEROS (type))\n    (outp (abs @0))))\n  /* Transform X * (X > 0.0 ? -1.0 : 1.0) into -abs(X). */\n  /* Transform X * (X >= 0.0 ? -1.0 : 1.0) into -abs(X). */\n  /* Transform X * (X < 0.0 ? -1.0 : 1.0) into abs(X). */\n  /* Transform X * (X <= 0.0 ? -1.0 : 1.0) into abs(X). */\n  (simplify\n   (mult:c @0 (cond (cmp @0 real_zerop) real_minus_onep real_onep@1))\n-  (if (!HONOR_NANS (type) && !HONOR_SIGNED_ZEROS (type))\n+  (if (!tree_expr_maybe_nan_p (@0) && !HONOR_SIGNED_ZEROS (type))\n    (outn (abs @0)))))\n \n /* Transform X * copysign (1.0, X) into abs(X). */\n (simplify\n  (mult:c @0 (COPYSIGN_ALL real_onep @0))\n- (if (!HONOR_NANS (type) && !HONOR_SIGNED_ZEROS (type))\n+ (if (!tree_expr_maybe_nan_p (@0) && !HONOR_SIGNED_ZEROS (type))\n   (abs @0)))\n \n /* Transform X * copysign (1.0, -X) into -abs(X). */\n (simplify\n  (mult:c @0 (COPYSIGN_ALL real_onep (negate @0)))\n- (if (!HONOR_NANS (type) && !HONOR_SIGNED_ZEROS (type))\n+ (if (!tree_expr_maybe_nan_p (@0) && !HONOR_SIGNED_ZEROS (type))\n   (negate (abs @0))))\n \n /* Transform copysign (CST, X) into copysign (ABS(CST), X). */\n@@ -444,13 +446,13 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n /* In IEEE floating point, x/1 is not equivalent to x for snans.  */\n (simplify\n  (rdiv @0 real_onep)\n- (if (!HONOR_SNANS (type))\n+ (if (!tree_expr_maybe_signaling_nan_p (@0))\n   (non_lvalue @0)))\n \n /* In IEEE floating point, x/-1 is not equivalent to -x for snans.  */\n (simplify\n  (rdiv @0 real_minus_onep)\n- (if (!HONOR_SNANS (type))\n+ (if (!tree_expr_maybe_signaling_nan_p (@0))\n   (negate @0)))\n \n (if (flag_reciprocal_math)\n@@ -3543,7 +3545,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n    (-ARG1 + ARG0) reduces to -ARG1.  */\n (simplify\n  (minus real_zerop@0 @1)\n- (if (fold_real_zero_addition_p (type, @0, 0))\n+ (if (fold_real_zero_addition_p (type, @1, @0, 0))\n   (negate @1)))\n \n /* Transform x * -1 into -x.  */"}, {"sha": "662bacb62bc006486f1b4fc9b419f065b58ec4be", "filename": "gcc/testsuite/gcc.dg/pr96392.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96392.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96392.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96392.c?ref=5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457", "patch": "@@ -0,0 +1,33 @@\n+/* PR tree-optimization/96392 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+double plus0(int x)\n+{\n+  return x + 0.0;\n+}\n+\n+double sub0(int x)\n+{\n+  return x - 0.0;\n+}\n+\n+double mult0(int x)\n+{\n+  return 0.0 * x;\n+}\n+\n+double negate(int x)\n+{\n+  return 0.0 - x;\n+}\n+\n+double subtract(int x)\n+{\n+  return (double)x - (double)x;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \" \\\\+ \" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \" \\\\- \" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \" \\\\* \" \"optimized\" } } */\n+"}, {"sha": "2dd4435b98101f8426d3e56c9f7fda807a315c18", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=5b02ed4b87685c0f7c5da9b46cde3ce56fcfd457", "patch": "@@ -1062,7 +1062,7 @@ eliminate_using_constants (enum tree_code opcode,\n \t  if (integer_zerop (oelast->op)\n \t      || (FLOAT_TYPE_P (type)\n \t\t  && (opcode == PLUS_EXPR || opcode == MINUS_EXPR)\n-\t\t  && fold_real_zero_addition_p (type, oelast->op,\n+\t\t  && fold_real_zero_addition_p (type, 0, oelast->op,\n \t\t\t\t\t\topcode == MINUS_EXPR)))\n \t    {\n \t      if (ops->length () != 1)"}]}