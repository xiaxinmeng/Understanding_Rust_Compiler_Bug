{"sha": "24c49431499bcb462aeee41e027a3dac25e934b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRjNDk0MzE0OTliY2I0NjJhZWVlNDFlMDI3YTNkYWMyNWU5MzRiMw==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2018-09-05T13:39:38Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2018-09-05T13:39:38Z"}, "message": "Optimise sqrt reciprocal multiplications\n\nThis patch aims to optimise sequences involving uses of 1.0 / sqrt (a) under -freciprocal-math and -funsafe-math-optimizations.\nIn particular consider:\n\nx = 1.0 / sqrt (a);\nr1 = x * x;  // same as 1.0 / a\nr2 = a * x; // same as sqrt (a)\n\nIf x, r1 and r2 are all used further on in the code, this can be transformed into:\ntmp1 = 1.0 / a\ntmp2 = sqrt (a)\ntmp3 = tmp1 * tmp2\nx = tmp3\nr1 = tmp1\nr2 = tmp2\n\nA bit convoluted, but this saves us one multiplication and, more importantly, the sqrt and division are now independent.\nThis also allows optimisation of a subset of these expressions.\nFor example:\nx = 1.0 / sqrt (a)\nr1 = x * x\n\ncan be transformed to r1 = 1.0 / a, eliminating the sqrt if x is not used anywhere else.\nAnd similarly:\nx = 1.0 / sqrt (a)\nr1 = a * x\n\ncan be transformed to sqrt (a) eliminating the division.\n\nFor the testcase:\ndouble res, res2, tmp;\nvoid\nfoo (double a, double b)\n{\n  tmp = 1.0 / __builtin_sqrt (a);\n  res = tmp * tmp;\n  res2 = a * tmp;\n}\n\nWe now generate for aarch64 with -Ofast:\nfoo:\n        fmov    d2, 1.0e+0\n        adrp    x2, res2\n        fsqrt   d1, d0\n        adrp    x1, res\n        fdiv    d0, d2, d0\n        adrp    x0, tmp\n        str     d1, [x2, #:lo12:res2]\n        fmul    d1, d1, d0\n        str     d0, [x1, #:lo12:res]\n        str     d1, [x0, #:lo12:tmp]\n        ret\n\nwhere before it generated:\nfoo:\n        fsqrt   d2, d0\n        fmov    d1, 1.0e+0\n        adrp    x1, res2\n        adrp    x2, tmp\n        adrp    x0, res\n        fdiv    d1, d1, d2\n        fmul    d0, d1, d0\n        fmul    d2, d1, d1\n        str     d1, [x2, #:lo12:tmp]\n        str     d0, [x1, #:lo12:res2]\n        str     d2, [x0, #:lo12:res]\n        ret\n\nAs you can see, the new sequence has one fewer multiply and the fsqrt and fdiv are independent. \n\n\t* tree-ssa-math-opts.c (is_mult_by): New function.\n\t(is_square_of): Use the above.\n\t(optimize_recip_sqrt): New function.\n\t(pass_cse_reciprocals::execute): Use the above.\n\n\t* gcc.dg/recip_sqrt_mult_1.c: New test.\n\t* gcc.dg/recip_sqrt_mult_2.c: Likewise.\n\t* gcc.dg/recip_sqrt_mult_3.c: Likewise.\n\t* gcc.dg/recip_sqrt_mult_4.c: Likewise.\n\t* gcc.dg/recip_sqrt_mult_5.c: Likewise.\n\t* g++.dg/recip_sqrt_mult_1.C: Likewise.\n\t* g++.dg/recip_sqrt_mult_2.C: Likewise.\n\nFrom-SVN: r264126", "tree": {"sha": "65e7f2c1e0a84d7ea2da8fca45dd3c7b86341ccb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65e7f2c1e0a84d7ea2da8fca45dd3c7b86341ccb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24c49431499bcb462aeee41e027a3dac25e934b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24c49431499bcb462aeee41e027a3dac25e934b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24c49431499bcb462aeee41e027a3dac25e934b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24c49431499bcb462aeee41e027a3dac25e934b3/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "76a5eae5494440844a9b6d0171efdcf4ebb6f3c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76a5eae5494440844a9b6d0171efdcf4ebb6f3c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76a5eae5494440844a9b6d0171efdcf4ebb6f3c6"}], "stats": {"total": 399, "additions": 395, "deletions": 4}, "files": [{"sha": "f398c609302a8cd9426c742eb8cd4aa46be28c72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=24c49431499bcb462aeee41e027a3dac25e934b3", "patch": "@@ -1,3 +1,10 @@\n+2018-09-05  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* tree-ssa-math-opts.c (is_mult_by): New function.\n+\t(is_square_of): Use the above.\n+\t(optimize_recip_sqrt): New function.\n+\t(pass_cse_reciprocals::execute): Use the above.\n+\n 2018-09-05  Richard Biener  <rguenther@suse.de>\n \n \tPR bootstrap/87134"}, {"sha": "74467f9ee18c8647b224bd98dee339e0bbd0b855", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=24c49431499bcb462aeee41e027a3dac25e934b3", "patch": "@@ -1,3 +1,13 @@\n+2018-09-05  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* gcc.dg/recip_sqrt_mult_1.c: New test.\n+\t* gcc.dg/recip_sqrt_mult_2.c: Likewise.\n+\t* gcc.dg/recip_sqrt_mult_3.c: Likewise.\n+\t* gcc.dg/recip_sqrt_mult_4.c: Likewise.\n+\t* gcc.dg/recip_sqrt_mult_5.c: Likewise.\n+\t* g++.dg/recip_sqrt_mult_1.C: Likewise.\n+\t* g++.dg/recip_sqrt_mult_2.C: Likewise.\n+\n 2018-09-05  Martin Liska  <mliska@suse.cz>\n \n \tPR tree-optimization/87205"}, {"sha": "11d9c6f758f1529d8ed4cadf85010f6ce379c195", "filename": "gcc/testsuite/g++.dg/recip_sqrt_mult_1.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Frecip_sqrt_mult_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Frecip_sqrt_mult_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Frecip_sqrt_mult_1.C?ref=24c49431499bcb462aeee41e027a3dac25e934b3", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -fnon-call-exceptions -fdump-tree-recip\" } */\n+\n+double res, res2, tmp;\n+void\n+foo1 (double a, double b)\n+{\n+  try {\n+    tmp = 1.0 / __builtin_sqrt (a);\n+    res = tmp * tmp;\n+    res2 = a * tmp;\n+  }\n+  catch (...)\n+    { ; }\n+}\n+\n+void\n+foo4 (double a, double b, int c, int d)\n+{\n+  try {\n+    tmp = 1.0 / __builtin_sqrt (a);\n+  }\n+  catch (...)\n+    {\n+      if (c)\n+\tres = tmp * tmp;\n+\n+      if (d)\n+\tres2 = a * tmp;\n+    }\n+}\n+\n+void\n+foo5 (double a, double b, int c, int d)\n+{\n+  try {\n+    tmp = 1.0 / __builtin_sqrt (a);\n+    res = tmp * tmp;\n+\n+    if (d)\n+      res2 = a * tmp;\n+  }\n+  catch (...)\n+    { ; }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Optimizing reciprocal sqrt multiplications\" 2 \"recip\" } } */\n+/* { dg-final { scan-tree-dump-times \"Replacing squaring multiplication\" 2 \"recip\" } } */\n+/* { dg-final { scan-tree-dump-times \"Replacing original division\" 2 \"recip\" } } */"}, {"sha": "cca12caf4d79bfa69933d9b8fce41f38bb5b7a19", "filename": "gcc/testsuite/g++.dg/recip_sqrt_mult_2.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Frecip_sqrt_mult_2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Frecip_sqrt_mult_2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Frecip_sqrt_mult_2.C?ref=24c49431499bcb462aeee41e027a3dac25e934b3", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-w -Ofast -fnon-call-exceptions -ftrapping-math -fdump-tree-recip\" } */\n+\n+/* Check that the recip_sqrt optimization does not trigger here, causing an\n+   ICE due to EH info.  */\n+\n+\n+double res, res2, tmp;\n+void\n+foo1 (double a, double b)\n+{\n+  try {\n+    tmp = 1.0 / __builtin_sqrt (a);\n+    res = tmp * tmp;\n+    res2 = a * tmp;\n+  }\n+  catch (...)\n+    { ; }\n+}\n+\n+void\n+foo4 (double a, double b, int c, int d)\n+{\n+  try {\n+    tmp = 1.0 / __builtin_sqrt (a);\n+  }\n+  catch (...)\n+    {\n+      if (c)\n+\tres = tmp * tmp;\n+\n+      if (d)\n+\tres2 = a * tmp;\n+    }\n+}\n+\n+void\n+foo5 (double a, double b, int c, int d)\n+{\n+  try {\n+    tmp = 1.0 / __builtin_sqrt (a);\n+    res = tmp * tmp;\n+\n+    if (d)\n+      res2 = a * tmp;\n+  }\n+  catch (...)\n+    { ; }\n+}"}, {"sha": "188390a4ecffca1b21f05c4f19abecfb7ebd188f", "filename": "gcc/testsuite/gcc.dg/recip_sqrt_mult_1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2Ftestsuite%2Fgcc.dg%2Frecip_sqrt_mult_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2Ftestsuite%2Fgcc.dg%2Frecip_sqrt_mult_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Frecip_sqrt_mult_1.c?ref=24c49431499bcb462aeee41e027a3dac25e934b3", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -fdump-tree-recip\" } */\n+\n+double res, res2, tmp;\n+void\n+foo (double a, double b)\n+{\n+  tmp = 1.0 / __builtin_sqrt (a);\n+  res = tmp * tmp;\n+  res2 = a * tmp;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Optimizing reciprocal sqrt multiplications\" \"recip\" } } */\n+/* { dg-final { scan-tree-dump \"Replacing squaring multiplication\" \"recip\" } } */\n+/* { dg-final { scan-tree-dump \"Replacing original division\" \"recip\" } } */"}, {"sha": "c5fc3de7b657b1769e76254b4bc874e0595e43ef", "filename": "gcc/testsuite/gcc.dg/recip_sqrt_mult_2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2Ftestsuite%2Fgcc.dg%2Frecip_sqrt_mult_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2Ftestsuite%2Fgcc.dg%2Frecip_sqrt_mult_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Frecip_sqrt_mult_2.c?ref=24c49431499bcb462aeee41e027a3dac25e934b3", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -fdump-tree-optimized\" } */\n+\n+float\n+foo (float a)\n+{\n+  float tmp = 1.0f / __builtin_sqrtf (a);\n+  return a * tmp;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \" / \" \"optimized\" } } */"}, {"sha": "e7d185ba7e22cfc7cca72296d5ccc544f24fdb14", "filename": "gcc/testsuite/gcc.dg/recip_sqrt_mult_3.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2Ftestsuite%2Fgcc.dg%2Frecip_sqrt_mult_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2Ftestsuite%2Fgcc.dg%2Frecip_sqrt_mult_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Frecip_sqrt_mult_3.c?ref=24c49431499bcb462aeee41e027a3dac25e934b3", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -fdump-tree-optimized\" } */\n+\n+double\n+foo (double a)\n+{\n+  double tmp = 1.0f / __builtin_sqrt (a);\n+  return tmp * tmp;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"__builtin_sqrt\" \"optimized\" } } */"}, {"sha": "e3005f2feb6f4bacbb6eafc0155e196cb866fcdf", "filename": "gcc/testsuite/gcc.dg/recip_sqrt_mult_4.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2Ftestsuite%2Fgcc.dg%2Frecip_sqrt_mult_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2Ftestsuite%2Fgcc.dg%2Frecip_sqrt_mult_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Frecip_sqrt_mult_4.c?ref=24c49431499bcb462aeee41e027a3dac25e934b3", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -fdump-tree-recip\" } */\n+\n+/* The main path doesn't have any multiplications.\n+   Avoid introducing them in the recip pass.  */\n+\n+double res, res2, tmp;\n+void\n+foo (double a, double b, int c, int d)\n+{\n+  tmp = 1.0 / __builtin_sqrt (a);\n+  if (c)\n+    res = tmp * tmp;\n+\n+  if (d)\n+    res2 = a * tmp;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Optimizing reciprocal sqrt multiplications\" \"recip\" } } */\n+/* { dg-final { scan-tree-dump-not \"Replacing squaring multiplication\" \"recip\" } } */\n+/* { dg-final { scan-tree-dump-not \"Replacing original division\" \"recip\" } } */"}, {"sha": "e871f0fcd4feb1687f9815e4babf4d0667a15ea8", "filename": "gcc/testsuite/gcc.dg/recip_sqrt_mult_5.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2Ftestsuite%2Fgcc.dg%2Frecip_sqrt_mult_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2Ftestsuite%2Fgcc.dg%2Frecip_sqrt_mult_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Frecip_sqrt_mult_5.c?ref=24c49431499bcb462aeee41e027a3dac25e934b3", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -fdump-tree-recip\" } */\n+\n+/* We want to do the recip_sqrt transformations here there is already\n+   a multiplication on the main path.  */\n+\n+double res, res2, tmp;\n+void\n+foo (double a, double b, int c, int d)\n+{\n+  tmp = 1.0 / __builtin_sqrt (a);\n+  res = tmp * tmp;\n+\n+  if (d)\n+    res2 = a * tmp;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Optimizing reciprocal sqrt multiplications\" \"recip\" } } */\n+/* { dg-final { scan-tree-dump \"Replacing squaring multiplication\" \"recip\" } } */\n+/* { dg-final { scan-tree-dump \"Replacing original division\" \"recip\" } } */"}, {"sha": "19bff5c3c3715f3e194e1c091ae01f6c4d6d2ce8", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 202, "deletions": 4, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24c49431499bcb462aeee41e027a3dac25e934b3/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=24c49431499bcb462aeee41e027a3dac25e934b3", "patch": "@@ -337,21 +337,29 @@ is_division_by (gimple *use_stmt, tree def)\n \t && gimple_assign_rhs1 (use_stmt) != def;\n }\n \n-/* Return whether USE_STMT is DEF * DEF.  */\n+/* Return TRUE if USE_STMT is a multiplication of DEF by A.  */\n static inline bool\n-is_square_of (gimple *use_stmt, tree def)\n+is_mult_by (gimple *use_stmt, tree def, tree a)\n {\n   if (gimple_code (use_stmt) == GIMPLE_ASSIGN\n       && gimple_assign_rhs_code (use_stmt) == MULT_EXPR)\n     {\n       tree op0 = gimple_assign_rhs1 (use_stmt);\n       tree op1 = gimple_assign_rhs2 (use_stmt);\n \n-      return op0 == op1 && op0 == def;\n+      return (op0 == def && op1 == a)\n+\t      || (op0 == a && op1 == def);\n     }\n   return 0;\n }\n \n+/* Return whether USE_STMT is DEF * DEF.  */\n+static inline bool\n+is_square_of (gimple *use_stmt, tree def)\n+{\n+  return is_mult_by (use_stmt, def, def);\n+}\n+\n /* Return whether USE_STMT is a floating-point division by\n    DEF * DEF.  */\n static inline bool\n@@ -526,6 +534,188 @@ free_bb (struct occurrence *occ)\n     }\n }\n \n+/* Transform sequences like\n+   t = sqrt (a)\n+   x = 1.0 / t;\n+   r1 = x * x;\n+   r2 = a * x;\n+   into:\n+   t = sqrt (a)\n+   r1 = 1.0 / a;\n+   r2 = t;\n+   x = r1 * r2;\n+   depending on the uses of x, r1, r2.  This removes one multiplication and\n+   allows the sqrt and division operations to execute in parallel.\n+   DEF_GSI is the gsi of the initial division by sqrt that defines\n+   DEF (x in the example abovs).  */\n+\n+static void\n+optimize_recip_sqrt (gimple_stmt_iterator *def_gsi, tree def)\n+{\n+  gimple *use_stmt;\n+  imm_use_iterator use_iter;\n+  gimple *stmt = gsi_stmt (*def_gsi);\n+  tree x = def;\n+  tree orig_sqrt_ssa_name = gimple_assign_rhs2 (stmt);\n+  tree div_rhs1 = gimple_assign_rhs1 (stmt);\n+\n+  if (TREE_CODE (orig_sqrt_ssa_name) != SSA_NAME\n+      || TREE_CODE (div_rhs1) != REAL_CST\n+      || !real_equal (&TREE_REAL_CST (div_rhs1), &dconst1))\n+    return;\n+\n+  gcall *sqrt_stmt\n+    = dyn_cast <gcall *> (SSA_NAME_DEF_STMT (orig_sqrt_ssa_name));\n+\n+  if (!sqrt_stmt || !gimple_call_lhs (sqrt_stmt))\n+    return;\n+\n+  switch (gimple_call_combined_fn (sqrt_stmt))\n+    {\n+    CASE_CFN_SQRT:\n+    CASE_CFN_SQRT_FN:\n+      break;\n+\n+    default:\n+      return;\n+    }\n+  tree a = gimple_call_arg (sqrt_stmt, 0);\n+\n+  /* We have 'a' and 'x'.  Now analyze the uses of 'x'.  */\n+\n+  /* Statements that use x in x * x.  */\n+  auto_vec<gimple *> sqr_stmts;\n+  /* Statements that use x in a * x.  */\n+  auto_vec<gimple *> mult_stmts;\n+  bool has_other_use = false;\n+  bool mult_on_main_path = false;\n+\n+  FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, x)\n+    {\n+      if (is_gimple_debug (use_stmt))\n+\tcontinue;\n+      if (is_square_of (use_stmt, x))\n+\t{\n+\t  sqr_stmts.safe_push (use_stmt);\n+\t  if (gimple_bb (use_stmt) == gimple_bb (stmt))\n+\t    mult_on_main_path = true;\n+\t}\n+      else if (is_mult_by (use_stmt, x, a))\n+\t{\n+\t  mult_stmts.safe_push (use_stmt);\n+\t  if (gimple_bb (use_stmt) == gimple_bb (stmt))\n+\t    mult_on_main_path = true;\n+\t}\n+      else\n+\thas_other_use = true;\n+    }\n+\n+  /* In the x * x and a * x cases we just rewire stmt operands or\n+     remove multiplications.  In the has_other_use case we introduce\n+     a multiplication so make sure we don't introduce a multiplication\n+     on a path where there was none.  */\n+  if (has_other_use && !mult_on_main_path)\n+    return;\n+\n+  if (sqr_stmts.is_empty () && mult_stmts.is_empty ())\n+    return;\n+\n+  /* If x = 1.0 / sqrt (a) has uses other than those optimized here we want\n+     to be able to compose it from the sqr and mult cases.  */\n+  if (has_other_use && (sqr_stmts.is_empty () || mult_stmts.is_empty ()))\n+    return;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Optimizing reciprocal sqrt multiplications of\\n\");\n+      print_gimple_stmt (dump_file, sqrt_stmt, 0, TDF_NONE);\n+      print_gimple_stmt (dump_file, stmt, 0, TDF_NONE);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  bool delete_div = !has_other_use;\n+  tree sqr_ssa_name = NULL_TREE;\n+  if (!sqr_stmts.is_empty ())\n+    {\n+      /* r1 = x * x.  Transform the original\n+\t x = 1.0 / t\n+\t into\n+\t tmp1 = 1.0 / a\n+\t r1 = tmp1.  */\n+\n+      sqr_ssa_name\n+\t= make_temp_ssa_name (TREE_TYPE (a), NULL, \"recip_sqrt_sqr\");\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Replacing original division\\n\");\n+\t  print_gimple_stmt (dump_file, stmt, 0, TDF_NONE);\n+\t  fprintf (dump_file, \"with new division\\n\");\n+\t}\n+      gimple_assign_set_lhs (stmt, sqr_ssa_name);\n+      gimple_assign_set_rhs2 (stmt, a);\n+      fold_stmt_inplace (def_gsi);\n+      update_stmt (stmt);\n+\n+      if (dump_file)\n+\tprint_gimple_stmt (dump_file, stmt, 0, TDF_NONE);\n+\n+      delete_div = false;\n+      gimple *sqr_stmt;\n+      unsigned int i;\n+      FOR_EACH_VEC_ELT (sqr_stmts, i, sqr_stmt)\n+\t{\n+\t  gimple_stmt_iterator gsi2 = gsi_for_stmt (sqr_stmt);\n+\t  gimple_assign_set_rhs_from_tree (&gsi2, sqr_ssa_name);\n+\t  update_stmt (sqr_stmt);\n+\t}\n+    }\n+  if (!mult_stmts.is_empty ())\n+    {\n+      /* r2 = a * x.  Transform this into:\n+\t r2 = t (The original sqrt (a)).  */\n+      unsigned int i;\n+      gimple *mult_stmt = NULL;\n+      FOR_EACH_VEC_ELT (mult_stmts, i, mult_stmt)\n+\t{\n+\t  gimple_stmt_iterator gsi2 = gsi_for_stmt (mult_stmt);\n+\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Replacing squaring multiplication\\n\");\n+\t      print_gimple_stmt (dump_file, mult_stmt, 0, TDF_NONE);\n+\t      fprintf (dump_file, \"with assignment\\n\");\n+\t    }\n+\t  gimple_assign_set_rhs_from_tree (&gsi2, orig_sqrt_ssa_name);\n+\t  fold_stmt_inplace (&gsi2);\n+\t  update_stmt (mult_stmt);\n+\t  if (dump_file)\n+\t    print_gimple_stmt (dump_file, mult_stmt, 0, TDF_NONE);\n+      }\n+    }\n+\n+  if (has_other_use)\n+    {\n+      /* Using the two temporaries tmp1, tmp2 from above\n+\t the original x is now:\n+\t x = tmp1 * tmp2.  */\n+      gcc_assert (orig_sqrt_ssa_name);\n+      gcc_assert (sqr_ssa_name);\n+\n+      gimple *new_stmt\n+\t= gimple_build_assign (x, MULT_EXPR,\n+\t\t\t\torig_sqrt_ssa_name, sqr_ssa_name);\n+      gsi_insert_after (def_gsi, new_stmt, GSI_NEW_STMT);\n+      update_stmt (stmt);\n+    }\n+  else if (delete_div)\n+    {\n+      /* Remove the original division.  */\n+      gimple_stmt_iterator gsi2 = gsi_for_stmt (stmt);\n+      gsi_remove (&gsi2, true);\n+      release_defs (stmt);\n+    }\n+}\n \n /* Look for floating-point divisions among DEF's uses, and try to\n    replace them by multiplications with the reciprocal.  Add\n@@ -756,7 +946,15 @@ pass_cse_reciprocals::execute (function *fun)\n \t      && (def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF)) != NULL\n \t      && FLOAT_TYPE_P (TREE_TYPE (def))\n \t      && TREE_CODE (def) == SSA_NAME)\n-\t    execute_cse_reciprocals_1 (&gsi, def);\n+\t    {\n+\t      if (flag_unsafe_math_optimizations\n+\t\t  && is_gimple_assign (stmt)\n+\t\t  && !stmt_can_throw_internal (stmt)\n+\t\t  && gimple_assign_rhs_code (stmt) == RDIV_EXPR)\n+\t\toptimize_recip_sqrt (&gsi, def);\n+\t      else\n+\t\texecute_cse_reciprocals_1 (&gsi, def);\n+\t    }\n \t}\n \n       if (optimize_bb_for_size_p (bb))"}]}