{"sha": "95cdcf701dad826f225d6413b59650f181954399", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVjZGNmNzAxZGFkODI2ZjIyNWQ2NDEzYjU5NjUwZjE4MTk1NDM5OQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2020-06-29T21:11:06Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2020-06-29T21:11:30Z"}, "message": "Do not generate recursion check for compiler-generated procedures.\n\nThis one-line fix removes a check for recursion for procedures\nwhich are compiler-generated, such as finalizers or deallocation.\nThese need to be recursive, even if the user code should not be.\n\ngcc/fortran/ChangeLog:\n\n\tPR fortran/95743\n\t* trans-decl.c (gfc_generate_function_code): Do not generate\n\trecursion check for compiler-generated procedures.", "tree": {"sha": "03f4708f939f322b199be542123f16d20d65da8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03f4708f939f322b199be542123f16d20d65da8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95cdcf701dad826f225d6413b59650f181954399", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95cdcf701dad826f225d6413b59650f181954399", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95cdcf701dad826f225d6413b59650f181954399", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95cdcf701dad826f225d6413b59650f181954399/comments", "author": null, "committer": null, "parents": [{"sha": "ace60939fd27271fe3b3e53621eca80c7357836c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ace60939fd27271fe3b3e53621eca80c7357836c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ace60939fd27271fe3b3e53621eca80c7357836c"}], "stats": {"total": 27, "additions": 26, "deletions": 1}, "files": [{"sha": "769ab20c82d6a8b5d279e50b728b723518c9a91f", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95cdcf701dad826f225d6413b59650f181954399/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95cdcf701dad826f225d6413b59650f181954399/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=95cdcf701dad826f225d6413b59650f181954399", "patch": "@@ -6789,7 +6789,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n \t\t || (sym->attr.entry_master\n \t\t     && sym->ns->entries->sym->attr.recursive);\n   if ((gfc_option.rtcheck & GFC_RTCHECK_RECURSION)\n-      && !is_recursive && !flag_recursive)\n+      && !is_recursive && !flag_recursive && !sym->attr.artificial)\n     {\n       char * msg;\n "}, {"sha": "d8e9d69ea7b82e1ae85b2839f04c0d8a545428a3", "filename": "gcc/testsuite/gfortran.dg/recursive_check_16.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95cdcf701dad826f225d6413b59650f181954399/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_16.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95cdcf701dad826f225d6413b59650f181954399/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_16.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_16.f90?ref=95cdcf701dad826f225d6413b59650f181954399", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do  run }\n+! ! { dg-options \"-fcheck=recursion\" }\n+! PR 95743 - this used cause a runtime error.\n+! Test case by Antoine Lemoine\n+\n+program test_recursive_call\n+   implicit none\n+\n+   type t_tree_node\n+      type(t_tree_node), dimension(:), allocatable :: child\n+   end type\n+\n+   type t_tree\n+      type(t_tree_node), allocatable :: root\n+   end type\n+\n+   type(t_tree), allocatable :: tree\n+\n+   allocate(tree)\n+   allocate(tree%root)\n+   allocate(tree%root%child(1))\n+   ! If the line below is removed, the code works fine.\n+   allocate(tree%root%child(1)%child(1))\n+   deallocate(tree)\n+end program"}]}