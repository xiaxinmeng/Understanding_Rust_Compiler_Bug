{"sha": "110cfe1cdcd721d4d6936bb8a922a3c4b129abbe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEwY2ZlMWNkY2Q3MjFkNGQ2OTM2YmI4YTkyMmEzYzRiMTI5YWJiZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-12-29T11:10:31Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-12-29T11:10:31Z"}, "message": "tree-inline.c (remap_ssa_name): New function.\n\n\t* tree-inline.c (remap_ssa_name): New function.\n\t(remap_decl): Update SSA datastructures for DECLs.\n\t(copy_body_r): Deal with SSA_NAMEs; add referenced global vars.\n\t(copy_bb): Set SSA_NAME def stmts.\n\t(update_ssa_acorss_eh_edges): New function.\n\t(copy_edge_for_bb): Call it; mark new vars for renaming.\n\t(copy_phis_for_bb): New function.\n\t(initialize_cfun): Break out from ...\n\t(copy_cfg_body): ... here; maintain AUX map for both directions;\n\tcall SSA updating workers; do not produce copy of cfun to be copied.\n\t(setup_one_parameter): Do propagation across SSA form.\n\t(declare_return_variable): Work on SSA; use return_slot instead of\n\taddress of return slot of argument to avoid folding back and forth.\n\t(expand_call_inline): Update SSA from on return values.\n\t(optimize_inline_calls): Do sanity checking, dead blocks removal,\n\tupdate SSA form.\n\t(tree_function_verioning): Update initialize_cfun.\n\nFrom-SVN: r120260", "tree": {"sha": "23e644f639ad7d69d096c7721f91be51fc73a263", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23e644f639ad7d69d096c7721f91be51fc73a263"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/110cfe1cdcd721d4d6936bb8a922a3c4b129abbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/110cfe1cdcd721d4d6936bb8a922a3c4b129abbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/110cfe1cdcd721d4d6936bb8a922a3c4b129abbe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/110cfe1cdcd721d4d6936bb8a922a3c4b129abbe/comments", "author": null, "committer": null, "parents": [{"sha": "9d30f270db7f21cd6a501dc94b28a76831444e87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d30f270db7f21cd6a501dc94b28a76831444e87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d30f270db7f21cd6a501dc94b28a76831444e87"}], "stats": {"total": 669, "additions": 525, "deletions": 144}, "files": [{"sha": "f4c9b9c14ead555b64a93794f4404f88380262dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110cfe1cdcd721d4d6936bb8a922a3c4b129abbe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110cfe1cdcd721d4d6936bb8a922a3c4b129abbe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=110cfe1cdcd721d4d6936bb8a922a3c4b129abbe", "patch": "@@ -1,3 +1,23 @@\n+2006-12-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-inline.c (remap_ssa_name): New function.\n+\t(remap_decl): Update SSA datastructures for DECLs.\n+\t(copy_body_r): Deal with SSA_NAMEs; add referenced global vars.\n+\t(copy_bb): Set SSA_NAME def stmts.\n+\t(update_ssa_acorss_eh_edges): New function.\n+\t(copy_edge_for_bb): Call it; mark new vars for renaming.\n+\t(copy_phis_for_bb): New function.\n+\t(initialize_cfun): Break out from ...\n+\t(copy_cfg_body): ... here; maintain AUX map for both directions;\n+\tcall SSA updating workers; do not produce copy of cfun to be copied.\n+\t(setup_one_parameter): Do propagation across SSA form.\n+\t(declare_return_variable): Work on SSA; use return_slot instead of\n+\taddress of return slot of argument to avoid folding back and forth.\n+\t(expand_call_inline): Update SSA from on return values.\n+\t(optimize_inline_calls): Do sanity checking, dead blocks removal,\n+\tupdate SSA form.\n+\t(tree_function_verioning): Update initialize_cfun.\n+\n 2006-12-29  Marcin Dalecki  <martin@dalecki.de>\n \n \t* doc/invoke.texi: Replace no longer supported -fno-strength-reduce"}, {"sha": "8843eb27fde25da88cc4b8d516974f36e241999e", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 505, "deletions": 144, "changes": 649, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/110cfe1cdcd721d4d6936bb8a922a3c4b129abbe/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/110cfe1cdcd721d4d6936bb8a922a3c4b129abbe/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=110cfe1cdcd721d4d6936bb8a922a3c4b129abbe", "patch": "@@ -50,6 +50,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"pointer-set.h\"\n #include \"ipa-prop.h\"\n #include \"value-prof.h\"\n+#include \"tree-pass.h\"\n \n /* I'm not real happy about this, but we need to handle gimple and\n    non-gimple trees.  */\n@@ -141,6 +142,50 @@ insert_decl_map (copy_body_data *id, tree key, tree value)\n \t\t       (splay_tree_value) value);\n }\n \n+/* Construct new SSA name for old NAME. ID is the inline context.  */\n+\n+static tree\n+remap_ssa_name (tree name, copy_body_data *id)\n+{\n+  tree new;\n+  splay_tree_node n;\n+\n+  gcc_assert (TREE_CODE (name) == SSA_NAME);\n+\n+  n = splay_tree_lookup (id->decl_map, (splay_tree_key) name);\n+  if (n)\n+    return (tree) n->value;\n+\n+  /* Do not set DEF_STMT yet as statement is not copied yet. We do that\n+     in copy_bb.  */\n+  new = remap_decl (SSA_NAME_VAR (name), id);\n+  /* We might've substituted constant or another SSA_NAME for\n+     the variable. \n+\n+     Replace the SSA name representing RESULT_DECL by variable during\n+     inlining:  this saves us from need to introduce PHI node in a case\n+     return value is just partly initialized.  */\n+  if ((TREE_CODE (new) == VAR_DECL || TREE_CODE (new) == PARM_DECL)\n+      && (TREE_CODE (SSA_NAME_VAR (name)) != RESULT_DECL\n+\t  || !id->transform_return_to_modify))\n+    {\n+      new = make_ssa_name (new, NULL);\n+      insert_decl_map (id, name, new);\n+      if (IS_EMPTY_STMT (SSA_NAME_DEF_STMT (name)))\n+\t{\n+\t  SSA_NAME_DEF_STMT (new) = build_empty_stmt ();\n+\t  if (gimple_default_def (id->src_cfun, SSA_NAME_VAR (name)) == name)\n+\t    set_default_def (SSA_NAME_VAR (new), new);\n+\t}\n+      SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new)\n+\t= SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name);\n+      TREE_TYPE (new) = TREE_TYPE (SSA_NAME_VAR (new));\n+    }\n+  else\n+    insert_decl_map (id, name, new);\n+  return new;\n+}\n+\n /* Remap DECL during the copying of the BLOCK tree for the function.  */\n \n tree\n@@ -188,6 +233,22 @@ remap_decl (tree decl, copy_body_data *id)\n \t    walk_tree (&DECL_QUALIFIER (t), copy_body_r, id, NULL);\n \t}\n \n+      if (cfun && gimple_in_ssa_p (cfun)\n+\t  && (TREE_CODE (t) == VAR_DECL\n+\t      || TREE_CODE (t) == RESULT_DECL || TREE_CODE (t) == PARM_DECL))\n+\t{\n+          tree def = gimple_default_def (id->src_cfun, decl);\n+\t  get_var_ann (t);\n+\t  if (TREE_CODE (decl) != PARM_DECL && def)\n+\t    {\n+\t      tree map = remap_ssa_name (def, id);\n+\t      /* Watch out RESULT_DECLs whose SSA names map directly\n+\t\t to them.  */\n+\t      if (TREE_CODE (map) == SSA_NAME)\n+\t        set_default_def (t, map);\n+\t    }\n+\t  add_referenced_var (t);\n+\t}\n       return t;\n     }\n \n@@ -500,6 +561,12 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t  return (tree) (void *)1;\n \t}\n     }\n+  else if (TREE_CODE (*tp) == SSA_NAME)\n+    {\n+      *tp = remap_ssa_name (*tp, id);\n+      *walk_subtrees = 0;\n+      return NULL;\n+    }\n \n   /* Local variables and labels need to be replaced by equivalent\n      variables.  We don't want to copy static variables; there's only\n@@ -621,6 +688,11 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n       /* Here is the \"usual case\".  Copy this tree node, and then\n \t tweak some special cases.  */\n       copy_tree_r (tp, walk_subtrees, NULL);\n+\n+      /* Global variables we didn't seen yet needs to go into referenced\n+\t vars.  */\n+      if (gimple_in_ssa_p (cfun) && TREE_CODE (*tp) == VAR_DECL)\n+\tadd_referenced_var (*tp);\n        \n       /* If EXPR has block defined, map it to newly constructed block.\n          When inlining we want EXPRs without block appear in the block\n@@ -718,74 +790,132 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale, int count_scal\n \t    gimplify_stmt (&stmt);\n \n           bsi_insert_after (&copy_bsi, stmt, BSI_NEW_STMT);\n-\t  call = get_call_expr_in (stmt);\n-\t  /* We're duplicating a CALL_EXPR.  Find any corresponding\n-\t     callgraph edges and update or duplicate them.  */\n-\t  if (call && (decl = get_callee_fndecl (call)))\n+\n+\t  /* Process new statement.  gimplify_stmt possibly turned statement\n+\t     into multiple statements, we need to process all of them.  */\n+\t  while (!bsi_end_p (copy_bsi))\n \t    {\n-\t      struct cgraph_node *node;\n-\t      struct cgraph_edge *edge;\n-\t     \n-\t      switch (id->transform_call_graph_edges)\n+\t      stmt = bsi_stmt (copy_bsi);\n+\t      call = get_call_expr_in (stmt);\n+\t      /* We're duplicating a CALL_EXPR.  Find any corresponding\n+\t\t callgraph edges and update or duplicate them.  */\n+\t      if (call && (decl = get_callee_fndecl (call)))\n \t\t{\n-\t\tcase CB_CGE_DUPLICATE:\n-\t\t  edge = cgraph_edge (id->src_node, orig_stmt);\n-\t\t  if (edge)\n-\t\t    cgraph_clone_edge (edge, id->dst_node, stmt,\n-\t\t\t\t       REG_BR_PROB_BASE, 1, true);\n-\t\t  break;\n-\n-\t\tcase CB_CGE_MOVE_CLONES:\n-\t\t  for (node = id->dst_node->next_clone;\n-\t\t       node;\n-\t\t       node = node->next_clone)\n+\t\t  struct cgraph_node *node;\n+\t\t  struct cgraph_edge *edge;\n+\t\t \n+\t\t  switch (id->transform_call_graph_edges)\n \t\t    {\n-\t\t      edge = cgraph_edge (node, orig_stmt);\n-\t\t      gcc_assert (edge);\n-\t\t      cgraph_set_call_stmt (edge, stmt);\n+\t\t    case CB_CGE_DUPLICATE:\n+\t\t      edge = cgraph_edge (id->src_node, orig_stmt);\n+\t\t      if (edge)\n+\t\t\tcgraph_clone_edge (edge, id->dst_node, stmt,\n+\t\t\t\t\t   REG_BR_PROB_BASE, 1, true);\n+\t\t      break;\n+\n+\t\t    case CB_CGE_MOVE_CLONES:\n+\t\t      for (node = id->dst_node->next_clone;\n+\t\t\t   node;\n+\t\t\t   node = node->next_clone)\n+\t\t\t{\n+\t\t\t  edge = cgraph_edge (node, orig_stmt);\n+\t\t\t  gcc_assert (edge);\n+\t\t\t  cgraph_set_call_stmt (edge, stmt);\n+\t\t\t}\n+\t\t      /* FALLTHRU */\n+\n+\t\t    case CB_CGE_MOVE:\n+\t\t      edge = cgraph_edge (id->dst_node, orig_stmt);\n+\t\t      if (edge)\n+\t\t\tcgraph_set_call_stmt (edge, stmt);\n+\t\t      break;\n+\n+\t\t    default:\n+\t\t      gcc_unreachable ();\n \t\t    }\n-\t\t  /* FALLTHRU */\n-\n-\t\tcase CB_CGE_MOVE:\n-\t\t  edge = cgraph_edge (id->dst_node, orig_stmt);\n-\t\t  if (edge)\n-\t\t    cgraph_set_call_stmt (edge, stmt);\n-\t\t  break;\n+\t\t}\n+\t      /* If you think we can abort here, you are wrong.\n+\t\t There is no region 0 in tree land.  */\n+\t      gcc_assert (lookup_stmt_eh_region_fn (id->src_cfun, orig_stmt)\n+\t\t\t  != 0);\n \n-\t\tdefault:\n-\t\t  gcc_unreachable ();\n+\t      if (tree_could_throw_p (stmt))\n+\t\t{\n+\t\t  int region = lookup_stmt_eh_region_fn (id->src_cfun, orig_stmt);\n+\t\t  /* Add an entry for the copied tree in the EH hashtable.\n+\t\t     When cloning or versioning, use the hashtable in\n+\t\t     cfun, and just copy the EH number.  When inlining, use the\n+\t\t     hashtable in the caller, and adjust the region number.  */\n+\t\t  if (region > 0)\n+\t\t    add_stmt_to_eh_region (stmt, region + id->eh_region_offset);\n+\n+\t\t  /* If this tree doesn't have a region associated with it,\n+\t\t     and there is a \"current region,\"\n+\t\t     then associate this tree with the current region\n+\t\t     and add edges associated with this region.  */\n+\t\t  if ((lookup_stmt_eh_region_fn (id->src_cfun,\n+\t\t\t\t\t\t orig_stmt) <= 0\n+\t\t       && id->eh_region > 0)\n+\t\t      && tree_could_throw_p (stmt))\n+\t\t    add_stmt_to_eh_region (stmt, id->eh_region);\n \t\t}\n-\t    }\n-\t  /* If you think we can abort here, you are wrong.\n-\t     There is no region 0 in tree land.  */\n-\t  gcc_assert (lookup_stmt_eh_region_fn (id->src_cfun, orig_stmt)\n-\t\t      != 0);\n+\t      if (gimple_in_ssa_p (cfun))\n+\t\t{\n+\t\t   ssa_op_iter i;\n+\t\t   tree def;\n \n-\t  if (tree_could_throw_p (stmt))\n-\t    {\n-\t      int region = lookup_stmt_eh_region_fn (id->src_cfun, orig_stmt);\n-\t      /* Add an entry for the copied tree in the EH hashtable.\n-\t\t When cloning or versioning, use the hashtable in\n-\t\t cfun, and just copy the EH number.  When inlining, use the\n-\t\t hashtable in the caller, and adjust the region number.  */\n-\t      if (region > 0)\n-\t\tadd_stmt_to_eh_region (stmt, region + id->eh_region_offset);\n-\n-\t      /* If this tree doesn't have a region associated with it,\n-\t\t and there is a \"current region,\"\n-\t\t then associate this tree with the current region\n-\t\t and add edges associated with this region.  */\n-\t      if ((lookup_stmt_eh_region_fn (id->src_cfun,\n-\t\t\t\t\t     orig_stmt) <= 0\n-\t\t   && id->eh_region > 0)\n-\t\t  && tree_could_throw_p (stmt))\n-\t\tadd_stmt_to_eh_region (stmt, id->eh_region);\n+\t\t   find_new_referenced_vars (bsi_stmt_ptr (copy_bsi));\n+\t\t   FOR_EACH_SSA_TREE_OPERAND (def, stmt, i, SSA_OP_DEF)\n+\t\t    if (TREE_CODE (def) == SSA_NAME)\n+\t\t      SSA_NAME_DEF_STMT (def) = stmt;\n+\t\t}\n+\t      bsi_next (&copy_bsi);\n \t    }\n+\t  copy_bsi = bsi_last (copy_basic_block);\n \t}\n     }\n   return copy_basic_block;\n }\n \n+/* Inserting Single Entry Multiple Exit region in SSA form into code in SSA\n+   form is quite easy, since dominator relationship for old basic blocks does\n+   not change.\n+\n+   There is however exception where inlining might change dominator relation\n+   across EH edges from basic block within inlined functions destinating\n+   to landging pads in function we inline into.\n+\n+   The function mark PHI_RESULT of such PHI nodes for renaming; it is\n+   safe the EH edges are abnormal and SSA_NAME_OCCURS_IN_ABNORMAL_PHI\n+   must be set.  This means, that there will be no overlapping live ranges\n+   for the underlying symbol.\n+\n+   This might change in future if we allow redirecting of EH edges and\n+   we might want to change way build CFG pre-inlining to include\n+   all the possible edges then.  */\n+static void\n+update_ssa_across_eh_edges (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (!e->dest->aux\n+\t|| ((basic_block)e->dest->aux)->index == ENTRY_BLOCK)\n+      {\n+\ttree phi;\n+\n+\tgcc_assert (e->flags & EDGE_EH);\n+\tfor (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n+\t  {\n+\t    gcc_assert (SSA_NAME_OCCURS_IN_ABNORMAL_PHI\n+\t\t\t(PHI_RESULT (phi)));\n+\t    mark_sym_for_renaming\n+\t      (SSA_NAME_VAR (PHI_RESULT (phi)));\n+\t  }\n+      }\n+}\n+\n /* Copy edges from BB into its copy constructed earlier, scale profile\n    accordingly.  Edges will be taken care of later.  Assume aux\n    pointers to point to the copies of each BB.  */\n@@ -825,6 +955,8 @@ copy_edges_for_bb (basic_block bb, int count_scale)\n \n       copy_stmt = bsi_stmt (bsi);\n       update_stmt (copy_stmt);\n+      if (gimple_in_ssa_p (cfun))\n+        mark_symbols_for_renaming (copy_stmt);\n       /* Do this before the possible split_block.  */\n       bsi_next (&bsi);\n \n@@ -847,11 +979,54 @@ copy_edges_for_bb (basic_block bb, int count_scale)\n \t       right at this point; split_block doesn't care.  */\n \t    {\n \t      edge e = split_block (new_bb, copy_stmt);\n+\n \t      new_bb = e->dest;\n+\t      new_bb->aux = e->src->aux;\n \t      bsi = bsi_start (new_bb);\n \t    }\n \n            make_eh_edges (copy_stmt);\n+\n+\t   if (gimple_in_ssa_p (cfun))\n+\t     update_ssa_across_eh_edges (bb_for_stmt (copy_stmt));\n+\t}\n+    }\n+}\n+\n+/* Copy the PHIs.  All blocks and edges are copied, some blocks\n+   was possibly split and new outgoing EH edges inserted.\n+   BB points to the block of original function and AUX pointers links\n+   the original and newly copied blocks.  */\n+\n+static void\n+copy_phis_for_bb (basic_block bb, copy_body_data *id)\n+{\n+  basic_block new_bb = bb->aux;\n+  edge_iterator ei;\n+  tree phi;\n+\n+  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+    {\n+      tree res = PHI_RESULT (phi);\n+      tree new_res = res;\n+      tree new_phi;\n+      edge new_edge;\n+\n+      if (is_gimple_reg (res))\n+\t{\n+\t  walk_tree (&new_res, copy_body_r, id, NULL);\n+\t  SSA_NAME_DEF_STMT (new_res)\n+\t    = new_phi = create_phi_node (new_res, new_bb);\n+\t  FOR_EACH_EDGE (new_edge, ei, new_bb->preds)\n+\t    {\n+\t      edge old_edge = find_edge (new_edge->src->aux, bb);\n+\t      tree arg = PHI_ARG_DEF_FROM_EDGE (phi, old_edge);\n+\t      tree new_arg = arg;\n+\n+\t      walk_tree (&new_arg, copy_body_r, id, NULL);\n+\t      gcc_assert (new_arg);\n+\t      add_phi_arg (new_phi, new_arg, new_edge);\n+\t    }\n \t}\n     }\n }\n@@ -863,6 +1038,67 @@ remap_decl_1 (tree decl, void *data)\n   return remap_decl (decl, (copy_body_data *) data);\n }\n \n+/* Build struct function and associated datastructures for the new clone\n+   NEW_FNDECL to be build.  CALLEE_FNDECL is the original */\n+\n+static void\n+initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count,\n+\t\t int frequency)\n+{\n+  struct function *new_cfun\n+     = (struct function *) ggc_alloc_cleared (sizeof (struct function));\n+  struct function *src_cfun = DECL_STRUCT_FUNCTION (callee_fndecl);\n+  int count_scale, frequency_scale;\n+\n+  if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count)\n+    count_scale = (REG_BR_PROB_BASE * count\n+\t\t   / ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count);\n+  else\n+    count_scale = 1;\n+\n+  if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency)\n+    frequency_scale = (REG_BR_PROB_BASE * frequency\n+\t\t       /\n+\t\t       ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency);\n+  else\n+    frequency_scale = count_scale;\n+\n+  /* Register specific tree functions.  */\n+  tree_register_cfg_hooks ();\n+  *new_cfun = *DECL_STRUCT_FUNCTION (callee_fndecl);\n+  VALUE_HISTOGRAMS (new_cfun) = NULL;\n+  new_cfun->unexpanded_var_list = NULL;\n+  new_cfun->cfg = NULL;\n+  new_cfun->decl = new_fndecl /*= copy_node (callee_fndecl)*/;\n+  new_cfun->ib_boundaries_block = NULL;\n+  DECL_STRUCT_FUNCTION (new_fndecl) = new_cfun;\n+  push_cfun (new_cfun);\n+  init_empty_tree_cfg ();\n+\n+  ENTRY_BLOCK_PTR->count =\n+    (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count * count_scale /\n+     REG_BR_PROB_BASE);\n+  ENTRY_BLOCK_PTR->frequency =\n+    (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency *\n+     frequency_scale / REG_BR_PROB_BASE);\n+  EXIT_BLOCK_PTR->count =\n+    (EXIT_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count * count_scale /\n+     REG_BR_PROB_BASE);\n+  EXIT_BLOCK_PTR->frequency =\n+    (EXIT_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency *\n+     frequency_scale / REG_BR_PROB_BASE);\n+  if (src_cfun->eh)\n+    init_eh_for_function ();\n+\n+  if (src_cfun->gimple_df)\n+    {\n+      init_tree_ssa ();\n+      cfun->gimple_df->in_ssa_p = true;\n+      init_ssa_operands ();\n+    }\n+  pop_cfun ();\n+}\n+\n /* Make a copy of the body of FN so that it can be inserted inline in\n    another function.  Walks FN via CFG, returns new fndecl.  */\n \n@@ -873,15 +1109,11 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency,\n   tree callee_fndecl = id->src_fn;\n   /* Original cfun for the callee, doesn't change.  */\n   struct function *src_cfun = DECL_STRUCT_FUNCTION (callee_fndecl);\n-  /* Copy, built by this function.  */\n-  struct function *new_cfun;\n-  /* Place to copy from; when a copy of the function was saved off earlier,\n-     use that instead of the main copy.  */\n-  struct function *cfun_to_copy =\n-    (struct function *) ggc_alloc_cleared (sizeof (struct function));\n+  struct function *cfun_to_copy;\n   basic_block bb;\n   tree new_fndecl = NULL;\n   int count_scale, frequency_scale;\n+  int last;\n \n   if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count)\n     count_scale = (REG_BR_PROB_BASE * count\n@@ -903,64 +1135,47 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency,\n   gcc_assert (ENTRY_BLOCK_PTR_FOR_FUNCTION\n \t      (DECL_STRUCT_FUNCTION (callee_fndecl)));\n \n-  *cfun_to_copy = *DECL_STRUCT_FUNCTION (callee_fndecl);\n-\n-  id->src_cfun = cfun_to_copy;\n-\n-  /* If requested, create new basic_block_info and label_to_block_maps.\n-     Otherwise, insert our new blocks and labels into the existing cfg.  */\n-  if (id->transform_new_cfg)\n-    {\n-      new_cfun =\n-\t(struct function *) ggc_alloc_cleared (sizeof (struct function));\n-      *new_cfun = *DECL_STRUCT_FUNCTION (callee_fndecl);\n-      new_cfun->cfg = NULL;\n-      new_cfun->decl = new_fndecl = copy_node (callee_fndecl);\n-      new_cfun->ib_boundaries_block = NULL;\n-      DECL_STRUCT_FUNCTION (new_fndecl) = new_cfun;\n-      push_cfun (new_cfun);\n-      init_empty_tree_cfg ();\n-\n-      ENTRY_BLOCK_PTR->count =\n-\t(ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count * count_scale /\n-\t REG_BR_PROB_BASE);\n-      ENTRY_BLOCK_PTR->frequency =\n-\t(ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency *\n-\t frequency_scale / REG_BR_PROB_BASE);\n-      EXIT_BLOCK_PTR->count =\n-\t(EXIT_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count * count_scale /\n-\t REG_BR_PROB_BASE);\n-      EXIT_BLOCK_PTR->frequency =\n-\t(EXIT_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency *\n-\t frequency_scale / REG_BR_PROB_BASE);\n-\n-      entry_block_map = ENTRY_BLOCK_PTR;\n-      exit_block_map = EXIT_BLOCK_PTR;\n-    }\n+  cfun_to_copy = id->src_cfun = DECL_STRUCT_FUNCTION (callee_fndecl);\n+\n \n   ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun_to_copy)->aux = entry_block_map;\n   EXIT_BLOCK_PTR_FOR_FUNCTION (cfun_to_copy)->aux = exit_block_map;\n+  entry_block_map->aux = ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun_to_copy);\n+  exit_block_map->aux = EXIT_BLOCK_PTR_FOR_FUNCTION (cfun_to_copy);\n \n   /* Duplicate any exception-handling regions.  */\n   if (cfun->eh)\n     {\n-      if (id->transform_new_cfg)\n-        init_eh_for_function ();\n       id->eh_region_offset\n \t= duplicate_eh_regions (cfun_to_copy, remap_decl_1, id,\n \t\t\t\t0, id->eh_region);\n     }\n   /* Use aux pointers to map the original blocks to copy.  */\n   FOR_EACH_BB_FN (bb, cfun_to_copy)\n-    bb->aux = copy_bb (id, bb, frequency_scale, count_scale);\n+    {\n+      basic_block new = copy_bb (id, bb, frequency_scale, count_scale);\n+      bb->aux = new;\n+      new->aux = bb;\n+    }\n+\n+  last = n_basic_blocks;\n   /* Now that we've duplicated the blocks, duplicate their edges.  */\n   FOR_ALL_BB_FN (bb, cfun_to_copy)\n     copy_edges_for_bb (bb, count_scale);\n+  if (gimple_in_ssa_p (cfun))\n+    FOR_ALL_BB_FN (bb, cfun_to_copy)\n+      copy_phis_for_bb (bb, id);\n   FOR_ALL_BB_FN (bb, cfun_to_copy)\n-    bb->aux = NULL;\n-\n-  if (id->transform_new_cfg)\n-    pop_cfun ();\n+    {\n+      ((basic_block)bb->aux)->aux = NULL;\n+      bb->aux = NULL;\n+    }\n+  /* Zero out AUX fields of newly created block during EH edge\n+     insertion. */\n+  for (; last < n_basic_blocks; last++)\n+    BASIC_BLOCK (last)->aux = NULL;\n+  entry_block_map->aux = NULL;\n+  exit_block_map->aux = NULL;\n \n   return new_fndecl;\n }\n@@ -1017,13 +1232,17 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n   tree init_stmt;\n   tree var;\n   tree var_sub;\n+  tree rhs = value ? fold_convert (TREE_TYPE (p), value) : NULL;\n+  tree def = (gimple_in_ssa_p (cfun)\n+\t      ? gimple_default_def (id->src_cfun, p) : NULL);\n \n-  /* If the parameter is never assigned to, we may not need to\n-     create a new variable here at all.  Instead, we may be able\n-     to just use the argument value.  */\n+  /* If the parameter is never assigned to, has no SSA_NAMEs created,\n+     we may not need to create a new variable here at all.  Instead, we may\n+     be able to just use the argument value.  */\n   if (TREE_READONLY (p)\n       && !TREE_ADDRESSABLE (p)\n-      && value && !TREE_SIDE_EFFECTS (value))\n+      && value && !TREE_SIDE_EFFECTS (value)\n+      && !def)\n     {\n       /* We may produce non-gimple trees by adding NOPs or introduce\n \t invalid sharing when operand is not really constant.\n@@ -1047,6 +1266,11 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n      here since the type of this decl must be visible to the calling\n      function.  */\n   var = copy_decl_to_var (p, id);\n+  if (gimple_in_ssa_p (cfun) && TREE_CODE (var) == VAR_DECL)\n+    {\n+      get_var_ann (var);\n+      add_referenced_var (var);\n+    }\n \n   /* See if the frontend wants to pass this by invisible reference.  If\n      so, our new VAR_DECL will have REFERENCE_TYPE, and we need to\n@@ -1085,21 +1309,54 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n   if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (p)))\n     TREE_READONLY (var) = 0;\n \n+  /* If there is no setup required and we are in SSA, take the easy route\n+     replacing all SSA names representing the function parameter by the\n+     SSA name passed to function.\n+\n+     We need to construct map for the variable anyway as it might be used\n+     in different SSA names when parameter is set in function.\n+\n+     FIXME: This usually kills the last connection in between inlined\n+     function parameter and the actual value in debug info.  Can we do\n+     better here?  If we just inserted the statement, copy propagation\n+     would kill it anyway as it always did in older versions of GCC.\n+\n+     We might want to introduce a notion that single SSA_NAME might\n+     represent multiple variables for purposes of debugging. */\n+  if (gimple_in_ssa_p (cfun) && rhs && def && is_gimple_reg (p)\n+      && (TREE_CODE (rhs) == SSA_NAME\n+\t  || is_gimple_min_invariant (rhs)))\n+    {\n+      insert_decl_map (id, def, rhs);\n+      return;\n+    }\n+\n   /* Initialize this VAR_DECL from the equivalent argument.  Convert\n      the argument to the proper type in case it was promoted.  */\n   if (value)\n     {\n-      tree rhs = fold_convert (TREE_TYPE (var), value);\n       block_stmt_iterator bsi = bsi_last (bb);\n \n       if (rhs == error_mark_node)\n-\treturn;\n+\t{\n+  \t  insert_decl_map (id, p, var_sub);\n+\t  return;\n+\t}\n \n       STRIP_USELESS_TYPE_CONVERSION (rhs);\n \n       /* We want to use GIMPLE_MODIFY_STMT, not INIT_EXPR here so that we\n \t keep our trees in gimple form.  */\n-      init_stmt = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (var), var, rhs);\n+      if (def && gimple_in_ssa_p (cfun) && is_gimple_reg (p))\n+\t{\n+\t  def = remap_ssa_name (def, id);\n+          init_stmt = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (var), def, rhs);\n+\t  SSA_NAME_DEF_STMT (def) = init_stmt;\n+\t  SSA_NAME_IS_DEFAULT_DEF (def) = 0;\n+\t  set_default_def (var, NULL);\n+\t}\n+      else\n+        init_stmt = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (var), var, rhs);\n \n       /* If we did not create a gimple value and we did not create a gimple\n \t cast of a gimple value, then we will need to gimplify INIT_STMTS\n@@ -1110,12 +1367,29 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n \t  && (!is_gimple_cast (rhs)\n \t      || !is_gimple_val (TREE_OPERAND (rhs, 0))))\n \t  || !is_gimple_reg (var))\n-\tgimplify_stmt (&init_stmt);\n+\t{\n+          tree_stmt_iterator i;\n+\n+\t  push_gimplify_context ();\n+\t  gimplify_stmt (&init_stmt);\n+\t  if (gimple_in_ssa_p (cfun)\n+              && init_stmt && TREE_CODE (init_stmt) == STATEMENT_LIST)\n+\t    {\n+\t      /* The replacement can expose previously unreferenced\n+\t\t variables.  */\n+\t      for (i = tsi_start (init_stmt); !tsi_end_p (i); tsi_next (&i))\n+\t\tfind_new_referenced_vars (tsi_stmt_ptr (i));\n+\t     }\n+\t  pop_gimplify_context (NULL);\n+\t}\n \n       /* If VAR represents a zero-sized variable, it's possible that the\n \t assignment statment may result in no gimple statements.  */\n       if (init_stmt)\n         bsi_insert_after (&bsi, init_stmt, BSI_NEW_STMT);\n+      if (gimple_in_ssa_p (cfun))\n+\tfor (;!bsi_end_p (bsi); bsi_next (&bsi))\n+\t  mark_symbols_for_renaming (bsi_stmt (bsi));\n     }\n }\n \n@@ -1170,17 +1444,17 @@ initialize_inlined_parameters (copy_body_data *id, tree args, tree static_chain,\n    The USE_STMT is filled to contain a use of the declaration to\n    indicate the return value of the function.\n \n-   RETURN_SLOT_ADDR, if non-null, was a fake parameter that\n-   took the address of the result.  MODIFY_DEST, if non-null, was the LHS of\n-   the GIMPLE_MODIFY_STMT to which this call is the RHS.\n+   RETURN_SLOT, if non-null is place where to store the result.  It\n+   is set only for CALL_EXPR_RETURN_SLOT_OPT.  MODIFY_DEST, if non-null,\n+   was the LHS of the GIMPLE_MODIFY_STMT to which this call is the RHS.\n \n    The return value is a (possibly null) value that is the result of the\n    function as seen by the callee.  *USE_P is a (possibly null) value that\n    holds the result as seen by the caller.  */\n \n static tree\n-declare_return_variable (copy_body_data *id, tree return_slot_addr,\n-\t\t\t tree modify_dest, tree *use_p)\n+declare_return_variable (copy_body_data *id, tree return_slot, tree modify_dest,\n+\t\t\t tree *use_p)\n {\n   tree callee = id->src_fn;\n   tree caller = id->dst_fn;\n@@ -1199,15 +1473,49 @@ declare_return_variable (copy_body_data *id, tree return_slot_addr,\n \n   /* If there was a return slot, then the return value is the\n      dereferenced address of that object.  */\n-  if (return_slot_addr)\n+  if (return_slot)\n     {\n-      /* The front end shouldn't have used both return_slot_addr and\n+      /* The front end shouldn't have used both return_slot and\n \t a modify expression.  */\n       gcc_assert (!modify_dest);\n       if (DECL_BY_REFERENCE (result))\n-\tvar = return_slot_addr;\n+\t{\n+\t  tree return_slot_addr = build_fold_addr_expr (return_slot);\n+\t  STRIP_USELESS_TYPE_CONVERSION (return_slot_addr);\n+\n+\t  /* We are going to construct *&return_slot and we can't do that\n+\t     for variables believed to be not addressable. \n+\n+\t     FIXME: This check possibly can match, because values returned\n+\t     via return slot optimization are not believed to have address\n+\t     taken by alias analysis.  */\n+\t  gcc_assert (TREE_CODE (return_slot) != SSA_NAME);\n+\t  if (gimple_in_ssa_p (cfun))\n+\t    {\n+\t      HOST_WIDE_INT bitsize;\n+\t      HOST_WIDE_INT bitpos;\n+\t      tree offset;\n+\t      enum machine_mode mode;\n+\t      int unsignedp;\n+\t      int volatilep;\n+\t      tree base;\n+\t      base = get_inner_reference (return_slot, &bitsize, &bitpos,\n+\t\t\t\t\t  &offset,\n+\t\t\t\t\t  &mode, &unsignedp, &volatilep,\n+\t\t\t\t\t  false);\n+\t      if (TREE_CODE (base) == INDIRECT_REF)\n+\t\tbase = TREE_OPERAND (base, 0);\n+\t      if (TREE_CODE (base) == SSA_NAME)\n+\t\tbase = SSA_NAME_VAR (base);\n+\t      mark_sym_for_renaming (base);\n+\t    }\n+\t  var = return_slot_addr;\n+\t}\n       else\n-\tvar = build_fold_indirect_ref (return_slot_addr);\n+\t{\n+\t  var = return_slot;\n+\t  gcc_assert (TREE_CODE (var) != SSA_NAME);\n+\t}\n       if ((TREE_CODE (TREE_TYPE (result)) == COMPLEX_TYPE\n            || TREE_CODE (TREE_TYPE (result)) == VECTOR_TYPE)\n \t  && !DECL_GIMPLE_REG_P (result)\n@@ -1221,7 +1529,8 @@ declare_return_variable (copy_body_data *id, tree return_slot_addr,\n   gcc_assert (!TREE_ADDRESSABLE (callee_type));\n \n   /* Attempt to avoid creating a new temporary variable.  */\n-  if (modify_dest)\n+  if (modify_dest\n+      && TREE_CODE (modify_dest) != SSA_NAME)\n     {\n       bool use_it = false;\n \n@@ -1270,6 +1579,11 @@ declare_return_variable (copy_body_data *id, tree return_slot_addr,\n   gcc_assert (TREE_CODE (TYPE_SIZE_UNIT (callee_type)) == INTEGER_CST);\n \n   var = copy_result_decl_to_var (result, id);\n+  if (gimple_in_ssa_p (cfun))\n+    {\n+      get_var_ann (var);\n+      add_referenced_var (var);\n+    }\n \n   DECL_SEEN_IN_BIND_EXPR_P (var) = 1;\n   DECL_STRUCT_FUNCTION (caller)->unexpanded_var_list\n@@ -1938,7 +2252,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   tree fn;\n   splay_tree st;\n   tree args;\n-  tree return_slot_addr;\n+  tree return_slot;\n   tree modify_dest;\n   location_t saved_location;\n   struct cgraph_edge *cg_edge;\n@@ -2095,6 +2409,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   /* Record the function we are about to inline.  */\n   id->src_fn = fn;\n   id->src_node = cg_edge->callee;\n+  id->src_cfun = DECL_STRUCT_FUNCTION (fn);\n \n   initialize_inlined_parameters (id, args, TREE_OPERAND (t, 2), fn, bb);\n \n@@ -2108,7 +2423,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   gcc_assert (TREE_CODE (DECL_INITIAL (fn)) == BLOCK);\n \n   /* Find the lhs to which the result of this call is assigned.  */\n-  return_slot_addr = NULL;\n+  return_slot = NULL;\n   if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n     {\n       modify_dest = GIMPLE_STMT_OPERAND (stmt, 0);\n@@ -2123,16 +2438,15 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n \tTREE_NO_WARNING (modify_dest) = 1;\n       if (CALL_EXPR_RETURN_SLOT_OPT (t))\n \t{\n-\t  return_slot_addr = build_fold_addr_expr (modify_dest);\n-\t  STRIP_USELESS_TYPE_CONVERSION (return_slot_addr);\n+\t  return_slot = modify_dest;\n \t  modify_dest = NULL;\n \t}\n     }\n   else\n     modify_dest = NULL;\n \n   /* Declare the return variable for the function.  */\n-  declare_return_variable (id, return_slot_addr,\n+  declare_return_variable (id, return_slot,\n \t\t\t   modify_dest, &use_retvar);\n \n   /* This is it.  Duplicate the callee body.  Assume callee is\n@@ -2164,12 +2478,44 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   if (use_retvar && (TREE_CODE (bsi_stmt (stmt_bsi)) != CALL_EXPR))\n     {\n       *tp = use_retvar;\n+      if (gimple_in_ssa_p (cfun))\n+\t{\n+          update_stmt (stmt);\n+          mark_symbols_for_renaming (stmt);\n+\t}\n       maybe_clean_or_replace_eh_stmt (stmt, stmt);\n     }\n   else\n     /* We're modifying a TSI owned by gimple_expand_calls_inline();\n        tsi_delink() will leave the iterator in a sane state.  */\n-    bsi_remove (&stmt_bsi, true);\n+    {\n+      /* Handle case of inlining function that miss return statement so \n+         return value becomes undefined.  */\n+      if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+\t  && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == SSA_NAME)\n+\t{\n+\t  tree name = TREE_OPERAND (stmt, 0);\n+\t  tree var = SSA_NAME_VAR (TREE_OPERAND (stmt, 0));\n+\t  tree def = gimple_default_def (cfun, var);\n+\n+\t  /* If the variable is used undefined, make this name undefined via\n+\t     move.  */\n+\t  if (def)\n+\t    {\n+\t      TREE_OPERAND (stmt, 1) = def;\n+\t      update_stmt (stmt);\n+\t    }\n+\t  /* Otherwise make this variable undefined.  */\n+\t  else\n+\t    {\n+\t      bsi_remove (&stmt_bsi, true);\n+\t      set_default_def (var, name);\n+\t      SSA_NAME_DEF_STMT (name) = build_empty_stmt ();\n+\t    }\n+\t}\n+      else\n+        bsi_remove (&stmt_bsi, true);\n+    }\n \n   if (purge_dead_abnormal_edges)\n     tree_purge_dead_abnormal_call_edges (return_block);\n@@ -2290,7 +2636,23 @@ optimize_inline_calls (tree fn)\n      as inlining loops might increase the maximum.  */\n   if (ENTRY_BLOCK_PTR->count)\n     counts_to_freqs ();\n-  fold_cond_expr_cond ();\n+  if (gimple_in_ssa_p (cfun))\n+    {\n+      /* We make no attempts to keep dominance info up-to-date.  */\n+      free_dominance_info (CDI_DOMINATORS);\n+      free_dominance_info (CDI_POST_DOMINATORS);\n+      delete_unreachable_blocks ();\n+      update_ssa (TODO_update_ssa);\n+      fold_cond_expr_cond ();\n+      if (need_ssa_update_p ())\n+        update_ssa (TODO_update_ssa);\n+    }\n+  else\n+    fold_cond_expr_cond ();\n+  /* It would be nice to check SSA/CFG/statement consistency here, but it is\n+     not possible yet - the IPA passes might make various functions to not\n+     throw and they don't care to proactively update local EH info.  This is\n+     done later in fixup_cfg pass that also execute the verification.  */\n }\n \n /* FN is a function that has a complete body, and CLONE is a function whose\n@@ -2782,7 +3144,7 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n   struct cgraph_node *old_version_node;\n   struct cgraph_node *new_version_node;\n   copy_body_data id;\n-  tree p, new_fndecl;\n+  tree p;\n   unsigned i;\n   struct ipa_replace_map *replace_info;\n   basic_block old_entry_block;\n@@ -2828,6 +3190,12 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n   id.transform_lang_insert_block = false;\n \n   current_function_decl = new_decl;\n+  old_entry_block = ENTRY_BLOCK_PTR_FOR_FUNCTION\n+    (DECL_STRUCT_FUNCTION (old_decl));\n+  initialize_cfun (new_decl, old_decl,\n+\t\t   old_entry_block->count,\n+\t\t   old_entry_block->frequency);\n+  push_cfun (DECL_STRUCT_FUNCTION (new_decl));\n   \n   /* Copy the function's static chain.  */\n   p = DECL_STRUCT_FUNCTION (old_decl)->static_chain_decl;\n@@ -2871,36 +3239,29 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n       }\n   \n   /* Copy the Function's body.  */\n-  old_entry_block = ENTRY_BLOCK_PTR_FOR_FUNCTION\n-    (DECL_STRUCT_FUNCTION (old_decl));\n-  new_fndecl = copy_body (&id,\n-\t\t\t  old_entry_block->count,\n-\t\t\t  old_entry_block->frequency, NULL, NULL);\n+  copy_body (&id, old_entry_block->count, old_entry_block->frequency, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR);\n   \n-  DECL_SAVED_TREE (new_decl) = DECL_SAVED_TREE (new_fndecl);\n-\n-  DECL_STRUCT_FUNCTION (new_decl)->cfg =\n-    DECL_STRUCT_FUNCTION (new_fndecl)->cfg;\n-  DECL_STRUCT_FUNCTION (new_decl)->eh = DECL_STRUCT_FUNCTION (new_fndecl)->eh;\n-  DECL_STRUCT_FUNCTION (new_decl)->ib_boundaries_block =\n-    DECL_STRUCT_FUNCTION (new_fndecl)->ib_boundaries_block;\n-  DECL_STRUCT_FUNCTION (new_decl)->last_label_uid =\n-    DECL_STRUCT_FUNCTION (new_fndecl)->last_label_uid;\n-\n   if (DECL_RESULT (old_decl) != NULL_TREE)\n     {\n       tree *res_decl = &DECL_RESULT (old_decl);\n       DECL_RESULT (new_decl) = remap_decl (*res_decl, &id);\n       lang_hooks.dup_lang_specific_decl (DECL_RESULT (new_decl));\n     }\n   \n-  current_function_decl = NULL;\n   /* Renumber the lexical scoping (non-code) blocks consecutively.  */\n   number_blocks (new_decl);\n \n   /* Clean up.  */\n   splay_tree_delete (id.decl_map);\n   fold_cond_expr_cond ();\n+  if (gimple_in_ssa_p (cfun))\n+    {\n+      update_ssa (TODO_update_ssa);\n+    }\n+  free_dominance_info (CDI_DOMINATORS);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+  pop_cfun ();\n+  current_function_decl = NULL;\n   return;\n }\n "}]}