{"sha": "e4878d25f33bcfd0c7224af55f0c364b3b518ad0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ4NzhkMjVmMzNiY2ZkMGM3MjI0YWY1NWYwYzM2NGIzYjUxOGFkMA==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2012-10-23T01:05:25Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2012-10-23T01:05:25Z"}, "message": "re PR middle-end/55030 (gcc.c-torture/execute/builtins/memcpy-chk.c execution,  -Os (et al))\n\n\tPR middle-end/55030\n\tRevert:\n\t* stmt.c (expand_nl_goto_receiver): Remove almost-copy of\n\texpand_builtin_setjmp_receiver.\n\t(expand_label): Adjust, call expand_builtin_setjmp_receiver\n\twith NULL for the label parameter.\n\t* builtins.c (expand_builtin_setjmp_receiver): Don't clobber\n\tthe frame-pointer.  Adjust comments.\n\t[HAVE_builtin_setjmp_receiver]: Emit builtin_setjmp_receiver\n\tonly if LABEL is non-NULL.\n\nFrom-SVN: r192701", "tree": {"sha": "86348b8c9c7685079a971f61f3b53e883b7eda9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86348b8c9c7685079a971f61f3b53e883b7eda9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4878d25f33bcfd0c7224af55f0c364b3b518ad0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4878d25f33bcfd0c7224af55f0c364b3b518ad0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4878d25f33bcfd0c7224af55f0c364b3b518ad0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4878d25f33bcfd0c7224af55f0c364b3b518ad0/comments", "author": null, "committer": null, "parents": [{"sha": "78445bd87f7d161b6799dfd3f51f7de286b764b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78445bd87f7d161b6799dfd3f51f7de286b764b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78445bd87f7d161b6799dfd3f51f7de286b764b4"}], "stats": {"total": 117, "additions": 95, "deletions": 22}, "files": [{"sha": "9ec0467ab9b3523505899157f393285c4ab6ad04", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4878d25f33bcfd0c7224af55f0c364b3b518ad0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4878d25f33bcfd0c7224af55f0c364b3b518ad0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4878d25f33bcfd0c7224af55f0c364b3b518ad0", "patch": "@@ -1,3 +1,16 @@\n+2012-10-23  Hans-Peter Nilsson  <hp@bitrange.com>\n+\n+\tPR middle-end/55030\n+\tRevert:\n+\t* stmt.c (expand_nl_goto_receiver): Remove almost-copy of\n+\texpand_builtin_setjmp_receiver.\n+\t(expand_label): Adjust, call expand_builtin_setjmp_receiver\n+\twith NULL for the label parameter.\n+\t* builtins.c (expand_builtin_setjmp_receiver): Don't clobber\n+\tthe frame-pointer.  Adjust comments.\n+\t[HAVE_builtin_setjmp_receiver]: Emit builtin_setjmp_receiver\n+\tonly if LABEL is non-NULL.\n+\n 2012-10-22  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \tPR tree-optimization/55008"}, {"sha": "c309566919ecf19e160d239ca69a84198c17820b", "filename": "gcc/builtins.c", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4878d25f33bcfd0c7224af55f0c364b3b518ad0/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4878d25f33bcfd0c7224af55f0c364b3b518ad0/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e4878d25f33bcfd0c7224af55f0c364b3b518ad0", "patch": "@@ -885,15 +885,14 @@ expand_builtin_setjmp_setup (rtx buf_addr, rtx receiver_label)\n }\n \n /* Construct the trailing part of a __builtin_setjmp call.  This is\n-   also called directly by the SJLJ exception handling code.\n-   If RECEIVER_LABEL is NULL, instead contruct a nonlocal goto handler.  */\n+   also called directly by the SJLJ exception handling code.  */\n \n void\n expand_builtin_setjmp_receiver (rtx receiver_label ATTRIBUTE_UNUSED)\n {\n   rtx chain;\n \n-  /* Mark the FP as used when we get here, so we have to make sure it's\n+  /* Clobber the FP when we get here, so we have to make sure it's\n      marked as used by this function.  */\n   emit_use (hard_frame_pointer_rtx);\n \n@@ -908,28 +907,17 @@ expand_builtin_setjmp_receiver (rtx receiver_label ATTRIBUTE_UNUSED)\n #ifdef HAVE_nonlocal_goto\n   if (! HAVE_nonlocal_goto)\n #endif\n-    /* First adjust our frame pointer to its actual value.  It was\n-       previously set to the start of the virtual area corresponding to\n-       the stacked variables when we branched here and now needs to be\n-       adjusted to the actual hardware fp value.\n-\n-       Assignments to virtual registers are converted by\n-       instantiate_virtual_regs into the corresponding assignment\n-       to the underlying register (fp in this case) that makes\n-       the original assignment true.\n-       So the following insn will actually be decrementing fp by\n-       STARTING_FRAME_OFFSET.  */\n-    emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n+    {\n+      emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n+      /* This might change the hard frame pointer in ways that aren't\n+\t apparent to early optimization passes, so force a clobber.  */\n+      emit_clobber (hard_frame_pointer_rtx);\n+    }\n \n #if !HARD_FRAME_POINTER_IS_ARG_POINTER\n   if (fixed_regs[ARG_POINTER_REGNUM])\n     {\n #ifdef ELIMINABLE_REGS\n-      /* If the argument pointer can be eliminated in favor of the\n-\t frame pointer, we don't need to restore it.  We assume here\n-\t that if such an elimination is present, it can always be used.\n-\t This is the case on all known machines; if we don't make this\n-\t assumption, we do unnecessary saving on many machines.  */\n       size_t i;\n       static const struct elims {const int from, to;} elim_regs[] = ELIMINABLE_REGS;\n \n@@ -950,7 +938,7 @@ expand_builtin_setjmp_receiver (rtx receiver_label ATTRIBUTE_UNUSED)\n #endif\n \n #ifdef HAVE_builtin_setjmp_receiver\n-  if (receiver_label != NULL && HAVE_builtin_setjmp_receiver)\n+  if (HAVE_builtin_setjmp_receiver)\n     emit_insn (gen_builtin_setjmp_receiver (receiver_label));\n   else\n #endif"}, {"sha": "14a28abcc58a2246881d373803b18245d47596a8", "filename": "gcc/stmt.c", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4878d25f33bcfd0c7224af55f0c364b3b518ad0/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4878d25f33bcfd0c7224af55f0c364b3b518ad0/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=e4878d25f33bcfd0c7224af55f0c364b3b518ad0", "patch": "@@ -106,6 +106,7 @@ extern basic_block label_to_block_fn (struct function *, tree);\n \f\n static int n_occurrences (int, const char *);\n static bool tree_conflicts_with_clobbers_p (tree, HARD_REG_SET *);\n+static void expand_nl_goto_receiver (void);\n static bool check_operand_nalternatives (tree, tree);\n static bool check_unique_operand_names (tree, tree, tree);\n static char *resolve_operand_name_1 (char *, tree, tree, tree);\n@@ -199,7 +200,7 @@ expand_label (tree label)\n \n   if (DECL_NONLOCAL (label))\n     {\n-      expand_builtin_setjmp_receiver (NULL);\n+      expand_nl_goto_receiver ();\n       nonlocal_goto_handler_labels\n \t= gen_rtx_EXPR_LIST (VOIDmode, label_r,\n \t\t\t     nonlocal_goto_handler_labels);\n@@ -1555,6 +1556,77 @@ expand_return (tree retval)\n     }\n }\n \f\n+/* Emit code to restore vital registers at the beginning of a nonlocal goto\n+   handler.  */\n+static void\n+expand_nl_goto_receiver (void)\n+{\n+  rtx chain;\n+\n+  /* Clobber the FP when we get here, so we have to make sure it's\n+     marked as used by this function.  */\n+  emit_use (hard_frame_pointer_rtx);\n+\n+  /* Mark the static chain as clobbered here so life information\n+     doesn't get messed up for it.  */\n+  chain = targetm.calls.static_chain (current_function_decl, true);\n+  if (chain && REG_P (chain))\n+    emit_clobber (chain);\n+\n+#ifdef HAVE_nonlocal_goto\n+  if (! HAVE_nonlocal_goto)\n+#endif\n+    /* First adjust our frame pointer to its actual value.  It was\n+       previously set to the start of the virtual area corresponding to\n+       the stacked variables when we branched here and now needs to be\n+       adjusted to the actual hardware fp value.\n+\n+       Assignments are to virtual registers are converted by\n+       instantiate_virtual_regs into the corresponding assignment\n+       to the underlying register (fp in this case) that makes\n+       the original assignment true.\n+       So the following insn will actually be\n+       decrementing fp by STARTING_FRAME_OFFSET.  */\n+    emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n+\n+#if !HARD_FRAME_POINTER_IS_ARG_POINTER\n+  if (fixed_regs[ARG_POINTER_REGNUM])\n+    {\n+#ifdef ELIMINABLE_REGS\n+      /* If the argument pointer can be eliminated in favor of the\n+\t frame pointer, we don't need to restore it.  We assume here\n+\t that if such an elimination is present, it can always be used.\n+\t This is the case on all known machines; if we don't make this\n+\t assumption, we do unnecessary saving on many machines.  */\n+      static const struct elims {const int from, to;} elim_regs[] = ELIMINABLE_REGS;\n+      size_t i;\n+\n+      for (i = 0; i < ARRAY_SIZE (elim_regs); i++)\n+\tif (elim_regs[i].from == ARG_POINTER_REGNUM\n+\t    && elim_regs[i].to == HARD_FRAME_POINTER_REGNUM)\n+\t  break;\n+\n+      if (i == ARRAY_SIZE (elim_regs))\n+#endif\n+\t{\n+\t  /* Now restore our arg pointer from the address at which it\n+\t     was saved in our stack frame.  */\n+\t  emit_move_insn (crtl->args.internal_arg_pointer,\n+\t\t\t  copy_to_reg (get_arg_pointer_save_area ()));\n+\t}\n+    }\n+#endif\n+\n+#ifdef HAVE_nonlocal_goto_receiver\n+  if (HAVE_nonlocal_goto_receiver)\n+    emit_insn (gen_nonlocal_goto_receiver ());\n+#endif\n+\n+  /* We must not allow the code we just generated to be reordered by\n+     scheduling.  Specifically, the update of the frame pointer must\n+     happen immediately, not later.  */\n+  emit_insn (gen_blockage ());\n+}\n \f\n /* Emit code to save the current value of stack.  */\n rtx"}]}