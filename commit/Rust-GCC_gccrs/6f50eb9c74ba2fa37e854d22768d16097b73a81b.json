{"sha": "6f50eb9c74ba2fa37e854d22768d16097b73a81b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY1MGViOWM3NGJhMmZhMzdlODU0ZDIyNzY4ZDE2MDk3YjczYTgxYg==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2010-04-11T22:59:36Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2010-04-11T22:59:36Z"}, "message": "sh-protos.h (sh_legitimize_reload_address): Declare.\n\n\t* config/sh/sh-protos.h (sh_legitimize_reload_address): Declare.\n\t* config/sh/sh.c: Include reload.h.\n\t(sh_legitimize_reload_address): New.\n\t* config/sh/sh.h (LEGITIMIZE_RELOAD_ADDRESS): Use\n\tsh_legitimize_reload_address.\n\nFrom-SVN: r158208", "tree": {"sha": "71c76db0db3656f57e70de5532420a74c81e251d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71c76db0db3656f57e70de5532420a74c81e251d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f50eb9c74ba2fa37e854d22768d16097b73a81b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f50eb9c74ba2fa37e854d22768d16097b73a81b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f50eb9c74ba2fa37e854d22768d16097b73a81b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f50eb9c74ba2fa37e854d22768d16097b73a81b/comments", "author": null, "committer": null, "parents": [{"sha": "c11c09f9beac5e556e0c27d898cdbfd9a309fea1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c11c09f9beac5e556e0c27d898cdbfd9a309fea1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c11c09f9beac5e556e0c27d898cdbfd9a309fea1"}], "stats": {"total": 176, "additions": 99, "deletions": 77}, "files": [{"sha": "c2bd0a9a728774f92d3315d5d286e91a6ec9bae5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f50eb9c74ba2fa37e854d22768d16097b73a81b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f50eb9c74ba2fa37e854d22768d16097b73a81b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f50eb9c74ba2fa37e854d22768d16097b73a81b", "patch": "@@ -1,3 +1,11 @@\n+2010-04-11  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* config/sh/sh-protos.h (sh_legitimize_reload_address): Declare.\n+\t* config/sh/sh.c: Include reload.h.\n+\t(sh_legitimize_reload_address): New.\n+\t* config/sh/sh.h (LEGITIMIZE_RELOAD_ADDRESS): Use\n+\tsh_legitimize_reload_address.\n+\n 2010-04-11  Kaushik Phatak  <kaushik.phatak@kpitcummins.com>\n \n \t* config/sh/sh.md (*movqi_pop): New insn pattern."}, {"sha": "fdef756b1645ce1a81f8520bd6ff735819577f20", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f50eb9c74ba2fa37e854d22768d16097b73a81b/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f50eb9c74ba2fa37e854d22768d16097b73a81b/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=6f50eb9c74ba2fa37e854d22768d16097b73a81b", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler for Renesas / SuperH SH.\n    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2003,\n-   2004, 2005, 2006, 2007, 2008, 2009\n+   2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Steve Chamberlain (sac@cygnus.com).\n    Improved by Jim Wilson (wilson@cygnus.com).\n@@ -59,6 +59,7 @@ extern int fp_one_operand (rtx);\n extern int fp_int_operand (rtx);\n extern rtx get_fpscr_rtx (void);\n extern bool sh_legitimate_index_p (enum machine_mode, rtx);\n+extern bool sh_legitimize_reload_address (rtx *, enum machine_mode, int, int);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n extern int nonpic_symbol_mentioned_p (rtx);\n extern void emit_sf_insn (rtx);"}, {"sha": "18491378730347438c9f438b38785d63d83f6825", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f50eb9c74ba2fa37e854d22768d16097b73a81b/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f50eb9c74ba2fa37e854d22768d16097b73a81b/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=6f50eb9c74ba2fa37e854d22768d16097b73a81b", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"expr.h\"\n #include \"optabs.h\"\n+#include \"reload.h\"\n #include \"function.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -9625,6 +9626,88 @@ sh_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n   return x;\n }\n \n+/* Attempt to replace *P, which is an address that needs reloading, with\n+   a valid memory address for an operand of mode MODE.\n+   Like for sh_legitimize_address, for the SH we try to get a normal form\n+   of the address.  That will allow inheritance of the address reloads.  */\n+\n+bool\n+sh_legitimize_reload_address (rtx *p, enum machine_mode mode, int opnum,\n+\t\t\t      int itype)\n+{\n+  enum reload_type type = (enum reload_type) itype;\n+\n+  if (GET_CODE (*p) == PLUS\n+      && (GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8)\n+      && CONST_INT_P (XEXP (*p, 1))\n+      && BASE_REGISTER_RTX_P (XEXP (*p, 0))\n+      && ! TARGET_SHMEDIA\n+      && ! (TARGET_SH4 && mode == DFmode)\n+      && ! (mode == PSImode && type == RELOAD_FOR_INPUT_ADDRESS)\n+      && (ALLOW_INDEXED_ADDRESS\n+\t  || XEXP (*p, 0) == stack_pointer_rtx\n+\t  || XEXP (*p, 0) == hard_frame_pointer_rtx))\n+    {\n+      rtx index_rtx = XEXP (*p, 1);\n+      HOST_WIDE_INT offset = INTVAL (index_rtx), offset_base;\n+      rtx sum;\n+\n+      if (TARGET_SH2A && mode == DFmode && (offset & 0x7))\n+\t{\n+\t  push_reload (*p, NULL_RTX, p, NULL,\n+\t\t       BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, opnum, type);\n+\t  goto win;\n+\t}\n+      if (TARGET_SH2E && mode == SFmode)\n+\t{\n+\t  *p = copy_rtx (*p);\n+\t  push_reload (*p, NULL_RTX, p, NULL,\n+\t\t       BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, opnum, type);\n+\t  goto win;\n+\t}\n+      /* Instead of offset_base 128..131 use 124..127, so that\n+\t simple add suffices.  */\n+      if (offset > 127)\n+\toffset_base = ((offset + 4) & ~60) - 4;\n+      else\n+\toffset_base = offset & ~60;\n+      /* Sometimes the normal form does not suit DImode.  We could avoid\n+\t that by using smaller ranges, but that would give less optimized\n+\t code when SImode is prevalent.  */\n+      if (offset_base != 0\n+\t  && GET_MODE_SIZE (mode) + offset - offset_base <= 64)\n+\t{\n+\t  sum = gen_rtx_PLUS (Pmode, XEXP (*p, 0), GEN_INT (offset_base));\n+\t  *p = gen_rtx_PLUS (Pmode, sum, GEN_INT (offset - offset_base));\n+\t  push_reload (sum, NULL_RTX, &XEXP (*p, 0), NULL,\n+\t\t       BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, opnum, type);\n+\t  goto win;\n+\t}\n+    }\n+  /* We must re-recognize what we created before.  */\n+  else if (GET_CODE (*p) == PLUS\n+\t   && (GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8)\n+\t   && GET_CODE (XEXP (*p, 0)) == PLUS\n+\t   && CONST_INT_P (XEXP (XEXP (*p, 0), 1))\n+\t   && BASE_REGISTER_RTX_P (XEXP (XEXP (*p, 0), 0))\n+\t   && CONST_INT_P (XEXP (*p, 1))\n+\t   && ! TARGET_SHMEDIA\n+\t   && ! (TARGET_SH2E && mode == SFmode))\n+    {\n+      /* Because this address is so complex, we know it must have\n+\t been created by LEGITIMIZE_RELOAD_ADDRESS before; thus,\n+\t it is already unshared, and needs no further unsharing.  */\n+      push_reload (XEXP (*p, 0), NULL_RTX, &XEXP (*p, 0), NULL,\n+\t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, opnum, type);\n+      goto win;\n+    }\n+\n+  return false;\n+\n+ win:\n+  return true;\n+}\n+\n /* Mark the use of a constant in the literal table. If the constant\n    has multiple labels, make it unique.  */\n static rtx"}, {"sha": "8b4f6c0539cab9b44ac7d8e66173b74cc569e224", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 6, "deletions": 76, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f50eb9c74ba2fa37e854d22768d16097b73a81b/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f50eb9c74ba2fa37e854d22768d16097b73a81b/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=6f50eb9c74ba2fa37e854d22768d16097b73a81b", "patch": "@@ -1,6 +1,7 @@\n /* Definitions of target machine for GNU compiler for Renesas / SuperH SH.\n    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-   2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Free Software Foundation, Inc.\n    Contributed by Steve Chamberlain (sac@cygnus.com).\n    Improved by Jim Wilson (wilson@cygnus.com).\n \n@@ -2010,84 +2011,13 @@ struct sh_args {\n \f\n /* A C compound statement that attempts to replace X, which is an address\n    that needs reloading, with a valid memory address for an operand of\n-   mode MODE.  WIN is a C statement label elsewhere in the code.\n-\n-   Like for LEGITIMIZE_ADDRESS, for the SH we try to get a normal form\n-   of the address.  That will allow inheritance of the address reloads.  */\n+   mode MODE.  WIN is a C statement label elsewhere in the code.  */\n \n #define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-      && (GET_MODE_SIZE (MODE) == 4 || GET_MODE_SIZE (MODE) == 8)\t\\\n-      && CONST_INT_P (XEXP (X, 1))\t\t\t\t\t\\\n-      && BASE_REGISTER_RTX_P (XEXP (X, 0))\t\t\t\t\\\n-      && ! TARGET_SHMEDIA\t\t\t\t\t\t\\\n-      && ! (TARGET_SH4 && (MODE) == DFmode)\t\t\t\t\\\n-      && ! ((MODE) == PSImode && (TYPE) == RELOAD_FOR_INPUT_ADDRESS)\t\\\n-      && (ALLOW_INDEXED_ADDRESS\t\t\t\t\t\t\\\n-\t  || XEXP ((X), 0) == stack_pointer_rtx\t\t\t\t\\\n-\t  || XEXP ((X), 0) == hard_frame_pointer_rtx))\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx index_rtx = XEXP (X, 1);\t\t\t\t\t\\\n-      HOST_WIDE_INT offset = INTVAL (index_rtx), offset_base;\t\t\\\n-      rtx sum;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (TARGET_SH2A && (MODE) == DFmode && (offset & 0x7))\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  push_reload (X, NULL_RTX, &X, NULL,\t\t\t\t\\\n-\t\t       BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, (OPNUM),\t\\\n-\t\t       (TYPE));\t\t\t\t\t\t\\\n-\t  goto WIN;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if (TARGET_SH2E && MODE == SFmode)\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  X = copy_rtx (X);\t\t\t\t\t\t\\\n-\t  push_reload (X, NULL_RTX, &X, NULL,\t\t\t\t\\\n-\t\t       BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, (OPNUM),\t\\\n-\t\t       (TYPE));\t\t\t\t\t\t\\\n-\t  goto WIN;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      /* Instead of offset_base 128..131 use 124..127, so that\t\t\\\n-\t simple add suffices.  */\t\t\t\t\t\\\n-      if (offset > 127)\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  offset_base = ((offset + 4) & ~60) - 4;\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\toffset_base = offset & ~60;\t\t\t\t\t\\\n-      /* Sometimes the normal form does not suit DImode.  We\t\t\\\n-\t could avoid that by using smaller ranges, but that\t\t\\\n-\t would give less optimized code when SImode is\t\t\t\\\n-\t prevalent.  */\t\t\t\t\t\t\t\\\n-      if (GET_MODE_SIZE (MODE) + offset - offset_base <= 64)\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  sum = gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\t\\\n-\t\t\t GEN_INT (offset_base));\t\t\t\\\n-\t  X = gen_rtx_PLUS (Pmode, sum, GEN_INT (offset - offset_base));\\\n-\t  push_reload (sum, NULL_RTX, &XEXP (X, 0), NULL,\t\t\\\n-\t\t       BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, (OPNUM),\t\\\n-\t\t       (TYPE));\t\t\t\t\t\t\\\n-\t  goto WIN;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  /* We must re-recognize what we created before.  */\t\t\t\\\n-  else if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-\t   && (GET_MODE_SIZE (MODE) == 4 || GET_MODE_SIZE (MODE) == 8)\t\\\n-\t   && GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\\\n-\t   && CONST_INT_P (XEXP (XEXP (X, 0), 1))\t\t\t\\\n-\t   && BASE_REGISTER_RTX_P (XEXP (XEXP (X, 0), 0))\t\t\\\n-\t   && CONST_INT_P (XEXP (X, 1))\t\t\t\t\t\\\n-\t   && ! TARGET_SHMEDIA\t\t\t\t\t\t\\\n-\t   && ! (TARGET_SH2E && MODE == SFmode))\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      /* Because this address is so complex, we know it must have\t\\\n-\t been created by LEGITIMIZE_RELOAD_ADDRESS before; thus,\t\\\n-\t it is already unshared, and needs no further unsharing.  */\t\\\n-      push_reload (XEXP ((X), 0), NULL_RTX, &XEXP ((X), 0), NULL,\t\\\n-\t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0, (OPNUM), (TYPE));\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (sh_legitimize_reload_address (&(X), (MODE), (OPNUM), (TYPE)))\t\\\n       goto WIN;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n+  } while (0)\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */"}]}