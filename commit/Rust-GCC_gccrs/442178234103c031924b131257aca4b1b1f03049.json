{"sha": "442178234103c031924b131257aca4b1b1f03049", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQyMTc4MjM0MTAzYzAzMTkyNGIxMzEyNTdhY2E0YjFiMWYwMzA0OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-01-19T18:55:12Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-01-19T18:55:12Z"}, "message": "mn10300: Implement adddi3, subdi3.\n\nVia expander, pre- and post-reload patterns.  The pre-reload\npattern is defined to allow lower_subregs totally split the\nDImode values.\n\nFrom-SVN: r169014", "tree": {"sha": "84ff74222c89ca95b4efea29170a06523da5adb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84ff74222c89ca95b4efea29170a06523da5adb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/442178234103c031924b131257aca4b1b1f03049", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/442178234103c031924b131257aca4b1b1f03049", "html_url": "https://github.com/Rust-GCC/gccrs/commit/442178234103c031924b131257aca4b1b1f03049", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/442178234103c031924b131257aca4b1b1f03049/comments", "author": null, "committer": null, "parents": [{"sha": "37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37a185d79e630fd3ad5acd7ac5a29ac07a5be4d6"}], "stats": {"total": 332, "additions": 332, "deletions": 0}, "files": [{"sha": "670fb6846b93f3feefd515326285ccb40d21e08d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442178234103c031924b131257aca4b1b1f03049/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442178234103c031924b131257aca4b1b1f03049/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=442178234103c031924b131257aca4b1b1f03049", "patch": "@@ -1,5 +1,11 @@\n 2011-01-19  Richard Henderson  <rth@redhat.com>\n \n+\t* config/mn10300/mn10300.md (addsi3_flags): New.\n+\t(addc_internal, adddi3, adddi3_internal, *adddi3_degenerate): New.\n+\t(subsi3_flags, subc_internal, subdi3): New.\n+\t(subdi3_internal, *subdi3_degenerate): New.\n+\t* config/mn10300/predicates.md (reg_or_am33_const_operand): New.\n+\n \t* config/mn10300/mn10300.c (mn10300_can_use_retf_insn): New.\n \t(mn10300_can_use_rets_insn): Rename from mn10300_can_use_return_insn.\n \t(mn10300_expand_epilogue): Use it.  Compute REG_SAVE_BYTES once."}, {"sha": "bb95b3734cc365ee4c78bcf87c0e081f6ccdaa79", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442178234103c031924b131257aca4b1b1f03049/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442178234103c031924b131257aca4b1b1f03049/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=442178234103c031924b131257aca4b1b1f03049", "patch": "@@ -543,6 +543,172 @@\n   [(set_attr \"timings\" \"11,22\")]\n )\n \n+;; A helper to expand the above, with the CC_MODE filled in.\n+(define_expand \"addsi3_flags\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\")\n+\t\t   (plus:SI (match_operand:SI 1 \"register_operand\")\n+\t\t\t    (match_operand:SI 2 \"nonmemory_operand\")))\n+\t      (set (reg:CCZNC CC_REG)\n+\t\t   (compare:CCZNC (plus:SI (match_dup 1) (match_dup 2))\n+\t\t\t\t  (const_int 0)))])]\n+  \"\"\n+)\n+\n+(define_insn \"addc_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\"            \"=D,r,r\")\n+\t(plus:SI\n+\t  (plus:SI\n+\t    (ltu:SI (reg:CC CC_REG) (const_int 0))\n+\t    (match_operand:SI 1 \"register_operand\"        \"%0,0,r\"))\n+\t  (match_operand:SI 2 \"reg_or_am33_const_operand\" \" D,i,r\")))\n+    (clobber (reg:CC CC_REG))]\n+  \"reload_completed\"\n+  \"@\n+   addc %2,%0\n+   addc %2,%0\n+   addc %2,%1,%0\"\n+  [(set_attr \"isa\" \"*,am33,am33\")]\n+)\n+\n+(define_expand \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+{\n+  rtx op0l, op0h, op1l, op1h, op2l, op2h;\n+\n+  op0l = gen_lowpart (SImode, operands[0]);\n+  op1l = gen_lowpart (SImode, operands[1]);\n+  op2l = gen_lowpart (SImode, operands[2]);\n+  op0h = gen_highpart (SImode, operands[0]);\n+  op1h = gen_highpart (SImode, operands[1]);\n+  op2h = gen_highpart_mode (SImode, DImode, operands[2]);\n+\n+  if (!reg_or_am33_const_operand (op2h, SImode))\n+    op2h = force_reg (SImode, op2h);\n+\n+  emit_insn (gen_adddi3_internal (op0l, op0h, op1l, op2l, op1h, op2h));\n+  DONE;\n+})\n+\n+;; Note that reload only supports one commutative operand.  Thus we cannot\n+;; auto-swap both the high and low outputs with their matching constraints.\n+;; For MN103, we're strapped for registers but thankfully the alternatives\n+;; are few.  For AM33, it becomes much easier to not represent the early\n+;; clobber and 6 permutations of immediate and three-operand adds, but\n+;; instead allocate a scratch register and do the expansion by hand.\n+\n+(define_insn_and_split \"adddi3_internal\"\n+  [(set (match_operand:SI          0 \"register_operand\"   \"=r, r, r\")\n+\t(plus:SI (match_operand:SI 2 \"register_operand\"   \"%0, 0, r\")\n+\t\t (match_operand:SI 3 \"nonmemory_operand\"  \"ri,ri,ri\")))\n+   (set (match_operand:SI          1 \"register_operand\"   \"=D, D, r\")\n+\t(plus:SI\n+\t  (plus:SI\n+\t    (ltu:SI (plus:SI (match_dup 2) (match_dup 3)) (match_dup 2))\n+\t    (match_operand:SI      4 \"register_operand\"   \" 1, D, r\"))\n+\t  (match_operand:SI 5 \"reg_or_am33_const_operand\" \" D, 1,ri\")))\n+   (clobber (match_scratch:SI      6                      \"=X, X,&r\"))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx op0l = operands[0];\n+  rtx op0h = operands[1];\n+  rtx op1l = operands[2];\n+  rtx op2l = operands[3];\n+  rtx op1h = operands[4];\n+  rtx op2h = operands[5];\n+  rtx scratch = operands[6];\n+  rtx x;\n+\n+  if (reg_overlap_mentioned_p (op0l, op1h))\n+    {\n+      emit_move_insn (scratch, op0l);\n+      op1h = scratch;\n+      if (reg_overlap_mentioned_p (op0l, op2h))\n+\top2h = scratch;\n+    }\n+  else if (reg_overlap_mentioned_p (op0l, op2h))\n+    {\n+      emit_move_insn (scratch, op0l);\n+      op2h = scratch;\n+    }\n+\n+  if (rtx_equal_p (op0l, op1l))\n+    ;\n+  else if (rtx_equal_p (op0l, op2l))\n+    x = op1l, op1l = op2l, op2l = x;\n+  else\n+    {\n+      gcc_assert (TARGET_AM33);\n+      if (!REG_P (op2l))\n+\t{\n+\t  emit_move_insn (op0l, op2l);\n+\t  op2l = op1l;\n+\t  op1l = op0l;\n+\t}\n+    }\n+  emit_insn (gen_addsi3_flags (op0l, op1l, op2l));\n+\n+  if (rtx_equal_p (op0h, op1h))\n+    ;\n+  else if (rtx_equal_p (op0h, op2h))\n+    x = op1h, op1h = op2h, op2h = x;\n+  else\n+    {\n+      gcc_assert (TARGET_AM33);\n+      if (!REG_P (op2h))\n+\t{\n+\t  emit_move_insn (op0h, op2h);\n+\t  op2h = op1h;\n+\t  op1h = op0h;\n+\t}\n+    }\n+  emit_insn (gen_addc_internal (op0h, op1h, op2h));\n+  DONE;\n+}\n+  [(set_attr \"isa\" \"*,*,am33\")]\n+)\n+\n+;; The following pattern is generated by combine when it proves that one\n+;; of the inputs to the low-part of the double-word add is zero, and thus\n+;; no carry is generated into the high-part.\n+\n+(define_insn_and_split \"*adddi3_degenerate\"\n+  [(set (match_operand:SI          0 \"register_operand\"  \"=&r,&r\")\n+\t(match_operand:SI          2 \"nonmemory_operand\" \"  0, 0\"))\n+   (set (match_operand:SI          1 \"register_operand\"  \"=r , r\")\n+\t(plus:SI (match_operand:SI 3 \"register_operand\"  \"%1 , r\")\n+\t\t (match_operand:SI 4 \"nonmemory_operand\" \"ri, r\")))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n+  \"#\"\n+  \"\"\n+  [(const_int 0)]\n+{\n+  rtx scratch = NULL_RTX;\n+  if (!rtx_equal_p (operands[0], operands[2]))\n+    {\n+      gcc_assert (!reg_overlap_mentioned_p (operands[0], operands[1]));\n+      if (reg_overlap_mentioned_p (operands[0], operands[3])\n+\t  || reg_overlap_mentioned_p (operands[0], operands[4]))\n+\t{\n+\t  scratch = gen_reg_rtx (SImode);\n+\t  emit_move_insn (scratch, operands[2]);\n+\t}\n+      else\n+\temit_move_insn (operands[0], operands[2]);\n+    }\n+  emit_insn (gen_addsi3 (operands[1], operands[3], operands[4]));\n+  if (scratch)\n+    emit_move_insn (operands[0], scratch);\n+  DONE;\n+})\n+\n ;; ----------------------------------------------------------------------\n ;; SUBTRACT INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n@@ -575,6 +741,161 @@\n    (set_attr \"timings\" \"11,22\")]\n )\n \n+;; A helper to expand the above, with the CC_MODE filled in.\n+(define_expand \"subsi3_flags\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\")\n+\t\t   (minus:SI (match_operand:SI 1 \"register_operand\")\n+\t\t\t     (match_operand:SI 2 \"nonmemory_operand\")))\n+\t      (set (reg:CCZNC CC_REG)\n+\t\t   (compare:CCZNC (minus:SI (match_dup 1) (match_dup 2))\n+\t\t\t\t  (const_int 0)))])]\n+  \"\"\n+)\n+\n+(define_insn \"subc_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\"                      \"=D,r,r\")\n+\t(minus:SI\n+\t  (minus:SI (match_operand:SI 1 \"register_operand\"          \" 0,0,r\")\n+\t\t    (match_operand:SI 2 \"reg_or_am33_const_operand\" \" D,i,r\"))\n+\t  (geu:SI (reg:CC CC_REG) (const_int 0))))\n+   (clobber (reg:CC CC_REG))]\n+  \"reload_completed\"\n+  \"@\n+   subc %2,%0\n+   subc %2,%0\n+   subc %2,%1,%0\"\n+  [(set_attr \"isa\" \"*,am33,am33\")]\n+)\n+\n+(define_expand \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+        (minus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+                  (match_operand:DI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+{\n+  rtx op0l, op0h, op1l, op1h, op2l, op2h;\n+\n+  op0l = gen_lowpart (SImode, operands[0]);\n+  op1l = gen_lowpart (SImode, operands[1]);\n+  op2l = gen_lowpart (SImode, operands[2]);\n+  op0h = gen_highpart (SImode, operands[0]);\n+  op1h = gen_highpart (SImode, operands[1]);\n+  op2h = gen_highpart_mode (SImode, DImode, operands[2]);\n+\n+  if (!reg_or_am33_const_operand (op2h, SImode))\n+    op2h = force_reg (SImode, op2h);\n+\n+  emit_insn (gen_subdi3_internal (op0l, op0h, op1l, op1h, op2l, op2h));\n+  DONE;\n+})\n+\n+;; As with adddi3, the use of the scratch register helps reduce the \n+;; number of permutations for AM33.\n+;; ??? The early clobber on op0 avoids a reload bug wherein both output\n+;; registers are set the same.  Consider negate, where both op2 and op3\n+;; are 0, are csed to the same input register, and reload fails to undo\n+;; the cse when satisfying the matching constraints.\n+\n+(define_insn_and_split \"subdi3_internal\"\n+  [(set (match_operand:SI     0 \"register_operand\"         \"=&r, r\")\n+\t(minus:SI\n+\t  (match_operand:SI   2 \"register_operand\"         \"  0, r\")\n+\t  (match_operand:SI   4 \"nonmemory_operand\"        \" ri,ri\")))\n+   (set (match_operand:SI     1 \"register_operand\"         \"=D , r\")\n+\t(minus:SI\n+\t  (minus:SI\n+\t    (match_operand:SI 3 \"register_operand\"         \"  1, r\")\n+\t    (match_operand:SI 5 \"reg_or_am33_const_operand\" \" D,ri\"))\n+\t  (ltu:SI (match_dup 2) (match_dup 4))))\n+   (clobber (match_scratch:SI 6                            \"=X ,&r\"))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx op0l = operands[0];\n+  rtx op0h = operands[1];\n+  rtx op1l = operands[2];\n+  rtx op1h = operands[3];\n+  rtx op2l = operands[4];\n+  rtx op2h = operands[5];\n+  rtx scratch = operands[6];\n+\n+  if (reg_overlap_mentioned_p (op0l, op1h))\n+    {\n+      emit_move_insn (scratch, op0l);\n+      op1h = scratch;\n+      if (reg_overlap_mentioned_p (op0l, op2h))\n+\top2h = scratch;\n+    }\n+  else if (reg_overlap_mentioned_p (op0l, op2h))\n+    {\n+      emit_move_insn (scratch, op0l);\n+      op2h = scratch;\n+    }\n+\n+  if (!rtx_equal_p (op0l, op1l))\n+    {\n+      gcc_assert (TARGET_AM33);\n+      if (!REG_P (op2l))\n+\t{\n+\t  emit_move_insn (op0l, op1l);\n+\t  op1l = op0l;\n+\t}\n+    }\n+  emit_insn (gen_subsi3_flags (op0l, op1l, op2l));\n+\n+  if (!rtx_equal_p (op0h, op1h))\n+    {\n+      gcc_assert (TARGET_AM33);\n+      if (!REG_P (op2h))\n+\t{\n+\t  emit_move_insn (op0h, op1h);\n+\t  op1h = op0h;\n+\t}\n+    }\n+  emit_insn (gen_subc_internal (op0h, op1h, op2h));\n+  DONE;\n+}\n+  [(set_attr \"isa\" \"*,am33\")]\n+)\n+\n+;; The following pattern is generated by combine when it proves that one\n+;; of the inputs to the low-part of the double-word sub is zero, and thus\n+;; no carry is generated into the high-part.\n+\n+(define_insn_and_split \"*subdi3_degenerate\"\n+  [(set (match_operand:SI          0 \"register_operand\"   \"=&r,&r\")\n+\t(match_operand:SI          2 \"nonmemory_operand\"  \"  0, 0\"))\n+   (set (match_operand:SI          1 \"register_operand\"   \"=r , r\")\n+\t(minus:SI (match_operand:SI 3 \"register_operand\"  \"  1, r\")\n+\t\t  (match_operand:SI 4 \"nonmemory_operand\" \" ri, r\")))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n+  \"#\"\n+  \"\"\n+  [(const_int 0)]\n+{\n+  rtx scratch = NULL_RTX;\n+  if (!rtx_equal_p (operands[0], operands[2]))\n+    {\n+      gcc_assert (!reg_overlap_mentioned_p (operands[0], operands[1]));\n+      if (reg_overlap_mentioned_p (operands[0], operands[3])\n+\t  || reg_overlap_mentioned_p (operands[0], operands[4]))\n+\t{\n+\t  scratch = gen_reg_rtx (SImode);\n+\t  emit_move_insn (scratch, operands[2]);\n+\t}\n+      else\n+\temit_move_insn (operands[0], operands[2]);\n+    }\n+  emit_insn (gen_subsi3 (operands[1], operands[3], operands[4]));\n+  if (scratch)\n+    emit_move_insn (operands[0], scratch);\n+  DONE;\n+})\n+\n (define_insn_and_split \"negsi2\"\n   [(set (match_operand:SI         0 \"register_operand\"  \"=D,&r\")\n \t(neg:SI (match_operand:SI 1 \"register_operand\"  \" 0, r\")))"}, {"sha": "83169901648179ebc430bd521d91cdca025ad5e0", "filename": "gcc/config/mn10300/predicates.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442178234103c031924b131257aca4b1b1f03049/gcc%2Fconfig%2Fmn10300%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442178234103c031924b131257aca4b1b1f03049/gcc%2Fconfig%2Fmn10300%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fpredicates.md?ref=442178234103c031924b131257aca4b1b1f03049", "patch": "@@ -43,6 +43,11 @@\n       || XEXP (op, 1) == stack_pointer_rtx;\n })\n \n+(define_predicate \"reg_or_am33_const_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (and (match_test \"TARGET_AM33\")\n+\t    (match_operand 0 \"immediate_operand\"))))\n+\n (define_predicate \"label_ref_operand\"\n   (match_code \"label_ref\"))\n "}]}