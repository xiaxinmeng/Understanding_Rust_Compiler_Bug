{"sha": "6e63438a0d7085e508d82063af2f04d26fa46494", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU2MzQzOGEwZDcwODVlNTA4ZDgyMDYzYWYyZjA0ZDI2ZmE0NjQ5NA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-19T19:10:32Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-20T19:06:23Z"}, "message": "libstdc++: Fix capturing of lvalue references in_RangeAdaptor::operator()\n\nThis fixes a dangling-reference issue with views::split and other multi-argument\nadaptors that may take its extra arguments by reference.\n\nWhen creating the _RangeAdaptorClosure in _RangeAdaptor::operator(), we\ncurrently capture all provided arguments by value.  When we then use the\n_RangeAdaptorClosure and call it with a range, as in e.g.\n\n    v = views::split(p)(range),\n\nwe forward the range and the captures to the underlying adaptor routine.  But\nthen when the temporary _RangeAdaptorClosure goes out of scope, the by-value\ncaptures get destroyed and the references to these captures in the resulting view\nbecome dangling.\n\nThis patch fixes this problem by capturing lvalue references by reference in\n_RangeAdaptorClosure::operator(), and then forwarding the captures appropriately\nto the underlying adaptor routine.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/ranges (views::__adaptor::__maybe_refwrap): New utility\n\tfunction.\n\t(views::__adaptor::_RangeAdaptor::operator()): Add comments.  Use\n\t__maybe_refwrap to capture lvalue references by reference, and then use\n\tunwrap_reference_t to forward the by-reference captures as references.\n\t* testsuite/std/ranges/adaptors/split.cc: Augment test.\n\t* testsuite/std/ranges/adaptors/split_neg.cc: New test.", "tree": {"sha": "023ca2b24d93258d073faea14ad2786cdf10ce23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/023ca2b24d93258d073faea14ad2786cdf10ce23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e63438a0d7085e508d82063af2f04d26fa46494", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e63438a0d7085e508d82063af2f04d26fa46494", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e63438a0d7085e508d82063af2f04d26fa46494", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e63438a0d7085e508d82063af2f04d26fa46494/comments", "author": null, "committer": null, "parents": [{"sha": "5586e5060fb6a30ade7a7ef854c21bb89b7065c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5586e5060fb6a30ade7a7ef854c21bb89b7065c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5586e5060fb6a30ade7a7ef854c21bb89b7065c9"}], "stats": {"total": 125, "additions": 122, "deletions": 3}, "files": [{"sha": "3649864644e505a1b0b125b54d008d4170b4d818", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e63438a0d7085e508d82063af2f04d26fa46494/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e63438a0d7085e508d82063af2f04d26fa46494/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=6e63438a0d7085e508d82063af2f04d26fa46494", "patch": "@@ -1,5 +1,13 @@\n 2020-02-20  Patrick Palka  <ppalka@redhat.com>\n \n+\t* include/std/ranges (views::__adaptor::__maybe_refwrap): New utility\n+\tfunction.\n+\t(views::__adaptor::_RangeAdaptor::operator()): Add comments.  Use\n+\t__maybe_refwrap to capture lvalue references by reference, and then use\n+\tunwrap_reference_t to forward the by-reference captures as references.\n+\t* testsuite/std/ranges/adaptors/split.cc: Augment test.\n+\t* testsuite/std/ranges/adaptors/split_neg.cc: New test.\n+\n \t* include/std/ranges (iota_view): Forward declare _Sentinel.\n \t(iota_view::_Iterator): Befriend _Sentinel.\n \t(iota_view::_Sentinel::_M_equal): New member function."}, {"sha": "8c925fa278b523535f0e6701d0b208ed835ca71e", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e63438a0d7085e508d82063af2f04d26fa46494/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e63438a0d7085e508d82063af2f04d26fa46494/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=6e63438a0d7085e508d82063af2f04d26fa46494", "patch": "@@ -1051,6 +1051,21 @@ namespace views\n {\n   namespace __adaptor\n   {\n+    template<typename _Tp>\n+      inline constexpr auto\n+      __maybe_refwrap(_Tp& __arg)\n+      { return reference_wrapper<_Tp>{__arg}; }\n+\n+    template<typename _Tp>\n+      inline constexpr auto\n+      __maybe_refwrap(const _Tp& __arg)\n+      { return reference_wrapper<const _Tp>{__arg}; }\n+\n+    template<typename _Tp>\n+      inline constexpr decltype(auto)\n+      __maybe_refwrap(_Tp&& __arg)\n+      { return std::forward<_Tp>(__arg); }\n+\n     template<typename _Callable>\n       struct _RangeAdaptorClosure;\n \n@@ -1079,18 +1094,47 @@ namespace views\n \t  constexpr auto\n \t  operator()(_Args&&... __args) const\n \t  {\n+\t    // [range.adaptor.object]: If a range adaptor object accepts more\n+\t    // than one argument, then the following expressions are equivalent:\n+\t    //\n+\t    //   (1) adaptor(range, args...)\n+\t    //   (2) adaptor(args...)(range)\n+\t    //   (3) range | adaptor(args...)\n+\t    //\n+\t    // In this case, adaptor(args...) is a range adaptor closure object.\n+\t    //\n+\t    // We handle (1) and (2) here, and (3) is just a special case of a\n+\t    // more general case already handled by _RangeAdaptorClosure.\n \t    if constexpr (is_invocable_v<_Callable, _Args...>)\n \t      {\n \t\tstatic_assert(sizeof...(_Args) != 1,\n \t\t\t      \"a _RangeAdaptor that accepts only one argument \"\n \t\t\t      \"should be defined as a _RangeAdaptorClosure\");\n+\t\t// Here we handle adaptor(range, args...) -- just forward all\n+\t\t// arguments to the underlying adaptor routine.\n \t\treturn _Callable{}(std::forward<_Args>(__args)...);\n \t      }\n \t    else\n \t      {\n-\t\tauto __closure = [__args...] <typename _Range> (_Range&& __r) {\n-\t\t  return _Callable{}(std::forward<_Range>(__r), __args...);\n-\t\t};\n+\t\t// Here we handle adaptor(args...)(range).\n+\t\t// Given args..., we return a _RangeAdaptorClosure that takes a\n+\t\t// range argument, such that (2) is equivalent to (1).\n+\t\t//\n+\t\t// We need to be careful about how we capture args... in this\n+\t\t// closure.  By using __maybe_refwrap, we capture lvalue\n+\t\t// references by reference (through a reference_wrapper) and\n+\t\t// otherwise capture by value.\n+\t\tauto __closure\n+\t\t  = [...__args(__maybe_refwrap(std::forward<_Args>(__args)))]\n+\t\t    <typename _Range> (_Range&& __r) {\n+\t\t      // This static_cast has two purposes: it forwards a\n+\t\t      // reference_wrapper<T> capture as a T&, and otherwise\n+\t\t      // forwards the captured argument as an rvalue.\n+\t\t      return _Callable{}(std::forward<_Range>(__r),\n+\t\t\t       (static_cast<unwrap_reference_t\n+\t\t\t\t\t    <remove_const_t<decltype(__args)>>>\n+\t\t\t\t(__args))...);\n+\t\t    };\n \t\tusing _ClosureType = decltype(__closure);\n \t\treturn _RangeAdaptorClosure<_ClosureType>(std::move(__closure));\n \t      }"}, {"sha": "e25031c0aeaaa19768d5f493cd7a12d7f8b95aa1", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/split.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e63438a0d7085e508d82063af2f04d26fa46494/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fsplit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e63438a0d7085e508d82063af2f04d26fa46494/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fsplit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fsplit.cc?ref=6e63438a0d7085e508d82063af2f04d26fa46494", "patch": "@@ -74,10 +74,28 @@ test03()\n   VERIFY( i == v.end() );\n }\n \n+void\n+test04()\n+{\n+  auto x = \"the  quick  brown  fox\"sv;\n+  std::initializer_list<char> p = {' ', ' '};\n+  static_assert(!ranges::view<decltype(p)>);\n+  static_assert(std::same_as<decltype(p | views::all),\n+\t\t\t     ranges::ref_view<decltype(p)>>);\n+  auto v = x | views::split(p);\n+  auto i = v.begin();\n+  VERIFY( ranges::equal(*i++, \"the\"sv) );\n+  VERIFY( ranges::equal(*i++, \"quick\"sv) );\n+  VERIFY( ranges::equal(*i++, \"brown\"sv) );\n+  VERIFY( ranges::equal(*i++, \"fox\"sv) );\n+  VERIFY( i == v.end() );\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n   test03();\n+  test04();\n }"}, {"sha": "6b876c5759164c328300e2bcc27537b26a9fe52e", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/split_neg.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e63438a0d7085e508d82063af2f04d26fa46494/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fsplit_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e63438a0d7085e508d82063af2f04d26fa46494/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fsplit_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fsplit_neg.cc?ref=6e63438a0d7085e508d82063af2f04d26fa46494", "patch": "@@ -0,0 +1,49 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <algorithm>\n+#include <ranges>\n+#include <string_view>\n+\n+namespace ranges = std::ranges;\n+namespace views = std::ranges::views;\n+\n+void\n+test01()\n+{\n+  using namespace std::literals;\n+  auto x = \"the  quick  brown  fox\"sv;\n+  auto v = views::split(x, std::initializer_list<char>{' ', ' '});\n+  v.begin(); // { dg-error \"\" }\n+}\n+\n+void\n+test02()\n+{\n+  using namespace std::literals;\n+  auto x = \"the  quick  brown  fox\"sv;\n+  auto v = x | views::split(std::initializer_list<char>{' ', ' '}); // { dg-error \"no match\" }\n+  v.begin();\n+}\n+\n+// { dg-prune-output \"in requirements\" }\n+// { dg-error \"deduction failed\" \"\" { target *-*-* } 0 }\n+// { dg-error \"no match\" \"\" { target *-*-* } 0 }\n+// { dg-error \"constraint failure\" \"\" { target *-*-* } 0 }"}]}