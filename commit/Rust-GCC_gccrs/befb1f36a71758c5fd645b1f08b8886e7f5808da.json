{"sha": "befb1f36a71758c5fd645b1f08b8886e7f5808da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVmYjFmMzZhNzE3NThjNWZkNjQ1YjFmMDhiODg4NmU3ZjU4MDhkYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-01-20T20:03:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-01-20T20:03:23Z"}, "message": "re PR ipa/63576 (ICE : in ipa_merge_profiles, at ipa-utils.c:540 during Firefox LTO/PGO build)\n\n\tPR ipa/63576\n\t* ipa-utils.c (ipa_merge_profiles): Merge speculative edges.\n\nFrom-SVN: r219910", "tree": {"sha": "e9d54a11212a674f38a2545167dedcd4148a8def", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9d54a11212a674f38a2545167dedcd4148a8def"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/befb1f36a71758c5fd645b1f08b8886e7f5808da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/befb1f36a71758c5fd645b1f08b8886e7f5808da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/befb1f36a71758c5fd645b1f08b8886e7f5808da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/befb1f36a71758c5fd645b1f08b8886e7f5808da/comments", "author": null, "committer": null, "parents": [{"sha": "bb1e543c64ff31a2e5d6959b0e4260c507c45b5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb1e543c64ff31a2e5d6959b0e4260c507c45b5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb1e543c64ff31a2e5d6959b0e4260c507c45b5b"}], "stats": {"total": 97, "additions": 89, "deletions": 8}, "files": [{"sha": "f9755b8200cc7ceb98b85f530332d126b3315af4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befb1f36a71758c5fd645b1f08b8886e7f5808da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befb1f36a71758c5fd645b1f08b8886e7f5808da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=befb1f36a71758c5fd645b1f08b8886e7f5808da", "patch": "@@ -1,3 +1,8 @@\n+2015-01-19  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/63576\n+\t* ipa-utils.c (ipa_merge_profiles): Merge speculative edges.\n+\n 2015-01-19  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR lto/45375"}, {"sha": "76125481cd9f9062e121bfc14823902522335f55", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 84, "deletions": 8, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befb1f36a71758c5fd645b1f08b8886e7f5808da/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befb1f36a71758c5fd645b1f08b8886e7f5808da/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=befb1f36a71758c5fd645b1f08b8886e7f5808da", "patch": "@@ -539,7 +539,7 @@ ipa_merge_profiles (struct cgraph_node *dst,\n     }\n   if (match)\n     {\n-      struct cgraph_edge *e;\n+      struct cgraph_edge *e, *e2;\n       basic_block srcbb, dstbb;\n \n       /* TODO: merge also statement histograms.  */\n@@ -562,19 +562,95 @@ ipa_merge_profiles (struct cgraph_node *dst,\n       pop_cfun ();\n       for (e = dst->callees; e; e = e->next_callee)\n \t{\n-\t  gcc_assert (!e->speculative);\n+\t  if (e->speculative)\n+\t    continue;\n \t  e->count = gimple_bb (e->call_stmt)->count;\n \t  e->frequency = compute_call_stmt_bb_frequency\n \t\t\t     (dst->decl,\n \t\t\t      gimple_bb (e->call_stmt));\n \t}\n-      for (e = dst->indirect_calls; e; e = e->next_callee)\n+      for (e = dst->indirect_calls, e2 = src->indirect_calls; e;\n+\t   e2 = (e2 ? e2->next_callee : NULL), e = e->next_callee)\n \t{\n-\t  gcc_assert (!e->speculative);\n-\t  e->count = gimple_bb (e->call_stmt)->count;\n-\t  e->frequency = compute_call_stmt_bb_frequency\n-\t\t\t     (dst->decl,\n-\t\t\t      gimple_bb (e->call_stmt));\n+\t  gcov_type count = gimple_bb (e->call_stmt)->count;\n+\t  int freq = compute_call_stmt_bb_frequency\n+\t\t\t(dst->decl,\n+\t\t\t gimple_bb (e->call_stmt));\n+\t  /* When call is speculative, we need to re-distribute probabilities\n+\t     the same way as they was.  This is not really correct because\n+\t     in the other copy the speculation may differ; but probably it\n+\t     is not really worth the effort.  */\n+\t  if (e->speculative)\n+\t    {\n+\t      cgraph_edge *direct, *indirect;\n+\t      cgraph_edge *direct2 = NULL, *indirect2 = NULL;\n+\t      ipa_ref *ref;\n+\n+\t      e->speculative_call_info (direct, indirect, ref);\n+\t      gcc_assert (e == indirect);\n+\t      if (e2 && e2->speculative)\n+\t        e2->speculative_call_info (direct2, indirect2, ref);\n+\t      if (indirect->count || direct->count)\n+\t\t{\n+\t\t  /* We should mismatch earlier if there is no matching\n+\t\t     indirect edge.  */\n+\t\t  if (!e2)\n+\t\t    {\n+\t\t      if (dump_file)\n+\t\t        fprintf (dump_file,\n+\t\t\t\t \"Mismatch in merging indirect edges\\n\");\n+\t\t    }\n+\t\t  else if (!e2->speculative)\n+\t\t    indirect->count += e2->count;\n+\t\t  else if (e2->speculative)\n+\t\t    {\n+\t\t      if (DECL_ASSEMBLER_NAME (direct2->callee->decl)\n+\t\t\t  != DECL_ASSEMBLER_NAME (direct->callee->decl))\n+\t\t\t{\n+\t\t\t  if (direct2->count >= direct->count)\n+\t\t\t    {\n+\t\t\t      direct->redirect_callee (direct2->callee);\n+\t\t\t      indirect->count += indirect2->count\n+\t\t\t\t\t\t + direct->count;\n+\t\t\t      direct->count = direct2->count;\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    indirect->count += indirect2->count + direct2->count;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t   direct->count += direct2->count;\n+\t\t\t   indirect->count += indirect2->count;\n+\t\t\t}\n+\t\t    }\n+\t\t  int  prob = RDIV (direct->count * REG_BR_PROB_BASE ,\n+\t\t\t\t    direct->count + indirect->count);\n+\t\t  direct->frequency = RDIV (freq * prob, REG_BR_PROB_BASE);\n+\t\t  indirect->frequency = RDIV (freq * (REG_BR_PROB_BASE - prob),\n+\t\t\t\t\t      REG_BR_PROB_BASE);\n+\t\t}\n+\t      else\n+\t\t/* At the moment we should have only profile feedback based\n+\t\t   speculations when merging.  */\n+\t\tgcc_unreachable ();\n+\t    }\n+\t  else if (e2->speculative)\n+\t    {\n+\t      cgraph_edge *direct, *indirect;\n+\t      ipa_ref *ref;\n+\n+\t      e2->speculative_call_info (direct, indirect, ref);\n+\t      e->count = count;\n+\t      e->frequency = freq;\n+\t      int prob = RDIV (direct->count * REG_BR_PROB_BASE, e->count);\n+\t      e->make_speculative (direct->callee, direct->count,\n+\t\t\t\t   RDIV (freq * prob, REG_BR_PROB_BASE));\n+\t    }\n+\t  else\n+\t    {\n+\t      e->count = count;\n+\t      e->frequency = freq;\n+\t    }\n \t}\n       src->release_body ();\n       inline_update_overall_summary (dst);"}]}