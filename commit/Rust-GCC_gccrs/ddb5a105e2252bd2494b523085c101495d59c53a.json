{"sha": "ddb5a105e2252bd2494b523085c101495d59c53a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRiNWExMDVlMjI1MmJkMjQ5NGI1MjMwODVjMTAxNDk1ZDU5YzUzYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-03-23T10:04:08Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-03-23T10:04:08Z"}, "message": "trans.c (create_temporary): New function taken from...\n\n\t* gcc-interface/trans.c (create_temporary): New function taken from...\n\t(create_init_temporary): ...here.  Call it.\n\t(call_to_gnu): Create the temporary for the return value early, if any.\n\tCreate it for a function with copy-in/copy-out parameters if there is\n\tno target; in other cases of copy-in/copy-out, use another temporary.\n\tPush the new binding level lazily.  Add and rename local variables.\n\nFrom-SVN: r171345", "tree": {"sha": "95fb7ad60a335d8a7918afcbb3f27c23c4dc83b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95fb7ad60a335d8a7918afcbb3f27c23c4dc83b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddb5a105e2252bd2494b523085c101495d59c53a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddb5a105e2252bd2494b523085c101495d59c53a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddb5a105e2252bd2494b523085c101495d59c53a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddb5a105e2252bd2494b523085c101495d59c53a/comments", "author": null, "committer": null, "parents": [{"sha": "3460fdf328976b9f328478e12e0c87c48091d33a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3460fdf328976b9f328478e12e0c87c48091d33a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3460fdf328976b9f328478e12e0c87c48091d33a"}], "stats": {"total": 235, "additions": 164, "deletions": 71}, "files": [{"sha": "2468644e7f4fc5fe08e146cf1869b5d03b5c8280", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb5a105e2252bd2494b523085c101495d59c53a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb5a105e2252bd2494b523085c101495d59c53a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ddb5a105e2252bd2494b523085c101495d59c53a", "patch": "@@ -1,3 +1,12 @@\n+2011-03-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (create_temporary): New function taken from...\n+\t(create_init_temporary): ...here.  Call it.\n+\t(call_to_gnu): Create the temporary for the return value early, if any.\n+\tCreate it for a function with copy-in/copy-out parameters if there is\n+\tno target; in other cases of copy-in/copy-out, use another temporary.\n+\tPush the new binding level lazily.  Add and rename local variables.\n+\n 2011-03-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (validate_size): Improve comments and tweak"}, {"sha": "dc83f0a1c8b261002b97b812392b11ad3add7b9d", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 110, "deletions": 71, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb5a105e2252bd2494b523085c101495d59c53a/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb5a105e2252bd2494b523085c101495d59c53a/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=ddb5a105e2252bd2494b523085c101495d59c53a", "patch": "@@ -2701,6 +2701,19 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   mark_out_of_scope (Defining_Unit_Name (Specification (gnat_node)));\n }\n \f\n+/* Create a temporary variable with PREFIX and TYPE, and return it.  */\n+\n+static tree\n+create_temporary (const char *prefix, tree type)\n+{\n+  tree gnu_temp = create_var_decl (create_tmp_var_name (prefix), NULL_TREE,\n+\t\t\t\t   type, NULL_TREE, false, false, false, false,\n+\t\t\t\t   NULL, Empty);\n+  DECL_ARTIFICIAL (gnu_temp) = 1;\n+  DECL_IGNORED_P (gnu_temp) = 1;\n+\n+  return gnu_temp;\n+}\n \n /* Create a temporary variable with PREFIX and initialize it with GNU_INIT.\n    Put the initialization statement into GNU_INIT_STMT and annotate it with\n@@ -2710,11 +2723,7 @@ static tree\n create_init_temporary (const char *prefix, tree gnu_init, tree *gnu_init_stmt,\n \t\t       Node_Id gnat_node)\n {\n-  tree gnu_temp = create_var_decl (create_tmp_var_name (prefix), NULL_TREE,\n-\t\t\t\t   TREE_TYPE (gnu_init), NULL_TREE, false,\n-\t\t\t\t   false, false, false, NULL, Empty);\n-  DECL_ARTIFICIAL (gnu_temp) = 1;\n-  DECL_IGNORED_P (gnu_temp) = 1;\n+  tree gnu_temp = create_temporary (prefix, TREE_TYPE (gnu_init));\n \n   *gnu_init_stmt = build_binary_op (INIT_EXPR, NULL_TREE, gnu_temp, gnu_init);\n   set_expr_location_from_node (*gnu_init_stmt, gnat_node);\n@@ -2731,24 +2740,28 @@ create_init_temporary (const char *prefix, tree gnu_init, tree *gnu_init_stmt,\n static tree\n call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n {\n+  const bool function_call = (Nkind (gnat_node) == N_Function_Call);\n+  const bool returning_value = (function_call && !gnu_target);\n   /* The GCC node corresponding to the GNAT subprogram name.  This can either\n      be a FUNCTION_DECL node if we are dealing with a standard subprogram call,\n      or an indirect reference expression (an INDIRECT_REF node) pointing to a\n      subprogram.  */\n   tree gnu_subprog = gnat_to_gnu (Name (gnat_node));\n   /* The FUNCTION_TYPE node giving the GCC type of the subprogram.  */\n   tree gnu_subprog_type = TREE_TYPE (gnu_subprog);\n+  /* The return type of the FUNCTION_TYPE.  */\n+  tree gnu_result_type = TREE_TYPE (gnu_subprog_type);\n   tree gnu_subprog_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_subprog);\n-  Entity_Id gnat_formal;\n-  Node_Id gnat_actual;\n   VEC(tree,gc) *gnu_actual_vec = NULL;\n   tree gnu_name_list = NULL_TREE;\n-  tree gnu_before_list = NULL_TREE;\n+  tree gnu_stmt_list = NULL_TREE;\n   tree gnu_after_list = NULL_TREE;\n+  tree gnu_retval = NULL_TREE;\n   tree gnu_call, gnu_result;\n-  bool returning_value = (Nkind (gnat_node) == N_Function_Call && !gnu_target);\n-  bool pushed_binding_level = false;\n   bool went_into_elab_proc = false;\n+  bool pushed_binding_level = false;\n+  Entity_Id gnat_formal;\n+  Node_Id gnat_actual;\n \n   gcc_assert (TREE_CODE (gnu_subprog_type) == FUNCTION_TYPE);\n \n@@ -2766,8 +2779,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \n       if (returning_value)\n \t{\n-\t  *gnu_result_type_p = TREE_TYPE (gnu_subprog_type);\n-\t  return build1 (NULL_EXPR, TREE_TYPE (gnu_subprog_type), call_expr);\n+\t  *gnu_result_type_p = gnu_result_type;\n+\t  return build1 (NULL_EXPR, gnu_result_type, call_expr);\n \t}\n \n       return call_expr;\n@@ -2785,28 +2798,28 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n   else\n     gnat_formal = First_Formal_With_Extras (Entity (Name (gnat_node)));\n \n-  /* If we are translating a statement, push a new binding level that will\n-     surround it to declare the temporaries created for the call.  Likewise\n-     if we'll be returning a value and also have copy-in/copy-out parameters,\n-     as we need to create statements to fetch their value after the call.\n-\n-     ??? We could do that unconditionally, but the middle-end doesn't seem\n-     to be prepared to handle the construct in nested contexts.  */\n-  if (!returning_value || TYPE_CI_CO_LIST (gnu_subprog_type))\n-    {\n-      start_stmt_group ();\n-      gnat_pushlevel ();\n-      pushed_binding_level = true;\n-    }\n-\n-  /* The lifetime of the temporaries created for the call ends with the call\n-     so we can give them the scope of the elaboration routine at top level.  */\n+  /* The lifetime of the temporaries created for the call ends right after the\n+     return value is copied, so we can give them the scope of the elaboration\n+     routine at top level.  */\n   if (!current_function_decl)\n     {\n       current_function_decl = get_elaboration_procedure ();\n       went_into_elab_proc = true;\n     }\n \n+  /* First, create the temporary for the return value if we need it: for a\n+     variable-sized return type if there is no target or if this is slice,\n+     because the gimplifier doesn't support these cases; or for a function\n+     with copy-in/copy-out parameters if there is no target, because we'll\n+     need to preserve the return value before copying back the parameters.\n+     This must be done before we push a new binding level around the call\n+     as we will pop it before copying the return value.  */\n+  if (function_call\n+      && ((TREE_CODE (TYPE_SIZE (gnu_result_type)) != INTEGER_CST\n+\t   && (!gnu_target || TREE_CODE (gnu_target) == ARRAY_RANGE_REF))\n+\t  || (!gnu_target && TYPE_CI_CO_LIST (gnu_subprog_type))))\n+    gnu_retval = create_temporary (\"R\", gnu_result_type);\n+\n   /* Create the list of the actual parameters as GCC expects it, namely a\n      chain of TREE_LIST nodes in which the TREE_VALUE field of each node\n      is an expression and the TREE_PURPOSE field is null.  But skip Out\n@@ -2823,7 +2836,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t an lvalue but can nevertheless cause the creation of a temporary,\n \t because we need the real object in this case, either to pass its\n \t address if it's passed by reference or as target of the back copy\n-\t done after the call if it uses the copy-in copy-out mechanism.\n+\t done after the call if it uses the copy-in/copy-out mechanism.\n \t We do it in the In case too, except for an unchecked conversion\n \t because it alone can cause the actual to be misaligned and the\n \t addressability test is applied to the real object.  */\n@@ -2916,23 +2929,30 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t\t\t\t       TREE_TYPE (gnu_name))))\n \t    gnu_name = convert (gnu_name_type, gnu_name);\n \n-\t  /* If we haven't pushed a binding level and this is an In Out or Out\n-\t     parameter, push a new one.  This is needed to wrap the copy-back\n-\t     statements we'll be making below.  */\n-\t  if (!pushed_binding_level && !in_param)\n+\t  /* If this is an In Out or Out parameter and we're returning a value,\n+\t     we need to create a temporary for the return value because we must\n+\t     preserve it before copying back at the very end.  */\n+\t  if (!in_param && returning_value && !gnu_retval)\n+\t    gnu_retval = create_temporary (\"R\", gnu_result_type);\n+\n+\t  /* If we haven't pushed a binding level, push a new one.  This will\n+\t     narrow the lifetime of the temporary we are about to make as much\n+\t     as possible.  The drawback is that we'd need to create a temporary\n+\t     for the return value, if any (see comment before the loop).  So do\n+\t     it only when this temporary was already created just above.  */\n+\t  if (!pushed_binding_level && !(in_param && returning_value))\n \t    {\n \t      start_stmt_group ();\n \t      gnat_pushlevel ();\n \t      pushed_binding_level = true;\n \t    }\n \n-\t  /* Create an explicit temporary holding the copy.  This ensures that\n-\t     its lifetime is as narrow as possible around a statement.  */\n+\t  /* Create an explicit temporary holding the copy.  */\n \t  gnu_temp\n \t    = create_init_temporary (\"A\", gnu_name, &gnu_stmt, gnat_actual);\n \n \t  /* But initialize it on the fly like for an implicit temporary as\n-\t     we aren't necessarily dealing with a statement.  */\n+\t     we aren't necessarily having a statement list.  */\n \t  gnu_name = build_compound_expr (TREE_TYPE (gnu_name), gnu_stmt,\n \t\t\t\t\t  gnu_temp);\n \n@@ -2994,7 +3014,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t  if (Ekind (gnat_formal) != E_In_Parameter)\n \t    {\n \t      /* In Out or Out parameters passed by reference don't use the\n-\t\t copy-in copy-out mechanism so the address of the real object\n+\t\t copy-in/copy-out mechanism so the address of the real object\n \t\t must be passed to the function.  */\n \t      gnu_actual = gnu_name;\n \n@@ -3085,7 +3105,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t    {\n \t      /* Make sure side-effects are evaluated before the call.  */\n \t      if (TREE_SIDE_EFFECTS (gnu_name))\n-\t\tappend_to_statement_list (gnu_name, &gnu_before_list);\n+\t\tappend_to_statement_list (gnu_name, &gnu_stmt_list);\n \t      continue;\n \t    }\n \n@@ -3111,10 +3131,20 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       VEC_safe_push (tree, gc, gnu_actual_vec, gnu_actual);\n     }\n \n-  gnu_call = build_call_vec (TREE_TYPE (gnu_subprog_type), gnu_subprog_addr,\n-                             gnu_actual_vec);\n+  gnu_call\n+    = build_call_vec (gnu_result_type, gnu_subprog_addr, gnu_actual_vec);\n   set_expr_location_from_node (gnu_call, gnat_node);\n \n+  /* If we have created a temporary for the return value, initialize it.  */\n+  if (gnu_retval)\n+    {\n+      tree gnu_stmt\n+\t= build_binary_op (INIT_EXPR, NULL_TREE, gnu_retval, gnu_call);\n+      set_expr_location_from_node (gnu_stmt, gnat_node);\n+      append_to_statement_list (gnu_stmt, &gnu_stmt_list);\n+      gnu_call = gnu_retval;\n+    }\n+\n   /* If this is a subprogram with copy-in/copy-out parameters, we need to\n      unpack the valued returned from the function into the In Out or Out\n      parameters.  We deal with the function return (if this is an Ada\n@@ -3130,10 +3160,22 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t function is pure.  Save the result into a temporary if needed.  */\n       if (length > 1)\n \t{\n-\t  tree gnu_stmt;\n-\t  gnu_call\n-\t    = create_init_temporary (\"R\", gnu_call, &gnu_stmt, gnat_node);\n-\t  append_to_statement_list (gnu_stmt, &gnu_before_list);\n+\t  if (!gnu_retval)\n+\t    {\n+\t      tree gnu_stmt;\n+\t      /* If we haven't pushed a binding level, push a new one.  This\n+\t\t will narrow the lifetime of the temporary we are about to\n+\t\t make as much as possible.  */\n+\t      if (!pushed_binding_level)\n+\t\t{\n+\t\t  start_stmt_group ();\n+\t\t  gnat_pushlevel ();\n+\t\t  pushed_binding_level = true;\n+\t        }\n+\t      gnu_call\n+\t\t= create_init_temporary (\"P\", gnu_call, &gnu_stmt, gnat_node);\n+\t      append_to_statement_list (gnu_stmt, &gnu_stmt_list);\n+\t    }\n \n \t  gnu_name_list = nreverse (gnu_name_list);\n \t}\n@@ -3226,7 +3268,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t    gnu_result = build_binary_op (MODIFY_EXPR, NULL_TREE,\n \t\t\t\t\t  gnu_actual, gnu_result);\n \t    set_expr_location_from_node (gnu_result, gnat_node);\n-\t    append_to_statement_list (gnu_result, &gnu_before_list);\n+\t    append_to_statement_list (gnu_result, &gnu_stmt_list);\n \t    gnu_cico_list = TREE_CHAIN (gnu_cico_list);\n \t    gnu_name_list = TREE_CHAIN (gnu_name_list);\n \t  }\n@@ -3235,10 +3277,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n   /* If this is a function call, the result is the call expression unless a\n      target is specified, in which case we copy the result into the target\n      and return the assignment statement.  */\n-  if (Nkind (gnat_node) == N_Function_Call)\n+  if (function_call)\n     {\n-      tree gnu_result_type = TREE_TYPE (gnu_subprog_type);\n-\n       /* If this is a function with copy-in/copy-out parameters, extract the\n \t return value from it and update the return type.  */\n       if (TYPE_CI_CO_LIST (gnu_subprog_type))\n@@ -3267,11 +3307,11 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t      = emit_range_check (gnu_call, Etype (Name (gnat_parent)),\n \t\t\t\t  gnat_parent);\n \n-\t  /* ??? If the return type has non-constant size, then force the\n-\t     return slot optimization as we would not be able to generate\n-\t     a temporary.  Likewise if it was unconstrained as we would\n-\t     copy too much data.  That's what has been done historically.  */\n-\t  if (!TREE_CONSTANT (TYPE_SIZE (gnu_result_type))\n+\t  /* ??? If the return type has variable size, then force the return\n+\t     slot optimization as we would not be able to create a temporary.\n+\t     Likewise if it was unconstrained as we would copy too much data.\n+\t     That's what has been done historically.  */\n+\t  if (TREE_CODE (TYPE_SIZE (gnu_result_type)) != INTEGER_CST\n \t      || (TYPE_IS_PADDING_P (gnu_result_type)\n \t\t  && CONTAINS_PLACEHOLDER_P\n \t\t     (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS (gnu_result_type))))))\n@@ -3282,7 +3322,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t  gnu_call\n \t    = build_binary_op (op_code, NULL_TREE, gnu_target, gnu_call);\n \t  set_expr_location_from_node (gnu_call, gnat_parent);\n-\t  append_to_statement_list (gnu_call, &gnu_before_list);\n+\t  append_to_statement_list (gnu_call, &gnu_stmt_list);\n \t}\n       else\n \t*gnu_result_type_p = get_unpadded_type (Etype (gnat_node));\n@@ -3291,36 +3331,35 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n   /* Otherwise, if this is a procedure call statement without copy-in/copy-out\n      parameters, the result is just the call statement.  */\n   else if (!TYPE_CI_CO_LIST (gnu_subprog_type))\n-    append_to_statement_list (gnu_call, &gnu_before_list);\n+    append_to_statement_list (gnu_call, &gnu_stmt_list);\n+\n+  /* Finally, add the copy back statements, if any.  */\n+  append_to_statement_list (gnu_after_list, &gnu_stmt_list);\n \n   if (went_into_elab_proc)\n     current_function_decl = NULL_TREE;\n \n-  /* If we have pushed a binding level, the result is the statement group.\n-     Otherwise it's just the call expression.  */\n+  /* If we have pushed a binding level, pop it and finish up the enclosing\n+     statement group.  */\n   if (pushed_binding_level)\n     {\n-      /* If we need a value and haven't created the call statement, do so.  */\n-      if (returning_value && !TYPE_CI_CO_LIST (gnu_subprog_type))\n-\t{\n-\t  tree gnu_stmt;\n-\t  gnu_call\n-\t    = create_init_temporary (\"R\", gnu_call, &gnu_stmt, gnat_node);\n-\t  append_to_statement_list (gnu_stmt, &gnu_before_list);\n-\t}\n-      append_to_statement_list (gnu_after_list, &gnu_before_list);\n-      add_stmt (gnu_before_list);\n+      add_stmt (gnu_stmt_list);\n       gnat_poplevel ();\n       gnu_result = end_stmt_group ();\n     }\n+\n+  /* Otherwise, retrieve the statement list, if any.  */\n+  else if (gnu_stmt_list)\n+    gnu_result = gnu_stmt_list;\n+\n+  /* Otherwise, just return the call expression.  */\n   else\n     return gnu_call;\n \n-  /* If we need a value, make a COMPOUND_EXPR to return it; otherwise,\n-     return the result.  Deal specially with UNCONSTRAINED_ARRAY_REF.  */\n+  /* If we nevertheless need a value, make a COMPOUND_EXPR to return it.  */\n   if (returning_value)\n-    gnu_result = build_compound_expr (TREE_TYPE (gnu_call), gnu_result,\n-\t\t\t\t      gnu_call);\n+    gnu_result\n+      = build_compound_expr (TREE_TYPE (gnu_call), gnu_result, gnu_call);\n \n   return gnu_result;\n }"}, {"sha": "cfc85e3f0f85bfe91eba49da7a01a470d47e9c8f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb5a105e2252bd2494b523085c101495d59c53a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb5a105e2252bd2494b523085c101495d59c53a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ddb5a105e2252bd2494b523085c101495d59c53a", "patch": "@@ -1,3 +1,8 @@\n+2011-03-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/discr26.ad[sb]: New test.\n+\t* gnat.dg/discr26_pkg.ads: New helper.\n+\n 2011-03-23  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \tPR target/47553"}, {"sha": "2d498889bf8186477c4b5b546bc55293365b064c", "filename": "gcc/testsuite/gnat.dg/discr26.adb", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb5a105e2252bd2494b523085c101495d59c53a/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr26.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb5a105e2252bd2494b523085c101495d59c53a/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr26.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr26.adb?ref=ddb5a105e2252bd2494b523085c101495d59c53a", "patch": "@@ -0,0 +1,19 @@\n+-- { dg-do compile }\n+-- { dg-options \"-gnatws\" }\n+\n+package body Discr26 is\n+\n+  function F1 return My_T1 is\n+    R: My_T1;\n+  begin\n+    return R;\n+  end;\n+\n+  procedure Proc is\n+  begin\n+    if F1.D = 0 then\n+      raise Program_Error;\n+    end if;\n+  end;\n+\n+end Discr26;"}, {"sha": "5a428f2bfed8f9fc919cd5c72564d1c1c8933294", "filename": "gcc/testsuite/gnat.dg/discr26.ads", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb5a105e2252bd2494b523085c101495d59c53a/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr26.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb5a105e2252bd2494b523085c101495d59c53a/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr26.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr26.ads?ref=ddb5a105e2252bd2494b523085c101495d59c53a", "patch": "@@ -0,0 +1,16 @@\n+with Discr26_Pkg;\n+\n+package Discr26 is\n+\n+  type T1 (D : Integer) is record\n+    case D is\n+      when 1 => I : Integer;\n+      when others => null;\n+    end case;\n+  end record;\n+\n+  type My_T1 is new T1 (Discr26_Pkg.N);\n+\n+  procedure Proc;\n+\n+end Discr26;"}, {"sha": "ca775eb5d614442c57d2173475e9e98569f5987e", "filename": "gcc/testsuite/gnat.dg/discr26_pkg.ads", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb5a105e2252bd2494b523085c101495d59c53a/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr26_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb5a105e2252bd2494b523085c101495d59c53a/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr26_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr26_pkg.ads?ref=ddb5a105e2252bd2494b523085c101495d59c53a", "patch": "@@ -0,0 +1,5 @@\n+package Discr26_Pkg is\n+\n+  function N return Integer;\n+\n+end Discr26_Pkg;"}]}