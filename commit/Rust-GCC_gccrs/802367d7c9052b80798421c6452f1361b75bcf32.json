{"sha": "802367d7c9052b80798421c6452f1361b75bcf32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAyMzY3ZDdjOTA1MmI4MDc5ODQyMWM2NDUyZjEzNjFiNzViY2YzMg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-04-30T16:56:01Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-04-30T16:56:01Z"}, "message": "re PR fortran/35993 (wrong answer for all array intrinsics with scalar mask)\n\n2008-04-30  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/35993\n\t* ifunction.m4 (SCALAR_ARRAY_FUNCTION):  Use correct\n\timplementation for multi-dimensional return arrays when\n\tthe mask is .false.\n\t* generated/maxloc1_16_i1.c: Regenerated.\n\t* generated/maxloc1_16_i16.c: Regenerated.\n\t* generated/maxloc1_16_i2.c: Regenerated.\n\t* generated/maxloc1_16_i4.c: Regenerated.\n\t* generated/maxloc1_16_i8.c: Regenerated.\n\t* generated/maxloc1_16_r10.c: Regenerated.\n\t* generated/maxloc1_16_r16.c: Regenerated.\n\t* generated/maxloc1_16_r4.c: Regenerated.\n\t* generated/maxloc1_16_r8.c: Regenerated.\n\t* generated/maxloc1_4_i1.c: Regenerated.\n\t* generated/maxloc1_4_i16.c: Regenerated.\n\t* generated/maxloc1_4_i2.c: Regenerated.\n\t* generated/maxloc1_4_i4.c: Regenerated.\n\t* generated/maxloc1_4_i8.c: Regenerated.\n\t* generated/maxloc1_4_r10.c: Regenerated.\n\t* generated/maxloc1_4_r16.c: Regenerated.\n\t* generated/maxloc1_4_r4.c: Regenerated.\n\t* generated/maxloc1_4_r8.c: Regenerated.\n\t* generated/maxloc1_8_i1.c: Regenerated.\n\t* generated/maxloc1_8_i16.c: Regenerated.\n\t* generated/maxloc1_8_i2.c: Regenerated.\n\t* generated/maxloc1_8_i4.c: Regenerated.\n\t* generated/maxloc1_8_i8.c: Regenerated.\n\t* generated/maxloc1_8_r10.c: Regenerated.\n\t* generated/maxloc1_8_r16.c: Regenerated.\n\t* generated/maxloc1_8_r4.c: Regenerated.\n\t* generated/maxloc1_8_r8.c: Regenerated.\n\t* generated/maxval_i1.c: Regenerated.\n\t* generated/maxval_i16.c: Regenerated.\n\t* generated/maxval_i2.c: Regenerated.\n\t* generated/maxval_i4.c: Regenerated.\n\t* generated/maxval_i8.c: Regenerated.\n\t* generated/maxval_r10.c: Regenerated.\n\t* generated/maxval_r16.c: Regenerated.\n\t* generated/maxval_r4.c: Regenerated.\n\t* generated/maxval_r8.c: Regenerated.\n\t* generated/minloc1_16_i1.c: Regenerated.\n\t* generated/minloc1_16_i16.c: Regenerated.\n\t* generated/minloc1_16_i2.c: Regenerated.\n\t* generated/minloc1_16_i4.c: Regenerated.\n\t* generated/minloc1_16_i8.c: Regenerated.\n\t* generated/minloc1_16_r10.c: Regenerated.\n\t* generated/minloc1_16_r16.c: Regenerated.\n\t* generated/minloc1_16_r4.c: Regenerated.\n\t* generated/minloc1_16_r8.c: Regenerated.\n\t* generated/minloc1_4_i1.c: Regenerated.\n\t* generated/minloc1_4_i16.c: Regenerated.\n\t* generated/minloc1_4_i2.c: Regenerated.\n\t* generated/minloc1_4_i4.c: Regenerated.\n\t* generated/minloc1_4_i8.c: Regenerated.\n\t* generated/minloc1_4_r10.c: Regenerated.\n\t* generated/minloc1_4_r16.c: Regenerated.\n\t* generated/minloc1_4_r4.c: Regenerated.\n\t* generated/minloc1_4_r8.c: Regenerated.\n\t* generated/minloc1_8_i1.c: Regenerated.\n\t* generated/minloc1_8_i16.c: Regenerated.\n\t* generated/minloc1_8_i2.c: Regenerated.\n\t* generated/minloc1_8_i4.c: Regenerated.\n\t* generated/minloc1_8_i8.c: Regenerated.\n\t* generated/minloc1_8_r10.c: Regenerated.\n\t* generated/minloc1_8_r16.c: Regenerated.\n\t* generated/minloc1_8_r4.c: Regenerated.\n\t* generated/minloc1_8_r8.c: Regenerated.\n\t* generated/minval_i1.c: Regenerated.\n\t* generated/minval_i16.c: Regenerated.\n\t* generated/minval_i2.c: Regenerated.\n\t* generated/minval_i4.c: Regenerated.\n\t* generated/minval_i8.c: Regenerated.\n\t* generated/minval_r10.c: Regenerated.\n\t* generated/minval_r16.c: Regenerated.\n\t* generated/minval_r4.c: Regenerated.\n\t* generated/minval_r8.c: Regenerated.\n\t* generated/product_c10.c: Regenerated.\n\t* generated/product_c16.c: Regenerated.\n\t* generated/product_c4.c: Regenerated.\n\t* generated/product_c8.c: Regenerated.\n\t* generated/product_i1.c: Regenerated.\n\t* generated/product_i16.c: Regenerated.\n\t* generated/product_i2.c: Regenerated.\n\t* generated/product_i4.c: Regenerated.\n\t* generated/product_i8.c: Regenerated.\n\t* generated/product_r10.c: Regenerated.\n\t* generated/product_r16.c: Regenerated.\n\t* generated/product_r4.c: Regenerated.\n\t* generated/product_r8.c: Regenerated.\n\t* generated/sum_c10.c: Regenerated.\n\t* generated/sum_c16.c: Regenerated.\n\t* generated/sum_c4.c: Regenerated.\n\t* generated/sum_c8.c: Regenerated.\n\t* generated/sum_i1.c: Regenerated.\n\t* generated/sum_i16.c: Regenerated.\n\t* generated/sum_i2.c: Regenerated.\n\t* generated/sum_i4.c: Regenerated.\n\t* generated/sum_i8.c: Regenerated.\n\t* generated/sum_r10.c: Regenerated.\n\t* generated/sum_r16.c: Regenerated.\n\t* generated/sum_r4.c: Regenerated.\n\t* generated/sum_r8.c: Regenerated.\n\n2008-04-30  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/35993\n\t* gfortran.dg/intrinsic_product_1.f90:  New test case.\n\nFrom-SVN: r134830", "tree": {"sha": "cef9f4a283e613e49703c565f78cc63beb5c48bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cef9f4a283e613e49703c565f78cc63beb5c48bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/802367d7c9052b80798421c6452f1361b75bcf32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/802367d7c9052b80798421c6452f1361b75bcf32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/802367d7c9052b80798421c6452f1361b75bcf32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/802367d7c9052b80798421c6452f1361b75bcf32/comments", "author": null, "committer": null, "parents": [{"sha": "9eec643d3658e78737ec8078ce5d0726a19dbe37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eec643d3658e78737ec8078ce5d0726a19dbe37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eec643d3658e78737ec8078ce5d0726a19dbe37"}], "stats": {"total": 12811, "additions": 10435, "deletions": 2376}, "files": [{"sha": "53978ccd0f5b1024da167c6935c5bab433fe7b44", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -1,3 +1,8 @@\n+2008-04-30  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/35993\n+\t* gfortran.dg/intrinsic_product_1.f90:  New test case.\n+\n 2008-04-30  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/14847"}, {"sha": "34d34fe81581c0bfe3cff0d8df079aa70772db6a", "filename": "gcc/testsuite/gfortran.dg/intrinsic_product_1.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_product_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_product_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_product_1.f90?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+! PR 35993 - some intrinsics with mask = .false. didn't set\n+! the whole return array for multi-dimensional arrays.\n+! Test case adapted from Dick Hendrickson.\n+\n+      program try\n+\n+      call       ga3019(  1,  2,  3,  4)\n+      end program\n+\n+      SUBROUTINE GA3019(nf1,nf2,nf3,nf4)\n+      INTEGER IDA(NF2,NF3)\n+      INTEGER IDA1(NF2,NF4,NF3)\n+\n+      ida1 = 3\n+\n+      ida = -3\n+      IDA(NF1:NF2,NF1:NF3) = PRODUCT(IDA1,NF2, NF1 .LT. 0)  !fails\n+      if (any(ida /= 1)) call abort\n+\n+      ida = -3\n+      IDA(NF1:NF2,NF1:NF3) = PRODUCT(IDA1,NF2, .false. )    !fails\n+      if (any(ida /= 1)) call abort\n+\n+      ida = -3\n+      IDA(NF1:NF2,NF1:NF3) = PRODUCT(IDA1,NF2, ida1 .eq. 137 )    !works\n+      if (any(ida /= 1)) call abort\n+\n+      END SUBROUTINE"}, {"sha": "0ee684858ad57b0ba82077fdc52cfd90e4e2d7d6", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -1,3 +1,108 @@\n+2008-04-30  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/35993\n+\t* ifunction.m4 (SCALAR_ARRAY_FUNCTION):  Use correct\n+\timplementation for multi-dimensional return arrays when\n+\tthe mask is .false.\n+\t* generated/maxloc1_16_i1.c: Regenerated.\n+\t* generated/maxloc1_16_i16.c: Regenerated.\n+\t* generated/maxloc1_16_i2.c: Regenerated.\n+\t* generated/maxloc1_16_i4.c: Regenerated.\n+\t* generated/maxloc1_16_i8.c: Regenerated.\n+\t* generated/maxloc1_16_r10.c: Regenerated.\n+\t* generated/maxloc1_16_r16.c: Regenerated.\n+\t* generated/maxloc1_16_r4.c: Regenerated.\n+\t* generated/maxloc1_16_r8.c: Regenerated.\n+\t* generated/maxloc1_4_i1.c: Regenerated.\n+\t* generated/maxloc1_4_i16.c: Regenerated.\n+\t* generated/maxloc1_4_i2.c: Regenerated.\n+\t* generated/maxloc1_4_i4.c: Regenerated.\n+\t* generated/maxloc1_4_i8.c: Regenerated.\n+\t* generated/maxloc1_4_r10.c: Regenerated.\n+\t* generated/maxloc1_4_r16.c: Regenerated.\n+\t* generated/maxloc1_4_r4.c: Regenerated.\n+\t* generated/maxloc1_4_r8.c: Regenerated.\n+\t* generated/maxloc1_8_i1.c: Regenerated.\n+\t* generated/maxloc1_8_i16.c: Regenerated.\n+\t* generated/maxloc1_8_i2.c: Regenerated.\n+\t* generated/maxloc1_8_i4.c: Regenerated.\n+\t* generated/maxloc1_8_i8.c: Regenerated.\n+\t* generated/maxloc1_8_r10.c: Regenerated.\n+\t* generated/maxloc1_8_r16.c: Regenerated.\n+\t* generated/maxloc1_8_r4.c: Regenerated.\n+\t* generated/maxloc1_8_r8.c: Regenerated.\n+\t* generated/maxval_i1.c: Regenerated.\n+\t* generated/maxval_i16.c: Regenerated.\n+\t* generated/maxval_i2.c: Regenerated.\n+\t* generated/maxval_i4.c: Regenerated.\n+\t* generated/maxval_i8.c: Regenerated.\n+\t* generated/maxval_r10.c: Regenerated.\n+\t* generated/maxval_r16.c: Regenerated.\n+\t* generated/maxval_r4.c: Regenerated.\n+\t* generated/maxval_r8.c: Regenerated.\n+\t* generated/minloc1_16_i1.c: Regenerated.\n+\t* generated/minloc1_16_i16.c: Regenerated.\n+\t* generated/minloc1_16_i2.c: Regenerated.\n+\t* generated/minloc1_16_i4.c: Regenerated.\n+\t* generated/minloc1_16_i8.c: Regenerated.\n+\t* generated/minloc1_16_r10.c: Regenerated.\n+\t* generated/minloc1_16_r16.c: Regenerated.\n+\t* generated/minloc1_16_r4.c: Regenerated.\n+\t* generated/minloc1_16_r8.c: Regenerated.\n+\t* generated/minloc1_4_i1.c: Regenerated.\n+\t* generated/minloc1_4_i16.c: Regenerated.\n+\t* generated/minloc1_4_i2.c: Regenerated.\n+\t* generated/minloc1_4_i4.c: Regenerated.\n+\t* generated/minloc1_4_i8.c: Regenerated.\n+\t* generated/minloc1_4_r10.c: Regenerated.\n+\t* generated/minloc1_4_r16.c: Regenerated.\n+\t* generated/minloc1_4_r4.c: Regenerated.\n+\t* generated/minloc1_4_r8.c: Regenerated.\n+\t* generated/minloc1_8_i1.c: Regenerated.\n+\t* generated/minloc1_8_i16.c: Regenerated.\n+\t* generated/minloc1_8_i2.c: Regenerated.\n+\t* generated/minloc1_8_i4.c: Regenerated.\n+\t* generated/minloc1_8_i8.c: Regenerated.\n+\t* generated/minloc1_8_r10.c: Regenerated.\n+\t* generated/minloc1_8_r16.c: Regenerated.\n+\t* generated/minloc1_8_r4.c: Regenerated.\n+\t* generated/minloc1_8_r8.c: Regenerated.\n+\t* generated/minval_i1.c: Regenerated.\n+\t* generated/minval_i16.c: Regenerated.\n+\t* generated/minval_i2.c: Regenerated.\n+\t* generated/minval_i4.c: Regenerated.\n+\t* generated/minval_i8.c: Regenerated.\n+\t* generated/minval_r10.c: Regenerated.\n+\t* generated/minval_r16.c: Regenerated.\n+\t* generated/minval_r4.c: Regenerated.\n+\t* generated/minval_r8.c: Regenerated.\n+\t* generated/product_c10.c: Regenerated.\n+\t* generated/product_c16.c: Regenerated.\n+\t* generated/product_c4.c: Regenerated.\n+\t* generated/product_c8.c: Regenerated.\n+\t* generated/product_i1.c: Regenerated.\n+\t* generated/product_i16.c: Regenerated.\n+\t* generated/product_i2.c: Regenerated.\n+\t* generated/product_i4.c: Regenerated.\n+\t* generated/product_i8.c: Regenerated.\n+\t* generated/product_r10.c: Regenerated.\n+\t* generated/product_r16.c: Regenerated.\n+\t* generated/product_r4.c: Regenerated.\n+\t* generated/product_r8.c: Regenerated.\n+\t* generated/sum_c10.c: Regenerated.\n+\t* generated/sum_c16.c: Regenerated.\n+\t* generated/sum_c4.c: Regenerated.\n+\t* generated/sum_c8.c: Regenerated.\n+\t* generated/sum_i1.c: Regenerated.\n+\t* generated/sum_i16.c: Regenerated.\n+\t* generated/sum_i2.c: Regenerated.\n+\t* generated/sum_i4.c: Regenerated.\n+\t* generated/sum_i8.c: Regenerated.\n+\t* generated/sum_r10.c: Regenerated.\n+\t* generated/sum_r16.c: Regenerated.\n+\t* generated/sum_r4.c: Regenerated.\n+\t* generated/sum_r8.c: Regenerated.\n+\n 2008-04-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR libfortran/35960"}, {"sha": "6e4153c3eb99ce2d71cae5313f230f1a9b334174", "filename": "libgfortran/generated/maxloc1_16_i1.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_16_i1 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "b4fd55d635022661753d946911141ce09ffb4de6", "filename": "libgfortran/generated/maxloc1_16_i16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_16_i16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "483b90372eee4fb06f81c5f11d2f93dbafc2caa9", "filename": "libgfortran/generated/maxloc1_16_i2.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_16_i2 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "69d35d75556d90520050bc4d047686eef7440b51", "filename": "libgfortran/generated/maxloc1_16_i4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_16_i4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "54d016c2d514df60862899da11554a9c408d3186", "filename": "libgfortran/generated/maxloc1_16_i8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_16_i8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "10ea86849e5cc84a2bdfdc5c590d6455ce0bf502", "filename": "libgfortran/generated/maxloc1_16_r10.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_16_r10 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "54b2aeb90eb317f0899f7b77baa551606de995f7", "filename": "libgfortran/generated/maxloc1_16_r16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_16_r16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "f9712e6082ae3c800909f37e8c3aa7faa500caea", "filename": "libgfortran/generated/maxloc1_16_r4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_16_r4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "1e836288439494757943b0e5cfcf4b76f84a2386", "filename": "libgfortran/generated/maxloc1_16_r8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_16_r8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "271ef38e3f234cba1515c16c84893a259ac845d4", "filename": "libgfortran/generated/maxloc1_4_i1.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_4_i1 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "627e36030c451ab30646c4b79665c375ba75df06", "filename": "libgfortran/generated/maxloc1_4_i16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_4_i16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "cf42ddfc7082193864d827a2c2197db197caad5c", "filename": "libgfortran/generated/maxloc1_4_i2.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_4_i2 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "a26180f4e7f435124a6b528afd22d11a0faa04f0", "filename": "libgfortran/generated/maxloc1_4_i4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_4_i4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "40f2c36a93d9145ecad65f4aeeda9b4f4c166547", "filename": "libgfortran/generated/maxloc1_4_i8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_4_i8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "75497022d7604ec7a400356c3f3a40be179522bd", "filename": "libgfortran/generated/maxloc1_4_r10.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_4_r10 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "3ed0d96671e413ed306998e26f3bfbf942499420", "filename": "libgfortran/generated/maxloc1_4_r16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_4_r16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "24ecf9a40e66c947b2a7788c402e3796acad66d7", "filename": "libgfortran/generated/maxloc1_4_r4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_4_r4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "9a695da2b2980f7c80bfdc7bd54b7332376cf5c1", "filename": "libgfortran/generated/maxloc1_4_r8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_4_r8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "489ed11a8fcd78bd84142e3080cd3ea7adf260b9", "filename": "libgfortran/generated/maxloc1_8_i1.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_8_i1 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "9f8c7ad01ffee01ddbd6c5329b39779454a2b121", "filename": "libgfortran/generated/maxloc1_8_i16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_8_i16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "28e0163919898bd33d0c14bc342b5921b9158053", "filename": "libgfortran/generated/maxloc1_8_i2.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_8_i2 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "82038dc474574e1efa95441afdb00e12fae342b6", "filename": "libgfortran/generated/maxloc1_8_i4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_8_i4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "c7301eab6c12fd30778a307f7b66cace3c0ded34", "filename": "libgfortran/generated/maxloc1_8_i8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_8_i8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "d83600d60199240966c74fb0d3aaef8f57e057c4", "filename": "libgfortran/generated/maxloc1_8_r10.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_8_r10 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "6d45297df7727929309885aac1dff4c64dda6709", "filename": "libgfortran/generated/maxloc1_8_r16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_8_r16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "470d73c1ea3ed30d27531679e5f83b42a3bc3375", "filename": "libgfortran/generated/maxloc1_8_r4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_8_r4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "7003594e00cbef30926282a34162fbaaa575954f", "filename": "libgfortran/generated/maxloc1_8_r8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ smaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxloc1_8_r8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "9468e4aad4a8ebe898c2f39135bc02ad91228613", "filename": "libgfortran/generated/maxval_i1.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i1.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -417,51 +417,131 @@ smaxval_i1 (gfc_array_i1 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_1 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_1 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxval_i1 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_1) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXVAL intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = (-GFC_INTEGER_1_HUGE-1) ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = (-GFC_INTEGER_1_HUGE-1);\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "de2cac8c11300a7bf252c64bb33e8229995401e1", "filename": "libgfortran/generated/maxval_i16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -417,51 +417,131 @@ smaxval_i16 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxval_i16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXVAL intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = (-GFC_INTEGER_16_HUGE-1) ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = (-GFC_INTEGER_16_HUGE-1);\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "818fc29e8896cfa3d66b7f0bf34a1bd382ec797a", "filename": "libgfortran/generated/maxval_i2.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i2.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -417,51 +417,131 @@ smaxval_i2 (gfc_array_i2 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_2 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_2 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxval_i2 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_2) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXVAL intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = (-GFC_INTEGER_2_HUGE-1) ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = (-GFC_INTEGER_2_HUGE-1);\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "e5289f1e1d8272eb0e0ea59bac7e0f604c365b65", "filename": "libgfortran/generated/maxval_i4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -417,51 +417,131 @@ smaxval_i4 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxval_i4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXVAL intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = (-GFC_INTEGER_4_HUGE-1) ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = (-GFC_INTEGER_4_HUGE-1);\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "d05737d66f1e1a6714fb296bbddb1a3425ee6327", "filename": "libgfortran/generated/maxval_i8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -417,51 +417,131 @@ smaxval_i8 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxval_i8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXVAL intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = (-GFC_INTEGER_8_HUGE-1) ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = (-GFC_INTEGER_8_HUGE-1);\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "921ad487d4748b8136d0fe33de72ab2f2c910c93", "filename": "libgfortran/generated/maxval_r10.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r10.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -417,51 +417,131 @@ smaxval_r10 (gfc_array_r10 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_10 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_REAL_10 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxval_r10 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_REAL_10) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_10) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXVAL intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = -GFC_REAL_10_HUGE ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = -GFC_REAL_10_HUGE;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "15bdd7e215a37ae7f5e26cb2d946cce2ac4e5883", "filename": "libgfortran/generated/maxval_r16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -417,51 +417,131 @@ smaxval_r16 (gfc_array_r16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_REAL_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxval_r16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_REAL_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXVAL intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = -GFC_REAL_16_HUGE ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = -GFC_REAL_16_HUGE;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "f3470e8b951c7148a3857766a5dd7b38c4a2b3dc", "filename": "libgfortran/generated/maxval_r4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -417,51 +417,131 @@ smaxval_r4 (gfc_array_r4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_REAL_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxval_r4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_REAL_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXVAL intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = -GFC_REAL_4_HUGE ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = -GFC_REAL_4_HUGE;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "b5d7f3c0d521c3a6a4ceb1ff5192ec2342fec9d6", "filename": "libgfortran/generated/maxval_r8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fmaxval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -417,51 +417,131 @@ smaxval_r8 (gfc_array_r8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_REAL_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       maxval_r8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_REAL_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MAXVAL intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = -GFC_REAL_8_HUGE ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = -GFC_REAL_8_HUGE;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "8a20d7b453c5996f100f12a8f1b5b1ac7846c4ae", "filename": "libgfortran/generated/minloc1_16_i1.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i1.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_16_i1 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "f0c5b84384afdb268b2248e36fd54f4ab703ac6e", "filename": "libgfortran/generated/minloc1_16_i16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_16_i16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "234f364880abecffb2145f9d3606410f0d7bc1b4", "filename": "libgfortran/generated/minloc1_16_i2.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i2.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_16_i2 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "2b55cff40b861747046c43325ce51b5e2d0a4e59", "filename": "libgfortran/generated/minloc1_16_i4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_16_i4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "2e2e89407c0177829fcdaad94e88a5f4924371c8", "filename": "libgfortran/generated/minloc1_16_i8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_16_i8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "dcf291f64537784705498f50ef83db1d12e1f0e3", "filename": "libgfortran/generated/minloc1_16_r10.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r10.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_16_r10 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "eb496134df7ea0162eaa15f1e3d42df4c30b9516", "filename": "libgfortran/generated/minloc1_16_r16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_16_r16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "dd39b5dd02ce99bdca4fb73a5e0780fb6158bf5a", "filename": "libgfortran/generated/minloc1_16_r4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_16_r4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "e31410f0cecedb2f68d8c9f9711303ffc6c34926", "filename": "libgfortran/generated/minloc1_16_r8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_16_r8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "5111c7d6f46045cbba9ca6a1bd9101ba19488f40", "filename": "libgfortran/generated/minloc1_4_i1.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i1.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_4_i1 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "db898320157db48b82f0f9c86b72748f963a219c", "filename": "libgfortran/generated/minloc1_4_i16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_4_i16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "3e1448dc50f265fce6c6f98ebdbcc372d03976ce", "filename": "libgfortran/generated/minloc1_4_i2.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i2.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_4_i2 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "b66c23edfc1ecb4c5e180f6b5781fade3aa59002", "filename": "libgfortran/generated/minloc1_4_i4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_4_i4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "1eb3c4cbcf01f8aba7244cc75d21dcaec8fcfae5", "filename": "libgfortran/generated/minloc1_4_i8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_4_i8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "a224fd3ef0576949198367e78944aea076887ea6", "filename": "libgfortran/generated/minloc1_4_r10.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r10.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_4_r10 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "404be416cff7059fb8ffdb70ac4815f28c02d945", "filename": "libgfortran/generated/minloc1_4_r16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_4_r16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "4d9844ce633bde22b425ad9d662ebe9f0bbfd84c", "filename": "libgfortran/generated/minloc1_4_r4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_4_r4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "fc9b0aea239d286bbf1e19fe0423042502f38e47", "filename": "libgfortran/generated/minloc1_4_r8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_4_r8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "b0fbe0d946ec48ffe34b8c7234424564b9d04603", "filename": "libgfortran/generated/minloc1_8_i1.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i1.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_8_i1 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "4c4a76c75de0fd5de7590aa15225200672681810", "filename": "libgfortran/generated/minloc1_8_i16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_8_i16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "f18cd2aea79db8fac6d9ae728b5abb7e920de7bb", "filename": "libgfortran/generated/minloc1_8_i2.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i2.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_8_i2 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "758249e063151aab1b161e8b965a71f446f8f413", "filename": "libgfortran/generated/minloc1_8_i4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_8_i4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "245522e579dc0063491ebb264d3694012e7c0963", "filename": "libgfortran/generated/minloc1_8_i8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_8_i8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "ae8035ee0619c86e747415e62ab023a3523d7d6e", "filename": "libgfortran/generated/minloc1_8_r10.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r10.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_8_r10 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "af4e2ea41b22d86af33170d2498220d261009940", "filename": "libgfortran/generated/minloc1_8_r16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_8_r16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "3f2b2e1dd4e7dc512eaf8c479d0c0361c69bc4fe", "filename": "libgfortran/generated/minloc1_8_r4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_8_r4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "5e00272ec9bfcd05c1d5ef16bcf1df929df56fd1", "filename": "libgfortran/generated/minloc1_8_r8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -428,51 +428,131 @@ sminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minloc1_8_r8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINLOC intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "3815d44f8df08584604f8344250163553059407b", "filename": "libgfortran/generated/minval_i1.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i1.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -417,51 +417,131 @@ sminval_i1 (gfc_array_i1 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_1 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_1 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minval_i1 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_1) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINVAL intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = GFC_INTEGER_1_HUGE ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = GFC_INTEGER_1_HUGE;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "b8b99d33529f2a23327902d6ead7cc07ee058f91", "filename": "libgfortran/generated/minval_i16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -417,51 +417,131 @@ sminval_i16 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minval_i16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINVAL intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = GFC_INTEGER_16_HUGE ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = GFC_INTEGER_16_HUGE;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "1e83efd024ca5680b2e7010718b511c7fe7298b2", "filename": "libgfortran/generated/minval_i2.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i2.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -417,51 +417,131 @@ sminval_i2 (gfc_array_i2 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_2 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_2 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minval_i2 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_2) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINVAL intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = GFC_INTEGER_2_HUGE ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = GFC_INTEGER_2_HUGE;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "a40fc2cfd77d03aa6bc660cd6d1bcecbccd5b155", "filename": "libgfortran/generated/minval_i4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -417,51 +417,131 @@ sminval_i4 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minval_i4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINVAL intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = GFC_INTEGER_4_HUGE ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = GFC_INTEGER_4_HUGE;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "af37f4369af0b0a9945c41686c2149338f128599", "filename": "libgfortran/generated/minval_i8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -417,51 +417,131 @@ sminval_i8 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minval_i8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINVAL intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = GFC_INTEGER_8_HUGE ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = GFC_INTEGER_8_HUGE;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "829c630037bfa90e6aa01bb448a9cf6c41b44f69", "filename": "libgfortran/generated/minval_r10.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r10.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -417,51 +417,131 @@ sminval_r10 (gfc_array_r10 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_10 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_REAL_10 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minval_r10 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_REAL_10) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_10) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINVAL intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = GFC_REAL_10_HUGE ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = GFC_REAL_10_HUGE;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "c3797c7f537bb274352829477b253ed1b3218821", "filename": "libgfortran/generated/minval_r16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -417,51 +417,131 @@ sminval_r16 (gfc_array_r16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_REAL_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minval_r16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_REAL_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINVAL intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = GFC_REAL_16_HUGE ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = GFC_REAL_16_HUGE;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "c8c8fd518090f80ce110ecaf90fbd2d04160561c", "filename": "libgfortran/generated/minval_r4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -417,51 +417,131 @@ sminval_r4 (gfc_array_r4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_REAL_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minval_r4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_REAL_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINVAL intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = GFC_REAL_4_HUGE ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = GFC_REAL_4_HUGE;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "e404b170b915d606c90f9ace10cf6775440e8965", "filename": "libgfortran/generated/minval_r8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fminval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -417,51 +417,131 @@ sminval_r8 (gfc_array_r8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_REAL_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       minval_r8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_REAL_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in MINVAL intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = GFC_REAL_8_HUGE ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = GFC_REAL_8_HUGE;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "0366544a205fd7e67df11346c9d91455491bff1e", "filename": "libgfortran/generated/product_c10.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c10.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ sproduct_c10 (gfc_array_c10 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_COMPLEX_10 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_COMPLEX_10 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       product_c10 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_COMPLEX_10) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_COMPLEX_10) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 1 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 1;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "c4612cf2059d8d1186a83c7d5c114b17c8b6050b", "filename": "libgfortran/generated/product_c16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ sproduct_c16 (gfc_array_c16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_COMPLEX_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_COMPLEX_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       product_c16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_COMPLEX_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_COMPLEX_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 1 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 1;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "53c7f80b269c19711fbaacda5761aad4069a08c8", "filename": "libgfortran/generated/product_c4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ sproduct_c4 (gfc_array_c4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_COMPLEX_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_COMPLEX_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       product_c4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_COMPLEX_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_COMPLEX_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 1 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 1;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "812fb3ba38e65990cde43d1d87c603eab9ec991a", "filename": "libgfortran/generated/product_c8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ sproduct_c8 (gfc_array_c8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_COMPLEX_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_COMPLEX_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       product_c8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_COMPLEX_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_COMPLEX_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 1 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 1;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "72b894f89c41370416e3db898afbae7ee701f7a5", "filename": "libgfortran/generated/product_i1.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i1.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ sproduct_i1 (gfc_array_i1 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_1 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_1 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       product_i1 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_1) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 1 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 1;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "e04293179a84c8f7f0afdbca03ec1e251a9f077e", "filename": "libgfortran/generated/product_i16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ sproduct_i16 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       product_i16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 1 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 1;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "af3da57cf979652efaef7ba4d252d417b8300daf", "filename": "libgfortran/generated/product_i2.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i2.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ sproduct_i2 (gfc_array_i2 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_2 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_2 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       product_i2 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_2) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 1 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 1;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "75028e57980a249e2325511ca590921ed7775ae7", "filename": "libgfortran/generated/product_i4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ sproduct_i4 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       product_i4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 1 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 1;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "1fc446cf2a0db968f1cdef3ec68c3ecd145342aa", "filename": "libgfortran/generated/product_i8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ sproduct_i8 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       product_i8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 1 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 1;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "7956b30958d7534879e39638fcc482304fe72cdc", "filename": "libgfortran/generated/product_r10.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r10.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ sproduct_r10 (gfc_array_r10 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_10 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_REAL_10 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       product_r10 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_REAL_10) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_10) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 1 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 1;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "9cfd8df0213aa300a4834921b5f03249757f96c2", "filename": "libgfortran/generated/product_r16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ sproduct_r16 (gfc_array_r16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_REAL_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       product_r16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_REAL_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 1 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 1;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "276d91ae3fdee03adc72ed4b71c70a47f873d3a6", "filename": "libgfortran/generated/product_r4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ sproduct_r4 (gfc_array_r4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_REAL_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       product_r4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_REAL_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 1 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 1;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "2c07381736a8e0051c367585b6aa2d33a072803f", "filename": "libgfortran/generated/product_r8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fproduct_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ sproduct_r8 (gfc_array_r8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_REAL_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       product_r8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_REAL_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in PRODUCT intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 1 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 1;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "6c2228917533c5b88cca5c60779f7a58e49a7a10", "filename": "libgfortran/generated/sum_c10.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c10.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ ssum_c10 (gfc_array_c10 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_COMPLEX_10 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_COMPLEX_10 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       sum_c10 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_COMPLEX_10) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_COMPLEX_10) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in SUM intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "203c483619ae65ce733d3eb7ef8fdd8816113bf5", "filename": "libgfortran/generated/sum_c16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ ssum_c16 (gfc_array_c16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_COMPLEX_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_COMPLEX_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       sum_c16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_COMPLEX_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_COMPLEX_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in SUM intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "4a91bb2631a682253dfd81538b44f8790180d735", "filename": "libgfortran/generated/sum_c4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ ssum_c4 (gfc_array_c4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_COMPLEX_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_COMPLEX_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       sum_c4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_COMPLEX_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_COMPLEX_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in SUM intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "f877d09413535cfc9507df23435a1d9fb539727c", "filename": "libgfortran/generated/sum_c8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ ssum_c8 (gfc_array_c8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_COMPLEX_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_COMPLEX_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       sum_c8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_COMPLEX_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_COMPLEX_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in SUM intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "de46086a775631ac40c05e27bac0111119e7f51b", "filename": "libgfortran/generated/sum_i1.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i1.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ ssum_i1 (gfc_array_i1 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_1 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_1 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       sum_i1 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_1) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in SUM intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "b7fc6e1a1704b9db0535933edc7d4fcbf5a0e678", "filename": "libgfortran/generated/sum_i16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ ssum_i16 (gfc_array_i16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       sum_i16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in SUM intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "f7b85d7b6c8d35837b1a2f8d5fafb5eddeac8839", "filename": "libgfortran/generated/sum_i2.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i2.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ ssum_i2 (gfc_array_i2 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_2 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_2 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       sum_i2 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_2) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in SUM intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "04849b5bcf18ab286af82968c5fa0c389ea486e3", "filename": "libgfortran/generated/sum_i4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ ssum_i4 (gfc_array_i4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       sum_i4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in SUM intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "bf65615376b65c45c9552cd437eac9f63eb49b7d", "filename": "libgfortran/generated/sum_i8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ ssum_i8 (gfc_array_i8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_INTEGER_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       sum_i8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in SUM intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "deefd30870a69f6941733c7d296ae299b39053e9", "filename": "libgfortran/generated/sum_r10.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r10.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ ssum_r10 (gfc_array_r10 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_10 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_REAL_10 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       sum_r10 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_REAL_10) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_10) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in SUM intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "ee365f74d15c8274fa039d750da53229aad81f4f", "filename": "libgfortran/generated/sum_r16.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r16.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ ssum_r16 (gfc_array_r16 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_16 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_REAL_16 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       sum_r16 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_REAL_16) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in SUM intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "07f43397b7be57ca210b69b50e73fff8bf3d97bf", "filename": "libgfortran/generated/sum_r4.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r4.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ ssum_r4 (gfc_array_r4 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_4 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_REAL_4 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       sum_r4 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_REAL_4) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in SUM intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "f83c683347dd1b99b05ee4aecb1971ab47406bd8", "filename": "libgfortran/generated/sum_r8.c", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fgenerated%2Fsum_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r8.c?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -416,51 +416,131 @@ ssum_r8 (gfc_array_r8 * const restrict retarray,\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_8 * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  GFC_REAL_8 *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       sum_r8 (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (GFC_REAL_8) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" SUM intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in SUM intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" SUM intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = 0 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }\n \n #endif"}, {"sha": "5ab2952a49127baee4c7480363702e46854681be", "filename": "libgfortran/m4/ifunction.m4", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fm4%2Fifunction.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802367d7c9052b80798421c6452f1361b75bcf32/libgfortran%2Fm4%2Fifunction.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifunction.m4?ref=802367d7c9052b80798421c6452f1361b75bcf32", "patch": "@@ -398,51 +398,131 @@ void\n \tconst index_type * const restrict pdim, \n \tGFC_LOGICAL_4 * mask)\n {\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  rtype_name * restrict dest;\n   index_type rank;\n   index_type n;\n-  index_type dstride;\n-  rtype_name *dest;\n+  index_type dim;\n+\n \n   if (*mask)\n     {\n       name`'rtype_qual`_'atype_code (retarray, array, pdim);\n       return;\n     }\n-    rank = GFC_DESCRIPTOR_RANK (array);\n-  if (rank <= 0)\n-    runtime_error (\"Rank of array needs to be > 0\");\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = array->dim[n].stride;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = array->dim[n + 1].stride;\n+      extent[n] =\n+        array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] <= 0)\n+        extent[n] = 0;\n+    }\n \n   if (retarray->data == NULL)\n     {\n-      retarray->dim[0].lbound = 0;\n-      retarray->dim[0].ubound = rank-1;\n-      retarray->dim[0].stride = 1;\n-      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      size_t alloc_size;\n+\n+      for (n = 0; n < rank; n++)\n+        {\n+          retarray->dim[n].lbound = 0;\n+          retarray->dim[n].ubound = extent[n]-1;\n+          if (n == 0)\n+            retarray->dim[n].stride = 1;\n+          else\n+            retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n+        }\n+\n       retarray->offset = 0;\n-      retarray->data = internal_malloc_size (sizeof (rtype_name) * rank);\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (rtype_name) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" u_name intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n       if (compile_options.bounds_check)\n \t{\n-\t  int ret_rank;\n-\t  index_type ret_extent;\n-\n-\t  ret_rank = GFC_DESCRIPTOR_RANK (retarray);\n-\t  if (ret_rank != 1)\n-\t    runtime_error (\"rank of return array in u_name intrinsic\"\n-\t\t\t   \" should be 1, is %ld\", (long int) ret_rank);\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n \n-\t  ret_extent = retarray->dim[0].ubound + 1 - retarray->dim[0].lbound;\n-\t    if (ret_extent != rank)\n-\t      runtime_error (\"dimension of return array incorrect\");\n+\t      ret_extent = retarray->dim[n].ubound + 1\n+\t\t- retarray->dim[n].lbound;\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" u_name intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n \t}\n     }\n-    dstride = retarray->dim[0].stride;\n-    dest = retarray->data;\n \n-    for (n = 0; n < rank; n++)\n-      dest[n * dstride] = $1 ;\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = retarray->dim[n].stride;\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = '$1`;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+\t  /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= dstride[n] * extent[n];\n+          n++;\n+          if (n == rank)\n+\t    return;\n+          else\n+            {\n+              count[n]++;\n+              dest += dstride[n];\n+            }\n+      \t}\n+    }\n }')dnl\n define(ARRAY_FUNCTION,\n `START_ARRAY_FUNCTION"}]}