{"sha": "b84a3874349ccc870c3d278b874d43763efbc9bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg0YTM4NzQzNDljY2M4NzBjM2QyNzhiODc0ZDQzNzYzZWZiYzliYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-04-26T07:40:12Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-04-26T07:40:12Z"}, "message": "c-common.c (fix_string_type): Split out of ...\n\n        * c-common.c (fix_string_type): Split out of ...\n        (combine_strings): ... here.  Take a varray, not a tree list.\n        (c_expand_builtin_printf): Use fix_string_type.\n        * c-common.h: Update decls.\n        * c-parse.in (string): Remove.  Update all uses to use STRING\n        instead, and not call combine_strings.\n        (yylexstring): New.\n        (_yylex): Use it.\n        * c-typeck.c (simple_asm_stmt): Don't call combine_strings.\n        (build_asm_stmt): Likewise.\n        * objc/objc-act.c (my_build_string): Use fix_string_type.\n        (build_objc_string_object): Build varray for combine_strings.\n\n        * parse.y (string): Remove.  Update all uses to use STRING\n        instead, and not call combine_strings.\n        * rtti.c (tinfo_name): Use fix_string_type.\n        * semantics.c (finish_asm_stmt): Don't call combine_strings.\n        * spew.c (yylexstring): New.\n        (read_token): Use it.\n\n\t* g++.dg/parse/concat1.C: New.\n\t* gcc.dg/concat2.c: New.\n\nFrom-SVN: r52790", "tree": {"sha": "f89357e36b49124025bfcd5e54bb2778e043f4e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f89357e36b49124025bfcd5e54bb2778e043f4e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b84a3874349ccc870c3d278b874d43763efbc9bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b84a3874349ccc870c3d278b874d43763efbc9bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b84a3874349ccc870c3d278b874d43763efbc9bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b84a3874349ccc870c3d278b874d43763efbc9bb/comments", "author": null, "committer": null, "parents": [{"sha": "4d7ea4fc78df072028a41875a967d49f9b4c9dea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d7ea4fc78df072028a41875a967d49f9b4c9dea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d7ea4fc78df072028a41875a967d49f9b4c9dea"}], "stats": {"total": 509, "additions": 322, "deletions": 187}, "files": [{"sha": "667ec4f77d8f409e887812419e5a5b21dab014ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b84a3874349ccc870c3d278b874d43763efbc9bb", "patch": "@@ -1,3 +1,19 @@\n+2002-04-26  Richard Henderson  <rth@redhat.com>\n+\n+\tPR c/3581\n+\t* c-common.c (fix_string_type): Split out of ...\n+\t(combine_strings): ... here.  Take a varray, not a tree list.\n+\t(c_expand_builtin_printf): Use fix_string_type.\n+\t* c-common.h: Update decls.\n+\t* c-parse.in (string): Remove.  Update all uses to use STRING\n+\tinstead, and not call combine_strings.\n+\t(yylexstring): New.\n+\t(_yylex): Use it.\n+\t* c-typeck.c (simple_asm_stmt): Don't call combine_strings.\n+\t(build_asm_stmt): Likewise.\n+\t* objc/objc-act.c (my_build_string): Use fix_string_type.\n+\t(build_objc_string_object): Build varray for combine_strings.\n+\n 2002-04-26  Bo Thorsen  <bo@suse.co.uk>\n \n \t* config/i386/linux64.h (MD_FALLBACK_FRAME_STATE_FOR): Define for"}, {"sha": "86fc75938178e13726e3eec8417c93ccbe2317c4", "filename": "gcc/c-common.c", "status": "modified", "additions": 113, "deletions": 96, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=b84a3874349ccc870c3d278b874d43763efbc9bb", "patch": "@@ -683,105 +683,17 @@ fname_decl (rid, id)\n   return decl;\n }\n \n-/* Given a chain of STRING_CST nodes,\n-   concatenate them into one STRING_CST\n-   and give it a suitable array-of-chars data type.  */\n+/* Given a STRING_CST, give it a suitable array-of-chars data type.  */\n \n tree\n-combine_strings (strings)\n-     tree strings;\n+fix_string_type (value)\n+      tree value;\n {\n-  tree value, t;\n-  int length = 1;\n-  int wide_length = 0;\n-  int wide_flag = 0;\n-  int wchar_bytes = TYPE_PRECISION (wchar_type_node) / BITS_PER_UNIT;\n-  int nchars;\n+  const int wchar_bytes = TYPE_PRECISION (wchar_type_node) / BITS_PER_UNIT;\n+  const int wide_flag = TREE_TYPE (value) == wchar_array_type_node;\n   const int nchars_max = flag_isoc99 ? 4095 : 509;\n-\n-  if (TREE_CHAIN (strings))\n-    {\n-      /* More than one in the chain, so concatenate.  */\n-      char *p, *q;\n-\n-      /* Don't include the \\0 at the end of each substring,\n-\t except for the last one.\n-\t Count wide strings and ordinary strings separately.  */\n-      for (t = strings; t; t = TREE_CHAIN (t))\n-\t{\n-\t  if (TREE_TYPE (t) == wchar_array_type_node)\n-\t    {\n-\t      wide_length += (TREE_STRING_LENGTH (t) - wchar_bytes);\n-\t      wide_flag = 1;\n-\t    }\n-\t  else\n-\t    {\n-\t      length += (TREE_STRING_LENGTH (t) - 1);\n-\t      if (C_ARTIFICIAL_STRING_P (t) && !in_system_header)\n-\t\twarning (\"concatenation of string literals with __FUNCTION__ is deprecated.  This feature will be removed in future\"); \n-\t    }\n-\t}\n-\n-      /* If anything is wide, the non-wides will be converted,\n-\t which makes them take more space.  */\n-      if (wide_flag)\n-\tlength = length * wchar_bytes + wide_length;\n-\n-      p = alloca (length);\n-\n-      /* Copy the individual strings into the new combined string.\n-\t If the combined string is wide, convert the chars to ints\n-\t for any individual strings that are not wide.  */\n-\n-      q = p;\n-      for (t = strings; t; t = TREE_CHAIN (t))\n-\t{\n-\t  int len = (TREE_STRING_LENGTH (t)\n-\t\t     - ((TREE_TYPE (t) == wchar_array_type_node)\n-\t\t\t? wchar_bytes : 1));\n-\t  if ((TREE_TYPE (t) == wchar_array_type_node) == wide_flag)\n-\t    {\n-\t      memcpy (q, TREE_STRING_POINTER (t), len);\n-\t      q += len;\n-\t    }\n-\t  else\n-\t    {\n-\t      int i, j;\n-\t      for (i = 0; i < len; i++)\n-\t\t{\n-\t\t  if (BYTES_BIG_ENDIAN)\n-\t\t    {\n-\t\t      for (j=0; j<(WCHAR_TYPE_SIZE / BITS_PER_UNIT)-1; j++)\n-\t\t\t*q++ = 0;\n-\t\t      *q++ = TREE_STRING_POINTER (t)[i];\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      *q++ = TREE_STRING_POINTER (t)[i];\n-\t\t      for (j=0; j<(WCHAR_TYPE_SIZE / BITS_PER_UNIT)-1; j++)\n-\t\t\t*q++ = 0;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-      if (wide_flag)\n-\t{\n-\t  int i;\n-\t  for (i = 0; i < wchar_bytes; i++)\n-\t    *q++ = 0;\n-\t}\n-      else\n-\t*q = 0;\n-\n-      value = build_string (length, p);\n-    }\n-  else\n-    {\n-      value = strings;\n-      length = TREE_STRING_LENGTH (value);\n-      if (TREE_TYPE (value) == wchar_array_type_node)\n-\twide_flag = 1;\n-    }\n+  int length = TREE_STRING_LENGTH (value);\n+  int nchars;\n \n   /* Compute the number of elements, for the array type.  */\n   nchars = wide_flag ? length / wchar_bytes : length;\n@@ -813,6 +725,111 @@ combine_strings (strings)\n   TREE_STATIC (value) = 1;\n   return value;\n }\n+\n+/* Given a VARRAY of STRING_CST nodes, concatenate them into one\n+   STRING_CST.  */\n+\n+tree\n+combine_strings (strings)\n+     varray_type strings;\n+{\n+  const int wchar_bytes = TYPE_PRECISION (wchar_type_node) / BITS_PER_UNIT;\n+  const int nstrings = VARRAY_ACTIVE_SIZE (strings);\n+  tree value, t;\n+  int length = 1;\n+  int wide_length = 0;\n+  int wide_flag = 0;\n+  int i;\n+  char *p, *q;\n+\n+  /* Don't include the \\0 at the end of each substring.  Count wide\n+     strings and ordinary strings separately.  */\n+  for (i = 0; i < nstrings; ++i)\n+    {\n+      t = VARRAY_TREE (strings, i);\n+\n+      if (TREE_TYPE (t) == wchar_array_type_node)\n+\t{\n+\t  wide_length += TREE_STRING_LENGTH (t) - wchar_bytes;\n+\t  wide_flag = 1;\n+\t}\n+      else\n+\t{\n+\t  length += (TREE_STRING_LENGTH (t) - 1);\n+\t  if (C_ARTIFICIAL_STRING_P (t) && !in_system_header)\n+\t    warning (\"concatenation of string literals with __FUNCTION__ is deprecated\"); \n+\t}\n+    }\n+\n+  /* If anything is wide, the non-wides will be converted,\n+     which makes them take more space.  */\n+  if (wide_flag)\n+    length = length * wchar_bytes + wide_length;\n+\n+  p = xmalloc (length);\n+\n+  /* Copy the individual strings into the new combined string.\n+     If the combined string is wide, convert the chars to ints\n+     for any individual strings that are not wide.  */\n+\n+  q = p;\n+  for (i = 0; i < nstrings; ++i)\n+    {\n+      int len, this_wide;\n+\n+      t = VARRAY_TREE (strings, i);\n+      this_wide = TREE_TYPE (t) == wchar_array_type_node;\n+      len = TREE_STRING_LENGTH (t) - (this_wide ? wchar_bytes : 1);\n+      if (this_wide == wide_flag)\n+\t{\n+\t  memcpy (q, TREE_STRING_POINTER (t), len);\n+\t  q += len;\n+\t}\n+      else\n+\t{\n+\t  const int nzeros = (WCHAR_TYPE_SIZE / BITS_PER_UNIT) - 1;\n+\t  int j, k;\n+\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    {\n+\t      for (k = 0; k < len; k++)\n+\t\t{\n+\t\t  for (j = 0; j < nzeros; j++)\n+\t\t    *q++ = 0;\n+\t\t  *q++ = TREE_STRING_POINTER (t)[k];\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      for (k = 0; k < len; k++)\n+\t\t{\n+\t\t  *q++ = TREE_STRING_POINTER (t)[k];\n+\t\t  for (j = 0; j < nzeros; j++)\n+\t\t    *q++ = 0;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  /* Nul terminate the string.  */\n+  if (wide_flag)\n+    {\n+      for (i = 0; i < wchar_bytes; i++)\n+\t*q++ = 0;\n+    }\n+  else\n+    *q = 0;\n+\n+  value = build_string (length, p);\n+  free (p);\n+\n+  if (wide_flag)\n+    TREE_TYPE (value) = wchar_array_type_node;\n+  else\n+    TREE_TYPE (value) = char_array_type_node;\n+\n+  return value;\n+}\n \f\n static int is_valid_printf_arglist PARAMS ((tree));\n static rtx c_expand_builtin PARAMS ((tree, rtx, enum machine_mode, enum expand_modifier));\n@@ -4058,7 +4075,7 @@ c_expand_builtin_printf (arglist, target, tmode, modifier, ignore, unlocked)\n \t  memcpy (newstr, TREE_STRING_POINTER (stripped_string), newlen - 1);\n \t  newstr[newlen - 1] = 0;\n \t  \n-\t  arglist = combine_strings (build_string (newlen, newstr));\n+\t  arglist = fix_string_type (build_string (newlen, newstr));\n \t  arglist = build_tree_list (NULL_TREE, arglist);\n \t  fn = fn_puts;\n \t}"}, {"sha": "873fa4a2919b6dd9a008e9365c4a0d5a491b576e", "filename": "gcc/c-common.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=b84a3874349ccc870c3d278b874d43763efbc9bb", "patch": "@@ -530,12 +530,13 @@ extern tree c_expand_expr_stmt\t\t\tPARAMS ((tree));\n extern void c_expand_start_cond\t\t\tPARAMS ((tree, int, tree));\n extern void c_finish_then                       PARAMS ((void));\n extern void c_expand_start_else\t\t\tPARAMS ((void));\n-extern void c_finish_else                   PARAMS ((void));\n+extern void c_finish_else\t\t\tPARAMS ((void));\n extern void c_expand_end_cond\t\t\tPARAMS ((void));\n /* Validate the expression after `case' and apply default promotions.  */\n extern tree check_case_value\t\t\tPARAMS ((tree));\n-/* Concatenate a list of STRING_CST nodes into one STRING_CST.  */\n-extern tree combine_strings\t\t\tPARAMS ((tree));\n+extern tree fix_string_type\t\t\tPARAMS ((tree));\n+struct varray_head_tag;\n+extern tree combine_strings\t\tPARAMS ((struct varray_head_tag *));\n extern void constant_expression_warning\t\tPARAMS ((tree));\n extern tree convert_and_check\t\t\tPARAMS ((tree, tree));\n extern void overflow_warning\t\t\tPARAMS ((tree));"}, {"sha": "f7cc49283b6445a72b247b7c1954b153345b3462", "filename": "gcc/c-parse.in", "status": "modified", "additions": 71, "deletions": 36, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=b84a3874349ccc870c3d278b874d43763efbc9bb", "patch": "@@ -181,7 +181,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n %type <ttype> BREAK CONTINUE RETURN GOTO ASM_KEYWORD SIZEOF TYPEOF ALIGNOF\n \n %type <ttype> identifier IDENTIFIER TYPENAME CONSTANT expr nonnull_exprlist exprlist\n-%type <ttype> expr_no_commas cast_expr unary_expr primary string STRING\n+%type <ttype> expr_no_commas cast_expr unary_expr primary STRING\n %type <ttype> declspecs_nosc_nots_nosa_noea declspecs_nosc_nots_nosa_ea\n %type <ttype> declspecs_nosc_nots_sa_noea declspecs_nosc_nots_sa_ea\n %type <ttype> declspecs_nosc_ts_nosa_noea declspecs_nosc_ts_nosa_ea\n@@ -329,6 +329,7 @@ end ifc\n static void yyprint\t  PARAMS ((FILE *, int, YYSTYPE));\n static void yyerror\t  PARAMS ((const char *));\n static int yylexname\t  PARAMS ((void));\n+static int yylexstring\t  PARAMS ((void));\n static inline int _yylex  PARAMS ((void));\n static int  yylex\t  PARAMS ((void));\n static void init_reswords PARAMS ((void));\n@@ -658,8 +659,8 @@ primary:\n \t\t  $$ = build_external_ref ($1, yychar == '(');\n \t\t}\n \t| CONSTANT\n-\t| string\n-\t\t{ $$ = combine_strings ($1); }\n+\t| STRING\n+\t\t{ $$ = fix_string_type ($$); }\n \t| VAR_FUNC_NAME\n \t\t{ $$ = fname_decl (C_RID_CODE ($$), $$); }\n \t| '(' typename ')' '{' \n@@ -770,29 +771,6 @@ ifobjc\n end ifobjc\n \t;\n \n-/* Produces a STRING_CST with perhaps more STRING_CSTs chained onto it.  */\n-string:\n-\t  STRING\n-\t| string STRING\n-\t\t{\n-ifc\n-                  static int last_lineno = 0;\n-                  static const char *last_input_filename = 0;\n-end ifc\n-                  $$ = chainon ($1, $2);\n-ifc\n-\t\t  if (warn_traditional && !in_system_header\n-\t\t      && (lineno != last_lineno || !last_input_filename ||\n-\t\t\t  strcmp (last_input_filename, input_filename)))\n-\t\t    {\n-\t\t      warning (\"traditional C rejects string concatenation\");\n-\t\t      last_lineno = lineno;\n-\t\t      last_input_filename = input_filename;\n-\t\t    }\n-end ifc\n-\t\t}\n-\t;\n-\n ifobjc\n /* Produces an STRING_CST with perhaps more STRING_CSTs chained\n    onto it, which is to be read as an ObjC string object.  */\n@@ -1433,10 +1411,8 @@ notype_initdecls:\n maybeasm:\n \t  /* empty */\n \t\t{ $$ = NULL_TREE; }\n-\t| ASM_KEYWORD '(' string ')'\n-\t\t{ if (TREE_CHAIN ($3)) $3 = combine_strings ($3);\n-\t\t  $$ = $3;\n-\t\t}\n+\t| ASM_KEYWORD '(' STRING ')'\n+\t\t{ $$ = $3; }\n \t;\n \n initdcl:\n@@ -2508,10 +2484,10 @@ asm_operand:\n \t;\n \n asm_clobbers:\n-\t  string\n-\t\t{ $$ = tree_cons (NULL_TREE, combine_strings ($1), NULL_TREE); }\n-\t| asm_clobbers ',' string\n-\t\t{ $$ = tree_cons (NULL_TREE, combine_strings ($3), $1); }\n+\t  STRING\n+\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE); }\n+\t| asm_clobbers ',' STRING\n+\t\t{ $$ = tree_cons (NULL_TREE, $3, $1); }\n \t;\n \f\n /* This is what appears inside the parens in a function declarator.\n@@ -3703,6 +3679,59 @@ end ifobjc\n   return IDENTIFIER;\n }\n \n+/* Concatenate strings before returning them to the parser.  This isn't quite\n+   as good as having it done in the lexer, but it's better than nothing.  */\n+\n+static int\n+yylexstring ()\n+{\n+  enum cpp_ttype next_type;\n+  tree orig = yylval.ttype;\n+\n+  next_type = c_lex (&yylval.ttype);\n+  if (next_type == CPP_STRING\n+      || next_type == CPP_WSTRING\n+      || (next_type == CPP_NAME && yylexname () == STRING))\n+    {\n+      varray_type strings;\n+\n+ifc\n+      static int last_lineno = 0;\n+      static const char *last_input_filename = 0;\n+      if (warn_traditional && !in_system_header\n+\t  && (lineno != last_lineno || !last_input_filename ||\n+\t      strcmp (last_input_filename, input_filename)))\n+\t{\n+\t  warning (\"traditional C rejects string concatenation\");\n+\t  last_lineno = lineno;\n+\t  last_input_filename = input_filename;\n+\t}\n+end ifc\n+\n+      VARRAY_TREE_INIT (strings, 32, \"strings\");\n+      VARRAY_PUSH_TREE (strings, orig);\n+\n+      do\n+\t{\n+\t  VARRAY_PUSH_TREE (strings, yylval.ttype);\n+\t  next_type = c_lex (&yylval.ttype);\n+\t}\n+      while (next_type == CPP_STRING\n+\t     || next_type == CPP_WSTRING\n+\t     || (next_type == CPP_NAME && yylexname () == STRING));\n+\n+      yylval.ttype = combine_strings (strings);\n+\n+      VARRAY_FREE (strings);\n+    }\n+  else\n+    yylval.ttype = orig;\n+\n+  /* We will have always read one token too many.  */\n+  _cpp_backup_tokens (parse_in, 1);\n+\n+  return STRING;\n+}\n \n static inline int\n _yylex ()\n@@ -3769,7 +3798,13 @@ _yylex ()\n       return 0;\n \n     case CPP_NAME:\n-      return yylexname ();\n+      {\n+\tint ret = yylexname ();\n+\tif (ret == STRING)\n+\t  return yylexstring ();\n+\telse\n+\t  return ret;\n+      }\n \n     case CPP_NUMBER:\n     case CPP_CHAR:\n@@ -3778,7 +3813,7 @@ _yylex ()\n \n     case CPP_STRING:\n     case CPP_WSTRING:\n-      return STRING;\n+      return yylexstring ();\n       \n       /* This token is Objective-C specific.  It gives the next token\n \t special significance.  */"}, {"sha": "f883801955722f2ee6823e8d4b04e12dc6399cd5", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=b84a3874349ccc870c3d278b874d43763efbc9bb", "patch": "@@ -6849,8 +6849,6 @@ simple_asm_stmt (expr)\n     {\n       tree stmt;\n \n-      if (TREE_CHAIN (expr))\n-\texpr = combine_strings (expr);\n       stmt = add_stmt (build_stmt (ASM_STMT, NULL_TREE, expr,\n \t\t\t\t   NULL_TREE, NULL_TREE,\n \t\t\t\t   NULL_TREE));\n@@ -6875,8 +6873,6 @@ build_asm_stmt (cv_qualifier, string, outputs, inputs, clobbers)\n {\n   tree tail;\n \n-  if (TREE_CHAIN (string))\n-    string = combine_strings (string);\n   if (TREE_CODE (string) != STRING_CST)\n     {\n       error (\"asm template is not a string constant\");"}, {"sha": "607aa433fdbddd899c7db0f3eaf467970d5eb0ed", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b84a3874349ccc870c3d278b874d43763efbc9bb", "patch": "@@ -1,3 +1,13 @@\n+2002-04-26  Richard Henderson  <rth@redhat.com>\n+\n+\tPR c/3581\n+\t* parse.y (string): Remove.  Update all uses to use STRING\n+\tinstead, and not call combine_strings.\n+\t* rtti.c (tinfo_name): Use fix_string_type.\n+\t* semantics.c (finish_asm_stmt): Don't call combine_strings.\n+\t* spew.c (yylexstring): New.\n+\t(read_token): Use it.\n+\n 2002-04-25  Richard Henderson  <rth@redhat.com>\n \n \tPR c/2161"}, {"sha": "2d8d0465cfb43b415f4eb27d64cbbdbd35a552c1", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=b84a3874349ccc870c3d278b874d43763efbc9bb", "patch": "@@ -378,7 +378,7 @@ cp_parse_init ()\n %type <ttype> PFUNCNAME maybe_identifier\n %type <ttype> paren_expr_or_null nontrivial_exprlist SELFNAME\n %type <ttype> expr_no_commas expr_no_comma_rangle\n-%type <ttype> cast_expr unary_expr primary string STRING\n+%type <ttype> cast_expr unary_expr primary STRING\n %type <ttype> reserved_declspecs boolean.literal\n %type <ttype> reserved_typespecquals\n %type <ttype> SCSPEC TYPESPEC CV_QUALIFIER maybe_cv_qualifier\n@@ -543,9 +543,8 @@ extdef:\n \t\t{ do_pending_inlines (); }\n \t| template_def\n \t\t{ do_pending_inlines (); }\n-\t| asm_keyword '(' string ')' ';'\n-\t\t{ if (TREE_CHAIN ($3)) $3 = combine_strings ($3);\n-\t\t  assemble_asm ($3); }\n+\t| asm_keyword '(' STRING ')' ';'\n+\t\t{ assemble_asm ($3); }\n \t| extern_lang_string '{' extdefs_opt '}'\n \t\t{ pop_lang_context (); }\n \t| extern_lang_string .hush_warning fndef .warning_ok eat_saved_input\n@@ -1608,10 +1607,10 @@ primary:\n \t\t}\t\t\n \t| CONSTANT\n \t| boolean.literal\n-\t| string\n+\t| STRING\n \t\t{\n-\t\t  $$ = combine_strings ($$);\n-\t\t  /* combine_strings doesn't set up TYPE_MAIN_VARIANT of\n+\t\t  $$ = fix_string_type ($$);\n+\t\t  /* fix_string_type doesn't set up TYPE_MAIN_VARIANT of\n \t\t     a const array the way we want, so fix it.  */\n \t\t  if (flag_const_strings)\n \t\t    TREE_TYPE ($$) = build_cplus_array_type\n@@ -1812,13 +1811,6 @@ boolean.literal:\n \t\t{ $$ = boolean_false_node; }\n \t;\n \n-/* Produces a STRING_CST with perhaps more STRING_CSTs chained onto it.  */\n-string:\n-\t  STRING\n-\t| string STRING\n-\t\t{ $$ = chainon ($$, $2); }\n-\t;\n-\n nodecls:\n \t  /* empty */\n \t\t{\n@@ -2098,8 +2090,8 @@ nomods_initdecls:\n maybeasm:\n \t  /* empty */\n \t\t{ $$ = NULL_TREE; }\n-\t| asm_keyword '(' string ')'\n-\t\t{ if (TREE_CHAIN ($3)) $3 = combine_strings ($3); $$ = $3; }\n+\t| asm_keyword '(' STRING ')'\n+\t\t{ $$ = $3; }\n \t;\n \n initdcl:\n@@ -3494,27 +3486,27 @@ simple_stmt:\n                 { $$ = finish_return_stmt (NULL_TREE); }\n \t| RETURN_KEYWORD expr ';'\n                 { $$ = finish_return_stmt ($2); }\n-\t| asm_keyword maybe_cv_qualifier '(' string ')' ';'\n+\t| asm_keyword maybe_cv_qualifier '(' STRING ')' ';'\n \t\t{ $$ = finish_asm_stmt ($2, $4, NULL_TREE, NULL_TREE,\n \t\t\t\t\tNULL_TREE);\n \t\t  ASM_INPUT_P ($$) = 1; }\n \t/* This is the case with just output operands.  */\n-\t| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ')' ';'\n+\t| asm_keyword maybe_cv_qualifier '(' STRING ':' asm_operands ')' ';'\n \t\t{ $$ = finish_asm_stmt ($2, $4, $6, NULL_TREE, NULL_TREE); }\n \t/* This is the case with input operands as well.  */\n-\t| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ':'\n+\t| asm_keyword maybe_cv_qualifier '(' STRING ':' asm_operands ':'\n \t  asm_operands ')' ';'\n \t\t{ $$ = finish_asm_stmt ($2, $4, $6, $8, NULL_TREE); }\n-\t| asm_keyword maybe_cv_qualifier '(' string SCOPE asm_operands ')' ';'\n+\t| asm_keyword maybe_cv_qualifier '(' STRING SCOPE asm_operands ')' ';'\n \t\t{ $$ = finish_asm_stmt ($2, $4, NULL_TREE, $6, NULL_TREE); }\n \t/* This is the case with clobbered registers as well.  */\n-\t| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ':'\n+\t| asm_keyword maybe_cv_qualifier '(' STRING ':' asm_operands ':'\n \t  asm_operands ':' asm_clobbers ')' ';'\n \t\t{ $$ = finish_asm_stmt ($2, $4, $6, $8, $10); }\n-\t| asm_keyword maybe_cv_qualifier '(' string SCOPE asm_operands ':'\n+\t| asm_keyword maybe_cv_qualifier '(' STRING SCOPE asm_operands ':'\n \t  asm_clobbers ')' ';'\n \t\t{ $$ = finish_asm_stmt ($2, $4, NULL_TREE, $6, $8); }\n-\t| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands SCOPE\n+\t| asm_keyword maybe_cv_qualifier '(' STRING ':' asm_operands SCOPE\n \t  asm_clobbers ')' ';'\n \t\t{ $$ = finish_asm_stmt ($2, $4, $6, NULL_TREE, $8); }\n \t| GOTO '*' expr ';'\n@@ -3677,10 +3669,10 @@ asm_operand:\n \t;\n \n asm_clobbers:\n-\t  string\n-\t\t{ $$ = tree_cons (NULL_TREE, combine_strings ($1), NULL_TREE);}\n-\t| asm_clobbers ',' string\n-\t\t{ $$ = tree_cons (NULL_TREE, combine_strings ($3), $1); }\n+\t  STRING\n+\t\t{ $$ = tree_cons (NULL_TREE, $1, NULL_TREE);}\n+\t| asm_clobbers ',' STRING\n+\t\t{ $$ = tree_cons (NULL_TREE, $3, $1); }\n \t;\n \n /* This is what appears inside the parens in a function declarator."}, {"sha": "16df801b0d0390727c1fa6fb57d8f6abef4d2213", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=b84a3874349ccc870c3d278b874d43763efbc9bb", "patch": "@@ -259,7 +259,7 @@ tinfo_name (type)\n   tree name_string;\n \n   name = mangle_type_string (type);\n-  name_string = combine_strings (build_string (strlen (name) + 1, name));\n+  name_string = fix_string_type (build_string (strlen (name) + 1, name));\n   return name_string;\n }\n "}, {"sha": "ce1cbaca68a4532ebc128901c7a8e0819cb414fc", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=b84a3874349ccc870c3d278b874d43763efbc9bb", "patch": "@@ -863,9 +863,6 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n   tree r;\n   tree t;\n \n-  if (TREE_CHAIN (string))\n-    string = combine_strings (string);\n-\n   if (cv_qualifier != NULL_TREE\n       && cv_qualifier != ridpointers[(int) RID_VOLATILE])\n     {"}, {"sha": "9607e975f117b5758e1c5a64c587b5fa7a744c29", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=b84a3874349ccc870c3d278b874d43763efbc9bb", "patch": "@@ -102,6 +102,7 @@ static SPEW_INLINE int identifier_type PARAMS ((tree));\n static void scan_tokens PARAMS ((int));\n static void feed_defarg PARAMS ((tree));\n static void finish_defarg PARAMS ((void));\n+static void yylexstring PARAMS ((struct token *));\n static int read_token PARAMS ((struct token *));\n \n static SPEW_INLINE int num_tokens PARAMS ((void));\n@@ -242,6 +243,43 @@ read_process_identifier (pyylval)\n   return IDENTIFIER;\n }\n \n+/* Concatenate strings before returning them to the parser.  This isn't quite\n+   as good as having it done in the lexer, but it's better than nothing.  */\n+\n+static void\n+yylexstring (t)\n+     struct token *t;\n+{\n+  enum cpp_ttype next_type;\n+  tree next;\n+\n+  next_type = c_lex (&next);\n+  if (next_type == CPP_STRING || next_type == CPP_WSTRING)\n+    {\n+      varray_type strings;\n+\n+      VARRAY_TREE_INIT (strings, 32, \"strings\");\n+      VARRAY_PUSH_TREE (strings, t->yylval.ttype);\n+\n+      do\n+\t{\n+\t  VARRAY_PUSH_TREE (strings, next);\n+\t  next_type = c_lex (&next);\n+\t}\n+      while (next_type == CPP_STRING || next_type == CPP_WSTRING);\n+\n+      t->yylval.ttype = combine_strings (strings);\n+      last_token_id = t->yylval.ttype;\n+\n+      VARRAY_FREE (strings);\n+    }\n+\n+  /* We will have always read one token too many.  */\n+  _cpp_backup_tokens (parse_in, 1);\n+\n+  t->yychar = STRING;\n+}\n+\n /* Read the next token from the input file.  The token is written into\n    T, and its type number is returned.  */\n static int\n@@ -336,7 +374,7 @@ read_token (t)\n \n     case CPP_STRING:\n     case CPP_WSTRING:\n-      t->yychar = STRING;\n+      yylexstring (t);\n       break;\n \n     default:"}, {"sha": "4795160f09f98afb63784fe0b7d80abbd7915554", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=b84a3874349ccc870c3d278b874d43763efbc9bb", "patch": "@@ -1201,21 +1201,7 @@ my_build_string (len, str)\n      int len;\n      const char *str;\n {\n-  int wide_flag = 0;\n-  tree a_string = build_string (len, str);\n-\n-  /* Some code from combine_strings, which is local to c-parse.y.  */\n-  if (TREE_TYPE (a_string) == int_array_type_node)\n-    wide_flag = 1;\n-\n-  TREE_TYPE (a_string)\n-    = build_array_type (wide_flag ? integer_type_node : char_type_node,\n-\t\t\tbuild_index_type (build_int_2 (len - 1, 0)));\n-\n-  TREE_CONSTANT (a_string) = 1;\t/* Puts string in the readonly segment */\n-  TREE_STATIC (a_string) = 1;\n-\n-  return a_string;\n+  return fix_string_type (build_string (len, str));\n }\n \n /* Given a chain of STRING_CST's, build a static instance of\n@@ -1241,7 +1227,23 @@ build_objc_string_object (strings)\n \n   add_class_reference (constant_string_id);\n \n-  string = combine_strings (strings);\n+  if (TREE_CHAIN (strings))\n+    {\n+      varray_type vstrings;\n+      VARRAY_TREE_INIT (vstrings, 32, \"strings\");\n+\n+      for (; strings ; strings = TREE_CHAIN (strings))\n+\tVARRAY_PUSH_TREE (vstrings, strings);\n+\n+      string = combine_strings (vstrings);\n+\n+      VARRAY_FREE (vstrings);\n+    }\n+  else\n+    string = strings;\n+\n+  string = fix_string_type (string);\n+\n   TREE_SET_CODE (string, STRING_CST);\n   length = TREE_STRING_LENGTH (string) - 1;\n "}, {"sha": "7bf97a628743529e73509de3a4e7a4f79e6784ef", "filename": "gcc/testsuite/g++.dg/parse/concat1.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconcat1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconcat1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconcat1.C?ref=b84a3874349ccc870c3d278b874d43763efbc9bb", "patch": "@@ -0,0 +1,15 @@\n+/* PR c/3581 */\n+/* { dg-do compile } */\n+\n+/* Intended as a compile-time test for string literal concatenation.\n+   The fact that the string isn't actually used in the resulting program\n+   should allow this to compile for any target.  */\n+\n+#define e0\t\"a\"\n+#define e1\te0 e0 e0 e0 e0 e0 e0 e0 e0 e0\n+#define e2\te1 e1 e1 e1 e1 e1 e1 e1 e1 e1\n+#define e3\te2 e2 e2 e2 e2 e2 e2 e2 e2 e2\n+#define e4\te3 e3 e3 e3 e3 e3 e3 e3 e3 e3\n+#define e5\te4 e4 e4 e4 e4 e4 e4 e4 e4 e4\n+\n+void foo() { (void)(e5); }"}, {"sha": "1e92400663f00df5d7e55ab945418861ce79cb43", "filename": "gcc/testsuite/gcc.dg/concat2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Ftestsuite%2Fgcc.dg%2Fconcat2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b84a3874349ccc870c3d278b874d43763efbc9bb/gcc%2Ftestsuite%2Fgcc.dg%2Fconcat2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fconcat2.c?ref=b84a3874349ccc870c3d278b874d43763efbc9bb", "patch": "@@ -0,0 +1,16 @@\n+/* PR c/3581 */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+/* Intended as a compile-time test for string literal concatenation.\n+   The fact that the string isn't actually used in the resulting program\n+   should allow this to compile for any target.  */\n+\n+#define e0\t\"a\"\n+#define e1\te0 e0 e0 e0 e0 e0 e0 e0 e0 e0\n+#define e2\te1 e1 e1 e1 e1 e1 e1 e1 e1 e1\n+#define e3\te2 e2 e2 e2 e2 e2 e2 e2 e2 e2\n+#define e4\te3 e3 e3 e3 e3 e3 e3 e3 e3 e3\n+#define e5\te4 e4 e4 e4 e4 e4 e4 e4 e4 e4\n+\n+void foo() { (void)(e5); }"}]}