{"sha": "1e080ab4ed3a4390f6e57adb608b91b2c440af36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUwODBhYjRlZDNhNDM5MGY2ZTU3YWRiNjA4YjkxYjJjNDQwYWYzNg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-10-26T14:22:20Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-10-26T14:22:20Z"}, "message": "tree-object-size.c: Remove builtins.h include, include tree-cfg.h.\n\n2015-10-26  Richard Biener  <rguenther@suse.de>\n\n\t* tree-object-size.c: Remove builtins.h include, include tree-cfg.h.\n\t(do_valueize): New function.\n\t(pass_object_sizes::execute): Use gimple_fold_stmt_to_constant and\n\treplace_uses_by.\n\t* tree-ssa-threadedge.c: Remove builtins.h include, include\n\tgimple-fold.h\n\t(fold_assignment_stmt): Remove.\n\t(threadedge_valueize): New function.\n\t(record_temporary_equivalences_from_stmts): Use\n\tgimple_fold_stmt_to_constant_1, note additional cleanup\n\topportunities.\n\nFrom-SVN: r229364", "tree": {"sha": "7612eb7cb09900d59522c9f603ee66b5da5b0595", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7612eb7cb09900d59522c9f603ee66b5da5b0595"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e080ab4ed3a4390f6e57adb608b91b2c440af36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e080ab4ed3a4390f6e57adb608b91b2c440af36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e080ab4ed3a4390f6e57adb608b91b2c440af36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e080ab4ed3a4390f6e57adb608b91b2c440af36/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3373589b25382e5389a189acc832fb657016f375", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3373589b25382e5389a189acc832fb657016f375", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3373589b25382e5389a189acc832fb657016f375"}], "stats": {"total": 172, "additions": 75, "deletions": 97}, "files": [{"sha": "37af21566e096724c9da5ef254840db09798fcc7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e080ab4ed3a4390f6e57adb608b91b2c440af36/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e080ab4ed3a4390f6e57adb608b91b2c440af36/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e080ab4ed3a4390f6e57adb608b91b2c440af36", "patch": "@@ -1,3 +1,17 @@\n+2015-10-26  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-object-size.c: Remove builtins.h include, include tree-cfg.h.\n+\t(do_valueize): New function.\n+\t(pass_object_sizes::execute): Use gimple_fold_stmt_to_constant and\n+\treplace_uses_by.\n+\t* tree-ssa-threadedge.c: Remove builtins.h include, include\n+\tgimple-fold.h\n+\t(fold_assignment_stmt): Remove.\n+\t(threadedge_valueize): New function.\n+\t(record_temporary_equivalences_from_stmts): Use\n+\tgimple_fold_stmt_to_constant_1, note additional cleanup\n+\topportunities.\n+\n 2015-10-26  Richard Biener  <rguenther@suse.de>\n \n \t* match.pd ((A & ~B) - (A & B) -> (A ^ B) - B): Add missing :c."}, {"sha": "e332d4cff801320525b11c5c2714f4e09bf4ace0", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e080ab4ed3a4390f6e57adb608b91b2c440af36/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e080ab4ed3a4390f6e57adb608b91b2c440af36/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=1e080ab4ed3a4390f6e57adb608b91b2c440af36", "patch": "@@ -36,7 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-iterator.h\"\n #include \"tree-pass.h\"\n #include \"tree-ssa-propagate.h\"\n-#include \"builtins.h\"\n+#include \"tree-cfg.h\"\n \n struct object_size_info\n {\n@@ -1231,6 +1231,14 @@ class pass_object_sizes : public gimple_opt_pass\n \n }; // class pass_object_sizes\n \n+/* Dummy valueize function.  */\n+\n+static tree\n+do_valueize (tree t)\n+{\n+  return t;\n+}\n+\n unsigned int\n pass_object_sizes::execute (function *fun)\n {\n@@ -1287,7 +1295,11 @@ pass_object_sizes::execute (function *fun)\n \t      continue;\n \t    }\n \n-\t  result = fold_call_stmt (as_a <gcall *> (call), false);\n+\t  tree lhs = gimple_call_lhs (call);\n+\t  if (!lhs)\n+\t    continue;\n+\n+\t  result = gimple_fold_stmt_to_constant (call, do_valueize);\n \t  if (!result)\n \t    {\n \t      tree ost = gimple_call_arg (call, 1);\n@@ -1318,22 +1330,8 @@ pass_object_sizes::execute (function *fun)\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \n-\t  tree lhs = gimple_call_lhs (call);\n-\t  if (!lhs)\n-\t    continue;\n-\n \t  /* Propagate into all uses and fold those stmts.  */\n-\t  gimple *use_stmt;\n-\t  imm_use_iterator iter;\n-\t  FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n-\t    {\n-\t      use_operand_p use_p;\n-\t      FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n-\t\tSET_USE (use_p, result);\n-\t      gimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n-\t      fold_stmt (&gsi);\n-\t      update_stmt (gsi_stmt (gsi));\n-\t    }\n+\t  replace_uses_by (lhs, result);\n \t}\n     }\n "}, {"sha": "38f80ba14fc2dc3ee2478f66d7255680ecb88038", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 46, "deletions": 80, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e080ab4ed3a4390f6e57adb608b91b2c440af36/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e080ab4ed3a4390f6e57adb608b91b2c440af36/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=1e080ab4ed3a4390f6e57adb608b91b2c440af36", "patch": "@@ -36,7 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-threadedge.h\"\n #include \"tree-ssa-threadbackward.h\"\n #include \"tree-ssa-dom.h\"\n-#include \"builtins.h\"\n+#include \"gimple-fold.h\"\n \n /* To avoid code explosion due to jump threading, we limit the\n    number of statements we are going to copy.  This variable\n@@ -180,54 +180,18 @@ record_temporary_equivalences_from_phis (edge e, const_and_copies *const_and_cop\n   return true;\n }\n \n-/* Fold the RHS of an assignment statement and return it as a tree.\n-   May return NULL_TREE if no simplification is possible.  */\n+/* Valueize hook for gimple_fold_stmt_to_constant_1.  */\n \n static tree\n-fold_assignment_stmt (gimple *stmt)\n+threadedge_valueize (tree t)\n {\n-  enum tree_code subcode = gimple_assign_rhs_code (stmt);\n-\n-  switch (get_gimple_rhs_class (subcode))\n+  if (TREE_CODE (t) == SSA_NAME)\n     {\n-    case GIMPLE_SINGLE_RHS:\n-      return fold (gimple_assign_rhs1 (stmt));\n-\n-    case GIMPLE_UNARY_RHS:\n-      {\n-        tree lhs = gimple_assign_lhs (stmt);\n-        tree op0 = gimple_assign_rhs1 (stmt);\n-        return fold_unary (subcode, TREE_TYPE (lhs), op0);\n-      }\n-\n-    case GIMPLE_BINARY_RHS:\n-      {\n-        tree lhs = gimple_assign_lhs (stmt);\n-        tree op0 = gimple_assign_rhs1 (stmt);\n-        tree op1 = gimple_assign_rhs2 (stmt);\n-        return fold_binary (subcode, TREE_TYPE (lhs), op0, op1);\n-      }\n-\n-    case GIMPLE_TERNARY_RHS:\n-      {\n-        tree lhs = gimple_assign_lhs (stmt);\n-        tree op0 = gimple_assign_rhs1 (stmt);\n-        tree op1 = gimple_assign_rhs2 (stmt);\n-        tree op2 = gimple_assign_rhs3 (stmt);\n-\n-\t/* Sadly, we have to handle conditional assignments specially\n-\t   here, because fold expects all the operands of an expression\n-\t   to be folded before the expression itself is folded, but we\n-\t   can't just substitute the folded condition here.  */\n-        if (gimple_assign_rhs_code (stmt) == COND_EXPR)\n-\t  op0 = fold (op0);\n-\n-        return fold_ternary (subcode, TREE_TYPE (lhs), op0, op1, op2);\n-      }\n-\n-    default:\n-      gcc_unreachable ();\n+      tree tem = SSA_NAME_VALUE (t);\n+      if (tem)\n+\treturn tem;\n     }\n+  return t;\n }\n \n /* Try to simplify each statement in E->dest, ultimately leading to\n@@ -371,48 +335,50 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n       else\n \t{\n \t  /* A statement that is not a trivial copy or ASSERT_EXPR.\n-\t     We're going to temporarily copy propagate the operands\n-\t     and see if that allows us to simplify this statement.  */\n-\t  tree *copy;\n-\t  ssa_op_iter iter;\n-\t  use_operand_p use_p;\n-\t  unsigned int num, i = 0;\n-\n-\t  num = NUM_SSA_OPERANDS (stmt, (SSA_OP_USE | SSA_OP_VUSE));\n-\t  copy = XCNEWVEC (tree, num);\n-\n-\t  /* Make a copy of the uses & vuses into USES_COPY, then cprop into\n-\t     the operands.  */\n-\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE | SSA_OP_VUSE)\n-\t    {\n-\t      tree tmp = NULL;\n-\t      tree use = USE_FROM_PTR (use_p);\n-\n-\t      copy[i++] = use;\n-\t      if (TREE_CODE (use) == SSA_NAME)\n-\t\ttmp = SSA_NAME_VALUE (use);\n-\t      if (tmp)\n-\t\tSET_USE (use_p, tmp);\n-\t    }\n-\n-\t  /* Try to fold/lookup the new expression.  Inserting the\n+\t     Try to fold the new expression.  Inserting the\n \t     expression into the hash table is unlikely to help.  */\n-          if (is_gimple_call (stmt))\n-            cached_lhs = fold_call_stmt (as_a <gcall *> (stmt), false);\n-\t  else\n-            cached_lhs = fold_assignment_stmt (stmt);\n-\n+\t  /* ???  The DOM callback below can be changed to setting\n+\t     the mprts_hook around the call to thread_across_edge,\n+\t     avoiding the use substitution.  The VRP hook should be\n+\t     changed to properly valueize operands itself using\n+\t     SSA_NAME_VALUE in addition to its own lattice.  */\n+\t  cached_lhs = gimple_fold_stmt_to_constant_1 (stmt,\n+\t\t\t\t\t\t       threadedge_valueize);\n           if (!cached_lhs\n               || (TREE_CODE (cached_lhs) != SSA_NAME\n                   && !is_gimple_min_invariant (cached_lhs)))\n-            cached_lhs = (*simplify) (stmt, stmt, avail_exprs_stack);\n+\t    {\n+\t      /* We're going to temporarily copy propagate the operands\n+\t\t and see if that allows us to simplify this statement.  */\n+\t      tree *copy;\n+\t      ssa_op_iter iter;\n+\t      use_operand_p use_p;\n+\t      unsigned int num, i = 0;\n+\n+\t      num = NUM_SSA_OPERANDS (stmt, SSA_OP_ALL_USES);\n+\t      copy = XALLOCAVEC (tree, num);\n+\n+\t      /* Make a copy of the uses & vuses into USES_COPY, then cprop into\n+\t\t the operands.  */\n+\t      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n+\t\t{\n+\t\t  tree tmp = NULL;\n+\t\t  tree use = USE_FROM_PTR (use_p);\n+\n+\t\t  copy[i++] = use;\n+\t\t  if (TREE_CODE (use) == SSA_NAME)\n+\t\t    tmp = SSA_NAME_VALUE (use);\n+\t\t  if (tmp)\n+\t\t    SET_USE (use_p, tmp);\n+\t\t}\n \n-\t  /* Restore the statement's original uses/defs.  */\n-\t  i = 0;\n-\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE | SSA_OP_VUSE)\n-\t    SET_USE (use_p, copy[i++]);\n+\t      cached_lhs = (*simplify) (stmt, stmt, avail_exprs_stack);\n \n-\t  free (copy);\n+\t      /* Restore the statement's original uses/defs.  */\n+\t      i = 0;\n+\t      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n+\t\tSET_USE (use_p, copy[i++]);\n+\t    }\n \t}\n \n       /* Record the context sensitive equivalence if we were able"}]}