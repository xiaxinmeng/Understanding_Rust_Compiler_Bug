{"sha": "173399a0b4910ce027194cf4cc21d2a8856180d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTczMzk5YTBiNDkxMGNlMDI3MTk0Y2Y0Y2MyMWQyYTg4NTYxODBkNw==", "commit": {"author": {"name": "Daniel Santos", "email": "daniel.santos@pobox.com", "date": "2017-11-04T22:38:43Z"}, "committer": {"name": "Daniel Santos", "email": "dansan@gcc.gnu.org", "date": "2017-11-04T22:38:43Z"}, "message": "PR target/82002 Part 2: Correct non-immediate offset/invalid INSN\n\nWhen we are realigning the stack pointer, making an ms_abi to sysv_abi\ncall and allocating 2GiB or more on the stack we end up with an invalid\nINSN due to a non-immediate offset.  This occurs both with and without\n-mcall-ms2sysv-xlogues.  Additionally, the stack allocation with\n-mcall-ms2sysv-xlogues is ignoring (silently disabling) stack checking,\nstack clash checking and probing.\n\nThis patch fixes these problems by:\n\n1. No longer allocate stack space in ix86_emit_outlined_ms2sysv_save.\n2. Rearrange where we emit SSE saves or stub call:\n   a. Before frame allocation when offset from frame to save area is >= 2GiB.\n   b. After frame allocation when frame is < 2GiB.  (Stack allocations\n      prior to the stub call can't be combined with those afterwards, so\n      this is better when possible.)\n3. Modify choose_baseaddr to take an optional scratch_regno argument\n   and never return rtx that cannot be used as an immediate.\n\ngcc:\n\tconfig/i386/i386.c (choose_basereg): Use optional scratch\n\tregister and add assertion.\n\t(x86_emit_outlined_ms2sysv_save): Use scratch register when\n\tneeded, and don't allocate stack.\n\t(ix86_expand_prologue): Rearrange where SSE saves/stub call is\n\temitted, correct wrong allocation with -mcall-ms2sysv-xlogues.\n\t(ix86_emit_outlined_ms2sysv_restore): Fix non-immediate offsets.\n\ngcc/testsuite:\n\tgcc.target/i386/pr82002-2a.c: Change from xfail to fail.\n\tgcc.target/i386/pr82002-2b.c: Likewise.\n\nFrom-SVN: r254412", "tree": {"sha": "ac9418676fb68121eb91bd4fa134bd733c3f3c80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac9418676fb68121eb91bd4fa134bd733c3f3c80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/173399a0b4910ce027194cf4cc21d2a8856180d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/173399a0b4910ce027194cf4cc21d2a8856180d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/173399a0b4910ce027194cf4cc21d2a8856180d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/173399a0b4910ce027194cf4cc21d2a8856180d7/comments", "author": {"login": "daniel-santos", "id": 980562, "node_id": "MDQ6VXNlcjk4MDU2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/980562?v=4", "gravatar_id": "", "url": "https://api.github.com/users/daniel-santos", "html_url": "https://github.com/daniel-santos", "followers_url": "https://api.github.com/users/daniel-santos/followers", "following_url": "https://api.github.com/users/daniel-santos/following{/other_user}", "gists_url": "https://api.github.com/users/daniel-santos/gists{/gist_id}", "starred_url": "https://api.github.com/users/daniel-santos/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/daniel-santos/subscriptions", "organizations_url": "https://api.github.com/users/daniel-santos/orgs", "repos_url": "https://api.github.com/users/daniel-santos/repos", "events_url": "https://api.github.com/users/daniel-santos/events{/privacy}", "received_events_url": "https://api.github.com/users/daniel-santos/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "59fcf6c3ec651d043266c4b898390656bd97e4c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59fcf6c3ec651d043266c4b898390656bd97e4c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59fcf6c3ec651d043266c4b898390656bd97e4c0"}], "stats": {"total": 81, "additions": 64, "deletions": 17}, "files": [{"sha": "ec8af50fa050804e6285e3de42051db60a0de910", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173399a0b4910ce027194cf4cc21d2a8856180d7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173399a0b4910ce027194cf4cc21d2a8856180d7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=173399a0b4910ce027194cf4cc21d2a8856180d7", "patch": "@@ -1,3 +1,13 @@\n+2017-11-04  Daniel Santos  <daniel.santos@pobox.com>\n+\n+\tconfig/i386/i386.c (choose_basereg): Use optional scratch\n+\tregister and add assertion.\n+\t(x86_emit_outlined_ms2sysv_save): Use scratch register when\n+\tneeded, and don't allocate stack.\n+\t(ix86_expand_prologue): Rearrange where SSE saves/stub call is\n+\temitted, correct wrong allocation with -mcall-ms2sysv-xlogues.\n+\t(ix86_emit_outlined_ms2sysv_restore): Fix non-immediate offsets.\n+\n 2017-11-03  Jeff Law  <law@redhat.com>\n \n \t* config/i386/i386.c (ix86_emit_restore_reg_using_pop): Prototype."}, {"sha": "4123edf982f35eca69daf32aef7b95f75231d639", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 49, "deletions": 13, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173399a0b4910ce027194cf4cc21d2a8856180d7/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173399a0b4910ce027194cf4cc21d2a8856180d7/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=173399a0b4910ce027194cf4cc21d2a8856180d7", "patch": "@@ -11517,12 +11517,15 @@ choose_basereg (HOST_WIDE_INT cfa_offset, rtx &base_reg,\n    an alignment value (in bits) that is preferred or zero and will\n    recieve the alignment of the base register that was selected,\n    irrespective of rather or not CFA_OFFSET is a multiple of that\n-   alignment value.\n+   alignment value.  If it is possible for the base register offset to be\n+   non-immediate then SCRATCH_REGNO should specify a scratch register to\n+   use.\n \n    The valid base registers are taken from CFUN->MACHINE->FS.  */\n \n static rtx\n-choose_baseaddr (HOST_WIDE_INT cfa_offset, unsigned int *align)\n+choose_baseaddr (HOST_WIDE_INT cfa_offset, unsigned int *align,\n+\t\t unsigned int scratch_regno = INVALID_REGNUM)\n {\n   rtx base_reg = NULL;\n   HOST_WIDE_INT base_offset = 0;\n@@ -11536,6 +11539,19 @@ choose_baseaddr (HOST_WIDE_INT cfa_offset, unsigned int *align)\n     choose_basereg (cfa_offset, base_reg, base_offset, 0, align);\n \n   gcc_assert (base_reg != NULL);\n+\n+  rtx base_offset_rtx = GEN_INT (base_offset);\n+\n+  if (!x86_64_immediate_operand (base_offset_rtx, Pmode))\n+    {\n+      gcc_assert (scratch_regno != INVALID_REGNUM);\n+\n+      rtx scratch_reg = gen_rtx_REG (Pmode, scratch_regno);\n+      emit_move_insn (scratch_reg, base_offset_rtx);\n+\n+      return gen_rtx_PLUS (Pmode, base_reg, scratch_reg);\n+    }\n+\n   return plus_constant (Pmode, base_reg, base_offset);\n }\n \n@@ -12801,23 +12817,19 @@ ix86_emit_outlined_ms2sysv_save (const struct ix86_frame &frame)\n   rtx sym, addr;\n   rtx rax = gen_rtx_REG (word_mode, AX_REG);\n   const struct xlogue_layout &xlogue = xlogue_layout::get_instance ();\n-  HOST_WIDE_INT allocate = frame.stack_pointer_offset - m->fs.sp_offset;\n \n   /* AL should only be live with sysv_abi.  */\n   gcc_assert (!ix86_eax_live_at_start_p ());\n+  gcc_assert (m->fs.sp_offset >= frame.sse_reg_save_offset);\n \n   /* Setup RAX as the stub's base pointer.  We use stack_realign_offset rather\n      we've actually realigned the stack or not.  */\n   align = GET_MODE_ALIGNMENT (V4SFmode);\n   addr = choose_baseaddr (frame.stack_realign_offset\n-\t\t\t  + xlogue.get_stub_ptr_offset (), &align);\n+\t\t\t  + xlogue.get_stub_ptr_offset (), &align, AX_REG);\n   gcc_assert (align >= GET_MODE_ALIGNMENT (V4SFmode));\n-  emit_insn (gen_rtx_SET (rax, addr));\n \n-  /* Allocate stack if not already done.  */\n-  if (allocate > 0)\n-      pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\tGEN_INT (-allocate), -1, false);\n+  emit_insn (gen_rtx_SET (rax, addr));\n \n   /* Get the stub symbol.  */\n   sym = xlogue.get_stub_rtx (frame_pointer_needed ? XLOGUE_STUB_SAVE_HFP\n@@ -12849,6 +12861,7 @@ ix86_expand_prologue (void)\n   HOST_WIDE_INT allocate;\n   bool int_registers_saved;\n   bool sse_registers_saved;\n+  bool save_stub_call_needed;\n   rtx static_chain = NULL_RTX;\n \n   if (ix86_function_naked (current_function_decl))\n@@ -13024,6 +13037,8 @@ ix86_expand_prologue (void)\n \n   int_registers_saved = (frame.nregs == 0);\n   sse_registers_saved = (frame.nsseregs == 0);\n+  save_stub_call_needed = (m->call_ms2sysv);\n+  gcc_assert (sse_registers_saved || !save_stub_call_needed);\n \n   if (frame_pointer_needed && !m->fs.fp_valid)\n     {\n@@ -13118,10 +13133,28 @@ ix86_expand_prologue (void)\n \t target.  */\n       if (TARGET_SEH)\n \tm->fs.sp_valid = false;\n-    }\n \n-  if (m->call_ms2sysv)\n-    ix86_emit_outlined_ms2sysv_save (frame);\n+      /* If SP offset is non-immediate after allocation of the stack frame,\n+\t then emit SSE saves or stub call prior to allocating the rest of the\n+\t stack frame.  This is less efficient for the out-of-line stub because\n+\t we can't combine allocations across the call barrier, but it's better\n+\t than using a scratch register.  */\n+      else if (!x86_64_immediate_operand (GEN_INT (frame.stack_pointer_offset\n+\t\t\t\t\t\t   - m->fs.sp_realigned_offset),\n+\t\t\t\t\t  Pmode))\n+\t{\n+\t  if (!sse_registers_saved)\n+\t    {\n+\t      ix86_emit_save_sse_regs_using_mov (frame.sse_reg_save_offset);\n+\t      sse_registers_saved = true;\n+\t    }\n+\t  else if (save_stub_call_needed)\n+\t    {\n+\t      ix86_emit_outlined_ms2sysv_save (frame);\n+\t      save_stub_call_needed = false;\n+\t    }\n+\t}\n+    }\n \n   allocate = frame.stack_pointer_offset - m->fs.sp_offset;\n \n@@ -13349,6 +13382,8 @@ ix86_expand_prologue (void)\n     ix86_emit_save_regs_using_mov (frame.reg_save_offset);\n   if (!sse_registers_saved)\n     ix86_emit_save_sse_regs_using_mov (frame.sse_reg_save_offset);\n+  else if (save_stub_call_needed)\n+    ix86_emit_outlined_ms2sysv_save (frame);\n \n   /* For the mcount profiling on 32 bit PIC mode we need to emit SET_GOT\n      in PROLOGUE.  */\n@@ -13589,8 +13624,9 @@ ix86_emit_outlined_ms2sysv_restore (const struct ix86_frame &frame,\n \n   /* Setup RSI as the stub's base pointer.  */\n   align = GET_MODE_ALIGNMENT (V4SFmode);\n-  tmp = choose_baseaddr (rsi_offset, &align);\n+  tmp = choose_baseaddr (rsi_offset, &align, SI_REG);\n   gcc_assert (align >= GET_MODE_ALIGNMENT (V4SFmode));\n+\n   emit_insn (gen_rtx_SET (rsi, tmp));\n \n   /* Get a symbol for the stub.  */"}, {"sha": "e4ab15974e06b24b077d7366cd800efd9e7e7ee6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173399a0b4910ce027194cf4cc21d2a8856180d7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173399a0b4910ce027194cf4cc21d2a8856180d7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=173399a0b4910ce027194cf4cc21d2a8856180d7", "patch": "@@ -1,3 +1,8 @@\n+2017-11-04  Daniel Santos  <daniel.santos@pobox.com>\n+\n+\tgcc.target/i386/pr82002-2a.c: Change from xfail to fail.\n+\tgcc.target/i386/pr82002-2b.c: Likewise.\n+\n 2017-11-04  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \t* gfortran.dg/coarray/send_char_array_1.f90: New test."}, {"sha": "c31440debe26ce8d20acfe58dce318f08f275128", "filename": "gcc/testsuite/gcc.target/i386/pr82002-2a.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173399a0b4910ce027194cf4cc21d2a8856180d7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82002-2a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173399a0b4910ce027194cf4cc21d2a8856180d7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82002-2a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82002-2a.c?ref=173399a0b4910ce027194cf4cc21d2a8856180d7", "patch": "@@ -1,7 +1,5 @@\n /* { dg-do compile { target lp64 } } */\n /* { dg-options \"-Ofast -mstackrealign -mabi=ms\" } */\n-/* { dg-xfail-if \"\" { *-*-* }  } */\n-/* { dg-xfail-run-if \"\" { *-*-* }  } */\n \n void __attribute__((sysv_abi)) a (char *);\n void"}, {"sha": "939e069517d166b236f52c6e6707026248ce690c", "filename": "gcc/testsuite/gcc.target/i386/pr82002-2b.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173399a0b4910ce027194cf4cc21d2a8856180d7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82002-2b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173399a0b4910ce027194cf4cc21d2a8856180d7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82002-2b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82002-2b.c?ref=173399a0b4910ce027194cf4cc21d2a8856180d7", "patch": "@@ -1,7 +1,5 @@\n /* { dg-do compile { target lp64 } } */\n /* { dg-options \"-Ofast -mstackrealign -mabi=ms -mcall-ms2sysv-xlogues\" } */\n-/* { dg-xfail-if \"\" { *-*-* }  } */\n-/* { dg-xfail-run-if \"\" { *-*-* }  } */\n \n void __attribute__((sysv_abi)) a (char *);\n void"}]}