{"sha": "26e0e4107be8104724d3ce21c7f093cee15a4365", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZlMGU0MTA3YmU4MTA0NzI0ZDNjZTIxYzdmMDkzY2VlMTVhNDM2NQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-14T18:27:19Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-14T18:27:19Z"}, "message": "dominance.c (struct dom_info): Add fake_exit_edge.\n\n        * dominance.c (struct dom_info): Add fake_exit_edge.\n        (init_dom_info): Allocate it.\n        (free_dom_info): Free it.\n        (calc_dfs_tree): Set it.  Handle noreturn and infinite loops\n        in two passes.\n        (calc_idoms): Honor fake_exit_edge.\n\nFrom-SVN: r84697", "tree": {"sha": "09f77bf8b6c081b8b2777050d1a7121b427684b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09f77bf8b6c081b8b2777050d1a7121b427684b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26e0e4107be8104724d3ce21c7f093cee15a4365", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26e0e4107be8104724d3ce21c7f093cee15a4365", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26e0e4107be8104724d3ce21c7f093cee15a4365", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26e0e4107be8104724d3ce21c7f093cee15a4365/comments", "author": null, "committer": null, "parents": [{"sha": "0c322af34a9bdd8bce4b32a0aab0777580b20b9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c322af34a9bdd8bce4b32a0aab0777580b20b9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c322af34a9bdd8bce4b32a0aab0777580b20b9b"}], "stats": {"total": 83, "additions": 70, "deletions": 13}, "files": [{"sha": "166737dd3bd6053fbd5fd47bb9509006d3f1bfce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e0e4107be8104724d3ce21c7f093cee15a4365/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e0e4107be8104724d3ce21c7f093cee15a4365/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26e0e4107be8104724d3ce21c7f093cee15a4365", "patch": "@@ -1,3 +1,12 @@\n+2004-07-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* dominance.c (struct dom_info): Add fake_exit_edge.\n+\t(init_dom_info): Allocate it.\n+\t(free_dom_info): Free it.\n+\t(calc_dfs_tree): Set it.  Handle noreturn and infinite loops\n+\tin two passes.\n+\t(calc_idoms): Honor fake_exit_edge.\n+\n 2004-07-13  Jason Merrill  <jason@redhat.com>\n \n \t* tree-gimple.c (is_gimple_reg_rhs, is_gimple_mem_rhs): New fns."}, {"sha": "156fc98b6e0ae78d15b1c604084ebcd3c921a853", "filename": "gcc/dominance.c", "status": "modified", "additions": 61, "deletions": 13, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e0e4107be8104724d3ce21c7f093cee15a4365/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e0e4107be8104724d3ce21c7f093cee15a4365/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=26e0e4107be8104724d3ce21c7f093cee15a4365", "patch": "@@ -101,13 +101,17 @@ struct dom_info\n      is true for every basic block bb, but not the opposite.  */\n   basic_block *dfs_to_bb;\n \n-  /* This is the next free DFS number when creating the DFS tree or forest.  */\n+  /* This is the next free DFS number when creating the DFS tree.  */\n   unsigned int dfsnum;\n   /* The number of nodes in the DFS tree (==dfsnum-1).  */\n   unsigned int nodes;\n+\n+  /* Blocks with bits set here have a fake edge to EXIT.  These are used\n+     to turn a DFS forest into a proper tree.  */\n+  bitmap fake_exit_edge;\n };\n \n-static void init_dom_info (struct dom_info *);\n+static void init_dom_info (struct dom_info *, enum cdi_direction);\n static void free_dom_info (struct dom_info *);\n static void calc_dfs_tree_nonrec (struct dom_info *, basic_block,\n \t\t\t\t  enum cdi_direction);\n@@ -142,7 +146,7 @@ static unsigned n_bbs_in_dom_tree[2];\n    This initializes the contents of DI, which already must be allocated.  */\n \n static void\n-init_dom_info (struct dom_info *di)\n+init_dom_info (struct dom_info *di, enum cdi_direction dir)\n {\n   /* We need memory for n_basic_blocks nodes and the ENTRY_BLOCK or\n      EXIT_BLOCK.  */\n@@ -164,6 +168,8 @@ init_dom_info (struct dom_info *di)\n \n   di->dfsnum = 1;\n   di->nodes = 0;\n+\n+  di->fake_exit_edge = dir ? BITMAP_XMALLOC () : NULL;\n }\n \n #undef init_ar\n@@ -184,6 +190,7 @@ free_dom_info (struct dom_info *di)\n   free (di->set_child);\n   free (di->dfs_order);\n   free (di->dfs_to_bb);\n+  BITMAP_XFREE (di->fake_exit_edge);\n }\n \n /* The nonrecursive variant of creating a DFS tree.  DI is our working\n@@ -193,9 +200,9 @@ free_dom_info (struct dom_info *di)\n    assigned their dfs number and are linked together to form a tree.  */\n \n static void\n-calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb, enum cdi_direction reverse)\n+calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb,\n+\t\t      enum cdi_direction reverse)\n {\n-  /* We never call this with bb==EXIT_BLOCK_PTR (ENTRY_BLOCK_PTR if REVERSE).  */\n   /* We call this _only_ if bb is not already visited.  */\n   edge e;\n   TBB child_i, my_i = 0;\n@@ -322,18 +329,47 @@ calc_dfs_tree (struct dom_info *di, enum cdi_direction reverse)\n     {\n       /* In the post-dom case we may have nodes without a path to EXIT_BLOCK.\n          They are reverse-unreachable.  In the dom-case we disallow such\n-         nodes, but in post-dom we have to deal with them, so we simply\n-         include them in the DFS tree which actually becomes a forest.  */\n+         nodes, but in post-dom we have to deal with them.\n+\n+\t There are two situations in which this occurs.  First, noreturn\n+\t functions.  Second, infinite loops.  In the first case we need to\n+\t pretend that there is an edge to the exit block.  In the second\n+\t case, we wind up with a forest.  We need to process all noreturn\n+\t blocks before we know if we've got any infinite loops.  */\n+\n       basic_block b;\n+      bool saw_unconnected = false;\n+\n       FOR_EACH_BB_REVERSE (b)\n \t{\n-\t  if (di->dfs_order[b->index])\n-\t    continue;\n+\t  if (b->succ)\n+\t    {\n+\t      if (di->dfs_order[b->index] == 0)\n+\t\tsaw_unconnected = true;\n+\t      continue;\n+\t    }\n+\t  bitmap_set_bit (di->fake_exit_edge, b->index);\n \t  di->dfs_order[b->index] = di->dfsnum;\n \t  di->dfs_to_bb[di->dfsnum] = b;\n+\t  di->dfs_parent[di->dfsnum] = di->dfs_order[last_basic_block];\n \t  di->dfsnum++;\n \t  calc_dfs_tree_nonrec (di, b, reverse);\n \t}\n+\n+      if (saw_unconnected)\n+\t{\n+\t  FOR_EACH_BB_REVERSE (b)\n+\t    {\n+\t      if (di->dfs_order[b->index])\n+\t\tcontinue;\n+\t      bitmap_set_bit (di->fake_exit_edge, b->index);\n+\t      di->dfs_order[b->index] = di->dfsnum;\n+\t      di->dfs_to_bb[di->dfsnum] = b;\n+\t      di->dfs_parent[di->dfsnum] = di->dfs_order[last_basic_block];\n+\t      di->dfsnum++;\n+\t      calc_dfs_tree_nonrec (di, b, reverse);\n+\t    }\n+\t}\n     }\n \n   di->nodes = di->dfsnum - 1;\n@@ -459,15 +495,24 @@ calc_idoms (struct dom_info *di, enum cdi_direction reverse)\n       par = di->dfs_parent[v];\n       k = v;\n       if (reverse)\n-\te = bb->succ;\n+\t{\n+\t  e = bb->succ;\n+\n+\t  /* If this block has a fake edge to exit, process that first.  */\n+\t  if (bitmap_bit_p (di->fake_exit_edge, bb->index))\n+\t    {\n+\t      e_next = e;\n+\t      goto do_fake_exit_edge;\n+\t    }\n+\t}\n       else\n \te = bb->pred;\n \n       /* Search all direct predecessors for the smallest node with a path\n          to them.  That way we have the smallest node with also a path to\n          us only over nodes behind us.  In effect we search for our\n          semidominator.  */\n-      for (; e; e = e_next)\n+      for (; e ; e = e_next)\n \t{\n \t  TBB k1;\n \t  basic_block b;\n@@ -483,7 +528,10 @@ calc_idoms (struct dom_info *di, enum cdi_direction reverse)\n \t      e_next = e->pred_next;\n \t    }\n \t  if (b == en_block)\n-\t    k1 = di->dfs_order[last_basic_block];\n+\t    {\n+\t    do_fake_exit_edge:\n+\t      k1 = di->dfs_order[last_basic_block];\n+\t    }\n \t  else\n \t    k1 = di->dfs_order[b->index];\n \n@@ -590,7 +638,7 @@ calculate_dominance_info (enum cdi_direction dir)\n \t}\n       n_bbs_in_dom_tree[dir] = n_basic_blocks + 2;\n \n-      init_dom_info (&di);\n+      init_dom_info (&di, dir);\n       calc_dfs_tree (&di, dir);\n       calc_idoms (&di, dir);\n "}]}