{"sha": "bcc478b9647e2af4b715fda6676d98f1e129d16b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNjNDc4Yjk2NDdlMmFmNGI3MTVmZGE2Njc2ZDk4ZjFlMTI5ZDE2Yg==", "commit": {"author": {"name": "Bernhard Reutner-Fischer", "email": "aldot@gcc.gnu.org", "date": "2017-10-19T07:24:33Z"}, "committer": {"name": "Bernhard Reutner-Fischer", "email": "aldot@gcc.gnu.org", "date": "2017-10-19T07:24:33Z"}, "message": "Use Levenshtein spelling suggestions in Fortran FE\n\ngcc/fortran/ChangeLog\n\n2017-10-19  Bernhard Reutner-Fischer  <aldot@gcc.gnu.org>\n\n\t* gfortran.h (gfc_lookup_function_fuzzy): New declaration.\n\t(gfc_closest_fuzzy_match): New declaration.\n\t(vec_push): New definition.\n\t* misc.c (gfc_closest_fuzzy_match): New definition.\n\t* resolve.c: Include spellcheck.h.\n\t(lookup_function_fuzzy_find_candidates): New static function.\n\t(lookup_uop_fuzzy_find_candidates): Likewise.\n\t(lookup_uop_fuzzy): Likewise.\n\t(resolve_operator) <INTRINSIC_USER>: Call lookup_uop_fuzzy.\n\t(gfc_lookup_function_fuzzy): New definition.\n\t(resolve_unknown_f): Call gfc_lookup_function_fuzzy.\n\t* interface.c (check_interface0): Likewise.\n\t(lookup_arg_fuzzy_find_candidates): New static function.\n\t(lookup_arg_fuzzy ): Likewise.\n\t(compare_actual_formal): Call lookup_arg_fuzzy.\n\t* symbol.c: Include spellcheck.h.\n\t(lookup_symbol_fuzzy_find_candidates): New static function.\n\t(lookup_symbol_fuzzy): Likewise.\n\t(gfc_set_default_type): Call lookup_symbol_fuzzy.\n\t(lookup_component_fuzzy_find_candidates): New static function.\n\t(lookup_component_fuzzy): Likewise.\n\t(gfc_find_component): Call lookup_component_fuzzy.\n\ngcc/testsuite/ChangeLog\n\n2017-10-19  Bernhard Reutner-Fischer  <aldot@gcc.gnu.org>\n\n\t* gfortran.dg/spellcheck-operator.f90: New testcase.\n\t* gfortran.dg/spellcheck-procedure_1.f90: New testcase.\n\t* gfortran.dg/spellcheck-procedure_2.f90: New testcase.\n\t* gfortran.dg/spellcheck-structure.f90: New testcase.\n\t* gfortran.dg/spellcheck-parameter.f90: New testcase.\n\nFrom-SVN: r253877", "tree": {"sha": "78eb982a4151306d46381aacdf1b5298544bdac2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78eb982a4151306d46381aacdf1b5298544bdac2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcc478b9647e2af4b715fda6676d98f1e129d16b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcc478b9647e2af4b715fda6676d98f1e129d16b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcc478b9647e2af4b715fda6676d98f1e129d16b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcc478b9647e2af4b715fda6676d98f1e129d16b/comments", "author": null, "committer": null, "parents": [{"sha": "fba832054d9467a296d126754cc3a5efca707bdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fba832054d9467a296d126754cc3a5efca707bdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fba832054d9467a296d126754cc3a5efca707bdf"}], "stats": {"total": 500, "additions": 483, "deletions": 17}, "files": [{"sha": "0181c06b34767265b9768b8b4b4dd76b7c5ef517", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=bcc478b9647e2af4b715fda6676d98f1e129d16b", "patch": "@@ -1,3 +1,28 @@\n+2017-10-19  Bernhard Reutner-Fischer  <aldot@gcc.gnu.org>\n+\n+\t* gfortran.h (gfc_lookup_function_fuzzy): New declaration.\n+\t(gfc_closest_fuzzy_match): New declaration.\n+\t(vec_push): New definition.\n+\t* misc.c (gfc_closest_fuzzy_match): New definition.\n+\t* resolve.c: Include spellcheck.h.\n+\t(lookup_function_fuzzy_find_candidates): New static function.\n+\t(lookup_uop_fuzzy_find_candidates): Likewise.\n+\t(lookup_uop_fuzzy): Likewise.\n+\t(resolve_operator) <INTRINSIC_USER>: Call lookup_uop_fuzzy.\n+\t(gfc_lookup_function_fuzzy): New definition.\n+\t(resolve_unknown_f): Call gfc_lookup_function_fuzzy.\n+\t* interface.c (check_interface0): Likewise.\n+\t(lookup_arg_fuzzy_find_candidates): New static function.\n+\t(lookup_arg_fuzzy ): Likewise.\n+\t(compare_actual_formal): Call lookup_arg_fuzzy.\n+\t* symbol.c: Include spellcheck.h.\n+\t(lookup_symbol_fuzzy_find_candidates): New static function.\n+\t(lookup_symbol_fuzzy): Likewise.\n+\t(gfc_set_default_type): Call lookup_symbol_fuzzy.\n+\t(lookup_component_fuzzy_find_candidates): New static function.\n+\t(lookup_component_fuzzy): Likewise.\n+\t(gfc_find_component): Call lookup_component_fuzzy.\n+\n 2017-10-18  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/82567"}, {"sha": "cdf2b54f0b6524d52383c9827ce52a4204d40157", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=bcc478b9647e2af4b715fda6676d98f1e129d16b", "patch": "@@ -2796,6 +2796,17 @@ void gfc_done_2 (void);\n \n int get_c_kind (const char *, CInteropKind_t *);\n \n+const char *gfc_closest_fuzzy_match (const char *, char **);\n+static inline void\n+vec_push (char **&optr, size_t &osz, const char *elt)\n+{\n+  /* {auto,}vec.safe_push () replacement.  Don't ask..  */\n+  // if (strlen (elt) < 4) return; premature optimization: eliminated by cutoff\n+  optr = XRESIZEVEC (char *, optr, osz + 2);\n+  optr[osz] = CONST_CAST (char *, elt);\n+  optr[++osz] = NULL;\n+}\n+\n /* options.c */\n unsigned int gfc_option_lang_mask (void);\n void gfc_init_options_struct (struct gcc_options *);\n@@ -3228,6 +3239,7 @@ bool gfc_type_is_extensible (gfc_symbol *);\n bool gfc_resolve_intrinsic (gfc_symbol *, locus *);\n bool gfc_explicit_interface_required (gfc_symbol *, char *, int);\n extern int gfc_do_concurrent_flag;\n+const char* gfc_lookup_function_fuzzy (const char *, gfc_symtree *);\n \n \n /* array.c */"}, {"sha": "b4f5a4dcce1955c9f1743cc908f67aa02baa30c5", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 63, "deletions": 9, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=bcc478b9647e2af4b715fda6676d98f1e129d16b", "patch": "@@ -1793,13 +1793,27 @@ check_interface0 (gfc_interface *p, const char *interface_name)\n \t   || !p->sym->attr.if_source)\n \t  && !gfc_fl_struct (p->sym->attr.flavor))\n \t{\n+\t  const char *guessed\n+\t    = gfc_lookup_function_fuzzy (p->sym->name, p->sym->ns->sym_root);\n+\n \t  if (p->sym->attr.external)\n-\t    gfc_error (\"Procedure %qs in %s at %L has no explicit interface\",\n-\t\t       p->sym->name, interface_name, &p->sym->declared_at);\n+\t    if (guessed)\n+\t      gfc_error (\"Procedure %qs in %s at %L has no explicit interface\"\n+\t\t\t \"; did you mean %qs?\",\n+\t\t\t p->sym->name, interface_name, &p->sym->declared_at,\n+\t\t\t guessed);\n+\t    else\n+\t      gfc_error (\"Procedure %qs in %s at %L has no explicit interface\",\n+\t\t\t p->sym->name, interface_name, &p->sym->declared_at);\n \t  else\n-\t    gfc_error (\"Procedure %qs in %s at %L is neither function nor \"\n-\t\t       \"subroutine\", p->sym->name, interface_name,\n-\t\t      &p->sym->declared_at);\n+\t    if (guessed)\n+\t      gfc_error (\"Procedure %qs in %s at %L is neither function nor \"\n+\t\t\t \"subroutine; did you mean %qs?\", p->sym->name,\n+\t\t\tinterface_name, &p->sym->declared_at, guessed);\n+\t    else\n+\t      gfc_error (\"Procedure %qs in %s at %L is neither function nor \"\n+\t\t\t \"subroutine\", p->sym->name, interface_name,\n+\t\t\t&p->sym->declared_at);\n \t  return true;\n \t}\n \n@@ -2778,6 +2792,31 @@ is_procptr_result (gfc_expr *expr)\n }\n \n \n+/* Recursively append candidate argument ARG to CANDIDATES.  Store the\n+   number of total candidates in CANDIDATES_LEN.  */\n+\n+static void\n+lookup_arg_fuzzy_find_candidates (gfc_formal_arglist *arg,\n+\t\t\t\t  char **&candidates,\n+\t\t\t\t  size_t &candidates_len)\n+{\n+  for (gfc_formal_arglist *p = arg; p && p->sym; p = p->next)\n+    vec_push (candidates, candidates_len, p->sym->name);\n+}\n+\n+\n+/* Lookup argument ARG fuzzily, taking names in ARGUMENTS into account.  */\n+\n+static const char*\n+lookup_arg_fuzzy (const char *arg, gfc_formal_arglist *arguments)\n+{\n+  char **candidates = NULL;\n+  size_t candidates_len = 0;\n+  lookup_arg_fuzzy_find_candidates (arguments, candidates, candidates_len);\n+  return gfc_closest_fuzzy_match (arg, candidates);\n+}\n+\n+\n /* Given formal and actual argument lists, see if they are compatible.\n    If they are compatible, the actual argument list is sorted to\n    correspond with the formal list, and elements for missing optional\n@@ -2831,8 +2870,16 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  if (f == NULL)\n \t    {\n \t      if (where)\n-\t\tgfc_error (\"Keyword argument %qs at %L is not in \"\n-\t\t\t   \"the procedure\", a->name, &a->expr->where);\n+\t\t{\n+\t\t  const char *guessed = lookup_arg_fuzzy (a->name, formal);\n+\t\t  if (guessed)\n+\t\t    gfc_error (\"Keyword argument %qs at %L is not in \"\n+\t\t\t       \"the procedure; did you mean %qs?\",\n+\t\t\t       a->name, &a->expr->where, guessed);\n+\t\t  else\n+\t\t    gfc_error (\"Keyword argument %qs at %L is not in \"\n+\t\t\t       \"the procedure\", a->name, &a->expr->where);\n+\t\t}\n \t      return false;\n \t    }\n \n@@ -3552,8 +3599,15 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n     {\n       if (sym->ns->has_implicit_none_export && sym->attr.proc == PROC_UNKNOWN)\n \t{\n-\t  gfc_error (\"Procedure %qs called at %L is not explicitly declared\",\n-\t\t     sym->name, where);\n+\t  const char *guessed\n+\t    = gfc_lookup_function_fuzzy (sym->name, sym->ns->sym_root);\n+\t  if (guessed)\n+\t    gfc_error (\"Procedure %qs called at %L is not explicitly declared\"\n+\t\t       \"; did you mean %qs?\",\n+\t\t       sym->name, where, guessed);\n+\t  else\n+\t    gfc_error (\"Procedure %qs called at %L is not explicitly declared\",\n+\t\t       sym->name, where);\n \t  return false;\n \t}\n       if (warn_implicit_interface)"}, {"sha": "f47d111ba47e0627f3115fc0773849f27fb0e1c2", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=bcc478b9647e2af4b715fda6676d98f1e129d16b", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"gfortran.h\"\n+#include \"spellcheck.h\"\n \n \n /* Initialize a typespec to unknown.  */\n@@ -280,3 +281,43 @@ get_c_kind(const char *c_kind_name, CInteropKind_t kinds_table[])\n \n   return ISOCBINDING_INVALID;\n }\n+\n+\n+/* For a given name TYPO, determine the best candidate from CANDIDATES\n+   perusing Levenshtein distance.  Frees CANDIDATES before returning.  */\n+\n+const char *\n+gfc_closest_fuzzy_match (const char *typo, char **candidates)\n+{\n+  /* Determine closest match.  */\n+  const char *best = NULL;\n+  char **cand = candidates;\n+  edit_distance_t best_distance = MAX_EDIT_DISTANCE;\n+  const size_t tl = strlen (typo);\n+\n+  while (cand && *cand)\n+    {\n+      edit_distance_t dist = levenshtein_distance (typo, tl, *cand,\n+\t  strlen (*cand));\n+      if (dist < best_distance)\n+\t{\n+\t   best_distance = dist;\n+\t   best = *cand;\n+\t}\n+      cand++;\n+    }\n+  /* If more than half of the letters were misspelled, the suggestion is\n+     likely to be meaningless.  */\n+  if (best)\n+    {\n+      unsigned int cutoff = MAX (tl, strlen (best)) / 2;\n+\n+      if (best_distance > cutoff)\n+\t{\n+\t  XDELETEVEC (candidates);\n+\t  return NULL;\n+\t}\n+      XDELETEVEC (candidates);\n+    }\n+  return best;\n+}"}, {"sha": "0188bddea6fed357386f8467df70866dffb94a2c", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 96, "deletions": 4, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=bcc478b9647e2af4b715fda6676d98f1e129d16b", "patch": "@@ -2801,6 +2801,43 @@ resolve_specific_f (gfc_expr *expr)\n   return true;\n }\n \n+/* Recursively append candidate SYM to CANDIDATES.  Store the number of\n+   candidates in CANDIDATES_LEN.  */\n+\n+static void\n+lookup_function_fuzzy_find_candidates (gfc_symtree *sym,\n+\t\t\t\t       char **&candidates,\n+\t\t\t\t       size_t &candidates_len)\n+{\n+  gfc_symtree *p;\n+\n+  if (sym == NULL)\n+    return;\n+  if ((sym->n.sym->ts.type != BT_UNKNOWN || sym->n.sym->attr.external)\n+      && sym->n.sym->attr.flavor == FL_PROCEDURE)\n+    vec_push (candidates, candidates_len, sym->name);\n+\n+  p = sym->left;\n+  if (p)\n+    lookup_function_fuzzy_find_candidates (p, candidates, candidates_len);\n+\n+  p = sym->right;\n+  if (p)\n+    lookup_function_fuzzy_find_candidates (p, candidates, candidates_len);\n+}\n+\n+\n+/* Lookup function FN fuzzily, taking names in SYMROOT into account.  */\n+\n+const char*\n+gfc_lookup_function_fuzzy (const char *fn, gfc_symtree *symroot)\n+{\n+  char **candidates = NULL;\n+  size_t candidates_len = 0;\n+  lookup_function_fuzzy_find_candidates (symroot, candidates, candidates_len);\n+  return gfc_closest_fuzzy_match (fn, candidates);\n+}\n+\n \n /* Resolve a procedure call not known to be generic nor specific.  */\n \n@@ -2851,8 +2888,15 @@ resolve_unknown_f (gfc_expr *expr)\n \n       if (ts->type == BT_UNKNOWN)\n \t{\n-\t  gfc_error (\"Function %qs at %L has no IMPLICIT type\",\n-\t\t     sym->name, &expr->where);\n+\t  const char *guessed\n+\t    = gfc_lookup_function_fuzzy (sym->name, sym->ns->sym_root);\n+\t  if (guessed)\n+\t    gfc_error (\"Function %qs at %L has no IMPLICIT type\"\n+\t\t       \"; did you mean %qs?\",\n+\t\t       sym->name, &expr->where, guessed);\n+\t  else\n+\t    gfc_error (\"Function %qs at %L has no IMPLICIT type\",\n+\t\t       sym->name, &expr->where);\n \t  return false;\n \t}\n       else\n@@ -3713,6 +3757,46 @@ logical_to_bitwise (gfc_expr *e)\n   return e;\n }\n \n+/* Recursively append candidate UOP to CANDIDATES.  Store the number of\n+   candidates in CANDIDATES_LEN.  */\n+static void\n+lookup_uop_fuzzy_find_candidates (gfc_symtree *uop,\n+\t\t\t\t  char **&candidates,\n+\t\t\t\t  size_t &candidates_len)\n+{\n+  gfc_symtree *p;\n+\n+  if (uop == NULL)\n+    return;\n+\n+  /* Not sure how to properly filter here.  Use all for a start.\n+     n.uop.op is NULL for empty interface operators (is that legal?) disregard\n+     these as i suppose they don't make terribly sense.  */\n+\n+  if (uop->n.uop->op != NULL)\n+    vec_push (candidates, candidates_len, uop->name);\n+\n+  p = uop->left;\n+  if (p)\n+    lookup_uop_fuzzy_find_candidates (p, candidates, candidates_len);\n+\n+  p = uop->right;\n+  if (p)\n+    lookup_uop_fuzzy_find_candidates (p, candidates, candidates_len);\n+}\n+\n+/* Lookup user-operator OP fuzzily, taking names in UOP into account.  */\n+\n+static const char*\n+lookup_uop_fuzzy (const char *op, gfc_symtree *uop)\n+{\n+  char **candidates = NULL;\n+  size_t candidates_len = 0;\n+  lookup_uop_fuzzy_find_candidates (uop, candidates, candidates_len);\n+  return gfc_closest_fuzzy_match (op, candidates);\n+}\n+\n+\n /* Resolve an operator expression node.  This can involve replacing the\n    operation with a user defined function call.  */\n \n@@ -3935,8 +4019,16 @@ resolve_operator (gfc_expr *e)\n \n     case INTRINSIC_USER:\n       if (e->value.op.uop->op == NULL)\n-\tsprintf (msg, _(\"Unknown operator %%<%s%%> at %%L\"),\n-\t\t e->value.op.uop->name);\n+\t{\n+\t  const char *name = e->value.op.uop->name;\n+\t  const char *guessed;\n+\t  guessed = lookup_uop_fuzzy (name, e->value.op.uop->ns->uop_root);\n+\t  if (guessed)\n+\t    sprintf (msg, _(\"Unknown operator %%<%s%%> at %%L; did you mean '%s'?\"),\n+\t\tname, guessed);\n+\t  else\n+\t    sprintf (msg, _(\"Unknown operator %%<%s%%> at %%L\"), name);\n+\t}\n       else if (op2 == NULL)\n \tsprintf (msg, _(\"Operand of user operator %%<%s%%> at %%L is %s\"),\n \t\t e->value.op.uop->name, gfc_typename (&op1->ts));"}, {"sha": "36abba5a4881e2d498ac69b0299b919350942e4d", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 82, "deletions": 4, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=bcc478b9647e2af4b715fda6676d98f1e129d16b", "patch": "@@ -245,6 +245,44 @@ gfc_get_default_type (const char *name, gfc_namespace *ns)\n }\n \n \n+/* Recursively append candidate SYM to CANDIDATES.  Store the number of\n+   candidates in CANDIDATES_LEN.  */\n+\n+static void\n+lookup_symbol_fuzzy_find_candidates (gfc_symtree *sym,\n+\t\t\t\t     char **&candidates,\n+\t\t\t\t     size_t &candidates_len)\n+{\n+  gfc_symtree *p;\n+\n+  if (sym == NULL)\n+    return;\n+\n+  if (sym->n.sym->ts.type != BT_UNKNOWN && sym->n.sym->ts.type != BT_PROCEDURE)\n+    vec_push (candidates, candidates_len, sym->name);\n+  p = sym->left;\n+  if (p)\n+    lookup_symbol_fuzzy_find_candidates (p, candidates, candidates_len);\n+\n+  p = sym->right;\n+  if (p)\n+    lookup_symbol_fuzzy_find_candidates (p, candidates, candidates_len);\n+}\n+\n+\n+/* Lookup symbol SYM_NAME fuzzily, taking names in SYMBOL into account.  */\n+\n+static const char*\n+lookup_symbol_fuzzy (const char *sym_name, gfc_symbol *symbol)\n+{\n+  char **candidates = NULL;\n+  size_t candidates_len = 0;\n+  lookup_symbol_fuzzy_find_candidates (symbol->ns->sym_root, candidates,\n+\t\t\t\t       candidates_len);\n+  return gfc_closest_fuzzy_match (sym_name, candidates);\n+}\n+\n+\n /* Given a pointer to a symbol, set its type according to the first\n    letter of its name.  Fails if the letter in question has no default\n    type.  */\n@@ -263,8 +301,14 @@ gfc_set_default_type (gfc_symbol *sym, int error_flag, gfc_namespace *ns)\n     {\n       if (error_flag && !sym->attr.untyped)\n \t{\n-\t  gfc_error (\"Symbol %qs at %L has no IMPLICIT type\",\n-\t\t     sym->name, &sym->declared_at);\n+\t  const char *guessed = lookup_symbol_fuzzy (sym->name, sym);\n+\t  if (guessed)\n+\t    gfc_error (\"Symbol %qs at %L has no IMPLICIT type\"\n+\t\t       \"; did you mean %qs?\",\n+\t\t       sym->name, &sym->declared_at, guessed);\n+\t  else\n+\t    gfc_error (\"Symbol %qs at %L has no IMPLICIT type\",\n+\t\t       sym->name, &sym->declared_at);\n \t  sym->attr.untyped = 1; /* Ensure we only give an error once.  */\n \t}\n \n@@ -2336,6 +2380,32 @@ find_union_component (gfc_symbol *un, const char *name,\n }\n \n \n+/* Recursively append candidate COMPONENT structures to CANDIDATES.  Store\n+   the number of total candidates in CANDIDATES_LEN.  */\n+\n+static void\n+lookup_component_fuzzy_find_candidates (gfc_component *component,\n+\t\t\t\t\tchar **&candidates,\n+\t\t\t\t\tsize_t &candidates_len)\n+{\n+  for (gfc_component *p = component; p; p = p->next)\n+    vec_push (candidates, candidates_len, p->name);\n+}\n+\n+\n+/* Lookup component MEMBER fuzzily, taking names in COMPONENT into account.  */\n+\n+static const char*\n+lookup_component_fuzzy (const char *member, gfc_component *component)\n+{\n+  char **candidates = NULL;\n+  size_t candidates_len = 0;\n+  lookup_component_fuzzy_find_candidates (component, candidates,\n+\t\t\t\t\t  candidates_len);\n+  return gfc_closest_fuzzy_match (member, candidates);\n+}\n+\n+\n /* Given a derived type node and a component name, try to locate the\n    component structure.  Returns the NULL pointer if the component is\n    not found or the components are private.  If noaccess is set, no access\n@@ -2433,8 +2503,16 @@ gfc_find_component (gfc_symbol *sym, const char *name,\n     }\n \n   if (p == NULL && !silent)\n-    gfc_error (\"%qs at %C is not a member of the %qs structure\",\n-\t       name, sym->name);\n+    {\n+      const char *guessed = lookup_component_fuzzy (name, sym->components);\n+      if (guessed)\n+\tgfc_error (\"%qs at %C is not a member of the %qs structure\"\n+\t\t   \"; did you mean %qs?\",\n+\t\t   name, sym->name, guessed);\n+      else\n+\tgfc_error (\"%qs at %C is not a member of the %qs structure\",\n+\t\t   name, sym->name);\n+    }\n \n   /* Component was found; build the ultimate component reference. */\n   if (p != NULL && ref)"}, {"sha": "971a9c4a65e9f9c5705f284b6199be07b9398040", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bcc478b9647e2af4b715fda6676d98f1e129d16b", "patch": "@@ -1,3 +1,11 @@\n+2017-10-19  Bernhard Reutner-Fischer  <aldot@gcc.gnu.org>\n+\n+\t* gfortran.dg/spellcheck-operator.f90: New testcase.\n+\t* gfortran.dg/spellcheck-procedure_1.f90: New testcase.\n+\t* gfortran.dg/spellcheck-procedure_2.f90: New testcase.\n+\t* gfortran.dg/spellcheck-structure.f90: New testcase.\n+\t* gfortran.dg/spellcheck-parameter.f90: New testcase.\n+\n 2017-10-18  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/82567"}, {"sha": "810a770698b8663580143149fc530f4acfbb3327", "filename": "gcc/testsuite/gfortran.dg/spellcheck-operator.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ftestsuite%2Fgfortran.dg%2Fspellcheck-operator.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ftestsuite%2Fgfortran.dg%2Fspellcheck-operator.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fspellcheck-operator.f90?ref=bcc478b9647e2af4b715fda6676d98f1e129d16b", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do compile }\n+! test levenshtein based spelling suggestions\n+\n+module mymod1\n+  implicit none\n+  contains\n+    function something_good (iarg1)\n+      integer :: something_good\n+      integer, intent(in) :: iarg1\n+      something_good = iarg1 + 42\n+    end function something_good\n+end module mymod1\n+\n+program spellchekc\n+  use mymod1\n+  implicit none\n+\n+  interface operator (.mywrong.)\n+    module procedure something_wring ! { dg-error \"Procedure .something_wring. in operator interface .mywrong. at .1. is neither function nor subroutine; did you mean .something_good.\\\\?|User operator procedure .something_wring. at .1. must be a FUNCTION\" }\n+  end interface\n+\n+  interface operator (.mygood.)\n+    module procedure something_good\n+  end interface\n+\n+  integer :: i, j, added\n+  i = 0\n+  j = 0\n+  added = .mygoof. j ! { dg-error \"Unknown operator .mygoof. at .1.; did you mean .mygood.\\\\?\" }\n+end program spellchekc"}, {"sha": "715c5abcce79d432d70d33ce6d0e931d21b72e70", "filename": "gcc/testsuite/gfortran.dg/spellcheck-parameter.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ftestsuite%2Fgfortran.dg%2Fspellcheck-parameter.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ftestsuite%2Fgfortran.dg%2Fspellcheck-parameter.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fspellcheck-parameter.f90?ref=bcc478b9647e2af4b715fda6676d98f1e129d16b", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! Contributed by Joost VandeVondele\n+! test levenshtein based spelling suggestions for keyword arguments\n+\n+module test\n+contains\n+  subroutine mysub(iarg1)\n+    integer :: iarg1\n+  end subroutine\n+end module\n+\n+use test\n+call mysub(iarg=1) ! { dg-error \"Keyword argument .iarg. at .1. is not in the procedure; did you mean .iarg1.\\\\?\" }\n+\n+end"}, {"sha": "3b7f71694689ae25f4c3c889d9dd2a216c3150aa", "filename": "gcc/testsuite/gfortran.dg/spellcheck-procedure_1.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ftestsuite%2Fgfortran.dg%2Fspellcheck-procedure_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ftestsuite%2Fgfortran.dg%2Fspellcheck-procedure_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fspellcheck-procedure_1.f90?ref=bcc478b9647e2af4b715fda6676d98f1e129d16b", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do compile }\n+! test levenshtein based spelling suggestions\n+\n+module mymod1\n+  implicit none\n+  contains\n+    function something_else (iarg1)\n+      integer :: something_else\n+      integer, intent(in) :: iarg1\n+      something_else = iarg1 + 42\n+    end function something_else\n+    function add_fourtytwo (iarg1)\n+      integer :: add_fourtytwo\n+      integer, intent(in) :: iarg1\n+      add_fourtytwo = iarg1 + 42\n+    end function add_fourtytwo\n+end module mymod1\n+\n+function myadd(iarg1, iarg2)\n+  implicit none\n+  integer :: myadd\n+  integer, intent(in) :: iarg1, iarg2\n+  myadd = iarg1 + iarg2\n+end function myadd\n+\n+program spellchekc\n+  use mymod1, something_good => something_else\n+  implicit none\n+\n+  integer :: myadd, i, j, myvar\n+  i = 0\n+  j = 0\n+\n+  j = something_goof(j) ! { dg-error \"no IMPLICIT type; did you mean .something_good.\\\\?\" }\n+  j = myaddd(i, j) ! { dg-error \"no IMPLICIT type; did you mean .myadd.\\\\?\" }\n+  if (j /= 42) call abort\n+  j = add_fourtytow(i, j) ! { dg-error \"no IMPLICIT type; did you mean .add_fourtytwo.\\\\?\" }\n+  myval = myadd(i, j) ! { dg-error \"no IMPLICIT type; did you mean .myvar.\\\\?\" }\n+  if (j /= 42 * 2) call abort\n+\n+end program spellchekc"}, {"sha": "a6ea5f9f280e1ff16c28fdb991734b5362ee2c11", "filename": "gcc/testsuite/gfortran.dg/spellcheck-procedure_2.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ftestsuite%2Fgfortran.dg%2Fspellcheck-procedure_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ftestsuite%2Fgfortran.dg%2Fspellcheck-procedure_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fspellcheck-procedure_2.f90?ref=bcc478b9647e2af4b715fda6676d98f1e129d16b", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do compile }\n+! test levenshtein based spelling suggestions\n+\n+\n+program spellchekc\n+  implicit none (external) ! { dg-warning \"GNU Extension: IMPORT NONE with spec list\" }\n+\n+  interface\n+    subroutine bark_unless_zero(iarg)\n+      implicit none\n+      integer, intent(in) :: iarg\n+    end subroutine bark_unless_zero\n+  end interface\n+\n+  integer :: i\n+  i = 0\n+\n+  if (i /= 1) call abort\n+  call bark_unless_0(i) ! { dg-error \"not explicitly declared; did you mean .bark_unless_zero.\\\\?\" }\n+!  call complain_about_0(i) ! { -dg-error \"not explicitly declared; did you mean .complain_about_zero.\\\\?\" }\n+\n+contains\n+! We cannot reliably see this ATM, would need an unambiguous bit somewhere\n+  subroutine complain_about_zero(iarg)\n+    integer, intent(in) :: iarg\n+    if (iarg /= 0) call abort\n+  end subroutine complain_about_zero\n+\n+end program spellchekc\n+\n+subroutine bark_unless_zero(iarg)\n+  implicit none\n+  integer, intent(in) :: iarg\n+  if (iarg /= 0) call abort\n+end subroutine bark_unless_zero"}, {"sha": "929e05f21519538864f7f0a44e2ab77d9b797180", "filename": "gcc/testsuite/gfortran.dg/spellcheck-structure.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ftestsuite%2Fgfortran.dg%2Fspellcheck-structure.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc478b9647e2af4b715fda6676d98f1e129d16b/gcc%2Ftestsuite%2Fgfortran.dg%2Fspellcheck-structure.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fspellcheck-structure.f90?ref=bcc478b9647e2af4b715fda6676d98f1e129d16b", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do compile }\n+! test levenshtein based spelling suggestions\n+implicit none\n+\n+!!!!!!!!!!!!!! structure tests !!!!!!!!!!!!!!\n+type type1\n+   real :: radius\n+   integer :: i\n+end type type1\n+\n+type type2\n+  integer :: myint\n+  type(type1) :: mytype\n+end type type2\n+\n+type type3\n+  type(type2) :: type_2\n+end type type3\n+type type4\n+  type(type3) :: type_3\n+end type type4\n+\n+type(type1) :: t1\n+t1%radiuz = .0 ! { dg-error \".radiuz. at .1. is not a member of the .type1. structure; did you mean .radius.\\\\?\" }\n+t1%x = .0 ! { dg-error \".x. at .1. is not a member of the .type1. structure\" }\n+type(type2) :: t2\n+t2%mytape%radius = .0 ! { dg-error \".mytape. at .1. is not a member of the .type2. structure; did you mean .mytype.\\\\?\" }\n+t2%mytype%radious = .0 ! { dg-error \".radious. at .1. is not a member of the .type1. structure; did you mean .radius.\\\\?\" }\n+type(type4) :: t4\n+t4%type_3%type_2%mytype%radium = 88.0 ! { dg-error \".radium. at .1. is not a member of the .type1. structure; did you mean .radius.\\\\?\" }\n+\n+!!!!!!!!!!!!!! symbol tests !!!!!!!!!!!!!!\n+integer :: iarg1\n+iarg2 = 1 ! { dg-error \"Symbol .iarg2. at .1. has no IMPLICIT type; did you mean .iarg1.\\\\?\" }\n+end"}]}