{"sha": "b497b46043b4679353aecf4be76266686813bdf3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ5N2I0NjA0M2I0Njc5MzUzYWVjZjRiZTc2MjY2Njg2ODEzYmRmMw==", "commit": {"author": {"name": "Jose Ruiz", "email": "ruiz@adacore.com", "date": "2005-06-16T08:28:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-06-16T08:28:24Z"}, "message": "a-sytaco.ads, [...] (Suspension_Object): These objects are no longer protected objects.\n\n2005-06-14  Jose Ruiz  <ruiz@adacore.com>\n\t    Arnaud Charlet  <charlet@adacore.com>\n\n\t* a-sytaco.ads, a-sytaco.adb (Suspension_Object): These objects are no\n\tlonger protected objects. They have been replaced by lower-level\n\tsuspension objects made up by a mutex and a condition variable (or\n\ttheir equivalent given a particular OS) plus some internal data to\n\treflect the state of the suspension object.\n\t(Initialize, Finalize): Add this initialization procedure for\n\tSuspension_Object, which is a controlled type.\n\t(Finalize): Add the finalization procedure for Suspension_Object,\n\twhich is a controlled type.\n\n\t* a-sytaco-vxworks.ads, a-sytaco-vxworks.adb: Remove this version of\n\tAda.Synchronous_Task_Control because there is no longer a need for a\n\tVxWorks specific version of this package. Target dependencies\n\thas been moved to System.Task_Primitives.Operations.\n\n\t* s-osinte-mingw.ads (pCRITICAL_SECTION): Remove this type which is no\n\tlonger needed.\n\t(InitializeCriticalSection, EnterCriticalSection,\n\tLeaveCriticalSection, DeleteCriticalSection): Replace the type\n\tpCriticalSection by an anonymous access type so that we avoid problems\n\tof accessibility to local objects.\n\n\t* s-taprop.ads, s-taprop-posix.adb, s-taprop-vxworks.adb,\n\ts-taprop-mingw.adb, s-taprop-vms.adb, s-taprop-solaris.adb,\n\ts-taprop-os2.adb, s-taprop-dummy.adb, s-taprop-hpux-dce.adb,\n\ts-taprop-linux.adb, s-taprop-irix.adb, s-taprop-irix-athread.adb,\n\ts-taprop-tru64.adb, s-taprop-lynxos.adb (Elaboration Code): No longer\n\tset the environment task mask here.\n\t(Current_State): Add this function that returns the state of the\n\tsuspension object.\n\t(Set_False): Add this procedure that sets the state of the suspension\n\tobject to False.\n\t(Set_True): Add this procedure that sets the state of the suspension\n\tobject to True, releasing the task that was suspended, if any.\n\t(Suspend_Until_True): Add this procedure that blocks the calling task\n\tuntil the state of the object is True. Program_Error is raised if\n\tanother task is already waiting on that suspension object.\n\t(Initialize): Add this procedure for initializing the suspension\n\tobject. It initializes the mutex and the condition variable which are\n\tused for synchronization and queuing, and it sets the internal state\n\tto False.\n\t(Finalize): Add this procedure for finalizing the suspension object,\n\tdestroying the mutex and the condition variable.\n\n\t* s-taspri-posix.ads, s-taspri-vxworks.ads, s-taspri-mingw.ads,\n\ts-taspri-vms.ads, s-taspri-solaris.ads, s-taspri-os2.ads,\n\ts-taspri-dummy.ads, s-taspri-hpux-dce.ads, s-taspri-linux.ads,\n\ts-taspri-tru64.ads, s-taspri-lynxos.ads (Suspension_Object): New object\n\twhich provides a low-level abstraction (using operating system\n\tprimitives) for Ada.Synchronous_Task_Control.\n\tThis object is made up by a mutex (for ensuring mutual exclusion), a\n\tcondition variable (for queuing threads until the condition is\n\tsignaled), a Boolean (State) indicating whether the object is open,\n\tand a Boolean (Waiting) reflecting whether there is a task already\n\tsuspended on this object.\n\n\t* s-intman.ads, s-intman-irix.adb, s-intman-irix-athread.adb,\n\ts-intman-dummy.adb, s-intman-solaris.adb, s-intman-vms.adb,\n\ts-intman-vms.ads, s-intman-mingw.adb,\n\t(Initialize_Interrupts): Removed, no longer used.\n\n\t* s-inmaop-posix.adb, s-inmaop-vms.adb, s-inmaop-dummy.adb,\n\t(Setup_Interrupt_Mask): New procedure.\n\n\t* s-intman-vxworks.ads, s-intman-vxworks.adb:  Update comments.\n\n\t* s-inmaop.ads (Setup_Interrupt_Mask): New procedure\n\n\t* s-interr.adb: Add explicit call to Setup_Interrupt_Mask now that\n\tthis is no longer done in the body of s-taprop\n\t(Server_Task): Explicitely test for Pending_Action in case\n\tSystem.Parameters.No_Abort is True.\n\n\t* s-taasde.adb: Add explicit call to Setup_Interrupt_Mask now that this\n\tis no longer done in the body of s-taprop\n\nFrom-SVN: r101015", "tree": {"sha": "4fb352539eb2da55b0cd66a4286daa9a48c396d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fb352539eb2da55b0cd66a4286daa9a48c396d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b497b46043b4679353aecf4be76266686813bdf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b497b46043b4679353aecf4be76266686813bdf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b497b46043b4679353aecf4be76266686813bdf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b497b46043b4679353aecf4be76266686813bdf3/comments", "author": {"login": "JoseRuizAdaCore", "id": 22770339, "node_id": "MDQ6VXNlcjIyNzcwMzM5", "avatar_url": "https://avatars.githubusercontent.com/u/22770339?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoseRuizAdaCore", "html_url": "https://github.com/JoseRuizAdaCore", "followers_url": "https://api.github.com/users/JoseRuizAdaCore/followers", "following_url": "https://api.github.com/users/JoseRuizAdaCore/following{/other_user}", "gists_url": "https://api.github.com/users/JoseRuizAdaCore/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoseRuizAdaCore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoseRuizAdaCore/subscriptions", "organizations_url": "https://api.github.com/users/JoseRuizAdaCore/orgs", "repos_url": "https://api.github.com/users/JoseRuizAdaCore/repos", "events_url": "https://api.github.com/users/JoseRuizAdaCore/events{/privacy}", "received_events_url": "https://api.github.com/users/JoseRuizAdaCore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3084fecdb96ba949ce9188b6356121c911cdff76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3084fecdb96ba949ce9188b6356121c911cdff76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3084fecdb96ba949ce9188b6356121c911cdff76"}], "stats": {"total": 3428, "additions": 2650, "deletions": 778}, "files": [{"sha": "fcb320a97ecba602aa25728f6a3cc0d3f0a6050f", "filename": "gcc/ada/a-sytaco-vxworks.adb", "status": "removed", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3084fecdb96ba949ce9188b6356121c911cdff76/gcc%2Fada%2Fa-sytaco-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3084fecdb96ba949ce9188b6356121c911cdff76/gcc%2Fada%2Fa-sytaco-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sytaco-vxworks.adb?ref=3084fecdb96ba949ce9188b6356121c911cdff76", "patch": "@@ -1,147 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUNTIME COMPONENTS                          --\n---                                                                          --\n---         A D A . S Y N C H R O N O U S _ T A S K _ C O N T R O L          --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---            Copyright (C) 1992-2004 Free Software Foundation, Inc.        --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Interfaces.C;\n-\n-package body Ada.Synchronous_Task_Control is\n-   use System.OS_Interface;\n-   use type Interfaces.C.int;\n-\n-   -------------------\n-   -- Current_State --\n-   -------------------\n-\n-   function Current_State (S : Suspension_Object) return Boolean is\n-      St     : STATUS;\n-      Result : Boolean := False;\n-\n-   begin\n-      --  Determine state by attempting to take the semaphore with\n-      --  a 0 timeout value.  Status = OK indicates the semaphore was\n-      --  full, so reset it to the full state.\n-\n-      St := semTake (S.Sema, NO_WAIT);\n-\n-      --  If we took the semaphore, reset semaphore state to FULL\n-\n-      if St = OK then\n-         Result := True;\n-         St := semGive (S.Sema);\n-      end if;\n-\n-      return Result;\n-   end Current_State;\n-\n-   ---------------\n-   -- Set_False --\n-   ---------------\n-\n-   procedure Set_False (S : in out Suspension_Object) is\n-      St : STATUS;\n-\n-   begin\n-      --  Need to get the semaphore into the \"empty\" state.\n-      --  On return, this task will have made the semaphore\n-      --  empty (St = OK) or have left it empty.\n-\n-      St := semTake (S.Sema, NO_WAIT);\n-      pragma Assert (St = OK);\n-   end Set_False;\n-\n-   --------------\n-   -- Set_True --\n-   --------------\n-\n-   procedure Set_True (S : in out Suspension_Object) is\n-      St : STATUS;\n-      pragma Unreferenced (St);\n-   begin\n-      St := semGive (S.Sema);\n-   end Set_True;\n-\n-   ------------------------\n-   -- Suspend_Until_True --\n-   ------------------------\n-\n-   procedure Suspend_Until_True (S : in out Suspension_Object) is\n-      St : STATUS;\n-\n-   begin\n-      --  Determine whether another task is pending on the suspension\n-      --  object. Should never be called from an ISR. Therefore semTake can\n-      --  be called on the mutex\n-\n-      St := semTake (S.Mutex, NO_WAIT);\n-\n-      if St = OK then\n-\n-         --  Wait for suspension object\n-\n-         St := semTake (S.Sema, WAIT_FOREVER);\n-         St := semGive (S.Mutex);\n-\n-      else\n-         --  Another task is pending on the suspension object\n-\n-         raise Program_Error;\n-      end if;\n-   end Suspend_Until_True;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize (S : in out Suspension_Object) is\n-   begin\n-      S.Sema := semBCreate (SEM_Q_FIFO, SEM_EMPTY);\n-\n-      --  Use simpler binary semaphore instead of VxWorks\n-      --  mutual exclusion semaphore, because we don't need\n-      --  the fancier semantics and their overhead.\n-\n-      S.Mutex := semBCreate (SEM_Q_FIFO, SEM_FULL);\n-   end Initialize;\n-\n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize (S : in out Suspension_Object) is\n-      St : STATUS;\n-      pragma Unreferenced (St);\n-   begin\n-      St := semDelete (S.Sema);\n-      St := semDelete (S.Mutex);\n-   end Finalize;\n-\n-end Ada.Synchronous_Task_Control;"}, {"sha": "c3c54bee43c6758237c312d79326f42c6259c542", "filename": "gcc/ada/a-sytaco-vxworks.ads", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3084fecdb96ba949ce9188b6356121c911cdff76/gcc%2Fada%2Fa-sytaco-vxworks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3084fecdb96ba949ce9188b6356121c911cdff76/gcc%2Fada%2Fa-sytaco-vxworks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sytaco-vxworks.ads?ref=3084fecdb96ba949ce9188b6356121c911cdff76", "patch": "@@ -1,68 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---         A D A . S Y N C H R O N O U S _ T A S K _ C O N T R O L          --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n--- MA 02111-1307, USA.                                                      --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with System.OS_Interface;\n-with Ada.Finalization;\n-package Ada.Synchronous_Task_Control is\n-\n-   type Suspension_Object is limited private;\n-\n-   procedure Set_True (S : in out Suspension_Object);\n-\n-   procedure Set_False (S : in out Suspension_Object);\n-\n-   function Current_State (S : Suspension_Object) return Boolean;\n-\n-   procedure Suspend_Until_True (S : in out Suspension_Object);\n-\n-private\n-\n-   procedure Initialize (S : in out Suspension_Object);\n-\n-   procedure Finalize (S : in out Suspension_Object);\n-\n-   --  Implement with a VxWorks binary semaphore. A second semaphore\n-   --  is used to avoid a race condition related to the implementation of\n-   --  the STC requirement to raise Program_Error when Suspend_Until_True is\n-   --  called with a task already pending on the suspension object\n-\n-   type Suspension_Object is new Ada.Finalization.Controlled with record\n-      Sema  : System.OS_Interface.SEM_ID;\n-      Mutex : System.OS_Interface.SEM_ID;\n-   end record;\n-\n-end Ada.Synchronous_Task_Control;"}, {"sha": "c3ea8faca4c0bc46defe410ead81a4e69edea499", "filename": "gcc/ada/a-sytaco.adb", "status": "modified", "additions": 49, "deletions": 56, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fa-sytaco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fa-sytaco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sytaco.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                         GNAT RUNTIME COMPONENTS                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n --         A D A . S Y N C H R O N O U S _ T A S K _ C O N T R O L          --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---            Copyright (C) 1992-2001 Free Software Foundation, Inc.        --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,73 +31,55 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+pragma Warnings (Off);\n+--  Allow withing of non-Preelaborated units in Ada 2005 mode where this\n+--  package will be categorized as Preelaborate. See AI-362 for details.\n+--  It is safe in the context of the run-time to violate the rules!\n \n-package body Ada.Synchronous_Task_Control is\n-\n-   -------------------\n-   -- Suspension_PO --\n-   -------------------\n-\n-   protected body Suspension_Object is\n-\n-      --------------\n-      -- Get_Open --\n-      --------------\n-\n-      function Get_Open return Boolean is\n-      begin\n-         return Open;\n-      end Get_Open;\n+with System.Tasking;\n+--  Used for Detect_Blocking\n+--           Self\n \n-      ---------------\n-      -- Set_False --\n-      ---------------\n+with Ada.Exceptions;\n+--  Used for Raise_Exception\n \n-      procedure Set_False is\n-      begin\n-         Open := False;\n-      end Set_False;\n+with System.Task_Primitives.Operations;\n+--  Used for Initialize\n+--           Finalize\n+--           Current_State\n+--           Set_False\n+--           Set_True\n+--           Suspend_Until_True\n \n-      --------------\n-      -- Set_True --\n-      --------------\n+pragma Warnings (On);\n \n-      procedure Set_True is\n-      begin\n-         Open := True;\n-      end Set_True;\n-\n-      ----------\n-      -- Wait --\n-      ----------\n-\n-      entry Wait when Open is\n-      begin\n-         Open := False;\n-      end Wait;\n+package body Ada.Synchronous_Task_Control is\n \n-      --------------------\n-      -- Wait_Exception --\n-      --------------------\n+   ----------------\n+   -- Initialize --\n+   ----------------\n \n-      entry Wait_Exception when True is\n-      begin\n-         if Wait'Count /= 0 then\n-            raise Program_Error;\n-         end if;\n+   procedure Initialize (S : in out Suspension_Object) is\n+   begin\n+      System.Task_Primitives.Operations.Initialize (S.SO);\n+   end Initialize;\n \n-         requeue Wait;\n-      end Wait_Exception;\n+   --------------\n+   -- Finalize --\n+   --------------\n \n-   end Suspension_Object;\n+   procedure Finalize (S : in out Suspension_Object) is\n+   begin\n+      System.Task_Primitives.Operations.Finalize (S.SO);\n+   end Finalize;\n \n    -------------------\n    -- Current_State --\n    -------------------\n \n    function Current_State (S : Suspension_Object) return Boolean is\n    begin\n-      return S.Get_Open;\n+      return System.Task_Primitives.Operations.Current_State (S.SO);\n    end Current_State;\n \n    ---------------\n@@ -106,7 +88,7 @@ package body Ada.Synchronous_Task_Control is\n \n    procedure Set_False (S : in out Suspension_Object) is\n    begin\n-      S.Set_False;\n+      System.Task_Primitives.Operations.Set_False (S.SO);\n    end Set_False;\n \n    --------------\n@@ -115,7 +97,7 @@ package body Ada.Synchronous_Task_Control is\n \n    procedure Set_True (S : in out Suspension_Object) is\n    begin\n-      S.Set_True;\n+      System.Task_Primitives.Operations.Set_True (S.SO);\n    end Set_True;\n \n    ------------------------\n@@ -124,7 +106,18 @@ package body Ada.Synchronous_Task_Control is\n \n    procedure Suspend_Until_True (S : in out Suspension_Object) is\n    begin\n-      S.Wait_Exception;\n+      --  This is a potentially blocking (see ARM D.10, par. 10), so that\n+      --  if pragma Detect_Blocking is active then Program_Error must be\n+      --  raised if this operation is called from a protected action.\n+\n+      if System.Tasking.Detect_Blocking\n+        and then System.Tasking.Self.Common.Protected_Action_Nesting > 0\n+      then\n+         Ada.Exceptions.Raise_Exception\n+           (Program_Error'Identity, \"potentially blocking operation\");\n+      end if;\n+\n+      System.Task_Primitives.Operations.Suspend_Until_True (S.SO);\n    end Suspend_Until_True;\n \n end Ada.Synchronous_Task_Control;"}, {"sha": "98eda726b9a7937e31dd99e1aa7bb21058cf1837", "filename": "gcc/ada/a-sytaco.ads", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fa-sytaco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fa-sytaco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-sytaco.ads?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -35,9 +35,22 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System;\n+pragma Warnings (Off);\n+--  Allow withing of non-Preelaborated units in Ada 2005 mode where this\n+--  package will be implicitly categorized as Preelaborate. See AI-362 for\n+--  details. It is safe in the context of the run-time to violate the rules!\n+\n+with System.Task_Primitives;\n+--  Used for Suspension_Object\n+\n+with Ada.Finalization;\n+--  Used for Limited_Controlled\n+\n+pragma Warnings (On);\n \n package Ada.Synchronous_Task_Control is\n+pragma Preelaborate_05 (Synchronous_Task_Control);\n+--  In accordance with Ada 2005 AI-362\n \n    type Suspension_Object is limited private;\n \n@@ -51,19 +64,25 @@ package Ada.Synchronous_Task_Control is\n \n private\n \n-   --  ??? Using a protected object is overkill; suspension could be\n-   --      implemented more efficiently.\n+   procedure Initialize (S : in out Suspension_Object);\n+   --  Initialization for Suspension_Object\n+\n+   procedure Finalize (S : in out Suspension_Object);\n+   --  Finalization for Suspension_Object\n \n-   protected type Suspension_Object is\n-      entry Wait;\n-      procedure Set_False;\n-      procedure Set_True;\n-      function Get_Open return Boolean;\n-      entry Wait_Exception;\n+   type Suspension_Object is\n+     new Ada.Finalization.Limited_Controlled with record\n+      SO : System.Task_Primitives.Suspension_Object;\n+      --  Use low-level suspension objects so that the synchronization\n+      --  functionality provided by this object can be achieved using\n+      --  efficient operating system primitives.\n+     end record;\n \n-      pragma Priority (System.Any_Priority'Last);\n-   private\n-      Open : Boolean := False;\n-   end Suspension_Object;\n+   pragma Inline (Set_True);\n+   pragma Inline (Set_False);\n+   pragma Inline (Current_State);\n+   pragma Inline (Suspend_Until_True);\n+   pragma Inline (Initialize);\n+   pragma Inline (Finalize);\n \n end Ada.Synchronous_Task_Control;"}, {"sha": "c7e125b6a2a6e060057fbfdfae68feeeea434c94", "filename": "gcc/ada/s-inmaop-dummy.adb", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-inmaop-dummy.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-inmaop-dummy.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-inmaop-dummy.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,13 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n---                  SYSTEM.INTERRUPT_MANAGEMENT.OPERATIONS                  --\n+--          S Y S T E M . I N T E R R U P T _ M A N A G E M E N T .         --\n+--                            O P E R A T I O N S                           --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +32,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is a NO tasking version of this package.\n+--  This is a NO tasking version of this package\n \n package body System.Interrupt_Management.Operations is\n \n@@ -191,4 +192,13 @@ package body System.Interrupt_Management.Operations is\n       null;\n    end Interrupt_Self_Process;\n \n+   --------------------------\n+   -- Setup_Interrupt_Mask --\n+   --------------------------\n+\n+   procedure Setup_Interrupt_Mask is\n+   begin\n+      null;\n+   end Setup_Interrupt_Mask;\n+\n end System.Interrupt_Management.Operations;"}, {"sha": "987fb717bf051b105f059b13d003ff361732004f", "filename": "gcc/ada/s-inmaop-posix.adb", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-inmaop-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-inmaop-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-inmaop-posix.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,13 +1,14 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                 GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS              --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n --                                                                          --\n---                   SYSTEM.INTERRUPT_MANAGEMENT.OPERATIONS                 --\n+--          S Y S T E M . I N T E R R U P T _ M A N A G E M E N T .         --\n+--                            O P E R A T I O N S                           --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2003, Ada Core Technologies               --\n+--                     Copyright (C) 1995-2005, AdaCore                     --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -78,7 +79,6 @@ package body System.Interrupt_Management.Operations is\n    is\n       Result : Interfaces.C.int;\n       Mask   : aliased sigset_t;\n-\n    begin\n       Result := sigemptyset (Mask'Access);\n       pragma Assert (Result = 0);\n@@ -97,7 +97,6 @@ package body System.Interrupt_Management.Operations is\n    is\n       Mask   : aliased sigset_t;\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := sigemptyset (Mask'Access);\n       pragma Assert (Result = 0);\n@@ -113,7 +112,6 @@ package body System.Interrupt_Management.Operations is\n \n    procedure Set_Interrupt_Mask (Mask : access Interrupt_Mask) is\n       Result   : Interfaces.C.int;\n-\n    begin\n       Result := pthread_sigmask\n         (SIG_SETMASK, +Interrupt_Mask_Ptr (Mask), null);\n@@ -125,7 +123,6 @@ package body System.Interrupt_Management.Operations is\n       OMask : access Interrupt_Mask)\n    is\n       Result  : Interfaces.C.int;\n-\n    begin\n       Result := pthread_sigmask\n         (SIG_SETMASK, +Interrupt_Mask_Ptr (Mask), +Interrupt_Mask_Ptr (OMask));\n@@ -138,7 +135,6 @@ package body System.Interrupt_Management.Operations is\n \n    procedure Get_Interrupt_Mask (Mask : access Interrupt_Mask) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_sigmask\n         (SIG_SETMASK, null, +Interrupt_Mask_Ptr (Mask));\n@@ -155,7 +151,6 @@ package body System.Interrupt_Management.Operations is\n    is\n       Result : Interfaces.C.int;\n       Sig    : aliased Signal;\n-\n    begin\n       Result := sigwait (Mask, Sig'Access);\n \n@@ -172,7 +167,6 @@ package body System.Interrupt_Management.Operations is\n \n    procedure Install_Default_Action (Interrupt : Interrupt_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := sigaction\n         (Signal (Interrupt),\n@@ -186,7 +180,6 @@ package body System.Interrupt_Management.Operations is\n \n    procedure Install_Ignore_Action (Interrupt : Interrupt_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := sigaction (Signal (Interrupt), Ignore_Action'Access, null);\n       pragma Assert (Result = 0);\n@@ -198,7 +191,6 @@ package body System.Interrupt_Management.Operations is\n \n    procedure Fill_Interrupt_Mask (Mask : access Interrupt_Mask) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := sigfillset (Mask);\n       pragma Assert (Result = 0);\n@@ -210,7 +202,6 @@ package body System.Interrupt_Management.Operations is\n \n    procedure Empty_Interrupt_Mask (Mask : access Interrupt_Mask) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := sigemptyset (Mask);\n       pragma Assert (Result = 0);\n@@ -225,7 +216,6 @@ package body System.Interrupt_Management.Operations is\n       Interrupt : Interrupt_ID)\n    is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := sigaddset (Mask, Signal (Interrupt));\n       pragma Assert (Result = 0);\n@@ -240,7 +230,6 @@ package body System.Interrupt_Management.Operations is\n       Interrupt : Interrupt_ID)\n    is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := sigdelset (Mask, Signal (Interrupt));\n       pragma Assert (Result = 0);\n@@ -255,7 +244,6 @@ package body System.Interrupt_Management.Operations is\n       Interrupt : Interrupt_ID) return Boolean\n    is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := sigismember (Mask, Signal (Interrupt));\n       pragma Assert (Result = 0 or else Result = 1);\n@@ -268,8 +256,7 @@ package body System.Interrupt_Management.Operations is\n \n    procedure Copy_Interrupt_Mask\n      (X : out Interrupt_Mask;\n-      Y : Interrupt_Mask)\n-   is\n+      Y : Interrupt_Mask) is\n    begin\n       X := Y;\n    end Copy_Interrupt_Mask;\n@@ -280,12 +267,24 @@ package body System.Interrupt_Management.Operations is\n \n    procedure Interrupt_Self_Process (Interrupt : Interrupt_ID) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := kill (getpid, Signal (Interrupt));\n       pragma Assert (Result = 0);\n    end Interrupt_Self_Process;\n \n+   --------------------------\n+   -- Setup_Interrupt_Mask --\n+   --------------------------\n+\n+   procedure Setup_Interrupt_Mask is\n+   begin\n+      --  Mask task for all signals. The original mask of the Environment task\n+      --  will be recovered by Interrupt_Manager task during the elaboration\n+      --  of s-interr.adb.\n+\n+      Set_Interrupt_Mask (All_Tasks_Mask'Access);\n+   end Setup_Interrupt_Mask;\n+\n begin\n \n    declare"}, {"sha": "277d8865b9e5969f2ee260beedd1f88f6ef252a8", "filename": "gcc/ada/s-inmaop-vms.adb", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-inmaop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-inmaop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-inmaop-vms.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,13 +1,13 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T .        --\n --                           O P E R A T I O N S                            --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -268,9 +268,9 @@ package body System.Interrupt_Management.Operations is\n       X := Y;\n    end Copy_Interrupt_Mask;\n \n-   -------------------------\n+   ----------------------------\n    -- Interrupt_Self_Process --\n-   -------------------------\n+   ----------------------------\n \n    procedure Interrupt_Self_Process (Interrupt : Interrupt_ID) is\n       Status : Cond_Value_Type;\n@@ -285,6 +285,15 @@ package body System.Interrupt_Management.Operations is\n       pragma Assert ((Status and 1) = 1);\n    end Interrupt_Self_Process;\n \n+   --------------------------\n+   -- Setup_Interrupt_Mask --\n+   --------------------------\n+\n+   procedure Setup_Interrupt_Mask is\n+   begin\n+      null;\n+   end Setup_Interrupt_Mask;\n+\n begin\n    Environment_Mask := (others => False);\n    All_Tasks_Mask := (others => True);"}, {"sha": "0c8f6ee5377a758fbcfc6d7f5fc8d809d07bb848", "filename": "gcc/ada/s-inmaop.ads", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-inmaop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-inmaop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-inmaop.ads?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,13 +1,13 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --            S Y S T E M . I N T E R R U P T _ M A N A G E M E N T .       --\n --                             O P E R A T I O N S                          --\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -103,6 +103,11 @@ package System.Interrupt_Management.Operations is\n    pragma Inline (Interrupt_Self_Process);\n    --  Raise an Interrupt process-level\n \n+   procedure Setup_Interrupt_Mask;\n+   --  Mask Environment task for all signals\n+   --  This function should be called by the elaboration of System.Interrupt\n+   --  to set up proper signal masking in all tasks.\n+\n    --  The following objects serve as constants, but are initialized\n    --  in the body to aid portability.  These actually belong to the\n    --  System.Interrupt_Management but since Interrupt_Mask is a"}, {"sha": "fdff2748120c1069a192a29795881ebe91a96857", "filename": "gcc/ada/s-interr.adb", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-interr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-interr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,6 +1,6 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --                     S Y S T E M . I N T E R R U P T S                    --\n --                                                                          --\n@@ -1438,8 +1438,13 @@ package body System.Interrupts is\n \n          System.Tasking.Initialization.Undefer_Abort (Self_ID);\n \n-         --  Undefer abort here to allow a window for this task\n-         --  to be aborted  at the time of system shutdown.\n+         if Self_ID.Pending_Action then\n+            Initialization.Do_Pending_Action (Self_ID);\n+         end if;\n+\n+         --  Undefer abort here to allow a window for this task to be aborted\n+         --  at the time of system shutdown. We also explicitely test for\n+         --  Pending_Action in case System.Parameters.No_Abort is True.\n \n       end loop;\n    end Server_Task;\n@@ -1454,16 +1459,15 @@ begin\n    --  During the elaboration of this package body we want the RTS\n    --  to inherit the interrupt mask from the Environment Task.\n \n-   --  The environment task should have gotten its mask from\n-   --  the enclosing process during the RTS start up. (See\n-   --  processing in s-inmaop.adb). Pass the Interrupt_Mask\n-   --  of the environment task to the Interrupt_Manager.\n+   IMOP.Setup_Interrupt_Mask;\n+\n+   --  The environment task should have gotten its mask from the enclosing\n+   --  process during the RTS start up. (See processing in s-inmaop.adb). Pass\n+   --  the Interrupt_Mask of the environment task to the Interrupt_Manager.\n \n-   --  Note : At this point we know that all tasks (including\n-   --  RTS internal servers) are masked for non-reserved signals\n-   --  (see s-taprop.adb). Only the Interrupt_Manager will have\n-   --  masks set up differently inheriting the original environment\n-   --  task's mask.\n+   --  Note : At this point we know that all tasks are masked for non-reserved\n+   --  signals. Only the Interrupt_Manager will have masks set up differently\n+   --  inheriting the original environment task's mask.\n \n    Interrupt_Manager.Initialize (IMOP.Environment_Mask);\n end System.Interrupts;"}, {"sha": "0f67306b31d503ba3411e32e2a365c7332e964e2", "filename": "gcc/ada/s-intman-dummy.adb", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman-dummy.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman-dummy.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-dummy.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T          --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1997-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1997-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,15 +35,4 @@\n \n package body System.Interrupt_Management is\n \n-   ---------------------------\n-   -- Initialize_Interrupts --\n-   ---------------------------\n-\n-   --  Nothing needs to be done on this platform.\n-\n-   procedure Initialize_Interrupts is\n-   begin\n-      null;\n-   end Initialize_Interrupts;\n-\n end System.Interrupt_Management;"}, {"sha": "9a01480ef18d82d0256166143bf972cbdccb6f55", "filename": "gcc/ada/s-intman-irix-athread.adb", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman-irix-athread.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman-irix-athread.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-irix-athread.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,13 +1,13 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                 GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS              --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n --                                                                          --\n --           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T          --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2003, Ada Core Technologies               --\n+--                     Copyright (C) 1995-2005, AdaCore                     --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -82,28 +82,6 @@ package body System.Interrupt_Management is\n    pragma Import\n      (C, Unreserve_All_Interrupts, \"__gl_unreserve_all_interrupts\");\n \n-   ----------------------\n-   -- Notify_Exception --\n-   ----------------------\n-\n-   --  This function identifies the Ada exception to be raised using the\n-   --  information when the system received a synchronous signal.\n-   --  Since this function is machine and OS dependent, different code has to\n-   --  be provided for different target.\n-   --  On SGI, the signal handling is done is a-init.c, even when tasking is\n-   --  involved.\n-\n-   ---------------------------\n-   -- Initialize_Interrupts --\n-   ---------------------------\n-\n-   --  Nothing needs to be done on this platform.\n-\n-   procedure Initialize_Interrupts is\n-   begin\n-      null;\n-   end Initialize_Interrupts;\n-\n begin\n    declare\n       function State (Int : Interrupt_ID) return Character;"}, {"sha": "346e89b9f5afe3a594f177fa38bc92ac3e45e1a4", "filename": "gcc/ada/s-intman-irix.adb", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman-irix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman-irix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-irix.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,13 +1,13 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T          --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2003, Ada Core Technologies               --\n+---                     Copyright (C) 1995-2005, AdaCore                     --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -59,17 +59,6 @@ package body System.Interrupt_Management is\n       SIGSEGV, SIGSYS, SIGXCPU, SIGXFSZ, SIGPROF, SIGPTINTR, SIGPTRESCHED,\n       SIGABRT, SIGPIPE);\n \n-   ---------------------------\n-   -- Initialize_Interrupts --\n-   ---------------------------\n-\n-   --  Nothing needs to be done on this platform\n-\n-   procedure Initialize_Interrupts is\n-   begin\n-      null;\n-   end Initialize_Interrupts;\n-\n    Unreserve_All_Interrupts : Interfaces.C.int;\n    pragma Import\n      (C, Unreserve_All_Interrupts, \"__gl_unreserve_all_interrupts\");"}, {"sha": "c7c40227b80942d1c579abb45fa50db3e6cd2c8a", "filename": "gcc/ada/s-intman-mingw.adb", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-mingw.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T          --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1991-2000 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1991-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -50,18 +50,6 @@\n with System.OS_Interface; use System.OS_Interface;\n \n package body System.Interrupt_Management is\n-\n-   ---------------------------\n-   -- Initialize_Interrupts --\n-   ---------------------------\n-\n-   --  Nothing needs to be done on this platform.\n-\n-   procedure Initialize_Interrupts is\n-   begin\n-      null;\n-   end Initialize_Interrupts;\n-\n begin\n    --  \"Reserve\" all the interrupts, except those that are explicitely defined\n "}, {"sha": "a4ee11f27a6d6d4fb6364a90b815eef28b1a94fb", "filename": "gcc/ada/s-intman-solaris.adb", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-solaris.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T          --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -121,17 +121,6 @@ package body System.Interrupt_Management is\n       end case;\n    end Notify_Exception;\n \n-   ---------------------------\n-   -- Initialize_Interrupts --\n-   ---------------------------\n-\n-   --  Nothing needs to be done on this platform.\n-\n-   procedure Initialize_Interrupts is\n-   begin\n-      null;\n-   end Initialize_Interrupts;\n-\n ----------------------------\n -- Package Initialization --\n ----------------------------"}, {"sha": "4286eb06d379203373562bffac5f6117fd484d94", "filename": "gcc/ada/s-intman-vms.adb", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-vms.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T          --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2002, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,12 +33,6 @@\n \n --  This is a OpenVMS/Alpha version of this package.\n \n---  PLEASE DO NOT add any dependences on other packages.\n---  This package is designed to work with or without tasking support.\n-\n---  See the other warnings in the package specification before making\n---  any modifications to this file.\n-\n with System.OS_Interface;\n --  used for various Constants, Signal and types\n \n@@ -47,13 +41,16 @@ package body System.Interrupt_Management is\n    use System.OS_Interface;\n    use type unsigned_long;\n \n-   ---------------------------\n-   -- Initialize_Interrupts --\n-   ---------------------------\n+begin\n+   Abort_Task_Interrupt := Interrupt_ID_0;\n+   --  Unused\n+\n+   Reserve := Reserve or Keep_Unmasked or Keep_Masked;\n \n-   procedure Initialize_Interrupts is\n-      Status : Cond_Value_Type;\n+   Reserve (Interrupt_ID_0) := True;\n \n+   declare\n+      Status : Cond_Value_Type;\n    begin\n       Sys_Crembx\n         (Status => Status,\n@@ -73,16 +70,5 @@ package body System.Interrupt_Management is\n          Flags  => AGN_M_WRITEONLY);\n \n       pragma Assert ((Status and 1) = 1);\n-   end Initialize_Interrupts;\n-\n-begin\n-   --  Unused\n-\n-   Abort_Task_Interrupt := Interrupt_ID_0;\n-\n-   Reserve := Reserve or Keep_Unmasked or Keep_Masked;\n-\n-   Reserve (Interrupt_ID_0) := True;\n-\n-   Initialize_Interrupts;\n+   end;\n end System.Interrupt_Management;"}, {"sha": "2444e9014a8e4cb0e025199912b527d80773dc94", "filename": "gcc/ada/s-intman-vms.ads", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-vms.ads?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,6 +1,6 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --            S Y S T E M . I N T E R R U P T _ M A N A G E M E N T         --\n --                                                                          --\n@@ -110,12 +110,6 @@ package System.Interrupt_Management is\n    --  example, if interrupts are OS signals and signal masking is per-task,\n    --  use of the sigwait operation requires the signal be masked in all tasks.\n \n-   procedure Initialize_Interrupts;\n-   --  On systems where there is no signal inheritance between tasks (e.g\n-   --  VxWorks, GNU/LinuxThreads), this procedure is used to initialize\n-   --  interrupts handling in each task. Otherwise this function should\n-   --  only be called by initialize in this package body.\n-\n private\n    use type System.OS_Interface.unsigned_long;\n "}, {"sha": "395fa3a8cb17bbb237031f3979dceaab9ab1d029", "filename": "gcc/ada/s-intman-vxworks.adb", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-vxworks.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T          --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -62,10 +62,8 @@ package body System.Interrupt_Management is\n    Exception_Signals : constant Signal_List (1 .. 4) :=\n                          (SIGFPE, SIGILL, SIGSEGV, SIGBUS);\n \n-   --  Keep these variables global so that they are initialized only once\n-   --  What are \"these variables\" ???, I see only one\n-\n    Exception_Action : aliased struct_sigaction;\n+   --  Keep this variable global so that it is initialized only once\n \n    procedure Map_And_Raise_Exception (signo : Signal);\n    pragma Import (C, Map_And_Raise_Exception, \"__gnat_map_signal\");\n@@ -108,7 +106,6 @@ package body System.Interrupt_Management is\n    procedure Initialize_Interrupts is\n       Result  : int;\n       old_act : aliased struct_sigaction;\n-\n    begin\n       for J in Exception_Signals'Range loop\n          Result :="}, {"sha": "1e4deedadf762a0f91f2ab94f44d14f7d789bc62", "filename": "gcc/ada/s-intman-vxworks.ads", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman-vxworks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman-vxworks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-vxworks.ads?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,6 +1,6 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --            S Y S T E M . I N T E R R U P T _ M A N A G E M E N T         --\n --                                                                          --\n@@ -110,10 +110,9 @@ package System.Interrupt_Management is\n    --  or used to implement time delays.\n \n    procedure Initialize_Interrupts;\n-   --  On systems where there is no signal inheritance between tasks (e.g\n-   --  VxWorks, GNU/LinuxThreads), this procedure is used to initialize\n-   --  interrupts handling in each task. Otherwise this function should only\n-   --  be called by initialize in this package body.\n+   --  Under VxWorks, there is no signal inheritance between tasks.\n+   --  This procedure is used to initialize signal-to-exception mapping in\n+   --  each task.\n \n private\n    type Interrupt_Mask is new System.OS_Interface.sigset_t;"}, {"sha": "9cb3296eb9e1b36f19b7e7071a766764b5c05769", "filename": "gcc/ada/s-intman.ads", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-intman.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman.ads?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,6 +1,6 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --            S Y S T E M . I N T E R R U P T _ M A N A G E M E N T         --\n --                                                                          --\n@@ -103,12 +103,6 @@ package System.Interrupt_Management is\n    --  example, it may be mapped to an exception used to implement task abort,\n    --  or used to implement time delays.\n \n-   procedure Initialize_Interrupts;\n-   --  On systems where there is no signal inheritance between tasks (e.g\n-   --  VxWorks, GNU/LinuxThreads), this procedure is used to initialize\n-   --  interrupts handling in each task. Otherwise this function should only\n-   --  be called by initialize in this package body.\n-\n private\n    type Interrupt_Mask is new System.OS_Interface.sigset_t;\n    --  In some implementations Interrupt_Mask can be represented as a linked"}, {"sha": "6d75dd87f597dc82dfbda3eaec017c9fd0312b94", "filename": "gcc/ada/s-osinte-mingw.ads", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-osinte-mingw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-osinte-mingw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-mingw.ads?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,13 +1,13 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --                   S Y S T E M . O S _ I N T E R F A C E                  --\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2004, Free Software Foundation, Inc.      --\n+--             Copyright (C) 1995-2005, Free Software Foundation, Inc.      --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -198,19 +198,22 @@ pragma Preelaborate;\n    -----------------------\n \n    type CRITICAL_SECTION is private;\n-   type PCRITICAL_SECTION is access all CRITICAL_SECTION;\n \n-   procedure InitializeCriticalSection (pCriticalSection : PCRITICAL_SECTION);\n+   procedure InitializeCriticalSection\n+     (pCriticalSection : access CRITICAL_SECTION);\n    pragma Import\n      (Stdcall, InitializeCriticalSection, \"InitializeCriticalSection\");\n \n-   procedure EnterCriticalSection (pCriticalSection : PCRITICAL_SECTION);\n+   procedure EnterCriticalSection\n+     (pCriticalSection : access CRITICAL_SECTION);\n    pragma Import (Stdcall, EnterCriticalSection, \"EnterCriticalSection\");\n \n-   procedure LeaveCriticalSection (pCriticalSection : PCRITICAL_SECTION);\n+   procedure LeaveCriticalSection\n+     (pCriticalSection : access CRITICAL_SECTION);\n    pragma Import (Stdcall, LeaveCriticalSection, \"LeaveCriticalSection\");\n \n-   procedure DeleteCriticalSection (pCriticalSection : PCRITICAL_SECTION);\n+   procedure DeleteCriticalSection\n+     (pCriticalSection : access CRITICAL_SECTION);\n    pragma Import (Stdcall, DeleteCriticalSection, \"DeleteCriticalSection\");\n \n    -------------------------------------------------------------"}, {"sha": "e65b85f69190b7003d7a97d99fa7bd565ef9456d", "filename": "gcc/ada/s-taasde.adb", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taasde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taasde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taasde.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --           S Y S T E M . T A S K I N G . A S Y N C _ D E L A Y S          --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1998-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1998-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -64,6 +64,9 @@ with System.OS_Primitives;\n with Ada.Task_Identification;\n --  used for Task_Id type\n \n+with System.Interrupt_Management.Operations;\n+--  used for Setup_Interrupt_Mask\n+\n with System.Parameters;\n --  used for Single_Lock\n --           Runtime_Traces\n@@ -324,6 +327,12 @@ package body System.Tasking.Async_Delays is\n    begin\n       Timer_Server_ID := STPO.Self;\n \n+      --  Since this package may be elaborated before System.Interrupt,\n+      --  we need to call Setup_Interrupt_Mask explicitly to ensure that\n+      --  this task has the proper signal mask.\n+\n+      Interrupt_Management.Operations.Setup_Interrupt_Mask;\n+\n       --  Initialize the timer queue to empty, and make the wakeup time of the\n       --  header node be larger than any real wakeup time we will ever use.\n "}, {"sha": "651fc12269ace9412135250b19315ed46cfc2e68", "filename": "gcc/ada/s-taprop-dummy.adb", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-dummy.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-dummy.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-dummy.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -87,6 +87,15 @@ package body System.Task_Primitives.Operations is\n       return True;\n    end Check_No_Locks;\n \n+   -------------------\n+   -- Current_State --\n+   -------------------\n+\n+   function Current_State (S : Suspension_Object) return Boolean is\n+   begin\n+      return False;\n+   end Current_State;\n+\n    ----------------------\n    -- Environment_Task --\n    ----------------------\n@@ -129,6 +138,15 @@ package body System.Task_Primitives.Operations is\n       null;\n    end Exit_Task;\n \n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (S : in out Suspension_Object) is\n+   begin\n+      null;\n+   end Finalize;\n+\n    -------------------\n    -- Finalize_Lock --\n    -------------------\n@@ -179,6 +197,11 @@ package body System.Task_Primitives.Operations is\n       null;\n    end Initialize;\n \n+   procedure Initialize (S : in out Suspension_Object) is\n+   begin\n+      null;\n+   end Initialize;\n+\n    ---------------------\n    -- Initialize_Lock --\n    ---------------------\n@@ -289,6 +312,15 @@ package body System.Task_Primitives.Operations is\n       return Null_Task;\n    end Self;\n \n+   ---------------\n+   -- Set_False --\n+   ---------------\n+\n+   procedure Set_False (S : in out Suspension_Object) is\n+   begin\n+      null;\n+   end Set_False;\n+\n    ------------------\n    -- Set_Priority --\n    ------------------\n@@ -302,6 +334,15 @@ package body System.Task_Primitives.Operations is\n       null;\n    end Set_Priority;\n \n+   --------------\n+   -- Set_True --\n+   --------------\n+\n+   procedure Set_True (S : in out Suspension_Object) is\n+   begin\n+      null;\n+   end Set_True;\n+\n    -----------\n    -- Sleep --\n    -----------\n@@ -332,6 +373,15 @@ package body System.Task_Primitives.Operations is\n       return False;\n    end Suspend_Task;\n \n+   ------------------------\n+   -- Suspend_Until_True --\n+   ------------------------\n+\n+   procedure Suspend_Until_True (S : in out Suspension_Object) is\n+   begin\n+      null;\n+   end Suspend_Until_True;\n+\n    -----------------\n    -- Timed_Delay --\n    -----------------"}, {"sha": "998b4afdc1520c98a62a54fb24793dcdd487c071", "filename": "gcc/ada/s-taprop-hpux-dce.adb", "status": "modified", "additions": 152, "deletions": 2, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-hpux-dce.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-hpux-dce.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-hpux-dce.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -909,6 +909,156 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Abort_Task;\n \n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (S : in out Suspension_Object) is\n+      Mutex_Attr : aliased pthread_mutexattr_t;\n+      Cond_Attr  : aliased pthread_condattr_t;\n+      Result     : Interfaces.C.int;\n+   begin\n+      --  Initialize internal state. It is always initialized to False (ARM\n+      --  D.10 par. 6).\n+\n+      S.State := False;\n+      S.Waiting := False;\n+\n+      --  Initialize internal mutex\n+\n+      Result := pthread_mutex_init (S.L'Access, Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      --  Initialize internal condition variable\n+\n+      Result := pthread_cond_init (S.CV'Access, Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         if Result = ENOMEM then\n+            raise Storage_Error;\n+         end if;\n+      end if;\n+   end Initialize;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (S : in out Suspension_Object) is\n+      Result  : Interfaces.C.int;\n+   begin\n+      --  Destroy internal mutex\n+\n+      Result := pthread_mutex_destroy (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Destroy internal condition variable\n+\n+      Result := pthread_cond_destroy (S.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Finalize;\n+\n+   -------------------\n+   -- Current_State --\n+   -------------------\n+\n+   function Current_State (S : Suspension_Object) return Boolean is\n+   begin\n+      --  We do not want to use lock on this read operation. State is marked\n+      --  as Atomic so that we ensure that the value retrieved is correct.\n+\n+      return S.State;\n+   end Current_State;\n+\n+   ---------------\n+   -- Set_False --\n+   ---------------\n+\n+   procedure Set_False (S : in out Suspension_Object) is\n+      Result  : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      S.State := False;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Set_False;\n+\n+   --------------\n+   -- Set_True --\n+   --------------\n+\n+   procedure Set_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  If there is already a task waiting on this suspension object then\n+      --  we resume it, leaving the state of the suspension object to False,\n+      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves\n+      --  the state to True.\n+\n+      if S.Waiting then\n+         S.Waiting := False;\n+         S.State := False;\n+\n+         Result := pthread_cond_signal (S.CV'Access);\n+         pragma Assert (Result = 0);\n+      else\n+         S.State := True;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Set_True;\n+\n+   ------------------------\n+   -- Suspend_Until_True --\n+   ------------------------\n+\n+   procedure Suspend_Until_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      if S.Waiting then\n+         --  Program_Error must be raised upon calling Suspend_Until_True\n+         --  if another task is already waiting on that suspension object\n+         --  (ARM D.10 par. 10).\n+\n+         Result := pthread_mutex_unlock (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Program_Error;\n+      else\n+         --  Suspend the task if the state is False. Otherwise, the task\n+         --  continues its execution, and the state of the suspension object\n+         --  is set to False (ARM D.10 par. 9).\n+\n+         if S.State then\n+            S.State := False;\n+         else\n+            S.Waiting := True;\n+            Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+         end if;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Suspend_Until_True;\n+\n    ----------------\n    -- Check_Exit --\n    ----------------"}, {"sha": "64c1f069ca1fddcd41c91f3a60fddef072c51aa7", "filename": "gcc/ada/s-taprop-irix-athread.adb", "status": "modified", "additions": 183, "deletions": 2, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-irix-athread.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-irix-athread.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-irix-athread.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                 GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS              --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n --                                                                          --\n --     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -819,6 +819,187 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0);\n    end Abort_Task;\n \n+      ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (S : in out Suspension_Object) is\n+      Mutex_Attr : aliased pthread_mutexattr_t;\n+      Cond_Attr  : aliased pthread_condattr_t;\n+      Result     : Interfaces.C.int;\n+   begin\n+      --  Initialize internal state. It is always initialized to False (ARM\n+      --  D.10 par. 6).\n+\n+      S.State := False;\n+      S.Waiting := False;\n+\n+      --  Initialize internal mutex\n+\n+      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutex_init (S.L'Access, Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Initialize internal condition variable\n+\n+      Result := pthread_condattr_init (Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         if Result = ENOMEM then\n+            raise Storage_Error;\n+         end if;\n+      end if;\n+\n+      Result := pthread_cond_init (S.CV'Access, Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         if Result = ENOMEM then\n+            Result := pthread_condattr_destroy (Cond_Attr'Access);\n+            pragma Assert (Result = 0);\n+\n+            raise Storage_Error;\n+         end if;\n+      end if;\n+\n+      Result := pthread_condattr_destroy (Cond_Attr'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (S : in out Suspension_Object) is\n+      Result  : Interfaces.C.int;\n+   begin\n+      --  Destroy internal mutex\n+\n+      Result := pthread_mutex_destroy (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Destroy internal condition variable\n+\n+      Result := pthread_cond_destroy (S.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Finalize;\n+\n+   -------------------\n+   -- Current_State --\n+   -------------------\n+\n+   function Current_State (S : Suspension_Object) return Boolean is\n+   begin\n+      --  We do not want to use lock on this read operation. State is marked\n+      --  as Atomic so that we ensure that the value retrieved is correct.\n+\n+      return S.State;\n+   end Current_State;\n+\n+   ---------------\n+   -- Set_False --\n+   ---------------\n+\n+   procedure Set_False (S : in out Suspension_Object) is\n+      Result  : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      S.State := False;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Set_False;\n+\n+   --------------\n+   -- Set_True --\n+   --------------\n+\n+   procedure Set_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  If there is already a task waiting on this suspension object then\n+      --  we resume it, leaving the state of the suspension object to False,\n+      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves\n+      --  the state to True.\n+\n+      if S.Waiting then\n+         S.Waiting := False;\n+         S.State := False;\n+\n+         Result := pthread_cond_signal (S.CV'Access);\n+         pragma Assert (Result = 0);\n+      else\n+         S.State := True;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Set_True;\n+\n+   ------------------------\n+   -- Suspend_Until_True --\n+   ------------------------\n+\n+   procedure Suspend_Until_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      if S.Waiting then\n+         --  Program_Error must be raised upon calling Suspend_Until_True\n+         --  if another task is already waiting on that suspension object\n+         --  (ARM D.10 par. 10).\n+\n+         Result := pthread_mutex_unlock (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Program_Error;\n+      else\n+         --  Suspend the task if the state is False. Otherwise, the task\n+         --  continues its execution, and the state of the suspension object\n+         --  is set to False (ARM D.10 par. 9).\n+\n+         if S.State then\n+            S.State := False;\n+         else\n+            S.Waiting := True;\n+            Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+         end if;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Suspend_Until_True;\n+\n    ----------------\n    -- Check_Exit --\n    ----------------"}, {"sha": "e3b05b54f8f2bb8ed7871f1fe67e89336f691ce5", "filename": "gcc/ada/s-taprop-irix.adb", "status": "modified", "additions": 184, "deletions": 16, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-irix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-irix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-irix.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -57,11 +57,6 @@ with System.Interrupt_Management;\n --           Abort_Task_Interrupt\n --           Interrupt_ID\n \n-with System.Interrupt_Management.Operations;\n---  used for Set_Interrupt_Mask\n---           All_Tasks_Mask\n-pragma Elaborate_All (System.Interrupt_Management.Operations);\n-\n with System.Parameters;\n --  used for Size_Type\n \n@@ -964,6 +959,187 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0);\n    end Abort_Task;\n \n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (S : in out Suspension_Object) is\n+      Mutex_Attr : aliased pthread_mutexattr_t;\n+      Cond_Attr  : aliased pthread_condattr_t;\n+      Result     : Interfaces.C.int;\n+   begin\n+      --  Initialize internal state. It is always initialized to False (ARM\n+      --  D.10 par. 6).\n+\n+      S.State := False;\n+      S.Waiting := False;\n+\n+      --  Initialize internal mutex\n+\n+      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutex_init (S.L'Access, Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Initialize internal condition variable\n+\n+      Result := pthread_condattr_init (Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         if Result = ENOMEM then\n+            raise Storage_Error;\n+         end if;\n+      end if;\n+\n+      Result := pthread_cond_init (S.CV'Access, Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         if Result = ENOMEM then\n+            Result := pthread_condattr_destroy (Cond_Attr'Access);\n+            pragma Assert (Result = 0);\n+\n+            raise Storage_Error;\n+         end if;\n+      end if;\n+\n+      Result := pthread_condattr_destroy (Cond_Attr'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (S : in out Suspension_Object) is\n+      Result  : Interfaces.C.int;\n+   begin\n+      --  Destroy internal mutex\n+\n+      Result := pthread_mutex_destroy (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Destroy internal condition variable\n+\n+      Result := pthread_cond_destroy (S.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Finalize;\n+\n+   -------------------\n+   -- Current_State --\n+   -------------------\n+\n+   function Current_State (S : Suspension_Object) return Boolean is\n+   begin\n+      --  We do not want to use lock on this read operation. State is marked\n+      --  as Atomic so that we ensure that the value retrieved is correct.\n+\n+      return S.State;\n+   end Current_State;\n+\n+   ---------------\n+   -- Set_False --\n+   ---------------\n+\n+   procedure Set_False (S : in out Suspension_Object) is\n+      Result  : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      S.State := False;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Set_False;\n+\n+   --------------\n+   -- Set_True --\n+   --------------\n+\n+   procedure Set_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  If there is already a task waiting on this suspension object then\n+      --  we resume it, leaving the state of the suspension object to False,\n+      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves\n+      --  the state to True.\n+\n+      if S.Waiting then\n+         S.Waiting := False;\n+         S.State := False;\n+\n+         Result := pthread_cond_signal (S.CV'Access);\n+         pragma Assert (Result = 0);\n+      else\n+         S.State := True;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Set_True;\n+\n+   ------------------------\n+   -- Suspend_Until_True --\n+   ------------------------\n+\n+   procedure Suspend_Until_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      if S.Waiting then\n+         --  Program_Error must be raised upon calling Suspend_Until_True\n+         --  if another task is already waiting on that suspension object\n+         --  (ARM D.10 par. 10).\n+\n+         Result := pthread_mutex_unlock (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Program_Error;\n+      else\n+         --  Suspend the task if the state is False. Otherwise, the task\n+         --  continues its execution, and the state of the suspension object\n+         --  is set to False (ARM D.10 par. 9).\n+\n+         if S.State then\n+            S.State := False;\n+         else\n+            S.Waiting := True;\n+            Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+         end if;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Suspend_Until_True;\n+\n    ----------------\n    -- Check_Exit --\n    ----------------\n@@ -1078,7 +1254,7 @@ package body System.Task_Primitives.Operations is\n       --  Install the abort-signal handler\n \n       if State (System.Interrupt_Management.Abort_Task_Interrupt)\n-                                                        /= Default\n+        /= Default\n       then\n          act.sa_flags := 0;\n          act.sa_handler := Abort_Handler'Address;\n@@ -1099,15 +1275,7 @@ package body System.Task_Primitives.Operations is\n begin\n    declare\n       Result : Interfaces.C.int;\n-\n    begin\n-      --  Mask Environment task for all signals. The original mask of the\n-      --  Environment task will be recovered by Interrupt_Server task\n-      --  during the elaboration of s-interr.adb.\n-\n-      System.Interrupt_Management.Operations.Set_Interrupt_Mask\n-        (System.Interrupt_Management.Operations.All_Tasks_Mask'Access);\n-\n       --  Prepare the set of signals that should unblocked in all tasks\n \n       Result := sigemptyset (Unblocked_Signal_Mask'Access);"}, {"sha": "07a44dfc573516cd76be5c58415922c99dceae26", "filename": "gcc/ada/s-taprop-linux.adb", "status": "modified", "additions": 152, "deletions": 15, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-linux.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -52,11 +52,6 @@ with System.Interrupt_Management;\n --           Abort_Task_Interrupt\n --           Interrupt_ID\n \n-with System.Interrupt_Management.Operations;\n---  used for Set_Interrupt_Mask\n---           All_Tasks_Mask\n-pragma Elaborate_All (System.Interrupt_Management.Operations);\n-\n with System.Parameters;\n --  used for Size_Type\n \n@@ -81,7 +76,7 @@ with System.OS_Primitives;\n --  used for Delay_Modes\n \n with System.Soft_Links;\n---  used for Get_Machine_State_Addr\n+--  used for Abort_Defer/Undefer\n \n with Unchecked_Conversion;\n with Unchecked_Deallocation;\n@@ -932,6 +927,156 @@ package body System.Task_Primitives.Operations is\n       pragma Assert (Result = 0);\n    end Abort_Task;\n \n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      --  Initialize internal state. It is always initialized to False (ARM\n+      --  D.10 par. 6).\n+\n+      S.State := False;\n+      S.Waiting := False;\n+\n+      --  Initialize internal mutex\n+\n+      Result := pthread_mutex_init (S.L'Access, Mutex_Attr'Access);\n+\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      --  Initialize internal condition variable\n+\n+      Result := pthread_cond_init (S.CV'Access, Cond_Attr'Access);\n+\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         if Result = ENOMEM then\n+            raise Storage_Error;\n+         end if;\n+      end if;\n+   end Initialize;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (S : in out Suspension_Object) is\n+      Result  : Interfaces.C.int;\n+   begin\n+      --  Destroy internal mutex\n+\n+      Result := pthread_mutex_destroy (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Destroy internal condition variable\n+\n+      Result := pthread_cond_destroy (S.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Finalize;\n+\n+   -------------------\n+   -- Current_State --\n+   -------------------\n+\n+   function Current_State (S : Suspension_Object) return Boolean is\n+   begin\n+      --  We do not want to use lock on this read operation. State is marked\n+      --  as Atomic so that we ensure that the value retrieved is correct.\n+\n+      return S.State;\n+   end Current_State;\n+\n+   ---------------\n+   -- Set_False --\n+   ---------------\n+\n+   procedure Set_False (S : in out Suspension_Object) is\n+      Result  : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      S.State := False;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Set_False;\n+\n+   --------------\n+   -- Set_True --\n+   --------------\n+\n+   procedure Set_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  If there is already a task waiting on this suspension object then\n+      --  we resume it, leaving the state of the suspension object to False,\n+      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves\n+      --  the state to True.\n+\n+      if S.Waiting then\n+         S.Waiting := False;\n+         S.State := False;\n+\n+         Result := pthread_cond_signal (S.CV'Access);\n+         pragma Assert (Result = 0);\n+      else\n+         S.State := True;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Set_True;\n+\n+   ------------------------\n+   -- Suspend_Until_True --\n+   ------------------------\n+\n+   procedure Suspend_Until_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      if S.Waiting then\n+         --  Program_Error must be raised upon calling Suspend_Until_True\n+         --  if another task is already waiting on that suspension object\n+         --  (ARM D.10 par. 10).\n+\n+         Result := pthread_mutex_unlock (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Program_Error;\n+      else\n+         --  Suspend the task if the state is False. Otherwise, the task\n+         --  continues its execution, and the state of the suspension object\n+         --  is set to False (ARM D.10 par. 9).\n+\n+         if S.State then\n+            S.State := False;\n+         else\n+            S.Waiting := True;\n+            Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+         end if;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Suspend_Until_True;\n+\n    ----------------\n    -- Check_Exit --\n    ----------------\n@@ -1054,15 +1199,7 @@ package body System.Task_Primitives.Operations is\n begin\n    declare\n       Result : Interfaces.C.int;\n-\n    begin\n-      --  Mask Environment task for all signals. The original mask of the\n-      --  Environment task will be recovered by Interrupt_Server task\n-      --  during the elaboration of s-interr.adb.\n-\n-      System.Interrupt_Management.Operations.Set_Interrupt_Mask\n-        (System.Interrupt_Management.Operations.All_Tasks_Mask'Access);\n-\n       --  Prepare the set of signals that should unblocked in all tasks\n \n       Result := sigemptyset (Unblocked_Signal_Mask'Access);"}, {"sha": "889bdf23318f33a9b6dbe29d80d97e3e35489df2", "filename": "gcc/ada/s-taprop-lynxos.adb", "status": "modified", "additions": 198, "deletions": 31, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-lynxos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-lynxos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-lynxos.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -56,11 +56,6 @@ with System.Interrupt_Management;\n --           Abort_Task_Interrupt\n --           Interrupt_ID\n \n-with System.Interrupt_Management.Operations;\n---  used for Set_Interrupt_Mask\n---           All_Tasks_Mask\n-pragma Elaborate_All (System.Interrupt_Management.Operations);\n-\n with System.Parameters;\n --  used for Size_Type\n \n@@ -108,7 +103,7 @@ package body System.Task_Primitives.Operations is\n    --  Key used to find the Ada Task_Id associated with a thread\n \n    Environment_Task_Id : Task_Id;\n-   --  A variable to hold Task_Id for the environment task.\n+   --  A variable to hold Task_Id for the environment task\n \n    Locking_Policy : Character;\n    pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n@@ -120,7 +115,7 @@ package body System.Task_Primitives.Operations is\n    Unblocked_Signal_Mask : aliased sigset_t;\n    --  The set of signals that should unblocked in all tasks\n \n-   --  The followings are internal configuration constants needed.\n+   --  The followings are internal configuration constants needed\n \n    Next_Serial_Number : Task_Serial_Number := 100;\n    --  We start at 100, to reserve some special values for\n@@ -133,10 +128,10 @@ package body System.Task_Primitives.Operations is\n    pragma Import (C, Dispatching_Policy, \"__gl_task_dispatching_policy\");\n \n    FIFO_Within_Priorities : constant Boolean := Dispatching_Policy = 'F';\n-   --  Indicates whether FIFO_Within_Priorities is set.\n+   --  Indicates whether FIFO_Within_Priorities is set\n \n    Foreign_Task_Elaborated : aliased Boolean := True;\n-   --  Used to identified fake tasks (i.e., non-Ada Threads).\n+   --  Used to identified fake tasks (i.e., non-Ada Threads)\n \n    --------------------\n    -- Local Packages --\n@@ -146,31 +141,31 @@ package body System.Task_Primitives.Operations is\n \n       procedure Initialize (Environment_Task : Task_Id);\n       pragma Inline (Initialize);\n-      --  Initialize various data needed by this package.\n+      --  Initialize various data needed by this package\n \n       function Is_Valid_Task return Boolean;\n       pragma Inline (Is_Valid_Task);\n       --  Does the current thread have an ATCB?\n \n       procedure Set (Self_Id : Task_Id);\n       pragma Inline (Set);\n-      --  Set the self id for the current task.\n+      --  Set the self id for the current task\n \n       function Self return Task_Id;\n       pragma Inline (Self);\n-      --  Return a pointer to the Ada Task Control Block of the calling task.\n+      --  Return a pointer to the Ada Task Control Block of the calling task\n \n    end Specific;\n \n    package body Specific is separate;\n-   --  The body of this package is target specific.\n+   --  The body of this package is target specific\n \n    ---------------------------------\n    -- Support for foreign threads --\n    ---------------------------------\n \n    function Register_Foreign_Thread (Thread : Thread_Id) return Task_Id;\n-   --  Allocate and Initialize a new ATCB for the current Thread.\n+   --  Allocate and Initialize a new ATCB for the current Thread\n \n    function Register_Foreign_Thread\n      (Thread : Thread_Id) return Task_Id is separate;\n@@ -180,7 +175,7 @@ package body System.Task_Primitives.Operations is\n    -----------------------\n \n    procedure Abort_Handler (Sig : Signal);\n-   --  Signal handler used to implement asynchronous abort.\n+   --  Signal handler used to implement asynchronous abort\n \n    procedure Set_OS_Priority (T : Task_Id; Prio : System.Any_Priority);\n    --  This procedure calls the scheduler of the OS to set thread's priority\n@@ -1016,13 +1011,193 @@ package body System.Task_Primitives.Operations is\n    procedure Abort_Task (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n-      Result :=\n-        pthread_kill\n-          (T.Common.LL.Thread,\n-           Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n+      Result := pthread_kill (T.Common.LL.Thread,\n+         Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n       pragma Assert (Result = 0);\n    end Abort_Task;\n \n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (S : in out Suspension_Object) is\n+      Mutex_Attr : aliased pthread_mutexattr_t;\n+      Cond_Attr  : aliased pthread_condattr_t;\n+      Result     : Interfaces.C.int;\n+\n+   begin\n+      --  Initialize internal state. It is always initialized to False (ARM\n+      --  D.10 par. 6).\n+\n+      S.State := False;\n+      S.Waiting := False;\n+\n+      --  Initialize internal mutex\n+\n+      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutex_init (S.L'Access, Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Initialize internal condition variable\n+\n+      Result := pthread_condattr_init (Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         if Result = ENOMEM then\n+            raise Storage_Error;\n+         end if;\n+      end if;\n+\n+      Result := pthread_cond_init (S.CV'Access, Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         if Result = ENOMEM then\n+            Result := pthread_condattr_destroy (Cond_Attr'Access);\n+            pragma Assert (Result = 0);\n+\n+            raise Storage_Error;\n+         end if;\n+      end if;\n+\n+      Result := pthread_condattr_destroy (Cond_Attr'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (S : in out Suspension_Object) is\n+      Result  : Interfaces.C.int;\n+   begin\n+      --  Destroy internal mutex\n+\n+      Result := pthread_mutex_destroy (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Destroy internal condition variable\n+\n+      Result := pthread_cond_destroy (S.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Finalize;\n+\n+   -------------------\n+   -- Current_State --\n+   -------------------\n+\n+   function Current_State (S : Suspension_Object) return Boolean is\n+   begin\n+      --  We do not want to use lock on this read operation. State is marked\n+      --  as Atomic so that we ensure that the value retrieved is correct.\n+\n+      return S.State;\n+   end Current_State;\n+\n+   ---------------\n+   -- Set_False --\n+   ---------------\n+\n+   procedure Set_False (S : in out Suspension_Object) is\n+      Result  : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      S.State := False;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Set_False;\n+\n+   --------------\n+   -- Set_True --\n+   --------------\n+\n+   procedure Set_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  If there is already a task waiting on this suspension object then\n+      --  we resume it, leaving the state of the suspension object to False,\n+      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves\n+      --  the state to True.\n+\n+      if S.Waiting then\n+         S.Waiting := False;\n+         S.State := False;\n+\n+         Result := pthread_cond_signal (S.CV'Access);\n+         pragma Assert (Result = 0);\n+      else\n+         S.State := True;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Set_True;\n+\n+   ------------------------\n+   -- Suspend_Until_True --\n+   ------------------------\n+\n+   procedure Suspend_Until_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      if S.Waiting then\n+         --  Program_Error must be raised upon calling Suspend_Until_True\n+         --  if another task is already waiting on that suspension object\n+         --  (ARM D.10 par. 10).\n+\n+         Result := pthread_mutex_unlock (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Program_Error;\n+      else\n+         --  Suspend the task if the state is False. Otherwise, the task\n+         --  continues its execution, and the state of the suspension object\n+         --  is set to False (ARM D.10 par. 9).\n+\n+         if S.State then\n+            S.State := False;\n+         else\n+            S.Waiting := True;\n+            Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+         end if;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Suspend_Until_True;\n+\n    ----------------\n    -- Check_Exit --\n    ----------------\n@@ -1127,7 +1302,7 @@ package body System.Task_Primitives.Operations is\n    begin\n       Environment_Task_Id := Environment_Task;\n \n-      --  Initialize the lock used to synchronize chain of all ATCBs.\n+      --  Initialize the lock used to synchronize chain of all ATCBs\n \n       Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n \n@@ -1138,7 +1313,7 @@ package body System.Task_Primitives.Operations is\n       --  Install the abort-signal handler\n \n       if State (System.Interrupt_Management.Abort_Task_Interrupt)\n-                                                     /= Default\n+        /= Default\n       then\n          act.sa_flags := 0;\n          act.sa_handler := Abort_Handler'Address;\n@@ -1160,15 +1335,7 @@ package body System.Task_Primitives.Operations is\n begin\n    declare\n       Result : Interfaces.C.int;\n-\n    begin\n-      --  Mask Environment task for all signals. The original mask of the\n-      --  Environment task will be recovered by Interrupt_Server task\n-      --  during the elaboration of s-interr.adb.\n-\n-      System.Interrupt_Management.Operations.Set_Interrupt_Mask\n-        (System.Interrupt_Management.Operations.All_Tasks_Mask'Access);\n-\n       --  Prepare the set of signals that should unblocked in all tasks\n \n       Result := sigemptyset (Unblocked_Signal_Mask'Access);"}, {"sha": "11a5b7a0a0b44ed38a35b4931611a7f4fae461e1", "filename": "gcc/ada/s-taprop-mingw.adb", "status": "modified", "additions": 135, "deletions": 1, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-mingw.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,6 +1,6 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n --                                                                          --\n@@ -1040,6 +1040,140 @@ package body System.Task_Primitives.Operations is\n       return 0.000_001; --  1 micro-second\n    end RT_Resolution;\n \n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (S : in out Suspension_Object) is\n+   begin\n+      --  Initialize internal state. It is always initialized to False (ARM\n+      --  D.10 par. 6).\n+\n+      S.State := False;\n+      S.Waiting := False;\n+\n+      --  Initialize internal mutex\n+\n+      InitializeCriticalSection (S.L'Access);\n+\n+      --  Initialize internal condition variable\n+\n+      S.CV := CreateEvent (null, True, False, Null_Ptr);\n+      pragma Assert (S.CV /= 0);\n+   end Initialize;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (S : in out Suspension_Object) is\n+      Result : BOOL;\n+   begin\n+      --  Destroy internal mutex\n+\n+      DeleteCriticalSection (S.L'Access);\n+\n+      --  Destroy internal condition variable\n+\n+      Result := CloseHandle (S.CV);\n+      pragma Assert (Result = True);\n+   end Finalize;\n+\n+   -------------------\n+   -- Current_State --\n+   -------------------\n+\n+   function Current_State (S : Suspension_Object) return Boolean is\n+   begin\n+      --  We do not want to use lock on this read operation. State is marked\n+      --  as Atomic so that we ensure that the value retrieved is correct.\n+\n+      return S.State;\n+   end Current_State;\n+\n+   ---------------\n+   -- Set_False --\n+   ---------------\n+\n+   procedure Set_False (S : in out Suspension_Object) is\n+   begin\n+      EnterCriticalSection (S.L'Access);\n+\n+      S.State := False;\n+\n+      LeaveCriticalSection (S.L'Access);\n+   end Set_False;\n+\n+   --------------\n+   -- Set_True --\n+   --------------\n+\n+   procedure Set_True (S : in out Suspension_Object) is\n+      Result : BOOL;\n+   begin\n+      EnterCriticalSection (S.L'Access);\n+\n+      --  If there is already a task waiting on this suspension object then\n+      --  we resume it, leaving the state of the suspension object to False,\n+      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves\n+      --  the state to True.\n+\n+      if S.Waiting then\n+         S.Waiting := False;\n+         S.State := False;\n+\n+         Result := SetEvent (S.CV);\n+         pragma Assert (Result = True);\n+      else\n+         S.State := True;\n+      end if;\n+\n+      LeaveCriticalSection (S.L'Access);\n+   end Set_True;\n+\n+   ------------------------\n+   -- Suspend_Until_True --\n+   ------------------------\n+\n+   procedure Suspend_Until_True (S : in out Suspension_Object) is\n+      Result      : DWORD;\n+      Result_Bool : BOOL;\n+   begin\n+      EnterCriticalSection (S.L'Access);\n+\n+      if S.Waiting then\n+         --  Program_Error must be raised upon calling Suspend_Until_True\n+         --  if another task is already waiting on that suspension object\n+         --  (ARM D.10 par. 10).\n+\n+         LeaveCriticalSection (S.L'Access);\n+\n+         raise Program_Error;\n+      else\n+         --  Suspend the task if the state is False. Otherwise, the task\n+         --  continues its execution, and the state of the suspension object\n+         --  is set to False (ARM D.10 par. 9).\n+\n+         if S.State then\n+            S.State := False;\n+\n+            LeaveCriticalSection (S.L'Access);\n+         else\n+            S.Waiting := True;\n+\n+            --  Must reset CV BEFORE L is unlocked.\n+\n+            Result_Bool := ResetEvent (S.CV);\n+            pragma Assert (Result_Bool = True);\n+\n+            LeaveCriticalSection (S.L'Access);\n+\n+            Result := WaitForSingleObject (S.CV, Wait_Infinite);\n+            pragma Assert (Result = 0);\n+         end if;\n+      end if;\n+   end Suspend_Until_True;\n+\n    ----------------\n    -- Check_Exit --\n    ----------------"}, {"sha": "cd99f79b4a5e30e39286904e4e38dba85100bee5", "filename": "gcc/ada/s-taprop-os2.adb", "status": "modified", "additions": 143, "deletions": 1, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-os2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-os2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-os2.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,6 +1,6 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                 GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS              --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n --                                                                          --\n --    S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S     --\n --                                                                          --\n@@ -1012,6 +1012,148 @@ package body System.Task_Primitives.Operations is\n \n    end Abort_Task;\n \n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      --  Initialize internal state. It is always initialized to False (ARM\n+      --  D.10 par. 6).\n+\n+      S.State := False;\n+      S.Waiting := False;\n+\n+      --  Initialize internal mutex\n+      if DosCreateMutexSem\n+        (ICS.Null_Ptr, S.L'Unchecked_Access, 0, False32) /= NO_ERROR\n+      then\n+         raise Storage_Error;\n+      end if;\n+\n+      pragma Assert (S.L /= 0, \"Error creating Mutex\");\n+\n+      --  Initialize internal condition variable\n+\n+      if DosCreateEventSem\n+        (ICS.Null_Ptr, S.CV'Unchecked_Access, 0, True32) /= NO_ERROR\n+      then\n+         Must_Not_Fail (DosCloseMutexSem (S.L));\n+\n+         raise Storage_Error;\n+      end if;\n+\n+      pragma Assert (S.CV /= 0, \"Error creating Condition Variable\");\n+   end Initialize;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (S : in out Suspension_Object) is\n+   begin\n+      --  Destroy internal mutex\n+\n+      Must_Not_Fail (DosCloseMutexSem (S.L'Access));\n+\n+      --  Destroy internal condition variable\n+\n+      Must_Not_Fail (DosCloseEventSem (S.CV'Access));\n+   end Finalize;\n+\n+   -------------------\n+   -- Current_State --\n+   -------------------\n+\n+   function Current_State (S : Suspension_Object) return Boolean is\n+   begin\n+      --  We do not want to use lock on this read operation. State is marked\n+      --  as Atomic so that we ensure that the value retrieved is correct.\n+\n+      return S.State;\n+   end Current_State;\n+\n+   ---------------\n+   -- Set_False --\n+   ---------------\n+\n+   procedure Set_False (S : in out Suspension_Object) is\n+   begin\n+      Must_Not_Fail (DosRequestMutexSem (S.L, SEM_INDEFINITE_WAIT));\n+\n+      S.State := False;\n+\n+      Must_Not_Fail (DosReleaseMutexSem (S.L));\n+   end Set_False;\n+\n+   --------------\n+   -- Set_True --\n+   --------------\n+\n+   procedure Set_True (S : in out Suspension_Object) is\n+   begin\n+      Must_Not_Fail (DosRequestMutexSem (S.L, SEM_INDEFINITE_WAIT));\n+\n+      --  If there is already a task waiting on this suspension object then\n+      --  we resume it, leaving the state of the suspension object to False,\n+      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves\n+      --  the state to True.\n+\n+      if S.Waiting then\n+         S.Waiting := False;\n+         S.State := False;\n+\n+         Sem_Must_Not_Fail (DosPostEventSem (S.CV));\n+      else\n+         S.State := True;\n+      end if;\n+\n+      Must_Not_Fail (DosReleaseMutexSem (S.L));\n+   end Set_True;\n+\n+   ------------------------\n+   -- Suspend_Until_True --\n+   ------------------------\n+\n+   procedure Suspend_Until_True (S : in out Suspension_Object) is\n+      Count : aliased ULONG; -- Used to store dummy result\n+   begin\n+      Must_Not_Fail (DosRequestMutexSem (S.L, SEM_INDEFINITE_WAIT));\n+\n+      if S.Waiting then\n+         --  Program_Error must be raised upon calling Suspend_Until_True\n+         --  if another task is already waiting on that suspension object\n+         --  (ARM D.10 par. 10).\n+\n+         Must_Not_Fail (DosReleaseMutexSem (S.L));\n+\n+         raise Program_Error;\n+      else\n+         --  Suspend the task if the state is False. Otherwise, the task\n+         --  continues its execution, and the state of the suspension object\n+         --  is set to False (ARM D.10 par. 9).\n+\n+         if S.State then\n+            S.State := False;\n+\n+            Must_Not_Fail (DosReleaseMutexSem (S.L));\n+         else\n+            S.Waiting := True;\n+\n+            --  Must reset Cond BEFORE L is unlocked\n+\n+            Sem_Must_Not_Fail\n+              (DosResetEventSem (S.CV, Count'Unchecked_Access));\n+\n+            Must_Not_Fail (DosReleaseMutexSem (S.L));\n+\n+            Sem_Must_Not_Fail\n+              (DosWaitEventSem (S.CV, SEM_INDEFINITE_WAIT));\n+         end if;\n+      end if;\n+   end Suspend_Until_True;\n+\n    ----------------\n    -- Check_Exit --\n    ----------------"}, {"sha": "268fa22861232b6ea9bf62cadc25d244fba0ddf3", "filename": "gcc/ada/s-taprop-posix.adb", "status": "modified", "additions": 183, "deletions": 15, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-posix.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -61,11 +61,6 @@ with System.Interrupt_Management;\n --           Abort_Task_Interrupt\n --           Interrupt_ID\n \n-with System.Interrupt_Management.Operations;\n---  used for Set_Interrupt_Mask\n---           All_Tasks_Mask\n-pragma Elaborate_All (System.Interrupt_Management.Operations);\n-\n with System.Parameters;\n --  used for Size_Type\n \n@@ -1037,13 +1032,193 @@ package body System.Task_Primitives.Operations is\n \n    procedure Abort_Task (T : Task_Id) is\n       Result : Interfaces.C.int;\n-\n    begin\n       Result := pthread_kill (T.Common.LL.Thread,\n         Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n       pragma Assert (Result = 0);\n    end Abort_Task;\n \n+      ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (S : in out Suspension_Object) is\n+      Mutex_Attr : aliased pthread_mutexattr_t;\n+      Cond_Attr  : aliased pthread_condattr_t;\n+      Result     : Interfaces.C.int;\n+   begin\n+      --  Initialize internal state. It is always initialized to False (ARM\n+      --  D.10 par. 6).\n+\n+      S.State := False;\n+      S.Waiting := False;\n+\n+      --  Initialize internal mutex\n+\n+      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutex_init (S.L'Access, Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Initialize internal condition variable\n+\n+      Result := pthread_condattr_init (Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         if Result = ENOMEM then\n+            raise Storage_Error;\n+         end if;\n+      end if;\n+\n+      Result := pthread_cond_init (S.CV'Access, Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         if Result = ENOMEM then\n+            Result := pthread_condattr_destroy (Cond_Attr'Access);\n+            pragma Assert (Result = 0);\n+\n+            raise Storage_Error;\n+         end if;\n+      end if;\n+\n+      Result := pthread_condattr_destroy (Cond_Attr'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (S : in out Suspension_Object) is\n+      Result  : Interfaces.C.int;\n+   begin\n+      --  Destroy internal mutex\n+\n+      Result := pthread_mutex_destroy (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Destroy internal condition variable\n+\n+      Result := pthread_cond_destroy (S.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Finalize;\n+\n+   -------------------\n+   -- Current_State --\n+   -------------------\n+\n+   function Current_State (S : Suspension_Object) return Boolean is\n+   begin\n+      --  We do not want to use lock on this read operation. State is marked\n+      --  as Atomic so that we ensure that the value retrieved is correct.\n+\n+      return S.State;\n+   end Current_State;\n+\n+   ---------------\n+   -- Set_False --\n+   ---------------\n+\n+   procedure Set_False (S : in out Suspension_Object) is\n+      Result  : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      S.State := False;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Set_False;\n+\n+   --------------\n+   -- Set_True --\n+   --------------\n+\n+   procedure Set_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  If there is already a task waiting on this suspension object then\n+      --  we resume it, leaving the state of the suspension object to False,\n+      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves\n+      --  the state to True.\n+\n+      if S.Waiting then\n+         S.Waiting := False;\n+         S.State := False;\n+\n+         Result := pthread_cond_signal (S.CV'Access);\n+         pragma Assert (Result = 0);\n+      else\n+         S.State := True;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Set_True;\n+\n+   ------------------------\n+   -- Suspend_Until_True --\n+   ------------------------\n+\n+   procedure Suspend_Until_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      if S.Waiting then\n+         --  Program_Error must be raised upon calling Suspend_Until_True\n+         --  if another task is already waiting on that suspension object\n+         --  (ARM D.10 par. 10).\n+\n+         Result := pthread_mutex_unlock (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Program_Error;\n+      else\n+         --  Suspend the task if the state is False. Otherwise, the task\n+         --  continues its execution, and the state of the suspension object\n+         --  is set to False (ARM D.10 par. 9).\n+\n+         if S.State then\n+            S.State := False;\n+         else\n+            S.Waiting := True;\n+            Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+         end if;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Suspend_Until_True;\n+\n    ----------------\n    -- Check_Exit --\n    ----------------\n@@ -1181,13 +1356,6 @@ begin\n    declare\n       Result : Interfaces.C.int;\n    begin\n-      --  Mask Environment task for all signals. The original mask of the\n-      --  Environment task will be recovered by Interrupt_Server task\n-      --  during the elaboration of s-interr.adb.\n-\n-      System.Interrupt_Management.Operations.Set_Interrupt_Mask\n-        (System.Interrupt_Management.Operations.All_Tasks_Mask'Access);\n-\n       --  Prepare the set of signals that should unblocked in all tasks\n \n       Result := sigemptyset (Unblocked_Signal_Mask'Access);"}, {"sha": "dda5779d932d0fbc17ee30247896d955c3eda908", "filename": "gcc/ada/s-taprop-solaris.adb", "status": "modified", "additions": 150, "deletions": 17, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-solaris.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-solaris.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-solaris.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -58,11 +58,6 @@ with System.Interrupt_Management;\n --           Abort_Task_Interrupt\n --           Interrupt_ID\n \n-with System.Interrupt_Management.Operations;\n---  used for Set_Interrupt_Mask\n---           All_Tasks_Mask\n-pragma Elaborate_All (System.Interrupt_Management.Operations);\n-\n with System.Parameters;\n --  used for Size_Type\n \n@@ -1060,8 +1055,6 @@ package body System.Task_Primitives.Operations is\n \n       Result := thr_kill (T.Common.LL.Thread,\n         Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n-      null;\n-\n       pragma Assert (Result = 0);\n    end Abort_Task;\n \n@@ -1631,6 +1624,154 @@ package body System.Task_Primitives.Operations is\n       return True;\n    end Check_Finalize_Lock;\n \n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      --  Initialize internal state. It is always initialized to False (ARM\n+      --  D.10 par. 6).\n+\n+      S.State := False;\n+      S.Waiting := False;\n+\n+      --  Initialize internal mutex\n+\n+      Result := mutex_init (S.L'Access, USYNC_THREAD, System.Null_Address);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Raise_Exception (Storage_Error'Identity, \"Failed to allocate a lock\");\n+      end if;\n+\n+      --  Initialize internal condition variable\n+\n+      Result := cond_init (S.CV'Access, USYNC_THREAD, 0);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         if Result = ENOMEM then\n+            raise Storage_Error;\n+         end if;\n+      end if;\n+   end Initialize;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (S : in out Suspension_Object) is\n+      Result  : Interfaces.C.int;\n+   begin\n+      --  Destroy internal mutex\n+\n+      Result := mutex_destroy (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Destroy internal condition variable\n+\n+      Result := cond_destroy (S.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Finalize;\n+\n+   -------------------\n+   -- Current_State --\n+   -------------------\n+\n+   function Current_State (S : Suspension_Object) return Boolean is\n+   begin\n+      --  We do not want to use lock on this read operation. State is marked\n+      --  as Atomic so that we ensure that the value retrieved is correct.\n+\n+      return S.State;\n+   end Current_State;\n+\n+   ---------------\n+   -- Set_False --\n+   ---------------\n+\n+   procedure Set_False (S : in out Suspension_Object) is\n+      Result  : Interfaces.C.int;\n+   begin\n+      Result := mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      S.State := False;\n+\n+      Result := mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Set_False;\n+\n+   --------------\n+   -- Set_True --\n+   --------------\n+\n+   procedure Set_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  If there is already a task waiting on this suspension object then\n+      --  we resume it, leaving the state of the suspension object to False,\n+      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves\n+      --  the state to True.\n+\n+      if S.Waiting then\n+         S.Waiting := False;\n+         S.State := False;\n+\n+         Result := cond_signal (S.CV'Access);\n+         pragma Assert (Result = 0);\n+      else\n+         S.State := True;\n+      end if;\n+\n+      Result := mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Set_True;\n+\n+   ------------------------\n+   -- Suspend_Until_True --\n+   ------------------------\n+\n+   procedure Suspend_Until_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      if S.Waiting then\n+         --  Program_Error must be raised upon calling Suspend_Until_True\n+         --  if another task is already waiting on that suspension object\n+         --  (ARM D.10 par. 10).\n+\n+         Result := mutex_unlock (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Program_Error;\n+      else\n+         --  Suspend the task if the state is False. Otherwise, the task\n+         --  continues its execution, and the state of the suspension object\n+         --  is set to False (ARM D.10 par. 9).\n+\n+         if S.State then\n+            S.State := False;\n+         else\n+            S.Waiting := True;\n+            Result := cond_wait (S.CV'Access, S.L'Access);\n+         end if;\n+      end if;\n+\n+      Result := mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Suspend_Until_True;\n+\n    ----------------\n    -- Check_Exit --\n    ----------------\n@@ -1736,15 +1877,7 @@ package body System.Task_Primitives.Operations is\n begin\n    declare\n       Result : Interfaces.C.int;\n-\n    begin\n-      --  Mask Environment task for all signals. The original mask of the\n-      --  Environment task will be recovered by Interrupt_Server task\n-      --  during the elaboration of s-interr.adb.\n-\n-      System.Interrupt_Management.Operations.Set_Interrupt_Mask\n-        (System.Interrupt_Management.Operations.All_Tasks_Mask'Access);\n-\n       --  Prepare the set of signals that should unblocked in all tasks\n \n       Result := sigemptyset (Unblocked_Signal_Mask'Access);"}, {"sha": "89d4ca31413b4ebd8cc47315ebfb40c994bdcd56", "filename": "gcc/ada/s-taprop-tru64.adb", "status": "modified", "additions": 168, "deletions": 18, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-tru64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-tru64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-tru64.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,6 +1,6 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n --                                                                          --\n@@ -58,11 +58,6 @@ with System.Interrupt_Management;\n --           Abort_Task_Interrupt\n --           Interrupt_ID\n \n-with System.Interrupt_Management.Operations;\n---  used for Set_Interrupt_Mask\n---           All_Tasks_Mask\n-pragma Elaborate_All (System.Interrupt_Management.Operations);\n-\n with System.Parameters;\n --  used for Size_Type\n \n@@ -972,13 +967,176 @@ package body System.Task_Primitives.Operations is\n    procedure Abort_Task (T : Task_Id) is\n       Result : Interfaces.C.int;\n    begin\n-      Result :=\n-        pthread_kill\n-          (T.Common.LL.Thread,\n-           Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n+      Result := pthread_kill (T.Common.LL.Thread,\n+        Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n       pragma Assert (Result = 0);\n    end Abort_Task;\n \n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (S : in out Suspension_Object) is\n+      Mutex_Attr : aliased pthread_mutexattr_t;\n+      Cond_Attr  : aliased pthread_condattr_t;\n+      Result     : Interfaces.C.int;\n+   begin\n+      --  Initialize internal state. It is always initialized to False (ARM\n+      --  D.10 par. 6).\n+\n+      S.State := False;\n+      S.Waiting := False;\n+\n+      --  Initialize internal mutex\n+\n+      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutex_init (S.L'Access, Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Initialize internal condition variable\n+\n+      Result := pthread_condattr_init (Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      Result := pthread_cond_init (S.CV'Access, Cond_Attr'Access);\n+\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         if Result = ENOMEM then\n+            raise Storage_Error;\n+         end if;\n+      end if;\n+   end Initialize;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (S : in out Suspension_Object) is\n+      Result  : Interfaces.C.int;\n+   begin\n+      --  Destroy internal mutex\n+\n+      Result := pthread_mutex_destroy (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Destroy internal condition variable\n+\n+      Result := pthread_cond_destroy (S.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Finalize;\n+\n+   -------------------\n+   -- Current_State --\n+   -------------------\n+\n+   function Current_State (S : Suspension_Object) return Boolean is\n+   begin\n+      --  We do not want to use lock on this read operation. State is marked\n+      --  as Atomic so that we ensure that the value retrieved is correct.\n+\n+      return S.State;\n+   end Current_State;\n+\n+   ---------------\n+   -- Set_False --\n+   ---------------\n+\n+   procedure Set_False (S : in out Suspension_Object) is\n+      Result  : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      S.State := False;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Set_False;\n+\n+   --------------\n+   -- Set_True --\n+   --------------\n+\n+   procedure Set_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  If there is already a task waiting on this suspension object then\n+      --  we resume it, leaving the state of the suspension object to False,\n+      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves\n+      --  the state to True.\n+\n+      if S.Waiting then\n+         S.Waiting := False;\n+         S.State := False;\n+\n+         Result := pthread_cond_signal (S.CV'Access);\n+         pragma Assert (Result = 0);\n+      else\n+         S.State := True;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Set_True;\n+\n+   ------------------------\n+   -- Suspend_Until_True --\n+   ------------------------\n+\n+   procedure Suspend_Until_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      if S.Waiting then\n+         --  Program_Error must be raised upon calling Suspend_Until_True\n+         --  if another task is already waiting on that suspension object\n+         --  (ARM D.10 par. 10).\n+\n+         Result := pthread_mutex_unlock (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Program_Error;\n+      else\n+         --  Suspend the task if the state is False. Otherwise, the task\n+         --  continues its execution, and the state of the suspension object\n+         --  is set to False (ARM D.10 par. 9).\n+\n+         if S.State then\n+            S.State := False;\n+         else\n+            S.Waiting := True;\n+            Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+         end if;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Suspend_Until_True;\n+\n    ----------------\n    -- Check_Exit --\n    ----------------\n@@ -1114,15 +1272,7 @@ package body System.Task_Primitives.Operations is\n begin\n    declare\n       Result : Interfaces.C.int;\n-\n    begin\n-      --  Mask Environment task for all signals. The original mask of the\n-      --  Environment task will be recovered by Interrupt_Server task\n-      --  during the elaboration of s-interr.adb.\n-\n-      System.Interrupt_Management.Operations.Set_Interrupt_Mask\n-        (System.Interrupt_Management.Operations.All_Tasks_Mask'Access);\n-\n       --  Prepare the set of signals that should unblocked in all tasks\n \n       Result := sigemptyset (Unblocked_Signal_Mask'Access);"}, {"sha": "3a8eb7236531e06bc5786b1e9ca8bf0c5413ff14", "filename": "gcc/ada/s-taprop-vms.adb", "status": "modified", "additions": 184, "deletions": 3, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vms.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -887,7 +887,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Exit_Task is\n    begin\n-      Specific.Set (null);\n+      null;\n    end Exit_Task;\n \n    ----------------\n@@ -903,6 +903,187 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Abort_Task;\n \n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (S : in out Suspension_Object) is\n+      Mutex_Attr : aliased pthread_mutexattr_t;\n+      Cond_Attr  : aliased pthread_condattr_t;\n+      Result     : Interfaces.C.int;\n+   begin\n+      --  Initialize internal state. It is always initialized to False (ARM\n+      --  D.10 par. 6).\n+\n+      S.State := False;\n+      S.Waiting := False;\n+\n+      --  Initialize internal mutex\n+\n+      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutex_init (S.L'Access, Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Initialize internal condition variable\n+\n+      Result := pthread_condattr_init (Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         if Result = ENOMEM then\n+            raise Storage_Error;\n+         end if;\n+      end if;\n+\n+      Result := pthread_cond_init (S.CV'Access, Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         if Result = ENOMEM then\n+            Result := pthread_condattr_destroy (Cond_Attr'Access);\n+            pragma Assert (Result = 0);\n+\n+            raise Storage_Error;\n+         end if;\n+      end if;\n+\n+      Result := pthread_condattr_destroy (Cond_Attr'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (S : in out Suspension_Object) is\n+      Result  : Interfaces.C.int;\n+   begin\n+      --  Destroy internal mutex\n+\n+      Result := pthread_mutex_destroy (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Destroy internal condition variable\n+\n+      Result := pthread_cond_destroy (S.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Finalize;\n+\n+   -------------------\n+   -- Current_State --\n+   -------------------\n+\n+   function Current_State (S : Suspension_Object) return Boolean is\n+   begin\n+      --  We do not want to use lock on this read operation. State is marked\n+      --  as Atomic so that we ensure that the value retrieved is correct.\n+\n+      return S.State;\n+   end Current_State;\n+\n+   ---------------\n+   -- Set_False --\n+   ---------------\n+\n+   procedure Set_False (S : in out Suspension_Object) is\n+      Result  : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      S.State := False;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Set_False;\n+\n+   --------------\n+   -- Set_True --\n+   --------------\n+\n+   procedure Set_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  If there is already a task waiting on this suspension object then\n+      --  we resume it, leaving the state of the suspension object to False,\n+      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves\n+      --  the state to True.\n+\n+      if S.Waiting then\n+         S.Waiting := False;\n+         S.State := False;\n+\n+         Result := pthread_cond_signal (S.CV'Access);\n+         pragma Assert (Result = 0);\n+      else\n+         S.State := True;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Set_True;\n+\n+   ------------------------\n+   -- Suspend_Until_True --\n+   ------------------------\n+\n+   procedure Suspend_Until_True (S : in out Suspension_Object) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (S.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      if S.Waiting then\n+         --  Program_Error must be raised upon calling Suspend_Until_True\n+         --  if another task is already waiting on that suspension object\n+         --  (ARM D.10 par. 10).\n+\n+         Result := pthread_mutex_unlock (S.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Program_Error;\n+      else\n+         --  Suspend the task if the state is False. Otherwise, the task\n+         --  continues its execution, and the state of the suspension object\n+         --  is set to False (ARM D.10 par. 9).\n+\n+         if S.State then\n+            S.State := False;\n+         else\n+            S.Waiting := True;\n+            Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n+         end if;\n+      end if;\n+\n+      Result := pthread_mutex_unlock (S.L'Access);\n+      pragma Assert (Result = 0);\n+   end Suspend_Until_True;\n+\n    ----------------\n    -- Check_Exit --\n    ----------------"}, {"sha": "c2b56956e632db6874f200f4526e32c597671604", "filename": "gcc/ada/s-taprop-vxworks.adb", "status": "modified", "additions": 143, "deletions": 2, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vxworks.adb?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,6 +1,6 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                 GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS              --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n --                                                                          --\n --     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n --                                                                          --\n@@ -1010,13 +1010,154 @@ package body System.Task_Primitives.Operations is\n \n    procedure Abort_Task (T : Task_Id) is\n       Result : int;\n-\n    begin\n       Result := kill (T.Common.LL.Thread,\n                       Signal (Interrupt_Management.Abort_Task_Signal));\n       pragma Assert (Result = 0);\n    end Abort_Task;\n \n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (S : in out Suspension_Object) is\n+   begin\n+      --  Initialize internal state. It is always initialized to False (ARM\n+      --  D.10 par. 6).\n+\n+      S.State := False;\n+      S.Waiting := False;\n+\n+      --  Initialize internal mutex\n+\n+      --  Use simpler binary semaphore instead of VxWorks\n+      --  mutual exclusion semaphore, because we don't need\n+      --  the fancier semantics and their overhead.\n+\n+      S.L := semBCreate (SEM_Q_FIFO, SEM_FULL);\n+\n+      --  Initialize internal condition variable\n+\n+      S.CV := semBCreate (SEM_Q_FIFO, SEM_EMPTY);\n+   end Initialize;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (S : in out Suspension_Object) is\n+      Result : STATUS;\n+   begin\n+      --  Destroy internal mutex\n+\n+      Result := semDelete (S.L);\n+      pragma Assert (Result = OK);\n+\n+      --  Destroy internal condition variable\n+\n+      Result := semDelete (S.CV);\n+      pragma Assert (Result = OK);\n+   end Finalize;\n+\n+   -------------------\n+   -- Current_State --\n+   -------------------\n+\n+   function Current_State (S : Suspension_Object) return Boolean is\n+   begin\n+      --  We do not want to use lock on this read operation. State is marked\n+      --  as Atomic so that we ensure that the value retrieved is correct.\n+\n+      return S.State;\n+   end Current_State;\n+\n+   ---------------\n+   -- Set_False --\n+   ---------------\n+\n+   procedure Set_False (S : in out Suspension_Object) is\n+      Result  : STATUS;\n+   begin\n+      Result := semTake (S.L, WAIT_FOREVER);\n+      pragma Assert (Result = OK);\n+\n+      S.State := False;\n+\n+      Result := semGive (S.L);\n+      pragma Assert (Result = OK);\n+   end Set_False;\n+\n+   --------------\n+   -- Set_True --\n+   --------------\n+\n+   procedure Set_True (S : in out Suspension_Object) is\n+      Result : STATUS;\n+   begin\n+      Result := semTake (S.L, WAIT_FOREVER);\n+      pragma Assert (Result = OK);\n+\n+      --  If there is already a task waiting on this suspension object then\n+      --  we resume it, leaving the state of the suspension object to False,\n+      --  as it is specified in ARM D.10 par. 9. Otherwise, it just leaves\n+      --  the state to True.\n+\n+      if S.Waiting then\n+         S.Waiting := False;\n+         S.State := False;\n+\n+         Result := semGive (S.CV);\n+         pragma Assert (Result = OK);\n+      else\n+         S.State := True;\n+      end if;\n+\n+      Result := semGive (S.L);\n+      pragma Assert (Result = OK);\n+   end Set_True;\n+\n+   ------------------------\n+   -- Suspend_Until_True --\n+   ------------------------\n+\n+   procedure Suspend_Until_True (S : in out Suspension_Object) is\n+      Result : STATUS;\n+   begin\n+      Result := semTake (S.L, WAIT_FOREVER);\n+\n+      if S.Waiting then\n+         --  Program_Error must be raised upon calling Suspend_Until_True\n+         --  if another task is already waiting on that suspension object\n+         --  (ARM D.10 par. 10).\n+\n+         Result := semGive (S.L);\n+         pragma Assert (Result = OK);\n+\n+         raise Program_Error;\n+      else\n+         --  Suspend the task if the state is False. Otherwise, the task\n+         --  continues its execution, and the state of the suspension object\n+         --  is set to False (ARM D.10 par. 9).\n+\n+         if S.State then\n+            S.State := False;\n+\n+            Result := semGive (S.L);\n+            pragma Assert (Result = 0);\n+         else\n+            S.Waiting := True;\n+\n+            --  Release the mutex before sleeping\n+\n+            Result := semGive (S.L);\n+            pragma Assert (Result = OK);\n+\n+            Result := semTake (S.CV, WAIT_FOREVER);\n+            pragma Assert (Result = 0);\n+         end if;\n+      end if;\n+   end Suspend_Until_True;\n+\n    ----------------\n    -- Check_Exit --\n    ----------------"}, {"sha": "79c55c024ded31410edf8a94df01de45d8d13f4a", "filename": "gcc/ada/s-taprop.ads", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taprop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop.ads?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -444,6 +444,38 @@ package System.Task_Primitives.Operations is\n    --  The call to Stack_Guard has no effect if guard pages are not used on\n    --  the target, or if guard pages are automatically provided by the system.\n \n+   ------------------------\n+   -- Suspension objects --\n+   ------------------------\n+\n+   --  These subprograms provide the functionality required for synchronizing\n+   --  on a suspension object. Tasks can suspend execution and relinquish the\n+   --  processors until the condition is signaled.\n+\n+   function Current_State (S : Suspension_Object) return Boolean;\n+   --  Return the state of the suspension object\n+\n+   procedure Set_False (S : in out Suspension_Object);\n+   --  Set the state of the suspension object to False\n+\n+   procedure Set_True (S : in out Suspension_Object);\n+   --  Set the state of the suspension object to True. If a task were\n+   --  suspended on the protected object then this task is released (and\n+   --  the state of the suspension object remains set to False).\n+\n+   procedure Suspend_Until_True (S : in out Suspension_Object);\n+   --  If the state of the suspension object is True then the calling task\n+   --  continues its execution, and the state is set to False. If the state\n+   --  of the object is False then the task is suspended on the suspension\n+   --  object until a Set_True operation is executed. Program_Error is raised\n+   --  if another task is already waiting on that suspension object.\n+\n+   procedure Initialize (S : in out Suspension_Object);\n+   --  Initialize the suspension object\n+\n+   procedure Finalize (S : in out Suspension_Object);\n+   --  Finalize the suspension object\n+\n    -----------------------------------------\n    -- Runtime System Debugging Interfaces --\n    -----------------------------------------"}, {"sha": "23a1aff640870624911e04a53d024eec3c4bf6d7", "filename": "gcc/ada/s-taspri-dummy.ads", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-dummy.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-dummy.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-dummy.ads?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --                 S Y S T E M . T A S K _ P R I M I T I V E S              --\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1991-2000 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1991-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,12 +44,14 @@ package System.Task_Primitives is\n \n    type RTS_Lock is new Integer;\n \n+   type Suspension_Object is new Integer;\n+\n    type Task_Body_Access is access procedure;\n \n    type Private_Data is record\n-      Thread      : aliased Integer;\n-      CV          : aliased Integer;\n-      L           : aliased RTS_Lock;\n+      Thread : aliased Integer;\n+      CV     : aliased Integer;\n+      L      : aliased RTS_Lock;\n    end record;\n \n end System.Task_Primitives;"}, {"sha": "9f34bfea134e899ae9951bc55a779e477c5d4781", "filename": "gcc/ada/s-taspri-hpux-dce.ads", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-hpux-dce.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-hpux-dce.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-hpux-dce.ads?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n --                                                                          --\n --                 S Y S T E M . T A S K _ P R I M I T I V E S              --\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1991-2000 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1991-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,9 +31,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is a HP-UX version of this package.\n+--  This is a HP-UX version of this package\n \n---  This package provides low-level support for most tasking features.\n+--  This package provides low-level support for most tasking features\n \n pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during\n@@ -47,22 +47,24 @@ with System.OS_Interface;\n package System.Task_Primitives is\n \n    type Lock is limited private;\n-   --  Should be used for implementation of protected objects.\n+   --  Should be used for implementation of protected objects\n \n    type RTS_Lock is limited private;\n-   --  Should be used inside the runtime system.\n-   --  The difference between Lock and the RTS_Lock is that the later\n-   --  one serves only as a semaphore so that do not check for\n-   --  ceiling violations.\n+   --  Should be used inside the runtime system. The difference between Lock\n+   --  and the RTS_Lock is that the later one serves only as a semaphore so\n+   --  that do not check for ceiling violations.\n+\n+   type Suspension_Object is limited private;\n+   --  Should be used for the implementation of Ada.Synchronous_Task_Control\n \n    type Task_Body_Access is access procedure;\n    --  Pointer to the task body's entry point (or possibly a wrapper\n    --  declared local to the GNARL).\n \n    type Private_Data is limited private;\n-   --  Any information that the GNULLI needs maintained on a per-task\n-   --  basis.  A component of this type is guaranteed to be included\n-   --  in the Ada_Task_Control_Block.\n+   --  Any information that the GNULLI needs maintained on a per-task basis.\n+   --  A component of this type is guaranteed to be included in the\n+   --  Ada_Task_Control_Block.\n \n private\n    type Lock is record\n@@ -72,18 +74,37 @@ private\n    end record;\n \n    type RTS_Lock is new System.OS_Interface.pthread_mutex_t;\n+\n+   type Suspension_Object is record\n+      State   : Boolean;\n+      pragma Atomic (State);\n+      --  Boolean that indicates whether the object is open. This field is\n+      --  marked Atomic to ensure that we can read its value without locking\n+      --  the access to the Suspension_Object.\n+\n+      Waiting : Boolean;\n+      --  Flag showing if there is a task already suspended on this object\n+\n+      L : aliased System.OS_Interface.pthread_mutex_t;\n+      --  Protection for ensuring mutual exclusion on the Suspension_Object\n+\n+      CV : aliased System.OS_Interface.pthread_cond_t;\n+      --  Condition variable used to queue threads until condition is signaled\n+   end record;\n+\n    type Private_Data is record\n-      Thread      : aliased System.OS_Interface.pthread_t;\n+      Thread : aliased System.OS_Interface.pthread_t;\n       pragma Atomic (Thread);\n       --  Thread field may be updated by two different threads of control.\n-      --  (See, Enter_Task and Create_Task in s-taprop.adb).\n-      --  They put the same value (thr_self value). We do not want to\n-      --  use lock on those operations and the only thing we have to\n-      --  make sure is that they are updated in atomic fashion.\n-\n-      CV          : aliased System.OS_Interface.pthread_cond_t;\n-      L           : aliased RTS_Lock;\n-      --  protection for all components is lock L\n+      --  (See, Enter_Task and Create_Task in s-taprop.adb). They put the\n+      --  same value (thr_self value). We do not want to use lock on those\n+      --  operations and the only thing we have to make sure is that they\n+      --  are updated in atomic fashion.\n+\n+      CV : aliased System.OS_Interface.pthread_cond_t;\n+\n+      L : aliased RTS_Lock;\n+      --  Protection for all components is lock L\n    end record;\n \n end System.Task_Primitives;"}, {"sha": "d91738a9990848bbbf2cc84a0b8450cedbf15529", "filename": "gcc/ada/s-taspri-linux.ads", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-linux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-linux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-linux.ads?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---           Copyright (C) 1991-2001 Free Software Foundation, Inc.         --\n+--           Copyright (C) 1991-2005 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,9 +31,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is the GNU/Linux (GNU/LinuxThreads) version of this package.\n+--  This is the GNU/Linux (GNU/LinuxThreads) version of this package\n \n---  This package provides low-level support for most tasking features.\n+--  This package provides low-level support for most tasking features\n \n pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during\n@@ -47,34 +47,55 @@ with System.OS_Interface;\n package System.Task_Primitives is\n \n    type Lock is limited private;\n-   --  Should be used for implementation of protected objects.\n+   --  Should be used for implementation of protected objects\n \n    type RTS_Lock is limited private;\n-   --  Should be used inside the runtime system.\n-   --  The difference between Lock and the RTS_Lock is that the later\n-   --  one serves only as a semaphore so that do not check for\n-   --  ceiling violations.\n+   --  Should be used inside the runtime system. The difference between Lock\n+   --  and the RTS_Lock is that the later one serves only as a semaphore so\n+   --  that do not check for ceiling violations.\n+\n+   type Suspension_Object is limited private;\n+   --  Should be used for the implementation of Ada.Synchronous_Task_Control\n \n    type Task_Body_Access is access procedure;\n    --  Pointer to the task body's entry point (or possibly a wrapper\n    --  declared local to the GNARL).\n \n    type Private_Data is limited private;\n-   --  Any information that the GNULLI needs maintained on a per-task\n-   --  basis.  A component of this type is guaranteed to be included\n-   --  in the Ada_Task_Control_Block.\n+   --  Any information that the GNULLI needs maintained on a per-task basis.\n+   --  A component of this type is guaranteed to be included in the\n+   --  Ada_Task_Control_Block.\n \n private\n \n    type Prio_Array_Type is array (System.Any_Priority) of Integer;\n \n    type Lock is record\n-      L          : aliased System.OS_Interface.pthread_mutex_t;\n-      Ceiling    : System.Any_Priority := System.Any_Priority'First;\n+      L              : aliased System.OS_Interface.pthread_mutex_t;\n+      Ceiling        : System.Any_Priority := System.Any_Priority'First;\n       Saved_Priority : System.Any_Priority := System.Any_Priority'First;\n    end record;\n \n    type RTS_Lock is new System.OS_Interface.pthread_mutex_t;\n+\n+   type Suspension_Object is record\n+      State : Boolean;\n+      pragma Atomic (State);\n+      --  Boolean that indicates whether the object is open. This field is\n+      --  marked Atomic to ensure that we can read its value without locking\n+      --  the access to the Suspension_Object.\n+\n+      Waiting : Boolean;\n+      --  Flag showing if there is a task already suspended on this object\n+\n+      L : aliased System.OS_Interface.pthread_mutex_t;\n+      --  Protection for ensuring mutual exclusion on the Suspension_Object\n+\n+      CV : aliased System.OS_Interface.pthread_cond_t;\n+      --  Condition variable used to queue threads until the condition is\n+      --  signaled.\n+   end record;\n+\n    type Private_Data is record\n       Thread      : aliased System.OS_Interface.pthread_t;\n       pragma Atomic (Thread);\n@@ -84,13 +105,14 @@ private\n       --  use lock on those operations and the only thing we have to\n       --  make sure is that they are updated in atomic fashion.\n \n-      CV          : aliased System.OS_Interface.pthread_cond_t;\n-      L           : aliased RTS_Lock;\n-      --  protection for all components is lock L\n+      CV : aliased System.OS_Interface.pthread_cond_t;\n+\n+      L : aliased RTS_Lock;\n+      --  Protection for all components is lock L\n \n       Active_Priority : System.Any_Priority := System.Any_Priority'First;\n-      --  Simulated active priority,\n-      --  used only if Priority_Ceiling_Support is True.\n+      --  Simulated active priority, used only if Priority_Ceiling_Support\n+      --  is True.\n    end record;\n \n end System.Task_Primitives;"}, {"sha": "ce8c0ca17d48123be5190454424d0a54b593d2bb", "filename": "gcc/ada/s-taspri-lynxos.ads", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-lynxos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-lynxos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-lynxos.ads?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,13 +1,13 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                 GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS              --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n --                                                                          --\n --                 S Y S T E M . T A S K _ P R I M I T I V E S              --\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2003, Ada Core Technologies               --\n+--                     Copyright (C) 1995-2005, AdaCore                     --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,8 +32,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is a LynxOS version of this package, derived from\n---  7staspri.ads\n+--  This is a LynxOS version of this package, derived from 7staspri.ads\n \n pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during\n@@ -47,22 +46,24 @@ with System.OS_Interface;\n package System.Task_Primitives is\n \n    type Lock is limited private;\n-   --  Should be used for implementation of protected objects.\n+   --  Should be used for implementation of protected objects\n \n    type RTS_Lock is limited private;\n-   --  Should be used inside the runtime system.\n-   --  The difference between Lock and the RTS_Lock is that the later\n-   --  one serves only as a semaphore so that do not check for\n-   --  ceiling violations.\n+   --  Should be used inside the runtime system. The difference between Lock\n+   --  and the RTS_Lock is that the later one serves only as a semaphore so\n+   --  that do not check for ceiling violations.\n+\n+   type Suspension_Object is limited private;\n+   --  Should be used for the implementation of Ada.Synchronous_Task_Control\n \n    type Task_Body_Access is access procedure;\n    --  Pointer to the task body's entry point (or possibly a wrapper\n    --  declared local to the GNARL).\n \n    type Private_Data is limited private;\n-   --  Any information that the GNULLI needs maintained on a per-task\n-   --  basis.  A component of this type is guaranteed to be included\n-   --  in the Ada_Task_Control_Block.\n+   --  Any information that the GNULLI needs maintained on a per-task basis.\n+   --  A component of this type is guaranteed to be included in the\n+   --  Ada_Task_Control_Block.\n \n private\n \n@@ -74,14 +75,31 @@ private\n \n    type RTS_Lock is new System.OS_Interface.pthread_mutex_t;\n \n+   type Suspension_Object is record\n+      State : Boolean;\n+      pragma Atomic (State);\n+      --  Boolean that indicates whether the object is open. This field is\n+      --  marked Atomic to ensure that we can read its value without locking\n+      --  the access to the Suspension_Object.\n+\n+      Waiting : Boolean;\n+      --  Flag showing if there is a task already suspended on this object\n+\n+      L : aliased System.OS_Interface.pthread_mutex_t;\n+      --  Protection for ensuring mutual exclusion on the Suspension_Object\n+\n+      CV : aliased System.OS_Interface.pthread_cond_t;\n+      --  Condition variable used to queue threads until condition is signaled\n+   end record;\n+\n    type Private_Data is record\n       Thread : aliased System.OS_Interface.pthread_t;\n       pragma Atomic (Thread);\n       --  Thread field may be updated by two different threads of control.\n-      --  (See, Enter_Task and Create_Task in s-taprop.adb).\n-      --  They put the same value (thr_self value). We do not want to\n-      --  use lock on those operations and the only thing we have to\n-      --  make sure is that they are updated in atomic fashion.\n+      --  (See, Enter_Task and Create_Task in s-taprop.adb). They put the\n+      --  same value (thr_self value). We do not want to use lock on those\n+      --  operations and the only thing we have to make sure is that they\n+      --  are updated in atomic fashion.\n \n       LWP : aliased System.Address;\n       --  The purpose of this field is to provide a better tasking support on\n@@ -90,7 +108,7 @@ private\n \n       CV : aliased System.OS_Interface.pthread_cond_t;\n \n-      L  : aliased RTS_Lock;\n+      L : aliased RTS_Lock;\n       --  Protection for all components is lock L\n    end record;\n "}, {"sha": "0e1707fc880676da0c3e8a497cf08f989a5267a2", "filename": "gcc/ada/s-taspri-mingw.ads", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-mingw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-mingw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-mingw.ads?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --                 S Y S T E M . T A S K _ P R I M I T I V E S              --\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1991-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1991-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is a NT (native) version of this package.\n+--  This is a NT (native) version of this package\n \n pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during\n@@ -45,22 +45,24 @@ with System.OS_Interface;\n package System.Task_Primitives is\n \n    type Lock is limited private;\n-   --  Should be used for implementation of protected objects.\n+   --  Should be used for implementation of protected objects\n \n    type RTS_Lock is limited private;\n-   --  Should be used inside the runtime system.\n-   --  The difference between Lock and the RTS_Lock is that the later\n-   --  one serves only as a semaphore so that do not check for\n-   --  ceiling violations.\n+   --  Should be used inside the runtime system. The difference between Lock\n+   --  and the RTS_Lock is that the later one serves only as a semaphore so\n+   --  that do not check for ceiling violations.\n+\n+   type Suspension_Object is limited private;\n+   --  Should be used for the implementation of Ada.Synchronous_Task_Control\n \n    type Task_Body_Access is access procedure;\n    --  Pointer to the task body's entry point (or possibly a wrapper\n    --  declared local to the GNARL).\n \n    type Private_Data is limited private;\n-   --  Any information that the GNULLI needs maintained on a per-task\n-   --  basis.  A component of this type is guaranteed to be included\n-   --  in the Ada_Task_Control_Block.\n+   --  Any information that the GNULLI needs maintained on a per-task basis.\n+   --  A component of this type is guaranteed to be included in the\n+   --  Ada_Task_Control_Block.\n \n private\n \n@@ -74,6 +76,23 @@ private\n \n    type RTS_Lock is new System.OS_Interface.CRITICAL_SECTION;\n \n+   type Suspension_Object is record\n+      State : Boolean;\n+      pragma Atomic (State);\n+      --  Boolean that indicates whether the object is open. This field is\n+      --  marked Atomic to ensure that we can read its value without locking\n+      --  the access to the Suspension_Object.\n+\n+      Waiting : Boolean;\n+      --  Flag showing if there is a task already suspended on this object\n+\n+      L : aliased System.OS_Interface.CRITICAL_SECTION;\n+      --  Protection for ensuring mutual exclusion on the Suspension_Object\n+\n+      CV : aliased System.OS_Interface.HANDLE;\n+      --  Condition variable used to queue threads until condition is signaled\n+   end record;\n+\n    type Private_Data is record\n       Thread : aliased System.OS_Interface.HANDLE;\n       pragma Atomic (Thread);\n@@ -84,8 +103,7 @@ private\n       --  make sure is that they are updated in atomic fashion.\n \n       Thread_Id : aliased System.OS_Interface.DWORD;\n-      --  The purpose of this field is to provide a better tasking support\n-      --  in gdb.\n+      --  Used to provide a better tasking support in gdb\n \n       CV : aliased Condition_Variable;\n       --  Condition Variable used to implement Sleep/Wakeup"}, {"sha": "e434ac5380232809f2b4297bcfd07e49f5c20da9", "filename": "gcc/ada/s-taspri-os2.ads", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-os2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-os2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-os2.ads?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,13 +1,13 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                 GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS              --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n --                                                                          --\n --                S Y S T E M . T A S K _ P R I M I T I V E S               --\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2003, Ada Core Technologies               --\n+--                     Copyright (C) 1995-2005, AdaCore                     --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,9 +32,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is an OS/2 version of this package.\n+--  This is an OS/2 version of this package\n \n---  This package provides low-level support for most tasking features.\n+--  This package provides low-level support for most tasking features\n \n pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during\n@@ -47,6 +47,8 @@ package System.Task_Primitives is\n \n    pragma Preelaborate;\n \n+   --  Why are these commented out ???\n+\n --   type Lock is limited private;\n    --  Should be used for implementation of protected objects.\n \n@@ -65,7 +67,7 @@ package System.Task_Primitives is\n    --  basis.  A component of this type is guaranteed to be included\n    --  in the Ada_Task_Control_Block.\n \n---  private\n+--  private (why commented out???)\n \n    type Lock is record\n       Mutex          : aliased Interfaces.OS2Lib.Synchronization.HMTX;\n@@ -76,32 +78,48 @@ package System.Task_Primitives is\n \n    type RTS_Lock is new Lock;\n \n+   type Suspension_Object is record\n+      State : Boolean;\n+      pragma Atomic (State);\n+      --  Boolean that indicates whether the object is open. This field is\n+      --  marked Atomic to ensure that we can read its value without locking\n+      --  the access to the Suspension_Object.\n+\n+      Waiting : Boolean;\n+      --  Flag showing if there is a task already suspended on this object\n+\n+      L : aliased Interfaces.OS2Lib.Synchronization.HMTX;\n+      --  Protection for ensuring mutual exclusion on the Suspension_Object\n+\n+      CV : aliased Interfaces.OS2Lib.Synchronization.HEV;\n+      --  Condition variable used to queue threads until condition is signaled\n+   end record;\n+\n    type Private_Data is record\n-      Thread          : aliased Interfaces.OS2Lib.Threads.TID;\n+      Thread : aliased Interfaces.OS2Lib.Threads.TID;\n       pragma Atomic (Thread);\n       --  Thread field may be updated by two different threads of control.\n-      --  (See, Enter_Task and Create_Task in s-taprop.adb).\n-      --  They put the same value (thr_self value). We do not want to\n-      --  use lock on those operations and the only thing we have to\n-      --  make sure is that they are updated in atomic fashion.\n+      --  (See, Enter_Task and Create_Task in s-taprop.adb). They put the same\n+      --  value (thr_self value). We do not want to use lock on those\n+      --  operations and the only thing we have to make sure is that they are\n+      --  updated in atomic fashion.\n \n       CV : aliased Interfaces.OS2Lib.Synchronization.HEV;\n \n       L  : aliased RTS_Lock;\n       --  Protection for all components is lock L\n \n       Current_Priority : Integer := -1;\n-      --  The Current_Priority is the actual priority of a thread.\n-      --  This field is needed because it is only possible to set a\n-      --  delta priority in OS/2. The only places where this field should\n-      --  be set are Set_Priority, Create_Task and Initialize (Environment).\n+      --  The Current_Priority is the actual priority of a thread. This field\n+      --  is needed because it is only possible to set delta priority in OS/2.\n+      --  The only places where this field should be set are Set_Priority,\n+      --  Create_Task and Initialize (Environment).\n \n       Wrapper : Interfaces.OS2Lib.Threads.PFNTHREAD;\n-      --  This is the original wrapper passed by Operations.Create_Task.\n-      --  When installing an exception handler in a thread, the thread\n-      --  starts executing the Exception_Wrapper which calls Wrapper\n-      --  when the handler has been installed. The handler is removed when\n-      --  wrapper returns.\n+      --  This is the original wrapper passed by Operations.Create_Task. When\n+      --  installing an exception handler in a thread, the thread starts\n+      --  executing the Exception_Wrapper which calls Wrapper when the handler\n+      --  has been installed. The handler is removed when wrapper returns.\n    end record;\n \n end System.Task_Primitives;"}, {"sha": "3e31f7e46cf99d18f6a96fc4773a653d6314a74a", "filename": "gcc/ada/s-taspri-posix.ads", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-posix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-posix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-posix.ads?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,13 +1,13 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                 GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS              --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n --                                                                          --\n --                 S Y S T E M . T A S K _ P R I M I T I V E S              --\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2003, Ada Core Technologies               --\n+--                     Copyright (C) 1995-2005, AdaCore                     --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,8 +32,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is a POSIX-like version of this package.\n---  Note: this file can only be used for POSIX compliant systems.\n+--  This is a POSIX-like version of this package\n+\n+--  Note: this file can only be used for POSIX compliant systems\n \n pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during\n@@ -47,45 +48,65 @@ with System.OS_Interface;\n package System.Task_Primitives is\n \n    type Lock is limited private;\n-   --  Should be used for implementation of protected objects.\n+   --  Should be used for implementation of protected objects\n \n    type RTS_Lock is limited private;\n-   --  Should be used inside the runtime system.\n-   --  The difference between Lock and the RTS_Lock is that the later\n-   --  one serves only as a semaphore so that do not check for\n-   --  ceiling violations.\n+   --  Should be used inside the runtime system. The difference between Lock\n+   --  and the RTS_Lock is that the later one serves only as a semaphore so\n+   --  that do not check for ceiling violations.\n+\n+   type Suspension_Object is limited private;\n+   --  Should be used for the implementation of Ada.Synchronous_Task_Control\n \n    type Task_Body_Access is access procedure;\n-   --  Pointer to the task body's entry point (or possibly a wrapper\n-   --  declared local to the GNARL).\n+   --  Pointer to the task body's entry point (or possibly a wrapper declared\n+   --  local to the GNARL).\n \n    type Private_Data is limited private;\n-   --  Any information that the GNULLI needs maintained on a per-task\n-   --  basis.  A component of this type is guaranteed to be included\n-   --  in the Ada_Task_Control_Block.\n+   --  Any information that the GNULLI needs maintained on a per-task basis.\n+   --  A component of this type is guaranteed to be included in the\n+   --  Ada_Task_Control_Block.\n \n private\n \n    type Lock is new System.OS_Interface.pthread_mutex_t;\n    type RTS_Lock is new System.OS_Interface.pthread_mutex_t;\n \n+   type Suspension_Object is record\n+      State : Boolean;\n+      pragma Atomic (State);\n+      --  Boolean that indicates whether the object is open. This field is\n+      --  marked Atomic to ensure that we can read its value without locking\n+      --  the access to the Suspension_Object.\n+\n+      Waiting : Boolean;\n+      --  Flag showing if there is a task already suspended on this object\n+\n+      L : aliased System.OS_Interface.pthread_mutex_t;\n+      --  Protection for ensuring mutual exclusion on the Suspension_Object\n+\n+      CV : aliased System.OS_Interface.pthread_cond_t;\n+      --  Condition variable used to queue threads until condition is signaled\n+   end record;\n+\n    type Private_Data is record\n       Thread : aliased System.OS_Interface.pthread_t;\n       pragma Atomic (Thread);\n       --  Thread field may be updated by two different threads of control.\n-      --  (See, Enter_Task and Create_Task in s-taprop.adb).\n-      --  They put the same value (thr_self value). We do not want to\n-      --  use lock on those operations and the only thing we have to\n-      --  make sure is that they are updated in atomic fashion.\n+      --  (See, Enter_Task and Create_Task in s-taprop.adb). They put the same\n+      --  value (thr_self value). We do not want to use lock on those\n+      --  operations and the only thing we have to make sure is that they are\n+      --  updated in atomic fashion.\n \n       LWP : aliased System.Address;\n       --  The purpose of this field is to provide a better tasking support on\n       --  gdb. The order of the two first fields (Thread and LWP) is important.\n       --  On targets where lwp is not relevant, this is equivalent to Thread.\n \n       CV : aliased System.OS_Interface.pthread_cond_t;\n+      --  Should be commented ??? (in all versions of taspri)\n \n-      L  : aliased RTS_Lock;\n+      L : aliased RTS_Lock;\n       --  Protection for all components is lock L\n    end record;\n "}, {"sha": "668cd837ca4d6843cf2ff0a7cc824a9bd328e9a8", "filename": "gcc/ada/s-taspri-solaris.ads", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-solaris.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-solaris.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-solaris.ads?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n --                                                                          --\n --                 S Y S T E M . T A S K _ P R I M I T I V E S              --\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,7 +33,7 @@\n \n --  This is a Solaris version of this package\n \n---  This package provides low-level support for most tasking features.\n+--  This package provides low-level support for most tasking features\n \n pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during\n@@ -55,26 +55,28 @@ package System.Task_Primitives is\n \n    type RTS_Lock is limited private;\n    type RTS_Lock_Ptr is access all RTS_Lock;\n-   --  Should be used inside the runtime system.\n-   --  The difference between Lock and the RTS_Lock is that the later\n-   --  one serves only as a semaphore so that do not check for\n-   --  ceiling violations.\n+   --  Should be used inside the runtime system. The difference between Lock\n+   --  and the RTS_Lock is that the later one serves only as a semaphore so\n+   --  that do not check for ceiling violations.\n \n    function To_Lock_Ptr is new Unchecked_Conversion (RTS_Lock_Ptr, Lock_Ptr);\n \n+   type Suspension_Object is limited private;\n+   --  Should be used for the implementation of Ada.Synchronous_Task_Control\n+\n    type Task_Body_Access is access procedure;\n    --  Pointer to the task body's entry point (or possibly a wrapper\n    --  declared local to the GNARL).\n \n    type Private_Data is limited private;\n-   --  Any information that the GNULLI needs maintained on a per-task\n-   --  basis.  A component of this type is guaranteed to be included\n-   --  in the Ada_Task_Control_Block.\n+   --  Any information that the GNULLI needs maintained on a per-task basis.\n+   --  A component of this type is guaranteed to be included in the\n+   --  Ada_Task_Control_Block.\n \n private\n \n    type Private_Task_Serial_Number is mod 2 ** 64;\n-   --  Used to give each task a unique serial number.\n+   --  Used to give each task a unique serial number\n \n    type Base_Lock is new System.OS_Interface.mutex_t;\n \n@@ -99,28 +101,44 @@ private\n \n    type RTS_Lock is new Lock;\n \n-   --  Note that task support on gdb relies on the fact that the first\n-   --  2 fields of Private_Data are Thread and LWP.\n+   type Suspension_Object is record\n+      State : Boolean;\n+      pragma Atomic (State);\n+      --  Boolean that indicates whether the object is open. This field is\n+      --  marked Atomic to ensure that we can read its value without locking\n+      --  the access to the Suspension_Object.\n+\n+      Waiting : Boolean;\n+      --  Flag showing if there is a task already suspended on this object\n+\n+      L : aliased System.OS_Interface.mutex_t;\n+      --  Protection for ensuring mutual exclusion on the Suspension_Object\n+\n+      CV : aliased System.OS_Interface.cond_t;\n+      --  Condition variable used to queue threads until condition is signaled\n+   end record;\n+\n+   --  Note that task support on gdb relies on the fact that the first two\n+   --  fields of Private_Data are Thread and LWP.\n \n    type Private_Data is record\n-      Thread      : aliased System.OS_Interface.thread_t;\n+      Thread : aliased System.OS_Interface.thread_t;\n       pragma Atomic (Thread);\n       --  Thread field may be updated by two different threads of control.\n-      --  (See, Enter_Task and Create_Task in s-taprop.adb).\n-      --  They put the same value (thr_self value). We do not want to\n-      --  use lock on those operations and the only thing we have to\n-      --  make sure is that they are updated in atomic fashion.\n+      --  (See, Enter_Task and Create_Task in s-taprop.adb). They put the same\n+      --  value (thr_self value). We do not want to use lock on those\n+      --  operations and the only thing we have to make sure is that they are\n+      --  updated in atomic fashion.\n \n       LWP : System.OS_Interface.lwpid_t;\n-      --  The LWP id of the thread. Set by self in Enter_Task.\n+      --  The LWP id of the thread. Set by self in Enter_Task\n \n       CV : aliased System.OS_Interface.cond_t;\n       L  : aliased RTS_Lock;\n       --  Protection for all components is lock L\n \n       Active_Priority : System.Any_Priority := System.Any_Priority'First;\n-      --  Simulated active priority,\n-      --  used only if Priority_Ceiling_Support is True.\n+      --  Simulated active priority, used iff Priority_Ceiling_Support is True\n \n       Locking : Lock_Ptr;\n       Locks   : Lock_Ptr;"}, {"sha": "e524d573fb80f5755f8cafd53903077fc106004c", "filename": "gcc/ada/s-taspri-tru64.ads", "status": "modified", "additions": 43, "deletions": 23, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-tru64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-tru64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-tru64.ads?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --                 S Y S T E M . T A S K _ P R I M I T I V E S              --\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1991-2000 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1991-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,9 +31,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is the DEC Unix 4.0 version of this package.\n+--  This is the DEC Unix 4.0 version of this package\n \n---  This package provides low-level support for most tasking features.\n+--  This package provides low-level support for most tasking features\n \n pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during\n@@ -51,43 +51,63 @@ with System.OS_Interface;\n package System.Task_Primitives is\n \n    type Lock is limited private;\n-   --  Should be used for implementation of protected objects.\n+   --  Should be used for implementation of protected objects\n \n    type RTS_Lock is limited private;\n-   --  Should be used inside the runtime system.\n-   --  The difference between Lock and the RTS_Lock is that the later\n-   --  one serves only as a semaphore so that do not check for\n-   --  ceiling violations.\n+   --  Should be used inside the runtime system. The difference between Lock\n+   --  and the RTS_Lock is that the later one serves only as a semaphore so\n+   --  that do not check for ceiling violations.\n+\n+   type Suspension_Object is limited private;\n+   --  Should be used for the implementation of Ada.Synchronous_Task_Control\n \n    type Task_Body_Access is access procedure;\n    --  Pointer to the task body's entry point (or possibly a wrapper\n    --  declared local to the GNARL).\n \n    type Private_Data is limited private;\n-   --  Any information that the GNULLI needs maintained on a per-task\n-   --  basis.  A component of this type is guaranteed to be included\n-   --  in the Ada_Task_Control_Block.\n+   --  Any information that the GNULLI needs maintained on a per-task basis.\n+   --  A component of this type is guaranteed to be included\n \n private\n \n    type Lock is record\n-      L          : aliased System.OS_Interface.pthread_mutex_t;\n-      Ceiling    : Interfaces.C.int;\n+      L       : aliased System.OS_Interface.pthread_mutex_t;\n+      Ceiling : Interfaces.C.int;\n    end record;\n \n    type RTS_Lock is new System.OS_Interface.pthread_mutex_t;\n+\n+   type Suspension_Object is record\n+      State : Boolean;\n+      pragma Atomic (State);\n+      --  Boolean that indicates whether the object is open. This field is\n+      --  marked Atomic to ensure that we can read its value without locking\n+      --  the access to the Suspension_Object.\n+\n+      Waiting : Boolean;\n+      --  Flag showing if there is a task already suspended on this object\n+\n+      L : aliased System.OS_Interface.pthread_mutex_t;\n+      --  Protection for ensuring mutual exclusion on the Suspension_Object\n+\n+      CV : aliased System.OS_Interface.pthread_cond_t;\n+      --  Condition variable used to queue threads until the is signaled\n+   end record;\n+\n    type Private_Data is record\n-      Thread      : aliased System.OS_Interface.pthread_t;\n+      Thread : aliased System.OS_Interface.pthread_t;\n       pragma Atomic (Thread);\n       --  Thread field may be updated by two different threads of control.\n-      --  (See, Enter_Task and Create_Task in s-taprop.adb).\n-      --  They put the same value (thr_self value). We do not want to\n-      --  use lock on those operations and the only thing we have to\n-      --  make sure is that they are updated in atomic fashion.\n-\n-      CV          : aliased System.OS_Interface.pthread_cond_t;\n-      L           : aliased RTS_Lock;\n-      --  protection for all components is lock L\n+      --  (See, Enter_Task and Create_Task in s-taprop.adb). They put the same\n+      --  value (thr_self value). We do not want to use lock on those\n+      --  operations and the only thing we have to make sure is that they are\n+      --  updated in atomic fashion.\n+\n+      CV : aliased System.OS_Interface.pthread_cond_t;\n+\n+      L : aliased RTS_Lock;\n+      --  Protection for all components is lock L\n    end record;\n \n end System.Task_Primitives;"}, {"sha": "35c22dce793842bf2b34fa36cb137b2440e2e450", "filename": "gcc/ada/s-taspri-vms.ads", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-vms.ads?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n --                                                                          --\n --                 S Y S T E M . T A S K _ P R I M I T I V E S              --\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1991-2000 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1991-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,9 +31,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is a OpenVMS/Alpha version of this package.\n+--  This is a OpenVMS/Alpha version of this package\n \n---  This package provides low-level support for most tasking features.\n+--  This package provides low-level support for most tasking features\n \n pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during\n@@ -51,22 +51,24 @@ with System.OS_Interface;\n package System.Task_Primitives is\n \n    type Lock is limited private;\n-   --  Should be used for implementation of protected objects.\n+   --  Should be used for implementation of protected objects\n \n    type RTS_Lock is limited private;\n-   --  Should be used inside the runtime system.\n-   --  The difference between Lock and the RTS_Lock is that the later\n-   --  one serves only as a semaphore so that do not check for\n-   --  ceiling violations.\n+   --  Should be used inside the runtime system. The difference between Lock\n+   --  and the RTS_Lock is that the later one serves only as a semaphore so\n+   --  that do not check for ceiling violations.\n+\n+   type Suspension_Object is limited private;\n+   --  Should be used for the implementation of Ada.Synchronous_Task_Control\n \n    type Task_Body_Access is access procedure;\n    --  Pointer to the task body's entry point (or possibly a wrapper\n    --  declared local to the GNARL).\n \n    type Private_Data is limited private;\n-   --  Any information that the GNULLI needs maintained on a per-task\n-   --  basis.  A component of this type is guaranteed to be included\n-   --  in the Ada_Task_Control_Block.\n+   --  Any information that the GNULLI needs maintained on a per-task basis.\n+   --  A component of this type is guaranteed to be included in the\n+   --  Ada_Task_Control_Block.\n \n private\n \n@@ -81,21 +83,40 @@ private\n    end record;\n \n    type RTS_Lock is new System.OS_Interface.pthread_mutex_t;\n+\n+   type Suspension_Object is record\n+      State   : Boolean;\n+      pragma Atomic (State);\n+      --  Boolean that indicates whether the object is open. This field is\n+      --  marked Atomic to ensure that we can read its value without locking\n+      --  the access to the Suspension_Object.\n+\n+      Waiting : Boolean;\n+      --  Flag showing if there is a task already suspended on this object\n+\n+      L : aliased System.OS_Interface.pthread_mutex_t;\n+      --  Protection for ensuring mutual exclusion on the Suspension_Object\n+\n+      CV : aliased System.OS_Interface.pthread_cond_t;\n+      --  Condition variable used to queue threads until ondition is signaled\n+   end record;\n+\n    type Private_Data is record\n-      Thread      : aliased System.OS_Interface.pthread_t;\n+      Thread : aliased System.OS_Interface.pthread_t;\n       pragma Atomic (Thread);\n       --  Thread field may be updated by two different threads of control.\n-      --  (See, Enter_Task and Create_Task in s-taprop.adb).\n-      --  They put the same value (thr_self value). We do not want to\n-      --  use lock on those operations and the only thing we have to\n-      --  make sure is that they are updated in atomic fashion.\n+      --  (See, Enter_Task and Create_Task in s-taprop.adb). They put the\n+      --  same value (thr_self value). We do not want to use lock on those\n+      --  operations and the only thing we have to make sure is that they\n+      --  are updated in atomic fashion.\n+\n+      CV : aliased System.OS_Interface.pthread_cond_t;\n \n-      CV          : aliased System.OS_Interface.pthread_cond_t;\n-      L           : aliased RTS_Lock;\n-      --  protection for all components is lock L\n+      L : aliased RTS_Lock;\n+      --  Protection for all components is lock L\n \n       Exc_Stack_Ptr : Exc_Stack_Ptr_T;\n-      --  ??? This needs comments.\n+      --  ??? This needs comments\n \n       AST_Pending : Boolean;\n       --  Used to detect delay and sleep timeouts"}, {"sha": "2f3be4cdc2fde846e8f112e241fb9e1f328a25d0", "filename": "gcc/ada/s-taspri-vxworks.ads", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-vxworks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b497b46043b4679353aecf4be76266686813bdf3/gcc%2Fada%2Fs-taspri-vxworks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-vxworks.ads?ref=b497b46043b4679353aecf4be76266686813bdf3", "patch": "@@ -1,12 +1,12 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                 GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS              --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n --                                                                          --\n --                 S Y S T E M . T A S K _ P R I M I T I V E S              --\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 2001-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is a VxWorks version of this package.\n+--  This is a VxWorks version of this package\n \n pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during\n@@ -42,36 +42,56 @@ with System.OS_Interface;\n package System.Task_Primitives is\n \n    type Lock is limited private;\n-   --  Should be used for implementation of protected objects.\n+   --  Should be used for implementation of protected objects\n \n    type RTS_Lock is limited private;\n-   --  Should be used inside the runtime system.\n-   --  The difference between Lock and the RTS_Lock is that the later\n-   --  one serves only as a semaphore so that do not check for\n-   --  ceiling violations.\n+   --  Should be used inside the runtime system. The difference between Lock\n+   --  and the RTS_Lock is that the later one serves only as a semaphore so\n+   --  that do not check for ceiling violations.\n+\n+   type Suspension_Object is limited private;\n+   --  Should be used for the implementation of Ada.Synchronous_Task_Control\n \n    type Task_Body_Access is access procedure;\n    --  Pointer to the task body's entry point (or possibly a wrapper\n    --  declared local to the GNARL).\n \n    type Private_Data is limited private;\n-   --  Any information that the GNULLI needs maintained on a per-task\n-   --  basis.  A component of this type is guaranteed to be included\n-   --  in the Ada_Task_Control_Block.\n+   --  Any information that the GNULLI needs maintained on a per-task basis.\n+   --  A component of this type is guaranteed to be included in the\n+   --  Ada_Task_Control_Block.\n \n private\n \n    type Priority_Type is (Prio_None, Prio_Protect, Prio_Inherit);\n \n    type Lock is record\n-      Mutex        : System.OS_Interface.SEM_ID;\n-      Protocol     : Priority_Type;\n+      Mutex    : System.OS_Interface.SEM_ID;\n+      Protocol : Priority_Type;\n+\n       Prio_Ceiling : System.OS_Interface.int;\n-      --  priority ceiling of lock\n+      --  Priority ceiling of lock\n    end record;\n \n    type RTS_Lock is new Lock;\n \n+   type Suspension_Object is record\n+      State : Boolean;\n+      pragma Atomic (State);\n+      --  Boolean that indicates whether the object is open. This field is\n+      --  marked Atomic to ensure that we can read its value without locking\n+      --  the access to the Suspension_Object.\n+\n+      Waiting : Boolean;\n+      --  Flag showing if there is a task already suspended on this object\n+\n+      L : aliased System.OS_Interface.SEM_ID;\n+      --  Protection for ensuring mutual exclusion on the Suspension_Object\n+\n+      CV : aliased System.OS_Interface.SEM_ID;\n+      --  Condition variable used to queue threads until condition is signaled\n+   end record;\n+\n    type Private_Data is record\n       Thread : aliased System.OS_Interface.t_id := 0;\n       pragma Atomic (Thread);"}]}