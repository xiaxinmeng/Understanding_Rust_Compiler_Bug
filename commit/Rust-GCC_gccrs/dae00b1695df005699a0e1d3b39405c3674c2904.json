{"sha": "dae00b1695df005699a0e1d3b39405c3674c2904", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFlMDBiMTY5NWRmMDA1Njk5YTBlMWQzYjM5NDA1YzM2NzRjMjkwNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-10-05T17:40:58Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-10-05T17:40:58Z"}, "message": "i386: Rewrite ix86_expand_vshuffle.\n\n1: Handle TARGET_XOP.\n2: Reduce code duplication.\n3: Use ASHIFT instead of MULT for scaling.\n4: Fix errors in building convert-to-v16qi indicies.\n5: Handle v2di without sse4.1.\n\nFrom-SVN: r179564", "tree": {"sha": "e1eb0e9755eb3b0161ca7eb4e0820ad2d8f8517e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1eb0e9755eb3b0161ca7eb4e0820ad2d8f8517e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dae00b1695df005699a0e1d3b39405c3674c2904", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dae00b1695df005699a0e1d3b39405c3674c2904", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dae00b1695df005699a0e1d3b39405c3674c2904", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dae00b1695df005699a0e1d3b39405c3674c2904/comments", "author": null, "committer": null, "parents": [{"sha": "067f5960bdc9843445a97346566b0211a190d927", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/067f5960bdc9843445a97346566b0211a190d927", "html_url": "https://github.com/Rust-GCC/gccrs/commit/067f5960bdc9843445a97346566b0211a190d927"}], "stats": {"total": 220, "additions": 109, "deletions": 111}, "files": [{"sha": "800d69aab78e3911b73fbffe8ec69296f8515839", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae00b1695df005699a0e1d3b39405c3674c2904/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae00b1695df005699a0e1d3b39405c3674c2904/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dae00b1695df005699a0e1d3b39405c3674c2904", "patch": "@@ -6,6 +6,12 @@\n \tcode duplication.  Do update_stmt here ...\n \t(expand_vector_operations_1): ... not here.\n \n+\t* config/i386/i386.c (ix86_expand_vshuffle): Never fail.  Handle\n+\tTARGET_XOP.  Fix pshufb constant vector creation.  Reduce code\n+\tduplication.  Handle V2DI without SSE4.1.\n+\t* config/i386/i386-protos.h (ix86_expand_vshuffle): Update decl.\n+\t* config/i386/i386.md (vshuffle<V_128>): Remove assert for ok.\n+\n 2011-10-05  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (distance_non_agu_define): Simplify calculation"}, {"sha": "0bbfa9b735afb8554ab57d3a3e9b54579e28e501", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae00b1695df005699a0e1d3b39405c3674c2904/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae00b1695df005699a0e1d3b39405c3674c2904/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=dae00b1695df005699a0e1d3b39405c3674c2904", "patch": "@@ -123,7 +123,7 @@ extern bool ix86_expand_int_movcc (rtx[]);\n extern bool ix86_expand_fp_movcc (rtx[]);\n extern bool ix86_expand_fp_vcond (rtx[]);\n extern bool ix86_expand_int_vcond (rtx[]);\n-extern bool ix86_expand_vshuffle (rtx[]);\n+extern void ix86_expand_vshuffle (rtx[]);\n extern void ix86_expand_sse_unpack (rtx[], bool, bool);\n extern bool ix86_expand_int_addcc (rtx[]);\n extern rtx ix86_expand_call (rtx, rtx, rtx, rtx, rtx, bool);"}, {"sha": "faad3a53b8852eaf3ef7ac57a9e50bf6328ecfcb", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 101, "deletions": 107, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae00b1695df005699a0e1d3b39405c3674c2904/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae00b1695df005699a0e1d3b39405c3674c2904/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=dae00b1695df005699a0e1d3b39405c3674c2904", "patch": "@@ -19237,145 +19237,139 @@ ix86_expand_int_vcond (rtx operands[])\n   return true;\n }\n \n-bool\n+void\n ix86_expand_vshuffle (rtx operands[])\n {\n   rtx target = operands[0];\n   rtx op0 = operands[1];\n   rtx op1 = operands[2];\n   rtx mask = operands[3];\n-  rtx new_mask, vt, t1, t2, w_vector;\n+  rtx vt, vec[16];\n   enum machine_mode mode = GET_MODE (op0);\n   enum machine_mode maskmode = GET_MODE (mask);\n-  enum machine_mode maskinner = GET_MODE_INNER (mode);\n-  rtx vec[16];\n-  int w, i, j;\n-  bool one_operand_shuffle = op0 == op1;\n+  int w, e, i;\n+  bool one_operand_shuffle = rtx_equal_p (op0, op1);\n \n-  gcc_assert ((TARGET_SSSE3 || TARGET_AVX) && GET_MODE_BITSIZE (mode) == 128);\n+  gcc_checking_assert (GET_MODE_BITSIZE (mode) == 128);\n \n   /* Number of elements in the vector.  */\n-  w = GET_MODE_BITSIZE (maskmode) / GET_MODE_BITSIZE (maskinner);\n-\n-  /* generate w_vector = {w, w, ...}  */\n-  for (i = 0; i < w; i++)\n-    vec[i] = GEN_INT (w);\n-  w_vector = gen_rtx_CONST_VECTOR (maskmode, gen_rtvec_v (w, vec));\n-\n-  /* mask = mask & {w-1, w-1, w-1,...} */\n-  for (i = 0; i < w; i++)\n-    vec[i] = GEN_INT (w - 1);\n+  w = GET_MODE_NUNITS (mode);\n+  e = GET_MODE_UNIT_SIZE (mode);\n \n-  vt = gen_rtx_CONST_VECTOR (maskmode, gen_rtvec_v (w, vec));\n-  new_mask = expand_simple_binop (maskmode, AND, mask, vt,\n-\t\t\t\t  NULL_RTX, 0, OPTAB_DIRECT);\n-\n-  /* If the original vector mode is V16QImode, we can just\n-     use pshufb directly.  */\n-  if (mode == V16QImode && one_operand_shuffle)\n+  if (TARGET_XOP)\n     {\n-      t1 = gen_reg_rtx (V16QImode);\n-      emit_insn (gen_ssse3_pshufbv16qi3 (t1, op0, new_mask));\n-      emit_insn (gen_rtx_SET (VOIDmode, target, t1));\n-      return true;\n+      /* The XOP VPPERM insn supports three inputs.  By ignoring the \n+\t one_operand_shuffle special case, we avoid creating another\n+\t set of constant vectors in memory.  */\n+      one_operand_shuffle = false;\n+\n+      /* mask = mask & {2*w-1, ...} */\n+      vt = GEN_INT (2*w - 1);\n     }\n-  else if (mode == V16QImode)\n+  else\n     {\n-      rtx xops[6];\n-\n-      t1 = gen_reg_rtx (V16QImode);\n-      t2 = gen_reg_rtx (V16QImode);\n-      emit_insn (gen_ssse3_pshufbv16qi3 (t1, op0, new_mask));\n-      emit_insn (gen_ssse3_pshufbv16qi3 (t2, op1, new_mask));\n-\n-      /* mask = mask & {w, w, ...}  */\n-      mask = expand_simple_binop (V16QImode, AND, mask, w_vector,\n-\t\t\t\t  NULL_RTX, 0, OPTAB_DIRECT);\n-      xops[0] = target;\n-      xops[1] = operands[1];\n-      xops[2] = operands[2];\n-      xops[3] = gen_rtx_EQ (mode, mask, w_vector);\n-      xops[4] = t1;\n-      xops[5] = t2;\n-\n-      return ix86_expand_int_vcond (xops);\n+      /* mask = mask & {w-1, ...} */\n+      vt = GEN_INT (w - 1);\n     }\n \n-  /* mask = mask * {w, w, ...}  */\n-  new_mask = expand_simple_binop (maskmode, MULT, new_mask, w_vector,\n-\t\t\t\t  NULL_RTX, 0, OPTAB_DIRECT);\n-\n-  /* Convert mask to vector of chars.  */\n-  new_mask = simplify_gen_subreg (V16QImode, new_mask, maskmode, 0);\n-  new_mask = force_reg (V16QImode, new_mask);\n-\n-  /* Build a helper mask wich we will use in pshufb\n-     (v4si) --> {0,0,0,0, 4,4,4,4, 8,8,8,8, 12,12,12,12}\n-     (v8hi) --> {0,0, 2,2, 4,4, 6,6, ...}\n-     ...  */\n-  for (i = 0; i < w; i++)\n-    for (j = 0; j < 16/w; j++)\n-      vec[i*w+j] = GEN_INT (i*16/w);\n-  vt = gen_rtx_CONST_VECTOR (V16QImode, gen_rtvec_v (16, vec));\n-  vt = force_reg (V16QImode, vt);\n-\n-  t1 = gen_reg_rtx (V16QImode);\n-  emit_insn (gen_ssse3_pshufbv16qi3 (t1, new_mask, vt));\n-  new_mask = t1;\n-\n-  /* Convert it into the byte positions by doing\n-     new_mask = new_mask + {0,1,..,16/w, 0,1,..,16/w, ...}  */\n   for (i = 0; i < w; i++)\n-    for (j = 0; j < 16/w; j++)\n-      vec[i*w+j] = GEN_INT (j);\n+    vec[i] = vt;\n+  vt = gen_rtx_CONST_VECTOR (maskmode, gen_rtvec_v (w, vec));\n+  mask = expand_simple_binop (maskmode, AND, mask, vt,\n+\t\t\t      NULL_RTX, 0, OPTAB_DIRECT);\n \n-  vt = gen_rtx_CONST_VECTOR (V16QImode, gen_rtvec_v (16, vec));\n-  new_mask = expand_simple_binop (V16QImode, PLUS, new_mask, vt,\n+  /* For non-QImode operations, convert the word permutation control\n+     into a byte permutation control.  */\n+  if (mode != V16QImode)\n+    {\n+      mask = expand_simple_binop (maskmode, ASHIFT, mask,\n+\t\t\t\t  GEN_INT (exact_log2 (e)),\n \t\t\t\t  NULL_RTX, 0, OPTAB_DIRECT);\n \n-  t1 = gen_reg_rtx (V16QImode);\n+      /* Convert mask to vector of chars.  */\n+      mask = force_reg (V16QImode, gen_lowpart (V16QImode, mask));\n+\n+      /* Replicate each of the input bytes into byte positions:\n+\t (v2di) --> {0,0,0,0,0,0,0,0, 8,8,8,8,8,8,8,8}\n+\t (v4si) --> {0,0,0,0, 4,4,4,4, 8,8,8,8, 12,12,12,12}\n+\t (v8hi) --> {0,0, 2,2, 4,4, 6,6, ...}.  */\n+      for (i = 0; i < 16; ++i)\n+\tvec[i] = GEN_INT (i/e * e);\n+      vt = gen_rtx_CONST_VECTOR (V16QImode, gen_rtvec_v (16, vec));\n+      vt = force_const_mem (V16QImode, vt);\n+      if (TARGET_XOP)\n+\temit_insn (gen_xop_pperm (mask, mask, mask, vt));\n+      else\n+\temit_insn (gen_ssse3_pshufbv16qi3 (mask, mask, vt));\n \n-  /* Convert OP0 to vector of chars.  */\n-  op0 = simplify_gen_subreg (V16QImode, op0, mode, 0);\n-  op0 = force_reg (V16QImode, op0);\n-  emit_insn (gen_ssse3_pshufbv16qi3 (t1, op0, new_mask));\n+      /* Convert it into the byte positions by doing\n+\t mask = mask + {0,1,..,16/w, 0,1,..,16/w, ...}  */\n+      for (i = 0; i < 16; ++i)\n+\tvec[i] = GEN_INT (i % e);\n+      vt = gen_rtx_CONST_VECTOR (V16QImode, gen_rtvec_v (16, vec));\n+      vt = force_const_mem (V16QImode, vt);\n+      emit_insn (gen_addv16qi3 (mask, mask, vt));\n+    }\n \n-  if (one_operand_shuffle)\n+  /* The actual shuffle operations all operate on V16QImode.  */\n+  op0 = gen_lowpart (V16QImode, op0);\n+  op1 = gen_lowpart (V16QImode, op1);\n+  target = gen_lowpart (V16QImode, target);\n+\n+  if (TARGET_XOP)\n     {\n-      /* Convert it back from vector of chars to the original mode.  */\n-      t1 = simplify_gen_subreg (mode, t1, V16QImode, 0);\n-      emit_insn (gen_rtx_SET (VOIDmode, target, t1));\n-      return true;\n+      emit_insn (gen_xop_pperm (target, op0, op1, mask));\n+    }\n+  else if (one_operand_shuffle)\n+    {\n+      emit_insn (gen_ssse3_pshufbv16qi3 (target, op0, mask));\n     }\n   else\n     {\n-      rtx xops[6];\n+      rtx xops[6], t1, t2;\n+      bool ok;\n \n+      /* Shuffle the two input vectors independently.  */\n+      t1 = gen_reg_rtx (V16QImode);\n       t2 = gen_reg_rtx (V16QImode);\n-\n-      /* Convert OP1 to vector of chars.  */\n-      op1 = simplify_gen_subreg (V16QImode, op1, mode, 0);\n-      op1 = force_reg (V16QImode, op1);\n-      emit_insn (gen_ssse3_pshufbv16qi3 (t1, op1, new_mask));\n-\n-      /* mask = mask & {w, w, ...}  */\n-      mask = expand_simple_binop (V16QImode, AND, mask, w_vector,\n+      emit_insn (gen_ssse3_pshufbv16qi3 (t1, op0, mask));\n+      emit_insn (gen_ssse3_pshufbv16qi3 (t2, op1, mask));\n+\n+      /* Then merge them together.  The key is whether any given control\n+         element contained a bit set that indicates the second word.  */\n+      mask = operands[3];\n+      vt = GEN_INT (w);\n+      if (maskmode == V2DImode && !TARGET_SSE4_1)\n+\t{\n+\t  /* Without SSE4.1, we don't have V2DImode EQ.  Perform one\n+\t     more shuffle to convert the V2DI input mask into a V4SI\n+\t     input mask.  At which point the masking that expand_int_vcond\n+\t     will work as desired.  */\n+\t  rtx t3 = gen_reg_rtx (V4SImode);\n+\t  emit_insn (gen_sse2_pshufd_1 (t3, gen_lowpart (V4SImode, mask),\n+\t\t\t\t        const0_rtx, const0_rtx,\n+\t\t\t\t        const2_rtx, const2_rtx));\n+\t  mask = t3;\n+\t  maskmode = V4SImode;\n+\t  e = w = 4;\n+\t}\n+\n+      for (i = 0; i < w; i++)\n+\tvec[i] = vt;\n+      vt = gen_rtx_CONST_VECTOR (maskmode, gen_rtvec_v (w, vec));\n+      vt = force_reg (maskmode, vt);\n+      mask = expand_simple_binop (maskmode, AND, mask, vt,\n \t\t\t\t  NULL_RTX, 0, OPTAB_DIRECT);\n \n-      t1 = simplify_gen_subreg (mode, t1, V16QImode, 0);\n-      t2 = simplify_gen_subreg (mode, t2, V16QImode, 0);\n-\n-      xops[0] = target;\n-      xops[1] = operands[1];\n-      xops[2] = operands[2];\n-      xops[3] = gen_rtx_EQ (mode, mask, w_vector);\n-      xops[4] = t1;\n-      xops[5] = t2;\n-\n-      return ix86_expand_int_vcond (xops);\n+      xops[0] = gen_lowpart (maskmode, operands[0]);\n+      xops[1] = gen_lowpart (maskmode, t2);\n+      xops[2] = gen_lowpart (maskmode, t1);\n+      xops[3] = gen_rtx_EQ (maskmode, mask, vt);\n+      xops[4] = mask;\n+      xops[5] = vt;\n+      ok = ix86_expand_int_vcond (xops);\n+      gcc_assert (ok);\n     }\n-\n-  return false;\n }\n \n /* Unpack OP[1] into the next wider integer vector type.  UNSIGNED_P is"}, {"sha": "ee9cf0b42181dcfbed8fc4c4c661ad441abe2762", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dae00b1695df005699a0e1d3b39405c3674c2904/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dae00b1695df005699a0e1d3b39405c3674c2904/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=dae00b1695df005699a0e1d3b39405c3674c2904", "patch": "@@ -6229,12 +6229,10 @@\n    (match_operand:<sseshuffint> 3 \"register_operand\" \"\")]\n   \"TARGET_SSSE3 || TARGET_AVX\"\n {\n-  bool ok = ix86_expand_vshuffle (operands);\n-  gcc_assert (ok);\n+  ix86_expand_vshuffle (operands);\n   DONE;\n })\n \n-\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Parallel bitwise logical operations"}]}