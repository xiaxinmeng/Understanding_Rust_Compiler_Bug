{"sha": "8f0f2a1dfd96bc496c50a264d2482daa254490aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGYwZjJhMWRmZDk2YmM0OTZjNTBhMjY0ZDI0ODJkYWEyNTQ0OTBhYQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2008-10-27T16:50:23Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-10-27T16:50:23Z"}, "message": "re PR libstdc++/37919 ([c++0x] GCC 4.4 regression r141214 of gcc c++0x stl_pair.c causes a boost 1.36 compilation to fail)\n\n2008-10-27  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR libstdc++/37919\n\tRevert:\n\t2008-10-18  Douglas Gregor  <doug.gregor@gmail.com>\n\n\t* include/bits/stl_pair.h (__may_be_null_pointer_init): New.\n\t(pair::pair): Eliminate the redundant pair(U1&&, U2&&) constructor.\n\tAdd lvalue pair<U1, U2> constructor to handle non-const pair lvalues.\n\tRemove the old variadic constructor, and instead provide several\n\tvariadic constructors that avoid failing when attempting to\n\tinitialize a pointer from a null pointer constant.\n\t* testsuite/20_util/pair/moveable.cc (test3): Add new tests with\n\tinitialization of pointers from the null pointer constant.\n\nFrom-SVN: r141388", "tree": {"sha": "480aa8d3ec7622f0b85b44490fe14c83e8190ec3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/480aa8d3ec7622f0b85b44490fe14c83e8190ec3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f0f2a1dfd96bc496c50a264d2482daa254490aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f0f2a1dfd96bc496c50a264d2482daa254490aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f0f2a1dfd96bc496c50a264d2482daa254490aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f0f2a1dfd96bc496c50a264d2482daa254490aa/comments", "author": null, "committer": null, "parents": [{"sha": "202e781535186eb19b4d1bb2e737f2088d5c9141", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/202e781535186eb19b4d1bb2e737f2088d5c9141", "html_url": "https://github.com/Rust-GCC/gccrs/commit/202e781535186eb19b4d1bb2e737f2088d5c9141"}], "stats": {"total": 151, "additions": 24, "deletions": 127}, "files": [{"sha": "4230bc6a12982ef9aaf455422272e47e1db4ecb3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0f2a1dfd96bc496c50a264d2482daa254490aa/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0f2a1dfd96bc496c50a264d2482daa254490aa/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=8f0f2a1dfd96bc496c50a264d2482daa254490aa", "patch": "@@ -1,3 +1,18 @@\n+2008-10-27  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR libstdc++/37919\n+\tRevert:\n+\t2008-10-18  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+\t* include/bits/stl_pair.h (__may_be_null_pointer_init): New.\n+\t(pair::pair): Eliminate the redundant pair(U1&&, U2&&) constructor.\n+\tAdd lvalue pair<U1, U2> constructor to handle non-const pair lvalues.\n+\tRemove the old variadic constructor, and instead provide several\n+\tvariadic constructors that avoid failing when attempting to\n+\tinitialize a pointer from a null pointer constant.\n+\t* testsuite/20_util/pair/moveable.cc (test3): Add new tests with\n+\tinitialization of pointers from the null pointer constant.\n+\n 2008-10-27  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR libstdc++/37522"}, {"sha": "cf61b09945a0bbd8d548cb785e7fa4cb8569d851", "filename": "libstdc++-v3/include/bits/stl_pair.h", "status": "modified", "additions": 9, "deletions": 82, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0f2a1dfd96bc496c50a264d2482daa254490aa/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0f2a1dfd96bc496c50a264d2482daa254490aa/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h?ref=8f0f2a1dfd96bc496c50a264d2482daa254490aa", "patch": "@@ -65,35 +65,8 @@\n #include <bits/move.h> // for std::move / std::forward, std::decay, and\n                        // std::swap\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-#include <type_traits>\n-#endif\n-\n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-// A trait that determines whether the initialization of a T from\n-// arguments of type Args could possibly be the initialization of a\n-// pointer from a null pointer constant.\n-template<typename, typename...>\n-struct __may_be_null_pointer_init \n-  : public false_type { };\n-\n-template<typename _Tp, typename _Up>\n-struct __may_be_null_pointer_init<_Tp*, _Up>  \n-  : public integral_constant<bool,\n-             (is_integral<typename remove_reference<_Up>::type>::value \n-              || is_enum<typename remove_reference<_Up>::type>::value)> \n-  { };\n-\n-template<typename _Class, typename _Tp, typename _Up>\n-struct __may_be_null_pointer_init<_Tp _Class::*, _Up>  \n-  : public integral_constant<bool,\n-             (is_integral<typename remove_reference<_Up>::type>::value \n-              || is_enum<typename remove_reference<_Up>::type>::value)> \n-  { };\n-#endif\n-\n   /// pair holds two objects of arbitrary type.\n   template<class _T1, class _T2>\n     struct pair\n@@ -116,12 +89,10 @@ struct __may_be_null_pointer_init<_Tp _Class::*, _Up>\n       : first(__a), second(__b) { }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      // Omitted the following constructor, which appears in the C++0x\n-      // working paper but is redundant with the variadic constructors\n-      // below.\n-      //\n-      //   template<class _U1, class _U2>\n-      //     pair(_U1&& __x, _U2&& __y);\n+      template<class _U1, class _U2>\n+        pair(_U1&& __x, _U2&& __y)\n+\t: first(std::forward<_U1>(__x)),\n+\t  second(std::forward<_U2>(__y)) { }\n \n       pair(pair&& __p)\n       : first(std::move(__p.first)),\n@@ -140,56 +111,12 @@ struct __may_be_null_pointer_init<_Tp _Class::*, _Up>\n \t: first(std::move(__p.first)),\n \t  second(std::move(__p.second)) { }\n \n-      // This constructor is required so that lvalue pairs don't get\n-      // pushed to the variadic constructor below.\n-      template<class _U1, class _U2>\n-        pair(pair<_U1, _U2>& __p)\n-          : first(const_cast<const pair<_U1, _U2>&>(__p).first),\n-  \t    second(const_cast<const pair<_U1, _U2>&>(__p).second) { }\n-\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 811.  pair of pointers no longer works with literal 0\n-\n-      // Variadic constructor. The enable_if makes sure that we won't\n-      // try to initialize a pointer from an integral type, which\n-      // needs to be handled by a different constructor that will\n-      // convert a null pointer constant to that pointer type. See\n-      // library issue 767.\n-      template<class _U1, class... _Args,\n-        class _Checker \n-          = typename enable_if<\n-                       (!__may_be_null_pointer_init<_T1, _U1>::value\n-                        && !__may_be_null_pointer_init<_T2, _Args...>::value), \n-                     void>::type>\n-        pair(_U1&& __x, _Args&&... __args)\n-\t: first(std::forward<_U1>(__x)),\n-\t  second(std::forward<_Args>(__args)...) { }\n-\n-      // Variadic constructor. The enable_if makes sure that the\n-      // second argument isn't going to try to initialize a pointer\n-      // from an integral type. However, T1 may be a pointer whose\n-      // argument was a null pointer constant.\n-      template<class... _Args,\n-        class _Checker \n-          = typename enable_if<\n-                       !__may_be_null_pointer_init<_T2, _Args...>::value, \n-                     void>::type>\n-        pair(const _T1& __x, _Args&&... __args)\n-\t: first(__x),\n-\t  second(std::forward<_Args>(__args)...) { }\n-\n-      // Constructor typically used when T2 is a pointer and the\n-      // second argument was a null pointer constant. The enable_if\n-      // makes sure that the first argument isn't going to try to\n-      // initialize a pointer from an integral type.\n-      template<class _U1,\n-        class _Checker \n-          = typename enable_if<\n-                     !__may_be_null_pointer_init<_T1, _U1>::value,\n-                     void>::type>\n-        pair(_U1&& __x, const _T2& __y)\n+      // http://gcc.gnu.org/ml/libstdc++/2007-08/msg00052.html\n+      template<class _U1, class _Arg0, class... _Args>\n+        pair(_U1&& __x, _Arg0&& __arg0, _Args&&... __args)\n \t: first(std::forward<_U1>(__x)),\n-\t  second(__y) { }\n+\t  second(std::forward<_Arg0>(__arg0),\n+\t\t std::forward<_Args>(__args)...) { }\n \n       pair&\n       operator=(pair&& __p)"}, {"sha": "cd5de4162eb3608ebc4a70014701f1a1e1fb3283", "filename": "libstdc++-v3/testsuite/20_util/pair/moveable.cc", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0f2a1dfd96bc496c50a264d2482daa254490aa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fmoveable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0f2a1dfd96bc496c50a264d2482daa254490aa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fmoveable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fmoveable.cc?ref=8f0f2a1dfd96bc496c50a264d2482daa254490aa", "patch": "@@ -64,54 +64,9 @@ test2()\n          r.second.size() == 2 && p.second.size() == 0);\n }\n \n-struct X { \n-  explicit X(int, int) { }\n-\n-private:\n-  X(const X&) = delete;\n-};\n-\n-struct move_only {\n-  move_only() { }\n-  move_only(move_only&&) { }\n-\n-private:\n-  move_only(const move_only&) = delete;\n-};\n-\n-void\n-test3()\n-{\n-  int *ip = 0;\n-  int X::*mp = 0;\n-  std::pair<int*, int*> p1(0, 0);\n-  std::pair<int*, int*> p2(ip, 0);\n-  std::pair<int*, int*> p3(0, ip);\n-  std::pair<int*, int*> p4(ip, ip);\n-\n-  std::pair<int X::*, int*> p5(0, 0);\n-  std::pair<int X::*, int X::*> p6(mp, 0);\n-  std::pair<int X::*, int X::*> p7(0, mp);\n-  std::pair<int X::*, int X::*> p8(mp, mp);\n-\n-  std::pair<int*, X> p9(0, 1, 2);\n-  std::pair<int X::*, X> p10(0, 1, 2);\n-  std::pair<int*, X> p11(ip, 1, 2);\n-  std::pair<int X::*, X> p12(mp, 1, 2);\n-\n-  std::pair<int*, move_only> p13(0);\n-  std::pair<int X::*, move_only> p14(0);\n-\n-  std::pair<int*, move_only> p15(0, move_only());\n-  std::pair<int X::*, move_only> p16(0, move_only());\n-  std::pair<move_only, int*> p17(move_only(), 0);\n-  std::pair<move_only, int X::*> p18(move_only(), 0);\n-}\n-\n int \n main() \n {\n   test1();\n   test2();\n-  test3();\n }"}]}