{"sha": "bc59a4cf1af79b77e3621b2103efc02c57ac7aec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM1OWE0Y2YxYWY3OWI3N2UzNjIxYjIxMDNlZmMwMmM1N2FjN2FlYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-07-19T08:47:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-07-19T08:47:41Z"}, "message": "re PR tree-optimization/91207 (Wrong code with -O3)\n\n2019-07-19  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/91207\n\tRevert\n\t2019-07-17  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/91178\n\t* tree-vect-stmts.c (get_group_load_store_type): For SLP\n\tloads with a gap larger than the vector size always use\n\tVMAT_STRIDED_SLP.\n\t(vectorizable_load): For VMAT_STRIDED_SLP with a permutation\n\tavoid loading vectors that are only contained in the gap\n\tand thus are not needed.\n\n\t* gcc.dg/torture/pr91207.c: New testcase.\n\nFrom-SVN: r273593", "tree": {"sha": "5b8dbe3c6a2e65290e4993822d446d8b0f3a7706", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b8dbe3c6a2e65290e4993822d446d8b0f3a7706"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc59a4cf1af79b77e3621b2103efc02c57ac7aec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc59a4cf1af79b77e3621b2103efc02c57ac7aec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc59a4cf1af79b77e3621b2103efc02c57ac7aec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc59a4cf1af79b77e3621b2103efc02c57ac7aec/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "daaa6fcc70ffe66bd56f5819ad4ee78fecd54bb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daaa6fcc70ffe66bd56f5819ad4ee78fecd54bb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daaa6fcc70ffe66bd56f5819ad4ee78fecd54bb6"}], "stats": {"total": 66, "additions": 46, "deletions": 20}, "files": [{"sha": "95868abb6d454bf1662a1d5c1159c2a4bffcecdf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc59a4cf1af79b77e3621b2103efc02c57ac7aec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc59a4cf1af79b77e3621b2103efc02c57ac7aec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc59a4cf1af79b77e3621b2103efc02c57ac7aec", "patch": "@@ -1,3 +1,17 @@\n+2019-07-19  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/91207\n+\tRevert\n+\t2019-07-17  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/91178\n+\t* tree-vect-stmts.c (get_group_load_store_type): For SLP\n+\tloads with a gap larger than the vector size always use\n+\tVMAT_STRIDED_SLP.\n+\t(vectorizable_load): For VMAT_STRIDED_SLP with a permutation\n+\tavoid loading vectors that are only contained in the gap\n+\tand thus are not needed.\n+\n 2019-07-18  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*addqi_2_slp): Remove."}, {"sha": "b4fca286108b58b41d339669933fb5239acfbcf3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc59a4cf1af79b77e3621b2103efc02c57ac7aec/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc59a4cf1af79b77e3621b2103efc02c57ac7aec/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bc59a4cf1af79b77e3621b2103efc02c57ac7aec", "patch": "@@ -1,3 +1,8 @@\n+2019-07-19  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/91207\n+\t* gcc.dg/torture/pr91207.c: New testcase.\n+\n 2019-07-18  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \tPR target/91188"}, {"sha": "36d71d38b092dd779f8a6f902b294e63c6f032b3", "filename": "gcc/testsuite/gcc.dg/torture/pr91207.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc59a4cf1af79b77e3621b2103efc02c57ac7aec/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr91207.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc59a4cf1af79b77e3621b2103efc02c57ac7aec/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr91207.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr91207.c?ref=bc59a4cf1af79b77e3621b2103efc02c57ac7aec", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run } */\n+\n+long long a;\n+int b[92][32];\n+unsigned int c, d;\n+\n+void e(long long *f, int p2) { *f = p2; }\n+\n+int main()\n+{\n+  for (int i = 6; i <= 20; d = i++)\n+    for (int j = 6; j <= 91; j++) {\n+\tfor (int k = 16; k <= 31;k++)\n+\t  b[j][k] ^= 7;\n+\tc *= d;\n+    }\n+\n+  for (int i = 0; i < 21; ++i)\n+    for (int j = 0; j < 32; ++j)\n+      e(&a, b[i][j]);\n+\n+  if (a != 7)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "601a6f55fbff388c89f88d994e790aebf2bf960e", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc59a4cf1af79b77e3621b2103efc02c57ac7aec/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc59a4cf1af79b77e3621b2103efc02c57ac7aec/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=bc59a4cf1af79b77e3621b2103efc02c57ac7aec", "patch": "@@ -2267,23 +2267,14 @@ get_group_load_store_type (stmt_vec_info stmt_info, tree vectype, bool slp,\n \t\t\t/ vect_get_scalar_dr_size (first_dr_info)))\n \t    overrun_p = false;\n \n-\t  /* If the gap at the end of the group exceeds a whole vector\n-\t     in size use the strided SLP code which can skip code-generation\n-\t     for the gap.  */\n-\t  if (vls_type == VLS_LOAD && known_gt (gap, nunits))\n-\t    *memory_access_type = VMAT_STRIDED_SLP;\n-\t  else\n-\t    *memory_access_type = VMAT_CONTIGUOUS;\n-\n \t  /* If the gap splits the vector in half and the target\n \t     can do half-vector operations avoid the epilogue peeling\n \t     by simply loading half of the vector only.  Usually\n \t     the construction with an upper zero half will be elided.  */\n \t  dr_alignment_support alignment_support_scheme;\n \t  scalar_mode elmode = SCALAR_TYPE_MODE (TREE_TYPE (vectype));\n \t  machine_mode vmode;\n-\t  if (*memory_access_type == VMAT_CONTIGUOUS\n-\t      && overrun_p\n+\t  if (overrun_p\n \t      && !masked_p\n \t      && (((alignment_support_scheme\n \t\t      = vect_supportable_dr_alignment (first_dr_info, false)))\n@@ -2306,6 +2297,7 @@ get_group_load_store_type (stmt_vec_info stmt_info, tree vectype, bool slp,\n \t\t\t\t \"Peeling for outer loop is not supported\\n\");\n \t      return false;\n \t    }\n+\t  *memory_access_type = VMAT_CONTIGUOUS;\n \t}\n     }\n   else\n@@ -8740,7 +8732,6 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       /* Checked by get_load_store_type.  */\n       unsigned int const_nunits = nunits.to_constant ();\n       unsigned HOST_WIDE_INT cst_offset = 0;\n-      unsigned int group_gap = 0;\n \n       gcc_assert (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo));\n       gcc_assert (!nested_in_vect_loop);\n@@ -8758,7 +8749,6 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       if (slp && grouped_load)\n \t{\n \t  group_size = DR_GROUP_SIZE (first_stmt_info);\n-\t  group_gap = DR_GROUP_GAP (first_stmt_info);\n \t  ref_type = get_group_alias_ptr_type (first_stmt_info);\n \t}\n       else\n@@ -8902,14 +8892,6 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  if (nloads > 1)\n \t    vec_alloc (v, nloads);\n \t  stmt_vec_info new_stmt_info = NULL;\n-\t  if (slp && slp_perm\n-\t      && (group_el % group_size) > group_size - group_gap\n-\t      && (group_el % group_size) + nloads * lnel < group_size)\n-\t    {\n-\t      dr_chain.quick_push (NULL_TREE);\n-\t      group_el += nloads * lnel;\n-\t      continue;\n-\t    }\n \t  for (i = 0; i < nloads; i++)\n \t    {\n \t      tree this_off = build_int_cst (TREE_TYPE (alias_off),"}]}