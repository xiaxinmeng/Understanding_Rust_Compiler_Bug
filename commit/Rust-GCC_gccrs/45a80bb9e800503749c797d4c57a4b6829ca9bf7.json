{"sha": "45a80bb9e800503749c797d4c57a4b6829ca9bf7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVhODBiYjllODAwNTAzNzQ5Yzc5N2Q0YzU3YTRiNjgyOWNhOWJmNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-02-09T22:49:30Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-02-09T22:49:30Z"}, "message": "Makefile.in (passes.o, [...]): Add dependencies.\n\n\t* Makefile.in (passes.o, ipa-inline.o): Add dependencies.\n\t* cgraphbuild.c (build_cgraph_edges): Compute frequencies.\n\t(rebuild_cgraph_edges): Likewise.\n\t* cgraph.c (cgraph_set_call_stmt): Add new argument frequency.\n\t(dump_cgraph_node): Dump frequencies.\n\t(cgraph_clone_edge): Add frequency scales.\n\t(cgraph_clone_node): Add freuqnecy.\n\t* cgraph.h (cgraph_edge): Add freuqnecy argument.\n\t(CGRAPH_FREQ_BASE, CGRAPH_FREQ_MAX): New constants.\n\t(cgraph_create_edge, cgraph_clone_edge, cgraph_clone_node): Update.\n\t* tree-pass.h (TODO_rebuild_frequencies): New constant.\n\t* cgraphunit.c (verify_cgraph_node): Verify frequencies.\n\t(cgraph_copy_node_for_versioning): Update call of cgraph_clone_edge.\n\t(save_inline_function_body): Likewise.\n\t* ipa-inline.c: inluce rtl.h\n\t(cgraph_clone_inlined_nods): Update call of cgraph_clone_node.\n\t(cgraph_edge_badness): Use frequencies.\n\t(cgraph_decide_recursive_inlining): Update clonning.\n\t(cgraph_decide_inlining_of_small_function): Dump frequency.\n\t* predict.c (estimate_bb_frequencies): Export.\n\t* predict.h (estimate_bb_frequencies): Declare.\n\t* tree-inline.c (copy_bb): Watch overflows.\n\t(expand_call_inline): Update call of cgraph_create_edge.\n\t(optimize_inline_calls): Use TODO flags to update frequnecies.\n\t* passes.h: Include predict.h\n\t(init_optimization_passes): Move profile ahead.\n\t(execute_function_todo): Handle TODO_rebuild_frequencies.\n\nFrom-SVN: r121780", "tree": {"sha": "dd0cf0d6f5ee79e534f85b6bf4b3b2f75372bd8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd0cf0d6f5ee79e534f85b6bf4b3b2f75372bd8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45a80bb9e800503749c797d4c57a4b6829ca9bf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45a80bb9e800503749c797d4c57a4b6829ca9bf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45a80bb9e800503749c797d4c57a4b6829ca9bf7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45a80bb9e800503749c797d4c57a4b6829ca9bf7/comments", "author": null, "committer": null, "parents": [{"sha": "f2477b062c9c639e5354ef705022a47dcb61e213", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2477b062c9c639e5354ef705022a47dcb61e213", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2477b062c9c639e5354ef705022a47dcb61e213"}], "stats": {"total": 284, "additions": 218, "deletions": 66}, "files": [{"sha": "f9238459a01bb03f9f0f6c9b6153bad2227561b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45a80bb9e800503749c797d4c57a4b6829ca9bf7", "patch": "@@ -1,3 +1,33 @@\n+2007-02-09  Jan Hubicka  <jh@suse.cz>\n+\n+\t* Makefile.in (passes.o, ipa-inline.o): Add dependencies.\n+\t* cgraphbuild.c (build_cgraph_edges): Compute frequencies.\n+\t(rebuild_cgraph_edges): Likewise.\n+\t* cgraph.c (cgraph_set_call_stmt): Add new argument frequency.\n+\t(dump_cgraph_node): Dump frequencies.\n+\t(cgraph_clone_edge): Add frequency scales.\n+\t(cgraph_clone_node): Add freuqnecy.\n+\t* cgraph.h (cgraph_edge): Add freuqnecy argument.\n+\t(CGRAPH_FREQ_BASE, CGRAPH_FREQ_MAX): New constants.\n+\t(cgraph_create_edge, cgraph_clone_edge, cgraph_clone_node): Update.\n+\t* tree-pass.h (TODO_rebuild_frequencies): New constant.\n+\t* cgraphunit.c (verify_cgraph_node): Verify frequencies.\n+\t(cgraph_copy_node_for_versioning): Update call of cgraph_clone_edge.\n+\t(save_inline_function_body): Likewise.\n+\t* ipa-inline.c: inluce rtl.h\n+\t(cgraph_clone_inlined_nods): Update call of cgraph_clone_node.\n+\t(cgraph_edge_badness): Use frequencies.\n+\t(cgraph_decide_recursive_inlining): Update clonning.\n+\t(cgraph_decide_inlining_of_small_function): Dump frequency.\n+\t* predict.c (estimate_bb_frequencies): Export.\n+\t* predict.h (estimate_bb_frequencies): Declare.\n+\t* tree-inline.c (copy_bb): Watch overflows.\n+\t(expand_call_inline): Update call of cgraph_create_edge.\n+\t(optimize_inline_calls): Use TODO flags to update frequnecies.\n+\t* passes.h: Include predict.h\n+\t(init_optimization_passes): Move profile ahead.\n+\t(execute_function_todo): Handle TODO_rebuild_frequencies.\n+\n 2007-02-09  Roger Sayle  <roger@eyesopen.com>\n \n \t* config/alpha/alpha.c (emit_insxl): Force the first operand of"}, {"sha": "6b8882608d3f3bf82be90bb3bd8ba225ed143037", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=45a80bb9e800503749c797d4c57a4b6829ca9bf7", "patch": "@@ -2293,7 +2293,7 @@ passes.o : passes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    langhooks.h insn-flags.h $(CFGLAYOUT_H) $(REAL_H) $(CFGLOOP_H) \\\n    hosthooks.h $(CGRAPH_H) $(COVERAGE_H) tree-pass.h $(TREE_DUMP_H) \\\n    $(GGC_H) $(INTEGRATE_H) $(CPPLIB_H) opts.h $(TREE_FLOW_H) $(TREE_INLINE_H) \\\n-   gt-passes.h\n+   gt-passes.h $(PREDICT_H)\n \n main.o : main.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h\n \n@@ -2441,7 +2441,7 @@ ipa-cp.o : ipa-cp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n ipa-inline.o : ipa-inline.c gt-ipa-inline.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \\\n    $(DIAGNOSTIC_H) $(FIBHEAP_H) $(PARAMS_H) $(TIMEVAR_H) tree-pass.h \\\n-   $(COVERAGE_H) $(HASHTAB_H) \n+   $(COVERAGE_H) $(HASHTAB_H) $(RTL_H)\n ipa-utils.o : ipa-utils.c $(IPA_UTILS_H) $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(C_COMMON_H) $(TREE_GIMPLE_H) \\"}, {"sha": "87114e2ff1316372236497a8ad847a02186007f8", "filename": "gcc/cgraph.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=45a80bb9e800503749c797d4c57a4b6829ca9bf7", "patch": "@@ -324,7 +324,7 @@ cgraph_set_call_stmt (struct cgraph_edge *e, tree new_stmt)\n \n struct cgraph_edge *\n cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n-\t\t    tree call_stmt, gcov_type count, int nest)\n+\t\t    tree call_stmt, gcov_type count, int freq, int nest)\n {\n   struct cgraph_edge *edge = GGC_NEW (struct cgraph_edge);\n #ifdef ENABLE_CHECKING\n@@ -362,6 +362,10 @@ cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n   caller->callees = edge;\n   callee->callers = edge;\n   edge->count = count;\n+  gcc_assert (count >= 0);\n+  edge->frequency = freq;\n+  gcc_assert (freq >= 0);\n+  gcc_assert (freq <= CGRAPH_FREQ_MAX);\n   edge->loop_nest = nest;\n   if (caller->call_site_hash)\n     {\n@@ -713,6 +717,9 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n       if (edge->count)\n \tfprintf (f, \"(\"HOST_WIDEST_INT_PRINT_DEC\"x) \",\n \t\t (HOST_WIDEST_INT)edge->count);\n+      if (edge->frequency)\n+\tfprintf (f, \"(%.2f per call) \",\n+\t\t edge->frequency / (double)CGRAPH_FREQ_BASE);\n       if (!edge->inline_failed)\n \tfprintf(f, \"(inlined) \");\n     }\n@@ -727,6 +734,9 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n       if (edge->count)\n \tfprintf (f, \"(\"HOST_WIDEST_INT_PRINT_DEC\"x) \",\n \t\t (HOST_WIDEST_INT)edge->count);\n+      if (edge->frequency)\n+\tfprintf (f, \"(%.2f per call) \",\n+\t\t edge->frequency / (double)CGRAPH_FREQ_BASE);\n       if (edge->loop_nest)\n \tfprintf (f, \"(nested in %i loops) \", edge->loop_nest);\n     }\n@@ -795,13 +805,16 @@ cgraph_function_possibly_inlined_p (tree decl)\n /* Create clone of E in the node N represented by CALL_EXPR the callgraph.  */\n struct cgraph_edge *\n cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n-\t\t   tree call_stmt, gcov_type count_scale, int loop_nest,\n-\t\t   bool update_original)\n+\t\t   tree call_stmt, gcov_type count_scale, int freq_scale,\n+\t\t   int loop_nest, bool update_original)\n {\n   struct cgraph_edge *new;\n+  gcov_type count = e->count * count_scale / REG_BR_PROB_BASE;\n+  gcov_type freq = e->frequency * (gcov_type) freq_scale / CGRAPH_FREQ_BASE;\n \n-  new = cgraph_create_edge (n, e->callee, call_stmt,\n-\t\t\t    e->count * count_scale / REG_BR_PROB_BASE,\n+  if (freq > CGRAPH_FREQ_MAX)\n+    freq = CGRAPH_FREQ_MAX;\n+  new = cgraph_create_edge (n, e->callee, call_stmt, count, freq,\n \t\t\t    e->loop_nest + loop_nest);\n \n   new->inline_failed = e->inline_failed;\n@@ -821,7 +834,7 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n    function's profile to reflect the fact that part of execution is handled\n    by node.  */\n struct cgraph_node *\n-cgraph_clone_node (struct cgraph_node *n, gcov_type count, int loop_nest,\n+cgraph_clone_node (struct cgraph_node *n, gcov_type count, int freq, int loop_nest,\n \t\t   bool update_original)\n {\n   struct cgraph_node *new = cgraph_create_node ();\n@@ -853,7 +866,7 @@ cgraph_clone_node (struct cgraph_node *n, gcov_type count, int loop_nest,\n     }\n \n   for (e = n->callees;e; e=e->next_callee)\n-    cgraph_clone_edge (e, new, e->call_stmt, count_scale, loop_nest,\n+    cgraph_clone_edge (e, new, e->call_stmt, count_scale, freq, loop_nest,\n \t\t       update_original);\n \n   new->next_clone = n->next_clone;"}, {"sha": "b905bfdf6c320c7c369e9cdc0251a6bb406ea8b4", "filename": "gcc/cgraph.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=45a80bb9e800503749c797d4c57a4b6829ca9bf7", "patch": "@@ -201,10 +201,17 @@ struct cgraph_edge GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_call\n   const char *inline_failed;\n   /* Expected number of executions: calculated in profile.c.  */\n   gcov_type count;\n+  /* Expected frequency of executions within the function. \n+     When set to CGRAPH_FREQ_BASE, the edge is expected to be called once\n+     per function call.  The range is 0 to CGRAPH_FREQ_MAX.  */\n+  int frequency;\n   /* Depth of loop nest, 1 means no loop nest.  */\n   int loop_nest;\n };\n \n+#define CGRAPH_FREQ_BASE 1000\n+#define CGRAPH_FREQ_MAX 100000\n+\n typedef struct cgraph_edge *cgraph_edge_p;\n \n DEF_VEC_P(cgraph_edge_p);\n@@ -290,7 +297,7 @@ void cgraph_release_function_body (struct cgraph_node *);\n void cgraph_node_remove_callees (struct cgraph_node *node);\n struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n \t\t\t\t\tstruct cgraph_node *,\n-\t\t\t\t\ttree, gcov_type, int);\n+\t\t\t\t\ttree, gcov_type, int, int);\n struct cgraph_node *cgraph_node (tree);\n struct cgraph_node *cgraph_node_for_asm (tree asmname);\n struct cgraph_edge *cgraph_edge (struct cgraph_node *, tree);\n@@ -301,8 +308,8 @@ struct cgraph_rtl_info *cgraph_rtl_info (tree);\n const char * cgraph_node_name (struct cgraph_node *);\n struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n \t\t\t\t\tstruct cgraph_node *,\n-\t\t\t\t\ttree, gcov_type, int, bool);\n-struct cgraph_node * cgraph_clone_node (struct cgraph_node *, gcov_type,\n+\t\t\t\t\ttree, gcov_type, int, int, bool);\n+struct cgraph_node * cgraph_clone_node (struct cgraph_node *, gcov_type, int,\n \t\t\t\t\tint, bool);\n \n void cgraph_redirect_edge_callee (struct cgraph_edge *, struct cgraph_node *);"}, {"sha": "9d89aeb8d01529dfa6b85e1cce3217a8b05bf9d8", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=45a80bb9e800503749c797d4c57a4b6829ca9bf7", "patch": "@@ -115,6 +115,10 @@ build_cgraph_edges (void)\n   struct pointer_set_t *visited_nodes = pointer_set_create ();\n   block_stmt_iterator bsi;\n   tree step;\n+  int entry_freq = ENTRY_BLOCK_PTR->frequency;\n+\n+  if (!entry_freq)\n+    entry_freq = 1;\n \n   /* Create the callgraph edges and record the nodes referenced by the function.\n      body.  */\n@@ -127,8 +131,12 @@ build_cgraph_edges (void)\n \n \tif (call && (decl = get_callee_fndecl (call)))\n \t  {\n+\t    int freq = (!bb->frequency && !entry_freq ? CGRAPH_FREQ_BASE\n+\t\t\t: bb->frequency * CGRAPH_FREQ_BASE / entry_freq);\n+\t    if (freq > CGRAPH_FREQ_MAX)\n+\t      freq = CGRAPH_FREQ_MAX;\n \t    cgraph_create_edge (node, cgraph_node (decl), stmt,\n-\t\t\t\tbb->count,\n+\t\t\t\tbb->count, freq,\n \t\t\t\tbb->loop_depth);\n \t    walk_tree (&TREE_OPERAND (call, 1),\n \t\t       record_reference, node, visited_nodes);\n@@ -196,6 +204,10 @@ rebuild_cgraph_edges (void)\n   basic_block bb;\n   struct cgraph_node *node = cgraph_node (current_function_decl);\n   block_stmt_iterator bsi;\n+  int entry_freq = ENTRY_BLOCK_PTR->frequency;\n+\n+  if (!entry_freq)\n+    entry_freq = 1;\n \n   cgraph_node_remove_callees (node);\n \n@@ -209,9 +221,14 @@ rebuild_cgraph_edges (void)\n \ttree decl;\n \n \tif (call && (decl = get_callee_fndecl (call)))\n-\t  cgraph_create_edge (node, cgraph_node (decl), stmt,\n-\t\t\t      bb->count,\n-\t\t\t      bb->loop_depth);\n+\t  {\n+\t    int freq = (!bb->frequency && !entry_freq ? CGRAPH_FREQ_BASE\n+\t\t\t: bb->frequency * CGRAPH_FREQ_BASE / entry_freq);\n+\t    if (freq > CGRAPH_FREQ_MAX)\n+\t      freq = CGRAPH_FREQ_MAX;\n+\t    cgraph_create_edge (node, cgraph_node (decl), stmt,\n+\t\t\t\tbb->count, freq, bb->loop_depth);\n+\t   }\n       }\n   initialize_inline_failed (node);\n   gcc_assert (!node->global.inlined_to);"}, {"sha": "2d1ecda64acbe6fd28521ec767a9b7e5f034f358", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=45a80bb9e800503749c797d4c57a4b6829ca9bf7", "patch": "@@ -519,6 +519,16 @@ verify_cgraph_node (struct cgraph_node *node)\n \t  error (\"caller edge count is negative\");\n \t  error_found = true;\n \t}\n+      if (e->frequency < 0)\n+\t{\n+\t  error (\"caller edge frequency is negative\");\n+\t  error_found = true;\n+\t}\n+      if (e->frequency > CGRAPH_FREQ_MAX)\n+\t{\n+\t  error (\"caller edge frequency is too large\");\n+\t  error_found = true;\n+\t}\n       if (!e->inline_failed)\n \t{\n \t  if (node->global.inlined_to\n@@ -1412,7 +1422,8 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n       also cloned.  */\n    for (e = old_version->callees;e; e=e->next_callee)\n      {\n-       new_e = cgraph_clone_edge (e, new_version, e->call_stmt, 0, e->loop_nest, true);\n+       new_e = cgraph_clone_edge (e, new_version, e->call_stmt, 0, e->frequency,\n+\t\t\t\t  e->loop_nest, true);\n        new_e->count = e->count;\n      }\n    /* Fix recursive calls.\n@@ -1511,7 +1522,8 @@ save_inline_function_body (struct cgraph_node *node)\n     {\n       struct cgraph_edge *e;\n \n-      first_clone = cgraph_clone_node (node, node->count, 0, false);\n+      first_clone = cgraph_clone_node (node, node->count, 0, CGRAPH_FREQ_BASE,\n+\t\t\t\t       false);\n       first_clone->needed = 0;\n       first_clone->reachable = 1;\n       /* Recursively clone all bodies.  */"}, {"sha": "50b02fbf6f59e609526a2c0b5f5547d2de7c04bf", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 63, "deletions": 30, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=45a80bb9e800503749c797d4c57a4b6829ca9bf7", "patch": "@@ -139,6 +139,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"coverage.h\"\n #include \"ggc.h\"\n #include \"tree-flow.h\"\n+#include \"rtl.h\"\n \n /* Mode incremental inliner operate on:\n \n@@ -215,7 +216,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate, bool update_o\n       else\n \t{\n \t  struct cgraph_node *n;\n-\t  n = cgraph_clone_node (e->callee, e->count, e->loop_nest, \n+\t  n = cgraph_clone_node (e->callee, e->count, e->frequency, e->loop_nest, \n \t\t\t\t update_original);\n \t  cgraph_redirect_edge_callee (e, n);\n \t}\n@@ -478,44 +479,75 @@ cgraph_maybe_hot_edge_p (struct cgraph_edge *edge)\n    smallest badness are inlined first.  After each inlining is performed\n    the costs of all caller edges of nodes affected are recomputed so the\n    metrics may accurately depend on values such as number of inlinable callers\n-   of the function or function body size.\n-\n-   With profiling we use number of executions of each edge to drive the cost.\n-   We also should distinguish hot and cold calls where the cold calls are\n-   inlined into only when code size is overall improved.  \n-   */\n+   of the function or function body size.  */\n \n static int\n cgraph_edge_badness (struct cgraph_edge *edge)\n {\n+  int badness;\n+  int growth =\n+    cgraph_estimate_size_after_inlining (1, edge->caller, edge->callee);\n+\n+  growth -= edge->caller->global.insns;\n+\n+  /* Always prefer inlining saving code size.  */\n+  if (growth <= 0)\n+    badness = INT_MIN - growth;\n+\n+  /* When profiling is available, base priorities -(#calls / growth).\n+     So we optimize for overall number of \"executed\" inlined calls.  */\n   if (max_count)\n+    badness = ((int)((double)edge->count * INT_MIN / max_count)) / growth;\n+\n+  /* When function local profile is available, base priorities on\n+     growth / frequency, so we optimize for overall frequency of inlined\n+     calls.  This is not too accurate since while the call might be frequent\n+     within function, the function itself is infrequent.\n+\n+     Other objective to optimize for is number of different calls inlined.\n+     We add the estimated growth after inlining all functions to biass the\n+     priorities slightly in this direction (so fewer times called functions\n+     of the same size gets priority).  */\n+  else if (flag_guess_branch_prob)\n     {\n+      int div = edge->frequency * 100 / CGRAPH_FREQ_BASE;\n       int growth =\n \tcgraph_estimate_size_after_inlining (1, edge->caller, edge->callee);\n       growth -= edge->caller->global.insns;\n+      badness = growth * 256;\n+\n+      /* Decrease badness if call is nested.  */\n+      /* Compress the range so we don't overflow.  */\n+      if (div > 256)\n+\tdiv = 256 + ceil_log2 (div) - 8;\n+      if (div < 1)\n+\tdiv = 1;\n+      if (badness > 0)\n+\tbadness /= div;\n+      badness += cgraph_estimate_growth (edge->callee);\n+    }\n+  /* When function local profile is not available or it does not give\n+     useful information (ie frequency is zero), base the cost on\n+     loop nest and overall size growth, so we optimize for overall number\n+     of functions fully inlined in program.  */\n+  else\n+    {\n+      int nest = MIN (edge->loop_nest, 8);\n+      badness = cgraph_estimate_growth (edge->callee) * 256;\n \n-      /* Always prefer inlining saving code size.  */\n-      if (growth <= 0)\n-\treturn INT_MIN - growth;\n-      return ((int)((double)edge->count * INT_MIN / max_count)) / growth;\n+      /* Decrease badness if call is nested.  */\n+      if (badness > 0)    \n+\tbadness >>= nest;\n+      else\n+        {\n+\t  badness <<= nest;\n+        }\n     }\n+  /* Make recursive inlining happen always after other inlining is done.  */\n+  if (cgraph_recursive_inlining_p (edge->caller, edge->callee, NULL))\n+    return badness + 1;\n   else\n-  {\n-    int nest = MIN (edge->loop_nest, 8);\n-    int badness = cgraph_estimate_growth (edge->callee) * 256;\n-\n-    /* Decrease badness if call is nested.  */\n-    if (badness > 0)    \n-      badness >>= nest;\n-    else\n-      badness <<= nest;\n-\n-    /* Make recursive inlining happen always after other inlining is done.  */\n-    if (cgraph_recursive_inlining_p (edge->caller, edge->callee, NULL))\n-      return badness + 1;\n-    else\n-      return badness;\n-  }\n+    return badness;\n }\n \n /* Recompute heap nodes for each of caller edge.  */\n@@ -651,7 +683,7 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node)\n \t     cgraph_node_name (node));\n \n   /* We need original clone to copy around.  */\n-  master_clone = cgraph_clone_node (node, node->count, 1, false);\n+  master_clone = cgraph_clone_node (node, node->count, CGRAPH_FREQ_BASE, 1, false);\n   master_clone->needed = true;\n   for (e = master_clone->callees; e; e = e->next_callee)\n     if (!e->inline_failed)\n@@ -831,10 +863,11 @@ cgraph_decide_inlining_of_small_functions (void)\n \t  fprintf (dump_file, \n \t\t   \" to be inlined into %s\\n\"\n \t\t   \" Estimated growth after inlined into all callees is %+i insns.\\n\"\n-\t\t   \" Estimated badness is %i.\\n\",\n+\t\t   \" Estimated badness is %i, frequency %.2f.\\n\",\n \t\t   cgraph_node_name (edge->caller),\n \t\t   cgraph_estimate_growth (edge->callee),\n-\t\t   cgraph_edge_badness (edge));\n+\t\t   cgraph_edge_badness (edge),\n+\t\t   edge->frequency / (double)CGRAPH_FREQ_BASE);\n \t  if (edge->count)\n \t    fprintf (dump_file,\" Called \"HOST_WIDEST_INT_PRINT_DEC\"x\\n\", edge->count);\n \t}"}, {"sha": "35e4164f4d31eb93c8ec06972035b3d0a478bdc6", "filename": "gcc/passes.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=45a80bb9e800503749c797d4c57a4b6829ca9bf7", "patch": "@@ -83,6 +83,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree-flow.h\"\n #include \"tree-pass.h\"\n #include \"tree-dump.h\"\n+#include \"predict.h\"\n \n #if defined (DWARF2_UNWIND_INFO) || defined (DWARF2_DEBUGGING_INFO)\n #include \"dwarf2out.h\"\n@@ -493,6 +494,7 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_merge_phi);\n \t  NEXT_PASS (pass_dce);\n \t  NEXT_PASS (pass_tail_recursion);\n+          NEXT_PASS (pass_profile);\n \t  NEXT_PASS (pass_release_ssa_names);\n \t}\n       NEXT_PASS (pass_rebuild_cgraph_edges);\n@@ -540,7 +542,6 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_phiopt);\n       NEXT_PASS (pass_may_alias);\n       NEXT_PASS (pass_tail_recursion);\n-      NEXT_PASS (pass_profile);\n       NEXT_PASS (pass_ch);\n       NEXT_PASS (pass_stdarg);\n       NEXT_PASS (pass_lower_complex);\n@@ -886,6 +887,24 @@ execute_function_todo (void *data)\n       fflush (dump_file);\n     }\n \n+  if (flags & TODO_rebuild_frequencies)\n+    {\n+      if (profile_status == PROFILE_GUESSED)\n+\t{\n+\t  loop_optimizer_init (0);\n+\t  add_noreturn_fake_exit_edges ();\n+\t  mark_irreducible_loops ();\n+\t  connect_infinite_loops_to_exit ();\n+\t  estimate_bb_frequencies ();\n+\t  remove_fake_exit_edges ();\n+\t  loop_optimizer_finalize ();\n+\t}\n+      else if (profile_status == PROFILE_READ)\n+\tcounts_to_freqs ();\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n #if defined ENABLE_CHECKING\n   if (flags & TODO_verify_ssa)\n     verify_ssa (true);"}, {"sha": "39de19b21aa685554844e9364f15f4791f1b1e0d", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=45a80bb9e800503749c797d4c57a4b6829ca9bf7", "patch": "@@ -79,7 +79,6 @@ static bool last_basic_block_p (basic_block);\n static void compute_function_frequency (void);\n static void choose_function_section (void);\n static bool can_predict_insn_p (rtx);\n-static void estimate_bb_frequencies (void);\n \n /* Information we hold about each branch predictor.\n    Filled using information from predict.def.  */\n@@ -1685,7 +1684,7 @@ expensive_function_p (int threshold)\n \n /* Estimate basic blocks frequency by given branch probabilities.  */\n \n-static void\n+void\n estimate_bb_frequencies (void)\n {\n   basic_block bb;"}, {"sha": "3862a63939b6f8577e2cfd2a68376bd413e0edb1", "filename": "gcc/predict.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=45a80bb9e800503749c797d4c57a4b6829ca9bf7", "patch": "@@ -38,5 +38,6 @@ enum prediction\n \n extern void predict_insn_def (rtx, enum br_predictor, enum prediction);\n extern int counts_to_freqs (void);\n+extern void estimate_bb_frequencies (void);\n \n #endif  /* GCC_PREDICT_H */"}, {"sha": "8f4f2d9686a77c1f6ea00e77b19147554586fe4b", "filename": "gcc/testsuite/g++.dg/gomp/pr30696.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr30696.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr30696.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr30696.C?ref=45a80bb9e800503749c797d4c57a4b6829ca9bf7", "patch": "@@ -0,0 +1,12 @@\n+inline void foo() {}\n+\n+int main()\n+{\n+    foo();\n+\n+#pragma omp parallel for\n+    for ( int i=0; i<1; ++i )\n+        foo();\n+\n+    return 0;\n+}"}, {"sha": "d2d9487d367f6c9e31891f739a4ee174ec47ed64", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=45a80bb9e800503749c797d4c57a4b6829ca9bf7", "patch": "@@ -777,8 +777,13 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale, int count_scal\n   copy_basic_block = create_basic_block (NULL, (void *) 0,\n                                          (basic_block) bb->prev_bb->aux);\n   copy_basic_block->count = bb->count * count_scale / REG_BR_PROB_BASE;\n-  copy_basic_block->frequency = (bb->frequency\n+\n+  /* We are going to rebuild frequencies from scratch.  These values have just\n+     small importance to drive canonicalize_loop_headers.  */\n+  copy_basic_block->frequency = ((gcov_type)bb->frequency\n \t\t\t\t     * frequency_scale / REG_BR_PROB_BASE);\n+  if (copy_basic_block->frequency > BB_FREQ_MAX)\n+    copy_basic_block->frequency = BB_FREQ_MAX;\n   copy_bsi = bsi_start (copy_basic_block);\n \n   for (bsi = bsi_start (bb);\n@@ -839,7 +844,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale, int count_scal\n \t\t      edge = cgraph_edge (id->src_node, orig_stmt);\n \t\t      if (edge)\n \t\t\tcgraph_clone_edge (edge, id->dst_node, stmt,\n-\t\t\t\t\t   REG_BR_PROB_BASE, 1, true);\n+\t\t\t\t\t   REG_BR_PROB_BASE, 1, edge->frequency, true);\n \t\t      break;\n \n \t\t    case CB_CGE_MOVE_CLONES:\n@@ -2400,8 +2405,14 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n          (incorrect node sharing is most common reason for missing edges.  */\n       gcc_assert (dest->needed || !flag_unit_at_a_time);\n       cgraph_create_edge (id->dst_node, dest, stmt,\n-\t\t\t  bb->count, bb->loop_depth)->inline_failed\n+\t\t\t  bb->count, CGRAPH_FREQ_BASE,\n+\t\t\t  bb->loop_depth)->inline_failed\n \t= N_(\"originally indirect function call not considered for inlining\");\n+      if (dump_file)\n+\t{\n+\t   fprintf (dump_file, \"Created new direct edge to %s\",\n+\t\t    cgraph_node_name (dest));\n+\t}\n       goto egress;\n     }\n \n@@ -2808,10 +2819,6 @@ optimize_inline_calls (tree fn)\n \tgcc_assert (e->inline_failed);\n     }\n #endif\n-  /* We need to rescale frequencies again to peak at REG_BR_PROB_BASE\n-     as inlining loops might increase the maximum.  */\n-  if (ENTRY_BLOCK_PTR->count)\n-    counts_to_freqs ();\n \n   /* We are not going to maintain the cgraph edges up to date.\n      Kill it so it won't confuse us.  */\n@@ -2830,7 +2837,8 @@ optimize_inline_calls (tree fn)\n      throw and they don't care to proactively update local EH info.  This is\n      done later in fixup_cfg pass that also execute the verification.  */\n   return (TODO_update_ssa | TODO_cleanup_cfg\n-\t  | (gimple_in_ssa_p (cfun) ? TODO_remove_unused_locals : 0));\n+\t  | (gimple_in_ssa_p (cfun) ? TODO_remove_unused_locals : 0)\n+\t  | (profile_status != PROFILE_ABSENT ? TODO_rebuild_frequencies : 0));\n }\n \n /* FN is a function that has a complete body, and CLONE is a function whose"}, {"sha": "56679ca96d0282c6ac23c798e4e5915822676124", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45a80bb9e800503749c797d4c57a4b6829ca9bf7/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=45a80bb9e800503749c797d4c57a4b6829ca9bf7", "patch": "@@ -167,6 +167,7 @@ struct dump_file_info\n #define TODO_verify_loops\t\t(1 << 6)\n #define TODO_dump_cgraph\t\t(1 << 7)\n #define TODO_remove_functions\t\t(1 << 8)\n+#define TODO_rebuild_frequencies\t(1 << 9)\n \n /* To-do flags for calls to update_ssa.  */\n \n@@ -178,13 +179,13 @@ struct dump_file_info\n    in blocks that have one or more edges with no incoming definition\n    for O_j.  This would lead to uninitialized warnings for O_j's\n    symbol.  */\n-#define TODO_update_ssa\t\t\t(1 << 9)\n+#define TODO_update_ssa\t\t\t(1 << 10)\n \n /* Update the SSA form without inserting any new PHI nodes at all.\n    This is used by passes that have either inserted all the PHI nodes\n    themselves or passes that need only to patch use-def and def-def\n    chains for virtuals (e.g., DCE).  */\n-#define TODO_update_ssa_no_phi\t\t(1 << 10)\n+#define TODO_update_ssa_no_phi\t\t(1 << 11)\n \n /* Insert PHI nodes everywhere they are needed.  No pruning of the\n    IDF is done.  This is used by passes that need the PHI nodes for\n@@ -195,28 +196,28 @@ struct dump_file_info\n    may be doing something wrong.  Inserting PHI nodes for an old name\n    where not all edges carry a new replacement may lead to silent\n    codegen errors or spurious uninitialized warnings.  */\n-#define TODO_update_ssa_full_phi\t(1 << 11)\n+#define TODO_update_ssa_full_phi\t(1 << 12)\n \n /* Passes that update the SSA form on their own may want to delegate\n    the updating of virtual names to the generic updater.  Since FUD\n    chains are easier to maintain, this simplifies the work they need\n    to do.  NOTE: If this flag is used, any OLD->NEW mappings for real\n    names are explicitly destroyed and only the symbols marked for\n    renaming are processed.  */\n-#define TODO_update_ssa_only_virtuals\t(1 << 12)\n+#define TODO_update_ssa_only_virtuals\t(1 << 13)\n \n /* Some passes leave unused local variables that can be removed from\n    cfun->unexpanded_var_list.  This reduces the size of dump files and\n    the memory footprint for VAR_DECLs.  */\n-#define TODO_remove_unused_locals\t(1 << 13)\n+#define TODO_remove_unused_locals\t(1 << 14)\n \n /* Internally used for the first in a sequence of passes.  It is set\n    for the passes that are handed to register_dump_files.  */\n-#define TODO_set_props\t\t\t(1 << 14)\n+#define TODO_set_props\t\t\t(1 << 15)\n \n /* Set by passes that may make SMT's that were previously never used\n    in statements, used.  */\n-#define TODO_update_smt_usage           (1 << 15)\n+#define TODO_update_smt_usage           (1 << 16)\n \n #define TODO_update_ssa_any\t\t\\\n     (TODO_update_ssa\t\t\t\\"}]}