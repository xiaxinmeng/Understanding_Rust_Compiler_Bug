{"sha": "1e1847612d7f169f82c985b0b3a5e3301d6fe999", "node_id": "C_kwDOANBUbNoAKDFlMTg0NzYxMmQ3ZjE2OWY4MmM5ODViMGIzYTVlMzMwMWQ2ZmU5OTk", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-12-05T20:19:27Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-12-08T18:32:11Z"}, "message": "c++: fewer allocator temps [PR105838]\n\nIn this PR, initializing the array of std::string to pass to the vector\ninitializer_list constructor gets very confusing to the optimizers as the\nnumber of elements increases, primarily because of all the std::allocator\ntemporaries passed to all the string constructors.  Instead of creating one\nfor each string, let's share an allocator between all the strings; we can do\nthis safely because we know that std::allocator is stateless and that string\ndoesn't care about the object identity of its allocator parameter.\n\n\tPR c++/105838\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (is_std_allocator): Declare.\n\t* constexpr.cc (is_std_allocator): Split out  from...\n\t(is_std_allocator_allocate): ...here.\n\t* init.cc (find_temps_r): New.\n\t(find_allocator_temp): New.\n\t(build_vec_init): Use it.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/tree-ssa/allocator-opt1.C: New test.", "tree": {"sha": "43886abb4a1ab759fb6ebaf3d7472a7819de2c77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43886abb4a1ab759fb6ebaf3d7472a7819de2c77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e1847612d7f169f82c985b0b3a5e3301d6fe999", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e1847612d7f169f82c985b0b3a5e3301d6fe999", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e1847612d7f169f82c985b0b3a5e3301d6fe999", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e1847612d7f169f82c985b0b3a5e3301d6fe999/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3da5ae7a347b7d74765053f4a08eaf7ec58f8735", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3da5ae7a347b7d74765053f4a08eaf7ec58f8735", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3da5ae7a347b7d74765053f4a08eaf7ec58f8735"}], "stats": {"total": 99, "additions": 88, "deletions": 11}, "files": [{"sha": "e43d92864f510aafe7b5d2ea3d45afeb65ccb28c", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e1847612d7f169f82c985b0b3a5e3301d6fe999/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e1847612d7f169f82c985b0b3a5e3301d6fe999/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=1e1847612d7f169f82c985b0b3a5e3301d6fe999", "patch": "@@ -2214,28 +2214,35 @@ is_std_construct_at (const constexpr_call *call)\n \t  && is_std_construct_at (call->fundef->decl));\n }\n \n-/* Return true if FNDECL is std::allocator<T>::{,de}allocate.  */\n+/* True if CTX is an instance of std::allocator.  */\n \n-static inline bool\n-is_std_allocator_allocate (tree fndecl)\n+bool\n+is_std_allocator (tree ctx)\n {\n-  tree name = DECL_NAME (fndecl);\n-  if (name == NULL_TREE\n-      || !(id_equal (name, \"allocate\") || id_equal (name, \"deallocate\")))\n-    return false;\n-\n-  tree ctx = DECL_CONTEXT (fndecl);\n   if (ctx == NULL_TREE || !CLASS_TYPE_P (ctx) || !TYPE_MAIN_DECL (ctx))\n     return false;\n \n   tree decl = TYPE_MAIN_DECL (ctx);\n-  name = DECL_NAME (decl);\n+  tree name = DECL_NAME (decl);\n   if (name == NULL_TREE || !id_equal (name, \"allocator\"))\n     return false;\n \n   return decl_in_std_namespace_p (decl);\n }\n \n+/* Return true if FNDECL is std::allocator<T>::{,de}allocate.  */\n+\n+static inline bool\n+is_std_allocator_allocate (tree fndecl)\n+{\n+  tree name = DECL_NAME (fndecl);\n+  if (name == NULL_TREE\n+      || !(id_equal (name, \"allocate\") || id_equal (name, \"deallocate\")))\n+    return false;\n+\n+  return is_std_allocator (DECL_CONTEXT (fndecl));\n+}\n+\n /* Overload for the above taking constexpr_call*.  */\n \n static inline bool"}, {"sha": "581ac2b18178f21c8deca34d6f265bfe24d6c0f3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e1847612d7f169f82c985b0b3a5e3301d6fe999/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e1847612d7f169f82c985b0b3a5e3301d6fe999/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1e1847612d7f169f82c985b0b3a5e3301d6fe999", "patch": "@@ -8472,6 +8472,7 @@ extern bool is_rvalue_constant_expression (tree);\n extern bool is_nondependent_constant_expression (tree);\n extern bool is_nondependent_static_init_expression (tree);\n extern bool is_static_init_expression    (tree);\n+extern bool is_std_allocator (tree);\n extern bool potential_rvalue_constant_expression (tree);\n extern bool require_potential_constant_expression (tree);\n extern bool require_constant_expression (tree);"}, {"sha": "428fac5621c4ccac4b51836477de44538585a228", "filename": "gcc/cp/init.cc", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e1847612d7f169f82c985b0b3a5e3301d6fe999/gcc%2Fcp%2Finit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e1847612d7f169f82c985b0b3a5e3301d6fe999/gcc%2Fcp%2Finit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.cc?ref=1e1847612d7f169f82c985b0b3a5e3301d6fe999", "patch": "@@ -4308,6 +4308,51 @@ finish_length_check (tree atype, tree iterator, tree obase, unsigned n)\n     }\n }\n \n+/* walk_tree callback to collect temporaries in an expression.  */\n+\n+tree\n+find_temps_r (tree *tp, int *walk_subtrees, void *data)\n+{\n+  vec<tree*> &temps = *static_cast<auto_vec<tree*> *>(data);\n+  tree t = *tp;\n+  if (TREE_CODE (t) == TARGET_EXPR\n+      && !TARGET_EXPR_ELIDING_P (t))\n+    temps.safe_push (tp);\n+  else if (TYPE_P (t))\n+    *walk_subtrees = 0;\n+\n+  return NULL_TREE;\n+}\n+\n+/* If INIT initializes a standard library class, and involves a temporary\n+   std::allocator<T>, return a pointer to the temp.\n+\n+   Used by build_vec_init when initializing an array of e.g. strings to reuse\n+   the same temporary allocator for all of the strings.  We can do this because\n+   std::allocator has no data and the standard library doesn't care about the\n+   address of allocator objects.\n+\n+   ??? Add an attribute to allow users to assert the same property for other\n+   classes, i.e. one object of the type is interchangeable with any other?  */\n+\n+static tree*\n+find_allocator_temp (tree init)\n+{\n+  if (TREE_CODE (init) == EXPR_STMT)\n+    init = EXPR_STMT_EXPR (init);\n+  if (TREE_CODE (init) == CONVERT_EXPR)\n+    init = TREE_OPERAND (init, 0);\n+  tree type = TREE_TYPE (init);\n+  if (!CLASS_TYPE_P (type) || !decl_in_std_namespace_p (TYPE_NAME (type)))\n+    return NULL;\n+  auto_vec<tree*> temps;\n+  cp_walk_tree_without_duplicates (&init, find_temps_r, &temps);\n+  for (tree *p : temps)\n+    if (is_std_allocator (TREE_TYPE (*p)))\n+      return p;\n+  return NULL;\n+}\n+\n /* `build_vec_init' returns tree structure that performs\n    initialization of a vector of aggregate types.\n \n@@ -4589,6 +4634,8 @@ build_vec_init (tree base, tree maxindex, tree init,\n       if (try_const)\n \tvec_alloc (const_vec, CONSTRUCTOR_NELTS (init));\n \n+      tree alloc_obj = NULL_TREE;\n+\n       FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (init), idx, field, elt)\n \t{\n \t  tree baseref = build1 (INDIRECT_REF, type, base);\n@@ -4638,7 +4685,17 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t    }\n \n \t  if (one_init)\n-\t    finish_expr_stmt (one_init);\n+\t    {\n+\t      /* Only create one std::allocator temporary.  */\n+\t      if (tree *this_alloc = find_allocator_temp (one_init))\n+\t\t{\n+\t\t  if (alloc_obj)\n+\t\t    *this_alloc = alloc_obj;\n+\t\t  else\n+\t\t    alloc_obj = TARGET_EXPR_SLOT (*this_alloc);\n+\t\t}\n+\t      finish_expr_stmt (one_init);\n+\t    }\n \n \t  one_init = cp_build_unary_op (PREINCREMENT_EXPR, base, false,\n \t\t\t\t\tcomplain);"}, {"sha": "e8394c7ad702059b65af477144400ac1eef6d7e2", "filename": "gcc/testsuite/g++.dg/tree-ssa/allocator-opt1.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e1847612d7f169f82c985b0b3a5e3301d6fe999/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fallocator-opt1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e1847612d7f169f82c985b0b3a5e3301d6fe999/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fallocator-opt1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fallocator-opt1.C?ref=1e1847612d7f169f82c985b0b3a5e3301d6fe999", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/105838\n+// { dg-additional-options -fdump-tree-gimple }\n+\n+// Check that there's only one allocator (temporary) variable.\n+// Currently the dump doesn't print the allocator template arg in this context.\n+// { dg-final { scan-tree-dump-times \"struct allocator D\" 1 \"gimple\" } }\n+\n+#include <string>\n+void f (const char *p)\n+{\n+  std::string lst[] = { p, p, p, p };\n+}"}]}