{"sha": "7bb0943f9cd7d9c7f056671ec8331b0ea7e98c94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JiMDk0M2Y5Y2Q3ZDljN2YwNTY2NzFlYzgzMzFiMGVhN2U5OGM5NA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-10T16:23:27Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-10T16:23:27Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r953", "tree": {"sha": "b97643e4e54b70396e73f399b11e29159d56e419", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b97643e4e54b70396e73f399b11e29159d56e419"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bb0943f9cd7d9c7f056671ec8331b0ea7e98c94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bb0943f9cd7d9c7f056671ec8331b0ea7e98c94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bb0943f9cd7d9c7f056671ec8331b0ea7e98c94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bb0943f9cd7d9c7f056671ec8331b0ea7e98c94/comments", "author": null, "committer": null, "parents": [{"sha": "abf8eb0f8560e54807a083d7c6924e3bc2c69c45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abf8eb0f8560e54807a083d7c6924e3bc2c69c45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abf8eb0f8560e54807a083d7c6924e3bc2c69c45"}], "stats": {"total": 112, "additions": 87, "deletions": 25}, "files": [{"sha": "7dd7707be5f5f95767e20f35c7f86751c4f0889d", "filename": "gcc/expr.c", "status": "modified", "additions": 87, "deletions": 25, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bb0943f9cd7d9c7f056671ec8331b0ea7e98c94/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bb0943f9cd7d9c7f056671ec8331b0ea7e98c94/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=7bb0943f9cd7d9c7f056671ec8331b0ea7e98c94", "patch": "@@ -1919,9 +1919,10 @@ expand_assignment (to, from, want_value, suggest_reg)\n       enum machine_mode mode1;\n       int bitsize;\n       int bitpos;\n+      tree offset;\n       int unsignedp;\n       int volatilep = 0;\n-      tree tem = get_inner_reference (to, &bitsize, &bitpos,\n+      tree tem = get_inner_reference (to, &bitsize, &bitpos, &offset,\n \t\t\t\t      &mode1, &unsignedp, &volatilep);\n \n       /* If we are going to use store_bit_field and extract_bit_field,\n@@ -1931,6 +1932,16 @@ expand_assignment (to, from, want_value, suggest_reg)\n \ttem = stabilize_reference (tem);\n \n       to_rtx = expand_expr (tem, 0, VOIDmode, 0);\n+      if (offset != 0)\n+\t{\n+\t  rtx offset_rtx = expand_expr (offset, 0, VOIDmode, 0);\n+\n+\t  if (GET_CODE (to_rtx) != MEM)\n+\t    abort ();\n+\t  to_rtx = change_address (to_rtx, VOIDmode,\n+\t\t\t\t   gen_rtx (PLUS, Pmode, XEXP (to_rtx, 0),\n+\t\t\t\t\t    force_reg (Pmode, offset_rtx)));\n+\t}\n       if (volatilep)\n \t{\n \t  if (GET_CODE (to_rtx) == MEM)\n@@ -2445,6 +2456,10 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \n    We set *PBITSIZE to the size in bits that we want, *PBITPOS to the\n    bit position, and *PUNSIGNEDP to the signedness of the field.\n+   If the position of the field is variable, we store a tree\n+   giving the variable offset (in units) in *POFFSET.\n+   This offset is in addition to the bit position.\n+   If the position is not variable, we store 0 in *POFFSET.\n \n    If any of the extraction expressions is volatile,\n    we store 1 in *PVOLATILEP.  Otherwise we don't change that.\n@@ -2458,16 +2473,18 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n    this case, but the address of the object can be found.  */\n \n tree\n-get_inner_reference (exp, pbitsize, pbitpos, pmode, punsignedp, pvolatilep)\n+get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode, punsignedp, pvolatilep)\n      tree exp;\n      int *pbitsize;\n      int *pbitpos;\n+     tree *poffset;\n      enum machine_mode *pmode;\n      int *punsignedp;\n      int *pvolatilep;\n {\n   tree size_tree = 0;\n   enum machine_mode mode = VOIDmode;\n+  tree offset = 0;\n \n   if (TREE_CODE (exp) == COMPONENT_REF)\n     {\n@@ -2503,43 +2520,69 @@ get_inner_reference (exp, pbitsize, pbitpos, pmode, punsignedp, pvolatilep)\n \n   while (1)\n     {\n-      if (TREE_CODE (exp) == COMPONENT_REF)\n+      if (TREE_CODE (exp) == COMPONENT_REF || TREE_CODE (exp) == BIT_FIELD_REF)\n \t{\n-\t  tree field = TREE_OPERAND (exp, 1);\n+\t  tree pos = (TREE_CODE (exp) == COMPONENT_REF\n+\t\t      ? DECL_FIELD_BITPOS (TREE_OPERAND (exp, 1))\n+\t\t      : TREE_OPERAND (exp, 2));\n \n-\t  if (TREE_CODE (DECL_FIELD_BITPOS (field)) != INTEGER_CST)\n-\t    /* ??? This case remains to be written.  */\n-\t    abort ();\n-\n-\t  *pbitpos += TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field));\n-\t  if (TREE_THIS_VOLATILE (exp))\n-\t    *pvolatilep = 1;\n+\t  if (TREE_CODE (pos) == PLUS_EXPR)\n+\t    {\n+\t      tree constant, var;\n+\t      if (TREE_CODE (TREE_OPERAND (pos, 0)) == INTEGER_CST)\n+\t\t{\n+\t\t  constant = TREE_OPERAND (pos, 0);\n+\t\t  var = TREE_OPERAND (pos, 1);\n+\t\t}\n+\t      else if (TREE_CODE (TREE_OPERAND (pos, 1)) == INTEGER_CST)\n+\t\t{\n+\t\t  constant = TREE_OPERAND (pos, 1);\n+\t\t  var = TREE_OPERAND (pos, 0);\n+\t\t}\n+\t      else\n+\t\tabort ();\n+\t      *pbitpos += TREE_INT_CST_LOW (constant);\n+\t      if (offset)\n+\t\toffset = size_binop (PLUS_EXPR, offset,\n+\t\t\t\t     size_binop (FLOOR_DIV_EXPR, var,\n+\t\t\t\t\t\t size_int (BITS_PER_UNIT)));\n+\t      else\n+\t\toffset = size_binop (FLOOR_DIV_EXPR, var,\n+\t\t\t\t     size_int (BITS_PER_UNIT));\n+\t    }\n+\t  else if (TREE_CODE (pos) == INTEGER_CST)\n+\t    *pbitpos += TREE_INT_CST_LOW (pos);\n+\t  else\n+\t    {\n+\t      /* Assume here that the offset is a multiple of a unit.\n+\t\t If not, there should be an explicitly added constant.  */\n+\t      if (offset)\n+\t\toffset = size_binop (PLUS_EXPR, offset,\n+\t\t\t\t     size_binop (FLOOR_DIV_EXPR, pos,\n+\t\t\t\t\t\t size_int (BITS_PER_UNIT)));\n+\t      else\n+\t\toffset = size_binop (FLOOR_DIV_EXPR, pos,\n+\t\t\t\t     size_int (BITS_PER_UNIT));\n+\t    }\n \t}\n-      else if (TREE_CODE (exp) == BIT_FIELD_REF)\n-\t{\n-\t  if (TREE_CODE (TREE_OPERAND (exp, 2)) != INTEGER_CST)\n-\t    /* ??? This case remains to be written.  */\n-\t    abort ();\n \n-\t  *pbitpos += TREE_INT_CST_LOW (TREE_OPERAND (exp, 2));\n-\t  if (TREE_THIS_VOLATILE (exp))\n-\t    *pvolatilep = 1;\n-\t}\n       else if (TREE_CODE (exp) == ARRAY_REF\n \t       && TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST\n \t       && TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) == INTEGER_CST)\n \t{\n \t  *pbitpos += (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))\n \t\t       * TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (exp))));\n-\t  if (TREE_THIS_VOLATILE (exp))\n-\t    *pvolatilep = 1;\n \t}\n       else if (TREE_CODE (exp) != NON_LVALUE_EXPR\n \t       && ! ((TREE_CODE (exp) == NOP_EXPR\n \t\t      || TREE_CODE (exp) == CONVERT_EXPR)\n \t\t     && (TYPE_MODE (TREE_TYPE (exp))\n \t\t\t == TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))))\n \tbreak;\n+\n+      /* If any reference in the chain is volatile, the effect is volatile.  */\n+      if (TREE_THIS_VOLATILE (exp))\n+\t*pvolatilep = 1;\n       exp = TREE_OPERAND (exp, 0);\n     }\n \n@@ -2553,6 +2596,12 @@ get_inner_reference (exp, pbitsize, pbitpos, pmode, punsignedp, pvolatilep)\n     }\n \n   *pmode = mode;\n+  *poffset = offset;\n+#if 0\n+  /* We aren't finished fixing the callers to really handle nonzero offset.  */\n+  if (offset != 0)\n+    abort ();\n+#endif\n \n   return exp;\n }\n@@ -3404,8 +3453,9 @@ expand_expr (exp, target, tmode, modifier)\n \tenum machine_mode mode1;\n \tint bitsize;\n \tint bitpos;\n+\ttree offset;\n \tint volatilep = 0;\n-\ttree tem = get_inner_reference (exp, &bitsize, &bitpos,\n+\ttree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n \t\t\t\t\t&mode1, &unsignedp, &volatilep);\n \n \t/* In some cases, we will be offsetting OP0's address by a constant.\n@@ -3424,6 +3474,17 @@ expand_expr (exp, target, tmode, modifier)\n \t      op0 = validize_mem (force_const_mem (mode, op0));\n \t  }\n \n+\tif (offset != 0)\n+\t  {\n+\t    rtx offset_rtx = expand_expr (offset, 0, VOIDmode, 0);\n+\n+\t    if (GET_CODE (op0) != MEM)\n+\t      abort ();\n+\t    op0 = change_address (op0, VOIDmode,\n+\t\t\t\t  gen_rtx (PLUS, Pmode, XEXP (op0, 0),\n+\t\t\t\t\t   force_reg (Pmode, offset_rtx)));\n+\t  }\n+\n \t/* Don't forget about volatility even if this is a bitfield.  */\n \tif (GET_CODE (op0) == MEM && volatilep && ! MEM_VOLATILE_P (op0))\n \t  {\n@@ -5815,12 +5876,13 @@ do_jump (exp, if_false_label, if_true_label)\n \tint bitsize, bitpos, unsignedp;\n \tenum machine_mode mode;\n \ttree type;\n+\ttree offset;\n \tint volatilep = 0;\n \n \t/* Get description of this reference.  We don't actually care\n \t   about the underlying object here.  */\n-\tget_inner_reference (exp, &bitsize, &bitpos, &mode, &unsignedp,\n-\t\t\t     &volatilep);\n+\tget_inner_reference (exp, &bitsize, &bitpos, &offset,\n+\t\t\t     &mode, &unsignedp, &volatilep);\n \n \ttype = type_for_size (bitsize, unsignedp);\n \tif (type != 0 && bitsize >= 0"}]}