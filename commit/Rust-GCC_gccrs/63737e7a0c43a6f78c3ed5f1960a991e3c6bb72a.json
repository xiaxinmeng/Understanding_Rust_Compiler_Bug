{"sha": "63737e7a0c43a6f78c3ed5f1960a991e3c6bb72a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM3MzdlN2EwYzQzYTZmNzhjM2VkNWYxOTYwYTk5MWUzYzZiYjcyYQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-03-29T21:00:23Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-03-29T21:00:23Z"}, "message": "re PR java/52730 (Java front end emits assembly)\n\n\tPR java/52730\n\t* class.c (emit_register_classes_in_jcr_section): New function.\n\t(emit_Jv_RegisterClass_calls): New function, split out from ...\n\t(emit_register_classes): ... here. Reorganize.  Do not call\n\toutput_constant.\n\nFrom-SVN: r185977", "tree": {"sha": "ccb51ffde15012b144ac9c86e5e5b1c33f9c38ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccb51ffde15012b144ac9c86e5e5b1c33f9c38ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63737e7a0c43a6f78c3ed5f1960a991e3c6bb72a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63737e7a0c43a6f78c3ed5f1960a991e3c6bb72a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63737e7a0c43a6f78c3ed5f1960a991e3c6bb72a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63737e7a0c43a6f78c3ed5f1960a991e3c6bb72a/comments", "author": null, "committer": null, "parents": [{"sha": "d79318b79c4f0cd65a772a0175a6d6fc88be5e72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d79318b79c4f0cd65a772a0175a6d6fc88be5e72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d79318b79c4f0cd65a772a0175a6d6fc88be5e72"}], "stats": {"total": 127, "additions": 83, "deletions": 44}, "files": [{"sha": "f77f756b0daa5f1458b43181fdc11c79d742933d", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63737e7a0c43a6f78c3ed5f1960a991e3c6bb72a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63737e7a0c43a6f78c3ed5f1960a991e3c6bb72a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=63737e7a0c43a6f78c3ed5f1960a991e3c6bb72a", "patch": "@@ -1,3 +1,11 @@\n+2012-03-29  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\tPR java/52730\n+\t* class.c (emit_register_classes_in_jcr_section): New function.\n+\t(emit_Jv_RegisterClass_calls): New function, split out from ...\n+\t(emit_register_classes): ... here. Reorganize.  Do not call\n+\toutput_constant.\n+\n 2012-01-23  Andreas Schwab  <schwab@linux-m68k.org>\n \n \t* lang.c (java_init_options_struct): Set"}, {"sha": "69b00018d3fdf2f1b3a4489f35f93c2c6982e4ef", "filename": "gcc/java/class.c", "status": "modified", "additions": 75, "deletions": 44, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63737e7a0c43a6f78c3ed5f1960a991e3c6bb72a/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63737e7a0c43a6f78c3ed5f1960a991e3c6bb72a/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=63737e7a0c43a6f78c3ed5f1960a991e3c6bb72a", "patch": "@@ -2786,10 +2786,78 @@ emit_indirect_register_classes (tree *list_p)\n   append_to_statement_list (t, list_p);\n }\n \n+/* Emit a list of pointers to all classes we have emitted to JCR_SECTION.  */\n+\n+static void\n+emit_register_classes_in_jcr_section (void)\n+{\n+  tree klass, cdecl, class_array_type;\n+  int i;\n+  int size = VEC_length (tree, registered_class);\n+  VEC(constructor_elt,gc) *init = VEC_alloc (constructor_elt, gc, size);\n+\n+#ifndef JCR_SECTION_NAME\n+  /* A target has defined TARGET_USE_JCR_SECTION,\n+     but doesn't have a JCR_SECTION_NAME.  */\n+  gcc_unreachable ();\n+#endif\n+\n+  FOR_EACH_VEC_ELT (tree, registered_class, i, klass)\n+    CONSTRUCTOR_APPEND_ELT (init, NULL_TREE, build_fold_addr_expr (klass));\n+\n+  /* ??? I would like to use tree_output_constant_def() but there is no way\n+\t to put the data in a named section name, or to set the alignment,\n+\t via that function.  So do everything manually here.  */\n+  class_array_type = build_prim_array_type (ptr_type_node, size);\n+  cdecl = build_decl (UNKNOWN_LOCATION,\n+\t\t      VAR_DECL, get_identifier (\"_Jv_JCR_SECTION_data\"),\n+\t\t      class_array_type);\n+  DECL_SECTION_NAME (cdecl) = build_string (strlen (JCR_SECTION_NAME),\n+\t\t\t\t\t    JCR_SECTION_NAME);\n+  DECL_ALIGN (cdecl) = POINTER_SIZE;\n+  DECL_INITIAL (cdecl) = build_constructor (class_array_type, init);\n+  TREE_CONSTANT (DECL_INITIAL (cdecl)) = 1;\n+  TREE_STATIC (cdecl) = 1;\n+  TREE_READONLY (cdecl) = 1;\n+  TREE_CONSTANT (cdecl) = 1;\n+  DECL_ARTIFICIAL (cdecl) = 1;\n+  DECL_IGNORED_P (cdecl) = 1;\n+  pushdecl_top_level (cdecl);\n+  relayout_decl (cdecl);\n+  rest_of_decl_compilation (cdecl, 1, 0);\n+  mark_decl_referenced (cdecl);\n+}\n+\n+\n+/* Emit a series of calls to _Jv_RegisterClass for every class we emitted.\n+   A series of calls is added to LIST_P.  */\n+\n+static void\n+emit_Jv_RegisterClass_calls (tree *list_p)\n+{\n+  tree klass, t, register_class_fn;\n+  int i;\n+\n+  t = build_function_type_list (void_type_node, class_ptr_type, NULL);\n+  t = build_decl (input_location,\n+\t\t  FUNCTION_DECL, get_identifier (\"_Jv_RegisterClass\"), t);\n+  TREE_PUBLIC (t) = 1;\n+  DECL_EXTERNAL (t) = 1;\n+  register_class_fn = t;\n+\n+  FOR_EACH_VEC_ELT (tree, registered_class, i, klass)\n+    {\n+      t = build_fold_addr_expr (klass);\n+      t = build_call_expr (register_class_fn, 1, t);\n+      append_to_statement_list (t, list_p);\n+    }\n+}\n \n /* Emit something to register classes at start-up time.\n \n-   The preferred mechanism is through the .jcr section, which contain\n+   The default mechanism is to generate instances at run-time.\n+\n+   An alternative mechanism is through the .jcr section, which contain\n    a list of pointers to classes which get registered during constructor\n    invocation time.\n \n@@ -2803,55 +2871,18 @@ emit_register_classes (tree *list_p)\n   if (registered_class == NULL)\n     return;\n \n+  /* By default, generate instances of Class at runtime.  */\n   if (flag_indirect_classes)\n-    {\n-      emit_indirect_register_classes (list_p);\n-      return;\n-    }\n-\n+    emit_indirect_register_classes (list_p);\n   /* TARGET_USE_JCR_SECTION defaults to 1 if SUPPORTS_WEAK and\n      TARGET_ASM_NAMED_SECTION, else 0.  Some targets meet those conditions\n      but lack suitable crtbegin/end objects or linker support.  These\n      targets can override the default in tm.h to use the fallback mechanism.  */\n-  if (TARGET_USE_JCR_SECTION)\n-    {\n-      tree klass, t;\n-      int i;\n-\n-#ifdef JCR_SECTION_NAME\n-      switch_to_section (get_section (JCR_SECTION_NAME, SECTION_WRITE, NULL));\n-#else\n-      /* A target has defined TARGET_USE_JCR_SECTION,\n-\t but doesn't have a JCR_SECTION_NAME.  */\n-      gcc_unreachable ();\n-#endif\n-      assemble_align (POINTER_SIZE);\n-\n-      FOR_EACH_VEC_ELT (tree, registered_class, i, klass)\n-\t{\n-\t  t = build_fold_addr_expr (klass);\n-\t  output_constant (t, POINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE);\n-\t}\n-    }\n+  else if (TARGET_USE_JCR_SECTION)\n+    emit_register_classes_in_jcr_section ();\n+  /* Use the fallback mechanism.  */\n   else\n-    {\n-      tree klass, t, register_class_fn;\n-      int i;\n-\n-      t = build_function_type_list (void_type_node, class_ptr_type, NULL);\n-      t = build_decl (input_location,\n-\t\t      FUNCTION_DECL, get_identifier (\"_Jv_RegisterClass\"), t);\n-      TREE_PUBLIC (t) = 1;\n-      DECL_EXTERNAL (t) = 1;\n-      register_class_fn = t;\n-\n-      FOR_EACH_VEC_ELT (tree, registered_class, i, klass)\n-\t{\n-\t  t = build_fold_addr_expr (klass);\n-\t  t = build_call_expr (register_class_fn, 1, t);\n-\t  append_to_statement_list (t, list_p);\n-\t}\n-    }\n+    emit_Jv_RegisterClass_calls (list_p);\n }\n \n /* Build a constructor for an entry in the symbol table.  */"}]}