{"sha": "58b03ab29f5bad84af12b599a1791c65c2d01405", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThiMDNhYjI5ZjViYWQ4NGFmMTJiNTk5YTE3OTFjNjVjMmQwMTQwNQ==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2005-02-23T21:34:11Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2005-02-23T21:34:11Z"}, "message": "gfortran.h (gfc_expr): Move 'operator'...\n\n* gfortran.h (gfc_expr): Move 'operator', 'op1', 'op2', and 'uop'\nfields into new struct 'op' inside the 'value' union.\n* arith.c (eval_intrinsic): Adapt all users.\n* dependency.c (gfc_check_dependency): Likewise.\n* dump-parse-tree.c (gfc_show_expr): Likewise.\n* expr.c (gfc_get_expr): Don't clear removed fields.\n(free_expr0, gfc_copy_expr, gfc_type_convert_binary,\ngfc_is_constant_expr, simplify_intrinsic_op, check_init_expr,\ncheck_intrinsic_op): Adapt to new field names.\n* interface.c (gfc_extend_expr): Likewise.  Also explicitly\nnullify 'esym' and 'isym' fields of new function call.\n* iresolve.c (gfc_resolve_dot_product, gfc_resolve_matmul):\nAdapt to renamed structure fields.\n* matchexp.c (build_node, match_level_1, match_expr): Likewise.\n* module.c (mio_expr): Likewise.\n* resolve.c (resolve_operator): Likewise.\n(gfc_find_forall_index): Likewise.  Only look through operands\nif dealing with EXPR_OP\n* trans-array.c (gfc_walk_op_expr): Adapt to renamed fields.\n* trans-expr.c (gfc_conv_unary_op, gfc_conv_power_op,\ngfc_conv_concat_op, gfc_conv_expr_op): Likewise.\n\nFrom-SVN: r95471", "tree": {"sha": "295ec2157631e2c5540017a7c342edfea10f1458", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/295ec2157631e2c5540017a7c342edfea10f1458"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58b03ab29f5bad84af12b599a1791c65c2d01405", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58b03ab29f5bad84af12b599a1791c65c2d01405", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58b03ab29f5bad84af12b599a1791c65c2d01405", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58b03ab29f5bad84af12b599a1791c65c2d01405/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1303acd60e8f6172a9a08cf8bd413913682c040", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1303acd60e8f6172a9a08cf8bd413913682c040", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1303acd60e8f6172a9a08cf8bd413913682c040"}], "stats": {"total": 304, "additions": 168, "deletions": 136}, "files": [{"sha": "7bcb12d21c4321853863ae342fd17d993da78d6b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=58b03ab29f5bad84af12b599a1791c65c2d01405", "patch": "@@ -16,6 +16,28 @@\n \t* symbol.c (gfc_set_default_type): Issue error only once, by setting\n \tand checking 'untyped' attribute.\n \n+\t* gfortran.h (gfc_expr): Move 'operator', 'op1', 'op2', and 'uop'\n+\tfields into new struct 'op' inside the 'value' union.\n+\t* arith.c (eval_intrinsic): Adapt all users.\n+\t* dependency.c (gfc_check_dependency): Likewise.\n+\t* dump-parse-tree.c (gfc_show_expr): Likewise.\n+\t* expr.c (gfc_get_expr): Don't clear removed fields.\n+\t(free_expr0, gfc_copy_expr, gfc_type_convert_binary,\n+\tgfc_is_constant_expr, simplify_intrinsic_op, check_init_expr,\n+\tcheck_intrinsic_op): Adapt to new field names.\n+\t* interface.c (gfc_extend_expr): Likewise.  Also explicitly\n+\tnullify 'esym' and 'isym' fields of new function call.\n+\t* iresolve.c (gfc_resolve_dot_product, gfc_resolve_matmul):\n+\tAdapt to renamed structure fields.\n+\t* matchexp.c (build_node, match_level_1, match_expr): Likewise.\n+\t* module.c (mio_expr): Likewise.\n+\t* resolve.c (resolve_operator): Likewise.\n+\t(gfc_find_forall_index): Likewise.  Only look through operands\n+\tif dealing with EXPR_OP\n+\t* trans-array.c (gfc_walk_op_expr): Adapt to renamed fields.\n+\t* trans-expr.c (gfc_conv_unary_op, gfc_conv_power_op,\n+\tgfc_conv_concat_op, gfc_conv_expr_op): Likewise.\n+\n 2005-02-23  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* intrinsic.h, st.c: Update copyright."}, {"sha": "a219ed20675da11c1e1fa8d9a31b54c7d09de196", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=58b03ab29f5bad84af12b599a1791c65c2d01405", "patch": "@@ -1598,10 +1598,10 @@ eval_intrinsic (gfc_intrinsic_op operator,\n \n       temp.expr_type = EXPR_OP;\n       gfc_clear_ts (&temp.ts);\n-      temp.operator = operator;\n+      temp.value.op.operator = operator;\n \n-      temp.op1 = op1;\n-      temp.op2 = op2;\n+      temp.value.op.op1 = op1;\n+      temp.value.op.op2 = op2;\n \n       gfc_type_convert_binary (&temp);\n \n@@ -1671,10 +1671,10 @@ eval_intrinsic (gfc_intrinsic_op operator,\n   result->ts = temp.ts;\n \n   result->expr_type = EXPR_OP;\n-  result->operator = operator;\n+  result->value.op.operator = operator;\n \n-  result->op1 = op1;\n-  result->op2 = op2;\n+  result->value.op.op1 = op1;\n+  result->value.op.op2 = op2;\n \n   result->where = op1->where;\n "}, {"sha": "cb5cb50fd92915ccce9d4ac068ce60bdb3baf433", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=58b03ab29f5bad84af12b599a1791c65c2d01405", "patch": "@@ -277,11 +277,11 @@ gfc_check_dependency (gfc_expr * expr1, gfc_expr * expr2, gfc_expr ** vars,\n   switch (expr2->expr_type)\n     {\n     case EXPR_OP:\n-      n = gfc_check_dependency (expr1, expr2->op1, vars, nvars);\n+      n = gfc_check_dependency (expr1, expr2->value.op.op1, vars, nvars);\n       if (n)\n \treturn n;\n-      if (expr2->op2)\n-\treturn gfc_check_dependency (expr1, expr2->op2, vars, nvars);\n+      if (expr2->value.op.op2)\n+\treturn gfc_check_dependency (expr1, expr2->value.op.op2, vars, nvars);\n       return 0;\n \n     case EXPR_VARIABLE:"}, {"sha": "e60b4c082de2b6137f8d20ed621cd9da49827ff1", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=58b03ab29f5bad84af12b599a1791c65c2d01405", "patch": "@@ -415,7 +415,7 @@ gfc_show_expr (gfc_expr * p)\n \n     case EXPR_OP:\n       gfc_status (\"(\");\n-      switch (p->operator)\n+      switch (p->value.op.operator)\n \t{\n \tcase INTRINSIC_UPLUS:\n \t  gfc_status (\"U+ \");\n@@ -480,12 +480,12 @@ gfc_show_expr (gfc_expr * p)\n \t    (\"gfc_show_expr(): Bad intrinsic in expression!\");\n \t}\n \n-      gfc_show_expr (p->op1);\n+      gfc_show_expr (p->value.op.op1);\n \n-      if (p->op2)\n+      if (p->value.op.op2)\n \t{\n \t  gfc_status (\" \");\n-\t  gfc_show_expr (p->op2);\n+\t  gfc_show_expr (p->value.op.op2);\n \t}\n \n       gfc_status (\")\");"}, {"sha": "5867f9bfaa59517b26177237288577c5b77df228", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=58b03ab29f5bad84af12b599a1791c65c2d01405", "patch": "@@ -36,12 +36,9 @@ gfc_get_expr (void)\n   e = gfc_getmem (sizeof (gfc_expr));\n \n   gfc_clear_ts (&e->ts);\n-  e->op1 = NULL;\n-  e->op2 = NULL;\n   e->shape = NULL;\n   e->ref = NULL;\n   e->symtree = NULL;\n-  e->uop = NULL;\n \n   return e;\n }\n@@ -170,10 +167,10 @@ free_expr0 (gfc_expr * e)\n       break;\n \n     case EXPR_OP:\n-      if (e->op1 != NULL)\n-\tgfc_free_expr (e->op1);\n-      if (e->op2 != NULL)\n-\tgfc_free_expr (e->op2);\n+      if (e->value.op.op1 != NULL)\n+\tgfc_free_expr (e->value.op.op1);\n+      if (e->value.op.op2 != NULL)\n+\tgfc_free_expr (e->value.op.op2);\n       break;\n \n     case EXPR_FUNCTION:\n@@ -437,17 +434,17 @@ gfc_copy_expr (gfc_expr * p)\n       break;\n \n     case EXPR_OP:\n-      switch (q->operator)\n+      switch (q->value.op.operator)\n \t{\n \tcase INTRINSIC_NOT:\n \tcase INTRINSIC_UPLUS:\n \tcase INTRINSIC_UMINUS:\n-\t  q->op1 = gfc_copy_expr (p->op1);\n+\t  q->value.op.op1 = gfc_copy_expr (p->value.op.op1);\n \t  break;\n \n \tdefault:\t\t/* Binary operators */\n-\t  q->op1 = gfc_copy_expr (p->op1);\n-\t  q->op2 = gfc_copy_expr (p->op2);\n+\t  q->value.op.op1 = gfc_copy_expr (p->value.op.op1);\n+\t  q->value.op.op2 = gfc_copy_expr (p->value.op.op2);\n \t  break;\n \t}\n \n@@ -584,8 +581,8 @@ gfc_type_convert_binary (gfc_expr * e)\n {\n   gfc_expr *op1, *op2;\n \n-  op1 = e->op1;\n-  op2 = e->op2;\n+  op1 = e->value.op.op1;\n+  op2 = e->value.op.op2;\n \n   if (op1->ts.type == BT_UNKNOWN || op2->ts.type == BT_UNKNOWN)\n     {\n@@ -619,17 +616,17 @@ gfc_type_convert_binary (gfc_expr * e)\n       e->ts = op1->ts;\n \n       /* Special case for ** operator.  */\n-      if (e->operator == INTRINSIC_POWER)\n+      if (e->value.op.operator == INTRINSIC_POWER)\n \tgoto done;\n \n-      gfc_convert_type (e->op2, &e->ts, 2);\n+      gfc_convert_type (e->value.op.op2, &e->ts, 2);\n       goto done;\n     }\n \n   if (op1->ts.type == BT_INTEGER)\n     {\n       e->ts = op2->ts;\n-      gfc_convert_type (e->op1, &e->ts, 2);\n+      gfc_convert_type (e->value.op.op1, &e->ts, 2);\n       goto done;\n     }\n \n@@ -640,9 +637,9 @@ gfc_type_convert_binary (gfc_expr * e)\n   else\n     e->ts.kind = op2->ts.kind;\n   if (op1->ts.type != BT_COMPLEX || op1->ts.kind != e->ts.kind)\n-    gfc_convert_type (e->op1, &e->ts, 2);\n+    gfc_convert_type (e->value.op.op1, &e->ts, 2);\n   if (op2->ts.type != BT_COMPLEX || op2->ts.kind != e->ts.kind)\n-    gfc_convert_type (e->op2, &e->ts, 2);\n+    gfc_convert_type (e->value.op.op2, &e->ts, 2);\n \n done:\n   return;\n@@ -665,9 +662,9 @@ gfc_is_constant_expr (gfc_expr * e)\n   switch (e->expr_type)\n     {\n     case EXPR_OP:\n-      rv = (gfc_is_constant_expr (e->op1)\n-\t    && (e->op2 == NULL\n-\t\t|| gfc_is_constant_expr (e->op2)));\n+      rv = (gfc_is_constant_expr (e->value.op.op1)\n+\t    && (e->value.op.op2 == NULL\n+\t\t|| gfc_is_constant_expr (e->value.op.op2)));\n \n       break;\n \n@@ -729,11 +726,11 @@ simplify_intrinsic_op (gfc_expr * p, int type)\n {\n   gfc_expr *op1, *op2, *result;\n \n-  if (p->operator == INTRINSIC_USER)\n+  if (p->value.op.operator == INTRINSIC_USER)\n     return SUCCESS;\n \n-  op1 = p->op1;\n-  op2 = p->op2;\n+  op1 = p->value.op.op1;\n+  op2 = p->value.op.op2;\n \n   if (gfc_simplify_expr (op1, type) == FAILURE)\n     return FAILURE;\n@@ -745,10 +742,10 @@ simplify_intrinsic_op (gfc_expr * p, int type)\n     return SUCCESS;\n \n   /* Rip p apart */\n-  p->op1 = NULL;\n-  p->op2 = NULL;\n+  p->value.op.op1 = NULL;\n+  p->value.op.op2 = NULL;\n \n-  switch (p->operator)\n+  switch (p->value.op.operator)\n     {\n     case INTRINSIC_UPLUS:\n       result = gfc_uplus (op1);\n@@ -1191,15 +1188,17 @@ static try check_init_expr (gfc_expr *);\n static try\n check_intrinsic_op (gfc_expr * e, try (*check_function) (gfc_expr *))\n {\n+  gfc_expr *op1 = e->value.op.op1;\n+  gfc_expr *op2 = e->value.op.op2;\n \n-  if ((*check_function) (e->op1) == FAILURE)\n+  if ((*check_function) (op1) == FAILURE)\n     return FAILURE;\n \n-  switch (e->operator)\n+  switch (e->value.op.operator)\n     {\n     case INTRINSIC_UPLUS:\n     case INTRINSIC_UMINUS:\n-      if (!numeric_type (et0 (e->op1)))\n+      if (!numeric_type (et0 (op1)))\n \tgoto not_numeric;\n       break;\n \n@@ -1209,11 +1208,11 @@ check_intrinsic_op (gfc_expr * e, try (*check_function) (gfc_expr *))\n     case INTRINSIC_GE:\n     case INTRINSIC_LT:\n     case INTRINSIC_LE:\n-      if ((*check_function) (e->op2) == FAILURE)\n+      if ((*check_function) (op2) == FAILURE)\n \treturn FAILURE;\n       \n-      if (!(et0 (e->op1) == BT_CHARACTER && et0 (e->op2) == BT_CHARACTER)\n-\t  && !(numeric_type (et0 (e->op1)) && numeric_type (et0 (e->op2))))\n+      if (!(et0 (op1) == BT_CHARACTER && et0 (op2) == BT_CHARACTER)\n+\t  && !(numeric_type (et0 (op1)) && numeric_type (et0 (op2))))\n \t{\n \t  gfc_error (\"Numeric or CHARACTER operands are required in \"\n \t\t     \"expression at %L\", &e->where);\n@@ -1226,34 +1225,34 @@ check_intrinsic_op (gfc_expr * e, try (*check_function) (gfc_expr *))\n     case INTRINSIC_TIMES:\n     case INTRINSIC_DIVIDE:\n     case INTRINSIC_POWER:\n-      if ((*check_function) (e->op2) == FAILURE)\n+      if ((*check_function) (op2) == FAILURE)\n \treturn FAILURE;\n \n-      if (!numeric_type (et0 (e->op1)) || !numeric_type (et0 (e->op2)))\n+      if (!numeric_type (et0 (op1)) || !numeric_type (et0 (op2)))\n \tgoto not_numeric;\n \n-      if (e->operator == INTRINSIC_POWER\n-\t  && check_function == check_init_expr && et0 (e->op2) != BT_INTEGER)\n+      if (e->value.op.operator == INTRINSIC_POWER\n+\t  && check_function == check_init_expr && et0 (op2) != BT_INTEGER)\n \t{\n \t  gfc_error (\"Exponent at %L must be INTEGER for an initialization \"\n-\t\t     \"expression\", &e->op2->where);\n+\t\t     \"expression\", &op2->where);\n \t  return FAILURE;\n \t}\n \n       break;\n \n     case INTRINSIC_CONCAT:\n-      if ((*check_function) (e->op2) == FAILURE)\n+      if ((*check_function) (op2) == FAILURE)\n \treturn FAILURE;\n \n-      if (et0 (e->op1) != BT_CHARACTER || et0 (e->op2) != BT_CHARACTER)\n+      if (et0 (op1) != BT_CHARACTER || et0 (op2) != BT_CHARACTER)\n \t{\n \t  gfc_error (\"Concatenation operator in expression at %L \"\n-\t\t     \"must have two CHARACTER operands\", &e->op1->where);\n+\t\t     \"must have two CHARACTER operands\", &op1->where);\n \t  return FAILURE;\n \t}\n \n-      if (e->op1->ts.kind != e->op2->ts.kind)\n+      if (op1->ts.kind != op2->ts.kind)\n \t{\n \t  gfc_error (\"Concat operator at %L must concatenate strings of the \"\n \t\t     \"same kind\", &e->where);\n@@ -1263,10 +1262,10 @@ check_intrinsic_op (gfc_expr * e, try (*check_function) (gfc_expr *))\n       break;\n \n     case INTRINSIC_NOT:\n-      if (et0 (e->op1) != BT_LOGICAL)\n+      if (et0 (op1) != BT_LOGICAL)\n \t{\n \t  gfc_error (\".NOT. operator in expression at %L must have a LOGICAL \"\n-\t\t     \"operand\", &e->op1->where);\n+\t\t     \"operand\", &op1->where);\n \t  return FAILURE;\n \t}\n \n@@ -1276,10 +1275,10 @@ check_intrinsic_op (gfc_expr * e, try (*check_function) (gfc_expr *))\n     case INTRINSIC_OR:\n     case INTRINSIC_EQV:\n     case INTRINSIC_NEQV:\n-      if ((*check_function) (e->op2) == FAILURE)\n+      if ((*check_function) (op2) == FAILURE)\n \treturn FAILURE;\n \n-      if (et0 (e->op1) != BT_LOGICAL || et0 (e->op2) != BT_LOGICAL)\n+      if (et0 (op1) != BT_LOGICAL || et0 (op2) != BT_LOGICAL)\n \t{\n \t  gfc_error (\"LOGICAL operands are required in expression at %L\",\n \t\t     &e->where);"}, {"sha": "eb24cba4a8b7669e603b8b09d55f8170fed5085e", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=58b03ab29f5bad84af12b599a1791c65c2d01405", "patch": "@@ -1044,15 +1044,11 @@ typedef struct gfc_expr\n   int rank;\n   mpz_t *shape;\t\t/* Can be NULL if shape is unknown at compile time */\n \n-  gfc_intrinsic_op operator;\n-\n   /* Nonnull for functions and structure constructors */\n   gfc_symtree *symtree;\n \n-  gfc_user_op *uop;\n   gfc_ref *ref;\n \n-  struct gfc_expr *op1, *op2;\n   locus where;\n \n   union\n@@ -1068,6 +1064,14 @@ typedef struct gfc_expr\n     }\n     complex;\n \n+    struct\n+    {\n+      gfc_intrinsic_op operator;\n+      gfc_user_op *uop;\n+      struct gfc_expr *op1, *op2;\n+    }\n+    op;\n+\n     struct\n     {\n       gfc_actual_arglist *actual;"}, {"sha": "9f163d0efd2f7d1b0ff2a3775ef63a8c0b2fa1f7", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=58b03ab29f5bad84af12b599a1791c65c2d01405", "patch": "@@ -1640,21 +1640,21 @@ gfc_extend_expr (gfc_expr * e)\n   sym = NULL;\n \n   actual = gfc_get_actual_arglist ();\n-  actual->expr = e->op1;\n+  actual->expr = e->value.op.op1;\n \n-  if (e->op2 != NULL)\n+  if (e->value.op.op2 != NULL)\n     {\n       actual->next = gfc_get_actual_arglist ();\n-      actual->next->expr = e->op2;\n+      actual->next->expr = e->value.op.op2;\n     }\n \n-  i = fold_unary (e->operator);\n+  i = fold_unary (e->value.op.operator);\n \n   if (i == INTRINSIC_USER)\n     {\n       for (ns = gfc_current_ns; ns; ns = ns->parent)\n \t{\n-\t  uop = gfc_find_uop (e->uop->name, ns);\n+\t  uop = gfc_find_uop (e->value.op.uop->name, ns);\n \t  if (uop == NULL)\n \t    continue;\n \n@@ -1687,6 +1687,8 @@ gfc_extend_expr (gfc_expr * e)\n   e->expr_type = EXPR_FUNCTION;\n   e->symtree = find_sym_in_symtree (sym);\n   e->value.function.actual = actual;\n+  e->value.function.esym = NULL;\n+  e->value.function.isym = NULL;\n \n   if (gfc_pure (NULL) && !gfc_pure (sym))\n     {"}, {"sha": "9a30b7df2e160b87dc562a28d32bf27466fcbf7d", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=58b03ab29f5bad84af12b599a1791c65c2d01405", "patch": "@@ -383,9 +383,9 @@ gfc_resolve_dot_product (gfc_expr * f, gfc_expr * a, gfc_expr * b)\n     {\n       temp.expr_type = EXPR_OP;\n       gfc_clear_ts (&temp.ts);\n-      temp.operator = INTRINSIC_NONE;\n-      temp.op1 = a;\n-      temp.op2 = b;\n+      temp.value.op.operator = INTRINSIC_NONE;\n+      temp.value.op.op1 = a;\n+      temp.value.op.op2 = b;\n       gfc_type_convert_binary (&temp);\n       f->ts = temp.ts;\n     }\n@@ -753,9 +753,9 @@ gfc_resolve_matmul (gfc_expr * f, gfc_expr * a, gfc_expr * b)\n     {\n       temp.expr_type = EXPR_OP;\n       gfc_clear_ts (&temp.ts);\n-      temp.operator = INTRINSIC_NONE;\n-      temp.op1 = a;\n-      temp.op2 = b;\n+      temp.value.op.operator = INTRINSIC_NONE;\n+      temp.value.op.op1 = a;\n+      temp.value.op.op2 = b;\n       gfc_type_convert_binary (&temp);\n       f->ts = temp.ts;\n     }"}, {"sha": "04fd31f3609ad6a180400e5288606dda9c20062d", "filename": "gcc/fortran/matchexp.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Fmatchexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Fmatchexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatchexp.c?ref=58b03ab29f5bad84af12b599a1791c65c2d01405", "patch": "@@ -179,11 +179,11 @@ build_node (gfc_intrinsic_op operator, locus * where,\n \n   new = gfc_get_expr ();\n   new->expr_type = EXPR_OP;\n-  new->operator = operator;\n+  new->value.op.operator = operator;\n   new->where = *where;\n \n-  new->op1 = op1;\n-  new->op2 = op2;\n+  new->value.op.op1 = op1;\n+  new->value.op.op2 = op2;\n \n   return new;\n }\n@@ -214,7 +214,7 @@ match_level_1 (gfc_expr ** result)\n   else\n     {\n       f = build_node (INTRINSIC_USER, &where, e, NULL);\n-      f->uop = uop;\n+      f->value.op.uop = uop;\n       *result = f;\n     }\n \n@@ -873,7 +873,7 @@ gfc_match_expr (gfc_expr ** result)\n \t}\n \n       all = build_node (INTRINSIC_USER, &where, all, e);\n-      all->uop = uop;\n+      all->value.op.uop = uop;\n     }\n \n   *result = all;"}, {"sha": "8df1b9adf63af6c72efb798343414cb5c8f1777a", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=58b03ab29f5bad84af12b599a1791c65c2d01405", "patch": "@@ -2404,14 +2404,15 @@ mio_expr (gfc_expr ** ep)\n   switch (e->expr_type)\n     {\n     case EXPR_OP:\n-      e->operator = MIO_NAME(gfc_intrinsic_op) (e->operator, intrinsics);\n+      e->value.op.operator\n+\t= MIO_NAME(gfc_intrinsic_op) (e->value.op.operator, intrinsics);\n \n-      switch (e->operator)\n+      switch (e->value.op.operator)\n \t{\n \tcase INTRINSIC_UPLUS:\n \tcase INTRINSIC_UMINUS:\n \tcase INTRINSIC_NOT:\n-\t  mio_expr (&e->op1);\n+\t  mio_expr (&e->value.op.op1);\n \t  break;\n \n \tcase INTRINSIC_PLUS:\n@@ -2430,8 +2431,8 @@ mio_expr (gfc_expr ** ep)\n \tcase INTRINSIC_GE:\n \tcase INTRINSIC_LT:\n \tcase INTRINSIC_LE:\n-\t  mio_expr (&e->op1);\n-\t  mio_expr (&e->op2);\n+\t  mio_expr (&e->value.op.op1);\n+\t  mio_expr (&e->value.op.op2);\n \t  break;\n \n \tdefault:"}, {"sha": "ecbd89ddfbc3fd0172987cd88074f46306517b05", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=58b03ab29f5bad84af12b599a1791c65c2d01405", "patch": "@@ -1262,28 +1262,28 @@ resolve_operator (gfc_expr * e)\n \n   /* Resolve all subnodes-- give them types.  */\n \n-  switch (e->operator)\n+  switch (e->value.op.operator)\n     {\n     default:\n-      if (gfc_resolve_expr (e->op2) == FAILURE)\n+      if (gfc_resolve_expr (e->value.op.op2) == FAILURE)\n \treturn FAILURE;\n \n     /* Fall through...  */\n \n     case INTRINSIC_NOT:\n     case INTRINSIC_UPLUS:\n     case INTRINSIC_UMINUS:\n-      if (gfc_resolve_expr (e->op1) == FAILURE)\n+      if (gfc_resolve_expr (e->value.op.op1) == FAILURE)\n \treturn FAILURE;\n       break;\n     }\n \n   /* Typecheck the new node.  */\n \n-  op1 = e->op1;\n-  op2 = e->op2;\n+  op1 = e->value.op.op1;\n+  op2 = e->value.op.op2;\n \n-  switch (e->operator)\n+  switch (e->value.op.operator)\n     {\n     case INTRINSIC_UPLUS:\n     case INTRINSIC_UMINUS:\n@@ -1296,7 +1296,7 @@ resolve_operator (gfc_expr * e)\n \t}\n \n       sprintf (msg, \"Operand of unary numeric operator '%s' at %%L is %s\",\n-\t       gfc_op2string (e->operator), gfc_typename (&e->ts));\n+\t       gfc_op2string (e->value.op.operator), gfc_typename (&e->ts));\n       goto bad_op;\n \n     case INTRINSIC_PLUS:\n@@ -1312,7 +1312,7 @@ resolve_operator (gfc_expr * e)\n \n       sprintf (msg,\n \t       \"Operands of binary numeric operator '%s' at %%L are %s/%s\",\n-\t       gfc_op2string (e->operator), gfc_typename (&op1->ts),\n+\t       gfc_op2string (e->value.op.operator), gfc_typename (&op1->ts),\n \t       gfc_typename (&op2->ts));\n       goto bad_op;\n \n@@ -1345,7 +1345,7 @@ resolve_operator (gfc_expr * e)\n \t}\n \n       sprintf (msg, \"Operands of logical operator '%s' at %%L are %s/%s\",\n-\t       gfc_op2string (e->operator), gfc_typename (&op1->ts),\n+\t       gfc_op2string (e->value.op.operator), gfc_typename (&op1->ts),\n \t       gfc_typename (&op2->ts));\n \n       goto bad_op;\n@@ -1393,18 +1393,18 @@ resolve_operator (gfc_expr * e)\n \t}\n \n       sprintf (msg, \"Operands of comparison operator '%s' at %%L are %s/%s\",\n-\t       gfc_op2string (e->operator), gfc_typename (&op1->ts),\n+\t       gfc_op2string (e->value.op.operator), gfc_typename (&op1->ts),\n \t       gfc_typename (&op2->ts));\n \n       goto bad_op;\n \n     case INTRINSIC_USER:\n       if (op2 == NULL)\n \tsprintf (msg, \"Operand of user operator '%s' at %%L is %s\",\n-\t\t e->uop->name, gfc_typename (&op1->ts));\n+\t\t e->value.op.uop->name, gfc_typename (&op1->ts));\n       else\n \tsprintf (msg, \"Operands of user operator '%s' at %%L are %s/%s\",\n-\t\t e->uop->name, gfc_typename (&op1->ts),\n+\t\t e->value.op.uop->name, gfc_typename (&op1->ts),\n \t\t gfc_typename (&op2->ts));\n \n       goto bad_op;\n@@ -1417,7 +1417,7 @@ resolve_operator (gfc_expr * e)\n \n   t = SUCCESS;\n \n-  switch (e->operator)\n+  switch (e->value.op.operator)\n     {\n     case INTRINSIC_PLUS:\n     case INTRINSIC_MINUS:\n@@ -3327,23 +3327,27 @@ gfc_find_forall_index (gfc_expr *expr, gfc_symbol *symbol)\n       gfc_error (\"Unsupported statement while finding forall index in \"\n                  \"expression\");\n       break;\n-    default:\n+\n+    case EXPR_OP:\n+      /* Find the FORALL index in the first operand.  */\n+      if (expr->value.op.op1)\n+\t{\n+\t  if (gfc_find_forall_index (expr->value.op.op1, symbol) == SUCCESS)\n+\t    return SUCCESS;\n+\t}\n+\n+      /* Find the FORALL index in the second operand.  */\n+      if (expr->value.op.op2)\n+\t{\n+\t  if (gfc_find_forall_index (expr->value.op.op2, symbol) == SUCCESS)\n+\t    return SUCCESS;\n+\t}\n       break;\n-    }\n \n-  /* Find the FORALL index in the first operand.  */\n-  if (expr->op1)\n-    {\n-      if (gfc_find_forall_index (expr->op1, symbol) == SUCCESS)\n-        return SUCCESS;\n+    default:\n+      break;\n     }\n \n-  /* Find the FORALL index in the second operand.  */\n-  if (expr->op2)\n-    {\n-      if (gfc_find_forall_index (expr->op2, symbol) == SUCCESS)\n-        return SUCCESS;\n-    }\n   return FAILURE;\n }\n "}, {"sha": "985abd478360986c427510b82d6cc34d9cc89a32", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=58b03ab29f5bad84af12b599a1791c65c2d01405", "patch": "@@ -4194,18 +4194,18 @@ gfc_walk_op_expr (gfc_ss * ss, gfc_expr * expr)\n   gfc_ss *head2;\n   gfc_ss *newss;\n \n-  head = gfc_walk_subexpr (ss, expr->op1);\n-  if (expr->op2 == NULL)\n+  head = gfc_walk_subexpr (ss, expr->value.op.op1);\n+  if (expr->value.op.op2 == NULL)\n     head2 = head;\n   else\n-    head2 = gfc_walk_subexpr (head, expr->op2);\n+    head2 = gfc_walk_subexpr (head, expr->value.op.op2);\n \n   /* All operands are scalar.  Pass back and let the caller deal with it.  */\n   if (head2 == ss)\n     return head2;\n \n   /* All operands require scalarization.  */\n-  if (head != ss && (expr->op2 == NULL || head2 != head))\n+  if (head != ss && (expr->value.op.op2 == NULL || head2 != head))\n     return head2;\n \n   /* One of the operands needs scalarization, the other is scalar.\n@@ -4223,15 +4223,15 @@ gfc_walk_op_expr (gfc_ss * ss, gfc_expr * expr)\n       gcc_assert (head);\n       newss->next = ss;\n       head->next = newss;\n-      newss->expr = expr->op1;\n+      newss->expr = expr->value.op.op1;\n     }\n   else\t\t\t\t/* head2 == head */\n     {\n       gcc_assert (head2 == head);\n       /* Second operand is scalar.  */\n       newss->next = head2;\n       head2 = newss;\n-      newss->expr = expr->op2;\n+      newss->expr = expr->value.op.op2;\n     }\n \n   return head2;"}, {"sha": "685a9f97f9e796e3e7942f34ecc74a4ef4c788f9", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58b03ab29f5bad84af12b599a1791c65c2d01405/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=58b03ab29f5bad84af12b599a1791c65c2d01405", "patch": "@@ -414,7 +414,7 @@ gfc_conv_unary_op (enum tree_code code, gfc_se * se, gfc_expr * expr)\n   gcc_assert (expr->ts.type != BT_CHARACTER);\n   /* Initialize the operand.  */\n   gfc_init_se (&operand, se);\n-  gfc_conv_expr_val (&operand, expr->op1);\n+  gfc_conv_expr_val (&operand, expr->value.op.op1);\n   gfc_add_block_to_block (&se->pre, &operand.pre);\n \n   type = gfc_typenode_for_spec (&expr->ts);\n@@ -607,25 +607,25 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n   tree tmp;\n \n   gfc_init_se (&lse, se);\n-  gfc_conv_expr_val (&lse, expr->op1);\n+  gfc_conv_expr_val (&lse, expr->value.op.op1);\n   gfc_add_block_to_block (&se->pre, &lse.pre);\n \n   gfc_init_se (&rse, se);\n-  gfc_conv_expr_val (&rse, expr->op2);\n+  gfc_conv_expr_val (&rse, expr->value.op.op2);\n   gfc_add_block_to_block (&se->pre, &rse.pre);\n \n-  if (expr->op2->ts.type == BT_INTEGER\n-\t && expr->op2->expr_type == EXPR_CONSTANT)\n+  if (expr->value.op.op2->ts.type == BT_INTEGER\n+\t && expr->value.op.op2->expr_type == EXPR_CONSTANT)\n     if (gfc_conv_cst_int_power (se, lse.expr, rse.expr))\n       return;        \n \n   gfc_int4_type_node = gfc_get_int_type (4);\n \n-  kind = expr->op1->ts.kind;\n-  switch (expr->op2->ts.type)\n+  kind = expr->value.op.op1->ts.kind;\n+  switch (expr->value.op.op2->ts.type)\n     {\n     case BT_INTEGER:\n-      ikind = expr->op2->ts.kind;\n+      ikind = expr->value.op.op2->ts.kind;\n       switch (ikind)\n \t{\n \tcase 1:\n@@ -648,7 +648,7 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \t{\n \tcase 1:\n \tcase 2:\n-\t  if (expr->op1->ts.type == BT_INTEGER)\n+\t  if (expr->value.op.op1->ts.type == BT_INTEGER)\n \t    lse.expr = convert (gfc_int4_type_node, lse.expr);\n \t  else\n \t    gcc_unreachable ();\n@@ -666,7 +666,7 @@ gfc_conv_power_op (gfc_se * se, gfc_expr * expr)\n \t  gcc_unreachable ();\n \t}\n       \n-      switch (expr->op1->ts.type)\n+      switch (expr->value.op.op1->ts.type)\n \t{\n \tcase BT_INTEGER:\n \t  fndecl = gfor_fndecl_math_powi[kind][ikind].integer;\n@@ -780,14 +780,14 @@ gfc_conv_concat_op (gfc_se * se, gfc_expr * expr)\n   tree args;\n   tree tmp;\n \n-  gcc_assert (expr->op1->ts.type == BT_CHARACTER\n-\t  && expr->op2->ts.type == BT_CHARACTER);\n+  gcc_assert (expr->value.op.op1->ts.type == BT_CHARACTER\n+\t  && expr->value.op.op2->ts.type == BT_CHARACTER);\n \n   gfc_init_se (&lse, se);\n-  gfc_conv_expr (&lse, expr->op1);\n+  gfc_conv_expr (&lse, expr->value.op.op1);\n   gfc_conv_string_parameter (&lse);\n   gfc_init_se (&rse, se);\n-  gfc_conv_expr (&rse, expr->op2);\n+  gfc_conv_expr (&rse, expr->value.op.op2);\n   gfc_conv_string_parameter (&rse);\n \n   gfc_add_block_to_block (&se->pre, &lse.pre);\n@@ -846,10 +846,10 @@ gfc_conv_expr_op (gfc_se * se, gfc_expr * expr)\n \n   checkstring = 0;\n   lop = 0;\n-  switch (expr->operator)\n+  switch (expr->value.op.operator)\n     {\n     case INTRINSIC_UPLUS:\n-      gfc_conv_expr (se, expr->op1);\n+      gfc_conv_expr (se, expr->value.op.op1);\n       return;\n \n     case INTRINSIC_UMINUS:\n@@ -951,19 +951,19 @@ gfc_conv_expr_op (gfc_se * se, gfc_expr * expr)\n     }\n \n   /* The only exception to this is **, which is handled separately anyway.  */\n-  gcc_assert (expr->op1->ts.type == expr->op2->ts.type);\n+  gcc_assert (expr->value.op.op1->ts.type == expr->value.op.op2->ts.type);\n \n-  if (checkstring && expr->op1->ts.type != BT_CHARACTER)\n+  if (checkstring && expr->value.op.op1->ts.type != BT_CHARACTER)\n     checkstring = 0;\n \n   /* lhs */\n   gfc_init_se (&lse, se);\n-  gfc_conv_expr (&lse, expr->op1);\n+  gfc_conv_expr (&lse, expr->value.op.op1);\n   gfc_add_block_to_block (&se->pre, &lse.pre);\n \n   /* rhs */\n   gfc_init_se (&rse, se);\n-  gfc_conv_expr (&rse, expr->op2);\n+  gfc_conv_expr (&rse, expr->value.op.op2);\n   gfc_add_block_to_block (&se->pre, &rse.pre);\n \n   /* For string comparisons we generate a library call, and compare the return"}]}