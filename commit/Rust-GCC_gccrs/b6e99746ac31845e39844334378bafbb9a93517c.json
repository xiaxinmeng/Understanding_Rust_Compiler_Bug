{"sha": "b6e99746ac31845e39844334378bafbb9a93517c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZlOTk3NDZhYzMxODQ1ZTM5ODQ0MzM0Mzc4YmFmYmI5YTkzNTE3Yw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2008-07-01T08:54:18Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2008-07-01T08:54:18Z"}, "message": "Makefile.in (tree-switch-conversion.o): Add.\n\n2008-07-01  Martin Jambor  <mjambor@suse.cz>\n        * Makefile.in (tree-switch-conversion.o): Add.\n        (OBJS-common): Add tree-swtch-conversion.o.\n        * passes.c (init_optimization_passes): Add pass_convert_switch.\n        * tree-pass.h: (pass_convert_switch): Add.\n        * tree-switch-conversion.c: New file.\n        * gcc.dg/tree-ssa/cswtch.c: New testcase.\n        * common.opt (ftree-cswtch): New option.\n        * params.h (PARAM_SWITCH_CONVERSION_BRANCH_RATIO): New parameter.\n        * params.def (PARAM_SWITCH_CONVERSION_BRANCH_RATIO): New parameter.\n        * opts.c (decode_options): Set flag_tree_switch_conversion when\n        optimization level is >= 2.\n        * doc/invoke.texi (Optimize Options): Added description of\n        -ftree-swtch-conversion and switch-conversion-max-branch-ratio.\n\nFrom-SVN: r137313", "tree": {"sha": "2ae1175a480037017dac3b9663128e1be4517a06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ae1175a480037017dac3b9663128e1be4517a06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6e99746ac31845e39844334378bafbb9a93517c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6e99746ac31845e39844334378bafbb9a93517c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6e99746ac31845e39844334378bafbb9a93517c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6e99746ac31845e39844334378bafbb9a93517c/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ab652c72359fdd40b5a679e73802e377fe0aa824", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab652c72359fdd40b5a679e73802e377fe0aa824", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab652c72359fdd40b5a679e73802e377fe0aa824"}], "stats": {"total": 1017, "additions": 1013, "deletions": 4}, "files": [{"sha": "7084a420517b0f20931ab2e63ee7172b59679b3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6e99746ac31845e39844334378bafbb9a93517c", "patch": "@@ -1,3 +1,18 @@\n+2008-07-01  Martin Jambor  <mjambor@suse.cz>\n+        * Makefile.in (tree-switch-conversion.o): Add.\n+        (OBJS-common): Add tree-swtch-conversion.o.\n+        * passes.c (init_optimization_passes): Add pass_convert_switch.\n+        * tree-pass.h: (pass_convert_switch): Add.\n+        * tree-switch-conversion.c: New file.\n+        * gcc.dg/tree-ssa/cswtch.c: New testcase.\n+        * common.opt (ftree-cswtch): New option.\n+        * params.h (PARAM_SWITCH_CONVERSION_BRANCH_RATIO): New parameter.\n+        * params.def (PARAM_SWITCH_CONVERSION_BRANCH_RATIO): New parameter.\n+        * opts.c (decode_options): Set flag_tree_switch_conversion when\n+        optimization level is >= 2.\n+        * doc/invoke.texi (Optimize Options): Added description of\n+        -ftree-swtch-conversion and switch-conversion-max-branch-ratio.\n+\n 2008-06-30  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* config/darwin-driver.c (darwin_default_min_version): Fix"}, {"sha": "a792144449a311e0b68ebb0661417dcc799d43cf", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b6e99746ac31845e39844334378bafbb9a93517c", "patch": "@@ -1176,6 +1176,7 @@ OBJS-common = \\\n \ttree-profile.o \\\n \ttree-scalar-evolution.o \\\n \ttree-sra.o \\\n+\ttree-switch-conversion.o \\\n \ttree-ssa-address.o \\\n \ttree-ssa-alias.o \\\n \ttree-ssa-alias-warnings.o \\\n@@ -2629,6 +2630,11 @@ tree-sra.o : tree-sra.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) \\\n     $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_GIMPLE_H) \\\n     langhooks.h tree-pass.h $(FLAGS_H) $(EXPR_H) $(BASIC_BLOCK_H) \\\n     bitmap.h $(GGC_H) hard-reg-set.h $(OBSTACK_H) $(PARAMS_H) $(TARGET_H)\n+tree-switch-conversion.o : tree-switch-conversion.c $(CONFIG_H) $(SYSTEM_H) \\\n+    $(TREE_H) $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TREE_INLINE_H) \\\n+    $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_GIMPLE_H) \\\n+    tree-pass.h $(FLAGS_H) $(EXPR_H) $(BASIC_BLOCK_H) output.h \\\n+    $(GGC_H) $(OBSTACK_H) $(PARAMS_H) $(CPPLIB_H) $(PARAMS_H)\n tree-complex.o : tree-complex.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n     $(TM_H) $(RTL_H) $(REAL_H) $(FLAGS_H) $(TREE_FLOW_H) $(TREE_GIMPLE_H) \\\n     tree-iterator.h tree-pass.h tree-ssa-propagate.h $(DIAGNOSTIC_H)"}, {"sha": "200425d3128bdd0a1290735d7b759163276f6193", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=b6e99746ac31845e39844334378bafbb9a93517c", "patch": "@@ -1088,6 +1088,10 @@ ftree-cselim\n Common Report Var(flag_tree_cselim) Init(2) Optimization\n Transform condition stores into unconditional ones\n \n+ftree-switch-conversion\n+Common Report Var(flag_tree_switch_conversion) Optimization\n+Perform conversions of switch initializations.\n+\n ftree-dce\n Common Report Var(flag_tree_dce) Optimization\n Enable SSA dead code elimination optimization on trees"}, {"sha": "ee3b1c17915e40556c1407b34c079e0563340117", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b6e99746ac31845e39844334378bafbb9a93517c", "patch": "@@ -359,10 +359,10 @@ Objective-C and Objective-C++ Dialects}.\n -ftree-loop-distribution @gol\n -ftree-loop-ivcanon -ftree-loop-linear -ftree-loop-optimize @gol\n -ftree-parallelize-loops=@var{n} -ftree-pre -ftree-reassoc @gol\n--ftree-sink -ftree-sra -ftree-store-ccp -ftree-ter @gol\n--ftree-vect-loop-version -ftree-vectorize -ftree-vrp -funit-at-a-time @gol\n--funroll-all-loops -funroll-loops -funsafe-loop-optimizations @gol\n--funsafe-math-optimizations -funswitch-loops @gol\n+-ftree-sink -ftree-sra -ftree-store-ccp -ftree-switch-conversion @gol\n+-ftree-ter -ftree-vect-loop-version -ftree-vectorize -ftree-vrp @gol\n+-funit-at-a-time -funroll-all-loops -funroll-loops @gol\n+-funsafe-loop-optimizations -funsafe-math-optimizations -funswitch-loops @gol\n -fvariable-expansion-in-unroller -fvect-cost-model -fvpt -fweb @gol\n -fwhole-program @gol\n --param @var{name}=@var{value}\n@@ -5194,6 +5194,7 @@ also turns on the following optimization flags:\n -fsched-interblock  -fsched-spec @gol\n -fschedule-insns  -fschedule-insns2 @gol\n -fstrict-aliasing -fstrict-overflow @gol\n+-ftree-switch-conversion @gol\n -ftree-pre @gol\n -ftree-vrp}\n \n@@ -5868,6 +5869,11 @@ pass operates on both local scalar variables and memory stores and\n loads (global variables, structures, arrays, etc).  This flag is\n enabled by default at @option{-O2} and higher.\n \n+@item -ftree-switch-conversion\n+Perform conversion of simple initializations in a switch to\n+initializations from a scalar array.  This flag is enabled by default\n+at @option{-O2} and higher.\n+\n @item -ftree-dce\n @opindex ftree-dce\n Perform dead code elimination (DCE) on trees.  This flag is enabled by\n@@ -7344,6 +7350,11 @@ mechanism for comparing types in C++ and Objective-C++.  However, if\n bugs in the canonical type system are causing compilation failures,\n set this value to 0 to disable canonical types.\n \n+@item switch-conversion-max-branch-ratio\n+Switch initialization conversion will refuse to create arrays that are\n+bigger than @option{cswtch-max-branch-ratio} times the number of\n+branches in the switch.\n+\n @item max-partial-antic-length\n Maximum length of the partial antic set computed during the tree\n partial redundancy elimination optimization (@option{-ftree-pre}) when"}, {"sha": "0bea9e4e94ba090a709c961e3f576e61a0d87a1d", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=b6e99746ac31845e39844334378bafbb9a93517c", "patch": "@@ -891,6 +891,7 @@ decode_options (unsigned int argc, const char **argv)\n       flag_reorder_functions = 1;\n       flag_tree_store_ccp = 1;\n       flag_tree_vrp = 1;\n+      flag_tree_switch_conversion = 1;\n \n       if (!optimize_size)\n \t{"}, {"sha": "d1f8fcec0e7635701cd6fbe1f06e1decc1c29d26", "filename": "gcc/params.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=b6e99746ac31845e39844334378bafbb9a93517c", "patch": "@@ -710,6 +710,15 @@ DEFPARAM (PARAM_DF_DOUBLE_QUEUE_THRESHOLD_FACTOR,\n \t  \"Multiplier used for determining the double-queueing threshold\",\n \t  2, 0, 0)\n \n+/* Switch initialization conversion will refuse to create arrays that are\n+   bigger than this parameter times the number of switch branches.  */\n+\n+DEFPARAM (PARAM_SWITCH_CONVERSION_BRANCH_RATIO,\n+\t  \"switch-conversion-max-branch-ratio\",\n+\t  \"The maximum ratio between array size and switch branches for \"\n+\t  \"a switch conversion to take place\",\n+\t  8, 1, 0)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "7e08ec741e569b2b00207c6a1b12d2d47cb6381a", "filename": "gcc/params.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=b6e99746ac31845e39844334378bafbb9a93517c", "patch": "@@ -167,4 +167,6 @@ typedef enum compiler_param\n   PARAM_VALUE (PARAM_L2_CACHE_SIZE)\n #define USE_CANONICAL_TYPES \\\n   PARAM_VALUE (PARAM_USE_CANONICAL_TYPES)\n+#define SWITCH_CONVERSION_BRANCH_RATIO \\\n+  PARAM_VALUE (PARAM_SWITCH_CONVERSION_BRANCH_RATIO)\n #endif /* ! GCC_PARAMS_H */"}, {"sha": "e1d019fa9fd5e409bd4f911e606a241f34c8e1a8", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=b6e99746ac31845e39844334378bafbb9a93517c", "patch": "@@ -572,6 +572,7 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_update_address_taken);\n \t  NEXT_PASS (pass_simple_dse);\n \t  NEXT_PASS (pass_tail_recursion);\n+\t  NEXT_PASS (pass_convert_switch);\n           NEXT_PASS (pass_profile);\n \t  NEXT_PASS (pass_release_ssa_names);\n \t}"}, {"sha": "06710f2179331ef82f27bbc8e5742bbdc41699f3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cswtch.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcswtch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcswtch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcswtch.c?ref=b6e99746ac31845e39844334378bafbb9a93517c", "patch": "@@ -0,0 +1,81 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-switchconv\" } */\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+static int X, Y;\n+\n+int check(int param)\n+{\n+  int a = 0;\n+  int b = 1;\n+  \n+  switch (param) \n+    {\n+    case -2:\n+      a = 0;\n+      b = -1;\n+      break;\n+    case 1:\n+    case 2:\n+      a = 8;\n+      b = 6;\n+      break;\n+    case 3:\n+      a = 9;\n+      b = 5;\n+      break;\n+    case 6:\n+      a = 10;\n+      b = 4;\n+      break;\n+    default:\n+      a = 16;\n+      b = 1;\n+    }\n+  \n+  X = a;\n+  Y = b;\n+  return 0;\n+}\n+\n+void assertions(int a, int b)\n+{\n+  if (X != a || Y != b)\n+    abort();  \n+\n+  return;\n+}\n+\n+int main ()\n+{\n+  check (-10);\n+  assertions (16, 1);\n+\n+  check (-2);\n+  assertions (0, -1);\n+\n+  check(1);\n+  assertions (8, 6);\n+\n+  check(2);\n+  assertions (8, 6);\n+\n+  check(3);\n+  assertions (9, 5);\n+\n+  check(5);\n+  assertions (16, 1);\n+\n+  check(6);\n+  assertions (10, 4);\n+\n+  check(12);\n+  assertions (16, 1);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Switch converted\" \"switchconv\" } } */\n+/* { dg-final { cleanup-tree-dump \"switchconv\" } } */"}, {"sha": "c695863e553c7f195bb529ff1c689631683d6c97", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=b6e99746ac31845e39844334378bafbb9a93517c", "patch": "@@ -508,6 +508,7 @@ extern struct gimple_opt_pass pass_O0_always_inline;\n extern struct gimple_opt_pass pass_inline_parameters;\n extern struct gimple_opt_pass pass_all_early_optimizations;\n extern struct gimple_opt_pass pass_update_address_taken;\n+extern struct gimple_opt_pass pass_convert_switch;\n \n /* The root of the compilation pass tree, once constructed.  */\n extern struct opt_pass *all_passes, *all_ipa_passes, *all_lowering_passes;"}, {"sha": "940801e61fab9bce57c7eb3b36df0cea878b0636", "filename": "gcc/tree-switch-conversion.c", "status": "added", "additions": 878, "deletions": 0, "changes": 878, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e99746ac31845e39844334378bafbb9a93517c/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=b6e99746ac31845e39844334378bafbb9a93517c", "patch": "@@ -0,0 +1,878 @@\n+/* Switch Conversion converts variable initializations based on switch\n+   statements to initializations from a static array.\n+   Copyright (C) 2006, 2008 Free Software Foundation, Inc.\n+   Contributed by Martin Jambor <jamborm@suse.cz>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/*\n+     Switch initialization conversion\n+\n+The following pass changes simple initializations of scalars in a switch\n+statement into initializations from a static array.  Obviously, the values must\n+be constant and known at compile time and a default branch must be\n+provided.  For example, the following code:\n+\n+        int a,b;\n+\n+        switch (argc)\n+\t{\n+         case 1:\n+         case 2:\n+                a_1 = 8;\n+                b_1 = 6;\n+                break;\n+         case 3:\n+                a_2 = 9;\n+                b_2 = 5;\n+                break;\n+         case 12:\n+                a_3 = 10;\n+                b_3 = 4;\n+                break;\n+         default:\n+                a_4 = 16;\n+                b_4 = 1;\n+        }\n+\ta_5 = PHI <a_1, a_2, a_3, a_4>\n+\tb_5 = PHI <b_1, b_2, b_3, b_4>\n+\n+\n+is changed into:\n+\n+        static const int = CSWTCH01[] = {6, 6, 5, 1, 1, 1, 1, 1, 1, 1, 1, 4};\n+        static const int = CSWTCH02[] = {8, 8, 9, 16, 16, 16, 16, 16, 16, 16,\n+                                 16, 16, 10};\n+\n+        if (((unsigned) argc) - 1 < 11)\n+          {\n+\t    a_6 = CSWTCH02[argc - 1];\n+            b_6 = CSWTCH01[argc - 1];\n+\t  }\n+\telse\n+\t  {\n+\t    a_7 = 16;\n+\t    b_7 = 1;\n+          }\n+\t  a_5 = PHI <a_6, a_7>\n+\t  b_b = PHI <b_6, b_7>\n+\n+There are further constraints.  Specifically, the range of values across all\n+case labels must not be bigger than SWITCH_CONVERSION_BRANCH_RATIO (default\n+eight) times the number of the actual switch branches. */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include <signal.h>\n+\n+#include \"line-map.h\"\n+#include \"params.h\"\n+#include \"flags.h\"\n+#include \"tree.h\"\n+#include \"basic-block.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-flow-inline.h\"\n+#include \"tree-ssa-operands.h\"\n+#include \"output.h\"\n+#include \"input.h\"\n+#include \"tree-pass.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-dump.h\"\n+\n+/* The main structure of the pass.  */\n+struct switch_conv_info\n+{\n+  /* The expression used to decide the switch branch.  (It is subsequently used\n+     as the index to the created array.) */\n+  tree index_expr;\n+\n+  /* The following integer constants store the minimum value covered by the\n+     cases.  */\n+  tree range_min;\n+\n+  /* The difference of between the above two numbers, i.e. The size of the array\n+     that would have to be created by the transformation.  */\n+  tree range_size;\n+\n+  /* Basic block that contains the actual SWITCH_EXPR.  */\n+  basic_block switch_bb;\n+\n+  /* All branches of the switch statement must have a single successor stored in\n+     the following variable.  */\n+  basic_block final_bb;\n+\n+  /* Number of phi nodes in the final bb (that we'll be replacing).  */\n+  int phi_count;\n+\n+  /* Array of default values, n the same order as phi nodes.  */\n+  tree *default_values;\n+\n+  /* Constructors of new static arrays.  */\n+  VEC (constructor_elt, gc) **constructors;\n+\n+  /* Array of ssa names that are initialized with a value from a new static\n+     array.  */\n+  tree *target_inbound_names;\n+\n+  /* Array of ssa names that are initialized with the default value if the\n+     switch expression is out of range.  */\n+  tree *target_outbound_names;\n+\n+  /* The probability of the default edge in the replaced switch.  */\n+  int default_prob;\n+\n+  /* The count of the default edge in the replaced switch.  */\n+  gcov_type default_count;\n+\n+  /* Combined count of all other (non-default) edges in the replaced switch.  */\n+  gcov_type other_count;\n+\n+  /* The last load statement that loads a temporary from a new static array.  */\n+  tree arr_ref_first;\n+\n+  /* The last load statement that loads a temporary from a new static array.  */\n+  tree arr_ref_last;\n+\n+  /* String reason why the case wasn't a good candidate that is written to the\n+     dump file, if there is one.  */\n+  const char *reason;\n+};\n+\n+/* Global pass info.  */\n+static struct switch_conv_info info;\n+\n+\n+/* Checks whether the range given by individual case statements of the SWTCH\n+   switch statement isn't too big and whether the number of branches actually\n+   satisfies the size of the new array.  */\n+\n+static bool\n+check_range (tree swtch)\n+{\n+  tree min_case, max_case;\n+  tree cases = SWITCH_LABELS (swtch);\n+  unsigned int branch_num = TREE_VEC_LENGTH (cases);\n+  tree range_max;\n+\n+  /* The gimplifier has already sorted the cases by CASE_LOW and ensured there\n+     is a default label which is the last in the vector.  */\n+\n+  min_case = TREE_VEC_ELT (cases, 0);\n+  info.range_min = CASE_LOW (min_case);\n+\n+  gcc_assert (branch_num > 1);\n+  gcc_assert (CASE_LOW (TREE_VEC_ELT (cases, branch_num - 1)) == NULL_TREE);\n+  max_case = TREE_VEC_ELT (cases, branch_num - 2);\n+  if (CASE_HIGH (max_case) != NULL_TREE)\n+    range_max = CASE_HIGH (max_case);\n+  else\n+    range_max = CASE_LOW (max_case);\n+\n+  gcc_assert (info.range_min);\n+  gcc_assert (range_max);\n+\n+  info.range_size = int_const_binop (MINUS_EXPR, range_max, info.range_min, 0);\n+\n+  gcc_assert (info.range_size);\n+  if (!host_integerp (info.range_size, 1))\n+    {\n+      info.reason = \"index range way too large or otherwise unusable.\\n\";\n+      return false;\n+    }\n+\n+  if ((unsigned HOST_WIDE_INT) tree_low_cst (info.range_size, 1)\n+      > ((unsigned) branch_num * SWITCH_CONVERSION_BRANCH_RATIO))\n+    {\n+      info.reason = \"the maximum range-branch ratio exceeded.\\n\";\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Checks the given CS switch case whether it is suitable for conversion\n+   (whether all but the default basic blocks are empty and so on).  If it is,\n+   adds the case to the branch list along with values for the defined variables\n+   and returns true.  Otherwise returns false.  */\n+\n+static bool\n+check_process_case (tree cs)\n+{\n+  tree ldecl;\n+  basic_block label_bb, following_bb;\n+  edge e;\n+\n+  ldecl = CASE_LABEL (cs);\n+  label_bb = label_to_block (ldecl);\n+\n+  e = find_edge (info.switch_bb, label_bb);\n+  gcc_assert (e);\n+\n+  if (CASE_LOW (cs) == NULL_TREE)\n+    {\n+      /* Default branch.  */\n+      info.default_prob = e->probability;\n+      info.default_count = e->count;\n+    }\n+  else\n+    info.other_count += e->count;\n+\n+  if (!label_bb)\n+    {\n+      info.reason = \"  Bad case - cs BB  label is NULL\\n\";\n+      return false;\n+    }\n+\n+  if (!single_pred_p (label_bb))\n+    {\n+      if (info.final_bb && info.final_bb != label_bb)\n+\t{\n+\t  info.reason = \"  Bad case - a non-final BB has two predecessors\\n\";\n+\t  return false; /* sth complex going on in this branch  */\n+\t}\n+\n+      following_bb = label_bb;\n+    }\n+  else\n+    {\n+      if (!empty_block_p (label_bb))\n+\t{\n+\t  info.reason = \"  Bad case - a non-final BB not empty\\n\";\n+\t  return false;\n+\t}\n+\n+      e = single_succ_edge (label_bb);\n+      following_bb = single_succ (label_bb);\n+    }\n+\n+  if (!info.final_bb)\n+    info.final_bb = following_bb;\n+  else if (info.final_bb != following_bb)\n+    {\n+      info.reason = \"  Bad case - different final BB\\n\";\n+      return false; /* the only successor is not common for all the branches */\n+    }\n+\n+  return true;\n+}\n+\n+/* This function checks whether all required values in phi nodes in final_bb\n+   are constants.  Required values are those that correspond to a basic block\n+   which is a part of the examined switch statement.  It returns true if the\n+   phi nodes are OK, otherwise false.  */\n+\n+static bool\n+check_final_bb (void)\n+{\n+  tree phi;\n+\n+  info.phi_count = 0;\n+  for (phi = phi_nodes (info.final_bb); phi; phi = PHI_CHAIN (phi))\n+    {\n+      int i;\n+\n+      info.phi_count++;\n+\n+      for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n+\t{\n+\t  basic_block bb = PHI_ARG_EDGE (phi, i)->src;\n+\n+\t  if ((bb == info.switch_bb\n+\t       || (single_pred_p (bb) && single_pred (bb) == info.switch_bb))\n+\t      && !is_gimple_min_invariant (PHI_ARG_ELT (phi, i).def))\n+\t    {\n+\t      info.reason = \"   Non-invariant value from a case\\n\";\n+\t      return false; \t\t/* non invariant argument */\n+\t    }\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* The following function allocates default_values, target_{in,out}_names and\n+   constructors arrays.  The last one is also populated with pointers to\n+   vectors that will become constructors of new arrays.  */\n+\n+static void\n+create_temp_arrays (void)\n+{\n+  int i;\n+\n+  info.default_values = (tree *) xcalloc (info.phi_count, sizeof (tree));\n+  info.constructors = (VEC (constructor_elt, gc) **) xcalloc (info.phi_count,\n+\t\t\t\t\t\t\t      sizeof (tree));\n+  info.target_inbound_names = (tree *) xcalloc (info.phi_count, sizeof (tree));\n+  info.target_outbound_names = (tree *) xcalloc (info.phi_count,\n+\t\t\t\t\t\t sizeof (tree));\n+\n+  for (i = 0; i < info.phi_count; i++)\n+    {\n+      info.constructors[i] = VEC_alloc (constructor_elt, gc,\n+\t\t\t\t   tree_low_cst (info.range_size, 1) + 1);\n+    }\n+}\n+\n+/* Free the arrays created by create_temp_arrays().  The vectors that are\n+   created by that function are not freed here, however, because they have\n+   already become constructors and must be preserved.  */\n+\n+static void\n+free_temp_arrays (void)\n+{\n+  free (info.constructors);\n+  free (info.default_values);\n+  free (info.target_inbound_names);\n+  free (info.target_outbound_names);\n+}\n+\n+/* Populate the array of default values in the order of phi nodes.\n+   DEFAULT_CASE is the CASE_LABEL_EXPR for the default switch branch.  */\n+\n+static void\n+gather_default_values (tree default_case)\n+{\n+  tree phi;\n+  basic_block bb = label_to_block (CASE_LABEL (default_case));\n+  edge e;\n+  int i;\n+\n+  gcc_assert (CASE_LOW (default_case) == NULL_TREE);\n+\n+  if (bb == info.final_bb)\n+    e = find_edge (info.switch_bb, bb);\n+  else\n+    e = single_succ_edge (bb);\n+\n+  for (phi = phi_nodes (info.final_bb), i = 0; phi; phi = PHI_CHAIN (phi), i++)\n+    {\n+      tree val = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+      gcc_assert (val);\n+      info.default_values[i] = val;\n+    }\n+}\n+\n+/* The following function populates the vectors in the constructors array with\n+   future contents of the static arrays.  The vectors are populated in the\n+   order of phi nodes.  SWTCH is the switch statement being converted.  */\n+\n+static void\n+build_constructors (tree swtch)\n+{\n+  int i;\n+  tree cases = SWITCH_LABELS (swtch);\n+  tree pos = info.range_min;\n+\n+  for (i = 0; i < TREE_VEC_LENGTH (cases) - 1; i++)\n+    {\n+      tree cs = TREE_VEC_ELT (cases, i);\n+      basic_block bb = label_to_block (CASE_LABEL (cs));\n+      edge e;\n+      tree phi, high;\n+      int j;\n+\n+      if (bb == info.final_bb)\n+\te = find_edge (info.switch_bb, bb);\n+      else\n+\te = single_succ_edge (bb);\n+      gcc_assert (e);\n+\n+      while (tree_int_cst_lt (pos, CASE_LOW (cs)))\n+\t{\n+\t  int k;\n+\t  for (k = 0; k < info.phi_count; k++)\n+\t    {\n+\t      constructor_elt *elt;\n+\n+\t      elt = VEC_quick_push (constructor_elt,\n+\t\t\t\t    info.constructors[k], NULL);\n+\t      elt->index = int_const_binop (MINUS_EXPR, pos, info.range_min, 0);\n+\t      elt->value = info.default_values[k];\n+\t    }\n+\n+\t  pos = int_const_binop (PLUS_EXPR, pos, integer_one_node, 0);\n+\t}\n+      gcc_assert (tree_int_cst_equal (pos, CASE_LOW(cs)));\n+\n+      j = 0;\n+      if (CASE_HIGH (cs))\n+\thigh = CASE_HIGH (cs);\n+      else\n+\thigh = CASE_LOW(cs);\n+      for (phi = phi_nodes (info.final_bb); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  tree val = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+\t  pos = CASE_LOW (cs);\n+\n+\t  while (!tree_int_cst_lt (high, pos))\n+\t    {\n+\t      constructor_elt *elt;\n+\n+\t      elt = VEC_quick_push (constructor_elt,\n+\t\t\t\t    info.constructors[j], NULL);\n+\t      elt->index = int_const_binop (MINUS_EXPR, pos, info.range_min, 0);\n+\t      elt->value = val;\n+\n+\t      pos = int_const_binop (PLUS_EXPR, pos, integer_one_node, 0);\n+\t    }\n+\t  j++;\n+\t}\n+    }\n+}\n+\n+/* Create an appropriate array type and declaration and assemble a static array\n+   variable.  Also create a load statement that initializes the variable in\n+   question with a value from the static array.  SWTCH is the switch statement\n+   being converted, NUM is the index to arrays of constructors, default values\n+   and target SSA names for this particular array.  ARR_INDEX_TYPE is the type\n+   of the index of the new array, PHI is the phi node of the final BB that\n+   corresponds to the value that will be loaded from the created array.  TIDX\n+   is a temporary variable holding the index for loads from the new array.  */\n+\n+static void\n+build_one_array (tree swtch, int num, tree arr_index_type, tree phi, tree tidx)\n+{\n+  tree array_type;\n+  tree ctor;\n+  tree decl;\n+  tree value_type;\n+  tree name;\n+  tree fetch, load;\n+  block_stmt_iterator bsi;\n+\n+  gcc_assert (info.default_values[num]);\n+  value_type = TREE_TYPE (info.default_values[num]);\n+  array_type = build_array_type (value_type, arr_index_type);\n+\n+  ctor = build_constructor (array_type, info.constructors[num]);\n+  TREE_CONSTANT (ctor) = true;\n+\n+  decl = build_decl (VAR_DECL, NULL_TREE, array_type);\n+  TREE_STATIC (decl) = 1;\n+  DECL_INITIAL (decl) = ctor;\n+\n+  DECL_NAME (decl) = create_tmp_var_name (\"CSWTCH\");\n+  DECL_ARTIFICIAL (decl) = 1;\n+  TREE_CONSTANT (decl) = 1;\n+  add_referenced_var (decl);\n+  assemble_variable (decl, 0, 0, 0);\n+  mark_sym_for_renaming (decl);\n+\n+  name = make_ssa_name (SSA_NAME_VAR (PHI_RESULT (phi)), NULL_TREE);\n+  info.target_inbound_names[num] = name;\n+\n+  fetch = build4 (ARRAY_REF, value_type, decl, tidx, NULL_TREE,\n+\t\t  NULL_TREE);\n+  load = build2 (GIMPLE_MODIFY_STMT, void_type_node, name, fetch);\n+  SSA_NAME_DEF_STMT (name) = load;\n+\n+  bsi = bsi_for_stmt (swtch);\n+  bsi_insert_before (&bsi, load, BSI_SAME_STMT);\n+  mark_symbols_for_renaming (load);\n+\n+  info.arr_ref_last = load;\n+\n+  return;\n+}\n+\n+/* Builds and initializes static arrays initialized with values gathered from\n+   the SWTCH switch statement.  Also creates statements that load values from\n+   them.  */\n+\n+static void\n+build_arrays (tree swtch)\n+{\n+  tree arr_index_type;\n+  tree tidx, sub;\n+  block_stmt_iterator bsi;\n+  tree phi = phi_nodes (info.final_bb);\n+  int i;\n+\n+  arr_index_type = build_index_type (info.range_size);\n+  tidx = make_rename_temp (arr_index_type, \"csti\");\n+  sub = build2 (MINUS_EXPR, TREE_TYPE (info.index_expr), info.index_expr,\n+\t\tfold_convert (TREE_TYPE (info.index_expr), info.range_min));\n+  sub = build2 (GIMPLE_MODIFY_STMT, void_type_node, tidx, sub);\n+\n+  bsi = bsi_for_stmt (swtch);\n+  bsi_insert_before (&bsi, sub, BSI_SAME_STMT);\n+  mark_symbols_for_renaming (sub);\n+  info.arr_ref_first = sub;\n+\n+  for (phi = phi_nodes (info.final_bb), i = 0; phi; phi = PHI_CHAIN (phi), i++)\n+    build_one_array (swtch, i, arr_index_type, phi, tidx);\n+\n+  return;\n+}\n+\n+/* Generates and appropriately inserts loads of default values at the position\n+   given by BSI.  Returns the last inserted statement.  */\n+\n+static tree\n+gen_def_assigns (block_stmt_iterator *bsi)\n+{\n+  int i;\n+  tree assign = NULL_TREE;\n+\n+  for (i = 0; i < info.phi_count; i++)\n+    {\n+      tree name = make_ssa_name (SSA_NAME_VAR (info.target_inbound_names[i]),\n+\t\t\t\t NULL_TREE);\n+\n+      info.target_outbound_names[i] = name;\n+      assign = build2 (GIMPLE_MODIFY_STMT, void_type_node, name,\n+\t\t       info.default_values[i]);\n+      SSA_NAME_DEF_STMT (name) = assign;\n+      bsi_insert_before (bsi, assign, BSI_SAME_STMT);\n+      find_new_referenced_vars (&assign);\n+      mark_symbols_for_renaming (assign);\n+    }\n+  return assign;\n+}\n+\n+/* Deletes the unused bbs and edges that now contain the switch statement and\n+   its empty branch bbs.  BBD is the now dead BB containing the original switch\n+   statement, FINAL is the last BB of the converted switch statement (in terms\n+   of succession).  */\n+\n+static void\n+prune_bbs (basic_block bbd, basic_block final)\n+{\n+  edge_iterator ei;\n+  edge e;\n+\n+  for (ei = ei_start (bbd->succs); (e = ei_safe_edge (ei)); )\n+    {\n+      basic_block bb;\n+      bb = e->dest;\n+      remove_edge (e);\n+      if (bb != final)\n+\tdelete_basic_block (bb);\n+    }\n+  delete_basic_block (bbd);\n+}\n+\n+/* Add values to phi nodes in final_bb for the two new edges.  E1F is the edge\n+   from the basic block loading values from an array and E2F from the basic\n+   block loading default values.  BBF is the last switch basic block (see the\n+   bbf description in the comment below).  */\n+\n+static void\n+fix_phi_nodes (edge e1f, edge e2f, basic_block bbf)\n+{\n+  tree phi;\n+  int i;\n+\n+  for (phi = phi_nodes (bbf), i = 0; phi; phi = PHI_CHAIN (phi), i++)\n+    {\n+      add_phi_arg (phi, info.target_inbound_names[i], e1f);\n+      add_phi_arg (phi, info.target_outbound_names[i], e2f);\n+    }\n+\n+}\n+\n+/* Creates a check whether the switch expression value actually falls into the\n+   range given by all the cases.  If it does not, the temporaries are loaded\n+   with default values instead.  SWTCH is the switch statement being converted.\n+\n+   bb0 is the bb with the switch statement, however, we'll end it with a\n+       condition instead.\n+\n+   bb1 is the bb to be used when the range check went ok.  It is derived from\n+       the switch BB\n+\n+   bb2 is the bb taken when the expression evaluated outside of the range\n+       covered by the created arrays.  It is populated by loads of default\n+       values.\n+\n+   bbF is a fall through for both bb1 and bb2 and contains exactly what\n+       originally followed the switch statement.\n+\n+   bbD contains the switch statement (in the end).  It is unreachable but we\n+       still need to strip off its edges.\n+*/\n+\n+static void\n+gen_inbound_check (tree swtch)\n+{\n+  tree label_decl1 = create_artificial_label ();\n+  tree label_decl2 = create_artificial_label ();\n+  tree label_decl3 = create_artificial_label ();\n+  tree label1, label2, label3;\n+\n+  tree utype = unsigned_type_for (TREE_TYPE (info.index_expr));\n+  tree tmp_u;\n+  tree cast, cast_assign;\n+  tree ulb, minus, minus_assign;\n+  tree bound;\n+\n+  tree if_expr;\n+\n+  tree last_assign;\n+  block_stmt_iterator bsi;\n+  basic_block bb0, bb1, bb2, bbf, bbd;\n+  edge e01, e02, e21, e1d, e1f, e2f;\n+\n+  gcc_assert (info.default_values);\n+  bb0 = bb_for_stmt (swtch);\n+\n+  /* (end of) block 0 */\n+  bsi = bsi_for_stmt (info.arr_ref_first);\n+  tmp_u = make_rename_temp (utype, \"csui\");\n+\n+  cast = build1 (NOP_EXPR, utype, info.index_expr);\n+  cast_assign = build2 (GIMPLE_MODIFY_STMT, void_type_node, tmp_u, cast);\n+  find_new_referenced_vars (&cast_assign);\n+  bsi_insert_before (&bsi, cast_assign, BSI_SAME_STMT);\n+  mark_symbols_for_renaming (cast_assign);\n+\n+  ulb = fold_convert (utype, info.range_min);\n+  minus = build2 (MINUS_EXPR, utype, tmp_u, ulb);\n+  minus_assign = build2 (GIMPLE_MODIFY_STMT, void_type_node, tmp_u, minus);\n+  find_new_referenced_vars (&minus_assign);\n+  bsi_insert_before (&bsi, minus_assign, BSI_SAME_STMT);\n+  mark_symbols_for_renaming (minus_assign);\n+\n+  bound = fold_convert (utype, info.range_size);\n+\n+  if_expr = build3 (COND_EXPR, void_type_node,\n+\t\t    build2 (LE_EXPR, boolean_type_node, tmp_u, bound),\n+\t\t    NULL_TREE, NULL_TREE);\n+\n+  find_new_referenced_vars (&if_expr);\n+  bsi_insert_before (&bsi, if_expr, BSI_SAME_STMT);\n+  mark_symbols_for_renaming (if_expr);\n+\n+  /* block 2 */\n+  bsi = bsi_for_stmt (info.arr_ref_first);\n+  label2 = build1 (LABEL_EXPR, void_type_node, label_decl2);\n+  bsi_insert_before (&bsi, label2, BSI_SAME_STMT);\n+  last_assign = gen_def_assigns (&bsi);\n+\n+  /* block 1 */\n+  bsi = bsi_for_stmt (info.arr_ref_first);\n+  label1 = build1 (LABEL_EXPR, void_type_node, label_decl1);\n+  bsi_insert_before (&bsi, label1, BSI_SAME_STMT);\n+\n+  /* block F */\n+  bsi = bsi_start (info.final_bb);\n+  label3 = build1 (LABEL_EXPR, void_type_node, label_decl3);\n+  bsi_insert_before (&bsi, label3, BSI_SAME_STMT);\n+\n+  /* cfg fix */\n+  e02 = split_block (bb0, if_expr);\n+  bb2 = e02->dest;\n+\n+  e21 = split_block (bb2, last_assign);\n+  bb1 = e21->dest;\n+  remove_edge (e21);\n+\n+  e1d = split_block (bb1, info.arr_ref_last);\n+  bbd = e1d->dest;\n+  remove_edge (e1d);\n+\n+  /* flags and profiles of the edge for in-range values */\n+  e01 = make_edge (bb0, bb1, EDGE_TRUE_VALUE);\n+  e01->probability = REG_BR_PROB_BASE - info.default_prob;\n+  e01->count = info.other_count;\n+\n+  /* flags and profiles of the edge taking care of out-of-range values */\n+  e02->flags &= ~EDGE_FALLTHRU;\n+  e02->flags |= EDGE_FALSE_VALUE;\n+  e02->probability = info.default_prob;\n+  e02->count = info.default_count;\n+\n+  bbf = info.final_bb;\n+\n+  e1f = make_edge (bb1, bbf, EDGE_FALLTHRU);\n+  e1f->probability = REG_BR_PROB_BASE;\n+  e1f->count = info.other_count;\n+\n+  e2f = make_edge (bb2, bbf, EDGE_FALLTHRU);\n+  e2f->probability = REG_BR_PROB_BASE;\n+  e2f->count = info.default_count;\n+\n+  /* frequencies of the new BBs */\n+  bb1->frequency = EDGE_FREQUENCY (e01);\n+  bb2->frequency = EDGE_FREQUENCY (e02);\n+  bbf->frequency = EDGE_FREQUENCY (e1f) + EDGE_FREQUENCY (e2f);\n+\n+  prune_bbs (bbd, info.final_bb); /* to keep calc_dfs_tree() in dominance.c\n+\t\t\t\t     happy */\n+\n+  fix_phi_nodes (e1f, e2f, bbf);\n+\n+  free_dominance_info (CDI_DOMINATORS);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+}\n+\n+/* The following function is invoked on every switch statement (the current one\n+   is given in SWTCH) and runs the individual phases of switch conversion on it\n+   one after another until one fails or the conversion is completed.  */\n+\n+static bool\n+process_switch (tree swtch)\n+{\n+  int i;\n+  tree cases;\n+  tree index_type;\n+\n+  /* Operand 2 is either NULL_TREE or a vector of cases (stmt.c).  */\n+  if (TREE_OPERAND (swtch, 2) == NULL_TREE)\n+    {\n+      info.reason = \"swtch has no labels\\n\";\n+      return false;\n+    }\n+\n+  /* Comment from stmt.c:\n+     The switch body is lowered in gimplify.c, we should never have switches\n+     with a non-NULL SWITCH_BODY here.  */\n+  gcc_assert (!SWITCH_BODY (swtch));\n+\n+  cases = SWITCH_LABELS (swtch);\n+  info.final_bb = NULL;\n+  info.switch_bb = bb_for_stmt (swtch);\n+  info.index_expr = SWITCH_COND (swtch);\n+  index_type = TREE_TYPE (info.index_expr);\n+  info.arr_ref_first = NULL_TREE;\n+  info.arr_ref_last = NULL_TREE;\n+  info.default_prob = 0;\n+  info.default_count = 0;\n+  info.other_count = 0;\n+\n+  /* An ERROR_MARK occurs for various reasons including invalid data type.\n+     (comment from stmt.c) */\n+  if (index_type == error_mark_node)\n+    {\n+      info.reason = \"index error.\\n\";\n+      return false;\n+    }\n+\n+  /* Check the case label values are within reasonable range:  */\n+  if (!check_range (swtch))\n+    return false;\n+\n+  /* For all the cases, see whether they are empty, the assignments they\n+     represent constant and so on...  */\n+  for (i = 0; i < TREE_VEC_LENGTH (cases); i++)\n+    {\n+      tree part_case = TREE_VEC_ELT (cases, i);\n+      if (!check_process_case (part_case))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Processing of case %i failed\\n\", i);\n+\t  return false;\n+\t}\n+    }\n+\n+  if (!check_final_bb ())\n+    return false;\n+\n+  /* At this point all checks have passed and we can proceed with the\n+     transformation.  */\n+\n+  create_temp_arrays ();\n+  gather_default_values (TREE_VEC_ELT (cases, TREE_VEC_LENGTH (cases) - 1));\n+  build_constructors (swtch);\n+\n+  build_arrays (swtch); /* Build the static arrays and assignments.   */\n+  gen_inbound_check (swtch); \t/* Build the bounds check.  */\n+\n+  /* Cleanup:  */\n+  free_temp_arrays ();\n+  return true;\n+}\n+\n+/* The main function of the pass scans statements for switches and invokes\n+   process_switch on them.  */\n+\n+static unsigned int\n+do_switchconv (void)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+  {\n+    tree stmt = last_stmt (bb);\n+    if (stmt && TREE_CODE (stmt) == SWITCH_EXPR)\n+      {\n+\texpanded_location loc = expand_location (EXPR_LOCATION (stmt));\n+\n+\tif (dump_file)\n+\t  {\n+\t    fprintf (dump_file, \"beginning to process the following \"\n+\t\t     \"SWITCH statement (%s:%d) : ------- \\n\",\n+\t\t     loc.file, loc.line);\n+\t    print_generic_stmt (dump_file, stmt, 2);\n+\t    fprintf (dump_file, \"\\n\");\n+\t  }\n+\n+\tinfo.reason = NULL;\n+\tif (process_switch (stmt))\n+\t  {\n+\t    if (dump_file)\n+\t      {\n+\t\tfprintf (dump_file, \"Switch converted\\n\");\n+\t\tfprintf (dump_file, \"--------------------------------\\n\");\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    if (dump_file)\n+\t      {\n+\t\tgcc_assert (info.reason);\n+\t\tfprintf (dump_file, \"Bailing out - \");\n+\t\tfprintf (dump_file, info.reason);\n+\t\tfprintf (dump_file, \"--------------------------------\\n\");\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+  return 0;\n+}\n+\n+/* The pass gate. */\n+\n+static bool\n+switchconv_gate (void)\n+{\n+  return flag_tree_switch_conversion != 0;\n+}\n+\n+struct gimple_opt_pass pass_convert_switch =\n+{\n+ {\n+  GIMPLE_PASS,\n+  \"switchconv\",\t\t\t\t/* name */\n+  switchconv_gate,        \t\t/* gate */\n+  do_switchconv,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t        \t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t                /* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_update_ssa | TODO_dump_func\n+  | TODO_ggc_collect | TODO_verify_ssa  /* todo_flags_finish */\n+ }\n+};"}]}