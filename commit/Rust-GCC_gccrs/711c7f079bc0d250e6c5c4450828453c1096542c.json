{"sha": "711c7f079bc0d250e6c5c4450828453c1096542c", "node_id": "C_kwDOANBUbNoAKDcxMWM3ZjA3OWJjMGQyNTBlNmM1YzQ0NTA4Mjg0NTNjMTA5NjU0MmM", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-03-25T11:35:33Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-03-25T11:37:01Z"}, "message": "Fix issue for pointers to anonymous types with -fdump-ada-spec\n\nThis used to work long ago but broke at some point.\n\ngcc/c-family/\n\t* c-ada-spec.cc (dump_ada_import): Deal with the \"section\" attribute\n\t(dump_ada_node) <POINTER_TYPE>: Do not modify and pass the name, but\n\tthe referenced type instead.  Deal with the anonymous original type\n\tof a typedef'ed type.  In the actual access case, follow the chain\n\tof external subtypes.\n\t<TYPE_DECL>: Tidy up control flow.", "tree": {"sha": "dd5c153e937137d7ae166d1e8d41031a5177b860", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd5c153e937137d7ae166d1e8d41031a5177b860"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/711c7f079bc0d250e6c5c4450828453c1096542c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/711c7f079bc0d250e6c5c4450828453c1096542c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/711c7f079bc0d250e6c5c4450828453c1096542c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/711c7f079bc0d250e6c5c4450828453c1096542c/comments", "author": null, "committer": null, "parents": [{"sha": "45e955b0a936eafc9838cdc00dcc31b3799b321b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45e955b0a936eafc9838cdc00dcc31b3799b321b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45e955b0a936eafc9838cdc00dcc31b3799b321b"}], "stats": {"total": 89, "additions": 54, "deletions": 35}, "files": [{"sha": "f291e150934dac24aecaed17ff9e7edb1edb2db5", "filename": "gcc/c-family/c-ada-spec.cc", "status": "modified", "additions": 54, "deletions": 35, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711c7f079bc0d250e6c5c4450828453c1096542c/gcc%2Fc-family%2Fc-ada-spec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711c7f079bc0d250e6c5c4450828453c1096542c/gcc%2Fc-family%2Fc-ada-spec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.cc?ref=711c7f079bc0d250e6c5c4450828453c1096542c", "patch": "@@ -1526,6 +1526,15 @@ dump_ada_import (pretty_printer *buffer, tree t, int spc)\n \n   newline_and_indent (buffer, spc + 5);\n \n+  tree sec = lookup_attribute (\"section\", DECL_ATTRIBUTES (t));\n+  if (sec)\n+    {\n+      pp_string (buffer, \"Linker_Section => \\\"\");\n+      pp_string (buffer, TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (sec))));\n+      pp_string (buffer, \"\\\", \");\n+      newline_and_indent (buffer, spc + 5);\n+    }\n+\n   pp_string (buffer, \"External_Name => \\\"\");\n \n   if (is_stdcall)\n@@ -2179,10 +2188,11 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t}\n       else\n \t{\n-\t  const unsigned int quals = TYPE_QUALS (TREE_TYPE (node));\n+\t  tree ref_type = TREE_TYPE (node);\n+\t  const unsigned int quals = TYPE_QUALS (ref_type);\n \t  bool is_access = false;\n \n-\t  if (VOID_TYPE_P (TREE_TYPE (node)))\n+\t  if (VOID_TYPE_P (ref_type))\n \t    {\n \t      if (!name_only)\n \t\tpp_string (buffer, \"new \");\n@@ -2197,9 +2207,8 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t  else\n \t    {\n \t      if (TREE_CODE (node) == POINTER_TYPE\n-\t\t  && TREE_CODE (TREE_TYPE (node)) == INTEGER_TYPE\n-\t\t  && id_equal (DECL_NAME (TYPE_NAME (TREE_TYPE (node))),\n-\t\t\t       \"char\"))\n+\t\t  && TREE_CODE (ref_type) == INTEGER_TYPE\n+\t\t  && id_equal (DECL_NAME (TYPE_NAME (ref_type)), \"char\"))\n \t\t{\n \t\t  if (!name_only)\n \t\t    pp_string (buffer, \"new \");\n@@ -2214,28 +2223,11 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t}\n \t      else\n \t\t{\n-\t\t  tree type_name = TYPE_NAME (TREE_TYPE (node));\n-\n-\t\t  /* Generate \"access <type>\" instead of \"access <subtype>\"\n-\t\t     if the subtype comes from another file, because subtype\n-\t\t     declarations do not contribute to the limited view of a\n-\t\t     package and thus subtypes cannot be referenced through\n-\t\t     a limited_with clause.  */\n-\t\t  if (type_name\n-\t\t      && TREE_CODE (type_name) == TYPE_DECL\n-\t\t      && DECL_ORIGINAL_TYPE (type_name)\n-\t\t      && TYPE_NAME (DECL_ORIGINAL_TYPE (type_name)))\n-\t\t    {\n-\t\t      const expanded_location xloc\n-\t\t\t= expand_location (decl_sloc (type_name, false));\n-\t\t      if (xloc.line\n-\t\t\t  && xloc.file\n-\t\t\t  && xloc.file != current_source_file)\n-\t\t\ttype_name = DECL_ORIGINAL_TYPE (type_name);\n-\t\t    }\n+\t\t  tree stub = TYPE_STUB_DECL (ref_type);\n+\t\t  tree type_name = TYPE_NAME (ref_type);\n \n \t\t  /* For now, handle access-to-access as System.Address.  */\n-\t\t  if (TREE_CODE (TREE_TYPE (node)) == POINTER_TYPE)\n+\t\t  if (TREE_CODE (ref_type) == POINTER_TYPE)\n \t\t    {\n \t\t      if (package_prefix)\n \t\t\t{\n@@ -2251,7 +2243,7 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \n \t\t  if (!package_prefix)\n \t\t    pp_string (buffer, \"access\");\n-\t\t  else if (AGGREGATE_TYPE_P (TREE_TYPE (node)))\n+\t\t  else if (AGGREGATE_TYPE_P (ref_type))\n \t\t    {\n \t\t      if (!type || TREE_CODE (type) != FUNCTION_DECL)\n \t\t\t{\n@@ -2281,12 +2273,41 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t\tpp_string (buffer, \"all \");\n \t\t    }\n \n-\t\t  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (node)) && type_name)\n-\t\t    dump_ada_node (buffer, type_name, TREE_TYPE (node), spc,\n-\t\t\t\t   is_access, true);\n-\t\t  else\n-\t\t    dump_ada_node (buffer, TREE_TYPE (node), TREE_TYPE (node),\n-\t\t\t\t   spc, false, true);\n+\t\t  /* If this is the anonymous original type of a typedef'ed\n+\t\t     type, then use the name of the latter.  */\n+\t\t  if (!type_name\n+\t\t      && stub\n+\t\t      && DECL_CHAIN (stub)\n+\t\t      && TREE_CODE (DECL_CHAIN (stub)) == TYPE_DECL\n+\t\t      && DECL_ORIGINAL_TYPE (DECL_CHAIN (stub)) == ref_type)\n+\t\t    ref_type = TREE_TYPE (DECL_CHAIN (stub));\n+\n+\t\t  /* Generate \"access <type>\" instead of \"access <subtype>\"\n+\t\t     if the subtype comes from another file, because subtype\n+\t\t     declarations do not contribute to the limited view of a\n+\t\t     package and thus subtypes cannot be referenced through\n+\t\t     a limited_with clause.  */\n+\t\t  else if (is_access)\n+\t\t    while (type_name\n+\t\t\t   && TREE_CODE (type_name) == TYPE_DECL\n+\t\t\t   && DECL_ORIGINAL_TYPE (type_name)\n+\t\t\t   && TYPE_NAME (DECL_ORIGINAL_TYPE (type_name)))\n+\t\t      {\n+\t\t\tconst expanded_location xloc\n+\t\t\t  = expand_location (decl_sloc (type_name, false));\n+\t\t\tif (xloc.line\n+\t\t\t    && xloc.file\n+\t\t\t    && xloc.file != current_source_file)\n+\t\t\t  {\n+\t\t\t    ref_type = DECL_ORIGINAL_TYPE (type_name);\n+\t\t\t    type_name = TYPE_NAME (ref_type);\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  break;\n+\t\t      }\n+\n+\t\t  dump_ada_node (buffer, ref_type, ref_type, spc, is_access,\n+\t\t\t\t true);\n \t\t}\n \t    }\n \t}\n@@ -2361,10 +2382,8 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t      else\n \t\tpp_string (buffer, \"address\");\n \t    }\n-\t  break;\n \t}\n-\n-      if (name_only)\n+      else if (name_only)\n \tdump_ada_decl_name (buffer, node, limited_access);\n       else\n \t{"}]}