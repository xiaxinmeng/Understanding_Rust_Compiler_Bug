{"sha": "c0fb94d7250e1311bfd2724f3df629999f1a291b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBmYjk0ZDcyNTBlMTMxMWJmZDI3MjRmM2RmNjI5OTk5ZjFhMjkxYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2005-05-18T18:43:53Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2005-05-18T18:43:53Z"}, "message": "config.gcc (sh*-*-*): Define SUPPORT_* macros to 1.\n\n\t* config.gcc (sh*-*-*): Define SUPPORT_* macros to 1.\n\t* config/sh/sh.h: Update mask names throughout.\n\t(target_flags, ISIZE_BIT, DALIGN_BIT, SH1_BIT, SH2_BIT, SH3_BIT)\n\t(SH_E_BIT, HARD_SH4_BIT, FPU_SINGLE_BIT, SH4_BIT, SH4A_BIT, FMOVD_BIT)\n\t(SH5_BIT, SPACE_BIT, BIGTABLE_BIT, RELAX_BIT, USERMODE_BIT)\n\t(HITACHI_BIT, NOMACSAVE_BIT, PREFERGOT_BIT, PADSTRUCT_BIT)\n\t(LITTLE_ENDIAN_BIT, IEEE_BIT, SAVE_ALL_TR_BIT, HARD_SH2A_BIT)\n\t(HARD_SH2A_DOUBLE_BIT, INDEXED_ADDRESS_BIT, PT_FIXED_BIT)\n\t(INVALID_SYMBOLS_BIT, ADJUST_UNROLL_BIT, TARGET_DUMPISIZE)\n\t(TARGET_ALIGN_DOUBLE, TARGET_SH1, TARGET_SH2, TARGET_SH3)\n\t(TARGET_HARD_SH4, TARGET_FPU_SINGLE, TARGET_SH5, TARGET_FMOVD)\n\t(TARGET_IEEE, TARGET_SMALLCODE, TARGET_BIGTABLE, TARGET_RELAX)\n\t(TARGET_HITACHI, TARGET_NOMACSAVE, TARGET_PADSTRUCT)\n\t(TARGET_LITTLE_ENDIAN, TARGET_USERMODE, TARGET_PREFERGOT)\n\t(TARGET_SAVE_ALL_TARGET_REGS, TARGET_ALLOW_INDEXED_ADDRESS)\n\t(TARGET_PT_FIXED, TARGET_INVALID_SYMBOLS, TARGET_ADJUST_UNROLL)\n\t(TARGET_SWITCH_SH1, TARGET_SWITCH_SH2, TARGET_SWITCH_SH2E)\n\t(TARGET_SWITCH_SH2A, TARGET_SWITCH_SH2A_SINGLE_ONLY)\n\t(TARGET_SWITCH_SH2A_SINGLE, TARGET_SWITCH_SH2A_NOFPU)\n\t(TARGET_SWITCH_SH3, TARGET_SWITCH_SH3E, TARGET_SWITCH_SH4_SINGLE_ONLY)\n\t(TARGET_SWITCH_SH4_SINGLE, TARGET_SWITCH_SH4_NOFPU, TARGET_SWITCH_SH4)\n\t(TARGET_SWITCH_SH4A, TARGET_SWITCH_SH4A_SINGLE_ONLY)\n\t(TARGET_SWITCH_SH4A_SINGLE, TARGET_SWITCH_SH4A_NOFPU)\n\t(TARGET_SWITCH_SH4AL, TARGET_SWITCH_SH5_64MEDIA)\n\t(TARGET_SWITCH_SH5_64MEDIA_NOFPU, TARGET_SWITCHES_SH5_32MEDIA)\n\t(TARGET_SWITCHES_SH5_32MEDIA_NOFPU, TARGET_SWITCH_SH5_32_ANY_EXTRA)\n\t(TARGET_SWITCH_SH5_MEDIA_ANY_EXTRA, TARGET_SWITCHES)\n\t(SUBTARGET_SWITCHES): Delete.\n\t(TARGET_SH2E, TARGET_SH2A, TARGET_SH2A_SINGLE, TARGET_SH2A_DOUBLE)\n\t(TARGET_SH3E, TARGET_CACHE32, TARGET_SUPERSCALAR, TARGET_HARVARD)\n\t(TARGET_FPU_DOUBLE, TARGET_SH4A_ARCH, TARGET_SHMEDIA32)\n\t(TARGET_SHMEDIA64): Redefine using other TARGET_* macros.\n\t(TARGET_SH4): Undefine options.h definition and check MASK_SH1 as well.\n\t(SUPPORT_SH1, SUPPORT_SH2E, SUPPORT_SH4, SUPPORT_SH4_SINGLE)\n\t(SUPPORT_SH2A, SUPPORT_SH2A_SINGLE): Make numeric.\n\t(SUPPORT_SH2): Define to 1 if SUPPORT_SH1.\n\t(SUPPORT_SH3): Likewise SUPPORT_SH2.\n\t(SUPPORT_SH4_NOFPU): Likewise SUPPORT_SH3.\n\t(SUPPORT_SH4A_NOFPU, SUPPORT_SH4AL, SUPPORT_SH2A_NOFPU): Likewise\n\tSUPPORT_SH4_NOFPU.\n\t(SUPPORT_SH3E): Likewise SUPPORT_SH2E.\n\t(SUPPORT_SH4_SINGLE_ONLY, SUPPORT_SH4A_SINGLE_ONLY)\n\t(SUPPORT_SH2A_SINGLE_ONLY): Likewise SUPPORT_SH3E.\n\t(SUPPORT_SH4A): Likewise SUPPORT_SH4.\n\t(SUPPORT_SH4A_SINGLE): Likewise SUPPORT_SH4_SINGLE.\n\t(SUPPORT_SH5_32MEDIA): Likewise SUPPORT_SH5_COMPACT.\n\t(SUPPORT_SH5_32MEDIA_NOFPU): Likewise SUPPORT_SH5_COMPACT_NOFPU.\n\t(SUPPORT_ANY_SH5_32MEDIA, SUPPORT_ANY_SH5_64MEDIA)\n\t(SUPPORT_ANY_SH5): New macros.\n\t(TARGET_NONE): Replace with...\n\t(MASK_ARCH): ...this new macro.\n\t* config/sh/elf.h: Update mask names\n\t* config/sh/linux.h: Likewise.\n\t* config/sh/little.h: Likewise.\n\t* config/sh/netbsd-elf.h: Likewise.\n\t* config/sh/symbian-pre.h: Likewise.\n\t* config/sh/sh.c (sh_handle_option): New function.\n\t(TARGET_DEFAULT_TARGET_FLAGS, TARGET_HANDLE_OPTION): Override defaults.\n\t(calc_live_regs): Use MASK_FPU_SINGLE instead of FPU_SINGLE_BIT.\n\t(sh_target_switches, target_switches): Delete.\n\t(sh_pch_valid_p): Check for specific differences in the target_flags\n\tsettings.\n\t(sh_init_cumulative_args): Use MASK_HITACHI instead of HITACHI_BIT.\n\t* config/sh/sh.opt: New file.\n\nFrom-SVN: r99916", "tree": {"sha": "f1bb4d61a57b5b2aac8b19330300e914d887e680", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1bb4d61a57b5b2aac8b19330300e914d887e680"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0fb94d7250e1311bfd2724f3df629999f1a291b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0fb94d7250e1311bfd2724f3df629999f1a291b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0fb94d7250e1311bfd2724f3df629999f1a291b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0fb94d7250e1311bfd2724f3df629999f1a291b/comments", "author": null, "committer": null, "parents": [{"sha": "3d4ee18234ef5118ff305a8e7026505601a1ce23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d4ee18234ef5118ff305a8e7026505601a1ce23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d4ee18234ef5118ff305a8e7026505601a1ce23"}], "stats": {"total": 990, "additions": 521, "deletions": 469}, "files": [{"sha": "10ab31694d63b3219a3a9452e93075a99134eb49", "filename": "gcc/ChangeLog", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0fb94d7250e1311bfd2724f3df629999f1a291b", "patch": "@@ -1,3 +1,70 @@\n+2005-05-18  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config.gcc (sh*-*-*): Define SUPPORT_* macros to 1.\n+\t* config/sh/sh.h: Update mask names throughout.\n+\t(target_flags, ISIZE_BIT, DALIGN_BIT, SH1_BIT, SH2_BIT, SH3_BIT)\n+\t(SH_E_BIT, HARD_SH4_BIT, FPU_SINGLE_BIT, SH4_BIT, SH4A_BIT, FMOVD_BIT)\n+\t(SH5_BIT, SPACE_BIT, BIGTABLE_BIT, RELAX_BIT, USERMODE_BIT)\n+\t(HITACHI_BIT, NOMACSAVE_BIT, PREFERGOT_BIT, PADSTRUCT_BIT)\n+\t(LITTLE_ENDIAN_BIT, IEEE_BIT, SAVE_ALL_TR_BIT, HARD_SH2A_BIT)\n+\t(HARD_SH2A_DOUBLE_BIT, INDEXED_ADDRESS_BIT, PT_FIXED_BIT)\n+\t(INVALID_SYMBOLS_BIT, ADJUST_UNROLL_BIT, TARGET_DUMPISIZE)\n+\t(TARGET_ALIGN_DOUBLE, TARGET_SH1, TARGET_SH2, TARGET_SH3)\n+\t(TARGET_HARD_SH4, TARGET_FPU_SINGLE, TARGET_SH5, TARGET_FMOVD)\n+\t(TARGET_IEEE, TARGET_SMALLCODE, TARGET_BIGTABLE, TARGET_RELAX)\n+\t(TARGET_HITACHI, TARGET_NOMACSAVE, TARGET_PADSTRUCT)\n+\t(TARGET_LITTLE_ENDIAN, TARGET_USERMODE, TARGET_PREFERGOT)\n+\t(TARGET_SAVE_ALL_TARGET_REGS, TARGET_ALLOW_INDEXED_ADDRESS)\n+\t(TARGET_PT_FIXED, TARGET_INVALID_SYMBOLS, TARGET_ADJUST_UNROLL)\n+\t(TARGET_SWITCH_SH1, TARGET_SWITCH_SH2, TARGET_SWITCH_SH2E)\n+\t(TARGET_SWITCH_SH2A, TARGET_SWITCH_SH2A_SINGLE_ONLY)\n+\t(TARGET_SWITCH_SH2A_SINGLE, TARGET_SWITCH_SH2A_NOFPU)\n+\t(TARGET_SWITCH_SH3, TARGET_SWITCH_SH3E, TARGET_SWITCH_SH4_SINGLE_ONLY)\n+\t(TARGET_SWITCH_SH4_SINGLE, TARGET_SWITCH_SH4_NOFPU, TARGET_SWITCH_SH4)\n+\t(TARGET_SWITCH_SH4A, TARGET_SWITCH_SH4A_SINGLE_ONLY)\n+\t(TARGET_SWITCH_SH4A_SINGLE, TARGET_SWITCH_SH4A_NOFPU)\n+\t(TARGET_SWITCH_SH4AL, TARGET_SWITCH_SH5_64MEDIA)\n+\t(TARGET_SWITCH_SH5_64MEDIA_NOFPU, TARGET_SWITCHES_SH5_32MEDIA)\n+\t(TARGET_SWITCHES_SH5_32MEDIA_NOFPU, TARGET_SWITCH_SH5_32_ANY_EXTRA)\n+\t(TARGET_SWITCH_SH5_MEDIA_ANY_EXTRA, TARGET_SWITCHES)\n+\t(SUBTARGET_SWITCHES): Delete.\n+\t(TARGET_SH2E, TARGET_SH2A, TARGET_SH2A_SINGLE, TARGET_SH2A_DOUBLE)\n+\t(TARGET_SH3E, TARGET_CACHE32, TARGET_SUPERSCALAR, TARGET_HARVARD)\n+\t(TARGET_FPU_DOUBLE, TARGET_SH4A_ARCH, TARGET_SHMEDIA32)\n+\t(TARGET_SHMEDIA64): Redefine using other TARGET_* macros.\n+\t(TARGET_SH4): Undefine options.h definition and check MASK_SH1 as well.\n+\t(SUPPORT_SH1, SUPPORT_SH2E, SUPPORT_SH4, SUPPORT_SH4_SINGLE)\n+\t(SUPPORT_SH2A, SUPPORT_SH2A_SINGLE): Make numeric.\n+\t(SUPPORT_SH2): Define to 1 if SUPPORT_SH1.\n+\t(SUPPORT_SH3): Likewise SUPPORT_SH2.\n+\t(SUPPORT_SH4_NOFPU): Likewise SUPPORT_SH3.\n+\t(SUPPORT_SH4A_NOFPU, SUPPORT_SH4AL, SUPPORT_SH2A_NOFPU): Likewise\n+\tSUPPORT_SH4_NOFPU.\n+\t(SUPPORT_SH3E): Likewise SUPPORT_SH2E.\n+\t(SUPPORT_SH4_SINGLE_ONLY, SUPPORT_SH4A_SINGLE_ONLY)\n+\t(SUPPORT_SH2A_SINGLE_ONLY): Likewise SUPPORT_SH3E.\n+\t(SUPPORT_SH4A): Likewise SUPPORT_SH4.\n+\t(SUPPORT_SH4A_SINGLE): Likewise SUPPORT_SH4_SINGLE.\n+\t(SUPPORT_SH5_32MEDIA): Likewise SUPPORT_SH5_COMPACT.\n+\t(SUPPORT_SH5_32MEDIA_NOFPU): Likewise SUPPORT_SH5_COMPACT_NOFPU.\n+\t(SUPPORT_ANY_SH5_32MEDIA, SUPPORT_ANY_SH5_64MEDIA)\n+\t(SUPPORT_ANY_SH5): New macros.\n+\t(TARGET_NONE): Replace with...\n+\t(MASK_ARCH): ...this new macro.\n+\t* config/sh/elf.h: Update mask names\n+\t* config/sh/linux.h: Likewise.\n+\t* config/sh/little.h: Likewise.\n+\t* config/sh/netbsd-elf.h: Likewise.\n+\t* config/sh/symbian-pre.h: Likewise.\n+\t* config/sh/sh.c (sh_handle_option): New function.\n+\t(TARGET_DEFAULT_TARGET_FLAGS, TARGET_HANDLE_OPTION): Override defaults.\n+\t(calc_live_regs): Use MASK_FPU_SINGLE instead of FPU_SINGLE_BIT.\n+\t(sh_target_switches, target_switches): Delete.\n+\t(sh_pch_valid_p): Check for specific differences in the target_flags\n+\tsettings.\n+\t(sh_init_cumulative_args): Use MASK_HITACHI instead of HITACHI_BIT.\n+\t* config/sh/sh.opt: New file.\n+\n 2005-05-18  Richard Henderson  <rth@redhat.com>\n \n \tPR target/21632"}, {"sha": "34a267d5cc5adb9f2d31a491d1272f680131cc15", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=c0fb94d7250e1311bfd2724f3df629999f1a291b", "patch": "@@ -1945,7 +1945,7 @@ sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \\\n \t\tsh5-32media | sh5-32media-nofpu | \\\n \t\tsh5-compact | sh5-compact-nofpu)\n \t\t\ttmake_file=\"${tmake_file} sh/t-mlib-${sh_multilib}\"\n-\t\t\ttm_defines=\"$tm_defines SUPPORT_`echo $sh_multilib|tr a-z- A-Z_`\"\n+\t\t\ttm_defines=\"$tm_defines SUPPORT_`echo $sh_multilib|tr a-z- A-Z_`=1\"\n \t\t\t;;\n \t\t*)\n \t\t\techo \"with_multilib_list=${sh_multilib} not supported.\"\n@@ -1954,7 +1954,7 @@ sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \\\n \t\tesac\n \tdone\n \tif test x${enable_incomplete_targets} == xyes ; then\n-\t\ttm_defines=\"$tm_defines SUPPORT_SH1 SUPPORT_SH2E SUPPORT_SH4 SUPPORT_SH4_SINGLE SUPPORT_SH2A SUPPORT_SH2A_SINGLE SUPPORT_SH5_32MEDIA SUPPORT_SH5_32MEDIA_NOFPU SUPPORT_SH5_64MEDIA SUPPORT_SH5_64MEDIA_NOFPU\"\n+\t\ttm_defines=\"$tm_defines SUPPORT_SH1=1 SUPPORT_SH2E=1 SUPPORT_SH4=1 SUPPORT_SH4_SINGLE=1 SUPPORT_SH2A=1 SUPPORT_SH2A_SINGLE=1 SUPPORT_SH5_32MEDIA=1 SUPPORT_SH5_32MEDIA_NOFPU=1 SUPPORT_SH5_64MEDIA=1 SUPPORT_SH5_64MEDIA_NOFPU=1\"\n \tfi\n \tuse_fixproto=yes\n \t;;"}, {"sha": "52d0727eb64c3bcd1a4cde0b530b5dbea4a0d20a", "filename": "gcc/config/sh/elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2Fconfig%2Fsh%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2Fconfig%2Fsh%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Felf.h?ref=c0fb94d7250e1311bfd2724f3df629999f1a291b", "patch": "@@ -61,7 +61,7 @@ Boston, MA 02111-1307, USA.  */\n #undef LINK_SPEC\n #define LINK_SPEC SH_LINK_SPEC\n #undef LINK_EMUL_PREFIX\n-#if TARGET_ENDIAN_DEFAULT == LITTLE_ENDIAN_BIT\n+#if TARGET_ENDIAN_DEFAULT == MASK_LITTLE_ENDIAN\n #define LINK_EMUL_PREFIX \"sh%{!mb:l}elf\"\n #else\n #define LINK_EMUL_PREFIX \"sh%{ml:l}elf\""}, {"sha": "fe48d0ca0b1c1032c86057ec27020d1d6d769a87", "filename": "gcc/config/sh/linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2Fconfig%2Fsh%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2Fconfig%2Fsh%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Flinux.h?ref=c0fb94d7250e1311bfd2724f3df629999f1a291b", "patch": "@@ -48,7 +48,7 @@ Boston, MA 02111-1307, USA.  */\n \n #undef TARGET_DEFAULT\n #define TARGET_DEFAULT \\\n-  (TARGET_CPU_DEFAULT | USERMODE_BIT | TARGET_ENDIAN_DEFAULT \\\n+  (TARGET_CPU_DEFAULT | MASK_USERMODE | TARGET_ENDIAN_DEFAULT \\\n    | TARGET_OPT_DEFAULT)\n \n #define TARGET_ASM_FILE_END file_end_indicate_exec_stack"}, {"sha": "c0ccbd7693cf87434bb325bcdfc00980c5bbe79a", "filename": "gcc/config/sh/little.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2Fconfig%2Fsh%2Flittle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2Fconfig%2Fsh%2Flittle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Flittle.h?ref=c0fb94d7250e1311bfd2724f3df629999f1a291b", "patch": "@@ -19,4 +19,4 @@ along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#define TARGET_ENDIAN_DEFAULT LITTLE_ENDIAN_BIT\n+#define TARGET_ENDIAN_DEFAULT MASK_LITTLE_ENDIAN"}, {"sha": "92d7ae1e309b2f2779e99785c32a8351b7d0dccc", "filename": "gcc/config/sh/netbsd-elf.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2Fconfig%2Fsh%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2Fconfig%2Fsh%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fnetbsd-elf.h?ref=c0fb94d7250e1311bfd2724f3df629999f1a291b", "patch": "@@ -20,21 +20,21 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n /* Run-time Target Specification.  */\n-#if TARGET_ENDIAN_DEFAULT == LITTLE_ENDIAN_BIT\n+#if TARGET_ENDIAN_DEFAULT == MASK_LITTLE_ENDIAN\n #define TARGET_VERSION_ENDIAN \"le\"\n #else\n #define TARGET_VERSION_ENDIAN \"\"\n #endif\n \n-#if TARGET_CPU_DEFAULT & SH5_BIT\n-#if TARGET_CPU_DEFAULT & SH_E_BIT\n+#if TARGET_CPU_DEFAULT & MASK_SH5\n+#if TARGET_CPU_DEFAULT & MASK_SH_E\n #define TARGET_VERSION_CPU \"sh5\"\n #else\n #define TARGET_VERSION_CPU \"sh64\"\n-#endif /* SH_E_BIT */\n+#endif /* MASK_SH_E */\n #else\n #define TARGET_VERSION_CPU \"sh\"\n-#endif /* SH5_BIT */\n+#endif /* MASK_SH5 */\n \n #undef TARGET_VERSION\n #define TARGET_VERSION\tfprintf (stderr, \" (NetBSD/%s%s ELF)\",\t\t\\\n@@ -80,7 +80,7 @@ Boston, MA 02111-1307, USA.  */\n \n #undef TARGET_DEFAULT\n #define TARGET_DEFAULT \\\n-  (TARGET_CPU_DEFAULT | USERMODE_BIT | TARGET_ENDIAN_DEFAULT)\n+  (TARGET_CPU_DEFAULT | MASK_USERMODE | TARGET_ENDIAN_DEFAULT)\n \n /* Define because we use the label and we do not need them.  */\n #define NO_PROFILE_COUNTERS 1"}, {"sha": "a0b7862299f4cde5a41a5c1138ea09cfbab4c3c2", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 125, "deletions": 35, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=c0fb94d7250e1311bfd2724f3df629999f1a291b", "patch": "@@ -198,6 +198,7 @@ int assembler_dialect;\n \n static bool shmedia_space_reserved_for_target_registers;\n \n+static bool sh_handle_option (size_t, const char *, int);\n static void split_branches (rtx);\n static int branch_dest (rtx);\n static void force_into (rtx, rtx);\n@@ -325,6 +326,11 @@ static int hard_regs_intersect_p (HARD_REG_SET *, HARD_REG_SET *);\n #undef TARGET_ASM_FILE_START_FILE_DIRECTIVE\n #define TARGET_ASM_FILE_START_FILE_DIRECTIVE true\n \n+#undef TARGET_DEFAULT_TARGET_FLAGS\n+#define TARGET_DEFAULT_TARGET_FLAGS TARGET_DEFAULT\n+#undef TARGET_HANDLE_OPTION\n+#define TARGET_HANDLE_OPTION sh_handle_option\n+\n #undef TARGET_INSERT_ATTRIBUTES\n #define TARGET_INSERT_ATTRIBUTES sh_insert_attributes\n \n@@ -491,6 +497,112 @@ static int hard_regs_intersect_p (HARD_REG_SET *, HARD_REG_SET *);\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n+/* Implement TARGET_HANDLE_OPTION.  */\n+\n+static bool\n+sh_handle_option (size_t code, const char *arg ATTRIBUTE_UNUSED,\n+\t\t  int value ATTRIBUTE_UNUSED)\n+{\n+  switch (code)\n+    {\n+    case OPT_m1:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH1;\n+      return true;\n+\n+    case OPT_m2:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH2;\n+      return true;\n+\n+    case OPT_m2a:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH2A;\n+      return true;\n+\n+    case OPT_m2a_nofpu:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH2A_NOFPU;\n+      return true;\n+\n+    case OPT_m2a_single:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH2A_SINGLE;\n+      return true;\n+\n+    case OPT_m2a_single_only:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH2A_SINGLE_ONLY;\n+      return true;\n+\n+    case OPT_m2e:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH2E;\n+      return true;\n+\n+    case OPT_m3:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH3;\n+      return true;\n+\n+    case OPT_m3e:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH3E;\n+      return true;\n+\n+    case OPT_m4:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH4;\n+      return true;\n+\n+    case OPT_m4_nofpu:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH4_NOFPU;\n+      return true;\n+\n+    case OPT_m4_single:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH4_SINGLE;\n+      return true;\n+\n+    case OPT_m4_single_only:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH4_SINGLE_ONLY;\n+      return true;\n+\n+    case OPT_m4a:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH4A;\n+      return true;\n+\n+    case OPT_m4a_nofpu:\n+    case OPT_m4al:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH4A_NOFPU;\n+      return true;\n+\n+    case OPT_m4a_single:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH4A_SINGLE;\n+      return true;\n+\n+    case OPT_m4a_single_only:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH4A_SINGLE_ONLY;\n+      return true;\n+\n+    case OPT_m5_32media:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH5_32MEDIA;\n+      return true;\n+\n+    case OPT_m5_32media_nofpu:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH5_32MEDIA_NOFPU;\n+      return true;\n+\n+    case OPT_m5_64media:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH5_64MEDIA;\n+      return true;\n+\n+    case OPT_m5_64media_nofpu:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH5_64MEDIA_NOFPU;\n+      return true;\n+\n+    case OPT_m5_compact:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH5_COMPACT;\n+      return true;\n+\n+    case OPT_m5_compact_nofpu:\n+      target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH5_COMPACT_NOFPU;\n+      return true;\n+\n+    default:\n+      return true;\n+    }\n+}\n+\f\n /* Print the operand address in x to the stream.  */\n \n void\n@@ -5236,7 +5348,7 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n   CLEAR_HARD_REG_SET (*live_regs_mask);\n   if ((TARGET_SH4 || TARGET_SH2A_DOUBLE) && TARGET_FMOVD && interrupt_handler\n       && regs_ever_live[FPSCR_REG])\n-    target_flags &= ~FPU_SINGLE_BIT;\n+    target_flags &= ~MASK_FPU_SINGLE;\n   /* If we can save a lot of saves by switching to double mode, do that.  */\n   else if ((TARGET_SH4 || TARGET_SH2A_DOUBLE) && TARGET_FMOVD && TARGET_FPU_SINGLE)\n     for (count = 0, reg = FIRST_FP_REG; reg <= LAST_FP_REG; reg += 2)\n@@ -5245,7 +5357,7 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n \t      || (interrupt_handler && ! pragma_trapa))\n \t  && ++count > 2)\n \t{\n-\t  target_flags &= ~FPU_SINGLE_BIT;\n+\t  target_flags &= ~MASK_FPU_SINGLE;\n \t  break;\n \t}\n   /* PR_MEDIA_REG is a general purpose register, thus global_alloc already\n@@ -5327,7 +5439,7 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n \t      else if (XD_REGISTER_P (reg))\n \t\t{\n \t\t  /* Must switch to double mode to access these registers.  */\n-\t\t  target_flags &= ~FPU_SINGLE_BIT;\n+\t\t  target_flags &= ~MASK_FPU_SINGLE;\n \t\t}\n \t    }\n \t}\n@@ -7403,17 +7515,7 @@ sh_cfun_interrupt_handler_p (void)\n \t  != NULL_TREE);\n }\n \n-/* ??? target_switches in toplev.c is static, hence we have to duplicate it.  */\n-static const struct\n-{\n-  const char *const name;\n-  const int value;\n-  const char *const description;\n-}\n-sh_target_switches[] = TARGET_SWITCHES;\n-#define target_switches sh_target_switches\n-\n-/* Like default_pch_valid_p, but take flag_mask into account.  */\n+/* Like default_pch_valid_p, but only check certain target_flags.  */\n const char *\n sh_pch_valid_p (const void *data_p, size_t len)\n {\n@@ -7433,9 +7535,6 @@ sh_pch_valid_p (const void *data_p, size_t len)\n   const char *flag_that_differs = NULL;\n   size_t i;\n   int old_flags;\n-  int flag_mask\n-    = (SH1_BIT | SH2_BIT | SH3_BIT | SH_E_BIT | HARD_SH4_BIT | FPU_SINGLE_BIT\n-       | SH4_BIT | HITACHI_BIT | LITTLE_ENDIAN_BIT);\n \n   /* -fpic and -fpie also usually make a PCH invalid.  */\n   if (data[0] != flag_pic)\n@@ -7446,24 +7545,15 @@ sh_pch_valid_p (const void *data_p, size_t len)\n \n   /* Check target_flags.  */\n   memcpy (&old_flags, data, sizeof (target_flags));\n-  if (((old_flags ^ target_flags) & flag_mask) != 0)\n-    {\n-      for (i = 0; i < ARRAY_SIZE (target_switches); i++)\n-\t{\n-\t  int bits;\n+  if ((old_flags ^ target_flags) & (MASK_SH1 | MASK_SH2 | MASK_SH3\n+\t\t\t\t    | MASK_SH_E | MASK_HARD_SH4\n+\t\t\t\t    | MASK_FPU_SINGLE | MASK_SH4))\n+    return _(\"created and used with different architectures / ABIs\");\n+  if ((old_flags ^ target_flags) & MASK_HITACHI)\n+    return _(\"created and used with different ABIs\");\n+  if ((old_flags ^ target_flags) & MASK_LITTLE_ENDIAN)\n+    return _(\"created and used with different endianness\");\n \n-\t  bits = target_switches[i].value;\n-\t  if (bits < 0)\n-\t    bits = -bits;\n-\t  bits &= flag_mask;\n-\t  if ((target_flags & bits) != (old_flags & bits))\n-\t    {\n-\t      flag_that_differs = target_switches[i].name;\n-\t      goto make_message;\n-\t    }\n-\t}\n-      gcc_unreachable ();\n-    }\n   data += sizeof (target_flags);\n   len -= sizeof (target_flags);\n \n@@ -10649,7 +10739,7 @@ sh_init_cumulative_args (CUMULATIVE_ARGS *  pcum,\n \t     the TYPE or the FNDECL available so we synthesize the\n \t     contents of that function as best we can.  */\n \t  pcum->force_mem =\n-\t    (TARGET_DEFAULT & HITACHI_BIT)\n+\t    (TARGET_DEFAULT & MASK_HITACHI)\n \t    && (mode == BLKmode\n \t\t|| (GET_MODE_SIZE (mode) > 4\n \t\t    && !(mode == DFmode"}, {"sha": "92d8ce00696927998c0b993af79d57fea7b4bbff", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 103, "deletions": 422, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=c0fb94d7250e1311bfd2724f3df629999f1a291b", "patch": "@@ -148,108 +148,49 @@ do { \\\n \tSET_HARD_REG_BIT (reg_class_contents[SIBCALL_REGS], regno);\t\\\n } while (0)\n \f\n-/* ??? Need to write documentation for all SH options and add it to the\n-   invoke.texi file.  */\n-\n-/* Run-time compilation parameters selecting different hardware subsets.  */\n-\n-extern int target_flags;\n-#define ISIZE_BIT      \t(1<<1)\n-#define DALIGN_BIT     \t(1<<6)\n-#define SH1_BIT\t       \t(1<<8)\n-#define SH2_BIT\t       \t(1<<9)\n-#define SH3_BIT\t       \t(1<<10)\n-#define SH_E_BIT\t(1<<11)\n-#define HARD_SH4_BIT\t(1<<5)\n-#define FPU_SINGLE_BIT\t(1<<7)\n-#define SH4_BIT\t       \t(1<<12)\n-#define SH4A_BIT\t(1<<3)\n-#define FMOVD_BIT\t(1<<4)\n-#define SH5_BIT\t\t(1<<0)\n-#define SPACE_BIT \t(1<<13)\n-#define BIGTABLE_BIT  \t(1<<14)\n-#define RELAX_BIT\t(1<<15)\n-#define USERMODE_BIT\t(1<<16)\n-#define HITACHI_BIT     (1<<22)\n-#define NOMACSAVE_BIT   (1<<23)\n-#define PREFERGOT_BIT\t(1<<24)\n-#define PADSTRUCT_BIT  (1<<28)\n-#define LITTLE_ENDIAN_BIT (1<<29)\n-#define IEEE_BIT (1<<30)\n-#define SAVE_ALL_TR_BIT (1<<2)\n-#define HARD_SH2A_BIT\t(1<<17)\n-#define HARD_SH2A_DOUBLE_BIT\t(1<<18)\n-#define INDEXED_ADDRESS_BIT (1<<19)\n-#define PT_FIXED_BIT\t(1<<21)\n-#define INVALID_SYMBOLS_BIT (1<<25)\n-#define ADJUST_UNROLL_BIT (1<<20)\n-\n /* Nonzero if this is an ELF target - compile time only */\n #define TARGET_ELF 0\n \n-/* Nonzero if we should dump out instruction size info.  */\n-#define TARGET_DUMPISIZE  (target_flags & ISIZE_BIT)\n-\n-/* Nonzero to align doubles on 64 bit boundaries.  */\n-#define TARGET_ALIGN_DOUBLE (target_flags & DALIGN_BIT)\n-\n-/* Nonzero if we should generate code using type 1 insns.  */\n-#define TARGET_SH1 (target_flags & SH1_BIT)\n-\n-/* Nonzero if we should generate code using type 2 insns.  */\n-#define TARGET_SH2 (target_flags & SH2_BIT)\n-\n /* Nonzero if we should generate code using type 2E insns.  */\n-#define TARGET_SH2E ((target_flags & SH_E_BIT) && TARGET_SH2)\n+#define TARGET_SH2E (TARGET_SH2 && TARGET_SH_E)\n \n /* Nonzero if we should generate code using type 2A insns.  */\n-#define TARGET_SH2A (target_flags & HARD_SH2A_BIT)\n+#define TARGET_SH2A TARGET_HARD_SH2A\n /* Nonzero if we should generate code using type 2A SF insns.  */\n-#define TARGET_SH2A_SINGLE ((target_flags & HARD_SH2A_BIT) && TARGET_SH2E)\n+#define TARGET_SH2A_SINGLE (TARGET_SH2A && TARGET_SH2E)\n /* Nonzero if we should generate code using type 2A DF insns.  */\n-#define TARGET_SH2A_DOUBLE ((target_flags & HARD_SH2A_DOUBLE_BIT) && TARGET_SH2A)\n-\n-/* Nonzero if we should generate code using type 3 insns.  */\n-#define TARGET_SH3 (target_flags & SH3_BIT)\n+#define TARGET_SH2A_DOUBLE (TARGET_HARD_SH2A_DOUBLE && TARGET_SH2A)\n \n /* Nonzero if we should generate code using type 3E insns.  */\n-#define TARGET_SH3E ((target_flags & SH_E_BIT) && TARGET_SH3)\n+#define TARGET_SH3E (TARGET_SH3 && TARGET_SH_E)\n \n /* Nonzero if the cache line size is 32.  */\n-#define TARGET_CACHE32 (target_flags & HARD_SH4_BIT || TARGET_SH5)\n+#define TARGET_CACHE32 (TARGET_HARD_SH4 || TARGET_SH5)\n \n /* Nonzero if we schedule for a superscalar implementation.  */\n-#define TARGET_SUPERSCALAR (target_flags & HARD_SH4_BIT)\n+#define TARGET_SUPERSCALAR TARGET_HARD_SH4\n \n /* Nonzero if the target has separate instruction and data caches.  */\n-#define TARGET_HARVARD (target_flags & HARD_SH4_BIT || TARGET_SH5)\n-\n-/* Nonzero if compiling for SH4 hardware (to be used for insn costs etc.)  */\n-#define TARGET_HARD_SH4 (target_flags & HARD_SH4_BIT)\n-\n-/* Nonzero if the default precision of th FPU is single */\n-#define TARGET_FPU_SINGLE (target_flags & FPU_SINGLE_BIT)\n+#define TARGET_HARVARD (TARGET_HARD_SH4 || TARGET_SH5)\n \n /* Nonzero if a double-precision FPU is available.  */\n-#define TARGET_FPU_DOUBLE ((target_flags & SH4_BIT) || TARGET_SH2A_DOUBLE)\n+#define TARGET_FPU_DOUBLE (TARGET_SH4 || TARGET_SH2A_DOUBLE)\n \n /* Nonzero if an FPU is available.  */\n #define TARGET_FPU_ANY (TARGET_SH2E || TARGET_FPU_DOUBLE)\n \n /* Nonzero if we should generate code using type 4 insns.  */\n-#define TARGET_SH4 ((target_flags & SH4_BIT) && (target_flags & SH1_BIT))\n+#undef TARGET_SH4\n+#define TARGET_SH4 ((target_flags & MASK_SH4) != 0 && TARGET_SH1)\n \n /* Nonzero if we're generating code for the common subset of\n    instructions present on both SH4a and SH4al-dsp.  */\n-#define TARGET_SH4A_ARCH (target_flags & SH4A_BIT)\n+#define TARGET_SH4A_ARCH TARGET_SH4A\n \n /* Nonzero if we're generating code for SH4a, unless the use of the\n    FPU is disabled (which makes it compatible with SH4al-dsp).  */\n #define TARGET_SH4A_FP (TARGET_SH4A_ARCH && TARGET_FPU_ANY)\n \n-/* Nonzero if we should generate code for a SH5 CPU (either ISA).  */\n-#define TARGET_SH5 (target_flags & SH5_BIT)\n-\n /* Nonzero if we should generate code using the SHcompact instruction\n    set and 32-bit ABI.  */\n #define TARGET_SHCOMPACT (TARGET_SH5 && TARGET_SH1)\n@@ -260,55 +201,14 @@ extern int target_flags;\n \n /* Nonzero if we should generate code using the SHmedia ISA and 32-bit\n    ABI.  */\n-#define TARGET_SHMEDIA32 (TARGET_SH5 && ! TARGET_SH1 \\\n-\t\t\t  && (target_flags & SH_E_BIT))\n+#define TARGET_SHMEDIA32 (TARGET_SH5 && ! TARGET_SH1 && TARGET_SH_E)\n \n /* Nonzero if we should generate code using the SHmedia ISA and 64-bit\n    ABI.  */\n-#define TARGET_SHMEDIA64 (TARGET_SH5 && ! TARGET_SH1 \\\n- \t\t\t  && ! (target_flags & SH_E_BIT))\n+#define TARGET_SHMEDIA64 (TARGET_SH5 && ! TARGET_SH1 && ! TARGET_SH_E)\n \n /* Nonzero if we should generate code using SHmedia FPU instructions.  */\n #define TARGET_SHMEDIA_FPU (TARGET_SHMEDIA && TARGET_FPU_DOUBLE)\n-/* Nonzero if we should generate fmovd.  */\n-#define TARGET_FMOVD (target_flags & FMOVD_BIT)\n-\n-/* Nonzero if we respect NANs.  */\n-#define TARGET_IEEE (target_flags & IEEE_BIT)\n-\n-/* Nonzero if we should generate smaller code rather than faster code.  */\n-#define TARGET_SMALLCODE   (target_flags & SPACE_BIT)\n-\n-/* Nonzero to use long jump tables.  */\n-#define TARGET_BIGTABLE     (target_flags & BIGTABLE_BIT)\n-\n-/* Nonzero to generate pseudo-ops needed by the assembler and linker\n-   to do function call relaxing.  */\n-#define TARGET_RELAX (target_flags & RELAX_BIT)\n-\n-/* Nonzero if using Renesas's calling convention.  */\n-#define TARGET_HITACHI \t\t(target_flags & HITACHI_BIT)\n-\n-/* Nonzero if not saving macl/mach when using -mhitachi */\n-#define TARGET_NOMACSAVE\t(target_flags & NOMACSAVE_BIT)\n-\n-/* Nonzero if padding structures to a multiple of 4 bytes.  This is\n-   incompatible with Renesas's compiler, and gives unusual structure layouts\n-   which confuse programmers.\n-   ??? This option is not useful, but is retained in case there are people\n-   who are still relying on it.  It may be deleted in the future.  */\n-#define TARGET_PADSTRUCT       (target_flags & PADSTRUCT_BIT)\n-\n-/* Nonzero if generating code for a little endian SH.  */\n-#define TARGET_LITTLE_ENDIAN     (target_flags & LITTLE_ENDIAN_BIT)\n-\n-/* Nonzero if we should do everything in userland.  */\n-#define TARGET_USERMODE\t\t(target_flags & USERMODE_BIT)\n-\n-/* Nonzero if we should prefer @GOT calls when generating PIC.  */\n-#define TARGET_PREFERGOT\t(target_flags & PREFERGOT_BIT)\n-\n-#define TARGET_SAVE_ALL_TARGET_REGS (target_flags & SAVE_ALL_TR_BIT)\n \n /* This is not used by the SH2E calling convention  */\n #define TARGET_VARARGS_PRETEND_ARGS(FUN_DECL) \\\n@@ -317,12 +217,12 @@ extern int target_flags;\n \n #ifndef TARGET_CPU_DEFAULT\n #define TARGET_CPU_DEFAULT SELECT_SH1\n-#define SUPPORT_SH1\n-#define SUPPORT_SH2E\n-#define SUPPORT_SH4\n-#define SUPPORT_SH4_SINGLE\n-#define SUPPORT_SH2A\n-#define SUPPORT_SH2A_SINGLE\n+#define SUPPORT_SH1 1\n+#define SUPPORT_SH2E 1\n+#define SUPPORT_SH4 1\n+#define SUPPORT_SH4_SINGLE 1\n+#define SUPPORT_SH2A 1\n+#define SUPPORT_SH2A_SINGLE 1\n #endif\n \n #define TARGET_DIVIDE_INV \\\n@@ -339,315 +239,96 @@ extern int target_flags;\n #define TARGET_DIVIDE_INV_CALL (sh_div_strategy == SH_DIV_INV_CALL)\n #define TARGET_DIVIDE_INV_CALL2 (sh_div_strategy == SH_DIV_INV_CALL2)\n \n-/* Target macros pertaining to SHmedia architecture bugs.  */\n-#define TARGET_ALLOW_INDEXED_ADDRESS (target_flags & INDEXED_ADDRESS_BIT)\n-#define TARGET_PT_FIXED (target_flags & PT_FIXED_BIT)\n-#define TARGET_INVALID_SYMBOLS (target_flags & INVALID_SYMBOLS_BIT)\n-\n-#define TARGET_ADJUST_UNROLL (target_flags & ADJUST_UNROLL_BIT)\n-\n-#define SELECT_SH1               (SH1_BIT)\n-#define SELECT_SH2               (SH2_BIT | SELECT_SH1)\n-#define SELECT_SH2E              (SH_E_BIT | SH2_BIT | SH1_BIT | FPU_SINGLE_BIT)\n-#define SELECT_SH2A              (SH_E_BIT | HARD_SH2A_BIT | HARD_SH2A_DOUBLE_BIT | SH2_BIT | SH1_BIT)\n-#define SELECT_SH2A_NOFPU        (HARD_SH2A_BIT | SH2_BIT | SH1_BIT)\n-#define SELECT_SH2A_SINGLE_ONLY  (SH_E_BIT | HARD_SH2A_BIT | SH2_BIT | SH1_BIT | FPU_SINGLE_BIT)\n-#define SELECT_SH2A_SINGLE       (SH_E_BIT | HARD_SH2A_BIT | FPU_SINGLE_BIT \\\n-\t\t\t\t  | HARD_SH2A_DOUBLE_BIT | SH2_BIT | SH1_BIT)\n-#define SELECT_SH3               (SH3_BIT | SELECT_SH2)\n-#define SELECT_SH3E              (SH_E_BIT | FPU_SINGLE_BIT | SELECT_SH3)\n-#define SELECT_SH4_NOFPU         (HARD_SH4_BIT | SELECT_SH3)\n-#define SELECT_SH4_SINGLE_ONLY   (HARD_SH4_BIT | SELECT_SH3E)\n-#define SELECT_SH4               (SH4_BIT | SH_E_BIT | HARD_SH4_BIT | SELECT_SH3)\n-#define SELECT_SH4_SINGLE        (FPU_SINGLE_BIT | SELECT_SH4)\n-#define SELECT_SH4A_NOFPU        (SH4A_BIT | SELECT_SH4_NOFPU)\n-#define SELECT_SH4A_SINGLE_ONLY  (SH4A_BIT | SELECT_SH4_SINGLE_ONLY)\n-#define SELECT_SH4A              (SH4A_BIT | SELECT_SH4)\n-#define SELECT_SH4A_SINGLE       (SH4A_BIT | SELECT_SH4_SINGLE)\n-#define SELECT_SH5_64MEDIA       (SH5_BIT | SH4_BIT)\n-#define SELECT_SH5_64MEDIA_NOFPU (SH5_BIT)\n-#define SELECT_SH5_32MEDIA       (SH5_BIT | SH4_BIT | SH_E_BIT)\n-#define SELECT_SH5_32MEDIA_NOFPU (SH5_BIT | SH_E_BIT)\n-#define SELECT_SH5_COMPACT       (SH5_BIT | SH4_BIT | SELECT_SH3E)\n-#define SELECT_SH5_COMPACT_NOFPU (SH5_BIT | SELECT_SH3)\n-\n-/* Disable processor switches for which we have no suitable multilibs.  */\n-#ifndef SUPPORT_SH1\n-#define TARGET_SWITCH_SH1\n-#ifndef SUPPORT_SH2\n-#define TARGET_SWITCH_SH2\n-#ifndef SUPPORT_SH3\n-#define TARGET_SWITCH_SH3\n-#ifndef SUPPORT_SH4_NOFPU\n-#define TARGET_SWITCH_SH4_NOFPU\n-#endif\n-#ifndef SUPPORT_SH4A_NOFPU\n-#define TARGET_SWITCH_SH4A_NOFPU\n-#endif\n-#ifndef SUPPORT_SH4AL\n-#define TARGET_SWITCH_SH4AL\n-#endif\n-#ifndef SUPPORT_SH2A_NOFPU\n-#define TARGET_SWITCH_SH2A_NOFPU\n-#endif\n-#endif\n-#endif\n-#endif\n+#define SELECT_SH1               (MASK_SH1)\n+#define SELECT_SH2               (MASK_SH2 | SELECT_SH1)\n+#define SELECT_SH2E              (MASK_SH_E | MASK_SH2 | MASK_SH1 \\\n+\t\t\t\t  | MASK_FPU_SINGLE)\n+#define SELECT_SH2A              (MASK_SH_E | MASK_HARD_SH2A \\\n+\t\t\t\t  | MASK_HARD_SH2A_DOUBLE \\\n+\t\t\t\t  | MASK_SH2 | MASK_SH1)\n+#define SELECT_SH2A_NOFPU        (MASK_HARD_SH2A | MASK_SH2 | MASK_SH1)\n+#define SELECT_SH2A_SINGLE_ONLY  (MASK_SH_E | MASK_HARD_SH2A | MASK_SH2 \\\n+\t\t\t\t  | MASK_SH1 | MASK_FPU_SINGLE)\n+#define SELECT_SH2A_SINGLE       (MASK_SH_E | MASK_HARD_SH2A \\\n+\t\t\t\t  | MASK_FPU_SINGLE | MASK_HARD_SH2A_DOUBLE \\\n+\t\t\t\t  | MASK_SH2 | MASK_SH1)\n+#define SELECT_SH3               (MASK_SH3 | SELECT_SH2)\n+#define SELECT_SH3E              (MASK_SH_E | MASK_FPU_SINGLE | SELECT_SH3)\n+#define SELECT_SH4_NOFPU         (MASK_HARD_SH4 | SELECT_SH3)\n+#define SELECT_SH4_SINGLE_ONLY   (MASK_HARD_SH4 | SELECT_SH3E)\n+#define SELECT_SH4               (MASK_SH4 | MASK_SH_E | MASK_HARD_SH4 \\\n+\t\t\t\t  | SELECT_SH3)\n+#define SELECT_SH4_SINGLE        (MASK_FPU_SINGLE | SELECT_SH4)\n+#define SELECT_SH4A_NOFPU        (MASK_SH4A | SELECT_SH4_NOFPU)\n+#define SELECT_SH4A_SINGLE_ONLY  (MASK_SH4A | SELECT_SH4_SINGLE_ONLY)\n+#define SELECT_SH4A              (MASK_SH4A | SELECT_SH4)\n+#define SELECT_SH4A_SINGLE       (MASK_SH4A | SELECT_SH4_SINGLE)\n+#define SELECT_SH5_64MEDIA       (MASK_SH5 | MASK_SH4)\n+#define SELECT_SH5_64MEDIA_NOFPU (MASK_SH5)\n+#define SELECT_SH5_32MEDIA       (MASK_SH5 | MASK_SH4 | MASK_SH_E)\n+#define SELECT_SH5_32MEDIA_NOFPU (MASK_SH5 | MASK_SH_E)\n+#define SELECT_SH5_COMPACT       (MASK_SH5 | MASK_SH4 | SELECT_SH3E)\n+#define SELECT_SH5_COMPACT_NOFPU (MASK_SH5 | SELECT_SH3)\n \n-#ifndef SUPPORT_SH2E\n-#define TARGET_SWITCH_SH2E\n-#ifndef SUPPORT_SH3E\n-#define TARGET_SWITCH_SH3E\n-#ifndef SUPPORT_SH4_SINGLE_ONLY\n-#define TARGET_SWITCH_SH4_SINGLE_ONLY\n-#endif\n-#ifndef SUPPORT_SH4A_SINGLE_ONLY\n-#define TARGET_SWITCH_SH4A_SINGLE_ONLY\n-#endif\n-#ifndef SUPPORT_SH2A_SINGLE_ONLY\n-#define TARGET_SWITCH_SH2A_SINGLE_ONLY\n-#endif\n+#if SUPPORT_SH1\n+#define SUPPORT_SH2 1\n #endif\n+#if SUPPORT_SH2\n+#define SUPPORT_SH3 1\n #endif\n-\n-#ifndef SUPPORT_SH4\n-#define TARGET_SWITCH_SH4\n-#ifndef SUPPORT_SH4A\n-#define TARGET_SWITCH_SH4A\n+#if SUPPORT_SH3\n+#define SUPPORT_SH4_NOFPU 1\n #endif\n+#if SUPPORT_SH4_NOFPU\n+#define SUPPORT_SH4A_NOFPU 1\n+#define SUPPORT_SH4AL 1\n+#define SUPPORT_SH2A_NOFPU 1\n #endif\n \n-#ifndef SUPPORT_SH4_SINGLE\n-#define TARGET_SWITCH_SH4_SINGLE\n-#ifndef SUPPORT_SH4A_SINGLE\n-#define TARGET_SWITCH_SH4A_SINGLE\n-#endif\n+#if SUPPORT_SH2E\n+#define SUPPORT_SH3E 1\n #endif\n-\n-#ifndef SUPPORT_SH2A\n-#define TARGET_SWITCH_SH2A\n+#if SUPPORT_SH3E\n+#define SUPPORT_SH4_SINGLE_ONLY 1\n+#define SUPPORT_SH4A_SINGLE_ONLY 1\n+#define SUPPORT_SH2A_SINGLE_ONLY 1\n #endif\n \n-#ifndef SUPPORT_SH2A_SINGLE\n-#define TARGET_SWITCH_SH2A_SINGLE\n+#if SUPPORT_SH4\n+#define SUPPORT_SH4A 1\n #endif\n \n-#ifndef SUPPORT_SH5_64MEDIA\n-#define TARGET_SWITCH_SH5_64MEDIA\n+#if SUPPORT_SH4_SINGLE\n+#define SUPPORT_SH4A_SINGLE 1\n #endif\n \n-#ifndef SUPPORT_SH5_64MEDIA_NOFPU\n-#define TARGET_SWITCH_SH5_64MEDIA_NOFPU\n+#if SUPPORT_SH5_COMPAT\n+#define SUPPORT_SH5_32MEDIA 1\n #endif\n \n-#if !defined(SUPPORT_SH5_32MEDIA) && !defined (SUPPORT_SH5_COMPACT)\n-#define TARGET_SWITCHES_SH5_32MEDIA\n+#if SUPPORT_SH5_COMPACT_NOFPU\n+#define SUPPORT_SH5_32MEDIA_NOFPU 1\n #endif\n \n-#if !defined(SUPPORT_SH5_32MEDIA_NOFPU) && !defined (SUPPORT_SH5_COMPACT_NOFPU)\n-#define TARGET_SWITCHES_SH5_32MEDIA_NOFPU\n-#endif\n-\n-#if defined(TARGET_SWITCHES_SH5_32MEDIA) && defined(TARGET_SWITCHES_SH5_32MEDIA_NOFPU)\n-#define TARGET_SWITCH_SH5_32_ANY_EXTRA\n-#endif\n-\n-#if defined(TARGET_SWITCH_SH5_32_ANY_EXTRA) && !defined(SUPPORT_SH5_64MEDIA) && !defined(SUPPORT_SH5_64MEDIA_NOFPU)\n-#define TARGET_SWITCH_SH5_MEDIA_ANY_EXTRA\n-#endif\n+#define SUPPORT_ANY_SH5_32MEDIA \\\n+  (SUPPORT_SH5_32MEDIA || SUPPORT_SH5_32MEDIA_NOFPU)\n+#define SUPPORT_ANY_SH5_64MEDIA \\\n+  (SUPPORT_SH5_64MEDIA || SUPPORT_SH5_64MEDIA_NOFPU)\n+#define SUPPORT_ANY_SH5 \\\n+  (SUPPORT_ANY_SH5_32MEDIA || SUPPORT_ANY_SH5_64MEDIA)\n \n /* Reset all target-selection flags.  */\n-#define TARGET_NONE -(SH1_BIT | SH2_BIT | SH3_BIT | SH_E_BIT | SH4_BIT \\\n-\t\t      | HARD_SH2A_BIT | HARD_SH2A_DOUBLE_BIT \\\n-\t\t      | SH4A_BIT | HARD_SH4_BIT | FPU_SINGLE_BIT | SH5_BIT)\n-\n-#ifndef TARGET_SWITCH_SH1\n-#define TARGET_SWITCH_SH1 \\\n-  {\"1\",\t\tTARGET_NONE, \"\" }, \\\n-  {\"1\",\t\tSELECT_SH1, \"Generate SH1 code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH2\n-#define TARGET_SWITCH_SH2 \\\n-  {\"2\",\t\tTARGET_NONE, \"\" }, \\\n-  {\"2\",\t\tSELECT_SH2, \"Generate SH2 code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH2E\n-#define TARGET_SWITCH_SH2E \\\n-  {\"2e\",\tTARGET_NONE, \"\" }, \\\n-  {\"2e\",\tSELECT_SH2E, \"Generate SH2e code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH2A\n-#define TARGET_SWITCH_SH2A \\\n-  {\"2a\",\tTARGET_NONE, \"\" }, \\\n-  {\"2a\",\tSELECT_SH2A, \"Generate SH2a code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH2A_SINGLE_ONLY\n-#define TARGET_SWITCH_SH2A_SINGLE_ONLY \\\n-  {\"2a-single-only\", TARGET_NONE, \"\" },\t\\\n-  {\"2a-single-only\", SELECT_SH2A_SINGLE_ONLY, \"Generate only single-precision SH2a code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH2A_SINGLE\n-#define TARGET_SWITCH_SH2A_SINGLE \\\n-  {\"2a-single\", TARGET_NONE, \"\" },\t\\\n-  {\"2a-single\", SELECT_SH2A_SINGLE, \"Generate default single-precision SH2a code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH2A_NOFPU\n-#define TARGET_SWITCH_SH2A_NOFPU \\\n-  {\"2a-nofpu\",  TARGET_NONE, \"\" },\t\\\n-  {\"2a-nofpu\",  SELECT_SH2A_NOFPU, \"Generate SH2a FPU-less code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH3\n-#define TARGET_SWITCH_SH3 \\\n-  {\"3\",\t\tTARGET_NONE, \"\" }, \\\n-  {\"3\",\t\tSELECT_SH3, \"Generate SH3 code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH3E\n-#define TARGET_SWITCH_SH3E \\\n-  {\"3e\",\tTARGET_NONE, \"\" }, \\\n-  {\"3e\",\tSELECT_SH3E, \"Generate SH3e code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH4_SINGLE_ONLY\n-#define TARGET_SWITCH_SH4_SINGLE_ONLY \\\n-  {\"4-single-only\",\tTARGET_NONE, \"\" }, \\\n-  {\"4-single-only\",\tSELECT_SH4_SINGLE_ONLY, \"Generate only single-precision SH4 code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH4_SINGLE\n-#define TARGET_SWITCH_SH4_SINGLE \\\n-  {\"4-single\",\tTARGET_NONE, \"\" }, \\\n-  {\"4-single\",\tSELECT_SH4_SINGLE, \"Generate default single-precision SH4 code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH4_NOFPU\n-#define TARGET_SWITCH_SH4_NOFPU \\\n-  {\"4-nofpu\",\tTARGET_NONE, \"\" }, \\\n-  {\"4-nofpu\",\tSELECT_SH4_NOFPU, \"Generate SH4 FPU-less code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH4\n-#define TARGET_SWITCH_SH4 \\\n-  {\"4\",\t\tTARGET_NONE, \"\" }, \\\n-  {\"4\",\t\tSELECT_SH4, \"Generate SH4 code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH4A\n-#define TARGET_SWITCH_SH4A \\\n-  {\"4a\",\tTARGET_NONE, \"\" }, \\\n-  {\"4a\",\tSELECT_SH4A, \"Generate SH4a code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH4A_SINGLE_ONLY\n-#define TARGET_SWITCH_SH4A_SINGLE_ONLY \\\n-  {\"4a-single-only\",\tTARGET_NONE, \"\" },\t\\\n-  {\"4a-single-only\",\tSELECT_SH4A_SINGLE_ONLY, \"Generate only single-precision SH4a code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH4A_SINGLE\n-#define TARGET_SWITCH_SH4A_SINGLE \\\n-  {\"4a-single\",\tTARGET_NONE, \"\" },\\\n-  {\"4a-single\",\tSELECT_SH4A_SINGLE, \"Generate default single-precision SH4a code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH4A_NOFPU\n-#define TARGET_SWITCH_SH4A_NOFPU \\\n-  {\"4a-nofpu\",\tTARGET_NONE, \"\" },\\\n-  {\"4a-nofpu\",\tSELECT_SH4A_NOFPU, \"Generate SH4a FPU-less code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH4AL\n-#define TARGET_SWITCH_SH4AL \\\n-  {\"4al\",\tTARGET_NONE, \"\" },\\\n-  {\"4al\",\tSELECT_SH4A_NOFPU, \"Generate SH4al-dsp code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH5_64MEDIA\n-#define TARGET_SWITCH_SH5_64MEDIA \\\n-  {\"5-64media\",\tTARGET_NONE, \"\" },\t\t\\\n-  {\"5-64media\", SELECT_SH5_64MEDIA, \"Generate 64-bit SHmedia code\" },\n-#endif\n-#ifndef TARGET_SWITCH_SH5_64MEDIA_NOFPU\n-#define TARGET_SWITCH_SH5_64MEDIA_NOFPU \\\n-  {\"5-64media-nofpu\", TARGET_NONE, \"\" },\t\\\n-  {\"5-64media-nofpu\", SELECT_SH5_64MEDIA_NOFPU, \"Generate 64-bit FPU-less SHmedia code\" },\n-#endif\n-#ifndef TARGET_SWITCHES_SH5_32MEDIA\n-#define TARGET_SWITCHES_SH5_32MEDIA \\\n-  {\"5-32media\",\tTARGET_NONE, \"\" },\t\t\\\n-  {\"5-32media\", SELECT_SH5_32MEDIA, \"Generate 32-bit SHmedia code\" }, \\\n-  {\"5-compact\",\tTARGET_NONE, \"\" },\t\t\\\n-  {\"5-compact\",\tSELECT_SH5_COMPACT, \"Generate SHcompact code\" },\n-#endif\n-#ifndef TARGET_SWITCHES_SH5_32MEDIA_NOFPU\n-#define TARGET_SWITCHES_SH5_32MEDIA_NOFPU \\\n-  {\"5-32media-nofpu\", TARGET_NONE, \"\" },\t\\\n-  {\"5-32media-nofpu\", SELECT_SH5_32MEDIA_NOFPU, \"Generate 32-bit FPU-less SHmedia code\" }, \\\n-  {\"5-compact-nofpu\", TARGET_NONE, \"\" },\t\\\n-  {\"5-compact-nofpu\", SELECT_SH5_COMPACT_NOFPU, \"Generate FPU-less SHcompact code\" },\n-#endif\n-\n-#ifndef TARGET_SWITCH_SH5_32_ANY_EXTRA\n-#define TARGET_SWITCH_SH5_32_ANY_EXTRA \\\n-  {\"indexed-addressing\", INDEXED_ADDRESS_BIT, \"Enable the use of the indexed addressing mode for SHmedia32/SHcompact\"}, \\\n-  {\"no-indexed-addressing\", -INDEXED_ADDRESS_BIT, \"Disable the use of the indexed addressing mode for SHmedia32/SHcompact\"},\n-#endif\n-\n-#ifndef TARGET_SWITCH_SH5_MEDIA_ANY_EXTRA\n-#define TARGET_SWITCH_SH5_MEDIA_ANY_EXTRA \\\n-  {\"pt-fixed\",\tPT_FIXED_BIT, \"Assume pt* instructions won't trap\"}, \\\n-  {\"no-pt-fixed\", -PT_FIXED_BIT, \"Assume pt* instructions may trap\"}, \\\n-  {\"invalid-symbols\",INVALID_SYMBOLS_BIT, \"Assume symbols might be invalid\"}, \\\n-  {\"no-invalid-symbols\",-INVALID_SYMBOLS_BIT, \"Assume symbols won't be invalid\"}, \\\n-  {\"adjust-unroll\", ADJUST_UNROLL_BIT, \"Throttle unrolling to avoid thrashing target registers unless the unroll benefit outweighs this\"}, \\\n-  {\"no-adjust-unroll\", -ADJUST_UNROLL_BIT, \"Don't throttle unrolling\"},\n-#endif\n-\n-#define TARGET_SWITCHES \\\n-{ TARGET_SWITCH_SH1 \\\n-  TARGET_SWITCH_SH2 \\\n-  TARGET_SWITCH_SH2A_SINGLE_ONLY \\\n-  TARGET_SWITCH_SH2A_SINGLE \\\n-  TARGET_SWITCH_SH2A_NOFPU \\\n-  TARGET_SWITCH_SH2A \\\n-  TARGET_SWITCH_SH2E \\\n-  TARGET_SWITCH_SH3 \\\n-  TARGET_SWITCH_SH3E \\\n-  TARGET_SWITCH_SH4_SINGLE_ONLY \\\n-  TARGET_SWITCH_SH4_SINGLE \\\n-  TARGET_SWITCH_SH4_NOFPU \\\n-  TARGET_SWITCH_SH4 \\\n-  TARGET_SWITCH_SH4A_SINGLE_ONLY \\\n-  TARGET_SWITCH_SH4A_SINGLE \\\n-  TARGET_SWITCH_SH4A_NOFPU \\\n-  TARGET_SWITCH_SH4A \\\n-  TARGET_SWITCH_SH4AL \\\n-  TARGET_SWITCH_SH5_64MEDIA \\\n-  TARGET_SWITCH_SH5_64MEDIA_NOFPU \\\n-  TARGET_SWITCHES_SH5_32MEDIA \\\n-  TARGET_SWITCHES_SH5_32MEDIA_NOFPU \\\n-  {\"b\",\t\t-LITTLE_ENDIAN_BIT, \"Generate code in big endian mode\" }, \\\n-  {\"bigtable\", \tBIGTABLE_BIT, \"Generate 32-bit offsets in switch tables\" }, \\\n-  {\"dalign\",  \tDALIGN_BIT, \"Aligns doubles at 64-bit boundaries\" },\t\\\n-  {\"fmovd\",  \tFMOVD_BIT, \"\" },\t\t\t\t\t\\\n-  {\"hitachi\",\tHITACHI_BIT, \"Follow Renesas (formerly Hitachi) / SuperH calling conventions\" }, \\\n-  {\"renesas\",\tHITACHI_BIT, \"Follow Renesas (formerly Hitachi) / SuperH calling conventions\" }, \\\n-  {\"no-renesas\",-HITACHI_BIT,\"Follow the GCC calling conventions\" },\t\\\n-  {\"nomacsave\", NOMACSAVE_BIT, \"Mark MAC register as call-clobbered\" },\t\\\n-  {\"ieee\",  \tIEEE_BIT, \"Increase the IEEE compliance for floating-point code\" }, \\\n-  {\"isize\", \tISIZE_BIT, \"Annotate assembler instructions with estimated addresses\" }, \\\n-  {\"l\",\t\tLITTLE_ENDIAN_BIT, \"Generate code in little endian mode\" }, \\\n-  {\"no-ieee\",  \t-IEEE_BIT, \"Opposite of -mieee\" },\t\t\t\\\n-  {\"padstruct\", PADSTRUCT_BIT, \"Make structs a multiple of 4 bytes (warning: ABI altered)\" }, \\\n-  {\"prefergot\",\tPREFERGOT_BIT, \"Emit function-calls using global offset table when generating PIC\" }, \\\n-  {\"relax\",\tRELAX_BIT, \"Shorten address references during linking\" }, \\\n-  {\"space\", \tSPACE_BIT, \"Deprecated. Use -Os instead\" },\t\t\\\n-  {\"usermode\",\tUSERMODE_BIT, \"Generate library function call to invalidate instruction cache entries after fixing trampoline\" }, \\\n-  TARGET_SWITCH_SH5_32_ANY_EXTRA \\\n-  TARGET_SWITCH_SH5_MEDIA_ANY_EXTRA \\\n-  SUBTARGET_SWITCHES                            \t\t\t\\\n-  {\"\",   \tTARGET_DEFAULT, \"\" }\t\t\t\t\t\\\n-}\n-\n-/* This are meant to be redefined in the host dependent files */\n-#define SUBTARGET_SWITCHES\n+#define MASK_ARCH (MASK_SH1 | MASK_SH2 | MASK_SH3 | MASK_SH_E | MASK_SH4 \\\n+\t\t   | MASK_HARD_SH2A | MASK_HARD_SH2A_DOUBLE | MASK_SH4A \\\n+\t\t   | MASK_HARD_SH4 | MASK_FPU_SINGLE | MASK_SH5)\n \n /* This defaults us to big-endian.  */\n #ifndef TARGET_ENDIAN_DEFAULT\n #define TARGET_ENDIAN_DEFAULT 0\n #endif\n \n #ifndef TARGET_OPT_DEFAULT\n-#define TARGET_OPT_DEFAULT  ADJUST_UNROLL_BIT\n+#define TARGET_OPT_DEFAULT  MASK_ADJUST_UNROLL\n #endif\n \n #define TARGET_DEFAULT \\\n@@ -705,7 +386,7 @@ extern int target_flags;\n   { \"subtarget_asm_spec\", SUBTARGET_ASM_SPEC },\t\t\t\\\n   SUBTARGET_EXTRA_SPECS\n \n-#if TARGET_CPU_DEFAULT & HARD_SH4_BIT\n+#if TARGET_CPU_DEFAULT & MASK_HARD_SH4\n #define SUBTARGET_ASM_RELAX_SPEC \"%{!m1:%{!m2:%{!m3*:%{!m5*:-isa=sh4}}}}\"\n #else\n #define SUBTARGET_ASM_RELAX_SPEC \"%{m4*:-isa=sh4}\"\n@@ -726,7 +407,7 @@ extern int target_flags;\n #define ASM_SPEC SH_ASM_SPEC\n \n #ifndef SUBTARGET_ASM_ENDIAN_SPEC\n-#if TARGET_ENDIAN_DEFAULT == LITTLE_ENDIAN_BIT\n+#if TARGET_ENDIAN_DEFAULT == MASK_LITTLE_ENDIAN\n #define SUBTARGET_ASM_ENDIAN_SPEC \"%{mb:-big} %{!mb:-little}\"\n #else\n #define SUBTARGET_ASM_ENDIAN_SPEC \"%{ml:-little} %{!ml:-big}\"\n@@ -736,7 +417,7 @@ extern int target_flags;\n #if STRICT_NOFPU == 1\n /* Strict nofpu means that the compiler should tell the assembler\n    to reject FPU instructions. E.g. from ASM inserts.  */\n-#if TARGET_CPU_DEFAULT & HARD_SH4_BIT && !(TARGET_CPU_DEFAULT & SH_E_BIT)\n+#if TARGET_CPU_DEFAULT & MASK_HARD_SH4 && !(TARGET_CPU_DEFAULT & MASK_SH_E)\n #define SUBTARGET_ASM_ISA_SPEC \"%{!m1:%{!m2:%{!m3*:%{m4-nofpu|!m4*:%{!m5:-isa=sh4-nofpu}}}}}\"\n #else\n /* If there were an -isa option for sh5-nofpu then it would also go here. */\n@@ -751,30 +432,30 @@ extern int target_flags;\n #define SUBTARGET_ASM_SPEC \"\"\n #endif\n \n-#if TARGET_ENDIAN_DEFAULT == LITTLE_ENDIAN_BIT\n+#if TARGET_ENDIAN_DEFAULT == MASK_LITTLE_ENDIAN\n #define LINK_EMUL_PREFIX \"sh%{!mb:l}\"\n #else\n #define LINK_EMUL_PREFIX \"sh%{ml:l}\"\n #endif\n \n-#if TARGET_CPU_DEFAULT & SH5_BIT\n-#if TARGET_CPU_DEFAULT & SH_E_BIT\n+#if TARGET_CPU_DEFAULT & MASK_SH5\n+#if TARGET_CPU_DEFAULT & MASK_SH_E\n #define LINK_DEFAULT_CPU_EMUL \"32\"\n-#if TARGET_CPU_DEFAULT & SH1_BIT\n+#if TARGET_CPU_DEFAULT & MASK_SH1\n #define ASM_ISA_SPEC_DEFAULT \"--isa=SHcompact\"\n #else\n #define ASM_ISA_SPEC_DEFAULT \"--isa=SHmedia --abi=32\"\n-#endif /* SH1_BIT */\n-#else /* !SH_E_BIT */\n+#endif /* MASK_SH1 */\n+#else /* !MASK_SH_E */\n #define LINK_DEFAULT_CPU_EMUL \"64\"\n #define ASM_ISA_SPEC_DEFAULT \"--isa=SHmedia --abi=64\"\n-#endif /* SH_E_BIT */\n+#endif /* MASK_SH_E */\n #define ASM_ISA_DEFAULT_SPEC \\\n \" %{!m1:%{!m2*:%{!m3*:%{!m4*:%{!m5*:\" ASM_ISA_SPEC_DEFAULT \"}}}}}\"\n-#else /* !SH5_BIT */\n+#else /* !MASK_SH5 */\n #define LINK_DEFAULT_CPU_EMUL \"\"\n #define ASM_ISA_DEFAULT_SPEC \"\"\n-#endif /* SH5_BIT */\n+#endif /* MASK_SH5 */\n \n #define SUBTARGET_LINK_EMUL_SUFFIX \"\"\n #define SUBTARGET_LINK_SPEC \"\"\n@@ -806,7 +487,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   if (SIZE)\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      target_flags |= SPACE_BIT;\t\t\t\t\t\\\n+      target_flags |= MASK_SMALLCODE;\t\t\t\t\t\\\n       sh_div_str = SH_DIV_STR_FOR_SIZE ;\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   /* We can't meaningfully test TARGET_SHMEDIA here, because -m options\t\\\n@@ -817,7 +498,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       flag_branch_target_load_optimize = 1;\t\t\t\t\\\n       if (! (SIZE))\t\t\t\t\t\t\t\\\n-\ttarget_flags |= SAVE_ALL_TR_BIT;\t\t\t\t\\\n+\ttarget_flags |= MASK_SAVE_ALL_TARGET_REGS;\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   /* Likewise, we can't meaningfully test TARGET_SH2E / TARGET_IEEE\t\\\n      here, so leave it to OVERRIDE_OPTIONS to set\t\t\t\\\n@@ -857,7 +538,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n     flag_finite_math_only\t\t\t\t\t\t\\\n       = !flag_signaling_nans && TARGET_SH2E && ! TARGET_IEEE;\t\t\\\n   if (TARGET_SH2E && !flag_finite_math_only)\t\t\t\t\\\n-    target_flags |= IEEE_BIT;\t\t\t\t\t\t\\\n+    target_flags |= MASK_IEEE;\t\t\t\t\t\t\\\n   sh_cpu = CPU_SH1;\t\t\t\t\t\t\t\\\n   assembler_dialect = 0;\t\t\t\t\t\t\\\n   if (TARGET_SH2)\t\t\t\t\t\t\t\\\n@@ -868,7 +549,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       sh_cpu = CPU_SH2A;\t\t\t\t\t\t\\\n       if (TARGET_SH2A_DOUBLE)\t\t\t\t\t\t\\\n-        target_flags |= FMOVD_BIT;\t\t\t\t\t\\\n+        target_flags |= MASK_FMOVD;\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   if (TARGET_SH3)\t\t\t\t\t\t\t\\\n     sh_cpu = CPU_SH3;\t\t\t\t\t\t\t\\\n@@ -887,15 +568,15 @@ do {\t\t\t\t\t\t\t\t\t\\\n   if (TARGET_SH5)\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       sh_cpu = CPU_SH5;\t\t\t\t\t\t\t\\\n-      target_flags |= DALIGN_BIT;\t\t\t\t\t\\\n+      target_flags |= MASK_ALIGN_DOUBLE;\t\t\t\t\\\n       if (TARGET_SHMEDIA_FPU)\t\t\t\t\t\t\\\n-\ttarget_flags |= FMOVD_BIT;\t\t\t\t\t\\\n+\ttarget_flags |= MASK_FMOVD;\t\t\t\t\t\\\n       if (TARGET_SHMEDIA)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  /* There are no delay slots on SHmedia.  */\t\t\t\\\n \t  flag_delayed_branch = 0;\t\t\t\t\t\\\n \t  /* Relaxation isn't yet supported for SHmedia */\t\t\\\n-\t  target_flags &= ~RELAX_BIT;\t\t\t\t\t\\\n+\t  target_flags &= ~MASK_RELAX;\t\t\t\t\t\\\n \t  /* After reload, if conversion does little good but can cause \\\n \t     ICEs:\t\t\t\t\t\t\t\\\n \t     - find_if_block doesn't do anything for SH because we don't\\"}, {"sha": "c3c659f95d249c0550eb4445ace2162561ca72fc", "filename": "gcc/config/sh/sh.opt", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2Fconfig%2Fsh%2Fsh.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2Fconfig%2Fsh%2Fsh.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.opt?ref=c0fb94d7250e1311bfd2724f3df629999f1a291b", "patch": "@@ -0,0 +1,214 @@\n+; Options for the SH port of the compiler.\n+\n+; Copyright (C) 2005 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 2, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING.  If not, write to the Free\n+; Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+; 02111-1307, USA.\n+\n+;; Used for various architecture options.\n+Mask(SH_E)\n+\n+;; Set if the default precision of th FPU is single.\n+Mask(FPU_SINGLE)\n+\n+;; Set if we should generate code using type 2A insns.\n+Mask(HARD_SH2A)\n+\n+;; Set if we should generate code using type 2A DF insns.\n+Mask(HARD_SH2A_DOUBLE)\n+\n+;; Set if compiling for SH4 hardware (to be used for insn costs etc.)\n+Mask(HARD_SH4)\n+\n+;; Set if we should generate code for a SH5 CPU (either ISA).\n+Mask(SH5)\n+\n+;; Set if we should save all target registers.\n+Mask(SAVE_ALL_TARGET_REGS)\n+\n+m1\n+Target RejectNegative Mask(SH1) Condition(SUPPORT_SH1)\n+Generate SH1 code\n+\n+m2\n+Target RejectNegative Mask(SH2) Condition(SUPPORT_SH2)\n+Generate SH2 code\n+\n+m2a\n+Target RejectNegative Condition(SUPPORT_SH2A)\n+Generate SH2a code\n+\n+m2a-nofpu\n+Target RejectNegative Condition(SUPPORT_SH2A_NOFPU)\n+Generate SH2a FPU-less code\n+\n+m2a-single\n+Target RejectNegative Condition (SUPPORT_SH2A_SINGLE)\n+Generate default single-precision SH2a code\n+\n+m2a-single-only\n+Target RejectNegative Condition (SUPPORT_SH2A_SINGLE_ONLY)\n+Generate only single-precision SH2a code\n+\n+m2e\n+Target RejectNegative Condition(SUPPORT_SH2E)\n+Generate SH2e code\n+\n+m3\n+Target RejectNegative Mask(SH3) Condition(SUPPORT_SH3)\n+Generate SH3 code\n+\n+m3e\n+Target RejectNegative Condition(SUPPORT_SH3E)\n+Generate SH3e code\n+\n+m4\n+Target RejectNegative Mask(SH4) Condition(SUPPORT_SH4)\n+Generate SH4 code\n+\n+m4-nofpu\n+Target RejectNegative Condition(SUPPORT_SH4_NOFPU)\n+Generate SH4 FPU-less code\n+\n+m4-single\n+Target RejectNegative Condition(SUPPORT_SH4_SINGLE)\n+Generate default single-precision SH4 code\n+\n+m4-single-only\n+Target RejectNegative Condition(SUPPORT_SH4_SINGLE_ONLY)\n+Generate only single-precision SH4 code\n+\n+m4a\n+Target RejectNegative Mask(SH4A) Condition(SUPPORT_SH4A)\n+Generate SH4a code\n+\n+m4a-nofpu\n+Target RejectNegative Condition(SUPPORT_SH4A_NOFPU)\n+Generate SH4a FPU-less code\n+\n+m4a-single\n+Target RejectNegative Condition(SUPPORT_SH4A_SINGLE)\n+Generate default single-precision SH4a code\n+\n+m4a-single-only\n+Target RejectNegative Condition(SUPPORT_SH4A_SINGLE_ONLY)\n+Generate only single-precision SH4a code\n+\n+m4al\n+Target RejectNegative Condition(SUPPORT_SH4AL)\n+Generate SH4al-dsp code\n+\n+m5-32media\n+Target RejectNegative Condition(SUPPORT_SH5_32MEDIA)\n+Generate 32-bit SHmedia code\n+\n+m5-32media-nofpu\n+Target RejectNegative Condition(SUPPORT_SH5_32MEDIA_NOFPU)\n+Generate 32-bit FPU-less SHmedia code\n+\n+m5-64media\n+Target RejectNegative Condition(SUPPORT_SH5_64MEDIA)\n+Generate 64-bit SHmedia code\n+\n+m5-64media-nofpu\n+Target RejectNegative Condition(SUPPORT_SH5_64MEDIA_NOFPU)\n+Generate 64-bit FPU-less SHmedia code\n+\n+m5-compact\n+Target RejectNegative Condition(SUPPORT_SH5_32MEDIA)\n+Generate SHcompact code\n+\n+m5-compact-nofpu\n+Target RejectNegative Condition(SUPPORT_SH5_32MEDIA_NOFPU)\n+Generate FPU-less SHcompact code\n+\n+madjust-unroll\n+Target Report Mask(ADJUST_UNROLL) Condition(SUPPORT_ANY_SH5)\n+Throttle unrolling to avoid thrashing target registers unless the unroll benefit outweighs this\n+\n+mb\n+Target Report RejectNegative InverseMask(LITTLE_ENDIAN)\n+Generate code in big endian mode\n+\n+mbigtable\n+Target Report RejectNegative Mask(BIGTABLE)\n+Generate 32-bit offsets in switch tables\n+\n+mdalign\n+Target Report RejectNegative Mask(ALIGN_DOUBLE)\n+Align doubles at 64-bit boundaries\n+\n+mfmovd\n+Target RejectNegative Mask(FMOVD) Undocumented\n+\n+mhitachi\n+Target Report RejectNegative Mask(HITACHI)\n+Follow Renesas (formerly Hitachi) / SuperH calling conventions\n+\n+mieee\n+Target Report Mask(IEEE)\n+Increase the IEEE compliance for floating-point code\n+\n+mindexed-addressing\n+Target Report Mask(ALLOW_INDEXED_ADDRESS) Condition(SUPPORT_ANY_SH5_32MEDIA)\n+Enable the use of the indexed addressing mode for SHmedia32/SHcompact\n+\n+minvalid-symbols\n+Target Report Mask(INVALID_SYMBOLS) Condition(SUPPORT_ANY_SH5)\n+Assume symbols might be invalid\n+\n+misize\n+Target Report RejectNegative Mask(DUMPISIZE)\n+Annotate assembler instructions with estimated addresses\n+\n+ml\n+Target Report RejectNegative Mask(LITTLE_ENDIAN)\n+Generate code in little endian mode\n+\n+mnomacsave\n+Target Report RejectNegative Mask(NOMACSAVE)\n+Mark MAC register as call-clobbered\n+\n+;; ??? This option is not useful, but is retained in case there are people\n+;; who are still relying on it.  It may be deleted in the future.\n+mpadstruct\n+Target Report RejectNegative Mask(PADSTRUCT)\n+Make structs a multiple of 4 bytes (warning: ABI altered)\n+\n+mprefergot\n+Target Report RejectNegative Mask(PREFERGOT)\n+Emit function-calls using global offset table when generating PIC\n+\n+mpt-fixed\n+Target Report Mask(PT_FIXED) Condition(SUPPORT_ANY_SH5)\n+Assume pt* instructions won't trap\n+\n+mrelax\n+Target Report RejectNegative Mask(RELAX)\n+Shorten address references during linking\n+\n+mrenesas\n+Target Mask(HITACHI) MaskExists\n+Follow Renesas (formerly Hitachi) / SuperH calling conventions\n+\n+mspace\n+Target Report RejectNegative Mask(SMALLCODE)\n+Deprecated. Use -Os instead\n+\n+musermode\n+Target Report RejectNegative Mask(USERMODE)\n+Generate library function call to invalidate instruction cache entries after fixing trampoline"}, {"sha": "1d882bec0c3720b6d6d529ac5fc42e755b39da99", "filename": "gcc/config/sh/symbian-pre.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2Fconfig%2Fsh%2Fsymbian-pre.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0fb94d7250e1311bfd2724f3df629999f1a291b/gcc%2Fconfig%2Fsh%2Fsymbian-pre.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian-pre.h?ref=c0fb94d7250e1311bfd2724f3df629999f1a291b", "patch": "@@ -25,7 +25,7 @@\n #define SYMBIAN\t\t1\n \n /* Default to using the Renesas ABI.  */\n-#define TARGET_ABI_DEFAULT\tRENESAS_BIT\n+#define TARGET_ABI_DEFAULT\tMASK_HITACHI\n \n #define SUBTARGET_CPP_SPEC \"\"\n "}]}