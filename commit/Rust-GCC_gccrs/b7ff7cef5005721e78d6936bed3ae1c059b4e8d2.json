{"sha": "b7ff7cef5005721e78d6936bed3ae1c059b4e8d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdmZjdjZWY1MDA1NzIxZTc4ZDY5MzZiZWQzYWUxYzA1OWI0ZThkMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-10-29T09:33:49Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-10-29T09:33:49Z"}, "message": "re PR tree-optimization/65930 (Reduction with sign-change not handled)\n\n2019-10-29  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/65930\n\t* tree-vect-loop.c (check_reduction_path): Relax single-use\n\tcheck allowing out-of-loop uses.\n\t(vect_is_simple_reduction): SLP reduction chains cannot have\n\tintermediate stmts used outside of the loop.\n\t(vect_create_epilog_for_reduction): The adjustment might need\n\tto be converted.\n\t(vectorizable_reduction): Annotate live stmts of the reduction\n\tchain with STMT_VINFO_REDUC_DEF.\n\t* tree-vect-stms.c (process_use): Remove no longer true asserts.\n\n\t* gcc.dg/vect/pr65930-1.c: New testcase.\n\nFrom-SVN: r277566", "tree": {"sha": "55dfad525476996c65b132bf86f8ad06525e797d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55dfad525476996c65b132bf86f8ad06525e797d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7ff7cef5005721e78d6936bed3ae1c059b4e8d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7ff7cef5005721e78d6936bed3ae1c059b4e8d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7ff7cef5005721e78d6936bed3ae1c059b4e8d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7ff7cef5005721e78d6936bed3ae1c059b4e8d2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bc73c4c24daec96ad3e7ff904645c3095a4febe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc73c4c24daec96ad3e7ff904645c3095a4febe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc73c4c24daec96ad3e7ff904645c3095a4febe9"}], "stats": {"total": 124, "additions": 84, "deletions": 40}, "files": [{"sha": "77c8b185c6da674ebcfc8cf8271e1fd78d61c1ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7ff7cef5005721e78d6936bed3ae1c059b4e8d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7ff7cef5005721e78d6936bed3ae1c059b4e8d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7ff7cef5005721e78d6936bed3ae1c059b4e8d2", "patch": "@@ -1,3 +1,16 @@\n+2019-10-29  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/65930\n+\t* tree-vect-loop.c (check_reduction_path): Relax single-use\n+\tcheck allowing out-of-loop uses.\n+\t(vect_is_simple_reduction): SLP reduction chains cannot have\n+\tintermediate stmts used outside of the loop.\n+\t(vect_create_epilog_for_reduction): The adjustment might need\n+\tto be converted.\n+\t(vectorizable_reduction): Annotate live stmts of the reduction\n+\tchain with STMT_VINFO_REDUC_DEF.\n+\t* tree-vect-stms.c (process_use): Remove no longer true asserts.\n+\n 2019-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* calls.c (pass_by_reference): Leave the target to decide whether"}, {"sha": "f4885b6e7bd41cdd81196734f42048de3c9725f1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7ff7cef5005721e78d6936bed3ae1c059b4e8d2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7ff7cef5005721e78d6936bed3ae1c059b4e8d2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b7ff7cef5005721e78d6936bed3ae1c059b4e8d2", "patch": "@@ -1,3 +1,8 @@\n+2019-10-29  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/65930\n+\t* gcc.dg/vect/pr65930-1.c: New testcase.\n+\n 2019-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n \t    Kugan Vivekanandarajah  <kugan.vivekanandarajah@linaro.org>\n \t    Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>"}, {"sha": "895fbf8869d2369c5a86b51cdb6dc2960e50f400", "filename": "gcc/testsuite/gcc.dg/vect/pr65930-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7ff7cef5005721e78d6936bed3ae1c059b4e8d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65930-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7ff7cef5005721e78d6936bed3ae1c059b4e8d2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65930-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65930-1.c?ref=b7ff7cef5005721e78d6936bed3ae1c059b4e8d2", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+unsigned __attribute__((noipa))\n+bar (unsigned int *x)\n+{\n+  int sum = 4;\n+  x = __builtin_assume_aligned (x, __BIGGEST_ALIGNMENT__);\n+  for (int i = 0; i < 16; ++i)\n+    sum += x[i];\n+  return sum;\n+}\n+\n+int\n+main()\n+{\n+  static int a[16] __attribute__((aligned(__BIGGEST_ALIGNMENT__)))\n+    = { 1, 3, 5, 8, 9, 10, 17, 18, 23, 29, 30, 55, 42, 2, 3, 1 };\n+  check_vect ();\n+  if (bar (a) != 260)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" } } */"}, {"sha": "3f43fe6c3af2d8e5c3521a31726a08e4c3d2e0d2", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 38, "deletions": 17, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7ff7cef5005721e78d6936bed3ae1c059b4e8d2/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7ff7cef5005721e78d6936bed3ae1c059b4e8d2/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b7ff7cef5005721e78d6936bed3ae1c059b4e8d2", "patch": "@@ -2678,8 +2678,7 @@ check_reduction_path (dump_user_location_t loc, loop_p loop, gphi *phi,\n     {\n       gimple *use_stmt = USE_STMT (path[i].second);\n       tree op = USE_FROM_PTR (path[i].second);\n-      if (! has_single_use (op)\n-\t  || ! is_gimple_assign (use_stmt)\n+      if (! is_gimple_assign (use_stmt)\n \t  /* The following make sure we can compute the operand index\n \t     easily plus it mostly disallows chaining via COND_EXPR condition\n \t     operands.  */\n@@ -2690,7 +2689,21 @@ check_reduction_path (dump_user_location_t loc, loop_p loop, gphi *phi,\n \t  fail = true;\n \t  break;\n \t}\n-      enum tree_code use_code = gimple_assign_rhs_code (use_stmt);\n+      /* Check there's only a single stmt the op is used on inside\n+         of the loop.  */\n+      imm_use_iterator imm_iter;\n+      gimple *op_use_stmt;\n+      unsigned cnt = 0;\n+      FOR_EACH_IMM_USE_STMT (op_use_stmt, imm_iter, op)\n+\tif (!is_gimple_debug (op_use_stmt)\n+\t    && flow_bb_inside_loop_p (loop, gimple_bb (op_use_stmt)))\n+\t  cnt++;\n+      if (cnt != 1)\n+\t{\n+\t  fail = true;\n+\t  break;\n+\t}\n+      tree_code use_code = gimple_assign_rhs_code (use_stmt);\n       if (use_code == MINUS_EXPR)\n \t{\n \t  use_code = PLUS_EXPR;\n@@ -2922,7 +2935,10 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n       for (i = path.length () - 1; i >= 1; --i)\n \t{\n \t  gimple *stmt = USE_STMT (path[i].second);\n-\t  if (gimple_assign_rhs_code (stmt) != code)\n+\t  if (gimple_assign_rhs_code (stmt) != code\n+\t      /* We can only handle the final value in epilogue\n+\t\t generation for reduction chains.  */\n+\t      || (i != 1 && !has_single_use (gimple_assign_lhs (stmt))))\n \t    is_slp_reduc = false;\n \t  stmt_vec_info stmt_info = loop_info->lookup_stmt (stmt);\n \t  STMT_VINFO_REDUC_IDX (stmt_info)\n@@ -4119,11 +4135,11 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n   stmt_vec_info phi_info;\n   gimple_stmt_iterator exit_gsi;\n   tree vec_dest;\n-  tree new_temp = NULL_TREE, new_dest, new_name, new_scalar_dest;\n+  tree new_temp = NULL_TREE, new_name, new_scalar_dest;\n   gimple *epilog_stmt = NULL;\n   gimple *exit_phi;\n   tree bitsize;\n-  tree expr, def;\n+  tree def;\n   tree orig_name, scalar_result;\n   imm_use_iterator imm_iter, phi_imm_iter;\n   use_operand_p use_p, phi_use_p;\n@@ -5048,25 +5064,26 @@ vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n   if (adjustment_def)\n     {\n       gcc_assert (!slp_reduc);\n+      gimple_seq stmts = NULL;\n       if (nested_in_vect_loop)\n \t{\n           new_phi = new_phis[0];\n-\t  gcc_assert (TREE_CODE (TREE_TYPE (adjustment_def)) == VECTOR_TYPE);\n-\t  expr = build2 (code, vectype, PHI_RESULT (new_phi), adjustment_def);\n-\t  new_dest = vect_create_destination_var (scalar_dest, vectype);\n+\t  gcc_assert (VECTOR_TYPE_P (TREE_TYPE (adjustment_def)));\n+\t  adjustment_def = gimple_convert (&stmts, vectype, adjustment_def);\n+\t  new_temp = gimple_build (&stmts, code, vectype,\n+\t\t\t\t   PHI_RESULT (new_phi), adjustment_def);\n \t}\n       else\n \t{\n           new_temp = scalar_results[0];\n \t  gcc_assert (TREE_CODE (TREE_TYPE (adjustment_def)) != VECTOR_TYPE);\n-\t  expr = build2 (code, scalar_type, new_temp, adjustment_def);\n-\t  new_dest = vect_create_destination_var (scalar_dest, scalar_type);\n+\t  adjustment_def = gimple_convert (&stmts, scalar_type, adjustment_def);\n+\t  new_temp = gimple_build (&stmts, code, scalar_type,\n+\t\t\t\t   new_temp, adjustment_def);\n \t}\n \n-      epilog_stmt = gimple_build_assign (new_dest, expr);\n-      new_temp = make_ssa_name (new_dest, epilog_stmt);\n-      gimple_assign_set_lhs (epilog_stmt, new_temp);\n-      gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n+      epilog_stmt = gimple_seq_last_stmt (stmts);\n+      gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n       if (nested_in_vect_loop)\n         {\n \t  stmt_vec_info epilog_stmt_info = loop_vinfo->add_stmt (epilog_stmt);\n@@ -5742,6 +5759,10 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n \t}\n       if (!REDUC_GROUP_FIRST_ELEMENT (def))\n \tonly_slp_reduc_chain = false;\n+      /* ???  For epilogue generation live members of the chain need\n+         to point back to the PHI for info_for_reduction to work.  */\n+      if (STMT_VINFO_LIVE_P (def))\n+\tSTMT_VINFO_REDUC_DEF (def) = phi_info;\n       reduc_def = gimple_op (def->stmt, 1 + STMT_VINFO_REDUC_IDX (def));\n       reduc_chain_length++;\n     }\n@@ -7443,10 +7464,10 @@ vectorizable_live_operation (stmt_vec_info stmt_info,\n \n   gcc_assert (STMT_VINFO_LIVE_P (stmt_info));\n \n-  /* The last stmt of a reduction is live and vectorized via\n+  /* If a stmt of a reduction is live, vectorize it via\n      vect_create_epilog_for_reduction.  vectorizable_reduction assessed\n      validity so just trigger the transform here.  */\n-  if (STMT_VINFO_REDUC_DEF (vect_orig_stmt (stmt_info)))\n+  if (STMT_VINFO_REDUC_DEF (stmt_info))\n     {\n       if (!vec_stmt_p)\n \treturn true;"}, {"sha": "abc827f738ee45afc3990c8605add79466959643", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7ff7cef5005721e78d6936bed3ae1c059b4e8d2/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7ff7cef5005721e78d6936bed3ae1c059b4e8d2/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=b7ff7cef5005721e78d6936bed3ae1c059b4e8d2", "patch": "@@ -457,7 +457,6 @@ process_use (stmt_vec_info stmt_vinfo, tree use, loop_vec_info loop_vinfo,\n \t     bool force)\n {\n   stmt_vec_info dstmt_vinfo;\n-  basic_block bb, def_bb;\n   enum vect_def_type dt;\n \n   /* case 1: we are only interested in uses that need to be vectorized.  Uses\n@@ -473,28 +472,8 @@ process_use (stmt_vec_info stmt_vinfo, tree use, loop_vec_info loop_vinfo,\n   if (!dstmt_vinfo)\n     return opt_result::success ();\n \n-  def_bb = gimple_bb (dstmt_vinfo->stmt);\n-\n-  /* case 2: A reduction phi (STMT) defined by a reduction stmt (DSTMT_VINFO).\n-     DSTMT_VINFO must have already been processed, because this should be the\n-     only way that STMT, which is a reduction-phi, was put in the worklist,\n-     as there should be no other uses for DSTMT_VINFO in the loop.  So we just\n-     check that everything is as expected, and we are done.  */\n-  bb = gimple_bb (stmt_vinfo->stmt);\n-  if (gimple_code (stmt_vinfo->stmt) == GIMPLE_PHI\n-      && STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def\n-      && gimple_code (dstmt_vinfo->stmt) != GIMPLE_PHI\n-      && STMT_VINFO_DEF_TYPE (dstmt_vinfo) == vect_reduction_def\n-      && bb->loop_father == def_bb->loop_father)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, vect_location,\n-                         \"reduc-stmt defining reduc-phi in the same nest.\\n\");\n-      gcc_assert (STMT_VINFO_RELEVANT (dstmt_vinfo) < vect_used_by_reduction);\n-      gcc_assert (STMT_VINFO_LIVE_P (dstmt_vinfo)\n-\t\t  || STMT_VINFO_RELEVANT (dstmt_vinfo) > vect_unused_in_scope);\n-      return opt_result::success ();\n-    }\n+  basic_block def_bb = gimple_bb (dstmt_vinfo->stmt);\n+  basic_block bb = gimple_bb (stmt_vinfo->stmt);\n \n   /* case 3a: outer-loop stmt defining an inner-loop stmt:\n \touter-loop-header-bb:"}]}