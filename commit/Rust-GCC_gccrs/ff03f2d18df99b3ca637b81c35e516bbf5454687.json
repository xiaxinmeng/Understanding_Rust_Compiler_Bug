{"sha": "ff03f2d18df99b3ca637b81c35e516bbf5454687", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmYwM2YyZDE4ZGY5OWIzY2E2MzdiODFjMzVlNTE2YmJmNTQ1NDY4Nw==", "commit": {"author": {"name": "Mihail Ionescu", "email": "mihail.ionescu@arm.com", "date": "2018-11-23T10:48:52Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2018-11-23T10:48:52Z"}, "message": "[PATCH, ARM] Clean up arm backend using the @ construct for MD patterns\n\nThis patch removes some of the machine mode checks from the arm backend when\nemitting instructions by using the '@' construct (Parameterized Names[2]). It\nis based on the previous AArch64 patch[1].\n\n[1] https://gcc.gnu.org/ml/gcc-patches/2018-07/msg00673.html\n[2] https://gcc.gnu.org/onlinedocs/gccint/Parameterized-Names.html#Parameterized-Names\n\n\n2018-23-11  Mihail Ionescu  <mihail.ionescu@arm.com>\n\n\t* config/arm/arm.c (arm_expand_compare_and_swap): Simplify and call\n\tgen_atomic_compare_swap_1.\n\t(arm_evpc_neon_vuzp): Likewise gen_neon_vuzp_internal.\n\t(arm_evpc_neon_vtrn): Likewise gen_neon_vtrn_internal.\n\t(arm_evpc_neon_vext): Likewise gen_neon_vext_internal.\n\t(arm_evpc_neon_vzip): Likewise gen_neon_vzip_internal.\n\t(arm_evpc_neon_vrev): Replace the function pointer and simplify the mode\n\tchecks.\n\t* config/arm/arm.md (neon_vext<mode>),\n\t(neon_vrev64<mode>, neon_vrev32<mode>),\n\t(neon_vrev16<mode>, neon_vtrn<mode>_internal),\n\t(neon_vzip<mode>_internal, neon_vuzp<mode>_internal): Add an '@'character\n\tbefore the pattern name.\n\t* config/arm/sync.md:\n\t(atomic_compare_and_swap<CCSI:arch><NARROW:mode>_1),\n\t(atomic_compare_and_swap<CCSI:arch><SIDI:mode>_1): Likewise.\n\nFrom-SVN: r266404", "tree": {"sha": "2fe1af838f938b176284d7dc056b60dc60de9255", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fe1af838f938b176284d7dc056b60dc60de9255"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff03f2d18df99b3ca637b81c35e516bbf5454687", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff03f2d18df99b3ca637b81c35e516bbf5454687", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff03f2d18df99b3ca637b81c35e516bbf5454687", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff03f2d18df99b3ca637b81c35e516bbf5454687/comments", "author": null, "committer": null, "parents": [{"sha": "21150aba6ac0b00ce22b01a8d6104e5ea4e7c6ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21150aba6ac0b00ce22b01a8d6104e5ea4e7c6ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21150aba6ac0b00ce22b01a8d6104e5ea4e7c6ec"}], "stats": {"total": 215, "additions": 80, "deletions": 135}, "files": [{"sha": "91469b190cc2366fe07b05f4aaa44c969eb7c2a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03f2d18df99b3ca637b81c35e516bbf5454687/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03f2d18df99b3ca637b81c35e516bbf5454687/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff03f2d18df99b3ca637b81c35e516bbf5454687", "patch": "@@ -1,3 +1,22 @@\n+2018-23-11  Mihail Ionescu  <mihail.ionescu@arm.com>\n+\n+\t* config/arm/arm.c (arm_expand_compare_and_swap): Simplify and call\n+\tgen_atomic_compare_swap_1.\n+\t(arm_evpc_neon_vuzp): Likewise gen_neon_vuzp_internal.\n+\t(arm_evpc_neon_vtrn): Likewise gen_neon_vtrn_internal.\n+\t(arm_evpc_neon_vext): Likewise gen_neon_vext_internal.\n+\t(arm_evpc_neon_vzip): Likewise gen_neon_vzip_internal.\n+\t(arm_evpc_neon_vrev): Replace the function pointer and simplify the mode\n+\tchecks.\n+\t* config/arm/arm.md (neon_vext<mode>),\n+\t(neon_vrev64<mode>, neon_vrev32<mode>),\n+\t(neon_vrev16<mode>, neon_vtrn<mode>_internal),\n+\t(neon_vzip<mode>_internal, neon_vuzp<mode>_internal): Add an '@'character\n+\tbefore the pattern name.\n+\t* config/arm/sync.md:\n+\t(atomic_compare_and_swap<CCSI:arch><NARROW:mode>_1),\n+\t(atomic_compare_and_swap<CCSI:arch><SIDI:mode>_1): Likewise.\n+\n 2018-11-23  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/86614"}, {"sha": "40f0574e32e57c46530d641c8b5c40a7b65010dd", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 52, "deletions": 126, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03f2d18df99b3ca637b81c35e516bbf5454687/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03f2d18df99b3ca637b81c35e516bbf5454687/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=ff03f2d18df99b3ca637b81c35e516bbf5454687", "patch": "@@ -28588,8 +28588,7 @@ void\n arm_expand_compare_and_swap (rtx operands[])\n {\n   rtx bval, bdst, rval, mem, oldval, newval, is_weak, mod_s, mod_f, x;\n-  machine_mode mode;\n-  rtx (*gen) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);\n+  machine_mode mode, cmp_mode;\n \n   bval = operands[0];\n   rval = operands[1];\n@@ -28637,32 +28636,13 @@ arm_expand_compare_and_swap (rtx operands[])\n     }\n \n   if (TARGET_THUMB1)\n-    {\n-      switch (mode)\n-\t{\n-\tcase E_QImode: gen = gen_atomic_compare_and_swapt1qi_1; break;\n-\tcase E_HImode: gen = gen_atomic_compare_and_swapt1hi_1; break;\n-\tcase E_SImode: gen = gen_atomic_compare_and_swapt1si_1; break;\n-\tcase E_DImode: gen = gen_atomic_compare_and_swapt1di_1; break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n+    cmp_mode = E_SImode;\n   else\n-    {\n-      switch (mode)\n-\t{\n-\tcase E_QImode: gen = gen_atomic_compare_and_swap32qi_1; break;\n-\tcase E_HImode: gen = gen_atomic_compare_and_swap32hi_1; break;\n-\tcase E_SImode: gen = gen_atomic_compare_and_swap32si_1; break;\n-\tcase E_DImode: gen = gen_atomic_compare_and_swap32di_1; break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n+    cmp_mode = CC_Zmode;\n \n   bdst = TARGET_THUMB1 ? bval : gen_rtx_REG (CC_Zmode, CC_REGNUM);\n-  emit_insn (gen (bdst, rval, mem, oldval, newval, is_weak, mod_s, mod_f));\n+  emit_insn (gen_atomic_compare_and_swap_1 (cmp_mode, mode, bdst, rval, mem,\n+                                        oldval, newval, is_weak, mod_s, mod_f));\n \n   if (mode == QImode || mode == HImode)\n     emit_move_insn (operands[1], gen_lowpart (mode, rval));\n@@ -29028,7 +29008,6 @@ arm_evpc_neon_vuzp (struct expand_vec_perm_d *d)\n {\n   unsigned int i, odd, mask, nelt = d->perm.length ();\n   rtx out0, out1, in0, in1;\n-  rtx (*gen)(rtx, rtx, rtx, rtx);\n   int first_elem;\n   int swap_nelt;\n \n@@ -29062,22 +29041,6 @@ arm_evpc_neon_vuzp (struct expand_vec_perm_d *d)\n   if (d->testing_p)\n     return true;\n \n-  switch (d->vmode)\n-    {\n-    case E_V16QImode: gen = gen_neon_vuzpv16qi_internal; break;\n-    case E_V8QImode:  gen = gen_neon_vuzpv8qi_internal;  break;\n-    case E_V8HImode:  gen = gen_neon_vuzpv8hi_internal;  break;\n-    case E_V4HImode:  gen = gen_neon_vuzpv4hi_internal;  break;\n-    case E_V8HFmode:  gen = gen_neon_vuzpv8hf_internal;  break;\n-    case E_V4HFmode:  gen = gen_neon_vuzpv4hf_internal;  break;\n-    case E_V4SImode:  gen = gen_neon_vuzpv4si_internal;  break;\n-    case E_V2SImode:  gen = gen_neon_vuzpv2si_internal;  break;\n-    case E_V2SFmode:  gen = gen_neon_vuzpv2sf_internal;  break;\n-    case E_V4SFmode:  gen = gen_neon_vuzpv4sf_internal;  break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n   in0 = d->op0;\n   in1 = d->op1;\n   if (swap_nelt != 0)\n@@ -29088,7 +29051,7 @@ arm_evpc_neon_vuzp (struct expand_vec_perm_d *d)\n   if (odd)\n     std::swap (out0, out1);\n \n-  emit_insn (gen (out0, in0, in1, out1));\n+  emit_insn (gen_neon_vuzp_internal (d->vmode, out0, in0, in1, out1));\n   return true;\n }\n \n@@ -29099,7 +29062,6 @@ arm_evpc_neon_vzip (struct expand_vec_perm_d *d)\n {\n   unsigned int i, high, mask, nelt = d->perm.length ();\n   rtx out0, out1, in0, in1;\n-  rtx (*gen)(rtx, rtx, rtx, rtx);\n   int first_elem;\n   bool is_swapped;\n \n@@ -29137,22 +29099,6 @@ arm_evpc_neon_vzip (struct expand_vec_perm_d *d)\n   if (d->testing_p)\n     return true;\n \n-  switch (d->vmode)\n-    {\n-    case E_V16QImode: gen = gen_neon_vzipv16qi_internal; break;\n-    case E_V8QImode:  gen = gen_neon_vzipv8qi_internal;  break;\n-    case E_V8HImode:  gen = gen_neon_vzipv8hi_internal;  break;\n-    case E_V4HImode:  gen = gen_neon_vzipv4hi_internal;  break;\n-    case E_V8HFmode:  gen = gen_neon_vzipv8hf_internal;  break;\n-    case E_V4HFmode:  gen = gen_neon_vzipv4hf_internal;  break;\n-    case E_V4SImode:  gen = gen_neon_vzipv4si_internal;  break;\n-    case E_V2SImode:  gen = gen_neon_vzipv2si_internal;  break;\n-    case E_V2SFmode:  gen = gen_neon_vzipv2sf_internal;  break;\n-    case E_V4SFmode:  gen = gen_neon_vzipv4sf_internal;  break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n   in0 = d->op0;\n   in1 = d->op1;\n   if (is_swapped)\n@@ -29163,17 +29109,16 @@ arm_evpc_neon_vzip (struct expand_vec_perm_d *d)\n   if (high)\n     std::swap (out0, out1);\n \n-  emit_insn (gen (out0, in0, in1, out1));\n+  emit_insn (gen_neon_vzip_internal (d->vmode, out0, in0, in1, out1));\n   return true;\n }\n \n /* Recognize patterns for the VREV insns.  */\n-\n static bool\n arm_evpc_neon_vrev (struct expand_vec_perm_d *d)\n {\n   unsigned int i, j, diff, nelt = d->perm.length ();\n-  rtx (*gen)(rtx, rtx);\n+  rtx (*gen) (machine_mode, rtx, rtx);\n \n   if (!d->one_vector_p)\n     return false;\n@@ -29182,39 +29127,51 @@ arm_evpc_neon_vrev (struct expand_vec_perm_d *d)\n   switch (diff)\n     {\n     case 7:\n-      switch (d->vmode)\n-\t{\n-\tcase E_V16QImode: gen = gen_neon_vrev64v16qi; break;\n-\tcase E_V8QImode:  gen = gen_neon_vrev64v8qi;  break;\n-\tdefault:\n-\t  return false;\n-\t}\n-      break;\n+       switch (d->vmode)\n+        {\n+         case E_V16QImode:\n+         case E_V8QImode:\n+          gen = gen_neon_vrev64;\n+          break;\n+         default:\n+          return false;\n+        }\n+       break;\n     case 3:\n-      switch (d->vmode)\n-\t{\n-\tcase E_V16QImode: gen = gen_neon_vrev32v16qi; break;\n-\tcase E_V8QImode:  gen = gen_neon_vrev32v8qi;  break;\n-\tcase E_V8HImode:  gen = gen_neon_vrev64v8hi;  break;\n-\tcase E_V4HImode:  gen = gen_neon_vrev64v4hi;  break;\n-\tcase E_V8HFmode:  gen = gen_neon_vrev64v8hf;  break;\n-\tcase E_V4HFmode:  gen = gen_neon_vrev64v4hf;  break;\n+       switch (d->vmode)\n+        {\n+\tcase E_V16QImode:\n+\tcase E_V8QImode:\n+          gen = gen_neon_vrev32;\n+          break;\n+\tcase E_V8HImode:\n+\tcase E_V4HImode:\n+\tcase E_V8HFmode:\n+\tcase E_V4HFmode:\n+          gen = gen_neon_vrev64;\n+          break;\n \tdefault:\n \t  return false;\n \t}\n       break;\n     case 1:\n       switch (d->vmode)\n \t{\n-\tcase E_V16QImode: gen = gen_neon_vrev16v16qi; break;\n-\tcase E_V8QImode:  gen = gen_neon_vrev16v8qi;  break;\n-\tcase E_V8HImode:  gen = gen_neon_vrev32v8hi;  break;\n-\tcase E_V4HImode:  gen = gen_neon_vrev32v4hi;  break;\n-\tcase E_V4SImode:  gen = gen_neon_vrev64v4si;  break;\n-\tcase E_V2SImode:  gen = gen_neon_vrev64v2si;  break;\n-\tcase E_V4SFmode:  gen = gen_neon_vrev64v4sf;  break;\n-\tcase E_V2SFmode:  gen = gen_neon_vrev64v2sf;  break;\n-\tdefault:\n+\tcase E_V16QImode:\n+\tcase E_V8QImode:\n+          gen = gen_neon_vrev16;\n+          break;\n+\tcase E_V8HImode:\n+\tcase E_V4HImode:\n+          gen = gen_neon_vrev32;\n+          break;\n+\tcase E_V4SImode:\n+\tcase E_V2SImode:\n+\tcase E_V4SFmode:\n+\tcase E_V2SFmode:\n+          gen = gen_neon_vrev64;\n+\t  break;\n+        default:\n \t  return false;\n \t}\n       break;\n@@ -29239,7 +29196,7 @@ arm_evpc_neon_vrev (struct expand_vec_perm_d *d)\n   if (d->testing_p)\n     return true;\n \n-  emit_insn (gen (d->target, d->op0));\n+  emit_insn (gen (d->vmode, d->target, d->op0));\n   return true;\n }\n \n@@ -29250,7 +29207,6 @@ arm_evpc_neon_vtrn (struct expand_vec_perm_d *d)\n {\n   unsigned int i, odd, mask, nelt = d->perm.length ();\n   rtx out0, out1, in0, in1;\n-  rtx (*gen)(rtx, rtx, rtx, rtx);\n \n   if (GET_MODE_UNIT_SIZE (d->vmode) >= 8)\n     return false;\n@@ -29276,22 +29232,6 @@ arm_evpc_neon_vtrn (struct expand_vec_perm_d *d)\n   if (d->testing_p)\n     return true;\n \n-  switch (d->vmode)\n-    {\n-    case E_V16QImode: gen = gen_neon_vtrnv16qi_internal; break;\n-    case E_V8QImode:  gen = gen_neon_vtrnv8qi_internal;  break;\n-    case E_V8HImode:  gen = gen_neon_vtrnv8hi_internal;  break;\n-    case E_V4HImode:  gen = gen_neon_vtrnv4hi_internal;  break;\n-    case E_V8HFmode:  gen = gen_neon_vtrnv8hf_internal;  break;\n-    case E_V4HFmode:  gen = gen_neon_vtrnv4hf_internal;  break;\n-    case E_V4SImode:  gen = gen_neon_vtrnv4si_internal;  break;\n-    case E_V2SImode:  gen = gen_neon_vtrnv2si_internal;  break;\n-    case E_V2SFmode:  gen = gen_neon_vtrnv2sf_internal;  break;\n-    case E_V4SFmode:  gen = gen_neon_vtrnv4sf_internal;  break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n   in0 = d->op0;\n   in1 = d->op1;\n   if (BYTES_BIG_ENDIAN)\n@@ -29305,7 +29245,7 @@ arm_evpc_neon_vtrn (struct expand_vec_perm_d *d)\n   if (odd)\n     std::swap (out0, out1);\n \n-  emit_insn (gen (out0, in0, in1, out1));\n+  emit_insn (gen_neon_vtrn_internal (d->vmode, out0, in0, in1, out1));\n   return true;\n }\n \n@@ -29315,7 +29255,6 @@ static bool\n arm_evpc_neon_vext (struct expand_vec_perm_d *d)\n {\n   unsigned int i, nelt = d->perm.length ();\n-  rtx (*gen) (rtx, rtx, rtx, rtx);\n   rtx offset;\n \n   unsigned int location;\n@@ -29351,29 +29290,16 @@ arm_evpc_neon_vext (struct expand_vec_perm_d *d)\n \n   location = d->perm[0];\n \n-  switch (d->vmode)\n-    {\n-    case E_V16QImode: gen = gen_neon_vextv16qi; break;\n-    case E_V8QImode: gen = gen_neon_vextv8qi; break;\n-    case E_V4HImode: gen = gen_neon_vextv4hi; break;\n-    case E_V8HImode: gen = gen_neon_vextv8hi; break;\n-    case E_V2SImode: gen = gen_neon_vextv2si; break;\n-    case E_V4SImode: gen = gen_neon_vextv4si; break;\n-    case E_V4HFmode: gen = gen_neon_vextv4hf; break;\n-    case E_V8HFmode: gen = gen_neon_vextv8hf; break;\n-    case E_V2SFmode: gen = gen_neon_vextv2sf; break;\n-    case E_V4SFmode: gen = gen_neon_vextv4sf; break;\n-    case E_V2DImode: gen = gen_neon_vextv2di; break;\n-    default:\n-      return false;\n-    }\n-\n   /* Success! */\n   if (d->testing_p)\n     return true;\n \n   offset = GEN_INT (location);\n-  emit_insn (gen (d->target, d->op0, d->op1, offset));\n+\n+  if(d->vmode == E_DImode)\n+    return false;\n+\n+  emit_insn (gen_neon_vext (d->vmode, d->target, d->op0, d->op1, offset));\n   return true;\n }\n "}, {"sha": "8618018b07dd432ac11bf31baa1cdaf027218e03", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03f2d18df99b3ca637b81c35e516bbf5454687/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03f2d18df99b3ca637b81c35e516bbf5454687/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=ff03f2d18df99b3ca637b81c35e516bbf5454687", "patch": "@@ -4822,7 +4822,7 @@ if (BYTES_BIG_ENDIAN)\n   DONE;\n })\n \n-(define_insn \"neon_vext<mode>\"\n+(define_insn \"@neon_vext<mode>\"\n   [(set (match_operand:VDQX 0 \"s_register_operand\" \"=w\")\n \t(unspec:VDQX [(match_operand:VDQX 1 \"s_register_operand\" \"w\")\n \t\t      (match_operand:VDQX 2 \"s_register_operand\" \"w\")\n@@ -4836,7 +4836,7 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_ext<q>\")]\n )\n \n-(define_insn \"neon_vrev64<mode>\"\n+(define_insn \"@neon_vrev64<mode>\"\n   [(set (match_operand:VDQ 0 \"s_register_operand\" \"=w\")\n \t(unspec:VDQ [(match_operand:VDQ 1 \"s_register_operand\" \"w\")]\n                     UNSPEC_VREV64))]\n@@ -4845,7 +4845,7 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_rev<q>\")]\n )\n \n-(define_insn \"neon_vrev32<mode>\"\n+(define_insn \"@neon_vrev32<mode>\"\n   [(set (match_operand:VX 0 \"s_register_operand\" \"=w\")\n \t(unspec:VX [(match_operand:VX 1 \"s_register_operand\" \"w\")]\n                    UNSPEC_VREV32))]\n@@ -4854,7 +4854,7 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_rev<q>\")]\n )\n \n-(define_insn \"neon_vrev16<mode>\"\n+(define_insn \"@neon_vrev16<mode>\"\n   [(set (match_operand:VE 0 \"s_register_operand\" \"=w\")\n \t(unspec:VE [(match_operand:VE 1 \"s_register_operand\" \"w\")]\n                    UNSPEC_VREV16))]\n@@ -5310,7 +5310,7 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_tbl4\")]\n )\n \n-(define_expand \"neon_vtrn<mode>_internal\"\n+(define_expand \"@neon_vtrn<mode>_internal\"\n   [(parallel\n     [(set (match_operand:VDQWH 0 \"s_register_operand\")\n \t  (unspec:VDQWH [(match_operand:VDQWH 1 \"s_register_operand\")\n@@ -5336,7 +5336,7 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_permute<q>\")]\n )\n \n-(define_expand \"neon_vzip<mode>_internal\"\n+(define_expand \"@neon_vzip<mode>_internal\"\n   [(parallel\n     [(set (match_operand:VDQWH 0 \"s_register_operand\")\n \t  (unspec:VDQWH [(match_operand:VDQWH 1 \"s_register_operand\")\n@@ -5362,7 +5362,7 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_zip<q>\")]\n )\n \n-(define_expand \"neon_vuzp<mode>_internal\"\n+(define_expand \"@neon_vuzp<mode>_internal\"\n   [(parallel\n     [(set (match_operand:VDQWH 0 \"s_register_operand\")\n \t  (unspec:VDQWH [(match_operand:VDQWH 1 \"s_register_operand\")"}, {"sha": "1c3cd60cc4379cfc93cb178ac2a6a67caa0edf40", "filename": "gcc/config/arm/sync.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03f2d18df99b3ca637b81c35e516bbf5454687/gcc%2Fconfig%2Farm%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03f2d18df99b3ca637b81c35e516bbf5454687/gcc%2Fconfig%2Farm%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fsync.md?ref=ff03f2d18df99b3ca637b81c35e516bbf5454687", "patch": "@@ -186,7 +186,7 @@\n \n ;; Constraints of this pattern must be at least as strict as those of the\n ;; cbranchsi operations in thumb1.md and aim to be as permissive.\n-(define_insn_and_split \"atomic_compare_and_swap<CCSI:arch><NARROW:mode>_1\"\n+(define_insn_and_split \"@atomic_compare_and_swap<CCSI:arch><NARROW:mode>_1\"\n   [(set (match_operand:CCSI 0 \"cc_register_operand\" \"=&c,&l,&l,&l\")\t;; bool out\n \t(unspec_volatile:CCSI [(const_int 0)] VUNSPEC_ATOMIC_CAS))\n    (set (match_operand:SI 1 \"s_register_operand\" \"=&r,&l,&0,&l*h\")\t;; val out\n@@ -218,7 +218,7 @@\n \n ;; Constraints of this pattern must be at least as strict as those of the\n ;; cbranchsi operations in thumb1.md and aim to be as permissive.\n-(define_insn_and_split \"atomic_compare_and_swap<CCSI:arch><SIDI:mode>_1\"\n+(define_insn_and_split \"@atomic_compare_and_swap<CCSI:arch><SIDI:mode>_1\"\n   [(set (match_operand:CCSI 0 \"cc_register_operand\" \"=&c,&l,&l,&l\")\t;; bool out\n \t(unspec_volatile:CCSI [(const_int 0)] VUNSPEC_ATOMIC_CAS))\n    (set (match_operand:SIDI 1 \"s_register_operand\" \"=&r,&l,&0,&l*h\")\t;; val out"}]}