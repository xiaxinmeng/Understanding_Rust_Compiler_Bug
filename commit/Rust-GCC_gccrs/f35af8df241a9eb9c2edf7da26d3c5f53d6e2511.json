{"sha": "f35af8df241a9eb9c2edf7da26d3c5f53d6e2511", "node_id": "C_kwDOANBUbNoAKGYzNWFmOGRmMjQxYTllYjljMmVkZjdkYTI2ZDNjNWY1M2Q2ZTI1MTE", "commit": {"author": {"name": "Xionghu Luo", "email": "luoxhu@linux.ibm.com", "date": "2021-11-01T05:12:36Z"}, "committer": {"name": "Xionghu Luo", "email": "luoxhu@linux.ibm.com", "date": "2021-11-01T05:13:19Z"}, "message": "Refactor loop_version\n\nloop_version currently does lv_adjust_loop_entry_edge\nbefore it loopifys the copy inserted on the header.  This patch moves\nthe condition generation later and thus we have four pieces to help\nunderstanding of how the adjustment works:\n 1) duplicating the loop on the entry edge.\n 2) loopify the duplicated new loop.\n 3) adjusting the CFG to insert a condition branching to either loop\n with lv_adjust_loop_entry_edge.\n 4) From loopify extract the scale_loop_frequencies bits.\n\nAlso removed some piece of code seems obviously useless:\n - redirect_all_edges since it is false and loopify only called once.\n - extract_cond_bb_edges and lv_flush_pending_stmts (false_edge) as the\n edge is not redirected actually.\n\ngcc/ChangeLog:\n\n2021-11-01  Xionghu Luo  <luoxhu@linux.ibm.com>\n\n\t* cfgloopmanip.c (loop_version): Refactor loopify to\n\tloop_version.  Move condition generation after loopify.\n\t(loopify): Delete.\n\t* cfgloopmanip.h (loopify): Delete.", "tree": {"sha": "86849b0db6931ea7879a63c9d2f7e9f3416f0d1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86849b0db6931ea7879a63c9d2f7e9f3416f0d1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f35af8df241a9eb9c2edf7da26d3c5f53d6e2511", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f35af8df241a9eb9c2edf7da26d3c5f53d6e2511", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f35af8df241a9eb9c2edf7da26d3c5f53d6e2511", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f35af8df241a9eb9c2edf7da26d3c5f53d6e2511/comments", "author": {"login": "xionghul", "id": 4607154, "node_id": "MDQ6VXNlcjQ2MDcxNTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4607154?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xionghul", "html_url": "https://github.com/xionghul", "followers_url": "https://api.github.com/users/xionghul/followers", "following_url": "https://api.github.com/users/xionghul/following{/other_user}", "gists_url": "https://api.github.com/users/xionghul/gists{/gist_id}", "starred_url": "https://api.github.com/users/xionghul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xionghul/subscriptions", "organizations_url": "https://api.github.com/users/xionghul/orgs", "repos_url": "https://api.github.com/users/xionghul/repos", "events_url": "https://api.github.com/users/xionghul/events{/privacy}", "received_events_url": "https://api.github.com/users/xionghul/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xionghul", "id": 4607154, "node_id": "MDQ6VXNlcjQ2MDcxNTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4607154?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xionghul", "html_url": "https://github.com/xionghul", "followers_url": "https://api.github.com/users/xionghul/followers", "following_url": "https://api.github.com/users/xionghul/following{/other_user}", "gists_url": "https://api.github.com/users/xionghul/gists{/gist_id}", "starred_url": "https://api.github.com/users/xionghul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xionghul/subscriptions", "organizations_url": "https://api.github.com/users/xionghul/orgs", "repos_url": "https://api.github.com/users/xionghul/repos", "events_url": "https://api.github.com/users/xionghul/events{/privacy}", "received_events_url": "https://api.github.com/users/xionghul/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a71ea4df7e97a640e6747d6787a1885eb3bbc40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a71ea4df7e97a640e6747d6787a1885eb3bbc40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a71ea4df7e97a640e6747d6787a1885eb3bbc40"}], "stats": {"total": 116, "additions": 29, "deletions": 87}, "files": [{"sha": "a30ebe1cdb4752f20b37a447effd64018f95aead", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 29, "deletions": 84, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35af8df241a9eb9c2edf7da26d3c5f53d6e2511/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35af8df241a9eb9c2edf7da26d3c5f53d6e2511/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=f35af8df241a9eb9c2edf7da26d3c5f53d6e2511", "patch": "@@ -846,71 +846,6 @@ create_empty_loop_on_edge (edge entry_edge,\n   return loop;\n }\n \n-/* Make area between HEADER_EDGE and LATCH_EDGE a loop by connecting\n-   latch to header and update loop tree and dominators\n-   accordingly. Everything between them plus LATCH_EDGE destination must\n-   be dominated by HEADER_EDGE destination, and back-reachable from\n-   LATCH_EDGE source.  HEADER_EDGE is redirected to basic block SWITCH_BB,\n-   FALSE_EDGE of SWITCH_BB to original destination of HEADER_EDGE and\n-   TRUE_EDGE of SWITCH_BB to original destination of LATCH_EDGE.\n-   Returns the newly created loop.  Frequencies and counts in the new loop\n-   are scaled by FALSE_SCALE and in the old one by TRUE_SCALE.  */\n-\n-class loop *\n-loopify (edge latch_edge, edge header_edge,\n-\t basic_block switch_bb, edge true_edge, edge false_edge,\n-\t bool redirect_all_edges, profile_probability true_scale,\n-\t profile_probability false_scale)\n-{\n-  basic_block succ_bb = latch_edge->dest;\n-  basic_block pred_bb = header_edge->src;\n-  class loop *loop = alloc_loop ();\n-  class loop *outer = loop_outer (succ_bb->loop_father);\n-  profile_count cnt;\n-\n-  loop->header = header_edge->dest;\n-  loop->latch = latch_edge->src;\n-\n-  cnt = header_edge->count ();\n-\n-  /* Redirect edges.  */\n-  loop_redirect_edge (latch_edge, loop->header);\n-  loop_redirect_edge (true_edge, succ_bb);\n-\n-  /* During loop versioning, one of the switch_bb edge is already properly\n-     set. Do not redirect it again unless redirect_all_edges is true.  */\n-  if (redirect_all_edges)\n-    {\n-      loop_redirect_edge (header_edge, switch_bb);\n-      loop_redirect_edge (false_edge, loop->header);\n-\n-      /* Update dominators.  */\n-      set_immediate_dominator (CDI_DOMINATORS, switch_bb, pred_bb);\n-      set_immediate_dominator (CDI_DOMINATORS, loop->header, switch_bb);\n-    }\n-\n-  set_immediate_dominator (CDI_DOMINATORS, succ_bb, switch_bb);\n-\n-  /* Compute new loop.  */\n-  add_loop (loop, outer);\n-\n-  /* Add switch_bb to appropriate loop.  */\n-  if (switch_bb->loop_father)\n-    remove_bb_from_loops (switch_bb);\n-  add_bb_to_loop (switch_bb, outer);\n-\n-  /* Fix counts.  */\n-  if (redirect_all_edges)\n-    {\n-      switch_bb->count = cnt;\n-    }\n-  scale_loop_frequencies (loop, false_scale);\n-  scale_loop_frequencies (succ_bb->loop_father, true_scale);\n-  update_dominators_in_loop (loop);\n-\n-  return loop;\n-}\n-\n /* Remove the latch edge of a LOOP and update loops to indicate that\n    the LOOP was removed.  After this function, original loop latch will\n    have no successor, which caller is expected to fix somehow.\n@@ -1681,7 +1616,7 @@ loop_version (class loop *loop,\n \t      bool place_after)\n {\n   basic_block first_head, second_head;\n-  edge entry, latch_edge, true_edge, false_edge;\n+  edge entry, latch_edge;\n   int irred_flag;\n   class loop *nloop;\n   basic_block cond_bb;\n@@ -1694,19 +1629,36 @@ loop_version (class loop *loop,\n   /* Note down head of loop as first_head.  */\n   first_head = entry->dest;\n \n-  /* Duplicate loop.  */\n+  /* 1) Duplicate loop on the entry edge.  */\n   if (!cfg_hook_duplicate_loop_to_header_edge (loop, entry, 1,\n \t\t\t\t\t       NULL, NULL, NULL, 0))\n     {\n       entry->flags |= irred_flag;\n       return NULL;\n     }\n \n+  /* 2) loopify the duplicated new loop. */\n+  latch_edge = single_succ_edge (get_bb_copy (loop->latch));\n+  nloop = alloc_loop ();\n+  class loop *outer = loop_outer (latch_edge->dest->loop_father);\n+  edge new_header_edge = single_pred_edge (get_bb_copy (loop->header));\n+  nloop->header = new_header_edge->dest;\n+  nloop->latch = latch_edge->src;\n+  loop_redirect_edge (latch_edge, nloop->header);\n+\n+  /* Compute new loop.  */\n+  add_loop (nloop, outer);\n+  copy_loop_info (loop, nloop);\n+  set_loop_copy (loop, nloop);\n+\n+  /* loopify redirected latch_edge. Update its PENDING_STMTS.  */\n+  lv_flush_pending_stmts (latch_edge);\n+\n   /* After duplication entry edge now points to new loop head block.\n      Note down new head as second_head.  */\n   second_head = entry->dest;\n \n-  /* Split loop entry edge and insert new block with cond expr.  */\n+  /* 3) Split loop entry edge and insert new block with cond expr.  */\n   cond_bb =  lv_adjust_loop_entry_edge (first_head, second_head,\n \t\t\t\t\tentry, cond_expr, then_prob, else_prob);\n   if (condition_bb)\n@@ -1718,24 +1670,17 @@ loop_version (class loop *loop,\n       return NULL;\n     }\n \n-  latch_edge = single_succ_edge (get_bb_copy (loop->latch));\n-\n-  extract_cond_bb_edges (cond_bb, &true_edge, &false_edge);\n-  nloop = loopify (latch_edge,\n-\t\t   single_pred_edge (get_bb_copy (loop->header)),\n-\t\t   cond_bb, true_edge, false_edge,\n-\t\t   false /* Do not redirect all edges.  */,\n-\t\t   then_scale, else_scale);\n-\n-  copy_loop_info (loop, nloop);\n-  set_loop_copy (loop, nloop);\n+  /* Add cond_bb to appropriate loop.  */\n+  if (cond_bb->loop_father)\n+    remove_bb_from_loops (cond_bb);\n+  add_bb_to_loop (cond_bb, outer);\n \n-  /* loopify redirected latch_edge. Update its PENDING_STMTS.  */\n-  lv_flush_pending_stmts (latch_edge);\n+  /* 4) Scale the original loop and new loop frequency.  */\n+  scale_loop_frequencies (loop, then_scale);\n+  scale_loop_frequencies (nloop, else_scale);\n+  update_dominators_in_loop (loop);\n+  update_dominators_in_loop (nloop);\n \n-  /* loopify redirected condition_bb's succ edge. Update its PENDING_STMTS.  */\n-  extract_cond_bb_edges (cond_bb, &true_edge, &false_edge);\n-  lv_flush_pending_stmts (false_edge);\n   /* Adjust irreducible flag.  */\n   if (irred_flag)\n     {"}, {"sha": "312a3b48d05fa7dda4ecec9c1046a84bf126c26e", "filename": "gcc/cfgloopmanip.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35af8df241a9eb9c2edf7da26d3c5f53d6e2511/gcc%2Fcfgloopmanip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35af8df241a9eb9c2edf7da26d3c5f53d6e2511/gcc%2Fcfgloopmanip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.h?ref=f35af8df241a9eb9c2edf7da26d3c5f53d6e2511", "patch": "@@ -42,9 +42,6 @@ extern void scale_loop_profile (class loop *, profile_probability, gcov_type);\n extern edge create_empty_if_region_on_edge (edge, tree);\n extern class loop *create_empty_loop_on_edge (edge, tree, tree, tree, tree,\n \t\t\t\t\t       tree *, tree *, class loop *);\n-extern class loop *loopify (edge, edge,\n-\t\t\t     basic_block, edge, edge, bool,\n-\t\t\t     profile_probability, profile_probability);\n extern void unloop (class loop *, bool *, bitmap);\n extern void copy_loop_info (class loop *loop, class loop *target);\n extern class loop * duplicate_loop (class loop *, class loop *,"}]}