{"sha": "52ff33d0eb56df70238a99b7aa66140609f3abc3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJmZjMzZDBlYjU2ZGY3MDIzOGE5OWI3YWE2NjE0MDYwOWYzYWJjMw==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2007-06-05T19:46:23Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2007-06-05T19:46:23Z"}, "message": "rs6000.h (FIXED_SCRATCH): Use r0 as a scratch register on SPE targets.\n\n\t* config/rs6000/rs6000.h (FIXED_SCRATCH): Use r0 as a scratch\n\tregister on SPE targets.  Change documentation to reflect\n\treality.\n\t* config/rs6000/rs6000.c (rs6000_conditional_register_usage):\n\tChange FIXED_SCRATCH to 14 and document why we're keeping r14\n\tout of the register allocation pool.\n\t(rs6000_reg_live_or_pic_offset_p): New function.\n\t(rs6000_emit_prologue): Move the actual saving of LR up to free\n\tr0 for holding r11.  Split saving of SPE 64-bit registers into\n\tits own case.  Ensure that offsets will always be in-range for\n\t'evstdd' by using r11 as a scratch register to point at the start\n\tof the SPE save area.  Save r11 if necessary, as it is the static\n\tchain register.\n\t(rs6000_emit_epilogue): Split restoring of SPE 64-bit registers\n\tinto its own case.  Ensure that offsets will always be in-range\n\tfor 'evldd' by using r11 as a scratch register to point at the\n\tstart of the SPE save area.  Also adjust r11 when restoring\n\tthe stack pointer to compensate for pre-loading r11.\n\nFrom-SVN: r125340", "tree": {"sha": "ddb2aff474d2b21b69f98462040e6897f8ebc7ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddb2aff474d2b21b69f98462040e6897f8ebc7ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52ff33d0eb56df70238a99b7aa66140609f3abc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52ff33d0eb56df70238a99b7aa66140609f3abc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52ff33d0eb56df70238a99b7aa66140609f3abc3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52ff33d0eb56df70238a99b7aa66140609f3abc3/comments", "author": null, "committer": null, "parents": [{"sha": "b08f991d9127706927d639bb51173e4474b976df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b08f991d9127706927d639bb51173e4474b976df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b08f991d9127706927d639bb51173e4474b976df"}], "stats": {"total": 309, "additions": 207, "deletions": 102}, "files": [{"sha": "bf664a8e64d960b4efe9ba20e745a04433824e9a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ff33d0eb56df70238a99b7aa66140609f3abc3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ff33d0eb56df70238a99b7aa66140609f3abc3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52ff33d0eb56df70238a99b7aa66140609f3abc3", "patch": "@@ -1,3 +1,24 @@\n+2007-06-06  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* config/rs6000/rs6000.h (FIXED_SCRATCH): Use r0 as a scratch\n+\tregister on SPE targets.  Change documentation to reflect\n+\treality.\n+\t* config/rs6000/rs6000.c (rs6000_conditional_register_usage):\n+\tChange FIXED_SCRATCH to 14 and document why we're keeping r14\n+\tout of the register allocation pool.\n+\t(rs6000_reg_live_or_pic_offset_p): New function.\n+\t(rs6000_emit_prologue): Move the actual saving of LR up to free\n+\tr0 for holding r11.  Split saving of SPE 64-bit registers into\n+\tits own case.  Ensure that offsets will always be in-range for\n+\t'evstdd' by using r11 as a scratch register to point at the start\n+\tof the SPE save area.  Save r11 if necessary, as it is the static\n+\tchain register.\n+\t(rs6000_emit_epilogue): Split restoring of SPE 64-bit registers\n+\tinto its own case.  Ensure that offsets will always be in-range\n+\tfor 'evldd' by using r11 as a scratch register to point at the\n+\tstart of the SPE save area.  Also adjust r11 when restoring\n+\tthe stack pointer to compensate for pre-loading r11.\n+\n 2007-06-05  Thomas Neumann  <tneumann@users.sourceforge.net>\n \n \t* cfg.c (init_flow): Use type safe memory macros."}, {"sha": "67b7c86cda9b00e33a2ca198f9b675d265aa268d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 181, "deletions": 91, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ff33d0eb56df70238a99b7aa66140609f3abc3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ff33d0eb56df70238a99b7aa66140609f3abc3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=52ff33d0eb56df70238a99b7aa66140609f3abc3", "patch": "@@ -648,6 +648,7 @@ static void rs6000_eliminate_indexed_memrefs (rtx operands[2]);\n static const char *rs6000_mangle_fundamental_type (tree);\n extern const struct attribute_spec rs6000_attribute_table[];\n static void rs6000_set_default_type_attributes (tree);\n+static bool rs6000_reg_live_or_pic_offset_p (int);\n static void rs6000_output_function_prologue (FILE *, HOST_WIDE_INT);\n static void rs6000_output_function_epilogue (FILE *, HOST_WIDE_INT);\n static void rs6000_output_mi_thunk (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT,\n@@ -3991,9 +3992,15 @@ rs6000_conditional_register_usage (void)\n   if (TARGET_SPE)\n     {\n       global_regs[SPEFSCR_REGNO] = 1;\n-      fixed_regs[FIXED_SCRATCH]\n-\t= call_used_regs[FIXED_SCRATCH]\n-\t= call_really_used_regs[FIXED_SCRATCH] = 1;\n+      /* We used to use r14 as FIXED_SCRATCH to address SPE 64-bit\n+         registers in prologues and epilogues.  We no longer use r14\n+         for FIXED_SCRATCH, but we're keeping r14 out of the allocation\n+         pool for link-compatibility with older versions of GCC.  Once\n+         \"old\" code has died out, we can return r14 to the allocation\n+         pool.  */\n+      fixed_regs[14]\n+\t= call_used_regs[14]\n+\t= call_really_used_regs[14] = 1;\n     }\n \n   if (! TARGET_ALTIVEC)\n@@ -14629,6 +14636,20 @@ no_global_regs_above (int first_greg)\n #define TARGET_FIX_AND_CONTINUE 0\n #endif\n \n+/* Determine whether the gp REG is really used.  */\n+\n+static bool\n+rs6000_reg_live_or_pic_offset_p (int reg)\n+{\n+  return ((regs_ever_live[reg]\n+           && (!call_used_regs[reg]\n+               || (reg == RS6000_PIC_OFFSET_TABLE_REGNUM\n+                   && TARGET_TOC && TARGET_MINIMAL_TOC)))\n+          || (reg == RS6000_PIC_OFFSET_TABLE_REGNUM\n+              && ((DEFAULT_ABI == ABI_V4 && flag_pic != 0)\n+                  || (DEFAULT_ABI == ABI_DARWIN && flag_pic))));\n+}\n+\n /* Emit function prologue as insns.  */\n \n void\n@@ -14815,9 +14836,22 @@ rs6000_emit_prologue (void)\n   /* If we use the link register, get it into r0.  */\n   if (!WORLD_SAVE_P (info) && info->lr_save_p)\n     {\n+      rtx addr, reg, mem;\n+\n       insn = emit_move_insn (gen_rtx_REG (Pmode, 0),\n \t\t\t     gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n       RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t       GEN_INT (info->lr_save_offset + sp_offset));\n+      reg = gen_rtx_REG (Pmode, 0);\n+      mem = gen_rtx_MEM (Pmode, addr);\n+      /* This should not be of rs6000_sr_alias_set, because of\n+\t __builtin_return_address.  */\n+\n+      insn = emit_move_insn (mem, reg);\n+      rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n+\t\t\t    NULL_RTX, NULL_RTX);\n     }\n \n   /* If we need to save CR, put it into r12.  */\n@@ -14910,59 +14944,99 @@ rs6000_emit_prologue (void)\n       rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n \t\t\t    NULL_RTX, NULL_RTX);\n     }\n+   else if (!WORLD_SAVE_P (info)\n+            && TARGET_SPE_ABI\n+            && info->spe_64bit_regs_used != 0\n+            && info->first_gp_reg_save != 32)\n+     {\n+       int i;\n+       rtx spe_save_area_ptr;\n+       int using_static_chain_p = (cfun->static_chain_decl != NULL_TREE\n+                                   && regs_ever_live[STATIC_CHAIN_REGNUM]\n+                                   && !call_used_regs[STATIC_CHAIN_REGNUM]);\n+ \n+       /* Determine whether we can address all of the registers that need\n+          to be saved with an offset from the stack pointer that fits in\n+          the small const field for SPE memory instructions.  */\n+       int spe_regs_addressable_via_sp\n+         = SPE_CONST_OFFSET_OK(info->spe_gp_save_offset + sp_offset\n+                               + (32 - info->first_gp_reg_save - 1) * reg_size);\n+       int spe_offset;\n+ \n+       if (spe_regs_addressable_via_sp)\n+         {\n+           spe_save_area_ptr = sp_reg_rtx;\n+           spe_offset = info->spe_gp_save_offset + sp_offset;\n+         }\n+       else\n+         {\n+           /* Make r11 point to the start of the SPE save area.  We need\n+              to be careful here if r11 is holding the static chain.  If\n+              it is, then temporarily save it in r0.  We would use r0 as\n+              our base register here, but using r0 as a base register in\n+              loads and stores means something different from what we\n+              would like.  */\n+           if (using_static_chain_p)\n+             {\n+               rtx r0 = gen_rtx_REG (Pmode, 0);\n+ \n+               gcc_assert (info->first_gp_reg_save > 11);\n+ \n+               emit_move_insn (r0, gen_rtx_REG (Pmode, 11));\n+             }\n+ \n+           spe_save_area_ptr = gen_rtx_REG (Pmode, 11);\n+           emit_insn (gen_addsi3 (spe_save_area_ptr, sp_reg_rtx,\n+                                  GEN_INT (info->spe_gp_save_offset + sp_offset)));\n+ \n+           spe_offset = 0;\n+         }\n+ \n+       for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n+         if (rs6000_reg_live_or_pic_offset_p (info->first_gp_reg_save + i))\n+           {\n+             rtx reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n+             rtx offset, addr, mem;\n+ \n+             /* We're doing all this to ensure that the offset fits into\n+                the immediate offset of 'evstdd'.  */\n+             gcc_assert (SPE_CONST_OFFSET_OK (reg_size * i + spe_offset));\n+ \n+             offset = GEN_INT (reg_size * i + spe_offset);\n+             addr = gen_rtx_PLUS (Pmode, spe_save_area_ptr, offset);\n+             mem = gen_rtx_MEM (V2SImode, addr);\n+ \n+             insn = emit_move_insn (mem, reg);\n+           \n+             rs6000_frame_related (insn, spe_save_area_ptr,\n+                                   info->spe_gp_save_offset\n+                                   + sp_offset + reg_size * i,\n+                                   offset, const0_rtx);\n+           }\n+ \n+       /* Move the static chain pointer back.  */\n+       if (using_static_chain_p && !spe_regs_addressable_via_sp)\n+         emit_move_insn (gen_rtx_REG (Pmode, 11), gen_rtx_REG (Pmode, 0));\n+     }\n   else if (!WORLD_SAVE_P (info))\n     {\n       int i;\n       for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n-\tif ((regs_ever_live[info->first_gp_reg_save + i]\n-\t     && (!call_used_regs[info->first_gp_reg_save + i]\n-\t\t || (i + info->first_gp_reg_save\n-\t\t     == RS6000_PIC_OFFSET_TABLE_REGNUM\n-\t\t     && TARGET_TOC && TARGET_MINIMAL_TOC)))\n-\t    || (i + info->first_gp_reg_save == RS6000_PIC_OFFSET_TABLE_REGNUM\n-\t\t&& ((DEFAULT_ABI == ABI_V4 && flag_pic != 0)\n-\t\t    || (DEFAULT_ABI == ABI_DARWIN && flag_pic))))\n-\t  {\n-\t    rtx addr, reg, mem;\n-\t    reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n+\tif (rs6000_reg_live_or_pic_offset_p (info->first_gp_reg_save + i))\n+          {\n+            rtx addr, reg, mem;\n+            reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n \n-\t    if (TARGET_SPE_ABI && info->spe_64bit_regs_used != 0)\n-\t      {\n-\t\tint offset = info->spe_gp_save_offset + sp_offset + 8 * i;\n-\t\trtx b;\n+            addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+                                 GEN_INT (info->gp_save_offset\n+                                          + sp_offset\n+                                          + reg_size * i));\n+            mem = gen_frame_mem (reg_mode, addr);\n \n-\t\tif (!SPE_CONST_OFFSET_OK (offset))\n-\t\t  {\n-\t\t    b = gen_rtx_REG (Pmode, FIXED_SCRATCH);\n-\t\t    emit_move_insn (b, GEN_INT (offset));\n-\t\t  }\n-\t\telse\n-\t\t  b = GEN_INT (offset);\n-\n-\t\taddr = gen_rtx_PLUS (Pmode, frame_reg_rtx, b);\n-\t\tmem = gen_frame_mem (V2SImode, addr);\n-\t\tinsn = emit_move_insn (mem, reg);\n-\n-\t\tif (GET_CODE (b) == CONST_INT)\n-\t\t  rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n-\t\t\t\t\tNULL_RTX, NULL_RTX);\n-\t\telse\n-\t\t  rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n-\t\t\t\t\tb, GEN_INT (offset));\n-\t      }\n-\t    else\n-\t      {\n-\t\taddr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t\t     GEN_INT (info->gp_save_offset\n-\t\t\t\t\t      + sp_offset\n-\t\t\t\t\t      + reg_size * i));\n-\t\tmem = gen_frame_mem (reg_mode, addr);\n-\n-\t\tinsn = emit_move_insn (mem, reg);\n-\t\trs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n-\t\t\t\t      NULL_RTX, NULL_RTX);\n-\t      }\n-\t  }\n+            insn = emit_move_insn (mem, reg);\n+            rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n+                                  NULL_RTX, NULL_RTX);\n+          }\n     }\n \n   /* ??? There's no need to emit actual instructions here, but it's the\n@@ -15000,21 +15074,6 @@ rs6000_emit_prologue (void)\n \t}\n     }\n \n-  /* Save lr if we used it.  */\n-  if (!WORLD_SAVE_P (info) && info->lr_save_p)\n-    {\n-      rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t       GEN_INT (info->lr_save_offset + sp_offset));\n-      rtx reg = gen_rtx_REG (Pmode, 0);\n-      rtx mem = gen_rtx_MEM (Pmode, addr);\n-      /* This should not be of frame_alias_set, because of\n-\t __builtin_return_address.  */\n-\n-      insn = emit_move_insn (mem, reg);\n-      rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n-\t\t\t    NULL_RTX, NULL_RTX);\n-    }\n-\n   /* Save CR if we use any that must be preserved.  */\n   if (!WORLD_SAVE_P (info) && info->cr_save_p)\n     {\n@@ -15548,40 +15607,65 @@ rs6000_emit_epilogue (int sibcall)\n \t}\n       emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n     }\n+  else if (TARGET_SPE_ABI\n+           && info->spe_64bit_regs_used != 0\n+           && info->first_gp_reg_save != 32)\n+    {\n+      rtx spe_save_area_ptr;\n+      /* Determine whether we can address all of the registers that need\n+         to be saved with an offset from the stack pointer that fits in\n+         the small const field for SPE memory instructions.  */\n+      int spe_regs_addressable_via_sp\n+        = SPE_CONST_OFFSET_OK(info->spe_gp_save_offset + sp_offset\n+                              + (32 - info->first_gp_reg_save - 1) * reg_size);\n+      int spe_offset;\n+\n+      if (spe_regs_addressable_via_sp)\n+        {\n+          spe_save_area_ptr = frame_reg_rtx;\n+          spe_offset = info->spe_gp_save_offset + sp_offset;\n+        }\n+      else\n+        {\n+          /* Make r11 point to the start of the SPE save area.  We worried about\n+             not clobbering it when we were saving registers in the prolgoue.\n+             There's no need to worry here because the static chain is passed\n+             anew to every function.  */\n+          spe_save_area_ptr = gen_rtx_REG (Pmode, 11);\n+\n+          emit_insn (gen_addsi3 (spe_save_area_ptr, frame_reg_rtx,\n+                                 GEN_INT (info->spe_gp_save_offset + sp_offset)));\n+\n+          spe_offset = 0;\n+        }\n+\n+      for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n+        if (rs6000_reg_live_or_pic_offset_p (info->first_gp_reg_save + i))\n+          {\n+            rtx offset, addr, mem;\n+\n+            /* We're doing all this to ensure that the immediate offset\n+               fits into the immediate field of 'evldd'.  */\n+            gcc_assert (SPE_CONST_OFFSET_OK (spe_offset + reg_size * i));\n+\n+            offset = GEN_INT (spe_offset + reg_size * i);\n+            addr = gen_rtx_PLUS (Pmode, spe_save_area_ptr, offset);\n+            mem = gen_rtx_MEM (V2SImode, addr);\n+\n+            emit_move_insn (gen_rtx_REG (reg_mode, info->first_gp_reg_save + i),\n+                            mem);\n+          }\n+    }\n   else\n     for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n-      if ((regs_ever_live[info->first_gp_reg_save + i]\n-\t   && (!call_used_regs[info->first_gp_reg_save + i]\n-\t       || (i + info->first_gp_reg_save == RS6000_PIC_OFFSET_TABLE_REGNUM\n-\t\t   && TARGET_TOC && TARGET_MINIMAL_TOC)))\n-\t  || (i + info->first_gp_reg_save == RS6000_PIC_OFFSET_TABLE_REGNUM\n-\t      && ((DEFAULT_ABI == ABI_V4 && flag_pic != 0)\n-\t\t  || (DEFAULT_ABI == ABI_DARWIN && flag_pic))))\n+      if (rs6000_reg_live_or_pic_offset_p (info->first_gp_reg_save + i))\n \t{\n \t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n \t\t\t\t   GEN_INT (info->gp_save_offset\n \t\t\t\t\t    + sp_offset\n \t\t\t\t\t    + reg_size * i));\n \t  rtx mem = gen_frame_mem (reg_mode, addr);\n \n-\t  /* Restore 64-bit quantities for SPE.  */\n-\t  if (TARGET_SPE_ABI && info->spe_64bit_regs_used != 0)\n-\t    {\n-\t      int offset = info->spe_gp_save_offset + sp_offset + 8 * i;\n-\t      rtx b;\n-\n-\t      if (!SPE_CONST_OFFSET_OK (offset))\n-\t\t{\n-\t\t  b = gen_rtx_REG (Pmode, FIXED_SCRATCH);\n-\t\t  emit_move_insn (b, GEN_INT (offset));\n-\t\t}\n-\t      else\n-\t\tb = GEN_INT (offset);\n-\n-\t      addr = gen_rtx_PLUS (Pmode, frame_reg_rtx, b);\n-\t      mem = gen_frame_mem (V2SImode, addr);\n-\t    }\n-\n \t  emit_move_insn (gen_rtx_REG (reg_mode,\n \t\t\t\t       info->first_gp_reg_save + i), mem);\n \t}\n@@ -15657,7 +15741,13 @@ rs6000_emit_epilogue (int sibcall)\n       /* This blockage is needed so that sched doesn't decide to move\n \t the sp change before the register restores.  */\n       rs6000_emit_stack_tie ();\n-      emit_move_insn (sp_reg_rtx, frame_reg_rtx);\n+      if (TARGET_SPE_ABI\n+          && info->spe_64bit_regs_used != 0\n+          && info->first_gp_reg_save != 32)\n+        emit_insn (gen_addsi3 (sp_reg_rtx, gen_rtx_REG (Pmode, 11),\n+                               GEN_INT (-(info->spe_gp_save_offset + sp_offset))));\n+      else\n+        emit_move_insn (sp_reg_rtx, frame_reg_rtx);\n     }\n   else if (sp_offset != 0)\n     emit_insn (TARGET_32BIT"}, {"sha": "509cd6efb107a55927bd0d3585868357744ead6a", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ff33d0eb56df70238a99b7aa66140609f3abc3/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ff33d0eb56df70238a99b7aa66140609f3abc3/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=52ff33d0eb56df70238a99b7aa66140609f3abc3", "patch": "@@ -913,18 +913,12 @@ extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n \n #define LOGICAL_OP_NON_SHORT_CIRCUIT 0\n \n-/* A fixed register used at prologue and epilogue generation to fix\n-   addressing modes.  The SPE needs heavy addressing fixes at the last\n-   minute, and it's best to save a register for it.\n+/* A fixed register used at epilogue generation to address SPE registers\n+   with negative offsets.  The 64-bit load/store instructions on the SPE\n+   only take positive offsets (and small ones at that), so we need to\n+   reserve a register for consing up negative offsets.  */\n \n-   AltiVec also needs fixes, but we've gotten around using r11, which\n-   is actually wrong because when use_backchain_to_restore_sp is true,\n-   we end up clobbering r11.\n-\n-   The AltiVec case needs to be fixed.  Dunno if we should break ABI\n-   compatibility and reserve a register for it as well..  */\n-\n-#define FIXED_SCRATCH (TARGET_SPE ? 14 : 11)\n+#define FIXED_SCRATCH 0\n \n /* Define this macro to change register usage conditional on target\n    flags.  */"}]}