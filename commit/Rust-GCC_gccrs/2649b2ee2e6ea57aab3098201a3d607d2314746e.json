{"sha": "2649b2ee2e6ea57aab3098201a3d607d2314746e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY0OWIyZWUyZTZlYTU3YWFiMzA5ODIwMWEzZDYwN2QyMzE0NzQ2ZQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-12-06T12:54:18Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-12-06T12:54:18Z"}, "message": "Allow CSE to generate better code when refering to offsets > 32k.\n\nFrom-SVN: r2839", "tree": {"sha": "8a99515e7e718c314d1a4391c94b2af6a66a1cb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a99515e7e718c314d1a4391c94b2af6a66a1cb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2649b2ee2e6ea57aab3098201a3d607d2314746e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2649b2ee2e6ea57aab3098201a3d607d2314746e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2649b2ee2e6ea57aab3098201a3d607d2314746e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2649b2ee2e6ea57aab3098201a3d607d2314746e/comments", "author": null, "committer": null, "parents": [{"sha": "08455880e70070a2d72640ddaf7f994f00f7aaed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08455880e70070a2d72640ddaf7f994f00f7aaed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08455880e70070a2d72640ddaf7f994f00f7aaed"}], "stats": {"total": 64, "additions": 61, "deletions": 3}, "files": [{"sha": "2653b38956733528755ce0c1f56a839ce2f1f6e1", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 61, "deletions": 3, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2649b2ee2e6ea57aab3098201a3d607d2314746e/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2649b2ee2e6ea57aab3098201a3d607d2314746e/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=2649b2ee2e6ea57aab3098201a3d607d2314746e", "patch": "@@ -482,7 +482,7 @@ while (0)\n \f\n /* Print subsidiary information on the compiler version in use.  */\n \n-#define MIPS_VERSION \"[AL 1.1, MM 29]\"\n+#define MIPS_VERSION \"[AL 1.1, MM 30]\"\n \n #ifndef MACHINE_TYPE\n #define MACHINE_TYPE \"BSD Mips\"\n@@ -2241,9 +2241,67 @@ __enable_execute_stack (addr)\t\t\t\t\t\t\\\n    It is not necessary for this macro to come up with a legitimate\n    address.  The compiler has standard ways of doing so in all\n    cases.  In fact, it is safe for this macro to do nothing.  But\n-   often a machine-dependent strategy can generate better code.  */\n+   often a machine-dependent strategy can generate better code.\n \n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN) {}\n+   For the MIPS, transform:\n+\n+\tmemory(X + <large int>)\n+\n+   into:\n+\n+\tY = <large int> & ~0x7fff;\n+\tZ = X + Y\n+\tmemory (Z + (<large int> & 0x7fff));\n+\n+   This is for CSE to find several similar references, and only use one Z.  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  register rtx xinsn = (X);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_DEBUG_B_MODE)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      GO_PRINTF (\"\\n========== LEGITIMIZE_ADDRESS\\n\");\t\t\t\\\n+      GO_DEBUG_RTX (xinsn);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (xinsn) == PLUS && optimize)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      register rtx xplus0 = XEXP (xinsn, 0);\t\t\t\t\\\n+      register rtx xplus1 = XEXP (xinsn, 1);\t\t\t\t\\\n+      register enum rtx_code code0 = GET_CODE (xplus0);\t\t\t\\\n+      register enum rtx_code code1 = GET_CODE (xplus1);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (code0 != REG && code1 == REG)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  xplus0 = XEXP (xinsn, 1);\t\t\t\t\t\\\n+\t  xplus1 = XEXP (xinsn, 0);\t\t\t\t\t\\\n+\t  code0 = GET_CODE (xplus0);\t\t\t\t\t\\\n+\t  code1 = GET_CODE (xplus1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (code0 == REG && REG_OK_FOR_BASE_P (xplus0)\t\t\t\\\n+\t  && code1 == CONST_INT && !SMALL_INT (xplus1))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  rtx int_reg = gen_reg_rtx (Pmode);\t\t\t\t\\\n+\t  rtx ptr_reg = gen_reg_rtx (Pmode);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  emit_move_insn (int_reg,\t\t\t\t\t\\\n+\t\t\t  GEN_INT (INTVAL (xplus1) & ~ 0x7fff));\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  emit_insn (gen_rtx (SET, VOIDmode,\t\t\t\t\\\n+\t\t\t      ptr_reg,\t\t\t\t\t\\\n+\t\t\t      gen_rtx (PLUS, Pmode, xplus0, int_reg)));\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  X = gen_rtx (PLUS, Pmode, ptr_reg,\t\t\t\t\\\n+\t\t       GEN_INT (INTVAL (xplus1) & 0x7fff));\t\t\\\n+\t  goto WIN;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_DEBUG_B_MODE)\t\t\t\t\t\t\\\n+    GO_PRINTF (\"LEGITIMIZE_ADDRESS could not fix.\\n\");\t\t\t\\\n+}\n \n \n /* A C statement or compound statement with a conditional `goto"}]}