{"sha": "8e6acdb8cd69c66bde4d7eedaf583708de7f540e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU2YWNkYjhjZDY5YzY2YmRlNGQ3ZWVkYWY1ODM3MDhkZTdmNTQwZQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-05-17T17:54:52Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-05-17T17:54:52Z"}, "message": "re PR rtl-optimization/53125 (Very slow compilation on SPARC)\n\n\tPR rtl-optimization/53125\n\t* regstat.c (regstat_bb_compute_ri): Take new local_live_last_luid\n\targument.  Simplify calculation of REG_LIVE_LENGTH for regnos that\n\tdie in the basic block.  Correctly top off REG_FREQ and\n\tREG_FREQ_CALLS_CROSSED.\n\tRemove do_not_gen.\n\t(regstat_compute_ri): Allocate and free local_live_last_luid.\n\tRemove do_not_gen.\n\t(regstat_bb_compute_calls_crossed): Correctly top off\n\tREG_FREQ_CALLS_CROSSED.\n\nFrom-SVN: r187633", "tree": {"sha": "3547213c7d0f90adb777e29b25d5f7e3500dec1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3547213c7d0f90adb777e29b25d5f7e3500dec1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e6acdb8cd69c66bde4d7eedaf583708de7f540e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e6acdb8cd69c66bde4d7eedaf583708de7f540e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e6acdb8cd69c66bde4d7eedaf583708de7f540e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e6acdb8cd69c66bde4d7eedaf583708de7f540e/comments", "author": null, "committer": null, "parents": [{"sha": "6649df51ec79ed1ffe81dc8b93b7fc8cce85040f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6649df51ec79ed1ffe81dc8b93b7fc8cce85040f"}], "stats": {"total": 129, "additions": 81, "deletions": 48}, "files": [{"sha": "320ae0d09ccaf026fd3fe7b6acdff2128a9bdf3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6acdb8cd69c66bde4d7eedaf583708de7f540e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6acdb8cd69c66bde4d7eedaf583708de7f540e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e6acdb8cd69c66bde4d7eedaf583708de7f540e", "patch": "@@ -1,3 +1,16 @@\n+2012-05-17  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\tPR rtl-optimization/53125\n+\t* regstat.c (regstat_bb_compute_ri): Take new local_live_last_luid\n+\targument.  Simplify calculation of REG_LIVE_LENGTH for regnos that\n+\tdie in the basic block.  Correctly top off REG_FREQ and\n+\tREG_FREQ_CALLS_CROSSED.\n+\tRemove do_not_gen.\n+\t(regstat_compute_ri): Allocate and free local_live_last_luid.\n+\tRemove do_not_gen.\n+\t(regstat_bb_compute_calls_crossed): Correctly top off\n+\tREG_FREQ_CALLS_CROSSED.\n+\n 2012-05-17  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-symtab.c (lto_symtab_resolve_symbols): Preffer decl with constructor"}, {"sha": "66a856beee2b907790f4c60f96b425a5e7ee8cab", "filename": "gcc/regstat.c", "status": "modified", "additions": 68, "deletions": 48, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e6acdb8cd69c66bde4d7eedaf583708de7f540e/gcc%2Fregstat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e6acdb8cd69c66bde4d7eedaf583708de7f540e/gcc%2Fregstat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregstat.c?ref=8e6acdb8cd69c66bde4d7eedaf583708de7f540e", "patch": "@@ -118,8 +118,9 @@ size_t reg_info_p_size;\n \n static void\n regstat_bb_compute_ri (unsigned int bb_index,\n-\t\t       bitmap live, bitmap do_not_gen, bitmap artificial_uses,\n-\t\t       bitmap local_live, bitmap local_processed)\n+\t\t       bitmap live, bitmap artificial_uses,\n+\t\t       bitmap local_live, bitmap local_processed,\n+\t\t       int *local_live_last_luid)\n {\n   basic_block bb = BASIC_BLOCK (bb_index);\n   rtx insn;\n@@ -160,25 +161,15 @@ regstat_bb_compute_ri (unsigned int bb_index,\n   FOR_BB_INSNS_REVERSE (bb, insn)\n     {\n       unsigned int uid = INSN_UID (insn);\n-      unsigned int regno;\n       bitmap_iterator bi;\n       struct df_mw_hardreg **mws_rec;\n       rtx link;\n \n       if (!NONDEBUG_INSN_P (insn))\n \tcontinue;\n \n-      /* Increment the live_length for all of the registers that\n-\t are are referenced in this block and live at this\n-\t particular point.  */\n-      EXECUTE_IF_SET_IN_BITMAP (local_live, 0, regno, bi)\n-\t{\n-\t  REG_LIVE_LENGTH (regno)++;\n-\t}\n       luid++;\n \n-      bitmap_clear (do_not_gen);\n-\n       link = REG_NOTES (insn);\n       while (link)\n \t{\n@@ -196,6 +187,8 @@ regstat_bb_compute_ri (unsigned int bb_index,\n \t    {\n \t      REG_N_CALLS_CROSSED (regno)++;\n \t      REG_FREQ_CALLS_CROSSED (regno) += REG_FREQ_FROM_BB (bb);\n+\t      REG_FREQ_CALLS_CROSSED (regno) =\n+\t\tMIN (REG_FREQ_CALLS_CROSSED (regno), REG_FREQ_MAX);\n \t      if (can_throw)\n \t\tREG_N_THROWING_CALLS_CROSSED (regno)++;\n \n@@ -215,8 +208,9 @@ regstat_bb_compute_ri (unsigned int bb_index,\n \t    }\n \t}\n \n-      /* We only care about real sets for calls.  Clobbers only\n-\t may clobbers cannot be depended on.  */\n+      /* We only care about real sets for calls.  Clobbers cannot\n+\t be depended on.\n+\t Only do this if the value is totally dead.  */\n       for (mws_rec = DF_INSN_UID_MWS (uid); *mws_rec; mws_rec++)\n \t{\n \t  struct df_mw_hardreg *mws = *mws_rec;\n@@ -225,19 +219,17 @@ regstat_bb_compute_ri (unsigned int bb_index,\n \t      bool all_dead = true;\n \t      unsigned int r;\n \n-\t      for (r=mws->start_regno; r <= mws->end_regno; r++)\n-\t\tif ((bitmap_bit_p (live, r))\n-\t\t    || bitmap_bit_p (artificial_uses, r))\n+\t      for (r = mws->start_regno; r <= mws->end_regno; r++)\n+\t\tif (bitmap_bit_p (artificial_uses, r)\n+\t\t    || bitmap_bit_p (live, r))\n \t\t  {\n \t\t    all_dead = false;\n \t\t    break;\n \t\t  }\n \n \t      if (all_dead)\n \t\t{\n-\t\t  unsigned int regno = mws->start_regno;\n-\t\t  bitmap_set_bit (do_not_gen, regno);\n-\t\t  /* Only do this if the value is totally dead.  */\n+\t\t  regno = mws->start_regno;\n \t\t  REG_LIVE_LENGTH (regno)++;\n \t\t}\n \t    }\n@@ -255,20 +247,41 @@ regstat_bb_compute_ri (unsigned int bb_index,\n \n \t      if (bitmap_bit_p (live, dregno))\n \t\t{\n-\t\t  /* If we have seen this regno, then it has already been\n-\t\t     processed correctly with the per insn increment.  If we\n-\t\t     have not seen it we need to add the length from here to\n-\t\t     the end of the block to the live length.  */\n-\t\t  if (bitmap_bit_p (local_processed, dregno))\n+\t\t  /* If we have seen a use of DREGNO somewhere before (i.e.\n+\t\t     later in this basic block), and DEF is not a subreg\n+\t\t     store or conditional store, then kill the register\n+\t\t     here and add the proper length to its REG_LIVE_LENGTH.\n+\n+\t\t     If we have not seen a use of DREGNO later in this basic\n+\t\t     block, then we need to add the length from here to the\n+\t\t     end of the block to the live length.  */\n+\t\t  if (bitmap_bit_p (local_live, dregno))\n \t\t    {\n+\t\t      /* Note that LOCAL_LIVE implies LOCAL_PROCESSED, so\n+\t\t\t we don't have to set LOCAL_PROCESSED in this clause.  */\n \t\t      if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t\t\tbitmap_clear_bit (local_live, dregno);\n+\t\t\t{\n+\t\t\t  REG_LIVE_LENGTH (dregno) +=\n+\t\t\t    (luid - local_live_last_luid[dregno]);\n+\t\t\t  local_live_last_luid[dregno] = luid;\n+\t\t\t  bitmap_clear_bit (local_live, dregno);\n+\t\t\t}\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      bitmap_set_bit (local_processed, dregno);\n \t\t      REG_LIVE_LENGTH (dregno) += luid;\n+\t\t      local_live_last_luid[dregno] = luid;\n \t\t    }\n+\n+\t\t  /* Kill this register if it is not a subreg store or\n+\t\t     conditional store.\n+\t\t     ??? This means that any partial store is live from\n+\t\t     the last use in a basic block to the start of this\n+\t\t     basic block.  This results in poor calculations of\n+\t\t     REG_LIVE_LENGTH in large basic blocks.  */\n+\t\t  if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n+\t\t    bitmap_clear_bit (live, dregno);\n \t\t}\n \t      else if ((!(DF_REF_FLAGS (def) & DF_REF_MW_HARDREG))\n \t\t       && (!bitmap_bit_p (artificial_uses, dregno)))\n@@ -279,18 +292,14 @@ regstat_bb_compute_ri (unsigned int bb_index,\n \t      if (dregno >= FIRST_PSEUDO_REGISTER)\n \t\t{\n \t\t  REG_FREQ (dregno) += REG_FREQ_FROM_BB (bb);\n+\t\t  REG_FREQ (dregno) =\n+\t\t    MIN (REG_FREQ (dregno), REG_FREQ_MAX);\n+\n \t\t  if (REG_BASIC_BLOCK (dregno) == REG_BLOCK_UNKNOWN)\n \t\t    REG_BASIC_BLOCK (dregno) = bb->index;\n \t\t  else if (REG_BASIC_BLOCK (dregno) != bb->index)\n \t\t    REG_BASIC_BLOCK (dregno) = REG_BLOCK_GLOBAL;\n \t\t}\n-\n-\t      if (!(DF_REF_FLAGS (def) & (DF_REF_MUST_CLOBBER + DF_REF_MAY_CLOBBER)))\n-\t\tbitmap_set_bit (do_not_gen, dregno);\n-\n-\t      /* Kill this register if it is not a subreg store or conditional store.  */\n-\t      if (!(DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL)))\n-\t\tbitmap_clear_bit (live, dregno);\n \t    }\n \t}\n \n@@ -302,6 +311,9 @@ regstat_bb_compute_ri (unsigned int bb_index,\n \t  if (uregno >= FIRST_PSEUDO_REGISTER)\n \t    {\n \t      REG_FREQ (uregno) += REG_FREQ_FROM_BB (bb);\n+\t      REG_FREQ (uregno) =\n+\t\tMIN (REG_FREQ (uregno), REG_FREQ_MAX);\n+\n \t      if (REG_BASIC_BLOCK (uregno) == REG_BLOCK_UNKNOWN)\n \t\tREG_BASIC_BLOCK (uregno) = bb->index;\n \t      else if (REG_BASIC_BLOCK (uregno) != bb->index)\n@@ -310,22 +322,26 @@ regstat_bb_compute_ri (unsigned int bb_index,\n \n \t  if (bitmap_set_bit (live, uregno))\n \t    {\n-\t      /* This register is now live.  */\n-\n-\t      /* If we have seen this regno, then it has already been\n-\t\t processed correctly with the per insn increment.  If\n-\t\t we have not seen it we set the bit so that begins to\n-\t\t get processed locally.  Note that we don't even get\n-\t\t here if the variable was live at the end of the block\n-\t\t since just a ref inside the block does not effect the\n-\t\t calculations.  */\n+\t      /* This register is now live.  Begin to process it locally.\n+\n+\t\t Note that we don't even get here if the variable was live\n+\t\t at the end of the block since just a ref inside the block\n+\t\t does not effect the calculations.  */\n \t      REG_LIVE_LENGTH (uregno) ++;\n+\t      local_live_last_luid[uregno] = luid;\n \t      bitmap_set_bit (local_live, uregno);\n \t      bitmap_set_bit (local_processed, uregno);\n \t    }\n \t}\n     }\n \n+  /* Add the liveness length to all registers that were used somewhere\n+     in this bock, but not between that use and the head of this block.  */\n+  EXECUTE_IF_SET_IN_BITMAP (local_live, 0, regno, bi)\n+    {\n+      REG_LIVE_LENGTH (regno) += (luid - local_live_last_luid[regno]);\n+    }\n+\n   /* Add the length of the block to all of the registers that were not\n      referenced, but still live in this block.  */\n   bitmap_and_compl_into (live, local_processed);\n@@ -343,12 +359,12 @@ regstat_compute_ri (void)\n {\n   basic_block bb;\n   bitmap live = BITMAP_ALLOC (&df_bitmap_obstack);\n-  bitmap do_not_gen = BITMAP_ALLOC (&df_bitmap_obstack);\n   bitmap artificial_uses = BITMAP_ALLOC (&df_bitmap_obstack);\n   bitmap local_live = BITMAP_ALLOC (&df_bitmap_obstack);\n   bitmap local_processed = BITMAP_ALLOC (&df_bitmap_obstack);\n   unsigned int regno;\n   bitmap_iterator bi;\n+  int *local_live_last_luid;\n \n   /* Initialize everything.  */\n \n@@ -359,16 +375,20 @@ regstat_compute_ri (void)\n   max_regno = max_reg_num ();\n   reg_info_p_size = max_regno;\n   reg_info_p = XCNEWVEC (struct reg_info_t, max_regno);\n+  local_live_last_luid = XNEWVEC (int, max_regno);\n \n   FOR_EACH_BB (bb)\n     {\n-      regstat_bb_compute_ri (bb->index, live, do_not_gen, artificial_uses,\n-\t\t\t     local_live, local_processed);\n+      regstat_bb_compute_ri (bb->index, live, artificial_uses,\n+\t\t\t     local_live, local_processed,\n+\t\t\t     local_live_last_luid);\n     }\n \n   BITMAP_FREE (live);\n-  BITMAP_FREE (do_not_gen);\n   BITMAP_FREE (artificial_uses);\n+  BITMAP_FREE (local_live);\n+  BITMAP_FREE (local_processed);\n+  free (local_live_last_luid);\n \n   /* See the setjmp comment in regstat_ri_bb_compute.  */\n   EXECUTE_IF_SET_IN_BITMAP (setjmp_crosses, FIRST_PSEUDO_REGISTER, regno, bi)\n@@ -377,8 +397,6 @@ regstat_compute_ri (void)\n       REG_LIVE_LENGTH (regno) = -1;\n     }\n \n-  BITMAP_FREE (local_live);\n-  BITMAP_FREE (local_processed);\n   timevar_pop (TV_REG_STATS);\n }\n \n@@ -463,6 +481,8 @@ regstat_bb_compute_calls_crossed (unsigned int bb_index, bitmap live)\n \t    {\n \t      REG_N_CALLS_CROSSED (regno)++;\n \t      REG_FREQ_CALLS_CROSSED (regno) += REG_FREQ_FROM_BB (bb);\n+\t      REG_FREQ_CALLS_CROSSED (regno) =\n+\t\tMIN (REG_FREQ_CALLS_CROSSED (regno), REG_FREQ_MAX);\n \t    }\n \t}\n "}]}