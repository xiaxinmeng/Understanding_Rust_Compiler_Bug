{"sha": "86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZmYzdhNmM1ZDJmYzdmOWE1ZGFhNWU0OGY5NGNiZmI4N2NhNmRiMQ==", "commit": {"author": {"name": "Craig Burley", "email": "burley@gnu.org", "date": "1998-02-22T19:31:54Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-02-22T19:31:54Z"}, "message": "Improve run-time diagnostic for \"PRINT '(I1', 42\":\n\n        * com.c (ffecom_char_args_x_): Renamed from ffecom_char_args_,\n        which is now a macro (to avoid lots of changes to other code)\n        with new arg, ffecom_char_args_with_null_ being another new\n        macro to call same function with different value for new arg.\n        This function now appends a null byte to opCONTER expression\n        if the new arg is TRUE.\n        (ffecom_arg_ptr_to_expr): Support NULL length pointer.\n        * ste.c (ffeste_io_cilist_):\n        (ffeste_io_icilist_): Pass NULL length ptr for\n        FORMAT expression, so null byte gets appended where\n        feasible.\n        * target.c (ffetarget_character1):\n        (ffetarget_concatenate_character1):\n        (ffetarget_substr_character1):\n        (ffetarget_convert_character1_character1):\n        (ffetarget_convert_character1_hollerith):\n        (ffetarget_convert_character1_integer4):\n        (ffetarget_convert_character1_logical4):\n        (ffetarget_convert_character1_typeless):\n        (ffetarget_hollerith): Append extra phantom null byte as\n        part of FFETARGET-NULL-BYTE kludge.\nYes, even more patches from Craig :-)\n\nFrom-SVN: r18187", "tree": {"sha": "eac853048bea7ba61606cdf284b85763ea4e7828", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eac853048bea7ba61606cdf284b85763ea4e7828"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1/comments", "author": null, "committer": null, "parents": [{"sha": "99ce4a11118e146e3a09cf06899c4d2935e4d5bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99ce4a11118e146e3a09cf06899c4d2935e4d5bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99ce4a11118e146e3a09cf06899c4d2935e4d5bc"}], "stats": {"total": 244, "additions": 197, "deletions": 47}, "files": [{"sha": "864cf40adb7731b5bab07e212e9fb375bd24f28a", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1", "patch": "@@ -29,6 +29,29 @@ Fri Jan  9 19:09:07 1998  Craig Burley  <burley@gnu.org>\n \n Tue Dec 23 14:58:04 1997  Craig Burley  <burley@gnu.org>\n \n+\tImprove run-time diagnostic for \"PRINT '(I1', 42\":\n+\t* com.c (ffecom_char_args_x_): Renamed from ffecom_char_args_,\n+\twhich is now a macro (to avoid lots of changes to other code)\n+\twith new arg, ffecom_char_args_with_null_ being another new\n+\tmacro to call same function with different value for new arg.\n+\tThis function now appends a null byte to opCONTER expression\n+\tif the new arg is TRUE.\n+\t(ffecom_arg_ptr_to_expr): Support NULL length pointer.\n+\t* ste.c (ffeste_io_cilist_):\n+\t(ffeste_io_icilist_): Pass NULL length ptr for\n+\tFORMAT expression, so null byte gets appended where\n+\tfeasible.\n+\t* target.c (ffetarget_character1):\n+\t(ffetarget_concatenate_character1):\n+\t(ffetarget_substr_character1):\n+\t(ffetarget_convert_character1_character1):\n+\t(ffetarget_convert_character1_hollerith):\n+\t(ffetarget_convert_character1_integer4):\n+\t(ffetarget_convert_character1_logical4):\n+\t(ffetarget_convert_character1_typeless):\n+\t(ffetarget_hollerith): Append extra phantom null byte as\n+\tpart of FFETARGET-NULL-BYTE kludge.\n+\n \t* intrin.c (ffeintrin_fulfill_generic): Don't generate\n \tFFEBAD_INTRINSIC_TYPE for CHARACTER*(*) intrinsic.\n "}, {"sha": "06a7bf93f1a1d156aa521252ead4005794c0ab77", "filename": "gcc/f/com.c", "status": "modified", "additions": 70, "deletions": 26, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1", "patch": "@@ -420,8 +420,8 @@ static tree ffecom_call_binop_ (tree fn, ffeinfoKindtype kt,\n \t\t\t\ttree dest_tree, ffebld dest,\n \t\t\t\tbool *dest_used, tree callee_commons,\n \t\t\t\tbool scalar_args);\n-static void ffecom_char_args_ (tree *xitem, tree *length,\n-\t\t\t       ffebld expr);\n+static void ffecom_char_args_x_ (tree *xitem, tree *length,\n+\t\t\t\t ffebld expr, bool with_null);\n static tree ffecom_check_size_overflow_ (ffesymbol s, tree type, bool dummy);\n static tree ffecom_char_enhance_arg_ (tree *xtype, ffesymbol s);\n static ffecomConcatList_\n@@ -653,6 +653,9 @@ static char *ffecom_gfrt_argstring_[FFECOM_gfrt]\n #define ffecom_start_compstmt_ bison_rule_pushlevel_\n #define ffecom_end_compstmt_ bison_rule_compstmt_\n \n+#define ffecom_char_args_(i,l,e) ffecom_char_args_x_((i),(l),(e),FALSE)\n+#define ffecom_char_args_with_null_(i,l,e) ffecom_char_args_x_((i),(l),(e),TRUE)\n+\n /* For each binding contour we allocate a binding_level structure\n  * which records the names defined in that contour.\n  * Contours include:\n@@ -1646,36 +1649,46 @@ ffecom_call_binop_ (tree fn, ffeinfoKindtype kt, bool is_f2c_complex,\n }\n #endif\n \n-/* ffecom_char_args_ -- Return ptr/length args for char subexpression\n+/* ffecom_char_args_x_ -- Return ptr/length args for char subexpression\n \n    tree ptr_arg;\n    tree length_arg;\n    ffebld expr;\n-   ffecom_char_args_(&ptr_arg,&length_arg,expr);\n+   bool with_null;\n+   ffecom_char_args_x_(&ptr_arg,&length_arg,expr,with_null);\n \n    Handles CHARACTER-type CONTER, SYMTER, SUBSTR, ARRAYREF, and FUNCREF\n    subexpressions by constructing the appropriate trees for the ptr-to-\n    character-text and length-of-character-text arguments in a calling\n-   sequence.  */\n+   sequence.\n+\n+   Note that if with_null is TRUE, and the expression is an opCONTER,\n+   a null byte is appended to the string.  */\n \n #if FFECOM_targetCURRENT == FFECOM_targetGCC\n static void\n-ffecom_char_args_ (tree *xitem, tree *length, ffebld expr)\n+ffecom_char_args_x_ (tree *xitem, tree *length, ffebld expr, bool with_null)\n {\n   tree item;\n   tree high;\n   ffetargetCharacter1 val;\n+  ffetargetCharacterSize newlen;\n \n   switch (ffebld_op (expr))\n     {\n     case FFEBLD_opCONTER:\n       val = ffebld_constant_character1 (ffebld_conter (expr));\n-      *length = build_int_2 (ffetarget_length_character1 (val), 0);\n+      newlen = ffetarget_length_character1 (val);\n+      if (with_null)\n+\t{\n+\t  if (newlen != 0)\n+\t    ++newlen;\t/* begin FFETARGET-NULL-KLUDGE. */\n+\t}\n+      *length = build_int_2 (newlen, 0);\n       TREE_TYPE (*length) = ffecom_f2c_ftnlen_type_node;\n-      high = build_int_2 (ffetarget_length_character1 (val),\n-\t\t\t  0);\n+      high = build_int_2 (newlen, 0);\n       TREE_TYPE (high) = ffecom_f2c_ftnlen_type_node;\n-      item = build_string (ffetarget_length_character1 (val),\n+      item = build_string (newlen,\t/* end FFETARGET-NULL-KLUDGE. */\n \t\t\t   ffetarget_text_character1 (val));\n       TREE_TYPE (item)\n \t= build_type_variant\n@@ -10818,7 +10831,19 @@ ffecom_arg_expr (ffebld expr, tree *length)\n    returns and sets the length return value to NULL_TREE.  Otherwise\n    generates code to evaluate the character expression, returns the proper\n    pointer to the result, AND sets the length return value to a tree that\n-   specifies the length of the result.\t*/\n+   specifies the length of the result.\n+\n+   If the length argument is NULL, this is a slightly special\n+   case of building a FORMAT expression, that is, an expression that\n+   will be used at run time without regard to length.  For the current\n+   implementation, which uses the libf2c library, this means it is nice\n+   to append a null byte to the end of the expression, where feasible,\n+   to make sure any diagnostic about the FORMAT string terminates at\n+   some useful point.\n+\n+   For now, treat %REF(char-expr) as the same as char-expr with a NULL\n+   length argument.  This might even be seen as a feature, if a null\n+   byte can always be appended.  */\n \n #if FFECOM_targetCURRENT == FFECOM_targetGCC\n tree\n@@ -10828,7 +10853,8 @@ ffecom_arg_ptr_to_expr (ffebld expr, tree *length)\n   tree ign_length;\n   ffecomConcatList_ catlist;\n \n-  *length = NULL_TREE;\n+  if (length != NULL)\n+    *length = NULL_TREE;\n \n   if (expr == NULL)\n     return integer_zero_node;\n@@ -10850,8 +10876,11 @@ ffecom_arg_ptr_to_expr (ffebld expr, tree *length)\n     case FFEBLD_opPERCENT_REF:\n       if (ffeinfo_basictype (ffebld_info (expr)) != FFEINFO_basictypeCHARACTER)\n \treturn ffecom_ptr_to_expr (ffebld_left (expr));\n-      ign_length = NULL_TREE;\n-      length = &ign_length;\n+      if (length != NULL)\n+\t{\n+\t  ign_length = NULL_TREE;\n+\t  length = &ign_length;\n+\t}\n       expr = ffebld_left (expr);\n       break;\n \n@@ -10877,7 +10906,8 @@ ffecom_arg_ptr_to_expr (ffebld expr, tree *length)\n     }\n \n #ifdef PASS_HOLLERITH_BY_DESCRIPTOR\n-  if (ffeinfo_basictype (ffebld_info (expr)) == FFEINFO_basictypeHOLLERITH)\n+  if ((ffeinfo_basictype (ffebld_info (expr)) == FFEINFO_basictypeHOLLERITH)\n+      && (length != NULL))\n     {\t\t\t\t/* Pass Hollerith by descriptor. */\n       ffetargetHollerith h;\n \n@@ -10900,14 +10930,21 @@ ffecom_arg_ptr_to_expr (ffebld expr, tree *length)\n   switch (ffecom_concat_list_count_ (catlist))\n     {\n     case 0:\t\t\t/* Shouldn't happen, but in case it does... */\n-      *length = ffecom_f2c_ftnlen_zero_node;\n-      TREE_TYPE (*length) = ffecom_f2c_ftnlen_type_node;\n+      if (length != NULL)\n+\t{\n+\t  *length = ffecom_f2c_ftnlen_zero_node;\n+\t  TREE_TYPE (*length) = ffecom_f2c_ftnlen_type_node;\n+\t}\n       ffecom_concat_list_kill_ (catlist);\n       return null_pointer_node;\n \n     case 1:\t\t\t/* The (fairly) easy case. */\n-      ffecom_char_args_ (&item, length,\n-\t\t\t ffecom_concat_list_expr_ (catlist, 0));\n+      if (length == NULL)\n+\tffecom_char_args_with_null_ (&item, &ign_length,\n+\t\t\t\t     ffecom_concat_list_expr_ (catlist, 0));\n+      else\n+\tffecom_char_args_ (&item, length,\n+\t\t\t   ffecom_concat_list_expr_ (catlist, 0));\n       ffecom_concat_list_kill_ (catlist);\n       assert (item != NULL_TREE);\n       return item;\n@@ -10943,8 +10980,13 @@ ffecom_arg_ptr_to_expr (ffebld expr, tree *length)\n \n     for (i = 0; i < count; ++i)\n       {\n-\tffecom_char_args_ (&citem, &clength,\n-\t\t\t   ffecom_concat_list_expr_ (catlist, i));\n+\tif ((i == count)\n+\t    && (length == NULL))\n+\t  ffecom_char_args_with_null_ (&citem, &clength,\n+\t\t\t\t       ffecom_concat_list_expr_ (catlist, i));\n+\telse\n+\t  ffecom_char_args_ (&citem, &clength,\n+\t\t\t     ffecom_concat_list_expr_ (catlist, i));\n \tif ((citem == error_mark_node)\n \t    || (clength == error_mark_node))\n \t  {\n@@ -10963,10 +11005,11 @@ ffecom_arg_ptr_to_expr (ffebld expr, tree *length)\n \t\t\t\t     citem),\n \t\t      items);\n \tclength = ffecom_save_tree (clength);\n-\tknown_length\n-\t  = ffecom_2 (PLUS_EXPR, ffecom_f2c_ftnlen_type_node,\n-\t\t      known_length,\n-\t\t      clength);\n+\tif (length != NULL)\n+\t  known_length\n+\t    = ffecom_2 (PLUS_EXPR, ffecom_f2c_ftnlen_type_node,\n+\t\t\tknown_length,\n+\t\t\tclength);\n \tlengths\n \t  = ffecom_2 (COMPOUND_EXPR, TREE_TYPE (lengths),\n \t\t      ffecom_modify (void_type_node,\n@@ -11015,7 +11058,8 @@ ffecom_arg_ptr_to_expr (ffebld expr, tree *length)\n \t\t     item,\n \t\t     temporary);\n \n-    *length = known_length;\n+    if (length != NULL)\n+      *length = known_length;\n   }\n \n   ffecom_concat_list_kill_ (catlist);"}, {"sha": "3b9ece36f54706663fc100c6537828358a4e0f5b", "filename": "gcc/f/news.texi", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1/gcc%2Ff%2Fnews.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1/gcc%2Ff%2Fnews.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fnews.texi?ref=86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1", "patch": "@@ -27,6 +27,26 @@ involve a combination of these elements.\n @heading In 0.5.22:\n @itemize @bullet\n @item\n+@item\n+Improve diagnostic messages from @code{libf2c}\n+so it is more likely that the printing of the\n+active format string is limited to the string,\n+with no trailing garbage being printed.\n+\n+(Unlike @code{f2c}, @code{g77} does not append\n+a null byte to its compiled form of every\n+format string specified via a @code{FORMAT} statement.\n+However, @code{f2c} would exhibit the problem\n+anyway for a statement like @samp{PRINT '(I)garbage', 1}\n+by printing @samp{(I)garbage} as the format string.)\n+\n+@item\n+Improve compilation of FORMAT expressions so that\n+a null byte is appended to the last operand if it\n+is a constant.\n+This provides a cleaner run-time diagnostic as provided\n+by @code{libf2c} for statements like @samp{PRINT '(I1', 42}.\n+\n Fix @code{SIGNAL} intrinsic so it offers portable\n support for 64-bit systems (such as Digital Alphas\n running GNU/Linux)."}, {"sha": "f7168f0dfdddf69352ad84ca4d56e07b872228b7", "filename": "gcc/f/ste.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1/gcc%2Ff%2Fste.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1/gcc%2Ff%2Fste.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fste.c?ref=86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1", "patch": "@@ -999,7 +999,6 @@ ffeste_io_cilist_ (bool have_err,\n   int yes;\n   tree field;\n   tree inits, initn;\n-  tree ignore;\t\t\t/* We ignore the length of format! */\n   bool constantp = TRUE;\n   static tree errfield, unitfield, endfield, formatfield, recfield;\n   tree errinit, unitinit, endinit, formatinit, recinit;\n@@ -1086,7 +1085,7 @@ ffeste_io_cilist_ (bool have_err,\n       break;\n \n     case FFESTV_formatCHAREXPR:\n-      formatexp = ffecom_arg_ptr_to_expr (format_spec->u.expr, &ignore);\n+      formatexp = ffecom_arg_ptr_to_expr (format_spec->u.expr, NULL);\n       if (TREE_CONSTANT (formatexp))\n \t{\n \t  formatinit = formatexp;\n@@ -1305,7 +1304,6 @@ ffeste_io_icilist_ (bool have_err,\n   int yes;\n   tree field;\n   tree inits, initn;\n-  tree ignore;\t\t\t/* We ignore the length of format! */\n   bool constantp = TRUE;\n   static tree errfield, unitfield, endfield, formatfield, unitlenfield,\n     unitnumfield;\n@@ -1409,7 +1407,7 @@ ffeste_io_icilist_ (bool have_err,\n       break;\n \n     case FFESTV_formatCHAREXPR:\n-      formatexp = ffecom_arg_ptr_to_expr (format_spec->u.expr, &ignore);\n+      formatexp = ffecom_arg_ptr_to_expr (format_spec->u.expr, NULL);\n       if (TREE_CONSTANT (formatexp))\n \t{\n \t  formatinit = formatexp;"}, {"sha": "8dfe68d77825a3888c1122710ba7df51855080a0", "filename": "gcc/f/target.c", "status": "modified", "additions": 82, "deletions": 17, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1/gcc%2Ff%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1/gcc%2Ff%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ftarget.c?ref=86fc7a6c5d2fc7f9a5daa5e48f94cbfb87ca6db1", "patch": "@@ -280,6 +280,13 @@ ffetarget_align (ffetargetAlign *updated_alignment,\n   return min_pad;\n }\n \n+/* Always append a null byte to the end, in case this is wanted in\n+   a special case such as passing a string as a FORMAT or %REF.\n+   Done to save a bit of hassle, nothing more, but it's a kludge anyway,\n+   because it isn't a \"feature\" that is self-documenting.  Use the\n+   string \"FFETARGET-NULL-KLUDGE\" to flag anyplace you use this feature\n+   in the code.  */\n+\n #if FFETARGET_okCHARACTER1\n bool\n ffetarget_character1 (ffetargetCharacter1 *val, ffelexToken character,\n@@ -290,8 +297,9 @@ ffetarget_character1 (ffetargetCharacter1 *val, ffelexToken character,\n     val->text = NULL;\n   else\n     {\n-      val->text = malloc_new_kp (pool, \"ffetargetCharacter1\", val->length);\n+      val->text = malloc_new_kp (pool, \"ffetargetCharacter1\", val->length + 1);\n       memcpy (val->text, ffelex_token_text (character), val->length);\n+      val->text[val->length] = '\\0';\n     }\n \n   return TRUE;\n@@ -318,7 +326,12 @@ ffetarget_cmp_character1 (ffetargetCharacter1 l, ffetargetCharacter1 r)\n #endif\n /* ffetarget_concatenate_character1 -- Perform CONCAT op on two constants\n \n-   Compare lengths, if equal then use memcmp.  */\n+   Always append a null byte to the end, in case this is wanted in\n+   a special case such as passing a string as a FORMAT or %REF.\n+   Done to save a bit of hassle, nothing more, but it's a kludge anyway,\n+   because it isn't a \"feature\" that is self-documenting.  Use the\n+   string \"FFETARGET-NULL-KLUDGE\" to flag anyplace you use this feature\n+   in the code.  */\n \n #if FFETARGET_okCHARACTER1\n ffebad\n@@ -331,11 +344,12 @@ ffetarget_concatenate_character1 (ffetargetCharacter1 *res,\n     res->text = NULL;\n   else\n     {\n-      res->text = malloc_new_kp (pool, \"ffetargetCharacter1(CONCAT)\", *len);\n+      res->text = malloc_new_kp (pool, \"ffetargetCharacter1(CONCAT)\", *len + 1);\n       if (l.length != 0)\n \tmemcpy (res->text, l.text, l.length);\n       if (r.length != 0)\n \tmemcpy (res->text + l.length, r.text, r.length);\n+      res->text[*len] = '\\0';\n     }\n \n   return FFEBAD;\n@@ -501,7 +515,12 @@ ffetarget_ne_character1 (bool *res, ffetargetCharacter1 l,\n #endif\n /* ffetarget_substr_character1 -- Perform SUBSTR op on three constants\n \n-   Compare lengths, if equal then use memcmp.  */\n+   Always append a null byte to the end, in case this is wanted in\n+   a special case such as passing a string as a FORMAT or %REF.\n+   Done to save a bit of hassle, nothing more, but it's a kludge anyway,\n+   because it isn't a \"feature\" that is self-documenting.  Use the\n+   string \"FFETARGET-NULL-KLUDGE\" to flag anyplace you use this feature\n+   in the code.  */\n \n #if FFETARGET_okCHARACTER1\n ffebad\n@@ -519,8 +538,9 @@ ffetarget_substr_character1 (ffetargetCharacter1 *res,\n   else\n     {\n       res->length = *len = last - first + 1;\n-      res->text = malloc_new_kp (pool, \"ffetargetCharacter1(SUBSTR)\", *len);\n+      res->text = malloc_new_kp (pool, \"ffetargetCharacter1(SUBSTR)\", *len + 1);\n       memcpy (res->text, l.text + first - 1, *len);\n+      res->text[*len] = '\\0';\n     }\n \n   return FFEBAD;\n@@ -666,6 +686,13 @@ ffetarget_convert_any_typeless_ (char *res, size_t size,\n   return FFEBAD;\n }\n \n+/* Always append a null byte to the end, in case this is wanted in\n+   a special case such as passing a string as a FORMAT or %REF.\n+   Done to save a bit of hassle, nothing more, but it's a kludge anyway,\n+   because it isn't a \"feature\" that is self-documenting.  Use the\n+   string \"FFETARGET-NULL-KLUDGE\" to flag anyplace you use this feature\n+   in the code.  */\n+\n #if FFETARGET_okCHARACTER1\n ffebad\n ffetarget_convert_character1_character1 (ffetargetCharacter1 *res,\n@@ -678,20 +705,29 @@ ffetarget_convert_character1_character1 (ffetargetCharacter1 *res,\n     res->text = NULL;\n   else\n     {\n-      res->text = malloc_new_kp (pool, \"FFETARGET cvt char1\", size);\n+      res->text = malloc_new_kp (pool, \"FFETARGET cvt char1\", size + 1);\n       if (size <= l.length)\n \tmemcpy (res->text, l.text, size);\n       else\n \t{\n \t  memcpy (res->text, l.text, l.length);\n \t  memset (res->text + l.length, ' ', size - l.length);\n \t}\n+      res->text[size] = '\\0';\n     }\n \n   return FFEBAD;\n }\n \n #endif\n+\n+/* Always append a null byte to the end, in case this is wanted in\n+   a special case such as passing a string as a FORMAT or %REF.\n+   Done to save a bit of hassle, nothing more, but it's a kludge anyway,\n+   because it isn't a \"feature\" that is self-documenting.  Use the\n+   string \"FFETARGET-NULL-KLUDGE\" to flag anyplace you use this feature\n+   in the code.  */\n+\n #if FFETARGET_okCHARACTER1\n ffebad\n ffetarget_convert_character1_hollerith (ffetargetCharacter1 *res,\n@@ -703,7 +739,8 @@ ffetarget_convert_character1_hollerith (ffetargetCharacter1 *res,\n     res->text = NULL;\n   else\n     {\n-      res->text = malloc_new_kp (pool, \"FFETARGET cvt char1\", size);\n+      res->text = malloc_new_kp (pool, \"FFETARGET cvt char1\", size + 1);\n+      res->text[size] = '\\0';\n       if (size <= l.length)\n \t{\n \t  char *p;\n@@ -727,7 +764,14 @@ ffetarget_convert_character1_hollerith (ffetargetCharacter1 *res,\n }\n \n #endif\n-/* ffetarget_convert_character1_integer1 -- Raw conversion.  */\n+/* ffetarget_convert_character1_integer4 -- Raw conversion.\n+\n+   Always append a null byte to the end, in case this is wanted in\n+   a special case such as passing a string as a FORMAT or %REF.\n+   Done to save a bit of hassle, nothing more, but it's a kludge anyway,\n+   because it isn't a \"feature\" that is self-documenting.  Use the\n+   string \"FFETARGET-NULL-KLUDGE\" to flag anyplace you use this feature\n+   in the code.  */\n \n #if FFETARGET_okCHARACTER1\n ffebad\n@@ -788,7 +832,8 @@ ffetarget_convert_character1_integer4 (ffetargetCharacter1 *res,\n     res->text = NULL;\n   else\n     {\n-      res->text = malloc_new_kp (pool, \"FFETARGET cvt char1\", size);\n+      res->text = malloc_new_kp (pool, \"FFETARGET cvt char1\", size + 1);\n+      res->text[size] = '\\0';\n       if (((size_t) size) <= size_of)\n \t{\n \t  int i = size_of - size;\n@@ -813,7 +858,14 @@ ffetarget_convert_character1_integer4 (ffetargetCharacter1 *res,\n }\n \n #endif\n-/* ffetarget_convert_character1_logical1 -- Raw conversion.  */\n+/* ffetarget_convert_character1_logical4 -- Raw conversion.\n+\n+   Always append a null byte to the end, in case this is wanted in\n+   a special case such as passing a string as a FORMAT or %REF.\n+   Done to save a bit of hassle, nothing more, but it's a kludge anyway,\n+   because it isn't a \"feature\" that is self-documenting.  Use the\n+   string \"FFETARGET-NULL-KLUDGE\" to flag anyplace you use this feature\n+   in the code.  */\n \n #if FFETARGET_okCHARACTER1\n ffebad\n@@ -874,7 +926,8 @@ ffetarget_convert_character1_logical4 (ffetargetCharacter1 *res,\n     res->text = NULL;\n   else\n     {\n-      res->text = malloc_new_kp (pool, \"FFETARGET cvt char1\", size);\n+      res->text = malloc_new_kp (pool, \"FFETARGET cvt char1\", size + 1);\n+      res->text[size] = '\\0';\n       if (((size_t) size) <= size_of)\n \t{\n \t  int i = size_of - size;\n@@ -899,7 +952,14 @@ ffetarget_convert_character1_logical4 (ffetargetCharacter1 *res,\n }\n \n #endif\n-/* ffetarget_convert_character1_typeless -- Raw conversion.  */\n+/* ffetarget_convert_character1_typeless -- Raw conversion.\n+\n+   Always append a null byte to the end, in case this is wanted in\n+   a special case such as passing a string as a FORMAT or %REF.\n+   Done to save a bit of hassle, nothing more, but it's a kludge anyway,\n+   because it isn't a \"feature\" that is self-documenting.  Use the\n+   string \"FFETARGET-NULL-KLUDGE\" to flag anyplace you use this feature\n+   in the code.  */\n \n #if FFETARGET_okCHARACTER1\n ffebad\n@@ -960,7 +1020,8 @@ ffetarget_convert_character1_typeless (ffetargetCharacter1 *res,\n     res->text = NULL;\n   else\n     {\n-      res->text = malloc_new_kp (pool, \"FFETARGET cvt char1\", size);\n+      res->text = malloc_new_kp (pool, \"FFETARGET cvt char1\", size + 1);\n+      res->text[size] = '\\0';\n       if (((size_t) size) <= size_of)\n \t{\n \t  int i = size_of - size;\n@@ -1101,17 +1162,21 @@ ffetarget_divide_complex2 (ffetargetComplex2 *res, ffetargetComplex2 l,\n #endif\n /* ffetarget_hollerith -- Convert token to a hollerith constant\n \n-   See prototype.\n-\n-   Token use count not affected overall.  */\n+   Always append a null byte to the end, in case this is wanted in\n+   a special case such as passing a string as a FORMAT or %REF.\n+   Done to save a bit of hassle, nothing more, but it's a kludge anyway,\n+   because it isn't a \"feature\" that is self-documenting.  Use the\n+   string \"FFETARGET-NULL-KLUDGE\" to flag anyplace you use this feature\n+   in the code.  */\n \n bool\n ffetarget_hollerith (ffetargetHollerith *val, ffelexToken integer,\n \t\t     mallocPool pool)\n {\n   val->length = ffelex_token_length (integer);\n-  val->text = malloc_new_kp (pool, \"ffetargetHollerith\", val->length);\n+  val->text = malloc_new_kp (pool, \"ffetargetHollerith\", val->length + 1);\n   memcpy (val->text, ffelex_token_text (integer), val->length);\n+  val->text[val->length] = '\\0';\n \n   return TRUE;\n }"}]}