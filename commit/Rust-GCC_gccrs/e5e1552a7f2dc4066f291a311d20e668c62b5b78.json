{"sha": "e5e1552a7f2dc4066f291a311d20e668c62b5b78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVlMTU1MmE3ZjJkYzQwNjZmMjkxYTMxMWQyMGU2NjhjNjJiNWI3OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-11-05T15:49:36Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-11-05T15:49:36Z"}, "message": "(movdi matchers): Rewrite.\n\n(store_unaligned_di_reg): New pattern.\n(movti matchers): Rewrite.\n(store_unaligned_ti_reg): New pattern.\n\nFrom-SVN: r10553", "tree": {"sha": "160d1dbfd48918aea995a920a90e6697369456b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/160d1dbfd48918aea995a920a90e6697369456b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5e1552a7f2dc4066f291a311d20e668c62b5b78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5e1552a7f2dc4066f291a311d20e668c62b5b78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5e1552a7f2dc4066f291a311d20e668c62b5b78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5e1552a7f2dc4066f291a311d20e668c62b5b78/comments", "author": null, "committer": null, "parents": [{"sha": "3a89bbcbfa512a8593a1fce99ddad111e05faf1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a89bbcbfa512a8593a1fce99ddad111e05faf1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a89bbcbfa512a8593a1fce99ddad111e05faf1a"}], "stats": {"total": 128, "additions": 48, "deletions": 80}, "files": [{"sha": "01e18c5ac9cd97483195169dc19bf040143dbfc2", "filename": "gcc/config/i960/i960.md", "status": "modified", "additions": 48, "deletions": 80, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e1552a7f2dc4066f291a311d20e668c62b5b78/gcc%2Fconfig%2Fi960%2Fi960.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e1552a7f2dc4066f291a311d20e668c62b5b78/gcc%2Fconfig%2Fi960%2Fi960.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.md?ref=e5e1552a7f2dc4066f291a311d20e668c62b5b78", "patch": "@@ -821,41 +821,12 @@\n   switch (which_alternative)\n     {\n     case 0:\n-      if ((REGNO (operands[0]) & 1)\n-\t  || (REGNO (operands[1]) & 1))\n-\t{\n-\t  /* We normally copy the low-numbered register first.  However, if\n-\t     the second source register is the same as the first destination\n-\t     register, we must copy in the opposite order.  */\n-\t  if (REGNO (operands[1]) + 1 == REGNO (operands[0]))\n-\t    return \\\"mov\t%D1,%D0\\;mov\t%1,%0\\\";\n-\t  else\n-\t    return \\\"mov\t%1,%0\\;mov\t%D1,%D0\\\";\n-\t}\n-      else\n-\treturn \\\"movl\t%1,%0\\\";\n     case 1:\n-      if (REGNO (operands[0]) & 1)\n-\treturn \\\"mov\t%1,%0\\;mov\t0,%D0\\\";\n-      else\n-\treturn \\\"movl\t%1,%0\\\";\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n     case 3:\n-      if (REGNO (operands[0]) & 1)\n-\t{\n-\t  /* One can optimize a few cases here, but you have to be\n-\t     careful of clobbering registers used in the address and\n-\t     edge conditions.  */\n-\t  operands[2] = gen_rtx (REG, Pmode, REGNO (operands[0]) + 1);\n-\t  operands[3] = gen_rtx (MEM, word_mode, operands[2]);\n-\t  operands[4] = adj_offsettable_operand (operands[3], UNITS_PER_WORD);\n-\t  return \\\"lda\t%1,%2\\;ld\t%3,%0\\;ld\t%4,%D0\\\";\n-\t}\n-      else\n-\treturn \\\"ldl\t%1,%0\\\";\n     case 4:\n-      return \\\"stl\t%1,%0\\\";\n+      return i960_output_move_double (operands[0], operands[1]);\n+    case 2:\n+      return i960_output_ldconst (operands[0], operands[1]);\n     case 5:\n       operands[1] = adj_offsettable_operand (operands[0], 4);\n       return \\\"st\tg14,%0\\;st\tg14,%1\\\";\n@@ -878,45 +849,29 @@\n   switch (which_alternative)\n     {\n     case 0:\n-      if ((REGNO (operands[0]) & 1)\n-\t  || (REGNO (operands[1]) & 1))\n-\t{\n-\t  /* We normally copy the low-numbered register first.  However, if\n-\t     the second source register is the same as the first destination\n-\t     register, we must copy in the opposite order.  */\n-\t  if (REGNO (operands[1]) + 1 == REGNO (operands[0]))\n-\t    return \\\"mov\t%D1,%D0\\;mov\t%1,%0\\\";\n-\t  else\n-\t    return \\\"mov\t%1,%0\\;mov\t%D1,%D0\\\";\n-\t}\n-      else\n-\treturn \\\"movl\t%1,%0\\\";\n     case 1:\n-      if (REGNO (operands[0]) & 1)\n-\treturn \\\"mov\t%1,%0\\;mov\t0,%D0\\\";\n-      else\n-\treturn \\\"movl\t%1,%0\\\";\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n     case 3:\n-      if (REGNO (operands[0]) & 1)\n-\t{\n-\t  /* One can optimize a few cases here, but you have to be\n-\t     careful of clobbering registers used in the address and\n-\t     edge conditions.  */\n-\t  operands[2] = gen_rtx (REG, Pmode, REGNO (operands[0]) + 1);\n-\t  operands[3] = gen_rtx (MEM, word_mode, operands[2]);\n-\t  operands[4] = adj_offsettable_operand (operands[3], UNITS_PER_WORD);\n-\t  return \\\"lda\t%1,%2\\;ld\t%3,%0\\;ld\t%4,%D0\\\";\n-\t}\n-      else\n-\treturn \\\"ldl\t%1,%0\\\";\n     case 4:\n-      return \\\"stl\t%1,%0\\\";\n+      return i960_output_move_double (operands[0], operands[1]);\n+    case 2:\n+      return i960_output_ldconst (operands[0], operands[1]);\n     }\n }\"\n   [(set_attr \"type\" \"move,move,load,load,store\")])\n \n+(define_insn \"*store_unaligned_di_reg\"\n+  [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n+\t(match_operand:DI 1 \"register_operand\" \"d\"))\n+   (clobber (match_scratch:SI 2 \"=&d\"))]\n+  \"\"\n+  \"*\n+{\n+  operands[3] = gen_rtx (MEM, word_mode, operands[2]);\n+  operands[4] = adj_offsettable_operand (operands[3], UNITS_PER_WORD);\n+  return \\\"lda\t%0,%2\\;st\t%1,%3\\;st\t%D1,%4\\\";\n+}\"\n+  [(set_attr \"type\" \"store\")])\n+\n (define_expand \"movti\"\n   [(set (match_operand:TI 0 \"general_operand\" \"\")\n \t(match_operand:TI 1 \"general_operand\" \"\"))]\n@@ -929,8 +884,8 @@\n \n ;; The store case can not be separate.  See comment above.\n (define_insn \"\"\n-  [(set (match_operand:TI 0 \"general_operand\" \"=d,d,d,m,o\")\n-\t(match_operand:TI 1 \"general_operand\" \"dI,i,m,d,J\"))]\n+  [(set (match_operand:TI 0 \"general_operand\" \"=d,d,d,d,m,o\")\n+\t(match_operand:TI 1 \"general_operand\" \"d,I,i,m,d,J\"))]\n   \"(current_function_args_size == 0\n     && current_function_varargs == 0\n     && current_function_stdarg == 0\n@@ -943,26 +898,25 @@\n   switch (which_alternative)\n     {\n     case 0:\n-      return \\\"movq\t%1,%0\\\";\n     case 1:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 2:\n-      return \\\"ldq\t%1,%0\\\";\n     case 3:\n-      return \\\"stq\t%1,%0\\\";\n     case 4:\n+      return i960_output_move_quad (operands[0], operands[1]);\n+    case 2:\n+      return i960_output_ldconst (operands[0], operands[1]);\n+    case 5:\n       operands[1] = adj_offsettable_operand (operands[0], 4);\n       operands[2] = adj_offsettable_operand (operands[0], 8);\n       operands[3] = adj_offsettable_operand (operands[0], 12);\n       return \\\"st\tg14,%0\\;st\tg14,%1\\;st\tg14,%2\\;st\tg14,%3\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"move,load,load,store,store\")])\n+  [(set_attr \"type\" \"move,move,load,load,store,store\")])\n \n ;; The store case can not be separate.  See comment above.\n (define_insn \"\"\n-  [(set (match_operand:TI 0 \"general_operand\" \"=d,d,d,m\")\n-\t(match_operand:TI 1 \"general_operand\" \"dI,i,m,d\"))]\n+  [(set (match_operand:TI 0 \"general_operand\" \"=d,d,d,d,m\")\n+\t(match_operand:TI 1 \"general_operand\" \"d,I,i,m,d\"))]\n   \"(current_function_args_size != 0\n     || current_function_varargs != 0\n     || current_function_stdarg != 0\n@@ -974,16 +928,30 @@\n   switch (which_alternative)\n     {\n     case 0:\n-      return \\\"movq\t%1,%0\\\";\n     case 1:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 2:\n-      return \\\"ldq\t%1,%0\\\";\n     case 3:\n-      return \\\"stq\t%1,%0\\\";\n+    case 4:\n+      return i960_output_move_quad (operands[0], operands[1]);\n+    case 2:\n+      return i960_output_ldconst (operands[0], operands[1]);\n     }\n }\"\n-  [(set_attr \"type\" \"move,load,load,store\")])\n+  [(set_attr \"type\" \"move,move,load,load,store\")])\n+\n+(define_insn \"*store_unaligned_ti_reg\"\n+  [(set (match_operand:TI 0 \"memory_operand\" \"=m\")\n+\t(match_operand:TI 1 \"register_operand\" \"d\"))\n+   (clobber (match_scratch:SI 2 \"=&d\"))]\n+  \"\"\n+  \"*\n+{\n+  operands[3] = gen_rtx (MEM, word_mode, operands[2]);\n+  operands[4] = adj_offsettable_operand (operands[3], UNITS_PER_WORD);\n+  operands[5] = adj_offsettable_operand (operands[4], UNITS_PER_WORD);\n+  operands[6] = adj_offsettable_operand (operands[5], UNITS_PER_WORD);\n+  return \\\"lda\t%0,%2\\;st\t%1,%3\\;st\t%D1,%4\\;st\t%E1,%5\\;st\t%F1,%6\\\";\n+}\"\n+  [(set_attr \"type\" \"store\")])\n \n (define_expand \"store_multiple\"\n   [(set (match_operand:SI 0 \"\" \"\")\t;;- dest"}]}