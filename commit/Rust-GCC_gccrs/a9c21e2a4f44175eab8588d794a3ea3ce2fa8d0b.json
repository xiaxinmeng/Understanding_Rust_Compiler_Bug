{"sha": "a9c21e2a4f44175eab8588d794a3ea3ce2fa8d0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTljMjFlMmE0ZjQ0MTc1ZWFiODU4OGQ3OTRhM2VhM2NlMmZhOGQwYg==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2016-12-01T15:56:58Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2016-12-01T15:56:58Z"}, "message": "avr.c: Fix coding rule glitches.\n\n\t* config/avr/avr.c: Fix coding rule glitches.\n\nFrom-SVN: r243118", "tree": {"sha": "97862dea41b811e75ac82608643a95cc22adaa6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97862dea41b811e75ac82608643a95cc22adaa6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9c21e2a4f44175eab8588d794a3ea3ce2fa8d0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9c21e2a4f44175eab8588d794a3ea3ce2fa8d0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9c21e2a4f44175eab8588d794a3ea3ce2fa8d0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9c21e2a4f44175eab8588d794a3ea3ce2fa8d0b/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d95fe8017d40a6f0df671fd3e6a5fdc5b1d5319d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d95fe8017d40a6f0df671fd3e6a5fdc5b1d5319d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d95fe8017d40a6f0df671fd3e6a5fdc5b1d5319d"}], "stats": {"total": 156, "additions": 80, "deletions": 76}, "files": [{"sha": "5b2570b04166b9dc46d8e02addc64fce16894c5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9c21e2a4f44175eab8588d794a3ea3ce2fa8d0b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9c21e2a4f44175eab8588d794a3ea3ce2fa8d0b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9c21e2a4f44175eab8588d794a3ea3ce2fa8d0b", "patch": "@@ -1,3 +1,7 @@\n+2016-12-01  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\t* config/avr/avr.c: Fix coding rule glitches.\n+\n 2016-12-01  Markus Trippelsdorf  <markus@trippelsdorf.de>\n \n \tPR tree-optimization/78598"}, {"sha": "b7fd8798c72488853426a8a9a2e1de8fae1380de", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9c21e2a4f44175eab8588d794a3ea3ce2fa8d0b/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9c21e2a4f44175eab8588d794a3ea3ce2fa8d0b/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=a9c21e2a4f44175eab8588d794a3ea3ce2fa8d0b", "patch": "@@ -388,7 +388,7 @@ avr_parallel_insn_from_insns (rtx_insn *i[6])\n    If this is the case, fill in the insns from casesi to INSNS[1..5] and\n    the SImode extension to INSNS[0].  Moreover, extract the operands of\n    pattern casesi_<mode>_sequence forged from the sequence to recog_data.  */\n-   \n+\n static bool\n avr_is_casesi_sequence (basic_block bb, rtx_insn *insn, rtx_insn *insns[6])\n {\n@@ -702,7 +702,7 @@ avr_set_core_architecture (void)\n           break;\n         }\n       else if (0 == strcmp (mcu->name, avr_mmcu)\n-               // Is this a proper architecture ? \n+               // Is this a proper architecture ?\n                && NULL == mcu->macro)\n         {\n           avr_arch = &avr_arch_types[mcu->arch_id];\n@@ -1078,7 +1078,7 @@ avr_set_current_function (tree decl)\n \n       if (!STR_PREFIX_P (name, \"__vector\"))\n         warning_at (loc, OPT_Wmisspelled_isr, \"%qs appears to be a misspelled \"\n-                           \"%s handler, missing __vector prefix\", name, isr);\n+                    \"%s handler, missing __vector prefix\", name, isr);\n     }\n \n   /* Don't print the above diagnostics more than once.  */\n@@ -1163,7 +1163,7 @@ avr_regs_to_save (HARD_REG_SET *set)\n               /* Don't record frame pointer registers here.  They are treated\n                  indivitually in prologue.  */\n               && !(frame_pointer_needed\n-                   && (reg == REG_Y || reg == (REG_Y+1)))))\n+                   && (reg == REG_Y || reg == REG_Y + 1))))\n         {\n           if (set)\n             SET_HARD_REG_BIT (*set, reg);\n@@ -1374,7 +1374,7 @@ sequent_regs_live (void)\n       else\n         cur_seq = 0;\n \n-      if (df_regs_ever_live_p (REG_Y+1))\n+      if (df_regs_ever_live_p (REG_Y + 1))\n         {\n           ++live_seq;\n           ++cur_seq;\n@@ -1807,7 +1807,8 @@ avr_expand_prologue (void)\n   avr_prologue_setup_frame (size, set);\n \n   if (flag_stack_usage_info)\n-    current_function_static_stack_size = cfun->machine->stack_usage + INCOMING_FRAME_SP_OFFSET;\n+    current_function_static_stack_size\n+      = cfun->machine->stack_usage + INCOMING_FRAME_SP_OFFSET;\n }\n \n \n@@ -1840,9 +1841,9 @@ avr_asm_function_end_prologue (FILE *file)\n              avr_outgoing_args_size());\n \n   fprintf (file, \"/* frame size = \" HOST_WIDE_INT_PRINT_DEC \" */\\n\",\n-                 get_frame_size());\n+           get_frame_size());\n   fprintf (file, \"/* stack size = %d */\\n\",\n-                 cfun->machine->stack_usage);\n+           cfun->machine->stack_usage);\n   /* Create symbol stack offset here so all functions have it. Add 1 to stack\n      usage for offset so that SP + .L__stack_offset = return address.  */\n   fprintf (file, \".L__stack_usage = %d\\n\", cfun->machine->stack_usage);\n@@ -2522,7 +2523,7 @@ avr_print_operand_address (FILE *file, machine_mode /*mode*/, rtx addr)\n           rtx x = addr;\n           if (GET_CODE (x) == CONST)\n             x = XEXP (x, 0);\n-          if (GET_CODE (x) == PLUS && CONST_INT_P (XEXP (x,1)))\n+          if (GET_CODE (x) == PLUS && CONST_INT_P (XEXP (x, 1)))\n             {\n               /* Assembler gs() will implant word address.  Make offset\n                  a byte offset inside gs() for assembler.  This is\n@@ -2532,14 +2533,14 @@ avr_print_operand_address (FILE *file, machine_mode /*mode*/, rtx addr)\n                  from symbol which may not be what the user really wanted.  */\n \n               fprintf (file, \"gs(\");\n-              output_addr_const (file, XEXP (x,0));\n+              output_addr_const (file, XEXP (x, 0));\n               fprintf (file, \"+\" HOST_WIDE_INT_PRINT_DEC \")\",\n                        2 * INTVAL (XEXP (x, 1)));\n               if (AVR_3_BYTE_PC)\n                 if (warning (0, \"pointer offset from symbol maybe incorrect\"))\n                   {\n                     output_addr_const (stderr, addr);\n-                    fprintf(stderr,\"\\n\");\n+                    fprintf (stderr, \"\\n\");\n                   }\n             }\n           else\n@@ -2617,12 +2618,12 @@ avr_print_operand (FILE *file, rtx x, int code)\n     }\n   else if (code == 'E' || code == 'F')\n     {\n-      rtx op = XEXP(x, 0);\n+      rtx op = XEXP (x, 0);\n       fprintf (file, \"%s\", reg_names[REGNO (op) + ef]);\n     }\n   else if (code == 'I' || code == 'J')\n     {\n-      rtx op = XEXP(XEXP(x, 0), 0);\n+      rtx op = XEXP (XEXP (x, 0), 0);\n       fprintf (file, \"%s\", reg_names[REGNO (op) + ij]);\n     }\n   else if (REG_P (x))\n@@ -2714,12 +2715,12 @@ avr_print_operand (FILE *file, rtx x, int code)\n         }\n       else if (GET_CODE (addr) == PLUS)\n         {\n-          avr_print_operand_address (file, VOIDmode, XEXP (addr,0));\n+          avr_print_operand_address (file, VOIDmode, XEXP (addr, 0));\n           if (REGNO (XEXP (addr, 0)) == REG_X)\n             fatal_insn (\"internal compiler error.  Bad address:\"\n                         ,addr);\n           fputc ('+', file);\n-          avr_print_operand (file, XEXP (addr,1), code);\n+          avr_print_operand (file, XEXP (addr, 1), code);\n         }\n       else\n         avr_print_operand_address (file, VOIDmode, addr);\n@@ -2753,7 +2754,7 @@ avr_print_operand (FILE *file, rtx x, int code)\n                                 code);\n       fprintf (file, HOST_WIDE_INT_PRINT_DEC, ival);\n     }\n-  else if (GET_CODE (x) == CONST_DOUBLE)\n+  else if (CONST_DOUBLE_P (x))\n     {\n       long val;\n       if (GET_MODE (x) != SFmode)\n@@ -2781,15 +2782,15 @@ avr_print_operand (FILE *file, rtx x, int code)\n \n static bool\n avr_use_by_pieces_infrastructure_p (unsigned HOST_WIDE_INT size,\n-\t\t\t\t     unsigned int align ATTRIBUTE_UNUSED,\n-\t\t\t\t     enum by_pieces_operation op,\n-\t\t\t\t     bool speed_p)\n+                                    unsigned int align ATTRIBUTE_UNUSED,\n+                                    enum by_pieces_operation op,\n+                                    bool speed_p)\n {\n-\n-  if (op != MOVE_BY_PIECES || (speed_p && (size > (MOVE_MAX_PIECES))))\n+  if (op != MOVE_BY_PIECES\n+      || (speed_p && size > MOVE_MAX_PIECES))\n     return default_use_by_pieces_infrastructure_p (size, align, op, speed_p);\n \n-  return size <= (MOVE_MAX_PIECES);\n+  return size <= MOVE_MAX_PIECES;\n }\n \n \n@@ -2951,9 +2952,9 @@ avr_jump_mode (rtx x, rtx_insn *insn)\n   int cur_addr = INSN_ADDRESSES (INSN_UID (insn));\n   int jump_distance = cur_addr - dest_addr;\n \n-  if (-63 <= jump_distance && jump_distance <= 62)\n+  if (IN_RANGE (jump_distance, -63, 62))\n     return 1;\n-  else if (-2046 <= jump_distance && jump_distance <= 2045)\n+  else if (IN_RANGE (jump_distance, -2046, 2045))\n     return 2;\n   else if (AVR_HAVE_JMP_CALL)\n     return 3;\n@@ -3113,9 +3114,9 @@ avr_simplify_comparison_p (machine_mode mode, RTX_CODE op, rtx x)\n    register in which function arguments are sometimes passed.  */\n \n int\n-avr_function_arg_regno_p(int r)\n+avr_function_arg_regno_p (int r)\n {\n-  return (AVR_TINY ? r >= 20 && r <= 25 : r >= 8 && r <= 25);\n+  return AVR_TINY ? IN_RANGE (r, 20, 25) : IN_RANGE (r, 8, 25);\n }\n \n \n@@ -3526,8 +3527,8 @@ avr_out_lpm (rtx_insn *insn, rtx *op, int *plen)\n         }\n       else\n         {\n-          avr_asm_len (\"mov %5,%2\"         CR_TAB\n-                       \"ldi %2,%4\"         CR_TAB\n+          avr_asm_len (\"mov %5,%2\"   CR_TAB\n+                       \"ldi %2,%4\"   CR_TAB\n                        \"out %i6,%2\"  CR_TAB\n                        \"mov %2,%5\", xop, plen, 4);\n         }\n@@ -3595,7 +3596,7 @@ avr_out_lpm (rtx_insn *insn, rtx *op, int *plen)\n \n           if (REGNO (dest) == REG_Z - 2)\n             return avr_asm_len (\"%4lpm %5,%a2+\" CR_TAB\n-                                \"%4lpm %C0,%a2\"          CR_TAB\n+                                \"%4lpm %C0,%a2\" CR_TAB\n                                 \"mov %D0,%5\", xop, plen, 3);\n           else\n             {\n@@ -3801,8 +3802,8 @@ avr_out_movqi_r_mr_reg_disp_tiny (rtx_insn *insn, rtx op[], int *plen)\n   avr_asm_len (TINY_ADIW (%I1, %J1, %o1) CR_TAB\n                \"ld %0,%b1\" , op, plen, -3);\n \n-  if (!reg_overlap_mentioned_p (dest, XEXP (x,0))\n-      && !reg_unused_after (insn, XEXP (x,0)))\n+  if (!reg_overlap_mentioned_p (dest, XEXP (x, 0))\n+      && !reg_unused_after (insn, XEXP (x, 0)))\n     avr_asm_len (TINY_SBIW (%I1, %J1, %o1), op, plen, 2);\n \n   return \"\";\n@@ -3858,8 +3859,8 @@ out_movqi_r_mr (rtx_insn *insn, rtx op[], int *plen)\n           avr_asm_len (\"adiw r26,%o1\" CR_TAB\n                        \"ld %0,X\", op, plen, -2);\n \n-          if (!reg_overlap_mentioned_p (dest, XEXP (x,0))\n-              && !reg_unused_after (insn, XEXP (x,0)))\n+          if (!reg_overlap_mentioned_p (dest, XEXP (x, 0))\n+              && !reg_unused_after (insn, XEXP (x, 0)))\n             {\n               avr_asm_len (\"sbiw r26,%o1\", op, plen, 1);\n             }\n@@ -3891,7 +3892,7 @@ avr_out_movhi_r_mr_reg_no_disp_tiny (rtx_insn *insn, rtx op[], int *plen)\n \t\t\t\"ld %B0,%1\"          CR_TAB\n \t\t\t\"mov %A0,__tmp_reg__\", op, plen, -3);\n \n-  avr_asm_len (\"ld %A0,%1+\"                  CR_TAB\n+  avr_asm_len (\"ld %A0,%1+\" CR_TAB\n                \"ld %B0,%1\", op, plen, -2);\n \n   if (!reg_unused_after (insn, base))\n@@ -4228,12 +4229,12 @@ out_movsi_r_mr (rtx_insn *insn, rtx op[], int *l)\n                           \"ld %D0,X\"           CR_TAB\n                           \"mov %C0,__tmp_reg__\");\n           else if (reg_unused_after (insn, base))\n-            return  *l=4, (\"ld %A0,X+\"  CR_TAB\n+            return  *l=4, (\"ld %A0,X+\" CR_TAB\n                            \"ld %B0,X+\" CR_TAB\n                            \"ld %C0,X+\" CR_TAB\n                            \"ld %D0,X\");\n           else\n-            return  *l=5, (\"ld %A0,X+\"  CR_TAB\n+            return  *l=5, (\"ld %A0,X+\" CR_TAB\n                            \"ld %B0,X+\" CR_TAB\n                            \"ld %C0,X+\" CR_TAB\n                            \"ld %D0,X\"  CR_TAB\n@@ -4873,7 +4874,7 @@ avr_out_load_psi (rtx_insn *insn, rtx *op, int *plen)\n \n           return avr_asm_len (\"subi r28,lo8(-%o1)\" CR_TAB\n                               \"sbci r29,hi8(-%o1)\" CR_TAB\n-                              \"ld  %A0,Y\"           CR_TAB\n+                              \"ld  %A0,Y\"          CR_TAB\n                               \"ldd %B0,Y+1\"        CR_TAB\n                               \"ldd %C0,Y+2\"        CR_TAB\n                               \"subi r28,lo8(%o1)\"  CR_TAB\n@@ -5196,7 +5197,7 @@ avr_out_movqi_mr_r_reg_disp_tiny (rtx_insn *insn, rtx op[], int *plen)\n                    \"st %b0,%1\", op, plen, -3);\n     }\n \n-  if (!reg_unused_after (insn, XEXP (x,0)))\n+  if (!reg_unused_after (insn, XEXP (x, 0)))\n       avr_asm_len (TINY_SBIW (%I0, %J0, %o0), op, plen, 2);\n \n   return \"\";\n@@ -5243,7 +5244,7 @@ out_movqi_mr_r (rtx_insn *insn, rtx op[], int *plen)\n                               \"subi r28,lo8(%o0)\"  CR_TAB\n                               \"sbci r29,hi8(%o0)\", op, plen, -5);\n         }\n-      else if (REGNO (XEXP (x,0)) == REG_X)\n+      else if (REGNO (XEXP (x, 0)) == REG_X)\n         {\n           if (reg_overlap_mentioned_p (src, XEXP (x, 0)))\n             {\n@@ -5257,7 +5258,7 @@ out_movqi_mr_r (rtx_insn *insn, rtx op[], int *plen)\n                            \"st X,%1\", op, plen, -2);\n             }\n \n-          if (!reg_unused_after (insn, XEXP (x,0)))\n+          if (!reg_unused_after (insn, XEXP (x, 0)))\n             avr_asm_len (\"sbiw r26,%o0\", op, plen, 1);\n \n           return \"\";\n@@ -5403,7 +5404,7 @@ avr_out_movhi_mr_r_reg_no_disp_tiny (rtx_insn *insn, rtx op[], int *plen)\n                        \"st %0,__tmp_reg__\", op, plen, -5)\n         : avr_asm_len (\"mov __tmp_reg__,%B1\"   CR_TAB\n                        TINY_ADIW (%E0, %F0, 1) CR_TAB\n-                       \"st %0,__tmp_reg__\"      CR_TAB\n+                       \"st %0,__tmp_reg__\"     CR_TAB\n                        TINY_SBIW (%E0, %F0, 1) CR_TAB\n                        \"st %0, %A1\", op, plen, -7);\n     }\n@@ -6200,9 +6201,9 @@ ashlhi3_out (rtx_insn *insn, rtx operands[], int *len)\n \t      return (\"swap %A0\"    CR_TAB\n \t\t      \"swap %B0\"    CR_TAB\n \t\t      \"ldi %3,0xf0\" CR_TAB\n-\t\t      \"and %B0,%3\"      CR_TAB\n+\t\t      \"and %B0,%3\"  CR_TAB\n \t\t      \"eor %B0,%A0\" CR_TAB\n-\t\t      \"and %A0,%3\"      CR_TAB\n+\t\t      \"and %A0,%3\"  CR_TAB\n \t\t      \"eor %B0,%A0\");\n \t    }\n \t  break;  /* optimize_size ? 6 : 8 */\n@@ -6230,9 +6231,9 @@ ashlhi3_out (rtx_insn *insn, rtx operands[], int *len)\n \t\t      \"swap %A0\"    CR_TAB\n \t\t      \"swap %B0\"    CR_TAB\n \t\t      \"ldi %3,0xf0\" CR_TAB\n-\t\t      \"and %B0,%3\"      CR_TAB\n+\t\t      \"and %B0,%3\"  CR_TAB\n \t\t      \"eor %B0,%A0\" CR_TAB\n-\t\t      \"and %A0,%3\"      CR_TAB\n+\t\t      \"and %A0,%3\"  CR_TAB\n \t\t      \"eor %B0,%A0\");\n \t    }\n \t  break;  /* 10 */\n@@ -6344,7 +6345,7 @@ ashlhi3_out (rtx_insn *insn, rtx operands[], int *len)\n \t  if (AVR_HAVE_MUL)\n \t    {\n \t      *len = 6;\n-\t      return (\"set\"            CR_TAB\n+\t      return (\"set\"        CR_TAB\n \t\t      \"bld r1,5\"   CR_TAB\n \t\t      \"mul %A0,r1\" CR_TAB\n \t\t      \"mov %B0,r0\" CR_TAB\n@@ -7095,9 +7096,9 @@ lshrhi3_out (rtx_insn *insn, rtx operands[], int *len)\n \t      return (\"swap %B0\"    CR_TAB\n \t\t      \"swap %A0\"    CR_TAB\n \t\t      \"ldi %3,0x0f\" CR_TAB\n-\t\t      \"and %A0,%3\"      CR_TAB\n+\t\t      \"and %A0,%3\"  CR_TAB\n \t\t      \"eor %A0,%B0\" CR_TAB\n-\t\t      \"and %B0,%3\"      CR_TAB\n+\t\t      \"and %B0,%3\"  CR_TAB\n \t\t      \"eor %A0,%B0\");\n \t    }\n \t  break;  /* optimize_size ? 6 : 8 */\n@@ -7125,9 +7126,9 @@ lshrhi3_out (rtx_insn *insn, rtx operands[], int *len)\n \t\t      \"swap %B0\"    CR_TAB\n \t\t      \"swap %A0\"    CR_TAB\n \t\t      \"ldi %3,0x0f\" CR_TAB\n-\t\t      \"and %A0,%3\"      CR_TAB\n+\t\t      \"and %A0,%3\"  CR_TAB\n \t\t      \"eor %A0,%B0\" CR_TAB\n-\t\t      \"and %B0,%3\"      CR_TAB\n+\t\t      \"and %B0,%3\"  CR_TAB\n \t\t      \"eor %A0,%B0\");\n \t    }\n \t  break;  /* 10 */\n@@ -7239,7 +7240,7 @@ lshrhi3_out (rtx_insn *insn, rtx operands[], int *len)\n \t  if (AVR_HAVE_MUL)\n \t    {\n \t      *len = 6;\n-\t      return (\"set\"            CR_TAB\n+\t      return (\"set\"        CR_TAB\n \t\t      \"bld r1,3\"   CR_TAB\n \t\t      \"mul %B0,r1\" CR_TAB\n \t\t      \"mov %A0,r1\" CR_TAB\n@@ -7575,7 +7576,7 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc,\n          where this must be done is when NEG overflowed in case [2s] because\n          the V computation needs the right sign of the subtrahend.  */\n \n-      rtx msb = simplify_gen_subreg (QImode, xop[0], mode, n_bytes-1);\n+      rtx msb = simplify_gen_subreg (QImode, xop[0], mode, n_bytes - 1);\n \n       avr_asm_len (\"subi %0,128\" CR_TAB\n                    \"brmi 0f\", &msb, plen, 2);\n@@ -8257,9 +8258,9 @@ avr_out_sign_extend (rtx_insn *insn, rtx *xop, int *plen)\n       avr_asm_len (\"mov __tmp_reg__,%0\", &r_msb, plen, 1);\n       r_msb = tmp_reg_rtx;\n     }\n-  \n+\n   avr_asm_len (\"lsl %0\", &r_msb, plen, 1);\n-                   \n+\n   // ...and propagate it to all the new sign bits\n \n   for (unsigned n = n_src; n < n_dest; n++)\n@@ -8374,7 +8375,7 @@ avr_out_insert_notbit (rtx_insn *insn, rtx operands[], rtx xbitno, int *plen)\n \n       avr_asm_len (\"bld %0,%1\", op, plen, 1);\n     }\n-              \n+\n   return \"\";\n }\n \n@@ -9236,7 +9237,7 @@ int\n reg_unused_after (rtx_insn *insn, rtx reg)\n {\n   return (dead_or_set_p (insn, reg)\n-\t  || (REG_P(reg) && _reg_unused_after (insn, reg)));\n+\t  || (REG_P (reg) && _reg_unused_after (insn, reg)));\n }\n \n /* Return nonzero if REG is not used after INSN.\n@@ -9253,7 +9254,7 @@ _reg_unused_after (rtx_insn *insn, rtx reg)\n      case.  Disregard the case where this is a store to memory, since\n      we are checking a register used in the store address.  */\n   set = single_set (insn);\n-  if (set && GET_CODE (SET_DEST (set)) != MEM\n+  if (set && !MEM_P (SET_DEST (set))\n       && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n     return 1;\n \n@@ -9305,7 +9306,7 @@ _reg_unused_after (rtx_insn *insn, rtx reg)\n \t\treturn 0;\n \t      if (set && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n \t\t{\n-\t\t  if (GET_CODE (SET_DEST (set)) != MEM)\n+\t\t  if (!MEM_P (SET_DEST (set)))\n \t\t    retval = 1;\n \t\t  else\n \t\t    return 0;\n@@ -9337,7 +9338,7 @@ _reg_unused_after (rtx_insn *insn, rtx reg)\n       if (set && reg_overlap_mentioned_p (reg, SET_SRC (set)))\n \treturn 0;\n       if (set && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n-\treturn GET_CODE (SET_DEST (set)) != MEM;\n+\treturn !MEM_P (SET_DEST (set));\n       if (set == 0 && reg_overlap_mentioned_p (reg, PATTERN (insn)))\n \treturn 0;\n     }\n@@ -9640,7 +9641,7 @@ avr_attribute_table[] =\n /* Return true if we support address space AS for the architecture in effect\n    and false, otherwise.  If LOC is not UNKNOWN_LOCATION then also issue\n    a respective error.  */\n-   \n+\n bool\n avr_addr_space_supported_p (addr_space_t as, location_t loc)\n {\n@@ -10582,7 +10583,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code ATTRIBUTE_UNUSED,\n \t      *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code, 1,\n \t\t\t\t\t      speed);\n \t    }\n-\t  else if (INTVAL (XEXP (x, 1)) >= -63 && INTVAL (XEXP (x, 1)) <= 63)\n+\t  else if (IN_RANGE (INTVAL (XEXP (x, 1)), -63, 63))\n \t    *total = COSTS_N_INSNS (1);\n \t  else\n \t    *total = COSTS_N_INSNS (2);\n@@ -10595,7 +10596,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code ATTRIBUTE_UNUSED,\n               *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code, 1,\n                                               speed);\n             }\n-          else if (INTVAL (XEXP (x, 1)) >= -63 && INTVAL (XEXP (x, 1)) <= 63)\n+          else if (IN_RANGE (INTVAL (XEXP (x, 1)), -63, 63))\n             *total = COSTS_N_INSNS (2);\n           else\n             *total = COSTS_N_INSNS (3);\n@@ -10608,7 +10609,7 @@ avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code ATTRIBUTE_UNUSED,\n \t      *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code, 1,\n \t\t\t\t\t      speed);\n \t    }\n-\t  else if (INTVAL (XEXP (x, 1)) >= -63 && INTVAL (XEXP (x, 1)) <= 63)\n+\t  else if (IN_RANGE (INTVAL (XEXP (x, 1)), -63, 63))\n \t    *total = COSTS_N_INSNS (1);\n \t  else\n \t    *total = COSTS_N_INSNS (4);\n@@ -11323,8 +11324,7 @@ static bool\n avr_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t       int opno, int *total, bool speed)\n {\n-  bool done = avr_rtx_costs_1 (x, mode, outer_code,\n-                               opno, total, speed);\n+  bool done = avr_rtx_costs_1 (x, mode, outer_code, opno, total, speed);\n \n   if (avr_log.rtx_costs)\n     {\n@@ -11658,7 +11658,7 @@ avr_reorg (void)\n             {\n               rtx x = XEXP (pattern, 0);\n               rtx src = SET_SRC (pat);\n-              rtx t = XEXP (src,0);\n+              rtx t = XEXP (src, 0);\n               PUT_CODE (t, swap_condition (GET_CODE (t)));\n               XEXP (pattern, 0) = XEXP (pattern, 1);\n               XEXP (pattern, 1) = x;\n@@ -11669,7 +11669,7 @@ avr_reorg (void)\n             {\n               /* This is a tst insn, we can reverse it.  */\n               rtx src = SET_SRC (pat);\n-              rtx t = XEXP (src,0);\n+              rtx t = XEXP (src, 0);\n \n               PUT_CODE (t, swap_condition (GET_CODE (t)));\n               XEXP (pattern, 1) = XEXP (pattern, 0);\n@@ -11682,7 +11682,7 @@ avr_reorg (void)\n             {\n               rtx x = XEXP (pattern, 1);\n               rtx src = SET_SRC (pat);\n-              rtx t = XEXP (src,0);\n+              rtx t = XEXP (src, 0);\n               machine_mode mode = GET_MODE (XEXP (pattern, 0));\n \n               if (avr_simplify_comparison_p (mode, GET_CODE (t), x))\n@@ -11889,8 +11889,8 @@ avr_hard_regno_call_part_clobbered (unsigned regno, machine_mode mode)\n   /* Return true if any of the following boundaries is crossed:\n      17/18 or 19/20 (if AVR_TINY), 27/28 and 29/30.  */\n \n-  return ((regno <= LAST_CALLEE_SAVED_REG &&\n-           regno + GET_MODE_SIZE (mode) > (LAST_CALLEE_SAVED_REG + 1))\n+  return ((regno <= LAST_CALLEE_SAVED_REG\n+           && regno + GET_MODE_SIZE (mode) > 1 + LAST_CALLEE_SAVED_REG)\n           || (regno < REG_Y && regno + GET_MODE_SIZE (mode) > REG_Y)\n           || (regno < REG_Z && regno + GET_MODE_SIZE (mode) > REG_Z));\n }\n@@ -12309,7 +12309,7 @@ avr_output_addr_vec_elt (FILE *stream, int value)\n }\n \n static void\n-avr_conditional_register_usage(void)\n+avr_conditional_register_usage (void)\n {\n   if (AVR_TINY)\n     {\n@@ -13191,13 +13191,13 @@ avr_expand_delay_cycles (rtx operands0)\n \n   while (cycles >= 2)\n     {\n-      emit_insn (gen_nopv (GEN_INT(2)));\n+      emit_insn (gen_nopv (GEN_INT (2)));\n       cycles -= 2;\n     }\n \n   if (cycles == 1)\n     {\n-      emit_insn (gen_nopv (GEN_INT(1)));\n+      emit_insn (gen_nopv (GEN_INT (1)));\n       cycles--;\n     }\n }\n@@ -13807,7 +13807,7 @@ avr_default_expand_builtin (enum insn_code icode, tree exp, rtx target)\n       tree arg = CALL_EXPR_ARG (exp, n);\n       rtx op = expand_expr (arg, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n       machine_mode opmode = GET_MODE (op);\n-      machine_mode mode = insn_data[icode].operand[n+1].mode;\n+      machine_mode mode = insn_data[icode].operand[n + 1].mode;\n \n       if ((opmode == SImode || opmode == VOIDmode) && mode == HImode)\n         {\n@@ -13820,7 +13820,7 @@ avr_default_expand_builtin (enum insn_code icode, tree exp, rtx target)\n \n       gcc_assert (opmode == mode || opmode == VOIDmode);\n \n-      if (!insn_data[icode].operand[n+1].predicate (op, mode))\n+      if (!insn_data[icode].operand[n + 1].predicate (op, mode))\n         op = copy_to_mode_reg (mode, op);\n \n       xop[n] = op;\n@@ -13870,7 +13870,7 @@ avr_expand_builtin (tree exp, rtx target,\n   switch (id)\n     {\n     case AVR_BUILTIN_NOP:\n-      emit_insn (gen_nopv (GEN_INT(1)));\n+      emit_insn (gen_nopv (GEN_INT (1)));\n       return 0;\n \n     case AVR_BUILTIN_DELAY_CYCLES:"}]}