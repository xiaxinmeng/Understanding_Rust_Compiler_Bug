{"sha": "d6e5745a9a88314e27f387b2277299076862af67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZlNTc0NWE5YTg4MzE0ZTI3ZjM4N2IyMjc3Mjk5MDc2ODYyYWY2Nw==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-11-10T21:39:19Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-11-11T17:36:52Z"}, "message": "c++: Tweak tsubst_qualified_id location.\n\nRetain the location when tsubstituting a qualified-id so that our\nstatic_assert diagnostic can benefit.  Don't create useless location\nwrappers for temporary variables.\n\ngcc/ChangeLog:\n\n\tPR c++/97518\n\t* tree.c (maybe_wrap_with_location): Don't add a location\n\twrapper around an artificial and ignored decl.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/97518\n\t* pt.c (tsubst_qualified_id): Use EXPR_LOCATION of the qualified-id.\n\tUse it to maybe_wrap_with_location the final expression.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/97518\n\t* g++.dg/diagnostic/static_assert3.C: New test.", "tree": {"sha": "71ce4bec306b8303730e6a6c4257c3109ed045b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71ce4bec306b8303730e6a6c4257c3109ed045b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6e5745a9a88314e27f387b2277299076862af67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6e5745a9a88314e27f387b2277299076862af67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6e5745a9a88314e27f387b2277299076862af67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6e5745a9a88314e27f387b2277299076862af67/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e8b368c3d33fd8ddafdd37f8e1b2ba45d1a122e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e8b368c3d33fd8ddafdd37f8e1b2ba45d1a122e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e8b368c3d33fd8ddafdd37f8e1b2ba45d1a122e"}], "stats": {"total": 45, "additions": 43, "deletions": 2}, "files": [{"sha": "c592461c47415ab1d469a01c50692e3f4fcd8ee9", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6e5745a9a88314e27f387b2277299076862af67/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6e5745a9a88314e27f387b2277299076862af67/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d6e5745a9a88314e27f387b2277299076862af67", "patch": "@@ -16214,7 +16214,7 @@ tsubst_qualified_id (tree qualified_id, tree args,\n   tree name;\n   bool is_template;\n   tree template_args;\n-  location_t loc = UNKNOWN_LOCATION;\n+  location_t loc = EXPR_LOCATION (qualified_id);\n \n   gcc_assert (TREE_CODE (qualified_id) == SCOPE_REF);\n \n@@ -16223,7 +16223,6 @@ tsubst_qualified_id (tree qualified_id, tree args,\n   if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n     {\n       is_template = true;\n-      loc = EXPR_LOCATION (name);\n       template_args = TREE_OPERAND (name, 1);\n       if (template_args)\n \ttemplate_args = tsubst_template_args (template_args, args,\n@@ -16351,6 +16350,8 @@ tsubst_qualified_id (tree qualified_id, tree args,\n   if (REF_PARENTHESIZED_P (qualified_id))\n     expr = force_paren_expr (expr);\n \n+  expr = maybe_wrap_with_location (expr, loc);\n+\n   return expr;\n }\n "}, {"sha": "5d363884508df93c8f3c5bab3e4269f7c9b05ae1", "filename": "gcc/testsuite/g++.dg/diagnostic/static_assert3.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6e5745a9a88314e27f387b2277299076862af67/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fstatic_assert3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6e5745a9a88314e27f387b2277299076862af67/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fstatic_assert3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fstatic_assert3.C?ref=d6e5745a9a88314e27f387b2277299076862af67", "patch": "@@ -0,0 +1,36 @@\n+// PR c++/97518\n+// { dg-do compile { target c++17 } }\n+// { dg-options \"-fdiagnostics-show-caret\" }\n+\n+template <typename T, typename U> struct is_same { static constexpr bool value = false; };\n+template <typename T> struct is_same<T, T> { static constexpr bool value = true; };\n+\n+template <typename T, typename U>\n+void f(T, U)\n+{\n+  static_assert(is_same<T, T>::value && is_same<T, U>::value); // { dg-error \"56:static assertion failed\" }\n+/* { dg-begin-multiline-output \"\" }\n+   static_assert(is_same<T, T>::value && is_same<T, U>::value);\n+                                                        ^~~~~\n+   { dg-end-multiline-output \"\" } */\n+// { dg-message \".is_same<int, double>::value. evaluates to false\" \"\" { target *-*-* } .-5 }\n+  static_assert(is_same<U, T>::value && is_same<U, U>::value); // { dg-error \"32:static assertion failed\" }\n+/* { dg-begin-multiline-output \"\" }\n+   static_assert(is_same<U, T>::value && is_same<U, U>::value);\n+                                ^~~~~\n+   { dg-end-multiline-output \"\" } */\n+// { dg-message \".is_same<double, int>::value. evaluates to false\" \"\" { target *-*-* } .-5 }\n+  static_assert(is_same<U, U>::value\n+\t\t&& is_same<U, T>::value // { dg-error \"35:static assertion failed\" }\n+\t\t&& is_same<T, T>::value);\n+/* { dg-begin-multiline-output \"\" }\n+                 && is_same<U, T>::value\n+                                   ^~~~~\n+   { dg-end-multiline-output \"\" } */\n+// { dg-message \".is_same<double, int>::value. evaluates to false\" \"\" { target *-*-* } .-6 }\n+}\n+\n+void g()\n+{\n+ f(0, 1.3);\n+}"}, {"sha": "1ad4ad5a5f7403cbff656e4f596f7333e73e57bf", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6e5745a9a88314e27f387b2277299076862af67/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6e5745a9a88314e27f387b2277299076862af67/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d6e5745a9a88314e27f387b2277299076862af67", "patch": "@@ -15041,6 +15041,10 @@ maybe_wrap_with_location (tree expr, location_t loc)\n   if (EXCEPTIONAL_CLASS_P (expr))\n     return expr;\n \n+  /* Compiler-generated temporary variables don't need a wrapper.  */\n+  if (DECL_P (expr) && DECL_ARTIFICIAL (expr) && DECL_IGNORED_P (expr))\n+    return expr;\n+\n   /* If any auto_suppress_location_wrappers are active, don't create\n      wrappers.  */\n   if (suppress_location_wrappers > 0)"}]}