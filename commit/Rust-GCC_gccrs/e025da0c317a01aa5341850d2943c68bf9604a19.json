{"sha": "e025da0c317a01aa5341850d2943c68bf9604a19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAyNWRhMGMzMTdhMDFhYTUzNDE4NTBkMjk0M2M2OGJmOTYwNGExOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-03-30T18:00:21Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-03-30T18:00:21Z"}, "message": "i386: Add and use one_operand_p to vec_perm control struct.\n\n\t* config/i386/i386.c (struct expand_vec_perm_d): Add one_operand_p.\n\t(ix86_expand_vector_init_duplicate): Initialize it.\n\t(expand_vec_perm_palignr): Likewise.\n\t(ix86_expand_vec_perm_const): Likewise.\n\t(ix86_vectorize_vec_perm_const_ok): Likewise.\n\t(expand_vec_perm_blend): Use it.\n\t(expand_vec_perm_vpermil): Likewise.\n\t(expand_vec_perm_pshufb): Likewise.\n\t(expand_vec_perm_1): Likewise.\n\t(expand_vec_perm_pshuflw_pshufhw): Likewise.\n\t(expand_vec_perm_interleave2): Likewise.\n\t(expand_vec_perm_vpermq_perm_1): Likewise.\n\t(expand_vec_perm_vperm2f128): Likewise.\n\t(expand_vec_perm_interleave3): Likewise.\n\t(expand_vec_perm_vperm2f128_vblend): Likewise.\n\t(expand_vec_perm_vpshufb2_vpermq): Likewise.\n\t(expand_vec_perm_vpshufb2_vpermq_even_odd): Likewise,.\n\t(expand_vec_perm_broadcast): Likewise.\n\t(expand_vec_perm_vpshufb4_vpermq2): Likewise.\n\nFrom-SVN: r186017", "tree": {"sha": "549078e022601677693850396d5069f876491859", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/549078e022601677693850396d5069f876491859"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e025da0c317a01aa5341850d2943c68bf9604a19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e025da0c317a01aa5341850d2943c68bf9604a19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e025da0c317a01aa5341850d2943c68bf9604a19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e025da0c317a01aa5341850d2943c68bf9604a19/comments", "author": null, "committer": null, "parents": [{"sha": "7b470faf618e2322d2fef5b38eb580e672ca5325", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b470faf618e2322d2fef5b38eb580e672ca5325", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b470faf618e2322d2fef5b38eb580e672ca5325"}], "stats": {"total": 138, "additions": 76, "deletions": 62}, "files": [{"sha": "0fdd25a2ab215950d669abdd7e5719cfa936bb7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e025da0c317a01aa5341850d2943c68bf9604a19/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e025da0c317a01aa5341850d2943c68bf9604a19/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e025da0c317a01aa5341850d2943c68bf9604a19", "patch": "@@ -1,3 +1,25 @@\n+2012-03-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.c (struct expand_vec_perm_d): Add one_operand_p.\n+\t(ix86_expand_vector_init_duplicate): Initialize it.\n+\t(expand_vec_perm_palignr): Likewise.\n+\t(ix86_expand_vec_perm_const): Likewise.\n+\t(ix86_vectorize_vec_perm_const_ok): Likewise.\n+\t(expand_vec_perm_blend): Use it.\n+\t(expand_vec_perm_vpermil): Likewise.\n+\t(expand_vec_perm_pshufb): Likewise.\n+\t(expand_vec_perm_1): Likewise.\n+\t(expand_vec_perm_pshuflw_pshufhw): Likewise.\n+\t(expand_vec_perm_interleave2): Likewise.\n+\t(expand_vec_perm_vpermq_perm_1): Likewise.\n+\t(expand_vec_perm_vperm2f128): Likewise.\n+\t(expand_vec_perm_interleave3): Likewise.\n+\t(expand_vec_perm_vperm2f128_vblend): Likewise.\n+\t(expand_vec_perm_vpshufb2_vpermq): Likewise.\n+\t(expand_vec_perm_vpshufb2_vpermq_even_odd): Likewise,.\n+\t(expand_vec_perm_broadcast): Likewise.\n+\t(expand_vec_perm_vpshufb4_vpermq2): Likewise.\n+\n 2012-03-30  Richard Henderson  <rth@redhat.com>\n \n \t* dwarf2out.c (gen_variable_die): Initialize off."}, {"sha": "8cb5a0d56f5cb1d1c1d8a1c2f4a380743caffab2", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 54, "deletions": 62, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e025da0c317a01aa5341850d2943c68bf9604a19/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e025da0c317a01aa5341850d2943c68bf9604a19/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e025da0c317a01aa5341850d2943c68bf9604a19", "patch": "@@ -32938,6 +32938,7 @@ struct expand_vec_perm_d\n   unsigned char perm[MAX_VECT_LEN];\n   enum machine_mode vmode;\n   unsigned char nelt;\n+  bool one_operand_p;\n   bool testing_p;\n };\n \n@@ -33038,6 +33039,7 @@ ix86_expand_vector_init_duplicate (bool mmx_ok, enum machine_mode mode,\n \t  dperm.vmode = mode;\n \t  dperm.nelt = GET_MODE_NUNITS (mode);\n \t  dperm.op0 = dperm.op1 = gen_reg_rtx (mode);\n+\t  dperm.one_operand_p = true;\n \n \t  /* Extend to SImode using a paradoxical SUBREG.  */\n \t  tmp1 = gen_reg_rtx (SImode);\n@@ -35735,7 +35737,7 @@ expand_vec_perm_blend (struct expand_vec_perm_d *d)\n   rtx target, op0, op1, x;\n   rtx rperm[32], vperm;\n \n-  if (d->op0 == d->op1)\n+  if (d->one_operand_p)\n     return false;\n   if (TARGET_AVX2 && GET_MODE_SIZE (vmode) == 32)\n     ;\n@@ -35922,7 +35924,7 @@ expand_vec_perm_vpermil (struct expand_vec_perm_d *d)\n   rtx rperm[8], vperm;\n   unsigned i;\n \n-  if (!TARGET_AVX || d->vmode != V8SFmode || d->op0 != d->op1)\n+  if (!TARGET_AVX || d->vmode != V8SFmode || !d->one_operand_p)\n     return false;\n \n   /* We can only permute within the 128-bit lane.  */\n@@ -35998,7 +36000,7 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n \n   nelt = d->nelt;\n \n-  if (d->op0 != d->op1)\n+  if (!d->one_operand_p)\n     {\n       if (!TARGET_XOP || GET_MODE_SIZE (d->vmode) != 16)\n \t{\n@@ -36086,7 +36088,7 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n   else\n     {\n       eltsz = GET_MODE_SIZE (GET_MODE_INNER (d->vmode));\n-      if (d->op0 != d->op1)\n+      if (!d->one_operand_p)\n \tmask = 2 * nelt - 1;\n       else if (vmode == V16QImode)\n \tmask = nelt - 1;\n@@ -36113,7 +36115,7 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n \n   target = gen_lowpart (vmode, d->target);\n   op0 = gen_lowpart (vmode, d->op0);\n-  if (d->op0 == d->op1)\n+  if (d->one_operand_p)\n     {\n       if (vmode == V16QImode)\n \temit_insn (gen_ssse3_pshufbv16qi3 (target, op0, vperm));\n@@ -36145,7 +36147,7 @@ expand_vec_perm_1 (struct expand_vec_perm_d *d)\n   /* Check plain VEC_SELECT first, because AVX has instructions that could\n      match both SEL and SEL+CONCAT, but the plain SEL will allow a memory\n      input where SEL+CONCAT may not.  */\n-  if (d->op0 == d->op1)\n+  if (d->one_operand_p)\n     {\n       int mask = nelt - 1;\n       bool identity_perm = true;\n@@ -36242,7 +36244,7 @@ expand_vec_perm_1 (struct expand_vec_perm_d *d)\n     return true;\n \n   /* Recognize interleave style patterns with reversed operands.  */\n-  if (d->op0 != d->op1)\n+  if (!d->one_operand_p)\n     {\n       for (i = 0; i < nelt; ++i)\n \t{\n@@ -36285,7 +36287,7 @@ expand_vec_perm_pshuflw_pshufhw (struct expand_vec_perm_d *d)\n   unsigned i;\n   bool ok;\n \n-  if (d->vmode != V8HImode || d->op0 != d->op1)\n+  if (d->vmode != V8HImode || !d->one_operand_p)\n     return false;\n \n   /* The two permutations only operate in 64-bit lanes.  */\n@@ -36357,6 +36359,7 @@ expand_vec_perm_palignr (struct expand_vec_perm_d *d)\n \t\t\t\t  gen_lowpart (TImode, d->op0), shift));\n \n   d->op0 = d->op1 = d->target;\n+  d->one_operand_p = true;\n \n   in_order = true;\n   for (i = 0; i < nelt; ++i)\n@@ -36396,14 +36399,14 @@ expand_vec_perm_interleave2 (struct expand_vec_perm_d *d)\n \n   if (GET_MODE_SIZE (d->vmode) == 16)\n     {\n-      if (d->op0 == d->op1)\n+      if (d->one_operand_p)\n \treturn false;\n     }\n   else if (GET_MODE_SIZE (d->vmode) == 32)\n     {\n       if (!TARGET_AVX)\n \treturn false;\n-      /* For 32-byte modes allow even d->op0 == d->op1.\n+      /* For 32-byte modes allow even d->one_operand_p.\n \t The lack of cross-lane shuffling in some instructions\n \t might prevent a single insn shuffle.  */\n       dfinal = *d;\n@@ -36528,11 +36531,11 @@ expand_vec_perm_interleave2 (struct expand_vec_perm_d *d)\n \n       if (nzcnt == 1)\n \t{\n-\t  gcc_assert (d->op0 == d->op1);\n+\t  gcc_assert (d->one_operand_p);\n \t  nonzero_halves[1] = nonzero_halves[0];\n \t  same_halves = true;\n \t}\n-      else if (d->op0 == d->op1)\n+      else if (d->one_operand_p)\n \t{\n \t  gcc_assert (nonzero_halves[0] == 0);\n \t  gcc_assert (nonzero_halves[1] == 1);\n@@ -36571,7 +36574,7 @@ expand_vec_perm_interleave2 (struct expand_vec_perm_d *d)\n \t\t}\n \t    }\n \t}\n-      else if (d->op0 == d->op1)\n+      else if (d->one_operand_p)\n \treturn false;\n       else if (TARGET_AVX2\n \t       && (contents & (q[0] | q[2] | q[4] | q[6])) == contents)\n@@ -36628,6 +36631,7 @@ expand_vec_perm_interleave2 (struct expand_vec_perm_d *d)\n     }\n   dfinal.op0 = gen_reg_rtx (dfinal.vmode);\n   dfinal.op1 = dfinal.op0;\n+  dfinal.one_operand_p = true;\n   dremap.target = dfinal.op0;\n \n   /* Test if the final remap can be done with a single insn.  For V4SFmode or\n@@ -36671,7 +36675,7 @@ expand_vec_perm_vpermq_perm_1 (struct expand_vec_perm_d *d)\n \n   if (!(TARGET_AVX2\n \t&& (d->vmode == V32QImode || d->vmode == V16HImode)\n-\t&& d->op0 == d->op1))\n+\t&& d->one_operand_p))\n     return false;\n \n   contents[0] = 0;\n@@ -36699,6 +36703,7 @@ expand_vec_perm_vpermq_perm_1 (struct expand_vec_perm_d *d)\n   dremap.target = gen_reg_rtx (V4DImode);\n   dremap.op0 = gen_lowpart (V4DImode, d->op0);\n   dremap.op1 = dremap.op0;\n+  dremap.one_operand_p = true;\n   for (i = 0; i < 2; ++i)\n     {\n       unsigned int cnt = 0;\n@@ -36712,6 +36717,7 @@ expand_vec_perm_vpermq_perm_1 (struct expand_vec_perm_d *d)\n   dfinal = *d;\n   dfinal.op0 = gen_lowpart (dfinal.vmode, dremap.target);\n   dfinal.op1 = dfinal.op0;\n+  dfinal.one_operand_p = true;\n   for (i = 0, j = 0; i < nelt; ++i)\n     {\n       if (i == nelt2)\n@@ -36751,8 +36757,7 @@ expand_vec_perm_vperm2f128 (struct expand_vec_perm_d *d)\n     return false;\n \n   dsecond = *d;\n-  if (d->op0 == d->op1)\n-    dsecond.op1 = gen_reg_rtx (d->vmode);\n+  dsecond.one_operand_p = false;\n   dsecond.testing_p = true;\n \n   /* ((perm << 2)|perm) & 0x33 is the vperm2[fi]128\n@@ -36821,10 +36826,7 @@ expand_vec_perm_vperm2f128 (struct expand_vec_perm_d *d)\n \t     vperm2f128 on d->op0 and d->op1.  */\n \t  dsecond.testing_p = false;\n \t  dfirst = *d;\n-\t  if (d->op0 == d->op1)\n-\t    dfirst.target = dsecond.op1;\n-\t  else\n-\t    dfirst.target = gen_reg_rtx (d->vmode);\n+\t  dfirst.target = gen_reg_rtx (d->vmode);\n \t  for (i = 0; i < nelt; i++)\n \t    dfirst.perm[i] = (i & (nelt2 - 1))\n \t\t\t     + ((perm >> (2 * (i >= nelt2))) & 3) * nelt2;\n@@ -36845,9 +36847,8 @@ expand_vec_perm_vperm2f128 (struct expand_vec_perm_d *d)\n \t  return true;\n \t}\n \n-      /* For d->op0 == d->op1 the only useful vperm2f128 permutation\n-\t is 0x10.  */\n-      if (d->op0 == d->op1)\n+      /* For one operand, the only useful vperm2f128 permutation is 0x10.  */\n+      if (d->one_operand_p)\n \treturn false;\n     }\n \n@@ -36864,7 +36865,7 @@ expand_vec_perm_interleave3 (struct expand_vec_perm_d *d)\n   unsigned i, nelt;\n   rtx (*gen) (rtx, rtx, rtx);\n \n-  if (d->op0 == d->op1)\n+  if (d->one_operand_p)\n     return false;\n   if (TARGET_AVX2 && GET_MODE_SIZE (d->vmode) == 32)\n     ;\n@@ -36947,7 +36948,7 @@ expand_vec_perm_vperm2f128_vblend (struct expand_vec_perm_d *d)\n   if (!TARGET_AVX\n       || TARGET_AVX2\n       || (d->vmode != V8SFmode && d->vmode != V4DFmode)\n-      || d->op0 != d->op1)\n+      || !d->one_operand_p)\n     return false;\n \n   dfirst = *d;\n@@ -36985,6 +36986,7 @@ expand_vec_perm_vperm2f128_vblend (struct expand_vec_perm_d *d)\n   dsecond = *d;\n   dsecond.op0 = dfirst.target;\n   dsecond.op1 = dfirst.target;\n+  dsecond.one_operand_p = true;\n   dsecond.target = gen_reg_rtx (dsecond.vmode);\n   for (i = 0; i < nelt; i++)\n     dsecond.perm[i] = i ^ nelt2;\n@@ -37009,7 +37011,7 @@ expand_vec_perm_pshufb2 (struct expand_vec_perm_d *d)\n \n   if (!TARGET_SSSE3 || GET_MODE_SIZE (d->vmode) != 16)\n     return false;\n-  gcc_assert (d->op0 != d->op1);\n+  gcc_assert (!d->one_operand_p);\n \n   nelt = d->nelt;\n   eltsz = GET_MODE_SIZE (GET_MODE_INNER (d->vmode));\n@@ -37064,7 +37066,7 @@ expand_vec_perm_vpshufb2_vpermq (struct expand_vec_perm_d *d)\n   unsigned int i, nelt, eltsz;\n \n   if (!TARGET_AVX2\n-      || d->op0 != d->op1\n+      || !d->one_operand_p\n       || (d->vmode != V32QImode && d->vmode != V16HImode))\n     return false;\n \n@@ -37132,7 +37134,7 @@ expand_vec_perm_vpshufb2_vpermq_even_odd (struct expand_vec_perm_d *d)\n   unsigned int i, nelt, eltsz;\n \n   if (!TARGET_AVX2\n-      || d->op0 == d->op1\n+      || d->one_operand_p\n       || (d->vmode != V32QImode && d->vmode != V16HImode))\n     return false;\n \n@@ -37491,7 +37493,7 @@ expand_vec_perm_broadcast (struct expand_vec_perm_d *d)\n {\n   unsigned i, elt, nelt = d->nelt;\n \n-  if (d->op0 != d->op1)\n+  if (!d->one_operand_p)\n     return false;\n \n   elt = d->perm[0];\n@@ -37514,7 +37516,7 @@ expand_vec_perm_vpshufb4_vpermq2 (struct expand_vec_perm_d *d)\n   bool used[4];\n \n   if (!TARGET_AVX2\n-      || d->op0 == d->op1\n+      || d->one_operand_p\n       || (d->vmode != V32QImode && d->vmode != V16HImode))\n     return false;\n \n@@ -37715,58 +37717,47 @@ ix86_expand_vec_perm_const (rtx operands[4])\n       perm[i] = ei;\n     }\n \n+  d.one_operand_p = true;\n   switch (which)\n     {\n     default:\n       gcc_unreachable();\n \n     case 3:\n       if (!rtx_equal_p (d.op0, d.op1))\n-\tbreak;\n-\n+        {\n+\t  d.one_operand_p = false;\n+\t  break;\n+        }\n       /* The elements of PERM do not suggest that only the first operand\n \t is used, but both operands are identical.  Allow easier matching\n \t of the permutation by folding the permutation into the single\n \t input vector.  */\n-      for (i = 0; i < nelt; ++i)\n-\tif (d.perm[i] >= nelt)\n-\t  d.perm[i] -= nelt;\n       /* FALLTHRU */\n \n-    case 1:\n-      d.op1 = d.op0;\n-      break;\n-\n     case 2:\n       for (i = 0; i < nelt; ++i)\n-        d.perm[i] -= nelt;\n+        d.perm[i] &= nelt - 1;\n       d.op0 = d.op1;\n       break;\n+\n+    case 1:\n+      d.op1 = d.op0;\n+      break;\n     }\n \n   if (ix86_expand_vec_perm_const_1 (&d))\n     return true;\n \n-  /* If the mask says both arguments are needed, but they are the same,\n-     the above tried to expand with d.op0 == d.op1.  If that didn't work,\n-     retry with d.op0 != d.op1 as that is what testing has been done with.  */\n-  if (which == 3 && d.op0 == d.op1)\n+  /* If the selector says both arguments are needed, but the operands are the\n+     same, the above tried to expand with one_operand_p and flattened selector.\n+     If that didn't work, retry without one_operand_p; we succeeded with that\n+     during testing.  */\n+  if (which == 3 && d.one_operand_p)\n     {\n-      rtx seq;\n-      bool ok;\n-\n+      d.one_operand_p = false;\n       memcpy (d.perm, perm, sizeof (perm));\n-      d.op1 = gen_reg_rtx (d.vmode);\n-      start_sequence ();\n-      ok = ix86_expand_vec_perm_const_1 (&d);\n-      seq = get_insns ();\n-      end_sequence ();\n-      if (ok)\n-\t{\n-\t  emit_move_insn (d.op1, d.op0);\n-\t  emit_insn (seq);\n-\t  return true;\n-\t}\n+      return ix86_expand_vec_perm_const_1 (&d);\n     }\n \n   return false;\n@@ -37780,7 +37771,7 @@ ix86_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n {\n   struct expand_vec_perm_d d;\n   unsigned int i, nelt, which;\n-  bool ret, one_vec;\n+  bool ret;\n \n   d.vmode = vmode;\n   d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n@@ -37817,17 +37808,17 @@ ix86_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n       d.perm[i] -= nelt;\n \n   /* Check whether the mask can be applied to the vector type.  */\n-  one_vec = (which != 3);\n+  d.one_operand_p = (which != 3);\n \n   /* Implementable with shufps or pshufd.  */\n-  if (one_vec && (d.vmode == V4SFmode || d.vmode == V4SImode))\n+  if (d.one_operand_p && (d.vmode == V4SFmode || d.vmode == V4SImode))\n     return true;\n \n   /* Otherwise we have to go through the motions and see if we can\n      figure out how to generate the requested permutation.  */\n   d.target = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 1);\n   d.op1 = d.op0 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 2);\n-  if (!one_vec)\n+  if (!d.one_operand_p)\n     d.op1 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 3);\n \n   start_sequence ();\n@@ -37848,6 +37839,7 @@ ix86_expand_vec_extract_even_odd (rtx targ, rtx op0, rtx op1, unsigned odd)\n   d.op1 = op1;\n   d.vmode = GET_MODE (targ);\n   d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n+  d.one_operand_p = false;\n   d.testing_p = false;\n \n   for (i = 0; i < nelt; ++i)"}]}