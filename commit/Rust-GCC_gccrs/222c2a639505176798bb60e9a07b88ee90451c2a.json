{"sha": "222c2a639505176798bb60e9a07b88ee90451c2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIyYzJhNjM5NTA1MTc2Nzk4YmI2MGU5YTA3Yjg4ZWU5MDQ1MWMyYQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2011-05-14T09:48:08Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2011-05-14T09:48:08Z"}, "message": "re PR fortran/22572 (Double occurrence of matmul intrinsic not optimised)\n\n2011-05-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/22572\n\t* frontend-passes.c (cfe_register_funcs):  Also register functions\n\tfor potential elimination if the rank is > 0, the shape is unknown\n\tand reallocate on assignment is active.\n\t(create_var):  For rank > 0 functions with unknown shape, create\n\tan allocatable temporary.\n\n2011-05-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/22572\n\t* function_optimize_7.f90:  New test case.\n\nFrom-SVN: r173752", "tree": {"sha": "6e170974fca6afa5c0b90e0f2ef27c5b8f974282", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e170974fca6afa5c0b90e0f2ef27c5b8f974282"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/222c2a639505176798bb60e9a07b88ee90451c2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/222c2a639505176798bb60e9a07b88ee90451c2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/222c2a639505176798bb60e9a07b88ee90451c2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/222c2a639505176798bb60e9a07b88ee90451c2a/comments", "author": null, "committer": null, "parents": [{"sha": "2d8c9ad5c96e9a66b11deedb894822143202392e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d8c9ad5c96e9a66b11deedb894822143202392e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d8c9ad5c96e9a66b11deedb894822143202392e"}], "stats": {"total": 112, "additions": 94, "deletions": 18}, "files": [{"sha": "8e2ec731c81f525ff2f328a68cb6a3e0a6d3a6e9", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/222c2a639505176798bb60e9a07b88ee90451c2a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/222c2a639505176798bb60e9a07b88ee90451c2a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=222c2a639505176798bb60e9a07b88ee90451c2a", "patch": "@@ -1,3 +1,12 @@\n+2011-05-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/22572\n+\t* frontend-passes.c (cfe_register_funcs):  Also register functions\n+\tfor potential elimination if the rank is > 0, the shape is unknown\n+\tand reallocate on assignment is active.\n+\t(create_var):  For rank > 0 functions with unknown shape, create\n+\tan allocatable temporary.\n+\n 2011-05-14  Tobias Burnus  <burnus@net-b.de>\n \n \t* options.c (gfc_init_options, gfc_post_options): Enable"}, {"sha": "186cbb433042e3c717b77d45b4c03e1a6d7e8c9d", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/222c2a639505176798bb60e9a07b88ee90451c2a/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/222c2a639505176798bb60e9a07b88ee90451c2a/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=222c2a639505176798bb60e9a07b88ee90451c2a", "patch": "@@ -152,11 +152,11 @@ cfe_register_funcs (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n   if ((*e)->ts.type == BT_CHARACTER)\n     return 0;\n \n-  /* If we don't know the shape at compile time, we do not create a temporary\n-     variable to hold the intermediate result.  FIXME: Change this later when\n-     allocation on assignment works for intrinsics.  */\n+  /* If we don't know the shape at compile time, we create an allocatable\n+     temporary variable to hold the intermediate result, but only if\n+     allocation on assignment is active.  */\n \n-  if ((*e)->rank > 0 && (*e)->shape == NULL)\n+  if ((*e)->rank > 0 && (*e)->shape == NULL && !gfc_option.flag_realloc_lhs)\n     return 0;\n   \n   /* Skip the test for pure functions if -faggressive-function-elimination\n@@ -250,22 +250,38 @@ create_var (gfc_expr * e)\n \n   symbol = symtree->n.sym;\n   symbol->ts = e->ts;\n-  symbol->as = gfc_get_array_spec ();\n-  symbol->as->rank = e->rank;\n-  symbol->as->type = AS_EXPLICIT;\n-  for (i=0; i<e->rank; i++)\n+\n+  if (e->rank > 0)\n     {\n-      gfc_expr *p, *q;\n+      symbol->as = gfc_get_array_spec ();\n+      symbol->as->rank = e->rank;\n+\n+      if (e->shape == NULL)\n+\t{\n+\t  /* We don't know the shape at compile time, so we use an\n+\t     allocatable. */\n+\t  symbol->as->type = AS_DEFERRED;\n+\t  symbol->attr.allocatable = 1;\n+\t}\n+      else\n+\t{\n+\t  symbol->as->type = AS_EXPLICIT;\n+\t  /* Copy the shape.  */\n+\t  for (i=0; i<e->rank; i++)\n+\t    {\n+\t      gfc_expr *p, *q;\n       \n-      p = gfc_get_constant_expr (BT_INTEGER, gfc_default_integer_kind,\n-\t\t\t\t &(e->where));\n-      mpz_set_si (p->value.integer, 1);\n-      symbol->as->lower[i] = p;\n-\t  \n-      q = gfc_get_constant_expr (BT_INTEGER, gfc_index_integer_kind,\n-\t\t\t\t &(e->where));\n-      mpz_set (q->value.integer, e->shape[i]);\n-      symbol->as->upper[i] = q;\n+\t      p = gfc_get_constant_expr (BT_INTEGER, gfc_default_integer_kind,\n+\t\t\t\t\t &(e->where));\n+\t      mpz_set_si (p->value.integer, 1);\n+\t      symbol->as->lower[i] = p;\n+\t      \n+\t      q = gfc_get_constant_expr (BT_INTEGER, gfc_index_integer_kind,\n+\t\t\t\t\t &(e->where));\n+\t      mpz_set (q->value.integer, e->shape[i]);\n+\t      symbol->as->upper[i] = q;\n+\t    }\n+\t}\n     }\n \n   symbol->attr.flavor = FL_VARIABLE;"}, {"sha": "6cbf8829f9533d562e7ca7d444da4e0d7b6c697d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/222c2a639505176798bb60e9a07b88ee90451c2a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/222c2a639505176798bb60e9a07b88ee90451c2a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=222c2a639505176798bb60e9a07b88ee90451c2a", "patch": "@@ -1,3 +1,8 @@\n+2011-05-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/22572\n+\t* function_optimize_7.f90:  New test case.\n+\n 2011-05-13  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/decltype26.C: New."}, {"sha": "212c8fbd491f6b830e16005d80c346b0ce81050e", "filename": "gcc/testsuite/gfortran.dg/function_optimize_7.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/222c2a639505176798bb60e9a07b88ee90451c2a/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/222c2a639505176798bb60e9a07b88ee90451c2a/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_7.f90?ref=222c2a639505176798bb60e9a07b88ee90451c2a", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do compile }\n+! { dg-options \"-O -fdump-tree-original -Warray-temporaries\" }\n+subroutine xx(n, m, a, b, c, d, x, z, i, s_in, s_out)\n+  implicit none\n+  integer, intent(in) :: n, m\n+  real, intent(in), dimension(n,n) :: a, b, c\n+  real, intent(out), dimension(n,n) :: d\n+  real, intent(in), dimension(n,m) :: s_in\n+  real, intent(out), dimension(m) :: s_out\n+  integer, intent(out) :: i\n+  real, intent(inout) :: x\n+  real, intent(out) :: z\n+  character(60) :: line\n+  real, external :: ext_func\n+  interface\n+     elemental function element(x)\n+       real, intent(in) :: x\n+       real :: elem\n+     end function element\n+     pure function mypure(x)\n+       real, intent(in) :: x\n+       integer :: mypure\n+     end function mypure\n+     elemental impure function elem_impure(x)\n+       real, intent(in) :: x\n+       real :: elem_impure\n+     end function elem_impure\n+  end interface\n+\n+  d = matmul(a,b) + matmul(a,b)    ! { dg-warning \"Creating array temporary\" }\n+  z = sin(x) + cos(x) + sin(x) + cos(x)\n+  x = ext_func(a) + 23 + ext_func(a)\n+  z = element(x) + element(x)\n+  i = mypure(x) - mypure(x)\n+  z = elem_impure(x) - elem_impure(x)\n+  s_out = sum(s_in,1) + 3.14 / sum(s_in,1) ! { dg-warning \"Creating array temporary\" }\n+end subroutine xx\n+! { dg-final { scan-tree-dump-times \"matmul_r4\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_sinf\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_cosf\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"ext_func\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"element\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"mypure\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"elem_impure\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sum_r4\" 1 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}