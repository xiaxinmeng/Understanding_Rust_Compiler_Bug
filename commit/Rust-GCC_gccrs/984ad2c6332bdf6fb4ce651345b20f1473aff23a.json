{"sha": "984ad2c6332bdf6fb4ce651345b20f1473aff23a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg0YWQyYzYzMzJiZGY2ZmI0Y2U2NTEzNDViMjBmMTQ3M2FmZjIzYQ==", "commit": {"author": {"name": "Per Bothner", "email": "per@bothner.com", "date": "2001-01-14T21:48:10Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2001-01-14T21:48:10Z"}, "message": "Various patches to emit better messages on verification errors.\n\nFrom-SVN: r39019", "tree": {"sha": "b22806b6cbd1c6c8c4d9c0c81a071e2ded927cba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b22806b6cbd1c6c8c4d9c0c81a071e2ded927cba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/984ad2c6332bdf6fb4ce651345b20f1473aff23a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/984ad2c6332bdf6fb4ce651345b20f1473aff23a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/984ad2c6332bdf6fb4ce651345b20f1473aff23a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/984ad2c6332bdf6fb4ce651345b20f1473aff23a/comments", "author": {"login": "PerBothner", "id": 10293361, "node_id": "MDQ6VXNlcjEwMjkzMzYx", "avatar_url": "https://avatars.githubusercontent.com/u/10293361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PerBothner", "html_url": "https://github.com/PerBothner", "followers_url": "https://api.github.com/users/PerBothner/followers", "following_url": "https://api.github.com/users/PerBothner/following{/other_user}", "gists_url": "https://api.github.com/users/PerBothner/gists{/gist_id}", "starred_url": "https://api.github.com/users/PerBothner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PerBothner/subscriptions", "organizations_url": "https://api.github.com/users/PerBothner/orgs", "repos_url": "https://api.github.com/users/PerBothner/repos", "events_url": "https://api.github.com/users/PerBothner/events{/privacy}", "received_events_url": "https://api.github.com/users/PerBothner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "150d3c00862d07be7a48aa7a8aec1087426d9f04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/150d3c00862d07be7a48aa7a8aec1087426d9f04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/150d3c00862d07be7a48aa7a8aec1087426d9f04"}], "stats": {"total": 249, "additions": 171, "deletions": 78}, "files": [{"sha": "538d4b1cc34fa71ea9f8fe44f1bf2d27f6761724", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/984ad2c6332bdf6fb4ce651345b20f1473aff23a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/984ad2c6332bdf6fb4ce651345b20f1473aff23a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=984ad2c6332bdf6fb4ce651345b20f1473aff23a", "patch": "@@ -1,5 +1,20 @@\n 2001-01-14  Per Bothner  <per@bothner.com>\n \n+\tVarious patches to emit better messages on verification errors.\n+\t* expr.c (push_type_0):  Return error indication on stack overflow,\n+\tinstead of callinfg fatal.\n+\t(push_type):  Now just call push_type_0 (nd fatal on overflow).\n+\t(pop_type_0):  Return detailed error message (in a char** argument).\n+\t(pop_type):  If pop_type_0 fails, print error message.\n+\t(pop_argument_types):  Moved to verify.c.\n+\t* verify.c (pop_argument_types):  Moved from expr.c.\n+\tReturn a (possible) error message, rather than void.\n+\t(POP_TYPE, POP_TYPE_CONV, PUSH_TYPE, PUSH_PENDING):  New macros.\n+\t(verify_jvm_instruction):  Use new macros, improving error messages.\n+\tFor case OPCODE_astore use object_ptr_type_node.\n+\t* java-tree.h (TYPE_UNDERFLOW, TYPE_UNEXPECTED):  New macros.\n+\t(pop_type_0, push_type_0, pop_argument_types):  Update accordingly.\n+\n \t* parse.y (java_complete_lhs case EXPR_WITH_FILE_LOCATION): If body is\n \tconstant, return body without wrapper.  (Improves constant folding.)\n \t* lex.c (build_wfl_node):  Clear TREE_TYPE from returned node."}, {"sha": "abc5f69103fffb4fb45b83ec93b1837f1663ae33", "filename": "gcc/java/expr.c", "status": "modified", "additions": 53, "deletions": 29, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/984ad2c6332bdf6fb4ce651345b20f1473aff23a/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/984ad2c6332bdf6fb4ce651345b20f1473aff23a/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=984ad2c6332bdf6fb4ce651345b20f1473aff23a", "patch": "@@ -256,19 +256,31 @@ flush_quick_stack ()\n     }\n }\n \n-void\n-push_type (type)\n+/* Push TYPE on the type stack.\n+   Return true on success, 0 on overflow. */\n+\n+int\n+push_type_0 (type)\n      tree type;\n {\n   int n_words;\n   type = promote_type (type);\n   n_words = 1 + TYPE_IS_WIDE (type);\n   if (stack_pointer + n_words > DECL_MAX_STACK (current_function_decl))\n-    fatal (\"stack overflow\");\n+    return 0;\n   stack_type_map[stack_pointer++] = type;\n   n_words--;\n   while (--n_words >= 0)\n     stack_type_map[stack_pointer++] = TYPE_SECOND;\n+  return 1;\n+}\n+\n+void\n+push_type (type)\n+     tree type;\n+{\n+  if (! push_type_0 (type))\n+    fatal (\"stack overflow\");\n }\n \n static void\n@@ -296,23 +308,32 @@ push_value (value)\n \n /* Pop a type from the type stack.\n    TYPE is the expected type.   Return the actual type, which must be\n-   convertible to TYPE, otherwise NULL_TREE is returned. */\n+   convertible to TYPE.\n+   On an error, *MESSAGEP is set to a freshly malloc'd error message. */\n \n tree\n-pop_type_0 (type)\n+pop_type_0 (type, messagep)\n      tree type;\n+     char **messagep;\n {\n   int n_words;\n   tree t;\n+  *messagep = NULL;\n   if (TREE_CODE (type) == RECORD_TYPE)\n     type = promote_type (type);\n   n_words = 1 + TYPE_IS_WIDE (type);\n   if (stack_pointer < n_words)\n-    fatal (\"stack underflow\");\n+    {\n+      *messagep = xstrdup (\"stack underflow\");\n+      return type;\n+    }\n   while (--n_words > 0)\n     {\n       if (stack_type_map[--stack_pointer] != void_type_node)\n-\tfatal (\"Invalid multi-word value on type stack\");\n+\t{\n+\t  *messagep = xstrdup (\"Invalid multi-word value on type stack\");\n+\t  return type;\n+\t}\n     }\n   t = stack_type_map[--stack_pointer];\n   if (type == NULL_TREE || t == type)\n@@ -334,7 +355,24 @@ pop_type_0 (type)\n       /* FIXME: this is worse than a kludge, probably.  */\n       return object_ptr_type_node;\n     }\n-  return NULL_TREE;\n+  {\n+    const char *str1 = \"expected type '\";\n+    const char *str3 = \"' but stack contains '\";\n+    const char *str5 = \"'\";\n+    int len1 = strlen (str1);\n+    int len2 = strlen (lang_printable_name (type, 0));\n+    int len3 = strlen (str3);\n+    int len4 = strlen (lang_printable_name (t, 0));\n+    int len5 = strlen (str5);\n+    char *msg = xmalloc (len1 + len2 + len3 + len4 + len5 + 1);\n+    *messagep = msg;\n+    strcpy (msg, str1);  msg += len1;\n+    strcpy (msg, lang_printable_name (type, 0));  msg += len2;\n+    strcpy (msg, str3);  msg += len3;\n+    strcpy (msg, lang_printable_name (t, 0));  msg += len4;\n+    strcpy (msg, str5);\n+    return type;\n+  }\n }\n \n /* Pop a type from the type stack.\n@@ -345,10 +383,13 @@ tree\n pop_type (type)\n      tree type;\n {\n-  tree t = pop_type_0 (type);\n-  if (t != NULL_TREE)\n-    return t;\n-  error (\"unexpected type on stack\");\n+  char *message = NULL;\n+  type = pop_type_0 (type, &message);\n+  if (message != NULL)\n+    {\n+      error (message);\n+      free (message);\n+    }\n   return type;\n }\n \n@@ -1576,23 +1617,6 @@ expand_java_ret (return_address)\n }\n #endif\n \n-/* Recursive helper function to pop argument types during verifiation. */\n-\n-void\n-pop_argument_types (arg_types)\n-     tree arg_types;\n-{\n-  if (arg_types == end_params_node)\n-    return;\n-  if (TREE_CODE (arg_types) == TREE_LIST)\n-    {\n-      pop_argument_types (TREE_CHAIN (arg_types));\n-      pop_type (TREE_VALUE (arg_types));\n-      return;\n-    }\n-  abort ();\n-}\n-\n static tree\n pop_arguments (arg_types)\n      tree arg_types;"}, {"sha": "3d0793d4d587933d61dc8f2f6d84bfa6884953cd", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/984ad2c6332bdf6fb4ce651345b20f1473aff23a/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/984ad2c6332bdf6fb4ce651345b20f1473aff23a/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=984ad2c6332bdf6fb4ce651345b20f1473aff23a", "patch": "@@ -978,9 +978,8 @@ extern tree build_java_array_type PARAMS ((tree, HOST_WIDE_INT));\n extern int is_compiled_class PARAMS ((tree));\n extern tree mangled_classname PARAMS ((const char*, tree));\n extern tree lookup_label PARAMS ((int));\n-extern tree pop_type_0 PARAMS ((tree));\n+extern tree pop_type_0 PARAMS ((tree, char**));\n extern tree pop_type PARAMS ((tree));\n-extern void pop_argument_types PARAMS ((tree));\n extern tree decode_newarray_type PARAMS ((int));\n extern tree lookup_field PARAMS ((tree*, tree));\n extern int is_array_type_p PARAMS ((tree));\n@@ -1057,6 +1056,7 @@ extern int process_jvm_instruction PARAMS ((int, const unsigned char *, long));\n extern int maybe_adjust_start_pc PARAMS ((struct JCF *, int, int, int));\n extern void set_local_type PARAMS ((int, tree));\n extern int merge_type_state PARAMS ((tree));\n+extern int push_type_0 PARAMS ((tree));\n extern void push_type PARAMS ((tree));\n extern void load_type_state PARAMS ((tree));\n extern void add_interface PARAMS ((tree, tree));\n@@ -1244,6 +1244,12 @@ extern int linenumber_count;\n    used nor set in the subroutine. */\n #define TYPE_UNUSED error_mark_node\n \n+/* When returned from pop_type_0, indicates stack underflow. */\n+#define TYPE_UNDERFLOW integer_zero_node\n+\n+/* When returned from pop_type_0, indicates a type mismatch. */\n+#define TYPE_UNEXPECTED NULL_TREE\n+\n /* A array mapping variable/stack slot index to the type current\n    in that variable/stack slot.\n    TYPE_UNKNOWN, TYPE_SECOND, and TYPE_NULL are special cases. */"}, {"sha": "23b30887e514c78eb8ab182f36a3f748f7779cce", "filename": "gcc/java/verify.c", "status": "modified", "additions": 95, "deletions": 47, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/984ad2c6332bdf6fb4ce651345b20f1473aff23a/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/984ad2c6332bdf6fb4ce651345b20f1473aff23a/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=984ad2c6332bdf6fb4ce651345b20f1473aff23a", "patch": "@@ -348,9 +348,43 @@ start_pc_cmp (xp, yp)\n #define VERIFICATION_ERROR(MESSAGE) \\\n   do { message = MESSAGE;  goto verify_error; } while (0)\n \n+/* Recursive helper function to pop argument types during verifiation.\n+   ARG_TYPES is the list of formal parameter types.\n+   Return NULL on success and a freshly malloc'd error message on failure. */\n+\n+static char *\n+pop_argument_types (arg_types)\n+     tree arg_types;\n+{\n+  if (arg_types == end_params_node)\n+    return NULL;\n+  if (TREE_CODE (arg_types) == TREE_LIST)\n+    {\n+      char *message = pop_argument_types (TREE_CHAIN (arg_types));\n+      if (message == NULL)\n+\tpop_type_0 (TREE_VALUE (arg_types), &message);\n+      return message;\n+    }\n+  abort ();\n+}\n+\n+#define POP_TYPE(TYPE, MESSAGE) \\\n+  do { pmessage = NULL;  pop_type_0 (TYPE, &pmessage); \\\n+       if (pmessage != NULL) goto pop_type_error; \\\n+  } while (0)\n+\n+#define POP_TYPE_CONV(TYPE, POPPED_TYPE, MESSAGE) \\\n+  do { pmessage = NULL;  POPPED_TYPE = pop_type_0 (TYPE, &pmessage); \\\n+       if (pmessage != NULL) goto pop_type_error; \\\n+  } while (0)\n+\n+#define PUSH_TYPE(TYPE) \\\n+  do { if (! push_type_0 (TYPE)) { goto stack_overflow; }} while (0)\n+\n #define PUSH_PENDING(LABEL) \\\n-     do { if ((message = check_pending_block (LABEL)) != NULL) \\\n-             goto verify_error; } while (0)\n+     do { tree tmplab = LABEL; \\\n+          if ((message = check_pending_block (tmplab)) != NULL) \\\n+            { oldpc = LABEL_PC (tmplab); goto verify_error; }} while (0)\n \n #ifdef __GNUC__\n #define CHECK_PC_IN_RANGE(PC) ({if (PC < 0 || PC > length) goto bad_pc; (void)1;})\n@@ -376,6 +410,7 @@ verify_jvm_instructions (jcf, byte_ops, length)\n   int oldpc = 0; /* PC of start of instruction. */\n   int prevpc = 0;  /* If >= 0, PC of previous instruction. */\n   const char *message;\n+  char *pmessage;\n   int i;\n   register unsigned char *p;\n   struct eh_range *prev_eh_ranges = NULL_EH_RANGE;\n@@ -559,13 +594,13 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t  if (byte_ops[PC] == OPCODE_newarray\n \t      || byte_ops[PC] == OPCODE_newarray)\n \t    int_value = i;\n-\t  push_type (int_type_node);  break;\n+\t  PUSH_TYPE (int_type_node);  break;\n \tcase OPCODE_lconst_0:\tcase OPCODE_lconst_1:\n-\t  push_type (long_type_node);  break;\n+\t  PUSH_TYPE (long_type_node);  break;\n \tcase OPCODE_fconst_0:\tcase OPCODE_fconst_1:\tcase OPCODE_fconst_2:\n-\t  push_type (float_type_node);  break;\n+\t  PUSH_TYPE (float_type_node);  break;\n \tcase OPCODE_dconst_0:\tcase OPCODE_dconst_1:\n-\t  push_type (double_type_node);  break;\n+\t  PUSH_TYPE (double_type_node);  break;\n \tcase OPCODE_bipush:\n \t  i = IMMEDIATE_s1;\n \t  goto push_int;\n@@ -616,13 +651,13 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t\t? (! INTEGRAL_TYPE_P (tmp) || TYPE_PRECISION (tmp) > 32)\n \t\t: type != tmp))\n \t  VERIFICATION_ERROR(\"invalid local variable type in load\");\n-\tpush_type (tmp);\n+\tPUSH_TYPE (tmp);\n \tgoto note_used;\n \tcase OPCODE_istore:  type = int_type_node;  goto general_store;\n \tcase OPCODE_lstore:  type = long_type_node;  goto general_store;\n \tcase OPCODE_fstore:  type = float_type_node;  goto general_store;\n \tcase OPCODE_dstore:  type = double_type_node;  goto general_store;\n-\tcase OPCODE_astore:  type = ptr_type_node;  goto general_store;\n+\tcase OPCODE_astore:  type = object_ptr_type_node;  goto general_store;\n \tgeneral_store:\n \tindex = wide ? IMMEDIATE_u2 : IMMEDIATE_u1;\n \twide = 0;\n@@ -655,7 +690,7 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t    VERIFICATION_ERROR (\"invalid local variable index in store\");\n \t    return 0;\n \t  }\n-\ttype = pop_type (type);\n+\tPOP_TYPE_CONV (type, type, NULL);\n \ttype_map[index] = type;\n \n \t/* If local variable changed, we need to reconsider eh handlers. */\n@@ -723,19 +758,19 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t  type = double_type_node;  goto unop;\n \tunop:\n \t  pop_type (type);\n-\t  push_type (type);\n+\t  PUSH_TYPE (type);\n \t  break;\n \tbinop:\n \t  pop_type (type);\n \t  pop_type (type);\n-\t  push_type (type);\n+\t  PUSH_TYPE (type);\n \t  break;\n \tcase OPCODE_lshl:\n \tcase OPCODE_lshr:\n \tcase OPCODE_lushr:\n \t  pop_type (int_type_node);\n \t  pop_type (long_type_node);\n-\t  push_type (long_type_node);\n+\t  PUSH_TYPE (long_type_node);\n \t  break;\n \tcase OPCODE_iinc:\n \t  index = wide ? IMMEDIATE_u2 : IMMEDIATE_u1;\n@@ -744,33 +779,34 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t  if (index < 0 || index >= DECL_MAX_LOCALS (current_function_decl))\n \t    VERIFICATION_ERROR (\"invalid local variable index in iinc\");\n \t  tmp = type_map[index];\n-\t  if (! INTEGRAL_TYPE_P (tmp) || TYPE_PRECISION (tmp) > 32)\n+\t  if (tmp == NULL_TREE\n+\t      || ! INTEGRAL_TYPE_P (tmp) || TYPE_PRECISION (tmp) > 32)\n \t    VERIFICATION_ERROR (\"invalid local variable type in iinc\");\n \t  break;\n \tcase OPCODE_i2l:\n-\t  pop_type (int_type_node);    push_type (long_type_node);   break;\n+\t  pop_type (int_type_node);    PUSH_TYPE (long_type_node);   break;\n \tcase OPCODE_i2f:\n-\t  pop_type (int_type_node);    push_type (float_type_node);  break;\n+\t  pop_type (int_type_node);    PUSH_TYPE (float_type_node);  break;\n \tcase OPCODE_i2d:\n-\t  pop_type (int_type_node);    push_type (double_type_node); break;\n+\t  pop_type (int_type_node);    PUSH_TYPE (double_type_node); break;\n \tcase OPCODE_l2i:\n-\t  pop_type (long_type_node);   push_type (int_type_node);    break;\n+\t  pop_type (long_type_node);   PUSH_TYPE (int_type_node);    break;\n \tcase OPCODE_l2f:\n-\t  pop_type (long_type_node);   push_type (float_type_node);  break;\n+\t  pop_type (long_type_node);   PUSH_TYPE (float_type_node);  break;\n \tcase OPCODE_l2d:\n-\t  pop_type (long_type_node);   push_type (double_type_node); break;\n+\t  pop_type (long_type_node);   PUSH_TYPE (double_type_node); break;\n \tcase OPCODE_f2i:\n-\t  pop_type (float_type_node);  push_type (int_type_node);    break;\n+\t  pop_type (float_type_node);  PUSH_TYPE (int_type_node);    break;\n \tcase OPCODE_f2l:\n-\t  pop_type (float_type_node);  push_type (long_type_node);   break;\n+\t  pop_type (float_type_node);  PUSH_TYPE (long_type_node);   break;\n \tcase OPCODE_f2d:\n-\t  pop_type (float_type_node);  push_type (double_type_node); break;\n+\t  pop_type (float_type_node);  PUSH_TYPE (double_type_node); break;\n \tcase OPCODE_d2i:\n-\t  pop_type (double_type_node); push_type (int_type_node);    break;\n+\t  pop_type (double_type_node); PUSH_TYPE (int_type_node);    break;\n \tcase OPCODE_d2l:\n-\t  pop_type (double_type_node); push_type (long_type_node);   break;\n+\t  pop_type (double_type_node); PUSH_TYPE (long_type_node);   break;\n \tcase OPCODE_d2f:\n-\t  pop_type (double_type_node); push_type (float_type_node);  break;\n+\t  pop_type (double_type_node); PUSH_TYPE (float_type_node);  break;\n \tcase OPCODE_lcmp:\n \t  type = long_type_node;  goto compare;\n \tcase OPCODE_fcmpl:\n@@ -781,7 +817,7 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t  type = double_type_node;  goto compare;\n \tcompare:\n \t  pop_type (type);  pop_type (type);\n-\t  push_type (int_type_node);  break;\n+\t  PUSH_TYPE (int_type_node);  break;\n \tcase OPCODE_ifeq:\n \tcase OPCODE_ifne:\n \tcase OPCODE_iflt:\n@@ -848,10 +884,7 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t  if (type != return_type)\n \t    VERIFICATION_ERROR (\"incorrect ?return opcode\");\n \t  if (type != void_type_node)\n-\t    {\n-\t      if (pop_type_0 (type) == NULL_TREE)\n-\t\tVERIFICATION_ERROR (\"return value has wrong type\");\n-\t    }\n+\t    POP_TYPE(type, \"return value has wrong type\");\n \t  INVALIDATE_PC;\n \t  break;\n \tcase OPCODE_getstatic: is_putting = 0;  is_static = 1;  goto field;\n@@ -864,22 +897,21 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t    tree field_signature = COMPONENT_REF_SIGNATURE (&current_jcf->cpool, index);\n \t    tree field_type = get_type_from_signature (field_signature);\n \t    if (is_putting)\n-\t      pop_type (field_type);\n+\t      POP_TYPE (field_type, \"incorrect type for field\");\n \t    if (! is_static)\n \t      {\n \t\tint clindex = COMPONENT_REF_CLASS_INDEX (&current_jcf->cpool,\n \t\t\t\t\t\t\tindex);\n \t\ttree self_type = get_class_constant (current_jcf, clindex);\n \t\t/* Defer actual checking until next pass. */\n-\t\tif (pop_type_0 (self_type) == NULL_TREE)\n-\t\t  VERIFICATION_ERROR (\"incorrect type for field reference\");\n+\t\tPOP_TYPE(self_type, \"incorrect type for field reference\");\n \t      }\n \t    if (! is_putting)\n-\t      push_type (field_type);\n+\t      PUSH_TYPE (field_type);\n \t    break;\n \t  }\n \tcase OPCODE_new:\n-\t  push_type (get_class_constant (jcf, IMMEDIATE_u2));\n+\t  PUSH_TYPE (get_class_constant (jcf, IMMEDIATE_u2));\n \t  break;\n \tcase OPCODE_dup:     type_stack_dup (1, 0);  break;\n \tcase OPCODE_dup_x1:  type_stack_dup (1, 1);  break;\n@@ -934,7 +966,7 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t      i = TREE_INT_CST_LOW (get_constant (current_jcf, index));\n \t      goto push_int;\n \t    }\n-\t  push_type (type);\n+\t  PUSH_TYPE (type);\n \t  break;\n \n \tcase OPCODE_invokevirtual:\n@@ -953,7 +985,12 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t\t\t\t\t\t  IDENTIFIER_LENGTH (sig));\n \t    if (TREE_CODE (method_type) != FUNCTION_TYPE)\n \t      VERIFICATION_ERROR (\"bad method signature\");\n-\t    pop_argument_types (TYPE_ARG_TYPES (method_type));\n+\t    pmessage = pop_argument_types (TYPE_ARG_TYPES (method_type));\n+\t    if (pmessage != NULL)\n+\t      {\n+\t\tmessage = \"invalid argument type\";\n+\t\tgoto pop_type_error;\n+\t      }\n \n \t    /* Can't invoke <clinit> */\n \t    if (ID_CLINIT_P (method_name))\n@@ -963,7 +1000,8 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t      VERIFICATION_ERROR (\"invoke opcode can't invoke <init>\");\n \n \t    if (op_code != OPCODE_invokestatic)\n-\t      pop_type (self_type);\n+\t      POP_TYPE (self_type,\n+\t\t\t\"stack type not subclass of invoked method's class\");\n \n \t    switch (op_code)\n \t      {\n@@ -980,14 +1018,14 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t      }\n \n \t    if (TREE_TYPE (method_type) != void_type_node)\n-\t      push_type (TREE_TYPE (method_type));\n+\t      PUSH_TYPE (TREE_TYPE (method_type));\n \t    break;\n \t  }\n \n \tcase OPCODE_arraylength:\n \t    /* Type checking actually made during code generation */\n \t    pop_type( ptr_type_node );\n-\t    push_type( int_type_node );\n+\t    PUSH_TYPE( int_type_node );\n \t    break;\n \t    \n         /* Q&D verification *or* more checking done during code generation\n@@ -1025,7 +1063,7 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t    type = TYPE_ARRAY_ELEMENT (TREE_TYPE (tmp));\n \t  else if (tmp != TYPE_NULL)\n \t    VERIFICATION_ERROR (\"array load from non-array type\");\n-\t  push_type (type);\n+\t  PUSH_TYPE (type);\n \t  break;\n \n \tcase OPCODE_anewarray:\n@@ -1061,7 +1099,7 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t    int_value = -1;\n \t  type = build_java_array_type (type, int_value);\n \t  pop_type (int_type_node);\n-\t  push_type (type);\n+\t  PUSH_TYPE (type);\n \t  break;\n \n \tcase OPCODE_multianewarray:\n@@ -1075,12 +1113,12 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \n \t    for( i = 0; i < ndim; i++ )\n \t      pop_type (int_type_node);\n-\t    push_type (get_class_constant (current_jcf, index));\n+\t    PUSH_TYPE (get_class_constant (current_jcf, index));\n \t    break;\n \t  }\n \n \tcase OPCODE_aconst_null:\n-\t  push_type (ptr_type_node);\n+\t  PUSH_TYPE (ptr_type_node);\n \t  break;\n \n \tcase OPCODE_athrow:\n@@ -1092,12 +1130,12 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \tcase OPCODE_checkcast:\n \t  pop_type (ptr_type_node);\n \t  type = get_class_constant (current_jcf, IMMEDIATE_u2);\n-\t  push_type (type);\n+\t  PUSH_TYPE (type);\n \t  break;\n \tcase OPCODE_instanceof:\n \t  pop_type (ptr_type_node);\n \t  get_class_constant (current_jcf, IMMEDIATE_u2);\n-\t  push_type (int_type_node);\n+\t  PUSH_TYPE (int_type_node);\n \t  break;\n \n \tcase OPCODE_tableswitch:\n@@ -1170,7 +1208,7 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t  {\n \t    tree target = lookup_label (oldpc + IMMEDIATE_s2);\n \t    tree return_label = lookup_label (PC);\n-\t    push_type (return_address_type_node);\n+\t    PUSH_TYPE (return_address_type_node);\n \t    /* The return label chain will be null if this is the first\n \t       time we've seen this jsr target.  */\n             if (LABEL_RETURN_LABEL (target) == NULL_TREE)\n@@ -1358,6 +1396,16 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t}\n     }\n   return 1;\n+ pop_type_error:\n+  error (\"verification error at PC=%d\", oldpc);\n+  if (message != NULL)\n+    error (\"%s\", message);\n+  error (\"%s\", pmessage);\n+  free (pmessage);\n+  return 0;\n+ stack_overflow:\n+  message = \"stack overflow\";\n+  goto verify_error;\n  bad_pc:\n   message = \"program counter out of range\";\n   goto verify_error;"}]}