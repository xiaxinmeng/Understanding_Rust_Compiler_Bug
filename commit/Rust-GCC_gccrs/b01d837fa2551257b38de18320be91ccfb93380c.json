{"sha": "b01d837fa2551257b38de18320be91ccfb93380c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjAxZDgzN2ZhMjU1MTI1N2IzOGRlMTgzMjBiZTkxY2NmYjkzMzgwYw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-09-17T09:14:12Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-09-17T09:14:12Z"}, "message": "basic-block.h, [...]: Fix comment typos.\n\n\t* basic-block.h, c-decl.c, c-parse.in, cgraphunit.c, ddg.c,\n\tgimplify.c, lambda-code.c, optabs.c, predict.c,\n\ttree-scalar-evolution.c, tree-sra.c, tree-ssa-loop-ch.c,\n\ttree-ssa.c, vec.h: Fix comment typos.  Follow spelling\n\tconventions.\n\nFrom-SVN: r87637", "tree": {"sha": "6f55e8ca1d5f6104ec983d20bd985efb5e4b87c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f55e8ca1d5f6104ec983d20bd985efb5e4b87c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b01d837fa2551257b38de18320be91ccfb93380c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b01d837fa2551257b38de18320be91ccfb93380c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b01d837fa2551257b38de18320be91ccfb93380c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b01d837fa2551257b38de18320be91ccfb93380c/comments", "author": null, "committer": null, "parents": [{"sha": "ee19761de757468f820e140b1364a07c304ffc32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee19761de757468f820e140b1364a07c304ffc32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee19761de757468f820e140b1364a07c304ffc32"}], "stats": {"total": 40, "additions": 24, "deletions": 16}, "files": [{"sha": "c3f265f1a731d6e2f8828eb8a148d07e1b6256f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b01d837fa2551257b38de18320be91ccfb93380c", "patch": "@@ -1,3 +1,11 @@\n+2004-09-17  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* basic-block.h, c-decl.c, c-parse.in, cgraphunit.c, ddg.c,\n+\tgimplify.c, lambda-code.c, optabs.c, predict.c,\n+\ttree-scalar-evolution.c, tree-sra.c, tree-ssa-loop-ch.c,\n+\ttree-ssa.c, vec.h: Fix comment typos.  Follow spelling\n+\tconventions.\n+\n 2004-09-17  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* doc/compat.texi, doc/cpp.texi, doc/cppopts.texi,"}, {"sha": "037f0ac4d47abe942a247978a17895a0a6f4d8aa", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=b01d837fa2551257b38de18320be91ccfb93380c", "patch": "@@ -167,7 +167,7 @@ typedef struct edge_def *edge;\n #define EDGE_SIBCALL\t\t256\t/* Edge from sibcall to exit.  */\n #define EDGE_LOOP_EXIT\t\t512\t/* Exit of a loop.  */\n #define EDGE_TRUE_VALUE\t\t1024\t/* Edge taken when controlling\n-\t\t\t\t\t   predicate is non zero.  */\n+\t\t\t\t\t   predicate is nonzero.  */\n #define EDGE_FALSE_VALUE\t2048\t/* Edge taken when controlling\n \t\t\t\t\t   predicate is zero.  */\n #define EDGE_EXECUTABLE\t\t4096\t/* Edge is executable.  Only"}, {"sha": "b29a152dacc3a06be595a767fd8aed4a778faf26", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=b01d837fa2551257b38de18320be91ccfb93380c", "patch": "@@ -6284,7 +6284,7 @@ store_parm_decls (void)\n   DECL_SAVED_TREE (fndecl) = push_stmt_list ();\n \n   /* ??? Insert the contents of the pending sizes list into the function\n-     to be evaluated.  This just changes mis-behaviour until assign_parms\n+     to be evaluated.  This just changes mis-behavior until assign_parms\n      phase ordering problems are resolved.  */\n   {\n     tree t;"}, {"sha": "20ed784f6f30b3cc551dbe538ff0ffba5e927aa0", "filename": "gcc/c-parse.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=b01d837fa2551257b38de18320be91ccfb93380c", "patch": "@@ -361,7 +361,7 @@ static inline int _yylex (void);\n static int  yylex (void);\n static void init_reswords (void);\n \n-  /* Initialisation routine for this file.  */\n+  /* Initialization routine for this file.  */\n void\n c_parse_init (void)\n {"}, {"sha": "4153504e38eb05cb3bee5ee865a9fc06608d254f", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=b01d837fa2551257b38de18320be91ccfb93380c", "patch": "@@ -142,7 +142,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n         ??? Move this to separate file after tree-ssa merge.\n \n \tWe separate inlining decisions from the inliner itself and store it\n-\tinside callgraph as so called inline plan.  Reffer to cgraph.c\n+\tinside callgraph as so called inline plan.  Refer to cgraph.c\n \tdocumentation about particular representation of inline plans in the\n \tcallgraph\n "}, {"sha": "15bfc3c67a82a9be730ec8fbb59e6ba007d475d1", "filename": "gcc/ddg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=b01d837fa2551257b38de18320be91ccfb93380c", "patch": "@@ -894,7 +894,7 @@ free_ddg_all_sccs (ddg_all_sccs_ptr all_sccs)\n \f\n /* Given FROM - a bitmap of source nodes - and TO - a bitmap of destination\n    nodes - find all nodes that lie on paths from FROM to TO (not excluding\n-   nodes from FROM and TO).  Return non zero if nodes exist.  */\n+   nodes from FROM and TO).  Return nonzero if nodes exist.  */\n int\n find_nodes_on_paths (sbitmap result, ddg_ptr g, sbitmap from, sbitmap to)\n {"}, {"sha": "523511818926c236e585d2603424fe29dfa6b2f9", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=b01d837fa2551257b38de18320be91ccfb93380c", "patch": "@@ -2363,7 +2363,7 @@ gimplify_init_ctor_preeval (tree *expr_p, tree *pre_p, tree *post_p,\n      the gimplifier will consider this a store to memory.  Doing this \n      gimplification now means that we won't have to deal with complicated\n      language-specific trees, nor trees like SAVE_EXPR that can induce\n-     exponential search behaviour.  */\n+     exponential search behavior.  */\n   one = gimplify_expr (expr_p, pre_p, post_p, is_gimple_mem_rhs, fb_rvalue);\n   if (one == GS_ERROR)\n     {"}, {"sha": "f780da57754d6dc12cac5e8dd3e2017bda02ee9c", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=b01d837fa2551257b38de18320be91ccfb93380c", "patch": "@@ -1932,7 +1932,7 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \n \n /* Returns true when the vector V is lexicographically positive, in\n-   other words, when the first non zero element is positive.  */\n+   other words, when the first nonzero element is positive.  */\n \n static bool\n lambda_vector_lexico_pos (lambda_vector v, "}, {"sha": "0b75a81cd7f548d93086bca0e014ec1a700599c7", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=b01d837fa2551257b38de18320be91ccfb93380c", "patch": "@@ -407,7 +407,7 @@ expand_subword_shift (enum machine_mode op1_mode, optab binoptab,\n     {\n       /* We must avoid shifting by BITS_PER_WORD bits since that is either\n \t the same as a zero shift (if shift_mask == BITS_PER_WORD - 1) or\n-\t has unknown behaviour.  Do a single shift first, then shift by the\n+\t has unknown behavior.  Do a single shift first, then shift by the\n \t remainder.  It's OK to use ~OP1 as the remainder if shift counts\n \t are truncated to the mode size.  */\n       carries = expand_binop (word_mode, reverse_unsigned_shift,"}, {"sha": "8a7f093f014daea0dcf5b6841270b69b8dbde6ee", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=b01d837fa2551257b38de18320be91ccfb93380c", "patch": "@@ -932,7 +932,7 @@ expr_expected_value (tree expr, bitmap visited)\n \n \t      /* If this PHI has itself as an argument, we cannot\n \t\t determine the string length of this argument.  However,\n-\t\t if we can find a expectd constant value for the other\n+\t\t if we can find a expected constant value for the other\n \t\t PHI args then we can still be sure that this is\n \t\t likely a constant.  So be optimistic and just\n \t\t continue with the next argument.  */"}, {"sha": "35d2fe9ca8b509f7bfcf41b34a37bd0ac4f8f303", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=b01d837fa2551257b38de18320be91ccfb93380c", "patch": "@@ -331,7 +331,7 @@ del_scev_info (void *e)\n \n /* Get the index corresponding to VAR in the current LOOP.  If\n    it's the first time we ask for this VAR, then we return\n-   chrec_not_analysed_yet for this VAR and return its index.  */\n+   chrec_not_analyzed_yet for this VAR and return its index.  */\n \n static tree *\n find_var_scev_info (tree var)"}, {"sha": "e54d7d158fa056da7d3c54a7ad0a292b7bfeb633", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=b01d837fa2551257b38de18320be91ccfb93380c", "patch": "@@ -132,7 +132,7 @@ struct sra_elt\n };\n \n /* Random access to the child of a parent is performed by hashing.\n-   This prevents quadratic behaviour, and allows SRA to function\n+   This prevents quadratic behavior, and allows SRA to function\n    reasonably on larger records.  */\n static htab_t sra_map;\n "}, {"sha": "4d25d0f5b31d4f2cd03e8e9f4b60b6a84752c14f", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=b01d837fa2551257b38de18320be91ccfb93380c", "patch": "@@ -40,7 +40,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* Duplicates headers of loops if they are small enough, so that the statements\n    in the loop body are always executed when the loop is entered.  This\n-   increases effectivity of code motion optimizations, and reduces the need\n+   increases effectiveness of code motion optimizations, and reduces the need\n    for loop preconditioning.  */\n \n /* Check whether we should duplicate HEADER of LOOP.  At most *LIMIT"}, {"sha": "3e9b2134f9a4edf7e05a64a36a2de008d2b2d962", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=b01d837fa2551257b38de18320be91ccfb93380c", "patch": "@@ -650,8 +650,8 @@ verify_ssa (void)\n   verify_alias_info ();\n \n   free (definition_block);\n-  /* Restore the dominance infomation to its prior known state, so\n-     that we do not perturb the compiler's subsequent behaviour.  */\n+  /* Restore the dominance information to its prior known state, so\n+     that we do not perturb the compiler's subsequent behavior.  */\n   if (orig_dom_state == DOM_NONE)\n     free_dominance_info (CDI_DOMINATORS);\n   else"}, {"sha": "3e272d40c4717ac88054de89cb94eb87f8e0b12d", "filename": "gcc/vec.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01d837fa2551257b38de18320be91ccfb93380c/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=b01d837fa2551257b38de18320be91ccfb93380c", "patch": "@@ -29,7 +29,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    out-of-line generic functions.  The vectors are designed to\n    interoperate with the GTY machinery.\n \n-   Because of the different behaviour of objects and of pointers to\n+   Because of the different behavior of objects and of pointers to\n    objects, there are two flavors.  One to deal with a vector of\n    pointers to objects, and one to deal with a vector of objects\n    themselves.  Both of these pass pointers to objects around -- in\n@@ -200,7 +200,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n    Ensure that V has at least RESERVE slots available, if RESERVE is\n    >= 0.  If RESERVE < 0, ensure that there is at least one spare\n-   slot.  These differ in their reallocation behaviour, the first will\n+   slot.  These differ in their reallocation behavior, the first will\n    not create additional headroom, but the second mechanism will\n    perform the usual exponential headroom increase.  Note this can\n    cause V to be reallocated.  Returns nonzero iff reallocation"}]}