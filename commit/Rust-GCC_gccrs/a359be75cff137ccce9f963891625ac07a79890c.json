{"sha": "a359be75cff137ccce9f963891625ac07a79890c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM1OWJlNzVjZmYxMzdjY2NlOWY5NjM4OTE2MjVhYzA3YTc5ODkwYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-05-07T09:47:57Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-05-07T09:47:57Z"}, "message": "init.c (resolve_offset_ref): Don't return a raw method.\n\n\t* init.c (resolve_offset_ref): Don't return a raw method.\n\tUse BASELINK_P.\n\t* typeck.c (decay_conversion): Don't handle a raw method.\n\tResolve all OFFSET_REFs.\n\t(get_member_function_from_ptrfunc): 0 is a valid vtable index.\n\t(build_binary_op_nodefault): Handle resolving overloaded fns.  Use\n\tsame_type_p for pmf bits.  Don't use build_binary_op to compare\n\traw pointers to methods.\n\t(convert_for_assignment): Check for OFFSET_REF, not OFFSET_TYPE,\n\tto decide when to call resolve_offset_ref.\n\t(build_c_cast, convert_for_initialization): Likewise.\n\t* cvt.c (build_expr_type_conversion): Likewise.\n\nFrom-SVN: r26815", "tree": {"sha": "470f7f0e86034b584dc4f06cb1bc67a8ba0227ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/470f7f0e86034b584dc4f06cb1bc67a8ba0227ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a359be75cff137ccce9f963891625ac07a79890c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a359be75cff137ccce9f963891625ac07a79890c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a359be75cff137ccce9f963891625ac07a79890c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a359be75cff137ccce9f963891625ac07a79890c/comments", "author": null, "committer": null, "parents": [{"sha": "475836b16f4525a91731ab928385389464675c0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/475836b16f4525a91731ab928385389464675c0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/475836b16f4525a91731ab928385389464675c0e"}], "stats": {"total": 140, "additions": 79, "deletions": 61}, "files": [{"sha": "2bf502710b60841d0173691a8b68485539ba179e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a359be75cff137ccce9f963891625ac07a79890c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a359be75cff137ccce9f963891625ac07a79890c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a359be75cff137ccce9f963891625ac07a79890c", "patch": "@@ -1,3 +1,18 @@\n+1999-05-07  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* init.c (resolve_offset_ref): Don't return a raw method.\n+\tUse BASELINK_P.\n+\t* typeck.c (decay_conversion): Don't handle a raw method.\n+\tResolve all OFFSET_REFs.\n+\t(get_member_function_from_ptrfunc): 0 is a valid vtable index.\n+\t(build_binary_op_nodefault): Handle resolving overloaded fns.  Use\n+\tsame_type_p for pmf bits.  Don't use build_binary_op to compare\n+\traw pointers to methods.\n+\t(convert_for_assignment): Check for OFFSET_REF, not OFFSET_TYPE,\n+\tto decide when to call resolve_offset_ref.\n+\t(build_c_cast, convert_for_initialization): Likewise.\n+\t* cvt.c (build_expr_type_conversion): Likewise.\n+\n 1999-05-06  Nathan Sidwell  <nathan@acm.org>\n \n \t* call.c (build_new_method_call): Use TYPE_MAIN_VARIANT of class."}, {"sha": "c9c41000a790133ad0d436c2ff1a9b1640e2a066", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a359be75cff137ccce9f963891625ac07a79890c/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a359be75cff137ccce9f963891625ac07a79890c/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=a359be75cff137ccce9f963891625ac07a79890c", "patch": "@@ -976,7 +976,7 @@ build_expr_type_conversion (desires, expr, complain)\n       && !(desires & WANT_NULL))\n     cp_warning (\"converting NULL to non-pointer type\");\n     \n-  if (TREE_CODE (basetype) == OFFSET_TYPE)\n+  if (TREE_CODE (expr) == OFFSET_REF || BASELINK_P (expr))\n     expr = resolve_offset_ref (expr);\n   expr = convert_from_reference (expr);\n   basetype = TREE_TYPE (expr);"}, {"sha": "d54d6f6c559fc1998a0f6937d853563fbaf56efb", "filename": "gcc/cp/init.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a359be75cff137ccce9f963891625ac07a79890c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a359be75cff137ccce9f963891625ac07a79890c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a359be75cff137ccce9f963891625ac07a79890c", "patch": "@@ -1692,7 +1692,7 @@ resolve_offset_ref (exp)\n   tree member;\n   tree basetype, addr;\n \n-  if (TREE_CODE (exp) == TREE_LIST)\n+  if (BASELINK_P (exp))\n     {\n       cp_pedwarn (\"assuming & on overloaded member function\");\n       return build_unary_op (ADDR_EXPR, exp, 0);\n@@ -1719,15 +1719,20 @@ resolve_offset_ref (exp)\n   if ((TREE_CODE (member) == VAR_DECL\n        && ! TYPE_PTRMEMFUNC_P (TREE_TYPE (member))\n        && ! TYPE_PTRMEM_P (TREE_TYPE (member)))\n-      || TREE_CODE (TREE_TYPE (member)) == FUNCTION_TYPE\n-      || TREE_CODE (TREE_TYPE (member)) == METHOD_TYPE)\n+      || TREE_CODE (TREE_TYPE (member)) == FUNCTION_TYPE)\n     {\n       /* These were static members.  */\n       if (mark_addressable (member) == 0)\n \treturn error_mark_node;\n       return member;\n     }\n \n+  if (TREE_CODE (TREE_TYPE (member)) == METHOD_TYPE)\n+    {\n+      cp_pedwarn (\"assuming & on `%E'\", member);\n+      return build_unary_op (ADDR_EXPR, exp, 0);\n+    }\n+\n   if (TREE_CODE (TREE_TYPE (member)) == POINTER_TYPE\n       && TREE_CODE (TREE_TYPE (TREE_TYPE (member))) == METHOD_TYPE)\n     return member;"}, {"sha": "fe4f509b2cd4a4db856d6c782edc16307bf2f5ca", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 55, "deletions": 57, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a359be75cff137ccce9f963891625ac07a79890c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a359be75cff137ccce9f963891625ac07a79890c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a359be75cff137ccce9f963891625ac07a79890c", "patch": "@@ -1714,23 +1714,14 @@ tree\n decay_conversion (exp)\n      tree exp;\n {\n-  register tree type = TREE_TYPE (exp);\n-  register enum tree_code code = TREE_CODE (type);\n+  register tree type;\n+  register enum tree_code code;\n \n-  if (code == OFFSET_TYPE)\n-    {\n-      if (TREE_CODE (exp) == OFFSET_REF)\n-\treturn decay_conversion (resolve_offset_ref (exp));\n+  if (TREE_CODE (exp) == OFFSET_REF || BASELINK_P (exp))\n+    exp = resolve_offset_ref (exp);\n \n-      type = TREE_TYPE (type);\n-      code = TREE_CODE (type);\n-\n-      if (type == unknown_type_node)\n-\t{\n-\t  cp_pedwarn (\"assuming & on overloaded member function\");\n-\t  return build_unary_op (ADDR_EXPR, exp, 0);\n-\t}\n-    }\n+  type = TREE_TYPE (exp);\n+  code = TREE_CODE (type);\n \n   if (code == REFERENCE_TYPE)\n     {\n@@ -1765,10 +1756,7 @@ decay_conversion (exp)\n       return error_mark_node;\n     }\n   if (code == METHOD_TYPE)\n-    {\n-      cp_pedwarn (\"assuming & on `%E'\", exp);\n-      return build_unary_op (ADDR_EXPR, exp, 0);\n-    }\n+    my_friendly_abort (990506);\n   if (code == FUNCTION_TYPE || is_overloaded_fn (exp))\n     return build_unary_op (ADDR_EXPR, exp, 0);\n   if (code == ARRAY_TYPE)\n@@ -2871,7 +2859,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \t\t\t   (build_component_ref (function,\n \t\t\t\t\t\t index_identifier,\n \t\t\t\t\t\t NULL_TREE, 0)));\n-\t  e1 = build_binary_op (GT_EXPR, idx, integer_zero_node);\n+\t  e1 = build_binary_op (GE_EXPR, idx, integer_zero_node);\n \n \t  /* Convert down to the right base, before using the instance.  */\n \t  instance = convert_pointer_to_real (basetype, instance_ptr);\n@@ -3356,6 +3344,32 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n       op1 = default_conversion (orig_op1);\n     }\n \n+  /* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */\n+  STRIP_TYPE_NOPS (op0);\n+  STRIP_TYPE_NOPS (op1);\n+\n+  /* DTRT if one side is an overloaded function, but complain about it.  */\n+  if (type_unknown_p (op0))\n+    {\n+      tree t = instantiate_type (TREE_TYPE (op1), op0, 0);\n+      if (t != error_mark_node)\n+\t{\n+\t  cp_pedwarn (\"assuming cast to `%T' from overloaded function\",\n+\t\t      TREE_TYPE (t));\n+\t  op0 = t;\n+\t}\n+    }\n+  if (type_unknown_p (op1))\n+    {\n+      tree t = instantiate_type (TREE_TYPE (op0), op1, 0);\n+      if (t != error_mark_node)\n+\t{\n+\t  cp_pedwarn (\"assuming cast to `%T' from overloaded function\",\n+\t\t      TREE_TYPE (t));\n+\t  op1 = t;\n+\t}\n+    }\n+\n   type0 = TREE_TYPE (op0);\n   type1 = TREE_TYPE (op1);\n \n@@ -3364,10 +3378,6 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n   code0 = TREE_CODE (type0);\n   code1 = TREE_CODE (type1);\n \n-  /* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */\n-  STRIP_TYPE_NOPS (op0);\n-  STRIP_TYPE_NOPS (op1);\n-\n   /* If an error was already reported for one of the arguments,\n      avoid reporting another error.  */\n \n@@ -3640,8 +3650,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  result_type = TREE_TYPE (op0);\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type0) && TYPE_PTRMEMFUNC_P (type1)\n-\t       && (TYPE_PTRMEMFUNC_FN_TYPE (type0)\n-\t\t   == TYPE_PTRMEMFUNC_FN_TYPE (type1)))\n+\t       && same_type_p (type0, type1))\n \t{\n \t  /* The code we generate for the test is:\n \n@@ -3665,15 +3674,17 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  e2 = build_binary_op (NE_EXPR, index1, integer_neg_one_node);\n \t  e2 = build_binary_op (TRUTH_ANDIF_EXPR, e2,\n \t\t\t\tbuild_binary_op (EQ_EXPR, delta20, delta21));\n-\t  e3 = build_binary_op (EQ_EXPR, pfn0, pfn1);\n+\t  /* We can't use build_binary_op for this cmp because it would get\n+\t     confused by the ptr to method types and think we want pmfs.  */\n+\t  e3 = build (EQ_EXPR, boolean_type_node, pfn0, pfn1);\n \t  e2 = build_binary_op (TRUTH_ORIF_EXPR, e2, e3);\n \t  e2 = build_binary_op (TRUTH_ANDIF_EXPR, e1, e2);\n \t  if (code == EQ_EXPR)\n \t    return e2;\n \t  return build_binary_op (EQ_EXPR, e2, integer_zero_node);\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type0)\n-\t       && TYPE_PTRMEMFUNC_FN_TYPE (type0) == type1)\n+\t       && same_type_p (TYPE_PTRMEMFUNC_FN_TYPE (type0), type1))\n \t{\n \t  tree index0 = build_component_ref (op0, index_identifier,\n \t\t\t\t\t     NULL_TREE, 0);\n@@ -3712,15 +3723,17 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  e2 = build_binary_op (NE_EXPR, index1, integer_neg_one_node);\n \t  e2 = build_binary_op (TRUTH_ANDIF_EXPR, e2,\n \t\t\t\tbuild_binary_op (EQ_EXPR, delta20, delta21));\n-\t  e3 = build_binary_op (EQ_EXPR, pfn0, op1);\n+\t  /* We can't use build_binary_op for this cmp because it would get\n+\t     confused by the ptr to method types and think we want pmfs.  */\n+\t  e3 = build (EQ_EXPR, boolean_type_node, pfn0, op1);\n \t  e2 = build_binary_op (TRUTH_ORIF_EXPR, e2, e3);\n \t  e2 = build_binary_op (TRUTH_ANDIF_EXPR, e1, e2);\n \t  if (code == EQ_EXPR)\n \t    return e2;\n \t  return build_binary_op (EQ_EXPR, e2, integer_zero_node);\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type1)\n-\t       && TYPE_PTRMEMFUNC_FN_TYPE (type1) == type0)\n+\t       && same_type_p (TYPE_PTRMEMFUNC_FN_TYPE (type1), type0))\n \treturn build_binary_op (code, op1, op0);\n       break;\n \n@@ -5718,9 +5731,7 @@ build_c_cast (type, expr)\n       && TREE_TYPE (value) == TREE_TYPE (TREE_OPERAND (value, 0)))\n     value = TREE_OPERAND (value, 0);\n \n-  if (TREE_TYPE (expr)\n-      && TREE_CODE (TREE_TYPE (expr)) == OFFSET_TYPE\n-      && TREE_CODE (type) != OFFSET_TYPE)\n+  if (TREE_CODE (value) == OFFSET_REF || BASELINK_P (value))\n     value = resolve_offset_ref (value);\n \n   if (TREE_CODE (type) == ARRAY_TYPE)\n@@ -6687,40 +6698,23 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n {\n   register enum tree_code codel = TREE_CODE (type);\n   register tree rhstype;\n-  register enum tree_code coder = TREE_CODE (TREE_TYPE (rhs));\n-\n-  /* Issue warnings about peculiar, but legal, uses of NULL.  */\n-  if (ARITHMETIC_TYPE_P (type) && rhs == null_node)\n-    cp_warning (\"converting NULL to non-pointer type\");\n-\n-  if (coder == ERROR_MARK)\n-    return error_mark_node;\n+  register enum tree_code coder;\n \n   if (codel == OFFSET_TYPE)\n-    {\n-      type = TREE_TYPE (type);\n-      codel = TREE_CODE (type);\n-    }\n+    my_friendly_abort (990505);\n+\n+  if (TREE_CODE (rhs) == OFFSET_REF || BASELINK_P (rhs))\n+    rhs = resolve_offset_ref (rhs);\n \n   /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n   if (TREE_CODE (rhs) == NON_LVALUE_EXPR)\n     rhs = TREE_OPERAND (rhs, 0);\n \n-  if (rhs == error_mark_node)\n+  if (rhs == error_mark_node || TREE_TYPE (rhs) == error_mark_node)\n     return error_mark_node;\n-\n   if (TREE_CODE (rhs) == TREE_LIST && TREE_VALUE (rhs) == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (TREE_TYPE (rhs)) == OFFSET_TYPE)\n-    {\n-      rhs = resolve_offset_ref (rhs);\n-      if (rhs == error_mark_node)\n-\treturn error_mark_node;\n-      rhstype = TREE_TYPE (rhs);\n-      coder = TREE_CODE (rhstype);\n-    }\n-\n   if (TREE_CODE (TREE_TYPE (rhs)) == ARRAY_TYPE\n       || is_overloaded_fn (rhs))\n     rhs = default_conversion (rhs);\n@@ -6736,6 +6730,10 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n   rhstype = TREE_TYPE (rhs);\n   coder = TREE_CODE (rhstype);\n \n+  /* Issue warnings about peculiar, but legal, uses of NULL.  */\n+  if (ARITHMETIC_TYPE_P (type) && rhs == null_node)\n+    cp_warning (\"converting NULL to non-pointer type\");\n+\n   /* This should no longer change types on us.  */\n   if (TREE_CODE (rhs) == CONST_DECL)\n     rhs = DECL_INITIAL (rhs);\n@@ -7135,7 +7133,7 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n       || (TREE_CODE (rhs) == TREE_LIST && TREE_VALUE (rhs) == error_mark_node))\n     return error_mark_node;\n \n-  if (TREE_CODE (TREE_TYPE (rhs)) == OFFSET_TYPE)\n+  if (TREE_CODE (rhs) == OFFSET_REF || BASELINK_P (rhs))\n     {\n       rhs = resolve_offset_ref (rhs);\n       if (rhs == error_mark_node)"}]}