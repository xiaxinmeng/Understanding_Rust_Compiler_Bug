{"sha": "caaf33fa57a73698365a8c1b6eccca88016fa1ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FhZjMzZmE1N2E3MzY5ODM2NWE4YzFiNmVjY2NhODgwMTZmYTFhZQ==", "commit": {"author": {"name": "Tim Shen", "email": "timshen91@gmail.com", "date": "2013-10-28T03:55:12Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2013-10-28T03:55:12Z"}, "message": "regex_executor.tcc: Add comments.\n\n2013-10-28  Tim Shen  <timshen91@gmail.com>\n\n\t* regex_executor.tcc: Add comments.\n\nFrom-SVN: r204117", "tree": {"sha": "e65ae4a755f8cff4ecc16c8ca9bbc0c137d6f3c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e65ae4a755f8cff4ecc16c8ca9bbc0c137d6f3c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/caaf33fa57a73698365a8c1b6eccca88016fa1ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caaf33fa57a73698365a8c1b6eccca88016fa1ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caaf33fa57a73698365a8c1b6eccca88016fa1ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caaf33fa57a73698365a8c1b6eccca88016fa1ae/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "58fe50d5c90eb14e3cecacf66035751fcc06dd3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58fe50d5c90eb14e3cecacf66035751fcc06dd3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58fe50d5c90eb14e3cecacf66035751fcc06dd3b"}], "stats": {"total": 109, "additions": 71, "deletions": 38}, "files": [{"sha": "1b83aa5aa658680ba3d670d9125f91ad6666086a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caaf33fa57a73698365a8c1b6eccca88016fa1ae/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caaf33fa57a73698365a8c1b6eccca88016fa1ae/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=caaf33fa57a73698365a8c1b6eccca88016fa1ae", "patch": "@@ -1,3 +1,7 @@\n+2013-10-28  Tim Shen  <timshen91@gmail.com>\n+\n+\t* regex_executor.tcc: Add comments.\n+\n 2013-10-26  Tim Shen  <timshen91@gmail.com>\n \n \t* include/bits/regex.h: Remove unnecessary friends."}, {"sha": "0c42189eb877b78a0786c8c7399fc0642f0278de", "filename": "libstdc++-v3/include/bits/regex_executor.tcc", "status": "modified", "additions": 67, "deletions": 38, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caaf33fa57a73698365a8c1b6eccca88016fa1ae/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caaf33fa57a73698365a8c1b6eccca88016fa1ae/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc?ref=caaf33fa57a73698365a8c1b6eccca88016fa1ae", "patch": "@@ -53,6 +53,49 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return false;\n     }\n \n+  // This function operates in different modes, DFS mode or BFS mode, indicated\n+  // by template parameter __dfs_mode. See _M_main for details.\n+  //\n+  // ------------------------------------------------------------\n+  //\n+  // DFS mode:\n+  //\n+  // It applies a Depth-First-Search (aka backtracking) on given NFA and input\n+  // string.\n+  // At the very beginning the executor stands in the start state, then it tries\n+  // every possible state transition in current state recursively. Some state\n+  // transitions consume input string, say, a single-char-matcher or a\n+  // back-reference matcher; some don't, like assertion or other anchor nodes.\n+  // When the input is exhausted and/or the current state is an accepting state,\n+  // the whole executor returns true.\n+  //\n+  // TODO: This approach is exponentially slow for certain input.\n+  //       Try to compile the NFA to a DFA.\n+  //\n+  // Time complexity: o(match_length), O(2^(_M_nfa.size()))\n+  // Space complexity: \\theta(match_results.size() + match_length)\n+  //\n+  // ------------------------------------------------------------\n+  //\n+  // BFS mode:\n+  //\n+  // Russ Cox's article (http://swtch.com/~rsc/regexp/regexp1.html)\n+  // explained this algorithm clearly.\n+  //\n+  // It first computes epsilon closure for every state that's still matching,\n+  // using the same DFS algorithm, but doesn't reenter states (set true in\n+  // _M_visited), nor follows _S_opcode_match.\n+  //\n+  // Then apply DFS using every _S_opcode_match (in _M_match_queue) as the start\n+  // state.\n+  //\n+  // It significantly reduces potential duplicate states, so has a better\n+  // upper bound; but it requires more overhead.\n+  //\n+  // Time complexity: o(match_length * match_results.size())\n+  //                  O(match_length * _M_nfa.size() * match_results.size())\n+  // Space complexity: o(_M_nfa.size() + match_results.size())\n+  //                   O(_M_nfa.size() * match_results.size())\n   template<typename _BiIter, typename _Alloc, typename _TraitsT,\n     bool __dfs_mode>\n   template<bool __match_mode>\n@@ -68,18 +111,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n       else\n \t{\n-\t  // Like the DFS approach, it try every possible state transition;\n-\t  // Unlike DFS, it uses a queue instead of a stack to store matching\n-\t  // states. It's a BFS approach.\n-\t  //\n-\t  // Russ Cox's article(http://swtch.com/~rsc/regexp/regexp1.html)\n-\t  // explained this algorithm clearly.\n-\t  //\n-\t  // Time complexity: o(match_length * match_results.size())\n-\t  //                  O(match_length * _M_nfa.size()\n-\t  //                    * match_results.size())\n-\t  // Space complexity: o(_M_nfa.size() + match_results.size())\n-\t  //                   O(_M_nfa.size() * match_results.size())\n \t  _M_match_queue->push(make_pair(_M_start_state, _M_results));\n \t  bool __ret = false;\n \t  while (1)\n@@ -132,20 +163,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return false;\n     }\n \n-  // A _DFSExecutor perform a DFS on given NFA and input string. At the very\n-  // beginning the executor stands in the start state, then it try every\n-  // possible state transition in current state recursively. Some state\n-  // transitions consume input string, say, a single-char-matcher or a\n-  // back-reference matcher; some not, like assertion or other anchor nodes.\n-  // When the input is exhausted and the current state is an accepting state,\n-  // the whole executor return true.\n-  //\n-  // TODO: This approach is exponentially slow for certain input.\n-  //       Try to compile the NFA to a DFA.\n-  //\n-  // Time complexity: o(match_length), O(2^(_M_nfa.size()))\n-  // Space complexity: \\theta(match_results.size() + match_length)\n-  //\n   template<typename _BiIter, typename _Alloc, typename _TraitsT,\n     bool __dfs_mode>\n   template<bool __match_mode>\n@@ -160,42 +177,54 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n \n       const auto& __state = _M_nfa[__i];\n+      // Every change on _M_cur_results and _M_current will be rolled back after\n+      // finishing the recursion step.\n       switch (__state._M_opcode)\n \t{\n+\t// _M_alt branch is \"match once more\", while _M_next is \"get me out\n+\t// of this quantifier\". Executing _M_next first or _M_alt first don't\n+\t// mean the same thing, and we need to choose the correct order under\n+\t// given greedy mode.\n \tcase _S_opcode_alternative:\n-\t  // Greedy or not, this is a question ;)\n+\t  // Greedy.\n \t  if (!__state._M_neg)\n \t    {\n+\t      // \"Once more\" is preferred in greedy mode.\n \t      _M_dfs<__match_mode>(__state._M_alt);\n+\t      // If it's DFS executor and already accepted, we're done.\n \t      if (!__dfs_mode || !_M_has_sol)\n \t\t_M_dfs<__match_mode>(__state._M_next);\n \t    }\n-\t  else\n+\t  else // Non-greedy mode\n \t    {\n \t      if (__dfs_mode)\n \t\t{\n+\t\t  // vice-versa.\n \t\t  _M_dfs<__match_mode>(__state._M_next);\n \t\t  if (!_M_has_sol)\n \t\t    _M_dfs<__match_mode>(__state._M_alt);\n \t\t}\n \t      else\n \t\t{\n+\t\t  // DON'T attempt anything, because there's already another\n+\t\t  // state with higher priority accepted. This state cannot be\n+\t\t  // better by attempting its next node.\n \t\t  if (!_M_has_sol)\n \t\t    {\n \t\t      _M_dfs<__match_mode>(__state._M_next);\n+\t\t      // DON'T attempt anything if it's already accepted. An\n+\t\t      // accepted state *must* be better than a solution that\n+\t\t      // matches a non-greedy quantifier one more time.\n \t\t      if (!_M_has_sol)\n \t\t\t_M_dfs<__match_mode>(__state._M_alt);\n \t\t    }\n \t\t}\n \t    }\n \t  break;\n \tcase _S_opcode_subexpr_begin:\n-\t  // Here's the critical part: if there's nothing changed since last\n-\t  // visit, do NOT continue. This prevents the executor from get into\n-\t  // infinite loop when use \"()*\" to match \"\".\n-\t  //\n-\t  // Every change on _M_cur_results will be roll back after the\n-\t  // recursion step finished.\n+\t  // If there's nothing changed since last visit, do NOT continue.\n+\t  // This prevents the executor from get into infinite loop when using\n+\t  // \"()*\" to match \"\".\n \t  if (!_M_cur_results[__state._M_subexpr].matched\n \t      || _M_cur_results[__state._M_subexpr].first != _M_current)\n \t    {\n@@ -232,8 +261,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  if (_M_word_boundry(__state) == !__state._M_neg)\n \t    _M_dfs<__match_mode>(__state._M_next);\n \t  break;\n-\t  // Here __state._M_alt offers a single start node for a sub-NFA.\n-\t  // We recursivly invoke our algorithm to match the sub-NFA.\n+\t// Here __state._M_alt offers a single start node for a sub-NFA.\n+\t// We recursively invoke our algorithm to match the sub-NFA.\n \tcase _S_opcode_subexpr_lookahead:\n \t  if (_M_lookahead(__state) == !__state._M_neg)\n \t    _M_dfs<__match_mode>(__state._M_next);\n@@ -254,8 +283,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  break;\n \t// First fetch the matched result from _M_cur_results as __submatch;\n \t// then compare it with\n-\t// (_M_current, _M_current + (__submatch.second - __submatch.first))\n-\t// If matched, keep going; else just return to try another state.\n+\t// (_M_current, _M_current + (__submatch.second - __submatch.first)).\n+\t// If matched, keep going; else just return and try another state.\n \tcase _S_opcode_backref:\n \t  {\n \t    _GLIBCXX_DEBUG_ASSERT(__dfs_mode);"}]}