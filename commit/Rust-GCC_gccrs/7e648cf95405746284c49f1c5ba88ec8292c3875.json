{"sha": "7e648cf95405746284c49f1c5ba88ec8292c3875", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U2NDhjZjk1NDA1NzQ2Mjg0YzQ5ZjFjNWJhODhlYzgyOTJjMzg3NQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-02-01T06:14:26Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-02-01T06:14:26Z"}, "message": "prims.cc (_Jv_MallocUnchecked): New function.\n\n\t* prims.cc (_Jv_MallocUnchecked): New function.\n\t(main_init): Call _Jv_JNI_Init.\n\t* include/jvm.h (_Jv_MallocUnchecked): Declare.\n\t(_Jv_JNI_Init): Declare.\n\t* jni.cc: Include Hashtable.h, OutOfMemoryError.h, Integer.h,\n\t<string.h>.\n\t(_Jv_JNI_NewGlobalRef): New function.\n\t(_Jv_JNI_DeleteGlobalRef): New function.\n\t(_Jv_JNI_DeleteLocalRef): New function.\n\t(_Jv_JNI_conversion_call): Initialize and clear local reference\n\tframe.\n\t(_Jv_JNI_NewLocalRef): New function.\n\t(struct _Jv_JNI_LocalFrame): New structure.\n\t(_Jv_JNI_PushLocalFrame): New function.\n\t(_Jv_JNI_EnsureLocalCapacity): New function.\n\t(FRAME_SIZE): New define.\n\t(_Jv_JNI_GetStringChars): Mark string, not characters.\n\t(_Jv_JNI_ReleaseStringChars): Unmark string, not characters.\n\t(_Jv_JNI_GetPrimitiveArrayElements): Mark array, not elements.\n\t(_Jv_JNI_ReleasePrimitiveArrayElements): Unmark array, not\n\telements.\n\t(_Jv_JNI_DefineClass): Make return value a local ref.\n\t(_Jv_JNI_FindClass): Likewise.\n\t(_Jv_JNI_GetSuperclass): Likewise.\n\t(_Jv_JNI_ExceptionOccurred): Likewise.\n\t(_Jv_JNI_AllocObject): Likewise.\n\t(_Jv_JNI_GetObjectClass): Likewise.\n\t(_Jv_JNI_CallAnyMethodV): Likewise.\n\t(_Jv_JNI_NewString): Likewise.\n\t(_Jv_JNI_NewStringUTF): Likewise.\n\t(_Jv_JNI_NewObjectArray): Likewise.\n\t(_Jv_JNI_GetObjectArrayElement): Likewise.\n\t(_Jv_JNI_ToReflectedField): Likewise.\n\t(_Jv_JNI_ToReflectedMethod): Likewise.\n\t(_Jv_JNIFunctions): Updated table for new functions.\n\t(_Jv_JNI_Init): New function.\n\t(mark_for_gc): Wrote.\n\t(unmark_for_gc): Wrote.\n\t* include/jni.h (struct JNINativeInterface): Removed name from\n\tPopLocalFrame parameter.\n\t(class _Jv_JNIEnv): Added `locals' field.\n\nFrom-SVN: r31730", "tree": {"sha": "37bc5e7b05325b8b7a5590d5caf2fda61bb3f57d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37bc5e7b05325b8b7a5590d5caf2fda61bb3f57d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e648cf95405746284c49f1c5ba88ec8292c3875", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e648cf95405746284c49f1c5ba88ec8292c3875", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e648cf95405746284c49f1c5ba88ec8292c3875", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e648cf95405746284c49f1c5ba88ec8292c3875/comments", "author": null, "committer": null, "parents": [{"sha": "07a3462a53b230baae7bb0438cf276de28d2aedf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07a3462a53b230baae7bb0438cf276de28d2aedf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07a3462a53b230baae7bb0438cf276de28d2aedf"}], "stats": {"total": 379, "additions": 333, "deletions": 46}, "files": [{"sha": "93db6e7a45c09c46ad88a0392edb3421708a46f8", "filename": "libjava/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e648cf95405746284c49f1c5ba88ec8292c3875/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e648cf95405746284c49f1c5ba88ec8292c3875/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7e648cf95405746284c49f1c5ba88ec8292c3875", "patch": "@@ -1,3 +1,47 @@\n+2000-01-31  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* prims.cc (_Jv_MallocUnchecked): New function.\n+\t(main_init): Call _Jv_JNI_Init.\n+\t* include/jvm.h (_Jv_MallocUnchecked): Declare.\n+\t(_Jv_JNI_Init): Declare.\n+\t* jni.cc: Include Hashtable.h, OutOfMemoryError.h, Integer.h,\n+\t<string.h>.\n+\t(_Jv_JNI_NewGlobalRef): New function.\n+\t(_Jv_JNI_DeleteGlobalRef): New function.\n+\t(_Jv_JNI_DeleteLocalRef): New function.\n+\t(_Jv_JNI_conversion_call): Initialize and clear local reference\n+\tframe.\n+\t(_Jv_JNI_NewLocalRef): New function.\n+\t(struct _Jv_JNI_LocalFrame): New structure.\n+\t(_Jv_JNI_PushLocalFrame): New function.\n+\t(_Jv_JNI_EnsureLocalCapacity): New function.\n+\t(FRAME_SIZE): New define.\n+\t(_Jv_JNI_GetStringChars): Mark string, not characters.\n+\t(_Jv_JNI_ReleaseStringChars): Unmark string, not characters.\n+\t(_Jv_JNI_GetPrimitiveArrayElements): Mark array, not elements.\n+\t(_Jv_JNI_ReleasePrimitiveArrayElements): Unmark array, not\n+\telements.\n+\t(_Jv_JNI_DefineClass): Make return value a local ref.\n+\t(_Jv_JNI_FindClass): Likewise.\n+\t(_Jv_JNI_GetSuperclass): Likewise.\n+\t(_Jv_JNI_ExceptionOccurred): Likewise.\n+\t(_Jv_JNI_AllocObject): Likewise.\n+\t(_Jv_JNI_GetObjectClass): Likewise.\n+\t(_Jv_JNI_CallAnyMethodV): Likewise.\n+\t(_Jv_JNI_NewString): Likewise.\n+\t(_Jv_JNI_NewStringUTF): Likewise.\n+\t(_Jv_JNI_NewObjectArray): Likewise.\n+\t(_Jv_JNI_GetObjectArrayElement): Likewise.\n+\t(_Jv_JNI_ToReflectedField): Likewise.\n+\t(_Jv_JNI_ToReflectedMethod): Likewise.\n+\t(_Jv_JNIFunctions): Updated table for new functions.\n+\t(_Jv_JNI_Init): New function.\n+\t(mark_for_gc): Wrote.\n+\t(unmark_for_gc): Wrote.\n+\t* include/jni.h (struct JNINativeInterface): Removed name from\n+\tPopLocalFrame parameter.\n+\t(class _Jv_JNIEnv): Added `locals' field.\n+\n Mon Jan 31 00:43:15 2000  Anthony Green  <green@redhat.com>\n \n \t* gnu/gcj/convert/natIconv.cc (read): Minor fixes."}, {"sha": "c5ca7dc95dd3678756637849a91f585fbf282124", "filename": "libjava/include/jni.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e648cf95405746284c49f1c5ba88ec8292c3875/libjava%2Finclude%2Fjni.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e648cf95405746284c49f1c5ba88ec8292c3875/libjava%2Finclude%2Fjni.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjni.h?ref=7e648cf95405746284c49f1c5ba88ec8292c3875", "patch": "@@ -133,7 +133,7 @@ struct JNINativeInterface\n   void     (*FatalError)                   (JNIEnv *, const char *);\n \n   jint     (*PushLocalFrame)\t\t   (JNIEnv *, jint);\n-  jobject  (*PopLocalFrame)\t\t   (JNIEnv *, jobject result);\n+  jobject  (*PopLocalFrame)\t\t   (JNIEnv *, jobject);\n \n   jobject  (*NewGlobalRef)                 (JNIEnv *, jobject);\n   void     (*DeleteGlobalRef)              (JNIEnv *, jobject);\n@@ -538,6 +538,9 @@ class _Jv_JNIEnv\n   /* The class of the current native method.  */\n   jclass klass;\n \n+  /* The chain of local frames.  */\n+  struct _Jv_JNI_LocalFrame *locals;\n+\n public:\n   jclass GetSuperclass (jclass cl)\n   { return p->GetSuperclass (this, cl); }"}, {"sha": "c9eb1b95c808a3c90be05400daa32eae8d6fc5c7", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e648cf95405746284c49f1c5ba88ec8292c3875/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e648cf95405746284c49f1c5ba88ec8292c3875/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=7e648cf95405746284c49f1c5ba88ec8292c3875", "patch": "@@ -72,6 +72,10 @@ void _Jv_InitGC (void);\n /* Register a finalizer.  */\n void _Jv_RegisterFinalizer (void *object, _Jv_FinalizerFunc *method);\n \n+/* Allocate some unscanned, unmoveable memory.  Return NULL if out of\n+   memory.  */\n+void *_Jv_MallocUnchecked (jsize size) __attribute__((__malloc__));\n+\n /* Run finalizers for objects ready to be finalized..  */\n void _Jv_RunFinalizers (void);\n /* Run all finalizers.  Should be called only before exit.  */\n@@ -197,4 +201,8 @@ extern \"C\"\n extern char *_Jv_ThisExecutable (void);\n extern void _Jv_ThisExecutable (const char *);\n \n+/* Initialize JNI.  */\n+extern void _Jv_JNI_Init (void);\n+\n+\n #endif /* __JAVA_JVM_H__ */"}, {"sha": "0b51fce35a45ff74a45499d74bc71610b7862e91", "filename": "libjava/jni.cc", "status": "modified", "additions": 267, "deletions": 45, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e648cf95405746284c49f1c5ba88ec8292c3875/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e648cf95405746284c49f1c5ba88ec8292c3875/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=7e648cf95405746284c49f1c5ba88ec8292c3875", "patch": "@@ -17,6 +17,7 @@ details.  */\n #include <config.h>\n \n #include <stddef.h>\n+#include <string.h>\n \n // Define this before including jni.h.\n #define __GCJ_JNI_IMPL__\n@@ -37,6 +38,9 @@ details.  */\n #include <java/lang/reflect/Constructor.h>\n #include <java/lang/reflect/Method.h>\n #include <java/lang/reflect/Modifier.h>\n+#include <java/lang/OutOfMemoryError.h>\n+#include <java/util/Hashtable.h>\n+#include <java/lang/Integer.h>\n \n #include <gcj/method.h>\n #include <gcj/field.h>\n@@ -62,20 +66,202 @@ enum invocation_type\n // Forward declaration.\n extern struct JNINativeInterface _Jv_JNIFunctions;\n \n+// Number of slots in the default frame.  The VM must allow at least\n+// 16.\n+#define FRAME_SIZE 32\n+\n+// This structure is used to keep track of local references.\n+struct _Jv_JNI_LocalFrame\n+{\n+  // This is true if this frame object represents a pushed frame (eg\n+  // from PushLocalFrame).\n+  int marker :  1;\n+\n+  // Number of elements in frame.\n+  int size   : 31;\n+\n+  // Next frame in chain.\n+  _Jv_JNI_LocalFrame *next;\n+\n+  // The elements.  These are allocated using the C \"struct hack\".\n+  jobject vec[0];\n+};\n+\n+// This holds a reference count for all local and global references.\n+static java::util::Hashtable *ref_table;\n+\n \f\n \n+void\n+_Jv_JNI_Init (void)\n+{\n+  ref_table = new java::util::Hashtable;\n+}\n+\n // Tell the GC that a certain pointer is live.\n static void\n-mark_for_gc (void *)\n+mark_for_gc (jobject obj)\n {\n-  // FIXME.\n+  JvSynchronize sync (ref_table);\n+\n+  using namespace java::lang;\n+  Integer *refcount = (Integer *) ref_table->get (obj);\n+  jint val = (refcount == NULL) ? 0 : refcount->intValue ();\n+  ref_table->put (obj, new Integer (val + 1));\n }\n \n // Unmark a pointer.\n static void\n-unmark_for_gc (void *)\n+unmark_for_gc (jobject obj)\n {\n-  // FIXME.\n+  JvSynchronize sync (ref_table);\n+\n+  using namespace java::lang;\n+  Integer *refcount = (Integer *) ref_table->get (obj);\n+  JvAssert (refcount);\n+  jint val = refcount->intValue () - 1;\n+  if (val == 0)\n+    ref_table->remove (obj);\n+  else\n+    ref_table->put (obj, new Integer (val));\n+}\n+\n+\f\n+\n+static jobject\n+_Jv_JNI_NewGlobalRef (JNIEnv *, jobject obj)\n+{\n+  mark_for_gc (obj);\n+  return obj;\n+}\n+\n+static void\n+_Jv_JNI_DeleteGlobalRef (JNIEnv *, jobject obj)\n+{\n+  unmark_for_gc (obj);\n+}\n+\n+static void\n+_Jv_JNI_DeleteLocalRef (JNIEnv *env, jobject obj)\n+{\n+  _Jv_JNI_LocalFrame *frame;\n+\n+  for (frame = env->locals; frame != NULL; frame = frame->next)\n+    {\n+      for (int i = 0; i < FRAME_SIZE; ++i)\n+\t{\n+\t  if (frame->vec[i] == obj)\n+\t    {\n+\t      frame->vec[i] = NULL;\n+\t      unmark_for_gc (obj);\n+\t      return;\n+\t    }\n+\t}\n+\n+      // Don't go past a marked frame.\n+      JvAssert (! frame->marker);\n+    }\n+\n+  JvAssert (0);\n+}\n+\n+static jint\n+_Jv_JNI_EnsureLocalCapacity (JNIEnv *env, jint size)\n+{\n+  // It is easier to just always allocate a new frame of the requested\n+  // size.  This isn't the most efficient thing, but for now we don't\n+  // care.  Note that _Jv_JNI_PushLocalFrame relies on this right now.\n+\n+  _Jv_JNI_LocalFrame *frame\n+    = (_Jv_JNI_LocalFrame *) _Jv_MallocUnchecked (sizeof (_Jv_JNI_LocalFrame)\n+\t\t\t\t\t\t  + size * sizeof (jobject));\n+  if (frame == NULL)\n+    {\n+      // FIXME: exception processing.\n+      env->ex = new java::lang::OutOfMemoryError;\n+      return -1;\n+    }\n+\n+  frame->marker = true;\n+  frame->size = size;\n+  memset (&frame->vec[0], 0, size * sizeof (jobject));\n+  frame->next = env->locals;\n+  env->locals = frame;\n+\n+  return 0;\n+}\n+\n+static jint\n+_Jv_JNI_PushLocalFrame (JNIEnv *env, jint size)\n+{\n+  jint r = _Jv_JNI_EnsureLocalCapacity (env, size);\n+  if (r < 0)\n+    return r;\n+\n+  // The new frame is on top.\n+  env->locals->marker = true;\n+\n+  return 0;\n+}\n+\n+static jobject\n+_Jv_JNI_NewLocalRef (JNIEnv *env, jobject obj)\n+{\n+  // Try to find an open slot somewhere in the topmost frame.\n+  _Jv_JNI_LocalFrame *frame = env->locals;\n+  bool done = false, set = false;\n+  while (frame != NULL && ! done)\n+    {\n+      for (int i = 0; i < frame->size; ++i)\n+\tif (frame->vec[i] == NULL)\n+\t  {\n+\t    set = true;\n+\t    done = true;\n+\t    frame->vec[i] = obj;\n+\t    break;\n+\t  }\n+    }\n+\n+  if (! set)\n+    {\n+      // No slots, so we allocate a new frame.  According to the spec\n+      // we could just die here.  FIXME: return value.\n+      _Jv_JNI_EnsureLocalCapacity (env, 16);\n+      // We know the first element of the new frame will be ok.\n+      env->locals->vec[0] = obj;\n+    }\n+\n+  mark_for_gc (obj);\n+  return obj;\n+}\n+\n+static jobject\n+_Jv_JNI_PopLocalFrame (JNIEnv *env, jobject result)\n+{\n+  _Jv_JNI_LocalFrame *rf = env->locals;\n+\n+  bool done = false;\n+  while (rf != NULL && ! done)\n+    {  \n+      for (int i = 0; i < rf->size; ++i)\n+\tif (rf->vec[i] != NULL)\n+\t  unmark_for_gc (rf->vec[i]);\n+\n+      // If the frame we just freed is the marker frame, we are done.\n+      done = rf->marker;\n+\n+      _Jv_JNI_LocalFrame *n = rf->next;\n+      // When N==NULL, we've reached the stack-allocated frame, and we\n+      // must not free it.  However, we must be sure to clear all its\n+      // elements, since we might conceivably reuse it.\n+      if (n == NULL)\n+\tmemset (&rf->vec[0], 0, rf->size * sizeof (jobject));\n+      else\n+\t_Jv_Free (rf);\n+      rf = n;\n+    }\n+\n+  return result == NULL ? NULL : _Jv_JNI_NewLocalRef (env, result);\n }\n \n \f\n@@ -87,7 +273,7 @@ _Jv_JNI_GetVersion (JNIEnv *)\n }\n \n static jclass\n-_Jv_JNI_DefineClass (JNIEnv *, jobject loader, \n+_Jv_JNI_DefineClass (JNIEnv *env, jobject loader, \n \t\t     const jbyte *buf, jsize bufLen)\n {\n   jbyteArray bytes = JvNewByteArray (bufLen);\n@@ -99,7 +285,7 @@ _Jv_JNI_DefineClass (JNIEnv *, jobject loader,\n \n   // FIXME: exception processing.\n   jclass result = l->defineClass (bytes, 0, bufLen);\n-  return result;\n+  return (jclass) _Jv_JNI_NewLocalRef (env, result);\n }\n \n static jclass\n@@ -125,13 +311,13 @@ _Jv_JNI_FindClass (JNIEnv *env, const char *name)\n   // FIXME: exception processing.\n   jclass r = loader->findClass (n);\n \n-  return r;\n+  return (jclass) _Jv_JNI_NewLocalRef (env, r);\n }\n \n static jclass\n-_Jv_JNI_GetSuperclass (JNIEnv *, jclass clazz)\n+_Jv_JNI_GetSuperclass (JNIEnv *env, jclass clazz)\n {\n-  return clazz->getSuperclass ();\n+  return (jclass) _Jv_JNI_NewLocalRef (env, clazz->getSuperclass ());\n }\n \n static jboolean\n@@ -175,8 +361,7 @@ _Jv_JNI_ThrowNew (JNIEnv *env, jclass clazz, const char *message)\n static jthrowable\n _Jv_JNI_ExceptionOccurred (JNIEnv *env)\n {\n-  // FIXME: create local reference.\n-  return env->ex;\n+  return (jthrowable) _Jv_JNI_NewLocalRef (env, env->ex);\n }\n \n static void\n@@ -204,6 +389,8 @@ _Jv_JNI_FatalError (JNIEnv *, const char *message)\n   JvFail (message);\n }\n \n+\f\n+\n static jboolean\n _Jv_JNI_IsSameObject (JNIEnv *, jobject obj1, jobject obj2)\n {\n@@ -224,13 +411,13 @@ _Jv_JNI_AllocObject (JNIEnv *env, jclass clazz)\n       obj = JvAllocObject (clazz);\n     }\n \n-  return obj;\n+  return _Jv_JNI_NewLocalRef (env, obj);\n }\n \n static jclass\n-_Jv_JNI_GetObjectClass (JNIEnv *, jobject obj)\n+_Jv_JNI_GetObjectClass (JNIEnv *env, jobject obj)\n {\n-  return obj->getClass();\n+  return (jclass) _Jv_JNI_NewLocalRef (env, obj->getClass());\n }\n \n static jboolean\n@@ -346,6 +533,14 @@ _Jv_JNI_CallAnyMethodV (JNIEnv *env, jobject obj, jclass klass,\n   if (ex != NULL)\n     env->ex = ex;\n \n+  if (! return_type->isPrimitive ())\n+    {\n+      // Make sure we create a local reference.  The cast hackery is\n+      // to avoid problems for template instantations we know won't be\n+      // used.\n+      return (T) (long long) _Jv_JNI_NewLocalRef (env, result.l);\n+    }\n+\n   // We cheat a little here.  FIXME.\n   return * (T *) &result;\n }\n@@ -390,6 +585,14 @@ _Jv_JNI_CallAnyMethodA (JNIEnv *env, jobject obj, jclass klass,\n   if (ex != NULL)\n     env->ex = ex;\n \n+  if (! return_type->isPrimitive ())\n+    {\n+      // Make sure we create a local reference.  The cast hackery is\n+      // to avoid problems for template instantations we know won't be\n+      // used.\n+      return (T) (long long) _Jv_JNI_NewLocalRef (env, result.l);\n+    }\n+\n   // We cheat a little here.  FIXME.\n   return * (T *) &result;\n }\n@@ -608,6 +811,7 @@ _Jv_JNI_NewObjectA (JNIEnv *env, jclass klass, jmethodID id,\n \n \f\n \n+// FIXME: local reference\n template<typename T>\n static T\n _Jv_JNI_GetField (JNIEnv *, jobject obj, jfieldID field) \n@@ -675,6 +879,7 @@ _Jv_JNI_GetAnyFieldID (JNIEnv *env, jclass clazz,\n   return NULL;\n }\n \n+// FIXME: local reference\n template<typename T>\n static T\n _Jv_JNI_GetStaticField (JNIEnv *, jclass, jfieldID field)\n@@ -692,11 +897,11 @@ _Jv_JNI_SetStaticField (JNIEnv *, jclass, jfieldID field, T value)\n }\n \n static jstring\n-_Jv_JNI_NewString (JNIEnv *, const jchar *unichars, jsize len)\n+_Jv_JNI_NewString (JNIEnv *env, const jchar *unichars, jsize len)\n {\n   // FIXME: exception processing.\n   jstring r = _Jv_NewString (unichars, len);\n-  return r;\n+  return (jstring) _Jv_JNI_NewLocalRef (env, r);\n }\n \n static jsize\n@@ -709,24 +914,24 @@ static const jchar *\n _Jv_JNI_GetStringChars (JNIEnv *, jstring string, jboolean *isCopy)\n {\n   jchar *result = _Jv_GetStringChars (string);\n-  mark_for_gc (result);\n+  mark_for_gc (string);\n   if (isCopy)\n     *isCopy = false;\n   return (const jchar *) result;\n }\n \n static void\n-_Jv_JNI_ReleaseStringChars (JNIEnv *, jstring, const jchar *chars)\n+_Jv_JNI_ReleaseStringChars (JNIEnv *, jstring string, const jchar *)\n {\n-  unmark_for_gc ((void *) chars);\n+  unmark_for_gc (string);\n }\n \n static jstring\n-_Jv_JNI_NewStringUTF (JNIEnv *, const char *bytes)\n+_Jv_JNI_NewStringUTF (JNIEnv *env, const char *bytes)\n {\n   // FIXME: exception processing.\n-  jstring r = JvNewStringUTF (bytes);\n-  return r;\n+  jstring result = JvNewStringUTF (bytes);\n+  return (jstring) _Jv_JNI_NewLocalRef (env, result);\n }\n \n static jsize\n@@ -801,19 +1006,19 @@ _Jv_JNI_GetArrayLength (JNIEnv *, jarray array)\n }\n \n static jarray\n-_Jv_JNI_NewObjectArray (JNIEnv *, jsize length, jclass elementClass,\n+_Jv_JNI_NewObjectArray (JNIEnv *env, jsize length, jclass elementClass,\n \t\t\tjobject init)\n {\n   // FIXME: exception processing.\n   jarray result = JvNewObjectArray (length, elementClass, init);\n-  return result;\n+  return (jarray) _Jv_JNI_NewLocalRef (env, result);\n }\n \n static jobject\n-_Jv_JNI_GetObjectArrayElement (JNIEnv *, jobjectArray array, jsize index)\n+_Jv_JNI_GetObjectArrayElement (JNIEnv *env, jobjectArray array, jsize index)\n {\n   jobject *elts = elements (array);\n-  return elts[index];\n+  return _Jv_JNI_NewLocalRef (env, elts[index]);\n }\n \n static void\n@@ -828,9 +1033,11 @@ _Jv_JNI_SetObjectArrayElement (JNIEnv *, jobjectArray array, jsize index,\n \n template<typename T, jclass K>\n static JArray<T> *\n-_Jv_JNI_NewPrimitiveArray (JNIEnv *, jsize length)\n+_Jv_JNI_NewPrimitiveArray (JNIEnv *env, jsize length)\n {\n-  return (JArray<T> *) _Jv_NewPrimArray (K, length);\n+  // FIXME: exception processing.\n+  return (JArray<T> *) _Jv_JNI_NewLocalRef (env,\n+\t\t\t\t\t    _Jv_NewPrimArray (K, length));\n }\n \n template<typename T>\n@@ -844,19 +1051,19 @@ _Jv_JNI_GetPrimitiveArrayElements (JNIEnv *, JArray<T> *array,\n       // We elect never to copy.\n       *isCopy = false;\n     }\n-  mark_for_gc (elts);\n+  mark_for_gc (array);\n   return elts;\n }\n \n template<typename T>\n static void\n-_Jv_JNI_ReleasePrimitiveArrayElements (JNIEnv *, JArray<T> *,\n-\t\t\t\t       T *elems, jint /* mode */)\n+_Jv_JNI_ReleasePrimitiveArrayElements (JNIEnv *, JArray<T> *array,\n+\t\t\t\t       T *, jint /* mode */)\n {\n   // Note that we ignore MODE.  We can do this because we never copy\n   // the array elements.  My reading of the JNI documentation is that\n   // this is an option for the implementor.\n-  unmark_for_gc (elems);\n+  unmark_for_gc (array);\n }\n \n template<typename T>\n@@ -931,16 +1138,15 @@ _Jv_JNI_MonitorExit (JNIEnv *, jobject obj)\n \n // JDK 1.2\n jobject\n-_Jv_JNI_ToReflectedField (JNIEnv *, jclass cls, jfieldID fieldID,\n+_Jv_JNI_ToReflectedField (JNIEnv *env, jclass cls, jfieldID fieldID,\n \t\t\t  jboolean)\n {\n   // FIXME: exception processing.\n   java::lang::reflect::Field *field = new java::lang::reflect::Field();\n   field->declaringClass = cls;\n   field->offset = (char*) fieldID - (char *) cls->fields;\n   field->name = _Jv_NewStringUtf8Const (fieldID->getNameUtf8Const (cls));\n-  // FIXME: make a local reference.\n-  return field;\n+  return _Jv_JNI_NewLocalRef (env, field);\n }\n \n // JDK 1.2\n@@ -954,7 +1160,7 @@ _Jv_JNI_FromReflectedField (JNIEnv *, jobject f)\n }\n \n jobject\n-_Jv_JNI_ToReflectedMethod (JNIEnv *, jclass klass, jmethodID id,\n+_Jv_JNI_ToReflectedMethod (JNIEnv *env, jclass klass, jmethodID id,\n \t\t\t   jboolean)\n {\n   using namespace java::lang::reflect;\n@@ -979,8 +1185,7 @@ _Jv_JNI_ToReflectedMethod (JNIEnv *, jclass klass, jmethodID id,\n       result = meth;\n     }\n \n-  // FIXME: make a local reference.\n-  return result;\n+  return _Jv_JNI_NewLocalRef (env, result);\n }\n \n static jmethodID\n@@ -1003,13 +1208,26 @@ static T\n _Jv_JNI_conversion_call (fixme)\n {\n   JNIEnv env;\n+  _Jv_JNI_LocalFrame *frame\n+    = (_Jv_JNI_LocalFrame *) alloca (sizeof (_Jv_JNI_LocalFrame)\n+\t\t\t\t     + FRAME_SIZE * sizeof (jobject));\n \n   env.p = &_Jv_JNIFunctions;\n   env.ex = NULL;\n   env.klass = FIXME;\n+  env.locals = frame;\n+\n+  frame->marker = true;\n+  frame->next = NULL;\n+  frame->size = FRAME_SIZE;\n+  for (int i = 0; i < frame->size; ++i)\n+    frame->vec[i] = NULL;\n \n   T result = FIXME_ffi_call (args);\n \n+  while (env.locals != NULL)\n+    _Jv_JNI_PopLocalFrame (&env, result);\n+\n   if (env.ex)\n     JvThrow (env.ex);\n \n@@ -1043,14 +1261,18 @@ struct JNINativeInterface _Jv_JNIFunctions =\n   _Jv_JNI_ExceptionDescribe,\n   _Jv_JNI_ExceptionClear,\n   _Jv_JNI_FatalError,\n-  NOT_IMPL,\n-  NOT_IMPL,\n-  NOT_IMPL /* NewGlobalRef */,\n-  NOT_IMPL /* DeleteGlobalRef */,\n-  NOT_IMPL /* DeleteLocalRef */,\n+\n+  _Jv_JNI_PushLocalFrame,\n+  _Jv_JNI_PopLocalFrame,\n+  _Jv_JNI_NewGlobalRef,\n+  _Jv_JNI_DeleteGlobalRef,\n+  _Jv_JNI_DeleteLocalRef,\n+\n   _Jv_JNI_IsSameObject,\n-  NOT_IMPL,\n-  NOT_IMPL,\n+\n+  _Jv_JNI_NewLocalRef,\n+  _Jv_JNI_EnsureLocalCapacity,\n+\n   _Jv_JNI_AllocObject,\n   _Jv_JNI_NewObject,\n   _Jv_JNI_NewObjectV,"}, {"sha": "5d72f15de650faf738e563a763967d6c15fcea0e", "filename": "libjava/prims.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e648cf95405746284c49f1c5ba88ec8292c3875/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e648cf95405746284c49f1c5ba88ec8292c3875/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=7e648cf95405746284c49f1c5ba88ec8292c3875", "patch": "@@ -687,6 +687,8 @@ main_init ()\n   sigemptyset (&act.sa_mask);\n   act.sa_flags = 0;\n   sigaction (SIGPIPE, &act, NULL);\n+\n+  _Jv_JNI_Init ();\n }\n \n #ifndef DISABLE_GETENV_PROPERTIES\n@@ -915,6 +917,14 @@ _Jv_SetMaximumHeapSize (const char *arg)\n \n \f\n \n+void *\n+_Jv_MallocUnchecked (jsize size)\n+{\n+  if (size == 0)\n+    size = 1;\n+  return malloc ((size_t) size);\n+}\n+\n void *\n _Jv_Malloc (jsize size)\n {"}]}