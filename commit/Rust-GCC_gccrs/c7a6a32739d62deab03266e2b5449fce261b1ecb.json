{"sha": "c7a6a32739d62deab03266e2b5449fce261b1ecb", "node_id": "C_kwDOANBUbNoAKGM3YTZhMzI3MzlkNjJkZWFiMDMyNjZlMmI1NDQ5ZmNlMjYxYjFlY2I", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-03-16T13:34:34Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-03-18T16:50:18Z"}, "message": "c++: alias template and empty parameter packs [PR104008]\n\nZero-length pack expansions are treated as if no list were provided\nat all, that is, with\n\n  template<typename...> struct S { };\n  template<typename T, typename... Ts>\n  void g() {\n    S<std::is_same<T, Ts>...>;\n  }\n\ng<int> will result in S<>.  In the following test we have something\nsimilar:\n\n  template <typename T, typename... Ts>\n  using IsOneOf = disjunction<is_same<T, Ts>...>;\n\nand then we have \"IsOneOf<OtherHolders>...\" where OtherHolders is an\nempty pack.  Since r11-7931, we strip_typedefs in TYPE_PACK_EXPANSION.\nIn this test that results in \"IsOneOf<OtherHolders>\" being turned into\n\"disjunction<>\".  So the whole expansion is now \"disjunction<>...\".  But\nthen we error in make_pack_expansion because find_parameter_packs_r won't\nfind the pack OtherHolders.\n\nWe strip the alias template because dependent_alias_template_spec_p says\nit's not dependent.  It it not dependent because this alias is not\nTEMPLATE_DECL_COMPLEX_ALIAS_P.  My understanding is that currently we\nconsider an alias complex if it\n\n1) expands a pack from the enclosing class, as in\n\n    template<template<typename... U> typename... TT>\n    struct S {\n      template<typename... Args>\n      using X = P<TT<Args...>...>;\n    };\n\n   where the alias expands TT; or\n\n2) the expansion does *not* name all the template parameters, as in\n\n    template<typename...> struct R;\n    template<typename T, typename... Ts>\n    using U = R<X<Ts>...>;\n\n   where T is not named in the expansion.\n\nBut IsOneOf is neither.  And it can't know how it's going to be used.\nTherefore I think we cannot make it complex (and in turn dependent) to fix\nthis bug.\n\nAfter much gnashing of teeth, I think we simply want to avoid stripping\nthe alias if the new pattern doesn't have any parameter packs to expand.\n\n\tPR c++/104008\n\ngcc/cp/ChangeLog:\n\n\t* tree.cc (strip_typedefs): Don't strip an alias template when\n\tdoing so would result in losing a parameter pack.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/variadic-alias3.C: New test.\n\t* g++.dg/cpp0x/variadic-alias4.C: New test.", "tree": {"sha": "643f699758d2d3aa7a5bce4395da9105f3076788", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/643f699758d2d3aa7a5bce4395da9105f3076788"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7a6a32739d62deab03266e2b5449fce261b1ecb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a6a32739d62deab03266e2b5449fce261b1ecb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7a6a32739d62deab03266e2b5449fce261b1ecb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a6a32739d62deab03266e2b5449fce261b1ecb/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c133bdfa9e7d9225510d00dbb7270cc052e4e4ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c133bdfa9e7d9225510d00dbb7270cc052e4e4ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c133bdfa9e7d9225510d00dbb7270cc052e4e4ee"}], "stats": {"total": 106, "additions": 105, "deletions": 1}, "files": [{"sha": "eb59e56610b6f5546283812def4efad298d41c02", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a6a32739d62deab03266e2b5449fce261b1ecb/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a6a32739d62deab03266e2b5449fce261b1ecb/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=c7a6a32739d62deab03266e2b5449fce261b1ecb", "patch": "@@ -1778,7 +1778,18 @@ strip_typedefs (tree t, bool *remove_attributes, unsigned int flags)\n \tif (TYPE_P (pat))\n \t  {\n \t    type = strip_typedefs (pat, remove_attributes, flags);\n-\t    if (type != pat)\n+\t    /* Empty packs can thwart our efforts here.  Consider\n+\n+\t\ttemplate <typename T, typename... Ts>\n+\t\tusing IsOneOf = disjunction<is_same<T, Ts>...>;\n+\n+\t      where IsOneOf seemingly uses all of its template parameters in\n+\t      its expansion (and does not expand a pack from the enclosing\n+\t      class), so the alias is not marked as complex.  However, it may\n+\t      be used as in \"IsOneOf<Ts>\", where Ts is an empty parameter pack,\n+\t      and stripping it down into \"disjunction<>\" here would exclude the\n+\t      Ts pack, resulting in an error.  */\n+\t    if (type != pat && uses_parameter_packs (type))\n \t      {\n \t\tresult = copy_node (t);\n \t\tPACK_EXPANSION_PATTERN (result) = type;"}, {"sha": "6b6dd9f4c85e517c25d285c9e7d26bd024206fe6", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic-alias3.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a6a32739d62deab03266e2b5449fce261b1ecb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-alias3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a6a32739d62deab03266e2b5449fce261b1ecb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-alias3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-alias3.C?ref=c7a6a32739d62deab03266e2b5449fce261b1ecb", "patch": "@@ -0,0 +1,45 @@\n+// PR c++/104008\n+// { dg-do compile { target c++11 } }\n+\n+template <typename...> struct conjunction;\n+template <typename...> struct disjunction;\n+template <typename, typename> struct is_same;\n+template <bool> struct enable_if;\n+template <bool _Cond> using enable_if_t = typename enable_if<_Cond>::type;\n+struct B;\n+struct __uniq_ptr_impl {\n+  struct _Ptr {\n+    using type = B *;\n+  };\n+  using pointer = _Ptr::type;\n+};\n+struct unique_ptr {\n+  using pointer = __uniq_ptr_impl::pointer;\n+  unique_ptr(pointer);\n+};\n+template <typename T, typename... Ts>\n+using IsOneOf = disjunction<is_same<T, Ts>...>;\n+\n+template <typename...> struct any_badge;\n+\n+struct badge {\n+  badge(any_badge<>);\n+  badge();\n+};\n+\n+template <typename...> struct any_badge {\n+  template <typename... OtherHolders,\n+            enable_if_t<conjunction<IsOneOf<OtherHolders>...>::value>>\n+  any_badge();\n+};\n+\n+template <typename, typename... _Args> unique_ptr make_unique(_Args... __args);\n+\n+struct B {\n+  B(badge);\n+  unique_ptr b_ = make_unique<B>(badge{});\n+};\n+\n+template <typename, typename... _Args> unique_ptr make_unique(_Args... __args) {\n+  return new B(__args...);\n+}"}, {"sha": "896a4725627352da200410dc91205a7be4340422", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic-alias4.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a6a32739d62deab03266e2b5449fce261b1ecb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-alias4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a6a32739d62deab03266e2b5449fce261b1ecb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-alias4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-alias4.C?ref=c7a6a32739d62deab03266e2b5449fce261b1ecb", "patch": "@@ -0,0 +1,48 @@\n+// PR c++/104008\n+// { dg-do compile { target c++11 } }\n+// Differs from variadic-alias3.C only in the pattern of a pack expansion\n+// in line 34.  But it's important to check that we also deal with more\n+// complex patterns.\n+\n+template <typename...> struct conjunction;\n+template <typename...> struct disjunction;\n+template <typename, typename> struct is_same;\n+template <bool> struct enable_if;\n+template <bool _Cond> using enable_if_t = typename enable_if<_Cond>::type;\n+struct B;\n+struct __uniq_ptr_impl {\n+  struct _Ptr {\n+    using type = B *;\n+  };\n+  using pointer = _Ptr::type;\n+};\n+struct unique_ptr {\n+  using pointer = __uniq_ptr_impl::pointer;\n+  unique_ptr(pointer);\n+};\n+template <typename T, typename... Ts>\n+using IsOneOf = disjunction<is_same<T, Ts>...>;\n+\n+template <typename...> struct any_badge;\n+\n+struct badge {\n+  badge(any_badge<>);\n+  badge();\n+};\n+\n+template <typename...> struct any_badge {\n+  template <typename... OtherHolders,\n+            enable_if_t<conjunction<IsOneOf<OtherHolders>&...>::value>>\n+  any_badge();\n+};\n+\n+template <typename, typename... _Args> unique_ptr make_unique(_Args... __args);\n+\n+struct B {\n+  B(badge);\n+  unique_ptr b_ = make_unique<B>(badge{});\n+};\n+\n+template <typename, typename... _Args> unique_ptr make_unique(_Args... __args) {\n+  return new B(__args...);\n+}"}]}