{"sha": "18bf656fc370751398d978b977d3d4c406a5246e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThiZjY1NmZjMzcwNzUxMzk4ZDk3OGI5NzdkM2Q0YzQwNmE1MjQ2ZQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1999-09-14T07:39:14Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-09-14T07:39:14Z"}, "message": "regmove.c (fixup_match_1): Don't change an unchanging register.\n\n        * regmove.c (fixup_match_1): Don't change an unchanging register.\n        (stable_but_for_p): Renamed to:\n        (stable_and_no_regs_but_for_p).  Reject unchanging registers too.\n        Changed all callers.\n\nFrom-SVN: r29394", "tree": {"sha": "e931f706c326b0432553be380d76a52377371cba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e931f706c326b0432553be380d76a52377371cba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18bf656fc370751398d978b977d3d4c406a5246e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18bf656fc370751398d978b977d3d4c406a5246e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18bf656fc370751398d978b977d3d4c406a5246e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18bf656fc370751398d978b977d3d4c406a5246e/comments", "author": null, "committer": null, "parents": [{"sha": "328de7dac7ee9534f9245d1a8f8084fbaa6b3451", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/328de7dac7ee9534f9245d1a8f8084fbaa6b3451", "html_url": "https://github.com/Rust-GCC/gccrs/commit/328de7dac7ee9534f9245d1a8f8084fbaa6b3451"}], "stats": {"total": 41, "additions": 33, "deletions": 8}, "files": [{"sha": "37e12e6403b7685c4f2453cab487c2ccdf5eef72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18bf656fc370751398d978b977d3d4c406a5246e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18bf656fc370751398d978b977d3d4c406a5246e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18bf656fc370751398d978b977d3d4c406a5246e", "patch": "@@ -1,3 +1,10 @@\n+Tue Sep 14 01:38:52 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* regmove.c (fixup_match_1): Don't change an unchanging register.\n+\t(stable_but_for_p): Renamed to:\n+\t(stable_and_no_regs_but_for_p).  Reject unchanging registers too.\n+\tChanged all callers.\n+\n Tue Sep 14 01:33:15 1999  Andreas Schwab  <schwab@suse.de>\n \n \t* loop.c (strength_reduce): Don't call reg_used_between_p if the"}, {"sha": "e46eff2819227659348fd2ab36c0e47e533debcf", "filename": "gcc/regmove.c", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18bf656fc370751398d978b977d3d4c406a5246e/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18bf656fc370751398d978b977d3d4c406a5246e/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=18bf656fc370751398d978b977d3d4c406a5246e", "patch": "@@ -63,7 +63,7 @@ static int find_matches PROTO((rtx, struct match *));\n static int fixup_match_1 PROTO((rtx, rtx, rtx, rtx, rtx, int, int, int, FILE *))\n ;\n static int reg_is_remote_constant_p PROTO((rtx, rtx, rtx));\n-static int stable_but_for_p PROTO((rtx, rtx, rtx));\n+static int stable_and_no_regs_but_for_p PROTO((rtx, rtx, rtx));\n static int regclass_compatible_p PROTO((int, int));\n static int loop_depth;\n \n@@ -1675,6 +1675,12 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n   rtx src_note = find_reg_note (insn, REG_DEAD, src), dst_note;\n   int length, s_length, true_loop_depth;\n \n+  /* If SRC is marked as unchanging, we may not change it.\n+     ??? Maybe we could get better code by removing the unchanging bit\n+     instead, and changing it back if we don't succeed?  */\n+  if (RTX_UNCHANGING_P (src))\n+    return 0;\n+\n   if (! src_note)\n     {\n       /* Look for (set (regX) (op regA constX))\n@@ -1691,7 +1697,7 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n \t  && XEXP (SET_SRC (set), 0) == src\n \t  && GET_CODE (XEXP (SET_SRC (set), 1)) == CONST_INT)\n \tinsn_const = INTVAL (XEXP (SET_SRC (set), 1));\n-      else if (! stable_but_for_p (SET_SRC (set), src, dst))\n+      else if (! stable_and_no_regs_but_for_p (SET_SRC (set), src, dst))\n \treturn 0;\n       else\n \t/* We might find a src_note while scanning.  */\n@@ -2113,10 +2119,16 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n }\n \n \n-/* return nonzero if X is stable but for mentioning SRC or mentioning /\n-   changing DST .  If in doubt, presume it is unstable.  */\n+/* return nonzero if X is stable and mentions no regsiters but for\n+   mentioning SRC or mentioning / changing DST .  If in doubt, presume\n+   it is unstable.\n+   The rationale is that we want to check if we can move an insn easily\n+   while just paying attention to SRC and DST.  A register is considered\n+   stable if it has the RTX_UNCHANGING_P bit set, but that would still\n+   leave the burden to update REG_DEAD / REG_UNUSED notes, so we don't\n+   want any registers but SRC and DST.  */\n static int\n-stable_but_for_p (x, src, dst)\n+stable_and_no_regs_but_for_p (x, src, dst)\n      rtx x, src, dst;\n {\n   RTX_CODE code = GET_CODE (x);\n@@ -2127,13 +2139,19 @@ stable_but_for_p (x, src, dst)\n \tint i;\n \tconst char *fmt = GET_RTX_FORMAT (code);\n \tfor (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-\t  if (fmt[i] == 'e' && ! stable_but_for_p (XEXP (x, i), src, dst))\n+\t  if (fmt[i] == 'e'\n+\t      && ! stable_and_no_regs_but_for_p (XEXP (x, i), src, dst))\n \t      return 0;\n \treturn 1;\n       }\n     case 'o':\n-      if (x == src || x == dst)\n-\treturn 1;\n+      if (code == REG)\n+\treturn x == src || x == dst;\n+      /* If this is a MEM, look inside - there might be a register hidden in\n+\t the address of an unchanging MEM.  */\n+      if (code == MEM\n+\t  && ! stable_and_no_regs_but_for_p (XEXP (x, 0), src, dst))\n+\treturn 0;\n       /* fall through */\n     default:\n       return ! rtx_unstable_p (x);"}]}