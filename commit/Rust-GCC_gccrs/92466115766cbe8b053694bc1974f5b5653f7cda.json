{"sha": "92466115766cbe8b053694bc1974f5b5653f7cda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI0NjYxMTU3NjZjYmU4YjA1MzY5NGJjMTk3NGY1YjU2NTNmN2NkYQ==", "commit": {"author": {"name": "Bill Seurer", "email": "seurer@linux.vnet.ibm.com", "date": "2016-05-20T15:25:04Z"}, "committer": {"name": "Bill Seurer", "email": "seurer@gcc.gnu.org", "date": "2016-05-20T15:25:04Z"}, "message": "This patch adds support for the signed and unsigned int versions of the...\n\nThis patch adds support for the signed and unsigned int versions of the\nvec_addec altivec builtins from the Power Architecture 64-Bit ELF V2 ABI\nOpenPOWER ABI for Linux Supplement (16 July 2015 Version 1.1). There are\nmany of the builtins that are missing and this is part of a series\nof patches to add them.\n\nThere aren't instructions for the int versions of vec_addec so the\noutput code is built from other built-ins that do have instructions\nwhich in this case is the following.\n\nvec_addec (va, vb, carryv) == vec_or (vec_addc (va, vb),\n\t\t\t\tvec_addc(vec_add(va, vb),\n\t\t\t\t\t vec_and (carryv, 0x1)))\n\nThe new test cases are executable tests which verify that the generated\ncode produces expected values. C macros were used so that the same\ntest case could be used for both the signed and unsigned versions. An\nextra executable test case is also included to ensure that the modified\nsupport for the __int128 versions of vec_addec is not broken. The same\ntest case could not be used for both int and __int128 because of some\ndifferences in loading and storing the vectors.\n\nBootstrapped and tested on powerpc64le-unknown-linux-gnu and\npowerpc64-unknown-linux-gnu with no regressions. Is this ok for trunk?\n\n[gcc]\n\n2016-05-20  Bill Seurer  <seurer@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000-builtin.def (vec_addec): Change vec_addec to a\n\tspecial case builtin.\n\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin): Add\n\tsupport for ALTIVEC_BUILTIN_VEC_ADDEC.\n\t* config/rs6000/rs6000.c (altivec_init_builtins): Add definition\n\tfor __builtin_vec_addec.\n\n[gcc/testsuite]\n\n2016-05-20  Bill Seurer  <seurer@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/vec-addec.c: New test.\n\t* gcc.target/powerpc/vec-addec-int128.c: New test.\n\nFrom-SVN: r236515", "tree": {"sha": "0880c3512cb9b6968f798f3a246b818039b58584", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0880c3512cb9b6968f798f3a246b818039b58584"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92466115766cbe8b053694bc1974f5b5653f7cda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92466115766cbe8b053694bc1974f5b5653f7cda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92466115766cbe8b053694bc1974f5b5653f7cda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92466115766cbe8b053694bc1974f5b5653f7cda/comments", "author": {"login": "BillSeurer", "id": 8561221, "node_id": "MDQ6VXNlcjg1NjEyMjE=", "avatar_url": "https://avatars.githubusercontent.com/u/8561221?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BillSeurer", "html_url": "https://github.com/BillSeurer", "followers_url": "https://api.github.com/users/BillSeurer/followers", "following_url": "https://api.github.com/users/BillSeurer/following{/other_user}", "gists_url": "https://api.github.com/users/BillSeurer/gists{/gist_id}", "starred_url": "https://api.github.com/users/BillSeurer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BillSeurer/subscriptions", "organizations_url": "https://api.github.com/users/BillSeurer/orgs", "repos_url": "https://api.github.com/users/BillSeurer/repos", "events_url": "https://api.github.com/users/BillSeurer/events{/privacy}", "received_events_url": "https://api.github.com/users/BillSeurer/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a385c2d3d74ffed78f2ed9ad47b844d2f294105", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a385c2d3d74ffed78f2ed9ad47b844d2f294105"}], "stats": {"total": 340, "additions": 339, "deletions": 1}, "files": [{"sha": "f640bb740496f1994ba3aba7b3b8d559559169c4", "filename": "ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92466115766cbe8b053694bc1974f5b5653f7cda/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92466115766cbe8b053694bc1974f5b5653f7cda/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=92466115766cbe8b053694bc1974f5b5653f7cda", "patch": "@@ -1,3 +1,12 @@\n+2016-05-20  Bill Seurer  <seurer@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000-builtin.def (vec_addec): Change vec_addec to a\n+\tspecial case builtin.\n+\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin): Add\n+\tsupport for ALTIVEC_BUILTIN_VEC_ADDEC.\n+\t* config/rs6000/rs6000.c (altivec_init_builtins): Add definition\n+\tfor __builtin_vec_addec.\n+\n 2016-05-16  Jakub Sejdak  <jakub.sejdak@phoesys.com>\n \n \t* config.guess: Import version 2016-04-02 (newest)."}, {"sha": "399d9f695142cbdd782c122873b4ffca5782eb26", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92466115766cbe8b053694bc1974f5b5653f7cda/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92466115766cbe8b053694bc1974f5b5653f7cda/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=92466115766cbe8b053694bc1974f5b5653f7cda", "patch": "@@ -991,7 +991,6 @@ BU_ALTIVEC_X (VEC_EXT_V4SF,\t\"vec_ext_v4sf\",     CONST)\n    before we get to the point about classifying the builtin type.  */\n \n /* 3 argument Altivec overloaded builtins.  */\n-BU_ALTIVEC_OVERLOAD_3 (ADDEC,\t   \"addec\")\n BU_ALTIVEC_OVERLOAD_3 (MADD,       \"madd\")\n BU_ALTIVEC_OVERLOAD_3 (MADDS,      \"madds\")\n BU_ALTIVEC_OVERLOAD_3 (MLADD,      \"mladd\")\n@@ -1177,6 +1176,7 @@ BU_ALTIVEC_OVERLOAD_P (VCMPGE_P,   \"vcmpge_p\")\n \n /* Overloaded Altivec builtins that are handled as special cases.  */\n BU_ALTIVEC_OVERLOAD_X (ADDE,\t   \"adde\")\n+BU_ALTIVEC_OVERLOAD_X (ADDEC,\t   \"addec\")\n BU_ALTIVEC_OVERLOAD_X (CTF,\t   \"ctf\")\n BU_ALTIVEC_OVERLOAD_X (CTS,\t   \"cts\")\n BU_ALTIVEC_OVERLOAD_X (CTU,\t   \"ctu\")"}, {"sha": "d22f6bd2095d79533c92ab29817146de8589c63c", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92466115766cbe8b053694bc1974f5b5653f7cda/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92466115766cbe8b053694bc1974f5b5653f7cda/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=92466115766cbe8b053694bc1974f5b5653f7cda", "patch": "@@ -4661,6 +4661,86 @@ assignment for unaligned loads and stores\");\n \t}\n     }\n \n+  if (fcode == ALTIVEC_BUILTIN_VEC_ADDEC)\n+    {\n+      /* vec_addec needs to be special cased because there is no instruction\n+\tfor the {un}signed int version.  */\n+      if (nargs != 3)\n+\t{\n+\t  error (\"vec_addec only accepts 3 arguments\");\n+\t  return error_mark_node;\n+\t}\n+\n+      tree arg0 = (*arglist)[0];\n+      tree arg0_type = TREE_TYPE (arg0);\n+      tree arg1 = (*arglist)[1];\n+      tree arg1_type = TREE_TYPE (arg1);\n+      tree arg2 = (*arglist)[2];\n+      tree arg2_type = TREE_TYPE (arg2);\n+\n+      /* All 3 arguments must be vectors of (signed or unsigned) (int or\n+\t__int128) and the types must match.  */\n+      if (arg0_type != arg1_type || arg1_type != arg2_type)\n+\tgoto bad;\n+      if (TREE_CODE (arg0_type) != VECTOR_TYPE)\n+\tgoto bad;\n+\n+      switch (TYPE_MODE (TREE_TYPE (arg0_type)))\n+\t{\n+\t  /* For {un}signed ints,\n+\t      vec_addec (va, vb, carryv) ==\n+\t\t\t\tvec_or (vec_addc (va, vb),\n+\t\t\t\t\tvec_addc (vec_add (va, vb),\n+\t\t\t\t\t\t  vec_and (carryv, 0x1))).  */\n+\t  case SImode:\n+\t    {\n+\t    /* Use save_expr to ensure that operands used more than once\n+\t\tthat may have side effects (like calls) are only evaluated\n+\t\tonce.  */\n+\t    arg0 = save_expr (arg0);\n+\t    arg1 = save_expr (arg1);\n+\t    vec<tree, va_gc> *params = make_tree_vector ();\n+\t    vec_safe_push (params, arg0);\n+\t    vec_safe_push (params, arg1);\n+\t    tree addc_builtin = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_ADDC];\n+\t    tree call1 = altivec_resolve_overloaded_builtin (loc, addc_builtin,\n+\t\t\t\t\t\t\t     params);\n+\t    params = make_tree_vector ();\n+\t    vec_safe_push (params, arg0);\n+\t    vec_safe_push (params, arg1);\n+\t    tree add_builtin = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_ADD];\n+\t    tree call2 = altivec_resolve_overloaded_builtin (loc, add_builtin,\n+\t\t\t\t\t\t\t     params);\n+\t    tree const1 = build_int_cstu (TREE_TYPE (arg0_type), 1);\n+\t    tree ones_vector = build_vector_from_val (arg0_type, const1);\n+\t    tree and_expr = fold_build2_loc (loc, BIT_AND_EXPR, arg0_type,\n+\t\t\t\t\t     arg2, ones_vector);\n+\t    params = make_tree_vector ();\n+\t    vec_safe_push (params, call2);\n+\t    vec_safe_push (params, and_expr);\n+\t    call2 = altivec_resolve_overloaded_builtin (loc, addc_builtin,\n+\t\t\t\t\t\t\tparams);\n+\t    params = make_tree_vector ();\n+\t    vec_safe_push (params, call1);\n+\t    vec_safe_push (params, call2);\n+\t    tree or_builtin = rs6000_builtin_decls[ALTIVEC_BUILTIN_VEC_OR];\n+\t    return altivec_resolve_overloaded_builtin (loc, or_builtin,\n+\t\t\t\t\t\t       params);\n+\t    }\n+\t  /* For {un}signed __int128s use the vaddecuq instruction.  */\n+\t  case TImode:\n+\t    {\n+\t    tree VADDECUQ_bii = rs6000_builtin_decls[P8V_BUILTIN_VEC_VADDECUQ];\n+\t    return altivec_resolve_overloaded_builtin (loc, VADDECUQ_bii,\n+\t\t\t\t\t\t       arglist);\n+\t    }\n+\t  /* Types other than {un}signed int and {un}signed __int128\n+\t\tare errors.  */\n+\t  default:\n+\t    goto bad;\n+\t}\n+    }\n+\n   /* For now treat vec_splats and vec_promote as the same.  */\n   if (fcode == ALTIVEC_BUILTIN_VEC_SPLATS\n       || fcode == ALTIVEC_BUILTIN_VEC_PROMOTE)"}, {"sha": "0488db563e66e94784ab28a984d23f7c769dc765", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92466115766cbe8b053694bc1974f5b5653f7cda/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92466115766cbe8b053694bc1974f5b5653f7cda/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=92466115766cbe8b053694bc1974f5b5653f7cda", "patch": "@@ -16557,6 +16557,8 @@ altivec_init_builtins (void)\n \n   def_builtin (\"__builtin_vec_adde\", opaque_ftype_opaque_opaque_opaque,\n \t\tALTIVEC_BUILTIN_VEC_ADDE);\n+  def_builtin (\"__builtin_vec_addec\", opaque_ftype_opaque_opaque_opaque,\n+\t\tALTIVEC_BUILTIN_VEC_ADDEC);\n \n   /* Cell builtins.  */\n   def_builtin (\"__builtin_altivec_lvlx\",  v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVLX);"}, {"sha": "323e69f514cb4a7c0caf40347d3a4f9abe16e294", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92466115766cbe8b053694bc1974f5b5653f7cda/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92466115766cbe8b053694bc1974f5b5653f7cda/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=92466115766cbe8b053694bc1974f5b5653f7cda", "patch": "@@ -1,3 +1,8 @@\n+2016-05-20  Bill Seurer  <seurer@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/vec-addec.c: New test.\n+\t* gcc.target/powerpc/vec-addec-int128.c: New test.\n+\n 2016-05-20  David Malcolm  <dmalcolm@redhat.com>\n \n \t* gcc.dg/plugin/must-tail-call-1.c: New test case."}, {"sha": "f95143a7e0afc18d10e56b8678b9464223230e12", "filename": "gcc/testsuite/gcc.target/powerpc/vec-addec-int128.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92466115766cbe8b053694bc1974f5b5653f7cda/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-addec-int128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92466115766cbe8b053694bc1974f5b5653f7cda/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-addec-int128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-addec-int128.c?ref=92466115766cbe8b053694bc1974f5b5653f7cda", "patch": "@@ -0,0 +1,123 @@\n+/* { dg-do run { target { powerpc64*-*-* } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+\n+/* Test that the vec_addec builtin works as expected.  */\n+\n+#include \"altivec.h\"\n+\n+#define N 4096\n+\n+void abort ();\n+\n+#define define_test_functions(STYPE, NAMESUFFIX) \\\n+\\\n+STYPE result_##NAMESUFFIX[N]; \\\n+STYPE addend1_##NAMESUFFIX[N]; \\\n+STYPE addend2_##NAMESUFFIX[N]; \\\n+STYPE carry_##NAMESUFFIX[N]; \\\n+STYPE expected_##NAMESUFFIX[N]; \\\n+\\\n+__attribute__((noinline)) void vector_tests_##NAMESUFFIX () \\\n+{ \\\n+  vector STYPE v1, v2, v3, tmp; \\\n+  int i; \\\n+  for (i = 0; i < N; i+=16/sizeof (STYPE)) \\\n+    { \\\n+      /* result=carry of addend1+addend2+(carry & 0x1).  */ \\\n+      v1 = (vector STYPE) { addend1_##NAMESUFFIX[i] }; \\\n+      v2 = (vector STYPE) { addend2_##NAMESUFFIX[i] }; \\\n+      v3 = (vector STYPE) { carry_##NAMESUFFIX[i] }; \\\n+\\\n+      tmp = vec_addec (v1, v2, v3); \\\n+      result_##NAMESUFFIX[i] = tmp[0]; \\\n+    } \\\n+} \\\n+\\\n+__attribute__((noinline)) void init_##NAMESUFFIX () \\\n+{ \\\n+  int i; \\\n+  for (i = 0; i < N; ++i) \\\n+    { \\\n+      result_##NAMESUFFIX[i] = 0; \\\n+      if (i%6 == 0) \\\n+\t{ \\\n+\t  addend1_##NAMESUFFIX[i] = ((__int128)0xffffffffffffffff << 64); \\\n+\t  addend2_##NAMESUFFIX[i] =  0xfffffffffffffffe; \\\n+\t  carry_##NAMESUFFIX[i] = 1; \\\n+\t  expected_##NAMESUFFIX[i] = 0; \\\n+\t} \\\n+      else if (i%6 == 1) \\\n+\t{ \\\n+\t  addend1_##NAMESUFFIX[i] = ((__int128)0xffffffffffffffff << 64) + \\\n+\t\t\t\t    0xffffffffffffffff; \\\n+\t  addend2_##NAMESUFFIX[i] = 1; \\\n+\t  carry_##NAMESUFFIX[i] = 0; \\\n+\t  expected_##NAMESUFFIX[i] = 1; \\\n+\t} \\\n+      else if (i%6 == 2) \\\n+\t{ \\\n+\t  addend1_##NAMESUFFIX[i] = ((__int128)0xffffffffffffffff << 64) + \\\n+\t\t\t\t    0xffffffffffffffff; \\\n+\t  addend2_##NAMESUFFIX[i] = 0; \\\n+\t  carry_##NAMESUFFIX[i] = 3; /* 3 should work like 1 here.  */ \\\n+\t  expected_##NAMESUFFIX[i] = 1; \\\n+\t}  \\\n+      else if (i%6 == 3) \\\n+\t{ \\\n+\t  addend1_##NAMESUFFIX[i] = 1; \\\n+\t  addend2_##NAMESUFFIX[i] = ((__int128)0xffffffffffffffff << 64) + \\\n+\t\t\t\t    0xffffffffffffffff; \\\n+\t  carry_##NAMESUFFIX[i] = 2; /* 2 should work like 0 here.  */ \\\n+\t  expected_##NAMESUFFIX[i] = 1; \\\n+\t} \\\n+      else if (i%6 == 4) \\\n+\t{ \\\n+\t  addend1_##NAMESUFFIX[i] = 0; \\\n+\t  addend2_##NAMESUFFIX[i] = ((__int128)0xffffffffffffffff << 64) + \\\n+\t\t\t\t    0xffffffffffffffff; \\\n+\t  carry_##NAMESUFFIX[i] = 1; \\\n+\t  expected_##NAMESUFFIX[i] = 1; \\\n+\t} \\\n+      else if (i%6 == 5) \\\n+\t{ \\\n+\t  addend1_##NAMESUFFIX[i] = ((__int128)0xffffffffffffffff << 64); \\\n+\t  addend2_##NAMESUFFIX[i] = 0xffffffffffffffff; \\\n+\t  carry_##NAMESUFFIX[i] = 1; \\\n+\t  expected_##NAMESUFFIX[i] = 1; \\\n+\t} \\\n+    } \\\n+} \\\n+\\\n+__attribute__((noinline)) void verify_results_##NAMESUFFIX () \\\n+{ \\\n+  int i; \\\n+  for (i = 0; i < N; ++i) \\\n+    { \\\n+      if (result_##NAMESUFFIX[i] != expected_##NAMESUFFIX[i]) \\\n+\tabort (); \\\n+    } \\\n+}\n+\n+\n+#define execute_test_functions(STYPE, NAMESUFFIX) \\\n+{ \\\n+  init_##NAMESUFFIX (); \\\n+  vector_tests_##NAMESUFFIX (); \\\n+  verify_results_##NAMESUFFIX (); \\\n+}\n+\n+\n+define_test_functions (signed __int128, si128);\n+define_test_functions (unsigned __int128, ui128);\n+\n+int main ()\n+{\n+  execute_test_functions (signed __int128, si128);\n+  execute_test_functions (unsigned __int128, ui128);\n+\n+  return 0;\n+}\n+\n+"}, {"sha": "53bd41f4b91f07bd2105e6f06d1e020680d69681", "filename": "gcc/testsuite/gcc.target/powerpc/vec-addec.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92466115766cbe8b053694bc1974f5b5653f7cda/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-addec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92466115766cbe8b053694bc1974f5b5653f7cda/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-addec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-addec.c?ref=92466115766cbe8b053694bc1974f5b5653f7cda", "patch": "@@ -0,0 +1,119 @@\n+/* { dg-do run { target { powerpc64*-*-* } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+\n+/* Test that the vec_addec builtin works as expected.  */\n+\n+#include \"altivec.h\"\n+\n+#define N 4096\n+\n+void abort ();\n+\n+#define define_test_functions(STYPE, NAMESUFFIX) \\\n+\\\n+STYPE result_##NAMESUFFIX[N]; \\\n+STYPE addend1_##NAMESUFFIX[N]; \\\n+STYPE addend2_##NAMESUFFIX[N]; \\\n+STYPE carry_##NAMESUFFIX[N]; \\\n+STYPE expected_##NAMESUFFIX[N]; \\\n+\\\n+__attribute__((noinline)) void vector_tests_##NAMESUFFIX () \\\n+{ \\\n+  vector STYPE v1, v2, v3, tmp; \\\n+  int i; \\\n+  for (i = 0; i < N; i+=16/sizeof (STYPE)) \\\n+    { \\\n+      /* result=carry of addend1+addend2+(carry & 0x1).  */ \\\n+      v1 = vec_vsx_ld (0, &addend1_##NAMESUFFIX[i]); \\\n+      v2 = vec_vsx_ld (0, &addend2_##NAMESUFFIX[i]); \\\n+      v3 = vec_vsx_ld (0, &carry_##NAMESUFFIX[i]); \\\n+\\\n+      tmp = vec_addec (v1, v2, v3); \\\n+      vec_vsx_st (tmp, 0, &result_##NAMESUFFIX[i]); \\\n+    } \\\n+} \\\n+\\\n+__attribute__((noinline)) void init_##NAMESUFFIX () \\\n+{ \\\n+  int i; \\\n+  for (i = 0; i < N; ++i) \\\n+    { \\\n+      result_##NAMESUFFIX[i] = 0; \\\n+      if (i%6 == 0) \\\n+\t{ \\\n+\t  addend1_##NAMESUFFIX[i] = 0xfffffffd; \\\n+\t  addend2_##NAMESUFFIX[i] =  1; \\\n+\t  carry_##NAMESUFFIX[i] = 1; \\\n+\t  expected_##NAMESUFFIX[i] = 0; \\\n+\t} \\\n+      else if (i%6 == 1) \\\n+\t{ \\\n+\t  addend1_##NAMESUFFIX[i] = 0xffffffff; \\\n+\t  addend2_##NAMESUFFIX[i] = 1; \\\n+\t  carry_##NAMESUFFIX[i] = 0; \\\n+\t  expected_##NAMESUFFIX[i] = 1; \\\n+\t} \\\n+      else if (i%6 == 2) \\\n+\t{ \\\n+\t  addend1_##NAMESUFFIX[i] = 0xffffffff; \\\n+\t  addend2_##NAMESUFFIX[i] = 0; \\\n+\t  carry_##NAMESUFFIX[i] = 3; /* 3 should work like 1 here.  */ \\\n+\t  expected_##NAMESUFFIX[i] = 1; \\\n+\t} \\\n+      else if (i%6 == 3) \\\n+\t{ \\\n+\t  addend1_##NAMESUFFIX[i] = 1; \\\n+\t  addend2_##NAMESUFFIX[i] = 0xffffffff; \\\n+\t  carry_##NAMESUFFIX[i] = 2; /* 2 should work like 0 here.  */ \\\n+\t  expected_##NAMESUFFIX[i] = 1; \\\n+\t} \\\n+      else if (i%6 == 4) \\\n+\t{ \\\n+\t  addend1_##NAMESUFFIX[i] = 0; \\\n+\t  addend2_##NAMESUFFIX[i] = 0xffffffff; \\\n+\t  carry_##NAMESUFFIX[i] = 1; \\\n+\t  expected_##NAMESUFFIX[i] = 1; \\\n+\t} \\\n+      else if (i%6 == 5) \\\n+\t{ \\\n+\t  addend1_##NAMESUFFIX[i] = 0xffff0000; \\\n+\t  addend2_##NAMESUFFIX[i] = 0x0000ffff; \\\n+\t  carry_##NAMESUFFIX[i] = 1; \\\n+\t  expected_##NAMESUFFIX[i] = 1; \\\n+\t} \\\n+    } \\\n+} \\\n+\\\n+__attribute__((noinline)) void verify_results_##NAMESUFFIX () \\\n+{ \\\n+  int i; \\\n+  for (i = 0; i < N; ++i) \\\n+    { \\\n+      if (result_##NAMESUFFIX[i] != expected_##NAMESUFFIX[i]) \\\n+\tabort (); \\\n+    } \\\n+}\n+\n+\n+#define execute_test_functions(STYPE, NAMESUFFIX) \\\n+{ \\\n+  init_##NAMESUFFIX (); \\\n+  vector_tests_##NAMESUFFIX (); \\\n+  verify_results_##NAMESUFFIX (); \\\n+}\n+\n+\n+define_test_functions (signed int, si);\n+define_test_functions (unsigned int, ui);\n+\n+int main ()\n+{\n+  execute_test_functions (signed int, si);\n+  execute_test_functions (unsigned int, ui);\n+\n+  return 0;\n+}\n+\n+"}]}