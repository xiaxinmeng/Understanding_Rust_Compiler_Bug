{"sha": "998511a6100212931d039e3a46403d2d878c8e5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk4NTExYTYxMDAyMTI5MzFkMDM5ZTNhNDY0MDNkMmQ4NzhjOGU1YQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-09-18T20:18:09Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-09-18T20:18:09Z"}, "message": "re PR fortran/29550 (Optimize -fexternal-blas calls for conjg())\n\n2018-09-18  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/29550\n\t* gfortran.h (gfc_expr): Add external_blas flag.\n\t* frontend-passes.c (matrix_case): Add case A2TB2T.\n\t(optimize_namespace): Handle flag_external_blas by\n\tcalling call_external_blas.\n\t(get_array_inq_function): Add argument okind. If\n\tit is nonzero, use it as the kind of argument\n\tto be used.\n\t(inline_limit_check): Remove m_case argument, add\n\tlimit argument instead.  Remove assert about m_case.\n\tSet the limit for inlining from the limit argument.\n\t(matmul_lhs_realloc): Handle case A2TB2T.\n\t(inline_matmul_assign): Handle inline limit for other cases with\n\ttwo rank-two matrices.  Remove no-op calls to inline_limit_check.\n\t(call_external_blas): New function.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_funcall): Do not add\n\targument to external BLAS if external_blas is already set.\n\n2018-09-18  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/29550\n\t* gfortran.dg/inline_matmul_13.f90: Adjust count for\n\t_gfortran_matmul.\n\t* gfortran.dg/inline_matmul_16.f90: Likewise.\n\t* gfortran.dg/promotion_2.f90: Add -fblas-matmul-limit=1.  Scan\n\tfor dgemm instead of dgemm_.  Add call to random_number to make\n\tstandard conforming.\n\t* gfortran.dg/matmul_blas_1.f90: New test.\n\t* gfortran.dg/matmul_bounds_14.f: New test.\n\t* gfortran.dg/matmul_bounds_15.f: New test.\n\t* gfortran.dg/matmul_bounds_16.f: New test.\n\t* gfortran.dg/blas_gemm_routines.f: New test / additional file for\n\tpreceding tests.\n\nFrom-SVN: r264412", "tree": {"sha": "70e69614c308f81a76996bb4aac9fafffce58837", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70e69614c308f81a76996bb4aac9fafffce58837"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/998511a6100212931d039e3a46403d2d878c8e5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/998511a6100212931d039e3a46403d2d878c8e5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/998511a6100212931d039e3a46403d2d878c8e5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/998511a6100212931d039e3a46403d2d878c8e5a/comments", "author": null, "committer": null, "parents": [{"sha": "5c470e0f07563c3ab540c0a9f40b8a6ac4a29f07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c470e0f07563c3ab540c0a9f40b8a6ac4a29f07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c470e0f07563c3ab540c0a9f40b8a6ac4a29f07"}], "stats": {"total": 2723, "additions": 2701, "deletions": 22}, "files": [{"sha": "2a65b52fad72ce53e32ae1deb7367daab4025fb5", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 439, "deletions": 17, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=998511a6100212931d039e3a46403d2d878c8e5a", "patch": "@@ -53,6 +53,7 @@ static gfc_code * create_do_loop (gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t\t\t  char *vname=NULL);\n static gfc_expr* check_conjg_transpose_variable (gfc_expr *, bool *,\n \t\t\t\t\t\t bool *);\n+static int call_external_blas (gfc_code **, int *, void *);\n static bool has_dimen_vector_ref (gfc_expr *);\n static int matmul_temp_args (gfc_code **, int *,void *data);\n static int index_interchange (gfc_code **, int*, void *);\n@@ -131,7 +132,7 @@ static int var_num = 1;\n \n /* What sort of matrix we are dealing with when inlining MATMUL.  */\n \n-enum matrix_case { none=0, A2B2, A2B1, A1B2, A2B2T, A2TB2 };\n+enum matrix_case { none=0, A2B2, A2B1, A1B2, A2B2T, A2TB2, A2TB2T };\n \n /* Keep track of the number of expressions we have inserted so far\n    using create_var.  */\n@@ -1428,7 +1429,7 @@ optimize_namespace (gfc_namespace *ns)\n       gfc_code_walker (&ns->code, convert_elseif, dummy_expr_callback, NULL);\n       gfc_code_walker (&ns->code, cfe_code, cfe_expr_0, NULL);\n       gfc_code_walker (&ns->code, optimize_code, optimize_expr, NULL);\n-      if (flag_inline_matmul_limit != 0)\n+      if (flag_inline_matmul_limit != 0 || flag_external_blas)\n \t{\n \t  bool found;\n \t  do\n@@ -1441,9 +1442,15 @@ optimize_namespace (gfc_namespace *ns)\n \n \t  gfc_code_walker (&ns->code, matmul_temp_args, dummy_expr_callback,\n \t\t\t   NULL);\n-\t  gfc_code_walker (&ns->code, inline_matmul_assign, dummy_expr_callback,\n-\t\t\t   NULL);\n \t}\n+\n+      if (flag_external_blas)\n+\tgfc_code_walker (&ns->code, call_external_blas, dummy_expr_callback,\n+\t\t\t NULL);\n+\n+      if (flag_inline_matmul_limit != 0)\n+\tgfc_code_walker (&ns->code, inline_matmul_assign, dummy_expr_callback,\n+\t\t\t NULL);\n     }\n \n   if (flag_frontend_loop_interchange)\n@@ -2938,7 +2945,7 @@ matmul_temp_args (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n    dim is zero-based.  */\n \n static gfc_expr *\n-get_array_inq_function (gfc_isym_id id, gfc_expr *e, int dim)\n+get_array_inq_function (gfc_isym_id id, gfc_expr *e, int dim, int okind = 0)\n {\n   gfc_expr *fcn;\n   gfc_expr *dim_arg, *kind;\n@@ -2964,8 +2971,12 @@ get_array_inq_function (gfc_isym_id id, gfc_expr *e, int dim)\n     }\n \n   dim_arg =  gfc_get_int_expr (gfc_default_integer_kind, &e->where, dim);\n-  kind = gfc_get_int_expr (gfc_default_integer_kind, &e->where,\n-\t\t\t   gfc_index_integer_kind);\n+  if (okind != 0)\n+    kind = gfc_get_int_expr (gfc_default_integer_kind, &e->where,\n+\t\t\t     okind);\n+  else\n+    kind = gfc_get_int_expr (gfc_default_integer_kind, &e->where,\n+\t\t\t     gfc_index_integer_kind);\n \n   ec = gfc_copy_expr (e);\n \n@@ -3026,22 +3037,19 @@ get_operand (gfc_intrinsic_op op, gfc_expr *e1, gfc_expr *e2)\n    removed by DCE. Only called for rank-two matrices A and B.  */\n \n static gfc_code *\n-inline_limit_check (gfc_expr *a, gfc_expr *b, enum matrix_case m_case)\n+inline_limit_check (gfc_expr *a, gfc_expr *b, int limit)\n {\n   gfc_expr *inline_limit;\n   gfc_code *if_1, *if_2, *else_2;\n   gfc_expr *b2, *a2, *a1, *m1, *m2;\n   gfc_typespec ts;\n   gfc_expr *cond;\n \n-  gcc_assert (m_case == A2B2 || m_case == A2B2T || m_case == A2TB2);\n-\n   /* Calculation is done in real to avoid integer overflow.  */\n \n   inline_limit = gfc_get_constant_expr (BT_REAL, gfc_default_real_kind,\n \t\t\t\t\t&a->where);\n-  mpfr_set_si (inline_limit->value.real, flag_inline_matmul_limit,\n-\t       GFC_RND_MODE);\n+  mpfr_set_si (inline_limit->value.real, limit, GFC_RND_MODE);\n   mpfr_pow_ui (inline_limit->value.real, inline_limit->value.real, 3,\n \t       GFC_RND_MODE);\n \n@@ -3235,6 +3243,22 @@ matmul_lhs_realloc (gfc_expr *c, gfc_expr *a, gfc_expr *b,\n \t\t\t\t get_array_inq_function (GFC_ISYM_SIZE, b, 2));\n       break;\n \n+    case A2TB2T:\n+      /* This can only happen for BLAS, we do not handle that case in\n+\t inline mamtul.  */\n+      ar->start[0] = get_array_inq_function (GFC_ISYM_SIZE, a, 2);\n+      ar->start[1] = get_array_inq_function (GFC_ISYM_SIZE, b, 1);\n+\n+      ne1 = build_logical_expr (INTRINSIC_NE,\n+\t\t\t\tget_array_inq_function (GFC_ISYM_SIZE, c, 1),\n+\t\t\t\tget_array_inq_function (GFC_ISYM_SIZE, a, 2));\n+      ne2 = build_logical_expr (INTRINSIC_NE,\n+\t\t\t\tget_array_inq_function (GFC_ISYM_SIZE, c, 2),\n+\t\t\t\tget_array_inq_function (GFC_ISYM_SIZE, b, 1));\n+\n+      cond = build_logical_expr (INTRINSIC_OR, ne1, ne2);\n+      break;\n+\n     default:\n       gcc_unreachable();\n \n@@ -3946,9 +3970,11 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n   /* Take care of the inline flag.  If the limit check evaluates to a\n      constant, dead code elimination will eliminate the unneeded branch.  */\n \n-  if (m_case == A2B2 && flag_inline_matmul_limit > 0)\n+  if (flag_inline_matmul_limit > 0 && matrix_a->rank == 2\n+      && matrix_b->rank == 2)\n     {\n-      if_limit = inline_limit_check (matrix_a, matrix_b, m_case);\n+      if_limit = inline_limit_check (matrix_a, matrix_b,\n+\t\t\t\t     flag_inline_matmul_limit);\n \n       /* Insert the original statement into the else branch.  */\n       if_limit->block->block->next = co;\n@@ -4118,7 +4144,6 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n   switch (m_case)\n     {\n     case A2B2:\n-      inline_limit_check (matrix_a, matrix_b, m_case);\n \n       u1 = get_size_m1 (matrix_b, 2);\n       u2 = get_size_m1 (matrix_a, 2);\n@@ -4151,7 +4176,6 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n       break;\n \n     case A2B2T:\n-      inline_limit_check (matrix_a, matrix_b, m_case);\n \n       u1 = get_size_m1 (matrix_b, 1);\n       u2 = get_size_m1 (matrix_a, 2);\n@@ -4184,7 +4208,6 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n       break;\n \n     case A2TB2:\n-      inline_limit_check (matrix_a, matrix_b, m_case);\n \n       u1 = get_size_m1 (matrix_a, 2);\n       u2 = get_size_m1 (matrix_b, 2);\n@@ -4311,6 +4334,405 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n   return 0;\n }\n \n+/* Change matmul function calls in the form of\n+\n+   c = matmul(a,b)\n+\n+   to the corresponding call to a BLAS routine, if applicable.  */\n+\n+static int\n+call_external_blas (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t    void *data ATTRIBUTE_UNUSED)\n+{\n+  gfc_code *co, *co_next;\n+  gfc_expr *expr1, *expr2;\n+  gfc_expr *matrix_a, *matrix_b;\n+  gfc_code *if_limit = NULL;\n+  gfc_actual_arglist *a, *b;\n+  bool conjg_a, conjg_b, transpose_a, transpose_b;\n+  gfc_code *call;\n+  const char *blas_name;\n+  const char *transa, *transb;\n+  gfc_expr *c1, *c2, *b1;\n+  gfc_actual_arglist *actual, *next;\n+  bt type;\n+  int kind;\n+  enum matrix_case m_case;\n+  bool realloc_c;\n+  gfc_code **next_code_point;\n+\n+  /* Many of the tests for inline matmul also apply here.  */\n+\n+  co = *c;\n+\n+  if (co->op != EXEC_ASSIGN)\n+    return 0;\n+\n+  if (in_where || in_assoc_list)\n+    return 0;\n+\n+  /* The BLOCKS generated for the temporary variables and FORALL don't\n+     mix.  */\n+  if (forall_level > 0)\n+    return 0;\n+\n+  /* For now don't do anything in OpenMP workshare, it confuses\n+     its translation, which expects only the allowed statements in there. */\n+\n+  if (in_omp_workshare)\n+    return 0;\n+\n+  expr1 = co->expr1;\n+  expr2 = co->expr2;\n+  if (expr2->expr_type != EXPR_FUNCTION\n+      || expr2->value.function.isym == NULL\n+      || expr2->value.function.isym->id != GFC_ISYM_MATMUL)\n+    return 0;\n+\n+  type = expr2->ts.type;\n+  kind = expr2->ts.kind;\n+\n+  /* Guard against recursion. */\n+\n+  if (expr2->external_blas)\n+    return 0;\n+\n+  if (type != expr1->ts.type || kind != expr1->ts.kind)\n+    return 0;\n+\n+  if (type == BT_REAL)\n+    {\n+      if (kind == 4)\n+\tblas_name = \"sgemm\";\n+      else if (kind == 8)\n+\tblas_name = \"dgemm\";\n+      else\n+\treturn 0;\n+    }\n+  else if (type == BT_COMPLEX)\n+    {\n+      if (kind == 4)\n+\tblas_name = \"cgemm\";\n+      else if (kind == 8)\n+\tblas_name = \"zgemm\";\n+      else\n+\treturn 0;\n+    }\n+  else\n+    return 0;\n+\n+  a = expr2->value.function.actual;\n+  if (a->expr->rank != 2)\n+    return 0;\n+\n+  b = a->next;\n+  if (b->expr->rank != 2)\n+    return 0;\n+\n+  matrix_a = check_conjg_transpose_variable (a->expr, &conjg_a, &transpose_a);\n+  if (matrix_a == NULL)\n+    return 0;\n+\n+  if (transpose_a)\n+    {\n+      if (conjg_a)\n+\ttransa = \"C\";\n+      else\n+\ttransa = \"T\";\n+    }\n+  else\n+    transa = \"N\";\n+\n+  matrix_b = check_conjg_transpose_variable (b->expr, &conjg_b, &transpose_b);\n+  if (matrix_b == NULL)\n+    return 0;\n+\n+  if (transpose_b)\n+    {\n+      if (conjg_b)\n+\ttransb = \"C\";\n+      else\n+\ttransb = \"T\";\n+    }\n+  else\n+    transb = \"N\";\n+\n+  if (transpose_a)\n+    {\n+      if (transpose_b)\n+\tm_case = A2TB2T;\n+      else\n+\tm_case = A2TB2;\n+    }\n+  else\n+    {\n+      if (transpose_b)\n+\tm_case = A2B2T;\n+      else\n+\tm_case = A2B2;\n+    }\n+\n+  current_code = c;\n+  inserted_block = NULL;\n+  changed_statement = NULL;\n+\n+  expr2->external_blas = 1;\n+\n+  /* We do not handle data dependencies yet.  */\n+  if (gfc_check_dependency (expr1, matrix_a, true)\n+      || gfc_check_dependency (expr1, matrix_b, true))\n+    return 0;\n+\n+  /* Generate the if statement and hang it into the tree.  */\n+  if_limit = inline_limit_check (matrix_a, matrix_b, flag_blas_matmul_limit);\n+  co_next = co->next;\n+  (*current_code) = if_limit;\n+  co->next = NULL;\n+  if_limit->block->next = co;\n+\n+  call = XCNEW (gfc_code);\n+  call->loc = co->loc;\n+\n+  /* Bounds checking - a bit simpler than for inlining since we only\n+     have to take care of two-dimensional arrays here.  */\n+\n+  realloc_c = flag_realloc_lhs && gfc_is_reallocatable_lhs (expr1);\n+  next_code_point = &(if_limit->block->block->next);\n+\n+  if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n+    {\n+      gfc_code *test;\n+      //      gfc_expr *a2, *b1, *c1, *c2, *a1, *b2;\n+      gfc_expr *c1, *a1, *c2, *b2, *a2;\n+      switch (m_case)\n+\t{\n+\tcase A2B2:\n+\t  b1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 1);\n+\t  a2 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 2);\n+\t  test = runtime_error_ne (b1, a2, B_ERROR(1));\n+\t  *next_code_point = test;\n+\t  next_code_point = &test->next;\n+\n+\t  if (!realloc_c)\n+\t    {\n+\t      c1 = get_array_inq_function (GFC_ISYM_SIZE, expr1, 1);\n+\t      a1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 1);\n+\t      test = runtime_error_ne (c1, a1, C_ERROR(1));\n+\t      *next_code_point = test;\n+\t      next_code_point = &test->next;\n+\n+\t      c2 = get_array_inq_function (GFC_ISYM_SIZE, expr1, 2);\n+\t      b2 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 2);\n+\t      test = runtime_error_ne (c2, b2, C_ERROR(2));\n+\t      *next_code_point = test;\n+\t      next_code_point = &test->next;\n+\t    }\n+\t  break;\n+\n+\tcase A2B2T:\n+\n+\t  b2 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 2);\n+\t  a2 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 2);\n+\t  /* matrix_b is transposed, hence dimension 1 for the error message.  */\n+\t  test = runtime_error_ne (b2, a2, B_ERROR(1));\n+\t  *next_code_point = test;\n+\t  next_code_point = &test->next;\n+\n+\t  if (!realloc_c)\n+\t    {\n+\t      c1 = get_array_inq_function (GFC_ISYM_SIZE, expr1, 1);\n+\t      a1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 1);\n+\t      test = runtime_error_ne (c1, a1, C_ERROR(1));\n+\t      *next_code_point = test;\n+\t      next_code_point = &test->next;\n+\n+\t      c2 = get_array_inq_function (GFC_ISYM_SIZE, expr1, 2);\n+\t      b1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 1);\n+\t      test = runtime_error_ne (c2, b1, C_ERROR(2));\n+\t      *next_code_point = test;\n+\t      next_code_point = &test->next;\n+\t    }\n+\t  break;\n+\n+\tcase A2TB2:\n+\n+\t  b1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 1);\n+\t  a1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 1);\n+\t  test = runtime_error_ne (b1, a1, B_ERROR(1));\n+\t  *next_code_point = test;\n+\t  next_code_point = &test->next;\n+\n+\t  if (!realloc_c)\n+\t    {\n+\t      c1 = get_array_inq_function (GFC_ISYM_SIZE, expr1, 1);\n+\t      a2 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 2);\n+\t      test = runtime_error_ne (c1, a2, C_ERROR(1));\n+\t      *next_code_point = test;\n+\t      next_code_point = &test->next;\n+\n+\t      c2 = get_array_inq_function (GFC_ISYM_SIZE, expr1, 2);\n+\t      b2 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 2);\n+\t      test = runtime_error_ne (c2, b2, C_ERROR(2));\n+\t      *next_code_point = test;\n+\t      next_code_point = &test->next;\n+\t    }\n+\t  break;\n+\n+\tcase A2TB2T:\n+\t  b2 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 2);\n+\t  a1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 1);\n+\t  test = runtime_error_ne (b2, a1, B_ERROR(1));\n+\t  *next_code_point = test;\n+\t  next_code_point = &test->next;\n+\n+\t  if (!realloc_c)\n+\t    {\n+\t      c1 = get_array_inq_function (GFC_ISYM_SIZE, expr1, 1);\n+\t      a2 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 2);\n+\t      test = runtime_error_ne (c1, a2, C_ERROR(1));\n+\t      *next_code_point = test;\n+\t      next_code_point = &test->next;\n+\n+\t      c2 = get_array_inq_function (GFC_ISYM_SIZE, expr1, 2);\n+\t      b1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 1);\n+\t      test = runtime_error_ne (c2, b1, C_ERROR(2));\n+\t      *next_code_point = test;\n+\t      next_code_point = &test->next;\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }    \n+\n+  /* Handle the reallocation, if needed.  */\n+\n+  if (realloc_c)\n+    {\n+      gfc_code *lhs_alloc;\n+\n+      lhs_alloc = matmul_lhs_realloc (expr1, matrix_a, matrix_b, m_case);\n+      *next_code_point = lhs_alloc;\n+      next_code_point = &lhs_alloc->next;\n+    }\n+\n+  *next_code_point = call;\n+  if_limit->next = co_next;\n+\n+  /* Set up the BLAS call.  */\n+\n+  call->op = EXEC_CALL;\n+\n+  gfc_get_sym_tree (blas_name, current_ns, &(call->symtree), true);\n+  call->symtree->n.sym->attr.subroutine = 1;\n+  call->symtree->n.sym->attr.procedure = 1;\n+  call->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n+  call->resolved_sym = call->symtree->n.sym;\n+\n+  /* Argument TRANSA.  */\n+  next = gfc_get_actual_arglist ();\n+  next->expr = gfc_get_character_expr (gfc_default_character_kind, &co->loc,\n+\t\t\t\t       transa, 1);\n+\n+  call->ext.actual = next;\n+\n+  /* Argument TRANSB.  */\n+  actual = next;\n+  next = gfc_get_actual_arglist ();\n+  next->expr = gfc_get_character_expr (gfc_default_character_kind, &co->loc,\n+\t\t\t\t       transb, 1);\n+  actual->next = next;\n+\n+  c1 = get_array_inq_function (GFC_ISYM_SIZE, gfc_copy_expr (a->expr), 1,\n+\t\t\t       gfc_integer_4_kind);\n+  c2 = get_array_inq_function (GFC_ISYM_SIZE, gfc_copy_expr (b->expr), 2,\n+\t\t\t       gfc_integer_4_kind);\n+\n+  b1 = get_array_inq_function (GFC_ISYM_SIZE, gfc_copy_expr (b->expr), 1,\n+\t\t\t       gfc_integer_4_kind);\n+\n+  /* Argument M. */\n+  actual = next;\n+  next = gfc_get_actual_arglist ();\n+  next->expr = c1;\n+  actual->next = next;\n+\n+  /* Argument N. */\n+  actual = next;\n+  next = gfc_get_actual_arglist ();\n+  next->expr = c2;\n+  actual->next = next;\n+\n+  /* Argument K.  */\n+  actual = next;\n+  next = gfc_get_actual_arglist ();\n+  next->expr = b1;\n+  actual->next = next;\n+\n+  /* Argument ALPHA - set to one.  */\n+  actual = next;\n+  next = gfc_get_actual_arglist ();\n+  next->expr = gfc_get_constant_expr (type, kind, &co->loc);\n+  if (type == BT_REAL)\n+    mpfr_set_ui (next->expr->value.real, 1, GFC_RND_MODE);\n+  else\n+    mpc_set_ui (next->expr->value.complex, 1, GFC_MPC_RND_MODE);\n+  actual->next = next;\n+\n+  /* Argument A.  */\n+  actual = next;\n+  next = gfc_get_actual_arglist ();\n+  next->expr = gfc_copy_expr (matrix_a);\n+  actual->next = next;\n+\n+  /* Argument LDA.  */\n+  actual = next;\n+  next = gfc_get_actual_arglist ();\n+  next->expr = get_array_inq_function (GFC_ISYM_SIZE, gfc_copy_expr (matrix_a),\n+\t\t\t\t       1, gfc_integer_4_kind);\n+  actual->next = next;\n+\n+  /* Argument B.  */\n+  actual = next;\n+  next = gfc_get_actual_arglist ();\n+  next->expr = gfc_copy_expr (matrix_b);\n+  actual->next = next;\n+\n+  /* Argument LDB.  */\n+  actual = next;\n+  next = gfc_get_actual_arglist ();\n+  next->expr = get_array_inq_function (GFC_ISYM_SIZE, gfc_copy_expr (matrix_b),\n+\t\t\t\t       1, gfc_integer_4_kind);\n+  actual->next = next;\n+\n+  /* Argument BETA - set to zero.  */\n+  actual = next;\n+  next = gfc_get_actual_arglist ();\n+  next->expr = gfc_get_constant_expr (type, kind, &co->loc);\n+  if (type == BT_REAL)\n+    mpfr_set_ui (next->expr->value.real, 0, GFC_RND_MODE);\n+  else\n+    mpc_set_ui (next->expr->value.complex, 0, GFC_MPC_RND_MODE);\n+  actual->next = next;\n+\n+  /* Argument C.  */\n+\n+  actual = next;\n+  next = gfc_get_actual_arglist ();\n+  next->expr = gfc_copy_expr (expr1);\n+  actual->next = next;\n+\n+  /* Argument LDC.  */\n+  actual = next;\n+  next = gfc_get_actual_arglist ();\n+  next->expr = get_array_inq_function (GFC_ISYM_SIZE, gfc_copy_expr (expr1),\n+\t\t\t\t       1, gfc_integer_4_kind);\n+  actual->next = next;\n+\n+  return 0;\n+}\n+\n \n /* Code for index interchange for loops which are grouped together in DO\n    CONCURRENT or FORALL statements.  This is currently only applied if the"}, {"sha": "3359974d1084d4bfe7cc6e34837e20b41501e870", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=998511a6100212931d039e3a46403d2d878c8e5a", "patch": "@@ -2143,6 +2143,11 @@ typedef struct gfc_expr\n \n   unsigned int no_bounds_check : 1;\n \n+  /* Set this if a matmul expression has already been evaluated for conversion\n+     to a BLAS call.  */\n+\n+  unsigned int external_blas : 1;\n+\n   /* If an expression comes from a Hollerith constant or compile-time\n      evaluation of a transfer statement, it may have a prescribed target-\n      memory representation, and these cannot always be backformed from"}, {"sha": "0c83f4747977d7cc930ce13d1ca81024eabe051f", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=998511a6100212931d039e3a46403d2d878c8e5a", "patch": "@@ -4055,6 +4055,7 @@ gfc_conv_intrinsic_funcall (gfc_se * se, gfc_expr * expr)\n      to be able to call the BLAS ?gemm functions if required and possible.  */\n   append_args = NULL;\n   if (expr->value.function.isym->id == GFC_ISYM_MATMUL\n+      && !expr->external_blas\n       && sym->ts.type != BT_LOGICAL)\n     {\n       tree cint = gfc_get_int_type (gfc_c_int_kind);"}, {"sha": "f97a33b5fbc8de9a8f9cfbd1b428e984f4ad85f8", "filename": "gcc/testsuite/gfortran.dg/blas_gemm_routines.f", "status": "added", "additions": 1955, "deletions": 0, "changes": 1955, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fblas_gemm_routines.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fblas_gemm_routines.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fblas_gemm_routines.f?ref=998511a6100212931d039e3a46403d2d878c8e5a", "patch": "@@ -0,0 +1,1955 @@\n+! { dg-do compile }\n+! { dg-options \"-std=legacy\" }\n+*> \\brief \\b CGEMM\n+*\n+*  =========== DOCUMENTATION ===========\n+*\n+* Online html documentation available at\n+*            http://www.netlib.org/lapack/explore-html/\n+*\n+*  Definition:\n+*  ===========\n+*\n+*       SUBROUTINE CGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n+*\n+*       .. Scalar Arguments ..\n+*       COMPLEX ALPHA,BETA\n+*       INTEGER K,LDA,LDB,LDC,M,N\n+*       CHARACTER TRANSA,TRANSB\n+*       ..\n+*       .. Array Arguments ..\n+*       COMPLEX A(LDA,*),B(LDB,*),C(LDC,*)\n+*       ..\n+*\n+*\n+*> \\par Purpose:\n+*  =============\n+*>\n+*> \\verbatim\n+*>\n+*> CGEMM  performs one of the matrix-matrix operations\n+*>\n+*>    C := alpha*op( A )*op( B ) + beta*C,\n+*>\n+*> where  op( X ) is one of\n+*>\n+*>    op( X ) = X   or   op( X ) = X**T   or   op( X ) = X**H,\n+*>\n+*> alpha and beta are scalars, and A, B and C are matrices, with op( A )\n+*> an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.\n+*> \\endverbatim\n+*\n+*  Arguments:\n+*  ==========\n+*\n+*> \\param[in] TRANSA\n+*> \\verbatim\n+*>          TRANSA is CHARACTER*1\n+*>           On entry, TRANSA specifies the form of op( A ) to be used in\n+*>           the matrix multiplication as follows:\n+*>\n+*>              TRANSA = 'N' or 'n',  op( A ) = A.\n+*>\n+*>              TRANSA = 'T' or 't',  op( A ) = A**T.\n+*>\n+*>              TRANSA = 'C' or 'c',  op( A ) = A**H.\n+*> \\endverbatim\n+*>\n+*> \\param[in] TRANSB\n+*> \\verbatim\n+*>          TRANSB is CHARACTER*1\n+*>           On entry, TRANSB specifies the form of op( B ) to be used in\n+*>           the matrix multiplication as follows:\n+*>\n+*>              TRANSB = 'N' or 'n',  op( B ) = B.\n+*>\n+*>              TRANSB = 'T' or 't',  op( B ) = B**T.\n+*>\n+*>              TRANSB = 'C' or 'c',  op( B ) = B**H.\n+*> \\endverbatim\n+*>\n+*> \\param[in] M\n+*> \\verbatim\n+*>          M is INTEGER\n+*>           On entry,  M  specifies  the number  of rows  of the  matrix\n+*>           op( A )  and of the  matrix  C.  M  must  be at least  zero.\n+*> \\endverbatim\n+*>\n+*> \\param[in] N\n+*> \\verbatim\n+*>          N is INTEGER\n+*>           On entry,  N  specifies the number  of columns of the matrix\n+*>           op( B ) and the number of columns of the matrix C. N must be\n+*>           at least zero.\n+*> \\endverbatim\n+*>\n+*> \\param[in] K\n+*> \\verbatim\n+*>          K is INTEGER\n+*>           On entry,  K  specifies  the number of columns of the matrix\n+*>           op( A ) and the number of rows of the matrix op( B ). K must\n+*>           be at least  zero.\n+*> \\endverbatim\n+*>\n+*> \\param[in] ALPHA\n+*> \\verbatim\n+*>          ALPHA is COMPLEX\n+*>           On entry, ALPHA specifies the scalar alpha.\n+*> \\endverbatim\n+*>\n+*> \\param[in] A\n+*> \\verbatim\n+*>          A is COMPLEX array, dimension ( LDA, ka ), where ka is\n+*>           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.\n+*>           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k\n+*>           part of the array  A  must contain the matrix  A,  otherwise\n+*>           the leading  k by m  part of the array  A  must contain  the\n+*>           matrix A.\n+*> \\endverbatim\n+*>\n+*> \\param[in] LDA\n+*> \\verbatim\n+*>          LDA is INTEGER\n+*>           On entry, LDA specifies the first dimension of A as declared\n+*>           in the calling (sub) program. When  TRANSA = 'N' or 'n' then\n+*>           LDA must be at least  max( 1, m ), otherwise  LDA must be at\n+*>           least  max( 1, k ).\n+*> \\endverbatim\n+*>\n+*> \\param[in] B\n+*> \\verbatim\n+*>          B is COMPLEX array, dimension ( LDB, kb ), where kb is\n+*>           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.\n+*>           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n\n+*>           part of the array  B  must contain the matrix  B,  otherwise\n+*>           the leading  n by k  part of the array  B  must contain  the\n+*>           matrix B.\n+*> \\endverbatim\n+*>\n+*> \\param[in] LDB\n+*> \\verbatim\n+*>          LDB is INTEGER\n+*>           On entry, LDB specifies the first dimension of B as declared\n+*>           in the calling (sub) program. When  TRANSB = 'N' or 'n' then\n+*>           LDB must be at least  max( 1, k ), otherwise  LDB must be at\n+*>           least  max( 1, n ).\n+*> \\endverbatim\n+*>\n+*> \\param[in] BETA\n+*> \\verbatim\n+*>          BETA is COMPLEX\n+*>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is\n+*>           supplied as zero then C need not be set on input.\n+*> \\endverbatim\n+*>\n+*> \\param[in,out] C\n+*> \\verbatim\n+*>          C is COMPLEX array, dimension ( LDC, N )\n+*>           Before entry, the leading  m by n  part of the array  C must\n+*>           contain the matrix  C,  except when  beta  is zero, in which\n+*>           case C need not be set on entry.\n+*>           On exit, the array  C  is overwritten by the  m by n  matrix\n+*>           ( alpha*op( A )*op( B ) + beta*C ).\n+*> \\endverbatim\n+*>\n+*> \\param[in] LDC\n+*> \\verbatim\n+*>          LDC is INTEGER\n+*>           On entry, LDC specifies the first dimension of C as declared\n+*>           in  the  calling  (sub)  program.   LDC  must  be  at  least\n+*>           max( 1, m ).\n+*> \\endverbatim\n+*\n+*  Authors:\n+*  ========\n+*\n+*> \\author Univ. of Tennessee\n+*> \\author Univ. of California Berkeley\n+*> \\author Univ. of Colorado Denver\n+*> \\author NAG Ltd.\n+*\n+*> \\date December 2016\n+*\n+*> \\ingroup complex_blas_level3\n+*\n+*> \\par Further Details:\n+*  =====================\n+*>\n+*> \\verbatim\n+*>\n+*>  Level 3 Blas routine.\n+*>\n+*>  -- Written on 8-February-1989.\n+*>     Jack Dongarra, Argonne National Laboratory.\n+*>     Iain Duff, AERE Harwell.\n+*>     Jeremy Du Croz, Numerical Algorithms Group Ltd.\n+*>     Sven Hammarling, Numerical Algorithms Group Ltd.\n+*> \\endverbatim\n+*>\n+*  =====================================================================\n+      SUBROUTINE CGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n+*\n+*  -- Reference BLAS level3 routine (version 3.7.0) --\n+*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --\n+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n+*     December 2016\n+*\n+*     .. Scalar Arguments ..\n+      COMPLEX ALPHA,BETA\n+      INTEGER K,LDA,LDB,LDC,M,N\n+      CHARACTER TRANSA,TRANSB\n+*     ..\n+*     .. Array Arguments ..\n+      COMPLEX A(LDA,*),B(LDB,*),C(LDC,*)\n+*     ..\n+*\n+*  =====================================================================\n+*\n+*     .. External Functions ..\n+      LOGICAL LSAME\n+      EXTERNAL LSAME\n+*     ..\n+*     .. External Subroutines ..\n+      EXTERNAL XERBLA\n+*     ..\n+*     .. Intrinsic Functions ..\n+      INTRINSIC CONJG,MAX\n+*     ..\n+*     .. Local Scalars ..\n+      COMPLEX TEMP\n+      INTEGER I,INFO,J,L,NCOLA,NROWA,NROWB\n+      LOGICAL CONJA,CONJB,NOTA,NOTB\n+*     ..\n+*     .. Parameters ..\n+      COMPLEX ONE\n+      PARAMETER (ONE= (1.0E+0,0.0E+0))\n+      COMPLEX ZERO\n+      PARAMETER (ZERO= (0.0E+0,0.0E+0))\n+*     ..\n+*\n+*     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not\n+*     conjugated or transposed, set  CONJA and CONJB  as true if  A  and\n+*     B  respectively are to be  transposed but  not conjugated  and set\n+*     NROWA, NCOLA and  NROWB  as the number of rows and  columns  of  A\n+*     and the number of rows of  B  respectively.\n+*\n+      NOTA = LSAME(TRANSA,'N')\n+      NOTB = LSAME(TRANSB,'N')\n+      CONJA = LSAME(TRANSA,'C')\n+      CONJB = LSAME(TRANSB,'C')\n+      IF (NOTA) THEN\n+          NROWA = M\n+          NCOLA = K\n+      ELSE\n+          NROWA = K\n+          NCOLA = M\n+      END IF\n+      IF (NOTB) THEN\n+          NROWB = K\n+      ELSE\n+          NROWB = N\n+      END IF\n+*\n+*     Test the input parameters.\n+*\n+      INFO = 0\n+      IF ((.NOT.NOTA) .AND. (.NOT.CONJA) .AND.\n+     +    (.NOT.LSAME(TRANSA,'T'))) THEN\n+          INFO = 1\n+      ELSE IF ((.NOT.NOTB) .AND. (.NOT.CONJB) .AND.\n+     +         (.NOT.LSAME(TRANSB,'T'))) THEN\n+          INFO = 2\n+      ELSE IF (M.LT.0) THEN\n+          INFO = 3\n+      ELSE IF (N.LT.0) THEN\n+          INFO = 4\n+      ELSE IF (K.LT.0) THEN\n+          INFO = 5\n+      ELSE IF (LDA.LT.MAX(1,NROWA)) THEN\n+          INFO = 8\n+      ELSE IF (LDB.LT.MAX(1,NROWB)) THEN\n+          INFO = 10\n+      ELSE IF (LDC.LT.MAX(1,M)) THEN\n+          INFO = 13\n+      END IF\n+      IF (INFO.NE.0) THEN\n+          CALL XERBLA('CGEMM ',INFO)\n+          RETURN\n+      END IF\n+*\n+*     Quick return if possible.\n+*\n+      IF ((M.EQ.0) .OR. (N.EQ.0) .OR.\n+     +    (((ALPHA.EQ.ZERO).OR. (K.EQ.0)).AND. (BETA.EQ.ONE))) RETURN\n+*\n+*     And when  alpha.eq.zero.\n+*\n+      IF (ALPHA.EQ.ZERO) THEN\n+          IF (BETA.EQ.ZERO) THEN\n+              DO 20 J = 1,N\n+                  DO 10 I = 1,M\n+                      C(I,J) = ZERO\n+   10             CONTINUE\n+   20         CONTINUE\n+          ELSE\n+              DO 40 J = 1,N\n+                  DO 30 I = 1,M\n+                      C(I,J) = BETA*C(I,J)\n+   30             CONTINUE\n+   40         CONTINUE\n+          END IF\n+          RETURN\n+      END IF\n+*\n+*     Start the operations.\n+*\n+      IF (NOTB) THEN\n+          IF (NOTA) THEN\n+*\n+*           Form  C := alpha*A*B + beta*C.\n+*\n+              DO 90 J = 1,N\n+                  IF (BETA.EQ.ZERO) THEN\n+                      DO 50 I = 1,M\n+                          C(I,J) = ZERO\n+   50                 CONTINUE\n+                  ELSE IF (BETA.NE.ONE) THEN\n+                      DO 60 I = 1,M\n+                          C(I,J) = BETA*C(I,J)\n+   60                 CONTINUE\n+                  END IF\n+                  DO 80 L = 1,K\n+                      TEMP = ALPHA*B(L,J)\n+                      DO 70 I = 1,M\n+                          C(I,J) = C(I,J) + TEMP*A(I,L)\n+   70                 CONTINUE\n+   80             CONTINUE\n+   90         CONTINUE\n+          ELSE IF (CONJA) THEN\n+*\n+*           Form  C := alpha*A**H*B + beta*C.\n+*\n+              DO 120 J = 1,N\n+                  DO 110 I = 1,M\n+                      TEMP = ZERO\n+                      DO 100 L = 1,K\n+                          TEMP = TEMP + CONJG(A(L,I))*B(L,J)\n+  100                 CONTINUE\n+                      IF (BETA.EQ.ZERO) THEN\n+                          C(I,J) = ALPHA*TEMP\n+                      ELSE\n+                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)\n+                      END IF\n+  110             CONTINUE\n+  120         CONTINUE\n+          ELSE\n+*\n+*           Form  C := alpha*A**T*B + beta*C\n+*\n+              DO 150 J = 1,N\n+                  DO 140 I = 1,M\n+                      TEMP = ZERO\n+                      DO 130 L = 1,K\n+                          TEMP = TEMP + A(L,I)*B(L,J)\n+  130                 CONTINUE\n+                      IF (BETA.EQ.ZERO) THEN\n+                          C(I,J) = ALPHA*TEMP\n+                      ELSE\n+                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)\n+                      END IF\n+  140             CONTINUE\n+  150         CONTINUE\n+          END IF\n+      ELSE IF (NOTA) THEN\n+          IF (CONJB) THEN\n+*\n+*           Form  C := alpha*A*B**H + beta*C.\n+*\n+              DO 200 J = 1,N\n+                  IF (BETA.EQ.ZERO) THEN\n+                      DO 160 I = 1,M\n+                          C(I,J) = ZERO\n+  160                 CONTINUE\n+                  ELSE IF (BETA.NE.ONE) THEN\n+                      DO 170 I = 1,M\n+                          C(I,J) = BETA*C(I,J)\n+  170                 CONTINUE\n+                  END IF\n+                  DO 190 L = 1,K\n+                      TEMP = ALPHA*CONJG(B(J,L))\n+                      DO 180 I = 1,M\n+                          C(I,J) = C(I,J) + TEMP*A(I,L)\n+  180                 CONTINUE\n+  190             CONTINUE\n+  200         CONTINUE\n+          ELSE\n+*\n+*           Form  C := alpha*A*B**T + beta*C\n+*\n+              DO 250 J = 1,N\n+                  IF (BETA.EQ.ZERO) THEN\n+                      DO 210 I = 1,M\n+                          C(I,J) = ZERO\n+  210                 CONTINUE\n+                  ELSE IF (BETA.NE.ONE) THEN\n+                      DO 220 I = 1,M\n+                          C(I,J) = BETA*C(I,J)\n+  220                 CONTINUE\n+                  END IF\n+                  DO 240 L = 1,K\n+                      TEMP = ALPHA*B(J,L)\n+                      DO 230 I = 1,M\n+                          C(I,J) = C(I,J) + TEMP*A(I,L)\n+  230                 CONTINUE\n+  240             CONTINUE\n+  250         CONTINUE\n+          END IF\n+      ELSE IF (CONJA) THEN\n+          IF (CONJB) THEN\n+*\n+*           Form  C := alpha*A**H*B**H + beta*C.\n+*\n+              DO 280 J = 1,N\n+                  DO 270 I = 1,M\n+                      TEMP = ZERO\n+                      DO 260 L = 1,K\n+                          TEMP = TEMP + CONJG(A(L,I))*CONJG(B(J,L))\n+  260                 CONTINUE\n+                      IF (BETA.EQ.ZERO) THEN\n+                          C(I,J) = ALPHA*TEMP\n+                      ELSE\n+                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)\n+                      END IF\n+  270             CONTINUE\n+  280         CONTINUE\n+          ELSE\n+*\n+*           Form  C := alpha*A**H*B**T + beta*C\n+*\n+              DO 310 J = 1,N\n+                  DO 300 I = 1,M\n+                      TEMP = ZERO\n+                      DO 290 L = 1,K\n+                          TEMP = TEMP + CONJG(A(L,I))*B(J,L)\n+  290                 CONTINUE\n+                      IF (BETA.EQ.ZERO) THEN\n+                          C(I,J) = ALPHA*TEMP\n+                      ELSE\n+                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)\n+                      END IF\n+  300             CONTINUE\n+  310         CONTINUE\n+          END IF\n+      ELSE\n+          IF (CONJB) THEN\n+*\n+*           Form  C := alpha*A**T*B**H + beta*C\n+*\n+              DO 340 J = 1,N\n+                  DO 330 I = 1,M\n+                      TEMP = ZERO\n+                      DO 320 L = 1,K\n+                          TEMP = TEMP + A(L,I)*CONJG(B(J,L))\n+  320                 CONTINUE\n+                      IF (BETA.EQ.ZERO) THEN\n+                          C(I,J) = ALPHA*TEMP\n+                      ELSE\n+                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)\n+                      END IF\n+  330             CONTINUE\n+  340         CONTINUE\n+          ELSE\n+*\n+*           Form  C := alpha*A**T*B**T + beta*C\n+*\n+              DO 370 J = 1,N\n+                  DO 360 I = 1,M\n+                      TEMP = ZERO\n+                      DO 350 L = 1,K\n+                          TEMP = TEMP + A(L,I)*B(J,L)\n+  350                 CONTINUE\n+                      IF (BETA.EQ.ZERO) THEN\n+                          C(I,J) = ALPHA*TEMP\n+                      ELSE\n+                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)\n+                      END IF\n+  360             CONTINUE\n+  370         CONTINUE\n+          END IF\n+      END IF\n+*\n+      RETURN\n+*\n+*     End of CGEMM .\n+*\n+      END\n+\n+*> \\brief \\b LSAME\n+*\n+*  =========== DOCUMENTATION ===========\n+*\n+* Online html documentation available at\n+*            http://www.netlib.org/lapack/explore-html/\n+*\n+*  Definition:\n+*  ===========\n+*\n+*       LOGICAL FUNCTION LSAME(CA,CB)\n+*\n+*       .. Scalar Arguments ..\n+*       CHARACTER CA,CB\n+*       ..\n+*\n+*\n+*> \\par Purpose:\n+*  =============\n+*>\n+*> \\verbatim\n+*>\n+*> LSAME returns .TRUE. if CA is the same letter as CB regardless of\n+*> case.\n+*> \\endverbatim\n+*\n+*  Arguments:\n+*  ==========\n+*\n+*> \\param[in] CA\n+*> \\verbatim\n+*>          CA is CHARACTER*1\n+*> \\endverbatim\n+*>\n+*> \\param[in] CB\n+*> \\verbatim\n+*>          CB is CHARACTER*1\n+*>          CA and CB specify the single characters to be compared.\n+*> \\endverbatim\n+*\n+*  Authors:\n+*  ========\n+*\n+*> \\author Univ. of Tennessee\n+*> \\author Univ. of California Berkeley\n+*> \\author Univ. of Colorado Denver\n+*> \\author NAG Ltd.\n+*\n+*> \\date December 2016\n+*\n+*> \\ingroup aux_blas\n+*\n+*  =====================================================================\n+      LOGICAL FUNCTION LSAME(CA,CB)\n+*\n+*  -- Reference BLAS level1 routine (version 3.1) --\n+*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --\n+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n+*     December 2016\n+*\n+*     .. Scalar Arguments ..\n+      CHARACTER CA,CB\n+*     ..\n+*\n+* =====================================================================\n+*\n+*     .. Intrinsic Functions ..\n+      INTRINSIC ICHAR\n+*     ..\n+*     .. Local Scalars ..\n+      INTEGER INTA,INTB,ZCODE\n+*     ..\n+*\n+*     Test if the characters are equal\n+*\n+      LSAME = CA .EQ. CB\n+      IF (LSAME) RETURN\n+*\n+*     Now test for equivalence if both characters are alphabetic.\n+*\n+      ZCODE = ICHAR('Z')\n+*\n+*     Use 'Z' rather than 'A' so that ASCII can be detected on Prime\n+*     machines, on which ICHAR returns a value with bit 8 set.\n+*     ICHAR('A') on Prime machines returns 193 which is the same as\n+*     ICHAR('A') on an EBCDIC machine.\n+*\n+      INTA = ICHAR(CA)\n+      INTB = ICHAR(CB)\n+*\n+      IF (ZCODE.EQ.90 .OR. ZCODE.EQ.122) THEN\n+*\n+*        ASCII is assumed - ZCODE is the ASCII code of either lower or\n+*        upper case 'Z'.\n+*\n+          IF (INTA.GE.97 .AND. INTA.LE.122) INTA = INTA - 32\n+          IF (INTB.GE.97 .AND. INTB.LE.122) INTB = INTB - 32\n+*\n+      ELSE IF (ZCODE.EQ.233 .OR. ZCODE.EQ.169) THEN\n+*\n+*        EBCDIC is assumed - ZCODE is the EBCDIC code of either lower or\n+*        upper case 'Z'.\n+*\n+          IF (INTA.GE.129 .AND. INTA.LE.137 .OR.\n+     +        INTA.GE.145 .AND. INTA.LE.153 .OR.\n+     +        INTA.GE.162 .AND. INTA.LE.169) INTA = INTA + 64\n+          IF (INTB.GE.129 .AND. INTB.LE.137 .OR.\n+     +        INTB.GE.145 .AND. INTB.LE.153 .OR.\n+     +        INTB.GE.162 .AND. INTB.LE.169) INTB = INTB + 64\n+*\n+      ELSE IF (ZCODE.EQ.218 .OR. ZCODE.EQ.250) THEN\n+*\n+*        ASCII is assumed, on Prime machines - ZCODE is the ASCII code\n+*        plus 128 of either lower or upper case 'Z'.\n+*\n+          IF (INTA.GE.225 .AND. INTA.LE.250) INTA = INTA - 32\n+          IF (INTB.GE.225 .AND. INTB.LE.250) INTB = INTB - 32\n+      END IF\n+      LSAME = INTA .EQ. INTB\n+*\n+*     RETURN\n+*\n+*     End of LSAME\n+*\n+      END\n+\n+*> \\brief \\b XERBLA\n+*\n+*  =========== DOCUMENTATION ===========\n+*\n+* Online html documentation available at\n+*            http://www.netlib.org/lapack/explore-html/\n+*\n+*  Definition:\n+*  ===========\n+*\n+*       SUBROUTINE XERBLA( SRNAME, INFO )\n+*\n+*       .. Scalar Arguments ..\n+*       CHARACTER*(*)      SRNAME\n+*       INTEGER            INFO\n+*       ..\n+*\n+*\n+*> \\par Purpose:\n+*  =============\n+*>\n+*> \\verbatim\n+*>\n+*> XERBLA  is an error handler for the LAPACK routines.\n+*> It is called by an LAPACK routine if an input parameter has an\n+*> invalid value.  A message is printed and execution stops.\n+*>\n+*> Installers may consider modifying the STOP statement in order to\n+*> call system-specific exception-handling facilities.\n+*> \\endverbatim\n+*\n+*  Arguments:\n+*  ==========\n+*\n+*> \\param[in] SRNAME\n+*> \\verbatim\n+*>          SRNAME is CHARACTER*(*)\n+*>          The name of the routine which called XERBLA.\n+*> \\endverbatim\n+*>\n+*> \\param[in] INFO\n+*> \\verbatim\n+*>          INFO is INTEGER\n+*>          The position of the invalid parameter in the parameter list\n+*>          of the calling routine.\n+*> \\endverbatim\n+*\n+*  Authors:\n+*  ========\n+*\n+*> \\author Univ. of Tennessee\n+*> \\author Univ. of California Berkeley\n+*> \\author Univ. of Colorado Denver\n+*> \\author NAG Ltd.\n+*\n+*> \\date December 2016\n+*\n+*> \\ingroup aux_blas\n+*\n+*  =====================================================================\n+      SUBROUTINE XERBLA( SRNAME, INFO )\n+*\n+*  -- Reference BLAS level1 routine (version 3.7.0) --\n+*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --\n+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n+*     December 2016\n+*\n+*     .. Scalar Arguments ..\n+      CHARACTER*(*)      SRNAME\n+      INTEGER            INFO\n+*     ..\n+*\n+* =====================================================================\n+*\n+*     .. Intrinsic Functions ..\n+      INTRINSIC          LEN_TRIM\n+*     ..\n+*     .. Executable Statements ..\n+*\n+      WRITE( *, FMT = 9999 )SRNAME( 1:LEN_TRIM( SRNAME ) ), INFO\n+*\n+      STOP\n+*\n+ 9999 FORMAT( ' ** On entry to ', A, ' parameter number ', I2, ' had ',\n+     $      'an illegal value' )\n+*\n+*     End of XERBLA\n+*\n+      END\n+\n+*> \\brief \\b SGEMM\n+*\n+*  =========== DOCUMENTATION ===========\n+*\n+* Online html documentation available at\n+*            http://www.netlib.org/lapack/explore-html/\n+*\n+*  Definition:\n+*  ===========\n+*\n+*       SUBROUTINE SGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n+*\n+*       .. Scalar Arguments ..\n+*       REAL ALPHA,BETA\n+*       INTEGER K,LDA,LDB,LDC,M,N\n+*       CHARACTER TRANSA,TRANSB\n+*       ..\n+*       .. Array Arguments ..\n+*       REAL A(LDA,*),B(LDB,*),C(LDC,*)\n+*       ..\n+*\n+*\n+*> \\par Purpose:\n+*  =============\n+*>\n+*> \\verbatim\n+*>\n+*> SGEMM  performs one of the matrix-matrix operations\n+*>\n+*>    C := alpha*op( A )*op( B ) + beta*C,\n+*>\n+*> where  op( X ) is one of\n+*>\n+*>    op( X ) = X   or   op( X ) = X**T,\n+*>\n+*> alpha and beta are scalars, and A, B and C are matrices, with op( A )\n+*> an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.\n+*> \\endverbatim\n+*\n+*  Arguments:\n+*  ==========\n+*\n+*> \\param[in] TRANSA\n+*> \\verbatim\n+*>          TRANSA is CHARACTER*1\n+*>           On entry, TRANSA specifies the form of op( A ) to be used in\n+*>           the matrix multiplication as follows:\n+*>\n+*>              TRANSA = 'N' or 'n',  op( A ) = A.\n+*>\n+*>              TRANSA = 'T' or 't',  op( A ) = A**T.\n+*>\n+*>              TRANSA = 'C' or 'c',  op( A ) = A**T.\n+*> \\endverbatim\n+*>\n+*> \\param[in] TRANSB\n+*> \\verbatim\n+*>          TRANSB is CHARACTER*1\n+*>           On entry, TRANSB specifies the form of op( B ) to be used in\n+*>           the matrix multiplication as follows:\n+*>\n+*>              TRANSB = 'N' or 'n',  op( B ) = B.\n+*>\n+*>              TRANSB = 'T' or 't',  op( B ) = B**T.\n+*>\n+*>              TRANSB = 'C' or 'c',  op( B ) = B**T.\n+*> \\endverbatim\n+*>\n+*> \\param[in] M\n+*> \\verbatim\n+*>          M is INTEGER\n+*>           On entry,  M  specifies  the number  of rows  of the  matrix\n+*>           op( A )  and of the  matrix  C.  M  must  be at least  zero.\n+*> \\endverbatim\n+*>\n+*> \\param[in] N\n+*> \\verbatim\n+*>          N is INTEGER\n+*>           On entry,  N  specifies the number  of columns of the matrix\n+*>           op( B ) and the number of columns of the matrix C. N must be\n+*>           at least zero.\n+*> \\endverbatim\n+*>\n+*> \\param[in] K\n+*> \\verbatim\n+*>          K is INTEGER\n+*>           On entry,  K  specifies  the number of columns of the matrix\n+*>           op( A ) and the number of rows of the matrix op( B ). K must\n+*>           be at least  zero.\n+*> \\endverbatim\n+*>\n+*> \\param[in] ALPHA\n+*> \\verbatim\n+*>          ALPHA is REAL\n+*>           On entry, ALPHA specifies the scalar alpha.\n+*> \\endverbatim\n+*>\n+*> \\param[in] A\n+*> \\verbatim\n+*>          A is REAL array, dimension ( LDA, ka ), where ka is\n+*>           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.\n+*>           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k\n+*>           part of the array  A  must contain the matrix  A,  otherwise\n+*>           the leading  k by m  part of the array  A  must contain  the\n+*>           matrix A.\n+*> \\endverbatim\n+*>\n+*> \\param[in] LDA\n+*> \\verbatim\n+*>          LDA is INTEGER\n+*>           On entry, LDA specifies the first dimension of A as declared\n+*>           in the calling (sub) program. When  TRANSA = 'N' or 'n' then\n+*>           LDA must be at least  max( 1, m ), otherwise  LDA must be at\n+*>           least  max( 1, k ).\n+*> \\endverbatim\n+*>\n+*> \\param[in] B\n+*> \\verbatim\n+*>          B is REAL array, dimension ( LDB, kb ), where kb is\n+*>           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.\n+*>           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n\n+*>           part of the array  B  must contain the matrix  B,  otherwise\n+*>           the leading  n by k  part of the array  B  must contain  the\n+*>           matrix B.\n+*> \\endverbatim\n+*>\n+*> \\param[in] LDB\n+*> \\verbatim\n+*>          LDB is INTEGER\n+*>           On entry, LDB specifies the first dimension of B as declared\n+*>           in the calling (sub) program. When  TRANSB = 'N' or 'n' then\n+*>           LDB must be at least  max( 1, k ), otherwise  LDB must be at\n+*>           least  max( 1, n ).\n+*> \\endverbatim\n+*>\n+*> \\param[in] BETA\n+*> \\verbatim\n+*>          BETA is REAL\n+*>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is\n+*>           supplied as zero then C need not be set on input.\n+*> \\endverbatim\n+*>\n+*> \\param[in,out] C\n+*> \\verbatim\n+*>          C is REAL array, dimension ( LDC, N )\n+*>           Before entry, the leading  m by n  part of the array  C must\n+*>           contain the matrix  C,  except when  beta  is zero, in which\n+*>           case C need not be set on entry.\n+*>           On exit, the array  C  is overwritten by the  m by n  matrix\n+*>           ( alpha*op( A )*op( B ) + beta*C ).\n+*> \\endverbatim\n+*>\n+*> \\param[in] LDC\n+*> \\verbatim\n+*>          LDC is INTEGER\n+*>           On entry, LDC specifies the first dimension of C as declared\n+*>           in  the  calling  (sub)  program.   LDC  must  be  at  least\n+*>           max( 1, m ).\n+*> \\endverbatim\n+*\n+*  Authors:\n+*  ========\n+*\n+*> \\author Univ. of Tennessee\n+*> \\author Univ. of California Berkeley\n+*> \\author Univ. of Colorado Denver\n+*> \\author NAG Ltd.\n+*\n+*> \\date December 2016\n+*\n+*> \\ingroup single_blas_level3\n+*\n+*> \\par Further Details:\n+*  =====================\n+*>\n+*> \\verbatim\n+*>\n+*>  Level 3 Blas routine.\n+*>\n+*>  -- Written on 8-February-1989.\n+*>     Jack Dongarra, Argonne National Laboratory.\n+*>     Iain Duff, AERE Harwell.\n+*>     Jeremy Du Croz, Numerical Algorithms Group Ltd.\n+*>     Sven Hammarling, Numerical Algorithms Group Ltd.\n+*> \\endverbatim\n+*>\n+*  =====================================================================\n+      SUBROUTINE SGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n+*\n+*  -- Reference BLAS level3 routine (version 3.7.0) --\n+*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --\n+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n+*     December 2016\n+*\n+*     .. Scalar Arguments ..\n+      REAL ALPHA,BETA\n+      INTEGER K,LDA,LDB,LDC,M,N\n+      CHARACTER TRANSA,TRANSB\n+*     ..\n+*     .. Array Arguments ..\n+      REAL A(LDA,*),B(LDB,*),C(LDC,*)\n+*     ..\n+*\n+*  =====================================================================\n+*\n+*     .. External Functions ..\n+      LOGICAL LSAME\n+      EXTERNAL LSAME\n+*     ..\n+*     .. External Subroutines ..\n+      EXTERNAL XERBLA\n+*     ..\n+*     .. Intrinsic Functions ..\n+      INTRINSIC MAX\n+*     ..\n+*     .. Local Scalars ..\n+      REAL TEMP\n+      INTEGER I,INFO,J,L,NCOLA,NROWA,NROWB\n+      LOGICAL NOTA,NOTB\n+*     ..\n+*     .. Parameters ..\n+      REAL ONE,ZERO\n+      PARAMETER (ONE=1.0E+0,ZERO=0.0E+0)\n+*     ..\n+*\n+*     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not\n+*     transposed and set  NROWA, NCOLA and  NROWB  as the number of rows\n+*     and  columns of  A  and the  number of  rows  of  B  respectively.\n+*\n+      NOTA = LSAME(TRANSA,'N')\n+      NOTB = LSAME(TRANSB,'N')\n+      IF (NOTA) THEN\n+          NROWA = M\n+          NCOLA = K\n+      ELSE\n+          NROWA = K\n+          NCOLA = M\n+      END IF\n+      IF (NOTB) THEN\n+          NROWB = K\n+      ELSE\n+          NROWB = N\n+      END IF\n+*\n+*     Test the input parameters.\n+*\n+      INFO = 0\n+      IF ((.NOT.NOTA) .AND. (.NOT.LSAME(TRANSA,'C')) .AND.\n+     +    (.NOT.LSAME(TRANSA,'T'))) THEN\n+          INFO = 1\n+      ELSE IF ((.NOT.NOTB) .AND. (.NOT.LSAME(TRANSB,'C')) .AND.\n+     +         (.NOT.LSAME(TRANSB,'T'))) THEN\n+          INFO = 2\n+      ELSE IF (M.LT.0) THEN\n+          INFO = 3\n+      ELSE IF (N.LT.0) THEN\n+          INFO = 4\n+      ELSE IF (K.LT.0) THEN\n+          INFO = 5\n+      ELSE IF (LDA.LT.MAX(1,NROWA)) THEN\n+          INFO = 8\n+      ELSE IF (LDB.LT.MAX(1,NROWB)) THEN\n+          INFO = 10\n+      ELSE IF (LDC.LT.MAX(1,M)) THEN\n+          INFO = 13\n+      END IF\n+      IF (INFO.NE.0) THEN\n+          CALL XERBLA('SGEMM ',INFO)\n+          RETURN\n+      END IF\n+*\n+*     Quick return if possible.\n+*\n+      IF ((M.EQ.0) .OR. (N.EQ.0) .OR.\n+     +    (((ALPHA.EQ.ZERO).OR. (K.EQ.0)).AND. (BETA.EQ.ONE))) RETURN\n+*\n+*     And if  alpha.eq.zero.\n+*\n+      IF (ALPHA.EQ.ZERO) THEN\n+          IF (BETA.EQ.ZERO) THEN\n+              DO 20 J = 1,N\n+                  DO 10 I = 1,M\n+                      C(I,J) = ZERO\n+   10             CONTINUE\n+   20         CONTINUE\n+          ELSE\n+              DO 40 J = 1,N\n+                  DO 30 I = 1,M\n+                      C(I,J) = BETA*C(I,J)\n+   30             CONTINUE\n+   40         CONTINUE\n+          END IF\n+          RETURN\n+      END IF\n+*\n+*     Start the operations.\n+*\n+      IF (NOTB) THEN\n+          IF (NOTA) THEN\n+*\n+*           Form  C := alpha*A*B + beta*C.\n+*\n+              DO 90 J = 1,N\n+                  IF (BETA.EQ.ZERO) THEN\n+                      DO 50 I = 1,M\n+                          C(I,J) = ZERO\n+   50                 CONTINUE\n+                  ELSE IF (BETA.NE.ONE) THEN\n+                      DO 60 I = 1,M\n+                          C(I,J) = BETA*C(I,J)\n+   60                 CONTINUE\n+                  END IF\n+                  DO 80 L = 1,K\n+                      TEMP = ALPHA*B(L,J)\n+                      DO 70 I = 1,M\n+                          C(I,J) = C(I,J) + TEMP*A(I,L)\n+   70                 CONTINUE\n+   80             CONTINUE\n+   90         CONTINUE\n+          ELSE\n+*\n+*           Form  C := alpha*A**T*B + beta*C\n+*\n+              DO 120 J = 1,N\n+                  DO 110 I = 1,M\n+                      TEMP = ZERO\n+                      DO 100 L = 1,K\n+                          TEMP = TEMP + A(L,I)*B(L,J)\n+  100                 CONTINUE\n+                      IF (BETA.EQ.ZERO) THEN\n+                          C(I,J) = ALPHA*TEMP\n+                      ELSE\n+                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)\n+                      END IF\n+  110             CONTINUE\n+  120         CONTINUE\n+          END IF\n+      ELSE\n+          IF (NOTA) THEN\n+*\n+*           Form  C := alpha*A*B**T + beta*C\n+*\n+              DO 170 J = 1,N\n+                  IF (BETA.EQ.ZERO) THEN\n+                      DO 130 I = 1,M\n+                          C(I,J) = ZERO\n+  130                 CONTINUE\n+                  ELSE IF (BETA.NE.ONE) THEN\n+                      DO 140 I = 1,M\n+                          C(I,J) = BETA*C(I,J)\n+  140                 CONTINUE\n+                  END IF\n+                  DO 160 L = 1,K\n+                      TEMP = ALPHA*B(J,L)\n+                      DO 150 I = 1,M\n+                          C(I,J) = C(I,J) + TEMP*A(I,L)\n+  150                 CONTINUE\n+  160             CONTINUE\n+  170         CONTINUE\n+          ELSE\n+*\n+*           Form  C := alpha*A**T*B**T + beta*C\n+*\n+              DO 200 J = 1,N\n+                  DO 190 I = 1,M\n+                      TEMP = ZERO\n+                      DO 180 L = 1,K\n+                          TEMP = TEMP + A(L,I)*B(J,L)\n+  180                 CONTINUE\n+                      IF (BETA.EQ.ZERO) THEN\n+                          C(I,J) = ALPHA*TEMP\n+                      ELSE\n+                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)\n+                      END IF\n+  190             CONTINUE\n+  200         CONTINUE\n+          END IF\n+      END IF\n+*\n+      RETURN\n+*\n+*     End of SGEMM .\n+*\n+      END\n+\n+*> \\brief \\b DGEMM\n+*\n+*  =========== DOCUMENTATION ===========\n+*\n+* Online html documentation available at\n+*            http://www.netlib.org/lapack/explore-html/\n+*\n+*  Definition:\n+*  ===========\n+*\n+*       SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n+*\n+*       .. Scalar Arguments ..\n+*       DOUBLE PRECISION ALPHA,BETA\n+*       INTEGER K,LDA,LDB,LDC,M,N\n+*       CHARACTER TRANSA,TRANSB\n+*       ..\n+*       .. Array Arguments ..\n+*       DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)\n+*       ..\n+*\n+*\n+*> \\par Purpose:\n+*  =============\n+*>\n+*> \\verbatim\n+*>\n+*> DGEMM  performs one of the matrix-matrix operations\n+*>\n+*>    C := alpha*op( A )*op( B ) + beta*C,\n+*>\n+*> where  op( X ) is one of\n+*>\n+*>    op( X ) = X   or   op( X ) = X**T,\n+*>\n+*> alpha and beta are scalars, and A, B and C are matrices, with op( A )\n+*> an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.\n+*> \\endverbatim\n+*\n+*  Arguments:\n+*  ==========\n+*\n+*> \\param[in] TRANSA\n+*> \\verbatim\n+*>          TRANSA is CHARACTER*1\n+*>           On entry, TRANSA specifies the form of op( A ) to be used in\n+*>           the matrix multiplication as follows:\n+*>\n+*>              TRANSA = 'N' or 'n',  op( A ) = A.\n+*>\n+*>              TRANSA = 'T' or 't',  op( A ) = A**T.\n+*>\n+*>              TRANSA = 'C' or 'c',  op( A ) = A**T.\n+*> \\endverbatim\n+*>\n+*> \\param[in] TRANSB\n+*> \\verbatim\n+*>          TRANSB is CHARACTER*1\n+*>           On entry, TRANSB specifies the form of op( B ) to be used in\n+*>           the matrix multiplication as follows:\n+*>\n+*>              TRANSB = 'N' or 'n',  op( B ) = B.\n+*>\n+*>              TRANSB = 'T' or 't',  op( B ) = B**T.\n+*>\n+*>              TRANSB = 'C' or 'c',  op( B ) = B**T.\n+*> \\endverbatim\n+*>\n+*> \\param[in] M\n+*> \\verbatim\n+*>          M is INTEGER\n+*>           On entry,  M  specifies  the number  of rows  of the  matrix\n+*>           op( A )  and of the  matrix  C.  M  must  be at least  zero.\n+*> \\endverbatim\n+*>\n+*> \\param[in] N\n+*> \\verbatim\n+*>          N is INTEGER\n+*>           On entry,  N  specifies the number  of columns of the matrix\n+*>           op( B ) and the number of columns of the matrix C. N must be\n+*>           at least zero.\n+*> \\endverbatim\n+*>\n+*> \\param[in] K\n+*> \\verbatim\n+*>          K is INTEGER\n+*>           On entry,  K  specifies  the number of columns of the matrix\n+*>           op( A ) and the number of rows of the matrix op( B ). K must\n+*>           be at least  zero.\n+*> \\endverbatim\n+*>\n+*> \\param[in] ALPHA\n+*> \\verbatim\n+*>          ALPHA is DOUBLE PRECISION.\n+*>           On entry, ALPHA specifies the scalar alpha.\n+*> \\endverbatim\n+*>\n+*> \\param[in] A\n+*> \\verbatim\n+*>          A is DOUBLE PRECISION array, dimension ( LDA, ka ), where ka is\n+*>           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.\n+*>           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k\n+*>           part of the array  A  must contain the matrix  A,  otherwise\n+*>           the leading  k by m  part of the array  A  must contain  the\n+*>           matrix A.\n+*> \\endverbatim\n+*>\n+*> \\param[in] LDA\n+*> \\verbatim\n+*>          LDA is INTEGER\n+*>           On entry, LDA specifies the first dimension of A as declared\n+*>           in the calling (sub) program. When  TRANSA = 'N' or 'n' then\n+*>           LDA must be at least  max( 1, m ), otherwise  LDA must be at\n+*>           least  max( 1, k ).\n+*> \\endverbatim\n+*>\n+*> \\param[in] B\n+*> \\verbatim\n+*>          B is DOUBLE PRECISION array, dimension ( LDB, kb ), where kb is\n+*>           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.\n+*>           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n\n+*>           part of the array  B  must contain the matrix  B,  otherwise\n+*>           the leading  n by k  part of the array  B  must contain  the\n+*>           matrix B.\n+*> \\endverbatim\n+*>\n+*> \\param[in] LDB\n+*> \\verbatim\n+*>          LDB is INTEGER\n+*>           On entry, LDB specifies the first dimension of B as declared\n+*>           in the calling (sub) program. When  TRANSB = 'N' or 'n' then\n+*>           LDB must be at least  max( 1, k ), otherwise  LDB must be at\n+*>           least  max( 1, n ).\n+*> \\endverbatim\n+*>\n+*> \\param[in] BETA\n+*> \\verbatim\n+*>          BETA is DOUBLE PRECISION.\n+*>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is\n+*>           supplied as zero then C need not be set on input.\n+*> \\endverbatim\n+*>\n+*> \\param[in,out] C\n+*> \\verbatim\n+*>          C is DOUBLE PRECISION array, dimension ( LDC, N )\n+*>           Before entry, the leading  m by n  part of the array  C must\n+*>           contain the matrix  C,  except when  beta  is zero, in which\n+*>           case C need not be set on entry.\n+*>           On exit, the array  C  is overwritten by the  m by n  matrix\n+*>           ( alpha*op( A )*op( B ) + beta*C ).\n+*> \\endverbatim\n+*>\n+*> \\param[in] LDC\n+*> \\verbatim\n+*>          LDC is INTEGER\n+*>           On entry, LDC specifies the first dimension of C as declared\n+*>           in  the  calling  (sub)  program.   LDC  must  be  at  least\n+*>           max( 1, m ).\n+*> \\endverbatim\n+*\n+*  Authors:\n+*  ========\n+*\n+*> \\author Univ. of Tennessee\n+*> \\author Univ. of California Berkeley\n+*> \\author Univ. of Colorado Denver\n+*> \\author NAG Ltd.\n+*\n+*> \\date December 2016\n+*\n+*> \\ingroup double_blas_level3\n+*\n+*> \\par Further Details:\n+*  =====================\n+*>\n+*> \\verbatim\n+*>\n+*>  Level 3 Blas routine.\n+*>\n+*>  -- Written on 8-February-1989.\n+*>     Jack Dongarra, Argonne National Laboratory.\n+*>     Iain Duff, AERE Harwell.\n+*>     Jeremy Du Croz, Numerical Algorithms Group Ltd.\n+*>     Sven Hammarling, Numerical Algorithms Group Ltd.\n+*> \\endverbatim\n+*>\n+*  =====================================================================\n+      SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n+*\n+*  -- Reference BLAS level3 routine (version 3.7.0) --\n+*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --\n+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n+*     December 2016\n+*\n+*     .. Scalar Arguments ..\n+      DOUBLE PRECISION ALPHA,BETA\n+      INTEGER K,LDA,LDB,LDC,M,N\n+      CHARACTER TRANSA,TRANSB\n+*     ..\n+*     .. Array Arguments ..\n+      DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)\n+*     ..\n+*\n+*  =====================================================================\n+*\n+*     .. External Functions ..\n+      LOGICAL LSAME\n+      EXTERNAL LSAME\n+*     ..\n+*     .. External Subroutines ..\n+      EXTERNAL XERBLA\n+*     ..\n+*     .. Intrinsic Functions ..\n+      INTRINSIC MAX\n+*     ..\n+*     .. Local Scalars ..\n+      DOUBLE PRECISION TEMP\n+      INTEGER I,INFO,J,L,NCOLA,NROWA,NROWB\n+      LOGICAL NOTA,NOTB\n+*     ..\n+*     .. Parameters ..\n+      DOUBLE PRECISION ONE,ZERO\n+      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)\n+*     ..\n+*\n+*     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not\n+*     transposed and set  NROWA, NCOLA and  NROWB  as the number of rows\n+*     and  columns of  A  and the  number of  rows  of  B  respectively.\n+*\n+      NOTA = LSAME(TRANSA,'N')\n+      NOTB = LSAME(TRANSB,'N')\n+      IF (NOTA) THEN\n+          NROWA = M\n+          NCOLA = K\n+      ELSE\n+          NROWA = K\n+          NCOLA = M\n+      END IF\n+      IF (NOTB) THEN\n+          NROWB = K\n+      ELSE\n+          NROWB = N\n+      END IF\n+*\n+*     Test the input parameters.\n+*\n+      INFO = 0\n+      IF ((.NOT.NOTA) .AND. (.NOT.LSAME(TRANSA,'C')) .AND.\n+     +    (.NOT.LSAME(TRANSA,'T'))) THEN\n+          INFO = 1\n+      ELSE IF ((.NOT.NOTB) .AND. (.NOT.LSAME(TRANSB,'C')) .AND.\n+     +         (.NOT.LSAME(TRANSB,'T'))) THEN\n+          INFO = 2\n+      ELSE IF (M.LT.0) THEN\n+          INFO = 3\n+      ELSE IF (N.LT.0) THEN\n+          INFO = 4\n+      ELSE IF (K.LT.0) THEN\n+          INFO = 5\n+      ELSE IF (LDA.LT.MAX(1,NROWA)) THEN\n+          INFO = 8\n+      ELSE IF (LDB.LT.MAX(1,NROWB)) THEN\n+          INFO = 10\n+      ELSE IF (LDC.LT.MAX(1,M)) THEN\n+          INFO = 13\n+      END IF\n+      IF (INFO.NE.0) THEN\n+          CALL XERBLA('DGEMM ',INFO)\n+          RETURN\n+      END IF\n+*\n+*     Quick return if possible.\n+*\n+      IF ((M.EQ.0) .OR. (N.EQ.0) .OR.\n+     +    (((ALPHA.EQ.ZERO).OR. (K.EQ.0)).AND. (BETA.EQ.ONE))) RETURN\n+*\n+*     And if  alpha.eq.zero.\n+*\n+      IF (ALPHA.EQ.ZERO) THEN\n+          IF (BETA.EQ.ZERO) THEN\n+              DO 20 J = 1,N\n+                  DO 10 I = 1,M\n+                      C(I,J) = ZERO\n+   10             CONTINUE\n+   20         CONTINUE\n+          ELSE\n+              DO 40 J = 1,N\n+                  DO 30 I = 1,M\n+                      C(I,J) = BETA*C(I,J)\n+   30             CONTINUE\n+   40         CONTINUE\n+          END IF\n+          RETURN\n+      END IF\n+*\n+*     Start the operations.\n+*\n+      IF (NOTB) THEN\n+          IF (NOTA) THEN\n+*\n+*           Form  C := alpha*A*B + beta*C.\n+*\n+              DO 90 J = 1,N\n+                  IF (BETA.EQ.ZERO) THEN\n+                      DO 50 I = 1,M\n+                          C(I,J) = ZERO\n+   50                 CONTINUE\n+                  ELSE IF (BETA.NE.ONE) THEN\n+                      DO 60 I = 1,M\n+                          C(I,J) = BETA*C(I,J)\n+   60                 CONTINUE\n+                  END IF\n+                  DO 80 L = 1,K\n+                      TEMP = ALPHA*B(L,J)\n+                      DO 70 I = 1,M\n+                          C(I,J) = C(I,J) + TEMP*A(I,L)\n+   70                 CONTINUE\n+   80             CONTINUE\n+   90         CONTINUE\n+          ELSE\n+*\n+*           Form  C := alpha*A**T*B + beta*C\n+*\n+              DO 120 J = 1,N\n+                  DO 110 I = 1,M\n+                      TEMP = ZERO\n+                      DO 100 L = 1,K\n+                          TEMP = TEMP + A(L,I)*B(L,J)\n+  100                 CONTINUE\n+                      IF (BETA.EQ.ZERO) THEN\n+                          C(I,J) = ALPHA*TEMP\n+                      ELSE\n+                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)\n+                      END IF\n+  110             CONTINUE\n+  120         CONTINUE\n+          END IF\n+      ELSE\n+          IF (NOTA) THEN\n+*\n+*           Form  C := alpha*A*B**T + beta*C\n+*\n+              DO 170 J = 1,N\n+                  IF (BETA.EQ.ZERO) THEN\n+                      DO 130 I = 1,M\n+                          C(I,J) = ZERO\n+  130                 CONTINUE\n+                  ELSE IF (BETA.NE.ONE) THEN\n+                      DO 140 I = 1,M\n+                          C(I,J) = BETA*C(I,J)\n+  140                 CONTINUE\n+                  END IF\n+                  DO 160 L = 1,K\n+                      TEMP = ALPHA*B(J,L)\n+                      DO 150 I = 1,M\n+                          C(I,J) = C(I,J) + TEMP*A(I,L)\n+  150                 CONTINUE\n+  160             CONTINUE\n+  170         CONTINUE\n+          ELSE\n+*\n+*           Form  C := alpha*A**T*B**T + beta*C\n+*\n+              DO 200 J = 1,N\n+                  DO 190 I = 1,M\n+                      TEMP = ZERO\n+                      DO 180 L = 1,K\n+                          TEMP = TEMP + A(L,I)*B(J,L)\n+  180                 CONTINUE\n+                      IF (BETA.EQ.ZERO) THEN\n+                          C(I,J) = ALPHA*TEMP\n+                      ELSE\n+                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)\n+                      END IF\n+  190             CONTINUE\n+  200         CONTINUE\n+          END IF\n+      END IF\n+*\n+      RETURN\n+*\n+*     End of DGEMM .\n+*\n+      END\n+\n+*> \\brief \\b ZGEMM\n+*\n+*  =========== DOCUMENTATION ===========\n+*\n+* Online html documentation available at\n+*            http://www.netlib.org/lapack/explore-html/\n+*\n+*  Definition:\n+*  ===========\n+*\n+*       SUBROUTINE ZGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n+*\n+*       .. Scalar Arguments ..\n+*       COMPLEX*16 ALPHA,BETA\n+*       INTEGER K,LDA,LDB,LDC,M,N\n+*       CHARACTER TRANSA,TRANSB\n+*       ..\n+*       .. Array Arguments ..\n+*       COMPLEX*16 A(LDA,*),B(LDB,*),C(LDC,*)\n+*       ..\n+*\n+*\n+*> \\par Purpose:\n+*  =============\n+*>\n+*> \\verbatim\n+*>\n+*> ZGEMM  performs one of the matrix-matrix operations\n+*>\n+*>    C := alpha*op( A )*op( B ) + beta*C,\n+*>\n+*> where  op( X ) is one of\n+*>\n+*>    op( X ) = X   or   op( X ) = X**T   or   op( X ) = X**H,\n+*>\n+*> alpha and beta are scalars, and A, B and C are matrices, with op( A )\n+*> an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.\n+*> \\endverbatim\n+*\n+*  Arguments:\n+*  ==========\n+*\n+*> \\param[in] TRANSA\n+*> \\verbatim\n+*>          TRANSA is CHARACTER*1\n+*>           On entry, TRANSA specifies the form of op( A ) to be used in\n+*>           the matrix multiplication as follows:\n+*>\n+*>              TRANSA = 'N' or 'n',  op( A ) = A.\n+*>\n+*>              TRANSA = 'T' or 't',  op( A ) = A**T.\n+*>\n+*>              TRANSA = 'C' or 'c',  op( A ) = A**H.\n+*> \\endverbatim\n+*>\n+*> \\param[in] TRANSB\n+*> \\verbatim\n+*>          TRANSB is CHARACTER*1\n+*>           On entry, TRANSB specifies the form of op( B ) to be used in\n+*>           the matrix multiplication as follows:\n+*>\n+*>              TRANSB = 'N' or 'n',  op( B ) = B.\n+*>\n+*>              TRANSB = 'T' or 't',  op( B ) = B**T.\n+*>\n+*>              TRANSB = 'C' or 'c',  op( B ) = B**H.\n+*> \\endverbatim\n+*>\n+*> \\param[in] M\n+*> \\verbatim\n+*>          M is INTEGER\n+*>           On entry,  M  specifies  the number  of rows  of the  matrix\n+*>           op( A )  and of the  matrix  C.  M  must  be at least  zero.\n+*> \\endverbatim\n+*>\n+*> \\param[in] N\n+*> \\verbatim\n+*>          N is INTEGER\n+*>           On entry,  N  specifies the number  of columns of the matrix\n+*>           op( B ) and the number of columns of the matrix C. N must be\n+*>           at least zero.\n+*> \\endverbatim\n+*>\n+*> \\param[in] K\n+*> \\verbatim\n+*>          K is INTEGER\n+*>           On entry,  K  specifies  the number of columns of the matrix\n+*>           op( A ) and the number of rows of the matrix op( B ). K must\n+*>           be at least  zero.\n+*> \\endverbatim\n+*>\n+*> \\param[in] ALPHA\n+*> \\verbatim\n+*>          ALPHA is COMPLEX*16\n+*>           On entry, ALPHA specifies the scalar alpha.\n+*> \\endverbatim\n+*>\n+*> \\param[in] A\n+*> \\verbatim\n+*>          A is COMPLEX*16 array, dimension ( LDA, ka ), where ka is\n+*>           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.\n+*>           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k\n+*>           part of the array  A  must contain the matrix  A,  otherwise\n+*>           the leading  k by m  part of the array  A  must contain  the\n+*>           matrix A.\n+*> \\endverbatim\n+*>\n+*> \\param[in] LDA\n+*> \\verbatim\n+*>          LDA is INTEGER\n+*>           On entry, LDA specifies the first dimension of A as declared\n+*>           in the calling (sub) program. When  TRANSA = 'N' or 'n' then\n+*>           LDA must be at least  max( 1, m ), otherwise  LDA must be at\n+*>           least  max( 1, k ).\n+*> \\endverbatim\n+*>\n+*> \\param[in] B\n+*> \\verbatim\n+*>          B is COMPLEX*16 array, dimension ( LDB, kb ), where kb is\n+*>           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.\n+*>           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n\n+*>           part of the array  B  must contain the matrix  B,  otherwise\n+*>           the leading  n by k  part of the array  B  must contain  the\n+*>           matrix B.\n+*> \\endverbatim\n+*>\n+*> \\param[in] LDB\n+*> \\verbatim\n+*>          LDB is INTEGER\n+*>           On entry, LDB specifies the first dimension of B as declared\n+*>           in the calling (sub) program. When  TRANSB = 'N' or 'n' then\n+*>           LDB must be at least  max( 1, k ), otherwise  LDB must be at\n+*>           least  max( 1, n ).\n+*> \\endverbatim\n+*>\n+*> \\param[in] BETA\n+*> \\verbatim\n+*>          BETA is COMPLEX*16\n+*>           On entry,  BETA  specifies the scalar  beta.  When  BETA  is\n+*>           supplied as zero then C need not be set on input.\n+*> \\endverbatim\n+*>\n+*> \\param[in,out] C\n+*> \\verbatim\n+*>          C is COMPLEX*16 array, dimension ( LDC, N )\n+*>           Before entry, the leading  m by n  part of the array  C must\n+*>           contain the matrix  C,  except when  beta  is zero, in which\n+*>           case C need not be set on entry.\n+*>           On exit, the array  C  is overwritten by the  m by n  matrix\n+*>           ( alpha*op( A )*op( B ) + beta*C ).\n+*> \\endverbatim\n+*>\n+*> \\param[in] LDC\n+*> \\verbatim\n+*>          LDC is INTEGER\n+*>           On entry, LDC specifies the first dimension of C as declared\n+*>           in  the  calling  (sub)  program.   LDC  must  be  at  least\n+*>           max( 1, m ).\n+*> \\endverbatim\n+*\n+*  Authors:\n+*  ========\n+*\n+*> \\author Univ. of Tennessee\n+*> \\author Univ. of California Berkeley\n+*> \\author Univ. of Colorado Denver\n+*> \\author NAG Ltd.\n+*\n+*> \\date December 2016\n+*\n+*> \\ingroup complex16_blas_level3\n+*\n+*> \\par Further Details:\n+*  =====================\n+*>\n+*> \\verbatim\n+*>\n+*>  Level 3 Blas routine.\n+*>\n+*>  -- Written on 8-February-1989.\n+*>     Jack Dongarra, Argonne National Laboratory.\n+*>     Iain Duff, AERE Harwell.\n+*>     Jeremy Du Croz, Numerical Algorithms Group Ltd.\n+*>     Sven Hammarling, Numerical Algorithms Group Ltd.\n+*> \\endverbatim\n+*>\n+*  =====================================================================\n+      SUBROUTINE ZGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)\n+*\n+*  -- Reference BLAS level3 routine (version 3.7.0) --\n+*  -- Reference BLAS is a software package provided by Univ. of Tennessee,    --\n+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n+*     December 2016\n+*\n+*     .. Scalar Arguments ..\n+      COMPLEX*16 ALPHA,BETA\n+      INTEGER K,LDA,LDB,LDC,M,N\n+      CHARACTER TRANSA,TRANSB\n+*     ..\n+*     .. Array Arguments ..\n+      COMPLEX*16 A(LDA,*),B(LDB,*),C(LDC,*)\n+*     ..\n+*\n+*  =====================================================================\n+*\n+*     .. External Functions ..\n+      LOGICAL LSAME\n+      EXTERNAL LSAME\n+*     ..\n+*     .. External Subroutines ..\n+      EXTERNAL XERBLA\n+*     ..\n+*     .. Intrinsic Functions ..\n+      INTRINSIC DCONJG,MAX\n+*     ..\n+*     .. Local Scalars ..\n+      COMPLEX*16 TEMP\n+      INTEGER I,INFO,J,L,NCOLA,NROWA,NROWB\n+      LOGICAL CONJA,CONJB,NOTA,NOTB\n+*     ..\n+*     .. Parameters ..\n+      COMPLEX*16 ONE\n+      PARAMETER (ONE= (1.0D+0,0.0D+0))\n+      COMPLEX*16 ZERO\n+      PARAMETER (ZERO= (0.0D+0,0.0D+0))\n+*     ..\n+*\n+*     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not\n+*     conjugated or transposed, set  CONJA and CONJB  as true if  A  and\n+*     B  respectively are to be  transposed but  not conjugated  and set\n+*     NROWA, NCOLA and  NROWB  as the number of rows and  columns  of  A\n+*     and the number of rows of  B  respectively.\n+*\n+      NOTA = LSAME(TRANSA,'N')\n+      NOTB = LSAME(TRANSB,'N')\n+      CONJA = LSAME(TRANSA,'C')\n+      CONJB = LSAME(TRANSB,'C')\n+      IF (NOTA) THEN\n+          NROWA = M\n+          NCOLA = K\n+      ELSE\n+          NROWA = K\n+          NCOLA = M\n+      END IF\n+      IF (NOTB) THEN\n+          NROWB = K\n+      ELSE\n+          NROWB = N\n+      END IF\n+*\n+*     Test the input parameters.\n+*\n+      INFO = 0\n+      IF ((.NOT.NOTA) .AND. (.NOT.CONJA) .AND.\n+     +    (.NOT.LSAME(TRANSA,'T'))) THEN\n+          INFO = 1\n+      ELSE IF ((.NOT.NOTB) .AND. (.NOT.CONJB) .AND.\n+     +         (.NOT.LSAME(TRANSB,'T'))) THEN\n+          INFO = 2\n+      ELSE IF (M.LT.0) THEN\n+          INFO = 3\n+      ELSE IF (N.LT.0) THEN\n+          INFO = 4\n+      ELSE IF (K.LT.0) THEN\n+          INFO = 5\n+      ELSE IF (LDA.LT.MAX(1,NROWA)) THEN\n+          INFO = 8\n+      ELSE IF (LDB.LT.MAX(1,NROWB)) THEN\n+          INFO = 10\n+      ELSE IF (LDC.LT.MAX(1,M)) THEN\n+          INFO = 13\n+      END IF\n+      IF (INFO.NE.0) THEN\n+          CALL XERBLA('ZGEMM ',INFO)\n+          RETURN\n+      END IF\n+*\n+*     Quick return if possible.\n+*\n+      IF ((M.EQ.0) .OR. (N.EQ.0) .OR.\n+     +    (((ALPHA.EQ.ZERO).OR. (K.EQ.0)).AND. (BETA.EQ.ONE))) RETURN\n+*\n+*     And when  alpha.eq.zero.\n+*\n+      IF (ALPHA.EQ.ZERO) THEN\n+          IF (BETA.EQ.ZERO) THEN\n+              DO 20 J = 1,N\n+                  DO 10 I = 1,M\n+                      C(I,J) = ZERO\n+   10             CONTINUE\n+   20         CONTINUE\n+          ELSE\n+              DO 40 J = 1,N\n+                  DO 30 I = 1,M\n+                      C(I,J) = BETA*C(I,J)\n+   30             CONTINUE\n+   40         CONTINUE\n+          END IF\n+          RETURN\n+      END IF\n+*\n+*     Start the operations.\n+*\n+      IF (NOTB) THEN\n+          IF (NOTA) THEN\n+*\n+*           Form  C := alpha*A*B + beta*C.\n+*\n+              DO 90 J = 1,N\n+                  IF (BETA.EQ.ZERO) THEN\n+                      DO 50 I = 1,M\n+                          C(I,J) = ZERO\n+   50                 CONTINUE\n+                  ELSE IF (BETA.NE.ONE) THEN\n+                      DO 60 I = 1,M\n+                          C(I,J) = BETA*C(I,J)\n+   60                 CONTINUE\n+                  END IF\n+                  DO 80 L = 1,K\n+                      TEMP = ALPHA*B(L,J)\n+                      DO 70 I = 1,M\n+                          C(I,J) = C(I,J) + TEMP*A(I,L)\n+   70                 CONTINUE\n+   80             CONTINUE\n+   90         CONTINUE\n+          ELSE IF (CONJA) THEN\n+*\n+*           Form  C := alpha*A**H*B + beta*C.\n+*\n+              DO 120 J = 1,N\n+                  DO 110 I = 1,M\n+                      TEMP = ZERO\n+                      DO 100 L = 1,K\n+                          TEMP = TEMP + DCONJG(A(L,I))*B(L,J)\n+  100                 CONTINUE\n+                      IF (BETA.EQ.ZERO) THEN\n+                          C(I,J) = ALPHA*TEMP\n+                      ELSE\n+                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)\n+                      END IF\n+  110             CONTINUE\n+  120         CONTINUE\n+          ELSE\n+*\n+*           Form  C := alpha*A**T*B + beta*C\n+*\n+              DO 150 J = 1,N\n+                  DO 140 I = 1,M\n+                      TEMP = ZERO\n+                      DO 130 L = 1,K\n+                          TEMP = TEMP + A(L,I)*B(L,J)\n+  130                 CONTINUE\n+                      IF (BETA.EQ.ZERO) THEN\n+                          C(I,J) = ALPHA*TEMP\n+                      ELSE\n+                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)\n+                      END IF\n+  140             CONTINUE\n+  150         CONTINUE\n+          END IF\n+      ELSE IF (NOTA) THEN\n+          IF (CONJB) THEN\n+*\n+*           Form  C := alpha*A*B**H + beta*C.\n+*\n+              DO 200 J = 1,N\n+                  IF (BETA.EQ.ZERO) THEN\n+                      DO 160 I = 1,M\n+                          C(I,J) = ZERO\n+  160                 CONTINUE\n+                  ELSE IF (BETA.NE.ONE) THEN\n+                      DO 170 I = 1,M\n+                          C(I,J) = BETA*C(I,J)\n+  170                 CONTINUE\n+                  END IF\n+                  DO 190 L = 1,K\n+                      TEMP = ALPHA*DCONJG(B(J,L))\n+                      DO 180 I = 1,M\n+                          C(I,J) = C(I,J) + TEMP*A(I,L)\n+  180                 CONTINUE\n+  190             CONTINUE\n+  200         CONTINUE\n+          ELSE\n+*\n+*           Form  C := alpha*A*B**T + beta*C\n+*\n+              DO 250 J = 1,N\n+                  IF (BETA.EQ.ZERO) THEN\n+                      DO 210 I = 1,M\n+                          C(I,J) = ZERO\n+  210                 CONTINUE\n+                  ELSE IF (BETA.NE.ONE) THEN\n+                      DO 220 I = 1,M\n+                          C(I,J) = BETA*C(I,J)\n+  220                 CONTINUE\n+                  END IF\n+                  DO 240 L = 1,K\n+                      TEMP = ALPHA*B(J,L)\n+                      DO 230 I = 1,M\n+                          C(I,J) = C(I,J) + TEMP*A(I,L)\n+  230                 CONTINUE\n+  240             CONTINUE\n+  250         CONTINUE\n+          END IF\n+      ELSE IF (CONJA) THEN\n+          IF (CONJB) THEN\n+*\n+*           Form  C := alpha*A**H*B**H + beta*C.\n+*\n+              DO 280 J = 1,N\n+                  DO 270 I = 1,M\n+                      TEMP = ZERO\n+                      DO 260 L = 1,K\n+                          TEMP = TEMP + DCONJG(A(L,I))*DCONJG(B(J,L))\n+  260                 CONTINUE\n+                      IF (BETA.EQ.ZERO) THEN\n+                          C(I,J) = ALPHA*TEMP\n+                      ELSE\n+                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)\n+                      END IF\n+  270             CONTINUE\n+  280         CONTINUE\n+          ELSE\n+*\n+*           Form  C := alpha*A**H*B**T + beta*C\n+*\n+              DO 310 J = 1,N\n+                  DO 300 I = 1,M\n+                      TEMP = ZERO\n+                      DO 290 L = 1,K\n+                          TEMP = TEMP + DCONJG(A(L,I))*B(J,L)\n+  290                 CONTINUE\n+                      IF (BETA.EQ.ZERO) THEN\n+                          C(I,J) = ALPHA*TEMP\n+                      ELSE\n+                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)\n+                      END IF\n+  300             CONTINUE\n+  310         CONTINUE\n+          END IF\n+      ELSE\n+          IF (CONJB) THEN\n+*\n+*           Form  C := alpha*A**T*B**H + beta*C\n+*\n+              DO 340 J = 1,N\n+                  DO 330 I = 1,M\n+                      TEMP = ZERO\n+                      DO 320 L = 1,K\n+                          TEMP = TEMP + A(L,I)*DCONJG(B(J,L))\n+  320                 CONTINUE\n+                      IF (BETA.EQ.ZERO) THEN\n+                          C(I,J) = ALPHA*TEMP\n+                      ELSE\n+                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)\n+                      END IF\n+  330             CONTINUE\n+  340         CONTINUE\n+          ELSE\n+*\n+*           Form  C := alpha*A**T*B**T + beta*C\n+*\n+              DO 370 J = 1,N\n+                  DO 360 I = 1,M\n+                      TEMP = ZERO\n+                      DO 350 L = 1,K\n+                          TEMP = TEMP + A(L,I)*B(J,L)\n+  350                 CONTINUE\n+                      IF (BETA.EQ.ZERO) THEN\n+                          C(I,J) = ALPHA*TEMP\n+                      ELSE\n+                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)\n+                      END IF\n+  360             CONTINUE\n+  370         CONTINUE\n+          END IF\n+      END IF\n+*\n+      RETURN\n+*\n+*     End of ZGEMM .\n+*\n+      END"}, {"sha": "8ccfdd5e67d8b153f55d54931606cfb9ee7f825a", "filename": "gcc/testsuite/gfortran.dg/inline_matmul_13.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_13.f90?ref=998511a6100212931d039e3a46403d2d878c8e5a", "patch": "@@ -44,4 +44,4 @@ program main\n   deallocate(calloc)\n \n end program main\n-! { dg-final { scan-tree-dump-times \"_gfortran_matmul\" 0 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_matmul\" 1 \"original\" } }"}, {"sha": "580cb1ac9393c052f0b3f83c3484cd19d32925ca", "filename": "gcc/testsuite/gfortran.dg/inline_matmul_16.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_16.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_16.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_16.f90?ref=998511a6100212931d039e3a46403d2d878c8e5a", "patch": "@@ -58,4 +58,4 @@ program main\n      end do\n   end do\n end program main\n-! { dg-final { scan-tree-dump-times \"_gfortran_matmul\" 0 \"optimized\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_matmul\" 1 \"optimized\" } }"}, {"sha": "6a88981c9d71901ba98b2e11304654958a1ffc78", "filename": "gcc/testsuite/gfortran.dg/matmul_blas_1.f", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_blas_1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_blas_1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_blas_1.f?ref=998511a6100212931d039e3a46403d2d878c8e5a", "patch": "@@ -0,0 +1,240 @@\n+C { dg-do  run }\n+C { dg-options \"-fcheck=bounds -fdump-tree-optimized -fblas-matmul-limit=1 -O -fexternal-blas\" }\n+C { dg-additional-sources blas_gemm_routines.f }\n+C Test calling of BLAS routines\n+\n+      program main\n+      call sub_s\n+      call sub_d\n+      call sub_c\n+      call sub_z\n+      end\n+\n+      subroutine sub_d\n+      implicit none\n+      real(8), dimension(3,2) :: a\n+      real(8), dimension(2,3) :: at\n+      real(8), dimension(2,4) :: b\n+      real(8), dimension(4,2) :: bt\n+      real(8), dimension(3,4) :: c\n+      real(8), dimension(3,4) :: cres\n+      real(8), dimension(:,:), allocatable :: c_alloc\n+      data a / 2.,  -3.,  5.,  -7., 11., -13./\n+      data b /17., -23., 29., -31., 37., -39., 41., -47./\n+      data cres /195., -304.,  384.,  275., -428.,  548.,  347., -540.,\n+     &           692.,  411., -640.,  816./\n+\n+      c = matmul(a,b)\n+      if (any (c /= cres)) stop 31\n+\n+      at = transpose(a)\n+      c = (1.2,-2.2)\n+      c = matmul(transpose(at), b)\n+      if (any (c /= cres)) stop 32\n+\n+      bt = transpose(b)\n+      c = (1.2,-2.1)\n+      c = matmul(a, transpose(bt))\n+      if (any (c /= cres)) stop 33\n+\n+      c_alloc = matmul(a,b)\n+      if (any (c /= cres)) stop 34\n+\n+      at = transpose(a)\n+      deallocate (c_alloc)\n+      c = matmul(transpose(at), b)\n+      if (any (c /= cres)) stop 35\n+\n+      bt = transpose(b)\n+      allocate (c_alloc(20,20))\n+      c = (1.2,-2.1)\n+      c = matmul(a, transpose(bt))\n+      if (any (c /= cres)) stop 36\n+\n+      end\n+\n+      subroutine sub_s\n+      implicit none\n+      real, dimension(3,2) :: a\n+      real, dimension(2,3) :: at\n+      real, dimension(2,4) :: b\n+      real, dimension(4,2) :: bt\n+      real, dimension(3,4) :: c\n+      real, dimension(3,4) :: cres\n+      real, dimension(:,:), allocatable :: c_alloc\n+      data a / 2.,  -3.,  5.,  -7., 11., -13./\n+      data b /17., -23., 29., -31., 37., -39., 41., -47./\n+      data cres /195., -304.,  384.,  275., -428.,  548.,  347., -540.,\n+     &           692.,  411., -640.,  816./\n+\n+      c = matmul(a,b)\n+      if (any (c /= cres)) stop 21\n+\n+      at = transpose(a)\n+      c = (1.2,-2.2)\n+      c = matmul(transpose(at), b)\n+      if (any (c /= cres)) stop 22\n+\n+      bt = transpose(b)\n+      c = (1.2,-2.1)\n+      c = matmul(a, transpose(bt))\n+      if (any (c /= cres)) stop 23\n+\n+      c_alloc = matmul(a,b)\n+      if (any (c /= cres)) stop 24\n+\n+      at = transpose(a)\n+      deallocate (c_alloc)\n+      c = matmul(transpose(at), b)\n+      if (any (c /= cres)) stop 25\n+\n+      bt = transpose(b)\n+      allocate (c_alloc(20,20))\n+      c = (1.2,-2.1)\n+      c = matmul(a, transpose(bt))\n+      if (any (c /= cres)) stop 26\n+\n+      end\n+\n+      subroutine sub_c\n+      implicit none\n+      complex, dimension(3,2) :: a\n+      complex, dimension(2,3) :: at, ah\n+      complex, dimension(2,4) :: b\n+      complex, dimension(4,2) :: bt, bh\n+      complex, dimension(3,4) :: c\n+      complex, dimension(3,4) :: cres\n+      complex, dimension(:,:), allocatable :: c_alloc\n+      \n+      data a / (2.,-3.), (-5.,7.), (11.,-13.), (17.,19), (-23., -29),\n+     &     (-31., 37.)/\n+\n+      data b / (-41., 43.), (-47., 53.), (-59.,-61.), (-67., 71),\n+     &     ( 73.,79. ), (83.,-89.), (97.,-101.), (-107.,-109.)/\n+      data cres /(-1759.,217.), (2522.,-358.), (-396.,-2376.),\n+     &     (-2789.,-11.),\n+     &     (4322.,202.), (-1992.,-4584.), (3485.,3.), (-5408.,-244.),\n+     &     (2550.,5750.), (143.,-4379.), (-478.,6794.), (7104.,-2952.) /\n+\n+      c = matmul(a,b)\n+      if (any (c /= cres)) stop 1\n+\n+      at = transpose(a)\n+      c = (1.2,-2.2)\n+      c = matmul(transpose(at), b)\n+      if (any (c /= cres)) stop 2\n+\n+      bt = transpose(b)\n+      c = (1.2,-2.1)\n+      c = matmul(a, transpose(bt))\n+      if (any (c /= cres)) stop 3\n+\n+      ah = transpose(conjg(a))\n+      c = (1.2,-2.2)\n+      c = matmul(conjg(transpose(ah)), b)\n+      if (any (c /= cres)) stop 4\n+\n+      bh = transpose(conjg(b))\n+      c = (1.2,-2.2)\n+      c = matmul(a, transpose(conjg(bh)))\n+      if (any (c /= cres)) stop 5\n+\n+      c_alloc = matmul(a,b)\n+      if (any (c /= cres)) stop 6\n+\n+      at = transpose(a)\n+      deallocate (c_alloc)\n+      c = matmul(transpose(at), b)\n+      if (any (c /= cres)) stop 7\n+\n+      bt = transpose(b)\n+      allocate (c_alloc(20,20))\n+      c = (1.2,-2.1)\n+      c = matmul(a, transpose(bt))\n+      if (any (c /= cres)) stop 8\n+\n+      ah = transpose(conjg(a))\n+      c = (1.2,-2.2)\n+      c = matmul(conjg(transpose(ah)), b)\n+      if (any (c /= cres)) stop 9\n+\n+      deallocate (c_alloc)\n+      allocate (c_alloc(0,0))\n+      bh = transpose(conjg(b))\n+      c = (1.2,-2.2)\n+      c = matmul(a, transpose(conjg(bh)))\n+      if (any (c /= cres)) stop 10\n+\n+      end\n+\n+      subroutine sub_z\n+      implicit none\n+      complex(8), dimension(3,2) :: a\n+      complex(8), dimension(2,3) :: at, ah\n+      complex(8), dimension(2,4) :: b\n+      complex(8), dimension(4,2) :: bt, bh\n+      complex(8), dimension(3,4) :: c\n+      complex(8), dimension(3,4) :: cres\n+      complex(8), dimension(:,:), allocatable :: c_alloc\n+      \n+      data a / (2.,-3.), (-5._8,7.), (11.,-13.), (17.,19),\n+     &         (-23., -29), (-31., 37.)/\n+\n+      data b / (-41., 43.), (-47., 53.), (-59.,-61.), (-67., 71),\n+     &     ( 73.,79. ), (83.,-89.), (97.,-101.), (-107.,-109.)/\n+      data cres /(-1759.,217.), (2522.,-358.), (-396.,-2376.),\n+     &     (-2789.,-11.),\n+     &     (4322.,202.), (-1992.,-4584.), (3485.,3.), (-5408.,-244.),\n+     &     (2550.,5750.), (143.,-4379.), (-478.,6794.), (7104.,-2952.) /\n+\n+      c = matmul(a,b)\n+      if (any (c /= cres)) stop 11\n+\n+      at = transpose(a)\n+      c = (1.2,-2.2)\n+      c = matmul(transpose(at), b)\n+      if (any (c /= cres)) stop 12\n+\n+      bt = transpose(b)\n+      c = (1.2,-2.1)\n+      c = matmul(a, transpose(bt))\n+      if (any (c /= cres)) stop 13\n+\n+      ah = transpose(conjg(a))\n+      c = (1.2,-2.2)\n+      c = matmul(conjg(transpose(ah)), b)\n+      if (any (c /= cres)) stop 14\n+\n+      bh = transpose(conjg(b))\n+      c = (1.2,-2.2)\n+      c = matmul(a, transpose(conjg(bh)))\n+      if (any (c /= cres)) stop 15\n+\n+      c_alloc = matmul(a,b)\n+      if (any (c /= cres)) stop 16\n+\n+      at = transpose(a)\n+      deallocate (c_alloc)\n+      c = matmul(transpose(at), b)\n+      if (any (c /= cres)) stop 17\n+\n+      bt = transpose(b)\n+      allocate (c_alloc(20,20))\n+      c = (1.2,-2.1)\n+      c = matmul(a, transpose(bt))\n+      if (any (c /= cres)) stop 18\n+\n+      ah = transpose(conjg(a))\n+      c = (1.2,-2.2)\n+      c = matmul(conjg(transpose(ah)), b)\n+      if (any (c /= cres)) stop 19\n+\n+      deallocate (c_alloc)\n+      allocate (c_alloc(0,0))\n+      bh = transpose(conjg(b))\n+      c = (1.2,-2.2)\n+      c = matmul(a, transpose(conjg(bh)))\n+      if (any (c /= cres)) stop 20\n+\n+      end\n+! { dg-final { scan-tree-dump-times \"_gfortran_matmul\" 0 \"optimized\" } }"}, {"sha": "4c8a51521d62fc8f8d845d3195fff2ae7bd8a598", "filename": "gcc/testsuite/gfortran.dg/matmul_bounds_14.f", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_14.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_14.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_14.f?ref=998511a6100212931d039e3a46403d2d878c8e5a", "patch": "@@ -0,0 +1,16 @@\n+C { dg-do  run }\n+C { dg-options \"-fno-realloc-lhs -fdump-tree-optimized -fcheck=bounds -fblas-matmul-limit=1 -O -fexternal-blas\" }\n+C { dg-shouldfail \"Fortran runtime error: Array bound mismatch for dimension 2 of array.\" }\n+C { dg-additional-sources blas_gemm_routines.f }\n+\n+      program main\n+      real, dimension(3,2) :: a\n+      real, dimension(2,3) :: b\n+      real, dimension(:,:), allocatable :: ret\n+      a = 1.0\n+      b = 2.3\n+      allocate(ret(3,2))\n+      ret = matmul(a,b)         ! This should throw an error.\n+      end\n+! { dg-output \"Fortran runtime error: Array bound mismatch for dimension 2 of array.*\" }\n+! { dg-final { scan-tree-dump-times \"_gfortran_matmul\" 0 \"optimized\" } }"}, {"sha": "db4627adb9fdf0c1a6ae8cbea061481aaee04d93", "filename": "gcc/testsuite/gfortran.dg/matmul_bounds_15.f", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_15.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_15.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_15.f?ref=998511a6100212931d039e3a46403d2d878c8e5a", "patch": "@@ -0,0 +1,19 @@\n+C { dg-do  run }\n+C { dg-options \"-fdump-tree-optimized -fcheck=bounds -fblas-matmul-limit=1 -O -fexternal-blas\" }\n+C { dg-shouldfail \"Fortran runtime error: Incorrect extent in argument B in MATMUL intrinsic in dimension 1.*\" }\n+C { dg-additional-sources blas_gemm_routines.f }\n+      program main\n+      character(len=20) :: line\n+      integer :: n, m\n+      real, dimension(3,2) :: a\n+      real, dimension(:,:), allocatable :: b\n+      real, dimension(:,:), allocatable :: ret\n+      a = 1.0\n+      line = '3 3'\n+      read (unit=line,fmt=*) n, m\n+      allocate (b(n,m))\n+      b = 2.3\n+      ret = matmul(a,b)         ! This should throw an error.\n+      end\n+! { dg-output \"Fortran runtime error: Incorrect extent in argument B in MATMUL intrinsic in dimension 1.*\" }\n+! { dg-final { scan-tree-dump-times \"_gfortran_matmul\" 0 \"optimized\" } }"}, {"sha": "50e91ae4958af03cad5327f5623f7c9d2c6f37a0", "filename": "gcc/testsuite/gfortran.dg/matmul_bounds_16.f", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_16.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_16.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_bounds_16.f?ref=998511a6100212931d039e3a46403d2d878c8e5a", "patch": "@@ -0,0 +1,20 @@\n+C { dg-do  run }\n+C { dg-options \"-fdump-tree-optimized -fcheck=bounds -fblas-matmul-limit=1 -O -fexternal-blas\" }\n+C { dg-shouldfail \"Fortran runtime error: Incorrect extent in argument B in MATMUL intrinsic in dimension 1\" }\n+C { dg-additional-sources blas_gemm_routines.f }\n+\n+      program main\n+      character(len=20) :: line\n+      integer :: n, m\n+      real, dimension(3,2) :: a\n+      real, dimension(:,:), allocatable :: b\n+      real, dimension(:,:), allocatable :: ret\n+      a = 1.0\n+      line = '4 3'\n+      read (unit=line,fmt=*) n, m\n+      allocate (b(n,m))\n+      b = 2.3\n+      ret = matmul(transpose(a),b)         ! This should throw an error.\n+      end\n+! { dg-output \"Fortran runtime error: Incorrect extent in argument B in MATMUL intrinsic in dimension 1.*\" }\n+! { dg-final { scan-tree-dump-times \"_gfortran_matmul\" 0 \"optimized\" } }"}, {"sha": "83fc062767704431366b8e656911c54c5fac14f0", "filename": "gcc/testsuite/gfortran.dg/promotion_2.f90", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fpromotion_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/998511a6100212931d039e3a46403d2d878c8e5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fpromotion_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpromotion_2.f90?ref=998511a6100212931d039e3a46403d2d878c8e5a", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-options \"-fdefault-real-8 -fexternal-blas -fdump-tree-original -finline-matmul-limit=0\" }\n+! { dg-options \"-fdefault-real-8 -fexternal-blas -fblas-matmul-limit=1 -fdump-tree-original -finline-matmul-limit=0\" }\n !\n ! PR fortran/54463\n !\n@@ -8,8 +8,9 @@\n program test\n   implicit none\n   real, dimension(3,3) :: A\n+  call random_number(a)\n   A = matmul(A,A)\n end program test\n \n-! { dg-final { scan-tree-dump-times \"sgemm_\" 0 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"dgemm_\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sgemm\" 0 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"dgemm\" 1 \"original\" } }"}]}