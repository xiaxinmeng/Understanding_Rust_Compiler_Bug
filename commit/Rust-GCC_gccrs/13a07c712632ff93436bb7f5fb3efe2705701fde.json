{"sha": "13a07c712632ff93436bb7f5fb3efe2705701fde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNhMDdjNzEyNjMyZmY5MzQzNmJiN2Y1ZmIzZWZlMjcwNTcwMWZkZQ==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1992-03-22T22:25:42Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1992-03-22T22:25:42Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r570", "tree": {"sha": "a909bca90c692a7caaa140c4b41fe32f82e190ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a909bca90c692a7caaa140c4b41fe32f82e190ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13a07c712632ff93436bb7f5fb3efe2705701fde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13a07c712632ff93436bb7f5fb3efe2705701fde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13a07c712632ff93436bb7f5fb3efe2705701fde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13a07c712632ff93436bb7f5fb3efe2705701fde/comments", "author": null, "committer": null, "parents": [{"sha": "45848a8cf22dcb6203bde2a76d4f9091cc6f9320", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45848a8cf22dcb6203bde2a76d4f9091cc6f9320", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45848a8cf22dcb6203bde2a76d4f9091cc6f9320"}], "stats": {"total": 55, "additions": 22, "deletions": 33}, "files": [{"sha": "127d07776e0dff89d669aa7f500bb1e1d3764001", "filename": "gcc/config/pyr/pyr.h", "status": "modified", "additions": 22, "deletions": 33, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13a07c712632ff93436bb7f5fb3efe2705701fde/gcc%2Fconfig%2Fpyr%2Fpyr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13a07c712632ff93436bb7f5fb3efe2705701fde/gcc%2Fconfig%2Fpyr%2Fpyr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpyr%2Fpyr.h?ref=13a07c712632ff93436bb7f5fb3efe2705701fde", "patch": "@@ -52,21 +52,16 @@ extern int target_flags;\n /* Nonzero if compiling code that Unix assembler can assemble.  */\n #define TARGET_UNIX_ASM (target_flags & 1)\n \n-/* Use the indexed addressing modes (were once not known to work).\n-   Leaving this in means we can disable them and so find out what\n-   they win us.  */\n-#define TARGET_INDEX (target_flags & 2)\n-\n /* Implement stdarg in the same fashion used on all other machines.  */\n-#define TARGET_GNU_STDARG   (target_flags & 4)\n+#define TARGET_GNU_STDARG   (target_flags & 2)\n \n /* Compile using RETD to pop off the args.\n    This will not work unless you use prototypes at least\n    for all functions that can take varying numbers of args.\n    This contravenes the Pyramid calling convention, so we don't\n    do it yet.  */\n \n-#define TARGET_RETD (target_flags & 8)\n+#define TARGET_RETD (target_flags & 4)\n \n /* Macros used in the machine description to test the flags.  */\n \n@@ -76,27 +71,23 @@ extern int target_flags;\n    where VALUE is the bits to set or minus the bits to clear.\n    An empty string NAME is used to identify the default VALUE.\n \n-   -mgnu will be useful if we ever have GAS on a pyramid.\n-   -mindex was used to enable indexing when I didn't understand\n-    how pyramid's indexing modes worked.  */\n+   -mgnu will be useful if we ever have GAS on a pyramid.  */\n \n #define TARGET_SWITCHES  \\\n   { {\"unix\", 1},  \t\t\\\n     {\"gnu\", -1},  \t\t\\\n-    {\"index\", 2},\t\t\\\n-    {\"noindex\", -2},\t\t\\\n-    {\"gnu-stdarg\", 4},\t\t\\\n-    {\"nognu-stdarg\", -4},\t\\\n-    {\"retd\", 8},\t\t\\\n-    {\"no-retd\", -8},\t\t\\\n+    {\"gnu-stdarg\", 2},\t\t\\\n+    {\"nognu-stdarg\", -2},\t\\\n+    {\"retd\", 4},\t\t\\\n+    {\"no-retd\", -4},\t\t\\\n     { \"\", TARGET_DEFAULT}}\n \n /* Default target_flags if no switches specified.\n \n    (equivalent to \"-munix -mindex -mgnu-stdarg\")  */\n \n #ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT (1 + 2 + 4)\n+#define TARGET_DEFAULT (1 + 2)\n #endif\n \n /* Never allow $ in identifiers */\n@@ -105,16 +96,17 @@ extern int target_flags;\n \f\n /*** Target machine storage layout ***/\n \n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.\n+/* Define this to non-zero if most significant bit is lowest\n+   numbered in instructions that operate on numbered bit-fields.\n    This is not true on the pyramid.  */\n #define BITS_BIG_ENDIAN 0\n \n-/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* Define this to non-zero if most significant byte of a word is\n+   the lowest numbered.  */\n #define BYTES_BIG_ENDIAN 1\n \n-/* Define this if most significant word of a multiword number is the lowest\n-   numbered.  */\n+/* Define this to non-zero if most significant word of a multiword\n+   number is the lowest numbered.  */\n #define WORDS_BIG_ENDIAN 1\n \n /* Number of bits in an addressable storage unit */\n@@ -146,7 +138,6 @@ extern int target_flags;\n #define EMPTY_FIELD_BOUNDARY 32\n \n /* Every structure's size must be a multiple of this.  */\n-/* ??? This is a guess.  */\n #define STRUCTURE_SIZE_BOUNDARY 32\n \n /* No data type wants to be aligned rounder than this.  */\n@@ -161,7 +152,6 @@ extern int target_flags;\n    on the size of a cache line, which is 32 bytes.\n    Newer pyrs have single insns that do strcmp() and strcpy(), so this\n    may not actually win anything.   */\n-\n #define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n   (TREE_CODE (EXP) == STRING_CST\t\\\n    && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n@@ -256,8 +246,7 @@ frame n    |            |            |            |\n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n \n-   On the pyramid, these are LOGPSW, CFP, SP, PC, and all the other \n-   global regs.  */\n+   On the pyramid, these are LOGPSW, SP, and PC.  */\n \n #define FIXED_REGISTERS \\\n   {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n@@ -314,7 +303,7 @@ frame n    |            |            |            |\n \n /* Base register for access to local variables of the function.\n    Pyramid uses CFP (GR13) as both frame pointer and argument pointer. */\n-#define FRAME_POINTER_REGNUM 13 /* PYR_GREG(13) */\n+#define FRAME_POINTER_REGNUM PYR_GREG(13)\n \n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms\n@@ -799,10 +788,11 @@ extern int current_function_calls_alloca;\n /* All registers except gr0 OK as index or base registers.  */\n \n #define REGNO_OK_FOR_BASE_P(regno) \\\n-((0 < (regno) && (regno) < FIRST_PSEUDO_REGISTER) || reg_renumber[regno] > 0)\n+((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] < FIRST_PSEUDO_REGISTER)\n \n #define REGNO_OK_FOR_INDEX_P(regno)  \\\n-((0 < (regno) && (regno) < FIRST_PSEUDO_REGISTER) || reg_renumber[regno] > 0)\n+((unsigned) (regno) - 1 < FIRST_PSEUDO_REGISTER - 1 \\\n+ || (unsigned) reg_renumber[regno] - 1 < FIRST_PSEUDO_REGISTER - 1)\n \n /* Maximum number of registers that can appear in a valid memory address.  */\n \n@@ -834,7 +824,7 @@ extern int current_function_calls_alloca;\n \n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) 1\n+#define REG_OK_FOR_INDEX_P(X) (REGNO (X) > 0)\n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X) 1\n@@ -857,8 +847,7 @@ extern int current_function_calls_alloca;\n    except for CONSTANT_ADDRESS_P which is actually machine-independent.  */\n \n \n-/* Go to ADDR if X is indexable -- ie, neither indexed nor offset.\n-   Note that X is indexable iff x is offset.  */\n+/* Go to ADDR if X is indexable -- i.e., neither indexed nor offset.  */\n #define GO_IF_INDEXABLE_ADDRESS(X, ADDR)  \\\n { register rtx xfoob = (X);\t\t\t\t\t\t\\\n   if ((CONSTANT_ADDRESS_P (xfoob))\t\t\t\t\t\\\n@@ -923,7 +912,7 @@ extern int current_function_calls_alloca;\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n { register rtx xone, xtwo, xfoo0, xfoo1;\t\t\t\t\\\n   GO_IF_NONINDEXED_ADDRESS (X, ADDR);\t\t\t\t\t\\\n-  if (TARGET_INDEX && GET_CODE (X) == PLUS)\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       /* Handle <address>[index] represented with index-sum outermost */\\\n       xone = XEXP (X, 0);\t\t\t\t\t\t\\"}]}