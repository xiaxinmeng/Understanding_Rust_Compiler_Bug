{"sha": "4c9b38955a4f023614b23e7ad5c99ef10e4d5b27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM5YjM4OTU1YTRmMDIzNjE0YjIzZTdhZDVjOTllZjEwZTRkNWIyNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-06-02T03:55:42Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-06-02T03:55:42Z"}, "message": "DR 990\n\n\tDR 990\n\t* call.c (add_list_candidates): Prefer the default constructor.\n\t(build_aggr_conv): Treat missing initializers like { }.\n\t* typeck2.c (process_init_constructor_record): Likewise.\n\t* init.c (expand_default_init): Use digest_init for\n\tdirect aggregate initialization, too.\n\n\t* call.c (add_list_candidates): Split out...\n\t(build_user_type_conversion_1): ...from here.\n\t(build_new_method_call): And here.\n\t(implicit_conversion): Propagate LOOKUP_NO_NARROWING.\n\nFrom-SVN: r160132", "tree": {"sha": "98bd2417ebc26a584ed6de5f1cfb8d4a2de56810", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98bd2417ebc26a584ed6de5f1cfb8d4a2de56810"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e5901560633ce741df65202f21afbb4733af8753", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5901560633ce741df65202f21afbb4733af8753", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5901560633ce741df65202f21afbb4733af8753"}], "stats": {"total": 239, "additions": 166, "deletions": 73}, "files": [{"sha": "f17c735d55d05a3185f5f6382c9b79f8e098c506", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4c9b38955a4f023614b23e7ad5c99ef10e4d5b27", "patch": "@@ -1,5 +1,17 @@\n 2010-06-01  Jason Merrill  <jason@redhat.com>\n \n+\tDR 990\n+\t* call.c (add_list_candidates): Prefer the default constructor.\n+\t(build_aggr_conv): Treat missing initializers like { }.\n+\t* typeck2.c (process_init_constructor_record): Likewise.\n+\t* init.c (expand_default_init): Use digest_init for\n+\tdirect aggregate initialization, too.\n+\n+\t* call.c (add_list_candidates): Split out...\n+\t(build_user_type_conversion_1): ...from here.\n+\t(build_new_method_call): And here.\n+\t(implicit_conversion): Propagate LOOKUP_NO_NARROWING.\n+\n \tPR c++/44358\n \t* call.c (build_list_conv): Set list-initialization flags properly.\n "}, {"sha": "b9f1c7fd4ec7ba829917806d6a3ee6d8e2aa9455", "filename": "gcc/cp/call.c", "status": "modified", "additions": 89, "deletions": 63, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4c9b38955a4f023614b23e7ad5c99ef10e4d5b27", "patch": "@@ -634,6 +634,7 @@ build_aggr_conv (tree type, tree ctor, int flags)\n   unsigned HOST_WIDE_INT i = 0;\n   conversion *c;\n   tree field = next_initializable_field (TYPE_FIELDS (type));\n+  tree empty_ctor = NULL_TREE;\n \n   for (; field; field = next_initializable_field (TREE_CHAIN (field)))\n     {\n@@ -647,8 +648,14 @@ build_aggr_conv (tree type, tree ctor, int flags)\n \t  if (TREE_CODE (type) == UNION_TYPE)\n \t    break;\n \t}\n-      else if (build_value_init (TREE_TYPE (field)) == error_mark_node)\n-\treturn NULL;\n+      else\n+\t{\n+\t  if (empty_ctor == NULL_TREE)\n+\t    empty_ctor = build_constructor (init_list_type_node, NULL);\n+\t  if (!can_convert_arg (TREE_TYPE (field), TREE_TYPE (empty_ctor),\n+\t\t\t\tempty_ctor, flags))\n+\t    return NULL;\n+\t}\n     }\n \n   if (i < CONSTRUCTOR_NELTS (ctor))\n@@ -1461,7 +1468,8 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n       && (flags & LOOKUP_NO_CONVERSION) == 0)\n     {\n       struct z_candidate *cand;\n-      int convflags = (flags & (LOOKUP_NO_TEMP_BIND|LOOKUP_ONLYCONVERTING));\n+      int convflags = (flags & (LOOKUP_NO_TEMP_BIND|LOOKUP_ONLYCONVERTING\n+\t\t\t\t|LOOKUP_NO_NARROWING));\n \n       if (CLASS_TYPE_P (to)\n \t  && !CLASSTYPE_NON_AGGREGATE (complete_type (to))\n@@ -2813,6 +2821,65 @@ merge_conversion_sequences (conversion *user_seq, conversion *std_seq)\n   return std_seq;\n }\n \n+/* Handle overload resolution for initializing an object of class type from\n+   an initializer list.  First we look for a suitable constructor that\n+   takes a std::initializer_list; if we don't find one, we then look for a\n+   non-list constructor.\n+\n+   Parameters are as for add_candidates, except that the arguments are in\n+   the form of a CONSTRUCTOR (the initializer list) rather than a VEC, and\n+   the RETURN_TYPE parameter is replaced by TOTYPE, the desired type.  */\n+\n+static void\n+add_list_candidates (tree fns, tree first_arg,\n+\t\t     tree init_list, tree totype,\n+\t\t     tree explicit_targs, bool template_only,\n+\t\t     tree conversion_path, tree access_path,\n+\t\t     int flags,\n+\t\t     struct z_candidate **candidates)\n+{\n+  VEC(tree,gc) *args;\n+\n+  gcc_assert (*candidates == NULL);\n+\n+  /* For list-initialization we consider explicit constructors, but\n+     give an error if one is selected.  */\n+  flags &= ~LOOKUP_ONLYCONVERTING;\n+  /* And we don't allow narrowing conversions.  We also use this flag to\n+     avoid the copy constructor call for copy-list-initialization.  */\n+  flags |= LOOKUP_NO_NARROWING;\n+\n+  /* Always use the default constructor if the list is empty (DR 990).  */\n+  if (CONSTRUCTOR_NELTS (init_list) == 0\n+      && TYPE_HAS_DEFAULT_CONSTRUCTOR (totype))\n+    ;\n+  /* If the class has a list ctor, try passing the list as a single\n+     argument first, but only consider list ctors.  */\n+  else if (TYPE_HAS_LIST_CTOR (totype))\n+    {\n+      flags |= LOOKUP_LIST_ONLY;\n+      args = make_tree_vector_single (init_list);\n+      add_candidates (fns, first_arg, args, NULL_TREE,\n+\t\t      explicit_targs, template_only, conversion_path,\n+\t\t      access_path, flags, candidates);\n+      if (any_strictly_viable (*candidates))\n+\treturn;\n+    }\n+\n+  args = ctor_to_vec (init_list);\n+\n+  /* We aren't looking for list-ctors anymore.  */\n+  flags &= ~LOOKUP_LIST_ONLY;\n+  /* We allow more user-defined conversions within an init-list.  */\n+  flags &= ~LOOKUP_NO_CONVERSION;\n+  /* But not for the copy ctor.  */\n+  flags |= LOOKUP_NO_COPY_CTOR_CONVERSION;\n+\n+  add_candidates (fns, first_arg, args, NULL_TREE,\n+\t\t  explicit_targs, template_only, conversion_path,\n+\t\t  access_path, flags, candidates);\n+}\n+\n /* Returns the best overload candidate to perform the requested\n    conversion.  This function is used for three the overloading situations\n    described in [over.match.copy], [over.match.conv], and [over.match.ref].\n@@ -2872,49 +2939,25 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n   if (ctors)\n     {\n       int ctorflags = flags;\n-      bool try_single_arg = true;\n       ctors = BASELINK_FUNCTIONS (ctors);\n \n       first_arg = build_int_cst (build_pointer_type (totype), 0);\n-      if (BRACE_ENCLOSED_INITIALIZER_P (expr))\n-\t{\n-\t  /* For list-initialization we consider explicit constructors, but\n-\t     give an error if one is selected.  */\n-\t  ctorflags &= ~LOOKUP_ONLYCONVERTING;\n-\t  /* If the class has a list ctor, try passing the list as a single\n-\t     argument first, but only consider list ctors.  */\n-\t  if (TYPE_HAS_LIST_CTOR (totype))\n-\t    ctorflags |= LOOKUP_LIST_ONLY;\n-\t  else\n-\t    try_single_arg = false;\n-\t}\n \n       /* We should never try to call the abstract or base constructor\n \t from here.  */\n       gcc_assert (!DECL_HAS_IN_CHARGE_PARM_P (OVL_CURRENT (ctors))\n \t\t  && !DECL_HAS_VTT_PARM_P (OVL_CURRENT (ctors)));\n \n-      /* If EXPR is not an initializer-list, or if totype has a list\n-\t constructor, try EXPR as a single argument.  */\n-      if (try_single_arg)\n+      if (BRACE_ENCLOSED_INITIALIZER_P (expr))\n \t{\n-\t  args = make_tree_vector_single (expr);\n-\t  add_candidates (ctors, first_arg, args, NULL_TREE, NULL_TREE, false,\n-\t\t\t  TYPE_BINFO (totype), TYPE_BINFO (totype),\n-\t\t\t  ctorflags, &candidates);\n+\t  /* List-initialization.  */\n+\t  add_list_candidates (ctors, first_arg, expr, totype, NULL_TREE,\n+\t\t\t       false, TYPE_BINFO (totype), TYPE_BINFO (totype),\n+\t\t\t       ctorflags, &candidates);\n \t}\n-\n-      /* If we didn't find a suitable list constructor for an initializer-list,\n-\t try breaking it apart.  */\n-      if (!candidates && BRACE_ENCLOSED_INITIALIZER_P (expr))\n+      else\n \t{\n-\t  args = ctor_to_vec (expr);\n-\t  /* We aren't looking for list-ctors anymore.  */\n-\t  ctorflags &= ~LOOKUP_LIST_ONLY;\n-\t  /* We still allow more conversions within an init-list.  */\n-\t  ctorflags &= ~LOOKUP_NO_CONVERSION;\n-\t  /* But not for the copy ctor.  */\n-\t  ctorflags |= LOOKUP_NO_COPY_CTOR_CONVERSION;\n+\t  args = make_tree_vector_single (expr);\n \t  add_candidates (ctors, first_arg, args, NULL_TREE, NULL_TREE, false,\n \t\t\t  TYPE_BINFO (totype), TYPE_BINFO (totype),\n \t\t\t  ctorflags, &candidates);\n@@ -6233,8 +6276,6 @@ build_new_method_call (tree instance, tree fns, VEC(tree,gc) **args,\n   tree orig_fns;\n   VEC(tree,gc) *orig_args = NULL;\n   void *p;\n-  tree list = NULL_TREE;\n-  bool try_normal;\n \n   gcc_assert (instance != NULL_TREE);\n \n@@ -6346,47 +6387,32 @@ build_new_method_call (tree instance, tree fns, VEC(tree,gc) **args,\n   if (DECL_DESTRUCTOR_P (fn))\n     name = complete_dtor_identifier;\n \n+  first_mem_arg = instance_ptr;\n+\n+  /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n+  p = conversion_obstack_alloc (0);\n+\n   /* If CONSTRUCTOR_IS_DIRECT_INIT is set, this was a T{ } form\n-     initializer, not T({ }).  If the type doesn't have a list ctor (or no\n-     viable list ctor), break apart the list into separate ctor args.  */\n-  try_normal = true;\n+     initializer, not T({ }).  */\n   if (DECL_CONSTRUCTOR_P (fn) && args != NULL && !VEC_empty (tree, *args)\n       && BRACE_ENCLOSED_INITIALIZER_P (VEC_index (tree, *args, 0))\n       && CONSTRUCTOR_IS_DIRECT_INIT (VEC_index (tree, *args, 0)))\n     {\n       gcc_assert (VEC_length (tree, *args) == 1\n \t\t  && !(flags & LOOKUP_ONLYCONVERTING));\n-      list = VEC_index (tree, *args, 0);\n \n-      if (TYPE_HAS_LIST_CTOR (basetype))\n-\tflags |= LOOKUP_LIST_ONLY;\n-      else\n-\ttry_normal = false;\n+      add_list_candidates (fns, first_mem_arg, VEC_index (tree, *args, 0),\n+\t\t\t   basetype, explicit_targs, template_only,\n+\t\t\t   conversion_path, access_binfo, flags, &candidates);\n     }\n-\n-  first_mem_arg = instance_ptr;\n-\n-  /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n-  p = conversion_obstack_alloc (0);\n-\n-  any_viable_p = false;\n-  if (try_normal)\n+  else\n     {\n       add_candidates (fns, first_mem_arg, user_args, optype,\n \t\t      explicit_targs, template_only, conversion_path,\n \t\t      access_binfo, flags, &candidates);\n-      candidates = splice_viable (candidates, pedantic, &any_viable_p);\n-    }\n-\n-  if (!any_viable_p && list)\n-    {\n-      VEC(tree,gc) *list_args = ctor_to_vec (list);\n-      flags &= ~LOOKUP_LIST_ONLY;\n-      add_candidates (fns, first_mem_arg, list_args, optype,\n-\t\t      explicit_targs, template_only, conversion_path,\n-\t\t      access_binfo, flags, &candidates);\n-      candidates = splice_viable (candidates, pedantic, &any_viable_p);\n     }\n+  any_viable_p = false;\n+  candidates = splice_viable (candidates, pedantic, &any_viable_p);\n \n   if (!any_viable_p)\n     {"}, {"sha": "1f3e8035382a4a97eea8a2b551b024b5b644654d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=4c9b38955a4f023614b23e7ad5c99ef10e4d5b27", "patch": "@@ -1308,6 +1308,18 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n   tree rval;\n   VEC(tree,gc) *parms;\n \n+  if (init && BRACE_ENCLOSED_INITIALIZER_P (init)\n+      && CP_AGGREGATE_TYPE_P (type))\n+    {\n+      /* A brace-enclosed initializer for an aggregate.  In C++0x this can\n+\t happen for direct-initialization, too.  */\n+      init = digest_init (type, init);\n+      init = build2 (INIT_EXPR, TREE_TYPE (exp), exp, init);\n+      TREE_SIDE_EFFECTS (init) = 1;\n+      finish_expr_stmt (init);\n+      return;\n+    }\n+\n   if (init && TREE_CODE (init) != TREE_LIST\n       && (flags & LOOKUP_ONLYCONVERTING))\n     {\n@@ -1320,12 +1332,6 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n \t   to run a new constructor; and catching an exception, where we\n \t   have already built up the constructor call so we could wrap it\n \t   in an exception region.  */;\n-      else if (BRACE_ENCLOSED_INITIALIZER_P (init)\n-\t       && CP_AGGREGATE_TYPE_P (type))\n-\t{\n-\t  /* A brace-enclosed initializer for an aggregate.  */\n-\t  init = digest_init (type, init);\n-\t}\n       else\n \tinit = ocp_convert (type, init, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n "}, {"sha": "7603ead5463fee99d4b51f5f9448d10ec9d29e95", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=4c9b38955a4f023614b23e7ad5c99ef10e4d5b27", "patch": "@@ -1165,17 +1165,15 @@ process_init_constructor_record (tree type, tree init)\n \t     default-initialization, we can't rely on the back end to do it\n \t     for us, so build up TARGET_EXPRs.  If the type in question is\n \t     a class, just build one up; if it's an array, recurse.  */\n+\t  next = build_constructor (init_list_type_node, NULL);\n \t  if (MAYBE_CLASS_TYPE_P (TREE_TYPE (field)))\n \t    {\n-\t      next = build_functional_cast (TREE_TYPE (field), NULL_TREE,\n-\t\t\t\t\t    tf_warning_or_error);\n+\t      next = finish_compound_literal (TREE_TYPE (field), next);\n \t      /* direct-initialize the target. No temporary is going\n \t\t  to be involved.  */\n \t      if (TREE_CODE (next) == TARGET_EXPR)\n \t\tTARGET_EXPR_DIRECT_INIT_P (next) = true;\n \t    }\n-\t  else\n-\t    next = build_constructor (init_list_type_node, NULL);\n \n \t  next = digest_init_r (TREE_TYPE (field), next, true, LOOKUP_IMPLICIT);\n "}, {"sha": "05e5fdcfda854d489ca269eaed5b2c4f49566ae0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4c9b38955a4f023614b23e7ad5c99ef10e4d5b27", "patch": "@@ -1,5 +1,9 @@\n 2010-06-01  Jason Merrill  <jason@redhat.com>\n \n+\tDR 990\n+\t* g++.dg/cpp0x/initlist37.C: New.\n+\t* g++.dg/cpp0x/initlist38.C: New.\n+\n \tPR c++/44358\n \t* g++.dg/cpp0x/initlist36.C: New.\n "}, {"sha": "94624c977c92ecb7c1efe61d9437dda237523cf9", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist36.C", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist36.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist36.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist36.C?ref=4c9b38955a4f023614b23e7ad5c99ef10e4d5b27", "patch": "@@ -18,4 +18,6 @@ int main()\n {\n   B b0 = {{1}};\n   B b1 = {{1.0}};\t\t// { dg-error \"narrowing\" }\n+  B b2 {1.0};\t\t\t// { dg-error \"narrowing\" }\n+  A a {1.0};\t\t\t// { dg-error \"narrowing\" }\n }"}, {"sha": "20c6ab6311f7bd826657126916174f841aa487b9", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist37.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist37.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist37.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist37.C?ref=4c9b38955a4f023614b23e7ad5c99ef10e4d5b27", "patch": "@@ -0,0 +1,24 @@\n+// DR 990\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <initializer_list>\n+\n+struct S {\n+  S(std::initializer_list<double>);  // #1\n+  S(std::initializer_list<int>);     // #2\n+  S();                                     // #3\n+  // ...\n+};\n+S s1 = { 1.0, 2.0, 3.0 };            // invoke #1\n+S s2 = { 1, 2, 3 };                  // invoke #2\n+S s3 = { };                          // invoke #3 (for value-initialization)\n+\n+\n+// Test some other situations, too.\n+void f (S);\n+int main()\n+{\n+  S s4 { };\n+  f({ });\n+  S {};\n+}"}, {"sha": "818d69ad654acb0b1476880efc95d36960dcc1ab", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist38.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist38.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9b38955a4f023614b23e7ad5c99ef10e4d5b27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist38.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist38.C?ref=4c9b38955a4f023614b23e7ad5c99ef10e4d5b27", "patch": "@@ -0,0 +1,21 @@\n+// DR 990\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <initializer_list>\n+\n+struct A {\n+  A(std::initializer_list<int>);  // #1\n+};\n+struct B {\n+  A a;\n+};\n+\n+void f (B);\n+int main()\n+{\n+  B{};\n+  f({});\n+  B b0 = { };\n+  B b1 { };    // OK, uses #1\n+  B b2 { 1 };  // { dg-error \"conversion\" }\n+}"}]}