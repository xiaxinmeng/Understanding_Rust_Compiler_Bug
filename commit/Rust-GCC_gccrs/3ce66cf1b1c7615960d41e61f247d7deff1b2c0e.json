{"sha": "3ce66cf1b1c7615960d41e61f247d7deff1b2c0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NlNjZjZjFiMWM3NjE1OTYwZDQxZTYxZjI0N2Q3ZGVmZjFiMmMwZQ==", "commit": {"author": {"name": "Dorit Naishlos", "email": "dorit@il.ibm.com", "date": "2005-03-29T17:45:39Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-03-29T17:45:39Z"}, "message": "tree-vectorizer.c (slpeel_update_phi_nodes_for_guard): Removed.\n\n        * tree-vectorizer.c (slpeel_update_phi_nodes_for_guard): Removed.\n        (slpeel_update_phi_nodes_for_guard1): New function.\n        (slpeel_update_phi_nodes_for_guard2): New function.\n        (slpeel_tree_peel_loop_to_edge): Call above new functions instead\n        of slpeel_update_phi_nodes_for_guard.\n        (vectorize_loops): Remove call to loop_closed_rewrite.\n        * tree-vect-transform.c (vect_update_ivs_after_vectorizer): Remove\n        assertion.\n\nFrom-SVN: r97195", "tree": {"sha": "e6548b44cf9744eae1bd130db12b3fcfe3fbc1f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6548b44cf9744eae1bd130db12b3fcfe3fbc1f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ce66cf1b1c7615960d41e61f247d7deff1b2c0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ce66cf1b1c7615960d41e61f247d7deff1b2c0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ce66cf1b1c7615960d41e61f247d7deff1b2c0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ce66cf1b1c7615960d41e61f247d7deff1b2c0e/comments", "author": null, "committer": null, "parents": [{"sha": "97b73103c46af5f6d81365e0edea4cfe1bbc3b33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97b73103c46af5f6d81365e0edea4cfe1bbc3b33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97b73103c46af5f6d81365e0edea4cfe1bbc3b33"}], "stats": {"total": 459, "additions": 373, "deletions": 86}, "files": [{"sha": "9b7386015aa352fd674de2e6907449fadd8e9dac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce66cf1b1c7615960d41e61f247d7deff1b2c0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce66cf1b1c7615960d41e61f247d7deff1b2c0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ce66cf1b1c7615960d41e61f247d7deff1b2c0e", "patch": "@@ -1,3 +1,14 @@\n+2005-03-29  Dorit Naishlos  <dorit@il.ibm.com>\n+\n+\t* tree-vectorizer.c (slpeel_update_phi_nodes_for_guard): Removed.\n+\t(slpeel_update_phi_nodes_for_guard1): New function.\n+\t(slpeel_update_phi_nodes_for_guard2): New function.\n+\t(slpeel_tree_peel_loop_to_edge): Call above new functions instead\n+\tof slpeel_update_phi_nodes_for_guard.\n+\t(vectorize_loops): Remove call to loop_closed_rewrite.\n+\t* tree-vect-transform.c (vect_update_ivs_after_vectorizer): Remove\n+\tassertion.\n+\n 2005-03-29  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/m32r/little.h (TARGET_ENDIAN_DEFAULT): Delete."}, {"sha": "5032dedf2a0c595f7216c0f491118936814e6d9f", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce66cf1b1c7615960d41e61f247d7deff1b2c0e/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce66cf1b1c7615960d41e61f247d7deff1b2c0e/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=3ce66cf1b1c7615960d41e61f247d7deff1b2c0e", "patch": "@@ -1453,8 +1453,6 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n         bsi_insert_before (&last_bsi, stmt, BSI_SAME_STMT);   \n \n       /* Fix phi expressions in the successor bb.  */\n-      gcc_assert (PHI_ARG_DEF_FROM_EDGE (phi1, update_e) ==\n-                  PHI_ARG_DEF_FROM_EDGE (phi, single_succ_edge (loop->latch)));\n       SET_PHI_ARG_DEF (phi1, update_e->dest_idx, ni_name);\n     }\n }"}, {"sha": "2f1d421ab6c5736564960fbed0bb490e712dfcef", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 362, "deletions": 84, "changes": 446, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ce66cf1b1c7615960d41e61f247d7deff1b2c0e/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ce66cf1b1c7615960d41e61f247d7deff1b2c0e/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=3ce66cf1b1c7615960d41e61f247d7deff1b2c0e", "patch": "@@ -153,7 +153,10 @@ static struct loop *slpeel_tree_duplicate_loop_to_edge_cfg\n   (struct loop *, struct loops *, edge);\n static void slpeel_update_phis_for_duplicate_loop \n   (struct loop *, struct loop *, bool after);\n-static void slpeel_update_phi_nodes_for_guard (edge, struct loop *, bool, bool);\n+static void slpeel_update_phi_nodes_for_guard1 \n+  (edge, struct loop *, bool, basic_block *, bitmap *); \n+static void slpeel_update_phi_nodes_for_guard2 \n+  (edge, struct loop *, bool, basic_block *);\n static edge slpeel_add_loop_guard (basic_block, tree, basic_block, basic_block);\n \n static void allocate_new_names (bitmap);\n@@ -448,110 +451,390 @@ slpeel_update_phis_for_duplicate_loop (struct loop *orig_loop,\n         controls whether LOOP is to be executed.  GUARD_EDGE is the edge that\n         originates from the guard-bb, skips LOOP and reaches the (unique) exit\n         bb of LOOP.  This loop-exit-bb is an empty bb with one successor.\n-        We denote this bb NEW_MERGE_BB because it had a single predecessor (the\n-        LOOP header) before the guard code was added, and now it became a merge\n+        We denote this bb NEW_MERGE_BB because before the guard code was added\n+        it had a single predecessor (the LOOP header), and now it became a merge\n         point of two paths - the path that ends with the LOOP exit-edge, and\n         the path that ends with GUARD_EDGE.\n+   - NEW_EXIT_BB: New basic block that is added by this function between LOOP\n+        and NEW_MERGE_BB. It is used to place loop-closed-ssa-form exit-phis.\n \n-        This function creates and updates the relevant phi nodes to account for\n-        the new incoming edge (GUARD_EDGE) into NEW_MERGE_BB:\n-        1. Create phi nodes at NEW_MERGE_BB.\n-        2. Update the phi nodes at the successor of NEW_MERGE_BB (denoted\n-           UPDATE_BB).  UPDATE_BB was the exit-bb of LOOP before NEW_MERGE_BB\n-           was added:\n+   ===> The CFG before the guard-code was added:\n+        LOOP_header_bb:\n+          loop_body\n+          if (exit_loop) goto update_bb\n+          else           goto LOOP_header_bb\n+        update_bb:\n \n-        ===> The CFG before the guard-code was added:\n+   ==> The CFG after the guard-code was added:\n+        guard_bb:\n+          if (LOOP_guard_condition) goto new_merge_bb\n+          else                      goto LOOP_header_bb\n         LOOP_header_bb:\n-          if (exit_loop) goto update_bb : LOOP_header_bb\n+          loop_body\n+          if (exit_loop_condition) goto new_merge_bb\n+          else                     goto LOOP_header_bb\n+        new_merge_bb:\n+          goto update_bb\n         update_bb:\n \n-        ==> The CFG after the guard-code was added:\n-        guard_bb: \n-          if (LOOP_guard_condition) goto new_merge_bb : LOOP_header_bb\n+   ==> The CFG after this function:\n+        guard_bb:\n+          if (LOOP_guard_condition) goto new_merge_bb\n+          else                      goto LOOP_header_bb\n         LOOP_header_bb:\n-          if (exit_loop_condition) goto new_merge_bb : LOOP_header_bb\n+          loop_body\n+          if (exit_loop_condition) goto new_exit_bb\n+          else                     goto LOOP_header_bb\n+        new_exit_bb:\n         new_merge_bb:\n           goto update_bb\n         update_bb:\n \n-   - ENTRY_PHIS: If ENTRY_PHIS is TRUE, this indicates that the phis in \n-        UPDATE_BB are loop entry phis, like the phis in the LOOP header,\n-        organized in the same order. \n-        If ENTRY_PHIs is FALSE, this indicates that the phis in UPDATE_BB are\n-        loop exit phis.\n-\n-   - IS_NEW_LOOP: TRUE if LOOP is a new loop (a duplicated copy of another\n-        \"original\" loop).  FALSE if LOOP is an original loop (not a newly \n-        created copy).  The SSA_NAME_AUX fields of the defs in the original\n-        loop are the corresponding new ssa-names used in the new duplicated\n-        loop copy.  IS_NEW_LOOP indicates which of the two args of the phi \n-        nodes in UPDATE_BB takes the original ssa-name, and which takes the \n-        new name: If IS_NEW_LOOP is TRUE, the phi-arg that is associated with\n-        the LOOP-exit-edge takes the new-name, and the phi-arg that is \n-        associated with GUARD_EDGE takes the original name.  If IS_NEW_LOOP is\n-        FALSE, it's the other way around.\n+   This function:\n+   1. creates and updates the relevant phi nodes to account for the new\n+      incoming edge (GUARD_EDGE) into NEW_MERGE_BB. This involves:\n+      1.1. Create phi nodes at NEW_MERGE_BB.\n+      1.2. Update the phi nodes at the successor of NEW_MERGE_BB (denoted\n+           UPDATE_BB).  UPDATE_BB was the exit-bb of LOOP before NEW_MERGE_BB\n+   2. preserves loop-closed-ssa-form by creating the required phi nodes\n+      at the exit of LOOP (i.e, in NEW_EXIT_BB).\n+\n+   There are two flavors to this function:\n+\n+   slpeel_update_phi_nodes_for_guard1:\n+     Here the guard controls whether we enter or skip LOOP, where LOOP is a\n+     prolog_loop (loop1 below), and the new phis created in NEW_MERGE_BB are\n+     for variables that have phis in the loop header.\n+\n+   slpeel_update_phi_nodes_for_guard2:\n+     Here the guard controls whether we enter or skip LOOP, where LOOP is an\n+     epilog_loop (loop2 below), and the new phis created in NEW_MERGE_BB are\n+     for variables that have phis in the loop exit.\n+\n+   I.E., the overall structure is:\n+\n+        loop1_preheader_bb:\n+                guard1 (goto loop1/merg1_bb)\n+        loop1\n+        loop1_exit_bb:\n+                guard2 (goto merge1_bb/merge2_bb)\n+        merge1_bb\n+        loop2\n+        loop2_exit_bb\n+        merge2_bb\n+        next_bb\n+\n+   slpeel_update_phi_nodes_for_guard1 takes care of creating phis in\n+   loop1_exit_bb and merge1_bb. These are entry phis (phis for the vars\n+   that have phis in loop1->header).\n+\n+   slpeel_update_phi_nodes_for_guard2 takes care of creating phis in\n+   loop2_exit_bb and merge2_bb. These are exit phis (phis for the vars\n+   that have phis in next_bb). It also adds some of these phis to\n+   loop1_exit_bb.\n+\n+   slpeel_update_phi_nodes_for_guard1 is always called before\n+   slpeel_update_phi_nodes_for_guard2. They are both needed in order\n+   to create correct data-flow and loop-closed-ssa-form.\n+\n+   Generally slpeel_update_phi_nodes_for_guard1 creates phis for variables\n+   that change between iterations of a loop (and therefore have a phi-node\n+   at the loop entry), whereas slpeel_update_phi_nodes_for_guard2 creates\n+   phis for variables that are used out of the loop (and therefore have \n+   loop-closed exit phis). Some variables may be both updated between \n+   iterations and used after the loop. This is why in loop1_exit_bb we\n+   may need both entry_phis (created by slpeel_update_phi_nodes_for_guard1)\n+   and exit phis (created by slpeel_update_phi_nodes_for_guard2).\n+\n+   - IS_NEW_LOOP: if IS_NEW_LOOP is true, then LOOP is a newly created copy of\n+     an original loop. i.e., we have:\n+\n+           orig_loop\n+           guard_bb (goto LOOP/new_merge)\n+           new_loop <-- LOOP\n+           new_exit\n+           new_merge\n+           next_bb\n+\n+     If IS_NEW_LOOP is false, then LOOP is an original loop, in which case we\n+     have:\n+\n+           new_loop\n+           guard_bb (goto LOOP/new_merge)\n+           orig_loop <-- LOOP\n+           new_exit\n+           new_merge\n+           next_bb\n+\n+     The ssa-names defined in the original loop have an SSA_NAME_AUX pointer\n+     that records the corresponding new ssa-name used in the new duplicated\n+     loop copy.\n   */\n \n+/* Function slpeel_update_phi_nodes_for_guard1\n+   \n+   Input:\n+   - GUARD_EDGE, LOOP, IS_NEW_LOOP, NEW_EXIT_BB - as explained above.\n+   - DEFS - a bitmap of ssa names to mark new names for which we recorded\n+            information. \n+   \n+   In the context of the overall structure, we have:\n+\n+        loop1_preheader_bb: \n+                guard1 (goto loop1/merg1_bb)\n+LOOP->  loop1\n+        loop1_exit_bb:\n+                guard2 (goto merge1_bb/merge2_bb)\n+        merge1_bb\n+        loop2\n+        loop2_exit_bb\n+        merge2_bb\n+        next_bb\n+\n+   For each name updated between loop iterations (i.e - for each name that has\n+   an entry (loop-header) phi in LOOP) we create a new phi in:\n+   1. merge1_bb (to account for the edge from guard1)\n+   2. loop1_exit_bb (an exit-phi to keep LOOP in loop-closed form)\n+*/\n+\n static void\n-slpeel_update_phi_nodes_for_guard (edge guard_edge, \n-\t\t\t\t   struct loop *loop,\n-\t\t\t\t   bool entry_phis,\n-\t\t\t\t   bool is_new_loop)\n+slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n+                                    bool is_new_loop, basic_block *new_exit_bb,\n+                                    bitmap *defs)\n {\n-  tree orig_phi, new_phi, update_phi;\n+  tree orig_phi, new_phi;\n+  tree update_phi, update_phi2;\n+  tree *new_name_ptr, *new_name_ptr2;\n   tree guard_arg, loop_arg;\n   basic_block new_merge_bb = guard_edge->dest;\n-  edge e = single_succ_edge (new_merge_bb);\n+  edge e = EDGE_SUCC (new_merge_bb, 0);\n   basic_block update_bb = e->dest;\n-  basic_block orig_bb = (entry_phis ? loop->header : update_bb);\n+  basic_block orig_bb = loop->header;\n+  edge new_exit_e;\n+  tree current_new_name;\n+\n+  /* Create new bb between loop and new_merge_bb.  */\n+  *new_exit_bb = split_edge (loop->single_exit);\n+  add_bb_to_loop (*new_exit_bb, loop->outer);\n+\n+  new_exit_e = EDGE_SUCC (*new_exit_bb, 0);\n \n   for (orig_phi = phi_nodes (orig_bb), update_phi = phi_nodes (update_bb);\n        orig_phi && update_phi;\n        orig_phi = PHI_CHAIN (orig_phi), update_phi = PHI_CHAIN (update_phi))\n     {\n-      /* 1. Generate new phi node in NEW_MERGE_BB:  */\n+      /** 1. Handle new-merge-point phis  **/\n+\n+      /* 1.1. Generate new phi node in NEW_MERGE_BB:  */\n+      new_phi = create_phi_node (SSA_NAME_VAR (PHI_RESULT (orig_phi)),\n+                                 new_merge_bb);\n+\n+      /* 1.2. NEW_MERGE_BB has two incoming edges: GUARD_EDGE and the exit-edge\n+            of LOOP. Set the two phi args in NEW_PHI for these edges:  */\n+      loop_arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, EDGE_SUCC (loop->latch, 0));\n+      guard_arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, loop_preheader_edge (loop));\n+\n+      add_phi_arg (new_phi, loop_arg, new_exit_e);\n+      add_phi_arg (new_phi, guard_arg, guard_edge);\n+\n+      /* 1.3. Update phi in successor block.  */\n+      gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi, e) == loop_arg\n+                  || PHI_ARG_DEF_FROM_EDGE (update_phi, e) == guard_arg);\n+      SET_PHI_ARG_DEF (update_phi, e->dest_idx, PHI_RESULT (new_phi));\n+      update_phi2 = new_phi;\n+\n+\n+      /** 2. Handle loop-closed-ssa-form phis  **/\n+\n+      /* 2.1. Generate new phi node in NEW_EXIT_BB:  */\n+      new_phi = create_phi_node (SSA_NAME_VAR (PHI_RESULT (orig_phi)),\n+                                 *new_exit_bb);\n+\n+      /* 2.2. NEW_EXIT_BB has one incoming edge: the exit-edge of the loop.  */\n+      add_phi_arg (new_phi, loop_arg, loop->single_exit);\n+\n+      /* 2.3. Update phi in successor of NEW_EXIT_BB:  */\n+      gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi2, new_exit_e) == loop_arg);\n+      SET_PHI_ARG_DEF (update_phi2, new_exit_e->dest_idx, PHI_RESULT (new_phi));\n+\n+      /* 2.4. Record the newly created name in SSA_NAME_AUX.\n+         We want to find a name such that\n+                name = *(SSA_NAME_AUX (orig_loop_name))\n+         and to set its SSA_NAME_AUX as follows:\n+                *(SSA_NAME_AUX (name)) = new_phi_name\n+\n+         If LOOP is a new loop then loop_arg is already the name we're\n+         looking for. If LOOP is the original loop, then loop_arg is\n+         the orig_loop_name and the relevant name is recorded in its\n+         SSA_NAME_AUX  */\n+      if (is_new_loop)\n+        current_new_name = loop_arg;\n+      else\n+        {\n+          new_name_ptr = SSA_NAME_AUX (loop_arg);\n+          gcc_assert (new_name_ptr);\n+          current_new_name = *new_name_ptr;\n+        }\n+#ifdef ENABLE_CHECKING\n+      gcc_assert (! SSA_NAME_AUX (current_new_name));\n+#endif\n+\n+      new_name_ptr2 = xmalloc (sizeof (tree));\n+      *new_name_ptr2 = PHI_RESULT (new_phi);\n+      SSA_NAME_AUX (current_new_name) = new_name_ptr2;\n+      bitmap_set_bit (*defs, SSA_NAME_VERSION (current_new_name));\n+    }\n+\n+  set_phi_nodes (new_merge_bb, phi_reverse (phi_nodes (new_merge_bb)));\n+}\n+\n+\n+/* Function slpeel_update_phi_nodes_for_guard2\n+\n+   Input:\n+   - GUARD_EDGE, LOOP, IS_NEW_LOOP, NEW_EXIT_BB - as explained above.\n+\n+   In the context of the overall structure, we have:\n+\n+        loop1_preheader_bb: \n+                guard1 (goto loop1/merg1_bb)\n+        loop1\n+        loop1_exit_bb: \n+                guard2 (goto merge1_bb/merge2_bb)\n+        merge1_bb\n+LOOP->  loop2\n+        loop2_exit_bb\n+        merge2_bb\n+        next_bb\n+\n+   For each name used out side the loop (i.e - for each name that has an exit\n+   phi in next_bb) we create a new phi in:\n+   1. merge2_bb (to account for the edge from guard_bb) \n+   2. loop2_exit_bb (an exit-phi to keep LOOP in loop-closed form)\n+   3. guard2 bb (an exit phi to keep the preceding loop in loop-closed form),\n+      if needed (if it wasn't handled by slpeel_update_phis_nodes_for_phi1).\n+*/\n+\n+static void\n+slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n+                                    bool is_new_loop, basic_block *new_exit_bb)\n+{\n+  tree orig_phi, new_phi;\n+  tree update_phi, update_phi2;\n+  tree *new_name_ptr, *new_name_ptr2;\n+  tree guard_arg, loop_arg;\n+  basic_block new_merge_bb = guard_edge->dest;\n+  edge e = EDGE_SUCC (new_merge_bb, 0);\n+  basic_block update_bb = e->dest;\n+  edge new_exit_e;\n+  tree orig_def;\n+  tree new_name, new_name2;\n+  tree arg;\n+\n+  /* Create new bb between loop and new_merge_bb.  */\n+  *new_exit_bb = split_edge (loop->single_exit);\n+  add_bb_to_loop (*new_exit_bb, loop->outer);\n+\n+  new_exit_e = EDGE_SUCC (*new_exit_bb, 0);\n+\n+  for (update_phi = phi_nodes (update_bb); update_phi; \n+       update_phi = PHI_CHAIN (update_phi))\n+    {\n+      orig_phi = update_phi;\n+      orig_def = PHI_ARG_DEF_FROM_EDGE (orig_phi, e);\n+      new_name_ptr = SSA_NAME_AUX (orig_def);\n+      arg = NULL_TREE;\n+\n+      /** 1. Handle new-merge-point phis  **/\n+\n+      /* 1.1. Generate new phi node in NEW_MERGE_BB:  */\n       new_phi = create_phi_node (SSA_NAME_VAR (PHI_RESULT (orig_phi)),\n                                  new_merge_bb);\n \n-      /* 2. NEW_MERGE_BB has two incoming edges: GUARD_EDGE and the exit-edge\n+      /* 1.2. NEW_MERGE_BB has two incoming edges: GUARD_EDGE and the exit-edge\n             of LOOP. Set the two phi args in NEW_PHI for these edges:  */\n-      if (entry_phis)\n+      new_name = orig_def;\n+      new_name2 = NULL_TREE;\n+      if (new_name_ptr)\n         {\n-          loop_arg = PHI_ARG_DEF_FROM_EDGE (orig_phi,\n-                                            loop_latch_edge (loop));\n-          guard_arg = PHI_ARG_DEF_FROM_EDGE (orig_phi,\n-\t\t\t\t\t     loop_preheader_edge (loop));\n+          new_name = *new_name_ptr;\n+          new_name_ptr2 = SSA_NAME_AUX (new_name);\n+          if (new_name_ptr2)\n+            /* Some variables have both loop-entry-phis and loop-exit-phis.\n+               Such variables were given yet newer names by phis placed in\n+               guard_bb by slpeel_update_phi_nodes_for_guard1. I.e:\n+               new_name2 = SSA_NAME_AUX (SSA_NAME_AUX (orig_name)).  */\n+            new_name2 = *new_name_ptr2;\n         }\n-      else /* exit phis */\n+  \n+      if (is_new_loop)\n         {\n-          tree orig_def = PHI_ARG_DEF_FROM_EDGE (orig_phi, e);\n-          tree *new_name_ptr = SSA_NAME_AUX (orig_def);\n-          tree new_name;\n-\n-          if (new_name_ptr)\n-            new_name = *new_name_ptr;\n-          else\n-            /* Something defined outside of the loop  */\n-            new_name = orig_def;\n-\n-          if (is_new_loop)\n-            {\n-              guard_arg = orig_def;\n-              loop_arg = new_name;\n-            }\n-          else\n-            {\n-              guard_arg = new_name;\n-              loop_arg = orig_def;\n-            }\n+          guard_arg = orig_def;\n+          loop_arg = new_name;\n         }\n-      add_phi_arg (new_phi, loop_arg, loop->single_exit);\n+      else\n+        {\n+          guard_arg = new_name;\n+          loop_arg = orig_def;\n+        }\n+      if (new_name2)\n+        guard_arg = new_name2;\n+  \n+      add_phi_arg (new_phi, loop_arg, new_exit_e);\n       add_phi_arg (new_phi, guard_arg, guard_edge);\n \n-      /* 3. Update phi in successor block.  */\n-      gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi, e) == loop_arg\n-                  || PHI_ARG_DEF_FROM_EDGE (update_phi, e) == guard_arg);\n+      /* 1.3. Update phi in successor block.  */\n+      gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi, e) == orig_def);\n       SET_PHI_ARG_DEF (update_phi, e->dest_idx, PHI_RESULT (new_phi));\n+      update_phi2 = new_phi;\n+\n+\n+      /** 2. Handle loop-closed-ssa-form phis  **/\n+\n+      /* 2.1. Generate new phi node in NEW_EXIT_BB:  */\n+      new_phi = create_phi_node (SSA_NAME_VAR (PHI_RESULT (orig_phi)),\n+                                 *new_exit_bb);\n+\n+      /* 2.2. NEW_EXIT_BB has one incoming edge: the exit-edge of the loop.  */\n+      add_phi_arg (new_phi, loop_arg, loop->single_exit);\n+\n+      /* 2.3. Update phi in successor of NEW_EXIT_BB:  */\n+      gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi2, new_exit_e) == loop_arg);\n+      SET_PHI_ARG_DEF (update_phi2, new_exit_e->dest_idx, PHI_RESULT (new_phi));\n+\n+\n+      /** 3. Handle loop-closed-ssa-form phis for first loop  **/\n+\n+      /* 3.1. Find the relevant names that need an exit-phi in GUARD_BB, i.e.\n+         names for which slpeel_update_phi_nodes_for_guard1 had not already\n+         created a phi node. This is the case for names that are used out\n+         side the loop (and therefore need an exit phi) but are not updated\n+         across loop iterations (and therefore don't have a loop-header-phi).\n+\n+         slpeel_update_phi_nodes_for_guard1 is responssible for creating\n+         loop-exit phis in GUARD_BB for names that have a loop-header-phi. When\n+         such a phi is created we also record the new name in SSA_NAME_AUX. If\n+         this new name exists, then guard_arg was set to this new name\n+         (see 1.2 above). Therefore, if guard_arg is not this new name, this is\n+         an indication that an exit-phi in GUARD_BB was not yet created, so we\n+         take care of it here.\n+       */\n+      if (guard_arg == new_name2)\n+\tcontinue;\n+      arg = guard_arg;\n+\n+      /* 3.2. Generate new phi node in GUARD_BB:  */\n+      new_phi = create_phi_node (SSA_NAME_VAR (PHI_RESULT (orig_phi)),\n+                                 guard_edge->src);\n+\n+      /* 3.3. GUARD_BB has one incoming edge:  */\n+      gcc_assert (EDGE_COUNT (guard_edge->src->preds) == 1);\n+      add_phi_arg (new_phi, arg, EDGE_PRED (guard_edge->src, 0));\n+\n+      /* 3.4. Update phi in successor of GUARD_BB:  */\n+      gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi2, guard_edge)\n+                                                                == guard_arg);\n+      SET_PHI_ARG_DEF (update_phi2, guard_edge->dest_idx, PHI_RESULT (new_phi));\n     }\n \n   set_phi_nodes (new_merge_bb, phi_reverse (phi_nodes (new_merge_bb)));\n@@ -742,7 +1025,7 @@ slpeel_add_loop_guard (basic_block guard_bb, tree cond, basic_block exit_bb,\n   edge new_e, enter_e;\n   tree cond_stmt, then_label, else_label;\n \n-  enter_e = single_succ_edge (guard_bb);\n+  enter_e = EDGE_SUCC (guard_bb, 0);\n   enter_e->flags &= ~EDGE_FALLTHRU;\n   enter_e->flags |= EDGE_FALSE_VALUE;\n   bsi = bsi_last (guard_bb);\n@@ -754,7 +1037,7 @@ slpeel_add_loop_guard (basic_block guard_bb, tree cond, basic_block exit_bb,\n   cond_stmt = build3 (COND_EXPR, void_type_node, cond,\n    \t\t     then_label, else_label);\n   bsi_insert_after (&bsi, cond_stmt, BSI_NEW_STMT);\n-  /* Add new edge to connect entry block to the second loop.  */\n+  /* Add new edge to connect guard block to the merge/loop-exit block.  */\n   new_e = make_edge (guard_bb, exit_bb, EDGE_TRUE_VALUE);\n   set_immediate_dominator (CDI_DOMINATORS, exit_bb, dom_bb);\n   return new_e;\n@@ -878,6 +1161,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n   basic_block bb_before_second_loop, bb_after_second_loop;\n   basic_block bb_before_first_loop;\n   basic_block bb_between_loops;\n+  basic_block new_exit_bb;\n   edge exit_e = loop->single_exit;\n   LOC loop_loc;\n   \n@@ -966,8 +1250,9 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n     fold (build2 (LE_EXPR, boolean_type_node, first_niters, integer_zero_node));\n   skip_e = slpeel_add_loop_guard (bb_before_first_loop, pre_condition,\n                                   bb_before_second_loop, bb_before_first_loop);\n-  slpeel_update_phi_nodes_for_guard (skip_e, first_loop, true /* entry-phis */,\n-                                     first_loop == new_loop);\n+  slpeel_update_phi_nodes_for_guard1 (skip_e, first_loop,\n+\t\t\t\t      first_loop == new_loop,\n+\t\t\t\t      &new_exit_bb, &definitions);\n \n \n   /* 3. Add the guard that controls whether the second loop is executed.\n@@ -996,21 +1281,16 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n         orig_exit_bb:\n    */\n \n-  bb_between_loops = split_edge (first_loop->single_exit);\n-  add_bb_to_loop (bb_between_loops, first_loop->outer);\n+  bb_between_loops = new_exit_bb;\n   bb_after_second_loop = split_edge (second_loop->single_exit);\n   add_bb_to_loop (bb_after_second_loop, second_loop->outer);\n \n   pre_condition = \n \tfold (build2 (EQ_EXPR, boolean_type_node, first_niters, niters));\n   skip_e = slpeel_add_loop_guard (bb_between_loops, pre_condition,\n                                   bb_after_second_loop, bb_before_first_loop);\n-  slpeel_update_phi_nodes_for_guard (skip_e, second_loop, false /* exit-phis */,\n-                                     second_loop == new_loop);\n-\n-  /* Flow loop scan does not update loop->single_exit field.  */\n-  first_loop->single_exit = first_loop->single_exit;\n-  second_loop->single_exit = second_loop->single_exit;\n+  slpeel_update_phi_nodes_for_guard2 (skip_e, second_loop,\n+                                     second_loop == new_loop, &new_exit_bb);\n \n   /* 4. Make first-loop iterate FIRST_NITERS times, if requested.\n    */\n@@ -1618,6 +1898,4 @@ vectorize_loops (struct loops *loops)\n       destroy_loop_vec_info (loop_vinfo);\n       loop->aux = NULL;\n     }\n-\n-  rewrite_into_loop_closed_ssa (NULL); /* FORNOW */\n }"}]}