{"sha": "809e3e7fece2749886700d92571232ec3faef2a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA5ZTNlN2ZlY2UyNzQ5ODg2NzAwZDkyNTcxMjMyZWMzZmFlZjJhMA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-07-06T08:51:32Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-07-06T08:51:32Z"}, "message": "tree.h (TREE_VIA_VIRTUAL): Rename to ...\n\n\t* tree.h (TREE_VIA_VIRTUAL): Rename to ...\n\t(BINFO_VIRTUAL_P): ... here. Require TREE_BINFO only.\n\t(BINFO_MARKED, BINFO_FLAG_[16]): New binfo flags.\n\t* dbxout.c (dbxout_type): Use BINFO_VIRTUAL_P.\n\t* dwarf2out.c (add_data_member_location_attribute): Likewise.\n\t(gen_inheritance_die): Likewise.\n\t* tree-dump.c (deque_and_dump): Likewise.\n\t* doc/c-tree.texi (Binfos): Add under reconstruction note.\n\n\t* cp/cp-tree.h (BINFO_MARKED): Remove.\n\t(BINFO_VTABLE_PATH_MARKED, BINFO_NEW_VTABLE_MARKED,\n\tBINFO_DEPENDENT_BASE_P, BINFO_LOST_PRIMARY_P,\n\tBINFO_INDIRECT_PRIMARY_P): Use appropriate BINFO_FLAG_n.\n\t(SET_BINFO_NEW_VTABLE_MARKED): Use BINFO_VIRTUAL_P.\n\t* cp/class.c (build_base_path): Use BINFO_VIRTUAL_P.\n\t(mark_primary_bases, determine_primary_base, base_derived_from,\n\tdfs_find_final_overrider, dfs_find_final_overrider_q,\n\tdfs_find_inal_overrider_post, update_vtable_entry_for_fn,\n\tdfs_modify_vtables, walk_subobject_offsets,\n\tlayout_nonempty_base_or_field, build_base_field,\n\tbuild_base_fields, propagate_binfo_offsets, layout_virtual_bases,\n\tend_of_class, get_vfield_name, dump_class_hierarchy, dump_vtable,\n\tfinish_vtbls, build_vtt_inits, dfs_build_secondary_vptr_vtt_inits,\n\tbuild_ctor_vtbl_group, accumulate_vtble_inits,\n\tdfs_accumulate_vtbls_inits, build_vbase_offset_vtbl_entries,\n\tbuild_vcall_offset_vtbl_entries, add_vcall_offset_vtbl_entries_r,\n\tadd_vcall_offset_vtbl_entries_1): Likewise.\n\t* cp/decl.c (xref_basetypes): Incomming virtual base indicated by\n\tTREE_TYPE. Adjust.\n\t* cp/dump.c (cp_dump_tree): Use BINFO_VIRTUAL_P.\n\t* cp/init.c (finish_init_stmts, sort_mem_initializers,\n\temit_mem_initializers, build_vtble_address, expand_member_init,\n\tpush_base_cleanups): Likewise.\n\t* cp/method.c (do_build_copy_constructor): Likewise.\n\t* cp/pt.c (instantiate_class_template,\n\tget_template_base_recursive): Likewise.\n\t* cp/rtti.c (dfs_class_hint_mark, get_pseudo_ti_init,\n\tget_pseudo_ti_desc): Likewise.\n\t* cp/search.c (lookup_base_r, dynamic_cast_base_recurse,\n\tbinfo_from_vbase, binfo_via_virtual, copied_binfo,\n\toriginal_binfo): Likewise.\n\t* cp/semantics.c (finish_base_specifier): Virtualness is indicated\n\tby TREE_TYPE.\n\t* cp/tree.c (copy_base_binfos): Use BINFO_VIRTUAL_P.\n\n\t* java/java-tree.h (CLASS_HAS_SUPER_FLAG): Use BINFO_FLAG_1.\n\t* java/class.c (add_interface_do): Use BINFO_VIRTUAL_P.\n\nFrom-SVN: r84148", "tree": {"sha": "a990dca8afae963468b42e953ee838e411e88c45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a990dca8afae963468b42e953ee838e411e88c45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/809e3e7fece2749886700d92571232ec3faef2a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/809e3e7fece2749886700d92571232ec3faef2a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/809e3e7fece2749886700d92571232ec3faef2a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/809e3e7fece2749886700d92571232ec3faef2a0/comments", "author": null, "committer": null, "parents": [{"sha": "a95d27c83b595db1e4e428fb3b0eba12cd6e7107", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a95d27c83b595db1e4e428fb3b0eba12cd6e7107", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a95d27c83b595db1e4e428fb3b0eba12cd6e7107"}], "stats": {"total": 278, "additions": 165, "deletions": 113}, "files": [{"sha": "4100c8561a4c1f1460b694ec00b9a07310b79603", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -1,3 +1,14 @@\n+2004-07-06  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* tree.h (TREE_VIA_VIRTUAL): Rename to ...\n+\t(BINFO_VIRTUAL_P): ... here. Require TREE_BINFO only.\n+\t(BINFO_MARKED, BINFO_FLAG_[16]): New binfo flags.\n+\t* dbxout.c (dbxout_type): Use BINFO_VIRTUAL_P.\n+\t* dwarf2out.c (add_data_member_location_attribute): Likewise.\n+\t(gen_inheritance_die): Likewise.\n+\t* tree-dump.c (deque_and_dump): Likewise.\n+\t* doc/c-tree.texi (Binfos): Add under reconstruction note.\n+\n 2004-07-06  Steven Bosscher  <stevenb@suse.de>\n \n \t* config/mcore/mcore.c (TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE):"}, {"sha": "ff63da14f45c6e6f5d83f990ff63b3a175a30480", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -1,3 +1,41 @@\n+2004-07-06  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (BINFO_MARKED): Remove.\n+\t(BINFO_VTABLE_PATH_MARKED, BINFO_NEW_VTABLE_MARKED,\n+\tBINFO_DEPENDENT_BASE_P, BINFO_LOST_PRIMARY_P,\n+\tBINFO_INDIRECT_PRIMARY_P): Use appropriate BINFO_FLAG_n.\n+\t(SET_BINFO_NEW_VTABLE_MARKED): Use BINFO_VIRTUAL_P.\n+\t* class.c (build_base_path): Use BINFO_VIRTUAL_P.\n+\t(mark_primary_bases, determine_primary_base, base_derived_from,\n+\tdfs_find_final_overrider, dfs_find_final_overrider_q,\n+\tdfs_find_inal_overrider_post, update_vtable_entry_for_fn,\n+\tdfs_modify_vtables, walk_subobject_offsets,\n+\tlayout_nonempty_base_or_field, build_base_field,\n+\tbuild_base_fields, propagate_binfo_offsets, layout_virtual_bases,\n+\tend_of_class, get_vfield_name, dump_class_hierarchy, dump_vtable,\n+\tfinish_vtbls, build_vtt_inits, dfs_build_secondary_vptr_vtt_inits,\n+\tbuild_ctor_vtbl_group, accumulate_vtble_inits,\n+\tdfs_accumulate_vtbls_inits, build_vbase_offset_vtbl_entries,\n+\tbuild_vcall_offset_vtbl_entries, add_vcall_offset_vtbl_entries_r,\n+\tadd_vcall_offset_vtbl_entries_1): Likewise.\n+\t* decl.c (xref_basetypes): Incomming virtual base indicated by\n+\tTREE_TYPE. Adjust.\n+\t* dump.c (cp_dump_tree): Use BINFO_VIRTUAL_P.\n+\t* init.c (finish_init_stmts, sort_mem_initializers,\n+\temit_mem_initializers, build_vtble_address, expand_member_init,\n+\tpush_base_cleanups): Likewise.\n+\t* method.c (do_build_copy_constructor): Likewise.\n+\t* pt.c (instantiate_class_template,\n+\tget_template_base_recursive): Likewise.\n+\t* rtti.c (dfs_class_hint_mark, get_pseudo_ti_init,\n+\tget_pseudo_ti_desc): Likewise.\n+\t* search.c (lookup_base_r, dynamic_cast_base_recurse,\n+\tbinfo_from_vbase, binfo_via_virtual, copied_binfo,\n+\toriginal_binfo): Likewise.\n+\t* semantics.c (finish_base_specifier): Virtualness is indicated\n+\tby TREE_TYPE.\n+\t* tree.c (copy_base_binfos): Use BINFO_VIRTUAL_P.\n+\n 2004-07-06  Mark Mitchell  <mark@codesourcery.com>\n \n \tRevert:"}, {"sha": "f3ebb83ddb4b2d41d734fcb2fff2261c70018be8", "filename": "gcc/cp/class.c", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -264,7 +264,7 @@ build_base_path (enum tree_code code,\n       d_binfo = probe;\n       if (is_empty_class (BINFO_TYPE (probe)))\n \thas_empty = true;\n-      if (!v_binfo && TREE_VIA_VIRTUAL (probe))\n+      if (!v_binfo && BINFO_VIRTUAL_P (probe))\n \tv_binfo = probe;\n     }\n \n@@ -1257,7 +1257,7 @@ check_bases (tree t,\n                         basetype);\n \t}\n \n-      if (TREE_VIA_VIRTUAL (base_binfo))\n+      if (BINFO_VIRTUAL_P (base_binfo))\n \t/* A virtual base does not effect nearly emptiness.  */\n \t;\n       else if (CLASSTYPE_NEARLY_EMPTY_P (basetype))\n@@ -1312,7 +1312,7 @@ mark_primary_bases (tree type)\n \t  /* A virtual binfo might have been copied from within\n   \t     another hierarchy. As we're about to use it as a primary\n   \t     base, make sure the offsets match.  */\n-\t  if (TREE_VIA_VIRTUAL (base_binfo))\n+\t  if (BINFO_VIRTUAL_P (base_binfo))\n \t    {\n \t      tree delta = size_diffop (convert (ssizetype,\n \t\t\t\t\t\t BINFO_OFFSET (binfo)),\n@@ -1363,7 +1363,7 @@ determine_primary_base (tree t)\n \t{\n \t  /* We prefer a non-virtual base, although a virtual one will\n \t     do.  */\n-\t  if (TREE_VIA_VIRTUAL (base_binfo))\n+\t  if (BINFO_VIRTUAL_P (base_binfo))\n \t    continue;\n \n \t  if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n@@ -1380,7 +1380,7 @@ determine_primary_base (tree t)\n \t\t   vfields;\n \t\t   vfields = TREE_CHAIN (vfields))\n \t\tif (VF_BINFO_VALUE (vfields) == NULL_TREE\n-\t\t    || ! TREE_VIA_VIRTUAL (VF_BINFO_VALUE (vfields)))\n+\t\t    || ! BINFO_VIRTUAL_P (VF_BINFO_VALUE (vfields)))\n \t\t  CLASSTYPE_VFIELDS (t) \n \t\t    = tree_cons (base_binfo, \n \t\t\t\t VF_BASETYPE_VALUE (vfields),\n@@ -1444,7 +1444,7 @@ determine_primary_base (tree t)\n \t{\n \t  tree basetype = BINFO_TYPE (base_binfo);\n \n-\t  if (TREE_VIA_VIRTUAL (base_binfo) \n+\t  if (BINFO_VIRTUAL_P (base_binfo) \n \t      && CLASSTYPE_NEARLY_EMPTY_P (basetype))\n \t    {\n \t      /* If this is not an indirect primary base, then it's\n@@ -1916,7 +1916,7 @@ base_derived_from (tree derived, tree base)\n     {\n       if (probe == derived)\n \treturn true;\n-      else if (TREE_VIA_VIRTUAL (probe))\n+      else if (BINFO_VIRTUAL_P (probe))\n \t/* If we meet a virtual base, we can't follow the inheritance\n \t   any more.  See if the complete type of DERIVED contains\n \t   such a virtual base.  */\n@@ -1959,7 +1959,7 @@ dfs_find_final_overrider (tree binfo, void* data)\n \t  path = tree_cons (NULL_TREE, probe, path);\n \t  if (same_type_p (BINFO_TYPE (probe), ffod->most_derived_type))\n \t    break;\n-\t  if (TREE_VIA_VIRTUAL (probe))\n+\t  if (BINFO_VIRTUAL_P (probe))\n \t    {\n \t      probe = TREE_VALUE (vpath);\n \t      vpath = TREE_CHAIN (vpath);\n@@ -2008,7 +2008,7 @@ dfs_find_final_overrider_q (tree derived, int ix, void *data)\n   tree binfo = BINFO_BASETYPE (derived, ix);\n   find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n \n-  if (TREE_VIA_VIRTUAL (binfo))\n+  if (BINFO_VIRTUAL_P (binfo))\n     ffod->vpath = tree_cons (NULL_TREE, derived, ffod->vpath);\n   \n   return binfo;\n@@ -2019,7 +2019,7 @@ dfs_find_final_overrider_post (tree binfo, void *data)\n {\n   find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n \n-  if (TREE_VIA_VIRTUAL (binfo) && TREE_CHAIN (ffod->vpath))\n+  if (BINFO_VIRTUAL_P (binfo) && TREE_CHAIN (ffod->vpath))\n     ffod->vpath = TREE_CHAIN (ffod->vpath);\n   \n   return NULL_TREE;\n@@ -2188,7 +2188,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n \t\t{\n \t\t  /* We convert via virtual base. Find the virtual\n \t\t     base and adjust the fixed offset to be from there.  */\n-\t\t  while (!TREE_VIA_VIRTUAL (thunk_binfo))\n+\t\t  while (!BINFO_VIRTUAL_P (thunk_binfo))\n \t\t    thunk_binfo = BINFO_INHERITANCE_CHAIN (thunk_binfo);\n \n \t\t  virtual_offset = thunk_binfo;\n@@ -2233,7 +2233,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n       /* If we find a virtual base, and we haven't yet found the\n \t overrider, then there is a virtual base between the\n \t declaring base (first_defn) and the final overrider.  */\n-      if (TREE_VIA_VIRTUAL (b))\n+      if (BINFO_VIRTUAL_P (b))\n \t{\n \t  virtual_base = b;\n \t  break;\n@@ -2260,7 +2260,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n \n       while ((probe = get_primary_binfo (probe))\n \t     && (unsigned) list_length (BINFO_VIRTUALS (probe)) > ix)\n-\tif (TREE_VIA_VIRTUAL (probe))\n+\tif (BINFO_VIRTUAL_P (probe))\n \t  virtual_base = probe;\n       \n       if (virtual_base)\n@@ -2309,7 +2309,7 @@ dfs_modify_vtables (tree binfo, void* data)\n          primary base; we're not going to use that vtable anyhow.\n \t We do still need to do this for virtual primary bases, as they\n \t could become non-primary in a construction vtable.  */\n-      (!BINFO_PRIMARY_P (binfo) || TREE_VIA_VIRTUAL (binfo))\n+      (!BINFO_PRIMARY_P (binfo) || BINFO_VIRTUAL_P (binfo))\n       /* Similarly, a base without a vtable needs no modification.  */\n       && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n     {\n@@ -3273,11 +3273,11 @@ walk_subobject_offsets (tree type,\n \t  binfo = BINFO_BASETYPE (type_binfo, i);\n \n \t  if (abi_version_at_least (2) \n-\t      && TREE_VIA_VIRTUAL (binfo))\n+\t      && BINFO_VIRTUAL_P (binfo))\n \t    continue;\n \n \t  if (!vbases_p \n-\t      && TREE_VIA_VIRTUAL (binfo) \n+\t      && BINFO_VIRTUAL_P (binfo) \n \t      && !BINFO_PRIMARY_P (binfo))\n \t    continue;\n \n@@ -3339,7 +3339,7 @@ walk_subobject_offsets (tree type,\n \t\t above.)  */\n \t      tree vbase = get_primary_binfo (type_binfo);\n \t      \n-\t      if (vbase && TREE_VIA_VIRTUAL (vbase)\n+\t      if (vbase && BINFO_VIRTUAL_P (vbase)\n \t\t  && BINFO_PRIMARY_BASE_OF (vbase) == type_binfo)\n \t\t{\n \t\t  r = (walk_subobject_offsets \n@@ -3517,7 +3517,7 @@ layout_nonempty_base_or_field (record_layout_info rli,\n \tbreak;\n       /* G++ 3.2 did not check for overlaps when placing a non-empty\n \t virtual base.  */\n-      if (!abi_version_at_least (2) && binfo && TREE_VIA_VIRTUAL (binfo))\n+      if (!abi_version_at_least (2) && binfo && BINFO_VIRTUAL_P (binfo))\n \tbreak;\n       if (layout_conflict_p (field_p ? type : binfo, offset, \n \t\t\t     offsets, field_p))\n@@ -3679,7 +3679,7 @@ build_base_field (record_layout_info rli, tree binfo,\n       atend = layout_empty_base (binfo, eoc, offsets);\n       /* A nearly-empty class \"has no proper base class that is empty,\n \t not morally virtual, and at an offset other than zero.\"  */\n-      if (!TREE_VIA_VIRTUAL (binfo) && CLASSTYPE_NEARLY_EMPTY_P (t))\n+      if (!BINFO_VIRTUAL_P (binfo) && CLASSTYPE_NEARLY_EMPTY_P (t))\n \t{\n \t  if (atend)\n \t    CLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n@@ -3757,7 +3757,7 @@ build_base_fields (record_layout_info rli,\n \n       /* Virtual bases are added at the end (a primary virtual base\n \t will have already been added).  */\n-      if (TREE_VIA_VIRTUAL (base_binfo))\n+      if (BINFO_VIRTUAL_P (base_binfo))\n \tcontinue;\n \n       next_field = build_base_field (rli, base_binfo,\n@@ -4387,7 +4387,7 @@ propagate_binfo_offsets (tree binfo, tree offset)\n \t}\n \n       /* Skip virtual bases that aren't our canonical primary base.  */\n-      if (TREE_VIA_VIRTUAL (base_binfo)\n+      if (BINFO_VIRTUAL_P (base_binfo)\n \t  && BINFO_PRIMARY_BASE_OF (base_binfo) != binfo)\n \tcontinue;\n \n@@ -4436,7 +4436,7 @@ layout_virtual_bases (record_layout_info rli, splay_tree offsets)\n      allocated in inheritance graph order.  */\n   for (vbase = TYPE_BINFO (t); vbase; vbase = TREE_CHAIN (vbase))\n     {\n-      if (!TREE_VIA_VIRTUAL (vbase))\n+      if (!BINFO_VIRTUAL_P (vbase))\n \tcontinue;\n \n       if (!BINFO_PRIMARY_P (vbase))\n@@ -4507,7 +4507,7 @@ end_of_class (tree t, int include_virtuals_p)\n       binfo = BINFO_BASETYPE (TYPE_BINFO (t), i);\n \n       if (!include_virtuals_p\n-\t  && TREE_VIA_VIRTUAL (binfo) \n+\t  && BINFO_VIRTUAL_P (binfo) \n \t  && BINFO_PRIMARY_BASE_OF (binfo) != TYPE_BINFO (t))\n \tcontinue;\n \n@@ -6257,7 +6257,7 @@ get_vfield_name (tree type)\n \n   while (BINFO_BASETYPES (binfo)\n \t && TYPE_CONTAINS_VPTR_P (BINFO_TYPE (BINFO_BASETYPE (binfo, 0)))\n-\t && ! TREE_VIA_VIRTUAL (BINFO_BASETYPE (binfo, 0)))\n+\t && ! BINFO_VIRTUAL_P (BINFO_BASETYPE (binfo, 0)))\n     binfo = BINFO_BASETYPE (binfo, 0);\n \n   type = BINFO_TYPE (binfo);\n@@ -6525,7 +6525,7 @@ dump_class_hierarchy_r (FILE *stream,\n     fprintf (stream, \" empty\");\n   else if (CLASSTYPE_NEARLY_EMPTY_P (BINFO_TYPE (binfo)))\n     fprintf (stream, \" nearly-empty\");\n-  if (TREE_VIA_VIRTUAL (binfo))\n+  if (BINFO_VIRTUAL_P (binfo))\n     fprintf (stream, \" virtual\");\n   fprintf (stream, \"\\n\");\n \n@@ -6680,7 +6680,7 @@ dump_vtable (tree t, tree binfo, tree vtable)\n \t       type_as_string (binfo, TFF_PLAIN_IDENTIFIER));\n       if (ctor_vtbl_p)\n \t{\n-\t  if (!TREE_VIA_VIRTUAL (binfo))\n+\t  if (!BINFO_VIRTUAL_P (binfo))\n \t    fprintf (stream, \" (0x%lx instance)\", (unsigned long)binfo);\n \t  fprintf (stream, \" in %s\", type_as_string (t, TFF_PLAIN_IDENTIFIER));\n \t}\n@@ -6777,7 +6777,7 @@ finish_vtbls (tree t)\n   /* Then come the virtual bases, also in inheritance graph order.  */\n   for (vbase = TYPE_BINFO (t); vbase; vbase = TREE_CHAIN (vbase))\n     {\n-      if (!TREE_VIA_VIRTUAL (vbase))\n+      if (!BINFO_VIRTUAL_P (vbase))\n \tcontinue;\n       accumulate_vtbl_inits (vbase, vbase, TYPE_BINFO (t), t, list);\n     }\n@@ -6928,7 +6928,7 @@ build_vtt_inits (tree binfo, tree t, tree* inits, tree* index)\n   for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n     {\n       b = BINFO_BASETYPE (binfo, i);\n-      if (!TREE_VIA_VIRTUAL (b))\n+      if (!BINFO_VIRTUAL_P (b))\n \tinits = build_vtt_inits (BINFO_BASETYPE (binfo, i), t, \n \t\t\t\t inits, index);\n     }\n@@ -6967,7 +6967,7 @@ build_vtt_inits (tree binfo, tree t, tree* inits, tree* index)\n   if (top_level_p)\n     for (b = TYPE_BINFO (BINFO_TYPE (binfo)); b; b = TREE_CHAIN (b))\n       {\n-\tif (!TREE_VIA_VIRTUAL (b))\n+\tif (!BINFO_VIRTUAL_P (b))\n \t  continue;\n \t\n \tinits = build_vtt_inits (b, t, inits, index);\n@@ -7016,7 +7016,7 @@ dfs_build_secondary_vptr_vtt_inits (tree binfo, void *data)\n     return NULL_TREE;\n \n   /* We're not interested in non-virtual primary bases.  */\n-  if (!TREE_VIA_VIRTUAL (binfo) && BINFO_PRIMARY_P (binfo))\n+  if (!BINFO_VIRTUAL_P (binfo) && BINFO_PRIMARY_P (binfo))\n     return NULL_TREE;\n \n   /* If BINFO has virtual bases or is reachable via a virtual path\n@@ -7036,7 +7036,7 @@ dfs_build_secondary_vptr_vtt_inits (tree binfo, void *data)\n \t\t\t      TYPE_SIZE_UNIT (ptr_type_node));\n \n   /* Add the initializer for the secondary vptr itself.  */\n-  if (top_level_p && TREE_VIA_VIRTUAL (binfo))\n+  if (top_level_p && BINFO_VIRTUAL_P (binfo))\n     {\n       /* It's a primary virtual base, and this is not the construction\n          vtable. Find the base this is primary of in the inheritance graph,\n@@ -7126,7 +7126,7 @@ build_ctor_vtbl_group (tree binfo, tree t)\n     {\n       tree b;\n \n-      if (!TREE_VIA_VIRTUAL (vbase))\n+      if (!BINFO_VIRTUAL_P (vbase))\n \tcontinue;\n       b = copied_binfo (vbase, binfo);\n       \n@@ -7196,7 +7196,7 @@ accumulate_vtbl_inits (tree binfo,\n       tree base_binfo = BINFO_BASETYPE (binfo, i);\n       \n       /* Skip virtual bases.  */\n-      if (TREE_VIA_VIRTUAL (base_binfo))\n+      if (BINFO_VIRTUAL_P (base_binfo))\n \tcontinue;\n       accumulate_vtbl_inits (base_binfo,\n \t\t\t     BINFO_BASETYPE (orig_binfo, i),\n@@ -7220,7 +7220,7 @@ dfs_accumulate_vtbl_inits (tree binfo,\n   int ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n \n   if (ctor_vtbl_p\n-      && TREE_VIA_VIRTUAL (orig_binfo) && BINFO_PRIMARY_P (orig_binfo))\n+      && BINFO_VIRTUAL_P (orig_binfo) && BINFO_PRIMARY_P (orig_binfo))\n     {\n       /* In the hierarchy of BINFO_TYPE (RTTI_BINFO), this is a\n \t primary virtual base.  If it is not the same primary in\n@@ -7245,14 +7245,14 @@ dfs_accumulate_vtbl_inits (tree binfo,\n       for (; b; b = BINFO_PRIMARY_BASE_OF (b))\n \t{\n \t  last = b;\n-\t  if (TREE_VIA_VIRTUAL (b) || b == rtti_binfo)\n+\t  if (BINFO_VIRTUAL_P (b) || b == rtti_binfo)\n \t    break;\n \t}\n       /* If we run out of primary links, keep looking down our\n \t inheritance chain; we might be an indirect primary.  */\n       if (b == NULL_TREE)\n \tfor (b = last; b; b = BINFO_INHERITANCE_CHAIN (b))\n-\t  if (TREE_VIA_VIRTUAL (b) || b == rtti_binfo)\n+\t  if (BINFO_VIRTUAL_P (b) || b == rtti_binfo)\n \t    break;\n \n       /* If we found RTTI_BINFO, this is case 1.  If we found a virtual\n@@ -7297,7 +7297,7 @@ dfs_accumulate_vtbl_inits (tree binfo,\n        So, we make a TREE_LIST.  Later, dfs_fixup_binfo_vtbls will\n        straighten this out.  */\n     BINFO_VTABLE (binfo) = tree_cons (rtti_binfo, vtbl, BINFO_VTABLE (binfo));\n-  else if (BINFO_PRIMARY_P (binfo) && TREE_VIA_VIRTUAL (binfo))\n+  else if (BINFO_PRIMARY_P (binfo) && BINFO_VIRTUAL_P (binfo))\n     inits = NULL_TREE;\n   else\n      /* For an ordinary vtable, set BINFO_VTABLE.  */\n@@ -7551,7 +7551,7 @@ build_vbase_offset_vtbl_entries (tree binfo, vtbl_init_data* vid)\n \t base (possibly multi-level) of vid->binfo, or we wouldn't\n \t have called build_vcall_and_vbase_vtbl_entries for it.  But it\n \t might be a lost primary, so just skip down to vid->binfo.  */\n-      if (TREE_VIA_VIRTUAL (non_primary_binfo))\n+      if (BINFO_VIRTUAL_P (non_primary_binfo))\n \t{\n \t  non_primary_binfo = vid->binfo;\n \t  break;\n@@ -7571,7 +7571,7 @@ build_vbase_offset_vtbl_entries (tree binfo, vtbl_init_data* vid)\n       tree b;\n       tree delta;\n       \n-      if (!TREE_VIA_VIRTUAL (vbase))\n+      if (!BINFO_VIRTUAL_P (vbase))\n \tcontinue;\n \n       /* Find the instance of this virtual base in the complete\n@@ -7629,7 +7629,7 @@ build_vcall_offset_vtbl_entries (tree binfo, vtbl_init_data* vid)\n   /* We only need these entries if this base is a virtual base.  We\n      compute the indices -- but do not add to the vtable -- when\n      building the main vtable for a class.  */\n-  if (TREE_VIA_VIRTUAL (binfo) || binfo == TYPE_BINFO (vid->derived))\n+  if (BINFO_VIRTUAL_P (binfo) || binfo == TYPE_BINFO (vid->derived))\n     {\n       /* We need a vcall offset for each of the virtual functions in this\n \t vtable.  For example:\n@@ -7652,7 +7652,7 @@ build_vcall_offset_vtbl_entries (tree binfo, vtbl_init_data* vid)\n       vid->vbase = binfo;\n       /* If we are just computing the vcall indices -- but do not need\n \t the actual entries -- not that.  */\n-      if (!TREE_VIA_VIRTUAL (binfo))\n+      if (!BINFO_VIRTUAL_P (binfo))\n \tvid->generate_vcall_entries = false;\n       /* Now, walk through the non-virtual bases, adding vcall offsets.  */\n       add_vcall_offset_vtbl_entries_r (binfo, vid);\n@@ -7671,7 +7671,7 @@ add_vcall_offset_vtbl_entries_r (tree binfo, vtbl_init_data* vid)\n      virtual base for which we are building vcall offsets.  Any\n      primary virtual base will have already had its offsets generated\n      through the recursion in build_vcall_and_vbase_vtbl_entries.  */\n-  if (TREE_VIA_VIRTUAL (binfo) && vid->vbase != binfo)\n+  if (BINFO_VIRTUAL_P (binfo) && vid->vbase != binfo)\n     return;\n   \n   /* If BINFO has a primary base, process it first.  */\n@@ -7734,7 +7734,7 @@ add_vcall_offset_vtbl_entries_1 (tree binfo, vtbl_init_data* vid)\n \t     base (possibly multi-level) of vid->binfo, or we wouldn't\n \t     have called build_vcall_and_vbase_vtbl_entries for it.  But it\n \t     might be a lost primary, so just skip down to vid->binfo.  */\n-\t  if (TREE_VIA_VIRTUAL (non_primary_binfo))\n+\t  if (BINFO_VIRTUAL_P (non_primary_binfo))\n \t    {\n \t      if (non_primary_binfo != vid->vbase)\n \t\tabort ();"}, {"sha": "e1e89c882b47e55fa28478e8d8918a46e7faf0a3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -31,12 +31,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"varray.h\"\n #include \"c-common.h\"\n #include \"name-lookup.h\"\n-\n struct diagnostic_context;\n \n /* Usage of TREE_LANG_FLAG_?:\n-   0: BINFO_MARKED (BINFO nodes).\n-      IDENTIFIER_MARKED (IDENTIFIER_NODEs)\n+   0: IDENTIFIER_MARKED (IDENTIFIER_NODEs)\n       NEW_EXPR_USE_GLOBAL (in NEW_EXPR).\n       DELETE_EXPR_USE_GLOBAL (in DELETE_EXPR).\n       COMPOUND_EXPR_OVERLOADED (in COMPOUND_EXPR).\n@@ -57,24 +55,19 @@ struct diagnostic_context;\n       (TREE_CALLS_NEW) (in _EXPR or _REF) (commented-out).\n       TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (in _TYPE).\n       ICS_ELLIPSIS_FLAG (in _CONV)\n-      BINFO_DEPENDENT_BASE_P (in BINFO)\n       DECL_INITIALIZED_P (in VAR_DECL)\n    2: IDENTIFIER_OPNAME_P.\n       TYPE_POLYMORPHIC_P (in _TYPE)\n       ICS_THIS_FLAG (in _CONV)\n-      BINFO_LOST_PRIMARY_P (in BINFO)\n       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (in VAR_DECL)\n       STATEMENT_LIST_TRY_BLOCK (in STATEMENT_LIST)\n    3: TYPE_USES_VIRTUAL_BASECLASSES (in a class TYPE).\n-      BINFO_VTABLE_PATH_MARKED.\n-      BINFO_PUSHDECLS_MARKED.\n       (TREE_REFERENCE_EXPR) (in NON_LVALUE_EXPR) (commented-out).\n       ICS_BAD_FLAG (in _CONV)\n       FN_TRY_BLOCK_P (in TRY_BLOCK)\n       IDENTIFIER_CTOR_OR_DTOR_P (in IDENTIFIER_NODE)\n       BIND_EXPR_BODY_BLOCK (in BIND_EXPR)\n-   4: BINFO_NEW_VTABLE_MARKED.\n-      TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n+   4: TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n           or FIELD_DECL).\n       IDENTIFIER_TYPENAME_P (in IDENTIFIER_NODE)\n    5: C_IS_RESERVED_WORD (in IDENTIFIER_NODE)\n@@ -111,9 +104,6 @@ struct diagnostic_context;\n \n    Usage of language-independent fields in a language-dependent manner:\n \n-   TREE_USED\n-     This field is BINFO_INDIRECT_PRIMARY_P in a BINFO.\n-\n    TYPE_ALIAS_SET\n      This field is used by TYPENAME_TYPEs, TEMPLATE_TYPE_PARMs, and so\n      forth as a substitute for the mark bits provided in `lang_type'.\n@@ -1401,32 +1391,27 @@ struct lang_type GTY(())\n    tree.h, this pointer is described as pointing in other\n    direction.  The binfos of virtual bases are shared.  */\n \n-/* Nonzero means marked by DFS or BFS search.  */\n-#define BINFO_MARKED(NODE)   TREE_LANG_FLAG_0 (NODE)\n-\n /* Nonzero means that this class is on a path leading to a new vtable.  */\n-#define BINFO_VTABLE_PATH_MARKED(NODE) TREE_LANG_FLAG_3 (NODE)\n+#define BINFO_VTABLE_PATH_MARKED(NODE) BINFO_FLAG_1 (NODE)\n \n /* Nonzero means B (a BINFO) has its own vtable.  Any copies will not\n    have this flag set.  */\n-#define BINFO_NEW_VTABLE_MARKED(B) (TREE_LANG_FLAG_4 (B))\n+#define BINFO_NEW_VTABLE_MARKED(B) (BINFO_FLAG_2 (B))\n \n /* Any subobject that needs a new vtable must have a vptr and must not\n    be a non-virtual primary base (since it would then use the vtable from a\n    derived class and never become non-primary.)  */\n #define SET_BINFO_NEW_VTABLE_MARKED(B)\t\t\t\t\t \\\n   (BINFO_NEW_VTABLE_MARKED (B) = 1,\t\t\t\t\t \\\n    my_friendly_assert (!BINFO_PRIMARY_P (B)\t\t\t\t \\\n-\t\t       || TREE_VIA_VIRTUAL (B), 20000517),\t\t \\\n+\t\t       || BINFO_VIRTUAL_P (B), 20000517),\t\t\t \\\n    my_friendly_assert (CLASSTYPE_VFIELDS (BINFO_TYPE (B)) != NULL_TREE,  \\\n \t\t       20000517))\n \n /* Nonzero means this class has done dfs_pushdecls.  */\n #define BINFO_PUSHDECLS_MARKED(NODE) BINFO_VTABLE_PATH_MARKED (NODE)\n \n-/* Nonzero if this BINFO is a primary base class.  Note, this can be\n-   set for non-canonical virtual bases. For a virtual primary base\n-   you might also need to check whether it is canonical.  */\n+/* Nonzero if this BINFO is a primary base class.  */\n \n #define BINFO_PRIMARY_P(NODE) \\\n   (BINFO_PRIMARY_BASE_OF (NODE) != NULL_TREE)\n@@ -1451,17 +1436,17 @@ struct lang_type GTY(())\n \n /* Nonzero if this binfo is for a dependent base - one that should not\n    be searched.  */\n-#define BINFO_DEPENDENT_BASE_P(NODE) TREE_LANG_FLAG_1 (NODE)\n+#define BINFO_DEPENDENT_BASE_P(NODE) BINFO_FLAG_3 (NODE)\n \n /* Nonzero if this binfo has lost its primary base binfo (because that\n    is a nearly-empty virtual base that has been taken by some other\n    base in the complete hierarchy.  */\n-#define BINFO_LOST_PRIMARY_P(NODE) TREE_LANG_FLAG_2 (NODE)\n+#define BINFO_LOST_PRIMARY_P(NODE) BINFO_FLAG_4 (NODE)\n \n /* Nonzero if this binfo is an indirect primary base, i.e. a virtual\n    base that is a primary base of some of other class in the\n    hierarchy.  */\n-#define BINFO_INDIRECT_PRIMARY_P(NODE) TREE_USED (NODE)\n+#define BINFO_INDIRECT_PRIMARY_P(NODE) BINFO_FLAG_5 (NODE)\n \n /* Used by various search routines.  */\n #define IDENTIFIER_MARKED(NODE) TREE_LANG_FLAG_0 (NODE)"}, {"sha": "2e4e1afd46bdabb0b4bd8a7d74fb786afd60028b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -9033,9 +9033,9 @@ xref_tag_from_type (tree old, tree id, int globalize)\n /* REF is a type (named NAME), for which we have just seen some\n    baseclasses.  BASE_LIST is a list of those baseclasses; the\n    TREE_PURPOSE is an access_* node, and the TREE_VALUE is the type of\n-   the base-class.  TREE_VIA_VIRTUAL indicates virtual\n-   inheritance. CODE_TYPE_NODE indicates whether REF is a class,\n-   struct, or union.  */\n+   the base-class.  Non-NULL TREE_TYPE indicates virtual inheritance.\n+   CODE_TYPE_NODE indicates whether REF is a class, struct, or\n+   union.  */\n \n void\n xref_basetypes (tree ref, tree base_list)\n@@ -9088,7 +9088,7 @@ xref_basetypes (tree ref, tree base_list)\n       for (i = 0; base_list; base_list = TREE_CHAIN (base_list))\n \t{\n \t  tree access = TREE_PURPOSE (base_list);\n-\t  int via_virtual = TREE_VIA_VIRTUAL (base_list);\n+\t  int via_virtual = TREE_TYPE (base_list) != NULL_TREE;\n \t  tree basetype = TREE_VALUE (base_list);\n \t  tree base_binfo;\n \t  \n@@ -9141,7 +9141,7 @@ xref_basetypes (tree ref, tree base_list)\n \t  TREE_VEC_ELT (accesses, i) = access;\n \t  /* This flag will be in the binfo of the base type, we must\n \t     clear it after copying the base binfos.  */\n-\t  TREE_VIA_VIRTUAL (base_binfo) = via_virtual;\n+\t  BINFO_VIRTUAL_P (base_binfo) = via_virtual;\n \t  \n \t  SET_CLASSTYPE_MARKED (basetype);\n \t  \n@@ -9211,7 +9211,7 @@ xref_basetypes (tree ref, tree base_list)\n       CLEAR_CLASSTYPE_MARKED (basetype);\n       if (CLASS_TYPE_P (basetype))\n \t{\n-\t  TREE_VIA_VIRTUAL (TYPE_BINFO (basetype)) = 0;\n+\t  BINFO_VIRTUAL_P (TYPE_BINFO (basetype)) = 0;\n \t  BINFO_DEPENDENT_BASE_P (TYPE_BINFO (basetype)) = 0;\n \t}\n     }"}, {"sha": "f5cc1dde4ce6ed01cd7939360a470d6e85fb3113", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -272,7 +272,7 @@ cp_dump_tree (void* dump_info, tree t)\n \t    {\n \t      tree base_binfo = BINFO_BASETYPE (TYPE_BINFO (t), i);\n \t      dump_child (\"base\", BINFO_TYPE (base_binfo));\n-\t      if (TREE_VIA_VIRTUAL (base_binfo)) \n+\t      if (BINFO_VIRTUAL_P (base_binfo)) \n \t\tdump_string (di, \"virtual\");\n \t      dump_access (di, base_binfo);\n \t    }"}, {"sha": "19e51cdaaa29bbbbb530b21956289c7b56d426ec", "filename": "gcc/cp/init.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -101,7 +101,7 @@ finish_init_stmts (bool is_global, tree stmt_expr, tree compound_stmt)\n static tree\n dfs_initialize_vtbl_ptrs (tree binfo, void *data)\n {\n-  if ((!BINFO_PRIMARY_P (binfo) || TREE_VIA_VIRTUAL (binfo))\n+  if ((!BINFO_PRIMARY_P (binfo) || BINFO_VIRTUAL_P (binfo))\n       && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n     {\n       tree base_ptr = TREE_VALUE ((tree) data);\n@@ -478,7 +478,7 @@ sort_mem_initializers (tree t, tree mem_inits)\n   for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); ++i)\n     {\n       base = BINFO_BASETYPE (TYPE_BINFO (t), i);\n-      if (!TREE_VIA_VIRTUAL (base))\n+      if (!BINFO_VIRTUAL_P (base))\n \tsorted_inits = tree_cons (base, NULL_TREE, sorted_inits);\n     }\n   /* Process the non-static data members.  */\n@@ -677,7 +677,7 @@ emit_mem_initializers (tree mem_inits)\n \targuments = NULL_TREE;\n \n       /* Initialize the base.  */\n-      if (TREE_VIA_VIRTUAL (subobject))\n+      if (BINFO_VIRTUAL_P (subobject))\n \tconstruct_virtual_base (subobject, arguments);\n       else\n \t{\n@@ -717,7 +717,7 @@ build_vtbl_address (tree binfo)\n   tree binfo_for = binfo;\n   tree vtbl;\n \n-  if (BINFO_VPTR_INDEX (binfo) && TREE_VIA_VIRTUAL (binfo)\n+  if (BINFO_VPTR_INDEX (binfo) && BINFO_VIRTUAL_P (binfo)\n       && BINFO_PRIMARY_P (binfo))\n     /* If this is a virtual primary base, then the vtable we want to store\n        is that for the base this is being used as the primary base of.  We\n@@ -990,7 +990,7 @@ expand_member_init (tree name)\n \t  }\n       /* Look for a virtual base -- unless the direct base is itself\n \t virtual.  */\n-      if (!direct_binfo || !TREE_VIA_VIRTUAL (direct_binfo))\n+      if (!direct_binfo || !BINFO_VIRTUAL_P (direct_binfo))\n \tvirtual_binfo = binfo_for_vbase (basetype, current_class_type);\n \n       /* [class.base.init]\n@@ -2918,7 +2918,7 @@ push_base_cleanups (void)\n     {\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n       if (TYPE_HAS_TRIVIAL_DESTRUCTOR (BINFO_TYPE (base_binfo))\n-\t  || TREE_VIA_VIRTUAL (base_binfo))\n+\t  || BINFO_VIRTUAL_P (base_binfo))\n \tcontinue;\n \n       expr = build_special_member_call (current_class_ref, "}, {"sha": "436359b558c824a055b16ec77d523b0671db8fd5", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -542,7 +542,7 @@ do_build_copy_constructor (tree fndecl)\n       for (i = 0; i < n_bases; ++i)\n \t{\n \t  tree binfo = TREE_VEC_ELT (binfos, i);\n-\t  if (TREE_VIA_VIRTUAL (binfo))\n+\t  if (BINFO_VIRTUAL_P (binfo))\n \t    continue; \n \n \t  member_init_list "}, {"sha": "9ecec9878def1eafca795b91eebad5efb51b54b5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -5443,7 +5443,8 @@ instantiate_class_template (tree type)\n \t    continue;\n \t  \n \t  base_list = tree_cons (access, base, base_list);\n-\t  TREE_VIA_VIRTUAL (base_list) = TREE_VIA_VIRTUAL (pbase);\n+\t  if (BINFO_VIRTUAL_P (pbase))\n+\t    TREE_TYPE (base_list) = integer_type_node;\n \t}\n \n       /* The list is now in reverse order; correct that.  */\n@@ -9408,7 +9409,7 @@ get_template_base_recursive (tree tparms,\n \tcontinue;\n \n       this_virtual = \n-\t(flags & GTB_VIA_VIRTUAL) || TREE_VIA_VIRTUAL (base_binfo);\n+\t(flags & GTB_VIA_VIRTUAL) || BINFO_VIRTUAL_P (base_binfo);\n       \n       /* When searching for a non-virtual, we cannot mark virtually\n \t found binfos.  */"}, {"sha": "559d594e48f01be2b9cd4fa9b3c6c0ce29dffcf8", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -909,7 +909,7 @@ dfs_class_hint_mark (tree binfo, void *data)\n   tree basetype = BINFO_TYPE (binfo);\n   int *hint = (int *) data;\n   \n-  if (TREE_VIA_VIRTUAL (binfo))\n+  if (BINFO_VIRTUAL_P (binfo))\n     {\n       if (CLASSTYPE_MARKED (basetype))\n         *hint |= 1;\n@@ -1062,7 +1062,7 @@ get_pseudo_ti_init (tree type, tree var_desc, bool *non_public_p)\n               if (TREE_VEC_ELT (base_accesses, ix) == access_public_node)\n                 flags |= 2;\n               tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n-\t      if (TREE_VIA_VIRTUAL (base_binfo))\n+\t      if (BINFO_VIRTUAL_P (base_binfo))\n \t\t{\n \t\t   /* We store the vtable offset at which the virtual\n        \t\t      base offset can be found.  */\n@@ -1200,7 +1200,7 @@ get_pseudo_ti_desc (tree type)\n \t  \n \t  if (num_bases == 1\n \t      && TREE_VEC_ELT (base_accesses, 0) == access_public_node\n-\t      && !TREE_VIA_VIRTUAL (base_binfo)\n+\t      && !BINFO_VIRTUAL_P (base_binfo)\n \t      && integer_zerop (BINFO_OFFSET (base_binfo)))\n \t    /* single non-virtual public.  */\n \t    return si_class_desc_type_node;"}, {"sha": "a3ab7c8173a52db619e351d1dea5dff3147e9193", "filename": "gcc/cp/search.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -197,7 +197,7 @@ lookup_base_r (tree binfo, tree base, base_access access,\n \n       bk = lookup_base_r (base_binfo, base,\n \t\t    \t  access,\n-\t\t\t  is_virtual || TREE_VIA_VIRTUAL (base_binfo),\n+\t\t\t  is_virtual || BINFO_VIRTUAL_P (base_binfo),\n \t\t\t  binfo_ptr);\n \n       switch (bk)\n@@ -376,7 +376,7 @@ dynamic_cast_base_recurse (tree subtype, tree binfo, bool is_via_virtual,\n         continue;\n       rval = dynamic_cast_base_recurse\n              (subtype, base_binfo,\n-              is_via_virtual || TREE_VIA_VIRTUAL (base_binfo), offset_ptr);\n+              is_via_virtual || BINFO_VIRTUAL_P (base_binfo), offset_ptr);\n       if (worst == -2)\n         worst = rval;\n       else if (rval >= 0)\n@@ -2493,7 +2493,7 @@ binfo_from_vbase (tree binfo)\n {\n   for (; binfo; binfo = BINFO_INHERITANCE_CHAIN (binfo))\n     {\n-      if (TREE_VIA_VIRTUAL (binfo))\n+      if (BINFO_VIRTUAL_P (binfo))\n \treturn binfo;\n     }\n   return NULL_TREE;\n@@ -2509,7 +2509,7 @@ binfo_via_virtual (tree binfo, tree limit)\n   for (; binfo && (!limit || !same_type_p (BINFO_TYPE (binfo), limit));\n        binfo = BINFO_INHERITANCE_CHAIN (binfo))\n     {\n-      if (TREE_VIA_VIRTUAL (binfo))\n+      if (BINFO_VIRTUAL_P (binfo))\n \treturn binfo;\n     }\n   return NULL_TREE;\n@@ -2524,7 +2524,7 @@ copied_binfo (tree binfo, tree here)\n {\n   tree result = NULL_TREE;\n   \n-  if (TREE_VIA_VIRTUAL (binfo))\n+  if (BINFO_VIRTUAL_P (binfo))\n     {\n       tree t;\n \n@@ -2588,7 +2588,7 @@ original_binfo (tree binfo, tree here)\n   \n   if (BINFO_TYPE (binfo) == BINFO_TYPE (here))\n     result = here;\n-  else if (TREE_VIA_VIRTUAL (binfo))\n+  else if (BINFO_VIRTUAL_P (binfo))\n     result = (CLASSTYPE_VBASECLASSES (BINFO_TYPE (here))\n \t      ? binfo_for_vbase (BINFO_TYPE (binfo), BINFO_TYPE (here))\n \t      : NULL_TREE);"}, {"sha": "e7502260e4d04a0660ce417dc2ee033c4ab4a29a", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -2232,7 +2232,8 @@ finish_template_type (tree name, tree args, int entering_scope)\n    Return a TREE_LIST containing the ACCESS_SPECIFIER and the\n    BASE_CLASS, or NULL_TREE if an error occurred.  The\n    ACCESS_SPECIFIER is one of\n-   access_{default,public,protected_private}[_virtual]_node.*/\n+   access_{default,public,protected_private}_node.  For a virtual base\n+   we set TREE_TYPE.  */\n \n tree \n finish_base_specifier (tree base, tree access, bool virtual_p)\n@@ -2254,7 +2255,8 @@ finish_base_specifier (tree base, tree access, bool virtual_p)\n           base = TYPE_MAIN_VARIANT (base);\n         }\n       result = build_tree_list (access, base);\n-      TREE_VIA_VIRTUAL (result) = virtual_p;\n+      if (virtual_p)\n+\tTREE_TYPE (result) = integer_type_node;\n     }\n \n   return result;"}, {"sha": "0863e29191dd3fbd81b7434e4cf9b5f65ca1a77c", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -612,7 +612,7 @@ copy_base_binfos (tree binfo, tree t, tree prev)\n \t  BINFO_INHERITANCE_CHAIN (new_binfo) = binfo;\n \t  BINFO_DEPENDENT_BASE_P (new_binfo) = 1;\n \t}\n-      else if (TREE_VIA_VIRTUAL (base_binfo))\n+      else if (BINFO_VIRTUAL_P (base_binfo))\n \tnew_binfo = binfo_for_vbase (BINFO_TYPE (base_binfo), t);\n       \n       if (!new_binfo)\n@@ -621,10 +621,10 @@ copy_base_binfos (tree binfo, tree t, tree prev)\n \t\t\t\t  base_binfo, NULL_TREE,\n \t\t\t\t  BINFO_VIRTUALS (base_binfo));\n \t  prev = copy_base_binfos (new_binfo, t, prev);\n-\t  if (TREE_VIA_VIRTUAL (base_binfo))\n+\t  if (BINFO_VIRTUAL_P (base_binfo))\n \t    {\n \t      VEC_quick_push (tree, CLASSTYPE_VBASECLASSES (t), new_binfo);\n-\t      TREE_VIA_VIRTUAL (new_binfo) = 1;\n+\t      BINFO_VIRTUAL_P (new_binfo) = 1;\n \t      BINFO_INHERITANCE_CHAIN (new_binfo) = TYPE_BINFO (t);\n \t    }\n \t  else"}, {"sha": "a8b47bad876dd778b7a3bfc78e71080bb717a616", "filename": "gcc/dbxout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -1704,12 +1704,12 @@ dbxout_type (tree type, int full)\n \t    if (use_gnu_debug_info_extensions)\n \t      {\n \t\thave_used_extensions = 1;\n-                putc (TREE_VIA_VIRTUAL (child) ? '1' : '0', asmfile);\n+                putc (BINFO_VIRTUAL_P (child) ? '1' : '0', asmfile);\n                 putc (access == access_public_node ? '2' :\n                       (access == access_protected_node ? '1' :'0'),\n                       asmfile);\n \t\tCHARS (2);\n-\t\tif (TREE_VIA_VIRTUAL (child)\n+\t\tif (BINFO_VIRTUAL_P (child)\n \t\t    && strcmp (lang_hooks.name, \"GNU C++\") == 0)\n \t\t  /* For a virtual base, print the (negative) offset within\n \t\t     the vtable where we must look to find the necessary"}, {"sha": "f25c8fb006a1f16a26c2d5e0c01771bd2ba55ba2", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -747,6 +747,8 @@ list.  Implicitly declared functions (including default constructors,\n copy constructors, assignment operators, and destructors) will appear on\n this list as well.\n \n+@c under reconstruction 2004-07-01, FIXME:Nathan Sidwell\n+[Binfos are being redesigned, this information is in a state of flux.]\n Every class has an associated @dfn{binfo}, which can be obtained with\n @code{TYPE_BINFO}.  Binfos are used to represent base-classes.  The\n binfo given by @code{TYPE_BINFO} is the degenerate case, whereby every"}, {"sha": "e1c8b75ea8430c6ef2dcf7f6b4e3e92f6053b161", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -9471,7 +9471,7 @@ add_data_member_location_attribute (dw_die_ref die, tree decl)\n   if (TREE_CODE (decl) == TREE_BINFO)\n     {\n       /* We're working on the TAG_inheritance for a base class.  */\n-      if (TREE_VIA_VIRTUAL (decl) && is_cxx ())\n+      if (BINFO_VIRTUAL_P (decl) && is_cxx ())\n \t{\n \t  /* For C++ virtual bases we can't just use BINFO_OFFSET, as they\n \t     aren't at a fixed offset from all (sub)objects of the same\n@@ -11860,7 +11860,7 @@ gen_inheritance_die (tree binfo, tree access, dw_die_ref context_die)\n   add_type_attribute (die, BINFO_TYPE (binfo), 0, 0, context_die);\n   add_data_member_location_attribute (die, binfo);\n \n-  if (TREE_VIA_VIRTUAL (binfo))\n+  if (BINFO_VIRTUAL_P (binfo))\n     add_AT_unsigned (die, DW_AT_virtuality, DW_VIRTUALITY_virtual);\n \n   if (access == access_public_node)"}, {"sha": "bfe435d1aa14b0e9ba2ea57f476b9e8b67b88ef5", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -1,3 +1,8 @@\n+2004-07-06  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* java-tree.h (CLASS_HAS_SUPER_FLAG): Use BINFO_FLAG_1.\n+\t* class.c (add_interface_do): Use BINFO_VIRTUAL_P.\n+\n 2004-07-05  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* class.c (make_class): Use make_tree_binfo.\n@@ -8167,7 +8172,7 @@\n \tproperly initialize `finished_label'. Don't emit gotos for empty\n \ttry statements.\n \n-2000-03-19  Martin v. L\u00f6wis  <loewis@informatik.hu-berlin.de>\n+2000-03-19  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* except.c (emit_handlers): Clear catch_clauses_last.\n "}, {"sha": "be4b3fdc92036a7870fba149d140dd744e3457e3", "filename": "gcc/java/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -616,7 +616,7 @@ add_interface_do (tree basetype_vec, tree interface_class, int i)\n   BINFO_TYPE (interface_binfo) = interface_class;\n   BINFO_OFFSET (interface_binfo) = integer_zero_node;\n   BINFO_VPTR_FIELD (interface_binfo) = integer_zero_node;\n-  TREE_VIA_VIRTUAL (interface_binfo) = 1;\n+  BINFO_VIRTUAL_P (interface_binfo) = 1;\n   TREE_VEC_ELT (basetype_vec, i) = interface_binfo;\n }\n "}, {"sha": "04a8f1f3e0f334ffdcf2327d8c575f59d5a8516b", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -48,8 +48,7 @@ struct JCF;\n       SUPPRESS_UNREACHABLE_ERROR (for other _EXPR nodes)\n       ANONYMOUS_CLASS_P (in RECORD_TYPE)\n       ARG_FINAL_P (in TREE_LIST)\n-   1: CLASS_HAS_SUPER_FLAG (in TREE_BINFO).\n-      IS_A_CLASSFILE_NAME (in IDENTIFIER_NODE)\n+   1: IS_A_CLASSFILE_NAME (in IDENTIFIER_NODE)\n       COMPOUND_ASSIGN_P (in EXPR (binop_*))\n       LOCAL_CLASS_P (in RECORD_TYPE)\n       BLOCK_IS_IMPLICIT (in BLOCK)\n@@ -122,7 +121,7 @@ struct JCF;\n \n /* True if the class whose TYPE_BINFO this is has a superclass.\n    (True of all classes except Object.) */\n-#define CLASS_HAS_SUPER_FLAG(BINFO) TREE_LANG_FLAG_1 (TREE_BINFO_CHECK (BINFO))\n+#define CLASS_HAS_SUPER_FLAG(BINFO) BINFO_FLAG_1 (BINFO)\n #define CLASS_HAS_SUPER(TYPE) CLASS_HAS_SUPER_FLAG (TYPE_BINFO (TYPE))\n \n /* Return the supertype of class TYPE, or NULL_TREE is it has none. */"}, {"sha": "8ee8f4b5031f643a0ac982d77c0ae78d61076385", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -257,7 +257,7 @@ dequeue_and_dump (dump_info_p di)\n \n       dump_child (\"type\", BINFO_TYPE (t));\n \n-      if (TREE_VIA_VIRTUAL (t))\n+      if (BINFO_VIRTUAL_P (t))\n \tdump_string (di, \"virt\");\n \n       dump_int (di, \"bases\", n_bases);"}, {"sha": "51fc2ad66e55fdc5c73c764105a34de8638647ed", "filename": "gcc/tree.h", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/809e3e7fece2749886700d92571232ec3faef2a0/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=809e3e7fece2749886700d92571232ec3faef2a0", "patch": "@@ -203,7 +203,7 @@ struct tree_common GTY(())\n        TREE_STATIC in\n            VAR_DECL, FUNCTION_DECL, CONSTRUCTOR, ADDR_EXPR\n        TREE_VIA_VIRTUAL in\n-           TREE_LIST or TREE_BINFO\n+           TREE_BINFO\n        TREE_CONSTANT_OVERFLOW in\n            INTEGER_CST, REAL_CST, COMPLEX_CST, VECTOR_CST\n        TREE_SYMBOL_REFERENCED in\n@@ -738,11 +738,6 @@ extern void tree_operand_check_failed (int, enum tree_code,\n    implicitly and should not lead to any sort of warning.  */\n #define TREE_NO_WARNING(NODE) ((NODE)->common.nowarning_flag)\n \n-/* Nonzero for a TREE_LIST or TREE_BINFO node means that the derivation\n-   chain is via a `virtual' declaration.  */\n-#define TREE_VIA_VIRTUAL(NODE) \\\n-  (TREE_CHECK2 (NODE, TREE_LIST, TREE_BINFO)->common.static_flag)\n-\n /* In an INTEGER_CST, REAL_CST, COMPLEX_CST, or VECTOR_CST this means\n    there was an overflow in folding.  This is distinct from\n    TREE_OVERFLOW because ANSI C requires a diagnostic when overflows\n@@ -1597,6 +1592,20 @@ struct tree_type GTY(())\n    Thus, given a pointer to class C, one can get a pointer to the binfo\n    of D acting as a basetype for C by looking at C's binfo's basetypes.  */\n \n+/* BINFO specific flags.  */\n+\n+/* Nonzero means that the derivation chain is via a `virtual' declaration.  */\n+#define BINFO_VIRTUAL_P(NODE) (TREE_BINFO_CHECK (NODE)->common.static_flag)\n+\n+/* Flags for language dependent use.  */\n+#define BINFO_MARKED(NODE) TREE_LANG_FLAG_0(TREE_BINFO_CHECK(NODE))\n+#define BINFO_FLAG_1(NODE) TREE_LANG_FLAG_1(TREE_BINFO_CHECK(NODE))\n+#define BINFO_FLAG_2(NODE) TREE_LANG_FLAG_2(TREE_BINFO_CHECK(NODE))\n+#define BINFO_FLAG_3(NODE) TREE_LANG_FLAG_3(TREE_BINFO_CHECK(NODE))\n+#define BINFO_FLAG_4(NODE) TREE_LANG_FLAG_4(TREE_BINFO_CHECK(NODE))\n+#define BINFO_FLAG_5(NODE) TREE_LANG_FLAG_5(TREE_BINFO_CHECK(NODE))\n+#define BINFO_FLAG_6(NODE) TREE_LANG_FLAG_6(TREE_BINFO_CHECK(NODE))\n+\n /* The actual data type node being inherited in this basetype.  */\n #define BINFO_TYPE(NODE) TREE_TYPE (TREE_BINFO_CHECK(NODE))\n "}]}