{"sha": "a9a2595b5892b183a7435432b7835b2f416315ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTlhMjU5NWI1ODkyYjE4M2E3NDM1NDMyYjc4MzViMmY0MTYzMTVhYw==", "commit": {"author": {"name": "Joern Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-04-02T02:42:26Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-04-02T02:42:26Z"}, "message": "reload.c (find_reloads_address): Try LEGITIMIZE_RELOAD_ADDRESS.\n\n* reload.c (find_reloads_address): Try LEGITIMIZE_RELOAD_ADDRESS.\n(move_replacements): New function.\n* reload.h: Prototype it.\n* alpha.h (LEGITIMIZE_RELOAD_ADDRESS): New definition.\n\nCo-Authored-By: Richard Henderson <rth@cygnus.com>\n\nFrom-SVN: r18947", "tree": {"sha": "f59e40f4deba74dfcf190f270a49743212d8ea4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f59e40f4deba74dfcf190f270a49743212d8ea4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9a2595b5892b183a7435432b7835b2f416315ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9a2595b5892b183a7435432b7835b2f416315ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9a2595b5892b183a7435432b7835b2f416315ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9a2595b5892b183a7435432b7835b2f416315ac/comments", "author": null, "committer": null, "parents": [{"sha": "ce4d78eb2f91ec1b5278a4a23467055089ccc22f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce4d78eb2f91ec1b5278a4a23467055089ccc22f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce4d78eb2f91ec1b5278a4a23467055089ccc22f"}], "stats": {"total": 134, "additions": 134, "deletions": 0}, "files": [{"sha": "ac37ecd95b44777d9be00170f074bf92a7d784ad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a2595b5892b183a7435432b7835b2f416315ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a2595b5892b183a7435432b7835b2f416315ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9a2595b5892b183a7435432b7835b2f416315ac", "patch": "@@ -1,3 +1,12 @@\n+Thu Apr  2 02:37:07 1998  Joern Rennecke  (amylaar@cygnus.co.uk)\n+\t \t\t  Richard Henderson  <rth@cygnus.com>\n+\n+\t* reload.c (find_reloads_address): Try LEGITIMIZE_RELOAD_ADDRESS.\n+\t(move_replacements): New function.\n+\t* reload.h: Prototype it.\n+\t\n+\t* alpha.h (LEGITIMIZE_RELOAD_ADDRESS): New definition.\n+\t\n Thu Apr  2 01:01:34 1998  Richard Henderson  <rth@cygnus.com>\n \n \t* configure (alpha-*-linuxecoff, alpha-*-linux-gnulibc1):"}, {"sha": "39b5abfb4c0942a7a948d37bd514269bf02cf0d3", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a2595b5892b183a7435432b7835b2f416315ac/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a2595b5892b183a7435432b7835b2f416315ac/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=a9a2595b5892b183a7435432b7835b2f416315ac", "patch": "@@ -1467,6 +1467,46 @@ extern void alpha_init_expanders ();\n     }\t\t\t\t\t\t\t\t\\\n }\n \n+/* Try a machine-dependent way of reloading an illegitimate address\n+   operand.  If we find one, push the reload and jump to WIN.  This\n+   macro is used in only one place: `find_reloads_address' in reload.c.\n+\n+   For the Alpha, we wish to handle large displacements off a base\n+   register by splitting the addend across an ldah and the mem insn.\n+   This cuts number of extra insns needed from 3 to 1.  */\n+   \n+#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+      && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+      && REGNO (XEXP (X, 0)) < FIRST_PSEUDO_REGISTER\t\t\t\\\n+      && REG_MODE_OK_FOR_BASE_P (XEXP (X, 0), MODE)\t\t\t\\\n+      && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      HOST_WIDE_INT val = INTVAL (XEXP (X, 1));\t\t\t\t\\\n+      HOST_WIDE_INT low = ((val & 0xffff) ^ 0x8000) - 0x8000;\t\t\\\n+      HOST_WIDE_INT high\t\t\t\t\t\t\\\n+\t= (((val - low) & 0xffffffff) ^ 0x80000000) - 0x80000000;\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* Check for 32-bit overflow.  */\t\t\t\t\t\\\n+      if (high + low != val)\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* Reload the high part into a base reg; leave the low part\t\\\n+\t in the mem directly.  */\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      X = gen_rtx_PLUS (GET_MODE (X),\t\t\t\t\t\\\n+\t\t\tgen_rtx_PLUS (GET_MODE (X), XEXP (X, 0),\t\\\n+\t\t\t\t      GEN_INT (high)),\t\t\t\\\n+\t\t\tGEN_INT (low));\t\t\t\t\t\\\n+\t  \t\t\t\t\t\t\t\t\\\n+      push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL_PTR,\t\\\n+\t\t   BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,\t\\\n+\t\t   OPNUM, TYPE);\t\t\t\t\t\\\n+      goto WIN;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.\n    On the Alpha this is true only for the unaligned modes.   We can"}, {"sha": "6548243023424d7f757b4d7560b354673f3536ee", "filename": "gcc/reload.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a2595b5892b183a7435432b7835b2f416315ac/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a2595b5892b183a7435432b7835b2f416315ac/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=a9a2595b5892b183a7435432b7835b2f416315ac", "patch": "@@ -4422,6 +4422,24 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \treturn 0;\n     }\n \n+#ifdef LEGITIMIZE_RELOAD_ADDRESS\n+  do\n+    {\n+      if (memrefloc)\n+\t{\n+\t  LEGITIMIZE_RELOAD_ADDRESS (ad, GET_MODE (*memrefloc), opnum, type,\n+\t\t\t\t     ind_levels, win);\n+\t}\n+      break;\n+    win:\n+      *memrefloc = copy_rtx (*memrefloc);\n+      XEXP (*memrefloc, 0) = ad;\n+      move_replacements (&ad, &XEXP (*memrefloc, 0));\n+      return 1;\n+    }\n+  while (0);\n+#endif\n+\n   /* The address is not valid.  We have to figure out why.  One possibility\n      is that it is itself a MEM.  This can happen when the frame pointer is\n      being eliminated, a pseudo is not allocated to a hard register, and the\n@@ -5372,6 +5390,25 @@ copy_replacements (x, y)\n \t    }\n \t}\n }\n+\n+/* Change any replacements being done to *X to be done to *Y */\n+\n+void\n+move_replacements (x, y)\n+     rtx *x;\n+     rtx *y;\n+{\n+  int i;\n+\n+  for (i = 0; i < n_replacements; i++)\n+    if (replacements[i].subreg_loc == x)\n+      replacements[i].subreg_loc = y;\n+    else if (replacements[i].where == x)\n+      {\n+\treplacements[i].where = y;\n+\treplacements[i].subreg_loc = 0;\n+      }\n+}\n \f\n /* If LOC was scheduled to be replaced by something, return the replacement.\n    Otherwise, return *LOC.  */"}, {"sha": "79f5882e98edbfd2d3e07d8dbe395ecc3ecf08d2", "filename": "gcc/reload.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a2595b5892b183a7435432b7835b2f416315ac/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a2595b5892b183a7435432b7835b2f416315ac/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=a9a2595b5892b183a7435432b7835b2f416315ac", "patch": "@@ -187,6 +187,9 @@ extern void subst_reloads PROTO((void));\n    the RTL.  */\n extern void copy_replacements PROTO((rtx, rtx));\n \n+/* Change any replacements being done to *X to be done to *Y */\n+extern void move_replacements PROTO((rtx *x, rtx *y));\n+\n /* If LOC was scheduled to be replaced by something, return the replacement.\n    Otherwise, return *LOC.  */\n extern rtx find_replacement PROTO((rtx *));"}, {"sha": "9a8887fdaf98f84ec32a924f16e2914e260c1ad5", "filename": "gcc/tm.texi", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9a2595b5892b183a7435432b7835b2f416315ac/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9a2595b5892b183a7435432b7835b2f416315ac/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=a9a2595b5892b183a7435432b7835b2f416315ac", "patch": "@@ -4223,6 +4223,51 @@ address.  The compiler has standard ways of doing so in all cases.  In\n fact, it is safe for this macro to do nothing.  But often a\n machine-dependent strategy can generate better code.\n \n+@findex LEGITIMIZE_RELOAD_ADDRESS\n+@item LEGITIMIZE_RELOAD_ADDRESS (@var{x}, @var{mode}, @var{opnum}, @var{type}, @var{ind_levels}, @var{win})\n+A C compound statement that attempts to replace @var{x}, which is an address\n+that needs reloading, with a valid memory address for an operand of mode\n+@var{mode}.  @var{win} will be a C statement label elsewhere in the code.\n+It is not necessary to define this macro, but it might be useful for\n+performance reasons. \n+\n+For example, on the i386, it is sometimes possible to use a single\n+reload register instead of two by reloading a sum of two pseudo\n+registers into a register.  On the other hand, for number of RISC\n+processors offsets are limited so that often an intermediate address\n+needs to be generated in order to address a stack slot.  By defining\n+LEGITIMIZE_RELOAD_ADDRESS appropriately, the intermediate addresses\n+generated for adjacent some stack slots can be made identical, and thus\n+be shared.\n+\n+@findex strict_memory_address_p\n+The macro definition may use @code{strict_memory_address_p} to test if\n+the address has become legitimate.\n+\n+@findex push_reload\n+It may use @code{push_reload} to indicate parts that need reloading.\n+@var{opnum}, @var{type} and @var{ind_levels} are usually suitable to be\n+passed unaltered to push_reload.\n+\n+The code generated by this macro should not alter the substructure of\n+@var{x}.  If it transforms @var{x} into a more legitimate form, it\n+should assign @var{x} (which will always be a C variable) a new value.\n+This also applies to parts that you change indirectly by calling\n+@code{push_reload}.\n+\n+@findex copy_rtx\n+If you want to change only a part of @var{x}, one standard way of doing\n+this is to use @code{copy_rtx}.  Note, however, that is unshares only a\n+single level of rtl.  Thus, if the part to be changed is not at the\n+top level, you'll need to replace first the top leve\n+It is not necessary for this macro to come up with a legitimate\n+address;  but often a machine-dependent strategy can generate better code.\n+\n+@emph{Note}: This macro should be used with caution.  It is necessary\n+to know something of how reload works in order to effectively use this,\n+and it is quite easy to produce macros that build in too much knowledge\n+of reload internals.\n+\n @findex GO_IF_MODE_DEPENDENT_ADDRESS\n @item GO_IF_MODE_DEPENDENT_ADDRESS (@var{addr}, @var{label})\n A C statement or compound statement with a conditional @code{goto"}]}