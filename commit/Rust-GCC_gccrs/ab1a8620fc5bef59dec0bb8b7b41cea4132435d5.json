{"sha": "ab1a8620fc5bef59dec0bb8b7b41cea4132435d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIxYTg2MjBmYzViZWY1OWRlYzBiYjhiN2I0MWNlYTQxMzI0MzVkNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-11-29T01:03:15Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-11-29T01:03:15Z"}, "message": "tree-nested.c (check_for_nested_with_variably_modified): New.\n\n\t* tree-nested.c (check_for_nested_with_variably_modified): New.\n\t(create_nesting_tree): Call it.\n\nFrom-SVN: r91449", "tree": {"sha": "27de2755d3124d876ba5e82bd25a3c692922dafa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27de2755d3124d876ba5e82bd25a3c692922dafa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab1a8620fc5bef59dec0bb8b7b41cea4132435d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab1a8620fc5bef59dec0bb8b7b41cea4132435d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab1a8620fc5bef59dec0bb8b7b41cea4132435d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab1a8620fc5bef59dec0bb8b7b41cea4132435d5/comments", "author": null, "committer": null, "parents": [{"sha": "406eab994a2da3bb54b959901acc1ddf9826eccf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/406eab994a2da3bb54b959901acc1ddf9826eccf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/406eab994a2da3bb54b959901acc1ddf9826eccf"}], "stats": {"total": 51, "additions": 50, "deletions": 1}, "files": [{"sha": "38eb985f09f26ed31d3f2e329d657591822317ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab1a8620fc5bef59dec0bb8b7b41cea4132435d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab1a8620fc5bef59dec0bb8b7b41cea4132435d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab1a8620fc5bef59dec0bb8b7b41cea4132435d5", "patch": "@@ -1,5 +1,8 @@\n 2004-11-28  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* tree-nested.c (check_for_nested_with_variably_modified): New.\n+\t(create_nesting_tree): Call it.\n+\n \t* tree-ssa-alias.c (compute_points_to_and_addr_escapes): Remove\n \tspecial code for assigning to non-pointer.\n \t(is_escape_site): If RHS is a conversion between pointer and integer"}, {"sha": "76396ca96f82430dd7e2f051bca84a30eeeb70e9", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab1a8620fc5bef59dec0bb8b7b41cea4132435d5/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab1a8620fc5bef59dec0bb8b7b41cea4132435d5/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=ab1a8620fc5bef59dec0bb8b7b41cea4132435d5", "patch": "@@ -612,8 +612,49 @@ walk_all_functions (walk_tree_fn callback, struct nesting_info *root)\n     }\n   while (root);\n }\n-\n \f\n+/* We have to check for a fairly pathalogical case.  The operands of function\n+   nested function are to be interpreted in the context of the enclosing\n+   function.  So if any are variably-sized, they will get remapped when the\n+   enclosing function is inlined.  But that remapping would also have to be\n+   done in the types of the PARM_DECLs of the nested function, meaning the\n+   argument types of that function will disagree with the arguments in the\n+   calls to that function.  So we'd either have to make a copy of the nested\n+   function corresponding to each time the enclosing function was inlined or\n+   add a VIEW_CONVERT_EXPR to each such operand for each call to the nested\n+   function.  The former is not practical.  The latter would still require\n+   detecting this case to know when to add the conversions.  So, for now at\n+   least, we don't inline such an enclosing function.\n+\n+   We have to do that check recursively, so here return indicating whether\n+   FNDECL has such a nested function.  ORIG_FN is the function we were\n+   trying to inline to use for checking whether any argument is variably\n+   modified by anything in it.\n+\n+   It would be better to do this in tree-inline.c so that we could give\n+   the appropriate warning for why a function can't be inlined, but that's\n+   too late since the nesting structure has already been flattened and\n+   adding a flag just to record this fact seems a waste of a flag.  */\n+\n+static bool\n+check_for_nested_with_variably_modified (tree fndecl, tree orig_fndecl)\n+{\n+  struct cgraph_node *cgn = cgraph_node (fndecl);\n+  tree arg;\n+\n+  for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n+    {\n+      for (arg = DECL_ARGUMENTS (cgn->decl); arg; arg = TREE_CHAIN (arg))\n+\tif (variably_modified_type_p (TREE_TYPE (arg), 0), orig_fndecl)\n+\t  return true;\n+\n+      if (check_for_nested_with_variably_modified (cgn->decl, orig_fndecl))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n /* Construct our local datastructure describing the function nesting\n    tree rooted by CGN.  */\n \n@@ -632,6 +673,11 @@ create_nesting_tree (struct cgraph_node *cgn)\n       info->inner = sub;\n     }\n \n+  /* See discussion at check_for_nested_with_variably_modified for a\n+     discussion of why this has to be here.  */\n+  if (check_for_nested_with_variably_modified (info->context, info->context))\n+    DECL_UNINLINABLE (info->context) = true;\n+\n   return info;\n }\n "}]}