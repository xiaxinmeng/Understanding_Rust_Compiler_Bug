{"sha": "e86a910ff5b8ecfeeeb1e57bffcb85887b771f9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg2YTkxMGZmNWI4ZWNmZWVlYjFlNTdiZmZjYjg1ODg3Yjc3MWY5YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-04-18T18:30:45Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-04-18T18:30:45Z"}, "message": "ipa-inline.c (spec_rem): New static variable.\n\n\t* ipa-inline.c (spec_rem): New static variable.\n\t(dump_overall_stats): New function.\n\t(dump_inline_stats): New function.\n\nFrom-SVN: r209522", "tree": {"sha": "f13c9287e9f4b5d2d24d112f7c85d5f4ecf6d4ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f13c9287e9f4b5d2d24d112f7c85d5f4ecf6d4ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e86a910ff5b8ecfeeeb1e57bffcb85887b771f9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e86a910ff5b8ecfeeeb1e57bffcb85887b771f9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e86a910ff5b8ecfeeeb1e57bffcb85887b771f9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e86a910ff5b8ecfeeeb1e57bffcb85887b771f9a/comments", "author": null, "committer": null, "parents": [{"sha": "fc45aeeeeccfe9e81f7e9619188c5450b1550634", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc45aeeeeccfe9e81f7e9619188c5450b1550634", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc45aeeeeccfe9e81f7e9619188c5450b1550634"}], "stats": {"total": 144, "additions": 141, "deletions": 3}, "files": [{"sha": "a7d1c9df32f7ca3c04ff7b5c974ef1145b8192a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86a910ff5b8ecfeeeb1e57bffcb85887b771f9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86a910ff5b8ecfeeeb1e57bffcb85887b771f9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e86a910ff5b8ecfeeeb1e57bffcb85887b771f9a", "patch": "@@ -1,3 +1,9 @@\n+2014-04-18  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-inline.c (spec_rem): New static variable.\n+\t(dump_overall_stats): New function.\n+\t(dump_inline_stats): New function.\n+\n 2014-04-18  Richard Henderson  <rth@redhat.com>\n \n \t* config/aarch64/aarch64.c (aarch64_register_move_cost): Pass a mode"}, {"sha": "1b7a74e0745f3fb507b05744a624a37241ef5fc5", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 135, "deletions": 3, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e86a910ff5b8ecfeeeb1e57bffcb85887b771f9a/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e86a910ff5b8ecfeeeb1e57bffcb85887b771f9a/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=e86a910ff5b8ecfeeeb1e57bffcb85887b771f9a", "patch": "@@ -127,6 +127,7 @@ along with GCC; see the file COPYING3.  If not see\n static int overall_size;\n static gcov_type max_count;\n static sreal max_count_real, max_relbenefit_real, half_int_min_real;\n+static gcov_type spec_rem;\n \n /* Return false when inlining edge E would lead to violating\n    limits on function unit growth or stack usage growth.  \n@@ -1533,6 +1534,7 @@ resolve_noninline_speculation (fibheap_t edge_heap, struct cgraph_edge *edge)\n \t\t\t\t  ? node->global.inlined_to : node;\n       bitmap updated_nodes = BITMAP_ALLOC (NULL);\n \n+      spec_rem += edge->count;\n       cgraph_resolve_speculation (edge, NULL);\n       reset_edge_caches (where);\n       inline_update_overall_summary (where);\n@@ -1996,6 +1998,130 @@ inline_to_all_callers (struct cgraph_node *node, void *data)\n   return false;\n }\n \n+/* Output overall time estimate.  */\n+static void\n+dump_overall_stats (void)\n+{\n+  HOST_WIDEST_INT sum_weighted = 0, sum = 0;\n+  struct cgraph_node *node;\n+\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    if (!node->global.inlined_to\n+\t&& !node->alias)\n+      {\n+\tint time = inline_summary (node)->time;\n+\tsum += time;\n+\tsum_weighted += time * node->count;\n+      }\n+  fprintf (dump_file, \"Overall time estimate: \"\n+\t   HOST_WIDEST_INT_PRINT_DEC\" weighted by profile: \"\n+\t   HOST_WIDEST_INT_PRINT_DEC\"\\n\", sum, sum_weighted);\n+}\n+\n+/* Output some useful stats about inlining.  */\n+\n+static void\n+dump_inline_stats (void)\n+{\n+  HOST_WIDEST_INT inlined_cnt = 0, inlined_indir_cnt = 0;\n+  HOST_WIDEST_INT inlined_virt_cnt = 0, inlined_virt_indir_cnt = 0;\n+  HOST_WIDEST_INT noninlined_cnt = 0, noninlined_indir_cnt = 0;\n+  HOST_WIDEST_INT noninlined_virt_cnt = 0, noninlined_virt_indir_cnt = 0;\n+  HOST_WIDEST_INT  inlined_speculative = 0, inlined_speculative_ply = 0;\n+  HOST_WIDEST_INT indirect_poly_cnt = 0, indirect_cnt = 0;\n+  HOST_WIDEST_INT reason[CIF_N_REASONS][3];\n+  int i;\n+  struct cgraph_node *node;\n+\n+  memset (reason, 0, sizeof (reason));\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+  {\n+    struct cgraph_edge *e;\n+    for (e = node->callees; e; e = e->next_callee)\n+      {\n+\tif (e->inline_failed)\n+\t  {\n+\t    reason[(int) e->inline_failed][0] += e->count;\n+\t    reason[(int) e->inline_failed][1] += e->frequency;\n+\t    reason[(int) e->inline_failed][2] ++;\n+\t    if (DECL_VIRTUAL_P (e->callee->decl))\n+\t      {\n+\t\tif (e->indirect_inlining_edge)\n+\t\t  noninlined_virt_indir_cnt += e->count;\n+\t\telse\n+\t\t  noninlined_virt_cnt += e->count;\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (e->indirect_inlining_edge)\n+\t\t  noninlined_indir_cnt += e->count;\n+\t\telse\n+\t\t  noninlined_cnt += e->count;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    if (e->speculative)\n+\t      {\n+\t\tif (DECL_VIRTUAL_P (e->callee->decl))\n+\t\t  inlined_speculative_ply += e->count;\n+\t\telse\n+\t\t  inlined_speculative += e->count;\n+\t      }\n+\t    else if (DECL_VIRTUAL_P (e->callee->decl))\n+\t      {\n+\t\tif (e->indirect_inlining_edge)\n+\t\t  inlined_virt_indir_cnt += e->count;\n+\t\telse\n+\t\t  inlined_virt_cnt += e->count;\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (e->indirect_inlining_edge)\n+\t\t  inlined_indir_cnt += e->count;\n+\t\telse\n+\t\t  inlined_cnt += e->count;\n+\t      }\n+\t  }\n+      }\n+    for (e = node->indirect_calls; e; e = e->next_callee)\n+      if (e->indirect_info->polymorphic)\n+\tindirect_poly_cnt += e->count;\n+      else\n+\tindirect_cnt += e->count;\n+  }\n+  if (max_count)\n+    {\n+      fprintf (dump_file,\n+\t       \"Inlined \" HOST_WIDEST_INT_PRINT_DEC \" + speculative \"\n+\t       HOST_WIDEST_INT_PRINT_DEC \" + speculative polymorphic \"\n+\t       HOST_WIDEST_INT_PRINT_DEC \" + previously indirect \"\n+\t       HOST_WIDEST_INT_PRINT_DEC \" + virtual \"\n+\t       HOST_WIDEST_INT_PRINT_DEC \" + virtual and previously indirect \"\n+\t       HOST_WIDEST_INT_PRINT_DEC \"\\n\" \"Not inlined \"\n+\t       HOST_WIDEST_INT_PRINT_DEC \" + previously indirect \"\n+\t       HOST_WIDEST_INT_PRINT_DEC \" + virtual \"\n+\t       HOST_WIDEST_INT_PRINT_DEC \" + virtual and previously indirect \"\n+\t       HOST_WIDEST_INT_PRINT_DEC \" + stil indirect \"\n+\t       HOST_WIDEST_INT_PRINT_DEC \" + still indirect polymorphic \"\n+\t       HOST_WIDEST_INT_PRINT_DEC \"\\n\", inlined_cnt,\n+\t       inlined_speculative, inlined_speculative_ply,\n+\t       inlined_indir_cnt, inlined_virt_cnt, inlined_virt_indir_cnt,\n+\t       noninlined_cnt, noninlined_indir_cnt, noninlined_virt_cnt,\n+\t       noninlined_virt_indir_cnt, indirect_cnt, indirect_poly_cnt);\n+      fprintf (dump_file,\n+\t       \"Removed speculations \" HOST_WIDEST_INT_PRINT_DEC \"\\n\",\n+\t       spec_rem);\n+    }\n+  dump_overall_stats ();\n+  fprintf (dump_file, \"\\nWhy inlining failed?\\n\");\n+  for (i = 0; i < CIF_N_REASONS; i++)\n+    if (reason[i][2])\n+      fprintf (dump_file, \"%-50s: %8i calls, %8i freq, \"HOST_WIDEST_INT_PRINT_DEC\" count\\n\",\n+\t       cgraph_inline_failed_string ((cgraph_inline_failed_t) i),\n+\t       (int) reason[i][2], (int) reason[i][1], reason[i][0]);\n+}\n+\n /* Decide on the inlining.  We do so in the topological order to avoid\n    expenses on updating data structures.  */\n \n@@ -2048,6 +2174,8 @@ ipa_inline (void)\n \t  flatten_function (node, false);\n \t}\n     }\n+  if (dump_file)\n+    dump_overall_stats ();\n \n   inline_small_functions ();\n \n@@ -2092,6 +2220,7 @@ ipa_inline (void)\n \t      if (edge->speculative && !speculation_useful_p (edge, false))\n \t\t{\n \t\t  cgraph_resolve_speculation (edge, NULL);\n+\t\t  spec_rem += edge->count;\n \t\t  update = true;\n \t\t  remove_functions = true;\n \t\t}\n@@ -2122,9 +2251,12 @@ ipa_inline (void)\n     ipa_free_all_structures_after_iinln ();\n \n   if (dump_file)\n-    fprintf (dump_file,\n-\t     \"\\nInlined %i calls, eliminated %i functions\\n\\n\",\n-\t     ncalls_inlined, nfunctions_inlined);\n+    {\n+      fprintf (dump_file,\n+\t       \"\\nInlined %i calls, eliminated %i functions\\n\\n\",\n+\t       ncalls_inlined, nfunctions_inlined);\n+      dump_inline_stats ();\n+    }\n \n   if (dump_file)\n     dump_inline_summaries (dump_file);"}]}