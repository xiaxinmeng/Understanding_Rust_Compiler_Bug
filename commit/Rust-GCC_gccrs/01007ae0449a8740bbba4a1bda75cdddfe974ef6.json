{"sha": "01007ae0449a8740bbba4a1bda75cdddfe974ef6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEwMDdhZTA0NDlhODc0MGJiYmE0YTFiZGE3NWNkZGRmZTk3NGVmNg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-04-14T09:46:02Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-04-14T09:46:02Z"}, "message": "reorg.c (fill_simple_delay_slots): Reindent block of code.\n\n\t* reorg.c (fill_simple_delay_slots): Reindent block of code.\n\t* resource.c (mark_target_live_regs): Reformat conditional block.\n\nFrom-SVN: r197949", "tree": {"sha": "dc7e865a0b0c6fd3bcb4edf42e3cbd395ddc724a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc7e865a0b0c6fd3bcb4edf42e3cbd395ddc724a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01007ae0449a8740bbba4a1bda75cdddfe974ef6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01007ae0449a8740bbba4a1bda75cdddfe974ef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01007ae0449a8740bbba4a1bda75cdddfe974ef6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01007ae0449a8740bbba4a1bda75cdddfe974ef6/comments", "author": null, "committer": null, "parents": [{"sha": "da98a6a1bb2cfa19c46ea6ee719bc5ddf647114c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da98a6a1bb2cfa19c46ea6ee719bc5ddf647114c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da98a6a1bb2cfa19c46ea6ee719bc5ddf647114c"}], "stats": {"total": 113, "additions": 58, "deletions": 55}, "files": [{"sha": "370ccbb507a381b7bcfb213c06092f97eb788ce5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01007ae0449a8740bbba4a1bda75cdddfe974ef6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01007ae0449a8740bbba4a1bda75cdddfe974ef6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01007ae0449a8740bbba4a1bda75cdddfe974ef6", "patch": "@@ -1,3 +1,8 @@\n+2013-04-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* reorg.c (fill_simple_delay_slots): Reindent block of code.\n+\t* resource.c (mark_target_live_regs): Reformat conditional block.\n+\n 2013-04-13  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* sched-deps.c (deps_analyze_insn): Do not check for EH_REGION insn"}, {"sha": "30efd79be8208541cb7bb0884b2692237d453285", "filename": "gcc/reorg.c", "status": "modified", "additions": 50, "deletions": 53, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01007ae0449a8740bbba4a1bda75cdddfe974ef6/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01007ae0449a8740bbba4a1bda75cdddfe974ef6/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=01007ae0449a8740bbba4a1bda75cdddfe974ef6", "patch": "@@ -2144,69 +2144,66 @@ fill_simple_delay_slots (int non_jumps_p)\n \t  if (CALL_P (insn))\n \t    maybe_never = 1;\n \n-\t    for (trial = next_nonnote_insn (insn); !stop_search_p (trial, 1);\n-\t\t trial = next_trial)\n-\t      {\n-\t\tnext_trial = next_nonnote_insn (trial);\n+\t  for (trial = next_nonnote_insn (insn); !stop_search_p (trial, 1);\n+\t       trial = next_trial)\n+\t    {\n+\t      next_trial = next_nonnote_insn (trial);\n \n-\t\t/* This must be an INSN or CALL_INSN.  */\n-\t\tpat = PATTERN (trial);\n+\t      /* This must be an INSN or CALL_INSN.  */\n+\t      pat = PATTERN (trial);\n \n-\t\t/* Stand-alone USE and CLOBBER are just for flow.  */\n-\t\tif (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n-\t\t  continue;\n+\t      /* Stand-alone USE and CLOBBER are just for flow.  */\n+\t      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n+\t\tcontinue;\n \n-\t\t/* If this already has filled delay slots, get the insn needing\n-\t\t   the delay slots.  */\n-\t\tif (GET_CODE (pat) == SEQUENCE)\n-\t\t  trial_delay = XVECEXP (pat, 0, 0);\n-\t\telse\n-\t\t  trial_delay = trial;\n-\n-\t\t/* Stop our search when seeing a jump.  */\n-\t\tif (JUMP_P (trial_delay))\n-\t\t  break;\n-\n-\t\t/* See if we have a resource problem before we try to\n-\t\t   split.  */\n-\t\tif (GET_CODE (pat) != SEQUENCE\n-\t\t    && ! insn_references_resource_p (trial, &set, true)\n-\t\t    && ! insn_sets_resource_p (trial, &set, true)\n-\t\t    && ! insn_sets_resource_p (trial, &needed, true)\n+\t      /* If this already has filled delay slots, get the insn needing\n+\t\t the delay slots.  */\n+\t      if (GET_CODE (pat) == SEQUENCE)\n+\t\ttrial_delay = XVECEXP (pat, 0, 0);\n+\t      else\n+\t\ttrial_delay = trial;\n+\n+\t      /* Stop our search when seeing a jump.  */\n+\t      if (JUMP_P (trial_delay))\n+\t\tbreak;\n+\n+\t      /* See if we have a resource problem before we try to split.  */\n+\t      if (GET_CODE (pat) != SEQUENCE\n+\t\t  && ! insn_references_resource_p (trial, &set, true)\n+\t\t  && ! insn_sets_resource_p (trial, &set, true)\n+\t\t  && ! insn_sets_resource_p (trial, &needed, true)\n #ifdef HAVE_cc0\n-\t\t    && ! (reg_mentioned_p (cc0_rtx, pat) && ! sets_cc0_p (pat))\n+\t\t  && ! (reg_mentioned_p (cc0_rtx, pat) && ! sets_cc0_p (pat))\n #endif\n-\t\t    && ! (maybe_never && may_trap_or_fault_p (pat))\n-\t\t    && (trial = try_split (pat, trial, 0))\n-\t\t    && eligible_for_delay (insn, slots_filled, trial, flags)\n-\t\t    && ! can_throw_internal(trial))\n-\t\t  {\n-\t\t    next_trial = next_nonnote_insn (trial);\n-\t\t    delay_list = add_to_delay_list (trial, delay_list);\n-\n+\t\t  && ! (maybe_never && may_trap_or_fault_p (pat))\n+\t\t  && (trial = try_split (pat, trial, 0))\n+\t\t  && eligible_for_delay (insn, slots_filled, trial, flags)\n+\t\t  && ! can_throw_internal(trial))\n+\t\t{\n+\t\t  next_trial = next_nonnote_insn (trial);\n+\t\t  delay_list = add_to_delay_list (trial, delay_list);\n #ifdef HAVE_cc0\n-\t\t    if (reg_mentioned_p (cc0_rtx, pat))\n-\t\t      link_cc0_insns (trial);\n+\t\t  if (reg_mentioned_p (cc0_rtx, pat))\n+\t\t    link_cc0_insns (trial);\n #endif\n+\t\t  delete_related_insns (trial);\n+\t\t  if (slots_to_fill == ++slots_filled)\n+\t\t    break;\n+\t\t  continue;\n+\t\t}\n \n-\t\t    delete_related_insns (trial);\n-\t\t    if (slots_to_fill == ++slots_filled)\n-\t\t      break;\n-\t\t    continue;\n-\t\t  }\n-\n-\t\tmark_set_resources (trial, &set, 0, MARK_SRC_DEST_CALL);\n-\t\tmark_referenced_resources (trial, &needed, true);\n+\t      mark_set_resources (trial, &set, 0, MARK_SRC_DEST_CALL);\n+\t      mark_referenced_resources (trial, &needed, true);\n \n-\t\t/* Ensure we don't put insns between the setting of cc and the\n-\t\t   comparison by moving a setting of cc into an earlier delay\n-\t\t   slot since these insns could clobber the condition code.  */\n-\t\tset.cc = 1;\n+\t      /* Ensure we don't put insns between the setting of cc and the\n+\t\t comparison by moving a setting of cc into an earlier delay\n+\t\t slot since these insns could clobber the condition code.  */\n+\t      set.cc = 1;\n \n-\t\t/* If this is a call, we might not get here.  */\n-\t\tif (CALL_P (trial_delay))\n-\t\t  maybe_never = 1;\n-\t      }\n+\t      /* If this is a call, we might not get here.  */\n+\t      if (CALL_P (trial_delay))\n+\t\tmaybe_never = 1;\n+\t    }\n \n \t  /* If there are slots left to fill and our search was stopped by an\n \t     unconditional branch, try the insn at the branch target.  We can"}, {"sha": "6051313732e4bb5278cb4eaf265a3a39fa0f3036", "filename": "gcc/resource.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01007ae0449a8740bbba4a1bda75cdddfe974ef6/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01007ae0449a8740bbba4a1bda75cdddfe974ef6/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=01007ae0449a8740bbba4a1bda75cdddfe974ef6", "patch": "@@ -990,9 +990,10 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \n \t  /* If this insn is a USE made by update_block, we care about the\n \t     underlying insn.  */\n-\t  if (code == INSN && GET_CODE (PATTERN (insn)) == USE\n+\t  if (code == INSN\n+\t      && GET_CODE (PATTERN (insn)) == USE\n \t      && INSN_P (XEXP (PATTERN (insn), 0)))\n-\t      real_insn = XEXP (PATTERN (insn), 0);\n+\t    real_insn = XEXP (PATTERN (insn), 0);\n \n \t  if (CALL_P (real_insn))\n \t    {"}]}