{"sha": "72f339d27372d36d1fcf7056db88fc10d824adb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJmMzM5ZDI3MzcyZDM2ZDFmY2Y3MDU2ZGI4OGZjMTBkODI0YWRiNg==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2003-04-10T18:24:42Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2003-04-10T18:24:42Z"}, "message": "[multiple changes]\n\n2003-03-16  Mohan Embar  <gnustuff@thisiscool.com>\n\n        * Make-lang.in: added win32-host.c\n        * jcf.h: defined macro JCF_OPEN_EXACT_CASE which\n        resolves to open() on non-Win32 platforms and\n        Win32-specific jcf_open_exact_case() on Win32\n        * jcf-io.c (find_class): use JCF_OPEN_EXACT_CASE\n        when trying .java and .class files\n        * win32-host.c: added to repository. Defines\n        Win32-specific jcf_open_exact_case()\n\n2003-04-10  Andrew Haley  <aph@redhat.com>\n\n        * jcf-write.c (struct jcf_partial): num_jsrs: new field.\n        (maybe_free_localvar): Renamed from localvar_free.\n        Add new arg, really.\n        (generate_bytecode_insns): Set new variable, jsrs.\n        Only free local vars if no jsr insns have been emittted.\n        Call maybe_free_localvar, not localvar_free.\n\nFrom-SVN: r65430", "tree": {"sha": "98f513bd1a000a4d78b65f788485eb0f3dd32eeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98f513bd1a000a4d78b65f788485eb0f3dd32eeb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72f339d27372d36d1fcf7056db88fc10d824adb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72f339d27372d36d1fcf7056db88fc10d824adb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72f339d27372d36d1fcf7056db88fc10d824adb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72f339d27372d36d1fcf7056db88fc10d824adb6/comments", "author": null, "committer": null, "parents": [{"sha": "1839841c90469b92929b3ce58fa74a8fd05039fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1839841c90469b92929b3ce58fa74a8fd05039fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1839841c90469b92929b3ce58fa74a8fd05039fc"}], "stats": {"total": 153, "additions": 143, "deletions": 10}, "files": [{"sha": "85a30a987e2ea172fc78c8a7d19e04f7b0be5afc", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72f339d27372d36d1fcf7056db88fc10d824adb6/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72f339d27372d36d1fcf7056db88fc10d824adb6/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=72f339d27372d36d1fcf7056db88fc10d824adb6", "patch": "@@ -1,3 +1,23 @@\n+2003-03-16  Mohan Embar  <gnustuff@thisiscool.com>\n+\n+\t* Make-lang.in: added win32-host.c\n+\t* jcf.h: defined macro JCF_OPEN_EXACT_CASE which\n+\tresolves to open() on non-Win32 platforms and\n+\tWin32-specific jcf_open_exact_case() on Win32\n+\t* jcf-io.c (find_class): use JCF_OPEN_EXACT_CASE\n+\twhen trying .java and .class files\n+\t* win32-host.c: added to repository. Defines\n+\tWin32-specific jcf_open_exact_case()\n+\n+2003-04-10  Andrew Haley  <aph@redhat.com>\n+\n+\t* jcf-write.c (struct jcf_partial): num_jsrs: new field.\n+\t(maybe_free_localvar): Renamed from localvar_free.\n+\tAdd new arg, really.\n+\t(generate_bytecode_insns): Set new variable, jsrs.\n+\tOnly free local vars if no jsr insns have been emittted.\n+\tCall maybe_free_localvar, not localvar_free.\n+\n 2003-03-30  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* gcj.texi: Remove @ at start of file."}, {"sha": "5d747142127dab1bbeb97adf8434ee81b42957d8", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72f339d27372d36d1fcf7056db88fc10d824adb6/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72f339d27372d36d1fcf7056db88fc10d824adb6/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=72f339d27372d36d1fcf7056db88fc10d824adb6", "patch": "@@ -334,6 +334,7 @@ java/resource.o: java/resource.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   $(TARGET_H) function.h gt-java-resource.h\n java/typeck.o: java/typeck.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h \\\n   java/convert.h toplev.h $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) real.h\n+java/win32-host.o: java/win32-host.c $(CONFIG_H) $(SYSTEM_H) java/jcf.h\n java/verify.o: java/verify.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h \\\n   java/javaop.h java/java-opcodes.h java/java-except.h toplev.h $(SYSTEM_H) \\\n   coretypes.h $(TM_H)"}, {"sha": "d673ec8c7cc346ee0d8cfd93301e959ed1165bf5", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72f339d27372d36d1fcf7056db88fc10d824adb6/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72f339d27372d36d1fcf7056db88fc10d824adb6/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=72f339d27372d36d1fcf7056db88fc10d824adb6", "patch": "@@ -544,7 +544,7 @@ find_class (const char *classname, int classname_length, JCF *jcf,\n \t\t\t      classname+classname_length-\n \t\t\t      (classname_length <= 30 ? \n \t\t\t       classname_length : 30)));\n-      fd = open (buffer, O_RDONLY | O_BINARY);\n+      fd = JCF_OPEN_EXACT_CASE (buffer, O_RDONLY | O_BINARY);\n       if (fd >= 0)\n \tgoto found;\n     }\n@@ -556,7 +556,7 @@ find_class (const char *classname, int classname_length, JCF *jcf,\n \t\t\t      classname+classname_length-\n \t\t\t      (classname_length <= 30 ? \n \t\t\t       classname_length : 30)));\n-      fd = open (buffer, O_RDONLY);\n+      fd = JCF_OPEN_EXACT_CASE (buffer, O_RDONLY);\n       if (fd >= 0)\n \t{\n \t  jcf->java_source = 1;"}, {"sha": "9c05a5ae831c3d1ff72b784bef21ea8c5f3aa25c", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72f339d27372d36d1fcf7056db88fc10d824adb6/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72f339d27372d36d1fcf7056db88fc10d824adb6/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=72f339d27372d36d1fcf7056db88fc10d824adb6", "patch": "@@ -279,6 +279,9 @@ struct jcf_partial\n \n   /* Information about the current switch statement. */\n   struct jcf_switch_state *sw_state;\n+\n+  /* The count of jsr instructions that have been emmitted.  */\n+  long num_jsrs;\n };\n \n static void generate_bytecode_insns (tree, int, struct jcf_partial *);\n@@ -293,7 +296,7 @@ static void define_jcf_label (struct jcf_block *, struct jcf_partial *);\n static struct jcf_block * get_jcf_label_here (struct jcf_partial *);\n static void put_linenumber (int, struct jcf_partial *);\n static void localvar_alloc (tree, struct jcf_partial *);\n-static void localvar_free (tree, struct jcf_partial *);\n+static void maybe_free_localvar (tree, struct jcf_partial *, int);\n static int get_access_flags (tree);\n static void write_chunks (FILE *, struct chunk *);\n static int adjust_typed_op (tree, int);\n@@ -601,7 +604,7 @@ localvar_alloc (tree decl, struct jcf_partial *state)\n }\n \n static void\n-localvar_free (tree decl, struct jcf_partial *state)\n+maybe_free_localvar (tree decl, struct jcf_partial *state, int really)\n {\n   struct jcf_block *end_label = get_jcf_label_here (state);\n   int index = DECL_LOCAL_INDEX (decl);\n@@ -613,6 +616,8 @@ localvar_free (tree decl, struct jcf_partial *state)\n \n   if (info->decl != decl)\n     abort ();\n+  if (! really)\n+    return;\n   ptr[0] = NULL;\n   if (wide)\n     {\n@@ -1066,6 +1071,7 @@ emit_jsr (struct jcf_block *target, struct jcf_partial *state)\n   OP1 (OPCODE_jsr);\n   /* Value is 1 byte from reloc back to start of instruction.  */\n   emit_reloc (RELOCATION_VALUE_1, OPCODE_jsr_w, target, state);\n+  state->num_jsrs++;\n }\n \n /* Generate code to evaluate EXP.  If the result is true,\n@@ -1347,7 +1353,7 @@ generate_bytecode_return (tree exp, struct jcf_partial *state)\n \t  emit_store (state->return_value_decl, state);\n \t  call_cleanups (NULL, state);\n \t  emit_load (state->return_value_decl, state);\n-\t  /* If we call localvar_free (state->return_value_decl, state),\n+\t  /* If we call maybe_free_localvar (state->return_value_decl, state, 1),\n \t     then we risk the save decl erroneously re-used in the\n \t     finalizer.  Instead, we keep the state->return_value_decl\n \t     allocated through the rest of the method.  This is not\n@@ -1384,6 +1390,7 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n \t{\n \t  tree local;\n \t  tree body = BLOCK_EXPR_BODY (exp);\n+\t  long jsrs = state->num_jsrs;\n \t  for (local = BLOCK_EXPR_DECLS (exp); local; )\n \t    {\n \t      tree next = TREE_CHAIN (local);\n@@ -1397,10 +1404,11 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n \t      body = TREE_OPERAND (body, 1);\n \t    }\n \t  generate_bytecode_insns (body, target, state);\n+\t  \n \t  for (local = BLOCK_EXPR_DECLS (exp); local; )\n \t    {\n \t      tree next = TREE_CHAIN (local);\n-\t      localvar_free (local, state);\n+\t      maybe_free_localvar (local, state, state->num_jsrs <= jsrs);\n \t      local = next;\n \t    }\n \t}\n@@ -2354,8 +2362,8 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n \tif (CAN_COMPLETE_NORMALLY (finally))\n \t  {\n \t    maybe_wide (OPCODE_ret, DECL_LOCAL_INDEX (return_link), state);\n-\t    localvar_free (exception_decl, state);\n-\t    localvar_free (return_link, state);\n+\t    maybe_free_localvar (exception_decl, state, 1);\n+\t    maybe_free_localvar (return_link, state, 1);\n \t    define_jcf_label (finished_label, state);\n \t  }\n       }\n@@ -2960,6 +2968,7 @@ generate_classfile (tree clas, struct jcf_partial *state)\n \t  get_jcf_label_here (state);  /* Force a first block. */\n \t  for (t = DECL_ARGUMENTS (part);  t != NULL_TREE;  t = TREE_CHAIN (t))\n \t    localvar_alloc (t, state);\n+\t  state->num_jsrs = 0;\n \t  generate_bytecode_insns (body, IGNORE_TARGET, state);\n \t  if (CAN_COMPLETE_NORMALLY (body))\n \t    {\n@@ -2969,9 +2978,9 @@ generate_classfile (tree clas, struct jcf_partial *state)\n \t      OP1 (OPCODE_return);\n \t    }\n \t  for (t = DECL_ARGUMENTS (part);  t != NULL_TREE;  t = TREE_CHAIN (t))\n-\t    localvar_free (t, state);\n+\t    maybe_free_localvar (t, state, 1);\n \t  if (state->return_value_decl != NULL_TREE)\n-\t    localvar_free (state->return_value_decl, state);\n+\t    maybe_free_localvar (state->return_value_decl, state, 1);\n \t  finish_jcf_block (state);\n \t  perform_relocations (state);\n "}, {"sha": "5a28735c061b090fecb26bc208fe47220fc79972", "filename": "gcc/java/jcf.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72f339d27372d36d1fcf7056db88fc10d824adb6/gcc%2Fjava%2Fjcf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72f339d27372d36d1fcf7056db88fc10d824adb6/gcc%2Fjava%2Fjcf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf.h?ref=72f339d27372d36d1fcf7056db88fc10d824adb6", "patch": "@@ -63,6 +63,24 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #define COMPARE_FILENAMES(X, Y) strcmp ((X), (Y))\n #endif\n \n+/* On case-insensitive file systems, we need to ensure that a request\n+   to open a .java or .class file is honored only if the file to be\n+   opened is of the exact case we are asking for. In other words, we\n+   want to override the inherent case insensitivity of the underlying\n+   file system. On other platforms, this macro becomes the vanilla\n+   open() call.\n+\n+   If you want to add another host, add your define to the list below\n+   (i.e. defined(WIN32) || defined(YOUR_HOST)) and add an host-specific\n+   .c file to Make-lang.in similar to win32-host.c  */\n+#if defined(WIN32)\n+extern int\n+jcf_open_exact_case (const char* filename, int oflag);\n+#define JCF_OPEN_EXACT_CASE(X, Y) jcf_open_exact_case (X, Y)\n+#else\n+#define JCF_OPEN_EXACT_CASE open\n+#endif /* WIN32 */\n+\n struct JCF;\n typedef int (*jcf_filbuf_t) PARAMS ((struct JCF*, int needed));\n "}, {"sha": "7ab8fa53f96265b9a889b68cfefcc16933363d17", "filename": "gcc/java/win32-host.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72f339d27372d36d1fcf7056db88fc10d824adb6/gcc%2Fjava%2Fwin32-host.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72f339d27372d36d1fcf7056db88fc10d824adb6/gcc%2Fjava%2Fwin32-host.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fwin32-host.c?ref=72f339d27372d36d1fcf7056db88fc10d824adb6", "patch": "@@ -0,0 +1,85 @@\n+/* Platform-Specific Win32 Functions\n+   Copyright (C) 2003  Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Written by Mohan Embar <gnustuff@thisiscool.com>, March 2003. */\n+\n+#ifdef WIN32\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+\n+#include \"jcf.h\"\n+\n+#define WIN32_LEAN_AND_MEAN\n+#include <windows.h>\n+#undef WIN32_LEAN_AND_MEAN\n+\n+/* Simulate an open() failure with ENOENT */\n+static int\n+file_not_found (void);\n+\n+static int\n+file_not_found (void)\n+{\n+  errno = ENOENT;\n+  return -1;\n+}\n+\n+int\n+jcf_open_exact_case (const char *filename, int oflag)\n+{\n+  int filename_len = strlen (filename);\n+  int found_file_len;\n+  HANDLE found_file_handle;\n+  WIN32_FIND_DATA fd;\n+  \n+  /* See if we can find this file. */\n+  found_file_handle = FindFirstFile (filename, &fd);\n+  if (found_file_handle == INVALID_HANDLE_VALUE)\n+    return file_not_found ();\n+  FindClose (found_file_handle);\n+\n+  found_file_len = strlen (fd.cFileName);\n+  \n+  /* This should never happen. */\n+  if (found_file_len > filename_len)\n+    return file_not_found ();\n+  \n+  /* Here, we're only actually comparing the filename and not\n+     checking the case of any containing directory components.\n+     Although we're not fully obeying our contract, checking\n+     all directory components would be tedious and time-consuming\n+     and it's a pretty safe assumption that mixed-case package\n+     names are a fringe case.... */\n+  if (strcmp (filename + filename_len - found_file_len, fd.cFileName))\n+    {\n+      /* Reject this because it is not a perfect-case match. */\n+      /* printf(\"************\\nRejected:\\n%s\\n%s\\n************\\n\\n\", filename, fd.cFileName); */\n+      return file_not_found ();\n+    }\n+  else\n+    {\n+      return open (filename, oflag);\n+    }\n+}\n+\n+#endif /* WIN32 */"}]}