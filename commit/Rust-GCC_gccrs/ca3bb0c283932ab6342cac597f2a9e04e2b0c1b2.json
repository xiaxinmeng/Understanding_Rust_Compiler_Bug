{"sha": "ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EzYmIwYzI4MzkzMmFiNjM0MmNhYzU5N2YyYTllMDRlMmIwYzFiMg==", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@redhat.com", "date": "2004-01-22T09:54:19Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2004-01-22T09:54:19Z"}, "message": "2004-01-22  Graydon Hoare  <graydon@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GdkClasspathFontPeer.java:\n\t* gnu/java/awt/peer/gtk/GdkGlyphVector.java:\n\tPredicate static initialization on GtkToolkit.useGraphics2D().\n\t* java/awt/Component.java (processPaintEvent): Consume event.\n\t* javax/swing/AbstractButton.java: Reimplement, document.\n\t* javax/swing/DefaultButtonModel.java: Reimplement, document.\n\t* javax/swing/JComponent.java (paint): Use double buffer.\n\t(listenerList): Enable member.\n\t* javax/swing/ToggleButtonModel.java: Remove incorrect constructor.\n\t* javax/swing/JToggleButton.java\n\t(JToggleButton): Modify model constructor.\n\t* javax/swing/SwingUtilities.java\n\t(layoutCompoundLabel): Adjust arithmetic.\n\t* javax/swing/plaf/basic/BasicButtonUI.java: Reimplement, document.\n\t* javax/swing/plaf/basic/BasicGraphicsUtils.java\n\t(getPreferredButtonSize): Include margins in calculation.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c\n\t(Java_gnu_java_awt_peer_gtk_GtkWindowPeer_connectSignals):\n\tReceive up events from subordinate layout component.\n\nFrom-SVN: r76344", "tree": {"sha": "0f7e79b1c6afb9ecf4b3d15908999b740f7cd2ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f7e79b1c6afb9ecf4b3d15908999b740f7cd2ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/comments", "author": null, "committer": null, "parents": [{"sha": "1fd05073984ebdf3e087613adce163587b33e1e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fd05073984ebdf3e087613adce163587b33e1e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fd05073984ebdf3e087613adce163587b33e1e5"}], "stats": {"total": 2752, "additions": 2150, "deletions": 602}, "files": [{"sha": "6f307f1fe6efdcf25ce45c31caf5a65a4d795847", "filename": "libjava/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2", "patch": "@@ -1,3 +1,25 @@\n+2004-01-22  Graydon Hoare  <graydon@redhat.com>\n+\t\n+\t* gnu/java/awt/peer/gtk/GdkClasspathFontPeer.java: \n+\t* gnu/java/awt/peer/gtk/GdkGlyphVector.java:\n+\tPredicate static initialization on GtkToolkit.useGraphics2D().\n+\t* java/awt/Component.java (processPaintEvent): Consume event.\n+\t* javax/swing/AbstractButton.java: Reimplement, document.\n+\t* javax/swing/DefaultButtonModel.java: Reimplement, document.\n+\t* javax/swing/JComponent.java (paint): Use double buffer.\n+\t(listenerList): Enable member.\n+\t* javax/swing/ToggleButtonModel.java: Remove incorrect constructor.\n+\t* javax/swing/JToggleButton.java \n+\t(JToggleButton): Modify model constructor.\n+\t* javax/swing/SwingUtilities.java \n+\t(layoutCompoundLabel): Adjust arithmetic.\n+\t* javax/swing/plaf/basic/BasicButtonUI.java: Reimplement, document.\n+\t* javax/swing/plaf/basic/BasicGraphicsUtils.java \n+\t(getPreferredButtonSize): Include margins in calculation.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c\n+\t(Java_gnu_java_awt_peer_gtk_GtkWindowPeer_connectSignals):\n+\tReceive up events from subordinate layout component.\n+\n 2004-01-21  Thomas Fitzsimmons  <fitzsim@redhat.com>\n \n \t* java/awt/Component.java (show): Set visible to true before"}, {"sha": "8f96e15ab548ab1df2150c0e8362d1c3435e669a", "filename": "libjava/gnu/java/awt/peer/gtk/GdkClasspathFontPeer.java", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkClasspathFontPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkClasspathFontPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkClasspathFontPeer.java?ref=ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2", "patch": "@@ -70,6 +70,8 @@ public class GdkClasspathFontPeer extends ClasspathFontPeer\n       {\n         System.loadLibrary(\"gtkpeer\");\n       }\n+\n+    if (GtkToolkit.useGraphics2D ())\n     initStaticState ();\n   }\n   native static void initStaticState ();"}, {"sha": "076a90e7b158ca82947a088d5203a8e315851c49", "filename": "libjava/gnu/java/awt/peer/gtk/GdkGlyphVector.java", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGlyphVector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGlyphVector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGlyphVector.java?ref=ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2", "patch": "@@ -60,6 +60,8 @@ public class GdkGlyphVector extends GlyphVector\n       {\n         System.loadLibrary(\"gtkpeer\");\n       }\n+\n+    if (GtkToolkit.useGraphics2D ())\n     initStaticState ();\n   }\n   native static void initStaticState ();"}, {"sha": "b440c510df86c2e422000f3f5195d969d991923c", "filename": "libjava/java/awt/Component.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjava%2Fawt%2FComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjava%2Fawt%2FComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FComponent.java?ref=ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2", "patch": "@@ -4252,6 +4252,7 @@ private void processPaintEvent(PaintEvent event)\n \t  default:\n \t    throw new IllegalArgumentException(\"unknown paint event\");\n \t  }\n+\tevent.consume ();\n       }\n     finally\n       {"}, {"sha": "e9751fa78d6682bdf08632cae62288fa6cca68c1", "filename": "libjava/javax/swing/AbstractButton.java", "status": "modified", "additions": 1421, "deletions": 421, "changes": 1842, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjavax%2Fswing%2FAbstractButton.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjavax%2Fswing%2FAbstractButton.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FAbstractButton.java?ref=ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2", "patch": "@@ -1,5 +1,5 @@\n /* AbstractButton.java -- Provides basic button functionality.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,9 +35,10 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n+import java.awt.AWTEvent;\n+import java.awt.AWTEventMulticaster;\n import java.awt.Graphics;\n import java.awt.Image;\n import java.awt.Insets;\n@@ -51,751 +52,1750 @@\n import java.awt.event.ItemEvent;\n import java.awt.event.ItemListener;\n import java.awt.event.MouseEvent;\n+import java.beans.PropertyChangeEvent;\n import java.beans.PropertyChangeListener;\n+import java.io.Serializable;\n+import java.util.Vector;\n+import java.util.EventListener;\n import javax.accessibility.AccessibleAction;\n import javax.accessibility.AccessibleIcon;\n-import javax.accessibility.AccessibleStateSet;\n import javax.accessibility.AccessibleRelationSet;\n+import javax.accessibility.AccessibleStateSet;\n import javax.accessibility.AccessibleText;\n import javax.accessibility.AccessibleValue;\n import javax.swing.event.ChangeEvent;\n import javax.swing.event.ChangeListener;\n import javax.swing.plaf.ButtonUI;\n import javax.swing.text.AttributeSet;\n \n+\n /**\n- * Provides basic button functionality\n+ * <p>The purpose of this class is to serve as a facade over a number of\n+ * classes which collectively represent the semantics of a button: the\n+ * button's model, its listeners, its action, and its look and feel. Some\n+ * parts of a button's state are stored explicitly in this class, other\n+ * parts are delegates to the model. Some methods related to buttons are\n+ * implemented in this class, other methods pass through to the current \n+ * model or look and feel.</p>\n+ *\n+ * <p>Furthermore this class is supposed to serve as a base class for\n+ * several kinds of buttons with similar but non-identical semantics:\n+ * toggle buttons (radio buttons and checkboxes), simple \"push\" buttons,\n+ * menu items.</p>\n+ *\n+ * <p>Buttons have many properties, some of which are stored in this class\n+ * while others are delegated to the button's model. The following properties\n+ * are available:</p>\n+ *\n+ * <table>\n+ * <tr><th>Property               </th><th>Stored in</th><th>Bound?</th></tr>\n+ *\n+ * <tr><td>action                 </td><td>button</td> <td>no</td></tr>\n+ * <tr><td>actionCommand          </td><td>model</td>  <td>no</td></tr>\n+ * <tr><td>borderPainted          </td><td>button</td> <td>yes</td></tr>\n+ * <tr><td>contentAreaFilled      </td><td>button</td> <td>yes</td></tr>\n+ * <tr><td>disabledIcon           </td><td>button</td> <td>yes</td></tr>\n+ * <tr><td>disabledSelectedIcon   </td><td>button</td> <td>yes</td></tr>\n+ * <tr><td>displayedMnemonicIndex </td><td>button</td> <td>no</td></tr>\n+ * <tr><td>enabled                </td><td>model</td>  <td>no</td></tr>\n+ * <tr><td>focusPainted           </td><td>button</td> <td>yes</td></tr>\n+ * <tr><td>horizontalAlignment    </td><td>button</td> <td>yes</td></tr>\n+ * <tr><td>horizontalTextPosition </td><td>button</td> <td>yes</td></tr>\n+ * <tr><td>icon                   </td><td>button</td> <td>yes</td></tr>\n+ * <tr><td>iconTextGap            </td><td>button</td> <td>no</td></tr>\n+ * <tr><td>label (same as text)   </td><td>model</td>  <td>yes</td></tr>\n+ * <tr><td>margin                 </td><td>button</td> <td>yes</td></tr>\n+ * <tr><td>multiClickThreshold    </td><td>button</td> <td>no</td></tr>\n+ * <tr><td>pressedIcon            </td><td>button</td> <td>yes</td></tr>\n+ * <tr><td>rolloverEnabled        </td><td>button</td> <td>yes</td></tr>\n+ * <tr><td>rolloverIcon           </td><td>button</td> <td>yes</td></tr>\n+ * <tr><td>rolloverSelectedIcon   </td><td>button</td> <td>yes</td></tr>\n+ * <tr><td>selected               </td><td>model</td>  <td>no</td></tr>\n+ * <tr><td>selectedIcon           </td><td>button</td> <td>yes</td></tr>\n+ * <tr><td>selectedObjects        </td><td>button</td> <td>no</td></tr>\n+ * <tr><td>text                   </td><td>model</td>  <td>yes</td></tr>\n+ * <tr><td>UI                     </td><td>button</td> <td>yes</td></tr>\n+ * <tr><td>verticalAlignment      </td><td>button</td> <td>yes</td></tr>\n+ * <tr><td>verticalTextPosition   </td><td>button</td> <td>yes</td></tr>\n+ *\n+ * </table>\n+ *\n+ * <p>The various behavioral aspects of these properties follows:</p>\n+ *\n+ * <ul> \n+ *\n+ * <li>When non-bound properties stored in the button change, the button\n+ * fires ChangeEvents to its ChangeListeners.</li>\n+ * \n+ * <li>When bound properties stored in the button change, the button fires\n+ * PropertyChangeEvents to its PropertyChangeListeners</li>\n  *\n- * @author Ronald Veldema (rveldema@cs.vu.nl)\n+ * <li>If any of the model's properties change, it fires a ChangeEvent to\n+ * its ChangeListeners, which include the button.</li>\n+ *\n+ * <li>If the button receives a ChangeEvent from its model, it will\n+ * propagate the ChangeEvent to its ChangeListeners, with the ChangeEvent's\n+ * \"source\" property set to refer to the button, rather than the model. The\n+ * the button will request a repaint, to paint its updated state.</li>\n+ *\n+ * <li>If the model's \"selected\" property changes, the model will fire an\n+ * ItemEvent to its ItemListeners, which include the button, in addition to\n+ * the ChangeEvent which models the property change. The button propagates\n+ * ItemEvents directly to its ItemListeners.</li>\n+ *\n+ * <li>If the model's armed and pressed properties are simultaneously\n+ * <code>true</code>, the model will fire an ActionEvent to its\n+ * ActionListeners, which include the button. The button will propagate\n+ * this ActionEvent to its ActionListeners, with the ActionEvent's \"source\"\n+ * property set to refer to the button, rather than the model.</li>\n+ *\n+ * </ul>\n+ *\n+ * @author Ronald Veldema (rveldema&064;cs.vu.nl)\n+ * @author Graydon Hoare (graydon&064;redhat.com)\n  */\n+\n public abstract class AbstractButton extends JComponent\n   implements ItemSelectable, SwingConstants\n {\n-  Icon default_icon, pressed_button, disabled_button,\n-    selected_button, disabled_selected_button, current_icon;\n+  /** The icon displayed by default. */\n+  Icon default_icon;\n+\n+  /** The icon displayed when the button is pressed. */\n+  Icon pressed_icon;\n+\n+  /** The icon displayed when the button is disabled. */\n+  Icon disabled_icon;\n+\n+  /** The icon displayed when the button is selected. */\n+  Icon selected_icon;\n+\n+  /** The icon displayed when the button is selected but disabled. */\n+  Icon disabled_selected_icon;\n+\n+  /** The icon displayed when the button is rolled over. */\n+  Icon rollover_icon;\n+\n+  /** The icon displayed when the button is selected and rolled over. */\n+  Icon rollover_selected_icon;\n+\n+  /** The icon currently displayed. */\n+  Icon current_icon;\n+\n+  /** The text displayed in the button. */\n   String text;\n \n+  /** The vertical alignment of the button's text and icon. */\n   int vert_align = CENTER;\n+\n+  /** The horizontal alignment of the button's text and icon. */\n   int hori_align = CENTER;\n+\n+  /** The horizontal position of the button's text relative to its icon. */\n   int hori_text_pos = CENTER;\n+\n+  /** The vertical position of the button's text relative to its icon. */\n   int vert_text_pos = CENTER;\n \n-  boolean paint_border = true, paint_focus;\n-  Action action_taken;\n+  /** Whether or not the button paints its border. */\n+  boolean paint_border = true;\n+\n+  /** Whether or not the button paints its focus state. */\n+  boolean paint_focus;\n+\n+  /** Whether or not the button fills its content area. */\n+  boolean content_area_filled;\n+\n+  /** The action taken when the button is clicked. */\n+  Action action;\n+\n+  /** The button's current state. */\n   ButtonModel model;\n+\n+  /** The margin between the button's border and its label. */\n   Insets margin;\n \n-  public static final String FOCUS_PAINTED_CHANGED_PROPERTY = \"focusPainted\";\n+  /** a hint to the look and feel class, suggesting which character in the\n+   * button's label should be underlined when drawing the label. */\n+  int mnemonicIndex;\n \n-  /**\n-   * AccessibleAbstractButton\n-   */\n-  protected abstract class AccessibleAbstractButton \n-    extends AccessibleJComponent \n-    implements AccessibleAction, AccessibleValue, AccessibleText {\n+  /** Listener the button uses to receive ActionEvents from its model.  */\n+  ActionListener actionListener;\n \n-    /**\n-     * Constructor AccessibleAbstractButton\n-     * @param component TODO\n-     */\n-    protected AccessibleAbstractButton(AbstractButton component) {\n-      super(component);\n-      // TODO\n-    } // AccessibleAbstractButton()\n+  /** Listener the button uses to receive ItemEvents from its model.  */\n+  ItemListener itemListener;\n+\n+  /** Listener the button uses to receive ChangeEvents from its model.  */  \n+  ChangeListener changeListener;\n+\n+  /** Listener the button uses to receive PropertyChangeEvents from its\n+      Action. */\n+  PropertyChangeListener actionPropertyChangeListener;\n+  \n+  /** Fired in a PropertyChangeEvent when the \"borderPainted\" property changes. */\n+  public static String BORDER_PAINTED_CHANGED_PROPERTY = \"borderPainted\";\n+  \n+  /** Fired in a PropertyChangeEvent when the \"contentAreaFilled\" property changes. */\n+  public static String CONTENT_AREA_FILLED_CHANGED_PROPERTY = \"contentAreaFilled\";\n+  \n+  /** Fired in a PropertyChangeEvent when the \"disabledIcon\" property changes. */\n+  public static String DISABLED_ICON_CHANGED_PROPERTY = \"disabledIcon\";\n+  \n+  /** Fired in a PropertyChangeEvent when the \"disabledSelectedIcon\" property changes. */\n+  public static String DISABLED_SELECTED_ICON_CHANGED_PROPERTY = \"disabledSelectedIcon\";\n+  \n+  /** Fired in a PropertyChangeEvent when the \"focusPainted\" property changes. */\n+  public static String FOCUS_PAINTED_CHANGED_PROPERTY = \"focusPainted\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"horizontalAlignment\" property changes. */\n+  public static String HORIZONTAL_ALIGNMENT_CHANGED_PROPERTY = \"horizontalAlignment\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"horizontalTextPosition\" property changes. */\n+  public static String HORIZONTAL_TEXT_POSITION_CHANGED_PROPERTY = \"horizontalTextPosition\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"icon\" property changes. */\n+  public static String ICON_CHANGED_PROPERTY = \"icon\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"margin\" property changes. */\n+  public static String MARGIN_CHANGED_PROPERTY = \"margin\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"mnemonic\" property changes. */\n+  public static String MNEMONIC_CHANGED_PROPERTY = \"mnemonic\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"model\" property changes. */\n+  public static String MODEL_CHANGED_PROPERTY = \"model\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"pressedIcon\" property changes. */\n+  public static String PRESSED_ICON_CHANGED_PROPERTY = \"pressedIcon\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"rolloverEnabled\" property changes. */\n+  public static String ROLLOVER_ENABLED_CHANGED_PROPERTY = \"rolloverEnabled\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"rolloverIcon\" property changes. */\n+  public static String ROLLOVER_ICON_CHANGED_PROPERTY = \"rolloverIcon\";\n+  \n+  /** Fired in a PropertyChangeEvent when the \"rolloverSelectedIcon\" property changes. */\n+  public static String ROLLOVER_SELECTED_ICON_CHANGED_PROPERTY = \"rolloverSelectedIcon\";\n+  \n+  /** Fired in a PropertyChangeEvent when the \"selectedIcon\" property changes. */\n+  public static String SELECTED_ICON_CHANGED_PROPERTY = \"selectedIcon\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"text\" property changes. */\n+  public static String TEXT_CHANGED_PROPERTY = \"text\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"verticalAlignment\" property changes. */\n+  public static String VERTICAL_ALIGNMENT_CHANGED_PROPERTY = \"verticalAlignment\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"verticalTextPosition\" property changes. */\n+  public static String VERTICAL_TEXT_POSITION_CHANGED_PROPERTY = \"verticalTextPosition\";\n \n     /**\n-     * getAccessibleStateSet\n-     * @returns AccessibleStateSet\n+   * A Java Accessibility extension of the AbstractButton.\n      */\n-    public AccessibleStateSet getAccessibleStateSet() {\n+  protected abstract class AccessibleAbstractButton\n+    extends AccessibleJComponent implements AccessibleAction, AccessibleValue,\n+                                            AccessibleText\n+  {\n+    protected AccessibleAbstractButton(JComponent c)\n+    {\n+      super(c);\n+    }\n+\n+    public AccessibleStateSet getAccessibleStateSet()\n+    {\n       return null; // TODO\n-    } // getAccessibleStateSet()\n+    }\n \n-    /**\n-     * getAccessibleName\n-     * @returns String\n-     */\n-    public String getAccessibleName() {\n+    public String getAccessibleName()\n+    {\n       return null; // TODO\n-    } // getAccessibleName()\n+    }\n \n-    /**\n-     * getAccessibleIcon\n-     * @returns AccessibleIcon[]\n-     */\n-    public AccessibleIcon[] getAccessibleIcon() {\n+    public AccessibleIcon[] getAccessibleIcon()\n+    {\n       return null; // TODO\n-    } // getAccessibleIcon()\n+    }\n \n-    /**\n-     * getAccessibleRelationSet\n-     * @returns AccessibleRelationSet\n-     */\n-    public AccessibleRelationSet getAccessibleRelationSet() {\n+    public AccessibleRelationSet getAccessibleRelationSet()\n+    {\n       return null; // TODO\n-    } // getAccessibleRelationSet()\n+    }\n \n-    /**\n-     * getAccessibleAction\n-     * @returns AccessibleAction\n-     */\n-    public AccessibleAction getAccessibleAction() {\n+    public AccessibleAction getAccessibleAction()\n+    {\n       return null; // TODO\n-    } // getAccessibleAction()\n+    }\n \n-    /**\n-     * getAccessibleValue\n-     * @returns AccessibleValue\n-     */\n-    public AccessibleValue getAccessibleValue() {\n+    public AccessibleValue getAccessibleValue()\n+    {\n       return null; // TODO\n-    } // getAccessibleValue()\n+    }\n \n-    /**\n-     * getAccessibleActionCount\n-     * @returns int\n-     */\n-    public int getAccessibleActionCount() {\n+    public int getAccessibleActionCount()\n+    {\n       return 0; // TODO\n-    } // getAccessibleActionCount()\n+    }\n \n-    /**\n-     * getAccessibleActionDescription\n-     * @param value0 TODO\n-     * @returns String\n-     */\n-    public String getAccessibleActionDescription(int value0) {\n+    public String getAccessibleActionDescription(int value0)\n+    {\n       return null; // TODO\n-    } // getAccessibleActionDescription()\n+    }\n \n-    /**\n-     * doAccessibleAction\n-     * @param value0 TODO\n-     * @returns boolean\n-     */\n-    public boolean doAccessibleAction(int value0) {\n+    public boolean doAccessibleAction(int value0)\n+    {\n       return false; // TODO\n-    } // doAccessibleAction()\n+    }\n \n-    /**\n-     * getCurrentAccessibleValue\n-     * @returns Number\n-     */\n-    public Number getCurrentAccessibleValue() {\n+    public Number getCurrentAccessibleValue()\n+    {\n       return null; // TODO\n-    } // getCurrentAccessibleValue()\n+    }\n \n-    /**\n-     * setCurrentAccessibleValue\n-     * @param value0 TODO\n-     * @returns boolean\n-     */\n-    public boolean setCurrentAccessibleValue(Number value0) {\n+    public boolean setCurrentAccessibleValue(Number value0)\n+    {\n       return false; // TODO\n-    } // setCurrentAccessibleValue()\n+    }\n \n-    /**\n-     * getMinimumAccessibleValue\n-     * @returns Number\n-     */\n-    public Number getMinimumAccessibleValue() {\n+    public Number getMinimumAccessibleValue()\n+    {\n       return null; // TODO\n-    } // getMinimumAccessibleValue()\n+    }\n \n-    /**\n-     * getMaximumAccessibleValue\n-     * @returns Number\n-     */\n-    public Number getMaximumAccessibleValue() {\n+    public Number getMaximumAccessibleValue()\n+    {\n       return null; // TODO\n-    } // getMaximumAccessibleValue()\n+    }\n \n-    /**\n-     * getAccessibleText\n-     * @returns AccessibleText\n-     */\n-    public AccessibleText getAccessibleText() {\n+    public AccessibleText getAccessibleText()\n+    {\n       return null; // TODO\n-    } // getAccessibleText()\n+    }\n \n-    /**\n-     * getIndexAtPoint\n-     * @param value0 TODO\n-     * @returns int\n-     */\n-    public int getIndexAtPoint(Point value0) {\n+    public int getIndexAtPoint(Point value0)\n+    {\n       return 0; // TODO\n-    } // getIndexAtPoint()\n+    }\n \n-    /**\n-     * getCharacterBounds\n-     * @param value0 TODO\n-     * @returns Rectangle\n-     */\n-    public Rectangle getCharacterBounds(int value0) {\n+    public Rectangle getCharacterBounds(int value0)\n+    {\n       return null; // TODO\n-    } // getCharacterBounds()\n+    }\n \n-    /**\n-     * getCharCount\n-     * @returns int\n-     */\n-    public int getCharCount() {\n+    public int getCharCount()\n+    {\n       return 0; // TODO\n-    } // getCharCount()\n+    }\n \n-    /**\n-     * getCaretPosition\n-     * @returns int\n-     */\n-    public int getCaretPosition() {\n+    public int getCaretPosition()\n+    {\n       return 0; // TODO\n-    } // getCaretPosition()\n+    }\n \n-    /**\n-     * getAtIndex\n-     * @param value0 TODO\n-     * @param value1 TODO\n-     * @returns String\n-     */\n-    public String getAtIndex(int value0, int value1) {\n+    public String getAtIndex(int value0, int value1)\n+    {\n       return null; // TODO\n-    } // getAtIndex()\n+    }\n \n-    /**\n-     * getAfterIndex\n-     * @param value0 TODO\n-     * @param value1 TODO\n-     * @returns String\n-     */\n-    public String getAfterIndex(int value0, int value1) {\n+    public String getAfterIndex(int value0, int value1)\n+    {\n       return null; // TODO\n-    } // getAfterIndex()\n+    }\n \n-    /**\n-     * getBeforeIndex\n-     * @param value0 TODO\n-     * @param value1 TODO\n-     * @returns String\n-     */\n-    public String getBeforeIndex(int value0, int value1) {\n+    public String getBeforeIndex(int value0, int value1)\n+    {\n       return null; // TODO\n-    } // getBeforeIndex()\n+    }\n \n-    /**\n-     * getCharacterAttribute\n-     * @param value0 TODO\n-     * @returns AttributeSet\n-     */\n-    public AttributeSet getCharacterAttribute(int value0) {\n+    public AttributeSet getCharacterAttribute(int value0)\n+    {\n       return null; // TODO\n-    } // getCharacterAttribute()\n+    }\n \n-    /**\n-     * getSelectionStart\n-     * @returns int\n-     */\n-    public int getSelectionStart() {\n+    public int getSelectionStart()\n+    {\n       return 0; // TODO\n-    } // getSelectionStart()\n+    }\n \n-    /**\n-     * getSelectionEnd\n-     * @returns int\n-     */\n-    public int getSelectionEnd() {\n+    public int getSelectionEnd()\n+    {\n       return 0; // TODO\n-    } // getSelectionEnd()\n-\n-    /**\n-     * getSelectedText\n-     * @returns String\n-     */\n-    public String getSelectedText() {\n-      return null; // TODO\n-    } // getSelectedText()\n-\n-    /**\n-     * getTextRectangle\n-     * @returns Rectangle\n-     */\n-    private Rectangle getTextRectangle() {\n-      return null; // TODO\n-    } // getTextRectangle()\n-\n-\n-  } // AccessibleAbstractButton\n-\n+    }\n \n-  static private class JFocusListener implements FocusListener\n+    public String getSelectedText()\n   {\n-    AbstractButton c;\n+      return null; // TODO\n+    }\n \n-    JFocusListener(AbstractButton c)\n+    private Rectangle getTextRectangle()\n     {\n-      this.c = c;\n+      return null; // TODO\n+    }\n     }\n \n-    public void focusLost(FocusEvent event)\n+  /**\n+   * Helper class used to subscribe to FocusEvents received by the button.\n+   */\n+  private class ButtonFocusListener implements FocusListener\n     {\n-      c.getModel().setArmed(false);\n-\n-      System.out.println(\"LOST FOCUS\");\n-      if (c.isFocusPainted())\n+    /**\n+     * Possibly repaint the model in response to loss of focus.\n+     *\n+     * @param event The loss-of-focus event\n+     */\n+    public void focusLost(FocusEvent event)\n         {\n-          c.repaint();\n-        }\n+      if (AbstractButton.this.isFocusPainted())\n+        AbstractButton.this.repaint();\n     }\n+\n+    /**\n+     * Possibly repaint the button in response to acquisition of focus.\n+     *\n+     * @param event The gained-focus event\n+     */\n     public void focusGained(FocusEvent event)\n     {\n-      System.out.println(\"GAIN FOCUS\");\n+      if (AbstractButton.this.isFocusPainted())\n+        AbstractButton.this.repaint();\n     }\n   }\n \n+  /**\n+   * Creates a new AbstractButton object.\n+   */\n   AbstractButton()\n   {\n     this(\"\",null);\n   }\n \n-  AbstractButton(String text,\n-                 Icon icon)\n+  /**\n+   * Creates a new AbstractButton object.\n+   *\n+   * @param txt Value to use for the button's \"text\" property\n+   * @param icon Value to use for the button's \"defaultIcon\" property\n+   */\n+  AbstractButton(String txt, Icon icon)\n   {\n-    this.text    = text;\n-    setIcon(icon);\n+    text = txt;\n+    default_icon = icon;\n+    model = new DefaultButtonModel();\n+    actionListener = createActionListener();\n+    changeListener = createChangeListener();\n+    itemListener = createItemListener();\n+\n+    model.addActionListener(actionListener);\n+    model.addChangeListener(changeListener);\n+    model.addItemListener(itemListener);\n \n     setAlignmentX(LEFT_ALIGNMENT);\n     setAlignmentY(CENTER_ALIGNMENT);\n-\n-    addFocusListener( new JFocusListener(this) );\n-\n-    setModel(new DefaultButtonModel(this));\n-\n-    updateUI(); // get a proper ui\n+    addFocusListener(new ButtonFocusListener());\n+    updateUI();\n   }\n \n+  /**\n+   * Get the model the button is currently using.\n+   *\n+   * @return The current model\n+   */\n   public ButtonModel getModel()\n-  {\treturn model;    }\n+  {\n+    return model;\n+  }\n \n+  /**\n+   * Set the model the button is currently using. This un-registers all \n+   * listeners associated with the current model, and re-registers them\n+   * with the new model.\n+   *\n+   * @param newModel The new model\n+   */\n   public void setModel(ButtonModel newModel)\n-  {\tmodel = newModel;    }\n+  {\n+    if (newModel == model)\n+      return;\n \n+    if (model != null)\n+      {\n+        model.removeActionListener(actionListener);\n+        model.removeChangeListener(changeListener);\n+        model.removeItemListener(itemListener);\n+      }\n+    ButtonModel old = model;\n+    model = newModel;\n+    if (model != null)\n+      {\n+        model.addActionListener(actionListener);\n+        model.addChangeListener(changeListener);\n+        model.addItemListener(itemListener);\n+      }\n+    firePropertyChange(MODEL_CHANGED_PROPERTY, old, model);\n+    revalidate();\n+    repaint();\n+  }\n+\n+  /**\n+   * Get the action command string for this button's model.\n+   *\n+   * @return The current action command string from the button's model\n+   */\n   public String getActionCommand()\n-  {\treturn getModel().getActionCommand();    }\n+  {\n+    return getModel().getActionCommand();\n+  }\n \n+  /**\n+   * Set the action command string for this button's model.\n+   *\n+   * @param aCommand The new action command string to set in the button's\n+   * model.\n+   */\n   public void setActionCommand(String aCommand)\n-  {   getModel().setActionCommand(aCommand);   }\n+  {\n+    getModel().setActionCommand(aCommand);\n+  }\n \n+  /**\n+   * Adds an ActionListener to the button's listener list. When the\n+   * button's model is clicked it fires an ActionEvent, and these\n+   * listeners will be called.\n+   *\n+   * @param l The new listener to add\n+   */\n   public void addActionListener(ActionListener l)\n-  {\tgetModel().addActionListener(l);    }\n+  {\n+    listenerList.add(ActionListener.class, l);\n+  }\n \n+  /**\n+   * Removes an ActionListener from the button's listener list.\n+   *\n+   * @param l The listener to remove\n+   */\n   public void removeActionListener(ActionListener l)\n-  {\tgetModel().removeActionListener(l);    }\n+  {\n+    listenerList.remove(ActionListener.class, l);\n+  }\n \n+  /**\n+   * Adds an ItemListener to the button's listener list. When the button's\n+   * model changes state (between any of ARMED, ENABLED, PRESSED, ROLLOVER\n+   * or SELECTED) it fires an ItemEvent, and these listeners will be\n+   * called.\n+   *\n+   * @param l The new listener to add\n+   */\n+  public void addItemListener(ItemListener l)\n+  {\n+    listenerList.add(ItemListener.class, l);\n+  }\n+\n+  /**\n+   * Removes an ItemListener from the button's listener list.\n+   *\n+   * @param l The listener to remove\n+   */\n+  public void removeItemListener(ItemListener l)\n+  {\n+    listenerList.remove(ItemListener.class, l);\n+  }\n+\n+  /**\n+   * Adds a ChangeListener to the button's listener list. When the button's\n+   * model changes any of its (non-bound) properties, these listeners will be\n+   * called. \n+   *\n+   * @param l The new listener to add\n+   */\n   public void addChangeListener(ChangeListener l)\n-  {   getModel().addChangeListener(l);     }\n+  {\n+    listenerList.add(ChangeListener.class, l);\n+  }\n \n+  /**\n+   * Removes a ChangeListener from the button's listener list.\n+   *\n+   * @param l The listener to remove\n+   */\n   public void removeChangeListener(ChangeListener l)\n-  {  getModel().removeChangeListener(l);    }\n+  {\n+    listenerList.remove(ChangeListener.class, l);\n+  }\n \n-  public void addItemListener(ItemListener l)\n-  {  getModel().addItemListener(l);    }\n+  /**\n+   * Calls {@link ItemListener.itemStateChanged} on each ItemListener in\n+   * the button's listener list.\n+   *\n+   * @param e The event signifying that the button's model changed state\n+   */\n+  public void fireItemStateChanged(ItemEvent e)\n+  {\n+    EventListener[] ll = listenerList.getListeners(ItemListener.class);\n+    for (int i = 0; i < ll.length; i++)\n+      ((ItemListener)ll[i]).itemStateChanged(e);\n+  }\n \n-  public void removeItemListener(ItemListener l)\n-  {  getModel().removeItemListener(l);  }\n+  /**\n+   * Calls {@link ActionListener.actionPerformed} on each {@link\n+   * ActionListener} in the button's listener list.\n+   *\n+   * @param e The event signifying that the button's model was clicked\n+   */\n+  public void fireActionPerformed(ActionEvent e)\n+  {\n+    EventListener[] ll = listenerList.getListeners(ActionListener.class);\n+    for (int i = 0; i < ll.length; i++)\n+      ((ActionListener)ll[i]).actionPerformed(e);\n+  }\n \n-  public int getHorizontalAlignment()\n-  {\treturn hori_align;    }\n+  /**\n+   * Calls {@link ChangeEvent.stateChanged} on each {@link ChangeListener}\n+   * in the button's listener list.\n+   *\n+   * @param e The event signifying a change in one of the (non-bound)\n+   * properties of the button's model.\n+   */\n+  public void fireStateChanged(ChangeEvent e)\n+  {\n+    EventListener[] ll = listenerList.getListeners(ChangeListener.class);\n+    for (int i = 0; i < ll.length; i++)\n+      ((ChangeListener)ll[i]).stateChanged(e);\n+  }\n \n-  public int getHorizontalTextPosition()\n-  {\treturn hori_text_pos;    }\n+  /**\n+   * Get the current keyboard mnemonic value. This value corresponds to a\n+   * single key code (one of the {@link java.awt.event.KeyEvent} VK_*\n+   * codes) and is used to activate the button when pressed in conjunction\n+   * with the \"mouseless modifier\" of the button's look and feel class, and\n+   * when focus is in one of the button's ancestors.\n+   *\n+   * @return The button's current keyboard mnemonic\n+   */\n+  public int getMnemonic()\n+  {\n+    return getModel().getMnemonic();\n+  }\n \n-  public int getVerticalAlignment()\n-  {\treturn vert_align;   }\n+  /**\n+   * Set the current keyboard mnemonic value. This value corresponds to a\n+   * single key code (one of the {@link java.awt.event.KeyEvent} VK_*\n+   * codes) and is used to activate the button when pressed in conjunction\n+   * with the \"mouseless modifier\" of the button's look and feel class, and\n+   * when focus is in one of the button's ancestors.\n+   *\n+   * @param mne A new mnemonic to use for the button\n+   */\n+  public void setMnemonic(char mne)\n+  {\n+    int old = getModel().getMnemonic();\n+    getModel().setMnemonic(mne);\n+    if (old != getModel().getMnemonic())\n+      {\n+        firePropertyChange(MNEMONIC_CHANGED_PROPERTY, old, (int) mne);        \n+        revalidate();\n+        repaint();\n+      }\n+  }\n \n-  public int getVerticalTextPosition()\n-  {\treturn vert_text_pos;  }\n+  /**\n+   * Set the current keyboard mnemonic value. This value corresponds to a\n+   * single key code (one of the {@link java.awt.event.KeyEvent} VK_*\n+   * codes) and is used to activate the button when pressed in conjunction\n+   * with the \"mouseless modifier\" of the button's look and feel class, and\n+   * when focus is in one of the button's ancestors.\n+   *\n+   * @param mne A new mnemonic to use for the button\n+   */\n+  public void setMnemonic(int mne)\n+  {\n+    int old = mne;\n+    getModel().setMnemonic(mne);\n+    if (old != getModel().getMnemonic())\n+      {\n+        firePropertyChange(MNEMONIC_CHANGED_PROPERTY, old, mne);\n+        revalidate();\n+        repaint();\n+      }\n+  }\n+\n+  /** \n+   * Sets the button's mnemonic index. The mnemonic index is a hint to the\n+   * look and feel class, suggesting which character in the button's label\n+   * should be underlined when drawing the label. If the mnemonic index is\n+   * -1, no mnemonic will be displayed. \n+   * \n+   * If no mnemonic index is set, the button will choose a mnemonic index\n+   * by default, which will be the first occurrence of the mnemonic\n+   * character in the button's text.\n+   *\n+   * @param index An offset into the \"text\" property of the button\n+   * @throws IllegalArgumentException If <code>index</code> is not within the\n+   * range of legal offsets for the \"text\" property of the button.\n+   * @since 1.4\n+   */\n \n-  protected  void fireItemStateChanged(ItemEvent event)\n+  public void setDisplayedMnemonicIndex(int index)\n   {\n+    if (index < -1 || index >= text.length())\n+      throw new IllegalArgumentException();\n+    else\n+      mnemonicIndex = index;\n   }\n   \n-  protected  void fireStateChanged(ChangeEvent event)\n+  /** \n+   * Get the button's mnemonic index, which is an offset into the button's\n+   * \"text\" property.  The character specified by this offset should be\n+   * underlined when the look and feel class draws this button.\n+   *\n+   * @return An index into the button's \"text\" property\n+   */\n+  public int getDisplayedMnemonicIndex(int index)\n   {\n+    return mnemonicIndex;\n   }\n   \n-  protected void fireActionPerformed(ActionEvent event)\n+\n+  /**\n+   * Set the \"rolloverEnabled\" property. When rollover is enabled, and the\n+   * look and feel supports it, the button will change its icon to\n+   * rollover_icon, when the mouse passes over it.\n+   *\n+   * @param r Whether or not to enable rollover icon changes\n+   */\n+  public void setRolloverEnabled(boolean r)\n+  {\n+    boolean old = getModel().isRollover();\n+    getModel().setRollover(r);\n+    if (old != getModel().isRollover())\n   {\n+        firePropertyChange(ROLLOVER_ENABLED_CHANGED_PROPERTY, old, r);\n+        revalidate();\n+        repaint();\n+      }\n   }\n \n-  public void setVerticalAlignment(int alignment)\n-  {\tvert_align = alignment;    }\n+  /**\n+   * Returns whether or not rollover icon changes are enabled on the\n+   * button.\n+   *\n+   * @return The state of the \"rolloverEnabled\" property\n+   */\n+  public boolean isRolloverEnabled()\n+  {\n+    return getModel().isRollover();\n+  }\n \n-  public void setHorizontalAlignment(int alignment)\n-  {   hori_align = alignment;   }\n+  /**\n+   * Set the value of the button's \"selected\" property. Selection is only\n+   * meaningful for toggle-type buttons (check boxes, radio buttons).\n+   *\n+   * @param s New value for the property\n+   */\n+  public void setSelected(boolean s)\n+  {\n+    getModel().setSelected(s);\n+  }\n \n-  public void setVerticalTextPosition(int textPosition)\n-  {\tvert_text_pos = textPosition;    }\n+  /**\n+   * Get the value of the button's \"selected\" property. Selection is only\n+   * meaningful for toggle-type buttons (check boxes, radio buttons).\n+   *\n+   * @return The value of the property\n+   */\n+  public boolean isSelected()\n+  {\n+    return getModel().isSelected();\n+  }\n \n-  public void setHorizontalTextPosition(int textPosition)\n-  {   hori_text_pos = textPosition;   }\n+  /**\n+   * Enables or disables the button. A button will neither be selectable\n+   * nor preform any actions unless it is enabled.\n+   *\n+   * @param b Whether or not to enable the button\n+   */\n+  public void setEnabled(boolean b)\n+  {\n+    super.setEnabled(b);\n+    getModel().setEnabled(b);\n+  }\n \n-  public int getMnemonic()\n-  {\treturn getModel().getMnemonic();    }\n+  /** \n+   * Set the horizontal alignment of the button's text and icon. The\n+   * alignment is a numeric constant from {@link SwingConstants}. It must\n+   * be one of: <code>RIGHT</code>, <code>LEFT</code>, <code>CENTER</code>,\n+   * <code>LEADING</code> or <code>TRAILING</code>.  The default is\n+   * <code>RIGHT</code>.\n+   * \n+   * @return The current horizontal alignment\n+   */\n+  public int getHorizontalAlignment()\n+  {\n+    return hori_align;\n+  }\n \n-  public void setMnemonic(char mne)\n-  {\tgetModel().setMnemonic(mne);    }\n+  /**\n+   * Set the horizontal alignment of the button's text and icon. The\n+   * alignment is a numeric constant from {@link SwingConstants}. It must\n+   * be one of: <code>RIGHT</code>, <code>LEFT</code>, <code>CENTER</code>,\n+   * <code>LEADING</code> or <code>TRAILING</code>.  The default is\n+   * <code>RIGHT</code>.\n+   *\n+   * @param a The new horizontal alignment\n+   * @throws IllegalArgumentException If alignment is not one of the legal\n+   * constants.\n+   */\n+  public void setHorizontalAlignment(int a)\n+  {\n+    int old = hori_align;\n+    hori_align = a;\n+    if (old != a)\n+      {\n+        firePropertyChange(HORIZONTAL_ALIGNMENT_CHANGED_PROPERTY, old, a);\n+        revalidate();\n+        repaint();\n+      }\n+  }\n \n-  public void setMnemonic(int mne)\n-  {\tgetModel().setMnemonic(mne);    }\n+  /**\n+   * Get the horizontal position of the button's text relative to its\n+   * icon. The position is a numeric constant from {@link\n+   * SwingConstants}. It must be one of: <code>RIGHT</code>,\n+   * <code>LEFT</code>, <code>CENTER</code>, <code>LEADING</code> or\n+   * <code>TRAILING</code>.  The default is <code>TRAILING</code>.\n+   *\n+   * @return The current horizontal text position\n+   */\n+  public int getHorizontalTextPosition()\n+  {\n+    return hori_text_pos;\n+  }\n+\n+  /**\n+   * Set the horizontal position of the button's text relative to its\n+   * icon. The position is a numeric constant from {@link\n+   * SwingConstants}. It must be one of: <code>RIGHT</code>,\n+   * <code>LEFT</code>, <code>CENTER</code>, <code>LEADING</code> or\n+   * <code>TRAILING</code>. The default is <code>TRAILING</code>.\n+   *\n+   * @param t The new horizontal text position\n+   * @throws IllegalArgumentException If position is not one of the legal\n+   * constants.\n+   */\n+  public void setHorizontalTextPosition(int t)\n+  {\n+    int old = hori_text_pos;\n+    hori_text_pos = t;\n+    if (old != t)\n+      {\n+        firePropertyChange(HORIZONTAL_TEXT_POSITION_CHANGED_PROPERTY, old, t);\n+        revalidate();\n+        repaint();\n+      }\n+  }\n+\n+  /**\n+   * Get the vertical alignment of the button's text and icon. The\n+   * alignment is a numeric constant from {@link SwingConstants}. It must\n+   * be one of: <code>CENTER</code>, <code>TOP</code>, or\n+   * <code>BOTTOM</code>. The default is <code>CENTER</code>.\n+   *\n+   * @return The current vertical alignment\n+   */\n+  public int getVerticalAlignment()\n+  {\n+    return vert_align;\n+  }\n+\n+  /**\n+   * Set the vertical alignment of the button's text and icon. The\n+   * alignment is a numeric constant from {@link SwingConstants}. It must\n+   * be one of: <code>CENTER</code>, <code>TOP</code>, or\n+   * <code>BOTTOM</code>. The default is <code>CENTER</code>.\n+   *\n+   * @param a The new vertical alignment\n+   * @throws IllegalArgumentException If alignment is not one of the legal\n+   * constants.\n+   */\n+  public void setVerticalAlignment(int a)\n+  {\n+    int old = vert_align;\n+    vert_align = a;\n+    if (old != a)\n+      {\n+        firePropertyChange(VERTICAL_ALIGNMENT_CHANGED_PROPERTY, old, a);\n+        revalidate();\n+        repaint();\n+      }\n+  }\n \n-  public void setRolloverEnabled(boolean b)\n-  {    getModel().setRollover(b);    }\n+  /**\n+   * Get the vertical position of the button's text relative to its\n+   * icon. The alignment is a numeric constant from {@link\n+   * SwingConstants}. It must be one of: <code>CENTER</code>,\n+   * <code>TOP</code>, or <code>BOTTOM</code>. The default is\n+   * <code>CENTER</code>.\n+   *\n+   * @return The current vertical position\n+   */\n+  public int getVerticalTextPosition()\n+  {\n+    return vert_text_pos;\n+  }\n \n-  public boolean isRolloverEnabled()\n-  {    return getModel().isRollover();     }\n+  /**\n+   * Set the vertical position of the button's text relative to its\n+   * icon. The alignment is a numeric constant from {@link\n+   * SwingConstants}. It must be one of: <code>CENTER</code>,\n+   * <code>TOP</code>, or <code>BOTTOM</code>. The default is\n+   * <code>CENTER</code>.\n+   *\n+   * @param t The new vertical position\n+   * @throws IllegalArgumentException If position is not one of the legal\n+   * constants.\n+   */\n+  public void setVerticalTextPosition(int t)\n+  {\n+    int old = vert_text_pos;\n+    vert_text_pos = t;\n+    if (old != t)\n+      {\n+        firePropertyChange(VERTICAL_TEXT_POSITION_CHANGED_PROPERTY, old, t);\n+        revalidate();\n+        repaint();\n+      }\n+  }\n \n+  /**\n+   * Set the value of the \"borderPainted\" property. If set to\n+   * <code>false</code>, the button's look and feel class should not paint\n+   * a border for the button. The default is <code>true</code>.\n+   *\n+   * @return The current value of the property.\n+   */\n   public boolean isBorderPainted()\n-  {\treturn paint_border;    }\n+  {\n+    return paint_border;\n+  }\n \n+  /**\n+   * Set the value of the \"borderPainted\" property. If set to\n+   * <code>false</code>, the button's look and feel class should not paint\n+   * a border for the button. The default is <code>true</code>.\n+   *\n+   * @param b The new value of the property.\n+   */\n   public void setBorderPainted(boolean b)\n   {\n-    if (b != paint_border)\n-      {\n+    boolean old = paint_border;\n         paint_border = b;\n+    if (b != old)\n+      {\n+        firePropertyChange(BORDER_PAINTED_CHANGED_PROPERTY, old, b);\n         revalidate();\n         repaint();\n       }\n   }\n \n+  /**\n+   * Get the value of the \"action\" property. \n+   *\n+   * @return The current value of the \"action\" property\n+   */\n   public Action getAction()\n-  {\treturn action_taken;    }\n+  {\n+    return action;\n+  }\n \n+  /**\n+   * <p>Set the button's \"action\" property, subscribing the new action to the\n+   * button, as an ActionListener, if it is not already subscribed. The old\n+   * Action, if it exists, is unsubscribed, and the button is unsubscribed\n+   * from the old Action if it was previously subscribed as a\n+   * PropertyChangeListener.</p>\n+   *\n+   * <p>This method also configures several of the button's properties from\n+   * the Action, by calling {@link configurePropertiesFromAction}, and\n+   * subscribes the button to the Action as a PropertyChangeListener.\n+   * Subsequent changes to the Action will thus reconfigure the button \n+   * automatically.</p>\n+   *\n+   * @param a The new value of the \"action\" property\n+   */\n   public void setAction(Action a)\n   {\n-    action_taken = a;\n-    revalidate();\n-    repaint();\n+    if (action != null)\n+      {\n+        action.removePropertyChangeListener(actionPropertyChangeListener);\n+        removeActionListener(action);\n+        if (actionPropertyChangeListener != null)\n+          {\n+            action.removePropertyChangeListener(actionPropertyChangeListener);\n+            actionPropertyChangeListener = null;\n+          }\n+        actionPropertyChangeListener = createActionPropertyChangeListener(a);\n   }\n \n-  public void setSelected(boolean b)\n-  {\tgetModel().setSelected(b);    }\n+    Action old = action;\n+    action = a;\n+    configurePropertiesFromAction(action);\n \n-  public boolean isSelected()\n-  {\treturn getModel().isSelected();     }\n+    if (action != null)\n+      {\n+        action.addPropertyChangeListener(actionPropertyChangeListener);\n+        addActionListener(action);\n+      }\n+  }\n \n+  /**\n+   * Return the button's default \"icon\" property.\n+   *\n+   * @return The current default icon\n+   */\n   public Icon getIcon()\n-  {\treturn default_icon;    }\n-\n-  public void setIcon(Icon defaultIcon)\n   {\n-    if (default_icon == defaultIcon)\n-      return;\n+    return default_icon;\n+  }\n \n-    default_icon = defaultIcon;\n-    if (default_icon != null)\n+  /**\n+   * Set the button's default \"icon\" property. This icon is used as a basis\n+   * for the pressed and disabled icons, if none are explicitly set.\n+   *\n+   * @param i The new default icon\n+   */\n+  public void setIcon(Icon i)\n       {\n-        // XXX FIXME - icons do not know their parent\n-        //  \t\t\tdefault_icon.setParent(this);\n-      }\n+    Icon old = default_icon;\n+    default_icon = i;\n+    if (old != i)\n+      {\n+        firePropertyChange(ICON_CHANGED_PROPERTY, old, i);\n     revalidate();\n     repaint();\n   }\n+  }\n \n+  /**\n+   * Return the button's \"text\" property. This property is synonymous with\n+   * the \"label\" property.\n+   *\n+   * @return The current \"text\" property\n+   */\n   public String getText()\n-  {\treturn text;    }\n+  {\n+    return text;\n+  }\n \n+  /**\n+   * Set the button's \"label\" property. This property is synonymous with the\n+   * \"text\" property.\n+   *\n+   * @param label The new \"label\" property\n+   */\n   public void setLabel(String label)\n-  {\tsetText(label);    }\n+  {\n+    setText(label);\n+  }\n \n+  /**\n+   * Return the button's \"label\" property. This property is synonymous with\n+   * the \"text\" property.\n+   *\n+   * @return The current \"label\" property\n+   */\n   public String getLabel()\n-  {\treturn getText();    }\n+  {\n+    return getText();\n+  }\n \n-  public void setText(String text)\n+  /**\n+   * Set the button's \"text\" property. This property is synonymous with the\n+   * \"label\" property.\n+   *\n+   * @param t The new \"text\" property\n+   */\n+  public void setText(String t)\n   {\n-    this.text = text;\n+    String old = text;\n+    text = t;\n+    if (t != old)\n+      {\n+        firePropertyChange(TEXT_CHANGED_PROPERTY, old, t);\n     revalidate();\n     repaint();\n   }\n+  }\n \n+  /**\n+   * Return the button's \"margin\" property, which is an {@link Insets} object\n+   * describing the distance between the button's border and its text and\n+   * icon.\n+   *\n+   * @return The current \"margin\" property\n+   */\n   public \tInsets getMargin()\n-  {      return margin; }\n+  {\n+    return margin;\n+  }\n \n+  /**\n+   * Set the button's \"margin\" property, which is an {@link Insets} object\n+   * describing the distance between the button's border and its text and\n+   * icon.\n+   *\n+   * @param m The new \"margin\" property\n+   */\n   public void setMargin(Insets m)\n   {\n+    Insets old = margin;\n     margin = m;\n-    revalidate();\n+    if (m != old)\n+      {\n+        firePropertyChange(MARGIN_CHANGED_PROPERTY, old, m);\n+        revalidate();\n     repaint();\n   }\n-\n-  public void setEnabled(boolean b)\n-  {\n-    super.setEnabled(b);\n-    getModel().setEnabled(b);\n-    repaint();\n   }\n \n+  /**\n+   * Return the button's \"pressedIcon\" property. The look and feel class\n+   * should paint this icon when the \"pressed\" property of the button's\n+   * {@link ButtonModel} is <code>true</code>. This property may be\n+   * <code>null</code>, in which case the default icon is used.\n+   *\n+   * @return The current \"pressedIcon\" property\n+   */\n   public Icon getPressedIcon()\n-  {\treturn pressed_button;    }\n+  {\n+    return pressed_icon;\n+  }\n \n+  /**\n+   * Set the button's \"pressedIcon\" property. The look and feel class\n+   * should paint this icon when the \"pressed\" property of the button's\n+   * {@link ButtonModel} is <code>true</code>. This property may be\n+   * <code>null</code>, in which case the default icon is used.\n+   *\n+   * @param pressedIcon The new \"pressedIcon\" property\n+   */\n   public void setPressedIcon(Icon pressedIcon)\n   {\n-    pressed_button = pressedIcon;\n+    Icon old = pressed_icon;\n+    pressed_icon = pressedIcon;\n+    if (pressed_icon != old)\n+      {\n+        firePropertyChange(PRESSED_ICON_CHANGED_PROPERTY, old, pressed_icon);\n     revalidate();\n     repaint();\n   }\n+  }\n \n+  /**\n+   * Return the button's \"disabledIcon\" property. The look and feel class\n+   * should paint this icon when the \"enabled\" property of the button's\n+   * {@link ButtonModel} is <code>false</code>. This property may be\n+   * <code>null</code>, in which case an icon is constructed, based on the\n+   * default icon.\n+   *\n+   * @return The current \"disabledIcon\" property\n+   */\n   public Icon getDisabledIcon()\n-  {\treturn disabled_button;    }\n+  {\n+    return disabled_icon;\n+  }\n \n+  /**\n+   * Set the button's \"disabledIcon\" property. The look and feel class should\n+   * paint this icon when the \"enabled\" property of the button's {@link\n+   * ButtonModel} is <code>false</code>. This property may be\n+   * <code>null</code>, in which case an icon is constructed, based on the\n+   * default icon.\n+   *\n+   * @param disabledIcon The new \"disabledIcon\" property\n+   */\n   public void setDisabledIcon(Icon disabledIcon)\n   {\n-    disabled_button = disabledIcon;\n+    disabled_icon = disabledIcon;\n     revalidate();\n     repaint();\n   }\n \n+  /**\n+   * Return the button's \"paintFocus\" property. This property controls\n+   * whether or not the look and feel class will paint a special indicator\n+   * of focus state for the button. If it is false, the button still paints\n+   * when focused, but no special decoration is painted to indicate the\n+   * presence of focus.\n+   *\n+   * @return The current \"paintFocus\" property\n+   */\n   public boolean isFocusPainted()\n-  {   return paint_focus;   }\n+  {\n+    return paint_focus;\n+  }\n \n+  /**\n+   * Set the button's \"paintFocus\" property. This property controls whether\n+   * or not the look and feel class will paint a special indicator of focus\n+   * state for the button. If it is false, the button still paints when\n+   * focused, but no special decoration is painted to indicate the presence\n+   * of focus.\n+   *\n+   * @param b The new \"paintFocus\" property\n+   */\n   public void setFocusPainted(boolean b)\n   {\n     boolean old = paint_focus;\n     paint_focus = b;\n \n-    firePropertyChange(FOCUS_PAINTED_CHANGED_PROPERTY,\n-                       old,\n-                       b);\n-    if (hasFocus())\n+    if (old != b)\n       {\n+        firePropertyChange(FOCUS_PAINTED_CHANGED_PROPERTY, old, b);\n         revalidate();\n         repaint();\n       }\n   }\n \n+  /**\n+   * Return the button's \"focusTraversable\" property. This property controls\n+   * whether or not the button can receive focus when the user attempts to\n+   * traverse the focus hierarchy.\n+   *\n+   * @return The current \"focusTraversable\" property\n+   */\n   public boolean isFocusTraversable()\n   {\n-    //Identifies whether or not this component can receive the focus.\n     return true;\n   }\n \n-\n+  /**\n+   * Verifies that a particular key is one of the valid constants used for\n+   * describing horizontal alignment and positioning. The valid constants\n+   * are the following members of {@link SwingConstants}:\n+   * <code>RIGHT</code>, <code>LEFT</code>, <code>CENTER</code>,\n+   * <code>LEADING</code> or <code>TRAILING</code>.\n+   *\n+   * @param key The key to check\n+   * @param exception A message to include in an IllegalArgumentException\n+   *\n+   * @return the value of key\n+   *\n+   * @throws IllegalArgumentException If key is not one of the valid constants\n+   *\n+   * @see setHorizontalTextPosition()\n+   * @see setHorizontalAlignment()\n+   */\n   protected  int checkHorizontalKey(int key, String exception)\n   {\n-    //       Verify that key is a legal value for the horizontalAlignment properties.\n-    return 0;\n+    switch (key)\n+      {\n+      case SwingConstants.RIGHT:\n+      case SwingConstants.LEFT:\n+      case SwingConstants.CENTER:\n+      case SwingConstants.LEADING:\n+      case SwingConstants.TRAILING:\n+        break;\n+      default:\n+        throw new IllegalArgumentException(exception);\n+      }\n+    return key;\n   }\n \n+  /**\n+   * Verifies that a particular key is one of the valid constants used for\n+   * describing vertical alignment and positioning. The valid constants are\n+   * the following members of {@link SwingConstants}: <code>TOP</code>,\n+   * <code>BOTTOM</code> or <code>CENTER</code>.\n+   *\n+   * @param key The key to check\n+   * @param exception A message to include in an IllegalArgumentException\n+   *\n+   * @return the value of key\n+   *\n+   * @throws IllegalArgumentException If key is not one of the valid constants\n+   *\n+   * @see setVerticalTextPosition()\n+   * @see setVerticalAlignment()\n+   */\n   protected  int checkVerticalKey(int key, String exception)\n   {\n-    //       Ensures that the key is a valid.\n-    return 0;\n+    switch (key)\n+      {\n+      case SwingConstants.TOP:\n+      case SwingConstants.BOTTOM:\n+      case SwingConstants.CENTER:\n+        break;\n+      default:\n+        throw new IllegalArgumentException(exception);\n+      }\n+    return key;\n   }\n \n+  /**\n+   * Configure various properties of the button by reading properties\n+   * of an {@link Action}. The mapping of properties is as follows:\n+   *\n+   * <table>\n+   *\n+   * <tr><th>Action keyed property</th> <th>AbstractButton property</th></tr>\n+   *\n+   * <tr><td>NAME                 </td> <td>text                   </td></tr>\n+   * <tr><td>SMALL_ICON           </td> <td>icon                   </td></tr>\n+   * <tr><td>SHORT_DESCRIPTION    </td> <td>toolTipText            </td></tr>\n+   * <tr><td>MNEMONIC_KEY         </td> <td>mnemonic               </td></tr>\n+   * <tr><td>ACTION_COMMAND_KEY   </td> <td>actionCommand          </td></tr>\n+   *\n+   * </table>\n+   *\n+   * <p>In addition, this method always sets the button's \"enabled\" property to\n+   * the value of the Action's \"enabled\" property.</p>\n+   *\n+   * <p>If the provided Action is <code>null</code>, the text, icon, and\n+   * toolTipText properties of the button are set to <code>null</code>, and\n+   * the \"enabled\" property is set to <code>true</code>; the mnemonic and\n+   * actionCommand properties are unchanged.</p>\n+   *\n+   * @param a An Action to configure the button from\n+   */\n   protected  void configurePropertiesFromAction(Action a)\n   {\n-    //Factory method which sets the ActionEvent source's properties according to values from the Action instance.\n+    if (a == null)\n+      {\n+        setText(null);\n+        setIcon(null);\n+        setEnabled(true);\n+        setToolTipText(null);\n+      }\n+    else\n+      {\n+        setText((String)(a.getValue(Action.NAME)));\n+        setIcon((Icon)(a.getValue(Action.SMALL_ICON)));\n+        setEnabled(a.isEnabled());\n+        setToolTipText((String)(a.getValue(Action.SHORT_DESCRIPTION)));\n+        setMnemonic(((Integer)(a.getValue(Action.MNEMONIC_KEY))).intValue());\n+        setActionCommand((String)(a.getValue(Action.ACTION_COMMAND_KEY)));\n+      }\n   }\n \n+  /**\n+   * <p>A factory method which should return an {@link ActionListener} that\n+   * propagates events from the button's {@link ButtonModel} to any of the\n+   * button's ActionListeners. By default, this is an inner class which\n+   * calls {@link AbstractButton.fireActionPerformed} with a modified copy\n+   * of the incoming model {@link ActionEvent}.</p>\n+   *\n+   * <p>The button calls this method during construction, stores the\n+   * resulting ActionListener in its <code>actionListener</code> member\n+   * field, and subscribes it to the button's model. If the button's model\n+   * is changed, this listener is unsubscribed from the old model and\n+   * subscribed to the new one.</p>\n+   *\n+   * @return A new ActionListener \n+   */\n   protected  ActionListener createActionListener()\n   {\n     return new ActionListener()\n       {\n-        public void actionPerformed(ActionEvent e) { }\n+        public void actionPerformed(ActionEvent e)\n+        {\n+          e.setSource(AbstractButton.this);\n+          AbstractButton.this.fireActionPerformed(e);\n+        }\n       };\n   }\n \n+  /**\n+   * <p>A factory method which should return a {@link PropertyChangeListener}\n+   * that accepts changes to the specified {@link Action} and reconfigure\n+   * the {@link AbstractButton}, by default using the {@link\n+   * configurePropertiesFromAction} method.</p>\n+   *\n+   * <p>The button calls this method whenever a new Action is assigned to\n+   * the button's \"action\" property, via {@link setAction}, and stores the\n+   * resulting PropertyChangeListener in its\n+   * <code>actionPropertyChangeListener</code> member field. The button\n+   * then subscribes the listener to the button's new action. If the\n+   * button's action is changed subsequently, the listener is unsubscribed\n+   * from the old action and subscribed to the new one.</p>\n+   *\n+   * @param a The Action which will be listened to, and which should be \n+   * the same as the source of any PropertyChangeEvents received by the\n+   * new listener returned from this method.\n+   *\n+   * @return A new PropertyChangeListener\n+   */\n   protected  PropertyChangeListener createActionPropertyChangeListener(Action a)\n   {\n-    //Factory method which creates the PropertyChangeListener used to update the ActionEvent source as properties change on its Action instance.\n-    return null;\n+    return new PropertyChangeListener()\n+      {\n+        public void propertyChange(PropertyChangeEvent e)\n+        {\n+          Action act = (Action)(e.getSource());\n+          AbstractButton.this.configurePropertiesFromAction(act);\n+        }\n+      };\n   }\n \n+  /**\n+   * <p>Factory method which creates a {@link ChangeListener}, used to\n+   * subscribe to ChangeEvents from the button's model. Subclasses of\n+   * AbstractButton may wish to override the listener used to subscribe to\n+   * such ChangeEvents. By default, the listener just propagates the\n+   * {@link ChangeEvent} to the button's ChangeListeners, via the {@link\n+   * AbstractButton.fireStateChanged} method.</p>\n+   *\n+   * <p>The button calls this method during construction, stores the\n+   * resulting ChangeListener in its <code>changeListener</code> member\n+   * field, and subscribes it to the button's model. If the button's model\n+   * is changed, this listener is unsubscribed from the old model and\n+   * subscribed to the new one.</p>\n+   *\n+   * @return The new ChangeListener\n+   */\n   protected  ChangeListener createChangeListener()\n   {\n-    //       Subclasses that want to handle ChangeEvents differently can override this to return another ChangeListener implementation.\n     return new ChangeListener()\n       {\n-        public void stateChanged(ChangeEvent e) { }\n+        public void stateChanged(ChangeEvent e)\n+        {\n+          AbstractButton.this.fireStateChanged(e);\n+          AbstractButton.this.revalidate();\n+          AbstractButton.this.repaint();          \n+        }\n       };\n   }\n \n+  /**\n+   * <p>Factory method which creates a {@link ItemListener}, used to\n+   * subscribe to ItemEvents from the button's model. Subclasses of\n+   * AbstractButton may wish to override the listener used to subscribe to\n+   * such ItemEvents. By default, the listener just propagates the\n+   * {@link ItemEvent} to the button's ItemListeners, via the {@link\n+   * AbstractButton.fireItemStateChanged} method.</p>\n+   *\n+   * <p>The button calls this method during construction, stores the\n+   * resulting ItemListener in its <code>changeListener</code> member\n+   * field, and subscribes it to the button's model. If the button's model\n+   * is changed, this listener is unsubscribed from the old model and\n+   * subscribed to the new one.</p>\n+   *\n+   * <p>Note that ItemEvents are only generated from the button's model\n+   * when the model's <em>selected</em> property changes. If you want to\n+   * subscribe to other properties of the model, you must subscribe to\n+   * ChangeEvents.\n+   *\n+   * @return The new ItemListener\n+   */\n   protected  ItemListener createItemListener()\n   {\n     return new ItemListener()\n       {\n-        public void itemStateChanged(ItemEvent e) { }\n+        public void itemStateChanged(ItemEvent e)\n+        {\n+          AbstractButton.this.fireItemStateChanged(e);\n+        }\n       };\n   }\n \n+  /**\n+   * Programmatically perform a \"click\" on the button: arming, pressing,\n+   * waiting, un-pressing, and disarming the model.\n+   */\n   public void doClick()\n   {\n     doClick(100);\n   }\n \n+  /**\n+   * Programmatically perform a \"click\" on the button: arming, pressing,\n+   * waiting, un-pressing, and disarming the model.\n+   *\n+   * @param pressTime The number of milliseconds to wait in the pressed state\n+   */\n   public void doClick(int pressTime)\n   {\n-    //Toolkit.tlkBeep ();\n-    //Programmatically perform a \"click\".\n-  }\n-\n-  public Icon getDisabledSelectedIcon()\n+    getModel().setArmed(true);\n+    getModel().setPressed(true);\n+    try\n   {\n-    //Returns the icon used by the button when it's disabled and selected.\n-    return disabled_selected_button;\n+        java.lang.Thread.sleep(pressTime);\n   }\n-\n-  public Icon getRolloverIcon()\n+    catch (java.lang.InterruptedException e)\n   {\n-    //       Returns the rollover icon for the button.\n-    return null;\n+        // probably harmless\n   }\n-\n-  Icon getRolloverSelectedIcon()\n-  {\n-    //       Returns the rollover selection icon for the button.\n-    return null;\n+    getModel().setPressed(false);\n+    getModel().setArmed(false);\n   }\n \n-  Icon getSelectedIcon()\n+  /**\n+   * Return the button's disabled selected icon. The look and feel class\n+   * should paint this icon when the \"enabled\" property of the button's model\n+   * is <code>false</code> and its \"selected\" property is\n+   * <code>true</code>. This icon can be <code>null</code>, in which case\n+   * it is synthesized from the button's selected icon.\n+   *\n+   * @return The current disabled selected icon\n+   */\n+  public Icon getDisabledSelectedIcon()\n   {\n-    //       Returns the selected icon for the button.\n-    return selected_button;\n+    return disabled_selected_icon;\n   }\n \n-  public Object[] getSelectedObjects()\n+  /**\n+   * Set the button's disabled selected icon. The look and feel class\n+   * should paint this icon when the \"enabled\" property of the button's model\n+   * is <code>false</code> and its \"selected\" property is\n+   * <code>true</code>. This icon can be <code>null</code>, in which case\n+   * it is synthesized from the button's selected icon.\n+   *\n+   * @param disabledSelectedIcon The new disabled selected icon\n+   */\n+  public void setDisabledSelectedIcon(Icon disabledSelectedIcon)\n   {\n-    //Returns an array (length 1) containing the label or null if the button is not selected.\n-    return null;\n-  }\n-\n-  public boolean imageUpdate(Image img, int infoflags, int x, int y, int w, int h)\n+    Icon old = disabled_selected_icon;\n+    disabled_selected_icon = disabledSelectedIcon;\n+    if (old != disabledSelectedIcon)\n   {\n-    //This is overridden to return false if the current Icon's Image is not equal to the passed in Image img.\n-    return current_icon == img;\n+        firePropertyChange(DISABLED_SELECTED_ICON_CHANGED_PROPERTY, old, \n+                           disabledSelectedIcon);\n+        revalidate();\n+        repaint();        \n   }\n-\n-  public boolean isContentAreaFilled()\n-  {\n-    //       Checks whether the \"content area\" of the button should be filled.\n-    return false;\n   }\n \n-  protected  void paintBorder(Graphics g)\n-  {\n-    //       Paint the button's border if BorderPainted property is true.\n-    if (isBorderPainted())\n-      super.paintBorder(g);\n-  }\n \n-  protected  String paramString()\n+  /**\n+   * Return the button's rollover icon. The look and feel class should\n+   * paint this icon when the \"rolloverEnabled\" property of the button is\n+   * <code>true</code> and the mouse rolls over the button.\n+   *\n+   * @return The current rollover icon\n+   */\n+  public Icon getRolloverIcon()\n   {\n-    //        Returns a string representation of this AbstractButton.\n-    return \"AbstractButton\";\n+    return rollover_icon;\n   }\n \n-  public void setContentAreaFilled(boolean b)\n+  /**\n+   * Set the button's rollover icon. The look and feel class should\n+   * paint this icon when the \"rolloverEnabled\" property of the button is\n+   * <code>true</code> and the mouse rolls over the button.\n+   *\n+   * @param rolloverIcon The new rollover icon\n+   */\n+  public void setRolloverIcon(Icon rolloverIcon)\n   {\n-    //Sets whether the button should paint the content area or leave it transparent.\n-  }\n-\n-  public void setDisabledSelectedIcon(Icon disabledSelectedIcon)\n+    Icon old = rollover_icon;\n+    rollover_icon = rolloverIcon;\n+    if (old != rolloverIcon)\n   {\n-    //          Sets the disabled selection icon for the button.\n+        firePropertyChange(ROLLOVER_ICON_CHANGED_PROPERTY, old, \n+                           rolloverIcon);\n+        revalidate();\n+        repaint();\n+      }\n   }\n \n-  public void setRolloverIcon(Icon rolloverIcon)\n+  /**\n+   * Return the button's rollover selected icon. The look and feel class\n+   * should paint this icon when the \"rolloverEnabled\" property of the button\n+   * is <code>true</code>, the \"selected\" property of the button's model is\n+   * <code>true</code>, and the mouse rolls over the button.\n+   *\n+   * @return The current rollover selected icon\n+   */\n+  Icon getRolloverSelectedIcon()\n   {\n-    //       Sets the rollover icon for the button.\n+    return rollover_selected_icon;\n   }\n+\n+  /**\n+   * Set the button's rollover selected icon. The look and feel class\n+   * should paint this icon when the \"rolloverEnabled\" property of the button\n+   * is <code>true</code>, the \"selected\" property of the button's model is\n+   * <code>true</code>, and the mouse rolls over the button.\n+   *\n+   * @param rolloverSelectedIcon The new rollover selected icon\n+   */\n   public void setRolloverSelectedIcon(Icon rolloverSelectedIcon)\n   {\n-    //       Sets the rollover selected icon for the button.\n-  }\n-\n-  public void setSelectedIcon(Icon selectedIcon)\n+    Icon old = rollover_selected_icon;\n+    rollover_selected_icon = rolloverSelectedIcon;\n+    if (old != rolloverSelectedIcon)\n   {\n-    //       Sets the selected icon for the button.\n+        firePropertyChange(ROLLOVER_SELECTED_ICON_CHANGED_PROPERTY, old, \n+                           rolloverSelectedIcon);\n+        revalidate();\n+        repaint();\n   }\n-\n-  public void setUI(ButtonUI ui)\n-  {\t//       Sets the L&F object that renders this component.\n-    super.setUI(ui);\n   }\n \n-  public ButtonUI getUI()\n+\n+  /**\n+   * Return the button's selected icon. The look and feel class should\n+   * paint this icon when the \"selected\" property of the button's model is\n+   * <code>true</code>, and either the \"rolloverEnabled\" property of the\n+   * button is <code>false</code> or the mouse is not currently rolled\n+   * over the button.\n+   *\n+   * @return The current selected icon\n+   */\n+  Icon getSelectedIcon()\n   {\n-    //Returns the L&F object that renders this component.\n-    return (ButtonUI) ui;\n+    return selected_icon;\n   }\n \n-  public void updateUI()\n+  /**\n+   * Set the button's selected icon. The look and feel class should\n+   * paint this icon when the \"selected\" property of the button's model is\n+   * <code>true</code>, and either the \"rolloverEnabled\" property of the\n+   * button is <code>false</code> or the mouse is not currently rolled\n+   * over the button.\n+   *\n+   * @param selectedIcon The new selected icon\n+   */\n+  public void setSelectedIcon(Icon selectedIcon)\n   {\n-    /*\n-    //          Notification from the UIFactory that the L&F has changed.\n-    if (getUI() == null)\n+    Icon old = selected_icon;\n+    selected_icon = selectedIcon;\n+    if (old != selectedIcon)\n     {\n-    setUI(getUI());\n+        firePropertyChange(SELECTED_ICON_CHANGED_PROPERTY, old, \n+                           selectedIcon);\n+        revalidate();\n+        repaint();\n     }\n-    */\n   }\n \n-  protected void processActionEvent(ActionEvent e)\n+  /**\n+   * Returns an single-element array containing the \"text\" property of the\n+   * button if the \"selected\" property of the button's model is\n+   * <code>true</code>, otherwise returns <code>null</code>.\n+   *\n+   * @return The button's \"selected object\" array\n+   */\n+  public Object[] getSelectedObjects()\n   {\n-    System.out.println(\"PROCESS-ACTION-EVENT: \" + e);\n+    if (isSelected())\n+      {\n+        Object[] objs = new Object[1];\n+        objs[0] = getText();\n+        return objs;\n   }\n-\n-  protected void processMouseEvent(MouseEvent e)\n+    else\n   {\n-    //\tSystem.out.println(\"PROCESS-MOUSE-EVENT: \" + e + \", PRESSED-IN-MODEL=\"+getModel().isPressed());\n+        return null;\n+      }\n+  }\n \n-    switch (e.getID())\n-      {\n-      case MouseEvent.MOUSE_MOVED:\n+  /**\n+   * Called when image data becomes available for one of the button's icons.\n+   *\n+   * @param img The image being updated\n+   * @param infoflags One of the constant codes in {@link ImageObserver} used to describe\n+   * updated portions of an image.\n+   * @param x X coordinate of the region being updated\n+   * @param y Y coordinate of the region being updated\n+   * @param w Width of the region beign updated\n+   * @param h Height of the region being updated\n+   *\n+   * @return <code>true</code> if img is equal to the button's current\n+   * icon, otherwise <code>false</code>\n+   */\n+  public boolean imageUpdate(Image img, int infoflags, int x, int y, int w,\n+                             int h)\n         {\n-          break;\n+    return current_icon == img;\n         }\n-      case MouseEvent.MOUSE_PRESSED:\n-        {\n-          if (! isEnabled())\n+\n+  /**\n+   * Returns the value of the button's \"contentAreaFilled\" property. This\n+   * property indicates whether the area surrounding the text and icon of\n+   * the button should be filled by the look and feel class.  If this\n+   * property is <code>false</code>, the look and feel class should leave\n+   * the content area transparent.\n+   *\n+   * @return The current value of the \"contentAreaFilled\" property\n+   */\n+  public boolean isContentAreaFilled()\n             {\n-              System.out.println(\"button not enabled, ignoring press\");\n+    return content_area_filled;\n             }\n-          else\n+\n+  /**\n+   * Sets the value of the button's \"contentAreaFilled\" property. This\n+   * property indicates whether the area surrounding the text and icon of\n+   * the button should be filled by the look and feel class.  If this\n+   * property is <code>false</code>, the look and feel class should leave\n+   * the content area transparent.\n+   *\n+   * @param b The new value of the \"contentAreaFilled\" property\n+   */\n+  public void setContentAreaFilled(boolean b)\n             {\n-              System.out.println(\"telling model:press: \" + getModel());\n-              getModel().setPressed(true);\n+    boolean old = content_area_filled;\n+    content_area_filled = b;\n+    if (b != old)\n+      {\n+        firePropertyChange(CONTENT_AREA_FILLED_CHANGED_PROPERTY, old, b);\n+        revalidate();\n               repaint();\n             }\n-          break;\n         }\n \n-      case MouseEvent.MOUSE_RELEASED:\n-        {\n-          if (! isEnabled())\n+  /**\n+   * Paints the button's border, if the button's \"borderPainted\" property is\n+   * <code>true</code>, by out calling to the button's look and feel class.\n+   *\n+   * @param g The graphics context used to paint the border\n+   */\n+  protected void paintBorder(Graphics g)\n             {\n-              System.out.println(\"button not enabled, ignoring release\");\n+    if (isBorderPainted())\n+      super.paintBorder(g);\n             }\n-          else\n-            {\n-              int flags = 0;\n \n-              System.out.println(\"        XXX--> \" + getActionCommand());\n+  /**\n+   * Returns a string, used only for debugging, which identifies or somehow\n+   * represents this button. The exact value is implementation-defined.\n+   *\n+   * @return A string representation of the button\n+   */\n+  protected String paramString()\n+  {\n+    return \"AbstractButton\";\n+  }\n \n-              fireActionPerformed(new ActionEvent(this,\n-                                                  ActionEvent.ACTION_PERFORMED,\n-                                                  getActionCommand(),\n-                                                  flags));\n \n-              //System.out.println(\"telling model:release\");\n-              getModel().setPressed(false);\n-              repaint();\n-            }\n-          break;\n-        }\n-      case MouseEvent.MOUSE_CLICKED:\n+  /**\n+   * Set the \"UI\" property of the button, which is a look and feel class\n+   * responsible for handling the button's input events and painting it.\n+   *\n+   * @param ui The new \"UI\" property\n+   */\n+  public void setUI(ButtonUI ui)\n         {\n-          break;\n+    super.setUI(ui);\n         }\n+  \n+  /**\n+   * Set the \"UI\" property of the button, which is a look and feel class\n+   * responsible for handling the button's input events and painting it.\n+   *\n+   * @return The current \"UI\" property\n+   */\n+  public ButtonUI getUI()\n+  {\n+    return (ButtonUI) ui;\n       }\n+  \n+  /**\n+   * Set the \"UI\" property to a class constructed, via the {@link\n+   * UIManager}, from the current look and feel. This should be overridden\n+   * for each subclass of AbstractButton, to retrieve a suitable {@link\n+   * ButtonUI} look and feel class.\n+   */\n+  public void updateUI()\n+  {\n   }\n }"}, {"sha": "1997e6a1ff2b40f461dda8da9d0177e30b08a9c2", "filename": "libjava/javax/swing/DefaultButtonModel.java", "status": "modified", "additions": 371, "deletions": 88, "changes": 459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjavax%2Fswing%2FDefaultButtonModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjavax%2Fswing%2FDefaultButtonModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FDefaultButtonModel.java?ref=ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2", "patch": "@@ -1,5 +1,5 @@\n /* DefaultButtonModel.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,9 +35,10 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n+import java.awt.AWTEvent;\n+import java.awt.AWTEventMulticaster;\n import java.awt.event.ActionEvent;\n import java.awt.event.ActionListener;\n import java.awt.event.ItemEvent;\n@@ -49,130 +50,412 @@\n import javax.swing.event.ChangeListener;\n import javax.swing.event.EventListenerList;\n \n-public class DefaultButtonModel\n-  implements ButtonModel, Serializable\n+/**\n+ * The purpose of this class is to model the dynamic state of an abstract\n+ * button. The concrete button type holding this state may be a a \"toggle\"\n+ * button (checkbox, radio button) or a \"push\" button (menu button, button).\n+ * \n+ * Any change to the model's properties will trigger the firing of a\n+ * ChangeEvent.\n+ *\n+ * Any change to the \"pressed\" property will trigger the firing of an\n+ * ItemEvent in addition to ChangeEvent.\n+ *\n+ * Any change which causes the enabled, armed and pressed properties to\n+ * simultaneously become <code>true</code> will trigger the firing of an\n+ * ActionEvent in addition to the ChangeEvent.\n+ *\n+ * @author Graydon Hoare (graydon&064;redhat.com)\n+ */\n+public class DefaultButtonModel implements ButtonModel, Serializable\n {\n   static final long serialVersionUID = -5342609566534980231L;\n \n-    Vector actions          = new Vector();\n+  /** Indicates that the button is <em>partially</em> committed to being\n+   pressed, but not entirely. This usually happens when a user has pressed\n+   but not yet released the mouse button. */\n+  static int ARMED = 1;\n \n-    Vector items    = new Vector();\n-    Vector changes  = new Vector();\n-    ButtonGroup group;\n-    JComponent comp;\n+  /** State constant indicating that the button is enabled. Buttons cannot\n+   be pressed or selected unless they are enabled. */\n+  static int ENABLED = 2;\n \n-    \n-    DefaultButtonModel(JComponent a)\n-    {\n-\tcomp = a;\n-    }\n+  /** State constant indicating that the button has been fully\n+   pressed. This usually happens when a user has released the mouse over a\n+   previously \"armed\" button. */\n+  static int PRESSED = 4;\n+\n+  /** State constant indicating that the mouse is currently positioned over\n+      the button. */\n+  static int ROLLOVER = 8;\n \n+  /** State constant indicating that the button is selected. This constant\n+      is only meaningful for toggle-type buttons (radio buttons,\n+      checkboxes). */\n+  static int SELECTED = 16;\n+\n+  /** Represents the \"state properties\" (armed, enabled, pressed, rollover\n+      and selected) by a bitwise combination of integer constants. */\n+  int stateMask;\n+\n+  /** List of ItemListeners, ChangeListeners, and ActionListeners\n+      registered on this model. */\n+  EventListenerList listenerList;\n+\n+  /** The single ChangeEvent this model (re)uses to call its\n+      ChangeListeners. */\n+  ChangeEvent changeEvent;\n+\n+  /** The group this model belongs to. Only one button in a group may be\n+      selected at any given time. */\n+    ButtonGroup group;\n \n+  /** The key code (one of {@link java.awt.event.KeyEvent} VK_*) used to\n+      press this button via a keyboard interface. */\n+  int mnemonic;\n+\n+  /** The string used as the \"command\" property of any ActionEvent this\n+      model sends. */\n+  String actionCommand;\n+\n+  public DefaultButtonModel()\n+  {\n+    stateMask = 0;\n+    listenerList = new EventListenerList();    \n+    changeEvent = new ChangeEvent(this);\n+  }\n+\n+  /**\n+   * Return <code>null</code>. Use {@link AbstractButton} if you wish to\n+   * interface with a button via an {@link ItemSelectable} interface.\n+   *\n+   * @return <code>null</code>\n+   */\n     public Object[] getSelectedObjects()\n     {\n \treturn null;\n     }\n \n-\n-    public void fireItemStateChanged(ItemEvent event)\n-    {\n-\tfor (int i=0;i<items.size();i++)\n+  /**\n+   * Add an ActionListener to the model. Usually only called to subscribe\n+   * an AbstractButton's listener to the model.\n+   *\n+   * @param l The listener to add\n+   */\n+  public void addActionListener(ActionListener l)\n \t    {\n-\t\tItemListener a = (ItemListener) items.get(i);\n-\t\ta.itemStateChanged(event);\n-\t    }\n+    listenerList.add(ActionListener.class, l);\n     }\n-    public void fireStateChanged(ChangeEvent event)\n+\n+  /**\n+   * Remove an ActionListener to the model. Usually only called to\n+   * unsubscribe an AbstractButton's listener to the model.\n+   *\n+   * @param l The listener to remove\n+   */\n+  public void removeActionListener(ActionListener l)\n+  {\n+    listenerList.remove(ActionListener.class, l);\n+  }\n+\n+  /**\n+   * Add an ItemListener to the model. Usually only called to subscribe\n+   * an AbstractButton's listener to the model.\n+   *\n+   * @param l The listener to add\n+   */\n+  public void addItemListener(ItemListener l)\n+  {\n+    listenerList.add(ItemListener.class, l);\n+  }\n+\n+  /**\n+   * Remove an ItemListener to the model. Usually only called to\n+   * unsubscribe an AbstractButton's listener to the model.\n+   *\n+   * @param l The listener to remove\n+   */\n+  public void removeItemListener(ItemListener l)\n+  {\n+    listenerList.remove(ItemListener.class, l);\n+  }\n+\n+  /**\n+   * Add a ChangeListener to the model. Usually only called to subscribe\n+   * an AbstractButton's listener to the model.\n+   *\n+   * @param l The listener to add\n+   */\n+  public void addChangeListener(ChangeListener l)\n+  {\n+    listenerList.add(ChangeListener.class, l);\n+  }\n+\n+  /**\n+   * Remove a ChangeListener to the model. Usually only called to\n+   * unsubscribe an AbstractButton's listener to the model.\n+   *\n+   * @param l The listener to remove\n+   */\n+  public void removeChangeListener(ChangeListener l)\n+  {\n+    listenerList.remove(ChangeListener.class, l);\n+  }\n+\n+  /**\n+   * Inform each ItemListener in the {@link listenerList} that an ItemEvent\n+   * has occurred. This happens in response to any change to the {@link\n+   * stateMask} field.\n+   *\n+   * @param e The ItemEvent to fire\n+   */\n+  public void fireItemStateChanged(ItemEvent e)\n+  {\n+    EventListener[] ll = listenerList.getListeners(ItemListener.class);\n+    for (int i = 0; i < ll.length; i++)\n+      ((ItemListener)ll[i]).itemStateChanged(e);\n+  }\n+\n+  /**\n+   * Inform each ActionListener in the {@link listenerList} that an\n+   * ActionEvent has occurred. This happens in response to the any change\n+   * to the {@link stateMask} field which makes the enabled, armed and\n+   * pressed properties all simultaneously <code>true</code>.\n+   *\n+   * @param e The ActionEvent to fire\n+   */\n+  public void fireActionPerformed(ActionEvent e)\n+  {\n+    EventListener[] ll = listenerList.getListeners(ActionListener.class);\n+    for (int i = 0; i < ll.length; i++)\n+      ((ActionListener)ll[i]).actionPerformed(e);\n+  }\n+\n+  /**\n+   * Inform each ChangeListener in the {@link listenerList} that a\n+   * ChangeEvent has occurred. This happens in response to the any change\n+   * to a property of the model.\n+   *\n+   * @param event The ChangeEvent to fire\n+   */\n+  public void fireStateChanged(ChangeEvent e)\n+  {\n+    EventListener[] ll = listenerList.getListeners(ChangeListener.class);\n+    for (int i = 0; i < ll.length; i++)\n+      ((ChangeListener)ll[i]).stateChanged(e);\n+  }\n+\n+  /**\n+   * Helper method to fire a ChangeEvent with the model as the event's\n+   * source.\n+   */\n+  protected void changeState(int stateflag, boolean b)\n     {\n-\tfor (int i=0;i<changes.size();i++)\n+    int oldstate = stateMask;\n+    int newstate;\n+\n+    if (b)\n+      newstate = oldstate | stateflag;\n+    else\n+      newstate = oldstate & ~stateflag;\n+\n+    if (oldstate == newstate)\n+      return;\n+\n+    stateMask = newstate;\n+\n+    fireStateChanged(changeEvent);\n+\n+    if ((newstate & ENABLED) == 0)\n+      return;\n+\n+    if ((oldstate & SELECTED) == 0\n+        && (newstate & SELECTED) == SELECTED)\n+      fireItemStateChanged(new ItemEvent(this, ItemEvent.ITEM_STATE_CHANGED, \n+                                         null, ItemEvent.SELECTED));\n+\n+    else if ((oldstate & SELECTED) == SELECTED\n+             && (newstate & SELECTED) == 0)\n+      fireItemStateChanged(new ItemEvent(this, ItemEvent.ITEM_STATE_CHANGED, \n+                                         null, ItemEvent.DESELECTED));\n+\n+    else if ((newstate & ARMED) == ARMED\n+             && (newstate & PRESSED) == PRESSED)\n \t    {\n-\t\tChangeListener a = (ChangeListener) changes.get(i);\n-\t\ta.stateChanged(event);\n+        fireActionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED,\n+                                            actionCommand));\n+        stateMask = stateMask & ~(PRESSED | ARMED);\n \t    }\n+    \n     }\n-    public void fireActionPerformed(ActionEvent event)\n-    {\n-\tfor (int i=0;i<actions.size();i++)\n+\n+  /**\n+   * Get the value of the model's \"armed\" property.\n+   * \n+   * @return The current \"armed\" property \n+   */\n+  public boolean isArmed()\n \t    {\n-\t\tActionListener a = (ActionListener) actions.get(i);\n-\t\ta.actionPerformed(event);\n-\t    }\n+    return (stateMask & ARMED) == ARMED;\n     }\n \n-    boolean arm;\n-    public boolean isArmed()          { return arm; }\n-    public void setArmed(boolean b)   { arm = b; }\n-\n-    boolean enabled = true;\n-    public boolean isEnabled()         { return enabled; }\n-    public void setEnabled(boolean b)  { enabled = b; }\n-\n-    boolean pressed;\n-    public void setPressed(boolean b)  \n+  /**\n+   * Set the value of the model's \"armed\" property.\n+   *\n+   * @param a The new \"armed\" property\n+   */\n+  public void setArmed(boolean a)\n+  {\n+    changeState(ARMED, a);\n+  }\n+\n+  /**\n+   * Get the value of the model's \"enabled\" property.\n+   *\n+   * @return The current \"enabled\" property.\n+   */\n+  public boolean isEnabled()\n     {\n-\tpressed = b; \n+    return (stateMask & ENABLED) == ENABLED;\n     }\n-    public boolean isPressed()         { return pressed; }\n-\n \n-    public void removeActionListener(ActionListener l) { actions.removeElement(l); }\n-    public void addActionListener(ActionListener l)    \n+  /**\n+   * Set the value of the model's \"enabled\" property.\n+   *\n+   * @param e The new \"enabled\" property\n+   */\n+  public void setEnabled(boolean e)\n+  {\n+    changeState(ENABLED, e);\n+  }\n+\n+  /**\n+   * Set the value of the model's \"pressed\" property.\n+   *\n+   * @param p The new \"pressed\" property\n+   */\n+  public void setPressed(boolean p)\n     {\t\n-\t//\tcomp.enableEvents( AWTEvent.ACTION_EVENT_MASK );\n-\tactions.addElement(l);    \n+    changeState(PRESSED, p);\n     }\n \n-    public void addItemListener(ItemListener l)        { items.addElement(l); }\n-    public void removeItemListener(ItemListener l)     { items.removeElement(l); }\n-\n-    public void addChangeListener(ChangeListener l)    { changes.addElement(l); }\n-    public void removeChangeListener(ChangeListener l) { changes.removeElement(l); }\n-\n-    boolean roll;\n-    public void setRollover(boolean b) { roll = b; }\n-    public boolean isRollover()        { return roll; }\n-\n-    int mne;  \n-    public int  getMnemonic()        { return mne; }\n-    public void setMnemonic(int key) { mne = key; }\n-\n-    String com;\n-    public void setActionCommand(String s) { com = s; }\n-    public String getActionCommand()       { return com; }\n-\n-    public void setGroup(ButtonGroup group)\n+  /**\n+   * Get the value of the model's \"pressed\" property.\n+   *\n+   * @return The current \"pressed\" property\n+   */\n+  public boolean isPressed()\n+  {\n+    return (stateMask & PRESSED) == PRESSED;\n+  }\n+\n+  /**\n+   * Set the value of the model's \"rollover\" property.\n+   *\n+   * @param r The new \"rollover\" property\n+   */\n+  public void setRollover(boolean r)\n+  {\n+    changeState(ROLLOVER, r);\n+  }\n+\n+\n+  /**\n+   * Set the value of the model's \"selected\" property.\n+   *\n+   * @param s The new \"selected\" property\n+   */\n+  public void setSelected(boolean s)\n+  {\n+    changeState(SELECTED, s);\n+  }\n+\n+  /**\n+   * Get the value of the model's \"selected\" property.\n+   *\n+   * @return The current \"selected\" property\n+   */\n+  public boolean isSelected()\n+  {\n+    return (stateMask & SELECTED) == SELECTED;\n+  }\n+\n+  /**\n+   * Get the value of the model's \"rollover\" property.\n+   *\n+   * @return The current \"rollover\" property\n+   */\n+  public boolean isRollover()\n     {\n-\tthis.group = group;\n+    return (stateMask & ROLLOVER) == ROLLOVER;\n     }\n \n-    boolean sel;\n-    public void setSelected(boolean b) \n+  /**\n+   * Get the value of the model's \"mnemonic\" property.\n+   *\n+   * @return The current \"mnemonic\" property\n+   */\n+  public int getMnemonic()\n     { \n-\tif (group != null)\n+    return mnemonic;\n+  }\n+\n+  /**\n+   * Set the value of the model's \"mnemonic\" property.\n+   *\n+   * @param key The new \"mnemonic\" property\n+   */\n+  public void setMnemonic(int key)\n \t    {\n-\t\tif (b == true)\n+    if (mnemonic != key)\n \t\t    {\n-\t\t\tSystem.out.println(\"selected button in group:\"+this);\n-\t\t\tgroup.setSelected(this, b);\n-\t\t\tsel = true;\n+        mnemonic = key;\n+        fireStateChanged(changeEvent);\n \t\t    }\n-\t\telse\n+  }\n+\n+  /**\n+   * Set the value of the model's \"actionCommand\" property. This property\n+   * is used as the \"command\" property of the {@link ActionEvent} fired\n+   * from the model.\n+   *\n+   * @param s The new \"actionCommand\" property.\n+   */\n+  public void setActionCommand(String s)\n \t\t    {\n-\t\t\tSystem.out.println(\"deselected button in group: \" + this);\n-\t\t\tsel = false;\n+    if (actionCommand != s)\n+      {\n+        actionCommand = s;\n+        fireStateChanged(changeEvent);\n \t\t    }\n \t    } \n-\telse\n+\n+  /**\n+   * Set the value of the model's \"actionCommand\" property. This property\n+   * is used as the \"command\" property of the {@link ActionEvent} fired\n+   * from the model.\n+   *\n+   * @return The current \"actionCommand\" property\n+   */\n+  public String getActionCommand()\n \t    {\n-\t\tsel = b;\n+    return actionCommand;\n+  }\n+\n+  /**\n+   * Set the value of the model's \"group\" property. The model is said to be\n+   * a member of the {@link ButtonGroup} held in its \"group\" property, and\n+   * only one models in a given group can have their \"selected\" property be\n+   * <code>true</code> at a time.\n+   *\n+   * @param g The new \"group\" property\n+   */\n+  public void setGroup(ButtonGroup g)\n+  {\n+    if (group != g)\n+      {\n+        group = g;\n+        fireStateChanged(changeEvent);\n \t    }\n     }\n-    public boolean isSelected()        { return sel; }\n }\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "b95b7e6c480347ebc4ff1275c4f49cec1fcf92b3", "filename": "libjava/javax/swing/JComponent.java", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjavax%2Fswing%2FJComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjavax%2Fswing%2FJComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJComponent.java?ref=ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2", "patch": "@@ -46,6 +46,7 @@\n import java.awt.FlowLayout;\n import java.awt.Font;\n import java.awt.Graphics;\n+import java.awt.Image;\n import java.awt.Insets;\n import java.awt.Point;\n import java.awt.Rectangle;\n@@ -56,6 +57,7 @@\n import java.awt.event.FocusListener;\n import java.awt.event.KeyEvent;\n import java.awt.event.MouseEvent;\n+import java.awt.image.ImageObserver;\n import java.awt.peer.LightweightPeer;\n import java.beans.PropertyChangeListener;\n import java.beans.PropertyVetoException;\n@@ -271,13 +273,16 @@ public JComponent()\n \t\tsuper();\n \t\tsuper.setLayout(new FlowLayout());\n \t\t\n+\t\tlistenerList = new EventListenerList();\n+    \n \t\t//eventMask |= AWTEvent.COMP_KEY_EVENT_MASK;\n-\t\tenableEvents( AWTEvent.KEY_EVENT_MASK );\n+\t\t// enableEvents( AWTEvent.KEY_EVENT_MASK );\n \n \t\t//updateUI(); // get a proper ui\n \t}\n \n-\t// protected EventListenerList listenerList\n+\tprotected EventListenerList listenerList;\n+\n \tpublic boolean contains(int x, int y)\n \t{\n \t\t//return dims.contains(x,y);\n@@ -701,11 +706,29 @@ public boolean isValidateRoot()\n \n \tpublic void paint(Graphics g)\n \t{\n-\t\t//\tSystem.out.println(\"SWING_PAINT:\" + this);\n+\t\tGraphics g2 = g;\n+\t\tImage im = null;\n+\t\tRectangle r = getBounds ();\n+\t\t// System.err.println(this + \".paint(...), bounds = \" + r);\n+\t\t\n+\t\tif (use_double_buffer)\n+\t\t{\n+\t\t\tim = createImage (r.width, r.height);\n+\t\t\tg2 = im.getGraphics ();\n+\t\t\tg2.clearRect (0, 0, r.width, r.height);\n+\t\t}\n+\t\t\n+\t\tpaintBorder(g2);\n+\t\tpaintComponent(g2);\n+\t\tpaintChildren(g2);\n \n-\t\tpaintBorder(g);\n-\t\tpaintComponent(g);\n-\t\tpaintChildren(g);\n+\t\tif (use_double_buffer)\n+\t\t{\n+\t\t\t// always draw at 0,0, because regardless of your current bounds,\n+\t\t\t// the graphics object you were passed was positioned so the origin\n+\t\t\t// was at the upper left corner of your bounds.\n+\t\t\tg.drawImage (im, 0, 0, (ImageObserver)null);\n+\t\t}\n \t}\n \n \tprotected  void paintBorder(Graphics g)\n@@ -729,7 +752,7 @@ protected  void paintBorder(Graphics g)\n \tprotected  void paintChildren(Graphics g)\n \t{\n \t    //      Paint this component's children.\n-\t    //super.paintChildren(g);\n+\t\tsuper.paint(g);\n \t}\n \n \tprotected  void paintComponent(Graphics g)"}, {"sha": "1b05f3190c056138d8cbe7b7ad50800005f596f4", "filename": "libjava/javax/swing/JToggleButton.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjavax%2Fswing%2FJToggleButton.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjavax%2Fswing%2FJToggleButton.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJToggleButton.java?ref=ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2", "patch": "@@ -74,7 +74,7 @@ public JToggleButton (String text, Icon icon, boolean selected)\n \tsuper(text, icon);\n \n         // Create the model\n-        setModel(new ToggleButtonModel(this));\n+        setModel(new ToggleButtonModel());\n \t\n         model.setSelected(selected);\n     }"}, {"sha": "1591132882e60e8e44588c891d051a48514812b9", "filename": "libjava/javax/swing/SwingUtilities.java", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjavax%2Fswing%2FSwingUtilities.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjavax%2Fswing%2FSwingUtilities.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FSwingUtilities.java?ref=ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2", "patch": "@@ -97,8 +97,8 @@ public static String layoutCompoundLabel(JComponent c,\n     // view rect 'vr' already ok, \n     // we need to compute ir (icon rect) and tr (text-rect)\n \t\n-    int next_x = 0;//vr.x;\n-    int next_y = 0;//vr.y;\n+    int next_x = vr.x;\n+    int next_y = vr.y;\n \t\n     ir.height = ir.width = ir.y = ir.x = 0;\n \n@@ -115,10 +115,10 @@ public static String layoutCompoundLabel(JComponent c,\n       }\n \t\n     tr.x = next_x;\n-    tr.y = vr.y + (vr.height/2);\n+    tr.y = vr.y; // + (vr.height/2);\n \n     tr.width  = fm.stringWidth(text);\n-    tr.height = fm.getHeight() +  fm.getAscent()/2;\n+    tr.height = fm.getHeight(); // +  fm.getAscent()/2;\n \n     return text;\n   }"}, {"sha": "4954604f83f0895e82a0e21294cc74de1943ba3e", "filename": "libjava/javax/swing/ToggleButtonModel.java", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjavax%2Fswing%2FToggleButtonModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjavax%2Fswing%2FToggleButtonModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FToggleButtonModel.java?ref=ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2", "patch": "@@ -40,11 +40,6 @@\n \n public class ToggleButtonModel extends DefaultButtonModel\n {\n-    ToggleButtonModel(JComponent c)\n-    {\n-\tsuper(c);\n-    }\n-\n     public void setPressed(boolean b)  \n     {\n \tif (! isEnabled())"}, {"sha": "3bcff944d9034f5aa831b9aa167f4f60bb89d6bb", "filename": "libjava/javax/swing/plaf/basic/BasicButtonUI.java", "status": "modified", "additions": 276, "deletions": 73, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java?ref=ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2", "patch": "@@ -35,16 +35,23 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing.plaf.basic;\n \n+import java.awt.BasicStroke;\n import java.awt.Color;\n import java.awt.Dimension;\n import java.awt.Font;\n import java.awt.FontMetrics;\n import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Stroke;\n import java.awt.Insets;\n import java.awt.Rectangle;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n import javax.swing.AbstractButton;\n import javax.swing.JComponent;\n import javax.swing.SwingUtilities;\n@@ -53,20 +60,161 @@\n \n public class BasicButtonUI extends ButtonUI\n {\n+  /** A constant used to pad out elements in the button's layout and\n+      preferred size calculations. */\n     int gap = 3;\n-    //    int y_text_space = 2, x_text_space + 5;\n \n-    Color textColor, disabledTextColor;\n-    Color pressedBackgroundColor;\n-    Color normalBackgroundColor;\n+  /** The color that text will be painted when the button is enabled */\n+  Color textColor;\n \n+  /** The color that text will be painted when the button is disabled */\n+  Color disabledTextColor;\n+\n+  /** The color that the button's background will be painted when the\n+      button is pressed. */\n+    Color pressedBackgroundColor;\n \n+  /** The color that the button's background will be painted when the\n+      button is not pressed. */\n+  Color normalBackgroundColor;\n+\n+  /**\n+   * Factory method to create an instance of BasicButtonUI for a given\n+   * {@link JComponent}, which should be an {@link AbstractButton}.\n+   *\n+   * @param c The component to create a UI got\n+   *\n+   * @return A new UI capable of drawing the component\n+   */\n     public static ComponentUI createUI(final JComponent c) \n     {\n \treturn new BasicButtonUI();\n     }\n \n+  /**\n+   * Helper class which listens to a button's focus events and disarms the\n+   * button's model when focus is lost.\n+   */\n+  private static class FocusUIListener extends FocusAdapter\n+  {\n+    /** Button to listen to focus events from */\n+    AbstractButton button;\n+\n+    /**\n+     * Creates a new FocusUIListener object.\n+     *\n+     * @param b The button to listen to\n+     */\n+    FocusUIListener(AbstractButton b)\n+    {\n+      button = b;\n+    }\n     \n+    /**\n+     * Called when the button loses focus.\n+     *\n+     * @param event The loss of focus event.\n+     */\n+    public void focusLost(FocusEvent event)\n+    {\n+      // System.err.println(\"ButtonUI :: lost focus -- disarming\");\n+      button.getModel().setArmed(false);\n+    }\n+  }\n+\n+  /**\n+   * A helper class which interprets mouse events as \n+   * state changes to the button's underlying model.\n+   */\n+  private static class ButtonUIListener extends MouseAdapter\n+  {\n+    /** The button to change the model of */\n+    AbstractButton button;\n+\n+    /**\n+     * Creates a new ButtonUIListener object.\n+     *\n+     * @param b The button to change the model of\n+     */\n+    public ButtonUIListener(AbstractButton b)\n+    {\n+      button = b;\n+    }\n+\n+    /**\n+     * Accept a mouse press event and arm the button's model.\n+     *\n+     * @param e The mouse press event to accept\n+     */\n+    public void mousePressed(MouseEvent e)\n+    {\n+      // System.err.println(\"ButtonUI :: mouse pressed\");\n+      if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0)\n+        {\n+          // System.err.println(\"ButtonUI :: arming\");\n+          button.getModel().setArmed(true);\n+        }\n+    }\n+\n+    /**\n+     * Accept a mouse enter event and set the button's model's\n+     * \"rollover\" property to <code>true</code>. If the button's\n+     * model is currently armed and the mouse button is not held\n+     * down, this enter event will also disarm the model.\n+     *\n+     * @param e The mouse enter event to accept\n+     */\n+    public void mouseEntered(MouseEvent e)\n+    {\n+      // System.err.println(\"ButtonUI :: mouse entered\");\n+      // System.err.println(\"ButtonUI :: rolling over\");\n+      button.getModel().setRollover(true);\n+      if (button.getModel().isArmed() \n+          && (e.getModifiers() & InputEvent.BUTTON1_MASK) == 0)\n+        {\n+          // System.err.println(\"ButtonUI :: no button pressed -- disarming\");\n+          button.getModel().setArmed(false);\n+        }\n+    }\n+\n+    /**\n+     * Accept a mouse exit event and set the button's model's\n+     * \"rollover\" property to <code>false</code>.\n+     *\n+     * @param e The mouse exit event to accept\n+     */\n+    public void mouseExited(MouseEvent e)\n+    {\n+      // System.err.println(\"ButtonUI :: mouse exited\");\n+      button.getModel().setRollover(false);\n+    }\n+\n+    /**\n+     * Accept a mouse release event and set the button's model's\n+     * \"pressed\" property to <code>true</code>, if the model\n+     * is armed. If the model is not armed, ignore the event.\n+     *\n+     * @param e The mouse release event to accept\n+     */\n+    public void mouseReleased(MouseEvent e)\n+    {\n+      // System.err.println(\"ButtonUI :: mouse released\");\n+      if (button.getModel().isArmed()\n+          && (e.getModifiers() & InputEvent.BUTTON1_MASK) != 0)\n+        {\n+          button.getModel().setPressed(true);\n+        }\n+    }\n+  }\n+\n+  /**\n+   * Install the BasicButtonUI as the UI for a particular component.\n+   * This means registering all the UI's listeners with the component,\n+   * and setting any properties of the button which are particular to \n+   * this look and feel.\n+   *\n+   * @param c The component to install the UI into\n+   */\n     public void installUI(final JComponent c) \n     {\n \tsuper.installUI(c);\n@@ -76,141 +224,196 @@ public void installUI(final JComponent c)\n \tpressedBackgroundColor   = new Color(150,150,150);\n \tpressedBackgroundColor   = new Color(150,150,150);\n \tnormalBackgroundColor    = new Color(192,192,192);\n-    }\n-    \n \n+    // this tells the border (if we have one) how to paint.\n+    c.setBackground(normalBackgroundColor);\n+    ((AbstractButton)c).setMargin (new Insets(10,10,10,10));\n+\n+    c.addMouseListener(new ButtonUIListener((AbstractButton) c));\n+    c.addFocusListener(new FocusUIListener((AbstractButton) c));\n+  }\n+\n+  /**\n+   * Calculate the preferred size of this component, by delegating to\n+   * {@link BasicGraphicsUtils.getPreferredButtonSize}.\n+   *\n+   * @param c The component to measure\n+   *\n+   * @return The preferred dimensions of the component\n+   */\n     public Dimension getPreferredSize(JComponent c) \n     {\n \tAbstractButton b = (AbstractButton)c;\n \tDimension d = BasicGraphicsUtils.getPreferredButtonSize(b, gap);\n-\t//\tSystem.out.println(\"^^^^^^^^^^^^^^^^^^^^^^   BASIC-PREF=\"+d + \",T=\"+b.text);\n \treturn d;\n     }\n     \n-\n+  /**\n+   * Paint the component, which is an {@link AbstractButton}, according to \n+   * its current state.\n+   *\n+   * @param g The graphics context to paint with\n+   * @param c The component to paint the state of\n+   */\n     public void paint(Graphics g, JComponent c)\n     {      \n \tAbstractButton b = (AbstractButton) c;\n \n \tRectangle tr = new Rectangle();\n \tRectangle ir = new Rectangle();\n \tRectangle vr = new Rectangle();\n+    Rectangle br = new Rectangle();\n \n         Font f = c.getFont();\n \n         g.setFont(f);\n \n         FontMetrics fm = g.getFontMetrics(f);\n \n-        Insets i = c.getInsets();\n+    Insets border = b.getInsets();\n+    Insets margin = b.getMargin();\n \n-        vr.x      = i.left;\n-        vr.y      = i.top;\n-        vr.width  = b.getWidth()  - (i.right  + vr.x);\n-        vr.height = b.getHeight() - (i.bottom + vr.y);\n-\t\n-\t//System.out.println(\"             VIEW-RECT-BUTTON=\"+vr+\", insets=\"+i+\", FONTM=\"+fm);\n-\t\n-\tString text = SwingUtilities.layoutCompoundLabel(c,\n-\t\t\t\t\t\t\t fm, \n-\t\t\t\t\t\t\t b.getText(),\n+    br.x = border.left;\n+    br.y = border.top;\n+    br.width = b.getWidth() - (border.right + border.left);\n+    br.height = b.getHeight() - (border.top + border.bottom);\n+\n+    vr.x = br.x + margin.left;\n+    vr.y = br.y + margin.top;\n+    vr.width = br.width - (margin.right + margin.left);\n+    vr.height = br.height - (margin.top + margin.bottom);\n+\n+    String text = SwingUtilities.layoutCompoundLabel(c, fm, b.getText(),\n \t\t\t\t\t\t\t b.getIcon(),\n \t\t\t\t\t\t\t b.getVerticalAlignment(), \n \t\t\t\t\t\t\t b.getHorizontalAlignment(),\n \t\t\t\t\t\t\t b.getVerticalTextPosition(), \n \t\t\t\t\t\t\t b.getHorizontalTextPosition(),\n-\t\t\t\t\t\t\t vr,\n-\t\t\t\t\t\t\t ir,\n-\t\t\t\t\t\t\t tr,\n-\t\t\t\t\t\t\t gap);\n+                                                     vr, ir, tr, gap);\n \n-        if (b.getModel().isPressed() ||\n-\t    b.getModel().isSelected())\n-\t    {\n-\t      //System.out.println(\"paint pressed\");\n-\t\tpaintButtonPressed(g, c);\n-\t    }\n+    if ((b.getModel().isRollover() && b.getModel().isArmed()) \n+        || b.getModel().isSelected())\n+      paintButtonPressed(g, br, c);\n \telse\n-\t    {\n-\t      //System.out.println(\"paint normal\");\n-\t\tpaintButtonNormal(g, c);\n-\t    }\n+      paintButtonNormal(g, br, c);\n \t\n \tpaintIcon(g, c, ir);\n \tpaintText(g, c, tr, b.getText());\n \tpaintFocus(g, c, vr, tr, ir);\n     }\n \n-\n-    protected void paintFocus(Graphics g, \n-\t\t\t      JComponent c,\n-\t\t\t      Rectangle vr,\n-\t\t\t      Rectangle tr,\n-\t\t\t      Rectangle ir)\n+  /**\n+   * Paint any focus decoration this {@link JComponent} might have.  The\n+   * component, which in this case will be an {@link AbstractButton},\n+   * should only have focus decoration painted if it has the focus, and its\n+   * \"focusPainted\" property is <code>true</code>.\n+   *\n+   * @param g Graphics context to paint with\n+   * @param c Component to paint the focus of\n+   * @param vr Visible rectangle, the area in which to paint\n+   * @param tr Text rectangle, contained in visible rectangle\n+   * @param ir Icon rectangle, contained in visible rectangle\n+   *\n+   * @see AbstractButton.isFocusPainted()\n+   * @see JComponent.hasFocus()\n+   */\n+  protected void paintFocus(Graphics g, JComponent c, Rectangle vr,\n+                            Rectangle tr, Rectangle ir)\n+  {\n+    AbstractButton b = (AbstractButton) c;\n+    if (b.hasFocus() && b.isFocusPainted())\n     {\n+        Graphics2D g2 = (Graphics2D) g;\n+        Stroke saved_stroke = g2.getStroke();\n+        Color saved_color = g2.getColor();\n+        float dashes[] = new float[] {1.0f, 1.0f};        \n+        BasicStroke s = new BasicStroke(1.0f, \n+                                        BasicStroke.CAP_SQUARE, \n+                                        BasicStroke.JOIN_MITER,\n+                                        10, dashes, 0.0f);\n+        g2.setStroke(s);\n+        g2.setColor(Color.BLACK);\n+        g2.drawRect(vr.x + 2, \n+                    vr.y + 2, \n+                    vr.width - 4,\n+                    vr.height - 4);\n+        g2.setStroke(saved_stroke);\n+        g2.setColor(saved_color);\n+      }\n     }\n \n-    protected void paintIcon(Graphics g, \n-\t\t\t     JComponent c, \n-\t\t\t     Rectangle iconRect)\n+  /**\n+   * Paint the icon for this component. Depending on the state of the\n+   * component and the availability of the button's various icon\n+   * properties, this might mean painting one of several different icons.\n+   *\n+   * @param g Graphics context to paint with\n+   * @param c Component to paint the icon of\n+   * @param iconRect Rectangle in which the icon should be painted\n+   */\n+  protected void paintIcon(Graphics g, JComponent c, Rectangle iconRect)\n     {\n \tAbstractButton b = (AbstractButton) c;\n \tif (b.getIcon() != null)\n \t    {\n \t\tint x = iconRect.x;\n \t\tint y = iconRect.y;\n-\n-\t\tSystem.out.println(\"WE HAVE AN ICON: \" + b.getIcon());\n- \n \t\tb.getIcon().paintIcon(c, g, x, y);\n \t    }\n-\telse\n-\t    {\n-\t\t//System.out.println(\"NO ICON FOR BUTTON:\" + b.text);\n-\t    }\n     }\n \n-    protected void paintButtonPressed(Graphics g,\n-\t\t\t\t      JComponent b)\n+  /**\n+   * Paints the background area of an {@link AbstractButton} in the pressed\n+   * state.  This means filling the supplied area with the {@link\n+   * pressedBackgroundColor}.\n+   *\n+   * @param g The graphics context to paint with\n+   * @param area The area in which to paint\n+   * @param b The component to paint the state of\n+   */\n+  protected void paintButtonPressed(Graphics g, Rectangle area, JComponent b)\n     {\n \tDimension size = b.getSize();\n \t\n \tg.setColor(pressedBackgroundColor);\n-\tg.fillRect(1,1,size.width-2, size.height-2);                \n-\n+    g.fillRect(area.x, area.y, area.width, area.height);\n     }\n     \n-    protected void paintButtonNormal(Graphics g,\n-\t\t\t\t     JComponent b)\n+  /**\n+   * Paints the background area of an {@link AbstractButton} in the normal,\n+   * non-pressed state.  This means filling the supplied area with the\n+   * {@link normalBackgroundColor}.\n+   *\n+   * @param g The graphics context to paint with\n+   * @param area The area in which to paint\n+   * @param b The component to paint the state of\n+   */\n+  protected void paintButtonNormal(Graphics g, Rectangle area, JComponent b)\n     {\n \tDimension size = b.getSize();\n-\t\n \tg.setColor(normalBackgroundColor);\n-\tg.fillRect(1,1,size.width-2, size.height-2);                \n-\n+    g.fillRect(area.x, area.y, area.width, area.height);\n     }\n     \n-    protected void paintText(Graphics g,\n-\t\t\t     JComponent c,\n-\t\t\t     Rectangle textRect,\n+  /**\n+   * Paints the \"text\" property of an {@link AbstractButton}, using the\n+   * {@link textColor} color.\n+   *\n+   * @param g The graphics context to paint with\n+   * @param c The component to paint the state of\n+   * @param textRect The area in which to paint the text\n+   * @param text The text to paint\n+   */\n+  protected void paintText(Graphics g, JComponent c, Rectangle textRect,\n \t\t\t     String text) \n     {\t\n \tFont f = c.getFont();\n-\n         g.setFont(f);\n-\n         FontMetrics fm = g.getFontMetrics(f);\n-\n \tg.setColor(c.isEnabled() ? textColor : disabledTextColor);\n-\n-\tBasicGraphicsUtils.drawString(g,\n-\t\t\t\t      text, \n+    BasicGraphicsUtils.drawString(g, text, \n \t\t\t\t      0,\n \t\t\t\t      textRect.x, \n-\t\t\t\t      textRect.y + fm.getAscent()/2);\n+                                  textRect.y + fm.getAscent());\n     } \n }\n-\n-\n-\n-"}, {"sha": "f88bf9287474cda550c05496c45b2dfb92873449", "filename": "libjava/javax/swing/plaf/basic/BasicGraphicsUtils.java", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicGraphicsUtils.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicGraphicsUtils.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicGraphicsUtils.java?ref=ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2", "patch": "@@ -595,6 +595,7 @@ public static Dimension getPreferredButtonSize(AbstractButton b,\n     Rectangle iconRect = new Rectangle();\n     Rectangle textRect = new Rectangle();\n     Insets insets = b.getInsets();\n+    Insets margin = b.getMargin();\n     \n     /* For determining the ideal size, do not assume a size restriction. */\n     viewRect = new Rectangle(0, 0,\n@@ -620,7 +621,6 @@ public static Dimension getPreferredButtonSize(AbstractButton b,\n       viewRect, iconRect, textRect,\n       textIconGap);\n \n-\n     /*  +------------------------+       +------------------------+\n      *  |                        |       |                        |\n      *  | ICON                   |       | CONTENTCONTENTCONTENT  |\n@@ -630,7 +630,11 @@ public static Dimension getPreferredButtonSize(AbstractButton b,\n      */\n     contentRect = textRect.union(iconRect);\n \n-    return new Dimension(insets.left + contentRect.width + insets.right,\n-                         insets.top + contentRect.height + insets.bottom);\n+    return new Dimension(insets.left + margin.left\n+\t\t\t + contentRect.width \n+\t\t\t + insets.right + margin.right,\n+                         insets.top + margin.top\n+\t\t\t + contentRect.height \n+\t\t\t + insets.bottom + margin.bottom);\n   }\n }"}, {"sha": "742550f8ef256effe6ea6ce6ad7cc0be5f22f9ea", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkWindowPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkWindowPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkWindowPeer.c?ref=ca3bb0c283932ab6342cac597f2a9e04e2b0c1b2", "patch": "@@ -228,12 +228,25 @@ Java_gnu_java_awt_peer_gtk_GtkWindowPeer_connectSignals\n {\n   void *ptr = NSA_GET_PTR (env, obj);\n   jobject *gref = NSA_GET_GLOBAL_REF (env, obj);\n+  GtkWidget* vbox, *layout;\n+  GList* children;\n   g_assert (gref);\n \n   gdk_threads_enter ();\n \n   gtk_widget_realize (ptr);\n \n+  /* Receive events from the GtkLayout too */\n+  children = gtk_container_get_children(GTK_CONTAINER(ptr));\n+  vbox = children->data;  \n+  g_assert(GTK_IS_VBOX(vbox));\n+  children = gtk_container_get_children(GTK_CONTAINER(vbox));\n+  layout = children->data;  \n+  g_assert(GTK_IS_LAYOUT(layout));\n+\n+  g_signal_connect (GTK_OBJECT (layout), \"event\", \n+\t\t    G_CALLBACK (pre_event_handler), *gref);\n+\n   /* Connect signals for window event support. */\n   g_signal_connect (G_OBJECT (ptr), \"delete-event\",\n \t\t    G_CALLBACK (window_delete_cb), *gref);"}]}