{"sha": "c7a28c1bc27c8eb9fa223147c081588c7fd8a369", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdhMjhjMWJjMjdjOGViOWZhMjIzMTQ3YzA4MTU4OGM3ZmQ4YTM2OQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-02-13T23:53:54Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-02-13T23:53:54Z"}, "message": "re PR bootstrap/65060 (r220696 breaks bootstrap on Linux/x86-32)\n\n       PR bootstrap/65060\n        Revert my change for tree-optimization/64823.\n\nFrom-SVN: r220701", "tree": {"sha": "e0630ab98623373f42d5beefbcc9e2baace92a18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0630ab98623373f42d5beefbcc9e2baace92a18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7a28c1bc27c8eb9fa223147c081588c7fd8a369", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a28c1bc27c8eb9fa223147c081588c7fd8a369", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7a28c1bc27c8eb9fa223147c081588c7fd8a369", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a28c1bc27c8eb9fa223147c081588c7fd8a369/comments", "author": null, "committer": null, "parents": [{"sha": "f7a0790f3ccdf71e47e8cb79af7820539361f9d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7a0790f3ccdf71e47e8cb79af7820539361f9d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7a0790f3ccdf71e47e8cb79af7820539361f9d2"}], "stats": {"total": 78, "additions": 19, "deletions": 59}, "files": [{"sha": "ca43bfd0b94d897a7824d16ebbb5352b52047f5d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a28c1bc27c8eb9fa223147c081588c7fd8a369/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a28c1bc27c8eb9fa223147c081588c7fd8a369/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7a28c1bc27c8eb9fa223147c081588c7fd8a369", "patch": "@@ -1,3 +1,8 @@\n+2015-02-13  Jeff Law  <law@redhat.com>\n+\n+\tPR bootstrap/65060\n+\tRevert my change for tree-optimization/64823.\n+\n 2015-02-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/65053"}, {"sha": "bb13dc15523ecf2d6a4bb2bd72cf48d76b90d0d5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a28c1bc27c8eb9fa223147c081588c7fd8a369/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a28c1bc27c8eb9fa223147c081588c7fd8a369/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c7a28c1bc27c8eb9fa223147c081588c7fd8a369", "patch": "@@ -1,3 +1,8 @@\n+2015-02-13  Jeff Law  <law@redhat.com>\n+\n+\tPR bootstrap/65060\n+\tRevert my change for tree-optimization/64823.\n+\n 2015-02-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/65053"}, {"sha": "12001aee9937e4ac4ebce75425ada030d6241575", "filename": "gcc/testsuite/gcc.dg/uninit-20.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7a0790f3ccdf71e47e8cb79af7820539361f9d2/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7a0790f3ccdf71e47e8cb79af7820539361f9d2/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-20.c?ref=f7a0790f3ccdf71e47e8cb79af7820539361f9d2", "patch": "@@ -1,18 +0,0 @@\n-/* Spurious uninitialized variable warnings, from gdb */\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -Wuninitialized\" } */\n-struct os { struct o *o; };\n-struct o { struct o *next; struct os *se; };\n-void f(struct o *o){\n-  struct os *s;\n-  if(o) s = o->se;\n-  while(o && s == o->se){\n-    s++; // here `o' is non-zero and thus s is initialized\n-    s == o->se  // `?' is essential, `if' does not trigger the warning\n-      ? (o = o->next, o ? s = o->se : 0)\n-      : 0;\n-  }\n-}\n-\n-\n-"}, {"sha": "4f839910a84c686644c59daf3c2b63e74250eeb1", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 7, "deletions": 32, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a28c1bc27c8eb9fa223147c081588c7fd8a369/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a28c1bc27c8eb9fa223147c081588c7fd8a369/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=c7a28c1bc27c8eb9fa223147c081588c7fd8a369", "patch": "@@ -110,15 +110,6 @@ potentially_threadable_block (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n \n-  /* Special case.  We can get blocks that are forwarders, but are\n-     not optimized away because they forward from outside a loop\n-     to the loop header.   We want to thread through them as we can\n-     sometimes thread to the loop exit, which is obviously profitable. \n-     the interesting case here is when the block has PHIs.  */\n-  if (gsi_end_p (gsi_start_nondebug_bb (bb))\n-      && !gsi_end_p (gsi_start_phis (bb)))\n-    return true;\n-  \n   /* If BB has a single successor or a single predecessor, then\n      there is no threading opportunity.  */\n   if (single_succ_p (bb) || single_pred_p (bb))\n@@ -1290,32 +1281,16 @@ thread_through_normal_block (edge e,\n     = record_temporary_equivalences_from_stmts_at_dest (e, stack, simplify,\n \t\t\t\t\t\t\t*backedge_seen_p);\n \n-  /* There's two reasons STMT might be null, and distinguishing\n-     between them is important.\n+  /* If we didn't look at all the statements, the most likely reason is\n+     there were too many and thus duplicating this block is not profitable.\n \n-     First the block may not have had any statements.  For example, it\n-     might have some PHIs and unconditionally transfer control elsewhere.\n-     Such blocks are suitable for jump threading, particularly as a\n-     joiner block.\n-\n-     The second reason would be if we did not process all the statements\n-     in the block (because there were too many to make duplicating the\n-     block profitable.   If we did not look at all the statements, then\n-     we may not have invalidated everything needing invalidation.  Thus\n-     we must signal to our caller that this block is not suitable for\n-     use as a joiner in a threading path.  */\n+     Also note if we do not look at all the statements, then we may not\n+     have invalidated equivalences that are no longer valid if we threaded\n+     around a loop.  Thus we must signal to our caller that this block\n+     is not suitable for use as a joiner in a threading path.  */\n   if (!stmt)\n-    {\n-      /* First case.  The statement simply doesn't have any instructions, but\n-\t does have PHIs.  */\n-      if (gsi_end_p (gsi_start_nondebug_bb (e->dest))\n-\t  && !gsi_end_p (gsi_start_phis (e->dest)))\n-\treturn 0;\n+    return -1;\n \n-      /* Second case.  */\n-      return -1;\n-    }\n-  \n   /* If we stopped at a COND_EXPR or SWITCH_EXPR, see if we know which arm\n      will be taken.  */\n   if (gimple_code (stmt) == GIMPLE_COND"}, {"sha": "dad1830e9a1b98e111ea1b5b46fc71efe4cd27ef", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7a28c1bc27c8eb9fa223147c081588c7fd8a369/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7a28c1bc27c8eb9fa223147c081588c7fd8a369/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=c7a28c1bc27c8eb9fa223147c081588c7fd8a369", "patch": "@@ -10181,15 +10181,8 @@ identify_jump_threads (void)\n       /* We're basically looking for a switch or any kind of conditional with\n \t integral or pointer type arguments.  Note the type of the second\n \t argument will be the same as the first argument, so no need to\n-\t check it explicitly. \n-\n-\t We also handle the case where there are no statements in the\n-\t block.  This come up with forwarder blocks that are not\n-\t optimized away because they lead to a loop header.  But we do\n-\t want to thread through them as we can sometimes thread to the\n-\t loop exit which is obviously profitable.  */\n-      if (!last\n-\t  || gimple_code (last) == GIMPLE_SWITCH\n+\t check it explicitly.  */\n+      if (gimple_code (last) == GIMPLE_SWITCH\n \t  || (gimple_code (last) == GIMPLE_COND\n       \t      && TREE_CODE (gimple_cond_lhs (last)) == SSA_NAME\n \t      && (INTEGRAL_TYPE_P (TREE_TYPE (gimple_cond_lhs (last)))"}]}