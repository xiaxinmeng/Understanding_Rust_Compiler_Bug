{"sha": "529bc4103b78fa16cbd93d7947724472a4ffb31e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI5YmM0MTAzYjc4ZmExNmNiZDkzZDc5NDc3MjQ0NzJhNGZmYjMxZQ==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2019-08-07T14:20:40Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2019-08-07T14:20:40Z"}, "message": "PR c++/91346 - Implement P1668R1, allow unevaluated asm in constexpr.\n\n\t* constexpr.c (cxx_eval_constant_expression): Handle ASM_EXPR.\n\t(potential_constant_expression_1) <case ASM_EXPR>: Allow.\n\t* cp-tree.h (finish_asm_stmt): Adjust.\n\t* parser.c (cp_parser_asm_definition): Grab the locaion of \"asm\" and\n\tuse it.  Change an error to a pedwarn.  Allow asm in C++2a, warn\n\totherwise.\n\t* pt.c (tsubst_expr): Pass a location down to finish_asm_stmt.\n\t* semantics.c (finish_asm_stmt): New location_t parameter.  Use it.\n\n\t* g++.dg/cpp2a/inline-asm1.C: New test.\n\t* g++.dg/cpp2a/inline-asm2.C: New test.\n\t* g++.dg/cpp1y/constexpr-neg1.C: Adjust dg-error.\n\nFrom-SVN: r274169", "tree": {"sha": "d4855ef69ac242d4c4342067cb9a3958413af358", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4855ef69ac242d4c4342067cb9a3958413af358"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/529bc4103b78fa16cbd93d7947724472a4ffb31e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/529bc4103b78fa16cbd93d7947724472a4ffb31e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/529bc4103b78fa16cbd93d7947724472a4ffb31e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/529bc4103b78fa16cbd93d7947724472a4ffb31e/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "699ce759c278cd4f8ccc4dc53f185f6d3142d990", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/699ce759c278cd4f8ccc4dc53f185f6d3142d990", "html_url": "https://github.com/Rust-GCC/gccrs/commit/699ce759c278cd4f8ccc4dc53f185f6d3142d990"}], "stats": {"total": 107, "additions": 89, "deletions": 18}, "files": [{"sha": "64714e0600e0c54f4237de2588e7cb1959e5b690", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=529bc4103b78fa16cbd93d7947724472a4ffb31e", "patch": "@@ -1,3 +1,15 @@\n+2019-08-07  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/91346 - Implement P1668R1, allow unevaluated asm in constexpr.\n+\t* constexpr.c (cxx_eval_constant_expression): Handle ASM_EXPR.\n+\t(potential_constant_expression_1) <case ASM_EXPR>: Allow.\n+\t* cp-tree.h (finish_asm_stmt): Adjust.\n+\t* parser.c (cp_parser_asm_definition): Grab the locaion of \"asm\" and\n+\tuse it.  Change an error to a pedwarn.  Allow asm in C++2a, warn\n+\totherwise.\n+\t* pt.c (tsubst_expr): Pass a location down to finish_asm_stmt.\n+\t* semantics.c (finish_asm_stmt): New location_t parameter.  Use it.\n+\n 2019-08-07  Jakub Jelinek  <jakub@redhat.com>\n \n \t* parser.c (cp_parser_omp_clause_name): Parse use_device_addr clause."}, {"sha": "e86b0789b840b7b34515622d463fc671a52dba18", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=529bc4103b78fa16cbd93d7947724472a4ffb31e", "patch": "@@ -5289,6 +5289,18 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       r = void_node;\n       break;\n \n+    case ASM_EXPR:\n+      if (!ctx->quiet)\n+\t{\n+\t  error_at (cp_expr_loc_or_input_loc (t),\n+\t\t    \"inline assembly is not a constant expression\");\n+\t  inform (cp_expr_loc_or_input_loc (t),\n+\t\t  \"only unevaluated inline assembly is allowed in a \"\n+\t\t  \"%<constexpr%> function in C++2a\");\n+\t}\n+      *non_constant_p = true;\n+      return t;\n+\n     default:\n       if (STATEMENT_CODE_P (TREE_CODE (t)))\n \t{\n@@ -6469,13 +6481,18 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n       /* GCC internal stuff.  */\n     case VA_ARG_EXPR:\n     case TRANSACTION_EXPR:\n-    case ASM_EXPR:\n     case AT_ENCODE_EXPR:\n     fail:\n       if (flags & tf_error)\n \terror_at (loc, \"expression %qE is not a constant expression\", t);\n       return false;\n \n+    case ASM_EXPR:\n+      /* In C++2a, unevaluated inline assembly is permitted in constexpr\n+\t functions.  If it's used in earlier standard modes, we pedwarn in\n+\t cp_parser_asm_definition.  */\n+      return true;\n+\n     case OBJ_TYPE_REF:\n       if (cxx_dialect >= cxx2a)\n \t/* In C++2a virtual calls can be constexpr, don't give up yet.  */"}, {"sha": "72ee1d61e9768cb208e6d7994027cd561a2bddd6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=529bc4103b78fa16cbd93d7947724472a4ffb31e", "patch": "@@ -7052,8 +7052,8 @@ enum {\n extern tree begin_compound_stmt\t\t\t(unsigned int);\n \n extern void finish_compound_stmt\t\t(tree);\n-extern tree finish_asm_stmt\t\t\t(int, tree, tree, tree, tree,\n-\t\t\t\t\t\t tree, bool);\n+extern tree finish_asm_stmt\t\t\t(location_t, int, tree, tree,\n+\t\t\t\t\t\t tree, tree, tree, bool);\n extern tree finish_label_stmt\t\t\t(tree);\n extern void finish_label_decl\t\t\t(tree);\n extern cp_expr finish_parenthesized_expr\t(cp_expr);"}, {"sha": "ccf89f0856f327ced51f4cbcc28f54b3e0bd066d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=529bc4103b78fa16cbd93d7947724472a4ffb31e", "patch": "@@ -19817,16 +19817,18 @@ cp_parser_asm_definition (cp_parser* parser)\n   bool invalid_inputs_p = false;\n   bool invalid_outputs_p = false;\n   required_token missing = RT_NONE;\n+  location_t asm_loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   /* Look for the `asm' keyword.  */\n   cp_parser_require_keyword (parser, RID_ASM, RT_ASM);\n \n+  /* In C++2a, unevaluated inline assembly is permitted in constexpr\n+     functions.  */\n   if (parser->in_function_body\n-      && DECL_DECLARED_CONSTEXPR_P (current_function_decl))\n-    {\n-      error (\"%<asm%> in %<constexpr%> function\");\n-      cp_function_chain->invalid_constexpr = true;\n-    }\n+      && DECL_DECLARED_CONSTEXPR_P (current_function_decl)\n+      && (cxx_dialect < cxx2a))\n+    pedwarn (asm_loc, 0, \"%<asm%> in %<constexpr%> function only available \"\n+\t     \"with %<-std=c++2a%> or %<-std=gnu++2a%>\");\n \n   /* Handle the asm-qualifier-list.  */\n   location_t volatile_loc = UNKNOWN_LOCATION;\n@@ -20032,7 +20034,7 @@ cp_parser_asm_definition (cp_parser* parser)\n       /* Create the ASM_EXPR.  */\n       if (parser->in_function_body)\n \t{\n-\t  asm_stmt = finish_asm_stmt (volatile_p, string, outputs,\n+\t  asm_stmt = finish_asm_stmt (asm_loc, volatile_p, string, outputs,\n \t\t\t\t      inputs, clobbers, labels, inline_p);\n \t  /* If the extended syntax was not used, mark the ASM_EXPR.  */\n \t  if (!extended_p)"}, {"sha": "b03968febb4ea1218b2c07ff1c77460512c943ba", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=529bc4103b78fa16cbd93d7947724472a4ffb31e", "patch": "@@ -17396,8 +17396,9 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t \t\t\t\t\t  complain, in_decl);\n \ttree labels = tsubst_copy_asm_operands (ASM_LABELS (t), args,\n \t\t\t\t\t\tcomplain, in_decl);\n-\ttmp = finish_asm_stmt (ASM_VOLATILE_P (t), string, outputs, inputs,\n-\t\t\t       clobbers, labels, ASM_INLINE_P (t));\n+\ttmp = finish_asm_stmt (EXPR_LOCATION (t), ASM_VOLATILE_P (t), string,\n+\t\t\t       outputs, inputs, clobbers, labels,\n+\t\t\t       ASM_INLINE_P (t));\n \ttree asm_expr = tmp;\n \tif (TREE_CODE (asm_expr) == CLEANUP_POINT_EXPR)\n \t  asm_expr = TREE_OPERAND (asm_expr, 0);"}, {"sha": "8fe632f2239e2278cc84805252707b5b7b0986ff", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=529bc4103b78fa16cbd93d7947724472a4ffb31e", "patch": "@@ -1484,8 +1484,9 @@ finish_compound_stmt (tree stmt)\n    considered volatile, and whether it is asm inline.  */\n \n tree\n-finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n-\t\t tree input_operands, tree clobbers, tree labels, bool inline_p)\n+finish_asm_stmt (location_t loc, int volatile_p, tree string,\n+\t\t tree output_operands, tree input_operands, tree clobbers,\n+\t\t tree labels, bool inline_p)\n {\n   tree r;\n   tree t;\n@@ -1532,7 +1533,7 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n \t\t     effectively const.  */\n \t\t  || (CLASS_TYPE_P (TREE_TYPE (operand))\n \t\t      && C_TYPE_FIELDS_READONLY (TREE_TYPE (operand)))))\n-\t    cxx_readonly_error (input_location, operand, lv_asm);\n+\t    cxx_readonly_error (loc, operand, lv_asm);\n \n \t  tree *op = &operand;\n \t  while (TREE_CODE (*op) == COMPOUND_EXPR)\n@@ -1585,8 +1586,9 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n \t     resolve the overloading.  */\n \t  if (TREE_TYPE (operand) == unknown_type_node)\n \t    {\n-\t      error (\"type of %<asm%> operand %qE could not be determined\",\n-\t\t     TREE_VALUE (t));\n+\t      error_at (loc,\n+\t\t\t\"type of %<asm%> operand %qE could not be determined\",\n+\t\t\tTREE_VALUE (t));\n \t      operand = error_mark_node;\n \t    }\n \n@@ -1634,7 +1636,7 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n \t}\n     }\n \n-  r = build_stmt (input_location, ASM_EXPR, string,\n+  r = build_stmt (loc, ASM_EXPR, string,\n \t\t  output_operands, input_operands,\n \t\t  clobbers, labels);\n   ASM_VOLATILE_P (r) = volatile_p || noutputs == 0;"}, {"sha": "f2e6afc0e8ddf8bba786b2ab0229fedd74a49caf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=529bc4103b78fa16cbd93d7947724472a4ffb31e", "patch": "@@ -1,3 +1,10 @@\n+2019-08-07  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/91346 - Implement P1668R1, allow unevaluated asm in constexpr.\n+\t* g++.dg/cpp2a/inline-asm1.C: New test.\n+\t* g++.dg/cpp2a/inline-asm2.C: New test.\n+\t* g++.dg/cpp1y/constexpr-neg1.C: Adjust dg-error.\n+\n 2019-08-07  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/53796"}, {"sha": "d82dbada1bf1b844b1409245ed6dfd3174f67a32", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-neg1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-neg1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-neg1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-neg1.C?ref=529bc4103b78fa16cbd93d7947724472a4ffb31e", "patch": "@@ -7,7 +7,7 @@ constexpr int f(int i) {\n   thread_local int l = i;\t// { dg-error \"thread_local\" }\n   goto foo;\t\t\t// { dg-error \"goto\" }\n  foo:\n-  asm(\"foo\");\t\t\t// { dg-error \"asm\" }\n+  asm(\"foo\");\t\t\t// { dg-error \"asm\" \"\" { target c++17_down } }\n   int k;\t\t\t// { dg-error \"uninitialized\" }\n   A a;\t\t\t\t// { dg-error \"non-literal\" }\n   return i;"}, {"sha": "a7835c7199e057b2036cd866bd5995c244b16d7e", "filename": "gcc/testsuite/g++.dg/cpp2a/inline-asm1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Finline-asm1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Finline-asm1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Finline-asm1.C?ref=529bc4103b78fa16cbd93d7947724472a4ffb31e", "patch": "@@ -0,0 +1,13 @@\n+// P1668R1: Permit unevaluated inline asm in constexpr functions\n+// PR c++/91346\n+// { dg-do compile { target c++14 } }\n+// { dg-options \"\" }\n+\n+constexpr int\n+foo (int a, int b)\n+{\n+  if (__builtin_is_constant_evaluated ())\n+    return a + b;\n+  asm (\"\"); // { dg-warning \".asm. in .constexpr. function only available with\" \"\" { target c++17_down } }\n+  return a;\n+}"}, {"sha": "6038c111eb077075ef468b6d32670e41e0506d64", "filename": "gcc/testsuite/g++.dg/cpp2a/inline-asm2.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Finline-asm2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/529bc4103b78fa16cbd93d7947724472a4ffb31e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Finline-asm2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Finline-asm2.C?ref=529bc4103b78fa16cbd93d7947724472a4ffb31e", "patch": "@@ -0,0 +1,17 @@\n+// P1668R1: Permit unevaluated inline asm in constexpr functions\n+// PR c++/91346\n+// { dg-do compile { target c++2a } }\n+\n+constexpr int\n+foo (bool b)\n+{\n+  if (b)\n+    return 42;\n+  asm (\"\"); // { dg-error \"inline assembly is not a constant expression\" }\n+// { dg-message \"only unevaluated inline assembly\" \"\" { target *-*-* } .-1 }\n+  return -1;\n+}\n+\n+constexpr int i = foo (true);\n+static_assert(i == 42, \"\");\n+constexpr int j = foo (false); // { dg-message \"in .constexpr. expansion of\" }"}]}