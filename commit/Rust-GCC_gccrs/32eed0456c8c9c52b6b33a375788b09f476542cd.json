{"sha": "32eed0456c8c9c52b6b33a375788b09f476542cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJlZWQwNDU2YzhjOWM1MmI2YjMzYTM3NTc4OGIwOWY0NzY1NDJjZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2007-09-23T09:34:28Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2007-09-23T09:34:28Z"}, "message": "re PR middle-end/28755 (duplicate members of arrays)\n\n\tPR middle-end/28755\n\t* expr.c (expand_constructor): New function.\n\t(expand_expr_real_1) <case CONSTRUCTOR>: Call it.\n\t(expand_expr_real_1) <case ARRAY_REF>: Call it if VALUE is\n\tCONSTRUCTOR.\n\n\t* gcc.dg/pr28755.c: New test.\n\nFrom-SVN: r128685", "tree": {"sha": "b61cf5aa1683abc17ffef926b5895ba08f2bb920", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b61cf5aa1683abc17ffef926b5895ba08f2bb920"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32eed0456c8c9c52b6b33a375788b09f476542cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32eed0456c8c9c52b6b33a375788b09f476542cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32eed0456c8c9c52b6b33a375788b09f476542cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32eed0456c8c9c52b6b33a375788b09f476542cd/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f2531eb6e5d9c62379284931f9994e69718015b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2531eb6e5d9c62379284931f9994e69718015b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2531eb6e5d9c62379284931f9994e69718015b2"}], "stats": {"total": 207, "additions": 138, "deletions": 69}, "files": [{"sha": "33f900f1fb572edfc260d0ee5aaf487b95e8d835", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32eed0456c8c9c52b6b33a375788b09f476542cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32eed0456c8c9c52b6b33a375788b09f476542cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32eed0456c8c9c52b6b33a375788b09f476542cd", "patch": "@@ -1,3 +1,11 @@\n+2007-09-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/28755\n+\t* expr.c (expand_constructor): New function.\n+\t(expand_expr_real_1) <case CONSTRUCTOR>: Call it.\n+\t(expand_expr_real_1) <case ARRAY_REF>: Call it if VALUE is\n+\tCONSTRUCTOR.\n+\n 2007-09-23  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* config/mips/mips.c (dump_constants_1): Generalize to include"}, {"sha": "c7b29b53c942319a0093d438b64bb6a7f46a9841", "filename": "gcc/expr.c", "status": "modified", "additions": 103, "deletions": 69, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32eed0456c8c9c52b6b33a375788b09f476542cd/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32eed0456c8c9c52b6b33a375788b09f476542cd/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=32eed0456c8c9c52b6b33a375788b09f476542cd", "patch": "@@ -6887,6 +6887,89 @@ expand_expr_addr_expr (tree exp, rtx target, enum machine_mode tmode,\n   return result;\n }\n \n+/* Generate code for computing CONSTRUCTOR EXP.\n+   An rtx for the computed value is returned.  If AVOID_TEMP_MEM\n+   is TRUE, instead of creating a temporary variable in memory\n+   NULL is returned and the caller needs to handle it differently.  */\n+\n+static rtx\n+expand_constructor (tree exp, rtx target, enum expand_modifier modifier,\n+\t\t    bool avoid_temp_mem)\n+{\n+  tree type = TREE_TYPE (exp);\n+  enum machine_mode mode = TYPE_MODE (type);\n+\n+  /* Try to avoid creating a temporary at all.  This is possible\n+     if all of the initializer is zero.\n+     FIXME: try to handle all [0..255] initializers we can handle\n+     with memset.  */\n+  if (TREE_STATIC (exp)\n+      && !TREE_ADDRESSABLE (exp)\n+      && target != 0 && mode == BLKmode\n+      && all_zeros_p (exp))\n+    {\n+      clear_storage (target, expr_size (exp), BLOCK_OP_NORMAL);\n+      return target;\n+    }\n+\n+  /* All elts simple constants => refer to a constant in memory.  But\n+     if this is a non-BLKmode mode, let it store a field at a time\n+     since that should make a CONST_INT or CONST_DOUBLE when we\n+     fold.  Likewise, if we have a target we can use, it is best to\n+     store directly into the target unless the type is large enough\n+     that memcpy will be used.  If we are making an initializer and\n+     all operands are constant, put it in memory as well.\n+\n+     FIXME: Avoid trying to fill vector constructors piece-meal.\n+     Output them with output_constant_def below unless we're sure\n+     they're zeros.  This should go away when vector initializers\n+     are treated like VECTOR_CST instead of arrays.  */\n+  if ((TREE_STATIC (exp)\n+       && ((mode == BLKmode\n+\t    && ! (target != 0 && safe_from_p (target, exp, 1)))\n+\t\t  || TREE_ADDRESSABLE (exp)\n+\t\t  || (host_integerp (TYPE_SIZE_UNIT (type), 1)\n+\t\t      && (! MOVE_BY_PIECES_P\n+\t\t\t\t     (tree_low_cst (TYPE_SIZE_UNIT (type), 1),\n+\t\t\t\t      TYPE_ALIGN (type)))\n+\t\t      && ! mostly_zeros_p (exp))))\n+      || ((modifier == EXPAND_INITIALIZER || modifier == EXPAND_CONST_ADDRESS)\n+\t  && TREE_CONSTANT (exp)))\n+    {\n+      rtx constructor;\n+\n+      if (avoid_temp_mem)\n+\treturn NULL_RTX;\n+\n+      constructor = expand_expr_constant (exp, 1, modifier);\n+\n+      if (modifier != EXPAND_CONST_ADDRESS\n+\t  && modifier != EXPAND_INITIALIZER\n+\t  && modifier != EXPAND_SUM)\n+\tconstructor = validize_mem (constructor);\n+\n+      return constructor;\n+    }\n+\n+  /* Handle calls that pass values in multiple non-contiguous\n+     locations.  The Irix 6 ABI has examples of this.  */\n+  if (target == 0 || ! safe_from_p (target, exp, 1)\n+      || GET_CODE (target) == PARALLEL || modifier == EXPAND_STACK_PARM)\n+    {\n+      if (avoid_temp_mem)\n+\treturn NULL_RTX;\n+\n+      target\n+\t= assign_temp (build_qualified_type (type, (TYPE_QUALS (type)\n+\t\t\t\t\t\t    | (TREE_READONLY (exp)\n+\t\t\t\t\t\t       * TYPE_QUAL_CONST))),\n+\t\t       0, TREE_ADDRESSABLE (exp), 1);\n+    }\n+\n+  store_constructor (exp, target, 0, int_expr_size (exp));\n+  return target;\n+}\n+\n \n /* expand_expr: generate code for computing expression EXP.\n    An rtx for the computed value is returned.  The value is never null.\n@@ -7379,71 +7462,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  return const0_rtx;\n \t}\n \n-      /* Try to avoid creating a temporary at all.  This is possible\n-\t if all of the initializer is zero.\n-\t FIXME: try to handle all [0..255] initializers we can handle\n-\t with memset.  */\n-      else if (TREE_STATIC (exp)\n-\t       && !TREE_ADDRESSABLE (exp)\n-\t       && target != 0 && mode == BLKmode\n-\t       && all_zeros_p (exp))\n-\t{\n-\t  clear_storage (target, expr_size (exp), BLOCK_OP_NORMAL);\n-\t  return target;\n-\t}\n-\n-      /* All elts simple constants => refer to a constant in memory.  But\n-\t if this is a non-BLKmode mode, let it store a field at a time\n-\t since that should make a CONST_INT or CONST_DOUBLE when we\n-\t fold.  Likewise, if we have a target we can use, it is best to\n-\t store directly into the target unless the type is large enough\n-\t that memcpy will be used.  If we are making an initializer and\n-\t all operands are constant, put it in memory as well.\n-\n-\tFIXME: Avoid trying to fill vector constructors piece-meal.\n-\tOutput them with output_constant_def below unless we're sure\n-\tthey're zeros.  This should go away when vector initializers\n-\tare treated like VECTOR_CST instead of arrays.\n-      */\n-      else if ((TREE_STATIC (exp)\n-\t\t&& ((mode == BLKmode\n-\t\t     && ! (target != 0 && safe_from_p (target, exp, 1)))\n-\t\t    || TREE_ADDRESSABLE (exp)\n-\t\t    || (host_integerp (TYPE_SIZE_UNIT (type), 1)\n-\t\t\t&& (! MOVE_BY_PIECES_P\n-\t\t\t    (tree_low_cst (TYPE_SIZE_UNIT (type), 1),\n-\t\t\t     TYPE_ALIGN (type)))\n-\t\t\t&& ! mostly_zeros_p (exp))))\n-\t       || ((modifier == EXPAND_INITIALIZER\n-\t\t    || modifier == EXPAND_CONST_ADDRESS)\n-\t\t   && TREE_CONSTANT (exp)))\n-\t{\n-\t  rtx constructor = expand_expr_constant (exp, 1, modifier);\n-\n-\t  if (modifier != EXPAND_CONST_ADDRESS\n-\t      && modifier != EXPAND_INITIALIZER\n-\t      && modifier != EXPAND_SUM)\n-\t    constructor = validize_mem (constructor);\n-\n-\t  return constructor;\n-\t}\n-      else\n-\t{\n-\t  /* Handle calls that pass values in multiple non-contiguous\n-\t     locations.  The Irix 6 ABI has examples of this.  */\n-\t  if (target == 0 || ! safe_from_p (target, exp, 1)\n-\t      || GET_CODE (target) == PARALLEL\n-\t      || modifier == EXPAND_STACK_PARM)\n-\t    target\n-\t      = assign_temp (build_qualified_type (type,\n-\t\t\t\t\t\t   (TYPE_QUALS (type)\n-\t\t\t\t\t\t    | (TREE_READONLY (exp)\n-\t\t\t\t\t\t       * TYPE_QUAL_CONST))),\n-\t\t\t     0, TREE_ADDRESSABLE (exp), 1);\n-\n-\t  store_constructor (exp, target, 0, int_expr_size (exp));\n-\t  return target;\n-\t}\n+      return expand_constructor (exp, target, modifier, false);\n \n     case MISALIGNED_INDIRECT_REF:\n     case ALIGN_INDIRECT_REF:\n@@ -7585,10 +7604,25 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t\t\t      field, value)\n \t\t      if (tree_int_cst_equal (field, index))\n \t\t\t{\n-\t\t\t  if (!TREE_SIDE_EFFECTS (value))\n-\t\t\t    return expand_expr (fold (value), target, tmode,\n-\t\t\t\t\t\tmodifier);\n-\t\t\t  break;\n+\t\t\t  if (TREE_SIDE_EFFECTS (value))\n+\t\t\t    break;\n+\n+\t\t\t  if (TREE_CODE (value) == CONSTRUCTOR)\n+\t\t\t    {\n+\t\t\t      /* If VALUE is a CONSTRUCTOR, this\n+\t\t\t\t optimization is only useful if\n+\t\t\t\t this doesn't store the CONSTRUCTOR\n+\t\t\t\t into memory.  If it does, it is more\n+\t\t\t\t efficient to just load the data from\n+\t\t\t\t the array directly.  */\n+\t\t\t      rtx ret = expand_constructor (value, target,\n+\t\t\t\t\t\t\t    modifier, true);\n+\t\t\t      if (ret == NULL_RTX)\n+\t\t\t\tbreak;\n+\t\t\t    }\n+\n+\t\t\t  return expand_expr (fold (value), target, tmode,\n+\t\t\t\t\t      modifier);\n \t\t\t}\n \t\t  }\n \t\telse if(TREE_CODE (init) == STRING_CST)"}, {"sha": "a6d166095a3af948917b1195295e9b64ef6f3b1a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32eed0456c8c9c52b6b33a375788b09f476542cd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32eed0456c8c9c52b6b33a375788b09f476542cd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=32eed0456c8c9c52b6b33a375788b09f476542cd", "patch": "@@ -1,3 +1,8 @@\n+2007-09-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/28755\n+\t* gcc.dg/pr28755.c: New test.\n+\n 2007-09-23  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* lib/target-supports.exp (check_effective_target_nomips16): New"}, {"sha": "9a01f88d0d986b01fbd0e8ab3ba1b5c4a9959c37", "filename": "gcc/testsuite/gcc.dg/pr28755.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32eed0456c8c9c52b6b33a375788b09f476542cd/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28755.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32eed0456c8c9c52b6b33a375788b09f476542cd/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28755.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr28755.c?ref=32eed0456c8c9c52b6b33a375788b09f476542cd", "patch": "@@ -0,0 +1,22 @@\n+/* PR middle-end/28755 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Os\" } */\n+/* { dg-final { scan-assembler-times \"2112543726\\|7deadbee\" 2 } } */\n+\n+struct S\n+{\n+  void *s1;\n+  unsigned s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;\n+};\n+\n+const struct S array[] = {\n+  { (void *) 0, 60, 640, 2112543726, 39682, 48, 16, 33, 10, 96, 2, 0, 0, 4 },\n+  { (void *) 0, 60, 2112543726, 192, 18251, 16, 33, 10, 96, 2, 0, 0, 4, 212 }\n+};\n+\n+void\n+foo (struct S *x)\n+{\n+  x[0] = array[0];\n+  x[5] = array[1];\n+}"}]}