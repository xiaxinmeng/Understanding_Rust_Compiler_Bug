{"sha": "aabb4cd6c05de7654cb6ea249f0f5b2b4de67b55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFiYjRjZDZjMDVkZTc2NTRjYjZlYTI0OWYwZjViMmI0ZGU2N2I1NQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-05-16T22:44:17Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-05-16T22:44:17Z"}, "message": "class.c (copy_virtuals): New function.\n\n\t* class.c (copy_virtuals): New function.\n\t(build_primary_table): Use it.\n\t(build_secondary_vtable): Likewise.\n\t(modify_vtable_entry): Use NULL_TREE, not integer_zero_node, to\n\tindicate that no vcall offset is required.\n\t(add_virtual_function): Likewise.\n\t(modify_all_vtables): Likewise.\n\t(dfs_finish_vtbls): Adjust call to build_vtbl_initializer.\n\t(dfs_accumulate_vtbl_inits): Likewise.\n\t(build_vtbl_initializer): Make changes to handle construction\n\tvtables.\n\t(dfs_build_vcall_offset_vtbl_entries): Likewise.\n\t(build_rtti_vtbl_entries): Likewise.\n\t(build_vtable_entries): Handle a NULL vcall_index.\n\nFrom-SVN: r33944", "tree": {"sha": "fbe86382d7003d663698d0ae649b737ee64c02e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbe86382d7003d663698d0ae649b737ee64c02e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aabb4cd6c05de7654cb6ea249f0f5b2b4de67b55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aabb4cd6c05de7654cb6ea249f0f5b2b4de67b55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aabb4cd6c05de7654cb6ea249f0f5b2b4de67b55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aabb4cd6c05de7654cb6ea249f0f5b2b4de67b55/comments", "author": null, "committer": null, "parents": [{"sha": "5a1b894d603ef6f071c58025e25570efce0d9e5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a1b894d603ef6f071c58025e25570efce0d9e5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a1b894d603ef6f071c58025e25570efce0d9e5a"}], "stats": {"total": 112, "additions": 85, "deletions": 27}, "files": [{"sha": "569a90aaef586928e04282c0c72b7b1b9609fdec", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabb4cd6c05de7654cb6ea249f0f5b2b4de67b55/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabb4cd6c05de7654cb6ea249f0f5b2b4de67b55/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=aabb4cd6c05de7654cb6ea249f0f5b2b4de67b55", "patch": "@@ -1,3 +1,20 @@\n+2000-05-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (copy_virtuals): New function.\n+\t(build_primary_table): Use it.\n+\t(build_secondary_vtable): Likewise.\n+\t(modify_vtable_entry): Use NULL_TREE, not integer_zero_node, to\n+\tindicate that no vcall offset is required.\n+\t(add_virtual_function): Likewise.\n+\t(modify_all_vtables): Likewise.\n+\t(dfs_finish_vtbls): Adjust call to build_vtbl_initializer.\n+\t(dfs_accumulate_vtbl_inits): Likewise.\n+\t(build_vtbl_initializer): Make changes to handle construction\n+\tvtables.\n+\t(dfs_build_vcall_offset_vtbl_entries): Likewise.\n+\t(build_rtti_vtbl_entries): Likewise.\n+\t(build_vtable_entries): Handle a NULL vcall_index.\n+\n 2000-05-15  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* decl2.c (lang_decode_option): Fix thinko."}, {"sha": "962ef12efd67acc54fa24f6561ab7812a7a8e560", "filename": "gcc/cp/class.c", "status": "modified", "additions": 68, "deletions": 27, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aabb4cd6c05de7654cb6ea249f0f5b2b4de67b55/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aabb4cd6c05de7654cb6ea249f0f5b2b4de67b55/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=aabb4cd6c05de7654cb6ea249f0f5b2b4de67b55", "patch": "@@ -118,7 +118,7 @@ static tree fixed_type_or_null PARAMS ((tree, int *));\n static tree resolve_address_of_overloaded_function PARAMS ((tree, tree, int,\n \t\t\t\t\t\t\t  int, tree));\n static void build_vtable_entry_ref PARAMS ((tree, tree, tree));\n-static tree build_vtbl_initializer PARAMS ((tree, tree, int *));\n+static tree build_vtbl_initializer PARAMS ((tree, tree, tree, tree, int *));\n static int count_fields PARAMS ((tree));\n static int add_fields_to_vec PARAMS ((tree, tree, int));\n static void check_bitfield_decl PARAMS ((tree));\n@@ -176,6 +176,7 @@ static void mark_primary_bases PARAMS ((tree));\n static void clone_constructors_and_destructors PARAMS ((tree));\n static tree build_clone PARAMS ((tree, tree));\n static void update_vtable_entry_for_fn PARAMS ((tree, tree, tree, tree *));\n+static tree copy_virtuals PARAMS ((tree));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -742,6 +743,23 @@ get_vtable_decl (type, complete)\n   return decl;\n }\n \n+/* Returns a copy of the BINFO_VIRTUALS list in BINFO.  The\n+   BV_VCALL_INDEX for each entry is cleared.  */\n+\n+static tree\n+copy_virtuals (binfo)\n+     tree binfo;\n+{\n+  tree copies;\n+  tree t;\n+\n+  copies = copy_list (BINFO_VIRTUALS (binfo));\n+  for (t = copies; t; t = TREE_CHAIN (t))\n+    BV_VCALL_INDEX (t) = NULL_TREE;\n+\n+  return copies;\n+}\n+      \n /* Build the primary virtual function table for TYPE.  If BINFO is\n    non-NULL, build the vtable starting with the initial approximation\n    that it is the same as the one which is the head of the association\n@@ -763,7 +781,7 @@ build_primary_vtable (binfo, type)\n \t   no need to do it again.  */\n \treturn 0;\n       \n-      virtuals = copy_list (BINFO_VIRTUALS (binfo));\n+      virtuals = copy_virtuals (binfo);\n       TREE_TYPE (decl) = TREE_TYPE (get_vtbl_decl_for_binfo (binfo));\n       DECL_SIZE (decl) = TYPE_SIZE (TREE_TYPE (decl));\n       DECL_SIZE_UNIT (decl) = TYPE_SIZE_UNIT (TREE_TYPE (decl));\n@@ -837,7 +855,7 @@ build_secondary_vtable (binfo, for_type)\n   SET_BINFO_NEW_VTABLE_MARKED (binfo, current_class_type);\n   \n   /* Make fresh virtual list, so we can smash it later.  */\n-  BINFO_VIRTUALS (binfo) = copy_list (BINFO_VIRTUALS (binfo));\n+  BINFO_VIRTUALS (binfo) = copy_virtuals (binfo);\n \n   if (TREE_VIA_VIRTUAL (binfo))\n     {\n@@ -1012,7 +1030,7 @@ modify_vtable_entry (t, binfo, fndecl, delta, virtuals)\n \n       base_fndecl = BV_FN (v);\n       BV_DELTA (v) = delta;\n-      BV_VCALL_INDEX (v) = integer_zero_node;\n+      BV_VCALL_INDEX (v) = NULL_TREE;\n       BV_FN (v) = fndecl;\n \n       /* Now assign virtual dispatch information, if unset.  We can\n@@ -1086,7 +1104,6 @@ add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n \n   new_virtual = build_tree_list (NULL_TREE, fndecl);\n   BV_DELTA (new_virtual) = integer_zero_node;\n-  BV_VCALL_INDEX (new_virtual) = integer_zero_node;\n \n   if (DECL_VINDEX (fndecl) == error_mark_node)\n     {\n@@ -2639,7 +2656,7 @@ modify_all_vtables (t, vfuns_p, overridden_virtuals)\n \t      /* We don't need to adjust the `this' pointer when\n \t\t calling this function.  */\n \t      BV_DELTA (*fnsp) = integer_zero_node;\n-\t      BV_VCALL_INDEX (*fnsp) = integer_zero_node;\n+\t      BV_VCALL_INDEX (*fnsp) = NULL_TREE;\n \n \t      /* This is an overridden function not already in our\n \t\t vtable.  Keep it.  */\n@@ -6395,7 +6412,8 @@ dfs_finish_vtbls (binfo, data)\n       && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo))\n       && BINFO_NEW_VTABLE_MARKED (binfo, t))\n     initialize_vtable (binfo, \n-\t\t       build_vtbl_initializer (binfo, t, NULL));\n+\t\t       build_vtbl_initializer (binfo, binfo, t, \n+\t\t\t\t\t       TYPE_BINFO (t), NULL));\n \n   CLEAR_BINFO_NEW_VTABLE_MARKED (binfo, t);\n   SET_BINFO_MARKED (binfo);\n@@ -6465,7 +6483,8 @@ dfs_accumulate_vtbl_inits (binfo, data)\n       int non_fn_entries;\n \n       /* Compute the initializer for this vtable.  */\n-      inits = build_vtbl_initializer (binfo, t, &non_fn_entries);\n+      inits = build_vtbl_initializer (binfo, binfo, t, TYPE_BINFO (t), \n+\t\t\t\t      &non_fn_entries);\n \n       /* Set BINFO_VTABLE to the address where the VPTR should point.  */\n       vtbl = TREE_PURPOSE (l);\n@@ -6492,20 +6511,30 @@ dfs_accumulate_vtbl_inits (binfo, data)\n }\n \n /* Construct the initializer for BINFOs virtual function table.  BINFO\n-   is part of the hierarchy dominated by T.  The value returned is a\n-   TREE_LIST suitable for wrapping in a CONSTRUCTOR to use as the\n-   DECL_INITIAL for a vtable.  If NON_FN_ENTRIES_P is not NULL,\n-   *NON_FN_ENTRIES_P is set to the number of non-function entries in\n-   the vtable.  */\n+   is part of the hierarchy dominated by T.  If we're building a\n+   construction vtable, the ORIGINAL_BINFO is the binfo we should use\n+   to find the actual function pointers to put in the vtable.\n+   Otherwise, ORIGINAL_BINFO should be the same as BINFO.  The\n+   RTTI_DOMINATOR is the BINFO that should be indicated by the RTTI\n+   information in the vtable; it will be a base class of T, rather\n+   than T itself, if we are building a construction vtable.\n+\n+   The value returned is a TREE_LIST suitable for wrapping in a\n+   CONSTRUCTOR to use as the DECL_INITIAL for a vtable.  If\n+   NON_FN_ENTRIES_P is not NULL, *NON_FN_ENTRIES_P is set to the\n+   number of non-function entries in the vtable.  */\n \n static tree\n-build_vtbl_initializer (binfo, t, non_fn_entries_p)\n+build_vtbl_initializer (binfo, original_binfo, t, rtti_binfo,\n+\t\t\tnon_fn_entries_p)\n      tree binfo;\n+     tree original_binfo;\n      tree t;\n+     tree rtti_binfo;\n      int *non_fn_entries_p;\n {\n-  tree v = BINFO_VIRTUALS (binfo);\n-  tree inits = NULL_TREE;\n+  tree v;\n+  tree inits;\n   tree vfun_inits;\n   tree vbase;\n   vcall_offset_data vod;\n@@ -6528,15 +6557,15 @@ build_vtbl_initializer (binfo, t, non_fn_entries_p)\n     CLEAR_BINFO_VTABLE_PATH_MARKED (vbase);\n \n   /* Add entries to the vtable for RTTI.  */\n-  inits = chainon (inits, build_rtti_vtbl_entries (binfo, t));\n+  inits = chainon (inits, build_rtti_vtbl_entries (binfo, rtti_binfo));\n \n   if (non_fn_entries_p)\n     *non_fn_entries_p = list_length (inits);\n \n   /* Go through all the ordinary virtual functions, building up\n      initializers.  */\n   vfun_inits = NULL_TREE;\n-  while (v)\n+  for (v = BINFO_VIRTUALS (original_binfo); v; v = TREE_CHAIN (v))\n     {\n       tree delta;\n       tree vcall_index;\n@@ -6566,9 +6595,6 @@ build_vtbl_initializer (binfo, t, non_fn_entries_p)\n       init = build_vtable_entry (delta, vcall_index, pfn);\n       /* And add it to the chain of initializers.  */\n       vfun_inits = tree_cons (NULL_TREE, init, vfun_inits);\n-\n-      /* Keep going.  */\n-      v = TREE_CHAIN (v);\n     }\n \n   /* The initializers for virtual functions were built up in reverse\n@@ -6749,9 +6775,19 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n \t\t\t\t\t\tBINFO_OFFSET (vod->vbase)))),\n \t\t     binfo_inits);\n \n+      /* If there is already a vcall index, then we are processing a\n+\t construction vtable.  The index should be the same as it was\n+\t when we processed the vtable for the base class.  */\n+      if (BV_VCALL_INDEX (derived_virtuals))\n+\tmy_friendly_assert (tree_int_cst_equal (BV_VCALL_INDEX\n+\t\t\t\t\t\t(derived_virtuals),\n+\t\t\t\t\t\tvod->index),\n+\t\t\t    20000516);\n       /* Keep track of the vtable index where this vcall offset can be\n \t found.  */\n-      BV_VCALL_INDEX (derived_virtuals) = vod->index;\n+      else\n+\tBV_VCALL_INDEX (derived_virtuals) = vod->index;\n+\n       /* The next vcall offset will be found at a more negative\n \t offset.  */\n       vod->index = fold (build (MINUS_EXPR, integer_type_node,\n@@ -6834,15 +6870,16 @@ build_vcall_offset_vtbl_entries (binfo, vod)\n }\n \n /* Return vtbl initializers for the RTTI entries coresponding to the\n-   BINFO's vtable.  BINFO is a part of the hierarchy dominated by \n-   T.  */\n+   BINFO's vtable.  The RTTI entries should indicate the object given\n+   by RTTI_BINFO.  */\n \n static tree\n-build_rtti_vtbl_entries (binfo, t)\n+build_rtti_vtbl_entries (binfo, rtti_binfo)\n      tree binfo;\n-     tree t;\n+     tree rtti_binfo;\n {\n   tree b;\n+  tree t;\n   tree basetype;\n   tree offset;\n   tree decl;\n@@ -6851,6 +6888,7 @@ build_rtti_vtbl_entries (binfo, t)\n \n   basetype = BINFO_TYPE (binfo);\n   inits = NULL_TREE;\n+  t = BINFO_TYPE (rtti_binfo);\n \n   /* For a COM object there is no RTTI entry.  */\n   if (CLASSTYPE_COM_INTERFACE (basetype))\n@@ -6868,7 +6906,7 @@ build_rtti_vtbl_entries (binfo, t)\n \tbreak;\n       b = primary_base;\n     }\n-  offset = size_diffop (size_zero_node, BINFO_OFFSET (b));\n+  offset = size_diffop (BINFO_OFFSET (rtti_binfo), BINFO_OFFSET (b));\n \n   /* The second entry is, in the case of the new ABI, the address of\n      the typeinfo object, or, in the case of the old ABI, a function\n@@ -6928,6 +6966,9 @@ build_vtable_entry (delta, vcall_index, entry)\n      tree vcall_index;\n      tree entry;\n {\n+  if (!vcall_index)\n+    vcall_index = integer_zero_node;\n+\n   if (flag_vtable_thunks)\n     {\n       HOST_WIDE_INT idelta;"}]}