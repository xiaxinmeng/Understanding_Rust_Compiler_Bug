{"sha": "3343cf6a6e3d9567cc5c8f68f19c9ebab8791a50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM0M2NmNmE2ZTNkOTU2N2NjNWM4ZjY4ZjE5YzllYmFiODc5MWE1MA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-04-01T10:38:19Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-04-01T10:38:19Z"}, "message": "re PR target/60604 (GCC incorrectly compiles s_csinh function on MIPS32 (32bit fp))\n\ngcc/\n\tPR rtl-optimization/60604\n\t* recog.c (general_operand): Incorporate REG_CANNOT_CHANGE_MODE_P\n\tcheck from register_operand.\n\t(register_operand): Redefine in terms of general_operand.\n\t(nonmemory_operand): Use register_operand for the non-constant cases.\n\nFrom-SVN: r208984", "tree": {"sha": "493e97a2808505aca0c708435a66764a6b1b1fe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/493e97a2808505aca0c708435a66764a6b1b1fe2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3343cf6a6e3d9567cc5c8f68f19c9ebab8791a50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3343cf6a6e3d9567cc5c8f68f19c9ebab8791a50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3343cf6a6e3d9567cc5c8f68f19c9ebab8791a50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3343cf6a6e3d9567cc5c8f68f19c9ebab8791a50/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fb0aab2335b3b85bde152a36aa72468519a48e56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb0aab2335b3b85bde152a36aa72468519a48e56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb0aab2335b3b85bde152a36aa72468519a48e56"}], "stats": {"total": 83, "additions": 26, "deletions": 57}, "files": [{"sha": "c5c775adc21b7e8b57215ffc30a2e3f54ae241af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3343cf6a6e3d9567cc5c8f68f19c9ebab8791a50/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3343cf6a6e3d9567cc5c8f68f19c9ebab8791a50/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3343cf6a6e3d9567cc5c8f68f19c9ebab8791a50", "patch": "@@ -1,3 +1,11 @@\n+2014-04-01  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\tPR rtl-optimization/60604\n+\t* recog.c (general_operand): Incorporate REG_CANNOT_CHANGE_MODE_P\n+\tcheck from register_operand.\n+\t(register_operand): Redefine in terms of general_operand.\n+\t(nonmemory_operand): Use register_operand for the non-constant cases.\n+\n 2014-04-01  Richard Biener  <rguenther@suse.de>\n \n \t* gimple.h (struct gimple_statement_base): Align subcode to"}, {"sha": "f2647e39aae9fc7b6be8ff969c700a387c75393e", "filename": "gcc/recog.c", "status": "modified", "additions": 18, "deletions": 57, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3343cf6a6e3d9567cc5c8f68f19c9ebab8791a50/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3343cf6a6e3d9567cc5c8f68f19c9ebab8791a50/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=3343cf6a6e3d9567cc5c8f68f19c9ebab8791a50", "patch": "@@ -1023,6 +1023,19 @@ general_operand (rtx op, enum machine_mode mode)\n \t  && MEM_P (sub))\n \treturn 0;\n \n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+      if (REG_P (sub)\n+\t  && REGNO (sub) < FIRST_PSEUDO_REGISTER\n+\t  && REG_CANNOT_CHANGE_MODE_P (REGNO (sub), GET_MODE (sub), mode)\n+\t  && GET_MODE_CLASS (GET_MODE (sub)) != MODE_COMPLEX_INT\n+\t  && GET_MODE_CLASS (GET_MODE (sub)) != MODE_COMPLEX_FLOAT\n+\t  /* LRA can generate some invalid SUBREGS just for matched\n+\t     operand reload presentation.  LRA needs to treat them as\n+\t     valid.  */\n+\t  && ! LRA_SUBREG_P (op))\n+\treturn 0;\n+#endif\n+\n       /* FLOAT_MODE subregs can't be paradoxical.  Combine will occasionally\n \t create such rtl, and we must reject it.  */\n       if (SCALAR_FLOAT_MODE_P (GET_MODE (op))\n@@ -1083,9 +1096,6 @@ address_operand (rtx op, enum machine_mode mode)\n int\n register_operand (rtx op, enum machine_mode mode)\n {\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return 0;\n-\n   if (GET_CODE (op) == SUBREG)\n     {\n       rtx sub = SUBREG_REG (op);\n@@ -1096,41 +1106,12 @@ register_operand (rtx op, enum machine_mode mode)\n \t (Ideally, (SUBREG (MEM)...) should not exist after reload,\n \t but currently it does result from (SUBREG (REG)...) where the\n \t reg went on the stack.)  */\n-      if (! reload_completed && MEM_P (sub))\n-\treturn general_operand (op, mode);\n-\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-      if (REG_P (sub)\n-\t  && REGNO (sub) < FIRST_PSEUDO_REGISTER\n-\t  && REG_CANNOT_CHANGE_MODE_P (REGNO (sub), GET_MODE (sub), mode)\n-\t  && GET_MODE_CLASS (GET_MODE (sub)) != MODE_COMPLEX_INT\n-\t  && GET_MODE_CLASS (GET_MODE (sub)) != MODE_COMPLEX_FLOAT\n-\t  /* LRA can generate some invalid SUBREGS just for matched\n-\t     operand reload presentation.  LRA needs to treat them as\n-\t     valid.  */\n-\t  && ! LRA_SUBREG_P (op))\n-\treturn 0;\n-#endif\n-\n-      /* FLOAT_MODE subregs can't be paradoxical.  Combine will occasionally\n-\t create such rtl, and we must reject it.  */\n-      if (SCALAR_FLOAT_MODE_P (GET_MODE (op))\n-\t  /* LRA can use subreg to store a floating point value in an\n-\t     integer mode.  Although the floating point and the\n-\t     integer modes need the same number of hard registers, the\n-\t     size of floating point mode can be less than the integer\n-\t     mode.  */\n-\t  && ! lra_in_progress \n-\t  && GET_MODE_SIZE (GET_MODE (op)) > GET_MODE_SIZE (GET_MODE (sub)))\n+      if (!REG_P (sub) && (reload_completed || !MEM_P (sub)))\n \treturn 0;\n-\n-      op = sub;\n     }\n-\n-  return (REG_P (op)\n-\t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t      || in_hard_reg_set_p (operand_reg_set,\n-\t\t\t\t    GET_MODE (op), REGNO (op))));\n+  else if (!REG_P (op))\n+    return 0;\n+  return general_operand (op, mode);\n }\n \n /* Return 1 for a register in Pmode; ignore the tested mode.  */\n@@ -1232,27 +1213,7 @@ nonmemory_operand (rtx op, enum machine_mode mode)\n {\n   if (CONSTANT_P (op))\n     return immediate_operand (op, mode);\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return 0;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    {\n-      /* Before reload, we can allow (SUBREG (MEM...)) as a register operand\n-\t because it is guaranteed to be reloaded into one.\n-\t Just make sure the MEM is valid in itself.\n-\t (Ideally, (SUBREG (MEM)...) should not exist after reload,\n-\t but currently it does result from (SUBREG (REG)...) where the\n-\t reg went on the stack.)  */\n-      if (! reload_completed && MEM_P (SUBREG_REG (op)))\n-\treturn general_operand (op, mode);\n-      op = SUBREG_REG (op);\n-    }\n-\n-  return (REG_P (op)\n-\t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t      || in_hard_reg_set_p (operand_reg_set,\n-\t\t\t\t    GET_MODE (op), REGNO (op))));\n+  return register_operand (op, mode);\n }\n \n /* Return 1 if OP is a valid operand that stands for pushing a"}]}