{"sha": "1eaba2f2086b04bb92b153214d970146452b2fb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVhYmEyZjIwODZiMDRiYjkyYjE1MzIxNGQ5NzAxNDY0NTJiMmZiNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-06-29T06:59:35Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-06-29T06:59:35Z"}, "message": "tree-cfg.c (verify_stmt): Add last_in_block parameter.\n\n        * tree-cfg.c (verify_stmt): Add last_in_block parameter.  Verify\n        that eh stmts can throw.\n        (verify_stmts): Update verify_stmt call.\n        (tree_purge_dead_eh_edges, tree_purge_all_dead_eh_edges): New.\n        * tree-eh.c (remove_stmt_from_eh_region): New.\n        (lower_eh_constructs): Fix throw_stmt_table delete routine.\n        (tree_could_trap_p): Match may_trap_p.\n        (maybe_clean_eh_stmt): New.\n        * tree-flow.h: Update decls.\n        * tree-ssa-ccp.c (pass_ccp): Add TODO_verify_stmts.\n        (substitute_and_fold): Clean eh edges.\n        * tree-ssa-dce.c (mark_control_dependent_edges_necessary): Handle\n        empty basic blocks.\n        * tree-ssa-dom.c (need_eh_cleanup): New.\n        (tree_ssa_dominator_optimize): Allocate it.  Cleanup eh edges.\n        (optimize_stmt): Cleanup eh stmts; set need_eh_cleanup.\n\nFrom-SVN: r83843", "tree": {"sha": "017eaae88bfa95da2ee42be01673c3b4ea54a1c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/017eaae88bfa95da2ee42be01673c3b4ea54a1c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1eaba2f2086b04bb92b153214d970146452b2fb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eaba2f2086b04bb92b153214d970146452b2fb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eaba2f2086b04bb92b153214d970146452b2fb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eaba2f2086b04bb92b153214d970146452b2fb4/comments", "author": null, "committer": null, "parents": [{"sha": "afc066ef359fbce1d44025e59c67eeb08aa87a44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afc066ef359fbce1d44025e59c67eeb08aa87a44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afc066ef359fbce1d44025e59c67eeb08aa87a44"}], "stats": {"total": 247, "additions": 223, "deletions": 24}, "files": [{"sha": "854141fed44731a34259ea586f2cbaf01ad0611b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eaba2f2086b04bb92b153214d970146452b2fb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eaba2f2086b04bb92b153214d970146452b2fb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1eaba2f2086b04bb92b153214d970146452b2fb4", "patch": "@@ -1,3 +1,22 @@\n+2004-06-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree-cfg.c (verify_stmt): Add last_in_block parameter.  Verify\n+\tthat eh stmts can throw.\n+\t(verify_stmts): Update verify_stmt call.\n+\t(tree_purge_dead_eh_edges, tree_purge_all_dead_eh_edges): New.\n+\t* tree-eh.c (remove_stmt_from_eh_region): New.\n+\t(lower_eh_constructs): Fix throw_stmt_table delete routine.\n+\t(tree_could_trap_p): Match may_trap_p.\n+\t(maybe_clean_eh_stmt): New.\n+\t* tree-flow.h: Update decls.\n+\t* tree-ssa-ccp.c (pass_ccp): Add TODO_verify_stmts.\n+\t(substitute_and_fold): Clean eh edges.\n+\t* tree-ssa-dce.c (mark_control_dependent_edges_necessary): Handle\n+\tempty basic blocks.\n+\t* tree-ssa-dom.c (need_eh_cleanup): New.\n+\t(tree_ssa_dominator_optimize): Allocate it.  Cleanup eh edges.\n+\t(optimize_stmt): Cleanup eh stmts; set need_eh_cleanup.\n+\t\n 2004-06-29  Alan Modra  <amodra@bigpond.net.au>\n \n \t* function.c (assign_parms): Don't abort with zero size stack"}, {"sha": "88e66f7badce6c3fb4e0688d0bf1f81fb3ccce9a", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 62, "deletions": 5, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eaba2f2086b04bb92b153214d970146452b2fb4/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eaba2f2086b04bb92b153214d970146452b2fb4/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=1eaba2f2086b04bb92b153214d970146452b2fb4", "patch": "@@ -3316,15 +3316,14 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n    TODO: Implement type checking.  */\n \n static bool\n-verify_stmt (tree stmt)\n+verify_stmt (tree stmt, bool last_in_block)\n {\n   tree addr;\n \n   if (!is_gimple_stmt (stmt))\n     {\n       error (\"Is not a valid GIMPLE statement.\");\n-      debug_generic_stmt (stmt);\n-      return true;\n+      goto fail;\n     }\n \n   addr = walk_tree (&stmt, verify_expr, NULL, NULL);\n@@ -3334,7 +3333,30 @@ verify_stmt (tree stmt)\n       return true;\n     }\n \n+  /* If the statement is marked as part of an EH region, then it is\n+     expected that the statement could throw.  Verify that when we\n+     have optimizations that simplify statements such that we prove\n+     that they cannot throw, that we update other data structures\n+     to match.  */\n+  if (lookup_stmt_eh_region (stmt) >= 0)\n+    {\n+      if (!tree_could_throw_p (stmt))\n+\t{\n+\t  error (\"Statement marked for throw, but doesn't.\");\n+\t  goto fail;\n+\t}\n+      if (!last_in_block && tree_can_throw_internal (stmt))\n+\t{\n+\t  error (\"Statement marked for throw in middle of block.\");\n+\t  goto fail;\n+\t}\n+    }\n+\n   return false;\n+\n+ fail:\n+  debug_generic_stmt (stmt);\n+  return true;\n }\n \n \n@@ -3449,10 +3471,11 @@ verify_stmts (void)\n \t    }\n \t}\n \n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); )\n \t{\n \t  tree stmt = bsi_stmt (bsi);\n-\t  err |= verify_stmt (stmt);\n+\t  bsi_next (&bsi);\n+\t  err |= verify_stmt (stmt, bsi_end_p (bsi));\n \t  addr = walk_tree (&stmt, verify_node_sharing, htab, NULL);\n \t  if (addr)\n \t    {\n@@ -4637,6 +4660,40 @@ tree_flow_call_edges_add (sbitmap blocks)\n   return blocks_split;\n }\n \n+bool\n+tree_purge_dead_eh_edges (basic_block bb)\n+{\n+  bool changed = false;\n+  edge e, next;\n+  tree stmt = last_stmt (bb);\n+\n+  if (stmt && tree_can_throw_internal (stmt))\n+    return false;\n+\n+  for (e = bb->succ; e ; e = next)\n+    {\n+      next = e->succ_next;\n+      if (e->flags & EDGE_EH)\n+\t{\n+\t  ssa_remove_edge (e);\n+\t  changed = true;\n+\t}\n+    }\n+\n+  return changed;\n+}\n+\n+bool\n+tree_purge_all_dead_eh_edges (bitmap blocks)\n+{\n+  bool changed = false;\n+  size_t i;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n+    { changed |= tree_purge_dead_eh_edges (BASIC_BLOCK (i)); });\n+\n+  return changed;\n+}\n \n struct cfg_hooks tree_cfg_hooks = {\n   \"tree\","}, {"sha": "c0ddf3e7c3c6c8a6e089bc0cdd88166268be49e0", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 101, "deletions": 10, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eaba2f2086b04bb92b153214d970146452b2fb4/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eaba2f2086b04bb92b153214d970146452b2fb4/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=1eaba2f2086b04bb92b153214d970146452b2fb4", "patch": "@@ -119,7 +119,27 @@ add_stmt_to_eh_region (tree t, int num)\n     abort ();\n   *slot = n;\n }\n-  \n+\n+bool\n+remove_stmt_from_eh_region (tree t)\n+{\n+  struct throw_stmt_node dummy;\n+  void **slot;\n+\n+  if (!throw_stmt_table)\n+    return false;\n+\n+  dummy.stmt = t;\n+  slot = htab_find_slot (throw_stmt_table, &dummy, NO_INSERT);\n+  if (slot)\n+    {\n+      htab_clear_slot (throw_stmt_table, slot);\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n int\n lookup_stmt_eh_region (tree t)\n {\n@@ -1600,7 +1620,8 @@ lower_eh_constructs (void)\n   tree *tp = &DECL_SAVED_TREE (current_function_decl);\n \n   finally_tree = htab_create (31, struct_ptr_hash, struct_ptr_eq, free);\n-  throw_stmt_table = htab_create_ggc (31, struct_ptr_hash, struct_ptr_eq, free);\n+  throw_stmt_table = htab_create_ggc (31, struct_ptr_hash, struct_ptr_eq,\n+\t\t\t\t      ggc_free);\n \n   collect_finally_tree (*tp, NULL);\n \n@@ -1670,15 +1691,32 @@ make_eh_edges (tree stmt)\n \n \n \f\n-/* Return true if the expr can trap, as in dereferencing an\n-   invalid pointer location.  */\n+/* Return true if the expr can trap, as in dereferencing an invalid pointer\n+   location or floating point arithmetic.  C.f. the rtl version, may_trap_p.\n+   This routine expects only GIMPLE lhs or rhs input.  */\n \n bool\n tree_could_trap_p (tree expr)\n {\n   enum tree_code code = TREE_CODE (expr);\n+  bool honor_nans = false;\n+  bool honor_snans = false;\n+  bool fp_operation = false;\n   tree t;\n \n+  if (TREE_CODE_CLASS (code) == '<'\n+      || TREE_CODE_CLASS (code) == '1'\n+      || TREE_CODE_CLASS (code) == '2')\n+    {\n+      t = TREE_TYPE (expr);\n+      fp_operation = FLOAT_TYPE_P (t);\n+      if (fp_operation)\n+\t{\n+\t  honor_nans = flag_trapping_math && !flag_finite_math_only;\n+\t  honor_snans = flag_signaling_nans != 0;\n+\t}\n+    }\n+\n   switch (code)\n     {\n     case ARRAY_REF:\n@@ -1691,7 +1729,10 @@ tree_could_trap_p (tree expr)\n       return !t || tree_could_trap_p (t);\n \n     case INDIRECT_REF:\n-      return (TREE_THIS_NOTRAP (expr) == false);\n+      return !TREE_THIS_NOTRAP (expr);\n+\n+    case ASM_EXPR:\n+      return TREE_THIS_VOLATILE (expr);\n \n     case TRUNC_DIV_EXPR:\n     case CEIL_DIV_EXPR:\n@@ -1702,16 +1743,57 @@ tree_could_trap_p (tree expr)\n     case FLOOR_MOD_EXPR:\n     case ROUND_MOD_EXPR:\n     case TRUNC_MOD_EXPR:\n-      return true;\n+    case RDIV_EXPR:\n+      if (honor_snans)\n+\treturn true;\n+      if (fp_operation && flag_trapping_math)\n+\treturn true;\n+      t = TREE_OPERAND (expr, 1);\n+      if (!TREE_CONSTANT (t) || integer_zerop (t))\n+        return true;\n+      return false;\n+\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case LTGT_EXPR:\n+      /* Some floating point comparisons may trap.  */\n+      return honor_nans;\n+\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case UNORDERED_EXPR:\n+    case ORDERED_EXPR:\n+    case UNLT_EXPR:\n+    case UNLE_EXPR:\n+    case UNGT_EXPR:\n+    case UNGE_EXPR:\n+    case UNEQ_EXPR:\n+      return honor_snans;\n+\n+    case CONVERT_EXPR:\n+    case FIX_TRUNC_EXPR:\n+    case FIX_CEIL_EXPR:\n+    case FIX_FLOOR_EXPR:\n+    case FIX_ROUND_EXPR:\n+      /* Conversion of floating point might trap.  */\n+      return honor_nans;\n+\n+    case NEGATE_EXPR:\n+    case ABS_EXPR:\n+    case CONJ_EXPR:\n+      /* These operations don't trap even with floating point.  */\n+      return false;\n \n     default:\n-      break;\n+      /* Any floating arithmetic may trap.  */\n+      if (fp_operation && flag_trapping_math)\n+\treturn true;\n+      return false;\n     }\n-\n-  return false;\n }\n \n-\n bool\n tree_could_throw_p (tree t)\n {\n@@ -1750,4 +1832,13 @@ tree_can_throw_external (tree stmt)\n   return can_throw_external_1 (region_nr);\n }\n \n+bool\n+maybe_clean_eh_stmt (tree stmt)\n+{\n+  if (!tree_could_throw_p (stmt))\n+    if (remove_stmt_from_eh_region (stmt))\n+      return true;\n+  return false;\n+}\n+\n #include \"gt-tree-eh.h\""}, {"sha": "8b6690b21e7b4af1d5c39c248e5582ade976fbe4", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eaba2f2086b04bb92b153214d970146452b2fb4/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eaba2f2086b04bb92b153214d970146452b2fb4/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=1eaba2f2086b04bb92b153214d970146452b2fb4", "patch": "@@ -497,6 +497,8 @@ extern void compute_dominance_frontiers (bitmap *);\n extern void verify_stmts (void);\n extern tree tree_block_label (basic_block bb);\n extern void extract_true_false_edges_from_block (basic_block, edge *, edge *);\n+extern bool tree_purge_dead_eh_edges (basic_block);\n+extern bool tree_purge_all_dead_eh_edges (bitmap);\n \n /* In tree-pretty-print.c.  */\n extern void dump_generic_bb (FILE *, basic_block, int, int);\n@@ -600,7 +602,10 @@ extern bool tree_could_trap_p (tree);\n extern bool tree_could_throw_p (tree);\n extern bool tree_can_throw_internal (tree);\n extern bool tree_can_throw_external (tree);\n+extern int lookup_stmt_eh_region (tree);\n extern void add_stmt_to_eh_region (tree, int);\n+extern bool remove_stmt_from_eh_region (tree);\n+extern bool maybe_clean_eh_stmt (tree);\n \n /* In tree-ssa-pre.c  */\n void add_to_value (tree, tree);"}, {"sha": "559f19b0765218540e8eedffc1e95ef30e542048", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eaba2f2086b04bb92b153214d970146452b2fb4/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eaba2f2086b04bb92b153214d970146452b2fb4/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=1eaba2f2086b04bb92b153214d970146452b2fb4", "patch": "@@ -248,7 +248,8 @@ struct tree_opt_pass pass_ccp =\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n   TODO_dump_func | TODO_rename_vars\n-    | TODO_ggc_collect | TODO_verify_ssa /* todo_flags_finish */\n+    | TODO_ggc_collect | TODO_verify_ssa\n+    | TODO_verify_stmts\t\t\t/* todo_flags_finish */\n };\n \n \n@@ -427,7 +428,11 @@ substitute_and_fold (void)\n \t      /* If we folded a builtin function, we'll likely\n \t\t need to rename VDEFs.  */\n \t      if (replaced_address || changed)\n-\t\tmark_new_vars_to_rename (stmt, vars_to_rename);\n+\t\t{\n+\t\t  mark_new_vars_to_rename (stmt, vars_to_rename);\n+\t\t  if (maybe_clean_eh_stmt (stmt))\n+\t\t    tree_purge_dead_eh_edges (bb);\n+\t\t}\n \t    }\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "e9ead5c0dfbc4b08a735024e766eb845f5955775", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eaba2f2086b04bb92b153214d970146452b2fb4/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eaba2f2086b04bb92b153214d970146452b2fb4/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=1eaba2f2086b04bb92b153214d970146452b2fb4", "patch": "@@ -500,7 +500,7 @@ mark_control_dependent_edges_necessary (basic_block bb, struct edge_list *el)\n       SET_BIT (last_stmt_necessary, cd_bb->index);\n \n       t = last_stmt (cd_bb);\n-      if (is_ctrl_stmt (t))\n+      if (t && is_ctrl_stmt (t))\n \tmark_stmt_necessary (t, true);\n     });\n }"}, {"sha": "ddd803bc4ba250de3cdbfdbac4a37274fec3cffa", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eaba2f2086b04bb92b153214d970146452b2fb4/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eaba2f2086b04bb92b153214d970146452b2fb4/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=1eaba2f2086b04bb92b153214d970146452b2fb4", "patch": "@@ -95,6 +95,10 @@ static bitmap nonzero_vars;\n /* Track whether or not we have changed the control flow graph.  */\n static bool cfg_altered;\n \n+/* Bitmap of blocks that have had EH statements cleaned.  We should\n+   remove thier dead edges eventually.  */\n+static bitmap need_eh_cleanup;\n+\n /* Statistics for dominator optimizations.  */\n struct opt_stats_d\n {\n@@ -554,6 +558,7 @@ tree_ssa_dominator_optimize (void)\n   nonzero_vars = BITMAP_XMALLOC ();\n   VARRAY_EDGE_INIT (redirection_edges, 20, \"redirection_edges\");\n   VARRAY_GENERIC_PTR_INIT (vrp_data, num_ssa_names, \"vrp_data\");\n+  need_eh_cleanup = BITMAP_XMALLOC ();\n \n   /* Setup callbacks for the generic dominator tree walker.  */\n   walk_data.walk_stmts_backward = false;\n@@ -599,15 +604,24 @@ tree_ssa_dominator_optimize (void)\n       if (VARRAY_ACTIVE_SIZE (redirection_edges) > 0)\n \tredirect_edges_and_update_ssa_graph (redirection_edges);\n \n+      if (bitmap_first_set_bit (need_eh_cleanup) >= 0)\n+\t{\n+\t  cfg_altered = tree_purge_all_dead_eh_edges (need_eh_cleanup);\n+\t  bitmap_zero (need_eh_cleanup);\n+\t}\n+\n       /* We may have made some basic blocks unreachable, remove them.  */\n       cfg_altered |= delete_unreachable_blocks ();\n \n       /* If the CFG was altered, then recompute the dominator tree.  This\n \t is not strictly needed if we only removed unreachable blocks, but\n \t may produce better results.  If we threaded jumps, then rebuilding\n-\t the dominator tree is strictly necessary.  */\n+\t the dominator tree is strictly necessary.  Likewise with EH cleanup.\n+\t Free the dominance info first so that cleanup_tree_cfg doesn't try\n+\t to verify it.  */\n       if (cfg_altered)\n \t{\n+          free_dominance_info (CDI_DOMINATORS);\n \t  cleanup_tree_cfg ();\n \t  calculate_dominance_info (CDI_DOMINATORS);\n \t}\n@@ -656,6 +670,7 @@ tree_ssa_dominator_optimize (void)\n \n   /* Free nonzero_vars.   */\n   BITMAP_XFREE (nonzero_vars);\n+  BITMAP_XFREE (need_eh_cleanup);\n }\n \n static bool\n@@ -2985,8 +3000,7 @@ cprop_into_stmt (tree stmt, varray_type const_and_copies)\n       the variable in the LHS in the CONST_AND_COPIES table.  */\n \n static void\n-optimize_stmt (struct dom_walk_data *walk_data,\n-\t       basic_block bb ATTRIBUTE_UNUSED,\n+optimize_stmt (struct dom_walk_data *walk_data, basic_block bb,\n \t       block_stmt_iterator si)\n {\n   stmt_ann_t ann;\n@@ -3100,11 +3114,19 @@ optimize_stmt (struct dom_walk_data *walk_data,\n       else if (TREE_CODE (stmt) == SWITCH_EXPR)\n \tval = SWITCH_COND (stmt);\n \n-      if (val && TREE_CODE (val) == INTEGER_CST\n-\t  && find_taken_edge (bb_for_stmt (stmt), val))\n+      if (val && TREE_CODE (val) == INTEGER_CST && find_taken_edge (bb, val))\n \tcfg_altered = true;\n+\n+      /* If we simplified a statement in such a way as to be shown that it\n+\t cannot trap, update the eh information and the cfg to match.  */\n+      if (maybe_clean_eh_stmt (stmt))\n+\t{\n+\t  bitmap_set_bit (need_eh_cleanup, bb->index);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"  Flagged to clear EH edges.\\n\");\n+\t}\n     }\n-                                                                                \n+\n   if (may_have_exposed_new_symbols)\n     {\n       if (! bd->stmts_to_rescan)"}]}