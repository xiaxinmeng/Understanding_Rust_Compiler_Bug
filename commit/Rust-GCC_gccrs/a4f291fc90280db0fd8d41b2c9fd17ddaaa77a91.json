{"sha": "a4f291fc90280db0fd8d41b2c9fd17ddaaa77a91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRmMjkxZmM5MDI4MGRiMGZkOGQ0MWIyYzlmZDE3ZGRhYWE3N2E5MQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-08-20T19:52:02Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-08-20T19:52:02Z"}, "message": "jni.cc (nathash, [...]): New globals.\n\n\t* jni.cc (nathash, nathash_count, nathash_size): New globals.\n\t(DELETED_ENTRY): New define.\n\t(hash): New function.\n\t(nathash_find_slot): Likewise.\n\t(natrehash): Likewise.\n\t(nathash_add): Likewise.\n\t(_Jv_JNI_RegisterNatives): No longer interpreter-specific.  Use\n\tnathash_add.\n\t(nathash_find): New function.\n\t(_Jv_LookupJNIMethod): Use it.  Synchronize body.\n\t(call): Synchronize around assignment.\n\nFrom-SVN: r45060", "tree": {"sha": "72ebcb6066ec1399589094123d3264ca44d2b537", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72ebcb6066ec1399589094123d3264ca44d2b537"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4f291fc90280db0fd8d41b2c9fd17ddaaa77a91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4f291fc90280db0fd8d41b2c9fd17ddaaa77a91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4f291fc90280db0fd8d41b2c9fd17ddaaa77a91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4f291fc90280db0fd8d41b2c9fd17ddaaa77a91/comments", "author": null, "committer": null, "parents": [{"sha": "010dc908b299f6e08f7d4101e2fde31a130493db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/010dc908b299f6e08f7d4101e2fde31a130493db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/010dc908b299f6e08f7d4101e2fde31a130493db"}], "stats": {"total": 187, "additions": 166, "deletions": 21}, "files": [{"sha": "b6fa02688e4b07a70ebe5b60e5c2bb3dfe318cae", "filename": "libjava/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4f291fc90280db0fd8d41b2c9fd17ddaaa77a91/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4f291fc90280db0fd8d41b2c9fd17ddaaa77a91/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a4f291fc90280db0fd8d41b2c9fd17ddaaa77a91", "patch": "@@ -1,3 +1,17 @@\n+2001-08-20  Tom Tromey  <tromey@redhat.com>\n+\n+\t* jni.cc (nathash, nathash_count, nathash_size): New globals.\n+\t(DELETED_ENTRY): New define.\n+\t(hash): New function.\n+\t(nathash_find_slot): Likewise.\n+\t(natrehash): Likewise.\n+\t(nathash_add): Likewise.\n+\t(_Jv_JNI_RegisterNatives): No longer interpreter-specific.  Use\n+\tnathash_add.\n+\t(nathash_find): New function.\n+\t(_Jv_LookupJNIMethod): Use it.  Synchronize body.\n+\t(call): Synchronize around assignment.\n+\n 2001-08-17  Jeff Sturm  <jsturm@one-point.com>\n \n \t* gnu/gcj/convert/UnicodeToBytes.java (write): Write work buffer"}, {"sha": "be45cb231605559d42b167eed81fdb6161f9abe5", "filename": "libjava/jni.cc", "status": "modified", "additions": 152, "deletions": 21, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4f291fc90280db0fd8d41b2c9fd17ddaaa77a91/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4f291fc90280db0fd8d41b2c9fd17ddaaa77a91/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=a4f291fc90280db0fd8d41b2c9fd17ddaaa77a91", "patch": "@@ -1543,31 +1543,142 @@ _Jv_JNI_FromReflectedMethod (JNIEnv *, jobject method)\n     _Jv_FromReflectedConstructor (reinterpret_cast<Constructor *> (method));\n }\n \n+\f\n+\n+// Hash table of native methods.\n+static JNINativeMethod *nathash;\n+// Number of slots used.\n+static int nathash_count = 0;\n+// Number of slots available.  Must be power of 2.\n+static int nathash_size = 0;\n+\n+#define DELETED_ENTRY ((char *) (~0))\n+\n+// Compute a hash value for a native method descriptor.\n+static int\n+hash (const JNINativeMethod *method)\n+{\n+  char *ptr;\n+  int hash = 0;\n+\n+  ptr = method->name;\n+  while (*ptr)\n+    hash = (31 * hash) + *ptr++;\n+\n+  ptr = method->signature;\n+  while (*ptr)\n+    hash = (31 * hash) + *ptr++;\n+\n+  return hash;\n+}\n+\n+// Find the slot where a native method goes.\n+static JNINativeMethod *\n+nathash_find_slot (const JNINativeMethod *method)\n+{\n+  jint h = hash (method);\n+  int step = (h ^ (h >> 16)) | 1;\n+  int w = h & (nathash_size - 1);\n+  int del = -1;\n+\n+  for (;;)\n+    {\n+      JNINativeMethod *slotp = &nathash[w];\n+      if (slotp->name == NULL)\n+\t{\n+\t  if (del >= 0)\n+\t    return &nathash[del];\n+\t  else\n+\t    return slotp;\n+\t}\n+      else if (slotp->name == DELETED_ENTRY)\n+\tdel = w;\n+      else if (! strcmp (slotp->name, method->name)\n+\t       && ! strcmp (slotp->signature, method->signature))\n+\treturn slotp;\n+      w = (w + step) & (nathash_size - 1);\n+    }\n+}\n+\n+// Find a method.  Return NULL if it isn't in the hash table.\n+static void *\n+nathash_find (JNINativeMethod *method)\n+{\n+  if (nathash == NULL)\n+    return NULL;\n+  JNINativeMethod *slot = nathash_find_slot (method);\n+  if (slot->name == NULL || slot->name == DELETED_ENTRY)\n+    return NULL;\n+  return slot->fnPtr;\n+}\n+\n+static void\n+natrehash ()\n+{\n+  if (nathash == NULL)\n+    {\n+      nathash_size = 1024;\n+      nathash =\n+\t(JNINativeMethod *) _Jv_AllocBytes (nathash_size\n+\t\t\t\t\t    * sizeof (JNINativeMethod));\n+      memset (nathash, 0, nathash_size * sizeof (JNINativeMethod));\n+    }\n+  else\n+    {\n+      int savesize = nathash_size;\n+      JNINativeMethod *savehash = nathash;\n+      nathash_size *= 2;\n+      nathash =\n+\t(JNINativeMethod *) _Jv_AllocBytes (nathash_size\n+\t\t\t\t\t    * sizeof (JNINativeMethod));\n+      memset (nathash, 0, nathash_size * sizeof (JNINativeMethod));\n+\n+      for (int i = 0; i < savesize; ++i)\n+\t{\n+\t  if (savehash[i].name != NULL && savehash[i].name != DELETED_ENTRY)\n+\t    {\n+\t      JNINativeMethod *slot = nathash_find_slot (&savehash[i]);\n+\t      *slot = savehash[i];\n+\t    }\n+\t}\n+    }\n+}\n+\n+static void\n+nathash_add (const JNINativeMethod *method)\n+{\n+  if (3 * nathash_count >= 2 * nathash_size)\n+    natrehash ();\n+  JNINativeMethod *slot = nathash_find_slot (method);\n+  // If the slot has a real entry in it, then there is no work to do.\n+  if (slot->name != NULL && slot->name != DELETED_ENTRY)\n+    return;\n+  // FIXME\n+  slot->name = strdup (method->name);\n+  slot->signature = strdup (method->signature);\n+  slot->fnPtr = method->fnPtr;\n+}\n+\n static jint\n-_Jv_JNI_RegisterNatives (JNIEnv *env, jclass k,\n+_Jv_JNI_RegisterNatives (JNIEnv *env, jclass klass,\n \t\t\t const JNINativeMethod *methods,\n \t\t\t jint nMethods)\n {\n-#ifdef INTERPRETER\n-  // For now, this only matters for interpreted methods.  FIXME.\n-  if (! _Jv_IsInterpretedClass (k))\n-    {\n-      // FIXME: throw exception.\n-      return JNI_ERR;\n-    }\n-  _Jv_InterpClass *klass = reinterpret_cast<_Jv_InterpClass *> (k);\n+  // Synchronize while we do the work.  This must match\n+  // synchronization in some other functions that manipulate or use\n+  // the nathash table.\n+  JvSynchronize sync (global_ref_table);\n \n   // Look at each descriptor given us, and find the corresponding\n   // method in the class.\n   for (int j = 0; j < nMethods; ++j)\n     {\n       bool found = false;\n \n-      _Jv_MethodBase **imeths = _Jv_GetFirstMethod (klass);\n+      _Jv_Method *imeths = JvGetFirstMethod (klass);\n       for (int i = 0; i < JvNumMethods (klass); ++i)\n \t{\n-\t  _Jv_MethodBase *meth = imeths[i];\n-\t  _Jv_Method *self = meth->get_method ();\n+\t  _Jv_Method *self = &imeths[i];\n \n \t  if (! strcmp (self->name->data, methods[j].name)\n \t      && ! strcmp (self->signature->data, methods[j].signature))\n@@ -1577,9 +1688,9 @@ _Jv_JNI_RegisterNatives (JNIEnv *env, jclass k,\n \t\tbreak;\n \n \t      // Found a match that is native.\n-\t      _Jv_JNIMethod *jmeth = reinterpret_cast<_Jv_JNIMethod *> (meth);\n-\t      jmeth->set_function (methods[i].fnPtr);\n \t      found = true;\n+\t      nathash_add (&methods[j]);\n+\n \t      break;\n \t    }\n \t}\n@@ -1600,14 +1711,12 @@ _Jv_JNI_RegisterNatives (JNIEnv *env, jclass k,\n     }\n \n   return JNI_OK;\n-#else /* INTERPRETER */\n-  return JNI_ERR;\n-#endif /* INTERPRETER */\n }\n \n static jint\n _Jv_JNI_UnregisterNatives (JNIEnv *, jclass)\n {\n+  // FIXME -- we could implement this.\n   return JNI_ERR;\n }\n \n@@ -1751,6 +1860,22 @@ _Jv_LookupJNIMethod (jclass klass, _Jv_Utf8Const *name,\n   int long_start;\n   void *function;\n \n+  // Synchronize on something convenient.  Right now we use the hash.\n+  JvSynchronize sync (global_ref_table);\n+\n+  // First see if we have an override in the hash table.\n+  strncpy (buf, name->data, name->length);\n+  buf[name->length] = '\\0';\n+  strncpy (buf + name->length + 1, signature->data, signature->length);\n+  buf[name->length + signature->length + 1] = '\\0';\n+  JNINativeMethod meth;\n+  meth.name = buf;\n+  meth.signature = buf + name->length + 1;\n+  function = nathash_find (&meth);\n+  if (function != NULL)\n+    return function;\n+\n+  // If there was no override, then look in the symbol table.\n   mangled_name (klass, name, signature, buf, &long_start);\n   char c = buf[long_start];\n   buf[long_start] = '\\0';\n@@ -1787,10 +1912,16 @@ _Jv_JNIMethod::call (ffi_cif *, void *ret, ffi_raw *args, void *__this)\n   // We cache the value that we find, of course, but if we don't find\n   // a value we don't cache that fact -- we might subsequently load a\n   // library which finds the function in question.\n-  if (_this->function == NULL)\n-    _this->function = _Jv_LookupJNIMethod (_this->defining_class,\n-\t\t\t\t\t   _this->self->name,\n-\t\t\t\t\t   _this->self->signature);\n+  {\n+    // Synchronize on a convenient object to ensure sanity in case two\n+    // threads reach this point for the same function at the same\n+    // time.\n+    JvSynchronize sync (global_ref_table);\n+    if (_this->function == NULL)\n+      _this->function = _Jv_LookupJNIMethod (_this->defining_class,\n+\t\t\t\t\t     _this->self->name,\n+\t\t\t\t\t     _this->self->signature);\n+  }\n \n   JvAssert (_this->args_raw_size % sizeof (ffi_raw) == 0);\n   ffi_raw real_args[2 + _this->args_raw_size / sizeof (ffi_raw)];"}]}