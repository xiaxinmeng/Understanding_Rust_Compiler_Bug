{"sha": "f3130d75de9ee11021903011d6ef4452aa2a2bb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMxMzBkNzVkZTllZTExMDIxOTAzMDExZDZlZjQ0NTJhYTJhMmJiNQ==", "commit": {"author": {"name": "Andi Kleen", "email": "ak@suse.de", "date": "2008-03-02T12:09:08Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-03-02T12:09:08Z"}, "message": "struct-equiv.c: Remove file.\n\n2008-03-02  Andi Kleen  <ak@suse.de>\n\tRichard Guenther  <rguenther@suse.de>\n\n\t* struct-equiv.c: Remove file.\n\t* cfg_cleanup.c (condjump_equiv_p): Remove.\n\t* Makefile.in (OBJS-common): Remove struct-equiv.o.\n\t(struct-equiv.o): Remove rule.\n\t* basic-block.h (struct_equiv_checkpoint, STRUCT_EQUIV_*,\n\tinsns_match_p, struct_equiv_block_eq, struct_equiv_init, \n\trtx_equiv_p, condjump_equiv_p): Remove prototypes.\n\nCo-Authored-By: Richard Guenther <rguenther@suse.de>\n\nFrom-SVN: r132814", "tree": {"sha": "783ce3b866cf2b027ecd4951420ee3157eb004be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/783ce3b866cf2b027ecd4951420ee3157eb004be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3130d75de9ee11021903011d6ef4452aa2a2bb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3130d75de9ee11021903011d6ef4452aa2a2bb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3130d75de9ee11021903011d6ef4452aa2a2bb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3130d75de9ee11021903011d6ef4452aa2a2bb5/comments", "author": null, "committer": null, "parents": [{"sha": "363d536b17b212bb02f709bc045c174c53062ef2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/363d536b17b212bb02f709bc045c174c53062ef2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/363d536b17b212bb02f709bc045c174c53062ef2"}], "stats": {"total": 1659, "additions": 11, "deletions": 1648}, "files": [{"sha": "9ed3fc5a54fe1c354deae98d2a4f1c80cbe50ab8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3130d75de9ee11021903011d6ef4452aa2a2bb5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3130d75de9ee11021903011d6ef4452aa2a2bb5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3130d75de9ee11021903011d6ef4452aa2a2bb5", "patch": "@@ -1,3 +1,14 @@\n+2008-03-02  Andi Kleen  <ak@suse.de>\n+\tRichard Guenther  <rguenther@suse.de>\n+\n+\t* struct-equiv.c: Remove file.\n+\t* cfg_cleanup.c (condjump_equiv_p): Remove.\n+\t* Makefile.in (OBJS-common): Remove struct-equiv.o.\n+\t(struct-equiv.o): Remove rule.\n+\t* basic-block.h (struct_equiv_checkpoint, STRUCT_EQUIV_*,\n+\tinsns_match_p, struct_equiv_block_eq, struct_equiv_init, \n+\trtx_equiv_p, condjump_equiv_p): Remove prototypes.\n+\n 2008-03-01  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* ifcvt.c (noce_process_if_block): Try to handle only the then"}, {"sha": "6b8aab3ea80a5cef9da1405c172bb6ee379f13a3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3130d75de9ee11021903011d6ef4452aa2a2bb5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3130d75de9ee11021903011d6ef4452aa2a2bb5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f3130d75de9ee11021903011d6ef4452aa2a2bb5", "patch": "@@ -1138,7 +1138,6 @@ OBJS-common = \\\n \tstmt.o \\\n \tstor-layout.o \\\n \tstringpool.o \\\n-\tstruct-equiv.o \\\n \ttarghooks.o \\\n \ttimevar.o \\\n \ttoplev.o \\\n@@ -2677,10 +2676,6 @@ cfgloopanal.o : cfgloopanal.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(OBSTACK_H) output.h graphds.h\n graphds.o : graphds.c graphds.h $(CONFIG_H) $(SYSTEM_H) bitmap.h $(OBSTACK_H) \\\n    coretypes.h vec.h vecprim.h\n-struct-equiv.o : struct-equiv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(RTL_H) hard-reg-set.h output.h $(FLAGS_H) $(RECOG_H) \\\n-   insn-config.h $(TARGET_H) $(TM_P_H) $(PARAMS_H) \\\n-   $(REGS_H) $(EMIT_RTL_H) $(DF_H)\n loop-iv.o : loop-iv.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(BASIC_BLOCK_H) \\\n    hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) coretypes.h $(TM_H) $(OBSTACK_H) \\\n    output.h intl.h $(DF_H) $(HASHTAB_H)"}, {"sha": "4955b5e3ad3dd3df59a9e14fe22a8740d952bf89", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 176, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3130d75de9ee11021903011d6ef4452aa2a2bb5/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3130d75de9ee11021903011d6ef4452aa2a2bb5/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=f3130d75de9ee11021903011d6ef4452aa2a2bb5", "patch": "@@ -805,17 +805,6 @@ edge find_edge (basic_block, basic_block);\n \t\t\t\t\t   insns.  */\n #define CLEANUP_CFGLAYOUT\t32\t/* Do cleanup in cfglayout mode.  */\n \n-/* The following are ORed in on top of the CLEANUP* flags in calls to\n-   struct_equiv_block_eq.  */\n-#define STRUCT_EQUIV_START\t64\t /* Initializes the search range.  */\n-#define STRUCT_EQUIV_RERUN\t128\t/* Rerun to find register use in\n-\t\t\t\t\t   found equivalence.  */\n-#define STRUCT_EQUIV_FINAL\t256\t/* Make any changes necessary to get\n-\t\t\t\t\t   actual equivalence.  */\n-#define STRUCT_EQUIV_NEED_FULL_BLOCK 512 /* struct_equiv_block_eq is required\n-\t\t\t\t\t     to match only full blocks  */\n-#define STRUCT_EQUIV_MATCH_JUMPS 1024\t/* Also include the jumps at the end of the block in the comparison.  */\n-\n /* In lcm.c */\n extern struct edge_list *pre_edge_lcm (int, sbitmap *, sbitmap *,\n \t\t\t\t       sbitmap *, sbitmap *, sbitmap **,\n@@ -955,171 +944,6 @@ extern rtx insert_insn_end_bb_new (rtx, basic_block);\n \n #include \"cfghooks.h\"\n \n-/* In struct-equiv.c */\n-\n-/* Constants used to size arrays in struct equiv_info (currently only one).\n-   When these limits are exceeded, struct_equiv returns zero.\n-   The maximum number of pseudo registers that are different in the two blocks,\n-   but appear in equivalent places and are dead at the end (or where one of\n-   a pair is dead at the end).  */\n-#define STRUCT_EQUIV_MAX_LOCAL 16\n-/* The maximum number of references to an input register that struct_equiv\n-   can handle.  */\n-\n-/* Structure used to track state during struct_equiv that can be rolled\n-   back when we find we can't match an insn, or if we want to match part\n-   of it in a different way.\n-   This information pertains to the pair of partial blocks that has been\n-   matched so far.  Since this pair is structurally equivalent, this is\n-   conceptually just one partial block expressed in two potentially\n-   different ways.  */\n-struct struct_equiv_checkpoint\n-{\n-  int ninsns;       /* Insns are matched so far.  */\n-  int local_count;  /* Number of block-local registers.  */\n-  int input_count;  /* Number of inputs to the block.  */\n-\n-  /* X_START and Y_START are the first insns (in insn stream order)\n-     of the partial blocks that have been considered for matching so far.\n-     Since we are scanning backwards, they are also the instructions that\n-     are currently considered - or the last ones that have been considered -\n-     for matching (Unless we tracked back to these because a preceding\n-     instruction failed to match).  */\n-  rtx x_start, y_start;\n-\n-  /*  INPUT_VALID indicates if we have actually set up X_INPUT / Y_INPUT\n-      during the current pass; we keep X_INPUT / Y_INPUT around between passes\n-      so that we can match REG_EQUAL / REG_EQUIV notes referring to these.  */\n-  bool input_valid;\n-\n-  /* Some information would be expensive to exactly checkpoint, so we\n-     merely increment VERSION any time information about local\n-     registers, inputs and/or register liveness changes.  When backtracking,\n-     it is decremented for changes that can be undone, and if a discrepancy\n-     remains, NEED_RERUN in the relevant struct equiv_info is set to indicate\n-     that a new pass should be made over the entire block match to get\n-     accurate register information.  */\n-  int version;\n-};\n-\n-/* A struct equiv_info is used to pass information to struct_equiv and\n-   to gather state while two basic blocks are checked for structural\n-   equivalence.  */\n-\n-struct equiv_info\n-{\n-  /* Fields set up by the caller to struct_equiv_block_eq */\n-\n-  basic_block x_block, y_block;  /* The two blocks being matched.  */\n-\n-  /* MODE carries the mode bits from cleanup_cfg if we are called from\n-     try_crossjump_to_edge, and additionally it carries the\n-     STRUCT_EQUIV_* bits described above.  */\n-  int mode;\n-\n-  /* INPUT_COST is the cost that adding an extra input to the matched blocks\n-     is supposed to have, and is taken into account when considering if the\n-     matched sequence should be extended backwards.  input_cost < 0 means\n-     don't accept any inputs at all.  */\n-  int input_cost;\n-\n-\n-  /* Fields to track state inside of struct_equiv_block_eq.  Some of these\n-     are also outputs.  */\n-\n-  /* X_INPUT and Y_INPUT are used by struct_equiv to record a register that\n-     is used as an input parameter, i.e. where different registers are used\n-     as sources.  This is only used for a register that is live at the end\n-     of the blocks, or in some identical code at the end of the blocks;\n-     Inputs that are dead at the end go into X_LOCAL / Y_LOCAL.  */\n-  rtx x_input, y_input;\n-  /* When a previous pass has identified a valid input, INPUT_REG is set\n-     by struct_equiv_block_eq, and it is henceforth replaced in X_BLOCK\n-     for the input.  */\n-  rtx input_reg;\n-\n-  /* COMMON_LIVE keeps track of the registers which are currently live\n-     (as we scan backwards from the end) and have the same numbers in both\n-     blocks.  N.B. a register that is in common_live is unsuitable to become\n-     a local reg.  */\n-  regset common_live;\n-  /* Likewise, X_LOCAL_LIVE / Y_LOCAL_LIVE keep track of registers that are\n-     local to one of the blocks; these registers must not be accepted as\n-     identical when encountered in both blocks.  */\n-  regset x_local_live, y_local_live;\n-\n-  /* EQUIV_USED indicates for which insns a REG_EQUAL or REG_EQUIV note is\n-     being used, to avoid having to backtrack in the next pass, so that we\n-     get accurate life info for this insn then.  For each such insn,\n-     the bit with the number corresponding to the CUR.NINSNS value at the\n-     time of scanning is set.  */\n-  bitmap equiv_used;\n-\n-  /* Current state that can be saved & restored easily.  */\n-  struct struct_equiv_checkpoint cur;\n-  /* BEST_MATCH is used to store the best match so far, weighing the\n-     cost of matched insns COSTS_N_INSNS (CUR.NINSNS) against the cost\n-     CUR.INPUT_COUNT * INPUT_COST of setting up the inputs.  */\n-  struct struct_equiv_checkpoint best_match;\n-  /* If a checkpoint restore failed, or an input conflict newly arises,\n-     NEED_RERUN is set.  This has to be tested by the caller to re-run\n-     the comparison if the match appears otherwise sound.  The state kept in\n-     x_start, y_start, equiv_used and check_input_conflict ensures that\n-     we won't loop indefinitely.  */\n-  bool need_rerun;\n-  /* If there is indication of an input conflict at the end,\n-     CHECK_INPUT_CONFLICT is set so that we'll check for input conflicts\n-     for each insn in the next pass.  This is needed so that we won't discard\n-     a partial match if there is a longer match that has to be abandoned due\n-     to an input conflict.  */\n-  bool check_input_conflict;\n-  /* HAD_INPUT_CONFLICT is set if CHECK_INPUT_CONFLICT was already set and we\n-     have passed a point where there were multiple dying inputs.  This helps\n-     us decide if we should set check_input_conflict for the next pass.  */\n-  bool had_input_conflict;\n-\n-  /* LIVE_UPDATE controls if we want to change any life info at all.  We\n-     set it to false during REG_EQUAL / REG_EUQIV note comparison of the final\n-     pass so that we don't introduce new registers just for the note; if we\n-     can't match the notes without the current register information, we drop\n-     them.  */\n-  bool live_update;\n-\n-  /* X_LOCAL and Y_LOCAL are used to gather register numbers of register pairs\n-     that are local to X_BLOCK and Y_BLOCK, with CUR.LOCAL_COUNT being the index\n-     to the next free entry.  */\n-  rtx x_local[STRUCT_EQUIV_MAX_LOCAL], y_local[STRUCT_EQUIV_MAX_LOCAL];\n-  /* LOCAL_RVALUE is nonzero if the corresponding X_LOCAL / Y_LOCAL entry\n-     was a source operand (including STRICT_LOW_PART) for the last invocation\n-     of struct_equiv mentioning it, zero if it was a destination-only operand.\n-     Since we are scanning backwards, this means the register is input/local\n-     for the (partial) block scanned so far.  */\n-  bool local_rvalue[STRUCT_EQUIV_MAX_LOCAL];\n-\n-\n-  /* Additional fields that are computed for the convenience of the caller.  */\n-\n-  /* DYING_INPUTS is set to the number of local registers that turn out\n-     to be inputs to the (possibly partial) block.  */\n-  int dying_inputs;\n-  /* X_END and Y_END are the last insns in X_BLOCK and Y_BLOCK, respectively,\n-     that are being compared.  A final jump insn will not be included.  */\n-  rtx x_end, y_end;\n-\n-  /* If we are matching tablejumps, X_LABEL in X_BLOCK corresponds to\n-     Y_LABEL in Y_BLOCK.  */\n-  rtx x_label, y_label;\n-\n-};\n-\n-extern bool insns_match_p (rtx, rtx, struct equiv_info *);\n-extern int struct_equiv_block_eq (int, struct equiv_info *);\n-extern bool struct_equiv_init (int, struct equiv_info *);\n-extern bool rtx_equiv_p (rtx *, rtx, int, struct equiv_info *);\n-\n-/* In cfgcleanup.c */\n-extern bool condjump_equiv_p (struct equiv_info *, bool);\n-\n /* Return true when one of the predecessor edges of BB is marked with EDGE_EH.  */\n static inline bool\n bb_has_eh_pred (basic_block bb)"}, {"sha": "a95204cf4fc498472f3d42f1b0eef0deda4fa735", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3130d75de9ee11021903011d6ef4452aa2a2bb5/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3130d75de9ee11021903011d6ef4452aa2a2bb5/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=f3130d75de9ee11021903011d6ef4452aa2a2bb5", "patch": "@@ -1134,134 +1134,6 @@ flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,\n   return ninsns;\n }\n \n-/* Return true iff the condbranches at the end of BB1 and BB2 match.  */\n-bool\n-condjump_equiv_p (struct equiv_info *info, bool call_init)\n-{\n-  basic_block bb1 = info->x_block;\n-  basic_block bb2 = info->y_block;\n-  edge b1 = BRANCH_EDGE (bb1);\n-  edge b2 = BRANCH_EDGE (bb2);\n-  edge f1 = FALLTHRU_EDGE (bb1);\n-  edge f2 = FALLTHRU_EDGE (bb2);\n-  bool reverse, match;\n-  rtx set1, set2, cond1, cond2;\n-  rtx src1, src2;\n-  enum rtx_code code1, code2;\n-\n-  /* Get around possible forwarders on fallthru edges.  Other cases\n-     should be optimized out already.  */\n-  if (FORWARDER_BLOCK_P (f1->dest))\n-    f1 = single_succ_edge (f1->dest);\n-\n-  if (FORWARDER_BLOCK_P (f2->dest))\n-    f2 = single_succ_edge (f2->dest);\n-\n-  /* To simplify use of this function, return false if there are\n-     unneeded forwarder blocks.  These will get eliminated later\n-     during cleanup_cfg.  */\n-  if (FORWARDER_BLOCK_P (f1->dest)\n-      || FORWARDER_BLOCK_P (f2->dest)\n-      || FORWARDER_BLOCK_P (b1->dest)\n-      || FORWARDER_BLOCK_P (b2->dest))\n-    return false;\n-\n-  if (f1->dest == f2->dest && b1->dest == b2->dest)\n-    reverse = false;\n-  else if (f1->dest == b2->dest && b1->dest == f2->dest)\n-    reverse = true;\n-  else\n-    return false;\n-\n-  set1 = pc_set (BB_END (bb1));\n-  set2 = pc_set (BB_END (bb2));\n-  if ((XEXP (SET_SRC (set1), 1) == pc_rtx)\n-      != (XEXP (SET_SRC (set2), 1) == pc_rtx))\n-    reverse = !reverse;\n-\n-  src1 = SET_SRC (set1);\n-  src2 = SET_SRC (set2);\n-  cond1 = XEXP (src1, 0);\n-  cond2 = XEXP (src2, 0);\n-  code1 = GET_CODE (cond1);\n-  if (reverse)\n-    code2 = reversed_comparison_code (cond2, BB_END (bb2));\n-  else\n-    code2 = GET_CODE (cond2);\n-\n-  if (code2 == UNKNOWN)\n-    return false;\n-\n-  if (call_init && !struct_equiv_init (STRUCT_EQUIV_START | info->mode, info))\n-    gcc_unreachable ();\n-  /* Make the sources of the pc sets unreadable so that when we call\n-     insns_match_p it won't process them.\n-     The death_notes_match_p from insns_match_p won't see the local registers\n-     used for the pc set, but that could only cause missed optimizations when\n-     there are actually condjumps that use stack registers.  */\n-  SET_SRC (set1) = pc_rtx;\n-  SET_SRC (set2) = pc_rtx;\n-  /* Verify codes and operands match.  */\n-  if (code1 == code2)\n-    {\n-      match = (insns_match_p (BB_END (bb1), BB_END (bb2), info)\n-\t       && rtx_equiv_p (&XEXP (cond1, 0), XEXP (cond2, 0), 1, info)\n-\t       && rtx_equiv_p (&XEXP (cond1, 1), XEXP (cond2, 1), 1, info));\n-\n-    }\n-  else if (code1 == swap_condition (code2))\n-    {\n-      match = (insns_match_p (BB_END (bb1), BB_END (bb2), info)\n-\t       && rtx_equiv_p (&XEXP (cond1, 1), XEXP (cond2, 0), 1, info)\n-\t       && rtx_equiv_p (&XEXP (cond1, 0), XEXP (cond2, 1), 1, info));\n-\n-    }\n-  else\n-    match = false;\n-  SET_SRC (set1) = src1;\n-  SET_SRC (set2) = src2;\n-  match &= verify_changes (0);\n-\n-  /* If we return true, we will join the blocks.  Which means that\n-     we will only have one branch prediction bit to work with.  Thus\n-     we require the existing branches to have probabilities that are\n-     roughly similar.  */\n-  if (match\n-      && !optimize_size\n-      && maybe_hot_bb_p (bb1)\n-      && maybe_hot_bb_p (bb2))\n-    {\n-      int prob2;\n-\n-      if (b1->dest == b2->dest)\n-\tprob2 = b2->probability;\n-      else\n-\t/* Do not use f2 probability as f2 may be forwarded.  */\n-\tprob2 = REG_BR_PROB_BASE - b2->probability;\n-\n-      /* Fail if the difference in probabilities is greater than 50%.\n-\t This rules out two well-predicted branches with opposite\n-\t outcomes.  */\n-      if (abs (b1->probability - prob2) > REG_BR_PROB_BASE / 2)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \"Outcomes of branch in bb %i and %i differ too much (%i %i)\\n\",\n-\t\t     bb1->index, bb2->index, b1->probability, prob2);\n-\n-\t  match = false;\n-\t}\n-    }\n-\n-  if (dump_file && match)\n-    fprintf (dump_file, \"Conditionals in bb %i and %i match.\\n\",\n-\t     bb1->index, bb2->index);\n-\n-  if (!match)\n-    cancel_changes (0);\n-  return match;\n-}\n-\n /* Return true iff outgoing edges of BB1 and BB2 match, together with\n    the branch instruction.  This means that if we commonize the control\n    flow before end of the basic block, the semantic remains unchanged."}, {"sha": "6675e5bf71bc32748758e6d9606d1f24765e1715", "filename": "gcc/struct-equiv.c", "status": "removed", "additions": 0, "deletions": 1339, "changes": 1339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/363d536b17b212bb02f709bc045c174c53062ef2/gcc%2Fstruct-equiv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/363d536b17b212bb02f709bc045c174c53062ef2/gcc%2Fstruct-equiv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstruct-equiv.c?ref=363d536b17b212bb02f709bc045c174c53062ef2", "patch": "@@ -1,1339 +0,0 @@\n-/* Control flow optimization code for GNU compiler.\n-   Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n-   Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* Try to match two basic blocks - or their ends - for structural equivalence.\n-   We scan the blocks from their ends backwards, and expect that insns are\n-   identical, except for certain cases involving registers.  A mismatch\n-   We scan the blocks from their ends backwards, hoping to find a match, I.e.\n-   insns are identical, except for certain cases involving registers.  A\n-   mismatch between register number RX (used in block X) and RY (used in the\n-   same way in block Y) can be handled in one of the following cases:\n-   1. RX and RY are local to their respective blocks; they are set there and\n-      die there.  If so, they can effectively be ignored.\n-   2. RX and RY die in their blocks, but live at the start.  If any path\n-      gets redirected through X instead of Y, the caller must emit\n-      compensation code to move RY to RX.  If there are overlapping inputs,\n-      the function resolve_input_conflict ensures that this can be done.\n-      Information about these registers are tracked in the X_LOCAL, Y_LOCAL,\n-      LOCAL_COUNT and LOCAL_RVALUE fields.\n-   3. RX and RY live throughout their blocks, including the start and the end.\n-      Either RX and RY must be identical, or we have to replace all uses in\n-      block X with a new pseudo, which is stored in the INPUT_REG field.  The\n-      caller can then use block X instead of block Y by copying RY to the new\n-      pseudo.\n-\n-   The main entry point to this file is struct_equiv_block_eq.  This function\n-   uses a struct equiv_info to accept some of its inputs, to keep track of its\n-   internal state, to pass down to its helper functions, and to communicate\n-   some of the results back to the caller.\n-\n-   Most scans will result in a failure to match a sufficient number of insns\n-   to make any optimization worth while, therefore the process is geared more\n-   to quick scanning rather than the ability to exactly backtrack when we\n-   find a mismatch.  The information gathered is still meaningful to make a\n-   preliminary decision if we want to do an optimization, we might only\n-   slightly overestimate the number of matchable insns, and underestimate\n-   the number of inputs an miss an input conflict.  Sufficient information\n-   is gathered so that when we make another pass, we won't have to backtrack\n-   at the same point.\n-   Another issue is that information in memory attributes and/or REG_NOTES\n-   might have to be merged or discarded to make a valid match.  We don't want\n-   to discard such information when we are not certain that we want to merge\n-   the two (partial) blocks.\n-   For these reasons, struct_equiv_block_eq has to be called first with the\n-   STRUCT_EQUIV_START bit set in the mode parameter.  This will calculate the\n-   number of matched insns and the number and types of inputs.  If the\n-   need_rerun field is set, the results are only tentative, and the caller\n-   has to call again with STRUCT_EQUIV_RERUN till need_rerun is false in\n-   order to get a reliable match.\n-   To install the changes necessary for the match, the function has to be\n-   called again with STRUCT_EQUIV_FINAL.\n-\n-   While scanning an insn, we process first all the SET_DESTs, then the\n-   SET_SRCes, then the REG_NOTES, in order to keep the register liveness\n-   information consistent.\n-   If we were to mix up the order for sources / destinations in an insn where\n-   a source is also a destination, we'd end up being mistaken to think that\n-   the register is not live in the preceding insn.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"output.h\"\n-#include \"insn-config.h\"\n-#include \"flags.h\"\n-#include \"recog.h\"\n-#include \"tm_p.h\"\n-#include \"target.h\"\n-#include \"emit-rtl.h\"\n-#include \"reload.h\"\n-#include \"df.h\"\n-\n-static void merge_memattrs (rtx, rtx);\n-static bool set_dest_equiv_p (rtx x, rtx y, struct equiv_info *info);\n-static bool set_dest_addr_equiv_p (rtx x, rtx y, struct equiv_info *info);\n-static void find_dying_inputs (struct equiv_info *info);\n-static bool resolve_input_conflict (struct equiv_info *info);\n-\n-/* After reload, some moves, as indicated by SECONDARY_RELOAD_CLASS and\n-   SECONDARY_MEMORY_NEEDED, cannot be done directly.  For our purposes, we\n-   consider them impossible to generate after reload (even though some\n-   might be synthesized when you throw enough code at them).\n-   Since we don't know while processing a cross-jump if a local register\n-   that is currently live will eventually be live and thus be an input,\n-   we keep track of potential inputs that would require an impossible move\n-   by using a prohibitively high cost for them.\n-   This number, multiplied with the larger of STRUCT_EQUIV_MAX_LOCAL and\n-   FIRST_PSEUDO_REGISTER, must fit in the input_cost field of\n-   struct equiv_info.  */\n-#define IMPOSSIBLE_MOVE_FACTOR 20000\n-\n-\f\n-\n-/* Removes the memory attributes of MEM expression\n-   if they are not equal.  */\n-\n-void\n-merge_memattrs (rtx x, rtx y)\n-{\n-  int i;\n-  int j;\n-  enum rtx_code code;\n-  const char *fmt;\n-\n-  if (x == y)\n-    return;\n-  if (x == 0 || y == 0)\n-    return;\n-\n-  code = GET_CODE (x);\n-\n-  if (code != GET_CODE (y))\n-    return;\n-\n-  if (GET_MODE (x) != GET_MODE (y))\n-    return;\n-\n-  if (code == MEM && MEM_ATTRS (x) != MEM_ATTRS (y))\n-    {\n-      if (! MEM_ATTRS (x))\n-\tMEM_ATTRS (y) = 0;\n-      else if (! MEM_ATTRS (y))\n-\tMEM_ATTRS (x) = 0;\n-      else\n-\t{\n-\t  rtx mem_size;\n-\n-\t  if (MEM_ALIAS_SET (x) != MEM_ALIAS_SET (y))\n-\t    {\n-\t      set_mem_alias_set (x, 0);\n-\t      set_mem_alias_set (y, 0);\n-\t    }\n-\n-\t  if (! mem_expr_equal_p (MEM_EXPR (x), MEM_EXPR (y)))\n-\t    {\n-\t      set_mem_expr (x, 0);\n-\t      set_mem_expr (y, 0);\n-\t      set_mem_offset (x, 0);\n-\t      set_mem_offset (y, 0);\n-\t    }\n-\t  else if (MEM_OFFSET (x) != MEM_OFFSET (y))\n-\t    {\n-\t      set_mem_offset (x, 0);\n-\t      set_mem_offset (y, 0);\n-\t    }\n-\n-\t  if (!MEM_SIZE (x))\n-\t    mem_size = NULL_RTX;\n-\t  else if (!MEM_SIZE (y))\n-\t    mem_size = NULL_RTX;\n-\t  else\n-\t    mem_size = GEN_INT (MAX (INTVAL (MEM_SIZE (x)),\n-\t\t\t\t     INTVAL (MEM_SIZE (y))));\n-\t  set_mem_size (x, mem_size);\n-\t  set_mem_size (y, mem_size);\n-\n-\t  set_mem_align (x, MIN (MEM_ALIGN (x), MEM_ALIGN (y)));\n-\t  set_mem_align (y, MEM_ALIGN (x));\n-\t}\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      switch (fmt[i])\n-\t{\n-\tcase 'E':\n-\t  /* Two vectors must have the same length.  */\n-\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n-\t    return;\n-\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    merge_memattrs (XVECEXP (x, i, j), XVECEXP (y, i, j));\n-\n-\t  break;\n-\n-\tcase 'e':\n-\t  merge_memattrs (XEXP (x, i), XEXP (y, i));\n-\t}\n-    }\n-  return;\n-}\n-\n-/* In SET, assign the bit for the register number of REG the value VALUE.\n-   If REG is a hard register, do so for all its constituent registers.\n-   Return the number of registers that have become included (as a positive\n-   number) or excluded (as a negative number).  */\n-static int\n-assign_reg_reg_set (regset set, rtx reg, int value)\n-{\n-  unsigned regno = REGNO (reg);\n-  int nregs, i, old;\n-\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    {\n-      gcc_assert (!reload_completed);\n-      nregs = 1;\n-    }\n-  else\n-    nregs = hard_regno_nregs[regno][GET_MODE (reg)];\n-  for (old = 0, i = nregs; --i >= 0; regno++)\n-    {\n-      if ((value != 0) == REGNO_REG_SET_P (set, regno))\n-\tcontinue;\n-      if (value)\n-\told++, SET_REGNO_REG_SET (set, regno);\n-      else\n-\told--, CLEAR_REGNO_REG_SET (set, regno);\n-    }\n-  return old;\n-}\n-\n-/* Record state about current inputs / local registers / liveness\n-   in *P.  */\n-static inline void\n-struct_equiv_make_checkpoint (struct struct_equiv_checkpoint *p,\n-\t\t\t      struct equiv_info *info)\n-{\n-  *p = info->cur;\n-}\n-\n-/* Call struct_equiv_make_checkpoint (P, INFO) if the current partial block\n-   is suitable to split off - i.e. there is no dangling cc0 user - and\n-   if the current cost of the common instructions, minus the cost for\n-   setting up the inputs, is higher than what has been recorded before\n-   in CHECKPOINT[N].  Also, if we do so, confirm or cancel any pending\n-   changes.  */\n-static void\n-struct_equiv_improve_checkpoint (struct struct_equiv_checkpoint *p,\n-\t\t\t\t struct equiv_info *info)\n-{\n-#ifdef HAVE_cc0\n-  if (reg_mentioned_p (cc0_rtx, info->cur.x_start)\n-      && !sets_cc0_p (info->cur.x_start))\n-    return;\n-#endif\n-  if (info->cur.input_count >= IMPOSSIBLE_MOVE_FACTOR)\n-    return;\n-  if (info->input_cost >= 0\n-      ? (COSTS_N_INSNS(info->cur.ninsns - p->ninsns)\n-\t > info->input_cost * (info->cur.input_count - p->input_count))\n-      : info->cur.ninsns > p->ninsns && !info->cur.input_count)\n-    {\n-      if (info->check_input_conflict && ! resolve_input_conflict (info))\n-\treturn;\n-      /* We have a profitable set of changes.  If this is the final pass,\n-\t commit them now.  Otherwise, we don't know yet if we can make any\n-\t change, so put the old code back for now.  */\n-      if (info->mode & STRUCT_EQUIV_FINAL)\n-\tconfirm_change_group ();\n-      else\n-\tcancel_changes (0);\n-      struct_equiv_make_checkpoint (p, info);\n-    }\n-}\n-\n-/* Restore state about current inputs / local registers / liveness\n-   from P.  */\n-static void\n-struct_equiv_restore_checkpoint (struct struct_equiv_checkpoint *p,\n-\t\t\t\t struct equiv_info *info)\n-{\n-  info->cur.ninsns = p->ninsns;\n-  info->cur.x_start = p->x_start;\n-  info->cur.y_start = p->y_start;\n-  info->cur.input_count = p->input_count;\n-  info->cur.input_valid = p->input_valid;\n-  while (info->cur.local_count > p->local_count)\n-    {\n-      info->cur.local_count--;\n-      info->cur.version--;\n-      if (REGNO_REG_SET_P (info->x_local_live,\n-\t\t\t   REGNO (info->x_local[info->cur.local_count])))\n-\t{\n-\t  assign_reg_reg_set (info->x_local_live,\n-\t\t\t      info->x_local[info->cur.local_count], 0);\n-\t  assign_reg_reg_set (info->y_local_live,\n-\t\t\t      info->y_local[info->cur.local_count], 0);\n-\t  info->cur.version--;\n-\t}\n-    }\n-  if (info->cur.version != p->version)\n-    info->need_rerun = true;\n-}\n-\n-\n-/* Update register liveness to reflect that X is now life (if rvalue is\n-   nonzero) or dead (if rvalue is zero) in INFO->x_block, and likewise Y\n-   in INFO->y_block.  Return the number of registers the liveness of which\n-   changed in each block (as a negative number if registers became dead).  */\n-static int\n-note_local_live (struct equiv_info *info, rtx x, rtx y, int rvalue)\n-{\n-  unsigned x_regno = REGNO (x);\n-  unsigned y_regno = REGNO (y);\n-  int x_nominal_nregs = (x_regno >= FIRST_PSEUDO_REGISTER\n-\t\t\t ? 1 : hard_regno_nregs[x_regno][GET_MODE (x)]);\n-  int y_nominal_nregs = (y_regno >= FIRST_PSEUDO_REGISTER\n-\t\t\t ? 1 : hard_regno_nregs[y_regno][GET_MODE (y)]);\n-  int x_change = assign_reg_reg_set (info->x_local_live, x, rvalue);\n-  int y_change = assign_reg_reg_set (info->y_local_live, y, rvalue);\n-\n-  gcc_assert (x_nominal_nregs && y_nominal_nregs);\n-  gcc_assert (x_change * y_nominal_nregs == y_change * x_nominal_nregs);\n-  if (y_change)\n-    {\n-      if (reload_completed)\n-\t{\n-\t  unsigned x_regno ATTRIBUTE_UNUSED = REGNO (x);\n-\t  unsigned y_regno ATTRIBUTE_UNUSED = REGNO (y);\n-\t  enum machine_mode x_mode = GET_MODE (x);\n-\n-\t  if (secondary_reload_class (0, REGNO_REG_CLASS (y_regno), x_mode, x)\n-\t      != NO_REGS\n-#ifdef SECONDARY_MEMORY_NEEDED\n-\t      || SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (y_regno),\n-\t\t\t\t\t  REGNO_REG_CLASS (x_regno), x_mode)\n-#endif\n-\t      )\n-\t  y_change *= IMPOSSIBLE_MOVE_FACTOR;\n-\t}\n-      info->cur.input_count += y_change;\n-      info->cur.version++;\n-    }\n-  return x_change;\n-}\n-\n-/* Check if *XP is equivalent to Y.  Until an unreconcilable difference is\n-   found, use in-group changes with validate_change on *XP to make register\n-   assignments agree.  It is the (not necessarily direct) callers\n-   responsibility to verify / confirm / cancel these changes, as appropriate.\n-   RVALUE indicates if the processed piece of rtl is used as a destination, in\n-   which case we can't have different registers being an input.  Returns\n-   nonzero if the two blocks have been identified as equivalent, zero otherwise.\n-   RVALUE == 0: destination\n-   RVALUE == 1: source\n-   RVALUE == -1: source, ignore SET_DEST of SET / clobber.  */\n-bool\n-rtx_equiv_p (rtx *xp, rtx y, int rvalue, struct equiv_info *info)\n-{\n-  rtx x = *xp;\n-  enum rtx_code code;\n-  int length;\n-  const char *format;\n-  int i;\n-\n-  if (!y || !x)\n-    return x == y;\n-  code = GET_CODE (y);\n-  if (code != REG && x == y)\n-    return true;\n-  if (GET_CODE (x) != code\n-      || GET_MODE (x) != GET_MODE (y))\n-    return false;\n-\n-  /* ??? could extend to allow CONST_INT inputs.  */\n-  switch (code)\n-    {\n-    case REG:\n-      {\n-\tunsigned x_regno = REGNO (x);\n-\tunsigned y_regno = REGNO (y);\n-\tint x_common_live, y_common_live;\n-\n-\tif (reload_completed\n-\t    && (x_regno >= FIRST_PSEUDO_REGISTER\n-\t\t|| y_regno >= FIRST_PSEUDO_REGISTER))\n-\t  {\n-\t    /* We should only see this in REG_NOTEs.  */\n-\t    gcc_assert (!info->live_update);\n-\t    /* Returning false will cause us to remove the notes.  */\n-\t    return false;\n-\t  }\n-#ifdef STACK_REGS\n-\t/* After reg-stack, can only accept literal matches of stack regs.  */\n-\tif (info->mode & CLEANUP_POST_REGSTACK\n-\t    && (IN_RANGE (x_regno, FIRST_STACK_REG, LAST_STACK_REG)\n-\t\t|| IN_RANGE (y_regno, FIRST_STACK_REG, LAST_STACK_REG)))\n-\t  return x_regno == y_regno;\n-#endif\n-\n-\t/* If the register is a locally live one in one block, the\n-\t   corresponding one must be locally live in the other, too, and\n-\t   match of identical regnos doesn't apply.  */\n-\tif (REGNO_REG_SET_P (info->x_local_live, x_regno))\n-\t  {\n-\t    if (!REGNO_REG_SET_P (info->y_local_live, y_regno))\n-\t      return false;\n-\t  }\n-\telse if (REGNO_REG_SET_P (info->y_local_live, y_regno))\n-\t  return false;\n-\telse if (x_regno == y_regno)\n-\t  {\n-\t    if (!rvalue && info->cur.input_valid\n-\t\t&& (reg_overlap_mentioned_p (x, info->x_input)\n-\t\t    || reg_overlap_mentioned_p (x, info->y_input)))\n-\t      return false;\n-\n-\t    /* Update liveness information.  */\n-\t    if (info->live_update\n-\t\t&& assign_reg_reg_set (info->common_live, x, rvalue))\n-\t      info->cur.version++;\n-\n-\t    return true;\n-\t  }\n-\n-\tx_common_live = REGNO_REG_SET_P (info->common_live, x_regno);\n-\ty_common_live = REGNO_REG_SET_P (info->common_live, y_regno);\n-\tif (x_common_live != y_common_live)\n-\t  return false;\n-\telse if (x_common_live)\n-\t  {\n-\t    if (! rvalue || info->input_cost < 0 || reload_completed)\n-\t      return false;\n-\t    /* If info->live_update is not set, we are processing notes.\n-\t       We then allow a match with x_input / y_input found in a\n-\t       previous pass.  */\n-\t    if (info->live_update && !info->cur.input_valid)\n-\t      {\n-\t\tinfo->cur.input_valid = true;\n-\t\tinfo->x_input = x;\n-\t\tinfo->y_input = y;\n-\t\tinfo->cur.input_count += optimize_size ? 2 : 1;\n-\t\tif (info->input_reg\n-\t\t    && GET_MODE (info->input_reg) != GET_MODE (info->x_input))\n-\t\t  info->input_reg = NULL_RTX;\n-\t\tif (!info->input_reg)\n-\t\t  info->input_reg = gen_reg_rtx (GET_MODE (info->x_input));\n-\t      }\n-\t    else if ((info->live_update\n-\t\t      ? ! info->cur.input_valid : ! info->x_input)\n-\t\t     || ! rtx_equal_p (x, info->x_input)\n-\t\t     || ! rtx_equal_p (y, info->y_input))\n-\t      return false;\n-\t    validate_change (info->cur.x_start, xp, info->input_reg, 1);\n-\t  }\n-\telse\n-\t  {\n-\t    int x_nregs = (x_regno >= FIRST_PSEUDO_REGISTER\n-\t\t\t   ? 1 : hard_regno_nregs[x_regno][GET_MODE (x)]);\n-\t    int y_nregs = (y_regno >= FIRST_PSEUDO_REGISTER\n-\t\t\t   ? 1 : hard_regno_nregs[y_regno][GET_MODE (y)]);\n-\t    int size = GET_MODE_SIZE (GET_MODE (x));\n-\t    enum machine_mode x_mode = GET_MODE (x);\n-\t    unsigned x_regno_i, y_regno_i;\n-\t    int x_nregs_i, y_nregs_i, size_i;\n-\t    int local_count = info->cur.local_count;\n-\n-\t    /* This might be a register local to each block.  See if we have\n-\t       it already registered.  */\n-\t    for (i = local_count - 1; i >= 0; i--)\n-\t      {\n-\t\tx_regno_i = REGNO (info->x_local[i]);\n-\t\tx_nregs_i = (x_regno_i >= FIRST_PSEUDO_REGISTER\n-\t\t\t     ? 1 : hard_regno_nregs[x_regno_i][GET_MODE (x)]);\n-\t\ty_regno_i = REGNO (info->y_local[i]);\n-\t\ty_nregs_i = (y_regno_i >= FIRST_PSEUDO_REGISTER\n-\t\t\t     ? 1 : hard_regno_nregs[y_regno_i][GET_MODE (y)]);\n-\t\tsize_i = GET_MODE_SIZE (GET_MODE (info->x_local[i]));\n-\n-\t\t/* If we have a new pair of registers that is wider than an\n-\t\t   old pair and enclosing it with matching offsets,\n-\t\t   remove the old pair.  If we find a matching, wider, old\n-\t\t   pair, use the old one.  If the width is the same, use the\n-\t\t   old one if the modes match, but the new if they don't.\n-\t\t   We don't want to get too fancy with subreg_regno_offset\n-\t\t   here, so we just test two straightforward cases each.  */\n-\t\tif (info->live_update\n-\t\t    && (x_mode != GET_MODE (info->x_local[i])\n-\t\t\t? size >= size_i : size > size_i))\n-\t\t  {\n-\t\t    /* If the new pair is fully enclosing a matching\n-\t\t       existing pair, remove the old one.  N.B. because\n-\t\t       we are removing one entry here, the check below\n-\t\t       if we have space for a new entry will succeed.  */\n-\t\t    if ((x_regno <= x_regno_i\n-\t\t\t && x_regno + x_nregs >= x_regno_i + x_nregs_i\n-\t\t\t && x_nregs == y_nregs && x_nregs_i == y_nregs_i\n-\t\t\t && x_regno - x_regno_i == y_regno - y_regno_i)\n-\t\t\t|| (x_regno == x_regno_i && y_regno == y_regno_i\n-\t\t\t    && x_nregs >= x_nregs_i && y_nregs >= y_nregs_i))\n-\t\t      {\n-\t\t\tinfo->cur.local_count = --local_count;\n-\t\t\tinfo->x_local[i] = info->x_local[local_count];\n-\t\t\tinfo->y_local[i] = info->y_local[local_count];\n-\t\t\tcontinue;\n-\t\t      }\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\n-\t\t    /* If the new pair is fully enclosed within a matching\n-\t\t       existing pair, succeed.  */\n-\t\t    if (x_regno >= x_regno_i\n-\t\t\t&& x_regno + x_nregs <= x_regno_i + x_nregs_i\n-\t\t\t&& x_nregs == y_nregs && x_nregs_i == y_nregs_i\n-\t\t\t&& x_regno - x_regno_i == y_regno - y_regno_i)\n-\t\t      break;\n-\t\t    if (x_regno == x_regno_i && y_regno == y_regno_i\n-\t\t\t&& x_nregs <= x_nregs_i && y_nregs <= y_nregs_i)\n-\t\t      break;\n-\t\t}\n-\n-\t\t/* Any other overlap causes a match failure.  */\n-\t\tif (x_regno + x_nregs > x_regno_i\n-\t\t    && x_regno_i + x_nregs_i > x_regno)\n-\t\t  return false;\n-\t\tif (y_regno + y_nregs > y_regno_i\n-\t\t    && y_regno_i + y_nregs_i > y_regno)\n-\t\t  return false;\n-\t      }\n-\t    if (i < 0)\n-\t      {\n-\t\t/* Not found.  Create a new entry if possible.  */\n-\t\tif (!info->live_update\n-\t\t    || info->cur.local_count >= STRUCT_EQUIV_MAX_LOCAL)\n-\t\t  return false;\n-\t\tinfo->x_local[info->cur.local_count] = x;\n-\t\tinfo->y_local[info->cur.local_count] = y;\n-\t\tinfo->cur.local_count++;\n-\t\tinfo->cur.version++;\n-\t      }\n-\t    note_local_live (info, x, y, rvalue);\n-\t  }\n-\treturn true;\n-      }\n-    case SET:\n-      gcc_assert (rvalue < 0);\n-      /* Ignore the destinations role as a destination.  Still, we have\n-\t to consider input registers embedded in the addresses of a MEM.\n-\t N.B., we process the rvalue aspect of STRICT_LOW_PART /\n-\t ZERO_EXTEND / SIGN_EXTEND along with their lvalue aspect.  */\n-      if(!set_dest_addr_equiv_p (SET_DEST (x), SET_DEST (y), info))\n-\treturn false;\n-      /* Process source.  */\n-      return rtx_equiv_p (&SET_SRC (x), SET_SRC (y), 1, info);\n-    case PRE_MODIFY:\n-      /* Process destination.  */\n-      if (!rtx_equiv_p (&XEXP (x, 0), XEXP (y, 0), 0, info))\n-\treturn false;\n-      /* Process source.  */\n-      return rtx_equiv_p (&XEXP (x, 1), XEXP (y, 1), 1, info);\n-    case POST_MODIFY:\n-      {\n-\trtx x_dest0, x_dest1;\n-\n-\t/* Process destination.  */\n-\tx_dest0 = XEXP (x, 0);\n-\tgcc_assert (REG_P (x_dest0));\n-\tif (!rtx_equiv_p (&XEXP (x, 0), XEXP (y, 0), 0, info))\n-\t  return false;\n-\tx_dest1 = XEXP (x, 0);\n-\t/* validate_change might have changed the destination.  Put it back\n-\t   so that we can do a proper match for its role as an input.  */\n-\tXEXP (x, 0) = x_dest0;\n-\tif (!rtx_equiv_p (&XEXP (x, 0), XEXP (y, 0), 1, info))\n-\t  return false;\n-\tgcc_assert (x_dest1 == XEXP (x, 0));\n-\t/* Process source.  */\n-\treturn rtx_equiv_p (&XEXP (x, 1), XEXP (y, 1), 1, info);\n-      }\n-    case CLOBBER:\n-      gcc_assert (rvalue < 0);\n-      return true;\n-    /* Some special forms are also rvalues when they appear in lvalue\n-       positions.  However, we must ont try to match a register after we\n-       have already altered it with validate_change, consider the rvalue\n-       aspect while we process the lvalue.  */\n-    case STRICT_LOW_PART:\n-    case ZERO_EXTEND:\n-    case SIGN_EXTEND:\n-      {\n-\trtx x_inner, y_inner;\n-\tenum rtx_code code;\n-\tint change;\n-\n-\tif (rvalue)\n-\t  break;\n-\tx_inner = XEXP (x, 0);\n-\ty_inner = XEXP (y, 0);\n-\tif (GET_MODE (x_inner) != GET_MODE (y_inner))\n-\t  return false;\n-\tcode = GET_CODE (x_inner);\n-\tif (code != GET_CODE (y_inner))\n-\t  return false;\n-\t/* The address of a MEM is an input that will be processed during\n-\t   rvalue == -1 processing.  */\n-\tif (code == SUBREG)\n-\t  {\n-\t    if (SUBREG_BYTE (x_inner) != SUBREG_BYTE (y_inner))\n-\t      return false;\n-\t    x = x_inner;\n-\t    x_inner = SUBREG_REG (x_inner);\n-\t    y_inner = SUBREG_REG (y_inner);\n-\t    if (GET_MODE (x_inner) != GET_MODE (y_inner))\n-\t      return false;\n-\t    code = GET_CODE (x_inner);\n-\t    if (code != GET_CODE (y_inner))\n-\t      return false;\n-\t  }\n-\tif (code == MEM)\n-\t  return true;\n-\tgcc_assert (code == REG);\n-\tif (! rtx_equiv_p (&XEXP (x, 0), y_inner, rvalue, info))\n-\t  return false;\n-\tif (REGNO (x_inner) == REGNO (y_inner))\n-\t  {\n-\t    change = assign_reg_reg_set (info->common_live, x_inner, 1);\n-\t    info->cur.version++;\n-\t  }\n-\telse\n-\t  change = note_local_live (info, x_inner, y_inner, 1);\n-\tgcc_assert (change);\n-\treturn true;\n-      }\n-    /* The AUTO_INC / POST_MODIFY / PRE_MODIFY sets are modelled to take\n-       place during input processing, however, that is benign, since they\n-       are paired with reads.  */\n-    case MEM:\n-      return !rvalue || rtx_equiv_p (&XEXP (x, 0), XEXP (y, 0), rvalue, info);\n-    case POST_INC: case POST_DEC: case PRE_INC: case PRE_DEC:\n-      return (rtx_equiv_p (&XEXP (x, 0), XEXP (y, 0), 0, info)\n-\t      && rtx_equiv_p (&XEXP (x, 0), XEXP (y, 0), 1, info));\n-    case PARALLEL:\n-      /* If this is a top-level PATTERN PARALLEL, we expect the caller to \n-\t have handled the SET_DESTs.  A complex or vector PARALLEL can be\n-\t identified by having a mode.  */\n-      gcc_assert (rvalue < 0 || GET_MODE (x) != VOIDmode);\n-      break;\n-    case LABEL_REF:\n-      /* Check special tablejump match case.  */\n-      if (XEXP (y, 0) == info->y_label)\n-\treturn (XEXP (x, 0) == info->x_label);\n-      /* We can't assume nonlocal labels have their following insns yet.  */\n-      if (LABEL_REF_NONLOCAL_P (x) || LABEL_REF_NONLOCAL_P (y))\n-\treturn XEXP (x, 0) == XEXP (y, 0);\n-\n-      /* Two label-refs are equivalent if they point at labels\n-\t in the same position in the instruction stream.  */\n-      return (next_real_insn (XEXP (x, 0))\n-\t      == next_real_insn (XEXP (y, 0)));\n-    case SYMBOL_REF:\n-      return XSTR (x, 0) == XSTR (y, 0);\n-    /* Some rtl is guaranteed to be shared, or unique;  If we didn't match\n-       EQ equality above, they aren't the same.  */\n-    case CONST_INT:\n-    case CODE_LABEL:\n-      return false;\n-    default:\n-      break;\n-    }\n-\n-  /* For commutative operations, the RTX match if the operands match in any\n-     order.  */\n-  if (targetm.commutative_p (x, UNKNOWN))\n-    return ((rtx_equiv_p (&XEXP (x, 0), XEXP (y, 0), rvalue, info)\n-\t     && rtx_equiv_p (&XEXP (x, 1), XEXP (y, 1), rvalue, info))\n-\t    || (rtx_equiv_p (&XEXP (x, 0), XEXP (y, 1), rvalue, info)\n-\t\t&& rtx_equiv_p (&XEXP (x, 1), XEXP (y, 0), rvalue, info)));\n-\n-  /* Process subexpressions - this is similar to rtx_equal_p.  */\n-  length = GET_RTX_LENGTH (code);\n-  format = GET_RTX_FORMAT (code);\n-\n-  for (i = 0; i < length; ++i)\n-    {\n-      switch (format[i])\n-\t{\n-\tcase 'w':\n-\t  if (XWINT (x, i) != XWINT (y, i))\n-\t    return false;\n-\t  break;\n-\tcase 'n':\n-\tcase 'i':\n-\t  if (XINT (x, i) != XINT (y, i))\n-\t    return false;\n-\t  break;\n-\tcase 'V':\n-\tcase 'E':\n-\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n-\t    return false;\n-\t  if (XVEC (x, i) != 0)\n-\t    {\n-\t      int j;\n-\t      for (j = 0; j < XVECLEN (x, i); ++j)\n-\t\t{\n-\t\t  if (! rtx_equiv_p (&XVECEXP (x, i, j), XVECEXP (y, i, j),\n-\t\t\t\t     rvalue, info))\n-\t\t    return false;\n-\t\t}\n-\t    }\n-\t  break;\n-\tcase 'e':\n-\t  if (! rtx_equiv_p (&XEXP (x, i), XEXP (y, i), rvalue, info))\n-\t    return false;\n-\t  break;\n-\tcase 'S':\n-\tcase 's':\n-\t  if ((XSTR (x, i) || XSTR (y, i))\n-\t      && (! XSTR (x, i) || ! XSTR (y, i)\n-\t\t  || strcmp (XSTR (x, i), XSTR (y, i))))\n-\t    return false;\n-\t  break;\n-\tcase 'u':\n-\t  /* These are just backpointers, so they don't matter.  */\n-\t  break;\n-\tcase '0':\n-\tcase 't':\n-\t  break;\n-\t  /* It is believed that rtx's at this level will never\n-\t     contain anything but integers and other rtx's,\n-\t     except for within LABEL_REFs and SYMBOL_REFs.  */\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-  return true;\n-}\n-\n-/* Do only the rtx_equiv_p SET_DEST processing for SETs and CLOBBERs.\n-   Since we are scanning backwards, this the first step in processing each\n-   insn.  Return true for success.  */\n-static bool\n-set_dest_equiv_p (rtx x, rtx y, struct equiv_info *info)\n-{\n-  if (!x || !y)\n-    return x == y;\n-  if (GET_CODE (x) != GET_CODE (y))\n-    return false;\n-  else if (GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n-    return rtx_equiv_p (&XEXP (x, 0), XEXP (y, 0), 0, info);\n-  else if (GET_CODE (x) == PARALLEL)\n-    {\n-      int j;\n-\n-      if (XVECLEN (x, 0) != XVECLEN (y, 0))\n-\treturn false;\n-      for (j = 0; j < XVECLEN (x, 0); ++j)\n-\t{\n-\t  rtx xe = XVECEXP (x, 0, j);\n-\t  rtx ye = XVECEXP (y, 0, j);\n-\n-\t  if (GET_CODE (xe) != GET_CODE (ye))\n-\t    return false;\n-\t  if ((GET_CODE (xe) == SET || GET_CODE (xe) == CLOBBER)\n-\t      && ! rtx_equiv_p (&XEXP (xe, 0), XEXP (ye, 0), 0, info))\n-\t    return false;\n-\t}\n-    }\n-  return true;\n-}\n-\n-/* Process MEMs in SET_DEST destinations.  We must not process this together\n-   with REG SET_DESTs, but must do it separately, lest when we see\n-   [(set (reg:SI foo) (bar))\n-    (set (mem:SI (reg:SI foo) (baz)))]\n-   struct_equiv_block_eq could get confused to assume that (reg:SI foo)\n-   is not live before this instruction.  */\n-static bool\n-set_dest_addr_equiv_p (rtx x, rtx y, struct equiv_info *info)\n-{\n-  enum rtx_code code = GET_CODE (x);\n-  int length;\n-  const char *format;\n-  int i;\n-\n-  if (code != GET_CODE (y))\n-    return false;\n-  if (code == MEM)\n-    return rtx_equiv_p (&XEXP (x, 0), XEXP (y, 0), 1, info);\n-\n-  /* Process subexpressions.  */\n-  length = GET_RTX_LENGTH (code);\n-  format = GET_RTX_FORMAT (code);\n-\n-  for (i = 0; i < length; ++i)\n-    {\n-      switch (format[i])\n-\t{\n-\tcase 'V':\n-\tcase 'E':\n-\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n-\t    return false;\n-\t  if (XVEC (x, i) != 0)\n-\t    {\n-\t      int j;\n-\t      for (j = 0; j < XVECLEN (x, i); ++j)\n-\t\t{\n-\t\t  if (! set_dest_addr_equiv_p (XVECEXP (x, i, j),\n-\t\t\t\t\t       XVECEXP (y, i, j), info))\n-\t\t    return false;\n-\t\t}\n-\t    }\n-\t  break;\n-\tcase 'e':\n-\t  if (! set_dest_addr_equiv_p (XEXP (x, i), XEXP (y, i), info))\n-\t    return false;\n-\t  break;\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-  return true;\n-}\n-\n-/* Check if the set of REG_DEAD notes attached to I1 and I2 allows us to\n-   go ahead with merging I1 and I2, which otherwise look fine.\n-   Inputs / local registers for the inputs of I1 and I2 have already been\n-   set up.  */\n-static bool\n-death_notes_match_p (rtx i1 ATTRIBUTE_UNUSED, rtx i2 ATTRIBUTE_UNUSED,\n-\t\t     struct equiv_info *info ATTRIBUTE_UNUSED)\n-{\n-#ifdef STACK_REGS\n-  /* If cross_jump_death_matters is not 0, the insn's mode\n-     indicates whether or not the insn contains any stack-like regs.  */\n-\n-  if ((info->mode & CLEANUP_POST_REGSTACK) && stack_regs_mentioned (i1))\n-    {\n-      /* If register stack conversion has already been done, then\n-\t death notes must also be compared before it is certain that\n-\t the two instruction streams match.  */\n-\n-      rtx note;\n-      HARD_REG_SET i1_regset, i2_regset;\n-\n-      CLEAR_HARD_REG_SET (i1_regset);\n-      CLEAR_HARD_REG_SET (i2_regset);\n-\n-      for (note = REG_NOTES (i1); note; note = XEXP (note, 1))\n-\tif (REG_NOTE_KIND (note) == REG_DEAD && STACK_REG_P (XEXP (note, 0)))\n-\t  SET_HARD_REG_BIT (i1_regset, REGNO (XEXP (note, 0)));\n-\n-      for (note = REG_NOTES (i2); note; note = XEXP (note, 1))\n-\tif (REG_NOTE_KIND (note) == REG_DEAD && STACK_REG_P (XEXP (note, 0)))\n-\t  {\n-\t    unsigned regno = REGNO (XEXP (note, 0));\n-\t    int i;\n-\n-\t    for (i = info->cur.local_count - 1; i >= 0; i--)\n-\t      if (regno == REGNO (info->y_local[i]))\n-\t\t{\n-\t\t  regno = REGNO (info->x_local[i]);\n-\t\t  break;\n-\t\t}\n-\t    SET_HARD_REG_BIT (i2_regset, regno);\n-\t  }\n-\n-      if (!hard_reg_set_equal_p (i1_regset, i2_regset))\n-\treturn false;\n-    }\n-#endif\n-  return true;\n-}\n-\n-/* Return true if I1 and I2 are equivalent and thus can be crossjumped.  */\n-\n-bool\n-insns_match_p (rtx i1, rtx i2, struct equiv_info *info)\n-{\n-  int rvalue_change_start;\n-  struct struct_equiv_checkpoint before_rvalue_change;\n-\n-  /* Verify that I1 and I2 are equivalent.  */\n-  if (GET_CODE (i1) != GET_CODE (i2))\n-    return false;\n-\n-  info->cur.x_start = i1;\n-  info->cur.y_start = i2;\n-\n-  /* If this is a CALL_INSN, compare register usage information.\n-     If we don't check this on stack register machines, the two\n-     CALL_INSNs might be merged leaving reg-stack.c with mismatching\n-     numbers of stack registers in the same basic block.\n-     If we don't check this on machines with delay slots, a delay slot may\n-     be filled that clobbers a parameter expected by the subroutine.\n-\n-     ??? We take the simple route for now and assume that if they're\n-     equal, they were constructed identically.  */\n-\n-  if (CALL_P (i1))\n-    {\n-      if (SIBLING_CALL_P (i1) != SIBLING_CALL_P (i2)\n-\t  || ! set_dest_equiv_p (PATTERN (i1), PATTERN (i2), info)\n-\t  || ! set_dest_equiv_p (CALL_INSN_FUNCTION_USAGE (i1),\n-\t\t\t\t CALL_INSN_FUNCTION_USAGE (i2), info)\n-\t  || ! rtx_equiv_p (&CALL_INSN_FUNCTION_USAGE (i1),\n-\t\t\t    CALL_INSN_FUNCTION_USAGE (i2), -1, info))\n-\t{\n-\t  cancel_changes (0);\n-\t  return false;\n-\t}\n-    }\n-  else if (INSN_P (i1))\n-    {\n-      if (! set_dest_equiv_p (PATTERN (i1), PATTERN (i2), info))\n-\t{\n-\t  cancel_changes (0);\n-\t  return false;\n-\t}\n-    }\n-  rvalue_change_start = num_validated_changes ();\n-  struct_equiv_make_checkpoint (&before_rvalue_change, info);\n-  /* Check death_notes_match_p *after* the inputs have been processed,\n-     so that local inputs will already have been set up.  */\n-  if (! INSN_P (i1)\n-      || (!bitmap_bit_p (info->equiv_used, info->cur.ninsns)\n-\t  && rtx_equiv_p (&PATTERN (i1), PATTERN (i2), -1, info)\n-\t  && death_notes_match_p (i1, i2, info)\n-\t  && verify_changes (0)))\n-    return true;\n-\n-  /* Do not do EQUIV substitution after reload.  First, we're undoing the\n-     work of reload_cse.  Second, we may be undoing the work of the post-\n-     reload splitting pass.  */\n-  /* ??? Possibly add a new phase switch variable that can be used by\n-     targets to disallow the troublesome insns after splitting.  */\n-  if (!reload_completed)\n-    {\n-      rtx equiv1, equiv2;\n-\n-      cancel_changes (rvalue_change_start);\n-      struct_equiv_restore_checkpoint (&before_rvalue_change, info);\n-\n-      /* The following code helps take care of G++ cleanups.  */\n-      equiv1 = find_reg_equal_equiv_note (i1);\n-      equiv2 = find_reg_equal_equiv_note (i2);\n-      if (equiv1 && equiv2\n-\t  /* If the equivalences are not to a constant, they may\n-\t     reference pseudos that no longer exist, so we can't\n-\t     use them.  */\n-\t  && (! reload_completed\n-\t      || (CONSTANT_P (XEXP (equiv1, 0))\n-\t\t  && rtx_equal_p (XEXP (equiv1, 0), XEXP (equiv2, 0)))))\n-\t{\n-\t  rtx s1 = single_set (i1);\n-\t  rtx s2 = single_set (i2);\n-\n-\t  if (s1 != 0 && s2 != 0)\n-\t    {\n-\t      validate_change (i1, &SET_SRC (s1), XEXP (equiv1, 0), 1);\n-\t      validate_change (i2, &SET_SRC (s2), XEXP (equiv2, 0), 1);\n-\t      /* Only inspecting the new SET_SRC is not good enough,\n-\t\t because there may also be bare USEs in a single_set\n-\t\t PARALLEL.  */\n-\t      if (rtx_equiv_p (&PATTERN (i1), PATTERN (i2), -1, info)\n-\t\t  && death_notes_match_p (i1, i2, info)\n-\t\t  && verify_changes (0))\n-\t\t{\n-\t\t  /* Mark this insn so that we'll use the equivalence in\n-\t\t     all subsequent passes.  */\n-\t\t  bitmap_set_bit (info->equiv_used, info->cur.ninsns);\n-\t\t  return true;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  cancel_changes (0);\n-  return false;\n-}\n-\n-/* Set up mode and register information in INFO.  Return true for success.  */\n-bool\n-struct_equiv_init (int mode, struct equiv_info *info)\n-{\n-  if (!REG_SET_EQUAL_P (DF_LR_OUT (info->x_block),\n-\t\t\tDF_LR_OUT (info->y_block)))\n-    {\n-#ifdef STACK_REGS\n-      unsigned rn;\n-\n-      if (!(mode & CLEANUP_POST_REGSTACK))\n-\treturn false;\n-      /* After reg-stack.  Remove bogus live info about stack regs.  N.B.\n-\t these regs are not necessarily all dead - we swap random bogosity\n-\t against constant bogosity.  However, clearing these bits at\n-\t least makes the regsets comparable.  */\n-      for (rn = FIRST_STACK_REG; rn <= LAST_STACK_REG; rn++)\n-\t{\n-\t  CLEAR_REGNO_REG_SET (DF_LR_OUT (info->x_block), rn);\n-\t  CLEAR_REGNO_REG_SET (DF_LR_OUT (info->y_block), rn);\n-\t}\n-      if (!REG_SET_EQUAL_P (DF_LR_OUT (info->x_block),\n-\t\t\t    DF_LR_OUT (info->y_block)))\n-#endif\n-\treturn false;\n-    }\n-  info->mode = mode;\n-  if (mode & STRUCT_EQUIV_START)\n-    {\n-      info->x_input = info->y_input = info->input_reg = NULL_RTX;\n-      info->equiv_used = ALLOC_REG_SET (&reg_obstack);\n-      info->check_input_conflict = false;\n-    }\n-  info->had_input_conflict = false;\n-  info->cur.ninsns = info->cur.version = 0;\n-  info->cur.local_count = info->cur.input_count = 0;\n-  info->cur.x_start = info->cur.y_start = NULL_RTX;\n-  info->x_label = info->y_label = NULL_RTX;\n-  info->need_rerun = false;\n-  info->live_update = true;\n-  info->cur.input_valid = false;\n-  info->common_live = ALLOC_REG_SET (&reg_obstack);\n-  info->x_local_live = ALLOC_REG_SET (&reg_obstack);\n-  info->y_local_live = ALLOC_REG_SET (&reg_obstack);\n-  COPY_REG_SET (info->common_live, DF_LR_OUT (info->x_block));\n-  struct_equiv_make_checkpoint (&info->best_match, info);\n-  return true;\n-}\n-\n-/* Insns XI and YI have been matched.  Merge memory attributes and reg\n-   notes.  */\n-static void\n-struct_equiv_merge (rtx xi, rtx yi, struct equiv_info *info)\n-{\n-  rtx equiv1, equiv2;\n-\n-  merge_memattrs (xi, yi);\n-\n-  /* If the merged insns have different REG_EQUAL notes, then\n-     remove them.  */\n-  info->live_update = false;\n-  equiv1 = find_reg_equal_equiv_note (xi);\n-  equiv2 = find_reg_equal_equiv_note (yi);\n-  if (equiv1 && !equiv2)\n-    remove_note (xi, equiv1);\n-  else if (!equiv1 && equiv2)\n-    remove_note (yi, equiv2);\n-  else if (equiv1 && equiv2\n-  \t && !rtx_equiv_p (&XEXP (equiv1, 0), XEXP (equiv2, 0),\n-  \t\t\t   1, info))\n-    {\n-      remove_note (xi, equiv1);\n-      remove_note (yi, equiv2);\n-    }\n-  info->live_update = true;\n-}\n-\n-/* Return number of matched insns.\n-   This function must be called up to three times for a successful cross-jump\n-   match:\n-   first to find out which instructions do match.  While trying to match\n-   another instruction that doesn't match, we destroy information in info\n-   about the actual inputs.  So if there have been any before the last\n-   match attempt, we need to call this function again to recompute the\n-   actual inputs up to the actual start of the matching sequence.\n-   When we are then satisfied that the cross-jump is worthwhile, we\n-   call this function a third time to make any changes needed to make the\n-   sequences match: apply equivalences, remove non-matching\n-   notes and merge memory attributes.  */\n-int\n-struct_equiv_block_eq (int mode, struct equiv_info *info)\n-{\n-  rtx x_stop, y_stop;\n-  rtx xi, yi;\n-  int i;\n-\n-  if (mode & STRUCT_EQUIV_START)\n-    {\n-      x_stop = BB_HEAD (info->x_block);\n-      y_stop = BB_HEAD (info->y_block);\n-      if (!x_stop || !y_stop)\n-\treturn 0;\n-    }\n-  else\n-    {\n-      x_stop = info->cur.x_start;\n-      y_stop = info->cur.y_start;\n-    }\n-  if (!struct_equiv_init (mode, info))\n-    gcc_unreachable ();\n-\n-  /* Skip simple jumps at the end of the blocks.  Complex jumps still\n-     need to be compared for equivalence, which we'll do below.  */\n-\n-  xi = BB_END (info->x_block);\n-  if (onlyjump_p (xi)\n-      || (returnjump_p (xi) && !side_effects_p (PATTERN (xi))))\n-    {\n-      info->cur.x_start = xi;\n-      xi = PREV_INSN (xi);\n-    }\n-\n-  yi = BB_END (info->y_block);\n-  if (onlyjump_p (yi)\n-      || (returnjump_p (yi) && !side_effects_p (PATTERN (yi))))\n-    {\n-      info->cur.y_start = yi;\n-      /* Count everything except for unconditional jump as insn.  */\n-      /* ??? Is it right to count unconditional jumps with a clobber?\n-\t Should we count conditional returns?  */\n-      if (!simplejump_p (yi) && !returnjump_p (yi) && info->cur.x_start)\n-\tinfo->cur.ninsns++;\n-      yi = PREV_INSN (yi);\n-    }\n-\n-  if (mode & STRUCT_EQUIV_MATCH_JUMPS)\n-    {\n-      /* The caller is expected to have compared the jumps already, but we\n-\t need to match them again to get any local registers and inputs.  */\n-      gcc_assert (!info->cur.x_start == !info->cur.y_start);\n-      if (info->cur.x_start)\n-\t{\n-\t  if (any_condjump_p (info->cur.x_start)\n-\t      ? !condjump_equiv_p (info, false)\n-\t      : !insns_match_p (info->cur.x_start, info->cur.y_start, info))\n-\t    gcc_unreachable ();\n-\t}\n-      else if (any_condjump_p (xi) && any_condjump_p (yi))\n-\t{\n-\t  info->cur.x_start = xi;\n-\t  info->cur.y_start = yi;\n-\t  xi = PREV_INSN (xi);\n-\t  yi = PREV_INSN (yi);\n-\t  info->cur.ninsns++;\n-\t  if (!condjump_equiv_p (info, false))\n-\t    gcc_unreachable ();\n-\t}\n-      if (info->cur.x_start && info->mode & STRUCT_EQUIV_FINAL)\n-\tstruct_equiv_merge (info->cur.x_start, info->cur.y_start, info);\n-    }\n-\n-  struct_equiv_improve_checkpoint (&info->best_match, info);\n-  info->x_end = xi;\n-  info->y_end = yi;\n-  if (info->cur.x_start != x_stop)\n-    for (;;)\n-      {\n-\t/* Ignore notes.  */\n-\twhile (!INSN_P (xi) && xi != x_stop)\n-\t  xi = PREV_INSN (xi);\n-\n-\twhile (!INSN_P (yi) && yi != y_stop)\n-\t  yi = PREV_INSN (yi);\n-\n-\tif (!insns_match_p (xi, yi, info))\n-\t  break;\n-\tif (INSN_P (xi))\n-\t  {\n-\t    if (info->mode & STRUCT_EQUIV_FINAL)\n-\t      struct_equiv_merge (xi, yi, info);\n-\t    info->cur.ninsns++;\n-\t    struct_equiv_improve_checkpoint (&info->best_match, info);\n-\t  }\n-\tif (xi == x_stop || yi == y_stop)\n-\t  {\n-\t    /* If we reached the start of at least one of the blocks, but\n-\t       best_match hasn't been advanced back to the first valid insn\n-\t       yet, represent the increased benefit of completing the block\n-\t       as an increased instruction count.  */\n-\t    if (info->best_match.x_start != info->cur.x_start\n-\t\t&& (xi == BB_HEAD (info->x_block)\n-\t\t    || yi == BB_HEAD (info->y_block)))\n-\t      {\n-\t\tinfo->cur.ninsns++;\n-\t\tstruct_equiv_improve_checkpoint (&info->best_match, info);\n-\t\tinfo->cur.ninsns--;\n-\t\tif (info->best_match.ninsns > info->cur.ninsns)\n-\t\t  info->best_match.ninsns = info->cur.ninsns;\n-\t      }\n-\t    break;\n-\t  }\n-\txi = PREV_INSN (xi);\n-\tyi = PREV_INSN (yi);\n-      }\n-\n-  /* If we failed to match an insn, but had some changes registered from\n-     trying to make the insns match, we need to cancel these changes now.  */\n-  cancel_changes (0);\n-  /* Restore to best_match to get the sequence with the best known-so-far\n-     cost-benefit difference.  */\n-  struct_equiv_restore_checkpoint (&info->best_match, info);\n-\n-  /* Include preceding notes and labels in the cross-jump / if-conversion.\n-     One, this may bring us to the head of the blocks.\n-     Two, it keeps line number notes as matched as may be.  */\n-  if (info->cur.ninsns)\n-    {\n-      xi = info->cur.x_start;\n-      yi = info->cur.y_start;\n-      while (xi != x_stop && !INSN_P (PREV_INSN (xi)))\n-\txi = PREV_INSN (xi);\n-\n-      while (yi != y_stop && !INSN_P (PREV_INSN (yi)))\n-\tyi = PREV_INSN (yi);\n-\n-      info->cur.x_start = xi;\n-      info->cur.y_start = yi;\n-    }\n-\n-  if (!info->cur.input_valid)\n-    info->x_input = info->y_input = info->input_reg = NULL_RTX;\n-  if (!info->need_rerun)\n-    {\n-      find_dying_inputs (info);\n-      if (info->mode & STRUCT_EQUIV_FINAL)\n-\t{\n-\t  if (info->check_input_conflict && ! resolve_input_conflict (info))\n-\t    gcc_unreachable ();\n-\t}\n-      else\n-\t{\n-\t  bool input_conflict = info->had_input_conflict;\n-\n-\t  if (!input_conflict\n-\t      && info->dying_inputs > 1\n-\t      && bitmap_intersect_p (info->x_local_live, info->y_local_live))\n-\t    {\n-\t      regset_head clobbered_regs;\n-\n-\t      INIT_REG_SET (&clobbered_regs);\n-\t      for (i = 0; i < info->cur.local_count; i++)\n-\t\t{\n-\t\t  if (assign_reg_reg_set (&clobbered_regs, info->y_local[i], 0))\n-\t\t    {\n-\t\t      input_conflict = true;\n-\t\t      break;\n-\t\t    }\n-\t\t  assign_reg_reg_set (&clobbered_regs, info->x_local[i], 1);\n-\t\t}\n-\t      CLEAR_REG_SET (&clobbered_regs);\n-\t    }\n-\t  if (input_conflict && !info->check_input_conflict)\n-\t    info->need_rerun = true;\n-\t  info->check_input_conflict = input_conflict;\n-\t}\n-    }\n-\n-  if (info->mode & STRUCT_EQUIV_NEED_FULL_BLOCK\n-      && (info->cur.x_start != x_stop || info->cur.y_start != y_stop))\n-    return 0;\n-  return info->cur.ninsns;\n-}\n-\n-/* For each local register, set info->local_rvalue to true iff the register\n-   is a dying input.  Store the total number of these in info->dying_inputs.  */\n-static void\n-find_dying_inputs (struct equiv_info *info)\n-{\n-  int i;\n-\n-  info->dying_inputs = 0;\n-  for (i = info->cur.local_count-1; i >=0; i--)\n-    {\n-      rtx x = info->x_local[i];\n-      unsigned regno = REGNO (x);\n-      int nregs = (regno >= FIRST_PSEUDO_REGISTER\n-\t\t   ? 1 : hard_regno_nregs[regno][GET_MODE (x)]);\n-\n-      for (info->local_rvalue[i] = false; nregs > 0; regno++, --nregs)\n-\tif (REGNO_REG_SET_P (info->x_local_live, regno))\n-\t  {\n-\t    info->dying_inputs++;\n-\t    info->local_rvalue[i] = true;\n-\t    break;\n-\t  }\n-    }\n-}\n-\n-/* For each local register that is a dying input, y_local[i] will be\n-   copied to x_local[i].  We'll do this in ascending order.  Try to\n-   re-order the locals to avoid conflicts like r3 = r2; r4 = r3; .\n-   Return true iff the re-ordering is successful, or not necessary.  */\n-static bool\n-resolve_input_conflict (struct equiv_info *info)\n-{\n-  int i, j, end;\n-  int nswaps = 0;\n-  rtx save_x_local[STRUCT_EQUIV_MAX_LOCAL];\n-  rtx save_y_local[STRUCT_EQUIV_MAX_LOCAL];\n-\n-  find_dying_inputs (info);\n-  if (info->dying_inputs <= 1)\n-    return true;\n-  memcpy (save_x_local, info->x_local, sizeof save_x_local);\n-  memcpy (save_y_local, info->y_local, sizeof save_y_local);\n-  end = info->cur.local_count - 1;\n-  for (i = 0; i <= end; i++)\n-    {\n-      /* Cycle detection with regsets is expensive, so we just check that\n-\t we don't exceed the maximum number of swaps needed in the acyclic\n-\t case.  */\n-      int max_swaps = end - i;\n-\n-      /* Check if x_local[i] will be clobbered.  */\n-      if (!info->local_rvalue[i])\n-\tcontinue;\n-      /* Check if any later value needs to be copied earlier.  */\n-      for (j = i + 1; j <= end; j++)\n-\t{\n-\t  rtx tmp;\n-\n-\t  if (!info->local_rvalue[j])\n-\t    continue;\n-\t  if (!reg_overlap_mentioned_p (info->x_local[i], info->y_local[j]))\n-\t    continue;\n-\t  if (--max_swaps < 0)\n-\t    {\n-\t      memcpy (info->x_local, save_x_local, sizeof save_x_local);\n-\t      memcpy (info->y_local, save_y_local, sizeof save_y_local);\n-\t      return false;\n-\t    }\n-\t  nswaps++;\n-\t  tmp = info->x_local[i];\n-\t  info->x_local[i] = info->x_local[j];\n-\t  info->x_local[j] = tmp;\n-\t  tmp = info->y_local[i];\n-\t  info->y_local[i] = info->y_local[j];\n-\t  info->y_local[j] = tmp;\n-\t  j = i;\n-\t}\n-    }\n-  info->had_input_conflict = true;\n-  if (dump_file && nswaps)\n-    fprintf (dump_file, \"Resolved input conflict, %d %s.\\n\",\n-\t     nswaps, nswaps == 1 ? \"swap\" : \"swaps\");\n-  return true;\n-}"}]}