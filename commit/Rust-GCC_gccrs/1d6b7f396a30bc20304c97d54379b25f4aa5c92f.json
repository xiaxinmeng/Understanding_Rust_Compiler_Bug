{"sha": "1d6b7f396a30bc20304c97d54379b25f4aa5c92f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ2YjdmMzk2YTMwYmMyMDMwNGM5N2Q1NDM3OWIyNWY0YWE1YzkyZg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-09-16T09:17:49Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-09-16T09:17:49Z"}, "message": "re PR fortran/29396 (segfault with character pointer association)\n\n2007-09-16  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/29396\n\tPR fortran/29606\n\tPR fortran/30625\n\tPR fortran/30871\n\t* trans.h : Add extra argument to gfc_build_array_ref. Rename\n\tgfc_conv_aliased_arg to gfc_conv_subref_array_arg.  Move\n\tprototype of is_aliased_array to gfortran.h and rename it\n\tgfc_is_subref_array.  Add field span to lang_decl, add a new\n\tdecl lang specific flag accessed by GFC_DECL_SUBREF_ARRAY_P\n\tand a new type flag GFC_DECL_SUBREF_ARRAY_P.\n\t* trans.c (gfc_build_array_ref): Add the new argument, decl.\n\tIf this is a subreference array pointer, use the lang_decl\n\tfield 'span' to calculate the offset in bytes and use pointer\n\tarithmetic to address the element.\n\t* trans-array.c (gfc_conv_scalarized_array_ref,\n\tgfc_conv_array_ref): Add the backend declaration as the third\n\tfield, if it is likely to be a subreference array pointer.\n\t(gfc_conv_descriptor_dimension, gfc_trans_array_ctor_element,\n\tgfc_trans_array_constructor_element, structure_alloc_comps,\n\tgfc_conv_array_index_offset): For all other references to\n\tgfc_build_array_ref, set the third argument to NULL.\n\t(gfc_get_dataptr_offset): New function.\n\t(gfc_conv_expr_descriptor): If the rhs of a pointer assignment\n\tis a subreference array, then calculate the offset to the\n\tsubreference of the first element and set the descriptor data\n\tpointer to this, using gfc_get_dataptr_offset.\n\ttrans-expr.c (gfc_get_expr_charlen): Use the expression for the\n\tcharacter length for a character subreference.\n\t(gfc_conv_substring, gfc_conv_subref_array_arg): Add NULL for\n\tthird argument in call to gfc_build_array_ref.\n\t(gfc_conv_aliased_arg): Rename to gfc_conv_subref_array_arg.\n\t(is_aliased_array): Remove.\n\t(gfc_conv_function_call): Change reference to is_aliased_array\n\tto gfc_is_subref_array and reference to gfc_conv_aliased_arg to\n\tgfc_conv_subref_array_arg.\n\t(gfc_trans_pointer_assignment): Add the array element length to\n\tthe lang_decl 'span' field.\n\t* gfortran.h : Add subref_array_pointer to symbol_attribute and\n\tadd the prototype for gfc_is_subref_array.\n\t* trans-stmt.c : Add NULL for third argument in all references\n\tto gfc_build_array_ref.\n\t* expr.c (gfc_is_subref_array): Renamed is_aliased_array.\n\tIf this is a subreference array pointer, return true.\n\t(gfc_check_pointer_assign): If the rhs is a subreference array,\n\tset the lhs subreference_array_pointer attribute.\n\t* trans-decl.c (gfc_get_symbol_decl): Allocate the lang_decl\n\tfield if the symbol is a subreference array pointer and set an\n\tinitial value of zero for the 'span' field.\n\t* trans-io.c (set_internal_unit): Refer to is_subref_array and\n\tgfc_conv_subref_array_arg.\n\t(nml_get_addr_expr): Add NULL third argument to\n\tgfc_build_array_ref. \n\t(gfc_trans_transfer): Use the scalarizer for a subreference\n\tarray.\n\n2007-09-16  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/29396\n\tPR fortran/29606\n\tPR fortran/30625\n\tPR fortran/30871\n\t* gfortran.dg/subref_array_pointer_1.f90: New test.\n\t* gfortran.dg/subref_array_pointer_2.f90: New test.\n\nFrom-SVN: r128523", "tree": {"sha": "0671456d4a0001c3c76dbc6dc8b6b3c8d5ac9a80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0671456d4a0001c3c76dbc6dc8b6b3c8d5ac9a80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d6b7f396a30bc20304c97d54379b25f4aa5c92f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d6b7f396a30bc20304c97d54379b25f4aa5c92f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d6b7f396a30bc20304c97d54379b25f4aa5c92f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/comments", "author": null, "committer": null, "parents": [{"sha": "1b95f1f634ddfdc1aae90d49103584a5dd0b8221", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b95f1f634ddfdc1aae90d49103584a5dd0b8221", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b95f1f634ddfdc1aae90d49103584a5dd0b8221"}], "stats": {"total": 579, "additions": 502, "deletions": 77}, "files": [{"sha": "6aca2c7ddd753365a96048eba0f25017babe6023", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1d6b7f396a30bc20304c97d54379b25f4aa5c92f", "patch": "@@ -1,3 +1,60 @@\n+2007-09-16  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/29396\n+\tPR fortran/29606\n+\tPR fortran/30625\n+\tPR fortran/30871\n+\t* trans.h : Add extra argument to gfc_build_array_ref. Rename\n+\tgfc_conv_aliased_arg to gfc_conv_subref_array_arg.  Move\n+\tprototype of is_aliased_array to gfortran.h and rename it\n+\tgfc_is_subref_array.  Add field span to lang_decl, add a new\n+\tdecl lang specific flag accessed by GFC_DECL_SUBREF_ARRAY_P\n+\tand a new type flag GFC_DECL_SUBREF_ARRAY_P.\n+\t* trans.c (gfc_build_array_ref): Add the new argument, decl.\n+\tIf this is a subreference array pointer, use the lang_decl\n+\tfield 'span' to calculate the offset in bytes and use pointer\n+\tarithmetic to address the element.\n+\t* trans-array.c (gfc_conv_scalarized_array_ref,\n+\tgfc_conv_array_ref): Add the backend declaration as the third\n+\tfield, if it is likely to be a subreference array pointer.\n+\t(gfc_conv_descriptor_dimension, gfc_trans_array_ctor_element,\n+\tgfc_trans_array_constructor_element, structure_alloc_comps,\n+\tgfc_conv_array_index_offset): For all other references to\n+\tgfc_build_array_ref, set the third argument to NULL.\n+\t(gfc_get_dataptr_offset): New function.\n+\t(gfc_conv_expr_descriptor): If the rhs of a pointer assignment\n+\tis a subreference array, then calculate the offset to the\n+\tsubreference of the first element and set the descriptor data\n+\tpointer to this, using gfc_get_dataptr_offset.\n+\ttrans-expr.c (gfc_get_expr_charlen): Use the expression for the\n+\tcharacter length for a character subreference.\n+\t(gfc_conv_substring, gfc_conv_subref_array_arg): Add NULL for\n+\tthird argument in call to gfc_build_array_ref.\n+\t(gfc_conv_aliased_arg): Rename to gfc_conv_subref_array_arg.\n+\t(is_aliased_array): Remove.\n+\t(gfc_conv_function_call): Change reference to is_aliased_array\n+\tto gfc_is_subref_array and reference to gfc_conv_aliased_arg to\n+\tgfc_conv_subref_array_arg.\n+\t(gfc_trans_pointer_assignment): Add the array element length to\n+\tthe lang_decl 'span' field.\n+\t* gfortran.h : Add subref_array_pointer to symbol_attribute and\n+\tadd the prototype for gfc_is_subref_array.\n+\t* trans-stmt.c : Add NULL for third argument in all references\n+\tto gfc_build_array_ref.\n+\t* expr.c (gfc_is_subref_array): Renamed is_aliased_array.\n+\tIf this is a subreference array pointer, return true.\n+\t(gfc_check_pointer_assign): If the rhs is a subreference array,\n+\tset the lhs subreference_array_pointer attribute.\n+\t* trans-decl.c (gfc_get_symbol_decl): Allocate the lang_decl\n+\tfield if the symbol is a subreference array pointer and set an\n+\tinitial value of zero for the 'span' field.\n+\t* trans-io.c (set_internal_unit): Refer to is_subref_array and\n+\tgfc_conv_subref_array_arg.\n+\t(nml_get_addr_expr): Add NULL third argument to\n+\tgfc_build_array_ref. \n+\t(gfc_trans_transfer): Use the scalarizer for a subreference\n+\tarray.\n+\n 2007-09-13  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \t* iresolve.c (resolve_mask_arg): If a mask is an array"}, {"sha": "815612e43a64a5ed048e8bfcefce887e7ecad8a7", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=1d6b7f396a30bc20304c97d54379b25f4aa5c92f", "patch": "@@ -792,6 +792,35 @@ gfc_is_constant_expr (gfc_expr *e)\n }\n \n \n+/* Is true if an array reference is followed by a component or substring\n+   reference.  */\n+bool\n+is_subref_array (gfc_expr * e)\n+{\n+  gfc_ref * ref;\n+  bool seen_array;\n+\n+  if (e->expr_type != EXPR_VARIABLE)\n+    return false;\n+\n+  if (e->symtree->n.sym->attr.subref_array_pointer)\n+    return true;\n+\n+  seen_array = false;\n+  for (ref = e->ref; ref; ref = ref->next)\n+    {\n+      if (ref->type == REF_ARRAY\n+\t    && ref->u.ar.type != AR_ELEMENT)\n+\tseen_array = true;\n+\n+      if (seen_array\n+\t    && ref->type != REF_ARRAY)\n+\treturn seen_array;\n+    }\n+  return false;\n+}\n+\n+\n /* Try to collapse intrinsic expressions.  */\n \n static try\n@@ -2802,6 +2831,9 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n       return FAILURE;\n     }\n \n+  if (rvalue->expr_type == EXPR_VARIABLE && is_subref_array (rvalue))\n+    lvalue->symtree->n.sym->attr.subref_array_pointer = 1;\n+\n   attr = gfc_expr_attr (rvalue);\n   if (!attr.target && !attr.pointer)\n     {"}, {"sha": "a5f4881f453c03f0e6cbc6e08e051a0ada04db4e", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=1d6b7f396a30bc20304c97d54379b25f4aa5c92f", "patch": "@@ -578,7 +578,7 @@ typedef struct\n   unsigned allocatable:1, dimension:1, external:1, intrinsic:1,\n     optional:1, pointer:1, target:1, value:1, volatile_:1,\n     dummy:1, result:1, assign:1, threadprivate:1, not_always_present:1,\n-    implied_index:1;\n+    implied_index:1, subref_array_pointer:1;\n \n   ENUM_BITFIELD (save_state) save:2;\n \n@@ -2172,6 +2172,7 @@ void gfc_free_actual_arglist (gfc_actual_arglist *);\n gfc_actual_arglist *gfc_copy_actual_arglist (gfc_actual_arglist *);\n const char *gfc_extract_int (gfc_expr *, int *);\n gfc_expr *gfc_expr_to_initialize (gfc_expr *);\n+bool is_subref_array (gfc_expr *);\n \n gfc_expr *gfc_build_conversion (gfc_expr *);\n void gfc_free_ref_list (gfc_ref *);"}, {"sha": "1e02b81167fafd2b068a68d7facb1fc31898a303", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 135, "deletions": 18, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=1d6b7f396a30bc20304c97d54379b25f4aa5c92f", "patch": "@@ -245,7 +245,7 @@ gfc_conv_descriptor_dimension (tree desc, tree dim)\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (field))) == RECORD_TYPE);\n \n   tmp = build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n-  tmp = gfc_build_array_ref (tmp, dim);\n+  tmp = gfc_build_array_ref (tmp, dim, NULL);\n   return tmp;\n }\n \n@@ -961,7 +961,7 @@ gfc_trans_array_ctor_element (stmtblock_t * pblock, tree desc,\n \n   /* Store the value.  */\n   tmp = build_fold_indirect_ref (gfc_conv_descriptor_data_get (desc));\n-  tmp = gfc_build_array_ref (tmp, offset);\n+  tmp = gfc_build_array_ref (tmp, offset, NULL);\n   if (expr->ts.type == BT_CHARACTER)\n     {\n       gfc_conv_string_parameter (se);\n@@ -1181,7 +1181,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t      /* Use BUILTIN_MEMCPY to assign the values.  */\n \t      tmp = gfc_conv_descriptor_data_get (desc);\n \t      tmp = build_fold_indirect_ref (tmp);\n-\t      tmp = gfc_build_array_ref (tmp, *poffset);\n+\t      tmp = gfc_build_array_ref (tmp, *poffset, NULL);\n \t      tmp = build_fold_addr_expr (tmp);\n \t      init = build_fold_addr_expr (init);\n \n@@ -2167,7 +2167,7 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n \n \t  /* Read the vector to get an index into info->descriptor.  */\n \t  data = build_fold_indirect_ref (gfc_conv_array_data (desc));\n-\t  index = gfc_build_array_ref (data, index);\n+\t  index = gfc_build_array_ref (data, index, NULL);\n \t  index = gfc_evaluate_now (index, &se->pre);\n \n \t  /* Do any bounds checking on the final info->descriptor index.  */\n@@ -2219,6 +2219,7 @@ static void\n gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n {\n   gfc_ss_info *info;\n+  tree decl = NULL_TREE;\n   tree index;\n   tree tmp;\n   int n;\n@@ -2236,8 +2237,11 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n   if (!integer_zerop (info->offset))\n     index = fold_build2 (PLUS_EXPR, gfc_array_index_type, index, info->offset);\n \n+  if (se->ss->expr && is_subref_array (se->ss->expr))\n+    decl = se->ss->expr->symtree->n.sym->backend_decl;\n+\n   tmp = build_fold_indirect_ref (info->data);\n-  se->expr = gfc_build_array_ref (tmp, index);\n+  se->expr = gfc_build_array_ref (tmp, index, decl);\n }\n \n \n@@ -2338,11 +2342,11 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n   tmp = gfc_conv_array_offset (se->expr);\n   if (!integer_zerop (tmp))\n     index = fold_build2 (PLUS_EXPR, gfc_array_index_type, index, tmp);\n-      \n+\n   /* Access the calculated element.  */\n   tmp = gfc_conv_array_data (se->expr);\n   tmp = build_fold_indirect_ref (tmp);\n-  se->expr = gfc_build_array_ref (tmp, index);\n+  se->expr = gfc_build_array_ref (tmp, index, sym->backend_decl);\n }\n \n \n@@ -4336,6 +4340,116 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n }\n \n \n+/* Calculate the overall offset, including subreferences.  */\n+static void\n+gfc_get_dataptr_offset (stmtblock_t *block, tree parm, tree desc, tree offset,\n+\t\t\tbool subref, gfc_expr *expr)\n+{\n+  tree tmp;\n+  tree field;\n+  tree stride;\n+  tree index;\n+  gfc_ref *ref;\n+  gfc_se start;\n+  int n;\n+\n+  /* If offset is NULL and this is not a subreferenced array, there is\n+     nothing to do.  */\n+  if (offset == NULL_TREE)\n+    {\n+      if (subref)\n+\toffset = gfc_index_zero_node;\n+      else\n+\treturn;\n+    }\n+\n+  tmp = gfc_conv_array_data (desc);\n+  tmp = build_fold_indirect_ref (tmp);\n+  tmp = gfc_build_array_ref (tmp, offset, NULL);\n+\n+  /* Offset the data pointer for pointer assignments from arrays with\n+     subreferences; eg. my_integer => my_type(:)%integer_component.  */\n+  if (subref)\n+    {\n+      /* Go past the array reference.  */\n+      for (ref = expr->ref; ref; ref = ref->next)\n+\tif (ref->type == REF_ARRAY &&\n+\t      ref->u.ar.type != AR_ELEMENT)\n+\t  {\n+\t    ref = ref->next;\n+\t    break;\n+\t  }\n+\n+      /* Calculate the offset for each subsequent subreference.  */\n+      for (; ref; ref = ref->next)\n+\t{\n+\t  switch (ref->type)\n+\t    {\n+\t    case REF_COMPONENT:\n+\t      field = ref->u.c.component->backend_decl;\n+\t      gcc_assert (field && TREE_CODE (field) == FIELD_DECL);\n+\t      tmp = build3 (COMPONENT_REF, TREE_TYPE (field), tmp, field, NULL_TREE);\n+\t      break;\n+\n+\t    case REF_SUBSTRING:\n+\t      gcc_assert (TREE_CODE (TREE_TYPE (tmp)) == ARRAY_TYPE);\n+\t      gfc_init_se (&start, NULL);\n+\t      gfc_conv_expr_type (&start, ref->u.ss.start, gfc_charlen_type_node);\n+\t      gfc_add_block_to_block (block, &start.pre);\n+\t      tmp = gfc_build_array_ref (tmp, start.expr, NULL);\n+\t      break;\n+\n+\t    case REF_ARRAY:\n+\t      gcc_assert (TREE_CODE (TREE_TYPE (tmp)) == ARRAY_TYPE\n+\t\t\t    && ref->u.ar.type == AR_ELEMENT);\n+\n+\t      /* TODO - Add bounds checking.  */\n+\t      stride = gfc_index_one_node;\n+\t      index = gfc_index_zero_node;\n+\t      for (n = 0; n < ref->u.ar.dimen; n++)\n+\t\t{\n+\t\t  tree itmp;\n+\t\t  tree jtmp;\n+\n+\t\t  /* Update the index.  */\n+\t\t  gfc_init_se (&start, NULL);\n+\t\t  gfc_conv_expr_type (&start, ref->u.ar.start[n], gfc_array_index_type);\n+\t\t  itmp = gfc_evaluate_now (start.expr, block);\n+\t\t  gfc_init_se (&start, NULL);\n+\t\t  gfc_conv_expr_type (&start, ref->u.ar.as->lower[n], gfc_array_index_type);\n+\t\t  jtmp = gfc_evaluate_now (start.expr, block);\n+\t\t  itmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, itmp, jtmp);\n+\t\t  itmp = fold_build2 (MULT_EXPR, gfc_array_index_type, itmp, stride);\n+\t\t  index = fold_build2 (PLUS_EXPR, gfc_array_index_type, itmp, index);\n+\t\t  index = gfc_evaluate_now (index, block);\n+\n+\t\t  /* Update the stride.  */\n+\t\t  gfc_init_se (&start, NULL);\n+\t\t  gfc_conv_expr_type (&start, ref->u.ar.as->upper[n], gfc_array_index_type);\n+\t\t  itmp =  fold_build2 (MINUS_EXPR, gfc_array_index_type, start.expr, jtmp);\n+\t\t  itmp =  fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t\t       gfc_index_one_node, itmp);\n+\t\t  stride =  fold_build2 (MULT_EXPR, gfc_array_index_type, stride, itmp);\n+\t\t  stride = gfc_evaluate_now (stride, block);\n+\t\t}\n+\n+\t      /* Apply the index to obtain the array element.  */\n+\t      tmp = gfc_build_array_ref (tmp, index, NULL);\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  /* Set the target data pointer.  */\n+  offset = gfc_build_addr_expr (gfc_array_dataptr_type (desc), tmp);\n+  gfc_conv_descriptor_data_set (block, parm, offset);\n+}\n+\n+\n /* Convert an array for passing as an actual argument.  Expressions and\n    vector subscripts are evaluated and stored in a temporary, which is then\n    passed.  For whole arrays the descriptor is passed.  For array sections\n@@ -4373,6 +4487,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n   tree start;\n   tree offset;\n   int full;\n+  bool subref_array_target = false;\n \n   gcc_assert (ss != gfc_ss_terminator);\n \n@@ -4395,7 +4510,10 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       gfc_conv_ss_descriptor (&se->pre, secss, 0);\n       desc = info->descriptor;\n \n-      need_tmp = gfc_ref_needs_temporary_p (expr->ref);\n+      subref_array_target = se->direct_byref && is_subref_array (expr);\n+      need_tmp = gfc_ref_needs_temporary_p (expr->ref)\n+\t\t\t&& !subref_array_target;\n+\n       if (need_tmp)\n \tfull = 0;\n       else if (GFC_ARRAY_TYPE_P (TREE_TYPE (desc)))\n@@ -4416,6 +4534,10 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t    {\n \t      /* Copy the descriptor for pointer assignments.  */\n \t      gfc_add_modify_expr (&se->pre, se->expr, desc);\n+\n+\t      /* Add any offsets from subreferences.  */\n+\t      gfc_get_dataptr_offset (&se->pre, se->expr, desc, NULL_TREE,\n+\t\t\t\t      subref_array_target, expr);\n \t    }\n \t  else if (se->want_pointer)\n \t    {\n@@ -4742,14 +4864,9 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       if (se->data_not_needed)\n \tgfc_conv_descriptor_data_set (&loop.pre, parm, gfc_index_zero_node);\n       else\n-\t{\n-\t  /* Point the data pointer at the first element in the section.  */\n-\t  tmp = gfc_conv_array_data (desc);\n-\t  tmp = build_fold_indirect_ref (tmp);\n-\t  tmp = gfc_build_array_ref (tmp, offset);\n-\t  offset = gfc_build_addr_expr (gfc_array_dataptr_type (desc), tmp);\n-\t  gfc_conv_descriptor_data_set (&loop.pre, parm, offset);\n-\t}\n+\t/* Point the data pointer at the first element in the section.  */\n+\tgfc_get_dataptr_offset (&loop.pre, parm, desc, offset,\n+\t\t\t\tsubref_array_target, expr);\n \n       if ((se->direct_byref || GFC_ARRAY_TYPE_P (TREE_TYPE (desc)))\n \t  && !se->data_not_needed)\n@@ -5082,15 +5199,15 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n       /* Build the body of the loop.  */\n       gfc_init_block (&loopbody);\n \n-      vref = gfc_build_array_ref (var, index);\n+      vref = gfc_build_array_ref (var, index, NULL);\n \n       if (purpose == COPY_ALLOC_COMP)\n         {\n           tmp = gfc_duplicate_allocatable (dest, decl, TREE_TYPE(decl), rank);\n \t  gfc_add_expr_to_block (&fnblock, tmp);\n \n \t  tmp = build_fold_indirect_ref (gfc_conv_descriptor_data_get (dest));\n-\t  dref = gfc_build_array_ref (tmp, index);\n+\t  dref = gfc_build_array_ref (tmp, index, NULL);\n \t  tmp = structure_alloc_comps (der_type, vref, dref, rank, purpose);\n \t}\n       else"}, {"sha": "854ca54af02e8f5cd2b88e3146129090b7da8595", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=1d6b7f396a30bc20304c97d54379b25f4aa5c92f", "patch": "@@ -1016,6 +1016,25 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t  gcc_assert (!sym->value);\n \t}\n     }\n+  else if (sym->attr.subref_array_pointer)\n+    {\n+      /* We need the span for these beasts.  */\n+      gfc_allocate_lang_decl (decl);\n+    }\n+\n+  if (sym->attr.subref_array_pointer)\n+    {\n+      tree span;\n+      GFC_DECL_SUBREF_ARRAY_P (decl) = 1;\n+      span = build_decl (VAR_DECL, create_tmp_var_name (\"span\"),\n+\t\t\t gfc_array_index_type);\n+      gfc_finish_var_decl (span, sym);\n+      TREE_STATIC (span) = 1;\n+      DECL_INITIAL (span) = build_int_cst (NULL_TREE, 0);\n+\n+      GFC_DECL_SPAN (decl) = span;\n+    }\n+\n   sym->backend_decl = decl;\n \n   if (sym->attr.assign)"}, {"sha": "f5d7c65b80f4cfb50234688a7d4ce7be8bbc3818", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=1d6b7f396a30bc20304c97d54379b25f4aa5c92f", "patch": "@@ -183,6 +183,15 @@ gfc_get_expr_charlen (gfc_expr *e)\n   \n   length = NULL; /* To silence compiler warning.  */\n \n+  if (is_subref_array (e) && e->ts.cl->length)\n+    {\n+      gfc_se tmpse;\n+      gfc_init_se (&tmpse, NULL);\n+      gfc_conv_expr_type (&tmpse, e->ts.cl->length, gfc_charlen_type_node);\n+      e->ts.cl->backend_decl = tmpse.expr;\n+      return tmpse.expr;\n+    }\n+\n   /* First candidate: if the variable is of type CHARACTER, the\n      expression's length could be the length of the character\n      variable.  */\n@@ -207,6 +216,7 @@ gfc_get_expr_charlen (gfc_expr *e)\n \t  /* We should never got substring references here.  These will be\n \t     broken down by the scalarizer.  */\n \t  gcc_unreachable ();\n+\t  break;\n \t}\n     }\n \n@@ -270,7 +280,7 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n \ttmp = se->expr;\n       else\n \ttmp = build_fold_indirect_ref (se->expr);\n-      tmp = gfc_build_array_ref (tmp, start.expr);\n+      tmp = gfc_build_array_ref (tmp, start.expr, NULL);\n       se->expr = gfc_build_addr_expr (type, tmp);\n     }\n \n@@ -1782,15 +1792,13 @@ gfc_apply_interface_mapping (gfc_interface_mapping * mapping,\n   gfc_free_expr (expr);\n }\n \n+\n /* Returns a reference to a temporary array into which a component of\n    an actual argument derived type array is copied and then returned\n-   after the function call.\n-   TODO Get rid of this kludge, when array descriptors are capable of\n-   handling arrays with a bigger stride in bytes than size.  */\n-\n+   after the function call.  */\n void\n-gfc_conv_aliased_arg (gfc_se * parmse, gfc_expr * expr,\n-\t\t      int g77, sym_intent intent)\n+gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr,\n+\t\t\t   int g77, sym_intent intent)\n {\n   gfc_se lse;\n   gfc_se rse;\n@@ -1962,7 +1970,7 @@ gfc_conv_aliased_arg (gfc_se * parmse, gfc_expr * expr,\n \n   /* Now use the offset for the reference.  */\n   tmp = build_fold_indirect_ref (info->data);\n-  rse.expr = gfc_build_array_ref (tmp, tmp_index);\n+  rse.expr = gfc_build_array_ref (tmp, tmp_index, NULL);\n \n   if (expr->ts.type == BT_CHARACTER)\n     rse.string_length = expr->ts.cl->backend_decl;\n@@ -2005,28 +2013,6 @@ gfc_conv_aliased_arg (gfc_se * parmse, gfc_expr * expr,\n   return;\n }\n \n-/* Is true if an array reference is followed by a component or substring\n-   reference.  */\n-\n-bool\n-is_aliased_array (gfc_expr * e)\n-{\n-  gfc_ref * ref;\n-  bool seen_array;\n-\n-  seen_array = false;\t\n-  for (ref = e->ref; ref; ref = ref->next)\n-    {\n-      if (ref->type == REF_ARRAY\n-\t    && ref->u.ar.type != AR_ELEMENT)\n-\tseen_array = true;\n-\n-      if (seen_array\n-\t    && ref->type != REF_ARRAY)\n-\treturn seen_array;\n-    }\n-  return false;\n-}\n \n /* Generate the code for argument list functions.  */\n \n@@ -2256,12 +2242,12 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t      f = f || !sym->attr.always_explicit;\n \n \t      if (e->expr_type == EXPR_VARIABLE\n-\t\t    && is_aliased_array (e))\n+\t\t    && is_subref_array (e))\n \t\t/* The actual argument is a component reference to an\n \t\t   array of derived types.  In this case, the argument\n \t\t   is converted to a temporary, which is passed and then\n \t\t   written back after the procedure call.  */\n-\t\tgfc_conv_aliased_arg (&parmse, e, f,\n+\t\tgfc_conv_subref_array_arg (&parmse, e, f,\n \t\t\tfsym ? fsym->attr.intent : INTENT_INOUT);\n \t      else\n \t        gfc_conv_array_parameter (&parmse, e, argss, f);\n@@ -3471,6 +3457,8 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n   stmtblock_t block;\n   tree desc;\n   tree tmp;\n+  tree decl;\n+\n \n   gfc_start_block (&block);\n \n@@ -3509,6 +3497,19 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t  /* Assign directly to the pointer's descriptor.  */\n           lse.direct_byref = 1;\n \t  gfc_conv_expr_descriptor (&lse, expr2, rss);\n+\n+\t  /* If this is a subreference array pointer assignment, use the rhs\n+\t     element size for the lhs span.  */\n+\t  if (expr1->symtree->n.sym->attr.subref_array_pointer)\n+\t    {\n+\t      decl = expr1->symtree->n.sym->backend_decl;\n+\t      tmp = rss->data.info.descriptor;\n+\t      tmp = gfc_get_element_type (TREE_TYPE (tmp));\n+\t      tmp = size_in_bytes (tmp);\n+\t      tmp = fold_convert (gfc_array_index_type, tmp);\n+\t      gfc_add_modify_expr (&lse.post, GFC_DECL_SPAN(decl), tmp);\n+\t    }\n+\n \t  break;\n \n \tdefault:"}, {"sha": "72875f1e7beb96673e6fcf294aa7bc2a03cd64cc", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=1d6b7f396a30bc20304c97d54379b25f4aa5c92f", "patch": "@@ -724,11 +724,11 @@ set_internal_unit (stmtblock_t * block, stmtblock_t * post_block,\n     {\n       se.ss = gfc_walk_expr (e);\n \n-      if (is_aliased_array (e))\n+      if (is_subref_array (e))\n \t{\n \t  /* Use a temporary for components of arrays of derived types\n \t     or substring array references.  */\n-\t  gfc_conv_aliased_arg (&se, e, 0,\n+\t  gfc_conv_subref_array_arg (&se, e, 0,\n \t\tlast_dt == READ ? INTENT_IN : INTENT_OUT);\n \t  tmp = build_fold_indirect_ref (se.expr);\n \t  se.expr = gfc_build_addr_expr (pchar_type_node, tmp);\n@@ -1330,7 +1330,7 @@ nml_get_addr_expr (gfc_symbol * sym, gfc_component * c,\n      a RECORD_TYPE.  */\n \n   if (array_flagged)\n-    tmp = gfc_build_array_ref (tmp, gfc_index_zero_node);\n+    tmp = gfc_build_array_ref (tmp, gfc_index_zero_node, NULL);\n \n   /* Now build the address expression.  */\n \n@@ -1964,7 +1964,9 @@ gfc_trans_transfer (gfc_code * code)\n \t  gcc_assert (ref->type == REF_ARRAY);\n \t}\n \n-      if (expr->ts.type != BT_DERIVED && ref && ref->next == NULL)\n+      if (expr->ts.type != BT_DERIVED\n+\t    && ref && ref->next == NULL\n+\t    && !is_subref_array (expr))\n \t{\n \t  /* Get the descriptor.  */\n \t  gfc_conv_expr_descriptor (&se, expr, ss);"}, {"sha": "0bf0387d9508311e62242ea5f64bd2b008db2de8", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=1d6b7f396a30bc20304c97d54379b25f4aa5c92f", "patch": "@@ -1650,7 +1650,7 @@ gfc_trans_nested_forall_loop (forall_info * nested_forall_info, tree body,\n           /* If a mask was specified make the assignment conditional.  */\n           if (mask)\n             {\n-              tmp = gfc_build_array_ref (mask, maskindex);\n+              tmp = gfc_build_array_ref (mask, maskindex, NULL);\n               body = build3_v (COND_EXPR, tmp, body, build_empty_stmt ());\n             }\n         }\n@@ -1729,7 +1729,7 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree count3,\n       gfc_conv_expr (&lse, expr);\n \n       /* Form the expression for the temporary.  */\n-      tmp = gfc_build_array_ref (tmp1, count1);\n+      tmp = gfc_build_array_ref (tmp1, count1, NULL);\n \n       /* Use the scalar assignment as is.  */\n       gfc_add_block_to_block (&block, &lse.pre);\n@@ -1770,7 +1770,7 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree count3,\n \n       /* Form the expression of the temporary.  */\n       if (lss != gfc_ss_terminator)\n-\trse.expr = gfc_build_array_ref (tmp1, count1);\n+\trse.expr = gfc_build_array_ref (tmp1, count1, NULL);\n       /* Translate expr.  */\n       gfc_conv_expr (&lse, expr);\n \n@@ -1781,7 +1781,7 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree count3,\n       /* Form the mask expression according to the mask tree list.  */\n       if (wheremask)\n \t{\n-\t  wheremaskexpr = gfc_build_array_ref (wheremask, count3);\n+\t  wheremaskexpr = gfc_build_array_ref (wheremask, count3, NULL);\n \t  if (invert)\n \t    wheremaskexpr = fold_build1 (TRUTH_NOT_EXPR,\n \t\t\t\t\t TREE_TYPE (wheremaskexpr),\n@@ -1843,7 +1843,7 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree count3,\n     {\n       gfc_init_block (&body1);\n       gfc_conv_expr (&rse, expr2);\n-      lse.expr = gfc_build_array_ref (tmp1, count1);\n+      lse.expr = gfc_build_array_ref (tmp1, count1, NULL);\n     }\n   else\n     {\n@@ -1867,7 +1867,7 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree count3,\n       gfc_conv_expr (&rse, expr2);\n \n       /* Form the expression of the temporary.  */\n-      lse.expr = gfc_build_array_ref (tmp1, count1);\n+      lse.expr = gfc_build_array_ref (tmp1, count1, NULL);\n     }\n \n   /* Use the scalar assignment.  */\n@@ -1878,7 +1878,7 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree count3,\n   /* Form the mask expression according to the mask tree list.  */\n   if (wheremask)\n     {\n-      wheremaskexpr = gfc_build_array_ref (wheremask, count3);\n+      wheremaskexpr = gfc_build_array_ref (wheremask, count3, NULL);\n       if (invert)\n \twheremaskexpr = fold_build1 (TRUTH_NOT_EXPR,\n \t\t\t\t     TREE_TYPE (wheremaskexpr),\n@@ -2251,7 +2251,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n \t\t\t\t\t    inner_size, NULL, block, &ptemp1);\n       gfc_start_block (&body);\n       gfc_init_se (&lse, NULL);\n-      lse.expr = gfc_build_array_ref (tmp1, count);\n+      lse.expr = gfc_build_array_ref (tmp1, count, NULL);\n       gfc_init_se (&rse, NULL);\n       rse.want_pointer = 1;\n       gfc_conv_expr (&rse, expr2);\n@@ -2278,7 +2278,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_start_block (&body);\n       gfc_init_se (&lse, NULL);\n       gfc_init_se (&rse, NULL);\n-      rse.expr = gfc_build_array_ref (tmp1, count);\n+      rse.expr = gfc_build_array_ref (tmp1, count, NULL);\n       lse.want_pointer = 1;\n       gfc_conv_expr (&lse, expr1);\n       gfc_add_block_to_block (&body, &lse.pre);\n@@ -2320,7 +2320,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n \t\t\t\t\t    inner_size, NULL, block, &ptemp1);\n       gfc_start_block (&body);\n       gfc_init_se (&lse, NULL);\n-      lse.expr = gfc_build_array_ref (tmp1, count);\n+      lse.expr = gfc_build_array_ref (tmp1, count, NULL);\n       lse.direct_byref = 1;\n       rss = gfc_walk_expr (expr2);\n       gfc_conv_expr_descriptor (&lse, expr2, rss);\n@@ -2343,7 +2343,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       /* Reset count.  */\n       gfc_add_modify_expr (block, count, gfc_index_zero_node);\n \n-      parm = gfc_build_array_ref (tmp1, count);\n+      parm = gfc_build_array_ref (tmp1, count, NULL);\n       lss = gfc_walk_expr (expr1);\n       gfc_init_se (&lse, NULL);\n       gfc_conv_expr_descriptor (&lse, expr1, lss);\n@@ -2596,7 +2596,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n       /* Store the mask.  */\n       se.expr = convert (mask_type, se.expr);\n \n-      tmp = gfc_build_array_ref (mask, maskindex);\n+      tmp = gfc_build_array_ref (mask, maskindex, NULL);\n       gfc_add_modify_expr (&body, tmp, se.expr);\n \n       /* Advance to the next mask element.  */\n@@ -2795,15 +2795,15 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n \n   if (mask && (cmask || pmask))\n     {\n-      tmp = gfc_build_array_ref (mask, count);\n+      tmp = gfc_build_array_ref (mask, count, NULL);\n       if (invert)\n \ttmp = fold_build1 (TRUTH_NOT_EXPR, mask_type, tmp);\n       gfc_add_modify_expr (&body1, mtmp, tmp);\n     }\n \n   if (cmask)\n     {\n-      tmp1 = gfc_build_array_ref (cmask, count);\n+      tmp1 = gfc_build_array_ref (cmask, count, NULL);\n       tmp = cond;\n       if (mask)\n \ttmp = build2 (TRUTH_AND_EXPR, mask_type, mtmp, tmp);\n@@ -2812,7 +2812,7 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n \n   if (pmask)\n     {\n-      tmp1 = gfc_build_array_ref (pmask, count);\n+      tmp1 = gfc_build_array_ref (pmask, count, NULL);\n       tmp = build1 (TRUTH_NOT_EXPR, mask_type, cond);\n       if (mask)\n \ttmp = build2 (TRUTH_AND_EXPR, mask_type, mtmp, tmp);\n@@ -2971,7 +2971,7 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n \n   /* Form the mask expression according to the mask.  */\n   index = count1;\n-  maskexpr = gfc_build_array_ref (mask, index);\n+  maskexpr = gfc_build_array_ref (mask, index, NULL);\n   if (invert)\n     maskexpr = fold_build1 (TRUTH_NOT_EXPR, TREE_TYPE (maskexpr), maskexpr);\n \n@@ -3028,7 +3028,7 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n \n           /* Form the mask expression according to the mask tree list.  */\n           index = count2;\n-          maskexpr = gfc_build_array_ref (mask, index);\n+          maskexpr = gfc_build_array_ref (mask, index, NULL);\n \t  if (invert)\n \t    maskexpr = fold_build1 (TRUTH_NOT_EXPR, TREE_TYPE (maskexpr),\n \t\t\t\t    maskexpr);"}, {"sha": "0d036aadfa1e8502ba69c10e6bb8baa56c231b9b", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=1d6b7f396a30bc20304c97d54379b25f4aa5c92f", "patch": "@@ -309,9 +309,11 @@ gfc_build_addr_expr (tree type, tree t)\n /* Build an ARRAY_REF with its natural type.  */\n \n tree\n-gfc_build_array_ref (tree base, tree offset)\n+gfc_build_array_ref (tree base, tree offset, tree decl)\n {\n   tree type = TREE_TYPE (base);\n+  tree tmp;\n+\n   gcc_assert (TREE_CODE (type) == ARRAY_TYPE);\n   type = TREE_TYPE (type);\n \n@@ -321,7 +323,28 @@ gfc_build_array_ref (tree base, tree offset)\n   /* Strip NON_LVALUE_EXPR nodes.  */\n   STRIP_TYPE_NOPS (offset);\n \n-  return build4 (ARRAY_REF, type, base, offset, NULL_TREE, NULL_TREE);\n+  /* If the array reference is to a pointer, whose target contains a\n+     subreference, use the span that is stored with the backend decl\n+     and reference the element with pointer arithmetic.  */\n+  if (decl && (TREE_CODE (decl) == FIELD_DECL\n+\t\t || TREE_CODE (decl) == VAR_DECL\n+\t\t || TREE_CODE (decl) == PARM_DECL)\n+\t&& GFC_DECL_SUBREF_ARRAY_P (decl)\n+\t&& !integer_zerop (GFC_DECL_SPAN(decl)))\n+    {\n+      offset = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t    offset, GFC_DECL_SPAN(decl));\n+      tmp = gfc_build_addr_expr (pvoid_type_node, base);\n+      tmp = fold_build2 (POINTER_PLUS_EXPR, pvoid_type_node,\n+\t\t\t tmp, fold_convert (sizetype, offset));\n+      tmp = fold_convert (build_pointer_type (type), tmp);\n+      if (!TYPE_STRING_FLAG (type))\n+\ttmp = build_fold_indirect_ref (tmp);\n+      return tmp;\n+    }\n+  else\n+    /* Otherwise use a straightforward array reference.  */\n+    return build4 (ARRAY_REF, type, base, offset, NULL_TREE, NULL_TREE);\n }\n \n "}, {"sha": "58bdf3d1ac492640cf418514bd953f3d3f5656f0", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=1d6b7f396a30bc20304c97d54379b25f4aa5c92f", "patch": "@@ -316,8 +316,7 @@ tree gfc_conv_operator_assign (gfc_se *, gfc_se *, gfc_symbol *);\n int gfc_conv_function_call (gfc_se *, gfc_symbol *, gfc_actual_arglist *,\n \t\t\t    tree);\n \n-void gfc_conv_aliased_arg (gfc_se *, gfc_expr *, int, sym_intent);\n-bool is_aliased_array (gfc_expr *);\n+void gfc_conv_subref_array_arg (gfc_se *, gfc_expr *, int, sym_intent);\n \n /* gfc_trans_* shouldn't call push/poplevel, use gfc_push/pop_scope */\n \n@@ -379,7 +378,7 @@ tree gfc_get_function_decl (gfc_symbol *);\n tree gfc_build_addr_expr (tree, tree);\n \n /* Build an ARRAY_REF.  */\n-tree gfc_build_array_ref (tree, tree);\n+tree gfc_build_array_ref (tree, tree, tree);\n \n /* Creates a label.  Decl is artificial if label_id == NULL_TREE.  */\n tree gfc_build_label_decl (tree);\n@@ -593,11 +592,13 @@ struct lang_decl\t\tGTY(())\n      address of target label.  */\n   tree stringlen;\n   tree addr;\n+  tree span;\n };\n \n \n #define GFC_DECL_ASSIGN_ADDR(node) DECL_LANG_SPECIFIC(node)->addr\n #define GFC_DECL_STRING_LEN(node) DECL_LANG_SPECIFIC(node)->stringlen\n+#define GFC_DECL_SPAN(node) DECL_LANG_SPECIFIC(node)->span\n #define GFC_DECL_SAVED_DESCRIPTOR(node) \\\n   (DECL_LANG_SPECIFIC(node)->saved_descriptor)\n #define GFC_DECL_PACKED_ARRAY(node) DECL_LANG_FLAG_0(node)\n@@ -606,6 +607,7 @@ struct lang_decl\t\tGTY(())\n #define GFC_DECL_COMMON_OR_EQUIV(node) DECL_LANG_FLAG_3(node)\n #define GFC_DECL_CRAY_POINTEE(node) DECL_LANG_FLAG_4(node)\n #define GFC_DECL_RESULT(node) DECL_LANG_FLAG_5(node)\n+#define GFC_DECL_SUBREF_ARRAY_P(node) DECL_LANG_FLAG_6(node)\n \n /* An array descriptor.  */\n #define GFC_DESCRIPTOR_TYPE_P(node) TYPE_LANG_FLAG_1(node)"}, {"sha": "496c309ec4ae8f8f819408fd8b95773914a69631", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1d6b7f396a30bc20304c97d54379b25f4aa5c92f", "patch": "@@ -1,3 +1,12 @@\n+2007-09-16  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/29396\n+\tPR fortran/29606\n+\tPR fortran/30625\n+\tPR fortran/30871\n+\t* gfortran.dg/subref_array_pointer_1.f90: New test.\n+\t* gfortran.dg/subref_array_pointer_2.f90: New test.\n+\n 2007-09-15  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* gfortran.dg/nint_2.f90: Correct last change."}, {"sha": "7bb0ff5e609daf27ab6789a198a6a19a8892a31f", "filename": "gcc/testsuite/gfortran.dg/subref_array_pointer_1.f90", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubref_array_pointer_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubref_array_pointer_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubref_array_pointer_1.f90?ref=1d6b7f396a30bc20304c97d54379b25f4aa5c92f", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do run }\n+! Test the fix for PRs29396, 29606, 30625 and 30871, in which pointers\n+! to arrays with subreferences did not work.\n+!\n+  call pr29396\n+  call pr29606\n+  call pr30625\n+  call pr30871\n+contains\n+  subroutine pr29396\n+! Contributed by Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n+    CHARACTER(LEN=2), DIMENSION(:), POINTER :: a \n+    CHARACTER(LEN=4), DIMENSION(3), TARGET :: b \n+    b=(/\"bbbb\",\"bbbb\",\"bbbb\"/) \n+    a=>b(:)(2:3) \n+    a=\"aa\" \n+    IF (ANY(b.NE.(/\"baab\",\"baab\",\"baab\"/))) CALL ABORT() \n+  END subroutine\n+\n+  subroutine pr29606\n+! Contributed by Daniel Franke <franke.daniel@gmail.com> \n+    TYPE foo\n+      INTEGER :: value\n+    END TYPE\n+    TYPE foo_array\n+      TYPE(foo), DIMENSION(:), POINTER :: array\n+    END TYPE\n+    TYPE(foo_array)                :: array_holder\n+    INTEGER, DIMENSION(:), POINTER :: array_ptr\n+    ALLOCATE( array_holder%array(3) )\n+    array_holder%array = (/ foo(1), foo(2), foo(3) /)\n+    array_ptr => array_holder%array%value\n+    if (any (array_ptr .ne. (/1,2,3/))) call abort ()\n+  END subroutine\n+\n+  subroutine pr30625\n+! Contributed by Paul Thomas <pault@gcc.gnu.org> \n+    type :: a\n+      real :: r = 3.14159\n+      integer :: i = 42\n+    end type a\n+    type(a), target :: dt(2)\n+    integer, pointer :: ip(:)\n+    ip => dt%i\n+    if (any (ip .ne. 42)) call abort ()\n+  end subroutine\n+\n+  subroutine pr30871\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk> \n+    TYPE data\n+      CHARACTER(LEN=3) :: A\n+    END TYPE\n+    TYPE(data), DIMENSION(10), TARGET :: Z\n+    CHARACTER(LEN=1), DIMENSION(:), POINTER :: ptr\n+    Z(:)%A=\"123\"\n+    ptr=>Z(:)%A(2:2)\n+    if (any (ptr .ne. \"2\")) call abort ()\n+  END subroutine\n+end"}, {"sha": "97aabf1e16087ddf5db40d0c3a5a90bdc51af2b0", "filename": "gcc/testsuite/gfortran.dg/subref_array_pointer_2.f90", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubref_array_pointer_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d6b7f396a30bc20304c97d54379b25f4aa5c92f/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubref_array_pointer_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubref_array_pointer_2.f90?ref=1d6b7f396a30bc20304c97d54379b25f4aa5c92f", "patch": "@@ -0,0 +1,103 @@\n+! { dg-do run }\n+! Test the fix for PRs29396, 29606, 30625 and 30871, in which pointers\n+! to arrays with subreferences did not work.\n+!\n+  type :: t\n+    real :: r\n+    integer :: i\n+    character(3) :: chr\n+  end type t\n+\n+  type :: t2\n+    real :: r(2, 2)\n+    integer :: i\n+    character(3) :: chr\n+  end type t2\n+\n+  type :: s\n+    type(t), pointer :: t(:)\n+  end type s\n+\n+  integer, parameter :: sh(2) = (/2,2/)\n+  real, parameter :: a1(2,2) = reshape ((/1.0,2.0,3.0,4.0/),sh)\n+  real, parameter :: a2(2,2) = reshape ((/5.0,6.0,7.0,8.0/),sh)\n+\n+  type(t), target :: tar1(2) = (/t(1.0, 2, \"abc\"), t(3.0, 4, \"efg\")/)\n+  character(4), target :: tar2(2) = (/\"abcd\",\"efgh\"/)\n+  type(s), target :: tar3\n+  character(2), target :: tar4(2) = (/\"ab\",\"cd\"/)\n+  type(t2), target :: tar5(2) = (/t2(a1, 2, \"abc\"), t2(a2, 4, \"efg\")/)\n+\n+  integer, pointer :: ptr(:)\n+  character(2), pointer :: ptr2(:)\n+  real, pointer :: ptr3(:)\n+\n+!_______________component subreference___________\n+  ptr => tar1%i\n+  ptr = ptr + 1              ! check the scalarizer is OK\n+\n+  if (any (ptr .ne. (/3, 5/))) call abort ()\n+  if (any ((/ptr(1), ptr(2)/) .ne. (/3, 5/))) call abort ()\n+  if (any (tar1%i .ne. (/3, 5/))) call abort ()\n+\n+! Make sure that the other components are not touched.\n+  if (any (tar1%r .ne. (/1.0, 3.0/))) call abort ()\n+  if (any (tar1%chr .ne. (/\"abc\", \"efg\"/))) call abort ()\n+\n+! Check that the pointer is passed correctly as an actual argument.\n+  call foo (ptr)\n+  if (any (tar1%i .ne. (/2, 4/))) call abort ()\n+\n+! And that dummy pointers are OK too.\n+  call bar (ptr)\n+  if (any (tar1%i .ne. (/101, 103/))) call abort ()\n+\n+!_______________substring subreference___________\n+  ptr2 => tar2(:)(2:3)\n+  ptr2 = ptr2(:)(2:2)//\"z\"   ! again, check the scalarizer\n+\n+  if (any (ptr2 .ne. (/\"cz\", \"gz\"/))) call abort ()\n+  if (any ((/ptr2(1), ptr2(2)/) .ne. (/\"cz\", \"gz\"/))) call abort ()\n+  if (any (tar2 .ne. (/\"aczd\", \"egzh\"/))) call abort ()\n+\n+!_______________substring component subreference___________\n+  ptr2 => tar1(:)%chr(1:2)\n+  ptr2 = ptr2(:)(2:2)//\"q\"   ! yet again, check the scalarizer\n+  if (any (ptr2 .ne. (/\"bq\",\"fq\"/))) call abort ()\n+  if (any (tar1%chr .ne. (/\"bqc\",\"fqg\"/))) call abort ()\n+\n+!_______________trailing array element subreference___________\n+  ptr3 => tar5%r(1,2)\n+  ptr3 = (/99.0, 999.0/)\n+  if (any (tar5(1)%r .ne. reshape ((/1.0,2.0,99.0,4.0/), sh))) call abort ()\n+  if (any (tar5(2)%r .ne. reshape ((/5.0,6.0,999.0,8.0/), sh))) call abort ()\n+\n+!_______________forall assignment___________\n+  ptr2 => tar2(:)(1:2)\n+  forall (i = 1:2) ptr2(i)(1:1) = \"z\"\n+  if (any (tar2 .ne. (/\"zczd\", \"zgzh\"/))) call abort ()\n+\n+!_______________something more complicated___________\n+  tar3%t => tar1\n+  ptr3 => tar3%t%r\n+  ptr3 = cos (ptr3)\n+  if (any (ptr3 .ne. (/cos(1.0_4), cos(3.0_4)/))) call abort ()\n+\n+  ptr2 => tar3%t(:)%chr(2:3)\n+  ptr2 = \" x\"\n+  if (any (tar1%chr .ne. (/\"b x\", \"f x\"/))) call abort ()\n+\n+!_______________check non-subref works still___________\n+  ptr2 => tar4\n+  if (any (ptr2 .ne. (/\"ab\",\"cd\"/))) call abort ()\n+\n+contains\n+  subroutine foo (arg)\n+    integer :: arg(:)\n+    arg = arg - 1\n+  end subroutine\n+  subroutine bar (arg)\n+    integer, pointer :: arg(:)\n+    arg = arg + 99\n+  end subroutine\n+end"}]}