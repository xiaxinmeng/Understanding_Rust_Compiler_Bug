{"sha": "840e2ff10988bf7a1adf0bc0a0ac94e51e96ba6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQwZTJmZjEwOTg4YmY3YTFhZGYwYmMwYTBhYzk0ZTUxZTk2YmE2Yw==", "commit": {"author": {"name": "Stephane Carrez", "email": "Stephane.Carrez@worldnet.fr", "date": "2002-03-16T12:52:20Z"}, "committer": {"name": "Stephane Carrez", "email": "ciceron@gcc.gnu.org", "date": "2002-03-16T12:52:20Z"}, "message": "m68hc11-protos.h (ix_reg): Declare.\n\n\t* config/m68hc11/m68hc11-protos.h (ix_reg): Declare.\n\t* config/m68hc11/m68hc11.md (\"addsi3\"): Use general_operand for sources.\n\t(splits): Remove unused add splits.\n\t(\"*addhi3_68hc12\"): Tune constraints.\n\t(\"addhi_sp\"): Try to use X instead of Y in all cases and if the\n\tconstant fits in 8-bits and D is dead use abx/aby instructions.\n\t(\"*addhi3\"): Remove extern declaration of ix_reg.\n\t(\"*subsi3\"): Optimize and provide new split.\n\t(\"subhi3\"): Cleanup.\n\t(\"*subhi3_sp\"): Avoid saving X if we know it is dead.\n\t(arith splits): For 68hc12 save the address register on the stack\n\tand do the arithmetic operation with a pop.\n\nFrom-SVN: r50880", "tree": {"sha": "601ce27d41448786593b04667da83dcbf7421f16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/601ce27d41448786593b04667da83dcbf7421f16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/840e2ff10988bf7a1adf0bc0a0ac94e51e96ba6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/840e2ff10988bf7a1adf0bc0a0ac94e51e96ba6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/840e2ff10988bf7a1adf0bc0a0ac94e51e96ba6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/840e2ff10988bf7a1adf0bc0a0ac94e51e96ba6c/comments", "author": null, "committer": null, "parents": [{"sha": "3c9a5efec97e3684486d0d861610d9c9fd1c8391", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9a5efec97e3684486d0d861610d9c9fd1c8391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c9a5efec97e3684486d0d861610d9c9fd1c8391"}], "stats": {"total": 244, "additions": 134, "deletions": 110}, "files": [{"sha": "87181f2fa8b5efd76efe06514991f625c3ea6457", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/840e2ff10988bf7a1adf0bc0a0ac94e51e96ba6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/840e2ff10988bf7a1adf0bc0a0ac94e51e96ba6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=840e2ff10988bf7a1adf0bc0a0ac94e51e96ba6c", "patch": "@@ -1,3 +1,18 @@\n+2002-03-16  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n+\n+\t* config/m68hc11/m68hc11-protos.h (ix_reg): Declare.\n+\t* config/m68hc11/m68hc11.md (\"addsi3\"): Use general_operand for sources.\n+\t(splits): Remove unused add splits.\n+\t(\"*addhi3_68hc12\"): Tune constraints.\n+\t(\"addhi_sp\"): Try to use X instead of Y in all cases and if the\n+\tconstant fits in 8-bits and D is dead use abx/aby instructions.\n+\t(\"*addhi3\"): Remove extern declaration of ix_reg.\n+\t(\"*subsi3\"): Optimize and provide new split.\n+\t(\"subhi3\"): Cleanup.\n+\t(\"*subhi3_sp\"): Avoid saving X if we know it is dead.\n+\t(arith splits): For 68hc12 save the address register on the stack\n+\tand do the arithmetic operation with a pop.\n+\n 2002-03-16  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n \n \t* config/m68hc11/m68hc11.md (\"*movqi_68hc12\"): Fix constraints, avoid"}, {"sha": "36114850ca28490f55bbad776cda5fdee4a3ac09", "filename": "gcc/config/m68hc11/m68hc11-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/840e2ff10988bf7a1adf0bc0a0ac94e51e96ba6c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/840e2ff10988bf7a1adf0bc0a0ac94e51e96ba6c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h?ref=840e2ff10988bf7a1adf0bc0a0ac94e51e96ba6c", "patch": "@@ -49,6 +49,7 @@ extern rtx m68hc11_compare_op0;\n extern rtx m68hc11_compare_op1;\n extern rtx m68hc11_soft_tmp_reg;\n extern rtx iy_reg;\n+extern rtx ix_reg;\n extern rtx d_reg;\n \n extern void m68hc11_initialize_trampoline PARAMS((rtx, rtx, rtx));"}, {"sha": "092b903f54bac41f93511de7d3aa6cb3d57e94fc", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "modified", "additions": 118, "deletions": 110, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/840e2ff10988bf7a1adf0bc0a0ac94e51e96ba6c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/840e2ff10988bf7a1adf0bc0a0ac94e51e96ba6c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=840e2ff10988bf7a1adf0bc0a0ac94e51e96ba6c", "patch": "@@ -1418,7 +1418,6 @@\n   \"\"\n   \"*\n {\n-  extern rtx ix_reg;\n   rtx ops[3];\n   int need_tst = 0;\n \n@@ -1598,7 +1597,6 @@\n   \"\"\n   \"*\n {\n-  extern rtx ix_reg;\n   rtx ops[2];\n   int x_reg_used;\n \n@@ -1765,35 +1763,12 @@\n ;;\n (define_expand \"addsi3\"\n   [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t             (plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t             (plus:SI (match_operand:SI 1 \"general_operand\" \"\")\n \t\t              (match_operand:SI 2 \"general_operand\" \"\")))\n               (clobber (match_scratch:HI 3 \"\"))])]\n   \"\"\n   \"\")\n \n-;;\n-;; Translate D = D + D into D = D << 1\n-;; We have to do this because adding a register to itself is not possible.\n-;;\n-;; Manipulation of A and B registers directly confuses the cse-regs pass\n-;; so the split must be made after z-replacement register.\n-;;\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"=D\")\n-\t(plus:SI (match_dup 0)\n-\t\t (match_dup 0)))\n-   (clobber (match_scratch:HI 1 \"=X\"))]\n-  \"reload_completed && z_replacement_completed == 2\"\n-  [(set (reg:HI D_REGNUM) (ashift:HI (reg:HI D_REGNUM) (const_int 1)))\n-   (parallel [(set (reg:HI D_REGNUM) (reg:HI X_REGNUM))\n-              (set (reg:HI X_REGNUM) (reg:HI D_REGNUM))])\n-   (set (reg:QI B_REGNUM) (rotate:QI (reg:QI B_REGNUM) (reg:QI CC_REGNUM)))\n-   (set (reg:QI A_REGNUM) (rotate:QI (reg:QI A_REGNUM) (reg:QI CC_REGNUM)))\n-   (parallel [(set (reg:HI D_REGNUM) (reg:HI X_REGNUM))\n-              (set (reg:HI X_REGNUM) (reg:HI D_REGNUM))])]\n-  \"\")\n-\n-\n (define_insn \"*addsi3_zero_extendhi\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=D,D,D,D\")\n \t(plus:SI (zero_extend:SI \n@@ -2113,36 +2088,17 @@\n     }\n }\")\n \n-(define_split /* \"*addhi3_strict_low_part\" */\n-  [(set (strict_low_part (match_operand:QI 0 \"register_operand\" \"+dxy\"))\n-        (plus:QI (match_operand:QI 1 \"register_operand\" \"\")\n-                 (match_operand:QI 2 \"general_operand\" \"\")))]\n-  \"0 && z_replacement_completed == 2\"\n-  [(set (match_dup 0)\n-\t(plus:QI (match_dup 1) (match_dup 2)))]\n-  \"\")\n-\n-(define_split /* \"*addhi3_strict_low_part\" */\n-  [(set (match_operand:HI 0 \"register_operand\" \"=dA\")\n-        (plus:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n-                 (match_operand:HI 2 \"general_operand\" \"\")))\n-   (clobber (match_scratch:HI 3 \"\"))]\n-  \"0 && z_replacement_completed == 2 && !SP_REG_P (operands[0])\"\n-  [(set (match_dup 0)\n-\t(plus:HI (match_dup 1) (match_dup 2)))]\n-  \"\")\n-\n (define_insn \"*addhi3_68hc12\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=*d,A*w,A*w,A\")\n-        (plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0,Aw,0\")\n-                 (match_operand:HI 2 \"general_operand\" \"imA*wu,id,id,!muA\")))]\n+  [(set (match_operand:HI 0 \"register_operand\" \"=xy,d,xy*z*w,xy*z*w,xy*z\")\n+        (plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,xy*zw,0\")\n+                 (match_operand:HI 2 \"general_operand\" \"N,im*A*wu,id,id,!mu*A\")))]\n   \"TARGET_M6812\"\n   \"*\n {\n   int val;\n   const char* insn_code;\n \n-  if (which_alternative >= 3)\n+  if (which_alternative >= 4)\n     {\n       if (A_REG_P (operands[2]))\n         {\n@@ -2183,7 +2139,7 @@\n   else\n     val = 1000;\n \n-  if (val != -1 || val != 1 || !rtx_equal_p (operands[0], operands[1]))\n+  if ((val != -1 && val != 1) || !rtx_equal_p (operands[0], operands[1]))\n     {\n       m68hc11_notice_keep_cc (operands[0]);\n       switch (REGNO (operands[0]))\n@@ -2256,14 +2212,15 @@\n {\n   HOST_WIDE_INT val;\n \n+  if (optimize && Y_REG_P (operands[3])\n+      && dead_register_here (insn, gen_rtx (REG, HImode, HARD_X_REGNUM)))\n+    operands[3] = gen_rtx (REG, HImode, HARD_X_REGNUM);\n+\n   if (GET_CODE (operands[2]) == CONST_INT\n       && (val = INTVAL (operands[2])) != 0\n       && (CONST_OK_FOR_LETTER_P (val, 'P')\n \t  || (val > 0 && val <= 8)))\n     {\n-      if (optimize && Y_REG_P (operands[3])\n-          && dead_register_here (insn, gen_rtx (REG, HImode, HARD_X_REGNUM)))\n-\toperands[3] = gen_rtx (REG, HImode, HARD_X_REGNUM);\n       while (val > 1 || val < -1)\n \t{\n \t  if (val > 0)\n@@ -2297,31 +2254,29 @@\n       return \\\"\\\";\n     }\n \n-  /* Need to transfer to SP to IY and then to D register.\n-     Register IY is lost, this is specified by the (clobber) statement.  */\n+  /* Need to transfer to SP to X/Y and then to D register.\n+     Register X/Y is lost, this is specified by the (clobber) statement.  */\n   output_asm_insn (\\\"ts%3\\\", operands);\n-  output_asm_insn (\\\"xgd%3\\\", operands);\n-  output_asm_insn (\\\"addd\\\\t%2\\\", operands);\n-  output_asm_insn (\\\"xgd%3\\\", operands);\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && ((val = INTVAL (operands[2]) >= 0 && val < 0x100))\n+      && dead_register_here (insn, gen_rtx (REG, HImode, HARD_D_REGNUM)))\n+    {\n+      output_asm_insn (\\\"ldab\\\\t%2\\\", operands);\n+      output_asm_insn (\\\"ab%3\\\", operands);\n+      CC_STATUS_INIT;\n+    }\n+  else\n+    {\n+      output_asm_insn (\\\"xgd%3\\\", operands);\n+      output_asm_insn (\\\"addd\\\\t%2\\\", operands);\n+      output_asm_insn (\\\"xgd%3\\\", operands);\n+    }\n \n    /* The status flags correspond to the addd.  xgdy and tys do not\n       modify the flags.  */\n   return \\\"t%3s\\\";\n }\")\n \n-;;\n-;; Translate d = d + d into d = d << 1\n-;; We have to do this because adding a register to itself is not possible.\n-;; ??? It's not clear whether this is really necessary.\n-;;\n-(define_split\n-  [(set (match_operand:HI 0 \"hard_reg_operand\" \"=dA\")\n-\t(plus:HI (match_dup 0)\n-\t\t (match_dup 0)))]\n-  \"reload_completed\"\n-  [(set (match_dup 0) (ashift:HI (match_dup 0) (const_int 1)))]\n-  \"\")\n-\n (define_insn \"*addhi3\"\n   [(set (match_operand:HI 0 \"hard_reg_operand\" \"=A,d,!A,d*A,!d*A\")\n \t(plus:HI (match_operand:HI 1 \"general_operand\" \"%0,0,0,0,0\")\n@@ -2331,7 +2286,6 @@\n {\n   const char* insn_code;\n   int val;\n-  extern rtx ix_reg;\n \n   if (D_REG_P (operands[0]) && SP_REG_P (operands[2]))\n     {\n@@ -2545,10 +2499,10 @@\n   \"\")\n \n (define_insn \"*subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=D,D\")\n-\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,!mui\")\n-\t\t  (match_operand:SI 2 \"general_operand\" \"!mui,!D\")))\n-   (clobber (match_scratch:HI 3 \"=X,X\"))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=D,D,D,D,!u\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,mi,0,!u,0\")\n+\t\t  (match_operand:SI 2 \"general_operand\" \"mi,D,!u,D,!mui\")))\n+   (clobber (match_scratch:HI 3 \"=X,X,X,X,d\"))]\n   \"\"\n   \"#\")\n \n@@ -2634,6 +2588,27 @@\n    operands[5] = m68hc11_gen_highpart (QImode, operands[4]);\n    operands[4] = m68hc11_gen_lowpart (QImode, operands[4]);\")\n \n+(define_split /* \"*subsi3\" */\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=u\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t  (match_operand:SI 2 \"general_operand\" \"mui\")))\n+   (clobber (match_scratch:HI 3 \"=d\"))]\n+  \"reload_completed && z_replacement_completed == 2\n+   && !X_REG_P (operands[0])\"\n+  [(set (match_dup 3) (match_dup 4))\n+   (set (match_dup 3) (minus:HI (match_dup 3) (match_dup 5)))\n+   (set (match_dup 4) (match_dup 3))\n+   (set (match_dup 3) (match_dup 6))\n+   (set (reg:QI 6) (minus:QI (minus:QI (reg:QI 7) (reg:QI 6)) (match_dup 7)))\n+   (set (reg:QI 5) (minus:QI (minus:QI (reg:QI 7) (reg:QI 5)) (match_dup 8)))\n+   (set (match_dup 6) (match_dup 3))]\n+  \"operands[4] = m68hc11_gen_lowpart (HImode, operands[1]);\n+   operands[5] = m68hc11_gen_lowpart (HImode, operands[2]);\n+   operands[6] = m68hc11_gen_highpart (HImode, operands[1]);\n+   operands[7] = m68hc11_gen_highpart (HImode, operands[2]);\n+   operands[8] = m68hc11_gen_highpart (QImode, operands[7]);\n+   operands[7] = m68hc11_gen_lowpart (QImode, operands[7]);\")\n+\n ;;\n ;; - 16-bit Subtract.\n ;;\n@@ -2642,20 +2617,7 @@\n \t(minus:HI (match_operand:HI 1 \"register_operand\" \"0\")\n \t\t  (match_operand:HI 2 \"general_operand\" \"g\")))]\n   \"\"\n-  \"\n-{\n-  if (TARGET_M6811 && SP_REG_P (operands[0]))\n-    {\n-     emit_insn (gen_rtx (PARALLEL, VOIDmode, gen_rtvec (2,\n-\t\t\t gen_rtx (SET, VOIDmode,\n-\t\t\t\t  operand0,\n-\t\t\t\t  gen_rtx (MINUS, HImode,\n-\t\t\t\t\t   operand1, operand2)),\n-\t\t\tgen_rtx (CLOBBER, VOIDmode,\n-\t\t\t\tgen_rtx (SCRATCH, HImode, 0)))));\n-     DONE;\n-  }\n-}\")\n+  \"\")\n \n ;;\n ;; Subtract from stack. This is better if we provide a pattern.\n@@ -2686,7 +2648,11 @@\n \n   if (D_REG_P (operands[3]))\n     {\n-      output_asm_insn (\\\"xgdx\\\", operands);\n+      int save_x;\n+\n+      save_x = !dead_register_here (insn, ix_reg);\n+      if (save_x)\n+\toutput_asm_insn (\\\"xgdx\\\", operands);\n       output_asm_insn (\\\"tsx\\\", operands);\n       output_asm_insn (\\\"xgdx\\\", operands);\n       output_asm_insn (\\\"subd\\\\t%2\\\", operands);\n@@ -2695,7 +2661,10 @@\n       /* The status flags correspond to the addd. xgdx/y and tx/ys do not\n          modify the flags.  */\n       output_asm_insn (\\\"txs\\\", operands);\n-      return \\\"xgdx\\\";\n+      if (save_x)\n+        return \\\"xgdx\\\";\n+      else\n+        return \\\"\\\";\n     }\n \n   /* Need to transfer to SP to X,Y and then to D register.\n@@ -4014,17 +3983,39 @@\n \t(match_operator:HI 3 \"m68hc11_non_shift_operator\"\n             [(match_operand:HI 1 \"d_register_operand\" \"%0\")\n \t     (match_operand:HI 2 \"hard_reg_operand\" \"*d*A\")]))]\n-  \"z_replacement_completed == 2 && !SP_REG_P (operands[2])\"\n+  \"TARGET_M6811\n+   && z_replacement_completed == 2 && !SP_REG_P (operands[2])\"\n   [(set (match_dup 4) (match_dup 2))\n    (set (match_dup 0) (match_op_dup 3 [(match_dup 0) (match_dup 4)]))]\n   \"operands[4] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);\")\n \n+;;\n+;; For 68HC12, push the operand[2] value on the stack and do the\n+;; logical/arithmetic operation with a pop.\n+;;\n+(define_split\n+  [(set (match_operand:HI 0 \"d_register_operand\" \"=d\")\n+\t(match_operator:HI 3 \"m68hc11_non_shift_operator\"\n+            [(match_operand:HI 1 \"d_register_operand\" \"%0\")\n+\t     (match_operand:HI 2 \"hard_reg_operand\" \"*d*A\")]))]\n+  \"TARGET_M6812\n+   && z_replacement_completed == 2 && !SP_REG_P (operands[2])\"\n+  [(set (match_dup 4) (match_dup 2))\n+   (set (match_dup 0) (match_op_dup 3 [(match_dup 0) (match_dup 5)]))]\n+  \"operands[4] = gen_rtx (MEM, HImode,\n+\t\t\t  gen_rtx (PRE_DEC, HImode,\n+\t\t\t\t   gen_rtx (REG, HImode, HARD_SP_REGNUM)));\n+   operands[5] = gen_rtx (MEM, HImode,\n+\t\t\t  gen_rtx (POST_INC, HImode,\n+\t\t\t\t   gen_rtx (REG, HImode, HARD_SP_REGNUM)));\n+   \")\n+\n ;;--------------------------------------------------------------------\n ;; 16-bit Unary operations on X and Y:\n ;;\n ;;\t\tNOT NEG\n ;;\n-;; Operations on X or Y registers are split here. Instructions are\n+;; Operations on X or Y registers are split here.  Instructions are\n ;; changed into:\n ;;   - xgdx/xgdy instruction pattern,\n ;;   - The same operation on register D,\n@@ -4038,9 +4029,9 @@\n ;;     (set (REG:HI X) (PLUS:HI (REG:HI X) (REG:HI X)))\n ;;\n (define_split\n-  [(set (match_operand:HI 0 \"hard_addr_reg_operand\" \"=A\")\n+  [(set (match_operand:HI 0 \"hard_addr_reg_operand\" \"\")\n \t(match_operator:HI 2 \"m68hc11_unary_operator\"\n-            [(match_operand 1 \"general_operand\" \"uim*d*A\")]))]\n+            [(match_operand 1 \"general_operand\" \"\")]))]\n   \"z_replacement_completed == 2\"\n   [(set (match_dup 4) (match_dup 5))\n    (parallel [(set (reg:HI D_REGNUM) (match_dup 0))\n@@ -4135,10 +4126,10 @@\n ;; The shift operators are special and must not appear here.\n ;;\n (define_split\n-  [(set (match_operand:QI 0 \"d_register_operand\" \"=d\")\n+  [(set (match_operand:QI 0 \"d_register_operand\" \"\")\n \t(match_operator:QI 3 \"m68hc11_non_shift_operator\"\n-            [(match_operand:QI 1 \"d_register_operand\" \"%0\")\n-\t     (match_operand:QI 2 \"hard_reg_operand\" \"*d*x*y\")]))]\n+            [(match_operand:QI 1 \"d_register_operand\" \"\")\n+\t     (match_operand:QI 2 \"hard_reg_operand\" \"\")]))]\n   \"reload_completed\"\n   [(set (match_dup 5) (match_dup 6))\n    (set (match_dup 0) (match_op_dup 3 [(match_dup 0) (match_dup 4)]))]\n@@ -4151,7 +4142,7 @@\n ;;\n ;;\t\tNOT NEG\n ;;\n-;; Operations on X or Y registers are split here. Instructions are\n+;; Operations on X or Y registers are split here.  Instructions are\n ;; changed into:\n ;;   - xgdx/xgdy instruction pattern,\n ;;   - The same operation on register D,\n@@ -4165,9 +4156,9 @@\n ;;     (set (REG:HI X) (PLUS:HI (REG:HI X) (REG:HI X)))\n ;;\n (define_split\n-  [(set (match_operand:QI 0 \"hard_addr_reg_operand\" \"=xy\")\n+  [(set (match_operand:QI 0 \"hard_addr_reg_operand\" \"\")\n \t(match_operator:QI 2 \"m68hc11_unary_operator\"\n-            [(match_operand:QI 1 \"general_operand\" \"uim*d*x*y\")]))]\n+            [(match_operand:QI 1 \"general_operand\" \"\")]))]\n   \"z_replacement_completed == 2\"\n   [(set (match_dup 4) (match_dup 5))\n    (parallel [(set (reg:HI D_REGNUM) (match_dup 3))\n@@ -4420,23 +4411,40 @@\n     operands[8] = m68hc11_gen_lowpart (HImode, operands[8]);\")\n \n (define_insn \"addsi_silshr16\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=D\")\n-          (plus:SI (lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"uim\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=D,D\")\n+          (plus:SI (lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"!*uim,0\")\n \t\t\t\t(const_int 16))\n-\t\t   (match_operand:SI 2 \"general_operand\" \"0\")))]\n+\t\t   (match_operand:SI 2 \"general_operand\" \"0,m!*u\")))]\n   \"\"\n   \"#\")\n \n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"=D\")\n-          (plus:SI (lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"uim\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+          (plus:SI (lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"\")\n \t\t\t\t(const_int 16))\n-\t\t   (match_operand:SI 2 \"general_operand\" \"0\")))]\n-  \"z_replacement_completed == 2\"\n+\t\t   (match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"z_replacement_completed == 2 && !X_REG_P (operands[1])\"\n   [(set (reg:HI D_REGNUM) (plus:HI (reg:HI D_REGNUM) (match_dup 3)))\n-   (set (reg:HI X_REGNUM) (plus:HI (plus:HI (reg:HI X_REGNUM) (const_int 0)) (reg:HI CC_REGNUM)))]\n+   (set (reg:HI X_REGNUM) (plus:HI (plus:HI (reg:HI X_REGNUM)\n+\t\t\t\t\t    (const_int 0))\n+\t\t\t\t   (reg:HI CC_REGNUM)))]\n   \"operands[3] = m68hc11_gen_highpart (HImode, operands[1]);\")\n \n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+          (plus:SI (lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t\t\t(const_int 16))\n+\t\t   (match_operand:SI 2 \"general_operand\" \"\")))]\n+  \"z_replacement_completed == 2 && X_REG_P (operands[1])\"\n+  [(set (reg:HI D_REGNUM) (reg:HI X_REGNUM))\n+   (set (reg:HI X_REGNUM) (match_dup 3))\n+   (set (reg:HI D_REGNUM) (plus:HI (reg:HI D_REGNUM) (match_dup 4)))\n+   (set (reg:HI X_REGNUM) (plus:HI (plus:HI (reg:HI X_REGNUM)\n+\t\t\t\t\t    (const_int 0))\n+\t\t\t\t   (reg:HI CC_REGNUM)))]\n+  \"operands[3] = m68hc11_gen_highpart (HImode, operands[2]);\n+   operands[4] = m68hc11_gen_lowpart (HImode, operands[2]);\")\n+\n (define_insn \"addsi_ashift16\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=D\")\n           (plus:SI "}]}