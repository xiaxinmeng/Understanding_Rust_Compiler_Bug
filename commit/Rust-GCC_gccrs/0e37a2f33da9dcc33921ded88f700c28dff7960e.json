{"sha": "0e37a2f33da9dcc33921ded88f700c28dff7960e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUzN2EyZjMzZGE5ZGNjMzM5MjFkZWQ4OGY3MDBjMjhkZmY3OTYwZQ==", "commit": {"author": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2014-06-20T21:20:51Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2014-06-20T21:20:51Z"}, "message": "asan.c (pass_sanopt::execute): Handle IFN_UBSAN_BOUNDS.\n\n\t* asan.c (pass_sanopt::execute): Handle IFN_UBSAN_BOUNDS.\n\t* flag-types.h (enum sanitize_code): Add SANITIZE_BOUNDS and or it\n\tinto SANITIZE_UNDEFINED.\n\t* doc/invoke.texi: Describe -fsanitize=bounds.\n\t* gimplify.c (gimplify_call_expr): Add gimplification of internal\n\tfunctions created in the FEs.\n\t* internal-fn.c: Move \"internal-fn.h\" after \"tree.h\".\n\t(expand_UBSAN_BOUNDS): New function.\n\t* internal-fn.def (UBSAN_BOUNDS): New internal function.\n\t* internal-fn.h: Don't define internal functions here.\n\t* opts.c (common_handle_option): Add -fsanitize=bounds.\n\t* sanitizer.def (BUILT_IN_UBSAN_HANDLE_OUT_OF_BOUNDS,\n\tBUILT_IN_UBSAN_HANDLE_OUT_OF_BOUNDS_ABORT): Add.\n\t* tree-core.h: Define internal functions here.\n\t(struct tree_base): Add ifn field.\n\t* tree-pretty-print.c: Include \"internal-fn.h\".\n\t(dump_generic_node): Handle functions without CALL_EXPR_FN.\n\t* tree.c (get_callee_fndecl): Likewise.\n\t(build_call_expr_internal_loc): New function.\n\t* tree.def (CALL_EXPR): Update description.\n\t* tree.h (CALL_EXPR_IFN): Define.\n\t(build_call_expr_internal_loc): Declare.\n\t* ubsan.c (get_ubsan_type_info_for_type): Return 0 for non-arithmetic\n\ttypes.\n\t(ubsan_type_descriptor): Change bool parameter to enum\n\tubsan_print_style.  Adjust the code.  Add handling of\n\tUBSAN_PRINT_ARRAY.\n\t(ubsan_expand_bounds_ifn): New function.\n\t(ubsan_expand_null_ifn): Adjust ubsan_type_descriptor call.\n\t(ubsan_build_overflow_builtin): Likewise.\n\t(instrument_bool_enum_load): Likewise.\n\t(ubsan_instrument_float_cast): Likewise.\n\t* ubsan.h (enum ubsan_print_style): New enum.\n\t(ubsan_expand_bounds_ifn): Declare.\n\t(ubsan_type_descriptor): Adjust declaration.  Use a default parameter.\nc-family/\n\t* c-gimplify.c: Include \"c-ubsan.h\" and \"pointer-set.h\".\n\t(ubsan_walk_array_refs_r): New function.\n\t(c_genericize): Instrument array bounds.\n\t* c-ubsan.c: Include \"internal-fn.h\".\n\t(ubsan_instrument_division): Mark instrumented arrays as having\n\tside effects.  Adjust ubsan_type_descriptor call.\n\t(ubsan_instrument_shift): Likewise.\n\t(ubsan_instrument_vla): Adjust ubsan_type_descriptor call.\n\t(ubsan_instrument_bounds): New function.\n\t(ubsan_array_ref_instrumented_p): New function.\n\t(ubsan_maybe_instrument_array_ref): New function.\n\t* c-ubsan.h (ubsan_instrument_bounds): Declare.\n\t(ubsan_array_ref_instrumented_p): Declare.\n\t(ubsan_maybe_instrument_array_ref): Declare.\ntestsuite/\n\t* c-c++-common/ubsan/bounds-1.c: New test.\n\t* c-c++-common/ubsan/bounds-2.c: New test.\n\t* c-c++-common/ubsan/bounds-3.c: New test.\n\t* c-c++-common/ubsan/bounds-4.c: New test.\n\t* c-c++-common/ubsan/bounds-5.c: New test.\n\t* c-c++-common/ubsan/bounds-6.c: New test.\n\nFrom-SVN: r211859", "tree": {"sha": "909724d7e8bcbb98c38c8f42a5f641e17c4ac7ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/909724d7e8bcbb98c38c8f42a5f641e17c4ac7ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e37a2f33da9dcc33921ded88f700c28dff7960e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e37a2f33da9dcc33921ded88f700c28dff7960e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e37a2f33da9dcc33921ded88f700c28dff7960e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e37a2f33da9dcc33921ded88f700c28dff7960e/comments", "author": null, "committer": null, "parents": [{"sha": "87681fb55051518fb40426e61ee4fbc2a47073c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87681fb55051518fb40426e61ee4fbc2a47073c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87681fb55051518fb40426e61ee4fbc2a47073c3"}], "stats": {"total": 925, "additions": 877, "deletions": 48}, "files": [{"sha": "43b9939c010bf691b477184e3da7f10565b620df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -1,3 +1,41 @@\n+2014-06-20  Marek Polacek  <polacek@redhat.com>\n+\n+\t* asan.c (pass_sanopt::execute): Handle IFN_UBSAN_BOUNDS.\n+\t* flag-types.h (enum sanitize_code): Add SANITIZE_BOUNDS and or it\n+\tinto SANITIZE_UNDEFINED.\n+\t* doc/invoke.texi: Describe -fsanitize=bounds.\n+\t* gimplify.c (gimplify_call_expr): Add gimplification of internal\n+\tfunctions created in the FEs.\n+\t* internal-fn.c: Move \"internal-fn.h\" after \"tree.h\".\n+\t(expand_UBSAN_BOUNDS): New function.\n+\t* internal-fn.def (UBSAN_BOUNDS): New internal function.\n+\t* internal-fn.h: Don't define internal functions here.\n+\t* opts.c (common_handle_option): Add -fsanitize=bounds.\n+\t* sanitizer.def (BUILT_IN_UBSAN_HANDLE_OUT_OF_BOUNDS,\n+\tBUILT_IN_UBSAN_HANDLE_OUT_OF_BOUNDS_ABORT): Add.\n+\t* tree-core.h: Define internal functions here.\n+\t(struct tree_base): Add ifn field.\n+\t* tree-pretty-print.c: Include \"internal-fn.h\".\n+\t(dump_generic_node): Handle functions without CALL_EXPR_FN.\n+\t* tree.c (get_callee_fndecl): Likewise.\n+\t(build_call_expr_internal_loc): New function.\n+\t* tree.def (CALL_EXPR): Update description.\n+\t* tree.h (CALL_EXPR_IFN): Define.\n+\t(build_call_expr_internal_loc): Declare.\n+\t* ubsan.c (get_ubsan_type_info_for_type): Return 0 for non-arithmetic\n+\ttypes.\n+\t(ubsan_type_descriptor): Change bool parameter to enum\n+\tubsan_print_style.  Adjust the code.  Add handling of\n+\tUBSAN_PRINT_ARRAY.\n+\t(ubsan_expand_bounds_ifn): New function.\n+\t(ubsan_expand_null_ifn): Adjust ubsan_type_descriptor call.\n+\t(ubsan_build_overflow_builtin): Likewise.\n+\t(instrument_bool_enum_load): Likewise.\n+\t(ubsan_instrument_float_cast): Likewise.\n+\t* ubsan.h (enum ubsan_print_style): New enum.\n+\t(ubsan_expand_bounds_ifn): Declare.\n+\t(ubsan_type_descriptor): Adjust declaration.  Use a default parameter.\n+\n 2014-06-20  Maciej W. Rozycki  <macro@codesourcery.com>\n \n \t* config/rs6000/rs6000.md: Append `DONE' to preparation"}, {"sha": "eee1a71e8dad21e4ee7f38bf18bbcc390e869190", "filename": "gcc/asan.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -2762,6 +2762,9 @@ pass_sanopt::execute (function *fun)\n \t      case IFN_UBSAN_NULL:\n \t\tubsan_expand_null_ifn (gsi);\n \t\tbreak;\n+\t      case IFN_UBSAN_BOUNDS:\n+\t\tubsan_expand_bounds_ifn (&gsi);\n+\t\tbreak;\n \t      default:\n \t\tbreak;\n \t      }\n@@ -2772,6 +2775,10 @@ pass_sanopt::execute (function *fun)\n \t      print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n+\n+\t  /* ubsan_expand_bounds_ifn might move us to the end of the BB.  */\n+\t  if (gsi_end_p (gsi))\n+\t    break;\n \t}\n     }\n   return 0;"}, {"sha": "e37aa46d856b23382b0fa0f2c15b0dbd2c8b2e98", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -1,4 +1,21 @@\n-2014-06-20 Hale Wang <hale.wang@arm.com>\n+2014-06-20  Marek Polacek  <polacek@redhat.com>\n+\n+\t* c-gimplify.c: Include \"c-ubsan.h\" and \"pointer-set.h\".\n+\t(ubsan_walk_array_refs_r): New function.\n+\t(c_genericize): Instrument array bounds.\n+\t* c-ubsan.c: Include \"internal-fn.h\".\n+\t(ubsan_instrument_division): Mark instrumented arrays as having\n+\tside effects.  Adjust ubsan_type_descriptor call.\n+\t(ubsan_instrument_shift): Likewise.\n+\t(ubsan_instrument_vla): Adjust ubsan_type_descriptor call.\n+\t(ubsan_instrument_bounds): New function.\n+\t(ubsan_array_ref_instrumented_p): New function.\n+\t(ubsan_maybe_instrument_array_ref): New function.\n+\t* c-ubsan.h (ubsan_instrument_bounds): Declare.\n+\t(ubsan_array_ref_instrumented_p): Declare.\n+\t(ubsan_maybe_instrument_array_ref): Declare.\n+\n+2014-06-20  Hale Wang  <hale.wang@arm.com>\n \n \tPR lto/61123\n \t* c.opt (fshort-enums): Add to LTO."}, {"sha": "c797d994516b9724e12d9193de93d5ddcb1d427f", "filename": "gcc/c-family/c-gimplify.c", "status": "modified", "additions": 48, "deletions": 5, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fc-family%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fc-family%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-gimplify.c?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -45,6 +45,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-pretty-print.h\"\n #include \"cgraph.h\"\n #include \"cilk.h\"\n+#include \"c-ubsan.h\"\n+#include \"pointer-set.h\"\n \n /*  The gimplification pass converts the language-dependent trees\n     (ld-trees) emitted by the parser into language-independent trees\n@@ -67,6 +69,39 @@ along with GCC; see the file COPYING3.  If not see\n     walk back up, we check that they fit our constraints, and copy them\n     into temporaries if not.  */\n \n+/* Callback for c_genericize.  */\n+\n+static tree\n+ubsan_walk_array_refs_r (tree *tp, int *walk_subtrees, void *data)\n+{\n+  struct pointer_set_t *pset = (struct pointer_set_t *) data;\n+\n+  /* Since walk_tree doesn't call the callback function on the decls\n+     in BIND_EXPR_VARS, we have to walk them manually.  */\n+  if (TREE_CODE (*tp) == BIND_EXPR)\n+    {\n+      for (tree decl = BIND_EXPR_VARS (*tp); decl; decl = DECL_CHAIN (decl))\n+\t{\n+\t  if (TREE_STATIC (decl))\n+\t    {\n+\t      *walk_subtrees = 0;\n+\t      continue;\n+\t    }\n+\t  walk_tree (&DECL_INITIAL (decl), ubsan_walk_array_refs_r, pset,\n+\t\t     pset);\n+\t  walk_tree (&DECL_SIZE (decl), ubsan_walk_array_refs_r, pset, pset);\n+\t  walk_tree (&DECL_SIZE_UNIT (decl), ubsan_walk_array_refs_r, pset,\n+\t\t     pset);\n+\t}\n+    }\n+  else if (TREE_CODE (*tp) == ADDR_EXPR\n+\t   && TREE_CODE (TREE_OPERAND (*tp, 0)) == ARRAY_REF)\n+    ubsan_maybe_instrument_array_ref (&TREE_OPERAND (*tp, 0), true);\n+  else if (TREE_CODE (*tp) == ARRAY_REF)\n+    ubsan_maybe_instrument_array_ref (tp, false);\n+  return NULL_TREE;\n+}\n+\n /* Gimplification of statement trees.  */\n \n /* Convert the tree representation of FNDECL from C frontend trees to\n@@ -79,6 +114,14 @@ c_genericize (tree fndecl)\n   int local_dump_flags;\n   struct cgraph_node *cgn;\n \n+  if (flag_sanitize & SANITIZE_BOUNDS)\n+    {\n+      struct pointer_set_t *pset = pointer_set_create ();\n+      walk_tree (&DECL_SAVED_TREE (fndecl), ubsan_walk_array_refs_r, pset,\n+\t\t pset);\n+      pointer_set_destroy (pset);\n+    }\n+\n   /* Dump the C-specific tree IR.  */\n   dump_orig = dump_begin (TDI_original, &local_dump_flags);\n   if (dump_orig)\n@@ -207,16 +250,16 @@ c_gimplify_expr (tree *expr_p, gimple_seq *pre_p ATTRIBUTE_UNUSED,\n \t  }\n \tbreak;\n       }\n-      \n+\n     case CILK_SPAWN_STMT:\n-      gcc_assert \n-\t(fn_contains_cilk_spawn_p (cfun) \n+      gcc_assert\n+\t(fn_contains_cilk_spawn_p (cfun)\n \t && cilk_detect_spawn_and_unwrap (expr_p));\n-      \n+\n       /* If errors are seen, then just process it as a CALL_EXPR.  */\n       if (!seen_error ())\n \treturn (enum gimplify_status) gimplify_cilk_spawn (expr_p);\n-      \n+\n     case MODIFY_EXPR:\n     case INIT_EXPR:\n     case CALL_EXPR:"}, {"sha": "36985806b4e1aa773cfc36e092a215817a7417dd", "filename": "gcc/c-family/c-ubsan.c", "status": "modified", "additions": 132, "deletions": 10, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fc-family%2Fc-ubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fc-family%2Fc-ubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ubsan.c?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-family/c-common.h\"\n #include \"c-family/c-ubsan.h\"\n #include \"asan.h\"\n+#include \"internal-fn.h\"\n \n /* Instrument division by zero and INT_MIN / -1.  If not instrumenting,\n    return NULL_TREE.  */\n@@ -77,15 +78,27 @@ ubsan_instrument_division (location_t loc, tree op0, tree op1)\n     return NULL_TREE;\n \n   /* In case we have a SAVE_EXPR in a conditional context, we need to\n-     make sure it gets evaluated before the condition.  */\n+     make sure it gets evaluated before the condition.  If the OP0 is\n+     an instrumented array reference, mark it as having side effects so\n+     it's not folded away.  */\n+  if (flag_sanitize & SANITIZE_BOUNDS)\n+    {\n+      tree xop0 = op0;\n+      while (CONVERT_EXPR_P (xop0))\n+\txop0 = TREE_OPERAND (xop0, 0);\n+      if (TREE_CODE (xop0) == ARRAY_REF)\n+\t{\n+\t  TREE_SIDE_EFFECTS (xop0) = 1;\n+\t  TREE_SIDE_EFFECTS (op0) = 1;\n+\t}\n+    }\n   t = fold_build2 (COMPOUND_EXPR, TREE_TYPE (t), op0, t);\n   if (flag_sanitize_undefined_trap_on_error)\n     tt = build_call_expr_loc (loc, builtin_decl_explicit (BUILT_IN_TRAP), 0);\n   else\n     {\n       tree data = ubsan_create_data (\"__ubsan_overflow_data\", &loc, NULL,\n-\t\t\t\t     ubsan_type_descriptor (type, false),\n-\t\t\t\t     NULL_TREE);\n+\t\t\t\t     ubsan_type_descriptor (type), NULL_TREE);\n       data = build_fold_addr_expr_loc (loc, data);\n       enum built_in_function bcode\n \t= flag_sanitize_recover\n@@ -154,7 +167,20 @@ ubsan_instrument_shift (location_t loc, enum tree_code code,\n     return NULL_TREE;\n \n   /* In case we have a SAVE_EXPR in a conditional context, we need to\n-     make sure it gets evaluated before the condition.  */\n+     make sure it gets evaluated before the condition.  If the OP0 is\n+     an instrumented array reference, mark it as having side effects so\n+     it's not folded away.  */\n+  if (flag_sanitize & SANITIZE_BOUNDS)\n+    {\n+      tree xop0 = op0;\n+      while (CONVERT_EXPR_P (xop0))\n+\txop0 = TREE_OPERAND (xop0, 0);\n+      if (TREE_CODE (xop0) == ARRAY_REF)\n+\t{\n+\t  TREE_SIDE_EFFECTS (xop0) = 1;\n+\t  TREE_SIDE_EFFECTS (op0) = 1;\n+\t}\n+    }\n   t = fold_build2 (COMPOUND_EXPR, TREE_TYPE (t), op0, t);\n   t = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, t,\n \t\t   tt ? tt : integer_zero_node);\n@@ -164,10 +190,8 @@ ubsan_instrument_shift (location_t loc, enum tree_code code,\n   else\n     {\n       tree data = ubsan_create_data (\"__ubsan_shift_data\", &loc, NULL,\n-\t\t\t\t     ubsan_type_descriptor (type0, false),\n-\t\t\t\t     ubsan_type_descriptor (type1, false),\n-\t\t\t\t     NULL_TREE);\n-\n+\t\t\t\t     ubsan_type_descriptor (type0),\n+\t\t\t\t     ubsan_type_descriptor (type1), NULL_TREE);\n       data = build_fold_addr_expr_loc (loc, data);\n \n       enum built_in_function bcode\n@@ -197,8 +221,7 @@ ubsan_instrument_vla (location_t loc, tree size)\n   else\n     {\n       tree data = ubsan_create_data (\"__ubsan_vla_data\", &loc, NULL,\n-\t\t\t\t     ubsan_type_descriptor (type, false),\n-\t\t\t\t     NULL_TREE);\n+\t\t\t\t     ubsan_type_descriptor (type), NULL_TREE);\n       data = build_fold_addr_expr_loc (loc, data);\n       enum built_in_function bcode\n \t= flag_sanitize_recover\n@@ -228,3 +251,102 @@ ubsan_instrument_return (location_t loc)\n   tree t = builtin_decl_explicit (BUILT_IN_UBSAN_HANDLE_MISSING_RETURN);\n   return build_call_expr_loc (loc, t, 1, build_fold_addr_expr_loc (loc, data));\n }\n+\n+/* Instrument array bounds for ARRAY_REFs.  We create special builtin,\n+   that gets expanded in the sanopt pass, and make an array dimension\n+   of it.  ARRAY is the array, *INDEX is an index to the array.\n+   Return NULL_TREE if no instrumentation is emitted.\n+   IGNORE_OFF_BY_ONE is true if the ARRAY_REF is inside a ADDR_EXPR.  */\n+\n+tree\n+ubsan_instrument_bounds (location_t loc, tree array, tree *index,\n+\t\t\t bool ignore_off_by_one)\n+{\n+  tree type = TREE_TYPE (array);\n+  tree domain = TYPE_DOMAIN (type);\n+\n+  if (domain == NULL_TREE)\n+    return NULL_TREE;\n+\n+  tree bound = TYPE_MAX_VALUE (domain);\n+  if (ignore_off_by_one)\n+    bound = fold_build2 (PLUS_EXPR, TREE_TYPE (bound), bound,\n+\t\t\t build_int_cst (TREE_TYPE (bound), 1));\n+\n+  /* Detect flexible array members and suchlike.  */\n+  tree base = get_base_address (array);\n+  if (base && (TREE_CODE (base) == INDIRECT_REF\n+\t       || TREE_CODE (base) == MEM_REF))\n+    {\n+      tree next = NULL_TREE;\n+      tree cref = array;\n+\n+      /* Walk all structs/unions.  */\n+      while (TREE_CODE (cref) == COMPONENT_REF)\n+\t{\n+\t  if (TREE_CODE (TREE_TYPE (TREE_OPERAND (cref, 0))) == RECORD_TYPE)\n+\t    for (next = DECL_CHAIN (TREE_OPERAND (cref, 1));\n+\t\t next && TREE_CODE (next) != FIELD_DECL;\n+\t\t next = DECL_CHAIN (next))\n+\t      ;\n+\t  if (next)\n+\t    /* Not a last element.  Instrument it.  */\n+\t    break;\n+\t  /* Ok, this is the last field of the structure/union.  But the\n+\t     aggregate containing the field must be the last field too,\n+\t     recursively.  */\n+\t  cref = TREE_OPERAND (cref, 0);\n+\t}\n+      if (!next)\n+\t/* Don't instrument this flexible array member-like array in non-strict\n+\t   -fsanitize=bounds mode.  */\n+        return NULL_TREE;\n+    }\n+\n+  *index = save_expr (*index);\n+  /* Create a \"(T *) 0\" tree node to describe the array type.  */\n+  tree zero_with_type = build_int_cst (build_pointer_type (type), 0);\n+  return build_call_expr_internal_loc (loc, IFN_UBSAN_BOUNDS,\n+\t\t\t\t       void_type_node, 3, zero_with_type,\n+\t\t\t\t       *index, bound);\n+}\n+\n+/* Return true iff T is an array that was instrumented by SANITIZE_BOUNDS.  */\n+\n+bool\n+ubsan_array_ref_instrumented_p (const_tree t)\n+{\n+  if (TREE_CODE (t) != ARRAY_REF)\n+    return false;\n+\n+  tree op1 = TREE_OPERAND (t, 1);\n+  return TREE_CODE (op1) == COMPOUND_EXPR\n+\t && TREE_CODE (TREE_OPERAND (op1, 0)) == CALL_EXPR\n+\t && CALL_EXPR_FN (TREE_OPERAND (op1, 0)) == NULL_TREE\n+\t && CALL_EXPR_IFN (TREE_OPERAND (op1, 0)) == IFN_UBSAN_BOUNDS;\n+}\n+\n+/* Instrument an ARRAY_REF, if it hasn't already been instrumented.\n+   IGNORE_OFF_BY_ONE is true if the ARRAY_REF is inside a ADDR_EXPR.  */\n+\n+void\n+ubsan_maybe_instrument_array_ref (tree *expr_p, bool ignore_off_by_one)\n+{\n+  if (!ubsan_array_ref_instrumented_p (*expr_p)\n+      && current_function_decl != NULL_TREE\n+      && !lookup_attribute (\"no_sanitize_undefined\",\n+\t\t\t    DECL_ATTRIBUTES (current_function_decl)))\n+    {\n+      tree op0 = TREE_OPERAND (*expr_p, 0);\n+      tree op1 = TREE_OPERAND (*expr_p, 1);\n+      tree e = ubsan_instrument_bounds (EXPR_LOCATION (*expr_p), op0, &op1,\n+\t\t\t\t\tignore_off_by_one);\n+      if (e != NULL_TREE)\n+\t{\n+\t  tree t = copy_node (*expr_p);\n+\t  TREE_OPERAND (t, 1) = build2 (COMPOUND_EXPR, TREE_TYPE (op1),\n+\t\t\t\t\te, op1);\n+\t  *expr_p = t;\n+\t}\n+    }\n+}"}, {"sha": "edf5bc60be64863caa9a32743c4ff08f7564e81d", "filename": "gcc/c-family/c-ubsan.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fc-family%2Fc-ubsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fc-family%2Fc-ubsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ubsan.h?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -25,5 +25,8 @@ extern tree ubsan_instrument_division (location_t, tree, tree);\n extern tree ubsan_instrument_shift (location_t, enum tree_code, tree, tree);\n extern tree ubsan_instrument_vla (location_t, tree);\n extern tree ubsan_instrument_return (location_t);\n+extern tree ubsan_instrument_bounds (location_t, tree, tree *, bool);\n+extern bool ubsan_array_ref_instrumented_p (const_tree);\n+extern void ubsan_maybe_instrument_array_ref (tree *, bool);\n \n #endif  /* GCC_C_UBSAN_H  */"}, {"sha": "0d4bd00c0e09a837454b3f2deeba6d0ff61d9284", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -5448,6 +5448,13 @@ This option enables floating-point type to integer conversion checking.\n We check that the result of the conversion does not overflow.\n This option does not work well with @code{FE_INVALID} exceptions enabled.\n \n+@item -fsanitize=bounds\n+@opindex fsanitize=bounds\n+\n+This option enables instrumentation of array bounds.  Various out of bounds\n+accesses are detected.  Flexible array members are not instrumented, as well\n+as initializers of variables with static storage.\n+\n @item -fsanitize-recover\n @opindex fsanitize-recover\n By default @option{-fsanitize=undefined} sanitization (and its suboptions"}, {"sha": "4b8e33889a75c53f13c9e3fcb8d13743a0b20e7e", "filename": "gcc/flag-types.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -230,9 +230,11 @@ enum sanitize_code {\n   SANITIZE_ENUM = 1 << 11,\n   SANITIZE_FLOAT_DIVIDE = 1 << 12,\n   SANITIZE_FLOAT_CAST = 1 << 13,\n+  SANITIZE_BOUNDS = 1 << 14,\n   SANITIZE_UNDEFINED = SANITIZE_SHIFT | SANITIZE_DIVIDE | SANITIZE_UNREACHABLE\n \t\t       | SANITIZE_VLA | SANITIZE_NULL | SANITIZE_RETURN\n-\t\t       | SANITIZE_SI_OVERFLOW | SANITIZE_BOOL | SANITIZE_ENUM,\n+\t\t       | SANITIZE_SI_OVERFLOW | SANITIZE_BOOL | SANITIZE_ENUM\n+\t\t       | SANITIZE_BOUNDS,\n   SANITIZE_NONDEFAULT = SANITIZE_FLOAT_DIVIDE | SANITIZE_FLOAT_CAST\n };\n "}, {"sha": "338c5c0ffe6ac55cdcd2967f01be33576d503416", "filename": "gcc/gimplify.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -2264,6 +2264,24 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n   if (! EXPR_HAS_LOCATION (*expr_p))\n     SET_EXPR_LOCATION (*expr_p, input_location);\n \n+  /* Gimplify internal functions created in the FEs.  */\n+  if (CALL_EXPR_FN (*expr_p) == NULL_TREE)\n+    {\n+      nargs = call_expr_nargs (*expr_p);\n+      enum internal_fn ifn = CALL_EXPR_IFN (*expr_p);\n+      auto_vec<tree> vargs (nargs);\n+\n+      for (i = 0; i < nargs; i++)\n+\t{\n+\t  gimplify_arg (&CALL_EXPR_ARG (*expr_p, i), pre_p,\n+\t\t\tEXPR_LOCATION (*expr_p));\n+\t  vargs.quick_push (CALL_EXPR_ARG (*expr_p, i));\n+\t}\n+      gimple call = gimple_build_call_internal_vec (ifn, vargs);\n+      gimplify_seq_add_stmt (pre_p, call);\n+      return GS_ALL_DONE;\n+    }\n+\n   /* This may be a call to a builtin function.\n \n      Builtin function calls may be transformed into different"}, {"sha": "78f59d6a7b737cf9fa18e5ed3776214410be61a3", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -20,8 +20,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n-#include \"internal-fn.h\"\n #include \"tree.h\"\n+#include \"internal-fn.h\"\n #include \"stor-layout.h\"\n #include \"expr.h\"\n #include \"optabs.h\"\n@@ -159,6 +159,14 @@ expand_UBSAN_NULL (gimple stmt ATTRIBUTE_UNUSED)\n   gcc_unreachable ();\n }\n \n+/* This should get expanded in the sanopt pass.  */\n+\n+static void\n+expand_UBSAN_BOUNDS (gimple stmt ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\n /* Add sub/add overflow checking to the statement STMT.\n    CODE says whether the operation is +, or -.  */\n "}, {"sha": "f0766bc4b45c2d24135170ab9e473c8f4a829af2", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -48,6 +48,7 @@ DEF_INTERNAL_FN (MASK_LOAD, ECF_PURE | ECF_LEAF)\n DEF_INTERNAL_FN (MASK_STORE, ECF_LEAF)\n DEF_INTERNAL_FN (ANNOTATE,  ECF_CONST | ECF_LEAF | ECF_NOTHROW)\n DEF_INTERNAL_FN (UBSAN_NULL, ECF_LEAF | ECF_NOTHROW)\n+DEF_INTERNAL_FN (UBSAN_BOUNDS, ECF_LEAF | ECF_NOTHROW)\n DEF_INTERNAL_FN (UBSAN_CHECK_ADD, ECF_CONST | ECF_LEAF | ECF_NOTHROW)\n DEF_INTERNAL_FN (UBSAN_CHECK_SUB, ECF_CONST | ECF_LEAF | ECF_NOTHROW)\n DEF_INTERNAL_FN (UBSAN_CHECK_MUL, ECF_CONST | ECF_LEAF | ECF_NOTHROW)"}, {"sha": "2dcf44e6ebdd3f4025daf3634b12252e5348a1c1", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -20,13 +20,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_INTERNAL_FN_H\n #define GCC_INTERNAL_FN_H\n \n-enum internal_fn {\n-#define DEF_INTERNAL_FN(CODE, FLAGS) IFN_##CODE,\n-#include \"internal-fn.def\"\n-#undef DEF_INTERNAL_FN\n-  IFN_LAST\n-};\n-\n /* Return the name of internal function FN.  The name is only meaningful\n    for dumps; it has no linkage.  */\n "}, {"sha": "3ab06c67c398b8f7b465b3a6faac6faaf238c84e", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -1467,6 +1467,7 @@ common_handle_option (struct gcc_options *opts,\n \t\tsizeof \"float-divide-by-zero\" - 1 },\n \t      { \"float-cast-overflow\", SANITIZE_FLOAT_CAST,\n \t\tsizeof \"float-cast-overflow\" - 1 },\n+\t      { \"bounds\", SANITIZE_BOUNDS, sizeof \"bounds\" - 1 },\n \t      { NULL, 0, 0 }\n \t    };\n \t    const char *comma;"}, {"sha": "1f5ef210ab44bba132115a6d56b7d28e08a69194", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -409,3 +409,11 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_FLOAT_CAST_OVERFLOW_ABORT,\n \t\t      \"__ubsan_handle_float_cast_overflow_abort\",\n \t\t      BT_FN_VOID_PTR_PTR,\n \t\t      ATTR_COLD_NORETURN_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_OUT_OF_BOUNDS,\n+\t\t      \"__ubsan_handle_out_of_bounds\",\n+\t\t      BT_FN_VOID_PTR_PTR,\n+\t\t      ATTR_COLD_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_OUT_OF_BOUNDS_ABORT,\n+\t\t      \"__ubsan_handle_out_of_bounds_abort\",\n+\t\t      BT_FN_VOID_PTR_PTR,\n+\t\t      ATTR_COLD_NORETURN_NOTHROW_LEAF_LIST)"}, {"sha": "dcab923fb32477576cffd33c2443ca215a3812b3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -1,3 +1,12 @@\n+2014-06-20  Marek Polacek  <polacek@redhat.com>\n+\n+\t* c-c++-common/ubsan/bounds-1.c: New test.\n+\t* c-c++-common/ubsan/bounds-2.c: New test.\n+\t* c-c++-common/ubsan/bounds-3.c: New test.\n+\t* c-c++-common/ubsan/bounds-4.c: New test.\n+\t* c-c++-common/ubsan/bounds-5.c: New test.\n+\t* c-c++-common/ubsan/bounds-6.c: New test.\n+\n 2014-06-20  Yufeng Zhang  <yufeng.zhang@arm.com>\n \n \tMake the tests big-endian friendly."}, {"sha": "aa192d3787bda10442e6a96ee2a7d12aec12c965", "filename": "gcc/testsuite/c-c++-common/ubsan/bounds-1.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fbounds-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fbounds-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fbounds-1.c?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -0,0 +1,75 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=bounds -fno-sanitize-recover -Wall\" } */\n+\n+/* Don't fail on valid uses.  */\n+\n+struct S { int a[10]; };\n+struct T { int l; int a[]; };\n+struct U { int l; int a[0]; };\n+\n+__attribute__ ((noinline, noclone))\n+void\n+fn_p (int p)\n+{\n+}\n+\n+__attribute__ ((noinline, noclone))\n+void\n+fn_a (volatile int a[])\n+{\n+  /* This is not instrumented.  */\n+  a[4] = 5;\n+}\n+\n+__attribute__ ((noinline, noclone))\n+int\n+foo_i (int i)\n+{\n+  int a[5] = { };\n+  int k = i ? a[i] : i;\n+  return k;\n+}\n+\n+int\n+main (void)\n+{\n+  volatile int a[5];\n+  a[4] = 1;\n+  a[2] = a[3];\n+  fn_p (a[4]);\n+  fn_a (a);\n+\n+  int i = 4;\n+  a[i] = 1;\n+  a[2] = a[i];\n+  fn_p (a[i]);\n+  foo_i (i);\n+\n+  const int n = 5;\n+  volatile int b[n];\n+  b[4] = 1;\n+  b[2] = b[3];\n+  fn_p (b[4]);\n+  fn_a (b);\n+\n+  volatile int c[n][n][n];\n+  c[2][2][2] = 2;\n+  i = c[4][4][4];\n+\n+  volatile struct S s;\n+  s.a[9] = 1;\n+  i = s.a[9];\n+\n+  /* Don't instrument flexible array members.  */\n+  struct T *t = (struct T *) __builtin_malloc (sizeof (struct T) + 10);\n+  t->a[1] = 1;\n+\n+  struct U *u = (struct U *) __builtin_malloc (sizeof (struct U) + 10);\n+  u->a[1] = 1;\n+\n+  long int *d[10][5];\n+  d[9][0] = (long int *) 0;\n+  d[8][3] = d[9][0];\n+\n+  return 0;\n+}"}, {"sha": "95f77c28f3fc22ecbeab296c56330f9cfc9ca17b", "filename": "gcc/testsuite/c-c++-common/ubsan/bounds-2.c", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fbounds-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fbounds-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fbounds-2.c?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -0,0 +1,168 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=bounds -Wall -Wextra -Wno-unused -Wno-array-bounds\" } */\n+\n+/* Test runtime errors.  */\n+\n+struct S { int a[10]; };\n+\n+int\n+foo_5 (void)\n+{\n+  return 5;\n+}\n+\n+__attribute__ ((noinline, noclone))\n+void\n+fn_p (int p)\n+{\n+  (void) p;\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+fn1 (void)\n+{\n+  volatile int a[5];\n+  a[5] = 1;\n+  a[2] = a[5];\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+fn2 (void)\n+{\n+  volatile int a[5];\n+  int i = 5;\n+  int *p = &i;\n+  a[*p] = 1;\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+fn3 (void)\n+{\n+  volatile int a[5];\n+  fn_p (a[5]);\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+fn4 (void)\n+{\n+  volatile int a[5];\n+  a[foo_5 ()] = 1;\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+fn5 (void)\n+{\n+  int i = 5;\n+  volatile int a[i];\n+  a[i] = 1;\n+  a[2] = a[i];\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+fn6 (void)\n+{\n+  int i = 5;\n+  volatile int a[i];\n+  fn_p (a[i]);\n+  a[foo_5 ()] = 1;\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+fn7 (void)\n+{\n+  int n = 5, i;\n+  volatile int c[n][n][n];\n+  c[5][2][2] = 2;\n+  c[2][5][2] = 2;\n+  c[2][2][5] = 2;\n+  i = c[5][2][2];\n+  i = c[2][5][2];\n+  i = c[2][2][5];\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+fn8 (void)\n+{\n+  int i = 5;\n+  volatile struct S s;\n+  s.a[10] = 1;\n+  i = s.a[10];\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+fn9 (void)\n+{\n+  long int *volatile d[10][5];\n+  d[10][0] = 0;\n+  d[8][3] = d[10][0];\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+fn10 (void)\n+{\n+  /* Beware of side-effects.  */\n+  volatile int x = 10;\n+  volatile int e[20];\n+  e[x++] = 3;\n+  if (x != 11)\n+    __builtin_abort ();\n+  e[x--] = 3;\n+  if (x != 10)\n+    __builtin_abort ();\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+fn11 (void)\n+{\n+  char ***volatile f[5];\n+  f[5] = 0;\n+  f[2] = f[5];\n+}\n+\n+static void __attribute__ ((noinline, noclone))\n+fn12 (int i)\n+{\n+  volatile int a[5] = { };\n+  int k = i ? a[i] : i;\n+}\n+\n+int\n+main (void)\n+{\n+  fn1 ();\n+  fn2 ();\n+  fn3 ();\n+  fn4 ();\n+  fn5 ();\n+  fn6 ();\n+  fn7 ();\n+  fn8 ();\n+  fn9 ();\n+  fn10 ();\n+  fn11 ();\n+  fn12 (5);\n+  return 0;\n+}\n+\n+/* { dg-output \"index 5 out of bounds for type 'int \\\\\\[5\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 5 out of bounds for type 'int \\\\\\[5\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 5 out of bounds for type 'int \\\\\\[5\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 5 out of bounds for type 'int \\\\\\[5\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 5 out of bounds for type 'int \\\\\\[5\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 5 out of bounds for type 'int \\\\\\[\\\\\\*\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 5 out of bounds for type 'int \\\\\\[\\\\\\*\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 5 out of bounds for type 'int \\\\\\[\\\\\\*\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 5 out of bounds for type 'int \\\\\\[\\\\\\*\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 5 out of bounds for type 'int \\\\\\[\\\\\\*\\\\\\]\\\\\\[\\\\\\*\\\\\\]\\\\\\[\\\\\\*\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 5 out of bounds for type 'int \\\\\\[\\\\\\*\\\\\\]\\\\\\[\\\\\\*\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 5 out of bounds for type 'int \\\\\\[\\\\\\*\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 5 out of bounds for type 'int \\\\\\[\\\\\\*\\\\\\]\\\\\\[\\\\\\*\\\\\\]\\\\\\[\\\\\\*\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 5 out of bounds for type 'int \\\\\\[\\\\\\*\\\\\\]\\\\\\[\\\\\\*\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 5 out of bounds for type 'int \\\\\\[\\\\\\*\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 10 out of bounds for type 'int \\\\\\[10\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 10 out of bounds for type 'int \\\\\\[10\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 10 out of bounds for type 'long int \\\\\\*\\\\\\[10\\\\\\]\\\\\\[5\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 10 out of bounds for type 'long int \\\\\\*\\\\\\[10\\\\\\]\\\\\\[5\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 5 out of bounds for type 'char \\\\\\*\\\\\\*\\\\\\*\\\\\\[5\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 5 out of bounds for type 'char \\\\\\*\\\\\\*\\\\\\*\\\\\\[5\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 5 out of bounds for type 'int \\\\\\[5\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "fcf71a3bf8a0965b437f5f2d3cf01db7952d7ff5", "filename": "gcc/testsuite/c-c++-common/ubsan/bounds-3.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fbounds-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fbounds-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fbounds-3.c?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fsanitize=bounds -Wall -Wextra\" } */\n+\n+/* Do not generate invalid diagnostics.  */\n+\n+extern const int a[10];\n+extern int bar (int);\n+void\n+foo (int i, int j)\n+{\n+  bar (a[i] >> j);\n+  bar ((unsigned long) a[i] >> j);\n+  bar ((short int) (unsigned long) a[i] >> j);\n+  bar (j >> a[i]);\n+  bar (j >> (unsigned long) a[i]);\n+  bar (j >> (short int) (unsigned long) a[i]);\n+  bar (a[i] / j);\n+  bar ((unsigned long) a[i] / j);\n+  bar ((short int) (unsigned long) a[i] / j);\n+  bar (j / a[i]);\n+  bar (j / (unsigned long) a[i]);\n+  bar (j / (short int) (unsigned long) a[i]);\n+}"}, {"sha": "7748780884c331a2d4cfd84af0c6747e0de3d7fc", "filename": "gcc/testsuite/c-c++-common/ubsan/bounds-4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fbounds-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fbounds-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fbounds-4.c?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fsanitize=bounds -Wall -Wextra -Wno-unused\" } */\n+\n+/* Initializers of TREE_STATICs aren't instrumented.\n+   But don't ICE on 'em.  */\n+\n+int A[2];\n+int *gp = &A[4];\n+int *gpi;\n+\n+int\n+main (void)\n+{\n+  gpi = &A[4];\n+  static int *pi = &A[4];\n+  return 0;\n+}"}, {"sha": "7b7d76d41d13c258e0f9a87eeb6dddd8789a1773", "filename": "gcc/testsuite/c-c++-common/ubsan/bounds-5.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fbounds-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fbounds-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fbounds-5.c?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -0,0 +1,88 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=bounds -Wall -Wextra -Wno-unused -Wno-array-bounds\" } */\n+\n+/* Test flexible array member-like arrays.  Normal flexible array members\n+   are tested in bounds-1.c.  Test non-strict mode.  */\n+\n+__attribute__ ((noinline, noclone))\n+void\n+fn1 (void)\n+{\n+  volatile struct S { char a[1]; char b; } s;\n+  s.a[0] = 1; // OK\n+  s.a[1] = 2; // error\n+  volatile struct S *p = &s;\n+  p->a[0] = 1; // OK\n+  p->a[1] = 1; // error\n+}\n+\n+__attribute__ ((noinline, noclone))\n+void\n+fn2 (void)\n+{\n+  struct S { int c; char d[4]; };\n+  volatile struct T { int e; struct S f; int g; } t;\n+  t.f.d[3] = 1; // OK\n+  t.f.d[4] = 1; // error\n+  volatile struct T *p = &t;\n+  p->f.d[3] = 1; // OK\n+  p->f.d[4] = 1; // error\n+}\n+\n+__attribute__ ((noinline, noclone))\n+void\n+fn3 (void)\n+{\n+  volatile struct S { char b; char a[1]; } s;\n+  s.a[0] = 1; // OK\n+  s.a[1] = 1; // error\n+  volatile struct S *p = &s;\n+  p->a[0] = 1; // OK\n+  p->a[1] = 1; // error in strict mode\n+}\n+\n+__attribute__ ((noinline, noclone))\n+void\n+fn4 (void)\n+{\n+  volatile struct S { char b; char a[1]; } s;\n+  volatile struct T { struct S s; int i; } t;\n+  t.s.a[0] = 1; // OK\n+  t.s.a[1] = 1; // error\n+  volatile struct T *pt = &t;\n+  pt->s.a[0] = 1; // OK\n+  pt->s.a[1] = 1; // error\n+}\n+\n+__attribute__ ((noinline, noclone))\n+void\n+fn5 (void)\n+{\n+  volatile struct S { char b; char a[1]; } s;\n+  volatile struct U { int a; struct S s; } u;\n+  u.s.a[0] = 1; // OK\n+  u.s.a[1] = 1; // error\n+  volatile struct U *pu = &u;\n+  pu->s.a[0] = 1; // OK\n+  pu->s.a[1] = 1; // error in strict mode\n+}\n+\n+int\n+main (void)\n+{\n+  fn1 ();\n+  fn2 ();\n+  fn3 ();\n+  fn4 ();\n+  fn5 ();\n+  return 0;\n+}\n+\n+/* { dg-output \"index 1 out of bounds for type 'char \\\\\\[1\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 1 out of bounds for type 'char \\\\\\[1\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 4 out of bounds for type 'char \\\\\\[4\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 4 out of bounds for type 'char \\\\\\[4\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 1 out of bounds for type 'char \\\\\\[1\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 1 out of bounds for type 'char \\\\\\[1\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 1 out of bounds for type 'char \\\\\\[1\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 1 out of bounds for type 'char \\\\\\[1\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "78ad29a73c03614feef57c61210d5b518a6012cb", "filename": "gcc/testsuite/c-c++-common/ubsan/bounds-6.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fbounds-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fbounds-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fbounds-6.c?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fsanitize=bounds -Wall -Wextra\" } */\n+\n+/* Test off-by-one.  */\n+\n+struct S { int a; int b; } s[4], *t;\n+struct U { int a[10]; } u[4], *v;\n+volatile int *a, *b, *c;\n+volatile void *d;\n+volatile int e[4][4];\n+\n+int\n+main (void)\n+{\n+  t = &s[4];  // OK\n+  a = &s[4].a; // Error\n+  b = &s[4].b; // Error\n+  d = &e[4];  // OK\n+  c = &e[4][0]; // Error\n+  c = &e[3][4]; // OK\n+  c = &e[3][3]; // OK\n+\n+  a = &u[4].a[9]; // Error\n+  a = &u[4].a[10]; // Error\n+  a = &u[3].a[9]; // OK\n+  a = &u[3].a[10]; // OK\n+  a = &u[3].a[11]; // Error\n+\n+  return 0;\n+}\n+\n+/* { dg-output \"index 4 out of bounds for type 'S \\\\\\[4\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 4 out of bounds for type 'S \\\\\\[4\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 4 out of bounds for type 'int \\\\\\[4\\\\\\]\\\\\\[4\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 4 out of bounds for type 'U \\\\\\[4\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 4 out of bounds for type 'U \\\\\\[4\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*index 11 out of bounds for type 'int \\\\\\[10\\\\\\]'\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "a2c88f92cb528117533fd64949cfb62b86de48fb", "filename": "gcc/tree-core.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -665,6 +665,13 @@ enum annot_expr_kind {\n   annot_expr_kind_last\n };\n \n+/* Internal functions.  */\n+enum internal_fn {\n+#define DEF_INTERNAL_FN(CODE, FLAGS) IFN_##CODE,\n+#include \"internal-fn.def\"\n+#undef DEF_INTERNAL_FN\n+  IFN_LAST\n+};\n \n /*---------------------------------------------------------------------------\n                                 Type definitions\n@@ -787,6 +794,9 @@ struct GTY(()) tree_base {\n \n     /* SSA version number.  This field is only used with SSA_NAME.  */\n     unsigned int version;\n+\n+    /* Internal function code.  */\n+    enum internal_fn ifn;\n   } GTY((skip(\"\"))) u;\n };\n "}, {"sha": "8522d7953108b0f1bada9a59c447ca5207a4a040", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"value-prof.h\"\n #include \"predict.h\"\n #include \"wide-int-print.h\"\n+#include \"internal-fn.h\"\n \n #include <new>                           // For placement-new.\n \n@@ -1753,7 +1754,10 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       break;\n \n     case CALL_EXPR:\n-      print_call_name (buffer, CALL_EXPR_FN (node), flags);\n+      if (CALL_EXPR_FN (node) != NULL_TREE)\n+\tprint_call_name (buffer, CALL_EXPR_FN (node), flags);\n+      else\n+\tpp_string (buffer, internal_fn_name (CALL_EXPR_IFN (node)));\n \n       /* Print parameters.  */\n       pp_space (buffer);"}, {"sha": "ac4012c04b7b0572cf57a4f190783116e007553b", "filename": "gcc/tree.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -8971,6 +8971,10 @@ get_callee_fndecl (const_tree call)\n      called.  */\n   addr = CALL_EXPR_FN (call);\n \n+  /* If there is no function, return early.  */\n+  if (addr == NULL_TREE)\n+    return NULL_TREE;\n+\n   STRIP_NOPS (addr);\n \n   /* If this is a readonly function pointer, extract its initial value.  */\n@@ -10598,6 +10602,27 @@ build_call_expr (tree fndecl, int n, ...)\n   return build_call_expr_loc_array (UNKNOWN_LOCATION, fndecl, n, argarray);\n }\n \n+/* Build internal call expression.  This is just like CALL_EXPR, except\n+   its CALL_EXPR_FN is NULL.  It will get gimplified later into ordinary\n+   internal function.  */\n+\n+tree\n+build_call_expr_internal_loc (location_t loc, enum internal_fn ifn,\n+\t\t\t      tree type, int n, ...)\n+{\n+  va_list ap;\n+  int i;\n+\n+  tree fn = build_call_1 (type, NULL_TREE, n);\n+  va_start (ap, n);\n+  for (i = 0; i < n; i++)\n+    CALL_EXPR_ARG (fn, i) = va_arg (ap, tree);\n+  va_end (ap);\n+  SET_EXPR_LOCATION (fn, loc);\n+  CALL_EXPR_IFN (fn) = ifn;\n+  return fn;\n+}\n+\n /* Create a new constant string literal and return a char* pointer to it.\n    The STRING_CST value is the LEN characters at STR.  */\n tree"}, {"sha": "299aacc06ccc2103cc3b4ae4a5219032edd7df11", "filename": "gcc/tree.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -574,7 +574,7 @@ DEFTREECODE (BIND_EXPR, \"bind_expr\", tcc_expression, 3)\n /* Function call.  CALL_EXPRs are represented by variably-sized expression\n    nodes.  There are at least three fixed operands.  Operand 0 is an\n    INTEGER_CST node containing the total operand count, the number of\n-   arguments plus 3.  Operand 1 is the function, while operand 2 is\n+   arguments plus 3.  Operand 1 is the function or NULL, while operand 2 is\n    is static chain argument, or NULL.  The remaining operands are the\n    arguments to the call.  */\n DEFTREECODE (CALL_EXPR, \"call_expr\", tcc_vl_exp, 3)"}, {"sha": "41de5c1eeb18de9cede6fb796101ffedce79769a", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -1134,12 +1134,12 @@ extern void protected_set_expr_location (tree, location_t);\n #define ASSERT_EXPR_VAR(NODE)\tTREE_OPERAND (ASSERT_EXPR_CHECK (NODE), 0)\n #define ASSERT_EXPR_COND(NODE)\tTREE_OPERAND (ASSERT_EXPR_CHECK (NODE), 1)\n \n-/* CALL_EXPR accessors.\n- */\n+/* CALL_EXPR accessors.  */\n #define CALL_EXPR_FN(NODE) TREE_OPERAND (CALL_EXPR_CHECK (NODE), 1)\n #define CALL_EXPR_STATIC_CHAIN(NODE) TREE_OPERAND (CALL_EXPR_CHECK (NODE), 2)\n #define CALL_EXPR_ARG(NODE, I) TREE_OPERAND (CALL_EXPR_CHECK (NODE), (I) + 3)\n #define call_expr_nargs(NODE) (VL_EXP_OPERAND_LENGTH (NODE) - 3)\n+#define CALL_EXPR_IFN(NODE) (CALL_EXPR_CHECK (NODE)->base.u.ifn)\n \n /* CALL_EXPR_ARGP returns a pointer to the argument vector for NODE.\n    We can't use &CALL_EXPR_ARG (NODE, 0) because that will complain if\n@@ -3631,6 +3631,8 @@ extern tree build_call_expr_loc_array (location_t, tree, int, tree *);\n extern tree build_call_expr_loc_vec (location_t, tree, vec<tree, va_gc> *);\n extern tree build_call_expr_loc (location_t, tree, int, ...);\n extern tree build_call_expr (tree, int, ...);\n+extern tree build_call_expr_internal_loc (location_t, enum internal_fn,\n+\t\t\t\t\t  tree, int, ...);\n extern tree build_string_literal (int, const char *);\n \n /* Construct various nodes representing data types.  */"}, {"sha": "5e1c3e7c9ed5931d5c4559c35c79171f37a4468e", "filename": "gcc/ubsan.c", "status": "modified", "additions": 113, "deletions": 18, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -271,23 +271,24 @@ get_ubsan_type_info_for_type (tree type)\n   gcc_assert (TYPE_SIZE (type) && tree_fits_uhwi_p (TYPE_SIZE (type)));\n   if (TREE_CODE (type) == REAL_TYPE)\n     return tree_to_uhwi (TYPE_SIZE (type));\n-  else\n+  else if (INTEGRAL_TYPE_P (type))\n     {\n       int prec = exact_log2 (tree_to_uhwi (TYPE_SIZE (type)));\n       gcc_assert (prec != -1);\n       return (prec << 1) | !TYPE_UNSIGNED (type);\n     }\n+  else\n+    return 0;\n }\n \n /* Helper routine that returns ADDR_EXPR of a VAR_DECL of a type\n    descriptor.  It first looks into the hash table; if not found,\n    create the VAR_DECL, put it into the hash table and return the\n-   ADDR_EXPR of it.  TYPE describes a particular type.  WANT_POINTER_TYPE_P\n-   means whether we are interested in the pointer type and not the pointer\n-   itself.  */\n+   ADDR_EXPR of it.  TYPE describes a particular type.  PSTYLE is\n+   an enum controlling how we want to print the type.  */\n \n tree\n-ubsan_type_descriptor (tree type, bool want_pointer_type_p)\n+ubsan_type_descriptor (tree type, enum ubsan_print_style pstyle)\n {\n   /* See through any typedefs.  */\n   type = TYPE_MAIN_VARIANT (type);\n@@ -308,7 +309,7 @@ ubsan_type_descriptor (tree type, bool want_pointer_type_p)\n   unsigned short tkind, tinfo;\n \n   /* Get the name of the type, or the name of the pointer type.  */\n-  if (want_pointer_type_p)\n+  if (pstyle == UBSAN_PRINT_POINTER)\n     {\n       gcc_assert (POINTER_TYPE_P (type));\n       type2 = TREE_TYPE (type);\n@@ -324,6 +325,12 @@ ubsan_type_descriptor (tree type, bool want_pointer_type_p)\n   /* If an array, get its type.  */\n   type2 = strip_array_types (type2);\n \n+  if (pstyle == UBSAN_PRINT_ARRAY)\n+    {\n+      while (POINTER_TYPE_P (type2))\n+        deref_depth++, type2 = TREE_TYPE (type2);\n+    }\n+\n   if (TYPE_NAME (type2) != NULL)\n     {\n       if (TREE_CODE (TYPE_NAME (type2)) == IDENTIFIER_NODE)\n@@ -338,7 +345,7 @@ ubsan_type_descriptor (tree type, bool want_pointer_type_p)\n \n   /* Decorate the type name with '', '*', \"struct\", or \"union\".  */\n   pretty_name = (char *) alloca (strlen (tname) + 16 + deref_depth);\n-  if (want_pointer_type_p)\n+  if (pstyle == UBSAN_PRINT_POINTER)\n     {\n       int pos = sprintf (pretty_name, \"'%s%s%s%s%s%s%s\",\n \t\t\t TYPE_VOLATILE (type2) ? \"volatile \" : \"\",\n@@ -355,6 +362,33 @@ ubsan_type_descriptor (tree type, bool want_pointer_type_p)\n       pretty_name[pos++] = '\\'';\n       pretty_name[pos] = '\\0';\n     }\n+  else if (pstyle == UBSAN_PRINT_ARRAY)\n+    {\n+      /* Pretty print the array dimensions.  */\n+      gcc_assert (TREE_CODE (type) == ARRAY_TYPE);\n+      tree t = type;\n+      int pos = sprintf (pretty_name, \"'%s \", tname);\n+      while (deref_depth-- > 0)\n+        pretty_name[pos++] = '*';\n+      while (TREE_CODE (t) == ARRAY_TYPE)\n+\t{\n+\t  pretty_name[pos++] = '[';\n+\t  tree dom = TYPE_DOMAIN (t);\n+\t  if (dom && TREE_CODE (TYPE_MAX_VALUE (dom)) == INTEGER_CST)\n+\t    pos += sprintf (&pretty_name[pos], HOST_WIDE_INT_PRINT_DEC,\n+\t\t\t    tree_to_shwi (TYPE_MAX_VALUE (dom)) + 1);\n+\t  else\n+\t    /* ??? We can't determine the variable name; print VLA unspec.  */\n+\t    pretty_name[pos++] = '*';\n+\t  pretty_name[pos++] = ']';\n+\t  t = TREE_TYPE (t);\n+\t}\n+      pretty_name[pos++] = '\\'';\n+      pretty_name[pos] = '\\0';\n+\n+     /* Save the tree with stripped types.  */\n+     type = t;\n+    }\n   else\n     sprintf (pretty_name, \"'%s'\", tname);\n \n@@ -550,6 +584,69 @@ is_ubsan_builtin_p (tree t)\n \t\t     \"__builtin___ubsan_\", 18) == 0;\n }\n \n+/* Expand the UBSAN_BOUNDS special builtin function.  */\n+\n+void\n+ubsan_expand_bounds_ifn (gimple_stmt_iterator *gsi)\n+{\n+  gimple stmt = gsi_stmt (*gsi);\n+  location_t loc = gimple_location (stmt);\n+  gcc_assert (gimple_call_num_args (stmt) == 3);\n+\n+  /* Pick up the arguments of the UBSAN_BOUNDS call.  */\n+  tree type = TREE_TYPE (TREE_TYPE (gimple_call_arg (stmt, 0)));\n+  tree index = gimple_call_arg (stmt, 1);\n+  tree orig_index_type = TREE_TYPE (index);\n+  tree bound = gimple_call_arg (stmt, 2);\n+\n+  gimple_stmt_iterator gsi_orig = *gsi;\n+\n+  /* Create condition \"if (index > bound)\".  */\n+  basic_block then_bb, fallthru_bb;\n+  gimple_stmt_iterator cond_insert_point\n+    = create_cond_insert_point (gsi, 0/*before_p*/, false, true,\n+\t\t\t\t&then_bb, &fallthru_bb);\n+  index = fold_convert (TREE_TYPE (bound), index);\n+  index = force_gimple_operand_gsi (&cond_insert_point, index,\n+\t\t\t\t    true/*simple_p*/, NULL_TREE,\n+\t\t\t\t    false/*before*/, GSI_NEW_STMT);\n+  gimple g = gimple_build_cond (GT_EXPR, index, bound, NULL_TREE, NULL_TREE);\n+  gimple_set_location (g, loc);\n+  gsi_insert_after (&cond_insert_point, g, GSI_NEW_STMT);\n+\n+  /* Generate __ubsan_handle_out_of_bounds call.  */\n+  *gsi = gsi_after_labels (then_bb);\n+  if (flag_sanitize_undefined_trap_on_error)\n+    g = gimple_build_call (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n+  else\n+    {\n+      tree data\n+\t= ubsan_create_data (\"__ubsan_out_of_bounds_data\", &loc, NULL,\n+\t\t\t     ubsan_type_descriptor (type, UBSAN_PRINT_ARRAY),\n+\t\t\t     ubsan_type_descriptor (orig_index_type),\n+\t\t\t     NULL_TREE);\n+      data = build_fold_addr_expr_loc (loc, data);\n+      enum built_in_function bcode\n+\t= flag_sanitize_recover\n+\t  ? BUILT_IN_UBSAN_HANDLE_OUT_OF_BOUNDS\n+\t  : BUILT_IN_UBSAN_HANDLE_OUT_OF_BOUNDS_ABORT;\n+      tree fn = builtin_decl_explicit (bcode);\n+      tree val = force_gimple_operand_gsi (gsi, ubsan_encode_value (index),\n+\t\t\t\t\t   true, NULL_TREE, true,\n+\t\t\t\t\t   GSI_SAME_STMT);\n+      g = gimple_build_call (fn, 2, data, val);\n+    }\n+  gimple_set_location (g, loc);\n+  gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+\n+  /* Get rid of the UBSAN_BOUNDS call from the IR.  */\n+  unlink_stmt_vdef (stmt);\n+  gsi_remove (&gsi_orig, true);\n+\n+  /* Point GSI to next logical statement.  */\n+  *gsi = gsi_start_bb (fallthru_bb);\n+}\n+\n /* Expand UBSAN_NULL internal call.  */\n \n void\n@@ -609,9 +706,11 @@ ubsan_expand_null_ifn (gimple_stmt_iterator gsi)\n       tree fn = builtin_decl_implicit (bcode);\n       const struct ubsan_mismatch_data m\n \t= { build_zero_cst (pointer_sized_int_node), ckind };\n-      tree data = ubsan_create_data (\"__ubsan_null_data\", &loc, &m,\n-\t\t\t\t     ubsan_type_descriptor (TREE_TYPE (ptr),\n-\t\t\t\t\t\t\t    true), NULL_TREE);\n+      tree data\n+\t= ubsan_create_data (\"__ubsan_null_data\", &loc, &m,\n+\t\t\t     ubsan_type_descriptor (TREE_TYPE (ptr),\n+\t\t\t\t\t\t    UBSAN_PRINT_POINTER),\n+\t\t\t     NULL_TREE);\n       data = build_fold_addr_expr_loc (loc, data);\n       g = gimple_build_call (fn, 2, data,\n \t\t\t     build_zero_cst (pointer_sized_int_node));\n@@ -689,8 +788,7 @@ ubsan_build_overflow_builtin (tree_code code, location_t loc, tree lhstype,\n     return build_call_expr_loc (loc, builtin_decl_explicit (BUILT_IN_TRAP), 0);\n \n   tree data = ubsan_create_data (\"__ubsan_overflow_data\", &loc, NULL,\n-\t\t\t\t ubsan_type_descriptor (lhstype, false),\n-\t\t\t\t NULL_TREE);\n+\t\t\t\t ubsan_type_descriptor (lhstype), NULL_TREE);\n   enum built_in_function fn_code;\n \n   switch (code)\n@@ -884,8 +982,7 @@ instrument_bool_enum_load (gimple_stmt_iterator *gsi)\n   else\n     {\n       tree data = ubsan_create_data (\"__ubsan_invalid_value_data\", &loc, NULL,\n-\t\t\t\t     ubsan_type_descriptor (type, false),\n-\t\t\t\t     NULL_TREE);\n+\t\t\t\t     ubsan_type_descriptor (type), NULL_TREE);\n       data = build_fold_addr_expr_loc (loc, data);\n       enum built_in_function bcode\n \t= flag_sanitize_recover\n@@ -1005,10 +1102,8 @@ ubsan_instrument_float_cast (location_t loc, tree type, tree expr)\n     {\n       /* Create the __ubsan_handle_float_cast_overflow fn call.  */\n       tree data = ubsan_create_data (\"__ubsan_float_cast_overflow_data\", NULL,\n-\t\t\t\t     NULL,\n-\t\t\t\t     ubsan_type_descriptor (expr_type, false),\n-\t\t\t\t     ubsan_type_descriptor (type, false),\n-\t\t\t\t     NULL_TREE);\n+\t\t\t\t     NULL, ubsan_type_descriptor (expr_type),\n+\t\t\t\t     ubsan_type_descriptor (type), NULL_TREE);\n       enum built_in_function bcode\n \t= flag_sanitize_recover\n \t  ? BUILT_IN_UBSAN_HANDLE_FLOAT_CAST_OVERFLOW"}, {"sha": "485449c32eceed78587eae0589c92090b78de5dd", "filename": "gcc/ubsan.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fubsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e37a2f33da9dcc33921ded88f700c28dff7960e/gcc%2Fubsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.h?ref=0e37a2f33da9dcc33921ded88f700c28dff7960e", "patch": "@@ -30,17 +30,25 @@ enum ubsan_null_ckind {\n   UBSAN_MEMBER_CALL\n };\n \n+/* This controls how ubsan prints types.  Used in ubsan_type_descriptor.  */\n+enum ubsan_print_style {\n+  UBSAN_PRINT_NORMAL,\n+  UBSAN_PRINT_POINTER,\n+  UBSAN_PRINT_ARRAY\n+};\n+\n /* An extra data used by ubsan pointer checking.  */\n struct ubsan_mismatch_data {\n   tree align;\n   tree ckind;\n };\n \n+extern void ubsan_expand_bounds_ifn (gimple_stmt_iterator *);\n extern void ubsan_expand_null_ifn (gimple_stmt_iterator);\n extern tree ubsan_instrument_unreachable (location_t);\n extern tree ubsan_create_data (const char *, const location_t *,\n \t\t\t       const struct ubsan_mismatch_data *, ...);\n-extern tree ubsan_type_descriptor (tree, bool);\n+extern tree ubsan_type_descriptor (tree, enum ubsan_print_style = UBSAN_PRINT_NORMAL);\n extern tree ubsan_encode_value (tree, bool = false);\n extern bool is_ubsan_builtin_p (tree);\n extern tree ubsan_build_overflow_builtin (tree_code, location_t, tree, tree, tree);"}]}