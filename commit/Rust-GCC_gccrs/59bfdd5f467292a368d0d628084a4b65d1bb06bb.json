{"sha": "59bfdd5f467292a368d0d628084a4b65d1bb06bb", "node_id": "C_kwDOANBUbNoAKDU5YmZkZDVmNDY3MjkyYTM2OGQwZDYyODA4NGE0YjY1ZDFiYjA2YmI", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2023-03-17T18:36:10Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2023-03-23T13:25:41Z"}, "message": "c++: further -Wdangling-reference refinement [PR107532]\n\nBased on <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=107532#c24>,\nit seems like we should treat *any* class with a reference member\nas a reference wrapper.  To suppress the warning in\n\n  int i = 42;\n  auto const& v = std::get<0>(std::tuple<int&>(i));\n\nwe have to look into base classes as well.  For std::tuple, this means\nthat we have to check the _Head_base subobject, which is a non-direct\nbase class of std::tuple.  So I've employed a DFS walk.\n\n\tPR c++/107532\n\ngcc/cp/ChangeLog:\n\n\t* call.cc (class_has_reference_member_p): New.\n\t(class_has_reference_member_p_r): New.\n\t(reference_like_class_p): Don't look for a specific constructor.\n\tUse a DFS walk with class_has_reference_member_p_r.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/warn/Wdangling-reference11.C: New test.\n\t* g++.dg/warn/Wdangling-reference12.C: New test.", "tree": {"sha": "f50a5eaa6ce601ea9751a42f0cb8cb7eae11d367", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f50a5eaa6ce601ea9751a42f0cb8cb7eae11d367"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59bfdd5f467292a368d0d628084a4b65d1bb06bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59bfdd5f467292a368d0d628084a4b65d1bb06bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59bfdd5f467292a368d0d628084a4b65d1bb06bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59bfdd5f467292a368d0d628084a4b65d1bb06bb/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b97715af0e848ef8703ac04665bde562b2ac159", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b97715af0e848ef8703ac04665bde562b2ac159", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b97715af0e848ef8703ac04665bde562b2ac159"}], "stats": {"total": 98, "additions": 72, "deletions": 26}, "files": [{"sha": "5df0f7ddee93aefeea2c21c479361c575375ae0d", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59bfdd5f467292a368d0d628084a4b65d1bb06bb/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59bfdd5f467292a368d0d628084a4b65d1bb06bb/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=59bfdd5f467292a368d0d628084a4b65d1bb06bb", "patch": "@@ -13785,8 +13785,31 @@ std_pair_ref_ref_p (tree t)\n \n /* Return true if a class CTYPE is either std::reference_wrapper or\n    std::ref_view, or a reference wrapper class.  We consider a class\n-   a reference wrapper class if it has a reference member and a\n-   constructor taking the same reference type.  */\n+   a reference wrapper class if it has a reference member.  We no\n+   longer check that it has a constructor taking the same reference type\n+   since that approach still generated too many false positives.  */\n+\n+static bool\n+class_has_reference_member_p (tree t)\n+{\n+  for (tree fields = TYPE_FIELDS (t);\n+       fields;\n+       fields = DECL_CHAIN (fields))\n+    if (TREE_CODE (fields) == FIELD_DECL\n+\t&& !DECL_ARTIFICIAL (fields)\n+\t&& TYPE_REF_P (TREE_TYPE (fields)))\n+      return true;\n+  return false;\n+}\n+\n+/* A wrapper for the above suitable as a callback for dfs_walk_once.  */\n+\n+static tree\n+class_has_reference_member_p_r (tree binfo, void *)\n+{\n+  return (class_has_reference_member_p (BINFO_TYPE (binfo))\n+\t  ? integer_one_node : NULL_TREE);\n+}\n \n static bool\n reference_like_class_p (tree ctype)\n@@ -13802,31 +13825,19 @@ reference_like_class_p (tree ctype)\n   if (decl_in_std_namespace_p (tdecl))\n     {\n       tree name = DECL_NAME (tdecl);\n-      return (name\n-\t      && (id_equal (name, \"reference_wrapper\")\n-\t\t  || id_equal (name, \"span\")\n-\t\t  || id_equal (name, \"ref_view\")));\n-    }\n-  for (tree fields = TYPE_FIELDS (ctype);\n-       fields;\n-       fields = DECL_CHAIN (fields))\n-    {\n-      if (TREE_CODE (fields) != FIELD_DECL || DECL_ARTIFICIAL (fields))\n-\tcontinue;\n-      tree type = TREE_TYPE (fields);\n-      if (!TYPE_REF_P (type))\n-\tcontinue;\n-      /* OK, the field is a reference member.  Do we have a constructor\n-\t taking its type?  */\n-      for (tree fn : ovl_range (CLASSTYPE_CONSTRUCTORS (ctype)))\n-\t{\n-\t  tree args = FUNCTION_FIRST_USER_PARMTYPE (fn);\n-\t  if (args\n-\t      && same_type_p (TREE_VALUE (args), type)\n-\t      && TREE_CHAIN (args) == void_list_node)\n-\t    return true;\n-\t}\n+      if (name\n+\t  && (id_equal (name, \"reference_wrapper\")\n+\t      || id_equal (name, \"span\")\n+\t      || id_equal (name, \"ref_view\")))\n+\treturn true;\n     }\n+\n+  /* Some classes, such as std::tuple, have the reference member in its\n+     (non-direct) base class.  */\n+  if (dfs_walk_once (TYPE_BINFO (ctype), class_has_reference_member_p_r,\n+\t\t     nullptr, nullptr))\n+    return true;\n+\n   return false;\n }\n "}, {"sha": "667618e7196f7e2ce1cad63074b443242f7ae4ab", "filename": "gcc/testsuite/g++.dg/warn/Wdangling-reference11.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59bfdd5f467292a368d0d628084a4b65d1bb06bb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59bfdd5f467292a368d0d628084a4b65d1bb06bb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference11.C?ref=59bfdd5f467292a368d0d628084a4b65d1bb06bb", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/107532\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-Wdangling-reference\" }\n+\n+struct R\n+{\n+    int& r;\n+    int& get() { return r; }\n+    int&& rget() { return static_cast<int&&>(r); }\n+};\n+\n+int main()\n+{\n+    int i = 42;\n+    int& l = R{i}.get(); // { dg-bogus \"dangling reference\" }\n+    int const& cl = R{i}.get(); // { dg-bogus \"dangling reference\" }\n+    int&& r = R{i}.rget(); // { dg-bogus \"dangling reference\" }\n+    int const&& cr = R{i}.rget(); // { dg-bogus \"dangling reference\" }\n+    (void) l;\n+    (void) r;\n+    (void) cr;\n+    (void) cl;\n+}"}, {"sha": "85e01f01a506e982383fbc254eb6dae5151cb52c", "filename": "gcc/testsuite/g++.dg/warn/Wdangling-reference12.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59bfdd5f467292a368d0d628084a4b65d1bb06bb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59bfdd5f467292a368d0d628084a4b65d1bb06bb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference12.C?ref=59bfdd5f467292a368d0d628084a4b65d1bb06bb", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/107532\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-Wdangling-reference\" }\n+\n+#include <tuple>\n+\n+int main()\n+{\n+  int i = 42;\n+  auto const& v = std::get<0>(std::tuple<int&>(i)); // { dg-bogus \"dangling reference\" }\n+  (void) v;\n+}"}]}