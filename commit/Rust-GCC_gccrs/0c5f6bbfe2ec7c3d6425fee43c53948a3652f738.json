{"sha": "0c5f6bbfe2ec7c3d6425fee43c53948a3652f738", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM1ZjZiYmZlMmVjN2MzZDY0MjVmZWU0M2M1Mzk0OGEzNjUyZjczOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-08-13T17:59:00Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-08-13T18:16:42Z"}, "message": "[c++]: Unconfuse lookup_name_real API a bit\n\nThe API for lookup_name_real is really confusing.  This addresses the part\nwhere we have NONCLASS to say DON'T search class scopes, and BLOCK_P to say\nDO search block scopes.  I've added a single bitmask to explicitly say which\nscopes to search.  I used an enum class so one can't accidentally misorder\nit.  It's also reordered so we don't mix it up with the parameters that say\nwhat kind of thing we're looking for.\n\n\tgcc/cp/\n\t* name-lookup.h (enum class LOOK_where): New.\n\t(operator|, operator&): Overloads for it.\n\t(lookup_name_real): Replace NONCLASS & BLOCK_P parms with WHERE.\n\t* name-lookup.c (identifier_type_value_w): Adjust\n\tlookup_name_real call.\n\t(lookup_name_real_1): Replace NONCLASS and BLOCK_P parameters\n\twith WHERE bitmask. Don't search namespaces if not asked to.\n\t(lookup_name_real): Adjust lookup_name_real_1 call.\n\t(lookup_name_nonclass, lookup_name)\n\t(lookup_name_prefer_type): Likewise.\n\t* call.c (build_operator_new_call)\n\t(add_operator_candidates): Adjust lookup_name_real calls.\n\t* parser.c (cp_parser_lookup_name): Likewise.\n\t* pt.c (tsubst_friend_class, lookup_init_capture_pack)\n\t(tsubst_expr): Likewise.\n\t* semantics.c (capture_decltype): Likewise.\n\tlibcc1/\n\t* libcp1plugin.cc (plugin_build_dependent_expr): Likewise.", "tree": {"sha": "93635729d6d168ab6b0e8e763b648bb9cf3851bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93635729d6d168ab6b0e8e763b648bb9cf3851bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c5f6bbfe2ec7c3d6425fee43c53948a3652f738", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c5f6bbfe2ec7c3d6425fee43c53948a3652f738", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c5f6bbfe2ec7c3d6425fee43c53948a3652f738", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c5f6bbfe2ec7c3d6425fee43c53948a3652f738/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55484a0f816ef9ad7e13fb1057751223ed8471d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55484a0f816ef9ad7e13fb1057751223ed8471d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55484a0f816ef9ad7e13fb1057751223ed8471d8"}], "stats": {"total": 104, "additions": 71, "deletions": 33}, "files": [{"sha": "47a368d069da452d08a84622a98e005595b8a269", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c5f6bbfe2ec7c3d6425fee43c53948a3652f738/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c5f6bbfe2ec7c3d6425fee43c53948a3652f738/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0c5f6bbfe2ec7c3d6425fee43c53948a3652f738", "patch": "@@ -4704,7 +4704,7 @@ build_operator_new_call (tree fnname, vec<tree, va_gc> **args,\n        up in the global scope.\n \n      we disregard block-scope declarations of \"operator new\".  */\n-  fns = lookup_name_real (fnname, 0, 1, /*block_p=*/false, 0, 0);\n+  fns = lookup_name_real (fnname, LOOK_where::NAMESPACE, 0, 0, 0);\n   fns = lookup_arg_dependent (fnname, fns, *args);\n \n   if (align_arg)\n@@ -5982,7 +5982,8 @@ add_operator_candidates (z_candidate **candidates,\n      consider.  */\n   if (!memonly)\n     {\n-      tree fns = lookup_name_real (fnname, 0, 1, /*block_p=*/true, 0, 0);\n+      tree fns = lookup_name_real (fnname, LOOK_where::BLOCK_NAMESPACE,\n+\t\t\t\t   0, 0, 0);\n       fns = lookup_arg_dependent (fnname, fns, arglist);\n       add_candidates (fns, NULL_TREE, arglist, NULL_TREE,\n \t\t      NULL_TREE, false, NULL_TREE, NULL_TREE,"}, {"sha": "4fdac9421d16d86c6b183b1ed62f61f2b5aa7716", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c5f6bbfe2ec7c3d6425fee43c53948a3652f738/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c5f6bbfe2ec7c3d6425fee43c53948a3652f738/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=0c5f6bbfe2ec7c3d6425fee43c53948a3652f738", "patch": "@@ -3741,7 +3741,7 @@ identifier_type_value_1 (tree id)\n     return REAL_IDENTIFIER_TYPE_VALUE (id);\n   /* Have to search for it. It must be on the global level, now.\n      Ask lookup_name not to return non-types.  */\n-  id = lookup_name_real (id, 2, 1, /*block_p=*/true, 0, 0);\n+  id = lookup_name_real (id, LOOK_where::BLOCK_NAMESPACE, 2, 0, 0);\n   if (id)\n     return TREE_TYPE (id);\n   return NULL_TREE;\n@@ -6413,10 +6413,16 @@ innermost_non_namespace_value (tree name)\n    namespace of variables, functions and typedefs.  Return a ..._DECL\n    node of some kind representing its definition if there is only one\n    such declaration, or return a TREE_LIST with all the overloaded\n-   definitions if there are many, or return 0 if it is undefined.\n+   definitions if there are many, or return NULL_TREE if it is undefined.\n    Hidden name, either friend declaration or built-in function, are\n    not ignored.\n \n+   WHERE controls which scopes are considered.  It is a bit mask of\n+   LOOKUP_where::BLOCK (look in block scope), LOOKUP_where::CLASS\n+   (look in class scopes) & LOOKUP_where::NAMESPACE (look in namespace\n+   scopes).  It is an error for no bits to be set.  These scopes are\n+   searched from innermost to outermost.\n+\n    If PREFER_TYPE is > 0, we prefer TYPE_DECLs or namespaces.\n    If PREFER_TYPE is > 1, we reject non-type decls (e.g. namespaces).\n    Otherwise we prefer non-TYPE_DECLs.\n@@ -6425,12 +6431,14 @@ innermost_non_namespace_value (tree name)\n    BLOCK_P is false, bindings in block scopes are ignored.  */\n \n static tree\n-lookup_name_real_1 (tree name, int prefer_type, int nonclass, bool block_p,\n+lookup_name_real_1 (tree name, LOOK_where where, int prefer_type,\n \t\t    int namespaces_only, int flags)\n {\n   cxx_binding *iter;\n   tree val = NULL_TREE;\n \n+  gcc_checking_assert (unsigned (where) != 0);\n+\n   query_oracle (name);\n \n   /* Conversion operators are handled specially because ordinary\n@@ -6468,17 +6476,19 @@ lookup_name_real_1 (tree name, int prefer_type, int nonclass, bool block_p,\n   /* First, look in non-namespace scopes.  */\n \n   if (current_class_type == NULL_TREE)\n-    nonclass = 1;\n+    /* Maybe avoid searching the binding stack at all.  */\n+    where = LOOK_where (unsigned (where) & ~unsigned (LOOK_where::CLASS));\n \n-  if (block_p || !nonclass)\n-    for (iter = outer_binding (name, NULL, !nonclass);\n+  if (where & (LOOK_where::BLOCK | LOOK_where::CLASS))\n+    for (iter = outer_binding (name, NULL, where & LOOK_where::CLASS);\n \t iter;\n-\t iter = outer_binding (name, iter, !nonclass))\n+\t iter = outer_binding (name, iter, where & LOOK_where::CLASS))\n       {\n \ttree binding;\n \n \t/* Skip entities we don't want.  */\n-\tif (LOCAL_BINDING_P (iter) ? !block_p : nonclass)\n+\tif (!(where & (LOCAL_BINDING_P (iter)\n+\t\t       ? LOOK_where::BLOCK : LOOK_where::CLASS)))\n \t  continue;\n \n \t/* If this is the kind of thing we're looking for, we're done.  */\n@@ -6548,7 +6558,7 @@ lookup_name_real_1 (tree name, int prefer_type, int nonclass, bool block_p,\n       }\n \n   /* Now lookup in namespace scopes.  */\n-  if (!val)\n+  if (!val && (where & LOOK_where::NAMESPACE))\n     {\n       name_lookup lookup (name, flags);\n       if (lookup.search_unqualified\n@@ -6566,12 +6576,12 @@ lookup_name_real_1 (tree name, int prefer_type, int nonclass, bool block_p,\n /* Wrapper for lookup_name_real_1.  */\n \n tree\n-lookup_name_real (tree name, int prefer_type, int nonclass, bool block_p,\n+lookup_name_real (tree name, LOOK_where where, int prefer_type,\n \t\t  int namespaces_only, int flags)\n {\n   tree ret;\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  ret = lookup_name_real_1 (name, prefer_type, nonclass, block_p,\n+  ret = lookup_name_real_1 (name, where, prefer_type,\n \t\t\t    namespaces_only, flags);\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return ret;\n@@ -6580,19 +6590,20 @@ lookup_name_real (tree name, int prefer_type, int nonclass, bool block_p,\n tree\n lookup_name_nonclass (tree name)\n {\n-  return lookup_name_real (name, 0, 1, /*block_p=*/true, 0, 0);\n+  return lookup_name_real (name, LOOK_where::BLOCK_NAMESPACE,\n+\t\t\t   0, 0, 0);\n }\n \n tree\n lookup_name (tree name)\n {\n-  return lookup_name_real (name, 0, 0, /*block_p=*/true, 0, 0);\n+  return lookup_name_real (name, LOOK_where::ALL, 0, 0, 0);\n }\n \n tree\n lookup_name_prefer_type (tree name, int prefer_type)\n {\n-  return lookup_name_real (name, prefer_type, 0, /*block_p=*/true, 0, 0);\n+  return lookup_name_real (name, LOOK_where::ALL, prefer_type, 0, 0);\n }\n \n /* Look up NAME for type used in elaborated name specifier in"}, {"sha": "4368c14d48cec27d1d9b6d96b981847c3d5e57af", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c5f6bbfe2ec7c3d6425fee43c53948a3652f738/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c5f6bbfe2ec7c3d6425fee43c53948a3652f738/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=0c5f6bbfe2ec7c3d6425fee43c53948a3652f738", "patch": "@@ -278,8 +278,33 @@ extern void push_binding_level (cp_binding_level *);\n extern bool handle_namespace_attrs (tree, tree);\n extern void pushlevel_class (void);\n extern void poplevel_class (void);\n+\n+/* What kind of scopes name lookup looks in.  An enum class so we\n+   don't accidentally mix integers.  */\n+enum class LOOK_where\n+{\n+  BLOCK = 1 << 0,  /* Consider block scopes.  */ \n+  CLASS = 1 << 1,  /* Consider class scopes.  */ \n+  NAMESPACE = 1 << 2,  /* Consider namespace scopes.  */ \n+\n+  ALL = BLOCK | CLASS | NAMESPACE,\n+  BLOCK_NAMESPACE = BLOCK | NAMESPACE,\n+  CLASS_NAMESPACE = CLASS | NAMESPACE,\n+};\n+constexpr LOOK_where operator| (LOOK_where a, LOOK_where b)\n+{\n+  return LOOK_where (unsigned (a) | unsigned (b));\n+}\n+constexpr bool operator& (LOOK_where a, LOOK_where b)\n+{\n+  return 0 != (unsigned (a) & unsigned (b));\n+}\n+\n extern tree lookup_name_prefer_type (tree, int);\n-extern tree lookup_name_real (tree, int, int, bool, int, int);\n+\n+\n+extern tree lookup_name_real (tree, LOOK_where, int prefer_type,\n+\t\t\t      int namespaces_only, int flags);\n extern tree lookup_type_scope (tree, tag_scope);\n extern tree get_namespace_binding (tree ns, tree id);\n extern void set_global_binding (tree decl);"}, {"sha": "2c45a3d6f41b461e2823bd3572987e1c11ee4e5d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c5f6bbfe2ec7c3d6425fee43c53948a3652f738/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c5f6bbfe2ec7c3d6425fee43c53948a3652f738/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0c5f6bbfe2ec7c3d6425fee43c53948a3652f738", "patch": "@@ -28459,17 +28459,17 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n       if (!decl)\n \t/* Look it up in the enclosing context.  DR 141: When looking for a\n \t   template-name after -> or ., only consider class templates.  */\n-\tdecl = lookup_name_real (name, prefer_type_arg (tag_type, is_template),\n-\t\t\t\t /*nonclass=*/0,\n-\t\t\t\t /*block_p=*/true, is_namespace, 0);\n+\tdecl = lookup_name_real (name, LOOK_where::ALL,\n+\t\t\t\t prefer_type_arg (tag_type, is_template),\n+\t\t\t\t is_namespace, 0);\n       parser->object_scope = object_type;\n       parser->qualifying_scope = NULL_TREE;\n     }\n   else\n     {\n-      decl = lookup_name_real (name, prefer_type_arg (tag_type),\n-\t\t\t       /*nonclass=*/0,\n-\t\t\t       /*block_p=*/true, is_namespace, 0);\n+      decl = lookup_name_real (name, LOOK_where::ALL,\n+\t\t\t       prefer_type_arg (tag_type),\n+\t\t\t       is_namespace, 0);\n       parser->qualifying_scope = NULL_TREE;\n       parser->object_scope = NULL_TREE;\n     }"}, {"sha": "5fd16bf781cd8ecebb4063f13c6bfd5960c2b4c0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c5f6bbfe2ec7c3d6425fee43c53948a3652f738/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c5f6bbfe2ec7c3d6425fee43c53948a3652f738/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0c5f6bbfe2ec7c3d6425fee43c53948a3652f738", "patch": "@@ -11183,9 +11183,9 @@ tsubst_friend_class (tree friend_tmpl, tree args)\n       push_nested_class (context);\n     }\n \n-  tmpl = lookup_name_real (DECL_NAME (friend_tmpl), /*prefer_type=*/false,\n-\t\t\t   /*non_class=*/false, /*block_p=*/false,\n-\t\t\t   /*namespaces_only=*/false, LOOKUP_HIDDEN);\n+  tmpl = lookup_name_real (DECL_NAME (friend_tmpl), LOOK_where::CLASS_NAMESPACE,\n+\t\t\t   /*prefer_type=*/0, /*namespaces_only=*/false,\n+\t\t\t   LOOKUP_HIDDEN);\n \n   if (tmpl && DECL_CLASS_TEMPLATE_P (tmpl))\n     {\n@@ -17835,7 +17835,7 @@ lookup_init_capture_pack (tree decl)\n   for (int i = 0; i < len; ++i)\n     {\n       tree ename = vec ? make_ith_pack_parameter_name (cname, i) : cname;\n-      tree elt = lookup_name_real (ename, 0, 0, true, 0, LOOKUP_NORMAL);\n+      tree elt = lookup_name_real (ename, LOOK_where::ALL, 0, 0, LOOKUP_NORMAL);\n       if (vec)\n \tTREE_VEC_ELT (vec, i) = elt;\n       else\n@@ -17940,9 +17940,10 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t    tree inst;\n \t    if (!DECL_PACK_P (decl))\n \t      {\n-\t\tinst = lookup_name_real (DECL_NAME (decl), /*prefer_type*/0,\n-\t\t\t\t\t /*nonclass*/1, /*block_p=*/true,\n-\t\t\t\t\t /*ns_only*/0, LOOKUP_HIDDEN);\n+\t\tinst = lookup_name_real (DECL_NAME (decl),\n+\t\t\t\t\t LOOK_where::BLOCK_NAMESPACE,\n+\t\t\t\t\t /*prefer_type*/0, /*ns_only*/0,\n+\t\t\t\t\t LOOKUP_HIDDEN);\n \t\tgcc_assert (inst != decl && is_capture_proxy (inst));\n \t      }\n \t    else if (is_normal_capture_proxy (decl))"}, {"sha": "e979a8b716c6e50d4216789cd0a4eb02734afd6f", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c5f6bbfe2ec7c3d6425fee43c53948a3652f738/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c5f6bbfe2ec7c3d6425fee43c53948a3652f738/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0c5f6bbfe2ec7c3d6425fee43c53948a3652f738", "patch": "@@ -10322,8 +10322,8 @@ static tree\n capture_decltype (tree decl)\n {\n   tree lam = CLASSTYPE_LAMBDA_EXPR (DECL_CONTEXT (current_function_decl));\n-  tree cap = lookup_name_real (DECL_NAME (decl), /*type*/0, /*nonclass*/1,\n-\t\t\t       /*block_p=*/true, /*ns*/0, LOOKUP_HIDDEN);\n+  tree cap = lookup_name_real (DECL_NAME (decl), LOOK_where::BLOCK_NAMESPACE,\n+\t\t\t       /*type*/0, /*ns*/false, LOOKUP_HIDDEN);\n   tree type;\n \n   if (cap && is_capture_proxy (cap))"}, {"sha": "24582c74a86daea3d908789170af113cd45cfdd5", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c5f6bbfe2ec7c3d6425fee43c53948a3652f738/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c5f6bbfe2ec7c3d6425fee43c53948a3652f738/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=0c5f6bbfe2ec7c3d6425fee43c53948a3652f738", "patch": "@@ -2652,7 +2652,7 @@ plugin_build_dependent_expr (cc1_plugin::connection *self,\n     }\n   tree res = identifier;\n   if (!scope)\n-    res = lookup_name_real (res, 0, 0, true, 0, 0);\n+    res = lookup_name_real (res, LOOK_where::BLOCK_NAMESPACE, 0, 0, 0);\n   else if (!TYPE_P (scope) || !dependent_scope_p (scope))\n     {\n       res = lookup_qualified_name (scope, res, false, true);"}]}