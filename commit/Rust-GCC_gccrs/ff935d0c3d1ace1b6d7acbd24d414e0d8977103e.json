{"sha": "ff935d0c3d1ace1b6d7acbd24d414e0d8977103e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY5MzVkMGMzZDFhY2UxYjZkN2FjYmQyNGQ0MTRlMGQ4OTc3MTAzZQ==", "commit": {"author": {"name": "Martin Galvan", "email": "martin.galvan@tallertechnologies.com", "date": "2015-05-15T16:57:10Z"}, "committer": {"name": "Ramana Radhakrishnan", "email": "ramana@gcc.gnu.org", "date": "2015-05-15T16:57:10Z"}, "message": "Add support for CFI directives in fp emulation routines for ARM.\n\n\n2015-05-15  Martin Galvan  <martin.galvan@tallertechnologies.com>\n\n        * config/arm/lib1funcs.S (CFI_START_FUNCTION, CFI_END_FUNCTION):\n        New macros.\n        * config/arm/ieee754-df.S: Add CFI directives.\n        * config/arm/ieee754-sf.S: Add CFI directives.\n\nFrom-SVN: r223220", "tree": {"sha": "8bc5aeb5cd40e0029d529b6404cbc10634856a6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bc5aeb5cd40e0029d529b6404cbc10634856a6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff935d0c3d1ace1b6d7acbd24d414e0d8977103e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff935d0c3d1ace1b6d7acbd24d414e0d8977103e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff935d0c3d1ace1b6d7acbd24d414e0d8977103e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff935d0c3d1ace1b6d7acbd24d414e0d8977103e/comments", "author": null, "committer": null, "parents": [{"sha": "cf57e99350d0b44876979c71986d8ca29c361f83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf57e99350d0b44876979c71986d8ca29c361f83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf57e99350d0b44876979c71986d8ca29c361f83"}], "stats": {"total": 301, "additions": 271, "deletions": 30}, "files": [{"sha": "4bf7c750611f8ebdd852a1822a93d9e401b88df7", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff935d0c3d1ace1b6d7acbd24d414e0d8977103e/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff935d0c3d1ace1b6d7acbd24d414e0d8977103e/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=ff935d0c3d1ace1b6d7acbd24d414e0d8977103e", "patch": "@@ -1,3 +1,10 @@\n+2015-05-15  Martin Galvan  <martin.galvan@tallertechnologies.com>\n+\n+        * config/arm/lib1funcs.S (CFI_START_FUNCTION, CFI_END_FUNCTION):\n+        New macros.\n+        * config/arm/ieee754-df.S: Add CFI directives.\n+        * config/arm/ieee754-sf.S: Add CFI directives.\n+\n 2015-05-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* configure.ac: Include config/sjlj.m4."}, {"sha": "4fa629d094baf28a6af1cd2ebfccc688925da750", "filename": "libgcc/config/arm/ieee754-df.S", "status": "modified", "additions": 162, "deletions": 21, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff935d0c3d1ace1b6d7acbd24d414e0d8977103e/libgcc%2Fconfig%2Farm%2Fieee754-df.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff935d0c3d1ace1b6d7acbd24d414e0d8977103e/libgcc%2Fconfig%2Farm%2Fieee754-df.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Farm%2Fieee754-df.S?ref=ff935d0c3d1ace1b6d7acbd24d414e0d8977103e", "patch": "@@ -33,8 +33,12 @@\n  * Only the default rounding mode is intended for best performances.\n  * Exceptions aren't supported yet, but that can be added quite easily\n  * if necessary without impacting performances.\n+ *\n+ * In the CFI related comments, 'previousOffset' refers to the previous offset\n+ * from sp used to compute the CFA.\n  */\n \n+\t.cfi_sections .debug_frame\n \n #ifndef __ARMEB__\n #define xl r0\n@@ -53,11 +57,13 @@\n \n ARM_FUNC_START negdf2\n ARM_FUNC_ALIAS aeabi_dneg negdf2\n+\tCFI_START_FUNCTION\n \n \t@ flip sign bit\n \teor\txh, xh, #0x80000000\n \tRET\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_dneg\n \tFUNC_END negdf2\n \n@@ -66,6 +72,7 @@ ARM_FUNC_ALIAS aeabi_dneg negdf2\n #ifdef L_arm_addsubdf3\n \n ARM_FUNC_START aeabi_drsub\n+\tCFI_START_FUNCTION\n \n \teor\txh, xh, #0x80000000\t@ flip sign bit of first arg\n \tb\t1f\t\n@@ -81,7 +88,11 @@ ARM_FUNC_ALIAS aeabi_dsub subdf3\n ARM_FUNC_START adddf3\n ARM_FUNC_ALIAS aeabi_dadd adddf3\n \n-1:\tdo_push\t{r4, r5, lr}\n+1:  do_push {r4, r5, lr}        @ sp -= 12\n+\t.cfi_adjust_cfa_offset 12   @ CFA is now sp + previousOffset + 12\n+\t.cfi_rel_offset r4, 0       @ Registers are saved from sp to sp + 8\n+\t.cfi_rel_offset r5, 4\n+\t.cfi_rel_offset lr, 8\n \n \t@ Look for zeroes, equal values, INF, or NAN.\n \tshift1\tlsl, r4, xh, #1\n@@ -148,6 +159,11 @@ ARM_FUNC_ALIAS aeabi_dadd adddf3\n \t@ Since this is not common case, rescale them off line.\n \tteq\tr4, r5\n \tbeq\tLSYM(Lad_d)\n+\n+@ CFI note: we're lucky that the branches to Lad_* that appear after this function\n+@ have a CFI state that's exactly the same as the one we're in at this\n+@ point. Otherwise the CFI would change to a different state after the branch,\n+@ which would be disastrous for backtracing.\n LSYM(Lad_x):\n \n \t@ Compensate for the exponent overlapping the mantissa MSB added later\n@@ -413,19 +429,27 @@ LSYM(Lad_i):\n \torrne\txh, xh, #0x00080000\t@ quiet NAN\n \tRETLDM\t\"r4, r5\"\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_dsub\n \tFUNC_END subdf3\n \tFUNC_END aeabi_dadd\n \tFUNC_END adddf3\n \n ARM_FUNC_START floatunsidf\n ARM_FUNC_ALIAS aeabi_ui2d floatunsidf\n+\tCFI_START_FUNCTION\n \n \tteq\tr0, #0\n \tdo_it\teq, t\n \tmoveq\tr1, #0\n \tRETc(eq)\n-\tdo_push\t{r4, r5, lr}\n+\n+\tdo_push {r4, r5, lr}        @ sp -= 12\n+\t.cfi_adjust_cfa_offset 12   @ CFA is now sp + previousOffset + 12\n+\t.cfi_rel_offset r4, 0       @ Registers are saved from sp + 0 to sp + 8.\n+\t.cfi_rel_offset r5, 4\n+\t.cfi_rel_offset lr, 8\n+\n \tmov\tr4, #0x400\t\t@ initial exponent\n \tadd\tr4, r4, #(52-1 - 1)\n \tmov\tr5, #0\t\t\t@ sign bit is 0\n@@ -435,17 +459,25 @@ ARM_FUNC_ALIAS aeabi_ui2d floatunsidf\n \tmov\txh, #0\n \tb\tLSYM(Lad_l)\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_ui2d\n \tFUNC_END floatunsidf\n \n ARM_FUNC_START floatsidf\n ARM_FUNC_ALIAS aeabi_i2d floatsidf\n+\tCFI_START_FUNCTION\n \n \tteq\tr0, #0\n \tdo_it\teq, t\n \tmoveq\tr1, #0\n \tRETc(eq)\n-\tdo_push\t{r4, r5, lr}\n+\n+\tdo_push {r4, r5, lr}        @ sp -= 12\n+\t.cfi_adjust_cfa_offset 12   @ CFA is now sp + previousOffset + 12\n+\t.cfi_rel_offset r4, 0       @ Registers are saved from sp + 0 to sp + 8.\n+\t.cfi_rel_offset r5, 4\n+\t.cfi_rel_offset lr, 8\n+\n \tmov\tr4, #0x400\t\t@ initial exponent\n \tadd\tr4, r4, #(52-1 - 1)\n \tands\tr5, r0, #0x80000000\t@ sign bit in r5\n@@ -457,11 +489,13 @@ ARM_FUNC_ALIAS aeabi_i2d floatsidf\n \tmov\txh, #0\n \tb\tLSYM(Lad_l)\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_i2d\n \tFUNC_END floatsidf\n \n ARM_FUNC_START extendsfdf2\n ARM_FUNC_ALIAS aeabi_f2d extendsfdf2\n+\tCFI_START_FUNCTION\n \n \tmovs\tr2, r0, lsl #1\t\t@ toss sign bit\n \tmov\txh, r2, asr #3\t\t@ stretch exponent\n@@ -480,34 +514,54 @@ ARM_FUNC_ALIAS aeabi_f2d extendsfdf2\n \n \t@ value was denormalized.  We can normalize it now.\n \tdo_push\t{r4, r5, lr}\n+\t.cfi_adjust_cfa_offset 12   @ CFA is now sp + previousOffset + 12\n+\t.cfi_rel_offset r4, 0       @ Registers are saved from sp + 0 to sp + 8.\n+\t.cfi_rel_offset r5, 4\n+\t.cfi_rel_offset lr, 8\n+\n \tmov\tr4, #0x380\t\t@ setup corresponding exponent\n \tand\tr5, xh, #0x80000000\t@ move sign bit in r5\n \tbic\txh, xh, #0x80000000\n \tb\tLSYM(Lad_l)\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_f2d\n \tFUNC_END extendsfdf2\n \n ARM_FUNC_START floatundidf\n ARM_FUNC_ALIAS aeabi_ul2d floatundidf\n+\tCFI_START_FUNCTION\n+\t.cfi_remember_state        @ Save the current CFA state.\n \n \torrs\tr2, r0, r1\n \tdo_it\teq\n \tRETc(eq)\n \n-\tdo_push\t{r4, r5, lr}\n+\tdo_push {r4, r5, lr}       @ sp -= 12\n+\t.cfi_adjust_cfa_offset 12  @ CFA is now sp + previousOffset + 12\n+\t.cfi_rel_offset r4, 0      @ Registers are saved from sp + 0 to sp + 8\n+\t.cfi_rel_offset r5, 4\n+\t.cfi_rel_offset lr, 8\n \n \tmov\tr5, #0\n \tb\t2f\n \n ARM_FUNC_START floatdidf\n ARM_FUNC_ALIAS aeabi_l2d floatdidf\n+\t.cfi_restore_state\n+\t@ Restore the CFI state we saved above. If we didn't do this then the\n+\t@ following instructions would have the CFI state that was set by the\n+\t@ offset adjustments made in floatundidf.\n \n \torrs\tr2, r0, r1\n \tdo_it\teq\n \tRETc(eq)\n \n-\tdo_push\t{r4, r5, lr}\n+\tdo_push {r4, r5, lr}       @ sp -= 12\n+\t.cfi_adjust_cfa_offset 12  @ CFA is now sp + previousOffset + 12\n+\t.cfi_rel_offset r4, 0      @ Registers are saved from sp to sp + 8\n+\t.cfi_rel_offset r5, 4\n+\t.cfi_rel_offset lr, 8\n \n \tands\tr5, ah, #0x80000000\t@ sign bit in r5\n \tbpl\t2f\n@@ -550,6 +604,7 @@ ARM_FUNC_ALIAS aeabi_l2d floatdidf\n \tadd\tr4, r4, r2\n \tb\tLSYM(Lad_p)\n \n+\tCFI_END_FUNCTION\n \tFUNC_END floatdidf\n \tFUNC_END aeabi_l2d\n \tFUNC_END floatundidf\n@@ -561,7 +616,14 @@ ARM_FUNC_ALIAS aeabi_l2d floatdidf\n \n ARM_FUNC_START muldf3\n ARM_FUNC_ALIAS aeabi_dmul muldf3\n-\tdo_push\t{r4, r5, r6, lr}\n+\tCFI_START_FUNCTION\n+\n+\tdo_push {r4, r5, r6, lr}    @ sp -= 16\n+\t.cfi_adjust_cfa_offset 16   @ CFA is now sp + previousOffset + 16\n+\t.cfi_rel_offset r4, 0       @ Registers are saved from sp to sp + 12.\n+\t.cfi_rel_offset r5, 4\n+\t.cfi_rel_offset r6, 8\n+\t.cfi_rel_offset lr, 12\n \n \t@ Mask out exponents, trap any zero/denormal/INF/NAN.\n \tmov\tip, #0xff\n@@ -596,7 +658,16 @@ ARM_FUNC_ALIAS aeabi_dmul muldf3\n \tand   r6, r6, #0x80000000\n \n \t@ Well, no way to make it shorter without the umull instruction.\n-\tstmfd\tsp!, {r6, r7, r8, r9, sl, fp}\n+\tstmfd   sp!, {r6, r7, r8, r9, sl, fp}   @ sp -= 24\n+\t.cfi_remember_state         @ Save the current CFI state.\n+\t.cfi_adjust_cfa_offset 24   @ CFA is now sp + previousOffset + 24.\n+\t.cfi_rel_offset r6, 0       @ Registers are saved from sp to sp + 20.\n+\t.cfi_rel_offset r7, 4\n+\t.cfi_rel_offset r8, 8\n+\t.cfi_rel_offset r9, 12\n+\t.cfi_rel_offset sl, 16\n+\t.cfi_rel_offset fp, 20\n+\n \tmov\tr7, xl, lsr #16\n \tmov\tr8, yl, lsr #16\n \tmov\tr9, xh, lsr #16\n@@ -648,8 +719,8 @@ ARM_FUNC_ALIAS aeabi_dmul muldf3\n \tmul\tfp, xh, yh\n \tadcs\tr5, r5, fp\n \tadc\tr6, r6, #0\n-\tldmfd\tsp!, {yl, r7, r8, r9, sl, fp}\n-\n+\tldmfd   sp!, {yl, r7, r8, r9, sl, fp}   @ sp += 24\n+\t.cfi_restore_state   @ Restore the previous CFI state.\n #else\n \n \t@ Here is the actual multiplication.\n@@ -715,7 +786,6 @@ LSYM(Lml_1):\n \torr\txh, xh, #0x00100000\n \tmov\tlr, #0\n \tsubs\tr4, r4, #1\n-\n LSYM(Lml_u):\n \t@ Overflow?\n \tbgt\tLSYM(Lml_o)\n@@ -863,13 +933,20 @@ LSYM(Lml_n):\n \torr\txh, xh, #0x00f80000\n \tRETLDM\t\"r4, r5, r6\"\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_dmul\n \tFUNC_END muldf3\n \n ARM_FUNC_START divdf3\n ARM_FUNC_ALIAS aeabi_ddiv divdf3\n+\tCFI_START_FUNCTION\n \t\n \tdo_push\t{r4, r5, r6, lr}\n+\t.cfi_adjust_cfa_offset 16\n+\t.cfi_rel_offset r4, 0\n+\t.cfi_rel_offset r5, 4\n+\t.cfi_rel_offset r6, 8\n+\t.cfi_rel_offset lr, 12\n \n \t@ Mask out exponents, trap any zero/denormal/INF/NAN.\n \tmov\tip, #0xff\n@@ -1052,6 +1129,7 @@ LSYM(Ldv_s):\n \tbne\tLSYM(Lml_z)\t\t@ 0 / <non_zero> -> 0\n \tb\tLSYM(Lml_n)\t\t@ 0 / 0 -> NAN\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_ddiv\n \tFUNC_END divdf3\n \n@@ -1063,6 +1141,7 @@ LSYM(Ldv_s):\n \n ARM_FUNC_START gtdf2\n ARM_FUNC_ALIAS gedf2 gtdf2\n+\tCFI_START_FUNCTION\n \tmov\tip, #-1\n \tb\t1f\n \n@@ -1077,6 +1156,10 @@ ARM_FUNC_ALIAS eqdf2 cmpdf2\n \tmov\tip, #1\t\t\t@ how should we specify unordered here?\n \n 1:\tstr\tip, [sp, #-4]!\n+\t.cfi_adjust_cfa_offset 4        @ CFA is now sp + previousOffset + 4.\n+\t@ We're not adding CFI for ip as it's pushed into the stack\n+\t@ only because @ it may be popped off later as a return value\n+\t@ (i.e. we're not preserving @ it anyways).\n \n \t@ Trap any INF/NAN first.\n \tmov\tip, xh, lsl #1\n@@ -1085,10 +1168,18 @@ ARM_FUNC_ALIAS eqdf2 cmpdf2\n \tdo_it\tne\n \tCOND(mvn,s,ne)\tip, ip, asr #21\n \tbeq\t3f\n-\n-\t@ Test for equality.\n-\t@ Note that 0.0 is equal to -0.0.\n+\t.cfi_remember_state\n+\t@ Save the current CFI state. This is done because the branch\n+\t@ is conditional, @ and if we don't take it we'll issue a\n+\t@ .cfi_adjust_cfa_offset and return.  @ If we do take it,\n+\t@ however, the .cfi_adjust_cfa_offset from the non-branch @ code\n+\t@ will affect the branch code as well. To avoid this we'll\n+\t@ restore @ the current state before executing the branch code.\n+\n+\t@ Test for equality.  @ Note that 0.0 is equal to -0.0.\n 2:\tadd\tsp, sp, #4\n+\t.cfi_adjust_cfa_offset -4       @ CFA is now sp + previousOffset.\n+\n \torrs\tip, xl, xh, lsl #1\t@ if x == 0.0 or -0.0\n \tdo_it\teq, e\n \tCOND(orr,s,eq)\tip, yl, yh, lsl #1\t@ and y == 0.0 or -0.0\n@@ -1117,8 +1208,13 @@ ARM_FUNC_ALIAS eqdf2 cmpdf2\n \torr\tr0, r0, #1\n \tRET\n \n-\t@ Look for a NAN.\n-3:\tmov\tip, xh, lsl #1\n+3:  @ Look for a NAN.\n+\n+\t@ Restore the previous CFI state (i.e. keep the CFI state as it was\n+\t@ before the branch).\n+\t.cfi_restore_state\n+\n+\tmov ip, xh, lsl #1\n \tmvns\tip, ip, asr #21\n \tbne\t4f\n \torrs\tip, xl, xh, lsl #12\n@@ -1128,9 +1224,13 @@ ARM_FUNC_ALIAS eqdf2 cmpdf2\n \tbne\t2b\n \torrs\tip, yl, yh, lsl #12\n \tbeq\t2b\t\t\t@ y is not NAN\n+\n 5:\tldr\tr0, [sp], #4\t\t@ unordered return code\n+\t.cfi_adjust_cfa_offset -4       @ CFA is now sp + previousOffset.\n+\n \tRET\n \n+\tCFI_END_FUNCTION\n \tFUNC_END gedf2\n \tFUNC_END gtdf2\n \tFUNC_END ledf2\n@@ -1140,6 +1240,7 @@ ARM_FUNC_ALIAS eqdf2 cmpdf2\n \tFUNC_END cmpdf2\n \n ARM_FUNC_START aeabi_cdrcmple\n+\tCFI_START_FUNCTION\n \n \tmov\tip, r0\n \tmov\tr0, r2\n@@ -1148,80 +1249,112 @@ ARM_FUNC_START aeabi_cdrcmple\n \tmov\tr1, r3\n \tmov\tr3, ip\n \tb\t6f\n-\t\n+\n ARM_FUNC_START aeabi_cdcmpeq\n ARM_FUNC_ALIAS aeabi_cdcmple aeabi_cdcmpeq\n \n \t@ The status-returning routines are required to preserve all\n \t@ registers except ip, lr, and cpsr.\n 6:\tdo_push\t{r0, lr}\n+\t.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8.\n+\t.cfi_rel_offset r0, 0     @ Previous r0 is saved at sp.\n+\t.cfi_rel_offset lr, 4     @ Previous lr is saved at sp + 4.\n+\n \tARM_CALL cmpdf2\n \t@ Set the Z flag correctly, and the C flag unconditionally.\n \tcmp\tr0, #0\n \t@ Clear the C flag if the return value was -1, indicating\n \t@ that the first operand was smaller than the second.\n \tdo_it\tmi\n \tcmnmi\tr0, #0\n+\n \tRETLDM\t\"r0\"\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_cdcmple\n \tFUNC_END aeabi_cdcmpeq\n \tFUNC_END aeabi_cdrcmple\n \t\n ARM_FUNC_START\taeabi_dcmpeq\n+\tCFI_START_FUNCTION\n+\n+\tstr lr, [sp, #-8]!        @ sp -= 8\n+\t.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8\n+\t.cfi_rel_offset lr, 0     @ lr is at sp\n \n-\tstr\tlr, [sp, #-8]!\n \tARM_CALL aeabi_cdcmple\n \tdo_it\teq, e\n \tmoveq\tr0, #1\t@ Equal to.\n \tmovne\tr0, #0\t@ Less than, greater than, or unordered.\n+\n \tRETLDM\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_dcmpeq\n \n ARM_FUNC_START\taeabi_dcmplt\n+\tCFI_START_FUNCTION\n+\n+\tstr lr, [sp, #-8]!        @ sp -= 8\n+\t.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8\n+\t.cfi_rel_offset lr, 0     @ lr is at sp\n \n-\tstr\tlr, [sp, #-8]!\n \tARM_CALL aeabi_cdcmple\n \tdo_it\tcc, e\n \tmovcc\tr0, #1\t@ Less than.\n \tmovcs\tr0, #0\t@ Equal to, greater than, or unordered.\n \tRETLDM\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_dcmplt\n \n ARM_FUNC_START\taeabi_dcmple\n+\tCFI_START_FUNCTION\n+\n+\tstr lr, [sp, #-8]!        @ sp -= 8\n+\t.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8\n+\t.cfi_rel_offset lr, 0     @ lr is at sp\n \n-\tstr\tlr, [sp, #-8]!\n \tARM_CALL aeabi_cdcmple\n \tdo_it\tls, e\n \tmovls\tr0, #1  @ Less than or equal to.\n \tmovhi\tr0, #0\t@ Greater than or unordered.\n \tRETLDM\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_dcmple\n \n ARM_FUNC_START\taeabi_dcmpge\n+\tCFI_START_FUNCTION\n+\n+\tstr lr, [sp, #-8]!        @ sp -= 8\n+\t.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8\n+\t.cfi_rel_offset lr, 0     @ lr is at sp\n \n-\tstr\tlr, [sp, #-8]!\n \tARM_CALL aeabi_cdrcmple\n \tdo_it\tls, e\n \tmovls\tr0, #1\t@ Operand 2 is less than or equal to operand 1.\n \tmovhi\tr0, #0\t@ Operand 2 greater than operand 1, or unordered.\n \tRETLDM\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_dcmpge\n \n ARM_FUNC_START\taeabi_dcmpgt\n+\tCFI_START_FUNCTION\n+\n+\tstr lr, [sp, #-8]!        @ sp -= 8\n+\t.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8\n+\t.cfi_rel_offset lr, 0     @ lr is at sp\n \n-\tstr\tlr, [sp, #-8]!\n \tARM_CALL aeabi_cdrcmple\n \tdo_it\tcc, e\n \tmovcc\tr0, #1\t@ Operand 2 is less than operand 1.\n \tmovcs\tr0, #0  @ Operand 2 is greater than or equal to operand 1,\n \t\t\t@ or they are unordered.\n \tRETLDM\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_dcmpgt\n \n #endif /* L_cmpdf2 */\n@@ -1230,6 +1363,7 @@ ARM_FUNC_START\taeabi_dcmpgt\n \n ARM_FUNC_START unorddf2\n ARM_FUNC_ALIAS aeabi_dcmpun unorddf2\n+\t.cfi_startproc\n \n \tmov\tip, xh, lsl #1\n \tmvns\tip, ip, asr #21\n@@ -1247,6 +1381,7 @@ ARM_FUNC_ALIAS aeabi_dcmpun unorddf2\n 3:\tmov\tr0, #1\t\t\t@ arguments are unordered.\n \tRET\n \n+\t.cfi_endproc\n \tFUNC_END aeabi_dcmpun\n \tFUNC_END unorddf2\n \n@@ -1256,6 +1391,7 @@ ARM_FUNC_ALIAS aeabi_dcmpun unorddf2\n \n ARM_FUNC_START fixdfsi\n ARM_FUNC_ALIAS aeabi_d2iz fixdfsi\n+\tCFI_START_FUNCTION\n \n \t@ check exponent range.\n \tmov\tr2, xh, lsl #1\n@@ -1289,6 +1425,7 @@ ARM_FUNC_ALIAS aeabi_d2iz fixdfsi\n 4:\tmov\tr0, #0\t\t\t@ How should we convert NAN?\n \tRET\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_d2iz\n \tFUNC_END fixdfsi\n \n@@ -1298,6 +1435,7 @@ ARM_FUNC_ALIAS aeabi_d2iz fixdfsi\n \n ARM_FUNC_START fixunsdfsi\n ARM_FUNC_ALIAS aeabi_d2uiz fixunsdfsi\n+\tCFI_START_FUNCTION\n \n \t@ check exponent range.\n \tmovs\tr2, xh, lsl #1\n@@ -1327,6 +1465,7 @@ ARM_FUNC_ALIAS aeabi_d2uiz fixunsdfsi\n 4:\tmov\tr0, #0\t\t\t@ How should we convert NAN?\n \tRET\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_d2uiz\n \tFUNC_END fixunsdfsi\n \n@@ -1336,6 +1475,7 @@ ARM_FUNC_ALIAS aeabi_d2uiz fixunsdfsi\n \n ARM_FUNC_START truncdfsf2\n ARM_FUNC_ALIAS aeabi_d2f truncdfsf2\n+\tCFI_START_FUNCTION\n \n \t@ check exponent range.\n \tmov\tr2, xh, lsl #1\n@@ -1400,6 +1540,7 @@ ARM_FUNC_ALIAS aeabi_d2f truncdfsf2\n \torr\tr0, r0, #0x00800000\n \tRET\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_d2f\n \tFUNC_END truncdfsf2\n "}, {"sha": "0e2f0694dd854585bcf0bc0632c34e966159d865", "filename": "libgcc/config/arm/ieee754-sf.S", "status": "modified", "additions": 92, "deletions": 9, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff935d0c3d1ace1b6d7acbd24d414e0d8977103e/libgcc%2Fconfig%2Farm%2Fieee754-sf.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff935d0c3d1ace1b6d7acbd24d414e0d8977103e/libgcc%2Fconfig%2Farm%2Fieee754-sf.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Farm%2Fieee754-sf.S?ref=ff935d0c3d1ace1b6d7acbd24d414e0d8977103e", "patch": "@@ -31,16 +31,21 @@\n  * Only the default rounding mode is intended for best performances.\n  * Exceptions aren't supported yet, but that can be added quite easily\n  * if necessary without impacting performances.\n+ *\n+ * In the CFI related comments, 'previousOffset' refers to the previous offset\n+ * from sp used to compute the CFA.\n  */\n \n #ifdef L_arm_negsf2\n \t\n ARM_FUNC_START negsf2\n ARM_FUNC_ALIAS aeabi_fneg negsf2\n+\tCFI_START_FUNCTION\n \n \teor\tr0, r0, #0x80000000\t@ flip sign bit\n \tRET\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_fneg\n \tFUNC_END negsf2\n \n@@ -49,6 +54,7 @@ ARM_FUNC_ALIAS aeabi_fneg negsf2\n #ifdef L_arm_addsubsf3\n \n ARM_FUNC_START aeabi_frsub\n+\tCFI_START_FUNCTION\n \n \teor\tr0, r0, #0x80000000\t@ flip sign bit of first arg\n \tb\t1f\n@@ -284,6 +290,7 @@ LSYM(Lad_i):\n \torrne\tr0, r0, #0x00400000\t@ quiet NAN\n \tRET\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_frsub\n \tFUNC_END aeabi_fadd\n \tFUNC_END addsf3\n@@ -292,6 +299,7 @@ LSYM(Lad_i):\n \n ARM_FUNC_START floatunsisf\n ARM_FUNC_ALIAS aeabi_ui2f floatunsisf\n+\tCFI_START_FUNCTION\n \t\t\n \tmov\tr3, #0\n \tb\t1f\n@@ -316,13 +324,15 @@ ARM_FUNC_ALIAS aeabi_i2f floatsisf\n \tmov\tal, #0\n \tb\t2f\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_i2f\n \tFUNC_END floatsisf\n \tFUNC_END aeabi_ui2f\n \tFUNC_END floatunsisf\n \n ARM_FUNC_START floatundisf\n ARM_FUNC_ALIAS aeabi_ul2f floatundisf\n+\tCFI_START_FUNCTION\n \n \torrs\tr2, r0, r1\n \tdo_it\teq\n@@ -409,6 +419,7 @@ ARM_FUNC_ALIAS aeabi_l2f floatdisf\n \tbiceq\tr0, r0, ip, lsr #31\n \tRET\n \n+\tCFI_END_FUNCTION\n \tFUNC_END floatdisf\n \tFUNC_END aeabi_l2f\n \tFUNC_END floatundisf\n@@ -420,6 +431,7 @@ ARM_FUNC_ALIAS aeabi_l2f floatdisf\n \n ARM_FUNC_START mulsf3\n ARM_FUNC_ALIAS aeabi_fmul mulsf3\n+\tCFI_START_FUNCTION\n \n \t@ Mask out exponents, trap any zero/denormal/INF/NAN.\n \tmov\tip, #0xff\n@@ -454,7 +466,13 @@ LSYM(Lml_x):\n \tand\tr3, ip, #0x80000000\n \n \t@ Well, no way to make it shorter without the umull instruction.\n-\tdo_push\t{r3, r4, r5}\n+\tdo_push\t{r3, r4, r5}       @ sp -= 12\n+\t.cfi_remember_state        @ Save the current CFI state\n+\t.cfi_adjust_cfa_offset 12  @ CFA is now sp + previousOffset + 12\n+\t.cfi_rel_offset r3, 0      @ Registers are saved from sp to sp + 8\n+\t.cfi_rel_offset r4, 4\n+\t.cfi_rel_offset r5, 8\n+\n \tmov\tr4, r0, lsr #16\n \tmov\tr5, r1, lsr #16\n \tbic\tr0, r0, r4, lsl #16\n@@ -465,7 +483,8 @@ LSYM(Lml_x):\n \tmla\tr0, r4, r1, r0\n \tadds\tr3, r3, r0, lsl #16\n \tadc\tr1, ip, r0, lsr #16\n-\tdo_pop\t{r0, r4, r5}\n+\tdo_pop\t{r0, r4, r5}       @ sp += 12\n+\t.cfi_restore_state         @ Restore the previous CFI state\n \n #else\n \n@@ -618,11 +637,13 @@ LSYM(Lml_n):\n \torr\tr0, r0, #0x00c00000\n \tRET\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_fmul\n \tFUNC_END mulsf3\n \n ARM_FUNC_START divsf3\n ARM_FUNC_ALIAS aeabi_fdiv divsf3\n+\tCFI_START_FUNCTION\n \n \t@ Mask out exponents, trap any zero/denormal/INF/NAN.\n \tmov\tip, #0xff\n@@ -758,6 +779,7 @@ LSYM(Ldv_s):\n \tbne\tLSYM(Lml_z)\t\t@ 0 / <non_zero> -> 0\n \tb\tLSYM(Lml_n)\t\t@ 0 / 0 -> NAN\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_fdiv\n \tFUNC_END divsf3\n \n@@ -782,6 +804,7 @@ LSYM(Ldv_s):\n \n ARM_FUNC_START gtsf2\n ARM_FUNC_ALIAS gesf2 gtsf2\n+\tCFI_START_FUNCTION\n \tmov\tip, #-1\n \tb\t1f\n \n@@ -796,6 +819,10 @@ ARM_FUNC_ALIAS eqsf2 cmpsf2\n \tmov\tip, #1\t\t\t@ how should we specify unordered here?\n \n 1:\tstr\tip, [sp, #-4]!\n+\t.cfi_adjust_cfa_offset 4  @ CFA is now sp + previousOffset + 4.\n+\t@ We're not adding CFI for ip as it's pushed into the stack only because\n+\t@ it may be popped off later as a return value (i.e. we're not preserving\n+\t@ it anyways).\n \n \t@ Trap any INF/NAN first.\n \tmov\tr2, r0, lsl #1\n@@ -804,10 +831,18 @@ ARM_FUNC_ALIAS eqsf2 cmpsf2\n \tdo_it\tne\n \tCOND(mvn,s,ne)\tip, r3, asr #24\n \tbeq\t3f\n+\t.cfi_remember_state\n+\t@ Save the current CFI state. This is done because the branch is conditional,\n+\t@ and if we don't take it we'll issue a .cfi_adjust_cfa_offset and return.\n+\t@ If we do take it, however, the .cfi_adjust_cfa_offset from the non-branch\n+\t@ code will affect the branch code as well. To avoid this we'll restore\n+\t@ the current state before executing the branch code.\n \n \t@ Compare values.\n \t@ Note that 0.0 is equal to -0.0.\n 2:\tadd\tsp, sp, #4\n+\t.cfi_adjust_cfa_offset -4       @ CFA is now sp + previousOffset.\n+\n \torrs\tip, r2, r3, lsr #1\t@ test if both are 0, clear C flag\n \tdo_it\tne\n \tteqne\tr0, r1\t\t\t@ if not 0 compare sign\n@@ -823,18 +858,26 @@ ARM_FUNC_ALIAS eqsf2 cmpsf2\n \torrne\tr0, r0, #1\n \tRET\n \n-\t@ Look for a NAN. \n-3:\tmvns\tip, r2, asr #24\n+3:\t@ Look for a NAN.\n+\n+\t@ Restore the previous CFI state (i.e. keep the CFI state as it was\n+\t@ before the branch).\n+\t.cfi_restore_state\n+\n+\tmvns\tip, r2, asr #24\n \tbne\t4f\n \tmovs\tip, r0, lsl #9\n \tbne\t5f\t\t\t@ r0 is NAN\n 4:\tmvns\tip, r3, asr #24\n \tbne\t2b\n \tmovs\tip, r1, lsl #9\n \tbeq\t2b\t\t\t@ r1 is not NAN\n+\n 5:\tldr\tr0, [sp], #4\t\t@ return unordered code.\n+\t.cfi_adjust_cfa_offset -4       @ CFA is now sp + previousOffset.\n \tRET\n \n+\tCFI_END_FUNCTION\n \tFUNC_END gesf2\n \tFUNC_END gtsf2\n \tFUNC_END lesf2\n@@ -844,6 +887,7 @@ ARM_FUNC_ALIAS eqsf2 cmpsf2\n \tFUNC_END cmpsf2\n \n ARM_FUNC_START aeabi_cfrcmple\n+\tCFI_START_FUNCTION\n \n \tmov\tip, r0\n \tmov\tr0, r1\n@@ -856,6 +900,13 @@ ARM_FUNC_ALIAS aeabi_cfcmple aeabi_cfcmpeq\n \t@ The status-returning routines are required to preserve all\n \t@ registers except ip, lr, and cpsr.\n 6:\tdo_push\t{r0, r1, r2, r3, lr}\n+\t.cfi_adjust_cfa_offset 20  @ CFA is at sp + previousOffset + 20\n+\t.cfi_rel_offset r0, 0      @ Registers are saved from sp to sp + 16\n+\t.cfi_rel_offset r1, 4\n+\t.cfi_rel_offset r2, 8\n+\t.cfi_rel_offset r3, 12\n+\t.cfi_rel_offset lr, 16\n+\n \tARM_CALL cmpsf2\n \t@ Set the Z flag correctly, and the C flag unconditionally.\n \tcmp\tr0, #0\n@@ -865,64 +916,90 @@ ARM_FUNC_ALIAS aeabi_cfcmple aeabi_cfcmpeq\n \tcmnmi\tr0, #0\n \tRETLDM\t\"r0, r1, r2, r3\"\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_cfcmple\n \tFUNC_END aeabi_cfcmpeq\n \tFUNC_END aeabi_cfrcmple\n \n ARM_FUNC_START\taeabi_fcmpeq\n+\tCFI_START_FUNCTION\n+\n+\tstr\tlr, [sp, #-8]!    @ sp -= 8\n+\t.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8\n+\t.cfi_rel_offset lr, 0     @ lr is at sp\n \n-\tstr\tlr, [sp, #-8]!\n \tARM_CALL aeabi_cfcmple\n \tdo_it\teq, e\n \tmoveq\tr0, #1\t@ Equal to.\n \tmovne\tr0, #0\t@ Less than, greater than, or unordered.\n \tRETLDM\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_fcmpeq\n \n ARM_FUNC_START\taeabi_fcmplt\n+\tCFI_START_FUNCTION\n+\n+\tstr\tlr, [sp, #-8]!    @ sp -= 8\n+\t.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8\n+\t.cfi_rel_offset lr, 0     @ lr is at sp\n \n-\tstr\tlr, [sp, #-8]!\n \tARM_CALL aeabi_cfcmple\n \tdo_it\tcc, e\n \tmovcc\tr0, #1\t@ Less than.\n \tmovcs\tr0, #0\t@ Equal to, greater than, or unordered.\n \tRETLDM\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_fcmplt\n \n ARM_FUNC_START\taeabi_fcmple\n+\tCFI_START_FUNCTION\n+\n+\tstr\tlr, [sp, #-8]!    @ sp -= 8\n+\t.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8\n+\t.cfi_rel_offset lr, 0     @ lr is at sp\n \n-\tstr\tlr, [sp, #-8]!\n \tARM_CALL aeabi_cfcmple\n \tdo_it\tls, e\n \tmovls\tr0, #1  @ Less than or equal to.\n \tmovhi\tr0, #0\t@ Greater than or unordered.\n \tRETLDM\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_fcmple\n \n ARM_FUNC_START\taeabi_fcmpge\n+\tCFI_START_FUNCTION\n+\n+\tstr\tlr, [sp, #-8]!    @ sp -= 8\n+\t.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8\n+\t.cfi_rel_offset lr, 0     @ lr is at sp\n \n-\tstr\tlr, [sp, #-8]!\n \tARM_CALL aeabi_cfrcmple\n \tdo_it\tls, e\n \tmovls\tr0, #1\t@ Operand 2 is less than or equal to operand 1.\n \tmovhi\tr0, #0\t@ Operand 2 greater than operand 1, or unordered.\n \tRETLDM\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_fcmpge\n \n ARM_FUNC_START\taeabi_fcmpgt\n+\tCFI_START_FUNCTION\n+\n+\tstr\tlr, [sp, #-8]!    @ sp -= 8\n+\t.cfi_adjust_cfa_offset 8  @ CFA is now sp + previousOffset + 8\n+\t.cfi_rel_offset lr, 0     @ lr is at sp\n \n-\tstr\tlr, [sp, #-8]!\n \tARM_CALL aeabi_cfrcmple\n \tdo_it\tcc, e\n \tmovcc\tr0, #1\t@ Operand 2 is less than operand 1.\n \tmovcs\tr0, #0  @ Operand 2 is greater than or equal to operand 1,\n \t\t\t@ or they are unordered.\n \tRETLDM\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_fcmpgt\n \n #endif /* L_cmpsf2 */\n@@ -931,6 +1008,7 @@ ARM_FUNC_START\taeabi_fcmpgt\n \n ARM_FUNC_START unordsf2\n ARM_FUNC_ALIAS aeabi_fcmpun unordsf2\n+\tCFI_START_FUNCTION\n \n \tmov\tr2, r0, lsl #1\n \tmov\tr3, r1, lsl #1\n@@ -947,6 +1025,7 @@ ARM_FUNC_ALIAS aeabi_fcmpun unordsf2\n 3:\tmov\tr0, #1\t\t\t@ arguments are unordered.\n \tRET\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_fcmpun\n \tFUNC_END unordsf2\n \n@@ -956,6 +1035,7 @@ ARM_FUNC_ALIAS aeabi_fcmpun unordsf2\n \n ARM_FUNC_START fixsfsi\n ARM_FUNC_ALIAS aeabi_f2iz fixsfsi\n+\tCFI_START_FUNCTION\n \n \t@ check exponent range.\n \tmov\tr2, r0, lsl #1\n@@ -989,6 +1069,7 @@ ARM_FUNC_ALIAS aeabi_f2iz fixsfsi\n 4:\tmov\tr0, #0\t\t\t@ What should we convert NAN to?\n \tRET\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_f2iz\n \tFUNC_END fixsfsi\n \n@@ -998,6 +1079,7 @@ ARM_FUNC_ALIAS aeabi_f2iz fixsfsi\n \n ARM_FUNC_START fixunssfsi\n ARM_FUNC_ALIAS aeabi_f2uiz fixunssfsi\n+\tCFI_START_FUNCTION\n \n \t@ check exponent range.\n \tmovs\tr2, r0, lsl #1\n@@ -1027,6 +1109,7 @@ ARM_FUNC_ALIAS aeabi_f2uiz fixunssfsi\n 4:\tmov\tr0, #0\t\t\t@ What should we convert NAN to?\n \tRET\n \n+\tCFI_END_FUNCTION\n \tFUNC_END aeabi_f2uiz\n \tFUNC_END fixunssfsi\n "}, {"sha": "e43d9a6c43bb5f3af05cabd3aaf60d4074af937d", "filename": "libgcc/config/arm/lib1funcs.S", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff935d0c3d1ace1b6d7acbd24d414e0d8977103e/libgcc%2Fconfig%2Farm%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff935d0c3d1ace1b6d7acbd24d414e0d8977103e/libgcc%2Fconfig%2Farm%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Farm%2Flib1funcs.S?ref=ff935d0c3d1ace1b6d7acbd24d414e0d8977103e", "patch": "@@ -1965,6 +1965,16 @@ LSYM(Lchange_\\register):\n \n #endif /* Arch supports thumb.  */\n \n+.macro CFI_START_FUNCTION\n+\t.cfi_startproc\n+\t.cfi_remember_state\n+.endm\n+\n+.macro CFI_END_FUNCTION\n+\t.cfi_restore_state\n+\t.cfi_endproc\n+.endm\n+\n #ifndef __symbian__\n #ifndef __ARM_ARCH_6M__\n #include \"ieee754-df.S\""}]}