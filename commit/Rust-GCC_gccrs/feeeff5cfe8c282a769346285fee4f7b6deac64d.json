{"sha": "feeeff5cfe8c282a769346285fee4f7b6deac64d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVlZWZmNWNmZThjMjgyYTc2OTM0NjI4NWZlZTRmN2I2ZGVhYzY0ZA==", "commit": {"author": {"name": "Joern Rennecke", "email": "joern.rennecke@embecosm.com", "date": "2011-11-05T20:48:23Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2011-11-05T20:48:23Z"}, "message": "config.gcc (epiphany-*-*): New architecture.\n\ngcc:\n        * config.gcc (epiphany-*-*): New architecture.\n        (epiphany-*-elf): New configuration.\n        * config/epiphany, common/config/epiphany : New directories.\n        * doc/extend.texi (disinterrupt attribute): Add Epiphany.\n        (interrupt attribute): Add Epiphany.\n        (long_call, short_call attribute): Add Epiphany.\n        * doc/invoke.texi (Options): Add Epiphany options.\n        * doc/md.texi (Machine Constraints): Add Epiphany constraints.\n        * doc/install.texi (Options specification):\n        Add --with-stack-offset=@var{num} description.\n        (host/target specific issues): Add epiphany-*-elf.\n        * doc/contrib.texi (Contributors): Mention Epiphany port.\ngcc/testsuite:\n        * gcc.c-torture/execute/ieee/mul-subnormal-single-1.x:\n        Disable test on Epiphany.\n        * gcc.c-torture/execute/20101011-1.c: Disable test on Epiphany.\n        * gcc.dg/stack-usage-1.c [__epiphany__] (SIZE): Define.\n        * gcc.dg/pragma-pack-3.c: Disable test on Epiphany.\n        * g++.dg/parse/pragma3.C: Likewise.\n        * stackalign/builtin-apply-2.c (STACK_ARGUMENTS_SIZE): Define.\n        (bar): Use it.\n        * gcc.dg/weak/typeof-2.c [epiphany-*-*]: Add option -mshort-calls.\n        * gcc.dg/tls/thr-cse-1.c: Likewise.\n        * g++.dg/opt/devirt2.C: Likewise.\n        * gcc.dg/20020312-2.c [epiphany-*-*] (PIC_REG): Define.\n        * gcc.dg/builtin-apply2.c [__epiphany__]: (STACK_ARGUMENTS_SIZE): 20.\n        * gcc.target/epiphany: New directory.\nlibgcc:\n        * config.host (epiphany-*-elf*): New configuration.\n        * config/epiphany: New Directory.\ncontrib:\n        * contrib-list.mk: Add Epiphany configurations.\n\nFrom-SVN: r181016", "tree": {"sha": "401d26da68f08d999dcb20c50e0d8c174247b88a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/401d26da68f08d999dcb20c50e0d8c174247b88a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/feeeff5cfe8c282a769346285fee4f7b6deac64d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feeeff5cfe8c282a769346285fee4f7b6deac64d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/feeeff5cfe8c282a769346285fee4f7b6deac64d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feeeff5cfe8c282a769346285fee4f7b6deac64d/comments", "author": {"login": "amylaar", "id": 1663475, "node_id": "MDQ6VXNlcjE2NjM0NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/1663475?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amylaar", "html_url": "https://github.com/amylaar", "followers_url": "https://api.github.com/users/amylaar/followers", "following_url": "https://api.github.com/users/amylaar/following{/other_user}", "gists_url": "https://api.github.com/users/amylaar/gists{/gist_id}", "starred_url": "https://api.github.com/users/amylaar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amylaar/subscriptions", "organizations_url": "https://api.github.com/users/amylaar/orgs", "repos_url": "https://api.github.com/users/amylaar/repos", "events_url": "https://api.github.com/users/amylaar/events{/privacy}", "received_events_url": "https://api.github.com/users/amylaar/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "12ca92d4f0ffdb6c6189da32ce44c87d4dc33ddc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12ca92d4f0ffdb6c6189da32ce44c87d4dc33ddc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12ca92d4f0ffdb6c6189da32ce44c87d4dc33ddc"}], "stats": {"total": 9560, "additions": 9550, "deletions": 10}, "files": [{"sha": "1336a6fa7864983e7d60dea61b05ce2de1fc2fa9", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -1,3 +1,7 @@\n+2011-11-05  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\n+\t* contrib-list.mk: Add Epiphany configurations.\n+\n 2011-09-13   Diego Novillo  <dnovillo@google.com>\n \n \t* testsuite-management: New."}, {"sha": "31e0237b62d850d338f6f7718a06cf61970a9752", "filename": "contrib/config-list.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/contrib%2Fconfig-list.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/contrib%2Fconfig-list.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fconfig-list.mk?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -18,7 +18,8 @@ LIST = alpha-linux-gnu alpha-freebsd6 alpha-netbsd alpha-openbsd \\\n   arm-linux-androideabi arm-uclinux_eabi arm-ecos-elf arm-eabi \\\n   arm-symbianelf arm-rtems arm-elf arm-wince-pe avr-rtems avr-elf \\\n   bfin-elf bfin-uclinux bfin-linux-uclibc bfin-rtems bfin-openbsd \\\n-  c6x-elf c6x-uclinux cris-elf cris-linux crisv32-elf crisv32-linux fido-elf \\\n+  c6x-elf c6x-uclinux cris-elf cris-linux crisv32-elf crisv32-linux \\\n+  epiphany-elf epiphany-elfOPT-with-stack-offset=16 fido-elf \\\n   fr30-elf frv-elf frv-linux h8300-elf h8300-rtems hppa-linux-gnu \\\n   hppa-linux-gnuOPT-enable-sjlj-exceptions=yes hppa64-linux-gnu \\\n   hppa2.0-hpux10.1 hppa64-hpux11.3 \\"}, {"sha": "2df0736db0e0542449ed8d245077bd1915ca8e62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -1,3 +1,18 @@\n+2011-11-05  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\n+\t* config.gcc (epiphany-*-*): New architecture.\n+\t(epiphany-*-elf): New configuration.\n+\t* config/epiphany, common/config/epiphany : New directories.\n+\t* doc/extend.texi (disinterrupt attribute): Add Epiphany.\n+\t(interrupt attribute): Add Epiphany.\n+\t(long_call, short_call attribute): Add Epiphany.\n+\t* doc/invoke.texi (Options): Add Epiphany options.\n+\t* doc/md.texi (Machine Constraints): Add Epiphany constraints.\n+\t* doc/install.texi (Options specification):\n+\tAdd --with-stack-offset=@var{num} description.\n+\t(host/target specific issues): Add epiphany-*-elf.\n+\t* doc/contrib.texi (Contributors): Mention Epiphany port.\n+\n 2011-11-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/50693"}, {"sha": "0382cb618390881d1b4296c85bc255cd7badcbd8", "filename": "gcc/common/config/epiphany/epiphany-common.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fcommon%2Fconfig%2Fepiphany%2Fepiphany-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fcommon%2Fconfig%2Fepiphany%2Fepiphany-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fepiphany%2Fepiphany-common.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,46 @@\n+/* Common hooks for Adapteva Epiphany\n+   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003,\n+   2004, 2005, 2006, 2007, 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"common/common-target.h\"\n+#include \"opts.h\"\n+#include \"flags.h\"\n+\n+#define TARGET_OPTION_OPTIMIZATION_TABLE epiphany_option_optimization_table\n+\n+#define TARGET_DEFAULT_TARGET_FLAGS \\\n+  (MASK_CMOVE | MASK_SOFT_CMPSF | MASK_SPLIT_LOHI | MASK_ROUND_NEAREST \\\n+   | MASK_VECT_DOUBLE | MASK_POST_INC | MASK_POST_MODIFY)\n+\n+#define TARGET_HAVE_NAMED_SECTIONS true\n+\n+#include \"common/common-target-def.h\"\n+\f\n+/* Implement TARGET_OPTION_OPTIMIZATION_TABLE.  */\n+static const struct default_options epiphany_option_optimization_table[] =\n+  {\n+    { OPT_LEVELS_1_PLUS, OPT_fomit_frame_pointer, NULL, 1 },\n+    { OPT_LEVELS_NONE, 0, NULL, 0 }\n+  };\n+\n+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;"}, {"sha": "1f1c54560a2c76f42293bd2b5a1ea9ce07886b72", "filename": "gcc/config.gcc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -967,6 +967,14 @@ crisv32-*-linux* | cris-*-linux*)\n \t\t;;\n \tesac\n \t;;\n+epiphany-*-elf )\n+\ttm_file=\"dbxelf.h elfos.h newlib-stdint.h ${tm_file}\"\n+\ttmake_file=\"epiphany/t-epiphany\"\n+\textra_options=\"${extra_options} fused-madd.opt\"\n+\textra_objs=\"$extra_objs mode-switch-use.o resolve-sw-modes.o\"\n+\ttm_defines=\"${tm_defines} EPIPHANY_STACK_OFFSET=${with_stack_offset:-8}\"\n+\textra_headers=\"epiphany_intrinsics.h\"\n+\t;;\n fr30-*-elf)\n \ttm_file=\"dbxelf.h elfos.h newlib-stdint.h ${tm_file}\"\n \t;;"}, {"sha": "d7c6c17845d69386d7c8cf961cc87692937d925d", "filename": "gcc/config/epiphany/constraints.md", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fconstraints.md?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,125 @@\n+;; Constraint definitions for Adaptiva epiphany\n+;; Copyright (C) 2007, 2009, 2011 Free Software Foundation, Inc.\n+;; Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; Integer constraints\n+\n+(define_constraint \"U16\"\n+  \"An unsigned 16-bit constant.\"\n+  (ior (and (match_code \"const_int\")\n+\t    (match_test \"IMM16 (ival)\"))\n+       (and (match_code \"symbol_ref,label_ref,const\")\n+\t    (match_test \"epiphany_small16 (op)\"))))\n+\n+(define_constraint \"K\"\n+  \"An unsigned 5-bit constant.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IMM5 (ival)\")))\n+\n+;; This could also accept symbol_ref, label_ref or const if we introduce\n+;; a small area and/or attribute that satisfies the 11-bit signed range.\n+(define_constraint \"L\"\n+  \"A signed 11-bit constant.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SIMM11 (ival)\")))\n+\n+(define_constraint \"Cm1\"\n+  \"A signed 11-bit constant added to -1\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SIMM11 (ival+1)\")\n+       (match_test \"epiphany_m1reg >= 0\")))\n+\n+(define_constraint \"Cl1\"\n+  \"Left-shift of -1\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == (ival | ~(ival-1))\")\n+       (match_test \"epiphany_m1reg >= 0\")))\n+\n+(define_constraint \"Cr1\"\n+  \"Right-shift of -1\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == (ival & ~(ival+1))\")\n+       (match_test \"epiphany_m1reg >= 0\")))\n+\n+(define_constraint \"Cal\"\n+  \"Constant for arithmetic/logical operations\"\n+  (match_test \"(flag_pic\n+\t\t? nonsymbolic_immediate_operand (op, VOIDmode)\n+\t\t: immediate_operand (op, VOIDmode))\"))\n+\n+(define_constraint \"Csy\"\n+  \"Symbolic constant for call/jump instruction\"\n+  (match_test \"symbolic_operand (op, VOIDmode)\"))\n+\n+;; Register constraints\n+;; proper register constraints define a register class and can thus\n+;; drive register allocation and reload.  OTOH sometimes we want to\n+;; avoid just that.\n+\n+;; The register class usable in short insns.\n+;; Subject to TARGET_PREFER_SHORT_INSN_REGS.\n+(define_register_constraint \"Rcs\" \"SHORT_INSN_REGS\"\n+  \"short insn register class.\")\n+\n+; The registers that can be used to hold a sibcall call address.\n+; This must not conflict with any callee-saved registers.\n+(define_register_constraint \"Rsc\" \"SIBCALL_REGS\"\n+  \"sibcall register class\")\n+\n+; The registers that can be used to hold a status value\n+(define_register_constraint \"Rct\" \"CORE_CONTROL_REGS\"\n+  \"Core control register class\")\n+\n+;; The register group usable in short insns.\n+(define_constraint \"Rgs\"\n+  \"short insn register group.\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) >= FIRST_PSEUDO_REGISTER || REGNO (op) <= 7\")))\n+\n+;; Constant suitable for the addsi3_r pattern.\n+(define_constraint \"Car\"\n+  \"addsi3_r constant.\"\n+  (and (match_code \"const_int\")\n+       (ior (match_test \"RTX_OK_FOR_OFFSET_P (SImode, op)\")\n+\t    (match_test \"RTX_OK_FOR_OFFSET_P (HImode, op)\")\n+\t    (match_test \"RTX_OK_FOR_OFFSET_P (QImode, op)\"))))\n+\n+;; The return address if it can be replaced with GPR_LR.\n+(define_constraint \"Rra\"\n+  \"return address constraint - register variant\"\n+  (and (match_code \"unspec\")\n+       (match_test \"XINT (op, 1) == UNSPEC_RETURN_ADDR\")\n+       (match_test \"!MACHINE_FUNCTION (cfun)->lr_clobbered\")))\n+\n+(define_constraint \"Rcc\"\n+  \"integer condition code\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == CC_REGNUM\")))\n+\n+;; The return address, which might be a stack slot.  */\n+(define_constraint \"Sra\"\n+  \"return address constraint - memory variant\"\n+  (and (match_code \"unspec\")\n+       (match_test \"XINT (op, 1) == UNSPEC_RETURN_ADDR\")))\n+\n+(define_constraint \"Cfm\"\n+  \"control register values to switch fp mode\"\n+  (and (match_code \"const\")\n+       (match_test \"GET_CODE (XEXP (op, 0)) == UNSPEC\")\n+       (match_test \"XINT (XEXP (op, 0), 1) == UNSPEC_FP_MODE\")))"}, {"sha": "c8375a1d75bcc550e02f3f490d67153867d66685", "filename": "gcc/config/epiphany/epiphany-modes.def", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fepiphany-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fepiphany-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany-modes.def?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,40 @@\n+/* Definitions of target machine for GNU compiler, Adapteva Epiphany cpu.\n+   Copyright (C) 2002, 2007, 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+CC_MODE (CC_Z);      /* only Z valid - for add, testing result.  */\n+CC_MODE (CC_N_NE);   /* N for not-equal (for lsl).  */\n+CC_MODE (CC_C_LTU);  /* C for unsigned-less-than (for add with carry).  */\n+CC_MODE (CC_C_GTU);  /* C for unsigned-greater-than (for sub with carry).  */\n+CC_MODE (CC_FP);\n+CC_MODE (CC_FP_EQ);  /* AZ for equal.  */\n+CC_MODE (CC_FP_ORD); /* AZ || ~AC for ordered.  */\n+CC_MODE (CC_FP_UNEQ); /* AZ || ~AC for unordered / equal.  */\n+CC_MODE (CC_FP_GTE); /* ~AC  / AZ for greater than / equal.  */\n+#if 0 /* This would be needed for simplified NaN testing.  */\n+RESET_FLOAT_FORMAT (SF, motorola_single_format);\n+RESET_FLOAT_FORMAT (DF, motorola_double_format);\n+#endif\n+VECTOR_MODES (INT, 4);\t\t/* V4QI V2HI */\n+VECTOR_MODES (INT, 8);\t\t/* V8QI V4HI V2SI */\n+VECTOR_MODE (FLOAT, SF, 2);\t/* V2SF */\n+ADJUST_ALIGNMENT (V8QI, epiphany_vect_align);\n+ADJUST_ALIGNMENT (V4HI, epiphany_vect_align);\n+ADJUST_ALIGNMENT (V2SI, epiphany_vect_align);\n+ADJUST_ALIGNMENT (V2SF, epiphany_vect_align);"}, {"sha": "334c5337f7ceb66d1e6cd412d5effc7799ba6a71", "filename": "gcc/config/epiphany/epiphany-protos.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fepiphany-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fepiphany-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany-protos.h?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,55 @@\n+/* Definitions of target machine for GNU compiler, EPIPHANY cpu.\n+   Copyright (C) 2000, 2004, 2007, 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifdef RTX_CODE\n+extern enum machine_mode epiphany_select_cc_mode (enum rtx_code, rtx, rtx);\n+\n+/* Define the function that build the compare insn for scc and bcc.  */\n+extern struct rtx_def *gen_compare_reg (enum machine_mode, enum rtx_code,\n+\t\t\t\t\tenum machine_mode, rtx, rtx);\n+#endif\n+\n+/* Declarations for various fns used in the .md file.  */\n+extern void epiphany_final_prescan_insn (rtx, rtx *, int);\n+extern bool epiphany_is_long_call_p (rtx);\n+extern bool epiphany_small16 (rtx);\n+bool epiphany_uninterruptible_p (tree decl);\n+bool epiphany_call_uninterruptible_p (rtx mem);\n+extern rtx sfunc_symbol (const char *name);\n+\n+extern void epiphany_expand_prologue (void);\n+extern void epiphany_expand_epilogue (int);\n+extern int epiphany_initial_elimination_offset (int, int);\n+extern void epiphany_init_expanders (void);\n+extern int hard_regno_mode_ok (int regno, enum machine_mode mode);\n+#ifdef HARD_CONST\n+extern void emit_set_fp_mode (int entity, int mode, HARD_REG_SET regs_live);\n+#endif\n+extern void epiphany_insert_mode_switch_use (rtx insn, int, int);\n+extern void epiphany_expand_set_fp_mode (rtx *operands);\n+extern int epiphany_mode_needed (int entity, rtx insn);\n+extern int epiphany_mode_entry_exit (int entity, bool);\n+extern int epiphany_mode_after (int entity, int last_mode, rtx insn);\n+extern int epiphany_mode_priority_to_mode (int entity, unsigned priority);\n+extern bool epiphany_epilogue_uses (int regno);\n+extern bool epiphany_optimize_mode_switching (int entity);\n+extern bool epiphany_is_interrupt_p (tree);\n+extern unsigned epiphany_special_round_type_align (tree, unsigned, unsigned);\n+extern unsigned epiphany_adjust_field_align (tree, unsigned);"}, {"sha": "a2420a562ae8ba2062f7a0d5aea365ad2ba61bd7", "filename": "gcc/config/epiphany/epiphany-sched.md", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fepiphany-sched.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fepiphany-sched.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany-sched.md?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,135 @@\n+;; DFA scheduling description for EPIPHANY\n+;; Copyright (C) 2004, 2006, 2007, 2009 Free Software Foundation, Inc.\n+;; Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; Two automata are defined to reduce number of states\n+;; which a single large automaton will have. (Factoring)\n+\n+(define_automaton \"inst_pipeline,fpu_pipe\")\n+\n+;; This unit is basically the decode unit of the processor.\n+;; Since epiphany is a dual issue machine, it is as if there are two\n+;; units so that any insn can be processed by either one\n+;; of the decoding unit.\n+\n+(define_cpu_unit \"pipe_01,pipe_02\" \"inst_pipeline\")\n+\n+;; The fixed point arithmetic unit.\n+\n+(define_cpu_unit  \"int\" \"inst_pipeline\")\n+\n+;; The floating point unit.\n+\n+(define_cpu_unit \"F0\" \"fpu_pipe\")\n+\n+;; ----------------------------------------------------\n+;; This reservation is to simplify the dual issue description.\n+\n+(define_reservation  \"issue\"  \"pipe_01|pipe_02\")\n+\n+;; This is to express instructions that cannot be paired.\n+\n+(define_reservation  \"d_lock\" \"pipe_01+pipe_02\")\n+\n+;; We don't model all pipeline stages; we model the issue stage\n+;; inasmuch as we allow only two instructions to issue simultaneously,\n+;; and flow instructions prevent any simultaneous issue of another instruction.\n+;; (This uses pipe_01 and pipe_02).\n+;; Double issue of 'other' insns is prevented by using the int unit in the\n+;; E1 stage.\n+;; Double issue of float instructions is prevented by using F0 in the E1 stage.\n+\n+(define_insn_reservation \"simple_arith\" 2\n+  (and (eq_attr \"pipe_model\" \"epiphany\")\n+       (eq_attr \"type\" \"move,cmove,compare,shift,misc,mul\")\n+       (eq_attr \"length\" \"4\"))\n+  \"issue,int\")\n+\n+; anything but fp / fp_int has a bypass\n+(define_bypass 1 \"simple_arith\" \"simple_arith,simple_arith_2,simple_arith_4,load,store,branch,call,flow\")\n+\n+(define_insn_reservation \"simple_arith_2\" 2\n+  (and (eq_attr \"pipe_model\" \"epiphany\")\n+       (eq_attr \"type\" \"move,cmove,compare,shift,misc,mul\")\n+       (eq_attr \"length\" \"8\"))\n+  \"issue,issue+int,int\")\n+\n+(define_insn_reservation \"simple_arith_4\" 4\n+  (and (eq_attr \"pipe_model\" \"epiphany\")\n+       (eq_attr \"type\" \"move,compare,shift,misc,mul\")\n+       (eq_attr \"length\" \"12,16,20,24\"))\n+  \"issue,issue+int,issue+int,issue+int,int\")\n+\n+;; Loads have a latency of two.\n+;; Note that we fix up the latency of post_modify in epiphany.c:epiphany_adjust_cost\n+\n+(define_insn_reservation \"load\" 3\n+  (and (eq_attr \"pipe_model\" \"epiphany\")\n+       (eq_attr \"type\" \"load\"))\n+  \"issue,int\")\n+\n+; anything but fp / fp_int has a bypass\n+(define_bypass 2 \"load\" \"simple_arith,simple_arith_2,simple_arith_4,load,store,branch,call,flow\")\n+\n+(define_insn_reservation \"store\" 1\n+  (and (eq_attr \"pipe_model\" \"epiphany\")\n+       (eq_attr \"type\" \"store\"))\n+  \"issue,int\")\n+\n+;; Branch\n+;; Latency when taken: \t3\n+;; Issue Rate: \t1\n+;; The latency is 1 when the branch is not taken.\n+;; We can't really do much with the latency, even if we could express it,\n+;; but the pairing restrictions are useful to take into account.\n+\n+(define_insn_reservation \"branch\"  1\n+  (and (eq_attr \"pipe_model\" \"epiphany\")\n+       (eq_attr \"type\" \"branch,uncond_branch\"))\n+  \"d_lock\")\n+\n+;; calls introduce a longisch delay that is likely to flush the pipelines\n+;; of the caller's instructions.  Both the call instruction itself and\n+;; the rts at the end of the call / sfunc incurs a three cycle penalty,\n+;; thus also isolating the scheduling of caller and callee.\n+\n+(define_insn_reservation \"call\" 8\n+  (and (eq_attr \"pipe_model\" \"epiphany\")\n+       (eq_attr \"type\" \"call,sfunc,fp_sfunc\"))\n+  \"d_lock*8\")\n+\n+(define_insn_reservation \"flow\" 1\n+  (and (eq_attr \"pipe_model\" \"epiphany\")\n+       (eq_attr \"type\" \"flow\"))\n+  \"d_lock\")\n+\f\n+(define_insn_reservation \"fp_arith_trunc\"  3\n+  (and (eq_attr \"pipe_model\" \"epiphany\")\n+       (and (eq_attr \"type\" \"fp,fp_int\")\n+\t    (eq_attr \"rounding\" \"trunc\")))\n+  \"issue,F0\")\n+\n+(define_insn_reservation \"fp_arith_nearest\"  5\n+  (and (eq_attr \"pipe_model\" \"epiphany\")\n+       (and (eq_attr \"type\" \"fp,fp_int\")\n+\t    (eq_attr \"rounding\" \"nearest\")))\n+  \"issue,F0\")\n+\n+(define_bypass 2 \"fp_arith_trunc\" \"store\")\n+(define_bypass 4 \"fp_arith_nearest\" \"store\")"}, {"sha": "a4652da87b815ea4ac73fa85d333cd481ee31ec3", "filename": "gcc/config/epiphany/epiphany.c", "status": "added", "additions": 2751, "deletions": 0, "changes": 2751, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,2751 @@\n+/* Subroutines used for code generation on the EPIPHANY cpu.\n+   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003,\n+   2004, 2005, 2006, 2007, 2009, 2010, 2011 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"diagnostic-core.h\"\n+#include \"recog.h\"\n+#include \"toplev.h\"\n+#include \"tm_p.h\"\n+#include \"target.h\"\n+#include \"df.h\"\n+#include \"langhooks.h\"\n+#include \"insn-codes.h\"\n+#include \"ggc.h\"\n+#include \"tm-constrs.h\"\n+#include \"tree-pass.h\"\n+#include \"integrate.h\"\n+\n+/* Which cpu we're compiling for.  */\n+int epiphany_cpu_type;\n+\n+/* Name of mangle string to add to symbols to separate code compiled for each\n+   cpu (or NULL).  */\n+const char *epiphany_mangle_cpu;\n+\n+/* Array of valid operand punctuation characters.  */\n+char epiphany_punct_chars[256];\n+\n+/* The rounding mode that we generally use for floating point.  */\n+int epiphany_normal_fp_rounding;\n+\n+static void epiphany_init_reg_tables (void);\n+static int get_epiphany_condition_code (rtx);\n+static tree epiphany_handle_interrupt_attribute (tree *, tree, tree, int, bool *);\n+static bool epiphany_pass_by_reference (cumulative_args_t, enum machine_mode,\n+\t\t\t\t\tconst_tree, bool);\n+static rtx frame_insn (rtx);\n+\f\n+/* defines for the initialization of the GCC target structure.  */\n+#define TARGET_ATTRIBUTE_TABLE epiphany_attribute_table\n+\n+#define TARGET_PRINT_OPERAND epiphany_print_operand\n+#define TARGET_PRINT_OPERAND_ADDRESS epiphany_print_operand_address\n+\n+#define TARGET_RTX_COSTS epiphany_rtx_costs\n+#define TARGET_ADDRESS_COST epiphany_address_cost\n+#define TARGET_MEMORY_MOVE_COST epiphany_memory_move_cost\n+\n+#define TARGET_PROMOTE_FUNCTION_MODE epiphany_promote_function_mode\n+#define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true\n+\n+#define TARGET_RETURN_IN_MEMORY epiphany_return_in_memory\n+#define TARGET_PASS_BY_REFERENCE epiphany_pass_by_reference\n+#define TARGET_CALLEE_COPIES hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true\n+#define TARGET_FUNCTION_VALUE epiphany_function_value\n+#define TARGET_LIBCALL_VALUE epiphany_libcall_value\n+#define TARGET_FUNCTION_VALUE_REGNO_P epiphany_function_value_regno_p\n+\n+#define TARGET_SETUP_INCOMING_VARARGS epiphany_setup_incoming_varargs\n+\n+/* Using the simplistic varags handling forces us to do partial reg/stack\n+   argument passing for types with larger size (> 4 bytes) than alignemnt.  */\n+#define TARGET_ARG_PARTIAL_BYTES epiphany_arg_partial_bytes\n+\n+#define TARGET_FUNCTION_OK_FOR_SIBCALL epiphany_function_ok_for_sibcall\n+\n+#define TARGET_SCHED_ISSUE_RATE epiphany_issue_rate\n+#define TARGET_SCHED_ADJUST_COST epiphany_adjust_cost\n+\n+#define TARGET_LEGITIMATE_ADDRESS_P epiphany_legitimate_address_p\n+\n+#define TARGET_SECONDARY_RELOAD epiphany_secondary_reload\n+\n+#define TARGET_OPTION_OVERRIDE epiphany_override_options\n+\n+#define TARGET_CONDITIONAL_REGISTER_USAGE epiphany_conditional_register_usage\n+\n+#define TARGET_FUNCTION_ARG epiphany_function_arg\n+\n+#define TARGET_FUNCTION_ARG_ADVANCE epiphany_function_arg_advance\n+\n+#define TARGET_FUNCTION_ARG_BOUNDARY epiphany_function_arg_boundary\n+\n+#define TARGET_TRAMPOLINE_INIT epiphany_trampoline_init\n+\n+/* Nonzero if the constant rtx value is a legitimate general operand.\n+   We can handle any 32- or 64-bit constant.  */\n+#define TARGET_LEGITIMATE_CONSTANT_P hook_bool_mode_rtx_true\n+\n+#define TARGET_MIN_DIVISIONS_FOR_RECIP_MUL \\\n+  epiphany_min_divisions_for_recip_mul\n+\n+#define TARGET_VECTORIZE_PREFERRED_SIMD_MODE epiphany_preferred_simd_mode\n+\n+#define TARGET_VECTOR_MODE_SUPPORTED_P epiphany_vector_mode_supported_p\n+\n+#define TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE \\\n+  epiphany_vector_alignment_reachable\n+\n+#define TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT \\\n+  epiphany_support_vector_misalignment\n+\n+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK \\\n+  hook_bool_const_tree_hwi_hwi_const_tree_true\n+#define TARGET_ASM_OUTPUT_MI_THUNK epiphany_output_mi_thunk\n+\n+#include \"target-def.h\"\n+\n+#undef TARGET_ASM_ALIGNED_HI_OP\n+#define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n+\f\n+bool\n+epiphany_is_interrupt_p (tree decl)\n+{\n+  tree attrs;\n+\n+  attrs = DECL_ATTRIBUTES (decl);\n+  if (lookup_attribute (\"interrupt\", attrs))\n+    return true;\n+  else\n+    return false;\n+}\n+\n+/* Called from epiphany_override_options.\n+   We use this to initialize various things.  */\n+\n+static void\n+epiphany_init (void)\n+{\n+  /* N.B. this pass must not run before the first optimize_mode_switching\n+     pass because of the side offect of epiphany_mode_needed on\n+     MACHINE_FUNCTION(cfun)->unknown_mode_uses.  But it must run before\n+     pass_resolve_sw_modes.  */\n+  static struct register_pass_info insert_use_info\n+    = { &pass_mode_switch_use.pass, \"mode_sw\",\n+\t1, PASS_POS_INSERT_AFTER\n+      };\n+  static struct register_pass_info mode_sw2_info\n+    = { &pass_mode_switching.pass, \"mode_sw\",\n+\t1, PASS_POS_INSERT_AFTER\n+      };\n+  static struct register_pass_info mode_sw3_info\n+    = { &pass_resolve_sw_modes.pass, \"mode_sw\",\n+\t1, PASS_POS_INSERT_AFTER\n+      };\n+  static struct register_pass_info mode_sw4_info\n+    = { &pass_split_all_insns.pass, \"mode_sw\",\n+\t1, PASS_POS_INSERT_AFTER\n+      };\n+\n+  epiphany_init_reg_tables ();\n+\n+  /* Initialize array for PRINT_OPERAND_PUNCT_VALID_P.  */\n+  memset (epiphany_punct_chars, 0, sizeof (epiphany_punct_chars));\n+  epiphany_punct_chars['-'] = 1;\n+\n+  epiphany_normal_fp_rounding\n+    = (epiphany_normal_fp_mode == FP_MODE_ROUND_TRUNC\n+       ? FP_MODE_ROUND_TRUNC : FP_MODE_ROUND_NEAREST);\n+  register_pass (&mode_sw4_info);\n+  register_pass (&mode_sw2_info);\n+  register_pass (&mode_sw3_info);\n+  register_pass (&insert_use_info);\n+  register_pass (&mode_sw2_info);\n+\n+#if 1 /* As long as peep2_rescan is not implemented,\n+         (see http://gcc.gnu.org/ml/gcc-patches/2011-10/msg02819.html,)\n+         we need a second peephole2 pass to get reasonable code.  */\n+  {\n+    static struct register_pass_info peep2_2_info\n+      = { &pass_peephole2.pass, \"peephole2\",\n+\t  1, PASS_POS_INSERT_AFTER\n+\t};\n+\n+    register_pass (&peep2_2_info);\n+  }\n+#endif\n+}\n+\n+/* The condition codes of the EPIPHANY, and the inverse function.  */\n+static const char *const epiphany_condition_codes[] =\n+{ /* 0    1      2      3      4      5      6     7      8      9   */\n+   \"eq\", \"ne\", \"ltu\", \"gteu\", \"gt\", \"lte\", \"gte\", \"lt\", \"gtu\", \"lteu\",\n+  /* 10   11    12     13  */\n+   \"beq\",\"bne\",\"blt\", \"blte\",\n+};\n+\n+#define EPIPHANY_INVERSE_CONDITION_CODE(X)  ((X) ^ 1)\n+\n+/* Returns the index of the EPIPHANY condition code string in\n+   `epiphany_condition_codes'.  COMPARISON should be an rtx like\n+   `(eq (...) (...))'.  */\n+\n+static int\n+get_epiphany_condition_code (rtx comparison)\n+{\n+  switch (GET_MODE (XEXP (comparison, 0)))\n+    {\n+    case CCmode:\n+      switch (GET_CODE (comparison))\n+\t{\n+\tcase EQ  : return 0;\n+\tcase NE  : return 1;\n+\tcase LTU : return 2;\n+\tcase GEU : return 3;\n+\tcase GT  : return 4;\n+\tcase LE  : return 5;\n+\tcase GE  : return 6;\n+\tcase LT  : return 7;\n+\tcase GTU : return 8;\n+\tcase LEU : return 9;\n+\n+\tdefault : gcc_unreachable ();\n+\t}\n+    case CC_N_NEmode:\n+      switch (GET_CODE (comparison))\n+\t{\n+\tcase EQ: return 6;\n+\tcase NE: return 7;\n+\tdefault: gcc_unreachable ();\n+\t}\n+    case CC_C_LTUmode:\n+      switch (GET_CODE (comparison))\n+\t{\n+\tcase GEU: return 2;\n+\tcase LTU: return 3;\n+\tdefault: gcc_unreachable ();\n+\t}\n+    case CC_C_GTUmode:\n+      switch (GET_CODE (comparison))\n+\t{\n+\tcase LEU: return 3;\n+\tcase GTU: return 2;\n+\tdefault: gcc_unreachable ();\n+\t}\n+    case CC_FPmode:\n+      switch (GET_CODE (comparison))\n+\t{\n+\tcase EQ: return 10;\n+\tcase NE: return 11;\n+\tcase LT: return 12;\n+\tcase LE: return 13;\n+\tdefault: gcc_unreachable ();\n+\t}\n+    case CC_FP_EQmode:\n+      switch (GET_CODE (comparison))\n+\t{\n+\tcase EQ: return 0;\n+\tcase NE: return 1;\n+\tdefault: gcc_unreachable ();\n+\t}\n+    case CC_FP_GTEmode:\n+      switch (GET_CODE (comparison))\n+\t{\n+\tcase EQ: return 0;\n+\tcase NE: return 1;\n+\tcase GT : return 4;\n+\tcase GE : return 6;\n+\tcase UNLE : return 5;\n+\tcase UNLT : return 7;\n+\tdefault: gcc_unreachable ();\n+\t}\n+    case CC_FP_ORDmode:\n+      switch (GET_CODE (comparison))\n+\t{\n+\tcase ORDERED: return 9;\n+\tcase UNORDERED: return 8;\n+\tdefault: gcc_unreachable ();\n+\t}\n+    case CC_FP_UNEQmode:\n+      switch (GET_CODE (comparison))\n+\t{\n+\tcase UNEQ: return 9;\n+\tcase LTGT: return 8;\n+\tdefault: gcc_unreachable ();\n+\t}\n+    default: gcc_unreachable ();\n+    }\n+  /*NOTREACHED*/\n+  return (42);\n+}\n+\n+\n+/* Return 1 if hard register REGNO can hold a value of machine_mode MODE.  */\n+int\n+hard_regno_mode_ok (int regno, enum machine_mode mode)\n+{\n+  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+    return (regno & 1) == 0 && GPR_P (regno);\n+  else\n+    return 1;\n+}\n+\n+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n+   return the mode to be used for the comparison.  */\n+\n+enum machine_mode\n+epiphany_select_cc_mode (enum rtx_code op,\n+\t\t\t rtx x ATTRIBUTE_UNUSED,\n+\t\t\t rtx y ATTRIBUTE_UNUSED)\n+{\n+  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+    {\n+      if (TARGET_SOFT_CMPSF)\n+\t{\n+\t  if (op == EQ || op == NE)\n+\t    return CC_FP_EQmode;\n+\t  if (op == ORDERED || op == UNORDERED)\n+\t    return CC_FP_ORDmode;\n+\t  if (op == UNEQ || op == LTGT)\n+\t    return CC_FP_UNEQmode;\n+\t  return CC_FP_GTEmode;\n+\t}\n+      return CC_FPmode;\n+    }\n+  /* recognize combiner pattern ashlsi_btst:\n+     (parallel [\n+\t    (set (reg:N_NE 65 cc1)\n+\t\t(compare:N_NE (zero_extract:SI (reg/v:SI 75 [ a ])\n+\t\t\t(const_int 1 [0x1])\n+\t\t\t(const_int 0 [0x0]))\n+\t\t    (const_int 0 [0x0])))\n+\t    (clobber (scratch:SI))  */\n+  else if ((op == EQ || op == NE)\n+\t   && GET_CODE (x) == ZERO_EXTRACT\n+\t   && XEXP (x, 1) == const1_rtx\n+\t   && CONST_INT_P (XEXP (x, 2)))\n+    return CC_N_NEmode;\n+  else if ((op == GEU || op == LTU) && GET_CODE (x) == PLUS)\n+    return CC_C_LTUmode;\n+  else if ((op == LEU || op == GTU) && GET_CODE (x) == MINUS)\n+    return CC_C_GTUmode;\n+  else\n+    return CCmode;\n+}\n+\n+enum reg_class epiphany_regno_reg_class[FIRST_PSEUDO_REGISTER];\n+\n+static void\n+epiphany_init_reg_tables (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (i == GPR_LR)\n+\tepiphany_regno_reg_class[i] = LR_REGS;\n+      else if (i <= 7 && TARGET_PREFER_SHORT_INSN_REGS)\n+\tepiphany_regno_reg_class[i] = SHORT_INSN_REGS;\n+      else if (call_used_regs[i]\n+\t       && TEST_HARD_REG_BIT (reg_class_contents[GENERAL_REGS], i))\n+\tepiphany_regno_reg_class[i] = SIBCALL_REGS;\n+      else if (i >= CORE_CONTROL_FIRST && i <= CORE_CONTROL_LAST)\n+\tepiphany_regno_reg_class[i] = CORE_CONTROL_REGS;\n+      else if (i < (GPR_LAST+1)\n+\t       || i == ARG_POINTER_REGNUM || i == FRAME_POINTER_REGNUM)\n+\tepiphany_regno_reg_class[i] = GENERAL_REGS;\n+      else if (i == CC_REGNUM)\n+\tepiphany_regno_reg_class[i] = NO_REGS /* CC_REG: must be NO_REGS */;\n+      else\n+\tepiphany_regno_reg_class[i] = NO_REGS;\n+    }\n+}\n+\f\n+/* EPIPHANY specific attribute support.\n+\n+   The EPIPHANY has these attributes:\n+   interrupt - for interrupt functions.\n+   short_call - the function is assumed to be reachable with the b / bl\n+\t\tinstructions.\n+   long_call - the function address is loaded into a register before use.\n+   disinterrupt - functions which mask interrupts throughout.\n+                     They unmask them while calling an interruptible\n+\t\t     function, though.  */\n+\n+static const struct attribute_spec epiphany_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"interrupt\",  1, 1, true,  false, false, epiphany_handle_interrupt_attribute, true },\n+  { \"long_call\",  0, 0, false, true, true, NULL, false },\n+  { \"short_call\", 0, 0, false, true, true, NULL, false },\n+  { \"disinterrupt\", 0, 0, false, true, true, NULL, false },\n+  { NULL,         0, 0, false, false, false, NULL, false }\n+};\n+\n+/* Handle an \"interrupt\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+epiphany_handle_interrupt_attribute (tree *node ATTRIBUTE_UNUSED,\n+\t\t\t\t     tree name, tree args,\n+\t\t\t\t     int flags ATTRIBUTE_UNUSED,\n+\t\t\t\t     bool *no_add_attrs)\n+{\n+  tree value = TREE_VALUE (args);\n+\n+  if (TREE_CODE (value) != STRING_CST)\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"argument of %qE attribute is not a string constant\", name);\n+      *no_add_attrs = true;\n+    }\n+  else if (strcmp (TREE_STRING_POINTER (value), \"reset\")\n+\t   && strcmp (TREE_STRING_POINTER (value), \"software_exception\")\n+\t   && strcmp (TREE_STRING_POINTER (value), \"timer\")\n+\t   && strcmp (TREE_STRING_POINTER (value), \"dma0\")\n+\t   && strcmp (TREE_STRING_POINTER (value), \"dma1\")\n+\t   && strcmp (TREE_STRING_POINTER (value), \"static_flag\")\n+\t   && strcmp (TREE_STRING_POINTER (value), \"swi\"))\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"argument of %qE attribute is not \\\"reset\\\", \\\"software_exception\\\", \\\"timer\\\", \\\"dma0\\\", \\\"dma1\\\", \\\"static_flag\\\" or \\\"swi\\\"\",\n+\t       name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+\f\n+/* Misc. utilities.  */\n+\n+/* Generate a SYMBOL_REF for the special function NAME.  When the address\n+   can't be placed directly into a call instruction, and if possible, copy\n+   it to a register so that cse / code hoisting is possible.  */\n+rtx\n+sfunc_symbol (const char *name)\n+{\n+  rtx sym = gen_rtx_SYMBOL_REF (Pmode, name);\n+\n+  /* These sfuncs should be hidden, and every dso should get a copy.  */\n+  SYMBOL_REF_FLAGS (sym) = SYMBOL_FLAG_FUNCTION | SYMBOL_FLAG_LOCAL;\n+  if (TARGET_SHORT_CALLS)\n+    ; /* Nothing to be done.  */\n+  else if (can_create_pseudo_p ())\n+    sym = copy_to_mode_reg (Pmode, sym);\n+  else /* We rely on reload to fix this up.  */\n+    gcc_assert (!reload_in_progress || reload_completed);\n+  return sym;\n+}\n+\n+/* X and Y are two things to compare using CODE in IN_MODE.\n+   Emit the compare insn, construct the the proper cc reg in the proper\n+   mode, and return the rtx for the cc reg comparison in CMODE.  */\n+\n+rtx\n+gen_compare_reg (enum machine_mode cmode, enum rtx_code code,\n+\t\t enum machine_mode in_mode, rtx x, rtx y)\n+{\n+  enum machine_mode mode = SELECT_CC_MODE (code, x, y);\n+  rtx cc_reg, pat, clob0, clob1, clob2;\n+\n+  if (in_mode == VOIDmode)\n+    in_mode = GET_MODE (x);\n+  if (in_mode == VOIDmode)\n+    in_mode = GET_MODE (y);\n+\n+  if (mode == CC_FPmode)\n+    {\n+      /* The epiphany has only EQ / NE / LT / LE conditions for\n+\t hardware floating point.  */\n+      if (code == GT || code == GE || code == UNLE || code == UNLT)\n+\t{\n+\t  rtx tmp = x; x = y; y = tmp;\n+\t  code = swap_condition (code);\n+\t}\n+      cc_reg = gen_rtx_REG (mode, CCFP_REGNUM);\n+      y = force_reg (in_mode, y);\n+    }\n+  else\n+    {\n+      if (mode == CC_FP_GTEmode\n+\t  && (code == LE || code == LT || code == UNGT || code == UNGE))\n+\t{\n+\t  rtx tmp = x; x = y; y = tmp;\n+\t  code = swap_condition (code);\n+\t}\n+      cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n+    }\n+  if ((mode == CC_FP_EQmode || mode == CC_FP_GTEmode\n+       || mode == CC_FP_ORDmode || mode == CC_FP_UNEQmode)\n+      /* mov<mode>cc might want to re-emit a comparison during ifcvt.  */\n+      && (!REG_P (x) || REGNO (x) != 0 || !REG_P (y) || REGNO (y) != 1))\n+    {\n+      rtx reg;\n+\n+      gcc_assert (currently_expanding_to_rtl);\n+      reg = gen_rtx_REG (in_mode, 0);\n+      gcc_assert (!reg_overlap_mentioned_p (reg, y));\n+      emit_move_insn (reg, x);\n+      x = reg;\n+      reg = gen_rtx_REG (in_mode, 1);\n+      emit_move_insn (reg, y);\n+      y = reg;\n+    }\n+  else\n+    x = force_reg (in_mode, x);\n+\n+  pat = gen_rtx_SET (VOIDmode, cc_reg, gen_rtx_COMPARE (mode, x, y));\n+  if (mode == CC_FP_EQmode || mode == CC_FP_GTEmode)\n+    {\n+      const char *name = mode == CC_FP_EQmode ? \"__eqsf2\" : \"__gtesf2\";\n+      rtx use = gen_rtx_USE (VOIDmode, sfunc_symbol (name));\n+\n+      clob0 = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, GPR_IP));\n+      clob1 = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, GPR_LR));\n+      pat = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (4, pat, use, clob0, clob1));\n+    }\n+  else if (mode == CC_FP_ORDmode || mode == CC_FP_UNEQmode)\n+    {\n+      const char *name = mode == CC_FP_ORDmode ? \"__ordsf2\" : \"__uneqsf2\";\n+      rtx use = gen_rtx_USE (VOIDmode, sfunc_symbol (name));\n+\n+      clob0 = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, GPR_IP));\n+      clob1 = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, GPR_16));\n+      clob2 = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, GPR_LR));\n+      pat = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (5, pat, use,\n+\t\t\t\t\t\t   clob0, clob1, clob2));\n+    }\n+  else\n+    {\n+      clob0 = gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (in_mode));\n+      pat = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, pat, clob0));\n+    }\n+  emit_insn (pat);\n+  return gen_rtx_fmt_ee (code, cmode, cc_reg, const0_rtx);\n+}\n+\f\n+/* The ROUND_ADVANCE* macros are local to this file.  */\n+/* Round SIZE up to a word boundary.  */\n+#define ROUND_ADVANCE(SIZE) \\\n+  (((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Round arg MODE/TYPE up to the next word boundary.  */\n+#define ROUND_ADVANCE_ARG(MODE, TYPE) \\\n+  ((MODE) == BLKmode \\\n+   ? ROUND_ADVANCE (int_size_in_bytes (TYPE)) \\\n+   : ROUND_ADVANCE (GET_MODE_SIZE (MODE)))\n+\n+/* Round CUM up to the necessary point for argument MODE/TYPE.  */\n+#define ROUND_ADVANCE_CUM(CUM, MODE, TYPE) \\\n+  (epiphany_function_arg_boundary ((MODE), (TYPE)) > BITS_PER_WORD \\\n+   ? (((CUM) + 1) & ~1)\t\\\n+   : (CUM))\n+\n+static unsigned int\n+epiphany_function_arg_boundary (enum machine_mode mode, const_tree type)\n+{\n+  if ((type ? TYPE_ALIGN (type) : GET_MODE_BITSIZE (mode)) <= PARM_BOUNDARY)\n+    return PARM_BOUNDARY;\n+  return 2 * PARM_BOUNDARY;\n+}\n+\n+/* Do any needed setup for a variadic function.  For the EPIPHANY, we\n+   actually emit the code in epiphany_expand_prologue.\n+\n+   CUM has not been updated for the last named argument which has type TYPE\n+   and mode MODE, and we rely on this fact.  */\n+\n+\n+static void\n+epiphany_setup_incoming_varargs (cumulative_args_t cum, enum machine_mode mode,\n+\t\t\t\t tree type, int *pretend_size, int no_rtl)\n+{\n+  int first_anon_arg;\n+  CUMULATIVE_ARGS next_cum;\n+  machine_function_t *mf = MACHINE_FUNCTION (cfun);\n+\n+  /* All BLKmode values are passed by reference.  */\n+  gcc_assert (mode != BLKmode);\n+\n+  next_cum = *get_cumulative_args (cum);\n+  next_cum\n+    = ROUND_ADVANCE_CUM (next_cum, mode, type) + ROUND_ADVANCE_ARG (mode, type);\n+  first_anon_arg = next_cum;\n+\n+  if (first_anon_arg < MAX_EPIPHANY_PARM_REGS && !no_rtl)\n+    {\n+      /* Note that first_reg_offset < MAX_EPIPHANY_PARM_REGS.  */\n+      int first_reg_offset = first_anon_arg;\n+\n+      *pretend_size = ((MAX_EPIPHANY_PARM_REGS - first_reg_offset)\n+\t\t       * UNITS_PER_WORD);\n+    }\n+  mf->args_parsed = 1;\n+  mf->pretend_args_odd = ((*pretend_size & UNITS_PER_WORD) ? 1 : 0);\n+}\n+\n+static int\n+epiphany_arg_partial_bytes (cumulative_args_t cum, enum machine_mode mode,\n+\t\t\t    tree type, bool named ATTRIBUTE_UNUSED)\n+{\n+  int words = 0, rounded_cum;\n+\n+  gcc_assert (!epiphany_pass_by_reference (cum, mode, type, /* named */ true));\n+\n+  rounded_cum = ROUND_ADVANCE_CUM (*get_cumulative_args (cum), mode, type);\n+  if (rounded_cum < MAX_EPIPHANY_PARM_REGS)\n+    {\n+      words = MAX_EPIPHANY_PARM_REGS - rounded_cum;\n+      if (words >= ROUND_ADVANCE_ARG (mode, type))\n+\twords = 0;\n+    }\n+  return words * UNITS_PER_WORD;\n+}\n+\f\n+/* Cost functions.  */\n+\n+/* Compute a (partial) cost for rtx X.  Return true if the complete\n+   cost has been computed, and false if subexpressions should be\n+   scanned.  In either case, *TOTAL contains the cost result.  */\n+\n+static bool\n+epiphany_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n+\t\t    int *total, bool speed ATTRIBUTE_UNUSED)\n+{\n+  switch (code)\n+    {\n+      /* Small integers in the right context are as cheap as registers.  */\n+    case CONST_INT:\n+      if ((outer_code == PLUS || outer_code == MINUS)\n+\t  && SIMM11 (INTVAL (x)))\n+\t{\n+\t  *total = 0;\n+\t  return true;\n+\t}\n+      if (IMM16 (INTVAL (x)))\n+\t{\n+\t  *total = outer_code == SET ? 0 : COSTS_N_INSNS (1);\n+\t  return true;\n+\t}\n+      /* FALLTHRU */\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      *total = COSTS_N_INSNS ((epiphany_small16 (x) ? 0 : 1)\n+\t\t\t      + (outer_code == SET ? 0 : 1));\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      {\n+\trtx high, low;\n+\tsplit_double (x, &high, &low);\n+\t*total = COSTS_N_INSNS (!IMM16 (INTVAL (high))\n+\t\t\t\t+ !IMM16 (INTVAL (low)));\n+\treturn true;\n+      }\n+\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+\n+/* Provide the costs of an addressing mode that contains ADDR.\n+   If ADDR is not a valid address, its cost is irrelevant.  */\n+\n+static int\n+epiphany_address_cost (rtx addr, bool speed)\n+{\n+  rtx reg;\n+  rtx off = const0_rtx;\n+  int i;\n+\n+  if (speed)\n+    return 0;\n+  /* Return 0 for addresses valid in short insns, 1 for addresses only valid\n+     in long insns.  */\n+  switch (GET_CODE (addr))\n+    {\n+    case PLUS :\n+      reg = XEXP (addr, 0);\n+      off = XEXP (addr, 1);\n+      break;\n+    case POST_MODIFY:\n+      reg = XEXP (addr, 0);\n+      off = XEXP (addr, 1);\n+      gcc_assert (GET_CODE (off) == PLUS && rtx_equal_p (reg, XEXP (off, 0)));\n+      off = XEXP (off, 1);\n+      if (satisfies_constraint_Rgs (reg) && satisfies_constraint_Rgs (off))\n+\treturn 0;\n+      return 1;\n+    case REG:\n+    default:\n+      reg = addr;\n+      break;\n+    }\n+  if (!satisfies_constraint_Rgs (reg))\n+    return 1;\n+  /* ??? We don't know the mode of the memory access.  We are going to assume\n+     SImode, unless lack of offset alignment indicates a smaller access.  */\n+  /* First, make sure we have a valid integer.  */\n+  if (!satisfies_constraint_L (off))\n+    return 1;\n+  i = INTVAL (off);\n+  if ((i & 1) == 0)\n+    i >>= 1;\n+  if ((i & 1) == 0)\n+    i >>= 1;\n+  if (i < -7 || i > 7)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Compute the cost of moving data between registers and memory.\n+   For integer, load latency is twice as long as register-register moves,\n+   but issue pich is the same.  For floating point, load latency is three\n+   times as much as a reg-reg move.  */\n+static int\n+epiphany_memory_move_cost (enum machine_mode mode,\n+                          reg_class_t rclass ATTRIBUTE_UNUSED,\n+                          bool in ATTRIBUTE_UNUSED)\n+{\n+  return GET_MODE_CLASS (mode) == MODE_INT ? 3 : 4;\n+}\n+\f\n+/* Function prologue/epilogue handlers.  */\n+\n+/* EPIPHANY stack frames look like:\n+\n+\t     Before call                       After call\n+\t+-----------------------+       +-----------------------+\n+\t|                       |       |                       |\n+   high |  local variables,     |       |  local variables,     |\n+   mem  |  reg save area, etc.  |       |  reg save area, etc.  |\n+\t|                       |       |                       |\n+\t+-----------------------+       +-----------------------+\n+\t|                       |       |                       |\n+\t|  arguments on stack.  |       |  arguments on stack.  |\n+\t|                       |       |                       |\n+  SP+8->+-----------------------+FP+8m->+-----------------------+\n+\t| 2 word save area for  |       |  reg parm save area,  |\n+\t| leaf funcs / flags    |       |  only created for     |\n+  SP+0->+-----------------------+       |  variable argument    |\n+\t\t\t\t\t|  functions            |\n+\t\t\t\t FP+8n->+-----------------------+\n+\t\t\t\t\t|                       |\n+\t\t\t\t\t|  register save area   |\n+\t\t\t\t\t|                       |\n+\t\t\t\t\t+-----------------------+\n+\t\t\t\t\t|                       |\n+\t\t\t\t\t|  local variables      |\n+\t\t\t\t\t|                       |\n+\t\t\t\t  FP+0->+-----------------------+\n+\t\t\t\t\t|                       |\n+\t\t\t\t\t|  alloca allocations   |\n+\t\t\t\t\t|                       |\n+\t\t\t\t\t+-----------------------+\n+\t\t\t\t\t|                       |\n+\t\t\t\t\t|  arguments on stack   |\n+\t\t\t\t\t|                       |\n+\t\t\t\t  SP+8->+-----------------------+\n+   low                                  | 2 word save area for  |\n+   memory                               | leaf funcs / flags    |\n+\t\t\t\t  SP+0->+-----------------------+\n+\n+Notes:\n+1) The \"reg parm save area\" does not exist for non variable argument fns.\n+   The \"reg parm save area\" could be eliminated if we created our\n+   own TARGET_GIMPLIFY_VA_ARG_EXPR, but that has tradeoffs as well\n+   (so it's not done).  */\n+\n+/* Structure to be filled in by epiphany_compute_frame_size with register\n+   save masks, and offsets for the current function.  */\n+struct epiphany_frame_info\n+{\n+  unsigned int total_size;\t/* # bytes that the entire frame takes up.  */\n+  unsigned int pretend_size;\t/* # bytes we push and pretend caller did.  */\n+  unsigned int args_size;\t/* # bytes that outgoing arguments take up.  */\n+  unsigned int reg_size;\t/* # bytes needed to store regs.  */\n+  unsigned int var_size;\t/* # bytes that variables take up.  */\n+  HARD_REG_SET gmask;\t\t/* Set of saved gp registers.  */\n+  int          initialized;\t/* Nonzero if frame size already calculated.  */\n+  int      stld_sz;             /* Current load/store data size for offset\n+\t\t\t\t   adjustment. */\n+  int      need_fp;             /* value to override \"frame_pointer_needed */\n+  int first_slot, last_slot, first_slot_offset, last_slot_offset;\n+  int first_slot_size;\n+  int small_threshold;\n+};\n+\n+/* Current frame information calculated by epiphany_compute_frame_size.  */\n+static struct epiphany_frame_info current_frame_info;\n+\n+/* Zero structure to initialize current_frame_info.  */\n+static struct epiphany_frame_info zero_frame_info;\n+\n+/* The usual; we set up our machine_function data.  */\n+static struct machine_function *\n+epiphany_init_machine_status (void)\n+{\n+  struct machine_function *machine;\n+\n+  /* Reset state info for each function.  */\n+  current_frame_info = zero_frame_info;\n+\n+  machine = ggc_alloc_cleared_machine_function_t ();\n+\n+  return machine;\n+}\n+\n+/* Implements INIT_EXPANDERS.  We just set up to call the above\n+ *    function.  */\n+void\n+epiphany_init_expanders (void)\n+{\n+  init_machine_status = epiphany_init_machine_status;\n+}\n+\n+/* Type of function DECL.\n+\n+   The result is cached.  To reset the cache at the end of a function,\n+   call with DECL = NULL_TREE.  */\n+\n+static enum epiphany_function_type\n+epiphany_compute_function_type (tree decl)\n+{\n+  tree a;\n+  /* Cached value.  */\n+  static enum epiphany_function_type fn_type = EPIPHANY_FUNCTION_UNKNOWN;\n+  /* Last function we were called for.  */\n+  static tree last_fn = NULL_TREE;\n+\n+  /* Resetting the cached value?  */\n+  if (decl == NULL_TREE)\n+    {\n+      fn_type = EPIPHANY_FUNCTION_UNKNOWN;\n+      last_fn = NULL_TREE;\n+      return fn_type;\n+    }\n+\n+  if (decl == last_fn && fn_type != EPIPHANY_FUNCTION_UNKNOWN)\n+    return fn_type;\n+\n+  /* Assume we have a normal function (not an interrupt handler).  */\n+  fn_type = EPIPHANY_FUNCTION_NORMAL;\n+\n+  /* Now see if this is an interrupt handler.  */\n+  for (a = DECL_ATTRIBUTES (decl);\n+       a;\n+       a = TREE_CHAIN (a))\n+    {\n+      tree name = TREE_PURPOSE (a), args = TREE_VALUE (a);\n+\n+      if (name == get_identifier (\"interrupt\")\n+\t  && list_length (args) == 1\n+\t  && TREE_CODE (TREE_VALUE (args)) == STRING_CST)\n+\t{\n+\t  tree value = TREE_VALUE (args);\n+\n+\t  if (!strcmp (TREE_STRING_POINTER (value), \"reset\"))\n+\t    fn_type = EPIPHANY_FUNCTION_RESET;\n+\t  else if (!strcmp (TREE_STRING_POINTER (value), \"software_exception\"))\n+\t    fn_type = EPIPHANY_FUNCTION_SOFTWARE_EXCEPTION;\n+\t  else if (!strcmp (TREE_STRING_POINTER (value), \"timer\"))\n+\t    fn_type = EPIPHANY_FUNCTION_TIMER;\n+\t  else if (!strcmp (TREE_STRING_POINTER (value), \"dma0\"))\n+\t    fn_type = EPIPHANY_FUNCTION_DMA0;\n+\t  else if (!strcmp (TREE_STRING_POINTER (value), \"dma1\"))\n+\t    fn_type = EPIPHANY_FUNCTION_DMA1;\n+\t  else if (!strcmp (TREE_STRING_POINTER (value), \"static_flag\"))\n+\t    fn_type = EPIPHANY_FUNCTION_STATIC_FLAG;\n+\t  else if (!strcmp (TREE_STRING_POINTER (value), \"swi\"))\n+\t    fn_type = EPIPHANY_FUNCTION_SWI;\n+\t  else\n+\t    gcc_unreachable ();\n+\t  break;\n+\t}\n+    }\n+\n+  last_fn = decl;\n+  return fn_type;\n+}\n+\n+#define RETURN_ADDR_REGNUM GPR_LR\n+#define FRAME_POINTER_MASK (1 << (FRAME_POINTER_REGNUM))\n+#define RETURN_ADDR_MASK (1 << (RETURN_ADDR_REGNUM))\n+\n+/* Tell prologue and epilogue if register REGNO should be saved / restored.\n+   The return address and frame pointer are treated separately.\n+   Don't consider them here.  */\n+#define MUST_SAVE_REGISTER(regno, interrupt_p) \\\n+  ((df_regs_ever_live_p (regno) \\\n+    || (interrupt_p && !current_function_is_leaf \\\n+\t&& call_used_regs[regno] && !fixed_regs[regno])) \\\n+   && (!call_used_regs[regno] || regno == GPR_LR \\\n+       || (interrupt_p && regno != GPR_SP)))\n+\n+#define MUST_SAVE_RETURN_ADDR 0\n+\n+/* Return the bytes needed to compute the frame pointer from the current\n+   stack pointer.\n+\n+   SIZE is the size needed for local variables.  */\n+\n+static unsigned int\n+epiphany_compute_frame_size (int size /* # of var. bytes allocated.  */)\n+{\n+  int regno;\n+  unsigned int total_size, var_size, args_size, pretend_size, reg_size;\n+  HARD_REG_SET gmask;\n+  enum epiphany_function_type fn_type;\n+  int interrupt_p;\n+  int first_slot, last_slot, first_slot_offset, last_slot_offset;\n+  int first_slot_size;\n+  int small_slots = 0;\n+  long lr_slot_offset;\n+\n+  var_size\t= size;\n+  args_size\t= crtl->outgoing_args_size;\n+  pretend_size\t= crtl->args.pretend_args_size;\n+  total_size\t= args_size + var_size;\n+  reg_size\t= 0;\n+  CLEAR_HARD_REG_SET (gmask);\n+  first_slot = -1;\n+  first_slot_offset = 0;\n+  last_slot = -1;\n+  last_slot_offset = 0;\n+  first_slot_size = UNITS_PER_WORD;\n+\n+  /* See if this is an interrupt handler.  Call used registers must be saved\n+     for them too.  */\n+  fn_type = epiphany_compute_function_type (current_function_decl);\n+  interrupt_p = EPIPHANY_INTERRUPT_P (fn_type);\n+\n+  /* Calculate space needed for registers.  */\n+\n+  for (regno = MAX_EPIPHANY_PARM_REGS - 1; pretend_size > reg_size; regno--)\n+    {\n+      reg_size += UNITS_PER_WORD;\n+      SET_HARD_REG_BIT (gmask, regno);\n+      if (epiphany_stack_offset - reg_size == 0)\n+\tfirst_slot = regno;\n+    }\n+\n+  if (interrupt_p)\n+    reg_size += 2 * UNITS_PER_WORD;\n+  else\n+    small_slots = epiphany_stack_offset / UNITS_PER_WORD;\n+\n+  if (frame_pointer_needed)\n+    {\n+      current_frame_info.need_fp = 1;\n+      if (!interrupt_p && first_slot < 0)\n+\tfirst_slot = GPR_FP;\n+    }\n+  else\n+    current_frame_info.need_fp = 0;\n+  for (regno = 0; regno <= GPR_LAST; regno++)\n+    {\n+      if (MUST_SAVE_REGISTER (regno, interrupt_p))\n+\t{\n+\t  gcc_assert (!TEST_HARD_REG_BIT (gmask, regno));\n+\t  reg_size += UNITS_PER_WORD;\n+\t  SET_HARD_REG_BIT (gmask, regno);\n+\t  /* FIXME: when optimizing for speed, take schedling into account\n+\t     when selecting these registers.  */\n+\t  if (regno == first_slot)\n+\t    gcc_assert (regno == GPR_FP && frame_pointer_needed);\n+\t  else if (!interrupt_p && first_slot < 0)\n+\t    first_slot = regno;\n+\t  else if (last_slot < 0\n+\t\t   && (first_slot ^ regno) != 1\n+\t\t   && (!interrupt_p || regno > GPR_0 + 1))\n+\t    last_slot = regno;\n+\t}\n+    }\n+  if (TEST_HARD_REG_BIT (gmask, GPR_LR))\n+    MACHINE_FUNCTION (cfun)->lr_clobbered = 1;\n+  /* ??? Could sometimes do better than that.  */\n+  current_frame_info.small_threshold\n+    = (optimize >= 3 || interrupt_p ? 0\n+       : pretend_size ? small_slots\n+       : 4 + small_slots - (first_slot == GPR_FP));\n+\n+  /* If there might be variables with 64-bit alignment requirement, align the\n+     start of the variables.  */\n+  if (var_size >= 2 * UNITS_PER_WORD\n+      /* We don't want to split a double reg save/restore across two unpaired\n+\t stack slots when optimizing.  This rounding could be avoided with\n+\t more complex reordering of the register saves, but that would seem\n+\t to be a lot of code complexity for little gain.  */\n+      || (reg_size > 8 && optimize))\n+    reg_size = EPIPHANY_STACK_ALIGN (reg_size);\n+  if (total_size + reg_size <= (unsigned) epiphany_stack_offset\n+      && !interrupt_p\n+      && current_function_is_leaf && !frame_pointer_needed)\n+    {\n+      first_slot = -1;\n+      last_slot = -1;\n+      goto alloc_done;\n+    }\n+  else if (reg_size\n+\t   && !interrupt_p\n+\t   && reg_size < (unsigned HOST_WIDE_INT) epiphany_stack_offset)\n+    reg_size = epiphany_stack_offset;\n+  if (interrupt_p)\n+    {\n+      if (total_size + reg_size < 0x3fc)\n+\t{\n+\t  first_slot_offset = EPIPHANY_STACK_ALIGN (total_size + reg_size);\n+\t  first_slot_offset += EPIPHANY_STACK_ALIGN (epiphany_stack_offset);\n+\t  last_slot = -1;\n+\t}\n+      else\n+\t{\n+\t  first_slot_offset = EPIPHANY_STACK_ALIGN (reg_size);\n+\t  last_slot_offset = EPIPHANY_STACK_ALIGN (total_size);\n+\t  last_slot_offset += EPIPHANY_STACK_ALIGN (epiphany_stack_offset);\n+\t  if (last_slot >= 0)\n+\t    CLEAR_HARD_REG_BIT (gmask, last_slot);\n+\t}\n+    }\n+  else if (total_size + reg_size < 0x1ffc && first_slot >= 0)\n+    {\n+      first_slot_offset = EPIPHANY_STACK_ALIGN (total_size + reg_size);\n+      last_slot = -1;\n+    }\n+  else\n+    {\n+      if (total_size + reg_size <= (unsigned) epiphany_stack_offset)\n+\t{\n+\t  gcc_assert (first_slot < 0);\n+\t  gcc_assert (reg_size == 0);\n+\t  last_slot_offset = EPIPHANY_STACK_ALIGN (total_size + reg_size);\n+\t}\n+      else\n+\t{\n+\t  first_slot_offset\n+\t    = (reg_size\n+\t       ? EPIPHANY_STACK_ALIGN (reg_size - epiphany_stack_offset) : 0);\n+\t  if (!first_slot_offset)\n+\t    {\n+\t      if (first_slot != GPR_FP || !current_frame_info.need_fp)\n+\t\tlast_slot = first_slot;\n+\t      first_slot = -1;\n+\t    }\n+\t  last_slot_offset = EPIPHANY_STACK_ALIGN (total_size);\n+\t  if (reg_size)\n+\t    last_slot_offset += EPIPHANY_STACK_ALIGN (epiphany_stack_offset);\n+\t}\n+      if (last_slot >= 0)\n+\tCLEAR_HARD_REG_BIT (gmask, last_slot);\n+    }\n+ alloc_done:\n+  if (first_slot >= 0)\n+    {\n+      CLEAR_HARD_REG_BIT (gmask, first_slot);\n+      if (TEST_HARD_REG_BIT (gmask, first_slot ^ 1)\n+\t  && epiphany_stack_offset - pretend_size >= 2 * UNITS_PER_WORD)\n+\t{\n+\t  CLEAR_HARD_REG_BIT (gmask, first_slot ^ 1);\n+\t  first_slot_size = 2 * UNITS_PER_WORD;\n+\t  first_slot &= ~1;\n+\t}\n+    }\n+  total_size = first_slot_offset + last_slot_offset;\n+\n+  lr_slot_offset\n+    = (frame_pointer_needed ? first_slot_offset : (long) total_size);\n+  if (first_slot != GPR_LR)\n+    {\n+      int stack_offset = epiphany_stack_offset - UNITS_PER_WORD;\n+\n+      for (regno = 0; ; regno++)\n+\t{\n+\t  if (stack_offset + UNITS_PER_WORD - first_slot_size == 0\n+\t      && first_slot >= 0)\n+\t    {\n+\t      stack_offset -= first_slot_size;\n+\t      regno--;\n+\t    }\n+\t  else if (regno == GPR_LR)\n+\t    break;\n+\t  else if TEST_HARD_REG_BIT (gmask, regno)\n+\t    stack_offset -= UNITS_PER_WORD;\n+\t}\n+      lr_slot_offset += stack_offset;\n+    }\n+\n+  /* Save computed information.  */\n+  current_frame_info.total_size   = total_size;\n+  current_frame_info.pretend_size = pretend_size;\n+  current_frame_info.var_size     = var_size;\n+  current_frame_info.args_size    = args_size;\n+  current_frame_info.reg_size\t  = reg_size;\n+  COPY_HARD_REG_SET (current_frame_info.gmask, gmask);\n+  current_frame_info.first_slot\t\t= first_slot;\n+  current_frame_info.last_slot\t\t= last_slot;\n+  current_frame_info.first_slot_offset\t= first_slot_offset;\n+  current_frame_info.first_slot_size\t= first_slot_size;\n+  current_frame_info.last_slot_offset\t= last_slot_offset;\n+  MACHINE_FUNCTION (cfun)->lr_slot_offset = lr_slot_offset;\n+\n+  current_frame_info.initialized  = reload_completed;\n+\n+  /* Ok, we're done.  */\n+  return total_size;\n+}\n+\f\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+\n+static void\n+epiphany_print_operand (FILE *file, rtx x, int code)\n+{\n+  switch (code)\n+    {\n+    case 'd':\n+      fputs (epiphany_condition_codes[get_epiphany_condition_code (x)], file);\n+      return;\n+    case 'D':\n+     fputs (epiphany_condition_codes[EPIPHANY_INVERSE_CONDITION_CODE\n+\t\t\t\t (get_epiphany_condition_code (x))],\n+\t     file);\n+      return;\n+\n+    case 'X':\n+      current_frame_info.stld_sz = 8;\n+      break;\n+\n+    case 'C' :\n+      current_frame_info.stld_sz = 4;\n+      break;\n+\n+    case 'c' :\n+      current_frame_info.stld_sz = 2;\n+      break;\n+\n+    case 'f':\n+     fputs (REG_P (x) ? \"jalr \" : \"bl \", file);\n+     break;\n+\n+    case '-':\n+    fprintf (file, \"r%d\", epiphany_m1reg);\n+    return;\n+\n+    case 0 :\n+      /* Do nothing special.  */\n+      break;\n+    default :\n+      /* Unknown flag.  */\n+      output_operand_lossage (\"invalid operand output code\");\n+    }\n+\n+  switch (GET_CODE (x))\n+    {\n+      rtx addr;\n+      rtx offset;\n+\n+    case REG :\n+      fputs (reg_names[REGNO (x)], file);\n+      break;\n+    case MEM :\n+      if (code == 0)\n+\tcurrent_frame_info.stld_sz = 1;\n+      fputc ('[', file);\n+      addr = XEXP (x, 0);\n+      switch (GET_CODE (addr))\n+\t{\n+\t  case POST_INC:\n+\t    offset = GEN_INT (GET_MODE_SIZE (GET_MODE (x)));\n+\t    addr = XEXP (addr, 0);\n+\t    break;\n+\t  case POST_DEC:\n+\t    offset = GEN_INT (-GET_MODE_SIZE (GET_MODE (x)));\n+\t    addr = XEXP (addr, 0);\n+\t    break;\n+\t  case POST_MODIFY:\n+\t    offset = XEXP (XEXP (addr, 1), 1);\n+\t    addr = XEXP (addr, 0);\n+\t    break;\n+\t  default:\n+\t    offset = 0;\n+\t    break;\n+\t}\n+      output_address (addr);\n+      fputc (']', file);\n+      if (offset)\n+\t{\n+\t  fputc (',', file);\n+\t  if (CONST_INT_P (offset)) switch (GET_MODE_SIZE (GET_MODE (x)))\n+\t    {\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      case 8:\n+\t\toffset = GEN_INT (INTVAL (offset) >> 3);\n+\t\tbreak;\n+\t      case 4:\n+\t\toffset = GEN_INT (INTVAL (offset) >> 2);\n+\t\tbreak;\n+\t      case 2:\n+\t\toffset = GEN_INT (INTVAL (offset) >> 1);\n+\t\tbreak;\n+\t      case 1:\n+\t\tbreak;\n+\t    }\n+\t  output_address (offset);\n+\t}\n+      break;\n+    case CONST_DOUBLE :\n+      /* We handle SFmode constants here as output_addr_const doesn't.  */\n+      if (GET_MODE (x) == SFmode)\n+\t{\n+\t  REAL_VALUE_TYPE d;\n+\t  long l;\n+\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (d, x);\n+\t  REAL_VALUE_TO_TARGET_SINGLE (d, l);\n+\t  fprintf (file, \"%s0x%08lx\", IMMEDIATE_PREFIX, l);\n+\t  break;\n+\t}\n+      /* Fall through.  Let output_addr_const deal with it.  */\n+    case CONST_INT:\n+      fprintf(file,\"%s\",IMMEDIATE_PREFIX);\n+      if (code == 'C' || code == 'X')\n+\t{\n+\t  fprintf (file, \"%ld\",\n+\t\t   (long) (INTVAL (x) / current_frame_info.stld_sz));\n+\t  break;\n+\t}\n+      /* Fall through */\n+    default :\n+      output_addr_const (file, x);\n+      break;\n+    }\n+}\n+\n+/* Print a memory address as an operand to reference that memory location.  */\n+\n+static void\n+epiphany_print_operand_address (FILE *file, rtx addr)\n+{\n+  register rtx base, index = 0;\n+  int offset = 0;\n+\n+  switch (GET_CODE (addr))\n+    {\n+    case REG :\n+      fputs (reg_names[REGNO (addr)], file);\n+      break;\n+    case SYMBOL_REF :\n+      if (/*???*/ 0 && SYMBOL_REF_FUNCTION_P (addr))\n+\t{\n+\t  output_addr_const (file, addr);\n+\t}\n+      else\n+\t{\n+\t  output_addr_const (file, addr);\n+\t}\n+      break;\n+    case PLUS :\n+      if (GET_CODE (XEXP (addr, 0)) == CONST_INT)\n+\toffset = INTVAL (XEXP (addr, 0)), base = XEXP (addr, 1);\n+      else if (GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+\toffset = INTVAL (XEXP (addr, 1)), base = XEXP (addr, 0);\n+      else\n+\tbase = XEXP (addr, 0), index = XEXP (addr, 1);\n+      gcc_assert (GET_CODE (base) == REG);\n+      fputs (reg_names[REGNO (base)], file);\n+      if (index == 0)\n+\t{\n+\t  /*\n+\t  ** ++rk quirky method to scale offset for ld/str.......\n+\t  */\n+\t  fprintf (file, \",%s%d\", IMMEDIATE_PREFIX,\n+\t\t   offset/current_frame_info.stld_sz);\n+\t}\n+      else\n+\t{\n+\t  switch (GET_CODE (index))\n+\t    {\n+\t    case REG:\n+\t      fprintf (file, \",%s\", reg_names[REGNO (index)]);\n+\t      break;\n+\t    case SYMBOL_REF:\n+\t      fputc (',', file), output_addr_const (file, index);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+      break;\n+    case PRE_INC: case PRE_DEC: case POST_INC: case POST_DEC: case POST_MODIFY:\n+      /* We shouldn't get here as we've lost the mode of the memory object\n+\t (which says how much to inc/dec by.  */\n+      gcc_unreachable ();\n+      break;\n+    default:\n+      output_addr_const (file, addr);\n+      break;\n+    }\n+}\n+\n+void\n+epiphany_final_prescan_insn (rtx insn ATTRIBUTE_UNUSED,\n+\t\t\t     rtx *opvec ATTRIBUTE_UNUSED,\n+\t\t\t     int noperands ATTRIBUTE_UNUSED)\n+{\n+  int i = epiphany_n_nops;\n+  rtx pat ATTRIBUTE_UNUSED;\n+\n+  while (i--)\n+    fputs (\"\\tnop\\n\", asm_out_file);\n+}\n+\n+\f\n+/* Worker function for TARGET_RETURN_IN_MEMORY.  */\n+\n+static bool\n+epiphany_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n+{\n+  HOST_WIDE_INT size = int_size_in_bytes (type);\n+\n+  if (AGGREGATE_TYPE_P (type)\n+      && (TYPE_MODE (type) == BLKmode || TYPE_NEEDS_CONSTRUCTING (type)))\n+    return true;\n+  return (size == -1 || size > 8);\n+}\n+\n+/* For EPIPHANY, All aggregates and arguments greater than 8 bytes are\n+   passed by reference.  */\n+\n+static bool\n+epiphany_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n+\t\t       enum machine_mode mode, const_tree type,\n+\t\t       bool named ATTRIBUTE_UNUSED)\n+{\n+  if (type)\n+    {\n+      if (AGGREGATE_TYPE_P (type)\n+\t  && (mode == BLKmode || TYPE_NEEDS_CONSTRUCTING (type)))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+\n+static rtx\n+epiphany_function_value (const_tree ret_type,\n+\t\t\t const_tree fn_decl_or_type ATTRIBUTE_UNUSED,\n+\t\t\t bool outgoing ATTRIBUTE_UNUSED)\n+{\n+  enum machine_mode mode;\n+\n+  mode = TYPE_MODE (ret_type);\n+  /* We must change the mode like PROMOTE_MODE does.\n+     ??? PROMOTE_MODE is ignored for non-scalar types.\n+     The set of types tested here has to be kept in sync\n+     with the one in explow.c:promote_mode.  */\n+  if (GET_MODE_CLASS (mode) == MODE_INT\n+      && GET_MODE_SIZE (mode) < 4\n+      && (TREE_CODE (ret_type) == INTEGER_TYPE\n+          || TREE_CODE (ret_type) == ENUMERAL_TYPE\n+          || TREE_CODE (ret_type) == BOOLEAN_TYPE\n+          || TREE_CODE (ret_type) == OFFSET_TYPE))\n+    mode = SImode;\n+  return gen_rtx_REG (mode, 0);\n+}\n+\n+static rtx\n+epiphany_libcall_value (enum machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n+{\n+  return gen_rtx_REG (mode, 0);\n+}\n+\n+bool\n+epiphany_function_value_regno_p (const unsigned int regno ATTRIBUTE_UNUSED)\n+{\n+  return regno == 0;\n+}\n+\n+/* Fix up invalid option settings.  */\n+static void\n+epiphany_override_options (void)\n+{\n+  if (epiphany_stack_offset < 4)\n+    error (\"stack_offset must be at least 4\");\n+  if (epiphany_stack_offset & 3)\n+    error (\"stack_offset must be a multiple of 4\");\n+  epiphany_stack_offset = (epiphany_stack_offset + 3) & -4;\n+\n+  /* This needs to be done at start up.  It's convenient to do it here.  */\n+  epiphany_init ();\n+}\n+\n+/* For a DImode load / store SET, make a SImode set for a\n+   REG_FRAME_RELATED_EXPR note, using OFFSET to create a high or lowpart\n+   subreg.  */\n+static rtx\n+frame_subreg_note (rtx set, int offset)\n+{\n+  rtx src = simplify_gen_subreg (SImode, SET_SRC (set), DImode, offset);\n+  rtx dst = simplify_gen_subreg (SImode, SET_DEST (set), DImode, offset);\n+\n+  set = gen_rtx_SET (VOIDmode, dst ,src);\n+  RTX_FRAME_RELATED_P (set) = 1;\n+  return set;\n+}\n+\n+static rtx\n+frame_insn (rtx x)\n+{\n+  int i;\n+  rtx note = NULL_RTX;\n+\n+  if (GET_CODE (x) == PARALLEL)\n+    {\n+      rtx part = XVECEXP (x, 0, 0);\n+\n+      if (GET_MODE (SET_DEST (part)) == DImode)\n+\t{\n+\t  note = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (XVECLEN (x, 0) + 1));\n+\t  XVECEXP (note, 0, 0) = frame_subreg_note (part, 0);\n+\t  XVECEXP (note, 0, 1) = frame_subreg_note (part, UNITS_PER_WORD);\n+\t  for (i = XVECLEN (x, 0) - 1; i >= 1; i--)\n+\t    {\n+\t      part = copy_rtx (XVECEXP (x, 0, i));\n+\n+\t      if (GET_CODE (part) == SET)\n+\t\tRTX_FRAME_RELATED_P (part) = 1;\n+\t      XVECEXP (note, 0, i + 1) = part;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n+\t    {\n+\t      part = XVECEXP (x, 0, i);\n+\n+\t      if (GET_CODE (part) == SET)\n+\t\tRTX_FRAME_RELATED_P (part) = 1;\n+\t    }\n+\t}\n+    }\n+  else if (GET_CODE (x) == SET && GET_MODE (SET_DEST (x)) == DImode)\n+    note = gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t     gen_rtvec (2, frame_subreg_note (x, 0),\n+\t\t\t\t\tframe_subreg_note (x, UNITS_PER_WORD)));\n+  x = emit_insn (x);\n+  RTX_FRAME_RELATED_P (x) = 1;\n+  if (note)\n+    add_reg_note (x, REG_FRAME_RELATED_EXPR, note);\n+  return x;\n+}\n+\n+static rtx\n+frame_move_insn (rtx to, rtx from)\n+{\n+  return frame_insn (gen_rtx_SET (VOIDmode, to, from));\n+}\n+\n+/* Generate a MEM referring to a varargs argument slot.  */\n+\n+static rtx\n+gen_varargs_mem (enum machine_mode mode, rtx addr)\n+{\n+  rtx mem = gen_rtx_MEM (mode, addr);\n+  MEM_NOTRAP_P (mem) = 1;\n+  set_mem_alias_set (mem, get_varargs_alias_set ());\n+  return mem;\n+}\n+\n+/* Emit instructions to save or restore registers in the range [MIN..LIMIT) .\n+   If EPILOGUE_P is 0, save; if it is one, restore.\n+   ADDR is the stack slot to save the first register to; subsequent\n+   registers are written to lower addresses.\n+   However, the order of register pairs can be reversed in order to\n+   use double-word load-store instructions.  Likewise, an unpaired single\n+   word save slot can be skipped while double saves are carried out, and\n+   reused when a single register is to be saved.  */\n+\n+static void\n+epiphany_emit_save_restore (int min, int limit, rtx addr, int epilogue_p)\n+{\n+  int i;\n+  int stack_offset\n+    = current_frame_info.first_slot >= 0 ? epiphany_stack_offset : 0;\n+  rtx skipped_mem = NULL_RTX;\n+  int last_saved = limit - 1;\n+\n+  if (!optimize)\n+    while (last_saved >= 0\n+\t   && !TEST_HARD_REG_BIT (current_frame_info.gmask, last_saved))\n+      last_saved--;\n+  for (i = 0; i < limit; i++)\n+    {\n+      enum machine_mode mode = word_mode;\n+      rtx mem, reg;\n+      int n = i;\n+      rtx (*gen_mem) (enum machine_mode, rtx) = gen_frame_mem;\n+\n+      /* Make sure we push the arguments in the right order.  */\n+      if (n < MAX_EPIPHANY_PARM_REGS && crtl->args.pretend_args_size)\n+\t{\n+\t  n = MAX_EPIPHANY_PARM_REGS - 1 - n;\n+\t  gen_mem = gen_varargs_mem;\n+\t}\n+      if (stack_offset == current_frame_info.first_slot_size\n+\t  && current_frame_info.first_slot >= 0)\n+\t{\n+\t  if (current_frame_info.first_slot_size > UNITS_PER_WORD)\n+\t    {\n+\t      mode = DImode;\n+\t      addr = plus_constant (addr, - (HOST_WIDE_INT) UNITS_PER_WORD);\n+\t    }\n+\t  if (i-- < min || !epilogue_p)\n+\t    goto next_slot;\n+\t  n = current_frame_info.first_slot;\n+\t  gen_mem = gen_frame_mem;\n+\t}\n+      else if (n == UNKNOWN_REGNUM\n+\t       && stack_offset > current_frame_info.first_slot_size)\n+\t{\n+\t  i--;\n+\t  goto next_slot;\n+\t}\n+      else if (!TEST_HARD_REG_BIT (current_frame_info.gmask, n))\n+\tcontinue;\n+      else if (i < min)\n+\tgoto next_slot;\n+\n+      /* Check for a register pair to save.  */\n+      if (n == i\n+\t  && (n >= MAX_EPIPHANY_PARM_REGS || crtl->args.pretend_args_size == 0)\n+\t  && (n & 1) == 0 && n+1 < limit\n+\t  && TEST_HARD_REG_BIT (current_frame_info.gmask, n+1))\n+\t{\n+\t  /* If it fits in the current stack slot pair, place it there.  */\n+\t  if (GET_CODE (addr) == PLUS && (stack_offset & 7) == 0\n+\t      && stack_offset != 2 * UNITS_PER_WORD\n+\t      && (current_frame_info.last_slot < 0\n+\t\t  || INTVAL (XEXP (addr, 1)) != UNITS_PER_WORD)\n+\t      && (n+1 != last_saved || !skipped_mem))\n+\t    {\n+\t      mode = DImode;\n+\t      i++;\n+\t      addr = plus_constant (addr, - (HOST_WIDE_INT) UNITS_PER_WORD);\n+\t    }\n+\t  /* If it fits in the following stack slot pair, that's fine, too.  */\n+\t  else if (GET_CODE (addr) == PLUS && (stack_offset & 7) == 4\n+\t\t   && stack_offset != 2 * UNITS_PER_WORD\n+\t\t   && stack_offset != 3 * UNITS_PER_WORD\n+\t\t   && (current_frame_info.last_slot < 0\n+\t\t       || INTVAL (XEXP (addr, 1)) != 2 * UNITS_PER_WORD)\n+\t\t   && n + 1 != last_saved)\n+\t    {\n+\t      gcc_assert (!skipped_mem);\n+\t      stack_offset -= GET_MODE_SIZE (mode);\n+\t      skipped_mem = gen_mem (mode, addr);\n+\t      mode = DImode;\n+\t      i++;\n+\t      addr = plus_constant (addr, - (HOST_WIDE_INT) 2 * UNITS_PER_WORD);\n+\t    }\n+\t}\n+      reg = gen_rtx_REG (mode, n);\n+      if (mode != DImode && skipped_mem)\n+\tmem = skipped_mem;\n+      else\n+\tmem = gen_mem (mode, addr);\n+      if (!epilogue_p)\n+\tframe_move_insn (mem, reg);\n+      else if (n >= MAX_EPIPHANY_PARM_REGS || !crtl->args.pretend_args_size)\n+\temit_move_insn (reg, mem);\n+      if (mem == skipped_mem)\n+\t{\n+\t  skipped_mem = NULL_RTX;\n+\t  continue;\n+\t}\n+    next_slot:\n+      addr = plus_constant (addr, - (HOST_WIDE_INT) UNITS_PER_WORD);\n+      stack_offset -= GET_MODE_SIZE (mode);\n+    }\n+}\n+\n+void\n+epiphany_expand_prologue (void)\n+{\n+  int interrupt_p;\n+  enum epiphany_function_type fn_type;\n+  rtx addr, mem, off, reg;\n+  rtx save_config;\n+\n+  if (!current_frame_info.initialized)\n+    epiphany_compute_frame_size (get_frame_size ());\n+\n+  /* It is debatable if we should adjust this by epiphany_stack_offset.  */\n+  if (flag_stack_usage_info)\n+    current_function_static_stack_size = current_frame_info.total_size;\n+\n+  fn_type = epiphany_compute_function_type (current_function_decl);\n+  interrupt_p = EPIPHANY_INTERRUPT_P (fn_type);\n+\n+  if (interrupt_p)\n+    {\n+      addr = plus_constant (stack_pointer_rtx,\n+\t\t\t    - (HOST_WIDE_INT) 2 * UNITS_PER_WORD);\n+      frame_move_insn (gen_frame_mem (DImode, addr),\n+\t\t       gen_rtx_REG (DImode, GPR_0));\n+      frame_move_insn (gen_rtx_REG (SImode, GPR_0),\n+\t\t       gen_rtx_REG (word_mode, STATUS_REGNUM));\n+      frame_move_insn (gen_rtx_REG (SImode, GPR_0+1),\n+\t\t       gen_rtx_REG (word_mode, IRET_REGNUM));\n+      mem = gen_frame_mem (BLKmode, stack_pointer_rtx);\n+      off = GEN_INT (-current_frame_info.first_slot_offset);\n+      frame_insn (gen_stack_adjust_add (off, mem));\n+      if (!epiphany_uninterruptible_p (current_function_decl))\n+\temit_insn (gen_gie ());\n+      addr = plus_constant (stack_pointer_rtx,\n+\t\t\t    current_frame_info.first_slot_offset\n+\t\t\t    - (HOST_WIDE_INT) 3 * UNITS_PER_WORD);\n+    }\n+  else\n+    {\n+      addr = plus_constant (stack_pointer_rtx,\n+\t\t\t    epiphany_stack_offset\n+\t\t\t    - (HOST_WIDE_INT) UNITS_PER_WORD);\n+      epiphany_emit_save_restore (0, current_frame_info.small_threshold,\n+\t\t\t\t  addr, 0);\n+      /* Allocate register save area; for small to medium size frames,\n+\t allocate the entire frame; this is joint with one register save.  */\n+      if (current_frame_info.first_slot >= 0)\n+\t{\n+\t  enum machine_mode mode\n+\t= (current_frame_info.first_slot_size == UNITS_PER_WORD\n+\t   ? word_mode : DImode);\n+\n+\t  off = GEN_INT (-current_frame_info.first_slot_offset);\n+\t  mem = gen_frame_mem (BLKmode,\n+\t\t\t       gen_rtx_PLUS (Pmode, stack_pointer_rtx, off));\n+\t  frame_insn (gen_stack_adjust_str\n+\t\t       (gen_frame_mem (mode, stack_pointer_rtx),\n+\t\t\tgen_rtx_REG (mode, current_frame_info.first_slot),\n+\t\t\toff, mem));\n+\t  addr = plus_constant (addr, current_frame_info.first_slot_offset);\n+\t}\n+    }\n+  epiphany_emit_save_restore (current_frame_info.small_threshold,\n+\t\t\t      FIRST_PSEUDO_REGISTER, addr, 0);\n+  if (current_frame_info.need_fp)\n+    frame_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n+  /* For large frames, allocate bulk of frame.  This is usually joint with one\n+     register save.  */\n+  if (current_frame_info.last_slot >= 0)\n+    {\n+      gcc_assert (current_frame_info.last_slot != GPR_FP\n+\t\t  || (!current_frame_info.need_fp\n+\t\t      && current_frame_info.first_slot < 0));\n+      off = GEN_INT (-current_frame_info.last_slot_offset);\n+      mem = gen_frame_mem (BLKmode,\n+\t\t\t   gen_rtx_PLUS (Pmode, stack_pointer_rtx, off));\n+      reg = gen_rtx_REG (Pmode, GPR_IP);\n+      frame_move_insn (reg, off);\n+      frame_insn (gen_stack_adjust_str\n+\t\t   (gen_frame_mem (word_mode, stack_pointer_rtx),\n+\t\t    gen_rtx_REG (word_mode, current_frame_info.last_slot),\n+\t\t    reg, mem));\n+    }\n+  /* If there is only one or no register to save, yet we have a large frame,\n+     use an add.  */\n+  else if (current_frame_info.last_slot_offset)\n+    {\n+      mem = gen_frame_mem (BLKmode,\n+\t\t\t   plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t  current_frame_info.last_slot_offset));\n+      off = GEN_INT (-current_frame_info.last_slot_offset);\n+      if (!SIMM11 (INTVAL (off)))\n+\t{\n+\t  reg = gen_rtx_REG (Pmode, GPR_IP);\n+\t  frame_move_insn (reg, off);\n+\t  off = reg;\n+\t}\n+      frame_insn (gen_stack_adjust_add (off, mem));\n+    }\n+\n+  /* Mode switching uses get_hard_reg_initial_val after\n+      emit_initial_value_sets, so we have to fix this up now.  */\n+  save_config = has_hard_reg_initial_val (SImode, CONFIG_REGNUM);\n+  if (save_config)\n+    {\n+      if (REG_P (save_config))\n+\t{\n+\t  if (REGNO (save_config) >= FIRST_PSEUDO_REGISTER)\n+\t    gcc_assert (!df_regs_ever_live_p (REGNO (save_config)));\n+\t  else\n+\t    frame_move_insn (save_config,\n+\t\t\t     get_hard_reg_initial_reg (save_config));\n+\t}\n+      else\n+\t{\n+\t  rtx save_dst = save_config;\n+\n+\t  reg = gen_rtx_REG (SImode, GPR_IP);\n+\t  gcc_assert (MEM_P (save_dst));\n+\t  if (!memory_operand (save_dst, SImode))\n+\t    {\n+\t      rtx addr = XEXP (save_dst, 0);\n+\t      rtx reg2 = gen_rtx_REG (SImode, GPR_16);\n+\n+\t      gcc_assert (GET_CODE (addr) == PLUS);\n+\t      gcc_assert (XEXP (addr, 0) == hard_frame_pointer_rtx\n+\t\t\t  || XEXP (addr, 0) == stack_pointer_rtx);\n+\t      emit_move_insn (reg2, XEXP (addr, 1));\n+\t      save_dst\n+\t\t= replace_equiv_address (save_dst,\n+\t\t\t\t\t gen_rtx_PLUS (Pmode, XEXP (addr, 0),\n+\t\t\t\t\t\t       reg2));\n+\t    }\n+\t  emit_move_insn (reg, get_hard_reg_initial_reg (save_config));\n+\t  emit_move_insn (save_dst, reg);\n+\t}\n+    }\n+}\n+\n+void\n+epiphany_expand_epilogue (int sibcall_p)\n+{\n+  int interrupt_p;\n+  enum epiphany_function_type fn_type;\n+  rtx mem, addr, reg, off;\n+  HOST_WIDE_INT restore_offset;\n+\n+  fn_type = epiphany_compute_function_type( current_function_decl);\n+  interrupt_p = EPIPHANY_INTERRUPT_P (fn_type);\n+\n+  /* For variable frames, deallocate bulk of frame.  */\n+  if (current_frame_info.need_fp)\n+    {\n+      mem = gen_frame_mem (BLKmode, stack_pointer_rtx);\n+      emit_insn (gen_stack_adjust_mov (mem));\n+    }\n+  /* Else for large static frames, deallocate bulk of frame.  */\n+  else if (current_frame_info.last_slot_offset)\n+    {\n+      mem = gen_frame_mem (BLKmode, stack_pointer_rtx);\n+      reg = gen_rtx_REG (Pmode, GPR_IP);\n+      emit_move_insn (reg, GEN_INT (current_frame_info.last_slot_offset));\n+      emit_insn (gen_stack_adjust_add (reg, mem));\n+    }\n+  restore_offset = (interrupt_p\n+\t\t    ? - 3 * UNITS_PER_WORD\n+\t\t    : epiphany_stack_offset - (HOST_WIDE_INT) UNITS_PER_WORD);\n+  addr = plus_constant (stack_pointer_rtx,\n+\t\t\t(current_frame_info.first_slot_offset\n+\t\t\t + restore_offset));\n+  epiphany_emit_save_restore (current_frame_info.small_threshold,\n+\t\t\t   FIRST_PSEUDO_REGISTER, addr, 1);\n+\n+  if (interrupt_p && !epiphany_uninterruptible_p (current_function_decl))\n+    emit_insn (gen_gid ());\n+\n+  off = GEN_INT (current_frame_info.first_slot_offset);\n+  mem = gen_frame_mem (BLKmode, stack_pointer_rtx);\n+  /* For large / variable size frames, deallocating the register save area is\n+     joint with one register restore; for medium size frames, we use a\n+     dummy post-increment load to dealloacte the whole frame.  */\n+  if (!SIMM11 (INTVAL (off)) || current_frame_info.last_slot >= 0)\n+    {\n+      emit_insn (gen_stack_adjust_ldr\n+\t\t  (gen_rtx_REG (word_mode,\n+\t\t\t\t(current_frame_info.last_slot >= 0\n+\t\t\t\t ? current_frame_info.last_slot : GPR_IP)),\n+\t\t   gen_frame_mem (word_mode, stack_pointer_rtx),\n+\t\t   off,\n+\t\t   mem));\n+    }\n+  /* While for small frames, we deallocate the entire frame with one add.  */\n+  else if (INTVAL (off))\n+    {\n+      emit_insn (gen_stack_adjust_add (off, mem));\n+    }\n+  if (interrupt_p)\n+    {\n+      frame_move_insn (gen_rtx_REG (word_mode, STATUS_REGNUM),\n+\t\t       gen_rtx_REG (SImode, GPR_0));\n+      frame_move_insn (gen_rtx_REG (word_mode, IRET_REGNUM),\n+\t\t       gen_rtx_REG (SImode, GPR_0+1));\n+      addr = plus_constant (stack_pointer_rtx,\n+\t\t\t    - (HOST_WIDE_INT) 2 * UNITS_PER_WORD);\n+      frame_move_insn (gen_rtx_REG (DImode, GPR_0),\n+\t\t       gen_frame_mem (DImode, addr));\n+    }\n+  addr = plus_constant (stack_pointer_rtx,\n+\t\t\tepiphany_stack_offset - (HOST_WIDE_INT) UNITS_PER_WORD);\n+  epiphany_emit_save_restore (0, current_frame_info.small_threshold, addr, 1);\n+  if (!sibcall_p)\n+    {\n+      if (interrupt_p)\n+\temit_jump_insn (gen_return_internal_interrupt());\n+      else\n+\temit_jump_insn (gen_return_i ());\n+    }\n+}\n+\n+int\n+epiphany_initial_elimination_offset (int from, int to)\n+{\n+  epiphany_compute_frame_size (get_frame_size ());\n+  if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    return current_frame_info.total_size - current_frame_info.reg_size;\n+  if (from == FRAME_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n+    return current_frame_info.first_slot_offset - current_frame_info.reg_size;\n+  if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    return (current_frame_info.total_size\n+\t    - ((current_frame_info.pretend_size + 4) & -8));\n+  if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n+    return (current_frame_info.first_slot_offset\n+\t    - ((current_frame_info.pretend_size + 4) & -8));\n+  gcc_unreachable ();\n+}\n+\n+static int\n+epiphany_issue_rate (void)\n+{\n+  return 2;\n+}\n+\n+/* Function to update the integer COST\n+   based on the relationship between INSN that is dependent on\n+   DEP_INSN through the dependence LINK.  The default is to make no\n+   adjustment to COST.  This can be used for example to specify to\n+   the scheduler that an output- or anti-dependence does not incur\n+   the same cost as a data-dependence.  The return value should be\n+   the new value for COST.  */\n+static int\n+epiphany_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n+{\n+  if (REG_NOTE_KIND (link) == 0)\n+    {\n+      rtx dep_set;\n+\n+      if (recog_memoized (insn) < 0\n+\t  || recog_memoized (dep_insn) < 0)\n+\treturn cost;\n+\n+      dep_set = single_set (dep_insn);\n+\n+      /* The latency that we specify in the scheduling description refers\n+\t to the actual output, not to an auto-increment register; for that,\n+\t the latency is one.  */\n+      if (dep_set && MEM_P (SET_SRC (dep_set)) && cost > 1)\n+\t{\n+\t  rtx set = single_set (insn);\n+\n+\t  if (set\n+\t      && !reg_mentioned_p (SET_DEST (dep_set), SET_SRC (set))\n+\t      && (!MEM_P (SET_DEST (set))\n+\t\t  || !reg_mentioned_p (SET_DEST (dep_set),\n+\t\t\t\t       XEXP (SET_DEST (set), 0))))\n+\t    cost = 1;\n+\t}\n+    }\n+  return cost;\n+}\n+\n+#define REG_OK_FOR_INDEX_P(X) REG_OK_FOR_BASE_P (X)\n+\n+#define RTX_OK_FOR_BASE_P(X) \\\n+  (REG_P (X) && REG_OK_FOR_BASE_P (X))\n+\n+#define RTX_OK_FOR_INDEX_P(MODE, X) \\\n+  ((GET_MODE_CLASS (MODE) != MODE_VECTOR_INT \\\n+    || epiphany_vect_align >= GET_MODE_SIZE (MODE)) \\\n+   && (REG_P (X) && REG_OK_FOR_INDEX_P (X)))\n+\n+#define LEGITIMATE_OFFSET_ADDRESS_P(MODE, X) \\\n+(GET_CODE (X) == PLUS \\\n+ && RTX_OK_FOR_BASE_P (XEXP (X, 0)) \\\n+ && (RTX_OK_FOR_INDEX_P (MODE, XEXP (X, 1)) \\\n+     || RTX_OK_FOR_OFFSET_P (MODE, XEXP (X, 1))))\n+\n+static bool\n+epiphany_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n+{\n+#define REG_OK_FOR_BASE_P(X) \\\n+  (strict ? GPR_P (REGNO (X)) : GPR_AP_OR_PSEUDO_P (REGNO (X)))\n+  if (RTX_OK_FOR_BASE_P (x))\n+    return true;\n+  if (RTX_FRAME_OFFSET_P (x))\n+    return true;\n+  if (LEGITIMATE_OFFSET_ADDRESS_P (mode, x))\n+    return true;\n+  if (TARGET_POST_INC\n+      && (GET_CODE (x) == POST_DEC || GET_CODE (x) == POST_INC)\n+      && RTX_OK_FOR_BASE_P (XEXP ((x), 0)))\n+    return true;\n+  if ((TARGET_POST_MODIFY || reload_completed)\n+      && GET_CODE (x) == POST_MODIFY\n+      && GET_CODE (XEXP ((x), 1)) == PLUS\n+      && rtx_equal_p (XEXP ((x), 0), XEXP (XEXP ((x), 1), 0))\n+      && LEGITIMATE_OFFSET_ADDRESS_P (mode, XEXP ((x), 1)))\n+    return true;\n+  if (mode == BLKmode)\n+    return true;\n+  return false;\n+}\n+\n+static reg_class_t\n+epiphany_secondary_reload (bool in_p, rtx x, reg_class_t rclass,\n+\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\tsecondary_reload_info *sri)\n+{\n+  /* This could give more reload inheritance, but we are missing some\n+     reload infrastructure.  */\n+ if (0)\n+  if (in_p && GET_CODE (x) == UNSPEC\n+      && satisfies_constraint_Sra (x) && !satisfies_constraint_Rra (x))\n+    {\n+      gcc_assert (rclass == GENERAL_REGS);\n+      sri->icode = CODE_FOR_reload_insi_ra;\n+      return NO_REGS;\n+    }\n+  return NO_REGS;\n+}\n+\n+bool\n+epiphany_is_long_call_p (rtx x)\n+{\n+  tree decl = SYMBOL_REF_DECL (x);\n+  bool ret_val = !TARGET_SHORT_CALLS;\n+  tree attrs;\n+\n+  /* ??? Is it safe to default to ret_val if decl is NULL?  We should\n+     probably encode information via encode_section_info, and also\n+     have (an) option(s) to take SYMBOL_FLAG_LOCAL and/or SYMBOL_FLAG_EXTERNAL\n+     into account.  */\n+  if (decl)\n+    {\n+      attrs = TYPE_ATTRIBUTES (TREE_TYPE (decl));\n+      if (lookup_attribute (\"long_call\", attrs))\n+\tret_val = true;\n+      else if (lookup_attribute (\"short_call\", attrs))\n+\tret_val = false;\n+    }\n+  return ret_val;\n+}\n+\n+bool\n+epiphany_small16 (rtx x)\n+{\n+  rtx base = x;\n+  rtx offs ATTRIBUTE_UNUSED = const0_rtx;\n+\n+  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS)\n+    {\n+      base = XEXP (XEXP (x, 0), 0);\n+      offs = XEXP (XEXP (x, 0), 1);\n+    }\n+  if (GET_CODE (base) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (base)\n+      && epiphany_is_long_call_p (base))\n+    return false;\n+  return TARGET_SMALL16 != 0;\n+}\n+\n+/* Return nonzero if it is ok to make a tail-call to DECL.  */\n+static bool\n+epiphany_function_ok_for_sibcall (tree decl, tree exp)\n+{\n+  bool cfun_interrupt_p, call_interrupt_p;\n+\n+  cfun_interrupt_p = EPIPHANY_INTERRUPT_P (epiphany_compute_function_type\n+\t\t\t\t\t(current_function_decl));\n+  if (decl)\n+    call_interrupt_p = EPIPHANY_INTERRUPT_P (epiphany_compute_function_type (decl));\n+  else\n+    {\n+      tree fn_type = TREE_TYPE (CALL_EXPR_FN (exp));\n+\n+      gcc_assert (POINTER_TYPE_P (fn_type));\n+      fn_type = TREE_TYPE (fn_type);\n+      gcc_assert (TREE_CODE (fn_type) == FUNCTION_TYPE\n+\t\t  || TREE_CODE (fn_type) == METHOD_TYPE);\n+      call_interrupt_p\n+\t= lookup_attribute (\"interrupt\", TYPE_ATTRIBUTES (fn_type)) != NULL;\n+    }\n+\n+  /* Don't tailcall from or to an ISR routine - although we could in\n+     principle tailcall from one ISR routine to another, we'd need to\n+     handle this in sibcall_epilogue to make it work.  */\n+  if (cfun_interrupt_p || call_interrupt_p)\n+    return false;\n+\n+  /* Everything else is ok.  */\n+  return true;\n+}\n+\n+/* T is a function declaration or the MEM_EXPR of a MEM passed to a call\n+   expander.\n+   Return true iff the type of T has the uninterruptible attribute.\n+   If T is NULL, return false.  */\n+bool\n+epiphany_uninterruptible_p (tree t)\n+{\n+  tree attrs;\n+\n+  if (t)\n+    {\n+      attrs = TYPE_ATTRIBUTES (TREE_TYPE (t));\n+      if (lookup_attribute (\"disinterrupt\", attrs))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+bool\n+epiphany_call_uninterruptible_p (rtx mem)\n+{\n+  rtx addr = XEXP (mem, 0);\n+  tree t = NULL_TREE;\n+\n+  if (GET_CODE (addr) == SYMBOL_REF)\n+    t = SYMBOL_REF_DECL (addr);\n+  if (!t)\n+    t = MEM_EXPR (mem);\n+  return epiphany_uninterruptible_p (t);\n+}\n+\n+static enum machine_mode\n+epiphany_promote_function_mode (const_tree type, enum machine_mode mode,\n+\t\t\t\tint *punsignedp ATTRIBUTE_UNUSED,\n+\t\t\t\tconst_tree funtype ATTRIBUTE_UNUSED,\n+\t\t\t\tint for_return ATTRIBUTE_UNUSED)\n+{\n+  int dummy;\n+\n+  return promote_mode (type, mode, &dummy);\n+}\n+\n+static void\n+epiphany_conditional_register_usage (void)\n+{\n+  int i;\n+\n+  if (PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\n+    {\n+      fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\n+      call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\n+    }\n+  if (TARGET_HALF_REG_FILE)\n+    {\n+      for (i = 32; i <= 63; i++)\n+\t{\n+\t  fixed_regs[i] = 1;\n+\t  call_used_regs[i] = 1;\n+\t}\n+    }\n+  if (epiphany_m1reg >= 0)\n+    {\n+      fixed_regs[epiphany_m1reg] = 1;\n+      call_used_regs[epiphany_m1reg] = 1;\n+    }\n+  if (!TARGET_PREFER_SHORT_INSN_REGS)\n+    CLEAR_HARD_REG_SET (reg_class_contents[SHORT_INSN_REGS]);\n+  COPY_HARD_REG_SET (reg_class_contents[SIBCALL_REGS],\n+\t\t     reg_class_contents[GENERAL_REGS]);\n+  /* It would be simpler and quicker if we could just use\n+     AND_COMPL_HARD_REG_SET, alas, call_used_reg_set is yet uninitialized;\n+     it is set up later by our caller.  */\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (!call_used_regs[i])\n+      CLEAR_HARD_REG_BIT (reg_class_contents[SIBCALL_REGS], i);\n+}\n+\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+/* On the EPIPHANY the first MAX_EPIPHANY_PARM_REGS args are normally in\n+   registers and the rest are pushed.  */\n+static rtx\n+epiphany_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n+\t\t       const_tree type, bool named ATTRIBUTE_UNUSED)\n+{\n+  CUMULATIVE_ARGS cum = *get_cumulative_args (cum_v);\n+\n+  if (PASS_IN_REG_P (cum, mode, type))\n+    return gen_rtx_REG (mode, ROUND_ADVANCE_CUM (cum, mode, type));\n+  return 0;\n+}\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+static void\n+epiphany_function_arg_advance (cumulative_args_t cum_v, enum machine_mode mode,\n+\t\t\t       const_tree type, bool named ATTRIBUTE_UNUSED)\n+{\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+\n+  *cum = ROUND_ADVANCE_CUM (*cum, mode, type) + ROUND_ADVANCE_ARG (mode, type);\n+}\n+\f\n+/* Nested function support.\n+   An epiphany trampoline looks like this:\n+   mov r16,%low(fnaddr)\n+   movt r16,%high(fnaddr)\n+   mov ip,%low(cxt)\n+   movt ip,%high(cxt)\n+   jr r16  */\n+\n+#define EPIPHANY_LOW_RTX(X) \\\n+  (gen_rtx_IOR (SImode, \\\n+    gen_rtx_ASHIFT (SImode, \\\n+\t\t    gen_rtx_AND (SImode, (X), GEN_INT (0xff)), GEN_INT (5)), \\\n+    gen_rtx_ASHIFT (SImode, \\\n+\t\t    gen_rtx_AND (SImode, (X), GEN_INT (0xff00)), GEN_INT (12))))\n+#define EPIPHANY_HIGH_RTX(X) \\\n+  EPIPHANY_LOW_RTX (gen_rtx_LSHIFTRT (SImode, (X), GEN_INT (16)))\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+static void\n+epiphany_trampoline_init (rtx tramp_mem, tree fndecl, rtx cxt)\n+{\n+  rtx fnaddr = XEXP (DECL_RTL (fndecl), 0);\n+  rtx tramp = force_reg (Pmode, XEXP (tramp_mem, 0));\n+\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 0)),\n+\t\t  gen_rtx_IOR (SImode, GEN_INT (0x4002000b),\n+\t\t\t       EPIPHANY_LOW_RTX (fnaddr)));\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 4)),\n+\t\t  gen_rtx_IOR (SImode, GEN_INT (0x5002000b),\n+\t\t\t       EPIPHANY_HIGH_RTX (fnaddr)));\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 8)),\n+\t\t  gen_rtx_IOR (SImode, GEN_INT (0x2002800b),\n+\t\t\t       EPIPHANY_LOW_RTX (cxt)));\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 12)),\n+\t\t  gen_rtx_IOR (SImode, GEN_INT (0x3002800b),\n+\t\t\t       EPIPHANY_HIGH_RTX (cxt)));\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 16)),\n+\t\t  GEN_INT (0x0802014f));\n+}\n+\f\n+bool\n+epiphany_optimize_mode_switching (int entity)\n+{\n+  if (MACHINE_FUNCTION (cfun)->sw_entities_processed & (1 << entity))\n+    return false;\n+  switch (entity)\n+    {\n+    case EPIPHANY_MSW_ENTITY_AND:\n+    case EPIPHANY_MSW_ENTITY_OR:\n+      return true;\n+    case EPIPHANY_MSW_ENTITY_NEAREST:\n+    case EPIPHANY_MSW_ENTITY_TRUNC:\n+      return optimize > 0;\n+    case EPIPHANY_MSW_ENTITY_ROUND_UNKNOWN:\n+      return MACHINE_FUNCTION (cfun)->unknown_mode_uses != 0;\n+    case EPIPHANY_MSW_ENTITY_ROUND_KNOWN:\n+      return (MACHINE_FUNCTION (cfun)->sw_entities_processed\n+\t      & (1 << EPIPHANY_MSW_ENTITY_ROUND_UNKNOWN)) != 0;\n+    case EPIPHANY_MSW_ENTITY_FPU_OMNIBUS:\n+      return optimize == 0 || current_pass == &pass_mode_switch_use.pass;\n+    }\n+  gcc_unreachable ();\n+}\n+\n+int\n+epiphany_mode_priority_to_mode (int entity, unsigned priority)\n+{\n+  if (entity == EPIPHANY_MSW_ENTITY_AND || entity == EPIPHANY_MSW_ENTITY_OR)\n+    return priority;\n+  if (priority > 3)\n+    switch (priority)\n+      {\n+      case 4: return FP_MODE_ROUND_UNKNOWN;\n+      case 5: return FP_MODE_NONE;\n+      default: gcc_unreachable ();\n+      }\n+  switch ((enum attr_fp_mode) epiphany_normal_fp_mode)\n+    {\n+      case FP_MODE_INT:\n+\tswitch (priority)\n+\t  {\n+\t  case 0: return FP_MODE_INT;\n+\t  case 1: return epiphany_normal_fp_rounding;\n+\t  case 2: return (epiphany_normal_fp_rounding == FP_MODE_ROUND_NEAREST\n+\t\t\t  ? FP_MODE_ROUND_TRUNC : FP_MODE_ROUND_NEAREST);\n+\t  case 3: return FP_MODE_CALLER;\n+\t  }\n+      case FP_MODE_ROUND_NEAREST:\n+      case FP_MODE_CALLER:\n+\tswitch (priority)\n+\t  {\n+\t  case 0: return FP_MODE_ROUND_NEAREST;\n+\t  case 1: return FP_MODE_ROUND_TRUNC;\n+\t  case 2: return FP_MODE_INT;\n+\t  case 3: return FP_MODE_CALLER;\n+\t  }\n+      case FP_MODE_ROUND_TRUNC:\n+\tswitch (priority)\n+\t  {\n+\t  case 0: return FP_MODE_ROUND_TRUNC;\n+\t  case 1: return FP_MODE_ROUND_NEAREST;\n+\t  case 2: return FP_MODE_INT;\n+\t  case 3: return FP_MODE_CALLER;\n+\t  }\n+      case FP_MODE_ROUND_UNKNOWN:\n+      case FP_MODE_NONE:\n+\tgcc_unreachable ();\n+    }\n+  gcc_unreachable ();\n+}\n+\n+int\n+epiphany_mode_needed (int entity, rtx insn)\n+{\n+  enum attr_fp_mode mode;\n+\n+  if (recog_memoized (insn) < 0)\n+    {\n+      if (entity == EPIPHANY_MSW_ENTITY_AND\n+\t  || entity == EPIPHANY_MSW_ENTITY_OR)\n+\treturn 2;\n+      return FP_MODE_NONE;\n+    }\n+  mode = get_attr_fp_mode (insn);\n+\n+  switch (entity)\n+  {\n+  case EPIPHANY_MSW_ENTITY_AND:\n+    return mode != FP_MODE_INT ? 1 : 2;\n+  case EPIPHANY_MSW_ENTITY_OR:\n+    return mode == FP_MODE_INT ? 1 : 2;\n+  case EPIPHANY_MSW_ENTITY_ROUND_KNOWN:\n+    if (recog_memoized (insn) == CODE_FOR_set_fp_mode)\n+      mode = (enum attr_fp_mode) epiphany_mode_after (entity, mode, insn);\n+    /* Fall through.  */\n+  case EPIPHANY_MSW_ENTITY_NEAREST:\n+  case EPIPHANY_MSW_ENTITY_TRUNC:\n+    if (mode == FP_MODE_ROUND_UNKNOWN)\n+      {\n+\tMACHINE_FUNCTION (cfun)->unknown_mode_uses++;\n+\treturn FP_MODE_NONE;\n+      }\n+    return mode;\n+  case EPIPHANY_MSW_ENTITY_ROUND_UNKNOWN:\n+    if (mode == FP_MODE_ROUND_NEAREST || mode == FP_MODE_ROUND_TRUNC)\n+\treturn FP_MODE_ROUND_UNKNOWN;\n+    return mode;\n+  case EPIPHANY_MSW_ENTITY_FPU_OMNIBUS:\n+    if (mode == FP_MODE_ROUND_UNKNOWN)\n+      return epiphany_normal_fp_rounding;\n+    return mode;\n+  default:\n+    gcc_unreachable ();\n+  }\n+}\n+\n+int\n+epiphany_mode_entry_exit (int entity, bool exit)\n+{\n+  int normal_mode = epiphany_normal_fp_mode ;\n+\n+  MACHINE_FUNCTION (cfun)->sw_entities_processed |= (1 << entity);\n+  if (epiphany_is_interrupt_p (current_function_decl))\n+    normal_mode = FP_MODE_CALLER;\n+  switch (entity)\n+    {\n+    case EPIPHANY_MSW_ENTITY_AND:\n+      if (exit)\n+\treturn normal_mode != FP_MODE_INT ? 1 : 2;\n+      return 0;\n+    case EPIPHANY_MSW_ENTITY_OR:\n+      if (exit)\n+\treturn normal_mode == FP_MODE_INT ? 1 : 2;\n+      return 0;\n+    case EPIPHANY_MSW_ENTITY_ROUND_UNKNOWN:\n+      if (normal_mode == FP_MODE_ROUND_NEAREST\n+\t  || normal_mode == FP_MODE_ROUND_TRUNC)\n+      return FP_MODE_ROUND_UNKNOWN;\n+      /* Fall through.  */\n+    case EPIPHANY_MSW_ENTITY_NEAREST:\n+    case EPIPHANY_MSW_ENTITY_TRUNC:\n+    case EPIPHANY_MSW_ENTITY_ROUND_KNOWN:\n+    case EPIPHANY_MSW_ENTITY_FPU_OMNIBUS:\n+      return normal_mode;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+int\n+epiphany_mode_after (int entity, int last_mode, rtx insn)\n+{\n+  /* We have too few call-saved registers to hope to keep the masks across\n+     calls.  */\n+  if (entity == EPIPHANY_MSW_ENTITY_AND || entity == EPIPHANY_MSW_ENTITY_OR)\n+    {\n+      if (GET_CODE (insn) == CALL_INSN)\n+\treturn 0;\n+      return last_mode;\n+    }\n+  if (recog_memoized (insn) < 0)\n+    return last_mode;\n+  if (get_attr_fp_mode (insn) == FP_MODE_ROUND_UNKNOWN\n+      && last_mode != FP_MODE_ROUND_NEAREST && last_mode != FP_MODE_ROUND_TRUNC)\n+    {\n+      if (entity == EPIPHANY_MSW_ENTITY_NEAREST)\n+\treturn FP_MODE_ROUND_NEAREST;\n+      if (entity == EPIPHANY_MSW_ENTITY_TRUNC)\n+\treturn FP_MODE_ROUND_TRUNC;\n+    }\n+  if (recog_memoized (insn) == CODE_FOR_set_fp_mode)\n+    {\n+      rtx src = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));\n+      int fp_mode;\n+\n+      if (REG_P (src))\n+\treturn FP_MODE_CALLER;\n+      fp_mode = INTVAL (XVECEXP (XEXP (src, 0), 0, 0));\n+      if (entity == EPIPHANY_MSW_ENTITY_ROUND_UNKNOWN\n+\t  && (fp_mode == FP_MODE_ROUND_NEAREST\n+\t      || fp_mode == EPIPHANY_MSW_ENTITY_TRUNC))\n+\treturn FP_MODE_ROUND_UNKNOWN;\n+      return fp_mode;\n+    }\n+  return last_mode;\n+}\n+\n+void\n+emit_set_fp_mode (int entity, int mode, HARD_REG_SET regs_live ATTRIBUTE_UNUSED)\n+{\n+  rtx save_cc, cc_reg, mask, src, src2;\n+  enum attr_fp_mode fp_mode;\n+\n+  if (!MACHINE_FUNCTION (cfun)->and_mask)\n+    {\n+      MACHINE_FUNCTION (cfun)->and_mask = gen_reg_rtx (SImode);\n+      MACHINE_FUNCTION (cfun)->or_mask = gen_reg_rtx (SImode);\n+    }\n+  if (entity == EPIPHANY_MSW_ENTITY_AND)\n+    {\n+      gcc_assert (mode >= 0 && mode <= 2);\n+      if (mode == 1)\n+\temit_move_insn (MACHINE_FUNCTION (cfun)->and_mask,\n+\t\t\tgen_int_mode (0xfff1fffe, SImode));\n+      return;\n+    }\n+  else if (entity == EPIPHANY_MSW_ENTITY_OR)\n+    {\n+      gcc_assert (mode >= 0 && mode <= 2);\n+      if (mode == 1)\n+\temit_move_insn (MACHINE_FUNCTION (cfun)->or_mask, GEN_INT(0x00080000));\n+      return;\n+    }\n+  fp_mode = (enum attr_fp_mode) mode;\n+  src = NULL_RTX;\n+\n+  switch (fp_mode)\n+    {\n+      case FP_MODE_CALLER:\n+\tsrc = get_hard_reg_initial_val (SImode, CONFIG_REGNUM);\n+\tmask = MACHINE_FUNCTION (cfun)->and_mask;\n+\tbreak;\n+      case FP_MODE_ROUND_UNKNOWN:\n+\tMACHINE_FUNCTION (cfun)->unknown_mode_sets++;\n+\tmask = MACHINE_FUNCTION (cfun)->and_mask;\n+\tbreak;\n+      case FP_MODE_ROUND_NEAREST:\n+\tif (entity == EPIPHANY_MSW_ENTITY_TRUNC)\n+\t  return;\n+\tmask = MACHINE_FUNCTION (cfun)->and_mask;\n+\tbreak;\n+      case FP_MODE_ROUND_TRUNC:\n+\tif (entity == EPIPHANY_MSW_ENTITY_NEAREST)\n+\t  return;\n+\tmask = MACHINE_FUNCTION (cfun)->and_mask;\n+\tbreak;\n+      case FP_MODE_INT:\n+\tmask = MACHINE_FUNCTION (cfun)->or_mask;\n+\tbreak;\n+      case FP_MODE_NONE:\n+      default:\n+\tgcc_unreachable ();\n+    }\n+  save_cc = gen_reg_rtx (CCmode);\n+  cc_reg = gen_rtx_REG (CCmode, CC_REGNUM);\n+  emit_move_insn (save_cc, cc_reg);\n+  mask = force_reg (SImode, mask);\n+  if (!src)\n+    {\n+      rtvec v = gen_rtvec (1, GEN_INT (fp_mode));\n+\n+      src = gen_rtx_CONST (SImode, gen_rtx_UNSPEC (SImode, v, UNSPEC_FP_MODE));\n+    }\n+  if (entity == EPIPHANY_MSW_ENTITY_ROUND_KNOWN\n+      || entity == EPIPHANY_MSW_ENTITY_FPU_OMNIBUS)\n+    src2 = copy_rtx (src);\n+  else\n+    {\n+      rtvec v = gen_rtvec (1, GEN_INT (FP_MODE_ROUND_UNKNOWN));\n+\n+      src2 = gen_rtx_CONST (SImode, gen_rtx_UNSPEC (SImode, v, UNSPEC_FP_MODE));\n+    }\n+  emit_insn (gen_set_fp_mode (src, src2, mask));\n+  emit_move_insn (cc_reg, save_cc);\n+}\n+\n+void\n+epiphany_expand_set_fp_mode (rtx *operands)\n+{\n+  rtx ctrl = gen_rtx_REG (SImode, CONFIG_REGNUM);\n+  rtx src = operands[0];\n+  rtx mask_reg = operands[2];\n+  rtx scratch = operands[3];\n+  enum attr_fp_mode fp_mode;\n+\n+\n+  gcc_assert (rtx_equal_p (src, operands[1])\n+\t      /* Sometimes reload gets silly and reloads the same pseudo\n+\t\t into different registers.  */\n+\t      || (REG_P (src) && REG_P (operands[1])));\n+\n+  if (!epiphany_uninterruptible_p (current_function_decl))\n+    emit_insn (gen_gid ());\n+  emit_move_insn (scratch, ctrl);\n+\n+  if (GET_CODE (src) == REG)\n+    {\n+      /* FP_MODE_CALLER */\n+      emit_insn (gen_xorsi3 (scratch, scratch, src));\n+      emit_insn (gen_andsi3 (scratch, scratch, mask_reg));\n+      emit_insn (gen_xorsi3 (scratch, scratch, src));\n+    }\n+  else\n+    {\n+      gcc_assert (GET_CODE (src) == CONST);\n+      src = XEXP (src, 0);\n+      fp_mode = (enum attr_fp_mode) INTVAL (XVECEXP (src, 0, 0));\n+      switch (fp_mode)\n+\t{\n+\tcase FP_MODE_ROUND_NEAREST:\n+\t  emit_insn (gen_andsi3 (scratch, scratch, mask_reg));\n+\t  break;\n+\tcase FP_MODE_ROUND_TRUNC:\n+\t  emit_insn (gen_andsi3 (scratch, scratch, mask_reg));\n+\t  emit_insn (gen_add2_insn (scratch, const1_rtx));\n+\t  break;\n+\tcase FP_MODE_INT:\n+\t  emit_insn (gen_iorsi3 (scratch, scratch, mask_reg));\n+\t  break;\n+\tcase FP_MODE_CALLER:\n+\tcase FP_MODE_ROUND_UNKNOWN:\n+\tcase FP_MODE_NONE:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  emit_move_insn (ctrl, scratch);\n+  if (!epiphany_uninterruptible_p (current_function_decl))\n+    emit_insn (gen_gie ());\n+}\n+\n+void\n+epiphany_insert_mode_switch_use (rtx insn,\n+\t\t\t\t int entity ATTRIBUTE_UNUSED,\n+\t\t\t\t int mode ATTRIBUTE_UNUSED)\n+{\n+  rtx pat = PATTERN (insn);\n+  rtvec v;\n+  int len, i;\n+  rtx near = gen_rtx_REG (SImode, FP_NEAREST_REGNUM);\n+  rtx trunc = gen_rtx_REG (SImode, FP_TRUNCATE_REGNUM);\n+\n+  if (entity != EPIPHANY_MSW_ENTITY_FPU_OMNIBUS)\n+    return;\n+  switch ((enum attr_fp_mode) get_attr_fp_mode (insn))\n+    {\n+      case FP_MODE_ROUND_NEAREST:\n+\tnear = gen_rtx_USE (VOIDmode, near);\n+\ttrunc = gen_rtx_CLOBBER (VOIDmode, trunc);\n+\tbreak;\n+      case FP_MODE_ROUND_TRUNC:\n+\tnear = gen_rtx_CLOBBER (VOIDmode, near);\n+\ttrunc = gen_rtx_USE (VOIDmode, trunc);\n+\tbreak;\n+      case FP_MODE_ROUND_UNKNOWN:\n+\tnear = gen_rtx_USE (VOIDmode, gen_rtx_REG (SImode, FP_ANYFP_REGNUM));\n+\ttrunc = copy_rtx (near);\n+\t/* Fall through.  */\n+      case FP_MODE_INT:\n+      case FP_MODE_CALLER:\n+\tnear = gen_rtx_USE (VOIDmode, near);\n+\ttrunc = gen_rtx_USE (VOIDmode, trunc);\n+\tbreak;\n+      case FP_MODE_NONE:\n+\tgcc_unreachable ();\n+    }\n+  gcc_assert (GET_CODE (pat) == PARALLEL);\n+  len = XVECLEN (pat, 0);\n+  v = rtvec_alloc (len + 2);\n+  for (i = 0; i < len; i++)\n+    RTVEC_ELT (v, i) = XVECEXP (pat, 0, i);\n+  RTVEC_ELT (v, len) = near;\n+  RTVEC_ELT (v, len + 1) = trunc;\n+  pat = gen_rtx_PARALLEL (VOIDmode, v);\n+  PATTERN (insn) = pat;\n+  MACHINE_FUNCTION (cfun)->control_use_inserted = true;\n+}\n+\n+bool\n+epiphany_epilogue_uses (int regno)\n+{\n+  if (regno == GPR_LR)\n+    return true;\n+  if (reload_completed && epiphany_is_interrupt_p (current_function_decl))\n+    {\n+      if (fixed_regs[regno]\n+\t  && regno != STATUS_REGNUM && regno != IRET_REGNUM\n+\t  && regno != FP_NEAREST_REGNUM && regno != FP_TRUNCATE_REGNUM)\n+\treturn false;\n+      return true;\n+    }\n+  if (regno == FP_NEAREST_REGNUM\n+      && epiphany_normal_fp_mode != FP_MODE_ROUND_TRUNC)\n+    return true;\n+  if (regno == FP_TRUNCATE_REGNUM\n+      && epiphany_normal_fp_mode != FP_MODE_ROUND_NEAREST)\n+    return true;\n+  return false;\n+}\n+\n+static unsigned int\n+epiphany_min_divisions_for_recip_mul (enum machine_mode mode)\n+{\n+  if (flag_reciprocal_math && mode == SFmode)\n+    /* We'll expand into a multiply-by-reciprocal anyway, so we might a well do\n+       it already at the tree level and expose it to further optimizations.  */\n+    return 1;\n+  return default_min_divisions_for_recip_mul (mode);\n+}\n+\n+static enum machine_mode\n+epiphany_preferred_simd_mode (enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return TARGET_VECT_DOUBLE ? DImode : SImode;\n+}\n+\n+static bool\n+epiphany_vector_mode_supported_p (enum machine_mode mode)\n+{\n+  if (mode == V2SFmode)\n+    return true;\n+  if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n+      && (GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8))\n+    return true;\n+  return false;\n+}\n+\n+static bool\n+epiphany_vector_alignment_reachable (const_tree type, bool is_packed)\n+{\n+  /* Vectors which aren't in packed structures will not be less aligned than\n+     the natural alignment of their element type, so this is safe.  */\n+  if (TYPE_ALIGN_UNIT (type) == 4)\n+    return !is_packed;\n+\n+  return default_builtin_vector_alignment_reachable (type, is_packed);\n+}\n+\n+static bool\n+epiphany_support_vector_misalignment (enum machine_mode mode, const_tree type,\n+\t\t\t\t      int misalignment, bool is_packed)\n+{\n+  if (GET_MODE_SIZE (mode) == 8 && misalignment % 4 == 0)\n+    return true;\n+  return default_builtin_support_vector_misalignment (mode, type, misalignment,\n+\t\t\t\t\t\t      is_packed);\n+}\n+\n+/* STRUCTURE_SIZE_BOUNDARY seems a bit crude in how it enlarges small\n+   structs.  Make structs double-word-aligned it they are a double word or\n+   (potentially) larger;  failing that, do the same for a size of 32 bits.  */\n+unsigned\n+epiphany_special_round_type_align (tree type, unsigned computed,\n+\t\t\t\t   unsigned specified)\n+{\n+  unsigned align = MAX (computed, specified);\n+  tree field;\n+  HOST_WIDE_INT total, max;\n+  unsigned try_align = FASTEST_ALIGNMENT;\n+\n+  if (maximum_field_alignment && try_align > maximum_field_alignment)\n+    try_align = maximum_field_alignment;\n+  if (align >= try_align)\n+    return align;\n+  for (max = 0, field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+    {\n+      tree offset, size;\n+\n+      if (TREE_CODE (field) != FIELD_DECL\n+\t  || TREE_TYPE (field) == error_mark_node)\n+\tcontinue;\n+      offset = bit_position (field);\n+      size = DECL_SIZE (field);\n+      if (!host_integerp (offset, 1) || !host_integerp (size, 1)\n+\t  || TREE_INT_CST_LOW (offset) >= try_align\n+\t  || TREE_INT_CST_LOW (size) >= try_align)\n+\treturn try_align;\n+      total = TREE_INT_CST_LOW (offset) + TREE_INT_CST_LOW (size);\n+      if (total > max)\n+\tmax = total;\n+    }\n+  if (max >= (HOST_WIDE_INT) try_align)\n+    align = try_align;\n+  else if (try_align > 32 && max >= 32)\n+    align = max > 32 ? 64 : 32;\n+  return align;\n+}\n+\n+/* Upping the alignment of arrays in structs is not only a performance\n+   enhancement, it also helps preserve assumptions about how\n+   arrays-at-the-end-of-structs work, like for struct gcov_fn_info in\n+   libgcov.c .  */\n+unsigned\n+epiphany_adjust_field_align (tree field, unsigned computed)\n+{\n+  if (computed == 32\n+      && TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE)\n+    {\n+      tree elmsz = TYPE_SIZE (TREE_TYPE (TREE_TYPE (field)));\n+\n+      if (!host_integerp (elmsz, 1) || tree_low_cst (elmsz, 1) >= 32)\n+\treturn 64;\n+    }\n+  return computed;\n+}\n+\n+/* Output code to add DELTA to the first argument, and then jump\n+   to FUNCTION.  Used for C++ multiple inheritance.  */\n+static void\n+epiphany_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n+\t\t\t  HOST_WIDE_INT delta,\n+\t\t\t  HOST_WIDE_INT vcall_offset,\n+\t\t\t  tree function)\n+{\n+  int this_regno\n+    = aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function) ? 1 : 0;\n+  const char *this_name = reg_names[this_regno];\n+  const char *fname;\n+\n+  /* We use IP and R16 as a scratch registers.  */\n+  gcc_assert (call_used_regs [GPR_IP]);\n+  gcc_assert (call_used_regs [GPR_16]);\n+\n+  /* Add DELTA.  When possible use a plain add, otherwise load it into\n+     a register first. */\n+  if (delta == 0)\n+    ; /* Done.  */\n+  else if (SIMM11 (delta))\n+    asm_fprintf (file, \"\\tadd\\t%s,%s,%d\\n\", this_name, this_name, (int) delta);\n+  else if (delta < 0 && delta >= -0xffff)\n+    {\n+      asm_fprintf (file, \"\\tmov\\tip,%d\\n\", (int) -delta);\n+      asm_fprintf (file, \"\\tsub\\t%s,%s,ip\\n\", this_name, this_name);\n+    }\n+  else\n+    {\n+      asm_fprintf (file, \"\\tmov\\tip,%%low(%ld)\\n\", (long) delta);\n+      if (delta & ~0xffff)\n+\tasm_fprintf (file, \"\\tmovt\\tip,%%high(%ld)\\n\", (long) delta);\n+      asm_fprintf (file, \"\\tadd\\t%s,%s,ip\\n\", this_name, this_name);\n+    }\n+\n+  /* If needed, add *(*THIS + VCALL_OFFSET) to THIS.  */\n+  if (vcall_offset != 0)\n+    {\n+      /* ldr ip,[this]\t\t--> temp = *this\n+\t ldr ip,[ip,vcall_offset] > temp = *(*this + vcall_offset)\n+\t add this,this,ip\t--> this+ = *(*this + vcall_offset) */\n+      asm_fprintf (file, \"\\tldr\\tip, [%s]\\n\", this_name);\n+      if (vcall_offset < -0x7ff * 4 || vcall_offset > 0x7ff * 4\n+\t  || (vcall_offset & 3) != 0)\n+\t{\n+\t  asm_fprintf (file, \"\\tmov\\tr16, %%low(%ld)\\n\", (long) vcall_offset);\n+\t  asm_fprintf (file, \"\\tmovt\\tr16, %%high(%ld)\\n\", (long) vcall_offset);\n+\t  asm_fprintf (file, \"\\tldr\\tip, [ip,r16]\\n\");\n+\t}\n+      else\n+\tasm_fprintf (file, \"\\tldr\\tip, [ip,%d]\\n\", (int) vcall_offset / 4);\n+      asm_fprintf (file, \"\\tadd\\t%s, %s, ip\\n\", this_name, this_name);\n+    }\n+\n+  fname = XSTR (XEXP (DECL_RTL (function), 0), 0);\n+  if (epiphany_is_long_call_p (XEXP (DECL_RTL (function), 0)))\n+    {\n+      fputs (\"\\tmov\\tip,%low(\", file);\n+      assemble_name (file, fname);\n+      fputs (\")\\n\\tmovt\\tip,%high(\", file);\n+      assemble_name (file, fname);\n+      fputs (\")\\n\\tjr ip\\n\", file);\n+    }\n+  else\n+    {\n+      fputs (\"\\tb\\t\", file);\n+      assemble_name (file, fname);\n+      fputc ('\\n', file);\n+    }\n+}\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "9d03ee909b891c15a9b6e7b475eef8ed0da27d36", "filename": "gcc/config/epiphany/epiphany.h", "status": "added", "additions": 881, "deletions": 0, "changes": 881, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fepiphany.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fepiphany.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.h?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,881 @@\n+/* Definitions of target machine for GNU compiler, Argonaut EPIPHANY cpu.\n+   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005,\n+   2007, 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_EPIPHANY_H\n+#define GCC_EPIPHANY_H\n+\n+#undef LINK_SPEC\n+#undef STARTFILE_SPEC\n+#undef ENDFILE_SPEC\n+#undef SIZE_TYPE\n+#undef PTRDIFF_TYPE\n+#undef WCHAR_TYPE\n+#undef WCHAR_TYPE_SIZE\n+\f\n+/* Names to predefine in the preprocessor for this target machine.  */\n+#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+\tbuiltin_define (\"__epiphany__\");\t\\\n+        builtin_define (\"__little_endian__\");\t\\\n+\tbuiltin_define_with_int_value (\"__EPIPHANY_STACK_OFFSET__\", \\\n+\t\t\t\t       epiphany_stack_offset); \\\n+\tbuiltin_assert (\"cpu=epiphany\");\t\\\n+\tbuiltin_assert (\"machine=epiphany\");\t\\\n+    } while (0)\n+\n+/* Pick up the libgloss library. One day we may do this by linker script, but\n+   for now its static. */\n+#undef LIB_SPEC\n+#define LIB_SPEC \"%{!shared:%{g*:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}} -lepiphany\"\n+\n+#define LINK_SPEC \"%{v}\"\n+\n+#define STARTFILE_SPEC \"%{!shared:crt0.o%s} crti.o%s \" \\\n+  \"%{mfp-mode=int:crtint.o%s} %{mfp-mode=truncate:crtrunc.o%s} \" \\\n+  \"%{m1reg-r43:crtm1reg-r43.o%s} %{m1reg-r63:crtm1reg-r63.o%s} \" \\\n+  \"crtbegin.o%s\"\n+\n+#define ENDFILE_SPEC \"crtend.o%s crtn.o%s\"\n+\n+#undef USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX \"_\"\n+\n+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC) \\\n+   asm (SECTION_OP \"\\n\\\n+\tmov r0,%low(\" USER_LABEL_PREFIX #FUNC\")\\n\\\n+\tmovt r0,%high(\" USER_LABEL_PREFIX #FUNC\")\\n\\\n+\tjalr r0\\n\\\n+\t.text\");\n+\n+#if 0 /* We would like to use Posix for profiling, but the simulator\n+\t interface still lacks mkdir.  */\n+#define TARGET_POSIX_IO\n+#endif\n+\f\n+/* Target machine storage layout.  */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.  */\n+#define BITS_BIG_ENDIAN 0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+#define BYTES_BIG_ENDIAN 0\n+\n+/* Define this if most significant word of a multiword number is the lowest\n+   numbered.  */\n+#define WORDS_BIG_ENDIAN 0\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Define this macro if it is advisable to hold scalars in registers\n+   in a wider mode than that declared by the program.  In such cases,\n+   the value is constrained to be within the bounds of the declared\n+   type, but kept valid in the wider mode.  The signedness of the\n+   extension may differ from that of the type.  */\n+/* It is far faster to zero extend chars than to sign extend them */\n+\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+      && GET_MODE_SIZE (MODE) < 4)      \t\\\n+    {\t\t\t\t\t\t\\\n+      if (MODE == QImode)\t\t\t\\\n+\tUNSIGNEDP = 1;\t\t\t\t\\\n+      else if (MODE == HImode)\t\t\t\\\n+\tUNSIGNEDP = 1;\t\t\t\t\\\n+      (MODE) = SImode;\t\t\t\t\\\n+    }\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 64\n+\n+/* ALIGN FRAMES on word boundaries */\n+#define EPIPHANY_STACK_ALIGN(LOC) (((LOC)+7) & ~7)\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 32\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* A bit-field declared as `int' forces `int' alignment for the struct.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* No data type wants to be aligned rounder than this.  */\n+/* This is bigger than currently necessary for the EPIPHANY.  If 8 byte floats are\n+   ever added it's not clear whether they'll need such alignment or not.  For\n+   now we assume they will.  We can always relax it if necessary but the\n+   reverse isn't true.  */\n+#define BIGGEST_ALIGNMENT 64\n+\n+/* The best alignment to use in cases where we have a choice.  */\n+#define FASTEST_ALIGNMENT 64\n+\n+#define MALLOC_ABI_ALIGNMENT BIGGEST_ALIGNMENT\n+\n+/* Make strings dword-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  ((TREE_CODE (EXP) == STRING_CST\t\\\n+    && (ALIGN) < FASTEST_ALIGNMENT)\t\\\n+   ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/* Make arrays of chars dword-aligned for the same reasons.\n+   Also, align arrays of SImode items.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < FASTEST_ALIGNMENT\t\t\\\n+   ? FASTEST_ALIGNMENT\t\t\t\t\\\n+   : (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+      && TYPE_MODE (TREE_TYPE (TYPE)) == SImode\t\\\n+      && (ALIGN) < FASTEST_ALIGNMENT)\t\t\\\n+   ? FASTEST_ALIGNMENT\t\t\t\t\\\n+   : (ALIGN))\n+\n+/* Set this nonzero if move instructions will actually fail to work\n+   when given unaligned data.  */\n+/* On the EPIPHANY the lower address bits are masked to 0 as necessary.  The chip\n+   won't croak when given an unaligned address, but the insn will still fail\n+   to produce the correct result.  */\n+#define STRICT_ALIGNMENT 1\n+\n+/* layout_type overrides our ADJUST_ALIGNMENT settings from epiphany-modes.def\n+   for vector modes, so we have to override it back.  */\n+#define ROUND_TYPE_ALIGN(TYPE, MANGLED_ALIGN, SPECIFIED_ALIGN) \\\n+ (TREE_CODE (TYPE) == VECTOR_TYPE && !TYPE_USER_ALIGN (TYPE) \\\n+  && SPECIFIED_ALIGN <= GET_MODE_ALIGNMENT (TYPE_MODE (TYPE)) \\\n+  ? GET_MODE_ALIGNMENT (TYPE_MODE (TYPE)) \\\n+  : ((TREE_CODE (TYPE) == RECORD_TYPE \\\n+      || TREE_CODE (TYPE) == UNION_TYPE \\\n+      || TREE_CODE (TYPE) == QUAL_UNION_TYPE) \\\n+     && !TYPE_PACKED (TYPE)) \\\n+  ? epiphany_special_round_type_align ((TYPE), (MANGLED_ALIGN), \\\n+\t\t\t\t       (SPECIFIED_ALIGN)) \\\n+  : MAX ((MANGLED_ALIGN), (SPECIFIED_ALIGN)))\n+\n+#define ADJUST_FIELD_ALIGN(FIELD, COMPUTED) \\\n+  epiphany_adjust_field_align((FIELD), (COMPUTED))\n+\f\n+/* Layout of source language data types.  */\n+\n+#define SHORT_TYPE_SIZE\t\t16\n+#define INT_TYPE_SIZE\t\t32\n+#define LONG_TYPE_SIZE\t\t32\n+#define LONG_LONG_TYPE_SIZE\t64\n+#define FLOAT_TYPE_SIZE\t\t32\n+#define DOUBLE_TYPE_SIZE\t64\n+#define LONG_DOUBLE_TYPE_SIZE\t64\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 0\n+\n+#define SIZE_TYPE \"long unsigned int\"\n+#define PTRDIFF_TYPE \"long int\"\n+#define WCHAR_TYPE \"unsigned int\"\n+#define WCHAR_TYPE_SIZE BITS_PER_WORD\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.  */\n+\n+#define FIRST_PSEUDO_REGISTER 78\n+\n+\n+/* General purpose registers.  */\n+#define GPR_FIRST       0                       /* First gpr */\n+\n+#define PIC_REGNO       (GPR_FIRST + 28)        /* PIC register.  */\n+#define GPR_LAST        (GPR_FIRST + 63)        /* Last gpr */\n+#define CORE_CONTROL_FIRST CONFIG_REGNUM\n+#define CORE_CONTROL_LAST IRET_REGNUM\n+\n+#define GPR_P(R)\tIN_RANGE (R, GPR_FIRST, GPR_LAST)\n+#define GPR_OR_AP_P(R)\t(GPR_P (R) || (R) == ARG_POINTER_REGNUM)\n+\n+#define GPR_OR_PSEUDO_P(R)\t(GPR_P (R) || (R) >= FIRST_PSEUDO_REGISTER)\n+#define GPR_AP_OR_PSEUDO_P(R)\t(GPR_OR_AP_P (R) || (R) >= FIRST_PSEUDO_REGISTER)\n+\n+#define FIXED_REGISTERS\t\t\t\t\t\t\t\\\n+{\t/* Integer Registers */\t\t\t\t\t\t\\\n+\t0, 0, 0, 0, 0, 0, 0, 0,\t\t/* 000-007, gr0  - gr7  */\t\\\n+\t0, 0, 0, 0, 0, 1, 0, 0,\t\t/* 008-015, gr8  - gr15 */\t\\\n+\t0, 0, 0, 0, 0, 0, 0, 0,\t\t/* 016-023, gr16 - gr23 */\t\\\n+\t0, 0, 0, 0, 1, 1, 1, 1,\t\t/* 024-031, gr24 - gr31 */\t\\\n+\t0, 0, 0, 0, 0, 0, 0, 0,\t\t/* 032-039, gr32 - gr39 */\t\\\n+\t1, 1, 1, 1, 0, 0, 0, 0,\t\t/* 040-047, gr40 - gr47 */\t\\\n+\t0, 0, 0, 0, 0, 0, 0, 0,\t\t/* 048-055, gr48 - gr55 */\t\\\n+\t0, 0, 0, 0, 0, 0, 0, 0,\t\t/* 056-063, gr56 - gr63 */\t\\\n+\t/* Other registers */\t\t\t\t\t\t\\\n+\t1,\t\t\t\t/* 64 AP   - fake arg ptr */\t\\\n+\t1,\t\t\t\t/* soft frame pointer */\t\\\n+        1,\t\t\t\t/* CC_REGNUM  - integer conditions */\\\n+\t1,\t\t\t\t/* CCFP_REGNUM  - fp conditions */\\\n+\t1, 1, 1, 1, 1, 1,               /* Core Control Registers.  */  \\\n+\t1, 1, 1,\t\t\t/* FP_{NEAREST,...}_REGNUM */\\\n+\t1,\t\t\t\t/* UNKNOWN_REGNUM - placeholder.  */\\\n+}\n+\n+/* Like `FIXED_REGISTERS' but has 1 for each register that is clobbered (in\n+   general) by function calls as well as for fixed registers.  This macro\n+   therefore identifies the registers that are not available for general\n+   allocation of values that must live across function calls.\n+\n+   If a register has 0 in `CALL_USED_REGISTERS', the compiler automatically\n+   saves it on function entry and restores it on function exit, if the register\n+   is used within the function.  */\n+\n+#define CALL_USED_REGISTERS\t\t\t\t\t\t\\\n+{\t/* Integer Registers */\t\t\t\t\t\t\\\n+\t1, 1, 1, 1, 0, 0, 0, 0,\t        /* 000-007, gr0  - gr7  */\t\\\n+\t0, 0, 0, 0, 1, 1, 1, 0,\t\t/* 008-015, gr8  - gr15 */\t\\\n+\t1, 1, 1, 1, 1, 1, 1, 1,\t\t/* 016-023, gr16 - gr23 */\t\\\n+\t1, 1, 1, 1, 1, 1, 1, 1,\t\t/* 024-031, gr24 - gr31 */\t\\\n+\t0, 0, 0, 0, 0, 0, 0, 0,\t\t/* 032-039, gr32 - gr38 */\t\\\n+\t1, 1, 1, 1, 1, 1, 1, 1,\t\t/* 040-047, gr40 - gr47 */\t\\\n+\t1, 1, 1, 1, 1, 1, 1, 1,\t\t/* 048-055, gr48 - gr55 */\t\\\n+\t1, 1, 1, 1, 1, 1, 1, 1,\t\t/* 056-063, gr56 - gr63 */\t\\\n+\t1,\t\t\t\t/* 64 AP   - fake arg ptr */\t\\\n+\t1,\t\t\t\t/* soft frame pointer */\t\\\n+\t1,\t\t\t\t/* 66 CC_REGNUM */   \t\t\\\n+\t1,\t\t\t\t/* 67 CCFP_REGNUM */   \t\t\\\n+\t1, 1, 1, 1, 1, 1,               /* Core Control Registers.  */  \\\n+\t1, 1, 1,\t\t\t/* FP_{NEAREST,...}_REGNUM */\\\n+\t1,\t\t\t\t/* UNKNOWN_REGNUM - placeholder.  */\\\n+}\n+\n+#define REG_ALLOC_ORDER \\\n+  { \\\n+    0, 1, 2, 3, /* Caller-saved 'small' registers.  */ \\\n+    12, /* Caller-saved unpaired register.  */ \\\n+    /* Caller-saved registers.  */ \\\n+    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, \\\n+    44, 45, 46, 47, \\\n+    48, 49, 50, 51, 52, 53, 54, 55, \\\n+    56, 57, 58, 59, 60, 61, 62, 63, \\\n+    4, 5, 6, 7, /* Calle-saved 'small' registers.  */ \\\n+    15, /* Calle-saved unpaired register.  */ \\\n+    8, 9, 10, 11, /* Calle-saved registers.  */ \\\n+    32, 33, 34, 35, 36, 37, 38, 39, \\\n+    14, 13, /* Link register, stack pointer.  */ \\\n+    40, 41, 42, 43, /* Usually constant, but might be made callee-saved.  */ \\\n+    /* Can't allocate, but must name these... */ \\\n+    28, 29, 30, 31, \\\n+    64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77 \\\n+  }\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE) \\\n+((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n+extern const unsigned int epiphany_hard_regno_mode_ok[];\n+extern unsigned int epiphany_mode_class[];\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) hard_regno_mode_ok((REGNO), (MODE))\n+\n+/* A C expression that is nonzero if it is desirable to choose\n+   register allocation so as to avoid move instructions between a\n+   value of mode MODE1 and a value of mode MODE2.\n+\n+   If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R,\n+   MODE2)' are ever different for any R, then `MODES_TIEABLE_P (MODE1,\n+   MODE2)' must be zero.  */\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2) 1\n+\n+/* Register classes and constants.  */\n+\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.\n+\n+   It is important that any condition codes have class NO_REGS.\n+   See `register_operand'.  */\n+\n+enum reg_class {\n+  NO_REGS,\n+  LR_REGS,\n+  SHORT_INSN_REGS,\n+  SIBCALL_REGS,\n+  GENERAL_REGS,\n+  CORE_CONTROL_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES ((int) LIM_REG_CLASSES)\n+\n+/* Give names of register classes as strings for dump file.  */\n+#define REG_CLASS_NAMES \\\n+{\t\t\t\\\n+  \"NO_REGS\",\t\t\\\n+  \"LR_REGS\",\t\t\\\n+  \"SHORT_INSN_REGS\",\t\\\n+  \"SIBCALL_REGS\",\t\\\n+  \"GENERAL_REGS\",\t\\\n+  \"CORE_CONTROL_REGS\",\t\\\n+  \"ALL_REGS\"\t\t\\\n+}\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n+{  /* r0-r31    r32-r63  ap/sfp/cc1/cc2/iret/status */\t\t\t\\\n+  { 0x00000000,0x00000000,0x0},  /* NO_REGS  */\t\t\t\t\\\n+  { 0x00004000,0x00000000,0x0},  /* LR_REGS  */\t\t\t\t\\\n+  { 0x000000ff,0x00000000,0x0},  /* SHORT_INSN_REGS */\t\t\t\\\n+  { 0xffff100f,0xffffff00,0x0},  /* SIBCALL_REGS */\t\t\t\\\n+  { 0xffffffff,0xffffffff,0x0003}, /* GENERAL_REGS */\t\t\t\\\n+  { 0x00000000,0x00000000,0x03f0}, /* CORE_CONTROL_REGS */\t\t\\\n+  { 0xffffffff,0xffffffff,0x3fff}, /* ALL_REGS */\t\t\t\t\\\n+}\n+\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+extern enum reg_class epiphany_regno_reg_class[FIRST_PSEUDO_REGISTER];\n+#define REGNO_REG_CLASS(REGNO) \\\n+(epiphany_regno_reg_class[REGNO])\n+\n+/* The class value for index registers, and the one for base regs.  */\n+#define BASE_REG_CLASS GENERAL_REGS\n+#define INDEX_REG_CLASS GENERAL_REGS\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+#define REGNO_OK_FOR_BASE_P(REGNO) \\\n+((REGNO) < FIRST_PSEUDO_REGISTER || (unsigned) reg_renumber[REGNO] < FIRST_PSEUDO_REGISTER)\n+#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n+((REGNO) < FIRST_PSEUDO_REGISTER || (unsigned) reg_renumber[REGNO] < FIRST_PSEUDO_REGISTER)\n+\n+\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) \\\n+(CLASS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE) \\\n+((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* The letters I, J, K, L, M, N, O, P in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.  */\n+\n+/* 'I' is used for 16 bit unsigned.\n+   'Cal' is used for long immediates (32 bits)\n+   'K' is used for any constant up to 5 bits.\n+   'L' is used for any 11 bit signed.\n+*/\n+\n+#define IMM16(X)     (IN_RANGE ((X), 0, 0xFFFF))\n+#define SIMM16(X)    (IN_RANGE ((X), -65536, 65535))\n+#define SIMM11(X)    (IN_RANGE ((X), -1024, 1023))\n+#define IMM5(X)      (IN_RANGE ((X), 0, 0x1F))\n+\f\n+typedef struct GTY (()) machine_function\n+{\n+  unsigned args_parsed : 1;\n+  unsigned pretend_args_odd : 1;\n+  unsigned lr_clobbered : 1;\n+  unsigned control_use_inserted : 1;\n+  unsigned sw_entities_processed : 6;\n+  long lr_slot_offset;\n+  rtx and_mask;\n+  rtx or_mask;\n+  unsigned unknown_mode_uses;\n+  unsigned unknown_mode_sets;\n+} machine_function_t;\n+\n+#define MACHINE_FUNCTION(fun) (fun)->machine\n+\n+#define INIT_EXPANDERS epiphany_init_expanders ()\n+\f\n+/* Stack layout and stack pointer usage.  */\n+\n+/* Define this macro if pushing a word onto the stack moves the stack\n+   pointer to a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this to nonzero if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD 1\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET epiphany_stack_offset\n+\n+/* Offset from the stack pointer register to the first location at which\n+   outgoing arguments are placed.  */\n+#define STACK_POINTER_OFFSET epiphany_stack_offset\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+/* 4 bytes for each of previous fp, return address, and previous gp.\n+   4 byte reserved area for future considerations.  */\n+#define FIRST_PARM_OFFSET(FNDECL) \\\n+  (epiphany_stack_offset \\\n+   + (MACHINE_FUNCTION (DECL_STRUCT_FUNCTION (FNDECL))->pretend_args_odd \\\n+      ? 4 : 0))\n+\n+#define INCOMING_FRAME_SP_OFFSET epiphany_stack_offset\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM GPR_SP\n+\n+/* Base register for access to local variables of the function.  */\n+#define HARD_FRAME_POINTER_REGNUM GPR_FP\n+\n+/* Register in which static-chain is passed to a function.  This must\n+   not be a register used by the prologue.  */\n+#define STATIC_CHAIN_REGNUM GPR_IP\n+\n+/* Define the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\t\\\n+{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\t\\\n+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},\t\t\\\n+ { ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},                   \\\n+ { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},\t\t\\\n+}\n+\n+/* Define the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  ((OFFSET) = epiphany_initial_elimination_offset ((FROM), (TO)))\n+\f\n+/* Function argument passing.  */\n+\n+/* If defined, the maximum amount of space required for outgoing\n+   arguments will be computed and placed into the variable\n+   `current_function_outgoing_args_size'.  No space will be pushed\n+   onto the stack for each call; instead, the function prologue should\n+   increase the stack frame size by this amount.  */\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.  */\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.  */\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n+((CUM) = 0)\n+\n+/* The number of registers used for parameter passing.  Local to this file.  */\n+#define MAX_EPIPHANY_PARM_REGS 4\n+\n+/* 1 if N is a possible register number for function argument passing.  */\n+#define FUNCTION_ARG_REGNO_P(N) \\\n+((unsigned) (N) < MAX_EPIPHANY_PARM_REGS)\n+\n+/* Return boolean indicating arg of type TYPE and mode MODE will be passed in\n+   a reg.  This includes arguments that have to be passed by reference as the\n+   pointer to them is passed in a reg if one is available (and that is what\n+   we're given).\n+   This macro is only used in this file.  */\n+/* We must use partial argument passing because of the chosen mode\n+   of varargs handling.  */\n+#define PASS_IN_REG_P(CUM, MODE, TYPE) \\\n+  (ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)) < MAX_EPIPHANY_PARM_REGS)\n+\f\n+/* Tell GCC to use TARGET_RETURN_IN_MEMORY.  */\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\f\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+#define EXIT_IGNORE_STACK 1\n+\n+#define EPILOGUE_USES(REGNO) epiphany_epilogue_uses (REGNO)\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+#define FUNCTION_PROFILER(FILE, LABELNO)\n+\n+/* Given an rtx for the frame pointer,\n+   return an rtx for the address of the frame.  */\n+#define FRAME_ADDR_RTX(frame) \\\n+  ((frame) == hard_frame_pointer_rtx ? arg_pointer_rtx : NULL)\n+\n+/* This is not only for dwarf unwind info, but also for the benefit of\n+   df-scan.c to tell it that LR is live at the function start.  */\n+#define INCOMING_RETURN_ADDR_RTX \\\n+  gen_rtx_REG (Pmode, \\\n+\t       (current_function_decl != NULL \\\n+\t\t&& epiphany_is_interrupt_p (current_function_decl) \\\n+\t       ? IRET_REGNUM : GPR_LR))\n+\n+/* However, we haven't implemented the rest needed for dwarf2 unwind info.  */\n+#define DWARF2_UNWIND_INFO 0\n+\n+#define RETURN_ADDR_RTX(count, frame) \\\n+  (count ? NULL_RTX \\\n+   : gen_rtx_UNSPEC (SImode, gen_rtvec (1, const0_rtx), UNSPEC_RETURN_ADDR))\n+\f\n+/* Trampolines.\n+   An epiphany trampoline looks like this:\n+   mov r16,%low(fnaddr)\n+   movt r16,%high(fnaddr)\n+   mov ip,%low(cxt)\n+   movt ip,%high(cxt)\n+   jr r16  */\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+#define TRAMPOLINE_SIZE 20\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* We have post_modify (load/store with update).  */\n+#define HAVE_POST_INCREMENT TARGET_POST_INC\n+#define HAVE_POST_DECREMENT TARGET_POST_INC\n+#define HAVE_POST_MODIFY_DISP TARGET_POST_MODIFY\n+#define HAVE_POST_MODIFY_REG TARGET_POST_MODIFY\n+\n+/* Recognize any constant value that is a valid address.  */\n+#define CONSTANT_ADDRESS_P(X) \\\n+(GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\\\n+ || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST)\n+\n+#define RTX_OK_FOR_OFFSET_P(MODE, X) \\\n+  RTX_OK_FOR_OFFSET_1 (GET_MODE_CLASS (MODE) == MODE_VECTOR_INT \\\n+\t\t       && epiphany_vect_align == 4 ? SImode : (MODE), X)\n+#define RTX_OK_FOR_OFFSET_1(MODE, X) \\\n+  (GET_CODE (X) == CONST_INT \\\n+   && !(INTVAL (X) & (GET_MODE_SIZE (MODE) - 1)) \\\n+   && INTVAL (X) >= -2047 * (int) GET_MODE_SIZE (MODE) \\\n+   && INTVAL (X) <=  2047 * (int) GET_MODE_SIZE (MODE))\n+\n+/* Frame offsets cannot be evaluated till the frame pointer is eliminated.  */\n+#define RTX_FRAME_OFFSET_P(X) \\\n+  ((X) == frame_pointer_rtx \\\n+   || (GET_CODE (X) == PLUS && XEXP ((X), 0) == frame_pointer_rtx \\\n+       && CONST_INT_P (XEXP ((X), 1))))\n+\f\n+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n+   return the mode to be used for the comparison.  */\n+#define SELECT_CC_MODE(OP, X, Y) \\\n+  epiphany_select_cc_mode (OP, X, Y)\n+\n+/* Return nonzero if SELECT_CC_MODE will never return MODE for a\n+   floating point inequality comparison.  */\n+\n+#define REVERSE_CONDITION(CODE, MODE) \\\n+  ((MODE) == CC_FPmode || (MODE) == CC_FP_EQmode || (MODE) == CC_FP_GTEmode \\\n+   || (MODE) == CC_FP_ORDmode || (MODE) == CC_FP_UNEQmode \\\n+   ? reverse_condition_maybe_unordered (CODE) \\\n+   : (MODE) == CCmode ? reverse_condition (CODE) \\\n+   : UNKNOWN)\n+\n+/* We can reverse all CCmodes with REVERSE_CONDITION.  */\n+#define REVERSIBLE_CC_MODE(MODE) \\\n+  ((MODE) == CCmode || (MODE) == CC_FPmode || (MODE) == CC_FP_EQmode \\\n+   || (MODE) == CC_FP_GTEmode || (MODE) == CC_FP_ORDmode \\\n+   || (MODE) == CC_FP_UNEQmode)\n+\f\n+/* Costs.  */\n+\n+/* The cost of a branch insn.  */\n+/* ??? What's the right value here?  Branches are certainly more\n+   expensive than reg->reg moves.  */\n+#define BRANCH_COST(speed_p, predictable_p) \\\n+  (speed_p ? epiphany_branch_cost : 1)\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.\n+   For RISC chips, it means that access to memory by bytes is no\n+   better than access by words when possible, so grab a whole word\n+   and maybe make use of that.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* Define this macro if it is as good or better to call a constant\n+   function address than to call an address kept in a register.  */\n+/* On the EPIPHANY, calling through registers is slow.  */\n+#define NO_FUNCTION_CSE\n+\f\n+/* Section selection.  */\n+/* WARNING: These section names also appear in dwarf2out.c.  */\n+\n+#define TEXT_SECTION_ASM_OP\t\"\\t.section .text\"\n+#define DATA_SECTION_ASM_OP\t\"\\t.section .data\"\n+\n+#undef  READONLY_DATA_SECTION_ASM_OP\n+#define READONLY_DATA_SECTION_ASM_OP\t\"\\t.section .rodata\"\n+\n+#define BSS_SECTION_ASM_OP\t\"\\t.section .bss\"\n+\n+/* Define this macro if jump tables (for tablejump insns) should be\n+   output in the text section, along with the assembler instructions.\n+   Otherwise, the readonly data section is used.\n+   This macro is irrelevant if there is no separate readonly data section.  */\n+#define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)\n+\f\n+/* PIC */\n+\n+/* The register number of the register used to address a table of static\n+   data addresses in memory.  In some cases this register is defined by a\n+   processor's ``application binary interface'' (ABI).  When this macro\n+   is defined, RTL is generated for this register once, as with the stack\n+   pointer and frame pointer registers.  If this macro is not defined, it\n+   is up to the machine-dependent files to allocate such a register (if\n+   necessary).  */\n+#define PIC_OFFSET_TABLE_REGNUM  (flag_pic ? PIC_REGNO : INVALID_REGNUM)\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* A C string constant describing how to begin a comment in the target\n+   assembler language.  The compiler assumes that the comment will\n+   end at the end of the line.  */\n+#define ASM_COMMENT_START \";\"\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+#define ASM_APP_ON \"\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+#define ASM_APP_OFF \"\"\n+\n+/* Globalizing directive for a label.  */\n+#define GLOBAL_ASM_OP \"\\t.global\\t\"\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  \"r0\",  \"r1\",  \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",\t\\\n+  \"r8\",  \"r9\",  \"r10\", \"fp\",  \"ip\",  \"sp\",  \"lr\",  \"r15\",\t\\\n+  \"r16\",  \"r17\",\"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\t\\\n+  \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\",\t\\\n+  \"r32\", \"r33\", \"r34\", \"r35\", \"r36\", \"r37\", \"r38\", \"r39\",\t\\\n+  \"r40\", \"r41\", \"r42\", \"r43\", \"r44\", \"r45\", \"r46\", \"r47\",\t\\\n+  \"r48\", \"r49\", \"r50\", \"r51\", \"r52\", \"r53\", \"r54\", \"r55\",\t\\\n+  \"r56\", \"r57\", \"r58\", \"r59\", \"r60\", \"r61\", \"r62\", \"r63\",\t\\\n+  \"ap\",  \"sfp\", \"cc1\", \"cc2\",\t\t\t\t\t\\\n+  \"config\", \"status\", \"lc\", \"ls\", \"le\", \"iret\",\t\t\t\\\n+  \"fp_near\", \"fp_trunc\", \"fp_anyfp\", \"unknown\"\t\t\t\\\n+}\n+\n+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) \\\n+  epiphany_final_prescan_insn (INSN, OPVEC, NOPERANDS)\n+\n+#define LOCAL_LABEL_PREFIX  \".\"\n+\n+/* A C expression which evaluates to true if CODE is a valid\n+   punctuation character for use in the `PRINT_OPERAND' macro.  */\n+extern char epiphany_punct_chars[256];\n+#define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n+  epiphany_punct_chars[(unsigned char) (CHAR)]\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+do { \\\n+  if (CASE_VECTOR_MODE == Pmode) \\\n+    asm_fprintf ((FILE), \"\\t.word %LL%d\\n\", (VALUE)); \\\n+  else \\\n+    asm_fprintf ((FILE), \"\\t.short %LL%d\\n\", (VALUE)); \\\n+} while (0)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n+do {\t\t\t\t\t\t\t\\\n+  if (CASE_VECTOR_MODE == Pmode) \\\n+    asm_fprintf ((FILE), \"\\t.word\"); \\\n+  else \\\n+    asm_fprintf ((FILE), \"\\t.short\"); \\\n+  asm_fprintf ((FILE), \" %LL%d-%LL%d\\n\", (VALUE), (REL)); \\\n+} while (0)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+#define ASM_OUTPUT_ALIGN(FILE,LOG) \\\n+do { if ((LOG) != 0) fprintf (FILE, \"\\t.balign %d\\n\", 1 << (LOG)); } while (0)\n+\f\n+/* Debugging information.  */\n+\n+/* Generate DBX and DWARF debugging information.  */\n+#define DBX_DEBUGGING_INFO 1\n+\n+#undef PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+\n+/* Turn off splitting of long stabs.  */\n+#define DBX_CONTIN_LENGTH 0\n+\f\n+/* Miscellaneous.  */\n+\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE (TARGET_SMALL16 && optimize_size ? HImode : Pmode)\n+\n+/* Define if operations between registers always perform the operation\n+   on the full register even if a narrower mode is specified.  */\n+#define WORD_REGISTER_OPERATIONS\n+\n+/* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n+   will either zero-extend or sign-extend.  The value of this macro should\n+   be the code that says which one of the two operations is implicitly\n+   done, UNKNOWN if none.  */\n+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 8\n+\n+/* Define this to be nonzero if shift instructions ignore all but the low-order\n+   few bits.  */\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+\n+#define Pmode SImode\n+\n+/* A function address in a call instruction.  */\n+#define FUNCTION_MODE SImode\n+\f\n+/* EPIPHANY function types.  */\n+enum epiphany_function_type\n+{\n+  EPIPHANY_FUNCTION_UNKNOWN, EPIPHANY_FUNCTION_NORMAL,\n+  /* These are interrupt handlers.  The name corresponds to the register\n+     name that contains the return address.  */\n+  EPIPHANY_FUNCTION_ILINK1, EPIPHANY_FUNCTION_ILINK2,\n+  /* These are interrupt handlers. The name corresponds to which type\n+     of interrupt handler we're dealing with. */\n+  EPIPHANY_FUNCTION_RESET, EPIPHANY_FUNCTION_SOFTWARE_EXCEPTION,\n+  EPIPHANY_FUNCTION_TIMER, EPIPHANY_FUNCTION_DMA0,\n+  EPIPHANY_FUNCTION_DMA1, EPIPHANY_FUNCTION_STATIC_FLAG,\n+  EPIPHANY_FUNCTION_SWI\n+};\n+\n+#define EPIPHANY_INTERRUPT_P(TYPE) \\\n+  ((TYPE) >= EPIPHANY_FUNCTION_RESET && (TYPE) <= EPIPHANY_FUNCTION_SWI)\n+\n+/* Compute the type of a function from its DECL.  */\n+\n+#define IMMEDIATE_PREFIX \"#\"\n+\n+#define OPTIMIZE_MODE_SWITCHING(ENTITY) \\\n+  (epiphany_optimize_mode_switching (ENTITY))\n+\n+/* We have two fake entities for lazy code motion of the mask constants,\n+   one entity each for round-to-nearest / truncating\n+   with a different idea what FP_MODE_ROUND_UNKNOWN will be, and\n+   finally an entity that runs in a second mode switching pass to\n+   resolve FP_MODE_ROUND_UNKNOWN.  */\n+#define NUM_MODES_FOR_MODE_SWITCHING \\\n+  { 2, 2, FP_MODE_NONE, FP_MODE_NONE, FP_MODE_NONE, FP_MODE_NONE, FP_MODE_NONE }\n+\n+#define MODE_NEEDED(ENTITY, INSN) epiphany_mode_needed((ENTITY), (INSN))\n+\n+#define MODE_PRIORITY_TO_MODE(ENTITY, N) \\\n+  (epiphany_mode_priority_to_mode ((ENTITY), (N)))\n+\n+#define EMIT_MODE_SET(ENTITY, MODE, HARD_REGS_LIVE) \\\n+  emit_set_fp_mode ((ENTITY), (MODE), (HARD_REGS_LIVE))\n+\n+#define MODE_ENTRY(ENTITY) (epiphany_mode_entry_exit ((ENTITY), false))\n+#define MODE_EXIT(ENTITY) (epiphany_mode_entry_exit ((ENTITY), true))\n+#define MODE_AFTER(LAST_MODE, INSN) \\\n+  (epiphany_mode_after (e, (LAST_MODE), (INSN)))\n+\n+#define TARGET_INSERT_MODE_SWITCH_USE epiphany_insert_mode_switch_use\n+\n+/* Mode switching entities.  */\n+enum\n+{\n+  EPIPHANY_MSW_ENTITY_AND,\n+  EPIPHANY_MSW_ENTITY_OR,\n+  EPIPHANY_MSW_ENTITY_NEAREST,\n+  EPIPHANY_MSW_ENTITY_TRUNC,\n+  EPIPHANY_MSW_ENTITY_ROUND_UNKNOWN,\n+  EPIPHANY_MSW_ENTITY_ROUND_KNOWN,\n+  EPIPHANY_MSW_ENTITY_FPU_OMNIBUS\n+};\n+\n+extern int epiphany_normal_fp_rounding;\n+extern struct rtl_opt_pass pass_mode_switch_use;\n+extern struct rtl_opt_pass pass_resolve_sw_modes;\n+\n+/* This will need to be adjusted when FP_CONTRACT_ON is properly\n+   implemented.  */\n+#define TARGET_FUSED_MADD (flag_fp_contract_mode == FP_CONTRACT_FAST)\n+\n+#endif /* !GCC_EPIPHANY_H */"}, {"sha": "c8354e8eddb7cfd75c363cbc66d902c8eec1cb7f", "filename": "gcc/config/epiphany/epiphany.md", "status": "added", "additions": 2447, "deletions": 0, "changes": 2447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fepiphany.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fepiphany.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.md?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,2447 @@\n+;; Machine description of the Adaptiva epiphany cpu for GNU C compiler\n+;; Copyright (C) 1994, 1997, 1998, 1999, 2000, 2004, 2005, 2007, 2009, 2010,\n+;; 2011 Free Software Foundation, Inc.\n+;; Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\f\n+(define_constants\n+  [(GPR_0\t\t\t 0)\n+   (GPR_FP\t\t\t11)\n+   (GPR_IP\t\t\t12)\n+   (GPR_SP\t\t\t13)\n+   (GPR_LR\t\t\t14)\n+   (GPR_16\t\t\t16)\n+   (GPR_18\t\t\t18)\n+   (GPR_20\t\t\t20)\n+   (ARG_POINTER_REGNUM\t\t64)\n+   (FRAME_POINTER_REGNUM\t65)\n+   (CC_REGNUM\t\t\t66)   ;; 66 or 17\n+   (CCFP_REGNUM\t\t\t67)   ;; 67 or 18\n+   (CONFIG_REGNUM\t\t68)\n+   (STATUS_REGNUM\t\t69)\n+   (LC_REGNUM\t\t\t70)\n+   (LS_REGNUM\t\t\t71)\n+   (LE_REGNUM\t\t\t72)\n+   (IRET_REGNUM\t\t\t73)\n+   (FP_NEAREST_REGNUM\t\t74)\n+   (FP_TRUNCATE_REGNUM\t\t75)\n+   (FP_ANYFP_REGNUM\t\t76)\n+   (UNKNOWN_REGNUM\t\t77) ; used for addsi3_r and friends\n+   ; We represent the return address as an unspec rather than a reg.\n+   ; If we used a reg, we could use register elimination, but eliminating\n+   ; to GPR_LR would make the latter visible to dataflow, thus making it\n+   ; harder to determine when it must be saved.\n+   (UNSPEC_RETURN_ADDR\t\t 0)\n+   (UNSPEC_FP_MODE\t\t 1)\n+\n+   (UNSPECV_GID\t\t\t 0)\n+   (UNSPECV_GIE\t\t\t 1)])\n+\n+;; Insn type.  Used to default other attribute values.\n+\n+(define_attr \"type\"\n+  \"move,load,store,cmove,unary,compare,shift,mul,uncond_branch,branch,call,fp,fp_int,misc,sfunc,fp_sfunc,flow\"\n+  (const_string \"misc\"))\n+\n+;; Length (in # bytes)\n+\n+(define_attr \"length\" \"\" (const_int 4))\n+\n+;; The length here is the length of a single asm.\n+\n+(define_asm_attributes\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"misc\")])\n+\n+;; pipeline model; so far we have only one.\n+(define_attr \"pipe_model\" \"epiphany\" (const_string \"epiphany\"))\n+\n+(define_attr \"rounding\" \"trunc,nearest\"\n+  (cond [(ne (symbol_ref \"TARGET_ROUND_NEAREST\") (const_int 0))\n+\t (const_string \"nearest\")]\n+\t(const_string \"trunc\")))\n+\n+(define_attr \"fp_mode\" \"round_unknown,round_nearest,round_trunc,int,caller,none\"\n+  (cond [(eq_attr \"type\" \"fp,fp_sfunc\")\n+\t (symbol_ref \"(enum attr_fp_mode) epiphany_normal_fp_rounding\")\n+\t (eq_attr \"type\" \"call\")\n+\t (symbol_ref \"(enum attr_fp_mode) epiphany_normal_fp_mode\")\n+\t (eq_attr \"type\" \"fp_int\")\n+\t (const_string \"int\")]\n+\t(const_string \"none\")))\n+\n+(include \"epiphany-sched.md\")\n+\n+(include \"predicates.md\")\n+(include \"constraints.md\")\n+\n+;; modes that are held in a single register, and hence, a word.\n+(define_mode_iterator WMODE [SI SF HI QI V2HI V4QI])\n+(define_mode_iterator WMODE2 [SI SF HI QI V2HI V4QI])\n+\n+;; modes that are held in a two single registers\n+(define_mode_iterator DWMODE [DI DF V2SI V2SF V4HI V8QI])\n+\n+;; Double-word mode made up of two single-word mode values.\n+(define_mode_iterator DWV2MODE [V2SI V2SF])\n+(define_mode_attr vmode_part [(V2SI \"si\") (V2SF \"sf\")])\n+(define_mode_attr vmode_PART [(V2SI \"SI\") (V2SF \"SF\")])\n+(define_mode_attr vmode_fp_type [(V2SI \"fp_int\") (V2SF \"fp\")])\n+(define_mode_attr vmode_ccmode [(V2SI \"CC\") (V2SF \"CC_FP\")])\n+(define_mode_attr vmode_cc [(V2SI \"CC_REGNUM\") (V2SF \"CCFP_REGNUM\")])\n+\n+;; Move instructions.\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:WMODE 0 \"general_operand\" \"\")\n+\t(match_operand:WMODE 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  if (<MODE>mode == V4QImode || <MODE>mode == V2HImode)\n+    {\n+      operands[0] = simplify_gen_subreg (SImode, operands[0], <MODE>mode, 0);\n+      operands[1] = simplify_gen_subreg (SImode, operands[1], <MODE>mode, 0);\n+      emit_insn (gen_movsi (operands[0], operands[1]));\n+      DONE;\n+    }\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (<MODE>mode, operands[1]);\n+  if (<MODE>mode == SImode\n+      && (operands[1] == frame_pointer_rtx || operands[1] == arg_pointer_rtx))\n+    {\n+      rtx reg = operands[0];\n+\n+      if (!REG_P (reg))\n+\treg = gen_reg_rtx (SImode);\n+      emit_insn (gen_move_frame (reg, operands[1]));\n+      operands[1] = reg;\n+      if (operands[0] == reg)\n+\tDONE;\n+    }\n+})\n+\n+(define_insn \"*movqi_insn\"\n+  [(set (match_operand:QI 0 \"move_dest_operand\" \"=Rcs,   r,  r,r,m\")\n+\t(match_operand:QI 1 \"move_src_operand\"   \"Rcs,rU16,Cal,m,r\"))]\n+;; ??? Needed?\n+  \"gpr_operand (operands[0], QImode)\n+   || gpr_operand (operands[1], QImode)\"\n+  \"@\n+   mov %0,%1\n+   mov %0,%1\n+   mov %0,%1\n+   ldrb %0,%1\n+   strb %1,%0\"\n+  [(set_attr \"type\" \"move,move,move,load,store\")])\n+\n+(define_insn_and_split \"*movhi_insn\"\n+  [(set (match_operand:HI 0 \"move_dest_operand\" \"=r,  r,r,m\")\n+\t(match_operand:HI 1 \"move_src_operand\"\"rU16,Cal,m,r\"))]\n+  \"gpr_operand (operands[0], HImode)\n+   || gpr_operand (operands[1], HImode)\"\n+  \"@\n+   mov %0,%1\n+   mov %0,%%low(%1); %1\n+   ldrh %0,%c1\n+   strh %1,%c0\"\n+  \"reload_completed && CONSTANT_P (operands[1])\n+   && !satisfies_constraint_U16 (operands[1]) && TARGET_SPLIT_LOHI\"\n+  [(set (match_dup 2) (match_dup 3))]\n+  \"operands[2] = simplify_gen_subreg (SImode, operands[0], HImode, 0);\n+   operands[3] = simplify_gen_subreg (SImode, operands[1], HImode, 0);\"\n+  [(set_attr \"type\" \"move,move,load,store\")])\n+\n+;; We use a special pattern for a move from the frame pointer to\n+;; show the flag clobber that is needed when this move is changed\n+;; to an add by register elimination.\n+;; ??? A pseudo register might be equivalent to a function invariant,\n+;; and thus placed by reload into reg_equiv_invariant; if the pseudo\n+;; does not get a hard register, we then end up with the function\n+;; invariant in its place, i.e. an unexpected clobber of the flags\n+;; register.\n+;;\n+;; N.B. operand 1 is an operand so that reload will perform elimination.\n+;;\n+;; The post-reload pattern recognition and splitting is done in frame_move_1.\n+(define_insn \"move_frame\"\n+  [(set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+\t(match_operand:SI 1 \"register_operand\" \"r\"))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"operands[1] == frame_pointer_rtx || operands[1] == arg_pointer_rtx\"\n+  \"#\")\n+\n+(define_insn \"movsi_high\"\n+  [(set (match_operand:SI 0 \"gpr_operand\" \"+r\")\n+\t(ior:SI (and:SI (match_dup 0) (const_int 65535))\n+\t\t(high:SI (match_operand:SI 1 \"move_src_operand\" \"i\"))))]\n+  \"\"\n+  \"movt %0, %%high(%1)\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"movsi_lo_sum\"\n+  [(set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+\t(lo_sum:SI (const_int 0)\n+\t\t   (match_operand:SI 1 \"move_src_operand\" \"i\")))]\n+  \"\"\n+  \"mov %0, %%low(%1)\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn_and_split \"*movsi_insn\"\n+  [(set (match_operand:SI 0 \"move_dest_operand\"\n+\t \"=   r,  r,  r,  r,  r,   r,   m,  r,  Rct\")\n+\t(match_operand:SI 1 \"move_src_operand\"\n+\t \"rU16Rra,Cm1,Cl1,Cr1,Cal,mSra,rRra,Rct,r\"))]\n+  \"gpr_operand (operands[0], SImode)\n+   || gpr_operand (operands[1], SImode)\n+   || satisfies_constraint_Sra (operands[1])\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \"mov %0,%1\";\n+    case 1: return \"add %0,%-,(1+%1)\";\n+    case 2: operands[1] = GEN_INT (exact_log2 (-INTVAL (operands[1])));\n+      return \"lsl %0,%-,%1\";\n+    case 3: operands[1] = GEN_INT (32 - exact_log2 (INTVAL (operands[1]) + 1));\n+      return \"lsr %0,%-,%1\";\n+    case 4: return \"mov %0,%%low(%1)\\;movt %0,%%high(%1) ; %1\";\n+    case 5: return \"ldr %0,%C1\";\n+    case 6: return \"str %1,%C0\";\n+    case 7: return \"movfs %0,%1\";\n+    case 8: return \"movts %0,%1\";\n+    default: gcc_unreachable ();\n+    }\n+}\n+  \"reload_completed && CONSTANT_P (operands[1])\n+   && !satisfies_constraint_U16 (operands[1])\n+   && !satisfies_constraint_Cm1 (operands[1])\n+   && !satisfies_constraint_Cl1 (operands[1])\n+   && !satisfies_constraint_Cr1 (operands[1])\n+   && TARGET_SPLIT_LOHI\"\n+  [(match_dup 2) (match_dup 3)]\n+  \"operands[2] = gen_movsi_lo_sum (operands[0], operands[1]);\n+   operands[3] = gen_movsi_high (operands[0], operands[1]);\"\n+  [(set_attr \"type\" \"move,misc,misc,misc,move,load,store,flow,flow\")\n+   (set_attr \"length\" \"4,4,4,4,8,4,4,4,4\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\")\n+\t(unspec:SI [(const_int 0)] UNSPEC_RETURN_ADDR))]\n+  \"reload_completed && !MACHINE_FUNCTION (cfun)->lr_clobbered\"\n+  [(set (match_dup 0) (reg:SI GPR_LR))])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"gpr_operand\")\n+\t(unspec:SI [(const_int 0)] UNSPEC_RETURN_ADDR))]\n+  \"reload_completed\"\n+  [(set (match_dup 0) (match_dup 1))]\n+{\n+  emit_insn (gen_reload_insi_ra (operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_expand \"reload_insi_ra\"\n+  [(set (match_operand:SI 0 \"gpr_operand\" \"r\") (match_operand:SI 1 \"\" \"Sra\"))]\n+  \"\"\n+{\n+  rtx addr\n+    = (frame_pointer_needed ? hard_frame_pointer_rtx : stack_pointer_rtx);\n+\n+  addr = plus_constant (addr, MACHINE_FUNCTION (cfun)->lr_slot_offset);\n+  operands[1] = gen_frame_mem (SImode, addr);\n+})\n+\n+;; If the frame pointer elimination offset is zero, we'll use this pattern.\n+;; Note that the splitter can accept any gpr in operands[1]; this is\n+;; necessary, (e.g. for compile/20021015-1.c -O0,)\n+;; because when register elimination cannot be done with the constant\n+;; as an immediate operand of the add instruction, reload will resort to\n+;; loading the constant into a reload register, using gen_add2_insn to add\n+;; the stack pointer, and then use the reload register as new source in\n+;; the move_frame pattern.\n+(define_insn_and_split \"*move_frame_1\"\n+  [(set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+\t(match_operand:SI 1 \"gpr_operand\" \"r\"))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"(reload_in_progress || reload_completed)\n+   && (operands[1] == stack_pointer_rtx\n+       || operands[1] == hard_frame_pointer_rtx)\"\n+  \"#\"\n+  \"reload_in_progress || reload_completed\"\n+  [(set (match_dup 0) (match_dup 1))])\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:DWMODE 0 \"general_operand\" \"\")\n+\t(match_operand:DWMODE 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE_CLASS (<MODE>mode) == MODE_VECTOR_INT\n+      || GET_MODE_CLASS (<MODE>mode) == MODE_VECTOR_FLOAT)\n+    {\n+      if (epiphany_vect_align == 4 && TARGET_SPLIT_VECMOVE_EARLY)\n+\t{\n+\t  rtx o0l, o0h, o1l, o1h;\n+\n+\t  o0l = simplify_gen_subreg (SImode, operands[0], <MODE>mode, 0);\n+\t  o0h = simplify_gen_subreg (SImode, operands[0], <MODE>mode,\n+\t\t\t\t     UNITS_PER_WORD);\n+\t  o1l = simplify_gen_subreg (SImode, operands[1], <MODE>mode, 0);\n+\t  o1h = simplify_gen_subreg (SImode, operands[1], <MODE>mode,\n+\t\t\t\t     UNITS_PER_WORD);\n+\t  if (reg_overlap_mentioned_p (o0l, o1h))\n+\t    {\n+\t      emit_move_insn (o0h, o1h);\n+\t      emit_move_insn (o0l, o1l);\n+\t    }\n+\t  else\n+\t    {\n+\t      emit_move_insn (o0l, o1l);\n+\t      emit_move_insn (o0h, o1h);\n+\t    }\n+\t  DONE;\n+\t}\n+      /* lower_subreg has a tendency to muck up vectorized code.\n+\t To protect the wide memory accesses, we must use same-size\n+\t subregs.  */\n+      if (epiphany_vect_align != 4 /* == 8 */\n+\t  && !reload_in_progress\n+\t  && (GET_CODE (operands[0]) == MEM || GET_CODE (operands[1]) == MEM)\n+\t  && (GET_CODE (operands[0]) != SUBREG\n+\t      || (GET_MODE_SIZE (GET_MODE (SUBREG_REG (operands[0])))\n+\t\t  != GET_MODE_SIZE (<MODE>mode)\n+\t\t  && GET_CODE (operands[1]) != SUBREG)))\n+\t{\n+\t  operands[0]\n+\t    = simplify_gen_subreg (DImode, operands[0], <MODE>mode, 0);\n+\t  operands[1]\n+\t    = simplify_gen_subreg (DImode, operands[1], <MODE>mode, 0);\n+\t  emit_insn (gen_movdi (operands[0], operands[1]));\n+\t  DONE;\n+\t}\n+    }\n+  /* Everything except mem = const or mem = mem can be done easily.  */\n+\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (<MODE>mode, operands[1]);\n+}\")\n+\n+(define_insn_and_split \"*mov<mode>_insn\"\n+  [(set (match_operand:DWMODE 0 \"move_dest_operand\"      \"=r,   r,r,m\")\n+\t(match_operand:DWMODE 1 \"move_double_src_operand\" \"r,CalE,m,r\"))]\n+  \"(gpr_operand (operands[0], <MODE>mode)\n+    || gpr_operand (operands[1], <MODE>mode))\"\n+  \"@\n+   #\n+   #\n+   ldrd %0,%X1\n+   strd %1,%X0\"\n+  \"reload_completed\n+   && ((!MEM_P (operands[0]) && !MEM_P (operands[1]))\n+       || epiphany_vect_align == 4)\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+{\n+  int word0 = 0, word1 = UNITS_PER_WORD;\n+\n+  if (post_modify_operand (operands[0], <MODE>mode)\n+      || post_modify_operand (operands[1], <MODE>mode))\n+    word0 = UNITS_PER_WORD, word1 = 0;\n+\n+  operands[2] = simplify_gen_subreg (SImode, operands[0], <MODE>mode, word0);\n+  operands[3] = simplify_gen_subreg (SImode, operands[1], <MODE>mode, word0);\n+  operands[4] = simplify_gen_subreg (SImode, operands[0], <MODE>mode, word1);\n+  operands[5] = simplify_gen_subreg (SImode, operands[1], <MODE>mode, word1);\n+  if (post_modify_operand (operands[0], <MODE>mode))\n+    operands[2]\n+      = change_address (operands[2], VOIDmode,\n+\t\t\tplus_constant (XEXP (XEXP (operands[0], 0), 0),\n+\t\t\t\t       UNITS_PER_WORD));\n+  if (post_modify_operand (operands[1], <MODE>mode))\n+    operands[3]\n+      = change_address (operands[3], VOIDmode,\n+\t\t\tplus_constant (XEXP (XEXP (operands[1], 0), 0),\n+\t\t\t\t       UNITS_PER_WORD));\n+}\n+  [(set_attr \"type\" \"move,move,load,store\")\n+   (set_attr \"length\" \"8,16,4,4\")])\n+\n+\n+(define_insn_and_split \"*movsf_insn\"\n+  [(set (match_operand:SF 0 \"move_dest_operand\" \"=r,r,r,m\")\n+\t(match_operand:SF 1 \"move_src_operand\"   \"r,E,m,r\"))]\n+  \"gpr_operand (operands[0], SFmode)\n+   || gpr_operand (operands[1], SFmode)\"\n+  \"@\n+   mov %0,%1\n+   mov %0,%%low(%1)\\;movt %0,%%high(%1) ; %1\n+   ldr %0,%C1\n+   str %1,%C0\"\n+  \"reload_completed && CONSTANT_P (operands[1]) && TARGET_SPLIT_LOHI\"\n+  [(set (match_dup 2) (match_dup 3))]\n+  \"operands[2] = simplify_gen_subreg (SImode, operands[0], SFmode, 0);\n+   operands[3] = simplify_gen_subreg (SImode, operands[1], SFmode, 0);\"\n+  [(set_attr \"type\" \"move,move,load,store\")\n+   (set_attr \"length\" \"4,8,4,4\")])\n+\n+(define_expand \"addsi3\"\n+  [(set (match_operand:SI 0 \"add_reg_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"add_reg_operand\" \"\")\n+\t\t (match_operand:SI 2 \"add_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (reload_in_progress || reload_completed)\n+    emit_insn (gen_addsi3_r (operands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_addsi3_i (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_insn \"addsi3_i\"\n+  [(set (match_operand:SI 0 \"add_reg_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"add_reg_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"add_operand\" \"rL\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"add %0,%1,%2\"\n+[(set_attr \"type\" \"misc\")])\n+\n+; We use a clobber of UNKNOWN_REGNUM here so that the peephole optimizers\n+; can identify the unresolved flags clobber problem, and also to\n+; avoid unwanted matches.\n+;\n+; At -O0 / -O1 we don't peephole all instances away.  We could get better\n+; debug unwinding through the emitted code if we added a splitter.\n+(define_insn \"addsi3_r\"\n+  [(set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"gpr_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rCar\")))\n+   (clobber (reg:CC UNKNOWN_REGNUM))]\n+  \"reload_in_progress || reload_completed\"\n+{\n+  int scratch = (0x17\n+\t\t ^ (true_regnum (operands[0]) & 1)\n+\t\t ^ (true_regnum (operands[1]) & 2)\n+\t\t ^ (true_regnum (operands[2]) & 4));\n+  asm_fprintf (asm_out_file, \"\\tstr r%d,[sp,#0]\\n\", scratch);\n+  asm_fprintf (asm_out_file, \"\\tmovfs r%d,status\\n\", scratch);\n+  output_asm_insn (\"add %0,%1,%2\", operands);\n+  asm_fprintf (asm_out_file, \"\\tmovts status,r%d\\n\", scratch);\n+  asm_fprintf (asm_out_file, \"\\tldr r%d,[sp,#0]\\n\", scratch);\n+  return \"\";\n+}\n+  [(set_attr \"length\" \"20\")\n+   (set_attr \"type\" \"misc\")])\n+\n+;; reload uses gen_addsi2 because it doesn't understand the need for\n+;; the clobber.\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"gpr_operand\" \"\")\n+\t(match_operand:SI 1 \"const_int_operand\" \"\"))\n+   (parallel [(set (match_dup 0)\n+\t\t   (plus:SI (match_dup 0)\n+\t\t\t    (match_operand:SI 2 \"gpr_operand\")))\n+\t      (clobber (reg:CC UNKNOWN_REGNUM))])]\n+  \"satisfies_constraint_L (operands[1])\n+   || ((operands[2] == stack_pointer_rtx\n+\t|| (operands[2] == hard_frame_pointer_rtx && frame_pointer_needed))\n+       && !peep2_regno_dead_p (2, CC_REGNUM)\n+       && satisfies_constraint_Car (operands[1]))\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (plus:SI (match_dup 2) (match_dup 1)))\n+\t      (clobber (reg:CC UNKNOWN_REGNUM))])]\n+  ;; FIXME:\n+  ;; need this patch: http://gcc.gnu.org/ml/gcc-patches/2011-10/msg02819.html\n+  ;; \"peep2_rescan = true;\"\n+)\n+\n+(define_peephole2\n+  [(match_parallel 5 \"\"\n+     [(set (match_operand 3 \"cc_operand\" \"\") (match_operand 4 \"\" \"\"))])\n+   (parallel [(set (match_operand:SI 0 \"gpr_operand\" \"\")\n+\t\t   (plus:SI (match_operand:SI 1 \"gpr_operand\" \"\")\n+\t\t\t    (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (reg:CC UNKNOWN_REGNUM))])]\n+  \"REGNO (operands[3]) == CC_REGNUM\n+   && (gpr_operand (operands[2], SImode)\n+       || satisfies_constraint_L (operands[2]))\n+   && !reg_overlap_mentioned_p (operands[0], operands[5])\n+   && !reg_set_p (operands[1], operands[5])\n+   && !reg_set_p (operands[2], operands[5])\"\n+  [(parallel [(set (match_operand:SI 0 \"gpr_operand\" \"\")\n+\t\t   (plus:SI (match_operand:SI 1 \"gpr_operand\" \"\")\n+\t\t\t    (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (reg:CC CC_REGNUM))])\n+   (match_dup 5)]\n+  \"\")\n+\n+(define_peephole2\n+  [(parallel [(set (match_operand:SI 0 \"gpr_operand\" \"\")\n+\t\t   (plus:SI (match_operand:SI 1 \"gpr_operand\" \"\")\n+\t\t\t    (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (reg:CC UNKNOWN_REGNUM))])]\n+  \"peep2_regno_dead_p (1, CC_REGNUM)\n+   && (gpr_operand (operands[2], SImode)\n+       || satisfies_constraint_L (operands[2]))\"\n+  [(parallel [(set (match_operand:SI 0 \"gpr_operand\" \"\")\n+\t\t   (plus:SI (match_operand:SI 1 \"gpr_operand\" \"\")\n+\t\t\t    (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+\n+(define_peephole2\n+  [(parallel [(set (match_operand:SI 0 \"gpr_operand\" \"\")\n+\t\t   (plus:SI (reg:SI GPR_SP)\n+\t\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"\")))\n+\t      (clobber (reg:CC UNKNOWN_REGNUM))])]\n+  \"(REG_P (operands[1]) && !reg_overlap_mentioned_p (operands[0], operands[1]))\n+   || RTX_OK_FOR_OFFSET_P (<MODE>mode, operands[1])\"\n+  [(set (match_dup 0) (reg:SI GPR_SP))\n+   (set (mem:WMODE (post_modify (match_dup 0)\n+\t\t\t\t(plus:SI (match_dup 0) (match_dup 1))))\n+\t(reg:WMODE GPR_SP))]\n+  \"\")\n+\n+\n+\n+(define_peephole2\n+  [(parallel [(set (match_operand:SI 0 \"gpr_operand\" \"\")\n+\t\t   (plus:SI (reg:SI GPR_FP)\n+\t\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"\")))\n+\t      (clobber (reg:CC UNKNOWN_REGNUM))])\n+   (match_scratch:WMODE 2 \"r\")]\n+  \"frame_pointer_needed\n+   && ((REG_P (operands[1])\n+\t&& !reg_overlap_mentioned_p (operands[0], operands[1]))\n+       || RTX_OK_FOR_OFFSET_P (<MODE>mode, operands[1]))\"\n+  [(set (match_dup 0) (reg:SI GPR_FP))\n+   (set (match_dup 2)\n+\t(mem:WMODE (post_modify (match_dup 0)\n+\t\t\t\t(plus:SI (match_dup 0) (match_dup 1)))))]\n+  \"\")\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"add_reg_operand\" \"r\")\n+\t\t  (match_operand:SI 2 \"arith_operand\" \"rL\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"sub %0,%1,%2\"\n+  [(set_attr \"type\" \"misc\")])\n+\n+; After mode-switching, floating point operations, fp_sfuncs and calls\n+; must exhibit the use of the control register, lest the setting of the\n+; control register could be deleted or moved.  OTOH a use of a hard register\n+; greatly coundounds optimizers like the rtl loop optimizers or combine.\n+; Therefore, we put an extra pass immediately after the mode switching pass\n+; that inserts the USEs of the control registers, and sets a flag in struct\n+; machine_function that float_operation can henceforth only match with that\n+; USE.\n+\n+;; Addition\n+(define_expand \"addsf3\"\n+  [(parallel\n+     [(set (match_operand:SF 0 \"gpr_operand\" \"\")\n+\t   (plus:SF (match_operand:SF 1 \"gpr_operand\" \"\")\n+\t\t    (match_operand:SF 2 \"gpr_operand\" \"\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])])\n+\n+(define_insn \"*addsf3_i\"\n+  [(match_parallel 3 \"float_operation\"\n+     [(set (match_operand:SF 0 \"gpr_operand\" \"=r\")\n+\t   (plus:SF (match_operand:SF 1 \"gpr_operand\" \"%r\")\n+\t\t    (match_operand:SF 2 \"gpr_operand\" \"r\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"fadd %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+;; Subtraction\n+(define_expand \"subsf3\"\n+  [(parallel\n+     [(set (match_operand:SF 0 \"gpr_operand\" \"\")\n+\t   (minus:SF (match_operand:SF 1 \"gpr_operand\" \"\")\n+\t\t     (match_operand:SF 2 \"gpr_operand\" \"\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])])\n+\n+(define_insn \"*subsf3_i\"\n+  [(match_parallel 3 \"float_operation\"\n+     [(set (match_operand:SF 0 \"gpr_operand\" \"=r\")\n+\t   (minus:SF (match_operand:SF 1 \"gpr_operand\" \"r\")\n+\t\t     (match_operand:SF 2 \"gpr_operand\" \"r\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"fsub %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_expand \"subsf3_f\"\n+  [(parallel\n+     [(set (reg:CC_FP CCFP_REGNUM)\n+\t   (compare:CC_FP (match_operand:SF 1 \"gpr_operand\" \"r\")\n+\t\t\t  (match_operand:SF 2 \"gpr_operand\" \"r\")))\n+      (set (match_operand:SF 0 \"gpr_operand\" \"=r\")\n+\t   (minus:SF (match_dup 1) (match_dup 2)))])]\n+  \"!TARGET_SOFT_CMPSF\")\n+\n+(define_insn \"*subsf3_f_i\"\n+  [(match_parallel 3 \"float_operation\"\n+     [(set (reg:CC_FP CCFP_REGNUM)\n+\t   (compare:CC_FP (match_operand:SF 1 \"gpr_operand\" \"r\")\n+\t\t\t  (match_operand:SF 2 \"gpr_operand\" \"r\")))\n+      (set (match_operand:SF 0 \"gpr_operand\" \"=r\")\n+\t   (minus:SF (match_dup 1) (match_dup 2)))])]\n+  \"!TARGET_SOFT_CMPSF\"\n+  \"fsub %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+; There is an fabs instruction, but it has longer latency.\n+(define_expand \"abssf2\"\n+  [(set (match_operand:SF 0 \"gpr_operand\" \"\")\n+\t(abs:SF (match_operand:SF 1 \"gpr_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx op1 = copy_to_mode_reg (SImode, simplify_gen_subreg (SImode, operands[1],\n+\t\t\t\t\t\t\t   SFmode, 0));\n+  rtx op0 = simplify_gen_subreg (SImode, operands[0], SFmode, 0);\n+\n+  emit_insn (gen_ashlsi3 (op1, op1, const1_rtx));\n+  emit_insn (gen_lshrsi3 (op0, op1, const1_rtx));\n+  DONE;\n+}\")\n+\n+;; Multiplication\n+(define_expand \"mulsf3\"\n+  [(parallel\n+     [(set (match_operand:SF 0 \"gpr_operand\" \"\")\n+\t   (mult:SF (match_operand:SF 1 \"gpr_operand\" \"\")\n+\t\t    (match_operand:SF 2 \"gpr_operand\" \"\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])])\n+\n+(define_insn \"*mulsf3_i\"\n+  [(match_parallel 3 \"float_operation\"\n+     [(set (match_operand:SF 0 \"gpr_operand\" \"=r\")\n+\t   (mult:SF (match_operand:SF 1 \"gpr_operand\" \"%r\")\n+\t\t    (match_operand:SF 2 \"gpr_operand\" \"r\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"fmul %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+;; Division\n+(define_expand \"divsf3\"\n+  [(set (match_operand:SF 0 \"gpr_operand\" \"\")\n+\t(div:SF (match_operand:SF 1 \"gpr_operand\" \"\")\n+\t\t(match_operand:SF 2 \"gpr_operand\" \"\")))]\n+  \"flag_reciprocal_math\"\n+{\n+  rtx one = CONST1_RTX (SFmode);\n+  rtx dst = operands[0];\n+\n+  if (rtx_equal_p (dst, operands[1]))\n+    {\n+      emit_move_insn (dst, one);\n+      DONE;\n+    }\n+  else if (!register_operand (dst, SFmode) && can_create_pseudo_p ())\n+    dst = gen_reg_rtx (SFmode);\n+  emit_insn (gen_recipsf2 (dst, one, operands[2],\n+\t\t\t   sfunc_symbol (\\\"__fast_recipsf2\\\")));\n+  emit_insn (gen_mulsf3 (operands[0], operands[1], dst));\n+  DONE;\n+})\n+\n+;; Before reload, keep the hard reg usage to clobbers so that the loop\n+;; optimizers can more easily move this insn.\n+;; It would be nicer to use a constraint for a GPR_0 - only register class,\n+;; but sched1 can still cause trouble then, and there is no guarantee of\n+;; better register allocations.\n+;; Neither is there when using the opposite strategy - putting explicit\n+;; hard register references into pre-reload rtl.\n+(define_expand \"recipsf2\"\n+  [(parallel\n+     [(set (match_operand:SF 0 \"gpr_operand\" \"\")\n+\t   (div:SF (match_operand:SF 1 \"const_float_1_operand\" \"\")\n+\t\t   (match_operand:SF 2 \"move_src_operand\" \"\")))\n+      (use (match_operand:SI 3 \"move_src_operand\" \"\"))\n+      (clobber (reg:SF 0))\n+      (clobber (reg:SI 1))\n+      (clobber (reg:SF GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:DI GPR_18))\n+      (clobber (reg:SI GPR_20))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])])\n+\n+(define_insn_and_split \"*recipsf2_1\"\n+  [(match_parallel 4 \"float_operation\"\n+     [(set (match_operand:SF 0 \"gpr_operand\" \"=r,r\")\n+\t   (div:SF (match_operand:SF 1 \"const_float_1_operand\" \"\")\n+\t\t   (match_operand:SF 2 \"move_src_operand\" \"rU16m,rU16mCal\")))\n+      (use (match_operand:SI 3 \"move_src_operand\" \"rU16m,rU16mCal\"))\n+      (clobber (reg:SF 0))\n+      (clobber (reg:SI 1))\n+      (clobber (reg:SF GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:DI GPR_18))\n+      (clobber (reg:SI GPR_20))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"flag_reciprocal_math\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (reg:SI 1) (match_dup 3))\n+   (set (reg:SF 0) (match_dup 2))\n+   (parallel\n+     [(set (reg:SF 0)\n+\t   (div:SF (match_dup 1)\n+\t\t   (reg:SF 0)))\n+      (use (reg:SI 1))\n+      (clobber (reg:SI GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:DI GPR_18))\n+      (clobber (reg:SI GPR_20))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))\n+      (match_dup 5)\n+      (match_dup 6)])\n+   (set (match_dup 0) (reg:SF 0))]\n+  \"operands[5] = XVECEXP (operands[4], 0, XVECLEN (operands[4], 0) - 2);\n+   operands[6] = XVECEXP (operands[4], 0, XVECLEN (operands[4], 0) - 1);\"\n+  [(set_attr \"type\" \"fp_sfunc\")\n+   (set_attr \"length\" \"16,24\")])\n+\n+(define_insn \"*recipsf2_2\"\n+  [(match_parallel 1 \"float_operation\"\n+     [(set (reg:SF 0)\n+\t   (div:SF (match_operand:SF 0 \"const_float_1_operand\" \"\")\n+\t\t   (reg:SF 0)))\n+      (use (reg:SI 1))\n+      (clobber (reg:SI GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:DI GPR_18))\n+      (clobber (reg:SI GPR_20))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"flag_reciprocal_math\"\n+  \"jalr r1\"\n+  [(set_attr \"type\" \"fp_sfunc\")])\n+\n+\n+;; Fused multiply-add\n+(define_expand \"fmasf4\"\n+  [(parallel\n+     [(set (match_operand:SF 0 \"gpr_operand\" \"\")\n+\t   (fma:SF (match_operand:SF 1 \"gpr_operand\" \"\")\n+\t\t   (match_operand:SF 2 \"gpr_operand\" \"\")\n+\t\t   (match_operand:SF 3 \"gpr_operand\" \"\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\")\n+\n+; The multiply operands are commutative, but since they have the\n+; same constraints, there is no point in telling reload about this.\n+(define_insn \"*fmadd\"\n+  [(match_parallel 4 \"float_operation\"\n+     [(set (match_operand:SF 0 \"gpr_operand\" \"=r\")\n+\t   (fma:SF (match_operand:SF 1 \"gpr_operand\" \"r\")\n+\t\t   (match_operand:SF 2 \"gpr_operand\" \"r\")\n+\t\t   (match_operand:SF 3 \"gpr_operand\" \"0\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"fmadd %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+; Once vetorization consistently works for this port, should check\n+; if the fmadd / fmsub patterns still serve a purpose.  With the\n+; introduction of fma / fnma handling by the SSA optimizers,\n+; at least scalars should be handled by these optimizers, would\n+; have to see how well they do on vectors from auto-vectorization.\n+;\n+; combiner pattern, also used by vector combiner pattern\n+(define_expand \"maddsf\"\n+  [(parallel\n+     [(set (match_operand:SF 0 \"gpr_operand\" \"=r\")\n+\t   (plus:SF (mult:SF (match_operand:SF 1 \"gpr_operand\" \"r\")\n+\t\t\t     (match_operand:SF 2 \"gpr_operand\" \"r\"))\n+\t\t    (match_operand:SF 3 \"gpr_operand\" \"0\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"TARGET_FUSED_MADD\")\n+\n+(define_insn \"*maddsf_combine\"\n+  [(match_parallel 4 \"float_operation\"\n+     [(set (match_operand:SF 0 \"gpr_operand\" \"=r\")\n+\t   (plus:SF (mult:SF (match_operand:SF 1 \"gpr_operand\" \"r\")\n+\t\t\t     (match_operand:SF 2 \"gpr_operand\" \"r\"))\n+\t\t    (match_operand:SF 3 \"gpr_operand\" \"0\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"TARGET_FUSED_MADD\"\n+  \"fmadd %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+;; Fused multiply-sub\n+(define_expand \"fnmasf4\"\n+  [(parallel\n+     [(set (match_operand:SF 0 \"gpr_operand\" \"\")\n+\t   (fma:SF (neg:SF (match_operand:SF 1 \"gpr_operand\" \"\"))\n+\t\t   (match_operand:SF 2 \"gpr_operand\" \"\")\n+\t\t   (match_operand:SF 3 \"gpr_operand\" \"\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*fmsub\"\n+  [(match_parallel 4 \"float_operation\"\n+     [(set (match_operand:SF 0 \"gpr_operand\" \"=r\")\n+\t   (fma:SF (neg:SF (match_operand:SF 1 \"gpr_operand\" \"r\"))\n+\t\t   (match_operand:SF 2 \"gpr_operand\" \"r\")\n+\t\t   (match_operand:SF 3 \"gpr_operand\" \"0\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"fmsub %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"*fmsub_combine\"\n+  [(match_parallel 4 \"float_operation\"\n+     [(set (match_operand:SF 0 \"gpr_operand\" \"=r\")\n+\t   (minus:SF  (match_operand:SF 3 \"gpr_operand\" \"0\")\n+\t\t      (mult:SF (match_operand:SF 1 \"gpr_operand\" \"r\")\n+\t\t\t       (match_operand:SF 2 \"gpr_operand\" \"r\"))))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"TARGET_FUSED_MADD\"\n+  \"fmsub %0,%1,%2\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+;; float / integer conversions\n+\n+(define_expand \"floatsisf2\"\n+  [(parallel\n+     [(set (match_operand:SF 0 \"gpr_operand\" \"\")\n+\t   (float:SF (match_operand:SI 1 \"gpr_operand\" \"\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])])\n+\n+(define_insn \"*floatsisf2_i\"\n+  [(match_parallel 2 \"float_operation\"\n+     [(set (match_operand:SF 0 \"gpr_operand\" \"=r\")\n+\t   (float:SF (match_operand:SI 1 \"gpr_operand\" \"r\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"float %0, %1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_expand \"floatsisf2_cmp\"\n+  [(parallel\n+     [(set (reg:CC_FP CCFP_REGNUM)\n+\t   (compare:CC_FP (float:SF (match_operand:SF 1 \"gpr_operand\" \"r\"))\n+\t\t\t  (match_dup 2)))\n+      (set (match_operand:SF 0 \"gpr_operand\" \"=r\")\n+\t   (float:SF (match_dup 1)))])]\n+  \"\"\n+  \"operands[2] = CONST0_RTX (SFmode);\")\n+\n+(define_insn \"*floatsisf2_cmp_i\"\n+  [(match_parallel 3 \"float_operation\"\n+     [(set (reg:CC_FP CCFP_REGNUM)\n+\t   (compare:CC_FP (float:SF (match_operand:SF 1 \"gpr_operand\" \"r\"))\n+\t\t\t  (match_operand:SF 2 \"const0_operand\" \"\")))\n+      (set (match_operand:SF 0 \"gpr_operand\" \"=r\")\n+\t   (float:SF (match_dup 1)))])]\n+  \"\"\n+  \"float %0, %1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_expand \"floatunssisf2\"\n+  [(set (match_operand:SF 0 \"gpr_operand\" \"\")\n+\t(float:SF (match_operand:SI 1 \"gpr_operand\" \"\")))]\n+  \"epiphany_normal_fp_rounding == /*FP_MODE_ROUND_TRUNC*/ 2\"\n+{\n+  rtx cst = force_reg (SImode, gen_int_mode (0xb0800000, SImode));\n+  rtx tmp = gen_reg_rtx (SImode);\n+  rtx cmp = gen_rtx_GTU (VOIDmode, gen_rtx_REG (CCmode, CC_REGNUM), const0_rtx);\n+\n+  if (reg_overlap_mentioned_p (operands[0], operands[1]))\n+    operands[1] = copy_to_mode_reg (SImode, operands[1]);\n+  emit_insn (gen_floatsisf2 (operands[0], operands[1]));\n+  emit_insn (gen_ashrsi3 (tmp, operands[1], GEN_INT (8)));\n+  emit_insn (gen_sub_f (tmp, tmp, cst));\n+  emit_insn (gen_movsfcc (operands[0], cmp,\n+\t\t\t  simplify_gen_subreg (SFmode, tmp, SImode, 0),\n+\t\t\t  operands[0]));\n+  DONE;\n+})\n+\n+(define_expand \"fix_truncsfsi2\"\n+  [(parallel\n+     [(set (match_operand:SI 0 \"gpr_operand\" \"\")\n+\t   (fix:SI (match_operand:SF 1 \"gpr_operand\" \"\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])])\n+\n+(define_insn \"*fix_truncsfsi2_i\"\n+  [(match_parallel 2 \"float_operation\"\n+     [(set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+\t   (fix:SI (match_operand:SF 1 \"gpr_operand\" \"r\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"fix %0, %1\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_mode\" \"round_trunc\")])\n+\n+(define_expand \"fixuns_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"gpr_operand\" \"\")\n+\t(unsigned_fix:SI (match_operand:SF 1 \"gpr_operand\" \"\")))]\n+  \"\"\n+{\n+  if (reg_overlap_mentioned_p (operands[0], operands[1]))\n+    operands[1] = copy_to_mode_reg (SImode, operands[1]);\n+  if (TARGET_SOFT_CMPSF || optimize_function_for_speed_p (cfun))\n+    {\n+      rtx op1si;\n+      /* By toggling what it to be bit31 before the shift, we get a chance to\n+\t use a short movt insn.  */\n+      rtx bit31 = force_reg (SImode, GEN_INT (0x800000));\n+      rtx tmp = gen_reg_rtx (SImode);\n+      rtx limit = force_reg (SImode, gen_int_mode (0x4f000000, SImode));\n+      rtx cmp\n+\t= gen_rtx_GE (VOIDmode, gen_rtx_REG (CCmode, CC_REGNUM), const0_rtx);\n+\n+      op1si = simplify_gen_subreg (SImode, operands[1], SFmode, 0);\n+      emit_insn (gen_fix_truncsfsi2 (operands[0], operands[1]));\n+      emit_insn (gen_subsi3 (tmp, op1si, bit31));\n+      emit_insn (gen_ashlsi3 (tmp, tmp, GEN_INT (8)));\n+      emit_insn (gen_cmpsi_cc_insn (op1si, limit));\n+      emit_insn (gen_movsicc (operands[0], cmp, tmp, operands[0]));\n+    }\n+  else\n+    {\n+      REAL_VALUE_TYPE offset;\n+      rtx limit;\n+      rtx tmp = gen_reg_rtx (SFmode);\n+      rtx label = gen_label_rtx ();\n+      rtx bit31;\n+      rtx cc1 = gen_rtx_REG (CC_FPmode, CCFP_REGNUM);\n+      rtx cmp = gen_rtx_LT (VOIDmode, cc1, CONST0_RTX (SFmode));\n+\n+      real_2expN (&offset, 31, SFmode);\n+      limit = CONST_DOUBLE_FROM_REAL_VALUE (offset, SFmode);\n+      limit = force_reg (SFmode, limit);\n+      emit_insn (gen_fix_truncsfsi2 (operands[0], operands[1]));\n+      emit_insn (gen_subsf3_f (tmp, operands[1], limit));\n+      emit_jump_insn (gen_branch_insn (label, cmp, cc1));\n+      bit31 = force_reg (SImode, gen_int_mode (0x80000000, SImode));\n+      emit_insn (gen_fix_truncsfsi2 (operands[0], tmp));\n+      emit_insn (gen_xorsi3 (operands[0], operands[0], bit31));\n+      emit_label (label);\n+    }\n+  DONE;\n+})\n+\n+(define_insn \"*iadd\"\n+  [(match_parallel 3 \"float_operation\"\n+     [(set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+\t   (plus:SI (match_operand:SI 1 \"gpr_operand\" \"%r\")\n+\t\t    (match_operand:SI 2 \"gpr_operand\" \"r\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"iadd %0, %1, %2\"\n+  [(set_attr \"type\" \"fp_int\")])\n+\n+(define_insn \"*isub\"\n+  [(match_parallel 3 \"float_operation\"\n+     [(set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+\t   (minus:SI (match_operand:SI 1 \"gpr_operand\" \"r\")\n+\t\t     (match_operand:SI 2 \"gpr_operand\" \"r\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"isub %0, %1, %2\"\n+  [(set_attr \"type\" \"fp_int\")])\n+\n+(define_expand \"mulsi3\"\n+  [(parallel\n+     [(set (match_operand:SI 0 \"gpr_operand\" \"\")\n+\t   (mult:SI (match_operand:SI 1 \"gpr_operand\" \"\")\n+\t\t    (match_operand:SI 2 \"gpr_operand\" \"\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])])\n+\n+(define_insn \"*imul\"\n+  [(match_parallel 3 \"float_operation\"\n+     [(set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+\t   (mult:SI (match_operand:SI 1 \"gpr_operand\" \"%r\")\n+\t\t    (match_operand:SI 2 \"gpr_operand\" \"r\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"imul %0, %1, %2\"\n+  [(set_attr \"type\" \"fp_int\")])\n+\n+; combiner pattern, also used by vector combiner pattern\n+(define_expand \"maddsi\"\n+  [(parallel\n+     [(set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+\t   (plus:SI (mult:SI (match_operand:SI 1 \"gpr_operand\" \"r\")\n+\t\t\t     (match_operand:SI 2 \"gpr_operand\" \"r\"))\n+\t\t    (match_operand:SI 3 \"gpr_operand\" \"0\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*maddsi_combine\"\n+  [(match_parallel 4 \"float_operation\"\n+     [(set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+\t   (plus:SI (mult:SI (match_operand:SI 1 \"gpr_operand\" \"r\")\n+\t\t\t     (match_operand:SI 2 \"gpr_operand\" \"r\"))\n+\t\t    (match_operand:SI 3 \"gpr_operand\" \"0\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"imsub %0, %1, %2\"\n+  [(set_attr \"type\" \"fp_int\")])\n+\n+(define_insn \"*imsub\"\n+  [(match_parallel 4 \"float_operation\"\n+     [(set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+\t   (minus:SI (match_operand:SI 3 \"gpr_operand\" \"0\")\n+\t\t     (mult:SI (match_operand:SI 1 \"gpr_operand\" \"r\")\n+\t\t\t      (match_operand:SI 2 \"gpr_operand\" \"r\"))))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"imsub %0, %1, %2\"\n+  [(set_attr \"type\" \"fp_int\")])\n+\n+(define_expand \"divsi3\"\n+  [(parallel\n+     [(set (match_operand:SI 0 \"move_dest_operand\" \"\")\n+\t   (div:SI (match_operand:SI 1 \"move_src_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"move_src_operand\" \"\")))\n+      (use (match_dup 3))\n+      (clobber (reg:SI 0))\n+      (clobber (reg:SI 1))\n+      (clobber (reg:SI GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:DI GPR_18))\n+      (clobber (reg:SI GPR_20))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"operands[3] = sfunc_symbol (\\\"__divsi3\\\");\")\n+\n+;; Before reload, keep the hard reg usage to clobbers so that the loop\n+;; optimizers can more easily move this insn.\n+(define_insn_and_split \"*divsi3_1\"\n+  [(match_parallel 4 \"float_operation\"\n+     [(set (match_operand:SI 0 \"move_dest_operand\" \"=r,r\")\n+\t   (div:SI (match_operand:SI 1 \"move_src_operand\" \"rU16m,rU16mCal\")\n+\t\t   (match_operand:SI 2 \"move_src_operand\" \"rU16m,rU16mCal\")))\n+      (use (match_operand:SI 3 \"call_address_operand\" \"Csy,r\"))\n+      (clobber (reg:SI 0))\n+      (clobber (reg:SI 1))\n+      (clobber (reg:SI GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:DI GPR_18))\n+      (clobber (reg:SI GPR_20))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (reg:SI 0) (match_dup 1))\n+   (set (reg:SI 1) (match_dup 2))\n+   (parallel\n+     [(set (reg:SI 0) (div:SI (reg:SI 0) (reg:SI 1)))\n+      (use (match_dup 3))\n+      (clobber (reg:SI 1))\n+      (clobber (reg:SI GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:DI GPR_18))\n+      (clobber (reg:SI GPR_20))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))\n+      (match_dup 5)\n+      (match_dup 6)])\n+   (set (match_dup 0) (reg:SI 0))]\n+  \"operands[5] = XVECEXP (operands[4], 0, XVECLEN (operands[4], 0) - 2);\n+   operands[6] = XVECEXP (operands[4], 0, XVECLEN (operands[4], 0) - 1);\"\n+  [(set_attr \"type\" \"fp_sfunc\")\n+   (set_attr \"length\" \"16,24\")])\n+\n+(define_insn \"*divsi3_2\"\n+  [(match_parallel 1 \"float_operation\"\n+     [(set (reg:SI 0) (div:SI (reg:SI 0) (reg:SI 1)))\n+      (use (match_operand:SI 0 \"call_address_operand\" \"Csy,r\"))\n+      (clobber (reg:SI 1))\n+      (clobber (reg:SI GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:DI GPR_18))\n+      (clobber (reg:SI GPR_20))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"%f0\"\n+  [(set_attr \"type\" \"fp_sfunc\")])\n+\n+(define_expand \"udivsi3\"\n+  [(parallel\n+     [(set (match_operand:SI 0 \"move_dest_operand\" \"\")\n+\t   (udiv:SI (match_operand:SI 1 \"move_src_operand\" \"\")\n+\t\t    (match_operand:SI 2 \"move_src_operand\" \"\")))\n+      (use (match_dup 3))\n+      (clobber (reg:SI 0))\n+      (clobber (reg:SI 1))\n+      (clobber (reg:SI GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:SI GPR_18))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"operands[3] = sfunc_symbol (\\\"__udivsi3\\\");\")\n+\n+;; Before reload, keep the hard reg usage to clobbers so that the loop\n+;; optimizers can more easily move this insn.\n+(define_insn_and_split \"*udivsi3_1\"\n+  [(match_parallel 4 \"float_operation\"\n+     [(set (match_operand:SI 0 \"move_dest_operand\" \"=r,r\")\n+\t   (udiv:SI (match_operand:SI 1 \"move_src_operand\" \"rU16m,rU16mCal\")\n+\t\t    (match_operand:SI 2 \"move_src_operand\" \"rU16m,rU16mCal\")))\n+      (use (match_operand:SI 3 \"call_address_operand\" \"Csy,r\"))\n+      (clobber (reg:SI 0))\n+      (clobber (reg:SI 1))\n+      (clobber (reg:SI GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:SI GPR_18))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (reg:SI 0) (match_dup 1))\n+   (set (reg:SI 1) (match_dup 2))\n+   (parallel\n+     [(set (reg:SI 0) (udiv:SI (reg:SI 0) (reg:SI 1)))\n+      (use (match_dup 3))\n+      (clobber (reg:SI 1))\n+      (clobber (reg:SI GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:SI GPR_18))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))\n+      (match_dup 5)\n+      (match_dup 6)])\n+   (set (match_dup 0) (reg:SI 0))]\n+  \"operands[5] = XVECEXP (operands[4], 0, XVECLEN (operands[4], 0) - 2);\n+   operands[6] = XVECEXP (operands[4], 0, XVECLEN (operands[4], 0) - 1);\"\n+  [(set_attr \"type\" \"fp_sfunc\")\n+   (set_attr \"length\" \"16,24\")])\n+\n+(define_insn \"*udivsi3_2\"\n+  [(match_parallel 1 \"float_operation\"\n+     [(set (reg:SI 0) (udiv:SI (reg:SI 0) (reg:SI 1)))\n+      (use (match_operand:SI 0 \"call_address_operand\" \"Csy,r\"))\n+      (clobber (reg:SI 1))\n+      (clobber (reg:SI GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:SI GPR_18))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"%f0\"\n+  [(set_attr \"type\" \"fp_sfunc\")])\n+\n+(define_expand \"modsi3\"\n+  [(parallel\n+     [(set (match_operand:SI 0 \"move_dest_operand\" \"\")\n+\t   (mod:SI (match_operand:SI 1 \"move_src_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"move_src_operand\" \"\")))\n+      (use (match_dup 3))\n+      (clobber (reg:SI 0))\n+      (clobber (reg:SI 1))\n+      (clobber (reg:SI 2))\n+      (clobber (reg:SI GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:DI GPR_18))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"operands[3] = sfunc_symbol (\\\"__modsi3\\\");\")\n+\n+;; Before reload, keep the hard reg usage to clobbers so that the loop\n+;; optimizers can more easily move this insn.\n+(define_insn_and_split \"*modsi3_1\"\n+  [(match_parallel 4 \"float_operation\"\n+     [(set (match_operand:SI 0 \"move_dest_operand\" \"=r,r\")\n+\t   (mod:SI (match_operand:SI 1 \"move_src_operand\" \"rU16m,rU16mCal\")\n+\t\t   (match_operand:SI 2 \"move_src_operand\" \"rU16m,rU16mCal\")))\n+      (use (match_operand:SI 3 \"call_address_operand\" \"Csy,r\"))\n+      (clobber (reg:SI 0))\n+      (clobber (reg:SI 1))\n+      (clobber (reg:SI 2))\n+      (clobber (reg:SI GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:DI GPR_18))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (reg:SI 0) (match_dup 1))\n+   (set (reg:SI 1) (match_dup 2))\n+   (parallel\n+     [(set (reg:SI 0) (mod:SI (reg:SI 0) (reg:SI 1)))\n+      (use (match_dup 3))\n+      (clobber (reg:SI 2))\n+      (clobber (reg:SI GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:DI GPR_18))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))\n+      (match_dup 5)\n+      (match_dup 6)])\n+   (set (match_dup 0) (reg:SI 0))]\n+  \"operands[5] = XVECEXP (operands[4], 0, XVECLEN (operands[4], 0) - 2);\n+   operands[6] = XVECEXP (operands[4], 0, XVECLEN (operands[4], 0) - 1);\"\n+  [(set_attr \"type\" \"fp_sfunc\")\n+   (set_attr \"length\" \"16,24\")])\n+\n+(define_insn \"*modsi3_2\"\n+  [(match_parallel 1 \"float_operation\"\n+     [(set (reg:SI 0) (mod:SI (reg:SI 0) (reg:SI 1)))\n+      (use (match_operand:SI 0 \"call_address_operand\" \"Csy,r\"))\n+      (clobber (reg:SI 2))\n+      (clobber (reg:SI GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:DI GPR_18))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"%f0\"\n+  [(set_attr \"type\" \"fp_sfunc\")])\n+\n+(define_expand \"umodsi3\"\n+  [(parallel\n+     [(set (match_operand:SI 0 \"move_dest_operand\" \"\")\n+\t   (umod:SI (match_operand:SI 1 \"move_src_operand\" \"\")\n+\t\t    (match_operand:SI 2 \"move_src_operand\" \"\")))\n+      (use (match_dup 3))\n+      (clobber (reg:SI 0))\n+      (clobber (reg:SI 1))\n+      (clobber (reg:SI 2))\n+      (clobber (reg:SI GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"operands[3] = sfunc_symbol (\\\"__umodsi3\\\");\")\n+\n+;; Before reload, keep the hard reg usage to clobbers so that the loop\n+;; optimizers can more easily move this insn.\n+(define_insn_and_split \"*umodsi3_1\"\n+  [(match_parallel 4 \"float_operation\"\n+     [(set (match_operand:SI 0 \"move_dest_operand\" \"=r,r\")\n+\t   (umod:SI (match_operand:SI 1 \"move_src_operand\" \"rU16m,rU16mCal\")\n+\t\t    (match_operand:SI 2 \"move_src_operand\" \"rU16m,rU16mCal\")))\n+      (use (match_operand:SI 3 \"call_address_operand\" \"Csy,r\"))\n+      (clobber (reg:SI 0))\n+      (clobber (reg:SI 1))\n+      (clobber (reg:SI 2))\n+      (clobber (reg:SI GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (reg:SI 0) (match_dup 1))\n+   (set (reg:SI 1) (match_dup 2))\n+   (parallel\n+     [(set (reg:SI 0) (umod:SI (reg:SI 0) (reg:SI 1)))\n+      (use (match_dup 3))\n+      (clobber (reg:SI 2))\n+      (clobber (reg:SI GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))\n+      (match_dup 5)\n+      (match_dup 6)])\n+   (set (match_dup 0) (reg:SI 0))]\n+  \"operands[5] = XVECEXP (operands[4], 0, XVECLEN (operands[4], 0) - 2);\n+   operands[6] = XVECEXP (operands[4], 0, XVECLEN (operands[4], 0) - 1);\"\n+  [(set_attr \"type\" \"fp_sfunc\")\n+   (set_attr \"length\" \"16,24\")])\n+\n+(define_insn \"*umodsi3_2\"\n+  [(match_parallel 1 \"float_operation\"\n+     [(set (reg:SI 0) (umod:SI (reg:SI 0) (reg:SI 1)))\n+      (use (match_operand:SI 0 \"call_address_operand\" \"Csy,r\"))\n+      (clobber (reg:SI 2))\n+      (clobber (reg:SI GPR_IP))\n+      (clobber (reg:DI GPR_16))\n+      (clobber (reg:SI GPR_LR))\n+      (clobber (reg:CC CC_REGNUM))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"%f0\"\n+  [(set_attr \"type\" \"fp_sfunc\")])\n+\n+; Disable interrupts.\n+; Any earlier values read from CONFIG_REGNUM are out of date, since interrupts\n+; might have changed settings that we do not want to mess with.\n+(define_insn \"gid\"\n+  [(set (reg:SI CONFIG_REGNUM)\n+\t(unspec_volatile:SI [(const_int 0)] UNSPECV_GID))]\n+  \"\"\n+  \"gid\"\n+  [(set_attr \"type\" \"flow\")])\n+\n+; Enable interrupts.\n+; Present CONTROL_REGNUM here to make sure it is live before the\n+; actual uses in floating point insns / calls are inserted.\n+; FWIW, interrupts also do mind what is in the control register.\n+(define_insn \"gie\"\n+  [(unspec_volatile [(reg:SI CONFIG_REGNUM)] UNSPECV_GIE)]\n+  \"\"\n+  \"gie\"\n+  [(set_attr \"type\" \"flow\")])\n+\n+; Floating point instructions require manipulating the control register.\n+; Manipulating the control register needs aritmetic.\n+; Arithmetic clobbers flags.\n+; The flags are in the status register, which also contains the alternate\n+; flag and the interrupt enable/disable bits.\n+; saving/restoring status and mixing up the order with gid/gie could\n+; lead to disaster.\n+; Usually, saving/restoring the status is unnecessary, and will be optimized\n+; away.  But when we really need it, we must make sure that we don't change\n+; anything but the flags.\n+; N.B.: We could make the constant easier to load by inverting it, but\n+; then we'd need to clobber the saved value - and that would make optimizing\n+; away unneeded saves/restores harder / less likely.\n+(define_expand \"movcc\"\n+  [(parallel [(set (match_operand:CC 0 \"cc_move_operand\"  \"\")\n+\t\t   (match_operand:CC 1 \"cc_move_operand\" \"\"))\n+\t      (use (match_dup 2))\n+\t      (clobber (match_scratch:SI 3                 \"=X, &r\"))])]\n+  \"\"\n+  \"operands[2] = gen_int_mode (~0x10f0, SImode);\")\n+\n+(define_insn \"*movcc_i\"\n+  [(set (match_operand:CC 0 \"cc_move_operand\"  \"=r,Rcc\")\n+\t(match_operand:CC 1 \"cc_move_operand\" \"Rcc,  r\"))\n+   (use (match_operand:SI 2 \"nonmemory_operand\"  \"X,  r\"))\n+   (clobber (match_scratch:SI 3                 \"=X, &r\"))]\n+  \"\"\n+  \"@\n+   movfs %0,status\n+   movfs %3,status\\;eor %3,%3,%1\\;and %3,%3,%2\\;eor %3,%3,%1\\;movts status,%3\"\n+  [(set_attr \"type\" \"flow\")\n+   (set_attr \"length\" \"20,4\")])\n+\n+(define_insn_and_split \"set_fp_mode\"\n+  [(set (reg:SI FP_NEAREST_REGNUM)\n+\t(match_operand:SI 0 \"set_fp_mode_operand\" \"rCfm\"))\n+   (set (reg:SI FP_TRUNCATE_REGNUM) (match_dup 0))\n+   (set (reg:SI FP_ANYFP_REGNUM)\n+\t(match_operand:SI 1 \"set_fp_mode_operand\" \"rCfm\"))\n+   (use (match_operand:SI 2 \"gpr_operand\" \"r\"))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (match_scratch:SI 3 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed || !rtx_equal_p (operands[0], operands[1])\"\n+  [(const_int 0)]\n+{\n+  if (!reload_completed)\n+    emit_note (NOTE_INSN_DELETED);\n+  else\n+    epiphany_expand_set_fp_mode (operands);\n+  DONE;\n+})\n+\n+\n+;; Boolean instructions.\n+;;\n+;; We don't define the DImode versions as expand_binop does a good enough job.\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+\t(and:SI (match_operand:SI 1 \"gpr_operand\" \"r\")\n+\t\t(match_operand:SI 2 \"gpr_operand\" \"r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"and %0,%1,%2\")\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+\t(ior:SI (match_operand:SI 1 \"gpr_operand\" \"r\")\n+\t\t(match_operand:SI 2 \"gpr_operand\" \"r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"orr %0,%1,%2\")\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+\t(xor:SI (match_operand:SI 1 \"gpr_operand\" \"r\")\n+\t\t(match_operand:SI 2 \"gpr_operand\" \"r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"eor %0,%1,%2\")\n+\n+(define_expand \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"gpr_operand\" \"\")\n+\t(xor:SI (match_operand:SI 1 \"gpr_operand\" \"\")\n+\t\t(match_dup 2)))]\n+  \"\"\n+{\n+  if (epiphany_m1reg >= 0)\n+    emit_insn (gen_one_cmplsi2_i (operands[0], operands[1]));\n+  else\n+    emit_insn (gen_xorsi3 (operands[0], operands[1],\n+\t\t\t   force_reg (SImode, GEN_INT (-1))));\n+  DONE;\n+})\n+\n+; Note that folding this pattern into the xorsi3 pattern would make combine\n+; less effective.\n+(define_insn \"one_cmplsi2_i\"\n+  [(set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+        (not:SI (match_operand:SI 1 \"gpr_operand\" \"r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"epiphany_m1reg >= 0\"\n+  \"eor %0,%1,%-\")\n+\n+;; Shift instructions.\n+;; In principle we could support arbitrary symbolic values as shift constant\n+;; (truncating the value appropriately), but that would require a suitable\n+;; relocation and assembler & linker support.\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"gpr_operand\" \"=r,r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"gpr_operand\" \"r,r\")\n+\t\t     (match_operand:SI 2 \"arith_operand\" \"r,K\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"asr %0,%1,%2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"shift\")])\n+\n+(define_insn \"ashrsi3_tst\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC\n+\t  (ashiftrt:SI (match_operand:SI 1 \"gpr_operand\" \"r,r\")\n+\t\t       (match_operand:SI 2 \"arith_operand\" \"r,K\"))\n+\t(const_int 0)))\n+   (set (match_operand:SI 0 \"gpr_operand\" \"=r,r\")\n+\t(ashiftrt:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"asr %0,%1,%2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"shift\")])\n+\n+;; Logical Shift Right\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"gpr_operand\" \"=r,r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"gpr_operand\" \"r,r\")\n+\t\t     (match_operand:SI 2 \"arith_operand\" \"r,K\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"lsr %0,%1,%2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"shift\")])\n+\n+(define_insn \"lshrsi3_tst\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC\n+\t  (lshiftrt:SI (match_operand:SI 1 \"gpr_operand\" \"r,r\")\n+\t\t       (match_operand:SI 2 \"arith_operand\" \"r,K\"))\n+\t(const_int 0)))\n+   (set (match_operand:SI 0 \"gpr_operand\" \"=r,r\")\n+\t(lshiftrt:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"lsr %0,%1,%2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"shift\")])\n+\n+;; Logical/Arithmetic Shift Left\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"gpr_operand\" \"=r,r\")\n+\t(ashift:SI (match_operand:SI 1 \"gpr_operand\" \"r,r\")\n+\t\t   (match_operand:SI 2 \"arith_operand\" \"r,K\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"lsl %0,%1,%2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"shift\")])\n+\n+(define_insn \"*ashlsi_btst\"\n+  [(set (reg:CC_N_NE CC_REGNUM)\n+\t(compare:CC_N_NE\n+\t  (zero_extract:SI (match_operand:SI 1 \"gpr_operand\" \"r\")\n+\t\t\t   (const_int 1)\n+\t\t\t   (match_operand 2 \"const_int_operand\" \"K\"))\n+\t  (const_int 0)))\n+   (clobber (match_scratch:SI 0 \"=r\"))]\n+  \"\"\n+{\n+  rtx xop[3];\n+\n+  xop[0] = operands[0];\n+  xop[1] = operands[1];\n+  xop[2] = GEN_INT (31-INTVAL (operands[2]));\n+  output_asm_insn (\"lsl %0,%1,%2\", xop);\n+  return \"\";\n+})\n+\n+;; zero extensions\n+(define_insn_and_split \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"r,m\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"@\n+   #\n+   ldrb %0,%1\"\n+  \"reload_completed\n+   ? true_regnum (operands[1]) >= 0\n+   : REG_P (operands[1]) && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\"\n+  [(parallel [(set (match_dup 0) (ashift:SI (match_dup 2) (const_int 24)))\n+\t      (clobber (reg:CC CC_REGNUM))])\n+   (parallel [(set (match_dup 0) (lshiftrt:SI (match_dup 0) (const_int 24)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"operands[2] = simplify_gen_subreg (SImode, operands[1], QImode, 0);\")\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"0,m\")))]\n+  \"\"\n+  \"@\n+   movt %0, 0\n+   ldrh %0,%c1\")\n+\n+\n+;; Compare instructions.\n+\n+(define_insn \"cmpsi_cc_insn\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC (match_operand:SI 0 \"add_reg_operand\" \"r,r\")\n+\t\t    (match_operand:SI 1 \"arith_operand\" \"r,L\")))\n+   (clobber (match_scratch:SI 2 \"=r,r\"))]\n+  \"\"\n+  \"sub %2,%0,%1\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"sub_f\"\n+  [(set (reg:CC CC_REGNUM)\n+        (compare:CC (match_operand:SI 1 \"gpr_operand\"  \"r,r\")\n+                    (match_operand:SI 2 \"arith_operand\" \"r,L\")))\n+   (set (match_operand:SI 0 \"gpr_operand\" \"=r,r\")\n+        (minus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"sub %0,%1,%2\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"*sub_f_add_imm\"\n+  [(set (reg:CC CC_REGNUM)\n+        (compare:CC (match_operand:SI 1 \"gpr_operand\"  \"r\")\n+                    (match_operand:SI 2 \"arith_int_operand\" \"L\")))\n+   (set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+        (plus:SI (match_dup 1) (match_operand:SI 3 \"const_int_operand\" \"L\")))]\n+  \"INTVAL (operands[2]) == -INTVAL (operands[3])\"\n+  \"sub %0,%1,%2\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_expand \"abssi2\"\n+  [(set (match_dup 2) (const_int 0))\n+   (parallel [(set (reg:CC CC_REGNUM)\n+\t\t   (compare:CC (match_dup 2)\n+\t\t\t       (match_operand:SI 1 \"nonmemory_operand\" \"\")))\n+\t      (set (match_dup 3)\n+\t\t   (minus:SI (match_dup 2) (match_dup 1)))])\n+   (set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+\t(if_then_else:SI (gt:SI (reg:CC CC_REGNUM) (const_int 0))\n+\t\t\t (match_dup 3)\n+\t\t\t (match_dup 1)))]\n+  \"TARGET_CMOVE\"\n+  \"operands[2] = gen_reg_rtx (SImode); operands[3] = gen_reg_rtx (SImode);\")\n+\n+(define_insn \"*add_c\"\n+  [(set (reg:CC_C_LTU CC_REGNUM)\n+        (compare:CC_C_LTU\n+\t  (plus:SI (match_operand:SI 1 \"gpr_operand\" \"%r,r\")\n+\t\t   (match_operand:SI 2 \"arith_operand\" \"r,L\"))\n+\t  (match_dup 1)))\n+   (set (match_operand:SI 0 \"gpr_operand\" \"=r,r\")\n+        (plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"add %0,%1,%2\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"*add_c_rev\"\n+  [(set (reg:CC_C_LTU CC_REGNUM)\n+        (compare:CC_C_LTU\n+\t  (plus:SI (match_operand:SI 1 \"gpr_operand\" \"%r,r\")\n+\t\t   (match_operand:SI 2 \"arith_operand\" \"r,L\"))\n+\t  (match_dup 1)))\n+   (set (match_operand:SI 0 \"gpr_operand\" \"=r,r\")\n+        (plus:SI (match_dup 2) (match_dup 1)))]\n+  \"\"\n+  \"add %0,%1,%2\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"*sub_c\"\n+  [(set (reg:CC_C_GTU CC_REGNUM)\n+        (compare:CC_C_GTU\n+\t  (minus:SI (match_operand:SI 1 \"gpr_operand\"  \"r,r\")\n+\t\t    (match_operand:SI 2 \"arith_operand\" \"r,L\"))\n+\t  (match_dup 1)))\n+   (set (match_operand:SI 0 \"gpr_operand\" \"=r,r\")\n+        (minus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"sub %0,%1,%2\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"*sub_c_void\"\n+  [(set (reg:CC_C_GTU CC_REGNUM)\n+        (compare:CC_C_GTU\n+\t  (minus:SI (match_operand:SI 1 \"gpr_operand\"  \"r,r\")\n+\t\t    (match_operand:SI 2 \"arith_operand\" \"r,L\"))\n+\t  (match_dup 1)))\n+   (clobber (match_scratch:SI 0 \"=r,r\"))]\n+  \"\"\n+  \"sub %0,%1,%2\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+; floating point comparisons\n+\n+(define_insn \"*cmpsf_cc_insn\"\n+  [(match_parallel 3 \"float_operation\"\n+     [(set (reg:CC_FP CCFP_REGNUM)\n+\t   (compare:CC_FP (match_operand:SF 0 \"gpr_operand\" \"r\")\n+\t\t\t  (match_operand:SF 1 \"gpr_operand\" \"r\")))\n+      (clobber (match_scratch:SF 2 \"=r\"))])]\n+  \"!TARGET_SOFT_CMPSF\"\n+  \"fsub %2,%0,%1\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"fp_mode\" \"round_unknown\")])\n+\n+;; ??? do we have to relax the operand0 predicate to immediate_operand\n+;; to allow the rtl loop optimizer to generate comparisons?  OTOH\n+;; we want call_address_operand to enforce valid operands so that\n+;; combine won't do silly things, allowing instruction scheduling to do\n+;; a proper job.\n+(define_insn \"*cmpsf_eq\"\n+  [(set (reg:CC_FP_EQ CC_REGNUM) (compare:CC_FP_EQ (reg:SF 0) (reg:SF 1)))\n+   (use (match_operand:SI 0 \"call_address_operand\" \"Csy,r\"))\n+   (clobber (reg:SI GPR_IP))\n+   (clobber (reg:SI GPR_LR))]\n+  \"TARGET_SOFT_CMPSF\"\n+  \"%f0\"\n+  [(set_attr \"type\" \"sfunc\")])\n+\n+(define_insn \"*cmpsf_gte\"\n+  [(set (reg:CC_FP_GTE CC_REGNUM) (compare:CC_FP_GTE (reg:SF 0) (reg:SF 1)))\n+   (use (match_operand:SI 0 \"call_address_operand\" \"Csy,r\"))\n+   (clobber (reg:SI GPR_IP))\n+   (clobber (reg:SI GPR_LR))]\n+  \"TARGET_SOFT_CMPSF\"\n+  \"%f0\"\n+  [(set_attr \"type\" \"sfunc\")])\n+\n+(define_insn \"*cmpsf_ord\"\n+  [(set (reg:CC_FP_ORD CC_REGNUM) (compare:CC_FP_ORD (reg:SF 0) (reg:SF 1)))\n+   (use (match_operand:SI 0 \"call_address_operand\" \"Csy,r\"))\n+   (clobber (reg:SI GPR_IP))\n+   (clobber (reg:SI GPR_16))\n+   (clobber (reg:SI GPR_LR))]\n+  \"TARGET_SOFT_CMPSF\"\n+  \"%f0\"\n+  [(set_attr \"type\" \"sfunc\")])\n+\n+(define_insn \"*cmpsf_uneq\"\n+  [(set (reg:CC_FP_UNEQ CC_REGNUM) (compare:CC_FP_UNEQ (reg:SF 0) (reg:SF 1)))\n+   (use (match_operand:SI 0 \"call_address_operand\" \"Csy,r\"))\n+   (clobber (reg:SI GPR_IP))\n+   (clobber (reg:SI GPR_16))\n+   (clobber (reg:SI GPR_LR))]\n+  \"TARGET_SOFT_CMPSF\"\n+  \"%f0\"\n+  [(set_attr \"type\" \"sfunc\")])\n+\n+;; conditional moves\n+\n+(define_expand \"mov<mode>cc\"\n+  [(set (match_operand:WMODE 0 \"gpr_operand\" \"\")\n+\t(if_then_else:WMODE (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t    (match_operand:WMODE 2 \"gpr_operand\" \"\")\n+\t\t\t    (match_operand:WMODE 3 \"gpr_operand\" \"\")))]\n+  \"TARGET_CMOVE\"\n+{\n+  rtx cmp_op0 = XEXP (operands[1], 0);\n+  rtx cmp_op1 = XEXP (operands[1], 1);\n+  enum machine_mode cmp_in_mode;\n+  enum rtx_code code = GET_CODE (operands[1]);\n+\n+  cmp_in_mode = GET_MODE (cmp_op0);\n+  if (cmp_in_mode == VOIDmode)\n+    cmp_in_mode = GET_MODE (cmp_op0);\n+  if (cmp_in_mode == VOIDmode)\n+    cmp_in_mode = SImode;\n+  /* If the operands are a better match when reversed, swap them now.\n+     This allows combine to see the proper comparison codes.  */\n+  if (rtx_equal_p (operands[0], operands[2])\n+      && !rtx_equal_p (operands[0], operands[3]))\n+    {\n+      rtx tmp = operands[2]; operands[2] = operands[3]; operands[3] = tmp;\n+      code = (FLOAT_MODE_P (GET_MODE (cmp_op0))\n+\t      ? reverse_condition_maybe_unordered (code)\n+\t      : reverse_condition (code));\n+    }\n+\n+  if (proper_comparison_operator (operands[1], VOIDmode))\n+    operands[1] = gen_rtx_fmt_ee (code, cmp_in_mode, cmp_op0, cmp_op1);\n+  else\n+    {\n+      if (!currently_expanding_to_rtl)\n+\t{\n+\t  /* ???  It would seem safest to FAIL here, but that would defeat\n+\t     the purpose of having an if-conversion pass; its logic currently\n+\t     assumes that the backend should be safe to insert condition code\n+\t     setting instructions, as the same condition codes were presumably\n+\t     set by the if-conversion input code.  */\n+\t}\n+      /* What mode to give as first operand to gen_compare_reg here is\n+\t debatable.  VOIDmode would be minimalist; telling gen_compare_reg\n+\t to use the mode of CC_REGNUM (or putting it on the comparison\n+\t operator afterwards) is also a logical choice.  OTOH, by using\n+\t <MODE>mode, we have mode combine opportunities with flag setting\n+\t operations - if we get some.  */\n+      operands[1]\n+\t= gen_compare_reg (<MODE>mode, code, cmp_in_mode, cmp_op0, cmp_op1);\n+    }\n+})\n+\n+(define_insn \"*mov<mode>cc_insn\"\n+  [(set (match_operand:WMODE 0 \"gpr_operand\" \"=r\")\n+\t(if_then_else:WMODE (match_operator 3 \"proper_comparison_operator\"\n+\t\t\t      [(match_operand 4 \"cc_operand\") (const_int 0)])\n+\t\t\t    (match_operand:WMODE 1 \"gpr_operand\" \"r\")\n+\t\t\t    (match_operand:WMODE 2 \"gpr_operand\" \"0\")))]\n+  \"TARGET_CMOVE\"\n+  \"mov%d3 %0,%1\"\n+  [(set_attr \"type\" \"cmove\")])\n+\n+(define_peephole2\n+  [(parallel [(set (match_operand:WMODE 0 \"gpr_operand\" \"\")\n+\t\t   (match_operand:WMODE 1 \"\" \"\"))\n+\t      (clobber (match_operand 8 \"cc_operand\"))])\n+   (match_operand 2 \"\" \"\")\n+   (set (match_operand:WMODE2 3 \"gpr_operand\" \"\")\n+\t(match_operand:WMODE2 9 \"gpr_operand\" \"\"))\n+   (set (match_dup 3)\n+\t(if_then_else:WMODE2 (match_operator 5 \"proper_comparison_operator\"\n+\t\t\t       [(match_operand 6 \"cc_operand\")\n+\t\t\t\t(match_operand 7 \"const0_operand\")])\n+\t\t\t     (match_operand:WMODE2 4 \"nonmemory_operand\" \"\")\n+\t\t\t     (match_dup 3)))]\n+  \"REGNO (operands[0]) == REGNO (operands[9])\n+   && peep2_reg_dead_p (3, operands[0])\n+   && !reg_set_p (operands[0], operands[2])\n+   && !reg_set_p (operands[3], operands[2])\n+   && !reg_overlap_mentioned_p (operands[3], operands[2])\"\n+  [(parallel [(set (match_dup 10) (match_dup 1))\n+\t      (clobber (match_dup 8))])\n+   (match_dup 2)\n+   (set (match_dup 3)\n+\t(if_then_else:WMODE2 (match_dup 5) (match_dup 4) (match_dup 3)))]\n+{\n+  operands[10] = simplify_gen_subreg (<WMODE:MODE>mode, operands[3],\n+\t\t\t\t      <WMODE2:MODE>mode, 0);\n+  replace_rtx (operands[2], operands[9], operands[3]);\n+  replace_rtx (operands[2], operands[0], operands[10]);\n+  gcc_assert (!reg_overlap_mentioned_p (operands[0], operands[2]));\n+})\n+\n+(define_peephole2\n+  [(parallel [(set (match_operand 6 \"cc_operand\") (match_operand 2 \"\" \"\"))\n+\t      (set (match_operand:WMODE 0 \"gpr_operand\" \"\")\n+\t\t   (match_operand:WMODE 1 \"\" \"\"))])\n+   (set (match_operand:WMODE2 3 \"gpr_operand\" \"\")\n+\t(match_operand:WMODE2 4 \"gpr_operand\"))\n+   (set (match_dup 3)\n+\t(if_then_else:WMODE2 (match_operator 5 \"proper_comparison_operator\"\n+\t\t\t       [(match_dup 6)\n+\t\t\t       (match_operand:WMODE 7 \"const0_operand\")])\n+\t\t\t    (match_operand:WMODE2 8 \"gpr_operand\")\n+\t\t\t    (match_dup 3)))]\n+  \"REGNO (operands[0]) == REGNO (operands[8])\n+   && REVERSIBLE_CC_MODE (GET_MODE (operands[6]))\n+   && peep2_reg_dead_p (3, operands[6])\n+   && peep2_reg_dead_p (3, operands[0])\n+   && !reg_overlap_mentioned_p (operands[4], operands[3])\"\n+  [(parallel [(set (match_dup 6) (match_dup 2))\n+\t      (set (match_dup 9) (match_dup 1))])\n+   (set (match_dup 3)\n+\t(if_then_else:WMODE2 (match_dup 5) (match_dup 4) (match_dup 3)))]\n+  \"\n+{\n+  operands[5]\n+    = gen_rtx_fmt_ee (REVERSE_CONDITION (GET_CODE (operands[5]),\n+\t\t\t\t\t GET_MODE (operands[6])),\n+\t\t      GET_MODE (operands[5]), operands[6], operands[7]);\n+  operands[9] = simplify_gen_subreg (<WMODE:MODE>mode, operands[3],\n+\t\t\t\t     <WMODE2:MODE>mode, 0);\n+}\")\n+\n+;; These control RTL generation for conditional jump insns\n+\n+;; To signal to can_compare_p that the cbranchs?4 patterns work,\n+;; they must allow const0_rtx for both comparison operands\n+(define_expand \"cbranchsi4\"\n+  [(set (reg CC_REGNUM)\n+\t(compare (match_operand:SI 1 \"add_operand\" \"\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else\n+\t      (match_operator 0 \"ordered_comparison_operator\" [(reg CC_REGNUM)\n+\t\t\t\t\t\t\t       (const_int 0)])\n+\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"\"\n+{\n+  rtx cmp = gen_compare_reg (VOIDmode, GET_CODE (operands[0]), SImode,\n+\t\t\t     operands[1], operands[2]);\n+  emit_jump_insn (gen_branch_insn (operands[3], cmp, XEXP (cmp, 0)));\n+  DONE;\n+})\n+\n+(define_expand \"cbranchsf4\"\n+  [(set (reg CC_REGNUM)\n+\t(compare (match_operand:SF 1 \"arith_operand\" \"\")\n+\t\t (match_operand:SF 2 \"arith_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else\n+\t      (match_operator 0 \"comparison_operator\" [(reg CC_REGNUM)\n+\t\t\t\t\t\t       (const_int 0)])\n+\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"\"\n+{\n+  rtx cmp = gen_compare_reg (VOIDmode, GET_CODE (operands[0]), SFmode,\n+\t\t\t     operands[1], operands[2]);\n+  emit_jump_insn (gen_branch_insn (operands[3], cmp, XEXP (cmp, 0)));\n+  DONE;\n+})\n+\n+;; Now match both normal and inverted jump.\n+\n+(define_insn \"branch_insn\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"proper_comparison_operator\"\n+\t\t\t\t      [(match_operand 2 \"cc_operand\")\n+\t\t\t\t       (const_int 0)])\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"b%d1 %l0\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"*rev_branch_insn\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"proper_comparison_operator\"\n+\t\t\t\t      [(reg CC_REGNUM) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"b%D1 %l0\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+;; Unconditional and other jump instructions.\n+\n+(define_insn \"jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"b %l0\"\n+  [(set_attr \"type\" \"uncond_branch\")])\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"gpr_operand\" \"r\"))]\n+  \"\"\n+  \"jr %0\"\n+  [(set_attr \"type\" \"uncond_branch\")])\n+\n+(define_expand \"tablejump\"\n+  [(parallel [(set (pc) (match_operand:SI 0 \"gpr_operand\" \"\"))\n+              (use (label_ref (match_operand 1 \"\" \"\")))])]\n+  \"\"\n+{\n+  /* In PIC mode, the table entries are stored PC relative.\n+     Convert the relative address to an absolute address.  */\n+  if (flag_pic)\n+    {\n+      rtx op1 = gen_rtx_LABEL_REF (Pmode, operands[1]);\n+\n+      operands[0] = expand_simple_binop (Pmode, PLUS, operands[0],\n+\t\t\t\t\t op1, NULL_RTX, 0, OPTAB_DIRECT);\n+    }\n+})\n+\n+(define_insn \"*tablejump_internal\"\n+  [(set (pc) (match_operand:SI 0 \"gpr_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"jr %0;\"\n+  [(set_attr \"type\" \"uncond_branch\")])\n+\n+(define_insn \"*tablejump_hi_internal\"\n+  [(set (pc) (match_operand:HI 0 \"gpr_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"optimize_size && TARGET_SMALL16\"\n+  \"jr %0;\"\n+  [(set_attr \"type\" \"uncond_branch\")])\n+\n+\n+(define_expand \"call\"\n+  ;; operands[1] is stack_size_rtx\n+  ;; operands[2] is next_arg_register\n+  [(parallel [(call (match_operand:SI 0 \"call_operand\" \"\")\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t     (clobber (reg:SI GPR_LR))])]\n+  \"\"\n+{\n+  bool target_uninterruptible = epiphany_call_uninterruptible_p (operands[0]);\n+\n+  if (!call_operand (operands[1], VOIDmode))\n+    operands[0]\n+      = change_address (operands[0], VOIDmode,\n+\t\t\tcopy_to_mode_reg (Pmode, XEXP (operands[0], 0)));\n+  if (epiphany_uninterruptible_p (current_function_decl)\n+      != target_uninterruptible)\n+    {\n+      emit_insn (target_uninterruptible ? gen_gid (): gen_gie ());\n+      emit_call_insn\n+\t(gen_rtx_PARALLEL\n+\t  (VOIDmode,\n+\t   gen_rtvec (2, gen_rtx_CALL (VOIDmode, operands[0], operands[1]),\n+\t\t\t gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t  gen_rtx_REG (SImode, GPR_LR)))));\n+      emit_insn (target_uninterruptible ? gen_gie (): gen_gid ());\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"*call_i\"\n+  [(match_parallel 2 \"float_operation\"\n+     [(call (mem:SI (match_operand:SI 0 \"call_address_operand\" \"Csy,r\"))\n+\t    (match_operand 1 \"\" \"\"))\n+      (clobber (reg:SI GPR_LR))])]\n+  \"\"\n+  \"%f0\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"sibcall\"\n+  ;; operands[1] is stack_size_rtx\n+  ;; operands[2] is next_arg_register\n+  [(parallel [(call (match_operand:SI 0 \"call_operand\" \"\")\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t     (return)])]\n+  \"\"\n+{\n+  bool target_uninterruptible = epiphany_call_uninterruptible_p (operands[0]);\n+\n+  if (!call_operand (operands[1], VOIDmode))\n+    operands[0]\n+      = change_address (operands[0], VOIDmode,\n+\t\t\tcopy_to_mode_reg (Pmode, XEXP (operands[0], 0)));\n+  if (epiphany_uninterruptible_p (current_function_decl)\n+      != target_uninterruptible)\n+    {\n+      emit_insn (target_uninterruptible ? gen_gid (): gen_gie ());\n+      emit_call_insn\n+\t(gen_rtx_PARALLEL\n+\t  (VOIDmode,\n+\t   gen_rtvec (2, gen_rtx_CALL (VOIDmode, operands[0], operands[1]),\n+\t\t\t ret_rtx)));\n+      emit_insn (target_uninterruptible ? gen_gie (): gen_gid ());\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"*sibcall_i\"\n+  [(call (mem:SI (match_operand:SI 0 \"call_address_operand\" \"Csy,Rsc\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (return)]\n+  \"\"\n+  \"@\n+   b %0\n+   jr %0\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"call_value\"\n+  ;; operand 2 is stack_size_rtx\n+  ;; operand 3 is next_arg_register\n+  [(parallel [(set (match_operand 0 \"gpr_operand\" \"=r\")\n+\t\t   (call (match_operand:SI 1 \"call_operand\" \"\")\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t     (clobber (reg:SI GPR_LR))])]\n+  \"\"\n+{\n+  bool target_uninterruptible = epiphany_call_uninterruptible_p (operands[1]);\n+\n+  if (!call_operand (operands[1], VOIDmode))\n+    operands[1]\n+      = change_address (operands[1], VOIDmode,\n+\t\t\tcopy_to_mode_reg (Pmode, XEXP (operands[1], 0)));\n+  if (epiphany_uninterruptible_p (current_function_decl)\n+      != target_uninterruptible)\n+    {\n+      emit_insn (target_uninterruptible ? gen_gid (): gen_gie ());\n+      emit_call_insn\n+\t(gen_rtx_PARALLEL\n+\t  (VOIDmode,\n+\t   gen_rtvec (2, gen_rtx_SET\n+\t\t\t   (VOIDmode, operands[0],\n+\t\t\t    gen_rtx_CALL (VOIDmode, operands[1], operands[2])),\n+\t\t\t gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t  gen_rtx_REG (SImode, GPR_LR)))));\n+      emit_insn (target_uninterruptible ? gen_gie (): gen_gid ());\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"*call_value_i\"\n+  [(match_parallel 3 \"float_operation\"\n+     [(set (match_operand 0 \"gpr_operand\" \"=r,r\")\n+\t   (call (mem:SI (match_operand:SI 1 \"call_address_operand\" \"Csy,r\"))\n+\t         (match_operand 2 \"\" \"\")))\n+      (clobber (reg:SI GPR_LR))])]\n+  \"\"\n+  \"%f1\"\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_expand \"sibcall_value\"\n+  ;; operand 2 is stack_size_rtx\n+  ;; operand 3 is next_arg_register\n+  [(parallel [(set (match_operand 0 \"gpr_operand\" \"=r\")\n+\t\t   (call (match_operand:SI 1 \"call_operand\" \"\")\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t     (return)])]\n+  \"\"\n+{\n+  bool target_uninterruptible = epiphany_call_uninterruptible_p (operands[1]);\n+\n+  if (!call_operand (operands[1], VOIDmode))\n+    operands[1]\n+      = change_address (operands[1], VOIDmode,\n+\t\t\tcopy_to_mode_reg (Pmode, XEXP (operands[1], 0)));\n+  if (epiphany_uninterruptible_p (current_function_decl)\n+      != target_uninterruptible)\n+    {\n+      emit_insn (target_uninterruptible ? gen_gid (): gen_gie ());\n+      emit_call_insn\n+\t(gen_rtx_PARALLEL\n+\t  (VOIDmode,\n+\t   gen_rtvec (2, gen_rtx_SET\n+\t\t\t   (VOIDmode, operands[0],\n+\t\t\t    gen_rtx_CALL (VOIDmode, operands[1], operands[2])),\n+\t\t\t ret_rtx)));\n+      emit_insn (target_uninterruptible ? gen_gie (): gen_gid ());\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"*sibcall_value_i\"\n+  [(set (match_operand 0 \"gpr_operand\" \"=r,r\")\n+\t(call (mem:SI (match_operand:SI 1 \"call_address_operand\" \"Csy,Rsc\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (return)]\n+  \"\"\n+  \"@\n+   b %1\n+   jr %1\"\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_expand \"prologue\"\n+  [(pc)]\n+  \"\"\n+{\n+  epiphany_expand_prologue ();\n+  DONE;\n+})\n+\n+(define_expand \"epilogue\"\n+  [(pc)]\n+  \"\"\n+{\n+  epiphany_expand_epilogue (0);\n+  DONE;\n+})\n+\n+(define_expand \"sibcall_epilogue\"\n+  [(pc)]\n+  \"\"\n+{\n+  epiphany_expand_epilogue (1);\n+  DONE;\n+})\n+\n+; Since the demise of REG_N_SETS, it is no longer possible to find out\n+; in the prologue / epilogue expanders how many times lr is set.\n+; Using df_regs_ever_live_p to decide if lr needs saving means that\n+; any explicit use of lr will cause it to be saved; hence we cannot\n+; represent the blink use in return / sibcall instructions themselves, and\n+; instead have to show it in EPILOGUE_USES.\n+(define_insn \"return_i\"\n+  [(return)]\n+  \"reload_completed\"\n+  \"rts\"\n+  [(set_attr \"type\" \"uncond_branch\")])\n+\n+(define_insn \"return_internal_interrupt\"\n+  [(return)\n+   (unspec_volatile [(const_int 0)] 1)]\n+  \"\"\n+  \"rti\"\n+  [(set_attr \"type\" \"uncond_branch\")])\n+\n+(define_insn \"stack_adjust_add\"\n+  [(set (reg:SI GPR_SP)\n+\t(plus:SI (reg:SI GPR_SP) (match_operand:SI 0 \"arith_operand\" \"rL\")))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (reg:SI STATUS_REGNUM))\n+   (clobber (match_operand:BLK 1 \"memory_operand\" \"=m\"))]\n+  \"reload_completed\"\n+  \"add sp,sp,%0\")\n+\n+(define_insn \"stack_adjust_mov\"\n+  [(set (reg:SI GPR_SP) (reg:SI GPR_FP))\n+   (clobber (match_operand:BLK 0 \"memory_operand\" \"=m\"))]\n+  \"reload_completed\"\n+  \"mov sp,fp\"\n+  [(set_attr \"type\" \"move\")])\n+\n+(define_insn \"stack_adjust_str\"\n+  [(set (match_operand 0 \"stacktop_operand\" \"=m\")\n+\t(match_operand 1 \"any_gpr_operand\" \"r\"))\n+   (set (reg:SI GPR_SP)\n+\t(plus:SI (reg:SI GPR_SP) (match_operand:SI 2 \"nonmemory_operand\" \"rn\")))\n+   (clobber (match_operand:BLK 3 \"memory_operand\" \"=m\"))]\n+  \"reload_completed\"\n+{\n+  return (GET_MODE_SIZE (GET_MODE (operands[0])) <= 4\n+\t  ? \\\"str %1,%0,%C2\\\" : \\\"strd %1,%0,%X2\\\");\n+}\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_insn \"stack_adjust_ldr\"\n+  [(set (match_operand:SI 0 \"gpr_operand\" \"=r\")\n+\t(match_operand:SI 1 \"stacktop_operand\" \"m\"))\n+   (set (reg:SI GPR_SP)\n+\t(plus:SI (reg:SI GPR_SP) (match_operand:SI 2 \"nonmemory_operand\" \"rn\")))\n+   (clobber (match_operand:BLK 3 \"memory_operand\" \"=m\"))]\n+  \"reload_completed\"\n+  \"ldr %0,%1,%C2\"\n+  [(set_attr \"type\" \"load\")])\n+\f\n+;; Define some fake vector operations so that the vectorizer is happy to use\n+;; 64 bit loads/stores.\n+(define_expand \"vec_unpacks_lo_v4hi\"\n+  [(match_operand:V2SI 0 \"gpr_operand\")\n+   (match_operand:V4HI 1 \"gpr_operand\")]\n+  \"\"\n+{\n+  rtx in = simplify_gen_subreg (SImode, operands[1], V4HImode, 0);\n+  rtx outl = simplify_gen_subreg (SImode, operands[0], V2SImode, 0);\n+  rtx outh\n+    = simplify_gen_subreg (SImode, operands[0], V2SImode, UNITS_PER_WORD);\n+\n+  if (reg_overlap_mentioned_p (outl, in))\n+    in = copy_to_mode_reg (SImode, in);\n+  emit_insn (gen_ashlsi3 (outl, in, GEN_INT (16)));\n+  emit_insn (gen_ashrsi3 (outl, outl, GEN_INT (16)));\n+  emit_insn (gen_ashrsi3 (outh, in, GEN_INT (16)));\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacks_hi_v4hi\"\n+  [(match_operand:V2SI 0 \"gpr_operand\")\n+   (match_operand:V4HI 1 \"gpr_operand\")]\n+  \"\"\n+{\n+  rtx in = simplify_gen_subreg (SImode, operands[1], V4HImode, UNITS_PER_WORD);\n+  rtx outl = simplify_gen_subreg (SImode, operands[0], V2SImode, 0);\n+  rtx outh\n+    = simplify_gen_subreg (SImode, operands[0], V2SImode, UNITS_PER_WORD);\n+\n+  if (reg_overlap_mentioned_p (outl, in))\n+    in = copy_to_mode_reg (SImode, in);\n+  emit_insn (gen_ashlsi3 (outl, in, GEN_INT (16)));\n+  emit_insn (gen_ashrsi3 (outl, outl, GEN_INT (16)));\n+  emit_insn (gen_ashrsi3 (outh, in, GEN_INT (16)));\n+  DONE;\n+})\n+\n+(define_code_iterator addsub [plus minus])\n+\n+(define_code_iterator alu_binop\n+  [plus minus and ior xor])\n+\n+(define_code_attr insn_opname\n+  [(plus \"add\") (minus \"sub\") (mult \"mul\") (div \"div\")\n+   (and \"and\") (ior \"ior\") (xor \"xor\")])\n+\n+; You might think that this would work better as a define_expand, but\n+; again lower_subreg pessimizes the code if it sees indiviudual operations.\n+; We need to keep inputs and outputs as register pairs if we want to\n+; get sensible register allocation for double-word load and store operations.\n+(define_insn_and_split \"<insn_opname>v2si3\"\n+  [(set (match_operand:V2SI 0 \"gpr_operand\" \"=r\")\n+\t(alu_binop:V2SI (match_operand:V2SI 1 \"gpr_operand\" \"r\")\n+\t\t\t(match_operand:V2SI 2 \"gpr_operand\" \"r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed || (epiphany_vect_align == 4 && TARGET_SPLIT_VECMOVE_EARLY)\"\n+  [(const_int 0)]\n+{\n+  rtx o0l, o0h, o1l, o1h, o2l, o2h;\n+\n+  o0l = simplify_gen_subreg (SImode, operands[0], V2SImode, 0);\n+  o0h = simplify_gen_subreg (SImode, operands[0], V2SImode, UNITS_PER_WORD);\n+  o1l = simplify_gen_subreg (SImode, operands[1], V2SImode, 0);\n+  o1h = simplify_gen_subreg (SImode, operands[1], V2SImode, UNITS_PER_WORD);\n+  o2l = simplify_gen_subreg (SImode, operands[2], V2SImode, 0);\n+  o2h = simplify_gen_subreg (SImode, operands[2], V2SImode, UNITS_PER_WORD);\n+  if (reg_overlap_mentioned_p (o0l, o1h))\n+    o1h = copy_to_mode_reg (SImode, o1h);\n+  if (reg_overlap_mentioned_p (o0l, o2h))\n+    o2h = copy_to_mode_reg (SImode, o2h);\n+  emit_insn (gen_<insn_opname>si3 (o0l, o1l, o2l));\n+  emit_insn (gen_<insn_opname>si3 (o0h, o1h, o2h));\n+  DONE;\n+}\n+  [(set_attr \"length\" \"8\")])\n+\n+(define_expand \"<insn_opname>v2sf3\"\n+  [(parallel\n+     [(set (match_operand:V2SF 0 \"gpr_operand\" \"\")\n+\t   (addsub:V2SF (match_operand:V2SF 1 \"gpr_operand\" \"\")\n+\t\t\t(match_operand:V2SF 2 \"gpr_operand\" \"\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])])\n+\n+(define_insn_and_split \"<insn_opname>v2sf3_i\"\n+  [(match_parallel 3 \"float_operation\"\n+     [(set (match_operand:V2SF 0 \"gpr_operand\" \"=r\")\n+\t   (addsub:V2SF (match_operand:V2SF 1 \"gpr_operand\" \"r\")\n+\t\t\t(match_operand:V2SF 2 \"gpr_operand\" \"r\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"#\"\n+  \"reload_completed || (epiphany_vect_align == 4 && TARGET_SPLIT_VECMOVE_EARLY)\"\n+  [(parallel\n+     [(set (match_dup 4) (addsub:SF (match_dup 5) (match_dup 6)))\n+      (clobber (reg:CC_FP CCFP_REGNUM))\n+      (match_dup 10)\n+      (match_dup 11)])\n+   (parallel\n+     [(set (match_dup 7) (addsub:SF (match_dup 8) (match_dup 9)))\n+      (clobber (reg:CC_FP CCFP_REGNUM))\n+      (match_dup 10)\n+      (match_dup 11)])]\n+{\n+  operands[4] = simplify_gen_subreg (SFmode, operands[0], V2SFmode, 0);\n+  operands[5] = simplify_gen_subreg (SFmode, operands[1], V2SFmode, 0);\n+  operands[6] = simplify_gen_subreg (SFmode, operands[2], V2SFmode, 0);\n+  operands[7]\n+    = simplify_gen_subreg (SFmode, operands[0], V2SFmode, UNITS_PER_WORD);\n+  operands[8]\n+    = simplify_gen_subreg (SFmode, operands[1], V2SFmode, UNITS_PER_WORD);\n+  operands[9]\n+    = simplify_gen_subreg (SFmode, operands[2], V2SFmode, UNITS_PER_WORD);\n+  if (!reload_completed)\n+    {\n+      if (reg_overlap_mentioned_p (operands[4], operands[8]))\n+\toperands[8] = copy_to_mode_reg (SFmode, operands[8]);\n+      if (reg_overlap_mentioned_p (operands[4], operands[9]))\n+\toperands[9] = copy_to_mode_reg (SFmode, operands[9]);\n+      emit_insn (gen_<insn_opname>sf3 (operands[4], operands[5], operands[6]));\n+      emit_insn (gen_<insn_opname>sf3 (operands[7], operands[8], operands[9]));\n+      DONE;\n+    }\n+  gcc_assert (!reg_overlap_mentioned_p (operands[4], operands[8]));\n+  gcc_assert (!reg_overlap_mentioned_p (operands[4], operands[9]));\n+  operands[10] = XVECEXP (operands[3], 0, XVECLEN (operands[3], 0) - 2);\n+  operands[11] = XVECEXP (operands[3], 0, XVECLEN (operands[3], 0) - 1);\n+}\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"fp\")])\n+\n+(define_expand \"mul<mode>3\"\n+  [(parallel\n+     [(set (match_operand:DWV2MODE 0 \"gpr_operand\" \"\")\n+\t   (mult:DWV2MODE (match_operand:DWV2MODE 1 \"gpr_operand\" \"\")\n+\t\t\t  (match_operand:DWV2MODE 2 \"gpr_operand\" \"\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])])\n+\n+(define_insn_and_split \"mul<mode>3_i\"\n+  [(match_parallel 3 \"float_operation\"\n+     [(set (match_operand:DWV2MODE 0 \"gpr_operand\" \"=r\")\n+\t   (mult:DWV2MODE (match_operand:DWV2MODE 1 \"gpr_operand\" \"r\")\n+\t\t\t  (match_operand:DWV2MODE 2 \"gpr_operand\" \"r\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"\"\n+  \"#\"\n+  \"reload_completed || (epiphany_vect_align == 4 && TARGET_SPLIT_VECMOVE_EARLY)\"\n+  [(parallel\n+     [(set (match_dup 4) (mult:<vmode_PART> (match_dup 5) (match_dup 6)))\n+      (clobber (reg:CC_FP CCFP_REGNUM))\n+      (match_dup 10)\n+      (match_dup 11)])\n+   (parallel\n+     [(set (match_dup 7) (mult:<vmode_PART> (match_dup 8) (match_dup 9)))\n+      (clobber (reg:CC_FP CCFP_REGNUM))\n+      (match_dup 10)\n+      (match_dup 11)])]\n+{\n+  operands[4]\n+    = simplify_gen_subreg (<vmode_PART>mode, operands[0], <MODE>mode, 0);\n+  operands[5]\n+    = simplify_gen_subreg (<vmode_PART>mode, operands[1], <MODE>mode, 0);\n+  operands[6]\n+    = simplify_gen_subreg (<vmode_PART>mode, operands[2], <MODE>mode, 0);\n+  operands[7] = simplify_gen_subreg (<vmode_PART>mode, operands[0],\n+\t\t\t\t     <MODE>mode, UNITS_PER_WORD);\n+  operands[8] = simplify_gen_subreg (<vmode_PART>mode, operands[1],\n+\t\t\t\t     <MODE>mode, UNITS_PER_WORD);\n+  operands[9] = simplify_gen_subreg (<vmode_PART>mode, operands[2],\n+\t\t\t\t     <MODE>mode, UNITS_PER_WORD);\n+  if (!reload_completed)\n+    {\n+      if (reg_overlap_mentioned_p (operands[4], operands[8]))\n+\toperands[8] = copy_to_mode_reg (<vmode_PART>mode, operands[8]);\n+      if (reg_overlap_mentioned_p (operands[4], operands[9]))\n+\toperands[9] = copy_to_mode_reg (<vmode_PART>mode, operands[9]);\n+      emit_insn (gen_mul<vmode_part>3 (operands[4], operands[5], operands[6]));\n+      emit_insn (gen_mul<vmode_part>3 (operands[7], operands[8], operands[9]));\n+      DONE;\n+    }\n+  gcc_assert (!reg_overlap_mentioned_p (operands[4], operands[8]));\n+  gcc_assert (!reg_overlap_mentioned_p (operands[4], operands[9]));\n+  operands[10] = XVECEXP (operands[3], 0, XVECLEN (operands[3], 0) - 2);\n+  operands[11] = XVECEXP (operands[3], 0, XVECLEN (operands[3], 0) - 1);\n+}\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"<vmode_fp_type>\")])\n+\n+(define_insn_and_split \"*fmadd<mode>_combine\"\n+  [(match_parallel 4 \"float_operation\"\n+     [(set (match_operand:DWV2MODE 0 \"gpr_operand\" \"=r\")\n+\t   (plus:DWV2MODE (mult:<MODE>\n+\t\t\t\t(match_operand:<MODE> 1 \"gpr_operand\" \"r\")\n+\t\t\t\t(match_operand:<MODE> 2 \"gpr_operand\" \"r\"))\n+\t\t\t  (match_operand:<MODE> 3 \"gpr_operand\" \"0\")))\n+      (clobber (reg:CC_FP CCFP_REGNUM))])]\n+  \"TARGET_FUSED_MADD || <MODE>mode == V2SImode\"\n+  \"#\"\n+  \"reload_completed || (epiphany_vect_align == 4 && TARGET_SPLIT_VECMOVE_EARLY)\"\n+  [(parallel\n+     [(set (match_dup 5)\n+\t   (plus:<vmode_PART> (mult:<vmode_PART> (match_dup 6) (match_dup 7))\n+\t\t\t      (match_dup 8)))\n+      (clobber (reg:CC_FP CCFP_REGNUM))\n+      (match_dup 13)\n+      (match_dup 14)])\n+   (parallel\n+     [(set (match_dup 9)\n+\t   (plus:<vmode_PART> (mult:<vmode_PART> (match_dup 10) (match_dup 11))\n+\t\t\t      (match_dup 12)))\n+      (clobber (reg:CC_FP CCFP_REGNUM))\n+      (match_dup 13)\n+      (match_dup 14)])]\n+{\n+  operands[5]\n+    = simplify_gen_subreg (<vmode_PART>mode, operands[0], <MODE>mode, 0);\n+  operands[6]\n+    = simplify_gen_subreg (<vmode_PART>mode, operands[1], <MODE>mode, 0);\n+  operands[7]\n+    = simplify_gen_subreg (<vmode_PART>mode, operands[2], <MODE>mode, 0);\n+  operands[8]\n+    = simplify_gen_subreg (<vmode_PART>mode, operands[3], <MODE>mode, 0);\n+  operands[9] = simplify_gen_subreg (<vmode_PART>mode, operands[0],\n+\t\t\t\t     <MODE>mode, UNITS_PER_WORD);\n+  operands[10] = simplify_gen_subreg (<vmode_PART>mode, operands[1],\n+\t\t\t\t      <MODE>mode, UNITS_PER_WORD);\n+  operands[11] = simplify_gen_subreg (<vmode_PART>mode, operands[2],\n+\t\t\t\t      <MODE>mode, UNITS_PER_WORD);\n+  operands[12] = simplify_gen_subreg (<vmode_PART>mode, operands[3],\n+\t\t\t\t      <MODE>mode, UNITS_PER_WORD);\n+  if (!reload_completed)\n+    {\n+      if (reg_overlap_mentioned_p (operands[5], operands[10]))\n+\toperands[10] = copy_to_mode_reg (<vmode_PART>mode, operands[10]);\n+      if (reg_overlap_mentioned_p (operands[5], operands[11]))\n+\toperands[11] = copy_to_mode_reg (<vmode_PART>mode, operands[11]);\n+      if (reg_overlap_mentioned_p (operands[5], operands[12]))\n+\toperands[12] = copy_to_mode_reg (<vmode_PART>mode, operands[12]);\n+      emit_insn (gen_madd<vmode_part> (operands[5], operands[6], operands[7],\n+\t\t\t\t       operands[8]));\n+      emit_insn (gen_madd<vmode_part> (operands[9], operands[10], operands[11],\n+\t\t\t\t       operands[12]));\n+      DONE;\n+    }\n+  gcc_assert (!reg_overlap_mentioned_p (operands[5], operands[10]));\n+  gcc_assert (!reg_overlap_mentioned_p (operands[5], operands[11]));\n+  gcc_assert (!reg_overlap_mentioned_p (operands[5], operands[12]));\n+  operands[13] = XVECEXP (operands[4], 0, XVECLEN (operands[4], 0) - 2);\n+  operands[14] = XVECEXP (operands[4], 0, XVECLEN (operands[4], 0) - 1);\n+}\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"<vmode_fp_type>\")])\n+\n+(define_expand \"vec_set<mode>\"\n+  [(match_operand:DWV2MODE 0 \"register_operand\")\n+   (match_operand:<vmode_PART> 1 \"register_operand\")\n+   (match_operand 2 \"const_int_operand\" \"\")]\n+  \"\"\n+{\n+  operands[0]\n+    = simplify_gen_subreg (<vmode_PART>mode, operands[0], <MODE>mode,\n+\t\t\t   UNITS_PER_WORD * INTVAL (operands[2]));\n+  emit_move_insn (operands[0], operands[1]);\n+  DONE;\n+})\n+\f\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"type\" \"flow\")])"}, {"sha": "374018260d485e4036d4a5d730bc54a28cb66c5c", "filename": "gcc/config/epiphany/epiphany.opt", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fepiphany.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fepiphany.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.opt?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,140 @@\n+; Options for the Adapteva EPIPHANY port of the compiler\n+;\n+; Copyright (C) 2005, 2007, 2009, 2011 Free Software Foundation, Inc.\n+; Contributed by Embecosm on behalf of Adapteva, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT\n+; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+; License for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+mhalf-reg-file\n+Target Mask(HALF_REG_FILE)\n+Don't use any of r32..r63.\n+\n+mprefer-short-insn-regs\n+Target Mask(PREFER_SHORT_INSN_REGS)\n+preferentially allocate registers that allow short instruction generation.\n+\n+mbranch-cost=\n+Target RejectNegative Joined UInteger Var(epiphany_branch_cost) Init(3)\n+Set branch cost\n+\n+mcmove\n+Target Mask(CMOVE)\n+enable conditional move instruction usage.\n+\n+mnops=\n+Target RejectNegative Joined UInteger Var(epiphany_n_nops) Init(0)\n+set number of nops to emit before each insn pattern\n+\n+; Problems with using the flags from fsub for comparison are:\n+; - Because of underflow (lack of subnormal numbers), different small numbers\n+;   can compare as equal.\n+; - the set of comparisons is limited, and reversing comparisons doesn't work\n+;   in the presence of NaNs.\n+; The latter problem might be tolerated with -ffinite-math-only , but nothing\n+; in -funsafe-math-optimizations says different small numbers may be considered\n+; equal.\n+msoft-cmpsf\n+Target Mask(SOFT_CMPSF)\n+Use software floating point comparisons\n+\n+msplit-lohi\n+Target Mask(SPLIT_LOHI)\n+Enable split of 32 bit immediate loads into low / high part\n+\n+mpost-inc\n+Target Mask(POST_INC)\n+Enable use of POST_INC / POST_DEC\n+\n+mpost-modify\n+Target Mask(POST_MODIFY)\n+Enable use of POST_MODIFY\n+\n+mstack-offset=\n+Target RejectNegative Joined UInteger Var(epiphany_stack_offset) Init(EPIPHANY_STACK_OFFSET)\n+Set number of bytes on the stack preallocated for use by the callee.\n+\n+mround-nearest\n+target Mask(ROUND_NEAREST)\n+Assume round to nearest is selected for purposes of scheduling.\n+\n+mlong-calls\n+Target Mask(LONG_CALLS)\n+Generate call insns as indirect calls\n+\n+mshort-calls\n+Target Mask(SHORT_CALLS)\n+Generate call insns as direct calls\n+\n+msmall16\n+Target Mask(SMALL16)\n+Assume labels and symbols can be addressed using 16 bit absolute addresses.\n+\n+mfp-mode=\n+Target RejectNegative Joined Var(epiphany_normal_fp_mode) Enum(attr_fp_mode) Init(FP_MODE_CALLER)\n+\n+; The values are from enum attr_fp_mode, but using that enum would bring\n+; problems with enum forward declarations.\n+Enum\n+Name(attr_fp_mode) Type(int)\n+\n+EnumValue\n+Enum(attr_fp_mode) String(caller) Value(FP_MODE_CALLER)\n+\n+EnumValue\n+Enum(attr_fp_mode) String(round-nearest) Value(FP_MODE_ROUND_NEAREST)\n+\n+EnumValue\n+Enum(attr_fp_mode) String(truncate) Value(FP_MODE_ROUND_TRUNC)\n+\n+EnumValue\n+Enum(attr_fp_mode) String(int) Value(FP_MODE_INT)\n+\n+mvect-double\n+Target Mask(VECT_DOUBLE)\n+Vectorize for double-word operations.\n+\n+max-vect-align=\n+Target RejectNegative Joined Var(epiphany_vect_align) Enum(vect_align) Init(8)\n+\n+Enum\n+Name(vect_align) Type(int)\n+\n+EnumValue\n+Enum(vect_align) String(4) Value(4)\n+\n+EnumValue\n+Enum(vect_align) String(8) Value(8)\n+\n+msplit-vecmove-early\n+Target Mask(SPLIT_VECMOVE_EARLY)\n+Split unaligned 8 byte vector moves before post-modify address generation.\n+\n+m1reg-\n+Target RejectNegative Joined Var(epiphany_m1reg) Enum(m1reg) Init(-1)\n+Set register to hold -1.\n+\n+Enum\n+Name(m1reg) Type(int)\n+\n+EnumValue\n+Enum(m1reg) String(none) Value(-1)\n+\n+EnumValue\n+Enum(m1reg) String(r43) Value(43)\n+\n+EnumValue\n+Enum(m1reg) String(r63) Value(63)"}, {"sha": "2c06b0c25044049ff24aa269ddbd0d503a351ef5", "filename": "gcc/config/epiphany/epiphany_intrinsics.h", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fepiphany_intrinsics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fepiphany_intrinsics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany_intrinsics.h?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,27 @@\n+/* Epiphany intrinsic functions\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#define __builtin_epiphany_fmadd(a, b, c) __builtin_fmaf (b, c, a)\n+#define __builtin_epiphany_fmsub(a, b, c) __builtin_fmaf (-(b), c, a)"}, {"sha": "a7020f4393b610c8f35ab59f0223031a81828204", "filename": "gcc/config/epiphany/mode-switch-use.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fmode-switch-use.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fmode-switch-use.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fmode-switch-use.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,91 @@\n+/* Insert USEs in instructions that require mode switching.\n+   This should probably be merged into mode-switching.c .\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"function.h\"\n+#include \"emit-rtl.h\"\n+#include \"tree-pass.h\"\n+#include \"insn-attr.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"tm_p.h\"\n+#include \"df.h\"\n+\n+#ifndef TARGET_INSERT_MODE_SWITCH_USE\n+#define TARGET_INSERT_MODE_SWITCH_USE NULL\n+#endif\n+\n+static unsigned int\n+insert_uses (void)\n+{\n+  static const int num_modes[] = NUM_MODES_FOR_MODE_SWITCHING;\n+#define N_ENTITIES ARRAY_SIZE (num_modes)\n+  int e;\n+  void (*target_insert_mode_switch_use) (rtx insn, int, int)\n+    = TARGET_INSERT_MODE_SWITCH_USE;\n+\n+  for (e = N_ENTITIES - 1; e >= 0; e--)\n+    {\n+      int no_mode = num_modes[e];\n+      rtx insn;\n+      int mode;\n+\n+      if (!OPTIMIZE_MODE_SWITCHING (e))\n+\tcontinue;\n+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+\t{\n+\t  if (!INSN_P (insn))\n+\t    continue;\n+\t  mode = MODE_NEEDED (e, insn);\n+\t  if (mode == no_mode)\n+\t    continue;\n+\t  if (target_insert_mode_switch_use)\n+\t    {\n+\t      target_insert_mode_switch_use (insn, e, mode);\n+\t      df_insn_rescan (insn);\n+\t    }\n+\t}\n+    }\n+  return 0;\n+}\n+\n+struct rtl_opt_pass pass_mode_switch_use =\n+{\n+ {\n+  RTL_PASS,\n+  \"mode_switch_use\",\t\t\t/* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  insert_uses,\t\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_NONE,\t\t\t\t/* tv_id */\n+  0,\t\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0,\t\t\t\t\t/* todo_flags_finish */\n+ }\n+};"}, {"sha": "6e96af9fed4e6c188772e5f998225e56286001b5", "filename": "gcc/config/epiphany/predicates.md", "status": "added", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fpredicates.md?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,352 @@\n+;; Predicate definitions for code generation on the EPIPHANY cpu.\n+;; Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003,\n+;; 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n+;; Free Software Foundation, Inc.\n+;; Contributed by Embecosm on behalf of Adapteva, Inc.\n+;;\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; Returns true iff OP is a symbol reference that is a valid operand\n+;; in a jump or call instruction.\n+\n+(define_predicate \"symbolic_operand\"\n+  (match_code \"symbol_ref,label_ref,const\")\n+{\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return (!epiphany_is_long_call_p (op)\n+\t    && (!flag_pic || SYMBOL_REF_LOCAL_P (op)));\n+  if (GET_CODE (op) == LABEL_REF)\n+    return true;\n+  if (GET_CODE (op) == CONST)\n+    {\n+      op = XEXP (op, 0);\n+      if (GET_CODE (op) != PLUS || !symbolic_operand (XEXP (op, 0), mode))\n+\treturn false;\n+      /* The idea here is that a 'small' constant offset should be OK.\n+\t What exactly is considered 'small' is a bit arbitrary.  */\n+      return satisfies_constraint_L (XEXP (op, 1));\n+    }\n+  gcc_unreachable ();\n+})\n+\n+;; Acceptable arguments to the call insn.\n+\n+(define_predicate \"call_address_operand\"\n+  (ior (match_code \"reg\")\n+       (match_operand 0 \"symbolic_operand\")))\n+\n+(define_predicate \"call_operand\"\n+  (match_code \"mem\")\n+{\n+  op = XEXP (op, 0);\n+  return call_address_operand (op, mode);\n+})\n+\n+;; general purpose register.\n+(define_predicate \"gpr_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  int regno;\n+\n+  if (!register_operand (op, mode))\n+    return 0;\n+  if (GET_CODE (op) == SUBREG)\n+    op = XEXP (op, 0);\n+  regno = REGNO (op);\n+  return regno >= FIRST_PSEUDO_REGISTER || regno <= 63;\n+})\n+\n+(define_special_predicate \"any_gpr_operand\"\n+  (match_code \"subreg,reg\")\n+{\n+  return gpr_operand (op, mode);\n+})\n+\n+;; register suitable for integer add / sub operations; besides general purpose\n+;; registers we allow fake hard registers that are eliminated to a real\n+;; hard register via an offset.\n+(define_predicate \"add_reg_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  int regno;\n+\n+  if (!register_operand (op, mode))\n+    return 0;\n+  if (GET_CODE (op) == SUBREG)\n+    op = XEXP (op, 0);\n+  regno = REGNO (op);\n+  return (regno >= FIRST_PSEUDO_REGISTER || regno <= 63\n+\t  || regno == FRAME_POINTER_REGNUM\n+\t  || regno == ARG_POINTER_REGNUM);\n+})\n+\n+;; Also allows suitable constants\n+(define_predicate \"add_operand\"\n+  (match_code \"reg,subreg,const_int,symbol_ref,label_ref,const\")\n+{\n+  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+    return add_reg_operand (op, mode);\n+  return satisfies_constraint_L (op);\n+})\n+\n+;; Ordinary 3rd operand for arithmetic operations\n+(define_predicate \"arith_operand\"\n+  (match_code \"reg,subreg,const_int,symbol_ref,label_ref,const\")\n+{\n+  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+    return register_operand (op, mode);\n+  return satisfies_constraint_L (op);\n+})\n+\n+;; Constant integer 3rd operand for arithmetic operations\n+(define_predicate \"arith_int_operand\"\n+  (match_code \"const_int,symbol_ref,label_ref,const\")\n+{\n+  return satisfies_constraint_L (op);\n+})\n+\n+;; Return true if OP is an acceptable argument for a single word move source.\n+\n+(define_predicate \"move_src_operand\"\n+  (match_code\n+   \"symbol_ref,label_ref,const,const_int,const_double,reg,subreg,mem,unspec\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF :\n+    case LABEL_REF :\n+    case CONST :\n+      return 1;\n+    case CONST_INT :\n+      return immediate_operand (op, mode);\n+    case CONST_DOUBLE :\n+      /* SImode constants should always fit into a CONST_INT.  Large\n+\t unsigned 32-bit constants are represented as negative CONST_INTs.  */\n+      gcc_assert (GET_MODE (op) != SImode);\n+      /* We can handle 32-bit floating point constants.  */\n+      if (mode == SFmode)\n+\treturn GET_MODE (op) == SFmode;\n+      return 0;\n+    case REG :\n+      return op != frame_pointer_rtx && register_operand (op, mode);\n+    case SUBREG :\n+      /* (subreg (mem ...) ...) can occur here if the inner part was once a\n+\t pseudo-reg and is now a stack slot.  */\n+      if (GET_CODE (SUBREG_REG (op)) == MEM)\n+\treturn address_operand (XEXP (SUBREG_REG (op), 0), mode);\n+      else\n+\treturn register_operand (op, mode);\n+    case MEM :\n+      return address_operand (XEXP (op, 0), mode);\n+    case UNSPEC:\n+      return satisfies_constraint_Sra (op);\n+    default :\n+      return 0;\n+    }\n+})\n+\n+;; Return true if OP is an acceptable argument for a double word move source.\n+\n+(define_predicate \"move_double_src_operand\"\n+  (match_code \"reg,subreg,mem,const_int,const_double,const_vector\")\n+{\n+  return general_operand (op, mode);\n+})\n+\n+;; Return true if OP is an acceptable argument for a move destination.\n+\n+(define_predicate \"move_dest_operand\"\n+  (match_code \"reg,subreg,mem\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case REG :\n+      return register_operand (op, mode);\n+    case SUBREG :\n+      /* (subreg (mem ...) ...) can occur here if the inner part was once a\n+\t pseudo-reg and is now a stack slot.  */\n+      if (GET_CODE (SUBREG_REG (op)) == MEM)\n+\t{\n+\t  return address_operand (XEXP (SUBREG_REG (op), 0), mode);\n+\t}\n+      else\n+\t{\n+\t  return register_operand (op, mode);\n+\t}\n+    case MEM :\n+      return address_operand (XEXP (op, 0), mode);\n+    default :\n+      return 0;\n+    }\n+})\n+\n+(define_special_predicate \"stacktop_operand\"\n+  (match_code \"mem\")\n+{\n+  if (mode != VOIDmode && GET_MODE (op) != mode)\n+    return false;\n+  return rtx_equal_p (XEXP (op, 0), stack_pointer_rtx);\n+})\n+\n+;; Return 1 if OP is a comparison operator valid for the mode of CC.\n+;; This allows the use of MATCH_OPERATOR to recognize all the branch insns.\n+;;\n+;; Some insns only set a few bits in the condition code.  So only allow those\n+;; comparisons that use the bits that are valid.\n+\n+(define_predicate \"proper_comparison_operator\"\n+  (match_code \"eq, ne, le, lt, ge, gt, leu, ltu, geu, gtu, unordered, ordered, uneq, unge, ungt, unle, unlt, ltgt\")\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  rtx cc = XEXP (op, 0);\n+\n+  /* combine can try strange things.  */\n+  if (!REG_P (cc))\n+    return 0;\n+  switch (GET_MODE (cc))\n+    {\n+    case CC_Zmode:\n+    case CC_N_NEmode:\n+    case CC_FP_EQmode:\n+      return REGNO (cc) == CC_REGNUM && (code == EQ || code == NE);\n+    case CC_C_LTUmode:\n+      return REGNO (cc) == CC_REGNUM && (code == LTU || code == GEU);\n+    case CC_C_GTUmode:\n+      return REGNO (cc) == CC_REGNUM && (code == GTU || code == LEU);\n+    case CC_FPmode:\n+      return (REGNO (cc) == CCFP_REGNUM\n+\t      && (code == EQ || code == NE || code == LT || code == LE));\n+    case CC_FP_GTEmode:\n+      return (REGNO (cc) == CC_REGNUM\n+\t      && (code == EQ || code == NE || code == GT || code == GE\n+\t\t  || code == UNLE || code == UNLT));\n+    case CC_FP_ORDmode:\n+      return REGNO (cc) == CC_REGNUM && (code == ORDERED || code == UNORDERED);\n+    case CC_FP_UNEQmode:\n+      return REGNO (cc) == CC_REGNUM && (code == UNEQ || code == LTGT);\n+    case CCmode:\n+      return REGNO (cc) == CC_REGNUM;\n+    /* From combiner.  */\n+    case QImode: case SImode: case SFmode: case HImode:\n+    /* From cse.c:dead_libcall_p.  */\n+    case DFmode:\n+      return 0;\n+    default:\n+      gcc_unreachable ();\n+    }\n+})\n+\n+(define_predicate \"cc_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == CC_REGNUM || REGNO (op) == CCFP_REGNUM\")))\n+\n+(define_predicate \"const0_operand\"\n+  (match_code \"const_int, const_double\")\n+{\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op);\n+  return op == CONST0_RTX (mode);\n+})\n+\n+(define_predicate \"const_float_1_operand\"\n+  (match_code \"const_double\")\n+{\n+  return op == CONST1_RTX (mode);\n+})\n+\n+(define_predicate \"cc_move_operand\"\n+  (and (match_code \"reg\")\n+       (ior (match_test \"REGNO (op) == CC_REGNUM\")\n+\t    (match_test \"gpr_operand (op, mode)\"))))\n+\n+(define_predicate \"float_operation\"\n+  (match_code \"parallel\")\n+{\n+  /* Most patterns start out with one SET and one CLOBBER, and gain a USE\n+     or two of FP_NEAREST_REGNUM / FP_TRUNCATE_REGNUM / FP_ANYFP_REGNUM\n+     after mode switching.  The longer patterns are\n+     all beyond length 4, and before mode switching, end with a\n+     CLOBBER of CCFP_REGNUM.  */\n+  int count = XVECLEN (op, 0);\n+  bool inserted = MACHINE_FUNCTION (cfun)->control_use_inserted;\n+  int i;\n+\n+  if (count == 2)\n+    return !inserted;\n+\n+  /* combine / recog will pass any old garbage here before checking the\n+     rest of the insn.  */\n+  if (count <= 3)\n+    return false;\n+\n+  i = 1;\n+  if (count > 4)\n+    for (i = 4; i < count; i++)\n+      {\n+\trtx x = XVECEXP (op, 0, i);\n+\n+\tif (GET_CODE (x) == CLOBBER)\n+\t  {\n+\t    if (!REG_P (XEXP (x, 0)))\n+\t      return false;\n+\t    if (REGNO (XEXP (x, 0)) == CCFP_REGNUM)\n+\t      {\n+\t\tif (count == i + 1)\n+\t\t  return !inserted;\n+\t\tbreak;\n+\t    }\n+\t  /* Just an ordinary clobber, keep looking.  */\n+\t}\n+      else if (GET_CODE (x) == USE\n+\t       || (GET_CODE (x) == SET && i == 2))\n+\tcontinue;\n+      else\n+\treturn false;\n+    }\n+  if (count != i + 3 || !inserted)\n+    return false;\n+  for (i = i+1; i < count; i++)\n+    {\n+      rtx x = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (x) != USE && GET_CODE (x) != CLOBBER)\n+\treturn false;\n+      x = XEXP (x, 0);\n+      if (!REG_P (x)\n+\t  || (REGNO (x) != FP_NEAREST_REGNUM\n+\t      && REGNO (x) != FP_TRUNCATE_REGNUM\n+\t      && REGNO (x) != FP_ANYFP_REGNUM))\n+\treturn false;\n+    }\n+  return true;\n+})\n+\n+(define_predicate \"set_fp_mode_operand\"\n+  (ior (match_test \"gpr_operand (op, mode)\")\n+       (and (match_code \"const\")\n+\t    (match_test \"satisfies_constraint_Cfm (op)\"))))\n+\n+(define_predicate \"post_modify_address\"\n+  (match_code \"post_modify,post_inc,post_dec\"))\n+\n+(define_predicate \"post_modify_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"post_modify_address (XEXP (op, 0), Pmode)\")))\n+\n+(define_predicate \"nonsymbolic_immediate_operand\"\n+  (ior (match_test \"immediate_operand (op, mode)\")\n+       (match_code \"const_vector\"))) /* Is this specific enough?  */"}, {"sha": "9564d752c4ff9bc7b6f9eb228838ca566f929b3c", "filename": "gcc/config/epiphany/resolve-sw-modes.c", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fresolve-sw-modes.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,182 @@\n+/* Mode switching cleanup pass for the EPIPHANY cpu.\n+   Copyright (C) 2000, 2011 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"machmode.h\"\n+#include \"tm.h\"\n+#include \"hard-reg-set.h\"\n+#include \"tm_p.h\"\n+#include \"vec.h\"\n+#include \"sbitmap.h\"\n+#include \"basic-block.h\"\n+#include \"df.h\"\n+#include \"rtl.h\"\n+#include \"insn-config.h\"\n+#include \"insn-codes.h\"\n+#include \"emit-rtl.h\"\n+#include \"recog.h\"\n+#include \"function.h\"\n+#include \"insn-attr-common.h\"\n+#include \"tree-pass.h\"\n+\n+/* Clean-up after mode switching:\n+   Check for mode setting insns that have FP_MODE_ROUND_UNKNOWN.\n+   If only one rounding mode is required, select that one.\n+   Else we have to choose one to use in this mode setting insn and\n+   insert new mode setting insns on the edges where the other mode\n+   becomes unambigous.  */\n+\n+static bool\n+gate_resolve_sw_modes (void)\n+{\n+  return optimize;\n+}\n+\n+static unsigned\n+resolve_sw_modes (void)\n+{\n+  basic_block bb;\n+  rtx insn, src;\n+  VEC (basic_block, heap) *todo;\n+  sbitmap pushed;\n+  bool need_commit = false;\n+  bool finalize_fp_sets = (MACHINE_FUNCTION (cfun)->unknown_mode_sets == 0);\n+\n+  todo = VEC_alloc (basic_block, heap, last_basic_block);\n+  pushed = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (pushed);\n+  if (!finalize_fp_sets)\n+    {\n+      df_note_add_problem ();\n+      df_analyze ();\n+    }\n+  FOR_EACH_BB (bb)\n+    FOR_BB_INSNS (bb, insn)\n+      {\n+\tenum attr_fp_mode selected_mode;\n+\n+\tif (!NONJUMP_INSN_P (insn)\n+\t    || recog_memoized (insn) != CODE_FOR_set_fp_mode)\n+\t  continue;\n+\tsrc = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));\n+\tif (finalize_fp_sets)\n+\t  {\n+\t    SET_SRC (XVECEXP (PATTERN (insn), 0, 2)) = copy_rtx (src);\n+\t    if (REG_P (src))\n+\t      df_insn_rescan (insn);\n+\t    continue;\n+\t  }\n+\tif (REG_P (src)\n+\t    || XINT (XVECEXP (XEXP (src, 0), 0, 0), 0) != FP_MODE_ROUND_UNKNOWN)\n+\t  continue;\n+\tif (find_regno_note (insn, REG_UNUSED, FP_TRUNCATE_REGNUM))\n+\t  selected_mode = FP_MODE_ROUND_NEAREST;\n+\telse if (find_regno_note (insn, REG_UNUSED, FP_NEAREST_REGNUM))\n+\t  selected_mode = FP_MODE_ROUND_TRUNC;\n+\telse\n+\t  {\n+\t    /* We could get more fancy in the selection of the mode by\n+\t       checking the total frequency of the affected edges.  */\n+\t    selected_mode = (enum attr_fp_mode) epiphany_normal_fp_rounding;\n+\n+\t    VEC_quick_push (basic_block, todo, bb);\n+\t    SET_BIT (pushed, bb->index);\n+\t  }\n+\tXVECEXP (XEXP (src, 0), 0, 0) = GEN_INT (selected_mode);\n+\tSET_SRC (XVECEXP (PATTERN (insn), 0, 1)) = copy_rtx (src);\n+\tSET_SRC (XVECEXP (PATTERN (insn), 0, 2)) = copy_rtx (src);\n+\tdf_insn_rescan (insn);\n+      }\n+  while (VEC_length (basic_block, todo))\n+    {\n+      basic_block bb = VEC_pop (basic_block, todo);\n+      int selected_reg, jilted_reg;\n+      enum attr_fp_mode jilted_mode;\n+      edge e;\n+      edge_iterator ei;\n+\n+      SET_BIT (pushed, bb->index);\n+      SET_BIT (pushed, bb->index);\n+\n+      if (epiphany_normal_fp_rounding == FP_MODE_ROUND_NEAREST)\n+\t{\n+\t  selected_reg = FP_NEAREST_REGNUM;\n+\t  jilted_reg = FP_TRUNCATE_REGNUM;\n+\t  jilted_mode = FP_MODE_ROUND_TRUNC;\n+\t}\n+      else\n+\t{\n+\t  selected_reg = FP_TRUNCATE_REGNUM;\n+\t  jilted_reg = FP_NEAREST_REGNUM;\n+\t  jilted_mode = FP_MODE_ROUND_NEAREST;\n+\t}\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  basic_block succ = e->dest;\n+\t  rtx seq;\n+\n+\t  if (!REGNO_REG_SET_P (DF_LIVE_IN (succ), jilted_reg))\n+\t    continue;\n+\t  if (REGNO_REG_SET_P (DF_LIVE_IN (succ), selected_reg))\n+\t    {\n+\t      if (TEST_BIT (pushed, succ->index))\n+\t\tcontinue;\n+\t      VEC_quick_push (basic_block, todo, succ);\n+\t      SET_BIT (pushed, bb->index);\n+\t      continue;\n+\t    }\n+\t  start_sequence ();\n+\t  emit_set_fp_mode (EPIPHANY_MSW_ENTITY_ROUND_UNKNOWN,\n+\t\t\t    jilted_mode, NULL);\n+\t  seq = get_insns ();\n+\t  end_sequence ();\n+\t  need_commit = true;\n+\t  insert_insn_on_edge (seq, e);\n+\t}\n+    }\n+  VEC_free (basic_block, heap, todo);\n+  sbitmap_free (pushed);\n+  if (need_commit)\n+    commit_edge_insertions ();\n+  return 0;\n+}\n+\n+struct rtl_opt_pass pass_resolve_sw_modes =\n+{\n+ {\n+  RTL_PASS,\n+  \"resolve_sw_modes\",\t\t\t/* name */\n+  gate_resolve_sw_modes,\t\t/* gate */\n+  resolve_sw_modes,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_MODE_SWITCH,\t\t\t/* tv_id */\n+  0,\t\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_df_finish | TODO_verify_rtl_sharing |\n+  0\t\t\t\t\t/* todo_flags_finish */\n+ }\n+};"}, {"sha": "33db4acef134bae4aec0afcc1e384740c93ad7df", "filename": "gcc/config/epiphany/t-epiphany", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Ft-epiphany", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fconfig%2Fepiphany%2Ft-epiphany", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Ft-epiphany?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,32 @@\n+# Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003,\n+# 2004, 2009, 2010, 2011 Free Software Foundation, Inc.\n+# Contributed by Embecosm on behalf of Adapteva, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+mode-switch-use.o : $(srcdir)/config/epiphany/mode-switch-use.c \\\n+   $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TM_P_H) $(RTL_H) \\\n+   $(TREE_PASS_H) $(INSN_ATTR_H) $(EMIT_RTL_H) $(FUNCTION_H) $(RECOG_H) \\\n+   insn-config.h $(DF_H)\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $<\n+\n+resolve-sw-modes.o : $(srcdir)/config/epiphany/resolve-sw-modes.c \\\n+  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(MACHMODE_H) $(TM_H) hard-reg-set.h \\\n+  $(TM_P_H) $(VEC_H) sbitmap.h $(BASIC_BLOCK_H) $(DF_H) $(RTL_H) \\\n+  insn-config.h insn-codes.h $(EMIT_RTL_H) $(RECOG_H) $(FUNCTION_H) \\\n+  insn-attr-common.h $(TREE_PASS_H)\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $<"}, {"sha": "f76cce8d23413ffd1f68c5b332edf13cc72849c4", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -746,7 +746,7 @@ Volker Reichelt for keeping up with the problem reports.\n \n @item\n Joern Rennecke for maintaining the sh port, loop, regmove & reload\n-hacking.\n+hacking and developing and maintaining the Epiphany port.\n \n @item\n Loren J. Rittle for improvements to libstdc++-v3 including the FreeBSD"}, {"sha": "c605462be91244931f851b8584b1f74ae46aca2b", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -2192,7 +2192,7 @@ types (@pxref{Variable Attributes}, @pxref{Type Attributes}.)\n \n @item disinterrupt\n @cindex @code{disinterrupt} attribute\n-On MeP targets, this attribute causes the compiler to emit\n+On Epiphany and MeP targets, this attribute causes the compiler to emit\n instructions to disable interrupts for the duration of the given\n function.\n \n@@ -2551,7 +2551,7 @@ This attribute is ignored for R8C target.\n \n @item interrupt\n @cindex interrupt handler functions\n-Use this attribute on the ARM, AVR, M32C, M32R/D, m68k, MeP, MIPS,\n+Use this attribute on the ARM, AVR, Epiphany, M32C, M32R/D, m68k, MeP, MIPS,\n RX and Xstormy16 ports to indicate that the specified function is an\n interrupt handler.  The compiler will generate function entry and exit\n sequences suitable for use in an interrupt handler when this attribute\n@@ -2723,7 +2723,8 @@ attribute is not allowed on types to annotate indirect calls.\n @item long_call/short_call\n @cindex indirect calls on ARM\n This attribute specifies how a particular function is called on\n-ARM@.  Both attributes override the @option{-mlong-calls} (@pxref{ARM Options})\n+ARM and Epiphany.  Both attributes override the\n+@option{-mlong-calls} (@pxref{ARM Options})\n command-line switch and @code{#pragma long_calls} settings.  The\n @code{long_call} attribute indicates that the function might be far\n away from the call site and require a different (more expensive)"}, {"sha": "643ba7208e68e022e3ab54497b7e3fa5509f2cc2", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -1208,6 +1208,11 @@ of the arguments depend on the target.\n Specify if the compiler should default to @option{-marm} or @option{-mthumb}.\n This option is only supported on ARM targets.\n \n+@item --with-stack-offset=@var{num}\n+This option sets the default for the -mstack-offset=@var{num} option,\n+and will thus generally also control the setting of this option for\n+libraries.  This option is only supported on Epiphany targets.\n+\n @item --with-fpmath=@var{isa}\n This options sets @option{-mfpmath=sse} by default and specifies the default\n ISA for floating-point arithmetics.  You can select either @samp{sse} which\n@@ -3312,6 +3317,13 @@ any MSDOS compiler except itself.  You need to get the complete\n compilation package DJGPP, which includes binaries as well as sources,\n and includes all the necessary compilation tools and libraries.\n \n+@html\n+<hr />\n+@end html\n+@heading @anchor{epiphany-x-elf}epiphany-*-elf\n+Adapteva Epiphany.\n+This configuration is intended for embedded systems.\n+\n @html\n <hr />\n @end html"}, {"sha": "780d5c8a7bb6658f4e7181fb8b5a612f1070ae29", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -458,6 +458,14 @@ Objective-C and Objective-C++ Dialects}.\n @c Try and put the significant identifier (CPU or system) first,\n @c so users have a clue at guessing where the ones they want will be.\n \n+@emph{Adapteva Epiphany Options}\n+@gccoptlist{-mhalf-reg-file -mprefer-short-insn-regs @gol\n+-mbranch-cost=@var{num} -mcmove -mnops=@var{num} -msoft-cmpsf @gol\n+-msplit-lohi -mpost-inc -mpost-modify -mstack-offset=@var{num} @gol\n+-mround-nearest -mlong-calls -mshort-calls -msmall16 @gol\n+-mfp-mode=@var{mode} -mvect-double -max-vect-align=@var{num} @gol\n+-msplit-vecmove-early -m1reg-@var{reg}}\n+\n @emph{ARM Options}\n @gccoptlist{-mapcs-frame  -mno-apcs-frame @gol\n -mabi=@var{name} @gol\n@@ -10226,6 +10234,7 @@ platform.\n @c in Machine Dependent Options\n \n @menu\n+* Adapteva Epiphany Options::\n * ARM Options::\n * AVR Options::\n * Blackfin Options::\n@@ -10274,6 +10283,161 @@ platform.\n * zSeries Options::\n @end menu\n \n+@node Adapteva Epiphany Options\n+@subsection Adapteva Epiphany Options\n+\n+These @samp{-m} options are defined for Adapteva Epiphany:\n+\n+@table @gcctabopt\n+@item -mhalf-reg-file\n+@opindex mhalf-reg-file\n+Don't allocate any register in the range @code{r32}@dots{}@code{r63}.\n+That allows code to run on hardware variants that lack these registers.\n+\n+@item -mprefer-short-insn-regs\n+@opindex mprefer-short-insn-regs\n+Preferrentially allocate registers that allow short instruction generation.\n+This can result in increasesd instruction count, so if this reduces or\n+increases code size might vary from case to case.\n+\n+@item -mbranch-cost=@var{num}\n+@opindex mbranch-cost\n+Set the cost of branches to roughly @var{num} ``simple'' instructions.\n+This cost is only a heuristic and is not guaranteed to produce\n+consistent results across releases.\n+\n+@item -mcmove\n+@opindex mcmove\n+Enable the generation of conditional moves.\n+\n+@item -mnops=@var{num}\n+@opindex mnops\n+Emit @var{num} nops before every other generated instruction.\n+\n+@item -mno-soft-cmpsf\n+@opindex mno-soft-cmpsf\n+For single-precision floating point comparisons, emit an fsub instruction\n+and test the flags.  This is faster than a software comparison, but can\n+get incorrect results in the presence of NaNs, or when two different small\n+numbers are compared such that their difference is calculated as zero.\n+The default is @option{-msoft-cmpsf}, which uses slower, but IEEE-compliant,\n+software comparisons.\n+\n+@item -mstack-offset=@var{num}\n+@opindex mstack-offset\n+Set the offset between the top of the stack and the stack pointer.\n+E.g., a value of 8 means that the eight bytes in the range sp+0@dots{}sp+7\n+can be used by leaf functions without stack allocation.\n+Values other than @samp{8} or @samp{16} are untested and unlikely to work.\n+Note also that this option changes the ABI, compiling a program with a\n+different stack offset than the libraries have been compiled with\n+will generally not work.\n+This option can be useful if you want to evaluate if a different stack\n+offset would give you better code, but to actually use a different stack\n+offset to build working programs, it is recommended to configure the\n+toolchain with the appropriate @samp{--with-stack-offset=@var{num}} option.\n+\n+@item -mno-round-nearest\n+@opindex mno-round-nearest\n+Make the scheduler assume that the rounding mode has been set to\n+truncating.  The default is @option{-mround-nearest}.\n+\n+@item -mlong-calls\n+@opindex mlong-calls\n+If not otherwise specified by an attribute, assume all calls might be beyond\n+the offset range of the b / bl instructions, and therefore load the\n+function address into a register before performing a (otherwise direct) call.\n+This is the default.\n+\n+@item -mshort-calls\n+@opindex short-calls\n+If not otherwise specified by an attribute, assume all direct calls are\n+in the range of the b / bl instructions, so use these instructions\n+for direct calls.  The default is @option{-mlong-calls}.\n+\n+@item -msmall16\n+@opindex msmall16\n+Assume addresses can be loaded as 16 bit unsigned values.  This does not\n+apply to function addresses for which @option{-mlong-calls} semantics\n+are in effect.\n+\n+@item -mfp-mode=@var{mode}\n+@opindex mfp-mode\n+Set the prevailing mode of the floating point unit.\n+This determines the floating point mode that is provided and expected\n+at function call and return time.  Making this mode match the mode you\n+predominantly need at function start can make your programs smaller and\n+faster by avoiding unnecessary mode switches.\n+\n+@var{mode} can be set to one the following values:\n+\n+@table @samp\n+@item caller\n+Any mode at function entry is valid, and retained or restored when\n+the function returns, and when it calls other functions.\n+This mode is useful for compiling libraries or other compilation units\n+you might want to incorporate into different programs with different\n+prevailing FPU modes, and the convenience of being able to use a single\n+object file outweighs the size and speed overhead for any extra\n+mode switching that might be needed, compared with what would be needed\n+with a more specific choice of prevailing FPU mode.\n+\n+@item truncate\n+This is the mode used for floating point calculations with\n+truncating (i.e.@: round towards zero) rounding mode.  That includes\n+conversion from floating point to integer.\n+\n+@item round-nearest\n+This is the mode used for floating point calculations with\n+round-to-nearest-or-even rounding mode.\n+\n+@item int\n+This is the mode used to perform integer calculations in the FPU, e.g.@:\n+integer multiply, or integer multiply-and-accumulate.\n+@end table\n+\n+The default is @option{-mfp-mode=caller}\n+\n+@item -mnosplit-lohi\n+@opindex mnosplit-lohi\n+@item -mno-postinc\n+@opindex mno-postinc\n+@item -mno-postmodify\n+@opindex mno-postmodify\n+Code generation tweaks that disable, respectively, splitting of 32\n+bit loads, generation of post-increment addresses, and generation of\n+post-modify addresses.  The defaults are @option{msplit-lohi},\n+@option{-mpost-inc}, and @option{-mpost-modify}.\n+\n+@item -mnovect-double\n+@opindex mno-vect-double\n+Change the preferred SIMD mode to SImode.  The default is\n+@option{-mvect-double}, which uses DImode as preferred SIMD mode.\n+\n+@item -max-vect-align=@var{num}\n+@opindex max-vect-align\n+The maximum alignment for SIMD vector mode types.\n+@var{num} may be 4 or 8.  The default is 8.\n+Note that this is an ABI change, even though many library function\n+interfaces will be unaffected, if they don't use SIMD vector modes\n+in places where they affect size and/or alignment of relevant types.\n+\n+@item -msplit-vecmove-early\n+@opindex msplit-vecmove-early\n+Split vector moves into single word moves before reload.  In theory this\n+could give better register allocation, but so far the reverse seems to be\n+generally the case.\n+\n+@item -m1reg-@var{reg}\n+@opindex m1reg-\n+Specify a register to hold the constant @minus{}1, which makes loading small negative\n+constants and certain bitmasks faster.\n+Allowable values for reg are r43 and r63, which specify to use that register\n+as a fixed register, and none, which means that no register is used for this\n+purpose.  The default is @option{-m1reg-none}.\n+\n+@end table\n+\n @node ARM Options\n @subsection ARM Options\n @cindex ARM options"}, {"sha": "a51e7cf2fbbee8ca4cba958ccb69d2a23c10606a", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -1,5 +1,5 @@\n @c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1996, 1998, 1999, 2000, 2001,\n-@c 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+@c 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n @c Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n@@ -1778,6 +1778,77 @@ A memory address based on Y or Z pointer with displacement.\n Constant integer 4\n @end table\n \n+@item Epiphany---@file{config/epiphany/constraints.md}\n+@table @code\n+@item U16\n+An unsigned 16-bit constant.\n+\n+@item K\n+An unsigned 5-bit constant.\n+\n+@item L\n+A signed 11-bit constant.\n+\n+@item Cm1\n+A signed 11-bit constant added to @minus{}1.\n+Can only match when the @option{-m1reg-@var{reg}} option is active.\n+\n+@item Cl1\n+Left-shift of @minus{}1, i.e., a bit mask with a block of leading ones, the rest\n+being a block of trailing zeroes.\n+Can only match when the @option{-m1reg-@var{reg}} option is active.\n+\n+@item Cr1\n+Right-shift of @minus{}1, i.e., a bit mask with a trailing block of ones, the\n+rest being zeroes.  Or to put it another way, one less than a power of two.\n+Can only match when the @option{-m1reg-@var{reg}} option is active.\n+\n+@item Cal\n+Constant for arithmetic/logical operations.\n+This is like @code{i}, except that for position independent code,\n+no symbols / expressions needing relocations are allowed.\n+\n+@item Csy\n+Symbolic constant for call/jump instruction.\n+\n+@item Rcs\n+The register class usable in short insns.  This is a register class\n+constraint, and can thus drive register allocation.\n+This constraint won't match unless @option{-mprefer-short-insn-regs} is\n+in effect.\n+\n+@item Rsc\n+The the register class of registers that can be used to hold a\n+sibcall call address.  I.e., a caller-saved register.\n+\n+@item Rct\n+Core control register class.\n+\n+@item Rgs\n+The register group usable in short insns.\n+This constraint does not use a register class, so that it only\n+passively matches suitable registers, and doesn't drive register allocation.\n+\n+@ifset INTERNALS\n+@item Car\n+Constant suitable for the addsi3_r pattern.  This is a valid offset\n+For byte, halfword, or word addressing.\n+@end ifset\n+\n+@item Rra\n+Matches the return address if it can be replaced with the link register.\n+\n+@item Rcc\n+Matches the integer condition code register.\n+\n+@item Sra\n+Matches the return address if it is in a stack slot.\n+\n+@item Cfm\n+Matches control register values to switch fp mode, which are encapsulated in\n+@code{UNSPEC_FP_MODE}.\n+@end table\n+\n @item Hewlett-Packard PA-RISC---@file{config/pa/pa.h}\n @table @code\n @item a"}, {"sha": "8091789c4383728bc8ff7486b13919c1de118802", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -1,3 +1,20 @@\n+2011-11-05  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\n+\t* gcc.c-torture/execute/ieee/mul-subnormal-single-1.x:\n+\tDisable test on Epiphany.\n+\t* gcc.c-torture/execute/20101011-1.c: Disable test on Epiphany.\n+\t* gcc.dg/stack-usage-1.c [__epiphany__] (SIZE): Define.\n+\t* gcc.dg/pragma-pack-3.c: Disable test on Epiphany.\n+\t* g++.dg/parse/pragma3.C: Likewise.\n+\t* stackalign/builtin-apply-2.c (STACK_ARGUMENTS_SIZE): Define.\n+\t(bar): Use it.\n+\t* gcc.dg/weak/typeof-2.c [epiphany-*-*]: Add option -mshort-calls.\n+\t* gcc.dg/tls/thr-cse-1.c: Likewise.\n+\t* g++.dg/opt/devirt2.C: Likewise.\n+\t* gcc.dg/20020312-2.c [epiphany-*-*] (PIC_REG): Define.\n+\t* gcc.dg/builtin-apply2.c [__epiphany__]: (STACK_ARGUMENTS_SIZE): 20.\n+\t* gcc.target/epiphany: New directory.\n+\n 2011-11-05  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.dg/quad_2.f90: New."}, {"sha": "1198abdd776edb57251172880ec356b163cac7aa", "filename": "gcc/testsuite/g++.dg/opt/devirt2.C", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdevirt2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdevirt2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdevirt2.C?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -1,5 +1,8 @@\n // { dg-do compile }\n // { dg-options \"-O2\" }\n+/* Using -mshort-calls avoids loading the function addresses in\n+   registers and thus getting the counts wrong.  */\n+// { dg-additional-options \"-mshort-calls\" {target epiphany-*-*} }\n // { dg-final { scan-assembler-times \"xyzzy\" 2 { target { ! { alpha*-*-* hppa*-*-* ia64*-*-hpux* sparc*-*-* } } } } }\n // The IA64 and HPPA compilers generate external declarations in addition\n // to the call so those scans need to be more specific."}, {"sha": "57793b385d0b24a84313de439524ac7a30d2ba3d", "filename": "gcc/testsuite/g++.dg/parse/pragma3.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpragma3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpragma3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpragma3.C?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -1,5 +1,6 @@\n // PR c++/25294\n-// { dg-do run }\n+// Epiphany makes struct S 8-byte aligned.\n+// { dg-do run { target { ! epiphany-*-* } } }\n \n extern \"C\" void abort (void);\n "}, {"sha": "fcf8c071246fffcf64e11138d2bb096b26f816dc", "filename": "gcc/testsuite/gcc.c-torture/execute/20101011-1.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20101011-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20101011-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20101011-1.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -28,6 +28,10 @@\n   /* Not all Linux kernels deal correctly the breakpoints generated by\n      MIPS16 divisions by zero.  They show up as a SIGTRAP instead.  */\n # define DO_TEST 0\n+#elif defined (__epiphany__)\n+  /* Epiphany does not have hardware division, and the software implementation\n+     has truly undefined behaviour for division by 0.  */\n+# define DO_TEST 0\n #else\n # define DO_TEST 1\n #endif"}, {"sha": "d090cbf610e72376efb096f8d569aecad0ae2f60", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/mul-subnormal-single-1.x", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fmul-subnormal-single-1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fmul-subnormal-single-1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Fmul-subnormal-single-1.x?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -1,3 +1,8 @@\n+if [istarget \"epiphany-*-*\"] {\n+    # The Epiphany single-precision floating point format does not\n+    # support subnormals.\n+    return 1\n+}\n if [istarget \"mips-sgi-irix6*\"] {\n     # IRIX 6 sets the MIPS IV flush to zero bit by default, so this test\n     # isn't expected to work for n32 and n64 on MIPS IV targets."}, {"sha": "6e568eddb909b86b3b02d41e2779ff7a4e5f7892", "filename": "gcc/testsuite/gcc.dg/20020312-2.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -20,6 +20,8 @@ extern void abort (void);\n /* No pic register.  */\n #elif defined(__cris__)\n # define PIC_REG  \"0\"\n+#elif defined(__epiphany__)\n+#define PIC_REG \"r28\"\n #elif defined(__fr30__)\n /* No pic register.  */\n #elif defined(__H8300__) || defined(__H8300H__) || defined(__H8300S__)"}, {"sha": "c5b841a849689648d32e11eb9a7530350bd1a57e", "filename": "gcc/testsuite/gcc.dg/builtin-apply2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-apply2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-apply2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-apply2.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -12,7 +12,7 @@\n \n #define INTEGER_ARG  5\n \n-#ifdef __ARM_PCS\n+#if defined(__ARM_PCS) || defined(__epiphany__)\n /* For Base AAPCS, NAME is passed in r0.  D is passed in r2 and r3.\n    E, F and G are passed on stack.  So the size of the stack argument\n    data is 20.  */"}, {"sha": "d38431491342651a1a479b84f5a24534ec4d64a5", "filename": "gcc/testsuite/gcc.dg/pragma-pack-3.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-pack-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-pack-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-pack-3.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -1,6 +1,7 @@\n /* PR c++/25294 */\n /* { dg-options \"-std=gnu99\" } */\n-/* { dg-do run } */\n+/* Epiphany makes struct S 8-byte aligned.  */\n+/* { dg-do run { target { ! epiphany-*-* } } } */\n \n extern void abort (void);\n "}, {"sha": "77dd03852fb15c8743f6f96d39dd9beb24d487dd", "filename": "gcc/testsuite/gcc.dg/stack-usage-1.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-usage-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-usage-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-usage-1.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -52,6 +52,8 @@\n #  define SIZE 160 /* 256 -  96 bytes for register save area */\n #elif defined (__SPU__)\n #  define SIZE 224\n+#elif defined (__epiphany__)\n+#  define SIZE (256 - __EPIPHANY_STACK_OFFSET__)\n #else\n #  define SIZE 256\n #endif"}, {"sha": "87fdc64688d92344073981947c0904cf91ee23fd", "filename": "gcc/testsuite/gcc.dg/tls/thr-cse-1.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fthr-cse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fthr-cse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fthr-cse-1.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -1,5 +1,8 @@\n /* { dg-do compile } */\n /* { dg-options \"-O1\" } */\n+/* Using -mshort-calls avoids loading the function addresses in\n+   registers and thus getting the counts wrong.  */\n+/* { dg-additional-options \"-mshort-calls\" { target epiphany-*-* } } */\n /* { dg-require-effective-target tls_emulated } */\n \n /* Test that we only get one call to emutls_get_address when CSE is"}, {"sha": "89c71a99d5bde591211b77b391e4aedcd60ec9b7", "filename": "gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fstackalign%2Fbuiltin-apply-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fstackalign%2Fbuiltin-apply-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fstackalign%2Fbuiltin-apply-2.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -9,6 +9,15 @@\n \n #define INTEGER_ARG  5\n \n+#if defined(__ARM_PCS) || defined(__epiphany__)\n+/* For Base AAPCS, NAME is passed in r0.  D is passed in r2 and r3.\n+   E, F and G are passed on stack.  So the size of the stack argument\n+   data is 20.  */\n+#define STACK_ARGUMENTS_SIZE  20\n+#else\n+#define STACK_ARGUMENTS_SIZE  64\n+#endif\n+\n extern void abort(void);\n \n void foo(char *name, double d, double e, double f, int g)\n@@ -19,7 +28,7 @@ void foo(char *name, double d, double e, double f, int g)\n \n void bar(char *name, ...)\n {\n-  __builtin_apply(foo, __builtin_apply_args(), 64);\n+  __builtin_apply(foo, __builtin_apply_args(), STACK_ARGUMENTS_SIZE);\n }\n \n int main(void)"}, {"sha": "d13235fd9729c151d158aa6a2abbd2c744ee9b88", "filename": "gcc/testsuite/gcc.dg/weak/typeof-2.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.dg%2Fweak%2Ftypeof-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.dg%2Fweak%2Ftypeof-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fweak%2Ftypeof-2.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -5,6 +5,9 @@\n /* { dg-require-weak \"\" } */\n /* { dg-require-alias \"\" } */\n /* { dg-options \"-O2\" } */\n+/* Using -mshort-calls avoids loading the function addresses in\n+   registers and thus getting the counts wrong.  */\n+/* { dg-additional-options \"-mshort-calls\" { target epiphany-*-* } } */\n \n extern int foo1 (int x) __asm (\"baz1\");\n int bar1 (int x) { return x; }"}, {"sha": "dc9fecc728e7ea94b9a5325bdd4824ffe207a169", "filename": "gcc/testsuite/gcc.target/epiphany/epiphany.exp", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.target%2Fepiphany%2Fepiphany.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.target%2Fepiphany%2Fepiphany.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fepiphany%2Fepiphany.exp?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,41 @@\n+# Copyright (C) 2007, 2011 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't an epiphany target.\n+if ![istarget epiphany*-*-*] then {\n+  return\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "868d5bd0226c2f2bebbe5c806c95716b43d8f8b3", "filename": "gcc/testsuite/gcc.target/epiphany/fmadd-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.target%2Fepiphany%2Ffmadd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.target%2Fepiphany%2Ffmadd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fepiphany%2Ffmadd-1.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-times \"fmadd\\[ \\ta-zA-Z0-9\\]*,\" 2 } } */\n+\n+#include <epiphany_intrinsics.h>\n+\n+float\n+f1 (float a, float b, float c)\n+{\n+  return __builtin_epiphany_fmadd (a, b, c);\n+}\n+\n+float\n+f2 (float a, float b, float c)\n+{\n+  return a + b * c;\n+}"}, {"sha": "ff7fefa7f200cd10aa24370a438e15d54c06da1a", "filename": "gcc/testsuite/gcc.target/epiphany/fmsub-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.target%2Fepiphany%2Ffmsub-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.target%2Fepiphany%2Ffmsub-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fepiphany%2Ffmsub-1.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-times \"fmsub\\[ \\ta-zA-Z0-9\\]*,\" 2 } } */\n+\n+#include <epiphany_intrinsics.h>\n+\n+float\n+f1 (float a, float b, float c)\n+{\n+  return __builtin_epiphany_fmsub (a, b, c);\n+}\n+\n+float\n+f2 (float a, float b, float c)\n+{\n+  return a - b * c;\n+}"}, {"sha": "a44c79e432e69fd6b71256c3880265dc22b97145", "filename": "gcc/testsuite/gcc.target/epiphany/interrupt.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.target%2Fepiphany%2Finterrupt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/gcc%2Ftestsuite%2Fgcc.target%2Fepiphany%2Finterrupt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fepiphany%2Finterrupt.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,14 @@\n+void __attribute__((interrupt(\"dma0\")))\n+f (void)\n+{\n+}\n+\n+void __attribute__((interrupt(\"Vss\")))\n+g (void)\n+{ /* { dg-warning \"is not \\\"reset\\\"\" } */\n+}\n+\n+void __attribute__((interrupt(42)))\n+h (void)\n+{ /* { dg-warning \"is not a string constant\" } */\n+}"}, {"sha": "ae5e4636c649dc0f91d5794984e04aa16054952f", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -1,3 +1,8 @@\n+2011-11-05  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\n+\t* config.host (epiphany-*-elf*): New configuration.\n+\t* config/epiphany: New Directory.\n+\n 2011-11-05  Ralf Cors\u00e9pius  <ralf.corsepius@rtems.org>\n \n \t* config.host (avr-*-rtems*): Add config/avr/t-rtems."}, {"sha": "36297feb4983037c2d5477b1550bdbddcdc3d6a6", "filename": "libgcc/config.host", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -433,6 +433,10 @@ cris-*-elf)\n cris-*-linux* | crisv32-*-linux*)\n \ttmake_file=\"$tmake_file cris/t-cris t-fdpbit cris/t-linux\"\n \t;;\n+epiphany-*-elf*)\n+\ttmake_file=\"epiphany/t-epiphany t-fdpbit epiphany/t-custom-eqsf\"\n+\textra_parts=\"$extra_parts crti.o crtint.o crtrunc.o crtm1reg-r43.o crtm1reg-r63.o crtn.o\"\n+\t;;\n fr30-*-elf)\n \ttmake_file=\"$tmake_file fr30/t-fr30 t-fdpbit\"\n \textra_parts=\"$extra_parts crti.o crtn.o\""}, {"sha": "527d926477588eca3b5c5345649b31c893fd0e1d", "filename": "libgcc/config/epiphany/crti.S", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fcrti.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fcrti.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fcrti.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,34 @@\n+# Start .init and .fini sections.\n+# Copyright (C) 2010, 2011 Free Software Foundation, Inc.\n+# Contributed by Embecosm on behalf of Adapteva, Inc.\n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+#\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+\t.section .init\n+\t.global\tinit\n+\t.balign 2\n+init:\n+\tstr lr,[sp],-4\n+\n+\t.section .fini\n+\t.global\tfini\n+\t.balign 2\n+fini:\n+\tstr lr,[sp],-4"}, {"sha": "e66b34e06520fffa16a6f0e14be73c8ae01f6f9b", "filename": "libgcc/config/epiphany/crtint.S", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fcrtint.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fcrtint.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fcrtint.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,27 @@\n+# initialize config for -mfp-mode=int\n+# Copyright (C) 2011 Free Software Foundation, Inc.\n+# Contributed by Embecosm on behalf of Adapteva, Inc.\n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+#\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+\t.section .init\n+\tmov r0, %low(#524288)\n+\tmovt r0, %high(#524288)\n+\tmovts config,r0"}, {"sha": "02ef9f2025c45212efdf92035f6536d9c4aef16d", "filename": "libgcc/config/epiphany/crtm1reg-r43.S", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fcrtm1reg-r43.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fcrtm1reg-r43.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fcrtm1reg-r43.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,26 @@\n+# initialize config for -m1reg-r43\n+# Copyright (C) 2011 Free Software Foundation, Inc.\n+# Contributed by Embecosm on behalf of Adapteva, Inc.\n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+#\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+\t.section .init\n+\tmov r0, 0\n+\tsub r43,r0,1"}, {"sha": "8bd9fb605cbe2de9d1cf0511b7a9794398e6f983", "filename": "libgcc/config/epiphany/crtm1reg-r63.S", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fcrtm1reg-r63.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fcrtm1reg-r63.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fcrtm1reg-r63.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,26 @@\n+# initialize config for -m1reg-r63\n+# Copyright (C) 2011 Free Software Foundation, Inc.\n+# Contributed by Embecosm on behalf of Adapteva, Inc.\n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+#\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+\t.section .init\n+\tmov r0, 0\n+\tsub r63,r0,1"}, {"sha": "2c326bf7b969315683db74921a214503339fc1df", "filename": "libgcc/config/epiphany/crtn.S", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fcrtn.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fcrtn.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fcrtn.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,32 @@\n+# End .init and .fini sections.\n+# Copyright (C) 2010, 2011 Free Software Foundation, Inc.\n+# Contributed by Embecosm on behalf of Adapteva, Inc.\n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+#\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+\t.section .init\n+\tldr lr,[sp,4]\n+\tadd sp,sp,16\n+\tjr lr\n+\n+\t.section .fini\n+\tldr lr,[sp,4]\n+\tadd sp,sp,16\n+\tjr lr"}, {"sha": "37b0507b49153788edceeb041db50e05abfceb4a", "filename": "libgcc/config/epiphany/crtrunc.S", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fcrtrunc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fcrtrunc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fcrtrunc.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,26 @@\n+# initialize config for -mfp-mode=truncate\n+# Copyright (C) 2011 Free Software Foundation, Inc.\n+# Contributed by Embecosm on behalf of Adapteva, Inc.\n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+#\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+\t.section .init\n+\tmov r0, 1\n+\tmovts config,r0"}, {"sha": "31a0506946e125c03f5f7158e84f76808f0404fa", "filename": "libgcc/config/epiphany/divsi3-float.S", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fdivsi3-float.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fdivsi3-float.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fdivsi3-float.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,77 @@\n+/* Signed 32 bit division optimized for Epiphany.\n+   Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"epiphany-asm.h\"\n+\n+\tFSTAB (__divsi3,T_UINT)\n+\t.global SYM(__divsi3)\n+\t.balign 4\n+\tHIDDEN_FUNC(__divsi3)\n+SYM(__divsi3):\n+\tfloat TMP2,r0\n+\t  mov TMP4,0\n+\tfloat TMP1,r1\n+\t  sub TMP0,TMP4,r0\n+\tbeq .Lret_r0\n+\tmovgt r0,TMP0\n+\tsub TMP0,TMP4,r1\n+\tmovgt r1,TMP0\n+\tmov TMP0,1\n+\tsub TMP2,TMP2,TMP1\n+\tasr TMP3,TMP2,31 ; save sign\n+\tlsl TMP2,TMP2,1\n+\tblt .Lret0\n+\tsub TMP1,TMP2,1 ; rounding compensation, avoid overflow\n+\tmovgte TMP2,TMP1\n+\tlsr TMP2,TMP2,24\n+\tlsl r1,r1,TMP2\n+\tlsl TMP0,TMP0,TMP2\n+\tsub TMP1,r0,r1\n+\tmovgteu r0,TMP1\n+\tmovgteu TMP4,TMP0\n+\tlsl TMP5,TMP0,1\n+\tsub TMP1,r0,r1\n+\tmovgteu r0,TMP1\n+\tmovgteu TMP4,TMP5\n+\tsub TMP1,r1,1\n+\tmov r1,%low(.L0step)\n+\tmovt r1,%high(.L0step)\n+\tlsl TMP2,TMP2,3\n+\tsub r1,r1,TMP2\n+\tjr r1\n+\t.rep 30\n+\tlsl r0,r0,1\n+\tsub.l r1,r0,TMP1\n+\tmovgteu r0,r1\n+\t.endr\n+.L0step:sub r1,TMP0,1 ; mask result bits from steps ...\n+\tand r0,r0,r1\n+\torr r0,r0,TMP4 ; ... and combine with first bit.\n+\teor r0,r0,TMP3 ; restore sign\n+\tsub r0,r0,TMP3\n+.Lret_r0:rts\n+.Lret0:\tmov r0,0\n+\trts\n+\tENDFUNC(__divsi3)"}, {"sha": "bdb2860dc0ded64e918c9f3cedd7ecbb1333070a", "filename": "libgcc/config/epiphany/divsi3.S", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fdivsi3.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fdivsi3.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fdivsi3.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,92 @@\n+/* Signed 32 bit division optimized for Epiphany.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"epiphany-asm.h\"\n+\n+\tFSTAB (__divsi3,T_INT)\n+\t.global SYM(__divsi3)\n+\t.balign 4\n+\tHIDDEN_FUNC(__divsi3)\n+SYM(__divsi3):\n+\tmov r12,0\n+\tsub r2,r12,r0\n+\tmovlt r2,r0\n+\tsub r3,r12,r1\n+\tmovlt r3,r1\n+\tsub r19,r2,r3\n+\tbltu .Lret0\n+\tmovt r12,0x4000\n+\torr r16,r2,r12\n+\torr r18,r3,r12\n+\t fsub r16,r16,r12\n+\tfsub r18,r18,r12\n+\t movt r12,0x4b80\n+\tlsr r19,r3,23\n+\tlsr r17,r2,23\n+\tmovt r17,0x4b80\n+\tfsub r17,r17,r12\n+\t movt r19,0x4b80\n+\tfsub r19,r19,r12\n+\t mov r12,%low(.L0step)\n+\tmovt r12,%high(.L0step)\n+\tmov r20,0\n+\tmov r21,1\n+\tmovne r16,r17\n+\tlsr r17,r3,23\n+\tmovne r18,r19\n+\teor r1,r1,r0 ; save sign\n+\tasr r19,r1,31\n+\tlsr r1,r16,23\n+\tlsr r0,r18,23\n+\tsub r1,r1,r0 ; calculate bit number difference.\n+\tlsl r3,r3,r1\n+\tlsr r16,r3,1\n+\tlsl r0,r21,r1\n+\tlsl r1,r1,3\n+\tsub r12,r12,r1\n+\tsub r3,r2,r3\n+\tmovgteu r2,r3\n+\tmovgteu r20,r0\n+\tlsr r0,r0,1\n+\tadd r17,r0,r20\n+\tsub r3,r2,r16\n+\tmovgteu r2,r3\n+\tmovgteu r20,r17\n+\tsub r16,r16,1\n+\tjr r12\n+\t.rep 30\n+\tlsl r2,r2,1\n+\tsub r3,r2,r16\n+\tmovgteu r2,r3\n+\t.endr\n+\tsub r0,r0,1 ; mask result bits from steps ...\n+\tand r0,r0,r2\n+\torr r20,r0,r20 ; ... and combine with first bit.\n+.L0step:eor r0,r20,r19 ; restore sign\n+\tsub r0,r0,r19\n+\trts\n+.Lret0:\tmov r0,0\n+\trts\n+\tENDFUNC(__divsi3)"}, {"sha": "c15aaf3eef6b8d469f4506fe210107c5baaf8405", "filename": "libgcc/config/epiphany/divsi3.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fdivsi3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fdivsi3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fdivsi3.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,120 @@\n+/* Generic signed 32 bit division implementation.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+typedef union { unsigned int i; float f; } fu;\n+\n+/* Although the semantics of the function ask for signed / unsigned inputs,\n+   for the actual implementation we use unsigned numbers.  */\n+unsigned int __divsi3 (unsigned int a, unsigned int b);\n+\n+unsigned int\n+__divsi3 (unsigned int a, unsigned int b)\n+{\n+  unsigned int sign = (int) (a ^ b) >> 31;\n+  unsigned int d, t, s0, s1, s2, r0, r1;\n+  fu u0, u1, u2, u1b, u2b;\n+\n+  a = abs (a);\n+  b = abs (b);\n+\n+  if (b > a)\n+    return 0;\n+\n+  /* Compute difference in number of bits in S0.  */\n+  u0.i = 0x40000000;\n+  u1b.i = u2b.i = u0.i;\n+  u1.i = a;\n+  u2.i = b;\n+  u1.i = a | u0.i;\n+  t = 0x4b800000 | ((a >> 23) & 0xffff);\n+  if (a >> 23)\n+    {\n+      u1.i = t;\n+      u1b.i = 0x4b800000;\n+    }\n+  u2.i = b | u0.i;\n+  t = 0x4b800000 | ((b >> 23) & 0xffff);\n+  if (b >> 23)\n+    {\n+      u2.i = t;\n+      u2b.i = 0x4b800000;\n+    }\n+  u1.f = u1.f - u1b.f;\n+  u2.f = u2.f - u2b.f;\n+  s1 = u1.i >> 23;\n+  s2 = u2.i >> 23;\n+  s0 = s1 - s2;\n+\n+  b <<= s0;\n+  d = b - 1;\n+\n+  r0 = 1 << s0;\n+  r1 = 0;\n+  t = a - b;\n+  if (t <= a)\n+    {\n+      a = t;\n+      r1 = r0;\n+    }\n+\n+#define STEP(n) case n: a += a; t = a - d; if (t <= a) a = t;\n+  switch (s0)\n+    {\n+    STEP (31)\n+    STEP (30)\n+    STEP (29)\n+    STEP (28)\n+    STEP (27)\n+    STEP (26)\n+    STEP (25)\n+    STEP (24)\n+    STEP (23)\n+    STEP (22)\n+    STEP (21)\n+    STEP (20)\n+    STEP (19)\n+    STEP (18)\n+    STEP (17)\n+    STEP (16)\n+    STEP (15)\n+    STEP (14)\n+    STEP (13)\n+    STEP (12)\n+    STEP (11)\n+    STEP (10)\n+    STEP (9)\n+    STEP (8)\n+    STEP (7)\n+    STEP (6)\n+    STEP (5)\n+    STEP (4)\n+    STEP (3)\n+    STEP (2)\n+    STEP (1)\n+    case 0: ;\n+    }\n+  r0 = r1 | (r0-1 & a);\n+  return (r0 ^ sign) - sign;\n+}"}, {"sha": "e86f7efd8942df5e2355aa74877762c1fb22b30f", "filename": "libgcc/config/epiphany/epiphany-asm.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fepiphany-asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fepiphany-asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fepiphany-asm.h?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,53 @@\n+/* Copyright (C) 1995, 1997, 2007, 2008, 2009, 2011\n+   Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* ANSI concatenation macros.  */\n+\n+#define CONCAT1(a, b) CONCAT2(a, b)\n+#define CONCAT2(a, b) a ## b\n+#define STRINGIFY2(a, b) STRINGIFY(a##b)\n+#define STRINGIFY(a) #a\n+\n+/* Use the right prefix for global labels.  */\n+\n+#define SYM(x) CONCAT1 (__USER_LABEL_PREFIX__, x)\n+\n+#define FSTAB(X,T)\t.stabs\tSTRINGIFY2(X##:F,T),36,0,__LINE__,SYM(X)\n+#define FUNC(X)\t\t.type SYM(X),@function\n+#define HIDDEN_FUNC(X)\tFUNC(X)` .hidden SYM(X)\n+#define ENDFUNC0(X)\tCONCAT1(.Lfe_,X): .size X,CONCAT1(.Lfe_,X)-X\n+#define ENDFUNC(X)\tENDFUNC0(SYM(X))\n+\n+#define TMP0\tr12\n+#define TMP1\tr16\n+#define TMP2\tr17\n+#define TMP3\tr18\n+#define TMP4\tr19\n+#define TMP5\tr20\n+\n+#define T_INT (0,1)\n+\t.stabs\t\"int:t(0,1)=r(0,1);-2147483648;2147483647;\",128,0,1,0\n+#define T_UINT (0,2)\n+\t.stabs\t\"unsigned int:t(0,2)=r(0,2);0;037777777777;\",128,0,1,0"}, {"sha": "3c04e2a94fc837b9ad079ff3f008c35dffb2451d", "filename": "libgcc/config/epiphany/ieee-754/eqsf2.S", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fieee-754%2Feqsf2.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fieee-754%2Feqsf2.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fieee-754%2Feqsf2.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,50 @@\n+/* Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"../epiphany-asm.h\"\n+\n+\t/* Assumption: NaNs have all bits 10..30 and one of bit 0..9 set.  */\n+\n+\tFSTAB (__eqsf2,T_INT)\n+\t.global SYM(__eqsf2)\n+\t.balign 4\n+\tHIDDEN_FUNC(__eqsf2)\n+SYM(__eqsf2):\n+\tsub\tTMP0,r0,r1\n+\tbeq\t.Lno_bdiff\n+\torr\tTMP0,r0,r1\n+\tadd\tTMP0,TMP0,TMP0\n+\trts\n+.Lno_bdiff:\n+#ifndef FLOAT_FORMAT_MOTOROLA\n+\tmov\tTMP0,0xffff\n+\tmovt\tTMP0,0x7f\n+\tadd\tTMP0,TMP0,r0\n+#else\n+\tadd\tTMP0,r0,0x3ff\n+#endif\n+\teor\tTMP0,TMP0,r0\n+\tlsr\tTMP0,TMP0,31\n+\trts\n+\tENDFUNC(__eqsf2)"}, {"sha": "a6cf748c6206b9927c5e0bab4b138f668bde3a8b", "filename": "libgcc/config/epiphany/ieee-754/fast_div.S", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fieee-754%2Ffast_div.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fieee-754%2Ffast_div.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fieee-754%2Ffast_div.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,124 @@\n+/* Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"../epiphany-asm.h\"\n+\n+.section _fast_div_text,\"a\",@progbits;\n+  .balign 8;\n+_fast_div_table:\n+.word 0x007fffff//   mantissa mask\n+.word 0x40257ebb//   hold constant a = 2.58586\n+\n+.word 0x3f000000//   hold constant 126 shifted to bits [30:23]\n+.word 0xc0ba2e88//   hold constant b = -5.81818\n+\n+.word 0x4087c1e8//   hold constant c = 4.24242\n+.word 0x40000000//  to hold constant 2 for Newton-Raphson iterations\n+\n+ .global SYM(__fast_recipsf2)\n+ FUNC(__fast_recipsf2)\n+SYM(__fast_recipsf2):\n+\n+//###################\n+//# input operands:\n+//###################\n+// Divisor\n+//R0\n+// Function address (used with negative offsets to read _fast_div_table)\n+//R1\n+/* Scratch registers:  two single (TMP0/TMP5) and two pairs.  */\n+#define P0L TMP1\n+#define P0H TMP2\n+#define P1L TMP3\n+#define P1H TMP4\n+\n+//#########################################\n+//# Constants to be used in the algorithm\n+//#########################################\n+ldrd P0L , [ R1 , -3 ]\n+\n+ldrd P1L , [ R1 , -2 ]\n+\n+\n+\n+//#############################################################################\n+//#                       The Algorithm\n+//#\n+//# Operation: C=A/B\n+//# stage 1 - find the reciprocal 1/B according to the following scheme:\n+//#  B = (2^E)*m                                (1<m<2, E=e-127)\n+//#  1/B = 1/((2^E)*m) = 1/((2^(E+1))*m1)          (0.5<m1<1)\n+//#      = (2^-(E+1))*(1/m1) = (2^E1)*(1/m1)\n+//#\n+//# Now we can find the new exponent:\n+//# e1 = E1+127 = -E-1+127 = -e+127-1+127 = 253-e **\n+//# 1/m1 alreadt has the exponent 127, so we have to add 126-e.\n+//# the exponent might underflow, which we can detect as a sign change.\n+//# Since the architeture uses flush-to-zero for subnormals, we can\n+//# give the result 0. then.\n+//#\n+//# The 1/m1 term with 0.5<m1<1 is approximated with the Chebyshev polynomial\n+//# 1/m1 = 2.58586*(m1^2) - 5.81818*m1 + 4.24242\n+//#\n+//# Next step is to use two iterations of Newton-Raphson algorithm to complete\n+//# the reciprocal calculation.\n+//#\n+//# Final result is achieved by multiplying A with 1/B\n+//#############################################################################\n+\n+\n+\n+// R0 exponent and sign \"replacement\" into TMP0\n+AND TMP0,R0,P0L\t\t ;\n+ORR TMP0,TMP0,P1L\n+SUB TMP5,R0,TMP0 // R0 sign/exponent extraction into TMP5\n+// Calculate new mantissa\n+FMADD P1H,TMP0,P0H\t         ;\n+\t\t// Calculate new exponent offset 126 - \"old exponent\"\n+\t\tSUB P1L,P1L,TMP5\n+\tldrd P0L , [ R1 , -1 ]\n+FMADD P0L,TMP0,P1H\t         ;\n+\t\teor P1H,r0,P1L // check for overflow (N-BIT).\n+\t\tblt .Lret_0\n+// P0L exponent and sign \"replacement\"\n+sub P0L,P0L,TMP5\n+\n+// Newton-Raphson iteration #1\n+MOV TMP0,P0H\t         ;\n+FMSUB P0H,R0,P0L\t ;\n+FMUL  P0L,P0H,P0L\t ;\n+// Newton-Raphson iteration #2\n+FMSUB TMP0,R0,P0L\t;\n+FMUL  R0,TMP0,P0L\t         ;\n+jr lr\n+.Lret_0:ldrd P0L , [ R1 , -3 ]\n+\tlsr TMP0,r0,31 ; extract sign\n+\tlsl TMP0,TMP0,31\n+\tadd P0L,P0L,r0 ; check for NaN input\n+\teor P0L,P0L,r0\n+\tmovgte r0,TMP0\n+\tjr lr\n+// Quotient calculation is expected by the caller: FMUL quotient,divident,R0\n+        ;\n+\tENDFUNC(__fast_recipsf2)"}, {"sha": "615dde4fd8a901dc19d6ac653a1b5c27944fa98b", "filename": "libgcc/config/epiphany/ieee-754/gtesf2.S", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fieee-754%2Fgtesf2.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fieee-754%2Fgtesf2.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fieee-754%2Fgtesf2.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,66 @@\n+/* Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"../epiphany-asm.h\"\n+\n+\t/* Assumptions: NaNs have all bits 10..30 and one of bit 0..9 set.\n+\t\t\tafter sub: AC = ~Borrow.\n+\t   clobber: TMP0\n+\t   output: gt / gte indicates greater / greater or equal.  */\n+\n+\tFSTAB (__gtesf2,T_INT)\n+\t.global SYM(__gtesf2)\n+\t.balign 4\n+\tHIDDEN_FUNC(__gtesf2)\n+SYM(__gtesf2):\n+#ifndef FLOAT_FORMAT_MOTOROLA\n+\tmov\tTMP0,0xffff\n+\tmovt\tTMP0,0x7f\n+\tadd\tTMP0,TMP0,r0\n+\teor\tTMP0,TMP0,r0\n+\tblt\t.Lret\n+\tmov\tTMP0,0xffff\n+\tmovt\tTMP0,0x7f\n+\tadd\tTMP0,TMP0,r1\n+#else\n+\tadd\tTMP0,r0,0x3ff; check for r0 NaN\n+\teor\tTMP0,TMP0,r0\n+\tblt\t.Lret\n+\tadd\tTMP0,r1,0x3ff; check for r1 NaN\n+#endif\n+\teor\tTMP0,TMP0,r1\n+\tblt\t.Lret\n+\tand\tTMP0,r0,r1\n+\tblt\t.Lneg\n+\torr\tTMP0,r0,r1\n+\tlsl\tTMP0,TMP0,1\n+\tbeq\t.Lret\n+\tsub\tTMP0,r0,r1\n+.Lret:\n+\trts\n+\t.balign 4\n+.Lneg:\n+\tsub\tTMP0,r1,r0\n+\trts\n+\tENDFUNC(__gtesf2)"}, {"sha": "8493660102c495ac051df612d92e6bd7a9ba55cc", "filename": "libgcc/config/epiphany/ieee-754/ordsf2.S", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fieee-754%2Fordsf2.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fieee-754%2Fordsf2.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fieee-754%2Fordsf2.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,50 @@\n+/* Copyright (C) 2008, 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"../epiphany-asm.h\"\n+\n+\tFSTAB (__ordsf2,T_INT)\n+\t.global SYM(__ordsf2)\n+\t.balign 8,,2\n+\tHIDDEN_FUNC(__ordsf2)\n+SYM(__ordsf2):\n+#ifndef FLOAT_FORMAT_MOTOROLA\n+\tmov\tTMP0,0\n+\tmovt\tTMP0,0xff00\n+\tlsl\tTMP1,r0,1\n+\tsub\tTMP1,TMP1,TMP0\n+\tbgtu\t.Lret\n+\tlsl\tTMP1,r1,1\n+\tsub\tTMP1,TMP1,TMP0\n+.Lret:\trts /* ordered: lteu */\n+#else\n+\t/* Assumption: NaNs have all bits 9..30 and one of bit 0..8 set.  */\n+\tlsl\tTMP0,r0,1\n+\tadd\tTMP0,TMP0,0x3fe\n+\tbgteu\t.Lret\n+\tlsl\tTMP0,r1,1\n+\tadd\tTMP0,TMP0,0x3fe\n+.Lret:\trts /* ordered: ltu */\n+#endif\n+\tENDFUNC(__ordsf2)"}, {"sha": "cba04d3946c9e019e6a3421f79c873cd5a0876f5", "filename": "libgcc/config/epiphany/ieee-754/uneqsf2.S", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fieee-754%2Funeqsf2.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fieee-754%2Funeqsf2.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fieee-754%2Funeqsf2.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,45 @@\n+/* Copyright (C) 2008, 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"../epiphany-asm.h\"\n+\n+\tFSTAB (__uneqsf2,T_INT)\n+\t.global SYM(__uneqsf2)\n+\t.balign 8,,2\n+\tHIDDEN_FUNC(__uneqsf2)\n+SYM(__uneqsf2):\n+        sub     TMP0,r0,r1\n+        beq     .Lret\n+        orr     TMP0,r0,r1\n+        add     TMP0,TMP0,TMP0\n+        beq     .Lret\n+\tmov\tTMP0,1\n+\tmovt\tTMP0,0xff00\n+\tlsl\tTMP1,r0,1\n+\tsub\tTMP1,TMP0,TMP1\n+\tblteu\t.Lret\n+\tlsl\tTMP1,r1,1\n+\tsub\tTMP1,TMP0,TMP1\n+.Lret:\trts /* uneq: lteu */\n+\tENDFUNC(__uneqsf2)"}, {"sha": "b789412ac1fd236431a2752a488d63107065fb23", "filename": "libgcc/config/epiphany/modsi3-float.S", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fmodsi3-float.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fmodsi3-float.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fmodsi3-float.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,65 @@\n+/* Unsigned 32 bit division optimized for Epiphany.\n+   Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"epiphany-asm.h\"\n+\n+\tFSTAB (__modsi3,T_UINT)\n+\t.global SYM(__modsi3)\n+\t.balign 4\n+\tHIDDEN_FUNC(__modsi3)\n+SYM(__modsi3):\n+\tasr TMP3,r0,31 ; save sign\n+\t float TMP0,r0\n+\tfloat TMP1,r1\n+\t mov r2,0\n+\tsub TMP4,r2,r0\n+\tbeq .Lret_r0\n+\tmovgt r0,TMP4\n+\tsub TMP2,r2,r1\n+\tmovlte TMP2,r1\n+\tsub r2,TMP0,TMP1\n+\tlsl r2,r2,1\n+\tblte .L0step\n+\tasr TMP4,r2,24\n+\tlsl r2,TMP4,3\n+\tmov TMP4,%low(.L0step)\n+\tmovt TMP4,%high(.L0step)\n+\tsub r2,TMP4,r2\n+\tjr r2\n+#define STEP(n) lsl.l r2,TMP2,n` sub r2,r0,r2` movgteu r0,r2\n+\t.balign 8,,2\n+\tSTEP(31)` STEP(30)` STEP(29)` STEP(28)`\n+\tSTEP(27)` STEP(26)` STEP(25)` STEP(24)`\n+\tSTEP(23)` STEP(22)` STEP(21)` STEP(20)`\n+\tSTEP(19)` STEP(18)` STEP(17)` STEP(16)`\n+\tSTEP(15)` STEP(14)` STEP(13)` STEP(12)`\n+\tSTEP(11)` STEP(10)` STEP(9)`  STEP(8)`\n+\tSTEP(7)` STEP(6)` STEP(5)` STEP(4)` STEP(3)` STEP(2)` STEP(1)\n+.L0step:STEP(0)\n+\teor r0,r0,TMP3 ; restore sign\n+\tsub r0,r0,TMP3\n+.Lret_r0:\n+\trts\n+\tENDFUNC(__modsi3)"}, {"sha": "d969b79c9333f9886eeb6af9b9f3a8b5b77928c9", "filename": "libgcc/config/epiphany/modsi3.S", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fmodsi3.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fmodsi3.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fmodsi3.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,77 @@\n+/* Signed 32 bit modulo optimized for Epiphany.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"epiphany-asm.h\"\n+\n+\tFSTAB (__modsi3,T_INT)\n+\t.global SYM(__modsi3)\n+\t.balign 4\n+\tHIDDEN_FUNC(__modsi3)\n+SYM(__modsi3):\n+\tasr r17,r0,31 ; save sign\n+\tmov r2,0\n+\tsub r3,r2,r0\n+\tmovgt r0,r3\n+\tsub r3,r2,r1\n+\tmovgt r1,r3\n+\tmovt r2,0xa000 ; 0xa0000000\n+\torr r3,r2,r0\n+\tlsr r15,r0,16\n+\tmovt r15,0xa800\n+\tmovne r3,r15\n+\tlsr r16,r2,2 ; 0x28000000\n+\tand r15,r3,r16\n+\tfadd r12,r3,r15\n+\t orr r3,r2,r1\n+\tlsr r2,r1,16\n+\tmovt r2,0xa800\n+\tmovne r3,r2\n+\tand r2,r16,r3\n+\tfadd r3,r3,r2\n+\t sub r2,r0,r1\n+\tbltu .Lret_a\n+\tlsr r12,r12,23\n+\tmov r2,%low(.L0step)\n+\tmovt r2,%high(.L0step)\n+\tlsr r3,r3,23\n+\tsub r3,r12,r3 ; calculate bit number difference.\n+\tlsl r3,r3,3\n+\tsub r2,r2,r3\n+\tjr r2\n+/*              lsl_l r2,r1,n`               sub r2,r0,r2` movgteu r0,r2  */\n+#define STEP(n) .long 0x0006441f | (n) << 5` sub r2,r0,r2` movgteu r0,r2\n+\t.balign 8,,2\n+\tSTEP(31)` STEP(30)` STEP(29)` STEP(28)`\n+\tSTEP(27)` STEP(26)` STEP(25)` STEP(24)`\n+\tSTEP(23)` STEP(22)` STEP(21)` STEP(20)`\n+\tSTEP(19)` STEP(18)` STEP(17)` STEP(16)`\n+\tSTEP(15)` STEP(14)` STEP(13)` STEP(12)`\n+\tSTEP(11)` STEP(10)` STEP(9)`  STEP(8)`\n+\tSTEP(7)` STEP(6)` STEP(5)` STEP(4)` STEP(3)` STEP(2)` STEP(1)\n+.L0step:STEP(0)\n+.Lret_a:eor r0,r0,r17 ; restore sign\n+\tsub r0,r0,r17\n+\trts\n+\tENDFUNC(__modsi3)"}, {"sha": "feee3d1ea2538c2289ebaff4f7ee60144a55a02e", "filename": "libgcc/config/epiphany/modsi3.c", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fmodsi3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fmodsi3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fmodsi3.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,106 @@\n+/* Generic signed 32 bit modulo implementation.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+typedef union { unsigned int i; float f; } fu;\n+\n+unsigned int __modsi3 (unsigned int a, unsigned int b);\n+\n+unsigned int\n+__modsi3 (unsigned int a, unsigned int b)\n+{\n+  unsigned int sign = (int) a >> 31;\n+  unsigned int d, t, s0, s1, s2, r0, r1;\n+  fu u0, u1, u2, u1b, u2b;\n+\n+  a = abs (a);\n+  b = abs (b);\n+\n+  if (b > a)\n+    goto ret_a;\n+\n+  /* Compute difference in number of bits in S0.  */\n+  u0.i = 0x40000000;\n+  u1b.i = u2b.i = u0.i;\n+  u1.i = a;\n+  u2.i = b;\n+  u1.i = a | u0.i;\n+  t = 0x4b800000 | ((a >> 23) & 0xffff);\n+  if (a >> 23)\n+    {\n+      u1.i = t;\n+      u1b.i = 0x4b800000;\n+    }\n+  u2.i = b | u0.i;\n+  t = 0x4b800000 | ((b >> 23) & 0xffff);\n+  if (b >> 23)\n+    {\n+      u2.i = t;\n+      u2b.i = 0x4b800000;\n+    }\n+  u1.f = u1.f - u1b.f;\n+  u2.f = u2.f - u2b.f;\n+  s1 = u1.i >> 23;\n+  s2 = u2.i >> 23;\n+  s0 = s1 - s2;\n+\n+#define STEP(n) case n: d = b << n; t = a - d; if (t <= a) a = t;\n+  switch (s0)\n+    {\n+    STEP (31)\n+    STEP (30)\n+    STEP (29)\n+    STEP (28)\n+    STEP (27)\n+    STEP (26)\n+    STEP (25)\n+    STEP (24)\n+    STEP (23)\n+    STEP (22)\n+    STEP (21)\n+    STEP (20)\n+    STEP (19)\n+    STEP (18)\n+    STEP (17)\n+    STEP (16)\n+    STEP (15)\n+    STEP (14)\n+    STEP (13)\n+    STEP (12)\n+    STEP (11)\n+    STEP (10)\n+    STEP (9)\n+    STEP (8)\n+    STEP (7)\n+    STEP (6)\n+    STEP (5)\n+    STEP (4)\n+    STEP (3)\n+    STEP (2)\n+    STEP (1)\n+    STEP (0)\n+    }\n+ ret_a:\n+  return (a ^ sign) - sign;\n+}"}, {"sha": "148361d92be07d767b8a0ba68201cbfc608b508a", "filename": "libgcc/config/epiphany/mulsi3.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fmulsi3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fmulsi3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fmulsi3.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,39 @@\n+/* Generic 32 bit multiply.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+unsigned int\n+__mulsi3 (unsigned int a, unsigned int b)\n+{\n+  unsigned int r = 0;\n+\n+  while (a)\n+    {\n+      if (a & 1)\n+\tr += b;\n+      a >>= 1;\n+      b <<= 1;\n+    }\n+  return r;\n+}"}, {"sha": "3b5a54acef237058ea52c1a555fd4b8522001c62", "filename": "libgcc/config/epiphany/t-custom-eqsf", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Ft-custom-eqsf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Ft-custom-eqsf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Ft-custom-eqsf?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1 @@\n+FPBIT_FUNCS := $(filter-out _eq_sf,$(FPBIT_FUNCS))"}, {"sha": "4b67f5d4690a73096634f919fd9e2c4fc802505c", "filename": "libgcc/config/epiphany/t-epiphany", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Ft-epiphany", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Ft-epiphany", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Ft-epiphany?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,35 @@\n+# Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003,\n+# 2004, 2009, 2010, 2011 Free Software Foundation, Inc.\n+# Contributed by Embecosm on behalf of Adapteva, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+LIB2ADD_ST = $(srcdir)/config/epiphany/modsi3-float.S \\\n+\t     $(srcdir)/config/epiphany/divsi3-float.S \\\n+\t     $(srcdir)/config/epiphany/udivsi3-float.S \\\n+\t     $(srcdir)/config/epiphany/umodsi3-float.S \\\n+\t     $(srcdir)/config/epiphany/ieee-754/eqsf2.S \\\n+\t     $(srcdir)/config/epiphany/ieee-754/gtesf2.S \\\n+\t     $(srcdir)/config/epiphany/ieee-754/ordsf2.S \\\n+\t     $(srcdir)/config/epiphany/ieee-754/uneqsf2.S \\\n+\t     $(srcdir)/config/epiphany/ieee-754/fast_div.S\n+\n+# .init/.fini section routines\n+\n+crtint.o crtrunc.o crtm1reg-r43.o crtm1reg-r63.o : \\\n+  %.o: $(srcdir)/config/epiphany/%.S $(GCC_PASSES) $(CONFIG_H)\n+\t$(crt_compile) -c -x assembler-with-cpp $<"}, {"sha": "5c960dce5f00e08f74f08582b78f3aba4e43b100", "filename": "libgcc/config/epiphany/udivsi3-float.S", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fudivsi3-float.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fudivsi3-float.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fudivsi3-float.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,83 @@\n+/* Unsigned 32 bit division optimized for Epiphany.\n+   Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"epiphany-asm.h\"\n+\n+\tFSTAB (__udivsi3,T_UINT)\n+\t.global SYM(__udivsi3)\n+\t.balign 4\n+\tHIDDEN_FUNC(__udivsi3)\n+SYM(__udivsi3):\n+\tsub TMP0,r0,r1\n+\tbltu .Lret0\n+\tfloat TMP2,r0\n+\t  mov TMP1,%low(0xb0800000) ; ??? this would be faster with small data\n+\tfloat TMP3,r1\n+\t  movt TMP1,%high(0xb0800000)\n+\tasr TMP0,r0,8\n+\tsub TMP0,TMP0,TMP1\n+\tmovt TMP1,%high(0x00810000)\n+\tmovgteu TMP2,TMP0\n+\tbblt .Lret1\n+\tsub TMP2,TMP2,TMP1\n+\tsub TMP2,TMP2,TMP3\n+\tmov TMP3,0\n+\tmovltu TMP2,TMP3\n+\tlsr TMP2,TMP2,23\n+\tlsl r1,r1,TMP2\n+\tmov TMP0,1\n+\tlsl TMP0,TMP0,TMP2\n+\tsub r0,r0,r1\n+\tbltu .Ladd_back\n+\tadd TMP3,TMP3,TMP0\n+\tsub r0,r0,r1\n+\tbltu .Ladd_back\n+.Lsub_loop:; More than two iterations are rare, so it makes sense to leave\n+           ; this label here to reduce average branch penalties.\n+\tadd TMP3,TMP3,TMP0\n+\tsub r0,r0,r1\n+\tbgteu .Lsub_loop\n+.Ladd_back:\n+\tadd r0,r0,r1\n+\tsub TMP1,r1,1\n+\tmov r1,%low(.L0step)\n+\tmovt r1,%high(.L0step)\n+\tlsl TMP2,TMP2,3\n+\tsub r1,r1,TMP2\n+\tjr r1\n+\t.rep 30\n+\tlsl r0,r0,1\n+\tsub.l r1,r0,TMP1\n+\tmovgteu r0,r1\n+\t.endr\n+.L0step:sub r1,TMP0,1 ; mask result bits from steps ...\n+\tand r0,r0,r1\n+\torr r0,r0,TMP3 ; ... and combine with first bits.\n+\trts\n+.Lret0:\tmov r0,0\n+\trts\n+.Lret1:\tmov r0,1\n+\trts\n+\tENDFUNC(__udivsi3)"}, {"sha": "c7f10590c498d0461e99d5de4e43dd19929a5da7", "filename": "libgcc/config/epiphany/udivsi3-float.c", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fudivsi3-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fudivsi3-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fudivsi3-float.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,125 @@\n+/* Generic unsigned 32 bit division implementation.\n+   Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+typedef union { unsigned int i; float f; } fu;\n+\n+unsigned int __udivsi3 (unsigned int a, unsigned int b);\n+\n+unsigned int\n+__udivsi3 (unsigned int a, unsigned int b)\n+{\n+  unsigned int d, t, s0, s1, s2, r0, r1;\n+  fu u0, u1, u2,  u1b, u2b;\n+\n+  if (b > a)\n+    return 0;\n+  if ((int) b < 0)\n+    return 1;\n+\n+  /* Assuming B is nonzero, compute S0 such that 0 <= S0,\n+     (B << S0+1) does not overflow,\n+     A < 4.01 * (B << S0), with S0 choosen as small as possible\n+     without taking to much time calculating.  */\n+#ifdef CONVERT_UNSIGNED\n+  u0.f = a;\n+  u1.f = b;\n+#else /* !CONVERT_UNSIGNED */\n+  u0.f = (int) a;\n+  u1.f = (int) b;\n+#ifdef CONCISE\n+  if (a < 0)\n+    u0.i = (a >> 8) - 0x00800000 + 0x3f800000 + (31 << 23);\n+#else /* To use flag seting / cmove, this can be written as:  */\n+ {\n+  unsigned c = 0xff800000 - 0x4f000000;\n+  t = (int)a >> 8;\n+  if (t >= c)\n+    u0.i = (t - c);\n+ }\n+#endif\n+#endif /* !CONVERT_UNSIGNED */\n+  s0 = u0.i + 1 /* Compensate for rounding errors.  */\n+\t    - 0x00800000 /* adjust by one */ ;\n+  s0 = s0 - u1.i;\n+  s0 = (int)s0 >= 0 ? s0 : 0;\n+  s0 >>= 23;\n+\n+  b <<= s0;\n+  r1 = 0;\n+\n+  r0 = 1 << s0;\n+  a = ((t=a) - b);\n+  if (a <= t)\n+    {\n+      r1 += r0;\n+      a = ((t=a) - b);\n+      if (a <= t)\n+\tdo {\n+\t  r1 += r0;\n+\t  a = ((t=a) - b);\n+\t} while (a <= t);\n+    }\n+  a += b;\n+  d = b - 1;\n+\n+#define STEP(n) case n: a += a; t = a - d; if (t <= a) a = t;\n+  switch (s0)\n+    {\n+    STEP (31)\n+    STEP (30)\n+    STEP (29)\n+    STEP (28)\n+    STEP (27)\n+    STEP (26)\n+    STEP (25)\n+    STEP (24)\n+    STEP (23)\n+    STEP (22)\n+    STEP (21)\n+    STEP (20)\n+    STEP (19)\n+    STEP (18)\n+    STEP (17)\n+    STEP (16)\n+    STEP (15)\n+    STEP (14)\n+    STEP (13)\n+    STEP (12)\n+    STEP (11)\n+    STEP (10)\n+    STEP (9)\n+    STEP (8)\n+    STEP (7)\n+    STEP (6)\n+    STEP (5)\n+    STEP (4)\n+    STEP (3)\n+    STEP (2)\n+    STEP (1)\n+    case 0: ;\n+    }\n+  r0 = r1 | (r0-1 & a);\n+  return r0;\n+}"}, {"sha": "1396281f73afdfee21baca207c4042150d383112", "filename": "libgcc/config/epiphany/udivsi3.S", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fudivsi3.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fudivsi3.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fudivsi3.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,85 @@\n+/* Unsigned 32 bit division optimized for Epiphany.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"epiphany-asm.h\"\n+\n+\tFSTAB (__udivsi3,T_UINT)\n+\t.global SYM(__udivsi3)\n+\t.balign 4\n+\tHIDDEN_FUNC(__udivsi3)\n+SYM(__udivsi3):\n+\tsub r3,r0,r1\n+\tbltu .Lret0\n+\tmov r3,0x95\n+\tlsl r12,r3,23 ; 0x4a800000\n+\tlsl r3,r3,30 ; 0x40000000\n+\torr r16,r0,r3\n+\torr r2,r1,r3\n+\t fsub r16,r16,r3\n+\tfsub r2,r2,r3\n+\t lsr r3,r1,21\n+\tlsr r17,r0,21\n+\tmovt r17,0x4a80\n+\tfsub r17,r17,r12\n+\t movt r3,0x4a80\n+\tfsub r3,r3,r12\n+\t mov r12,%low(.L0step)\n+\tmovt r12,%high(.L0step)\n+\tmov r21,1\n+\tmovne r16,r17\n+\tlsr r17,r1,21\n+\tmovne r2,r3\n+\tlsr r3,r16,23 ; must mask lower bits of r2 in case op0 was ..\n+\tlsr r2,r2,23 ; .. shifted and op1 was not.\n+\tsub r3,r3,r2 ; calculate bit number difference.\n+\tlsl r1,r1,r3\n+\tlsr r16,r1,1\n+\tlsl r2,r21,r3\n+\tlsl r3,r3,3\n+\tsub r12,r12,r3\n+\tsub r3,r0,r1\n+\tmovltu r3,r0\n+\tmov r0,0\n+\tmovgteu r0,r2\n+\tlsr r2,r2,1\n+\tadd r17,r2,r0\n+\tsub r1,r3,r16\n+\tmovgteu r3,r1\n+\tmovgteu r0,r17\n+\tsub r16,r16,1\n+\tjr r12\n+\t.rep 30\n+\tlsl r3,r3,1\n+\tsub r1,r3,r16\n+\tmovgteu r3,r1\n+\t.endr\n+\tsub r2,r2,1 ; mask result bits from steps ...\n+\tand r3,r3,r2\n+\torr r0,r0,r3 ; ... and combine with first bits.\n+\tnop\n+.L0step:rts\n+.Lret0:\tmov r0,0\n+\trts\n+\tENDFUNC(__udivsi3)"}, {"sha": "cd34c6d761c88599ad810912e1a6c9bfa5f8971e", "filename": "libgcc/config/epiphany/udivsi3.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fudivsi3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fudivsi3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fudivsi3.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,114 @@\n+/* Generic unsigned 32 bit division implementation.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+typedef union { unsigned int i; float f; } fu;\n+\n+unsigned int __udivsi3 (unsigned int a, unsigned int b);\n+\n+unsigned int\n+__udivsi3 (unsigned int a, unsigned int b)\n+{\n+  unsigned int d, t, s0, s1, s2, r0, r1;\n+  fu u0, u1, u2,  u1b, u2b;\n+\n+  if (b > a)\n+    return 0;\n+\n+  /* Compute difference in number of bits in S0.  */\n+  u0.i = 0x40000000;\n+  u1b.i = u2b.i = u0.i;\n+  u1.i = a;\n+  u2.i = b;\n+  u1.i = a | u0.i;\n+  t = 0x4b800000 | ((a >> 23) & 0xffff);\n+  if (a >> 23)\n+    {\n+      u1.i = t;\n+      u1b.i = 0x4b800000;\n+    }\n+  u2.i = b | u0.i;\n+  t = 0x4b800000 | ((b >> 23) & 0xffff);\n+  if (b >> 23)\n+    {\n+      u2.i = t;\n+      u2b.i = 0x4b800000;\n+    }\n+  u1.f = u1.f - u1b.f;\n+  u2.f = u2.f - u2b.f;\n+  s1 = u1.i >> 23;\n+  s2 = u2.i >> 23;\n+  s0 = s1 - s2;\n+\n+  b <<= s0;\n+  d = b - 1;\n+\n+  r0 = 1 << s0;\n+  r1 = 0;\n+  t = a - b;\n+  if (t <= a)\n+    {\n+      a = t;\n+      r1 = r0;\n+    }\n+\n+#define STEP(n) case n: a += a; t = a - d; if (t <= a) a = t;\n+  switch (s0)\n+    {\n+    STEP (31)\n+    STEP (30)\n+    STEP (29)\n+    STEP (28)\n+    STEP (27)\n+    STEP (26)\n+    STEP (25)\n+    STEP (24)\n+    STEP (23)\n+    STEP (22)\n+    STEP (21)\n+    STEP (20)\n+    STEP (19)\n+    STEP (18)\n+    STEP (17)\n+    STEP (16)\n+    STEP (15)\n+    STEP (14)\n+    STEP (13)\n+    STEP (12)\n+    STEP (11)\n+    STEP (10)\n+    STEP (9)\n+    STEP (8)\n+    STEP (7)\n+    STEP (6)\n+    STEP (5)\n+    STEP (4)\n+    STEP (3)\n+    STEP (2)\n+    STEP (1)\n+    case 0: ;\n+    }\n+  r0 = r1 | (r0-1 & a);\n+  return r0;\n+}"}, {"sha": "ca5db48906c65b61299262e28b73a9e3e727ddd4", "filename": "libgcc/config/epiphany/umodsi3-float.S", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fumodsi3-float.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fumodsi3-float.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fumodsi3-float.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,63 @@\n+/* Unsigned 32 bit division optimized for Epiphany.\n+   Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"epiphany-asm.h\"\n+\n+/* Because we handle a divident with bit 31 set with truncating integer\n+   arithmetic, there is no rounding-related overflow.  */\n+\tFSTAB (__umodsi3,T_UINT)\n+\t.global SYM(__umodsi3)\n+\t.balign 4\n+\tHIDDEN_FUNC(__umodsi3)\n+SYM(__umodsi3):\n+\tfloat r2,r0\n+\t  mov TMP1,%low(0xb0800000) ; ??? this would be faster with small data\n+\tfloat TMP2,r1\n+\t  movt TMP1,%high(0xb0800000)\n+\tasr TMP0,r0,8\n+\tsub TMP0,TMP0,TMP1\n+\tmov TMP1,%low(.L0step)\n+\tmovgteu r2,TMP0\n+\tsub r2,r2,TMP2\n+\tblteu .L0step\n+\tasr r2,r2,23\n+\tmovt TMP1,%high(.L0step)\n+\tlsl TMP2,r2,3\n+\tlsl r2,r1,r2` sub r2,r0,r2` movgteu r0,r2 ; STEP(r2)\n+\tsub r2,TMP1,TMP2\n+\tjr r2\n+#define STEP(n) lsl.l r2,r1,n` sub r2,r0,r2` movgteu r0,r2\n+\t.balign 8,,2\n+\tSTEP(31)` STEP(30)` STEP(29)` STEP(28)`\n+\tSTEP(27)` STEP(26)` STEP(25)` STEP(24)`\n+\tSTEP(23)` STEP(22)` STEP(21)` STEP(20)`\n+\tSTEP(19)` STEP(18)` STEP(17)` STEP(16)`\n+\tSTEP(15)` STEP(14)` STEP(13)` STEP(12)`\n+\tSTEP(11)` STEP(10)` STEP(9)`  STEP(8)`\n+\tSTEP(7)` STEP(6)` STEP(5)` STEP(4)` STEP(3)` STEP(2)` STEP(1)\n+.L0step:STEP(0)\n+.Lret_r0:\n+\trts\n+\tENDFUNC(__umodsi3)"}, {"sha": "6f808fdc7aab1decdb223385c51231b56c280559", "filename": "libgcc/config/epiphany/umodsi3.S", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fumodsi3.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fumodsi3.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fumodsi3.S?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,70 @@\n+/* Unsigned 32 bit modulo optimized for Epiphany.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"epiphany-asm.h\"\n+\n+\tFSTAB (__umodsi3,T_UINT)\n+\t.global SYM(__umodsi3)\n+\t.balign 4\n+\tHIDDEN_FUNC(__umodsi3)\n+SYM(__umodsi3):\n+\tmov r2,5\n+\tlsl r2,r2,29 ; 0xa0000000\n+\torr r3,r2,r0\n+\tlsr r15,r0,16\n+\tmovt r15,0xa800\n+\tmovne r3,r15\n+\tlsr r16,r2,2 ; 0x28000000\n+\tand r15,r3,r16\n+\tfadd r12,r3,r15\n+\t orr r3,r2,r1\n+\tlsr r2,r1,16\n+\tmovt r2,0xa800\n+\tmovne r3,r2\n+\tand r2,r16,r3\n+\tfadd r3,r3,r2\n+\t sub r2,r0,r1\n+\tbltu .Lret_a\n+\tlsr r12,r12,23\n+\tmov r2,%low(.L0step)\n+\tmovt r2,%high(.L0step)\n+\tlsr r3,r3,23\n+\tsub r3,r12,r3 ; calculate bit number difference.\n+\tlsl r3,r3,3\n+\tsub r2,r2,r3\n+\tjr r2\n+/*              lsl_l r2,r1,n`               sub r2,r0,r2` movgteu r0,r2  */\n+#define STEP(n) .long 0x0006441f | (n) << 5` sub r2,r0,r2` movgteu r0,r2\n+\t.balign 8,,2\n+\tSTEP(31)` STEP(30)` STEP(29)` STEP(28)`\n+\tSTEP(27)` STEP(26)` STEP(25)` STEP(24)`\n+\tSTEP(23)` STEP(22)` STEP(21)` STEP(20)`\n+\tSTEP(19)` STEP(18)` STEP(17)` STEP(16)`\n+\tSTEP(15)` STEP(14)` STEP(13)` STEP(12)`\n+\tSTEP(11)` STEP(10)` STEP(9)`  STEP(8)`\n+\tSTEP(7)` STEP(6)` STEP(5)` STEP(4)` STEP(3)` STEP(2)` STEP(1)\n+.L0step:STEP(0)\n+.Lret_a:rts\n+\tENDFUNC(__umodsi3)"}, {"sha": "609a250f14a6038017c279375d3aef71317e0be3", "filename": "libgcc/config/epiphany/umodsi3.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fumodsi3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feeeff5cfe8c282a769346285fee4f7b6deac64d/libgcc%2Fconfig%2Fepiphany%2Fumodsi3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fepiphany%2Fumodsi3.c?ref=feeeff5cfe8c282a769346285fee4f7b6deac64d", "patch": "@@ -0,0 +1,101 @@\n+/* Generic unsigned 32 bit modulo implementation.\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Embecosm on behalf of Adapteva, Inc.\n+\n+This file is part of GCC.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+typedef union { unsigned int i; float f; } fu;\n+\n+unsigned int __umodsi3 (unsigned int a, unsigned int b);\n+\n+unsigned int\n+__umodsi3 (unsigned int a, unsigned int b)\n+{\n+  unsigned int d, t, s0, s1, s2, r0, r1;\n+  fu u0, u1, u2,  u1b, u2b;\n+\n+  if (b > a)\n+    return a;\n+\n+  /* Compute difference in number of bits in S0.  */\n+  u0.i = 0x40000000;\n+  u1b.i = u2b.i = u0.i;\n+  u1.i = a;\n+  u2.i = b;\n+  u1.i = a | u0.i;\n+  t = 0x4b800000 | ((a >> 23) & 0xffff);\n+  if (a >> 23)\n+    {\n+      u1.i = t;\n+      u1b.i = 0x4b800000;\n+    }\n+  u2.i = b | u0.i;\n+  t = 0x4b800000 | ((b >> 23) & 0xffff);\n+  if (b >> 23)\n+    {\n+      u2.i = t;\n+      u2b.i = 0x4b800000;\n+    }\n+  u1.f = u1.f - u1b.f;\n+  u2.f = u2.f - u2b.f;\n+  s1 = u1.i >> 23;\n+  s2 = u2.i >> 23;\n+  s0 = s1 - s2;\n+\n+#define STEP(n) case n: d = b << n; t = a - d; if (t <= a) a = t;\n+  switch (s0)\n+    {\n+    STEP (31)\n+    STEP (30)\n+    STEP (29)\n+    STEP (28)\n+    STEP (27)\n+    STEP (26)\n+    STEP (25)\n+    STEP (24)\n+    STEP (23)\n+    STEP (22)\n+    STEP (21)\n+    STEP (20)\n+    STEP (19)\n+    STEP (18)\n+    STEP (17)\n+    STEP (16)\n+    STEP (15)\n+    STEP (14)\n+    STEP (13)\n+    STEP (12)\n+    STEP (11)\n+    STEP (10)\n+    STEP (9)\n+    STEP (8)\n+    STEP (7)\n+    STEP (6)\n+    STEP (5)\n+    STEP (4)\n+    STEP (3)\n+    STEP (2)\n+    STEP (1)\n+    STEP (0)\n+    }\n+  return a;\n+}"}]}