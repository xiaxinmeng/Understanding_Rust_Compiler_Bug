{"sha": "14886ab7b706a6b19c262d4c3b9684afb0e879c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ4ODZhYjdiNzA2YTZiMTljMjYyZDRjM2I5Njg0YWZiMGU4NzljMQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-05-18T16:13:44Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-05-18T16:13:44Z"}, "message": "* tree-ssa-phiopt.c: Fix various formatting issues.\n\nFrom-SVN: r81995", "tree": {"sha": "039cfcd0199be0c853359845b4ed10d683b00e87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/039cfcd0199be0c853359845b4ed10d683b00e87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14886ab7b706a6b19c262d4c3b9684afb0e879c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14886ab7b706a6b19c262d4c3b9684afb0e879c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14886ab7b706a6b19c262d4c3b9684afb0e879c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14886ab7b706a6b19c262d4c3b9684afb0e879c1/comments", "author": null, "committer": null, "parents": [{"sha": "81f4be3ce1fd9f08d811cf61413e374e0dc43166", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81f4be3ce1fd9f08d811cf61413e374e0dc43166", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81f4be3ce1fd9f08d811cf61413e374e0dc43166"}], "stats": {"total": 159, "additions": 80, "deletions": 79}, "files": [{"sha": "c7340043c0bb15f1a3878ee784742e40c232fcd5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14886ab7b706a6b19c262d4c3b9684afb0e879c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14886ab7b706a6b19c262d4c3b9684afb0e879c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14886ab7b706a6b19c262d4c3b9684afb0e879c1", "patch": "@@ -1,3 +1,7 @@\n+2004-05-18  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-phiopt.c: Fix various formatting issues.\n+\n 2004-05-18  Steven Bosscher  <stevenb@suse.de>\n \n \t* config/s390/s390.c (s390_expand_movstr, s390_expand_clrstr,"}, {"sha": "85dceee42cbc769697cf5332a73c4f5e26a72b89", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 76, "deletions": 79, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14886ab7b706a6b19c262d4c3b9684afb0e879c1/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14886ab7b706a6b19c262d4c3b9684afb0e879c1/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=14886ab7b706a6b19c262d4c3b9684afb0e879c1", "patch": "@@ -37,8 +37,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n static void tree_ssa_phiopt (void);\n static bool conditional_replacement (basic_block bb, tree phi, tree arg0,\n-                                     tree arg1);                            \n-                                  \n+\t\t\t\t     tree arg1);\t\t\t    \n+\t\t\t\t  \n /* This pass eliminates PHI nodes which can be trivially implemented as\n    an assignment from a conditional expression.  ie if we have something\n    like:\n@@ -49,16 +49,16 @@ static bool conditional_replacement (basic_block bb, tree phi, tree arg0,\n      bb2:\n       x = PHI (0 (bb1), 1 (bb0)\n \n-    We can rewrite that as:\n+   We can rewrite that as:\n     \n-    bb0:\n-    bb1:\n-    bb2:\n+     bb0:\n+     bb1:\n+     bb2:\n       x = cond;\n \n-    bb1 will become unreachable and bb0 and bb2 will almost always\n-    be merged into a single block.  This occurs often due to gimplification\n-    of conditionals.  */\n+   bb1 will become unreachable and bb0 and bb2 will almost always\n+   be merged into a single block.  This occurs often due to gimplification\n+   of conditionals.  */\n    \n static void\n tree_ssa_phiopt (void)\n@@ -77,19 +77,18 @@ tree_ssa_phiopt (void)\n       phi = phi_nodes (bb);\n       if (phi && TREE_CHAIN (phi) == NULL\n \t  && PHI_NUM_ARGS (phi) == 2)\n-        {\n-\n-            arg0 = PHI_ARG_DEF (phi, 0);\n-            arg1 = PHI_ARG_DEF (phi, 1);\n-            \n-            /* Do the replacement of conditional if it can be done.  */\n-            if (conditional_replacement (bb, phi, arg0, arg1))\n-              {\n-                /* We have done the replacement so we need to rebuild the cfg.   */\n-                removed_phis = true;\n-                continue;\n-              }\n-        }\n+\t{\n+\t  arg0 = PHI_ARG_DEF (phi, 0);\n+\t  arg1 = PHI_ARG_DEF (phi, 1);\n+\t    \n+\t  /* Do the replacement of conditional if it can be done.  */\n+\t  if (conditional_replacement (bb, phi, arg0, arg1))\n+\t    {\n+\t      /* We have done the replacement so we need to rebuild the cfg.  */\n+\t      removed_phis = true;\n+\t      continue;\n+\t    }\n+\t}\n     }\n \n   /* If we removed any PHIs, then we have unreachable blocks and blocks\n@@ -98,10 +97,11 @@ tree_ssa_phiopt (void)\n     cleanup_tree_cfg ();\n }\n \n-/*  The function conditional_replacement does the main work of doing the conditional\n-    replacement.  Return true if the replacement is done.  Otherwise return false.\n-    bb is the basic block where the replacement is going to be done on.  arg0\n-    is argument 0 from the phi.  Likewise for arg1.   */\n+/*  The function conditional_replacement does the main work of doing the\n+    conditional replacement.  Return true if the replacement is done.\n+    Otherwise return false.\n+    BB is the basic block where the replacement is going to be done on.  ARG0\n+    is argument 0 from PHI.  Likewise for ARG1.   */\n \n static bool\n conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n@@ -116,16 +116,16 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   tree new_var = NULL;\n \n   /* The PHI arguments have the constants 0 and 1, then convert\n-    it to the conditional.  */\n+     it to the conditional.  */\n   if ((integer_zerop (arg0) && integer_onep (arg1))\n       || (integer_zerop (arg1) && integer_onep (arg0)))\n     ;\n   else\n     return false;\n   \n   /* One of the alternatives must come from a block ending with\n-      a COND_EXPR.  The other block must be entirely empty, except\n-      for labels.  */\n+     a COND_EXPR.  The other block must be entirely empty, except\n+     for labels.  */\n   last0 = last_stmt (bb->pred->src);\n   last1 = last_stmt (bb->pred->pred_next->src);\n   if (last0 && TREE_CODE (last0) == COND_EXPR)\n@@ -142,7 +142,7 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n     return false;\n   \n   /* COND_BLOCK must have precisely two successors.  We indirectly\n-      verify that those successors are BB and OTHER_BLOCK.  */\n+     verify that those successors are BB and OTHER_BLOCK.  */\n   if (!cond_block->succ\n       || !cond_block->succ->succ_next\n       || cond_block->succ->succ_next->succ_next\n@@ -151,8 +151,8 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n     return false;\n   \n   /* OTHER_BLOCK must have a single predecessor which is COND_BLOCK,\n-      OTHER_BLOCK must have a single successor which is BB and\n-      OTHER_BLOCK must have no PHI nodes.  */\n+     OTHER_BLOCK must have a single successor which is BB and\n+     OTHER_BLOCK must have no PHI nodes.  */\n   if (!other_block->pred\n       || other_block->pred->src != cond_block\n       || other_block->pred->pred_next\n@@ -165,19 +165,18 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   /* OTHER_BLOCK must have no executable statements.  */\n   bsi = bsi_start (other_block);\n   while (!bsi_end_p (bsi)\n-          && (TREE_CODE (bsi_stmt (bsi)) == LABEL_EXPR\n-              || IS_EMPTY_STMT (bsi_stmt (bsi))))\n+\t  && (TREE_CODE (bsi_stmt (bsi)) == LABEL_EXPR\n+\t      || IS_EMPTY_STMT (bsi_stmt (bsi))))\n     bsi_next (&bsi);\n   \n   if (!bsi_end_p (bsi))\n     return false;\n   \n   /* If the condition is not a naked SSA_NAME and its type does not\n-      match the type of the result, then we have to create a new\n-      variable to optimize this case as it would likely create\n-      non-gimple code when the condition was converted to the\n-      result's type.  */\n-\n+     match the type of the result, then we have to create a new\n+     variable to optimize this case as it would likely create\n+     non-gimple code when the condition was converted to the\n+     result's type.  */\n   cond = COND_EXPR_COND (last_stmt (cond_block));\n   result = PHI_RESULT (phi);\n   if (TREE_CODE (cond) != SSA_NAME\n@@ -189,13 +188,13 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n     }\n   \n   /* If the condition was a naked SSA_NAME and the type is not the\n-      same as the type of the result, then convert the type of the\n-      condition.  */\n+     same as the type of the result, then convert the type of the\n+     condition.  */\n   if (!lang_hooks.types_compatible_p (TREE_TYPE (cond), TREE_TYPE (result)))\n     cond = fold_convert (TREE_TYPE (result), cond);\n   \n   /* We need to know which is the true edge and which is the false\n-      edge so that we know when to invert the condition below.  */\n+     edge so that we know when to invert the condition below.  */\n   extract_true_false_edges_from_block (cond_block, &true_edge, &false_edge);\n       \n   /* Insert our new statement at the head of our block.  */\n@@ -205,43 +204,41 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n     {\n       tree new1;\n       if (TREE_CODE_CLASS (TREE_CODE (old_result)) != '<')\n-        return false;\n+\treturn false;\n       \n       new1 = build (TREE_CODE (old_result), TREE_TYPE (result),\n-                    TREE_OPERAND (old_result, 0),\n-                    TREE_OPERAND (old_result, 1));\n+\t\t    TREE_OPERAND (old_result, 0),\n+\t\t    TREE_OPERAND (old_result, 1));\n       \n       new1 = build (MODIFY_EXPR, TREE_TYPE (result),\n-                    new_var, new1);\n+\t\t    new_var, new1);\n       bsi_insert_after (&bsi, new1, BSI_NEW_STMT);\n     }\n   \n-  \n   /* At this point we know we have a COND_EXPR with two successors.\n-      One successor is BB, the other successor is an empty block which\n-      falls through into BB.\n-  \n-      There is a single PHI node at the join point (BB) and its arguments\n-      are constants (0, 1).\n+     One successor is BB, the other successor is an empty block which\n+     falls through into BB.\n   \n-      So, given the condition COND, and the two PHI arguments, we can\n-      rewrite this PHI into non-branching code: \n+     There is a single PHI node at the join point (BB) and its arguments\n+     are constants (0, 1).\n   \n-        dest = (COND) or dest = COND'\n+     So, given the condition COND, and the two PHI arguments, we can\n+     rewrite this PHI into non-branching code: \n   \n-      We use the condition as-is if the argument associated with the\n-      true edge has the value one or the argument associated with the\n-      false edge as the value zero.  Note that those conditions are not\n-      the same since only one of the outgoing edges from the COND_EXPR\n-      will directly reach BB and thus be associated with an argument.  */\n+       dest = (COND) or dest = COND'\n   \n+     We use the condition as-is if the argument associated with the\n+     true edge has the value one or the argument associated with the\n+     false edge as the value zero.  Note that those conditions are not\n+     the same since only one of the outgoing edges from the COND_EXPR\n+     will directly reach BB and thus be associated with an argument.  */\n   if ((PHI_ARG_EDGE (phi, 0) == true_edge && integer_onep (arg0))\n       || (PHI_ARG_EDGE (phi, 0) == false_edge && integer_zerop (arg0))\n       || (PHI_ARG_EDGE (phi, 1) == true_edge && integer_onep (arg1))\n       || (PHI_ARG_EDGE (phi, 1) == false_edge && integer_zerop (arg1)))\n     {\n       new = build (MODIFY_EXPR, TREE_TYPE (PHI_RESULT (phi)),\n-                    PHI_RESULT (phi), cond);\n+\t\t    PHI_RESULT (phi), cond);\n     }\n   else\n     {\n@@ -254,35 +251,35 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n \treturn false; \n \n       /* If what we get back is not gimple try to create it as gimple by\n-         using a temporary variable.   */\n+\t using a temporary variable.   */\n       if (is_gimple_cast (cond)\n \t  && !is_gimple_val (TREE_OPERAND (cond, 0)))\n-        {\n-          tree temp = TREE_OPERAND (cond, 0);\n-          tree new_var_1 = make_rename_temp (TREE_TYPE (temp), NULL);\n-          new = build (MODIFY_EXPR, TREE_TYPE (new_var_1), new_var_1, temp);\n-          bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n-          cond = fold_convert (TREE_TYPE (result), new_var_1);\n-        }\n+\t{\n+\t  tree temp = TREE_OPERAND (cond, 0);\n+\t  tree new_var_1 = make_rename_temp (TREE_TYPE (temp), NULL);\n+\t  new = build (MODIFY_EXPR, TREE_TYPE (new_var_1), new_var_1, temp);\n+\t  bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n+\t  cond = fold_convert (TREE_TYPE (result), new_var_1);\n+\t}\n       \n       if (TREE_CODE (cond) == TRUTH_NOT_EXPR\n-          &&  !is_gimple_val (TREE_OPERAND (cond, 0)))\n-        return false;\n+\t  &&  !is_gimple_val (TREE_OPERAND (cond, 0)))\n+\treturn false;\n \n       new = build (MODIFY_EXPR, TREE_TYPE (PHI_RESULT (phi)),\n-                    PHI_RESULT (phi), cond);\n+\t\t    PHI_RESULT (phi), cond);\n     }\n   \n   bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n   \n   /* Register our new statement as the defining statement for\n-      the result.  */\n+     the result.  */\n   SSA_NAME_DEF_STMT (PHI_RESULT (phi)) = new;\n   \n   /* Remove the now useless PHI node. \n   \n-      We do not want to use remove_phi_node since that releases the\n-      SSA_NAME as well and the SSA_NAME is still being used.  */\n+     We do not want to use remove_phi_node since that releases the\n+     SSA_NAME as well and the SSA_NAME is still being used.  */\n   release_phi_node (phi);\n   bb_ann (bb)->phi_nodes = NULL;\n   \n@@ -308,10 +305,10 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file,\n-              \"COND_EXPR in block %d and PHI in block %d converted to straightline code.\\n\",\n-              cond_block->index,\n-              bb->index);\n-            \n+\t      \"COND_EXPR in block %d and PHI in block %d converted to straightline code.\\n\",\n+\t      cond_block->index,\n+\t      bb->index);\n+\t    \n   /* Note that we optimized this PHI.  */\n   return true;\n }"}]}