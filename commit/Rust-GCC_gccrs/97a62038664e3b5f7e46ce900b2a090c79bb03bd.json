{"sha": "97a62038664e3b5f7e46ce900b2a090c79bb03bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTdhNjIwMzg2NjRlM2I1ZjdlNDZjZTkwMGIyYTA5MGM3OWJiMDNiZA==", "commit": {"author": {"name": "Thomas Koenig", "email": "Thomas.Koenig@online.de", "date": "2006-03-20T21:56:00Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2006-03-20T21:56:00Z"}, "message": "re PR fortran/20935 (failed assertion for maxloc(n, mask=.true.))\n\n2006-03-20  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR fortran/20935\n\t* iresolve.c (gfc_resolve_maxloc):   If mask is scalar,\n\tprefix the function name with an \"s\".  If the mask is scalar\n\tor if its kind is smaller than gfc_default_logical_kind,\n\tcoerce it to default kind.\n\t(gfc_resolve_maxval):  Likewise.\n\t(gfc_resolve_minloc):  Likewise.\n\t(gfc_resolve_minval):  Likewise.\n\t(gfc_resolve_product):  Likewise.\n\t(gfc_resolve_sum):  Likewise.\n\n2006-03-20  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR fortran/20935\n\t* m4/iforeach.m4:  Add SCALAR_FOREACH_FUNCTION macro.\n\t* m4/ifunction.m4:  Add SCALAR_ARRAY_FUNCTION macro.\n\t* m4/minloc0.m4:  Use SCALAR_FOREACH_FUNCTION.\n\t* m4/minloc1.m4:  Use SCALAR_ARRAY_FUNCTION.\n\t* m4/maxloc0.m4:  Use SCALAR_FOREACH_FUNCTION.\n\t* m4/maxloc1.m4:  Use SCALAR_ARRAY_FUNCTION.\n\t* m4/minval.m4:  Likewise.\n\t* m4/maxval.m4:  Likewise.\n\t* m4/product.m4:  Likewise.\n\t* m4/sum.m4:  Likewise.\n\t* minloc0_16_i16.c : Regenerated.\n\t* minloc0_16_i4.c : Regenerated.\n\t* minloc0_16_i8.c : Regenerated.\n\t* minloc0_16_r10.c : Regenerated.\n\t* minloc0_16_r16.c : Regenerated.\n\t* minloc0_16_r4.c : Regenerated.\n\t* minloc0_16_r8.c : Regenerated.\n\t* minloc0_4_i16.c : Regenerated.\n\t* minloc0_4_i4.c : Regenerated.\n\t* minloc0_4_i8.c : Regenerated.\n\t* minloc0_4_r10.c : Regenerated.\n\t* minloc0_4_r16.c : Regenerated.\n\t* minloc0_4_r4.c : Regenerated.\n\t* minloc0_4_r8.c : Regenerated.\n\t* minloc0_8_i16.c : Regenerated.\n\t* minloc0_8_i4.c : Regenerated.\n\t* minloc0_8_i8.c : Regenerated.\n\t* minloc0_8_r10.c : Regenerated.\n\t* minloc0_8_r16.c : Regenerated.\n\t* minloc0_8_r4.c : Regenerated.\n\t* minloc0_8_r8.c : Regenerated.\n\t* minloc1_16_i16.c : Regenerated.\n\t* minloc1_16_i4.c : Regenerated.\n\t* minloc1_16_i8.c : Regenerated.\n\t* minloc1_16_r10.c : Regenerated.\n\t* minloc1_16_r16.c : Regenerated.\n\t* minloc1_16_r4.c : Regenerated.\n\t* minloc1_16_r8.c : Regenerated.\n\t* minloc1_4_i16.c : Regenerated.\n\t* minloc1_4_i4.c : Regenerated.\n\t* minloc1_4_i8.c : Regenerated.\n\t* minloc1_4_r10.c : Regenerated.\n\t* minloc1_4_r16.c : Regenerated.\n\t* minloc1_4_r4.c : Regenerated.\n\t* minloc1_4_r8.c : Regenerated.\n\t* minloc1_8_i16.c : Regenerated.\n\t* minloc1_8_i4.c : Regenerated.\n\t* minloc1_8_i8.c : Regenerated.\n\t* minloc1_8_r10.c : Regenerated.\n\t* minloc1_8_r16.c : Regenerated.\n\t* minloc1_8_r4.c : Regenerated.\n\t* minloc1_8_r8.c : Regenerated.\n\t* maxloc0_16_i16.c : Regenerated.\n\t* maxloc0_16_i4.c : Regenerated.\n\t* maxloc0_16_i8.c : Regenerated.\n\t* maxloc0_16_r10.c : Regenerated.\n\t* maxloc0_16_r16.c : Regenerated.\n\t* maxloc0_16_r4.c : Regenerated.\n\t* maxloc0_16_r8.c : Regenerated.\n\t* maxloc0_4_i16.c : Regenerated.\n\t* maxloc0_4_i4.c : Regenerated.\n\t* maxloc0_4_i8.c : Regenerated.\n\t* maxloc0_4_r10.c : Regenerated.\n\t* maxloc0_4_r16.c : Regenerated.\n\t* maxloc0_4_r4.c : Regenerated.\n\t* maxloc0_4_r8.c : Regenerated.\n\t* maxloc0_8_i16.c : Regenerated.\n\t* maxloc0_8_i4.c : Regenerated.\n\t* maxloc0_8_i8.c : Regenerated.\n\t* maxloc0_8_r10.c : Regenerated.\n\t* maxloc0_8_r16.c : Regenerated.\n\t* maxloc0_8_r4.c : Regenerated.\n\t* maxloc0_8_r8.c : Regenerated.\n\t* maxloc1_16_i16.c : Regenerated.\n\t* maxloc1_16_i4.c : Regenerated.\n\t* maxloc1_16_i8.c : Regenerated.\n\t* maxloc1_16_r10.c : Regenerated.\n\t* maxloc1_16_r16.c : Regenerated.\n\t* maxloc1_16_r4.c : Regenerated.\n\t* maxloc1_16_r8.c : Regenerated.\n\t* maxloc1_4_i16.c : Regenerated.\n\t* maxloc1_4_i4.c : Regenerated.\n\t* maxloc1_4_i8.c : Regenerated.\n\t* maxloc1_4_r10.c : Regenerated.\n\t* maxloc1_4_r16.c : Regenerated.\n\t* maxloc1_4_r4.c : Regenerated.\n\t* maxloc1_4_r8.c : Regenerated.\n\t* maxloc1_8_i16.c : Regenerated.\n\t* maxloc1_8_i4.c : Regenerated.\n\t* maxloc1_8_i8.c : Regenerated.\n\t* maxloc1_8_r10.c : Regenerated.\n\t* maxloc1_8_r16.c : Regenerated.\n\t* maxloc1_8_r4.c : Regenerated.\n\t* maxloc1_8_r8.c : Regenerated.\n\t* maxval_i16.c : Regenerated.\n\t* maxval_i4.c : Regenerated.\n\t* maxval_i8.c : Regenerated.\n\t* maxval_r10.c : Regenerated.\n\t* maxval_r16.c : Regenerated.\n\t* maxval_r4.c : Regenerated.\n\t* maxval_r8.c : Regenerated.\n\t* minval_i16.c : Regenerated.\n\t* minval_i4.c : Regenerated.\n\t* minval_i8.c : Regenerated.\n\t* minval_r10.c : Regenerated.\n\t* minval_r16.c : Regenerated.\n\t* minval_r4.c : Regenerated.\n\t* minval_r8.c : Regenerated.\n\t* sum_c10.c : Regenerated.\n\t* sum_c16.c : Regenerated.\n\t* sum_c4.c : Regenerated.\n\t* sum_c8.c : Regenerated.\n\t* sum_i16.c : Regenerated.\n\t* sum_i4.c : Regenerated.\n\t* sum_i8.c : Regenerated.\n\t* sum_r10.c : Regenerated.\n\t* sum_r16.c : Regenerated.\n\t* sum_r4.c : Regenerated.\n\t* sum_r8.c : Regenerated.\n\t* product_c10.c : Regenerated.\n\t* product_c16.c : Regenerated.\n\t* product_c4.c : Regenerated.\n\t* product_c8.c : Regenerated.\n\t* product_i16.c : Regenerated.\n\t* product_i4.c : Regenerated.\n\t* product_i8.c : Regenerated.\n\t* product_r10.c : Regenerated.\n\t* product_r16.c : Regenerated.\n\t* product_r4.c : Regenerated.\n\t* product_r8.c : Regenerated.\n\n2006-03-20  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR fortran/20935\n\t* gfortran.dg/scalar_mask_2.f90:  New test case.\n\nFrom-SVN: r112230", "tree": {"sha": "4e56d8107e30829f6e3b4fe1e1e92a5c631aabd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e56d8107e30829f6e3b4fe1e1e92a5c631aabd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97a62038664e3b5f7e46ce900b2a090c79bb03bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97a62038664e3b5f7e46ce900b2a090c79bb03bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97a62038664e3b5f7e46ce900b2a090c79bb03bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97a62038664e3b5f7e46ce900b2a090c79bb03bd/comments", "author": null, "committer": null, "parents": [{"sha": "ede497cfbd518c7fafda85bc7b5e26899e5b0f14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ede497cfbd518c7fafda85bc7b5e26899e5b0f14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ede497cfbd518c7fafda85bc7b5e26899e5b0f14"}], "stats": {"total": 6845, "additions": 6839, "deletions": 6}, "files": [{"sha": "7256b6eb2678206eeed2a68e88d9f55df9524c7c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -1,3 +1,16 @@\n+2006-03-20  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR fortran/20935\n+\t* iresolve.c (gfc_resolve_maxloc):   If mask is scalar,\n+\tprefix the function name with an \"s\".  If the mask is scalar\n+\tor if its kind is smaller than gfc_default_logical_kind,\n+\tcoerce it to default kind.\n+\t(gfc_resolve_maxval):  Likewise.\n+\t(gfc_resolve_minloc):  Likewise.\n+\t(gfc_resolve_minval):  Likewise.\n+\t(gfc_resolve_product):  Likewise.\n+\t(gfc_resolve_sum):  Likewise.\n+\n 2006-03-19  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/26741"}, {"sha": "df562f7860410a8d255b30b74ead8b0006775f58", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 138, "deletions": 6, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -1093,7 +1093,27 @@ gfc_resolve_maxloc (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n       gfc_resolve_dim_arg (dim);\n     }\n \n-  name = mask ? \"mmaxloc\" : \"maxloc\";\n+  if (mask)\n+    {\n+      if (mask->rank == 0)\n+\tname = \"smaxloc\";\n+      else\n+\tname = \"mmaxloc\";\n+\n+      /* The mask can be kind 4 or 8 for the array case.  For the\n+\t scalar case, coerce it to default kind unconditionally.  */\n+      if ((mask->ts.kind < gfc_default_logical_kind)\n+\t  || (mask->rank == 0 && mask->ts.kind != gfc_default_logical_kind))\n+\t{\n+\t  gfc_typespec ts;\n+\t  ts.type = BT_LOGICAL;\n+\t  ts.kind = gfc_default_logical_kind;\n+\t  gfc_convert_type_warn (mask, &ts, 2, 0);\n+\t}\n+    }\n+  else\n+    name = \"maxloc\";\n+\n   f->value.function.name =\n     gfc_get_string (PREFIX(\"%s%d_%d_%c%d\"), name, dim != NULL, f->ts.kind,\n                     gfc_type_letter (array->ts.type), array->ts.kind);\n@@ -1104,6 +1124,8 @@ void\n gfc_resolve_maxval (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n \t\t    gfc_expr * mask)\n {\n+  const char *name;\n+\n   f->ts = array->ts;\n \n   if (dim != NULL)\n@@ -1112,8 +1134,29 @@ gfc_resolve_maxval (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n       gfc_resolve_dim_arg (dim);\n     }\n \n+  if (mask)\n+    {\n+      if (mask->rank == 0)\n+\tname = \"smaxval\";\n+      else\n+\tname = \"mmaxval\";\n+\n+      /* The mask can be kind 4 or 8 for the array case.  For the\n+\t scalar case, coerce it to default kind unconditionally.  */\n+      if ((mask->ts.kind < gfc_default_logical_kind)\n+\t  || (mask->rank == 0 && mask->ts.kind != gfc_default_logical_kind))\n+\t{\n+\t  gfc_typespec ts;\n+\t  ts.type = BT_LOGICAL;\n+\t  ts.kind = gfc_default_logical_kind;\n+\t  gfc_convert_type_warn (mask, &ts, 2, 0);\n+\t}\n+    }\n+  else\n+    name = \"maxval\";\n+\n   f->value.function.name =\n-    gfc_get_string (PREFIX(\"%s_%c%d\"), mask ? \"mmaxval\" : \"maxval\",\n+    gfc_get_string (PREFIX(\"%s_%c%d\"), name,\n \t\t    gfc_type_letter (array->ts.type), array->ts.kind);\n }\n \n@@ -1157,7 +1200,27 @@ gfc_resolve_minloc (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n       gfc_resolve_dim_arg (dim);\n     }\n \n-  name = mask ? \"mminloc\" : \"minloc\";\n+  if (mask)\n+    {\n+      if (mask->rank == 0)\n+\tname = \"sminloc\";\n+      else\n+\tname = \"mminloc\";\n+\n+      /* The mask can be kind 4 or 8 for the array case.  For the\n+\t scalar case, coerce it to default kind unconditionally.  */\n+      if ((mask->ts.kind < gfc_default_logical_kind)\n+\t  || (mask->rank == 0 && mask->ts.kind != gfc_default_logical_kind))\n+\t{\n+\t  gfc_typespec ts;\n+\t  ts.type = BT_LOGICAL;\n+\t  ts.kind = gfc_default_logical_kind;\n+\t  gfc_convert_type_warn (mask, &ts, 2, 0);\n+\t}\n+    }\n+  else\n+    name = \"minloc\";\n+\n   f->value.function.name =\n     gfc_get_string (PREFIX(\"%s%d_%d_%c%d\"), name, dim != NULL, f->ts.kind,\n                     gfc_type_letter (array->ts.type), array->ts.kind);\n@@ -1168,6 +1231,8 @@ void\n gfc_resolve_minval (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n \t\t    gfc_expr * mask)\n {\n+  const char *name;\n+\n   f->ts = array->ts;\n \n   if (dim != NULL)\n@@ -1176,8 +1241,29 @@ gfc_resolve_minval (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n       gfc_resolve_dim_arg (dim);\n     }\n \n+  if (mask)\n+    {\n+      if (mask->rank == 0)\n+\tname = \"sminval\";\n+      else\n+\tname = \"mminval\";\n+\n+      /* The mask can be kind 4 or 8 for the array case.  For the\n+\t scalar case, coerce it to default kind unconditionally.  */\n+      if ((mask->ts.kind < gfc_default_logical_kind)\n+\t  || (mask->rank == 0 && mask->ts.kind != gfc_default_logical_kind))\n+\t{\n+\t  gfc_typespec ts;\n+\t  ts.type = BT_LOGICAL;\n+\t  ts.kind = gfc_default_logical_kind;\n+\t  gfc_convert_type_warn (mask, &ts, 2, 0);\n+\t}\n+    }\n+  else\n+    name = \"minval\";\n+\n   f->value.function.name =\n-    gfc_get_string (PREFIX(\"%s_%c%d\"), mask ? \"mminval\" : \"minval\",\n+    gfc_get_string (PREFIX(\"%s_%c%d\"), name,\n \t\t    gfc_type_letter (array->ts.type), array->ts.kind);\n }\n \n@@ -1311,6 +1397,8 @@ void\n gfc_resolve_product (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n \t\t     gfc_expr * mask)\n {\n+  const char *name;\n+\n   f->ts = array->ts;\n \n   if (dim != NULL)\n@@ -1319,8 +1407,29 @@ gfc_resolve_product (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n       gfc_resolve_dim_arg (dim);\n     }\n \n+  if (mask)\n+    {\n+      if (mask->rank == 0)\n+\tname = \"sproduct\";\n+      else\n+\tname = \"mproduct\";\n+\n+      /* The mask can be kind 4 or 8 for the array case.  For the\n+\t scalar case, coerce it to default kind unconditionally.  */\n+      if ((mask->ts.kind < gfc_default_logical_kind)\n+\t  || (mask->rank == 0 && mask->ts.kind != gfc_default_logical_kind))\n+\t{\n+\t  gfc_typespec ts;\n+\t  ts.type = BT_LOGICAL;\n+\t  ts.kind = gfc_default_logical_kind;\n+\t  gfc_convert_type_warn (mask, &ts, 2, 0);\n+\t}\n+    }\n+  else\n+    name = \"product\";\n+\n   f->value.function.name =\n-    gfc_get_string (PREFIX(\"%s_%c%d\"), mask ? \"mproduct\" : \"product\",\n+    gfc_get_string (PREFIX(\"%s_%c%d\"), name,\n \t\t    gfc_type_letter (array->ts.type), array->ts.kind);\n }\n \n@@ -1733,16 +1842,39 @@ void\n gfc_resolve_sum (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n \t\t gfc_expr * mask)\n {\n+  const char *name;\n+\n   f->ts = array->ts;\n \n+  if (mask)\n+    {\n+      if (mask->rank == 0)\n+\tname = \"ssum\";\n+      else\n+\tname = \"msum\";\n+\n+      /* The mask can be kind 4 or 8 for the array case.  For the\n+\t scalar case, coerce it to default kind unconditionally.  */\n+      if ((mask->ts.kind < gfc_default_logical_kind)\n+\t  || (mask->rank == 0 && mask->ts.kind != gfc_default_logical_kind))\n+\t{\n+\t  gfc_typespec ts;\n+\t  ts.type = BT_LOGICAL;\n+\t  ts.kind = gfc_default_logical_kind;\n+\t  gfc_convert_type_warn (mask, &ts, 2, 0);\n+\t}\n+    }\n+  else\n+    name = \"sum\";\n+\n   if (dim != NULL)\n     {\n       f->rank = array->rank - 1;\n       gfc_resolve_dim_arg (dim);\n     }\n \n   f->value.function.name =\n-    gfc_get_string (PREFIX(\"%s_%c%d\"), mask ? \"msum\" : \"sum\",\n+    gfc_get_string (PREFIX(\"%s_%c%d\"), name,\n \t\t    gfc_type_letter (array->ts.type), array->ts.kind);\n }\n "}, {"sha": "b7d52acf0d86fb724d264a95bdec4527eac84536", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -1,3 +1,8 @@\n+2006-03-20  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR fortran/20935\n+\t* gfortran.dg/scalar_mask_2.f90:  New test case.\n+\n 2006-03-20  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR tree-opt/26629"}, {"sha": "adc7bbd60d4ca7e23ececfae2b289a3fc0a7dd8c", "filename": "gcc/testsuite/gfortran.dg/scalar_mask_2.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/gcc%2Ftestsuite%2Fgfortran.dg%2Fscalar_mask_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/gcc%2Ftestsuite%2Fgfortran.dg%2Fscalar_mask_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fscalar_mask_2.f90?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do run }\n+program main\n+  ! Test scalar masks for different intrinsics.\n+  real, dimension(2,2) :: a\n+  logical(kind=2) :: lo\n+  lo = .false.\n+  a(1,1) = 1.\n+  a(1,2) = -1.\n+  a(2,1) = 13.\n+  a(2,2) = -31.\n+  if (any (minloc (a, lo) /= 0)) call abort\n+  if (any (minloc (a, .true.) /= (/ 2, 2 /))) call abort\n+  if (any (minloc(a, 1, .true.) /= (/ 1, 2/))) call abort\n+  if (any (minloc(a, 1, lo ) /= (/ 0, 0/))) call abort\n+\n+  if (any (maxloc (a, lo) /= 0)) call abort\n+  if (any (maxloc (a, .true.) /= (/ 2,1 /))) call abort\n+  if (any (maxloc(a, 1, .true.) /= (/ 2, 1/))) call abort\n+  if (any (maxloc(a, 1, lo) /= (/ 0, 0/))) call abort\n+\n+  if (any (maxval(a, 1, lo) /= -HUGE(a))) call abort\n+  if (any (maxval(a, 1, .true.) /= (/13., -1./))) call abort\n+  if (any (minval(a, 1, lo) /= HUGE(a))) call abort\n+  if (any (minval(a, 1, .true.) /= (/1., -31./))) call abort\n+\n+  if (any (product(a, 1, .true.) /= (/13., 31./))) call abort\n+  if (any (product(a, 1, lo ) /= (/1., 1./))) call abort\n+\n+  if (any (sum(a, 1, .true.) /= (/14., -32./))) call abort\n+  if (any (sum(a, 1, lo) /= (/0., 0./))) call abort\n+\n+end program main"}, {"sha": "9a0a8086f4123d078593924ba27870589357f698", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -1,3 +1,137 @@\n+2006-03-20  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR fortran/20935\n+\t* m4/iforeach.m4:  Add SCALAR_FOREACH_FUNCTION macro.\n+\t* m4/ifunction.m4:  Add SCALAR_ARRAY_FUNCTION macro.\n+\t* m4/minloc0.m4:  Use SCALAR_FOREACH_FUNCTION.\n+\t* m4/minloc1.m4:  Use SCALAR_ARRAY_FUNCTION.\n+\t* m4/maxloc0.m4:  Use SCALAR_FOREACH_FUNCTION.\n+\t* m4/maxloc1.m4:  Use SCALAR_ARRAY_FUNCTION.\n+\t* m4/minval.m4:  Likewise.\n+\t* m4/maxval.m4:  Likewise.\n+\t* m4/product.m4:  Likewise.\n+\t* m4/sum.m4:  Likewise.\n+\t* minloc0_16_i16.c : Regenerated.\n+\t* minloc0_16_i4.c : Regenerated.\n+\t* minloc0_16_i8.c : Regenerated.\n+\t* minloc0_16_r10.c : Regenerated.\n+\t* minloc0_16_r16.c : Regenerated.\n+\t* minloc0_16_r4.c : Regenerated.\n+\t* minloc0_16_r8.c : Regenerated.\n+\t* minloc0_4_i16.c : Regenerated.\n+\t* minloc0_4_i4.c : Regenerated.\n+\t* minloc0_4_i8.c : Regenerated.\n+\t* minloc0_4_r10.c : Regenerated.\n+\t* minloc0_4_r16.c : Regenerated.\n+\t* minloc0_4_r4.c : Regenerated.\n+\t* minloc0_4_r8.c : Regenerated.\n+\t* minloc0_8_i16.c : Regenerated.\n+\t* minloc0_8_i4.c : Regenerated.\n+\t* minloc0_8_i8.c : Regenerated.\n+\t* minloc0_8_r10.c : Regenerated.\n+\t* minloc0_8_r16.c : Regenerated.\n+\t* minloc0_8_r4.c : Regenerated.\n+\t* minloc0_8_r8.c : Regenerated.\n+\t* minloc1_16_i16.c : Regenerated.\n+\t* minloc1_16_i4.c : Regenerated.\n+\t* minloc1_16_i8.c : Regenerated.\n+\t* minloc1_16_r10.c : Regenerated.\n+\t* minloc1_16_r16.c : Regenerated.\n+\t* minloc1_16_r4.c : Regenerated.\n+\t* minloc1_16_r8.c : Regenerated.\n+\t* minloc1_4_i16.c : Regenerated.\n+\t* minloc1_4_i4.c : Regenerated.\n+\t* minloc1_4_i8.c : Regenerated.\n+\t* minloc1_4_r10.c : Regenerated.\n+\t* minloc1_4_r16.c : Regenerated.\n+\t* minloc1_4_r4.c : Regenerated.\n+\t* minloc1_4_r8.c : Regenerated.\n+\t* minloc1_8_i16.c : Regenerated.\n+\t* minloc1_8_i4.c : Regenerated.\n+\t* minloc1_8_i8.c : Regenerated.\n+\t* minloc1_8_r10.c : Regenerated.\n+\t* minloc1_8_r16.c : Regenerated.\n+\t* minloc1_8_r4.c : Regenerated.\n+\t* minloc1_8_r8.c : Regenerated.\n+\t* maxloc0_16_i16.c : Regenerated.\n+\t* maxloc0_16_i4.c : Regenerated.\n+\t* maxloc0_16_i8.c : Regenerated.\n+\t* maxloc0_16_r10.c : Regenerated.\n+\t* maxloc0_16_r16.c : Regenerated.\n+\t* maxloc0_16_r4.c : Regenerated.\n+\t* maxloc0_16_r8.c : Regenerated.\n+\t* maxloc0_4_i16.c : Regenerated.\n+\t* maxloc0_4_i4.c : Regenerated.\n+\t* maxloc0_4_i8.c : Regenerated.\n+\t* maxloc0_4_r10.c : Regenerated.\n+\t* maxloc0_4_r16.c : Regenerated.\n+\t* maxloc0_4_r4.c : Regenerated.\n+\t* maxloc0_4_r8.c : Regenerated.\n+\t* maxloc0_8_i16.c : Regenerated.\n+\t* maxloc0_8_i4.c : Regenerated.\n+\t* maxloc0_8_i8.c : Regenerated.\n+\t* maxloc0_8_r10.c : Regenerated.\n+\t* maxloc0_8_r16.c : Regenerated.\n+\t* maxloc0_8_r4.c : Regenerated.\n+\t* maxloc0_8_r8.c : Regenerated.\n+\t* maxloc1_16_i16.c : Regenerated.\n+\t* maxloc1_16_i4.c : Regenerated.\n+\t* maxloc1_16_i8.c : Regenerated.\n+\t* maxloc1_16_r10.c : Regenerated.\n+\t* maxloc1_16_r16.c : Regenerated.\n+\t* maxloc1_16_r4.c : Regenerated.\n+\t* maxloc1_16_r8.c : Regenerated.\n+\t* maxloc1_4_i16.c : Regenerated.\n+\t* maxloc1_4_i4.c : Regenerated.\n+\t* maxloc1_4_i8.c : Regenerated.\n+\t* maxloc1_4_r10.c : Regenerated.\n+\t* maxloc1_4_r16.c : Regenerated.\n+\t* maxloc1_4_r4.c : Regenerated.\n+\t* maxloc1_4_r8.c : Regenerated.\n+\t* maxloc1_8_i16.c : Regenerated.\n+\t* maxloc1_8_i4.c : Regenerated.\n+\t* maxloc1_8_i8.c : Regenerated.\n+\t* maxloc1_8_r10.c : Regenerated.\n+\t* maxloc1_8_r16.c : Regenerated.\n+\t* maxloc1_8_r4.c : Regenerated.\n+\t* maxloc1_8_r8.c : Regenerated.\n+\t* maxval_i16.c : Regenerated.\n+\t* maxval_i4.c : Regenerated.\n+\t* maxval_i8.c : Regenerated.\n+\t* maxval_r10.c : Regenerated.\n+\t* maxval_r16.c : Regenerated.\n+\t* maxval_r4.c : Regenerated.\n+\t* maxval_r8.c : Regenerated.\n+\t* minval_i16.c : Regenerated.\n+\t* minval_i4.c : Regenerated.\n+\t* minval_i8.c : Regenerated.\n+\t* minval_r10.c : Regenerated.\n+\t* minval_r16.c : Regenerated.\n+\t* minval_r4.c : Regenerated.\n+\t* minval_r8.c : Regenerated.\n+\t* sum_c10.c : Regenerated.\n+\t* sum_c16.c : Regenerated.\n+\t* sum_c4.c : Regenerated.\n+\t* sum_c8.c : Regenerated.\n+\t* sum_i16.c : Regenerated.\n+\t* sum_i4.c : Regenerated.\n+\t* sum_i8.c : Regenerated.\n+\t* sum_r10.c : Regenerated.\n+\t* sum_r16.c : Regenerated.\n+\t* sum_r4.c : Regenerated.\n+\t* sum_r8.c : Regenerated.\n+\t* product_c10.c : Regenerated.\n+\t* product_c16.c : Regenerated.\n+\t* product_c4.c : Regenerated.\n+\t* product_c8.c : Regenerated.\n+\t* product_i16.c : Regenerated.\n+\t* product_i4.c : Regenerated.\n+\t* product_i8.c : Regenerated.\n+\t* product_r10.c : Regenerated.\n+\t* product_r16.c : Regenerated.\n+\t* product_r4.c : Regenerated.\n+\t* product_r8.c : Regenerated.\n+\n 2006-03-17  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/26509"}, {"sha": "ab341d8bea9e988563bb2bde5e0d3967ea768dfa", "filename": "libgfortran/generated/maxloc0_16_i16.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_16_i16 (gfc_array_i16 * const restrict, \n+\tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_16_i16);\n+\n+void\n+smaxloc0_16_i16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_16_i16 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "51bee3154f6630b438b5e2bf4961c87ac19e0d63", "filename": "libgfortran/generated/maxloc0_16_i4.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_16_i4 (gfc_array_i16 * const restrict, \n+\tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_16_i4);\n+\n+void\n+smaxloc0_16_i4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_16_i4 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "dd8fb46a83ac07f663fa42606d8c31d9e164a52e", "filename": "libgfortran/generated/maxloc0_16_i8.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_16_i8 (gfc_array_i16 * const restrict, \n+\tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_16_i8);\n+\n+void\n+smaxloc0_16_i8 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_16_i8 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "793885da8d71711fc1fa60f2c83284c2db773bd0", "filename": "libgfortran/generated/maxloc0_16_r10.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_16_r10 (gfc_array_i16 * const restrict, \n+\tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_16_r10);\n+\n+void\n+smaxloc0_16_r10 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r10 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_16_r10 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "e3d0c7ff9c150c787dc3d72e3f52124d2b086fc8", "filename": "libgfortran/generated/maxloc0_16_r16.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_16_r16 (gfc_array_i16 * const restrict, \n+\tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_16_r16);\n+\n+void\n+smaxloc0_16_r16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r16 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_16_r16 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "eedeaffda5247c0ee84c481847f66cf186352010", "filename": "libgfortran/generated/maxloc0_16_r4.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_16_r4 (gfc_array_i16 * const restrict, \n+\tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_16_r4);\n+\n+void\n+smaxloc0_16_r4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r4 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_16_r4 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "0e93c2a4d8e13c9246fadfa478a57203e447b591", "filename": "libgfortran/generated/maxloc0_16_r8.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_16_r8 (gfc_array_i16 * const restrict, \n+\tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_16_r8);\n+\n+void\n+smaxloc0_16_r8 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r8 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_16_r8 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "01d787019640f5440017131b55623e64a7323a61", "filename": "libgfortran/generated/maxloc0_4_i16.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_4_i16 (gfc_array_i4 * const restrict, \n+\tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_4_i16);\n+\n+void\n+smaxloc0_4_i16 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_4_i16 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "7b1260c7e9694a4be275bf0a4dbbd6f6fdb7c6b0", "filename": "libgfortran/generated/maxloc0_4_i4.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_4_i4 (gfc_array_i4 * const restrict, \n+\tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_4_i4);\n+\n+void\n+smaxloc0_4_i4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_4_i4 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "18b81c6a6527d99514fdef7db4c5ee0ac45eb8d6", "filename": "libgfortran/generated/maxloc0_4_i8.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_4_i8 (gfc_array_i4 * const restrict, \n+\tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_4_i8);\n+\n+void\n+smaxloc0_4_i8 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_4_i8 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "59e521c2421134a6d2912b1e03ebd346e7fc9832", "filename": "libgfortran/generated/maxloc0_4_r10.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_4_r10 (gfc_array_i4 * const restrict, \n+\tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_4_r10);\n+\n+void\n+smaxloc0_4_r10 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r10 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_4_r10 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "18bf738889f11506be57f2e0ba15fcc829c6aae2", "filename": "libgfortran/generated/maxloc0_4_r16.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_4_r16 (gfc_array_i4 * const restrict, \n+\tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_4_r16);\n+\n+void\n+smaxloc0_4_r16 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r16 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_4_r16 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "daa379c72d3b06a6f337ec7babf00f356948470b", "filename": "libgfortran/generated/maxloc0_4_r4.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_4_r4 (gfc_array_i4 * const restrict, \n+\tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_4_r4);\n+\n+void\n+smaxloc0_4_r4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r4 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_4_r4 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "063fed03fac974f20d4715d903063e52bb29f6b5", "filename": "libgfortran/generated/maxloc0_4_r8.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_4_r8 (gfc_array_i4 * const restrict, \n+\tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_4_r8);\n+\n+void\n+smaxloc0_4_r8 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r8 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_4_r8 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "1e1dbf250492331da4745d02e0bf816cba927543", "filename": "libgfortran/generated/maxloc0_8_i16.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_8_i16 (gfc_array_i8 * const restrict, \n+\tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_8_i16);\n+\n+void\n+smaxloc0_8_i16 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_8_i16 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "2a08cd82de43989df83e839a4a6f56cb9ce54ac9", "filename": "libgfortran/generated/maxloc0_8_i4.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_8_i4 (gfc_array_i8 * const restrict, \n+\tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_8_i4);\n+\n+void\n+smaxloc0_8_i4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_8_i4 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "b17a445e96fd71904c1070ea8305c0d089e896d8", "filename": "libgfortran/generated/maxloc0_8_i8.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_8_i8 (gfc_array_i8 * const restrict, \n+\tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_8_i8);\n+\n+void\n+smaxloc0_8_i8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_8_i8 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "63c1467c54a91e91c1672aeac19be5b2044d1187", "filename": "libgfortran/generated/maxloc0_8_r10.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_8_r10 (gfc_array_i8 * const restrict, \n+\tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_8_r10);\n+\n+void\n+smaxloc0_8_r10 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r10 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_8_r10 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "c1fe42a71b8efa362e5968e8875e39ba35f1fbb4", "filename": "libgfortran/generated/maxloc0_8_r16.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_8_r16 (gfc_array_i8 * const restrict, \n+\tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_8_r16);\n+\n+void\n+smaxloc0_8_r16 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r16 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_8_r16 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "58de2ca0e46bed6e8f477ca67b827d2386f2be1c", "filename": "libgfortran/generated/maxloc0_8_r4.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_8_r4 (gfc_array_i8 * const restrict, \n+\tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_8_r4);\n+\n+void\n+smaxloc0_8_r4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r4 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_8_r4 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "e286a8198974e094682dab41c1aca8560fe260c7", "filename": "libgfortran/generated/maxloc0_8_r8.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n+\n+extern void smaxloc0_8_r8 (gfc_array_i8 * const restrict, \n+\tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(smaxloc0_8_r8);\n+\n+void\n+smaxloc0_8_r8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r8 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc0_8_r8 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "9f6408b111c6a016be8915f706c2bdd1f55a1ee8", "filename": "libgfortran/generated/maxloc1_16_i16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_16_i16 (gfc_array_i16 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_16_i16);\n+\n+void\n+smaxloc1_16_i16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_16_i16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "7810033dfd29d808823d99bf421743f2d2ac258d", "filename": "libgfortran/generated/maxloc1_16_i4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_16_i4 (gfc_array_i16 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_16_i4);\n+\n+void\n+smaxloc1_16_i4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_16_i4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "6c6a790a93ca6dee0b711629e98ce124aafd5b75", "filename": "libgfortran/generated/maxloc1_16_i8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_16_i8 (gfc_array_i16 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_16_i8);\n+\n+void\n+smaxloc1_16_i8 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_16_i8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "d122223ff37348cdab05fbcedd10288c5cd681ab", "filename": "libgfortran/generated/maxloc1_16_r10.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_16_r10 (gfc_array_i16 * const restrict, \n+\tgfc_array_r10 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_16_r10);\n+\n+void\n+smaxloc1_16_r10 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r10 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_16_r10 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "18d1225604936c6588fa7cfe6ae28ae3956b7b71", "filename": "libgfortran/generated/maxloc1_16_r16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_16_r16 (gfc_array_i16 * const restrict, \n+\tgfc_array_r16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_16_r16);\n+\n+void\n+smaxloc1_16_r16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_16_r16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "f5fbcac366fef5412449602bf1d08bc1fb76098a", "filename": "libgfortran/generated/maxloc1_16_r4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_16_r4 (gfc_array_i16 * const restrict, \n+\tgfc_array_r4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_16_r4);\n+\n+void\n+smaxloc1_16_r4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_16_r4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "40922e389e088a476396c5bbf2432f06d775eb07", "filename": "libgfortran/generated/maxloc1_16_r8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_16_r8 (gfc_array_i16 * const restrict, \n+\tgfc_array_r8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_16_r8);\n+\n+void\n+smaxloc1_16_r8 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_16_r8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "1dfb06d9cde2a9492c5780bc89dc8a3d0f3bd90f", "filename": "libgfortran/generated/maxloc1_4_i16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_4_i16 (gfc_array_i4 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_4_i16);\n+\n+void\n+smaxloc1_4_i16 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_4_i16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "ae016accbc23d31b4e1f37226210753acffc2195", "filename": "libgfortran/generated/maxloc1_4_i4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_4_i4 (gfc_array_i4 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_4_i4);\n+\n+void\n+smaxloc1_4_i4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_4_i4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "d55059bbe2a105457dc149cc2ee098f2ee1b89f3", "filename": "libgfortran/generated/maxloc1_4_i8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_4_i8 (gfc_array_i4 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_4_i8);\n+\n+void\n+smaxloc1_4_i8 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_4_i8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "70a0b7b2b78bd81c26512267b4eb7060515e4166", "filename": "libgfortran/generated/maxloc1_4_r10.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_4_r10 (gfc_array_i4 * const restrict, \n+\tgfc_array_r10 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_4_r10);\n+\n+void\n+smaxloc1_4_r10 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r10 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_4_r10 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "e3abb9c02ba69d21feee1b5ea0d8b76a2a007a2e", "filename": "libgfortran/generated/maxloc1_4_r16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_4_r16 (gfc_array_i4 * const restrict, \n+\tgfc_array_r16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_4_r16);\n+\n+void\n+smaxloc1_4_r16 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_4_r16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "bcecc57d02e9ca741db7ca169c4a2ba0bbc771dd", "filename": "libgfortran/generated/maxloc1_4_r4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_4_r4 (gfc_array_i4 * const restrict, \n+\tgfc_array_r4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_4_r4);\n+\n+void\n+smaxloc1_4_r4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_4_r4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "5bcf032557d3ba387da46d3ac7eac63e837a5b68", "filename": "libgfortran/generated/maxloc1_4_r8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_4_r8 (gfc_array_i4 * const restrict, \n+\tgfc_array_r8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_4_r8);\n+\n+void\n+smaxloc1_4_r8 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_4_r8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "8d5491a4b6d85d7ec1a3e0b15eb4283cac70e642", "filename": "libgfortran/generated/maxloc1_8_i16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_8_i16 (gfc_array_i8 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_8_i16);\n+\n+void\n+smaxloc1_8_i16 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_8_i16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "5c187e25daa8d3c7efa1fb5dc47894547f44c0da", "filename": "libgfortran/generated/maxloc1_8_i4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_8_i4 (gfc_array_i8 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_8_i4);\n+\n+void\n+smaxloc1_8_i4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_8_i4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "ea1231789405b7914361c0ffe7b3856df2c8b6b4", "filename": "libgfortran/generated/maxloc1_8_i8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_8_i8 (gfc_array_i8 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_8_i8);\n+\n+void\n+smaxloc1_8_i8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_8_i8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "40972e64840dc0e8e46dee7751a6eb4b3b84ca60", "filename": "libgfortran/generated/maxloc1_8_r10.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_8_r10 (gfc_array_i8 * const restrict, \n+\tgfc_array_r10 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_8_r10);\n+\n+void\n+smaxloc1_8_r10 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r10 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_8_r10 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "11f3e05aa756f8c0a9cdc25fec7554831462de49", "filename": "libgfortran/generated/maxloc1_8_r16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_8_r16 (gfc_array_i8 * const restrict, \n+\tgfc_array_r16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_8_r16);\n+\n+void\n+smaxloc1_8_r16 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_8_r16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "10bd416338e04e94b91a0109e8bad300d3ee012c", "filename": "libgfortran/generated/maxloc1_8_r4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_8_r4 (gfc_array_i8 * const restrict, \n+\tgfc_array_r4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_8_r4);\n+\n+void\n+smaxloc1_8_r4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_8_r4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "534e6cd80d6fb5983009f6f8a66044b855aa2f4b", "filename": "libgfortran/generated/maxloc1_8_r8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxloc1_8_r8 (gfc_array_i8 * const restrict, \n+\tgfc_array_r8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxloc1_8_r8);\n+\n+void\n+smaxloc1_8_r8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxloc1_8_r8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "2b505803daf593f6f77fa237cb08c666028aad0f", "filename": "libgfortran/generated/maxval_i16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -339,4 +339,58 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxval_i16 (gfc_array_i16 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxval_i16);\n+\n+void\n+smaxval_i16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxval_i16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = -GFC_INTEGER_16_HUGE ;\n+}\n+\n #endif"}, {"sha": "65136953239fe01239309ae924efd30a74c96d36", "filename": "libgfortran/generated/maxval_i4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -339,4 +339,58 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxval_i4 (gfc_array_i4 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxval_i4);\n+\n+void\n+smaxval_i4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxval_i4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = -GFC_INTEGER_4_HUGE ;\n+}\n+\n #endif"}, {"sha": "fe78be161a6eedf386e3ea19d52fb5fbc68b3d72", "filename": "libgfortran/generated/maxval_i8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -339,4 +339,58 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxval_i8 (gfc_array_i8 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxval_i8);\n+\n+void\n+smaxval_i8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxval_i8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = -GFC_INTEGER_8_HUGE ;\n+}\n+\n #endif"}, {"sha": "5f9c5db89fe30319c382710c2dc203fccc24e834", "filename": "libgfortran/generated/maxval_r10.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r10.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -339,4 +339,58 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxval_r10 (gfc_array_r10 * const restrict, \n+\tgfc_array_r10 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxval_r10);\n+\n+void\n+smaxval_r10 (gfc_array_r10 * const restrict retarray, \n+\tgfc_array_r10 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_REAL_10 *dest;\n+\n+  if (*mask)\n+    {\n+      maxval_r10 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_REAL_10) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = -GFC_REAL_10_HUGE ;\n+}\n+\n #endif"}, {"sha": "a52669164cce7eefaa1bbcad50fdc4cf65ec1c8b", "filename": "libgfortran/generated/maxval_r16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -339,4 +339,58 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxval_r16 (gfc_array_r16 * const restrict, \n+\tgfc_array_r16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxval_r16);\n+\n+void\n+smaxval_r16 (gfc_array_r16 * const restrict retarray, \n+\tgfc_array_r16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_REAL_16 *dest;\n+\n+  if (*mask)\n+    {\n+      maxval_r16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_REAL_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = -GFC_REAL_16_HUGE ;\n+}\n+\n #endif"}, {"sha": "23cee97d5e028f74b82ddf6e6edbaedd205e7505", "filename": "libgfortran/generated/maxval_r4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -339,4 +339,58 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxval_r4 (gfc_array_r4 * const restrict, \n+\tgfc_array_r4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxval_r4);\n+\n+void\n+smaxval_r4 (gfc_array_r4 * const restrict retarray, \n+\tgfc_array_r4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_REAL_4 *dest;\n+\n+  if (*mask)\n+    {\n+      maxval_r4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_REAL_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = -GFC_REAL_4_HUGE ;\n+}\n+\n #endif"}, {"sha": "2fd37e5fa9ba9aa169a21644081989fe59ddb547", "filename": "libgfortran/generated/maxval_r8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fmaxval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -339,4 +339,58 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n     }\n }\n \n+\n+extern void smaxval_r8 (gfc_array_r8 * const restrict, \n+\tgfc_array_r8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxval_r8);\n+\n+void\n+smaxval_r8 (gfc_array_r8 * const restrict retarray, \n+\tgfc_array_r8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_REAL_8 *dest;\n+\n+  if (*mask)\n+    {\n+      maxval_r8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_REAL_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = -GFC_REAL_8_HUGE ;\n+}\n+\n #endif"}, {"sha": "d41276d92306dca469b819bb86c7fefb9fd4e1d3", "filename": "libgfortran/generated/minloc0_16_i16.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_16_i16 (gfc_array_i16 * const restrict, \n+\tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_16_i16);\n+\n+void\n+sminloc0_16_i16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_16_i16 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "16e08638005e424e17f449957b371622f2b16dc9", "filename": "libgfortran/generated/minloc0_16_i4.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_16_i4 (gfc_array_i16 * const restrict, \n+\tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_16_i4);\n+\n+void\n+sminloc0_16_i4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_16_i4 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "bd2f08a56d1e7a4a2c8272a5f5c3d600851288ef", "filename": "libgfortran/generated/minloc0_16_i8.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_16_i8 (gfc_array_i16 * const restrict, \n+\tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_16_i8);\n+\n+void\n+sminloc0_16_i8 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_16_i8 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "ab88d299975ef9f63ecf534133fd09d17c9ceee3", "filename": "libgfortran/generated/minloc0_16_r10.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r10.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_16_r10 (gfc_array_i16 * const restrict, \n+\tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_16_r10);\n+\n+void\n+sminloc0_16_r10 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r10 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_16_r10 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "c71a24081aa8093a7764e38e80502fc11699ccf7", "filename": "libgfortran/generated/minloc0_16_r16.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_16_r16 (gfc_array_i16 * const restrict, \n+\tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_16_r16);\n+\n+void\n+sminloc0_16_r16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r16 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_16_r16 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "4cfa38934e9f1fd8808eb15adf5a11f7a6164789", "filename": "libgfortran/generated/minloc0_16_r4.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_16_r4 (gfc_array_i16 * const restrict, \n+\tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_16_r4);\n+\n+void\n+sminloc0_16_r4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r4 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_16_r4 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "52ef10b58671621b196787fecd85afdb97b5be84", "filename": "libgfortran/generated/minloc0_16_r8.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_16_r8 (gfc_array_i16 * const restrict, \n+\tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_16_r8);\n+\n+void\n+sminloc0_16_r8 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r8 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_16_r8 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "5486e93739d37adcf938e4f0d65b5e599c5ad553", "filename": "libgfortran/generated/minloc0_4_i16.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_4_i16 (gfc_array_i4 * const restrict, \n+\tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_4_i16);\n+\n+void\n+sminloc0_4_i16 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_4_i16 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "519b10ecf3aac32acdb5c0b9cba8331058e65dd0", "filename": "libgfortran/generated/minloc0_4_i4.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_4_i4 (gfc_array_i4 * const restrict, \n+\tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_4_i4);\n+\n+void\n+sminloc0_4_i4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_4_i4 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "3988838666bc896b226ba965badaf95cf2f95133", "filename": "libgfortran/generated/minloc0_4_i8.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_4_i8 (gfc_array_i4 * const restrict, \n+\tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_4_i8);\n+\n+void\n+sminloc0_4_i8 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_4_i8 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "5c0ccfbb59f6815c3c839f8ab1613f64e28cad55", "filename": "libgfortran/generated/minloc0_4_r10.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r10.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_4_r10 (gfc_array_i4 * const restrict, \n+\tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_4_r10);\n+\n+void\n+sminloc0_4_r10 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r10 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_4_r10 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "fbb75bab50c0561be233b5bad6ba5509a5b87813", "filename": "libgfortran/generated/minloc0_4_r16.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_4_r16 (gfc_array_i4 * const restrict, \n+\tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_4_r16);\n+\n+void\n+sminloc0_4_r16 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r16 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_4_r16 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "911117696ea062e29f1d47538b6b2fb0f6cc5e9d", "filename": "libgfortran/generated/minloc0_4_r4.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_4_r4 (gfc_array_i4 * const restrict, \n+\tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_4_r4);\n+\n+void\n+sminloc0_4_r4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r4 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_4_r4 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "461bedb9dfb15a2d44683741009863757b0ef6c8", "filename": "libgfortran/generated/minloc0_4_r8.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_4_r8 (gfc_array_i4 * const restrict, \n+\tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_4_r8);\n+\n+void\n+sminloc0_4_r8 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r8 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_4_r8 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "92bb0a225192d3f304a7ef907bc41aaae63c9c4f", "filename": "libgfortran/generated/minloc0_8_i16.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_8_i16 (gfc_array_i8 * const restrict, \n+\tgfc_array_i16 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_8_i16);\n+\n+void\n+sminloc0_8_i16 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_8_i16 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "6229244751fdcb538cd47898ed599e13ad5ddd9f", "filename": "libgfortran/generated/minloc0_8_i4.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_8_i4 (gfc_array_i8 * const restrict, \n+\tgfc_array_i4 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_8_i4);\n+\n+void\n+sminloc0_8_i4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_8_i4 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "01090ed9366b34233c91ea99f36c581782fd786b", "filename": "libgfortran/generated/minloc0_8_i8.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_8_i8 (gfc_array_i8 * const restrict, \n+\tgfc_array_i8 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_8_i8);\n+\n+void\n+sminloc0_8_i8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_8_i8 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "8bd4251829a59dd62ae9646056c9acddda102dec", "filename": "libgfortran/generated/minloc0_8_r10.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r10.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_8_r10 (gfc_array_i8 * const restrict, \n+\tgfc_array_r10 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_8_r10);\n+\n+void\n+sminloc0_8_r10 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r10 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_8_r10 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "ea229d7e40324bd7bb2d38221abaab67c023e687", "filename": "libgfortran/generated/minloc0_8_r16.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_8_r16 (gfc_array_i8 * const restrict, \n+\tgfc_array_r16 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_8_r16);\n+\n+void\n+sminloc0_8_r16 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r16 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_8_r16 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "e91466e28adc53385cfa240c276735915175fee2", "filename": "libgfortran/generated/minloc0_8_r4.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_8_r4 (gfc_array_i8 * const restrict, \n+\tgfc_array_r4 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_8_r4);\n+\n+void\n+sminloc0_8_r4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r4 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_8_r4 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "00d3718f92f37ede449966a2fe0139b4617d9c18", "filename": "libgfortran/generated/minloc0_8_r8.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -293,4 +293,56 @@ mminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   }\n }\n \n+\n+extern void sminloc0_8_r8 (gfc_array_i8 * const restrict, \n+\tgfc_array_r8 * const restrict, GFC_LOGICAL_4 *);\n+export_proto(sminloc0_8_r8);\n+\n+void\n+sminloc0_8_r8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r8 * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc0_8_r8 (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n #endif"}, {"sha": "5c49e798e0633b1737b237553cbce6f888230ec2", "filename": "libgfortran/generated/minloc1_16_i16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_16_i16 (gfc_array_i16 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_16_i16);\n+\n+void\n+sminloc1_16_i16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_16_i16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "cba6b90cfb8b8b93a8d872df204e803a9ba5ec67", "filename": "libgfortran/generated/minloc1_16_i4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_16_i4 (gfc_array_i16 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_16_i4);\n+\n+void\n+sminloc1_16_i4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_16_i4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "ba8be3987ad719d794eea2cdd9becc63ff56619b", "filename": "libgfortran/generated/minloc1_16_i8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_16_i8 (gfc_array_i16 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_16_i8);\n+\n+void\n+sminloc1_16_i8 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_16_i8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "3553c224faabb024701eea1aaedf5ef361eb5557", "filename": "libgfortran/generated/minloc1_16_r10.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r10.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_16_r10 (gfc_array_i16 * const restrict, \n+\tgfc_array_r10 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_16_r10);\n+\n+void\n+sminloc1_16_r10 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r10 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_16_r10 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "258a5e21561d70600b54ea4b8b28bb9777603cc2", "filename": "libgfortran/generated/minloc1_16_r16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_16_r16 (gfc_array_i16 * const restrict, \n+\tgfc_array_r16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_16_r16);\n+\n+void\n+sminloc1_16_r16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_16_r16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "86ba6670040962a88b22fe9f3ef34f721966d888", "filename": "libgfortran/generated/minloc1_16_r4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_16_r4 (gfc_array_i16 * const restrict, \n+\tgfc_array_r4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_16_r4);\n+\n+void\n+sminloc1_16_r4 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_16_r4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "1fe86e5019cf0993c80616767e5f8ec3ef174101", "filename": "libgfortran/generated/minloc1_16_r8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_16_r8 (gfc_array_i16 * const restrict, \n+\tgfc_array_r8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_16_r8);\n+\n+void\n+sminloc1_16_r8 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_16_r8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "5952d216005b4f8c1489d07119af604b53e3e67b", "filename": "libgfortran/generated/minloc1_4_i16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_4_i16 (gfc_array_i4 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_4_i16);\n+\n+void\n+sminloc1_4_i16 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_4_i16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "79321f14a8184628eee3ee3a81cd6b3ff5eb3d46", "filename": "libgfortran/generated/minloc1_4_i4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_4_i4 (gfc_array_i4 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_4_i4);\n+\n+void\n+sminloc1_4_i4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_4_i4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "625328beac9ec3b865df049dc2cc2e2902b7cb2b", "filename": "libgfortran/generated/minloc1_4_i8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_4_i8 (gfc_array_i4 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_4_i8);\n+\n+void\n+sminloc1_4_i8 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_4_i8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "ab4d5b415b781796d6bf00ea06fe14a48377b469", "filename": "libgfortran/generated/minloc1_4_r10.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r10.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_4_r10 (gfc_array_i4 * const restrict, \n+\tgfc_array_r10 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_4_r10);\n+\n+void\n+sminloc1_4_r10 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r10 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_4_r10 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "9ffdd331ddafcb188789897748c5ddea609d1cc6", "filename": "libgfortran/generated/minloc1_4_r16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_4_r16 (gfc_array_i4 * const restrict, \n+\tgfc_array_r16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_4_r16);\n+\n+void\n+sminloc1_4_r16 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_4_r16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "a91ee8da0deac655220b1d175d73768c0e869bb1", "filename": "libgfortran/generated/minloc1_4_r4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_4_r4 (gfc_array_i4 * const restrict, \n+\tgfc_array_r4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_4_r4);\n+\n+void\n+sminloc1_4_r4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_4_r4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "355333d20a5da877a568496e44ef6de9d0002e4d", "filename": "libgfortran/generated/minloc1_4_r8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_4_r8 (gfc_array_i4 * const restrict, \n+\tgfc_array_r8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_4_r8);\n+\n+void\n+sminloc1_4_r8 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_4_r8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "4e78589fc60c8e0b781452afa935adebba2ec555", "filename": "libgfortran/generated/minloc1_8_i16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_8_i16 (gfc_array_i8 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_8_i16);\n+\n+void\n+sminloc1_8_i16 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_8_i16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "ae71c33ff50b9a1feeadfdc383b0d318a11718c1", "filename": "libgfortran/generated/minloc1_8_i4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_8_i4 (gfc_array_i8 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_8_i4);\n+\n+void\n+sminloc1_8_i4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_8_i4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "31cc82213a0f164e6e0fd8cd141eb1cd61a6f715", "filename": "libgfortran/generated/minloc1_8_i8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_8_i8 (gfc_array_i8 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_8_i8);\n+\n+void\n+sminloc1_8_i8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_8_i8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "3dd3b1eca1c47ed8c773b56d57f31af2852b2eff", "filename": "libgfortran/generated/minloc1_8_r10.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r10.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_8_r10 (gfc_array_i8 * const restrict, \n+\tgfc_array_r10 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_8_r10);\n+\n+void\n+sminloc1_8_r10 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r10 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_8_r10 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "9de92d07d3e1e0be2e93c5a3cf3ed6cbce44f23d", "filename": "libgfortran/generated/minloc1_8_r16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_8_r16 (gfc_array_i8 * const restrict, \n+\tgfc_array_r16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_8_r16);\n+\n+void\n+sminloc1_8_r16 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_8_r16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "a47ef259afa9796204ffba132a5c28b686340982", "filename": "libgfortran/generated/minloc1_8_r4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_8_r4 (gfc_array_i8 * const restrict, \n+\tgfc_array_r4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_8_r4);\n+\n+void\n+sminloc1_8_r4 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_8_r4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "2637fe6351f434044f4d1afbaacd156ad539017c", "filename": "libgfortran/generated/minloc1_8_r8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -350,4 +350,58 @@ mminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminloc1_8_r8 (gfc_array_i8 * const restrict, \n+\tgfc_array_r8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminloc1_8_r8);\n+\n+void\n+sminloc1_8_r8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minloc1_8_r8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "f1c2e3852e6d2523b7749898d2e22270e041e253", "filename": "libgfortran/generated/minval_i16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -339,4 +339,58 @@ mminval_i16 (gfc_array_i16 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminval_i16 (gfc_array_i16 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminval_i16);\n+\n+void\n+sminval_i16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minval_i16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = GFC_INTEGER_16_HUGE ;\n+}\n+\n #endif"}, {"sha": "bb79787119d853ae5356aa113005f9dd0894043f", "filename": "libgfortran/generated/minval_i4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -339,4 +339,58 @@ mminval_i4 (gfc_array_i4 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminval_i4 (gfc_array_i4 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminval_i4);\n+\n+void\n+sminval_i4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minval_i4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = GFC_INTEGER_4_HUGE ;\n+}\n+\n #endif"}, {"sha": "deb5339122116127985fe393f9ad489c6faa092e", "filename": "libgfortran/generated/minval_i8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -339,4 +339,58 @@ mminval_i8 (gfc_array_i8 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminval_i8 (gfc_array_i8 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminval_i8);\n+\n+void\n+sminval_i8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minval_i8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = GFC_INTEGER_8_HUGE ;\n+}\n+\n #endif"}, {"sha": "be02a66dab95e5a0f5f0a25d353f51dd0d481e03", "filename": "libgfortran/generated/minval_r10.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r10.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -339,4 +339,58 @@ mminval_r10 (gfc_array_r10 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminval_r10 (gfc_array_r10 * const restrict, \n+\tgfc_array_r10 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminval_r10);\n+\n+void\n+sminval_r10 (gfc_array_r10 * const restrict retarray, \n+\tgfc_array_r10 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_REAL_10 *dest;\n+\n+  if (*mask)\n+    {\n+      minval_r10 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_REAL_10) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = GFC_REAL_10_HUGE ;\n+}\n+\n #endif"}, {"sha": "cacd524fff0b9f5bf31fadb97bd1222b7e461bfd", "filename": "libgfortran/generated/minval_r16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -339,4 +339,58 @@ mminval_r16 (gfc_array_r16 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminval_r16 (gfc_array_r16 * const restrict, \n+\tgfc_array_r16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminval_r16);\n+\n+void\n+sminval_r16 (gfc_array_r16 * const restrict retarray, \n+\tgfc_array_r16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_REAL_16 *dest;\n+\n+  if (*mask)\n+    {\n+      minval_r16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_REAL_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = GFC_REAL_16_HUGE ;\n+}\n+\n #endif"}, {"sha": "0f383d97a4c7d7c1448b81ce23d38d4d7fc3514e", "filename": "libgfortran/generated/minval_r4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -339,4 +339,58 @@ mminval_r4 (gfc_array_r4 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminval_r4 (gfc_array_r4 * const restrict, \n+\tgfc_array_r4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminval_r4);\n+\n+void\n+sminval_r4 (gfc_array_r4 * const restrict retarray, \n+\tgfc_array_r4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_REAL_4 *dest;\n+\n+  if (*mask)\n+    {\n+      minval_r4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_REAL_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = GFC_REAL_4_HUGE ;\n+}\n+\n #endif"}, {"sha": "31ba61935656e037d8d504d7e65839d3fc85a319", "filename": "libgfortran/generated/minval_r8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fminval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -339,4 +339,58 @@ mminval_r8 (gfc_array_r8 * const restrict retarray,\n     }\n }\n \n+\n+extern void sminval_r8 (gfc_array_r8 * const restrict, \n+\tgfc_array_r8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminval_r8);\n+\n+void\n+sminval_r8 (gfc_array_r8 * const restrict retarray, \n+\tgfc_array_r8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_REAL_8 *dest;\n+\n+  if (*mask)\n+    {\n+      minval_r8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_REAL_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = GFC_REAL_8_HUGE ;\n+}\n+\n #endif"}, {"sha": "59552f276d563c81454198cd4e6535f6d4083547", "filename": "libgfortran/generated/product_c10.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c10.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ mproduct_c10 (gfc_array_c10 * const restrict retarray,\n     }\n }\n \n+\n+extern void sproduct_c10 (gfc_array_c10 * const restrict, \n+\tgfc_array_c10 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sproduct_c10);\n+\n+void\n+sproduct_c10 (gfc_array_c10 * const restrict retarray, \n+\tgfc_array_c10 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_COMPLEX_10 *dest;\n+\n+  if (*mask)\n+    {\n+      product_c10 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_COMPLEX_10) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 1 ;\n+}\n+\n #endif"}, {"sha": "97b6ac1a219cab893d09c52266182f2488bc40e2", "filename": "libgfortran/generated/product_c16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ mproduct_c16 (gfc_array_c16 * const restrict retarray,\n     }\n }\n \n+\n+extern void sproduct_c16 (gfc_array_c16 * const restrict, \n+\tgfc_array_c16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sproduct_c16);\n+\n+void\n+sproduct_c16 (gfc_array_c16 * const restrict retarray, \n+\tgfc_array_c16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_COMPLEX_16 *dest;\n+\n+  if (*mask)\n+    {\n+      product_c16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_COMPLEX_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 1 ;\n+}\n+\n #endif"}, {"sha": "14dc21eaabe408c8f03c6bf604ac99c8d1d535be", "filename": "libgfortran/generated/product_c4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ mproduct_c4 (gfc_array_c4 * const restrict retarray,\n     }\n }\n \n+\n+extern void sproduct_c4 (gfc_array_c4 * const restrict, \n+\tgfc_array_c4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sproduct_c4);\n+\n+void\n+sproduct_c4 (gfc_array_c4 * const restrict retarray, \n+\tgfc_array_c4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_COMPLEX_4 *dest;\n+\n+  if (*mask)\n+    {\n+      product_c4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_COMPLEX_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 1 ;\n+}\n+\n #endif"}, {"sha": "3313f2ab1740ac50811ec2ff7f13872665ccd205", "filename": "libgfortran/generated/product_c8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ mproduct_c8 (gfc_array_c8 * const restrict retarray,\n     }\n }\n \n+\n+extern void sproduct_c8 (gfc_array_c8 * const restrict, \n+\tgfc_array_c8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sproduct_c8);\n+\n+void\n+sproduct_c8 (gfc_array_c8 * const restrict retarray, \n+\tgfc_array_c8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_COMPLEX_8 *dest;\n+\n+  if (*mask)\n+    {\n+      product_c8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_COMPLEX_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 1 ;\n+}\n+\n #endif"}, {"sha": "7079dc434134a8fda25d447f80dc326e70a92a2d", "filename": "libgfortran/generated/product_i16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ mproduct_i16 (gfc_array_i16 * const restrict retarray,\n     }\n }\n \n+\n+extern void sproduct_i16 (gfc_array_i16 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sproduct_i16);\n+\n+void\n+sproduct_i16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      product_i16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 1 ;\n+}\n+\n #endif"}, {"sha": "da88e97556e0d925cd1b54c90e51d35c41a6933c", "filename": "libgfortran/generated/product_i4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ mproduct_i4 (gfc_array_i4 * const restrict retarray,\n     }\n }\n \n+\n+extern void sproduct_i4 (gfc_array_i4 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sproduct_i4);\n+\n+void\n+sproduct_i4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      product_i4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 1 ;\n+}\n+\n #endif"}, {"sha": "c60e8f76572ce33942ae253cefa2f11bf0677c9b", "filename": "libgfortran/generated/product_i8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ mproduct_i8 (gfc_array_i8 * const restrict retarray,\n     }\n }\n \n+\n+extern void sproduct_i8 (gfc_array_i8 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sproduct_i8);\n+\n+void\n+sproduct_i8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      product_i8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 1 ;\n+}\n+\n #endif"}, {"sha": "710216fff830e5cbc25dc83fa0e8157a3846f6c9", "filename": "libgfortran/generated/product_r10.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r10.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ mproduct_r10 (gfc_array_r10 * const restrict retarray,\n     }\n }\n \n+\n+extern void sproduct_r10 (gfc_array_r10 * const restrict, \n+\tgfc_array_r10 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sproduct_r10);\n+\n+void\n+sproduct_r10 (gfc_array_r10 * const restrict retarray, \n+\tgfc_array_r10 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_REAL_10 *dest;\n+\n+  if (*mask)\n+    {\n+      product_r10 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_REAL_10) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 1 ;\n+}\n+\n #endif"}, {"sha": "b6df4ddbb2af5beadc0a22abf2c671dfb084ed61", "filename": "libgfortran/generated/product_r16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ mproduct_r16 (gfc_array_r16 * const restrict retarray,\n     }\n }\n \n+\n+extern void sproduct_r16 (gfc_array_r16 * const restrict, \n+\tgfc_array_r16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sproduct_r16);\n+\n+void\n+sproduct_r16 (gfc_array_r16 * const restrict retarray, \n+\tgfc_array_r16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_REAL_16 *dest;\n+\n+  if (*mask)\n+    {\n+      product_r16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_REAL_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 1 ;\n+}\n+\n #endif"}, {"sha": "e31b39452796ae3fe63ffe0f33d982c23a0c1f57", "filename": "libgfortran/generated/product_r4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ mproduct_r4 (gfc_array_r4 * const restrict retarray,\n     }\n }\n \n+\n+extern void sproduct_r4 (gfc_array_r4 * const restrict, \n+\tgfc_array_r4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sproduct_r4);\n+\n+void\n+sproduct_r4 (gfc_array_r4 * const restrict retarray, \n+\tgfc_array_r4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_REAL_4 *dest;\n+\n+  if (*mask)\n+    {\n+      product_r4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_REAL_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 1 ;\n+}\n+\n #endif"}, {"sha": "a2e805c0d33bc5b4d4a4b24ec36abd7ce2622560", "filename": "libgfortran/generated/product_r8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fproduct_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ mproduct_r8 (gfc_array_r8 * const restrict retarray,\n     }\n }\n \n+\n+extern void sproduct_r8 (gfc_array_r8 * const restrict, \n+\tgfc_array_r8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sproduct_r8);\n+\n+void\n+sproduct_r8 (gfc_array_r8 * const restrict retarray, \n+\tgfc_array_r8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_REAL_8 *dest;\n+\n+  if (*mask)\n+    {\n+      product_r8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_REAL_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 1 ;\n+}\n+\n #endif"}, {"sha": "344fd3ff386b4c84b0417dad9f4360a5540af5fc", "filename": "libgfortran/generated/sum_c10.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c10.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ msum_c10 (gfc_array_c10 * const restrict retarray,\n     }\n }\n \n+\n+extern void ssum_c10 (gfc_array_c10 * const restrict, \n+\tgfc_array_c10 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(ssum_c10);\n+\n+void\n+ssum_c10 (gfc_array_c10 * const restrict retarray, \n+\tgfc_array_c10 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_COMPLEX_10 *dest;\n+\n+  if (*mask)\n+    {\n+      sum_c10 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_COMPLEX_10) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "8cdf9766c53a944b0153223125e4e647a09e6541", "filename": "libgfortran/generated/sum_c16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ msum_c16 (gfc_array_c16 * const restrict retarray,\n     }\n }\n \n+\n+extern void ssum_c16 (gfc_array_c16 * const restrict, \n+\tgfc_array_c16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(ssum_c16);\n+\n+void\n+ssum_c16 (gfc_array_c16 * const restrict retarray, \n+\tgfc_array_c16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_COMPLEX_16 *dest;\n+\n+  if (*mask)\n+    {\n+      sum_c16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_COMPLEX_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "1e113ad85ce9c61f2cf8c536cd2f12f584acec65", "filename": "libgfortran/generated/sum_c4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ msum_c4 (gfc_array_c4 * const restrict retarray,\n     }\n }\n \n+\n+extern void ssum_c4 (gfc_array_c4 * const restrict, \n+\tgfc_array_c4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(ssum_c4);\n+\n+void\n+ssum_c4 (gfc_array_c4 * const restrict retarray, \n+\tgfc_array_c4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_COMPLEX_4 *dest;\n+\n+  if (*mask)\n+    {\n+      sum_c4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_COMPLEX_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "eec1b783826f03d82581c5cddbb79efdb618a126", "filename": "libgfortran/generated/sum_c8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ msum_c8 (gfc_array_c8 * const restrict retarray,\n     }\n }\n \n+\n+extern void ssum_c8 (gfc_array_c8 * const restrict, \n+\tgfc_array_c8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(ssum_c8);\n+\n+void\n+ssum_c8 (gfc_array_c8 * const restrict retarray, \n+\tgfc_array_c8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_COMPLEX_8 *dest;\n+\n+  if (*mask)\n+    {\n+      sum_c8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_COMPLEX_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "2a378361ff3da8489fba5fcbe3d90742e540732d", "filename": "libgfortran/generated/sum_i16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ msum_i16 (gfc_array_i16 * const restrict retarray,\n     }\n }\n \n+\n+extern void ssum_i16 (gfc_array_i16 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(ssum_i16);\n+\n+void\n+ssum_i16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (*mask)\n+    {\n+      sum_i16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "4062a3bbe15ad251042f81c3bfcb125c25197249", "filename": "libgfortran/generated/sum_i4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ msum_i4 (gfc_array_i4 * const restrict retarray,\n     }\n }\n \n+\n+extern void ssum_i4 (gfc_array_i4 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(ssum_i4);\n+\n+void\n+ssum_i4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (*mask)\n+    {\n+      sum_i4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "ce02c06348851f714a1052675c578d6625eca516", "filename": "libgfortran/generated/sum_i8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ msum_i8 (gfc_array_i8 * const restrict retarray,\n     }\n }\n \n+\n+extern void ssum_i8 (gfc_array_i8 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(ssum_i8);\n+\n+void\n+ssum_i8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (*mask)\n+    {\n+      sum_i8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_INTEGER_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "07f6ae397fc7b37fd60d3a95378ccf64c79bef3f", "filename": "libgfortran/generated/sum_r10.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r10.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ msum_r10 (gfc_array_r10 * const restrict retarray,\n     }\n }\n \n+\n+extern void ssum_r10 (gfc_array_r10 * const restrict, \n+\tgfc_array_r10 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(ssum_r10);\n+\n+void\n+ssum_r10 (gfc_array_r10 * const restrict retarray, \n+\tgfc_array_r10 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_REAL_10 *dest;\n+\n+  if (*mask)\n+    {\n+      sum_r10 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_REAL_10) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "975bc25853604e34eb966097158e32e3dcbca31d", "filename": "libgfortran/generated/sum_r16.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r16.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ msum_r16 (gfc_array_r16 * const restrict retarray,\n     }\n }\n \n+\n+extern void ssum_r16 (gfc_array_r16 * const restrict, \n+\tgfc_array_r16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(ssum_r16);\n+\n+void\n+ssum_r16 (gfc_array_r16 * const restrict retarray, \n+\tgfc_array_r16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_REAL_16 *dest;\n+\n+  if (*mask)\n+    {\n+      sum_r16 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_REAL_16) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "db905ae4c1347cb90adbc306f142741e61debd45", "filename": "libgfortran/generated/sum_r4.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r4.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ msum_r4 (gfc_array_r4 * const restrict retarray,\n     }\n }\n \n+\n+extern void ssum_r4 (gfc_array_r4 * const restrict, \n+\tgfc_array_r4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(ssum_r4);\n+\n+void\n+ssum_r4 (gfc_array_r4 * const restrict retarray, \n+\tgfc_array_r4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_REAL_4 *dest;\n+\n+  if (*mask)\n+    {\n+      sum_r4 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_REAL_4) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "ed2440be39a329e0f76918b04a9f440f41f37ff2", "filename": "libgfortran/generated/sum_r8.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fgenerated%2Fsum_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r8.c?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -337,4 +337,58 @@ msum_r8 (gfc_array_r8 * const restrict retarray,\n     }\n }\n \n+\n+extern void ssum_r8 (gfc_array_r8 * const restrict, \n+\tgfc_array_r8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(ssum_r8);\n+\n+void\n+ssum_r8 (gfc_array_r8 * const restrict retarray, \n+\tgfc_array_r8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  GFC_REAL_8 *dest;\n+\n+  if (*mask)\n+    {\n+      sum_r8 (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (GFC_REAL_8) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = 0 ;\n+}\n+\n #endif"}, {"sha": "7d20213e9aad8d29078e3f27fb3e2d54c77b8cde", "filename": "libgfortran/m4/iforeach.m4", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fiforeach.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fiforeach.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiforeach.m4?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -248,3 +248,56 @@ $1\n START_MASKED_FOREACH_BLOCK\n $2\n FINISH_MASKED_FOREACH_FUNCTION')dnl\n+define(SCALAR_FOREACH_FUNCTION,\n+`\n+extern void `s'name`'rtype_qual`_'atype_code (rtype * const restrict, \n+\tatype * const restrict, GFC_LOGICAL_4 *);\n+export_proto(`s'name`'rtype_qual`_'atype_code);\n+\n+void\n+`s'name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n+\tatype * const restrict array,\n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  rtype_name *dest;\n+\n+  if (*mask)\n+    {\n+      name`'rtype_qual`_'atype_code (retarray, array);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (rtype_name) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+  dstride = retarray->dim[0].stride;\n+  dest = retarray->data;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = $1 ;\n+}')dnl"}, {"sha": "d1a34da00b16afb390dbd400837dde7bf5374195", "filename": "libgfortran/m4/ifunction.m4", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fifunction.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fifunction.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifunction.m4?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -317,6 +317,60 @@ define(FINISH_MASKED_ARRAY_FUNCTION,\n         }\n     }\n }')dnl\n+define(SCALAR_ARRAY_FUNCTION,\n+`\n+extern void `s'name`'rtype_qual`_'atype_code (rtype * const restrict, \n+\tatype * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(`s'name`'rtype_qual`_'atype_code);\n+\n+void\n+`s'name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n+\tatype * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type rank;\n+  index_type n;\n+  index_type dstride;\n+  rtype_name *dest;\n+\n+  if (*mask)\n+    {\n+      name`'rtype_qual`_'atype_code (retarray, array, pdim);\n+      return;\n+    }\n+    rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->data == NULL)\n+    {\n+      retarray->dim[0].lbound = 0;\n+      retarray->dim[0].ubound = rank-1;\n+      retarray->dim[0].stride = 1;\n+      retarray->dtype = (retarray->dtype & ~GFC_DTYPE_RANK_MASK) | 1;\n+      retarray->offset = 0;\n+      retarray->data = internal_malloc_size (sizeof (rtype_name) * rank);\n+    }\n+  else\n+    {\n+      if (GFC_DESCRIPTOR_RANK (retarray) != 1)\n+\truntime_error (\"rank of return array does not equal 1\");\n+\n+      if (retarray->dim[0].ubound + 1 - retarray->dim[0].lbound != rank)\n+        runtime_error (\"dimension of return array incorrect\");\n+\n+      if (retarray->dim[0].stride == 0)\n+\tretarray->dim[0].stride = 1;\n+    }\n+\n+    dstride = retarray->dim[0].stride;\n+    dest = retarray->data;\n+\n+    for (n = 0; n < rank; n++)\n+      dest[n * dstride] = $1 ;\n+}')dnl\n define(ARRAY_FUNCTION,\n `START_ARRAY_FUNCTION\n $2"}, {"sha": "a7e88f0b2ceaf9532bfc9ed03a13abbf1c0cd18f", "filename": "libgfortran/m4/maxloc0.m4", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fmaxloc0.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fmaxloc0.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxloc0.m4?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -64,4 +64,5 @@ MASKED_FOREACH_FUNCTION(\n         dest[n * dstride] = count[n] + 1;\n     }')\n \n+SCALAR_FOREACH_FUNCTION(`0')\n #endif"}, {"sha": "3a6ed5ad974dfb937aa9c138c4155d15d9227f8d", "filename": "libgfortran/m4/maxloc1.m4", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fmaxloc1.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fmaxloc1.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxloc1.m4?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -60,4 +60,6 @@ MASKED_ARRAY_FUNCTION(0,\n       result = (rtype_name)n + 1;\n     }')\n \n+SCALAR_ARRAY_FUNCTION(0)\n+\n #endif"}, {"sha": "07cbbdd6ac660fe99c2483420997506da3b8684a", "filename": "libgfortran/m4/maxval.m4", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fmaxval.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fmaxval.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmaxval.m4?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -49,4 +49,6 @@ MASKED_ARRAY_FUNCTION(atype_min,\n `  if (*msrc && *src > result)\n     result = *src;')\n \n+SCALAR_ARRAY_FUNCTION(atype_min)\n+\n #endif"}, {"sha": "33bfe312a5406183353ba737d5dba65f0a1c6473", "filename": "libgfortran/m4/minloc0.m4", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fminloc0.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fminloc0.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminloc0.m4?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -64,4 +64,5 @@ MASKED_FOREACH_FUNCTION(\n         dest[n * dstride] = count[n] + 1;\n     }')\n \n+SCALAR_FOREACH_FUNCTION(`0')\n #endif"}, {"sha": "f923ca80410de3d89b490d4c68702de9f3845960", "filename": "libgfortran/m4/minloc1.m4", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fminloc1.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fminloc1.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminloc1.m4?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -60,4 +60,6 @@ MASKED_ARRAY_FUNCTION(0,\n       result = (rtype_name)n + 1;\n     }')\n \n+SCALAR_ARRAY_FUNCTION(0)\n+\n #endif"}, {"sha": "af02319c1ddb1097ba0060ccf2ffb5458e426ae8", "filename": "libgfortran/m4/minval.m4", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fminval.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fminval.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fminval.m4?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -49,4 +49,6 @@ MASKED_ARRAY_FUNCTION(atype_max,\n `  if (*msrc && *src < result)\n     result = *src;')\n \n+SCALAR_ARRAY_FUNCTION(atype_max)\n+\n #endif"}, {"sha": "47ee25b8b80c0c435a5dfd023bebc9d56ab91692", "filename": "libgfortran/m4/product.m4", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fproduct.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fproduct.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fproduct.m4?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -47,4 +47,6 @@ MASKED_ARRAY_FUNCTION(1,\n `  if (*msrc)\n     result *= *src;')\n \n+SCALAR_ARRAY_FUNCTION(1)\n+\n #endif"}, {"sha": "a9406882cfa7ac09cea07e056d95df8978abdfa1", "filename": "libgfortran/m4/sum.m4", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fsum.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a62038664e3b5f7e46ce900b2a090c79bb03bd/libgfortran%2Fm4%2Fsum.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fsum.m4?ref=97a62038664e3b5f7e46ce900b2a090c79bb03bd", "patch": "@@ -47,4 +47,6 @@ MASKED_ARRAY_FUNCTION(0,\n `  if (*msrc)\n     result += *src;')\n \n+SCALAR_ARRAY_FUNCTION(0)\n+\n #endif"}]}