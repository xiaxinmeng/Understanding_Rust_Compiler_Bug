{"sha": "52053c3b536353510cac1c8370541b24847f8022", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTIwNTNjM2I1MzYzNTM1MTBjYWMxYzgzNzA1NDFiMjQ4NDdmODAyMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-30T16:21:28Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-30T16:21:28Z"}, "message": "Remove global call sets: rtlanal.c\n\nThe reg_set_p part is simple, since the caller is asking about\na specific REG rtx, with a known register number and mode.\n\nThe find_all_hard_reg_sets part emphasises that the \"implicit\"\nbehaviour was always a bit suspect, since it includes fully-clobbered\nregisters but not partially-clobbered registers.  The only current\nuser of this path is the c6x-specific scheduler predication code,\nand c6x doesn't have partly call-clobbered registers, so in practice\nit's fine.  I've added a comment to try to disuade future users.\n(The !implicit path is OK and useful though.)\n\n2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* rtlanal.c: Include function-abi.h.\n\t(reg_set_p): Use insn_callee_abi to get the ABI of the called\n\tfunction and clobbers_reg_p to test whether the register\n\tis call-clobbered.\n\t(find_all_hard_reg_sets): When implicit is true, use insn_callee_abi\n\tto get the ABI of the called function and full_reg_clobbers to\n\tget the set of fully call-clobbered registers.  Warn about the\n\tpitfalls of using this mode.\n\nFrom-SVN: r276334", "tree": {"sha": "bc46d336910adf4e72a730f2226eb19a3f1a20c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc46d336910adf4e72a730f2226eb19a3f1a20c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52053c3b536353510cac1c8370541b24847f8022", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52053c3b536353510cac1c8370541b24847f8022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52053c3b536353510cac1c8370541b24847f8022", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52053c3b536353510cac1c8370541b24847f8022/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "12e20dde63c77eb696118e2624aacf8f11feb1f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12e20dde63c77eb696118e2624aacf8f11feb1f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12e20dde63c77eb696118e2624aacf8f11feb1f9"}], "stats": {"total": 24, "additions": 20, "deletions": 4}, "files": [{"sha": "046fbfc842585905a4107a3f1fcf52c2f37cfc5d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52053c3b536353510cac1c8370541b24847f8022/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52053c3b536353510cac1c8370541b24847f8022/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52053c3b536353510cac1c8370541b24847f8022", "patch": "@@ -1,3 +1,14 @@\n+2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* rtlanal.c: Include function-abi.h.\n+\t(reg_set_p): Use insn_callee_abi to get the ABI of the called\n+\tfunction and clobbers_reg_p to test whether the register\n+\tis call-clobbered.\n+\t(find_all_hard_reg_sets): When implicit is true, use insn_callee_abi\n+\tto get the ABI of the called function and full_reg_clobbers to\n+\tget the set of fully call-clobbered registers.  Warn about the\n+\tpitfalls of using this mode.\n+\n 2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* reload.c: Include function-abi.h."}, {"sha": "6adef47d9a68db06611b9ae237a3afa4095eca0c", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52053c3b536353510cac1c8370541b24847f8022/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52053c3b536353510cac1c8370541b24847f8022/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=52053c3b536353510cac1c8370541b24847f8022", "patch": "@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"addresses.h\"\n #include \"rtl-iter.h\"\n #include \"hard-reg-set.h\"\n+#include \"function-abi.h\"\n \n /* Forward declarations */\n static void set_of_1 (rtx, const_rtx, void *);\n@@ -1270,8 +1271,8 @@ reg_set_p (const_rtx reg, const_rtx insn)\n \t  || (CALL_P (insn)\n \t      && ((REG_P (reg)\n \t\t   && REGNO (reg) < FIRST_PSEUDO_REGISTER\n-\t\t   && overlaps_hard_reg_set_p (regs_invalidated_by_call,\n-\t\t\t\t\t       GET_MODE (reg), REGNO (reg)))\n+\t\t   && (insn_callee_abi (as_a<const rtx_insn *> (insn))\n+\t\t       .clobbers_reg_p (GET_MODE (reg), REGNO (reg))))\n \t\t  || MEM_P (reg)\n \t\t  || find_reg_fusage (insn, CLOBBER, reg)))))\n     return true;\n@@ -1486,7 +1487,11 @@ record_hard_reg_sets (rtx x, const_rtx pat ATTRIBUTE_UNUSED, void *data)\n }\n \n /* Examine INSN, and compute the set of hard registers written by it.\n-   Store it in *PSET.  Should only be called after reload.  */\n+   Store it in *PSET.  Should only be called after reload.\n+\n+   IMPLICIT is true if we should include registers that are fully-clobbered\n+   by calls.  This should be used with caution, since it doesn't include\n+   partially-clobbered registers.  */\n void\n find_all_hard_reg_sets (const rtx_insn *insn, HARD_REG_SET *pset, bool implicit)\n {\n@@ -1495,7 +1500,7 @@ find_all_hard_reg_sets (const rtx_insn *insn, HARD_REG_SET *pset, bool implicit)\n   CLEAR_HARD_REG_SET (*pset);\n   note_stores (insn, record_hard_reg_sets, pset);\n   if (CALL_P (insn) && implicit)\n-    *pset |= call_used_or_fixed_regs;\n+    *pset |= insn_callee_abi (insn).full_reg_clobbers ();\n   for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n     if (REG_NOTE_KIND (link) == REG_INC)\n       record_hard_reg_sets (XEXP (link, 0), NULL, pset);"}]}