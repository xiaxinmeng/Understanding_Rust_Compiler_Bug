{"sha": "071a6595101473e436302942d2ec631c7799c583", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDcxYTY1OTUxMDE0NzNlNDM2MzAyOTQyZDJlYzYzMWM3Nzk5YzU4Mw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1994-12-03T04:17:51Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1994-12-03T04:17:51Z"}, "message": "* expr.c (store_constructor):  Add support for SET_TYPE.\n\nFrom-SVN: r8604", "tree": {"sha": "f6a49673490ec9cb77e4cf8ff66c13c01d254018", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6a49673490ec9cb77e4cf8ff66c13c01d254018"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/071a6595101473e436302942d2ec631c7799c583", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/071a6595101473e436302942d2ec631c7799c583", "html_url": "https://github.com/Rust-GCC/gccrs/commit/071a6595101473e436302942d2ec631c7799c583", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/071a6595101473e436302942d2ec631c7799c583/comments", "author": null, "committer": null, "parents": [{"sha": "0be37202964cb589ce07001406a9dca99ec21b0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0be37202964cb589ce07001406a9dca99ec21b0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0be37202964cb589ce07001406a9dca99ec21b0d"}], "stats": {"total": 167, "additions": 167, "deletions": 0}, "files": [{"sha": "6634811174438f5eddaf3d892287e4fb12c41a56", "filename": "gcc/expr.c", "status": "modified", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/071a6595101473e436302942d2ec631c7799c583/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/071a6595101473e436302942d2ec631c7799c583/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=071a6595101473e436302942d2ec631c7799c583", "patch": "@@ -188,6 +188,7 @@ static rtx compare\t\tPROTO((tree, enum rtx_code, enum rtx_code));\n static rtx do_store_flag\tPROTO((tree, rtx, enum machine_mode, int));\n static tree defer_cleanups_to\tPROTO((tree));\n extern void (*interim_eh_hook)\tPROTO((tree));\n+extern tree get_set_constructor_words PROTO((tree, HOST_WIDE_INT*, int));\n \n /* Record for each mode whether we can move a register directly to or\n    from an object of that mode in memory.  If we can't, we won't try\n@@ -3099,6 +3100,172 @@ store_constructor (exp, target)\n \t    }\n \t}\n     }\n+  /* set constructor assignments */\n+  else if (TREE_CODE (type) == SET_TYPE)\n+    {\n+      tree elt;\n+      rtx xtarget = XEXP (target, 0);\n+      int set_word_size = TYPE_ALIGN (type);\n+      int nbytes = int_size_in_bytes (type);\n+      int nwords;\n+      tree non_const_elements;\n+      int need_to_clear_first;\n+      tree domain = TYPE_DOMAIN (type);\n+      tree domain_min, domain_max, bitlength;\n+\n+      /* The default implementation stategy is to extract the constant\n+\t parts of the constructor, use that to initialize the target,\n+\t and then \"or\" in whatever non-constant ranges we need in addition.\n+\n+\t If a large set is all zero or all ones, it is\n+\t probably better to set it using memset (if available) or bzero.\n+\t Also, if a large set has just a single range, it may also be\n+\t better to first clear all the first clear the set (using\n+\t bzero/memset), and set the bits we want. */\n+       \n+      /* Check for all zeros. */\n+      if (CONSTRUCTOR_ELTS (exp) == NULL_TREE)\n+\t{\n+\t  clear_storage (target, nbytes);\n+\t  return;\n+\t}\n+\n+      if (nbytes < 0)\n+\tabort();\n+\n+      nwords = (nbytes * BITS_PER_UNIT) / set_word_size;\n+      if (nwords == 0)\n+\tnwords = 1;\n+\n+      domain_min = convert (sizetype, TYPE_MIN_VALUE (domain));\n+      domain_max = convert (sizetype, TYPE_MAX_VALUE (domain));\n+      bitlength = size_binop (PLUS_EXPR,\n+\t\t\t      size_binop (MINUS_EXPR, domain_max, domain_min),\n+\t\t\t      size_one_node);\n+\n+      /* Check for range all ones, or at most a single range.\n+       (This optimization is only a win for big sets.) */\n+      if (GET_MODE (target) == BLKmode && nbytes > 16\n+\t  && TREE_CHAIN (CONSTRUCTOR_ELTS (exp)) == NULL_TREE)\n+\t{\n+\t  need_to_clear_first = 1;\n+\t  non_const_elements = CONSTRUCTOR_ELTS (exp);\n+\t}\n+      else\n+\t{\n+\t  HOST_WIDE_INT *buffer\n+\t    = (HOST_WIDE_INT*) alloca (sizeof (HOST_WIDE_INT) * nwords);\n+\t  non_const_elements = get_set_constructor_words (exp, buffer, nwords);\n+\n+\t  if (nbytes * BITS_PER_UNIT <= set_word_size)\n+\t    {\n+\t      if (BITS_BIG_ENDIAN)\n+\t\tbuffer[0] >>= set_word_size - nbytes * BITS_PER_UNIT;\n+\t      emit_move_insn (target, GEN_INT (buffer[0]));\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx addr = XEXP (target, 0);\n+\t      rtx to_rtx;\n+\t      register int i;\n+\t      enum machine_mode mode\n+\t\t= mode_for_size (set_word_size, MODE_INT, 1);\n+\n+\t      for (i = 0; i < nwords; i++)\n+\t\t{\n+\t\t  int offset = i * set_word_size / BITS_PER_UNIT;\n+\t\t  rtx datum = GEN_INT (buffer[i]);\n+\t\t  rtx to_rtx = change_address (target, mode,\n+\t\t\t\t\t       plus_constant (addr, offset));\n+\t\t  MEM_IN_STRUCT_P (to_rtx) = 1;\n+\t\t  emit_move_insn (to_rtx, datum);\n+\t\t}\n+\t    }\n+\t  need_to_clear_first = 0;\n+\t}\n+\n+      for (elt = non_const_elements; elt != NULL_TREE; elt = TREE_CHAIN (elt))\n+\t{\n+\t  /* start of range of element or NULL */\n+\t  tree startbit = TREE_PURPOSE (elt);\n+\t  /* end of range of element, or element value */\n+\t  tree endbit   = TREE_VALUE (elt);\n+\t  HOST_WIDE_INT startb, endb;\n+\t  rtx  bitlength_rtx, startbit_rtx, endbit_rtx, targetx;\n+\n+\t  bitlength_rtx = expand_expr (bitlength,\n+\t\t\t    NULL_RTX, MEM, EXPAND_CONST_ADDRESS);\n+\n+\t  /* handle non-range tuple element like [ expr ]  */\n+\t  if (startbit == NULL_TREE)\n+\t    {\n+\t      startbit = save_expr (endbit);\n+\t      endbit = startbit;\n+\t    }\n+\t  startbit = convert (sizetype, startbit);\n+\t  endbit = convert (sizetype, endbit);\n+\t  if (! integer_zerop (domain_min))\n+\t    {\n+\t      startbit = size_binop (MINUS_EXPR, startbit, domain_min);\n+\t      endbit = size_binop (MINUS_EXPR, endbit, domain_min);\n+\t    }\n+\t  startbit_rtx = expand_expr (startbit, NULL_RTX, MEM, \n+\t\t\t\t      EXPAND_CONST_ADDRESS);\n+\t  endbit_rtx = expand_expr (endbit, NULL_RTX, MEM, \n+\t\t\t\t    EXPAND_CONST_ADDRESS);\n+\n+\t  if (REG_P (target))\n+\t    {\n+\t      targetx = assign_stack_temp (GET_MODE (target),\n+\t\t\t\t\t   GET_MODE_SIZE (GET_MODE (target)),\n+\t\t\t\t\t   0);\n+\t      emit_move_insn (targetx, target);\n+\t    }\n+\t  else if (GET_CODE (target) == MEM)\n+\t    targetx = target;\n+\t  else\n+\t    abort ();\n+\n+#ifdef TARGET_MEM_FUNCTIONS\n+\t  /* Optimization:  If startbit and endbit are\n+\t     constants divisble by BITS_PER_UNIT,\n+\t     call memset instead. */\n+\t  if (TREE_CODE (startbit) == INTEGER_CST\n+\t      && TREE_CODE (endbit) == INTEGER_CST\n+\t      && (startb = TREE_INT_CST_LOW (startbit)) % BITS_PER_UNIT == 0\n+\t      && (endb = TREE_INT_CST_LOW (endbit)) % BITS_PER_UNIT == 0)\n+\t    {\n+\t\t\n+\t      if (need_to_clear_first\n+\t\t  && endb - startb != nbytes * BITS_PER_UNIT)\n+\t\tclear_storage (target, nbytes);\n+\t      need_to_clear_first = 0;\n+\t      emit_library_call (memset_libfunc, 0,\n+\t\t\t\t VOIDmode, 3,\n+\t\t\t\t plus_constant (XEXP (targetx, 0), startb),\n+\t\t\t\t Pmode,\n+\t\t\t\t constm1_rtx, Pmode,\n+\t\t\t\t GEN_INT ((endb - startb) / BITS_PER_UNIT),\n+\t\t\t\t Pmode);\n+\t    }\n+\t  else\n+#endif\n+\t    {\n+\t      if (need_to_clear_first)\n+\t\t{\n+\t\t  clear_storage (target, nbytes);\n+\t\t  need_to_clear_first = 0;\n+\t\t}\n+\t      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__setbits\"),\n+\t\t\t\t 0, VOIDmode, 4, XEXP (targetx, 0), Pmode,\n+\t\t\t\t bitlength_rtx, TYPE_MODE (sizetype),\n+\t\t\t\t startbit_rtx, TYPE_MODE (sizetype),\n+\t\t\t\t endbit_rtx, TYPE_MODE (sizetype));\n+\t    }\n+\t  if (REG_P (target))\n+\t    emit_move_insn (target, targetx);\n+\t}\n+    }\n \n   else\n     abort ();"}]}