{"sha": "13f5595a20c891d31bfb878087328b5d09bca436", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNmNTU5NWEyMGM4OTFkMzFiZmI4NzgwODczMjhiNWQwOWJjYTQzNg==", "commit": {"author": {"name": "Jie Zhang", "email": "zhangjie@magima.com.cn", "date": "2004-09-08T11:07:35Z"}, "committer": {"name": "Giovanni Bajo", "email": "giovannibajo@gcc.gnu.org", "date": "2004-09-08T11:07:35Z"}, "message": "tree-ssa-alias.c (compute_flow_insensitive_aliasing): If type memory tag is call clobbered, so are its aliases.\n\n\t* tree-ssa-alias.c (compute_flow_insensitive_aliasing): If type\n\tmemory tag is call clobbered, so are its aliases.\n\t(group_aliases): When two memory tags being grouped, if one is\n\tcall clobbered, so are the other and its aliases.\n\t(add_may_alias): Remove call-clobbering stuff.\n\t(replace_may_alias): Likewise.\n\t(merge_pointed_to_info): Merge pt_global_mem.\n\nFrom-SVN: r87182", "tree": {"sha": "7d8f9a4dd89e74cf2bcb5d9cf80cf64389f2d33b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d8f9a4dd89e74cf2bcb5d9cf80cf64389f2d33b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13f5595a20c891d31bfb878087328b5d09bca436", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13f5595a20c891d31bfb878087328b5d09bca436", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13f5595a20c891d31bfb878087328b5d09bca436", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13f5595a20c891d31bfb878087328b5d09bca436/comments", "author": null, "committer": {"login": "rasky", "id": 1014109, "node_id": "MDQ6VXNlcjEwMTQxMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1014109?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasky", "html_url": "https://github.com/rasky", "followers_url": "https://api.github.com/users/rasky/followers", "following_url": "https://api.github.com/users/rasky/following{/other_user}", "gists_url": "https://api.github.com/users/rasky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasky/subscriptions", "organizations_url": "https://api.github.com/users/rasky/orgs", "repos_url": "https://api.github.com/users/rasky/repos", "events_url": "https://api.github.com/users/rasky/events{/privacy}", "received_events_url": "https://api.github.com/users/rasky/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89480522221ee99f08da1abd7197b5b7c978d5c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89480522221ee99f08da1abd7197b5b7c978d5c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89480522221ee99f08da1abd7197b5b7c978d5c0"}], "stats": {"total": 57, "additions": 37, "deletions": 20}, "files": [{"sha": "4dc3df111109a77d950129bf976815cf98e10793", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f5595a20c891d31bfb878087328b5d09bca436/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f5595a20c891d31bfb878087328b5d09bca436/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=13f5595a20c891d31bfb878087328b5d09bca436", "patch": "@@ -1,3 +1,13 @@\n+2004-09-08  Jie Zhang  <zhangjie@magima.com.cn>\n+\n+\t* tree-ssa-alias.c (compute_flow_insensitive_aliasing): If type\n+\tmemory tag is call clobbered, so are its aliases.\n+\t(group_aliases): When two memory tags being grouped, if one is\n+\tcall clobbered, so are the other and its aliases.\n+\t(add_may_alias): Remove call-clobbering stuff.\n+\t(replace_may_alias): Likewise.\n+\t(merge_pointed_to_info): Merge pt_global_mem\n+\n 2004-09-08  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c (cgraph_remove_node): Free DECL_INITIAL field of node."}, {"sha": "4bd438b94397317e45bb4993aa8f872dba8d6105", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f5595a20c891d31bfb878087328b5d09bca436/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f5595a20c891d31bfb878087328b5d09bca436/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=13f5595a20c891d31bfb878087328b5d09bca436", "patch": "@@ -930,6 +930,10 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n \t      num_tag_refs = VARRAY_UINT (ai->num_references, tag_ann->uid);\n \t      num_var_refs = VARRAY_UINT (ai->num_references, v_ann->uid);\n \n+\t      /* If TAG is call clobbered, so is VAR.  */\n+\t      if (is_call_clobbered (tag))\n+\t\tmark_call_clobbered (var);\n+\n \t      /* Add VAR to TAG's may-aliases set.  */\n \t      add_may_alias (tag, var);\n \n@@ -1122,8 +1126,29 @@ group_aliases (struct alias_info *ai)\n \t  sbitmap_a_and_b (res, tag1_aliases, tag2_aliases);\n \t  if (sbitmap_first_set_bit (res) >= 0)\n \t    {\n+\t      size_t k;\n+\n \t      tree tag2 = var_ann (ai->pointers[j]->var)->type_mem_tag;\n \n+\t      if (!is_call_clobbered (tag1) && is_call_clobbered (tag2))\n+\t\t{\n+\t\t  mark_call_clobbered (tag1);\n+\t\t  EXECUTE_IF_SET_IN_SBITMAP (tag1_aliases, 0, k,\n+\t\t    {\n+\t\t      tree var = referenced_var (k);\n+\t\t      mark_call_clobbered (var);\n+\t\t    });\n+\t\t}\n+\t      else if (is_call_clobbered (tag1) && !is_call_clobbered (tag2))\n+\t\t{\n+\t\t  mark_call_clobbered (tag2);\n+\t\t  EXECUTE_IF_SET_IN_SBITMAP (tag2_aliases, 0, k,\n+\t\t    {\n+\t\t      tree var = referenced_var (k);\n+\t\t      mark_call_clobbered (var);\n+\t\t    });\n+\t\t}\n+\n \t      sbitmap_a_or_b (tag1_aliases, tag1_aliases, tag2_aliases);\n \n \t      /* TAG2 does not need its aliases anymore.  */\n@@ -1640,16 +1665,6 @@ add_may_alias (tree var, tree alias)\n     if (alias == VARRAY_TREE (v_ann->may_aliases, i))\n       return;\n \n-  /* If VAR is a call-clobbered variable, so is its new ALIAS.\n-     FIXME, call-clobbering should only depend on whether an address\n-     escapes.  It should be independent of aliasing.  */\n-  if (is_call_clobbered (var))\n-    mark_call_clobbered (alias);\n-\n-  /* Likewise.  If ALIAS is call-clobbered, so is VAR.  */\n-  else if (is_call_clobbered (alias))\n-    mark_call_clobbered (var);\n-\n   VARRAY_PUSH_TREE (v_ann->may_aliases, alias);\n   a_ann->is_alias_tag = 1;\n }\n@@ -1662,16 +1677,6 @@ replace_may_alias (tree var, size_t i, tree new_alias)\n {\n   var_ann_t v_ann = var_ann (var);\n   VARRAY_TREE (v_ann->may_aliases, i) = new_alias;\n-\n-  /* If VAR is a call-clobbered variable, so is NEW_ALIAS.\n-     FIXME, call-clobbering should only depend on whether an address\n-     escapes.  It should be independent of aliasing.  */\n-  if (is_call_clobbered (var))\n-    mark_call_clobbered (new_alias);\n-\n-  /* Likewise.  If NEW_ALIAS is call-clobbered, so is VAR.  */\n-  else if (is_call_clobbered (new_alias))\n-    mark_call_clobbered (var);\n }\n \n \n@@ -1728,6 +1733,8 @@ merge_pointed_to_info (struct alias_info *ai, tree dest, tree orig)\n \n   if (orig_pi)\n     {\n+      dest_pi->pt_global_mem |= orig_pi->pt_global_mem;\n+\n       /* Notice that we never merge PT_MALLOC.  This attribute is only\n \t true if the pointer is the result of a malloc() call.\n \t Otherwise, we can end up in this situation:"}]}