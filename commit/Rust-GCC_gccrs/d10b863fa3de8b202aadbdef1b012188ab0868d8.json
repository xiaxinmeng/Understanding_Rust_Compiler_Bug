{"sha": "d10b863fa3de8b202aadbdef1b012188ab0868d8", "node_id": "C_kwDOANBUbNoAKGQxMGI4NjNmYTNkZThiMjAyYWFkYmRlZjFiMDEyMTg4YWIwODY4ZDg", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2021-10-25T13:59:35Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2021-11-15T17:52:07Z"}, "message": "libstdc++: Unordered containers merge re-use hash code\n\nWhen merging 2 unordered containers with same hasher we can re-use the hash code from\nthe cache if any.\n\nAlso in the context of the merge operation on multi-container use previous insert iterator as a hint\nfor the next insert.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/hashtable_policy.h:\n\t(_Hash_code_base<>::_M_hash_code(const _Hash&, const _Hash_node_value<_Value, true>&)): New.\n\t(_Hash_code_base<>::_M_hash_code<_H2>(const _H2&, const _Hash_node_value<>&)): New.\n\t* include/bits/hashtable.h (_Hashtable<>::_M_merge_unique): Use latter.\n\t(_Hashtable<>::_M_merge_multi): Likewise.\n\t* testsuite/23_containers/unordered_multiset/modifiers/merge.cc (test05): New test.\n\t* testsuite/23_containers/unordered_set/modifiers/merge.cc (test04): New test.", "tree": {"sha": "6f4311493baaa5509b1c2abe64dee5874baa1fe7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f4311493baaa5509b1c2abe64dee5874baa1fe7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d10b863fa3de8b202aadbdef1b012188ab0868d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d10b863fa3de8b202aadbdef1b012188ab0868d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d10b863fa3de8b202aadbdef1b012188ab0868d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d10b863fa3de8b202aadbdef1b012188ab0868d8/comments", "author": null, "committer": null, "parents": [{"sha": "f861ed8b29a5eb6164d1ddbcfbb6232dddae713f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f861ed8b29a5eb6164d1ddbcfbb6232dddae713f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f861ed8b29a5eb6164d1ddbcfbb6232dddae713f"}], "stats": {"total": 88, "additions": 84, "deletions": 4}, "files": [{"sha": "6e2d4c10cfe7e79184746a374d93e20e146cf508", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10b863fa3de8b202aadbdef1b012188ab0868d8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10b863fa3de8b202aadbdef1b012188ab0868d8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=d10b863fa3de8b202aadbdef1b012188ab0868d8", "patch": "@@ -1076,7 +1076,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    {\n \t      auto __pos = __i++;\n \t      const key_type& __k = _ExtractKey{}(*__pos);\n-\t      __hash_code __code = this->_M_hash_code(__k);\n+\t      __hash_code __code\n+\t\t= this->_M_hash_code(__src.hash_function(), *__pos._M_cur);\n \t      size_type __bkt = _M_bucket_index(__code);\n \t      if (_M_find_node(__bkt, __k, __code) == nullptr)\n \t\t{\n@@ -1099,14 +1100,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      node_type>, \"Node types are compatible\");\n \t  __glibcxx_assert(get_allocator() == __src.get_allocator());\n \n+\t  __node_ptr __hint = nullptr;\n \t  this->reserve(size() + __src.size());\n \t  for (auto __i = __src.cbegin(), __end = __src.cend(); __i != __end;)\n \t    {\n \t      auto __pos = __i++;\n-\t      const key_type& __k = _ExtractKey{}(*__pos);\n-\t      __hash_code __code = this->_M_hash_code(__k);\n+\t      __hash_code __code\n+\t\t= this->_M_hash_code(__src.hash_function(), *__pos._M_cur);\n \t      auto __nh = __src.extract(__pos);\n-\t      _M_insert_multi_node(nullptr, __code, __nh._M_ptr);\n+\t      __hint = _M_insert_multi_node(__hint, __code, __nh._M_ptr)._M_cur;\n \t      __nh._M_ptr = nullptr;\n \t    }\n \t}"}, {"sha": "0b5443fc1870848c2bb0f629b08564fabc75d100", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10b863fa3de8b202aadbdef1b012188ab0868d8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10b863fa3de8b202aadbdef1b012188ab0868d8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=d10b863fa3de8b202aadbdef1b012188ab0868d8", "patch": "@@ -1250,6 +1250,19 @@ namespace __detail\n \t  return _M_hash()(__k);\n \t}\n \n+      __hash_code\n+      _M_hash_code(const _Hash&,\n+\t\t   const _Hash_node_value<_Value, true>& __n) const\n+      { return __n._M_hash_code; }\n+\n+      // Compute hash code using _Hash as __n _M_hash_code, if present, was\n+      // computed using _H2.\n+      template<typename _H2>\n+\t__hash_code\n+\t_M_hash_code(const _H2&,\n+\t\tconst _Hash_node_value<_Value, __cache_hash_code>& __n) const\n+\t{ return _M_hash_code(_ExtractKey{}(__n._M_v())); }\n+\n       std::size_t\n       _M_bucket_index(__hash_code __c, std::size_t __bkt_count) const\n       { return _RangeHash{}(__c, __bkt_count); }"}, {"sha": "07b8a3441694fea1b528407d1c4600d4907d651f", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/modifiers/merge.cc", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10b863fa3de8b202aadbdef1b012188ab0868d8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fmodifiers%2Fmerge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10b863fa3de8b202aadbdef1b012188ab0868d8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fmodifiers%2Fmerge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fmodifiers%2Fmerge.cc?ref=d10b863fa3de8b202aadbdef1b012188ab0868d8", "patch": "@@ -17,6 +17,7 @@\n \n // { dg-do run { target c++17 } }\n \n+#include <string>\n #include <unordered_set>\n #include <algorithm>\n #include <testsuite_hooks.h>\n@@ -105,11 +106,32 @@ test04()\n   VERIFY( c2.empty() );\n }\n \n+void\n+test05()\n+{\n+  const std::unordered_multiset<std::string> c0{ \"abcd\", \"abcd\", \"efgh\", \"efgh\", \"ijkl\", \"ijkl\" };\n+  std::unordered_multiset<std::string> c1 = c0;\n+  std::unordered_set<std::string> c2( c0.begin(), c0.end() );\n+\n+  c1.merge(c2);\n+  VERIFY( c1.size() == (1.5 * c0.size()) );\n+  for (auto& i : c1)\n+    VERIFY( c1.count(i) == (1.5 * c0.count(i)) );\n+  VERIFY( c2.empty() );\n+\n+  c1.clear();\n+  c2.insert( c0.begin(), c0.end() );\n+  c1.merge(std::move(c2));\n+  VERIFY( c1.size() == (0.5 * c0.size()) );\n+  VERIFY( c2.empty() );\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n   test03();\n   test04();\n+  test05();\n }"}, {"sha": "0e184b10c60ec67c3cee1bed455fd3bb7a0924e8", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/modifiers/merge.cc", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10b863fa3de8b202aadbdef1b012188ab0868d8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmodifiers%2Fmerge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10b863fa3de8b202aadbdef1b012188ab0868d8/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmodifiers%2Fmerge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmodifiers%2Fmerge.cc?ref=d10b863fa3de8b202aadbdef1b012188ab0868d8", "patch": "@@ -17,6 +17,7 @@\n \n // { dg-do run { target c++17 } }\n \n+#include <string>\n #include <unordered_set>\n #include <algorithm>\n #include <testsuite_hooks.h>\n@@ -125,10 +126,52 @@ test03()\n   VERIFY( c2.empty() );\n }\n \n+void\n+test04()\n+{\n+  const std::unordered_set<std::string> c0{ \"abcd\", \"efgh\", \"ijkl\", };\n+  std::unordered_set<std::string> c1 = c0;\n+  std::unordered_multiset<std::string> c2( c0.begin(), c0.end() );\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( equal_elements(c2, c0) );\n+\n+  c1.clear();\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+\n+  c2.merge(c1);\n+  VERIFY( c1.empty() );\n+  VERIFY( equal_elements(c2, c0) );\n+\n+  c1 = c0;\n+  c2.merge(c1);\n+  VERIFY( c1.empty() );\n+  VERIFY( c2.size() == (2 * c0.size()) );\n+  VERIFY( c2.count(\"abcd\") == 2 );\n+  VERIFY( c2.count(\"efgh\") == 2 );\n+  VERIFY( c2.count(\"ijkl\") == 2 );\n+\n+  c1.merge(c2);\n+  VERIFY( c1 == c0 );\n+  VERIFY( equal_elements(c2, c0) );\n+\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( equal_elements(c2, c0) );\n+\n+  c1.clear();\n+  c1.merge(std::move(c2));\n+  VERIFY( c1 == c0 );\n+  VERIFY( c2.empty() );\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n   test03();\n+  test04();\n }"}]}