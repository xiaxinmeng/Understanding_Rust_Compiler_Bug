{"sha": "6ee2cc70024253d2670a4a317158b2a65251a1d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVlMmNjNzAwMjQyNTNkMjY3MGE0YTMxNzE1OGIyYTY1MjUxYTFkMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-30T16:19:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-30T16:19:59Z"}, "message": "Pass an ABI identifier to hard_regno_call_part_clobbered\n\nThis patch replaces the rtx_insn argument to\ntargetm.hard_regno_call_part_clobbered with an ABI identifier, since\ncall insns are now just one possible way of getting an ABI handle.\nThis in turn allows predefined_function_abi::initialize to do the\nright thing for non-default ABIs.\n\nThe horrible ?: in need_for_call_save_p goes away in a later patch,\nwith the series as a whole removing most direct calls to the hook in\nfavour of function_abi operations.\n\n2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* target.def (hard_regno_call_part_clobbered): Take an ABI\n\tidentifier instead of an rtx_insn.\n\t* doc/tm.texi: Regenerate.\n\t* hooks.h (hook_bool_insn_uint_mode_false): Delete.\n\t(hook_bool_uint_uint_mode_false): New function.\n\t* hooks.c (hook_bool_insn_uint_mode_false): Delete.\n\t(hook_bool_uint_uint_mode_false): New function.\n\t* config/aarch64/aarch64.c (aarch64_hard_regno_call_part_clobbered):\n\tTake an ABI identifier instead of an rtx_insn.\n\t* config/avr/avr.c (avr_hard_regno_call_part_clobbered): Likewise.\n\t* config/i386/i386.c (ix86_hard_regno_call_part_clobbered): Likewise.\n\t* config/mips/mips.c (mips_hard_regno_call_part_clobbered): Likewise.\n\t* config/pru/pru.c (pru_hard_regno_call_part_clobbered): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_hard_regno_call_part_clobbered):\n\tLikewise.\n\t* config/s390/s390.c (s390_hard_regno_call_part_clobbered): Likewise.\n\t* cselib.c: Include function-abi.h.\n\t(cselib_process_insn): Update call to\n\ttargetm.hard_regno_call_part_clobbered, using insn_callee_abi\n\tto get the appropriate ABI identifier.\n\t* function-abi.cc (predefined_function_abi::initialize): Update call\n\tto targetm.hard_regno_call_part_clobbered.\n\t* ira-conflicts.c (ira_build_conflicts): Likewise.\n\t* ira-costs.c (ira_tune_allocno_costs): Likewise.\n\t* lra-constraints.c: Include function-abi.h.\n\t(need_for_call_save_p): Update call to\n\ttargetm.hard_regno_call_part_clobbered, using insn_callee_abi\n\tto get the appropriate ABI identifier.\n\t* lra-lives.c (check_pseudos_live_through_calls): Likewise.\n\t* regcprop.c (copyprop_hardreg_forward_1): Update call\n\tto targetm.hard_regno_call_part_clobbered.\n\t* reginfo.c (choose_hard_reg_mode): Likewise.\n\t* regrename.c (check_new_reg_p): Likewise.\n\t* reload.c (find_equiv_reg): Likewise.\n\t* reload1.c (emit_reload_insns): Likewise.\n\t* sched-deps.c: Include function-abi.h.\n\t(deps_analyze_insn): Update call to\n\ttargetm.hard_regno_call_part_clobbered, using insn_callee_abi\n\tto get the appropriate ABI identifier.\n\t* sel-sched.c (init_regs_for_mode, mark_unavailable_hard_regs): Update\n\tcall to targetm.hard_regno_call_part_clobbered.\n\t* targhooks.c (default_dwarf_frame_reg_mode): Likewise.\n\nFrom-SVN: r276311", "tree": {"sha": "7ceef0efbbe69d1fadfdd5ab9b202832d6239868", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ceef0efbbe69d1fadfdd5ab9b202832d6239868"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ee2cc70024253d2670a4a317158b2a65251a1d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ee2cc70024253d2670a4a317158b2a65251a1d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ee2cc70024253d2670a4a317158b2a65251a1d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ee2cc70024253d2670a4a317158b2a65251a1d1/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2a2e3a0dfcbe0861915f421d11b828f0c35023f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a2e3a0dfcbe0861915f421d11b828f0c35023f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a2e3a0dfcbe0861915f421d11b828f0c35023f0"}], "stats": {"total": 196, "additions": 132, "deletions": 64}, "files": [{"sha": "59bfeb2b66fa018a94a945a92f5286de744dde0d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -1,3 +1,48 @@\n+2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* target.def (hard_regno_call_part_clobbered): Take an ABI\n+\tidentifier instead of an rtx_insn.\n+\t* doc/tm.texi: Regenerate.\n+\t* hooks.h (hook_bool_insn_uint_mode_false): Delete.\n+\t(hook_bool_uint_uint_mode_false): New function.\n+\t* hooks.c (hook_bool_insn_uint_mode_false): Delete.\n+\t(hook_bool_uint_uint_mode_false): New function.\n+\t* config/aarch64/aarch64.c (aarch64_hard_regno_call_part_clobbered):\n+\tTake an ABI identifier instead of an rtx_insn.\n+\t* config/avr/avr.c (avr_hard_regno_call_part_clobbered): Likewise.\n+\t* config/i386/i386.c (ix86_hard_regno_call_part_clobbered): Likewise.\n+\t* config/mips/mips.c (mips_hard_regno_call_part_clobbered): Likewise.\n+\t* config/pru/pru.c (pru_hard_regno_call_part_clobbered): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_hard_regno_call_part_clobbered):\n+\tLikewise.\n+\t* config/s390/s390.c (s390_hard_regno_call_part_clobbered): Likewise.\n+\t* cselib.c: Include function-abi.h.\n+\t(cselib_process_insn): Update call to\n+\ttargetm.hard_regno_call_part_clobbered, using insn_callee_abi\n+\tto get the appropriate ABI identifier.\n+\t* function-abi.cc (predefined_function_abi::initialize): Update call\n+\tto targetm.hard_regno_call_part_clobbered.\n+\t* ira-conflicts.c (ira_build_conflicts): Likewise.\n+\t* ira-costs.c (ira_tune_allocno_costs): Likewise.\n+\t* lra-constraints.c: Include function-abi.h.\n+\t(need_for_call_save_p): Update call to\n+\ttargetm.hard_regno_call_part_clobbered, using insn_callee_abi\n+\tto get the appropriate ABI identifier.\n+\t* lra-lives.c (check_pseudos_live_through_calls): Likewise.\n+\t* regcprop.c (copyprop_hardreg_forward_1): Update call\n+\tto targetm.hard_regno_call_part_clobbered.\n+\t* reginfo.c (choose_hard_reg_mode): Likewise.\n+\t* regrename.c (check_new_reg_p): Likewise.\n+\t* reload.c (find_equiv_reg): Likewise.\n+\t* reload1.c (emit_reload_insns): Likewise.\n+\t* sched-deps.c: Include function-abi.h.\n+\t(deps_analyze_insn): Update call to\n+\ttargetm.hard_regno_call_part_clobbered, using insn_callee_abi\n+\tto get the appropriate ABI identifier.\n+\t* sel-sched.c (init_regs_for_mode, mark_unavailable_hard_regs): Update\n+\tcall to targetm.hard_regno_call_part_clobbered.\n+\t* targhooks.c (default_dwarf_frame_reg_mode): Likewise.\n+\n 2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/i386/i386.c: Include function-abi.h."}, {"sha": "ca4c183d89d10ce512b29444b31d0f8687580bda", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -1910,12 +1910,13 @@ aarch64_insn_callee_abi (const rtx_insn *insn)\n    clobbers the top 64 bits when restoring the bottom 64 bits.  */\n \n static bool\n-aarch64_hard_regno_call_part_clobbered (rtx_insn *insn, unsigned int regno,\n+aarch64_hard_regno_call_part_clobbered (unsigned int abi_id,\n+\t\t\t\t\tunsigned int regno,\n \t\t\t\t\tmachine_mode mode)\n {\n   if (FP_REGNUM_P (regno))\n     {\n-      bool simd_p = insn && CALL_P (insn) && aarch64_simd_call_p (insn);\n+      bool simd_p = (abi_id == ARM_PCS_SIMD);\n       poly_int64 per_register_size = GET_MODE_SIZE (mode);\n       unsigned int nregs = hard_regno_nregs (regno, mode);\n       if (nregs > 1)"}, {"sha": "3ccff8ebedc4633373c6c3951a93977fabff7ef8", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -12164,8 +12164,8 @@ avr_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n /* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  */\n \n static bool\n-avr_hard_regno_call_part_clobbered (rtx_insn *insn ATTRIBUTE_UNUSED,\n-\t\t\t\t    unsigned regno, machine_mode mode)\n+avr_hard_regno_call_part_clobbered (unsigned, unsigned regno,\n+\t\t\t\t    machine_mode mode)\n {\n   /* FIXME: This hook gets called with MODE:REGNO combinations that don't\n         represent valid hard registers like, e.g. HI:29.  Returning TRUE"}, {"sha": "8af4bc581e176bfb7fa773e1ce6b9426bb558190", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -18794,8 +18794,8 @@ ix86_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n    the low 16 bytes are saved.  */\n \n static bool\n-ix86_hard_regno_call_part_clobbered (rtx_insn *insn ATTRIBUTE_UNUSED,\n-\t\t\t\t     unsigned int regno, machine_mode mode)\n+ix86_hard_regno_call_part_clobbered (unsigned int, unsigned int regno,\n+\t\t\t\t     machine_mode mode)\n {\n   return SSE_REGNO_P (regno) && GET_MODE_SIZE (mode) > 16;\n }"}, {"sha": "91dd94bf4e6e0fb81a3c2c2d0ac39467370a31ff", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -12928,8 +12928,8 @@ mips_hard_regno_scratch_ok (unsigned int regno)\n    registers with MODE > 64 bits are part clobbered too.  */\n \n static bool\n-mips_hard_regno_call_part_clobbered (rtx_insn *insn ATTRIBUTE_UNUSED,\n-\t\t\t\t     unsigned int regno, machine_mode mode)\n+mips_hard_regno_call_part_clobbered (unsigned int, unsigned int regno,\n+\t\t\t\t     machine_mode mode)\n {\n   if (TARGET_FLOATXX\n       && hard_regno_nregs (regno, mode) == 1"}, {"sha": "16d1451262e9074252f15c129275209cef2ad103", "filename": "gcc/config/pru/pru.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fconfig%2Fpru%2Fpru.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fconfig%2Fpru%2Fpru.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -559,8 +559,8 @@ pru_hard_regno_scratch_ok (unsigned int regno)\n /* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  */\n \n static bool\n-pru_hard_regno_call_part_clobbered (rtx_insn *insn ATTRIBUTE_UNUSED,\n-\t\t\t\t    unsigned regno, machine_mode mode)\n+pru_hard_regno_call_part_clobbered (unsigned, unsigned regno,\n+\t\t\t\t    machine_mode mode)\n {\n   HARD_REG_SET caller_saved_set;\n   HARD_REG_SET callee_saved_set;"}, {"sha": "330e2490301950ab0d9ae61571d20468a6d3787b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -1946,8 +1946,8 @@ rs6000_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n /* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  */\n \n static bool\n-rs6000_hard_regno_call_part_clobbered (rtx_insn *insn ATTRIBUTE_UNUSED,\n-\t\t\t\t       unsigned int regno, machine_mode mode)\n+rs6000_hard_regno_call_part_clobbered (unsigned int, unsigned int regno,\n+\t\t\t\t       machine_mode mode)\n {\n   if (TARGET_32BIT\n       && TARGET_POWERPC64"}, {"sha": "1764c3450e60b3586a401f3a213bf9018a24a0ad", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -10297,8 +10297,8 @@ s390_hard_regno_scratch_ok (unsigned int regno)\n    bytes are saved across calls, however.  */\n \n static bool\n-s390_hard_regno_call_part_clobbered (rtx_insn *insn ATTRIBUTE_UNUSED,\n-\t\t\t\t     unsigned int regno, machine_mode mode)\n+s390_hard_regno_call_part_clobbered (unsigned int, unsigned int regno,\n+\t\t\t\t     machine_mode mode)\n {\n   if (!TARGET_64BIT\n       && TARGET_ZARCH"}, {"sha": "5de14a07317fd4f8c17d641a7f62057ad37d8197", "filename": "gcc/cselib.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dumpfile.h\"\n #include \"cselib.h\"\n #include \"params.h\"\n+#include \"function-abi.h\"\n \n /* A list of cselib_val structures.  */\n struct elt_list\n@@ -2765,11 +2766,13 @@ cselib_process_insn (rtx_insn *insn)\n      memory.  */\n   if (CALL_P (insn))\n     {\n+      function_abi callee_abi = insn_callee_abi (insn);\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (call_used_or_fixed_reg_p (i)\n \t    || (REG_VALUES (i) && REG_VALUES (i)->elt\n \t\t&& (targetm.hard_regno_call_part_clobbered\n-\t\t    (insn, i, GET_MODE (REG_VALUES (i)->elt->val_rtx)))))\n+\t\t    (callee_abi.id (), i,\n+\t\t     GET_MODE (REG_VALUES (i)->elt->val_rtx)))))\n \t  cselib_invalidate_regno (i, reg_raw_mode[i]);\n \n       /* Since it is not clear how cselib is going to be used, be"}, {"sha": "419c706cb9e8fd73f1fd715689595fc63effbd12", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -1919,14 +1919,23 @@ interoperability between several ABIs in the same translation unit.\n @cindex call-used register\n @cindex call-clobbered register\n @cindex call-saved register\n-@deftypefn {Target Hook} bool TARGET_HARD_REGNO_CALL_PART_CLOBBERED (rtx_insn *@var{insn}, unsigned int @var{regno}, machine_mode @var{mode})\n-This hook should return true if @var{regno} is partly call-saved and\n-partly call-clobbered, and if a value of mode @var{mode} would be partly\n-clobbered by call instruction @var{insn}.  If @var{insn} is NULL then it\n-should return true if any call could partly clobber the register.\n-For example, if the low 32 bits of @var{regno} are preserved across a call\n-but higher bits are clobbered, this hook should return true for a 64-bit\n-mode but false for a 32-bit mode.\n+@deftypefn {Target Hook} bool TARGET_HARD_REGNO_CALL_PART_CLOBBERED (unsigned int @var{abi_id}, unsigned int @var{regno}, machine_mode @var{mode})\n+ABIs usually specify that calls must preserve the full contents\n+of a particular register, or that calls can alter any part of a\n+particular register.  This information is captured by the target macro\n+@code{CALL_REALLY_USED_REGISTERS}.  However, some ABIs specify that calls\n+must preserve certain bits of a particular register but can alter others.\n+This hook should return true if this applies to at least one of the\n+registers in @samp{(reg:@var{mode} @var{regno})}, and if as a result the\n+call would alter part of the @var{mode} value.  For example, if a call\n+preserves the low 32 bits of a 64-bit hard register @var{regno} but can\n+clobber the upper 32 bits, this hook should return true for a 64-bit mode\n+but false for a 32-bit mode.\n+\n+The value of @var{abi_id} comes from the @code{predefined_function_abi}\n+structure that describes the ABI of the call; see the definition of the\n+structure for more details.  If (as is usual) the target uses the same ABI\n+for all functions in a translation unit, @var{abi_id} is always 0.\n \n The default implementation returns false, which is correct\n for targets that don't have partly call-clobbered registers."}, {"sha": "1d1ac9a25899936d383160935807e50236206ccc", "filename": "gcc/function-abi.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Ffunction-abi.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Ffunction-abi.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction-abi.cc?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -50,7 +50,7 @@ predefined_function_abi::initialize (unsigned int id,\n \n      If the ABI specifies that part of a hard register R is call-clobbered,\n      we should be able to find a single-register mode M for which\n-     targetm.hard_regno_call_part_clobbered (NULL, R, M) is true.\n+     targetm.hard_regno_call_part_clobbered (m_id, R, M) is true.\n      In other words, it shouldn't be the case that R can hold all\n      single-register modes across a call, but can't hold part of\n      a multi-register mode.\n@@ -66,7 +66,7 @@ predefined_function_abi::initialize (unsigned int id,\n       for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n \tif (targetm.hard_regno_mode_ok (regno, mode)\n \t    && hard_regno_nregs (regno, mode) == 1\n-\t    && targetm.hard_regno_call_part_clobbered (NULL, regno, mode))\n+\t    && targetm.hard_regno_call_part_clobbered (m_id, regno, mode))\n \t  SET_HARD_REG_BIT (m_full_and_partial_reg_clobbers, regno);\n     }\n \n@@ -89,7 +89,7 @@ predefined_function_abi::initialize (unsigned int id,\n       for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n \tif (targetm.hard_regno_mode_ok (regno, mode)\n \t    && !overlaps_hard_reg_set_p (m_full_reg_clobbers, mode, regno)\n-\t    && !targetm.hard_regno_call_part_clobbered (NULL, regno, mode))\n+\t    && !targetm.hard_regno_call_part_clobbered (m_id, regno, mode))\n \t  remove_from_hard_reg_set (&m_mode_clobbers[i], mode, regno);\n     }\n \n@@ -104,7 +104,7 @@ predefined_function_abi::initialize (unsigned int id,\n \tfor (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n \t  if (targetm.hard_regno_mode_ok (regno, mode)\n \t      && !overlaps_hard_reg_set_p (m_full_reg_clobbers, mode, regno)\n-\t      && targetm.hard_regno_call_part_clobbered (NULL, regno, mode))\n+\t      && targetm.hard_regno_call_part_clobbered (m_id, regno, mode))\n \t    gcc_assert (overlaps_hard_reg_set_p (all_clobbers, mode, regno)\n \t\t\t&& overlaps_hard_reg_set_p (m_mode_clobbers[i],\n \t\t\t\t\t\t    mode, regno));"}, {"sha": "a9a87de3cdbf85059d25cda38aa677917c907748", "filename": "gcc/hooks.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -140,9 +140,8 @@ hook_bool_puint64_puint64_true (poly_uint64, poly_uint64)\n   return true;\n }\n \n-/* Generic hook that takes (unsigned int, machine_mode) and returns false.  */\n bool\n-hook_bool_insn_uint_mode_false (rtx_insn *, unsigned int, machine_mode)\n+hook_bool_uint_uint_mode_false (unsigned int, unsigned int, machine_mode)\n {\n   return false;\n }"}, {"sha": "7cfe91d12dfdc3d01307b5b7b81364912668195c", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -40,7 +40,7 @@ extern bool hook_bool_const_rtx_insn_const_rtx_insn_true (const rtx_insn *,\n extern bool hook_bool_mode_uhwi_false (machine_mode,\n \t\t\t\t       unsigned HOST_WIDE_INT);\n extern bool hook_bool_puint64_puint64_true (poly_uint64, poly_uint64);\n-extern bool hook_bool_insn_uint_mode_false (rtx_insn *, unsigned int,\n+extern bool hook_bool_uint_uint_mode_false (unsigned int, unsigned int,\n \t\t\t\t\t    machine_mode);\n extern bool hook_bool_uint_mode_true (unsigned int, machine_mode);\n extern bool hook_bool_tree_false (tree);"}, {"sha": "6ceed5333292c68ad90a34925937a07ac6b2f51e", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -838,7 +838,7 @@ ira_build_conflicts (void)\n \t\t regs must conflict with them.  */\n \t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t\tif (!TEST_HARD_REG_BIT (call_used_or_fixed_regs, regno)\n-\t\t    && targetm.hard_regno_call_part_clobbered (NULL, regno,\n+\t\t    && targetm.hard_regno_call_part_clobbered (0, regno,\n \t\t\t\t\t\t\t       obj_mode))\n \t\t  {\n \t\t    SET_HARD_REG_BIT (OBJECT_CONFLICT_HARD_REGS (obj), regno);"}, {"sha": "2e7e10ac903a6bed9d84ad330a007ee4f5f477e8", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -2381,7 +2381,7 @@ ira_tune_allocno_costs (void)\n \t\t\t\t\t\t   *crossed_calls_clobber_regs)\n \t\t  && (ira_hard_reg_set_intersection_p (regno, mode,\n \t\t\t\t\t\t       call_used_or_fixed_regs)\n-\t\t      || targetm.hard_regno_call_part_clobbered (NULL, regno,\n+\t\t      || targetm.hard_regno_call_part_clobbered (0, regno,\n \t\t\t\t\t\t\t\t mode)))\n \t\tcost += (ALLOCNO_CALL_FREQ (a)\n \t\t\t * (ira_memory_move_cost[mode][rclass][0]"}, {"sha": "43fe1074788486ff03ea948320ebfefdbe877ea2", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -131,6 +131,7 @@\n #include \"lra.h\"\n #include \"lra-int.h\"\n #include \"print-rtl.h\"\n+#include \"function-abi.h\"\n \n /* Value of LRA_CURR_RELOAD_NUM at the beginning of BB of the current\n    insn.  Remember that LRA_CURR_RELOAD_NUM is the number of emitted\n@@ -5442,7 +5443,8 @@ need_for_call_save_p (int regno)\n \t       : call_used_or_fixed_regs,\n \t       PSEUDO_REGNO_MODE (regno), reg_renumber[regno])\n \t      || (targetm.hard_regno_call_part_clobbered\n-\t\t  (lra_reg_info[regno].call_insn,\n+\t\t  (lra_reg_info[regno].call_insn\n+\t\t   ? insn_callee_abi (lra_reg_info[regno].call_insn).id () : 0,\n \t\t   reg_renumber[regno], PSEUDO_REGNO_MODE (regno)))));\n }\n "}, {"sha": "40e9f66f3b11a4a57a1f270e2f037024b05cb675", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -594,7 +594,7 @@ check_pseudos_live_through_calls (int regno,\n   if (! sparseset_bit_p (pseudos_live_through_calls, regno))\n     return;\n \n-  gcc_assert (call_insn && CALL_P (call_insn));\n+  function_abi callee_abi = insn_callee_abi (call_insn);\n   old_call_insn = lra_reg_info[regno].call_insn;\n   if (!old_call_insn\n       || (targetm.return_call_with_max_clobbers\n@@ -606,7 +606,7 @@ check_pseudos_live_through_calls (int regno,\n   lra_reg_info[regno].conflict_hard_regs |= last_call_used_reg_set;\n \n   for (hr = 0; HARD_REGISTER_NUM_P (hr); hr++)\n-    if (targetm.hard_regno_call_part_clobbered (call_insn, hr,\n+    if (targetm.hard_regno_call_part_clobbered (callee_abi.id (), hr,\n \t\t\t\t\t\tPSEUDO_REGNO_MODE (regno)))\n       add_to_hard_reg_set (&lra_reg_info[regno].conflict_hard_regs,\n \t\t\t   PSEUDO_REGNO_MODE (regno), hr);"}, {"sha": "0bdd6b918150d2591b5c33c34d32b9652c4d12dc", "filename": "gcc/regcprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -1057,7 +1057,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t    if ((callee_abi.clobbers_full_reg_p (regno)\n \t\t || (targetm.hard_regno_call_part_clobbered\n-\t\t     (insn, regno, vd->e[regno].mode)))\n+\t\t     (callee_abi.id (), regno, vd->e[regno].mode)))\n \t\t&& (regno < set_regno || regno >= set_regno + set_nregs))\n \t      kill_value_regno (regno, 1, vd);\n "}, {"sha": "f084c0e430680850fee0e165c3e6ac5a574a0326", "filename": "gcc/reginfo.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -568,31 +568,31 @@ choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n     if (hard_regno_nregs (regno, mode) == nregs\n \t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n-\t    || !targetm.hard_regno_call_part_clobbered (NULL, regno, mode))\n+\t    || !targetm.hard_regno_call_part_clobbered (0, regno, mode))\n \t&& maybe_gt (GET_MODE_SIZE (mode), GET_MODE_SIZE (found_mode)))\n       found_mode = mode;\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_FLOAT)\n     if (hard_regno_nregs (regno, mode) == nregs\n \t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n-\t    || !targetm.hard_regno_call_part_clobbered (NULL, regno, mode))\n+\t    || !targetm.hard_regno_call_part_clobbered (0, regno, mode))\n \t&& maybe_gt (GET_MODE_SIZE (mode), GET_MODE_SIZE (found_mode)))\n       found_mode = mode;\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_FLOAT)\n     if (hard_regno_nregs (regno, mode) == nregs\n \t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n-\t    || !targetm.hard_regno_call_part_clobbered (NULL, regno, mode))\n+\t    || !targetm.hard_regno_call_part_clobbered (0, regno, mode))\n \t&& maybe_gt (GET_MODE_SIZE (mode), GET_MODE_SIZE (found_mode)))\n       found_mode = mode;\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_INT)\n     if (hard_regno_nregs (regno, mode) == nregs\n \t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n-\t    || !targetm.hard_regno_call_part_clobbered (NULL, regno, mode))\n+\t    || !targetm.hard_regno_call_part_clobbered (0, regno, mode))\n \t&& maybe_gt (GET_MODE_SIZE (mode), GET_MODE_SIZE (found_mode)))\n       found_mode = mode;\n \n@@ -606,7 +606,7 @@ choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n       if (hard_regno_nregs (regno, mode) == nregs\n \t  && targetm.hard_regno_mode_ok (regno, mode)\n \t  && (!call_saved\n-\t      || !targetm.hard_regno_call_part_clobbered (NULL, regno, mode)))\n+\t      || !targetm.hard_regno_call_part_clobbered (0, regno, mode)))\n \treturn mode;\n     }\n "}, {"sha": "6a2442bdaa7e981c9f6eaf87a9d8092f224ef41a", "filename": "gcc/regrename.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -339,9 +339,9 @@ check_new_reg_p (int reg ATTRIBUTE_UNUSED, int new_reg,\n \t && ! DEBUG_INSN_P (tmp->insn))\n \t|| (this_head->need_caller_save_reg\n \t    && ! (targetm.hard_regno_call_part_clobbered\n-\t\t  (NULL, reg, GET_MODE (*tmp->loc)))\n+\t\t  (0, reg, GET_MODE (*tmp->loc)))\n \t    && (targetm.hard_regno_call_part_clobbered\n-\t\t(NULL, new_reg, GET_MODE (*tmp->loc)))))\n+\t\t(0, new_reg, GET_MODE (*tmp->loc)))))\n       return false;\n \n   return true;"}, {"sha": "b7601307f82f60dca6165dfc3c2294e660b17d3d", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -6912,14 +6912,14 @@ find_equiv_reg (rtx goal, rtx_insn *insn, enum reg_class rclass, int other,\n \t  if (regno >= 0 && regno < FIRST_PSEUDO_REGISTER)\n \t    for (i = 0; i < nregs; ++i)\n \t      if (call_used_or_fixed_reg_p (regno + i)\n-\t\t  || targetm.hard_regno_call_part_clobbered (NULL, regno + i,\n+\t\t  || targetm.hard_regno_call_part_clobbered (0, regno + i,\n \t\t\t\t\t\t\t     mode))\n \t\treturn 0;\n \n \t  if (valueno >= 0 && valueno < FIRST_PSEUDO_REGISTER)\n \t    for (i = 0; i < valuenregs; ++i)\n \t      if (call_used_or_fixed_reg_p (valueno + i)\n-\t\t  || targetm.hard_regno_call_part_clobbered (NULL, valueno + i,\n+\t\t  || targetm.hard_regno_call_part_clobbered (0, valueno + i,\n \t\t\t\t\t\t\t     mode))\n \t\treturn 0;\n \t}"}, {"sha": "39dff6a32b2dc805bcd1f8e7055b56c999e0064a", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -8193,8 +8193,7 @@ emit_reload_insns (class insn_chain *chain)\n \t\t\t   : out_regno + k);\n \t\t      reg_reloaded_insn[regno + k] = insn;\n \t\t      SET_HARD_REG_BIT (reg_reloaded_valid, regno + k);\n-\t\t      if (targetm.hard_regno_call_part_clobbered (NULL,\n-\t\t\t\t\t\t\t\t  regno + k,\n+\t\t      if (targetm.hard_regno_call_part_clobbered (0, regno + k,\n \t\t\t\t\t\t\t\t  mode))\n \t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n \t\t\t\t\t  regno + k);\n@@ -8274,8 +8273,7 @@ emit_reload_insns (class insn_chain *chain)\n \t\t\t   : in_regno + k);\n \t\t      reg_reloaded_insn[regno + k] = insn;\n \t\t      SET_HARD_REG_BIT (reg_reloaded_valid, regno + k);\n-\t\t      if (targetm.hard_regno_call_part_clobbered (NULL,\n-\t\t\t\t\t\t\t\t  regno + k,\n+\t\t      if (targetm.hard_regno_call_part_clobbered (0, regno + k,\n \t\t\t\t\t\t\t\t  mode))\n \t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n \t\t\t\t\t  regno + k);\n@@ -8391,7 +8389,7 @@ emit_reload_insns (class insn_chain *chain)\n \t\t      CLEAR_HARD_REG_BIT (reg_reloaded_dead, src_regno + k);\n \t\t      SET_HARD_REG_BIT (reg_reloaded_valid, src_regno + k);\n \t\t      if (targetm.hard_regno_call_part_clobbered\n-\t\t\t  (NULL, src_regno + k, mode))\n+\t\t\t  (0, src_regno + k, mode))\n \t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n \t\t\t\t\t  src_regno + k);\n \t\t      else"}, {"sha": "87d0791374ed6322fc4c97ec8655bcecc1782a58", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"sched-int.h\"\n #include \"params.h\"\n #include \"cselib.h\"\n+#include \"function-abi.h\"\n \n #ifdef INSN_SCHEDULING\n \n@@ -3723,6 +3724,7 @@ deps_analyze_insn (class deps_desc *deps, rtx_insn *insn)\n         }\n       else\n         {\n+\t  function_abi callee_abi = insn_callee_abi (insn);\n           for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n             /* A call may read and modify global register variables.  */\n             if (global_regs[i])\n@@ -3734,8 +3736,8 @@ deps_analyze_insn (class deps_desc *deps, rtx_insn *insn)\n              Since we only have a choice between 'might be clobbered'\n              and 'definitely not clobbered', we must include all\n              partly call-clobbered registers here.  */\n-\t    else if (targetm.hard_regno_call_part_clobbered (insn, i,\n-\t\t\t\t\t\t\t     reg_raw_mode[i])\n+\t    else if (targetm.hard_regno_call_part_clobbered\n+\t\t     (callee_abi.id (), i, reg_raw_mode[i])\n                      || TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n               SET_REGNO_REG_SET (reg_pending_clobbers, i);\n           /* We don't know what set of fixed registers might be used"}, {"sha": "bf370b5a5d85ac8707b665282a45f85f7a52a0a0", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -1102,7 +1102,7 @@ init_regs_for_mode (machine_mode mode)\n       if (i >= 0)\n         continue;\n \n-      if (targetm.hard_regno_call_part_clobbered (NULL, cur_reg, mode))\n+      if (targetm.hard_regno_call_part_clobbered (0, cur_reg, mode))\n         SET_HARD_REG_BIT (sel_hrd.regs_for_call_clobbered[mode],\n                           cur_reg);\n \n@@ -1247,7 +1247,7 @@ mark_unavailable_hard_regs (def_t def, struct reg_rename *reg_rename_p,\n \n   /* Exclude registers that are partially call clobbered.  */\n   if (def->crosses_call\n-      && !targetm.hard_regno_call_part_clobbered (NULL, regno, mode))\n+      && !targetm.hard_regno_call_part_clobbered (0, regno, mode))\n     reg_rename_p->available_for_renaming\n       &= ~sel_hrd.regs_for_call_clobbered[mode];\n "}, {"sha": "3bdbb8d86bab30cddc75e08257b77a627f2f0705", "filename": "gcc/target.def", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -5814,18 +5814,27 @@ The default version of this hook always returns @code{true}.\",\n \n DEFHOOK\n (hard_regno_call_part_clobbered,\n- \"This hook should return true if @var{regno} is partly call-saved and\\n\\\n-partly call-clobbered, and if a value of mode @var{mode} would be partly\\n\\\n-clobbered by call instruction @var{insn}.  If @var{insn} is NULL then it\\n\\\n-should return true if any call could partly clobber the register.\\n\\\n-For example, if the low 32 bits of @var{regno} are preserved across a call\\n\\\n-but higher bits are clobbered, this hook should return true for a 64-bit\\n\\\n-mode but false for a 32-bit mode.\\n\\\n+ \"ABIs usually specify that calls must preserve the full contents\\n\\\n+of a particular register, or that calls can alter any part of a\\n\\\n+particular register.  This information is captured by the target macro\\n\\\n+@code{CALL_REALLY_USED_REGISTERS}.  However, some ABIs specify that calls\\n\\\n+must preserve certain bits of a particular register but can alter others.\\n\\\n+This hook should return true if this applies to at least one of the\\n\\\n+registers in @samp{(reg:@var{mode} @var{regno})}, and if as a result the\\n\\\n+call would alter part of the @var{mode} value.  For example, if a call\\n\\\n+preserves the low 32 bits of a 64-bit hard register @var{regno} but can\\n\\\n+clobber the upper 32 bits, this hook should return true for a 64-bit mode\\n\\\n+but false for a 32-bit mode.\\n\\\n+\\n\\\n+The value of @var{abi_id} comes from the @code{predefined_function_abi}\\n\\\n+structure that describes the ABI of the call; see the definition of the\\n\\\n+structure for more details.  If (as is usual) the target uses the same ABI\\n\\\n+for all functions in a translation unit, @var{abi_id} is always 0.\\n\\\n \\n\\\n The default implementation returns false, which is correct\\n\\\n for targets that don't have partly call-clobbered registers.\",\n- bool, (rtx_insn *insn, unsigned int regno, machine_mode mode),\n- hook_bool_insn_uint_mode_false)\n+ bool, (unsigned int abi_id, unsigned int regno, machine_mode mode),\n+ hook_bool_uint_uint_mode_false)\n \n DEFHOOK\n (return_call_with_max_clobbers,"}, {"sha": "6105137aad5a35f616fc3bbfb1972ad73c4416fc", "filename": "gcc/targhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ee2cc70024253d2670a4a317158b2a65251a1d1/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=6ee2cc70024253d2670a4a317158b2a65251a1d1", "patch": "@@ -1928,7 +1928,7 @@ default_dwarf_frame_reg_mode (int regno)\n {\n   machine_mode save_mode = reg_raw_mode[regno];\n \n-  if (targetm.hard_regno_call_part_clobbered (NULL, regno, save_mode))\n+  if (targetm.hard_regno_call_part_clobbered (0, regno, save_mode))\n     save_mode = choose_hard_reg_mode (regno, 1, true);\n   return save_mode;\n }"}]}