{"sha": "dd5797cc36028b51596c88d0b5ecc1f0a2902488", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ1Nzk3Y2MzNjAyOGI1MTU5NmM4OGQwYjVlY2MxZjBhMjkwMjQ4OA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-10-31T06:03:24Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-10-31T06:03:24Z"}, "message": "re PR fortran/29387 (ICE on character array function of variable length)\n\n2006-10-31  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/29387\n\t* trans-intrinsic.c (gfc_conv_intrinsic_len): Rearrange to have\n\ta specific case for EXPR_VARIABLE and, in default, build an ss\n\tto call gfc_conv_expr_descriptor for array expressions..\n\n\tPR fortran/29490\n\t* trans-expr.c (gfc_set_interface_mapping_bounds): In the case\n\tthat GFC_TYPE_ARRAY_LBOUND is not available, use descriptor\n\tvalues for it and GFC_TYPE_ARRAY_UBOUND.\n\n\tPR fortran/29641\n\t* trans-types.c (gfc_get_derived_type): If the derived type\n\tnamespace has neither a parent nor a proc_name, set NULL for\n\tthe search namespace.\n\n\n2006-10-31  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/29387\n\t* gfortran.dg/intrinsic_actual_2.f90: New test.\n\n\tPR fortran/29490\n\t* gfortran.dg/actual_array_interface_1.f90: New test.\n\n\tPR fortran/29641\n\t* gfortran.dg/used_types_11.f90: New test.\n\nFrom-SVN: r118220", "tree": {"sha": "a2f3d9751ac9c0b7ae6f8b76727cb0d066e270f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2f3d9751ac9c0b7ae6f8b76727cb0d066e270f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd5797cc36028b51596c88d0b5ecc1f0a2902488", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd5797cc36028b51596c88d0b5ecc1f0a2902488", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd5797cc36028b51596c88d0b5ecc1f0a2902488", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd5797cc36028b51596c88d0b5ecc1f0a2902488/comments", "author": null, "committer": null, "parents": [{"sha": "e5c18c3c298de538f6a9acec3120b63d830dc307", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5c18c3c298de538f6a9acec3120b63d830dc307", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5c18c3c298de538f6a9acec3120b63d830dc307"}], "stats": {"total": 184, "additions": 151, "deletions": 33}, "files": [{"sha": "3fd834c78ad6f01106946bc0e833fe482ee2799a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5797cc36028b51596c88d0b5ecc1f0a2902488/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5797cc36028b51596c88d0b5ecc1f0a2902488/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=dd5797cc36028b51596c88d0b5ecc1f0a2902488", "patch": "@@ -1,3 +1,20 @@\n+2006-10-31  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/29387\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_len): Rearrange to have\n+\ta specific case for EXPR_VARIABLE and, in default, build an ss\n+\tto call gfc_conv_expr_descriptor for array expressions..\n+\n+\tPR fortran/29490\n+\t* trans-expr.c (gfc_set_interface_mapping_bounds): In the case\n+\tthat GFC_TYPE_ARRAY_LBOUND is not available, use descriptor\n+\tvalues for it and GFC_TYPE_ARRAY_UBOUND.\n+\n+\tPR fortran/29641\n+\t* trans-types.c (gfc_get_derived_type): If the derived type\n+\tnamespace has neither a parent nor a proc_name, set NULL for\n+\tthe search namespace.\n+\n 2006-10-30  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/29452"}, {"sha": "f4fcea5d35b61008b1c458f1e442ca6dd5dcba30", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5797cc36028b51596c88d0b5ecc1f0a2902488/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5797cc36028b51596c88d0b5ecc1f0a2902488/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=dd5797cc36028b51596c88d0b5ecc1f0a2902488", "patch": "@@ -1296,10 +1296,17 @@ gfc_set_interface_mapping_bounds (stmtblock_t * block, tree type, tree desc)\n   offset = gfc_index_zero_node;\n   for (n = 0; n < GFC_TYPE_ARRAY_RANK (type); n++)\n     {\n+      dim = gfc_rank_cst[n];\n       GFC_TYPE_ARRAY_STRIDE (type, n) = gfc_conv_array_stride (desc, n);\n-      if (GFC_TYPE_ARRAY_UBOUND (type, n) == NULL_TREE)\n+      if (GFC_TYPE_ARRAY_LBOUND (type, n) == NULL_TREE)\n+\t{\n+\t  GFC_TYPE_ARRAY_LBOUND (type, n)\n+\t\t= gfc_conv_descriptor_lbound (desc, dim);\n+\t  GFC_TYPE_ARRAY_UBOUND (type, n)\n+\t\t= gfc_conv_descriptor_ubound (desc, dim);\n+\t}\n+      else if (GFC_TYPE_ARRAY_UBOUND (type, n) == NULL_TREE)\n \t{\n-\t  dim = gfc_rank_cst[n];\n \t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n \t\t\t     gfc_conv_descriptor_ubound (desc, dim),\n \t\t\t     gfc_conv_descriptor_lbound (desc, dim));"}, {"sha": "d0318789a871873fb3f04d24f5bfa88473b67deb", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5797cc36028b51596c88d0b5ecc1f0a2902488/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5797cc36028b51596c88d0b5ecc1f0a2902488/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=dd5797cc36028b51596c88d0b5ecc1f0a2902488", "patch": "@@ -2429,6 +2429,7 @@ gfc_conv_intrinsic_len (gfc_se * se, gfc_expr * expr)\n   gfc_symbol *sym;\n   gfc_se argse;\n   gfc_expr *arg;\n+  gfc_ss *ss;\n \n   gcc_assert (!se->ss);\n \n@@ -2448,32 +2449,37 @@ gfc_conv_intrinsic_len (gfc_se * se, gfc_expr * expr)\n       get_array_ctor_strlen (arg->value.constructor, &len);\n       break;\n \n-    default:\n-\tif (arg->expr_type == EXPR_VARIABLE\n-\t    && (arg->ref == NULL || (arg->ref->next == NULL\n-\t\t\t\t     && arg->ref->type == REF_ARRAY)))\n-\t  {\n-\t    /* This doesn't catch all cases.\n-\t       See http://gcc.gnu.org/ml/fortran/2004-06/msg00165.html\n-\t       and the surrounding thread.  */\n-\t    sym = arg->symtree->n.sym;\n-\t    decl = gfc_get_symbol_decl (sym);\n-\t    if (decl == current_function_decl && sym->attr.function\n+    case EXPR_VARIABLE:\n+      if (arg->ref == NULL\n+\t    || (arg->ref->next == NULL && arg->ref->type == REF_ARRAY))\n+\t{\n+\t  /* This doesn't catch all cases.\n+\t     See http://gcc.gnu.org/ml/fortran/2004-06/msg00165.html\n+\t     and the surrounding thread.  */\n+\t  sym = arg->symtree->n.sym;\n+\t  decl = gfc_get_symbol_decl (sym);\n+\t  if (decl == current_function_decl && sym->attr.function\n \t\t&& (sym->result == sym))\n-\t      decl = gfc_get_fake_result_decl (sym, 0);\n-\n-\t    len = sym->ts.cl->backend_decl;\n-\t    gcc_assert (len);\n-\t  }\n-\telse\n-\t  {\n-\t    /* Anybody stupid enough to do this deserves inefficient code.  */\n-\t    gfc_init_se (&argse, se);\n-\t    gfc_conv_expr (&argse, arg);\n-\t    gfc_add_block_to_block (&se->pre, &argse.pre);\n-\t    gfc_add_block_to_block (&se->post, &argse.post);\n-\t    len = argse.string_length;\n+\t    decl = gfc_get_fake_result_decl (sym, 0);\n+\n+\t  len = sym->ts.cl->backend_decl;\n+\t  gcc_assert (len);\n+\t  break;\n \t}\n+\n+      /* Otherwise fall through.  */\n+\n+    default:\n+      /* Anybody stupid enough to do this deserves inefficient code.  */\n+      ss = gfc_walk_expr (arg);\n+      gfc_init_se (&argse, se);\n+      if (ss == gfc_ss_terminator)\n+\tgfc_conv_expr (&argse, arg);\n+      else\n+\tgfc_conv_expr_descriptor (&argse, arg, ss);\n+      gfc_add_block_to_block (&se->pre, &argse.pre);\n+      gfc_add_block_to_block (&se->post, &argse.post);\n+      len = argse.string_length;\n       break;\n     }\n   se->expr = convert (type, len);\n@@ -3020,8 +3026,7 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n       else\n         {\n           /* A pointer to an array.  */\n-          arg1se.descriptor_only = 1;\n-          gfc_conv_expr_lhs (&arg1se, arg1->expr);\n+          gfc_conv_expr_descriptor (&arg1se, arg1->expr, ss1);\n           tmp2 = gfc_conv_descriptor_data_get (arg1se.expr);\n         }\n       gfc_add_block_to_block (&se->pre, &arg1se.pre);"}, {"sha": "ecae59339c1db2b3845999cecd7bbac452e6a48a", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5797cc36028b51596c88d0b5ecc1f0a2902488/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5797cc36028b51596c88d0b5ecc1f0a2902488/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=dd5797cc36028b51596c88d0b5ecc1f0a2902488", "patch": "@@ -1482,11 +1482,15 @@ gfc_get_derived_type (gfc_symbol * derived)\n \t building anew so that potential dummy and actual arguments use the\n \t same TREE_TYPE.  If an equal type is found without a backend_decl,\n \t build the parent version and use it in the current namespace.  */\n-\n-      /* Derived types in an interface body obtain their parent reference\n-\t through the proc_name symbol.  */\n-      ns = derived->ns->parent ? derived->ns->parent\n-\t\t\t       : derived->ns->proc_name->ns;\n+      if (derived->ns->parent)\n+\tns = derived->ns->parent;\n+      else if (derived->ns->proc_name)\n+\t/* Derived types in an interface body obtain their parent reference\n+\t   through the proc_name symbol.  */\n+\tns = derived->ns->proc_name->ns;\n+      else\n+\t/* Sometimes there isn't a parent reference!  */\n+\tns = NULL;\n \n       for (; ns; ns = ns->parent)\n \t{"}, {"sha": "ec77c1620a2a136b01fa3e9fc898199623d52a3e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5797cc36028b51596c88d0b5ecc1f0a2902488/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5797cc36028b51596c88d0b5ecc1f0a2902488/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dd5797cc36028b51596c88d0b5ecc1f0a2902488", "patch": "@@ -1,3 +1,14 @@\n+2006-10-31  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/29387\n+\t* gfortran.dg/intrinsic_actual_2.f90: New test.\n+\n+\tPR fortran/29490\n+\t* gfortran.dg/actual_array_interface_1.f90: New test.\n+\n+\tPR fortran/29641\n+\t* gfortran.dg/used_types_11.f90: New test.\n+\t\n 2006-10-30  Dirk Mueller  <dmueller@suse.de>\n \n \t* g++.old-deja/g++.pt/eichin01a.C (main): Fix prototype."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gfortran.dg/actual_array_interface_1.f90", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5797cc36028b51596c88d0b5ecc1f0a2902488/gcc%2Ftestsuite%2Fgfortran.dg%2Factual_array_interface_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5797cc36028b51596c88d0b5ecc1f0a2902488/gcc%2Ftestsuite%2Fgfortran.dg%2Factual_array_interface_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Factual_array_interface_1.f90?ref=dd5797cc36028b51596c88d0b5ecc1f0a2902488"}, {"sha": "d24d21f56be79906e0c69b5faab3b637e25d077d", "filename": "gcc/testsuite/gfortran.dg/intrinsic_actual_2.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5797cc36028b51596c88d0b5ecc1f0a2902488/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_actual_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5797cc36028b51596c88d0b5ecc1f0a2902488/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_actual_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_actual_2.f90?ref=dd5797cc36028b51596c88d0b5ecc1f0a2902488", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+! Tests the fix for PR29387, in which array valued arguments of\n+! LEN and ASSOCIATED would cause an ICE.\n+!\n+! Contributed by Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+!\n+  TYPE T1 \n+    INTEGER, POINTER :: I=>NULL() \n+  END TYPE T1 \n+  character(20) res\n+\n+  j = 10\n+  PRINT *, LEN(SUB(8))\n+  PRINT *, LEN(SUB(j))\n+! print *, len(SUB(j + 2)//\"a\")   ! This still fails (no charlen).\n+  print *, len(bar(2))\n+\n+  IF(.NOT.ASSOCIATED(F1(10))) CALL ABORT() \n+\n+CONTAINS\n+\n+  FUNCTION SUB(I)  \n+    CHARACTER(LEN=I) :: SUB(1)\n+    PRINT *, LEN(SUB(1))\n+  END FUNCTION\n+\n+  FUNCTION BAR(I)  \n+    CHARACTER(LEN=I*10) :: BAR(1)\n+    PRINT *, LEN(BAR)\n+  END FUNCTION\n+\n+  FUNCTION F1(I) RESULT(R) \n+   TYPE(T1), DIMENSION(:), POINTER :: R \n+   INTEGER :: I \n+   ALLOCATE(R(I)) \n+  END FUNCTION F1 \n+END "}, {"sha": "b3f4eaa56e4a4a4bc2bc758c82a0fab104730ac5", "filename": "gcc/testsuite/gfortran.dg/used_types_11.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5797cc36028b51596c88d0b5ecc1f0a2902488/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5797cc36028b51596c88d0b5ecc1f0a2902488/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_11.f90?ref=dd5797cc36028b51596c88d0b5ecc1f0a2902488", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+! Tests the patch for PR 29641, in which an ICE would occur with\n+! the ordering of USE statements below.\n+!\n+! Contributed by Jakub Jelinek <jakub@gcc.gnu.org>\n+!\n+module A\n+  type :: T\n+    integer :: u\n+  end type T\n+end module A\n+\n+module B\n+contains\n+  function foo()\n+    use A\n+    type(T), pointer :: foo\n+    nullify (foo)\n+  end function foo\n+end module B\n+\n+subroutine bar()\n+  use B             ! The order here is important\n+  use A             ! If use A comes before use B, it works\n+  type(T), pointer :: x\n+  x => foo()\n+end subroutine bar\n+\n+  use B\n+  use A\n+  type(T), pointer :: x\n+  type(T), target  :: y\n+  x => y\n+  print *, associated (x)\n+  x => foo ()\n+  print *, associated (x)\n+end"}]}