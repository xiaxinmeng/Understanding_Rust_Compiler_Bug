{"sha": "d0396b7941243ea231a4f812de072c89ca2cd345", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDAzOTZiNzk0MTI0M2VhMjMxYTRmODEyZGUwNzJjODljYTJjZDM0NQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-04-21T10:25:07Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-21T10:25:07Z"}, "message": "i386.c (type_natural_mode): Use gcc_unreachable and gcc_assert instead of abort.\n\n\t* config/i386/i386.c (type_natural_mode): Use gcc_unreachable and\n\tgcc_assert instead of abort.\n\t(classify_argument, examine_argument, construct_container,\n\tcontains_128bit_aligned_vector_p, ix86_check_movabs,\n\tstandard_80387_constant_opcode, standard_80387_constant_rtx,\n\tix86_initial_elimination_offset, ix86_compute_frame_layout,\n\tpro_epilogue_adjust_stack, ix86_expand_epilogue,\n\tix86_address_cost, legitimate_address_p, legitimize_pic_address,\n\tlegitimize_tls_address, output_pic_addr_const,\n\ti386_output_dwarf_dtprel, put_condition_code, print_reg,\n\tget_some_local_dynamic_name, print_operand, print_operand_address,\n\toutput_387_binary_op, emit_i387_cw_initialization,\n\toutput_fix_trunc, output_fp_compare, ix86_output_addr_vec_elt,\n\tix86_expand_clear, ix86_expand_binary_operator,\n\tix86_expand_unary_operator, ix86_match_ccmode, ix86_cc_mode,\n\tix86_cc_modes_compatible, ix86_fp_comparison_codes,\n\tix86_fp_comparison_arithmetics_cost, ix86_expand_fp_compare,\n\tix86_expand_branch, ix86_expand_setcc,\n\tix86_expand_carry_flag_compare, ix86_expand_fp_movcc,\n\tix86_expand_int_addcc, ix86_split_to_parts, ix86_split_long_move,\n\tix86_expand_movmem, ix86_expand_call, assign_386_stack_local,\n\tmemory_address_length, ix86_attr_length_immediate_default,\n\tix86_attr_length_address_default, ix86_agi_dependant,\n\tx86_initialize_trampoline, ix86_init_mmx_sse_builtins,\n\tix86_expand_binop_builtin, ix86_force_to_memory,\n\tix86_secondary_memory_needed, ix86_avoid_jump_misspredicts,\n\tx86_emit_floatuns): Likewise.\n\t* config/i386/netware.c (gen_regparm_prefix,\n\ti386_nlm_strip_name_encoding): Likewise.\n\t* config/i386/winnt.c (i386_pe_mark_dllexport): Likewise.\n\nFrom-SVN: r98500", "tree": {"sha": "0d27fe3b915ab8b6e7f56aef358f69781711a9b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d27fe3b915ab8b6e7f56aef358f69781711a9b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0396b7941243ea231a4f812de072c89ca2cd345", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0396b7941243ea231a4f812de072c89ca2cd345", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0396b7941243ea231a4f812de072c89ca2cd345", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0396b7941243ea231a4f812de072c89ca2cd345/comments", "author": null, "committer": null, "parents": [{"sha": "e3feb57152dbc5999bb84d8d778d0dfdc5ce42e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3feb57152dbc5999bb84d8d778d0dfdc5ce42e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3feb57152dbc5999bb84d8d778d0dfdc5ce42e8"}], "stats": {"total": 660, "additions": 320, "deletions": 340}, "files": [{"sha": "ab071b83cb9e6b1a9aa81b623a098df2a790b210", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0396b7941243ea231a4f812de072c89ca2cd345/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0396b7941243ea231a4f812de072c89ca2cd345/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0396b7941243ea231a4f812de072c89ca2cd345", "patch": "@@ -1,3 +1,36 @@\n+2005-04-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/i386/i386.c (type_natural_mode): Use gcc_unreachable and\n+\tgcc_assert instead of abort.\n+\t(classify_argument, examine_argument, construct_container,\n+\tcontains_128bit_aligned_vector_p, ix86_check_movabs,\n+\tstandard_80387_constant_opcode, standard_80387_constant_rtx,\n+\tix86_initial_elimination_offset, ix86_compute_frame_layout,\n+\tpro_epilogue_adjust_stack, ix86_expand_epilogue,\n+\tix86_address_cost, legitimate_address_p, legitimize_pic_address,\n+\tlegitimize_tls_address, output_pic_addr_const,\n+\ti386_output_dwarf_dtprel, put_condition_code, print_reg,\n+\tget_some_local_dynamic_name, print_operand, print_operand_address,\n+\toutput_387_binary_op, emit_i387_cw_initialization,\n+\toutput_fix_trunc, output_fp_compare, ix86_output_addr_vec_elt,\n+\tix86_expand_clear, ix86_expand_binary_operator,\n+\tix86_expand_unary_operator, ix86_match_ccmode, ix86_cc_mode,\n+\tix86_cc_modes_compatible, ix86_fp_comparison_codes,\n+\tix86_fp_comparison_arithmetics_cost, ix86_expand_fp_compare,\n+\tix86_expand_branch, ix86_expand_setcc,\n+\tix86_expand_carry_flag_compare, ix86_expand_fp_movcc,\n+\tix86_expand_int_addcc, ix86_split_to_parts, ix86_split_long_move,\n+\tix86_expand_movmem, ix86_expand_call, assign_386_stack_local,\n+\tmemory_address_length, ix86_attr_length_immediate_default,\n+\tix86_attr_length_address_default, ix86_agi_dependant,\n+\tx86_initialize_trampoline, ix86_init_mmx_sse_builtins,\n+\tix86_expand_binop_builtin, ix86_force_to_memory,\n+\tix86_secondary_memory_needed, ix86_avoid_jump_misspredicts,\n+\tx86_emit_floatuns): Likewise.\n+\t* config/i386/netware.c (gen_regparm_prefix,\n+\ti386_nlm_strip_name_encoding): Likewise.\n+\t* config/i386/winnt.c (i386_pe_mark_dllexport): Likewise.\n+\n 2005-04-21  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* optabs.c (gen_condiational_trap): Remove #define."}, {"sha": "8560fd3cc9a5d5fa96f2f9a87026bc11be6ccc8a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 269, "deletions": 315, "changes": 584, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0396b7941243ea231a4f812de072c89ca2cd345/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0396b7941243ea231a4f812de072c89ca2cd345/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d0396b7941243ea231a4f812de072c89ca2cd345", "patch": "@@ -2207,7 +2207,7 @@ type_natural_mode (tree type)\n \t\t&& GET_MODE_INNER (mode) == innermode)\n \t      return mode;\n \n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -2334,8 +2334,9 @@ classify_argument (enum machine_mode mode, tree type,\n \t}\n \n       /* Classify each field of record and merge classes.  */\n-      if (TREE_CODE (type) == RECORD_TYPE)\n+      switch (TREE_CODE (type))\n \t{\n+\tcase RECORD_TYPE:\n \t  /* For classes first merge in the field of the subclasses.  */\n \t  if (TYPE_BINFO (type))\n \t    {\n@@ -2400,55 +2401,36 @@ classify_argument (enum machine_mode mode, tree type,\n \t\t    }\n \t\t}\n \t    }\n-\t}\n-      /* Arrays are handled as small records.  */\n-      else if (TREE_CODE (type) == ARRAY_TYPE)\n-\t{\n-\t  int num;\n-\t  num = classify_argument (TYPE_MODE (TREE_TYPE (type)),\n-\t\t\t\t   TREE_TYPE (type), subclasses, bit_offset);\n-\t  if (!num)\n-\t    return 0;\n-\n-\t  /* The partial classes are now full classes.  */\n-\t  if (subclasses[0] == X86_64_SSESF_CLASS && bytes != 4)\n-\t    subclasses[0] = X86_64_SSE_CLASS;\n-\t  if (subclasses[0] == X86_64_INTEGERSI_CLASS && bytes != 4)\n-\t    subclasses[0] = X86_64_INTEGER_CLASS;\n-\n-\t  for (i = 0; i < words; i++)\n-\t    classes[i] = subclasses[i % num];\n-\t}\n-      /* Unions are similar to RECORD_TYPE but offset is always 0.  */\n-      else if (TREE_CODE (type) == UNION_TYPE\n-\t       || TREE_CODE (type) == QUAL_UNION_TYPE)\n-\t{\n-\t  /* For classes first merge in the field of the subclasses.  */\n-\t  if (TYPE_BINFO (type))\n-\t    {\n-\t      tree binfo, base_binfo;\n-\t      int basenum;\n+\t  break;\n \n-\t      for (binfo = TYPE_BINFO (type), basenum = 0;\n-\t\t   BINFO_BASE_ITERATE (binfo, basenum, base_binfo); basenum++)\n-\t\t{\n-\t\t   int num;\n-\t\t   int offset = tree_low_cst (BINFO_OFFSET (base_binfo), 0) * 8;\n-\t\t   tree type = BINFO_TYPE (base_binfo);\n+\tcase ARRAY_TYPE:\n+\t  /* Arrays are handled as small records.  */\n+\t  {\n+\t    int num;\n+\t    num = classify_argument (TYPE_MODE (TREE_TYPE (type)),\n+\t\t\t\t     TREE_TYPE (type), subclasses, bit_offset);\n+\t    if (!num)\n+\t      return 0;\n \n-\t\t   num = classify_argument (TYPE_MODE (type),\n-\t\t\t\t\t    type, subclasses,\n-\t\t\t\t\t    (offset + (bit_offset % 64)) % 256);\n-\t\t   if (!num)\n-\t\t     return 0;\n-\t\t   for (i = 0; i < num; i++)\n-\t\t     {\n-\t\t       int pos = (offset + (bit_offset % 64)) / 8 / 8;\n-\t\t       classes[i + pos] =\n-\t\t\t merge_classes (subclasses[i], classes[i + pos]);\n-\t\t     }\n-\t\t}\n-\t    }\n+\t    /* The partial classes are now full classes.  */\n+\t    if (subclasses[0] == X86_64_SSESF_CLASS && bytes != 4)\n+\t      subclasses[0] = X86_64_SSE_CLASS;\n+\t    if (subclasses[0] == X86_64_INTEGERSI_CLASS && bytes != 4)\n+\t      subclasses[0] = X86_64_INTEGER_CLASS;\n+\t    \n+\t    for (i = 0; i < words; i++)\n+\t      classes[i] = subclasses[i % num];\n+\t    \n+\t    break;\n+\t  }\n+\tcase UNION_TYPE:\n+\tcase QUAL_UNION_TYPE:\n+\t  /* Unions are similar to RECORD_TYPE but offset is always 0.\n+\t     */\n+\n+\t  /* Unions are not derived.  */\n+\t  gcc_assert (!TYPE_BINFO (type)\n+\t\t      || !BINFO_N_BASE_BINFOS (TYPE_BINFO (type)));\n \t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n \t    {\n \t      if (TREE_CODE (field) == FIELD_DECL)\n@@ -2463,9 +2445,11 @@ classify_argument (enum machine_mode mode, tree type,\n \t\t    classes[i] = merge_classes (subclasses[i], classes[i]);\n \t\t}\n \t    }\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else\n-\tabort ();\n \n       /* Final merger cleanup.  */\n       for (i = 0; i < words; i++)\n@@ -2581,21 +2565,19 @@ classify_argument (enum machine_mode mode, tree type,\n     case VOIDmode:\n       return 0;\n     default:\n-      if (VECTOR_MODE_P (mode))\n-\t{\n-\t  if (bytes > 16)\n-\t    return 0;\n-\t  if (GET_MODE_CLASS (GET_MODE_INNER (mode)) == MODE_INT)\n-\t    {\n-\t      if (bit_offset + GET_MODE_BITSIZE (mode) <= 32)\n-\t\tclasses[0] = X86_64_INTEGERSI_CLASS;\n-\t      else\n-\t\tclasses[0] = X86_64_INTEGER_CLASS;\n-\t      classes[1] = X86_64_INTEGER_CLASS;\n-\t      return 1 + (bytes > 8);\n-\t    }\n-\t}\n-      abort ();\n+      gcc_assert (VECTOR_MODE_P (mode));\n+      \n+      if (bytes > 16)\n+\treturn 0;\n+      \n+      gcc_assert (GET_MODE_CLASS (GET_MODE_INNER (mode)) == MODE_INT);\n+      \n+      if (bit_offset + GET_MODE_BITSIZE (mode) <= 32)\n+\tclasses[0] = X86_64_INTEGERSI_CLASS;\n+      else\n+\tclasses[0] = X86_64_INTEGER_CLASS;\n+      classes[1] = X86_64_INTEGER_CLASS;\n+      return 1 + (bytes > 8);\n     }\n }\n \n@@ -2635,7 +2617,7 @@ examine_argument (enum machine_mode mode, tree type, int in_return,\n       case X86_64_COMPLEX_X87_CLASS:\n \treturn in_return ? 2 : 0;\n       case X86_64_MEMORY_CLASS:\n-\tabort ();\n+\tgcc_unreachable ();\n       }\n   return 1;\n }\n@@ -2717,7 +2699,7 @@ construct_container (enum machine_mode mode, enum machine_mode orig_mode,\n \t/* Zero sized array, struct or class.  */\n \treturn NULL;\n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n       }\n   if (n == 2 && class[0] == X86_64_SSE_CLASS && class[1] == X86_64_SSEUP_CLASS\n       && mode != BLKmode)\n@@ -2783,7 +2765,7 @@ construct_container (enum machine_mode mode, enum machine_mode orig_mode,\n \t    sse_regno++;\n \t    break;\n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t}\n     }\n \n@@ -3091,38 +3073,43 @@ contains_128bit_aligned_vector_p (tree type)\n   if (AGGREGATE_TYPE_P (type))\n     {\n       /* Walk the aggregates recursively.  */\n-      if (TREE_CODE (type) == RECORD_TYPE\n-\t  || TREE_CODE (type) == UNION_TYPE\n-\t  || TREE_CODE (type) == QUAL_UNION_TYPE)\n+      switch (TREE_CODE (type))\n \t{\n-\t  tree field;\n-\n-\t  if (TYPE_BINFO (type))\n-\t    {\n-\t      tree binfo, base_binfo;\n-\t      int i;\n-\n-\t      for (binfo = TYPE_BINFO (type), i = 0;\n-\t\t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n-\t\tif (contains_128bit_aligned_vector_p (BINFO_TYPE (base_binfo)))\n+\tcase RECORD_TYPE:\n+\tcase UNION_TYPE:\n+\tcase QUAL_UNION_TYPE:\n+\t  {\n+\t    tree field;\n+\t    \n+\t    if (TYPE_BINFO (type))\n+\t      {\n+\t\ttree binfo, base_binfo;\n+\t\tint i;\n+\t\t\n+\t\tfor (binfo = TYPE_BINFO (type), i = 0;\n+\t\t     BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+\t\t  if (contains_128bit_aligned_vector_p\n+\t\t      (BINFO_TYPE (base_binfo)))\n+\t\t    return true;\n+\t      }\n+\t    /* And now merge the fields of structure.  */\n+\t    for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t      {\n+\t\tif (TREE_CODE (field) == FIELD_DECL\n+\t\t    && contains_128bit_aligned_vector_p (TREE_TYPE (field)))\n \t\t  return true;\n-\t    }\n-\t  /* And now merge the fields of structure.  */\n-\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-\t    {\n-\t      if (TREE_CODE (field) == FIELD_DECL\n-\t\t  && contains_128bit_aligned_vector_p (TREE_TYPE (field)))\n-\t\treturn true;\n-\t    }\n-\t}\n-      /* Just for use if some languages passes arrays by value.  */\n-      else if (TREE_CODE (type) == ARRAY_TYPE)\n-\t{\n+\t      }\n+\t    break;\n+\t  }\n+\n+\tcase ARRAY_TYPE:\n+\t  /* Just for use if some languages passes arrays by value.  */\n \t  if (contains_128bit_aligned_vector_p (TREE_TYPE (type)))\n \t    return true;\n+\t  \n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else\n-\tabort ();\n     }\n   return false;\n }\n@@ -3815,13 +3802,11 @@ ix86_check_movabs (rtx insn, int opnum)\n   set = PATTERN (insn);\n   if (GET_CODE (set) == PARALLEL)\n     set = XVECEXP (set, 0, 0);\n-  if (GET_CODE (set) != SET)\n-    abort ();\n+  gcc_assert (GET_CODE (set) == SET);\n   mem = XEXP (set, opnum);\n   while (GET_CODE (mem) == SUBREG)\n     mem = SUBREG_REG (mem);\n-  if (GET_CODE (mem) != MEM)\n-    abort ();\n+  gcc_assert (GET_CODE (mem) == MEM);\n   return (volatile_ok || !MEM_VOLATILE_P (mem));\n }\n \f\n@@ -3907,8 +3892,9 @@ standard_80387_constant_opcode (rtx x)\n       return \"fldl2t\";\n     case 7:\n       return \"fldpi\";\n+    default:\n+      gcc_unreachable ();\n     }\n-  abort ();\n }\n \n /* Return the CONST_DOUBLE representing the 80387 constant that is\n@@ -3934,7 +3920,7 @@ standard_80387_constant_rtx (int idx)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return CONST_DOUBLE_FROM_REAL_VALUE (ext_80387_constants_table[i],\n@@ -4260,14 +4246,13 @@ ix86_initial_elimination_offset (int from, int to)\n     return frame.hard_frame_pointer_offset - frame.frame_pointer_offset;\n   else\n     {\n-      if (to != STACK_POINTER_REGNUM)\n-\tabort ();\n-      else if (from == ARG_POINTER_REGNUM)\n+      gcc_assert (to == STACK_POINTER_REGNUM);\n+\n+      if (from == ARG_POINTER_REGNUM)\n \treturn frame.stack_pointer_offset;\n-      else if (from != FRAME_POINTER_REGNUM)\n-\tabort ();\n-      else\n-\treturn frame.stack_pointer_offset - frame.frame_pointer_offset;\n+      \n+      gcc_assert (from == FRAME_POINTER_REGNUM);\n+      return frame.stack_pointer_offset - frame.frame_pointer_offset;\n     }\n }\n \n@@ -4334,14 +4319,11 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n      preferred_alignment, since i386 port is the only using those features\n      that may break easily.  */\n \n-  if (size && !stack_alignment_needed)\n-    abort ();\n-  if (preferred_alignment < STACK_BOUNDARY / BITS_PER_UNIT)\n-    abort ();\n-  if (preferred_alignment > PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)\n-    abort ();\n-  if (stack_alignment_needed > PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)\n-    abort ();\n+  gcc_assert (!size || stack_alignment_needed);\n+  gcc_assert (preferred_alignment >= STACK_BOUNDARY / BITS_PER_UNIT);\n+  gcc_assert (preferred_alignment <= PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT);\n+  gcc_assert (stack_alignment_needed\n+\t      <= PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT);\n \n   if (stack_alignment_needed < STACK_BOUNDARY / BITS_PER_UNIT)\n     stack_alignment_needed = STACK_BOUNDARY / BITS_PER_UNIT;\n@@ -4491,8 +4473,7 @@ pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset, int style)\n \t epilogue and used after the epilogue.  ATM indirect sibcall\n \t shouldn't be used together with huge frame sizes in one\n \t function because of the frame_size check in sibcall.c.  */\n-      if (style == 0)\n-\tabort ();\n+      gcc_assert (style);\n       r11 = gen_rtx_REG (DImode, FIRST_REX_INT_REG + 3 /* R11 */);\n       insn = emit_insn (gen_rtx_SET (DImode, r11, offset));\n       if (style < 0)\n@@ -4554,8 +4535,7 @@ ix86_expand_prologue (void)\n       bool eax_live = ix86_eax_live_at_start_p ();\n       rtx t;\n \n-      if (TARGET_64BIT)\n-        abort ();\n+      gcc_assert (!TARGET_64BIT);\n \n       if (eax_live)\n \t{\n@@ -4761,8 +4741,7 @@ ix86_expand_epilogue (int style)\n \t pop the registers.  */\n       if (!sp_valid)\n \t{\n-\t  if (!frame_pointer_needed)\n-\t    abort ();\n+\t  gcc_assert (frame_pointer_needed);\n \t  pro_epilogue_adjust_stack (stack_pointer_rtx,\n \t\t\t\t     hard_frame_pointer_rtx,\n \t\t\t\t     GEN_INT (offset), style);\n@@ -4809,8 +4788,7 @@ ix86_expand_epilogue (int style)\n \t  rtx ecx = gen_rtx_REG (SImode, 2);\n \n \t  /* There is no \"pascal\" calling convention in 64bit ABI.  */\n-\t  if (TARGET_64BIT)\n-\t    abort ();\n+\t  gcc_assert (!TARGET_64BIT);\n \n \t  emit_insn (gen_popsi1 (ecx));\n \t  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, popc));\n@@ -4999,9 +4977,9 @@ ix86_address_cost (rtx x)\n {\n   struct ix86_address parts;\n   int cost = 1;\n+  int ok = ix86_decompose_address (x, &parts);\n \n-  if (!ix86_decompose_address (x, &parts))\n-    abort ();\n+  gcc_assert (ok);\n \n   if (parts.base && GET_CODE (parts.base) == SUBREG)\n     parts.base = SUBREG_REG (parts.base);\n@@ -5458,8 +5436,7 @@ legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n \t  case UNSPEC_GOT:\n \t  case UNSPEC_GOTOFF:\n \t  case UNSPEC_GOTPCREL:\n-\t    if (!flag_pic)\n-\t      abort ();\n+\t    gcc_assert (flag_pic);\n \t    goto is_legitimate_pic;\n \n \t  case UNSPEC_GOTTPOFF:\n@@ -5674,8 +5651,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t      || (GET_CODE (addr) == PLUS\n \t\t  && GET_CODE (XEXP (addr, 0)) == UNSPEC))\n \t    return orig;\n-\t  if (GET_CODE (addr) != PLUS)\n-\t    abort ();\n+\t  gcc_assert (GET_CODE (addr) == PLUS);\n \t}\n       if (GET_CODE (addr) == PLUS)\n \t{\n@@ -5868,7 +5844,7 @@ legitimize_tls_address (rtx x, enum tls_model model, int for_mov)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return dest;\n@@ -6081,10 +6057,8 @@ output_pic_addr_const (FILE *file, rtx x, int code)\n   switch (GET_CODE (x))\n     {\n     case PC:\n-      if (flag_pic)\n-\tputc ('.', file);\n-      else\n-\tabort ();\n+      gcc_assert (flag_pic);\n+      putc ('.', file);\n       break;\n \n     case SYMBOL_REF:\n@@ -6136,14 +6110,13 @@ output_pic_addr_const (FILE *file, rtx x, int code)\n \t  putc ('+', file);\n \t  output_pic_addr_const (file, XEXP (x, 1), code);\n \t}\n-      else if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+      else \n \t{\n+\t  gcc_assert (GET_CODE (XEXP (x, 1)) == CONST_INT);\n \t  output_pic_addr_const (file, XEXP (x, 1), code);\n \t  putc ('+', file);\n \t  output_pic_addr_const (file, XEXP (x, 0), code);\n \t}\n-      else\n-\tabort ();\n       break;\n \n     case MINUS:\n@@ -6157,8 +6130,7 @@ output_pic_addr_const (FILE *file, rtx x, int code)\n       break;\n \n      case UNSPEC:\n-       if (XVECLEN (x, 0) != 1)\n-\t abort ();\n+       gcc_assert (XVECLEN (x, 0) == 1);\n        output_pic_addr_const (file, XVECEXP (x, 0, 0), code);\n        switch (XINT (x, 1))\n \t{\n@@ -6224,7 +6196,7 @@ i386_output_dwarf_dtprel (FILE *file, int size, rtx x)\n       fputs (\", 0\", file);\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n    }\n }\n \n@@ -6314,8 +6286,7 @@ put_condition_code (enum rtx_code code, enum machine_mode mode, int reverse,\n     {\n       enum rtx_code second_code, bypass_code;\n       ix86_fp_comparison_codes (code, &bypass_code, &code, &second_code);\n-      if (bypass_code != UNKNOWN || second_code != UNKNOWN)\n-\tabort ();\n+      gcc_assert (bypass_code == UNKNOWN && second_code == UNKNOWN);\n       code = ix86_fp_compare_code_to_integer (code);\n       mode = CCmode;\n     }\n@@ -6331,52 +6302,64 @@ put_condition_code (enum rtx_code code, enum machine_mode mode, int reverse,\n       suffix = \"ne\";\n       break;\n     case GT:\n-      if (mode != CCmode && mode != CCNOmode && mode != CCGCmode)\n-\tabort ();\n+      gcc_assert (mode == CCmode || mode == CCNOmode || mode == CCGCmode);\n       suffix = \"g\";\n       break;\n     case GTU:\n       /* ??? Use \"nbe\" instead of \"a\" for fcmov lossage on some assemblers.\n \t Those same assemblers have the same but opposite lossage on cmov.  */\n-      if (mode != CCmode)\n-\tabort ();\n+      gcc_assert (mode == CCmode);\n       suffix = fp ? \"nbe\" : \"a\";\n       break;\n     case LT:\n-      if (mode == CCNOmode || mode == CCGOCmode)\n-\tsuffix = \"s\";\n-      else if (mode == CCmode || mode == CCGCmode)\n-\tsuffix = \"l\";\n-      else\n-\tabort ();\n+      switch (mode)\n+\t{\n+\tcase CCNOmode:\n+\tcase CCGOCmode:\n+\t  suffix = \"s\";\n+\t  break;\n+\n+\tcase CCmode:\n+\tcase CCGCmode:\n+\t  suffix = \"l\";\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n       break;\n     case LTU:\n-      if (mode != CCmode)\n-\tabort ();\n+      gcc_assert (mode == CCmode);\n       suffix = \"b\";\n       break;\n     case GE:\n-      if (mode == CCNOmode || mode == CCGOCmode)\n-\tsuffix = \"ns\";\n-      else if (mode == CCmode || mode == CCGCmode)\n-\tsuffix = \"ge\";\n-      else\n-\tabort ();\n+      switch (mode)\n+\t{\n+\tcase CCNOmode:\n+\tcase CCGOCmode:\n+\t  suffix = \"ns\";\n+\t  break;\n+\n+\tcase CCmode:\n+\tcase CCGCmode:\n+\t  suffix = \"ge\";\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n       break;\n     case GEU:\n       /* ??? As above.  */\n-      if (mode != CCmode)\n-\tabort ();\n+      gcc_assert (mode == CCmode);\n       suffix = fp ? \"nb\" : \"ae\";\n       break;\n     case LE:\n-      if (mode != CCmode && mode != CCGCmode && mode != CCNOmode)\n-\tabort ();\n+      gcc_assert (mode == CCmode || mode == CCGCmode || mode == CCNOmode);\n       suffix = \"le\";\n       break;\n     case LEU:\n-      if (mode != CCmode)\n-\tabort ();\n+      gcc_assert (mode == CCmode);\n       suffix = \"be\";\n       break;\n     case UNORDERED:\n@@ -6386,7 +6369,7 @@ put_condition_code (enum rtx_code code, enum machine_mode mode, int reverse,\n       suffix = fp ? \"nu\" : \"np\";\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   fputs (suffix, file);\n }\n@@ -6396,17 +6379,16 @@ put_condition_code (enum rtx_code code, enum machine_mode mode, int reverse,\n    If CODE is 'b', pretend the mode is QImode.\n    If CODE is 'k', pretend the mode is SImode.\n    If CODE is 'q', pretend the mode is DImode.\n-   If CODE is 'h', pretend the reg is the `high' byte register.\n+   If CODE is 'h', pretend the reg is the 'high' byte register.\n    If CODE is 'y', print \"st(0)\" instead of \"st\", if the reg is stack op.  */\n \n void\n print_reg (rtx x, int code, FILE *file)\n {\n-  if (REGNO (x) == ARG_POINTER_REGNUM\n-      || REGNO (x) == FRAME_POINTER_REGNUM\n-      || REGNO (x) == FLAGS_REG\n-      || REGNO (x) == FPSR_REG)\n-    abort ();\n+  gcc_assert (REGNO (x) != ARG_POINTER_REGNUM\n+\t      && REGNO (x) != FRAME_POINTER_REGNUM\n+\t      && REGNO (x) != FLAGS_REG\n+\t      && REGNO (x) != FPSR_REG);\n \n   if (ASSEMBLER_DIALECT == ASM_ATT || USER_LABEL_PREFIX[0] == 0)\n     putc ('%', file);\n@@ -6430,8 +6412,7 @@ print_reg (rtx x, int code, FILE *file)\n      from the normal registers.  */\n   if (REX_INT_REG_P (x))\n     {\n-      if (!TARGET_64BIT)\n-\tabort ();\n+      gcc_assert (TARGET_64BIT);\n       switch (code)\n \t{\n \t  case 0:\n@@ -6486,7 +6467,7 @@ print_reg (rtx x, int code, FILE *file)\n       fputs (qi_high_reg_name[REGNO (x)], file);\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -6507,7 +6488,7 @@ get_some_local_dynamic_name (void)\n \t&& for_each_rtx (&PATTERN (insn), get_some_local_dynamic_name_1, 0))\n       return cfun->machine->some_ld_name;\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \n static int\n@@ -6570,10 +6551,13 @@ print_operand (FILE *file, rtx x, int code)\n \t  return;\n \n \tcase 'A':\n-\t  if (ASSEMBLER_DIALECT == ASM_ATT)\n-\t    putc ('*', file);\n-\t  else if (ASSEMBLER_DIALECT == ASM_INTEL)\n+\t  switch (ASSEMBLER_DIALECT)\n \t    {\n+\t    case ASM_ATT:\n+\t      putc ('*', file);\n+\t      break;\n+\n+\t    case ASM_INTEL:\n \t      /* Intel syntax. For absolute addresses, registers should not\n \t\t be surrounded by braces.  */\n \t      if (GET_CODE (x) != REG)\n@@ -6583,9 +6567,11 @@ print_operand (FILE *file, rtx x, int code)\n \t\t  putc (']', file);\n \t\t  return;\n \t\t}\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n \t    }\n-\t  else\n-\t    abort ();\n \n \t  PRINT_OPERAND (file, x, 0);\n \t  return;\n@@ -6670,7 +6656,7 @@ print_operand (FILE *file, rtx x, int code)\n \t      return;\n \n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \n \tcase 'b':\n@@ -6728,8 +6714,7 @@ print_operand (FILE *file, rtx x, int code)\n \t      fputs (\"ord\", file);\n \t      break;\n \t    default:\n-\t      abort ();\n-\t      break;\n+\t      gcc_unreachable ();\n \t    }\n \t  return;\n \tcase 'O':\n@@ -6743,7 +6728,7 @@ print_operand (FILE *file, rtx x, int code)\n \t\tcase SFmode: putc ('l', file); break;\n \t\tcase DImode:\n \t\tcase DFmode: putc ('q', file); break;\n-\t\tdefault: abort ();\n+\t\tdefault: gcc_unreachable ();\n \t\t}\n \t      putc ('.', file);\n \t    }\n@@ -6841,7 +6826,7 @@ print_operand (FILE *file, rtx x, int code)\n \t    case 12: size = \"XWORD\"; break;\n \t    case 16: size = \"XMMWORD\"; break;\n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \n \t  /* Check for explicit size override (codes 'b', 'w' and 'k')  */\n@@ -6905,10 +6890,8 @@ print_operand (FILE *file, rtx x, int code)\n \t since we can in fact encode that into an immediate.  */\n       if (GET_CODE (x) == CONST_VECTOR)\n \t{\n-\t  if (x == CONST0_RTX (GET_MODE (x)))\n-\t    x = const0_rtx;\n-\t  else\n-\t    abort ();\n+\t  gcc_assert (x == CONST0_RTX (GET_MODE (x)));\n+\t  x = const0_rtx;\n \t}\n \n       if (code != 'P')\n@@ -6944,9 +6927,9 @@ print_operand_address (FILE *file, rtx addr)\n   struct ix86_address parts;\n   rtx base, index, disp;\n   int scale;\n+  int ok = ix86_decompose_address (addr, &parts);\n \n-  if (! ix86_decompose_address (addr, &parts))\n-    abort ();\n+  gcc_assert (ok);\n \n   base = parts.base;\n   index = parts.index;\n@@ -6964,7 +6947,7 @@ print_operand_address (FILE *file, rtx addr)\n       fputs ((parts.seg == SEG_FS ? \"fs:\" : \"gs:\"), file);\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (!base && !index)\n@@ -7224,8 +7207,8 @@ output_387_binary_op (rtx insn, rtx *operands)\n \t      && (STACK_REG_P (operands[1]) || GET_CODE (operands[1]) == MEM)))\n       && (STACK_TOP_P (operands[1]) || STACK_TOP_P (operands[2])))\n     ; /* ok */\n-  else if (!is_sse)\n-    abort ();\n+  else\n+    gcc_assert (is_sse);\n #endif\n \n   switch (GET_CODE (operands[3]))\n@@ -7267,7 +7250,7 @@ output_387_binary_op (rtx insn, rtx *operands)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (is_sse)\n@@ -7402,7 +7385,7 @@ output_387_binary_op (rtx insn, rtx *operands)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   strcat (buf, p);\n@@ -7447,7 +7430,7 @@ emit_i387_cw_initialization (rtx current_mode, rtx new_mode, int mode)\n \t  break;\n \n \tdefault:\n-\t  abort();\n+\t  gcc_unreachable ();\n \t}\n     }\n   else\n@@ -7477,7 +7460,7 @@ emit_i387_cw_initialization (rtx current_mode, rtx new_mode, int mode)\n \t  break;\n \n \tdefault:\n-\t  abort();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -7501,11 +7484,8 @@ output_fix_trunc (rtx insn, rtx *operands, int fisttp)\n   if ((dimode_p || fisttp) && !stack_top_dies)\n     output_asm_insn (\"fld\\t%y1\", operands);\n \n-  if (!STACK_TOP_P (operands[1]))\n-    abort ();\n-\n-  if (GET_CODE (operands[0]) != MEM)\n-    abort ();\n+  gcc_assert (STACK_TOP_P (operands[1]));\n+  gcc_assert (GET_CODE (operands[0]) == MEM);\n \n   if (fisttp)\n       output_asm_insn (\"fisttp%z0\\t%0\", operands);\n@@ -7559,8 +7539,7 @@ output_fp_compare (rtx insn, rtx *operands, int eflags_p, int unordered_p)\n \t  return \"comisd\\t{%1, %0|%0, %1}\";\n     }\n \n-  if (! STACK_TOP_P (cmp_op0))\n-    abort ();\n+  gcc_assert (STACK_TOP_P (cmp_op0));\n \n   stack_top_dies = find_regno_note (insn, REG_DEAD, FIRST_STACK_REG) != 0;\n \n@@ -7637,11 +7616,9 @@ output_fp_compare (rtx insn, rtx *operands, int eflags_p, int unordered_p)\n       mask |= unordered_p << 1;\n       mask |= stack_top_dies;\n \n-      if (mask >= 16)\n-\tabort ();\n+      gcc_assert (mask < 16);\n       ret = alt[mask];\n-      if (ret == NULL)\n-\tabort ();\n+      gcc_assert (ret);\n \n       return ret;\n     }\n@@ -7652,14 +7629,12 @@ ix86_output_addr_vec_elt (FILE *file, int value)\n {\n   const char *directive = ASM_LONG;\n \n-  if (TARGET_64BIT)\n-    {\n #ifdef ASM_QUAD\n-      directive = ASM_QUAD;\n+  if (TARGET_64BIT)\n+    directive = ASM_QUAD;\n #else\n-      abort ();\n+  gcc_assert (!TARGET_64BIT);\n #endif\n-    }\n \n   fprintf (file, \"%s%s%d\\n\", directive, LPREFIX, value);\n }\n@@ -7694,8 +7669,7 @@ ix86_expand_clear (rtx dest)\n   rtx tmp;\n \n   /* We play register width games, which are only valid after reload.  */\n-  if (!reload_completed)\n-    abort ();\n+  gcc_assert (reload_completed);\n \n   /* Avoid HImode and its attendant prefix byte.  */\n   if (GET_MODE_SIZE (GET_MODE (dest)) < 4)\n@@ -8103,8 +8077,7 @@ ix86_expand_binary_operator (enum rtx_code code, enum machine_mode mode,\n     {\n       /* Reload doesn't know about the flags register, and doesn't know that\n          it doesn't want to clobber it.  We can only do this with PLUS.  */\n-      if (code != PLUS)\n-\tabort ();\n+      gcc_assert (code == PLUS);\n       emit_insn (op);\n     }\n   else\n@@ -8192,8 +8165,7 @@ ix86_expand_unary_operator (enum rtx_code code, enum machine_mode mode,\n     {\n       /* Reload doesn't know about the flags register, and doesn't know that\n          it doesn't want to clobber it.  */\n-      if (code != NOT)\n-        abort ();\n+      gcc_assert (code == NOT);\n       emit_insn (op);\n     }\n   else\n@@ -8507,10 +8479,8 @@ ix86_match_ccmode (rtx insn, enum machine_mode req_mode)\n   set = PATTERN (insn);\n   if (GET_CODE (set) == PARALLEL)\n     set = XVECEXP (set, 0, 0);\n-  if (GET_CODE (set) != SET)\n-    abort ();\n-  if (GET_CODE (SET_SRC (set)) != COMPARE)\n-    abort ();\n+  gcc_assert (GET_CODE (set) == SET);\n+  gcc_assert (GET_CODE (SET_SRC (set)) == COMPARE);\n \n   set_mode = GET_MODE (SET_DEST (set));\n   switch (set_mode)\n@@ -8537,7 +8507,7 @@ ix86_match_ccmode (rtx insn, enum machine_mode req_mode)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return (GET_MODE (SET_SRC (set)) == set_mode);\n@@ -8619,7 +8589,7 @@ ix86_cc_mode (enum rtx_code code, rtx op0, rtx op1)\n     case USE:\n       return CCmode;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -8653,7 +8623,7 @@ ix86_cc_modes_compatible (enum machine_mode m1, enum machine_mode m2)\n   switch (m1)\n     {\n     default:\n-      abort ();\n+      gcc_unreachable ();\n \n     case CCmode:\n     case CCGCmode:\n@@ -8863,7 +8833,7 @@ ix86_fp_comparison_codes (enum rtx_code code, enum rtx_code *bypass_code,\n       *second_code = UNORDERED;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   if (!TARGET_IEEE_FP)\n     {\n@@ -8905,7 +8875,7 @@ ix86_fp_comparison_arithmetics_cost (enum rtx_code code)\n       return 6;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -9132,7 +9102,7 @@ ix86_expand_fp_compare (enum rtx_code code, rtx op0, rtx op1, rtx scratch,\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -9331,7 +9301,7 @@ ix86_expand_branch (enum rtx_code code, rtx label)\n \t  case NE:   code2 = UNKNOWN; break;\n \n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  }\n \n \t/*\n@@ -9360,7 +9330,7 @@ ix86_expand_branch (enum rtx_code code, rtx label)\n       }\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -9456,8 +9426,7 @@ ix86_expand_setcc (enum rtx_code code, rtx dest)\n       && !TARGET_64BIT)\n     return 0; /* FAIL */\n \n-  if (GET_MODE (dest) != QImode)\n-    abort ();\n+  gcc_assert (GET_MODE (dest) == QImode);\n \n   ret = ix86_expand_compare (code, &second_test, &bypass_test);\n   PUT_MODE (ret, QImode);\n@@ -9473,8 +9442,7 @@ ix86_expand_setcc (enum rtx_code code, rtx dest)\n       rtx tmp2 = gen_reg_rtx (QImode);\n       if (bypass_test)\n \t{\n-\t  if (second_test)\n-\t    abort ();\n+\t  gcc_assert (!second_test);\n \t  test = bypass_test;\n \t  bypass = 1;\n \t  PUT_CODE (test, reverse_condition_maybe_unordered (GET_CODE (test)));\n@@ -9622,8 +9590,7 @@ ix86_expand_carry_flag_compare (enum rtx_code code, rtx op0, rtx op1, rtx *pop)\n   ix86_compare_op0 = op0;\n   ix86_compare_op1 = op1;\n   *pop = ix86_expand_compare (code, NULL, NULL);\n-  if (GET_CODE (*pop) != LTU && GET_CODE (*pop) != GEU)\n-    abort ();\n+  gcc_assert (GET_CODE (*pop) == LTU || GET_CODE (*pop) == GEU);\n   return true;\n }\n \n@@ -10373,8 +10340,7 @@ ix86_expand_fp_movcc (rtx operands[])\n \n   if (!fcmov_comparison_operator (compare_op, VOIDmode))\n     {\n-      if (second_test != NULL || bypass_test != NULL)\n-\tabort ();\n+      gcc_assert (!second_test && !bypass_test);\n       tmp = gen_reg_rtx (QImode);\n       ix86_expand_setcc (code, tmp);\n       code = NE;\n@@ -10585,7 +10551,7 @@ ix86_expand_int_addcc (rtx operands[])\n             emit_insn (gen_subdi3_carry_rex64 (operands[0], operands[2], val, compare_op));\n \t    break;\n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t}\n     }\n   else\n@@ -10605,7 +10571,7 @@ ix86_expand_int_addcc (rtx operands[])\n             emit_insn (gen_adddi3_carry_rex64 (operands[0], operands[2], val, compare_op));\n \t    break;\n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t}\n     }\n   return 1; /* DONE */\n@@ -10627,10 +10593,8 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n   else\n     size = (GET_MODE_SIZE (mode) + 4) / 8;\n \n-  if (GET_CODE (operand) == REG && MMX_REGNO_P (REGNO (operand)))\n-    abort ();\n-  if (size < 2 || size > 3)\n-    abort ();\n+  gcc_assert (GET_CODE (operand) != REG || !MMX_REGNO_P (REGNO (operand)));\n+  gcc_assert (size >= 2 && size <= 3);\n \n   /* Optimize constant pool reference to immediates.  This is used by fp\n      moves, that force all constants to memory to allow combining.  */\n@@ -10644,9 +10608,10 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n   if (GET_CODE (operand) == MEM && !offsettable_memref_p (operand))\n     {\n       /* The only non-offsetable memories we handle are pushes.  */\n-      if (! push_operand (operand, VOIDmode))\n-\tabort ();\n-\n+      int ok = push_operand (operand, VOIDmode);\n+      \n+      gcc_assert (ok);\n+      \n       operand = copy_rtx (operand);\n       PUT_MODE (operand, Pmode);\n       parts[0] = parts[1] = parts[2] = operand;\n@@ -10669,8 +10634,7 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n \t{\n \t  if (REG_P (operand))\n \t    {\n-\t      if (!reload_completed)\n-\t\tabort ();\n+\t      gcc_assert (reload_completed);\n \t      parts[0] = gen_rtx_REG (SImode, REGNO (operand) + 0);\n \t      parts[1] = gen_rtx_REG (SImode, REGNO (operand) + 1);\n \t      if (size == 3)\n@@ -10700,13 +10664,13 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n \t\t  REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n \t\t  break;\n \t\tdefault:\n-\t\t  abort ();\n+\t\t  gcc_unreachable ();\n \t\t}\n \t      parts[1] = gen_int_mode (l[1], SImode);\n \t      parts[0] = gen_int_mode (l[0], SImode);\n \t    }\n \t  else\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t}\n     }\n   else\n@@ -10718,8 +10682,7 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n \t  enum machine_mode upper_mode = mode==XFmode ? SImode : DImode;\n \t  if (REG_P (operand))\n \t    {\n-\t      if (!reload_completed)\n-\t\tabort ();\n+\t      gcc_assert (reload_completed);\n \t      parts[0] = gen_rtx_REG (DImode, REGNO (operand) + 0);\n \t      parts[1] = gen_rtx_REG (upper_mode, REGNO (operand) + 1);\n \t    }\n@@ -10759,7 +10722,7 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n \t        parts[1] = immed_double_const (l[2], l[3], DImode);\n \t    }\n \t  else\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t}\n     }\n \n@@ -10807,9 +10770,9 @@ ix86_split_long_move (rtx operands[])\n   /* The only non-offsettable memory we handle is push.  */\n   if (push_operand (operands[0], VOIDmode))\n     push = 1;\n-  else if (GET_CODE (operands[0]) == MEM\n-\t   && ! offsettable_memref_p (operands[0]))\n-    abort ();\n+  else\n+    gcc_assert (GET_CODE (operands[0]) != MEM\n+\t\t|| offsettable_memref_p (operands[0]));\n \n   nparts = ix86_split_to_parts (operands[1], part[1], GET_MODE (operands[0]));\n   ix86_split_to_parts (operands[0], part[0], GET_MODE (operands[0]));\n@@ -10890,12 +10853,20 @@ ix86_split_long_move (rtx operands[])\n \t     moving of second half of TFmode value.  */\n \t  if (GET_MODE (part[1][1]) == SImode)\n \t    {\n-\t      if (GET_CODE (part[1][1]) == MEM)\n-\t\tpart[1][1] = adjust_address (part[1][1], DImode, 0);\n-\t      else if (REG_P (part[1][1]))\n-\t\tpart[1][1] = gen_rtx_REG (DImode, REGNO (part[1][1]));\n-\t      else\n-\t\tabort ();\n+\t      switch (GET_CODE (part[1][1]))\n+\t\t{\n+\t\tcase MEM:\n+\t\t  part[1][1] = adjust_address (part[1][1], DImode, 0);\n+\t\t  break;\n+\n+\t\tcase REG:\n+\t\t  part[1][1] = gen_rtx_REG (DImode, REGNO (part[1][1]));\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      \n \t      if (GET_MODE (part[1][0]) == SImode)\n \t\tpart[1][0] = part[1][1];\n \t    }\n@@ -11298,8 +11269,7 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp)\n   else\n     counter_mode = DImode;\n \n-  if (counter_mode != SImode && counter_mode != DImode)\n-    abort ();\n+  gcc_assert (counter_mode == SImode || counter_mode == DImode);\n \n   destreg = copy_to_mode_reg (Pmode, XEXP (dst, 0));\n   if (destreg != XEXP (dst, 0))\n@@ -12083,8 +12053,7 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n \n   if (pop == const0_rtx)\n     pop = NULL;\n-  if (TARGET_64BIT && pop)\n-    abort ();\n+  gcc_assert (!TARGET_64BIT || !pop);\n \n #if TARGET_MACHO\n   if (flag_pic && GET_CODE (XEXP (fnaddr, 0)) == SYMBOL_REF)\n@@ -12161,8 +12130,7 @@ assign_386_stack_local (enum machine_mode mode, int n)\n {\n   struct stack_local_entry *s;\n \n-  if (n < 0 || n >= MAX_386_STACK_LOCALS)\n-    abort ();\n+  gcc_assert (n >= 0 && n < MAX_386_STACK_LOCALS);\n \n   for (s = ix86_stack_locals; s; s = s->next)\n     if (s->mode == mode && s->n == n)\n@@ -12206,15 +12174,16 @@ memory_address_length (rtx addr)\n   struct ix86_address parts;\n   rtx base, index, disp;\n   int len;\n+  int ok;\n \n   if (GET_CODE (addr) == PRE_DEC\n       || GET_CODE (addr) == POST_INC\n       || GET_CODE (addr) == PRE_MODIFY\n       || GET_CODE (addr) == POST_MODIFY)\n     return 0;\n \n-  if (! ix86_decompose_address (addr, &parts))\n-    abort ();\n+  ok = ix86_decompose_address (addr, &parts);\n+  gcc_assert (ok);\n \n   if (parts.base && GET_CODE (parts.base) == SUBREG)\n     parts.base = SUBREG_REG (parts.base);\n@@ -12285,8 +12254,7 @@ ix86_attr_length_immediate_default (rtx insn, int shortform)\n   for (i = recog_data.n_operands - 1; i >= 0; --i)\n     if (CONSTANT_P (recog_data.operand[i]))\n       {\n-\tif (len)\n-\t  abort ();\n+\tgcc_assert (!len);\n \tif (shortform\n \t    && GET_CODE (recog_data.operand[i]) == CONST_INT\n \t    && CONST_OK_FOR_LETTER_P (INTVAL (recog_data.operand[i]), 'K'))\n@@ -12324,18 +12292,11 @@ ix86_attr_length_address_default (rtx insn)\n   if (get_attr_type (insn) == TYPE_LEA)\n     {\n       rtx set = PATTERN (insn);\n-      if (GET_CODE (set) == SET)\n-\t;\n-      else if (GET_CODE (set) == PARALLEL\n-\t       && GET_CODE (XVECEXP (set, 0, 0)) == SET)\n+\n+      if (GET_CODE (set) == PARALLEL)\n \tset = XVECEXP (set, 0, 0);\n-      else\n-\t{\n-#ifdef ENABLE_CHECKING\n-\t  abort ();\n-#endif\n-\t  return 0;\n-\t}\n+\n+      gcc_assert (GET_CODE (set) == SET);\n \n       return memory_address_length (SET_SRC (set));\n     }\n@@ -12430,13 +12391,12 @@ ix86_agi_dependant (rtx insn, rtx dep_insn, enum attr_type insn_type)\n       && TARGET_PENTIUM)\n     {\n       addr = PATTERN (insn);\n-      if (GET_CODE (addr) == SET)\n-\t;\n-      else if (GET_CODE (addr) == PARALLEL\n-\t       && GET_CODE (XVECEXP (addr, 0, 0)) == SET)\n+\n+      if (GET_CODE (addr) == PARALLEL)\n \taddr = XVECEXP (addr, 0, 0);\n-      else\n-\tabort ();\n+      \n+      gcc_assert (GET_CODE (addr) == SET);\n+      \n       addr = SET_SRC (addr);\n     }\n   else\n@@ -12808,8 +12768,7 @@ x86_initialize_trampoline (rtx tramp, rtx fnaddr, rtx cxt)\n       emit_move_insn (gen_rtx_MEM (QImode, plus_constant (tramp, offset+2)),\n \t\t      gen_int_mode (0xe3, QImode));\n       offset += 3;\n-      if (offset > TRAMPOLINE_SIZE)\n-\tabort ();\n+      gcc_assert (offset <= TRAMPOLINE_SIZE);\n     }\n \n #ifdef ENABLE_EXECUTE_STACK\n@@ -13985,7 +13944,7 @@ ix86_init_mmx_sse_builtins (void)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       /* Override for comparisons.  */\n@@ -14313,11 +14272,10 @@ ix86_expand_binop_builtin (enum insn_code icode, tree arglist, rtx target)\n       op1 = gen_lowpart (TImode, x);\n     }\n \n-  /* In case the insn wants input operands in modes different from\n-     the result, abort.  */\n-  if ((GET_MODE (op0) != mode0 && GET_MODE (op0) != VOIDmode)\n-      || (GET_MODE (op1) != mode1 && GET_MODE (op1) != VOIDmode))\n-    abort ();\n+  /* The insn must want input operands in the same modes as the\n+     result.  */\n+  gcc_assert ((GET_MODE (op0) == mode0 || GET_MODE (op0) == VOIDmode)\n+\t      && (GET_MODE (op1) == mode1 || GET_MODE (op1) == VOIDmode));\n \n   if (!(*insn_data[icode].operand[1].predicate) (op0, mode0))\n     op0 = copy_to_mode_reg (mode0, op0);\n@@ -15111,8 +15069,8 @@ rtx\n ix86_force_to_memory (enum machine_mode mode, rtx operand)\n {\n   rtx result;\n-  if (!reload_completed)\n-    abort ();\n+  \n+  gcc_assert (reload_completed);\n   if (TARGET_RED_ZONE)\n     {\n       result = gen_rtx_MEM (mode,\n@@ -15138,7 +15096,7 @@ ix86_force_to_memory (enum machine_mode mode, rtx operand)\n \t\t\t\t   operand));\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       result = gen_rtx_MEM (mode, stack_pointer_rtx);\n     }\n@@ -15178,7 +15136,7 @@ ix86_force_to_memory (enum machine_mode mode, rtx operand)\n \t\t\t\t   operand));\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       result = gen_rtx_MEM (mode, stack_pointer_rtx);\n     }\n@@ -15298,8 +15256,7 @@ ix86_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n       || MAYBE_MMX_CLASS_P (class1) != MMX_CLASS_P (class1)\n       || MAYBE_MMX_CLASS_P (class2) != MMX_CLASS_P (class2))\n     {\n-      if (strict)\n-\tabort ();\n+      gcc_assert (!strict);\n       return true;\n     }\n \n@@ -16419,8 +16376,7 @@ ix86_avoid_jump_misspredicts (void)\n \t    isjump = 0;\n \t  nbytes -= min_insn_size (start);\n \t}\n-      if (njumps < 0)\n-\tabort ();\n+      gcc_assert (njumps >= 0);\n       if (dump_file)\n         fprintf (dump_file, \"Interval %i to %i has %i bytes\\n\",\n \t\tINSN_UID (start), INSN_UID (insn), nbytes);\n@@ -16545,9 +16501,7 @@ x86_emit_floatuns (rtx operands[2])\n   enum machine_mode mode, inmode;\n \n   inmode = GET_MODE (operands[1]);\n-  if (inmode != SImode\n-      && inmode != DImode)\n-    abort ();\n+  gcc_assert (inmode == SImode || inmode == DImode);\n \n   out = operands[0];\n   in = force_reg (inmode, operands[1]);"}, {"sha": "bd83e0bef2b41cbd40342e1edc3e9ee9124d92a8", "filename": "gcc/config/i386/netware.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0396b7941243ea231a4f812de072c89ca2cd345/gcc%2Fconfig%2Fi386%2Fnetware.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0396b7941243ea231a4f812de072c89ca2cd345/gcc%2Fconfig%2Fi386%2Fnetware.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fnetware.c?ref=d0396b7941243ea231a4f812de072c89ca2cd345", "patch": "@@ -150,7 +150,7 @@ gen_regparm_prefix (tree decl, unsigned nregs)\n \n   if (nregs > total / BITS_PER_WORD)\n     nregs = total / BITS_PER_WORD;\n-  if (nregs > 9) abort();\n+  gcc_assert (nregs <= 9);\n   newsym = alloca (2 + strlen (asmname) + 1 + 1);\n   return IDENTIFIER_POINTER (get_identifier_with_length (newsym,\n \tsprintf (newsym, \"_%u@%s\", nregs, asmname)));\n@@ -201,8 +201,12 @@ i386_nlm_strip_name_encoding (const char *str)\n \t  ++name;\n \t  if (ISDIGIT (p[1]))\n \t    name = ggc_alloc_string (name, p - name);\n-\t  else if (!ISDIGIT (*name) || ++name != p)\n-\t    abort();\n+\t  else\n+\t    {\n+\t      gcc_assert (ISDIGIT (*name));\n+\t      name++;\n+\t      gcc_assert (name == p);\n+\t    }\n \t}\n     }\n   return name;"}, {"sha": "0d752383458dbc7c61181a52dff17d74e04b797d", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0396b7941243ea231a4f812de072c89ca2cd345/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0396b7941243ea231a4f812de072c89ca2cd345/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=d0396b7941243ea231a4f812de072c89ca2cd345", "patch": "@@ -273,13 +273,10 @@ i386_pe_mark_dllexport (tree decl)\n   tree idp;\n \n   rtlname = XEXP (DECL_RTL (decl), 0);\n-  if (GET_CODE (rtlname) == SYMBOL_REF)\n-    oldname = XSTR (rtlname, 0);\n-  else if (GET_CODE (rtlname) == MEM\n-\t   && GET_CODE (XEXP (rtlname, 0)) == SYMBOL_REF)\n-    oldname = XSTR (XEXP (rtlname, 0), 0);\n-  else\n-    abort ();\n+  if (GET_CODE (rtlname) == MEM)\n+    rtlname = XEXP (rtlname, 0);\n+  gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n+  oldname = XSTR (rtlname, 0);\n   if (i386_pe_dllimport_name_p (oldname))\n     {\n       warning (\"%Jinconsistent dll linkage for '%D', dllexport assumed.\",\n@@ -317,13 +314,10 @@ i386_pe_mark_dllimport (tree decl)\n   rtx symref;\n \n   rtlname = XEXP (DECL_RTL (decl), 0);\n-  if (GET_CODE (rtlname) == SYMBOL_REF)\n-    oldname = XSTR (rtlname, 0);\n-  else if (GET_CODE (rtlname) == MEM\n-\t   && GET_CODE (XEXP (rtlname, 0)) == SYMBOL_REF)\n-    oldname = XSTR (XEXP (rtlname, 0), 0);\n-  else\n-    abort ();\n+  if (GET_CODE (rtlname) == MEM)\n+    rtlname = XEXP (rtlname, 0);\n+  gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n+  oldname = XSTR (rtlname, 0);\n   if (i386_pe_dllexport_name_p (oldname))\n     {\n       error (\"%qs declared as both exported to and imported from a DLL\",\n@@ -332,14 +326,9 @@ i386_pe_mark_dllimport (tree decl)\n     }\n   else if (i386_pe_dllimport_name_p (oldname))\n     {\n-      /* Already done, but do a sanity check to prevent assembler errors.  */\n-      if (!DECL_EXTERNAL (decl) || !TREE_PUBLIC (decl))\n-\t{\n-\t  error (\"%Jfailure in redeclaration of '%D': dllimport'd \"\n-\t\t \"symbol lacks external linkage.\", decl, decl);\n-\t  abort();\n-\t}\n-      return;\n+      /* Already done, but do a sanity check to prevent assembler\n+\t errors.  */\n+      gcc_assert (DECL_EXTERNAL (decl) && TREE_PUBLIC (decl));\n     }\n \n   newname = alloca (strlen (DLL_IMPORT_PREFIX) + strlen (oldname) + 1);"}]}