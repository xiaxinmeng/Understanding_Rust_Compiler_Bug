{"sha": "813674e01f5710ea6e59ecbbf03e302c34ecf65d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODEzNjc0ZTAxZjU3MTBlYTZlNTllY2JiZjAzZTMwMmMzNGVjZjY1ZA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2002-06-22T03:08:21Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2002-06-22T03:08:21Z"}, "message": "genautomata.c (copy_node, [...]): Const-ify.\n\n\t* genautomata.c (copy_node, VLA_PTR_CREATE, VLA_PTR_EXPAND,\n\tVLA_PTR_ADD, VLA_HWINT_CREATE, VLA_HWINT_EXPAND, VLA_HWINT_ADD,\n\tDECL_UNIT, DECL_BYPASS, DECL_AUTOMATON, DECL_EXCL, DECL_PRESENCE,\n\tDECL_ABSENCE, DECL_RESERV, DECL_INSN_RESERV, REGEXP_UNIT,\n\tREGEXP_RESERV, REGEXP_SEQUENCE, REGEXP_REPEAT, REGEXP_ALLOF,\n\tREGEXP_ONEOF, check_name): Const-ify.\n\nFrom-SVN: r54898", "tree": {"sha": "6f8c236b1ad7bdf42361399afe01dbf864cf5d12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f8c236b1ad7bdf42361399afe01dbf864cf5d12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/813674e01f5710ea6e59ecbbf03e302c34ecf65d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/813674e01f5710ea6e59ecbbf03e302c34ecf65d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/813674e01f5710ea6e59ecbbf03e302c34ecf65d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/813674e01f5710ea6e59ecbbf03e302c34ecf65d/comments", "author": null, "committer": null, "parents": [{"sha": "224a45d026376a32418599386be3becc0ef62714", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/224a45d026376a32418599386be3becc0ef62714", "html_url": "https://github.com/Rust-GCC/gccrs/commit/224a45d026376a32418599386be3becc0ef62714"}], "stats": {"total": 64, "additions": 36, "deletions": 28}, "files": [{"sha": "ea2f1e5028dd53dc9c1882e2a516f1a07793981c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/813674e01f5710ea6e59ecbbf03e302c34ecf65d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/813674e01f5710ea6e59ecbbf03e302c34ecf65d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=813674e01f5710ea6e59ecbbf03e302c34ecf65d", "patch": "@@ -1,3 +1,12 @@\n+2002-06-21  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* genautomata.c (copy_node, VLA_PTR_CREATE, VLA_PTR_EXPAND,\n+\tVLA_PTR_ADD, VLA_HWINT_CREATE, VLA_HWINT_EXPAND, VLA_HWINT_ADD,\n+\tDECL_UNIT, DECL_BYPASS, DECL_AUTOMATON, DECL_EXCL, DECL_PRESENCE,\n+\tDECL_ABSENCE, DECL_RESERV, DECL_INSN_RESERV, REGEXP_UNIT,\n+\tREGEXP_RESERV, REGEXP_SEQUENCE, REGEXP_REPEAT, REGEXP_ALLOF,\n+\tREGEXP_ONEOF, check_name): Const-ify.\n+\n 2002-06-21  Matt Thomas  <matt@3am-software.com>\n \n \t* config/vax/vax.c (vax_output_function_prologue): Use"}, {"sha": "d5a746095388c7296f01e17045a5038068572934", "filename": "gcc/genautomata.c", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/813674e01f5710ea6e59ecbbf03e302c34ecf65d/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/813674e01f5710ea6e59ecbbf03e302c34ecf65d/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=813674e01f5710ea6e59ecbbf03e302c34ecf65d", "patch": "@@ -211,7 +211,7 @@ typedef struct state_ainsn_table *state_ainsn_table_t;\n    function `main'.  */\n \n static void *create_node            PARAMS ((size_t));\n-static void *copy_node              PARAMS ((void *, size_t));\n+static void *copy_node              PARAMS ((const void *, size_t));\n static char *check_name             PARAMS ((char *, pos_t));\n static char *next_sep_el            PARAMS ((char **, int, int));\n static int n_sep_els                PARAMS ((char *, int, int));\n@@ -530,7 +530,7 @@ static struct obstack irp;\n #define VLA_PTR_CREATE(vla, allocated_length, name)                   \t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {                                                                \t\\\n-      vla_ptr_t *vla_ptr = &(vla);                                      \\\n+      vla_ptr_t *const vla_ptr = &(vla);                                \\\n                                                                       \t\\\n       VARRAY_GENERIC_PTR_INIT (vla_ptr->varray, allocated_length, name);\\\n       vla_ptr->length = 0;                                              \\\n@@ -557,8 +557,8 @@ static struct obstack irp;\n    undefined.  */\n #define VLA_PTR_EXPAND(vla, n)                                        \\\n   do {                                                                \\\n-    vla_ptr_t *expand_vla_ptr = &(vla);                               \\\n-    size_t new_length = (n) + expand_vla_ptr->length;                 \\\n+    vla_ptr_t *const expand_vla_ptr = &(vla);                         \\\n+    const size_t new_length = (n) + expand_vla_ptr->length;           \\\n                                                                       \\\n     if (VARRAY_SIZE (expand_vla_ptr->varray) < new_length)            \\\n       VARRAY_GROW (expand_vla_ptr->varray,                            \\\n@@ -570,7 +570,7 @@ static struct obstack irp;\n /* Add element to the end of the vla.  */\n #define VLA_PTR_ADD(vla, ptr)                                         \\\n   do {                                                                \\\n-    vla_ptr_t *vla_ptr = &(vla);                                      \\\n+    vla_ptr_t *const vla_ptr = &(vla);                                \\\n                                                                       \\\n     VLA_PTR_EXPAND (*vla_ptr, 1);                                     \\\n     VARRAY_GENERIC_PTR (vla_ptr->varray, vla_ptr->length - 1) = (ptr);\\\n@@ -588,7 +588,7 @@ static struct obstack irp;\n \n #define VLA_HWINT_CREATE(vla, allocated_length, name)                 \\\n   do {                                                                \\\n-    vla_hwint_t *vla_ptr = &(vla);                                    \\\n+    vla_hwint_t *const vla_ptr = &(vla);                              \\\n                                                                       \\\n     VARRAY_WIDE_INT_INIT (vla_ptr->varray, allocated_length, name);   \\\n     vla_ptr->length = 0;                                              \\\n@@ -608,8 +608,8 @@ static struct obstack irp;\n \n #define VLA_HWINT_EXPAND(vla, n)                                      \\\n   do {                                                                \\\n-    vla_hwint_t *expand_vla_ptr = &(vla);                             \\\n-    size_t new_length = (n) + expand_vla_ptr->length;                 \\\n+    vla_hwint_t *const expand_vla_ptr = &(vla);                       \\\n+    const size_t new_length = (n) + expand_vla_ptr->length;           \\\n                                                                       \\\n     if (VARRAY_SIZE (expand_vla_ptr->varray) < new_length)            \\\n       VARRAY_GROW (expand_vla_ptr->varray,                            \\\n@@ -620,7 +620,7 @@ static struct obstack irp;\n \n #define VLA_HWINT_ADD(vla, ptr)                                       \\\n   do {                                                                \\\n-    vla_hwint_t *vla_ptr = &(vla);                                    \\\n+    vla_hwint_t *const vla_ptr = &(vla);                              \\\n                                                                       \\\n     VLA_HWINT_EXPAND (*vla_ptr, 1);                                   \\\n     VARRAY_WIDE_INT (vla_ptr->varray, vla_ptr->length - 1) = (ptr);   \\\n@@ -1244,56 +1244,56 @@ struct state_ainsn_table\n #if defined ENABLE_CHECKING && (GCC_VERSION >= 2007)\n \n #define DECL_UNIT(d) __extension__\t\t\t\t\t\\\n-(({ struct decl *_decl = (d);\t\t\t\t\t\t\\\n+(({ struct decl *const _decl = (d);\t\t\t\t\t\\\n      if (_decl->mode != dm_unit)\t\t\t\t\t\\\n        decl_mode_check_failed (_decl->mode, \"dm_unit\",\t\t\t\\\n \t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n      &(_decl)->decl.unit; }))\n \n #define DECL_BYPASS(d) __extension__\t\t\t\t\t\\\n-(({ struct decl *_decl = (d);\t\t\t\t\t\t\\\n+(({ struct decl *const _decl = (d);\t\t\t\t\t\\\n      if (_decl->mode != dm_bypass)\t\t\t\t\t\\\n        decl_mode_check_failed (_decl->mode, \"dm_bypass\",\t\t\\\n \t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n      &(_decl)->decl.bypass; }))\n \n #define DECL_AUTOMATON(d) __extension__\t\t\t\t\t\\\n-(({ struct decl *_decl = (d);\t\t\t\t\t\t\\\n+(({ struct decl *const _decl = (d);\t\t\t\t       \t\\\n      if (_decl->mode != dm_automaton)\t\t\t\t\t\\\n        decl_mode_check_failed (_decl->mode, \"dm_automaton\",\t\t\\\n \t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n      &(_decl)->decl.automaton; }))\n \n #define DECL_EXCL(d) __extension__\t\t\t\t\t\\\n-(({ struct decl *_decl = (d);\t\t\t\t\t\t\\\n+(({ struct decl *const _decl = (d);\t\t\t\t       \t\\\n      if (_decl->mode != dm_excl)\t\t\t\t\t\\\n        decl_mode_check_failed (_decl->mode, \"dm_excl\",\t\t\t\\\n \t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n      &(_decl)->decl.excl; }))\n \n #define DECL_PRESENCE(d) __extension__\t\t\t\t\t\\\n-(({ struct decl *_decl = (d);\t\t\t\t\t\t\\\n+(({ struct decl *const _decl = (d);\t\t\t\t\t\\\n      if (_decl->mode != dm_presence)\t\t\t\t\t\\\n        decl_mode_check_failed (_decl->mode, \"dm_presence\",\t\t\\\n \t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n      &(_decl)->decl.presence; }))\n \n #define DECL_ABSENCE(d) __extension__\t\t\t\t\t\\\n-(({ struct decl *_decl = (d);\t\t\t\t\t\t\\\n+(({ struct decl *const _decl = (d);\t\t\t\t       \t\\\n      if (_decl->mode != dm_absence)\t\t\t\t\t\\\n        decl_mode_check_failed (_decl->mode, \"dm_absence\",\t\t\\\n \t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n      &(_decl)->decl.absence; }))\n \n #define DECL_RESERV(d) __extension__\t\t\t\t\t\\\n-(({ struct decl *_decl = (d);\t\t\t\t\t\t\\\n+(({ struct decl *const _decl = (d);\t\t\t\t\t\\\n      if (_decl->mode != dm_reserv)\t\t\t\t\t\\\n-       decl_mode_check_failed (_decl->mode, \"dm_reserv\",\t\t\t\\\n+       decl_mode_check_failed (_decl->mode, \"dm_reserv\",\t\t\\\n \t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n      &(_decl)->decl.reserv; }))\n \n #define DECL_INSN_RESERV(d) __extension__\t\t\t\t\\\n-(({ struct decl *_decl = (d);\t\t\t\t\t\t\\\n+(({ struct decl *const _decl = (d);\t\t\t\t       \t\\\n      if (_decl->mode != dm_insn_reserv)\t\t\t\t\t\\\n        decl_mode_check_failed (_decl->mode, \"dm_insn_reserv\",\t\t\\\n \t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n@@ -1350,42 +1350,42 @@ decl_mode_check_failed (mode, expected_mode_str, file, line, func)\n \n \n #define REGEXP_UNIT(r) __extension__\t\t\t\t\t\\\n-(({ struct regexp *_regexp = (r);\t\t\t\t\t\\\n+(({ struct regexp *const _regexp = (r);\t\t\t\t\t\\\n      if (_regexp->mode != rm_unit)\t\t\t\t\t\\\n        regexp_mode_check_failed (_regexp->mode, \"rm_unit\",\t\t\\\n \t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n      &(_regexp)->regexp.unit; }))\n \n #define REGEXP_RESERV(r) __extension__\t\t\t\t\t\\\n-(({ struct regexp *_regexp = (r);\t\t\t\t\t\\\n+(({ struct regexp *const _regexp = (r);\t\t\t\t\t\\\n      if (_regexp->mode != rm_reserv)\t\t\t\t\t\\\n        regexp_mode_check_failed (_regexp->mode, \"rm_reserv\",\t\t\\\n \t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n      &(_regexp)->regexp.reserv; }))\n \n #define REGEXP_SEQUENCE(r) __extension__\t\t\t\t\\\n-(({ struct regexp *_regexp = (r);\t\t\t\t\t\\\n+(({ struct regexp *const _regexp = (r);\t\t\t\t\t\\\n      if (_regexp->mode != rm_sequence)\t\t\t\t\t\\\n        regexp_mode_check_failed (_regexp->mode, \"rm_sequence\",\t\t\\\n \t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n      &(_regexp)->regexp.sequence; }))\n \n #define REGEXP_REPEAT(r) __extension__\t\t\t\t\t\\\n-(({ struct regexp *_regexp = (r);\t\t\t\t\t\\\n+(({ struct regexp *const _regexp = (r);\t\t\t\t\t\\\n      if (_regexp->mode != rm_repeat)\t\t\t\t\t\\\n        regexp_mode_check_failed (_regexp->mode, \"rm_repeat\",\t\t\\\n \t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n      &(_regexp)->regexp.repeat; }))\n \n #define REGEXP_ALLOF(r) __extension__\t\t\t\t\t\\\n-(({ struct regexp *_regexp = (r);\t\t\t\t\t\\\n+(({ struct regexp *const _regexp = (r);\t\t\t\t\t\\\n      if (_regexp->mode != rm_allof)\t\t\t\t\t\\\n        regexp_mode_check_failed (_regexp->mode, \"rm_allof\",\t\t\\\n \t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n      &(_regexp)->regexp.allof; }))\n \n #define REGEXP_ONEOF(r) __extension__\t\t\t\t\t\\\n-(({ struct regexp *_regexp = (r);\t\t\t\t\t\\\n+(({ struct regexp *const _regexp = (r);\t\t\t\t\t\\\n      if (_regexp->mode != rm_oneof)\t\t\t\t\t\\\n        regexp_mode_check_failed (_regexp->mode, \"rm_oneof\",\t\t\\\n \t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n@@ -1478,11 +1478,10 @@ create_node (size)\n /* Copy IR structure (node).  */\n static void *\n copy_node (from, size)\n-     void *from;\n+     const void *from;\n      size_t size;\n {\n-  void *result;\n-  result = create_node (size);\n+  void *const result = create_node (size);\n   memcpy (result, from, size);\n   return result;\n }\n@@ -1493,7 +1492,7 @@ check_name (name, pos)\n      char * name;\n      pos_t pos ATTRIBUTE_UNUSED;\n {\n-  char *str;\n+  const char *str;\n \n   for (str = name; *str != '\\0'; str++)\n     if (*str == '\\\"')"}]}