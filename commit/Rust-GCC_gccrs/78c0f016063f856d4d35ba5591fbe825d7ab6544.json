{"sha": "78c0f016063f856d4d35ba5591fbe825d7ab6544", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhjMGYwMTYwNjNmODU2ZDRkMzViYTU1OTFmYmU4MjVkN2FiNjU0NA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-03-19T16:29:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-03-19T16:29:27Z"}, "message": "[multiple changes]\n\n2012-03-19  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch3.adb (Get_Discriminant_Value): Instead of looking\n\tat the immediate correcponsing discriminant, traverse a\n\tpotential chain of discriminants produced by type derivations.\n\t(Root_Corresponding_Discriminant): Traverse a chain of inherited\n\tdiscriminants and return the topmost discriminant.\n\n2012-03-19  Bob Duff  <duff@adacore.com>\n\n\t* debug.adb: Minor comment change.\n\t* gnat_ugn.texi: Update documentation for elaboration regarding\n\tindirect calls.\n\n2012-03-19  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): In\n\tthe case of an object of a class-wide interface type, where the\n\tdeclaration is rewritten as a renaming, call Set_Debug_Info_Needed\n\ton the renaming entity so that Materialize_Entity will be\n\tset. Also, change existing call (for other than interface cases)\n\tto call Set_Debug_Info_Needed rather than Set_Needs_Debug_Info\n\t(as specified for that flag).\n\nFrom-SVN: r185526", "tree": {"sha": "a03face93f0687dec95d67ec03cef5955cc2aca5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a03face93f0687dec95d67ec03cef5955cc2aca5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78c0f016063f856d4d35ba5591fbe825d7ab6544", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78c0f016063f856d4d35ba5591fbe825d7ab6544", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78c0f016063f856d4d35ba5591fbe825d7ab6544", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78c0f016063f856d4d35ba5591fbe825d7ab6544/comments", "author": null, "committer": null, "parents": [{"sha": "a49565158271693fa8f994ba9b35f00b9ee25028", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a49565158271693fa8f994ba9b35f00b9ee25028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a49565158271693fa8f994ba9b35f00b9ee25028"}], "stats": {"total": 115, "additions": 78, "deletions": 37}, "files": [{"sha": "5966f5ef7d9c2ec3b61fc1e86688cbdeec24a29e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c0f016063f856d4d35ba5591fbe825d7ab6544/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c0f016063f856d4d35ba5591fbe825d7ab6544/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=78c0f016063f856d4d35ba5591fbe825d7ab6544", "patch": "@@ -1,3 +1,27 @@\n+2012-03-19  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch3.adb (Get_Discriminant_Value): Instead of looking\n+\tat the immediate correcponsing discriminant, traverse a\n+\tpotential chain of discriminants produced by type derivations.\n+\t(Root_Corresponding_Discriminant): Traverse a chain of inherited\n+\tdiscriminants and return the topmost discriminant.\n+\n+2012-03-19  Bob Duff  <duff@adacore.com>\n+\n+\t* debug.adb: Minor comment change.\n+\t* gnat_ugn.texi: Update documentation for elaboration regarding\n+\tindirect calls.\n+\n+2012-03-19  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): In\n+\tthe case of an object of a class-wide interface type, where the\n+\tdeclaration is rewritten as a renaming, call Set_Debug_Info_Needed\n+\ton the renaming entity so that Materialize_Entity will be\n+\tset. Also, change existing call (for other than interface cases)\n+\tto call Set_Debug_Info_Needed rather than Set_Needs_Debug_Info\n+\t(as specified for that flag).\n+\n 2012-03-19  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_ch4.adb (Analyze_Allocator): Detect an allocator generated"}, {"sha": "032ba9dfe1e13ad28391eab06bffc1bed4c909c8", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c0f016063f856d4d35ba5591fbe825d7ab6544/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c0f016063f856d4d35ba5591fbe825d7ab6544/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=78c0f016063f856d4d35ba5591fbe825d7ab6544", "patch": "@@ -646,7 +646,8 @@ package body Debug is\n    --       elaboration model is conservative, especially regarding indirect\n    --       calls. If you say Proc'Access, it will assume you might call\n    --       Proc. This can cause elaboration cycles at bind time. This flag\n-   --       reverts to the behavior of earlier compilers.\n+   --       reverts to the behavior of earlier compilers, which ignored\n+   --       indirect calls.\n \n    --  d.W  Print out debugging information for Walk_Library_Items, including\n    --       the order in which units are walked. This is primarily for use in"}, {"sha": "9f6e56539117bb2254f7aa8629b976078462ad2f", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c0f016063f856d4d35ba5591fbe825d7ab6544/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c0f016063f856d4d35ba5591fbe825d7ab6544/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=78c0f016063f856d4d35ba5591fbe825d7ab6544", "patch": "@@ -4820,6 +4820,17 @@ package body Exp_Ch3 is\n                       Subtype_Mark        => New_Occurrence_Of (Typ, Loc),\n                       Name => Convert_Tag_To_Interface (Typ, Tag_Comp)));\n \n+                  --  If the original entity comes from source, then mark the\n+                  --  new entity as needing debug information, even though it's\n+                  --  defined by a generated renaming that does not come from\n+                  --  source, so that Materialize_Entity will be set on the\n+                  --  entity when Debug_Renaming_Declaration is called during\n+                  --  analysis.\n+\n+                  if Comes_From_Source (Def_Id) then\n+                     Set_Debug_Info_Needed (Defining_Identifier (N));\n+                  end if;\n+\n                   Analyze (N, Suppress => All_Checks);\n \n                   --  Replace internal identifier of rewritten node by the\n@@ -5065,7 +5076,7 @@ package body Exp_Ch3 is\n             --  renaming that does not come from source.\n \n             if Comes_From_Source (Defining_Identifier (N)) then\n-               Set_Needs_Debug_Info (Defining_Identifier (N));\n+               Set_Debug_Info_Needed (Defining_Identifier (N));\n             end if;\n \n             --  Now call the routine to generate debug info for the renaming"}, {"sha": "9022276aee0b1720a09342d2b7a78f3f94f48b90", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 16, "deletions": 33, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c0f016063f856d4d35ba5591fbe825d7ab6544/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c0f016063f856d4d35ba5591fbe825d7ab6544/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=78c0f016063f856d4d35ba5591fbe825d7ab6544", "patch": "@@ -601,7 +601,7 @@ Elaboration Order Handling in GNAT\n * Elaboration Issues for Library Tasks::\n * Mixing Elaboration Models::\n * What to Do If the Default Elaboration Behavior Fails::\n-* Elaboration for Access-to-Subprogram Values::\n+* Elaboration for Dispatching Calls::\n * Summary of Procedures for Elaboration Control::\n * Other Elaboration Order Considerations::\n \n@@ -23279,7 +23279,7 @@ elaboration code in your own application).\n * Elaboration Issues for Library Tasks::\n * Mixing Elaboration Models::\n * What to Do If the Default Elaboration Behavior Fails::\n-* Elaboration for Access-to-Subprogram Values::\n+* Elaboration for Dispatching Calls::\n * Summary of Procedures for Elaboration Control::\n * Other Elaboration Order Considerations::\n @end menu\n@@ -24936,39 +24936,22 @@ elaboration switch if your code is correct, and we assume that the\n C-tests are indeed correct (it is less efficient, but efficiency is\n not a factor in running the ACVC tests.)\n \n-@node Elaboration for Access-to-Subprogram Values\n-@section Elaboration for Access-to-Subprogram Values\n-@cindex Access-to-subprogram\n-\n-@noindent\n-Access-to-subprogram types (introduced in Ada 95) complicate\n-the handling of elaboration. The trouble is that it becomes\n-impossible to tell at compile time which procedure\n-is being called. This means that it is not possible for the binder\n-to analyze the elaboration requirements in this case.\n-\n-If at the point at which the access value is created\n-(i.e., the evaluation of @code{P'Access} for a subprogram @code{P}),\n-the body of the subprogram is\n-known to have been elaborated, then the access value is safe, and its use\n-does not require a check. This may be achieved by appropriate arrangement\n-of the order of declarations if the subprogram is in the current unit,\n-or, if the subprogram is in another unit, by using pragma\n-@code{Pure}, @code{Preelaborate}, or @code{Elaborate_Body}\n-on the referenced unit.\n-\n-If the referenced body is not known to have been elaborated at the point\n-the access value is created, then any use of the access value must do a\n-dynamic check, and this dynamic check will fail and raise a\n-@code{Program_Error} exception if the body has not been elaborated yet.\n-GNAT will generate the necessary checks, and in addition, if the\n-@option{-gnatwl}\n-switch is set, will generate warnings that such checks are required.\n+@node Elaboration for Dispatching Calls\n+@section Elaboration for Dispatching Calls\n+@cindex Dispatching calls\n \n-The use of dynamic dispatching for tagged types similarly generates\n-a requirement for dynamic checks, and premature calls to any primitive\n+@noindent\n+In rare cases, the static elaboration model fails to prevent\n+dispatching calls to not-yet-elaborated subprograms. In such cases, we\n+fall back to run-time checks; premature calls to any primitive\n operation of a tagged type before the body of the operation has been\n-elaborated, will result in the raising of @code{Program_Error}.\n+elaborated will raise @code{Program_Error}.\n+\n+Access-to-subprogram types, however, are handled conservatively, and\n+do not require run-time checks. This was not true in earlier versions\n+of the compiler; you can use the @option{-gnatd.U} debug switch to\n+revert to the old behavior if the new conservative behavior causes\n+elaboration cycles.\n \n @node Summary of Procedures for Elaboration Control\n @section Summary of Procedures for Elaboration Control"}, {"sha": "443c2d1048bc38b52c41be885965cd2000ba8605", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c0f016063f856d4d35ba5591fbe825d7ab6544/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c0f016063f856d4d35ba5591fbe825d7ab6544/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=78c0f016063f856d4d35ba5591fbe825d7ab6544", "patch": "@@ -15601,13 +15601,35 @@ package body Sem_Ch3 is\n       Typ_For_Constraint : Entity_Id;\n       Constraint         : Elist_Id) return Node_Id\n    is\n+      function Root_Corresponding_Discriminant\n+        (Discr : Entity_Id) return Entity_Id;\n+      --  Given a discriminant, traverse the chain of inherited discriminants\n+      --  and return the topmost discriminant.\n+\n       function Search_Derivation_Levels\n         (Ti                    : Entity_Id;\n          Discrim_Values        : Elist_Id;\n          Stored_Discrim_Values : Boolean) return Node_Or_Entity_Id;\n       --  This is the routine that performs the recursive search of levels\n       --  as described above.\n \n+      -------------------------------------\n+      -- Root_Corresponding_Discriminant --\n+      -------------------------------------\n+\n+      function Root_Corresponding_Discriminant\n+        (Discr : Entity_Id) return Entity_Id\n+      is\n+         D : Entity_Id := Discr;\n+\n+      begin\n+         while Present (Corresponding_Discriminant (D)) loop\n+            D := Corresponding_Discriminant (D);\n+         end loop;\n+\n+         return D;\n+      end Root_Corresponding_Discriminant;\n+\n       ------------------------------\n       -- Search_Derivation_Levels --\n       ------------------------------\n@@ -15782,7 +15804,7 @@ package body Sem_Ch3 is\n \n       --  ??? hack to disappear when this routine is gone\n \n-      if  Nkind (Result) = N_Defining_Identifier then\n+      if Nkind (Result) = N_Defining_Identifier then\n          declare\n             D : Entity_Id;\n             E : Elmt_Id;\n@@ -15791,7 +15813,7 @@ package body Sem_Ch3 is\n             D := First_Discriminant (Typ_For_Constraint);\n             E := First_Elmt (Constraint);\n             while Present (D) loop\n-               if Corresponding_Discriminant (D) = Discriminant then\n+               if Root_Corresponding_Discriminant (D) = Discriminant then\n                   return Node (E);\n                end if;\n "}]}