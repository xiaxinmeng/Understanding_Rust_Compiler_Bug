{"sha": "a3788dde0ed8aea741c59cc6f995ebfcb2374961", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM3ODhkZGUwZWQ4YWVhNzQxYzU5Y2M2Zjk5NWViZmNiMjM3NDk2MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-01-10T09:33:24Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-01-10T09:33:24Z"}, "message": "re PR c++/58252 (ice in gimple_get_virt_method_for_binfo with -O2)\n\n\n\tPR ipa/58252\n\tPR ipa/59226\n\t* ipa-devirt.c record_target_from_binfo): Take as argument\n\tstack of binfos and lookup matching one for virtual inheritance.\n\t(possible_polymorphic_call_targets_1): Update.\n\n\t* g++.dg/ipa/devirt-20.C: New testcase.\t\n\t* g++.dg/torture/pr58252.C: Likewise.\n\t* g++.dg/torture/pr59226.C: Likewise.\n\nFrom-SVN: r206516", "tree": {"sha": "c00d40de8dff450430f5f9dc1048fecc0b0bc1f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c00d40de8dff450430f5f9dc1048fecc0b0bc1f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3788dde0ed8aea741c59cc6f995ebfcb2374961", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3788dde0ed8aea741c59cc6f995ebfcb2374961", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3788dde0ed8aea741c59cc6f995ebfcb2374961", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3788dde0ed8aea741c59cc6f995ebfcb2374961/comments", "author": null, "committer": null, "parents": [{"sha": "6606b43e46accbdf72916ed106e16c1569c2765a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6606b43e46accbdf72916ed106e16c1569c2765a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6606b43e46accbdf72916ed106e16c1569c2765a"}], "stats": {"total": 259, "additions": 248, "deletions": 11}, "files": [{"sha": "b22e4000678c3915c65f1cbf13e79a9e15d4cbd7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3788dde0ed8aea741c59cc6f995ebfcb2374961/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3788dde0ed8aea741c59cc6f995ebfcb2374961/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a3788dde0ed8aea741c59cc6f995ebfcb2374961", "patch": "@@ -1,3 +1,11 @@\n+2014-01-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/58252\n+\tPR ipa/59226\n+\t* ipa-devirt.c record_target_from_binfo): Take as argument\n+\tstack of binfos and lookup matching one for virtual inheritance.\n+\t(possible_polymorphic_call_targets_1): Update.\n+\n 2014-01-10  Huacai Chen  <chenhc@lemote.com>\n \n \t* config/mips/driver-native.c (host_detect_local_cpu): Handle new"}, {"sha": "b0bedacd60924da21b350058a5db6ca204b5eb2d", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3788dde0ed8aea741c59cc6f995ebfcb2374961/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3788dde0ed8aea741c59cc6f995ebfcb2374961/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=a3788dde0ed8aea741c59cc6f995ebfcb2374961", "patch": "@@ -614,10 +614,8 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n    This match what get_binfo_at_offset does, but with offset\n    being unknown.\n \n-   TYPE_BINFO is binfo holding an virtual table matching\n-   BINFO's type.  In the case of single inheritance, this\n-   is binfo of BINFO's type ancestor (vtable is shared),\n-   otherwise it is binfo of BINFO's type.\n+   TYPE_BINFOS is a stack of BINFOS of types with defined\n+   virtual table seen on way from class type to BINFO.\n \n    MATCHED_VTABLES tracks virtual tables we already did lookup\n    for virtual function in. INSERTED tracks nodes we already\n@@ -630,7 +628,7 @@ static void\n record_target_from_binfo (vec <cgraph_node *> &nodes,\n \t\t\t  tree binfo,\n \t\t\t  tree otr_type,\n-\t\t\t  tree type_binfo,\n+\t\t\t  vec <tree> &type_binfos,\n \t\t\t  HOST_WIDE_INT otr_token,\n \t\t\t  tree outer_type,\n \t\t\t  HOST_WIDE_INT offset,\n@@ -642,10 +640,32 @@ record_target_from_binfo (vec <cgraph_node *> &nodes,\n   int i;\n   tree base_binfo;\n \n-  gcc_checking_assert (BINFO_VTABLE (type_binfo));\n \n+  if (BINFO_VTABLE (binfo))\n+    type_binfos.safe_push (binfo);\n   if (types_same_for_odr (type, outer_type))\n     {\n+      int i;\n+      tree type_binfo = NULL;\n+\n+      /* Lookup BINFO with virtual table.  For normal types it is always last\n+\t binfo on stack.  */\n+      for (i = type_binfos.length () - 1; i >= 0; i--)\n+\tif (BINFO_OFFSET (type_binfos[i]) == BINFO_OFFSET (binfo))\n+\t  {\n+\t    type_binfo = type_binfos[i];\n+\t    break;\n+\t  }\n+      if (BINFO_VTABLE (binfo))\n+\ttype_binfos.pop ();\n+      /* If this is duplicated BINFO for base shared by virtual inheritance,\n+\t we may not have its associated vtable.  This is not a problem, since\n+\t we will walk it on the other path.  */\n+      if (!type_binfo)\n+\t{\n+\t  gcc_assert (BINFO_VIRTUAL_P (binfo));\n+\t  return;\n+\t}\n       tree inner_binfo = get_binfo_at_offset (type_binfo,\n \t\t\t\t\t      offset, otr_type);\n       /* For types in anonymous namespace first check if the respective vtable\n@@ -676,12 +696,11 @@ record_target_from_binfo (vec <cgraph_node *> &nodes,\n     /* Walking bases that have no virtual method is pointless excercise.  */\n     if (polymorphic_type_binfo_p (base_binfo))\n       record_target_from_binfo (nodes, base_binfo, otr_type,\n-\t\t\t\t/* In the case of single inheritance,\n-\t\t\t\t   the virtual table is shared with\n-\t\t\t\t   the outer type.  */\n-\t\t\t\tBINFO_VTABLE (base_binfo) ? base_binfo : type_binfo,\n+\t\t\t\ttype_binfos, \n \t\t\t\totr_token, outer_type, offset, inserted,\n \t\t\t\tmatched_vtables, anonymous);\n+  if (BINFO_VTABLE (binfo))\n+    type_binfos.pop ();\n }\n      \n /* Lookup virtual methods matching OTR_TYPE (with OFFSET and OTR_TOKEN)\n@@ -701,11 +720,13 @@ possible_polymorphic_call_targets_1 (vec <cgraph_node *> &nodes,\n {\n   tree binfo = TYPE_BINFO (type->type);\n   unsigned int i;\n+  vec <tree> type_binfos = vNULL;\n \n-  record_target_from_binfo (nodes, binfo, otr_type, binfo, otr_token,\n+  record_target_from_binfo (nodes, binfo, otr_type, type_binfos, otr_token,\n \t\t\t    outer_type, offset,\n \t\t\t    inserted, matched_vtables,\n \t\t\t    type->anonymous_namespace);\n+  type_binfos.release ();\n   for (i = 0; i < type->derived_types.length (); i++)\n     possible_polymorphic_call_targets_1 (nodes, inserted, \n \t\t\t\t\t matched_vtables,"}, {"sha": "eaf5348c95e930af918a2a9162823d185bdd1254", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3788dde0ed8aea741c59cc6f995ebfcb2374961/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3788dde0ed8aea741c59cc6f995ebfcb2374961/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a3788dde0ed8aea741c59cc6f995ebfcb2374961", "patch": "@@ -1,3 +1,11 @@\n+2014-01-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/58252\n+\tPR ipa/59226\n+\t* g++.dg/ipa/devirt-20.C: New testcase.\t\n+\t* g++.dg/torture/pr58252.C: Likewise.\n+\t* g++.dg/torture/pr59226.C: Likewise.\n+\n 2014-01-10  Max Ostapenko  <m.ostapenko@partner.samsung.com>\n \n \t* c-c++-common/asan/no-asan-stack.c: New test."}, {"sha": "aee95147a6348c59f99f2e23ca4cf9778ac56554", "filename": "gcc/testsuite/g++.dg/ipa/devirt-20.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3788dde0ed8aea741c59cc6f995ebfcb2374961/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3788dde0ed8aea741c59cc6f995ebfcb2374961/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-20.C?ref=a3788dde0ed8aea741c59cc6f995ebfcb2374961", "patch": "@@ -0,0 +1,31 @@\n+#include <stdlib.h>\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-release_ssa\"  } */\n+namespace {\n+struct A\n+{ int a; virtual int foo() {return a;} void bar() {a=7;} };\n+struct B\n+{ int b; virtual int foo2() {return b;} void bar2() {b=9;} };\n+struct C : public virtual A, public virtual B { };\n+struct D : public virtual B, public virtual A { };\n+struct E : public C, public D { void bar2() {b=9;} }; }\n+int\n+main(void)\n+{\n+  struct E e;\n+  struct C *c = &e;\n+  struct D *d = &e;\n+  struct A *a = &e;\n+  struct B *b = &e;\n+  e.bar();\n+  e.bar2();\n+  if (e.foo() + e.foo2() != 16)\n+    abort ();\n+  if (c->foo() + d->foo2() != 16)\n+    abort ();\n+  if (a->foo() + b->foo2() != 16)\n+    abort ();\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump-not \"abort\" \"release_ssa\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"release_ssa\" } } */"}, {"sha": "d38a7a7ea4bed4feff9d5080efdc2c8561dcb47d", "filename": "gcc/testsuite/g++.dg/torture/pr58252.C", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3788dde0ed8aea741c59cc6f995ebfcb2374961/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr58252.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3788dde0ed8aea741c59cc6f995ebfcb2374961/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr58252.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr58252.C?ref=a3788dde0ed8aea741c59cc6f995ebfcb2374961", "patch": "@@ -0,0 +1,142 @@\n+// { dg-do compile }\n+// { dg-options \"-fpermissive\" }\n+typedef long unsigned int size_t;\n+       typedef bool _CORBA_Boolean;\n+         typedef unsigned int _CORBA_ULong;\n+             template <class T> class _CORBA_Sequence {\n+     public:   typedef _CORBA_Sequence<T> T_seq;\n+        inline T_seq &operator= (const T_seq &s)   {\n+         for (unsigned long i=0;\n+     i < pd_len;\n+     i++) {\n+       }\n+       }\n+       _CORBA_ULong pd_len;\n+     };\n+             template <class T> class _CORBA_Unbounded_Sequence : public _CORBA_Sequence<T> {\n+        inline _CORBA_Unbounded_Sequence_WChar() { // { dg-warning \"forbids declaration\" }\n+       }\n+     };\n+       class _CORBA_ObjRef_Var_base {\n+     };\n+         template <class T, class T_Helper> class _CORBA_ObjRef_Var : public _CORBA_ObjRef_Var_base {\n+     public:   typedef T* ptr_t;\n+       typedef T* T_ptr;\n+        inline _CORBA_ObjRef_Var() : pd_objref(T_Helper::_nil()) {\n+    }\n+       inline _CORBA_ObjRef_Var(T_ptr p) : pd_objref(p) {\n+       }\n+      private:   T_ptr pd_objref;\n+      };\n+        class omniLocalIdentity;\n+         class omniObjRef {\n+     };\n+            class omniServant {\n+      public:   virtual ~omniServant();\n+        virtual void* _ptrToInterface(const char* repoId);\n+          };\n+         namespace CORBA  {\n+      class NVList {\n+     };\n+      class Object {\n+     };\n+      struct StructMember {\n+     };\n+      class StructMemberSeq : public _CORBA_Unbounded_Sequence< StructMember > {\n+        };\n+      class _objref_IRObject :   public virtual ::CORBA::Object,   public virtual omniObjRef {\n+     };\n+      class _impl_IRObject :   public virtual omniServant {\n+      };\n+     class _objref_Container;\n+      typedef _objref_Container* Container_ptr;\n+      class _impl_Contained :   public virtual _impl_IRObject {\n+     };\n+     class _objref_ExceptionDef;\n+      typedef _objref_ExceptionDef* ExceptionDef_ptr;\n+      class ExceptionDef_Helper {\n+     public:   typedef ExceptionDef_ptr _ptr_type;\n+        static _ptr_type _nil();\n+     };\n+      typedef _CORBA_ObjRef_Var<_objref_ExceptionDef, ExceptionDef_Helper> ExceptionDef_var;\n+      class Container {\n+     public:    typedef Container_ptr _ptr_type;\n+        static const char* _PD_repoId;\n+       };\n+      class _objref_Container :   public virtual _objref_IRObject {\n+       ExceptionDef_ptr create_exception(const char* id, const char* name, const char* version, const ::CORBA::StructMemberSeq& members);\n+     };\n+      class _impl_Container :   public virtual _impl_IRObject {\n+     public:   virtual ~_impl_Container();\n+       virtual ExceptionDef_ptr create_exception(const char* id, const char* name, const char* version, const ::CORBA::StructMemberSeq& members) = 0;\n+     };\n+      class _impl_IDLType :   public virtual _impl_IRObject {\n+     };\n+      class _impl_TypedefDef :   public virtual _impl_Contained,   public virtual _impl_IDLType {\n+     };\n+      class _impl_StructDef :   public virtual _impl_TypedefDef,   public virtual _impl_Container {\n+      };\n+           }\n+          namespace PortableServer {\n+            class ServantBase : public virtual omniServant {\n+    };\n+             }\n+         namespace POA_CORBA {\n+           class IRObject :   public virtual CORBA::_impl_IRObject,   public virtual ::PortableServer::ServantBase {\n+     };\n+      class Contained :   public virtual CORBA::_impl_Contained,   public virtual IRObject {\n+     };\n+      class Container :   public virtual CORBA::_impl_Container,   public virtual IRObject {\n+     };\n+      class IDLType :   public virtual CORBA::_impl_IDLType,   public virtual IRObject {\n+     };\n+      class TypedefDef :   public virtual CORBA::_impl_TypedefDef,   public virtual Contained,     public virtual IDLType {\n+     };\n+      class StructDef :   public virtual CORBA::_impl_StructDef,   public virtual TypedefDef,     public virtual Container {\n+     public:   virtual ~StructDef();\n+     };\n+       }\n+         namespace omni {\n+     class omniOrbPOA;\n+     class giopAddress;\n+     }\n+             class omniCallDescriptor {\n+     public:   typedef void (*LocalCallFn)(omniCallDescriptor*, omniServant*);\n+        inline omniCallDescriptor(LocalCallFn lcfn, const char* op_,        int op_len_, _CORBA_Boolean oneway,        const char*const* user_excns_,        int n_user_excns_,                             _CORBA_Boolean is_upcall_)     : pd_localCall(lcfn),       pd_op(op_), pd_oplen(op_len_),       pd_user_excns(user_excns_),       pd_n_user_excns(n_user_excns_),       pd_is_oneway(oneway),       pd_is_upcall(is_upcall_),       pd_contains_values(0),       pd_first_address_used(0),       pd_current_address(0),       pd_objref(0),       pd_poa(0),       pd_localId(0),       pd_deadline_secs(0),       pd_deadline_nanosecs(0) {\n+    }\n+      private:   LocalCallFn pd_localCall;\n+       const char* pd_op;\n+       size_t pd_oplen;\n+       const char*const* pd_user_excns;\n+       int pd_n_user_excns;\n+       _CORBA_Boolean pd_is_oneway;\n+       _CORBA_Boolean pd_is_upcall;\n+       _CORBA_Boolean pd_contains_values;\n+        const omni::giopAddress* pd_first_address_used;\n+       const omni::giopAddress* pd_current_address;\n+           omniObjRef* pd_objref;\n+        omni::omniOrbPOA* pd_poa;\n+       omniLocalIdentity* pd_localId;\n+              unsigned long pd_deadline_secs;\n+       unsigned long pd_deadline_nanosecs;\n+      };\n+          class _0RL_cd_7963219a43724a61_f2000000   : public omniCallDescriptor {\n+     public:   inline _0RL_cd_7963219a43724a61_f2000000(LocalCallFn lcfn,const char* op_,size_t oplen,_CORBA_Boolean upcall=0):      omniCallDescriptor(lcfn, op_, oplen, 0, _user_exns, 0, upcall)   {\n+        }\n+         static const char* const _user_exns[];\n+       const char* arg_0;\n+       const char* arg_1;\n+       const char* arg_2;\n+       const CORBA::StructMemberSeq* arg_3;\n+       CORBA::ExceptionDef_var result;\n+     };\n+          static void _0RL_lcfn_7963219a43724a61_03000000(omniCallDescriptor* cd, omniServant* svnt) {\n+       _0RL_cd_7963219a43724a61_f2000000* tcd = (_0RL_cd_7963219a43724a61_f2000000*)cd;\n+       CORBA::_impl_Container* impl = (CORBA::_impl_Container*) svnt->_ptrToInterface(CORBA::Container::_PD_repoId);\n+       tcd->result = impl->create_exception(tcd->arg_0, tcd->arg_1, tcd->arg_2, *tcd->arg_3);\n+       }\n+         CORBA::ExceptionDef_ptr CORBA::_objref_Container::create_exception(const char* id, const char* name, const char* version, const ::CORBA::StructMemberSeq& members) {\n+       _0RL_cd_7963219a43724a61_f2000000 _call_desc(_0RL_lcfn_7963219a43724a61_03000000, \"create_exception\", 17);\n+       }\n+         POA_CORBA::StructDef::~StructDef() {\n+    }"}, {"sha": "cb0ebbe35f9fa642b6f3ef87d95cbdd670f17a36", "filename": "gcc/testsuite/g++.dg/torture/pr59226.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3788dde0ed8aea741c59cc6f995ebfcb2374961/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr59226.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3788dde0ed8aea741c59cc6f995ebfcb2374961/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr59226.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr59226.C?ref=a3788dde0ed8aea741c59cc6f995ebfcb2374961", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile }\n+struct A\n+{\n+  virtual void foo() {}\n+};\n+\n+struct B\n+{\n+  virtual void foo() {}\n+};\n+\n+struct C : virtual A {};\n+\n+struct D : virtual A, B\n+{\n+  virtual void foo() {}\n+};\n+\n+struct E : C, D\n+{\n+  virtual void foo() {}\n+};\n+\n+void bar(A* p)\n+{\n+  p->foo();\n+}"}]}