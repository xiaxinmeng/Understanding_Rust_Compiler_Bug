{"sha": "8ea4a34bd0b0a46277b5e077c89cbd86dfb09c48", "node_id": "C_kwDOANBUbNoAKDhlYTRhMzRiZDBiMGE0NjI3N2I1ZTA3N2M4OWNiZDg2ZGZiMDljNDg", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-03-05T08:50:45Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-03-05T08:50:45Z"}, "message": "PR 104732: Simplify/fix DI mode logic expansion/splitting on -m32.\n\nThis clean-up patch resolves PR testsuite/104732, the failure of the recent\ntest gcc.target/i386/pr100711-1.c on 32-bit Solaris/x86.  Rather than just\ntweak the testcase, the proposed approach is to fix the underlying problem\nby removing the \"TARGET_STV && TARGET_SSE2\" conditionals from the DI mode\nlogical operation expanders and pre-reload splitters in i386.md, which as\nI'll show generate inferior code (even a GCC 12 regression) on !TARGET_64BIT\nwhenever -mno-stv (such as Solaris) or -msse (but not -msse2).\n\nFirst a little bit of history.  In the beginning, DImode operations on\ni386 weren't defined by the machine description, and lowered during RTL\nexpansion to SI mode operations.  The with PR 65105 in 2015, -mstv was\nadded, together with a SWIM1248x mode iterator (later renamed to SWIM1248x)\ntogether with several *<code>di3_doubleword post-reload splitters that\nmade use of register allocation to perform some double word operations\nin 64-but XMM registers.  A short while later in 2016, PR 70322 added\nsimilar support for one_cmpldi2.  All of this logic was dependent upon\n\"!TARGET_64BIT && TARGET_STV && TARGET_SSE2\".  With the passing of time,\nthese conditions became irrelevant when in 2019, it was decided to split\nthese double-word patterns before reload.\nhttps://gcc.gnu.org/pipermail/gcc-patches/2019-June/523877.html\nhttps://gcc.gnu.org/pipermail/gcc-patches/2019-October/532236.html\nHence the current situation, where on most modern CPU architectures\n(where \"TARGET_STV && TARGET_SSE2\" is true), RTL is expanded with DI\nmode operations, that are then split into two SI mode instructions\nbefore reload, except on Solaris and other odd cases, where the splitting\nis to two SI mode instructions is done during RTL expansion.  By the\ntime compilation reaches register allocation both paths in theory\nproduce identical or similar code, so the vestigial legacy/logic would\nappear to be harmless.\n\nUnfortunately, there is one place where this arbitrary choice of how\nto lower DI mode doubleword operations is visible to the middle-end,\nit controls whether the backend appears to have a suitable optab, and\nthe presence (or not) of DImode optabs can influence vectorization\ncost models and veclower decisions.\n\nThe issue (and code quality regression) can be seen in this test case:\n\ntypedef long long v2di __attribute__((vector_size (16)));\nv2di x;\nvoid foo (long long a)\n{\n    v2di t = {a, a};\n    x = ~t;\n}\n\nwhich when compiled with \"-O2 -m32 -msse -march=pentiumpro\" produces:\n\nfoo:    subl    $28, %esp\n        movl    %ebx, 16(%esp)\n        movl    32(%esp), %eax\n        movl    %esi, 20(%esp)\n        movl    36(%esp), %edx\n        movl    %edi, 24(%esp)\n        movl    %eax, %esi\n        movl    %eax, %edi\n        movl    %edx, %ebx\n        movl    %edx, %ecx\n        notl    %esi\n        notl    %ebx\n        movl    %esi, (%esp)\n        notl    %edi\n        notl    %ecx\n        movl    %ebx, 4(%esp)\n        movl    20(%esp), %esi\n        movl    %edi, 8(%esp)\n        movl    16(%esp), %ebx\n        movl    %ecx, 12(%esp)\n        movl    24(%esp), %edi\n        movss   8(%esp), %xmm1\n        movss   12(%esp), %xmm2\n        movss   (%esp), %xmm0\n        movss   4(%esp), %xmm3\n        unpcklps        %xmm2, %xmm1\n        unpcklps        %xmm3, %xmm0\n        movlhps %xmm1, %xmm0\n        movaps  %xmm0, x\n        addl    $28, %esp\n        ret\n\nImportantly notice the four \"notl\" instructions.  With this patch:\n\nfoo:\tsubl    $28, %esp\n        movl    32(%esp), %edx\n        movl    36(%esp), %eax\n        notl    %edx\n        movl    %edx, (%esp)\n        notl    %eax\n        movl    %eax, 4(%esp)\n        movl    %edx, 8(%esp)\n        movl    %eax, 12(%esp)\n        movaps  (%esp), %xmm1\n        movaps  %xmm1, x\n        addl    $28, %esp\n        ret\n\nNotice only two \"notl\" instructions.  Checking with godbolt.org, GCC\ngenerated 4 NOTs in GCC 4.x and 5.x, 2 NOTs between GCC 6.x and 9.x,\nand regressed to 4 NOTs since GCC 10.x [which hopefully qualifies\nthis clean-up as suitable for stage 4].\n\nMost significantly, this patch allows pr100711-1.c to pass with\n-mno-stv, allowing pandn to be used with V2DImode on Solaris/x86.\nFingers-crossed this should reduce the number of discrepancies\nencountered supporting Solaris/x86.\n\n2022-03-05  Roger Sayle  <roger@nextmovesoftware.com>\n\t    Uro\u0161 Bizjak  <ubizjak@gmail.com>\n\ngcc/ChangeLog\n\tPR testsuite/104732\n\t* config/i386/i386.md (SWIM1248x): Renamed from SWIM1248s.\n\tInclude DI mode unconditionally.\n\t(*anddi3_doubleword): Remove && TARGET_STV && TARGET_SSE2 condition,\n\ti.e. always split on !TARGET_64BIT.\n\t(*<any_or>di3_doubleword): Likewise.\n\t(*one_cmpldi2_doubleword): Likewise.\n\t(and<mode>3 expander): Update to use SWIM1248x from SWIM1248s.\n\t(<any_or><mode>3 expander): Likewise.\n\t(one_cmpl<mode>2 expander): Likewise.\n\ngcc/testsuite/ChangeLog\n\tPR testsuite/104732\n\t* gcc.target/i386/pr104732.c: New test case.", "tree": {"sha": "b60be2b106fda9c712d9eb2584b161695b77a841", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b60be2b106fda9c712d9eb2584b161695b77a841"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ea4a34bd0b0a46277b5e077c89cbd86dfb09c48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ea4a34bd0b0a46277b5e077c89cbd86dfb09c48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ea4a34bd0b0a46277b5e077c89cbd86dfb09c48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ea4a34bd0b0a46277b5e077c89cbd86dfb09c48/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1301d7f647c7ac40da7f910aa6e790205e34bb8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1301d7f647c7ac40da7f910aa6e790205e34bb8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1301d7f647c7ac40da7f910aa6e790205e34bb8b"}], "stats": {"total": 42, "additions": 28, "deletions": 14}, "files": [{"sha": "d15170e8acf9120773348306a2a35875c291f24c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ea4a34bd0b0a46277b5e077c89cbd86dfb09c48/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ea4a34bd0b0a46277b5e077c89cbd86dfb09c48/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=8ea4a34bd0b0a46277b5e077c89cbd86dfb09c48", "patch": "@@ -1079,11 +1079,11 @@\n \t\t\t       (HI \"TARGET_HIMODE_MATH\")\n \t\t\t       SI])\n \n-;; Math-dependant integer modes with DImode (enabled for 32bit with STV).\n-(define_mode_iterator SWIM1248s\n+;; Math-dependant integer modes with DImode.\n+(define_mode_iterator SWIM1248x\n \t[(QI \"TARGET_QIMODE_MATH\")\n \t (HI \"TARGET_HIMODE_MATH\")\n-\t SI (DI \"TARGET_64BIT || (TARGET_STV && TARGET_SSE2)\")])\n+\t SI DI])\n \n ;; Math-dependant single word integer modes without QImode.\n (define_mode_iterator SWIM248 [(HI \"TARGET_HIMODE_MATH\")\n@@ -9693,9 +9693,9 @@\n ;; it should be done with splitters.\n \n (define_expand \"and<mode>3\"\n-  [(set (match_operand:SWIM1248s 0 \"nonimmediate_operand\")\n-\t(and:SWIM1248s (match_operand:SWIM1248s 1 \"nonimmediate_operand\")\n-\t\t       (match_operand:SWIM1248s 2 \"<general_szext_operand>\")))]\n+  [(set (match_operand:SWIM1248x 0 \"nonimmediate_operand\")\n+\t(and:SWIM1248x (match_operand:SWIM1248x 1 \"nonimmediate_operand\")\n+\t\t       (match_operand:SWIM1248x 2 \"<general_szext_operand>\")))]\n   \"\"\n {\n   machine_mode mode = <MODE>mode;\n@@ -9733,7 +9733,7 @@\n \t (match_operand:DI 1 \"nonimmediate_operand\")\n \t (match_operand:DI 2 \"x86_64_szext_general_operand\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_STV && TARGET_SSE2\n+  \"!TARGET_64BIT\n    && ix86_binary_operator_ok (AND, DImode, operands)\n    && ix86_pre_reload_split ()\"\n   \"#\"\n@@ -10337,9 +10337,9 @@\n ;; If this is considered useful, it should be done with splitters.\n \n (define_expand \"<code><mode>3\"\n-  [(set (match_operand:SWIM1248s 0 \"nonimmediate_operand\")\n-\t(any_or:SWIM1248s (match_operand:SWIM1248s 1 \"nonimmediate_operand\")\n-\t\t\t  (match_operand:SWIM1248s 2 \"<general_operand>\")))]\n+  [(set (match_operand:SWIM1248x 0 \"nonimmediate_operand\")\n+\t(any_or:SWIM1248x (match_operand:SWIM1248x 1 \"nonimmediate_operand\")\n+\t\t\t  (match_operand:SWIM1248x 2 \"<general_operand>\")))]\n   \"\"\n   \"ix86_expand_binary_operator (<CODE>, <MODE>mode, operands); DONE;\")\n \n@@ -10349,7 +10349,7 @@\n \t (match_operand:DI 1 \"nonimmediate_operand\")\n \t (match_operand:DI 2 \"x86_64_szext_general_operand\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_STV && TARGET_SSE2\n+  \"!TARGET_64BIT\n    && ix86_binary_operator_ok (<CODE>, DImode, operands)\n    && ix86_pre_reload_split ()\"\n   \"#\"\n@@ -11427,15 +11427,15 @@\n ;; One complement instructions\n \n (define_expand \"one_cmpl<mode>2\"\n-  [(set (match_operand:SWIM1248s 0 \"nonimmediate_operand\")\n-\t(not:SWIM1248s (match_operand:SWIM1248s 1 \"nonimmediate_operand\")))]\n+  [(set (match_operand:SWIM1248x 0 \"nonimmediate_operand\")\n+\t(not:SWIM1248x (match_operand:SWIM1248x 1 \"nonimmediate_operand\")))]\n   \"\"\n   \"ix86_expand_unary_operator (NOT, <MODE>mode, operands); DONE;\")\n \n (define_insn_and_split \"*one_cmpldi2_doubleword\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\")\n \t(not:DI (match_operand:DI 1 \"nonimmediate_operand\")))]\n-  \"!TARGET_64BIT && TARGET_STV && TARGET_SSE2\n+  \"!TARGET_64BIT\n    && ix86_unary_operator_ok (NOT, DImode, operands)\n    && ix86_pre_reload_split ()\"\n   \"#\""}, {"sha": "c8954366c6d2c5ac6bbe2965c143fb49e3dda8c6", "filename": "gcc/testsuite/gcc.target/i386/pr104732.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ea4a34bd0b0a46277b5e077c89cbd86dfb09c48/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr104732.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ea4a34bd0b0a46277b5e077c89cbd86dfb09c48/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr104732.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr104732.c?ref=8ea4a34bd0b0a46277b5e077c89cbd86dfb09c48", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target ia32 } } */\n+/* { dg-options \"-O2 -m32 -msse -march=pentiumpro\" } */\n+\n+typedef long long v2di __attribute__((vector_size (16)));\n+\n+v2di x;\n+\n+void foo (long long a)\n+{\n+    v2di t = {a, a};\n+    x = ~t;\n+}\n+\n+/* { dg-final { scan-assembler-times \"notl\" 2 } } */"}]}