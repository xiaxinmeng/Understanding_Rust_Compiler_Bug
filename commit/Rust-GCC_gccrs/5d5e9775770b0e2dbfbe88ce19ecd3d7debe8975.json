{"sha": "5d5e9775770b0e2dbfbe88ce19ecd3d7debe8975", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ1ZTk3NzU3NzBiMGUyZGJmYmU4OGNlMTllY2QzZDdkZWJlODk3NQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-23T09:51:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-23T09:51:19Z"}, "message": "[multiple changes]\n\n2009-07-23  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb (Analyze_N_Op_Rem): Assume operands are valid when\n\tchecking ranges for mod/rem to see if conditional jump will be\n\tgenerated.\n\t(Analyze_N_Op_Rem): Don't try to check actual lower bounds for\n\tgenerating special -1 test for rem, generate it whenever both\n\toperands can be negative (match circuit in Sem_Res).\n\t(Analyze_N_Op_Rem): Don't go to base type, no longer needed and\n\tdestroys memory of positive range.\n\t* sem_res.adb (Resolve_Arithmetic_Op): Assume operands are valid when\n\tchecking ranges for mod/rem to see if conditional jump will be generated\n\n2009-07-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch3.adb (Build_Equivalent_Record_Aggregate): If the type of a\n\tscalar components has non-static bounds, the equivalent aggregate\n\tcannot be built, even if the expression is static, because range checks\n\twill be generated.\n\nFrom-SVN: r149987", "tree": {"sha": "7ce25f72e0124a8a2005e43663639a9d21ed6a41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ce25f72e0124a8a2005e43663639a9d21ed6a41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d5e9775770b0e2dbfbe88ce19ecd3d7debe8975", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d5e9775770b0e2dbfbe88ce19ecd3d7debe8975", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d5e9775770b0e2dbfbe88ce19ecd3d7debe8975", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d5e9775770b0e2dbfbe88ce19ecd3d7debe8975/comments", "author": null, "committer": null, "parents": [{"sha": "27f55f3c3274e8312712ebfdada668352881aeae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27f55f3c3274e8312712ebfdada668352881aeae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27f55f3c3274e8312712ebfdada668352881aeae"}], "stats": {"total": 143, "additions": 87, "deletions": 56}, "files": [{"sha": "5026a5e5a86155ab99f5c3f8cfe4052c5a99042d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5e9775770b0e2dbfbe88ce19ecd3d7debe8975/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5e9775770b0e2dbfbe88ce19ecd3d7debe8975/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5d5e9775770b0e2dbfbe88ce19ecd3d7debe8975", "patch": "@@ -1,3 +1,23 @@\n+2009-07-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb (Analyze_N_Op_Rem): Assume operands are valid when\n+\tchecking ranges for mod/rem to see if conditional jump will be\n+\tgenerated.\n+\t(Analyze_N_Op_Rem): Don't try to check actual lower bounds for\n+\tgenerating special -1 test for rem, generate it whenever both\n+\toperands can be negative (match circuit in Sem_Res).\n+\t(Analyze_N_Op_Rem): Don't go to base type, no longer needed and\n+\tdestroys memory of positive range.\n+\t* sem_res.adb (Resolve_Arithmetic_Op): Assume operands are valid when\n+\tchecking ranges for mod/rem to see if conditional jump will be generated\n+\n+2009-07-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch3.adb (Build_Equivalent_Record_Aggregate): If the type of a\n+\tscalar components has non-static bounds, the equivalent aggregate\n+\tcannot be built, even if the expression is static, because range checks\n+\twill be generated.\n+\n 2009-07-23  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch4.adb (Expand_N_Type_Conversion): Don't promote integer"}, {"sha": "e88661db01ec6811a45c0476cb3989645e5f3a62", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5e9775770b0e2dbfbe88ce19ecd3d7debe8975/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5e9775770b0e2dbfbe88ce19ecd3d7debe8975/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=5d5e9775770b0e2dbfbe88ce19ecd3d7debe8975", "patch": "@@ -1240,8 +1240,9 @@ package body Exp_Ch3 is\n    ---------------------------------------\n \n    function Build_Equivalent_Record_Aggregate (T : Entity_Id) return Node_Id is\n-      Agg  : Node_Id;\n-      Comp : Entity_Id;\n+      Agg       : Node_Id;\n+      Comp      : Entity_Id;\n+      Comp_Type : Entity_Id;\n \n       --  Start of processing for Build_Equivalent_Record_Aggregate\n \n@@ -1269,38 +1270,40 @@ package body Exp_Ch3 is\n          --  aggregate with static components.\n \n          if Is_Array_Type (Etype (Comp)) then\n-            declare\n-               Comp_Type : constant Entity_Id := Component_Type (Etype (Comp));\n+            Comp_Type := Component_Type (Etype (Comp));\n \n-            begin\n-               if Nkind (Parent (Comp)) /= N_Component_Declaration\n-                 or else No (Expression (Parent (Comp)))\n-                 or else Nkind (Expression (Parent (Comp))) /= N_Aggregate\n-               then\n-                  Initialization_Warning (T);\n-                  return Empty;\n-\n-               elsif Is_Scalar_Type (Component_Type (Etype (Comp)))\n-                  and then\n-                    (not Compile_Time_Known_Value (Type_Low_Bound (Comp_Type))\n-                      or else not Compile_Time_Known_Value\n-                          (Type_High_Bound (Comp_Type)))\n-               then\n-                  Initialization_Warning (T);\n-                  return Empty;\n+            if Nkind (Parent (Comp)) /= N_Component_Declaration\n+              or else No (Expression (Parent (Comp)))\n+              or else Nkind (Expression (Parent (Comp))) /= N_Aggregate\n+            then\n+               Initialization_Warning (T);\n+               return Empty;\n \n-               elsif\n-                 not Static_Array_Aggregate (Expression (Parent (Comp)))\n-               then\n-                  Initialization_Warning (T);\n-                  return Empty;\n-               end if;\n-            end;\n+            elsif Is_Scalar_Type (Component_Type (Etype (Comp)))\n+               and then\n+                 (not Compile_Time_Known_Value (Type_Low_Bound (Comp_Type))\n+                   or else\n+                  not Compile_Time_Known_Value (Type_High_Bound (Comp_Type)))\n+            then\n+               Initialization_Warning (T);\n+               return Empty;\n+\n+            elsif\n+              not Static_Array_Aggregate (Expression (Parent (Comp)))\n+            then\n+               Initialization_Warning (T);\n+               return Empty;\n+            end if;\n \n          elsif Is_Scalar_Type (Etype (Comp)) then\n+            Comp_Type := Etype (Comp);\n+\n             if Nkind (Parent (Comp)) /= N_Component_Declaration\n               or else No (Expression (Parent (Comp)))\n               or else not Compile_Time_Known_Value (Expression (Parent (Comp)))\n+              or else not Compile_Time_Known_Value (Type_Low_Bound (Comp_Type))\n+              or else not\n+                Compile_Time_Known_Value (Type_High_Bound (Comp_Type))\n             then\n                Initialization_Warning (T);\n                return Empty;"}, {"sha": "dac3ca7a34a5d62221a200fdbdd9b03d7830b3b4", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5e9775770b0e2dbfbe88ce19ecd3d7debe8975/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5e9775770b0e2dbfbe88ce19ecd3d7debe8975/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=5d5e9775770b0e2dbfbe88ce19ecd3d7debe8975", "patch": "@@ -6270,8 +6270,8 @@ package body Exp_Ch4 is\n    begin\n       Binary_Op_Validity_Checks (N);\n \n-      Determine_Range (Right, ROK, Rlo, Rhi);\n-      Determine_Range (Left,  LOK, Llo, Lhi);\n+      Determine_Range (Right, ROK, Rlo, Rhi, Assume_Valid => True);\n+      Determine_Range (Left,  LOK, Llo, Lhi, Assume_Valid => True);\n \n       --  Convert mod to rem if operands are known non-negative. We do this\n       --  since it is quite likely that this will improve the quality of code,\n@@ -6865,15 +6865,15 @@ package body Exp_Ch4 is\n       Left  : constant Node_Id := Left_Opnd (N);\n       Right : constant Node_Id := Right_Opnd (N);\n \n-      LLB : Uint;\n-      Llo : Uint;\n-      Lhi : Uint;\n-      LOK : Boolean;\n-      Rlo : Uint;\n-      Rhi : Uint;\n-      ROK : Boolean;\n+      Lo : Uint;\n+      Hi : Uint;\n+      OK : Boolean;\n \n-      pragma Warnings (Off, Lhi);\n+      Lneg : Boolean;\n+      Rneg : Boolean;\n+      --  Set if corresponding operand can be negative\n+\n+      pragma Unreferenced (Hi);\n \n    begin\n       Binary_Op_Validity_Checks (N);\n@@ -6909,23 +6909,18 @@ package body Exp_Ch4 is\n       --  the remainder is always 0, and we can just ignore the left operand\n       --  completely in this case.\n \n-      Determine_Range (Right, ROK, Rlo, Rhi);\n-      Determine_Range (Left, LOK, Llo, Lhi);\n+      Determine_Range (Right, OK, Lo, Hi, Assume_Valid => True);\n+      Lneg := (not OK) or else Lo < 0;\n \n-      --  The operand type may be private (e.g. in the expansion of an\n-      --  intrinsic operation) so we must use the underlying type to get the\n-      --  bounds, and convert the literals explicitly.\n+      Determine_Range (Left,  OK, Lo, Hi, Assume_Valid => True);\n+      Rneg := (not OK) or else Lo < 0;\n \n-      LLB :=\n-        Expr_Value\n-          (Type_Low_Bound (Base_Type (Underlying_Type (Etype (Left)))));\n+      --  We won't mess with trying to find out if the left operand can really\n+      --  be the largest negative number (that's a pain in the case of private\n+      --  types and this is really marginal). We will just assume that we need\n+      --  the test if the left operand can be negative at all.\n \n-      --  Now perform the test, generating code only if needed\n-\n-      if ((not ROK) or else (Rlo <= (-1) and then (-1) <= Rhi))\n-        and then\n-         ((not LOK) or else (Llo = LLB))\n-      then\n+      if Lneg and Rneg then\n          Rewrite (N,\n            Make_Conditional_Expression (Loc,\n              Expressions => New_List ("}, {"sha": "c6a5a5ace599840533a8c1a9936b1befa50ebe26", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5e9775770b0e2dbfbe88ce19ecd3d7debe8975/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5e9775770b0e2dbfbe88ce19ecd3d7debe8975/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=5d5e9775770b0e2dbfbe88ce19ecd3d7debe8975", "patch": "@@ -4674,12 +4674,25 @@ package body Sem_Res is\n                --  Set if corresponding operand might be negative\n \n             begin\n-               Determine_Range (Left_Opnd (N), OK, Lo, Hi);\n+               Determine_Range\n+                 (Left_Opnd (N), OK, Lo, Hi, Assume_Valid => True);\n                LNeg := (not OK) or else Lo < 0;\n \n-               Determine_Range (Right_Opnd (N), OK, Lo, Hi);\n+               Determine_Range\n+                 (Right_Opnd (N), OK, Lo, Hi, Assume_Valid => True);\n                RNeg := (not OK) or else Lo < 0;\n \n+               --  Check if we will be generating conditionals. There are two\n+               --  cases where that can happen, first for REM, the only case\n+               --  is largest negative integer mod -1, where the division can\n+               --  overflow, but we still have to give the right result. The\n+               --  front end generates a test for this annoying case. Here we\n+               --  just test if both operands can be negative (that's what the\n+               --  expander does, so we match its logic here).\n+\n+               --  The second case is mod where either operand can be negative.\n+               --  In this case, the back end has to generate additonal tests.\n+\n                if (Nkind (N) = N_Op_Rem and then (LNeg and RNeg))\n                     or else\n                   (Nkind (N) = N_Op_Mod and then (LNeg or RNeg))\n@@ -4959,11 +4972,11 @@ package body Sem_Res is\n                Set_Entity (Subp, Nam);\n \n                if (Is_Array_Type (Ret_Type)\n-                     and then Component_Type (Ret_Type) /= Any_Type)\n+                    and then Component_Type (Ret_Type) /= Any_Type)\n                  or else\n                   (Is_Access_Type (Ret_Type)\n-                     and then Component_Type (Designated_Type (Ret_Type))\n-                                /= Any_Type)\n+                    and then\n+                      Component_Type (Designated_Type (Ret_Type)) /= Any_Type)\n                then\n                   if Needs_No_Actuals (Nam) then\n "}]}