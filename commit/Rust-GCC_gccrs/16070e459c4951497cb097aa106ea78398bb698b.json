{"sha": "16070e459c4951497cb097aa106ea78398bb698b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYwNzBlNDU5YzQ5NTE0OTdjYjA5N2FhMTA2ZWE3ODM5OGJiNjk4Yg==", "commit": {"author": {"name": "Andreas Tobler", "email": "a.tobler@schweiz.ch", "date": "2004-09-02T21:07:21Z"}, "committer": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2004-09-02T21:07:21Z"}, "message": "004-09-02  Andreas Tobler  <a.tobler@schweiz.ch>\n\n\t* src/powerpc/aix.S: Remove whitespaces.\n\t* src/powerpc/aix_closure.S: Likewise.\n\t* src/powerpc/asm.h: Likewise.\n\t* src/powerpc/ffi.c: Likewise.\n\t* src/powerpc/ffitarget.h: Likewise.\n\t* src/powerpc/linux64.S: Likewise.\n\t* src/powerpc/linux64_closure.S: Likewise.\n\t* src/powerpc/ppc_closure.S: Likewise.\n\t* src/powerpc/sysv.S: Likewise.\n\nFrom-SVN: r86991", "tree": {"sha": "c39a128c72847b9cb1b67c543db378552c49e23d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c39a128c72847b9cb1b67c543db378552c49e23d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16070e459c4951497cb097aa106ea78398bb698b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16070e459c4951497cb097aa106ea78398bb698b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16070e459c4951497cb097aa106ea78398bb698b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16070e459c4951497cb097aa106ea78398bb698b/comments", "author": null, "committer": null, "parents": [{"sha": "19dc705e0c81b9b626896a90b83a78f2cfece6fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19dc705e0c81b9b626896a90b83a78f2cfece6fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19dc705e0c81b9b626896a90b83a78f2cfece6fd"}], "stats": {"total": 540, "additions": 272, "deletions": 268}, "files": [{"sha": "e8456ee1a30cf2f9fe599eedad0fcad2daae544c", "filename": "libffi/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16070e459c4951497cb097aa106ea78398bb698b/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16070e459c4951497cb097aa106ea78398bb698b/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=16070e459c4951497cb097aa106ea78398bb698b", "patch": "@@ -1,3 +1,15 @@\n+2004-09-02  Andreas Tobler  <a.tobler@schweiz.ch>\n+\n+\t* src/powerpc/aix.S: Remove whitespaces.\n+\t* src/powerpc/aix_closure.S: Likewise.\n+\t* src/powerpc/asm.h: Likewise.\n+\t* src/powerpc/ffi.c: Likewise.\n+\t* src/powerpc/ffitarget.h: Likewise.\n+\t* src/powerpc/linux64.S: Likewise.\n+\t* src/powerpc/linux64_closure.S: Likewise.\n+\t* src/powerpc/ppc_closure.S: Likewise.\n+\t* src/powerpc/sysv.S: Likewise.\n+\n 2004-08-30  Anthony Green  <green@redhat.com>\n \n \t* Makefile.am: Add frv support."}, {"sha": "45502f7963e443391fcb6c5edadbdf8ba4d56352", "filename": "libffi/src/powerpc/aix.S", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16070e459c4951497cb097aa106ea78398bb698b/libffi%2Fsrc%2Fpowerpc%2Faix.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16070e459c4951497cb097aa106ea78398bb698b/libffi%2Fsrc%2Fpowerpc%2Faix.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Faix.S?ref=16070e459c4951497cb097aa106ea78398bb698b", "patch": "@@ -24,62 +24,62 @@\n    OTHER DEALINGS IN THE SOFTWARE.\n    ----------------------------------------------------------------------- */\n \n-        .set r0,0\n-        .set r1,1\n-        .set r2,2\n-        .set r3,3\n-        .set r4,4\n-        .set r5,5\n-        .set r6,6\n-        .set r7,7\n-        .set r8,8\n-        .set r9,9\n-        .set r10,10\n-        .set r11,11\n-        .set r12,12\n-        .set r13,13\n-        .set r14,14\n-        .set r15,15\n-        .set r16,16\n-        .set r17,17\n-        .set r18,18\n-        .set r19,19\n-        .set r20,20\n-        .set r21,21\n-        .set r22,22\n-        .set r23,23\n-        .set r24,24\n-        .set r25,25\n-        .set r26,26\n-        .set r27,27\n-        .set r28,28\n-        .set r29,29\n-        .set r30,30\n-        .set r31,31\n-        .set f0,0\n-        .set f1,1\n-        .set f2,2\n-        .set f3,3\n-        .set f4,4\n-        .set f5,5\n-        .set f6,6\n-        .set f7,7\n-        .set f8,8\n-        .set f9,9\n-        .set f10,10\n-        .set f11,11\n-        .set f12,12\n-        .set f13,13\n-        .set f14,14\n-        .set f15,15\n-        .set f16,16\n-        .set f17,17\n-        .set f18,18\n-        .set f19,19\n-        .set f20,20\n-        .set f21,21\n-\n-#define LIBFFI_ASM\t\n+\t.set r0,0\n+\t.set r1,1\n+\t.set r2,2\n+\t.set r3,3\n+\t.set r4,4\n+\t.set r5,5\n+\t.set r6,6\n+\t.set r7,7\n+\t.set r8,8\n+\t.set r9,9\n+\t.set r10,10\n+\t.set r11,11\n+\t.set r12,12\n+\t.set r13,13\n+\t.set r14,14\n+\t.set r15,15\n+\t.set r16,16\n+\t.set r17,17\n+\t.set r18,18\n+\t.set r19,19\n+\t.set r20,20\n+\t.set r21,21\n+\t.set r22,22\n+\t.set r23,23\n+\t.set r24,24\n+\t.set r25,25\n+\t.set r26,26\n+\t.set r27,27\n+\t.set r28,28\n+\t.set r29,29\n+\t.set r30,30\n+\t.set r31,31\n+\t.set f0,0\n+\t.set f1,1\n+\t.set f2,2\n+\t.set f3,3\n+\t.set f4,4\n+\t.set f5,5\n+\t.set f6,6\n+\t.set f7,7\n+\t.set f8,8\n+\t.set f9,9\n+\t.set f10,10\n+\t.set f11,11\n+\t.set f12,12\n+\t.set f13,13\n+\t.set f14,14\n+\t.set f15,15\n+\t.set f16,16\n+\t.set f17,17\n+\t.set f18,18\n+\t.set f19,19\n+\t.set f20,20\n+\t.set f21,21\n+\n+#define LIBFFI_ASM\n #include <fficonfig.h>\n #include <ffi.h>\n #define JUMPTARGET(name) name\n@@ -104,7 +104,7 @@ ffi_call_AIX:\n \tmr\tr8,r1\n \n \t/* Allocate the stack space we need.  */\n-\tstwux\tr1,r1,r4\t\n+\tstwux\tr1,r1,r4\n \n \t/* Save registers we use.  */\n \tmflr\tr9\n@@ -130,7 +130,7 @@ ffi_call_AIX:\n \tlwz\tr2,4(r12)\n \tlwz\tr12,0(r12)\n \tmtctr\tr12 // r12 holds address of _ffi_prep_args\n-\tbctrl \n+\tbctrl\n \tlwz     r2,20(r1)\n \n \t/* Now do the call.  */"}, {"sha": "7bf5c656063652a3f8e6d70ac08bfe6190c3e4ee", "filename": "libffi/src/powerpc/aix_closure.S", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16070e459c4951497cb097aa106ea78398bb698b/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16070e459c4951497cb097aa106ea78398bb698b/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S?ref=16070e459c4951497cb097aa106ea78398bb698b", "patch": "@@ -1,6 +1,6 @@\n /* -----------------------------------------------------------------------\n    aix_closure.S - Copyright (c) 2002 2003 Free Software Foundation, Inc.\n-   based on darwin_closure.S \n+   based on darwin_closure.S\n \n    PowerPC Assembly glue.\n \n@@ -119,10 +119,10 @@ ffi_closure_ASM:\n \tin the parents outgoing area  */\n \tstw   r3, 200(r1)\n \tstw   r4, 204(r1)\n-\tstw   r5, 208(r1) \n+\tstw   r5, 208(r1)\n \tstw   r6, 212(r1)\n \tstw   r7, 216(r1)\n-\tstw   r8, 220(r1) \n+\tstw   r8, 220(r1)\n \tstw   r9, 224(r1)\n \tstw   r10, 228(r1)\n \n@@ -135,11 +135,11 @@ ffi_closure_ASM:\n \tstfd  f6, 96(r1)\n \tstfd  f7, 104(r1)\n \tstfd  f8, 112(r1)\n-\tstfd  f9, 120(r1) \n-\tstfd  f10, 128(r1) \n-\tstfd  f11, 136(r1) \n-\tstfd  f12, 144(r1) \n-\tstfd  f13, 152(r1)  \n+\tstfd  f9, 120(r1)\n+\tstfd  f10, 128(r1)\n+\tstfd  f11, 136(r1)\n+\tstfd  f12, 144(r1)\n+\tstfd  f13, 152(r1)\n \n \t/* set up registers for the routine that actually does the work */\n \t/* get the context pointer from the trampoline */\n@@ -191,7 +191,7 @@ L..60:\n \n \n /* case double */\n-L..46:   \n+L..46:\n \tlfd f1,0(r5)\n \tb L..44\n \n@@ -233,7 +233,7 @@ L..57:\n \tb L..44\n \n /* case unsigned int16 */\n-L..58:\t\n+L..58:\n \taddi r5,r5,2\n \tlhz r3,0(r5)\n "}, {"sha": "e86e6b0914765c186fe28bd10f82db68eea3dcf4", "filename": "libffi/src/powerpc/asm.h", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16070e459c4951497cb097aa106ea78398bb698b/libffi%2Fsrc%2Fpowerpc%2Fasm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16070e459c4951497cb097aa106ea78398bb698b/libffi%2Fsrc%2Fpowerpc%2Fasm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fasm.h?ref=16070e459c4951497cb097aa106ea78398bb698b", "patch": "@@ -1,9 +1,7 @@\n /* -----------------------------------------------------------------------\n    asm.h - Copyright (c) 1998 Geoffrey Keating\n-   \n-   PowerPC Assembly glue.\n \n-   $Id: asm.h,v 1.1.1.1 1998/11/29 16:48:16 green Exp $\n+   PowerPC Assembly glue.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -50,12 +48,12 @@\n #ifdef PIC\n #define CALL_MCOUNT\t\t\t\t\t\t\t      \\\n   .pushsection;\t\t\t\t\t\t\t\t      \\\n-  .section \".data\";    \t\t\t\t\t\t\t      \\\n+  .section \".data\";\t\t\t\t\t\t\t      \\\n   .align ALIGNARG(2);\t\t\t\t\t\t\t      \\\n 0:.long 0;\t\t\t\t\t\t\t\t      \\\n   .previous;\t\t\t\t\t\t\t\t      \\\n   mflr  %r0;\t\t\t\t\t\t\t\t      \\\n-  stw   %r0,4(%r1);\t       \t\t\t\t\t\t      \\\n+  stw   %r0,4(%r1);\t\t\t\t\t\t\t      \\\n   bl    _GLOBAL_OFFSET_TABLE_@local-4;\t\t\t\t\t      \\\n   mflr  %r11;\t\t\t\t\t\t\t\t      \\\n   lwz   %r0,0b@got(%r11);\t\t\t\t\t\t      \\\n@@ -67,8 +65,8 @@\n 0:.long 0;\t\t\t\t\t\t\t\t      \\\n   .previous;\t\t\t\t\t\t\t\t      \\\n   mflr  %r0;\t\t\t\t\t\t\t\t      \\\n-  lis   %r11,0b@ha;\t\t       \t\t\t\t\t      \\\n-  stw   %r0,4(%r1);\t       \t\t\t\t\t\t      \\\n+  lis   %r11,0b@ha;\t\t\t\t\t\t\t      \\\n+  stw   %r0,4(%r1);\t\t\t\t\t\t\t      \\\n   addi  %r0,%r11,0b@l;\t\t\t\t\t\t\t      \\\n   bl    JUMPTARGET(_mcount);\n #endif /* PIC */\n@@ -125,4 +123,3 @@\n \n /* Local labels stripped out by the linker.  */\n #define L(x) .L##x\n-"}, {"sha": "c8d188777c851f89887e6ebfefe2903a0514d64f", "filename": "libffi/src/powerpc/ffi.c", "status": "modified", "additions": 155, "deletions": 157, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16070e459c4951497cb097aa106ea78398bb698b/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16070e459c4951497cb097aa106ea78398bb698b/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi.c?ref=16070e459c4951497cb097aa106ea78398bb698b", "patch": "@@ -1,9 +1,7 @@\n /* -----------------------------------------------------------------------\n    ffi.c - Copyright (c) 1998 Geoffrey Keating\n-   \n-   PowerPC Foreign Function Interface \n \n-   $Id: ffi.c,v 1.1.1.1 1998/11/29 16:48:16 green Exp $\n+   PowerPC Foreign Function Interface\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -67,7 +65,7 @@ enum { ASM_NEEDS_REGISTERS = 4 };\n \n    |   Return address from ffi_call_SYSV 4bytes\t|\thigher addresses\n    |--------------------------------------------|\n-   |   Previous backchain pointer\t4\t| \tstack pointer here\n+   |   Previous backchain pointer\t4\t|       stack pointer here\n    |--------------------------------------------|<+ <<<\ton entry to\n    |   Saved r28-r31\t\t\t4*4\t| |\tffi_call_SYSV\n    |--------------------------------------------| |\n@@ -84,15 +82,15 @@ enum { ASM_NEEDS_REGISTERS = 4 };\n    |   Current backchain pointer\t4\t|-/\tduring\n    |--------------------------------------------|   <<<\tffi_call_SYSV\n \n-   */\n+*/\n \n /*@-exportheader@*/\n void ffi_prep_args_SYSV(extended_cif *ecif, unsigned *const stack)\n /*@=exportheader@*/\n {\n   const unsigned bytes = ecif->cif->bytes;\n   const unsigned flags = ecif->cif->flags;\n-  \n+\n   /* 'stacktop' points at the previous backchain pointer.  */\n   unsigned *const stacktop = stack + (bytes / sizeof(unsigned));\n \n@@ -131,10 +129,10 @@ void ffi_prep_args_SYSV(extended_cif *ecif, unsigned *const stack)\n \n   /* Deal with return values that are actually pass-by-reference.  */\n   if (flags & FLAG_RETVAL_REFERENCE)\n-  {\n-    *gpr_base++ = (unsigned long)(char *)ecif->rvalue;\n-    intarg_count++;\n-  }\n+    {\n+      *gpr_base++ = (unsigned long)(char *)ecif->rvalue;\n+      intarg_count++;\n+    }\n \n   /* Now for the arguments.  */\n   p_argv = ecif->avalue;\n@@ -192,18 +190,18 @@ void ffi_prep_args_SYSV(extended_cif *ecif, unsigned *const stack)\n \t    }\n \t  else\n \t    {\n-              /* whoops: abi states only certain register pairs\n-               * can be used for passing long long int\n-               * specifically (r3,r4), (r5,r6), (r7,r8), \n-               * (r9,r10) and if next arg is long long but\n-               * not correct starting register of pair then skip\n-               * until the proper starting register\n+\t      /* whoops: abi states only certain register pairs\n+\t       * can be used for passing long long int\n+\t       * specifically (r3,r4), (r5,r6), (r7,r8),\n+\t       * (r9,r10) and if next arg is long long but\n+\t       * not correct starting register of pair then skip\n+\t       * until the proper starting register\n \t       */\n-              if (intarg_count%2 != 0)\n-                {\n-                  intarg_count ++;\n-                  gpr_base++;\n-                }\n+\t      if (intarg_count%2 != 0)\n+\t\t{\n+\t\t  intarg_count ++;\n+\t\t  gpr_base++;\n+\t\t}\n \t      *(long long *)gpr_base = *(long long *)*p_argv;\n \t      gpr_base += 2;\n \t    }\n@@ -217,7 +215,7 @@ void ffi_prep_args_SYSV(extended_cif *ecif, unsigned *const stack)\n \t  struct_copy_size = ((*ptr)->size + 15) & ~0xF;\n \t  copy_space -= struct_copy_size;\n \t  memcpy(copy_space, (char *)*p_argv, (*ptr)->size);\n-\t  \n+\n \t  gprvalue = (unsigned long)copy_space;\n \n \t  FFI_ASSERT(copy_space > (char *)next_arg);\n@@ -276,7 +274,7 @@ enum { ASM_NEEDS_REGISTERS64 = 4 };\n    |--------------------------------------------|\n    |   CR save area\t\t\t8bytes\t|\n    |--------------------------------------------|\n-   |   Previous backchain pointer\t8\t| \tstack pointer here\n+   |   Previous backchain pointer\t8\t|\tstack pointer here\n    |--------------------------------------------|<+ <<<\ton entry to\n    |   Saved r28-r31\t\t\t4*8\t| |\tffi_call_LINUX64\n    |--------------------------------------------| |\n@@ -299,7 +297,7 @@ enum { ASM_NEEDS_REGISTERS64 = 4 };\n    |   Current backchain pointer\t8\t|-/\tduring\n    |--------------------------------------------|   <<<\tffi_call_LINUX64\n \n-   */\n+*/\n \n /*@-exportheader@*/\n void hidden ffi_prep_args64(extended_cif *ecif, unsigned long *const stack)\n@@ -314,7 +312,7 @@ void hidden ffi_prep_args64(extended_cif *ecif, unsigned long *const stack)\n   /* 'next_arg' points at the space for gpr3, and grows upwards as\n      we use GPR registers, then continues at rest.  */\n   unsigned long *const gpr_base = stacktop - ASM_NEEDS_REGISTERS64\n-\t\t\t\t  - NUM_GPR_ARG_REGISTERS64;\n+    - NUM_GPR_ARG_REGISTERS64;\n   unsigned long *const gpr_end = gpr_base + NUM_GPR_ARG_REGISTERS64;\n   unsigned long *const rest = stack + 6 + NUM_GPR_ARG_REGISTERS64;\n   unsigned long *next_arg = gpr_base;\n@@ -434,7 +432,7 @@ void hidden ffi_prep_args64(extended_cif *ecif, unsigned long *const stack)\n \tcase FFI_TYPE_SINT32:\n \t  gprvalue = *(signed int *)*p_argv;\n \t  goto putgpr;\n-\t\n+\n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n \tcase FFI_TYPE_POINTER:\n@@ -466,7 +464,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   unsigned type = cif->rtype->type;\n \n   if (cif->abi != FFI_LINUX64)\n-    {    \n+    {\n       /* All the machine-independent calculation of cif->bytes will be wrong.\n \t Redo the calculation for SYSV.  */\n \n@@ -497,10 +495,10 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n      - 32-bit (or less) integer values are returned in gpr3;\n      - Structures of size <= 4 bytes also returned in gpr3;\n      - 64-bit integer values and structures between 5 and 8 bytes are returned\n-       in gpr3 and gpr4;\n+     in gpr3 and gpr4;\n      - Single/double FP values are returned in fpr1;\n      - Larger structures and long double (if not equivalent to double) values\n-       are allocated space and a pointer is passed as the first argument.\n+     are allocated space and a pointer is passed as the first argument.\n      For LINUX64:\n      - integer values in gpr3;\n      - Structures/Unions by reference;\n@@ -674,31 +672,31 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \n /*@-declundef@*/\n /*@-exportheader@*/\n-extern void ffi_call_SYSV(/*@out@*/ extended_cif *, \n-\t\t\t  unsigned, unsigned, \n-\t\t\t  /*@out@*/ unsigned *, \n+extern void ffi_call_SYSV(/*@out@*/ extended_cif *,\n+\t\t\t  unsigned, unsigned,\n+\t\t\t  /*@out@*/ unsigned *,\n \t\t\t  void (*fn)());\n-extern void hidden ffi_call_LINUX64(/*@out@*/ extended_cif *, \n+extern void hidden ffi_call_LINUX64(/*@out@*/ extended_cif *,\n \t\t\t\t    unsigned long, unsigned long,\n-\t\t\t\t    /*@out@*/ unsigned long *, \n+\t\t\t\t    /*@out@*/ unsigned long *,\n \t\t\t\t    void (*fn)());\n /*@=declundef@*/\n /*@=exportheader@*/\n \n-void ffi_call(/*@dependent@*/ ffi_cif *cif, \n-\t      void (*fn)(), \n-\t      /*@out@*/ void *rvalue, \n+void ffi_call(/*@dependent@*/ ffi_cif *cif,\n+\t      void (*fn)(),\n+\t      /*@out@*/ void *rvalue,\n \t      /*@dependent@*/ void **avalue)\n {\n   extended_cif ecif;\n \n   ecif.cif = cif;\n   ecif.avalue = avalue;\n-  \n+\n   /* If the return value is a struct and we don't have a return\t*/\n   /* value address then we need to make one\t\t        */\n \n-  if ((rvalue == NULL) && \n+  if ((rvalue == NULL) &&\n       (cif->rtype->type == FFI_TYPE_STRUCT))\n     {\n       /*@-sysunrecog@*/\n@@ -707,15 +705,15 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n     }\n   else\n     ecif.rvalue = rvalue;\n-    \n-  \n-  switch (cif->abi) \n+\n+\n+  switch (cif->abi)\n     {\n #ifndef POWERPC64\n     case FFI_SYSV:\n     case FFI_GCC_SYSV:\n       /*@-usedef@*/\n-      ffi_call_SYSV(&ecif, -cif->bytes, \n+      ffi_call_SYSV(&ecif, -cif->bytes,\n \t\t    cif->flags, ecif.rvalue, fn);\n       /*@=usedef@*/\n       break;\n@@ -744,8 +742,8 @@ static void flush_icache(char * addr1, int size)\n   int i;\n   char * addr;\n   for (i = 0; i < size; i += MIN_CACHE_LINE_SIZE) {\n-     addr = addr1 + i;\n-     __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%0;\" : : \"r\"(addr) : \"memory\");\n+    addr = addr1 + i;\n+    __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%0;\" : : \"r\"(addr) : \"memory\");\n   }\n   addr = addr1 + size - 1;\n   __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%0;\" \"sync;\" \"isync;\" : : \"r\"(addr) : \"memory\");\n@@ -799,21 +797,21 @@ typedef union\n   double d;\n } ffi_dblfl;\n \n-int ffi_closure_helper_SYSV (ffi_closure*, void*, unsigned long*, \n+int ffi_closure_helper_SYSV (ffi_closure*, void*, unsigned long*,\n \t\t\t     ffi_dblfl*, unsigned long*);\n \n-/* Basically the trampoline invokes ffi_closure_SYSV, and on \n+/* Basically the trampoline invokes ffi_closure_SYSV, and on\n  * entry, r11 holds the address of the closure.\n  * After storing the registers that could possibly contain\n  * parameters to be passed into the stack frame and setting\n- * up space for a return value, ffi_closure_SYSV invokes the \n+ * up space for a return value, ffi_closure_SYSV invokes the\n  * following helper function to do most of the work\n  */\n \n int\n-ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue, \n-            unsigned long * pgr, ffi_dblfl * pfr, \n-            unsigned long * pst)\n+ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue,\n+\t\t\t unsigned long * pgr, ffi_dblfl * pfr,\n+\t\t\t unsigned long * pst)\n {\n   /* rvalue is the pointer to space for return value in closure assembly */\n   /* pgr is the pointer to where r3-r10 are stored in ffi_closure_SYSV */\n@@ -825,8 +823,8 @@ ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue,\n   long             i, avn;\n   long             nf;   /* number of floating registers already used */\n   long             ng;   /* number of general registers already used */\n-  ffi_cif *        cif; \n-  double           temp; \n+  ffi_cif *        cif;\n+  double           temp;\n \n   cif = closure->cif;\n   avalue = alloca(cif->nargs * sizeof(void *));\n@@ -846,132 +844,132 @@ ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue,\n   i = 0;\n   avn = cif->nargs;\n   arg_types = cif->arg_types;\n-  \n+\n   /* Grab the addresses of the arguments from the stack frame.  */\n   while (i < avn)\n     {\n       switch (arg_types[i]->type)\n \t{\n \tcase FFI_TYPE_SINT8:\n \tcase FFI_TYPE_UINT8:\n-\t/* there are 8 gpr registers used to pass values */\n-          if (ng < 8) {\n-\t     avalue[i] = (((char *)pgr)+3);\n-             ng++;\n-             pgr++;\n-          } else {\n-             avalue[i] = (((char *)pst)+3);\n-             pst++;\n-          }\n+\t  /* there are 8 gpr registers used to pass values */\n+\t  if (ng < 8) {\n+\t    avalue[i] = (((char *)pgr)+3);\n+\t    ng++;\n+\t    pgr++;\n+\t  } else {\n+\t    avalue[i] = (((char *)pst)+3);\n+\t    pst++;\n+\t  }\n \t  break;\n-           \n+\n \tcase FFI_TYPE_SINT16:\n \tcase FFI_TYPE_UINT16:\n-\t/* there are 8 gpr registers used to pass values */\n-          if (ng < 8) {\n-\t     avalue[i] = (((char *)pgr)+2);\n-             ng++;\n-             pgr++;\n-          } else {\n-             avalue[i] = (((char *)pst)+2);\n-             pst++;\n-          }\n+\t  /* there are 8 gpr registers used to pass values */\n+\t  if (ng < 8) {\n+\t    avalue[i] = (((char *)pgr)+2);\n+\t    ng++;\n+\t    pgr++;\n+\t  } else {\n+\t    avalue[i] = (((char *)pst)+2);\n+\t    pst++;\n+\t  }\n \t  break;\n \n \tcase FFI_TYPE_SINT32:\n \tcase FFI_TYPE_UINT32:\n \tcase FFI_TYPE_POINTER:\n \t  /* there are 8 gpr registers used to pass values */\n-          if (ng < 8) {\n-\t     avalue[i] = pgr;\n-             ng++;\n-             pgr++;\n-          } else {\n-             avalue[i] = pst;\n-             pst++;\n-          }\n+\t  if (ng < 8) {\n+\t    avalue[i] = pgr;\n+\t    ng++;\n+\t    pgr++;\n+\t  } else {\n+\t    avalue[i] = pst;\n+\t    pst++;\n+\t  }\n \t  break;\n \n \tcase FFI_TYPE_STRUCT:\n-\t  /* Structs are passed by reference. The address will appear in a \n+\t  /* Structs are passed by reference. The address will appear in a\n \t     gpr if it is one of the first 8 arguments.  */\n-          if (ng < 8) {\n-\t     avalue[i] = (void *) *pgr;\n-             ng++;\n-             pgr++;\n-          } else {\n-             avalue[i] = (void *) *pst;\n-             pst++;\n-          }\n+\t  if (ng < 8) {\n+\t    avalue[i] = (void *) *pgr;\n+\t    ng++;\n+\t    pgr++;\n+\t  } else {\n+\t    avalue[i] = (void *) *pst;\n+\t    pst++;\n+\t  }\n \t  break;\n \n \tcase FFI_TYPE_SINT64:\n \tcase FFI_TYPE_UINT64:\n \t  /* passing long long ints are complex, they must\n-           * be passed in suitable register pairs such as\n-           * (r3,r4) or (r5,r6) or (r6,r7), or (r7,r8) or (r9,r10)\n-           * and if the entire pair aren't available then the outgoing\n-           * parameter stack is used for both but an alignment of 8\n-           * must will be kept.  So we must either look in pgr\n-           * or pst to find the correct address for this type\n-           * of parameter.\n-           */\n-           if (ng < 7) {\n-              if (ng & 0x01) {\n-\t\t/* skip r4, r6, r8 as starting points */\n-                  ng++;\n-                  pgr++;\n-              }\n-              avalue[i] = pgr;\n-              ng+=2;\n-              pgr+=2;\n-           } else {\n-              if (((long)pst) & 4) pst++;\n-              avalue[i] = pst;\n-              pst+=2;\n-           }\n-           break;\n+\t   * be passed in suitable register pairs such as\n+\t   * (r3,r4) or (r5,r6) or (r6,r7), or (r7,r8) or (r9,r10)\n+\t   * and if the entire pair aren't available then the outgoing\n+\t   * parameter stack is used for both but an alignment of 8\n+\t   * must will be kept.  So we must either look in pgr\n+\t   * or pst to find the correct address for this type\n+\t   * of parameter.\n+\t   */\n+\t  if (ng < 7) {\n+\t    if (ng & 0x01) {\n+\t      /* skip r4, r6, r8 as starting points */\n+\t      ng++;\n+\t      pgr++;\n+\t    }\n+\t    avalue[i] = pgr;\n+\t    ng+=2;\n+\t    pgr+=2;\n+\t  } else {\n+\t    if (((long)pst) & 4) pst++;\n+\t    avalue[i] = pst;\n+\t    pst+=2;\n+\t  }\n+\t  break;\n \n \tcase FFI_TYPE_FLOAT:\n-\t    /* unfortunately float values are stored as doubles\n-             * in the ffi_closure_SYSV code (since we don't check\n-             * the type in that routine).\n-             */\n-\n-          /* there are 8 64bit floating point registers */\n-\n-          if (nf < 8) {\n-             temp = pfr->d;\n-             pfr->f = (float)temp;\n-             avalue[i] = pfr;\n-             nf++;\n-             pfr++;\n-          } else {\n+\t  /* unfortunately float values are stored as doubles\n+\t   * in the ffi_closure_SYSV code (since we don't check\n+\t   * the type in that routine).\n+\t   */\n+\n+\t  /* there are 8 64bit floating point registers */\n+\n+\t  if (nf < 8) {\n+\t    temp = pfr->d;\n+\t    pfr->f = (float)temp;\n+\t    avalue[i] = pfr;\n+\t    nf++;\n+\t    pfr++;\n+\t  } else {\n \t    /* FIXME? here we are really changing the values\n-             * stored in the original calling routines outgoing\n-             * parameter stack.  This is probably a really\n-             * naughty thing to do but...\n-             */\n-\t     avalue[i] = pst;\n-             nf++;\n-             pst+=1;\n-          }\n+\t     * stored in the original calling routines outgoing\n+\t     * parameter stack.  This is probably a really\n+\t     * naughty thing to do but...\n+\t     */\n+\t    avalue[i] = pst;\n+\t    nf++;\n+\t    pst+=1;\n+\t  }\n \t  break;\n \n \tcase FFI_TYPE_DOUBLE:\n \t  /* On the outgoing stack all values are aligned to 8 */\n-          /* there are 8 64bit floating point registers */\n-\n-          if (nf < 8) {\n-\t     avalue[i] = pfr;\n-             nf++;\n-             pfr++;\n-          } else {\n-\t     if (((long)pst) & 4) pst++;\n-\t     avalue[i] = pst;\n-             nf++;\n-             pst+=2;\n-          }\n+\t  /* there are 8 64bit floating point registers */\n+\n+\t  if (nf < 8) {\n+\t    avalue[i] = pfr;\n+\t    nf++;\n+\t    pfr++;\n+\t  } else {\n+\t    if (((long)pst) & 4) pst++;\n+\t    avalue[i] = pst;\n+\t    nf++;\n+\t    pst+=2;\n+\t  }\n \t  break;\n \n \tdefault:\n@@ -993,7 +991,7 @@ int hidden ffi_closure_helper_LINUX64 (ffi_closure*, void*, unsigned long*,\n \t\t\t\t       ffi_dblfl*);\n \n int hidden\n-ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue, \n+ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n \t\t\t    unsigned long *pst, ffi_dblfl *pfr)\n {\n   /* rvalue is the pointer to space for return value in closure assembly */\n@@ -1004,7 +1002,7 @@ ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n   void **avalue;\n   ffi_type **arg_types;\n   long i, avn;\n-  ffi_cif *cif; \n+  ffi_cif *cif;\n   ffi_dblfl *end_pfr = pfr + NUM_FPR_ARG_REGISTERS64;\n \n   cif = closure->cif;\n@@ -1021,7 +1019,7 @@ ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n   i = 0;\n   avn = cif->nargs;\n   arg_types = cif->arg_types;\n-  \n+\n   /* Grab the addresses of the arguments from the stack frame.  */\n   while (i < avn)\n     {\n@@ -1032,7 +1030,7 @@ ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n \t  avalue[i] = (char *) pst + 7;\n \t  pst++;\n \t  break;\n-           \n+\n \tcase FFI_TYPE_SINT16:\n \tcase FFI_TYPE_UINT16:\n \t  avalue[i] = (char *) pst + 6;\n@@ -1064,13 +1062,13 @@ ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n \n \tcase FFI_TYPE_FLOAT:\n \t  /* unfortunately float values are stored as doubles\n-           * in the ffi_closure_LINUX64 code (since we don't check\n-           * the type in that routine).\n-           */\n+\t   * in the ffi_closure_LINUX64 code (since we don't check\n+\t   * the type in that routine).\n+\t   */\n \n-          /* there are 13 64bit floating point registers */\n+\t  /* there are 13 64bit floating point registers */\n \n-          if (pfr < end_pfr)\n+\t  if (pfr < end_pfr)\n \t    {\n \t      double temp = pfr->d;\n \t      pfr->f = (float) temp;\n@@ -1084,7 +1082,7 @@ ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n \n \tcase FFI_TYPE_DOUBLE:\n \t  /* On the outgoing stack all values are aligned to 8 */\n-          /* there are 13 64bit floating point registers */\n+\t  /* there are 13 64bit floating point registers */\n \n \t  if (pfr < end_pfr)\n \t    {"}, {"sha": "ee87152905e4c8d2e34a4d33746230279367c01e", "filename": "libffi/src/powerpc/ffitarget.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16070e459c4951497cb097aa106ea78398bb698b/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16070e459c4951497cb097aa106ea78398bb698b/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h?ref=16070e459c4951497cb097aa106ea78398bb698b", "patch": "@@ -88,4 +88,3 @@ struct ffi_aix_trampoline_struct {\n #endif\n \n #endif\n-"}, {"sha": "18423bfc97266dcf4bf4d8c3ab52b57a67f0be54", "filename": "libffi/src/powerpc/linux64.S", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16070e459c4951497cb097aa106ea78398bb698b/libffi%2Fsrc%2Fpowerpc%2Flinux64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16070e459c4951497cb097aa106ea78398bb698b/libffi%2Fsrc%2Fpowerpc%2Flinux64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Flinux64.S?ref=16070e459c4951497cb097aa106ea78398bb698b", "patch": "@@ -1,6 +1,6 @@\n /* -----------------------------------------------------------------------\n    sysv.h - Copyright (c) 2003 Jakub Jelinek <jakub@redhat.com>\n-   \n+\n    PowerPC64 Assembly glue.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -23,7 +23,7 @@\n    OTHER DEALINGS IN THE SOFTWARE.\n    ----------------------------------------------------------------------- */\n \n-#define LIBFFI_ASM\t\n+#define LIBFFI_ASM\n #include <fficonfig.h>\n #include <ffi.h>\n "}, {"sha": "5764971fbe14c3dfc0accdfeb44ed19ecc07fb64", "filename": "libffi/src/powerpc/linux64_closure.S", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16070e459c4951497cb097aa106ea78398bb698b/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16070e459c4951497cb097aa106ea78398bb698b/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S?ref=16070e459c4951497cb097aa106ea78398bb698b", "patch": "@@ -5,15 +5,15 @@\n \t.file\t\"linux64_closure.S\"\n \n #ifdef __powerpc64__\n-        .hidden ffi_closure_LINUX64, .ffi_closure_LINUX64\n-        .globl  ffi_closure_LINUX64, .ffi_closure_LINUX64\n-        .section        \".opd\",\"aw\"\n-        .align  3\n+\t.hidden ffi_closure_LINUX64, .ffi_closure_LINUX64\n+\t.globl  ffi_closure_LINUX64, .ffi_closure_LINUX64\n+\t.section        \".opd\",\"aw\"\n+\t.align  3\n ffi_closure_LINUX64:\n-        .quad   .ffi_closure_LINUX64,.TOC.@tocbase,0\n-        .size   ffi_closure_LINUX64,24\n-        .type   .ffi_closure_LINUX64,@function\n-        .text\n+\t.quad   .ffi_closure_LINUX64,.TOC.@tocbase,0\n+\t.size   ffi_closure_LINUX64,24\n+\t.type   .ffi_closure_LINUX64,@function\n+\t.text\n .ffi_closure_LINUX64:\n .LFB1:\n \t# save general regs into parm save area\n@@ -71,7 +71,7 @@ ffi_closure_LINUX64:\n \t# so use it to look up in a table\n \t# so we know how to deal with each type\n \n-\t# look up the proper starting point in table \n+\t# look up the proper starting point in table\n \t# by using return type as offset\n \tmflr %r4\t\t# move address of .Lret to r4\n \tsldi %r3, %r3, 4\t# now multiply return type by 16"}, {"sha": "ba13fa467e4880f242c62c90ac06007e80020c24", "filename": "libffi/src/powerpc/ppc_closure.S", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16070e459c4951497cb097aa106ea78398bb698b/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16070e459c4951497cb097aa106ea78398bb698b/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S?ref=16070e459c4951497cb097aa106ea78398bb698b", "patch": "@@ -3,7 +3,7 @@\n #include <ffi.h>\n #include <powerpc/asm.h>\n \n-        .file   \"ppc_closure.S\"\n+\t.file   \"ppc_closure.S\"\n \n #ifndef __powerpc64__\n \n@@ -17,14 +17,14 @@ ENTRY(ffi_closure_SYSV)\n \n # we want to build up an areas for the parameters passed\n # in registers (both floating point and integer)\n-\t\n+\n \t# so first save gpr 3 to gpr 10 (aligned to 4)\n \tstw   %r3, 16(%r1)\n \tstw   %r4, 20(%r1)\n-\tstw   %r5, 24(%r1) \n+\tstw   %r5, 24(%r1)\n \tstw   %r6, 28(%r1)\n \tstw   %r7, 32(%r1)\n-\tstw   %r8, 36(%r1) \n+\tstw   %r8, 36(%r1)\n \tstw   %r9, 40(%r1)\n \tstw   %r10,44(%r1)\n \n@@ -41,29 +41,29 @@ ENTRY(ffi_closure_SYSV)\n \t# set up registers for the routine that actually does the work\n \t# get the context pointer from the trampoline\n \tmr %r3,%r11\n-\t\n-        # now load up the pointer to the result storage\n+\n+\t# now load up the pointer to the result storage\n \taddi %r4,%r1,112\n-\t\n+\n \t# now load up the pointer to the saved gpr registers\n-        addi %r5,%r1,16\n+\taddi %r5,%r1,16\n \n-        # now load up the pointer to the saved fpr registers */\n-        addi %r6,%r1,48\n+\t# now load up the pointer to the saved fpr registers */\n+\taddi %r6,%r1,48\n \n-\t# now load up the pointer to the outgoing parameter \n+\t# now load up the pointer to the outgoing parameter\n \t# stack in the previous frame\n \t# i.e. the previous frame pointer + 8\n \taddi %r7,%r1,152\n-\t\n-        # make the call\n+\n+\t# make the call\n \tbl JUMPTARGET(ffi_closure_helper_SYSV)\n \n \t# now r3 contains the return type\n \t# so use it to look up in a table\n \t# so we know how to deal with each type\n \n-        # look up the proper starting point in table \n+\t# look up the proper starting point in table\n \t# by using return type as offset\n \taddi %r5,%r1,112   # get pointer to results area\n \tbl .Lget_ret_type0_addr # get pointer to .Lret_type0 into LR\n@@ -108,21 +108,21 @@ ENTRY(ffi_closure_SYSV)\n \n # case FFI_TYPE_DOUBLE\n .Lret_type3:\n-        lfd %f1,0(%r5)\n+\tlfd %f1,0(%r5)\n \tb .Lfinish\n \tnop\n \tnop\n \n # case FFI_TYPE_LONGDOUBLE\n .Lret_type4:\n-        lfd %f1,0(%r5)\n+\tlfd %f1,0(%r5)\n \tb .Lfinish\n \tnop\n \tnop\n \n # case FFI_TYPE_UINT8\n .Lret_type5:\n-        lbz %r3,3(%r5)\n+\tlbz %r3,3(%r5)\n \tb .Lfinish\n \tnop\n \tnop\n@@ -190,9 +190,9 @@ ENTRY(ffi_closure_SYSV)\n \tnop\n \tnop\n \n-# case done\t\n+# case done\n .Lfinish:\n-\t\n+\n \tlwz %r0,148(%r1)\n \tmtlr %r0\n \taddi %r1,%r1,144"}, {"sha": "1689d292d8079328764c1bfb0a490e989eaca0b2", "filename": "libffi/src/powerpc/sysv.S", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16070e459c4951497cb097aa106ea78398bb698b/libffi%2Fsrc%2Fpowerpc%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16070e459c4951497cb097aa106ea78398bb698b/libffi%2Fsrc%2Fpowerpc%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fsysv.S?ref=16070e459c4951497cb097aa106ea78398bb698b", "patch": "@@ -1,9 +1,7 @@\n /* -----------------------------------------------------------------------\n    sysv.h - Copyright (c) 1998 Geoffrey Keating\n-   \n-   PowerPC Assembly glue.\n \n-   $Id: sysv.S,v 1.1.1.1 1998/11/29 16:48:16 green Exp $\n+   PowerPC Assembly glue.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -25,7 +23,7 @@\n    OTHER DEALINGS IN THE SOFTWARE.\n    ----------------------------------------------------------------------- */\n \n-#define LIBFFI_ASM\t\n+#define LIBFFI_ASM\n #include <fficonfig.h>\n #include <ffi.h>\n #include <powerpc/asm.h>"}]}