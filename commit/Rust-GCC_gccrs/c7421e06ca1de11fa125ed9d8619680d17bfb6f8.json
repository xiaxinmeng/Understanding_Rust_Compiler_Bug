{"sha": "c7421e06ca1de11fa125ed9d8619680d17bfb6f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc0MjFlMDZjYTFkZTExZmExMjVlZDlkODYxOTY4MGQxN2JmYjZmOA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-07-13T02:12:08Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-07-13T02:12:08Z"}, "message": "re PR fortran/37077 (Implement Internal Unit I/O for character KIND=4)\n\n2010-07-12  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libfortran/37077\n\t* io/read.c: Fix comment.\n\t* io/io.h (is_char4_unit): New macro.\n\t* io/unit.c (get_internal_unit): Call new function open_internal4.\n\t* io/unix.c (mem_alloc_r4): New function. (mem_alloc_w4): New function.\n\t(mem_read4): New function, temporary stub. (mem_write4): New function.\n\t(open_internal4): New function to set stream pointers to use the new\n\tmem functions.\n\t* io/transfer.c (write_block): Use new mem_alloc_w4 to access internal\n\tunits of kind=4.\n\t* io/unix.h: Add prototypes for open_internal4, mem_alloc_w4, and\n\tmem_alloc_r4.\n\t* io/write.c (memset4): New helper function. (memcpy4): New helper\n\tfunction. (write_default_char4): Use new helper functions.\n\t(write_a): Likewise. (write_l): Likewise. (write_boz): Likewise.\n\t(write_decimal): Likewise. (write_x): Likewise.\n\t(write_integer): Likewise.\n\t* io/write_float.def (output_float): Add code blocks to handle internal\n\tunit kind=4 output utilizing gfc_char4_t pointers. (write_infnan): Use\n\tnew helper functions. (OUTPUT_FLOAT_FMT_G): Update this macro likewise.\n\nFrom-SVN: r162123", "tree": {"sha": "708fe1e3e6e8349ec20c2bbbb436fa48ee645bd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/708fe1e3e6e8349ec20c2bbbb436fa48ee645bd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7421e06ca1de11fa125ed9d8619680d17bfb6f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7421e06ca1de11fa125ed9d8619680d17bfb6f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7421e06ca1de11fa125ed9d8619680d17bfb6f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/comments", "author": null, "committer": null, "parents": [{"sha": "c8dce2cfddf0baf62bf56c2d5a49e1dfcdda0231", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8dce2cfddf0baf62bf56c2d5a49e1dfcdda0231", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8dce2cfddf0baf62bf56c2d5a49e1dfcdda0231"}], "stats": {"total": 644, "additions": 545, "deletions": 99}, "files": [{"sha": "f1ae1ea3a9d3fd3d8cf665473a84bb1330ddca02", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=c7421e06ca1de11fa125ed9d8619680d17bfb6f8", "patch": "@@ -1,3 +1,26 @@\n+2010-07-12  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libfortran/37077\n+\t* io/read.c: Fix comment.\n+\t* io/io.h (is_char4_unit): New macro.\n+\t* io/unit.c (get_internal_unit): Call new function open_internal4.\n+\t* io/unix.c (mem_alloc_r4): New function. (mem_alloc_w4): New function.\n+\t(mem_read4): New function, temporary stub. (mem_write4): New function.\n+\t(open_internal4): New function to set stream pointers to use the new\n+\tmem functions.\n+\t* io/transfer.c (write_block): Use new mem_alloc_w4 to access internal\n+\tunits of kind=4.\n+\t* io/unix.h: Add prototypes for open_internal4, mem_alloc_w4, and\n+\tmem_alloc_r4.\n+\t* io/write.c (memset4): New helper function. (memcpy4): New helper\n+\tfunction. (write_default_char4): Use new helper functions.\n+\t(write_a): Likewise. (write_l): Likewise. (write_boz): Likewise.\n+\t(write_decimal): Likewise. (write_x): Likewise.\n+\t(write_integer): Likewise.\n+\t* io/write_float.def (output_float): Add code blocks to handle internal\n+\tunit kind=4 output utilizing gfc_char4_t pointers. (write_infnan): Use\n+\tnew helper functions. (OUTPUT_FLOAT_FMT_G): Update this macro likewise.\n+\n 2010-07-12  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* config/fpu-387.h [__sun__ && __svr4__] Include <signal.h>,"}, {"sha": "fbc2fa354ab69428ba430fda8f8cdacff6782f2b", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=c7421e06ca1de11fa125ed9d8619680d17bfb6f8", "patch": "@@ -59,6 +59,8 @@ struct gfc_unit;\n \n #define is_stream_io(dtp) ((dtp)->u.p.current_unit->flags.access == ACCESS_STREAM)\n \n+#define is_char4_unit(dtp) ((dtp)->u.p.unit_is_internal && (dtp)->common.unit)\n+\n /* The array_loop_spec contains the variables for the loops over index ranges\n    that are encountered.  Since the variables can be negative, ssize_t\n    is used.  */"}, {"sha": "92983d51278abee3fd6e1709e90e6391bda5844d", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=c7421e06ca1de11fa125ed9d8619680d17bfb6f8", "patch": "@@ -40,7 +40,7 @@ typedef unsigned char uchar;\n \n \n /* set_integer()-- All of the integer assignments come here to\n- * actually place the value into memory.  */\n+   actually place the value into memory.  */\n \n void\n set_integer (void *dest, GFC_INTEGER_LARGEST value, int length)"}, {"sha": "a6e699d4a33f698345e14057c4bd2d3b4f3af60f", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=c7421e06ca1de11fa125ed9d8619680d17bfb6f8", "patch": "@@ -177,18 +177,6 @@ current_mode (st_parameter_dt *dtp)\n \n /* Mid level data transfer statements.  */\n \n-/* When reading sequential formatted records we have a problem.  We\n-   don't know how long the line is until we read the trailing newline,\n-   and we don't want to read too much.  If we read too much, we might\n-   have to do a physical seek backwards depending on how much data is\n-   present, and devices like terminals aren't seekable and would cause\n-   an I/O error.\n-\n-   Given this, the solution is to read a byte at a time, stopping if\n-   we hit the newline.  For small allocations, we use a static buffer.\n-   For larger allocations, we are forced to allocate memory on the\n-   heap.  Hopefully this won't happen very often.  */\n-   \n /* Read sequential file - internal unit  */\n \n static char *\n@@ -215,6 +203,7 @@ read_sf_internal (st_parameter_dt *dtp, int * length)\n \n   lorig = *length;\n   base = mem_alloc_r (dtp->u.p.current_unit->s, length);\n+\n   if (unlikely (lorig > *length))\n     {\n       hit_eof (dtp);\n@@ -230,6 +219,18 @@ read_sf_internal (st_parameter_dt *dtp, int * length)\n \n }\n \n+/* When reading sequential formatted records we have a problem.  We\n+   don't know how long the line is until we read the trailing newline,\n+   and we don't want to read too much.  If we read too much, we might\n+   have to do a physical seek backwards depending on how much data is\n+   present, and devices like terminals aren't seekable and would cause\n+   an I/O error.\n+\n+   Given this, the solution is to read a byte at a time, stopping if\n+   we hit the newline.  For small allocations, we use a static buffer.\n+   For larger allocations, we are forced to allocate memory on the\n+   heap.  Hopefully this won't happen very often.  */\n+\n /* Read sequential file - external unit */\n \n static char *\n@@ -639,16 +640,19 @@ write_block (st_parameter_dt *dtp, int length)\n \n   if (is_internal_unit (dtp))\n     {\n-    dest = mem_alloc_w (dtp->u.p.current_unit->s, &length);\n+      if (dtp->common.unit) /* char4 internal unit.  */\n+\tdest = mem_alloc_w4 (dtp->u.p.current_unit->s, &length);\n+      else\n+\tdest = mem_alloc_w (dtp->u.p.current_unit->s, &length);\n \n-    if (dest == NULL)\n-      {\n-        generate_error (&dtp->common, LIBERROR_END, NULL);\n-        return NULL;\n-      }\n+      if (dest == NULL)\n+\t{\n+          generate_error (&dtp->common, LIBERROR_END, NULL);\n+          return NULL;\n+\t}\n \n-    if (unlikely (dtp->u.p.current_unit->endfile == AT_ENDFILE))\n-      generate_error (&dtp->common, LIBERROR_END, NULL);\n+      if (unlikely (dtp->u.p.current_unit->endfile == AT_ENDFILE))\n+\tgenerate_error (&dtp->common, LIBERROR_END, NULL);\n     }\n   else\n     {"}, {"sha": "4e7dc5f3d122dcf49d43010e98cbf9b22d89ed69", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=c7421e06ca1de11fa125ed9d8619680d17bfb6f8", "patch": "@@ -423,9 +423,13 @@ get_internal_unit (st_parameter_dt *dtp)\n     }\n \n   /* Set initial values for unit parameters.  */\n+  if (dtp->common.unit)\n+    iunit->s = open_internal4 (dtp->internal_unit - start_record,\n+\t\t\t       dtp->internal_unit_len, -start_record);\n+  else\n+    iunit->s = open_internal (dtp->internal_unit - start_record,\n+\t\t\t      dtp->internal_unit_len, -start_record);\n \n-  iunit->s = open_internal (dtp->internal_unit - start_record,\n-\t\t\t    dtp->internal_unit_len, -start_record);\n   iunit->bytes_left = iunit->recl;\n   iunit->last_record=0;\n   iunit->maxrec=0;"}, {"sha": "65decce1be36381c24ad49ef6d39304af9d15a9e", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 111, "deletions": 6, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=c7421e06ca1de11fa125ed9d8619680d17bfb6f8", "patch": "@@ -598,7 +598,6 @@ buf_init (unix_stream * s)\n \n *********************************************************************/\n \n-\n char *\n mem_alloc_r (stream * strm, int * len)\n {\n@@ -619,6 +618,26 @@ mem_alloc_r (stream * strm, int * len)\n }\n \n \n+char *\n+mem_alloc_r4 (stream * strm, int * len)\n+{\n+  unix_stream * s = (unix_stream *) strm;\n+  gfc_offset n;\n+  gfc_offset where = s->logical_offset;\n+\n+  if (where < s->buffer_offset || where > s->buffer_offset + s->active)\n+    return NULL;\n+\n+  n = s->buffer_offset + s->active - where;\n+  if (*len > n)\n+    *len = n;\n+\n+  s->logical_offset = where + *len;\n+\n+  return s->buffer + (where - s->buffer_offset) * 4;\n+}\n+\n+\n char *\n mem_alloc_w (stream * strm, int * len)\n {\n@@ -640,7 +659,27 @@ mem_alloc_w (stream * strm, int * len)\n }\n \n \n-/* Stream read function for internal units.  */\n+char *\n+mem_alloc_w4 (stream * strm, int * len)\n+{\n+  unix_stream * s = (unix_stream *) strm;\n+  gfc_offset m;\n+  gfc_offset where = s->logical_offset;\n+\n+  m = where + *len;\n+\n+  if (where < s->buffer_offset)\n+    return NULL;\n+\n+  if (m > s->file_length)\n+    return NULL;\n+\n+  s->logical_offset = m;\n+  return s->buffer + (where - s->buffer_offset) * 4;\n+}\n+\n+\n+/* Stream read function for character(kine=1) internal units.  */\n \n static ssize_t\n mem_read (stream * s, void * buf, ssize_t nbytes)\n@@ -659,9 +698,26 @@ mem_read (stream * s, void * buf, ssize_t nbytes)\n }\n \n \n-/* Stream write function for internal units. This is not actually used\n-   at the moment, as all internal IO is formatted and the formatted IO\n-   routines use mem_alloc_w_at.  */\n+/* Stream read function for chracter(kind=4) internal units.  */\n+\n+static ssize_t\n+mem_read4 (stream * s, void * buf, ssize_t nbytes)\n+{\n+  void *p;\n+  int nb = nbytes;\n+\n+  p = mem_alloc_r (s, &nb);\n+  if (p)\n+    {\n+      memcpy (buf, p, nb);\n+      return (ssize_t) nb;\n+    }\n+  else\n+    return 0;\n+}\n+\n+\n+/* Stream write function for character(kind=1) internal units.  */\n \n static ssize_t\n mem_write (stream * s, const void * buf, ssize_t nbytes)\n@@ -680,6 +736,26 @@ mem_write (stream * s, const void * buf, ssize_t nbytes)\n }\n \n \n+/* Stream write function for character(kind=4) internal units.  */\n+\n+static ssize_t\n+mem_write4 (stream * s, const void * buf, ssize_t nwords)\n+{\n+  gfc_char4_t *p;\n+  int nw = nwords;\n+\n+  p = (gfc_char4_t *) mem_alloc_w4 (s, &nw);\n+  if (p)\n+    {\n+      while (nw--)\n+\t*p++ = (gfc_char4_t) *((char *) buf);\n+      return nwords;\n+    }\n+  else\n+    return 0;\n+}\n+\n+\n static gfc_offset\n mem_seek (stream * strm, gfc_offset offset, int whence)\n {\n@@ -763,7 +839,8 @@ empty_internal_buffer(stream *strm)\n   memset(s->buffer, ' ', s->file_length);\n }\n \n-/* open_internal()-- Returns a stream structure from an internal file */\n+/* open_internal()-- Returns a stream structure from a character(kind=1)\n+   internal file */\n \n stream *\n open_internal (char *base, int length, gfc_offset offset)\n@@ -790,6 +867,34 @@ open_internal (char *base, int length, gfc_offset offset)\n   return (stream *) s;\n }\n \n+/* open_internal4()-- Returns a stream structure from a character(kind=4)\n+   internal file */\n+\n+stream *\n+open_internal4 (char *base, int length, gfc_offset offset)\n+{\n+  unix_stream *s;\n+\n+  s = get_mem (sizeof (unix_stream));\n+  memset (s, '\\0', sizeof (unix_stream));\n+\n+  s->buffer = base;\n+  s->buffer_offset = offset;\n+\n+  s->logical_offset = 0;\n+  s->active = s->file_length = length;\n+\n+  s->st.close = (void *) mem_close;\n+  s->st.seek = (void *) mem_seek;\n+  s->st.tell = (void *) mem_tell;\n+  s->st.trunc = (void *) mem_truncate;\n+  s->st.read = (void *) mem_read4;\n+  s->st.write = (void *) mem_write4;\n+  s->st.flush = (void *) mem_flush;\n+\n+  return (stream *) s;\n+}\n+\n \n /* fd_to_stream()-- Given an open file descriptor, build a stream\n  * around it. */"}, {"sha": "c69e3574d8686b78603e45f6522e590ecb81d1a1", "filename": "libgfortran/io/unix.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/libgfortran%2Fio%2Funix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/libgfortran%2Fio%2Funix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.h?ref=c7421e06ca1de11fa125ed9d8619680d17bfb6f8", "patch": "@@ -94,12 +94,21 @@ internal_proto(open_external);\n extern stream *open_internal (char *, int, gfc_offset);\n internal_proto(open_internal);\n \n+extern stream *open_internal4 (char *, int, gfc_offset);\n+internal_proto(open_internal4);\n+\n extern char * mem_alloc_w (stream *, int *);\n internal_proto(mem_alloc_w);\n \n extern char * mem_alloc_r (stream *, int *);\n internal_proto(mem_alloc_r);\n \n+extern char * mem_alloc_w4 (stream *, int *);\n+internal_proto(mem_alloc_w4);\n+\n+extern char * mem_alloc_r4 (stream *, int *);\n+internal_proto(mem_alloc_r4);\n+\n extern stream *input_stream (void);\n internal_proto(input_stream);\n "}, {"sha": "07c9f54dfc468b27f81990bf75797685a533367d", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 177, "deletions": 21, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=c7421e06ca1de11fa125ed9d8619680d17bfb6f8", "patch": "@@ -36,10 +36,34 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <errno.h>\n #define star_fill(p, n) memset(p, '*', n)\n \n-#include \"write_float.def\"\n-\n typedef unsigned char uchar;\n \n+/* Helper functions for character(kind=4) internal units.  These are needed\n+   by write_float.def.  */\n+\n+static inline void\n+memset4 (void *p,  int offs, uchar c, int k)\n+{\n+  int j;\n+  gfc_char4_t *q = (gfc_char4_t *) (p + offs * 4);\n+  for (j = 0; j < k; j++)\n+    *q++ = c;\n+}\n+\n+static inline void\n+memcpy4 (void *dest,  int offs, const char *source, int k)\n+{\n+  int j;\n+  \n+  const char *p = source;\n+  gfc_char4_t *q = (gfc_char4_t *) (dest + offs * 4);\n+  for (j = 0; j < k; j++)\n+    *q++ = (gfc_char4_t) *p++;\n+}\n+\n+/* This include contains the heart and soul of formatted floating point.  */\n+#include \"write_float.def\"\n+\n /* Write out default char4.  */\n \n static void\n@@ -58,7 +82,10 @@ write_default_char4 (st_parameter_dt *dtp, gfc_char4_t *source,\n       p = write_block (dtp, k);\n       if (p == NULL)\n \treturn;\n-      memset (p, ' ', k);\n+      if (is_char4_unit (dtp))\n+\tmemset4 (p, 0, ' ', k);\n+      else\n+\tmemset (p, ' ', k);\n     }\n \n   /* Get ready to handle delimiters if needed.  */\n@@ -76,25 +103,48 @@ write_default_char4 (st_parameter_dt *dtp, gfc_char4_t *source,\n     }\n \n   /* Now process the remaining characters, one at a time.  */\n-  for (j = k; j < src_len; j++)\n+  for (j = 0; j < src_len; j++)\n     {\n       c = source[j];\n-    \n-      /* Handle delimiters if any.  */\n-      if (c == d && d != ' ')\n+      if (is_char4_unit (dtp))\n \t{\n-\t  p = write_block (dtp, 2);\n-\t  if (p == NULL)\n-\t    return;\n-\t  *p++ = (uchar) c;\n+\t  gfc_char4_t *q;\n+\t  /* Handle delimiters if any.  */\n+\t  if (c == d && d != ' ')\n+\t    {\n+\t      p = write_block (dtp, 2);\n+\t      if (p == NULL)\n+\t\treturn;\n+\t      q = (gfc_char4_t *) p;\n+\t      *q++ = c;\n+\t    }\n+\t  else\n+\t    {\n+\t      p = write_block (dtp, 1);\n+\t      if (p == NULL)\n+\t\treturn;\n+\t      q = (gfc_char4_t *) p;\n+\t    }\n+\t  *q = c;\n \t}\n       else\n \t{\n-\t  p = write_block (dtp, 1);\n-\t  if (p == NULL)\n-\t    return;\n+\t  /* Handle delimiters if any.  */\n+\t  if (c == d && d != ' ')\n+\t    {\n+\t      p = write_block (dtp, 2);\n+\t      if (p == NULL)\n+\t\treturn;\n+\t      *p++ = (uchar) c;\n+\t    }\n+          else\n+\t    {\n+\t      p = write_block (dtp, 1);\n+\t      if (p == NULL)\n+\t\treturn;\n+\t    }\n+\t    *p = c > 255 ? '?' : (uchar) c;\n \t}\n-      *p = c > 255 ? '?' : (uchar) c;\n     }\n }\n \n@@ -258,6 +308,18 @@ write_a (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n       if (p == NULL)\n \treturn;\n \n+      if (unlikely (is_char4_unit (dtp)))\n+\t{\n+\t  if (wlen < len)\n+\t    memcpy4 (p, 0, source, wlen);\n+\t  else\n+\t    {\n+\t      memset4 (p, 0, ' ', wlen - len);\n+\t      memcpy4 (p, wlen - len, source, len);\n+\t    }\n+\t  return;\n+\t}\n+\n       if (wlen < len)\n \tmemcpy (p, source, wlen);\n       else\n@@ -478,8 +540,17 @@ write_l (st_parameter_dt *dtp, const fnode *f, char *source, int len)\n   if (p == NULL)\n     return;\n \n-  memset (p, ' ', wlen - 1);\n   n = extract_int (source, len);\n+\n+  if (unlikely (is_char4_unit (dtp)))\n+    {\n+      gfc_char4_t *p4 = (gfc_char4_t *) p;\n+      memset4 (p, 0, ' ', wlen -1);\n+      p4[wlen - 1] = (n) ? 'T' : 'F';\n+      return;\n+    }\n+\n+  memset (p, ' ', wlen -1);\n   p[wlen - 1] = (n) ? 'T' : 'F';\n }\n \n@@ -503,8 +574,10 @@ write_boz (st_parameter_dt *dtp, const fnode *f, const char *q, int n)\n       p = write_block (dtp, w);\n       if (p == NULL)\n         return;\n-\n-      memset (p, ' ', w);\n+      if (unlikely (is_char4_unit (dtp)))\n+\tmemset4 (p, 0, ' ', w);\n+      else\n+\tmemset (p, ' ', w);\n       goto done;\n     }\n \n@@ -528,6 +601,35 @@ write_boz (st_parameter_dt *dtp, const fnode *f, const char *q, int n)\n \n   nblank = w - (nzero + digits);\n \n+  if (unlikely (is_char4_unit (dtp)))\n+    {\n+      gfc_char4_t *p4 = (gfc_char4_t *) p;\n+      if (nblank < 0)\n+\t{\n+\t  memset4 (p4, 0, '*', w);\n+\t  return;\n+\t}\n+\n+      if (!dtp->u.p.no_leading_blank)\n+\t{\n+\t  memset4 (p4, 0, ' ', nblank);\n+\t  q += nblank;\n+\t  memset4 (p4, 0, '0', nzero);\n+\t  q += nzero;\n+\t  memcpy4 (p4, 0, q, digits);\n+\t}\n+      else\n+\t{\n+\t  memset4 (p4, 0, '0', nzero);\n+\t  q += nzero;\n+\t  memcpy4 (p4, 0, q, digits);\n+\t  q += digits;\n+\t  memset4 (p4, 0, ' ', nblank);\n+\t  dtp->u.p.no_leading_blank = 0;\n+\t}\n+      return;\n+    }\n+\n   if (nblank < 0)\n     {\n       star_fill (p, w);\n@@ -582,8 +684,10 @@ write_decimal (st_parameter_dt *dtp, const fnode *f, const char *source,\n       p = write_block (dtp, w);\n       if (p == NULL)\n         return;\n-\n-      memset (p, ' ', w);\n+      if (unlikely (is_char4_unit (dtp)))\n+\tmemset4 (p, 0, ' ', w);\n+      else\n+\tmemset (p, ' ', w);\n       goto done;\n     }\n \n@@ -621,6 +725,37 @@ write_decimal (st_parameter_dt *dtp, const fnode *f, const char *source,\n \n   nblank = w - (nsign + nzero + digits);\n \n+  if (unlikely (is_char4_unit (dtp)))\n+    {\n+      gfc_char4_t * p4 = (gfc_char4_t *) p;\n+      if (nblank < 0)\n+\t{\n+\t  memset4 (p4, 0, '*', w);\n+\t  goto done;\n+\t}\n+\n+      memset4 (p4, 0, ' ', nblank);\n+      p4 += nblank;\n+\n+      switch (sign)\n+\t{\n+\tcase S_PLUS:\n+\t  *p4++ = '+';\n+\t  break;\n+\tcase S_MINUS:\n+\t  *p4++ = '-';\n+\t  break;\n+\tcase S_NONE:\n+\t  break;\n+\t}\n+\n+      memset4 (p4, 0, '0', nzero);\n+      p4 += nzero;\n+\n+      memcpy4 (p4, 0, q, digits);\n+      return;\n+    }\n+\n   if (nblank < 0)\n     {\n       star_fill (p, w);\n@@ -1055,7 +1190,12 @@ write_x (st_parameter_dt *dtp, int len, int nspaces)\n   if (p == NULL)\n     return;\n   if (nspaces > 0 && len - nspaces >= 0)\n-    memset (&p[len - nspaces], ' ', nspaces);\n+    {\n+      if (unlikely (is_char4_unit (dtp)))\n+\tmemset4 (p, len - nspaces, ' ', nspaces);\n+      else\n+\tmemset (&p[len - nspaces], ' ', nspaces);\n+    }\n }\n \n \n@@ -1132,6 +1272,22 @@ write_integer (st_parameter_dt *dtp, const char *source, int length)\n   p = write_block (dtp, width);\n   if (p == NULL)\n     return;\n+\n+  if (unlikely (is_char4_unit (dtp)))\n+    {\n+      if (dtp->u.p.no_leading_blank)\n+\t{\n+\t  memcpy4 (p, 0, q, digits);\n+\t  memset4 (p, digits, ' ', width - digits);\n+\t}\n+      else\n+\t{\n+\t  memset4 (p, 0, ' ', width - digits);\n+\t  memcpy4 (p, width - digits, q, digits);\n+\t}\n+      return;\n+    }\n+\n   if (dtp->u.p.no_leading_blank)\n     {\n       memcpy (p, q, digits);"}, {"sha": "02e1b8b9b13fcd5cb3db872d5234a3942778b873", "filename": "libgfortran/io/write_float.def", "status": "modified", "additions": 192, "deletions": 49, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/libgfortran%2Fio%2Fwrite_float.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7421e06ca1de11fa125ed9d8619680d17bfb6f8/libgfortran%2Fio%2Fwrite_float.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite_float.def?ref=c7421e06ca1de11fa125ed9d8619680d17bfb6f8", "patch": "@@ -127,6 +127,14 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n \t  out = write_block (dtp, w);\n \t  if (out == NULL)\n \t    return;\n+\n+\t  if (unlikely (is_char4_unit (dtp)))\n+\t    {\n+\t      gfc_char4_t *out4 = (gfc_char4_t *) out;\n+\t      *out4 = '0';\n+\t      return;\n+\t    }\n+\n \t  *out = '0';\n \t  return;\n \t}\n@@ -430,6 +438,11 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n   /* Check the value fits in the specified field width.  */\n   if (nblanks < 0 || edigits == -1)\n     {\n+      if (unlikely (is_char4_unit (dtp)))\n+\t{\n+\t  memset4 (out, 0, '*', w);\n+\t  return;\n+\t}\n       star_fill (out, w);\n       return;\n     }\n@@ -443,6 +456,105 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n   else\n     leadzero = 0;\n \n+  /* For internal character(kind=4) units, we duplicate the code used for\n+     regular output slightly modified.  This needs to be maintained\n+     consistent with the regular code that follows this block.  */\n+  if (unlikely (is_char4_unit (dtp)))\n+    {\n+      gfc_char4_t *out4 = (gfc_char4_t *) out;\n+      /* Pad to full field width.  */\n+\n+      if ( ( nblanks > 0 ) && !dtp->u.p.no_leading_blank)\n+\t{\n+\t  memset4 (out, 0, ' ', nblanks);\n+\t  out4 += nblanks;\n+\t}\n+\n+      /* Output the initial sign (if any).  */\n+      if (sign == S_PLUS)\n+\t*(out4++) = '+';\n+      else if (sign == S_MINUS)\n+\t*(out4++) = '-';\n+\n+      /* Output an optional leading zero.  */\n+      if (leadzero)\n+\t*(out4++) = '0';\n+\n+      /* Output the part before the decimal point, padding with zeros.  */\n+      if (nbefore > 0)\n+\t{\n+\t  if (nbefore > ndigits)\n+\t    {\n+\t      i = ndigits;\n+\t      memcpy4 (out4, 0, digits, i);\n+\t      ndigits = 0;\n+\t      while (i < nbefore)\n+\t\tout4[i++] = '0';\n+\t    }\n+\t  else\n+\t    {\n+\t      i = nbefore;\n+\t      memcpy4 (out4, 0, digits, i);\n+\t      ndigits -= i;\n+\t    }\n+\n+\t  digits += i;\n+\t  out4 += nbefore;\n+\t}\n+\n+      /* Output the decimal point.  */\n+      *(out4++) = dtp->u.p.current_unit->decimal_status\n+\t\t    == DECIMAL_POINT ? '.' : ',';\n+\n+      /* Output leading zeros after the decimal point.  */\n+      if (nzero > 0)\n+\t{\n+\t  for (i = 0; i < nzero; i++)\n+\t    *(out4++) = '0';\n+\t}\n+\n+      /* Output digits after the decimal point, padding with zeros.  */\n+      if (nafter > 0)\n+\t{\n+\t  if (nafter > ndigits)\n+\t    i = ndigits;\n+\t  else\n+\t    i = nafter;\n+\n+\t  memcpy4 (out4, 0, digits, i);\n+\t  while (i < nafter)\n+\t    out4[i++] = '0';\n+\n+\t  digits += i;\n+\t  ndigits -= i;\n+\t  out4 += nafter;\n+\t}\n+\n+      /* Output the exponent.  */\n+      if (expchar)\n+\t{\n+\t  if (expchar != ' ')\n+\t    {\n+\t      *(out4++) = expchar;\n+\t      edigits--;\n+\t    }\n+#if HAVE_SNPRINTF\n+\t  snprintf (buffer, size, \"%+0*d\", edigits, e);\n+#else\n+\t  sprintf (buffer, \"%+0*d\", edigits, e);\n+#endif\n+\t  memcpy4 (out4, 0, buffer, edigits);\n+\t}\n+\n+      if (dtp->u.p.no_leading_blank)\n+\t{\n+\t  out4 += edigits;\n+\t  memset4 (out4 , 0, ' ' , nblanks);\n+\t  dtp->u.p.no_leading_blank = 0;\n+\t}\n+      return;\n+    } /* End of character(kind=4) internal unit code.  */\n+\n   /* Pad to full field width.  */\n \n   if ( ( nblanks > 0 ) && !dtp->u.p.no_leading_blank)\n@@ -549,66 +661,94 @@ write_infnan (st_parameter_dt *dtp, const fnode *f, int isnan_flag, int sign_bit\n \n   if (f->format != FMT_B && f->format != FMT_O && f->format != FMT_Z)\n     {\n-\t  nb =  f->u.real.w;\n-\t  \n-\t  /* If the field width is zero, the processor must select a width \n-\t     not zero.  4 is chosen to allow output of '-Inf' or '+Inf' */\n-\t     \n-\t  if (nb == 0) nb = 4;\n-\t  p = write_block (dtp, nb);\n-          if (p == NULL)\n-            return;\n-\t  if (nb < 3)\n-\t    {\n-\t      memset (p, '*',nb);\n-\t      return;\n-\t    }\n+      nb =  f->u.real.w;\n+  \n+      /* If the field width is zero, the processor must select a width \n+\t not zero.  4 is chosen to allow output of '-Inf' or '+Inf' */\n+     \n+      if (nb == 0) nb = 4;\n+      p = write_block (dtp, nb);\n+      if (p == NULL)\n+\treturn;\n+      if (nb < 3)\n+\t{\n+\t  if (unlikely (is_char4_unit (dtp)))\n+\t    memset4 (p, 0, '*', nb);\n+\t  else\n+\t    memset (p, '*', nb);\n+\t  return;\n+\t}\n \n-\t  memset(p, ' ', nb);\n-\t  if (!isnan_flag)\n-\t    {\n-\t      if (sign_bit)\n-\t        {\n-\t        \n-\t          /* If the sign is negative and the width is 3, there is\n-\t             insufficient room to output '-Inf', so output asterisks */\n-\t             \n-\t          if (nb == 3)\n-\t            {\n-\t              memset (p, '*',nb);\n-\t              return;\n-\t            }\n-\t            \n-\t          /* The negative sign is mandatory */\n-\t            \n-\t          fin = '-';\n-\t\t}    \n-\t      else\n-\t      \n-\t          /* The positive sign is optional, but we output it for\n-\t             consistency */\n-\t\t  fin = '+';\n+      if (unlikely (is_char4_unit (dtp)))\n+        memset4 (p, 0, ' ', nb);\n+      else\n+\tmemset(p, ' ', nb);\n \n+      if (!isnan_flag)\n+\t{\n+\t  if (sign_bit)\n+\t    {\n+\t      /* If the sign is negative and the width is 3, there is\n+\t\t insufficient room to output '-Inf', so output asterisks */\n+\t      if (nb == 3)\n+\t\t{\n+\t\t  if (unlikely (is_char4_unit (dtp)))\n+\t\t    memset4 (p, 0, '*', nb);\n+\t\t  else\n+\t\t    memset (p, '*', nb);\n+\t\t  return;\n+\t\t}\n+\t      /* The negative sign is mandatory */\n+\t      fin = '-';\n+\t    }    \n+\t  else\n+\t    /* The positive sign is optional, but we output it for\n+\t       consistency */\n+\t    fin = '+';\n+\t    \n+\t  if (unlikely (is_char4_unit (dtp)))\n+\t    {\n+\t      gfc_char4_t *p4 = (gfc_char4_t *) p;\n \t      if (nb > 8)\n-\t      \n-\t        /* We have room, so output 'Infinity' */\n-\t\tmemcpy(p + nb - 8, \"Infinity\", 8);\n+\t\t/* We have room, so output 'Infinity' */\n+\t\tmemcpy4 (p4, nb - 8, \"Infinity\", 8);\n \t      else\n-\t      \n-\t        /* For the case of width equals 8, there is not enough room\n-\t           for the sign and 'Infinity' so we go with 'Inf' */\n-\t\tmemcpy(p + nb - 3, \"Inf\", 3);\n+\t\t/* For the case of width equals 8, there is not enough room\n+\t\t   for the sign and 'Infinity' so we go with 'Inf' */\n+\t\tmemcpy4 (p4, nb - 3, \"Inf\", 3);\n \n \t      if (nb < 9 && nb > 3)\n-\t\tp[nb - 4] = fin;  /* Put the sign in front of Inf */\n+\t        /* Put the sign in front of Inf */\n+\t\tp4[nb - 4] = (gfc_char4_t) fin;\n \t      else if (nb > 8)\n-\t\tp[nb - 9] = fin;  /* Put the sign in front of Infinity */\n+\t        /* Put the sign in front of Infinity */\n+\t\tp4[nb - 9] = (gfc_char4_t) fin;\n+\t      return;\n \t    }\n+\n+\t  if (nb > 8)\n+\t    /* We have room, so output 'Infinity' */\n+\t    memcpy(p + nb - 8, \"Infinity\", 8);\n+\t  else\n+\t    /* For the case of width equals 8, there is not enough room\n+\t       for the sign and 'Infinity' so we go with 'Inf' */\n+\t    memcpy(p + nb - 3, \"Inf\", 3);\n+\n+\t  if (nb < 9 && nb > 3)\n+\t    p[nb - 4] = fin;  /* Put the sign in front of Inf */\n+\t  else if (nb > 8)\n+\t    p[nb - 9] = fin;  /* Put the sign in front of Infinity */\n+\t}\n+      else\n+        {\n+\t  if (unlikely (is_char4_unit (dtp)))\n+\t    memcpy4 (p, nb - 3, \"NaN\", 3);\n \t  else\n \t    memcpy(p + nb - 3, \"NaN\", 3);\n-\t  return;\n \t}\n+      return;\n     }\n+}\n \n \n /* Returns the value of 10**d.  */\n@@ -750,7 +890,10 @@ output_float_FMT_G_ ## x (st_parameter_dt *dtp, const fnode *f, \\\n       p = write_block (dtp, nb);\\\n       if (p == NULL)\\\n \treturn;\\\n-      memset (p, ' ', nb);\\\n+      if (unlikely (is_char4_unit (dtp)))\\\n+\tmemset4 (p, 0, ' ', nb);\\\n+      else\\\n+\tmemset (p, ' ', nb);\\\n     }\\\n }\\\n "}]}