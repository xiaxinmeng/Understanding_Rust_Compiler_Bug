{"sha": "10a73df76280e12886cb20b028727436d73724c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBhNzNkZjc2MjgwZTEyODg2Y2IyMGIwMjg3Mjc0MzZkNzM3MjRjNQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-11-18T14:07:11Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-11-18T14:07:11Z"}, "message": "re PR tree-optimization/92516 (ICE in vect_schedule_slp_instance, at tree-vect-slp.c:4095 since r278246)\n\n2019-11-18  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/92516\n\t* tree-vect-slp.c (vect_analyze_slp_instance): Add bst_map\n\targument, hoist bst_map creation/destruction to ...\n\t(vect_analyze_slp): ... here, forming a true graph with\n\tSLP instances being the entries.\n\t(vect_detect_hybrid_slp_stmts): Remove wrapper.\n\t(vect_detect_hybrid_slp): Use one visited set for all\n\tgraph entries.\n\t(vect_slp_analyze_node_operations): Simplify visited/lvisited\n\tto hash-sets of slp_tree.\n\t(vect_slp_analyze_operations): Likewise.\n\t(vect_bb_slp_scalar_cost): Remove wrapper.\n\t(vect_bb_vectorization_profitable_p): Use one visited set for\n\tall graph entries.\n\t(vect_schedule_slp_instance): Elide bst_map use.\n\t(vect_schedule_slp): Likewise.\n\n\t* g++.dg/vect/slp-pr92516.cc: New testcase.\n\n2019-11-18  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (vect_analyze_slp_instance): When a CTOR\n\twas vectorized with just external refs fail.\n\n\t* gcc.dg/vect/vect-ctor-1.c: New testcase.\n\nFrom-SVN: r278406", "tree": {"sha": "e5e07edef9b912f5781f27c27645b3f9b9a14345", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5e07edef9b912f5781f27c27645b3f9b9a14345"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10a73df76280e12886cb20b028727436d73724c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10a73df76280e12886cb20b028727436d73724c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10a73df76280e12886cb20b028727436d73724c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10a73df76280e12886cb20b028727436d73724c5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "33b3af3fd4819a7fa14acc9aebd100faffdb9667", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33b3af3fd4819a7fa14acc9aebd100faffdb9667", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33b3af3fd4819a7fa14acc9aebd100faffdb9667"}], "stats": {"total": 216, "additions": 141, "deletions": 75}, "files": [{"sha": "7be88529905dd2a005aeb4bbb7ce24adabb8ebdf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a73df76280e12886cb20b028727436d73724c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a73df76280e12886cb20b028727436d73724c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10a73df76280e12886cb20b028727436d73724c5", "patch": "@@ -1,3 +1,27 @@\n+2019-11-18  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/92516\n+\t* tree-vect-slp.c (vect_analyze_slp_instance): Add bst_map\n+\targument, hoist bst_map creation/destruction to ...\n+\t(vect_analyze_slp): ... here, forming a true graph with\n+\tSLP instances being the entries.\n+\t(vect_detect_hybrid_slp_stmts): Remove wrapper.\n+\t(vect_detect_hybrid_slp): Use one visited set for all\n+\tgraph entries.\n+\t(vect_slp_analyze_node_operations): Simplify visited/lvisited\n+\tto hash-sets of slp_tree.\n+\t(vect_slp_analyze_operations): Likewise.\n+\t(vect_bb_slp_scalar_cost): Remove wrapper.\n+\t(vect_bb_vectorization_profitable_p): Use one visited set for\n+\tall graph entries.\n+\t(vect_schedule_slp_instance): Elide bst_map use.\n+\t(vect_schedule_slp): Likewise.\n+\n+2019-11-18  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-slp.c (vect_analyze_slp_instance): When a CTOR\n+\twas vectorized with just external refs fail.\n+\n 2019-11-18  Martin Liska  <mliska@suse.cz>\n \n \tPR ipa/92525"}, {"sha": "5053583d14939a955bdc4431690625b8ed007e87", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a73df76280e12886cb20b028727436d73724c5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a73df76280e12886cb20b028727436d73724c5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=10a73df76280e12886cb20b028727436d73724c5", "patch": "@@ -1,3 +1,12 @@\n+2019-11-18  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/92516\n+\t* g++.dg/vect/slp-pr92516.cc: New testcase.\n+\n+2019-11-18  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/vect/vect-ctor-1.c: New testcase.\n+\n 2019-11-18  Martin Liska  <mliska@suse.cz>\n \n \t* gcc.dg/ipa/ipa-icf-36.c: Remove 'all-all-all'."}, {"sha": "65b74ba722688664844e8273789abee2266e807a", "filename": "gcc/testsuite/g++.dg/vect/slp-pr92516.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a73df76280e12886cb20b028727436d73724c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fslp-pr92516.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a73df76280e12886cb20b028727436d73724c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fslp-pr92516.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fslp-pr92516.cc?ref=10a73df76280e12886cb20b028727436d73724c5", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+// { dg-require-effective-target c++14 }\n+\n+class a {\n+public:\n+  typedef int b;\n+  operator b();\n+};\n+class c {\n+public:\n+  constexpr int m_fn1() const;\n+  constexpr int d() const;\n+  int e;\n+  int f;\n+};\n+constexpr int c::m_fn1() const { return e; }\n+constexpr int c::d() const { return f; }\n+class g {\n+public:\n+  g();\n+  constexpr void i(const c &) noexcept;\n+  int j;\n+  int k;\n+  int l;\n+  int m;\n+};\n+constexpr void g::i(const c &n) noexcept {\n+  int v = l - j, h = m - k;\n+  j = n.m_fn1() - v / 2;\n+  k = n.d() - h / 2;\n+  l = j + v;\n+  m = k + h;\n+}\n+class o {\n+  void m_fn4() const;\n+  a p;\n+} r;\n+void o::m_fn4() const {\n+  g q;\n+  c t;\n+  q.i(t);\n+  r.p || 0;\n+}"}, {"sha": "e050db1a2e4072e65152d913595f4d55fd85e2fd", "filename": "gcc/testsuite/gcc.dg/vect/vect-ctor-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a73df76280e12886cb20b028727436d73724c5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ctor-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a73df76280e12886cb20b028727436d73724c5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ctor-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ctor-1.c?ref=10a73df76280e12886cb20b028727436d73724c5", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O3\" } */\n+/* { dg-additional-options \"-mavx2\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+typedef struct {\n+    unsigned short mprr_2[5][16][16];\n+} ImageParameters;\n+int s[16][2];\n+void intrapred_luma_16x16(ImageParameters *img, int s0)\n+{\n+  for (int j=0; j < 16; j++)\n+    for (int i=0; i < 16; i++)\n+      {\n+\timg->mprr_2[1 ][j][i]=s[j][1];\n+\timg->mprr_2[2 ][j][i]=s0;\n+      }\n+}"}, {"sha": "e3bd1dfb3bb8ac0fc0898107e00926b86ed1a260", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 48, "deletions": 75, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a73df76280e12886cb20b028727436d73724c5/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a73df76280e12886cb20b028727436d73724c5/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=10a73df76280e12886cb20b028727436d73724c5", "patch": "@@ -2087,6 +2087,7 @@ calculate_unrolling_factor (poly_uint64 nunits, unsigned int group_size)\n \n static bool\n vect_analyze_slp_instance (vec_info *vinfo,\n+\t\t\t   scalar_stmts_to_slp_tree_map_t *bst_map,\n \t\t\t   stmt_vec_info stmt_info, unsigned max_tree_size)\n {\n   slp_instance new_instance;\n@@ -2194,19 +2195,11 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   /* Build the tree for the SLP instance.  */\n   bool *matches = XALLOCAVEC (bool, group_size);\n   unsigned npermutes = 0;\n-  scalar_stmts_to_slp_tree_map_t *bst_map\n-    = new scalar_stmts_to_slp_tree_map_t ();\n   poly_uint64 max_nunits = nunits;\n   unsigned tree_size = 0;\n   node = vect_build_slp_tree (vinfo, scalar_stmts, group_size,\n \t\t\t      &max_nunits, matches, &npermutes,\n \t\t\t      &tree_size, bst_map);\n-  /* The map keeps a reference on SLP nodes built, release that.  */\n-  for (scalar_stmts_to_slp_tree_map_t::iterator it = bst_map->begin ();\n-       it != bst_map->end (); ++it)\n-    if ((*it).second)\n-      vect_free_slp_tree ((*it).second, false);\n-  delete bst_map;\n   if (node != NULL)\n     {\n       /* If this is a reduction chain with a conversion in front\n@@ -2260,6 +2253,18 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t  matches[group_size / const_max_nunits * const_max_nunits] = false;\n \t  vect_free_slp_tree (node, false);\n \t}\n+      else if (constructor\n+\t       && SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n+\t{\n+\t  /* CONSTRUCTOR vectorization relies on a vector stmt being\n+\t     generated, that doesn't work for fully external ones.  */\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"Build SLP failed: CONSTRUCTOR of external \"\n+\t\t\t     \"or constant elements\\n\");\n+\t  vect_free_slp_tree (node, false);\n+\t  return false;\n+\t}\n       else\n \t{\n \t  /* Create a new SLP instance.  */\n@@ -2394,7 +2399,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \n \t  stmt_vec_info rest = vect_split_slp_store_group (stmt_info,\n \t\t\t\t\t\t\t   group1_size);\n-\t  bool res = vect_analyze_slp_instance (vinfo, stmt_info,\n+\t  bool res = vect_analyze_slp_instance (vinfo, bst_map, stmt_info,\n \t\t\t\t\t\tmax_tree_size);\n \t  /* If the first non-match was in the middle of a vector,\n \t     skip the rest of that vector.  */\n@@ -2405,7 +2410,8 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t\trest = vect_split_slp_store_group (rest, const_nunits);\n \t    }\n \t  if (i < group_size)\n-\t    res |= vect_analyze_slp_instance (vinfo, rest, max_tree_size);\n+\t    res |= vect_analyze_slp_instance (vinfo, bst_map,\n+\t\t\t\t\t      rest, max_tree_size);\n \t  return res;\n \t}\n       /* Even though the first vector did not all match, we might be able to SLP\n@@ -2427,17 +2433,20 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n \n   DUMP_VECT_SCOPE (\"vect_analyze_slp\");\n \n+  scalar_stmts_to_slp_tree_map_t *bst_map\n+    = new scalar_stmts_to_slp_tree_map_t ();\n+\n   /* Find SLP sequences starting from groups of grouped stores.  */\n   FOR_EACH_VEC_ELT (vinfo->grouped_stores, i, first_element)\n-    vect_analyze_slp_instance (vinfo, first_element, max_tree_size);\n+    vect_analyze_slp_instance (vinfo, bst_map, first_element, max_tree_size);\n \n   if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo))\n     {\n       if (loop_vinfo->reduction_chains.length () > 0)\n \t{\n \t  /* Find SLP sequences starting from reduction chains.  */\n \t  FOR_EACH_VEC_ELT (loop_vinfo->reduction_chains, i, first_element)\n-\t    if (! vect_analyze_slp_instance (vinfo, first_element,\n+\t    if (! vect_analyze_slp_instance (vinfo, bst_map, first_element,\n \t\t\t\t\t     max_tree_size))\n \t      {\n \t\t/* Dissolve reduction chain group.  */\n@@ -2459,10 +2468,17 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n \n       /* Find SLP sequences starting from groups of reductions.  */\n       if (loop_vinfo->reductions.length () > 1)\n-\tvect_analyze_slp_instance (vinfo, loop_vinfo->reductions[0],\n+\tvect_analyze_slp_instance (vinfo, bst_map, loop_vinfo->reductions[0],\n \t\t\t\t   max_tree_size);\n     }\n \n+  /* The map keeps a reference on SLP nodes built, release that.  */\n+  for (scalar_stmts_to_slp_tree_map_t::iterator it = bst_map->begin ();\n+       it != bst_map->end (); ++it)\n+    if ((*it).second)\n+      vect_free_slp_tree ((*it).second, false);\n+  delete bst_map;\n+\n   return opt_result::success ();\n }\n \n@@ -2589,13 +2605,6 @@ vect_detect_hybrid_slp_stmts (slp_tree node, unsigned i, slp_vect_type stype,\n \tvect_detect_hybrid_slp_stmts (child, i, stype, visited);\n }\n \n-static void\n-vect_detect_hybrid_slp_stmts (slp_tree node, unsigned i, slp_vect_type stype)\n-{\n-  hash_map<slp_tree, unsigned> visited;\n-  vect_detect_hybrid_slp_stmts (node, i, stype, visited);\n-}\n-\n /* Helpers for vect_detect_hybrid_slp walking pattern stmt uses.  */\n \n static tree\n@@ -2678,11 +2687,12 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n   /* Then walk the SLP instance trees marking stmts with uses in\n      non-SLP stmts as hybrid, also propagating hybrid down the\n      SLP tree, collecting the above info on-the-fly.  */\n+  hash_map<slp_tree, unsigned> visited;\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n       for (unsigned i = 0; i < SLP_INSTANCE_GROUP_SIZE (instance); ++i)\n \tvect_detect_hybrid_slp_stmts (SLP_INSTANCE_TREE (instance),\n-\t\t\t\t      i, pure_slp);\n+\t\t\t\t      i, pure_slp, visited);\n     }\n }\n \n@@ -2830,8 +2840,8 @@ vect_slp_convert_to_external (vec_info *vinfo, slp_tree node,\n static bool\n vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n \t\t\t\t  slp_instance node_instance,\n-\t\t\t\t  scalar_stmts_to_slp_tree_map_t *visited,\n-\t\t\t\t  scalar_stmts_to_slp_tree_map_t *lvisited,\n+\t\t\t\t  hash_set<slp_tree> &visited,\n+\t\t\t\t  hash_set<slp_tree> &lvisited,\n \t\t\t\t  stmt_vector_for_cost *cost_vec)\n {\n   int i, j;\n@@ -2841,27 +2851,13 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n     return true;\n \n   /* If we already analyzed the exact same set of scalar stmts we're done.\n-     We share the generated vector stmts for those.  */\n-  slp_tree *leader;\n-  if ((leader = visited->get (SLP_TREE_SCALAR_STMTS (node)))\n-      || (leader = lvisited->get (SLP_TREE_SCALAR_STMTS (node))))\n-    {\n-      SLP_TREE_NUMBER_OF_VEC_STMTS (node)\n-\t= SLP_TREE_NUMBER_OF_VEC_STMTS (*leader);\n-      /* Cope with cases in which we made a late decision to build the\n-\t node from scalars.  */\n-      if (SLP_TREE_DEF_TYPE (*leader) == vect_external_def\n-\t  && vect_slp_convert_to_external (vinfo, node, node_instance))\n-\t;\n-      else\n-\tgcc_assert (SLP_TREE_DEF_TYPE (node) == SLP_TREE_DEF_TYPE (*leader));\n-      return true;\n-    }\n-\n-  /* The SLP graph is acyclic so not caching whether we failed or succeeded\n+     We share the generated vector stmts for those.\n+     The SLP graph is acyclic so not caching whether we failed or succeeded\n      doesn't result in any issue since we throw away the lvisited set\n      when we fail.  */\n-  lvisited->put (SLP_TREE_SCALAR_STMTS (node).copy (), node);\n+  if (visited.contains (node)\n+      || lvisited.add (node))\n+    return true;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     if (!vect_slp_analyze_node_operations (vinfo, child, node_instance,\n@@ -2934,16 +2930,15 @@ vect_slp_analyze_operations (vec_info *vinfo)\n \n   DUMP_VECT_SCOPE (\"vect_slp_analyze_operations\");\n \n-  scalar_stmts_to_slp_tree_map_t *visited\n-    = new scalar_stmts_to_slp_tree_map_t ();\n+  hash_set<slp_tree> visited;\n   for (i = 0; vinfo->slp_instances.iterate (i, &instance); )\n     {\n-      scalar_stmts_to_slp_tree_map_t lvisited;\n+      hash_set<slp_tree> lvisited;\n       stmt_vector_for_cost cost_vec;\n       cost_vec.create (2);\n       if (!vect_slp_analyze_node_operations (vinfo,\n \t\t\t\t\t     SLP_INSTANCE_TREE (instance),\n-\t\t\t\t\t     instance, visited, &lvisited,\n+\t\t\t\t\t     instance, visited, lvisited,\n \t\t\t\t\t     &cost_vec))\n         {\n \t  slp_tree node = SLP_INSTANCE_TREE (instance);\n@@ -2958,16 +2953,15 @@ vect_slp_analyze_operations (vec_info *vinfo)\n \t}\n       else\n \t{\n-\t  for (scalar_stmts_to_slp_tree_map_t::iterator x = lvisited.begin();\n+\t  for (hash_set<slp_tree>::iterator x = lvisited.begin();\n \t       x != lvisited.end(); ++x)\n-\t    visited->put ((*x).first.copy (), (*x).second);\n+\t    visited.add (*x);\n \t  i++;\n \n \t  add_stmt_costs (vinfo->target_cost_data, &cost_vec);\n \t  cost_vec.release ();\n \t}\n     }\n-  delete visited;\n \n   return !vinfo->slp_instances.is_empty ();\n }\n@@ -3058,15 +3052,6 @@ vect_bb_slp_scalar_cost (basic_block bb,\n     }\n }\n \n-static void \n-vect_bb_slp_scalar_cost (basic_block bb,\n-\t\t\t slp_tree node, vec<bool, va_heap> *life,\n-\t\t\t stmt_vector_for_cost *cost_vec)\n-{\n-  hash_set<slp_tree> visited;\n-  vect_bb_slp_scalar_cost (bb, node, life, cost_vec, visited);\n-}\n-\n /* Check if vectorization of the basic block is profitable.  */\n \n static bool\n@@ -3081,13 +3066,14 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n   /* Calculate scalar cost.  */\n   stmt_vector_for_cost scalar_costs;\n   scalar_costs.create (0);\n+  hash_set<slp_tree> visited;\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n       auto_vec<bool, 20> life;\n       life.safe_grow_cleared (SLP_INSTANCE_GROUP_SIZE (instance));\n       vect_bb_slp_scalar_cost (BB_VINFO_BB (bb_vinfo),\n \t\t\t       SLP_INSTANCE_TREE (instance),\n-\t\t\t       &life, &scalar_costs);\n+\t\t\t       &life, &scalar_costs, visited);\n     }\n   void *target_cost_data = init_cost (NULL);\n   add_stmt_costs (target_cost_data, &scalar_costs);\n@@ -4128,8 +4114,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n /* Vectorize SLP instance tree in postorder.  */\n \n static void\n-vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n-\t\t\t    scalar_stmts_to_slp_tree_map_t *bst_map)\n+vect_schedule_slp_instance (slp_tree node, slp_instance instance)\n {\n   gimple_stmt_iterator si;\n   stmt_vec_info stmt_info;\n@@ -4146,17 +4131,8 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   if (SLP_TREE_VEC_STMTS (node).exists ())\n     return;\n \n-  /* See if we have already vectorized the same set of stmts and reuse their\n-     vectorized stmts across instances.  */\n-  if (slp_tree *leader = bst_map->get (SLP_TREE_SCALAR_STMTS (node)))\n-    {\n-      SLP_TREE_VEC_STMTS (node).safe_splice (SLP_TREE_VEC_STMTS (*leader));\n-      return;\n-    }\n-\n-  bst_map->put (SLP_TREE_SCALAR_STMTS (node).copy (), node);\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_schedule_slp_instance (child, instance, bst_map);\n+    vect_schedule_slp_instance (child, instance);\n \n   /* Push SLP node def-type to stmts.  */\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n@@ -4376,14 +4352,12 @@ vect_schedule_slp (vec_info *vinfo)\n   slp_instance instance;\n   unsigned int i;\n \n-  scalar_stmts_to_slp_tree_map_t *bst_map\n-    = new scalar_stmts_to_slp_tree_map_t ();\n   slp_instances = vinfo->slp_instances;\n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n       slp_tree node = SLP_INSTANCE_TREE (instance);\n       /* Schedule the tree of INSTANCE.  */\n-      vect_schedule_slp_instance (node, instance, bst_map);\n+      vect_schedule_slp_instance (node, instance);\n \n       if (SLP_INSTANCE_ROOT_STMT (instance))\n \tvectorize_slp_instance_root_stmt (node, instance);\n@@ -4392,7 +4366,6 @@ vect_schedule_slp (vec_info *vinfo)\n \tdump_printf_loc (MSG_NOTE, vect_location,\n                          \"vectorizing stmts using SLP.\\n\");\n     }\n-  delete bst_map;\n \n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {"}]}