{"sha": "e963cb1a8a5b1660897be19d0aca20cbdcac413f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk2M2NiMWE4YTViMTY2MDg5N2JlMTlkMGFjYTIwY2JkY2FjNDEzZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-01-17T17:53:55Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-01-17T17:53:55Z"}, "message": "rx: Cleanup conditional branches.\n\nUse match_operator, not code_iterators.  Use a new helper function,\nrx_split_cbranch.  Get the modes right on the comparisons.  Distinguish\nfp comparisons with CC_Fmode.\n\nFrom-SVN: r168919", "tree": {"sha": "3007be2eaad792204f0b8c032a8f8aee8531c6ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3007be2eaad792204f0b8c032a8f8aee8531c6ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e963cb1a8a5b1660897be19d0aca20cbdcac413f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e963cb1a8a5b1660897be19d0aca20cbdcac413f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e963cb1a8a5b1660897be19d0aca20cbdcac413f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e963cb1a8a5b1660897be19d0aca20cbdcac413f/comments", "author": null, "committer": null, "parents": [{"sha": "af530bb412465cf6fc55fd9a31ab69b2b2c0a64a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af530bb412465cf6fc55fd9a31ab69b2b2c0a64a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af530bb412465cf6fc55fd9a31ab69b2b2c0a64a"}], "stats": {"total": 783, "additions": 465, "deletions": 318}, "files": [{"sha": "6636b512b49b8b9aec1cb0835760d5e138b82226", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e963cb1a8a5b1660897be19d0aca20cbdcac413f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e963cb1a8a5b1660897be19d0aca20cbdcac413f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e963cb1a8a5b1660897be19d0aca20cbdcac413f", "patch": "@@ -1,5 +1,34 @@\n 2011-01-17  Richard Henderson  <rth@redhat.com>\n \n+\t* config/rx/predicates.md (label_ref_operand): New.\n+\t(rx_z_comparison_operator): New.\n+\t(rx_zs_comparison_operator): New.\n+\t(rx_fp_comparison_operator): New.\n+\t* config/rx/rx.c (rx_print_operand) [B]: Examine comparison modes.\n+\tValidate that the flags are set properly for the comparison.\n+\t(rx_gen_cond_branch_template): Remove.\n+\t(rx_cc_modes_compatible): Remove.\n+\t(mode_from_flags): New.\n+\t(flags_from_code): Rename from flags_needed_for_conditional.\n+\t(rx_cc_modes_compatible): Re-write in terms of flags_from_mode.\n+\t(rx_select_cc_mode): Likewise.\n+\t(rx_split_fp_compare): New.\n+\t(rx_split_cbranch): New.\n+\t* config/rx/rx.md (most_cond, zs_cond): Remove iterators.\n+\t(*cbranchsi4): Use match_operator and rx_split_cbranch.\n+\t(*cbranchsf4): Similarly.\n+\t(*cbranchsi4_tst): Rename from *tstbranchsi4_<code>.  Use\n+\tmatch_operator and rx_split_cbranch.\n+\t(*cbranchsi4_tst_ext): Combine *tstbranchsi4m_eq and\n+\ttstbranchsi4m_ne.  Use match_operator and rx_split_cbranch.\n+\t(*cmpsi): Rename from cmpsi.\n+\t(*tstsi): Rename from tstsi.\n+\t(*cmpsf): Rename from cmpsf; use CC_Fmode.\n+\t(*conditional_branch): Rename from conditional_branch.\n+\t(*reveresed_conditional_branch): Remove.\n+\t(b<code>): Remove expander.\n+\t* config/rx/rx-protos.h: Update.\n+\n \t* config/rx/rx.c (rx_compare_redundant): Remove.\n \t* config/rx/rx.md (cmpsi): Don't use it.\n \t* config/rx/rx-protos.h: Update."}, {"sha": "0ab4df3aac9768a440cfff9d9ff44da5f918a235", "filename": "gcc/config/rx/predicates.md", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e963cb1a8a5b1660897be19d0aca20cbdcac413f/gcc%2Fconfig%2Frx%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e963cb1a8a5b1660897be19d0aca20cbdcac413f/gcc%2Fconfig%2Frx%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Fpredicates.md?ref=e963cb1a8a5b1660897be19d0aca20cbdcac413f", "patch": "@@ -293,3 +293,20 @@\n   element = XVECEXP (op, 0, count - 1);\n   return GET_CODE (element) == RETURN;\n })\n+\n+(define_predicate \"label_ref_operand\"\n+  (match_code \"label_ref\")\n+)\n+\n+(define_predicate \"rx_z_comparison_operator\"\n+  (match_code \"eq,ne\")\n+)\n+\n+(define_predicate \"rx_zs_comparison_operator\"\n+  (match_code \"eq,ne,lt,ge\")\n+)\n+\n+;; GT, LE, UNLE, UNGT omitted due to operand swap required.\n+(define_predicate \"rx_fp_comparison_operator\"\n+  (match_code \"eq,ne,lt,ge,ordered,unordered,uneq,unlt,unge,ltgt\")\n+)"}, {"sha": "f0c2105ad1c812a815ca1ada1fc6ae80eb85f4d8", "filename": "gcc/config/rx/rx-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e963cb1a8a5b1660897be19d0aca20cbdcac413f/gcc%2Fconfig%2Frx%2Frx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e963cb1a8a5b1660897be19d0aca20cbdcac413f/gcc%2Fconfig%2Frx%2Frx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx-protos.h?ref=e963cb1a8a5b1660897be19d0aca20cbdcac413f", "patch": "@@ -34,12 +34,13 @@ extern void             rx_emit_stack_popm (rtx *, bool);\n extern void             rx_emit_stack_pushm (rtx *);\n extern void\t\trx_expand_epilogue (bool);\n extern bool\t\trx_expand_insv (rtx *);\n-extern const char *\trx_gen_cond_branch_template (rtx, bool);\n extern char *\t\trx_gen_move_template (rtx *, bool);\n extern bool\t\trx_is_legitimate_constant (rtx);\n extern bool \t\trx_is_mode_dependent_addr (rtx);\n extern bool\t\trx_is_restricted_memory_address (rtx, Mmode);\n extern void\t\trx_notice_update_cc (rtx body, rtx insn);\n+extern void\t\trx_split_cbranch (Mmode, Rcode, rtx, rtx, rtx);\n+extern bool\t\trx_split_fp_compare (Rcode, Rcode *, Rcode *);\n extern Mmode\t\trx_select_cc_mode (Rcode, rtx, rtx);\n #endif\n "}, {"sha": "a2ff95ecdc93909590efecd9ce06ffac08e0633d", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 238, "deletions": 115, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e963cb1a8a5b1660897be19d0aca20cbdcac413f/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e963cb1a8a5b1660897be19d0aca20cbdcac413f/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=e963cb1a8a5b1660897be19d0aca20cbdcac413f", "patch": "@@ -53,6 +53,15 @@\n \f\n static void rx_print_operand (FILE *, rtx, int);\n \n+#define CC_FLAG_S\t(1 << 0)\n+#define CC_FLAG_Z\t(1 << 1)\n+#define CC_FLAG_O\t(1 << 2)\n+#define CC_FLAG_C\t(1 << 3)\n+#define CC_FLAG_FP\t(1 << 4)\t/* fake, to differentiate CC_Fmode */\n+\n+static unsigned int flags_from_mode (enum machine_mode mode);\n+static unsigned int flags_from_code (enum rtx_code code);\n+\n enum rx_cpu_types  rx_cpu_type = RX600;\n \f\n /* Return true if OP is a reference to an object in a small data area.  */\n@@ -395,21 +404,84 @@ rx_print_operand (FILE * file, rtx op, int letter)\n       break;\n \n     case 'B':\n-      switch (GET_CODE (op))\n-\t{\n-\tcase LT:  fprintf (file, \"lt\"); break;\n-\tcase GE:  fprintf (file, \"ge\"); break;\n-\tcase GT:  fprintf (file, \"gt\"); break;\n-\tcase LE:  fprintf (file, \"le\"); break;\n-\tcase GEU: fprintf (file, \"geu\"); break;\n-\tcase LTU: fprintf (file, \"ltu\"); break;\n-\tcase GTU: fprintf (file, \"gtu\"); break;\n-\tcase LEU: fprintf (file, \"leu\"); break;\n-\tcase EQ:  fprintf (file, \"eq\"); break;\n-\tcase NE:  fprintf (file, \"ne\"); break;\n-\tdefault:  debug_rtx (op); gcc_unreachable ();\n-\t}\n-      break;\n+      {\n+\tenum rtx_code code = GET_CODE (op);\n+\tenum machine_mode mode = GET_MODE (XEXP (op, 0));\n+\tconst char *ret;\n+\n+\tif (mode == CC_Fmode)\n+\t  {\n+\t    /* C flag is undefined, and O flag carries unordered.  None of the\n+\t       branch combinations that include O use it helpfully.  */\n+\t    switch (code)\n+\t      {\n+\t      case ORDERED:\n+\t\tret = \"no\";\n+\t\tbreak;\n+\t      case UNORDERED:\n+\t\tret = \"o\";\n+\t\tbreak;\n+\t      case LT:\n+\t\tret = \"n\";\n+\t\tbreak;\n+\t      case GE:\n+\t\tret = \"pz\";\n+\t\tbreak;\n+\t      case EQ:\n+\t\tret = \"eq\";\n+\t\tbreak;\n+\t      case NE:\n+\t\tret = \"ne\";\n+\t\tbreak;\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    switch (code)\n+\t      {\n+\t      case LT:\n+\t\tret = \"n\";\n+\t\tbreak;\n+\t      case GE:\n+\t\tret = \"pz\";\n+\t\tbreak;\n+\t      case GT:\n+\t\tret = \"gt\";\n+\t\tbreak;\n+\t      case LE:\n+\t\tret = \"le\";\n+\t\tbreak;\n+\t      case GEU:\n+\t\tret = \"geu\";\n+\t\tbreak;\n+\t      case LTU:\n+\t\tret = \"ltu\";\n+\t\tbreak;\n+\t      case GTU:\n+\t\tret = \"gtu\";\n+\t\tbreak;\n+\t      case LEU:\n+\t\tret = \"leu\";\n+\t\tbreak;\n+\t      case EQ:\n+\t\tret = \"eq\";\n+\t\tbreak;\n+\t      case NE:\n+\t\tret = \"ne\";\n+\t\tbreak;\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n+\t    /* ??? Removable when all of cbranch, cstore, cmove are updated. */\n+\t    if (GET_MODE_CLASS (mode) == MODE_CC)\n+\t    gcc_checking_assert ((flags_from_code (code)\n+\t\t\t\t  & ~flags_from_mode (mode)) == 0);\n+\t  }\n+\tfputs (ret, file);\n+\tbreak;\n+      }\n \n     case 'C':\n       gcc_assert (CONST_INT_P (op));\n@@ -700,51 +772,6 @@ rx_gen_move_template (rtx * operands, bool is_movu)\n \t   extension, src_template, dst_template);\n   return out_template;\n }\n-\n-/* Returns an assembler template for a conditional branch instruction.  */\n-\n-const char *\n-rx_gen_cond_branch_template (rtx condition, bool reversed)\n-{\n-  enum rtx_code code = GET_CODE (condition);\n-\n-  if (reversed)\n-    {\n-      if (rx_float_compare_mode)\n-\tcode = reverse_condition_maybe_unordered (code);\n-      else\n-\tcode = reverse_condition (code);\n-    }\n-\n-  /* We do not worry about encoding the branch length here as GAS knows\n-     how to choose the smallest version, and how to expand a branch that\n-     is to a destination that is out of range.  */\n-\n-  switch (code)\n-    {\n-    case UNEQ:\t    return \"bo\\t1f\\n\\tbeq\\t%0\\n1:\";\n-    case LTGT:\t    return \"bo\\t1f\\n\\tbne\\t%0\\n1:\";\n-    case UNLT:      return \"bo\\t1f\\n\\tbn\\t%0\\n1:\";\n-    case UNGE:      return \"bo\\t1f\\n\\tbpz\\t%0\\n1:\";\n-    case UNLE:      return \"bo\\t1f\\n\\tbgt\\t1f\\n\\tbra\\t%0\\n1:\";\n-    case UNGT:      return \"bo\\t1f\\n\\tble\\t1f\\n\\tbra\\t%0\\n1:\";\n-    case UNORDERED: return \"bo\\t%0\";\n-    case ORDERED:   return \"bno\\t%0\";\n-\n-    case LT:        return rx_float_compare_mode ? \"bn\\t%0\" : \"blt\\t%0\";\n-    case GE:        return rx_float_compare_mode ? \"bpz\\t%0\" : \"bge\\t%0\";\n-    case GT:        return \"bgt\\t%0\";\n-    case LE:        return \"ble\\t%0\";\n-    case GEU:       return \"bgeu\\t%0\";\n-    case LTU:       return \"bltu\\t%0\";\n-    case GTU:       return \"bgtu\\t%0\";\n-    case LEU:       return \"bleu\\t%0\";\n-    case EQ:        return \"beq\\t%0\";\n-    case NE:        return \"bne\\t%0\";\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n \f\n /* Return VALUE rounded up to the next ALIGNMENT boundary.  */\n \n@@ -2543,69 +2570,100 @@ rx_trampoline_init (rtx tramp, tree fndecl, rtx chain)\n     }\n }\n \f\n-\n-static enum machine_mode\n-rx_cc_modes_compatible (enum machine_mode m1, enum machine_mode m2)\n+static int\n+rx_memory_move_cost (enum machine_mode mode, reg_class_t regclass, bool in)\n {\n-  if (m1 == CCmode)\n-    return m2;\n-  if (m2 == CCmode)\n-    return m1;\n-  if (m1 == m2)\n-    return m1;\n-  if (m1 == CC_ZSmode)\n-    return m1;\n-  if (m2 == CC_ZSmode)\n-    return m2;\n-  return VOIDmode;   \n+  return 2 + memory_move_secondary_cost (mode, regclass, in);\n }\n \n-#define CC_FLAG_S (1 << 0)\n-#define CC_FLAG_Z (1 << 1)\n-#define CC_FLAG_O (1 << 2)\n-#define CC_FLAG_C (1 << 3)\n+/* Convert a CC_MODE to the set of flags that it represents.  */\n \n static unsigned int\n-flags_needed_for_conditional (rtx conditional)\n+flags_from_mode (enum machine_mode mode)\n {\n-  switch (GET_CODE (conditional))\n+  switch (mode)\n     {\n-    case LE:\n-    case GT:\treturn CC_FLAG_S | CC_FLAG_Z | CC_FLAG_O;\n-\n-    case LEU:\n-    case GTU:\treturn CC_FLAG_Z | CC_FLAG_C;\n-\n-    case LT:\n-    case GE:\treturn CC_FLAG_S | CC_FLAG_O;\n-\n-    case LTU:\n-    case GEU:\treturn CC_FLAG_C;\n+    case CC_ZSmode:\n+      return CC_FLAG_S | CC_FLAG_Z;\n+    case CC_ZSOmode:\n+      return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_O;\n+    case CC_ZSCmode:\n+      return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_C;\n+    case CCmode:\n+      return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_O | CC_FLAG_C;\n+    case CC_Fmode:\n+      return CC_FLAG_FP;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n \n-    case EQ:\n-    case NE:\treturn CC_FLAG_Z;\n+/* Convert a set of flags to a CC_MODE that can implement it.  */\n \n-    default:\tgcc_unreachable ();\n+static enum machine_mode\n+mode_from_flags (unsigned int f)\n+{\n+  if (f & CC_FLAG_FP)\n+    return CC_Fmode;\n+  if (f & CC_FLAG_O)\n+    {\n+      if (f & CC_FLAG_C)\n+\treturn CCmode;\n+      else\n+\treturn CC_ZSOmode;\n     }\n+  else if (f & CC_FLAG_C)\n+    return CC_ZSCmode;\n+  else\n+    return CC_ZSmode;\n }\n \n+/* Convert an RTX_CODE to the set of flags needed to implement it.\n+   This assumes an integer comparison.  */\n+\n static unsigned int\n-flags_from_mode (enum machine_mode mode)\n+flags_from_code (enum rtx_code code)\n {\n-  switch (mode)\n+  switch (code)\n     {\n-    case CCmode:     return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_O | CC_FLAG_C;\n-    case CC_ZSmode:  return CC_FLAG_S | CC_FLAG_Z;\n-    case CC_ZSOmode: return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_O;\n-    case CC_ZSCmode: return CC_FLAG_S | CC_FLAG_Z | CC_FLAG_C;\n-    default:         gcc_unreachable ();\n+    case LT:\n+    case GE:\n+      return CC_FLAG_S;\n+    case GT:\n+    case LE:\n+      return CC_FLAG_S | CC_FLAG_O | CC_FLAG_Z;\n+    case GEU:\n+    case LTU:\n+      return CC_FLAG_C;\n+    case GTU:\n+    case LEU:\n+      return CC_FLAG_C | CC_FLAG_Z;\n+    case EQ:\n+    case NE:\n+      return CC_FLAG_Z;\n+    default:\n+      gcc_unreachable ();\n     }\n }\n \n-static int\n-rx_memory_move_cost (enum machine_mode mode, reg_class_t regclass, bool in)\n+/* Return a CC_MODE of which both M1 and M2 are subsets.  */\n+\n+static enum machine_mode\n+rx_cc_modes_compatible (enum machine_mode m1, enum machine_mode m2)\n {\n-  return 2 + memory_move_secondary_cost (mode, regclass, in);\n+  unsigned f;\n+\n+  /* Early out for identical modes.  */\n+  if (m1 == m2)\n+    return m1;\n+\n+  /* There's no valid combination for FP vs non-FP.  */\n+  f = flags_from_mode (m1) | flags_from_mode (m2);\n+  if (f & CC_FLAG_FP)\n+    return VOIDmode;\n+\n+  /* Otherwise, see what mode can implement all the flags.  */\n+  return mode_from_flags (f);\n }\n \n /* Return the minimal CC mode needed to implement (CMP_CODE X Y).  */\n@@ -2616,24 +2674,89 @@ rx_select_cc_mode (enum rtx_code cmp_code, rtx x, rtx y ATTRIBUTE_UNUSED)\n   if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n     return CC_Fmode;\n \n-  switch (cmp_code)\n+  return mode_from_flags (flags_from_code (cmp_code));\n+}\n+\n+/* Split the floating-point comparison IN into individual comparisons\n+   O1 and O2.  O2 may be UNKNOWN if there is no second comparison.\n+   Return true iff the comparison operands must be swapped.  */\n+\n+bool\n+rx_split_fp_compare (enum rtx_code in, enum rtx_code *o1, enum rtx_code *o2)\n+{\n+  enum rtx_code cmp1 = in, cmp2 = UNKNOWN;\n+  bool swap = false;\n+\n+  switch (in)\n     {\n-    case EQ:\n-    case NE:\n+    case ORDERED:\n+    case UNORDERED:\n     case LT:\n     case GE:\n-      return CC_ZSmode;\n+    case EQ:\n+    case NE:\n+      break;\n+\n     case GT:\n     case LE:\n-      return CC_ZSOmode;\n-    case GEU:\n-    case LTU:\n-    case GTU:\n-    case LEU:\n-      return CC_ZSCmode;\n+      cmp1 = swap_condition (cmp1);\n+      swap = true;\n+      break;\n+\n+    case UNEQ:\n+      cmp1 = UNORDERED;\n+      cmp2 = EQ;\n+      break;\n+    case UNLT:\n+      cmp1 = UNORDERED;\n+      cmp2 = LT;\n+      break;\n+    case UNGE:\n+      cmp1 = UNORDERED;\n+      cmp2 = GE;\n+      break;\n+    case UNLE:\n+      cmp1 = UNORDERED;\n+      cmp2 = GT;\n+      swap = true;\n+      break;\n+    case UNGT:\n+      cmp1 = UNORDERED;\n+      cmp2 = LE;\n+      swap = true;\n+      break;\n+    case LTGT:\n+      cmp1 = ORDERED;\n+      cmp2 = NE;\n+      break;\n+\n     default:\n-      return CCmode;\n+      gcc_unreachable ();\n     }\n+\n+  *o1 = cmp1;\n+  *o2 = cmp2;\n+  return swap;\n+}\n+\n+/* Split the conditional branch.  Emit (COMPARE C1 C2) into CC_REG with\n+   CC_MODE, and use that in branches based on that compare.  */\n+\n+void\n+rx_split_cbranch (enum machine_mode cc_mode, enum rtx_code cmp1,\n+\t\t  rtx c1, rtx c2, rtx label)\n+{\n+  rtx flags, x;\n+\n+  flags = gen_rtx_REG (cc_mode, CC_REG);\n+  x = gen_rtx_COMPARE (cc_mode, c1, c2);\n+  x = gen_rtx_SET (VOIDmode, flags, x);\n+  emit_insn (x);\n+\n+  x = gen_rtx_fmt_ee (cmp1, VOIDmode, flags, const0_rtx);\n+  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, label, pc_rtx);\n+  x = gen_rtx_SET (VOIDmode, pc_rtx, x);\n+  emit_jump_insn (x);\n }\n \n \f"}, {"sha": "c2161a251412198e92caea0fdbd67e4281578a26", "filename": "gcc/config/rx/rx.md", "status": "modified", "additions": 179, "deletions": 202, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e963cb1a8a5b1660897be19d0aca20cbdcac413f/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e963cb1a8a5b1660897be19d0aca20cbdcac413f/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=e963cb1a8a5b1660897be19d0aca20cbdcac413f", "patch": "@@ -19,14 +19,6 @@\n ;; <http://www.gnu.org/licenses/>.\n \f\n \n-;; This code iterator allows all branch instructions to\n-;; be generated from a single define_expand template.\n-(define_code_iterator most_cond [eq ne gt ge lt le gtu geu ltu leu\n-\t\t\t\t unordered ordered ])\n-\n-;; Likewise, but only the ones that use Z or S.\n-(define_code_iterator zs_cond [eq ne gtu geu ltu leu ])\n-\n ;; This code iterator is used for sign- and zero- extensions.\n (define_mode_iterator small_int_modes [(HI \"\") (QI \"\")])\n \n@@ -150,6 +142,8 @@\n (define_insn_reservation \"throughput_18_latency_18\"  1\n   (eq_attr \"timings\" \"1818\") \"throughput*18\")\n \n+;; ----------------------------------------------------------------------------\n+\n ;; Comparisons\n \n ;; Note - we do not specify the two instructions necessary to perform\n@@ -160,245 +154,228 @@\n \n (define_expand \"cbranchsi4\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t\t      [(match_operand:SI 1 \"register_operand\")\n-\t\t\t\t       (match_operand:SI 2 \"rx_source_operand\")])\n-\t\t      (label_ref (match_operand 3 \"\"))\n-\t\t      (pc)))\n-   ]\n-  \"\"\n+\t(if_then_else\n+\t  (match_operator 0 \"comparison_operator\"\n+\t    [(match_operand:SI 1 \"register_operand\")\n+\t     (match_operand:SI 2 \"rx_source_operand\")])\n+\t  (label_ref (match_operand 3 \"\"))\n+\t  (pc)))]\n   \"\"\n )\n \n-(define_insn_and_split \"*cbranchsi4_<code>\"\n+(define_insn_and_split \"*cbranchsi4\"\n   [(set (pc)\n-\t(if_then_else (most_cond (match_operand:SI  0 \"register_operand\"  \"r\")\n-\t\t\t\t    (match_operand:SI  1 \"rx_source_operand\" \"riQ\"))\n-\t\t      (label_ref (match_operand        2 \"\" \"\"))\n-\t\t      (pc)))\n-   ]\n+\t(if_then_else\n+\t  (match_operator 3 \"comparison_operator\"\n+\t    [(match_operand:SI  0 \"register_operand\"  \"r\")\n+\t     (match_operand:SI  1 \"rx_source_operand\" \"riQ\")])\n+\t  (match_operand        2 \"label_ref_operand\" \"\")\n+\t  (pc)))]\n   \"\"\n   \"#\"\n   \"reload_completed\"\n   [(const_int 0)]\n-  \"\n-  /* We contstruct the split by hand as otherwise the JUMP_LABEL\n-     attribute is not set correctly on the jump insn.  */\n-  emit_insn (gen_cmpsi (operands[0], operands[1]));\n-  \n-  emit_jump_insn (gen_conditional_branch (operands[2],\n-  \t\t gen_rtx_fmt_ee (<most_cond:CODE>, CCmode,\n-\t\t\t\t gen_rtx_REG (CCmode, CC_REG), const0_rtx)));\n-  \"\n-)\n+{\n+  rx_split_cbranch (CCmode, GET_CODE (operands[3]),\n+\t\t    operands[0], operands[1], operands[2]);\n+  DONE;\n+})\n \n-;; -----------------------------------------------------------------------------\n-;; These two are the canonical TST/branch insns.  However, GCC\n-;; generates a wide variety of tst-like patterns, we catch those\n-;; below.\n-(define_insn_and_split \"*tstbranchsi4_<code>\"\n-  [(set (pc)\n-\t(if_then_else (zs_cond (and:SI (match_operand:SI  0 \"register_operand\"  \"r\")\n-\t\t\t\t       (match_operand:SI  1 \"rx_source_operand\" \"riQ\"))\n-\t\t\t       (const_int 0))\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))\n-   ]\n-  \"\"\n-  \"#\"\n+(define_insn \"*cmpsi\"\n+  [(set (reg:CC CC_REG)\n+\t(compare:CC (match_operand:SI 0 \"register_operand\"  \"r,r,r,r,r,r,r\")\n+\t\t    (match_operand:SI 1 \"rx_source_operand\" \"r,Uint04,Int08,Sint16,Sint24,i,Q\")))]\n   \"reload_completed\"\n-  [(const_int 0)]\n-  \"\n-  emit_insn (gen_tstsi (operands[0], operands[1]));\n-  \n-  emit_jump_insn (gen_conditional_branch (operands[2],\n-  \t\t gen_rtx_fmt_ee (<zs_cond:CODE>, CCmode,\n-\t\t\t\t gen_rtx_REG (CCmode, CC_REG), const0_rtx)));\n-  \"\n+  \"cmp\\t%Q1, %0\"\n+  [(set_attr \"timings\" \"11,11,11,11,11,11,33\")\n+   (set_attr \"length\"  \"2,2,3,4,5,6,5\")]\n )\n \n-;; Inverse of above\n-(define_insn_and_split \"*tstbranchsi4r_<code>\"\n+;; Canonical method for representing TST.\n+(define_insn_and_split \"*cbranchsi4_tst\"\n   [(set (pc)\n-\t(if_then_else (zs_cond (and:SI (match_operand:SI  0 \"register_operand\"  \"r\")\n-\t\t\t\t       (match_operand:SI  1 \"rx_source_operand\" \"riQ\"))\n-\t\t\t       (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))))\n-   ]\n+\t(if_then_else\n+\t  (match_operator 3 \"rx_zs_comparison_operator\"\n+\t    [(and:SI (match_operand:SI  0 \"register_operand\"  \"r\")\n+\t\t     (match_operand:SI  1 \"rx_source_operand\" \"riQ\"))\n+\t     (const_int 0)])\n+\t  (match_operand 2 \"label_ref_operand\" \"\")\n+\t  (pc)))]\n   \"\"\n   \"#\"\n   \"reload_completed\"\n   [(const_int 0)]\n-  \"\n-  emit_insn (gen_tstsi (operands[0], operands[1]));\n-  \n-  emit_jump_insn (gen_conditional_branch (operands[2],\n-  \t\t gen_rtx_fmt_ee (reverse_condition (<zs_cond:CODE>), CCmode,\n-\t\t\t\t gen_rtx_REG (CCmode, CC_REG), const0_rtx)));\n-  \"\n-)\n+{\n+  rx_split_cbranch (CC_ZSmode, GET_CODE (operands[3]),\n+\t\t    XEXP (operands[3], 0), XEXP (operands[3], 1),\n+\t\t    operands[2]);\n+  DONE;\n+})\n \n ;; Various other ways that GCC codes \"var & const\"\n-\n-(define_insn_and_split \"*tstbranchsi4m_eq\"\n-  [(set (pc)\n-\t(if_then_else (eq (zero_extract:SI (match_operand:SI  0 \"register_operand\"  \"r\")\n-\t\t\t\t\t   (match_operand  1 \"rx_constshift_operand\" \"i\")\n-\t\t\t\t\t   (match_operand  2 \"rx_constshift_operand\" \"i\"))\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand        3 \"\" \"\"))\n-\t\t      (pc)))\n-   ]\n-  \"\"\n-  \"#\"\n-  \"\"\n-  [(set (pc)\n-\t(if_then_else (eq (and:SI (match_dup  0)\n-\t\t\t\t  (match_dup 4))\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_dup 3))\n-\t\t      (pc)))\n-   ]\n-  \"operands[4] = GEN_INT (((1 << INTVAL (operands[1]))-1) << INTVAL (operands[2]));\"\n-)\n-\n-(define_insn_and_split \"*tstbranchsi4m_ne\"\n+(define_insn_and_split \"*cbranchsi4_tst_ext\"\n   [(set (pc)\n-\t(if_then_else (ne (zero_extract:SI (match_operand:SI  0 \"register_operand\"  \"r\")\n-\t\t\t\t\t   (match_operand  1 \"rx_constshift_operand\" \"i\")\n-\t\t\t\t\t   (match_operand  2 \"rx_constshift_operand\" \"i\"))\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand        3 \"\" \"\"))\n-\t\t      (pc)))\n-   ]\n+\t(if_then_else\n+\t  (match_operator 4 \"rx_z_comparison_operator\"\n+\t    [(zero_extract:SI\n+\t\t(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 1 \"rx_constshift_operand\" \"\")\n+\t\t(match_operand:SI 2 \"rx_constshift_operand\" \"\"))\n+\t     (const_int 0)])\n+\t  (match_operand 3 \"label_ref_operand\" \"\")\n+\t  (pc)))]\n   \"\"\n   \"#\"\n-  \"\"\n-  [(set (pc)\n-\t(if_then_else (ne (and:SI (match_dup  0)\n-\t\t\t\t  (match_dup 4))\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_dup 3))\n-\t\t      (pc)))\n-   ]\n-  \"operands[4] = GEN_INT (((1 << INTVAL (operands[1]))-1) << INTVAL (operands[2]));\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  HOST_WIDE_INT mask;\n+  rtx x;\n+\n+  mask = 1;\n+  mask <<= INTVAL (operands[1]);\n+  mask -= 1;\n+  mask <<= INTVAL (operands[2]);\n+  x = gen_rtx_AND (SImode, operands[0], gen_int_mode (mask, SImode));\n+\n+  rx_split_cbranch (CC_ZSmode, GET_CODE (operands[4]),\n+\t\t    x, const0_rtx, operands[3]);\n+  DONE;\n+})\n+\n+(define_insn \"*tstsi\"\n+  [(set (reg:CC_ZS CC_REG)\n+\t(compare:CC_ZS\n+\t  (and:SI (match_operand:SI 0 \"register_operand\"  \"r,r,r\")\n+\t\t  (match_operand:SI 1 \"rx_source_operand\" \"r,i,Q\"))\n+\t  (const_int 0)))]\n+  \"reload_completed\"\n+  \"tst\\t%Q1, %0\"\n+  [(set_attr \"timings\" \"11,11,33\")\n+   (set_attr \"length\"  \"3,7,6\")]\n )\n \n-;; -----------------------------------------------------------------------------\n-\n (define_expand \"cbranchsf4\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t\t      [(match_operand:SF 1 \"register_operand\")\n-\t\t\t\t       (match_operand:SF 2 \"rx_source_operand\")])\n-\t\t      (label_ref (match_operand 3 \"\"))\n-\t\t      (pc)))\n-   ]\n+\t(if_then_else\n+\t  (match_operator 0 \"comparison_operator\"\n+\t    [(match_operand:SF 1 \"register_operand\")\n+\t     (match_operand:SF 2 \"register_operand\")])\n+          (label_ref (match_operand 3 \"\"))\n+\t  (pc)))]\n   \"ALLOW_RX_FPU_INSNS\"\n-  \"\"\n-)\n-\n-(define_insn_and_split \"*cbranchsf4_<code>\"\n+{\n+  enum rtx_code cmp1, cmp2;\n+\n+  /* If the comparison needs swapping of operands, do that now.\n+     Do not split the comparison in two yet.  */\n+  if (rx_split_fp_compare (GET_CODE (operands[0]), &cmp1, &cmp2))\n+    {\n+      rtx op1, op2;\n+\n+      if (cmp2 != UNKNOWN)\n+\t{\n+\t  gcc_assert (cmp1 == UNORDERED);\n+\t  if (cmp2 == GT)\n+\t    cmp1 = UNGT;\n+\t  else if (cmp2 == LE)\n+\t    cmp1 = UNLE;\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+\n+      op1 = operands[2];\n+      op2 = operands[1];\n+      operands[0] = gen_rtx_fmt_ee (cmp1, VOIDmode, op1, op2);\n+      operands[1] = op1;\n+      operands[2] = op2;\n+    }\n+})\n+\n+(define_insn_and_split \"*cbranchsf4\"\n   [(set (pc)\n-\t(if_then_else (most_cond (match_operand:SF  0 \"register_operand\"  \"r\")\n-\t\t\t\t (match_operand:SF  1 \"rx_source_operand\" \"rFiQ\"))\n-\t\t      (label_ref (match_operand        2 \"\" \"\"))\n-\t\t      (pc)))\n-   ]\n+\t(if_then_else\n+\t  (match_operator 3 \"rx_fp_comparison_operator\"\n+\t    [(match_operand:SF  0 \"register_operand\"  \"r\")\n+\t     (match_operand:SF  1 \"rx_source_operand\" \"rFiQ\")])\n+\t  (match_operand        2 \"label_ref_operand\" \"\")\n+\t  (pc)))]\n   \"ALLOW_RX_FPU_INSNS\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n-  \"\n-  /* We contstruct the split by hand as otherwise the JUMP_LABEL\n-     attribute is not set correctly on the jump insn.  */\n-  emit_insn (gen_cmpsf (operands[0], operands[1]));\n-  \n-  emit_jump_insn (gen_conditional_branch (operands[2],\n-  \t\t gen_rtx_fmt_ee (<most_cond:CODE>, CCmode,\n- \t\t \t\t gen_rtx_REG (CCmode, CC_REG), const0_rtx)));\n-  \"\n-)\n-\n-(define_insn \"tstsi\"\n-  [(set (reg:CC_ZS CC_REG)\n-\t(compare:CC_ZS (and:SI (match_operand:SI 0 \"register_operand\"  \"r,r,r\")\n-\t\t\t       (match_operand:SI 1 \"rx_source_operand\" \"r,i,Q\"))\n-\t\t       (const_int 0)))]\n-  \"\"\n-  {\n-    rx_float_compare_mode = false;\n-    return \"tst\\t%Q1, %0\";\n-  }\n-  [(set_attr \"timings\" \"11,11,33\")\n-   (set_attr \"length\"   \"3,7,6\")]\n-)\n-\n-(define_insn \"cmpsi\"\n-  [(set (reg:CC CC_REG)\n-\t(compare:CC (match_operand:SI 0 \"register_operand\"  \"r,r,r,r,r,r,r\")\n-\t\t    (match_operand:SI 1 \"rx_source_operand\" \"r,Uint04,Int08,Sint16,Sint24,i,Q\")))]\n-  \"\"\n-  \"cmp\\t%Q1, %0\"\n-  [(set_attr \"timings\" \"11,11,11,11,11,11,33\")\n-   (set_attr \"length\"  \"2,2,3,4,5,6,5\")]\n-)\n-\n-;; ??? g++.dg/eh/080514-1.C to see this happen.\n-(define_insn \"cmpsf\"\n-  [(set (reg:CC_ZSO CC_REG)\n-\t(compare:CC_ZSO (match_operand:SF 0 \"register_operand\"  \"r,r,r\")\n-\t\t\t(match_operand:SF 1 \"rx_source_operand\" \"r,iF,Q\")))]\n-  \"ALLOW_RX_FPU_INSNS\"\n-  {\n-    rx_float_compare_mode = true;\n-    return \"fcmp\\t%1, %0\";\n-  }\n+{\n+  enum rtx_code cmp0, cmp1, cmp2;\n+  rtx flags, lab1, lab2, over, x;\n+  bool swap;\n+\n+  cmp0 = GET_CODE (operands[3]);\n+  swap = rx_split_fp_compare (cmp0, &cmp1, &cmp2);\n+  gcc_assert (!swap);\n+\n+  flags = gen_rtx_REG (CC_Fmode, CC_REG);\n+  x = gen_rtx_COMPARE (CC_Fmode, operands[0], operands[1]);\n+  x = gen_rtx_SET (VOIDmode, flags, x);\n+  emit_insn (x);\n+\n+  over = NULL;\n+  lab1 = lab2 = operands[2];\n+\n+  /* The one case of LTGT needs to be split into cmp1 && cmp2.  */\n+  if (cmp0 == LTGT)\n+    {\n+      over = gen_label_rtx ();\n+      lab1 = gen_rtx_LABEL_REF (VOIDmode, over);\n+      cmp1 = reverse_condition_maybe_unordered (cmp1);\n+    }\n+\n+  /* Otherwise we split into cmp1 || cmp2.  */\n+  x = gen_rtx_fmt_ee (cmp1, VOIDmode, flags, const0_rtx);\n+  x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, lab1, pc_rtx);\n+  x = gen_rtx_SET (VOIDmode, pc_rtx, x);\n+  emit_jump_insn (x);\n+\n+  if (cmp2 != UNKNOWN)\n+    {\n+      x = gen_rtx_fmt_ee (cmp2, VOIDmode, flags, const0_rtx);\n+      x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, lab2, pc_rtx);\n+      x = gen_rtx_SET (VOIDmode, pc_rtx, x);\n+      emit_jump_insn (x);\n+    }\n+\n+  if (over)\n+    emit_label (over);\n+  DONE;\n+})\n+\n+(define_insn \"*cmpsf\"\n+  [(set (reg:CC_F CC_REG)\n+\t(compare:CC_F\n+\t  (match_operand:SF 0 \"register_operand\"  \"r,r,r\")\n+\t  (match_operand:SF 1 \"rx_source_operand\" \"r,iF,Q\")))]\n+  \"ALLOW_RX_FPU_INSNS && reload_completed\"\n+  \"fcmp\\t%1, %0\"\n   [(set_attr \"timings\" \"11,11,33\")\n    (set_attr \"length\" \"3,7,5\")]\n )\n \n ;; Flow Control Instructions:\n \n-(define_expand \"b<code>\"\n-  [(set (pc)\n-        (if_then_else (most_cond (reg:CC CC_REG) (const_int 0))\n-                      (label_ref (match_operand 0))\n-                      (pc)))]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"conditional_branch\"\n+(define_insn \"*conditional_branch\"\n   [(set (pc)\n-\t(if_then_else (match_operator           1 \"comparison_operator\"\n-\t\t\t\t\t\t[(reg:CC CC_REG) (const_int 0)])\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+\t(if_then_else\n+\t  (match_operator 1 \"comparison_operator\"\n+\t    [(reg CC_REG) (const_int 0)])\n+\t  (label_ref (match_operand 0 \"\" \"\"))\n+\t  (pc)))]\n   \"\"\n-  {\n-    return rx_gen_cond_branch_template (operands[1], false);\n-  }\n+  \"b%B1\\t%0\"\n   [(set_attr \"length\" \"8\")    ;; This length is wrong, but it is\n                               ;; too hard to compute statically.\n    (set_attr \"timings\" \"33\")] ;; The timing assumes that the branch is taken.\n )\n \n-(define_insn \"*reveresed_conditional_branch\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(reg:CC CC_REG) (const_int 0)])\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  {\n-    return rx_gen_cond_branch_template (operands[1], true);\n-  }\n-  [(set_attr \"length\" \"8\")    ;; This length is wrong, but it is\n-                              ;; too hard to compute statically.\n-   (set_attr \"timings\" \"33\")] ;; The timing assumes that the branch is taken.\n-)\n+;; ----------------------------------------------------------------------------\n \n (define_insn \"jump\"\n   [(set (pc)"}]}