{"sha": "399f5feb92e4c588ec230d4a0b8ac9b0fa95d7ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk5ZjVmZWI5MmU0YzU4OGVjMjMwZDRhMGI4YWM5YjBmYTk1ZDdlZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2015-12-22T01:58:17Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-12-22T01:58:17Z"}, "message": "go-gcc.cc (class Bvariable): Remove Gcc_tree parent class.\n\n\t* go-gcc.cc (class Bvariable): Remove Gcc_tree parent class.  Add\n\tt_ and orig_type_ fields.  Add new two parameter constructor.  Add\n\tget_tree and get_decl methods.\n\t(Gcc_backend::var_expression): Pass location to var get_tree.\n\t(Gcc_backend::global_variable): Don't add VIEW_CONVERT_EXPR.  Use\n\ttwo parameter constructor for Bvariable.\n\t(Gcc_backend::global_variable_set_init): Don't remove\n\tVIEW_CONVERT_EXPR.  Use var get_decl, not get_tree.\n\t(Gcc_backend::write_global_definitions): Likewise.\n\t(Gcc_backend::init_statement): Call var get_decl, not get_tree.\n\t(Gcc_backend::block): Likewise.\n\t(Gcc_backend::implicit_variable_set_init): Likewise.\n\t(Gcc_backend::immutable_struct_set_init): Likewise.\n\t(Gcc_backend::function_set_parameters): Likewise.\n\nFrom-SVN: r231894", "tree": {"sha": "a8c1bae049e51a32ca8a424d0e68ee92fff9152e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8c1bae049e51a32ca8a424d0e68ee92fff9152e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/399f5feb92e4c588ec230d4a0b8ac9b0fa95d7ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/399f5feb92e4c588ec230d4a0b8ac9b0fa95d7ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/399f5feb92e4c588ec230d4a0b8ac9b0fa95d7ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/399f5feb92e4c588ec230d4a0b8ac9b0fa95d7ed/comments", "author": null, "committer": null, "parents": [{"sha": "18fb580c1e9e378448f202a818ff9f5aa1596574", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18fb580c1e9e378448f202a818ff9f5aa1596574", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18fb580c1e9e378448f202a818ff9f5aa1596574"}], "stats": {"total": 106, "additions": 77, "deletions": 29}, "files": [{"sha": "a6a0aad9256e939e6ab8954509742db9ef900de8", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399f5feb92e4c588ec230d4a0b8ac9b0fa95d7ed/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399f5feb92e4c588ec230d4a0b8ac9b0fa95d7ed/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=399f5feb92e4c588ec230d4a0b8ac9b0fa95d7ed", "patch": "@@ -1,3 +1,20 @@\n+2015-12-21  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-gcc.cc (class Bvariable): Remove Gcc_tree parent class.  Add\n+\tt_ and orig_type_ fields.  Add new two parameter constructor.  Add\n+\tget_tree and get_decl methods.\n+\t(Gcc_backend::var_expression): Pass location to var get_tree.\n+\t(Gcc_backend::global_variable): Don't add VIEW_CONVERT_EXPR.  Use\n+\ttwo parameter constructor for Bvariable.\n+\t(Gcc_backend::global_variable_set_init): Don't remove\n+\tVIEW_CONVERT_EXPR.  Use var get_decl, not get_tree.\n+\t(Gcc_backend::write_global_definitions): Likewise.\n+\t(Gcc_backend::init_statement): Call var get_decl, not get_tree.\n+\t(Gcc_backend::block): Likewise.\n+\t(Gcc_backend::implicit_variable_set_init): Likewise.\n+\t(Gcc_backend::immutable_struct_set_init): Likewise.\n+\t(Gcc_backend::function_set_parameters): Likewise.\n+\n 2015-12-21  Ian Lance Taylor  <iant@google.com>\n \n \t* go-gcc.cc (Gcc_backend::global_variable): If type is zero-sized,"}, {"sha": "eac321b7bb2007b4512aece05ea20b19c24e5f62", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 60, "deletions": 29, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399f5feb92e4c588ec230d4a0b8ac9b0fa95d7ed/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399f5feb92e4c588ec230d4a0b8ac9b0fa95d7ed/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=399f5feb92e4c588ec230d4a0b8ac9b0fa95d7ed", "patch": "@@ -109,22 +109,65 @@ class Bblock : public Gcc_tree\n   { }\n };\n \n-class Bvariable : public Gcc_tree\n+class Blabel : public Gcc_tree\n {\n  public:\n-  Bvariable(tree t)\n+  Blabel(tree t)\n     : Gcc_tree(t)\n   { }\n };\n \n-class Blabel : public Gcc_tree\n+// Bvariable is a bit more complicated, because of zero-sized types.\n+// The GNU linker does not permit dynamic variables with zero size.\n+// When we see such a variable, we generate a version of the type with\n+// non-zero size.  However, when referring to the global variable, we\n+// want an expression of zero size; otherwise, if, say, the global\n+// variable is passed to a function, we will be passing a\n+// non-zero-sized value to a zero-sized value, which can lead to a\n+// miscompilation.\n+\n+class Bvariable\n {\n  public:\n-  Blabel(tree t)\n-    : Gcc_tree(t)\n+  Bvariable(tree t)\n+    : t_(t), orig_type_(NULL)\n+  { }\n+\n+  Bvariable(tree t, tree orig_type)\n+    : t_(t), orig_type_(orig_type)\n   { }\n+\n+  // Get the tree for use as an expression.\n+  tree\n+  get_tree(Location) const;\n+\n+  // Get the actual decl;\n+  tree\n+  get_decl() const\n+  { return this->t_; }\n+\n+ private:\n+  tree t_;\n+  tree orig_type_;\n };\n \n+// Get the tree of a variable for use as an expression.  If this is a\n+// zero-sized global, create an expression that refers to the decl but\n+// has zero size.\n+tree\n+Bvariable::get_tree(Location location) const\n+{\n+  if (this->orig_type_ == NULL\n+      || this->t_ == error_mark_node\n+      || TREE_TYPE(this->t_) == this->orig_type_)\n+    return this->t_;\n+  // Return *(orig_type*)&decl.  */\n+  tree t = build_fold_addr_expr_loc(location.gcc_location(), this->t_);\n+  t = fold_build1_loc(location.gcc_location(), NOP_EXPR,\n+\t\t      build_pointer_type(this->orig_type_), t);\n+  return build_fold_indirect_ref_loc(location.gcc_location(), t);\n+}\n+\n // This file implements the interface between the Go frontend proper\n // and the gcc IR.  This implements specific instantiations of\n // abstract classes defined by the Go frontend proper.  The Go\n@@ -1158,9 +1201,9 @@ Gcc_backend::zero_expression(Btype* btype)\n // An expression that references a variable.\n \n Bexpression*\n-Gcc_backend::var_expression(Bvariable* var, Location)\n+Gcc_backend::var_expression(Bvariable* var, Location location)\n {\n-  tree ret = var->get_tree();\n+  tree ret = var->get_tree(location);\n   if (ret == error_mark_node)\n     return this->error_expression();\n   return this->make_expression(ret);\n@@ -1894,7 +1937,7 @@ Gcc_backend::expression_statement(Bexpression* expr)\n Bstatement*\n Gcc_backend::init_statement(Bvariable* var, Bexpression* init)\n {\n-  tree var_tree = var->get_tree();\n+  tree var_tree = var->get_decl();\n   tree init_tree = init->get_tree();\n   if (var_tree == error_mark_node || init_tree == error_mark_node)\n     return this->error_statement();\n@@ -2264,7 +2307,7 @@ Gcc_backend::block(Bfunction* function, Bblock* enclosing,\n        pv != vars.end();\n        ++pv)\n     {\n-      *pp = (*pv)->get_tree();\n+      *pp = (*pv)->get_decl();\n       if (*pp != error_mark_node)\n \tpp = &DECL_CHAIN(*pp);\n     }\n@@ -2420,11 +2463,7 @@ Gcc_backend::global_variable(const std::string& package_name,\n \n   go_preserve_from_gc(decl);\n \n-  if (orig_type_tree != type_tree)\n-    decl = fold_build1_loc(location.gcc_location(), VIEW_CONVERT_EXPR,\n-\t\t\t   orig_type_tree, decl);\n-\n-  return new Bvariable(decl);\n+  return new Bvariable(decl, orig_type_tree);\n }\n \n // Set the initial value of a global variable.\n@@ -2436,13 +2475,9 @@ Gcc_backend::global_variable_set_init(Bvariable* var, Bexpression* expr)\n   if (expr_tree == error_mark_node)\n     return;\n   gcc_assert(TREE_CONSTANT(expr_tree));\n-  tree var_decl = var->get_tree();\n+  tree var_decl = var->get_decl();\n   if (var_decl == error_mark_node)\n     return;\n-  // Undo the VIEW_CONVERT_EXPR that may have been added by\n-  // global_variable.\n-  if (TREE_CODE(var_decl) == VIEW_CONVERT_EXPR)\n-    var_decl = TREE_OPERAND(var_decl, 0);\n   DECL_INITIAL(var_decl) = expr_tree;\n \n   // If this variable goes in a unique section, it may need to go into\n@@ -2668,7 +2703,7 @@ Gcc_backend::implicit_variable_set_init(Bvariable* var, const std::string&,\n \t\t\t\t\tBtype*, bool, bool, bool is_common,\n \t\t\t\t\tBexpression* init)\n {\n-  tree decl = var->get_tree();\n+  tree decl = var->get_decl();\n   tree init_tree;\n   if (init == NULL)\n     init_tree = NULL_TREE;\n@@ -2762,7 +2797,7 @@ Gcc_backend::immutable_struct_set_init(Bvariable* var, const std::string&,\n \t\t\t\t       bool, bool is_common, Btype*, Location,\n \t\t\t\t       Bexpression* initializer)\n {\n-  tree decl = var->get_tree();\n+  tree decl = var->get_decl();\n   tree init_tree = initializer->get_tree();\n   if (decl == error_mark_node || init_tree == error_mark_node)\n     return;\n@@ -2981,7 +3016,7 @@ Gcc_backend::function_set_parameters(Bfunction* function,\n        pv != param_vars.end();\n        ++pv)\n     {\n-      *pp = (*pv)->get_tree();\n+      *pp = (*pv)->get_decl();\n       gcc_assert(*pp != error_mark_node);\n       pp = &DECL_CHAIN(*pp);\n     }\n@@ -3037,14 +3072,10 @@ Gcc_backend::write_global_definitions(\n        p != variable_decls.end();\n        ++p)\n     {\n-      if ((*p)->get_tree() != error_mark_node)\n+      tree v = (*p)->get_decl();\n+      if (v != error_mark_node)\n         {\n-\t  tree t = (*p)->get_tree();\n-\t  // Undo the VIEW_CONVERT_EXPR that may have been added by\n-\t  // global_variable.\n-\t  if (TREE_CODE(t) == VIEW_CONVERT_EXPR)\n-\t    t = TREE_OPERAND(t, 0);\n-          defs[i] = t;\n+          defs[i] = v;\n           go_preserve_from_gc(defs[i]);\n           ++i;\n         }"}]}