{"sha": "2a55fd4253835815654c550536b3311046bb2b14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE1NWZkNDI1MzgzNTgxNTY1NGM1NTA1MzZiMzMxMTA0NmJiMmIxNA==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2002-03-13T16:57:48Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2002-03-13T16:57:48Z"}, "message": "rs6000.h (PAD_VARARGS_DOWN): Define.\n\n        * config/rs6000/rs6000.h (PAD_VARARGS_DOWN): Define.\n        * config/rs6000/rs6000.c (rs6000_va_arg): Use\n        std_expand_builtin_va_arg if not ABI_V4.\n\nFrom-SVN: r50739", "tree": {"sha": "c33e84ffbc23fa18d05f23a954ab1c55497df37f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c33e84ffbc23fa18d05f23a954ab1c55497df37f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a55fd4253835815654c550536b3311046bb2b14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a55fd4253835815654c550536b3311046bb2b14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a55fd4253835815654c550536b3311046bb2b14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a55fd4253835815654c550536b3311046bb2b14/comments", "author": null, "committer": null, "parents": [{"sha": "9a789d73d1e3ec0db2755ea8ed4ba3cfc0231d1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a789d73d1e3ec0db2755ea8ed4ba3cfc0231d1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a789d73d1e3ec0db2755ea8ed4ba3cfc0231d1f"}], "stats": {"total": 58, "additions": 15, "deletions": 43}, "files": [{"sha": "a9bbb13a4018e174b06ab3f0333fa1890ecbaea9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a55fd4253835815654c550536b3311046bb2b14/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a55fd4253835815654c550536b3311046bb2b14/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a55fd4253835815654c550536b3311046bb2b14", "patch": "@@ -1,3 +1,9 @@\n+2002-03-13  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* config/rs6000/rs6000.h (PAD_VARARGS_DOWN): Define.\n+\t* config/rs6000/rs6000.c (rs6000_va_arg): Use\n+\tstd_expand_builtin_va_arg if not ABI_V4.\n+\n 2002-03-13  Jason Merrill  <jason@redhat.com>\n \n \t* varasm.c (globalize_decl): New fn."}, {"sha": "8ad9fa52e419eeb661a0fe69640c9ef9adf42979", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 43, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a55fd4253835815654c550536b3311046bb2b14/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a55fd4253835815654c550536b3311046bb2b14/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2a55fd4253835815654c550536b3311046bb2b14", "patch": "@@ -2903,8 +2903,6 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n   if (DEFAULT_ABI == ABI_V4)\n     {\n       /* Indicate to allocate space on the stack for varargs save area.  */\n-      /* ??? Does this really have to be located at a magic spot on the\n-\t stack, or can we allocate this with assign_stack_local instead.  */\n       cfun->machine->sysv_varargs_p = 1;\n       if (! no_rtl)\n \tsave_area = plus_constant (virtual_stack_vars_rtx,\n@@ -3096,48 +3094,8 @@ rs6000_va_arg (valist, type)\n   int indirect_p, size, rsize, n_reg, sav_ofs, sav_scale;\n   rtx lab_false, lab_over, addr_rtx, r;\n \n-  /* For AIX, the rule is that structures are passed left-aligned in\n-     their stack slot.  However, GCC does not presently do this:\n-     structures which are the same size as integer types are passed\n-     right-aligned, as if they were in fact integers.  This only\n-     matters for structures of size 1 or 2, or 4 when TARGET_64BIT.  */\n   if (DEFAULT_ABI != ABI_V4)\n-    {\n-      HOST_WIDE_INT align, rounded_size;\n-      enum machine_mode mode;\n-      tree addr_tree;\n-\n-      /* Compute the rounded size of the type.  */\n-      align = PARM_BOUNDARY / BITS_PER_UNIT;\n-      rounded_size = (((int_size_in_bytes (type) + align - 1) / align)\n-\t\t      * align);\n-\n-      addr_tree = valist;\n-\n-      mode = TYPE_MODE (type);\n-      if (mode != BLKmode)\n-\t{\n-\t  HOST_WIDE_INT adj;\n-\t  adj = TREE_INT_CST_LOW (TYPE_SIZE (type)) / BITS_PER_UNIT;\n-\t  if (rounded_size > align)\n-\t    adj = rounded_size;\n-\t  \n-\t  addr_tree = build (PLUS_EXPR, TREE_TYPE (addr_tree), addr_tree,\n-\t\t\t     build_int_2 (rounded_size - adj, 0));\n-\t}\n-\n-      addr_rtx = expand_expr (addr_tree, NULL_RTX, Pmode, EXPAND_NORMAL);\n-      addr_rtx = copy_to_reg (addr_rtx);\n-      \n-      /* Compute new value for AP.  */\n-      t = build (MODIFY_EXPR, TREE_TYPE (valist), valist,\n-\t\t build (PLUS_EXPR, TREE_TYPE (valist), valist,\n-\t\t\tbuild_int_2 (rounded_size, 0)));\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-      \n-      return addr_rtx;\n-    }\n+    return std_expand_builtin_va_arg (valist, type);\n \n   f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n   f_fpr = TREE_CHAIN (f_gpr);"}, {"sha": "ed8f0fb9d8f8ded857afec4d5403c18b971c5e9b", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a55fd4253835815654c550536b3311046bb2b14/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a55fd4253835815654c550536b3311046bb2b14/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=2a55fd4253835815654c550536b3311046bb2b14", "patch": "@@ -1697,6 +1697,14 @@ typedef struct rs6000_args\n #define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n   rs6000_va_arg (valist, type)\n \n+/* For AIX, the rule is that structures are passed left-aligned in\n+   their stack slot.  However, GCC does not presently do this:\n+   structures which are the same size as integer types are passed\n+   right-aligned, as if they were in fact integers.  This only\n+   matters for structures of size 1 or 2, or 4 when TARGET_64BIT.\n+   ABI_V4 does not use std_expand_builtin_va_arg.  */\n+#define PAD_VARARGS_DOWN (TYPE_MODE (type) != BLKmode)\n+\n /* Define this macro to be a nonzero value if the location where a function\n    argument is passed depends on whether or not it is a named argument.  */\n #define STRICT_ARGUMENT_NAMING 1"}]}