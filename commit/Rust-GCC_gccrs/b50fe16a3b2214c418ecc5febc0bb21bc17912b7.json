{"sha": "b50fe16a3b2214c418ecc5febc0bb21bc17912b7", "node_id": "C_kwDOANBUbNoAKGI1MGZlMTZhM2IyMjE0YzQxOGVjYzVmZWJjMGJiMjFiYzE3OTEyYjc", "commit": {"author": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2022-12-16T18:16:31Z"}, "committer": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2022-12-16T18:22:38Z"}, "message": "Revert \"IRA: Check that reg classes contain a hard reg of given mode in reg move cost calculation\"\n\nThe patch resulted in new PRs:\n\n\tPR target/108145\n\tPR testsuite/108141\n\nSo I am reverting the patch.\n\nThis reverts commit 12abd5a7d13209f79664ea603b3f3517f71b8c4f.", "tree": {"sha": "1751546aa3302d00dbb5b78ba5901064e2f40a24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1751546aa3302d00dbb5b78ba5901064e2f40a24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b50fe16a3b2214c418ecc5febc0bb21bc17912b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b50fe16a3b2214c418ecc5febc0bb21bc17912b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b50fe16a3b2214c418ecc5febc0bb21bc17912b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b50fe16a3b2214c418ecc5febc0bb21bc17912b7/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a27ae32fabf85685ffff758459d7ec284ccb95a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a27ae32fabf85685ffff758459d7ec284ccb95a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a27ae32fabf85685ffff758459d7ec284ccb95a"}], "stats": {"total": 123, "additions": 11, "deletions": 112}, "files": [{"sha": "964c94a06ef56e27d0134a66eee7f60700ecfbab", "filename": "gcc/ira-costs.cc", "status": "modified", "additions": 9, "deletions": 93, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b50fe16a3b2214c418ecc5febc0bb21bc17912b7/gcc%2Fira-costs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b50fe16a3b2214c418ecc5febc0bb21bc17912b7/gcc%2Fira-costs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.cc?ref=b50fe16a3b2214c418ecc5febc0bb21bc17912b7", "patch": "@@ -34,7 +34,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ira-int.h\"\n #include \"addresses.h\"\n #include \"reload.h\"\n-#include \"print-rtl.h\"\n \n /* The flags is set up every time when we calculate pseudo register\n    classes through function ira_set_pseudo_classes.  */\n@@ -504,18 +503,6 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n   int insn_allows_mem[MAX_RECOG_OPERANDS];\n   move_table *move_in_cost, *move_out_cost;\n   short (*mem_cost)[2];\n-  const char *p;\n-\n-  if (ira_dump_file != NULL && internal_flag_ira_verbose > 5)\n-    {\n-      fprintf (ira_dump_file, \"    Processing insn %u\", INSN_UID (insn));\n-      if (INSN_CODE (insn) >= 0\n-\t  && (p = get_insn_name (INSN_CODE (insn))) != NULL)\n-\tfprintf (ira_dump_file, \" {%s}\", p);\n-      fprintf (ira_dump_file, \" (freq=%d)\\n\",\n-\t       REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn)));\n-      dump_insn_slim (ira_dump_file, insn);\n-  }\n \n   for (i = 0; i < n_ops; i++)\n     insn_allows_mem[i] = 0;\n@@ -539,21 +526,6 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t  continue;\n \t}\n \n-      if (ira_dump_file != NULL && internal_flag_ira_verbose > 5)\n-\t{\n-\t  fprintf (ira_dump_file, \"      Alt %d:\", alt);\n-\t  for (i = 0; i < n_ops; i++)\n-\t    {\n-\t      p = constraints[i];\n-\t      if (*p == '\\0')\n-\t\tcontinue;\n-\t      fprintf (ira_dump_file, \"  (%d) \", i);\n-\t      for (; *p != '\\0' && *p != ',' && *p != '#'; p++)\n-\t\tfputc (*p, ira_dump_file);\n-\t    }\n-\t  fprintf (ira_dump_file, \"\\n\");\n-\t}\n-      \n       for (i = 0; i < n_ops; i++)\n \t{\n \t  unsigned char c;\n@@ -621,16 +593,12 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t     register, this alternative can't be used.  */\n \n \t\t  if (classes[j] == NO_REGS)\n-\t\t    {\n-\t\t      alt_fail = 1;\n-\t\t    }\n+\t\t    alt_fail = 1;\n+\t\t  /* Otherwise, add to the cost of this alternative\n+\t\t     the cost to copy the other operand to the hard\n+\t\t     register used for this operand.  */\n \t\t  else\n-\t\t    /* Otherwise, add to the cost of this alternative the cost\n-\t\t       to copy the other operand to the hard register used for\n-\t\t       this operand.  */\n-\t\t    {\n-\t\t      alt_cost += copy_cost (ops[j], mode, classes[j], 1, NULL);\n-\t\t    }\n+\t\t    alt_cost += copy_cost (ops[j], mode, classes[j], 1, NULL);\n \t\t}\n \t      else\n \t\t{\n@@ -1053,45 +1021,18 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n       for (i = 0; i < n_ops; i++)\n \tif (REG_P (ops[i]) && REGNO (ops[i]) >= FIRST_PSEUDO_REGISTER)\n \t  {\n-\t    int old_cost;\n-\t    bool cost_change_p = false;\n \t    struct costs *pp = op_costs[i], *qq = this_op_costs[i];\n \t    int *pp_costs = pp->cost, *qq_costs = qq->cost;\n \t    int scale = 1 + (recog_data.operand_type[i] == OP_INOUT);\n \t    cost_classes_t cost_classes_ptr\n \t      = regno_cost_classes[REGNO (ops[i])];\n \n-\t    old_cost = pp->mem_cost;\n-\t    pp->mem_cost = MIN (old_cost,\n+\t    pp->mem_cost = MIN (pp->mem_cost,\n \t\t\t\t(qq->mem_cost + op_cost_add) * scale);\n \n-\t    if (ira_dump_file != NULL && internal_flag_ira_verbose > 5\n-\t\t&& pp->mem_cost < old_cost)\n-\t      {\n-\t\tcost_change_p = true;\n-\t\tfprintf (ira_dump_file, \"        op %d(r=%u) new costs MEM:%d\",\n-\t\t\t i, REGNO(ops[i]), pp->mem_cost);\n-\t      }\n \t    for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n-\t      {\n-\t\told_cost = pp_costs[k];\n-\t\tpp_costs[k]\n-\t\t  = MIN (old_cost, (qq_costs[k] + op_cost_add) * scale);\n-\t\tif (ira_dump_file != NULL && internal_flag_ira_verbose > 5\n-\t\t    && pp_costs[k] < old_cost)\n-\t\t  {\n-\t\t    if (!cost_change_p)\n-\t\t      fprintf (ira_dump_file, \"        op %d(r=%u) new costs\",\n-\t\t\t       i, REGNO(ops[i]));\n-\t\t    cost_change_p = true;\n-\t\t    fprintf (ira_dump_file, \" %s:%d\",\n-\t\t\t     reg_class_names[cost_classes_ptr->classes[k]],\n-\t\t\t     pp_costs[k]);\n-\t\t  }\n-\t      }\n-\t    if (ira_dump_file != NULL && internal_flag_ira_verbose > 5\n-\t\t&& cost_change_p)\n-\t      fprintf (ira_dump_file, \"\\n\");\n+\t      pp_costs[k]\n+\t\t= MIN (pp_costs[k], (qq_costs[k] + op_cost_add) * scale);\n \t  }\n     }\n \n@@ -1565,18 +1506,6 @@ scan_one_insn (rtx_insn *insn)\n \n   record_operand_costs (insn, pref);\n \n-  if (ira_dump_file != NULL && internal_flag_ira_verbose > 5)\n-    {\n-      const char *p;\n-      fprintf (ira_dump_file, \"    Final costs after insn %u\", INSN_UID (insn));\n-      if (INSN_CODE (insn) >= 0\n-\t  && (p = get_insn_name (INSN_CODE (insn))) != NULL)\n-\tfprintf (ira_dump_file, \" {%s}\", p);\n-      fprintf (ira_dump_file, \" (freq=%d)\\n\",\n-\t       REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn)));\n-      dump_insn_slim (ira_dump_file, insn);\n-    }\n-\n   /* Now add the cost for each operand to the total costs for its\n      allocno.  */\n   for (i = 0; i < recog_data.n_operands; i++)\n@@ -1592,7 +1521,7 @@ scan_one_insn (rtx_insn *insn)\n \t  struct costs *q = op_costs[i];\n \t  int *p_costs = p->cost, *q_costs = q->cost;\n \t  cost_classes_t cost_classes_ptr = regno_cost_classes[regno];\n-\t  int add_cost = 0;\n+\t  int add_cost;\n \t  \n \t  /* If the already accounted for the memory \"cost\" above, don't\n \t     do so again.  */\n@@ -1604,27 +1533,14 @@ scan_one_insn (rtx_insn *insn)\n \t      else\n \t\tp->mem_cost += add_cost;\n \t    }\n-\t  if (ira_dump_file != NULL && internal_flag_ira_verbose > 5)\n-\t    {\n-\t      fprintf (ira_dump_file, \"        op %d(r=%u) MEM:%d(+%d)\",\n-\t\t       i, REGNO(op), p->mem_cost, add_cost);\n-\t    }\n \t  for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n \t    {\n \t      add_cost = q_costs[k];\n \t      if (add_cost > 0 && INT_MAX - add_cost < p_costs[k])\n \t\tp_costs[k] = INT_MAX;\n \t      else\n \t\tp_costs[k] += add_cost;\n-\t      if (ira_dump_file != NULL && internal_flag_ira_verbose > 5)\n-\t\t{\n-\t\t  fprintf (ira_dump_file, \" %s:%d(+%d)\",\n-\t\t\t   reg_class_names[cost_classes_ptr->classes[k]],\n-\t\t\t   p_costs[k], add_cost);\n-\t\t}\n \t    }\n-\t  if (ira_dump_file != NULL && internal_flag_ira_verbose > 5)\n-\t    fprintf (ira_dump_file, \"\\n\");\n \t}\n     }\n   return insn;"}, {"sha": "d28a67b2546f1a160761ba342e4e98151af43e84", "filename": "gcc/ira.cc", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b50fe16a3b2214c418ecc5febc0bb21bc17912b7/gcc%2Fira.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b50fe16a3b2214c418ecc5febc0bb21bc17912b7/gcc%2Fira.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.cc?ref=b50fe16a3b2214c418ecc5febc0bb21bc17912b7", "patch": "@@ -1627,22 +1627,14 @@ ira_init_register_move_cost (machine_mode mode)\n \t\t *p2 != LIM_REG_CLASSES; p2++)\n \t      if (ira_class_hard_regs_num[*p2] > 0\n \t\t  && (ira_reg_class_max_nregs[*p2][mode]\n-\t\t      <= ira_class_hard_regs_num[*p2])\n-\t\t  && hard_reg_set_intersect_p (ok_regs,\n-\t\t\t\t\t       reg_class_contents[cl1])\n-\t\t  && hard_reg_set_intersect_p (ok_regs,\n-\t\t\t\t\t       reg_class_contents[*p2]))\n+\t\t      <= ira_class_hard_regs_num[*p2]))\n \t\tcost = MAX (cost, ira_register_move_cost[mode][cl1][*p2]);\n \t    \n \t    for (p1 = &reg_class_subclasses[cl1][0];\n \t\t *p1 != LIM_REG_CLASSES; p1++)\n \t      if (ira_class_hard_regs_num[*p1] > 0\n \t\t  && (ira_reg_class_max_nregs[*p1][mode]\n-\t\t      <= ira_class_hard_regs_num[*p1])\n-\t\t  && hard_reg_set_intersect_p (ok_regs,\n-\t\t\t\t\t       reg_class_contents[cl2])\n-\t\t  && hard_reg_set_intersect_p (ok_regs,\n-\t\t\t\t\t       reg_class_contents[*p1]))\n+\t\t      <= ira_class_hard_regs_num[*p1]))\n \t\tcost = MAX (cost, ira_register_move_cost[mode][*p1][cl2]);\n \t    \n \t    ira_assert (cost <= 65535);"}, {"sha": "4b9bcbe115271bd084c0295cec6503912e31180b", "filename": "gcc/testsuite/gcc.target/avr/pr90706.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a27ae32fabf85685ffff758459d7ec284ccb95a/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Fpr90706.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a27ae32fabf85685ffff758459d7ec284ccb95a/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Fpr90706.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Fpr90706.c?ref=2a27ae32fabf85685ffff758459d7ec284ccb95a", "patch": "@@ -1,9 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-Os\" } */\n- \n-unsigned char check(float x)\n-{\n-   return (0.0 < x);\n-}\n- /* { dg-final { scan-assembler-not \"ldd\" } } */\n- /* { dg-final { scan-assembler-not \"std\" } } */"}]}