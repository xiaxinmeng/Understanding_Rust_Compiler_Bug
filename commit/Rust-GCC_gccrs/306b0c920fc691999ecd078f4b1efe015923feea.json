{"sha": "306b0c920fc691999ecd078f4b1efe015923feea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA2YjBjOTIwZmM2OTE5OTllY2QwNzhmNGIxZWZlMDE1OTIzZmVlYQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-06-28T07:47:35Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-06-28T07:47:35Z"}, "message": "tree-vectorizer.h (vect_get_vec_defs): Remove.\n\n2017-06-28  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vect_get_vec_defs): Remove.\n\t(vect_get_slp_defs): Adjust.\n\t* tree-vect-loop.c (get_initial_defs_for_reduction): Split\n\tout from ...\n\t* tree-vect-slp.c (vect_get_constant_vectors): ... here and\n\tsimplify.\n\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Use\n\tget_initial_defs_for_reduction instead of vect_get_vec_defs.\n\t(vectorizable_reduction): Adjust.\n\t* tree-vect-slp.c (vect_get_constant_vectors): Remove reduction\n\thandling.\n\t(vect_get_slp_defs): Likewise.\n\t* tree-vect-stmts.c (vect_get_vec_defs): Make static and adjust.\n\t(vectorizable_bswap): Adjust.\n\t(vectorizable_call): Likewise.\n\t(vectorizable_conversion): Likewise.\n\t(vectorizable_assignment): Likewise.\n\t(vectorizable_shift): Likewise.\n\t(vectorizable_operation): Likewise.\n\t(vectorizable_store): Likewise.\n\t(vectorizable_condition): Likewise.\n\t(vectorizable_comparison): Likewise.\n\nFrom-SVN: r249722", "tree": {"sha": "29a8b72441abd4aba5bd34d82eef1528351de3cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29a8b72441abd4aba5bd34d82eef1528351de3cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/306b0c920fc691999ecd078f4b1efe015923feea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/306b0c920fc691999ecd078f4b1efe015923feea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/306b0c920fc691999ecd078f4b1efe015923feea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/306b0c920fc691999ecd078f4b1efe015923feea/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "da9c26dd266f4af21d7f57520c2a804375f4457f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da9c26dd266f4af21d7f57520c2a804375f4457f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da9c26dd266f4af21d7f57520c2a804375f4457f"}], "stats": {"total": 370, "additions": 254, "deletions": 116}, "files": [{"sha": "9a7e095c08c395b8b05a2f19b352c662f130079a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/306b0c920fc691999ecd078f4b1efe015923feea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/306b0c920fc691999ecd078f4b1efe015923feea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=306b0c920fc691999ecd078f4b1efe015923feea", "patch": "@@ -1,3 +1,28 @@\n+2017-06-28  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (vect_get_vec_defs): Remove.\n+\t(vect_get_slp_defs): Adjust.\n+\t* tree-vect-loop.c (get_initial_defs_for_reduction): Split\n+\tout from ...\n+\t* tree-vect-slp.c (vect_get_constant_vectors): ... here and\n+\tsimplify.\n+\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Use\n+\tget_initial_defs_for_reduction instead of vect_get_vec_defs.\n+\t(vectorizable_reduction): Adjust.\n+\t* tree-vect-slp.c (vect_get_constant_vectors): Remove reduction\n+\thandling.\n+\t(vect_get_slp_defs): Likewise.\n+\t* tree-vect-stmts.c (vect_get_vec_defs): Make static and adjust.\n+\t(vectorizable_bswap): Adjust.\n+\t(vectorizable_call): Likewise.\n+\t(vectorizable_conversion): Likewise.\n+\t(vectorizable_assignment): Likewise.\n+\t(vectorizable_shift): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_store): Likewise.\n+\t(vectorizable_condition): Likewise.\n+\t(vectorizable_comparison): Likewise.\n+\n 2017-06-28  Michael Collison  <michael.collison@arm.com>\n \n \tPR target/68535"}, {"sha": "0e725aedd8f96683fb66bdbe28645e834c95122d", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 204, "deletions": 3, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/306b0c920fc691999ecd078f4b1efe015923feea/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/306b0c920fc691999ecd078f4b1efe015923feea/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=306b0c920fc691999ecd078f4b1efe015923feea", "patch": "@@ -4045,6 +4045,203 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n   return init_def;\n }\n \n+/* Get at the initial defs for OP in the reduction SLP_NODE.\n+   NUMBER_OF_VECTORS is the number of vector defs to create.\n+   REDUC_INDEX is the index of the reduction operand in the statements.  */\n+\n+static void\n+get_initial_defs_for_reduction (slp_tree slp_node,\n+\t\t\t\tvec<tree> *vec_oprnds,\n+\t\t\t\tunsigned int number_of_vectors,\n+\t\t\t\tint reduc_index, enum tree_code code)\n+{\n+  vec<gimple *> stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n+  gimple *stmt = stmts[0];\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n+  unsigned nunits;\n+  tree vec_cst;\n+  tree *elts;\n+  unsigned j, number_of_places_left_in_vector;\n+  tree vector_type, scalar_type;\n+  tree vop;\n+  int group_size = stmts.length ();\n+  unsigned int vec_num, i;\n+  unsigned number_of_copies = 1;\n+  vec<tree> voprnds;\n+  voprnds.create (number_of_vectors);\n+  bool constant_p;\n+  tree neutral_op = NULL;\n+  gimple *def_stmt;\n+  struct loop *loop;\n+  gimple_seq ctor_seq = NULL;\n+\n+  vector_type = STMT_VINFO_VECTYPE (stmt_vinfo);\n+  scalar_type = TREE_TYPE (vector_type);\n+  nunits = TYPE_VECTOR_SUBPARTS (vector_type);\n+\n+  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def\n+\t      && reduc_index != -1);\n+\n+  /* op is the reduction operand of the first stmt already.  */\n+  /* For additional copies (see the explanation of NUMBER_OF_COPIES below)\n+     we need either neutral operands or the original operands.  See\n+     get_initial_def_for_reduction() for details.  */\n+  switch (code)\n+    {\n+    case WIDEN_SUM_EXPR:\n+    case DOT_PROD_EXPR:\n+    case SAD_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+      neutral_op = build_zero_cst (scalar_type);\n+      break;\n+\n+    case MULT_EXPR:\n+      neutral_op = build_one_cst (scalar_type);\n+      break;\n+\n+    case BIT_AND_EXPR:\n+      neutral_op = build_all_ones_cst (scalar_type);\n+      break;\n+\n+    /* For MIN/MAX we don't have an easy neutral operand but\n+       the initial values can be used fine here.  Only for\n+       a reduction chain we have to force a neutral element.  */\n+    case MAX_EXPR:\n+    case MIN_EXPR:\n+      if (!GROUP_FIRST_ELEMENT (stmt_vinfo))\n+\tneutral_op = NULL;\n+      else\n+\t{\n+\t  tree op = get_reduction_op (stmts[0], reduc_index);\n+\t  def_stmt = SSA_NAME_DEF_STMT (op);\n+\t  loop = (gimple_bb (stmt))->loop_father;\n+\t  neutral_op = PHI_ARG_DEF_FROM_EDGE (def_stmt,\n+\t\t\t\t\t      loop_preheader_edge (loop));\n+\t}\n+      break;\n+\n+    default:\n+      gcc_assert (!GROUP_FIRST_ELEMENT (stmt_vinfo));\n+      neutral_op = NULL;\n+    }\n+\n+  /* NUMBER_OF_COPIES is the number of times we need to use the same values in\n+     created vectors. It is greater than 1 if unrolling is performed.\n+\n+     For example, we have two scalar operands, s1 and s2 (e.g., group of\n+     strided accesses of size two), while NUNITS is four (i.e., four scalars\n+     of this type can be packed in a vector).  The output vector will contain\n+     two copies of each scalar operand: {s1, s2, s1, s2}.  (NUMBER_OF_COPIES\n+     will be 2).\n+\n+     If GROUP_SIZE > NUNITS, the scalars will be split into several vectors\n+     containing the operands.\n+\n+     For example, NUNITS is four as before, and the group size is 8\n+     (s1, s2, ..., s8).  We will create two vectors {s1, s2, s3, s4} and\n+     {s5, s6, s7, s8}.  */\n+\n+  number_of_copies = nunits * number_of_vectors / group_size;\n+\n+  number_of_places_left_in_vector = nunits;\n+  constant_p = true;\n+  elts = XALLOCAVEC (tree, nunits);\n+  for (j = 0; j < number_of_copies; j++)\n+    {\n+      for (i = group_size - 1; stmts.iterate (i, &stmt); i--)\n+        {\n+\t  tree op = get_reduction_op (stmt, reduc_index);\n+\t  loop = (gimple_bb (stmt))->loop_father;\n+\t  def_stmt = SSA_NAME_DEF_STMT (op);\n+\n+\t  gcc_assert (loop);\n+\n+\t  /* Get the def before the loop.  In reduction chain we have only\n+\t     one initial value.  */\n+\t  if ((j != (number_of_copies - 1)\n+\t       || (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n+\t\t   && i != 0))\n+\t      && neutral_op)\n+\t    op = neutral_op;\n+\t  else\n+\t    op = PHI_ARG_DEF_FROM_EDGE (def_stmt,\n+\t\t\t\t\tloop_preheader_edge (loop));\n+\n+          /* Create 'vect_ = {op0,op1,...,opn}'.  */\n+          number_of_places_left_in_vector--;\n+\t  elts[number_of_places_left_in_vector] = op;\n+\t  if (!CONSTANT_CLASS_P (op))\n+\t    constant_p = false;\n+\n+          if (number_of_places_left_in_vector == 0)\n+            {\n+\t      if (constant_p)\n+\t\tvec_cst = build_vector (vector_type, elts);\n+\t      else\n+\t\t{\n+\t\t  vec<constructor_elt, va_gc> *v;\n+\t\t  unsigned k;\n+\t\t  vec_alloc (v, nunits);\n+\t\t  for (k = 0; k < nunits; ++k)\n+\t\t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, elts[k]);\n+\t\t  vec_cst = build_constructor (vector_type, v);\n+\t\t}\n+\t      tree init;\n+\t      gimple_stmt_iterator gsi;\n+\t      init = vect_init_vector (stmt, vec_cst, vector_type, NULL);\n+\t      if (ctor_seq != NULL)\n+\t\t{\n+\t\t  gsi = gsi_for_stmt (SSA_NAME_DEF_STMT (init));\n+\t\t  gsi_insert_seq_before_without_update (&gsi, ctor_seq,\n+\t\t\t\t\t\t\tGSI_SAME_STMT);\n+\t\t  ctor_seq = NULL;\n+\t\t}\n+\t      voprnds.quick_push (init);\n+\n+              number_of_places_left_in_vector = nunits;\n+\t      constant_p = true;\n+            }\n+        }\n+    }\n+\n+  /* Since the vectors are created in the reverse order, we should invert\n+     them.  */\n+  vec_num = voprnds.length ();\n+  for (j = vec_num; j != 0; j--)\n+    {\n+      vop = voprnds[j - 1];\n+      vec_oprnds->quick_push (vop);\n+    }\n+\n+  voprnds.release ();\n+\n+  /* In case that VF is greater than the unrolling factor needed for the SLP\n+     group of stmts, NUMBER_OF_VECTORS to be created is greater than\n+     NUMBER_OF_SCALARS/NUNITS or NUNITS/NUMBER_OF_SCALARS, and hence we have\n+     to replicate the vectors.  */\n+  while (number_of_vectors > vec_oprnds->length ())\n+    {\n+      tree neutral_vec = NULL;\n+\n+      if (neutral_op)\n+        {\n+          if (!neutral_vec)\n+\t    neutral_vec = build_vector_from_val (vector_type, neutral_op);\n+\n+          vec_oprnds->quick_push (neutral_vec);\n+        }\n+      else\n+        {\n+          for (i = 0; vec_oprnds->iterate (i, &vop) && i < vec_num; i++)\n+            vec_oprnds->quick_push (vop);\n+        }\n+    }\n+}\n+\n+\n /* Function vect_create_epilog_for_reduction\n \n    Create code at the loop-epilog to finalize the result of a reduction\n@@ -4189,8 +4386,12 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n   /* Get the loop-entry arguments.  */\n   enum vect_def_type initial_def_dt = vect_unknown_def_type;\n   if (slp_node)\n-    vect_get_vec_defs (reduction_op, NULL_TREE, stmt, &vec_initial_defs,\n-                       NULL, slp_node, reduc_index);\n+    {\n+      unsigned vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+      vec_initial_defs.reserve (vec_num);\n+      get_initial_defs_for_reduction (slp_node, &vec_initial_defs,\n+\t\t\t\t      vec_num, reduc_index, code);\n+    }\n   else\n     {\n       /* Get at the scalar def before the loop, that defines the initial value\n@@ -5939,7 +6140,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      if (op_type == ternary_op)\n \t\tslp_ops.quick_push (reduc_index == 2 ? NULL : ops[2]);\n \n-\t      vect_get_slp_defs (slp_ops, slp_node, &vec_defs, -1);\n+\t      vect_get_slp_defs (slp_ops, slp_node, &vec_defs);\n \n \t      vec_oprnds0.safe_splice (vec_defs[reduc_index == 0 ? 1 : 0]);\n \t      vec_defs[reduc_index == 0 ? 1 : 0].release ();"}, {"sha": "b755562ed762a0698d9afa662a21e7c6cba114fd", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 4, "deletions": 88, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/306b0c920fc691999ecd078f4b1efe015923feea/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/306b0c920fc691999ecd078f4b1efe015923feea/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=306b0c920fc691999ecd078f4b1efe015923feea", "patch": "@@ -2976,8 +2976,7 @@ vect_mask_constant_operand_p (gimple *stmt, int opnum)\n static void\n vect_get_constant_vectors (tree op, slp_tree slp_node,\n                            vec<tree> *vec_oprnds,\n-\t\t\t   unsigned int op_num, unsigned int number_of_vectors,\n-                           int reduc_index)\n+\t\t\t   unsigned int op_num, unsigned int number_of_vectors)\n {\n   vec<gimple *> stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n   gimple *stmt = stmts[0];\n@@ -2996,8 +2995,6 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n   bool constant_p, is_store;\n   tree neutral_op = NULL;\n   enum tree_code code = gimple_expr_code (stmt);\n-  gimple *def_stmt;\n-  struct loop *loop;\n   gimple_seq ctor_seq = NULL;\n \n   /* Check if vector type is a boolean vector.  */\n@@ -3009,64 +3006,6 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n     vector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n   nunits = TYPE_VECTOR_SUBPARTS (vector_type);\n \n-  if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def\n-      && reduc_index != -1)\n-    {\n-      op_num = reduc_index;\n-      op = gimple_op (stmt, op_num + 1);\n-      /* For additional copies (see the explanation of NUMBER_OF_COPIES below)\n-         we need either neutral operands or the original operands.  See\n-         get_initial_def_for_reduction() for details.  */\n-      switch (code)\n-        {\n-          case WIDEN_SUM_EXPR:\n-          case DOT_PROD_EXPR:\n-\t  case SAD_EXPR:\n-          case PLUS_EXPR:\n-          case MINUS_EXPR:\n-          case BIT_IOR_EXPR:\n-          case BIT_XOR_EXPR:\n-             if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (op)))\n-               neutral_op = build_real (TREE_TYPE (op), dconst0);\n-             else\n-               neutral_op = build_int_cst (TREE_TYPE (op), 0);\n-\n-             break;\n-\n-          case MULT_EXPR:\n-             if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (op)))\n-               neutral_op = build_real (TREE_TYPE (op), dconst1);\n-             else\n-               neutral_op = build_int_cst (TREE_TYPE (op), 1);\n-\n-             break;\n-\n-          case BIT_AND_EXPR:\n-            neutral_op = build_int_cst (TREE_TYPE (op), -1);\n-            break;\n-\n-\t  /* For MIN/MAX we don't have an easy neutral operand but\n-\t     the initial values can be used fine here.  Only for\n-\t     a reduction chain we have to force a neutral element.  */\n-\t  case MAX_EXPR:\n-\t  case MIN_EXPR:\n-\t    if (!GROUP_FIRST_ELEMENT (stmt_vinfo))\n-\t      neutral_op = NULL;\n-\t    else\n-\t      {\n-\t\tdef_stmt = SSA_NAME_DEF_STMT (op);\n-\t\tloop = (gimple_bb (stmt))->loop_father;\n-\t\tneutral_op = PHI_ARG_DEF_FROM_EDGE (def_stmt,\n-\t\t\t\t\t\t    loop_preheader_edge (loop));\n-\t      }\n-\t    break;\n-\n-          default:\n-\t    gcc_assert (!GROUP_FIRST_ELEMENT (stmt_vinfo));\n-            neutral_op = NULL;\n-        }\n-    }\n-\n   if (STMT_VINFO_DATA_REF (stmt_vinfo))\n     {\n       is_store = true;\n@@ -3154,25 +3093,6 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n \t\t}\n \t    }\n \n-          if (reduc_index != -1)\n-            {\n-              loop = (gimple_bb (stmt))->loop_father;\n-              def_stmt = SSA_NAME_DEF_STMT (op);\n-\n-              gcc_assert (loop);\n-\n-              /* Get the def before the loop.  In reduction chain we have only\n-                 one initial value.  */\n-              if ((j != (number_of_copies - 1)\n-                   || (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n-                       && i != 0))\n-                  && neutral_op)\n-                op = neutral_op;\n-              else\n-                op = PHI_ARG_DEF_FROM_EDGE (def_stmt,\n-                                            loop_preheader_edge (loop));\n-            }\n-\n           /* Create 'vect_ = {op0,op1,...,opn}'.  */\n           number_of_places_left_in_vector--;\n \t  tree orig_op = op;\n@@ -3340,7 +3260,7 @@ vect_get_slp_vect_defs (slp_tree slp_node, vec<tree> *vec_oprnds)\n \n void\n vect_get_slp_defs (vec<tree> ops, slp_tree slp_node,\n-\t\t   vec<vec<tree> > *vec_oprnds, int reduc_index)\n+\t\t   vec<vec<tree> > *vec_oprnds)\n {\n   gimple *first_stmt;\n   int number_of_vects = 0, i;\n@@ -3421,20 +3341,16 @@ vect_get_slp_defs (vec<tree> ops, slp_tree slp_node,\n \n       /* For reduction defs we call vect_get_constant_vectors (), since we are\n          looking for initial loop invariant values.  */\n-      if (vectorized_defs && reduc_index == -1)\n+      if (vectorized_defs)\n         /* The defs are already vectorized.  */\n \tvect_get_slp_vect_defs (child, &vec_defs);\n       else\n \t/* Build vectors from scalar defs.  */\n \tvect_get_constant_vectors (oprnd, slp_node, &vec_defs, i,\n-\t\t\t\t   number_of_vects, reduc_index);\n+\t\t\t\t   number_of_vects);\n \n       vec_oprnds->quick_push (vec_defs);\n \n-      /* For reductions, we only need initial values.  */\n-      if (reduc_index != -1)\n-        return;\n-\n       first_iteration = false;\n     }\n }"}, {"sha": "e04390ec4b0ef11fa6bd231e95d7addd1f1d7cc6", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/306b0c920fc691999ecd078f4b1efe015923feea/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/306b0c920fc691999ecd078f4b1efe015923feea/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=306b0c920fc691999ecd078f4b1efe015923feea", "patch": "@@ -1558,11 +1558,11 @@ vect_get_vec_defs_for_stmt_copy (enum vect_def_type *dt,\n    REDUC_INDEX is the index of reduction operand in case of reduction,\n    and -1 otherwise.  */\n \n-void\n+static void\n vect_get_vec_defs (tree op0, tree op1, gimple *stmt,\n \t\t   vec<tree> *vec_oprnds0,\n \t\t   vec<tree> *vec_oprnds1,\n-\t\t   slp_tree slp_node, int reduc_index)\n+\t\t   slp_tree slp_node)\n {\n   if (slp_node)\n     {\n@@ -1574,7 +1574,7 @@ vect_get_vec_defs (tree op0, tree op1, gimple *stmt,\n       if (op1)\n         ops.quick_push (op1);\n \n-      vect_get_slp_defs (ops, slp_node, &vec_defs, reduc_index);\n+      vect_get_slp_defs (ops, slp_node, &vec_defs);\n \n       *vec_oprnds0 = vec_defs[0];\n       if (op1)\n@@ -2525,7 +2525,7 @@ vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n     {\n       /* Handle uses.  */\n       if (j == 0)\n-        vect_get_vec_defs (op, NULL, stmt, &vec_oprnds, NULL, slp_node, -1);\n+        vect_get_vec_defs (op, NULL, stmt, &vec_oprnds, NULL, slp_node);\n       else\n         vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds, NULL);\n \n@@ -2860,7 +2860,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n \t      for (i = 0; i < nargs; i++)\n \t\tvargs.quick_push (gimple_call_arg (stmt, i));\n-\t      vect_get_slp_defs (vargs, slp_node, &vec_defs, -1);\n+\t      vect_get_slp_defs (vargs, slp_node, &vec_defs);\n \t      vec_oprnds0 = vec_defs[0];\n \n \t      /* Arguments are ready.  Create the new vector stmt.  */\n@@ -2990,7 +2990,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n \t      for (i = 0; i < nargs; i++)\n \t\tvargs.quick_push (gimple_call_arg (stmt, i));\n-\t      vect_get_slp_defs (vargs, slp_node, &vec_defs, -1);\n+\t      vect_get_slp_defs (vargs, slp_node, &vec_defs);\n \t      vec_oprnds0 = vec_defs[0];\n \n \t      /* Arguments are ready.  Create the new vector stmt.  */\n@@ -4401,8 +4401,7 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n       for (j = 0; j < ncopies; j++)\n \t{\n \t  if (j == 0)\n-\t    vect_get_vec_defs (op0, NULL, stmt, &vec_oprnds0, NULL, slp_node,\n-\t\t\t       -1);\n+\t    vect_get_vec_defs (op0, NULL, stmt, &vec_oprnds0, NULL, slp_node);\n \t  else\n \t    vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds0, NULL);\n \n@@ -4462,11 +4461,11 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\tvec_oprnds1.quick_push (vec_oprnd1);\n \n \t\t      vect_get_vec_defs (op0, NULL_TREE, stmt, &vec_oprnds0, NULL,\n-\t\t\t\t\t slp_node, -1);\n+\t\t\t\t\t slp_node);\n \t\t    }\n \t\t  else\n \t\t    vect_get_vec_defs (op0, op1, stmt, &vec_oprnds0,\n-\t\t\t\t       &vec_oprnds1, slp_node, -1);\n+\t\t\t\t       &vec_oprnds1, slp_node);\n \t\t}\n \t      else\n \t\t{\n@@ -4565,7 +4564,7 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  /* Handle uses.  */\n \t  if (slp_node)\n \t    vect_get_vec_defs (op0, NULL_TREE, stmt, &vec_oprnds0, NULL,\n-\t\t\t       slp_node, -1);\n+\t\t\t       slp_node);\n \t  else\n \t    {\n \t      vec_oprnds0.truncate (0);\n@@ -4748,7 +4747,7 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n     {\n       /* Handle uses.  */\n       if (j == 0)\n-        vect_get_vec_defs (op, NULL, stmt, &vec_oprnds, NULL, slp_node, -1);\n+        vect_get_vec_defs (op, NULL, stmt, &vec_oprnds, NULL, slp_node);\n       else\n         vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds, NULL);\n \n@@ -5155,10 +5154,10 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n              operand 1 should be of a vector type (the usual case).  */\n           if (vec_oprnd1)\n             vect_get_vec_defs (op0, NULL_TREE, stmt, &vec_oprnds0, NULL,\n-                               slp_node, -1);\n+                               slp_node);\n           else\n             vect_get_vec_defs (op0, op1, stmt, &vec_oprnds0, &vec_oprnds1,\n-                               slp_node, -1);\n+                               slp_node);\n         }\n       else\n         vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds0, &vec_oprnds1);\n@@ -5505,13 +5504,13 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n \t{\n \t  if (op_type == binary_op || op_type == ternary_op)\n \t    vect_get_vec_defs (op0, op1, stmt, &vec_oprnds0, &vec_oprnds1,\n-\t\t\t       slp_node, -1);\n+\t\t\t       slp_node);\n \t  else\n \t    vect_get_vec_defs (op0, NULL_TREE, stmt, &vec_oprnds0, NULL,\n-\t\t\t       slp_node, -1);\n+\t\t\t       slp_node);\n \t  if (op_type == ternary_op)\n \t    vect_get_vec_defs (op2, NULL_TREE, stmt, &vec_oprnds2, NULL,\n-\t\t\t       slp_node, -1);\n+\t\t\t       slp_node);\n \t}\n       else\n \t{\n@@ -6076,7 +6075,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t  if (slp)\n \t\t    {\n \t\t      vect_get_vec_defs (op, NULL_TREE, stmt, &vec_oprnds, NULL,\n-\t\t\t\t\t slp_node, -1);\n+\t\t\t\t\t slp_node);\n \t\t      vec_oprnd = vec_oprnds[0];\n \t\t    }\n \t\t  else\n@@ -6223,7 +6222,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n             {\n \t      /* Get vectorized arguments for SLP_NODE.  */\n               vect_get_vec_defs (op, NULL_TREE, stmt, &vec_oprnds,\n-                                 NULL, slp_node, -1);\n+                                 NULL, slp_node);\n \n               vec_oprnd = vec_oprnds[0];\n             }\n@@ -7976,7 +7975,7 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t}\n               ops.safe_push (then_clause);\n               ops.safe_push (else_clause);\n-              vect_get_slp_defs (ops, slp_node, &vec_defs, -1);\n+              vect_get_slp_defs (ops, slp_node, &vec_defs);\n \t      vec_oprnds3 = vec_defs.pop ();\n \t      vec_oprnds2 = vec_defs.pop ();\n \t      if (!masked)\n@@ -8314,7 +8313,7 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n \n \t      ops.safe_push (rhs1);\n \t      ops.safe_push (rhs2);\n-\t      vect_get_slp_defs (ops, slp_node, &vec_defs, -1);\n+\t      vect_get_slp_defs (ops, slp_node, &vec_defs);\n \t      vec_oprnds1 = vec_defs.pop ();\n \t      vec_oprnds0 = vec_defs.pop ();\n \t    }"}, {"sha": "1ab12319d53407436963c00bd3bcd7842e75cfa8", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/306b0c920fc691999ecd078f4b1efe015923feea/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/306b0c920fc691999ecd078f4b1efe015923feea/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=306b0c920fc691999ecd078f4b1efe015923feea", "patch": "@@ -1094,8 +1094,6 @@ extern void vect_get_load_cost (struct data_reference *, int, bool,\n extern void vect_get_store_cost (struct data_reference *, int,\n \t\t\t\t unsigned int *, stmt_vector_for_cost *);\n extern bool vect_supportable_shift (enum tree_code, tree);\n-extern void vect_get_vec_defs (tree, tree, gimple *, vec<tree> *,\n-\t\t\t       vec<tree> *, slp_tree, int);\n extern tree vect_gen_perm_mask_any (tree, const unsigned char *);\n extern tree vect_gen_perm_mask_checked (tree, const unsigned char *);\n extern void optimize_mask_stores (struct loop*);\n@@ -1179,8 +1177,7 @@ extern bool vect_schedule_slp (vec_info *);\n extern bool vect_analyze_slp (vec_info *, unsigned);\n extern bool vect_make_slp_decision (loop_vec_info);\n extern void vect_detect_hybrid_slp (loop_vec_info);\n-extern void vect_get_slp_defs (vec<tree> , slp_tree,\n-\t\t\t       vec<vec<tree> > *, int);\n+extern void vect_get_slp_defs (vec<tree> , slp_tree, vec<vec<tree> > *);\n extern bool vect_slp_bb (basic_block);\n extern gimple *vect_find_last_scalar_stmt_in_slp (slp_tree);\n extern bool is_simple_and_all_uses_invariant (gimple *, loop_vec_info);"}]}