{"sha": "383c27ca199cb51910ad73265b854743b3f9bf79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgzYzI3Y2ExOTljYjUxOTEwYWQ3MzI2NWI4NTQ3NDNiM2Y5YmY3OQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-09-19T23:29:48Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-09-19T23:29:48Z"}, "message": "(MACROPROLOGUE): New macro.\n\n(FUNCTION_{PRO,EPI}LOGUE): Added ability to use IBM supplied function\nprologue macros.\n(FUNCTION_PROLOGUE): Corrected function \"in-line\" prologue alignment\nproblems.\n(ASM_DECLARE_FUNCTION_NAME): Changed alignment to FullWord.\n(ASM_OUTPUT_{SHORT,ASCII}): Reworked.\n\nFrom-SVN: r10380", "tree": {"sha": "d01dbfc7138d1d1f21b298980c2278fa70a64d90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d01dbfc7138d1d1f21b298980c2278fa70a64d90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/383c27ca199cb51910ad73265b854743b3f9bf79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/383c27ca199cb51910ad73265b854743b3f9bf79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/383c27ca199cb51910ad73265b854743b3f9bf79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/383c27ca199cb51910ad73265b854743b3f9bf79/comments", "author": null, "committer": null, "parents": [{"sha": "1fadfc48ed453eaa51a0eddf3894fa2e0855a79f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fadfc48ed453eaa51a0eddf3894fa2e0855a79f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fadfc48ed453eaa51a0eddf3894fa2e0855a79f"}], "stats": {"total": 106, "additions": 76, "deletions": 30}, "files": [{"sha": "c31c348599df2914e19a71153d1e55aad9abeded", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 76, "deletions": 30, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/383c27ca199cb51910ad73265b854743b3f9bf79/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/383c27ca199cb51910ad73265b854743b3f9bf79/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=383c27ca199cb51910ad73265b854743b3f9bf79", "patch": "@@ -1,7 +1,7 @@\n /* Definitions of target machine for GNU compiler.  System/370 version.\n    Copyright (C) 1989, 1993, 1995 Free Software Foundation, Inc.\n    Contributed by Jan Stein (jan@cd.chalmers.se).\n-   Modified for C/370 MVS by Dave Pitts (pitts@mcdata.com)\n+   Modified for C/370 MVS by Dave Pitts (dpitts@nyx.cs.du.edu)\n \n This file is part of GNU CC.\n \n@@ -80,6 +80,13 @@ extern int current_function_outgoing_args_size;\n   { \"no-char-instructions\", -1},\t\t\t\t\t\\\n   { \"\", TARGET_DEFAULT} }\n \n+/* To use IBM supplied macro function prologue and epilogue, define the\n+   following to 1.  Should only be needed if IBM changes the definition\n+   of their prologue and epilogue.  */\n+\n+#define MACROPROLOGUE 0\n+#define MACROEPILOGUE 0\n+\n /* Target machine storage layout */\n \n /* Define this if most significant bit is lowest numbered in instructions\n@@ -479,6 +486,21 @@ enum reg_class\n /* This macro generates the assembly code for function entry.\n    All of the C/370 environment is preserved.  */\n \n+#if MACROPROLOGUE == 1\n+#define FUNCTION_PROLOGUE(FILE, LSIZE)\t\t\t\t\t\\\n+{ \t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tEDCPRLG USRDSAL=%d,BASEREG=%d\\n\",\t\t\t\\\n+\t   STACK_POINTER_OFFSET + LSIZE +\t\t\t\t\\\n+\t   current_function_outgoing_args_size, BASE_REGISTER);\t\t\\\n+  fprintf (FILE, \"PG%d\\tEQU\\t*\\n\", mvs_page_num );\t\t\t\\\n+  fprintf (FILE, \"\\tLR\\t11,1\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tL\\t%d,=A(PGT%d)\\n\", PAGE_REGISTER, mvs_page_num);\t\\\n+  mvs_page_code = 6;\t\t\t\t\t\t\t\\\n+  mvs_page_lit = 4;\t\t\t\t\t\t\t\\\n+  mvs_check_page (FILE, 0, 0);\t\t\t\t\t\t\\\n+  function_base_page = mvs_page_num;\t\t\t\t\t\\\n+}\n+#else /* MACROPROLOGUE != 1 */\n #define FUNCTION_PROLOGUE(FILE, LSIZE)\t\t\t\t\t\\\n { \t\t\t\t\t\t\t\t\t\\\n   static int function_label_index = 1;\t\t\t\t\t\\\n@@ -499,33 +521,39 @@ enum reg_class\n       function_minute = function_time->tm_min;\t\t\t\t\\\n       function_second = function_time->tm_sec;\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"$DSD%03d\\tDSECT\\n\", function_label_index);\t\t\\\n+  fprintf (FILE, \"\\tDS\\tD\\n\");\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDS\\tCL(120+%d)\\n\", STACK_POINTER_OFFSET + LSIZE\t\\\n+\t\t\t+ current_function_outgoing_args_size);\t\t\\\n+  fprintf (FILE, \"\\tORG\\t$DSD%03d\\n\", function_label_index);\t\t\\\n+  fprintf (FILE, \"\\tDS\\tCL(120+8)\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tORG\\n\");\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDS\\t0D\\n\");\t\t\t\t\t\t\\\n+  fprintf (FILE, \"$DSL%03d\\tEQU\\t*-$DSD%03d-8\\n\", function_label_index, \\\n+\t   function_label_index);\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDS\\t0H\\n\");\t\t\t\t\t\t\\\n+  assemble_name (FILE, mvs_function_name);\t\t\t\t\\\n+  fprintf (FILE, \"\\tCSECT\\n\");\t\t\t\t\t\t\\\n   fprintf (FILE, \"\\tUSING\\t*,15\\n\");\t\t\t\t\t\\\n   fprintf (FILE, \"\\tB\\tFPL%03d\\n\", function_label_index);\t\t\\\n   fprintf (FILE, \"\\tDC\\tAL1(FPL%03d+4-*)\\n\", function_label_index + 1);\t\\\n-  fprintf (FILE, \"\\tDC\\tX'CE',X'A0',X'10'\\n\");\t\t\t\t\\\n-  fprintf (FILE, \"\\tDC\\tA($PPA2)\\n\");\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDC\\tF'%d'\\n\", 0);\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDC\\tF'%d'\\n\", STACK_POINTER_OFFSET + LSIZE\t\t\\\n-\t\t\t+ current_function_outgoing_args_size);\t\t\\\n+  fprintf (FILE, \"\\tDC\\tX'CE',X'A0',AL1(16)\\n\");\t\t\t\\\n+  fprintf (FILE, \"\\tDC\\tAL4($PPA%03d)\\n\",function_label_index);\t\t\\\n+  fprintf (FILE, \"\\tDC\\tAL4(0)\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDC\\tAL4($DSL%03d)\\n\", function_label_index);\t\\\n   fprintf (FILE, \"FPL%03d\\tEQU\\t*\\n\", function_label_index + 1);\t\\\n   fprintf (FILE, \"\\tDC\\tAL2(%d),C'%s'\\n\", strlen (mvs_function_name),\t\\\n \tmvs_function_name);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n-  if (!function_first)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"$PPA2\\tEQU\\t*\\n\");\t\t\t\t\\\n-      fprintf (FILE, \"\\tDC\\tX'03',X'00',X'33',X'00'\\n\");\t\t\\\n-      fprintf (FILE, \"\\tDC\\tV(CEESTART),A(0)\\n\");\t\t\t\\\n-      fprintf (FILE, \"\\tDC\\tA($TIMES)\\n\");\t\t\t\t\\\n-      fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\\\n-      fprintf (FILE, \"$TIMES\\tEQU\\t*\\n\");\t\t\t\t\\\n-      fprintf (FILE, \"\\tDC\\tCL4'%d',CL4'%02d%02d',CL6'%02d%02d00'\\n\",\t\\\n-\t\t      function_year, function_month, function_day,\t\\\n-\t\t      function_hour, function_minute, function_second);\t\\\n-      fprintf (FILE, \"\\tDC\\tCL2'01',CL4'0100'\\n\");\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDS\\t0H\\n\");\t\t\t\t\t\t\\\n-  fprintf (FILE, \"FPL%03d\\tEQU\\t*\\n\", function_label_index);\t\t\\\n+  fprintf (FILE, \"$PPA%03d\\tDS\\t0F\\n\", function_label_index);\t\t\\\n+  fprintf (FILE, \"\\tDC\\tX'03',X'00',X'33',X'00'\\n\");\t\t\t\\\n+  fprintf (FILE, \"\\tDC\\tV(CEESTART),A(0)\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"\\tDC\\tA($TIM%03d)\\n\", function_label_index);\t\t\\\n+  fprintf (FILE, \"$TIM%03d\\tDS\\t0F\\n\", function_label_index);\t\t\\\n+  fprintf (FILE, \"\\tDC\\tCL4'%d',CL4'%02d%02d',CL6'%02d%02d00'\\n\",\t\\\n+\t\t function_year, function_month, function_day,\t\t\\\n+\t\t function_hour, function_minute, function_second);\t\\\n+  fprintf (FILE, \"\\tDC\\tCL2'01',CL4'0100'\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"FPL%03d\\tDS\\t0H\\n\", function_label_index);\t\t\\\n   fprintf (FILE, \"\\tSTM\\t14,12,12(13)\\n\");\t\t\t\t\\\n   fprintf (FILE, \"\\tL\\t2,76(,13)\\n\");\t\t\t\t\t\\\n   fprintf (FILE, \"\\tL\\t0,16(,15)\\n\");\t\t\t\t\t\\\n@@ -539,11 +567,11 @@ enum reg_class\n   fprintf (FILE, \"\\tMVI\\t0(2),X'10'\\n\");\t\t\t\t\\\n   fprintf (FILE, \"\\tST\\t13,4(,2)\\n \");\t\t\t\t\t\\\n   fprintf (FILE, \"\\tLR\\t13,2\\n\");\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tLR\\t11,1\\n\");\t\t\t\t\t\\\n   fprintf (FILE, \"\\tDROP\\t15\\n\");\t\t\t\t\t\\\n   fprintf (FILE, \"\\tBALR\\t%d,0\\n\", BASE_REGISTER);\t\t\t\\\n   fprintf (FILE, \"PG%d\\tEQU\\t*\\n\", mvs_page_num );\t\t\t\\\n   fprintf (FILE, \"\\tUSING\\t*,%d\\n\", BASE_REGISTER);\t\t\t\\\n+  fprintf (FILE, \"\\tLR\\t11,1\\n\");\t\t\t\t\t\\\n   fprintf (FILE, \"\\tL\\t%d,=A(PGT%d)\\n\", PAGE_REGISTER, mvs_page_num);\t\\\n   mvs_page_code = 4;\t\t\t\t\t\t\t\\\n   mvs_page_lit = 4;\t\t\t\t\t\t\t\\\n@@ -552,6 +580,7 @@ enum reg_class\n   function_first = 1;\t\t\t\t\t\t\t\\\n   function_label_index += 2;\t\t\t\t\t\t\\\n }\n+#endif /* MACROPROLOGUE */\n \n #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n@@ -575,7 +604,7 @@ enum reg_class\n     strcpy (mvs_function_name, \"gccmain\");\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     strcpy (mvs_function_name, NAME);\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDS\\t0H\\n\");\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n   assemble_name (FILE, mvs_function_name);\t\t\t\t\\\n   fputs (\"\\tCSECT\\n\", FILE);\t\t\t\t\t\t\\\n }\n@@ -590,6 +619,23 @@ enum reg_class\n    of alloca; we also take advantage of it to omit stack adjustments\n    before returning.  */\n \n+#if MACROEPILOGUE == 1\n+#define FUNCTION_EPILOGUE(FILE, LSIZE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\t\t\\\n+  check_label_emit();\t\t\t\t\t\t\t\\\n+  mvs_check_page (FILE,14,0);\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tEDCEPIL\\n\");\t\t\t\t\t\\\n+  mvs_page_num++;\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDS\\t0F\\n\" );\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tLTORG\\n\");\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n+  fprintf (FILE, \"PGT%d\\tEQU\\t*\\n\", function_base_page);\t\t\\\n+  mvs_free_label();\t\t\t\t\t\t\t\\\n+  for ( i = function_base_page; i < mvs_page_num; i++ )\t\t\t\\\n+    fprintf (FILE, \"\\tDC\\tA(PG%d)\\n\", i);\t\t\t\t\\\n+}\n+#else /* MACROEPILOGUE != 1 */\n #define FUNCTION_EPILOGUE(FILE, LSIZE)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   int i;\t\t\t\t\t\t\t\t\\\n@@ -611,6 +657,8 @@ enum reg_class\n   for ( i = function_base_page; i < mvs_page_num; i++ )\t\t\t\\\n     fprintf (FILE, \"\\tDC\\tA(PG%d)\\n\", i);\t\t\t\t\\\n }\n+#endif /* MACROEPILOGUE */\n+\n \n /* Output assembler code for a block containing the constant parts of a\n    trampoline, leaving space for the variable parts.\n@@ -1133,9 +1181,7 @@ enum reg_class\n \n #define ASM_OUTPUT_SHORT(FILE, EXP)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDC\\tH'\");\t\t\t\t\t\t\\\n-  output_addr_const (FILE, EXP);\t\t\t\t\t\\\n-  fprintf (FILE, \"'\\n\");\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDC\\tX'%04X'\\n\", INTVAL(EXP) & 0xFFFF);\t\t\\\n }\n \n /* This outputs a byte sized integer.  */\n@@ -1170,7 +1216,7 @@ enum reg_class\n       else\t\t\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  if (j % MVS_ASCII_TEXT_LENGTH == 0)\t\t\t\t\\\n-            fprintf (FILE, \"\\tDC\\tC'\", c);\t\t\t\t\\\n+            fprintf (FILE, \"\\tDC\\tC'\");\t\t\t\t\t\\\n           if ( c == '\\'' )                                       \t\\\n \t    fprintf (FILE, \"%c%c\", c, c);                        \t\\\n \t  else                                                   \t\\\n@@ -1324,8 +1370,8 @@ enum reg_class\n \t  fprintf (FILE, \"%d\", (INTVAL (X) << 16) >> 16);\t\t\\\n \telse if (CODE == 'H')\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n-\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=F'%d'\", (INTVAL (X) << 16) >> 16);\t\t\\\n+\t    mvs_page_lit += 2;\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"=H'%d'\", (INTVAL (X) << 16) >> 16);\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n \telse\t\t\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\"}]}