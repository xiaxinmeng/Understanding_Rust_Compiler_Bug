{"sha": "d9e7c8e3c35b45d40660abe038d4379eb4f770a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDllN2M4ZTNjMzViNDVkNDA2NjBhYmUwMzhkNDM3OWViNGY3NzBhMw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-12-02T01:43:58Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-12-02T01:43:58Z"}, "message": "re PR rtl-optimization/11634 ([hppa] ICE in verify_local_live_at_start, at flow.c:555)\n\n\n\tPR optimization/11634\n\t* recog.c (split_insn): Factor test of INSN_P and handling of\n\tset_noop_p out of here into the two callers.\n\t(split_all_insns): Add INSN_P test and set_noop_p handling here.\n\tIf deleting a no-op set after reload that has a REG_UNUSED note,\n\tmark the basic block as changed and recalculate life information.\n\t(split_all_insns_noflow): Add INSN_P test and set_noop_p handling\n\there.\n\n\t* gcc.dg/20031201-2.c: New test case.\n\nFrom-SVN: r74145", "tree": {"sha": "a53fd78aee8f68647d8de3b2cf423c36acf60972", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a53fd78aee8f68647d8de3b2cf423c36acf60972"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9e7c8e3c35b45d40660abe038d4379eb4f770a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9e7c8e3c35b45d40660abe038d4379eb4f770a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9e7c8e3c35b45d40660abe038d4379eb4f770a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9e7c8e3c35b45d40660abe038d4379eb4f770a3/comments", "author": null, "committer": null, "parents": [{"sha": "b58b21d521f8ee8dd0f53708d937db75262ae65e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b58b21d521f8ee8dd0f53708d937db75262ae65e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b58b21d521f8ee8dd0f53708d937db75262ae65e"}], "stats": {"total": 207, "additions": 146, "deletions": 61}, "files": [{"sha": "d11d4f0df525e3373233a9f65723d915c5044ed3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e7c8e3c35b45d40660abe038d4379eb4f770a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e7c8e3c35b45d40660abe038d4379eb4f770a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9e7c8e3c35b45d40660abe038d4379eb4f770a3", "patch": "@@ -1,3 +1,14 @@\n+2003-12-01  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR optimization/11634\n+\t* recog.c (split_insn): Factor test of INSN_P and handling of\n+\tset_noop_p out of here into the two callers.\n+\t(split_all_insns): Add INSN_P test and set_noop_p handling here.\n+\tIf deleting a no-op set after reload that has a REG_UNUSED note,\n+\tmark the basic block as changed and recalculate life information.\n+\t(split_all_insns_noflow): Add INSN_P test and set_noop_p handling\n+\there.\n+\n 2003-12-01  Roger Sayle  <roger@eyesopen.com>\n \n \tPR optimization/12322"}, {"sha": "3257fac099db2443ead105c184545072bd6b7c5c", "filename": "gcc/recog.c", "status": "modified", "additions": 89, "deletions": 61, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e7c8e3c35b45d40660abe038d4379eb4f770a3/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e7c8e3c35b45d40660abe038d4379eb4f770a3/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=d9e7c8e3c35b45d40660abe038d4379eb4f770a3", "patch": "@@ -2642,61 +2642,42 @@ reg_fits_class_p (rtx operand, enum reg_class class, int offset,\n   return 0;\n }\n \f\n-/* Split single instruction.  Helper function for split_all_insns.\n-   Return last insn in the sequence if successful, or NULL if unsuccessful.  */\n+/* Split single instruction.  Helper function for split_all_insns and\n+   split_all_insns_noflow.  Return last insn in the sequence if successful,\n+   or NULL if unsuccessful.  */\n+\n static rtx\n split_insn (rtx insn)\n {\n-  rtx set;\n-  if (!INSN_P (insn))\n-    ;\n-  /* Don't split no-op move insns.  These should silently\n-     disappear later in final.  Splitting such insns would\n-     break the code that handles REG_NO_CONFLICT blocks.  */\n+  /* Split insns here to get max fine-grain parallelism.  */\n+  rtx first = PREV_INSN (insn);\n+  rtx last = try_split (PATTERN (insn), insn, 1);\n \n-  else if ((set = single_set (insn)) != NULL && set_noop_p (set))\n-    {\n-      /* Nops get in the way while scheduling, so delete them\n-         now if register allocation has already been done.  It\n-         is too risky to try to do this before register\n-         allocation, and there are unlikely to be very many\n-         nops then anyways.  */\n-      if (reload_completed)\n-\tdelete_insn_and_edges (insn);\n-    }\n-  else\n-    {\n-      /* Split insns here to get max fine-grain parallelism.  */\n-      rtx first = PREV_INSN (insn);\n-      rtx last = try_split (PATTERN (insn), insn, 1);\n+  if (last == insn)\n+    return NULL_RTX;\n+\n+  /* try_split returns the NOTE that INSN became.  */\n+  PUT_CODE (insn, NOTE);\n+  NOTE_SOURCE_FILE (insn) = 0;\n+  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n \n-      if (last != insn)\n+  /* ??? Coddle to md files that generate subregs in post-reload\n+     splitters instead of computing the proper hard register.  */\n+  if (reload_completed && first != last)\n+    {\n+      first = NEXT_INSN (first);\n+      for (;;)\n \t{\n-\t  /* try_split returns the NOTE that INSN became.  */\n-\t  PUT_CODE (insn, NOTE);\n-\t  NOTE_SOURCE_FILE (insn) = 0;\n-\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\n-\t  /* ??? Coddle to md files that generate subregs in post-\n-\t     reload splitters instead of computing the proper\n-\t     hard register.  */\n-\t  if (reload_completed && first != last)\n-\t    {\n-\t      first = NEXT_INSN (first);\n-\t      while (1)\n-\t\t{\n-\t\t  if (INSN_P (first))\n-\t\t    cleanup_subreg_operands (first);\n-\t\t  if (first == last)\n-\t\t    break;\n-\t\t  first = NEXT_INSN (first);\n-\t\t}\n-\t    }\n-\t  return last;\n+\t  if (INSN_P (first))\n+\t    cleanup_subreg_operands (first);\n+\t  if (first == last)\n+\t    break;\n+\t  first = NEXT_INSN (first);\n \t}\n     }\n-  return NULL_RTX;\n+  return last;\n }\n+\n /* Split all insns in the function.  If UPD_LIFE, update life info after.  */\n \n void\n@@ -2717,24 +2698,52 @@ split_all_insns (int upd_life)\n \n       for (insn = bb->head; !finish ; insn = next)\n \t{\n-\t  rtx last;\n-\n \t  /* Can't use `next_real_insn' because that might go across\n \t     CODE_LABELS and short-out basic blocks.  */\n \t  next = NEXT_INSN (insn);\n \t  finish = (insn == bb->end);\n-\t  last = split_insn (insn);\n-\t  if (last)\n+\t  if (INSN_P (insn))\n \t    {\n-\t      /* The split sequence may include barrier, but the\n-\t\t BB boundary we are interested in will be set to previous\n-\t\t one.  */\n-\n-\t      while (GET_CODE (last) == BARRIER)\n-\t\tlast = PREV_INSN (last);\n-\t      SET_BIT (blocks, bb->index);\n-\t      changed = true;\n-\t      insn = last;\n+\t      rtx set = single_set (insn);\n+\n+\t      /* Don't split no-op move insns.  These should silently\n+\t\t disappear later in final.  Splitting such insns would\n+\t\t break the code that handles REG_NO_CONFLICT blocks.  */\n+\t      if (set && set_noop_p (set))\n+\t\t{\n+\t\t  /* Nops get in the way while scheduling, so delete them\n+\t\t     now if register allocation has already been done.  It\n+\t\t     is too risky to try to do this before register\n+\t\t     allocation, and there are unlikely to be very many\n+\t\t     nops then anyways.  */\n+\t\t  if (reload_completed)\n+\t\t    {\n+\t\t      /* If the no-op set has a REG_UNUSED note, we need\n+\t\t\t to update liveness information.  */\n+\t\t      if (find_reg_note (insn, REG_UNUSED, NULL_RTX))\n+\t\t\t{\n+\t\t\t  SET_BIT (blocks, bb->index);\n+\t\t\t  changed = true;\n+\t\t\t}\n+\t\t      /* ??? Is life info affected by deleting edges?  */\n+\t\t      delete_insn_and_edges (insn);\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rtx last = split_insn (insn);\n+\t\t  if (last)\n+\t\t    {\n+\t\t      /* The split sequence may include barrier, but the\n+\t\t\t BB boundary we are interested in will be set to\n+\t\t\t previous one.  */\n+\n+\t\t      while (GET_CODE (last) == BARRIER)\n+\t\t\tlast = PREV_INSN (last);\n+\t\t      SET_BIT (blocks, bb->index);\n+\t\t      changed = true;\n+\t\t    }\n+\t\t}\n \t    }\n \t}\n     }\n@@ -2771,9 +2780,28 @@ split_all_insns_noflow (void)\n   for (insn = get_insns (); insn; insn = next)\n     {\n       next = NEXT_INSN (insn);\n-      split_insn (insn);\n+      if (INSN_P (insn))\n+\t{\n+\t  /* Don't split no-op move insns.  These should silently\n+\t     disappear later in final.  Splitting such insns would\n+\t     break the code that handles REG_NO_CONFLICT blocks.  */\n+\t  rtx set = single_set (insn);\n+\t  if (set && set_noop_p (set))\n+\t    {\n+\t      /* Nops get in the way while scheduling, so delete them\n+\t\t now if register allocation has already been done.  It\n+\t\t is too risky to try to do this before register\n+\t\t allocation, and there are unlikely to be very many\n+\t\t nops then anyways.\n+\n+\t\t ??? Should we use delete_insn when the CFG isn't valid?  */\n+\t      if (reload_completed)\n+\t\tdelete_insn_and_edges (insn);\n+\t    }\n+\t  else\n+\t    split_insn (insn);\n+\t}\n     }\n-  return;\n }\n \f\n #ifdef HAVE_peephole2"}, {"sha": "d9bc74b3eef10982c5174b5d14b56b2b4f1f3714", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e7c8e3c35b45d40660abe038d4379eb4f770a3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e7c8e3c35b45d40660abe038d4379eb4f770a3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d9e7c8e3c35b45d40660abe038d4379eb4f770a3", "patch": "@@ -1,3 +1,8 @@\n+2003-12-01  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR optimization/11634\n+\t* gcc.dg/20031201-2.c: New test case.\n+\n 2003-12-01  Zack Weinberg  <zack@codesourcery.com>\n \n \tPR 11433"}, {"sha": "c32b5ebd2e2f54b69a85bd9d5b8f7af9c312294e", "filename": "gcc/testsuite/gcc.dg/20031201-2.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e7c8e3c35b45d40660abe038d4379eb4f770a3/gcc%2Ftestsuite%2Fgcc.dg%2F20031201-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e7c8e3c35b45d40660abe038d4379eb4f770a3/gcc%2Ftestsuite%2Fgcc.dg%2F20031201-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20031201-2.c?ref=d9e7c8e3c35b45d40660abe038d4379eb4f770a3", "patch": "@@ -0,0 +1,41 @@\n+/* PR optimization/11634 */\n+\n+/* The following code used to ICE in verify_local_live_at_start on\n+   PA when compiled with -O2.  The cause was that split_all_insns was\n+   not updating liveness information when deleting no-op moves that\n+   had REG_UNUSED notes.  */\n+\n+/* { dg-do compile { target hppa*-*-* } } */\n+/* { dg-options \"-O2\" } */\n+\n+void *f(void *s);\n+void H5T_conv_vlen (unsigned long long nelmts, unsigned char *bg_ptr)\n+{\n+  long long seq_len;\n+  unsigned long long bg_seq_len = 0;\n+  unsigned src_base_size, dst_base_size;\n+  void *tmp_buf = 0;\n+  unsigned tmp_buf_size = 0;\n+  unsigned long long elmtno;\n+  for (elmtno = 0; elmtno < nelmts; elmtno++)\n+    {\n+      unsigned char *tmp = bg_ptr;\n+      bg_seq_len = *tmp;\n+      if (bg_seq_len > 0\n+          && tmp_buf_size <\n+          (unsigned) (bg_seq_len *\n+                      (src_base_size > dst_base_size\n+                       ? src_base_size\n+\t\t       : dst_base_size)))\n+\t{\n+\t  tmp_buf_size =\n+\t    (unsigned) (bg_seq_len *\n+\t\t\t(src_base_size > dst_base_size\n+\t\t\t ? src_base_size\n+\t\t\t : dst_base_size));\n+\t}\n+      if (bg_seq_len < seq_len)\n+\tf ((unsigned char *) tmp_buf + dst_base_size * bg_seq_len);\n+    }\n+}\n+"}]}