{"sha": "967900711fa76f74c368bb49c4d78f8485e0cade", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY3OTAwNzExZmE3NmY3NGMzNjhiYjQ5YzRkNzhmODQ4NWUwY2FkZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2000-12-15T16:36:00Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-12-15T16:36:00Z"}, "message": "* init.c (build_new_1): Reorganize.  Now with 100% fewer SAVE_EXPRs!\n\nFrom-SVN: r38292", "tree": {"sha": "87be15c6f6d845e4752baddab8c1fb21ccb8c50c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87be15c6f6d845e4752baddab8c1fb21ccb8c50c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/967900711fa76f74c368bb49c4d78f8485e0cade", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/967900711fa76f74c368bb49c4d78f8485e0cade", "html_url": "https://github.com/Rust-GCC/gccrs/commit/967900711fa76f74c368bb49c4d78f8485e0cade", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/967900711fa76f74c368bb49c4d78f8485e0cade/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8d42565b847d588e6c04e9c3cd5a3157859e2c6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d42565b847d588e6c04e9c3cd5a3157859e2c6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d42565b847d588e6c04e9c3cd5a3157859e2c6a"}], "stats": {"total": 265, "additions": 121, "deletions": 144}, "files": [{"sha": "a59a83513359306f795011a5d8ecba517698ee52", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/967900711fa76f74c368bb49c4d78f8485e0cade/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/967900711fa76f74c368bb49c4d78f8485e0cade/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=967900711fa76f74c368bb49c4d78f8485e0cade", "patch": "@@ -1,5 +1,7 @@\n 2000-12-15  Jason Merrill  <jason@redhat.com>\n \n+\t* init.c (build_new_1): Reorganize.  Now with 100% fewer SAVE_EXPRs!\n+\n \t* init.c (build_new_1): Don't strip quals from type.\n \n \t* decl.c (pushdecl): Don't check for linkage on a non-decl."}, {"sha": "023c83446c7c4f70ccf0b9aac7a0fea89799c629", "filename": "gcc/cp/init.c", "status": "modified", "additions": 119, "deletions": 144, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/967900711fa76f74c368bb49c4d78f8485e0cade/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/967900711fa76f74c368bb49c4d78f8485e0cade/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=967900711fa76f74c368bb49c4d78f8485e0cade", "patch": "@@ -2236,9 +2236,10 @@ build_new_1 (exp)\n      tree exp;\n {\n   tree placement, init;\n-  tree type, true_type, size, rval;\n+  tree type, true_type, size, rval, t;\n   tree nelts = NULL_TREE;\n-  tree alloc_expr, alloc_node = NULL_TREE;\n+  tree alloc_call, alloc_expr, alloc_node;\n+  tree cookie_expr, init_expr;\n   int has_array = 0;\n   enum tree_code code;\n   int use_cookie, nothrow, check_new;\n@@ -2280,11 +2281,9 @@ build_new_1 (exp)\n   if (!complete_type_or_else (true_type, exp))\n     return error_mark_node;\n \n+  size = size_in_bytes (true_type);\n   if (has_array)\n-    size = fold (cp_build_binary_op (MULT_EXPR, size_in_bytes (true_type),\n-\t\t\t\t     nelts));\n-  else\n-    size = size_in_bytes (type);\n+    size = fold (cp_build_binary_op (MULT_EXPR, size, nelts));\n \n   if (TREE_CODE (true_type) == VOID_TYPE)\n     {\n@@ -2299,8 +2298,9 @@ build_new_1 (exp)\n      new.  */\n   if (!globally_qualified_p\n       && IS_AGGR_TYPE (true_type)\n-      && ((!has_array && TYPE_HAS_NEW_OPERATOR (true_type))\n-\t  || (has_array && TYPE_HAS_ARRAY_NEW_OPERATOR (true_type))))\n+      && (has_array\n+\t  ? TYPE_HAS_ARRAY_NEW_OPERATOR (true_type)\n+\t  : TYPE_HAS_NEW_OPERATOR (true_type)))\n     use_global_new = 0;\n   else\n     use_global_new = 1;\n@@ -2330,9 +2330,6 @@ build_new_1 (exp)\n       size = size_binop (PLUS_EXPR, size, cookie_size);\n     }\n \n-  if (has_array && init && pedantic)\n-    cp_pedwarn (\"initialization in array new\");\n-\n   /* Allocate the object.  */\n   \n   if (! placement && TYPE_FOR_JAVA (true_type))\n@@ -2346,11 +2343,10 @@ build_new_1 (exp)\n       if (alloc_decl == NULL_TREE)\n \tfatal(\"call to Java constructor, while `%s' undefined\", alloc_name);\n       class_addr = build1 (ADDR_EXPR, jclass_node, class_decl);\n-      rval = build_function_call (alloc_decl,\n-\t\t\t\t  tree_cons (NULL_TREE, class_addr,\n-\t\t\t\t\t     build_tree_list (NULL_TREE,\n-\t\t\t\t\t\t\t      class_size)));\n-      rval = cp_convert (build_pointer_type (true_type), rval);\n+      alloc_call = (build_function_call\n+\t\t    (alloc_decl,\n+\t\t     tree_cons (NULL_TREE, class_addr,\n+\t\t\t\tbuild_tree_list (NULL_TREE, class_size))));\n     }\n   else\n     {\n@@ -2361,19 +2357,21 @@ build_new_1 (exp)\n       fnname = ansi_opname (code);\n \n       if (use_global_new)\n-\trval = (build_new_function_call \n-\t\t(lookup_function_nonclass (fnname, args),\n-\t\t args));\n+\talloc_call = (build_new_function_call \n+\t\t      (lookup_function_nonclass (fnname, args),\n+\t\t       args));\n       else\n-\trval = build_method_call (build_dummy_object (true_type),\n-\t\t\t\t  fnname, args, NULL_TREE,\n-\t\t\t\t  LOOKUP_NORMAL);\n-      rval = cp_convert (build_pointer_type (true_type), rval);\n+\talloc_call = build_method_call (build_dummy_object (true_type),\n+\t\t\t\t\tfnname, args, NULL_TREE,\n+\t\t\t\t\tLOOKUP_NORMAL);\n     }\n \n-  if (rval == error_mark_node)\n+  if (alloc_call == error_mark_node)\n     return error_mark_node;\n \n+  if (alloc_call == NULL_TREE)\n+    abort ();\n+\n   /*        unless an allocation function is declared with an empty  excep-\n      tion-specification  (_except.spec_),  throw(), it indicates failure to\n      allocate storage by throwing a bad_alloc exception  (clause  _except_,\n@@ -2384,74 +2382,56 @@ build_new_1 (exp)\n \n      So check for a null exception spec on the op new we just called.  */\n \n-  nothrow = 0;\n-  if (rval)\n-    {\n-      /* The CALL_EXPR.  */\n-      tree t = TREE_OPERAND (rval, 0);\n-      /* The function.  */\n-      t = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n-      nothrow = TYPE_NOTHROW_P (TREE_TYPE (t));\n-    }\n+  /* The ADDR_EXPR.  */\n+  t = TREE_OPERAND (alloc_call, 0);\n+  /* The function.  */\n+  t = TREE_OPERAND (t, 0);\n+  nothrow = TYPE_NOTHROW_P (TREE_TYPE (t));\n   check_new = (flag_check_new || nothrow) && ! use_java_new;\n \n-  if ((check_new || flag_exceptions) && rval)\n-    {\n-      alloc_expr = get_target_expr (rval);\n-      alloc_node = rval = TREE_OPERAND (alloc_expr, 0);\n-    }\n-  else\n-    alloc_expr = NULL_TREE;\n+  alloc_expr = alloc_call;\n+\n+  if (use_cookie)\n+    /* Adjust so we're pointing to the start of the object.  */\n+    alloc_expr = build (PLUS_EXPR, TREE_TYPE (alloc_expr),\n+\t\t\talloc_expr, cookie_size);\n+  alloc_expr = convert (build_pointer_type (type), alloc_expr);\n+\n+  /* Now save the allocation expression so we only evaluate it once.  */\n+  alloc_expr = get_target_expr (alloc_expr);\n+  alloc_node = TREE_OPERAND (alloc_expr, 0);\n \n-  /* if rval is NULL_TREE I don't have to allocate it, but are we\n-     totally sure we have some extra bytes in that case for the\n-     cookies? And how does that interact with the code below? (mrs) */\n-  /* Finish up some magic for new'ed arrays */\n-  if (use_cookie && rval != NULL_TREE)\n+  /* Now initialize the cookie.  */\n+  if (use_cookie)\n     {\n-      tree cookie, exp1;\n-      rval = convert (string_type_node, rval); /* for ptr arithmetic */\n-      rval = save_expr (cp_build_binary_op (PLUS_EXPR, rval, cookie_size));\n+      tree cookie;\n+\n       /* Store the number of bytes allocated so that we can know how\n \t many elements to destroy later.  */\n       if (flag_new_abi)\n \t{\n \t  /* Under the new ABI, we use the last sizeof (size_t) bytes\n \t     to store the number of elements.  */\n-\t  cookie = build_indirect_ref (build (MINUS_EXPR,\n-\t\t\t\t\t      build_pointer_type (sizetype),\n-\t\t\t\t\t      rval,\n-\t\t\t\t\t      size_in_bytes (sizetype)),\n-\t\t\t\t       NULL_PTR);\n-\t  exp1 = build (MODIFY_EXPR, void_type_node, cookie, nelts);\n+\t  cookie = build (MINUS_EXPR, build_pointer_type (sizetype),\n+\t\t\t  alloc_node, size_in_bytes (sizetype));\n+\t  cookie = build_indirect_ref (cookie, NULL_PTR);\n \t}\n       else\n \t{\n-\t  cookie \n-\t    = build_indirect_ref (build (MINUS_EXPR,\n-\t\t\t\t\t build_pointer_type (BI_header_type),\n-\t\t\t\t\t rval, cookie_size), NULL_PTR);\n-\t  exp1 = build (MODIFY_EXPR, void_type_node,\n-\t\t\tbuild_component_ref (cookie, nelts_identifier,\n-\t\t\t\t\t     NULL_TREE, 0),\n-\t\t\tnelts);\n+\t  cookie = build (MINUS_EXPR, build_pointer_type (BI_header_type),\n+\t\t\t  alloc_node, cookie_size);\n+\t  cookie = build_indirect_ref (cookie, NULL_PTR);\n+\t  cookie = build_component_ref (cookie, nelts_identifier,\n+\t\t\t\t\tNULL_TREE, 0);\n \t}\n-\n-      /* Build `(cookie = nelts, rval)' and use that as the complete\n-\t expression.  */\n-      rval = cp_convert (build_pointer_type (true_type), rval);\n-      rval = build_compound_expr\n-\t(tree_cons (NULL_TREE, exp1,\n-\t\t    build_tree_list (NULL_TREE, rval)));\n+      cookie_expr = build (MODIFY_EXPR, void_type_node, cookie, nelts);\n+      TREE_SIDE_EFFECTS (cookie_expr) = 1;\n     }\n+  else\n+    cookie_expr = NULL_TREE;\n \n-  if (rval == error_mark_node)\n-    return error_mark_node;\n-\n-  /* Don't call any constructors or do any initialization.  */\n-  if (init == void_type_node)\n-    goto done;\n-\n+  /* Now initialize the allocated object.  */\n+  init_expr = NULL_TREE;\n   if (TYPE_NEEDS_CONSTRUCTING (type) || init)\n     {\n       if (! TYPE_NEEDS_CONSTRUCTING (type)\n@@ -2462,11 +2442,7 @@ build_new_1 (exp)\n \t  tree deref;\n \t  tree deref_type;\n \n-\t  /* At present RVAL is a temporary variable, created to hold\n-\t     the value from the call to `operator new'.  We transform\n-\t     it to (*RVAL = INIT, RVAL).  */\n-\t  rval = save_expr (rval);\n-\t  deref = build_indirect_ref (rval, NULL_PTR);\n+\t  deref = build_indirect_ref (alloc_node, NULL_PTR);\n \n \t  /* Even for something like `new const int (10)' we must\n \t     allow the expression to be non-const while we do the\n@@ -2480,54 +2456,48 @@ build_new_1 (exp)\n \t  TREE_READONLY (deref) = 0;\n \n \t  if (TREE_CHAIN (init) != NULL_TREE)\n-\t    pedwarn (\"initializer list being treated as compound expression\");\n+\t    pedwarn\n+\t      (\"initializer list being treated as compound expression\");\n \t  else if (TREE_CODE (init) == CONSTRUCTOR)\n \t    {\n-\t      pedwarn (\"initializer list appears where operand should be used\");\n+\t      pedwarn\n+\t\t(\"initializer list appears where operand should be used\");\n \t      init = TREE_OPERAND (init, 1);\n \t    }\n \t  init = build_compound_expr (init);\n \n \t  init = convert_for_initialization (deref, type, init, LOOKUP_NORMAL,\n \t\t\t\t\t     \"new\", NULL_TREE, 0);\n-\t  rval = build (COMPOUND_EXPR, TREE_TYPE (rval),\n-\t\t\tbuild_modify_expr (deref, NOP_EXPR, init),\n-\t\t\trval);\n-\t  TREE_NO_UNUSED_WARNING (rval) = 1;\n-\t  TREE_SIDE_EFFECTS (rval) = 1;\n+\t  init_expr = build_modify_expr (deref, NOP_EXPR, init);\n \t}\n       else if (! has_array)\n \t{\n-\t  tree newrval;\n \t  /* Constructors are never virtual. If it has an initialization, we\n \t     need to complain if we aren't allowed to use the ctor that took\n \t     that argument.  */\n \t  int flags = LOOKUP_NORMAL|LOOKUP_NONVIRTUAL|LOOKUP_COMPLAIN;\n \n-\t  rval = save_expr (rval);\n-\t  newrval = rval;\n-\n-\t  if (newrval && TREE_CODE (TREE_TYPE (newrval)) == POINTER_TYPE)\n-\t    newrval = build_indirect_ref (newrval, NULL_PTR);\n-\n-\t  newrval = build_method_call (newrval, \n-\t\t\t\t       complete_ctor_identifier,\n-\t\t\t\t       init, TYPE_BINFO (true_type), flags);\n-\n-\t  if (newrval == NULL_TREE || newrval == error_mark_node)\n-\t    return error_mark_node;\n+\t  init_expr = build_indirect_ref (alloc_node, NULL_PTR);\n \n-\t  newrval = build (COMPOUND_EXPR, TREE_TYPE (rval), newrval, rval);\n-\t  rval = newrval;\n-\t  TREE_HAS_CONSTRUCTOR (rval) = 1;\n+\t  init_expr = build_method_call (init_expr, \n+\t\t\t\t\t complete_ctor_identifier,\n+\t\t\t\t\t init, TYPE_BINFO (true_type), flags);\n \t}\n       else\n-\trval = (build_vec_init\n-\t\t(NULL_TREE, \n-\t\t save_expr (rval),\n-\t\t cp_build_binary_op (MINUS_EXPR, nelts, integer_one_node),\n-\t\t init,\n-\t\t /*from_array=*/0));\n+\t{\n+\t  if (init && pedantic)\n+\t    cp_pedwarn (\"initialization in array new\");\n+\n+\t  init_expr = convert (build_pointer_type (true_type), alloc_node);\n+\t  init_expr = (build_vec_init\n+\t\t       (NULL_TREE, init_expr,\n+\t\t\tcp_build_binary_op (MINUS_EXPR, nelts,\n+\t\t\t\t\t    integer_one_node),\n+\t\t\tinit, /*from_array=*/0));\n+\t}\n+\n+      if (init_expr == error_mark_node)\n+\treturn error_mark_node;\n \n       /* If any part of the object initialization terminates by throwing an\n \t exception and a suitable deallocation function can be found, the\n@@ -2537,10 +2507,10 @@ build_new_1 (exp)\n \t unambiguous matching deallocation function can be found,\n \t propagating the exception does not cause the object's memory to be\n \t freed.  */\n-      if (flag_exceptions && alloc_expr && ! use_java_new)\n+      if (flag_exceptions && ! use_java_new)\n \t{\n \t  enum tree_code dcode = has_array ? VEC_DELETE_EXPR : DELETE_EXPR;\n-\t  tree cleanup, fn = NULL_TREE;\n+\t  tree cleanup;\n \t  int flags = (LOOKUP_NORMAL \n \t\t       | (globally_qualified_p * LOOKUP_GLOBAL));\n \n@@ -2549,21 +2519,31 @@ build_new_1 (exp)\n              functions that we use for finding allocation functions.  */\n \t  flags |= LOOKUP_SPECULATIVELY;\n \n-\t  /* We expect alloc_expr to look like a TARGET_EXPR around\n-\t     a NOP_EXPR around the CALL_EXPR we want.  */\n-\t  fn = TREE_OPERAND (alloc_expr, 1);\n-\t  fn = TREE_OPERAND (fn, 0);\n-\n-\t  cleanup = build_op_delete_call (dcode, alloc_node, size, flags, fn);\n+\t  cleanup = build_op_delete_call (dcode, alloc_node, size, flags,\n+\t\t\t\t\t  alloc_call);\n \n \t  /* Ack!  First we allocate the memory.  Then we set our sentry\n \t     variable to true, and expand a cleanup that deletes the memory\n-\t     if sentry is true.  Then we run the constructor and store the\n-\t     returned pointer in buf.  Then we clear sentry and return buf.  */\n+\t     if sentry is true.  Then we run the constructor, and finally\n+\t     clear the sentry.\n+\n+\t     It would be nice to be able to handle this without the sentry\n+\t     variable, perhaps with a TRY_CATCH_EXPR, but this doesn't\n+\t     work.  We allocate the space first, so if there are any\n+\t     temporaries with cleanups in the constructor args we need this\n+\t     EH region to extend until end of full-expression to preserve\n+\t     nesting.\n+\n+\t     If the backend had some mechanism so that we could force the\n+\t     allocation to be expanded after all the other args to the\n+\t     constructor, that would fix the nesting problem and we could\n+\t     do away with this complexity.  But that would complicate other\n+\t     things; in particular, it would make it difficult to bail out\n+\t     if the allocation function returns null.  */\n \n \t  if (cleanup)\n \t    {\n-\t      tree end, sentry, begin, buf, t = TREE_TYPE (rval);\n+\t      tree end, sentry, begin;\n \n \t      begin = get_target_expr (boolean_true_node);\n \t      sentry = TREE_OPERAND (begin, 0);\n@@ -2572,46 +2552,41 @@ build_new_1 (exp)\n \t\t= build (COND_EXPR, void_type_node, sentry,\n \t\t\t cleanup, void_zero_node);\n \n-\t      rval = get_target_expr (rval);\n-\n \t      end = build (MODIFY_EXPR, TREE_TYPE (sentry),\n \t\t\t   sentry, boolean_false_node);\n \n-\t      buf = TREE_OPERAND (rval, 0);\n-\n-\t      rval = build (COMPOUND_EXPR, t, begin,\n-\t\t\t    build (COMPOUND_EXPR, t, rval,\n-\t\t\t\t   build (COMPOUND_EXPR, t, end, buf)));\n+\t      init_expr\n+\t\t= build (COMPOUND_EXPR, void_type_node, begin,\n+\t\t\t build (COMPOUND_EXPR, void_type_node, init_expr,\n+\t\t\t\tend));\n \t    }\n \t}\n     }\n   else if (CP_TYPE_CONST_P (true_type))\n     cp_error (\"uninitialized const in `new' of `%#T'\", true_type);\n \n- done:\n+  /* Now build up the return value in reverse order.  */\n \n-  if (alloc_expr && rval == alloc_node)\n-    {\n-      rval = TREE_OPERAND (alloc_expr, 1);\n-      alloc_expr = NULL_TREE;\n-    }\n+  rval = alloc_node;\n+\n+  if (init_expr)\n+    rval = build (COMPOUND_EXPR, TREE_TYPE (rval), init_expr, rval);\n+  if (cookie_expr)\n+    rval = build (COMPOUND_EXPR, TREE_TYPE (rval), cookie_expr, rval);\n \n-  if (check_new && alloc_expr)\n+  if (rval == alloc_node)\n+    /* If we didn't modify anything, strip the TARGET_EXPR and return the\n+       (adjusted) call.  */\n+    return TREE_OPERAND (alloc_expr, 1);\n+\n+  if (check_new)\n     {\n-      /* Did we modify the storage?  */\n       tree ifexp = cp_build_binary_op (NE_EXPR, alloc_node,\n \t\t\t\t       integer_zero_node);\n       rval = build_conditional_expr (ifexp, rval, alloc_node);\n     }\n \n-  if (alloc_expr)\n-    rval = build (COMPOUND_EXPR, TREE_TYPE (rval), alloc_expr, rval);\n-\n-  if (rval && TREE_TYPE (rval) != build_pointer_type (type))\n-    {\n-      /* The type of new int [3][3] is not int *, but int [3] * */\n-      rval = build_c_cast (build_pointer_type (type), rval);\n-    }\n+  rval = build (COMPOUND_EXPR, TREE_TYPE (rval), alloc_expr, rval);\n \n   return rval;\n }"}]}