{"sha": "9fda11a2ecf9047b64bbe2e92343f1e263ce1509", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZkYTExYTJlY2Y5MDQ3YjY0YmJlMmU5MjM0M2YxZTI2M2NlMTUwOQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2009-11-30T17:59:57Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2009-11-30T17:59:57Z"}, "message": "re PR middle-end/42196 (ICE when SRAing partial assigments to complex number)\n\n2009-11-30  Martin Jambor  <mjambor@suse.cz>\n\n\tPR middle-end/42196\n\t* tree-sra.c (struct access): New field grp_different_types.\n\t(dump_access): Dump grp_different_types.\n\t(compare_access_positions): Prefer scalars and vectors over other\n\tscalar types.\n\t(sort_and_splice_var_accesses): Set grp_different_types if appropriate.\n\t(sra_modify_expr): Use the original also when dealing with a complex\n\t or vector group accessed as multiple types.\n\n\t* testsuite/gcc.c-torture/compile/pr42196-1.c: New test.\n\t* testsuite/gcc.c-torture/compile/pr42196-2.c: New test.\n\t* testsuite/gcc.c-torture/compile/pr42196-3.c: New test.\n\nFrom-SVN: r154834", "tree": {"sha": "ab1827bc63ebf292fe7e7a3a659302538d0eb39f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab1827bc63ebf292fe7e7a3a659302538d0eb39f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fda11a2ecf9047b64bbe2e92343f1e263ce1509", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fda11a2ecf9047b64bbe2e92343f1e263ce1509", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fda11a2ecf9047b64bbe2e92343f1e263ce1509", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fda11a2ecf9047b64bbe2e92343f1e263ce1509/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ca659f6ed947ad43caf21917dca2aced344dc35b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca659f6ed947ad43caf21917dca2aced344dc35b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca659f6ed947ad43caf21917dca2aced344dc35b"}], "stats": {"total": 140, "additions": 134, "deletions": 6}, "files": [{"sha": "d5fb07532b007fa9d1ad11925056513f46472a92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fda11a2ecf9047b64bbe2e92343f1e263ce1509/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fda11a2ecf9047b64bbe2e92343f1e263ce1509/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9fda11a2ecf9047b64bbe2e92343f1e263ce1509", "patch": "@@ -1,3 +1,14 @@\n+2009-11-30  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR middle-end/42196\n+\t* tree-sra.c (struct access): New field grp_different_types.\n+\t(dump_access): Dump grp_different_types.\n+\t(compare_access_positions): Prefer scalars and vectors over other\n+\tscalar types.\n+\t(sort_and_splice_var_accesses): Set grp_different_types if appropriate.\n+\t(sra_modify_expr): Use the original also when dealing with a complex\n+\t or vector group accessed as multiple types.\n+\n 2009-11-30  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.c (avx_vperm2f128_parallel): New."}, {"sha": "4cef144e9c67bcabba2f0f4abc291de7bdf2462f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fda11a2ecf9047b64bbe2e92343f1e263ce1509/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fda11a2ecf9047b64bbe2e92343f1e263ce1509/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9fda11a2ecf9047b64bbe2e92343f1e263ce1509", "patch": "@@ -1,3 +1,10 @@\n+2009-11-30  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR middle-end/42196\n+\t* gcc.c-torture/compile/pr42196-1.c: New test.\n+\t* gcc.c-torture/compile/pr42196-2.c: New test.\n+\t* gcc.c-torture/compile/pr42196-3.c: New test.\n+\n 2009-11-30  Ira Rosen  <irar@il.ibm.com>\n \n \t* gfortran.dg/vect/vect-7.f90: New test."}, {"sha": "96936c5e5889743643e6a72894406bfaac310b37", "filename": "gcc/testsuite/gcc.c-torture/compile/pr42196-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fda11a2ecf9047b64bbe2e92343f1e263ce1509/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr42196-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fda11a2ecf9047b64bbe2e92343f1e263ce1509/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr42196-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr42196-1.c?ref=9fda11a2ecf9047b64bbe2e92343f1e263ce1509", "patch": "@@ -0,0 +1,28 @@\n+union U\n+{\n+  double d;\n+  __complex__ int c;\n+};\n+\n+double gd;\n+extern double bar (union U);\n+\n+double foo (int b, double d, int c1, int c2)\n+{\n+  union U u;\n+  double r;\n+\n+  if (b)\n+    {\n+      u.d = d;\n+      r = u.d;\n+    }\n+  else\n+    {\n+      __real__ u.c = c1;\n+      __imag__ u.c = c2;\n+      r = bar (u);\n+    }\n+\n+  return r;\n+}"}, {"sha": "40ae077f6b970e2212392e4fd5b63937e628daaf", "filename": "gcc/testsuite/gcc.c-torture/compile/pr42196-2.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fda11a2ecf9047b64bbe2e92343f1e263ce1509/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr42196-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fda11a2ecf9047b64bbe2e92343f1e263ce1509/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr42196-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr42196-2.c?ref=9fda11a2ecf9047b64bbe2e92343f1e263ce1509", "patch": "@@ -0,0 +1,28 @@\n+union U\n+{\n+  __complex__ int ci;\n+  __complex__ float cf;\n+};\n+\n+float gd;\n+extern float bar (union U);\n+\n+float foo (int b, double f1, double f2, int c1, int c2)\n+{\n+  union U u;\n+  double r;\n+\n+  if (b)\n+    {\n+      __real__ u.cf = f1;\n+      __imag__ u.cf = f2;\n+    }\n+  else\n+    {\n+      __real__ u.ci = c1;\n+      __imag__ u.ci = c2;\n+    }\n+\n+  r = bar (u);\n+  return r;\n+}"}, {"sha": "ccc0d7a195cf6f3b8678d51dee6567fc40c0e425", "filename": "gcc/testsuite/gcc.c-torture/compile/pr42196-3.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fda11a2ecf9047b64bbe2e92343f1e263ce1509/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr42196-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fda11a2ecf9047b64bbe2e92343f1e263ce1509/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr42196-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr42196-3.c?ref=9fda11a2ecf9047b64bbe2e92343f1e263ce1509", "patch": "@@ -0,0 +1,27 @@\n+union U\n+{\n+  __complex__ int ci;\n+  __complex__ float cf;\n+};\n+\n+float gd;\n+extern float bar (float, float);\n+\n+float foo (int b, union U u)\n+{\n+  float f1, f2, r;\n+\n+  if (b)\n+    {\n+      f1 = __real__ u.cf;\n+      f1 = __imag__ u.cf;\n+    }\n+  else\n+    {\n+      f1 = __real__ u.ci;\n+      f1 = __imag__ u.ci;\n+    }\n+\n+  r = bar (f1, f2);\n+  return r;\n+}"}, {"sha": "2c75838835a0d99bab8e0cf9b2d78109486910cf", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fda11a2ecf9047b64bbe2e92343f1e263ce1509/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fda11a2ecf9047b64bbe2e92343f1e263ce1509/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=9fda11a2ecf9047b64bbe2e92343f1e263ce1509", "patch": "@@ -199,6 +199,10 @@ struct access\n      BIT_FIELD_REF?  */\n   unsigned grp_partial_lhs : 1;\n \n+  /* Does this group contain accesses to different types? (I.e. through a union\n+     or a similar mechanism).  */\n+  unsigned grp_different_types : 1;\n+\n   /* Set when a scalar replacement should be created for this variable.  We do\n      the decision and creation at different places because create_tmp_var\n      cannot be called from within FOR_EACH_REFERENCED_VAR. */\n@@ -339,12 +343,14 @@ dump_access (FILE *f, struct access *access, bool grp)\n     fprintf (f, \", grp_write = %d, grp_read = %d, grp_hint = %d, \"\n \t     \"grp_covered = %d, grp_unscalarizable_region = %d, \"\n \t     \"grp_unscalarized_data = %d, grp_partial_lhs = %d, \"\n-\t     \"grp_to_be_replaced = %d\\n grp_maybe_modified = %d, \"\n+\t     \"grp_different_types = %d, grp_to_be_replaced = %d, \"\n+\t     \"grp_maybe_modified = %d, \"\n \t     \"grp_not_necessarilly_dereferenced = %d\\n\",\n \t     access->grp_write, access->grp_read, access->grp_hint,\n \t     access->grp_covered, access->grp_unscalarizable_region,\n \t     access->grp_unscalarized_data, access->grp_partial_lhs,\n-\t     access->grp_to_be_replaced, access->grp_maybe_modified,\n+\t     access->grp_different_types, access->grp_to_be_replaced,\n+\t     access->grp_maybe_modified,\n \t     access->grp_not_necessarilly_dereferenced);\n   else\n     fprintf (f, \", write = %d, grp_partial_lhs = %d\\n\", access->write,\n@@ -1112,14 +1118,25 @@ compare_access_positions (const void *a, const void *b)\n     {\n       /* Put any non-aggregate type before any aggregate type.  */\n       if (!is_gimple_reg_type (f1->type)\n-\t       && is_gimple_reg_type (f2->type))\n+\t  && is_gimple_reg_type (f2->type))\n \treturn 1;\n       else if (is_gimple_reg_type (f1->type)\n \t       && !is_gimple_reg_type (f2->type))\n \treturn -1;\n+      /* Put any complex or vector type before any other scalar type.  */\n+      else if (TREE_CODE (f1->type) != COMPLEX_TYPE\n+\t       && TREE_CODE (f1->type) != VECTOR_TYPE\n+\t       && (TREE_CODE (f2->type) == COMPLEX_TYPE\n+\t\t   || TREE_CODE (f2->type) == VECTOR_TYPE))\n+\treturn 1;\n+      else if ((TREE_CODE (f1->type) == COMPLEX_TYPE\n+\t\t|| TREE_CODE (f1->type) == VECTOR_TYPE)\n+\t       && TREE_CODE (f2->type) != COMPLEX_TYPE\n+\t       && TREE_CODE (f2->type) != VECTOR_TYPE)\n+\treturn -1;\n       /* Put the integral type with the bigger precision first.  */\n       else if (INTEGRAL_TYPE_P (f1->type)\n-\t  && INTEGRAL_TYPE_P (f2->type))\n+\t       && INTEGRAL_TYPE_P (f2->type))\n \treturn TYPE_PRECISION (f1->type) > TYPE_PRECISION (f2->type) ? -1 : 1;\n       /* Put any integral type with non-full precision last.  */\n       else if (INTEGRAL_TYPE_P (f1->type)\n@@ -1417,6 +1434,7 @@ sort_and_splice_var_accesses (tree var)\n       bool grp_read = !access->write;\n       bool multiple_reads = false;\n       bool grp_partial_lhs = access->grp_partial_lhs;\n+      bool grp_different_types = false;\n       bool first_scalar = is_gimple_reg_type (access->type);\n       bool unscalarizable_region = access->grp_unscalarizable_region;\n \n@@ -1448,6 +1466,7 @@ sort_and_splice_var_accesses (tree var)\n \t\tgrp_read = true;\n \t    }\n \t  grp_partial_lhs |= ac2->grp_partial_lhs;\n+\t  grp_different_types |= !types_compatible_p (access->type, ac2->type);\n \t  unscalarizable_region |= ac2->grp_unscalarizable_region;\n \t  relink_to_new_repr (access, ac2);\n \n@@ -1466,6 +1485,7 @@ sort_and_splice_var_accesses (tree var)\n       access->grp_read = grp_read;\n       access->grp_hint = multiple_reads;\n       access->grp_partial_lhs = grp_partial_lhs;\n+      access->grp_different_types = grp_different_types;\n       access->grp_unscalarizable_region = unscalarizable_region;\n       if (access->first_link)\n \tadd_access_to_work_queue (access);\n@@ -2112,8 +2132,15 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write,\n          access expression to extract the scalar component afterwards.\n \t This happens if scalarizing a function return value or parameter\n \t like in gcc.c-torture/execute/20041124-1.c, 20050316-1.c and\n-\t gcc.c-torture/compile/20011217-1.c.  */\n-      if (!is_gimple_reg_type (type))\n+\t gcc.c-torture/compile/20011217-1.c.\n+\n+         We also want to use this when accessing a complex or vector which can\n+         be accessed as a different type too, potentially creating a need for\n+         type conversion  (see PR42196).  */\n+      if (!is_gimple_reg_type (type)\n+\t  || (access->grp_different_types\n+\t      && (TREE_CODE (type) == COMPLEX_TYPE\n+\t\t  || TREE_CODE (type) == VECTOR_TYPE)))\n \t{\n \t  tree ref = access->base;\n \t  bool ok;"}]}