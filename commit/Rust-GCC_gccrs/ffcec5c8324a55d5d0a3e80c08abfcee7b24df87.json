{"sha": "ffcec5c8324a55d5d0a3e80c08abfcee7b24df87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZjZWM1YzgzMjRhNTVkNWQwYTNlODBjMDhhYmZjZWU3YjI0ZGY4Nw==", "commit": {"author": {"name": "Jerry Quinn", "email": "jlquinn@gcc.gnu.org", "date": "2004-01-27T02:58:06Z"}, "committer": {"name": "Jerry Quinn", "email": "jlquinn@gcc.gnu.org", "date": "2004-01-27T02:58:06Z"}, "message": "codecvt.h, [...]: Document.\n\n2003-01-26  Jerry Quinn  <jlquinn@optonline.net>\n\n\t* include/bits/codecvt.h, include/bits/locale_facets.h,\n\tinclude/bits/postypes.h, include/bits/stl_bvector.h,\n\tinclude/bits/stl_multiset.h, include/bits/stl_set.h,\n\tinclude/bits/stream_iterator.h, include/bits/streambuf_iterator.h,\n\tinclude/std/std_complex.h:  Document.\n\nFrom-SVN: r76688", "tree": {"sha": "61adcc97ba250f0bd758384665e91ed34c131377", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61adcc97ba250f0bd758384665e91ed34c131377"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/comments", "author": null, "committer": null, "parents": [{"sha": "1c62e7b282ae85cf578a3af015941e717422f116", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c62e7b282ae85cf578a3af015941e717422f116", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c62e7b282ae85cf578a3af015941e717422f116"}], "stats": {"total": 1544, "additions": 1190, "deletions": 354}, "files": [{"sha": "33d2b95e35ec68ce1aacb17abb254d085dae5b65", "filename": "libstdc++-v3/include/bits/codecvt.h", "status": "modified", "additions": 117, "deletions": 1, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h?ref=ffcec5c8324a55d5d0a3e80c08abfcee7b24df87", "patch": "@@ -1,6 +1,6 @@\n // Locale support (codecvt) -*- C++ -*-\n \n-// Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -44,6 +44,7 @@\n #pragma GCC system_header\n \n   //  22.2.1.5  Template class codecvt\n+  /// Base class for codecvt facet providing conversion result enum.\n   class codecvt_base\n   {\n   public:\n@@ -60,6 +61,15 @@\n   // NB: An abstract base class that fills in the public inlines, so\n   // that the specializations don't have to re-copy the public\n   // interface.\n+  /**\n+   *  @brief  Common base for codecvt facet\n+   *\n+   *  This template class provides implementations of the public functions\n+   *  that forward to the protected virtual functions.\n+   *\n+   *  This template also provides abstract stubs for the protected virtual\n+   *  functions.\n+  */\n   template<typename _InternT, typename _ExternT, typename _StateT>\n     class __codecvt_abstract_base \n     : public locale::facet, public codecvt_base\n@@ -72,6 +82,41 @@\n       typedef _StateT  \t\t\tstate_type;\n       \n       // 22.2.1.5.1 codecvt members\n+      /**\n+       *  @brief  Convert from internal to external character set.\n+       *\n+       *  Converts input string of intern_type to output string of\n+       *  extern_type.  This is analogous to wcsrtombs.  It does this by\n+       *  calling codecvt::do_out.\n+       *\n+       *  The source and destination character sets are determined by the\n+       *  facet's locale, internal and external types.\n+       *\n+       *  The characters in [from,from_end) are converted and written to\n+       *  [to,to_end).  from_next and to_next are set to point to the\n+       *  character following the last successfully converted character,\n+       *  respectively.  If the result needed no conversion, from_next and\n+       *  to_next are not affected.\n+       *\n+       *  The @a state argument should be intialized if the input is at the\n+       *  beginning and carried from a previous call if continuing\n+       *  conversion.  There are no guarantees about how @a state is used.\n+       *\n+       *  The result returned is a member of codecvt_base::result.  If all the\n+       *  input is converted, returns codecvt_base::ok.  If no conversion is\n+       *  necessary, returns codecvt_base::noconv.  If the input ends early or\n+       *  there is insufficient space in the output, returns codecvt_base::partial.\n+       *  Otherwise the conversion failed and codecvt_base::error is returned.\n+       *\n+       *  @param  state  Persistent conversion state data.\n+       *  @param  from  Start of input.\n+       *  @param  from_end  End of input.\n+       *  @param  from_next  Returns start of unconverted data.\n+       *  @param  to  Start of output buffer.\n+       *  @param  to_end  End of output buffer.\n+       *  @param  to_next  Returns start of unused output area.\n+       *  @return  codecvt_base::result.\n+      */\n       result\n       out(state_type& __state, const intern_type* __from, \n \t  const intern_type* __from_end, const intern_type*& __from_next,\n@@ -82,11 +127,75 @@\n \t\t\t    __to, __to_end, __to_next); \n       }\n \n+      /**\n+       *  @brief  Reset conversion state.\n+       *\n+       *  Writes characters to output that would restore @a state to initial\n+       *  conditions.  The idea is that if a partial conversion occurs, then\n+       *  the converting the characters written by this function would leave\n+       *  the state in initial conditions, rather than partial conversion\n+       *  state.  It does this by calling codecvt::do_unshift().\n+       *\n+       *  For example, if 4 external characters always converted to 1 internal\n+       *  character, and input to in() had 6 external characters with state\n+       *  saved, this function would write two characters to the output and\n+       *  set the state to initialized conditions.\n+       *\n+       *  The source and destination character sets are determined by the\n+       *  facet's locale, internal and external types.\n+       *\n+       *  The result returned is a member of codecvt_base::result.  If the\n+       *  state could be reset and data written, returns codecvt_base::ok.  If\n+       *  no conversion is necessary, returns codecvt_base::noconv.  If the\n+       *  output has insufficient space, returns codecvt_base::partial.\n+       *  Otherwise the reset failed and codecvt_base::error is returned.\n+       *\n+       *  @param  state  Persistent conversion state data.\n+       *  @param  to  Start of output buffer.\n+       *  @param  to_end  End of output buffer.\n+       *  @param  to_next  Returns start of unused output area.\n+       *  @return  codecvt_base::result.\n+      */\n       result\n       unshift(state_type& __state, extern_type* __to, extern_type* __to_end,\n \t      extern_type*& __to_next) const\n       { return this->do_unshift(__state, __to,__to_end,__to_next); }\n \n+      /**\n+       *  @brief  Convert from external to internal character set.\n+       *\n+       *  Converts input string of extern_type to output string of\n+       *  intern_type.  This is analogous to mbsrtowcs.  It does this by\n+       *  calling codecvt::do_in.\n+       *\n+       *  The source and destination character sets are determined by the\n+       *  facet's locale, internal and external types.\n+       *\n+       *  The characters in [from,from_end) are converted and written to\n+       *  [to,to_end).  from_next and to_next are set to point to the\n+       *  character following the last successfully converted character,\n+       *  respectively.  If the result needed no conversion, from_next and\n+       *  to_next are not affected.\n+       *\n+       *  The @a state argument should be intialized if the input is at the\n+       *  beginning and carried from a previous call if continuing\n+       *  conversion.  There are no guarantees about how @a state is used.\n+       *\n+       *  The result returned is a member of codecvt_base::result.  If all the\n+       *  input is converted, returns codecvt_base::ok.  If no conversion is\n+       *  necessary, returns codecvt_base::noconv.  If the input ends early or\n+       *  there is insufficient space in the output, returns codecvt_base::partial.\n+       *  Otherwise the conversion failed and codecvt_base::error is returned.\n+       *\n+       *  @param  state  Persistent conversion state data.\n+       *  @param  from  Start of input.\n+       *  @param  from_end  End of input.\n+       *  @param  from_next  Returns start of unconverted data.\n+       *  @param  to  Start of output buffer.\n+       *  @param  to_end  End of output buffer.\n+       *  @param  to_next  Returns start of unused output area.\n+       *  @return  codecvt_base::result.\n+      */\n       result\n       in(state_type& __state, const extern_type* __from, \n \t const extern_type* __from_end, const extern_type*& __from_next,\n@@ -121,6 +230,13 @@\n       virtual \n       ~__codecvt_abstract_base() { }\n \n+      /**\n+       *  @brief  Convert from internal to external character set.\n+       *\n+       *  Converts input string of intern_type to output string of\n+       *  extern_type.  This function is a hook for derived classes to change\n+       *  the value returned.  @see out for more information.\n+      */\n       virtual result\n       do_out(state_type& __state, const intern_type* __from, \n \t     const intern_type* __from_end, const intern_type*& __from_next,"}, {"sha": "3b1315d3f27e301d5aa884fd9112c508385ff34f", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=ffcec5c8324a55d5d0a3e80c08abfcee7b24df87", "patch": "@@ -4462,6 +4462,8 @@ namespace std\n   // NB: These are inline because, when used in a loop, some compilers\n   // can hoist the body out of the loop; then it's just as fast as the\n   // C is*() function.\n+  //@{\n+  /// Convenience interface to ctype.is().\n   template<typename _CharT>\n     inline bool \n     isspace(_CharT __c, const locale& __loc)\n@@ -4525,6 +4527,7 @@ namespace std\n     inline _CharT \n     tolower(_CharT __c, const locale& __loc)\n     { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }\n+  //@}\n } // namespace std\n \n #endif"}, {"sha": "cd0594c45c226738654cb1e3f513029eb93901da", "filename": "libstdc++-v3/include/bits/postypes.h", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpostypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpostypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpostypes.h?ref=ffcec5c8324a55d5d0a3e80c08abfcee7b24df87", "patch": "@@ -1,6 +1,6 @@\n // Position types -*- C++ -*-\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003 \n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003, 2004\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -64,6 +64,7 @@ namespace std\n   typedef long long     __streamoff_base_type;\n #endif\n \n+  /// Integral type for I/O operation counts and buffer sizes.\n   typedef ptrdiff_t\tstreamsize; // Signed integral type\n \n   template<typename _StateT>\n@@ -127,19 +128,30 @@ namespace std\n     }\n   };\n \n-  // In clauses 21.1.3.1 and 27.4.1 streamoff is described as an\n-  // implementation defined type. In this implementation it is a\n-  // distinct class type.\n-  // Note: In versions of GCC up to and including GCC 3.3, streamoff\n-  // was typedef long.\n+  /**\n+   *  @brief  Type used by fpos, char_traits<char>, and char_traits<wchar_t>.\n+   *\n+   *  @if maint\n+   *  In clauses 21.1.3.1 and 27.4.1 streamoff is described as an\n+   *  implementation defined type. In this implementation it is a\n+   *  distinct class type.\n+   *  Note: In versions of GCC up to and including GCC 3.3, streamoff\n+   *  was typedef long.\n+   *  @endif\n+  */\n   typedef class streamoff streamoff;\n \n-  // The standard fails to place any requiremens on the template\n-  // argument StateT. In this implementation StateT must be\n-  // DefaultConstructible, CopyConstructible and Assignable.  The\n-  // standard only requires that fpos should contain a member of type\n-  // StateT. In this implementation it also contains an offset stored\n-  // as a signed integer.\n+  /**\n+   *  @brief  Class representing stream positions.\n+   *\n+   *  The standard places no requirements upon the template parameter StateT.\n+   *  In this implementation StateT must be DefaultConstructible,\n+   *  CopyConstructible and Assignable.  The standard only requires that fpos\n+   *  should contain a member of type StateT. In this implementation it also\n+   *  contains an offset stored as a signed integer.\n+   *\n+   *  @param  StateT  Type passed to and returned from state().\n+   */\n   template<typename _StateT>\n     class fpos\n     {\n@@ -161,6 +173,7 @@ namespace std\n       // fpos, but gives no meaningful semantics for this\n       // conversion. In this implementation this constructor stores\n       // the integer as the offset and default constructs the state.\n+      /// Construct position from integer.\n       fpos(__streamoff_base_type __off)\n       : _M_off(__off), _M_state() { }\n \n@@ -170,13 +183,16 @@ namespace std\n       // implementation implicit conversion is also allowed, and this\n       // constructor stores the streamoff as the offset and default\n       // constructs the state.\n+      /// Construct position from offset.\n       fpos(const streamoff& __off)\n       : _M_off(__off), _M_state() { }\n \n+      /// Remember the value of @a st.\n       void\n       state(_StateT __st)\n       { _M_state = __st; }\n \n+      /// Return the last set value of @a st.\n       _StateT\n       state() const\n       { return _M_state; }\n@@ -185,17 +201,20 @@ namespace std\n       // equivalence relation. In this implementation two fpos<StateT>\n       // objects belong to the same equivalence class if the contained\n       // offsets compare equal.\n+      /// Test if equivalent to another position.\n       bool\n       operator==(const fpos& __other) const\n       { return _M_off == __other._M_off; }\n \n+      /// Test if not equivalent to another position.\n       bool\n       operator!=(const fpos& __other) const\n       { return _M_off != __other._M_off; }\n \n       // The standard requires that this operator must be defined, but\n       // gives no semantics. In this implemenation it just adds it's\n       // argument to the stored offset and returns *this.\n+      /// Add offset to this position.\n       fpos&\n       operator+=(const streamoff& __off)\n       {\n@@ -206,6 +225,7 @@ namespace std\n       // The standard requires that this operator must be defined, but\n       // gives no semantics. In this implemenation it just subtracts\n       // it's argument from the stored offset and returns *this.\n+      /// Subtract offset from this position.\n       fpos&\n       operator-=(const streamoff& __off)\n       {\n@@ -218,6 +238,7 @@ namespace std\n       // implementation it constructs a copy of *this, adds the\n       // argument to that copy using operator+= and then returns the\n       // copy.\n+      /// Add position and offset.\n       fpos\n       operator+(const streamoff& __off) const\n       {\n@@ -231,6 +252,7 @@ namespace std\n       // implementation it constructs a copy of *this, subtracts the\n       // argument from that copy using operator-= and then returns the\n       // copy.\n+      /// Subtract offset from position.\n       fpos\n       operator-(const streamoff& __off) const\n       {\n@@ -243,11 +265,13 @@ namespace std\n       // defines it's semantics only in terms of operator+. In this\n       // implementation it returns the difference between the offset\n       // stored in *this and in the argument.\n+      /// Subtract position to return offset.\n       streamoff\n       operator-(const fpos& __other) const\n       { return _M_off - __other._M_off; }\n     };\n \n+  /// Construct offset from position.\n   template<typename _StateT>\n     inline\n     streamoff::streamoff(const fpos<_StateT>& __pos)\n@@ -256,7 +280,9 @@ namespace std\n   // Clauses 21.1.3.1 and 21.1.3.2 describe streampos and wstreampos\n   // as implementation defined types, but clause 27.2 requires that\n   // they must both be typedefs for fpos<mbstate_t>\n+  /// File position for char streams.\n   typedef fpos<mbstate_t> streampos;\n+  /// File position for wchar_t streams.\n   typedef fpos<mbstate_t> wstreampos;\n } // namespace std\n "}, {"sha": "34b1a87ad5d3d8a97e209597456a3b229eea75f6", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=ffcec5c8324a55d5d0a3e80c08abfcee7b24df87", "patch": "@@ -1,6 +1,6 @@\n // bit_vector and vector<bool> specialization -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -296,6 +296,24 @@ class _Bvector_base\n #include <bits/stl_vector.h>\n namespace __gnu_norm\n {\n+\n+  /**\n+   *  @brief  A specialization of vector for booleans which offers fixed time\n+   *  access to individual elements in any order.\n+   *\n+   *  Note that vector<bool> does not actually meet the requirements for being\n+   *  a container.  This is because the reference and pointer types are not\n+   *  really references and pointers to bool.  See DR96 for details.  @see\n+   *  vector for function documentation.\n+   *\n+   *  @ingroup Containers\n+   *  @ingroup Sequences\n+   *\n+   *  In some terminology a %vector can be described as a dynamic C-style array,\n+   *  it offers fast and efficient access to individual elements in any order\n+   *  and saves the user from worrying about memory and size allocation.\n+   *  Subscripting ( @c [] ) access is also provided as with C-style arrays.\n+  */\n template <typename _Alloc> \n   class vector<bool, _Alloc> : public _Bvector_base<_Alloc> \n   {"}, {"sha": "2cd26d072e837f30a6d504d878fdfd42ea51b07e", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 444, "deletions": 174, "changes": 618, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=ffcec5c8324a55d5d0a3e80c08abfcee7b24df87", "patch": "@@ -1,6 +1,6 @@\n // Multiset implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -80,181 +80,451 @@ template <class _Key, class _Compare, class _Alloc>\n inline bool operator<(const multiset<_Key,_Compare,_Alloc>& __x, \n                       const multiset<_Key,_Compare,_Alloc>& __y);\n \n-template <class _Key, class _Compare, class _Alloc>\n-class multiset\n-{\n-  // concept requirements\n-  __glibcxx_class_requires(_Key, _SGIAssignableConcept)\n-  __glibcxx_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept)\n-\n-public:\n-\n-  // typedefs:\n-\n-  typedef _Key     key_type;\n-  typedef _Key     value_type;\n-  typedef _Compare key_compare;\n-  typedef _Compare value_compare;\n-private:\n-  typedef _Rb_tree<key_type, value_type, \n-                  _Identity<value_type>, key_compare, _Alloc> _Rep_type;\n-  _Rep_type _M_t;  // red-black tree representing multiset\n-public:\n-  typedef typename _Alloc::pointer pointer;\n-  typedef typename _Alloc::const_pointer const_pointer;\n-  typedef typename _Alloc::reference reference;\n-  typedef typename _Alloc::const_reference const_reference;\n-  typedef typename _Rep_type::const_iterator iterator;\n-  typedef typename _Rep_type::const_iterator const_iterator;\n-  typedef typename _Rep_type::const_reverse_iterator reverse_iterator;\n-  typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n-  typedef typename _Rep_type::size_type size_type;\n-  typedef typename _Rep_type::difference_type difference_type;\n-  typedef typename _Rep_type::allocator_type allocator_type;\n-\n-  // allocation/deallocation\n-\n-  multiset() : _M_t(_Compare(), allocator_type()) {}\n-  explicit multiset(const _Compare& __comp,\n-                    const allocator_type& __a = allocator_type())\n-    : _M_t(__comp, __a) {}\n-\n-  template <class _InputIterator>\n-  multiset(_InputIterator __first, _InputIterator __last)\n-    : _M_t(_Compare(), allocator_type())\n+  /**\n+   *  @brief A standard container made up of elements, which can be retrieved\n+   *  in logarithmic time.\n+   *\n+   *  @ingroup Containers\n+   *  @ingroup Assoc_containers\n+   *\n+   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n+   *  <a href=\"tables.html#66\">reversible container</a>, and an\n+   *  <a href=\"tables.html#69\">associative container</a> (using equivalent\n+   *  keys).  For a @c multiset<Key> the key_type and value_type are Key.\n+   *\n+   *  Multisets support bidirectional iterators.\n+   *\n+   *  @if maint\n+   *  The private tree data is declared exactly the same way for set and\n+   *  multiset; the distinction is made entirely in how the tree functions are\n+   *  called (*_unique versus *_equal, same as the standard).\n+   *  @endif\n+  */\n+  template <class _Key, class _Compare, class _Alloc>\n+  class multiset\n+  {\n+    // concept requirements\n+    __glibcxx_class_requires(_Key, _SGIAssignableConcept)\n+    __glibcxx_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept)\n+\n+  public:\n+    \n+    // typedefs:\n+    \n+    typedef _Key     key_type;\n+    typedef _Key     value_type;\n+    typedef _Compare key_compare;\n+    typedef _Compare value_compare;\n+\n+  private:\n+    /// @if maint  This turns a red-black tree into a [multi]set.  @endif\n+    typedef _Rb_tree<key_type, value_type, \n+\t\t     _Identity<value_type>, key_compare, _Alloc> _Rep_type;\n+    /// @if maint  The actual tree structure.  @endif\n+    _Rep_type _M_t;\n+\n+  public:\n+    typedef typename _Alloc::pointer pointer;\n+    typedef typename _Alloc::const_pointer const_pointer;\n+    typedef typename _Alloc::reference reference;\n+    typedef typename _Alloc::const_reference const_reference;\n+    typedef typename _Rep_type::const_iterator iterator;\n+    typedef typename _Rep_type::const_iterator const_iterator;\n+    typedef typename _Rep_type::const_reverse_iterator reverse_iterator;\n+    typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n+    typedef typename _Rep_type::size_type size_type;\n+    typedef typename _Rep_type::difference_type difference_type;\n+    typedef typename _Rep_type::allocator_type allocator_type;\n+\n+    // allocation/deallocation\n+\n+    /**\n+     *  @brief  Default constructor creates no elements.\n+    */\n+    multiset() : _M_t(_Compare(), allocator_type()) {}\n+    explicit multiset(const _Compare& __comp,\n+\t\t      const allocator_type& __a = allocator_type())\n+      : _M_t(__comp, __a) {}\n+\n+    /**\n+     *  @brief  Builds a %multiset from a range.\n+     *  @param  first  An input iterator.\n+     *  @param  last  An input iterator.\n+     *\n+     *  Create a %multiset consisting of copies of the elements from\n+     *  [first,last).  This is linear in N if the range is already sorted,\n+     *  and NlogN otherwise (where N is distance(first,last)).\n+    */\n+    template <class _InputIterator>\n+    multiset(_InputIterator __first, _InputIterator __last)\n+      : _M_t(_Compare(), allocator_type())\n     { _M_t.insert_equal(__first, __last); }\n \n-  template <class _InputIterator>\n-  multiset(_InputIterator __first, _InputIterator __last,\n-           const _Compare& __comp,\n-           const allocator_type& __a = allocator_type())\n-    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }\n-\n-  multiset(const multiset<_Key,_Compare,_Alloc>& __x) : _M_t(__x._M_t) {}\n-\n-  multiset<_Key,_Compare,_Alloc>&\n-  operator=(const multiset<_Key,_Compare,_Alloc>& __x) {\n-    _M_t = __x._M_t; \n-    return *this;\n-  }\n-\n-  // accessors:\n-\n-  key_compare key_comp() const { return _M_t.key_comp(); }\n-  value_compare value_comp() const { return _M_t.key_comp(); }\n-  allocator_type get_allocator() const { return _M_t.get_allocator(); }\n-\n-  iterator begin() const { return _M_t.begin(); }\n-  iterator end() const { return _M_t.end(); }\n-  reverse_iterator rbegin() const { return _M_t.rbegin(); } \n-  reverse_iterator rend() const { return _M_t.rend(); }\n-  bool empty() const { return _M_t.empty(); }\n-  size_type size() const { return _M_t.size(); }\n-  size_type max_size() const { return _M_t.max_size(); }\n-  void swap(multiset<_Key,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }\n-\n-  // insert/erase\n-  iterator insert(const value_type& __x) { \n-    return _M_t.insert_equal(__x);\n-  }\n-  iterator insert(iterator __position, const value_type& __x) {\n-    typedef typename _Rep_type::iterator _Rep_iterator;\n-    return _M_t.insert_equal((_Rep_iterator&)__position, __x);\n-  }\n-\n-  template <class _InputIterator>\n-  void insert(_InputIterator __first, _InputIterator __last) {\n-    _M_t.insert_equal(__first, __last);\n-  }\n-  void erase(iterator __position) { \n-    typedef typename _Rep_type::iterator _Rep_iterator;\n-    _M_t.erase((_Rep_iterator&)__position); \n-  }\n-  size_type erase(const key_type& __x) { \n-    return _M_t.erase(__x); \n-  }\n-  void erase(iterator __first, iterator __last) { \n-    typedef typename _Rep_type::iterator _Rep_iterator;\n-    _M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last); \n-  }\n-  void clear() { _M_t.clear(); }\n-\n-  // multiset operations:\n-\n-  size_type count(const key_type& __x) const { return _M_t.count(__x); }\n-\n-  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-  // 214.  set::find() missing const overload\n-  iterator find(const key_type& __x) { return _M_t.find(__x); }\n-  const_iterator find(const key_type& __x) const { return _M_t.find(__x); }\n-  iterator lower_bound(const key_type& __x) {\n-    return _M_t.lower_bound(__x);\n-  }\n-  const_iterator lower_bound(const key_type& __x) const {\n-    return _M_t.lower_bound(__x);\n-  }\n-  iterator upper_bound(const key_type& __x) {\n-    return _M_t.upper_bound(__x);\n-  }\n-  const_iterator upper_bound(const key_type& __x) const {\n-    return _M_t.upper_bound(__x);\n-  }\n-  pair<iterator,iterator> equal_range(const key_type& __x) {\n-    return _M_t.equal_range(__x);\n-  }\n-  pair<const_iterator,const_iterator> equal_range(const key_type& __x) const {\n-    return _M_t.equal_range(__x);\n-  }\n-\n-  template <class _K1, class _C1, class _A1>\n-  friend bool operator== (const multiset<_K1,_C1,_A1>&,\n-                          const multiset<_K1,_C1,_A1>&);\n-  template <class _K1, class _C1, class _A1>\n-  friend bool operator< (const multiset<_K1,_C1,_A1>&,\n-                         const multiset<_K1,_C1,_A1>&);\n-};\n-\n-template <class _Key, class _Compare, class _Alloc>\n-inline bool operator==(const multiset<_Key,_Compare,_Alloc>& __x, \n-                       const multiset<_Key,_Compare,_Alloc>& __y) {\n-  return __x._M_t == __y._M_t;\n-}\n-\n-template <class _Key, class _Compare, class _Alloc>\n-inline bool operator<(const multiset<_Key,_Compare,_Alloc>& __x, \n-                      const multiset<_Key,_Compare,_Alloc>& __y) {\n-  return __x._M_t < __y._M_t;\n-}\n-\n-template <class _Key, class _Compare, class _Alloc>\n-inline bool operator!=(const multiset<_Key,_Compare,_Alloc>& __x, \n-                       const multiset<_Key,_Compare,_Alloc>& __y) {\n-  return !(__x == __y);\n-}\n-\n-template <class _Key, class _Compare, class _Alloc>\n-inline bool operator>(const multiset<_Key,_Compare,_Alloc>& __x, \n-                      const multiset<_Key,_Compare,_Alloc>& __y) {\n-  return __y < __x;\n-}\n-\n-template <class _Key, class _Compare, class _Alloc>\n-inline bool operator<=(const multiset<_Key,_Compare,_Alloc>& __x, \n-                       const multiset<_Key,_Compare,_Alloc>& __y) {\n-  return !(__y < __x);\n-}\n-\n-template <class _Key, class _Compare, class _Alloc>\n-inline bool operator>=(const multiset<_Key,_Compare,_Alloc>& __x, \n-                       const multiset<_Key,_Compare,_Alloc>& __y) {\n-  return !(__x < __y);\n-}\n-\n-template <class _Key, class _Compare, class _Alloc>\n-inline void swap(multiset<_Key,_Compare,_Alloc>& __x, \n-                 multiset<_Key,_Compare,_Alloc>& __y) {\n-  __x.swap(__y);\n-}\n+    /**\n+     *  @brief  Builds a %multiset from a range.\n+     *  @param  first  An input iterator.\n+     *  @param  last  An input iterator.\n+     *  @param  comp  A comparison functor.\n+     *  @param  a  An allocator object.\n+     *\n+     *  Create a %multiset consisting of copies of the elements from\n+     *  [first,last).  This is linear in N if the range is already sorted,\n+     *  and NlogN otherwise (where N is distance(first,last)).\n+    */\n+    template <class _InputIterator>\n+    multiset(_InputIterator __first, _InputIterator __last,\n+\t     const _Compare& __comp,\n+\t     const allocator_type& __a = allocator_type())\n+      : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }\n+\n+    /**\n+     *  @brief  %Multiset copy constructor.\n+     *  @param  x  A %multiset of identical element and allocator types.\n+     *\n+     *  The newly-created %multiset uses a copy of the allocation object used\n+     *  by @a x.\n+    */\n+    multiset(const multiset<_Key,_Compare,_Alloc>& __x) : _M_t(__x._M_t) {}\n+\n+    /**\n+     *  @brief  %Multiset assignment operator.\n+     *  @param  x  A %multiset of identical element and allocator types.\n+     *\n+     *  All the elements of @a x are copied, but unlike the copy constructor,\n+     *  the allocator object is not copied.\n+    */\n+    multiset<_Key,_Compare,_Alloc>&\n+    operator=(const multiset<_Key,_Compare,_Alloc>& __x) {\n+      _M_t = __x._M_t; \n+      return *this;\n+    }\n+\n+    // accessors:\n+\n+    ///  Returns the comparison object.\n+    key_compare key_comp() const { return _M_t.key_comp(); }\n+    ///  Returns the comparison object.\n+    value_compare value_comp() const { return _M_t.key_comp(); }\n+    ///  Returns the memory allocation object.\n+    allocator_type get_allocator() const { return _M_t.get_allocator(); }\n+\n+    /**\n+     *  Returns a read/write iterator that points to the first element in the\n+     *  %multiset.  Iteration is done in ascending order according to the\n+     *  keys.\n+     */\n+    iterator begin() const { return _M_t.begin(); }\n+\n+    /**\n+     *  Returns a read/write iterator that points one past the last element in\n+     *  the %multiset.  Iteration is done in ascending order according to the\n+     *  keys.\n+     */\n+    iterator end() const { return _M_t.end(); }\n+\n+    /**\n+     *  Returns a read/write reverse iterator that points to the last element\n+     *  in the %multiset.  Iteration is done in descending order according to\n+     *  the keys.\n+     */\n+    reverse_iterator rbegin() const { return _M_t.rbegin(); } \n+    \n+    /**\n+     *  Returns a read/write reverse iterator that points to the last element\n+     *  in the %multiset.  Iteration is done in descending order according to\n+     *  the keys.\n+     */\n+    reverse_iterator rend() const { return _M_t.rend(); }\n+\n+    ///  Returns true if the %set is empty.\n+    bool empty() const { return _M_t.empty(); }\n+\n+    ///  Returns the size of the %set.\n+    size_type size() const { return _M_t.size(); }\n+\n+    ///  Returns the maximum size of the %set.\n+    size_type max_size() const { return _M_t.max_size(); }\n+\n+    /**\n+     *  @brief  Swaps data with another %multiset.\n+     *  @param  x  A %multiset of the same element and allocator types.\n+     *\n+     *  This exchanges the elements between two multisets in constant time.\n+     *  (It is only swapping a pointer, an integer, and an instance of the @c\n+     *  Compare type (which itself is often stateless and empty), so it should\n+     *  be quite fast.)\n+     *  Note that the global std::swap() function is specialized such that\n+     *  std::swap(s1,s2) will feed to this function.\n+     */\n+    void swap(multiset<_Key,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }\n+\n+    // insert/erase\n+    /**\n+     *  @brief Inserts an element into the %multiset.\n+     *  @param  x  Element to be inserted.\n+     *  @return An iterator that points to the inserted element.\n+     *\n+     *  This function inserts an element into the %multiset.  Contrary\n+     *  to a std::set the %multiset does not rely on unique keys and thus\n+     *  multiple copies of the same element can be inserted.\n+     *\n+     *  Insertion requires logarithmic time.\n+    */\n+    iterator insert(const value_type& __x) { \n+      return _M_t.insert_equal(__x);\n+    }\n+\n+    /**\n+     *  @brief Inserts an element into the %multiset.\n+     *  @param  position  An iterator that serves as a hint as to where the\n+     *                    element should be inserted.\n+     *  @param  x  Element to be inserted.\n+     *  @return An iterator that points to the inserted element.\n+     *\n+     *  This function inserts an element into the %multiset.  Contrary\n+     *  to a std::set the %multiset does not rely on unique keys and thus\n+     *  multiple copies of the same element can be inserted.\n+     *\n+     *  Note that the first parameter is only a hint and can potentially\n+     *  improve the performance of the insertion process.  A bad hint would\n+     *  cause no gains in efficiency.\n+     *\n+     *  See http://gcc.gnu.org/onlinedocs/libstdc++/23_containers/howto.html#4\n+     *  for more on \"hinting\".\n+     *\n+     *  Insertion requires logarithmic time (if the hint is not taken).\n+    */\n+    iterator insert(iterator __position, const value_type& __x) {\n+      typedef typename _Rep_type::iterator _Rep_iterator;\n+      return _M_t.insert_equal((_Rep_iterator&)__position, __x);\n+    }\n+\n+    /**\n+     *  @brief A template function that attemps to insert a range of elements.\n+     *  @param  first  Iterator pointing to the start of the range to be\n+     *                 inserted.\n+     *  @param  last  Iterator pointing to the end of the range.\n+     *\n+     *  Complexity similar to that of the range constructor.\n+    */\n+    template <class _InputIterator>\n+    void insert(_InputIterator __first, _InputIterator __last) {\n+      _M_t.insert_equal(__first, __last);\n+    }\n+\n+    /**\n+     *  @brief Erases an element from a %multiset.\n+     *  @param  position  An iterator pointing to the element to be erased.\n+     *\n+     *  This function erases an element, pointed to by the given iterator,\n+     *  from a %multiset.  Note that this function only erases the element,\n+     *  and that if the element is itself a pointer, the pointed-to memory is\n+     *  not touched in any way.  Managing the pointer is the user's\n+     *  responsibilty.\n+    */\n+    void erase(iterator __position) { \n+      typedef typename _Rep_type::iterator _Rep_iterator;\n+      _M_t.erase((_Rep_iterator&)__position); \n+    }\n+\n+    /**\n+     *  @brief Erases elements according to the provided key.\n+     *  @param  x  Key of element to be erased.\n+     *  @return  The number of elements erased.\n+     *\n+     *  This function erases all elements located by the given key from a\n+     *  %multiset.\n+     *  Note that this function only erases the element, and that if\n+     *  the element is itself a pointer, the pointed-to memory is not touched\n+     *  in any way.  Managing the pointer is the user's responsibilty.\n+    */\n+    size_type erase(const key_type& __x) { \n+      return _M_t.erase(__x); \n+    }\n+\n+    /**\n+     *  @brief Erases a [first,last) range of elements from a %multiset.\n+     *  @param  first  Iterator pointing to the start of the range to be erased.\n+     *  @param  last  Iterator pointing to the end of the range to be erased.\n+     *\n+     *  This function erases a sequence of elements from a %multiset.\n+     *  Note that this function only erases the elements, and that if\n+     *  the elements themselves are pointers, the pointed-to memory is not\n+     *  touched in any way.  Managing the pointer is the user's responsibilty.\n+    */\n+    void erase(iterator __first, iterator __last) { \n+      typedef typename _Rep_type::iterator _Rep_iterator;\n+      _M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last); \n+    }\n+\n+    /**\n+     *  Erases all elements in a %multiset.  Note that this function only\n+     *  erases the elements, and that if the elements themselves are pointers,\n+     *  the pointed-to memory is not touched in any way.  Managing the pointer\n+     *  is the user's responsibilty.\n+    */\n+    void clear() { _M_t.clear(); }\n+\n+    // multiset operations:\n+\n+    /**\n+     *  @brief Finds the number of elements with given key.\n+     *  @param  x  Key of elements to be located.\n+     *  @return Number of elements with specified key.\n+    */\n+    size_type count(const key_type& __x) const { return _M_t.count(__x); }\n+\n+    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+    // 214.  set::find() missing const overload\n+    //@{\n+    /**\n+     *  @brief Tries to locate an element in a %set.\n+     *  @param  x  Element to be located.\n+     *  @return  Iterator pointing to sought-after element, or end() if not\n+     *           found.\n+     *\n+     *  This function takes a key and tries to locate the element with which\n+     *  the key matches.  If successful the function returns an iterator\n+     *  pointing to the sought after element.  If unsuccessful it returns the\n+     *  past-the-end ( @c end() ) iterator.\n+     */\n+    iterator find(const key_type& __x) { return _M_t.find(__x); }\n+    const_iterator find(const key_type& __x) const { return _M_t.find(__x); }\n+    //@}\n+\n+    //@{\n+    /**\n+     *  @brief Finds the beginning of a subsequence matching given key.\n+     *  @param  x  Key to be located.\n+     *  @return  Iterator pointing to first element equal to or greater\n+     *           than key, or end().\n+     *\n+     *  This function returns the first element of a subsequence of elements\n+     *  that matches the given key.  If unsuccessful it returns an iterator\n+     *  pointing to the first element that has a greater value than given key\n+     *  or end() if no such element exists.\n+     */\n+    iterator lower_bound(const key_type& __x) {\n+      return _M_t.lower_bound(__x);\n+    }\n+    const_iterator lower_bound(const key_type& __x) const {\n+      return _M_t.lower_bound(__x);\n+    }\n+    //@}\n+\n+    //@{\n+    /**\n+     *  @brief Finds the end of a subsequence matching given key.\n+     *  @param  x  Key to be located.\n+     *  @return Iterator pointing to the first element\n+     *          greater than key, or end().\n+     */\n+    iterator upper_bound(const key_type& __x) {\n+      return _M_t.upper_bound(__x);\n+    }\n+    const_iterator upper_bound(const key_type& __x) const {\n+      return _M_t.upper_bound(__x);\n+    }\n+    //@}\n+\n+    //@{\n+    /**\n+     *  @brief Finds a subsequence matching given key.\n+     *  @param  x  Key to be located.\n+     *  @return  Pair of iterators that possibly points to the subsequence\n+     *           matching given key.\n+     *\n+     *  This function is equivalent to\n+     *  @code\n+     *    std::make_pair(c.lower_bound(val),\n+     *                   c.upper_bound(val))\n+     *  @endcode\n+     *  (but is faster than making the calls separately).\n+     *\n+     *  This function probably only makes sense for multisets.\n+     */\n+    pair<iterator,iterator> equal_range(const key_type& __x) {\n+      return _M_t.equal_range(__x);\n+    }\n+    pair<const_iterator,const_iterator> equal_range(const key_type& __x) const {\n+      return _M_t.equal_range(__x);\n+    }\n+\n+    template <class _K1, class _C1, class _A1>\n+    friend bool operator== (const multiset<_K1,_C1,_A1>&,\n+\t\t\t    const multiset<_K1,_C1,_A1>&);\n+    template <class _K1, class _C1, class _A1>\n+    friend bool operator< (const multiset<_K1,_C1,_A1>&,\n+\t\t\t   const multiset<_K1,_C1,_A1>&);\n+  };\n+\n+  /**\n+   *  @brief  Multiset equality comparison.\n+   *  @param  x  A %multiset.\n+   *  @param  y  A %multiset of the same type as @a x.\n+   *  @return  True iff the size and elements of the multisets are equal.\n+   *\n+   *  This is an equivalence relation.  It is linear in the size of the multisets.\n+   *  Multisets are considered equivalent if their sizes are equal, and if\n+   *  corresponding elements compare equal.\n+  */\n+  template <class _Key, class _Compare, class _Alloc>\n+    inline bool\n+    operator==(const multiset<_Key,_Compare,_Alloc>& __x, \n+\t       const multiset<_Key,_Compare,_Alloc>& __y)\n+  { return __x._M_t == __y._M_t; }\n+\n+  /**\n+   *  @brief  Multiset ordering relation.\n+   *  @param  x  A %multiset.\n+   *  @param  y  A %multiset of the same type as @a x.\n+   *  @return  True iff @a x is lexicographically less than @a y.\n+   *\n+   *  This is a total ordering relation.  It is linear in the size of the\n+   *  maps.  The elements must be comparable with @c <.\n+   *\n+   *  See std::lexicographical_compare() for how the determination is made.\n+  */\n+  template <class _Key, class _Compare, class _Alloc>\n+    inline bool\n+    operator<(const multiset<_Key,_Compare,_Alloc>& __x, \n+\t      const multiset<_Key,_Compare,_Alloc>& __y)\n+  { return __x._M_t < __y._M_t; }\n+\n+  ///  Returns !(x == y).\n+  template <class _Key, class _Compare, class _Alloc>\n+    inline bool\n+    operator!=(const multiset<_Key,_Compare,_Alloc>& __x, \n+\t       const multiset<_Key,_Compare,_Alloc>& __y)\n+  { return !(__x == __y); }\n+\n+  ///  Returns y < x.\n+  template <class _Key, class _Compare, class _Alloc>\n+    inline bool\n+    operator>(const multiset<_Key,_Compare,_Alloc>& __x, \n+\t      const multiset<_Key,_Compare,_Alloc>& __y)\n+  { return __y < __x; }\n+\n+  ///  Returns !(y < x)\n+  template <class _Key, class _Compare, class _Alloc>\n+    inline bool\n+    operator<=(const multiset<_Key,_Compare,_Alloc>& __x, \n+\t       const multiset<_Key,_Compare,_Alloc>& __y)\n+  { return !(__y < __x); }\n+\n+  ///  Returns !(x < y)\n+  template <class _Key, class _Compare, class _Alloc>\n+    inline bool\n+    operator>=(const multiset<_Key,_Compare,_Alloc>& __x, \n+\t       const multiset<_Key,_Compare,_Alloc>& __y)\n+  { return !(__x < __y); }\n+\n+  /// See std::multiset::swap().\n+  template <class _Key, class _Compare, class _Alloc>\n+    inline void\n+    swap(multiset<_Key,_Compare,_Alloc>& __x, \n+\t multiset<_Key,_Compare,_Alloc>& __y)\n+  { __x.swap(__y); }\n \n } // namespace __gnu_norm\n "}, {"sha": "a3f5472df7c5951d003438288ba2378b2d7f317b", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 438, "deletions": 159, "changes": 597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=ffcec5c8324a55d5d0a3e80c08abfcee7b24df87", "patch": "@@ -1,6 +1,6 @@\n // Set implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -80,6 +80,29 @@ namespace __gnu_norm\n     operator<(const set<_Key,_Compare,_Alloc>& __x, \n \t      const set<_Key,_Compare,_Alloc>& __y);\n \n+  /**\n+   *  @brief A standard container made up of unique keys, which can be\n+   *  retrieved in logarithmic time.\n+   *\n+   *  @ingroup Containers\n+   *  @ingroup Assoc_containers\n+   *\n+   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n+   *  <a href=\"tables.html#66\">reversible container</a>, and an\n+   *  <a href=\"tables.html#69\">associative container</a> (using unique keys).\n+   *\n+   *  Sets support bidirectional iterators.\n+   *\n+   *  @param  Key  Type of key objects.\n+   *  @param  Compare  Comparison function object type, defaults to less<Key>.\n+   *  @param  Alloc  Allocator type, defaults to allocator<Key>.\n+   *\n+   *  @if maint\n+   *  The private tree data is declared exactly the same way for set and\n+   *  multiset; the distinction is made entirely in how the tree functions are\n+   *  called (*_unique versus *_equal, same as the standard).\n+   *  @endif\n+  */\n   template<class _Key, class _Compare, class _Alloc>\n     class set\n     {\n@@ -89,168 +112,424 @@ namespace __gnu_norm\n \t\n \tpublic:\n       // typedefs:\n+      //@{\n+      /// Public typedefs.\n       typedef _Key     key_type;\n       typedef _Key     value_type;\n       typedef _Compare key_compare;\n       typedef _Compare value_compare;\n-private:\n-  typedef _Rb_tree<key_type, value_type, \n-                  _Identity<value_type>, key_compare, _Alloc> _Rep_type;\n-  _Rep_type _M_t;  // red-black tree representing set\n-public:\n-  typedef typename _Alloc::pointer pointer;\n-  typedef typename _Alloc::const_pointer const_pointer;\n-  typedef typename _Alloc::reference reference;\n-  typedef typename _Alloc::const_reference const_reference;\n-  typedef typename _Rep_type::const_iterator iterator;\n-  typedef typename _Rep_type::const_iterator const_iterator;\n-  typedef typename _Rep_type::const_reverse_iterator reverse_iterator;\n-  typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n-  typedef typename _Rep_type::size_type size_type;\n-  typedef typename _Rep_type::difference_type difference_type;\n-  typedef typename _Rep_type::allocator_type allocator_type;\n-\n-  // allocation/deallocation\n-\n-  set() : _M_t(_Compare(), allocator_type()) {}\n-  explicit set(const _Compare& __comp,\n-               const allocator_type& __a = allocator_type())\n-    : _M_t(__comp, __a) {}\n-\n-  template<class _InputIterator>\n-  set(_InputIterator __first, _InputIterator __last)\n-    : _M_t(_Compare(), allocator_type())\n-    { _M_t.insert_unique(__first, __last); }\n-\n-  template<class _InputIterator>\n-  set(_InputIterator __first, _InputIterator __last, const _Compare& __comp,\n-      const allocator_type& __a = allocator_type())\n-    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }\n-\n-  set(const set<_Key,_Compare,_Alloc>& __x) : _M_t(__x._M_t) {}\n-  set<_Key,_Compare,_Alloc>& operator=(const set<_Key, _Compare, _Alloc>& __x)\n-  { \n-    _M_t = __x._M_t; \n-    return *this;\n-  }\n-\n-  // accessors:\n-\n-  key_compare key_comp() const { return _M_t.key_comp(); }\n-  value_compare value_comp() const { return _M_t.key_comp(); }\n-  allocator_type get_allocator() const { return _M_t.get_allocator(); }\n-\n-  iterator begin() const { return _M_t.begin(); }\n-  iterator end() const { return _M_t.end(); }\n-  reverse_iterator rbegin() const { return _M_t.rbegin(); } \n-  reverse_iterator rend() const { return _M_t.rend(); }\n-  bool empty() const { return _M_t.empty(); }\n-  size_type size() const { return _M_t.size(); }\n-  size_type max_size() const { return _M_t.max_size(); }\n-  void swap(set<_Key,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }\n-\n-  // insert/erase\n-  pair<iterator,bool> insert(const value_type& __x) { \n-    pair<typename _Rep_type::iterator, bool> __p = _M_t.insert_unique(__x); \n-    return pair<iterator, bool>(__p.first, __p.second);\n-  }\n-  iterator insert(iterator __position, const value_type& __x) {\n-    typedef typename _Rep_type::iterator _Rep_iterator;\n-    return _M_t.insert_unique((_Rep_iterator&)__position, __x);\n-  }\n-  template<class _InputIterator>\n-  void insert(_InputIterator __first, _InputIterator __last) {\n-    _M_t.insert_unique(__first, __last);\n-  }\n-  void erase(iterator __position) { \n-    typedef typename _Rep_type::iterator _Rep_iterator;\n-    _M_t.erase((_Rep_iterator&)__position); \n-  }\n-  size_type erase(const key_type& __x) { \n-    return _M_t.erase(__x); \n-  }\n-  void erase(iterator __first, iterator __last) { \n-    typedef typename _Rep_type::iterator _Rep_iterator;\n-    _M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last); \n-  }\n-  void clear() { _M_t.clear(); }\n-\n-  // set operations:\n-\n-  size_type count(const key_type& __x) const {\n-    return _M_t.find(__x) == _M_t.end() ? 0 : 1;\n-  }\n-\n-  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-  // 214.  set::find() missing const overload\n-  iterator find(const key_type& __x) { return _M_t.find(__x); }\n-  const_iterator find(const key_type& __x) const { return _M_t.find(__x); }\n-  iterator lower_bound(const key_type& __x) {\n-    return _M_t.lower_bound(__x);\n-  }\n-  const_iterator lower_bound(const key_type& __x) const {\n-    return _M_t.lower_bound(__x);\n-  }\n-  iterator upper_bound(const key_type& __x) {\n-    return _M_t.upper_bound(__x); \n-  }\n-  const_iterator upper_bound(const key_type& __x) const {\n-    return _M_t.upper_bound(__x); \n-  }\n-  pair<iterator,iterator> equal_range(const key_type& __x) {\n-    return _M_t.equal_range(__x);\n-  }\n-  pair<const_iterator,const_iterator> equal_range(const key_type& __x) const {\n-    return _M_t.equal_range(__x);\n-  }\n-\n-  template<class _K1, class _C1, class _A1>\n-  friend bool operator== (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);\n-  template<class _K1, class _C1, class _A1>\n-  friend bool operator< (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);\n-};\n-\n-template<class _Key, class _Compare, class _Alloc>\n-inline bool operator==(const set<_Key,_Compare,_Alloc>& __x, \n-                       const set<_Key,_Compare,_Alloc>& __y) {\n-  return __x._M_t == __y._M_t;\n-}\n-\n-template<class _Key, class _Compare, class _Alloc>\n-inline bool operator<(const set<_Key,_Compare,_Alloc>& __x, \n-                      const set<_Key,_Compare,_Alloc>& __y) {\n-  return __x._M_t < __y._M_t;\n-}\n-\n-template<class _Key, class _Compare, class _Alloc>\n-inline bool operator!=(const set<_Key,_Compare,_Alloc>& __x, \n-                       const set<_Key,_Compare,_Alloc>& __y) {\n-  return !(__x == __y);\n-}\n-\n-template<class _Key, class _Compare, class _Alloc>\n-inline bool operator>(const set<_Key,_Compare,_Alloc>& __x, \n-                      const set<_Key,_Compare,_Alloc>& __y) {\n-  return __y < __x;\n-}\n-\n-template<class _Key, class _Compare, class _Alloc>\n-inline bool operator<=(const set<_Key,_Compare,_Alloc>& __x, \n-                       const set<_Key,_Compare,_Alloc>& __y) {\n-  return !(__y < __x);\n-}\n-\n-template<class _Key, class _Compare, class _Alloc>\n-inline bool operator>=(const set<_Key,_Compare,_Alloc>& __x, \n-                       const set<_Key,_Compare,_Alloc>& __y) {\n-  return !(__x < __y);\n-}\n-\n-template<class _Key, class _Compare, class _Alloc>\n-inline void swap(set<_Key,_Compare,_Alloc>& __x, \n-                 set<_Key,_Compare,_Alloc>& __y) {\n-  __x.swap(__y);\n-}\n+      //@}\n+\n+    private:\n+      typedef _Rb_tree<key_type, value_type, \n+\t\t       _Identity<value_type>, key_compare, _Alloc> _Rep_type;\n+      _Rep_type _M_t;  // red-black tree representing set\n+    public:\n+      //@{\n+      ///  Iterator-related typedefs.\n+      typedef typename _Alloc::pointer pointer;\n+      typedef typename _Alloc::const_pointer const_pointer;\n+      typedef typename _Alloc::reference reference;\n+      typedef typename _Alloc::const_reference const_reference;\n+      typedef typename _Rep_type::const_iterator iterator;\n+      typedef typename _Rep_type::const_iterator const_iterator;\n+      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;\n+      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n+      typedef typename _Rep_type::size_type size_type;\n+      typedef typename _Rep_type::difference_type difference_type;\n+      typedef typename _Rep_type::allocator_type allocator_type;\n+      //@}\n+\n+      // allocation/deallocation\n+      ///  Default constructor creates no elements.\n+      set() : _M_t(_Compare(), allocator_type()) {}\n+\n+      /**\n+       *  @brief  Default constructor creates no elements.\n+       *\n+       *  @param  comp  Comparator to use.\n+       *  @param  a  Allocator to use.\n+       */\n+      explicit set(const _Compare& __comp,\n+\t\t   const allocator_type& __a = allocator_type())\n+\t: _M_t(__comp, __a) {}\n+\n+      /**\n+       *  @brief  Builds a %set from a range.\n+       *  @param  first  An input iterator.\n+       *  @param  last  An input iterator.\n+       *\n+       *  Create a %set consisting of copies of the elements from [first,last).\n+       *  This is linear in N if the range is already sorted, and NlogN\n+       *  otherwise (where N is distance(first,last)).\n+       */\n+      template<class _InputIterator>\n+      set(_InputIterator __first, _InputIterator __last)\n+\t: _M_t(_Compare(), allocator_type())\n+      { _M_t.insert_unique(__first, __last); }\n+\n+      /**\n+       *  @brief  Builds a %set from a range.\n+       *  @param  first  An input iterator.\n+       *  @param  last  An input iterator.\n+       *  @param  comp  A comparison functor.\n+       *  @param  a  An allocator object.\n+       *\n+       *  Create a %set consisting of copies of the elements from [first,last).\n+       *  This is linear in N if the range is already sorted, and NlogN\n+       *  otherwise (where N is distance(first,last)).\n+       */\n+      template<class _InputIterator>\n+      set(_InputIterator __first, _InputIterator __last, const _Compare& __comp,\n+\t  const allocator_type& __a = allocator_type())\n+\t: _M_t(__comp, __a)\n+      { _M_t.insert_unique(__first, __last); }\n+\n+      /**\n+       *  @brief  Set copy constructor.\n+       *  @param  x  A %set of identical element and allocator types.\n+       *\n+       *  The newly-created %set uses a copy of the allocation object used\n+       *  by @a x.\n+       */\n+      set(const set<_Key,_Compare,_Alloc>& __x) : _M_t(__x._M_t) {}\n+      \n+      /**\n+       *  @brief  Set assignment operator.\n+       *  @param  x  A %set of identical element and allocator types.\n+       *\n+       *  All the elements of @a x are copied, but unlike the copy constructor,\n+       *  the allocator object is not copied.\n+       */\n+      set<_Key,_Compare,_Alloc>& operator=(const set<_Key, _Compare, _Alloc>& __x)\n+      { \n+\t_M_t = __x._M_t; \n+\treturn *this;\n+      }\n+\n+      // accessors:\n+\n+      ///  Returns the comparison object with which the %set was constructed.\n+      key_compare key_comp() const { return _M_t.key_comp(); }\n+      ///  Returns the comparison object with which the %set was constructed.\n+      value_compare value_comp() const { return _M_t.key_comp(); }\n+      ///  Returns the allocator object with which the %set was constructed.\n+      allocator_type get_allocator() const { return _M_t.get_allocator(); }\n+\n+      /**\n+       *  Returns a read/write iterator that points to the first element in the\n+       *  %set.  Iteration is done in ascending order according to the keys.\n+       */\n+      iterator begin() const { return _M_t.begin(); }\n+\n+      /**\n+       *  Returns a read/write iterator that points one past the last element in\n+       *  the %set.  Iteration is done in ascending order according to the keys.\n+       */\n+      iterator end() const { return _M_t.end(); }\n+\n+      /**\n+       *  Returns a read/write reverse iterator that points to the last element in\n+       *  the %set.  Iteration is done in descending order according to the keys.\n+       */\n+      reverse_iterator rbegin() const { return _M_t.rbegin(); } \n+\n+      /**\n+       *  Returns a read-only (constant) reverse iterator that points to the last\n+       *  pair in the %map.  Iteration is done in descending order according to\n+       *  the keys.\n+       */\n+      reverse_iterator rend() const { return _M_t.rend(); }\n+\n+      ///  Returns true if the %set is empty.\n+      bool empty() const { return _M_t.empty(); }\n+\n+      ///  Returns the size of the %set.\n+      size_type size() const { return _M_t.size(); }\n+\n+      ///  Returns the maximum size of the %set.\n+      size_type max_size() const { return _M_t.max_size(); }\n+\n+      /**\n+       *  @brief  Swaps data with another %set.\n+       *  @param  x  A %set of the same element and allocator types.\n+       *\n+       *  This exchanges the elements between two sets in constant time.\n+       *  (It is only swapping a pointer, an integer, and an instance of\n+       *  the @c Compare type (which itself is often stateless and empty), so it\n+       *  should be quite fast.)\n+       *  Note that the global std::swap() function is specialized such that\n+       *  std::swap(s1,s2) will feed to this function.\n+       */\n+      void swap(set<_Key,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }\n+\n+      // insert/erase\n+      /**\n+       *  @brief Attempts to insert an element into the %set.\n+       *  @param  x  Element to be inserted.\n+       *  @return  A pair, of which the first element is an iterator that points\n+       *           to the possibly inserted element, and the second is a bool that\n+       *           is true if the element was actually inserted.\n+       *\n+       *  This function attempts to insert an element into the %set.  A %set\n+       *  relies on unique keys and thus an element is only inserted if it is\n+       *  not already present in the %set.\n+       *\n+       *  Insertion requires logarithmic time.\n+       */\n+      pair<iterator,bool> insert(const value_type& __x)\n+      { \n+\tpair<typename _Rep_type::iterator, bool> __p = _M_t.insert_unique(__x); \n+\treturn pair<iterator, bool>(__p.first, __p.second);\n+      }\n+\n+      /**\n+       *  @brief Attempts to insert an element into the %set.\n+       *  @param  position  An iterator that serves as a hint as to where the\n+       *                    element should be inserted.\n+       *  @param  x  Element to be inserted.\n+       *  @return  An iterator that points to the element with key of @a x (may\n+       *           or may not be the element passed in).\n+       *\n+       *  This function is not concerned about whether the insertion took place,\n+       *  and thus does not return a boolean like the single-argument insert()\n+       *  does.  Note that the first parameter is only a hint and can\n+       *  potentially improve the performance of the insertion process.  A bad\n+       *  hint would cause no gains in efficiency.\n+       *\n+       *  See http://gcc.gnu.org/onlinedocs/libstdc++/23_containers/howto.html#4\n+       *  for more on \"hinting\".\n+       *\n+       *  Insertion requires logarithmic time (if the hint is not taken).\n+       */\n+      iterator insert(iterator __position, const value_type& __x)\n+      {\n+\ttypedef typename _Rep_type::iterator _Rep_iterator;\n+\treturn _M_t.insert_unique((_Rep_iterator&)__position, __x);\n+      }\n+\n+      /**\n+       *  @brief A template function that attemps to insert a range of elements.\n+       *  @param  first  Iterator pointing to the start of the range to be\n+       *                 inserted.\n+       *  @param  last  Iterator pointing to the end of the range.\n+       *\n+       *  Complexity similar to that of the range constructor.\n+       */\n+      template<class _InputIterator>\n+      void insert(_InputIterator __first, _InputIterator __last)\n+      { _M_t.insert_unique(__first, __last); }\n+      \n+      /**\n+       *  @brief Erases an element from a %set.\n+       *  @param  position  An iterator pointing to the element to be erased.\n+       *\n+       *  This function erases an element, pointed to by the given iterator,\n+       *  from a %set.  Note that this function only erases the element, and\n+       *  that if the element is itself a pointer, the pointed-to memory is not\n+       *  touched in any way.  Managing the pointer is the user's responsibilty.\n+       */\n+      void erase(iterator __position)\n+      { \n+\ttypedef typename _Rep_type::iterator _Rep_iterator;\n+\t_M_t.erase((_Rep_iterator&)__position); \n+      }\n+\n+      /**\n+       *  @brief Erases elements according to the provided key.\n+       *  @param  x  Key of element to be erased.\n+       *  @return  The number of elements erased.\n+       *\n+       *  This function erases all the elements located by the given key from\n+       *  a %set.\n+       *  Note that this function only erases the element, and that if\n+       *  the element is itself a pointer, the pointed-to memory is not touched\n+       *  in any way.  Managing the pointer is the user's responsibilty.\n+       */\n+      size_type erase(const key_type& __x) { return _M_t.erase(__x); }\n+\n+      /**\n+       *  @brief Erases a [first,last) range of elements from a %set.\n+       *  @param  first  Iterator pointing to the start of the range to be erased.\n+       *  @param  last  Iterator pointing to the end of the range to be erased.\n+       *\n+       *  This function erases a sequence of elements from a %set.\n+       *  Note that this function only erases the element, and that if\n+       *  the element is itself a pointer, the pointed-to memory is not touched\n+       *  in any way.  Managing the pointer is the user's responsibilty.\n+       */\n+      void erase(iterator __first, iterator __last)\n+      {\n+\ttypedef typename _Rep_type::iterator _Rep_iterator;\n+\t_M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last); \n+      }\n+\n+      /**\n+       *  Erases all elements in a %set.  Note that this function only erases\n+       *  the elements, and that if the elements themselves are pointers, the\n+       *  pointed-to memory is not touched in any way.  Managing the pointer is\n+       *  the user's responsibilty.\n+       */\n+      void clear() { _M_t.clear(); }\n+\n+      // set operations:\n+\n+      /**\n+       *  @brief  Finds the number of elements.\n+       *  @param  x  Element to located.\n+       *  @return  Number of elements with specified key.\n+       *\n+       *  This function only makes sense for multisets; for set the result will\n+       *  either be 0 (not present) or 1 (present).\n+       */\n+      size_type count(const key_type& __x) const\n+      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 214.  set::find() missing const overload\n+      //@{\n+      /**\n+       *  @brief Tries to locate an element in a %set.\n+       *  @param  x  Element to be located.\n+       *  @return  Iterator pointing to sought-after element, or end() if not\n+       *           found.\n+       *\n+       *  This function takes a key and tries to locate the element with which\n+       *  the key matches.  If successful the function returns an iterator\n+       *  pointing to the sought after element.  If unsuccessful it returns the\n+       *  past-the-end ( @c end() ) iterator.\n+       */\n+      iterator find(const key_type& __x) { return _M_t.find(__x); }\n+      const_iterator find(const key_type& __x) const { return _M_t.find(__x); }\n+      //@}\n+\n+      //@{\n+      /**\n+       *  @brief Finds the beginning of a subsequence matching given key.\n+       *  @param  x  Key to be located.\n+       *  @return  Iterator pointing to first element equal to or greater\n+       *           than key, or end().\n+       *\n+       *  This function returns the first element of a subsequence of elements\n+       *  that matches the given key.  If unsuccessful it returns an iterator\n+       *  pointing to the first element that has a greater value than given key\n+       *  or end() if no such element exists.\n+       */\n+      iterator lower_bound(const key_type& __x)\n+      { return _M_t.lower_bound(__x); }\n+      const_iterator lower_bound(const key_type& __x) const\n+      { return _M_t.lower_bound(__x); }\n+      //@}\n+\n+      //@{\n+      /**\n+       *  @brief Finds the end of a subsequence matching given key.\n+       *  @param  x  Key to be located.\n+       *  @return Iterator pointing to the first element\n+       *          greater than key, or end().\n+       */\n+      iterator upper_bound(const key_type& __x)\n+      { return _M_t.upper_bound(__x); }\n+      const_iterator upper_bound(const key_type& __x) const\n+      { return _M_t.upper_bound(__x); }\n+      //@}\n+\n+      //@{\n+      /**\n+       *  @brief Finds a subsequence matching given key.\n+       *  @param  x  Key to be located.\n+       *  @return  Pair of iterators that possibly points to the subsequence\n+       *           matching given key.\n+       *\n+       *  This function is equivalent to\n+       *  @code\n+       *    std::make_pair(c.lower_bound(val),\n+       *                   c.upper_bound(val))\n+       *  @endcode\n+       *  (but is faster than making the calls separately).\n+       *\n+       *  This function probably only makes sense for multisets.\n+       */\n+      pair<iterator,iterator> equal_range(const key_type& __x)\n+      { return _M_t.equal_range(__x); }\n+      pair<const_iterator,const_iterator> equal_range(const key_type& __x) const\n+      { return _M_t.equal_range(__x); }\n+      //@}\n+\n+      template<class _K1, class _C1, class _A1>\n+      friend bool operator== (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);\n+      template<class _K1, class _C1, class _A1>\n+      friend bool operator< (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);\n+    };\n+\n+\n+  /**\n+   *  @brief  Set equality comparison.\n+   *  @param  x  A %set.\n+   *  @param  y  A %set of the same type as @a x.\n+   *  @return  True iff the size and elements of the sets are equal.\n+   *\n+   *  This is an equivalence relation.  It is linear in the size of the sets.\n+   *  Sets are considered equivalent if their sizes are equal, and if\n+   *  corresponding elements compare equal.\n+  */\n+  template<class _Key, class _Compare, class _Alloc>\n+    inline bool\n+    operator==(const set<_Key,_Compare,_Alloc>& __x, \n+\t       const set<_Key,_Compare,_Alloc>& __y)\n+    { return __x._M_t == __y._M_t; }\n+\n+  /**\n+   *  @brief  Set ordering relation.\n+   *  @param  x  A %set.\n+   *  @param  y  A %set of the same type as @a x.\n+   *  @return  True iff @a x is lexicographically less than @a y.\n+   *\n+   *  This is a total ordering relation.  It is linear in the size of the\n+   *  maps.  The elements must be comparable with @c <.\n+   *\n+   *  See std::lexicographical_compare() for how the determination is made.\n+  */\n+  template<class _Key, class _Compare, class _Alloc>\n+    inline bool\n+    operator<(const set<_Key,_Compare,_Alloc>& __x, \n+\t      const set<_Key,_Compare,_Alloc>& __y)\n+    { return __x._M_t < __y._M_t; }\n+\n+  ///  Returns !(x == y).\n+  template<class _Key, class _Compare, class _Alloc>\n+    inline bool\n+    operator!=(const set<_Key,_Compare,_Alloc>& __x, \n+\t       const set<_Key,_Compare,_Alloc>& __y)\n+    { return !(__x == __y); }\n+\n+  ///  Returns y < x.\n+  template<class _Key, class _Compare, class _Alloc>\n+    inline bool\n+    operator>(const set<_Key,_Compare,_Alloc>& __x, \n+\t      const set<_Key,_Compare,_Alloc>& __y)\n+  { return __y < __x; }\n+\n+\n+  ///  Returns !(y < x)\n+  template<class _Key, class _Compare, class _Alloc>\n+    inline bool\n+    operator<=(const set<_Key,_Compare,_Alloc>& __x, \n+\t       const set<_Key,_Compare,_Alloc>& __y)\n+    { return !(__y < __x); }\n+  \n+  ///  Returns !(x < y)\n+  template<class _Key, class _Compare, class _Alloc>\n+    inline bool\n+    operator>=(const set<_Key,_Compare,_Alloc>& __x, \n+\t       const set<_Key,_Compare,_Alloc>& __y)\n+    { return !(__x < __y); }\n+\n+  /// See std::set::swap().\n+  template<class _Key, class _Compare, class _Alloc>\n+    inline void\n+    swap(set<_Key,_Compare,_Alloc>& __x, set<_Key,_Compare,_Alloc>& __y)\n+    { __x.swap(__y); }\n \n } // namespace __gnu_norm\n "}, {"sha": "a8bc0565a900d6cd94fc0f7bc1d3c00c8aaaeb21", "filename": "libstdc++-v3/include/bits/stream_iterator.h", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstream_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstream_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstream_iterator.h?ref=ffcec5c8324a55d5d0a3e80c08abfcee7b24df87", "patch": "@@ -1,6 +1,6 @@\n // Stream iterators\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -41,6 +41,7 @@\n \n namespace std\n {\n+  /// Provides input iterator semantics for streams.\n   template<typename _Tp, typename _CharT = char, \n            typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t> \n     class istream_iterator \n@@ -56,9 +57,11 @@ namespace std\n       _Tp \t\t_M_value;\n       bool \t\t_M_ok;\n \n-    public:      \n+    public:\n+      ///  Construct end of input stream iterator.\n       istream_iterator() : _M_stream(0), _M_ok(false) {}\n \n+      ///  Construct start of input stream iterator.\n       istream_iterator(istream_type& __s) : _M_stream(&__s) { _M_read(); }\n \n       istream_iterator(const istream_iterator& __obj) \n@@ -116,42 +119,72 @@ namespace std\n       }\n     };\n   \n+  ///  Return true if x and y are both end or not end, or x and y are the same.\n   template<typename _Tp, typename _CharT, typename _Traits, typename _Dist>\n     inline bool \n     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n \t       const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y) \n     { return __x._M_equal(__y); }\n \n+  ///  Return false if x and y are both end or not end, or x and y are the same.\n   template <class _Tp, class _CharT, class _Traits, class _Dist>\n     inline bool \n     operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n \t       const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y) \n     { return !__x._M_equal(__y); }\n \n \n+  /**\n+   *  @brief  Provides output iterator semantics for streams.\n+   *\n+   *  This class provides an iterator to write to an ostream.  The type Tp is\n+   *  the only type written by this iterator and there must be an\n+   *  operator<<(Tp) defined.\n+   *\n+   *  @param  Tp  The type to write to the ostream.\n+   *  @param  CharT  The ostream char_type.\n+   *  @param  Traits  The ostream char_traits.\n+  */\n   template<typename _Tp, typename _CharT = char, \n            typename _Traits = char_traits<_CharT> >\n     class ostream_iterator \n       : public iterator<output_iterator_tag, void, void, void, void>\n     {\n     public:\n+      //@{\n+      /// Public typedef\n       typedef _CharT                         char_type;\n       typedef _Traits                        traits_type;\n       typedef basic_ostream<_CharT, _Traits> ostream_type;\n+      //@}\n \n     private:\n       ostream_type* \t_M_stream;\n       const _CharT* \t_M_string;\n \n     public:\n+      /// Construct from an ostream.\n       ostream_iterator(ostream_type& __s) : _M_stream(&__s), _M_string(0) {}\n \n+      /**\n+       *  Construct from an ostream.\n+       *\n+       *  The delimiter string @a c is written to the stream after every Tp\n+       *  written to the stream.  The delimiter is not copied, and thus must\n+       *  not be destroyed while this iterator is in use.\n+       *\n+       *  @param  s  Underlying ostream to write to.\n+       *  @param  c  CharT delimiter string to insert.\n+      */\n       ostream_iterator(ostream_type& __s, const _CharT* __c) \n       : _M_stream(&__s), _M_string(__c)  { }\n \n+      /// Copy constructor.\n       ostream_iterator(const ostream_iterator& __obj)\n       : _M_stream(__obj._M_stream), _M_string(__obj._M_string)  { }\n \n+      /// Writes @a value to underlying ostream using operator<<.  If\n+      /// constructed with delimiter string, writes delimiter to ostream.\n       ostream_iterator& \n       operator=(const _Tp& __value) \n       { "}, {"sha": "908b8ddf33abbceb4ba9735166b954a7e22fc6d9", "filename": "libstdc++-v3/include/bits/streambuf_iterator.h", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h?ref=ffcec5c8324a55d5d0a3e80c08abfcee7b24df87", "patch": "@@ -1,6 +1,6 @@\n // Streambuf iterators\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -46,18 +46,22 @@\n namespace std\n {\n   // 24.5.3 Template class istreambuf_iterator\n+  /// Provides input iterator semantics for streambufs.\n   template<typename _CharT, typename _Traits>\n     class istreambuf_iterator\n     : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,\n     \t\t      _CharT*, _CharT&>\n     {\n     public:\n       // Types:\n+      //@{\n+      /// Public typedefs\n       typedef _CharT                         \t\tchar_type;\n       typedef _Traits                        \t\ttraits_type;\n       typedef typename _Traits::int_type     \t\tint_type;\n       typedef basic_streambuf<_CharT, _Traits> \t\tstreambuf_type;\n       typedef basic_istream<_CharT, _Traits>         \tistream_type;\n+      //@}\n \n     private:\n       // 24.5.3 istreambuf_iterator \n@@ -71,16 +75,21 @@ namespace std\n       int_type \t\t\t_M_c;\n \n     public:\n+      ///  Construct end of input stream iterator.\n       istreambuf_iterator() throw() \n       : _M_sbuf(0), _M_c(traits_type::eof()) { }\n       \n+      ///  Construct start of input stream iterator.\n       istreambuf_iterator(istream_type& __s) throw()\n       : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }\n \n+      ///  Construct start of streambuf iterator.\n       istreambuf_iterator(streambuf_type* __s) throw()\n       : _M_sbuf(__s), _M_c(traits_type::eof()) { }\n        \n-      // NB: The result of operator*() on an end of stream is undefined.\n+      ///  Return the current character pointed to by iterator.  This returns\n+      ///  streambuf.sgetc().  It cannot be assigned.  NB: The result of\n+      ///  operator*() on an end of stream is undefined.\n       char_type \n       operator*() const\n       { \n@@ -93,7 +102,8 @@ namespace std\n #endif\n \treturn traits_type::to_char_type(_M_get()); \n       }\n-\t\n+\n+      /// Advance the iterator.  Calls streambuf.sbumpc().\n       istreambuf_iterator& \n       operator++()\n       { \n@@ -108,6 +118,7 @@ namespace std\n \treturn *this; \n       }\n \n+      /// Advance the iterator.  Calls streambuf.sbumpc().\n       istreambuf_iterator\n       operator++(int)\n       {\n@@ -129,6 +140,7 @@ namespace std\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 110 istreambuf_iterator::equal not const\n       // NB: there is also number 111 (NAD, Future) pending on this function.\n+      /// Return true both iterators are end or both are not end.\n       bool \n       equal(const istreambuf_iterator& __b) const\n       {\n@@ -174,28 +186,35 @@ namespace std\n \t       const istreambuf_iterator<_CharT, _Traits>& __b)\n     { return !__a.equal(__b); }\n \n+  /// Provides output iterator semantics for streambufs.\n   template<typename _CharT, typename _Traits>\n     class ostreambuf_iterator\n     : public iterator<output_iterator_tag, void, void, void, void>\n     {\n     public:\n       // Types:\n+      //@{\n+      /// Public typedefs\n       typedef _CharT                           char_type;\n       typedef _Traits                          traits_type;\n       typedef basic_streambuf<_CharT, _Traits> streambuf_type;\n       typedef basic_ostream<_CharT, _Traits>   ostream_type;\n+      //@}\n \n     private:\n       streambuf_type* \t_M_sbuf;\n       bool \t\t_M_failed;\n \n     public:\n+      ///  Construct output iterator from ostream.\n       ostreambuf_iterator(ostream_type& __s) throw ()\n       : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }\n       \n+      ///  Construct output iterator from streambuf.\n       ostreambuf_iterator(streambuf_type* __s) throw ()\n       : _M_sbuf(__s), _M_failed(!_M_sbuf) { }\n \n+      ///  Write character to streambuf.  Calls streambuf.sputc().\n       ostreambuf_iterator& \n       operator=(_CharT __c)\n       {\n@@ -205,18 +224,22 @@ namespace std\n \treturn *this;\n       }\n \n+      /// Return *this.\n       ostreambuf_iterator& \n       operator*()\n       { return *this; }\n \n+      /// Return *this.\n       ostreambuf_iterator& \n       operator++(int)\n       { return *this; }\n \n+      /// Return *this.\n       ostreambuf_iterator& \n       operator++()\n       { return *this; }\n \n+      /// Return true if previous operator=() failed.\n       bool \n       failed() const throw()\n       { return _M_failed; }"}, {"sha": "25c657f270116c64e9d61871601aea6d114651b0", "filename": "libstdc++-v3/include/std/std_complex.h", "status": "modified", "additions": 70, "deletions": 2, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_complex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffcec5c8324a55d5d0a3e80c08abfcee7b24df87/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_complex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_complex.h?ref=ffcec5c8324a55d5d0a3e80c08abfcee7b24df87", "patch": "@@ -58,67 +58,113 @@ namespace std\n   template<> class complex<double>;\n   template<> class complex<long double>;\n \n+  ///  Return magnitude of @a z.\n   template<typename _Tp> _Tp abs(const complex<_Tp>&);\n+  ///  Return phase angle of @a z.\n   template<typename _Tp> _Tp arg(const complex<_Tp>&);\n+  ///  Return @a z magnitude squared.\n   template<typename _Tp> _Tp norm(const complex<_Tp>&);\n \n+  ///  Return complex conjugate of @a z.\n   template<typename _Tp> complex<_Tp> conj(const complex<_Tp>&);\n+  ///  Return complex with magnitude @a rho and angle @a theta.\n   template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp& = 0);\n \n   // Transcendentals:\n+  /// Return complex cosine of @a z.\n   template<typename _Tp> complex<_Tp> cos(const complex<_Tp>&);\n+  /// Return complex hyperbolic cosine of @a z.\n   template<typename _Tp> complex<_Tp> cosh(const complex<_Tp>&);\n+  /// Return complex base e exponential of @a z.\n   template<typename _Tp> complex<_Tp> exp(const complex<_Tp>&);\n+  /// Return complex natural logarithm of @a z.\n   template<typename _Tp> complex<_Tp> log(const complex<_Tp>&);\n+  /// Return complex base 10 logarithm of @a z.\n   template<typename _Tp> complex<_Tp> log10(const complex<_Tp>&);\n+  /// Return complex cosine of @a z.\n   template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, int);\n+  /// Return @a x to the @a y'th power.\n   template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);\n+  /// Return @a x to the @a y'th power.\n   template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, \n \t\t\t\t\t   const complex<_Tp>&);\n+  /// Return @a x to the @a y'th power.\n   template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);\n+  /// Return complex sine of @a z.\n   template<typename _Tp> complex<_Tp> sin(const complex<_Tp>&);\n+  /// Return complex hyperbolic sine of @a z.\n   template<typename _Tp> complex<_Tp> sinh(const complex<_Tp>&);\n+  /// Return complex square root of @a z.\n   template<typename _Tp> complex<_Tp> sqrt(const complex<_Tp>&);\n+  /// Return complex tangent of @a z.\n   template<typename _Tp> complex<_Tp> tan(const complex<_Tp>&);\n+  /// Return complex hyperbolic tangent of @a z.\n   template<typename _Tp> complex<_Tp> tanh(const complex<_Tp>&);\n+  //@}\n     \n     \n   // 26.2.2  Primary template class complex\n+  /**\n+   *  Template to represent complex numbers.\n+   *\n+   *  Specializations for float, double, and long double are part of the\n+   *  library.  Results with any other type are not guaranteed.\n+   *\n+   *  @param  Tp  Type of real and imaginary values.\n+  */\n   template<typename _Tp>\n     class complex\n     {\n     public:\n+      /// Value typedef.\n       typedef _Tp value_type;\n       \n+      ///  Default constructor.  First parameter is x, second parameter is y.\n+      ///  Unspecified parameters default to 0.\n       complex(const _Tp& = _Tp(), const _Tp & = _Tp());\n \n-      // Let's the compiler synthetize the copy constructor   \n+      // Lets the compiler synthesize the copy constructor   \n       // complex (const complex<_Tp>&);\n+      ///  Copy constructor.\n       template<typename _Up>\n         complex(const complex<_Up>&);\n \n+      ///  Return real part of complex number.\n       _Tp& real(); \n+      ///  Return real part of complex number.\n       const _Tp& real() const;\n+      ///  Return imaginary part of complex number.\n       _Tp& imag();\n+      ///  Return imaginary part of complex number.\n       const _Tp& imag() const;\n \n+      /// Assign this complex number to scalar @a t.\n       complex<_Tp>& operator=(const _Tp&);\n+      /// Add @a t to this complex number.\n       complex<_Tp>& operator+=(const _Tp&);\n+      /// Subtract @a t from this complex number.\n       complex<_Tp>& operator-=(const _Tp&);\n+      /// Multiply this complex number by @a t.\n       complex<_Tp>& operator*=(const _Tp&);\n+      /// Divide this complex number by @a t.\n       complex<_Tp>& operator/=(const _Tp&);\n \n-      // Let's the compiler synthetize the\n+      // Lets the compiler synthesize the\n       // copy and assignment operator\n       // complex<_Tp>& operator= (const complex<_Tp>&);\n+      /// Assign this complex number to complex @a z.\n       template<typename _Up>\n         complex<_Tp>& operator=(const complex<_Up>&);\n+      /// Add @a z to this complex number.\n       template<typename _Up>\n         complex<_Tp>& operator+=(const complex<_Up>&);\n+      /// Subtract @a z from this complex number.\n       template<typename _Up>\n         complex<_Tp>& operator-=(const complex<_Up>&);\n+      /// Multiply this complex number by @a z.\n       template<typename _Up>\n         complex<_Tp>& operator*=(const complex<_Up>&);\n+      /// Divide this complex number by @a z.\n       template<typename _Up>\n         complex<_Tp>& operator/=(const complex<_Up>&);\n \n@@ -261,6 +307,8 @@ namespace std\n     }\n     \n   // Operators:\n+  //@{\n+  ///  Return new complex value @a x plus @a y.\n   template<typename _Tp>\n     inline complex<_Tp>\n     operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)\n@@ -287,7 +335,10 @@ namespace std\n       __r.real() += __x;\n       return __r;\n     }\n+  //@}\n \n+  //@{\n+  ///  Return new complex value @a x minus @a y.\n   template<typename _Tp>\n     inline complex<_Tp>\n     operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)\n@@ -314,7 +365,10 @@ namespace std\n       __r.real() -= __y.real();\n       return __r;\n     }\n+  //@}\n \n+  //@{\n+  ///  Return new complex value @a x times @a y.\n   template<typename _Tp>\n     inline complex<_Tp>\n     operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)\n@@ -341,7 +395,10 @@ namespace std\n       __r *= __x;\n       return __r;\n     }\n+  //@}\n \n+  //@{\n+  ///  Return new complex value @a x divided by @a y.\n   template<typename _Tp>\n     inline complex<_Tp>\n     operator/(const complex<_Tp>& __x, const complex<_Tp>& __y)\n@@ -368,17 +425,22 @@ namespace std\n       __r /= __y;\n       return __r;\n     }\n+  //@}\n \n+  ///  Return @a x.\n   template<typename _Tp>\n     inline complex<_Tp>\n     operator+(const complex<_Tp>& __x)\n     { return __x; }\n \n+  ///  Return complex negation of @a x.\n   template<typename _Tp>\n     inline complex<_Tp>\n     operator-(const complex<_Tp>& __x)\n     {  return complex<_Tp>(-__x.real(), -__x.imag()); }\n \n+  //@{\n+  ///  Return true if @a x is equal to @a y.\n   template<typename _Tp>\n     inline bool\n     operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)\n@@ -393,7 +455,10 @@ namespace std\n     inline bool\n     operator==(const _Tp& __x, const complex<_Tp>& __y)\n     { return __x == __y.real() && _Tp() == __y.imag(); }\n+  //@}\n \n+  //@{\n+  ///  Return false if @a x is equal to @a y.\n   template<typename _Tp>\n     inline bool\n     operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)\n@@ -408,7 +473,9 @@ namespace std\n     inline bool\n     operator!=(const _Tp& __x, const complex<_Tp>& __y)\n     { return __x != __y.real() || _Tp() != __y.imag(); }\n+  //@}\n \n+  ///  Extraction operator for complex values.\n   template<typename _Tp, typename _CharT, class _Traits>\n     basic_istream<_CharT, _Traits>&\n     operator>>(basic_istream<_CharT, _Traits>& __is, complex<_Tp>& __x)\n@@ -441,6 +508,7 @@ namespace std\n       return __is;\n     }\n \n+  ///  Insertion operator for complex values.\n   template<typename _Tp, typename _CharT, class _Traits>\n     basic_ostream<_CharT, _Traits>&\n     operator<<(basic_ostream<_CharT, _Traits>& __os, const complex<_Tp>& __x)"}]}