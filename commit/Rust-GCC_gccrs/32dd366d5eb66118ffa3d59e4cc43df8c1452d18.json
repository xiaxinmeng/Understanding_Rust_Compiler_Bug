{"sha": "32dd366d5eb66118ffa3d59e4cc43df8c1452d18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJkZDM2NmQ1ZWI2NjExOGZmYTNkNTllNGNjNDNkZjhjMTQ1MmQxOA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-01-18T22:32:06Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-01-18T22:32:06Z"}, "message": "basic-block.h: Fix comment formatting.\n\n\t* basic-block.h: Fix comment formatting.\n\t* calls.c: Likewise.\n\t* combine.c: Likewise.\n\t* convert.c: Likewise.\n\t* gcov.c: Likewise.\n\t* haifa-sched.c: Likewise.\n\t* libgcc2.c: Likewise.\n\t* loop.c: Likewise.\n\t* profile.c: Likewise.\n\t* system.h: Likewise.\n\nFrom-SVN: r61478", "tree": {"sha": "425ca14b83df83fc9ec4077dae150050d77bb259", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/425ca14b83df83fc9ec4077dae150050d77bb259"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32dd366d5eb66118ffa3d59e4cc43df8c1452d18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32dd366d5eb66118ffa3d59e4cc43df8c1452d18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32dd366d5eb66118ffa3d59e4cc43df8c1452d18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/comments", "author": null, "committer": null, "parents": [{"sha": "634661fe5a3f091d6c4b15527ddc7cfc3e448469", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/634661fe5a3f091d6c4b15527ddc7cfc3e448469", "html_url": "https://github.com/Rust-GCC/gccrs/commit/634661fe5a3f091d6c4b15527ddc7cfc3e448469"}], "stats": {"total": 65, "additions": 39, "deletions": 26}, "files": [{"sha": "fcf1cbcb98bc802d0358d0a1054dac3fdf37d04a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32dd366d5eb66118ffa3d59e4cc43df8c1452d18", "patch": "@@ -1,3 +1,16 @@\n+2003-01-18  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* basic-block.h: Fix comment formatting.\n+\t* calls.c: Likewise.\n+\t* combine.c: Likewise.\n+\t* convert.c: Likewise.\n+\t* gcov.c: Likewise.\n+\t* haifa-sched.c: Likewise.\n+\t* libgcc2.c: Likewise.\n+\t* loop.c: Likewise.\n+\t* profile.c: Likewise.\n+\t* system.h: Likewise.\n+\n 2003-01-18  Roger Sayle  <roger@eyesopen.com>\n \n \t* config/pa/pa.md (muldi3): Avoid invalid sharing of SUBREG RTXs."}, {"sha": "fbc231eda0a122dea8db5b9a10945f8274353a36", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=32dd366d5eb66118ffa3d59e4cc43df8c1452d18", "patch": "@@ -117,7 +117,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    64bit.  Although a counter cannot be negative, we use a signed\n    type, because erroneous negative counts can be generated when the\n    flow graph is manipulated by various optimizations.  A signed type\n-   makes those easy to detect. */\n+   makes those easy to detect.  */\n typedef HOST_WIDEST_INT gcov_type;\n \n /* Control flow edge information.  */"}, {"sha": "52b5fc3ddbb49e530f2ff380ccf69f2c99c47491", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=32dd366d5eb66118ffa3d59e4cc43df8c1452d18", "patch": "@@ -1770,7 +1770,7 @@ load_register_parameters (args, num_actuals, call_fusage, flags,\n \n \t  /* When a parameter is a block, and perhaps in other cases, it is\n \t     possible that it did a load from an argument slot that was\n-\t     already clobbered. */\n+\t     already clobbered.  */\n \t  if (is_sibcall\n \t      && check_sibcall_argument_overlap (before_arg, &args[i], 0))\n \t    *sibcall_failure = 1;"}, {"sha": "75a4e5fccb8a564e2c06dfa86184695534e28a14", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=32dd366d5eb66118ffa3d59e4cc43df8c1452d18", "patch": "@@ -4350,7 +4350,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t}\n \n        /* Canonicalize (minus (neg A) (mult B C)) to \n-\t  (minus (mult (neg B) C) A). */\n+\t  (minus (mult (neg B) C) A).  */\n       if (GET_CODE (XEXP (x, 1)) == MULT \n \t  && GET_CODE (XEXP (x, 0)) == NEG)\n \t{"}, {"sha": "ae7b2c37bf432fa61aafcb76cf069a7ba61b04d4", "filename": "gcc/convert.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=32dd366d5eb66118ffa3d59e4cc43df8c1452d18", "patch": "@@ -210,7 +210,7 @@ convert_to_real (type, expr)\n \n \t  /* ??? Fortran frontend does not initialize built_in_decls.\n \t     For some reason creating the decl using builtin_function does not\n-\t     work as it should.   */\n+\t     work as it should.  */\n \t  if (built_in_decls [fcode])\n \t    {\n \t      arglist = build_tree_list (NULL_TREE, fold (convert_to_real (newtype, arg0)));"}, {"sha": "dd6dfc9f0df9269939d9c4b53c2468f4e0e9243e", "filename": "gcc/gcov.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=32dd366d5eb66118ffa3d59e4cc43df8c1452d18", "patch": "@@ -74,7 +74,7 @@ struct block_info;\n \n typedef struct arc_info\n {\n-  /* source and destination blocks. */\n+  /* source and destination blocks.  */\n   struct block_info *src;\n   struct block_info *dst;\n \n@@ -106,11 +106,11 @@ typedef struct block_info\n   arc_t *succ;\n   arc_t *pred;\n \n-  /* Number of unprocessed exit and entry arcs. */\n+  /* Number of unprocessed exit and entry arcs.  */\n   gcov_type num_succ;\n   gcov_type num_pred;\n \n-  /* Block execution count. */\n+  /* Block execution count.  */\n   gcov_type count;\n   unsigned count_valid : 1;\n   unsigned valid_chain : 1;\n@@ -122,7 +122,7 @@ typedef struct block_info\n   unsigned *encoding;\n   unsigned num_encodings;\n \n-  /* Temporary chain for solving graph. */\n+  /* Temporary chain for solving graph.  */\n   struct block_info *chain;\n   \n } block_t;\n@@ -171,7 +171,7 @@ typedef struct line_info\n {\n   gcov_type count;\t   /* execution count */\n   arc_t *branches; \t   /* branches from blocks that end on this\n-\t\t\t      line. */\n+\t\t\t      line.  */\n   unsigned exists : 1;\n } line_t;\n \n@@ -184,7 +184,7 @@ typedef struct source_info\n   char *name;\n   unsigned index;\n \n-  /* Array of line information. */\n+  /* Array of line information.  */\n   line_t *lines;\n   unsigned num_lines;\n \n@@ -202,7 +202,7 @@ static function_t *functions;\n \n static source_t *sources;\n \n-/* Modification time of graph file. */\n+/* Modification time of graph file.  */\n \n static time_t bbg_file_time;\n \n@@ -245,7 +245,7 @@ static char *object_directory = 0;\n static int flag_preserve_paths = 0;\n \n /* Output the number of times a branch was taken as opposed to the percentage\n-   of times it was taken. */\n+   of times it was taken.  */\n \n static int flag_counts = 0;\n \n@@ -977,8 +977,8 @@ solve_flow_graph (fn)\n   unsigned ix;\n   arc_t *arc;\n   gcov_type *count_ptr = fn->counts;\n-  block_t *valid_blocks = NULL;    /* valid, but unpropagated blocks. */\n-  block_t *invalid_blocks = NULL;  /* invalid, but inferable blocks. */\n+  block_t *valid_blocks = NULL;    /* valid, but unpropagated blocks.  */\n+  block_t *invalid_blocks = NULL;  /* invalid, but inferable blocks.  */\n   \n   if (fn->num_blocks < 2)\n     fnotice (stderr, \"%s:`%s' lacks entry and/or exit blocks\\n\",\n@@ -1027,7 +1027,7 @@ solve_flow_graph (fn)\n       /* Sort the successor arcs into ascending dst order. profile.c\n \t normally produces arcs in the right order, but sometimes with\n \t one or two out of order.  We're not using a particularly\n-\t smart sort. */\n+\t smart sort.  */\n       if (out_of_order)\n \t{\n \t  arc_t *start = fn->blocks[ix].succ;\n@@ -1380,7 +1380,7 @@ add_line_counts (coverage, fn)\n   line_t *line = NULL; /* this is propagated from one iteration to the\n \t\t\t  next.  */\n \n-  /* Scan each basic block. */\n+  /* Scan each basic block.  */\n   for (ix = 0; ix != fn->num_blocks; ix++)\n     {\n       const block_t *block = &fn->blocks[ix];\n@@ -1434,7 +1434,7 @@ add_line_counts (coverage, fn)\n     fnotice (stderr, \"%s:no lines for `%s'\\n\", bbg_file_name, fn->name);\n }\n \n-/* Accumulate the line counts of a file. */\n+/* Accumulate the line counts of a file.  */\n \n static void\n accumulate_line_counts (src)\n@@ -1447,7 +1447,7 @@ accumulate_line_counts (src)\n     {\n       arc_t *arc, *arc_p, *arc_n;\n       \n-      /* Total and reverse the branch information. */\n+      /* Total and reverse the branch information.  */\n       for (arc = line->branches, arc_p = NULL; arc; arc_p = arc, arc = arc_n)\n \t{\n \t  arc_n = arc->line_next;"}, {"sha": "c5b53cffd54910b7da9455742f5413bfd23328d4", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=32dd366d5eb66118ffa3d59e4cc43df8c1452d18", "patch": "@@ -1543,7 +1543,7 @@ rm_other_notes (head, tail)\n \n /* This function looks for a new register being defined.\n    If the destination register is already used by the source,\n-   a new register is not needed. */\n+   a new register is not needed.  */\n \n static int\n find_set_reg_weight (x)\n@@ -2263,7 +2263,7 @@ schedule_block (b, rgn_n_insns)\n \n \t  /* Sort the ready list based on priority.  This must be\n \t     redone here, as schedule_insn may have readied additional\n-\t     insns that will not be sorted correctly. */\n+\t     insns that will not be sorted correctly.  */\n \t  if (ready.n_ready > 0)\n \t    ready_sort (&ready);\n "}, {"sha": "a47dfd10a329011ebe2ee5500a49484fcec07a82", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=32dd366d5eb66118ffa3d59e4cc43df8c1452d18", "patch": "@@ -1279,7 +1279,7 @@ gcov_version_mismatch (struct gcov_info *ptr, unsigned version)\n    program's checksum to make sure we only accumulate whole program\n    statistics to the correct summary. An object file might be embedded\n    in two separate programs, and we must keep the two program\n-   summaries separate. */\n+   summaries separate.  */\n \n static void\n gcov_exit (void)\n@@ -1503,7 +1503,7 @@ gcov_exit (void)\n       count_ptr = ptr->arc_counts;\n       for (ix = ptr->n_functions, fn_info = ptr->functions; ix--; fn_info++)\n \t{\n-\t  /* Announce function. */\n+\t  /* Announce function.  */\n \t  if (gcov_write_unsigned (da_file, GCOV_TAG_FUNCTION)\n \t      || !(base = gcov_reserve_length (da_file))\n \t      /* function name */\n@@ -1533,7 +1533,7 @@ gcov_exit (void)\n \t    goto write_error;\n \t}\n \n-      /* Object file summary. */\n+      /* Object file summary.  */\n       if (gcov_write_summary (da_file, GCOV_TAG_OBJECT_SUMMARY, &object))\n \tgoto write_error;\n "}, {"sha": "d7ad050b52ea675facfc8b128ec35a807adc885c", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=32dd366d5eb66118ffa3d59e4cc43df8c1452d18", "patch": "@@ -3267,7 +3267,7 @@ loop_invariant_p (loop, x)\n \n       /* Out-of-range regs can occur when we are called from unrolling.\n \t These have always been created by the unroller and are set in\n-\t the loop, hence are never invariant. */\n+\t the loop, hence are never invariant.  */\n \n       if (REGNO (x) >= (unsigned) regs->num)\n \treturn 0;"}, {"sha": "5ee790a14dff6ad6d05bc321b4ada1ebba646bc4", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=32dd366d5eb66118ffa3d59e4cc43df8c1452d18", "patch": "@@ -1674,7 +1674,7 @@ create_profiler ()\n   /* Build structure.  */\n   assemble_variable (structure, 0, 0, 0);\n \n-  /* Build the constructor function to invoke __gcov_init. */\n+  /* Build the constructor function to invoke __gcov_init.  */\n   ctor_name = concat (IDENTIFIER_POINTER (get_file_function_name ('I')),\n \t\t      \"_GCOV\", NULL);\n   ctor = build_decl (FUNCTION_DECL, get_identifier (ctor_name),"}, {"sha": "a7f0bf271bfe435135a8326b8646bbe84cbc0a49", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32dd366d5eb66118ffa3d59e4cc43df8c1452d18/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=32dd366d5eb66118ffa3d59e4cc43df8c1452d18", "patch": "@@ -569,7 +569,7 @@ typedef char _Bool;\n \n #if defined(FLEX_SCANNER) || defined(YYBISON)\n /* Flex and bison use malloc and realloc.  Yuk.  Note that this means\n-   really_call_* cannot be used in a .l or .y file. */\n+   really_call_* cannot be used in a .l or .y file.  */\n #define malloc xmalloc\n #define realloc xrealloc\n #endif"}]}