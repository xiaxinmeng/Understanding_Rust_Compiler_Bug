{"sha": "87361f3098d399531bc329b2ad71f6a530742567", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODczNjFmMzA5OGQzOTk1MzFiYzMyOWIyYWQ3MWY2YTUzMDc0MjU2Nw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2015-01-18T14:25:22Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-01-18T14:25:22Z"}, "message": "atomic_futex.h: Use mutex and condition_variable when atomic int is not lock-free.\n\n\t* include/bits/atomic_futex.h: Use mutex and condition_variable when\n\tatomic int is not lock-free. Make member variables private.\n\t* src/c++11/futex.cc: Likewise.\n\nFrom-SVN: r219815", "tree": {"sha": "5d05b401b06caecf052d80d415985a05f47ea18a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d05b401b06caecf052d80d415985a05f47ea18a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87361f3098d399531bc329b2ad71f6a530742567", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87361f3098d399531bc329b2ad71f6a530742567", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87361f3098d399531bc329b2ad71f6a530742567", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87361f3098d399531bc329b2ad71f6a530742567/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e207c522623c3d3620416b5332b8a6d8644a1f06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e207c522623c3d3620416b5332b8a6d8644a1f06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e207c522623c3d3620416b5332b8a6d8644a1f06"}], "stats": {"total": 99, "additions": 52, "deletions": 47}, "files": [{"sha": "178da523b963590840c7080cb2953909067f43e3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87361f3098d399531bc329b2ad71f6a530742567/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87361f3098d399531bc329b2ad71f6a530742567/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=87361f3098d399531bc329b2ad71f6a530742567", "patch": "@@ -1,3 +1,9 @@\n+2015-01-18  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/bits/atomic_futex.h: Use mutex and condition_variable when\n+\tatomic int is not lock-free. Make member variables private.\n+\t* src/c++11/futex.cc: Likewise.\n+\n 2015-01-17  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/64638"}, {"sha": "51b9c7e573723f56dfec6f5d2a9686f64afe2fe9", "filename": "libstdc++-v3/include/bits/atomic_futex.h", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87361f3098d399531bc329b2ad71f6a530742567/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_futex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87361f3098d399531bc329b2ad71f6a530742567/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_futex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_futex.h?ref=87361f3098d399531bc329b2ad71f6a530742567", "patch": "@@ -35,7 +35,7 @@\n #include <bits/c++config.h>\n #include <atomic>\n #include <chrono>\n-#if !defined(_GLIBCXX_HAVE_LINUX_FUTEX)\n+#if ! (defined(_GLIBCXX_HAVE_LINUX_FUTEX) && ATOMIC_INT_LOCK_FREE > 1)\n #include <mutex>\n #include <condition_variable>\n #endif\n@@ -49,7 +49,7 @@ namespace std _GLIBCXX_VISIBILITY(default)\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1)\n-#if defined(_GLIBCXX_HAVE_LINUX_FUTEX)\n+#if defined(_GLIBCXX_HAVE_LINUX_FUTEX) && ATOMIC_INT_LOCK_FREE > 1\n   struct __atomic_futex_unsigned_base\n   {\n     // Returns false iff a timeout occurred.\n@@ -62,16 +62,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   };\n \n   template <unsigned _Waiter_bit = 0x80000000>\n-  struct __atomic_futex_unsigned : __atomic_futex_unsigned_base\n+  class __atomic_futex_unsigned : __atomic_futex_unsigned_base\n   {\n     typedef chrono::system_clock __clock_t;\n \n-    // XXX We expect this to be lock-free, and having the payload at offset 0.\n-#if ATOMIC_INT_LOCK_FREE < 2\n-# error We require lock-free atomic operations on int\n-#endif\n+    // This must be lock-free and at offset 0.\n     atomic<unsigned> _M_data;\n \n+  public:\n+    explicit\n     __atomic_futex_unsigned(unsigned __data) : _M_data(__data)\n     { }\n \n@@ -82,7 +81,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   private:\n-\n     // If a timeout occurs, returns a current value after the timeout;\n     // otherwise, returns the operand's value if equal is true or a different\n     // value if equal is false.\n@@ -165,26 +163,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     // Returns false iff a timeout occurred.\n     template<typename _Rep, typename _Period>\n-    _GLIBCXX_ALWAYS_INLINE bool\n-    _M_load_when_equal_for(unsigned __val, memory_order __mo,\n-\tconst chrono::duration<_Rep, _Period>& __rtime)\n-    {\n-      return _M_load_when_equal_until(__val, __mo, __clock_t::now() + __rtime);\n-    }\n+      _GLIBCXX_ALWAYS_INLINE bool\n+      _M_load_when_equal_for(unsigned __val, memory_order __mo,\n+\t  const chrono::duration<_Rep, _Period>& __rtime)\n+      {\n+\treturn _M_load_when_equal_until(__val, __mo,\n+\t\t\t\t\t__clock_t::now() + __rtime);\n+      }\n \n     // Returns false iff a timeout occurred.\n     template<typename _Clock, typename _Duration>\n-    _GLIBCXX_ALWAYS_INLINE bool\n-    _M_load_when_equal_until(unsigned __val, memory_order __mo,\n-\tconst chrono::time_point<_Clock, _Duration>& __atime)\n-    {\n-      // DR 887 - Sync unknown clock to known clock.\n-      const typename _Clock::time_point __c_entry = _Clock::now();\n-      const __clock_t::time_point __s_entry = __clock_t::now();\n-      const auto __delta = __atime - __c_entry;\n-      const auto __s_atime = __s_entry + __delta;\n-      return _M_load_when_equal_until(__val, __mo, __s_atime);\n-    }\n+      _GLIBCXX_ALWAYS_INLINE bool\n+      _M_load_when_equal_until(unsigned __val, memory_order __mo,\n+\t  const chrono::time_point<_Clock, _Duration>& __atime)\n+      {\n+\t// DR 887 - Sync unknown clock to known clock.\n+\tconst typename _Clock::time_point __c_entry = _Clock::now();\n+\tconst __clock_t::time_point __s_entry = __clock_t::now();\n+\tconst auto __delta = __atime - __c_entry;\n+\tconst auto __s_atime = __s_entry + __delta;\n+\treturn _M_load_when_equal_until(__val, __mo, __s_atime);\n+      }\n \n     // Returns false iff a timeout occurred.\n     template<typename _Duration>\n@@ -207,23 +206,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (_M_data.exchange(__val, __mo) & _Waiter_bit)\n \t_M_futex_notify_all(__futex);\n     }\n-\n   };\n \n-#else // !_GLIBCXX_HAVE_LINUX_FUTEX\n+#else // ! (_GLIBCXX_HAVE_LINUX_FUTEX && ATOMIC_INT_LOCK_FREE > 1)\n \n   // If futexes are not available, use a mutex and a condvar to wait.\n   // Because we access the data only within critical sections, all accesses\n   // are sequentially consistent; thus, we satisfy any provided memory_order.\n   template <unsigned _Waiter_bit = 0x80000000>\n-  struct __atomic_futex_unsigned\n+  class __atomic_futex_unsigned\n   {\n     typedef chrono::system_clock __clock_t;\n \n     unsigned _M_data;\n     mutex _M_mutex;\n     condition_variable _M_condvar;\n \n+  public:\n+    explicit\n     __atomic_futex_unsigned(unsigned __data) : _M_data(__data)\n     { }\n \n@@ -252,24 +252,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n     template<typename _Rep, typename _Period>\n-    _GLIBCXX_ALWAYS_INLINE bool\n-    _M_load_when_equal_for(unsigned __val, memory_order __mo,\n-\tconst chrono::duration<_Rep, _Period>& __rtime)\n-    {\n-      unique_lock<mutex> __lock(_M_mutex);\n-      return _M_condvar.wait_for(__lock, __rtime,\n-\t\t\t\t [&] { return _M_data == __val;});\n-    }\n+      _GLIBCXX_ALWAYS_INLINE bool\n+      _M_load_when_equal_for(unsigned __val, memory_order __mo,\n+\t  const chrono::duration<_Rep, _Period>& __rtime)\n+      {\n+\tunique_lock<mutex> __lock(_M_mutex);\n+\treturn _M_condvar.wait_for(__lock, __rtime,\n+\t\t\t\t   [&] { return _M_data == __val;});\n+      }\n \n     template<typename _Clock, typename _Duration>\n-    _GLIBCXX_ALWAYS_INLINE bool\n-    _M_load_when_equal_until(unsigned __val, memory_order __mo,\n-\tconst chrono::time_point<_Clock, _Duration>& __atime)\n-    {\n-      unique_lock<mutex> __lock(_M_mutex);\n-      return _M_condvar.wait_until(__lock, __atime,\n-\t\t\t\t   [&] { return _M_data == __val;});\n-    }\n+      _GLIBCXX_ALWAYS_INLINE bool\n+      _M_load_when_equal_until(unsigned __val, memory_order __mo,\n+\t  const chrono::time_point<_Clock, _Duration>& __atime)\n+      {\n+\tunique_lock<mutex> __lock(_M_mutex);\n+\treturn _M_condvar.wait_until(__lock, __atime,\n+\t\t\t\t     [&] { return _M_data == __val;});\n+      }\n \n     _GLIBCXX_ALWAYS_INLINE void\n     _M_store_notify_all(unsigned __val, memory_order __mo)\n@@ -278,10 +278,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_data = __val;\n       _M_condvar.notify_all();\n     }\n-\n   };\n \n-#endif // _GLIBCXX_HAVE_LINUX_FUTEX\n+#endif // _GLIBCXX_HAVE_LINUX_FUTEX && ATOMIC_INT_LOCK_FREE > 1\n #endif // _GLIBCXX_HAS_GTHREADS && _GLIBCXX_USE_C99_STDINT_TR1\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "f24b44e5a8f01b9115ce66974159fc8f76399fea", "filename": "libstdc++-v3/src/c++11/futex.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87361f3098d399531bc329b2ad71f6a530742567/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87361f3098d399531bc329b2ad71f6a530742567/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc?ref=87361f3098d399531bc329b2ad71f6a530742567", "patch": "@@ -23,7 +23,7 @@\n // <http://www.gnu.org/licenses/>.\n \n #include <bits/c++config.h>\n-#if defined(_GLIBCXX_HAVE_LINUX_FUTEX)\n+#if defined(_GLIBCXX_HAVE_LINUX_FUTEX) && ATOMIC_INT_LOCK_FREE > 1\n #include <bits/atomic_futex.h>\n #include <chrono>\n #include <climits>"}]}