{"sha": "ead1705900f4e5c6e06407208b928d83b4646320", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFkMTcwNTkwMGY0ZTVjNmUwNjQwNzIwOGI5MjhkODNiNDY0NjMyMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-05-18T13:21:14Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-05-18T13:21:14Z"}, "message": "tree.h (TYPE_SIZE_UNIT): New.\n\n* tree.h (TYPE_SIZE_UNIT): New.\n(struct tree_type): Add size_unit member.\n* stor-layout.c (layout_type): Initialize it.\n* expr.c (get_inner_reference) [ARRAY_REF]: Use it.\n* tree.c (size_in_bytes, int_size_in_bytes): Likewise.\n\nFrom-SVN: r19853", "tree": {"sha": "52f254790542ea9c24b53b11b490678708eeaa15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52f254790542ea9c24b53b11b490678708eeaa15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ead1705900f4e5c6e06407208b928d83b4646320", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ead1705900f4e5c6e06407208b928d83b4646320", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ead1705900f4e5c6e06407208b928d83b4646320", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ead1705900f4e5c6e06407208b928d83b4646320/comments", "author": null, "committer": null, "parents": [{"sha": "6d73fddc3f93058d8f3534a3b888779a134c484e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d73fddc3f93058d8f3534a3b888779a134c484e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d73fddc3f93058d8f3534a3b888779a134c484e"}], "stats": {"total": 109, "additions": 81, "deletions": 28}, "files": [{"sha": "5d298e8220132a459df80cee6e7f41d1b1e76811", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead1705900f4e5c6e06407208b928d83b4646320/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead1705900f4e5c6e06407208b928d83b4646320/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ead1705900f4e5c6e06407208b928d83b4646320", "patch": "@@ -1,3 +1,11 @@\n+Mon May 18 13:20:23 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* tree.h (TYPE_SIZE_UNIT): New.\n+\t(struct tree_type): Add size_unit member.\n+\t* stor-layout.c (layout_type): Initialize it.\n+\t* expr.c (get_inner_reference) [ARRAY_REF]: Use it.\n+\t* tree.c (size_in_bytes, int_size_in_bytes): Likewise.\n+\n Mon May 18 12:07:37 1998  Richard Earnshaw (rearnsha@arm.com)\n \n \t* stor-layout.c (layout_record): Fix off-by-one error when checking"}, {"sha": "f4e1d219bdcc688caab1e79a556b3662acd374d1", "filename": "gcc/expr.c", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead1705900f4e5c6e06407208b928d83b4646320/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead1705900f4e5c6e06407208b928d83b4646320/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ead1705900f4e5c6e06407208b928d83b4646320", "patch": "@@ -4374,6 +4374,7 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \t  tree low_bound\n \t    = domain ? TYPE_MIN_VALUE (domain) : integer_zero_node;\n \t  tree index_type = TREE_TYPE (index);\n+\t  tree xindex;\n \n \t  if (TYPE_PRECISION (index_type) != TYPE_PRECISION (sizetype))\n \t    {\n@@ -4391,21 +4392,27 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \t      index_type = TREE_TYPE (index);\n \t    }\n \n-\t  index = fold (build (MULT_EXPR, sbitsizetype, index,\n-\t\t\t       convert (sbitsizetype,\n-\t\t\t\t\tTYPE_SIZE (TREE_TYPE (exp)))));\n+\t  xindex = fold (build (MULT_EXPR, sbitsizetype, index,\n+\t\t\t        convert (sbitsizetype,\n+\t\t\t\t\t TYPE_SIZE (TREE_TYPE (exp)))));\n \n-\t  if (TREE_CODE (index) == INTEGER_CST\n-\t      && TREE_INT_CST_HIGH (index) == 0)\n-\t    *pbitpos += TREE_INT_CST_LOW (index);\n+\t  if (TREE_CODE (xindex) == INTEGER_CST\n+\t      && TREE_INT_CST_HIGH (xindex) == 0)\n+\t    *pbitpos += TREE_INT_CST_LOW (xindex);\n \t  else\n \t    {\n-\t      if (contains_placeholder_p (index))\n-\t\tindex = build (WITH_RECORD_EXPR, sizetype, index, exp);\n-\n-\t      offset = size_binop (PLUS_EXPR, offset,\n-\t\t\t\t   size_binop (FLOOR_DIV_EXPR, index,\n-\t\t\t\t\t       size_int (BITS_PER_UNIT)));\n+\t      /* Either the bit offset calculated above is not constant, or\n+\t\t it overflowed.  In either case, redo the multiplication\n+\t\t against the size in units.  This is especially important\n+\t\t in the non-constant case to avoid a division at runtime.  */\n+\t      xindex = fold (build (MULT_EXPR, ssizetype, index,\n+                                    convert (ssizetype,\n+                                         TYPE_SIZE_UNIT (TREE_TYPE (exp)))));\n+\n+\t      if (contains_placeholder_p (xindex))\n+\t\txindex = build (WITH_RECORD_EXPR, sizetype, xindex, exp);\n+\n+\t      offset = size_binop (PLUS_EXPR, offset, xindex);\n \t    }\n \t}\n       else if (TREE_CODE (exp) != NON_LVALUE_EXPR"}, {"sha": "77561c97b886b73746d6b15c2d4657d2a787909d", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead1705900f4e5c6e06407208b928d83b4646320/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead1705900f4e5c6e06407208b928d83b4646320/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=ead1705900f4e5c6e06407208b928d83b4646320", "patch": "@@ -720,11 +720,13 @@ layout_type (type)\n       TYPE_MODE (type) = smallest_mode_for_size (TYPE_PRECISION (type),\n \t\t\t\t\t\t MODE_INT);\n       TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)), 0L);\n+      TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n       break;\n \n     case REAL_TYPE:\n       TYPE_MODE (type) = mode_for_size (TYPE_PRECISION (type), MODE_FLOAT, 0);\n       TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)), 0L);\n+      TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n       break;\n \n     case COMPLEX_TYPE:\n@@ -735,29 +737,34 @@ layout_type (type)\n \t\t\t  ? MODE_COMPLEX_INT : MODE_COMPLEX_FLOAT),\n \t\t\t 0);\n       TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)), 0L);\n+      TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n       break;\n \n     case VOID_TYPE:\n       TYPE_SIZE (type) = size_zero_node;\n+      TYPE_SIZE_UNIT (type) = size_zero_node;\n       TYPE_ALIGN (type) = 1;\n       TYPE_MODE (type) = VOIDmode;\n       break;\n \n     case OFFSET_TYPE:\n       TYPE_SIZE (type) = bitsize_int (POINTER_SIZE, 0L);\n+      TYPE_SIZE_UNIT (type) = size_int (POINTER_SIZE / BITS_PER_UNIT);\n       TYPE_MODE (type) = ptr_mode;\n       break;\n \n     case FUNCTION_TYPE:\n     case METHOD_TYPE:\n       TYPE_MODE (type) = mode_for_size (2 * POINTER_SIZE, MODE_INT, 0);\n-      TYPE_SIZE (type) = size_int (2 * POINTER_SIZE);\n+      TYPE_SIZE (type) = bitsize_int (2 * POINTER_SIZE, 0);\n+      TYPE_SIZE_UNIT (type) = size_int ((2 * POINTER_SIZE) / BITS_PER_UNIT);\n       break;\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n       TYPE_MODE (type) = ptr_mode;\n       TYPE_SIZE (type) = bitsize_int (POINTER_SIZE, 0L);\n+      TYPE_SIZE_UNIT (type) = size_int (POINTER_SIZE / BITS_PER_UNIT);\n       TREE_UNSIGNED (type) = 1;\n       TYPE_PRECISION (type) = POINTER_SIZE;\n       break;\n@@ -810,6 +817,17 @@ layout_type (type)\n \n \t    TYPE_SIZE (type) = size_binop (MULT_EXPR, TYPE_SIZE (element),\n \t\t\t\t\t   length);\n+\n+\t    /* If we know the size of the element, calculate the total\n+\t       size directly, rather than do some division thing below.\n+\t       This optimization helps Fortran assumed-size arrays\n+\t       (where the size of the array is determined at runtime)\n+\t       substantially.  */\n+\t    if (TYPE_SIZE_UNIT (element) != 0)\n+\t      {\n+\t        TYPE_SIZE_UNIT (type)\n+\t\t  = size_binop (MULT_EXPR, TYPE_SIZE_UNIT (element), length);\n+\t      }\n \t  }\n \n \t/* Now round the alignment and size,\n@@ -824,8 +842,15 @@ layout_type (type)\n \n #ifdef ROUND_TYPE_SIZE\n \tif (TYPE_SIZE (type) != 0)\n-\t  TYPE_SIZE (type)\n-\t    = ROUND_TYPE_SIZE (type, TYPE_SIZE (type), TYPE_ALIGN (type));\n+\t  {\n+\t    tree tmp;\n+\t    tmp = ROUND_TYPE_SIZE (type, TYPE_SIZE (type), TYPE_ALIGN (type));\n+\t    /* If the rounding changed the size of the type, remove any\n+\t       pre-calculated TYPE_SIZE_UNIT.  */\n+\t    if (simple_cst_equal (TYPE_SIZE (type), tmp) != 1)\n+\t      TYPE_SIZE_UNIT (type) = NULL;\n+\t    TYPE_SIZE (type) = tmp;\n+\t  }\n #endif\n \n \tTYPE_MODE (type) = BLKmode;\n@@ -983,6 +1008,7 @@ layout_type (type)\n \t  else\n \t    TYPE_MODE (type) = mode_for_size (alignment, MODE_INT, 1);\n \t  TYPE_SIZE (type) = bitsize_int (rounded_size, 0L);\n+\t  TYPE_SIZE_UNIT (type) = size_int (rounded_size / BITS_PER_UNIT);\n \t  TYPE_ALIGN (type) = alignment;\n \t  TYPE_PRECISION (type) = size_in_bits;\n \t}\n@@ -1015,13 +1041,27 @@ layout_type (type)\n   if (TYPE_SIZE (type) != 0 && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n     TYPE_SIZE (type) = variable_size (TYPE_SIZE (type));\n \n+  /* If we failed to find a simple way to calculate the unit size\n+     of the type above, find it by division.  */\n+  if (TYPE_SIZE_UNIT (type) == 0 && TYPE_SIZE (type) != 0)\n+    {\n+      TYPE_SIZE_UNIT (type) = size_binop (FLOOR_DIV_EXPR, TYPE_SIZE (type),\n+\t\t\t\t          size_int (BITS_PER_UNIT));\n+    }\n+\n+  /* Once again evaluate only once, either now or as soon as safe.  */\n+  if (TYPE_SIZE_UNIT (type) != 0\n+      && TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST)\n+    TYPE_SIZE_UNIT (type) = variable_size (TYPE_SIZE_UNIT (type));\n+\n   /* Also layout any other variants of the type.  */\n   if (TYPE_NEXT_VARIANT (type)\n       || type != TYPE_MAIN_VARIANT (type))\n     {\n       tree variant;\n       /* Record layout info of this variant.  */\n       tree size = TYPE_SIZE (type);\n+      tree size_unit = TYPE_SIZE_UNIT (type);\n       int align = TYPE_ALIGN (type);\n       enum machine_mode mode = TYPE_MODE (type);\n \n@@ -1031,6 +1071,7 @@ layout_type (type)\n \t   variant = TYPE_NEXT_VARIANT (variant))\n \t{\n \t  TYPE_SIZE (variant) = size;\n+\t  TYPE_SIZE_UNIT (variant) = size_unit;\n \t  TYPE_ALIGN (variant) = align;\n \t  TYPE_MODE (variant) = mode;\n \t}"}, {"sha": "04bf8a31871a6d9286fc496f60c6646f33054590", "filename": "gcc/tree.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead1705900f4e5c6e06407208b928d83b4646320/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead1705900f4e5c6e06407208b928d83b4646320/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ead1705900f4e5c6e06407208b928d83b4646320", "patch": "@@ -2162,16 +2162,17 @@ size_in_bytes (type)\n \n   if (type == error_mark_node)\n     return integer_zero_node;\n+\n   type = TYPE_MAIN_VARIANT (type);\n-  if (TYPE_SIZE (type) == 0)\n+  t = TYPE_SIZE_UNIT (type);\n+  if (t == 0)\n     {\n       incomplete_type_error (NULL_TREE, type);\n       return integer_zero_node;\n     }\n-  t = size_binop (CEIL_DIV_EXPR, TYPE_SIZE (type),\n-\t\t  size_int (BITS_PER_UNIT));\n   if (TREE_CODE (t) == INTEGER_CST)\n     force_fit_type (t, 0);\n+\n   return t;\n }\n \n@@ -2188,16 +2189,10 @@ int_size_in_bytes (type)\n     return 0;\n \n   type = TYPE_MAIN_VARIANT (type);\n-  if (TYPE_SIZE (type) == 0\n-      || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n-    return -1;\n-\n-  if (TREE_INT_CST_HIGH (TYPE_SIZE (type)) == 0)\n-    return ((TREE_INT_CST_LOW (TYPE_SIZE (type)) + BITS_PER_UNIT - 1)\n-\t  / BITS_PER_UNIT);\n-\n-  t = size_binop (CEIL_DIV_EXPR, TYPE_SIZE (type), size_int (BITS_PER_UNIT));\n-  if (TREE_CODE (t) != INTEGER_CST || TREE_INT_CST_HIGH (t) != 0)\n+  t = TYPE_SIZE_UNIT (type);\n+  if (t == 0\n+      || TREE_CODE (t) != INTEGER_CST\n+      || TREE_INT_CST_HIGH (t) != 0)\n     return -1;\n \n   return TREE_INT_CST_LOW (t);"}, {"sha": "00bd4caa6b6f08992a108f5060a6af2bfdaee1cb", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead1705900f4e5c6e06407208b928d83b4646320/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead1705900f4e5c6e06407208b928d83b4646320/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ead1705900f4e5c6e06407208b928d83b4646320", "patch": "@@ -714,6 +714,7 @@ struct tree_block\n \n #define TYPE_UID(NODE) ((NODE)->type.uid)\n #define TYPE_SIZE(NODE) ((NODE)->type.size)\n+#define TYPE_SIZE_UNIT(NODE) ((NODE)->type.size_unit)\n #define TYPE_MODE(NODE) ((NODE)->type.mode)\n #define TYPE_VALUES(NODE) ((NODE)->type.values)\n #define TYPE_DOMAIN(NODE) ((NODE)->type.values)\n@@ -795,6 +796,7 @@ struct tree_type\n   char common[sizeof (struct tree_common)];\n   union tree_node *values;\n   union tree_node *size;\n+  union tree_node *size_unit;\n   union tree_node *attributes;\n   unsigned uid;\n "}]}