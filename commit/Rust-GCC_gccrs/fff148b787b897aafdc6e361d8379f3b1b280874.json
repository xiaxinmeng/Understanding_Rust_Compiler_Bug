{"sha": "fff148b787b897aafdc6e361d8379f3b1b280874", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZmMTQ4Yjc4N2I4OTdhYWZkYzZlMzYxZDgzNzlmM2IxYjI4MDg3NA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-01-08T16:44:45Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2020-01-08T16:44:45Z"}, "message": "libstdc++: Fix error handling in filesystem::remove_all (PR93201)\n\nWhen recursing into a directory, any errors that occur while removing a\ndirectory entry are ignored, because the subsequent increment of the\ndirectory iterator clears the error_code object.\n\nThis fixes that bug by checking the result of each recursive operation\nbefore incrementing. This is a change in observable behaviour, because\npreviously other directory entries would still be removed even if one\n(or more) couldn't be removed due to errors. Now the operation stops on\nthe first error, which is what the code intended to do all along. The\nstandard doesn't specify what happens in this case (because the order\nthat the entries are processed is unspecified anyway).\n\nIt also improves the error reporting so that the name of the file that\ncould not be removed is included in the filesystem_error exception. This\nis done by introducing a new helper type for reporting errors with\nadditional context and a new function that uses that type. Then the\noverload of std::filesystem::remove_all that throws an exception can use\nthe new function to ensure any exception contains the additional\ninformation.\n\nFor std::experimental::filesystem::remove_all just fix the bug where\nerrors are ignored.\n\n\tPR libstdc++/93201\n\t* src/c++17/fs_ops.cc (do_remove_all): New function implementing more\n\tdetailed error reporting for remove_all. Check result of recursive\n\tcall before incrementing iterator.\n\t(remove_all(const path&), remove_all(const path&, error_code&)): Use\n\tdo_remove_all.\n\t* src/filesystem/ops.cc (remove_all(const path&, error_code&)): Check\n\tresult of recursive call before incrementing iterator.\n\t* testsuite/27_io/filesystem/operations/remove_all.cc: Check errors\n\tare reported correctly.\n\t* testsuite/experimental/filesystem/operations/remove_all.cc: Likewise.\n\nFrom-SVN: r280014", "tree": {"sha": "329c98ae97dc6e2d48a0fefca9e2969966dce036", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/329c98ae97dc6e2d48a0fefca9e2969966dce036"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fff148b787b897aafdc6e361d8379f3b1b280874", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fff148b787b897aafdc6e361d8379f3b1b280874", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fff148b787b897aafdc6e361d8379f3b1b280874", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fff148b787b897aafdc6e361d8379f3b1b280874/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "face749a49c35ebe5732e7a526680b454d7e6cb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/face749a49c35ebe5732e7a526680b454d7e6cb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/face749a49c35ebe5732e7a526680b454d7e6cb5"}], "stats": {"total": 214, "additions": 182, "deletions": 32}, "files": [{"sha": "459759850d4c068c123f21184842988788f0baf2", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff148b787b897aafdc6e361d8379f3b1b280874/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff148b787b897aafdc6e361d8379f3b1b280874/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=fff148b787b897aafdc6e361d8379f3b1b280874", "patch": "@@ -1,3 +1,17 @@\n+2020-01-08  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/93201\n+\t* src/c++17/fs_ops.cc (do_remove_all): New function implementing more\n+\tdetailed error reporting for remove_all. Check result of recursive\n+\tcall before incrementing iterator.\n+\t(remove_all(const path&), remove_all(const path&, error_code&)): Use\n+\tdo_remove_all.\n+\t* src/filesystem/ops.cc (remove_all(const path&, error_code&)): Check\n+\tresult of recursive call before incrementing iterator.\n+\t* testsuite/27_io/filesystem/operations/remove_all.cc: Check errors\n+\tare reported correctly.\n+\t* testsuite/experimental/filesystem/operations/remove_all.cc: Likewise.\n+\n 2020-01-07  Thomas Rodgers  <trodgers@redhat.com>\n \n \t* include/std/condition_variable"}, {"sha": "873f93aacfc4cf5eebd3ec02df3cd0d113a0ad1a", "filename": "libstdc++-v3/src/c++17/fs_ops.cc", "status": "modified", "additions": 89, "deletions": 26, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff148b787b897aafdc6e361d8379f3b1b280874/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_ops.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff148b787b897aafdc6e361d8379f3b1b280874/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_ops.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_ops.cc?ref=fff148b787b897aafdc6e361d8379f3b1b280874", "patch": "@@ -1275,42 +1275,105 @@ fs::remove(const path& p, error_code& ec) noexcept\n   return false;\n }\n \n+namespace std::filesystem\n+{\n+namespace\n+{\n+  struct ErrorReporter\n+  {\n+    explicit\n+    ErrorReporter(error_code& ec) : code(&ec)\n+    { }\n+\n+    explicit\n+    ErrorReporter(const char* s, const path& p)\n+    : code(nullptr), msg(s), path1(&p)\n+    { }\n+\n+    error_code* code;\n+    const char* msg;\n+    const path* path1;\n+\n+    void\n+    report(const error_code& ec) const\n+    {\n+      if (code)\n+\t*code = ec;\n+      else\n+\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(msg, *path1, ec));\n+    }\n+\n+    void\n+    report(const error_code& ec, const path& path2) const\n+    {\n+      if (code)\n+\t*code = ec;\n+      else if (path2 != *path1)\n+\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(msg, *path1, path2, ec));\n+      else\n+\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(msg, *path1, ec));\n+    }\n+  };\n+\n+  uintmax_t\n+  do_remove_all(const path& p, const ErrorReporter& err)\n+  {\n+    error_code ec;\n+    const auto s = symlink_status(p, ec);\n+    if (!status_known(s))\n+      {\n+\tif (ec)\n+\t  err.report(ec, p);\n+\treturn -1;\n+      }\n+\n+    ec.clear();\n+    if (s.type() == file_type::not_found)\n+      return 0;\n+\n+    uintmax_t count = 0;\n+    if (s.type() == file_type::directory)\n+      {\n+\tdirectory_iterator d(p, ec), end;\n+\twhile (d != end)\n+\t  {\n+\t    const auto removed = fs::do_remove_all(d->path(), err);\n+\t    if (removed == numeric_limits<uintmax_t>::max())\n+\t      return -1;\n+\t    count += removed;\n+\n+\t    d.increment(ec);\n+\t    if (ec)\n+\t      {\n+\t\terr.report(ec, p);\n+\t\treturn -1;\n+\t      }\n+\t  }\n+      }\n+\n+    if (fs::remove(p, ec))\n+      ++count;\n+    if (ec)\n+      {\n+\terr.report(ec, p);\n+\treturn -1;\n+      }\n+    return count;\n+  }\n+}\n+}\n \n std::uintmax_t\n fs::remove_all(const path& p)\n {\n-  error_code ec;\n-  const auto result = remove_all(p, ec);\n-  if (ec)\n-    _GLIBCXX_THROW_OR_ABORT(filesystem_error(\"cannot remove all\", p, ec));\n-  return result;\n+  return fs::do_remove_all(p, ErrorReporter{\"cannot remove all\", p});\n }\n \n std::uintmax_t\n fs::remove_all(const path& p, error_code& ec)\n {\n-  const auto s = symlink_status(p, ec);\n-  if (!status_known(s))\n-    return -1;\n-\n   ec.clear();\n-  if (s.type() == file_type::not_found)\n-    return 0;\n-\n-  uintmax_t count = 0;\n-  if (s.type() == file_type::directory)\n-    {\n-      for (directory_iterator d(p, ec), end; !ec && d != end; d.increment(ec))\n-\tcount += fs::remove_all(d->path(), ec);\n-      if (ec.value() == ENOENT)\n-\tec.clear();\n-      else if (ec)\n-\treturn -1;\n-    }\n-\n-  if (fs::remove(p, ec))\n-    ++count;\n-  return ec ? -1 : count;\n+  return fs::do_remove_all(p, ErrorReporter{ec});\n }\n \n void"}, {"sha": "29ea9c0ce87536655bf66d614f7552d50982cd4a", "filename": "libstdc++-v3/src/filesystem/ops.cc", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff148b787b897aafdc6e361d8379f3b1b280874/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff148b787b897aafdc6e361d8379f3b1b280874/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fops.cc?ref=fff148b787b897aafdc6e361d8379f3b1b280874", "patch": "@@ -1099,12 +1099,17 @@ fs::remove_all(const path& p, error_code& ec) noexcept\n   uintmax_t count = 0;\n   if (s.type() == file_type::directory)\n     {\n-      for (directory_iterator d(p, ec), end; !ec && d != end; d.increment(ec))\n-\tcount += fs::remove_all(d->path(), ec);\n-      if (ec.value() == ENOENT)\n-\tec.clear();\n-      else if (ec)\n-\treturn -1;\n+      directory_iterator d(p, ec), end;\n+      while (!ec && d != end)\n+\t{\n+\t  const auto removed = fs::remove_all(d->path(), ec);\n+\t  if (removed == numeric_limits<uintmax_t>::max())\n+\t    return -1;\n+\t  count += removed;\n+\t  d.increment(ec);\n+\t  if (ec)\n+\t    return -1;\n+\t}\n     }\n \n   if (fs::remove(p, ec))"}, {"sha": "7e018b51af26bbeade592f0be5b5390a999de10c", "filename": "libstdc++-v3/testsuite/27_io/filesystem/operations/remove_all.cc", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff148b787b897aafdc6e361d8379f3b1b280874/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fremove_all.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff148b787b897aafdc6e361d8379f3b1b280874/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fremove_all.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Foperations%2Fremove_all.cc?ref=fff148b787b897aafdc6e361d8379f3b1b280874", "patch": "@@ -140,10 +140,45 @@ test03()\n   VERIFY( !exists(p) );\n }\n \n+void\n+test04()\n+{\n+#if defined(__MINGW32__) || defined(__MINGW64__)\n+  // no permissions\n+#else\n+  // PR libstdc++/93201\n+  std::error_code ec;\n+  std::uintmax_t n;\n+\n+  auto dir = __gnu_test::nonexistent_path();\n+  fs::create_directory(dir);\n+  __gnu_test::scoped_file f(dir/\"file\");\n+  // remove write permission on the directory:\n+  fs::permissions(dir, fs::perms::owner_read|fs::perms::owner_exec);\n+  n = fs::remove_all(dir, ec);\n+  VERIFY( n == -1 );\n+  VERIFY( ec == std::errc::permission_denied ); // not ENOTEMPTY\n+\n+  try {\n+    fs::remove_all(dir);\n+    VERIFY( false );\n+  } catch (const fs::filesystem_error& e) {\n+    VERIFY( e.code() == std::errc::permission_denied );\n+    // First path is the argument to remove_all\n+    VERIFY( e.path1() == dir );\n+    // Second path is the first file that couldn't be removed\n+    VERIFY( e.path2() == dir/\"file\" );\n+  }\n+\n+  fs::permissions(dir, fs::perms::owner_write, fs::perm_options::add);\n+#endif\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n   test03();\n+  test04();\n }"}, {"sha": "0e2aedae96dbb75fd444a9dfe82bc6fe19c9110d", "filename": "libstdc++-v3/testsuite/experimental/filesystem/operations/remove_all.cc", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff148b787b897aafdc6e361d8379f3b1b280874/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fremove_all.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff148b787b897aafdc6e361d8379f3b1b280874/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fremove_all.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Foperations%2Fremove_all.cc?ref=fff148b787b897aafdc6e361d8379f3b1b280874", "patch": "@@ -108,9 +108,42 @@ test02()\n   VERIFY( !exists(dir) );\n }\n \n+void\n+test04()\n+{\n+#if defined(__MINGW32__) || defined(__MINGW64__)\n+  // no permissions\n+#else\n+  // PR libstdc++/93201\n+  std::error_code ec;\n+  std::uintmax_t n;\n+\n+  auto dir = __gnu_test::nonexistent_path();\n+  fs::create_directory(dir);\n+  __gnu_test::scoped_file f(dir/\"file\");\n+  // remove write permission on the directory:\n+  fs::permissions(dir, fs::perms::owner_read|fs::perms::owner_exec);\n+  n = fs::remove_all(dir, ec);\n+  VERIFY( n == -1 );\n+  VERIFY( ec == std::errc::permission_denied ); // not ENOTEMPTY\n+\n+  try {\n+    fs::remove_all(dir);\n+    VERIFY( false );\n+  } catch (const fs::filesystem_error& e) {\n+    VERIFY( e.code() == std::errc::permission_denied );\n+    // First path is the argument to remove_all\n+    VERIFY( e.path1() == dir );\n+  }\n+\n+  fs::permissions(dir, fs::perms::owner_write|fs::perms::add_perms);\n+#endif\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n+  test04();\n }"}]}