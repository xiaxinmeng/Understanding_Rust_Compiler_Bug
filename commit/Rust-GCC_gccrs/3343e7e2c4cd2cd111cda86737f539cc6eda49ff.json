{"sha": "3343e7e2c4cd2cd111cda86737f539cc6eda49ff", "node_id": "C_kwDOANBUbNoAKDMzNDNlN2UyYzRjZDJjZDExMWNkYTg2NzM3ZjUzOWNjNmVkYTQ5ZmY", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-02-18T23:04:00Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-02-18T23:33:32Z"}, "message": "libgo: update Hurd support\n\nPatches from Svante Signell for PR go/104290.\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/386797", "tree": {"sha": "2ba797308a8520d31e076d6214e995b89d83718a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ba797308a8520d31e076d6214e995b89d83718a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3343e7e2c4cd2cd111cda86737f539cc6eda49ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3343e7e2c4cd2cd111cda86737f539cc6eda49ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3343e7e2c4cd2cd111cda86737f539cc6eda49ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4984f882f41be1472df6ce7c439c98c4bc4e6f08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4984f882f41be1472df6ce7c439c98c4bc4e6f08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4984f882f41be1472df6ce7c439c98c4bc4e6f08"}], "stats": {"total": 308, "additions": 298, "deletions": 10}, "files": [{"sha": "3c0380e8285f0cd1fcd8919598f8556664b926d4", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=3343e7e2c4cd2cd111cda86737f539cc6eda49ff", "patch": "@@ -1,4 +1,4 @@\n-fade776395ffe5497d8aae5c0e6bd6d15e09e04a\n+20e74f9ef8206fb02fd28ce3d6e0f01f6fb95dc9\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "19112076a3cafa9ca27d78a798ec29f48ba1b4ab", "filename": "libgo/go/internal/testenv/testenv_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/libgo%2Fgo%2Finternal%2Ftestenv%2Ftestenv_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/libgo%2Fgo%2Finternal%2Ftestenv%2Ftestenv_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Ftestenv%2Ftestenv_unix.go?ref=3343e7e2c4cd2cd111cda86737f539cc6eda49ff", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-//go:build aix || darwin || dragonfly || freebsd || linux || netbsd || openbsd || solaris\n+//go:build aix || darwin || dragonfly || freebsd || hurd || linux || netbsd || openbsd || solaris\n \n package testenv\n "}, {"sha": "fca328fc65bd5d9052b0b7a879f7979de11a1301", "filename": "libgo/go/os/exec/internal/fdtest/exists_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/libgo%2Fgo%2Fos%2Fexec%2Finternal%2Ffdtest%2Fexists_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/libgo%2Fgo%2Fos%2Fexec%2Finternal%2Ffdtest%2Fexists_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Finternal%2Ffdtest%2Fexists_unix.go?ref=3343e7e2c4cd2cd111cda86737f539cc6eda49ff", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-//go:build aix || darwin || dragonfly || freebsd || linux || netbsd || openbsd || solaris\n+//go:build aix || darwin || dragonfly || freebsd || hurd || linux || netbsd || openbsd || solaris\n \n // Package fdtest provides test helpers for working with file descriptors across exec.\n package fdtest"}, {"sha": "09ec1cc5d2a4d01b63810c2229d7b87698b1a3df", "filename": "libgo/go/os/user/cgo_listgroups_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/libgo%2Fgo%2Fos%2Fuser%2Fcgo_listgroups_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/libgo%2Fgo%2Fos%2Fuser%2Fcgo_listgroups_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Fcgo_listgroups_unix.go?ref=3343e7e2c4cd2cd111cda86737f539cc6eda49ff", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-//go:build (dragonfly || darwin || freebsd || (!android && linux) || netbsd || openbsd || (solaris && !illumos)) && cgo && !osusergo\n+//go:build (dragonfly || darwin || freebsd || hurd || (!android && linux) || netbsd || openbsd || (solaris && !illumos)) && cgo && !osusergo\n \n package user\n "}, {"sha": "e97e0bc64f608e67c4f3f0660493b1cfc48068c9", "filename": "libgo/go/os/user/getgrouplist_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/libgo%2Fgo%2Fos%2Fuser%2Fgetgrouplist_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/libgo%2Fgo%2Fos%2Fuser%2Fgetgrouplist_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Fgetgrouplist_unix.go?ref=3343e7e2c4cd2cd111cda86737f539cc6eda49ff", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-//go:build (dragonfly || freebsd || (!android && linux) || netbsd || openbsd || (solaris && !illumos)) && cgo && !osusergo\n+//go:build (dragonfly || freebsd || hurd || (!android && linux) || netbsd || openbsd || (solaris && !illumos)) && cgo && !osusergo\n \n package user\n "}, {"sha": "96b013845fac40a6398fe7f2ecfb8b8b8199771e", "filename": "libgo/go/runtime/netpoll_hurd.go", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/libgo%2Fgo%2Fruntime%2Fnetpoll_hurd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/libgo%2Fgo%2Fruntime%2Fnetpoll_hurd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll_hurd.go?ref=3343e7e2c4cd2cd111cda86737f539cc6eda49ff", "patch": "@@ -238,10 +238,7 @@ retry:\n \t\t\tpfd.events &= ^_POLLOUT\n \t\t}\n \t\tif mode != 0 {\n-\t\t\tpds[i].everr = false\n-\t\t\tif pfd.revents == _POLLERR {\n-\t\t\t\tpds[i].everr = true\n-\t\t\t}\n+\t\t\tpds[i].setEventErr(pfd.revents == _POLLERR)\n \t\t\tnetpollready(&toRun, pds[i], mode)\n \t\t\tn--\n \t\t}"}, {"sha": "9750a4822cfafac2c14294e7874ca670f976eebf", "filename": "libgo/go/runtime/os_hurd.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/libgo%2Fgo%2Fruntime%2Fos_hurd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/libgo%2Fgo%2Fruntime%2Fos_hurd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_hurd.go?ref=3343e7e2c4cd2cd111cda86737f539cc6eda49ff", "patch": "@@ -129,3 +129,16 @@ func osinit() {\n \t\tphysPageSize = uintptr(getPageSize())\n \t}\n }\n+\n+func setProcessCPUProfiler(hz int32) {\n+\tsetProcessCPUProfilerTimer(hz)\n+}\n+\n+func setThreadCPUProfiler(hz int32) {\n+\tsetThreadCPUProfilerHz(hz)\n+}\n+\n+//go:nosplit\n+func validSIGPROF(mp *m, c *sigctxt) bool {\n+\treturn true\n+}"}, {"sha": "86e513efdea86b530d5324ae9e098425aa06f143", "filename": "libgo/go/syscall/exec_bsd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/libgo%2Fgo%2Fsyscall%2Fexec_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/libgo%2Fgo%2Fsyscall%2Fexec_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_bsd.go?ref=3343e7e2c4cd2cd111cda86737f539cc6eda49ff", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-//go:build aix || darwin || dragonfly || hurd || netbsd || openbsd || solaris\n+//go:build aix || darwin || dragonfly || netbsd || openbsd || solaris\n \n package syscall\n "}, {"sha": "06df513c55cb0056b54327bde18da4f2659edc26", "filename": "libgo/go/syscall/exec_hurd.go", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/libgo%2Fgo%2Fsyscall%2Fexec_hurd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3343e7e2c4cd2cd111cda86737f539cc6eda49ff/libgo%2Fgo%2Fsyscall%2Fexec_hurd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_hurd.go?ref=3343e7e2c4cd2cd111cda86737f539cc6eda49ff", "patch": "@@ -0,0 +1,278 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+//go:build hurd\n+\n+package syscall\n+\n+import (\n+\t\"runtime\"\n+\t\"unsafe\"\n+)\n+\n+type SysProcAttr struct {\n+\tChroot     string      // Chroot.\n+\tCredential *Credential // Credential.\n+\tPtrace     bool        // Enable tracing.\n+\tSetsid     bool        // Create session.\n+\t// Setpgid sets the process group ID of the child to Pgid,\n+\t// or, if Pgid == 0, to the new child's process ID.\n+\tSetpgid bool\n+\t// Setctty sets the controlling terminal of the child to\n+\t// file descriptor Ctty. Ctty must be a descriptor number\n+\t// in the child process: an index into ProcAttr.Files.\n+\t// This is only meaningful if Setsid is true.\n+\tSetctty bool\n+\tNoctty  bool // Detach fd 0 from controlling terminal\n+\tCtty    int  // Controlling TTY fd\n+\t// Foreground places the child process group in the foreground.\n+\t// This implies Setpgid. The Ctty field must be set to\n+\t// the descriptor of the controlling TTY.\n+\t// Unlike Setctty, in this case Ctty must be a descriptor\n+\t// number in the parent process.\n+\tForeground bool\n+\tPgid       int // Child's process group ID if Setpgid.\n+}\n+\n+// Implemented in runtime package.\n+func runtime_BeforeFork()\n+func runtime_AfterFork()\n+func runtime_AfterForkInChild()\n+\n+// Fork, dup fd onto 0..len(fd), and exec(argv0, argvv, envv) in child.\n+// If a dup or exec fails, write the errno error to pipe.\n+// (Pipe is close-on-exec so if exec succeeds, it will be closed.)\n+// In the child, this function must not acquire any locks, because\n+// they might have been locked at the time of the fork. This means\n+// no rescheduling, no malloc calls, and no new stack segments.\n+// For the same reason compiler does not race instrument it.\n+// The calls to RawSyscall are okay because they are assembly\n+// functions that do not grow the stack.\n+//go:norace\n+func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr *ProcAttr, sys *SysProcAttr, pipe int) (pid int, err Errno) {\n+\t// Declare all variables at top in case any\n+\t// declarations require heap allocation (e.g., err1).\n+\tvar (\n+\t\tr1     Pid_t\n+\t\terr1   Errno\n+\t\tnextfd int\n+\t\ti      int\n+\t)\n+\n+\t// guard against side effects of shuffling fds below.\n+\t// Make sure that nextfd is beyond any currently open files so\n+\t// that we can't run the risk of overwriting any of them.\n+\tfd := make([]int, len(attr.Files))\n+\tnextfd = len(attr.Files)\n+\tfor i, ufd := range attr.Files {\n+\t\tif nextfd < int(ufd) {\n+\t\t\tnextfd = int(ufd)\n+\t\t}\n+\t\tfd[i] = int(ufd)\n+\t}\n+\tnextfd++\n+\n+\t// About to call fork.\n+\t// No more allocation or calls of non-assembly functions.\n+\truntime_BeforeFork()\n+\tr1, err1 = raw_fork()\n+\tif err1 != 0 {\n+\t\truntime_AfterFork()\n+\t\treturn 0, err1\n+\t}\n+\n+\tif r1 != 0 {\n+\t\t// parent; return PID\n+\t\truntime_AfterFork()\n+\t\treturn int(r1), 0\n+\t}\n+\n+\t// Fork succeeded, now in child.\n+\n+\t// Enable tracing if requested.\n+\tif sys.Ptrace {\n+\t\terr1 = raw_ptrace(_PTRACE_TRACEME, 0, 0, 0)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Session ID\n+\tif sys.Setsid {\n+\t\terr1 = raw_setsid()\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Set process group\n+\tif sys.Setpgid || sys.Foreground {\n+\t\t// Place child in process group.\n+\t\terr1 = raw_setpgid(0, sys.Pgid)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\tif sys.Foreground {\n+\t\tpgrp := Pid_t(sys.Pgid)\n+\t\tif pgrp == 0 {\n+\t\t\tpgrp = raw_getpid()\n+\t\t}\n+\n+\t\t// Place process group in foreground.\n+\t\t_, err1 = raw_ioctl_ptr(sys.Ctty, TIOCSPGRP, unsafe.Pointer(&pgrp))\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Restore the signal mask. We do this after TIOCSPGRP to avoid\n+\t// having the kernel send a SIGTTOU signal to the process group.\n+\truntime_AfterForkInChild()\n+\n+\t// Chroot\n+\tif chroot != nil {\n+\t\terr1 = raw_chroot(chroot)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// User and groups\n+\tif cred := sys.Credential; cred != nil {\n+\t\tngroups := len(cred.Groups)\n+\t\tvar groups unsafe.Pointer\n+\t\tif ngroups > 0 {\n+\t\t\tgroups = unsafe.Pointer(&cred.Groups[0])\n+\t\t}\n+\t\tif !cred.NoSetGroups {\n+\t\t\terr1 = raw_setgroups(ngroups, groups)\n+\t\t\tif err1 != 0 {\n+\t\t\t\tgoto childerror\n+\t\t\t}\n+\t\t}\n+\t\terr2 := Setgid(int(cred.Gid))\n+\t\tif err2 != nil {\n+\t\t\terr1 = err2.(Errno)\n+\t\t\tgoto childerror\n+\t\t}\n+\t\terr2 = Setuid(int(cred.Uid))\n+\t\tif err2 != nil {\n+\t\t\terr1 = err2.(Errno)\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Chdir\n+\tif dir != nil {\n+\t\terr1 = raw_chdir(dir)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Pass 1: look for fd[i] < i and move those up above len(fd)\n+\t// so that pass 2 won't stomp on an fd it needs later.\n+\tif pipe < nextfd {\n+\t\tswitch runtime.GOOS {\n+\t\tcase \"netbsd\":\n+\t\t\terr1 = raw_dup3(pipe, nextfd, O_CLOEXEC)\n+\t\t\tif err1 != 0 {\n+\t\t\t\tgoto childerror\n+\t\t\t}\n+\t\tdefault:\n+\t\t\terr1 = raw_dup2(pipe, nextfd)\n+\t\t\tif err1 != 0 {\n+\t\t\t\tgoto childerror\n+\t\t\t}\n+\t\t\traw_fcntl(nextfd, F_SETFD, FD_CLOEXEC)\n+\t\t}\n+\t\tpipe = nextfd\n+\t\tnextfd++\n+\t}\n+\tfor i = 0; i < len(fd); i++ {\n+\t\tif fd[i] >= 0 && fd[i] < int(i) {\n+\t\t\tif nextfd == pipe { // don't stomp on pipe\n+\t\t\t\tnextfd++\n+\t\t\t}\n+\t\t\tswitch runtime.GOOS {\n+\t\t\tcase \"netbsd\":\n+\t\t\t\terr1 = raw_dup3(fd[i], nextfd, O_CLOEXEC)\n+\t\t\t\tif err1 != 0 {\n+\t\t\t\t\tgoto childerror\n+\t\t\t\t}\n+\t\t\tdefault:\n+\t\t\t\terr1 = raw_dup2(fd[i], nextfd)\n+\t\t\t\tif err1 != 0 {\n+\t\t\t\t\tgoto childerror\n+\t\t\t\t}\n+\t\t\t\traw_fcntl(nextfd, F_SETFD, FD_CLOEXEC)\n+\t\t\t}\n+\t\t\tfd[i] = nextfd\n+\t\t\tnextfd++\n+\t\t}\n+\t}\n+\n+\t// Pass 2: dup fd[i] down onto i.\n+\tfor i = 0; i < len(fd); i++ {\n+\t\tif fd[i] == -1 {\n+\t\t\traw_close(i)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif fd[i] == int(i) {\n+\t\t\t// dup2(i, i) won't clear close-on-exec flag on Linux,\n+\t\t\t// probably not elsewhere either.\n+\t\t\t_, err1 = raw_fcntl(fd[i], F_SETFD, 0)\n+\t\t\tif err1 != 0 {\n+\t\t\t\tgoto childerror\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\t// The new fd is created NOT close-on-exec,\n+\t\t// which is exactly what we want.\n+\t\terr1 = raw_dup2(fd[i], i)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// By convention, we don't close-on-exec the fds we are\n+\t// started with, so if len(fd) < 3, close 0, 1, 2 as needed.\n+\t// Programs that know they inherit fds >= 3 will need\n+\t// to set them close-on-exec.\n+\tfor i = len(fd); i < 3; i++ {\n+\t\traw_close(i)\n+\t}\n+\n+\t// Detach fd 0 from tty\n+\tif sys.Noctty {\n+\t\t_, err1 = raw_ioctl(0, TIOCNOTTY, 0)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Set the controlling TTY to Ctty\n+\tif sys.Setctty {\n+\t\tif TIOCSCTTY == 0 {\n+\t\t\terr1 = ENOSYS\n+\t\t\tgoto childerror\n+\t\t}\n+\t\t_, err1 = raw_ioctl(sys.Ctty, TIOCSCTTY, 0)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Time to exec.\n+\terr1 = raw_execve(argv0, &argv[0], &envv[0])\n+\n+childerror:\n+\t// send error code on pipe\n+\traw_write(pipe, (*byte)(unsafe.Pointer(&err1)), int(unsafe.Sizeof(err1)))\n+\tfor {\n+\t\traw_exit(253)\n+\t}\n+}"}]}