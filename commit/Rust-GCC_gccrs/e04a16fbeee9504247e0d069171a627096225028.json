{"sha": "e04a16fbeee9504247e0d069171a627096225028", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA0YTE2ZmJlZWU5NTA0MjQ3ZTBkMDY5MTcxYTYyNzA5NjIyNTAyOA==", "commit": {"author": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "1998-09-06T15:36:06Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "1998-09-06T15:36:06Z"}, "message": "Initial revision\n\nFrom-SVN: r22299", "tree": {"sha": "b78f906318225a5e7bd3471f008be772727bdcea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b78f906318225a5e7bd3471f008be772727bdcea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e04a16fbeee9504247e0d069171a627096225028", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e04a16fbeee9504247e0d069171a627096225028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e04a16fbeee9504247e0d069171a627096225028", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e04a16fbeee9504247e0d069171a627096225028/comments", "author": null, "committer": null, "parents": [{"sha": "fc08e32958a1df77493bfe4abc52f88c7ade6251", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc08e32958a1df77493bfe4abc52f88c7ade6251", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc08e32958a1df77493bfe4abc52f88c7ade6251"}], "stats": {"total": 39504, "additions": 39504, "deletions": 0}, "files": [{"sha": "de1adf43869dcc5b0652d0d09a672bc2ef9e1d90", "filename": "gcc/java/Make-lang.in", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,209 @@\n+# Top level makefile fragment for the GNU compiler for the Java(TM)\n+# language.\n+#   Copyright (C) 1996, 1998 Free Software Foundation, Inc.\n+\n+#This file is part of GNU CC.\n+\n+#GNU CC is free software; you can redistribute it and/or modify\n+#it under the terms of the GNU General Public License as published by\n+#the Free Software Foundation; either version 2, or (at your option)\n+#any later version.\n+\n+#GNU CC is distributed in the hope that it will be useful,\n+#but WITHOUT ANY WARRANTY; without even the implied warranty of\n+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+#GNU General Public License for more details.\n+\n+#You should have received a copy of the GNU General Public License\n+#along with GNU CC; see the file COPYING.  If not, write to\n+#the Free Software Foundation, 59 Temple Place - Suite 330,\n+#Boston, MA 02111-1307, USA.\n+\n+#Java and all Java-based marks are trademarks or registered trademarks\n+#of Sun Microsystems, Inc. in the United States and other countries.\n+#The Free Software Foundation is independent of Sun Microsystems, Inc.\n+\n+# This file provides the language dependent support in the main Makefile.\n+# Each language makefile fragment must provide the following targets:\n+#\n+# foo.all.build, foo.all.cross, foo.start.encap, foo.rest.encap,\n+# foo.info, foo.dvi,\n+# foo.install-normal, foo.install-common, foo.install-info, foo.install-man,\n+# foo.uninstall, foo.distdir,\n+# foo.mostlyclean, foo.clean, foo.distclean, foo.extraclean,\n+# foo.maintainer-clean, foo.stage1, foo.stage2, foo.stage3, foo.stage4\n+#\n+# where `foo' is the name of the language.\n+#\n+# It should also provide rules for:\n+#\n+# - making any compiler driver (eg: g++)\n+# - the compiler proper (eg: jc1)\n+# - define the names for selecting the language in LANGUAGES.\n+\f\n+# Extra flags to pass to recursive makes.\n+JAVA_FLAGS_TO_PASS = \\\n+\t\"JAVA_FOR_BUILD=$(JAVA_FOR_BUILD)\" \\\n+\t\"JAVAFLAGS=$(JAVAFLAGS)\" \\\n+\t\"JAVA_FOR_TARGET=$(JAVA_FOR_TARGET)\"\n+\n+# Actual names to use when installing a native compiler.\n+JAVA_INSTALL_NAME = `t='$(program_transform_name)'; echo gcj | sed $$t`\n+\n+# Actual names to use when installing a cross-compiler.\n+JAVA_CROSS_NAME = `t='$(program_transform_cross_name)'; echo gcj | sed $$t`\n+\n+\f\n+# Define the names for selecting java in LANGUAGES.\n+java: jc1$(exeext) $(GCJ)$(exeext) jvgenmain$(exeext) gcjh$(exeext)\n+\n+# Define the name of target independant tools to be installed in $(bindir)\n+# Names are subject to changes\n+JAVA_TARGET_INDEPENDENT_BIN_TOOLS = gcjh jv-scan jcf-dump\n+\n+# Tell GNU make to ignore these if they exist.\n+.PHONY: java\n+\n+GCJ = gcj\n+\n+# Remember to keep this list in sync with JAVA_OBJS in Makefile.in!!!\n+#\n+JAVA_SRCS = $(srcdir)/java/parse.y $(srcdir)/java/class.c \\\n+  $(srcdir)/java/decl.c $(srcdir)/java/expr.c $(srcdir)/java/constants.c \\\n+  $(srcdir)/java/lang.c $(srcdir)/java/typeck.c $(srcdir)/java/except.c \\\n+  $(srcdir)/java/verify.c $(srcdir)/java/zextract.c $(srcdir)/java/jcf-io.c \\\n+  $(srcdir)/java/jcf-parse.c $(srcdir)/java/mangle.c \\\n+  $(srcdir)/java/jcf-write.c $(srcdir)/java/buffer.c\n+\n+jc1$(exeext): $(P) $(JAVA_SRCS) $(LIBDEPS) stamp-objlist\n+\tcd java; $(MAKE) $(FLAGS_TO_PASS) $(JAVA_FLAGS_TO_PASS) ../jc1$(exeext)\n+\n+$(GCJ).c: $(srcdir)/gcc.c\n+\t-rm -f $@\n+\t$(LN_S) $(srcdir)/gcc.c $@\n+\n+jvspec.o: $(srcdir)/java/jvspec.c\n+\t$(CC) -c -DWITH_THREAD_$(GCC_THREAD_FILE) \\\n+\t\t$(ALL_CFLAGS) $(ALL_CPPFLAGS) \\\n+\t\t$(INCLUDES) $(srcdir)/java/jvspec.c\n+\n+# N.B.: This is a copy of the gcc.o rule, with -DLANG_SPECIFIC_DRIVER added.\n+# It'd be nice if we could find an easier way to do this---rather than have\n+# to track changes to the toplevel gcc Makefile as well.\n+# We depend on $(GCJ).c last, to make it obvious where it came from.\n+$(GCJ).o: $(CONFIG_H) multilib.h config.status $(lang_specs_files) $(GCJ).c \\\n+       system.h\n+\t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t$(DRIVER_DEFINES) \\\n+\t-DLANG_SPECIFIC_DRIVER \\\n+  -c $(GCJ).c\n+\n+# Create the compiler driver for $(GCJ).\n+$(GCJ)$(exeext): $(GCJ).o jvspec.o version.o choose-temp.o\\\n+\t   pexecute.o prefix.o mkstemp.o $(LIBDEPS) $(EXTRA_GCC_OBJS)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(GCJ).o jvspec.o prefix.o \\\n+\t  version.o choose-temp.o pexecute.o mkstemp.o $(EXTRA_GCC_OBJS) $(LIBS)\n+\n+# Create a version of the $(GCJ) driver which calls the cross-compiler.\n+$(GCJ)-cross$(exeext): $(GCJ)$(exeext)\n+\t-rm -f $(GCJ)-cross$(exeext)\n+\tcp $(GCJ)$(exeext) $(GCJ)-cross$(exeext)\n+\n+# Dependencies here must be kept in sync with dependencies in Makefile.in.\n+jvgenmain$(exeext): $(srcdir)/java/jvgenmain.c $(srcdir)/java/mangle.c \\\n+\t\t$(OBSTACK)\n+\tcd java && $(MAKE) $(FLAGS_TO_PASS) $(JAVA_FLAGS_TO_PASS) ../jvgenmain$(exeext)\n+\n+# This must be kept in sync with dependencies in Makefile.in.\n+GCJH_SOURCES = $(srcdir)/java/gjavah.c $(srcdir)/java/jcf-io.c \\\n+\t$(srcdir)/java/zextract.c $(srcdir)/java/jcf-reader.c \\\n+\t$(srcdir)/java/jcf.h $(srcdir)/java/javaop.h \\\n+\t$(srcdir)/java/javaop.def\n+\n+gcjh$(exeext): $(GCJH_SOURCES)\n+\tcd java && $(MAKE) $(FLAGS_TO_PASS) $(JAVA_FLAGS_TO_PASS) ../gcjh$(exeext)\n+\n+\n+\f\n+# Build hooks:\n+\n+java.all.build: $(GCJ)$(exeext) jvgenmain$(exeext) gcjh$(exeext)\n+java.all.cross: $(GCJ)-cross$(exeext) jvgenmain$(exeext) gcjh$(exeext)\n+java.start.encap: $(GCJ)$(exeext)\n+java.rest.encap: jvgenmain$(exeext) gcjh$(exeext)\n+\n+java.info:\n+\n+# Install hooks:\n+# jc1, gcj, jvgenmain, and gcjh are installed elsewhere as part\n+# of $(COMPILERS).\n+\n+# Nothing to do here.\n+java.install-normal:\n+\n+java.install-common:\n+\t-if [ -f $(GCJ)$(exeext) ]; then \\\n+\t  if [ -f $(GCJ)-cross$(exeext) ]; then \\\n+\t    rm -f $(bindir)/$(JAVA_CROSS_NAME)$(exeext); \\\n+\t    $(INSTALL_PROGRAM) $(GCJ)-cross$(exeext) $(bindir)/$(JAVA_CROSS_NAME)$(exeext); \\\n+\t    chmod a+x $(bindir)/$(JAVA_CROSS_NAME)$(exeext); \\\n+\t  else \\\n+\t    rm -f $(bindir)/$(JAVA_INSTALL_NAME)$(exeext); \\\n+\t    $(INSTALL_PROGRAM) $(GCJ)$(exeext) $(bindir)/$(JAVA_INSTALL_NAME)$(exeext); \\\n+\t    chmod a+x $(bindir)/$(JAVA_INSTALL_NAME)$(exeext); \\\n+\t  fi ; \\\n+\tfi ; \\\n+        for tool in $(JAVA_TARGET_INDEPENDENT_BIN_TOOLS); do \\\n+          if [ -f $$tool$(exeext) ]; then \\\n+\t    rm -f $(bindir)/$$tool$(exeext); \\\n+\t    $(INSTALL_PROGRAM) $$tool$(exeext) $(bindir)/$$tool$(exeext); \\\n+\t    chmod a+x $(bindir)/$$tool$(exeext); \\\n+          fi ; \\\n+       done\n+\n+java.install-man:\n+\n+java.uninstall:\n+\t-rm -rf $(bindir)/$(JAVA_INSTALL_NAME)$(exeext)\n+\t-rm -rf $(bindir)/$(JAVA_CROSS_NAME)$(exeext)\n+\n+java.install-info:\n+\n+\f\n+# Clean hooks:\n+# A lot of the ancillary files are deleted by the main makefile.\n+# We just have to delete files specific to us.\n+\n+java.mostlyclean:\n+\t-rm -f java/*$(objext) $(DEMANGLER_PROG)\n+java.clean:\n+java.distclean:\n+\t-rm -f java/config.status java/Makefile\n+\t-rm -f java/parse.output\n+java.extraclean:\n+java.maintainer-clean:\n+\t-rm -f java/parse.h\n+\f\n+# Stage hooks:\n+# The main makefile has already created stage?/java.\n+\n+java.stage1:\n+\t-mv java/*$(objext) stage1/java\n+java.stage2:\n+\t-mv java/*$(objext) stage2/java\n+java.stage3:\n+\t-mv java/*$(objext) stage3/java\n+java.stage4:\n+\t-mv java/*$(objext) stage4/java\n+\f\n+# Maintenance hooks:\n+\n+# This target creates the files that can be rebuilt, but go in the\n+# distribution anyway.  It then copies the files to the distdir directory.\n+java.distdir:\n+\tmkdir tmp/java\n+\tcd java ; $(MAKE) $(FLAGS_TO_PASS) $(JAVA_FLAGS_TO_PASS) parse.c hash.h\n+\tcd java; \\\n+\tfor file in *[0-9a-zA-Z+]; do \\\n+\t  ln $$file ../tmp/java >/dev/null 2>&1 || cp $$file ../tmp/java; \\\n+\tdone"}, {"sha": "6f043dcca9c0c02003644dbf6c3b40536d6c63b8", "filename": "gcc/java/Makefile.in", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMakefile.in?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,258 @@\n+# Makefile for GNU compiler for the Java(TM) language.\n+#   Copyright (C) 1987, 88, 90-4, 1995, 1998 Free Software Foundation, Inc.\n+\n+#This file is part of GNU CC.\n+\n+#GNU CC is free software; you can redistribute it and/or modify\n+#it under the terms of the GNU General Public License as published by\n+#the Free Software Foundation; either version 2, or (at your option)\n+#any later version.\n+\n+#GNU CC is distributed in the hope that it will be useful,\n+#but WITHOUT ANY WARRANTY; without even the implied warranty of\n+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+#GNU General Public License for more details.\n+\n+#You should have received a copy of the GNU General Public License\n+#along with GNU CC; see the file COPYING.  If not, write to\n+#the Free Software Foundation, 59 Temple Place - Suite 330,\n+#Boston, MA 02111-1307, USA.\n+\n+#Java and all Java-based marks are trademarks or registered trademarks\n+#of Sun Microsystems, Inc. in the United States and other countries.\n+#The Free Software Foundation is independent of Sun Microsystems, Inc.\n+\n+# The makefile built from this file lives in the language subdirectory.\n+# Its purpose is to provide support for:\n+#\n+# 1) recursion where necessary, and only then (building .o's), and\n+# 2) building and debugging cc1 from the language subdirectory, and\n+# 3) nothing else.\n+#\n+# The parent makefile handles all other chores, with help from the\n+# language makefile fragment, of course.\n+#\n+# The targets for external use are:\n+# all, TAGS, ???mostlyclean, ???clean.\n+\n+# Suppress smart makes who think they know how to automake Yacc files\n+.y.c:\n+\n+# Variables that exist for you to override.\n+# See below for how to change them for certain systems.\n+\n+ALLOCA =\n+\n+# Various ways of specifying flags for compilations:  \n+# CFLAGS is for the user to override to, e.g., do a bootstrap with -O2.\n+# BOOT_CFLAGS is the value of CFLAGS to pass\n+# to the stage2 and stage3 compilations\n+# XCFLAGS is used for most compilations but not when using the GCC just built.\n+XCFLAGS =\n+CFLAGS = -g\n+BOOT_CFLAGS = -O $(CFLAGS)\n+# These exists to be overridden by the x-* and t-* files, respectively.\n+X_CFLAGS =\n+T_CFLAGS =\n+\n+X_CPPFLAGS =\n+T_CPPFLAGS =\n+\n+CC = @CC@\n+BISON = `if [ -f ../../bison/bison ] ; then echo ../../bison/bison -L $(srcdir)/../../bison/ ;  else echo bison ; fi`\n+BISONFLAGS =\n+JAVABISONFLAGS = --name-prefix=java_\n+LEX = `if [ -f ../../flex/flex ] ; then echo ../../flex/flex ;  else echo flex ; fi`\n+LEXFLAGS =\n+AR = ar\n+AR_FLAGS = rc\n+SHELL = /bin/sh\n+MAKEINFO = makeinfo\n+TEXI2DVI = texi2dvi\n+\n+# Define this as & to perform parallel make on a Sequent.\n+# Note that this has some bugs, and it seems currently necessary \n+# to compile all the gen* files first by hand to avoid erroneous results.\n+P =\n+\n+# This is used in the definition of SUBDIR_USE_ALLOCA.\n+# ??? Perhaps it would be better if it just looked for *gcc*.\n+OLDCC = cc\n+\n+# This is used instead of ALL_CFLAGS when compiling with GCC_FOR_TARGET.\n+# It omits XCFLAGS, and specifies -B./.\n+# It also specifies -B$(tooldir)/ to find as and ld for a cross compiler.\n+GCC_CFLAGS=$(INTERNAL_CFLAGS) $(X_CFLAGS) $(T_CFLAGS) $(CFLAGS)\n+\n+# Tools to use when building a cross-compiler.\n+# These are used because `configure' appends `cross-make'\n+# to the makefile when making a cross-compiler.\n+\n+# We don't use cross-make.  Instead we use the tools\n+# from the build tree, if they are available.\n+# program_transform_name and objdir are set by configure.in.\n+program_transform_name =\n+objdir = .\n+\n++target=@target@\n++xmake_file=@dep_host_xmake_file@\n++tmake_file=@dep_tmake_file@\n+#version=`sed -e 's/.*\\\"\\([^ \\\"]*\\)[ \\\"].*/\\1/' < $(srcdir)/version.c`\n+#mainversion=`sed -e 's/.*\\\"\\([0-9]*\\.[0-9]*\\).*/\\1/' < $(srcdir)/version.c`\n+\n+# Directory where sources are, from where we are.\n+srcdir = @srcdir@\n+VPATH = @srcdir@\n+\n+# Additional system libraries to link with.\n+CLIB=\n+\n+# Change this to a null string if obstacks are installed in the\n+# system library.\n+OBSTACK=obstack.o\n+\n+# Choose the real default target.\n+ALL=all\n+\n+# End of variables for you to override.\n+\n+# Definition of `all' is here so that new rules inserted by sed\n+# do not specify the default target.\n+all: all.indirect\n+\n+# This tells GNU Make version 3 not to put all variables in the environment.\n+.NOEXPORT:\n+\n+# sed inserts variable overrides after the following line.\n+####target overrides\n+@target_overrides@\n+####host overrides\n+@host_overrides@\n+####cross overrides\n+@cross_overrides@\n+####build overrides\n+@build_overrides@\n+####site overrides\n+\f\n+# Now figure out from those variables how to compile and link.\n+\n+all.indirect: Makefile ../jc1$(exeext) ../jcf-dump$(exeext) \\\n+\t../jvgenmain$(exeext) ../gcjh$(exeext) ../jv-scan$(exeext)\n+\n+# IN_GCC tells obstack.h that we are using gcc's <stddef.h> file.\n+INTERNAL_CFLAGS = $(CROSS) -DIN_GCC @extra_c_flags@\n+\n+# This is the variable actually used when we compile.\n+ALL_CFLAGS = $(INTERNAL_CFLAGS) $(X_CFLAGS) $(T_CFLAGS) $(CFLAGS) $(XCFLAGS)\n+\n+# Likewise.\n+ALL_CPPFLAGS = $(CPPFLAGS) $(X_CPPFLAGS) $(T_CPPFLAGS)\n+\n+# Even if ALLOCA is set, don't use it if compiling with GCC.\n+\n+SUBDIR_OBSTACK = `if [ x$(OBSTACK) != x ]; then echo ../$(OBSTACK); else true; fi`\n+SUBDIR_USE_ALLOCA = `case \"${CC}\" in \"${OLDCC}\") if [ x$(ALLOCA) != x ]; then echo ../$(ALLOCA); else true; fi ;; esac`\n+SUBDIR_MALLOC = `if [ x$(MALLOC) != x ]; then echo ../$(MALLOC); else true; fi`\n+\n+# How to link with both our special library facilities\n+# and the system's installed libraries.\n+LIBS = $(SUBDIR_OBSTACK) $(SUBDIR_USE_ALLOCA) $(SUBDIR_MALLOC) $(CLIB)\n+\n+# Specify the directories to be searched for header files.\n+# Both . and srcdir are used, in that order,\n+# so that tm.h and config.h will be found in the compilation\n+# subdirectory rather than in the source directory.\n+INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config\n+\n+# Always use -I$(srcdir)/config when compiling.\n+.c.o:\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n+\n+# This tells GNU make version 3 not to export all the variables\n+# defined in this file into the environment.\n+.NOEXPORT:\n+\f\n+# Lists of files for various purposes.\n+\n+# Language-specific object files for Gcc/Java:\n+\n+# Remember to keep this list in sync with JAVA_SRCS in Make-lang.in!!!\n+#\n+JAVA_OBJS = parse.o class.o decl.o expr.o constants.o lang.o typeck.o \\\n+  except.o verify.o zextract.o jcf-io.o jcf-parse.o mangle.o jcf-write.o \\\n+  buffer.o\n+\n+JAVA_OBJS_LITE = parse-scan.o jv-scan.o\n+\n+# Language-independent object files.\n+OBJS = `cat ../stamp-objlist`\n+OBJDEPS = ../stamp-objlist\n+\n+compiler: ../jc1$(exeext) ../jv-scan$(exeext)\n+../jc1$(exeext): $(P) $(JAVA_OBJS) $(OBJDEPS) $(LIBDEPS)\n+\trm -f ../jc1$(exeext)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ \\\n+\t      $(JAVA_OBJS) $(OBJS) $(LIBS)\n+../jv-scan$(exeext): $(P) $(JAVA_OBJS_LITE) $(OBJDEPS) $(LIBDEPS)\n+\trm -f ../jv-scan$(exeext)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ \\\n+\t      $(JAVA_OBJS_LITE) $(LIBS)\n+\n+../jcf-dump$(exeext): jcf-dump.o jcf-io.o zextract.o\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ jcf-dump.o jcf-io.o zextract.o\n+\n+# Dependencies here must be kept in sync with dependencies in Make-lang.in.\n+../jvgenmain$(exeext):  jvgenmain.o mangle.o\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ jvgenmain.o mangle.o ../obstack.o\n+\n+../gcjh$(exeext): gjavah.o jcf-io.o zextract.o\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ gjavah.o jcf-io.o zextract.o\n+\n+Makefile: $(srcdir)/Makefile.in $(srcdir)/../configure\n+\tcd ..; $(SHELL) config.status\n+\n+native: config.status ../jc1$(exeext)\n+\f\n+# Compiling object files from source files.\n+\n+PARSE_H = $(srcdir)/parse.h\n+PARSE_C = $(srcdir)/parse.c\n+PARSE_SCAN_C = $(srcdir)/parse-scan.c\n+\n+$(PARSE_H): $(PARSE_C)\n+$(PARSE_C):  $(srcdir)/parse.y $(srcdir)/lex.c $(PARSE_H) $(srcdir)/lex.h\n+\t$(BISON) -t -v $(BISONFLAGS) $(JAVABISONFLAGS) -o $(PARSE_C) \\\n+\t  $(srcdir)/parse.y\n+$(PARSE_SCAN_C):  $(srcdir)/parse-scan.y $(srcdir)/lex.c $(PARSE_H) \\\n+\t\t$(srcdir)/lex.h\n+\t$(BISON) -t -v $(BISONFLAGS) -o $(PARSE_SCAN_C) $(srcdir)/parse-scan.y\n+\n+lex.c: keyword.h lex.h\n+\n+keyword.h: keyword.gperf\n+\tgperf -p -t -j1 -i 1 -g -o -N java_keyword -k1,3,$$ \\\n+\tkeyword.gperf > keyword.h\n+\n+# These exist for maintenance purposes.\n+\n+# Update the tags table.\n+TAGS: force\n+\tcd $(srcdir) ;\t\t\t\t\\\n+\tetags *.c *.h ;\t\t\t\t\\\n+\techo 'l' | tr 'l' '\\f' >> TAGS ;\t\\\n+\techo 'parse.y,0' >> TAGS ; \t\t\\\n+\tetags -a ../*.h ../*.c;\n+\n+.PHONY: TAGS\n+\n+mostlyclean:\n+\trm -f *.o\n+\n+clean:  mostlyclean\n+\trm -f parse.c\n+\n+force:\n+\n+parse.o: $(PARSE_C) jcf-reader.c\n+jcf-dump.o: jcf-reader.c jcf.h javaop.h javaop.def\n+gjavah.o: jcf-reader.c jcf.h javaop.h"}, {"sha": "cea7899973b2aa3ce09a68e68528670c955fafd3", "filename": "gcc/java/buffer.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fbuffer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fbuffer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuffer.c?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,50 @@\n+/* A \"buffer\" utility type.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Written by Per Bothner <bothner@cygnus.com>, July 1998. */\n+\n+#include \"gansidecl.h\"\n+#include \"buffer.h\"\n+\n+/* Grow BUFP so there is room for at least SIZE more bytes. */\n+\n+void\n+buffer_grow (bufp, size)\n+     struct buffer *bufp;\n+     int size;\n+{\n+  if (bufp->limit - bufp->ptr >= size)\n+    return;\n+  if (bufp->data == 0)\n+    {\n+      if (size < 120)\n+\tsize = 120;\n+      bufp->data = (unsigned char*) xmalloc (size);\n+      bufp->ptr = bufp->data;\n+    }\n+  else\n+    {\n+      int index = bufp->ptr - bufp->data;\n+      size += 2 * (bufp->limit - bufp->data);\n+      bufp->data = (unsigned char *) xrealloc (bufp->data, size);\n+      bufp->ptr = bufp->data + index;\n+    }\n+  bufp->limit = bufp->data + size;\n+}"}, {"sha": "aa63840d75969402e617110a9dcb4fa5ac42058e", "filename": "gcc/java/buffer.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fbuffer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fbuffer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuffer.h?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,43 @@\n+/* A \"buffer\" utility type.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Written by Per Bothner <bothner@cygnus.com>, July 1998. */\n+\n+/* A simple data structure for an expandable buffer. */\n+\n+struct buffer\n+{\n+  /* The start of the actual data buffer. */\n+  unsigned char *data;\n+\n+  /* Where to write next in the buffer. */\n+  unsigned char *ptr;\n+\n+  /* The end of the allocated data buffer. */\n+  unsigned char *limit;\n+};\n+\n+#define NULL_BUFFER { (void*) 0, (void*) 0, (void*) 0 }\n+\n+#define BUFFER_LENGTH(BUFP) ((BUFP)->ptr - (BUFP)->data)\n+\n+#define BUFFER_RESET(BUFP) ((BUFP)->ptr = (BUFP)->data)\n+\n+extern void buffer_grow PROTO ((struct buffer*, int));"}, {"sha": "9dc49dcbeec1e4f2948fcd3a4040a5da94f5a26f", "filename": "gcc/java/class.c", "status": "added", "additions": 1601, "deletions": 0, "changes": 1601, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,1601 @@\n+/* Functions related to building classes and their related objects.\n+   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Written by Per Bothner <bothner@cygnus.com> */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"java-tree.h\"\n+#include \"jcf.h\"\n+#include \"obstack.h\"\n+\n+static tree mangle_class_field PROTO ((tree class));\n+\n+static rtx registerClass_libfunc;\n+\n+extern struct obstack permanent_obstack;\n+extern struct obstack temporary_obstack;\n+\n+/* Return an IDENTIFIER_NODE the same as (OLD_NAME, OLD_LENGTH).\n+   except that characters matching OLD_CHAR are substituted by NEW_CHAR.\n+   Also, PREFIX is prepended, and SUFFIX is appended. */\n+\n+tree\n+ident_subst (old_name, old_length, prefix, old_char, new_char, suffix)\n+     const char* old_name;\n+     int old_length;\n+     const char *prefix;\n+     int old_char;\n+     int new_char;\n+     const char *suffix;\n+{\n+  int prefix_len = strlen (prefix);\n+  int suffix_len = strlen (suffix);\n+  int i = prefix_len + old_length + suffix_len + 1;\n+#ifdef __GNUC__\n+  char buffer[i];\n+#else\n+  char *buffer = (char *)alloca  (i);\n+#endif\n+  strcpy (buffer, prefix);\n+  for (i = 0; i < old_length; i++)\n+    {\n+      char ch = old_name[i];\n+      if (ch == old_char)\n+\tch = new_char;\n+      buffer[prefix_len + i] = ch;\n+    }\n+  strcpy (buffer + prefix_len + old_length, suffix);\n+  return get_identifier (buffer);\n+}\n+\n+/* Return an IDENTIFIER_NODE the same as OLD_ID,\n+   except that characters matching OLD_CHAR are substituted by NEW_CHAR.\n+   Also, PREFIX is prepended, and SUFFIX is appended. */\n+\n+tree\n+identifier_subst (old_id, prefix, old_char, new_char, suffix)\n+     const tree old_id;\n+     const char *prefix;\n+     int old_char;\n+     int new_char;\n+     const char *suffix;\n+{\n+  return ident_subst (IDENTIFIER_POINTER (old_id), IDENTIFIER_LENGTH (old_id),\n+\t\t      prefix, old_char, new_char, suffix);\n+}\n+\n+/* Generate a valid C identifier from the name of the class TYPE,\n+   prefixed by PREFIX. */\n+\n+tree\n+mangled_classname (prefix, type)\n+     char *prefix;\n+     tree type;\n+{\n+  tree ident = TYPE_NAME (type);\n+  if (TREE_CODE (ident) != IDENTIFIER_NODE)\n+    ident = DECL_NAME (ident);\n+  return identifier_subst (ident, prefix, '/', '_', \"\");\n+}\n+\n+tree\n+make_class ()\n+{\n+  tree type;\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  type = make_node (RECORD_TYPE);\n+#ifdef JAVA_USE_HANDLES\n+  tree field1 = build_decl (FIELD_DECL, get_identifier (\"obj\"),\n+\t\t\t    build_pointer_type (type));\n+  tree field2 = build_decl (FIELD_DECL, get_identifier (\"methods\"),\n+\t\t\t    methodtable_ptr_type);\n+  tree handle_type = make_node (RECORD_TYPE);\n+  TREE_CHAIN (field1) = field2;\n+  TYPE_FIELDS (handle_type) = field1;\n+  TYPE_BINFO (type) = make_tree_vec (7);\n+  TYPE_BINFO (handle_type) = make_tree_vec (7);\n+  BINFO_HANDLE (TYPE_BINFO (handle_type)) = type;\n+  BINFO_HANDLE (TYPE_BINFO (type)) = handle_type;\n+#else\n+  TYPE_BINFO (type) = make_tree_vec (6);\n+#endif\n+  CLASS_P (type) = 1;\n+  pop_obstacks ();\n+\n+  return type;\n+}\n+\n+/* Given a fully-qualified classname in NAME (whose length is NAME_LENGTH),\n+   and where each of the constituents is separated by '/',\n+   return a corresponding IDENTIFIER_NODE, except using '.' as separator. */\n+\n+tree\n+unmangle_classname (name, name_length)\n+     const char *name;  int name_length;\n+{\n+  return ident_subst (name, name_length, \"\", '/', '.', \"\");\n+}\n+\n+tree\n+push_class (class_type, class_name)\n+     tree class_type, class_name;\n+{\n+  tree decl, signature;\n+  char *save_input_filename = input_filename;\n+  int save_lineno = lineno;\n+  tree source_name = identifier_subst (class_name, \"\", '.', '/', \".java\");\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  input_filename = IDENTIFIER_POINTER (source_name);\n+  lineno = 0;\n+  decl = build_decl (TYPE_DECL, class_name, class_type);\n+  input_filename = save_input_filename;\n+  lineno = save_lineno;\n+  signature = identifier_subst (class_name, \"L\", '.', '/', \";\");\n+  IDENTIFIER_SIGNATURE_TYPE (signature) = class_type;\n+\n+  /* Setting DECL_ARTIFICAL forces dbxout.c to specific the type is\n+     both a typedef and in the struct name-space.  We may want to re-visit\n+     this later, but for now it reduces the changes needed for gdb. */\n+  DECL_ARTIFICIAL (decl) = 1;\n+\n+  pushdecl_top_level (decl);\n+#ifdef JAVA_USE_HANDLES\n+  {\n+    tree handle_name = identifier_subst (class_name,\n+\t\t\t\t\t \"Handle$\", '.', '.', \"\");\n+    tree handle_decl = build_decl (TYPE_DECL, handle_name,\n+\t\t\t\t   CLASS_TO_HANDLE_TYPE (class_type));\n+    pushdecl (handle_decl);\n+  }\n+#endif\n+\n+  pop_obstacks ();\n+  return decl;\n+}\n+\n+/* Finds the (global) class named NAME.  Creates the class if not found.\n+   Also creates associated TYPE_DECL.\n+   Does not check if the class actually exists, load the class,\n+   fill in field or methods, or do layout_type. */\n+\n+tree\n+lookup_class (name)\n+     tree name;\n+{\n+  tree decl = IDENTIFIER_CLASS_VALUE (name);\n+  if (decl == NULL_TREE)\n+    decl = push_class (make_class (), name);\n+  return TREE_TYPE (decl);\n+}\n+\n+void\n+set_super_info (access_flags, this_class, super_class, interfaces_count)\n+     int access_flags;\n+     tree this_class;\n+     tree super_class;\n+     int interfaces_count;\n+{\n+  int total_supers = interfaces_count;\n+  tree class_decl = TYPE_NAME (this_class);\n+  if (super_class)\n+    total_supers++;\n+\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  TYPE_BINFO_BASETYPES (this_class) = make_tree_vec (total_supers);\n+  if (super_class)\n+    {\n+      tree super_binfo = make_tree_vec (6);\n+      BINFO_TYPE (super_binfo) = super_class;\n+      BINFO_OFFSET (super_binfo) = integer_zero_node;\n+      TREE_VIA_PUBLIC (super_binfo) = 1;\n+      TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (this_class)), 0)\n+\t= super_binfo;\n+      CLASS_HAS_SUPER (this_class) = 1;\n+    }\n+  pop_obstacks ();\n+  \n+  if (access_flags & ACC_PUBLIC)    CLASS_PUBLIC (class_decl) = 1;\n+  if (access_flags & ACC_FINAL)     CLASS_FINAL (class_decl) = 1;\n+  if (access_flags & ACC_SUPER)     CLASS_SUPER (class_decl) = 1;\n+  if (access_flags & ACC_INTERFACE) CLASS_INTERFACE (class_decl) = 1;\n+  if (access_flags & ACC_ABSTRACT)  CLASS_ABSTRACT (class_decl) = 1;\n+}\n+\n+/* Return length of inheritance chain of CLAS, where java.lang.Object is 0,\n+   direct sub-classes of Object are 1, and so on. */\n+\n+int\n+class_depth (clas)\n+     tree clas;\n+{\n+  int depth = 0;\n+  if (! CLASS_LOADED_P (clas))\n+    load_class (clas, 1);\n+  while (clas != object_type_node)\n+    {\n+      depth++;\n+      clas = TYPE_BINFO_BASETYPE (clas, 0);\n+    }\n+  return depth;\n+}\n+\n+/* Return true iff TYPE2 is an interface that extends interface TYPE1 */\n+\n+int\n+interface_of_p (type1, type2)\n+     tree type1, type2;\n+{\n+  int n, i;\n+  tree basetype_vec;\n+\n+  if (!(basetype_vec = TYPE_BINFO_BASETYPES (type2)))\n+    return 0;\n+  n = TREE_VEC_LENGTH (basetype_vec);\n+  for (i = 0; i < n; i++)\n+    {\n+      tree vec_elt = TREE_VEC_ELT (basetype_vec, i);\n+      if (vec_elt && BINFO_TYPE (vec_elt) == type1)\n+\treturn 1;\n+    }\n+  for (i = 0; i < n; i++)\n+    {\n+      tree vec_elt = TREE_VEC_ELT (basetype_vec, i);\n+      if (vec_elt && BINFO_TYPE (vec_elt) \n+\t  && interface_of_p (type1, BINFO_TYPE (vec_elt)))\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+/* Return true iff TYPE1 inherits from TYPE2. */\n+\n+int\n+inherits_from_p (type1, type2)\n+     tree type1, type2;\n+{\n+  while (type1 != NULL_TREE && TREE_CODE (type1) == RECORD_TYPE)\n+    {\n+      if (type1 == type2)\n+\treturn 1;\n+      type1 = CLASSTYPE_SUPER (type1);\n+    }\n+  return 0;\n+}\n+\n+static void\n+add_interface_do (basetype_vec, interface_class, i)\n+     tree basetype_vec, interface_class;\n+     int i;\n+{\n+  tree interface_binfo = make_tree_vec (6);\n+  BINFO_TYPE (interface_binfo) = interface_class;\n+  BINFO_OFFSET (interface_binfo) = integer_zero_node;\n+  TREE_VIA_VIRTUAL (interface_binfo) = 1;\n+  TREE_VIA_PUBLIC (interface_binfo) = 1;\n+  TREE_VEC_ELT (basetype_vec, i) = interface_binfo;\n+}\n+\n+/* Add INTERFACE_CLASS to THIS_CLASS iff INTERFACE_CLASS can't be\n+   found in THIS_CLASS. Returns NULL_TREE upon success, INTERFACE_CLASS\n+   if attempt is made to add it twice. */\n+\n+tree\n+maybe_add_interface (this_class, interface_class)\n+     tree this_class, interface_class;\n+{\n+  tree basetype_vec = TYPE_BINFO_BASETYPES (this_class);\n+  tree interface_binfo = make_tree_vec (6);\n+  int i;\n+  int n = TREE_VEC_LENGTH (basetype_vec);\n+  for (i = 0; ; i++)\n+    {\n+      if (i >= n)\n+\t{\n+\t  error (\"internal error - too many interface type\");\n+\t  return NULL_TREE;\n+\t}\n+      else if (TREE_VEC_ELT (basetype_vec, i) == NULL_TREE)\n+\tbreak;\n+      else if (BINFO_TYPE (TREE_VEC_ELT (basetype_vec, i)) == interface_class)\n+\treturn interface_class;\n+    } \n+  add_interface_do (basetype_vec, interface_class, i);\n+  return NULL_TREE;\n+}\n+\n+/* Add the INTERFACE_CLASS as one of the interfaces of THIS_CLASS. */\n+\n+void\n+add_interface (this_class, interface_class)\n+     tree this_class, interface_class;\n+{\n+  tree basetype_vec = TYPE_BINFO_BASETYPES (this_class);\n+  int i;\n+  int n = TREE_VEC_LENGTH (basetype_vec);\n+  for (i = 0; ; i++)\n+    {\n+      if (i >= n)\n+\t{\n+\t  error (\"internal error - too many interface type\");\n+\t  return;\n+\t}\n+      else if (TREE_VEC_ELT (basetype_vec, i) == NULL_TREE)\n+\tbreak;\n+    }\n+  add_interface_do (basetype_vec, interface_class, i);\n+}\n+\n+/* Return the address of a pointer to the first FUNCTION_DECL\n+   in the list (*LIST) whose DECL_NAME is NAME. */\n+\n+static tree *\n+find_named_method (list, name)\n+     tree *list;\n+     tree name;\n+{\n+  while (*list && DECL_NAME (*list) != name)\n+    list = &TREE_CHAIN (*list);\n+  return list;\n+}\n+\n+tree\n+build_java_method_type (fntype, this_class, access_flags)\n+     tree fntype;\n+     tree this_class;\n+     int access_flags;\n+{\n+  if (access_flags & ACC_STATIC)\n+    return fntype;\n+  return build_method_type (CLASS_TO_HANDLE_TYPE (this_class), fntype);\n+}\n+\n+tree\n+add_method_1 (handle_class, access_flags, name, function_type)\n+     tree handle_class;\n+     int access_flags;\n+     tree name;\n+     tree function_type;\n+{\n+  tree method_type, fndecl;\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+\n+  method_type = build_java_method_type (function_type,\n+\t\t\t\t\thandle_class, access_flags);\n+\n+  fndecl = build_decl (FUNCTION_DECL, name, method_type);\n+  DECL_CONTEXT (fndecl) = handle_class;\n+\n+  DECL_LANG_SPECIFIC (fndecl)\n+    = (struct lang_decl *) permalloc (sizeof (struct lang_decl));\n+  bzero (DECL_LANG_SPECIFIC (fndecl), sizeof (struct lang_decl));\n+\n+  TREE_CHAIN (fndecl) = TYPE_METHODS (handle_class);\n+  TYPE_METHODS (handle_class) = fndecl;\n+  pop_obstacks ();\n+\n+  if (access_flags & ACC_PUBLIC) METHOD_PUBLIC (fndecl) = 1;\n+  if (access_flags & ACC_PROTECTED) METHOD_PROTECTED (fndecl) = 1;\n+  if (access_flags & ACC_PRIVATE) METHOD_PRIVATE (fndecl) = 1;\n+  if (access_flags & ACC_NATIVE) METHOD_NATIVE (fndecl) = 1;\n+  if (access_flags & ACC_STATIC) METHOD_STATIC (fndecl) = 1;\n+  if (access_flags & ACC_FINAL) METHOD_FINAL (fndecl) = 1;\n+  if (access_flags & ACC_SYNCHRONIZED) METHOD_SYNCHRONIZED (fndecl) = 1;\n+  if (access_flags & ACC_ABSTRACT) METHOD_ABSTRACT (fndecl) = 1;\n+  if (access_flags & ACC_TRANSIENT) METHOD_TRANSIENT (fndecl) = 1;\n+  return fndecl;\n+}\n+\n+/* Add a method to THIS_CLASS.\n+   The method's name is NAME.\n+   Its signature (mangled type) is METHOD_SIG (an IDENTIFIER_NODE). */\n+\n+tree\n+add_method (this_class, access_flags, name, method_sig)\n+     tree this_class;\n+     int access_flags;\n+     tree name;\n+     tree method_sig;\n+{\n+  tree handle_class = CLASS_TO_HANDLE_TYPE (this_class);\n+  tree function_type, method_type, fndecl;\n+  unsigned char *sig = (unsigned char*)IDENTIFIER_POINTER (method_sig);\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  if (sig[0] != '(')\n+    fatal (\"bad method signature\");\n+  function_type = get_type_from_signature (method_sig);\n+  fndecl = add_method_1 (handle_class, access_flags, name, function_type);\n+  set_java_signature (TREE_TYPE (fndecl), method_sig);\n+  pop_obstacks ();\n+  return fndecl;\n+}\n+\n+tree\n+add_field (class, name, field_type, flags)\n+     tree class;\n+     tree name;\n+     tree field_type;\n+     int flags;\n+{\n+  int is_static = (flags & ACC_STATIC) != 0;\n+  tree field;\n+  /* Push the obstack of field_type ? FIXME */\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+#if ! JAVA_PROMOTE_TO_INT\n+  if (TREE_CODE (field_type) == RECORD_TYPE)\n+#endif\n+    field_type = promote_type (field_type);\n+  field = build_decl (is_static ? VAR_DECL : FIELD_DECL, name, field_type);\n+  pop_obstacks ();\n+  TREE_CHAIN (field) = TYPE_FIELDS (class);\n+  TYPE_FIELDS (class) = field;\n+  DECL_CONTEXT (field) = class;\n+\n+  if (flags & ACC_PUBLIC) FIELD_PUBLIC (field) = 1;\n+  if (flags & ACC_PROTECTED) FIELD_PROTECTED (field) = 1;\n+  if (flags & ACC_PRIVATE) FIELD_PRIVATE (field) = 1;\n+  if (flags & ACC_FINAL) FIELD_FINAL (field) = 1;\n+  if (flags & ACC_VOLATILE) FIELD_VOLATILE (field) = 1;\n+  if (flags & ACC_TRANSIENT) FIELD_TRANSIENT (field) = 1;\n+  if (is_static)\n+    {\n+      FIELD_STATIC (field) = 1;\n+      if (! FIELD_PRIVATE (field) || FIELD_PROTECTED (field))\n+\tTREE_PUBLIC (field) = 1;\n+    }\n+  return field;\n+}\n+\n+/* Associate a constant value CONSTANT with VAR_DECL FIELD. */\n+\n+void\n+set_constant_value (field, constant)\n+     tree field, constant;\n+{\n+  if (field == NULL_TREE)\n+    warning (\"misplaced ConstantValue attribute (not in any field)\");\n+  else if (DECL_INITIAL (field) != NULL_TREE)\n+    warning (\"duplicate ConstanValue atribute for field '%s'\",\n+\t     IDENTIFIER_POINTER (DECL_NAME (field)));\n+  else\n+    DECL_INITIAL (field) = constant;\n+}\n+\n+/* Count the number of Unicode chars encoded in a given Ut8 string. */\n+\n+int\n+strLengthUtf8 (str, len)\n+     char *str;\n+     int len;\n+{\n+  register unsigned char* ptr = (unsigned char*) str;\n+  register unsigned char *limit = ptr + len;\n+  int str_length = 0;\n+  for (; ptr < limit; str_length++) {\n+    if (UTF8_GET (ptr, limit) < 0)\n+      return -1;\n+  }\n+  return str_length;\n+}\n+\n+\n+/* Calculate a hash value for a string encoded in Utf8 format.\n+ * This returns the same hash value as specified for java.lang.String.hashCode.\n+ */\n+\n+int32\n+hashUtf8String (str, len)\n+     char *str;\n+     int len;\n+{\n+  register unsigned char* ptr = (unsigned char*) str;\n+  register unsigned char *limit = ptr + len;\n+  int32 hash = 0;\n+  for (; ptr < limit;)\n+    {\n+      int ch = UTF8_GET (ptr, limit);\n+      /* Updated specification from\n+\t http://www.javasoft.com/docs/books/jls/clarify.html. */\n+      hash = (31 * hash) + ch;\n+    }\n+  return hash;\n+}\n+\n+tree utf8_decl_list = NULL_TREE;\n+\n+tree\n+build_utf8_ref (name)\n+     tree name;\n+{\n+  char* name_ptr = IDENTIFIER_POINTER(name);\n+  int name_len = IDENTIFIER_LENGTH(name);\n+  char buf[60];\n+  char *buf_ptr;\n+  tree ctype, field, str_type, cinit, string;\n+  static int utf8_count = 0;\n+  int name_hash;\n+  tree ref = IDENTIFIER_UTF8_REF (name);\n+  tree decl;\n+  if (ref != NULL_TREE)\n+    return ref;\n+\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  ctype = make_node (RECORD_TYPE);\n+  str_type = build_prim_array_type (unsigned_byte_type_node,\n+\t\t\t\t    name_len + 1); /* Allow for final '\\0'. */\n+  PUSH_FIELD (ctype, field, \"hash\", unsigned_short_type_node);\n+  PUSH_FIELD (ctype, field, \"length\", unsigned_short_type_node);\n+  PUSH_FIELD (ctype, field, \"data\", str_type);\n+  FINISH_RECORD (ctype);\n+  START_RECORD_CONSTRUCTOR (cinit, ctype);\n+  name_hash = hashUtf8String (name_ptr, name_len) & 0xFFFF;\n+  PUSH_FIELD_VALUE (cinit, \"hash\", build_int_2 (name_hash, 0));\n+  PUSH_FIELD_VALUE (cinit, \"length\", build_int_2 (name_len, 0));\n+  string = build_string (name_len, name_ptr);\n+  TREE_TYPE (string) = str_type;\n+  PUSH_FIELD_VALUE (cinit, \"data\", string);\n+  FINISH_RECORD_CONSTRUCTOR (cinit);\n+\n+  /* Build a unique identifier based on buf. */\n+  sprintf(buf, \"_Utf%d\", ++utf8_count);\n+  buf_ptr = &buf[strlen (buf)];\n+  while (--name_len >= 0)\n+    {\n+      char c = *name_ptr++;\n+      if (c & 0x80)\n+\tcontinue;\n+      if (!isalpha(c) && !isdigit(c))\n+\tc = '_';\n+      *buf_ptr++ = c;\n+      if (buf_ptr >= buf + 50)\n+\tbreak;\n+    }\n+  *buf_ptr = '\\0';\n+\n+  decl = build_decl (VAR_DECL, get_identifier (buf), utf8const_type);\n+  /* FIXME get some way to force this into .text, not .data. */\n+  TREE_STATIC (decl) = 1;\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_IGNORED_P (decl) = 1;\n+  TREE_READONLY (decl) = 1;\n+  DECL_INITIAL (decl) = cinit;\n+  TREE_CHAIN (decl) = utf8_decl_list;\n+  layout_decl (decl, 0);\n+  pushdecl (decl);\n+  rest_of_decl_compilation (decl, (char*) 0, global_bindings_p (), 0);\n+  utf8_decl_list = decl;\n+  make_decl_rtl (decl, (char*) 0, 1);\n+  ref = build1 (ADDR_EXPR, utf8const_ptr_type, decl);\n+  IDENTIFIER_UTF8_REF (name) = ref;\n+  pop_obstacks ();\n+  return ref;\n+}\n+\n+/* Build a reference to the class TYPE.\n+   Also handles primitive types and array types. */\n+\n+tree\n+build_class_ref (type)\n+     tree type;\n+{\n+  int is_compiled = is_compiled_class (type);\n+  if (is_compiled)\n+    {\n+      tree ref, decl_name, decl;\n+      if (TREE_CODE (type) == POINTER_TYPE)\n+\ttype = TREE_TYPE (type);\n+      if (TREE_CODE (type) == RECORD_TYPE)\n+\t{\n+\t  if (TYPE_SIZE (type) == error_mark_node)\n+\t    return null_pointer_node;\n+\t  decl_name = identifier_subst (DECL_NAME (TYPE_NAME (type)),\n+\t\t\t\t\t\"\", '/', '/', \".class\");\n+\t  decl = IDENTIFIER_GLOBAL_VALUE (decl_name);\n+\t  if (decl == NULL_TREE)\n+\t    {\n+\t      push_obstacks (&permanent_obstack, &permanent_obstack);\n+\t      decl = build_decl (VAR_DECL, decl_name, class_type_node);\n+\t      DECL_SIZE (decl) = TYPE_SIZE (class_type_node);\n+\t      TREE_STATIC (decl) = 1;\n+\t      TREE_PUBLIC (decl) = 1;\n+\t      DECL_IGNORED_P (decl) = 1;\n+\t      DECL_ARTIFICIAL (decl) = 1;\n+\t      DECL_ASSEMBLER_NAME (decl) = mangle_class_field (type);\n+\t      make_decl_rtl (decl, NULL, 1);\n+\t      pushdecl_top_level (decl);\n+\t      if (is_compiled == 1)\n+\t\tDECL_EXTERNAL (decl) = 1;\n+\t      pop_obstacks ();\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  char *name;\n+\t  char buffer[20];\n+\t  decl_name = TYPE_NAME (type);\n+\t  if (TREE_CODE (decl_name) == TYPE_DECL)\n+\t    decl_name = DECL_NAME (decl_name);\n+\t  name = IDENTIFIER_POINTER (decl_name);\n+\t  if (strncmp (name, \"promoted_\", 9) == 0)\n+\t    name += 9;\n+\t  sprintf (buffer, \"%sClass\", name);\n+\t  decl_name = get_identifier (buffer);\n+\t  decl = IDENTIFIER_GLOBAL_VALUE (decl_name);\n+\t  if (decl == NULL_TREE)\n+\t    {\n+\t      push_obstacks (&permanent_obstack, &permanent_obstack);\n+\t      decl = build_decl (VAR_DECL, decl_name, class_type_node);\n+\t      TREE_STATIC (decl) = 1;\n+\t      TREE_PUBLIC (decl) = 1;\n+\t      make_decl_rtl (decl, NULL, 1);\n+\t      pushdecl_top_level (decl);\n+\t      if (is_compiled == 1)\n+\t\tDECL_EXTERNAL (decl) = 1;\n+\t      pop_obstacks ();\n+\t    }\n+\t}\n+\n+      ref = build1 (ADDR_EXPR, class_ptr_type, decl);\n+      return ref;\n+    }\n+  else\n+    {\n+      int index;\n+      tree cl;\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+      index = alloc_class_constant (type);\n+      cl = build_ref_from_constant_pool (index); \n+      TREE_TYPE (cl) = promote_type (class_ptr_type);\n+      pop_obstacks ();\n+      return cl;\n+    }\n+}\n+\n+tree\n+build_static_field_ref (fdecl)\n+     tree fdecl;\n+{\n+  tree fclass = DECL_CONTEXT (fdecl);\n+  int is_compiled = is_compiled_class (fclass);\n+  if (is_compiled)\n+    {\n+      if (DECL_RTL (fdecl) == 0)\n+\t{\n+\t  push_obstacks (&permanent_obstack, &permanent_obstack);\n+\t  make_decl_rtl (fdecl, NULL, 1);\n+\t  pop_obstacks ();\n+\t  if (is_compiled == 1)\n+\t    DECL_EXTERNAL (fdecl) = 1;\n+\t}\n+      return fdecl;\n+    }\n+  else\n+    {\n+      /* Compile as:\n+       * *(FTYPE*)build_class_ref(FCLASS)->fields[INDEX].info.addr\n+       */\n+      static tree fields_ident = NULL_TREE;\n+      static tree info_ident = NULL_TREE;\n+      tree ref = build_class_ref (fclass);\n+      tree fld;\n+      int field_index = 0;\n+      ref = build1 (INDIRECT_REF, class_type_node, ref);\n+      if (fields_ident == NULL_TREE)\n+\tfields_ident = get_identifier (\"fields\");\n+      if (info_ident == NULL_TREE)\n+\tinfo_ident = get_identifier (\"info\");\n+      ref = build (COMPONENT_REF, field_ptr_type_node, ref,\n+\t\t   lookup_field (&class_type_node, fields_ident));\n+\n+      for (fld = TYPE_FIELDS (fclass); ; fld = TREE_CHAIN (fld))\n+\t{\n+\t  if (fld == fdecl)\n+\t    break;\n+\t  if (fld == NULL_TREE)\n+\t    fatal (\"field '%s' not found in class\",\n+\t\t   IDENTIFIER_POINTER (DECL_NAME (fdecl)));\n+\t  if (FIELD_STATIC (fld))\n+\t    field_index++;\n+\t}\n+      field_index *= int_size_in_bytes (field_type_node);\n+      ref = fold (build (PLUS_EXPR, field_ptr_type_node,\n+\t\t\t ref, build_int_2 (field_index, 0)));\n+      ref = build1 (INDIRECT_REF, field_type_node, ref);\n+      ref = build (COMPONENT_REF, field_info_union_node,\n+\t\t   ref, lookup_field (&field_type_node, info_ident));\n+      ref = build (COMPONENT_REF, ptr_type_node,\n+\t\t   ref, TREE_CHAIN (TYPE_FIELDS (field_info_union_node)));\n+      return fold (build1 (INDIRECT_REF, TREE_TYPE(fdecl), ref));\n+    }\n+}\n+\n+int\n+get_access_flags_from_decl (decl)\n+     tree decl;\n+{\n+  int access_flags = 0;\n+  if (TREE_CODE (decl) == FIELD_DECL || TREE_CODE (decl) == VAR_DECL)\n+    {\n+      if (FIELD_STATIC (decl))\n+\taccess_flags |= ACC_STATIC;\n+      if (FIELD_PUBLIC (decl))\n+\taccess_flags |= ACC_PUBLIC;\n+      if (FIELD_PROTECTED (decl))\n+\taccess_flags |= ACC_PROTECTED;\n+      if (FIELD_PRIVATE (decl))\n+\taccess_flags |= ACC_PRIVATE;\n+      if (FIELD_FINAL (decl))\n+\taccess_flags |= ACC_FINAL;\n+      if (FIELD_VOLATILE (decl))\n+\taccess_flags |= ACC_VOLATILE;\n+      if (FIELD_TRANSIENT (decl))\n+\taccess_flags |= ACC_TRANSIENT;\n+      return access_flags;\n+    }\n+  if (TREE_CODE (decl) == TYPE_DECL)\n+    {\n+      if (CLASS_PUBLIC (decl))\n+\taccess_flags |= ACC_PUBLIC;\n+      if (CLASS_FINAL (decl))\n+\taccess_flags |= ACC_FINAL;\n+      if (CLASS_SUPER (decl))\n+\taccess_flags |= ACC_SUPER;\n+      if (CLASS_INTERFACE (decl))\n+\taccess_flags |= ACC_INTERFACE;\n+      if (CLASS_ABSTRACT (decl))\n+\taccess_flags |= ACC_ABSTRACT;\n+      return access_flags;\n+    }\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      if (METHOD_PUBLIC (decl))\n+\taccess_flags |= ACC_PUBLIC;\n+      if (METHOD_PRIVATE (decl))\n+\taccess_flags |= ACC_PRIVATE;\n+      if (METHOD_PROTECTED (decl))\n+\taccess_flags |= ACC_PROTECTED;\n+      if (METHOD_STATIC (decl))\n+\taccess_flags |= ACC_STATIC;\n+      if (METHOD_FINAL (decl))\n+\taccess_flags |= ACC_FINAL;\n+      if (METHOD_SYNCHRONIZED (decl))\n+\taccess_flags |= ACC_SYNCHRONIZED;\n+      if (METHOD_NATIVE (decl))\n+\taccess_flags |= ACC_NATIVE;\n+      if (METHOD_ABSTRACT (decl))\n+\taccess_flags |= ACC_ABSTRACT;\n+      if (METHOD_TRANSIENT (decl))\n+\taccess_flags |= ACC_TRANSIENT;\n+      return access_flags;\n+    }\n+  abort ();\n+}\n+\n+tree\n+make_field_value (tree fdecl)\n+{\n+  tree finit, info;\n+  int bsize, flags;\n+  tree type = TREE_TYPE (fdecl);\n+  int resolved = is_compiled_class (type);\n+  START_RECORD_CONSTRUCTOR (finit, field_type_node);\n+  PUSH_FIELD_VALUE (finit, \"name\", build_utf8_ref (DECL_NAME (fdecl)));\n+  if (resolved)\n+    type = build_class_ref (type);\n+  else\n+    type = build_utf8_ref (build_java_signature (type));\n+  PUSH_FIELD_VALUE (finit, \"type\", type);\n+  flags = get_access_flags_from_decl (fdecl);\n+  if (! resolved)\n+    flags |= 0x8000 /* FIELD_UNRESOLVED_FLAG */;\n+  PUSH_FIELD_VALUE (finit, \"accflags\", build_int_2 (flags, 0));\n+  bsize = TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (fdecl))) / BITS_PER_UNIT;\n+  PUSH_FIELD_VALUE (finit, \"bsize\", build_int_2 (bsize, 0));\n+  if (FIELD_STATIC (fdecl))\n+    {\n+      tree cfield = TREE_CHAIN (TYPE_FIELDS(field_info_union_node));\n+      tree faddr = build_address_of (build_static_field_ref (fdecl));\n+      info = build (CONSTRUCTOR, field_info_union_node, NULL_TREE,\n+\t\t    build_tree_list (cfield, faddr));\n+    }\n+  else\n+    {\n+      int boffset\n+\t= TREE_INT_CST_LOW (DECL_FIELD_BITPOS (fdecl)) / BITS_PER_UNIT;\n+      info = build (CONSTRUCTOR, field_info_union_node, NULL_TREE,\n+\t\t    build_tree_list (TYPE_FIELDS(field_info_union_node),\n+\t\t\t\t     build_int_2 (boffset, 0)));\n+    }\n+  PUSH_FIELD_VALUE (finit, \"info\", info);\n+\n+  FINISH_RECORD_CONSTRUCTOR (finit);\n+  return finit;\n+}\n+\n+tree\n+make_method_value (mdecl, this_class_addr)\n+     tree mdecl;\n+     tree this_class_addr;\n+{\n+  tree minit;\n+  tree code;\n+#define ACC_TRANSLATED          0x4000\n+  int accflags = get_access_flags_from_decl (mdecl) | ACC_TRANSLATED;\n+  code = null_pointer_node;\n+  if (DECL_RTL (mdecl))\n+    code = build1 (ADDR_EXPR, nativecode_ptr_type_node, mdecl);\n+  START_RECORD_CONSTRUCTOR (minit, method_type_node);\n+  PUSH_FIELD_VALUE (minit, \"name\",\n+\t\t    build_utf8_ref (DECL_CONSTRUCTOR_P (mdecl) ?\n+\t\t\t\t    init_identifier_node\n+\t\t\t\t    : DECL_NAME (mdecl)));\n+  PUSH_FIELD_VALUE (minit, \"signature\",\n+\t\t    build_utf8_ref (build_java_signature (TREE_TYPE (mdecl))));\n+  PUSH_FIELD_VALUE (minit, \"accflags\", build_int_2 (accflags, 0));\n+  PUSH_FIELD_VALUE (minit, \"ncode\", code);\n+  FINISH_RECORD_CONSTRUCTOR (minit);\n+  return minit;\n+}\n+\n+tree\n+get_dispatch_vector (type)\n+     tree type;\n+{\n+  tree vtable = TYPE_VTABLE (type);\n+  if (vtable == NULL)\n+    {\n+      int i;\n+      tree method;\n+      tree super = CLASSTYPE_SUPER (type);\n+      int nvirtuals = TREE_INT_CST_LOW (TYPE_NVIRTUALS (type));\n+      vtable = make_tree_vec (nvirtuals);\n+      TYPE_VTABLE (type) = vtable;\n+      if (super != NULL_TREE)\n+\t{\n+\t  tree super_vtable = get_dispatch_vector (super);\n+\t  for ( i = TREE_INT_CST_LOW (TYPE_NVIRTUALS (super));  --i >= 0; )\n+\t    TREE_VEC_ELT (vtable, i) = TREE_VEC_ELT (super_vtable, i);\n+\t}\n+      for (method = TYPE_METHODS (type);  method != NULL_TREE;\n+\t   method = TREE_CHAIN (method))\n+\t{\n+\t  if (DECL_VINDEX (method) != NULL_TREE\n+\t      && TREE_CODE (DECL_VINDEX (method)) == INTEGER_CST)\n+\t    {\n+\t      TREE_VEC_ELT (vtable, TREE_INT_CST_LOW (DECL_VINDEX (method)))\n+\t\t= method;\n+\t    }\n+\t}\n+    }\n+  return vtable;\n+}\n+\n+tree\n+get_dispatch_table (type, this_class_addr)\n+     tree type, this_class_addr;\n+{\n+  tree vtable = get_dispatch_vector (type);\n+  int i;\n+  tree list = NULL_TREE;\n+  int nvirtuals = TREE_VEC_LENGTH (vtable);\n+  for (i = nvirtuals;  --i >= 0; )\n+    {\n+      tree method = TREE_VEC_ELT (vtable, i);\n+      if (METHOD_ABSTRACT (method))\n+\twarning_with_decl (method, \"abstract method in non-abstract class\");\n+      if (DECL_RTL (method) == 0)\n+\tmake_decl_rtl (method, NULL, 1);\n+      list = tree_cons (NULL_TREE /*DECL_VINDEX (method) + 2*/,\n+\t\t\tbuild1 (ADDR_EXPR, nativecode_ptr_type_node, method),\n+\t\t\tlist);\n+    }\n+  /* Dummy entry for compatibility with G++ -fvtable-thunks. */\n+  list = tree_cons (integer_zero_node, null_pointer_node, list);\n+  list = tree_cons (integer_zero_node, this_class_addr, list);\n+  return build (CONSTRUCTOR, build_prim_array_type (nativecode_ptr_type_node,\n+\t\t\t\t\t\t    nvirtuals + 2),\n+\t\t NULL_TREE, list);\n+}\n+\n+void\n+make_class_data (type)\n+     tree type;\n+{\n+  tree decl, cons, temp;\n+  tree field, fields_decl;\n+  tree static_fields = NULL_TREE;\n+  tree instance_fields = NULL_TREE;\n+  HOST_WIDE_INT static_field_count = 0;\n+  HOST_WIDE_INT instance_field_count = 0;\n+  HOST_WIDE_INT field_count;\n+  tree field_array_type;\n+  tree method;\n+  tree methods = NULL_TREE;\n+  tree dtable_decl = NULL_TREE;\n+  HOST_WIDE_INT method_count = 0;\n+  tree method_array_type;\n+  tree methods_decl;\n+  tree super;\n+  tree this_class_addr;\n+  tree constant_pool_constructor;\n+  tree interfaces = null_pointer_node;\n+  int interface_len = 0;\n+  tree type_decl = TYPE_NAME (type);\n+\n+  this_class_addr = build_class_ref (type);\n+  decl = TREE_OPERAND (this_class_addr, 0);\n+\n+  /* Build Field array. */\n+  field = TYPE_FIELDS (type);\n+  if (DECL_NAME (field) == NULL_TREE)\n+    field = TREE_CHAIN (field);  /* Skip dummy field for inherited data. */\n+  for ( ;  field != NULL_TREE;  field = TREE_CHAIN (field))\n+    {\n+      if (! DECL_ARTIFICIAL (field))\n+\t{\n+\t  tree init = make_field_value (field);\n+\t  if (FIELD_STATIC (field))\n+\t    {\n+\t      static_field_count++;\n+\t      static_fields = tree_cons (NULL_TREE, init, static_fields);\n+\t      rest_of_decl_compilation (field, (char*) 0, 1, 1);\n+\t    }\n+\t  else\n+\t    {\n+\t      instance_field_count++;\n+\t      instance_fields = tree_cons (NULL_TREE, init, instance_fields);\n+\t    }\n+\t}\n+    }\n+  field_count = static_field_count + instance_field_count;\n+  if (field_count > 0)\n+    {\n+      static_fields = nreverse (static_fields);\n+      instance_fields = nreverse (instance_fields);\n+      static_fields = chainon (static_fields, instance_fields);\n+      field_array_type = build_prim_array_type (field_type_node, field_count);\n+      fields_decl = build_decl (VAR_DECL, mangled_classname (\"_FL_\", type),\n+\t\t\t\tfield_array_type);\n+      DECL_INITIAL (fields_decl) = build (CONSTRUCTOR, field_array_type,\n+\t\t\t\t\t  NULL_TREE, static_fields);\n+      TREE_STATIC (fields_decl) = 1;\n+      DECL_ARTIFICIAL (fields_decl) = 1;\n+      DECL_IGNORED_P (fields_decl) = 1;\n+      rest_of_decl_compilation (fields_decl, (char*) 0, 1, 0);\n+    }\n+  else\n+    fields_decl = NULL_TREE;\n+\n+  /* Build Method array. */\n+  for (method = TYPE_METHODS (CLASS_TO_HANDLE_TYPE (type));\n+       method != NULL_TREE; method = TREE_CHAIN (method))\n+    {\n+      tree init = make_method_value (method, this_class_addr);\n+      method_count++;\n+      methods = tree_cons (NULL_TREE, init, methods);\n+    }\n+  method_array_type = build_prim_array_type (method_type_node, method_count);\n+  methods_decl = build_decl (VAR_DECL, mangled_classname (\"_MT_\", type),\n+\t\t\t     method_array_type);\n+  DECL_INITIAL (methods_decl) = build (CONSTRUCTOR, method_array_type,\n+\t\t\t\t       NULL_TREE, nreverse (methods));\n+  TREE_STATIC (methods_decl) = 1;\n+  DECL_ARTIFICIAL (methods_decl) = 1;\n+  DECL_IGNORED_P (methods_decl) = 1;\n+  rest_of_decl_compilation (methods_decl, (char*) 0, 1, 0);\n+\n+  if (flag_assume_compiled\n+      && ! CLASS_ABSTRACT (type_decl) && ! CLASS_INTERFACE (type_decl))\n+    {\n+      tree dtable = get_dispatch_table (type, this_class_addr);\n+      dtable_decl = build_dtable_decl (type);\n+      DECL_INITIAL (dtable_decl) = dtable;\n+      TREE_STATIC (dtable_decl) = 1;\n+      DECL_ARTIFICIAL (dtable_decl) = 1;\n+      DECL_IGNORED_P (dtable_decl) = 1;\n+      TREE_PUBLIC (dtable_decl) = 1;\n+      rest_of_decl_compilation (dtable_decl, (char*) 0, 1, 0);\n+    }\n+\n+  super = CLASSTYPE_SUPER (type);\n+  if (super == NULL_TREE)\n+    super = null_pointer_node;\n+  else if (flag_assume_compiled)\n+    super = build_class_ref (super);\n+  else\n+    {\n+      int super_index = alloc_class_constant (super);\n+      super = build_int_2 (super_index, 0);\n+      TREE_TYPE (super) == ptr_type_node;\n+    }\n+\n+  /* Build and emit the array of implemented interfaces. */\n+  if (type != object_type_node)\n+      interface_len = TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (type)) - 1;\n+  if (interface_len > 0)\n+    {\n+      tree init = NULL_TREE;\n+      int i;\n+      tree interface_array_type, idecl;\n+      interface_array_type\n+\t= build_prim_array_type (class_ptr_type, interface_len);\n+      idecl = build_decl (VAR_DECL, mangled_classname (\"_IF_\", type),\n+\t\t\t  interface_array_type);\n+      for (i = interface_len;  i > 0; i--)\n+\t{\n+\t  tree child = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (type), i);\n+\t  tree iclass = BINFO_TYPE (child);\n+\t  tree index;\n+\t  if (flag_assume_compiled)\n+\t    index = build_class_ref (iclass);\n+\t  else\n+\t    {\n+\t\tint int_index = alloc_class_constant (iclass);\n+\t\tindex = build_int_2 (int_index, 0);\n+\t\tTREE_TYPE (index) == ptr_type_node;\n+\t    }\n+\t  init = tree_cons (NULL_TREE, index, init); \n+\t}\n+      DECL_INITIAL (idecl) = build (CONSTRUCTOR, interface_array_type,\n+\t\t\t\t    NULL_TREE, init);\n+      TREE_STATIC (idecl) = 1;\n+      DECL_ARTIFICIAL (idecl) = 1;\n+      DECL_IGNORED_P (idecl) = 1;\n+      interfaces = build1 (ADDR_EXPR, ptr_type_node, idecl);\n+      rest_of_decl_compilation (idecl,  (char*) 0, 1, 0);\n+    }\n+\n+  constant_pool_constructor = build_constants_constructor ();\n+\n+  START_RECORD_CONSTRUCTOR (temp, object_type_node);\n+#if 0\n+  PUSH_FIELD_VALUE (temp, \"dtable\", NULL_TREE);\n+#else\n+  PUSH_FIELD_VALUE (temp, \"dtable\",\n+\t\t    build1 (ADDR_EXPR, dtable_ptr_type, class_dtable_decl));\n+#endif\n+  PUSH_FIELD_VALUE (temp, \"sync_info\", null_pointer_node);\n+  FINISH_RECORD_CONSTRUCTOR (temp);\n+  START_RECORD_CONSTRUCTOR (cons, class_type_node);\n+  PUSH_SUPER_VALUE (cons, temp);\n+  PUSH_FIELD_VALUE (cons, \"next\", null_pointer_node);\n+  PUSH_FIELD_VALUE (cons, \"name\",\n+\t\t    build_utf8_ref (build_internal_class_name (type)));\n+  PUSH_FIELD_VALUE (cons, \"accflags\",\n+\t\t    build_int_2 (get_access_flags_from_decl (type_decl), 0));\n+\n+  PUSH_FIELD_VALUE (cons, \"superclass\", super);\n+  PUSH_FIELD_VALUE (cons, \"subclass_head\", null_pointer_node);\n+  PUSH_FIELD_VALUE (cons, \"subclass_next\", null_pointer_node);\n+  PUSH_FIELD_VALUE (cons, \"constants\", constant_pool_constructor);\n+  PUSH_FIELD_VALUE (cons, \"methods\",\n+\t\t    build1 (ADDR_EXPR, method_ptr_type_node, methods_decl));\n+  PUSH_FIELD_VALUE (cons, \"nmethods\",  build_int_2 (method_count, 0));\n+  PUSH_FIELD_VALUE (cons, \"msize\", TYPE_NVIRTUALS (type));\n+  PUSH_FIELD_VALUE (cons, \"fields\",\n+\t\t    fields_decl == NULL_TREE ? null_pointer_node\n+\t\t    : build1 (ADDR_EXPR, field_ptr_type_node, fields_decl));\n+  PUSH_FIELD_VALUE (cons, \"bfsize\", size_in_bytes (type));\n+  PUSH_FIELD_VALUE (cons, \"nfields\", build_int_2 (field_count, 0));\n+  PUSH_FIELD_VALUE (cons, \"nsfields\", build_int_2 (static_field_count, 0));\n+  /* For now, we let Kaffe fill in the dtable.  */\n+  PUSH_FIELD_VALUE (cons, \"dtable\",\n+\t\t    dtable_decl == NULL_TREE ? null_pointer_node\n+\t\t    : build1 (ADDR_EXPR, dtable_ptr_type, dtable_decl));\n+  PUSH_FIELD_VALUE (cons, \"interfaces\", interfaces);\n+  PUSH_FIELD_VALUE (cons, \"loader\", null_pointer_node);\n+  PUSH_FIELD_VALUE (cons, \"interface_len\", build_int_2 (interface_len, 0));\n+  PUSH_FIELD_VALUE (cons, \"state\",\n+\t\t    flag_assume_compiled ? integer_four_node\n+\t\t    : integer_two_node);\n+\n+  method = lookup_java_method (type,\n+\t\t\t       finalize_identifier_node, void_signature_node);\n+  PUSH_FIELD_VALUE (cons, \"final\",\n+\t\t    method == NULL ? integer_zero_node : integer_one_node);\n+\n+  FINISH_RECORD_CONSTRUCTOR (cons);\n+\n+  DECL_INITIAL (decl) = cons;\n+  rest_of_decl_compilation (decl, (char*) 0, 1, 0);\n+}\n+\n+/* Return 2 if CLASS is compiled by this compilation job;\n+   return 1 if CLASS can otherwise be assumed to be compiled;\n+   return 0 if we cannot assume that CLASS is compiled.\n+   Returns 1 for primitive and 0 for array types.  */\n+int\n+is_compiled_class (class)\n+     tree class;\n+{\n+  if (TREE_CODE (class) == POINTER_TYPE)\n+    class = TREE_TYPE (class);\n+  if (TREE_CODE (class) != RECORD_TYPE)  /* Primitive types are static. */\n+    return 1;\n+  if (TYPE_ARRAY_P (class))\n+    return 0;\n+  if (class == current_class)\n+    return 2;\n+  if ((TYPE_LANG_SPECIFIC (class) &&  TYPE_LANG_SPECIFIC (class)->jcf && \n+       TYPE_LANG_SPECIFIC (class)->jcf->seen_in_zip))\n+    {\n+      /* The class was seen in the current ZIP file and will be\n+\t available as a compiled class in the future but may not have\n+\t been loaded already. Load it if necessary. This prevent\n+\t build_class_ref () from crashing.  This should take into\n+\t consideration class specified in a multiple class file\n+\t command line. FIXME if necessary.  */\n+\n+      if (!CLASS_LOADED_P (class))\n+        load_class (class, 1);\n+      return 2;\n+    }\n+\n+  if (flag_assume_compiled)\n+    {\n+      if (!CLASS_LOADED_P (class))\n+\tload_class (class, 1);\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Append the mangled name of TYPE onto OBSTACK. */\n+\n+void\n+append_gpp_mangled_type (obstack, type)\n+     struct obstack *obstack;\n+     tree type;\n+{\n+  char buf[8];\n+  int len;\n+  char *ptr;\n+  switch (TREE_CODE (type))\n+    {\n+      char code;\n+    case BOOLEAN_TYPE: code = 'b';  goto primitive;\n+    case CHAR_TYPE:    code = 'w';  goto primitive;\n+    case VOID_TYPE:    code = 'v';  goto primitive;\n+    case INTEGER_TYPE:\n+      /* Get the original type instead of the arguments promoted type.\n+\t Avoid symbol name clashes. Should call a function to do that.\n+\t FIXME.  */\n+      if (type == promoted_short_type_node)\n+\ttype = short_type_node;\n+      if (type == promoted_byte_type_node)\n+        type = byte_type_node;\n+      switch (TYPE_PRECISION (type))\n+\t{\n+\tcase  8:       code = 'c';  goto primitive;\n+\tcase 16:       code = 's';  goto primitive;\n+\tcase 32:       code = 'i';  goto primitive;\n+\tcase 64:       code = 'x';  goto primitive;\n+\tdefault:  goto bad_type;\n+\t}\n+    primitive:\n+      obstack_1grow (obstack, code);\n+      break;\n+    case REAL_TYPE:\n+      switch (TYPE_PRECISION (type))\n+\t{\n+\tcase 32:       code = 'f';  goto primitive;\n+\tcase 64:       code = 'd';  goto primitive;\n+\tdefault:  goto bad_type;\n+\t}\n+    case POINTER_TYPE:\n+      type = TREE_TYPE (type);\n+      obstack_1grow (obstack, 'P');\n+    case RECORD_TYPE:\n+      if (TYPE_ARRAY_P (type))\n+\t{\n+\t  obstack_grow (obstack, \"t6JArray1Z\", sizeof(\"t6JArray1Z\")-1);\n+\t  append_gpp_mangled_type (obstack, TYPE_ARRAY_ELEMENT (type));\n+\t}\n+      else\n+\t{\n+\t  char *class_name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n+\t  append_gpp_mangled_classtype (obstack, class_name);\n+\t}\n+      break;\n+    bad_type:\n+    default:\n+      fatal (\"internal error - trying to mangle unknown type\");\n+    }\n+}\n+\n+/* Build the mangled name of the `class' field.  */\n+\n+static tree\n+mangle_class_field (class)\n+     tree class;\n+{\n+  tree name;\n+  obstack_grow (&temporary_obstack, \"_CL_\", 4);\n+  append_gpp_mangled_type (&temporary_obstack, class);\n+  obstack_1grow (&temporary_obstack, '\\0');\n+  name = get_identifier (obstack_base (&temporary_obstack));\n+  obstack_free (&temporary_obstack, obstack_base (&temporary_obstack));\n+  return name;\n+}\n+\n+/* Build the mangled (assembly-level) name of the static field FIELD. */\n+\n+tree\n+mangle_static_field (field)\n+     tree field;\n+{\n+  tree class = DECL_CONTEXT (field);\n+  tree name = DECL_NAME (field);\n+  int encoded_len;\n+#if ! defined (NO_DOLLAR_IN_LABEL) || ! defined (NO_DOT_IN_LABEL)\n+  obstack_1grow (&temporary_obstack, '_');\n+#else\n+  obstack_grow (&temporary_obstack, \"__static_\", 9);\n+#endif\n+  append_gpp_mangled_type (&temporary_obstack, class);\n+  encoded_len = unicode_mangling_length (IDENTIFIER_POINTER (name),\n+\t\t\t\t\t IDENTIFIER_LENGTH (name));\n+  if (encoded_len > 0)\n+    {\n+      obstack_1grow (&temporary_obstack, 'U');\n+    }\n+#ifndef NO_DOLLAR_IN_LABEL\n+  obstack_1grow (&temporary_obstack, '$');\n+#else /* NO_DOLLAR_IN_LABEL */\n+#ifndef NO_DOT_IN_LABEL\n+  obstack_1grow (&temporary_obstack, '.');\n+#else /* NO_DOT_IN_LABEL */\n+  obstack_1grow (&temporary_obstack, '_');\n+#endif  /* NO_DOT_IN_LABEL */\n+#endif  /* NO_DOLLAR_IN_LABEL */\n+  if (encoded_len > 0)\n+    {\n+      emit_unicode_mangled_name (&temporary_obstack,\n+\t\t\t\t IDENTIFIER_POINTER (name), \n+\t\t\t\t IDENTIFIER_LENGTH (name));\n+    }\n+  else\n+    {\n+      obstack_grow (&temporary_obstack,\n+\t\t    IDENTIFIER_POINTER (name),\n+\t\t    IDENTIFIER_LENGTH (name));\n+    }\n+  obstack_1grow (&temporary_obstack, '\\0');\n+  name = get_identifier (obstack_base (&temporary_obstack));\n+  obstack_free (&temporary_obstack, obstack_base (&temporary_obstack));\n+  return name;\n+}\n+\n+/* Build a VAR_DECL for the dispatch table (vtable) for class TYPE. */\n+\n+tree\n+build_dtable_decl (type)\n+     tree type;\n+{\n+  tree name;\n+  obstack_grow (&temporary_obstack, \"__vt_\", 5);\n+  append_gpp_mangled_type (&temporary_obstack, type);\n+  obstack_1grow (&temporary_obstack, '\\0');\n+  name = get_identifier (obstack_base (&temporary_obstack));\n+  obstack_free (&temporary_obstack, obstack_base (&temporary_obstack));\n+  return build_decl (VAR_DECL, name, dtable_type);\n+}\n+\n+/* Pre-pend the TYPE_FIELDS of THIS_CLASS with a dummy FIELD_DECL for the\n+   fields inherited from SUPER_CLASS. */\n+\n+void\n+push_super_field (this_class, super_class)\n+     tree this_class, super_class;\n+{\n+  tree base_decl;\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  base_decl = build_decl (FIELD_DECL, NULL_TREE, super_class);\n+  pop_obstacks ();\n+  DECL_IGNORED_P (base_decl) = 1;\n+  TREE_CHAIN (base_decl) = TYPE_FIELDS (this_class);\n+  TYPE_FIELDS (this_class) = base_decl;\n+  DECL_SIZE (base_decl) = TYPE_SIZE (super_class);\n+}\n+\n+void\n+layout_class (this_class)\n+     tree this_class;\n+{\n+  tree super_class = CLASSTYPE_SUPER (this_class);\n+  tree handle_type = CLASS_TO_HANDLE_TYPE (this_class);\n+  tree method_decl, field;\n+  tree dtable_count;\n+  int i;\n+\n+  if (super_class)\n+    {\n+      /* Class seen in source are now complete and can be layed out.\n+\t Once layed out, a class seen in the source has its\n+\t CLASS_LOADED_P flag set */\n+      if (CLASS_FROM_SOURCE_P (super_class) && !CLASS_LOADED_P (super_class))\n+\tsafe_layout_class (super_class);\n+      if (! CLASS_LOADED_P (super_class))\n+\tload_class (super_class, 1);\n+      if (TREE_CODE (TYPE_SIZE (super_class)) == ERROR_MARK)\n+\t{\n+\t  TYPE_SIZE (this_class) = error_mark_node;\n+\t  return;\n+\t}\n+      dtable_count = TYPE_NVIRTUALS (super_class);\n+\n+      if (TYPE_SIZE (this_class) == NULL_TREE)\n+\tpush_super_field (this_class, super_class);\n+    }\n+  else\n+    {\n+      dtable_count = integer_zero_node;\n+    }\n+\n+  for (field = TYPE_FIELDS (this_class);\n+       field != NULL_TREE;  field = TREE_CHAIN (field))\n+    {\n+      if (FIELD_STATIC (field))\n+\t{\n+\t  /* Set DECL_ASSEMBLER_NAME to something suitably mangled. */\n+\t  DECL_ASSEMBLER_NAME (field) = mangle_static_field (field);\n+\t}\n+    }\n+\n+  layout_type (this_class);\n+\n+  TYPE_METHODS (handle_type) = nreverse (TYPE_METHODS (handle_type));\n+\n+  for (method_decl = TYPE_METHODS (handle_type), i = 0;\n+       method_decl; method_decl = TREE_CHAIN (method_decl), i++)\n+    {\n+      char *ptr;\n+      char buf[8];\n+      char *asm_name;\n+      tree method_name = DECL_NAME (method_decl);\n+#if 1\n+      /* Remove this once we no longer need old (Kaffe / JDK 1.0)  mangling. */\n+      if (! flag_assume_compiled && METHOD_NATIVE (method_decl))\n+\t{\n+\t  for (ptr = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (this_class)));\n+\t       *ptr; )\n+\t    {\n+\t      int ch = *ptr++;\n+\t      if (ch == '.')\n+\t\tch = '_';\n+\t      obstack_1grow (&temporary_obstack, (char) ch);\n+\t    }\n+\t  obstack_1grow (&temporary_obstack, (char) '_');\n+\t  if (method_name == init_identifier_node)\n+\t    obstack_grow (&temporary_obstack, \"INIT\", 4);\n+\t  else\n+\t    obstack_grow (&temporary_obstack,\n+\t\t\t  IDENTIFIER_POINTER (method_name),\n+\t\t\t  IDENTIFIER_LENGTH (method_name));\n+\t}\n+      else\n+#endif\n+\t{\n+\t  int len;  tree arg, arglist, t;\n+\t  int method_name_needs_escapes = 0;\n+\t  if (method_name != init_identifier_node)\n+\t    {\n+\t      int encoded_len\n+\t\t= unicode_mangling_length (IDENTIFIER_POINTER (method_name), \n+\t\t\t\t\t   IDENTIFIER_LENGTH (method_name));\n+\t      if (encoded_len > 0)\n+\t\t{\n+\t\t  method_name_needs_escapes = 1;\n+\t\t  emit_unicode_mangled_name (&temporary_obstack,\n+\t\t\t\t\t     IDENTIFIER_POINTER (method_name), \n+\t\t\t\t\t     IDENTIFIER_LENGTH (method_name));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  obstack_grow (&temporary_obstack,\n+\t\t\t\tIDENTIFIER_POINTER (method_name),\n+\t\t\t\tIDENTIFIER_LENGTH (method_name));\n+\t\t}\n+\t    }\n+\n+\t  obstack_grow (&temporary_obstack, \"__\", 2);\n+\t  append_gpp_mangled_type (&temporary_obstack, this_class);\n+\t  TREE_PUBLIC (method_decl) = 1;\n+\n+\t  t = TREE_TYPE (method_decl);\n+\t  arglist = TYPE_ARG_TYPES (t);\n+\t  if (TREE_CODE (t) == METHOD_TYPE)\n+\t    arglist = TREE_CHAIN (arglist);\n+\t  for (arg = arglist; arg != NULL_TREE;  )\n+\t    {\n+\t      tree a = arglist;\n+\t      tree argtype = TREE_VALUE (arg);\n+\t      int tindex = 1;\n+\t      if (TREE_CODE (argtype) == POINTER_TYPE)\n+\t\t{\n+\t\t  /* This is O(N**2).  Do we care?  Cfr gcc/cp/method.c. */\n+\t\t  while (a != arg && argtype != TREE_VALUE (a))\n+\t\t    a = TREE_CHAIN (a), tindex++;\n+\t\t}\n+\t      else\n+\t\ta = arg;\n+\t      if (a != arg)\n+\t\t{\n+\t\t  char buf[12];\n+\t\t  int nrepeats = 0;\n+\t\t  do\n+\t\t    {\n+\t\t      arg = TREE_CHAIN (arg); nrepeats++;\n+\t\t    }\n+\t\t  while (arg != NULL_TREE && argtype == TREE_VALUE (arg));\n+\t\t  if (nrepeats > 1)\n+\t\t    {\n+\t\t      obstack_1grow (&temporary_obstack, 'N');\n+\t\t      sprintf (buf, \"%d\", nrepeats);\n+\t\t      obstack_grow (&temporary_obstack, buf, strlen (buf));\n+\t\t      if (nrepeats > 9)\n+\t\t\tobstack_1grow (&temporary_obstack, '_');\n+\t\t    }\n+\t\t  else\n+\t\t    obstack_1grow (&temporary_obstack, 'T');\n+\t\t  sprintf (buf, \"%d\", tindex);\n+\t\t  obstack_grow (&temporary_obstack, buf, strlen (buf));\n+\t\t  if (tindex > 9)\n+\t\t    obstack_1grow (&temporary_obstack, '_');\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  append_gpp_mangled_type (&temporary_obstack, argtype);\n+\t\t  arg = TREE_CHAIN (arg);\n+\t\t}\n+\t    }\n+\t  if (method_name_needs_escapes)\n+\t    obstack_1grow (&temporary_obstack, 'U');\n+\t}\n+      obstack_1grow (&temporary_obstack, '\\0');\n+      asm_name = obstack_finish (&temporary_obstack);\n+      DECL_ASSEMBLER_NAME (method_decl) = get_identifier (asm_name);\n+      if (! METHOD_ABSTRACT (method_decl))\n+\tmake_function_rtl (method_decl);\n+      obstack_free (&temporary_obstack, asm_name);\n+\n+      if (method_name == init_identifier_node)\n+\t{\n+\t  char *p = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (this_class)));\n+\t  for (ptr = p; *ptr; )\n+\t    {\n+\t      if (*ptr++ == '.')\n+\t\tp = ptr;\n+\t    }\n+\t  DECL_NAME (method_decl) = get_identifier (p);\n+\t  DECL_CONSTRUCTOR_P (method_decl) = 1;\n+\t}\n+      else if (! METHOD_STATIC (method_decl))\n+\t{\n+\t  tree method_sig = build_java_argument_signature (TREE_TYPE (method_decl));\n+\t  tree super_method = lookup_argument_method (super_class, method_name,\n+\t\t\t\t\t\t  method_sig);\n+\t  if (super_method != NULL_TREE)\n+\t    {\n+\t      DECL_VINDEX (method_decl) = DECL_VINDEX (super_method);\n+\t      if (DECL_VINDEX (method_decl) == NULL_TREE)\n+\t\terror_with_decl (method_decl,\n+\t\t\t \"non-static method '%s' overrides static method\");\n+#if 0\n+\t      else if (TREE_TYPE (TREE_TYPE (method_decl))\n+\t\t       != TREE_TYPE (TREE_TYPE (super_method)))\n+\t\t{\n+\t\t  error_with_decl (method_decl,\n+\t\t\t\t \"Method `%s' redefined with different return type\");  \n+\t\t  error_with_decl (super_method,\n+\t\t\t\t \"Overridden decl is here\");\n+\t\t}\n+#endif\n+\t    }\n+\t  else if (! METHOD_FINAL (method_decl)\n+\t\t   && ! CLASS_FINAL (TYPE_NAME (this_class)))\n+\t    {\n+\t      DECL_VINDEX (method_decl) = dtable_count;\n+\t      dtable_count = build_int_2 (1+TREE_INT_CST_LOW (dtable_count), 0);\n+\t    }\n+\t}\n+    }\n+  TYPE_NVIRTUALS (this_class) = dtable_count;\n+\n+#ifdef JAVA_USE_HANDLES\n+  layout_type (handle_type);\n+#endif\n+}\n+\n+static tree registered_class = NULL_TREE;\n+\n+void\n+register_class ()\n+{\n+  static tree end;\n+  tree node    = TREE_OPERAND (build_class_ref (current_class), 0);\n+  tree current = copy_node (node);\n+\n+  XEXP (DECL_RTL (current), 0) = copy_rtx (XEXP (DECL_RTL(node), 0));\n+  if (!registered_class)\n+    registered_class = current;\n+  else\n+    TREE_CHAIN (end) = current;\n+\n+  end = current;\n+}\n+\n+/* Generate a function that gets called at start-up (static contructor) time,\n+   which calls registerClass for all the compiled classes. */\n+\n+void\n+emit_register_class ()\n+{\n+  tree decl = getdecls ();\n+\n+  extern tree get_file_function_name PROTO((int));\n+  tree init_name = get_file_function_name ('I');\n+  tree init_type = build_function_type (void_type_node, NULL_TREE);\n+  tree init_decl;\n+  tree t;\n+\n+  start_sequence ();\n+  init_decl = build_decl (FUNCTION_DECL, init_name, init_type);\n+  DECL_ASSEMBLER_NAME (init_decl) = init_name;\n+  TREE_STATIC (init_decl) = 1;\n+  current_function_decl = init_decl;\n+  DECL_RESULT (init_decl) = build_decl(RESULT_DECL, NULL_TREE, void_type_node);\n+  /*  DECL_EXTERNAL (init_decl) = 1;*/\n+  TREE_PUBLIC (init_decl) = 1;\n+  pushlevel (0);\n+  make_function_rtl (init_decl);\n+  init_function_start (init_decl, input_filename, 0);\n+  expand_function_start (init_decl, 0);\n+\n+  for ( t = registered_class; t; t = TREE_CHAIN (t))\n+    emit_library_call (registerClass_libfunc, 0, VOIDmode, 1,\n+\t\t       XEXP (DECL_RTL (t), 0), Pmode);\n+\n+  expand_function_end (input_filename, 0, 0);\n+  poplevel (1, 0, 1);\n+  { \n+    /* Force generation, even with -O3 or deeper. Gross hack. FIXME */\n+    extern int flag_inline_functions;\n+    int saved_flag = flag_inline_functions;\n+    flag_inline_functions = 0;\t\n+    rest_of_compilation (init_decl);\n+    flag_inline_functions = saved_flag;\n+  }\n+  current_function_decl = NULL_TREE;\n+  assemble_constructor (IDENTIFIER_POINTER (init_name));\n+}\n+\n+void\n+init_class_processing ()\n+{\n+  registerClass_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"registerClass\");\n+}"}, {"sha": "571e65a734bdb8b3358864c583f88a8f3d839513", "filename": "gcc/java/config-lang.in", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconfig-lang.in?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,40 @@\n+# Top level configure fragment for the GNU compiler for the Java(TM)\n+# language.\n+#  Copyright (C) 1994, 1995 Free Software Foundation, Inc.\n+\n+#This file is part of GNU CC.\n+\n+#GNU CC is free software; you can redistribute it and/or modify\n+#it under the terms of the GNU General Public License as published by\n+#the Free Software Foundation; either version 2, or (at your option)\n+#any later version.\n+\n+#GNU CC is distributed in the hope that it will be useful,\n+#but WITHOUT ANY WARRANTY; without even the implied warranty of\n+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+#GNU General Public License for more details.\n+\n+#You should have received a copy of the GNU General Public License\n+#along with GNU CC; see the file COPYING.  If not, write to\n+#the Free Software Foundation, 59 Temple Place - Suite 330,\n+#Boston, MA 02111-1307, USA.\n+\n+#Java and all Java-based marks are trademarks or registered trademarks\n+#of Sun Microsystems, Inc. in the United States and other countries.\n+#The Free Software Foundation is independent of Sun Microsystems, Inc.\n+\n+# Configure looks for the existence of this file to auto-config each language.\n+# We define several parameters used by configure:\n+#\n+# language\t- name of language as it would appear in $(LANGUAGES)\n+# compilers\t- value to add to $(COMPILERS)\n+# stagestuff\t- files to add to $(STAGESTUFF)\n+# diff_excludes\t- files to ignore when building diffs between two versions.\n+\n+language=\"java\"\n+\n+compilers=\"jc1\\$(exeext) jvgenmain\\$(exeext)\"\n+\n+stagestuff=\"jc1\\$(exeext) gcj\\$(exeext) jvgenmain\\$(exeext) gcjh\\$(exeext)\"\n+\n+outputs=java/Makefile"}, {"sha": "696f6841130debf81fe84fa57ff5752e01685095", "filename": "gcc/java/constants.c", "status": "added", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,453 @@\n+/* Handle the constant pool of the Java(TM) Virtual Machine.\n+   Copyright (C) 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA. \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"java-tree.h\"\n+#include \"jcf.h\"\n+#include \"system.h\"\n+\n+extern struct obstack permanent_obstack;\n+\n+/* Set the INDEX'th constant in CPOOL to have the given TAG and VALUE. */\n+\n+void\n+set_constant_entry (cpool, index, tag, value)\n+     CPool *cpool;\n+     int index;\n+     int tag;\n+     jword value;\n+{\n+  if (cpool->data == NULL)\n+    {\n+      cpool->capacity = 100;\n+      cpool->tags = (uint8*) xmalloc (sizeof(uint8) * cpool->capacity);\n+      cpool->data = (jword*) xmalloc (sizeof(jword) * cpool->capacity);\n+      cpool->count = 1;\n+    }\n+  if (index >= cpool->capacity)\n+    {\n+      cpool->capacity *= 2;\n+      if (index >= cpool->capacity)\n+\tcpool->capacity = index + 10;\n+      cpool->tags = (uint8*) xrealloc (cpool->tags,\n+\t\t\t\t       sizeof(uint8) * cpool->capacity);\n+      cpool->data = (jword*) xrealloc (cpool->data,\n+\t\t\t\t       sizeof(jword) * cpool->capacity);\n+    }\n+  if (index >= cpool->count)\n+    cpool->count = index + 1;\n+  cpool->tags[index] = tag;\n+  cpool->data[index] = value;\n+}\n+\n+/* Find (or create) a constant pool entry matching TAG and VALUE. */\n+\n+int\n+find_constant1 (cpool, tag, value)\n+     CPool *cpool;\n+     int tag;\n+     jword value;\n+{\n+  int i;\n+  for (i = cpool->count;  --i > 0; )\n+    {\n+      if (cpool->tags[i] == tag && cpool->data[i] == value)\n+\treturn i;\n+    }\n+  i = cpool->count == 0 ? 1 : cpool->count;\n+  set_constant_entry (cpool, i, tag, value);\n+  return i;\n+}\n+\n+/* Find a double-word constant pool entry matching TAG and WORD1/WORD2. */\n+\n+int\n+find_constant2 (cpool, tag, word1, word2)\n+     CPool *cpool;\n+     int tag;\n+     jword word1, word2;\n+{\n+  int i;\n+  for (i = cpool->count - 1;  --i > 0; )\n+    {\n+      if (cpool->tags[i] == tag\n+\t  && cpool->data[i] == word1\n+\t  && cpool->data[i+1] == word2)\n+\treturn i;\n+    }\n+  i = cpool->count == 0 ? 1 : cpool->count;\n+  set_constant_entry (cpool, i, tag, word1);\n+  set_constant_entry (cpool, i+1, 0, word2);\n+  return i;\n+}\n+\n+int\n+find_utf8_constant (cpool, name)\n+     CPool *cpool;\n+     tree name;\n+{\n+  if (name == NULL_TREE)\n+    return 0;\n+  return find_constant1 (cpool, CONSTANT_Utf8, (jword) name);\n+}\n+\n+int\n+find_class_or_string_constant (cpool, tag, name)\n+     CPool *cpool;\n+     int tag;\n+     tree name;\n+{\n+  int j = find_utf8_constant (cpool, name);\n+  int i;\n+  for (i = cpool->count;  --i > 0; )\n+    {\n+      if (cpool->tags[i] == tag && cpool->data[i] == j)\n+\treturn i;\n+    }\n+  i = cpool->count;\n+  set_constant_entry (cpool, i, tag, (jword) j);\n+  return i;\n+}\n+\n+int\n+find_class_constant (cpool, type)\n+     CPool *cpool;\n+     tree type;\n+{\n+  return find_class_or_string_constant (cpool, CONSTANT_Class,\n+\t\t\t\t\tbuild_internal_class_name (type));\n+}\n+\n+/* Find (or create) a CONSTANT_NameAndType matching NAME and TYPE.\n+   Return its index in the constant pool CPOOL. */\n+\n+int\n+find_name_and_type_constant (cpool, name, type)\n+     CPool *cpool;\n+     tree name;\n+     tree type;\n+{\n+  int name_index = find_utf8_constant (cpool, name);\n+  int type_index = find_utf8_constant (cpool, build_java_signature (type));\n+  return find_constant1 (cpool, CONSTANT_NameAndType,\n+\t\t\t (name_index << 16) | type_index);\n+}\n+\n+/* Find (or create) a CONSTANT_Fieldref for DECL (a FIELD_DECL or VAR_DECL).\n+   Return its index in the constant pool CPOOL. */\n+\n+int\n+find_fieldref_index (cpool, decl)\n+     CPool *cpool;\n+     tree decl;\n+{\n+  int class_index = find_class_constant (cpool, DECL_CONTEXT (decl));\n+  int name_type_index\n+    = find_name_and_type_constant (cpool, DECL_NAME (decl), TREE_TYPE (decl));\n+  return find_constant1 (cpool, CONSTANT_Fieldref,\n+\t\t\t (class_index << 16) | name_type_index);\n+}\n+\n+/* Find (or create) a CONSTANT_Methodref for DECL (a FUNCTION_DECL).\n+   Return its index in the constant pool CPOOL. */\n+\n+int\n+find_methodref_index (cpool, decl)\n+     CPool *cpool;\n+     tree decl;\n+{\n+  int class_index = find_class_constant (cpool, DECL_CONTEXT (decl));\n+  tree name = DECL_CONSTRUCTOR_P (decl) ? init_identifier_node\n+    : DECL_NAME (decl);\n+  int name_type_index\n+    = find_name_and_type_constant (cpool, name, TREE_TYPE (decl));\n+  /* Methodref or INterfacemethodRef - FIXME */\n+  return find_constant1 (cpool, CONSTANT_Methodref,\n+\t\t\t (class_index << 16) | name_type_index);\n+}\n+\n+#define PUT1(X)  (*ptr++ = (X))\n+#define PUT2(X)  (PUT1((X) >> 8), PUT1(X))\n+#define PUT4(X)  (PUT2((X) >> 16), PUT2(X))\n+#define PUTN(P, N)  (bcopy(P, ptr, N), ptr += (N))\n+\n+/* Give the number of bytes needed in a .class file for the CPOOL\n+   constant pool.  Includes the 2-byte constant_pool_count. */\n+\n+int\n+count_constant_pool_bytes (cpool)\n+     CPool *cpool;\n+{\n+  int size = 2;\n+  int i = 1;\n+  jword *datap = &cpool->data[1];;\n+  for ( ;  i < cpool->count;  i++, datap++)\n+    {\n+      size++;\n+      switch (cpool->tags[i])\n+\t{\n+\tcase CONSTANT_NameAndType:\n+\tcase CONSTANT_Fieldref:\n+\tcase CONSTANT_Methodref:\n+\tcase CONSTANT_InterfaceMethodref:\n+\tcase CONSTANT_Float:\n+\tcase CONSTANT_Integer:\n+\t  size += 4;\n+\t  break;\n+\tcase CONSTANT_Class:\n+\tcase CONSTANT_String:\n+\t  size += 2;\n+\t  break;\n+\tcase CONSTANT_Long:\n+\tcase CONSTANT_Double:\n+\t  size += 4;\n+\t  break;\n+\tcase CONSTANT_Utf8:\n+\t  {\n+\t    tree t = (tree) *datap;\n+\t    int len = IDENTIFIER_LENGTH (t);\n+\t    size += len + 2;\n+\t  }\n+\t  break;\n+\t}\n+    }\n+  return size;\n+}\n+\n+/* Write the constant pool CPOOL into BUFFER.\n+   The length of BUFFER is LENGTH, which must match the needed length. */\n+\n+void\n+write_constant_pool (cpool, buffer, length)\n+     CPool *cpool;\n+     unsigned char* buffer;\n+     int length;\n+{\n+  unsigned char* ptr = buffer;\n+  int i = 1;\n+  jword *datap = &cpool->data[1];\n+  PUT2 (cpool->count);\n+  for ( ;  i < cpool->count;  i++, datap++)\n+    {\n+      int tag = cpool->tags[i];\n+      PUT1 (tag);\n+      switch (tag)\n+\t{\n+\tcase CONSTANT_NameAndType:\n+\tcase CONSTANT_Fieldref:\n+\tcase CONSTANT_Methodref:\n+\tcase CONSTANT_InterfaceMethodref:\n+\tcase CONSTANT_Float:\n+\tcase CONSTANT_Integer:\n+\t  PUT4 (*datap);\n+\t  break;\n+\tcase CONSTANT_Class:\n+\tcase CONSTANT_String:\n+\t  PUT2 (*datap);\n+\t  break;\n+\t  break;\n+\tcase CONSTANT_Long:\n+\tcase CONSTANT_Double:\n+\t  PUT4(*datap);\n+\t  i++;\n+\t  datap++;\n+\t  PUT4 (*datap);\n+\t  break;\n+\tcase CONSTANT_Utf8:\n+\t  {\n+\t    tree t = (tree) *datap;\n+\t    int len = IDENTIFIER_LENGTH (t);\n+\t    PUT2 (len);\n+\t    PUTN (IDENTIFIER_POINTER (t), len);\n+\t  }\n+\t  break;\n+\t}\n+    }\n+  if (ptr != buffer + length)\n+    fatal(\"internal error - incorrect constant pool\");\n+}\n+\n+CPool *outgoing_cpool;\n+\n+/* If non-NULL, an ADDR_EXPR referencing a VAR_DECL containing\n+   the constant data array for the current class. */\n+tree current_constant_pool_data_ref;\n+\n+/* A Cache for build_int_2 (CONSTANT_XXX, 0). */\n+static tree tag_nodes[13];\n+\n+tree\n+get_tag_node (tag)\n+     int tag;\n+{\n+  if (tag_nodes[tag] == NULL_TREE)\n+    {\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+      tag_nodes[tag] = build_int_2 (tag, 0);\n+      pop_obstacks ();\n+    }\n+  return tag_nodes[tag];\n+}\n+\n+/* Look for a constant pool entry that matches TAG and NAME.\n+   Creates a new entry if not found.\n+   TAG is one of CONSTANT_Utf8, CONSTANT_String or CONSTANT_Class.\n+   NAME is an IDENTIFIER_NODE naming the Utf8 constant, string, or class.\n+   Returns the index of the entry. */\n+\n+int\n+alloc_name_constant (tag, name)\n+     int tag;\n+     tree name;\n+{\n+  return find_constant1 (outgoing_cpool, tag, (jword) name);\n+}\n+\n+/* Build an identifier for the internal name of reference type TYPE. */\n+\n+tree\n+build_internal_class_name (type)\n+     tree type;\n+{\n+  tree name;\n+  if (TYPE_ARRAY_P (type))\n+    name = build_java_signature (type);\n+  else\n+    {\n+      name = TYPE_NAME (type);\n+      if (TREE_CODE (name) != IDENTIFIER_NODE)\n+\tname = DECL_NAME (name);\n+      name = identifier_subst (name, \"\", '.', '/', \"\");\n+    }\n+  return name;\n+}\n+\n+/* Look for a CONSTANT_Class entry for CLAS, creating a new one if needed. */\n+\n+int\n+alloc_class_constant (clas)\n+     tree clas;\n+{\n+\n+  return alloc_name_constant (CONSTANT_Class,\n+\t\t\t      build_internal_class_name (clas));\n+}\n+\n+/* Return a reference to the data array of the current constant pool. */\n+\n+tree\n+build_constant_data_ref ()\n+{\n+  if (current_constant_pool_data_ref == NULL_TREE)\n+    {\n+      tree decl;\n+      tree decl_name = mangled_classname (\"_CD_\", current_class);\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+      decl = build_decl (VAR_DECL, decl_name,\n+\t\t\t build_array_type (ptr_type_node,\n+\t\t\t\t\t   one_elt_array_domain_type));\n+      TREE_STATIC (decl) = 1;\n+      make_decl_rtl (decl, NULL, 1);\n+      pop_obstacks ();\n+      current_constant_pool_data_ref\n+\t= build1 (ADDR_EXPR, ptr_type_node, decl);\n+    }\n+  return current_constant_pool_data_ref;\n+}\n+\n+/* Get the pointer value at the INDEX'th element of the constant pool. */\n+\n+tree\n+build_ref_from_constant_pool (index)\n+     int index;\n+{\n+  tree t = build_constant_data_ref ();\n+  index *= int_size_in_bytes (ptr_type_node);\n+  t = fold (build (PLUS_EXPR, ptr_type_node,\n+                              t, build_int_2 (index, 0)));\n+  return build1 (INDIRECT_REF, ptr_type_node, t);\n+}\n+\n+/* Build an initializer for the constants field of the current constal pool.\n+   Should only be called at top-level, since it may emit declarations. */\n+\n+tree\n+build_constants_constructor ()\n+{\n+  tree tags_value, data_value;\n+  tree cons;\n+  tree tags_list = NULL_TREE;\n+  tree data_list = NULL_TREE;\n+  int i;\n+  for (i = outgoing_cpool->count;  --i > 0; )\n+    {\n+      tags_list\n+\t= tree_cons (NULL_TREE, get_tag_node (outgoing_cpool->tags[i]),\n+\t\t     tags_list);\n+      data_list\n+\t= tree_cons (NULL_TREE, build_utf8_ref ((tree)outgoing_cpool->data[i]),\n+\t\t     data_list);\n+    }\n+  if (outgoing_cpool->count > 0)\n+    {\n+      tree index_type;\n+      tree data_decl, tags_decl, tags_type;\n+      tree max_index = build_int_2 (outgoing_cpool->count - 1, 0);\n+      TREE_TYPE (max_index) = sizetype;\n+      index_type = build_index_type (max_index);\n+\n+      /* Add dummy 0'th element of constant pool. */\n+      tags_list = tree_cons (NULL_TREE, get_tag_node (0), tags_list);\n+      data_list = tree_cons (NULL_TREE, null_pointer_node, data_list);\n+  \n+      data_decl = TREE_OPERAND (build_constant_data_ref (), 0);\n+      TREE_TYPE (data_decl) = build_array_type (ptr_type_node, index_type), \n+      DECL_INITIAL (data_decl) = build (CONSTRUCTOR, TREE_TYPE (data_decl),\n+\t\t\t\t\tNULL_TREE, data_list);\n+      DECL_SIZE (data_decl) = TYPE_SIZE (TREE_TYPE (data_decl));\n+      rest_of_decl_compilation (data_decl, (char*) 0, 1, 0);\n+      data_value = build_address_of (data_decl);\n+\n+      tags_type = build_array_type (unsigned_byte_type_node, index_type);\n+      tags_decl = build_decl (VAR_DECL, mangled_classname (\"_CT_\", \n+\t\t\t\t\t\t\t   current_class),\n+\t\t\t      tags_type);\n+      TREE_STATIC (tags_decl) = 1;\n+      DECL_INITIAL (tags_decl) = build (CONSTRUCTOR, tags_type,\n+\t\t\t\t\tNULL_TREE, tags_list);\n+      rest_of_decl_compilation (tags_decl, (char*) 0, 1, 0);\n+      tags_value = build_address_of (tags_decl);\n+    }\n+  else\n+    {\n+      data_value = null_pointer_node;\n+      tags_value = null_pointer_node;\n+    }\n+  START_RECORD_CONSTRUCTOR (cons, constants_type_node);\n+  PUSH_FIELD_VALUE (cons, \"size\", build_int_2 (outgoing_cpool->count, 0));\n+  PUSH_FIELD_VALUE (cons, \"tags\", tags_value);\n+  PUSH_FIELD_VALUE (cons, \"data\", data_value);\n+  FINISH_RECORD_CONSTRUCTOR (cons);\n+  return cons;\n+}"}, {"sha": "1e1373e5e4183606a6c7b024a941ecd9d75dcf7b", "filename": "gcc/java/convert.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fconvert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fconvert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconvert.h?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,24 @@\n+/* Definition of conversion functions.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Written by Jeffrey Hsu <hsu@cygnus.com> */\n+\n+extern tree convert_to_boolean PROTO ((tree, tree));\n+extern tree convert_to_char    PROTO ((tree, tree));"}, {"sha": "a12931fe1bab5f729e8a7b0617e8d5776d7151e6", "filename": "gcc/java/decl.c", "status": "added", "additions": 1561, "deletions": 0, "changes": 1561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,1561 @@\n+/* Process declarations and variables for the GNU compiler for the\n+   Java(TM) language.\n+\n+   Copyright (C) 1996, 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Hacked by Per Bothner <bothner@cygnus.com> February 1996. */\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"java-tree.h\"\n+#include \"jcf.h\"\n+#include \"system.h\"\n+\n+/* The DECL_MAP is a mapping from (index, type) to a decl node.\n+   If index < max_locals, it is the index of a local variable.\n+   if index >= max_locals, then index-max_locals is a stack slot.\n+   The DECL_MAP mapping is represented as a TREE_VEC whose elements\n+   are a list of decls (VAR_DECL or PARM_DECL) chained by\n+   DECL_LOCAL_SLOT_CHAIN; the index finds the TREE_VEC element, and then\n+   we search the chain for a decl with a matching TREE_TYPE. */\n+\n+tree decl_map;\n+\n+/* A list of local variables VAR_DECLs for this method that we have seen\n+   debug information, but we have not reached their starting (byte) PC yet. */\n+\n+tree pending_local_decls = NULL_TREE;\n+\n+/* Push a local variable or stack slot into the decl_map,\n+   and assign it an rtl. */\n+\n+tree\n+push_jvm_slot (index, decl)\n+     int index;\n+     tree decl;\n+{\n+  struct rtx_def *rtl = NULL;\n+  tree type = TREE_TYPE (decl);\n+  tree tmp;\n+\n+  DECL_CONTEXT (decl) = current_function_decl;\n+  layout_decl (decl, 0);\n+\n+  /* See if we have an appropriate rtl (i.e. same mode) at this index.\n+     If so, we must use it. */ \n+  tmp = TREE_VEC_ELT (decl_map, index);\n+  while (tmp != NULL_TREE)\n+    {\n+      if (TYPE_MODE (type) == TYPE_MODE (TREE_TYPE (tmp)))\n+\trtl = DECL_RTL (tmp);\n+      if (rtl != NULL)\n+\tbreak;\n+     tmp = DECL_LOCAL_SLOT_CHAIN (tmp);\n+    }\n+  if (rtl != NULL)\n+    DECL_RTL (decl) = rtl;\n+  else\n+    {\n+      if (index >= DECL_MAX_LOCALS (current_function_decl))\n+\tDECL_REGISTER (decl) = 1;\n+      expand_decl (decl);\n+    }\n+\n+  /* Now link the decl into the decl_map. */\n+  if (DECL_LANG_SPECIFIC (decl) == NULL)\n+    {\n+      DECL_LANG_SPECIFIC (decl)\n+\t= (struct lang_decl *) permalloc (sizeof (struct lang_decl_var));\n+      DECL_LOCAL_START_PC (decl) = 0;\n+      DECL_LOCAL_END_PC (decl) = DECL_CODE_LENGTH (current_function_decl);\n+      DECL_LOCAL_SLOT_NUMBER (decl) = index;\n+    }\n+  DECL_LOCAL_SLOT_CHAIN (decl) = TREE_VEC_ELT (decl_map, index);\n+  TREE_VEC_ELT (decl_map, index) = decl;\n+  return decl;\n+}\n+\n+/* Find a VAR_DECL (or PARM_DECL) at local index INDEX that has type TYPE,\n+   that is valid at PC (or -1 if any pc).\n+   If there is no existing matching decl, allocate one.\n+   If we find a decl with matching modes but different types,\n+   we re-use the rtl, but create a new decl. */\n+\n+tree\n+find_local_variable (index, type, pc)\n+     int index;\n+     tree type;\n+     int pc;\n+{\n+  struct rtx_def *rtl = NULL;\n+  tree decl = TREE_VEC_ELT (decl_map, index);\n+  tree best = NULL_TREE;\n+  while (decl != NULL_TREE)\n+    {\n+      int in_range;\n+      in_range = pc < 0\n+\t|| (pc >= DECL_LOCAL_START_PC (decl)\n+\t    && pc < DECL_LOCAL_END_PC (decl));\n+\n+      if ((TREE_TYPE (decl) == type\n+\t   || (TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE\n+\t       && type == ptr_type_node))\n+\t   && in_range)\n+\t{\n+\t  if (best == NULL_TREE\n+\t      || (TREE_TYPE (decl) == type && TREE_TYPE (best) != type)\n+\t      || DECL_LOCAL_START_PC (decl) > DECL_LOCAL_START_PC (best)\n+\t      || DECL_LOCAL_END_PC (decl) < DECL_LOCAL_START_PC (decl))\n+\t    best = decl;\n+\t}\n+      decl = DECL_LOCAL_SLOT_CHAIN (decl);\n+    }\n+  if (best != NULL_TREE)\n+    return best;\n+  return push_jvm_slot (index, build_decl (VAR_DECL, NULL_TREE, type));\n+}\n+\n+\n+/* Same as find_local_index, except that INDEX is a stack index. */\n+\n+tree\n+find_stack_slot (index, type)\n+     int index;\n+     tree type;\n+{\n+  return find_local_variable (index + DECL_MAX_LOCALS (current_function_decl),\n+\t\t\t      type, -1);\n+}\n+\n+struct binding_level\n+  {\n+    /* A chain of _DECL nodes for all variables, constants, functions,\n+     * and typedef types.  These are in the reverse of the order supplied.\n+     */\n+    tree names;\n+\n+    /* For each level, a list of shadowed outer-level local definitions\n+       to be restored when this level is popped.\n+       Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and\n+       whose TREE_VALUE is its old definition (a kind of ..._DECL node).  */\n+    tree shadowed;\n+\n+    /* For each level (except not the global one),\n+       a chain of BLOCK nodes for all the levels\n+       that were entered and exited one level down.  */\n+    tree blocks;\n+\n+    /* The BLOCK node for this level, if one has been preallocated.\n+       If 0, the BLOCK is allocated (if needed) when the level is popped.  */\n+    tree this_block;\n+\n+    /* The binding level which this one is contained in (inherits from).  */\n+    struct binding_level *level_chain;\n+\n+    /* 1 means make a BLOCK for this level regardless of all else.\n+       2 for temporary binding contours created by the compiler.  */\n+    char keep;\n+\n+    /* Nonzero means make a BLOCK if this level has any subblocks.  */\n+    char keep_if_subblocks;\n+\n+    /* Nonzero if this level can safely have additional\n+       cleanup-needing variables added to it.  */\n+    char more_cleanups_ok;\n+    char have_cleanups;\n+\n+    /* The bytecode PC that marks the end of this level. */\n+    int end_pc;\n+  };\n+\n+#define NULL_BINDING_LEVEL (struct binding_level *) NULL\n+\n+/* The binding level currently in effect.  */\n+\n+static struct binding_level *current_binding_level;\n+\n+/* A chain of binding_level structures awaiting reuse.  */\n+\n+static struct binding_level *free_binding_level;\n+\n+/* The outermost binding level, for names of file scope.\n+   This is created when the compiler is started and exists\n+   through the entire run.  */\n+\n+static struct binding_level *global_binding_level;\n+\n+/* Binding level structures are initialized by copying this one.  */\n+\n+static struct binding_level clear_binding_level\n+  = {NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE,\n+       NULL_BINDING_LEVEL, 0, 0, 0, 0, 1000000000};\n+\n+#if 0\n+/* A list (chain of TREE_LIST nodes) of all LABEL_DECLs in the function\n+   that have names.  Here so we can clear out their names' definitions\n+   at the end of the function.  */\n+\n+static tree named_labels;\n+\n+/* A list of LABEL_DECLs from outer contexts that are currently shadowed.  */\n+\n+static tree shadowed_labels;\n+#endif\n+\n+int flag_traditional;\n+\n+/* Nonzero means unconditionally make a BLOCK for the next level pushed.  */\n+\n+static int keep_next_level_flag;\n+\n+/* Nonzero means make a BLOCK for the next level pushed\n+   if it has subblocks.  */\n+\n+static int keep_next_if_subblocks;\n+  \n+/* The FUNCTION_DECL for the function currently being compiled,\n+   or 0 if between functions.  */\n+tree current_function_decl;\n+\n+/* The type node for the ordinary character type.  */\n+tree char_type_node;\n+\n+tree object_type_node;\n+tree object_ptr_type_node;\n+tree string_type_node;\n+tree throwable_type_node;\n+\n+tree boolean_type_node;\n+\n+tree float_type_node;\n+tree double_type_node;\n+\n+/* a VOID_TYPE node.  */\n+\n+tree void_type_node;\n+tree ptr_type_node;\n+tree return_address_type_node;\n+\n+tree integer_type_node;\n+\n+tree byte_type_node;\n+tree short_type_node;\n+tree int_type_node;\n+tree long_type_node;\n+\n+tree promoted_byte_type_node;\n+tree promoted_short_type_node;\n+tree promoted_char_type_node;\n+tree promoted_boolean_type_node;\n+\n+tree unsigned_byte_type_node;\n+tree unsigned_short_type_node;\n+tree unsigned_int_type_node;\n+tree unsigned_long_type_node;\n+\n+/* The type for struct methodtable. */\n+tree methodtable_type;\n+tree methodtable_ptr_type;\n+\n+tree utf8const_type;\n+tree utf8const_ptr_type;\n+tree class_type_node;\n+tree class_ptr_type;\n+tree field_type_node;\n+tree field_ptr_type_node;\n+tree field_info_union_node;\n+tree jexception_type;\n+tree jexception_ptr_type;\n+tree lineNumberEntry_type;\n+tree lineNumbers_type;\n+tree constants_type_node;\n+tree dtable_type;\n+tree dtable_ptr_type;\n+tree method_type_node;\n+tree method_ptr_type_node;\n+tree nativecode_ptr_array_type_node;\n+tree one_elt_array_domain_type;\n+tree access_flags_type_node;\n+tree class_dtable_decl;\n+\n+/* a node which has tree code ERROR_MARK, and whose type is itself.\n+   All erroneous expressions are replaced with this node.  All functions\n+   that accept nodes as arguments should avoid generating error messages\n+   if this node is one of the arguments, since it is undesirable to get\n+   multiple error messages from one error in the input.  */\n+\n+tree error_mark_node;\n+\n+/* Two expressions that are constants with value zero.\n+   The first is of type `int', the second of type `void *'.  */\n+tree integer_zero_node;\n+tree null_pointer_node;\n+\n+/* Nodes for boolean constants TRUE and FALSE. */\n+tree boolean_true_node, boolean_false_node;\n+\n+tree TYPE_identifier_node;\n+tree init_identifier_node;\n+tree clinit_identifier_node;\n+tree finalize_identifier_node;\n+tree void_signature_node;\n+tree length_identifier_node;\n+tree this_identifier_node;\n+tree super_identifier_node;\n+\n+/* References to internal libjava functions we use. */\n+tree alloc_object_node;\n+tree soft_instanceof_node;\n+tree soft_checkcast_node;\n+tree soft_initclass_node;\n+tree soft_newarray_node;\n+tree soft_anewarray_node;\n+tree soft_multianewarray_node;\n+tree soft_badarrayindex_node;\n+tree throw_node;\n+tree soft_checkarraystore_node;\n+tree soft_monitorenter_node;\n+tree soft_monitorexit_node;\n+tree soft_lookupinterfacemethod_node;\n+tree soft_fmod_node;\n+\n+/* Build (and pushdecl) a \"promoted type\" for all standard\n+   types shorter than int.  */\n+\n+static tree\n+push_promoted_type (name, actual_type)\n+     char *name;\n+     tree actual_type;\n+{\n+  tree type = make_node (TREE_CODE (actual_type));\n+#if 1\n+  tree in_min = TYPE_MIN_VALUE (int_type_node);\n+  tree in_max = TYPE_MAX_VALUE (int_type_node);\n+#else\n+  tree in_min = TYPE_MIN_VALUE (actual_type);\n+  tree in_max = TYPE_MAX_VALUE (actual_type);\n+#endif\n+  TYPE_MIN_VALUE (type) = build_int_2 (TREE_INT_CST_LOW (in_min),\n+\t\t\t\t       TREE_INT_CST_HIGH (in_min));\n+  TREE_TYPE (TYPE_MIN_VALUE (type)) = type;\n+  TYPE_MAX_VALUE (type) = build_int_2 (TREE_INT_CST_LOW (in_max),\n+\t\t\t\t       TREE_INT_CST_HIGH (in_max));\n+  TREE_TYPE (TYPE_MAX_VALUE (type)) = type;\n+  TYPE_PRECISION (type) = TYPE_PRECISION (int_type_node);\n+  layout_type (type);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (name), type));\n+  return type;\n+}\n+\n+/* Nodes for integer constants.  */\n+tree integer_one_node, integer_two_node, integer_four_node;\n+tree integer_negative_one_node;\n+\n+/* Return a definition for a builtin function named NAME and whose data type\n+   is TYPE.  TYPE should be a function type with argument types.\n+   FUNCTION_CODE tells later passes how to compile calls to this function.\n+   See tree.h for its possible values.\n+\n+   If LIBRARY_NAME is nonzero, use that for DECL_ASSEMBLER_NAME,\n+   the name to be called if we can't opencode the function.  */\n+\n+tree\n+builtin_function (name, type, function_code, library_name)\n+     char *name;\n+     tree type;\n+     enum built_in_function function_code;\n+     char *library_name;\n+{\n+  tree decl = build_decl (FUNCTION_DECL, get_identifier (name), type);\n+  DECL_EXTERNAL (decl) = 1;\n+  TREE_PUBLIC (decl) = 1;\n+  if (library_name)\n+    DECL_ASSEMBLER_NAME (decl) = get_identifier (library_name);\n+  make_decl_rtl (decl, NULL_PTR, 1);\n+  pushdecl (decl);\n+  if (function_code != NOT_BUILT_IN)\n+    {\n+      DECL_BUILT_IN (decl) = 1;\n+      DECL_FUNCTION_CODE (decl) = function_code;\n+    }\n+  return decl;\n+}\n+\n+void\n+init_decl_processing ()\n+{\n+  tree field;\n+  tree t;\n+\n+  current_function_decl = NULL;\n+  current_binding_level = NULL_BINDING_LEVEL;\n+  free_binding_level = NULL_BINDING_LEVEL;\n+  pushlevel (0);\t/* make the binding_level structure for global names */\n+  global_binding_level = current_binding_level;\n+\n+  error_mark_node = make_node (ERROR_MARK);\n+  TREE_TYPE (error_mark_node) = error_mark_node;\n+\n+  /* Create sizetype first - needed for other types. */\n+  sizetype = make_unsigned_type (POINTER_SIZE);\n+  size_zero_node = build_int_2 (0, 0);\n+  TREE_TYPE (size_zero_node) = sizetype;\n+  size_one_node = build_int_2 (1, 0);\n+  TREE_TYPE (size_one_node) = sizetype;\n+\n+  byte_type_node = make_signed_type (8);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"byte\"), byte_type_node));\n+  short_type_node = make_signed_type (16);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"short\"), short_type_node));\n+  int_type_node = make_signed_type (32);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"int\"), int_type_node));\n+  long_type_node = make_signed_type (64);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"long\"), long_type_node));\n+\n+  unsigned_byte_type_node = make_unsigned_type (8);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned byte\"),\n+\t\t\tunsigned_byte_type_node));\n+  unsigned_short_type_node = make_unsigned_type (16);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned short\"),\n+\t\t\tunsigned_short_type_node));\n+  unsigned_int_type_node = make_unsigned_type (32);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned int\"),\n+\t\t\tunsigned_int_type_node));\n+  unsigned_long_type_node = make_unsigned_type (64);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned long\"),\n+\t\t\tunsigned_long_type_node));\n+\n+  integer_type_node = int_type_node;\n+\n+  integer_zero_node = build_int_2 (0, 0);\n+  integer_one_node = build_int_2 (1, 0);\n+  integer_two_node = build_int_2 (2, 0);\n+  integer_four_node = build_int_2 (4, 0);\n+  integer_negative_one_node = build_int_2 (-1, 0);\n+\n+  void_type_node = make_node (VOID_TYPE);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"void\"), void_type_node));\n+  layout_type (void_type_node);\t/* Uses size_zero_node */\n+  ptr_type_node = build_pointer_type (void_type_node);\n+  t = make_node (VOID_TYPE);\n+  layout_type (t); /* Uses size_zero_node */\n+  return_address_type_node = build_pointer_type (t);\n+\n+  null_pointer_node = build_int_2 (0, 0);\n+  TREE_TYPE (null_pointer_node) = ptr_type_node;\n+\n+#if 0\n+  /* Make a type to be the domain of a few array types\n+     whose domains don't really matter.\n+     200 is small enough that it always fits in size_t\n+     and large enough that it can hold most function names for the\n+     initializations of __FUNCTION__ and __PRETTY_FUNCTION__.  */\n+  short_array_type_node = build_prim_array_type (short_type_node, 200);\n+#endif\n+  char_type_node = make_node (CHAR_TYPE);\n+  TYPE_PRECISION (char_type_node) = 16;\n+  fixup_unsigned_type (char_type_node);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"char\"), char_type_node));\n+\n+  boolean_type_node = make_node (BOOLEAN_TYPE);\n+  TYPE_PRECISION (boolean_type_node) = 1;\n+  fixup_unsigned_type (boolean_type_node);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"boolean\"),\n+\t\t\tboolean_type_node));\n+  boolean_false_node = TYPE_MIN_VALUE (boolean_type_node);\n+  boolean_true_node = TYPE_MAX_VALUE (boolean_type_node);\n+\n+  promoted_byte_type_node\n+    = push_promoted_type (\"promoted_byte\", byte_type_node);\n+  promoted_short_type_node\n+    = push_promoted_type (\"promoted_short\", short_type_node);\n+  promoted_char_type_node\n+    = push_promoted_type (\"promoted_char\", char_type_node);\n+  promoted_boolean_type_node\n+    = push_promoted_type (\"promoted_boolean\", boolean_type_node);\n+\n+  float_type_node = make_node (REAL_TYPE);\n+  TYPE_PRECISION (float_type_node) = 32;\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"float\"),\n+                        float_type_node));\n+  layout_type (float_type_node);\n+\n+  double_type_node = make_node (REAL_TYPE);\n+  TYPE_PRECISION (double_type_node) = 64;\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"double\"),\n+                        double_type_node));\n+  layout_type (double_type_node);\n+\n+  object_type_node = lookup_class (get_identifier (\"java.lang.Object\"));\n+  object_ptr_type_node = promote_type (object_type_node);\n+  string_type_node = lookup_class (get_identifier (\"java.lang.String\"));\n+  class_type_node = lookup_class (get_identifier (\"java.lang.Class\"));\n+  throwable_type_node = lookup_class (get_identifier (\"java.lang.Throwable\"));\n+\n+  methodtable_type = make_node (RECORD_TYPE);\n+  layout_type (methodtable_type);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"methodtable\"),\n+\t\t\tmethodtable_type));\n+  methodtable_ptr_type = build_pointer_type (methodtable_type);\n+\n+  TYPE_identifier_node = get_identifier (\"TYPE\");\n+  init_identifier_node = get_identifier (\"<init>\");\n+  clinit_identifier_node = get_identifier (\"<clinit>\");\n+  finalize_identifier_node = get_identifier (\"finalize\");\n+  void_signature_node = get_identifier (\"()V\");\n+  length_identifier_node = get_identifier (\"length\");\n+  this_identifier_node = get_identifier (\"this\");\n+  super_identifier_node = get_identifier (\"super\");\n+\n+  /* for lack of a better place to put this stub call */\n+  init_expr_processing();\n+\n+  utf8const_type = make_node (RECORD_TYPE);\n+  PUSH_FIELD (utf8const_type, field, \"hash\", unsigned_short_type_node);\n+  PUSH_FIELD (utf8const_type, field, \"length\", unsigned_short_type_node);\n+  FINISH_RECORD (utf8const_type);\n+  utf8const_ptr_type = build_pointer_type (utf8const_type);\n+\n+  constants_type_node = make_node (RECORD_TYPE);\n+  PUSH_FIELD (constants_type_node, field, \"size\", unsigned_int_type_node);\n+  PUSH_FIELD (constants_type_node, field, \"tags\", ptr_type_node);\n+  PUSH_FIELD (constants_type_node, field, \"data\", ptr_type_node);\n+  FINISH_RECORD (constants_type_node);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"constants\"),\n+\t\t\tconstants_type_node));\n+\n+  access_flags_type_node = unsigned_short_type_node;\n+\n+  dtable_type = make_node (RECORD_TYPE);\n+  dtable_ptr_type = build_pointer_type (dtable_type);\n+\n+  PUSH_FIELD (object_type_node, field, \"dtable\", dtable_ptr_type);\n+  PUSH_FIELD (object_type_node, field, \"sync_info\", ptr_type_node);\n+  for (t = TYPE_FIELDS (object_type_node); t != NULL_TREE; t = TREE_CHAIN (t))\n+    FIELD_PRIVATE (t) = 1;\n+  FINISH_RECORD (object_type_node);\n+\n+  class_dtable_decl = build_dtable_decl (class_type_node);\n+  TREE_STATIC (class_dtable_decl) = 1;\n+  DECL_ARTIFICIAL (class_dtable_decl) = 1;\n+  DECL_IGNORED_P (class_dtable_decl) = 1;\n+  rest_of_decl_compilation (class_dtable_decl, (char*) 0, 1, 0);\n+\n+  field_type_node = make_node (RECORD_TYPE);\n+  field_ptr_type_node = build_pointer_type (field_type_node);\n+  method_type_node = make_node (RECORD_TYPE);\n+  method_ptr_type_node = build_pointer_type (method_type_node);\n+\n+  set_super_info (0, class_type_node, object_type_node, 0);\n+  set_super_info (0, string_type_node, object_type_node, 0);\n+  class_ptr_type = build_pointer_type (class_type_node);\n+\n+  PUSH_FIELD (class_type_node, field, \"next\", class_ptr_type);\n+  PUSH_FIELD (class_type_node, field, \"name\", utf8const_ptr_type);\n+  PUSH_FIELD (class_type_node, field, \"accflags\", access_flags_type_node);\n+  PUSH_FIELD (class_type_node, field, \"superclass\", class_ptr_type);\n+  PUSH_FIELD (class_type_node, field, \"subclass_head\", class_ptr_type);\n+  PUSH_FIELD (class_type_node, field, \"subclass_next\", class_ptr_type);\n+  PUSH_FIELD (class_type_node, field, \"constants\", constants_type_node);\n+  PUSH_FIELD (class_type_node, field, \"methods\", method_ptr_type_node);\n+  PUSH_FIELD (class_type_node, field, \"nmethods\", short_type_node);\n+  PUSH_FIELD (class_type_node, field, \"msize\", short_type_node);\n+  PUSH_FIELD (class_type_node, field, \"fields\", field_ptr_type_node);\n+  PUSH_FIELD (class_type_node, field, \"bfsize\", int_type_node);\n+  PUSH_FIELD (class_type_node, field, \"nfields\", short_type_node);\n+  PUSH_FIELD (class_type_node, field, \"nsfields\", short_type_node);\n+  PUSH_FIELD (class_type_node, field, \"dtable\", dtable_ptr_type);\n+  PUSH_FIELD (class_type_node, field, \"interfaces\",\n+\t      build_pointer_type (class_ptr_type));\n+  PUSH_FIELD (class_type_node, field, \"loader\", ptr_type_node);\n+  PUSH_FIELD (class_type_node, field, \"interface_len\", short_type_node);\n+  PUSH_FIELD (class_type_node, field, \"state\", byte_type_node);\n+  PUSH_FIELD (class_type_node, field, \"final\", byte_type_node);\n+  for (t = TYPE_FIELDS (class_type_node);  t != NULL_TREE;  t = TREE_CHAIN (t))\n+    FIELD_PRIVATE (t) = 1;\n+  push_super_field (class_type_node, object_type_node);\n+  FINISH_RECORD (class_type_node);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"Class\"), class_type_node));\n+\n+  field_info_union_node = make_node (UNION_TYPE);\n+  PUSH_FIELD (field_info_union_node, field, \"boffset\", int_type_node);\n+  PUSH_FIELD (field_info_union_node, field, \"addr\", ptr_type_node);\n+#if 0\n+  PUSH_FIELD (field_info_union_node, field, \"idx\", unsigned_short_type_node);\n+#endif\n+  layout_type (field_info_union_node);\n+\n+  PUSH_FIELD (field_type_node, field, \"name\", utf8const_ptr_type);\n+  PUSH_FIELD (field_type_node, field, \"type\", class_ptr_type);\n+  PUSH_FIELD (field_type_node, field, \"accflags\", access_flags_type_node);\n+  PUSH_FIELD (field_type_node, field, \"bsize\", unsigned_short_type_node);\n+  PUSH_FIELD (field_type_node, field, \"info\", field_info_union_node);\n+  FINISH_RECORD (field_type_node);\n+  CLASS_LOADED_P (field_type_node) = 1;\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"Field\"), field_type_node));\n+\n+  one_elt_array_domain_type = build_index_type (integer_one_node);\n+  nativecode_ptr_array_type_node\n+    = build_array_type (nativecode_ptr_type_node, one_elt_array_domain_type);\n+\n+  PUSH_FIELD (dtable_type, field, \"class\", class_ptr_type);\n+  PUSH_FIELD (dtable_type, field, \"methods\", nativecode_ptr_array_type_node);\n+  FINISH_RECORD (dtable_type);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"dispatchTable\"), dtable_type));\n+\n+#define jint_type int_type_node\n+#define jint_ptr_type ptr_type_node\n+\n+  jexception_type = make_node (RECORD_TYPE);\n+  PUSH_FIELD (jexception_type, field, \"start_pc\", ptr_type_node);\n+  PUSH_FIELD (jexception_type, field, \"end_pc\", ptr_type_node);\n+  PUSH_FIELD (jexception_type, field, \"handler_pc\", ptr_type_node);\n+  PUSH_FIELD (jexception_type, field, \"catch_type\", class_ptr_type);\n+  FINISH_RECORD (jexception_type);\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"jexception\"), field_type_node));\n+  jexception_ptr_type = build_pointer_type (jexception_type);\n+\n+  lineNumberEntry_type = make_node (RECORD_TYPE);\n+  PUSH_FIELD (lineNumberEntry_type, field, \"line_nr\", unsigned_short_type_node);\n+  PUSH_FIELD (lineNumberEntry_type, field, \"start_pc\", ptr_type_node);\n+  FINISH_RECORD (lineNumberEntry_type);\n+\n+  lineNumbers_type = make_node (RECORD_TYPE);\n+  PUSH_FIELD (lineNumbers_type, field, \"length\", unsigned_int_type_node);\n+  FINISH_RECORD (lineNumbers_type);\n+\n+#define instn_ptr_type_node ptr_type_node\t/* XXX JH */\n+\n+#define lineNumbers_ptr_type_node build_pointer_type(lineNumbers_type)\n+\n+  PUSH_FIELD (method_type_node, field, \"name\", utf8const_ptr_type);\n+  PUSH_FIELD (method_type_node, field, \"signature\", utf8const_ptr_type);\n+  PUSH_FIELD (method_type_node, field, \"accflags\", access_flags_type_node);\n+  PUSH_FIELD (method_type_node, field, \"ncode\", nativecode_ptr_type_node);\n+  FINISH_RECORD (method_type_node);\n+  CLASS_LOADED_P (method_type_node) = 1;\n+  pushdecl (build_decl (TYPE_DECL, get_identifier (\"Method\"), method_type_node));\n+\n+  t = tree_cons (NULL_TREE, class_ptr_type,\n+\t\t build_tree_list (NULL_TREE, int_type_node));\n+  alloc_object_node = builtin_function (\"_Jv_AllocObject\",\n+\t\t\t\t\tbuild_function_type (ptr_type_node, t),\n+\t\t\t\t\tNOT_BUILT_IN, NULL_PTR);\n+  soft_initclass_node = builtin_function (\"_Jv_InitClass\",\n+\t\t\t\t\t  build_function_type (void_type_node,\n+\t\t\t\t\t\t\t       t),\n+\t\t\t\t\t  NOT_BUILT_IN, NULL_PTR);\n+  t = build_tree_list (NULL_TREE, void_type_node);\n+  throw_node = builtin_function (\"_Jv_Throw\",\n+\t\t\t\t build_function_type (ptr_type_node, t),\n+\t\t\t\t NOT_BUILT_IN, NULL_PTR);\n+  soft_monitorenter_node \n+      = builtin_function (\"_Jv_MonitorEnter\",\n+\t\t\t  build_function_type (int_type_node, t),\n+\t\t\t  NOT_BUILT_IN, NULL_PTR);\n+  soft_monitorexit_node \n+      = builtin_function (\"_Jv_MonitorExit\",\n+\t\t\t  build_function_type (int_type_node, t),\n+\t\t\t  NOT_BUILT_IN, NULL_PTR);\n+  \n+  t = tree_cons (NULL_TREE, int_type_node, \n+\t\t build_tree_list (NULL_TREE, int_type_node));\n+  soft_newarray_node\n+      = builtin_function (\"_Jv_NewArray\",\n+\t\t\t  build_function_type(ptr_type_node, t),\n+\t\t\t  NOT_BUILT_IN, NULL_PTR );\n+\n+  t = tree_cons (NULL_TREE, int_type_node,\n+\t\t tree_cons (NULL_TREE, class_ptr_type,\n+\t\t\t    build_tree_list (NULL_TREE, object_ptr_type_node)));\n+  soft_anewarray_node\n+      = builtin_function (\"_Jv_NewObjectArray\",\n+\t\t\t  build_function_type (ptr_type_node, t),\n+\t\t\t  NOT_BUILT_IN, NULL_PTR );\n+\n+  t = tree_cons (NULL_TREE, ptr_type_node,\n+\t\t build_tree_list (NULL_TREE, int_type_node));\n+  soft_multianewarray_node\n+      = builtin_function (\"_Jv_NewMultiArray\",\n+\t\t\t  build_function_type (ptr_type_node, t),\n+\t\t\t  NOT_BUILT_IN, NULL_PTR );\n+\n+  t = build_function_type (void_type_node, NULL_TREE);\n+  soft_badarrayindex_node\n+      = builtin_function (\"_Jv_ThrowBadArrayIndex\", t, NOT_BUILT_IN, NULL_PTR );\n+  TREE_THIS_VOLATILE (soft_badarrayindex_node) = 1;\n+  TREE_SIDE_EFFECTS (soft_badarrayindex_node) = 1;\n+\n+  t = tree_cons (NULL_TREE, class_ptr_type,\n+\t\t build_tree_list (NULL_TREE, object_ptr_type_node));\n+  soft_checkcast_node\n+    = builtin_function (\"_Jv_CheckCast\",\n+\t\t\tbuild_function_type (ptr_type_node, t),\n+\t\t\tNOT_BUILT_IN, NULL_PTR);\n+  t = tree_cons (NULL_TREE, object_ptr_type_node,\n+\t\t build_tree_list (NULL_TREE, class_ptr_type));\n+  soft_instanceof_node\n+    = builtin_function (\"_Jv_IsInstanceOf\",\n+\t\t\tbuild_function_type (promoted_boolean_type_node, t),\n+\t\t\tNOT_BUILT_IN, NULL_PTR);\n+  t = tree_cons (NULL_TREE, object_ptr_type_node,\n+\t\t build_tree_list (NULL_TREE, object_ptr_type_node));\n+  soft_checkarraystore_node\n+    = builtin_function (\"_Jv_CheckArrayStore\",\n+\t\t\tbuild_function_type (void_type_node, t),\n+\t\t\tNOT_BUILT_IN, NULL_PTR);\n+  t = tree_cons (NULL_TREE, ptr_type_node,\n+\t\t tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t    build_tree_list (NULL_TREE, ptr_type_node)));\n+  soft_lookupinterfacemethod_node \n+    = builtin_function (\"_Jv_LookupInterfaceMethod\",\n+\t\t\tbuild_function_type(ptr_type_node, t),\n+\t\t\tNOT_BUILT_IN, NULL_PTR);\n+  t = tree_cons (NULL_TREE, double_type_node,\n+\t\t build_tree_list (NULL_TREE, double_type_node));\n+  soft_fmod_node\n+    = builtin_function (\"__builtin_fmod\",\n+\t\t\tbuild_function_type (double_type_node, t),\n+\t\t\tBUILT_IN_FMOD, \"fmod\");\n+#if 0\n+  t = tree_cons (NULL_TREE, float_type_node,\n+\t\t build_tree_list (NULL_TREE, float_type_node));\n+  soft_fmodf_node\n+    = builtin_function (\"__builtin_fmodf\",\n+\t\t\tbuild_function_type (float_type_node, t),\n+\t\t\tBUILT_IN_FMOD, \"fmodf\");\n+#endif\n+    \n+  init_class_processing ();\n+}\n+\n+\n+/* Look up NAME in the current binding level and its superiors\n+   in the namespace of variables, functions and typedefs.\n+   Return a ..._DECL node of some kind representing its definition,\n+   or return 0 if it is undefined.  */\n+\n+tree\n+lookup_name (name)\n+     tree name;\n+{\n+  register tree val;\n+  if (current_binding_level != global_binding_level\n+      && IDENTIFIER_LOCAL_VALUE (name))\n+    val = IDENTIFIER_LOCAL_VALUE (name);\n+  else\n+    val = IDENTIFIER_GLOBAL_VALUE (name);\n+  return val;\n+}\n+\n+/* Similar to `lookup_name' but look only at current binding level and\n+   the previous one if its the parameter level.  */\n+\n+tree\n+lookup_name_current_level (name)\n+     tree name;\n+{\n+  register tree t;\n+\n+  if (current_binding_level == global_binding_level)\n+    return IDENTIFIER_GLOBAL_VALUE (name);\n+\n+  if (IDENTIFIER_LOCAL_VALUE (name) == 0)\n+    return 0;\n+\n+  for (t = current_binding_level->names; t; t = TREE_CHAIN (t))\n+    if (DECL_NAME (t) == name)\n+      break;\n+\n+  return t;\n+}\n+\n+/* Use a binding level to record a labeled block declaration */\n+\n+void\n+push_labeled_block (lb)\n+    tree lb;\n+{\n+  register tree name = DECL_NAME (LABELED_BLOCK_LABEL (lb));\n+  register struct binding_level *b = current_binding_level;\n+  tree oldlocal = IDENTIFIER_LOCAL_VALUE (name);\n+  if (oldlocal != 0)\n+      b->shadowed = tree_cons (name, oldlocal, b->shadowed);\n+  TREE_CHAIN (lb) = b->names;\n+  b->names = lb;\n+  IDENTIFIER_LOCAL_VALUE (name) = lb;\n+}\n+\n+/* Pop the current binding level, reinstalling values for the previous\n+   labeled block */\n+\n+void\n+pop_labeled_block ()\n+{\n+  struct binding_level *b = current_binding_level;\n+  tree label =  b->names;\n+  IDENTIFIER_LOCAL_VALUE (DECL_NAME (LABELED_BLOCK_LABEL (label))) = \n+    NULL_TREE;\n+  if (b->shadowed)\n+    IDENTIFIER_LOCAL_VALUE (TREE_PURPOSE (b->shadowed)) = \n+      TREE_VALUE (b->shadowed);\n+\n+  /* Pop the current level, and free the structure for reuse.  */\n+  current_binding_level = current_binding_level->level_chain;\n+  b->level_chain = free_binding_level;\n+  free_binding_level = b;\n+}\n+\n+/* Record a decl-node X as belonging to the current lexical scope.\n+   Check for errors (such as an incompatible declaration for the same\n+   name already seen in the same scope).\n+\n+   Returns either X or an old decl for the same name.\n+   If an old decl is returned, it may have been smashed\n+   to agree with what X says.  */\n+\n+tree\n+pushdecl (x)\n+     tree x;\n+{\n+  register tree t;\n+  register tree name = DECL_NAME (x);\n+  register struct binding_level *b = current_binding_level;\n+\n+  DECL_CONTEXT (x) = current_function_decl;\n+  if (name)\n+    {\n+      char *file;\n+      int line;\n+      int different_binding_level = 0;\n+\n+      t = lookup_name_current_level (name);\n+      if (t != 0 && t == error_mark_node)\n+\t/* error_mark_node is 0 for a while during initialization!  */\n+\t{\n+\t  t = 0;\n+\t  error_with_decl (x, \"`%s' used prior to declaration\");\n+\t}\n+\n+      if (t != 0)\n+\t{\n+\t  file = DECL_SOURCE_FILE (t);\n+\t  line = DECL_SOURCE_LINE (t);\n+\t}\n+\n+      /* If we're naming a hitherto-unnamed type, set its TYPE_NAME\n+\t to point to the TYPE_DECL.\n+\t Since Java does not have typedefs, a type can only have\n+\t one (true) name, given by a class, interface, or builtin. */\n+      if (TREE_CODE (x) == TYPE_DECL\n+\t  && TYPE_NAME (TREE_TYPE (x)) == 0\n+\t  && TREE_TYPE (x) != error_mark_node)\n+\t{\n+\t  TYPE_NAME (TREE_TYPE (x)) = x;\n+\t  TYPE_STUB_DECL (TREE_TYPE (x)) = x;\n+\t}\n+\n+      /* This name is new in its binding level.\n+\t Install the new declaration and return it.  */\n+      if (b == global_binding_level)\n+\t{\n+\t  /* Install a global value.  */\n+\t  \n+\t  IDENTIFIER_GLOBAL_VALUE (name) = x;\n+\t}\n+      else\n+\t{\n+\t  /* Here to install a non-global value.  */\n+\t  tree oldlocal = IDENTIFIER_LOCAL_VALUE (name);\n+\t  tree oldglobal = IDENTIFIER_GLOBAL_VALUE (name);\n+\t  IDENTIFIER_LOCAL_VALUE (name) = x;\n+\n+#if 0\n+\t  /* Warn if shadowing an argument at the top level of the body.  */\n+\t  if (oldlocal != 0 && !DECL_EXTERNAL (x)\n+\t      /* This warning doesn't apply to the parms of a nested fcn.  */\n+\t      && ! current_binding_level->parm_flag\n+\t      /* Check that this is one level down from the parms.  */\n+\t      && current_binding_level->level_chain->parm_flag\n+\t      /* Check that the decl being shadowed\n+\t\t comes from the parm level, one level up.  */\n+\t      && chain_member (oldlocal, current_binding_level->level_chain->names))\n+\t    {\n+\t      if (TREE_CODE (oldlocal) == PARM_DECL)\n+\t\tpedwarn (\"declaration of `%s' shadows a parameter\",\n+\t\t\t IDENTIFIER_POINTER (name));\n+\t      else\n+\t\tpedwarn (\"declaration of `%s' shadows a symbol from the parameter list\",\n+\t\t\t IDENTIFIER_POINTER (name));\n+\t    }\n+\n+\t  /* Maybe warn if shadowing something else.  */\n+\t  else if (warn_shadow && !DECL_EXTERNAL (x)\n+\t\t   /* No shadow warnings for internally generated vars.  */\n+\t\t   && DECL_SOURCE_LINE (x) != 0\n+\t\t   /* No shadow warnings for vars made for inlining.  */\n+\t\t   && ! DECL_FROM_INLINE (x))\n+\t    {\n+\t      char *warnstring = 0;\n+\n+\t      if (TREE_CODE (x) == PARM_DECL\n+\t\t  && current_binding_level->level_chain->parm_flag)\n+\t\t/* Don't warn about the parm names in function declarator\n+\t\t   within a function declarator.\n+\t\t   It would be nice to avoid warning in any function\n+\t\t   declarator in a declaration, as opposed to a definition,\n+\t\t   but there is no way to tell it's not a definition.  */\n+\t\t;\n+\t      else if (oldlocal != 0 && TREE_CODE (oldlocal) == PARM_DECL)\n+\t\twarnstring = \"declaration of `%s' shadows a parameter\";\n+\t      else if (oldlocal != 0)\n+\t\twarnstring = \"declaration of `%s' shadows previous local\";\n+\t      else if (IDENTIFIER_GLOBAL_VALUE (name) != 0\n+\t\t       && IDENTIFIER_GLOBAL_VALUE (name) != error_mark_node)\n+\t\twarnstring = \"declaration of `%s' shadows global declaration\";\n+\n+\t      if (warnstring)\n+\t\twarning (warnstring, IDENTIFIER_POINTER (name));\n+\t    }\n+#endif\n+\n+\t  /* If storing a local value, there may already be one (inherited).\n+\t     If so, record it for restoration when this binding level ends.  */\n+\t  if (oldlocal != 0)\n+\t    b->shadowed = tree_cons (name, oldlocal, b->shadowed);\n+\t}\n+    }\n+\n+  /* Put decls on list in reverse order.\n+     We will reverse them later if necessary.  */\n+  TREE_CHAIN (x) = b->names;\n+  b->names = x;\n+\n+  return x;\n+}\n+void\n+pushdecl_force_head (x)\n+     tree x;\n+{\n+  current_binding_level->names = x;\n+}\n+\n+/* Like pushdecl, only it places X in GLOBAL_BINDING_LEVEL, if appropriate.  */\n+\n+tree\n+pushdecl_top_level (x)\n+     tree x;\n+{\n+  register tree t;\n+  register struct binding_level *b = current_binding_level;\n+\n+  current_binding_level = global_binding_level;\n+  t = pushdecl (x);\n+  current_binding_level = b;\n+  return t;\n+}\n+\n+/* Nonzero if we are currently in the global binding level.  */\n+\n+int\n+global_bindings_p ()\n+{\n+  return current_binding_level == global_binding_level;\n+}\n+\n+/* Return the list of declarations of the current level.\n+   Note that this list is in reverse order unless/until\n+   you nreverse it; and when you do nreverse it, you must\n+   store the result back using `storedecls' or you will lose.  */\n+\n+tree\n+getdecls ()\n+{\n+  return current_binding_level->names;\n+}\n+\n+/* Create a new `struct binding_level'.  */\n+\n+static\n+struct binding_level *\n+make_binding_level ()\n+{\n+  /* NOSTRICT */\n+  return (struct binding_level *) xmalloc (sizeof (struct binding_level));\n+}\n+\n+void\n+pushlevel (unused)\n+     int unused;\n+{\n+  register struct binding_level *newlevel = NULL_BINDING_LEVEL;\n+\n+#if 0\n+  /* If this is the top level of a function,\n+     just make sure that NAMED_LABELS is 0.  */\n+\n+  if (current_binding_level == global_binding_level)\n+    named_labels = 0;\n+#endif\n+\n+  /* Reuse or create a struct for this binding level.  */\n+\n+  if (free_binding_level)\n+    {\n+      newlevel = free_binding_level;\n+      free_binding_level = free_binding_level->level_chain;\n+    }\n+  else\n+    {\n+      newlevel = make_binding_level ();\n+    }\n+\n+  /* Add this level to the front of the chain (stack) of levels that\n+     are active.  */\n+\n+  *newlevel = clear_binding_level;\n+  newlevel->level_chain = current_binding_level;\n+  current_binding_level = newlevel;\n+  newlevel->keep = keep_next_level_flag;\n+  keep_next_level_flag = 0;\n+  newlevel->keep_if_subblocks = keep_next_if_subblocks;\n+  keep_next_if_subblocks = 0;\n+}\n+\n+/* Exit a binding level.\n+   Pop the level off, and restore the state of the identifier-decl mappings\n+   that were in effect when this level was entered.\n+\n+   If KEEP is nonzero, this level had explicit declarations, so\n+   and create a \"block\" (a BLOCK node) for the level\n+   to record its declarations and subblocks for symbol table output.\n+\n+   If FUNCTIONBODY is nonzero, this level is the body of a function,\n+   so create a block as if KEEP were set and also clear out all\n+   label names.\n+\n+   If REVERSE is nonzero, reverse the order of decls before putting\n+   them into the BLOCK.  */\n+\n+tree\n+poplevel (keep, reverse, functionbody)\n+     int keep;\n+     int reverse;\n+     int functionbody;\n+{\n+  register tree link;\n+  /* The chain of decls was accumulated in reverse order.\n+     Put it into forward order, just for cleanliness.  */\n+  tree decls;\n+  tree subblocks = current_binding_level->blocks;\n+  tree block = 0;\n+  tree decl;\n+  int block_previously_created;\n+\n+  keep |= current_binding_level->keep;\n+\n+  /* Get the decls in the order they were written.\n+     Usually current_binding_level->names is in reverse order.\n+     But parameter decls were previously put in forward order.  */\n+\n+  if (reverse)\n+    current_binding_level->names\n+      = decls = nreverse (current_binding_level->names);\n+  else\n+    decls = current_binding_level->names;\n+\n+  /* Output any nested inline functions within this block\n+     if they weren't already output.  */\n+\n+  for (decl = decls; decl; decl = TREE_CHAIN (decl))\n+    if (TREE_CODE (decl) == FUNCTION_DECL\n+\t&& ! TREE_ASM_WRITTEN (decl)\n+\t&& DECL_INITIAL (decl) != 0\n+\t&& TREE_ADDRESSABLE (decl))\n+      {\n+\t/* If this decl was copied from a file-scope decl\n+\t   on account of a block-scope extern decl,\n+\t   propagate TREE_ADDRESSABLE to the file-scope decl.\n+\n+\t   DECL_ABSTRACT_ORIGIN can be set to itself if warn_return_type is\n+\t   true, since then the decl goes through save_for_inline_copying.  */\n+\tif (DECL_ABSTRACT_ORIGIN (decl) != 0\n+\t    && DECL_ABSTRACT_ORIGIN (decl) != decl)\n+\t  TREE_ADDRESSABLE (DECL_ABSTRACT_ORIGIN (decl)) = 1;\n+\telse\n+\t  {\n+\t    push_function_context ();\n+\t    output_inline_function (decl);\n+\t    pop_function_context ();\n+\t  }\n+      }\n+\n+  /* If there were any declarations in that level,\n+     or if this level is a function body,\n+     create a BLOCK to record them for the life of this function.  */\n+\n+  block = 0;\n+  block_previously_created = (current_binding_level->this_block != 0);\n+  if (block_previously_created)\n+    block = current_binding_level->this_block;\n+  else if (keep || functionbody\n+\t   || (current_binding_level->keep_if_subblocks && subblocks != 0))\n+    block = make_node (BLOCK);\n+  if (block != 0)\n+    {\n+      BLOCK_VARS (block) = decls;\n+      BLOCK_TYPE_TAGS (block) = NULL_TREE;\n+      BLOCK_SUBBLOCKS (block) = subblocks;\n+      remember_end_note (block);\n+    }\n+\n+  /* In each subblock, record that this is its superior.  */\n+\n+  for (link = subblocks; link; link = TREE_CHAIN (link))\n+    BLOCK_SUPERCONTEXT (link) = block;\n+\n+  /* Clear out the meanings of the local variables of this level.  */\n+\n+  for (link = decls; link; link = TREE_CHAIN (link))\n+    {\n+      tree name = DECL_NAME (link);\n+      if (name != 0 && IDENTIFIER_LOCAL_VALUE (name) == link)\n+\t{\n+\t  /* If the ident. was used or addressed via a local extern decl,\n+\t     don't forget that fact.  */\n+\t  if (DECL_EXTERNAL (link))\n+\t    {\n+\t      if (TREE_USED (link))\n+\t\tTREE_USED (name) = 1;\n+\t      if (TREE_ADDRESSABLE (link))\n+\t\tTREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (link)) = 1;\n+\t    }\n+\t  IDENTIFIER_LOCAL_VALUE (name) = 0;\n+\t}\n+    }\n+\n+  /* Restore all name-meanings of the outer levels\n+     that were shadowed by this level.  */\n+\n+  for (link = current_binding_level->shadowed; link; link = TREE_CHAIN (link))\n+    IDENTIFIER_LOCAL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+\n+  /* If the level being exited is the top level of a function,\n+     check over all the labels, and clear out the current\n+     (function local) meanings of their names.  */\n+\n+  if (functionbody)\n+    {\n+      /* If this is the top level block of a function,\n+\t the vars are the function's parameters.\n+\t Don't leave them in the BLOCK because they are\n+\t found in the FUNCTION_DECL instead.  */\n+\n+      BLOCK_VARS (block) = 0;\n+\n+      /* Clear out the definitions of all label names,\n+\t since their scopes end here,\n+\t and add them to BLOCK_VARS.  */\n+\n+#if 0\n+      for (link = named_labels; link; link = TREE_CHAIN (link))\n+\t{\n+\t  register tree label = TREE_VALUE (link);\n+\n+\t  if (DECL_INITIAL (label) == 0)\n+\t    {\n+\t      error_with_decl (label, \"label `%s' used but not defined\");\n+\t      /* Avoid crashing later.  */\n+\t      define_label (input_filename, lineno,\n+\t\t\t    DECL_NAME (label));\n+\t    }\n+\t  else if (warn_unused && !TREE_USED (label))\n+\t    warning_with_decl (label, \"label `%s' defined but not used\");\n+\t  IDENTIFIER_LABEL_VALUE (DECL_NAME (label)) = 0;\n+\n+\t  /* Put the labels into the \"variables\" of the\n+\t     top-level block, so debugger can see them.  */\n+\t  TREE_CHAIN (label) = BLOCK_VARS (block);\n+\t  BLOCK_VARS (block) = label;\n+\t}\n+#endif\n+    }\n+\n+  /* Pop the current level, and free the structure for reuse.  */\n+\n+  {\n+    register struct binding_level *level = current_binding_level;\n+    current_binding_level = current_binding_level->level_chain;\n+\n+    level->level_chain = free_binding_level;\n+    free_binding_level = level;\n+  }\n+\n+  /* Dispose of the block that we just made inside some higher level.  */\n+  if (functionbody)\n+    DECL_INITIAL (current_function_decl) = block;\n+  else if (block)\n+    {\n+      if (!block_previously_created)\n+        current_binding_level->blocks\n+          = chainon (current_binding_level->blocks, block);\n+    }\n+  /* If we did not make a block for the level just exited,\n+     any blocks made for inner levels\n+     (since they cannot be recorded as subblocks in that level)\n+     must be carried forward so they will later become subblocks\n+     of something else.  */\n+  else if (subblocks)\n+    current_binding_level->blocks\n+      = chainon (current_binding_level->blocks, subblocks);\n+\n+  /* Set the TYPE_CONTEXTs for all of the tagged types belonging to this\n+     binding contour so that they point to the appropriate construct, i.e.\n+     either to the current FUNCTION_DECL node, or else to the BLOCK node\n+     we just constructed.\n+\n+     Note that for tagged types whose scope is just the formal parameter\n+     list for some function type specification, we can't properly set\n+     their TYPE_CONTEXTs here, because we don't have a pointer to the\n+     appropriate FUNCTION_TYPE node readily available to us.  For those\n+     cases, the TYPE_CONTEXTs of the relevant tagged type nodes get set\n+     in `grokdeclarator' as soon as we have created the FUNCTION_TYPE\n+     node which will represent the \"scope\" for these \"parameter list local\"\n+     tagged types.\n+  */\n+\n+  if (block)\n+    TREE_USED (block) = 1;\n+  return block;\n+}\n+\n+void\n+maybe_pushlevels (pc)\n+     int pc;\n+{\n+  while (pending_local_decls != NULL_TREE &&\n+\t DECL_LOCAL_START_PC (pending_local_decls) <= pc)\n+    {\n+      tree *ptr = &pending_local_decls;\n+      tree decl = *ptr;\n+      int end_pc = DECL_LOCAL_END_PC (decl);\n+\n+      while (*ptr != NULL_TREE\n+\t     && DECL_LOCAL_START_PC (*ptr) <= pc\n+\t     && DECL_LOCAL_END_PC (*ptr) == end_pc)\n+\tptr = &TREE_CHAIN (*ptr);\n+      pending_local_decls = *ptr;\n+      *ptr = NULL_TREE;\n+\n+      /* Force non-nested range to be nested in current range. */\n+      if (end_pc > current_binding_level->end_pc)\n+\tend_pc = current_binding_level->end_pc;\n+\n+      pushlevel (1);\n+      expand_start_bindings (0);\n+      current_binding_level->end_pc = end_pc;\n+      \n+      current_binding_level->names = decl;\n+      for ( ; decl != NULL_TREE;  decl = TREE_CHAIN (decl))\n+\t{\n+\t  push_jvm_slot (DECL_LOCAL_SLOT_NUMBER (decl), decl);\n+\t}\n+    }\n+}\n+\n+void\n+maybe_poplevels (pc)\n+     int pc;\n+{\n+  while (current_binding_level->end_pc <= pc)\n+    {\n+      expand_end_bindings (getdecls (), 1, 0);\n+      poplevel (1, 0, 0);\n+    }\n+}\n+\n+/* Insert BLOCK at the end of the list of subblocks of the\n+   current binding level.  This is used when a BIND_EXPR is expanded,\n+   to handle the BLOCK node inside the BIND_EXPR.  */\n+\n+void\n+insert_block (block)\n+     tree block;\n+{\n+  TREE_USED (block) = 1;\n+  abort ();\n+  current_binding_level->blocks\n+    = chainon (current_binding_level->blocks, block);\n+}\n+\n+/* Set the BLOCK node for the innermost scope\n+   (the one we are currently in).  */\n+\n+void\n+set_block (block)\n+     register tree block;\n+{\n+  current_binding_level->this_block = block;\n+}\n+\n+/* integrate_decl_tree calls this function. */\n+\n+void\n+copy_lang_decl (node)\n+     tree node;\n+{\n+  int lang_decl_size\n+    = TREE_CODE (node) == VAR_DECL ? sizeof (struct lang_decl_var)\n+    : sizeof (struct lang_decl);\n+  struct lang_decl *x = (struct lang_decl *) oballoc (lang_decl_size);\n+  bcopy (DECL_LANG_SPECIFIC (node), x, lang_decl_size);\n+  DECL_LANG_SPECIFIC (node) = x;\n+}\n+\n+/* If DECL has a cleanup, build and return that cleanup here.\n+   This is a callback called by expand_expr.  */\n+\n+tree\n+maybe_build_cleanup (decl)\n+     tree decl;\n+{\n+  /* There are no cleanups in Java (I think).  */\n+  return NULL_TREE;\n+}\n+\n+void\n+give_name_to_locals (jcf)\n+     JCF *jcf;\n+{\n+  int i, n = DECL_LOCALVARIABLES_OFFSET (current_function_decl);\n+  tree parm;\n+  pending_local_decls = NULL_TREE;\n+  if (n == 0)\n+    return;\n+  JCF_SEEK (jcf, n);\n+  n = JCF_readu2 (jcf);\n+  for (i = 0; i < n; i++)\n+    {\n+      int start_pc = JCF_readu2 (jcf);\n+      int length = JCF_readu2 (jcf);\n+      int name_index = JCF_readu2 (jcf);\n+      int signature_index = JCF_readu2 (jcf);\n+      int slot = JCF_readu2 (jcf);\n+      tree name = get_name_constant (jcf, name_index);\n+      tree type = promote_type (parse_signature (jcf, signature_index));\n+      if (slot < DECL_ARG_SLOT_COUNT (current_function_decl)\n+\t  && start_pc == 0\n+\t  && length == DECL_CODE_LENGTH (current_function_decl))\n+\t{\n+\t  tree decl = TREE_VEC_ELT (decl_map, slot);\n+\t  DECL_NAME (decl) = name;\n+\t  DECL_ASSEMBLER_NAME (decl) = name;\n+\t  if (TREE_CODE (decl) != PARM_DECL || TREE_TYPE (decl) != type)\n+\t    warning (\"bad type in parameter debug info\");\n+\t}\n+      else\n+\t{\n+\t  tree *ptr;\n+\t  int end_pc = start_pc + length;\n+\t  tree decl = build_decl (VAR_DECL, name, type);\n+\t  if (end_pc > DECL_CODE_LENGTH (current_function_decl))\n+\t    {\n+\t      warning_with_decl (decl,\n+\t\t\t \"bad PC range for debug info for local `%s'\");\n+\t      end_pc = DECL_CODE_LENGTH (current_function_decl);\n+\t    }\n+\t  DECL_LANG_SPECIFIC (decl)\n+\t    = (struct lang_decl *) permalloc (sizeof (struct lang_decl_var));\n+\t  DECL_LOCAL_SLOT_NUMBER (decl) = slot;\n+\t  DECL_LOCAL_START_PC (decl) = start_pc;\n+\t  DECL_LOCAL_END_PC (decl) = end_pc;\n+\n+\t  /* Now insert the new decl in the proper place in\n+\t     pending_local_decls.  We are essentially doing an insertion sort,\n+\t     which works fine, since the list input will normally already\n+\t     be sorted. */\n+\t  ptr = &pending_local_decls;\n+\t  while (*ptr != NULL_TREE\n+\t\t && (DECL_LOCAL_START_PC (*ptr) > start_pc\n+\t\t     || (DECL_LOCAL_START_PC (*ptr) == start_pc\n+\t\t\t && DECL_LOCAL_END_PC (*ptr) < end_pc)))\n+\t    ptr = &TREE_CHAIN (*ptr);\n+\t  TREE_CHAIN (decl) = *ptr;\n+\t  *ptr = decl;\n+\t}\n+    }\n+\n+  pending_local_decls = nreverse (pending_local_decls);\n+\n+  /* Fill in default names for the parameters. */ \n+  for (parm = DECL_ARGUMENTS (current_function_decl), i = 0;\n+       parm != NULL_TREE;  parm = TREE_CHAIN (parm), i++)\n+    {\n+      if (DECL_NAME (parm) == NULL_TREE)\n+\t{\n+\t  int arg_i = METHOD_STATIC (current_function_decl) ? i+1 : i;\n+\t  if (arg_i == 0)\n+\t    DECL_NAME (parm) = get_identifier (\"this\");\n+\t  else\n+\t    {\n+\t      char buffer[12];\n+\t      sprintf (buffer, \"ARG_%d\", arg_i);\n+\t      DECL_NAME (parm) = get_identifier (buffer);\n+\t    }\n+\t  DECL_ASSEMBLER_NAME (parm) = DECL_NAME (parm);\n+\t}\n+    }\n+}\n+\n+void\n+complete_start_java_method (fndecl)\n+  tree fndecl;\n+{\n+\n+  DECL_RESULT (fndecl) = build_decl (RESULT_DECL, NULL_TREE,\n+\t\t\t\t     TREE_TYPE (TREE_TYPE (fndecl)));\n+\n+  if (! flag_emit_class_files)\n+    {\n+      /* Initialize the RTL code for the function.  */\n+      init_function_start (fndecl, input_filename, lineno);\n+\n+      /* Set up parameters and prepare for return, for the function.  */\n+      expand_function_start (fndecl, 0);\n+    }\n+\n+  /* Allocate further tree nodes temporarily during compilation\n+     of this function only.  */\n+  temporary_allocation ();\n+\n+#if 0\n+      /* If this fcn was already referenced via a block-scope `extern' decl (or\n+         an implicit decl), propagate certain information about the usage. */\n+      if (TREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (current_function_decl)))\n+        TREE_ADDRESSABLE (current_function_decl) = 1;\n+\n+#endif\n+\n+  if (METHOD_SYNCHRONIZED (fndecl))\n+    {\n+      /* FIXME: surround the function body by a try/finally set.  */\n+    }\n+\n+  /* Push local variables. Function compiled from source code are\n+     using a different local variables management, and for them,\n+     pushlevel shouldn't be called from here.  */\n+  if (!CLASS_FROM_SOURCE_P (DECL_CONTEXT (fndecl)))\n+\n+    {\n+      pushlevel (2);\n+      if (! flag_emit_class_files)\n+\texpand_start_bindings (1);\n+    }\n+}\n+\n+void\n+start_java_method (fndecl)\n+     tree fndecl;\n+{\n+  tree tem, *ptr;\n+  int i;\n+\n+  current_function_decl = fndecl;\n+  announce_function (fndecl);\n+\n+  i = DECL_MAX_LOCALS(fndecl) + DECL_MAX_STACK(fndecl);\n+  decl_map = make_tree_vec (i);\n+  type_map = (tree *) oballoc (i * sizeof (tree));\n+\n+  pushlevel (1);  /* Push parameters. */\n+\n+  ptr = &DECL_ARGUMENTS (fndecl);\n+  for (tem = TYPE_ARG_TYPES (TREE_TYPE (fndecl)), i = 0;\n+       tem != NULL_TREE; tem = TREE_CHAIN (tem), i++)\n+    {\n+      tree parm_name = NULL_TREE, parm_decl;\n+      if (i >= DECL_MAX_LOCALS(fndecl))\n+\tfatal (\"function has more parameters than local slots\");\n+\n+      parm_decl = build_decl (PARM_DECL, parm_name, TREE_VALUE (tem));\n+      DECL_CONTEXT (parm_decl) = fndecl;\n+      DECL_ARG_TYPE (parm_decl) = TREE_TYPE (parm_decl);\n+\n+      *ptr = parm_decl;\n+      ptr = &TREE_CHAIN (parm_decl);\n+\n+      /* Add parm_decl to the decl_map. */\n+      push_jvm_slot (i, parm_decl);\n+\n+      type_map[i] = TREE_TYPE (parm_decl);\n+      if (TYPE_IS_WIDE (TREE_TYPE (parm_decl)))\n+\t{\n+\t  i++;\n+\t  type_map[i] = void_type_node;\n+\t}\n+    }\n+  *ptr = NULL_TREE;\n+  DECL_ARG_SLOT_COUNT (current_function_decl) = i;\n+\n+  while (i < DECL_MAX_LOCALS(fndecl))\n+    type_map[i++] = NULL_TREE;\n+\n+  complete_start_java_method (fndecl);\n+}\n+\n+void\n+end_java_method ()\n+{\n+  tree fndecl = current_function_decl;\n+\n+  expand_end_bindings (getdecls (), 1, 0);\n+  /* pop out of function */\n+  poplevel (1, 1, 0);\n+\n+  /* pop out of its parameters */\n+  poplevel (1, 0, 1);\n+\n+  BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n+\n+  emit_handlers ();\n+\n+  /* Generate rtl for function exit.  */\n+  expand_function_end (input_filename, lineno, 0);\n+\n+  /* Run the optimizers and output assembler code for this function. */\n+  rest_of_compilation (fndecl);\n+\n+  current_function_decl = NULL_TREE;\n+  permanent_allocation (1);\n+}\n+\n+tree \n+build_decl_no_layout (code, name, type)\n+     enum tree_code code;\n+     tree name, type;\n+{\n+  tree decl = build_decl (TYPE_DECL, name, type);\n+  TREE_SET_CODE (decl, code);\n+  return decl;\n+}"}, {"sha": "46c0f7cd7138929c48c659500b931a83bf50c08c", "filename": "gcc/java/except.c", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,278 @@\n+/* Handle exceptions for GNU compiler for the Java(TM) language.\n+   Copyright (C) 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"real.h\"\n+#include \"rtl.h\"\n+#include \"java-tree.h\"\n+#include \"javaop.h\"\n+#include \"java-opcodes.h\"\n+#include \"jcf.h\"\n+#include \"except.h\"\n+#include \"java-except.h\"\n+#include \"eh-common.h\"\n+\n+extern struct obstack permanent_obstack;\n+\n+struct eh_range *current_method_handlers;\n+\n+struct eh_range *current_try_block = NULL;\n+\n+struct eh_range *eh_range_freelist = NULL;\n+\n+/* These variables are used to speed up find_handler. */\n+\n+static int cache_range_start, cache_range_end;\n+static struct eh_range *cache_range;\n+static struct eh_range *cache_next_child;\n+\n+/* A dummy range that represents the entire method. */\n+\n+struct eh_range whole_range;\n+\n+/* Search for the most specific eh_range containing PC.\n+   Assume PC is within RANGE.\n+   CHILD is a list of children of RANGE such that any\n+   previous children have end_pc values that are too low. */\n+\n+static struct eh_range *\n+find_handler_in_range (pc, range, child)\n+     int pc;\n+     struct eh_range *range;\n+     register struct eh_range *child;\n+{\n+  for (; child != NULL;  child = child->next_sibling)\n+    {\n+      if (pc < child->start_pc)\n+\tbreak;\n+      if (pc <= child->end_pc)\n+\treturn find_handler_in_range (pc, child, child->first_child);\n+    }\n+  cache_range = range;\n+  cache_range_start = pc;\n+  cache_next_child = child;\n+  cache_range_end = child == NULL ? range->end_pc : child->start_pc;\n+  return range;\n+}\n+\n+/* Find the inner-most handler that contains PC. */\n+\n+struct eh_range *\n+find_handler (pc)\n+     int pc;\n+{\n+  struct eh_range *h;\n+  if (pc >= cache_range_start)\n+    {\n+      h = cache_range;\n+      if (pc < cache_range_end)\n+\treturn h;\n+      while (pc >= h->end_pc)\n+\t{\n+\t  cache_next_child = h->next_sibling;\n+\t  h = h->outer;\n+\t}\n+    }\n+  else\n+    {\n+      h = &whole_range;\n+      cache_next_child = h->first_child;\n+    }\n+  return find_handler_in_range (pc, h, cache_next_child);\n+}\n+\n+#if 0\n+first_child;\n+next_sibling;\n+outer;\n+#endif\n+\n+/* Recursive helper routine for add_handler. */\n+\n+static int\n+link_handler (start_pc, end_pc, handler, type, outer)\n+     int start_pc, end_pc;\n+     tree handler;\n+     tree type;\n+     struct eh_range *outer;\n+{\n+  struct eh_range **ptr;\n+  if (start_pc < outer->start_pc || end_pc > outer->end_pc)\n+    return 0;  /* invalid or non-nested exception range */\n+  if (start_pc == outer->start_pc && end_pc == outer->end_pc)\n+    {\n+      outer->handlers = tree_cons (type, handler, outer->handlers);\n+      return 1;\n+    }\n+  ptr = &outer->first_child;\n+  for (;; ptr = &(*ptr)->next_sibling)\n+    {\n+      if (*ptr == NULL || end_pc <= (*ptr)->start_pc)\n+\t{\n+\t  struct eh_range *h = (struct eh_range *)\n+\t    oballoc (sizeof (struct eh_range));\n+\t  h->start_pc = start_pc;\n+\t  h->end_pc = end_pc;\n+\t  h->next_sibling = *ptr;\n+\t  h->first_child = NULL;\n+\t  h->outer = outer;\n+\t  h->handlers = build_tree_list (type, handler);\n+\t  *ptr = h;\n+\t  return 1;\n+\t}\n+      else if (start_pc < (*ptr)->end_pc)\n+\treturn link_handler (start_pc, end_pc, handler, type, *ptr);\n+      /* end_pc > (*ptr)->start_pc && start_pc >= (*ptr)->end_pc. */\n+    }\n+}\n+\n+/* Called to re-initialize the exception machinery for a new method. */\n+\n+void\n+method_init_exceptions ()\n+{\n+  whole_range.start_pc = 0;\n+  whole_range.end_pc = DECL_CODE_LENGTH (current_function_decl) + 1;\n+  whole_range.outer = NULL;\n+  whole_range.first_child = NULL;\n+  whole_range.next_sibling = NULL;\n+  cache_range_start = 0xFFFFFF;\n+  set_exception_lang_code (EH_LANG_Java);\n+  set_exception_version_code (1);\n+}\n+\n+int\n+add_handler (start_pc, end_pc, handler, type)\n+     int start_pc, end_pc;\n+     tree handler;\n+     tree type;\n+{\n+  return link_handler (start_pc, end_pc, handler, type, &whole_range);\n+}\n+\n+\n+/* if there are any handlers for this range, issue start of region */\n+void\n+expand_start_java_handler (range)\n+     struct eh_range *range;\n+{\n+  expand_eh_region_start ();\n+}\n+\n+/* if there are any handlers for this range, isssue end of range,\n+   and then all handler blocks */\n+void\n+expand_end_java_handler (range)\n+     struct eh_range *range;\n+{\n+  tree handler = range->handlers;\n+  expand_start_all_catch ();\n+  for ( ; handler != NULL_TREE; handler = TREE_CHAIN (handler))\n+    {\n+      tree type = TREE_PURPOSE (handler);\n+      tree exp;\n+      /* The \"type\" (metch_info) in a (Java) exception table is one:\n+       * a) NULL - meaning match any type in a try-finally.\n+       * b) a pointer to a (ccmpiled) class (low-order bit 0).\n+       * c) a pointer to the Utf8Const name of the class, plus one\n+       * (which yields a value with low-order bit 1). */\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+      if (type == NULL_TREE)\n+\texp = null_pointer_node;\n+      else if (is_compiled_class (type))\n+\texp = build_class_ref (type);\n+      else\n+\texp = fold (build (PLUS_EXPR, ptr_type_node,\n+\t\t\t   build_utf8_ref (build_internal_class_name (type)),\n+\t\t\t   size_one_node));\n+      pop_obstacks ();\n+      start_catch_handler (exp);\n+      expand_goto (TREE_VALUE (handler));\n+    }\n+  expand_end_all_catch ();\n+}\n+\n+/* Recursive helper routine for maybe_start_handlers. */\n+\n+static void\n+check_start_handlers (range, pc)\n+     struct eh_range *range;\n+     int pc;\n+{\n+  if (range != NULL_EH_RANGE && range->start_pc == pc)\n+    {\n+      check_start_handlers (range->outer, pc);\n+      expand_start_java_handler (range);\n+    }\n+}\n+\n+struct eh_range *current_range;\n+\n+/* Emit any start-of-try-range start at PC. */\n+\n+void\n+maybe_start_try (pc)\n+     int pc;\n+{\n+  if (! doing_eh (1))\n+    return;\n+\n+  current_range = find_handler (pc);\n+  check_start_handlers (current_range, pc);\n+}\n+\n+/* Emit any end-of-try-range end at PC. */\n+\n+void\n+maybe_end_try (pc)\n+     int pc;\n+{\n+  if (! doing_eh (1))\n+    return;\n+\n+  while (current_range != NULL_EH_RANGE && current_range->end_pc <= pc)\n+    {\n+      expand_end_java_handler (current_range);\n+      current_range = current_range->outer;\n+    }\n+}\n+\n+/* Emit the handler labels and their code */\n+\n+void\n+emit_handlers ()\n+{\n+  if (catch_clauses)\n+    {\n+      rtx funcend = gen_label_rtx ();\n+      emit_jump (funcend);\n+\n+      emit_insns (catch_clauses);\n+      expand_leftover_cleanups ();\n+\n+      emit_label (funcend);\n+    }\n+}"}, {"sha": "2c204da534f5ef73bf3069e401b026a49102ba3c", "filename": "gcc/java/expr.c", "status": "added", "additions": 2283, "deletions": 0, "changes": 2283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,2283 @@\n+/* Process expressions for the GNU compiler for the Java(TM) language.\n+   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Hacked by Per Bothner <bothner@cygnus.com> February 1996. */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"real.h\"\n+#include \"rtl.h\"\n+#include \"expr.h\"\n+#include \"java-tree.h\"\n+#include \"javaop.h\"\n+#include \"java-opcodes.h\"\n+#include \"jcf.h\"\n+#include \"java-except.h\"\n+#include \"parse.h\"\n+\n+static tree operand_type[59];\n+extern struct obstack permanent_obstack;\n+\n+void\n+init_expr_processing()\n+{\n+  operand_type[21] = operand_type[54] = int_type_node;\n+  operand_type[22] = operand_type[55] = long_type_node;\n+  operand_type[23] = operand_type[56] = float_type_node;\n+  operand_type[24] = operand_type[57] = double_type_node;\n+  operand_type[25] = operand_type[58] = ptr_type_node;\n+}\n+\n+/* We store the stack state in two places:\n+   Within a basic block, we use the quick_stack, which is a\n+   pushdown list (TREE_LISTs) of expression nodes.\n+   This is the top part of the stack;  below that we use find_stack_slot.\n+   At the end of a basic block, the quick_stack must be flushed\n+   to the stack slot array (as handled by find_stack_slot).\n+   Using quick_stack generates better code (especially when\n+   compiled without optimization), because we do not have to\n+   explicitly store and load trees to temporary variables.\n+\n+   If a variable is on the quick stack, it means the value of variable\n+   when the quick stack was last flushed.  Conceptually, flush_quick_stack\n+   saves all the the quick_stack elements in parellel.  However, that is\n+   complicated, so it actually saves them (i.e. copies each stack value\n+   to is home virtual register) from low indexes.  This allows a quick_stack\n+   element at index i (counting from the bottom of stack the) to references\n+   slot virtuals for register that are >= i, but not those that are deeper.\n+   This convention makes most operations easier.  For example iadd works\n+   even when the stack contains (reg[0], reg[1]):  It results in the\n+   stack containing (reg[0]+reg[1]), which is OK.  However, some stack\n+   operations are more complicated.  For example dup given a stack\n+   containing (reg[0]) would yield (reg[0], reg[0]), which would violate\n+   the convention, since stack value 1 would refer to a register with\n+   lower index (reg[0]), which flush_quick_stack does not safely handle.\n+   So dup cannot just add an extra element to the quick_stack, but iadd can.\n+*/\n+\n+tree quick_stack = NULL_TREE;\n+\n+/* A free-list of unused permamnet TREE_LIST nodes. */\n+tree tree_list_free_list = NULL_TREE;\n+\n+/* The stack pointer of the Java virtual machine.\n+   This does include the size of the quick_stack. */\n+\n+int stack_pointer;\n+\n+unsigned char *linenumber_table;\n+int linenumber_count;\n+\n+tree\n+truthvalue_conversion (expr)\n+     tree expr;\n+{\n+  /* It is simpler and generates better code to have only TRUTH_*_EXPR\n+     or comparison expressions as truth values at this level.\n+\n+     This function should normally be identity for Java.  */\n+\n+  switch (TREE_CODE (expr))\n+    {\n+    case EQ_EXPR:\n+    case NE_EXPR: case LE_EXPR: case GE_EXPR: case LT_EXPR: case GT_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case ERROR_MARK:\n+      return expr;\n+\n+    case INTEGER_CST:\n+      return integer_zerop (expr) ? boolean_false_node : boolean_true_node;\n+\n+    case REAL_CST:\n+      return real_zerop (expr) ? boolean_false_node : boolean_true_node;\n+\n+    /* are these legal? XXX JH */\n+    case NEGATE_EXPR:\n+    case ABS_EXPR:\n+    case FLOAT_EXPR:\n+    case FFS_EXPR:\n+      /* These don't change whether an object is non-zero or zero.  */\n+      return truthvalue_conversion (TREE_OPERAND (expr, 0));\n+\n+    case COND_EXPR:\n+      /* Distribute the conversion into the arms of a COND_EXPR.  */\n+      return fold (build (COND_EXPR, boolean_type_node, TREE_OPERAND (expr, 0),\n+                          truthvalue_conversion (TREE_OPERAND (expr, 1)),\n+                          truthvalue_conversion (TREE_OPERAND (expr, 2))));\n+\n+    case NOP_EXPR:\n+      /* If this is widening the argument, we can ignore it.  */\n+      if (TYPE_PRECISION (TREE_TYPE (expr))\n+          >= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (expr, 0))))\n+        return truthvalue_conversion (TREE_OPERAND (expr, 0));\n+      /* fall through to default */\n+\n+    default:\n+      return fold (build (NE_EXPR, boolean_type_node, expr, boolean_false_node));\n+    }\n+}\n+\n+#ifdef JAVA_USE_HANDLES\n+/* Given a pointer to a handle, get a pointer to an object. */\n+\n+tree\n+unhand_expr (expr)\n+     tree expr;\n+{\n+  tree field, handle_type;\n+  expr = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (expr)), expr);\n+  handle_type = TREE_TYPE (expr);\n+  field = TYPE_FIELDS (handle_type);\n+  expr = build (COMPONENT_REF, TREE_TYPE (field), expr, field);\n+  return expr;\n+}\n+#endif\n+\n+/* Save any stack slots that happen to be in the quick_stack into their\n+   home virtual register slots.\n+\n+   The copy order is from low stack index to high, to support the invariant\n+   that the expression for a slot may contain decls for stack slots with\n+   higher (or the same) index, but not lower. */\n+\n+void\n+flush_quick_stack ()\n+{\n+  int stack_index = stack_pointer;\n+  register tree prev, cur, next;\n+\n+  /* First reverse the quick_stack, and count the number of slots it has. */\n+  for (cur = quick_stack, prev = NULL_TREE; cur != NULL_TREE; cur = next)\n+    {\n+      next = TREE_CHAIN (cur);\n+      TREE_CHAIN (cur) = prev;\n+      prev = cur;\n+      stack_index -= 1 + TYPE_IS_WIDE (TREE_TYPE (TREE_VALUE (cur)));\n+    }\n+  quick_stack = prev;\n+\n+  while (quick_stack != NULL_TREE)\n+    {\n+      tree decl;\n+      tree node = quick_stack, type;\n+      quick_stack = TREE_CHAIN (node);\n+      TREE_CHAIN (node) = tree_list_free_list;\n+      tree_list_free_list = node;\n+      node = TREE_VALUE (node);\n+      type = TREE_TYPE (node);\n+\n+      decl = find_stack_slot (stack_index, type);\n+      if (decl != node)\n+\t  expand_assignment (decl, node, 0, 0);\n+      stack_index += 1 + TYPE_IS_WIDE (type);\n+    }\n+}\n+\n+void\n+push_type (type)\n+     tree type;\n+{\n+  int n_words;\n+  type = promote_type (type);\n+  n_words = 1 + TYPE_IS_WIDE (type);\n+  if (stack_pointer + n_words > DECL_MAX_STACK (current_function_decl))\n+    fatal (\"stack overflow\");\n+  stack_type_map[stack_pointer++] = type;\n+  n_words--;\n+  while (--n_words >= 0)\n+    stack_type_map[stack_pointer++] = TYPE_SECOND;\n+}\n+\n+void\n+push_value (value)\n+     tree value;\n+{\n+  tree type = TREE_TYPE (value);\n+  if (TYPE_PRECISION (type) < 32 && INTEGRAL_TYPE_P (type))\n+    {\n+      type = promote_type (type);\n+      value = convert (type, value);\n+    }\n+  push_type (type);\n+  if (tree_list_free_list == NULL_TREE)\n+    quick_stack = perm_tree_cons (NULL_TREE, value, quick_stack);\n+  else\n+    {\n+      tree node = tree_list_free_list;\n+      tree_list_free_list = TREE_CHAIN (tree_list_free_list);\n+      TREE_VALUE (node) = value;\n+      TREE_CHAIN (node) = quick_stack;\n+      quick_stack = node;\n+    }\n+}\n+\n+tree\n+pop_type (type)\n+     tree type;\n+{\n+  int n_words;\n+  int i;\n+  tree t;\n+  if (TREE_CODE (type) == RECORD_TYPE)\n+    type = promote_type (type);\n+  n_words = 1 + TYPE_IS_WIDE (type);\n+  if (stack_pointer < n_words)\n+    fatal (\"stack underflow\");\n+  while (--n_words > 0)\n+    {\n+      if (stack_type_map[--stack_pointer] != void_type_node)\n+\tfatal (\"Invalid multi-word value on type stack\");\n+    }\n+  t = stack_type_map[--stack_pointer];\n+  if (type == NULL_TREE || t == type)\n+    return t;\n+  if (INTEGRAL_TYPE_P (type) && INTEGRAL_TYPE_P (t)\n+      && TYPE_PRECISION (type) <= 32 && TYPE_PRECISION (t) <= 32)\n+      return t;\n+  if (TREE_CODE (type) == POINTER_TYPE && TREE_CODE (t) == POINTER_TYPE)\n+    {\n+      if (type == ptr_type_node || type == object_ptr_type_node)\n+\treturn t;\n+      else if (t == ptr_type_node)  /* Special case for null reference. */\n+\treturn type;\n+      else if (can_widen_reference_to (t, type))\n+\treturn t;\n+    }\n+  error (\"unexpected type on stack\");\n+  return t;\n+}\n+\n+/* Return 1f if SOURCE_TYPE can be safely widened to TARGET_TYPE.\n+   Handles array types and interfaces.  */\n+\n+int\n+can_widen_reference_to (source_type, target_type)\n+     tree source_type, target_type;\n+{\n+  if (source_type == ptr_type_node || target_type == object_ptr_type_node)\n+    return 1;\n+\n+  /* Get rid of pointers  */\n+  if (TREE_CODE (source_type) == POINTER_TYPE)\n+    source_type = TREE_TYPE (source_type);\n+  if (TREE_CODE (target_type) == POINTER_TYPE)\n+    target_type = TREE_TYPE (target_type);\n+\n+  if (source_type == target_type)\n+    return 1;\n+  else\n+    {\n+      source_type = HANDLE_TO_CLASS_TYPE (source_type);\n+      target_type = HANDLE_TO_CLASS_TYPE (target_type);\n+      if (TYPE_ARRAY_P (source_type) || TYPE_ARRAY_P (target_type))\n+\t{\n+\t  HOST_WIDE_INT source_length, target_length;\n+\t  if (TYPE_ARRAY_P (source_type) != TYPE_ARRAY_P (target_type))\n+\t    return 0;\n+\t  target_length = java_array_type_length (target_type);\n+\t  if (target_length >= 0)\n+\t    {\n+\t      source_length = java_array_type_length (source_type);\n+\t      if (source_length != target_length)\n+\t\treturn 0;\n+\t    }\n+\t  source_type = TYPE_ARRAY_ELEMENT (source_type);\n+\t  target_type = TYPE_ARRAY_ELEMENT (target_type);\n+\t  if (source_type == target_type)\n+\t    return 1;\n+\t  if (TREE_CODE (source_type) != POINTER_TYPE\n+\t      || TREE_CODE (target_type) != POINTER_TYPE)\n+\t    return 0;\n+\t  return can_widen_reference_to (source_type, target_type);\n+\t}\n+      else\n+\t{\n+\t  int source_depth = class_depth (source_type);\n+\t  int target_depth = class_depth (target_type);\n+\n+\t  if (CLASS_INTERFACE (TYPE_NAME (target_type)))\n+\t    {\n+\t      /* target_type is OK if source_type or source_type ancestors\n+\t\t implement target_type. We handle multiple sub-interfaces  */\n+\n+\t      tree basetype_vec = TYPE_BINFO_BASETYPES (source_type);\n+\t      int n = TREE_VEC_LENGTH (basetype_vec), i;\n+\t      for (i=0 ; i < n; i++)\n+\t        if (can_widen_reference_to \n+\t\t    (TREE_TYPE (TREE_VEC_ELT (basetype_vec, i)),\n+\t\t     target_type))\n+\t\t  return 1;\n+\t\tif (n == 0)\n+\t\t  return 0;\n+\t    }\n+\n+\t  for ( ; source_depth > target_depth;  source_depth--) \n+\t    {\n+\t      source_type = TYPE_BINFO_BASETYPE (source_type, 0); \n+\t    }\n+\t  return source_type == target_type;\n+\t}\n+    }\n+}\n+\n+tree\n+pop_value (type)\n+     tree type;\n+{\n+  int n_words = 1 + TYPE_IS_WIDE (type);\n+  int i;\n+  type = pop_type (type);\n+  if (quick_stack)\n+    {\n+      tree node = quick_stack;\n+      quick_stack = TREE_CHAIN (quick_stack);\n+      TREE_CHAIN (node) = tree_list_free_list;\n+      tree_list_free_list = node;\n+      node = TREE_VALUE (node);\n+      return node;\n+    }\n+  else\n+    return find_stack_slot (stack_pointer, promote_type (type));\n+}\n+\n+\n+/* Pop and discrad the top COUNT stack slots. */\n+\n+void\n+java_stack_pop (count)\n+     int count;\n+{\n+  while (count > 0)\n+    {\n+      tree type, val;\n+      if (stack_pointer == 0)\n+\tfatal (\"stack underflow\");\n+      type = stack_type_map[stack_pointer - 1];\n+      if (type == TYPE_SECOND)\n+\t{\n+\t  count--;\n+\t  if (stack_pointer == 1 || count <= 0)\n+\t    fatal (\"stack underflow\");\n+\t  type = stack_type_map[stack_pointer - 2];\n+\t}\n+      val = pop_value (type);\n+      count--;\n+    }\n+}\n+\n+/* Implement the 'swap' operator (to swap two top stack slots). */\n+\n+void\n+java_stack_swap ()\n+{\n+  tree type1, type2;\n+  rtx temp;\n+  tree decl1, decl2;\n+\n+  if (stack_pointer < 2\n+      || (type1 = stack_type_map[stack_pointer - 1]) == TYPE_UNKNOWN\n+      || (type2 = stack_type_map[stack_pointer - 2]) == TYPE_UNKNOWN\n+      || type1 == TYPE_SECOND || type2 == TYPE_SECOND\n+      || TYPE_IS_WIDE (type1) || TYPE_IS_WIDE (type2))\n+    fatal (\"bad stack swap\");\n+\n+  flush_quick_stack ();\n+  decl1 = find_stack_slot (stack_pointer - 1, type1);\n+  decl2 = find_stack_slot (stack_pointer - 2, type2);\n+  temp = copy_to_reg (DECL_RTL (decl1));\n+  emit_move_insn (DECL_RTL (decl1), DECL_RTL (decl2));\n+  emit_move_insn (DECL_RTL (decl2), temp);\n+  stack_type_map[stack_pointer - 1] = type2;\n+  stack_type_map[stack_pointer - 2] = type1;\n+}\n+\n+void\n+java_stack_dup (size, offset)\n+     int size, offset;\n+{\n+  int low_index = stack_pointer - size - offset;\n+  int dst_index;\n+  if (low_index < 0)\n+    error (\"stack underflow - dup* operation\");\n+\n+  flush_quick_stack ();\n+\n+  stack_pointer += size;\n+  dst_index = stack_pointer;\n+\n+  for (dst_index = stack_pointer;  --dst_index >= low_index; )\n+    {\n+      tree type;\n+      int src_index = dst_index - size;\n+      if (src_index < low_index)\n+\tsrc_index = dst_index + size + offset;\n+      type = stack_type_map [src_index];\n+      if (type == TYPE_SECOND)\n+\t{\n+\t  if (src_index <= low_index)\n+\t    fatal (\"dup operation splits 64-bit number\");\n+\t  stack_type_map[dst_index] = type;\n+\t  src_index--;  dst_index--;\n+\t  type = stack_type_map[src_index];\n+\t  if (! TYPE_IS_WIDE (type))\n+            fatal (\"internal error - dup operation\");\n+\t}\n+      else if (TYPE_IS_WIDE (type))\n+\tfatal (\"internal error - dup operation\");\n+      if (src_index != dst_index)\n+\t{\n+\t  tree src_decl = find_stack_slot (src_index, type);\n+\t  tree dst_decl = find_stack_slot (dst_index, type);\n+\t  emit_move_insn (DECL_RTL (dst_decl), DECL_RTL (src_decl));\n+\t  stack_type_map[dst_index] = type;\n+\t}\n+    }\n+}\n+\n+/* Calls soft_athrow.  Discard the contents of the value stack. */\n+\n+tree\n+build_java_athrow (node)\n+    tree node;\n+{\n+  tree call;\n+\n+  call = build (CALL_EXPR,\n+\t\tvoid_type_node,\n+\t\tbuild_address_of (throw_node),\n+\t\tbuild_tree_list (NULL_TREE, node),\n+\t\tNULL_TREE);\n+  TREE_SIDE_EFFECTS (call) = 1;\n+  expand_expr_stmt (call);\n+  java_stack_pop (stack_pointer);\n+}\n+\n+/* Implementation for jsr/ret */\n+\n+void\n+build_java_jsr (where, ret)\n+    tree where;\n+    tree ret;\n+{\n+  tree ret_label = fold (build1 (ADDR_EXPR, return_address_type_node, ret));\n+  push_value (ret_label);\n+  flush_quick_stack ();\n+  expand_goto (where);\n+  expand_label (ret);\n+}\n+\n+void\n+build_java_ret (location)\n+  tree location;\n+{\n+  expand_computed_goto (location);\n+}\n+ \n+/* Implementation of operations on array: new, load, store, length */\n+\n+/* Array core info access macros */\n+\n+#define JAVA_ARRAY_LENGTH_OFFSET(A)\t\t\t\t\t   \\\n+  size_binop (CEIL_DIV_EXPR, \t\t\t\t\t\t   \\\n+\t      (DECL_FIELD_BITPOS\t\t\t\t\t   \\\n+\t\t  (TREE_CHAIN (TYPE_FIELDS (TREE_TYPE (TREE_TYPE (A)))))), \\\n+              size_int (BITS_PER_UNIT))\n+\n+tree\n+decode_newarray_type  (int atype)\n+{\n+  switch (atype)\n+    {\n+    case 4:  return boolean_type_node;\n+    case 5:  return char_type_node;\n+    case 6:  return float_type_node;\n+    case 7:  return double_type_node;\n+    case 8:  return byte_type_node;\n+    case 9:  return short_type_node;\n+    case 10: return int_type_node;\n+    case 11: return long_type_node;\n+    default: return NULL_TREE;\n+    }\n+}\n+\n+/* Build a call to soft_badarrayindex(), the ArrayIndexOfBoundsException\n+   exception handler.  */\n+\n+static tree\n+build_java_throw_out_of_bounds_exception ()\n+{\n+  tree node = build (CALL_EXPR, int_type_node,\n+\t\t     build_address_of (soft_badarrayindex_node), \n+\t\t     NULL_TREE, NULL_TREE );\n+  TREE_SIDE_EFFECTS (node) = 1;\t/* Allows expansion within ANDIF */\n+  return (node);\n+}\n+\n+/* Return the length of an array. Doesn't perform any checking on the nature\n+   or value of the array NODE. May be used to implement some bytecodes.  */\n+\n+tree\n+build_java_array_length_access (node)\n+    tree node;\n+{\n+  tree type = TREE_TYPE (node);\n+  HOST_WIDE_INT length;\n+  if (!is_array_type_p (type))\n+    fatal (\"array length on a non-array reference\");\n+  length = java_array_type_length (type);\n+  if (length >= 0)\n+    return build_int_2 (length, 0);\n+  return fold (build1 (INDIRECT_REF,\n+\t\t       int_type_node,\n+\t\t       fold (build (PLUS_EXPR, ptr_type_node,\n+\t\t\t\t    node, \n+\t\t\t\t    JAVA_ARRAY_LENGTH_OFFSET(node)))));\n+}\n+\n+/* Optionally checks an array against the NULL pointer, eventually throwing a\n+   NullPointerException. It could replace signal handling, but tied to NULL.\n+   ARG1: the pointer to check, ARG2: the expression to use if\n+   the pointer is non-null and ARG3 the type that should be returned.   */\n+\n+tree\n+build_java_arraynull_check (node, expr, type)\n+    tree node;\t\t\t\n+    tree expr;\t\t\t\n+    tree type;\t\t\t\n+{\n+#if 0\n+  static int java_array_access_throws_null_exception = 0;\n+  node = ???;\n+  if (java_array_access_throws_null_exception)\n+      return (build (COND_EXPR, \n+\t\t     type,\n+\t\t     build (EQ_EXPR, int_type_node, node, null_pointer_node),\n+\t\t     build_java_athrow (node), expr ));\n+  else\n+#endif\n+      return (expr);\n+}\n+\n+static tree\n+java_array_data_offset (array)\n+     tree array;\n+{\n+  tree array_type = TREE_TYPE (TREE_TYPE (array));\n+  tree data_fld = TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (array_type)));\n+  if (data_fld == NULL_TREE)\n+    return size_in_bytes (array_type);\n+  else\n+    return build_int_2 (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (data_fld))\n+\t\t\t/ BITS_PER_UNIT, 0);\n+}\n+\n+/* Implement array indexing (either as l-value or r-value).\n+   Returns a tree for ARRAY[INDEX], assume TYPE is the element type.\n+   Optionally performs bounds checking and/or test to NULL.\n+   At this point, ARRAY should have been verified as an array.  */\n+\n+tree\n+build_java_arrayaccess (array, type, index)\n+    tree array, type, index;\n+{\n+  tree arith, node, throw = NULL_TREE;\n+\n+  arith = fold (build (PLUS_EXPR, int_type_node,\n+\t\t       java_array_data_offset (array),\n+\t\t       fold (build (MULT_EXPR, int_type_node,\n+\t\t\t\t    index, size_in_bytes(type)))));\n+\n+  if (flag_bounds_check)\n+    {\n+      /* Generate:\n+       * (unsigned jint) INDEX >= (unsigned jint) LEN\n+       *    && throw ArrayIndexOutOfBoundsException.\n+       * Note this is equivalent to and more efficient than:\n+       * INDEX < 0 || INDEX >= LEN && throw ... */\n+      tree test;\n+      tree len = build_java_array_length_access (array);\n+      TREE_TYPE (len) = unsigned_int_type_node;\n+      test = fold (build (GE_EXPR, boolean_type_node, \n+\t\t\t       convert (unsigned_int_type_node, index),\n+\t\t\t       len));\n+      if (! integer_zerop (test))\n+\t{\n+\t  throw = build (TRUTH_ANDIF_EXPR, int_type_node, test,\n+\t\t\t build_java_throw_out_of_bounds_exception ());\n+\t  /* allows expansion within COMPOUND */\n+\t  TREE_SIDE_EFFECTS( throw ) = 1;\n+\t}\n+    }\n+\n+  node = build1 (INDIRECT_REF, type, \n+\t\t fold (build (PLUS_EXPR, ptr_type_node, \n+\t\t\t      array, \n+\t\t\t      (throw ? build (COMPOUND_EXPR, int_type_node, \n+\t\t\t\t\t      throw, arith )\n+\t\t\t             : arith))));\n+\n+  return (fold (build_java_arraynull_check (array, node, type)));\n+}\n+\n+/* Makes sure that INDEXED_TYPE is appropriate. If not, make it from\n+   ARRAY_NODE. This function is used to retrieve something less vague than\n+   a pointer type when indexing the first dimension of something like [[<t>.\n+   May return a corrected type, if necessary, otherwise INDEXED_TYPE is\n+   return unchanged.\n+   As a side effect, it also makes sure that ARRAY_NODE is an array.  */\n+\n+static tree\n+build_java_check_indexed_type (array_node, indexed_type)\n+    tree array_node;\n+    tree indexed_type;\n+{\n+  tree elt_type;\n+\n+  if (!is_array_type_p (TREE_TYPE (array_node)))\n+    fatal (\"array indexing on a non-array reference\");\n+\n+  elt_type = (TYPE_ARRAY_ELEMENT (TREE_TYPE (TREE_TYPE (array_node))));\n+\n+  if (indexed_type == ptr_type_node )\n+      return promote_type (elt_type);\n+\n+  /* BYTE/BOOLEAN store and load are used for both type */\n+  if (indexed_type == byte_type_node && elt_type == boolean_type_node )\n+    return boolean_type_node;\n+\n+  if (indexed_type != elt_type )\n+    fatal (\"type array element mismatch\");\n+  else\n+    return indexed_type;\n+}\n+\n+/* newarray triggers a call to soft_newarray. This function should be called\n+   with an integer code (the type of array to create) and get from the stack\n+   the size of the dimmension.  */\n+\n+tree\n+build_newarray (atype_value, length)\n+     int atype_value;\n+     tree length;\n+{\n+  tree type = build_java_array_type (decode_newarray_type (atype_value),\n+\t\t\t\t     TREE_CODE (length) == INTEGER_CST\n+\t\t\t\t     ? TREE_INT_CST_LOW (length)\n+\t\t\t\t     : -1);\n+  return build (CALL_EXPR, promote_type (type),\n+\t\tbuild_address_of (soft_newarray_node),\n+\t\ttree_cons (NULL_TREE, \n+\t\t\t   build_int_2 (atype_value, 0),\n+\t\t\t   build_tree_list (NULL_TREE, length)),\n+\t\tNULL_TREE);\n+}\n+\n+/* Generates anewarray from a given CLASS_TYPE. Gets from the stack the size\n+   of the dimension. */\n+/* Merge with build_newarray.  FIXME. */\n+tree\n+build_anewarray (class_type, length)\n+    tree class_type;\n+    tree length;\n+{\n+  tree type = build_java_array_type (promote_type (class_type),\n+\t\t\t\t     TREE_CODE (length) == INTEGER_CST\n+\t\t\t\t     ? TREE_INT_CST_LOW (length)\n+\t\t\t\t     : -1);\n+  return build (CALL_EXPR, promote_type (type),\n+\t\tbuild_address_of (soft_anewarray_node),\n+\t\ttree_cons (NULL_TREE, length,\n+\t\t\t   tree_cons (NULL_TREE, build_class_ref (class_type),\n+\t\t\t\t      build_tree_list (NULL_TREE,\n+\t\t\t\t\t\t       null_pointer_node))),\n+\t\tNULL_TREE);\n+}\n+\n+/* Generates a call to multianewarray. multianewarray expects a class pointer,\n+   a number of dimensions and the matching number of dimensions. The argument\n+   list is NULL terminated.  */\n+\n+void\n+expand_java_multianewarray (class_type, ndim)\n+    tree class_type;\n+    int  ndim;\n+{\n+  int i;\n+  tree args = build_tree_list( NULL_TREE, null_pointer_node );\n+\n+  for( i = 0; i < ndim; i++ )\n+    args = tree_cons (NULL_TREE, pop_value (int_type_node), args);\n+\n+  push_value (build (CALL_EXPR,\n+\t\t     promote_type (class_type),\n+\t\t     build_address_of (soft_multianewarray_node),\n+\t\t     tree_cons (NULL_TREE, build_class_ref (class_type),\n+\t\t\t\ttree_cons (NULL_TREE, \n+\t\t\t\t\t   build_int_2 (ndim, 0), args )),\n+\t\t     NULL_TREE));\n+}\n+\n+/*  ARRAY[INDEX] <- RHS. build_java_check_indexed_type makes sure that\n+    ARRAY is an array type. May expand some bound checking and NULL\n+    pointer checking. RHS_TYPE_NODE we are going to store. In the case\n+    of the CHAR/BYTE/BOOLEAN SHORT, the type popped of the stack is an\n+    INT. In those cases, we make the convertion.\n+\n+    if ARRAy is a reference type, the assignment is checked at run-time\n+    to make sure that the RHS can be assigned to the array element\n+    type. It is not necessary to generate this code if ARRAY is final.  */\n+\n+void\n+expand_java_arraystore (rhs_type_node)\n+     tree rhs_type_node;\n+{\n+  tree rhs_node    = pop_value ((INTEGRAL_TYPE_P (rhs_type_node) \n+\t\t\t\t && TYPE_PRECISION (rhs_type_node) <= 32) ? \n+\t\t\t\t int_type_node : rhs_type_node);\n+  tree index = pop_value (int_type_node);\n+  tree array = pop_value (ptr_type_node);\n+\n+  rhs_type_node    = build_java_check_indexed_type (array, rhs_type_node);\n+\n+  flush_quick_stack ();\n+\n+  index = save_expr (index);\n+  array = save_expr (array);\n+\n+  if (TREE_CODE (rhs_type_node) == POINTER_TYPE\n+      && !CLASS_FINAL (TYPE_NAME (TREE_TYPE (rhs_type_node))))\n+    {\n+      tree check = build (CALL_EXPR, void_type_node,\n+\t\t\t  build_address_of (soft_checkarraystore_node),\n+\t\t\t  tree_cons (NULL_TREE, array,\n+\t\t\t\t     build_tree_list (NULL_TREE, rhs_node)),\n+\t\t\t  NULL_TREE);\n+      TREE_SIDE_EFFECTS (check) = 1;\n+      expand_expr_stmt (check);\n+    }\n+  \n+  expand_assignment (build_java_arrayaccess (array,\n+\t\t\t\t\t     rhs_type_node,\n+\t\t\t\t\t     index),\n+\t\t     rhs_node, 0, 0);\n+}\n+\n+/* Expand the evaluation of ARRAY[INDEX]. build_java_check_indexed_type makes \n+   sure that LHS is an array type. May expand some bound checking and NULL\n+   pointer checking.  \n+   LHS_TYPE_NODE is the type of ARRAY[INDEX]. But in the case of CHAR/BYTE/\n+   BOOLEAN/SHORT, we push a promoted type back to the stack.\n+*/\n+\n+void\n+expand_java_arrayload (lhs_type_node )\n+    tree lhs_type_node;\n+{\n+  tree load_node;\n+  int convert;\n+  tree index_node = pop_value (int_type_node);\n+  tree array_node = pop_value (ptr_type_node);\n+\n+  index_node = save_expr (index_node);\n+  array_node = save_expr (array_node);\n+  lhs_type_node   = build_java_check_indexed_type (array_node, lhs_type_node);\n+\n+  load_node = build_java_arrayaccess (array_node,\n+\t\t\t\t      lhs_type_node,\n+\t\t\t\t      index_node);\n+\n+  if (INTEGRAL_TYPE_P (lhs_type_node) && TYPE_PRECISION (lhs_type_node) <= 32)\n+    load_node = fold (build1 (NOP_EXPR, int_type_node, load_node));\n+  push_value (load_node);\n+}\n+\n+/* Expands .length. Makes sure that we deal with and array and may expand\n+   a NULL check on the array object.  */\n+\n+void\n+expand_java_array_length ()\n+{\n+  tree array  = pop_value (ptr_type_node);\n+  tree length = build_java_array_length_access (array);\n+\n+  push_value (build_java_arraynull_check (array, length, int_type_node));\n+}\n+\n+/* Emit code for the call to soft_monitor{enter,exit}. CALL can be either\n+   soft_monitorenter_node or soft_monitorexit_node.  */\n+\n+tree\n+build_java_monitor (call, object)\n+    tree call;\n+    tree object;\n+{\n+  return (build (CALL_EXPR,\n+\t\t void_type_node,\n+\t\t build_address_of (call),\n+\t\t build_tree_list (NULL_TREE, object),\n+\t\t NULL_TREE));\n+}\n+\n+/* Emit code for one of the PUSHC instructions. */\n+\n+void\n+expand_java_pushc (ival, type)\n+     int ival;\n+     tree type;\n+{\n+  tree value;\n+  if (type == ptr_type_node && ival == 0)\n+    value = null_pointer_node;\n+  else if (type == int_type_node || type == long_type_node)\n+    {\n+      value = build_int_2 (ival, ival < 0 ? -1 : 0);\n+      TREE_TYPE (value) = type;\n+    }\n+  else if (type == float_type_node || type == double_type_node)\n+    {\n+      REAL_VALUE_TYPE x;\n+#ifdef REAL_ARITHMETIC\n+      REAL_VALUE_FROM_INT (x, ival, 0, TYPE_MODE (type));\n+#else\n+      x = ival;\n+#endif\n+      value = build_real (type, x);\n+    }\n+  else\n+    fatal (\"internal error in expand_java_pushc\");\n+  push_value (value);\n+}\n+\n+void\n+expand_java_return (type)\n+     tree type;\n+{\n+  if (type == void_type_node)\n+    expand_null_return ();\n+  else\n+    {\n+      tree retval = pop_value (type);\n+      tree res = DECL_RESULT (current_function_decl);\n+      retval = build (MODIFY_EXPR, TREE_TYPE (res), res, retval);\n+      TREE_SIDE_EFFECTS (retval) = 1;\n+      expand_return (retval);\n+    }\n+}\n+\n+tree\n+build_address_of (value)\n+     tree value;\n+{\n+  return build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (value)), value);\n+}\n+\n+void\n+expand_java_NEW (type)\n+     tree type;\n+{\n+  if (! CLASS_LOADED_P (type))\n+    load_class (type, 1);\n+  push_value (build (CALL_EXPR, promote_type (type),\n+\t\t     build_address_of (alloc_object_node),\n+\t\t     tree_cons (NULL_TREE, build_class_ref (type),\n+\t\t\t\tbuild_tree_list (NULL_TREE,\n+\t\t\t\t\t\t size_in_bytes (type))),\n+\t\t     NULL_TREE));\n+}\n+\n+void\n+expand_java_INSTANCEOF (type)\n+     tree type;\n+{\n+  tree value = pop_value (object_ptr_type_node);\n+  value = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (soft_instanceof_node)),\n+\t\t build_address_of (soft_instanceof_node),\n+\t\t tree_cons (NULL_TREE, value,\n+\t\t\t    build_tree_list (NULL_TREE,\n+\t\t\t\t\t     build_class_ref (type))),\n+\t\t NULL_TREE);\n+  push_value (value);\n+}\n+\n+void\n+expand_java_CHECKCAST (type)\n+     tree type;\n+{\n+  tree value = pop_value (ptr_type_node);\n+  value = build (CALL_EXPR, promote_type (type),\n+\t\t build_address_of (soft_checkcast_node),\n+\t\t tree_cons (NULL_TREE, build_class_ref (type),\n+\t\t\t    build_tree_list (NULL_TREE, value)),\n+\t\t NULL_TREE);\n+  push_value (value);\n+}\n+\n+void\n+expand_iinc (unsigned int local_var_index, int ival, int pc)\n+{\n+    tree local_var, res;\n+    tree constant_value;\n+\n+    flush_quick_stack ();\n+    local_var = find_local_variable (local_var_index, int_type_node, pc);\n+    constant_value = build_int_2 (ival, ival < 0 ? -1 : 0);\n+    res = fold (build (PLUS_EXPR, int_type_node, local_var, constant_value));\n+    expand_assignment (local_var, res, 0, 0);\n+}\n+\n+tree\n+build_java_binop (op, type, arg1, arg2)\n+     enum tree_code op;\n+     tree type, arg1, arg2;\n+{\n+  tree mask;\n+  switch (op)\n+    {\n+    case URSHIFT_EXPR:\n+      {\n+\ttree u_type = unsigned_type (type);\n+\targ1 = convert (u_type, arg1);\n+\targ1 = build_java_binop (RSHIFT_EXPR, u_type, arg1, arg2);\n+\treturn convert (type, arg1);\n+      }\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+      mask = build_int_2 (TYPE_PRECISION (TREE_TYPE (arg1)) - 1, 0);\n+      arg2 = fold (build (BIT_AND_EXPR, int_type_node, arg2, mask));\n+      break;\n+\n+    case COMPARE_L_EXPR:  /* arg1 > arg2 ?  1 : arg1 == arg2 ? 0 : -1 */\n+    case COMPARE_G_EXPR:  /* arg1 < arg2 ? -1 : arg1 == arg2 ? 0 :  1 */\n+      arg1 = save_expr (arg1);  arg2 = save_expr (arg2);\n+      {\n+\ttree ifexp1 = fold ( build (op == COMPARE_L_EXPR ? GT_EXPR : LT_EXPR,\n+\t\t\t\t    boolean_type_node, arg1, arg2));\n+\ttree ifexp2 = fold ( build (EQ_EXPR, boolean_type_node, arg1, arg2));\n+\ttree second_compare = fold (build (COND_EXPR, int_type_node,\n+\t\t\t\t\t   ifexp2, integer_zero_node,\n+\t\t\t\t\t   op == COMPARE_L_EXPR\n+\t\t\t\t\t   ? integer_negative_one_node\n+\t\t\t\t\t   : integer_one_node));\n+\treturn fold (build (COND_EXPR, int_type_node, ifexp1,\n+\t\t\t    op == COMPARE_L_EXPR ? integer_one_node\n+\t\t\t    : integer_negative_one_node,\n+\t\t\t    second_compare));\n+      }\n+    case COMPARE_EXPR:\n+      arg1 = save_expr (arg1);  arg2 = save_expr (arg2);\n+      {\n+\ttree ifexp1 = fold ( build (LT_EXPR, boolean_type_node, arg1, arg2));\n+\ttree ifexp2 = fold ( build (GT_EXPR, boolean_type_node, arg1, arg2));\n+\ttree second_compare = fold ( build (COND_EXPR, int_type_node,\n+\t\t\t\t\t    ifexp2, integer_one_node,\n+\t\t\t\t\t    integer_zero_node));\n+\treturn fold (build (COND_EXPR, int_type_node,\n+\t\t\t    ifexp1, integer_negative_one_node, second_compare));\n+      }\n+\n+    case TRUNC_MOD_EXPR:\n+      if (TREE_CODE (type) == REAL_TYPE)\n+\t{\n+\t  tree call;\n+\t  if (type != double_type_node)\n+\t    {\n+\t      arg1 = convert (double_type_node, arg1);\n+\t      arg2 = convert (double_type_node, arg2);\n+\t    }\n+\t  call = build (CALL_EXPR, double_type_node,\n+\t\t\tbuild_address_of (soft_fmod_node),\n+\t\t\ttree_cons (NULL_TREE, arg1,\n+\t\t\t\t   build_tree_list (NULL_TREE, arg2)),\n+\t\t\tNULL_TREE);\n+\t  if (type != double_type_node)\n+\t    call = convert (type, call);\n+\t  return call;\n+\t}\n+      break;\n+\n+#if 0\t/* not required */\n+    case PLUS_EXPR:\n+    case MULT_EXPR:\n+    case MINUS_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case RDIV_EXPR:\n+/*    case REM_EXPR: */\n+    case BIT_AND_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+      break;\n+    default:\n+      error (\"unknown opcode\");\n+      return error_mark_node;\n+#endif\n+\n+    }\n+  return fold (build (op, type, arg1, arg2));\n+}\n+\n+void\n+expand_java_binop (type, op)\n+     tree type;  enum tree_code op;\n+{\n+  tree larg, rarg;\n+  tree ltype = type;\n+  tree rtype = type;\n+  switch (op)\n+    {\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case URSHIFT_EXPR:\n+      rtype = int_type_node;\n+      rarg = pop_value (rtype);\n+      break;\n+    default:\n+      rarg = pop_value (rtype);\n+    }\n+  larg = pop_value (ltype);\n+  push_value (build_java_binop (op, type, larg, rarg));\n+}\n+\n+/* Lookup the field named NAME in *TYPEP or its super classes.\n+   If not found, return NULL_TREE.\n+   (If the *TYPEP is not found, return error_mark_node.)\n+   If found, return the FIELD_DECL, and set *TYPEP to the\n+   class containing the field. */\n+\n+tree\n+lookup_field (typep, name)\n+     tree *typep;\n+     tree name;\n+{\n+  if (CLASS_P (*typep) && !CLASS_LOADED_P (*typep))\n+    {\n+      load_class (*typep, 1);\n+      if (TREE_CODE (TYPE_SIZE (*typep)) == ERROR_MARK)\n+\treturn error_mark_node;\n+    }\n+  do\n+    {\n+      tree field;\n+      for (field = TYPE_FIELDS (*typep);  field;  field = TREE_CHAIN (field))\n+\t{\n+\t  if (DECL_NAME (field) == name)\n+\t    return field;\n+\t}\n+      *typep = CLASSTYPE_SUPER (*typep);\n+    } while (*typep);\n+  return NULL_TREE;\n+}\n+\n+/* Look up the field named NAME in object SELF_VALUE,\n+   which has class SELF_CLASS (a non-handle RECORD_TYPE).\n+   SELF_VALUE is NULL_TREE if looking for a static field. */\n+\n+tree\n+build_field_ref (self_value, self_class, name)\n+     tree self_value, self_class, name;\n+{\n+  tree base_class = self_class;\n+  tree field_decl = lookup_field (&base_class, name);\n+  if (field_decl == NULL_TREE)\n+    {\n+      error (\"field `%s' not found\", IDENTIFIER_POINTER (name));\n+      return error_mark_node;\n+    }\n+  if (self_value == NULL_TREE)\n+    {\n+      return build_static_field_ref (field_decl);\n+    }\n+  else\n+    {\n+      tree base_handle_type = promote_type (base_class);\n+      if (base_handle_type != TREE_TYPE (self_value))\n+\tself_value = fold (build1 (NOP_EXPR, base_handle_type, self_value));\n+#ifdef JAVA_USE_HANDLES\n+      self_value = unhand_expr (self_value);\n+#endif\n+      self_value = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (self_value)),\n+\t\t\t   self_value);\n+      return fold (build (COMPONENT_REF, TREE_TYPE (field_decl),\n+\t\t\t  self_value, field_decl));\n+    }\n+}\n+\n+tree\n+lookup_label (pc)\n+     int pc;\n+{\n+  tree name;\n+  char buf[20];\n+  sprintf (buf, \"LJpc=%d\", pc);\n+  name = get_identifier (buf);\n+  if (IDENTIFIER_LOCAL_VALUE (name))\n+    return IDENTIFIER_LOCAL_VALUE (name);\n+  else\n+    {\n+      /* The type of the address of a label is return_address_type_node. */\n+      tree decl = create_label_decl (name);\n+      LABEL_PC (decl) = pc;\n+      label_rtx (decl);\n+      return pushdecl (decl);\n+    }\n+}\n+\n+tree\n+create_label_decl (name)\n+     tree name;\n+{\n+  tree decl;\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  decl = build_decl (LABEL_DECL, name, \n+\t\t     TREE_TYPE (return_address_type_node));\n+  pop_obstacks ();\n+  DECL_CONTEXT (decl) = current_function_decl;\n+  DECL_IGNORED_P (decl) = 1;\n+  return decl;\n+}\n+\n+/* This maps a bytecode offset (PC) to various flags. */\n+char *instruction_bits;\n+\n+void\n+note_label (current_pc, target_pc)\n+     int current_pc, target_pc;\n+{\n+  lookup_label (target_pc);\n+  instruction_bits [target_pc] |= BCODE_JUMP_TARGET;\n+}\n+\n+/* Emit code to jump to TARGET_PC if VALUE1 CONDITION VALUE2,\n+   where CONDITION is one of one the compare operators. */\n+\n+\n+void\n+expand_compare (condition, value1, value2, target_pc)\n+     enum tree_code condition;\n+     tree value1, value2;\n+     int target_pc;\n+{\n+  tree target = lookup_label (target_pc);\n+  tree cond = fold (build (condition, boolean_type_node, value1, value2));\n+  expand_start_cond (truthvalue_conversion (cond), 0);\n+  expand_goto (target);\n+  expand_end_cond ();\n+}\n+\n+/* Emit code for a TEST-type opcode. */\n+\n+void\n+expand_test (condition, type, target_pc)\n+     enum tree_code condition;\n+     tree type;\n+     int target_pc;\n+{\n+  tree value1, value2;\n+  flush_quick_stack ();\n+  value1 = pop_value (type);\n+  value2 = (type == ptr_type_node) ? null_pointer_node : integer_zero_node;\n+  expand_compare (condition, value1, value2, target_pc);\n+}\n+\n+/* Emit code for a COND-type opcode. */\n+\n+void\n+expand_cond (condition, type, target_pc)\n+     enum tree_code condition;\n+     tree type;\n+     int target_pc;\n+{\n+  tree value1, value2;\n+  flush_quick_stack ();\n+  /* note: pop values in opposite order */\n+  value2 = pop_value (type);\n+  value1 = pop_value (type);\n+  /* Maybe should check value1 and value2 for type compatibility ??? */\n+  expand_compare (condition, value1, value2, target_pc);\n+}\n+\n+void\n+expand_java_goto (target_pc)\n+     int target_pc;\n+{\n+  tree target_label = lookup_label (target_pc);\n+  flush_quick_stack ();\n+  expand_goto (target_label);\n+}\n+\n+void\n+expand_java_call (target_pc, return_address)\n+     int target_pc, return_address;\n+{\n+  tree target_label = lookup_label (target_pc);\n+  tree value = build_int_2 (return_address, return_address < 0 ? -1 : 0);\n+  push_value (value);\n+  flush_quick_stack ();\n+  expand_goto (target_label);\n+}\n+\n+void\n+expand_java_ret (return_address)\n+     tree return_address;\n+{\n+  warning (\"ret instruction not implemented\");\n+#if 0\n+  tree target_label = lookup_label (target_pc);\n+  flush_quick_stack ();\n+  expand_goto (target_label);\n+#endif\n+}\n+\n+/* Recursive helper function to pop argument types during verifiation. */\n+\n+void\n+pop_argument_types (arg_types)\n+     tree arg_types;\n+{\n+  if (arg_types == NULL_TREE)\n+    return;\n+  if (TREE_CODE (arg_types) == TREE_LIST)\n+    {\n+      pop_argument_types (TREE_CHAIN (arg_types));\n+      pop_type (TREE_VALUE (arg_types));\n+      return;\n+    }\n+  abort ();\n+}\n+\n+tree\n+pop_arguments (arg_types)\n+     tree arg_types;\n+{\n+  if (arg_types == NULL_TREE)\n+    return NULL_TREE;\n+  if (TREE_CODE (arg_types) == TREE_LIST)\n+    {\n+      tree tail = pop_arguments (TREE_CHAIN (arg_types));\n+      return tree_cons (NULL_TREE, pop_value (TREE_VALUE (arg_types)), tail);\n+    }\n+  abort ();\n+}\n+\n+/* Build an expression to initialize the class CLAS.\n+   if EXPR is non-NULL, returns an expression to first call the initializer\n+   (if it is needed) and then calls EXPR. */\n+\n+tree\n+build_class_init (clas, expr)\n+     tree clas, expr;\n+{\n+  tree init;\n+  if (inherits_from_p (current_class, clas))\n+    return expr;\n+  init = build (CALL_EXPR, void_type_node,\n+\t\tbuild_address_of (soft_initclass_node),\n+\t\tbuild_tree_list (NULL_TREE, build_class_ref (clas)),\n+\t\tNULL_TREE);\n+  TREE_SIDE_EFFECTS (init) = 1;\n+  if (expr != NULL_TREE)\n+    {\n+      expr = build (COMPOUND_EXPR, TREE_TYPE (expr), init, expr);\n+      TREE_SIDE_EFFECTS (expr) = 1;\n+      return expr;\n+    }\n+  return init;\n+}\n+\n+static tree methods_ident = NULL_TREE;\n+static tree ncode_ident = NULL_TREE;\n+tree dtable_ident = NULL_TREE;\n+\n+tree\n+build_known_method_ref (method, method_type, self_type, method_signature, arg_list)\n+     tree method, method_type, self_type, method_signature, arg_list;\n+{\n+  tree func;\n+  if (flag_emit_class_files)\n+    return method;\n+  else if (is_compiled_class (self_type))\n+    {\n+      make_decl_rtl (method, NULL, 1);\n+      func = build1 (ADDR_EXPR, method_ptr_type_node, method);\n+    }\n+  else\n+    {\n+      /* We don't know whether the method has been (statically) compiled.\n+\t Compile this code to get a reference to the method's code:\n+\t \n+\t SELF_TYPE->methods[METHOD_INDEX].ncode\n+\t \n+\t This is guaranteed to work (assuming SELF_TYPE has\n+\t been initialized), since if the method is not compiled yet,\n+\t its ncode points to a trampoline that forces compilation. */\n+      \n+      int method_index = 0;\n+      tree meth;\n+      tree ref = build_class_ref (self_type);\n+      ref = build1 (INDIRECT_REF, class_type_node, ref);\n+      if (ncode_ident == NULL_TREE)\n+\tncode_ident = get_identifier (\"ncode\");\n+      if (methods_ident == NULL_TREE)\n+\tmethods_ident = get_identifier (\"methods\");\n+      ref = build (COMPONENT_REF, method_ptr_type_node, ref,\n+\t\t   lookup_field (&class_type_node, methods_ident));\n+      for (meth = TYPE_METHODS (CLASS_TO_HANDLE_TYPE (self_type));\n+\t   ; meth = TREE_CHAIN (meth))\n+\t{\n+\t  if (method == meth)\n+\t    break;\n+\t  if (meth == NULL_TREE)\n+\t    fatal (\"method '%s' not found in class\",\n+\t\t   IDENTIFIER_POINTER (DECL_NAME (method)));\n+\t  method_index++;\n+\t}\n+      method_index *= int_size_in_bytes (method_type_node);\n+      ref = fold (build (PLUS_EXPR, method_ptr_type_node,\n+\t\t\t ref, build_int_2 (method_index, 0)));\n+      ref = build1 (INDIRECT_REF, method_type_node, ref);\n+      func = build (COMPONENT_REF, nativecode_ptr_type_node,\n+\t\t    ref,\n+\t\t    lookup_field (&method_type_node, ncode_ident));\n+    }\n+  return func;\n+}\n+\n+tree\n+invoke_build_dtable (is_invoke_interface, arg_list)\n+     int is_invoke_interface;\n+     tree arg_list;\n+{\n+  tree dtable, objectref;\n+\n+  TREE_VALUE (arg_list) = save_expr (TREE_VALUE (arg_list));\n+\n+  /* If we're dealing with interfaces and if the objectref\n+     argument is an array then get the dispatch table of the class\n+     Object rather than the one from the objectref.  */\n+  objectref = (is_invoke_interface \n+\t       && is_array_type_p (TREE_TYPE (TREE_VALUE (arg_list))) ?\n+\t       object_type_node : TREE_VALUE (arg_list));\n+  \n+  if (dtable_ident == NULL_TREE)\n+    dtable_ident = get_identifier (\"dtable\");\n+  dtable = build1 (INDIRECT_REF, object_type_node, objectref );\n+  dtable = build (COMPONENT_REF, dtable_ptr_type, dtable,\n+\t\t  lookup_field (&object_type_node, dtable_ident));\n+\n+  return dtable;\n+}\n+\n+tree \n+build_invokevirtual (dtable, method)\n+     tree dtable, method;\n+{\n+  tree func;\n+  tree nativecode_ptr_ptr_type_node\n+    = build_pointer_type (nativecode_ptr_type_node);\n+  int method_index = TREE_INT_CST_LOW (DECL_VINDEX (method));\n+  /* Add one to skip \"class\" field of dtable, and one to skip unused\n+     vtable entry (for C++ compatibility). */\n+  method_index += 2;\n+  method_index\n+    *= int_size_in_bytes (nativecode_ptr_ptr_type_node);\n+  func = fold (build (PLUS_EXPR, nativecode_ptr_ptr_type_node,\n+\t\t      dtable, build_int_2 (method_index, 0)));\n+  func = build1 (INDIRECT_REF, nativecode_ptr_type_node, func);\n+\n+  return func;\n+}\n+\n+/* Expand one of the invoke_* opcodes.\n+   OCPODE is the specific opcode.\n+   METHOD_REF_INDEX is an index into the constant pool.\n+   NARGS is the number of arguments, or -1 if not specified. */\n+\n+void\n+expand_invoke (opcode, method_ref_index, nargs)\n+     int opcode;\n+     int method_ref_index;\n+     int nargs;\n+{\n+  tree method_signature = COMPONENT_REF_SIGNATURE(&current_jcf->cpool, method_ref_index);\n+  tree method_name = COMPONENT_REF_NAME (&current_jcf->cpool, method_ref_index);\n+  tree self_type = get_class_constant\n+    (current_jcf, COMPONENT_REF_CLASS_INDEX(&current_jcf->cpool, method_ref_index));\n+  char *self_name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (self_type)));\n+  tree call, func, method, arg_list, method_type;\n+\n+  static tree class_ident = NULL_TREE;\n+\n+  if (! CLASS_LOADED_P (self_type))\n+    {\n+      load_class (self_type, 1);\n+      if (TREE_CODE (TYPE_SIZE (self_type)) == ERROR_MARK)\n+\tfatal (\"failed to find class '%s'\", self_name);\n+    }\n+\n+  if (method_name == init_identifier_node)\n+    method = lookup_java_constructor (CLASS_TO_HANDLE_TYPE (self_type),\n+\t\t\t\t      method_signature);\n+  else\n+    method = lookup_java_method (CLASS_TO_HANDLE_TYPE (self_type),\n+\t\t\t\t method_name, method_signature);\n+  if (method == NULL_TREE)\n+    {\n+      error (\"Class '%s' has no method named '%s' matching signature '%s'\",\n+\t     self_name,\n+\t     IDENTIFIER_POINTER (method_name),\n+\t     IDENTIFIER_POINTER (method_signature));\n+    }\n+  /* Invoke static can't invoke static/abstract method */\n+  else if (opcode == OPCODE_invokestatic)\n+    {\n+      if (!METHOD_STATIC (method))\n+\t{\n+\t  error (\"invokestatic on non static method\");\n+\t  method = NULL_TREE;\n+\t}\n+      else if (METHOD_ABSTRACT (method))\n+\t{\n+\t  error (\"invokestatic on abstract method\");\n+\t  method = NULL_TREE;\n+\t}\n+    }\n+  else\n+    {\n+      if (METHOD_STATIC (method))\n+\t{\n+\t  error (\"invoke[non-static] on static method\");\n+\t  method = NULL_TREE;\n+\t}\n+    }\n+\n+  if (method == NULL_TREE)\n+    {\n+      method_type = get_type_from_signature (method_signature);\n+      pop_arguments (TYPE_ARG_TYPES (method_type));\n+      if (opcode != OPCODE_invokestatic) \n+\tpop_type (self_type);\n+      method_type = promote_type (TREE_TYPE (method_type));\n+      push_value (convert (method_type, integer_zero_node));\n+      return;\n+    }\n+\n+  method_type = TREE_TYPE (method);\n+  arg_list = pop_arguments (TYPE_ARG_TYPES (method_type));\n+  flush_quick_stack ();\n+\n+  if (opcode == OPCODE_invokestatic || opcode == OPCODE_invokespecial\n+      && ! inherits_from_p (current_class, self_type))\n+    { /* FIXME probably not needed for invokespecial if done by NEW. */\n+      /* Ensure self_type is initialized. */ \n+      func = build (CALL_EXPR, void_type_node, soft_initclass_node,\n+\t\t    build_tree_list (NULL_TREE,\n+\t\t\t\t     build_class_ref (self_type)),\n+\t\t    NULL_TREE);\n+      expand_expr_stmt (func);\n+    }\n+\n+  func = NULL_TREE;\n+  if (opcode == OPCODE_invokestatic || opcode == OPCODE_invokespecial\n+      || (opcode == OPCODE_invokevirtual\n+\t  && (METHOD_FINAL (method) || CLASS_FINAL (TYPE_NAME (self_type)))))\n+    func = build_known_method_ref (method, method_type, self_type,\n+\t\t\t\t   method_signature, arg_list);\n+  else\n+    {\n+      tree dtable = invoke_build_dtable (opcode == OPCODE_invokeinterface, \n+\t\t\t\t\t arg_list);\n+      if (opcode == OPCODE_invokevirtual)\n+\tfunc = build_invokevirtual (dtable, method);\n+      else\n+\t{\n+\t  /* We expand invokeinterface here. soft_lookupinterfacemethod () will\n+\t     ensure that the selected method exists, is public and not abstract\n+\t     nor static.  */\n+\t    \n+\t  tree lookup_arg;\n+\n+\t  if (class_ident == NULL_TREE)\n+\t    class_ident = get_identifier (\"class\");\n+\n+\t  dtable = build1 (INDIRECT_REF, dtable_type, dtable);\n+\t  dtable = build (COMPONENT_REF, class_ptr_type, dtable,\n+\t\t\t  lookup_field (&dtable_type, class_ident));\n+\t  lookup_arg = build_tree_list (NULL_TREE,\n+\t\t\t\t\tbuild_utf8_ref (method_signature));\n+\t  lookup_arg = tree_cons (NULL_TREE, dtable,\n+\t\t\t\t  tree_cons (NULL_TREE,\n+\t\t\t\t\t     build_utf8_ref (method_name),\n+\t\t\t\t\t     lookup_arg));\n+\t  func = build (CALL_EXPR,\n+\t\t\tptr_type_node,\n+\t\t\tbuild_address_of (soft_lookupinterfacemethod_node),\n+\t\t\tlookup_arg, NULL_TREE);\n+\t}\n+    }\n+  func = build1 (NOP_EXPR, build_pointer_type (method_type), func);\n+  call = build (CALL_EXPR, TREE_TYPE (method_type), func, arg_list, NULL_TREE);\n+  TREE_SIDE_EFFECTS (call) = 1;\n+\n+  if (opcode == OPCODE_invokestatic || opcode == OPCODE_invokespecial)\n+    { /* FIXME probably not needed for invokespecial if done by NEW. */\n+      /* Ensure self_type is initialized. */ \n+      call = build_class_init (self_type, call);\n+    }\n+\n+  if (TREE_CODE (TREE_TYPE (method_type)) == VOID_TYPE)\n+    expand_expr_stmt (call);\n+  else\n+    {\n+      push_value (call);\n+      flush_quick_stack ();\n+    }\n+}\n+\n+\n+/* Expand an operation to extract from or store into a field.\n+   IS_STATIC is 1 iff the field is static.\n+   IS_PUTTING is 1 for putting into a field;  0 for getting from the field.\n+   FIELD_REF_INDEX is an index into the constant pool.  */\n+\n+void\n+expand_java_field_op (is_static, is_putting, field_ref_index)\n+     int is_static;\n+     int is_putting;\n+     int field_ref_index;\n+{\n+  tree self_type = get_class_constant\n+    (current_jcf, COMPONENT_REF_CLASS_INDEX (&current_jcf->cpool, field_ref_index));\n+  char *self_name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (self_type)));\n+  tree field_name = COMPONENT_REF_NAME (&current_jcf->cpool, field_ref_index);\n+  tree field_signature = COMPONENT_REF_SIGNATURE (&current_jcf->cpool, field_ref_index);\n+  tree field_type = get_type_from_signature (field_signature);\n+  tree new_value = is_putting ? pop_value (field_type) : NULL_TREE;\n+  tree field_ref;\n+  int is_error = 0;\n+  tree field_decl = lookup_field (&self_type, field_name);\n+  if (field_decl == error_mark_node)\n+    {\n+      is_error = 1;\n+    }\n+  else if (field_decl == NULL_TREE)\n+    {\n+      error (\"Missing field '%s' in '%s'\",\n+\t     IDENTIFIER_POINTER (field_name), self_name);\n+      is_error = 1;\n+    }\n+  else if (build_java_signature (TREE_TYPE (field_decl)) != field_signature)\n+    {\n+      error (\"Mismatching signature for field '%s' in '%s'\",\n+\t     IDENTIFIER_POINTER (field_name), self_name);\n+      is_error = 1;\n+    }\n+  field_ref = is_static ? NULL_TREE : pop_value (self_type);\n+  if (is_error)\n+    {\n+      if (! is_putting)\n+\tpush_value (convert (promote_type (field_type), integer_zero_node));\n+      flush_quick_stack ();\n+      return;\n+    }\n+\n+  /* Inline references to java.lang.PRIMTYPE.TYPE.\n+     In addition to being a useful (minor) optimization,\n+     this is also needed to avoid circularities in the implementation\n+     of these fields in libjava. */\n+  if (field_name == TYPE_identifier_node && ! is_putting\n+      && field_type == class_type_node\n+      && strncmp (self_name, \"java.lang.\", 10) == 0)\n+    {\n+      char *class_name = self_name+10;\n+      tree typ;\n+      if (strcmp(class_name, \"Byte\") == 0)\n+\ttyp = byte_type_node;\n+      else if (strcmp(class_name, \"Short\") == 0)\n+\ttyp = short_type_node;\n+      else if (strcmp(class_name, \"Integer\") == 0)\n+\ttyp = int_type_node;\n+      else if (strcmp(class_name, \"Long\") == 0)\n+\ttyp = long_type_node;\n+      else if (strcmp(class_name, \"Float\") == 0)\n+\ttyp = float_type_node;\n+      else if (strcmp(class_name, \"Boolean\") == 0)\n+\ttyp = boolean_type_node;\n+      else if (strcmp(class_name, \"Char\") == 0)\n+\ttyp = char_type_node;\n+      else if (strcmp(class_name, \"Void\") == 0)\n+\ttyp = void_type_node;\n+      else\n+\ttyp = NULL_TREE;\n+      if (typ != NULL_TREE)\n+\t{\n+\t  push_value (build_class_ref (typ));\n+\t  return;\n+\t}\n+    }\n+\n+  field_ref = build_field_ref (field_ref, self_type, field_name);\n+  if (is_static)\n+    field_ref = build_class_init (self_type, field_ref);\n+  if (is_putting)\n+    {\n+      flush_quick_stack ();\n+      if (FIELD_FINAL (field_decl))\n+\t{\n+\t  if (DECL_CONTEXT (field_decl) != current_class)\n+\t    error_with_decl (field_decl,\n+\t\t     \"assignment to final field `%s' not in field's class\");\n+\t  else if (FIELD_STATIC (field_decl))\n+\t    {\n+\t      if (DECL_NAME (current_function_decl) != clinit_identifier_node)\n+\t\terror_with_decl (field_decl, \n+             \"assignment to final static field `%s' not in class initializer\");\n+\t    }\n+\t  else\n+\t    {\n+\t      if (! DECL_CONSTRUCTOR_P (current_function_decl))\n+\t\terror_with_decl (field_decl, \n+                           \"assignment to final field `%s' not in constructor\");\n+\t    }\n+\t}\n+      expand_assignment (field_ref, new_value, 0, 0);\n+    }\n+  else\n+    push_value (field_ref);\n+}\n+\n+void\n+load_type_state (label)\n+     tree label;\n+{\n+  int i;\n+  tree vec = LABEL_TYPE_STATE (label);\n+  int cur_length = TREE_VEC_LENGTH (vec);\n+  stack_pointer = cur_length - DECL_MAX_LOCALS(current_function_decl);\n+  for (i = 0; i < cur_length; i++)\n+    type_map [i] = TREE_VEC_ELT (vec, i);\n+}\n+\n+struct rtx_def *\n+java_lang_expand_expr (exp, target, tmode, modifier)\n+     register tree exp;\n+     rtx target;\n+     enum machine_mode tmode;\n+     enum expand_modifier modifier;\n+{\n+  register rtx op0;\n+  tree type = TREE_TYPE (exp);\n+  register enum machine_mode mode = TYPE_MODE (type);\n+  int unsignedp = TREE_UNSIGNED (type);\n+\n+  switch (TREE_CODE (exp))\n+    {\n+    case BLOCK:\n+      if (BLOCK_EXPR_BODY (exp))\n+\t{\n+\t  tree local;\n+\t  struct rtx_def *to_return;\n+\t  pushlevel (2);\t/* 2 and above */\n+\t  expand_start_bindings (0);\n+\t  local = BLOCK_EXPR_DECLS (exp);\n+\t  while (local)\n+\t    {\n+\t      tree next = TREE_CHAIN (local);\n+\t      layout_decl (local, 0);\n+\t      expand_decl (pushdecl (local));\n+\t      local = next;\n+\t    }\n+\t  to_return =\n+\t    expand_expr (BLOCK_EXPR_BODY (exp), target, tmode, modifier);\n+\t  poplevel (1, 1, 0);\n+\t  expand_end_bindings (getdecls (), 1, 0);\n+\t  return to_return;\n+\t}\n+      break;\n+\n+    default:\n+      fatal (\"Can't expand '%s' tree - java_lang_expand_expr\",\n+\t     tree_code_name [TREE_CODE (exp)]);\n+    }\n+}\n+\n+void\n+expand_byte_code (jcf, method)\n+     JCF *jcf;\n+     tree method;\n+{\n+  int PC;\n+  int i;\n+  int saw_index;\n+  unsigned char *linenumber_pointer;\n+  struct eh_range *prev_eh_ranges = NULL_EH_RANGE;\n+  struct eh_range *eh_ranges;\n+\n+#undef RET /* Defined by config/i386/i386.h */\n+#undef AND /* Causes problems with opcodes for iand and land. */\n+#undef PTR\n+#define BCODE byte_ops\n+#define BYTE_type_node byte_type_node\n+#define SHORT_type_node short_type_node\n+#define INT_type_node int_type_node\n+#define LONG_type_node long_type_node\n+#define CHAR_type_node char_type_node\n+#define PTR_type_node ptr_type_node\n+#define FLOAT_type_node float_type_node\n+#define DOUBLE_type_node double_type_node\n+#define VOID_type_node void_type_node\n+  jint INT_temp;\n+  unsigned char* byte_ops;\n+  long length = DECL_CODE_LENGTH (method);\n+\n+  stack_pointer = 0;\n+  JCF_SEEK (jcf, DECL_CODE_OFFSET (method));\n+  byte_ops = jcf->read_ptr;\n+\n+#define CONST_INDEX_1 (saw_index = 1, IMMEDIATE_u1)\n+#define CONST_INDEX_2 (saw_index = 1, IMMEDIATE_u2)\n+#define VAR_INDEX_1 (saw_index = 1, IMMEDIATE_u1)\n+#define VAR_INDEX_2 (saw_index = 1, IMMEDIATE_u2)\n+\n+#define CHECK_PC_IN_RANGE(PC) 1 /* Already handled by verifier. */\n+\n+  instruction_bits = oballoc (length + 1);\n+  bzero (instruction_bits, length + 1);\n+\n+  /* We make an initial pass of the line number table, to note\n+     which instructions have associated line number entries. */\n+  linenumber_pointer = linenumber_table;\n+  for (i = 0; i < linenumber_count; i++)\n+    {\n+      int pc = GET_u2 (linenumber_pointer);\n+      linenumber_pointer += 4;\n+      if (pc >= length)\n+\twarning (\"invalid PC in line number table\");\n+      else\n+\t{\n+\t  if ((instruction_bits[pc] & BCODE_HAS_LINENUMBER) != 0)\n+\t    instruction_bits[pc] |= BCODE_HAS_MULTI_LINENUMBERS;\n+\t  instruction_bits[pc] |= BCODE_HAS_LINENUMBER;\n+\t}\n+    }  \n+\n+  /* Do a preliminary pass.\n+   * This figures out which PC can be the targets of jumps. */\n+  for (PC = 0; PC < length;)\n+    {\n+      int oldpc = PC; /* PC at instruction start. */\n+      instruction_bits [PC] |=  BCODE_INSTRUCTION_START;\n+      switch (byte_ops[PC++])\n+\t{\n+#define JAVAOP(OPNAME, OPCODE, OPKIND, OPERAND_TYPE, OPERAND_VALUE) \\\n+        case OPCODE: \\\n+\t  PRE_##OPKIND(OPERAND_TYPE, OPERAND_VALUE); \\\n+\t  break;\n+\n+#define NOTE_LABEL(PC) note_label(oldpc, PC)\n+\n+#define PRE_PUSHC(OPERAND_TYPE, OPERAND_VALUE) (void)(OPERAND_VALUE);\n+#define PRE_LOAD(OPERAND_TYPE, OPERAND_VALUE) (void)(OPERAND_VALUE);\n+#define PRE_STORE(OPERAND_TYPE, OPERAND_VALUE) (void)(OPERAND_VALUE);\n+#define PRE_STACK(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n+#define PRE_UNOP(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n+#define PRE_BINOP(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n+#define PRE_CONVERT(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n+#define PRE_CONVERT2(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n+\n+#define PRE_SPECIAL(OPERAND_TYPE, INSTRUCTION) \\\n+  PRE_SPECIAL_##INSTRUCTION(OPERAND_TYPE)\n+#define PRE_SPECIAL_IINC(OPERAND_TYPE) \\\n+  ((void) IMMEDIATE_u1, (void) IMMEDIATE_s1)\n+#define PRE_SPECIAL_ENTER(IGNORE) /* nothing */\n+#define PRE_SPECIAL_EXIT(IGNORE) /* nothing */\n+#define PRE_SPECIAL_THROW(IGNORE) /* nothing */\n+#define PRE_SPECIAL_BREAK(IGNORE) /* nothing */\n+\n+/* two forms of wide instructions */\n+#define PRE_SPECIAL_WIDE(IGNORE) \\\n+  { \\\n+    int modified_opcode = IMMEDIATE_u1; \\\n+    if (modified_opcode == OPCODE_iinc)\t\\\n+      { \\\n+\t(void) IMMEDIATE_u2;\t/* indexbyte1 and indexbyte2 */ \\\n+\t(void) IMMEDIATE_s2;\t/* constbyte1 and constbyte2 */ \\\n+      } \\\n+    else \\\n+      { \\\n+\t(void) IMMEDIATE_u2;\t/* indexbyte1 and indexbyte2 */ \\\n+      } \\\n+  }\n+\n+/* nothing */ /* XXX JH */\n+\n+#define PRE_IMPL(IGNORE1, IGNORE2) /* nothing */\n+\n+#define PRE_MONITOR(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n+\n+#define PRE_RETURN(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n+#define PRE_ARRAY(OPERAND_TYPE, SUBOP) \\\n+\t  PRE_ARRAY_##SUBOP(OPERAND_TYPE)\n+#define PRE_ARRAY_LOAD(TYPE) /* nothing */\n+#define PRE_ARRAY_STORE(TYPE) /* nothing */\n+#define PRE_ARRAY_LENGTH(TYPE) /* nothing */\n+#define PRE_ARRAY_NEW(TYPE) PRE_ARRAY_NEW_##TYPE\n+#define PRE_ARRAY_NEW_NUM ((void) IMMEDIATE_u1)\n+#define PRE_ARRAY_NEW_PTR ((void) IMMEDIATE_u2)\n+#define PRE_ARRAY_NEW_MULTI ((void) IMMEDIATE_u2, (void) IMMEDIATE_u1)\n+\n+#define PRE_TEST(OPERAND_TYPE, OPERAND_VALUE) NOTE_LABEL (oldpc+IMMEDIATE_s2)\n+#define PRE_COND(OPERAND_TYPE, OPERAND_VALUE) NOTE_LABEL (oldpc+IMMEDIATE_s2)\n+#define PRE_BRANCH(OPERAND_TYPE, OPERAND_VALUE) \\\n+  saw_index = 0;  INT_temp = (OPERAND_VALUE); \\\n+  if (!saw_index)  NOTE_LABEL(oldpc + INT_temp);\n+#define PRE_JSR(OPERAND_TYPE, OPERAND_VALUE) \\\n+  saw_index = 0;  INT_temp = (OPERAND_VALUE); \\\n+  if (!saw_index)  NOTE_LABEL(oldpc + INT_temp);\n+\n+#define PRE_RET(OPERAND_TYPE, OPERAND_VALUE)  (void)(OPERAND_VALUE)\n+\n+#define PRE_SWITCH(OPERAND_TYPE, TABLE_OR_LOOKUP) \\\n+  PC = (PC + 3) / 4 * 4; PRE_##TABLE_OR_LOOKUP##_SWITCH\n+\n+#define PRE_LOOKUP_SWITCH\t\t\t\t\t\t\\\n+  { jint default_offset = IMMEDIATE_s4;  jint npairs = IMMEDIATE_s4;\t\\\n+    NOTE_LABEL (default_offset+oldpc);\t\t\t\t\t\\\n+    if (npairs >= 0)\t\t\t\t\t\t\t\\\n+      while (--npairs >= 0) {\t\t\t\t\t\t\\\n+       jint match = IMMEDIATE_s4; jint offset = IMMEDIATE_s4;\t\t\\\n+       NOTE_LABEL (offset+oldpc); }\t\t\t\t\t\\\n+  }\n+\n+#define PRE_TABLE_SWITCH\t\t\t\t\\\n+  { jint default_offset = IMMEDIATE_s4;\t\t\t\\\n+    jint low = IMMEDIATE_s4; jint high = IMMEDIATE_s4;\t\\\n+    NOTE_LABEL (default_offset+oldpc);\t\t\t\\\n+    if (low <= high)\t\t\t\t\t\\\n+     while (low++ <= high) {\t\t\t\t\\\n+       jint offset = IMMEDIATE_s4;\t\t\t\\\n+       NOTE_LABEL (offset+oldpc); }\t\t\t\\\n+  }\n+\n+#define PRE_FIELD(MAYBE_STATIC, PUT_OR_GET) (void)(IMMEDIATE_u2);\n+#define PRE_OBJECT(MAYBE_STATIC, PUT_OR_GET) (void)(IMMEDIATE_u2);\n+#define PRE_INVOKE(MAYBE_STATIC, IS_INTERFACE) \\\n+  (void)(IMMEDIATE_u2); \\\n+  PC += 2 * IS_INTERFACE /* for invokeinterface */;\n+\n+#include \"javaop.def\"\n+#undef JAVAOP\n+\t}\n+    } /* for */\n+\n+  if (! verify_jvm_instructions (jcf, byte_ops, length))\n+    return;\n+\n+  /* Translate bytecodes to rtl instructions. */\n+  linenumber_pointer = linenumber_table;\n+  for (PC = 0; PC < length;)\n+    {\n+      if ((instruction_bits [PC] & BCODE_TARGET) != 0 || PC == 0)\n+\t{\n+\t  tree label = lookup_label (PC);\n+          flush_quick_stack ();\n+\t  if ((instruction_bits [PC] & BCODE_TARGET) != 0)\n+\t    expand_label (label);\n+\t  if (LABEL_VERIFIED (label) || PC == 0)\n+\t    load_type_state (label);\n+\t}\n+\n+      if (! (instruction_bits [PC] & BCODE_VERIFIED))\n+\t{\n+\t  /* never executed - skip */\n+\t  warning (\"Some bytecode operations (starting at pc %d) can never be executed\", PC);\n+\t  while (PC < length\n+\t\t && ! (instruction_bits [PC] & BCODE_VERIFIED))\n+\t    PC++;\n+\t  continue;\n+\t}\n+\n+\n+      /* Handle possible line number entry for this PC.\n+\n+\t This code handles out-of-order and multiple linenumbers per PC,\n+\t but is optimized for the case of line numbers increasing\n+\t monotonically with PC. */\n+      if ((instruction_bits[PC] & BCODE_HAS_LINENUMBER) != 0)\n+\t{\n+\t  if ((instruction_bits[PC] & BCODE_HAS_MULTI_LINENUMBERS) != 0\n+\t      || GET_u2 (linenumber_pointer) != PC)\n+\t    linenumber_pointer = linenumber_table;\n+\t  while (linenumber_pointer < linenumber_table + linenumber_count * 4)\n+\t    {\n+\t      int pc = GET_u2 (linenumber_pointer);\n+\t      linenumber_pointer += 4;\n+\t      if (pc == PC)\n+\t\t{\n+\t\t  lineno = GET_u2 (linenumber_pointer - 2);\n+\t\t  emit_line_note (input_filename, lineno);\n+\t\t  if (!(instruction_bits[PC] & BCODE_HAS_MULTI_LINENUMBERS))\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t}\n+      maybe_start_try (PC);\n+      maybe_pushlevels (PC);\n+\n+      PC = process_jvm_instruction (PC, byte_ops, length);\n+\n+      maybe_poplevels (PC);\n+      maybe_end_try (PC);\n+    } /* for */\n+}\n+\n+void\n+java_push_constant_from_pool (jcf, index)\n+     JCF *jcf;\n+     int index;\n+{\n+  tree c;\n+  if (JPOOL_TAG (jcf, index) == CONSTANT_String)\n+    {\n+      tree name;\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+      name = get_name_constant (jcf, JPOOL_USHORT1 (jcf, index));\n+      index = alloc_name_constant (CONSTANT_String, name);\n+      c = build_ref_from_constant_pool (index);\n+      TREE_TYPE (c) = promote_type (string_type_node);\n+      pop_obstacks ();\n+    }\n+  else\n+    c = get_constant (jcf, index);\n+  push_value (c);\n+} \n+\n+int\n+process_jvm_instruction (PC, byte_ops, length)\n+     int PC;\n+     unsigned char* byte_ops;\n+     long length;\n+{ \n+  char *opname; /* Temporary ??? */\n+  int oldpc = PC; /* PC at instruction start. */\n+  switch (byte_ops[PC++])\n+    {\n+#define JAVAOP(OPNAME, OPCODE, OPKIND, OPERAND_TYPE, OPERAND_VALUE) \\\n+    case OPCODE: \\\n+      opname = #OPNAME; \\\n+      OPKIND(OPERAND_TYPE, OPERAND_VALUE); \\\n+      break;\n+\n+#define RET(OPERAND_TYPE, OPERAND_VALUE) \t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int saw_index = 0;\t\t\t\t\t\t\t\\\n+    int index     = OPERAND_VALUE;\t\t\t\t\t\\\n+    build_java_ret (find_local_variable (index, ptr_type_node, oldpc));\t\\\n+  }\n+\n+#define JSR(OPERAND_TYPE, OPERAND_VALUE)\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    tree where = lookup_label (oldpc+OPERAND_VALUE);\t\\\n+    tree ret   = lookup_label (PC);\t\t\t\\\n+    build_java_jsr (where, ret);\t\t\t\\\n+  }\n+\n+/* Push a constant onto the stack. */\n+#define PUSHC(OPERAND_TYPE, OPERAND_VALUE) \\\n+  { int saw_index = 0;  int ival = (OPERAND_VALUE); \\\n+    if (saw_index) java_push_constant_from_pool (current_jcf, ival); \\\n+    else expand_java_pushc (ival, OPERAND_TYPE##_type_node); }\n+\n+/* internal macro added for use by the WIDE case */\n+#define LOAD_INTERNAL(OPTYPE, OPVALUE) \\\n+  push_value (find_local_variable (OPVALUE, type_map[OPVALUE], oldpc));\n+\n+/* Push local variable onto the opcode stack. */\n+#define LOAD(OPERAND_TYPE, OPERAND_VALUE) \\\n+  { \\\n+    /* have to do this since OPERAND_VALUE may have side-effects */ \\\n+    int opvalue = OPERAND_VALUE; \\\n+    LOAD_INTERNAL(OPERAND_TYPE##_type_node, opvalue); \\\n+  }\n+\n+#define RETURN(OPERAND_TYPE, OPERAND_VALUE) \\\n+  expand_java_return (OPERAND_TYPE##_type_node)\n+\n+#define REM_EXPR TRUNC_MOD_EXPR\n+#define BINOP(OPERAND_TYPE, OPERAND_VALUE) \\\n+  expand_java_binop (OPERAND_TYPE##_type_node, OPERAND_VALUE##_EXPR)\n+\n+#define FIELD(IS_STATIC, IS_PUT) \\\n+  expand_java_field_op (IS_STATIC, IS_PUT, IMMEDIATE_u2)\n+\n+#define TEST(OPERAND_TYPE, CONDITION) \\\n+  expand_test (CONDITION##_EXPR, OPERAND_TYPE##_type_node, oldpc+IMMEDIATE_s2)\n+\n+#define COND(OPERAND_TYPE, CONDITION) \\\n+  expand_cond (CONDITION##_EXPR, OPERAND_TYPE##_type_node, oldpc+IMMEDIATE_s2)\n+\n+#define BRANCH(OPERAND_TYPE, OPERAND_VALUE) \\\n+  BRANCH_##OPERAND_TYPE (OPERAND_VALUE)\n+\n+#define BRANCH_GOTO(OPERAND_VALUE) \\\n+  expand_java_goto (oldpc + OPERAND_VALUE)\n+\n+#define BRANCH_CALL(OPERAND_VALUE) \\\n+  expand_java_call (oldpc + OPERAND_VALUE, oldpc)\n+\n+#if 0\n+#define BRANCH_RETURN(OPERAND_VALUE) \\\n+  { \\\n+    tree type = OPERAND_TYPE##_type_node; \\\n+    tree value = find_local_variable (OPERAND_VALUE, type, oldpc); \\\n+    expand_java_ret (value); \\\n+  }\n+#endif\n+\n+#define NOT_IMPL(OPERAND_TYPE, OPERAND_VALUE) \\\n+\t  fprintf (stderr, \"%3d: %s \", oldpc, opname); \\\n+\t  fprintf (stderr, \"(not implemented)\\n\")\n+#define NOT_IMPL1(OPERAND_VALUE) \\\n+\t  fprintf (stderr, \"%3d: %s \", oldpc, opname); \\\n+\t  fprintf (stderr, \"(not implemented)\\n\")\n+\n+#define BRANCH_RETURN(OPERAND_VALUE) NOT_IMPL1(OPERAND_VALUE)\n+\n+#define STACK(SUBOP, COUNT) STACK_##SUBOP (COUNT)\n+\n+#define STACK_POP(COUNT) java_stack_pop (COUNT)\n+\n+#define STACK_SWAP(COUNT) java_stack_swap()\n+\n+#define STACK_DUP(COUNT) java_stack_dup (COUNT, 0)\n+#define STACK_DUPx1(COUNT) java_stack_dup (COUNT, 1)\n+#define STACK_DUPx2(COUNT) java_stack_dup (COUNT, 2)\n+\n+#define SWITCH(OPERAND_TYPE, TABLE_OR_LOOKUP) \\\n+  PC = (PC + 3) / 4 * 4; TABLE_OR_LOOKUP##_SWITCH\n+\n+#define LOOKUP_SWITCH \\\n+  { jint default_offset = IMMEDIATE_s4;  jint npairs = IMMEDIATE_s4; \\\n+    tree selector = pop_value (INT_type_node); \\\n+    tree duplicate, label; \\\n+    tree type = TREE_TYPE (selector); \\\n+    flush_quick_stack (); \\\n+    expand_start_case (0, selector, type, \"switch statement\");\\\n+    push_momentary (); \\\n+    while (--npairs >= 0) \\\n+      { \\\n+\tjint match = IMMEDIATE_s4; jint offset = IMMEDIATE_s4; \\\n+\ttree value = build_int_2 (match, match < 0 ? -1 : 0); \\\n+\tTREE_TYPE (value) = type; \\\n+\tlabel =  build_decl (LABEL_DECL, NULL_TREE, NULL_TREE); \\\n+\tpushcase (value, convert, label, &duplicate); \\\n+\texpand_java_goto (oldpc + offset); \\\n+      } \\\n+    label =  build_decl (LABEL_DECL, NULL_TREE, NULL_TREE); \\\n+    pushcase (NULL_TREE, 0, label, &duplicate); \\\n+    expand_java_goto (oldpc + default_offset); \\\n+    pop_momentary (); \\\n+    expand_end_case (selector); \\\n+  }\n+\n+#define TABLE_SWITCH \\\n+  { jint default_offset = IMMEDIATE_s4; \\\n+    jint low = IMMEDIATE_s4; jint high = IMMEDIATE_s4; \\\n+    tree selector = pop_value (INT_type_node); \\\n+    tree duplicate, label; \\\n+    tree type = TREE_TYPE (selector); \\\n+    flush_quick_stack (); \\\n+    expand_start_case (0, selector, type, \"switch statement\");\\\n+    push_momentary (); \\\n+    for (; low <= high; low++) \\\n+      { \\\n+        jint offset = IMMEDIATE_s4; \\\n+        tree value = build_int_2 (low, low < 0 ? -1 : 0); \\\n+        TREE_TYPE (value) = type; \\\n+        label =  build_decl (LABEL_DECL, NULL_TREE, NULL_TREE); \\\n+        pushcase (value, convert, label, &duplicate); \\\n+        expand_java_goto (oldpc + offset); \\\n+      } \\\n+    label =  build_decl (LABEL_DECL, NULL_TREE, NULL_TREE); \\\n+    pushcase (NULL_TREE, 0, label, &duplicate); \\\n+    expand_java_goto (oldpc + default_offset); \\\n+    pop_momentary (); \\\n+    expand_end_case (selector); \\\n+  }\n+\n+#define INVOKE(MAYBE_STATIC, IS_INTERFACE) \\\n+  { int opcode = byte_ops[PC-1]; \\\n+    int method_ref_index = IMMEDIATE_u2; \\\n+    int nargs; \\\n+    if (IS_INTERFACE) { nargs = IMMEDIATE_u1;  (void) IMMEDIATE_u1; } \\\n+    else nargs = -1; \\\n+    expand_invoke (opcode, method_ref_index, nargs); \\\n+  }\n+\n+/* Handle new, checkcast, instanceof */\n+#define OBJECT(TYPE, OP) \\\n+  expand_java_##OP (get_class_constant (current_jcf, IMMEDIATE_u2))\n+\n+#define ARRAY(OPERAND_TYPE, SUBOP) ARRAY_##SUBOP(OPERAND_TYPE)\n+\n+#define ARRAY_LOAD(OPERAND_TYPE) \t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    expand_java_arrayload( OPERAND_TYPE##_type_node );\t\\\n+  }\n+\n+#define ARRAY_STORE(OPERAND_TYPE)\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    expand_java_arraystore( OPERAND_TYPE##_type_node );\t\\\n+  }\n+\n+#define ARRAY_LENGTH(OPERAND_TYPE) expand_java_array_length();\n+#define ARRAY_NEW(OPERAND_TYPE) ARRAY_NEW_##OPERAND_TYPE()\n+#define ARRAY_NEW_PTR()\t\t\t\t\t\t\t\\\n+    push_value (build_anewarray (get_class_constant (current_jcf,\t\\\n+\t\t\t\t\t\t     IMMEDIATE_u2),\t\\\n+\t\t\t\t pop_value (int_type_node)));\n+#define ARRAY_NEW_NUM()\t\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    int atype = IMMEDIATE_u1;\t\t\t\\\n+    push_value (build_newarray (atype, pop_value (int_type_node)));\\\n+  }\n+#define ARRAY_NEW_MULTI()\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    tree class = get_class_constant (current_jcf, IMMEDIATE_u2 );\t\\\n+    int  ndims = IMMEDIATE_u1;\t\t\t\t\t\\\n+    expand_java_multianewarray( class, ndims );\t\t\t\\\n+  }\n+\n+#define UNOP(OPERAND_TYPE, OPERAND_VALUE) \\\n+  push_value (fold (build1 (NEGATE_EXPR, OPERAND_TYPE##_type_node, \\\n+\t\t\t    pop_value (OPERAND_TYPE##_type_node))));\n+\n+#define CONVERT2(FROM_TYPE, TO_TYPE)\t\t\t\t\t \\\n+  {\t\t\t\t\t\t\t\t\t \\\n+    push_value (build1 (NOP_EXPR, int_type_node,\t\t\t \\\n+\t\t\t(convert (TO_TYPE##_type_node,\t\t\t \\\n+\t\t\t\t  pop_value (FROM_TYPE##_type_node))))); \\\n+  }\n+\n+#define CONVERT(FROM_TYPE, TO_TYPE)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    push_value (convert (TO_TYPE##_type_node,\t                \\\n+\t\t\t pop_value (FROM_TYPE##_type_node)));\t\\\n+  }\n+\n+/* internal macro added for use by the WIDE case \n+   Added TREE_TYPE (decl) assignment, apbianco  */\n+#define STORE_INTERNAL(OPTYPE, OPVALUE)\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    tree decl, value;\t\t\t\t\t\\\n+    int var = OPVALUE;\t\t\t\t\t\\\n+    tree type = OPTYPE;\t\t\t\t\t\\\n+    value = pop_value (type);\t\t\t\t\\\n+    type = TREE_TYPE (value);\t\t\t\t\\\n+    decl = find_local_variable (var, type, oldpc);\t\\\n+    set_local_type (var, type );\t\t\t\\\n+    expand_assignment (decl, value, 0, 0);\t\t\\\n+  }\n+\n+#define STORE(OPERAND_TYPE, OPERAND_VALUE) \\\n+  { \\\n+    /* have to do this since OPERAND_VALUE may have side-effects */ \\\n+    int opvalue = OPERAND_VALUE; \\\n+    STORE_INTERNAL(OPERAND_TYPE##_type_node, opvalue); \\\n+  }\n+\n+#define SPECIAL(OPERAND_TYPE, INSTRUCTION) \\\n+  SPECIAL_##INSTRUCTION(OPERAND_TYPE)\n+\n+#define SPECIAL_ENTER(IGNORED) MONITOR_OPERATION (soft_monitorenter_node)\n+#define SPECIAL_EXIT(IGNORED)  MONITOR_OPERATION (soft_monitorexit_node)\n+\n+#define MONITOR_OPERATION(call)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    tree o = pop_value (ptr_type_node);\t\t\\\n+    tree c;\t\t\t\t\t\\\n+    flush_quick_stack ();\t\t\t\\\n+    c = build_java_monitor (call, o);\t\t\\\n+    TREE_SIDE_EFFECTS (c) = 1;\t\t\t\\\n+    expand_expr_stmt (c);\t\t\t\\\n+  }\n+\n+#define SPECIAL_IINC(IGNORED) \\\n+  { \\\n+    unsigned int local_var_index = IMMEDIATE_u1; \\\n+    int ival = IMMEDIATE_s1; \\\n+    expand_iinc(local_var_index, ival, oldpc); \\\n+  }\n+\n+#define SPECIAL_WIDE(IGNORED) \\\n+  { \\\n+    int modified_opcode = IMMEDIATE_u1; \\\n+    unsigned int local_var_index = IMMEDIATE_u2; \\\n+    switch (modified_opcode) \\\n+      { \\\n+      case OPCODE_iinc: \\\n+\t{ \\\n+\t  int ival = IMMEDIATE_s2; \\\n+\t  expand_iinc (local_var_index, ival, oldpc); \\\n+\t  break; \\\n+\t} \\\n+      case OPCODE_iload: \\\n+      case OPCODE_lload: \\\n+      case OPCODE_fload: \\\n+      case OPCODE_dload: \\\n+      case OPCODE_aload: \\\n+\t{ \\\n+\t  /* duplicate code from LOAD macro */ \\\n+\t  LOAD_INTERNAL(operand_type[modified_opcode], local_var_index); \\\n+\t  break; \\\n+\t} \\\n+      case OPCODE_istore: \\\n+      case OPCODE_lstore: \\\n+      case OPCODE_fstore: \\\n+      case OPCODE_dstore: \\\n+      case OPCODE_astore: \\\n+\t{ \\\n+\t  STORE_INTERNAL(operand_type[modified_opcode], local_var_index); \\\n+\t  break; \\\n+\t} \\\n+      default: \\\n+        error (\"unrecogized wide sub-instruction\"); \\\n+      } \\\n+  }\n+\n+#define SPECIAL_THROW(IGNORED) \\\n+  build_java_athrow (pop_value (throwable_type_node))\n+\n+#define SPECIAL_BREAK NOT_IMPL1\n+#define IMPL          NOT_IMPL\n+\n+#include \"javaop.def\"\n+#undef JAVAOP\n+   default:\n+    fprintf (stderr, \"%3d: unknown(%3d)\\n\", oldpc, byte_ops[PC]);\n+  }\n+  return PC;\n+}"}, {"sha": "875e9907dba6df45a6744b784c34430a88095a8a", "filename": "gcc/java/gjavah.c", "status": "added", "additions": 959, "deletions": 0, "changes": 959, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,959 @@\n+/* Program to write C++-suitable header files from a Java(TM) .class\n+   file.  This is similar to SUN's javah.\n+\n+Copyright (C) 1996, 1998 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Written by Per Bothner <bothner@cygnus.com>, February 1996. */\n+\n+#include <stdio.h>\n+#include \"jcf.h\"\n+#ifdef __STDC__\n+#include <stdlib.h>\n+#endif\n+#include <math.h>\n+\n+/* The output file.  */\n+FILE *out = NULL;\n+\n+/* Nonzero on failure.  */\n+static int found_error = 0;\n+\n+/* Directory to place resulting files in. Set by -d option. */\n+char *output_directory = \"\";\n+\n+char *output_file = NULL;\n+\n+/* Directory to place temporary file.  Set by -td option.  Currently unused. */\n+char *temp_directory = \"/tmp\";\n+\n+/* Number of friend functions we have to declare.  */\n+static int friend_count;\n+\n+/* A class can optionally have a `friend' function declared.  If\n+   non-NULL, this is that function.  */\n+static char **friend_specs = NULL;\n+\n+/* Number of lines we are prepending before the class.  */\n+static int prepend_count;\n+\n+/* We can prepend extra lines before the class's start. */\n+static char **prepend_specs = NULL;\n+\n+/* Number of lines we are appending at the end of the class.  */\n+static int add_count;\n+\n+/* We can append extra lines just before the class's end. */\n+static char **add_specs = NULL;\n+\n+/* Number of lines we are appending after the class.  */\n+static int append_count;\n+\n+/* We can append extra lines after the class's end. */\n+static char **append_specs = NULL;\n+\n+int verbose = 0;\n+\n+int stubs = 0;\n+\n+struct JCF *current_jcf;\n+struct JCF *main_jcf;\n+\n+/* This holds access information for the last field we examined.  They\n+   let us generate \"private:\", \"public:\", and \"protected:\" properly.\n+   If 0 then we haven't previously examined any field.  */\n+static JCF_u2 last_access;\n+\n+#define ACC_VISIBILITY (ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED)\n+\n+int seen_fields = 0;\n+\n+static void print_field_info PROTO ((FILE *, JCF*, int, int, JCF_u2));\n+static void print_method_info PROTO ((FILE *, JCF*, int, int, JCF_u2));\n+static void print_c_decl PROTO ((FILE*, JCF*, int, int, JCF_u2, int));\n+\n+JCF_u2 current_field_name;\n+JCF_u2 current_field_value;\n+JCF_u2 current_field_signature;\n+JCF_u2 current_field_flags;\n+\n+#define HANDLE_START_FIELD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT) \\\n+( current_field_name = (NAME), current_field_signature = (SIGNATURE), \\\n+  current_field_flags = (ACCESS_FLAGS), current_field_value = 0)\n+\n+#define HANDLE_END_FIELD() \\\n+  print_field_info (out, jcf, current_field_name, current_field_signature, \\\n+\t\t    current_field_flags);\n+\n+#define HANDLE_CONSTANTVALUE(VALUEINDEX) current_field_value = (VALUEINDEX)\n+\n+#define HANDLE_METHOD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT) \\\n+  print_method_info (out, jcf, NAME, SIGNATURE, ACCESS_FLAGS)\n+\n+#include \"jcf-reader.c\"\n+\n+/* Some useful constants.  */\n+#define F_NAN_MASK 0x7f800000\n+#define D_NAN_MASK 0x7ff0000000000000LL\n+\n+/* Return 1 if F is not Inf or NaN.  */\n+static int\n+java_float_finite (f)\n+     jfloat f;\n+{\n+  int32 *ip = (int32 *) &f;\n+\n+  /* We happen to know that F_NAN_MASK will match all NaN values, and\n+     also positive and negative infinity.  That's why we only need one\n+     test here.  See The Java Language Specification, section 20.9.  */\n+  return (*ip & F_NAN_MASK) != F_NAN_MASK;\n+}\n+\n+/* Return 1 if D is not Inf or NaN.  */\n+static int\n+java_double_finite (d)\n+     jdouble d;\n+{\n+  int64 *ip = (int64 *) &d;\n+\n+  /* Now check for all NaNs.  */\n+  return (*ip & D_NAN_MASK) != D_NAN_MASK;\n+}\n+\n+void\n+DEFUN(print_name, (stream, jcf, name_index),\n+      FILE* stream AND JCF* jcf AND int name_index)\n+{\n+  if (JPOOL_TAG (jcf, name_index) != CONSTANT_Utf8)\n+    fprintf (stream, \"<not a UTF8 constant>\");\n+  else\n+    jcf_print_utf8 (stream, JPOOL_UTF_DATA (jcf, name_index),\n+\t\t    JPOOL_UTF_LENGTH (jcf, name_index));\n+}\n+\n+/* Print base name of class.  The base name is everything after the\n+   final separator.  */\n+\n+static void\n+print_base_classname (stream, jcf, index)\n+     FILE *stream;\n+     JCF *jcf;\n+     int index;\n+{\n+  int name_index = JPOOL_USHORT1 (jcf, index);\n+  int i, len;\n+  unsigned char *s, *p, *limit;\n+\n+  s = JPOOL_UTF_DATA (jcf, name_index);\n+  len = JPOOL_UTF_LENGTH (jcf, name_index);\n+  limit = s + len;\n+  p = s;\n+  while (s < limit)\n+    {\n+      int c = UTF8_GET (s, limit);\n+      if (c == '/')\n+\tp = s;\n+    }\n+\n+  while (p < limit)\n+    {\n+      int ch = UTF8_GET (p, limit);\n+      if (ch == '/')\n+\tfputs (\"::\", stream);\n+      else\n+\tjcf_print_char (stream, ch);\n+    }\n+}\n+\n+/* Return 0 if NAME is equal to STR, nonzero otherwise.  */\n+\n+static int\n+utf8_cmp (str, length, name)\n+     unsigned char *str;\n+     int length;\n+     char *name;\n+{\n+  unsigned char *limit = str + length;\n+  int i;\n+\n+  for (i = 0; name[i]; ++i)\n+    {\n+      int ch = UTF8_GET (str, limit);\n+      if (ch != name[i])\n+\treturn 1;\n+    }\n+\n+  return str != limit;\n+}\n+\n+/* Generate an access control keyword based on FLAGS.  Returns 0 if\n+   FLAGS matches the saved access information, nonzero otherwise.  */\n+\n+static void\n+generate_access (stream, flags)\n+     FILE *stream;\n+     JCF_u2 flags;\n+{\n+  /* FIXME: Java's \"protected\" and \"no access specifier\" modes don't\n+     actually map to C++ \"protected\".  That's how we map them for now,\n+     though.  */\n+\n+  if (! (flags & ACC_VISIBILITY))\n+    flags = ACC_PROTECTED;\n+\n+  if ((flags & ACC_VISIBILITY) == last_access)\n+    return;\n+  last_access = (flags & ACC_VISIBILITY);\n+\n+  switch (last_access)\n+    {\n+    case ACC_PUBLIC:\n+      fputs (\"public:\\n\", stream);\n+      break;\n+    case ACC_PRIVATE:\n+      fputs (\"private:\\n\", stream);\n+      break;\n+    case ACC_PROTECTED:\n+      fputs (\"protected:\\n\", stream);\n+      break;\n+    default:\n+      found_error = 1;\n+      fprintf (stream, \"#error unrecognized visibility %d\\n\",\n+\t       (flags & ACC_VISIBILITY));\n+      break;\n+    }\n+}\n+\n+static void\n+DEFUN(print_field_info, (stream, jcf, name_index, sig_index, flags),\n+      FILE *stream AND JCF* jcf\n+      AND int name_index AND int sig_index AND JCF_u2 flags)\n+{\n+  if (flags & ACC_FINAL)\n+    {\n+      if (current_field_value > 0)\n+\t{\n+\t  jlong num;\n+\t  char buffer[25];\n+\n+\t  generate_access (stream, flags);\n+\t  switch (JPOOL_TAG (jcf, current_field_value))\n+\t    {\n+\t    case CONSTANT_Integer:\n+\t      fputs (\"  static const jint \", out);\n+\t      print_name (out, jcf, name_index);\n+\t      fputs (\" = \", out);\n+\t      num = JPOOL_INT (jcf, current_field_value);\n+\t      format_int (buffer, num, 10);\n+\t      fprintf (out, \"%sL;\\n\", buffer);\n+\t      break;\n+\t    case CONSTANT_Long:\n+\t      fputs (\"  static const jlong \", out);\n+\t      print_name (out, jcf, name_index);\n+\t      fputs (\" = \", out);\n+\t      num = JPOOL_LONG (jcf, current_field_value);\n+\t      format_int (buffer, num, 10);\n+\t      fprintf (out, \"%sLL;\\n\", buffer);\n+\t      break;\n+\t    case CONSTANT_Float:\n+\t      {\n+\t\tjfloat fnum = JPOOL_FLOAT (jcf, current_field_value);\n+\t\tfputs (\"  static const jfloat \", out);\n+\t\tprint_name (out, jcf, name_index);\n+\t\tif (! java_float_finite (fnum))\n+\t\t  fputs (\";\\n\", out);\n+\t\telse\n+\t\t  fprintf (out, \" = %.10g;\\n\",  fnum);\n+\t      }\n+\t      break;\n+\t    case CONSTANT_Double:\n+\t      {\n+\t\tjdouble dnum = JPOOL_DOUBLE (jcf, current_field_value);\n+\t\tfputs (\"  static const jdouble \", out);\n+\t\tprint_name (out, jcf, name_index);\n+\t\tif (! java_double_finite (dnum))\n+\t\t  fputs (\";\\n\", out);\n+\t\telse\n+\t\t  fprintf (out, \" = %.17g;\\n\",  dnum);\n+\t      }\n+\t      break;\n+\t    default:\n+\t      fprintf(out, \" <<inappropriate constant type>>\\n\");\n+\t    }\n+\n+\t  return;\n+\t}\n+    }\n+\n+  generate_access (stream, flags);\n+  fputs (\"  \", out);\n+  if (flags & ACC_STATIC)\n+    fputs (\"static \", out);\n+  print_c_decl (out, jcf, name_index, sig_index, flags, 0);\n+  fputs (\";\\n\", out);\n+  if (! (flags & ACC_STATIC))\n+    seen_fields++;\n+}\n+\n+static void\n+DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n+      FILE *stream AND JCF* jcf\n+      AND int name_index AND int sig_index AND JCF_u2 flags)\n+{\n+  unsigned char *str;\n+  int length, is_init = 0;\n+\n+  if (JPOOL_TAG (jcf, name_index) != CONSTANT_Utf8)\n+    fprintf (stream, \"<not a UTF8 constant>\");\n+  str = JPOOL_UTF_DATA (jcf, name_index);\n+  length = JPOOL_UTF_LENGTH (jcf, name_index);\n+  if (str[0] == '<')\n+    {\n+      /* Ignore internally generated methods like <clinit>.  However,\n+\t treat <init> as a constructor.  */\n+      if (! utf8_cmp (str, length, \"<init>\"))\n+\tis_init = 1;\n+      else  \n+\treturn;\n+    }\n+\n+  /* We can't generate a method whose name is a C++ reserved word.\n+     For now the only problem has been `delete'; add more here as\n+     required.  FIXME: we need a better solution than just ignoring\n+     the method.  */\n+  if (! utf8_cmp (str, length, \"delete\"))\n+    return;\n+\n+  generate_access (stream, flags);\n+\n+  fputs (\"  \", out);\n+  if ((flags & ACC_STATIC))\n+    fputs (\"static \", out);\n+  else if (! (flags & ACC_FINAL) && ! (jcf->access_flags & ACC_FINAL))\n+    {\n+      /* Don't print `virtual' if we have a constructor.  */\n+      if (! is_init)\n+\tfputs (\"virtual \", out);\n+    }\n+  print_c_decl (out, jcf, name_index, sig_index, flags, is_init);\n+\n+  /* FIXME: it would be nice to decompile small methods here.  That\n+     would allow for inlining.  */\n+\n+  fprintf(out, \";\\n\");\n+}\n+\n+static void\n+DEFUN(print_c_decl, (stream, jcf, name_index, signature_index, flags, is_init),\n+      FILE* stream AND JCF* jcf\n+      AND int name_index AND int signature_index AND JCF_u2 flags\n+      AND int is_init)\n+{\n+  if (JPOOL_TAG (jcf, signature_index) != CONSTANT_Utf8)\n+    fprintf (stream, \"<not a UTF8 constant>\");\n+  else\n+    {\n+      int length = JPOOL_UTF_LENGTH (jcf, signature_index);\n+      unsigned char *str0 = JPOOL_UTF_DATA (jcf, signature_index);\n+      register  unsigned char *str = str0;\n+      unsigned char *limit = str + length;\n+      int j;\n+      char *ctype;\n+      int need_space = 0;\n+      int is_method = str[0] == '(';\n+\n+      if (is_method)\n+\t{\n+\t  /* Skip to the return signature, and print that first.\n+\t     However, don't do this is we are printing a construtcor.\n+\t     */\n+\t  if (is_init)\n+\t    {\n+\t      str = str0 + 1;\n+\t      /* FIXME: Most programmers love Celtic knots because\n+\t\t they see their own code in the interconnected loops.\n+\t\t That is, this is spaghetti.  */\n+\t      goto have_constructor;\n+\t    }\n+\t  else\n+\t    {\n+\t      while (str < limit)\n+\t\t{\n+\t\t  int ch = *str++;\n+\t\t  if (ch == ')')\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t}\n+\n+    again:\n+      while (str < limit)\n+\t{\n+\t  switch (str[0])\n+\t    {\n+\t    case '[':\n+\t      for (str++; str < limit && *str >= '0' && *str <= '9'; str++)\n+\t\t;\n+\t      switch (*str)\n+\t\t{\n+\t\tcase 'B': ctype = \"jbyteArray\";  goto printit;\n+\t\tcase 'C': ctype = \"jcharArray\";  goto printit;\n+\t\tcase 'D': ctype = \"jdoubleArray\";  goto printit;\n+\t\tcase 'F': ctype = \"jfloatArray\";  goto printit;\n+\t\tcase 'I': ctype = \"jintArray\";  goto printit;\n+\t\tcase 'S': ctype = \"jshortArray\";  goto printit;\n+\t\tcase 'J': ctype = \"jlongArray\";  goto printit;\n+\t\tcase 'Z': ctype = \"jbooleanArray\";  goto printit;\n+\t\tcase '[': ctype = \"jobjectArray\"; goto printit;\n+\t\tcase 'L':\n+\t\t  /* We have to generate a reference to JArray here,\n+\t\t     so that our output matches what the compiler\n+\t\t     does.  */\n+\t\t  ++str;\n+\t\t  fputs (\"JArray<\", out);\n+\t\t  while (str < limit && *str != ';')\n+\t\t    {\n+\t\t      int ch = UTF8_GET (str, limit);\n+\t\t      if (ch == '/')\n+\t\t\tfputs (\"::\", stream);\n+\t\t      else\n+\t\t\tjcf_print_char (stream, ch);\n+\t\t    }\n+\t\t  fputs (\" *> *\", out);\n+\t\t  need_space = 0;\n+\t\t  ++str;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  fprintf (stderr, \"unparseable signature `%s'\\n\", str0);\n+\t\t  found_error = 1;\n+\t\t  ctype = \"???\"; goto printit;\n+\t\t}\n+\t      break;\n+\t    case '(':\n+\t      fputc (*str++, stream);\n+\t      continue;\n+\t    case ')':\n+\t      fputc (*str++, stream);\n+\t      /* the return signature was printed in the first pass. */\n+\t      return;\n+\t    case 'B': ctype = \"jbyte\";  goto printit;\n+\t    case 'C': ctype = \"jchar\";  goto printit;\n+\t    case 'D': ctype = \"jdouble\";  goto printit;\n+\t    case 'F': ctype = \"jfloat\";  goto printit;\n+\t    case 'I': ctype = \"jint\";  goto printit;\n+\t    case 'J': ctype = \"jlong\";  goto printit;\n+\t    case 'S': ctype = \"jshort\";  goto printit;\n+\t    case 'Z': ctype = \"jboolean\";  goto printit;\n+\t    case 'V': ctype = \"void\";  goto printit;\n+\t    case 'L':\n+\t      ++str;\n+\t      while (*str && *str != ';')\n+\t\t{\n+\t\t  int ch = UTF8_GET (str, limit);\n+\t\t  if (ch == '/')\n+\t\t    fputs (\"::\", stream);\n+\t\t  else\n+\t\t    jcf_print_char (stream, ch);\n+\t\t}\n+\t      fputs (\" *\", stream);\n+\t      if (*str == ';')\n+\t\tstr++;\n+\t      need_space = 0;\n+\t      break;\n+\t    default:\n+\t      need_space = 1;\n+\t      jcf_print_char (stream, *str++);\n+\t      break;\n+\t    printit:\n+\t      str++;\n+\t      need_space = 1;\n+\t      fputs (ctype, stream);\n+\t      break;\n+\t    }\n+\n+\t  if (is_method && str < limit && *str != ')')\n+\t    fputs (\", \", stream);\n+\t}\n+    have_constructor:\n+      if (name_index)\n+\t{\n+\t  if (need_space)\n+\t    fprintf (stream, \" \");\n+\t  /* Declare constructors specially.  */\n+\t  if (is_init)\n+\t    print_base_classname (stream, jcf, jcf->this_class);\n+\t  else\n+\t    print_name (stream, jcf, name_index);\n+\t}\n+      if (is_method)\n+\t{\n+\t  fputs (\" (\", stream);\n+\t  /* Go to beginning, skipping '('. */\n+\t  str = str0 + 1;\n+\t  goto again; /* To handle argument signatures. */\n+\t}\n+    }\n+}\n+\n+int\n+DEFUN(print_mangled_classname, (stream, jcf, prefix, index),\n+      FILE *stream AND JCF *jcf AND char *prefix AND int index)\n+{\n+  int name_index = JPOOL_USHORT1 (jcf, index);\n+  fputs (prefix, stream);\n+  jcf_print_utf8_replace (out,\n+\t\t\t  JPOOL_UTF_DATA (jcf, name_index),\n+\t\t\t  JPOOL_UTF_LENGTH (jcf, name_index),\n+\t\t\t  '/', '_');\n+}\n+\n+/* Print PREFIX, then a class name in C++ format.  If the name refers\n+   to an array, ignore it and don't print PREFIX.  Returns 1 if\n+   something was printed, 0 otherwise.  */\n+static int\n+print_cxx_classname (stream, prefix, jcf, index)\n+     FILE *stream;\n+     char *prefix;\n+     JCF *jcf;\n+     int index;\n+{\n+  int name_index = JPOOL_USHORT1 (jcf, index);\n+  int i, len, c;\n+  unsigned char *s, *p, *limit;\n+\n+  s = JPOOL_UTF_DATA (jcf, name_index);\n+  len = JPOOL_UTF_LENGTH (jcf, name_index);\n+  limit = s + len;\n+\n+  /* Explicitly omit arrays here.  */\n+  p = s;\n+  c = UTF8_GET (p, limit);\n+  if (c == '[')\n+    return 0;\n+\n+  fputs (prefix, stream);\n+  while (s < limit)\n+    {\n+      c = UTF8_GET (s, limit);\n+      if (c == '/')\n+\tfputs (\"::\", stream);\n+      else\n+\tjcf_print_char (stream, c);\n+    }\n+\n+  return 1;\n+}\n+\n+int written_class_count = 0;\n+\n+/* Return name of superclass.  If LEN is not NULL, fill it with length\n+   of name.  */\n+static unsigned char *\n+super_class_name (derived_jcf, len)\n+     JCF *derived_jcf;\n+     int *len;\n+{\n+  int supername_index = JPOOL_USHORT1 (derived_jcf, derived_jcf->super_class);\n+  int supername_length = JPOOL_UTF_LENGTH (derived_jcf, supername_index);\n+  unsigned char *supername = JPOOL_UTF_DATA (derived_jcf, supername_index);\n+\n+  if (len)\n+    *len = supername_length;\n+\n+  return supername;\n+}\n+\n+/* Print declarations for all classes required by this class.  FIXME:\n+   the current implementation just prints every class name from the\n+   constant pool.  This is too much.  We really only need to print a\n+   declaration for each class which is the type of a return value, a\n+   field, or an argument.  */\n+static void\n+print_class_decls (out, jcf)\n+     FILE *out;\n+     JCF *jcf;\n+{\n+  int i, seen_one = 0;\n+\n+  for (i = 1; i < JPOOL_SIZE (jcf); ++i)\n+    {\n+      int kind = JPOOL_TAG (jcf, i);\n+      if (kind == CONSTANT_Class)\n+\t{\n+\t  if (print_cxx_classname (out, \"class \", jcf, i))\n+\t    fputs (\";\\n\", out);\n+\t  seen_one = 1;\n+\t}\n+    }\n+\n+  if (seen_one)\n+    fputs (\"\\n\", out);\n+}\n+\n+static void\n+DEFUN(process_file, (file, out),\n+      JCF *jcf AND FILE *out)\n+{\n+  int code, i;\n+\n+  current_jcf = main_jcf = jcf;\n+\n+  last_access = 0;\n+\n+  if (jcf_parse_preamble (jcf) != 0)\n+    {\n+      fprintf (stderr, \"Not a valid Java .class file.\\n\");\n+      found_error = 1;\n+      return;\n+    }\n+\n+  /* Parse and possibly print constant pool */\n+  code = jcf_parse_constant_pool (jcf);\n+  if (code != 0)\n+    {\n+      fprintf (stderr, \"error while parsing constant pool\\n\");\n+      found_error = 1;\n+      return;\n+    }\n+  code = verify_constant_pool (jcf);\n+  if (code > 0)\n+    {\n+      fprintf (stderr, \"error in constant pool entry #%d\\n\", code);\n+      found_error = 1;\n+      return;\n+    }\n+\n+  jcf_parse_class (jcf);\n+\n+  if (written_class_count++ == 0)\n+    fputs (\"// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-\\n\\n\",\n+\t   out);\n+\n+  print_mangled_classname (out, jcf, \"#ifndef __\", jcf->this_class);\n+  fprintf (out, \"__\\n\");\n+\n+  print_mangled_classname (out, jcf, \"#define __\", jcf->this_class);\n+  fprintf (out, \"__\\n\\n\");\n+\n+  if (jcf->super_class)\n+    {\n+      int super_length;\n+      unsigned char *supername = super_class_name (jcf, &super_length);\n+\n+      fputs (\"#include <\", out);\n+      jcf_print_utf8 (out, supername, super_length);\n+      fputs (\".h>\\n\", out);\n+\n+      /* FIXME: If our superclass is Object, then we include\n+\t java-array.h.  The right thing to do here is look at all the\n+\t methods and fields and see if an array is in use.  Only then\n+\t would we need to include java-array.h.  */\n+      if (! utf8_cmp (supername, super_length, \"java/lang/Object\"))\n+\tfputs (\"#include <java-array.h>\\n\", out);\n+\n+      fputs (\"\\n\", out);\n+    }\n+\n+  print_class_decls (out, jcf);\n+\n+  for (i = 0; i < prepend_count; ++i)\n+    fprintf (out, \"%s\\n\", prepend_specs[i]);\n+  if (prepend_count > 0)\n+    fputc ('\\n', out);\n+\n+  if (! print_cxx_classname (out, \"class \", jcf, jcf->this_class))\n+    {\n+      fprintf (stderr, \"class is of array type\\n\");\n+      found_error = 1;\n+      return;\n+    }\n+  if (jcf->super_class)\n+    {\n+      if (! print_cxx_classname (out, \" : public \", jcf, jcf->super_class))\n+\t{\n+\t  fprintf (stderr, \"base class is of array type\\n\");\n+\t  found_error = 1;\n+\t  return;\n+\t}\n+    }\n+  fputs (\"\\n{\\n\", out);\n+\n+  /* We make a single pass over the file, printing methods and fields\n+     as we see them.  We have to list the methods in the same order\n+     that they appear in the class file, so that the Java and C++\n+     vtables have the same layout.  */\n+  jcf_parse_fields (jcf);\n+  jcf_parse_methods (jcf);\n+  jcf_parse_final_attributes (jcf);\n+\n+  /* Generate friend decl if we still must.  */\n+  for (i = 0; i < friend_count; ++i)\n+    fprintf (out, \"  friend %s\\n\", friend_specs[i]);\n+\n+  /* Generate extra declarations.  */\n+  if (add_count > 0)\n+    fputc ('\\n', out);\n+  for (i = 0; i < add_count; ++i)\n+    fprintf (out, \"  %s\\n\", add_specs[i]);\n+\n+  fputs (\"};\\n\", out);\n+\n+  if (append_count > 0)\n+    fputc ('\\n', out);\n+  for (i = 0; i < append_count; ++i)\n+    fprintf (out, \"%s\\n\", append_specs[i]);\n+\n+  print_mangled_classname (out, jcf, \"\\n#endif /* __\", jcf->this_class);\n+  fprintf (out, \"__ */\\n\");\n+}\n+\n+static void\n+usage ()\n+{\n+  fprintf (stderr, \"gjavah: no classes specified\\n\");\n+  exit (1);\n+}\n+\n+static void\n+help ()\n+{\n+  printf (\"Usage: gjavah [OPTION]... CLASS...\\n\\n\");\n+  printf (\"Generate C++ header files from .class files\\n\\n\");\n+  printf (\"  --classpath PATH        Set path to find .class files\\n\");\n+  printf (\"  -d DIRECTORY            Set output directory name\\n\");\n+  printf (\"  --help                  Print this help, then exit\\n\");\n+  printf (\"  -o FILE                 Set output file name\\n\");\n+  printf (\"  -td DIRECTORY           Set temporary directory name\\n\");\n+  printf (\"  -v, --verbose           Print extra information while running\\n\");\n+  printf (\"  --version               Print version number, then exit\\n\");\n+  /* FIXME: print bug-report information.  */\n+  exit (0);\n+}\n+\n+static void\n+no_argument (opt)\n+     char *opt;\n+{\n+  fprintf (stderr, \"gjavah: no argument given for option `%s'\\n\", opt);\n+  exit (1);\n+}\n+\n+static void\n+version ()\n+{\n+  /* FIXME: use version.c?  */\n+  printf (\"gjavah (GNU gcc) 0.0\\n\\n\");\n+  printf (\"Copyright (C) 1998 Free Software Foundation, Inc.\\n\");\n+  printf (\"This is free software; see the source for copying conditions.  There is NO\\n\");\n+  printf (\"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\");\n+  exit (0);\n+}\n+\n+int\n+DEFUN(main, (argc, argv),\n+      int argc AND char** argv)\n+{\n+  JCF jcf;\n+  int argi;\n+\n+  if (argc <= 1)\n+    usage ();\n+\n+  for (argi = 1; argi < argc; argi++)\n+    {\n+      char *arg = argv[argi];\n+\n+      if (arg[0] != '-' || ! strcmp (arg, \"--\"))\n+\tbreak;\n+\n+      /* Just let all arguments be given in either \"-\" or \"--\" form.  */\n+      if (arg[1] == '-')\n+\t++arg;\n+\n+      if (strcmp (arg, \"-o\") == 0)\n+\t{\n+\t  if (argi + 1 < argc)\n+\t    output_file = argv[++argi];\n+\t  else\n+\t    no_argument (argv[argi]);\n+\t}\n+      else if (strcmp (arg, \"-d\") == 0)\n+\t{\n+\t  if (argi + 1 < argc)\n+\t    output_directory = argv[++argi];\n+\t  else\n+\t    no_argument (argv[argi]);\n+\t}\n+      else if (strcmp (arg, \"-td\") == 0)\n+\t{\n+\t  if (argi + 1 < argc)\n+\t    temp_directory = argv[++argi];\n+\t  else\n+\t    no_argument (argv[argi]);\n+\t}\n+      else if (strcmp (arg, \"-prepend\") == 0)\n+\t{\n+\t  if (argi + 1 < argc)\n+\t    {\n+\t      if (prepend_count == 0)\n+\t\tprepend_specs = (char**) ALLOC ((argc-argi) * sizeof (char*));\n+\t      prepend_specs[prepend_count++] = argv[++argi];\n+\t    }\n+\t  else\n+\t    no_argument (argv[argi]);\n+\t}\n+      else if (strcmp (arg, \"-friend\") == 0)\n+\t{\n+\t  if (argi + 1 < argc)\n+\t    {\n+\t      if (friend_count == 0)\n+\t\tfriend_specs = (char**) ALLOC ((argc-argi) * sizeof (char*));\n+\t      friend_specs[friend_count++] = argv[++argi];\n+\t    }\n+\t  else\n+\t    no_argument (argv[argi]);\n+\t}\n+      else if (strcmp (arg, \"-add\") == 0)\n+\t{\n+\t  if (argi + 1 < argc)\n+\t    {\n+\t      if (add_count == 0)\n+\t\tadd_specs = (char**) ALLOC ((argc-argi) * sizeof (char*));\n+\t      add_specs[add_count++] = argv[++argi];\n+\t    }\n+\t  else\n+\t    no_argument (argv[argi]);\n+\t}\n+      else if (strcmp (arg, \"-append\") == 0)\n+\t{\n+\t  if (argi + 1 < argc)\n+\t    {\n+\t      if (append_count == 0)\n+\t\tappend_specs = (char**) ALLOC ((argc-argi) * sizeof (char*));\n+\t      append_specs[append_count++] = argv[++argi];\n+\t    }\n+\t  else\n+\t    no_argument (argv[argi]);\n+\t}\n+      else if (strcmp (arg, \"-classpath\") == 0)\n+\t{\n+\t  if (argi + 1 < argc)\n+\t    classpath = argv[++argi];\n+\t  else\n+\t    no_argument (argv[argi]);\n+\t}\n+      else if (strcmp (arg, \"-verbose\") == 0 || strcmp (arg, \"-v\") == 0)\n+\tverbose++;\n+      else if (strcmp (arg, \"-stubs\") == 0)\n+\tstubs++;\n+      else if (strcmp (arg, \"-help\") == 0)\n+\thelp ();\n+      else if (strcmp (arg, \"-version\") == 0)\n+\tversion ();\n+      else\n+\t{\n+\t  fprintf (stderr, \"%s: illegal argument\\n\", argv[argi]);\n+\t  exit (1);\n+\t}\n+    }\n+\n+  if (argi == argc)\n+    usage ();\n+\n+  if (classpath == NULL)\n+    {\n+      classpath = (char *) getenv (\"CLASSPATH\");\n+      if (classpath == NULL)\n+\tclasspath = \"\";\n+    }\n+\n+  for (; argi < argc; argi++)\n+    {\n+      char *classname = argv[argi];\n+      char *classfile_name, *current_output_file;\n+\n+      if (verbose)\n+\tfprintf (stderr, \"Processing %s\\n\", classname);\n+      classfile_name = find_class (classname, strlen (classname), &jcf, 1);\n+      if (classfile_name == NULL)\n+\t{\n+\t  fprintf (stderr, \"%s: no such class\\n\", classname);\n+\t  exit (1);\n+\t}\n+      if (verbose)\n+\tfprintf (stderr, \"Found in %s\\n\", classfile_name);\n+      if (output_file)\n+\t{\n+\t  if (strcmp (output_file, \"-\") == 0)\n+\t    out = stdout;\n+\t  else if (out == NULL)\n+\t    out = fopen (output_file, \"w\");\n+\t  if (out == NULL)\n+\t    {\n+\t      perror (output_file);\n+\t      exit (1);\n+\t    }\n+\t  current_output_file = output_file;\n+\t}\n+      else\n+\t{\n+\t  int dir_len = strlen (output_directory);\n+\t  int i, classname_length = strlen (classname);\n+\t  current_output_file = (char*) ALLOC (dir_len + classname_length + 4);\n+\t  strcpy (current_output_file, output_directory);\n+\t  if (dir_len > 0 && output_directory[dir_len-1] != '/')\n+\t    current_output_file[dir_len++] = '/';\n+\t  for (i = 0; classname[i] != '\\0'; i++)\n+\t    {\n+\t      char ch = classname[i];\n+\t      if (ch == '.')\n+\t\tch = '/';\n+\t      current_output_file[dir_len++] = ch;\n+\t    }\n+\t  strcpy (current_output_file+dir_len, \".h\");\n+\t  out = fopen (current_output_file, \"w\");\n+\t  if (out == NULL)\n+\t    {\n+\t      perror (current_output_file);\n+\t      exit (1);\n+\t    }\n+\t}\n+      process_file (&jcf, out);\n+      JCF_FINISH (&jcf);\n+      if (current_output_file != output_file)\n+\tfree (current_output_file);\n+    }\n+\n+  if (out != NULL && out != stdout)\n+    fclose (out);\n+\n+  return found_error;\n+}\n+\n+/* TODO:\n+\n+ * Do whatever the javah -stubs flag does.\n+\n+ * Emit \"structure forward declarations\" when needed.\n+\n+ * Generate C headers, like javah\n+\n+ */"}, {"sha": "576096f8270292c18e8a564b0351f69085ab4fa4", "filename": "gcc/java/java-except.h", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjava-except.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjava-except.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-except.h?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,67 @@\n+/* Definitions for exception handling for use by the GNU compiler\n+   for the Java(TM) language compiler.\n+   Copyright (C) 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+struct eh_range\n+  {\n+    /* The (byte-code PC) range of the handled block. */\n+    int start_pc;\n+    int end_pc;\n+\n+    /* A list of handlers.  For each element in the list,\n+       the TREE_PURPOSE is the handled class (NULL_EXPR for a finally block),\n+       and the TREE_VALUE is the LABEL_DECL of the handler. */\n+    tree handlers;\n+\n+    /* Surrunding handler, if any. */\n+    struct eh_range *outer;\n+\n+    /* The first child range.  It is is nested inside this range\n+       (i.e. this.start_pc <= first_child.end_pc\n+       && this.end_pc >= first_child.end_pc).\n+       The children are linked together using next_sibling, and are sorted\n+       by increasing start_pc and end_pc (we do not support non-nested\n+       overlapping ranges). */\n+    struct eh_range *first_child;\n+\n+    /* The next child of outer, in address order. */\n+    struct eh_range *next_sibling;\n+\n+#if 0\n+    /* Next handler, sorted by ascending start_pc then descending end_pc. */\n+    tree next;\n+#endif\n+  };\n+\n+/* A dummy range that represents the entire method. */\n+extern struct eh_range whole_range;\n+\n+#define NULL_EH_RANGE (&whole_range)\n+\n+extern struct eh_range * find_handler PROTO ((int));\n+\n+extern void method_init_exceptions PROTO ((void));\n+\n+extern void emit_handlers PROTO ((void));\n+"}, {"sha": "8fbe55cb7088d72ae8481705006132c494203949", "filename": "gcc/java/java-opcodes.h", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjava-opcodes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjava-opcodes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-opcodes.h?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,5 @@\n+enum java_opcode {\n+#define JAVAOP(NAME, CODE, KIND, TYPE, VALUE) OPCODE_##NAME = CODE,\n+#include \"javaop.def\"\n+#undef JAVAOP\n+};"}, {"sha": "a05b92d0aace6c3a979c86d4c0c80264ad0a44c0", "filename": "gcc/java/java-tree.def", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjava-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjava-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.def?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,12 @@\n+/* Shift right, logical. */\n+\n+DEFTREECODE (URSHIFT_EXPR, \"urshift_expr\", \"2\", 2)\n+\n+/* Return -1, 0, 1 depending on whether the first argument is\n+   less, equal, or greater to the second argument. */\n+DEFTREECODE (COMPARE_EXPR, \"compare_expr\", \"2\", 2)\n+\n+/* Same as COMPARE_EXPR, but if either value is NaN, the result is -1. */\n+DEFTREECODE (COMPARE_L_EXPR, \"compare_l_expr\", \"2\", 2)\n+/* Same as COMPARE_EXPR, but if either value is NaN, the result is 1. */\n+DEFTREECODE (COMPARE_G_EXPR, \"compare_g_expr\", \"2\", 2)"}, {"sha": "d8084993bee569677b7240fdd27a538086e2df7c", "filename": "gcc/java/java-tree.h", "status": "added", "additions": 720, "deletions": 0, "changes": 720, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,720 @@\n+/* Definitions for parsing and type checking for the GNU compiler for\n+   the Java(TM) language.\n+   Copyright (C) 1997, 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Hacked by Per Bothner <bothner@cygnus.com> February 1996. */\n+\n+/* Java language-specific tree codes.  */\n+#define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n+enum java_tree_code {\n+  __DUMMY = LAST_AND_UNUSED_TREE_CODE,\n+#include \"java-tree.def\"\n+  LAST_JAVA_TREE_CODE\n+};\n+#undef DEFTREECODE\n+\n+struct JCF;\n+\n+/* Usage of TREE_LANG_FLAG_?:\n+   0: IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P (in IDENTIFIER_NODE)\n+      RESOLVE_EXPRESSION_NAME_P (in EXPR_WITH_FILE_LOCATION)\n+      IS_FOR_LOOP_P (in LOOP_EXPR)\n+   1: CLASS_HAS_SUPER_FLAG (in TREE_VEC).\n+      IS_A_CLASSFILE_NAME (in IDENTIFIER_NODE)\n+      COMPOUND_ASSIGN_P (in EXPR (binop_*))\n+   2: RETURN_MAP_ADJUSTED (in TREE_VEC).\n+      QUALIFIED_P (in IDENTIFIER_NODE)\n+      PRIMARY_P (in EXPR_WITH_FILE_LOCATION)\n+      MODIFY_EXPR_FROM_INITIALIZATION_P (in MODIFY_EXPR)\n+   3: IS_AN_IMPORT_ON_DEMAND_P (in IDENTIFIER_NODE)\n+      RESOLVE_PACKAGE_NAME_P (in EXPR_WITH_FILE_LOCATION)\n+   4: RESOLVE_TYPE_NAME_P (in EXPR_WITH_FILE_LOCATION)\n+   5: IS_BREAK_STMT_P (in EXPR_WITH_FILE_LOCATION)\n+\n+   Usage of TYPE_LANG_FLAG_?:\n+   1: TYPE_ARRAY_P (in RECORD_TYPE).\n+   2: CLASS_LOADED_P (in RECORD_TYPE).\n+   3: CLASS_FROM_SOURCE_P (in RECORD_TYPE).\n+   4: CLASS_P (in RECORD_TYPE).\n+\n+   Usage of DECL_LANG_FLAG_?:\n+   1: METHOD_PUBLIC (in FUNCTION_DECL).\n+      FIELD_PUBLIC (in FIELD_DECL).\n+      CLASS_PUBLIC (in TYPE_DECL).\n+   2: METHOD_STATIC (in FUNCTION_DECL).\n+      (But note that FIELD_STATIC uses TREE_STATIC!)\n+      CLASS_COMPLETE_P (in TYPE_DECL)\n+   3: METHOD_FINAL (in FUNCTION_DECL)\n+      FIELD_FINAL (in FIELD_DECL)\n+      CLASS_FINAL (in TYPE_DECL)\n+   4: METHOD_SYNCHRONIZED (in FUNCTION_DECL).\n+      LABEL_IN_SUBR (in LABEL_DECL)\n+      CLASS_INTERFACE (in TYPE_DECL)\n+      FIELD_VOLATILE (int FIELD_DECL)\n+   5: METHOD_ABSTRACT (in FUNCTION_DECL).\n+      LABEL_IS_SUBR_START (in LABEL_DECL)\n+      CLASS_ABSTRACT (in TYPE_DECL)\n+      FIELD_TRANSIENT (in FIELD_DECL)\n+   6: METHOD_TRANSIENT (in FUNCTION_DECL)\n+      LABEL_CHANGED (in LABEL_DECL)\n+      CLASS_SUPER (in TYPE_DECL, ACC_SUPER flag)\n+      INITIALIZED_P (in FIELD_DECL, VAR_DECL, PARM_DECL)\n+   7: DECL_CONSTRUCTOR_P (in FUNCTION_DECL)\n+*/\n+\n+/* True if the class whose TYPE_BINFO this is has a superclass.\n+   (True of all classes except Object.) */\n+#define CLASS_HAS_SUPER_FLAG(BINFO) TREE_LANG_FLAG_1(BINFO)\n+#define CLASS_HAS_SUPER(TYPE) CLASS_HAS_SUPER_FLAG (TYPE_BINFO (TYPE))\n+\n+/* Return the supertype of class TYPE, or NULL_TREE is it has none. */\n+#define CLASSTYPE_SUPER(TYPE) (CLASS_HAS_SUPER (TYPE) ? \\\n+  BINFO_TYPE (TREE_VEC_ELT (TYPE_BINFO_BASETYPES (TYPE), 0)) : NULL_TREE)\n+\n+/* True if the class we are compiling is a .java source file;\n+   false if it is a .class bytecode file. */\n+extern int compiling_from_source;\n+\n+/* The class defined by the actual (main) file we are compiling. */\n+extern tree main_class;\n+\n+/* The class we are currently processing. */\n+extern tree current_class;\n+\n+/* Nonzero if we want to automatically do array bounds checking;\n+   on by default.  Use -fno-bounds-check to disable.  */\n+\n+extern int flag_bounds_check;\n+\n+/* Nonzero if we should make is_compiled_class always return 1 for\n+   appropriate classes that we're referencing.  */\n+\n+extern int flag_assume_compiled;\n+\n+extern int flag_emit_class_files;\n+\n+/* The Java .class file that provides main_class;  the main input file. */\n+extern struct JCF main_jcf[1], *current_jcf;\n+\n+typedef struct CPool constant_pool;\n+\n+#define CONSTANT_ResolvedFlag 16\n+\n+/* The cpool->data[i] for a ResolvedString points to a STRING_CST. */\n+#define CONSTANT_ResolvedString    (CONSTANT_String+CONSTANT_ResolvedFlag)\n+\n+/* The cpool->data[i] for a ResolvedClass points to a RECORD_TYPE. */\n+#define CONSTANT_ResolvedClass     (CONSTANT_Class+CONSTANT_ResolvedFlag)\n+\n+#define CPOOL_UTF(CPOOL, INDEX) ((tree) (CPOOL)->data[INDEX])\n+\n+/* A NameAndType constant is represented as a TREE_LIST.\n+   The type is the signature string (as an IDENTIFIER_NODE).  */\n+\n+#define NAME_AND_TYPE_NAME(CPOOL, IDX) \\\n+  CPOOL_UTF(CPOOL, CPOOL_USHORT1(CPOOL, IDX))\n+#define NAME_AND_TYPE_SIGNATURE(CPOOL, IDX) \\\n+  CPOOL_UTF(CPOOL, CPOOL_USHORT2(CPOOL, IDX))\n+\n+/* A FieldRef, MethodRef or InterfaceMethodRef constant\n+   is represented as a TREE_LIST. */\n+\n+#define COMPONENT_REF_CLASS_INDEX(CPOOL, IDX) CPOOL_USHORT1(CPOOL, IDX)\n+#define COMPONENT_REF_NAME_AND_TYPE(CPOOL, IDX) CPOOL_USHORT2(CPOOL, IDX)\n+#define COMPONENT_REF_NAME(CPOOL, IDX) \\\n+  NAME_AND_TYPE_NAME (CPOOL, COMPONENT_REF_NAME_AND_TYPE(CPOOL, IDX))\n+#define COMPONENT_REF_SIGNATURE(CPOOL, IDX) \\\n+  NAME_AND_TYPE_SIGNATURE (CPOOL, COMPONENT_REF_NAME_AND_TYPE(CPOOL, IDX))\n+\n+/* \"Promoted types\" that are used for primitive types smaller\n+   than int.  We could use int_type_node, but then we would lose\n+   type information (such as needed for debugging). */\n+extern tree promoted_byte_type_node;\n+extern tree promoted_short_type_node;\n+extern tree promoted_char_type_node;\n+extern tree promoted_boolean_type_node;\n+\n+extern tree byte_type_node;\n+extern tree short_type_node;\n+extern tree int_type_node;\n+extern tree long_type_node;\n+\n+extern tree unsigned_byte_type_node;\n+extern tree unsigned_short_type_node;\n+extern tree unsigned_int_type_node;\n+extern tree unsigned_long_type_node;\n+\n+extern tree boolean_type_node;\n+extern tree char_type_node;\n+extern tree float_type_node;\n+extern tree double_type_node;\n+\n+extern tree object_type_node;\n+extern tree object_ptr_type_node;\n+extern tree string_type_node;\n+extern tree throwable_type_node;\n+\n+extern tree byte_array_type_node;\n+extern tree short_array_type_node;\n+extern tree int_array_type_node;\n+extern tree long_array_type_node;\n+extern tree boolean_array_type_node;\n+extern tree char_array_type_node;\n+extern tree double_array_type_node;\n+extern tree float_array_type_node;\n+extern tree array_array_type_node;\n+extern tree object_array_type_node;\n+extern tree string_array_type_node;\n+extern tree TYPE_identifier_node;      /* \"TYPE\" */\n+extern tree init_identifier_node;      /* \"<init>\" */\n+extern tree clinit_identifier_node;      /* \"<clinit>\" */\n+extern tree void_signature_node;       /* \"()V\" */\n+extern tree finalize_identifier_node;  /* \"finalize\" */\n+extern tree length_identifier_node;  /* \"length\" */\n+extern tree this_identifier_node;  /* \"this\" */\n+extern tree super_identifier_node;  /* \"super\" */\n+extern tree one_elt_array_domain_type;\n+extern tree void_type_node;\n+extern tree ptr_type_node;\n+/* The type of the return address of a subroutine. */\n+extern tree return_address_type_node;\n+\n+/* Nodes for boolean constants TRUE and FALSE. */\n+extern tree boolean_true_node, boolean_false_node;\n+\n+/* Integer constants not declared in tree.h. */\n+extern tree integer_negative_one_node;\n+extern tree integer_two_node;\n+extern tree integer_four_node;\n+\n+/* The type for struct methodtable. */\n+extern tree methodtable_type;\n+extern tree methodtable_ptr_type;\n+\n+extern tree utf8const_type;\n+extern tree utf8const_ptr_type;\n+\n+extern tree class_type_node;\n+extern tree class_ptr_type;\n+extern tree field_type_node;\n+extern tree constants_type_node;\n+extern tree dtable_type, dtable_ptr_type;\n+extern tree field_ptr_type_node;\n+extern tree field_info_union_node;\n+extern tree method_type_node;\n+extern tree method_ptr_type_node;\n+#define nativecode_ptr_type_node ptr_type_node\n+\n+/* References to internal libjava functions we use. */\n+extern tree alloc_object_node;\n+extern tree soft_instanceof_node;\n+extern tree soft_checkcast_node;\n+extern tree soft_initclass_node;\n+extern tree soft_newarray_node;\n+extern tree soft_anewarray_node;\n+extern tree soft_multianewarray_node;\n+extern tree soft_badarrayindex_node;\n+extern tree throw_node;\n+extern tree soft_checkarraystore_node;\n+extern tree soft_monitorenter_node;\n+extern tree soft_monitorexit_node;\n+extern tree soft_lookupinterfacemethod_node;\n+extern tree soft_fmod_node;\n+\n+extern tree access_flags_type_node;\n+\n+extern tree class_dtable_decl;\n+\n+/* They need to be reset before processing each class */\n+extern struct CPool *outgoing_cpool; \n+extern tree current_constant_pool_data_ref;\n+\n+\n+struct lang_identifier\n+{\n+  struct tree_identifier ignore;\n+  tree global_value, local_value;\n+\n+  /* If non-NULL:  An ADDR_REF to a VAR_DECL that contains\n+   * the Utf8Const representation of the identifier.  */\n+  tree utf8_ref;\n+};\n+\n+/* Macros for access to language-specific slots in an identifier.  */\n+/* UNless specifide, each of these slots contains a DECL node or null.  */\n+\n+/* This represents the value which the identifier has in the\n+   file-scope namespace.  */\n+#define IDENTIFIER_GLOBAL_VALUE(NODE)   \\\n+  (((struct lang_identifier *)(NODE))->global_value)\n+/* This represents the value which the identifier has in the current\n+   scope.  */\n+#define IDENTIFIER_LOCAL_VALUE(NODE)    \\\n+  (((struct lang_identifier *)(NODE))->local_value)\n+\n+/* Given an identifier NODE, get the corresponding (non-handle) class.\n+   For get_identifier (\"java.lang.Number\"), the result is\n+   the struct whose DECL_ASSEMBLER_NAME is \"Classjava_lang_Number\". */\n+#define IDENTIFIER_CLASS_VALUE(NODE) IDENTIFIER_GLOBAL_VALUE(NODE)\n+\n+/* Given an identifier NODE, get the corresponding handle class.\n+   For get_identifier (\"java.lang.Number\"), the result is\n+   the struct whose DECL_ASSEMBLER_NAME is \"Hjava_lang_Number\". */\n+#define IDENTIFIER_HANDLECLASS_VALUE(NODE) ???\n+\n+/* Given a signature of a reference (or array) type, or a method, return the\n+   corresponding type (if one has been allocated).\n+   Do not use for primitive types, since they may be ambiguous.\n+   (E.g. is \"I\" a signature or a class name?) */\n+#define IDENTIFIER_SIGNATURE_TYPE(NODE) IDENTIFIER_GLOBAL_VALUE(NODE)\n+\n+/* If non-NULL:  An ADDR_REF to a VAR_DECL that contains\n+   the Utf8Const representation of the identifier.  */\n+#define IDENTIFIER_UTF8_REF(NODE) \\\n+  (((struct lang_identifier *)(NODE))->utf8_ref)\n+\n+#define IDENTIFIER_UTF8_DECL(NODE) \\\n+  TREE_OPERAND((((struct lang_identifier *)(NODE))->utf8_ref), 0)\n+\n+/* For a FUNCTION_DECL, if we are compiling a .class file, then this is\n+   the position in the .class file of the method code.\n+   Specifically, this is the code itself, not the code attribute. */\n+#define DECL_CODE_OFFSET(DECL) (DECL_LANG_SPECIFIC(DECL)->code_offset)\n+/* Similarly, the length of the bytecode. */\n+#define DECL_CODE_LENGTH(DECL) (DECL_LANG_SPECIFIC(DECL)->code_length)\n+/* Similarly, the position of the LineNumberTable attribute. */\n+#define DECL_LINENUMBERS_OFFSET(DECL) \\\n+  (DECL_LANG_SPECIFIC(DECL)->linenumbers_offset)\n+/* Similarly, the position of the LocalVariableTable attribute\n+   (following the standard attribute header). */\n+#define DECL_LOCALVARIABLES_OFFSET(DECL) \\\n+  (DECL_LANG_SPECIFIC(DECL)->localvariables_offset)\n+\n+#define DECL_MAX_LOCALS(DECL) (DECL_LANG_SPECIFIC(DECL)->max_locals)\n+#define DECL_MAX_STACK(DECL) (DECL_LANG_SPECIFIC(DECL)->max_stack)\n+/* Number of local variable slots needed for the arguments of this function. */\n+#define DECL_ARG_SLOT_COUNT(DECL) (DECL_LANG_SPECIFIC(DECL)->arg_slot_count)\n+/* Pointer to the function's COMPOUND_EXPR tree */\n+#define DECL_FUNCTION_BODY(DECL) (DECL_LANG_SPECIFIC(DECL)->function_decl_body)\n+\n+/* In a LABEL_DECL, a TREE_VEC that saves the type_map at that point. */\n+#define LABEL_TYPE_STATE(NODE) (DECL_INITIAL (NODE))\n+\n+/* In the label of a subroutine, a dummy label that records the\n+   state following a merge of all the ret instructions in this subroutine. */\n+#define LABEL_RETURN_LABEL(DECL) DECL_ARGUMENTS(DECL)\n+\n+/* In the label of a sub-routine, records the type state at return.\n+ * A local may be TYPE_UNUSED, which means that the local is not\n+ * used (stored to or loaded from) in this subroutine - at least for\n+ * code that we have verified so far. */\n+#define LABEL_RETURN_TYPE_STATE(NODE) LABEL_TYPE_STATE (LABEL_RETURN_LABEL (NODE))\n+\n+/* In a TREE_VEC for a LABEL_RETURN_TYPE_STATE, notes that\n+   TREE_VEC_LENGTH has been adjust to the correct stack size. */\n+#define RETURN_MAP_ADJUSTED(NODE) TREE_LANG_FLAG_2(NODE)\n+\n+/* In the label of a sub-routine, a chain of the return location labels. */\n+#define LABEL_RETURN_LABELS(node) DECL_RESULT (LABEL_RETURN_LABEL(node))\n+\n+/* In a LABEL_DECL, the next pending label.\n+   See pending_blocks in expr.c. */\n+#define LABEL_PENDING_CHAIN(NODE) DECL_RESULT(NODE)\n+\n+/* In a LABEL_DECL, the corresponding bytecode program counter. */\n+#define LABEL_PC(NODE) ((NODE)->decl.saved_insns.i)\n+\n+/* Used during verification to mark the label has \"changed\". (See JVM Spec). */\n+#define LABEL_CHANGED(NODE) DECL_LANG_FLAG_6(NODE)\n+\n+/* In a LABEL_DECL, true if we have verified instructions starting here. */\n+#define LABEL_VERIFIED(NODE) (instruction_bits[LABEL_PC(NODE)]&BCODE_VERIFIED)\n+\n+/* True if this code is within a subroutine (target of a jsr). */\n+#define LABEL_IN_SUBR(NODE) DECL_LANG_FLAG_4(NODE)\n+/* True if this code is the start of a subroutine (target of a jsr). */\n+#define LABEL_IS_SUBR_START(NODE) DECL_LANG_FLAG_5(NODE)\n+\n+/* In a LABEL_DECL, if LABEL_IN_SUBR(NODE), points to start of subroutine. */\n+#define LABEL_SUBR_START(NODE) DECL_ABSTRACT_ORIGIN(NODE)\n+\n+/* In a LABEL_DECL that has LABEL_IS_SUBR_START, this points to the start\n+   of surrounding subroutine in the case of a nested subroutine,\n+   and NULL_TREE otherwise. */\n+#define LABEL_SUBR_CONTEXT(NODE) DECL_CONTEXT (LABEL_RETURN_LABEL (NODE))\n+\n+/* The slot number for this local variable. */\n+#define DECL_LOCAL_SLOT_NUMBER(NODE) \\\n+  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->slot_number)\n+/* The start (bytecode) pc for the valid range of this local variable. */\n+#define DECL_LOCAL_START_PC(NODE) \\\n+  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->start_pc)\n+/* The end (bytecode) pc for the valid range of this local variable. */\n+#define DECL_LOCAL_END_PC(NODE) \\\n+  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->end_pc)\n+/* For a VAR_DECLor PARM_DECL, used to chain decls with the same\n+   slot_number in decl_map. */\n+#define DECL_LOCAL_SLOT_CHAIN(NODE) \\\n+  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->slot_chain)\n+\n+/* DECL_LANG_SPECIFIC for FUNCTION_DECLs. */\n+struct lang_decl\n+{\n+  /*  tree chain; not yet used. */\n+  long code_offset;\n+  int code_length;\n+  long linenumbers_offset;\n+  long localvariables_offset;\n+  int arg_slots;\n+  int max_locals, max_stack, arg_slot_count;\n+  tree function_decl_body;\t/* Hold all function's statements */\n+};\n+\n+/* DECL_LANG_SPECIFIC for VAR_DECL and PARM_DECL. */\n+struct lang_decl_var\n+{\n+  int slot_number;\n+  int start_pc;\n+  int end_pc;\n+  tree slot_chain;\n+};\n+\n+struct lang_type\n+{\n+  tree signature;\n+  struct JCF *jcf;\n+};\n+\n+#ifdef JAVA_USE_HANDLES\n+/* TYPE_BINFO_HANDLE points from a handle-class to its corresponding\n+   non-handle-class, and vice verse. */\n+\n+#define BINFO_HANDLE(NODE) TREE_VEC_ELT ((NODE), 6)\n+\n+/* Given a RECORD_TYPE for a handle type, return the corresponding class. */\n+#define HANDLE_TO_CLASS_TYPE(HTYPE) BINFO_HANDLE (TYPE_BINFO (HTYPE))\n+\n+/* Given a RECORD_TYPE for a class, return the corresponding handle type. */\n+#define CLASS_TO_HANDLE_TYPE(TYPE) BINFO_HANDLE (TYPE_BINFO (TYPE))\n+#else\n+#define HANDLE_TO_CLASS_TYPE(HTYPE) (HTYPE)\n+#define CLASS_TO_HANDLE_TYPE(TYPE) (TYPE)\n+#endif\n+\n+#define JCF_u4 unsigned long\n+#define JCF_u2 unsigned short\n+\n+extern tree lookup_class PROTO ((tree));\n+extern tree lookup_java_constructor PROTO ((tree, tree));\n+extern tree lookup_java_method PROTO ((tree, tree, tree));\n+extern tree lookup_argument_method PROTO ((tree, tree, tree));\n+extern tree promote_type PROTO ((tree));\n+extern tree get_constant PROTO ((struct JCF*, int));\n+extern tree get_name_constant PROTO ((struct JCF*, int));\n+extern tree get_class_constant PROTO ((struct JCF*, int));\n+extern tree parse_signature PROTO ((struct JCF *jcf, int sig_index));\n+extern int jcf_parse PROTO ((struct JCF*));\n+extern tree add_field PROTO ((tree, tree, tree, int));\n+extern tree add_method PROTO ((tree, int, tree, tree));\n+extern tree add_method_1 PROTO ((tree, int, tree, tree));\n+extern tree make_class ();\n+extern tree push_class PROTO ((tree, tree));\n+extern tree unmangle_classname PROTO ((const char *name, int name_length));\n+extern tree parse_signature_string PROTO ((const unsigned char *, int));\n+extern tree get_type_from_signature PROTO ((tree));\n+extern void layout_class PROTO ((tree));\n+extern tree make_class ();\n+extern tree build_class_ref PROTO ((tree));\n+extern tree build_dtable_decl PROTO ((tree));\n+extern tree build_internal_class_name PROTO ((tree));\n+extern tree build_constants_constructor ();\n+extern tree build_ref_from_constant_pool PROTO ((int));\n+extern tree build_utf8_ref PROTO ((tree));\n+extern tree ident_subst PROTO ((const char*, int,\n+\t\t\t\tconst char*, int, int, const char*));\n+extern tree identifier_subst PROTO ((const tree,\n+\t\t\t\t     const char *, int, int, const char *));\n+extern tree build_java_signature PROTO ((tree));\n+extern tree build_java_argument_signature PROTO ((tree));\n+extern void set_java_signature PROTO ((tree, tree));\n+extern tree build_static_field_ref PROTO ((tree));\n+extern tree build_address_of PROTO ((tree));\n+extern tree find_local_variable PROTO ((int index, tree type, int pc));\n+extern tree find_stack_slot PROTO ((int index, tree type));\n+extern tree build_prim_array_type PROTO ((tree, HOST_WIDE_INT));\n+extern tree build_java_array_type PROTO ((tree, HOST_WIDE_INT));\n+extern int is_compiled_class PROTO ((tree));\n+extern tree mangled_classname PROTO ((char*, tree));\n+extern tree lookup_label PROTO ((int));\n+extern tree pop_type PROTO ((tree));\n+extern void pop_argument_types PROTO ((tree));\n+extern tree decode_newarray_type PROTO ((int));\n+extern tree lookup_field PROTO ((tree*, tree));\n+extern int is_array_type_p PROTO ((tree));\n+extern HOST_WIDE_INT java_array_type_length PROTO ((tree));\n+extern void load_class PROTO ((tree, int));\n+\n+extern tree lookup_name PROTO ((tree));\n+extern tree build_known_method_ref PROTO ((tree, tree, tree, tree, tree));\n+extern tree build_class_init PROTO ((tree, tree));\n+extern tree build_invokevirtual PROTO ((tree, tree));\n+extern tree invoke_build_dtable PROTO ((int, tree));\n+extern tree match_java_method PROTO ((tree, tree, tree));\n+extern tree build_field_ref PROTO ((tree, tree, tree));\n+extern void pushdecl_force_head PROTO ((tree));\n+extern tree build_java_binop PROTO ((enum tree_code, tree, tree, tree));\n+extern tree binary_numeric_promotion PROTO ((tree, tree, tree *, tree *));\n+extern tree build_decl_no_layout PROTO ((enum tree_code, tree, tree));\n+extern tree build_java_arrayaccess PROTO ((tree, tree, tree));\n+extern tree build_newarray PROTO ((int, tree));\n+extern tree build_anewarray PROTO ((tree, tree));\n+extern tree build_java_array_length_access PROTO ((tree));\n+extern tree build_java_arraynull_check PROTO ((tree, tree, tree));\n+extern tree create_label_decl PROTO ((tree));\n+extern void push_labeled_block PROTO ((tree));\n+\n+/* Access flags etc for a method (a FUNCTION_DECL): */\n+\n+#define METHOD_PUBLIC(DECL) DECL_LANG_FLAG_1 (DECL)\n+#define METHOD_PRIVATE(DECL) TREE_PRIVATE (DECL)\n+#define METHOD_PROTECTED(DECL) TREE_PROTECTED (DECL)\n+#define METHOD_STATIC(DECL) DECL_LANG_FLAG_2 (DECL)\n+#define METHOD_FINAL(DECL) DECL_LANG_FLAG_3 (DECL)\n+#define METHOD_SYNCHRONIZED(DECL) DECL_LANG_FLAG_4 (DECL)\n+#define METHOD_NATIVE(DECL) DECL_EXTERNAL(DECL)\n+#define METHOD_ABSTRACT(DECL) DECL_LANG_FLAG_5 (DECL)\n+#define METHOD_TRANSIENT(DECL) DECL_LANG_FLAG_6 (DECL)\n+\n+#define DECL_CONSTRUCTOR_P(DECL) DECL_LANG_FLAG_7(DECL)\n+\n+/* Access flags etc for a variable/field (a FIELD_DECL): */\n+\n+#define FIELD_PRIVATE(DECL) TREE_PRIVATE (DECL)\n+#define FIELD_PROTECTED(DECL) TREE_PROTECTED (DECL)\n+#define FIELD_PUBLIC(DECL) DECL_LANG_FLAG_1 (DECL)\n+#define FIELD_STATIC(DECL) TREE_STATIC (DECL)\n+#define FIELD_FINAL(DECL) DECL_LANG_FLAG_3 (DECL)\n+#define FIELD_VOLATILE(DECL) DECL_LANG_FLAG_4 (DECL)\n+#define FIELD_TRANSIENT(DECL) DECL_LANG_FLAG_5 (DECL)\n+\n+/* Initialized flag on variable/field/parm decl */\n+\n+#define INITIALIZED_P(DECL) DECL_LANG_FLAG_6 (DECL)\n+\n+/* Access flags etc for a class (a TYPE_DECL): */\n+\n+#define CLASS_PUBLIC(DECL) DECL_LANG_FLAG_1 (DECL)\n+#define CLASS_FINAL(DECL) DECL_LANG_FLAG_3 (DECL)\n+#define CLASS_INTERFACE(DECL) DECL_LANG_FLAG_4 (DECL)\n+#define CLASS_ABSTRACT(DECL) DECL_LANG_FLAG_5 (DECL)\n+#define CLASS_SUPER(DECL) DECL_LANG_FLAG_6 (DECL)\n+\n+/* The number of virtual methods in this class's dispatch table.\n+ Does not include initial two dummy entries (one points to the\n+ Class object, and the other is for G++ -fvtable-thunks compatibility). */\n+#define TYPE_NVIRTUALS(TYPE) TYPE_BINFO_VIRTUALS (TYPE)\n+\n+/* A TREE_VEC (indexed by DECL_VINDEX) containing this class's\n+   virtual methods. */\n+#define TYPE_VTABLE(TYPE) TYPE_BINFO_VTABLE(TYPE)\n+\n+/* True of a RECORD_TYPE of a class/interface type (not array type) */\n+#define CLASS_P(TYPE) TYPE_LANG_FLAG_4 (TYPE)\n+/* Use CLASS_LOADED_P? FIXME */\n+#define CLASS_COMPLETE_P(DECL) DECL_LANG_FLAG_2 (DECL) \n+\n+/* This maps a bytecode offset (PC) to various flags,\n+   listed below (starting with BCODE_). */\n+extern char *instruction_bits;\n+\n+/* True iff the byte is the start of an instruction. */\n+#define BCODE_INSTRUCTION_START 1\n+\n+/* True iff there is a jump to this location. */\n+#define BCODE_JUMP_TARGET 2\n+\n+/* True iff there is a return to this location.\n+   (I.e. the preceedng instruction was a call.) */\n+#define BCODE_RETURN_TARGET 4\n+\n+/* True iff this is the start of an exception handler. */\n+#define BCODE_EXCEPTION_TARGET 16\n+\n+/* True iff there is a jump to this location (and it needs a label). */\n+#define BCODE_TARGET \\\n+  (BCODE_JUMP_TARGET|BCODE_RETURN_TARGET \\\n+   | BCODE_EXCEPTION_TARGET)\n+\n+/* True iff there is an entry in the linenumber table for this location. */\n+#define BCODE_HAS_LINENUMBER 32\n+\n+/* True iff there is more than one entry in the linenumber table for\n+   this location.  (This probably does not make much sense.)  */\n+#define BCODE_HAS_MULTI_LINENUMBERS 64\n+\n+/* True if this instruction has been verified. */\n+#define BCODE_VERIFIED 8\n+\n+/* A pointer to the line number table of the current method. */\n+extern unsigned char *linenumber_table;\n+/* The length (in items) of the line number table. */\n+extern int linenumber_count;\n+\n+/* In type_map, means that slot is uninitialized or otherwise unusable. */\n+#define TYPE_UNKNOWN NULL_TREE\n+\n+/* In type_map, means the second half of a 64-bit double or long. */\n+#define TYPE_SECOND void_type_node\n+\n+/* In type_map, means the null type (i.e. type of a null reference). */ \n+#define TYPE_NULL ptr_type_node\n+\n+/* In a type map means the type the address subroutine return address. */\n+#define TYPE_RETURN_ADDR return_address_type_node\n+\n+/* In a subroutine's return type map, indicates that the slot was neither\n+   used nor set in the subroutine. */\n+#define TYPE_UNUSED error_mark_node\n+\n+/* A array mapping variable/stack slot index to the type current\n+   in that variable/stack slot.\n+   TYPE_UNKNOWN, TYPE_SECOND, and TYPE_NULL are special cases. */\n+extern tree *type_map;\n+\n+/* Map a stack index to the type currently in that slot. */\n+#define stack_type_map (type_map+DECL_MAX_LOCALS(current_function_decl))\n+\n+/* True iff TYPE takes two variable/stack slots. */\n+#define TYPE_IS_WIDE(TYPE) \\\n+  ((TYPE) == double_type_node || (TYPE) == long_type_node)\n+\n+/* True iff TYPE is a Java array type. */\n+#define TYPE_ARRAY_P(TYPE) TYPE_LANG_FLAG_1 (TYPE)\n+\n+/* If FUNCTION_TYPE or METHOD_TYPE: cache for build_java_argument_signature. */\n+#define TYPE_ARGUMENT_SIGNATURE(TYPE) TYPE_VFIELD(TYPE)\n+\n+/* Given an array type, give the type of the elements. */\n+/* FIXME this use of TREE_TYPE conflicts with something or other. */\n+#define TYPE_ARRAY_ELEMENT(ATYPE) TREE_TYPE(ATYPE)\n+\n+/* True if class TYPE has been loaded. */\n+#define CLASS_LOADED_P(TYPE) TYPE_LANG_FLAG_2 (TYPE)\n+\n+/* True if class TYPE was defined in Java source code. */\n+#define CLASS_FROM_SOURCE_P(TYPE) TYPE_LANG_FLAG_3 (TYPE)\n+\n+/* True if identifier ID was seen while processing a single type import stmt */\n+#define IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P(ID) TREE_LANG_FLAG_0 (ID)\n+\n+/* True if identifier ID was seen while processing an import statement */\n+#define IS_A_CLASSFILE_NAME(ID) TREE_LANG_FLAG_1 (ID)\n+\n+/* True if ID is a qualified named (contains . or /) */\n+#define QUALIFIED_P(ID) TREE_LANG_FLAG_2 (ID)\n+\n+/* True if ID is an already processed import on demand */\n+#define IS_AN_IMPORT_ON_DEMAND_P(ID) TREE_LANG_FLAG_3 (ID)\n+\n+/* True if EXPR is RHS sub-tree of a compound assign expression */\n+#define COMPOUND_ASSIGN_P(EXPR) TREE_LANG_FLAG_1 (EXPR)\n+\n+/* True if EXPR (a WFL in that case) was created after the\n+   reduction of PRIMARY . XXX */\n+#define PRIMARY_P(EXPR) TREE_LANG_FLAG_2 (EXPR)\n+\n+/* True if EXPR (a MODIFY_EXPR in that case) is the result of variable\n+   initialization during its declaration */\n+#define MODIFY_EXPR_FROM_INITIALIZATION_P(EXPR) TREE_LANG_FLAG_2 (EXPR)\n+\n+/* True if EXPR (a WFL in that case) resolves into an expression name */\n+#define RESOLVE_EXPRESSION_NAME_P(WFL) TREE_LANG_FLAG_0 (WFL)\n+\n+/* True if EXPR (a LOOP_EXPR in that case) is part of a for statement */\n+#define IS_FOR_LOOP_P(EXPR) TREE_LANG_FLAG_0 (EXPR)\n+\n+/* True if EXPR (a WFL in that case) resolves into a package name */\n+#define RESOLVE_PACKAGE_NAME_P(WFL) TREE_LANG_FLAG_3 (WFL)\n+\n+/* True if EXPR (a WFL in that case) resolves into a type name */\n+#define RESOLVE_TYPE_NAME_P(WFL) TREE_LANG_FLAG_4 (WFL)\n+\n+/* True if STMT (a WFL in that case) holds a BREAK statement */\n+#define IS_BREAK_STMT_P(WFL) TREE_LANG_FLAG_5 (WFL)\n+\n+/* Add a FIELD_DECL to RECORD_TYPE RTYPE.\n+   The field has name NAME (a char*), and type FTYPE.\n+   Unless this is the first field, FIELD most hold the previous field.\n+   FIELD is set to the newly created FIELD_DECL.\n+\n+   We set DECL_ARTIFICIAL so these fields get skipped by make_class_data\n+   if compiling java.lang.Object or java.lang.Class. */\n+\n+#define PUSH_FIELD(RTYPE, FIELD, NAME, FTYPE) \\\n+{ tree tmp_field = build_decl (FIELD_DECL, get_identifier(NAME), FTYPE); \\\n+  if (TYPE_FIELDS (RTYPE) == NULL_TREE) TYPE_FIELDS (RTYPE) = tmp_field; \\\n+  else TREE_CHAIN(FIELD) = tmp_field; \\\n+  DECL_CONTEXT (tmp_field) = RTYPE; \\\n+  DECL_ARTIFICIAL (tmp_field) = 1; \\\n+  FIELD = tmp_field; }\n+\n+#define FINISH_RECORD(RTYPE) layout_type (RTYPE)\n+\n+/* Start building a RECORD_TYPE constructor with a given TYPE in CONS. */\n+#define START_RECORD_CONSTRUCTOR(CONS, CTYPE) { \\\n+  CONS = build (CONSTRUCTOR, CTYPE, NULL_TREE, NULL_TREE);\\\n+  TREE_CHAIN(CONS) = TYPE_FIELDS (CTYPE); }\n+\n+/* Append a field initializer to CONS for the dummy field for the inherited\n+   fields.  The dummy field has the given VALUE, and the same type as the\n+   super-class.   Must be specified before calls to PUSH_FIELD_VALUE. */\n+\n+#define PUSH_SUPER_VALUE(CONS, VALUE) {\\\n+  tree field = TREE_CHAIN(CONS);\\\n+  if (DECL_NAME (field) != NULL_TREE) abort();\\\n+  CONSTRUCTOR_ELTS(CONS) = tree_cons (field, VALUE, CONSTRUCTOR_ELTS(CONS));\\\n+  TREE_CHAIN(CONS) = TREE_CHAIN (field); }\n+\n+/* Append a field initializer to CONS for a field with the given VALUE.\n+   NAME is a char* string used for error checking;\n+   the initializer must be specified in order. */\n+#define PUSH_FIELD_VALUE(CONS, NAME, VALUE) {\\\n+  tree field = TREE_CHAIN(CONS);\\\n+  if (strcmp (IDENTIFIER_POINTER (DECL_NAME (field)), NAME) != 0) abort();\\\n+  CONSTRUCTOR_ELTS(CONS) = tree_cons (field, VALUE, CONSTRUCTOR_ELTS(CONS));\\\n+  TREE_CHAIN(CONS) = TREE_CHAIN (field); }\n+\n+/* Finish creating a record CONSTRUCTOR CONS. */\n+#define FINISH_RECORD_CONSTRUCTOR(CONS) \\\n+  CONSTRUCTOR_ELTS(CONS) = nreverse (CONSTRUCTOR_ELTS(CONS))\n+\n+/* New tree code for expression, so we can expand then individually. */\n+#define JAVA_UNARY_PLUS_EXPR ((int)LAST_AND_UNUSED_TREE_CODE + 2)\n+#define JAVA_NEW_ARRAY_EXPR  ((int)LAST_AND_UNUSED_TREE_CODE + 3)\n+#define JAVA_NEW_CLASS_EXPR  ((int)LAST_AND_UNUSED_TREE_CODE + 4)\n+#define JAVA_THIS_EXPR       ((int)LAST_AND_UNUSED_TREE_CODE + 5)\n+\n+/* Macro(s) using the definitions above */\n+#define CALL_CONSTRUCTOR_P(NODE) (TREE_CODE (NODE) == JAVA_NEW_CLASS_EXPR)\n+"}, {"sha": "a722a8b69f9c4922970293ca064454d3e912ef29", "filename": "gcc/java/javaop.def", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjavaop.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjavaop.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjavaop.def?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,314 @@\n+/* Table of opcodes for byte codes defined by the Java(TM) virtual\n+   machine specification.\t\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.\n+\n+Written by Per Bothner <bothner@cygnus.com>, February 1996.\n+*/\n+\n+/* JAVAOP (OPNAME, OPCODE, OPKIND, OPERAND_TYPE, OPERAND_VALUE), where:\n+\tOPNAME is the name of the opcode.\n+\tOPCODE is the 1-byte opcode value.\n+\tOPKIND is the kind of operation.\n+\tOPERAND_TYPE is the type operands affected.\n+\tOPERAND_VALUE tells where to get the value.  (Its meaning\n+\t  depends on OPKIND.) */\n+\n+/* Various macro used in OPERAND_VALUE:\n+IMMEDIATE_s1:  An immediate signed 1-byte value in the byte-code stream.\n+IMMEDIATE_s2:  An immediate signed 2-byte value in the byte-code stream.\n+IMMEDIATE_u1:  An immediate unsigned 1-byte value in the byte-code stream.\n+IMMEDIATE_u2:  An immediate unsigned 2-byte value in the byte-code stream.\n+\n+CONST_INDEX_1:  An immediate unsigned 1-byte index into the constant pool.\n+CONST_INDEX_2:  An immediate unsigned 2-byte index into the constant pool.\n+*/\n+\n+/* More specifically, this is the meaning of the various OPKINDs:\n+\n+BINOP:\tbinary operation\n+\tOPERAND_TYPE is the argument type.\n+\tOPERAND_VALUE is PLUS, MINUS, MULT, TRUNC_DIV, RDIV, REM,\n+\t  LSHIFT, RSHIFT, URSHIFT, BIT_AND, BIT_IOR, BIT_XOR,\n+\t  COMPARE, COMPARE_L, or COMPARE_G.\n+\n+UNOP:\tunary operation\n+\tOPERAND_TYPE is the argument type.\n+\tOPERAND_VALUE is NEG.\n+\n+INVOKE: invoke operations\n+\tOPERAND_TYPE is VIRTUAL, SPECIAL, STATIC, or INTERFACE.\n+\tOPERAND_VALUE is 1 if interface, 0 otherwise.\n+\n+OBJECT:\tnew, checkcast, instanceof\n+\tOPERAND_TYPE is PTR.\n+\tOPERAND_VALUE is NEW, CHECKCAST, or INSTANCEOF.\n+\n+BRANCH: branch operations\n+\tOPERAND_TYPE is GOTO, CALL, or RETURN.\n+\tOPERAND_VALUE is IMMEDIATE_s2, VAR_INDEX_1, IMMEDIATE_s4,\n+\t  or VAR_INDEX_2.\n+\n+STACK:  Various stack operations.\n+\n+PUSHC:  Push a constant onto the operand stack.\n+\tOPERAND_VALUE maybe be the value to push,\n+\tor IMMEDIATE_s1 or IMMEDIATE_s2 if the constant is immediate,\n+\tor CONST_INDEX_1 or CONST_INDEX_2 for a constant pool index.\n+\n+LOAD: Push a value from a local variable onto the operand stack.\n+\tOPERAND_VALUE is the index of the local variable in the current\n+\tJava frame.  It can be a literal, or IMMEDIATE_i2.\n+\n+CONVERT: Convert top of stack value from one type to another.\n+\tOPERAND_TYPE is the argument type.\n+\tOPERAND_VALUE is the result type.\n+\n+TEST: Compares an integer (popped from the stack) against zero.\n+\tIf the test (in OPERAND_VALUE) is true, goto a relative\n+\toffset given by the next two bytes.\n+\n+COND:  Compares two values (popped from the stack) againt each other.\n+\tIf the test (in OPERAND_VALUE) is true, goto a relative\n+\toffset given by the next two bytes.\n+\n+SWITCH:\n+\tOPERAND_VALUE is either TABLE or LOOKUP.\n+\n+ARRAY:\n+\tOPERAND_VALUE is LOAD, STORE, LENGTH, or NEW.\n+\n+FIELD: Extracts from or stores into a field.\n+\tOPERAND_TYPE is 1 for a static field, 0 for a regular field.\n+\tOPERAND_VALUE is 1 for a put operation, 0 for a get operation.\n+\n+SPECIAL:\n+\tRandom bunch of opcodes.\n+\n+*/\n+\n+JAVAOP (nop,             0, STACK,   POP,    0)\n+JAVAOP (aconst_null,     1, PUSHC,   PTR,    0)\n+JAVAOP (iconst_m1,       2, PUSHC,   INT,    -1)\n+JAVAOP (iconst_0,        3, PUSHC,   INT,    0)\n+JAVAOP (iconst_1,        4, PUSHC,   INT,    1)\n+JAVAOP (iconst_2,        5, PUSHC,   INT,    2)\n+JAVAOP (iconst_3,        6, PUSHC,   INT,    3)\n+JAVAOP (iconst_4,        7, PUSHC,   INT,    4)\n+JAVAOP (iconst_5,        8, PUSHC,   INT,    5)\n+JAVAOP (lconst_0,        9, PUSHC,   LONG,   0)\n+JAVAOP (lconst_1,       10, PUSHC,   LONG,   1)\n+JAVAOP (fconst_0,       11, PUSHC,   FLOAT,  0)\n+JAVAOP (fconst_1,       12, PUSHC,   FLOAT,  1)\n+JAVAOP (fconst_2,       13, PUSHC,   FLOAT,  2)\n+JAVAOP (dconst_0,       14, PUSHC,   DOUBLE, 0)\n+JAVAOP (dconst_1,       15, PUSHC,   DOUBLE, 1)\n+JAVAOP (bipush,         16, PUSHC,   INT,    IMMEDIATE_s1)\n+JAVAOP (sipush,         17, PUSHC,   INT,    IMMEDIATE_s2)\n+JAVAOP (ldc,            18, PUSHC,   INT,    CONST_INDEX_1)\n+JAVAOP (ldc_w,          19, PUSHC,   INT,    CONST_INDEX_2)\n+JAVAOP (ldc2_w,         20, PUSHC,   LONG,   CONST_INDEX_2)\n+JAVAOP (iload,          21, LOAD,    INT,    IMMEDIATE_u1)\n+JAVAOP (lload,          22, LOAD,    LONG,   IMMEDIATE_u1)\n+JAVAOP (fload,          23, LOAD,    FLOAT,  IMMEDIATE_u1)\n+JAVAOP (dload,          24, LOAD,    DOUBLE, IMMEDIATE_u1)\n+JAVAOP (aload,          25, LOAD,    PTR,    IMMEDIATE_u1)\n+JAVAOP (iload_0,        26, LOAD,    INT,    0)\n+JAVAOP (iload_1,        27, LOAD,    INT,    1)\n+JAVAOP (iload_2,        28, LOAD,    INT,    2)\n+JAVAOP (iload_3,        29, LOAD,    INT,    3)\n+JAVAOP (lload_0,        30, LOAD,    LONG,   0)\n+JAVAOP (lload_1,        31, LOAD,    LONG,   1)\n+JAVAOP (lload_2,        32, LOAD,    LONG,   2)\n+JAVAOP (lload_3,        33, LOAD,    LONG,   3)\n+JAVAOP (fload_0,        34, LOAD,    FLOAT,  0)\n+JAVAOP (fload_1,        35, LOAD,    FLOAT,  1)\n+JAVAOP (fload_2,        36, LOAD,    FLOAT,  2)\n+JAVAOP (fload_3,        37, LOAD,    FLOAT,  3)\n+JAVAOP (dload_0,        38, LOAD,    DOUBLE, 0)\n+JAVAOP (dload_1,        39, LOAD,    DOUBLE, 1)\n+JAVAOP (dload_2,        40, LOAD,    DOUBLE, 2)\n+JAVAOP (dload_3,        41, LOAD,    DOUBLE, 3)\n+JAVAOP (aload_0,        42, LOAD,    PTR,    0)\n+JAVAOP (aload_1,        43, LOAD,    PTR,    1)\n+JAVAOP (aload_2,        44, LOAD,    PTR,    2)\n+JAVAOP (aload_3,        45, LOAD,    PTR,    3)\n+JAVAOP (iaload,         46, ARRAY,   INT,    LOAD)\n+JAVAOP (laload,         47, ARRAY,   LONG,   LOAD)\n+JAVAOP (faload,         48, ARRAY,   FLOAT,  LOAD)\n+JAVAOP (daload,         49, ARRAY,   DOUBLE, LOAD)\n+JAVAOP (aaload,         50, ARRAY,   PTR,    LOAD)\n+JAVAOP (baload,         51, ARRAY,   BYTE,   LOAD)\n+JAVAOP (caload,         52, ARRAY,   CHAR,   LOAD)\n+JAVAOP (saload,         53, ARRAY,   SHORT,  LOAD)\n+JAVAOP (istore,         54, STORE,   INT,    IMMEDIATE_u1)\n+JAVAOP (lstore,         55, STORE,   LONG,   IMMEDIATE_u1)\n+JAVAOP (fstore,         56, STORE,   FLOAT,  IMMEDIATE_u1)\n+JAVAOP (dstore,         57, STORE,   DOUBLE, IMMEDIATE_u1)\n+JAVAOP (astore,         58, STORE,   PTR,    IMMEDIATE_u1)\n+JAVAOP (istore_0,       59, STORE,   INT,    0)\n+JAVAOP (istore_1,       60, STORE,   INT,    1)\n+JAVAOP (istore_2,       61, STORE,   INT,    2)\n+JAVAOP (istore_3,       62, STORE,   INT,    3)\n+JAVAOP (lstore_0,       63, STORE,   LONG,   0)\n+JAVAOP (lstore_1,       64, STORE,   LONG,   1)\n+JAVAOP (lstore_2,       65, STORE,   LONG,   2)\n+JAVAOP (lstore_3,       66, STORE,   LONG,   3)\n+JAVAOP (fstore_0,       67, STORE,   FLOAT,  0)\n+JAVAOP (fstore_1,       68, STORE,   FLOAT,  1)\n+JAVAOP (fstore_2,       69, STORE,   FLOAT,  2)\n+JAVAOP (fstore_3,       70, STORE,   FLOAT,  3)\n+JAVAOP (dstore_0,       71, STORE,   DOUBLE, 0)\n+JAVAOP (dstore_1,       72, STORE,   DOUBLE, 1)\n+JAVAOP (dstore_2,       73, STORE,   DOUBLE, 2)\n+JAVAOP (dstore_3,       74, STORE,   DOUBLE, 3)\n+JAVAOP (astore_0,       75, STORE,   PTR,    0)\n+JAVAOP (astore_1,       76, STORE,   PTR,    1)\n+JAVAOP (astore_2,       77, STORE,   PTR,    2)\n+JAVAOP (astore_3,       78, STORE,   PTR,    3)\n+JAVAOP (iastore,        79, ARRAY,   INT,    STORE)\n+JAVAOP (lastore,        80, ARRAY,   LONG,   STORE)\n+JAVAOP (fastore,        81, ARRAY,   FLOAT,  STORE)\n+JAVAOP (dastore,        82, ARRAY,   DOUBLE, STORE)\n+JAVAOP (aastore,        83, ARRAY,   PTR,    STORE)\n+JAVAOP (bastore,        84, ARRAY,   BYTE,   STORE)\n+JAVAOP (castore,        85, ARRAY,   CHAR,   STORE)\n+JAVAOP (sastore,        86, ARRAY,   SHORT,  STORE)\n+JAVAOP (pop,            87, STACK,   POP,    1)\n+JAVAOP (pop2,           88, STACK,   POP,    2)\n+JAVAOP (dup,            89, STACK,   DUP,    1)\n+JAVAOP (dup_x1,         90, STACK,   DUPx1,  1)\n+JAVAOP (dup_x2,         91, STACK,   DUPx2,  1)\n+JAVAOP (dup2,           92, STACK,   DUP,    2)\n+JAVAOP (dup2_x1,        93, STACK,   DUPx1,  2)\n+JAVAOP (dup2_x2,        94, STACK,   DUPx2,  2)\n+JAVAOP (swap,           95, STACK,   SWAP,   0)\n+JAVAOP (iadd,           96, BINOP,   INT,    PLUS)\n+JAVAOP (ladd,           97, BINOP,   LONG,   PLUS)\n+JAVAOP (fadd,           98, BINOP,   FLOAT,  PLUS)\n+JAVAOP (dadd,           99, BINOP,   DOUBLE, PLUS)\n+JAVAOP (isub,          100, BINOP,   INT,    MINUS)\n+JAVAOP (lsub,          101, BINOP,   LONG,   MINUS)\n+JAVAOP (fsub,          102, BINOP,   FLOAT,  MINUS)\n+JAVAOP (dsub,          103, BINOP,   DOUBLE, MINUS)\n+JAVAOP (imul,          104, BINOP,   INT,    MULT)\n+JAVAOP (lmul,          105, BINOP,   LONG,   MULT)\n+JAVAOP (fmul,          106, BINOP,   FLOAT,  MULT)\n+JAVAOP (dmul,          107, BINOP,   DOUBLE, MULT)\n+JAVAOP (idiv,          108, BINOP,   INT,    TRUNC_DIV)\n+JAVAOP (ldiv,          109, BINOP,   LONG,   TRUNC_DIV)\n+JAVAOP (fdiv,          110, BINOP,   FLOAT,  RDIV)\n+JAVAOP (ddiv,          111, BINOP,   DOUBLE, RDIV)\n+JAVAOP (irem,          112, BINOP,   INT,    REM)\n+JAVAOP (lrem,          113, BINOP,   LONG,   REM)\n+JAVAOP (frem,          114, BINOP,   FLOAT,  REM)\n+JAVAOP (drem,          115, BINOP,   DOUBLE, REM)\n+JAVAOP (ineg,          116, UNOP,    INT,    NEG)\n+JAVAOP (lneg,          117, UNOP,    LONG,   NEG)\n+JAVAOP (fneg,          118, UNOP,    FLOAT,  NEG)\n+JAVAOP (dneg,          119, UNOP,    DOUBLE, NEG)\n+JAVAOP (ishl,          120, BINOP,   INT,    LSHIFT)\n+JAVAOP (lshl,          121, BINOP,   LONG,   LSHIFT)\n+JAVAOP (ishr,          122, BINOP,   INT,    RSHIFT)\n+JAVAOP (lshr,          123, BINOP,   LONG,   RSHIFT)\n+JAVAOP (iushr,         124, BINOP,   INT,    URSHIFT)\n+JAVAOP (lushr,         125, BINOP,   LONG,   URSHIFT)\n+JAVAOP (iand,          126, BINOP,   INT,    BIT_AND)\n+JAVAOP (land,          127, BINOP,   LONG,   BIT_AND)\n+JAVAOP (ior,           128, BINOP,   INT,    BIT_IOR)\n+JAVAOP (lor,           129, BINOP,   LONG,   BIT_IOR)\n+JAVAOP (ixor,          130, BINOP,   INT,    BIT_XOR)\n+JAVAOP (lxor,          131, BINOP,   LONG,   BIT_XOR)\n+JAVAOP (iinc,          132, SPECIAL, INT,    IINC)\n+JAVAOP (i2l,           133, CONVERT, INT,    LONG)\n+JAVAOP (i2f,           134, CONVERT, INT,    FLOAT)\n+JAVAOP (i2d,           135, CONVERT, INT,    DOUBLE)\n+JAVAOP (l2i,           136, CONVERT, LONG,   INT)\n+JAVAOP (l2f,           137, CONVERT, LONG,   FLOAT)\n+JAVAOP (l2d,           138, CONVERT, LONG,   DOUBLE)\n+JAVAOP (f2i,           139, CONVERT, FLOAT,  INT)\n+JAVAOP (f2l,           140, CONVERT, FLOAT,  LONG)\n+JAVAOP (f2d,           141, CONVERT, FLOAT,  DOUBLE)\n+JAVAOP (d2i,           142, CONVERT, DOUBLE, INT)\n+JAVAOP (d2l,           143, CONVERT, DOUBLE, LONG)\n+JAVAOP (d2f,           144, CONVERT, DOUBLE, FLOAT)\n+JAVAOP (i2b,\t       145, CONVERT2, INT,    BYTE)\n+JAVAOP (i2c,           146, CONVERT2, INT,    CHAR)\n+JAVAOP (i2s,           147, CONVERT2, INT,    SHORT)\n+JAVAOP (lcmp,          148, BINOP,   LONG,   COMPARE)\n+JAVAOP (fcmpl,         149, BINOP,   FLOAT,  COMPARE_L)\n+JAVAOP (fcmpg,         150, BINOP,   FLOAT,  COMPARE_G)\n+JAVAOP (dcmpl,         151, BINOP,   DOUBLE, COMPARE_L)\n+JAVAOP (dcmpg,         152, BINOP,   DOUBLE, COMPARE_G)\n+JAVAOP (ifeq,          153, TEST,    INT,    EQ)\n+JAVAOP (ifne,          154, TEST,    INT,    NE)\n+JAVAOP (iflt,          155, TEST,    INT,    LT)\n+JAVAOP (ifge,          156, TEST,    INT,    GE)\n+JAVAOP (ifgt,          157, TEST,    INT,    GT)\n+JAVAOP (ifle,          158, TEST,    INT,    LE)\n+JAVAOP (if_icmpeq,     159, COND,    INT,    EQ)\n+JAVAOP (if_icmpne,     160, COND,    INT,    NE)\n+JAVAOP (if_icmplt,     161, COND,    INT,    LT)\n+JAVAOP (if_icmpge,     162, COND,    INT,    GE)\n+JAVAOP (if_icmpgt,     163, COND,    INT,    GT)\n+JAVAOP (if_icmple,     164, COND,    INT,    LE)\n+JAVAOP (if_acmpeq,     165, COND,    PTR,    EQ)\n+JAVAOP (if_acmpne,     166, COND,    PTR,    NE)\n+JAVAOP (goto,          167, BRANCH,  GOTO,   IMMEDIATE_s2)\n+JAVAOP (jsr,           168, JSR,     CALL,   IMMEDIATE_s2)\n+JAVAOP (ret,           169, RET,     RETURN, VAR_INDEX_1)\n+JAVAOP (tableswitch,   170, SWITCH,  INT,    TABLE)\n+JAVAOP (lookupswitch,  171, SWITCH,  INT,    LOOKUP)\n+JAVAOP (ireturn,       172, RETURN,  INT,    0)\n+JAVAOP (lreturn,       173, RETURN,  LONG,   0)\n+JAVAOP (freturn,       174, RETURN,  FLOAT,  0)\n+JAVAOP (dreturn,       175, RETURN,  DOUBLE, 0)\n+JAVAOP (areturn,       176, RETURN,  PTR,    0)\n+JAVAOP (return,        177, RETURN,  VOID,   0)\n+JAVAOP (getstatic,     178, FIELD,   1,      0)\n+JAVAOP (putstatic,     179, FIELD,   1,      1)\n+JAVAOP (getfield,      180, FIELD,   0,      0)\n+JAVAOP (putfield,      181, FIELD,   0,      1)\n+JAVAOP (invokevirtual, 182, INVOKE,  VIRTUAL,0)\n+JAVAOP (invokespecial, 183, INVOKE,  SPECIAL, 0)\n+JAVAOP (invokestatic,  184, INVOKE,  STATIC, 0)\n+JAVAOP (invokeinterface,185, INVOKE, INTERFACE, 1)\n+JAVAOP (new,           187, OBJECT,  PTR,    NEW)\n+JAVAOP (newarray,      188, ARRAY,   NUM,    NEW)\n+JAVAOP (anewarray,     189, ARRAY,   PTR,    NEW)\n+JAVAOP (arraylength,   190, ARRAY,   INT,    LENGTH)\n+JAVAOP (athrow,        191, SPECIAL, ANY,    THROW)\n+JAVAOP (checkcast,     192, OBJECT,  PTR,    CHECKCAST)\n+JAVAOP (instanceof,    193, OBJECT,  PTR,    INSTANCEOF)\n+JAVAOP (monitorenter,  194, SPECIAL, MONITOR, ENTER)\n+JAVAOP (monitorexit,   195, SPECIAL, MONITOR, EXIT)\n+JAVAOP (wide,          196, SPECIAL, ANY,    WIDE)\n+JAVAOP (multianewarray,197, ARRAY,   MULTI,  NEW)\n+JAVAOP (ifnull,        198, TEST,    PTR,    EQ)\n+JAVAOP (ifnonnull,     199, TEST,    PTR,    NE)\n+JAVAOP (goto_w,        200, BRANCH,  GOTO,   IMMEDIATE_s4)\n+JAVAOP (jsr_w,         201, JSR,     CALL,   IMMEDIATE_s4)\n+JAVAOP (breakpoint,    202, SPECIAL, ANY,    BREAK)\n+JAVAOP (ret_w,         209, RET,     RETURN, VAR_INDEX_2)\n+JAVAOP (impdep1,       254, IMPL,    ANY,    1)\n+JAVAOP (impdep2,       255, IMPL,    ANY,    2)"}, {"sha": "f4ae05006be0017454e8c2c4995bf882caea6bb7", "filename": "gcc/java/javaop.h", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjavaop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjavaop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjavaop.h?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,142 @@\n+/* Utility macros to handle Java(TM) byte codes.\n+\n+   Copyright (C) 1996  Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Written by Per Bothner <bothner@cygnus.com>, February 1996. */\n+\n+#ifndef JAVAOP_H\n+#define JAVAOP_H\n+\n+typedef\tchar\t\tint8;\n+typedef\tunsigned char\tuint8;\n+#ifndef int16\n+#define int16 short\n+#endif\n+typedef unsigned int16\tuint16;\n+\n+#ifndef int32\n+#define int32 long\n+#endif\n+typedef unsigned int32\tuint32;\n+\n+/* A signed 64-bit (or more) integral type, suiteable for Java's 'long'. */\n+#ifndef int64\n+#define int64 long long\n+#endif\n+/* An unsigned 64-bit (or more) integral type, same length as int64. */\n+#ifndef uint64\n+#define uint64 unsigned int64\n+#endif\n+\n+typedef uint16\t\t\tjchar;\n+typedef int8\t\t\tjbyte;\n+typedef int16                   jshort;\n+typedef int32                   jint;\n+typedef int64                   jlong;\n+typedef void*                   jref;\n+\n+/* A 32-bit IEEE single-precision float. */\n+#ifndef jfloat \n+#define jfloat float\n+#endif\n+\n+/* A 32-bit IEEE double-precision float. */\n+#ifndef jdouble\n+#define jdouble double\n+#endif\n+\n+union Word {\n+  jint i;\n+  jfloat f;\n+  void *p;\n+};\n+\n+/* A jword is an unsigned integral type big enough for a 32-bit jint\n+   or jfloat *or* a pointer.  It is the type appropriate for stack\n+   locations and local variables in a Java interpreter. */\n+\n+\n+#ifndef jword\n+#define jword uint32\n+#endif\n+\n+#if !defined(inline) && !defined(__GC__) && !defined(__cplusplus)\n+#define inline static\n+#endif\n+\n+#ifndef IMMEDIATE_u1\n+#define IMMEDIATE_u1 (PC++, CHECK_PC_IN_RANGE(PC), BCODE[PC-1])\n+#endif\n+#ifndef IMMEDIATE_s1\n+#define IMMEDIATE_s1 (PC++, CHECK_PC_IN_RANGE(PC), (signed char)BCODE[PC-1])\n+#endif\n+#ifndef IMMEDIATE_s2\n+#define IMMEDIATE_s2 (PC+=2, CHECK_PC_IN_RANGE(PC), \\\n+  (signed char) BCODE[PC-2] * 256 + BCODE[PC-1])\n+#endif\n+#ifndef IMMEDIATE_u2\n+#define IMMEDIATE_u2 (PC+=2, CHECK_PC_IN_RANGE(PC),\\\n+  (BCODE[PC-2] * 256 + BCODE[PC-1]))\n+#endif\n+#ifndef IMMEDIATE_s4\n+#define IMMEDIATE_s4 (PC+=4, CHECK_PC_IN_RANGE(PC), \\\n+  ((jint)((BCODE[PC-4] << 24) | (BCODE[PC-3] << 16) \\\n+         | (BCODE[PC-2] << 8) | (BCODE[PC-1]))))\n+#endif\n+\n+inline jfloat\n+WORD_TO_FLOAT(jword w)\n+{ union Word wu;\n+  wu.i = w;\n+  return wu.f;\n+} \n+\n+inline jlong\n+WORDS_TO_LONG(jword hi, jword lo)\n+{\n+  return ((jlong) hi << 32) | ((jlong)lo & (((jlong)1 << 32) -1));\n+}\n+\n+union DWord {\n+  jdouble d;\n+  jlong l;\n+  jword w[2];\n+};\n+\n+inline jdouble\n+WORDS_TO_DOUBLE(jword hi, jword lo)\n+{ union DWord wu;\n+  wu.l = WORDS_TO_LONG(hi, lo);\n+  return wu.d;\n+} \n+\n+/* If PREFIX_CHAR is the first character of the Utf8 encoding of a character,\n+   return the number of bytes taken by the encoding.\n+   Return -1 for a continuation character.  */\n+#define UT8_CHAR_LENGTH(PREFIX_CHAR) \\\n+  ((unsigned char)(PREFIX_CHAR) < 128 ? 1 \\\n+   : ((PREFIX_CHAR) & 0x40) == 0 ? -1 \\\n+   : ((PREFIX_CHAR) & 0x20) == 0 ? 2 \\\n+   : ((PREFIX_CHAR) & 0x10) == 0 ? 3 \\\n+   : ((PREFIX_CHAR) & 0x08) == 0 ? 4 : 5)\n+\n+#endif /* !JAVAOP_H */"}, {"sha": "749aa82146f2300269d72acc2ec62c8460f9891a", "filename": "gcc/java/jcf-dump.c", "status": "added", "additions": 1072, "deletions": 0, "changes": 1072, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjcf-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjcf-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-dump.c?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,1072 @@\n+/* Program to dump out a Java(TM) .class file.\n+   Functionally similar to Sun's javap.\n+\n+   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Written by Per Bothner <bothner@cygnus.com>, February 1996. */\n+\n+/*\n+  jcf-dump is a program to print out the contents of class files.\n+  Usage:  jcf-dump [FLAGS] CLASS\n+  Each CLASS is either:\n+  + the name of a class in the CLASSPATH (e.g \"java.lang.String\"), or\n+  + the name of a class *file* (e.g. \"/home/me/work/package/Foo.class\").\n+  + The name of a .zip or .jar file (which prints all the classes in the\n+  archive).\n+\n+  OPTIONS:\n+  -c\n+\tDis-assemble each method.\n+  -classpath PATH\n+\tOverrides $CLASSPATH.\n+  --print-main\n+\tPrint nothing if there is no valid \"main\" method;\n+\totherwise, print only the class name.\n+  --javap\n+\tPrint output in the style of Sun's javap program.  VERY UNFINISHED.\n+ */\n+    \n+\n+#include <stdio.h>\n+#include \"jcf.h\"\n+\n+/* Outout file. */\n+FILE *out;\n+/* Name of output file, if NULL if stdout. */\n+char *output_file = NULL;\n+\n+int verbose = 0;\n+\n+int flag_disassemble_methods = 0;\n+int flag_print_class_info = 1;\n+int flag_print_constant_pool = 1;\n+int flag_print_fields = 1;\n+int flag_print_methods = 1;\n+int flag_print_attributes = 1;\n+\n+/* Print names of classes that have a \"main\" method. */\n+int flag_print_main = 0;\n+\n+/* Index in constant pool of this class. */\n+int this_class_index = 0;\n+\n+int class_access_flags = 0;\n+\n+/* Print in format similar to javap.  VERY IMCOMPLETE. */\n+int flag_javap_compatible = 0;\n+\n+static int print_access_flags PROTO ((FILE *, uint16));\n+static void print_constant_terse PROTO ((FILE*, JCF*, int, int));\n+static void print_constant PROTO ((FILE *, JCF *, int, int));\n+static void print_constant_ref PROTO ((FILE *, JCF *, int));\n+static void disassemble_method PROTO ((JCF*, unsigned char *, int));\n+static void print_name PROTO ((FILE*, JCF*, int));\n+static void print_signature PROTO ((FILE*, JCF*, int, int));\n+\n+#define PRINT_SIGNATURE_RESULT_ONLY 1\n+#define PRINT_SIGNATURE_ARGS_ONLY 2\n+\n+extern char* open_class();\n+\n+int\n+DEFUN(utf8_equal_string, (jcf, index, value),\n+      JCF *jcf AND int index AND char * value)\n+{\n+  if (CPOOL_INDEX_IN_RANGE (&jcf->cpool, index)\n+      && JPOOL_TAG (jcf, index) == CONSTANT_Utf8)\n+    {\n+      int len = strlen (value);\n+      if (JPOOL_UTF_LENGTH (jcf, index) == len\n+\t  && memcmp (JPOOL_UTF_DATA (jcf, index), value, len) == 0)\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+#define HANDLE_MAGIC(MAGIC, MINOR, MAJOR) \\\n+  this_class_index = 0; \\\n+  if (flag_print_class_info) \\\n+    fprintf (out, \\\n+             \"Magic number: 0x%0x, minor_version: %d, major_version: %d.\\n\", \\\n+\t     MAGIC, MINOR, MAJOR)\n+\n+#define HANDLE_START_CONSTANT_POOL(COUNT) \\\n+  if (flag_print_constant_pool) \\\n+    fprintf (out, \"\\nConstant pool (count: %d):\\n\", COUNT)\n+\n+#define HANDLE_SOURCEFILE(INDEX) \\\n+{ fprintf (out, \"Attribute \"); \\\n+  print_constant_terse (out, jcf, attribute_name, CONSTANT_Utf8); \\\n+  fprintf (out, \", length:%d, #%d=\", attribute_length, INDEX); \\\n+  print_constant_terse (out, jcf, INDEX, CONSTANT_Utf8); fputc ('\\n', out); }\n+\n+#define HANDLE_CLASS_INFO(ACCESS_FLAGS, THIS, SUPER, INTERFACES_COUNT) \\\n+  this_class_index = THIS; \\\n+  class_access_flags = ACCESS_FLAGS; \\\n+  if (flag_print_class_info) \\\n+    { fprintf (out, \"\\nAccess flags: 0x%x\", ACCESS_FLAGS); \\\n+      print_access_flags (out, ACCESS_FLAGS); \\\n+      fputc ('\\n', out); \\\n+      fprintf (out, \"This class: \"); \\\n+      if (flag_print_constant_pool) \\\n+        fprintf (out, \"%d=\", THIS); \\\n+      print_constant_terse (out, jcf, THIS, CONSTANT_Class); \\\n+      if (flag_print_constant_pool || SUPER != 0) \\\n+        fprintf (out, \", super: \"); \\\n+      if (flag_print_constant_pool) \\\n+        { \\\n+          fprintf (out, \"%d\", SUPER); \\\n+          if (SUPER != 0) \\\n+            fputc ('=', out); \\\n+        } \\\n+      if (SUPER != 0) \\\n+        print_constant_terse (out, jcf, SUPER, CONSTANT_Class); \\\n+      fprintf (out, \"\\nInterfaces (count: %d):\\n\", INTERFACES_COUNT); \\\n+    }\n+\n+#define IGNORE_ATTRIBUTE(JCF, NAME, NAME_LENGTH) \\\n+  (flag_print_attributes <= 0)\n+\n+#define HANDLE_CLASS_INTERFACE(INDEX) \\\n+  if (flag_print_class_info) \\\n+    { fprintf (out, \"- Implements: %d=\", INDEX); \\\n+      print_constant_terse (out, jcf, INDEX, CONSTANT_Class); \\\n+      fputc ('\\n', out); }\n+\n+#define HANDLE_START_FIELDS(FIELDS_COUNT) \\\n+  if (flag_print_fields) \\\n+    fprintf (out, \"\\nFields (count: %d):\\n\", FIELDS_COUNT)\n+\n+#define HANDLE_START_FIELD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT) \\\n+  if (flag_print_fields) \\\n+    { fprintf (out, \"Field name:\"); \\\n+      print_constant_terse (out, jcf, NAME, CONSTANT_Utf8); \\\n+      print_access_flags (out, ACCESS_FLAGS); \\\n+      fprintf (out, \" Signature: \"); \\\n+      if (flag_print_constant_pool) \\\n+        fprintf (out, \"%d=\", SIGNATURE); \\\n+      print_signature (out, jcf, SIGNATURE, 0); \\\n+      fputc ('\\n', out); } \\\n+  else \\\n+    flag_print_attributes--;\n+\n+#define HANDLE_END_FIELD() \\\n+  if (! flag_print_fields) \\\n+    flag_print_attributes++;\n+\n+#define HANDLE_START_METHODS(METHODS_COUNT) \\\n+  if (flag_print_methods) \\\n+    fprintf (out, \"\\nMethods (count: %d):\\n\", METHODS_COUNT); \\\n+  else \\\n+    flag_print_attributes--;\n+\n+\n+#define HANDLE_END_METHODS() \\\n+  if (! flag_print_methods) \\\n+    flag_print_attributes++;\n+\n+#define HANDLE_METHOD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT) \\\n+{ \\\n+  if (flag_print_methods) \\\n+    { \\\n+      if (flag_javap_compatible) \\\n+        { \\\n+\t  fprintf (out, \"    \"); \\\n+\t  print_access_flags (out, ACCESS_FLAGS); \\\n+\t  fputc (' ', out); \\\n+\t  print_signature (out, jcf, SIGNATURE, PRINT_SIGNATURE_RESULT_ONLY); \\\n+\t  fputc (' ', out); \\\n+\t  print_constant_terse (out, jcf, NAME, CONSTANT_Utf8); \\\n+\t  print_signature (out, jcf, SIGNATURE, PRINT_SIGNATURE_ARGS_ONLY); \\\n+\t  fputc ('\\n', out); \\\n+\t} \\\n+      else \\\n+\t{ \\\n+\t  fprintf (out, \"\\nMethod name:\"); \\\n+\t  print_constant_terse (out, jcf, NAME, CONSTANT_Utf8); \\\n+\t  print_access_flags (out, ACCESS_FLAGS); \\\n+\t  fprintf (out, \" Signature: \"); \\\n+\t  if (flag_print_constant_pool) \\\n+\t    fprintf (out, \"%d=\", SIGNATURE); \\\n+\t  print_signature (out, jcf, SIGNATURE, 0); \\\n+\t  fputc ('\\n', out); \\\n+\t} \\\n+    } \\\n+  if (flag_print_main && ACCESS_FLAGS == (ACC_STATIC|ACC_PUBLIC) \\\n+      && utf8_equal_string (jcf, NAME, \"main\") \\\n+      && utf8_equal_string (jcf, SIGNATURE, \"([Ljava/lang/String;)V\") \\\n+      && this_class_index > 0 \\\n+      && (class_access_flags & ACC_PUBLIC)) \\\n+    { \\\n+      print_constant_terse(out, jcf, this_class_index, CONSTANT_Class); \\\n+      fputc  ('\\n', out); \\\n+   } \\\n+}\n+\n+#define COMMON_HANDLE_ATTRIBUTE(JCF, INDEX, LENGTH) \\\n+( fprintf (out, \"Attribute \"), \\\n+  print_constant_terse (out, jcf, INDEX, CONSTANT_Utf8), \\\n+  fprintf (out, \", length:%d\", LENGTH) )\n+\n+#define HANDLE_CONSTANTVALUE(VALUE_INDEX) \\\n+( COMMON_HANDLE_ATTRIBUTE(JCF, attribute_name, attribute_length), \\\n+  fprintf (out, \", value: \"), \\\n+  print_constant_ref (out, jcf, VALUE_INDEX), \\\n+  fprintf (out, \"\\n\") )\n+\n+#define HANDLE_CODE_ATTRIBUTE(MAX_STACK, MAX_LOCALS, CODE_LENGTH) \\\n+{ COMMON_HANDLE_ATTRIBUTE(JCF, attribute_name, attribute_length); \\\n+  fprintf (out, \", max_stack:%d, max_locals:%d, code_length:%d\\n\", \\\n+    MAX_STACK, MAX_LOCALS, CODE_LENGTH); \\\n+  disassemble_method (jcf, jcf->read_ptr, CODE_LENGTH); }\n+\n+#define HANDLE_EXCEPTIONS_ATTRIBUTE(COUNT) \\\n+{ int n = (COUNT); int i; \\\n+  COMMON_HANDLE_ATTRIBUTE(JCF, attribute_name, attribute_length); \\\n+  fprintf (out, \", count: %d\\n\", n); \\\n+  for (i = 0; i < n; i++) {\\\n+    int ex_index = JCF_readu2 (jcf); \\\n+    fprintf (out, \"%3d: \", i); \\\n+    print_constant_ref (out, jcf, ex_index); \\\n+    fputc ('\\n', out); } }\n+\n+#define HANDLE_LOCALVARIABLETABLE_ATTRIBUTE(COUNT) \\\n+{ int n = (COUNT); int i; \\\n+  COMMON_HANDLE_ATTRIBUTE(JCF, attribute_name, attribute_length); \\\n+  fprintf (out, \", count: %d\\n\", n); \\\n+  for (i = 0; i < n; i++) {\\\n+    int start_pc = JCF_readu2 (jcf); \\\n+    int length = JCF_readu2 (jcf); \\\n+    int name_index = JCF_readu2 (jcf); \\\n+    int signature_index = JCF_readu2 (jcf); \\\n+    int slot = JCF_readu2 (jcf); \\\n+    fprintf (out, \"  slot#%d: name: %d=\", slot, name_index); \\\n+    print_name (out, jcf, name_index); \\\n+    fprintf (out, \", type: %d=\", signature_index); \\\n+    print_signature (out, jcf, signature_index, 0); \\\n+    fprintf (out, \" (pc: %d length: %d)\\n\", start_pc, length); }}\n+\n+#define HANDLE_LINENUMBERTABLE_ATTRIBUTE(COUNT) \\\n+{ int n = (COUNT); int i; \\\n+  COMMON_HANDLE_ATTRIBUTE(jcf, attribute_name, attribute_length); \\\n+  fprintf (out, \", count: %d\\n\", n); \\\n+  if (flag_disassemble_methods) \\\n+    for (i = 0; i < n; i++) {\\\n+      int start_pc = JCF_readu2 (jcf); \\\n+      int line_number = JCF_readu2 (jcf); \\\n+      fprintf (out, \"  line: %d at pc: %d\\n\", line_number, start_pc); }\\\n+  else \\\n+    JCF_SKIP (jcf, 4 * n); }\n+\n+#define PROCESS_OTHER_ATTRIBUTE(JCF, INDEX, LENGTH) \\\n+{ COMMON_HANDLE_ATTRIBUTE(JCF, INDEX, LENGTH); \\\n+  fputc ('\\n', out); JCF_SKIP (JCF, LENGTH); }\n+\n+#define START_FINAL_ATTRIBUTES(ATTRIBUTES_COUNT) \\\n+  if (flag_print_attributes > 0) \\\n+    fprintf (out, \"\\nAttributes (count: %d):\\n\", attributes_count);\n+\n+#include \"javaop.h\"\n+#include \"jcf-reader.c\"\n+\n+static void\n+DEFUN(print_constant_ref, (stream, jcf, index),\n+      FILE *stream AND JCF *jcf AND int index)\n+{\n+  fprintf (stream, \"#%d=<\", index);\n+  if (index <= 0 || index >= JPOOL_SIZE(jcf))\n+    fprintf (stream, \"out of range\");\n+  else\n+    print_constant (stream, jcf, index, 1);\n+  fprintf (stream, \">\", index);\n+}\n+\n+static int\n+DEFUN (print_access_flags, (stream, flags),\n+       FILE *stream AND uint16 flags)\n+{\n+  if (flags & ACC_PUBLIC) fprintf (stream, \" public\");\n+  if (flags & ACC_PRIVATE) fprintf (stream, \" private\");\n+  if (flags & ACC_PROTECTED) fprintf (stream, \" protected\");\n+  if (flags & ACC_STATIC) fprintf (stream, \" static\");\n+  if (flags & ACC_FINAL) fprintf (stream, \" final\");\n+  if (flags & ACC_SYNCHRONIZED) fprintf (stream, \" synchronized\");\n+  if (flags & ACC_VOLATILE) fprintf (stream, \" volatile\");\n+  if (flags & ACC_TRANSIENT) fprintf (stream, \" transient\");\n+  if (flags & ACC_NATIVE) fprintf (stream, \" native\");\n+  if (flags & ACC_INTERFACE) fprintf (stream, \" interface\");\n+  if (flags & ACC_ABSTRACT) fprintf (stream, \" abstract\");\n+}\n+\n+\n+static void\n+DEFUN(print_name, (stream, jcf, name_index),\n+      FILE* stream AND JCF* jcf AND int name_index)\n+{\n+  if (JPOOL_TAG (jcf, name_index) != CONSTANT_Utf8)\n+    fprintf (stream, \"<not a UTF8 constant>\");\n+  else\n+    jcf_print_utf8 (stream, JPOOL_UTF_DATA (jcf,name_index),\n+\t\t    JPOOL_UTF_LENGTH (jcf, name_index));\n+}\n+\n+/* If the type of the constant at INDEX matches EXPECTED,\n+   print it tersely, otherwise more verbosely. */\n+\n+void\n+DEFUN(print_constant_terse, (out, jcf, index, expected),\n+      FILE *out AND JCF *jcf AND int index AND int expected)\n+{\n+  if (JPOOL_TAG (jcf, index) != expected)\n+    {\n+      fprintf (out, \"<Unexpected constant type \");\n+      print_constant (out, jcf, index, 1);\n+      fprintf (out, \">\");\n+    }\n+  else\n+    print_constant (out, jcf, index, 0);\n+}\n+\n+/* Print the constant at INDEX in JCF's constant pool.\n+   If verbosity==0, print very tersely (no extraneous text).\n+   If verbosity==1, prefix the type of the constant.\n+   If verbosity==2, add more descriptive text. */\n+\n+static void\n+DEFUN(print_constant, (out, jcf, index, verbosity),\n+      FILE *out AND JCF *jcf AND int index AND int verbosity)\n+{\n+  int j, n;\n+  jlong num;\n+  char *str;\n+  int kind = JPOOL_TAG (jcf, index);\n+  switch (kind)\n+    {\n+    case CONSTANT_Class:\n+      n = JPOOL_USHORT1 (jcf, index);\n+      if (verbosity > 0)\n+\tfprintf (out, verbosity > 1 ? \"Class name: %d=\" : \"Class \", n);\n+      if (! CPOOL_INDEX_IN_RANGE (&jcf->cpool, n))\n+\tfprintf (out, \"<out of range>\");\n+      else if (verbosity < 2 && JPOOL_TAG (jcf, n) == CONSTANT_Utf8)\n+\t{\n+\t  int len = JPOOL_UTF_LENGTH (jcf, n);\n+\t  jcf_print_utf8_replace (out, JPOOL_UTF_DATA(jcf,n), len, '/', '.');\n+\t}\n+      else\n+\tprint_constant_terse (out, jcf, n, CONSTANT_Utf8);\n+      break;\n+    case CONSTANT_Fieldref:\n+      str = \"Field\"; goto field_or_method;\n+    case CONSTANT_Methodref:\n+      str = \"Method\"; goto field_or_method;\n+    case CONSTANT_InterfaceMethodref:\n+      str = \"InterfaceMethod\"; goto field_or_method;\n+    field_or_method:\n+      {\n+\tuint16 tclass = JPOOL_USHORT1 (jcf, index);\n+\tuint16 name_and_type = JPOOL_USHORT2 (jcf, index);\n+\tif (verbosity == 2)\n+\t  fprintf (out, \"%sref class: %d=\", str, tclass);\n+\telse if (verbosity > 0)\n+\t    fprintf (out, \"%s \", str);\n+\tprint_constant_terse (out, jcf, tclass, CONSTANT_Class);\n+\tfprintf (out, verbosity < 2 ? \".\" : \" name_and_type: %d=<\",\n+\t\t name_and_type);\n+\tprint_constant_terse (out, jcf, name_and_type, CONSTANT_NameAndType);\n+\tif (verbosity == 2)\n+\t  fputc ('>', out);\n+      }\n+      break;\n+    case CONSTANT_String:\n+      j = JPOOL_USHORT1 (jcf, index);\n+      if (verbosity > 0)\n+\tfprintf (out, verbosity > 1 ? \"String %d=\" : \"String \", j);\n+      print_constant_terse (out, jcf, j, CONSTANT_Utf8);\n+      break;\n+    case CONSTANT_Integer:\n+      if (verbosity > 0)\n+\tfprintf (out, \"Integer \");\n+      num = JPOOL_INT (jcf, index);\n+      goto integer;\n+    case CONSTANT_Long:\n+      if (verbosity > 0)\n+\tfprintf (out, \"Long \");\n+      num = JPOOL_LONG (jcf, index);\n+      goto integer;\n+    integer:\n+      {\n+\tchar buffer[25];\n+\tformat_int (buffer, num, 10);\n+\tfprintf (out, \"%s\", buffer);\n+\tif (verbosity > 1)\n+\t  {\n+\t    format_uint (buffer, (uint64)num, 16);\n+\t    fprintf (out, \"=0x%s\", buffer);\n+\t  }\n+      }\n+      break;\n+    case CONSTANT_Float:\n+      {\n+\tjfloat fnum = JPOOL_FLOAT (jcf, index);\n+\tfprintf (out, \"%s%.10g\", verbosity > 1 ? \"Float \" : \"\", (double) fnum);\n+\tif (verbosity > 1)\n+\t  fprintf (out, \", bits = 0x%08lx\", (long) (* (int32 *) &fnum));\n+\tbreak;\n+      }\n+    case CONSTANT_Double:\n+      {\n+\tjdouble dnum = JPOOL_DOUBLE (jcf, index);\n+\tfprintf (out, \"%s%.20g\", verbosity > 1 ? \"Double \" : \"\", dnum);\n+\tif (verbosity > 1)\n+\t  {\n+\t    int32 hi, lo;\n+\t    hi = JPOOL_UINT (jcf, index);\n+\t    lo = JPOOL_UINT (jcf, index + 1);\n+\t    fprintf (out, \", bits = 0x%08lx%08lx\", (long) hi, (long) lo);\n+\t  }\n+\tbreak;\n+      }\n+    case CONSTANT_NameAndType:\n+      {\n+\tuint16 name = JPOOL_USHORT1 (jcf, index);\n+\tuint16 sig = JPOOL_USHORT2 (jcf, index);\n+\tif (verbosity > 0)\n+\t  fprintf (out, verbosity > 1 ? \"%s name: %d=\" : \"%s \",\n+\t\t   \"NameAndType\", name);\n+\tprint_name (out, jcf, name);\n+\tif (verbosity <= 1)\n+\t  fputc (' ', out);\n+\telse\n+\t  fprintf (out, \", signature: %d=\", sig);\n+\tprint_signature (out, jcf, sig, 0);\n+      }\n+      break;\n+    case CONSTANT_Utf8:\n+      {\n+\tregister unsigned char *str = JPOOL_UTF_DATA (jcf, index);\n+\tint length = JPOOL_UTF_LENGTH (jcf, index);\n+\tif (verbosity > 0)\n+\t  { /* Print as 8-bit bytes. */\n+\t    fputs (\"Utf8: \\\"\", out);\n+\t    while (--length >= 0)\n+\t      jcf_print_char (out, *str++);\n+\t  }\n+\telse\n+\t  { /* Print as Unicode. */\n+\t    fputc ('\\\"', out);\n+\t    jcf_print_utf8 (out, str, length);\n+\t  }\n+\tfputc ('\\\"', out);\n+      }\n+      break;\n+    default:\n+      fprintf (out, \"(Unknown constant type %d)\", kind);\n+    }\n+}\n+\n+void\n+DEFUN(print_constant_pool, (jcf),\n+      JCF *jcf)\n+{\n+  int i;\n+  for (i = 1; i < JPOOL_SIZE(jcf); i++)\n+    {\n+      int kind = JPOOL_TAG (jcf, i);\n+      fprintf (out, \"#%d: \", i);\n+      print_constant (out, jcf, i, 2);\n+      fprintf (out, \"\\n\");\n+      if (kind == CONSTANT_Double || kind == CONSTANT_Long)\n+\ti++; /* These take up two slots in the constant table */\n+    }\n+}\n+\n+static void\n+DEFUN(print_signature_type, (stream, ptr, limit),\n+     FILE* stream AND const unsigned char **ptr AND const unsigned char *limit)\n+{\n+  int array_size;\n+  if ((*ptr) >= limit)\n+    return;\n+  switch (*(*ptr))\n+    {\n+    case '[':\n+      array_size = -1;\n+      for ((*ptr)++; (*ptr) < limit && isdigit (**ptr); (*ptr)++)\n+\t{\n+\t  int digit = \n+\t    array_size = (array_size < 0 ? 0 : 10 * array_size) + *(*ptr) - '0';\n+\t}\n+      print_signature_type (stream, ptr, limit);\n+      if (array_size == -1)\n+\tfprintf (stream, \"[]\");\n+      else\n+\tfprintf (stream, \"[%d]\", array_size);\n+      break;\n+    case '(':\n+      {\n+\tint nargs = 0;\n+\tfputc (*(*ptr)++, stream);\n+\tfor (; **ptr != ')' && *ptr < limit; nargs++)\n+\t  {\n+\t    if (nargs > 0)\n+\t      fputc (',', stream);\n+\t    print_signature_type (stream, ptr, limit);\n+\t  }\n+\tif (*ptr < limit)\n+\t  {\n+\t    fputc (*(*ptr)++, stream);\n+\t    print_signature_type (stream, ptr, limit);\n+\t  }\n+\telse\n+\t  fprintf (stream, \"???\");\n+      }\n+    break;\n+      \n+    case 'B':  fprintf (stream, \"byte\");  (*ptr)++;  break;\n+    case 'C':  fprintf (stream, \"char\");  (*ptr)++;  break;\n+    case 'D':  fprintf (stream, \"double\");  (*ptr)++;  break;\n+    case 'F':  fprintf (stream, \"float\");  (*ptr)++;  break;\n+    case 'S':  fprintf (stream, \"short\");  (*ptr)++;  break;\n+    case 'I':  fprintf (stream, \"int\");  (*ptr)++;  break;\n+    case 'J':  fprintf (stream, \"long\");  (*ptr)++;  break;\n+    case 'Z':  fprintf (stream, \"boolean\");  (*ptr)++;  break;\n+    case 'V':  fprintf (stream, \"void\");  (*ptr)++;  break;\n+\n+    case 'L':\n+      for ((*ptr)++; (*ptr)<limit && *(*ptr) != ';'; (*ptr)++)\n+\tjcf_print_char (stream, *(*ptr) == '/' ? '.' : *(*ptr));\n+      if (*(*ptr) == ';')\n+\t(*ptr)++;\n+      break;\n+    default:\n+      jcf_print_char (stream, *(*ptr)++);\n+    }\n+}\n+\n+static void\n+DEFUN(print_signature, (stream, jcf, signature_index, int options),\n+      FILE* stream AND JCF *jcf AND int signature_index AND int options)\n+{\n+  if (JPOOL_TAG (jcf, signature_index) != CONSTANT_Utf8)\n+    print_constant_terse (out, jcf, signature_index, CONSTANT_Utf8);\n+  else\n+    {\n+      int j;\n+      const unsigned char *str = JPOOL_UTF_DATA (jcf, signature_index);\n+      int length = JPOOL_UTF_LENGTH (jcf, signature_index);\n+      const unsigned char *limit;\n+      limit = str + length;\n+      if (str >= limit)\n+\tfprintf (stream, \"<empty signature string>\");\n+      else\n+\t{\n+\t  if (options & PRINT_SIGNATURE_RESULT_ONLY)\n+\t    {\n+\t      while (str < limit && *str++ != ')') ;\n+\t    }\n+\t  if (options & PRINT_SIGNATURE_ARGS_ONLY)\n+\t    {\n+\t      *str++;\n+\t      fputc ('(', stream);\n+\t      while (str < limit && *str != ')')\n+\t\t{\n+\t\t  print_signature_type (stream, &str, limit);\n+\t\t  if (*str != ')')\n+\t\t    fputs (\", \", stream);\n+\t\t}\n+\t      fputc (')', stream);\n+\t    }\n+\t  else\n+\t    {\n+\t      print_signature_type (stream, &str, limit);\n+\t      if (str < limit)\n+\t\t{\n+\t\t  fprintf (stream, \"<junk:\");\n+\t\t  jcf_print_utf8 (stream, str, limit - str);\n+\t\t  fputc ('>', stream);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+int\n+DEFUN (usage, (), )\n+{\n+  fprintf (stderr, \"Usage: jcf-dump [-o outputfile] [-c] classname\\n\");\n+  exit(1);\n+}\n+\n+void\n+DEFUN(process_class, (jcf),\n+      JCF *jcf)\n+{\n+  int code;\n+  if (jcf_parse_preamble (jcf) != 0)\n+    fprintf (stderr, \"Not a valid Java .class file.\\n\");    \n+\n+  /* Parse and possibly print constant pool */\n+  code = jcf_parse_constant_pool (jcf);\n+  if (code != 0)\n+    {\n+      fprintf (stderr, \"error while parsing constant pool\\n\");\n+      exit (-1);\n+    }\n+  code = verify_constant_pool (jcf);\n+  if (code > 0)\n+    {\n+      fprintf (stderr, \"error in constant pool entry #%d\\n\", code);\n+      exit (-1);\n+    }\n+  if (flag_print_constant_pool)\n+    print_constant_pool (jcf);\n+\n+  jcf_parse_class (jcf);\n+  code = jcf_parse_fields (jcf);\n+  if (code != 0)\n+    {\n+      fprintf (stderr, \"error while parsing fields\\n\");\n+      exit (-1);\n+    }\n+  code = jcf_parse_methods (jcf);\n+  if (code != 0)\n+    {\n+      fprintf (stderr, \"error while parsing methods\\n\");\n+      exit (-1);\n+    }\n+  code = jcf_parse_final_attributes (jcf);\n+  if (code != 0)\n+    {\n+      fprintf (stderr, \"error while parsing final attributes\\n\");\n+      exit (-1);\n+    }\n+  jcf->filename = NULL;\n+}\n+\n+int\n+DEFUN(main, (argc, argv),\n+      int argc AND char** argv)\n+{\n+  JCF jcf[1];\n+  int argi;\n+  if (argc <= 1)\n+    usage ();\n+\n+  for (argi = 1; argi < argc; argi++)\n+    {\n+      char *arg = argv[argi];\n+      if (arg[0] == '-')\n+\t{\n+\t  if (strcmp (arg, \"-o\") == 0 && argi + 1 < argc)\n+\t    output_file = argv[++argi];\n+\t  else if (arg[1] == '-')\n+\t    {\n+\t      arg++;\n+\t      if (strcmp (arg, \"-classpath\") == 0 && argi + 1 < argc)\n+\t\tclasspath = argv[++argi];\n+\t      else if (strcmp (arg, \"-verbose\") == 0)\n+\t\tverbose++;\n+\t      else if (strcmp (arg, \"-print-main\") == 0)\n+\t\tflag_print_main++;\n+\t      else if (strcmp (arg, \"-javap\") == 0)\n+\t\t{\n+\t\t  flag_javap_compatible++;\n+\t\t  flag_print_constant_pool = 0;\n+\t\t}\n+\t      else if (arg[2] == '\\0')\n+\t\tbreak;\n+\t      else\n+\t\t{\n+\t\t  fprintf (stderr, \"%s: illegal argument\\n\", argv[argi]);\n+\t\t  exit (-1);\n+\t\t}\n+\t      \n+\t    }\n+\t  else if (strcmp (arg, \"-classpath\") == 0 && argi + 1 < argc)\n+\t    classpath = argv[++argi];\n+\t  else if (strcmp (arg, \"-verbose\") == 0)\n+\t    verbose++;\n+\t  else if (strcmp (arg, \"-print-main\") == 0)\n+\t    flag_print_main++;\n+\t  else if (strcmp (arg, \"-c\") == 0)\n+\t    flag_disassemble_methods++;\n+\t  else\n+\t    {\n+\t      fprintf (stderr, \"%s: illegal argument\\n\", argv[argi]);\n+\t      exit (-1);\n+\t    }\n+\t}\n+      else\n+\tbreak;\n+    }\n+  if (argi == argc)\n+    usage ();\n+  if (flag_print_main)\n+    {\n+      flag_print_fields = 0;\n+      flag_print_methods = 0;\n+      flag_print_constant_pool = 0;\n+      flag_print_attributes = 0;\n+      flag_print_class_info = 0;\n+    }\n+\n+  if (classpath == NULL)\n+    {\n+      classpath = (char *) getenv (\"CLASSPATH\");\n+      if (classpath == NULL)\n+\tclasspath = \"\";\n+    }\n+\n+  if (output_file)\n+    {\n+      out = fopen (output_file, \"w\");\n+      if (out)\n+\t{\n+\t  fprintf (stderr, \"Cannot open '%s' for output.\\n\", output_file);\n+\t  exit (-1);\n+\t}\n+    }\n+  else\n+    out = stdout;\n+\n+  if (argi >= argc)\n+    {\n+      fprintf (out, \"Reading .class from <standard input>.\\n\");\n+#if JCF_USE_STDIO\n+      open_class (\"<stdio>\", jcf, stdin);\n+#else\n+      open_class (\"<stdio>\", jcf, 0);\n+#endif\n+      process_class (jcf);\n+    }\n+  else\n+    {\n+      for (; argi < argc; argi++)\n+\t{\n+\t  char *arg = argv[argi];\n+\t  char* class_filename = find_class (arg, strlen (arg), jcf, 1);\n+\t  if (class_filename == NULL)\n+\t    class_filename = find_classfile (arg, jcf);\n+\t  if (class_filename == NULL)\n+\t    {\n+\t      perror (\"Could not find class\");\n+\t      exit (-1);\n+\t    }\n+\t  JCF_FILL (jcf, 4);\n+\t  if (GET_u4 (jcf->read_ptr) == ZIPMAGIC)\n+\t    {\n+\t      long compressed_size, member_size;\n+\t      int compression_method, filename_length, extra_length;\n+\t      int general_purpose_bits;\n+\t      char *filename;\n+\t      int total_length;\n+\t      if (flag_print_class_info)\n+\t\tfprintf (out, \"Reading classes from archive %s.\\n\",\n+\t\t\t class_filename);\n+\t      for (;;)\n+\t\t{\n+\t\t  int skip = 0;\n+\t\t  jcf_filbuf_t save_filbuf = jcf->filbuf;\n+\t\t  long magic = JCF_readu4_le (jcf);\n+\t\t  if (magic == 0x02014b50 || magic == 0x06054b50)\n+\t\t    break;  /* got to central directory */\n+\t\t  if (magic != 0x04034b50) /* ZIPMAGIC (little-endian) */\n+\t\t    {\n+\t\t      fprintf (stderr, \"bad format of .zip archine\\n\");\n+\t\t      exit (-1);\n+\t\t    }\n+\t\t  JCF_FILL (jcf, 26);\n+\t\t  JCF_SKIP (jcf, 2);\n+\t\t  general_purpose_bits = JCF_readu2_le (jcf);\n+\t\t  compression_method = JCF_readu2_le (jcf);\n+\t\t  JCF_SKIP (jcf, 8);\n+\t\t  compressed_size = JCF_readu4_le (jcf);\n+\t\t  member_size = JCF_readu4_le (jcf);\n+\t\t  filename_length = JCF_readu2_le (jcf);\n+\t\t  extra_length = JCF_readu2_le (jcf);\n+\t\t  total_length = filename_length + extra_length\n+\t\t    + compressed_size;\n+\t\t  if (jcf->read_end - jcf->read_ptr < total_length)\n+\t\t    jcf_trim_old_input (jcf);\n+\t\t  JCF_FILL (jcf, total_length);\n+\t\t  filename = jcf->read_ptr;\n+\t\t  JCF_SKIP (jcf, filename_length);\n+\t\t  JCF_SKIP (jcf, extra_length);\n+\t\t  if (filename_length > 0\n+\t\t      && filename[filename_length-1] == '/')\n+\t\t    {\n+\t\t      if (flag_print_class_info)\n+\t\t\tfprintf (out, \"[Skipping directory %.*s]\\n\",\n+\t\t\t\t filename_length, filename);\n+\t\t      skip = 1;\n+\t\t    }\n+\t\t  else if (compression_method != 0)\n+\t\t    {\n+\t\t      if (flag_print_class_info)\n+\t\t\tfprintf (out, \"[Skipping compressed file %.*s]\\n\",\n+\t\t\t\t filename_length, filename);\n+\t\t      skip = 1;\n+\t\t    }\n+\t\t  else if (member_size < 4\n+\t\t\t   || GET_u4 (jcf->read_ptr) != 0xcafebabe)\n+\t\t    {\n+\t\t      if (flag_print_class_info)\n+\t\t\tfprintf (out, \"[Skipping non-.class member %.*s]\\n\",\n+\t\t\t\t filename_length, filename);\n+\t\t      skip = 1;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (flag_print_class_info)\n+\t\t\tfprintf (out, \"Reading class member: %.*s.\\n\",\n+\t\t\t\t filename_length, filename);\n+\t\t    }\n+\t\t  if (skip)\n+\t\t    {\n+\t\t      JCF_SKIP (jcf, compressed_size);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      unsigned char *save_end;\n+\t\t      jcf->filbuf = jcf_unexpected_eof;\n+\t\t      save_end = jcf->read_end;\n+\t\t      jcf->read_end = jcf->read_ptr + compressed_size;\n+\t\t      process_class (jcf);\n+\t\t      jcf->filbuf = save_filbuf;\n+\t\t      jcf->read_end = save_end;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (flag_print_class_info)\n+\t\tfprintf (out, \"Reading .class from %s.\\n\", class_filename);\n+\t      process_class (jcf);\n+\t    }\n+\t  JCF_FINISH(jcf);\n+\t}\n+    }\n+}\n+\n+static void\n+DEFUN(disassemble_method, (jcf, byte_ops, len),\n+      JCF* jcf AND unsigned char *byte_ops AND int len)\n+{\n+#undef AND /* Causes problems with opcodes for iand and land. */\n+#undef PTR\n+  int PC;\n+  int i;\n+  if (flag_disassemble_methods == 0)\n+    return;\n+#define BCODE byte_ops\n+  for (PC = 0; PC < len;)\n+    {\n+      int oldpc = PC;\n+      int saw_index;\n+      jlong LONG_temp;\n+      jint INT_temp;\n+      jfloat FLOAT_temp;\n+      jdouble DOUBLE_temp;\n+      switch (byte_ops[PC++])\n+\t{\n+\n+/* This is the actual code emitted for each of opcodes in javaops.def.\n+   The actual opcode-specific stuff is handled by the OPKIND macro.\n+   I.e. for an opcode whose OPKIND is BINOP, the BINOP will be called.\n+   Those macros are defiend below.  The OPKINDs that do not have any\n+   inline parameters (such as BINOP) and therefore do mot need anything\n+   else to me printed out just use an empty body. */\n+\n+#define JAVAOP(OPNAME, OPCODE, OPKIND, OPERAND_TYPE, OPERAND_VALUE) \\\n+        case OPCODE: \\\n+\t  fprintf (out, \"%3d: %s\", oldpc, #OPNAME); \\\n+\t  OPKIND(OPERAND_TYPE, OPERAND_VALUE); \\\n+\t  fputc ('\\n', out); \\\n+\t  break;\n+\n+#define CONST_INDEX_1 (saw_index = 1, IMMEDIATE_u1)\n+#define CONST_INDEX_2 (saw_index = 1, IMMEDIATE_u2)\n+#define VAR_INDEX_1 (saw_index = 1, IMMEDIATE_u1)\n+#define VAR_INDEX_2 (saw_index = 1, IMMEDIATE_u2)\n+\n+#define CHECK_PC_IN_RANGE(PC) (PC < 0 || PC > len ? \\\n+  (fprintf(stderr, \"Bad byte codes.\\n\"), exit(-1)) : 1)\n+\n+/* Print out operand (if not implied by the opcode) for PUSCH opcodes.\n+   These all push a constant onto the opcode stack. */\n+#define PUSHC(OPERAND_TYPE, OPERAND_VALUE) \\\n+  saw_index = 0, INT_temp = (OPERAND_VALUE); \\\n+  if (oldpc+1 == PC) /* nothing */; \\\n+  else if (saw_index) fprintf (out, \" \"), print_constant_ref (out, jcf, INT_temp); \\\n+  else fprintf (out, \" %d\", INT_temp);\n+\n+/* Print out operand (a local variable index) for LOAD opcodes.\n+   These all push local variable onto the opcode stack. */\n+#define LOAD(OPERAND_TYPE, OPERAND_VALUE) \\\n+  INT_temp = (OPERAND_VALUE); \\\n+  if (oldpc+1 == PC) /* nothing - local index implied by opcode */; \\\n+  else fprintf (out, \" %d\", INT_temp);\n+\n+/* Handle STORE opcodes same as LOAD opcodes.\n+   These all store a value from the opcode stack in a local variable. */\n+#define STORE LOAD\n+\n+/* Handle more kind of opcodes. */\n+#define STACK(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n+#define UNOP(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n+#define BINOP(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n+#define CONVERT(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n+#define CONVERT2(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n+#define RETURN(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n+#define UNKNOWN(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n+\n+/* Handle putfield and getfield opcodes, with static versions. */\n+#define FIELD(MAYBE_STATIC, PUT_OR_GET) \\\n+  fputc (' ', out); print_constant_ref (out, jcf, IMMEDIATE_u2)\n+\n+/* Print operand for invoke opcodes. */\n+#define INVOKE(OPERAND_TYPE, OPERAND_VALUE) \\\n+  fputc (' ', out); print_constant_ref (out, jcf, IMMEDIATE_u2);\\\n+  PC += 2 * OPERAND_VALUE /* for invokeinterface */;\n+\n+#define OBJECT(OPERAND_TYPE, OPERAND_VALUE) \\\n+  fputc (' ', out); print_constant_ref (out, jcf, IMMEDIATE_u2);\n+\n+#define ARRAY(OPERAND_TYPE, SUBOP) \\\n+  ARRAY_##SUBOP(OPERAND_TYPE)\n+/* Handle sub-categories of ARRAY opcodes. */\n+#define ARRAY_LOAD(TYPE) /* nothing */\n+#define ARRAY_STORE(TYPE) /* nothing */\n+#define ARRAY_LENGTH(TYPE) /* nothing */\n+#define ARRAY_NEW(TYPE) ARRAY_NEW_##TYPE\n+#define ARRAY_NEW_NUM \\\n+ INT_temp = IMMEDIATE_u1; \\\n+ { char *str; \\\n+  switch (INT_temp) {  \\\n+    case  4: str = \"boolean\"; break; \\\n+    case  5: str = \"char\"; break; \\\n+    case  6: str = \"float\"; break; \\\n+    case  7: str = \"double\"; break; \\\n+    case  8: str = \"byte\"; break; \\\n+    case  9: str = \"short\"; break; \\\n+    case 10: str = \"int\"; break; \\\n+    case 11: str = \"long\"; break; \\\n+    default: str = \"<unknown type code %d>\"; break; \\\n+  } \\\n+  fputc (' ', out); fprintf (out, str, INT_temp); }\n+\n+#define ARRAY_NEW_PTR  \\\n+  fputc (' ', out); print_constant_ref (out, jcf, IMMEDIATE_u2);\n+\n+#define ARRAY_NEW_MULTI \\\n+  fputc (' ', out); print_constant_ref (out, jcf, IMMEDIATE_u2); \\\n+  fprintf (out, \" %d\", IMMEDIATE_u1); /* number of dimensions */\n+\n+#define TEST(OPERAND_TYPE, OPERAND_VALUE) \\\n+  fprintf (out, \" %d\", oldpc + IMMEDIATE_s2)\n+\n+#define BRANCH(OPERAND_TYPE, OPERAND_VALUE) \\\n+  saw_index = 0, INT_temp = (OPERAND_VALUE); \\\n+  fprintf (out, \" %d\", saw_index ? INT_temp : oldpc + INT_temp)\n+\n+#define JSR(OPERAND_TYPE, OPERAND_VALUE) \\\n+  saw_index = 0, INT_temp = (OPERAND_VALUE); \\\n+  fprintf (out, \" %d\", saw_index ? INT_temp : oldpc + INT_temp)\n+\n+#define RET(OPERAND_TYPE, OPERAND_VALUE) \\\n+  INT_temp = (OPERAND_VALUE); \\\n+  fprintf (out, \" %d\", INT_temp);\n+\n+#define SWITCH(OPERAND_TYPE, TABLE_OR_LOOKUP) \\\n+  PC = (PC + 3) / 4 * 4; TABLE_OR_LOOKUP##_SWITCH\n+\n+#define LOOKUP_SWITCH \\\n+  { jint default_offset = IMMEDIATE_s4;  jint npairs = IMMEDIATE_s4; \\\n+    fprintf (out, \" npairs=%d, default=%d\", npairs, default_offset+oldpc); \\\n+    while (--npairs >= 0) { \\\n+     jint match = IMMEDIATE_s4; jint offset = IMMEDIATE_s4; \\\n+     fprintf (out, \"\\n%10ld: %ld\", (long)match, (long)(offset+oldpc)); } \\\n+  }\n+\n+#define TABLE_SWITCH \\\n+  { jint default_offset = IMMEDIATE_s4; \\\n+    jint low = IMMEDIATE_s4; jint high = IMMEDIATE_s4; \\\n+    fprintf (out, \" low==%d, high=%ddefault=%d\", \\\n+      low, high, default_offset+oldpc); \\\n+    for (; low <= high; low++) { \\\n+     jint offset = IMMEDIATE_s4; \\\n+     fprintf (out, \"\\n%10ld: %ld\", (long)low, (long)(offset+oldpc)); } \\\n+  }\n+\n+#define SPECIAL(OPERAND_TYPE, OPERAND_VALUE) \\\n+  SPECIAL_##OPERAND_VALUE(OPERAND_TYPE)\n+\n+#define SPECIAL_IINC(OPERAND_TYPE) \\\n+  INT_temp = IMMEDIATE_u1; \\\n+  fprintf (out, \"%d %d\", INT_temp, IMMEDIATE_s1)\n+\n+#define SPECIAL_WIDE(OPERAND_TYPE) \\\n+  INT_temp = IMMEDIATE_u1; fprintf (out, \"%d\", INT_temp)\n+\n+#define SPECIAL_EXIT(OPERAND_TYPE) /* nothing */\n+#define SPECIAL_ENTER(OPERAND_TYPE) /* nothing */\n+#define SPECIAL_BREAK(OPERAND_TYPE) /* nothing */\n+#define SPECIAL_THROW(OPERAND_TYPE) /* nothing */\n+\n+#define IMPL(OPERAND_TYPE, OPERAND_VALUE) \\\n+  fprintf (out, \" %d\", IMMEDIATE_u##OPERAND_VALUE)\n+\n+#define COND(OPERAND_TYPE, OPERAND_VALUE) \\\n+   TEST(OPERAND_TYPE, OPERAND_VALUE)\n+\n+#include \"javaop.def\"\n+\tdefault:\n+\t  fprintf (out, \"%3d: unknown(%3d)\\n\", oldpc, byte_ops[PC]);\n+\t}\n+    }\n+\n+  /* Print exception table. */\n+  i = GET_u2(byte_ops+len);\n+  if (i > 0)\n+    {\n+      unsigned char *ptr = byte_ops+len+2;\n+      fprintf (out, \"Exceptions (count: %d):\\n\", i);\n+      for (; --i >= 0;  ptr+= 8)\n+\t{\n+\t  int start_pc = GET_u2 (ptr);\n+\t  int end_pc = GET_u2 (ptr+2);\n+\t  int handler_pc = GET_u2 (ptr+4);\n+\t  int catch_type = GET_u2 (ptr+6);\n+\t  fprintf (out, \"  start: %d, end: %d, handler: %d, type: %d\",\n+\t\t   start_pc, end_pc, handler_pc, catch_type);\n+\t  if (catch_type == 0)\n+\t    fputs (\" /* finally */\", out);\n+\t  else\n+\t    {\n+\t      fputc('=', out);\n+\t      print_constant_terse (out, jcf, catch_type, CONSTANT_Class);\n+\t    }\n+\t  fputc ('\\n', out);\n+\t}\n+    }\n+}"}, {"sha": "931f34eaec5afcc60201cc6ba40d8c82733b7823", "filename": "gcc/java/jcf-io.c", "status": "added", "additions": 574, "deletions": 0, "changes": 574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,574 @@\n+/* Utility routines for finding and reading Java(TM) .class files.\n+   Copyright (C) 1996  Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Written by Per Bothner <bothner@cygnus.com>, February 1996. */\n+\n+#include <stdio.h>\n+\n+#define ENABLE_UNZIP 1\n+\n+#include \"jcf.h\"\n+#ifdef __STDC__\n+#include <stdlib.h>\n+#endif\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <sys/wait.h>\n+#include <errno.h>\n+#include <fcntl.h>\n+\n+/* DOS brain-damage */\n+#ifndef O_BINARY\n+#define O_BINARY 0 /* MS-DOS brain-damage */\n+#endif\n+\n+char *classpath;\n+\n+int\n+DEFUN(jcf_unexpected_eof, (jcf, count),\n+      JCF *jcf AND int count)\n+{\n+  if (jcf->filename)\n+    fprintf (stderr, \"Premature end of .class file %s.\\n\", jcf->filename);\n+  else\n+    fprintf (stderr, \"Premature end of .class file <stdin>.\\n\");\n+  exit (-1);\n+}\n+\n+void\n+DEFUN(jcf_trim_old_input, (jcf),\n+      JCF *jcf)\n+{\n+  int count = jcf->read_ptr - jcf->buffer;\n+  if (count > 0)\n+    {\n+      memmove (jcf->buffer, jcf->read_ptr, jcf->read_end - jcf->read_ptr);\n+      jcf->read_ptr -= count;\n+      jcf->read_end -= count;\n+    }\n+}\n+\n+int\n+DEFUN(jcf_filbuf_from_stdio, (jcf, count),\n+      JCF *jcf AND int count)\n+{\n+  FILE *file = (FILE*) (jcf->read_state);\n+  if (count > jcf->buffer_end - jcf->read_ptr)\n+    {\n+      JCF_u4 old_read_ptr = jcf->read_ptr - jcf->buffer;\n+      JCF_u4 old_read_end = jcf->read_end - jcf->buffer;\n+      JCF_u4 old_size = jcf->buffer_end - jcf->buffer;\n+      JCF_u4 new_size = (old_size == 0 ? 2000 : 2 * old_size) + count;\n+      unsigned char *new_buffer = jcf->buffer == NULL ? ALLOC (new_size)\n+\t: REALLOC (jcf->buffer, new_size);\n+      jcf->buffer = new_buffer;\n+      jcf->buffer_end = new_buffer + new_size;\n+      jcf->read_ptr = new_buffer + old_read_ptr;\n+      jcf->read_end = new_buffer + old_read_end;\n+    }\n+  count -= jcf->read_end - jcf->read_ptr;\n+  if (count <= 0)\n+    return 0;\n+  if (fread (jcf->read_end, 1, count, file) != count)\n+    jcf_unexpected_eof (jcf, count);\n+  jcf->read_end += count;\n+  return 0;\n+}\n+\n+#if ENABLE_UNZIP\n+#include \"zipfile.h\"\n+\n+struct ZipFileCache *SeenZipFiles = NULL;\n+\n+int\n+DEFUN(open_in_zip, (jcf, \n+zipfile, zipmember),\n+      JCF *jcf AND const char *zipfile AND const char *zipmember)\n+{\n+  struct ZipFileCache* zipf;\n+  ZipDirectory *zipd;\n+  int i, len;\n+  for (zipf = SeenZipFiles; ; zipf = zipf->next)\n+    {\n+      if (zipf == NULL)\n+\t{\n+\t  char magic [4];\n+\t  int fd = open (zipfile, O_RDONLY | O_BINARY);\n+\t  if (read (fd, magic, 4) != 4 || GET_u4 (magic) != (JCF_u4)ZIPMAGIC)\n+\t    return -1;\n+\t  lseek (fd, 0L, SEEK_SET);\n+\t  zipf = ALLOC (sizeof (struct ZipFileCache) + strlen (zipfile) + 1);\n+\t  zipf->next = SeenZipFiles;\n+\t  zipf->name = (char*)(zipf+1);\n+\t  strcpy (zipf->name, zipfile);\n+\t  SeenZipFiles = zipf;\n+\t  zipf->z.fd = fd;\n+\t  if (fd == -1)\n+\t    {\n+\t      /* A missing zip file is not considered an error. */\n+\t      zipf->z.count = 0;\n+\t      zipf->z.dir_size = 0;\n+\t      zipf->z.central_directory = NULL;\n+\t      return -1;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (read_zip_archive (&zipf->z) != 0)\n+\t\treturn -2; /* This however should be an error - FIXME */\n+\t    }\n+\t  break;\n+\t}\n+      if (strcmp (zipf->name, zipfile) == 0)\n+\tbreak;\n+    }\n+\n+  if (!zipmember)\n+    return 0;\n+\n+  len = strlen (zipmember);\n+  \n+  zipd = (struct ZipDirectory*) zipf->z.central_directory;\n+  for (i = 0; i < zipf->z.count; i++, zipd = ZIPDIR_NEXT (zipd))\n+    {\n+      if (len == zipd->filename_length &&\n+\t  strncmp (ZIPDIR_FILENAME (zipd), zipmember, len) == 0)\n+\t{\n+\t  JCF_ZERO (jcf);\n+\t  jcf->buffer = ALLOC (zipd->size);\n+\t  jcf->buffer_end = jcf->buffer + zipd->size;\n+\t  jcf->read_ptr = jcf->buffer;\n+\t  jcf->read_end = jcf->buffer_end;\n+\t  jcf->filbuf = jcf_unexpected_eof;\n+\t  jcf->filename = (char *) strdup (zipfile);\n+\t  jcf->classname = (char *) strdup (zipmember);\n+\t  jcf->zipd = (void *)zipd;\n+\t  if (lseek (zipf->z.fd, zipd->filestart, 0) < 0\n+\t      || read (zipf->z.fd, jcf->buffer, zipd->size) != zipd->size)\n+\t    return -2;\n+\t  return 0;\n+\t}\n+    }\n+  return -1;\n+}\n+#endif /* ENABLE_UNZIP */\n+\n+#if JCF_USE_STDIO\n+char*\n+DEFUN(open_class, (filename, jcf, stream),\n+      char *filename AND JCF *jcf AND FILE* stream)\n+{\n+  if (jcf)\n+    {\n+      JCF_ZERO (jcf);\n+      jcf->buffer = NULL;\n+      jcf->buffer_end = NULL;\n+      jcf->read_ptr = NULL;\n+      jcf->read_end = NULL;\n+      jcf->read_state = stream;\n+      jcf->filbuf = jcf_filbuf_from_stdio;\n+    }\n+  else\n+    fclose (stream);\n+  return filename;\n+}\n+#else\n+char*\n+DEFUN(open_class, (filename, jcf, fd),\n+      char *filename AND JCF *jcf AND int fd)\n+{\n+  if (jcf)\n+    {\n+      struct stat stat_buf;\n+      if (fstat (fd, &stat_buf) != 0\n+\t  || ! S_ISREG (stat_buf.st_mode))\n+\t{\n+\t  perror (\"Could not figure length of .class file\");\n+\t  return NULL;\n+\t}\n+      JCF_ZERO (jcf);\n+      jcf->buffer = ALLOC (stat_buf.st_size);\n+      jcf->buffer_end = jcf->buffer + stat_buf.st_size;\n+      jcf->read_ptr = jcf->buffer;\n+      jcf->read_end = jcf->buffer_end;\n+      jcf->read_state = NULL;\n+      jcf->filename = filename;\n+      if (read (fd, jcf->buffer, stat_buf.st_size) != stat_buf.st_size)\n+\t{\n+\t  perror (\"Failed to read .class file\");\n+\t  return NULL;\n+\t}\n+      close (fd);\n+      jcf->filbuf = jcf_unexpected_eof;\n+    }\n+  else\n+    close (fd);\n+  return filename;\n+}\n+#endif\n+\n+\n+char *\n+DEFUN(find_classfile, (filename_length, jcf),\n+      char *filename AND JCF *jcf)\n+{\n+#if JCF_USE_STDIO\n+  FILE *stream = fopen (filename, \"rb\");\n+  if (stream == NULL)\n+    return NULL;\n+  return open_class (arg, jcf, stream);\n+#else\n+  int fd = open (filename, O_RDONLY | O_BINARY);\n+  if (fd < 0)\n+    return NULL;\n+  return open_class (filename, jcf, fd);\n+#endif\n+}\n+\n+/* Returns a freshly malloc'd string with the fully qualified pathname\n+   of the .class file for the class CLASSNAME.  Returns NULL on\n+   failure.  If JCF != NULL, it is suitably initialized.  With\n+   DO_CLASS_FILE set to 1, search a .class/.java file named after\n+   CLASSNAME, otherwise, search a ZIP directory entry named after\n+   CLASSNAME.  */\n+\n+char *\n+DEFUN(find_class, (classname, classname_length, jcf, do_class_file),\n+      const char *classname AND int classname_length AND JCF *jcf AND int do_class_file)\n+\n+{\n+#if JCF_USE_STDIO\n+  FILE *stream;\n+#else\n+  int fd;\n+#endif\n+  int i, j, k, java, class;\n+  struct stat java_buf, class_buf;\n+\n+  /* Allocate and zero out the buffer, since we don't explicitly put a\n+     null pointer when we're copying it below.  */\n+  int buflen = strlen (classpath) + classname_length + 10;\n+  char *buffer = (char *) ALLOC (buflen);\n+  bzero (buffer, buflen);\n+\n+  jcf->java_source = jcf->outofsynch = 0;\n+  for (j = 0; classpath[j] != '\\0'; )\n+    {\n+      for (i = 0; classpath[j] != ':' && classpath[j] != '\\0'; i++, j++)\n+\tbuffer[i] = classpath[j];\n+      if (classpath[j] == ':')\n+\tj++;\n+      if (i > 0)  /* Empty directory is redundant */\n+\t{\n+\t  int dir_len;\n+\t  if (buffer[i-1] != '/')\n+\t    buffer[i++] = '/';\n+\t  dir_len = i-1;\n+\t  for (k = 0; k < classname_length; k++, i++)\n+\t    {\n+\t      char ch = classname[k];\n+\t      buffer[i] = ch == '.' ? '/' : ch;\n+\t    }\n+\t  if (do_class_file)\n+\t    strcpy (buffer+i, \".class\");\n+#if ENABLE_UNZIP\n+\t  if (dir_len > 4\n+\t      && buffer[dir_len-4] == '.' && buffer[dir_len-3] == 'z'\n+\t      && buffer[dir_len-2] == 'i' && buffer[dir_len-1] == 'p')\n+\t    {\n+\t      int err_code;\n+\t      JCF _jcf;\n+\t      if (!do_class_file)\n+\t\tstrcpy (buffer+i, \"/\");\n+\t      buffer[dir_len] = '\\0';\n+\t      if (do_class_file)\n+\t\tSOURCE_FRONTEND_DEBUG \n+\t\t  ((\"Trying [...%s]:%s\", \n+\t\t    &buffer[dir_len-(dir_len > 15 ? 15 : dir_len)], \n+\t\t    buffer+dir_len+1));\n+\t      if (jcf == NULL)\n+\t\tjcf = &_jcf;\n+\t      err_code = open_in_zip (jcf, buffer, buffer+dir_len+1);\n+\t      if (err_code == 0)\n+\t\t{\n+\t\t  if (!do_class_file)\n+\t\t    jcf->seen_in_zip = 1;\n+\t\t  else\n+\t\t    {\n+\t\t      buffer[dir_len] = '(';\n+\t\t      strcpy (buffer+i, \".class)\");\n+\t\t    }\n+\t\t  if (jcf == &_jcf)\n+\t\t    JCF_FINISH (jcf);\n+\t\t  return buffer;\n+\t\t}\n+\t      else\n+\t\tcontinue;\n+\t    }\n+#endif\n+\t  /* If we do directories, do them here */\n+\t  if (!do_class_file)\n+\t    {\n+\t      struct stat dir_buff;\n+\t      int dir;\n+\t      buffer[i] = '\\0';\t/* Was previously unterminated here. */\n+\t      if (!(dir = stat (buffer, &dir_buff)))\n+\t\t{\n+\t\t  jcf->seen_in_zip = 0;\n+\t\t  goto found;\n+\t\t}\n+\t    }\n+\t  \n+\t  /* Check for out of synch .class/.java files */\n+\t  class = stat (buffer, &class_buf);\n+\t  strcpy (buffer+i, \".java\");\n+\t  java = stat (buffer, &java_buf);\n+\t  if ((!java && !class) && java_buf.st_mtime >= class_buf.st_mtime)\n+\t    jcf->outofsynch = 1;\n+#if JCF_USE_STDIO\n+\t  if (!class)\n+\t    {\n+\t      strcpy (buffer+i, \".class\");\n+\t      SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n+\t      stream = fopen (buffer, \"rb\");\n+\t      if (stream)\n+\t\tgoto found;\n+\t    }\n+\t  /* Give .java a try, if necessary */\n+\t  if (!java)\n+\t    {\n+\t      strcpy (buffer+i, \".java\");\n+\t      SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n+\t      stream = fopen (buffer, \"r\");\n+\t      if (stream)\n+\t\t{\n+\t\t  jcf->java_source = 1;\n+\t\t  goto found;\n+\t\t}\n+\t    }\n+#else\n+\t  if (!class)\n+\t    {\n+\t      strcpy (buffer+i, \".class\");\n+\t      SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n+\t      fd = open (buffer, O_RDONLY | O_BINARY);\n+\t      if (fd >= 0)\n+\t\tgoto found;\n+\t    }\n+\t  /* Give .java a try, if necessary */\n+\t  if (!java)\n+\t    {\n+\t      if (do_class_file)\n+\t\tstrcpy (buffer+i, \".java\");\n+\t      SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n+\t      fd = open (buffer, O_RDONLY | O_BINARY);\n+\t      if (fd >= 0)\n+\t\t{\n+\t\t  jcf->java_source = 1;\n+\t\t  goto found;\n+\t\t}\n+\t    }\n+#endif\n+\t}\n+    }\n+  free (buffer);\n+  return NULL;\n+ found:\n+#if JCF_USE_STDIO\n+  if (jcf->java_source)\n+    return NULL;\t\t/* FIXME */\n+  else\n+    return open_class (buffer, jcf, stream);\n+#else\n+  if (jcf->java_source)\n+    {\n+      JCF_ZERO (jcf);\t\t/* JCF_FINISH relies on this */\n+      jcf->java_source = 1;\n+      jcf->filename = (char *) strdup (buffer);\n+      close (fd);\t\t/* We use STDIO for source file */\n+    }\n+  else if (do_class_file)\n+    buffer = open_class (buffer, jcf, fd);\n+  jcf->classname = (char *) ALLOC (classname_length + 1);\n+  strncpy (jcf->classname, classname, classname_length + 1);\n+  jcf->classname = (char *) strdup (classname);\n+  return buffer;\n+#endif\n+}\n+\n+void\n+DEFUN(jcf_print_char, (stream, ch),\n+      FILE *stream AND int ch)\n+{\n+  switch (ch)\n+    {\n+    case '\\'':\n+    case '\\\\':\n+    case '\\\"':\n+      fprintf (stream, \"\\\\%c\", ch);\n+      break;\n+    case '\\n':\n+      fprintf (stream, \"\\\\n\");\n+      break;\n+    case '\\t':\n+      fprintf (stream, \"\\\\t\");\n+      break;\n+    case '\\r':\n+      fprintf (stream, \"\\\\r\");\n+      break;\n+    default:\n+      if (ch >= ' ' && ch < 127)\n+\tputc (ch, stream);\n+      else if (ch < 256)\n+\tfprintf (stream, \"\\\\%03x\", ch);\n+      else\n+\tfprintf (stream, \"\\\\u%04x\", ch);\n+    }\n+}\n+\n+/* Print UTF8 string at STR of length LENGTH bytes to STREAM. */\n+\n+void\n+DEFUN(jcf_print_utf8, (stream, str, length),\n+      FILE *stream AND register unsigned char *str AND int length)\n+{\n+  unsigned char* limit = str + length;\n+  while (str < limit)\n+    {\n+      int ch = UTF8_GET (str, limit);\n+      if (ch < 0)\n+\t{\n+\t  fprintf (stream, \"\\\\<invalid>\");\n+\t  return;\n+\t}\n+      jcf_print_char (stream, ch);\n+    }\n+}\n+\n+/* Same as jcf_print_utf8, but print IN_CHAR as OUT_CHAR. */\n+\n+void\n+DEFUN(jcf_print_utf8_replace, (stream, str, length, in_char, out_char),\n+      FILE *stream AND unsigned char *str AND int length\n+      AND int in_char AND int out_char)\n+{\n+\n+  int i;/* FIXME - actually handle Unicode! */\n+  for (i = 0; i < length; i++)\n+    {\n+      int ch = str[i];\n+      jcf_print_char (stream, ch == in_char ? out_char : ch);\n+    }\n+}\n+\n+/* Check that all the cross-references in the constant pool are\n+   valid.  Returns 0 on success.\n+   Otherwise, returns the index of the (first) invalid entry. */\n+\n+int\n+DEFUN(verify_constant_pool, (jcf),\n+      JCF *jcf)\n+{\n+  int i, n;\n+  for (i = 1; i < JPOOL_SIZE (jcf); i++)\n+    {\n+      switch (JPOOL_TAG (jcf, i))\n+\t{\n+\tcase CONSTANT_NameAndType:\n+\t  n = JPOOL_USHORT2 (jcf, i);\n+\t  if (n <= 0 || n >= JPOOL_SIZE(jcf)\n+\t      || JPOOL_TAG (jcf, n) != CONSTANT_Utf8)\n+\t    return i;\n+\t  /* ... fall through ... */\n+\tcase CONSTANT_Class:\n+\tcase CONSTANT_String:\n+\t  n = JPOOL_USHORT1 (jcf, i);\n+\t  if (n <= 0 || n >= JPOOL_SIZE(jcf)\n+\t      || JPOOL_TAG (jcf, n) != CONSTANT_Utf8)\n+\t    return i;\n+\t  break;\n+\tcase CONSTANT_Fieldref:\n+\tcase CONSTANT_Methodref:\n+\tcase CONSTANT_InterfaceMethodref:\n+\t  n = JPOOL_USHORT1 (jcf, i);\n+\t  if (n <= 0 || n >= JPOOL_SIZE(jcf)\n+\t      || JPOOL_TAG (jcf, n) != CONSTANT_Class)\n+\t    return i;\n+\t  n = JPOOL_USHORT2 (jcf, i);\n+\t  if (n <= 0 || n >= JPOOL_SIZE(jcf)\n+\t      || JPOOL_TAG (jcf, n) != CONSTANT_NameAndType)\n+\t    return i;\n+\t  break;\n+\tcase CONSTANT_Long:\n+\tcase CONSTANT_Double:\n+\t  i++;\n+\t  break;\n+\tcase CONSTANT_Float:\n+\tcase CONSTANT_Integer:\n+\tcase CONSTANT_Utf8:\n+\tcase CONSTANT_Unicode:\n+\t  break;\n+\tdefault:\n+\t  return i;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+void\n+DEFUN(format_uint, (buffer, value, base),\n+      char *buffer AND uint64 value AND int base)\n+{\n+#define WRITE_BUF_SIZE (4 + sizeof(uint64) * 8)\n+  char buf[WRITE_BUF_SIZE];\n+  register char *buf_ptr = buf+WRITE_BUF_SIZE; /* End of buf. */\n+  int chars_written;\n+  int i;\n+\n+  /* Now do the actual conversion, placing the result at the *end* of buf. */\n+  /* Note this code does not pretend to be optimized. */\n+  do {\n+    int digit = value % base;\n+    static char digit_chars[] = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n+    *--buf_ptr = digit_chars[digit];\n+    value /= base;\n+  } while (value != 0);\n+\n+  chars_written = buf+WRITE_BUF_SIZE - buf_ptr;\n+  for (i = 0; i < chars_written; i++)\n+    buffer[i] = *buf_ptr++;\n+  buffer[i] = 0;\n+}\n+\n+void\n+DEFUN(format_int, (buffer, value, base),\n+      char *buffer AND jlong value AND int base)\n+{\n+  uint64 abs_value;\n+  if (value < 0)\n+    {\n+      abs_value = -(uint64)value;\n+      *buffer++ = '-';\n+    }\n+  else\n+    abs_value = (uint64) value;\n+  format_uint (buffer, abs_value, base);\n+}"}, {"sha": "0e8c51ccbde745c4dcc24e38706ad7b42de2d4ae", "filename": "gcc/java/jcf-parse.c", "status": "added", "additions": 917, "deletions": 0, "changes": 917, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,917 @@\n+/* Parser for Java(TM) .class files.\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Written by Per Bothner <bothner@cygnus.com> */\n+\n+#include <stdio.h>\n+#include <ctype.h>\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"obstack.h\"\n+#include \"flags.h\"\n+#include \"java-except.h\"\n+#include \"input.h\"\n+#include \"java-tree.h\"\n+\n+/* A CONSTANT_Utf8 element is converted to an IDENTIFIER_NODE at parse time. */\n+#define JPOOL_UTF(JCF, INDEX) CPOOL_UTF(&(JCF)->cpool, INDEX)\n+#define JPOOL_UTF_LENGTH(JCF, INDEX) IDENTIFIER_LENGTH (JPOOL_UTF (JCF, INDEX))\n+#define JPOOL_UTF_DATA(JCF, INDEX) \\\n+  ((unsigned char*) IDENTIFIER_POINTER (JPOOL_UTF (JCF, INDEX)))\n+#define HANDLE_CONSTANT_Utf8(JCF, INDEX, LENGTH) \\\n+  do { \\\n+    unsigned char save;  unsigned char *text; \\\n+    JCF_FILL (JCF, (LENGTH)+1); /* Make sure we read 1 byte beyond string. */ \\\n+    text = (JCF)->read_ptr; \\\n+    save = text[LENGTH]; \\\n+    text[LENGTH] = 0; \\\n+    (JCF)->cpool.data[INDEX] = (jword) get_identifier (text); \\\n+    text[LENGTH] = save; \\\n+    JCF_SKIP (JCF, LENGTH); } while (0)\n+\n+#include \"jcf.h\"\n+#ifdef __STDC__\n+/* For getenv */\n+#include <stdlib.h>\n+#endif\n+\n+#ifndef SEEK_SET\n+#include <unistd.h>\n+#endif\n+\n+extern struct obstack *saveable_obstack;\n+extern struct obstack temporary_obstack;\n+extern struct obstack permanent_obstack;\n+\n+/* The class we are currently processing. */\n+tree current_class = NULL_TREE;\n+\n+/* The class we started with. */\n+tree main_class = NULL_TREE;\n+\n+/* The FIELD_DECL for the current field. */\n+static tree current_field = NULL_TREE;\n+\n+static tree current_method = NULL_TREE;\n+\n+static tree give_name_to_class PROTO ((JCF *jcf, int index));\n+\n+void parse_zip_file_entries (void);\n+void process_zip_dir();\n+\n+/* Source file compilation declarations */\n+static void parse_source_file ();\n+extern int java_error_count;\n+#define java_parse_abort_on_error()\t\t\\\n+  {\t\t\t\t\t\t\\\n+     if (java_error_count)\t\t\t\\\n+       {\t\t\t\t\t\\\n+         java_report_errors ();\t\t\t\\\n+\t java_pop_parser_context ();\t\t\\\n+\t return;\t\t\t\t\\\n+       }\t\t\t\t\t\\\n+   }\n+\n+/* Handle \"SourceFile\" attribute. */\n+\n+void\n+set_source_filename (jcf, index)\n+     JCF *jcf;\n+     int index;\n+{\n+  tree sfname_id = get_name_constant (jcf, index);\n+  char *sfname = IDENTIFIER_POINTER (sfname_id);\n+  if (input_filename != NULL)\n+    {\n+      int old_len = strlen (input_filename);\n+      int new_len = IDENTIFIER_LENGTH (sfname_id);\n+      /* Use the current input_filename (derived from the class name)\n+\t if it has a directory prefix, but otherwise matches sfname. */\n+      if (old_len > new_len\n+\t  && strcmp (sfname, input_filename + old_len - new_len) == 0\n+\t  && (input_filename[old_len - new_len - 1] == '/'\n+\t      || input_filename[old_len - new_len - 1] == '\\\\'))\n+\treturn;\n+    }\n+  input_filename = sfname;\n+  DECL_SOURCE_FILE (TYPE_NAME (current_class)) = sfname;\n+  if (current_class == main_class) main_input_filename = input_filename;\n+}\n+\n+#define HANDLE_SOURCEFILE(INDEX) set_source_filename (jcf, INDEX)\n+\n+#define HANDLE_CLASS_INFO(ACCESS_FLAGS, THIS, SUPER, INTERFACES_COUNT) \\\n+{ tree super_class = SUPER==0 ? NULL_TREE : get_class_constant (jcf, SUPER); \\\n+  current_class = give_name_to_class (jcf, THIS); \\\n+  set_super_info (ACCESS_FLAGS, current_class, super_class, INTERFACES_COUNT);}\n+\n+#define HANDLE_CLASS_INTERFACE(INDEX) \\\n+  add_interface (current_class, get_class_constant (jcf, INDEX))\n+\n+#define HANDLE_START_FIELD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT) \\\n+{ int sig_index = SIGNATURE; \\\n+  current_field = add_field (current_class, get_name_constant (jcf, NAME), \\\n+\t\t\t     parse_signature (jcf, sig_index), ACCESS_FLAGS); \\\n+ set_java_signature (TREE_TYPE (current_field), JPOOL_UTF (jcf, sig_index)); }\n+\n+#define HANDLE_END_FIELDS() \\\n+  (current_field = NULL_TREE)\n+\n+#define HANDLE_CONSTANTVALUE(INDEX) \\\n+{ tree constant;  int index = INDEX; \\\n+  if (JPOOL_TAG (jcf, index) == CONSTANT_String) { \\\n+    tree name = get_name_constant (jcf, JPOOL_USHORT1 (jcf, index)); \\\n+    constant = build_utf8_ref (name); \\\n+  } \\\n+  else \\\n+    constant = get_constant (jcf, index); \\\n+  set_constant_value (current_field, constant); }\n+\n+#define HANDLE_METHOD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT) \\\n+ (current_method = add_method (current_class, ACCESS_FLAGS, \\\n+\t\t\t       get_name_constant (jcf, NAME), \\\n+\t\t\t       get_name_constant (jcf, SIGNATURE)), \\\n+  DECL_LOCALVARIABLES_OFFSET (current_method) = 0, \\\n+  DECL_LINENUMBERS_OFFSET (current_method) = 0)\n+\n+#define HANDLE_END_METHODS() \\\n+{ tree handle_type = CLASS_TO_HANDLE_TYPE (current_class); \\\n+  if (handle_type != current_class) layout_type (handle_type); }\n+\n+#define HANDLE_CODE_ATTRIBUTE(MAX_STACK, MAX_LOCALS, CODE_LENGTH) \\\n+{ DECL_MAX_STACK (current_method) = (MAX_STACK); \\\n+  DECL_MAX_LOCALS (current_method) = (MAX_LOCALS); \\\n+  DECL_CODE_LENGTH (current_method) = (CODE_LENGTH); \\\n+  DECL_CODE_OFFSET (current_method) = JCF_TELL (jcf); }\n+\n+#define HANDLE_LOCALVARIABLETABLE_ATTRIBUTE(COUNT) \\\n+{ int n = (COUNT); \\\n+  DECL_LOCALVARIABLES_OFFSET (current_method) = JCF_TELL (jcf) - 2; \\\n+  JCF_SKIP (jcf, n * 10); }\n+\n+#define HANDLE_LINENUMBERTABLE_ATTRIBUTE(COUNT) \\\n+{ int n = (COUNT); \\\n+  DECL_LINENUMBERS_OFFSET (current_method) = JCF_TELL (jcf) - 2; \\\n+  JCF_SKIP (jcf, n * 4); }\n+\n+#include \"jcf-reader.c\"\n+\n+static int yydebug;\n+\n+tree\n+parse_signature (jcf, sig_index)\n+     JCF *jcf;\n+     int sig_index;\n+{\n+  if (sig_index <= 0 || sig_index >= JPOOL_SIZE(jcf)\n+      || JPOOL_TAG (jcf, sig_index) != CONSTANT_Utf8)\n+    fatal (\"invalid field/method signature\");\n+  else\n+    {\n+      return parse_signature_string (JPOOL_UTF_DATA (jcf, sig_index),\n+\t\t\t\t     JPOOL_UTF_LENGTH (jcf, sig_index));\n+    }\n+}\n+\n+void\n+init_lex ()\n+{\n+  /* Make identifier nodes long enough for the language-specific slots.  */\n+  set_identifier_size (sizeof (struct lang_identifier));\n+}\n+\n+void\n+set_yydebug (value)\n+     int value;\n+{\n+  yydebug = value;\n+}\n+\n+tree\n+get_constant (jcf, index)\n+  JCF *jcf;\n+  int index;\n+{\n+  tree value;\n+  int tag;\n+  if (index <= 0 || index >= JPOOL_SIZE(jcf))\n+    goto bad;\n+  tag = JPOOL_TAG (jcf, index);\n+  if ((tag & CONSTANT_ResolvedFlag) || tag == CONSTANT_Utf8)\n+    return (tree) jcf->cpool.data[index];\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  switch (tag)\n+    {\n+    case CONSTANT_Integer:\n+      {\n+\tjint num = JPOOL_INT(jcf, index);\n+\tvalue = build_int_2 (num, num < 0 ? -1 : 0);\n+\tTREE_TYPE (value) = int_type_node;\n+\tbreak;\n+      }\n+    case CONSTANT_Long:\n+      {\n+\tjint num = JPOOL_INT (jcf, index);\n+\tHOST_WIDE_INT lo, hi;\n+\tlshift_double (num, 0, 32, 64, &lo, &hi, 0);\n+\tnum = JPOOL_INT (jcf, index+1);\n+\tadd_double (lo, hi, num, 0, &lo, &hi);\n+\tvalue = build_int_2 (lo, hi);\n+\tTREE_TYPE (value) = long_type_node;\n+\tforce_fit_type (value, 0);\n+\tbreak;\n+      }\n+#if TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n+    case CONSTANT_Float:\n+      {\n+\tjint num = JPOOL_INT(jcf, index);\n+\tREAL_VALUE_TYPE d;\n+#ifdef REAL_ARITHMETIC\n+\td = REAL_VALUE_FROM_TARGET_SINGLE (num);\n+#else\n+\tunion { float f;  jint i; } u;\n+\tu.i = num;\n+\td = u.f;\n+#endif\n+\tvalue = build_real (float_type_node, d);\n+\tbreak;\n+      }\n+    case CONSTANT_Double:\n+      {\n+\tHOST_WIDE_INT num[2];\n+\tREAL_VALUE_TYPE d;\n+\tHOST_WIDE_INT lo, hi;\n+\tnum[0] = JPOOL_INT (jcf, index);\n+\tlshift_double (num[0], 0, 32, 64, &lo, &hi, 0);\n+\tnum[0] = JPOOL_INT (jcf, index+1);\n+\tadd_double (lo, hi, num[0], 0, &lo, &hi);\n+\tif (FLOAT_WORDS_BIG_ENDIAN)\n+\t  {\n+\t    num[0] = hi;\n+\t    num[1] = lo;\n+\t  }\n+\telse\n+\t  {\n+\t    num[0] = lo;\n+\t    num[1] = hi;\n+\t  }\n+#ifdef REAL_ARITHMETIC\n+\td = REAL_VALUE_FROM_TARGET_DOUBLE (num);\n+#else\n+\tunion { double d;  jint i[2]; } u;\n+\tu.i[0] = (jint) num[0];\n+\tu.i[1] = (jint) num[1];\n+\td = u.d;\n+#endif\n+\tvalue = build_real (double_type_node, d);\n+\tbreak;\n+      }\n+#endif /* TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT */\n+    case CONSTANT_String:\n+      {\n+\textern struct obstack *expression_obstack;\n+\ttree name = get_name_constant (jcf, JPOOL_USHORT1 (jcf, index));\n+\tchar *utf8_ptr = IDENTIFIER_POINTER (name);\n+\tunsigned char *str_ptr;\n+\tint utf8_len = IDENTIFIER_LENGTH (name);\n+\tunsigned char *str = (unsigned char*)utf8_ptr;\n+\tint i = utf8_len;\n+\tint str_len;\n+\n+\t/* Count the number of Unicode characters in the string,\n+\t   while checking for a malformed Utf8 string. */\n+\tfor (str_len = 0; i > 0; str_len++)\n+\t  {\n+\t    int char_len = UT8_CHAR_LENGTH (*str);\n+\t    if (char_len < 0 || char_len > 2 || char_len > i)\n+\t      fatal (\"bad string constant\");\n+\t    str += char_len;\n+\t    i -= char_len;\n+\t  }\n+\n+\tvalue = make_node (STRING_CST);\n+\tTREE_STRING_LENGTH (value) = 2 * str_len;\n+\tTREE_STRING_POINTER (value)\n+\t  = obstack_alloc (expression_obstack, 2 * str_len);\n+\tstr_ptr = (unsigned char *) TREE_STRING_POINTER (value);\n+\tstr = (unsigned char*)utf8_ptr;\n+\tfor (i = 0; i < str_len; i++)\n+\t  {\n+\t    int char_value;\n+\t    int char_len = UT8_CHAR_LENGTH (*str);\n+\t    switch (char_len)\n+\t      {\n+\t      case 1:\n+\t\tchar_value = *str++;\n+\t\tbreak;\n+\t      case 2:\n+\t\tchar_value = *str++ & 0x1F;\n+\t\tchar_value = (char_value << 6) | (*str++ & 0x3F);\n+\t\tbreak;\n+\t      case 3:\n+\t\tchar_value = *str_ptr++ & 0x0F;\n+\t\tchar_value = (char_value << 6) | (*str++ & 0x3F);\n+\t\tchar_value = (char_value << 6) | (*str++ & 0x3F);\n+\t\tbreak;\n+\t      default:\n+\t\tgoto bad;\n+\t      }\n+\t    if (BYTES_BIG_ENDIAN)\n+\t      {\n+\t\t*str_ptr++ = char_value >> 8;\n+\t\t*str_ptr++ = char_value & 0xFF;\n+\t      }\n+\t    else\n+\t      {\n+\t\t*str_ptr++ = char_value & 0xFF;\n+\t\t*str_ptr++ = char_value >> 8;\n+\t      }\n+\t  }\n+      }\n+      break;\n+    default:\n+      goto bad;\n+    }\n+  pop_obstacks ();\n+  JPOOL_TAG(jcf, index) = tag | CONSTANT_ResolvedFlag;\n+  jcf->cpool.data [index] = (jword) value;\n+  return value;\n+ bad:\n+  fatal (\"bad value constant type %d, index %d\", \n+\t JPOOL_TAG( jcf, index ), index);\n+}\n+\n+tree\n+get_name_constant (jcf, index)\n+  JCF *jcf;\n+  int index;\n+{\n+  tree name = get_constant (jcf, index);\n+  if (TREE_CODE (name) != IDENTIFIER_NODE)\n+    fatal (\"bad nameandtype index %d\", index);\n+  return name;\n+}\n+\n+static tree\n+give_name_to_class (jcf, i)\n+     JCF *jcf;\n+     int i;\n+{\n+  if (i <= 0 || i >= JPOOL_SIZE(jcf)\n+      || JPOOL_TAG (jcf, i) != CONSTANT_Class)\n+    fatal (\"bad class index %d\", i);\n+  else\n+    {\n+      tree this_class;\n+      int j = JPOOL_USHORT1 (jcf, i);\n+      /* verify_constant_pool confirmed that j is a CONSTANT_Utf8. */\n+      tree class_name = unmangle_classname (JPOOL_UTF_DATA (jcf, j),\n+\t\t\t\t\t    JPOOL_UTF_LENGTH (jcf, j));\n+      this_class = lookup_class (class_name);\n+      input_filename = DECL_SOURCE_FILE (TYPE_NAME (this_class));\n+      lineno = 0;\n+      if (main_input_filename == NULL && jcf == main_jcf)\n+\tmain_input_filename = input_filename;\n+\n+      jcf->cpool.data[i] = (jword) this_class;\n+      JPOOL_TAG (jcf, i) = CONSTANT_ResolvedClass;\n+      return this_class;\n+    }\n+}\n+\n+/* Get the class of the CONSTANT_Class whose constant pool index is I. */\n+\n+tree\n+get_class_constant (JCF *jcf , int i)\n+{\n+  tree type;\n+  if (i <= 0 || i >= JPOOL_SIZE(jcf)\n+      || (JPOOL_TAG (jcf, i) & ~CONSTANT_ResolvedFlag) != CONSTANT_Class)\n+    fatal (\"bad class index %d\", i);\n+\n+  if (JPOOL_TAG (jcf, i) != CONSTANT_ResolvedClass)\n+    {\n+      int name_index = JPOOL_USHORT1 (jcf, i);\n+      /* verify_constant_pool confirmed that name_index is a CONSTANT_Utf8. */\n+      char *name = JPOOL_UTF_DATA (jcf, name_index);\n+      int nlength = JPOOL_UTF_LENGTH (jcf, name_index);\n+      if (name[0] == '[')  /* Handle array \"classes\". */\n+\t  type = parse_signature_string (name, nlength);\n+      else\n+        { \n+          tree cname = unmangle_classname (name, nlength);\n+          type = lookup_class (cname);\n+\t}\n+      jcf->cpool.data[i] = (jword) type;\n+      JPOOL_TAG (jcf, i) = CONSTANT_ResolvedClass;\n+    }\n+  else\n+    type = (tree) jcf->cpool.data[i];\n+  return type;\n+}\n+\n+void\n+fix_classpath ()\n+{\n+  static char default_path[] = DEFAULT_CLASS_PATH;\n+\n+  if (classpath == NULL)\n+    {\n+      classpath = (char *) getenv (\"CLASSPATH\");\n+      if (classpath == NULL)\n+\t{\n+\t  warning (\"CLASSPATH not set\");\n+\t  classpath = default_path;\n+\t}\n+    }\n+}\n+\n+void\n+DEFUN(jcf_out_of_synch, (jcf),\n+      JCF *jcf)\n+{\n+  char *source = strdup (jcf->filename);\n+  int i = strlen (source);\n+\n+  while (source[i] != '.')\n+    i--;\n+\n+  source [i] = '\\0';\n+  warning (\"Class file `%s' out of synch with `%s.java'\", \n+\t   jcf->filename, source);\n+  free (source);\n+}\n+\n+/* Load CLASS_OR_NAME. CLASS_OR_NAME can be a mere identifier if\n+   called from the parser, otherwise it's a RECORD_TYPE node. If\n+   VERBOSE is 1, print error message on failure to load a class. */\n+\n+void\n+load_class (class_or_name, verbose)\n+     tree class_or_name;\n+     int verbose;\n+{\n+  JCF this_jcf, *jcf;\n+  tree name = (TREE_CODE (class_or_name) == IDENTIFIER_NODE ?\n+\t       class_or_name : DECL_NAME (TYPE_NAME (class_or_name)));\n+  tree save_current_class = current_class;\n+  char *save_input_filename = input_filename;\n+  JCF *save_current_jcf = current_jcf;\n+  long saved_pos;\n+  if (current_jcf->read_state)\n+    saved_pos = ftell (current_jcf->read_state);\n+\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+\n+  if (!classpath)\n+    fix_classpath ();\n+  /* Search in current zip first.  */\n+  if (find_in_current_zip (IDENTIFIER_POINTER (name),\n+\t\t\t   IDENTIFIER_LENGTH (name), &jcf) == 0)\n+    if (find_class (IDENTIFIER_POINTER (name), IDENTIFIER_LENGTH (name),\n+\t\t     &this_jcf, 1) == 0)\n+      {\n+\tif (verbose)\n+\t  {\n+\t    error (\"Cannot find class file class %s.\", \n+\t\t   IDENTIFIER_POINTER (name));\n+\t    TYPE_SIZE (class_or_name) = error_mark_node;\n+\t    if (!strcmp (classpath, DEFAULT_CLASS_PATH))\n+\t      fatal (\"giving up\");\n+\t    pop_obstacks ();\t/* FIXME: one pop_obstack() per function */\n+\t  }\n+\treturn;\n+      }\n+    else\n+      {\n+        this_jcf.seen_in_zip = 0;\n+        current_jcf = &this_jcf;\n+\tif (this_jcf.outofsynch)\n+\t  jcf_out_of_synch (current_jcf);\n+      }\n+  else\n+    current_jcf = jcf;\n+\n+  if (current_jcf->java_source)\n+    jcf_parse_source (current_jcf);\n+  else {\n+    int saved_lineno = lineno;\n+    input_filename = current_jcf->filename;\n+    jcf_parse (current_jcf);\n+    lineno = saved_lineno;\n+  }\n+\n+  if (!current_jcf->seen_in_zip)\n+    JCF_FINISH (current_jcf);\n+/*  DECL_IGNORED_P (TYPE_NAME (class_or_name)) = 1;*/\n+  pop_obstacks ();\n+\n+  current_class = save_current_class;\n+  input_filename = save_input_filename;\n+  current_jcf = save_current_jcf;\n+  if (current_jcf->read_state)\n+    fseek (current_jcf->read_state, saved_pos, SEEK_SET);\n+}\n+\n+/* Parse a source file when JCF refers to a source file. This piece\n+   needs further work as far as error handling and report. */\n+\n+int\n+jcf_parse_source (jcf)\n+     JCF *jcf;\n+{\n+  java_parser_context_save_global ();\n+\n+  input_filename = current_jcf->filename;\n+  if (!(finput = fopen (input_filename, \"r\")))\n+    fatal (\"input file `%s' just disappeared - jcf_parse_source\",\n+\t   input_filename);\n+\n+  parse_source_file (1);\t/* Parse only */\n+  if (current_class && TREE_TYPE (current_class))\n+    CLASS_FROM_SOURCE_P (TREE_TYPE (current_class)) = 1;\n+\n+  fclose (finput);\n+  java_parser_context_restore_global ();\n+}\n+\n+/* Parse the .class file JCF. */\n+\n+int\n+jcf_parse (jcf)\n+     JCF* jcf;\n+{\n+  int i, code;\n+\n+  if (jcf_parse_preamble (jcf) != 0)\n+    fatal (\"Not a valid Java .class file.\\n\");\n+  code = jcf_parse_constant_pool (jcf);\n+  if (code != 0)\n+    fatal (\"error while parsing constant pool\");\n+  code = verify_constant_pool (jcf);\n+  if (code > 0)\n+    fatal (\"error in constant pool entry #%d\\n\", code);\n+\n+  jcf_parse_class (jcf);\n+  if (main_class == NULL_TREE)\n+    main_class = current_class;\n+  if (! quiet_flag && TYPE_NAME (current_class))\n+    fprintf (stderr, \" class %s\",\n+\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))));\n+  CLASS_LOADED_P (current_class) = 1;\n+\n+  for (i = 1; i < JPOOL_SIZE(jcf); i++)\n+    {\n+      switch (JPOOL_TAG (jcf, i))\n+\t{\n+\tcase CONSTANT_Class:\n+\t  get_class_constant (jcf, i);\n+\t  break;\n+\t}\n+    }\n+  \n+  code = jcf_parse_fields (jcf);\n+  if (code != 0)\n+    fatal (\"error while parsing fields\");\n+  code = jcf_parse_methods (jcf);\n+  if (code != 0)\n+    fatal (\"error while parsing methods\");\n+  code = jcf_parse_final_attributes (jcf);\n+  if (code != 0)\n+    fatal (\"error while parsing final attributes\");\n+\n+  /* The fields of class_type_node are already in correct order. */\n+  if (current_class != class_type_node && current_class != object_type_node)\n+    TYPE_FIELDS (current_class) = nreverse (TYPE_FIELDS (current_class));\n+\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  layout_class (current_class);\n+  pop_obstacks ();\n+}\n+\n+void\n+init_outgoing_cpool ()\n+{\n+  current_constant_pool_data_ref = NULL_TREE; \n+  if (outgoing_cpool == NULL)\n+    {\n+      static CPool outgoing_cpool_buffer;\n+      outgoing_cpool = &outgoing_cpool_buffer;\n+      CPOOL_INIT(outgoing_cpool);\n+    }\n+  else\n+    {\n+      CPOOL_REINIT(outgoing_cpool);\n+    }\n+}\n+\n+void\n+parse_class_file ()\n+{\n+  tree method;\n+  char *save_input_filename = input_filename;\n+  int save_lineno = lineno;\n+\n+  input_filename = DECL_SOURCE_FILE (TYPE_NAME (current_class));\n+  lineno = 0;\n+  debug_start_source_file (input_filename);\n+  init_outgoing_cpool ();\n+\n+  for ( method = TYPE_METHODS (CLASS_TO_HANDLE_TYPE (current_class));\n+\tmethod != NULL_TREE; method = TREE_CHAIN (method))\n+    {\n+      JCF *jcf = current_jcf;\n+\n+      if (METHOD_NATIVE (method) || METHOD_ABSTRACT (method))\n+\tcontinue;\n+\n+      if (DECL_CODE_OFFSET (method) == 0)\n+\t{\n+\t  error (\"missing Code attribute\");\n+\t  continue;\n+\t}\n+\n+      lineno = 0;\n+      if (DECL_LINENUMBERS_OFFSET (method))\n+\t{\n+\t  register int i;\n+\t  register unsigned char *ptr;\n+\t  JCF_SEEK (jcf, DECL_LINENUMBERS_OFFSET (method));\n+\t  linenumber_count = i = JCF_readu2 (jcf);\n+\t  linenumber_table = ptr = jcf->read_ptr;\n+\n+\t  for (ptr += 2; --i >= 0; ptr += 4)\n+\t    {\n+\t      int line = GET_u2 (ptr);\n+\t      /* Set initial lineno lineno to smallest linenumber.\n+\t       * Needs to be set before init_function_start. */\n+\t      if (lineno == 0 || line < lineno)\n+\t\tlineno = line;\n+\t    }  \n+\t}\n+      else\n+\t{\n+\t  linenumber_table = NULL;\n+\t  linenumber_count = 0;\n+\t}\n+\n+      start_java_method (method);\n+\n+      give_name_to_locals (jcf);\n+\n+      /* Actually generate code. */\n+      expand_byte_code (jcf, method);\n+\n+      end_java_method ();\n+    }\n+\n+  if (flag_emit_class_files)\n+    write_classfile (current_class);\n+  make_class_data (current_class);\n+  register_class ();\n+  rest_of_decl_compilation (TYPE_NAME (current_class), (char*) 0, 1, 0);\n+\n+  debug_end_source_file (save_lineno);\n+  input_filename = save_input_filename;\n+  lineno = save_lineno;\n+}\n+\n+/* Parse a source file, as pointed by the current JCF. If PARSE_ONLY\n+   is non zero, we're not parsing a file found on the command line and\n+   we skip things related to code generation. */\n+\n+static void\n+parse_source_file (parse_only)\n+     int parse_only;\n+{\n+  lang_init_source (1);\t\t    /* Error msgs have no method prototypes */\n+  java_push_parser_context ();\n+  java_init_lex ();\t\t    /* Initialize the parser */\n+  java_parse_abort_on_error ();\n+  java_parse ();\t\t    /* Parse and build partial tree nodes. */\n+  java_parse_abort_on_error ();\n+  java_complete_class ();\t    /* Parse unsatisfied class decl. */\n+  java_parse_abort_on_error ();\n+  java_check_circular_reference (); /* Check on circular references */\n+  java_parse_abort_on_error ();\n+  java_check_methods ();            /* Check the methods */\n+  java_parse_abort_on_error ();\n+  java_layout_classes ();\n+  java_parse_abort_on_error ();\n+  if (!parse_only)\n+    {\n+      lang_init_source (2);\t        /* Error msgs have method prototypes */\n+      java_complete_expand_methods ();  /* Complete and expand method bodies */\n+      java_parse_abort_on_error ();\n+      java_expand_finals ();\t        /* Expand and check the finals */\n+      java_parse_abort_on_error ();\n+      java_check_final ();              /* Check unitialized final  */\n+      java_parse_abort_on_error ();\n+      if (! flag_emit_class_files)\n+\temit_register_class ();\n+      java_report_errors ();\t        /* Final step for this file */\n+    }\n+  if (flag_emit_class_files)\n+    write_classfile (current_class);\n+  java_pop_parser_context ();\n+}\n+\n+int\n+yyparse ()\n+{\n+  /* Everything migh be enclosed within a loop processing each file after\n+     the other one.  */\n+\n+  switch (jcf_figure_file_type (current_jcf))\n+    {\n+    case JCF_ZIP:\n+      parse_zip_file_entries ();\n+      emit_register_class ();\n+      break;\n+    case JCF_CLASS:\n+      jcf_parse (current_jcf);\n+      parse_class_file ();\n+      emit_register_class ();\n+      break;\n+    case JCF_SOURCE:\n+      parse_source_file (0);\t/* Parse and generate */\n+      break;\n+    }\n+  return 0;\n+}\n+\n+static struct ZipFileCache *localToFile;\n+\n+/* Process all class entries found in the zip file.  */\n+void\n+parse_zip_file_entries (void)\n+{\n+  struct ZipDirectory *zdir;\n+  int i;\n+\n+  for (i = 0, zdir = (ZipDirectory *)localToFile->z.central_directory;\n+       i < localToFile->z.count; i++, zdir = ZIPDIR_NEXT (zdir))\n+    {\n+      tree class;\n+      \n+      /* We don't need to consider those files.  */\n+      if (!zdir->size || !zdir->filename_offset)\n+\tcontinue;\n+\n+      class = lookup_class (get_identifier (ZIPDIR_FILENAME (zdir)));\n+      current_jcf = TYPE_LANG_SPECIFIC (class)->jcf;\n+      current_class = class;\n+\n+      if ( !CLASS_LOADED_P (class))\n+\t{\n+          fseek (current_jcf->read_state, current_jcf->zip_offset, SEEK_SET);\n+\t  jcf_parse (current_jcf);\n+\t}\n+\n+      input_filename = current_jcf->filename;\n+\n+      parse_class_file ();\n+      FREE (current_jcf->buffer); /* No longer necessary */\n+      /* Note: there is a way to free this buffer right after a class seen\n+\t in a zip file has been parsed. The idea is the set its jcf in such\n+\t a way that buffer will be reallocated the time the code for the class\n+\t will be generated. FIXME.  */\n+    }\n+}\n+\n+/* Read all the entries of the zip file, creates a class and a JCF. Sets the\n+   jcf up for further processing and link it to the created class.  */\n+\n+void process_zip_dir()\n+{\n+  int i;\n+  ZipDirectory *zdir;\n+\n+  for (i = 0, zdir = (ZipDirectory *)localToFile->z.central_directory;\n+       i < localToFile->z.count; i++, zdir = ZIPDIR_NEXT (zdir))\n+    {\n+      char *class_name, *file_name, *class_name_in_zip_dir;\n+      tree class;\n+      JCF  *jcf;\n+      int   j;\n+\n+      class_name_in_zip_dir = ZIPDIR_FILENAME (zdir);\n+\n+      /* We choose to not to process entries with a zero size or entries\n+\t not bearing the .class extention.  */\n+      if (!zdir->size || !zdir->filename_offset ||\n+\t  strncmp (&class_name_in_zip_dir[zdir->filename_length-6], \n+\t\t   \".class\", 6))\n+\t{\n+\t  /* So it will be skipped in parse_zip_file_entries  */\n+\t  zdir->size = 0;  \n+\t  continue;\n+\t}\n+\n+      class_name = ALLOC (zdir->filename_length+1-6);\n+      file_name  = ALLOC (zdir->filename_length+1);\n+      jcf = ALLOC (sizeof (JCF));\n+      JCF_ZERO (jcf);\n+\n+      strncpy (class_name, class_name_in_zip_dir, zdir->filename_length-6);\n+      class_name [zdir->filename_length-6] = '\\0';\n+      strncpy (file_name, class_name_in_zip_dir, zdir->filename_length);\n+      file_name [zdir->filename_length] = '\\0';\n+\n+      for (j=0; class_name[j]; j++)\n+        class_name [j] = (class_name [j] == '/' ? '.' : class_name [j]);\n+\n+      /* Yes, we write back the true class name into the zip directory.  */\n+      strcpy (class_name_in_zip_dir, class_name);\n+      zdir->filename_length = j;\n+      class = lookup_class (get_identifier (class_name));\n+\n+      jcf->read_state  = finput;\n+      jcf->filbuf      = jcf_filbuf_from_stdio;\n+      jcf->seen_in_zip = 1;\n+      jcf->java_source = 0;\n+      jcf->zip_offset  = zdir->filestart;\n+      jcf->classname   = class_name;\n+      jcf->filename    = file_name;\n+\n+      TYPE_LANG_SPECIFIC (class) = \n+        (struct lang_type *) perm_calloc (1, sizeof (struct lang_type));\n+      TYPE_LANG_SPECIFIC (class)->jcf = jcf;\n+    }\n+}\n+\n+/* Lookup class NAME and figure whether is a class already found in the current\n+   zip file.  */\n+int\n+DEFUN(find_in_current_zip, (name, length, jcf),\n+      char *name AND int length AND JCF **jcf)\n+{\n+  JCF *local_jcf;\n+  tree class_name = maybe_get_identifier (name), class, icv;\n+\n+  if (!class_name)\n+    return 0;\n+\n+  if (!(icv = IDENTIFIER_CLASS_VALUE (class_name)))\n+    return 0;\n+\n+  class = TREE_TYPE (icv);\n+\n+  /* Doesn't have jcf specific info ? It's not ours */\n+  if (!TYPE_LANG_SPECIFIC (class) || !TYPE_LANG_SPECIFIC (class)->jcf)\n+    return 0;\n+\n+  *jcf = local_jcf = TYPE_LANG_SPECIFIC (class)->jcf;\n+  fseek (local_jcf->read_state, local_jcf->zip_offset, SEEK_SET);\n+  return 1;\n+}\n+\n+/* Figure what kind of file we're dealing with */\n+int\n+DEFUN(jcf_figure_file_type, (jcf),\n+      JCF *jcf)\n+{\n+  unsigned char magic_string[4];\n+  uint32 magic;\n+\n+  if (fread (magic_string, 1, 4, jcf->read_state) != 4)\n+    jcf_unexpected_eof (jcf, 4);\n+\n+  fseek (jcf->read_state, 0L, SEEK_SET);\n+  magic = GET_u4 (magic_string);\n+\n+  if (magic == 0xcafebabe)\n+    return JCF_CLASS;\n+\n+  if (!open_in_zip (jcf, input_filename, NULL))\n+    {\n+      localToFile = ALLOC (sizeof (struct ZipFileCache));\n+      bcopy (SeenZipFiles, localToFile, sizeof (struct ZipFileCache));\n+      process_zip_dir ();\t/* Register all the class defined there */\n+      return JCF_ZIP;\n+    }\n+\n+  return JCF_SOURCE;\n+}\n+"}, {"sha": "cf5c04277894da913d8afc5e23caed04ae5eea77", "filename": "gcc/java/jcf-reader.c", "status": "added", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjcf-reader.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjcf-reader.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-reader.c?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,352 @@\n+/* This file read a Java(TM) .class file.\n+   It is not stand-alone:  It depends on tons of macros, and the\n+   intent is you #include this file after you've defined the macros.\n+\n+   Copyright (C) 1996  Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+#include \"jcf.h\"\n+#include \"zipfile.h\"\n+\n+int\n+DEFUN(get_attribute, (jcf),\n+      JCF *jcf)\n+{\n+  uint16 attribute_name = (JCF_FILL (jcf, 6), JCF_readu2 (jcf));\n+  uint32 attribute_length = JCF_readu4 (jcf);\n+  uint32 start_pos = JCF_TELL(jcf);\n+  int name_length;\n+  unsigned char *name_data;\n+  JCF_FILL (jcf, attribute_length);\n+  if (attribute_name <= 0 || attribute_name >= JPOOL_SIZE(jcf))\n+    return -2;\n+  if (JPOOL_TAG (jcf, attribute_name) != CONSTANT_Utf8)\n+    return -2;\n+  name_length = JPOOL_UTF_LENGTH (jcf, attribute_name);\n+  name_data = JPOOL_UTF_DATA (jcf, attribute_name);\n+\n+#ifdef IGNORE_ATTRIBUTE\n+   if (IGNORE_ATTRIBUTE (jcf, attribute_name, attribute_length))\n+     {\n+       JCF_SKIP (jcf, attribute_length);\n+     }\n+   else\n+#endif\n+#ifdef HANDLE_SOURCEFILE\n+  if (name_length == 10 && memcmp (name_data, \"SourceFile\", 10) == 0)\n+    {\n+      uint16 sourcefile_index = JCF_readu2 (jcf);\n+      HANDLE_SOURCEFILE(sourcefile_index);\n+    }\n+  else\n+#endif\n+#ifdef HANDLE_CONSTANTVALUE\n+  if (name_length == 13 && memcmp (name_data, \"ConstantValue\", 13) == 0)\n+    {\n+      uint16 constantvalue_index = JCF_readu2 (jcf);\n+      if (constantvalue_index <= 0 || constantvalue_index >= JPOOL_SIZE(jcf))\n+\treturn -2;\n+      HANDLE_CONSTANTVALUE(constantvalue_index);\n+    }\n+  else\n+#endif\n+#ifdef HANDLE_CODE_ATTRIBUTE\n+  if (name_length == 4 && memcmp (name_data, \"Code\", 4) == 0)\n+    {\n+      uint16 j;\n+      uint16 max_stack = JCF_readu2 (jcf);\n+      uint16 max_locals = JCF_readu2 (jcf);\n+      uint32 code_length = JCF_readu4 (jcf);\n+      uint16 exception_table_length, attributes_count;\n+      if (code_length + 12 > attribute_length)\n+\treturn -1;\n+      HANDLE_CODE_ATTRIBUTE(max_stack, max_locals, code_length);\n+      JCF_SKIP (jcf, code_length);\n+      exception_table_length = JCF_readu2 (jcf);\n+      if (code_length + 8 * exception_table_length + 12 > attribute_length)\n+\treturn -1;\n+      JCF_SKIP (jcf, 2 * 4 * exception_table_length);\n+      attributes_count = JCF_readu2 (jcf);\n+      for (j = 0; j < attributes_count; j++)\n+\t{\n+\t  int code = get_attribute (jcf);\n+\t  if (code != 0)\n+\t    return code;\n+\t}\n+    }\n+  else\n+#endif /* HANDLE_CODE_ATTRIBUTE */\n+#ifdef HANDLE_EXCEPTIONS_ATTRIBUTE\n+  if (name_length == 10 && memcmp (name_data, \"Exceptions\", 10) == 0)\n+    {\n+      uint16 count = JCF_readu2 (jcf);\n+      HANDLE_EXCEPTIONS_ATTRIBUTE (count);\n+    }\n+  else\n+#endif\n+#ifdef HANDLE_LINENUMBERTABLE_ATTRIBUTE\n+  if (name_length == 15 && memcmp (name_data, \"LineNumberTable\", 15) == 0)\n+    {\n+      uint16 count = JCF_readu2 (jcf);\n+      HANDLE_LINENUMBERTABLE_ATTRIBUTE (count);\n+    }\n+  else\n+#endif\n+#ifdef HANDLE_LOCALVARIABLETABLE_ATTRIBUTE\n+  if (name_length == 18 && memcmp (name_data, \"LocalVariableTable\", 18) == 0)\n+    {\n+      uint16 count = JCF_readu2 (jcf);\n+      HANDLE_LOCALVARIABLETABLE_ATTRIBUTE (count);\n+    }\n+  else\n+#endif\n+    {\n+#ifdef PROCESS_OTHER_ATTRIBUTE\n+      PROCESS_OTHER_ATTRIBUTE(jcf, attribute_name, attribute_length);\n+#else\n+      JCF_SKIP (jcf, attribute_length);\n+#endif\n+    }\n+  if (start_pos + attribute_length != JCF_TELL(jcf))\n+    return -1;\n+  return 0;\n+}\n+\n+/* Read and handle the pre-amble. */\n+int\n+DEFUN(jcf_parse_preamble, (jcf),\n+      JCF* jcf)\n+{\n+  uint32 magic = (JCF_FILL (jcf, 8), JCF_readu4 (jcf));\n+  uint16 minor_version = JCF_readu2 (jcf);\n+  uint16 major_version = JCF_readu2 (jcf);\n+#ifdef HANDLE_MAGIC\n+  HANDLE_MAGIC (magic, minor_version, major_version);\n+#endif\n+  if (magic != 0xcafebabe)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Read and handle the constant pool.\n+\n+   Return 0 if OK.\n+   Return -2 if a bad cross-reference (index of other constant) was seen.\n+*/\n+int\n+DEFUN(jcf_parse_constant_pool, (jcf),\n+      JCF* jcf)\n+{\n+  int i, n;\n+  JPOOL_SIZE (jcf) = (JCF_FILL (jcf, 2), JCF_readu2 (jcf));\n+  jcf->cpool.tags = ALLOC (JPOOL_SIZE (jcf));\n+  jcf->cpool.data = ALLOC (sizeof (jword) * JPOOL_SIZE (jcf));\n+  jcf->cpool.tags[0] = 0;\n+#ifdef HANDLE_START_CONSTANT_POOL\n+  HANDLE_START_CONSTANT_POOL (JPOOL_SIZE (jcf));\n+#endif\n+  for (i = 1; i < (int) JPOOL_SIZE (jcf); i++)\n+    {\n+      int constant_kind;\n+       \n+      /* Make sure at least 9 bytes are available.  This is enough\n+\t for all fixed-sized constant pool entries (so we don't need many\n+\t more JCF_FILL calls below), but is is small enough that\n+\t we are guaranteed to not hit EOF (in a valid .class file). */\n+      JCF_FILL (jcf, 9);\n+      constant_kind = JCF_readu (jcf);\n+      jcf->cpool.tags[i] = constant_kind;\n+      switch (constant_kind)\n+\t{\n+\tcase CONSTANT_String:\n+\tcase CONSTANT_Class:\n+\t  jcf->cpool.data[i] = JCF_readu2 (jcf);\n+\t  break;\n+\tcase CONSTANT_Fieldref:\n+\tcase CONSTANT_Methodref:\n+\tcase CONSTANT_InterfaceMethodref:\n+\tcase CONSTANT_NameAndType:\n+\t  jcf->cpool.data[i] = JCF_readu2 (jcf);\n+\t  jcf->cpool.data[i] |= JCF_readu2 (jcf) << 16;\n+\t  break;\n+\tcase CONSTANT_Integer:\n+\tcase CONSTANT_Float:\n+\t  jcf->cpool.data[i] = JCF_readu4 (jcf);\n+\t  break;\n+\tcase CONSTANT_Long:\n+\tcase CONSTANT_Double:\n+\t  jcf->cpool.data[i] = JCF_readu4 (jcf);\n+\t  i++; /* These take up two spots in the constant pool */\n+\t  jcf->cpool.tags[i] = 0;\n+\t  jcf->cpool.data[i] = JCF_readu4 (jcf);\n+\t  break;\n+\tcase CONSTANT_Utf8:\n+\t  n = JCF_readu2 (jcf);\n+\t  JCF_FILL (jcf, n);\n+#ifdef HANDLE_CONSTANT_Utf8\n+\t  HANDLE_CONSTANT_Utf8(jcf, i, n);\n+#else\n+\t  jcf->cpool.data[i] = JCF_TELL(jcf) - 2;\n+\t  JCF_SKIP (jcf, n);\n+#endif\n+\t  break;\n+\tdefault:\n+\t  return i;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* Read various class flags and numbers. */\n+\n+void\n+DEFUN(jcf_parse_class, (jcf),\n+      JCF* jcf)\n+{\n+  int i;\n+  uint16 interfaces_count;\n+  JCF_FILL (jcf, 8);\n+  jcf->access_flags = JCF_readu2 (jcf);\n+  jcf->this_class = JCF_readu2 (jcf);\n+  jcf->super_class = JCF_readu2 (jcf);\n+  interfaces_count = JCF_readu2 (jcf);\n+\n+#ifdef HANDLE_CLASS_INFO\n+  HANDLE_CLASS_INFO(jcf->access_flags, jcf->this_class, jcf->super_class, interfaces_count);\n+#endif\n+\n+  JCF_FILL (jcf, 2 * interfaces_count);\n+\n+  /* Read interfaces. */\n+  for (i = 0; i < interfaces_count; i++)\n+    {\n+      uint16 index = JCF_readu2 (jcf);\n+#ifdef HANDLE_CLASS_INTERFACE\n+      HANDLE_CLASS_INTERFACE (index);\n+#endif\n+    }\n+}\n+\n+/* Read fields. */\n+int\n+DEFUN(jcf_parse_fields, (jcf),\n+      JCF* jcf)\n+{\n+  int i, j;\n+  uint16 fields_count;\n+  JCF_FILL (jcf, 2);\n+  fields_count = JCF_readu2 (jcf);\n+\n+#ifdef HANDLE_START_FIELDS\n+  HANDLE_START_FIELDS (fields_count);\n+#endif\n+  for (i = 0; i < fields_count; i++)\n+    {\n+      uint16 access_flags = (JCF_FILL (jcf, 8), JCF_readu2 (jcf));\n+      uint16 name_index = JCF_readu2 (jcf);\n+      uint16 signature_index = JCF_readu2 (jcf);\n+      uint16 attribute_count = JCF_readu2 (jcf);\n+#ifdef HANDLE_START_FIELD\n+      HANDLE_START_FIELD (access_flags, name_index, signature_index,\n+\t\t    attribute_count);\n+#endif\n+      for (j = 0; j < attribute_count; j++)\n+\t{\n+\t  int code = get_attribute (jcf);\n+\t  if (code != 0)\n+\t    return code;\n+\t}\n+#ifdef HANDLE_END_FIELD\n+      HANDLE_END_FIELD ();\n+#endif\n+    }\n+#ifdef HANDLE_END_FIELDS\n+  HANDLE_END_FIELDS ();\n+#endif\n+  return 0;\n+}\n+\n+/* Read methods. */\n+\n+int\n+DEFUN(jcf_parse_one_method, (jcf),\n+      JCF* jcf)\n+{\n+  int i;\n+  uint16 access_flags = (JCF_FILL (jcf, 8), JCF_readu2 (jcf));\n+  uint16 name_index = JCF_readu2 (jcf);\n+  uint16 signature_index = JCF_readu2 (jcf);\n+  uint16 attribute_count = JCF_readu2 (jcf);\n+#ifdef HANDLE_METHOD\n+  HANDLE_METHOD(access_flags, name_index, signature_index, attribute_count);\n+#endif\n+  for (i = 0; i < attribute_count; i++)\n+    {\n+      int code = get_attribute (jcf);\n+      if (code != 0)\n+\treturn code;\n+    }\n+  return 0;\n+}\n+\n+int\n+DEFUN(jcf_parse_methods, (jcf),\n+      JCF* jcf)\n+{\n+  int i;\n+  uint16 methods_count;\n+  JCF_FILL (jcf, 2);\n+  methods_count = JCF_readu2 (jcf);\n+#ifdef HANDLE_START_METHODS\n+  HANDLE_START_METHODS (methods_count);\n+#endif\n+  for (i = 0; i < methods_count; i++)\n+    {\n+      int code = jcf_parse_one_method (jcf);\n+      if (code != 0)\n+\treturn code;\n+    }\n+#ifdef HANDLE_END_METHODS\n+  HANDLE_END_METHODS ();\n+#endif\n+  return 0;\n+}\n+\n+/* Read attributes. */\n+int\n+DEFUN(jcf_parse_final_attributes, (jcf),\n+      JCF *jcf)\n+{\n+  int i;\n+  uint16 attributes_count = (JCF_FILL (jcf, 2), JCF_readu2 (jcf));\n+#ifdef START_FINAL_ATTRIBUTES\n+  START_FINAL_ATTRIBUTES (attributes_count)\n+#endif\n+  for (i = 0; i < attributes_count; i++)\n+    {\n+      int code = get_attribute (jcf);\n+      if (code != 0)\n+\treturn code;\n+    }\n+  return 0;\n+}\n+"}, {"sha": "931c9d582c182b90f2be83f3bce40d1f530ed8db", "filename": "gcc/java/jcf-write.c", "status": "added", "additions": 964, "deletions": 0, "changes": 964, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,964 @@\n+/* Write out a Java(TM) class file.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA. \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"java-tree.h\"\n+#include \"jcf.h\"\n+#include <stdio.h>\n+#include \"obstack.h\"\n+#undef AND\n+#include \"rtl.h\"\n+#include \"java-opcodes.h\"\n+#include \"parse.h\" /* for BLOCK_EXPR_BODY */\n+#include \"buffer.h\"\n+\n+extern struct obstack temporary_obstack;\n+\n+/* The buffer allocated for bytecode for the current method. */\n+\n+struct buffer bytecode = NULL_BUFFER;\n+\n+/* Make sure bytecode.data is big enough for at least N more bytes. */\n+\n+#define RESERVE(N) \\\n+  do { if (bytecode.ptr + (N) > bytecode.limit) buffer_grow (&bytecode, N); } while (0)\n+\n+/* Add a 1-byte instruction/operand I to bytecode.data,\n+   assuming space has already been RESERVE'd. */\n+\n+#define OP1(I) (*bytecode.ptr++ = (I))\n+\n+/* Like OP1, but I is a 2-byte big endian integer. */\n+\n+#define OP2(I) \\\n+  do { int _I = (I);  OP1 (_I >> 8);  OP1 (_I); } while (0)\n+\n+/* Like OP1, but I is a 4-byte big endian integer. */\n+\n+#define OP4(I) \\\n+  do { int _I = (I);  OP1 (_I >> 24);  OP1 (_I >> 16); \\\n+       OP1 (_I >> 8); OP1 (_I); } while (0)\n+\n+/* The current stack size (stack pointer) in the current method. */\n+\n+int code_SP = 0;\n+\n+/* The largest extent of stack size (stack pointer) in the current method. */\n+\n+int code_SP_max = 0;\n+\n+CPool *code_cpool;\n+\n+/* Macro to call each time we push I words on the JVM stack. */\n+\n+#define NOTE_PUSH(I) \\\n+  do { code_SP += (I); if (code_SP > code_SP_max) code_SP_max = code_SP; } while (0)\n+\n+/* Macro to call each time we pop I words from the JVM stack. */\n+\n+#define NOTE_POP(I) \\\n+  do { code_SP -= (I); if (code_SP < 0) abort(); } while (0)\n+\n+/* A chunk or segment of a .class file. */\n+\n+struct chunk\n+{\n+  /* The next segment of this .class file. */\n+  struct chunk *next;\n+\n+  /* The actual data in this segment to be written to the .class file. */\n+  unsigned char *data;\n+\n+  /* The size of the segment to be written to the .class file. */\n+  int size;\n+};\n+\n+/* Utility macros for appending (big-endian) data to a buffer.\n+   We assume a local variable 'ptr' points into where we want to\n+   write next, and we assume enoygh space has been allocated. */\n+\n+#define PUT1(X)  (*ptr++ = (X))\n+#define PUT2(X)  (PUT1((X) >> 8), PUT1((X) & 0xFF))\n+#define PUT4(X)  (PUT2((X) >> 16), PUT2((X) & 0xFFFF))\n+#define PUTN(P, N)  (bcopy(P, ptr, N), ptr += (N))\n+\n+\f\n+/* A buffer for storing line number entries for the current method. */\n+struct buffer linenumbers = NULL_BUFFER;\n+\n+/* Append a line number entry for the given PC and LINE into\n+   linenumbers.data.  This will later before a LineNumberTable attribute. */\n+\n+void\n+put_linenumber (pc, line)\n+     int pc, line;\n+{\n+  register unsigned char *ptr;\n+  if (linenumbers.ptr == linenumbers.limit)\n+    buffer_grow (&linenumbers, 4);\n+  ptr = linenumbers.ptr;\n+  PUT2 (pc);\n+  PUT2 (line);\n+  linenumbers.ptr = ptr;\n+}\n+\f\n+/* The index of jvm local variable allocated for this DECL.\n+   This is assign when generating .class files;\n+   contrast DECL_LOCAL_SLOT_NUMBER whcih is set when *reading* a .class file.\n+   (We don't allocate DECL_LANG_SPECIFIC for locals from Java sourc code.) */\n+\n+#define DECL_LOCAL_INDEX(DECL) DECL_ALIGN(DECL)\n+\n+struct localvar_info\n+{\n+  tree decl;\n+\n+  int start_pc;\n+\n+  /* Offset in LocalVariableTable. */\n+  int debug_offset;\n+};\n+\n+struct buffer localvars = NULL_BUFFER;\n+\n+#define localvar_buffer ((struct localvar_info*) localvars.data)\n+#define localvar_max ((struct localvar_info*) localvars.ptr - localvar_buffer)\n+\n+/* A buffer for storing LocalVariableTable entries entries. */\n+\n+struct buffer localvartable = NULL_BUFFER;\n+\n+int\n+localvar_alloc (decl, start_pc)\n+     tree decl;\n+     int start_pc;\n+{\n+  int wide = TYPE_IS_WIDE (TREE_TYPE (decl));\n+  int index;\n+  register struct localvar_info *info = (struct localvar_info*)localvars.data;\n+  register struct localvar_info *limit = (struct localvar_info*)localvars.ptr;\n+  for (index = 0;  info < limit;  index++, info++)\n+    {\n+      if (info->decl == NULL_TREE\n+\t  && (! wide || (info+1)->decl == NULL_TREE))\n+\tbreak;\n+    }\n+  if (info == limit)\n+    {\n+      buffer_grow (&localvars, sizeof (struct localvar_info));\n+      info = (struct localvar_info*)localvars.data + index;\n+      localvars.ptr = (unsigned char *) (info + 1 + wide);\n+    }\n+  info->decl = decl;\n+  if (wide)\n+    (info+1)->decl = TYPE_SECOND;\n+  DECL_LOCAL_INDEX (decl) = index;\n+  info->start_pc = start_pc;\n+\n+  if (DECL_NAME (decl) != NULL_TREE)\n+    {\n+      /* Generate debugging info. */\n+      int i;\n+      register unsigned char *ptr;\n+      buffer_grow (&localvartable, 10);\n+      ptr = localvartable.ptr;\n+      info->debug_offset = ptr - localvartable.data;\n+      PUT2 (start_pc);\n+      PUT2 (0);  /* length - fill in later */\n+      i = find_utf8_constant (code_cpool, DECL_NAME (decl));\n+      PUT2 (i); /* name_index*/\n+      i = find_utf8_constant (code_cpool,\n+\t\t\t      build_java_signature (TREE_TYPE (decl)));\n+      PUT2 (i);  /* descriptor_index */\n+      PUT2 (index);\n+      localvartable.ptr = ptr;\n+    }\n+  else\n+    info->debug_offset = -1;\n+}\n+\n+int\n+localvar_free (decl, end_pc)\n+     tree decl;\n+     int end_pc;\n+{\n+  register unsigned char *ptr;\n+  int index = DECL_LOCAL_INDEX (decl);\n+  register struct localvar_info *info = &localvar_buffer [index];\n+  int wide = TYPE_IS_WIDE (TREE_TYPE (decl));\n+  int i;\n+\n+  i = info->debug_offset;\n+  if (i >= 0)\n+    {\n+      register unsigned char *ptr;\n+      /* Point to length field of local_variable_table. */\n+      ptr = localvartable.data + i + 2;\n+      i = end_pc - info->start_pc;\n+      PUT2 (i);\n+    }\n+\n+  if (info->decl != decl)\n+    abort ();\n+  info->decl = NULL_TREE;\n+  if (wide)\n+    {\n+      info++;\n+      if (info->decl != TYPE_SECOND)\n+\tabort ();\n+      info->decl = NULL_TREE;\n+    }\n+\n+}\n+\n+\f\n+#define STACK_TARGET 1\n+#define IGNORE_TARGET 2\n+\n+/* Allocate a new chunk on obstack WORK, and link it in after LAST.\n+   Set the data and size fields to DATA and SIZE, respectively.\n+   However, if DATA is NULL and SIZE>0, allocate a buffer as well. */\n+\n+struct chunk *\n+alloc_chunk (last, data, size, work)\n+     struct chunk *last;\n+     unsigned char *data;\n+     int size;\n+     struct obstack *work;\n+{\n+  struct chunk *chunk = (struct chunk *)\n+    obstack_alloc (work, sizeof(struct chunk));\n+\n+  if (data == NULL && size > 0)\n+    data = obstack_alloc (work, size);\n+\n+  chunk->next = NULL;\n+  chunk->data = data;\n+  chunk->size = size;\n+  last->next = chunk;\n+  return chunk;\n+}\n+\n+/* Get the access flags of a class (TYPE_DECL), a method (FUNCTION_DECL), or\n+   a field (FIELD_DECL or VAR_DECL, if static), as encoded in a .class file. */\n+\n+int\n+get_access_flags (decl)\n+    tree decl;\n+{\n+  int flags = 0;\n+  int isfield = TREE_CODE (decl) == FIELD_DECL || TREE_CODE (decl) == VAR_DECL;\n+  if (CLASS_PUBLIC (decl))  /* same as FIELD_PUBLIC and METHOD_PUBLIC */\n+    flags |= ACC_PUBLIC;\n+  if (CLASS_FINAL (decl))  /* same as FIELD_FINAL and METHOD_FINAL */\n+    flags |= ACC_PUBLIC;\n+  if (isfield || TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      if (TREE_PROTECTED (decl))\n+\tflags |= ACC_PROTECTED;\n+      if (TREE_PRIVATE (decl))\n+\tflags |= ACC_PRIVATE;\n+    }\n+  else if (TREE_CODE (decl) == TYPE_DECL)\n+    {\n+      if (CLASS_SUPER (decl))\n+\tflags |= ACC_SUPER;\n+      if (CLASS_ABSTRACT (decl))\n+\tflags |= ACC_ABSTRACT;\n+      if (CLASS_INTERFACE (decl))\n+\tflags |= ACC_INTERFACE;\n+    }\n+  else\n+    fatal (\"internal error - bad argument to get_access_flags\");\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      if (METHOD_NATIVE (decl))\n+\tflags |= ACC_NATIVE;\n+      if (METHOD_STATIC (decl))\n+\tflags |= ACC_STATIC;\n+      if (METHOD_FINAL (decl))\n+\tflags |= ACC_FINAL;\n+      if (METHOD_SYNCHRONIZED (decl))\n+\tflags |= ACC_SYNCHRONIZED;\n+      if (METHOD_ABSTRACT (decl))\n+\tflags |= ACC_ABSTRACT;\n+    }\n+  if (isfield)\n+    {\n+      if (FIELD_STATIC (decl))\n+\tflags |= ACC_STATIC;\n+      if (FIELD_VOLATILE (decl))\n+\tflags |= ACC_VOLATILE;\n+      if (FIELD_TRANSIENT (decl))\n+\tflags |= ACC_TRANSIENT;\n+    }\n+  return flags;\n+}\n+\n+/* Write the list of segments starting at CHUNKS to STREAM. */\n+\n+void\n+write_chunks (stream, chunks)\n+     FILE* stream;\n+     struct chunk *chunks;\n+{\n+  for (;  chunks != NULL;  chunks = chunks->next)\n+    fwrite (chunks->data, chunks->size, 1, stream);\n+}\n+\n+void\n+push_constant1 (index)\n+     int index;\n+{\n+  if (index < 256)\n+    {\n+      OP1 (OPCODE_ldc);\n+      OP1 (index);\n+    }\n+  else\n+    {\n+      OP1 (OPCODE_ldc_w);\n+      OP2 (index);\n+    }\n+}\n+\n+void\n+push_constant2 (index)\n+     int index;\n+{\n+  RESERVE (3);\n+  OP1 (OPCODE_ldc2_w);\n+  OP2 (index);\n+}\n+\n+void\n+push_int_const (i)\n+     HOST_WIDE_INT i;\n+{\n+  RESERVE(3);\n+  if (i >= -1 && i <= 5)\n+    OP1(OPCODE_iconst_0 + i);\n+  else if (i >= -128 && i < 128)\n+    {\n+      OP1(OPCODE_bipush);\n+      OP1(i);\n+    }\n+  else if (i >= -32768 && i < 32768)\n+    {\n+      OP1(OPCODE_sipush);\n+      OP2(i);\n+    }\n+  else\n+    {\n+      i = find_constant1 (code_cpool, CONSTANT_Integer, i & 0xFFFFFFFF);\n+      push_constant1 (i);\n+    }\n+}\n+\n+void\n+push_long_const (lo, hi)\n+     HOST_WIDE_INT lo, hi;\n+{\n+  if (hi == 0 && lo >= 0 && lo <= 1)\n+    {\n+      RESERVE(1);\n+      OP1(OPCODE_lconst_0 + lo);\n+    }\n+#if 0\n+    else if ((jlong) (jint) i == i)\n+      {\n+        push_int_const ((jint) i);\n+        RESERVE (1);\n+        OP1 (OPCODE_i2l);\n+      }\n+#endif\n+  else\n+    {\n+      HOST_WIDE_INT w1, w2;\n+      lshift_double (lo, hi, -32, 64, &w1, &w2, 1);\n+      hi = find_constant1 (code_cpool, CONSTANT_Long,\n+\t\t\t   w1 & 0xFFFFFFFF, lo & 0xFFFFFFFF);\n+      push_constant2 (hi);\n+    }\n+}\n+\n+void\n+field_op (field, opcode)\n+     tree field;\n+     int opcode;\n+{\n+  int index = find_fieldref_index (code_cpool, field);\n+  RESERVE (3);\n+  OP1 (opcode);\n+  OP2 (index);\n+}\n+\n+/* Returns an integer in the range 0 (for 'int') through 4 (for object\n+   reference) to 7 (for 'short') which matches the pattern of how JVM\n+   opcodes typically depend on the operand type. */\n+\n+int\n+adjust_typed_op (type)\n+     tree type;\n+{\n+  switch (TREE_CODE (type))\n+    {\n+    case BOOLEAN_TYPE:  return 5;\n+    case CHAR_TYPE:     return 6;\n+    case POINTER_TYPE:\n+    case RECORD_TYPE:   return 4;\n+    case INTEGER_TYPE:\n+      switch (TYPE_PRECISION (type))\n+\t{\n+\tcase  8:       return 5;\n+\tcase 16:       return 7;\n+\tcase 32:       return 0;\n+\tcase 64:       return 1;\n+\t}\n+      break;\n+    case REAL_TYPE:\n+      switch (TYPE_PRECISION (type))\n+\t{\n+\tcase 32:       return 2;\n+\tcase 64:       return 3;\n+\t}\n+      break;\n+    }\n+  abort ();\n+}\n+\n+void\n+maybe_wide (opcode, index)\n+     int opcode, index;\n+{\n+  if (index >= 256)\n+    {\n+      RESERVE (4);\n+      OP1 (196); /* wide */\n+      OP1 (opcode);\n+      OP2 (index);\n+    }\n+  else\n+    {\n+      RESERVE (2);\n+      OP1 (opcode);\n+      OP1 (index);\n+    }\n+}\n+\n+#define PC BUFFER_LENGTH(&bytecode)\n+\n+/* Generate byetcode for sub-expression EXP of METHOD.\n+   TARGET is one of STACK_TARGET or IGNORE_TARGET. */\n+\n+void\n+generate_bytecode_insns (method, exp, target)\n+     tree method;\n+     tree exp;\n+     int target;\n+{\n+  rtx value;\n+  tree type = TREE_TYPE (exp);\n+  enum java_opcode jopcode;\n+  int op;\n+  switch (TREE_CODE (exp))\n+    {\n+    case BLOCK:\n+      if (BLOCK_EXPR_BODY (exp))\n+\t{\n+\t  tree local;\n+\t  for (local = BLOCK_EXPR_DECLS (exp); local; )\n+\t    {\n+\t      tree next = TREE_CHAIN (local);\n+\t      localvar_alloc (local, PC);\n+\t      local = next;\n+\t    }\n+\t  generate_bytecode_insns (method, BLOCK_EXPR_BODY (exp), target);\n+\t  for (local = BLOCK_EXPR_DECLS (exp); local; )\n+\t    {\n+\t      tree next = TREE_CHAIN (local);\n+\t      localvar_free (local, PC);\n+\t      local = next;\n+\t    }\n+\t}\n+      break;\n+      case COMPOUND_EXPR:\t\n+\tgenerate_bytecode_insns (method, TREE_OPERAND (exp, 0), IGNORE_TARGET);\n+\tgenerate_bytecode_insns (method, TREE_OPERAND (exp, 1), target);\n+      break;\n+    case EXPR_WITH_FILE_LOCATION:\n+      {\n+\tchar *saved_input_filename = input_filename;\n+\tint saved_lineno = lineno;\n+\tinput_filename = EXPR_WFL_FILENAME (exp);\n+\tlineno = EXPR_WFL_LINENO (exp);\n+\tif (EXPR_WFL_EMIT_LINE_NOTE (exp))\n+\t  put_linenumber (PC, EXPR_WFL_LINENO (exp));\n+\tgenerate_bytecode_insns (method, EXPR_WFL_NODE (exp), target);\n+\tinput_filename = saved_input_filename;\n+\tlineno = saved_lineno;\n+      }\n+      break;\n+    case INTEGER_CST:\n+      if (target == IGNORE_TARGET) ; /* do nothing */\n+      else if (TREE_CODE (type) == POINTER_TYPE)\n+\t{\n+\t  if (! integer_zerop (exp))\n+\t    abort();\n+\t  RESERVE(1);\n+\t  OP1 (OPCODE_aconst_null);\n+\t  NOTE_PUSH (1);\n+\t}\n+      else if (TYPE_PRECISION (type) <= 32)\n+\t{\n+\t  push_int_const (TREE_INT_CST_LOW (exp));\n+\t  NOTE_PUSH (1);\n+\t}\n+      else\n+\t{\n+\t  push_long_const (TREE_INT_CST_LOW (exp), TREE_INT_CST_HIGH (exp));\n+\t  NOTE_PUSH (2);\n+\t}\n+      break;\n+    case VAR_DECL:\n+      if (TREE_STATIC (exp))\n+\t{\n+\t  field_op (exp, OPCODE_getstatic);\n+\t  break;\n+\t}\n+      /* ... fall through ... */\n+    case PARM_DECL:\n+      {\n+\tint kind = adjust_typed_op (type);\n+\tint index = DECL_LOCAL_INDEX (exp);\n+\tif (index <= 3)\n+\t  {\n+\t    RESERVE (1);\n+\t    OP1 (26 + 4 * kind + index);    /* [ilfda]load_[0123] */\n+\t  }\n+\telse\n+\t  maybe_wide (21 + kind, index);  /* [ilfda]load */\n+      }\n+      break;\n+    case INDIRECT_REF:\n+      generate_bytecode_insns (method, TREE_OPERAND (exp, 0), target);\n+      break;\n+    case ARRAY_REF:\n+      generate_bytecode_insns (method, TREE_OPERAND (exp, 0), target);\n+      generate_bytecode_insns (method, TREE_OPERAND (exp, 1), target);\n+      if (target != IGNORE_TARGET)\n+\t{\n+\t  jopcode = OPCODE_iaload + adjust_typed_op (type);\n+\t  RESERVE(1);\n+\t  OP1 (jopcode);\n+\t}\n+      break;\n+    case COMPONENT_REF:\n+      {\n+\ttree obj = TREE_OPERAND (exp, 0);\n+\ttree field = TREE_OPERAND (exp, 1);\n+\tint is_static = FIELD_STATIC (field);\n+\tgenerate_bytecode_insns (method, obj,\n+\t\t\t\t is_static ? IGNORE_TARGET : target);\n+\tif (target != IGNORE_TARGET)\n+\t  {\n+\t    if (DECL_NAME (field) == length_identifier_node && !is_static\n+\t\t&& TYPE_ARRAY_P (TREE_TYPE (obj)))\n+\t      {\n+\t\tRESERVE (1);\n+\t\tOP1 (OPCODE_arraylength);\n+\t      }\n+\t    else\n+\t      field_op (field, is_static ? OPCODE_getstatic : OPCODE_getfield);\n+\t  }\n+      }\n+      break;\n+    case RETURN_EXPR:\n+      if (!TREE_OPERAND (exp, 0))\n+\top = OPCODE_return;\n+      else\n+\t{\n+\t  exp = TREE_OPERAND (exp, 0);\n+\t  if (TREE_CODE (exp) != MODIFY_EXPR)\n+\t    abort ();\n+\t  exp = TREE_OPERAND (exp, 1);\n+\t  op = OPCODE_ireturn + adjust_typed_op (TREE_TYPE (exp));\n+\t  generate_bytecode_insns (method, exp, STACK_TARGET);\n+\t}\n+      RESERVE (1);\n+      OP1 (op);\n+      break;\n+    case MODIFY_EXPR:\n+      {\n+\ttree lhs = TREE_OPERAND (exp, 0);\n+\ttree rhs = TREE_OPERAND (exp, 1);\n+\tHOST_WIDE_INT value;\n+#if 0\n+\tif (TREE_CODE (rhs) == PLUS_EXPR\n+\t    && TREE_CODE (lhs) == VAR_DECL\n+\t    /* && FIXME lhs is a local variable */\n+\t    && TYPE_MODE (TREE)TYPE (lhs) == SImode /* ??? */\n+\t    && TREE_OPERAND (rhs, 0) == lhs\n+\t    && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST\n+\t    /* or vice versa FIXME */\n+\t    && (value = TREE_INT_CST_LOW (TREE_OPERAND (rhs, 1)),\n+\t\t(value >= -32768 && value <= 32767)))\n+\t  {\n+\t    emit_insn (gen_rtx (SET, SImode,\n+\t\t\t\tDECL_RTL (lhs),\n+\t\t\t\tgen_rtx (PLUS, SImode,\n+\t\t\t\t\t DECL_RTL (lhs),\n+\t\t\t\t\t gen_rtx_CONST_INT (SImode, value))));\n+\t    return DECL_RTL (lhs);\n+\t  }\n+#endif\n+\tif (TREE_CODE (lhs) == COMPONENT_REF)\n+\t  generate_bytecode_insns (method, TREE_OPERAND (lhs, 0), STACK_TARGET);\n+\telse if (TREE_CODE (lhs) == ARRAY_REF)\n+\t  {\n+\t    generate_bytecode_insns (method,\n+\t\t\t\t     TREE_OPERAND (lhs, 0), STACK_TARGET);\n+\t    generate_bytecode_insns (method,\n+\t\t\t\t     TREE_OPERAND (lhs, 1), STACK_TARGET);\n+\t  }\n+\tgenerate_bytecode_insns (method, rhs, STACK_TARGET);\n+\tif (target != IGNORE_TARGET)\n+\t  {\n+\t    RESERVE (1);\n+\t    OP1 (TYPE_IS_WIDE (type) ? OPCODE_dup2_x1 : OPCODE_dup_x1);\n+\t  }\n+\tif (TREE_CODE (lhs) == COMPONENT_REF)\n+\t  {\n+\t    tree field = TREE_OPERAND (lhs, 1);\n+\t    field_op (field,\n+\t\t      FIELD_STATIC (field) ? OPCODE_putstatic\n+\t\t      : OPCODE_putfield);\n+\t  }\n+\telse if (TREE_CODE (lhs) == VAR_DECL\n+\t\t || TREE_CODE (lhs) == PARM_DECL)\n+\t  {\n+\t    if (FIELD_STATIC (lhs))\n+\t      {\n+\t\tfield_op (lhs, OPCODE_putstatic);\n+\t      }\n+\t    else\n+\t      {\n+\t\tint index = DECL_LOCAL_INDEX (lhs);\n+\t\tint opcode = adjust_typed_op (TREE_TYPE (lhs));\n+\t\tif (index <= 3)\n+\t\t  {\n+\t\t    RESERVE (1);\n+\t\t    opcode = 59 + 4 * opcode + index;\n+\t\t    OP1 (opcode);  /* [ilfda]store_[0123] */\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    maybe_wide (54 + opcode, index);  /* [ilfda]store */\n+\t\t  }\n+\t      }\n+\t  }\n+\telse if (TREE_CODE (lhs) == ARRAY_REF)\n+\t  {\n+\t    jopcode = OPCODE_iastore + adjust_typed_op (TREE_TYPE (lhs));\n+\t    RESERVE(1);\n+\t    OP1 (jopcode);\n+\t  }\n+\telse\n+\t  fatal (\"internal error (bad lhs to MODIFY_EXPR)\");\n+      }\n+      break;\n+    case PLUS_EXPR:\n+      jopcode = OPCODE_iadd + adjust_typed_op (type);\n+      goto binop;\n+    case MINUS_EXPR:\n+      jopcode = OPCODE_isub + adjust_typed_op (type);\n+      goto binop;\n+    case MULT_EXPR:\n+      jopcode = OPCODE_imul + adjust_typed_op (type);\n+      goto binop;\n+    case TRUNC_DIV_EXPR:\n+    case RDIV_EXPR:\n+      jopcode = OPCODE_idiv + adjust_typed_op (type);\n+      goto binop;\n+    binop:\n+      generate_bytecode_insns (method, TREE_OPERAND (exp, 0), target);\n+      generate_bytecode_insns (method, TREE_OPERAND (exp, 1), target);\n+      if (target == STACK_TARGET)\n+\t{\n+\t  RESERVE(1);\n+\t  OP1 (jopcode);\n+\t}\n+      break;\n+    case CALL_EXPR:\n+      {\n+\ttree t;\n+\tfor (t = TREE_OPERAND (exp, 1);  t != NULL_TREE;  t = TREE_CHAIN (t))\n+\t  {\n+\t    generate_bytecode_insns (method, TREE_VALUE (t), STACK_TARGET);\n+\t  }\n+\tt = TREE_OPERAND (exp, 0);\n+\tif (TREE_CODE (t) == FUNCTION_DECL)\n+\t  {\n+\t    int index = find_methodref_index (code_cpool, t);\n+\t    RESERVE (3);\n+\t    if (DECL_CONSTRUCTOR_P (t))\n+\t      OP1 (OPCODE_invokespecial);\n+\t    else if (METHOD_STATIC (t))\n+\t      OP1 (OPCODE_invokestatic);\n+\t    else\n+\t      OP1 (OPCODE_invokevirtual);\n+\t    OP2 (index);\n+\t    break;\n+\t  }\n+      }\n+      /* fall through */\n+    default:\n+      error(\"internal error - tree code not implemented: \", TREE_CODE (exp));\n+    }\n+}\n+\n+/* Generate and return a list of chunks containing the class CLAS\n+   in the .class file representation.  The list can be written to a\n+   .class file using write_chunks.  Allocate chunks from obstack WORK. */\n+\n+/* Currently does not write any attributes i.e. no code. */\n+\n+struct chunk *\n+generate_classfile (clas, work)\n+     tree clas;\n+     struct obstack *work;\n+{\n+  CPool cpool;\n+  struct chunk head;\n+  struct chunk *chunk;\n+  struct chunk *cpool_chunk;\n+  char *ptr;\n+  int i;\n+  char *fields_count_ptr;\n+  int fields_count = 0;\n+  char *methods_count_ptr;\n+  int methods_count = 0;\n+  tree part;\n+  int total_supers\n+    = clas == object_type_node ? 0\n+    : TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (clas));\n+\n+  chunk = alloc_chunk (&head, NULL, 8, work);\n+  ptr = chunk->data;\n+  PUT4 (0xCafeBabe);  /* Magic number */\n+  PUT2 (3);  /* Minor version */\n+  PUT2 (45);  /* Major version */\n+  \n+  CPOOL_INIT(&cpool);\n+  cpool_chunk = chunk = alloc_chunk (chunk, NULL, 0, work);\n+\n+  /* Next allocate the chunk containing acces_flags through fields_counr. */\n+  if (clas == object_type_node)\n+    i = 10;\n+  else\n+    i = 8 + 2 * total_supers;\n+  chunk = alloc_chunk (chunk, NULL, i, work);\n+  ptr = chunk->data;\n+  i = get_access_flags (TYPE_NAME (clas));  PUT2 (i); /* acces_flags */\n+  i = find_class_constant (&cpool, clas);  PUT2 (i);  /* this_class */\n+  if (clas == object_type_node)\n+    {\n+      PUT2(0);  /* super_class */\n+      PUT2(0);  /* interfaces_count */\n+    }\n+  else\n+    {\n+      tree basetypes = TYPE_BINFO_BASETYPES (clas);\n+      tree base = BINFO_TYPE (TREE_VEC_ELT (basetypes, 0));\n+      int j = find_class_constant (&cpool, base);  PUT2 (j);  /* super_class */\n+      PUT2 (total_supers - 1);  /* interfaces_count */\n+      for (i = 1;  i < total_supers;  i++)\n+\t{\n+\t  base = BINFO_TYPE (TREE_VEC_ELT (basetypes, i));\n+\t  j = find_class_constant (&cpool, base);\n+\t  PUT2 (j);\n+\t}\n+    }\n+  fields_count_ptr = ptr;\n+\n+  for (part = TYPE_FIELDS (clas);  part;  part = TREE_CHAIN (part))\n+    {\n+      if (DECL_NAME (part) == NULL_TREE)\n+\tcontinue;\n+      chunk = alloc_chunk (chunk, NULL, 8, work);\n+      ptr = chunk->data;\n+      i = get_access_flags (part);  PUT2 (i);\n+      i = find_utf8_constant (&cpool, DECL_NAME (part));  PUT2 (i);\n+      i = find_utf8_constant (&cpool, build_java_signature (TREE_TYPE (part)));\n+      PUT2(i);\n+      PUT2 (0);  /* attributes_count */\n+      /* FIXME - emit ConstantValue attribute when appropriate */\n+      fields_count++;\n+    }\n+  ptr = fields_count_ptr;  PUT2 (fields_count);\n+\n+  chunk = alloc_chunk (chunk, NULL, 2, work);\n+  ptr = methods_count_ptr = chunk->data;\n+  PUT2 (0);\n+\n+  for (part = TYPE_METHODS (clas);  part;  part = TREE_CHAIN (part))\n+    {\n+      tree body = BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (part));\n+      int linenumber_size;  /* 4 * number of line number entries */\n+      chunk = alloc_chunk (chunk, NULL, 8, work);\n+      ptr = chunk->data;\n+      i = get_access_flags (part);  PUT2 (i);\n+      i = find_utf8_constant (&cpool, DECL_NAME (part));  PUT2 (i);\n+      i = find_utf8_constant (&cpool, build_java_signature (TREE_TYPE (part)));\n+      PUT2 (i);\n+      PUT2 (body != NULL_TREE ? 1 : 0);   /* attributes_count */\n+      if (body != NULL_TREE)\n+\t{\n+\t  int code_attributes_count = 0;\n+\t  int linenumber_size;  /* 4 * number of line number entries */\n+\t  int localvartable_size;  /* 10 * number of local variable entries */\n+\t  static tree Code_node = NULL_TREE;\n+\t  tree t;\n+\t  char *attr_len_ptr;\n+\t  int code_length;\n+\t  if (Code_node == NULL_TREE)\n+\t    Code_node = get_identifier (\"Code\");\n+\t  chunk = alloc_chunk (chunk, NULL, 14, work);\n+\t  ptr = chunk->data;\n+\t  i = find_utf8_constant (&cpool, Code_node);  PUT2 (i);\n+\t  attr_len_ptr = ptr;\n+\t  BUFFER_RESET (&bytecode);\n+\t  BUFFER_RESET (&localvartable);\n+\t  BUFFER_RESET (&linenumbers);\n+\t  BUFFER_RESET (&localvars);\n+\t  code_SP = 0;\n+\t  code_SP_max = 0;\n+\t  code_cpool = &cpool;\n+\t  for (t = DECL_ARGUMENTS (part);  t != NULL_TREE;  t = TREE_CHAIN (t))\n+\t    localvar_alloc (t, 0);\n+\t  generate_bytecode_insns (part, body, IGNORE_TARGET);\n+\t  code_length = PC;\t\n+\t  for (t = DECL_ARGUMENTS (part);  t != NULL_TREE;  t = TREE_CHAIN (t))\n+\t    localvar_free (t, code_length);\n+\t  linenumber_size = BUFFER_LENGTH (&linenumbers);\n+\t  localvartable_size = BUFFER_LENGTH (&localvartable);\n+\t  chunk = alloc_chunk (chunk, NULL, code_length, work);\n+\t  bcopy (bytecode.data, chunk->data, code_length);\n+\t  ptr = attr_len_ptr;\n+\t  i = 8 + code_length + 4;\n+\t  if (linenumber_size > 0)\n+\t    {\n+\t      code_attributes_count++;\n+\t      i += 8 + linenumber_size;\n+\t    }\n+\t  if (localvartable_size > 0)\n+\t    {\n+\t      code_attributes_count++;\n+\t      i += 8 + localvartable_size;\n+\t    }\n+\t  PUT4 (i); /* attribute_length */\n+\t  PUT2 (code_SP_max);  /* max_stack */\n+\t  PUT2 (localvar_max);  /* max_locals */\n+\t  PUT4 (code_length);\n+\t  chunk = alloc_chunk (chunk, NULL, 4, work);\n+\t  ptr = chunk->data;\n+\t  PUT2 (0);  /* exception_table_length */\n+\t  PUT2 (code_attributes_count);\n+\n+\t  /* Write the LineNumberTable attribute. */\n+\t  if (linenumber_size > 0)\n+\t    {\n+\t      static tree LineNumberTable_node = NULL_TREE;\n+\t      chunk = alloc_chunk (chunk, NULL, 8 + linenumber_size, work);\n+\t      ptr = chunk->data;\n+\t      if (LineNumberTable_node == NULL_TREE)\n+\t\tLineNumberTable_node = get_identifier (\"LineNumberTable\");\n+\t      i = find_utf8_constant (&cpool, LineNumberTable_node);\n+\t      PUT2 (i);  /* attribute_name_index */\n+\t      i = 2 + linenumber_size;  PUT4 (i);  /* attribute_length */\n+\t      i = linenumber_size >> 2;  PUT2 (i);\n+\t      PUTN (linenumbers.data, linenumber_size);\n+\t    }\n+\n+\t  /* Write the LocalVariableTable attribute. */\n+\t  if (localvartable_size > 0)\n+\t    {\n+\t      static tree LocalVariableTable_node = NULL_TREE;\n+\t      chunk = alloc_chunk (chunk, NULL, 8 + localvartable_size, work);\n+\t      ptr = chunk->data;\n+\t      if (LocalVariableTable_node == NULL_TREE)\n+\t\tLocalVariableTable_node = get_identifier(\"LocalVariableTable\");\n+\t      i = find_utf8_constant (&cpool, LocalVariableTable_node);\n+\t      PUT2 (i);  /* attribute_name_index */\n+\t      i = 2 + localvartable_size;  PUT4 (i);  /* attribute_length */\n+\t      i = localvartable_size / 10;  PUT2 (i);\n+\t      PUTN (localvartable.data, localvartable_size);\n+\t    }\n+\t}\n+      methods_count++;\n+    }\n+  ptr = methods_count_ptr;  PUT2 (methods_count);\n+\n+  chunk = alloc_chunk (chunk, NULL, 2, work);\n+  ptr = chunk->data;\n+  PUT2 (0);  /* attributes_count */\n+\n+  /* New finally generate the contents of the constant pool chunk. */\n+  i = count_constant_pool_bytes (&cpool);\n+  ptr = obstack_alloc (work, i);\n+  cpool_chunk->data = ptr;\n+  cpool_chunk->size = i;\n+  write_constant_pool (&cpool, ptr, i);\n+  CPOOL_FINISH (&cpool);\n+  return head.next;\n+}\n+\n+char*\n+make_class_file_name (clas)\n+     tree clas;\n+{\n+  /* Should prepend an output directly, but need an option to specify it. */\n+  return IDENTIFIER_POINTER (identifier_subst (DECL_NAME (TYPE_NAME (clas)),\n+\t\t\t\t\t       \"\", '.', '/', \".class\"));\n+}\n+\n+/* Write out the contens of a class (RECORD_TYPE) CLAS, as a .class file.\n+   The output .class file name is make_class_file_name(CLAS). */\n+\n+void\n+write_classfile (clas)\n+     tree clas;\n+{\n+  struct obstack *work = &temporary_obstack;\n+  char *class_file_name = make_class_file_name (clas);\n+  struct chunk *chunks;\n+  FILE* stream = fopen (class_file_name, \"wb\");\n+  if (stream == NULL)\n+    fatal (\"failed to open `%s' for writing\", class_file_name);\n+  chunks = generate_classfile (clas, work);\n+  write_chunks (stream, chunks);\n+  if (fclose (stream))\n+    fatal (\"failed to close after writing `%s'\", class_file_name);\n+  obstack_free (work, chunks);\n+}"}, {"sha": "5e82387ca155ae2f497bd64e08b41f6d3068e6bd", "filename": "gcc/java/jcf.h", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjcf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjcf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf.h?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,260 @@\n+/* Utility macros to read Java(TM) .class files and byte codes.\n+\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Written by Per Bothner <bothner@cygnus.com>, February 1996. */\n+\n+#ifndef JCF_H\n+#define JCF_H\n+#include \"javaop.h\"\n+#ifndef DEFUN\n+#if defined (__STDC__)\n+#define AND             ,\n+#define PTR             void *\n+#define DEFUN(name, arglist, args)      name(args)\n+#else\n+#define PTR             char *\n+#define AND             ;\n+#define DEFUN(name, arglist, args)      name arglist args;\n+#define inline static\n+#endif\n+#endif /* !DEFUN */\n+\n+#ifndef PROTO\n+#if defined (__STDC__)\n+#define PROTO(paramlist)    paramlist\n+#else\n+#define PROTO(paramlist)    ()\n+#endif\n+#endif\n+\n+#ifndef JCF_u4\n+#define JCF_u4 unsigned long\n+#endif\n+#ifndef JCF_u2\n+#define JCF_u2 unsigned short\n+#endif\n+\n+#define ALLOC (void*)malloc\n+#define REALLOC (void*)realloc\n+#ifndef FREE\n+#define FREE(PTR) free(PTR)\n+#endif\n+\n+#ifdef JCF_word\n+#define JCF_word JCF_u4\n+#endif\n+\n+#define JCF_ZIP    1\n+#define JCF_CLASS  2\n+#define JCF_SOURCE 3\n+\n+struct JCF;\n+typedef int (*jcf_filbuf_t) PROTO ((struct JCF*, int needed));\n+\n+typedef struct CPool {\n+  /* Available number of elements in the constants array, before it\n+     must be re-allocated. */\n+  int capacity;\n+\n+  /* The constant_pool_count. */\n+  int\t\tcount;\n+\n+  uint8*\ttags;\n+\n+  jword*\tdata;\n+} CPool;\n+\n+/* JCF encapsulates the state of reading a Java Class File. */\n+\n+typedef struct JCF {\n+  unsigned char *buffer;\n+  unsigned char *buffer_end;\n+  unsigned char *read_ptr;\n+  unsigned char *read_end;\n+  int seen_in_zip;\n+  int java_source;\n+  int  outofsynch;\t\t/* Found a class file out of synch\n+\t\t\t\t   with the matching source file. */\n+  long zip_offset;    \n+  jcf_filbuf_t filbuf;\n+  void *read_state;\n+  char *filename;\n+  char *classname;\n+  void *zipd;\t\t\t/* Directory entry where it was found */\n+  JCF_u2 access_flags, this_class, super_class;\n+  CPool cpool;\n+} JCF;\n+/*typedef JCF*  JCF_FILE;*/\n+\n+/* The CPOOL macros take a (pointer to a) CPool.\n+   The JPOOL macros take a (pointer to a) JCF.\n+   Some of the latter should perhaps be deprecated or removed. */\n+\n+#define CPOOL_COUNT(CPOOL) ((CPOOL)->count)\n+#define JPOOL_SIZE(JCF) CPOOL_COUNT(&(JCF)->cpool)\n+#define JPOOL_TAG(JCF, INDEX) ((JCF)->cpool.tags[INDEX])\n+/* The INDEX'th constant pool entry as a JCF_u4. */\n+#define CPOOL_UINT(CPOOL, INDEX) ((CPOOL)->data[INDEX])\n+#define JPOOL_UINT(JCF, INDEX) CPOOL_UINT(&(JCF)->cpool, INDEX) /*deprecated*/\n+/* The first uint16 of the INDEX'th constant pool entry. */\n+#define CPOOL_USHORT1(CPOOL, INDEX) ((CPOOL)->data[INDEX] & 0xFFFF)\n+#define JPOOL_USHORT1(JCF, INDEX) CPOOL_USHORT1(&(JCF)->cpool, INDEX)\n+/* The second uint16 of the INDEX'th constant pool entry. */\n+#define CPOOL_USHORT2(CPOOL, INDEX) ((CPOOL)->data[INDEX] >> 16)\n+#define JPOOL_USHORT2(JCF, INDEX) CPOOL_USHORT2(&(JCF)->cpool, INDEX)\n+#define JPOOL_LONG(JCF, INDEX) \\\n+  WORDS_TO_LONG (JPOOL_UINT(JCF, INDEX), JPOOL_UINT(JCF, (INDEX)+1))\n+#define JPOOL_DOUBLE(JCF, INDEX) \\\n+  WORDS_TO_DOUBLE  (JPOOL_UINT(JCF, INDEX), JPOOL_UINT(JCF, (INDEX)+1))\n+#ifndef JPOOL_UTF_LENGTH\n+#define JPOOL_UTF_LENGTH(JCF, INDEX) \\\n+  GET_u2 ((JCF)->buffer+JPOOL_UINT(JCF, INDEX))\n+#endif\n+#ifndef JPOOL_UTF_DATA\n+#define JPOOL_UTF_DATA(JCF, INDEX) \\\n+  ((JCF)->buffer+JPOOL_UINT(JCF, INDEX)+2)\n+#endif\n+#define JPOOL_INT(JCF, INDEX) ((jint) JPOOL_UINT (JCF, INDEX))\n+#define JPOOL_FLOAT(JCF, INDEX) WORD_TO_FLOAT (JPOOL_UINT (JCF, INDEX))\n+\n+#define CPOOL_INDEX_IN_RANGE(CPOOL, INDEX) \\\n+ ((INDEX) > 0 && (INDEX) < CPOOL_COUNT(CPOOL))\n+\n+#define CPOOL_FINISH(CPOOL) { \\\n+  if ((CPOOL)->tags) FREE ((CPOOL)->tags); \\\n+  if ((CPOOL)->data) FREE ((CPOOL)->data); }\n+\n+#define JCF_FINISH(JCF) { \\\n+  CPOOL_FINISH(&(JCF)->cpool); \\\n+  if ((JCF)->buffer) FREE ((JCF)->buffer); \\\n+  if ((JCF)->filename) FREE ((JCF)->filename); \\\n+  if ((JCF)->classname) FREE ((JCF)->classname); }\n+  \n+#define CPOOL_INIT(CPOOL) \\\n+  ((CPOOL)->capacity = 0, (CPOOL)->count = 0, (CPOOL)->tags = 0, (CPOOL)->data = 0)\n+\n+#define CPOOL_REINIT(CPOOL) ((CPOOL)->count = 0)\n+\n+#define JCF_ZERO(JCF)  \\\n+  ((JCF)->buffer = (JCF)->buffer_end = (JCF)->read_ptr = (JCF)->read_end = 0,\\\n+   (JCF)->read_state = 0, (JCF)->filename = (JCF)->classname = 0, \\\n+   CPOOL_INIT(&(JCF)->cpool), (JCF)->java_source = 0)\n+\n+/* Given that PTR points to a 2-byte unsigned integer in network\n+   (big-endian) byte-order, return that integer. */\n+#define GET_u2(PTR) (((PTR)[0] << 8) | ((PTR)[1]))\n+/* Like GET_u2, but for little-endian format. */\n+#define GET_u2_le(PTR) (((PTR)[1] << 8) | ((PTR)[0]))\n+\n+/* Given that PTR points to a 4-byte unsigned integer in network\n+   (big-endian) byte-order, return that integer. */\n+#define GET_u4(PTR) (((JCF_u4)(PTR)[0] << 24) | ((JCF_u4)(PTR)[1] << 16) \\\n+  | ((JCF_u4)(PTR)[2] << 8) | ((JCF_u4)(PTR)[3]))\n+/* Like GET_u4, but for little-endian order. */\n+#define GET_u4_le(PTR) (((JCF_u4)(PTR)[3] << 24) | ((JCF_u4)(PTR)[2] << 16) \\\n+  | ((JCF_u4)(PTR)[1] << 8) | ((JCF_u4)(PTR)[0]))\n+\n+/* Make sure there are COUNT bytes readable. */\n+#define JCF_FILL(JCF, COUNT) \\\n+  ((JCF)->read_end-(JCF)->read_ptr >= (COUNT) ? 0 : (*(JCF)->filbuf)(JCF, COUNT))\n+#define JCF_GETC(JCF) (JCF_FILL(JCF, 1) ? -1 : *(JCF)->read_ptr++)\n+#define JCF_READ(JCF, BUFFER, N) \\\n+    (memcpy (BUFFER, (JCF)->read_ptr, N), (JCF)->read_ptr += (N))\n+#define JCF_SKIP(JCF,N) ((JCF)->read_ptr += (N))\n+#define JCF_readu(JCF) (*(JCF)->read_ptr++)\n+\n+/* Reads an unsigned 2-byte integer in network (big-endian) byte-order\n+   from JCF.  Returns that integer.\n+   Does not check for EOF (make sure to call JCF_FILL before-hand). */\n+#define JCF_readu2(JCF) ((JCF)->read_ptr += 2, GET_u2 ((JCF)->read_ptr-2))\n+#define JCF_readu2_le(JCF) ((JCF)->read_ptr += 2, GET_u2_le((JCF)->read_ptr-2))\n+\n+/* Like JCF_readu2, but read a 4-byte unsigned integer. */\n+#define JCF_readu4(JCF) ((JCF)->read_ptr += 4, GET_u4 ((JCF)->read_ptr-4))\n+#define JCF_readu4_le(JCF) ((JCF)->read_ptr += 4, GET_u4_le((JCF)->read_ptr-4))\n+\n+#define JCF_TELL(JCF) ((JCF)->read_ptr - (JCF)->buffer)\n+#define JCF_SEEK(JCF, POS) ((JCF)->read_ptr = (JCF)->buffer + (POS))\n+\n+#define ACC_PUBLIC 0x0001\n+#define ACC_PRIVATE 0x0002\n+#define ACC_PROTECTED 0x0004\n+#define ACC_STATIC 0x0008\n+#define ACC_FINAL 0x0010\n+#define ACC_SYNCHRONIZED 0x0020\n+#define ACC_SUPER 0x0020\n+#define ACC_VOLATILE 0x0040\n+#define ACC_TRANSIENT 0x0080\n+#define ACC_NATIVE 0x0100\n+#define ACC_INTERFACE 0x0200\n+#define ACC_ABSTRACT 0x0400\n+\n+#define CONSTANT_Class 7\n+#define CONSTANT_Fieldref 9\n+#define CONSTANT_Methodref 10\n+#define CONSTANT_InterfaceMethodref 11\n+#define CONSTANT_String 8\n+#define CONSTANT_Integer 3\n+#define CONSTANT_Float 4\n+#define CONSTANT_Long 5\n+#define CONSTANT_Double 6\n+#define CONSTANT_NameAndType 12\n+#define CONSTANT_Utf8 1\n+#define CONSTANT_Unicode 2\n+\n+extern char *classpath;\n+#define DEFAULT_CLASS_PATH \".\"\n+\n+extern char *find_class PROTO ((const char *, int, JCF*, int));\n+extern char *find_classfile PROTO ((char *, JCF*));\n+extern int jcf_filbuf_from_stdio PROTO ((JCF *jcf, int count));\n+extern void jcf_out_of_synch PROTO((JCF *));\n+extern int jcf_unexpected_eof PROTO ((JCF*, int));\n+\n+/* Extract a character from a Java-style Utf8 string.\n+ * PTR points to the current character.\n+ * LIMIT points to the end of the Utf8 string.\n+ * PTR is incremented to point after the character thta gets returns.\n+ * On an error, -1 is returned. */\n+#define UTF8_GET(PTR, LIMIT) \\\n+  ((PTR) >= (LIMIT) ? -1 \\\n+   : *(PTR) < 128 ? *(PTR)++ \\\n+   : (*(PTR)&0xE0) == 0xC0 && ((PTR)+=2)<=(LIMIT) && ((PTR)[-1]&0xC0) == 0x80 \\\n+   ? (((PTR)[-2] & 0x1F) << 6) + ((PTR)[-1] & 0x3F) \\\n+   : (*(PTR) & 0xF0) == 0xE0 && ((PTR) += 3) <= (LIMIT) \\\n+   && ((PTR)[-2] & 0xC0) == 0x80 && ((PTR)[-1] & 0xC0) == 0x80 \\\n+   ? (((PTR)[-3]&0x1F) << 12) + (((PTR)[-2]&0x3F) << 6) + ((PTR)[-1]&0x3F) \\\n+   : ((PTR)++, -1))\n+\n+/* Debug macros, for the front end */\n+\n+extern int quiet_flag;\n+#ifdef SOURCE_FRONTEND_DEBUG\n+#undef SOURCE_FRONTEND_DEBUG\n+#define SOURCE_FRONTEND_DEBUG(X)\t\t\t\t\\\n+  {if (!quiet_flag) {printf (\"* \"); printf X; putchar ('\\n');} }\n+#else\n+#define SOURCE_FRONTEND_DEBUG(X)\n+#endif\n+\n+#endif"}, {"sha": "99065927756e9311889f98bd46ddab9701024d2d", "filename": "gcc/java/jv-scan.c", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjv-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjv-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjv-scan.c?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,235 @@\n+/* Main for jv-scan\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Contributed by Alexandre Petit-Bianco (apbianco@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#ifdef __STDC__\n+#include <stdarg.h>\n+#else\n+#include <varargs.h>\n+#endif\n+\n+#include \"gansidecl.h\"\t\t/* Definitions of PROTO and VPROTO */\n+#include \"obstack.h\"\t\t/* We use obstacks in lex.c */\n+\n+void fatal VPROTO((char *s, ...));\n+void warning VPROTO((char *s, ...));\n+void gcc_obstack_init PROTO ((struct obstack *obstack));\n+extern void reset_report PROTO ((void));\n+\n+#define JC1_LITE\n+#include \"parse.h\"\n+\n+/* Current input file and output file IO streams.  */\n+FILE *finput, *out;\n+\n+/* Current input filename.  */\n+char *input_filename;\n+\n+/* Executable name.  */\n+char *exec_name;\n+\n+/* Flags matching command line options.  */\n+int flag_find_main = 0;\n+int flag_dump_class = 0;\n+int flag_list_filename = 0;\n+\n+/* jc1-lite main entry point */\n+int\n+main (argc, argv, envp)\n+     int argc;\n+     char **argv;\n+     char **envp;\n+{\n+  int i = 1;\n+  char *output_file = NULL;\n+  long ft;\n+\n+  exec_name = argv[0];\n+\n+  /* Default for output */\n+  out = stdout;\n+\n+  /* Process options first */\n+  while (argv [i])\n+    {\n+      if (argv [i][0] == '-')\n+\t{\n+\t  /* Dump result into a file */\n+\t  if (!strcmp (argv [i], \"-o\") && i+1 < argc)\n+\t    {\n+\t      argv [i] = NULL;\n+\t      output_file = argv [++i];\n+\t      argv [i] = NULL;\n+\t    }\n+\n+\t  /* Print the name of the class that contains main */\n+\t  else if (!strcmp (argv [i], \"--print-main\"))\n+\t    flag_find_main = 1;\n+\n+\t  else if (!strcmp (argv [i], \"--list-filename\"))\n+\t    flag_list_filename = 1;\n+\n+\t  /* List all the classes found in a source file */\n+\t  else if (!strcmp (argv [i], \"--list-class\"))\n+\t    flag_dump_class = 1;\n+\n+\t  else\n+\t    warning (\"Unrecognized argument `%s'\", argv[i]);\n+\n+\t  /* non recognized argument ignored silently */ \n+\t  argv [i] = NULL;\t/* Nullify so it's not considered a file */\n+\t}\n+      i++;\n+    }\n+\n+  /* No flags? Do nothing */\n+  if (!flag_find_main && !flag_dump_class)\n+    exit (0);\n+\n+  /* Check on bad usage */\n+  if (flag_find_main && flag_dump_class)\n+    fatal (\"Options `--print-main' and `--list-class' can't be turned on \"\n+\t   \"at the same time\", argv [0]);\n+\n+  if (output_file && !(out = fopen (output_file, \"w\")))\n+    fatal (\"Can't open output file `%s'\", argv [0], output_file);\n+\n+  ft = ftell (out);\n+\n+  gcc_obstack_init (&temporary_obstack);\n+  java_push_parser_context ();\n+\n+  for ( i = 1; i < argc; i++ )\n+    if (argv [i])\n+      {\n+\tinput_filename = argv [i];\n+\tif ( (finput = fopen (argv [i], \"r\")) )\n+\t  {\n+\t    java_init_lex ();\n+\t    yyparse ();\n+\t    if (ftell (out) != ft)\n+\t      fputc ('\\n', out);\n+\t    ft = ftell (out);\n+\t    fclose (finput);\n+\t    reset_report ();\n+\t  }\n+\telse\n+\t  fatal (\"File not found `%s'\", argv [0], argv [i]);\n+      }\n+\n+  /* Flush and close */\n+  if (ftell (out) != ft)\n+    fputc ('\\n', out);\n+  if (!output_file)\n+    fclose (out);\n+\n+  exit (0);\n+}\n+\n+/* Error report, memory, obstack initialization and other utility\n+   functions */\n+\n+void\n+fatal VPROTO((char *s, ...))\n+{\n+#ifndef __STDC__\n+  char *s;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, s);\n+\n+#ifndef __STDC__\n+  s = va_arg (ap, char *);\n+#endif\n+\n+  fprintf (stderr, \"%s: error: \", exec_name);\n+  vfprintf (stderr, s, ap);\n+  fputc ('\\n', stderr);\n+  va_end (ap);\n+  exit (1);\n+}\n+\n+char *\n+xmalloc (size)\n+     unsigned size;\n+{\n+  register char *value;\n+\n+  if (size == 0)\n+    size = 1;\n+\n+  value = (char *) malloc (size);\n+  if (value == 0)\n+    fatal (\"virtual memory exhausted\");\n+  return value;\n+}\n+\n+char *\n+xstrdup (string)\n+     char *string;\n+{\n+  int length = strlen (string)+1;\n+  char *to_return = xmalloc (length);\n+  strcpy (to_return, string);\n+  return to_return;\n+}\n+\n+void\n+warning VPROTO((char *s, ...))\n+{\n+#ifndef __STDC__\n+  char *s;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, s);\n+\n+#ifndef __STDC__\n+  s = va_arg (ap, char *);\n+#endif\n+\n+  fprintf (stderr, \"%s: warning: \", exec_name);\n+  vfprintf (stderr, s, ap);\n+  fputc ('\\n', stderr);\n+  va_end (ap);\n+}\n+\n+void\n+gcc_obstack_init (obstack)\n+     struct obstack *obstack;\n+{\n+  /* Let particular systems override the size of a chunk.  */\n+#ifndef OBSTACK_CHUNK_SIZE\n+#define OBSTACK_CHUNK_SIZE 0\n+#endif\n+  /* Let them override the alloc and free routines too.  */\n+#ifndef OBSTACK_CHUNK_ALLOC\n+#define OBSTACK_CHUNK_ALLOC xmalloc\n+#endif\n+#ifndef OBSTACK_CHUNK_FREE\n+#define OBSTACK_CHUNK_FREE free\n+#endif\n+  _obstack_begin (obstack, OBSTACK_CHUNK_SIZE, 0,\n+\t\t  (void *(*) ()) OBSTACK_CHUNK_ALLOC,\n+\t\t  (void (*) ()) OBSTACK_CHUNK_FREE);\n+}"}, {"sha": "ce7c60a315e29e297c483816c4d2b8f9d1ce1265", "filename": "gcc/java/jvgenmain.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjvgenmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjvgenmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvgenmain.c?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,124 @@\n+/* Program to generate \"main\" a Java(TM) class containing a main method.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA. \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Written by Per Bothner <bothner@cygnus.com> */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include \"config.h\"\n+#include \"obstack.h\"\n+\n+const char main_method_prefix[] = \"main__\";\n+const char main_method_suffix[] = \"Pt6JArray1ZPQ34java4lang6String\";\n+const char class_mangling_prefix[] = \"_CL_\";\n+\n+struct obstack name_obstack;\n+\n+void\n+error (const char *str)\n+{\n+  fprintf (stderr, \"%s\\n\", str);\n+  exit (-1);\n+}\n+\n+void *\n+xmalloc (size)\n+     size_t size;\n+{\n+  void *ptr = malloc (size);\n+  if (ptr == NULL)\n+    {\n+      fprintf (stderr, \"Not enough memory!\\n\");\n+      exit (-1);\n+    }\n+  return ptr;\n+}\n+\n+void\n+gcc_obstack_init (obstack)\n+     struct obstack *obstack;\n+{\n+  /* Let particular systems override the size of a chunk.  */\n+#ifndef OBSTACK_CHUNK_SIZE\n+#define OBSTACK_CHUNK_SIZE 0\n+#endif\n+  /* Let them override the alloc and free routines too.  */\n+#ifndef OBSTACK_CHUNK_ALLOC\n+#define OBSTACK_CHUNK_ALLOC xmalloc\n+#endif\n+#ifndef OBSTACK_CHUNK_FREE\n+#define OBSTACK_CHUNK_FREE free\n+#endif\n+  _obstack_begin (obstack, OBSTACK_CHUNK_SIZE, 0,\n+\t\t  (void *(*) ()) OBSTACK_CHUNK_ALLOC,\n+\t\t  (void (*) ()) OBSTACK_CHUNK_FREE);\n+}\n+\n+int\n+main (int argc, const char **argv)\n+{\n+  const char *classname;\n+  FILE *stream;\n+  char *mangled_classname;\n+\n+  if (argc < 2 || argc > 3)\n+    {\n+      fprintf (stderr, \"Usage: %s CLASSNAME [OUTFILE]\\n\", argv[0]);\n+      exit(-1);\n+    }\n+\n+  classname = argv[1];\n+\n+  gcc_obstack_init (&name_obstack);\n+  append_gpp_mangled_classtype (&name_obstack, classname);\n+  mangled_classname = obstack_finish (&name_obstack);\n+\n+  if (argc > 2 && strcmp (argv[2], \"-\") != 0)\n+    {\n+      const char *outfile = argv[2];\n+      stream = fopen (outfile, \"w\");\n+      if (stream == NULL)\n+\t{\n+\t  fprintf (stderr, \"%s: Cannot open output file: %s\\n\",\n+\t\t   argv[0], outfile);\n+\t  exit (-1);\n+\t}\n+    }\n+  else\n+    stream = stdout;\n+  fprintf (stream, \"extern struct Class %s%s;\\n\",\n+\t   class_mangling_prefix, mangled_classname);\n+  fprintf (stream, \"int main (int argc, const char **argv)\\n\");\n+  fprintf (stream, \"{\\n\");\n+  fprintf (stream, \"   JvRunMain (&%s%s, argc, argv);\\n\",\n+\t   class_mangling_prefix, mangled_classname);\n+  fprintf (stream, \"}\\n\");\n+  if (stream != stdout && fclose (stream) != 0)\n+    {\n+      fprintf (stderr, \"%s: Failed to close output file %s\\n\",\n+\t       argv[0], argv[2]);\n+      exit (-1);\n+    }\n+  return 0;\n+}"}, {"sha": "5f9381167d8efa01025f3201e81749f8b9ad1b67", "filename": "gcc/java/jvspec.c", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjvspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fjvspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvspec.c?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,357 @@\n+/* Specific flags and argument handling of the front-end of the \n+   GNU compiler for the Java(TM) language.\n+   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA. \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+#include \"config.h\"\n+\n+#include \"system.h\"\n+\n+#include \"gansidecl.h\"\n+\n+#if defined (WITH_THREAD_posix) || defined (WITH_THREAD_pthreads)\n+#define THREAD_NAME \"-lpthread\"\n+#elif defined (WITH_THREAD_qt)\n+#define THREAD_NAME \"-lqthreads\"\n+#endif\n+\n+/* This bit is set if we saw a `-xfoo' language specification.  */\n+#define LANGSPEC\t(1<<1)\n+/* This bit is set if they did `-lm' or `-lmath'.  */\n+#define MATHLIB\t\t(1<<2)\n+/* This bit is set if they did `-lc'.  */\n+#define WITHLIBC\t(1<<3)\n+/* This bit is set if they did `-lgc'.  */\n+#define GCLIB\t\t(1<<4)\n+/* This bit is set if they did `-lpthread' (or added some other thread\n+   library).  */\n+#define THREADLIB\t(1<<5)\n+\n+#ifndef MATH_LIBRARY\n+#define MATH_LIBRARY \"-lm\"\n+#endif\n+\n+extern char *xmalloc PROTO((size_t));\n+extern int do_spec\t\tPROTO((char *));\n+extern char *input_filename;\n+extern size_t input_filename_length;\n+\n+char *main_class_name = NULL;\n+int lang_specific_extra_outfiles = 0;\n+\n+char jvgenmain_spec[] =\n+  \"jvgenmain %i %{!pipe:%g.i} |\\n\\\n+   cc1 %{!pipe:%g.i} %1 \\\n+\t\t   %{!Q:-quiet} -dumpbase %b.c %{d*} %{m*} %{a*}\\\n+\t\t   %{g*} %{O*} \\\n+\t\t   %{v:-version} %{pg:-p} %{p} %{f*}\\\n+\t\t   %{aux-info*}\\\n+\t\t   %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n+\t\t   %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\\n\\\n+              %{!S:as %a %Y -o %w%b%O %{!pipe:%g.s} %A\\n }\";\n+\n+void\n+lang_specific_driver (fn, in_argc, in_argv, in_added_libraries)\n+     void (*fn)();\n+     int *in_argc;\n+     char ***in_argv;\n+     int *in_added_libraries;\n+{\n+  int i, j;\n+\n+  /* If non-zero, the user gave us the `-v' flag.  */ \n+  int saw_verbose_flag = 0;\n+\n+  /* This will be 0 if we encounter a situation where we should not\n+     link in libjava.  */\n+  int library = 1;\n+\n+  /* The number of arguments being added to what's in argv, other than\n+     libraries.  We use this to track the number of times we've inserted\n+     -xc++/-xnone.  */\n+  int added = 2;\n+\n+  /* Used to track options that take arguments, so we don't go wrapping\n+     those with -xc++/-xnone.  */\n+  char *quote = NULL;\n+\n+  /* The new argument list will be contained in this.  */\n+  char **arglist;\n+\n+  /* Non-zero if we saw a `-xfoo' language specification on the\n+     command line.  Used to avoid adding our own -xc++ if the user\n+     already gave a language for the file.  */\n+  int saw_speclang = 0;\n+\n+  /* \"-lm\" or \"-lmath\" if it appears on the command line.  */\n+  char *saw_math = 0;\n+\n+  /* \"-lc\" if it appears on the command line.  */\n+  char *saw_libc = 0;\n+\n+  /* \"-lgc\" if it appears on the command line.  */\n+  char *saw_gc = 0;\n+\n+  /* Saw `-l' option for the thread library.  */\n+  char *saw_threadlib = 0;\n+\n+  /* Saw `-ljava' on command line.  */\n+  int saw_libjava = 0;\n+\n+  /* An array used to flag each argument that needs a bit set for\n+     LANGSPEC, MATHLIB, WITHLIBC, or GCLIB.  */\n+  int *args;\n+\n+  /* By default, we throw on the math library.  */\n+  int need_math = 1;\n+\n+  /* By default, we throw in the thread library (if one is required).\n+   */\n+  int need_thread = 1;\n+\n+  /* The total number of arguments with the new stuff.  */\n+  int argc;\n+\n+  /* The argument list.  */\n+  char **argv;\n+\n+  /* The number of libraries added in.  */\n+  int added_libraries;\n+\n+  /* The total number of arguments with the new stuff.  */\n+  int num_args = 1;\n+\n+  argc = *in_argc;\n+  argv = *in_argv;\n+  added_libraries = *in_added_libraries;\n+\n+  args = (int *) xmalloc (argc * sizeof (int));\n+  bzero ((char *) args, argc * sizeof (int));\n+\n+  for (i = 1; i < argc; i++)\n+    {\n+      /* If the previous option took an argument, we swallow it here.  */\n+      if (quote)\n+\t{\n+\t  quote = NULL;\n+\t  continue;\n+\t}\n+\n+      /* We don't do this anymore, since we don't get them with minus\n+\t signs on them.  */\n+      if (argv[i][0] == '\\0' || argv[i][1] == '\\0')\n+\tcontinue;\n+\n+      if (argv[i][0] == '-')\n+\t{\n+\t  if (library != 0 && (strcmp (argv[i], \"-nostdlib\") == 0\n+\t\t\t       || strcmp (argv[i], \"-nodefaultlibs\") == 0))\n+\t    {\n+\t      library = 0;\n+\t    }\n+\t  else if (strcmp (argv[i], \"-lm\") == 0\n+\t\t   || strcmp (argv[i], \"-lmath\") == 0\n+#ifdef ALT_LIBM\n+\t\t   || strcmp (argv[i], ALT_LIBM) == 0\n+#endif\n+\t\t  )\n+\t    {\n+\t      args[i] |= MATHLIB;\n+\t      need_math = 0;\n+\t    }\n+\t  else if (strncmp (argv[i], \"-fmain=\", 7) == 0)\n+\t    main_class_name = argv[i] + 7;\n+\t  else if (strcmp (argv[i], \"-ljava\") == 0)\n+\t    saw_libjava = 1;\n+\t  else if (strcmp (argv[i], \"-lc\") == 0)\n+\t    args[i] |= WITHLIBC;\n+\t  else if (strcmp (argv[i], \"-lgc\") == 0)\n+\t    args[i] |= GCLIB;\n+#ifdef THREAD_NAME\n+\t  else if (strcmp (argv[i], THREAD_NAME) == 0)\n+\t    {\n+\t      args[i] |= THREADLIB;\n+\t      need_thread = 0;\n+\t    }\n+#endif\n+\t  else if (strcmp (argv[i], \"-v\") == 0)\n+\t    {\n+\t      saw_verbose_flag = 1;\n+\t      if (argc == 2)\n+\t\t{\n+\t\t  /* If they only gave us `-v', don't try to link\n+\t\t     in libjava.  */ \n+\t\t  library = 0;\n+\t\t}\n+\t    }\n+\t  else if (strncmp (argv[i], \"-x\", 2) == 0)\n+\t    saw_speclang = 1;\n+\t  else if (((argv[i][2] == '\\0'\n+\t\t     && (char *)strchr (\"bBVDUoeTuIYmLiA\", argv[i][1]) != NULL)\n+\t\t    || strcmp (argv[i], \"-Tdata\") == 0))\n+\t    quote = argv[i];\n+\t  else if (library != 0 && ((argv[i][2] == '\\0'\n+\t\t     && (char *) strchr (\"cSEM\", argv[i][1]) != NULL)\n+\t\t    || strcmp (argv[i], \"-MM\") == 0))\n+\t    {\n+\t      /* Don't specify libraries if we won't link, since that would\n+\t\t cause a warning.  */\n+\t      library = 0;\n+\t      added -= 2;\n+\t    }\n+\t  else\n+\t    /* Pass other options through.  */\n+\t    continue;\n+\t}\n+      else\n+\t{\n+\t  int len; \n+\n+\t  if (saw_speclang)\n+\t    {\n+\t      saw_speclang = 0;\n+\t      continue;\n+\t    }\n+\n+\t  /* If the filename ends in .c or .i, put options around it.\n+\t     But not if a specified -x option is currently active.  */\n+\t  len = strlen (argv[i]);\n+\t  if (len > 2\n+\t      && (argv[i][len - 1] == 'c' || argv[i][len - 1] == 'i')\n+\t      && argv[i][len - 2] == '.')\n+\t    {\n+\t      args[i] |= LANGSPEC;\n+\t      added += 2;\n+\t    }\n+\t}\n+    }\n+\n+  if (quote)\n+    (*fn) (\"argument to `%s' missing\\n\", quote);\n+\n+  /* If we know we don't have to do anything, bail now.  */\n+  if (! added && ! library && main_class_name == NULL)\n+    {\n+      free (args);\n+      return;\n+    }\n+\n+  num_args = argc + added + need_math + need_thread;\n+  if (main_class_name)\n+    {\n+      lang_specific_extra_outfiles++;\n+    }\n+  arglist = (char **) xmalloc (num_args * sizeof (char *));\n+\n+  /* NOTE: We start at 1 now, not 0.  */\n+  for (i = 0, j = 0; i < argc; i++, j++)\n+    {\n+      arglist[j] = argv[i];\n+\n+      if (strncmp (argv[i], \"-fmain=\", 7) == 0)\n+\t{\n+\t  --j;\n+\t  continue;\n+\t}\n+\n+      /* Make sure -ljava is before the math library, since libjava\n+\t itself uses those math routines.  */\n+      if (!saw_math && (args[i] & MATHLIB) && library)\n+\t{\n+\t  --j;\n+\t  saw_math = argv[i];\n+\t}\n+\n+      /* Likewise -ljava must come before -lc.  */\n+      if (!saw_libc && (args[i] & WITHLIBC) && library)\n+\t{\n+\t  --j;\n+\t  saw_libc = argv[i];\n+\t}\n+\n+      /* And -ljava must come before -lgc.  */\n+      if (!saw_gc && (args[i] & GCLIB) && library)\n+\t{\n+\t  --j;\n+\t  saw_gc = argv[i];\n+\t}\n+\n+      /* And -ljava must come before thread library.  */\n+      if (!saw_threadlib && (args[i] & THREADLIB) && library)\n+\t{\n+\t  --j;\n+\t  saw_threadlib = argv[i];\n+\t}\n+  }\n+\n+  /* Add `-ljava' if we haven't already done so.  */\n+  if (library && ! saw_libjava)\n+    {\n+      arglist[j++] = \"-ljava\";\n+      added_libraries++;\n+    }\n+\n+  if (saw_math)\n+    arglist[j++] = saw_math;\n+  else if (library)\n+    {\n+      arglist[j++] = MATH_LIBRARY;\n+      added_libraries++;\n+    }\n+\n+  /* FIXME: we need a way to know when the GC library should be\n+     added.  Then we can add it if the user hasn't already.  */\n+  if (saw_gc)\n+    arglist[j++] = saw_gc;\n+\n+  /* Thread library must come after GC library as well as after\n+     -ljava.  */\n+  if (saw_threadlib)\n+    arglist[j++] = saw_threadlib;\n+#ifdef THREAD_NAME\n+  else if (library)\n+    {\n+      arglist[j++] = THREAD_NAME;\n+      added_libraries++;\n+    }\n+#endif\n+\n+  if (saw_libc)\n+    arglist[j++] = saw_libc;\n+\n+  arglist[j] = NULL;\n+\n+  *in_argc = j;\n+  *in_argv = arglist;\n+  *in_added_libraries = added_libraries;\n+}\n+\n+int\n+lang_specific_pre_link ()\n+{\n+  if (main_class_name == NULL)\n+    return 0;\n+  input_filename = main_class_name;\n+  input_filename_length = strlen (main_class_name);\n+  return do_spec (jvgenmain_spec);\n+}"}, {"sha": "38f02572809c097abc1b6030e2af0a7433583780", "filename": "gcc/java/keyword.gperf", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fkeyword.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fkeyword.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fkeyword.gperf?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,80 @@\n+%{\n+/* Keyword definition for the GNU compiler for the Java(TM) language.\n+   Copyright (C) 1997, 1998 Free Software Foundation, Inc.\n+   Contributed by Alexandre Petit-Bianco (apbianco@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+%}\n+struct java_keyword { char *name; int token; };\n+%%\n+abstract, ABSTRACT_TK\n+default, DEFAULT_TK\n+if, IF_TK\n+private, PRIVATE_TK\n+throw, THROW_TK\n+boolean, BOOLEAN_TK\n+do, DO_TK\n+implements, IMPLEMENTS_TK\n+protected, PROTECTED_TK\n+throws, THROWS_TK\n+break, BREAK_TK\n+double, DOUBLE_TK\n+import, IMPORT_TK\n+public, PUBLIC_TK\n+transient, TRANSIENT_TK\n+byte, BYTE_TK\n+else, ELSE_TK\n+instanceof, INSTANCEOF_TK\n+return, RETURN_TK\n+try, TRY_TK\n+case, CASE_TK\n+extends, EXTENDS_TK\n+int, INT_TK\n+short, SHORT_TK\n+void, VOID_TK\n+catch, CATCH_TK\n+final, FINAL_TK\n+interface, INTERFACE_TK\n+static, STATIC_TK\n+volatile, VOLATILE_TK\n+char, CHAR_TK\n+finally, FINALLY_TK\n+long, LONG_TK\n+super, SUPER_TK\n+while, WHILE_TK\n+class, CLASS_TK\n+float, FLOAT_TK\n+native, NATIVE_TK\n+switch, SWITCH_TK\n+const, CONST_TK\n+for, FOR_TK\n+new, NEW_TK\n+synchronized, SYNCHRONIZED_TK\n+continue, CONTINUE_TK\n+goto, GOTO_TK\n+package, PACKAGE_TK\n+this, THIS_TK\n+# true, false and null aren't keyword. But we match them easily this way\n+true, TRUE_TK\n+false, FALSE_TK\n+null, NULL_TK"}, {"sha": "c9bd1711c44c34137917eef5d87b0e93ac96cda4", "filename": "gcc/java/keyword.h", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fkeyword.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fkeyword.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fkeyword.h?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,165 @@\n+/* C code produced by gperf version 2.5 (GNU C++ version) */\n+/* Command-line: gperf -p -t -j1 -i 1 -g -o -N java_keyword -k1,3,$ keyword.gperf  */\n+/* Keyword definitions for the GNU compiler for the Java(TM) language.\n+   Copyright (C) 1997, 1998 Free Software Foundation, Inc.\n+   Contributed by Alexandre Petit-Bianco (apbianco@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+struct java_keyword { char *name; int token; };\n+\n+#define TOTAL_KEYWORDS 50\n+#define MIN_WORD_LENGTH 2\n+#define MAX_WORD_LENGTH 12\n+#define MIN_HASH_VALUE 6\n+#define MAX_HASH_VALUE 86\n+/* maximum key range = 81, duplicates = 0 */\n+\n+#ifdef __GNUC__\n+inline\n+#endif\n+static unsigned int\n+hash (str, len)\n+     register char *str;\n+     register int unsigned len;\n+{\n+  static unsigned char asso_values[] =\n+    {\n+     87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n+     87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n+     87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n+     87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n+     87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n+     87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n+     87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n+     87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n+     87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n+     87, 87, 87, 87, 87, 87, 87, 18, 37, 38,\n+     27,  1, 30,  3, 12,  8, 87,  2, 11, 87,\n+      8,  1,  5, 87, 24,  1,  1, 30,  2, 36,\n+     87,  1, 87, 87, 87, 87, 87, 87,\n+    };\n+  register int hval = len;\n+\n+  switch (hval)\n+    {\n+      default:\n+      case 3:\n+        hval += asso_values[str[2]];\n+      case 2:\n+      case 1:\n+        hval += asso_values[str[0]];\n+        break;\n+    }\n+  return hval + asso_values[str[len - 1]];\n+}\n+\n+#ifdef __GNUC__\n+inline\n+#endif\n+struct java_keyword *\n+java_keyword (str, len)\n+     register char *str;\n+     register unsigned int len;\n+{\n+  static struct java_keyword wordlist[] =\n+    {\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"try\",  TRY_TK},\n+      {\"else\",  ELSE_TK},\n+      {\"short\",  SHORT_TK},\n+      {\"goto\",  GOTO_TK},\n+      {\"extends\",  EXTENDS_TK},\n+      {\"\",}, {\"\",}, \n+      {\"int\",  INT_TK},\n+      {\"this\",  THIS_TK},\n+      {\"\",}, \n+      {\"native\",  NATIVE_TK},\n+      {\"\",}, {\"\",}, \n+      {\"interface\",  INTERFACE_TK},\n+      {\"import\",  IMPORT_TK},\n+      {\"private\",  PRIVATE_TK},\n+      {\"volatile\",  VOLATILE_TK},\n+      {\"\",}, \n+      {\"implements\",  IMPLEMENTS_TK},\n+      {\"\",}, \n+      {\"long\",  LONG_TK},\n+      {\"switch\",  SWITCH_TK},\n+      {\"abstract\",  ABSTRACT_TK},\n+      {\"transient\",  TRANSIENT_TK},\n+      {\"do\",  DO_TK},\n+      {\"\",}, \n+      {\"throws\",  THROWS_TK},\n+      {\"\",}, \n+      {\"null\",  NULL_TK},\n+      {\"super\",  SUPER_TK},\n+      {\"true\",  TRUE_TK},\n+      {\"float\",  FLOAT_TK},\n+      {\"\",}, \n+      {\"return\",  RETURN_TK},\n+      {\"if\",  IF_TK},\n+      {\"void\",  VOID_TK},\n+      {\"protected\",  PROTECTED_TK},\n+      {\"byte\",  BYTE_TK},\n+      {\"case\",  CASE_TK},\n+      {\"break\",  BREAK_TK},\n+      {\"finally\",  FINALLY_TK},\n+      {\"false\",  FALSE_TK},\n+      {\"synchronized\",  SYNCHRONIZED_TK},\n+      {\"instanceof\",  INSTANCEOF_TK},\n+      {\"while\",  WHILE_TK},\n+      {\"package\",  PACKAGE_TK},\n+      {\"const\",  CONST_TK},\n+      {\"boolean\",  BOOLEAN_TK},\n+      {\"final\",  FINAL_TK},\n+      {\"continue\",  CONTINUE_TK},\n+      {\"catch\",  CATCH_TK},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"class\",  CLASS_TK},\n+      {\"static\",  STATIC_TK},\n+      {\"double\",  DOUBLE_TK},\n+      {\"default\",  DEFAULT_TK},\n+      {\"throw\",  THROW_TK},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"for\",  FOR_TK},\n+      {\"\",}, \n+      {\"new\",  NEW_TK},\n+      {\"char\",  CHAR_TK},\n+      {\"\",}, \n+      {\"public\",  PUBLIC_TK},\n+    };\n+\n+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n+    {\n+      register int key = hash (str, len);\n+\n+      if (key <= MAX_HASH_VALUE && key >= 0)\n+        {\n+          register char *s = wordlist[key].name;\n+\n+          if (*s == *str && !strcmp (str + 1, s + 1))\n+            return &wordlist[key];\n+        }\n+    }\n+  return 0;\n+}"}, {"sha": "f421e6a16c737f436b1837fa4498ff9ba26f6ce3", "filename": "gcc/java/lang-options.h", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang-options.h?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,35 @@\n+/* Switch definitions for the GNU compiler for the Java(TM) language.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* This is the contribution to the `lang_options' array in gcc.c for\n+   java.  */\n+\n+DEFINE_LANG_NAME (\"Java\")\n+     \n+  { \"-fbounds-check\", \"\" },\n+  { \"-fno-bounds-check\", \"Disable automatic array bounds checking\" },\n+  { \"-fassume-compiled\", \"Make is_compiled_class return 1\"},\n+  { \"-fno-assume-compiled\", \"\" },\n+  { \"-femit-class-file\", \"\" },\n+  { \"-femit-class-files\", \"Dump class files to <name>.class\" },"}, {"sha": "f86c327d0c0532c1eac1b84d2d7dcfaa25e39fdf", "filename": "gcc/java/lang-specs.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang-specs.h?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,38 @@\n+/* Definitions for specs for the GNU compiler for the Java(TM) language.\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* This is the contribution to the `default_compilers' array in gcc.c for\n+   Java.  */\n+\n+  {\".java\",   \"@java\" },\n+  {\".class\",  \"@java\" },\n+  {\"@java\",\n+   \"%{!M:%{!MM:%{!E:jc1 %i %1 %2 %{!Q:-quiet} %{d*} %{m*} %{a}\\\n+\t\t\t    %{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi}\\\n+\t\t\t    %{traditional} %{v:-version} %{pg:-p} %{p}\\\n+\t\t\t    %{f*} %{+e*} %{aux-info*}\\\n+\t\t\t    %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n+\t\t\t    %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\\n\\\n+\t            %{!S:as %a %Y\\\n+\t\t\t    %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O}\\\n+\t\t\t    %{!pipe:%g.s} %A\\n }}}}\"},"}, {"sha": "ddaff0cc6b51fc0dd011dd5aa682757b7e6fb82f", "filename": "gcc/java/lang.c", "status": "added", "additions": 406, "deletions": 0, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,406 @@\n+/* Java(TM) language-specific utility routines.\n+   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA. \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Hacked by Per Bothner <bothner@cygnus.com> February 1996. */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"input.h\"\n+#include \"java-tree.h\"\n+#include \"jcf.h\"\n+\n+int compiling_from_source;\n+\n+char *language_string = \"GNU Java\";\n+\n+/* Nonzero if we want to automatically do array bounds checking;\n+   on by default.  Use -fno-bounds-check to disable.  */\n+\n+int flag_bounds_check = 1;\n+\n+/* Nonzero if we should make is_compiled_class always return 1 for\n+   appropriate classes that we're referencing.  */\n+\n+int flag_assume_compiled = 1;\n+\n+int flag_emit_class_files = 0;\n+\n+/* From gcc/flags.h, and idicates if exceptions are turned on or not. */\n+\n+extern int flag_new_exceptions;\n+extern int flag_exceptions;\n+\n+/* Table of language-dependent -f options.\n+   STRING is the option name.  VARIABLE is the address of the variable.\n+   ON_VALUE is the value to store in VARIABLE\n+    if `-fSTRING' is seen as an option.\n+   (If `-fno-STRING' is seen as an option, the opposite value is stored.)  */\n+\n+static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n+{\n+  {\"bounds-check\", &flag_bounds_check, 1},\n+  {\"assume-compiled\", &flag_assume_compiled, 1},\n+  {\"emit-class-file\", &flag_emit_class_files, 1},\n+  {\"emit-class-files\", &flag_emit_class_files, 1},\n+};\n+\n+JCF main_jcf[1];\n+JCF *current_jcf;\n+\n+/*\n+ * process java-specific compiler command-line options\n+ */\n+int\n+lang_decode_option (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  char *p = argv[0];\n+  if (p[0] == '-' && p[1] == 'f')\n+    {\n+      /* Some kind of -f option.\n+\t P's value is the option sans `-f'.\n+\t Search for it in the table of options.  */\n+      int found = 0, j;\n+\n+      p += 2;\n+\n+      for (j = 0;\n+\t\t!found && j < sizeof (lang_f_options) / sizeof (lang_f_options[0]);\n+\t\tj++)\n+\t{\n+\t  if (!strcmp (p, lang_f_options[j].string))\n+\t    {\n+\t      *lang_f_options[j].variable = lang_f_options[j].on_value;\n+\t      /* A goto here would be cleaner,\n+\t\t but breaks the vax pcc.  */\n+\t      found = 1;\n+\t    }\n+\t  if (p[0] == 'n' && p[1] == 'o' && p[2] == '-'\n+\t      && ! strcmp (p+3, lang_f_options[j].string))\n+\t    {\n+\t      *lang_f_options[j].variable = ! lang_f_options[j].on_value;\n+\t      found = 1;\n+\t    }\n+\t}\n+      return found;\n+    }\n+\n+  return 0;\n+}\n+\n+FILE *finput;\n+char *\n+init_parse (filename)\n+     char *filename;\n+{\n+  /* Open input file.  */\n+\n+  if (filename == 0 || !strcmp (filename, \"-\"))\n+    {\n+      finput = stdin;\n+      filename = \"stdin\";\n+    }\n+  else\n+    finput = fopen (filename, \"r\");\n+  if (finput == 0)\n+    pfatal_with_name (filename);\n+\n+#ifdef IO_BUFFER_SIZE\n+  setvbuf (finput, (char *) xmalloc (IO_BUFFER_SIZE), _IOFBF, IO_BUFFER_SIZE);\n+#endif\n+  init_lex ();\n+\n+  return filename;\n+}\n+\n+void\n+finish_parse ()\n+{\n+  fclose (finput);\n+}\n+\n+/* Buffer used by lang_printable_name. */\n+static char *decl_buf = NULL;\n+\n+/* Allocated size of decl_buf. */\n+static int decl_buflen = 0;\n+\n+/* Length of used part of decl_buf;  position for next character. */\n+static int decl_bufpos = 0;\n+\n+/* Append the string STR to decl_buf.\n+   It length is given by LEN;  -1 means the string is nul-terminated. */\n+\n+static void\n+put_decl_string (str, len)\n+     char *str;\n+     int len;\n+{\n+  if (len < 0)\n+    len = strlen (str);\n+  if (decl_bufpos + len >= decl_buflen)\n+    {\n+      if (decl_buf == NULL)\n+\t{\n+\t  decl_buflen = len + 100;\n+\t  decl_buf = (char *) xmalloc (decl_buflen);\n+\t}\n+      else\n+\t{\n+\t  decl_buflen *= 2;\n+\t  decl_buf = (char *) xrealloc (decl_buf, decl_buflen);\n+\t}\n+    }\n+  strcpy (decl_buf + decl_bufpos, str);\n+  decl_bufpos += len;\n+}\n+\n+/* Append to decl_buf a printable name for NODE. */\n+\n+static void\n+put_decl_node (node)\n+     tree node;\n+{\n+  int was_pointer = 0;\n+  if (TREE_CODE (node) == POINTER_TYPE)\n+    {\n+      node = TREE_TYPE (node);\n+      was_pointer = 1;\n+    }\n+  if (TREE_CODE_CLASS (TREE_CODE (node)) == 'd'\n+      && DECL_NAME (node) != NULL_TREE)\n+    {\n+#if 0\n+      if (DECL_CONTEXT (node) != NULL_TREE)\n+\t{\n+\t  put_decl_node (DECL_CONTEXT (node));\n+\t  put_decl_string (\".\", 1);\n+\t}\n+#endif\n+      put_decl_node (DECL_NAME (node));\n+      if (TREE_CODE (node) == FUNCTION_DECL && TREE_TYPE (node) != NULL_TREE)\n+\t{\n+\t  int i = 0;\n+\t  tree args = TYPE_ARG_TYPES (TREE_TYPE (node));\n+\t  if (TREE_CODE (TREE_TYPE (node)) == METHOD_TYPE)\n+\t    args = TREE_CHAIN (args);\n+\t  put_decl_string (\"(\", 1);\n+\t  for ( ; args != NULL_TREE;  args = TREE_CHAIN (args), i++)\n+\t    {\n+\t      if (i > 0)\n+\t\tput_decl_string (\",\", 1);\n+\t      put_decl_node (TREE_VALUE (args));\n+\t    }\n+\t  put_decl_string (\")\", 1);\n+\t}\n+    }\n+  else if (TREE_CODE_CLASS (TREE_CODE (node)) == 't'\n+      && TYPE_NAME (node) != NULL_TREE)\n+    {\n+      if (TREE_CODE (node) == RECORD_TYPE && TYPE_ARRAY_P (node))\n+\t{\n+\t  put_decl_node (TYPE_ARRAY_ELEMENT (node));\n+\t  put_decl_string(\"[]\", 2);\n+\t}\n+      else if (node == promoted_byte_type_node)\n+\tput_decl_string (\"byte\", 4);\n+      else if (node == promoted_short_type_node)\n+\tput_decl_string (\"short\", 5);\n+      else if (node == promoted_char_type_node)\n+\tput_decl_string (\"char\", 4);\n+      else if (node == promoted_boolean_type_node)\n+\tput_decl_string (\"boolean\", 7);\n+      else if (node == void_type_node && was_pointer)\n+\tput_decl_string (\"null\", 4);\n+      else\n+\tput_decl_node (TYPE_NAME (node));\n+    }\n+  else if (TREE_CODE (node) == IDENTIFIER_NODE)\n+    put_decl_string (IDENTIFIER_POINTER (node), IDENTIFIER_LENGTH (node));\n+  else\n+    put_decl_string (\"<unknown>\", -1);\n+}\n+\n+/* Return a user-friendly name for DECL.\n+   The resulting string is only valid until the next call.\n+   The value of the hook decl_printable_name is this function,\n+   which is also called directly by lang_print_error. */\n+\n+char *\n+lang_printable_name (decl, v)\n+     tree decl;\n+     int v;\n+{\n+  decl_bufpos = 0;\n+  put_decl_node (decl);\n+  put_decl_string (\"\", 1);\n+  return decl_buf;\n+}\n+\n+/* Print on stderr the current class and method context.  This function\n+   is the value of the hook print_error_function, called from toplev.c. */\n+\n+void\n+lang_print_error (file)\n+     char *file;\n+{\n+  static tree last_error_function_context = NULL_TREE;\n+  static tree last_error_function = NULL;\n+\n+  if (current_function_decl != NULL\n+      && DECL_CONTEXT (current_function_decl) != last_error_function_context)\n+    {\n+      if (file)\n+\tfprintf (stderr, \"%s: \", file);\n+\n+      last_error_function_context = DECL_CONTEXT (current_function_decl);\n+      fprintf (stderr, \"In class `%s':\\n\",\n+\t       lang_printable_name (last_error_function_context));\n+    }\n+  if (last_error_function != current_function_decl)\n+    {\n+      if (file)\n+\tfprintf (stderr, \"%s: \", file);\n+\n+      if (current_function_decl == NULL)\n+\tfprintf (stderr, \"At top level:\\n\");\n+      else\n+\t{\n+\t  char *name = lang_printable_name (current_function_decl, 2);\n+\t  fprintf (stderr, \"In method `%s':\\n\", name);\n+\t}\n+\n+      last_error_function = current_function_decl;\n+    }\n+\n+}\n+\n+void\n+lang_init ()\n+{\n+  extern struct rtx_def * java_lang_expand_expr ();\n+  extern struct rtx_def * (*lang_expand_expr) ();\n+  extern void (*print_error_function) PROTO((char *));\n+#if 0\n+  extern int flag_minimal_debug;\n+  flag_minimal_debug = 0;\n+#endif\n+\n+  decl_printable_name = lang_printable_name;\n+  print_error_function = lang_print_error;\n+  lang_expand_expr = java_lang_expand_expr;\n+\n+  JCF_ZERO (main_jcf);\n+  main_jcf->read_state = finput;\n+  main_jcf->filbuf = jcf_filbuf_from_stdio;\n+  current_jcf = main_jcf;\n+\n+  flag_exceptions = 1;\n+}\n+\n+/* This doesn't do anything on purpose. It's used to satisfy the\n+   print_error_function hook we don't print error messages with bogus\n+   function prototypes.  */\n+\n+void java_dummy_print (s)\n+     char *s;\n+{\n+}\n+\n+/* Called to install the PRINT_ERROR_FUNCTION hook differently\n+   according to LEVEL. LEVEL is 1 during early parsing, when function\n+   prototypes aren't fully resolved. print_error_function is set so it\n+   doesn't print incomplete function prototypes. When LEVEL is 2,\n+   function prototypes are fully resolved and can be printed when\n+   reporting errors.  */\n+\n+void lang_init_source (level)\n+     int level;\n+{\n+  extern void (*print_error_function) PROTO((char *));\n+  if (level == 1)\n+    print_error_function = java_dummy_print;\n+  else \n+    print_error_function = lang_print_error;\n+}\n+\n+void\n+lang_init_options ()\n+{\n+  flag_new_exceptions = 1;\n+}\n+\n+void\n+lang_finish ()\n+{\n+}\n+\n+char*\n+lang_identify ()\n+{\n+  return \"Java\";\n+}\n+\n+/* Hooks for print_node.  */\n+\n+void\n+print_lang_decl (file, node, indent)\n+     FILE *file;\n+     tree node;\n+     int indent;\n+{\n+}\n+\n+void\n+print_lang_type (file, node, indent)\n+     FILE *file;\n+     tree node;\n+     int indent;\n+{\n+}\n+\n+void\n+print_lang_identifier (file, node, indent)\n+     FILE *file;\n+     tree node;\n+     int indent;\n+{\n+}\n+\n+void\n+print_lang_statistics ()\n+{\n+}\n+\n+/* used by print-tree.c */\n+\n+void\n+lang_print_xnode (file, node, indent)\n+     FILE *file;\n+     tree node;\n+     int indent;\n+{\n+}"}, {"sha": "50999654766a8e6135d49bead83a18354c6dd74c", "filename": "gcc/java/lex.c", "status": "added", "additions": 1355, "deletions": 0, "changes": 1355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,1355 @@\n+/* Language lexer for the GNU compiler for the Java(TM) language.\n+   Copyright (C) 1997, 1998 Free Software Foundation, Inc.\n+   Contributed by Alexandre Petit-Bianco (apbianco@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA. \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* It defines java_lex (yylex) that reads a Java ASCII source file\n+possibly containing Unicode escape sequence or utf8 encoded characters\n+and returns a token for everything found but comments, white spaces\n+and line terminators. When necessary, it also fills the java_lval\n+(yylval) union. It's implemented to be called by a re-entrant parser\n+generated by Bison.\n+\n+The lexical analysis conforms to the Java grammar described in \"The\n+Java(TM) Language Specification. J. Gosling, B. Joy, G. Steele.\n+Addison Wesley 1996\" (http://java.sun.com/docs/books/jls/html/3.doc.html)  */\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <setjmp.h>\n+\n+#ifdef JAVA_LEX_DEBUG\n+#include <ctype.h>\n+#endif\n+\n+#ifdef inline\t\t\t/* javaop.h redefines inline as static */\n+#undef inline\n+#endif\n+#include \"keyword.h\"\n+\n+#ifndef SEEK_SET\n+#include <unistd.h>\n+#endif\n+\n+void\n+java_init_lex ()\n+{\n+  int java_lang_imported = 0;\n+\n+#ifndef JC1_LITE\n+  if (!java_lang_imported)\n+    {\n+      tree node = build_tree_list \n+\t(build_expr_wfl (get_identifier (\"java.lang\"), NULL, 0, 0), NULL_TREE);\n+      read_import_dir (TREE_PURPOSE (node));\n+      TREE_CHAIN (node) = ctxp->import_demand_list;\n+      ctxp->import_demand_list = node;\n+      java_lang_imported = 1;\n+    }\n+\n+  if (!wfl_operator)\n+    wfl_operator = build_expr_wfl (NULL_TREE, ctxp->filename, 0, 0);\n+  if (!label_id)\n+    label_id = get_identifier (\"$L\");\n+\n+  ctxp->static_initialized = ctxp->non_static_initialized = \n+    ctxp->incomplete_class = NULL_TREE;\n+  \n+  bzero (ctxp->modifier_ctx, 11*sizeof (ctxp->modifier_ctx[0]));\n+  classpath = NULL;\n+  bzero (current_jcf, sizeof (JCF));\n+  ctxp->current_parsed_class = NULL;\n+  ctxp->package = NULL_TREE;\n+#endif\n+\n+  ctxp->filename = input_filename;\n+  ctxp->lineno = lineno = 0;\n+  ctxp->p_line = NULL;\n+  ctxp->c_line = NULL;\n+  ctxp->unget_utf8_value = 0;\n+  ctxp->minus_seen = 0;\n+  ctxp->java_error_flag = 0;\n+}\n+\n+static char *\n+java_sprint_unicode (line, i)\n+    struct java_line *line;\n+    int i;\n+{\n+  static char buffer [10];\n+  if (line->unicode_escape_p [i] || line->line [i] > 128)\n+    sprintf (buffer, \"\\\\u%04x\", line->line [i]);\n+  else\n+    {\n+      buffer [0] = line->line [i];\n+      buffer [1] = '\\0';\n+    }\n+  return buffer;\n+}\n+\n+static unicode_t\n+java_sneak_unicode ()\n+{\n+  return (ctxp->c_line->line [ctxp->c_line->current]);\n+}\n+\n+static void\n+java_unget_unicode (c)\n+     unicode_t c;\n+{\n+  if (!ctxp->c_line->current)\n+    fatal (\"can't unget unicode - java_unget_unicode\");\n+  ctxp->c_line->current--;\n+  ctxp->c_line->char_col -= JAVA_COLUMN_DELTA (0);\n+}\n+\n+void\n+java_allocate_new_line ()\n+{\n+  int i;\n+  unicode_t ahead = (ctxp->c_line ? ctxp->c_line->ahead[0] : '\\0');\n+  char ahead_escape_p = (ctxp->c_line ? \n+\t\t\t ctxp->c_line->unicode_escape_ahead_p : 0);\n+\n+  if (ctxp->c_line && !ctxp->c_line->white_space_only)\n+    {\n+      if (ctxp->p_line)\n+\t{\n+\t  free (ctxp->p_line->unicode_escape_p);\n+\t  free (ctxp->p_line->line);\n+\t  free (ctxp->p_line);\n+\t}\n+      ctxp->p_line = ctxp->c_line;\n+      ctxp->c_line = NULL;\t\t/* Reallocated */\n+    }\n+\n+  if (!ctxp->c_line)\n+    {\n+      ctxp->c_line = (struct java_line *)malloc (sizeof (struct java_line));\n+      ctxp->c_line->max = JAVA_LINE_MAX;\n+      ctxp->c_line->line = (unicode_t *)malloc \n+\t  (sizeof (unicode_t)*ctxp->c_line->max);\n+      ctxp->c_line->unicode_escape_p = \n+\t  (char *)malloc (sizeof (char)*ctxp->c_line->max);\n+      ctxp->c_line->white_space_only = 0;\n+    }\n+\n+  ctxp->c_line->line [0] = ctxp->c_line->size = 0;\n+  ctxp->c_line->char_col = ctxp->c_line->current = 0;\n+  if (ahead)\n+    {\n+      ctxp->c_line->line [ctxp->c_line->size] = ahead;\n+      ctxp->c_line->unicode_escape_p [ctxp->c_line->size] = ahead_escape_p;\n+      ctxp->c_line->size++;\n+    }\n+  ctxp->c_line->ahead [0] = 0;\n+  ctxp->c_line->unicode_escape_ahead_p = 0;\n+  ctxp->c_line->lineno = ++lineno;\n+  ctxp->c_line->white_space_only = 1;\n+}\n+\n+static unicode_t\n+java_read_char ()\n+{\n+  int c;\n+  int c1, c2;\n+\n+  if (ctxp->unget_utf8_value)\n+    {\n+      int to_return = ctxp->unget_utf8_value;\n+      ctxp->unget_utf8_value = 0;\n+      return (to_return);\n+    }\n+\n+  c = GETC ();\n+\n+  if (c < 128)\n+    return (unicode_t)c;\n+  if (c == EOF)\n+    return UEOF;\n+  else\n+    {\n+      if (c & 0xe0 == 0xc0)\n+        {\n+          c1 = GETC ();\n+\t  if (c1 & 0xc0 == 0x80)\n+\t    return (unicode_t)(((c &0x1f) << 6) + (c1 & 0x3f));\n+\t}\n+      else if (c & 0xf0 == 0xe0)\n+        {\n+          c1 = GETC ();\n+\t  if (c1 & 0xc0 == 0x80)\n+\t    {\n+\t      c2 = GETC ();\n+\t      if (c2 & 0xc0 == 0x80)\n+\t        return (unicode_t)(((c & 0xf) << 12) + \n+\t\t\t\t   (( c1 & 0x3f) << 6) + (c2 & 0x3f));\n+\t    }\n+\t}\n+      java_lex_error (\"Bad utf8 encoding\", 0);\n+    }\n+}\n+\n+static void\n+java_store_unicode (l, c, unicode_escape_p)\n+    struct java_line *l;\n+    unicode_t c;\n+    int unicode_escape_p;\n+{\n+  if (l->size == l->max)\n+    {\n+      l->max += JAVA_LINE_MAX;\n+      l->line = (unicode_t *)realloc (l->line, sizeof (unicode_t)*l->max);\n+      l->unicode_escape_p = (char *)realloc (l->unicode_escape_p, \n+\t\t\t\t\t     sizeof (char)*l->max);\n+    }\n+  l->line [l->size] = c;\n+  l->unicode_escape_p [l->size++] = unicode_escape_p;\n+}\n+\n+static unicode_t\n+java_read_unicode (term_context, unicode_escape_p)\n+    int term_context;\n+    int *unicode_escape_p;\n+{\n+  unicode_t c;\n+  long i, base;\n+\n+  c = java_read_char ();\n+  *unicode_escape_p = 0;\n+\n+  if (c != '\\\\')\n+    return ((term_context ? c : \n+\t     java_lineterminator (c) ? '\\n' : (unicode_t)c));\n+\n+  /* Count the number of preceeding '\\' */\n+  for (base = ftell (finput), i = base-2; c == '\\\\';)\n+    { \n+      fseek (finput, i--, SEEK_SET);\n+      c = java_read_char ();\t/* Will fail if reading utf8 stream. FIXME */\n+    }\n+  fseek (finput, base, SEEK_SET);\n+  if ((base-i-3)%2 == 0)\t/* If odd number of \\ seen */\n+    {\n+      c = java_read_char ();\n+      if (c == 'u')\n+        {\n+\t  unsigned short unicode = 0;\n+\t  int shift = 12;\n+\t  /* Next should be 4 hex digits, otherwise it's an error.\n+\t     The hex value is converted into the unicode, pushed into\n+\t     the Unicode stream.  */\n+\t  for (shift = 12; shift >= 0; shift -= 4)\n+\t    {\n+\t      if ((c = java_read_char ()) == UEOF)\n+\t        return UEOF;\n+\t      if (c >= '0' && c <= '9')\n+\t\tunicode |= (unicode_t)((c-'0') << shift);\n+\t      else if ((c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'))\n+\t        unicode |= (unicode_t)(10+(c | 0x20)-'a' << shift);\n+\t      else\n+\t\t  java_lex_error \n+\t\t    (\"Non hex digit in Unicode escape sequence\", 0);\n+\t    }\n+\t  *unicode_escape_p = 1;\n+\t  return (term_context ? unicode :\n+\t\t  (java_lineterminator (c) ? '\\n' : unicode));\n+\t}\n+      UNGETC (c);\n+    }\n+  return (unicode_t)'\\\\';\n+}\n+\n+static unicode_t\n+java_get_unicode ()\n+{\n+  /* It's time to read a line when... */\n+  if (!ctxp->c_line || ctxp->c_line->current == ctxp->c_line->size)\n+    {\n+      unicode_t c;\n+      java_allocate_new_line ();\n+      if (ctxp->c_line->line[0] != '\\n')\n+\tfor (;;)\n+\t  {\n+\t    int unicode_escape_p;\n+\t    c = java_read_unicode (0, &unicode_escape_p);\n+\t    java_store_unicode (ctxp->c_line, c, unicode_escape_p);\n+\t    if (ctxp->c_line->white_space_only \n+\t\t&& !JAVA_WHITE_SPACE_P (c) && c!='\\n')\n+\t      ctxp->c_line->white_space_only = 0;\n+\t    if ((c == '\\n') || (c == UEOF))\n+\t      break;\n+\t  }\n+    }\n+  ctxp->c_line->char_col += JAVA_COLUMN_DELTA (0);\n+  JAVA_LEX_CHAR (ctxp->c_line->line [ctxp->c_line->current]);\n+  return ctxp->c_line->line [ctxp->c_line->current++];\n+}\n+\n+static int\n+java_lineterminator (c)\n+     unicode_t c;\n+{\n+  int unicode_escape_p;\n+  if (c == '\\n')\t\t/* CR */\n+    {\n+      if ((c = java_read_unicode (1, &unicode_escape_p)) != '\\r')\n+\t{\n+\t  ctxp->c_line->ahead [0] = c;\n+\t  ctxp->c_line->unicode_escape_ahead_p = unicode_escape_p;\n+\t}\n+      return 1;\n+    }\n+  else if (c == '\\r')\t\t/* LF */\n+    {\n+      if ((c = java_read_unicode (1, &unicode_escape_p)) != '\\n')\n+\t{\n+\t  ctxp->c_line->ahead [0] = c;\n+\t  ctxp->c_line->unicode_escape_ahead_p = unicode_escape_p;\n+\t}\n+      return 1;\n+    }\n+  else \n+    return 0;\n+}\n+\n+/* Parse the end of a C style comment */\n+static void\n+java_parse_end_comment ()\n+{\n+  unicode_t c;\n+\n+  for (c = java_get_unicode ();; c = java_get_unicode ())\n+    {\n+      switch (c)\n+\t{\n+\tcase UEOF:\n+\t  java_lex_error (\"Comment not terminated at end of input\", 0);\n+\tcase '*':\n+\t  switch (c = java_get_unicode ())\n+\t    {\n+\t    case UEOF:\n+\t      java_lex_error (\"Comment not terminated at end of input\", 0);\n+\t    case '/':\n+\t      return;\n+\t    case '*':\t/* reparse only '*' */\n+\t      java_unget_unicode (c);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* This function to be used only by JAVA_ID_CHAR_P (), otherwise it\n+   will return a wrong result.  */\n+static int\n+java_letter_or_digit_p (c)\n+     unicode_t c;\n+{\n+  return _JAVA_LETTER_OR_DIGIT_P (c);\n+}\n+\n+static unicode_t\n+java_parse_escape_sequence ()\n+{\n+  unicode_t char_lit;\n+  unicode_t c;\n+\n+  switch (c = java_get_unicode ())\n+    {\n+    case 'b':\n+      return (unicode_t)0x8;\n+    case 't':\n+      return (unicode_t)0x9;\n+    case 'n':\n+      return (unicode_t)0xa;\n+    case 'f':\n+      return (unicode_t)0xc;\n+    case 'r':\n+      return (unicode_t)0xd;\n+    case '\"':\n+      return (unicode_t)0x22;\n+    case '\\'':\n+      return (unicode_t)0x27;\n+    case '\\\\':\n+      return (unicode_t)0x5c;\n+    case '0': case '1': case '2': case '3': case '4':\n+    case '5': case '6': case '7': case '8': case '9':\n+      {\n+\tint octal_escape[3];\n+\tint octal_escape_index = 0;\n+\t\n+\tfor (; octal_escape_index < 3 && RANGE (c, '0', '9');\n+\t     c = java_get_unicode ())\n+\t  octal_escape [octal_escape_index++] = c;\n+\n+\tjava_unget_unicode (c);\n+\n+\tif ((octal_escape_index == 3) && (octal_escape [0] > '3'))\n+\t  {\n+\t    java_lex_error (\"Literal octal escape out of range\", 0);\n+\t    return JAVA_CHAR_ERROR;\n+\t  }\n+\telse\n+\t  {\n+\t    int i, shift;\n+\t    for (char_lit=0, i = 0, shift = 3*(octal_escape_index-1);\n+\t\t i < octal_escape_index; i++, shift -= 3)\n+\t      char_lit |= (octal_escape [i] - '0') << shift;\n+\n+\t    return (char_lit);\n+\t  }\n+\tbreak;\n+      }\n+    case '\\n':\n+      return '\\n';\t\t/* ULT, caught latter as a specific error */\n+    default:\n+      java_lex_error (\"Illegal character in escape sequence\", 0);\n+      return JAVA_CHAR_ERROR;\n+    }\n+}\n+\n+int\n+#ifdef JC1_LITE\n+yylex (java_lval)\n+#else\n+java_lex (java_lval)\n+#endif\n+     YYSTYPE *java_lval;\n+{\n+  unicode_t c, first_unicode;\n+  int line_terminator;\n+  int ascii_index, all_ascii;\n+  char *string;\n+\n+  /* Translation of the Unicode escape in the raw stream of Unicode\n+     characters. Takes care of line terminator.  */\n+ step1:\n+  /* Skip white spaces: SP, TAB and FF or ULT */ \n+  for (c = java_get_unicode ();\n+       c == '\\n' || JAVA_WHITE_SPACE_P (c); c = java_get_unicode ())\n+    if (c == '\\n')\n+      {\n+\tctxp->elc.line = ctxp->c_line->lineno;\n+\tctxp->elc.col  = ctxp->c_line->char_col-2;\n+      }\n+\n+  ctxp->elc.col = (ctxp->elc.col < 0 ? 0 : ctxp->elc.col);\n+\n+  if (c == 0x1a)\t\t/* CTRL-Z */\n+    {\n+      if ((c = java_get_unicode ()) == UEOF)\n+\treturn 0;\t\t/* Ok here */\n+      else\n+\tjava_unget_unicode (c);\t/* Caught latter at the end the function */\n+    }\n+  /* Handle EOF here */\n+  if (c == UEOF)\t/* Should probably do something here... */\n+    return 0;\n+\n+  /* Take care of eventual comments.  */\n+  if (c == '/')\n+    {\n+      switch (c = java_get_unicode ())\n+\t{\n+\tcase '/':\n+\t  for (c = java_get_unicode ();;c = java_get_unicode ())\n+\t    {\n+\t      if (c == UEOF)\n+\t\tjava_lex_error (\"Comment not terminated at end of input\", 0);\n+\t      if (c == '\\n')\t/* ULT */\n+\t\tgoto step1;\n+\t    }\n+\t  break;\n+\n+\tcase '*':\n+\t  if ((c = java_get_unicode ()) == '*')\n+\t    {\n+\t      if ((c = java_get_unicode ()) == '/')\n+\t\tgoto step1;\t/* Empy documentation comment  */\n+\n+\t      else\n+\t\t/* Parsing the documentation section. We're looking\n+\t\t for the @depracated pseudo keyword.  the @deprecated\n+\t\t tag must be at the beginning of a doc comment line\n+\t\t (ignoring white space and any * character)  */\n+\n+\t\t{ \n+\t\t  int valid_tag = 0, seen_star;\n+\n+\t\t  while (JAVA_WHITE_SPACE_P (c) || (c == '*') || c == '\\n')\n+\t\t    {\n+\t\t      switch (c)\n+\t\t\t{\n+\t\t\tcase '*':\n+\t\t\t  seen_star = 1;\n+\t\t\t  break;\n+\t\t\tcase '\\n': /* ULT */\n+\t\t\t  valid_tag = 1;\n+\t\t\t  break;\n+\t\t\tdefault:\n+\t\t\t  seen_star = 0;\n+\t\t\t}\n+\t\t      c = java_get_unicode();\n+\t\t    }\n+\t\t  \n+\t\t  if (c == UEOF)\n+\t\t    java_lex_error \n+\t\t      (\"Comment not terminated at end of input\", 0);\n+\n+\t\t  if (seen_star && (c == '/'))\n+\t\t    goto step1;\t/* End of documentation */\n+\n+\t\t  if (valid_tag && (c == '@'))\n+\t\t    {\n+\t\t      char deprecated [10];\n+\t\t      int  deprecated_index = 0;\n+\n+\t\t      for (deprecated_index = 0, c = java_get_unicode (); \n+\t\t\t   deprecated_index < 10 && c != UEOF;\n+\t\t\t   c = java_get_unicode ())\n+\t\t\tdeprecated [deprecated_index++] = c;\n+\n+\t\t      if (c == UEOF)\n+\t\t\tjava_lex_error \n+\t\t          (\"Comment not terminated at end of input\", 0);\n+\t\t      \n+\t\t      java_unget_unicode (c);\n+\t\t      deprecated [deprecated_index] = '\\0';\n+\t\t      if (!strcmp (deprecated, \"deprecated\"))\n+\t\t\t{\n+\t\t\t  /* Set global flag to be checked by class. FIXME  */\n+\t\t\t  warning (\"deprecated implementation found\");\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    java_unget_unicode (c);\n+\n+\t  java_parse_end_comment ();\n+\t  goto step1;\n+\t  break;\n+\tdefault:\n+\t  java_unget_unicode (c);\n+\t  c = '/';\n+\t  break;\n+\t}\n+    }\n+\n+  ctxp->elc.line = ctxp->c_line->lineno;\n+  ctxp->elc.col = ctxp->c_line->char_col - JAVA_COLUMN_DELTA (-1);\n+  if (ctxp->elc.col < 0)\n+    fatal (\"ctxp->elc.col < 0 - java_lex\");\n+\n+  /* Numeric literals */\n+  if (JAVA_ASCII_DIGIT (c) || (c == '.'))\n+    {\n+      unicode_t peep;\n+      /* This section of code is borrowed from gcc/c-lex.c  */\n+#define TOTAL_PARTS ((HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR) * 2 + 2)\n+      int parts[TOTAL_PARTS];\n+      HOST_WIDE_INT high, low;\n+      /* End borrowed section  */\n+      char literal_token [256];\n+      int  literal_index = 0, radix = 10, long_suffix = 0, overflow = 0, bytes;\n+      int  i;\n+      int  number_beginning = ctxp->c_line->current;\n+      \n+      /* We might have a . separator instead of a FP like .[0-9]* */\n+      if (c == '.')\n+\t{\n+\t  unicode_t peep = java_sneak_unicode ();\n+\n+\t  if (!JAVA_ASCII_DIGIT (peep))\n+\t    {\n+\t      JAVA_LEX_SEP('.');\n+\t      BUILD_OPERATOR (DOT_TK);\n+\t    }\n+\t}\n+\n+      for (i = 0; i < TOTAL_PARTS; i++)\n+\tparts [i] = 0;\n+\n+      if (c == '0')\n+\t{\n+\t  c = java_get_unicode ();\n+\t  if (c == 'x' || c == 'X')\n+\t    {\n+\t      radix = 16;\n+\t      c = java_get_unicode ();\n+\t    }\n+\t  else if (JAVA_ASCII_DIGIT (c))\n+\t    radix = 8;\n+\t  else if (c == '.')\n+\t    {\n+\t      /* Push the '.' back and prepare for a FP parsing... */\n+\t      java_unget_unicode (c);\n+\t      c = '0';\n+\t    }\n+\t  else\n+\t    {\n+\t      /* We have a zero literal: 0, 0{f,F}, 0{d,D} */\n+\t      JAVA_LEX_LIT (\"0\", 10);\n+              switch (c)\n+\t\t{\t\t\n+\t\tcase 'L': case 'l':\n+\t\t  SET_LVAL_NODE_TYPE (integer_zero_node, long_type_node);\n+\t\t  return (INT_LIT_TK);\n+\t\tcase 'f': case 'F':\n+\t\t  SET_LVAL_NODE_TYPE (build_real (float_type_node, dconst0),\n+\t\t\t\t\tfloat_type_node);\n+\t\t  return (FP_LIT_TK);\n+\t\tcase 'd': case 'D':\n+\t\t  SET_LVAL_NODE_TYPE (build_real (double_type_node, dconst0),\n+\t\t\t\t\tdouble_type_node);\n+\t\t  return (FP_LIT_TK);\n+\t\tdefault:\n+\t\t  java_unget_unicode (c);\n+\t\t  SET_LVAL_NODE_TYPE (integer_zero_node, int_type_node);\n+\t\t  return (INT_LIT_TK);\n+\t\t}\n+\t    }\n+\t}\n+      /* Parse the first part of the literal, until we find something\n+\t which is not a number.  */\n+      while ((radix == 10 && JAVA_ASCII_DIGIT (c)) ||\n+\t     (radix == 16 && JAVA_ASCII_HEXDIGIT (c)) ||\n+\t     (radix == 8  && JAVA_ASCII_OCTDIGIT (c)))\n+\t{\n+\t  /* We store in a string (in case it turns out to be a FP) and in\n+\t     PARTS if we have to process a integer literal.  */\n+\t  int numeric = (RANGE (c, '0', '9') ? c-'0' : 10 +(c|0x20)-'a');\n+\t  int count;\n+\n+\t  literal_token [literal_index++] = c;\n+\t  /* This section of code if borrowed from gcc/c-lex.c  */\n+\t  for (count = 0; count < TOTAL_PARTS; count++)\n+\t    {\n+\t      parts[count] *= radix;\n+\t      if (count)\n+\t\t{\n+\t\t  parts[count]   += (parts[count-1] >> HOST_BITS_PER_CHAR);\n+\t\t  parts[count-1] &= (1 << HOST_BITS_PER_CHAR) - 1;\n+\t\t}\n+\t      else\n+\t\tparts[0] += numeric;\n+\t    }\n+\t  if (parts [TOTAL_PARTS-1] != 0)\n+\t    overflow = 1;\n+\t  /* End borrowed section.  */\n+\t  c = java_get_unicode ();\n+\t}\n+\n+      /* If we have something from the FP char set but not a digit, parse\n+\t a FP literal.  */\n+      if (JAVA_ASCII_FPCHAR (c) && !JAVA_ASCII_DIGIT (c))\n+\t{\n+\t  int stage = 0;\n+\t  int seen_digit = (literal_index ? 1 : 0);\n+\t  int seen_exponent = 0;\n+\t  int fflag = 0;\t/* 1 for {f,F}, 0 for {d,D}. FP literal are\n+\t\t\t\t   double unless specified. */\n+\t  if (radix != 10)\n+\t    java_lex_error (\"Can't express non-decimal FP literal\", 0);\n+\n+\t  for (;;)\n+\t    {\n+\t      if (c == '.')\n+\t\t{\n+\t\t  if (stage < 1)\n+\t\t    {\n+\t\t      stage = 1;\n+\t\t      literal_token [literal_index++ ] = c;\n+\t\t      c = java_get_unicode ();\n+\t\t    }\n+\t\t  else\n+\t\t    java_lex_error (\"Invalid character in FP literal\", 0);\n+\t\t}\n+\n+\t      if (c == 'e' || c == 'E')\n+\t\t{\n+\t\t  if (stage < 2)\n+\t\t    {\n+\t\t      /* {E,e} must have seen at list a digit */\n+\t\t      if (!seen_digit)\n+\t\t\tjava_lex_error (\"Invalid FP literal\", 0);\n+\t\t      seen_digit = 0;\n+\t\t      seen_exponent = 1;\n+\t\t      stage = 2;\n+\t\t      literal_token [literal_index++] = c;\n+\t\t      c = java_get_unicode ();\n+\t\t    }\n+\t\t  else\n+\t\t    java_lex_error (\"Invalid character in FP literal\", 0);\n+\t\t}\n+\t      if ( c == 'f' || c == 'F' || c == 'd' || c == 'D')\n+\t\t{\n+\t\t  fflag = ((c == 'd') || (c == 'D')) ? 0 : 1;\n+\t\t  stage = 4;\t/* So we fall through */\n+\t\t}\n+\n+\t      if ((c=='-' || c =='+') && stage < 3)\n+\t\t{\n+\t\t  stage = 3;\n+\t\t  literal_token [literal_index++] = c;\n+\t\t  c = java_get_unicode ();\n+\t\t}\n+\n+\t      if ((stage == 0 && JAVA_ASCII_FPCHAR (c)) ||\n+\t\t  (stage == 1 && JAVA_ASCII_FPCHAR (c) && !(c == '.')) ||\n+\t\t  (stage == 2 && (JAVA_ASCII_DIGIT (c) || JAVA_FP_PM (c))) ||\n+\t\t  (stage == 3 && JAVA_ASCII_DIGIT (c)))\n+\t\t{\n+\t\t  if (JAVA_ASCII_DIGIT (c))\n+\t\t    seen_digit = 1;\n+\t\t  literal_token [literal_index++ ] = c;\n+\t\t  c = java_get_unicode ();\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  jmp_buf handler;\n+\t\t  REAL_VALUE_TYPE value;\n+#ifndef JC1_LITE\n+\t\t  tree type = (fflag ? FLOAT_TYPE_NODE : DOUBLE_TYPE_NODE);\n+#endif\n+\n+\t\t  if (stage != 4) /* Don't push back fF/dD */\n+\t\t    java_unget_unicode (c);\n+\t\t  \n+\t\t  /* An exponent (if any) must have seen a digit.  */\n+\t\t  if (seen_exponent && !seen_digit)\n+\t\t    java_lex_error (\"Invalid FP literal\", 0);\n+\n+\t\t  literal_token [literal_index] = '\\0';\n+\t\t  JAVA_LEX_LIT (literal_token, radix);\n+\n+\t\t  if (setjmp (handler))\n+\t\t    {\n+\t\t      JAVA_FLOAT_RANGE_ERROR ((fflag ? \"float\" : \"double\"));\n+\t\t      value = DCONST0;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      SET_FLOAT_HANDLER (handler);\n+\t\t      SET_REAL_VALUE_ATOF \n+\t\t        (value, REAL_VALUE_ATOF (literal_token, \n+\t\t\t\t\t\t TYPE_MODE (type)));\n+\n+\t\t      if (REAL_VALUE_ISINF (value))\n+\t\t\tJAVA_FLOAT_RANGE_ERROR ((fflag ? \"float\" : \"double\"));\n+\n+\t\t      if (REAL_VALUE_ISNAN (value))\n+\t\t\tJAVA_FLOAT_RANGE_ERROR ((fflag ? \"float\" : \"double\"));\n+\n+\t\t      SET_LVAL_NODE_TYPE (build_real (type, value), type);\n+\t\t      SET_FLOAT_HANDLER (NULL_PTR);\n+\t\t      return FP_LIT_TK;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t} /* JAVA_ASCCI_FPCHAR (c) */\n+\n+      /* Here we get back to converting the integral literal.  */\n+      if (c == 'L' || c == 'l')\n+\tlong_suffix = 1;\n+      else if (radix == 16 && JAVA_ASCII_LETTER (c))\n+\tjava_lex_error (\"Digit out of range in hexadecimal literal\", 0);\n+      else if (radix == 8  && JAVA_ASCII_DIGIT (c))\n+\tjava_lex_error (\"Digit out of range in octal literal\", 0);\n+      else if (radix == 16 && !literal_index)\n+\tjava_lex_error (\"No digit specified for hexadecimal literal\", 0);\n+      else\n+\tjava_unget_unicode (c);\n+\n+#ifdef JAVA_LEX_DEBUG\n+      literal_token [literal_index] = '\\0'; /* So JAVA_LEX_LIT is safe. */\n+      JAVA_LEX_LIT (literal_token, radix);\n+#endif\n+      /* This section of code is borrowed from gcc/c-lex.c  */\n+      if (!overflow)\n+\t{\n+\t  bytes = GET_TYPE_PRECISION (long_type_node);\n+\t  for (i = bytes; i < TOTAL_PARTS; i++)\n+\t    if (parts [i])\n+\t      {\n+\t        overflow = 1;\n+\t\tbreak;\n+\t      }\n+\t}\n+      high = low = 0;\n+      for (i = 0; i < HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR; i++)\n+\t{\n+\t  high |= ((HOST_WIDE_INT) parts[i + (HOST_BITS_PER_WIDE_INT\n+\t\t\t\t\t      / HOST_BITS_PER_CHAR)]\n+\t\t   << (i * HOST_BITS_PER_CHAR));\n+\t  low |= (HOST_WIDE_INT) parts[i] << (i * HOST_BITS_PER_CHAR);\n+\t}\n+      /* End borrowed section.  */\n+\n+      /* Range checking */\n+      if (long_suffix)\n+\t{\n+\t  /* 9223372036854775808L is valid if operand of a '-'. Otherwise\n+\t     9223372036854775807L is the biggest `long' literal that can be\n+\t     expressed using a 10 radix. For other radixes, everything that\n+\t     fits withing 64 bits is OK. */\n+\t  int hb = (high >> 31);\n+\t  if (overflow || (hb && low && radix == 10) ||  \n+\t      (hb && high & 0x7fffffff && radix == 10) ||\n+\t      (hb && !(high & 0x7fffffff) && !ctxp->minus_seen && radix == 10))\n+\t    JAVA_INTEGRAL_RANGE_ERROR (\"Numeric overflow for `long' literal\");\n+\t}\n+      else\n+\t{\n+\t  /* 2147483648 is valid if operand of a '-'. Otherwise,\n+\t     2147483647 is the biggest `int' literal that can be\n+\t     expressed using a 10 radix. For other radixes, everything\n+\t     that fits within 32 bits is OK. */\n+\t  int hb = (low >> 31) & 0x1;\n+\t  if (overflow || high || (hb && low & 0x7fffffff && radix == 10) ||\n+\t      (hb && !(low & 0x7fffffff) && !ctxp->minus_seen && radix == 10))\n+\t    JAVA_INTEGRAL_RANGE_ERROR (\"Numeric overflow for `int' literal\");\n+\t}\n+      ctxp->minus_seen = 0;\n+      SET_LVAL_NODE_TYPE (build_int_2 (low, high),\n+\t\t\t  (long_suffix ? long_type_node : int_type_node));\n+      return INT_LIT_TK;\n+    }\n+\n+  ctxp->minus_seen = 0;\n+  /* Character literals */\n+  if (c == '\\'')\n+    {\n+      unicode_t char_lit;\n+      if ((c = java_get_unicode ()) == '\\\\')\n+\tchar_lit = java_parse_escape_sequence ();\n+      else\n+\tchar_lit = c;\n+\n+      c = java_get_unicode ();\n+      \n+      if ((c == '\\n') || (c == UEOF))\n+\tjava_lex_error (\"Character literal not terminated at end of line\", 0);\n+      if (c != '\\'')\n+\tjava_lex_error (\"Syntax error in character literal\", 0);\n+\n+      if (c == JAVA_CHAR_ERROR)\n+        char_lit = 0;\t\t/* We silently convert it to zero */\n+\n+      JAVA_LEX_CHAR_LIT (char_lit);\n+      SET_LVAL_NODE_TYPE (build_int_2 (char_lit, 0), char_type_node);\n+      return CHAR_LIT_TK;\n+    }\n+\n+  /* String literals */\n+  if (c == '\"')\n+    {\n+      int no_error;\n+      char *string;\n+\n+      for (no_error = 1, c = java_get_unicode (); \n+\t   c != '\"' && c != '\\n'; c = java_get_unicode ())\n+\t{\n+\t  if (c == '\\\\')\n+\t    c = java_parse_escape_sequence ();\n+\t  no_error &= (c != JAVA_CHAR_ERROR ? 1 : 0);\n+\t  if (c)\n+\t    java_unicode_2_utf8 (c);\n+\t}\n+      if (c == '\\n' || c == UEOF) /* ULT */\n+\t{\n+\t  lineno--;\t\t/* Refer to the line the terminator was seen */\n+\t  java_lex_error (\"String not terminated at end of line.\", 0);\n+\t  lineno++;\n+\t}\n+\n+      obstack_1grow (&temporary_obstack, '\\0');\n+      string = obstack_finish (&temporary_obstack);\n+      if (!no_error || (c != '\"'))\n+\t*string = '\\0';\t\t/* Silently turns the string to an empty one */\n+      \n+      JAVA_LEX_STR_LIT (string)\n+      \n+#ifndef JC1_LITE\n+      if (*string)\n+\t{\n+\t  extern struct obstack *expression_obstack;\n+\t  tree s = make_node (STRING_CST);\n+\t  TREE_STRING_LENGTH (s) = strlen (string);\n+\t  TREE_STRING_POINTER (s) = \n+\t    obstack_alloc (expression_obstack, strlen (string));\n+\t  strcpy (TREE_STRING_POINTER (s), string);\n+\t  java_lval->node = s;\n+\t}\n+      else\n+\tjava_lval->node = error_mark_node;\n+#endif\n+      return STRING_LIT_TK;\n+      \n+    }\n+\n+  /* Separator */\n+  switch (c)\n+    {\n+    case '(':\n+      JAVA_LEX_SEP (c);\n+      BUILD_OPERATOR (OP_TK);\n+    case ')':\n+      JAVA_LEX_SEP (c);\n+      return CP_TK;\n+    case '{':\n+      JAVA_LEX_SEP (c);\n+      if (ctxp->ccb_indent == 1)\n+\tctxp->first_ccb_indent1 = lineno;\n+      ctxp->ccb_indent++;\n+      return OCB_TK;\n+    case '}':\n+      JAVA_LEX_SEP (c);\n+      ctxp->ccb_indent--;\n+      if (ctxp->ccb_indent == 1)\n+        ctxp->last_ccb_indent1 = lineno;\n+      return CCB_TK;\n+    case '[':\n+      JAVA_LEX_SEP (c);\n+      BUILD_OPERATOR (OSB_TK);\n+    case ']':\n+      JAVA_LEX_SEP (c);\n+      return CSB_TK;\n+    case ';':\n+      JAVA_LEX_SEP (c);\n+      return SC_TK;\n+    case ',':\n+      JAVA_LEX_SEP (c);\n+      return C_TK;\n+    case '.':\n+      JAVA_LEX_SEP (c);\n+      BUILD_OPERATOR (DOT_TK);\n+      /*      return DOT_TK; */\n+    }\n+\n+  /* Operators */\n+  switch (c)\n+    {\n+    case '=':\n+      if ((c = java_get_unicode ()) == '=')\n+\t{\n+\t  BUILD_OPERATOR (EQ_TK);\n+\t}\n+      else\n+\t{\n+\t  /* Equals is used in two different locations. In the \n+\t     variable_declarator: rule, it has to be seen as '=' as opposed\n+\t     to being seen as an ordinary assignment operator in\n+\t     assignment_operators: rule.  */\n+\t  java_unget_unicode (c);\n+\t  BUILD_OPERATOR (ASSIGN_TK);\n+\t}\n+      \n+    case '>':\n+      switch ((c = java_get_unicode ()))\n+\t{\n+\tcase '=':\n+\t  BUILD_OPERATOR (GTE_TK);\n+\tcase '>':\n+\t  switch ((c = java_get_unicode ()))\n+\t    {\n+\t    case '>':\n+\t      if ((c = java_get_unicode ()) == '=')\n+\t\t{\n+\t\t  BUILD_OPERATOR2 (ZRS_ASSIGN_TK);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  java_unget_unicode (c);\n+\t\t  BUILD_OPERATOR (ZRS_TK);\n+\t\t}\n+\t    case '=':\n+\t      BUILD_OPERATOR2 (SRS_ASSIGN_TK);\n+\t    default:\n+\t      java_unget_unicode (c);\n+\t      BUILD_OPERATOR (SRS_TK);\n+\t    }\n+\tdefault:\n+\t  java_unget_unicode (c);\n+\t  BUILD_OPERATOR (GT_TK);\n+\t}\n+\t\n+    case '<':\n+      switch ((c = java_get_unicode ()))\n+\t{\n+\tcase '=':\n+\t  BUILD_OPERATOR (LTE_TK);\n+\tcase '<':\n+\t  if ((c = java_get_unicode ()) == '=')\n+\t    {\n+\t      BUILD_OPERATOR2 (LS_ASSIGN_TK);\n+\t    }\n+\t  else\n+\t    {\n+\t      java_unget_unicode (c);\n+\t      BUILD_OPERATOR (LS_TK);\n+\t    }\n+\tdefault:\n+\t  java_unget_unicode (c);\n+\t  BUILD_OPERATOR (LT_TK);\n+\t}\n+\n+    case '&':\n+      switch ((c = java_get_unicode ()))\n+\t{\n+\tcase '&':\n+\t  BUILD_OPERATOR (BOOL_AND_TK);\n+\tcase '=':\n+\t  BUILD_OPERATOR2 (AND_ASSIGN_TK);\n+\tdefault:\n+\t  java_unget_unicode (c);\n+\t  BUILD_OPERATOR (AND_TK);\n+\t}\n+\n+    case '|':\n+      switch ((c = java_get_unicode ()))\n+\t{\n+\tcase '|':\n+\t  BUILD_OPERATOR (BOOL_OR_TK);\n+\tcase '=':\n+\t  BUILD_OPERATOR2 (OR_ASSIGN_TK);\n+\tdefault:\n+\t  java_unget_unicode (c);\n+\t  BUILD_OPERATOR (OR_TK);\n+\t}\n+\n+    case '+':\n+      switch ((c = java_get_unicode ()))\n+\t{\n+\tcase '+':\n+\t  BUILD_OPERATOR (INCR_TK);\n+\tcase '=':\n+\t  BUILD_OPERATOR2 (PLUS_ASSIGN_TK);\n+\tdefault:\n+\t  java_unget_unicode (c);\n+\t  BUILD_OPERATOR (PLUS_TK);\n+\t}\n+\n+    case '-':\n+      switch ((c = java_get_unicode ()))\n+\t{\n+\tcase '-':\n+\t  BUILD_OPERATOR (DECR_TK);\n+\tcase '=':\n+\t  BUILD_OPERATOR2 (MINUS_ASSIGN_TK);\n+\tdefault:\n+\t  java_unget_unicode (c);\n+\t  ctxp->minus_seen = 1;\n+\t  BUILD_OPERATOR (MINUS_TK);\n+\t}\n+\n+    case '*':\n+      if ((c = java_get_unicode ()) == '=')\n+\t{\n+\t  BUILD_OPERATOR2 (MULT_ASSIGN_TK);\n+\t}\n+      else\n+\t{\n+\t  java_unget_unicode (c);\n+\t  BUILD_OPERATOR (MULT_TK);\n+\t}\n+\n+    case '/':\n+      if ((c = java_get_unicode ()) == '=')\n+\t{\n+\t  BUILD_OPERATOR2 (DIV_ASSIGN_TK);\n+\t}\n+      else\n+\t{\n+\t  java_unget_unicode (c);\n+\t  BUILD_OPERATOR (DIV_TK);\n+\t}\n+\n+    case '^':\n+      if ((c = java_get_unicode ()) == '=')\n+\t{\n+\t  BUILD_OPERATOR2 (XOR_ASSIGN_TK);\n+\t}\n+      else\n+\t{\n+\t  java_unget_unicode (c);\n+\t  BUILD_OPERATOR (XOR_TK);\n+\t}\n+\n+    case '%':\n+      if ((c = java_get_unicode ()) == '=')\n+\t{\n+\t  BUILD_OPERATOR2 (REM_ASSIGN_TK);\n+\t}\n+      else\n+\t{\n+\t  java_unget_unicode (c);\n+\t  BUILD_OPERATOR (REM_TK);\n+\t}\n+\n+    case '!':\n+      if ((c = java_get_unicode()) == '=')\n+\t{\n+\t  BUILD_OPERATOR (NEQ_TK);\n+\t}\n+      else\n+\t{\n+\t  java_unget_unicode (c);\n+\t  BUILD_OPERATOR (NEG_TK);\n+\t}\n+\t  \n+    case '?':\n+      JAVA_LEX_OP (\"?\");\n+      BUILD_OPERATOR (REL_QM_TK);\n+    case ':':\n+      JAVA_LEX_OP (\":\");\n+      BUILD_OPERATOR (REL_CL_TK);\n+    case '~':\n+      BUILD_OPERATOR (NOT_TK);\n+    }\n+  \n+  /* Keyword, boolean literal or null literal */\n+  for (first_unicode = c, all_ascii = 1, ascii_index = 0; \n+       JAVA_ID_CHAR_P (c); c = java_get_unicode ())\n+    {\n+      java_unicode_2_utf8 (c);\n+      if (all_ascii && c >= 128)\n+        all_ascii = 0;\n+      ascii_index++;\n+    }\n+\n+  obstack_1grow (&temporary_obstack, '\\0');\n+  string = obstack_finish (&temporary_obstack);\n+  java_unget_unicode (c);\n+\n+  /* If we have something all ascii, we consider a keyword, a boolean\n+     literal, a null literal or an all ASCII identifier.  Otherwise,\n+     this is an identifier (possibly not respecting formation rule).  */\n+  if (all_ascii)\n+    {\n+      struct java_keyword *kw;\n+      if ((kw=java_keyword (string, ascii_index)))\n+\t{\n+\t  JAVA_LEX_KW (string);\n+\t  switch (kw->token)\n+\t    {\n+\t    case PUBLIC_TK:       case PROTECTED_TK: case STATIC_TK:\n+\t    case ABSTRACT_TK:     case FINAL_TK:     case NATIVE_TK:\n+\t    case SYNCHRONIZED_TK: case TRANSIENT_TK: case VOLATILE_TK:\n+\t    case PRIVATE_TK:\n+\t      SET_MODIFIER_CTX (kw->token);\n+\t      return MODIFIER_TK;\n+\t    case FLOAT_TK:\n+\t      SET_LVAL_NODE (float_type_node);\n+\t      return FP_TK;\n+\t    case DOUBLE_TK:\n+\t      SET_LVAL_NODE (double_type_node);\n+\t      return FP_TK;\n+\t    case BOOLEAN_TK:\n+\t      SET_LVAL_NODE (boolean_type_node);\n+\t      return BOOLEAN_TK;\n+\t    case BYTE_TK:\n+\t      SET_LVAL_NODE (byte_type_node);\n+\t      return INTEGRAL_TK;\n+\t    case SHORT_TK:\n+\t      SET_LVAL_NODE (short_type_node);\n+\t      return INTEGRAL_TK;\n+\t    case INT_TK:\n+\t      SET_LVAL_NODE (int_type_node);\n+\t      return INTEGRAL_TK;\n+\t    case LONG_TK:\n+\t      SET_LVAL_NODE (long_type_node);\n+\t      return INTEGRAL_TK;\n+\t    case CHAR_TK:\n+\t      SET_LVAL_NODE (char_type_node);\n+\t      return INTEGRAL_TK;\n+\n+\t      /* Keyword based literals */\n+\t    case TRUE_TK:\n+\t    case FALSE_TK:\n+\t      SET_LVAL_NODE ((kw->token == TRUE_TK ? \n+\t\t\t      boolean_true_node : boolean_false_node));\n+\t      return BOOL_LIT_TK;\n+\t    case NULL_TK:\n+\t      SET_LVAL_NODE (null_pointer_node);\n+\t      return NULL_TK;\n+\n+\t      /* We build an operator for SUPER, so we can keep its position */\n+\t    case SUPER_TK:\n+\t    case THIS_TK:\n+\t    case RETURN_TK:\n+\t    case BREAK_TK:\n+\t    case CONTINUE_TK:\n+\t      BUILD_OPERATOR (kw->token);\n+\n+\t    default:\n+\t      return kw->token;\n+\t    }\n+\t}\n+    }\n+  \n+  /* We may have and ID here */\n+  if (JAVA_ID_CHAR_P(first_unicode) && !JAVA_DIGIT_P (first_unicode))\n+    {\n+      JAVA_LEX_ID (string);\n+      java_lval->node = BUILD_ID_WFL (GET_IDENTIFIER (string));\n+      return ID_TK;\n+    }\n+\n+  /* Everything else is an invalid character in the input */\n+  {\n+    char lex_error_buffer [128];\n+    sprintf (lex_error_buffer, \"Invalid character '%s' in input\", \n+\t     java_sprint_unicode (ctxp->c_line, ctxp->c_line->current));\n+    java_lex_error (lex_error_buffer, 1);\n+  }\n+  return 0;\n+}\n+\n+static void\n+java_unicode_2_utf8 (unicode)\n+    unicode_t unicode;\n+{\n+  if (RANGE (unicode, 0x01, 0x7f))\n+    obstack_1grow (&temporary_obstack, (char)unicode);\n+  else if (RANGE (unicode, 0x80, 0x7ff) || unicode == 0)\n+    {\n+      obstack_1grow (&temporary_obstack,\n+\t\t     (unsigned char)(0xc0 | ((0x7c0 & unicode) >> 6)));\n+      obstack_1grow (&temporary_obstack,\n+\t\t     (unsigned char)(0x80 | (unicode & 0x3f)));\n+    }\n+  else\t\t\t\t/* Range 0x800-0xffff */\n+    {\n+      obstack_1grow (&temporary_obstack,\n+\t\t     (unsigned char)(0xe0 | (unicode & 0xf000) >> 12));\n+      obstack_1grow (&temporary_obstack,\n+\t\t     (unsigned char)(0x80 | (unicode & 0x0fc0) >> 6));\n+      obstack_1grow (&temporary_obstack,\n+\t\t     (unsigned char)(0x80 | (unicode & 0x003f) >> 12));\n+    }\n+}\n+\n+#ifndef JC1_LITE\n+static tree\n+build_wfl_node (node)\n+     tree node;\n+{\n+  return build_expr_wfl (node, ctxp->filename, ctxp->elc.line, ctxp->elc.col);\n+}\n+#endif\n+\n+static void\n+java_lex_error (msg, forward)\n+     char *msg;\n+     int forward;\n+{\n+#ifndef JC1_LITE\n+  ctxp->elc.line = ctxp->c_line->lineno;\n+  ctxp->elc.col = ctxp->c_line->char_col-1+forward;\n+\n+  /* Might be caught in the middle of some error report */\n+  ctxp->java_error_flag = 0;\n+  java_error (NULL);\n+  java_error (msg);\n+#endif\n+}\n+\n+static int\n+java_is_eol (fp, c)\n+  FILE *fp;\n+  int c;\n+{\n+  int next;\n+  switch (c)\n+    {\n+    case '\\n':\n+      next = getc (fp);\n+      if (next != '\\r' && next != EOF)\n+\tungetc (next, fp);\n+      return 1;\n+    case '\\r':\n+      return 1;\n+    default:\n+      return 0;\n+    }  \n+}\n+\n+char *\n+java_get_line_col (filename, line, col)\n+     char *filename;\n+     int line, col;\n+{\n+#ifdef JC1_LITE\n+  return 0;\n+#else\n+  /* Dumb implementation. Doesn't try to cache or optimize things. */\n+  /* First line of the file is line 1, first column is 1 */\n+\n+  /* COL <= 0 means, at the CR/LF in LINE */\n+\n+  FILE *fp;\n+  int c, ccol, cline = 1;\n+  int current_line_col = 0;\n+\n+  if (!(fp = fopen (filename, \"r\")))\n+    fatal (\"Can't open file - java_display_line_col\");\n+\n+  while (cline != line)\n+    {\n+      c = getc (fp);\n+      if (c < 0)\n+\t{\n+\t  static char msg[] = \"<<file too short - unexpected EOF>>\";\n+\t  obstack_grow (&temporary_obstack, msg, sizeof(msg)-1);\n+\t  goto have_line;\n+\t}\n+      if (java_is_eol (fp, c))\n+\tcline++;\n+    }\n+\n+  /* Gather the chars of the current line in a buffer */\n+  for (;;)\n+    {\n+      c = getc (fp);\n+      if (c < 0 || java_is_eol (fp, c))\n+\tbreak;\n+      obstack_1grow (&temporary_obstack, c);\n+      current_line_col++;\n+    }\n+ have_line:\n+\n+  obstack_1grow (&temporary_obstack, '\\n');\n+\n+  if (col < 0)\n+    col = current_line_col;\n+\n+  /* Place the '^' a the right position */\n+  for (ccol = 1; ccol <= col; ccol++)\n+    obstack_1grow (&temporary_obstack, ' ');\n+  obstack_grow0 (&temporary_obstack, \"^\", 1);\n+\n+  fclose (fp);\n+  return obstack_finish (&temporary_obstack);\n+#endif\n+}"}, {"sha": "9116e42fbe073a719ea5f80bf35d24fa48a52ebc", "filename": "gcc/java/lex.h", "status": "added", "additions": 512, "deletions": 0, "changes": 512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.h?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,512 @@\n+/* Language lexer definitions for the GNU compiler for the Java(TM) language.\n+   Copyright (C) 1997, 1998 Free Software Foundation, Inc.\n+   Contributed by Alexandre Petit-Bianco (apbianco@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+#ifndef JV_LEX_H\n+#define JV_LEX_H\n+\n+/* Extern global variables declarations  */\n+extern FILE *finput;\n+extern int   lineno;\n+extern char *classpath;\n+\n+/* A Unicode character, as read from the input file  */\n+typedef unsigned short unicode_t;\n+\n+/* Function declaration  */\n+static int java_lineterminator ();\n+static char *java_sprint_unicode ();\n+static void java_unicode_2_utf8 ();\n+static void java_lex_error ();\n+static void java_store_unicode ();\n+\n+/* Debug macro to print-out what we match  */\n+#ifdef JAVA_LEX_DEBUG\n+#ifdef JAVA_LEX_DEBUG_CHAR\n+#define JAVA_LEX_CHAR(c)      printf (\"java_lex:%d: char '%c'.%d\\n\", \t\\\n+\t\t\t\t      lineno, (c < 128 ? c : '.'), c);\n+#else\n+#define JAVA_LEX_CHAR(c)\n+#endif\n+#define JAVA_LEX_KW(c)        printf (\"java_lex:%d: keyword: '%s'\\n\", lineno,c)\n+#define JAVA_LEX_ID(s)        printf (\"java_lex:%d: ID: '%s'\\n\",\t\\\n+\t\t\t\t      lineno,\t\t\t\t\\\n+\t\t\t\t      (all_ascii ? s : \"<U>\"))\n+#define JAVA_LEX_LIT(s, r)    printf (\"java_lex:%d: literal '%s'_%d\\n\",\t\\\n+\t\t\t\t      lineno, s, r)\n+#define JAVA_LEX_CHAR_LIT(s)  printf (\"java_lex:%d: literal '%d'\\n\", lineno, s)\n+#define JAVA_LEX_STR_LIT(s)   {\t\t\t\t\t\t \\\n+\t\t\t\t int i;\t\t\t\t\t \\\n+\t\t\t\t printf (\"java_lex:%d: literal '%s'\\n\",  \\\n+\t\t\t\t\t lineno, s);\t\t\t \\\n+\t\t\t       }\n+#define JAVA_LEX_SEP(c)       printf (\"java_lex:%d: separator '%c'\\n\",lineno,c)\n+#define JAVA_LEX_OP(c)        printf (\"java_lex:%d: operator '%s'\\n\", lineno,c)\n+#else\n+#define JAVA_LEX_CHAR(c)\n+#define JAVA_LEX_KW(c)\n+#define JAVA_LEX_ID(s)\n+#define JAVA_LEX_LIT(s,r)\n+#define JAVA_LEX_CHAR_LIT(s)\n+#define JAVA_LEX_STR_LIT(s)\n+#define JAVA_LEX_SEP(c)\n+#define JAVA_LEX_OP(s)\n+#endif\n+\n+/* Line information containers  */\n+struct java_line {\n+  unicode_t *line;\t\t/* The line's unicode */\n+  char      *unicode_escape_p;\t/* The maching char was a unicode escape */\n+  unicode_t ahead[1];\t\t/* Character ahead */\n+  char unicode_escape_ahead_p;\t/* Character ahead is a unicode escape */\n+  int max;\t\t\t/* buffer's max size */\n+  int size;\t\t\t/* number of unicodes */\n+  int current;\t\t\t/* Current position, unicode based */\n+  int char_col;\t\t\t/* Current position, input char based */\n+  int lineno;\t\t\t/* Its line number */\n+  int white_space_only;\t\t/* If it contains only white spaces */\n+};\n+#define JAVA_COLUMN_DELTA(p)\t\t\t\t\t\t\\\n+  (ctxp->c_line->unicode_escape_p [ctxp->c_line->current+(p)] ? 6 : \t\\\n+   (ctxp->c_line->line [ctxp->c_line->current+(p)] == '\\t' ? 8 : 1))\n+\n+struct java_error {\n+  struct java_line *line;\n+  int error;\n+};\n+\n+typedef struct _java_lc {\n+  int line;\n+  int col;\n+} java_lc;\n+\n+\n+#define JAVA_LINE_MAX 80\n+\n+/* Macro to read and unread chars */\n+#define UNGETC(c) ctxp->unget_utf8_value = (c);\n+#define GETC()    getc(finput)\n+\n+/* Build a location compound integer */\n+#define BUILD_LOCATION() ((ctxp->elc.line << 12) | (ctxp->elc.col & 0xfff))\n+\n+/* Those macros are defined differently if we compile jc1-lite\n+   (JC1_LITE defined) or jc1.  */\n+#ifdef JC1_LITE\n+\n+#define DCONST0 0\n+#define HOST_WIDE_INT long\n+#define HOST_BITS_PER_WIDE_INT 64\n+#define HOST_BITS_PER_CHAR 8\n+#define REAL_VALUE_TYPE int\n+#define SET_FLOAT_HANDLER(H)\n+#define GET_IDENTIFIER(S) xstrdup ((S))\n+#define REAL_VALUE_ATOF(LIT,MODE) 0\n+#define REAL_VALUE_ISINF(VALUE)   0\n+#define REAL_VALUE_ISNAN(VALUE)   0\n+#define SET_REAL_VALUE_ATOF(TARGET,SOURCE)\n+#define FLOAT_TYPE_NODE 0\n+#define DOUBLE_TYPE_NODE 0\n+#define SET_MODIFIER_CTX(TOKEN) java_lval->value = (TOKEN)\n+#define GET_TYPE_PRECISION(NODE) 4\n+#define BUILD_OPERATOR(TOKEN)\treturn TOKEN\n+#define BUILD_OPERATOR2(TOKEN)\treturn TOKEN\n+#define SET_LVAL_NODE(NODE)\n+#define SET_LVAL_NODE_TYPE(NODE, TYPE)\n+#define BUILD_ID_WFL(EXP) (EXP)\n+#define JAVA_FLOAT_RANGE_ERROR(S) {}\n+#define JAVA_INTEGRAL_RANGE_ERROR(S) {}\n+\n+#else\n+\n+static tree build_wfl_node ();\n+#define SET_FLOAT_HANDLER(H) set_float_handler ((H))\n+#define DCONST0 dconst0\n+#define GET_IDENTIFIER(S) get_identifier ((S))\n+#define SET_REAL_VALUE_ATOF(TARGET,SOURCE) (TARGET) = (SOURCE)\n+#define FLOAT_TYPE_NODE float_type_node\n+#define DOUBLE_TYPE_NODE double_type_node\n+/* Set modifier_ctx according to TOKEN */\n+#define SET_MODIFIER_CTX(TOKEN)\t\t\t\t\t\t   \\\n+  {\t\t\t\t\t\t\t\t\t   \\\n+    ctxp->modifier_ctx [(TOKEN)-PUBLIC_TK] = build_wfl_node (NULL_TREE); \\\n+    java_lval->value = (TOKEN)-PUBLIC_TK;\t\t\t\t   \\\n+  }\n+/* Type precision for long */\n+#define GET_TYPE_PRECISION(NODE) TYPE_PRECISION (long_type_node) / 8;\n+/* Build an operator tree node and return TOKEN */\n+#define BUILD_OPERATOR(TOKEN)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    java_lval->operator.token = (TOKEN);\t\t\\\n+    java_lval->operator.location = BUILD_LOCATION();\t\\\n+    return (TOKEN);\t\t\t\t\t\\\n+  }\n+\n+/* Build an operator tree node but return ASSIGN_ANY_TK */\n+#define BUILD_OPERATOR2(TOKEN)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    java_lval->operator.token = (TOKEN);\t\t\\\n+    java_lval->operator.location = BUILD_LOCATION();\t\\\n+    return ASSIGN_ANY_TK;\t\t\t\t\\\n+  }\n+/* Set java_lval->node and TREE_TYPE(java_lval->node) in macros */\n+#define SET_LVAL_NODE(NODE) java_lval->node = (NODE)\n+#define SET_LVAL_NODE_TYPE(NODE,TYPE)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    java_lval->node = (NODE);\t\t\t\\\n+    TREE_TYPE (java_lval->node) = (TYPE);\t\\\n+  }\n+/* Wrap identifier around a wfl */\n+#define BUILD_ID_WFL(EXP) build_wfl_node ((EXP))\n+/* Special ways to report error on numeric literals  */\n+#define JAVA_FLOAT_RANGE_ERROR(m)\t\t\t\t\t  \\\n+  {\t\t\t\t\t\t\t\t\t  \\\n+    char msg [1024];\t\t\t\t\t\t\t  \\\n+    int i = ctxp->c_line->current;\t\t\t\t\t  \\\n+    ctxp->c_line->current = number_beginning;\t\t\t\t  \\\n+    sprintf (msg, \"Floating pointer literal exceeds range of `%s'\", (m)); \\\n+    java_lex_error (msg, 0);\t\t\t\t\t\t  \\\n+    ctxp->c_line->current = i;\t\t\t\t\t\t  \\\n+    value = dconst0;\t\t\t\t\t\t\t  \\\n+  }\n+#define JAVA_INTEGRAL_RANGE_ERROR(m)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    int i = ctxp->c_line->current;\t\t\\\n+    ctxp->c_line->current = number_beginning;\t\\\n+    java_lex_error (m, 0);\t\t\t\\\n+    ctxp->c_line->current = i;\t\t\t\\\n+  }\n+\n+#endif /* Definitions for jc1 compilation only */\n+\n+/* Macros to decode character ranges */\n+#define RANGE(c, l, h)           (((c) >= l && (c) <= h))\n+#define JAVA_WHITE_SPACE_P(c) (c == ' ' || c == '\\t' || c == '\\f')\n+#define JAVA_ID_CHAR_P(c)     ((c < 128 && (RANGE (c, 'A', 'Z') ||\t\\\n+\t\t\t\t\t    RANGE (c, 'a', 'z') ||\t\\\n+\t\t\t\t\t    RANGE (c, '0', '9') ||\t\\\n+\t\t\t\t\t    c == '_'         ||\t\t\\\n+\t\t\t\t\t    c == '$'))       ||\t\t\\\n+\t\t\t       (c > 127 && java_letter_or_digit_p (c)))\n+#define JAVA_ASCII_DIGIT(c)    RANGE(c,'0', '9')\n+#define JAVA_ASCII_OCTDIGIT(c) RANGE(c,'0', '7')\n+#define JAVA_ASCII_HEXDIGIT(c) (RANGE(c,'0', '9') || \t\\\n+\t\t\t\tRANGE(c,'a', 'f') ||\t\\\n+\t\t\t\tRANGE(c,'A', 'F'))\n+#define JAVA_ASCII_FPCHAR(c)   (RANGE(c,'d', 'f') || RANGE(c,'D', 'F') || \\\n+\t\t\t\tc == '.' || JAVA_ASCII_DIGIT (c))\n+#define JAVA_FP_SUFFIX(c)      (c == 'D' || c == 'd' || c == 'f' || c == 'F')\n+#define JAVA_FP_EXP(c)         (c == 'E' || c == 'F')\n+#define JAVA_FP_PM(c)          (c == '-' || c == '+')\n+#define JAVA_ASCII_LETTER(c)   (RANGE(c,'a', 'z') || RANGE(c,'A', 'Z'))\n+#define JAVA_DIGIT_P(c)\t\t\t\t\t\t\t      \\\n+   (RANGE (c, 0x030, 0x039) || /* ISO-Latin-1 (and ASCII) digits ('0'-'9') */ \\\n+    RANGE (c, 0x660, 0x669) || /* Arabic-Indic digits */\t\t      \\\n+    RANGE (c, 0x6F0, 0x6F9) || /* Eastern Arabic-Indic digits */\t      \\\n+    RANGE (c, 0x966, 0x96F) || /* Devanagari digits */\t\t\t      \\\n+    RANGE (c, 0x9E6, 0x9EF) || /* Bengali digits */\t\t\t      \\\n+    RANGE (c, 0xA66, 0xA6F) || /* Gurmukhi digits */\t\t\t      \\\n+    RANGE (c, 0xAE6, 0xAEF) || /* Gujarati digits */\t\t\t      \\\n+    RANGE (c, 0xB66, 0xB6F) || /* Oriya digits */\t\t\t      \\\n+    RANGE (c, 0xBE7, 0xBEF) || /* Tamil digits */\t\t\t      \\\n+    RANGE (c, 0xC66, 0xC6F) || /* Telugu digits */\t\t\t      \\\n+    RANGE (c, 0xCE6, 0xCEF) || /* Kannada digits */\t\t\t      \\\n+    RANGE (c, 0xD66, 0xD6F) || /* Malayalam digits */\t\t\t      \\\n+    RANGE (c, 0xE50, 0xE59) || /* Thai digits */\t\t\t      \\\n+    RANGE (c, 0xED0, 0xED9))   /* Lao digits */\n+\n+/* This is not to be used as a stand alone macro. Use JAVA_ID_CHAR_P()\n+   or the forcoming JAVA_LETTER_OR_DIGIT_P() instead.\n+   It need to be split by region. FIXME.  */\n+#define _JAVA_LETTER_OR_DIGIT_P(c)\t\t\\\n+   (RANGE (c, 0x00C0, 0x00D6) ||\t\t\\\n+    RANGE (c, 0x00D8, 0x00F6) ||\t\t\\\n+    RANGE (c, 0x00F8, 0x01F5) ||\t\t\\\n+    RANGE (c, 0x01FA, 0x0217) ||\t\t\\\n+    RANGE (c, 0x0250, 0x02A8) ||\t\t\\\n+    RANGE (c, 0x02B0, 0x02DE) ||\t\t\\\n+    RANGE (c, 0x02E0, 0x02E9) ||\t\t\\\n+    RANGE (c, 0x0300, 0x0345) ||\t\t\\\n+    RANGE (c, 0x0360, 0x0361) ||\t\t\\\n+    RANGE (c, 0x0374, 0x0375) ||\t\t\\\n+    c == 0x037A            ||\t\t\t\\\n+    c == 0x037E            ||\t\t\t\\\n+    RANGE (c, 0x0384, 0x038A) ||\t\t\\\n+    c == 0x038C            ||\t\t\t\\\n+    c == 0x038E            ||\t\t\t\\\n+    RANGE (c, 0x038F, 0x03A1) ||\t\t\\\n+    RANGE (c, 0x03A3, 0x03CE) ||\t\t\\\n+    RANGE (c, 0x03D0, 0x03D6) ||\t\t\\\n+    RANGE (c, 0x03DA, 0x03E2) ||\t\t\\\n+    c == 0x03DA            ||\t\t\t\\\n+    c == 0x03DC            ||\t\t\t\\\n+    c == 0x03DE            ||\t\t\t\\\n+    c == 0x03E0            ||\t\t\t\\\n+    RANGE (c, 0x03E2, 0x03F3) ||\t\t\\\n+    RANGE (c, 0x0401, 0x040C) ||\t\t\\\n+    RANGE (c, 0x040E, 0x044F) ||\t\t\\\n+    RANGE (c, 0x0451, 0x045C) ||\t\t\\\n+    RANGE (c, 0x045E, 0x0486) ||\t\t\\\n+    RANGE (c, 0x0490, 0x04C4) ||\t\t\\\n+    RANGE (c, 0x04C7, 0x04C8) ||\t\t\\\n+    RANGE (c, 0x04CB, 0x04CC) ||\t\t\\\n+    RANGE (c, 0x04D0, 0x04EB) ||\t\t\\\n+    RANGE (c, 0x04EE, 0x04F5) ||\t\t\\\n+    RANGE (c, 0x04F8, 0x04F9) ||\t\t\\\n+    RANGE (c, 0x0531, 0x0556) ||\t\t\\\n+    RANGE (c, 0x0559, 0x055F) ||\t\t\\\n+    RANGE (c, 0x0561, 0x0587) ||\t\t\\\n+    c == 0x0589            ||\t\t\t\\\n+    RANGE (c, 0x05B0, 0x05B9) ||\t\t\\\n+    RANGE (c, 0x05BB, 0x05C3) ||\t\t\\\n+    RANGE (c, 0x05D0, 0x05EA) ||\t\t\\\n+    RANGE (c, 0x05F0, 0x05F4) ||\t\t\\\n+    c == 0x060C            ||\t\t\t\\\n+    c == 0x061B            ||\t\t\t\\\n+    c == 0x061F            ||\t\t\t\\\n+    c == 0x0621            ||\t\t\t\\\n+    RANGE (c, 0x0622, 0x063A) ||\t\t\\\n+    RANGE (c, 0x0640, 0x0652) ||\t\t\\\n+    RANGE (c, 0x0660, 0x066D) ||\t\t\\\n+    RANGE (c, 0x0670, 0x06B7) ||\t\t\\\n+    RANGE (c, 0x06BA, 0x06BE) ||\t\t\\\n+    RANGE (c, 0x06C0, 0x06CE) ||\t\t\\\n+    RANGE (c, 0x06D0, 0x06ED) ||\t\t\\\n+    RANGE (c, 0x06F0, 0x06F9) ||\t\t\\\n+    RANGE (c, 0x0901, 0x0903) ||\t\t\\\n+    RANGE (c, 0x0905, 0x0939) ||\t\t\\\n+    RANGE (c, 0x093C, 0x094D) ||\t\t\\\n+    RANGE (c, 0x0950, 0x0954) ||\t\t\\\n+    RANGE (c, 0x0958, 0x0970) ||\t\t\\\n+    RANGE (c, 0x0981, 0x0983) ||\t\t\\\n+    RANGE (c, 0x0985, 0x098C) ||\t\t\\\n+    RANGE (c, 0x098F, 0x0990) ||\t\t\\\n+    RANGE (c, 0x0993, 0x09A8) ||\t\t\\\n+    RANGE (c, 0x09AA, 0x09B0) ||\t\t\\\n+    c == 0x09B2            ||\t\t\t\\\n+    RANGE (c, 0x09B6, 0x09B9) ||\t\t\\\n+    c == 0x09BC            ||\t\t\t\\\n+    c == 0x09BE            ||\t\t\t\\\n+    RANGE (c, 0x09BF, 0x09C4) ||\t\t\\\n+    RANGE (c, 0x09C7, 0x09C8) ||\t\t\\\n+    RANGE (c, 0x09CB, 0x09CD) ||\t\t\\\n+    c == 0x09D7            ||\t\t\t\\\n+    RANGE (c, 0x09DC, 0x09DD) ||\t\t\\\n+    RANGE (c, 0x09DF, 0x09E3) ||\t\t\\\n+    RANGE (c, 0x09E6, 0x09FA) ||\t\t\\\n+    c == 0x0A02            ||\t\t\t\\\n+    RANGE (c, 0x0A05, 0x0A0A) ||\t\t\\\n+    RANGE (c, 0x0A0F, 0x0A10) ||\t\t\\\n+    RANGE (c, 0x0A13, 0x0A28) ||\t\t\\\n+    RANGE (c, 0x0A2A, 0x0A30) ||\t\t\\\n+    RANGE (c, 0x0A32, 0x0A33) ||\t\t\\\n+    RANGE (c, 0x0A35, 0x0A36) ||\t\t\\\n+    RANGE (c, 0x0A38, 0x0A39) ||\t\t\\\n+    c == 0x0A3C            ||\t\t\t\\\n+    c == 0x0A3E            ||\t\t\t\\\n+    RANGE (c, 0x0A3F, 0x0A42) ||\t\t\\\n+    RANGE (c, 0x0A47, 0x0A48) ||\t\t\\\n+    RANGE (c, 0x0A4B, 0x0A4D) ||\t\t\\\n+    RANGE (c, 0x0A59, 0x0A5C) ||\t\t\\\n+    c == 0x0A5E            ||\t\t\t\\\n+    RANGE (c, 0x0A66, 0x0A74) ||\t\t\\\n+    RANGE (c, 0x0A81, 0x0A83) ||\t\t\\\n+    RANGE (c, 0x0A85, 0x0A8B) ||\t\t\\\n+    c == 0x0A8D            ||\t\t\t\\\n+    c == 0x0A8F            ||\t\t\t\\\n+    RANGE (c, 0x0A90, 0x0A91) ||\t\t\\\n+    RANGE (c, 0x0A93, 0x0AA8) ||\t\t\\\n+    RANGE (c, 0x0AAA, 0x0AB0) ||\t\t\\\n+    RANGE (c, 0x0AB2, 0x0AB3) ||\t\t\\\n+    RANGE (c, 0x0AB5, 0x0AB9) ||\t\t\\\n+    RANGE (c, 0x0ABC, 0x0AC5) ||\t\t\\\n+    RANGE (c, 0x0AC7, 0x0AC9) ||\t\t\\\n+    RANGE (c, 0x0ACB, 0x0ACD) ||\t\t\\\n+    c == 0x0AD0            ||\t\t\t\\\n+    c == 0x0AE0            ||\t\t\t\\\n+    RANGE (c, 0x0AE6, 0x0AEF) ||\t\t\\\n+    RANGE (c, 0x0B01, 0x0B03) ||\t\t\\\n+    RANGE (c, 0x0B05, 0x0B0C) ||\t\t\\\n+    RANGE (c, 0x0B0F, 0x0B10) ||\t\t\\\n+    RANGE (c, 0x0B13, 0x0B28) ||\t\t\\\n+    RANGE (c, 0x0B2A, 0x0B30) ||\t\t\\\n+    RANGE (c, 0x0B32, 0x0B33) ||\t\t\\\n+    RANGE (c, 0x0B36, 0x0B39) ||\t\t\\\n+    RANGE (c, 0x0B3C, 0x0B43) ||\t\t\\\n+    RANGE (c, 0x0B47, 0x0B48) ||\t\t\\\n+    RANGE (c, 0x0B4B, 0x0B4D) ||\t\t\\\n+    RANGE (c, 0x0B56, 0x0B57) ||\t\t\\\n+    RANGE (c, 0x0B5C, 0x0B5D) ||\t\t\\\n+    RANGE (c, 0x0B5F, 0x0B61) ||\t\t\\\n+    RANGE (c, 0x0B66, 0x0B70) ||\t\t\\\n+    RANGE (c, 0x0B82, 0x0B83) ||\t\t\\\n+    RANGE (c, 0x0B85, 0x0B8A) ||\t\t\\\n+    RANGE (c, 0x0B8E, 0x0B90) ||\t\t\\\n+    RANGE (c, 0x0B92, 0x0B95) ||\t\t\\\n+    RANGE (c, 0x0B99, 0x0B9A) ||\t\t\\\n+    c == 0x0B9C            ||\t\t\t\\\n+    c == 0x0B9E            ||\t\t\t\\\n+    c == 0x0B9F            ||\t\t\t\\\n+    RANGE (c, 0x0BA3, 0x0BA4) ||\t\t\\\n+    RANGE (c, 0x0BA8, 0x0BAA) ||\t\t\\\n+    RANGE (c, 0x0BAE, 0x0BB5) ||\t\t\\\n+    RANGE (c, 0x0BB7, 0x0BB9) ||\t\t\\\n+    RANGE (c, 0x0BBE, 0x0BC2) ||\t\t\\\n+    RANGE (c, 0x0BC6, 0x0BC8) ||\t\t\\\n+    RANGE (c, 0x0BCA, 0x0BCD) ||\t\t\\\n+    c == 0x0BD7            ||\t\t\t\\\n+    RANGE (c, 0x0BE7, 0x0BF2) ||\t\t\\\n+    RANGE (c, 0x0C01, 0x0C03) ||\t\t\\\n+    RANGE (c, 0x0C05, 0x0C0C) ||\t\t\\\n+    RANGE (c, 0x0C0E, 0x0C10) ||\t\t\\\n+    RANGE (c, 0x0C12, 0x0C28) ||\t\t\\\n+    RANGE (c, 0x0C2A, 0x0C33) ||\t\t\\\n+    RANGE (c, 0x0C35, 0x0C39) ||\t\t\\\n+    RANGE (c, 0x0C3E, 0x0C44) ||\t\t\\\n+    RANGE (c, 0x0C46, 0x0C48) ||\t\t\\\n+    RANGE (c, 0x0C4A, 0x0C4D) ||\t\t\\\n+    RANGE (c, 0x0C55, 0x0C56) ||\t\t\\\n+    RANGE (c, 0x0C60, 0x0C61) ||\t\t\\\n+    RANGE (c, 0x0C66, 0x0C6F) ||\t\t\\\n+    RANGE (c, 0x0C82, 0x0C83) ||\t\t\\\n+    RANGE (c, 0x0C85, 0x0C8C) ||\t\t\\\n+    RANGE (c, 0x0C8E, 0x0C90) ||\t\t\\\n+    RANGE (c, 0x0C92, 0x0CA8) ||\t\t\\\n+    RANGE (c, 0x0CAA, 0x0CB3) ||\t\t\\\n+    RANGE (c, 0x0CB5, 0x0CB9) ||\t\t\\\n+    RANGE (c, 0x0CBE, 0x0CC4) ||\t\t\\\n+    RANGE (c, 0x0CC6, 0x0CC8) ||\t\t\\\n+    RANGE (c, 0x0CCA, 0x0CCD) ||\t\t\\\n+    RANGE (c, 0x0CD5, 0x0CD6) ||\t\t\\\n+    c == 0x0CDE            ||\t\t\t\\\n+    c == 0x0CE0            ||\t\t\t\\\n+    c == 0x0CE1            ||\t\t\t\\\n+    RANGE (c, 0x0CE6, 0x0CEF) ||\t\t\\\n+    RANGE (c, 0x0D02, 0x0D03) ||\t\t\\\n+    RANGE (c, 0x0D05, 0x0D0C) ||\t\t\\\n+    RANGE (c, 0x0D0E, 0x0D10) ||\t\t\\\n+    RANGE (c, 0x0D12, 0x0D28) ||\t\t\\\n+    RANGE (c, 0x0D2A, 0x0D39) ||\t\t\\\n+    RANGE (c, 0x0D3E, 0x0D43) ||\t\t\\\n+    RANGE (c, 0x0D46, 0x0D48) ||\t\t\\\n+    RANGE (c, 0x0D4A, 0x0D4D) ||\t\t\\\n+    c == 0x0D57            ||\t\t\t\\\n+    RANGE (c, 0x0D60, 0x0D61) ||\t\t\\\n+    RANGE (c, 0x0D66, 0x0D6F) ||\t\t\\\n+    RANGE (c, 0x0E01, 0x0E3A) ||\t\t\\\n+    RANGE (c, 0x0E3F, 0x0E5B) ||\t\t\\\n+    RANGE (c, 0x0E81, 0x0E82) ||\t\t\\\n+    c == 0x0E84            ||\t\t\t\\\n+    RANGE (c, 0x0E87, 0x0E88) ||\t\t\\\n+    c == 0x0E8A            ||\t\t\t\\\n+    c == 0x0E8D            ||\t\t\t\\\n+    RANGE (c, 0x0E94, 0x0E97) ||\t\t\\\n+    RANGE (c, 0x0E99, 0x0E9F) ||\t\t\\\n+    RANGE (c, 0x0EA1, 0x0EA3) ||\t\t\\\n+    c == 0x0EA5            ||\t\t\t\\\n+    c == 0x0EA7            ||\t\t\t\\\n+    RANGE (c, 0x0EAA, 0x0EAB) ||\t\t\\\n+    RANGE (c, 0x0EAD, 0x0EB9) ||\t\t\\\n+    RANGE (c, 0x0EBB, 0x0EBD) ||\t\t\\\n+    RANGE (c, 0x0EC0, 0x0EC4) ||\t\t\\\n+    c == 0x0EC6            ||\t\t\t\\\n+    c == 0x0EC8            ||\t\t\t\\\n+    RANGE (c, 0x0EC9, 0x0ECD) ||\t\t\\\n+    RANGE (c, 0x0ED0, 0x0ED9) ||\t\t\\\n+    RANGE (c, 0x0EDC, 0x0EDD) ||\t\t\\\n+    RANGE (c, 0x10A0, 0x10C5) ||\t\t\\\n+    RANGE (c, 0x10D0, 0x10F6) ||\t\t\\\n+    c == 0x10FB            ||\t\t\t\\\n+    RANGE (c, 0x1100, 0x1159) ||\t\t\\\n+    RANGE (c, 0x115F, 0x11A2) ||\t\t\\\n+    RANGE (c, 0x11A8, 0x11F9) ||\t\t\\\n+    RANGE (c, 0x1E00, 0x1E9A) ||\t\t\\\n+    RANGE (c, 0x1EA0, 0x1EF9) ||\t\t\\\n+    RANGE (c, 0x1F00, 0x1F15) ||\t\t\\\n+    RANGE (c, 0x1F18, 0x1F1D) ||\t\t\\\n+    RANGE (c, 0x1F20, 0x1F45) ||\t\t\\\n+    RANGE (c, 0x1F48, 0x1F4D) ||\t\t\\\n+    RANGE (c, 0x1F50, 0x1F57) ||\t\t\\\n+    c == 0x1F59            ||\t\t\t\\\n+    c == 0x1F5B            ||\t\t\t\\\n+    c == 0x1F5D            ||\t\t\t\\\n+    RANGE (c, 0x1F5F, 0x1F7D) ||\t\t\\\n+    RANGE (c, 0x1F80, 0x1FB4) ||\t\t\\\n+    RANGE (c, 0x1FB6, 0x1FC4) ||\t\t\\\n+    RANGE (c, 0x1FC6, 0x1FD3) ||\t\t\\\n+    RANGE (c, 0x1FD6, 0x1FDB) ||\t\t\\\n+    RANGE (c, 0x1FDD, 0x1FEF) ||\t\t\\\n+    RANGE (c, 0x1FF2, 0x1FF4) ||\t\t\\\n+    RANGE (c, 0x1FF6, 0x1FFE) ||\t\t\\\n+    RANGE (c, 0x3041, 0x3094) ||\t\t\\\n+    RANGE (c, 0x3099, 0x309E) ||\t\t\\\n+    RANGE (c, 0x30A1, 0x30FE) ||\t\t\\\n+    RANGE (c, 0x3105, 0x312C) ||\t\t\\\n+    RANGE (c, 0x3131, 0x318E) ||\t\t\\\n+    RANGE (c, 0x3190, 0x319F) ||\t\t\\\n+    RANGE (c, 0x3200, 0x321C) ||\t\t\\\n+    RANGE (c, 0x3220, 0x3243) ||\t\t\\\n+    RANGE (c, 0x3260, 0x327B) ||\t\t\\\n+    RANGE (c, 0x327F, 0x32B0) ||\t\t\\\n+    RANGE (c, 0x32C0, 0x32CB) ||\t\t\\\n+    RANGE (c, 0x32D0, 0x32FE) ||\t\t\\\n+    RANGE (c, 0x3300, 0x3376) ||\t\t\\\n+    RANGE (c, 0x337B, 0x33DD) ||\t\t\\\n+    RANGE (c, 0x33E0, 0x33FE) ||\t\t\\\n+    RANGE (c, 0x3400, 0x9FA5) ||\t\t\\\n+    RANGE (c, 0xF900, 0xFA2D) ||\t\t\\\n+    RANGE (c, 0xFB00, 0xFB06) ||\t\t\\\n+    RANGE (c, 0xFB13, 0xFB17) ||\t\t\\\n+    RANGE (c, 0xFB1E, 0xFB36) ||\t\t\\\n+    RANGE (c, 0xFB38, 0xFB3C) ||\t\t\\\n+    c == 0xFB3E            ||\t\t\t\\\n+    c == 0xFB40            ||\t\t\t\\\n+    c == 0xFB41            ||\t\t\t\\\n+    c == 0xFB43            ||\t\t\t\\\n+    c == 0xFB44            ||\t\t\t\\\n+    c == 0xFB46            ||\t\t\t\\\n+    RANGE (c, 0xFB47, 0xFBB1) ||\t\t\\\n+    RANGE (c, 0xFBD3, 0xFD3F) ||\t\t\\\n+    RANGE (c, 0xFD50, 0xFD8F) ||\t\t\\\n+    RANGE (c, 0xFD92, 0xFDC7) ||\t\t\\\n+    RANGE (c, 0xFDF0, 0xFDFB) ||\t\t\\\n+    RANGE (c, 0xFE70, 0xFE72) ||\t\t\\\n+    c == 0xFE74            ||\t\t\t\\\n+    c == 0xFE76            ||\t\t\t\\\n+    RANGE (c, 0xFE77, 0xFEFC) ||\t\t\\\n+    RANGE (c, 0xFF10, 0xFF19) ||\t\t\\\n+    RANGE (c, 0xFF21, 0xFF3A) ||\t\t\\\n+    RANGE (c, 0xFF41, 0xFF5A) ||\t\t\\\n+    RANGE (c, 0xFF66, 0xFFBE) ||\t\t\\\n+    RANGE (c, 0xFFC2, 0xFFC7) ||\t\t\\\n+    RANGE (c, 0xFFCA, 0xFFCF) ||\t\t\\\n+    RANGE (c, 0xFFD2, 0xFFD7) ||\t\t\\\n+    RANGE (c, 0xFFDA, 0xFFDC))\n+\n+/* Constants  */\n+#define JAVA_CHAR_ERROR 0xFFC1\t/* This is an illegal unicode!?! FIXME */\n+#define JAVA_READ_BUFFER 256\n+#define UEOF (unicode_t)0xffff\n+\n+#endif"}, {"sha": "f303c926a08765428577f46d4ac56982d8fc1857", "filename": "gcc/java/mangle.c", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle.c?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,163 @@\n+/* Functions related to mangling class names for the GNU compiler\n+   for the Java(TM) language.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA. \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Written by Per Bothner <bothner@cygnus.com> */\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"config.h\"\n+#include \"jcf.h\"\n+#include \"obstack.h\"\n+\n+/* Assuming (NAME, LEN) is a Utf8-encoding string, calculate\n+   the length of the string as mangled (a la g++) including Unicode escapes.\n+   If no escapes are needed, return 0. */\n+\n+int\n+unicode_mangling_length (name, len)\n+     char *name; \n+     int len; \n+{\n+  unsigned char *ptr;\n+  unsigned char *limit = (unsigned char *)name + len;\n+  int need_escapes = 0;\n+  int num_chars = 0;\n+  int underscores = 0;\n+  for (ptr = (unsigned char *) name;  ptr < limit;  )\n+    {\n+      int ch = UTF8_GET(ptr, limit);\n+      if (ch < 0)\n+\terror (\"internal error - invalid Utf8 name\");\n+      if (ch >= '0' && ch <= '9')\n+\tneed_escapes += num_chars == 0;\n+      else if (ch == '_')\n+\tunderscores++;\n+      else if ((ch < 'a' || ch > 'z') && (ch < 'A' || ch > 'Z'))\n+\tneed_escapes++;\n+      num_chars++;\n+    }\n+  if (need_escapes)\n+    return num_chars + 4 * (need_escapes + underscores);\n+  else\n+    return 0;\n+}\n+\n+/* Assuming (NAME, LEN) is a Utf8-encoding string, emit the string\n+   appropriately mangled (with Unicode escapes) to OBSTACK. */\n+\n+void\n+emit_unicode_mangled_name (obstack, name, len)\n+     struct obstack *obstack;\n+     char *name;\n+{\n+  unsigned char *ptr;\n+  unsigned char *limit = (unsigned char *)name + len;\n+  for (ptr = (unsigned char *) name;  ptr < limit;  )\n+    {\n+      int ch = UTF8_GET(ptr, limit);\n+      int emit_escape;\n+      if (ch < 0)\n+\t{\n+\t  error (\"internal error - bad Utf8 string\");\n+\t  break;\n+\t}\n+      if (ch >= '0' && ch <= '9')\n+\temit_escape = (ptr == (unsigned char*) name);\n+      else\n+\temit_escape = (ch < 'a' || ch > 'z') && (ch < 'A' || ch > 'Z');\n+      if (emit_escape)\n+\t{\n+\t  char buf[6];\n+\t  sprintf (buf, \"_%04x\", ch);\n+\t  obstack_grow (obstack, buf, 5);\n+\t}\n+      else\n+\t{\n+\t  obstack_1grow (obstack, ch);\n+\t}\n+    }\n+}\n+\n+/* Assuming (NAME, LEN) is a Utf8-encoding string, emit the string\n+   appropriately mangled (with Unicode escapes if needed) to OBSTACK. */\n+\n+void\n+append_gpp_mangled_name (obstack, name, len)\n+     struct obstack *obstack;\n+     char *name;\n+     int len;\n+{\n+  int encoded_len = unicode_mangling_length (name, len);\n+  int needs_escapes = encoded_len > 0;\n+  char buf[6];\n+  if (needs_escapes)\n+    {\n+      sprintf (buf, \"U%d\", encoded_len);\n+      obstack_grow (obstack, buf, strlen(buf));\n+      emit_unicode_mangled_name (obstack, name, len);\n+    }\n+  else\n+    {\n+      sprintf (buf, \"%d\", len);\n+      obstack_grow (obstack, buf, strlen(buf));\n+      obstack_grow (obstack, name, len);\n+    }\n+}\n+\n+/* Append the mangled name of a class named CLASSNAME onto OBSTACK. */\n+\n+void\n+append_gpp_mangled_classtype (obstack, class_name)\n+     struct obstack *obstack;\n+     char *class_name;\n+{\n+  char *ptr;\n+  int qualifications = 0;\n+\n+  for (ptr = class_name; *ptr != '\\0'; ptr++)\n+    {\n+      if (*ptr == '.')\n+\tqualifications++;\n+    }\n+  if (qualifications)\n+    {\n+      char buf[8];\n+      if (qualifications >= 9)\n+\tsprintf (buf, \"Q_%d_\", qualifications + 1);\n+      else\n+\tsprintf (buf, \"Q%d\", qualifications + 1);\n+      obstack_grow (obstack, buf, strlen (buf));\n+    }\n+  for (ptr = class_name; ; ptr++)\n+    {\n+      if (ptr[0] == '.' || ptr[0] == '\\0')\n+\t{\n+\t  append_gpp_mangled_name (obstack, class_name, ptr - class_name);\n+\t  if (ptr[0] == '\\0')\n+\t    break;\n+\t  class_name = ptr + 1;\n+\t}\n+    }\n+}"}, {"sha": "11c9978c67ee51949c64a2fdd8e22660fbc3b654", "filename": "gcc/java/parse-scan.y", "status": "added", "additions": 1162, "deletions": 0, "changes": 1162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fparse-scan.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fparse-scan.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse-scan.y?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,1162 @@\n+/* Parser grammar for quick source code scan of Java(TM) language programs.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Contributed by Alexandre Petit-Bianco (apbianco@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* This file parses Java source code. Action can be further completed\n+to achieve a desired behavior. This file isn't part of the Java\n+language gcc front end.\n+\n+The grammar conforms to the Java grammar described in \"The Java(TM)\n+Language Specification. J. Gosling, B. Joy, G. Steele. Addison Wesley\n+1996, ISBN 0-201-63451-1\"\n+\n+Some rules have been modified to support JDK1.1 inner classes\n+definitions and other extensions.  */\n+\n+%{\n+#define JC1_LITE\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+/* Definitions for PROTO and VPROTO macros */\n+#include \"gansidecl.h\"\n+#include \"obstack.h\"\n+\n+extern char *input_filename;\n+extern FILE *finput, *out;\n+\n+/* Obstack for the lexer.  */\n+struct obstack temporary_obstack;\n+\n+/* The current parser context.  */\n+static struct parser_ctxt *ctxp;\n+\n+/* Error and warning counts, current line number, because they're used\n+   elsewhere  */\n+int java_error_count;\n+int java_warning_count;\n+int lineno;\n+\n+/* Tweak default rules when necessary.  */\n+static int absorber;\n+#define USE_ABSORBER absorber = 0\n+\n+/* Keep track of the current class name and package name.  */\n+static char *current_class;\n+static char *package_name;\n+\n+/* Keep track of whether things have be listed before.  */\n+static int previous_output;\n+\n+/* Record modifier uses  */\n+static int modifier_value;\n+\n+/* Record a method declaration  */\n+struct method_declarator {\n+  char *method_name;\n+  char *args;\n+};\n+#define NEW_METHOD_DECLARATOR(D,N,A)\t\t\t\t\t     \\\n+{\t\t\t\t\t\t\t\t\t     \\\n+  (D) = \t\t\t\t\t\t\t\t     \\\n+    (struct method_declarator *)xmalloc (sizeof (struct method_declarator)); \\\n+  (D)->method_name = (N);\t\t\t\t\t\t     \\\n+  (D)->args = (A);\t\t\t\t\t\t\t     \\\n+}\n+\n+/* Two actions for this grammar */\n+static void report_class_declaration PROTO ((char *));\n+static void report_main_declaration PROTO ((struct method_declarator *));\n+\n+/* Other extern functions */\n+char *xmalloc PROTO ((unsigned));\n+char *xstrdup PROTO ((char *));\n+\n+#include \"lex.h\"\n+#include \"parse.h\"\n+%}\n+\n+%union {\n+  char *node;\n+  struct method_declarator *declarator;\n+  int value;\t\t\t/* For modifiers */\n+}\n+\n+%pure_parser\n+\n+/* Things defined here have to match the order of what's in the\n+   binop_lookup table.  */\n+\n+%token   PLUS_TK         MINUS_TK        MULT_TK         DIV_TK    REM_TK\n+%token   LS_TK           SRS_TK          ZRS_TK\n+%token   AND_TK          XOR_TK          OR_TK\n+%token   BOOL_AND_TK BOOL_OR_TK \n+%token   EQ_TK NEQ_TK GT_TK GTE_TK LT_TK LTE_TK\n+\n+/* This maps to the same binop_lookup entry than the token above */\n+\n+%token   PLUS_ASSIGN_TK  MINUS_ASSIGN_TK MULT_ASSIGN_TK DIV_ASSIGN_TK\n+%token   REM_ASSIGN_TK   \n+%token   LS_ASSIGN_TK    SRS_ASSIGN_TK   ZRS_ASSIGN_TK\n+%token   AND_ASSIGN_TK   XOR_ASSIGN_TK   OR_ASSIGN_TK\n+\n+\n+/* Modifier TOKEN have to be kept in this order. Don't scramble it */\n+\n+%token   PUBLIC_TK       PRIVATE_TK         PROTECTED_TK\n+%token   STATIC_TK       FINAL_TK           SYNCHRONIZED_TK\n+%token   VOLATILE_TK     TRANSIENT_TK       NATIVE_TK\n+%token   PAD_TK          ABSTRACT_TK        MODIFIER_TK\n+\n+/* Keep those two in order, too */\n+%token   DECR_TK INCR_TK\n+\n+/* From now one, things can be in any order */\n+\n+%token   DEFAULT_TK      IF_TK              THROW_TK\n+%token   BOOLEAN_TK      DO_TK              IMPLEMENTS_TK\n+%token   THROWS_TK       BREAK_TK           IMPORT_TK       \n+%token   ELSE_TK         INSTANCEOF_TK      RETURN_TK\n+%token   VOID_TK         CATCH_TK           INTERFACE_TK\n+%token   CASE_TK         EXTENDS_TK         FINALLY_TK\n+%token   SUPER_TK        WHILE_TK           CLASS_TK\n+%token   SWITCH_TK       CONST_TK           TRY_TK\n+%token   FOR_TK          NEW_TK             CONTINUE_TK\n+%token   GOTO_TK         PACKAGE_TK         THIS_TK\n+\n+%token   BYTE_TK         SHORT_TK           INT_TK            LONG_TK\n+%token   CHAR_TK         INTEGRAL_TK\n+\n+%token   FLOAT_TK        DOUBLE_TK          FP_TK\n+\n+%token   ID_TK\n+\n+%token   REL_QM_TK         REL_CL_TK NOT_TK  NEG_TK\n+\n+%token   ASSIGN_ANY_TK   ASSIGN_TK\n+%token   OP_TK  CP_TK  OCB_TK  CCB_TK  OSB_TK  CSB_TK  SC_TK  C_TK DOT_TK\n+\n+%token   STRING_LIT_TK   CHAR_LIT_TK        INT_LIT_TK        FP_LIT_TK\n+%token   TRUE_TK         FALSE_TK           BOOL_LIT_TK       NULL_TK\n+\n+%type <node> ID_TK identifier name simple_name qualified_name type\n+ \t     primitive_type reference_type array_type formal_parameter_list\n+\t     formal_parameter class_or_interface_type class_type interface_type\n+%type <declarator> method_declarator\n+%type <value>      MODIFIER_TK\n+\n+%%\n+/* 19.2 Production from 2.3: The Syntactic Grammar  */\n+goal:\n+\tcompilation_unit\n+;\n+\n+/* 19.3 Productions from 3: Lexical structure  */\n+literal:\n+\tINT_LIT_TK\n+|\tFP_LIT_TK\n+|\tBOOL_LIT_TK\n+|\tCHAR_LIT_TK\n+|       STRING_LIT_TK\n+|       NULL_TK\n+;\n+\n+/* 19.4 Productions from 4: Types, Values and Variables  */\n+type:\n+\tprimitive_type\n+|\treference_type\n+;\n+\n+primitive_type:\n+\tINTEGRAL_TK\n+\t\t{\n+\t\t  /* use preset global here. FIXME */\n+\t\t  $$ = xstrdup (\"int\");\n+\t\t}\n+|\tFP_TK\n+\t\t{\n+\t\t  /* use preset global here. FIXME */\n+\t\t  $$ = xstrdup (\"double\");\n+\t\t}\n+|\tBOOLEAN_TK\n+\t\t{\n+\t\t  /* use preset global here. FIXME */\n+\t\t  $$ = xstrdup (\"boolean\");\n+\t\t}\n+;\n+\n+reference_type:\n+\tclass_or_interface_type\n+|\tarray_type\n+;\n+\n+class_or_interface_type:\n+\tname\n+;\n+\n+class_type:\n+\tclass_or_interface_type\t/* Default rule */\n+;\n+\n+interface_type:\n+\t class_or_interface_type\n+;\n+\n+array_type:\n+\tprimitive_type OSB_TK CSB_TK\n+|\tname OSB_TK CSB_TK\n+\t\t{\n+\t\t  char *n = xmalloc (strlen ($1)+2);\n+\t\t  n [0] = '[';\n+\t\t  strcpy (n+1, $1);\n+\t\t  $$ = n;\n+\t\t}\n+|\tarray_type OSB_TK CSB_TK\n+\t\t{\t\n+\t\t  char *n = xmalloc (strlen ($1)+2);\n+\t\t  n [0] = '[';\n+\t\t  strcpy (n+1, $1);\n+\t\t  $$ = n;\n+\t\t}\n+;\n+\n+/* 19.5 Productions from 6: Names  */\n+name:\n+\tsimple_name\t\t/* Default rule */\n+|\tqualified_name\t\t/* Default rule */\n+;\n+\n+simple_name:\n+\tidentifier\t\t/* Default rule */\n+;\n+\n+qualified_name:\n+\tname DOT_TK identifier\n+\t\t{ \n+\t\t  char *n = xmalloc (strlen ($1)+strlen ($3)+2);\n+\t\t  sprintf (n, \"%s.s\", $1, $3);\n+\t\t  $$ = n;\n+\t\t}\n+;\n+\n+identifier:\n+\tID_TK\n+;\n+\n+/* 19.6: Production from 7: Packages  */\n+compilation_unit:\n+|\tpackage_declaration\n+|\timport_declarations\n+|\ttype_declarations\n+|       package_declaration import_declarations\n+|       package_declaration type_declarations\n+|       import_declarations type_declarations\n+|       package_declaration import_declarations type_declarations\n+;\n+\n+import_declarations:\n+\timport_declaration\n+|\timport_declarations import_declaration\n+;\n+\n+type_declarations:\n+\ttype_declaration\n+| \ttype_declarations type_declaration\n+;\n+\n+package_declaration:\n+\tPACKAGE_TK name SC_TK\n+\t\t{ package_name = $2; }\n+;\n+\n+import_declaration:\n+\tsingle_type_import_declaration\n+|\ttype_import_on_demand_declaration\n+;\n+\n+single_type_import_declaration:\n+\tIMPORT_TK name SC_TK\n+;\n+\n+type_import_on_demand_declaration:\n+\tIMPORT_TK name DOT_TK MULT_TK SC_TK\n+;\n+\n+type_declaration:\n+\tclass_declaration\n+|\tinterface_declaration\n+|\tSC_TK\n+;\n+\n+/* 19.7 Shortened from the original:\n+   modifiers: modifier | modifiers modifier\n+   modifier: any of public...  */\n+modifiers:\n+\tMODIFIER_TK\n+\t\t{ \n+\t\t  if ($1 == PUBLIC_TK)\n+\t\t    modifier_value++;\n+                  if ($1 == STATIC_TK)\n+                    modifier_value++;\n+\t          USE_ABSORBER;\n+\t\t}\t\n+|\tmodifiers MODIFIER_TK\n+\t\t{ \n+\t\t  if ($2 == PUBLIC_TK)\n+\t\t    modifier_value++;\n+                  if ($2 == STATIC_TK)\n+                    modifier_value++;\n+\t\t  USE_ABSORBER;\n+\t\t}\t\n+;\n+\n+/* 19.8.1 Production from $8.1: Class Declaration */\n+class_declaration:\n+\tmodifiers CLASS_TK identifier super interfaces \n+\t\t{ \n+\t\t  report_class_declaration($3);\n+\t\t  modifier_value = 0;\n+                }\n+\tclass_body\n+|\tCLASS_TK identifier super interfaces \n+\t\t{ report_class_declaration($2); }\n+\tclass_body\n+;\n+\n+super:\n+|\tEXTENDS_TK class_type\n+;\n+\n+interfaces:\n+|\tIMPLEMENTS_TK interface_type_list\n+;\n+\n+interface_type_list:\n+\tinterface_type\n+\t\t{ USE_ABSORBER; }\n+|\tinterface_type_list C_TK interface_type\n+\t\t{ USE_ABSORBER; }\n+;\n+\n+class_body:\n+\tOCB_TK CCB_TK\n+|\tOCB_TK class_body_declarations CCB_TK\n+;\n+\n+class_body_declarations:\n+\tclass_body_declaration\n+|\tclass_body_declarations class_body_declaration\n+;\n+\n+class_body_declaration:\n+\tclass_member_declaration\n+|\tstatic_initializer\n+|\tconstructor_declaration\n+|\tblock\t\t\t/* Added, JDK1.1, instance initializer */\n+;\n+\n+class_member_declaration:\n+\tfield_declaration\n+|\tmethod_declaration\n+|\tclass_declaration\t/* Added, JDK1.1 inner classes */\n+|\tinterface_declaration\t/* Added, JDK1.1 inner classes */\n+;\n+\n+/* 19.8.2 Productions from 8.3: Field Declarations  */\n+field_declaration:\n+\ttype variable_declarators SC_TK\n+\t\t{ USE_ABSORBER; }\n+|\tmodifiers type variable_declarators SC_TK\n+\t\t{ modifier_value = 0; }\n+;\n+\n+variable_declarators:\n+\t/* Should we use build_decl_list () instead ? FIXME */\n+\tvariable_declarator\t/* Default rule */\n+|\tvariable_declarators C_TK variable_declarator\n+;\n+\n+variable_declarator:\n+\tvariable_declarator_id\n+|\tvariable_declarator_id ASSIGN_TK variable_initializer\n+;\n+\n+variable_declarator_id:\n+\tidentifier\n+\t\t{ USE_ABSORBER; }\n+|\tvariable_declarator_id OSB_TK CSB_TK\n+;\n+\n+variable_initializer:\n+\texpression\n+|\tarray_initializer\n+;\n+\n+/* 19.8.3 Productions from 8.4: Method Declarations  */\n+method_declaration:\n+\tmethod_header method_body\n+;\n+\n+method_header:\t\n+\ttype method_declarator throws\n+\t\t{ USE_ABSORBER; }\n+|\tVOID_TK method_declarator throws\n+|\tmodifiers type method_declarator throws\n+\t\t{ modifier_value = 0; }\n+|\tmodifiers VOID_TK method_declarator throws\n+\t\t{ \n+                  report_main_declaration ($3);\n+\t\t  modifier_value = 0;\n+\t\t}\n+;\n+\n+method_declarator:\n+\tidentifier OP_TK CP_TK\n+\t\t{ \n+\t\t  struct method_declarator *d;\n+\t\t  NEW_METHOD_DECLARATOR (d, $1, NULL);\n+\t\t  $$ = d;\n+\t\t}\n+|\tidentifier OP_TK formal_parameter_list CP_TK\n+\t\t{ \n+\t\t  struct method_declarator *d;\n+\t\t  NEW_METHOD_DECLARATOR (d, $1, $3);\n+\t\t  $$ = d;\n+\t\t}\n+|\tmethod_declarator OSB_TK CSB_TK\n+;\n+\n+formal_parameter_list:\n+\tformal_parameter\n+|\tformal_parameter_list C_TK formal_parameter\n+\t\t{\n+\t\t  char *n = xmalloc (strlen ($1)+strlen($3)+2);\n+\t\t  sprintf (n, \"%s,%s\", $1, $3);\n+\t\t  $$ = n;\n+\t\t}\n+;\n+\n+formal_parameter:\n+\ttype variable_declarator_id\n+\t\t{ \n+\t\t  USE_ABSORBER;\n+\t\t  $$ = $1;\n+\t\t}\n+|\tmodifiers type variable_declarator_id /* Added, JDK1.1 final locals */\n+\t\t{ $$ = $2; }\n+;\n+\n+throws:\n+|\tTHROWS_TK class_type_list\n+;\n+\n+class_type_list:\n+\tclass_type\n+\t\t{ USE_ABSORBER; }\n+|\tclass_type_list C_TK class_type\n+\t\t{ USE_ABSORBER; }\n+;\n+\n+method_body:\n+\tblock\n+|\tblock SC_TK\n+|\tSC_TK\n+;\n+\n+/* 19.8.4 Productions from 8.5: Static Initializers  */\n+static_initializer:\n+\tstatic block\n+|\tstatic block SC_TK\t/* Shouldn't be here. FIXME */\n+;\n+\n+static:\t\t\t\t/* Test lval.sub_token here */\n+\tMODIFIER_TK\n+\t\t{ USE_ABSORBER; }\n+;\n+\n+/* 19.8.5 Productions from 8.6: Constructor Declarations  */\n+/* NOTE FOR FURTHER WORK ON CONSTRUCTORS:\n+   - If a forbidded modifier is found, the the error is either the use of\n+     a forbidded modifier for a constructor OR bogus attempt to declare a\n+     method without having specified the return type. FIXME */\n+constructor_declaration:\n+\tconstructor_declarator throws constructor_body\n+|\tmodifiers constructor_declarator throws constructor_body\n+\t\t{ modifier_value = 0; }\n+/* extra SC_TK, FIXME */\n+|\tconstructor_declarator throws constructor_body SC_TK\n+/* extra SC_TK, FIXME */\n+|\tmodifiers constructor_declarator throws constructor_body SC_TK\n+\t\t{ modifier_value = 0; }\n+/* I'm not happy with the SC_TK addition. It isn't in the grammer and should\n+   probably be matched by and empty statement. But it doesn't work. FIXME */\n+;\n+\n+constructor_declarator:\n+\tsimple_name OP_TK CP_TK\n+\t\t{ USE_ABSORBER; }\n+|\tsimple_name OP_TK formal_parameter_list CP_TK\n+\t\t{ USE_ABSORBER; }\n+;\n+\n+constructor_body:\n+\tOCB_TK CCB_TK\n+|\tOCB_TK explicit_constructor_invocation CCB_TK\n+|\tOCB_TK block_statements CCB_TK\n+|       OCB_TK explicit_constructor_invocation block_statements CCB_TK\n+;\n+\n+/* Error recovery for that rule moved down expression_statement: rule.  */\n+explicit_constructor_invocation:\n+\tthis_or_super OP_TK CP_TK SC_TK\n+|\tthis_or_super OP_TK argument_list CP_TK SC_TK\n+        /* Added, JDK1.1 inner classes. Modified because the rule\n+\t   'primary' couldn't work.  */\n+|\tname DOT_TK SUPER_TK OP_TK argument_list CP_TK SC_TK\n+\t\t{ USE_ABSORBER; }\n+|\tname DOT_TK SUPER_TK OP_TK CP_TK SC_TK\n+\t\t{ USE_ABSORBER; }\n+;\n+\n+this_or_super:\t\t\t/* Added, simplifies error diagnostics */\n+\tTHIS_TK\n+|\tSUPER_TK\n+;\n+\n+/* 19.9 Productions from 9: Interfaces  */\n+/* 19.9.1 Productions from 9.1: Interfaces Declarations  */\n+interface_declaration:\n+\tINTERFACE_TK identifier\tinterface_body\n+|\tmodifiers INTERFACE_TK identifier interface_body\n+\t\t{ modifier_value = 0; }\n+|\tINTERFACE_TK identifier extends_interfaces interface_body\n+|\tmodifiers INTERFACE_TK identifier extends_interfaces interface_body\n+\t\t{ modifier_value = 0; }\n+;\n+\n+extends_interfaces:\n+\tEXTENDS_TK interface_type\n+|\textends_interfaces C_TK interface_type\n+;\n+\n+interface_body:\n+\tOCB_TK CCB_TK\n+|\tOCB_TK interface_member_declarations CCB_TK\n+;\n+\n+interface_member_declarations:\n+\tinterface_member_declaration\n+|\tinterface_member_declarations interface_member_declaration\n+;\n+\n+interface_member_declaration:\n+\tconstant_declaration\n+|\tabstract_method_declaration\n+|\tclass_declaration\t/* Added, JDK1.1 inner classes */\n+|\tinterface_declaration\t/* Added, JDK1.1 inner classes */\n+;\n+\n+constant_declaration:\n+\tfield_declaration\n+;\n+\n+abstract_method_declaration:\n+\tmethod_header SC_TK\n+;\n+\n+/* 19.10 Productions from 10: Arrays  */\n+array_initializer:\n+\tOCB_TK CCB_TK\n+|\tOCB_TK variable_initializers CCB_TK\n+|\tOCB_TK C_TK CCB_TK\n+|\tOCB_TK variable_initializers C_TK CCB_TK\n+;\n+\n+variable_initializers:\n+\tvariable_initializer\n+|\tvariable_initializers C_TK variable_initializer\n+;\n+\n+/* 19.11 Production from 14: Blocks and Statements  */\n+block:\n+\tOCB_TK CCB_TK\n+|\tOCB_TK block_statements CCB_TK\n+;\n+\n+block_statements:\n+\tblock_statement\n+|\tblock_statements block_statement\n+;\n+\n+block_statement:\n+\tlocal_variable_declaration_statement\n+|\tstatement\n+|\tclass_declaration\t/* Added, JDK1.1 inner classes */\n+;\n+\n+local_variable_declaration_statement:\n+\tlocal_variable_declaration SC_TK /* Can't catch missing ';' here */\n+;\n+\n+local_variable_declaration:\n+\ttype variable_declarators\n+\t\t{ USE_ABSORBER; }\n+|\tmodifiers type variable_declarators /* Added, JDK1.1 final locals */\n+\t\t{ modifier_value = 0; }\n+;\n+\n+statement:\n+\tstatement_without_trailing_substatement\n+|\tlabeled_statement\n+|\tif_then_statement\n+|\tif_then_else_statement\n+|\twhile_statement\n+|\tfor_statement\n+;\n+\n+statement_nsi:\n+\tstatement_without_trailing_substatement\n+|\tlabeled_statement_nsi\n+|\tif_then_else_statement_nsi\n+|\twhile_statement_nsi\n+|\tfor_statement_nsi\n+;\n+\n+statement_without_trailing_substatement:\n+\tblock\n+|\tempty_statement\n+|\texpression_statement\n+|\tswitch_statement\n+|\tdo_statement\n+|\tbreak_statement\n+|\tcontinue_statement\n+|\treturn_statement\n+|\tsynchronized_statement\n+|\tthrow_statement\n+|\ttry_statement\n+;\n+\n+empty_statement:\n+\tSC_TK\n+;\n+\n+label_decl:\n+\tidentifier REL_CL_TK\n+\t\t{ USE_ABSORBER; }\n+;\n+\n+labeled_statement:\n+\tlabel_decl statement\n+;\n+\n+labeled_statement_nsi:\n+\tlabel_decl statement_nsi\n+;\n+\n+/* We concentrate here a bunch of error handling rules that we couldn't write\n+   earlier, because expression_statement catches a missing ';'.  */\n+expression_statement:\n+\tstatement_expression SC_TK\n+;\n+\n+statement_expression: \n+\tassignment\n+|\tpre_increment_expression\n+|\tpre_decrement_expression\n+|\tpost_increment_expression\n+|\tpost_decrement_expression\n+|\tmethod_invocation\n+|\tclass_instance_creation_expression\n+;\n+\n+if_then_statement:\n+\tIF_TK OP_TK expression CP_TK statement\n+;\n+\n+if_then_else_statement:\n+\tIF_TK OP_TK expression CP_TK statement_nsi ELSE_TK statement\n+;\n+\n+if_then_else_statement_nsi:\n+\tIF_TK OP_TK expression CP_TK statement_nsi ELSE_TK statement_nsi\n+;\n+\n+switch_statement:\n+\tSWITCH_TK OP_TK expression CP_TK switch_block\n+;\n+\n+switch_block:\n+\tOCB_TK CCB_TK\n+|\tOCB_TK switch_labels CCB_TK\n+|\tOCB_TK switch_block_statement_groups CCB_TK\n+|\tOCB_TK switch_block_statement_groups switch_labels CCB_TK\n+;\n+\n+switch_block_statement_groups: \n+\tswitch_block_statement_group\n+|\tswitch_block_statement_groups switch_block_statement_group\n+;\n+\n+switch_block_statement_group:\n+\tswitch_labels block_statements\n+;\n+\n+\n+switch_labels:\n+\tswitch_label\n+|\tswitch_labels switch_label\n+;\n+\n+switch_label:\n+\tCASE_TK constant_expression REL_CL_TK\n+|\tDEFAULT_TK REL_CL_TK\n+;\n+\n+while_expression:\n+\tWHILE_TK OP_TK expression CP_TK\n+;\n+\n+while_statement:\n+\twhile_expression statement\n+;\n+\n+while_statement_nsi:\n+\twhile_expression statement_nsi\n+;\n+\n+do_statement_begin:\n+\tDO_TK\n+;\n+\n+do_statement: \n+\tdo_statement_begin statement WHILE_TK OP_TK expression CP_TK SC_TK\n+;\n+\n+for_statement:\n+\tfor_begin SC_TK expression SC_TK for_update CP_TK statement\n+|\tfor_begin SC_TK SC_TK for_update CP_TK statement\n+;\n+\n+for_statement_nsi:\n+\tfor_begin SC_TK expression SC_TK for_update CP_TK statement_nsi\n+|\tfor_begin SC_TK SC_TK for_update CP_TK statement_nsi\n+;\n+\n+for_header:\n+\tFOR_TK OP_TK\n+;\n+\n+for_begin:\n+\tfor_header for_init\n+;\n+for_init:\t\t\t/* Can be empty */\n+|\tstatement_expression_list\n+|\tlocal_variable_declaration\n+;\n+\n+for_update:\t\t\t/* Can be empty */\n+|\tstatement_expression_list\n+;\n+\n+statement_expression_list:\n+\tstatement_expression\n+|\tstatement_expression_list C_TK statement_expression\n+;\n+\n+break_statement:\n+\tBREAK_TK SC_TK\n+|\tBREAK_TK identifier SC_TK\n+;\n+\n+continue_statement:\n+\tCONTINUE_TK SC_TK\n+|       CONTINUE_TK identifier SC_TK\n+;\n+\n+return_statement:\n+\tRETURN_TK SC_TK\n+|\tRETURN_TK expression SC_TK\n+;\n+\n+throw_statement:\n+\tTHROW_TK expression SC_TK\n+;\n+\n+synchronized_statement:\n+\tsynchronized OP_TK expression CP_TK block\n+|\tsynchronized OP_TK expression CP_TK error\n+;\n+\n+synchronized:\t\t\t/* Test lval.sub_token here */\n+\tMODIFIER_TK\n+\t\t{ USE_ABSORBER; }\n+;\n+\n+try_statement:\n+\tTRY_TK block catches\n+|\tTRY_TK block finally\n+|\tTRY_TK block catches finally\n+;\n+\n+catches:\n+\tcatch_clause\n+|\tcatches catch_clause\n+;\n+\n+catch_clause:\n+\tCATCH_TK OP_TK formal_parameter CP_TK block\n+;\n+\n+finally:\n+\tFINALLY_TK block\n+;\n+\n+/* 19.12 Production from 15: Expressions  */\n+primary:\n+\tprimary_no_new_array\n+|\tarray_creation_expression\n+;\n+\n+primary_no_new_array:\n+\tliteral\n+|\tTHIS_TK\n+|\tOP_TK expression CP_TK\n+|\tclass_instance_creation_expression\n+|\tfield_access\n+|\tmethod_invocation\n+|\tarray_access\n+\t/* type DOT_TK CLASS_TK doens't work. So we split the rule\n+\t   'type' into its components. Missing is something for array,\n+\t   which will complete the reference_type part. FIXME */\n+|\tname DOT_TK CLASS_TK\t       /* Added, JDK1.1 class literals */\n+\t\t{ USE_ABSORBER; }\n+|\tprimitive_type DOT_TK CLASS_TK /* Added, JDK1.1 class literals */\n+\t\t{ USE_ABSORBER; }\n+|\tVOID_TK DOT_TK CLASS_TK\t       /* Added, JDK1.1 class literals */\n+        /* Added, JDK1.1 inner classes. Documentation is wrong\n+           refering to a 'ClassName' (class_name) rule that doesn't\n+           exist. Used name instead.  */\n+|\tname DOT_TK THIS_TK\n+\t\t{ USE_ABSORBER; }\n+;\n+\n+class_instance_creation_expression:\n+\tNEW_TK class_type OP_TK argument_list CP_TK\n+|\tNEW_TK class_type OP_TK CP_TK\n+        /* Added, JDK1.1 inner classes but modified to use\n+           'class_type' instead of 'TypeName' (type_name) mentionned\n+           in the documentation but doesn't exist. */\n+|\tNEW_TK class_type OP_TK argument_list CP_TK class_body\n+|\tNEW_TK class_type OP_TK CP_TK class_body         \n+        /* Added, JDK1.1 inner classes, modified to use name or\n+\t   primary instead of primary solely which couldn't work in\n+\t   all situations.  */\n+|\tsomething_dot_new identifier OP_TK CP_TK\n+|\tsomething_dot_new identifier OP_TK CP_TK class_body\n+|\tsomething_dot_new identifier OP_TK argument_list CP_TK\n+|\tsomething_dot_new identifier OP_TK argument_list CP_TK class_body\n+;\n+\n+something_dot_new:\t\t/* Added, not part of the specs. */\n+\tname DOT_TK NEW_TK\n+\t\t{ USE_ABSORBER; }\n+|\tprimary DOT_TK NEW_TK\n+;\n+\n+argument_list:\n+\texpression\n+|\targument_list C_TK expression\n+|\targument_list C_TK error\n+;\n+\n+array_creation_expression:\n+\tNEW_TK primitive_type dim_exprs\n+|\tNEW_TK class_or_interface_type dim_exprs\n+|\tNEW_TK primitive_type dim_exprs dims\n+|\tNEW_TK class_or_interface_type dim_exprs dims\n+        /* Added, JDK1.1 anonymous array. Initial documentation rule\n+           modified */\n+|\tNEW_TK class_or_interface_type dims array_initializer\n+|\tNEW_TK primitive_type dims array_initializer\n+;\n+\n+dim_exprs:\n+\tdim_expr\n+|\tdim_exprs dim_expr\n+;\n+\n+dim_expr:\n+\tOSB_TK expression CSB_TK\n+;\n+\n+dims:\t\t\t\t\n+\tOSB_TK CSB_TK\n+|\tdims OSB_TK CSB_TK\n+;\n+\n+field_access:\n+\tprimary DOT_TK identifier\n+|\tSUPER_TK DOT_TK identifier\n+;\n+\n+method_invocation:\n+\tname OP_TK CP_TK\n+\t\t{ USE_ABSORBER; }\n+|\tname OP_TK argument_list CP_TK\n+\t\t{ USE_ABSORBER; }\n+|\tprimary DOT_TK identifier OP_TK CP_TK\n+|\tprimary DOT_TK identifier OP_TK argument_list CP_TK\n+|\tSUPER_TK DOT_TK identifier OP_TK CP_TK\n+|\tSUPER_TK DOT_TK identifier OP_TK argument_list CP_TK\n+;\n+\n+array_access:\n+\tname OSB_TK expression CSB_TK\n+\t\t{ USE_ABSORBER; }\n+|\tprimary_no_new_array OSB_TK expression CSB_TK\n+;\n+\n+postfix_expression:\n+\tprimary\n+|\tname\n+\t\t{ USE_ABSORBER; }\n+|\tpost_increment_expression\n+|\tpost_decrement_expression\n+;\n+\n+post_increment_expression:\n+\tpostfix_expression INCR_TK\n+;\n+\n+post_decrement_expression:\n+\tpostfix_expression DECR_TK\n+;\n+\n+unary_expression:\n+\tpre_increment_expression\n+|\tpre_decrement_expression\n+|\tPLUS_TK unary_expression\n+|\tMINUS_TK unary_expression\n+|\tunary_expression_not_plus_minus\n+;\n+\n+pre_increment_expression:\n+\tINCR_TK unary_expression\n+;\n+\n+pre_decrement_expression:\n+\tDECR_TK unary_expression\n+;\n+\n+unary_expression_not_plus_minus:\n+\tpostfix_expression\n+|\tNOT_TK unary_expression\n+|\tNEG_TK unary_expression\n+|\tcast_expression\n+;\n+\n+cast_expression:\t\t/* Error handling here is potentially weak */\n+\tOP_TK primitive_type dims CP_TK unary_expression\n+|\tOP_TK primitive_type CP_TK unary_expression\n+|\tOP_TK expression CP_TK unary_expression_not_plus_minus\n+|\tOP_TK name dims CP_TK unary_expression_not_plus_minus\n+;\n+\n+multiplicative_expression:\n+\tunary_expression\n+|\tmultiplicative_expression MULT_TK unary_expression\n+|\tmultiplicative_expression DIV_TK unary_expression\n+|\tmultiplicative_expression REM_TK unary_expression\n+;\n+\n+additive_expression:\n+\tmultiplicative_expression\n+|\tadditive_expression PLUS_TK multiplicative_expression\n+|\tadditive_expression MINUS_TK multiplicative_expression\n+;\n+\n+shift_expression:\n+\tadditive_expression\n+|\tshift_expression LS_TK additive_expression\n+|\tshift_expression SRS_TK additive_expression\n+|\tshift_expression ZRS_TK additive_expression\n+;\n+\n+relational_expression:\n+\tshift_expression\n+|\trelational_expression LT_TK shift_expression\n+|\trelational_expression GT_TK shift_expression\n+|\trelational_expression LTE_TK shift_expression\n+|\trelational_expression GTE_TK shift_expression\n+|\trelational_expression INSTANCEOF_TK reference_type\n+;\n+\n+equality_expression:\n+\trelational_expression\n+|\tequality_expression EQ_TK relational_expression\n+|\tequality_expression NEQ_TK relational_expression\n+;\n+\n+and_expression:\n+\tequality_expression\n+|\tand_expression AND_TK equality_expression\n+;\n+\n+exclusive_or_expression:\n+\tand_expression\n+|\texclusive_or_expression XOR_TK and_expression\n+;\n+\n+inclusive_or_expression:\n+\texclusive_or_expression\n+|\tinclusive_or_expression OR_TK exclusive_or_expression\n+;\n+\n+conditional_and_expression:\n+\tinclusive_or_expression\n+|\tconditional_and_expression BOOL_AND_TK inclusive_or_expression\n+;\n+\n+conditional_or_expression:\n+\tconditional_and_expression\n+|\tconditional_or_expression BOOL_OR_TK conditional_and_expression\n+;\n+\n+conditional_expression:\t\t/* Error handling here is weak */\n+\tconditional_or_expression\n+|\tconditional_or_expression REL_QM_TK expression REL_CL_TK conditional_expression\n+;\n+\n+assignment_expression:\n+\tconditional_expression\n+|\tassignment\n+;\n+\n+assignment:\n+\tleft_hand_side assignment_operator assignment_expression\n+;\n+\n+left_hand_side:\n+\tname\n+\t\t{ USE_ABSORBER; }\n+|\tfield_access\n+|\tarray_access\n+;\n+\n+assignment_operator:\n+\tASSIGN_ANY_TK\n+|\tASSIGN_TK\n+;\n+\n+expression:\n+\tassignment_expression\n+;\n+\n+constant_expression:\n+\texpression\n+;\n+\n+%%\n+\f\n+#include \"lex.c\"\n+\n+/* Create a new parser context */\n+\n+void\n+java_push_parser_context ()\n+{\n+  struct parser_ctxt *new = \n+    (struct parser_ctxt *)xmalloc(sizeof (struct parser_ctxt));\n+\n+  bzero (new, sizeof (struct parser_ctxt));\n+  new->next = ctxp;\n+  ctxp = new;\n+}  \n+\n+/* Actions defined here */\n+\n+static void\n+report_class_declaration (name)\n+     char * name;\n+{\n+  extern int flag_dump_class, flag_list_filename;\n+\n+  if (flag_dump_class)\n+    {\n+      if (!previous_output)\n+\t{\n+\t  if (flag_list_filename)\n+\t    fprintf (out, \"%s: \", input_filename);\n+\t  previous_output = 1;\n+\t}\n+\t\n+      if (package_name)\n+\tfprintf (out, \"%s.%s \", package_name, name);\n+      else\n+\tfprintf (out, \"%s \", name);\n+    }\n+      \n+  current_class = name;\n+}\n+\n+static void\n+report_main_declaration (declarator)\n+     struct method_declarator *declarator;\n+{\n+  extern int flag_find_main;\n+\n+  if (flag_find_main\n+      && modifier_value == 2\n+      && !strcmp (declarator->method_name, \"main\") \n+      && declarator->args \n+      && declarator->args [0] == '[' \n+      && !strcmp( declarator->args+1, \"String\")\n+      && current_class)\n+    {\n+      if (!previous_output)\n+\t{\n+\t  if (package_name)\n+\t    fprintf (out, \"%s.%s \", package_name, current_class);\n+\t  else\n+\t    fprintf (out, current_class);\n+\t  previous_output = 1;\n+\t}\n+    }\n+}\n+\n+/* Reset global status used by the report functions.  */\n+\n+void reset_report ()\n+{\n+  previous_output = 0;\n+  current_class = package_name = NULL;\n+}\n+\n+void\n+yyerror (msg)\n+     char *msg;\n+{\n+}"}, {"sha": "224ae38c7f6118a2c5cd2c07f3231988f4f9ed44", "filename": "gcc/java/parse.c", "status": "added", "additions": 10648, "deletions": 0, "changes": 10648, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=e04a16fbeee9504247e0d069171a627096225028"}, {"sha": "50d5140114914d868b999dd2048867f662145c6f", "filename": "gcc/java/parse.h", "status": "added", "additions": 599, "deletions": 0, "changes": 599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=e04a16fbeee9504247e0d069171a627096225028", "patch": "@@ -0,0 +1,599 @@\n+/* Language parser definitions for the GNU compiler for the Java(TM) language.\n+   Copyright (C) 1997, 1998 Free Software Foundation, Inc.\n+   Contributed by Alexandre Petit-Bianco (apbianco@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+#ifndef JV_LANG_H\n+#define JV_LANG_H\n+\n+#include \"lex.h\"\n+\n+/* Extern global variable declarations */\n+extern int java_error_count;\n+extern struct obstack temporary_obstack;\n+extern struct obstack permanent_obstack;\n+extern int quiet_flag;\n+\n+#ifndef JC1_LITE\n+/* Function extern to java/ */\n+extern int int_fits_type_p PROTO ((tree, tree));\n+extern tree stabilize_reference PROTO ((tree));\n+#endif\n+\n+/* Macros for verbose debug info  */\n+#ifdef  VERBOSE_SKELETON\n+#define RULE( rule ) printf ( \"jv_yacc:%d: rule %s\\n\", lineno, rule )\n+#else\n+#define RULE( rule )\n+#endif\n+\n+#ifdef SOURCE_FRONTEND_DEBUG\n+#undef SOURCE_FRONTEND_DEBUG\n+#define SOURCE_FRONTEND_DEBUG(X)\t\t\t\t\\\n+  {if (!quiet_flag) {printf (\"* \"); printf X; putchar ('\\n');} }\n+#else\n+#define SOURCE_FRONTEND_DEBUG(X)\n+#endif\n+\n+/* Macro for error recovering  */\n+#ifdef YYDEBUG\n+#define RECOVERED     \t\t\t\t\t\\\n+  { if (!quiet_flag) {printf (\"** Recovered\\n\");} }\n+#define DRECOVERED(s) \t\t\t\t\t\t\\\n+  { if (!quiet_flag) {printf (\"** Recovered (%s)\\n\", #s);}}\n+#else\n+#define RECOVERED\n+#define DRECOVERED(s)\n+#endif\n+\n+#define DRECOVER(s) {yyerrok; DRECOVERED(s)}\n+#define RECOVER     {yyerrok; RECOVERED}\n+\n+#define YYERROR_NOW ctxp->java_error_flag = 1\n+#define YYNOT_TWICE if (ctxp->prevent_ese != lineno)\n+\n+/* Accepted modifiers */\n+#define CLASS_MODIFIERS ACC_PUBLIC|ACC_ABSTRACT|ACC_FINAL\n+#define FIELD_MODIFIERS ACC_PUBLIC|ACC_PROTECTED|ACC_PRIVATE|ACC_FINAL| \\\n+                        ACC_STATIC|ACC_TRANSIENT|ACC_VOLATILE\n+#define METHOD_MODIFIERS ACC_PUBLIC|ACC_PROTECTED|ACC_PRIVATE|ACC_ABSTRACT| \\\n+\t\t\t ACC_STATIC|ACC_FINAL|ACC_SYNCHRONIZED|ACC_NATIVE\n+#define INTERFACE_MODIFIERS ACC_PUBLIC|ACC_ABSTRACT\n+#define INTERFACE_METHOD_MODIFIERS ACC_PUBLIC|ACC_ABSTRACT\n+#define INTERFACE_FIELD_MODIFIERS ACC_PUBLIC|ACC_STATIC|ACC_FINAL\n+\n+/* Getting a modifier WFL */\n+#define MODIFIER_WFL(M)   (ctxp->modifier_ctx [(M) - PUBLIC_TK])\n+\n+/* Check on modifiers */\n+#define THIS_MODIFIER_ONLY(f, m, v, count, l)\t\t\t\t\\\n+  if ((f) & (m))\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      tree node = ctxp->modifier_ctx [v];\t\t\t\t\\\n+      if ((l)\t\t\t\t\t\t\t\t\\\n+\t  && ((EXPR_WFL_COLNO (node) > EXPR_WFL_COLNO (l))\t\t\\\n+\t      || (EXPR_WFL_LINENO (node) > EXPR_WFL_LINENO (l))))\t\\\n+        l = node;\t\t\t\t\t\t\t\\\n+      else if (!(l))\t\t\t\t\t\t\t\\\n+        l = node;\t\t\t\t\t\t\t\\\n+      count++;\t\t\t\t\t\t\t\t\\\n+    }\n+\n+#define ABSTRACT_CHECK(flag, v, cl, s)\t\t\t\t\\\n+  if ((flag) & (v))\t\t\t\t\t\t\\\n+    parse_error_context (cl, s \" method can't be abstract\");\n+\n+/* Misc. */\n+#define exit_java_complete_class()\t\t\\\n+  {\t\t\t\t\t\t\\\n+    pop_obstacks ();\t\t\t\t\\\n+    return;\t\t\t\t\t\\\n+  }\n+\n+#define CLASS_OR_INTERFACE(decl, s1, s2)\t\t\t\\\n+   (decl ?\t\t\t\t\t\t\t\\\n+    ((get_access_flags_from_decl (TYPE_NAME (TREE_TYPE (decl)))\t\\\n+      & ACC_INTERFACE) ?\t\t\t\t\t\\\n+     s2 : s1) : ((s1 [0]=='S'|| s1 [0]=='s') ?\t\t\t\\\n+\t\t (s1 [0]=='S' ? \"Supertype\" : \"supertype\") :\t\\\n+\t\t (s1 [0] > 'A' ? \"Type\" : \"type\")))\n+\n+/* Pedantic warning on obsolete modifiers. Note: when cl is NULL,\n+   flags was set artificially, such as for a interface method */\n+#define OBSOLETE_MODIFIER_WARNING(cl, flags, modifier, format, arg)          \\\n+  {                                                                          \\\n+    if ((cl) && ((flags) & (modifier)))\t\t\t\t\t     \\\n+      parse_warning_context (cl,                                             \\\n+\t\t\t     \"Discouraged redundant use of `%s' modifier \"   \\\n+\t\t\t     \"in declaration of \" format,                    \\\n+\t\t\t     java_accstring_lookup (modifier), arg);         \\\n+  }\n+\n+/* Quickly build a temporary pointer on hypothetical type NAME. */\n+#define BUILD_PTR_FROM_NAME(ptr, name)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    ptr = build (POINTER_TYPE, NULL_TREE);\t\\\n+    TYPE_NAME (ptr) = name;\t\t\t\\\n+  }\n+\n+#define INCOMPLETE_TYPE_P(NODE)\t\t\t\t\t\\\n+  ((TREE_CODE (NODE) == TREE_LIST) \t\t\t\t\\\n+   && (TREE_CODE (TREE_PURPOSE (NODE)) == POINTER_TYPE) \t\\\n+   && (TREE_TYPE (TREE_PURPOSE (NODE)) == NULL_TREE))\n+\n+/* Set the EMIT_LINE_NOTE flag of a EXPR_WLF to 1 if debug information\n+   are requested. Works in the context of a parser rule. */\n+#define JAVA_MAYBE_GENERATE_DEBUG_INFO(node)\t\t\\\n+  (debug_info_level != DINFO_LEVEL_NONE ? \t\t\\\n+    EXPR_WFL_EMIT_LINE_NOTE (node) = 1, node : node)\n+\n+/* Types classification, according to the JLS, section 4.2 */\n+#define JFLOAT_TYPE_P(TYPE)      (TREE_CODE ((TYPE)) == REAL_TYPE)\n+#define JINTEGRAL_TYPE_P(TYPE)   ((TREE_CODE ((TYPE)) == INTEGER_TYPE)\t\\\n+\t\t\t\t  || (TREE_CODE ((TYPE)) == CHAR_TYPE))\n+#define JNUMERIC_TYPE_P(TYPE)    (JFLOAT_TYPE_P ((TYPE)) \t\\\n+\t\t\t\t  || JINTEGRAL_TYPE_P ((TYPE)))\n+#define JPRIMITIVE_TYPE_P(TYPE)  (JNUMERIC_TYPE_P ((TYPE)) \t\t   \\\n+\t\t\t\t  || (TREE_CODE ((TYPE)) == BOOLEAN_TYPE))\n+\n+/* Not defined in the LRM */\n+#define JSTRING_TYPE_P(TYPE) ((TYPE) == string_type_node ||\t\t\\\n+\t\t\t (TREE_CODE (TYPE) == POINTER_TYPE &&\t\t\\\n+\t\t\t  TREE_TYPE (op1_type) == string_type_node))\n+\n+#define JREFERENCE_TYPE_P(TYPE) (TREE_CODE (TYPE) == RECORD_TYPE ||\t\\\n+\t\t\t\t (TREE_CODE (TYPE) == POINTER_TYPE &&\t\\\n+\t\t\t\t TREE_CODE (TREE_TYPE (TYPE)) == RECORD_TYPE))\n+\n+/* Other predicate */\n+#define DECL_P(NODE) (NODE && (TREE_CODE (NODE) == PARM_DECL\t\t\\\n+\t\t\t       || TREE_CODE (NODE) == VAR_DECL\t\t\\\n+\t\t\t       || TREE_CODE (NODE) == FIELD_DECL))\n+\n+#define TYPE_INTERFACE_P(TYPE) \t\t\t\t\t\\\n+  (CLASS_P (TYPE) && CLASS_INTERFACE (TYPE_NAME (TYPE)))\n+\n+#define TYPE_CLASS_P(TYPE) (CLASS_P (TYPE) \t\t\t\t\\\n+\t\t\t    && !CLASS_INTERFACE (TYPE_NAME (TYPE))\t\\\n+\t\t\t    && !TYPE_ARRAY_P (TYPE))\n+\n+/* Standard error messages */\n+#define ERROR_CANT_CONVERT_TO_BOOLEAN(OPERATOR, NODE, TYPE)\t\t\\\n+  parse_error_context\t\t\t\t\t\t\t\\\n+    ((OPERATOR), \"Incompatible type for `%s'. Can't convert `%s' to \"\t\\\n+     \"boolean\", operator_string ((NODE)), lang_printable_name ((TYPE)))\n+\n+#define ERROR_CANT_CONVERT_TO_NUMERIC(OPERATOR, NODE, TYPE)\t\t\\\n+  parse_error_context\t\t\t\t\t\t\t\\\n+    ((OPERATOR), \"Incompatible type for `%s'. Can't convert `%s' to \"\t\\\n+     \"numeric type\", operator_string ((NODE)), lang_printable_name ((TYPE)))\n+\n+#define ERROR_CAST_NEEDED_TO_INTEGRAL(OPERATOR, NODE, TYPE)\t\t\\\n+  parse_error_context\t\t\t\t\t\t\t\\\n+    ((OPERATOR), (JPRIMITIVE_TYPE_P (TYPE) ?\t\t\t\t\\\n+     \"Incompatible type for `%s'. Explicit cast needed to convert \"\t\\\n+      \"`%s' to integral\" : \"Incompatible type for `%s'. Can't convert \"\t\\\n+      \"`%s' to integral\"), operator_string ((NODE)),\t\t\t\\\n+      lang_printable_name ((TYPE)))\n+\n+#define ERROR_VARIABLE_NOT_INITIALIZED(WFL, V)\t\t\t\\\n+  parse_error_context\t\t\t\t\t\t\\\n+    ((WFL), \"Variable `%s' may not have been initialized\", \t\\\n+     IDENTIFIER_POINTER (V))\n+\n+/* Definition for loop handling. This Java's own definition of a loop\n+   body. See parse.y for documentation. It's valid once you hold a\n+   loop's body (LOOP_EXPR_BODY) */\n+\n+/* The loop main block is the one hold the condition and the loop body */\n+#define LOOP_EXPR_BODY_MAIN_BLOCK(NODE) TREE_OPERAND (NODE, 0)\n+/* And then there is the loop update block */\n+#define LOOP_EXPR_BODY_UPDATE_BLOCK(NODE) TREE_OPERAND (NODE, 1)\n+\n+/* Inside the loop main block, there is the loop condition and the\n+   loop body. They may be reversed if the loop being described is a\n+   do-while loop. NOTE: if you use a WFL around the EXIT_EXPR so you\n+   can issue debug info for it, the EXIT_EXPR will be one operand\n+   further. */\n+#define LOOP_EXPR_BODY_CONDITION_EXPR(NODE, R) \t\t\t\\\n+  TREE_OPERAND (LOOP_EXPR_BODY_MAIN_BLOCK (NODE), (R ? 1 : 0))\n+\n+/* Here is the labeled block the loop real body is encapsulated in */\n+#define LOOP_EXPR_BODY_LABELED_BODY(NODE, R)\t\t\t\\\n+  TREE_OPERAND (LOOP_EXPR_BODY_MAIN_BLOCK (NODE), (R ? 0 : 1))\n+/* And here is the loop's real body */\n+#define LOOP_EXPR_BODY_BODY_EXPR(NODE, R)\t\t\t\\\n+  LABELED_BLOCK_BODY (LOOP_EXPR_BODY_LABELED_BODY(NODE, R))\n+\n+/* Does a loop have a label ? */\n+#define LOOP_HAS_LABEL_P(LOOP)\t\t\t\t\t\\\n+  (ctxp->current_labeled_block\t\t\t\t\t\\\n+   && LABELED_BLOCK_BODY (ctxp->current_labeled_block) == (LOOP))\n+\n+/* Same operation than the one performed above, but considering the\n+   previous labeled block */\n+#define LOOP_HAS_LABEL_SKIP_P(LOOP)\t\t\t\t\t     \\\n+  (ctxp->current_labeled_block\t\t\t\t\t\t     \\\n+   && TREE_CHAIN (ctxp->current_labeled_block)\t\t\t\t     \\\n+   && LABELED_BLOCK_BODY (TREE_CHAIN (ctxp->current_labeled_block)) == (LOOP))\n+\n+#define PUSH_LABELED_BLOCK(B)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    TREE_CHAIN (B) = ctxp->current_labeled_block;\t\\\n+    ctxp->current_labeled_block = (B);\t\t\t\\\n+  }\n+#define POP_LABELED_BLOCK() \t\t\t\t\t\t\\\n+  ctxp->current_labeled_block = TREE_CHAIN (ctxp->current_labeled_block)\n+\n+#define PUSH_LOOP(L)\t\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    TREE_CHAIN (L) = ctxp->current_loop;\t\\\n+    ctxp->current_loop = (L);\t\t\t\\\n+  }\n+#define POP_LOOP() ctxp->current_loop = TREE_CHAIN (ctxp->current_loop)\n+\n+\n+/* Invocation modes, as returned by invocation_mode (). */\n+enum {\n+  INVOKE_STATIC,\n+  INVOKE_NONVIRTUAL,\n+  INVOKE_SUPER,\n+  INVOKE_INTERFACE,\n+  INVOKE_VIRTUAL,\n+};\n+\n+/* We need the resolution stuff only if we compile jc1 */\n+#ifndef JC1_LITE\n+\n+/* Unresolved type identifiers handling. When we process the source\n+   code, we blindly accept an unknown type identifier and try to\n+   resolve it later. When an unknown type identifier is encountered\n+   and used, we record in a struct jdep element what the incomplete\n+   type is and what it should patch. Later, java_complete_class will\n+   process all classes known to have unresolved type\n+   dependencies. Within each of these classes, this routine will\n+   process unresolved type dependencies (JDEP_TO_RESOLVE), patch what\n+   needs to be patched in the dependent tree node (JDEP_GET_PATCH,\n+   JDEP_APPLY_PATCH) and perform other actions dictated by the context\n+   of the patch (JDEP_KIND). The ideas are: we patch only what needs\n+   to be patched, and with java_complete_class called at the right\n+   time, we will start processing incomplete function bodies tree\n+   nodes with everything external to function's bodies already\n+   completed, it makes things much simpler. */\n+\n+enum jdep_code {\n+  JDEP_NO_PATCH,\t\t/* Must be first */\n+  JDEP_SUPER,\t\t\t/* Patch the type of one type\n+\t\t\t\t   supertype. Requires some check\n+\t\t\t\t   before it's done */\n+  JDEP_FIELD,\t\t\t/* Patch the type of a class field */\n+\n+  /* JDEP_{METHOD,METHOD_RETURN,METHOD_END} to be kept in order */\n+  JDEP_METHOD,\t\t\t/* Mark the beginning of the patching\n+\t\t\t\t   of a method declaration, including\n+\t\t\t\t   it's arguments */\n+  JDEP_METHOD_RETURN,\t\t/* Mark the beginning of the patching\n+\t\t\t\t   of a method declaration. Arguments\n+\t\t\t\t   aren't patched, only the returned\n+\t\t\t\t   type is */\n+  JDEP_METHOD_END,\t\t/* Mark the end of the patching of a\n+\t\t\t\t   method declaration. It indicates\n+\t\t\t\t   that it's time to compute and\n+\t\t\t\t   install a new signature */\n+\n+  JDEP_INTERFACE,\t\t/* Patch the type of a Class/interface\n+\t\t\t\t   extension */\n+  JDEP_VARIABLE,\t\t/* Patch the type of a variable declaration */\n+  JDEP_PARM,\t\t\t/* Patch the type of a parm declaration */\n+  JDEP_TYPE,\t\t\t/* Patch a random tree node type,\n+                                   without the need for any specific\n+                                   actions */\n+};\n+\n+typedef struct _jdep {\n+#ifdef ONLY_INT_FIELDS\n+  int  kind : 8;\t\t/* Type of patch */\n+#else\n+  enum jdep_code kind : 8;\n+#endif\n+\n+  int  flag0 : 1;\t\t/* Some flags */\n+  tree decl;\t\t\t/* Tied decl/or WFL */\n+  tree solv;\t\t\t/* What to solve */\n+  tree wfl;\t\t\t/* Where thing to resolve where found */\n+  tree misc;\t\t\t/* Miscellaneous info (optional). */\n+  tree *patch;\t\t\t/* Address of a location to patch */\n+  struct _jdep *next;\t\t/* Linked list */\n+} jdep;\n+\n+\n+#define JDEP_DECL(J)          ((J)->decl)\n+#define JDEP_DECL_WFL(J)      ((J)->decl)\n+#define JDEP_KIND(J)          ((J)->kind)\n+#define JDEP_SOLV(J)          ((J)->solv)\n+#define JDEP_WFL(J)           ((J)->wfl)\n+#define JDEP_MISC(J)          ((J)->misc)\n+#define JDEP_CLASS(J)         ((J)->class)\n+#define JDEP_APPLY_PATCH(J,P) (*(J)->patch = (P))\n+#define JDEP_GET_PATCH(J)     ((J)->patch)\n+#define JDEP_CHAIN(J)         ((J)->next)\n+#define JDEP_TO_RESOLVE(J)    (TREE_PURPOSE ((J)->solv))\n+#define JDEP_RESOLVED_DECL(J) ((J)->solv ? TREE_PURPOSE ((J)->solv):NULL_TREE)\n+#define JDEP_RESOLVED(J, D)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    TREE_PURPOSE ((J)->solv) = D;\t\t\\\n+    TREE_VALUE ((J)->solv) = (J)->solv;\t\t\\\n+  }\n+#define JDEP_RESOLVED_P(J)    (!(J)->solv || \t\t\t\t\\\n+\t\t\t       TREE_VALUE ((J)->solv) == (J)->solv)\n+\n+typedef struct _jdeplist {\n+  jdep *first;\n+  jdep *last;\n+  struct _jdeplist *next;\n+} jdeplist;\n+static jdeplist *reverse_jdep_list ();\n+\n+#endif /* JC1_LITE */\n+\n+#define CLASSD_FIRST(CD) ((CD)->first)\n+#define CLASSD_LAST(CD)  ((CD)->last)\n+#define CLASSD_CHAIN(CD) ((CD)->next)\n+\n+#define JDEP_INSERT(L,J)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    if (!(L)->first)\t\t\t\t\\\n+      (L)->last = (L)->first = (J);\t\t\\\n+    else\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\tJDEP_CHAIN ((L)->last) = (J);\t\t\\\n+\t(L)->last = (J);\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+  }\n+\n+/* Insert a DECL in the current block */\n+#define BLOCK_CHAIN_DECL(NODE)\t\t\t\t\t\t    \\\n+  {\t\t \t\t\t\t\t\t\t    \\\n+    TREE_CHAIN ((NODE)) = \t\t\t\t\t\t    \\\n+      BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (current_function_decl));\t    \\\n+    BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (current_function_decl)) = (NODE); \\\n+  }\n+\n+#define BLOCK_EXPR_DECLS(NODE)  BLOCK_VARS(NODE)\n+#define BLOCK_EXPR_BODY(NODE)   BLOCK_SUBBLOCKS(NODE)\n+#define BLOCK_EXPR_ORIGIN(NODE) BLOCK_ABSTRACT_ORIGIN(NODE)\n+\n+/* Merge an other line to the source line number of a decl. Used to\n+   remember function's end. */\n+#define DECL_SOURCE_LINE_MERGE(DECL,NO) DECL_SOURCE_LINE(DECL) |= (NO << 16)\n+\n+/* Retrieve those two info separately. */\n+#define DECL_SOURCE_LINE_FIRST(DECL)    (DECL_SOURCE_LINE(DECL) & 0x0000ffff)\n+#define DECL_SOURCE_LINE_LAST(DECL)     (DECL_SOURCE_LINE(DECL) >> 16)\n+\n+/* Build a WFL for expression nodes */\n+#define BUILD_EXPR_WFL(NODE, WFL)\t\t\t\t\t\\\n+  build_expr_wfl ((NODE), input_filename, EXPR_WFL_LINENO ((WFL)), \t\\\n+\t\t  EXPR_WFL_COLNO ((WFL)))\n+\n+#define EXPR_WFL_QUALIFICATION(WFL) TREE_OPERAND ((WFL), 1)\n+#define QUAL_WFL(NODE) TREE_PURPOSE (NODE)\n+#define QUAL_RESOLUTION(NODE) TREE_VALUE (NODE)\n+#define QUAL_DECL_TYPE(NODE) \t\t\t\t\\\n+  (TREE_CODE (TREE_TYPE (NODE)) == POINTER_TYPE ?\t\\\n+   TREE_TYPE (TREE_TYPE (NODE)) : TREE_TYPE (NODE))\n+\n+/* Handy macros for the walk operation */\n+#define COMPLETE_CHECK_OP(NODE, N)\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  TREE_OPERAND ((NODE), (N)) = \t\t\t\t\\\n+    java_complete_tree (TREE_OPERAND ((NODE), (N)));\t\\\n+  if (TREE_OPERAND ((NODE), (N)) == error_mark_node)\t\\\n+    return error_mark_node;\t\t\t\t\\\n+}\n+#define COMPLETE_CHECK_OP_0(NODE) COMPLETE_CHECK_OP(NODE, 0)\n+#define COMPLETE_CHECK_OP_1(NODE) COMPLETE_CHECK_OP(NODE, 1)\n+\n+/* Parser context data structure. */\n+struct parser_ctxt {\n+\n+  char *filename;\t\t    /* Current filename */\n+  FILE *finput;\t\t\t    /* Current file input stream */\n+  struct parser_ctxt *next;\n+\n+  struct java_line *p_line, *c_line; /* Previous and current line */\n+  java_lc elc;\t\t\t     /* Error's line column info */\n+  unicode_t unget_utf8_value;        /* An unget utf8 value */\n+  int ccb_indent;\t\t     /* Keep track of {} indent, lexer */\n+  int first_ccb_indent1;\t     /* First { at ident level 1 */\n+  int last_ccb_indent1;\t\t     /* Last } at ident level 1 */\n+  int parser_ccb_indent;\t     /* Keep track of {} indent, parser */\n+  int osb_number;\t\t     /* Keep track of ['s */\n+  int minus_seen;\t\t     /* Integral literal overflow */\n+  int lineno;\t\t\t    /* Current lineno */\n+  int java_error_flag;\t\t    /* Report error when true */\n+\n+  /* This section is defined only if we compile jc1 */\n+#ifndef JC1_LITE\n+  tree modifier_ctx [11];\t     /* WFL of modifiers */\n+  tree current_class;\t\t    /* Current class */\n+  tree current_function_decl;\t    /* Current function decl, save/restore */\n+\n+  JCF *current_jcf;\t\t    /* CU jcf */\n+\n+  int prevent_ese;\t            /* Prevent expression statement error */\n+  int class_err;\t\t    /* Flag to report certain errors */\n+\n+  int formal_parameter_number;\t    /* Number of parameters found */\n+  int interface_number;\t\t    /* # itfs declared to extend an itf def */\n+\n+  tree package;\t\t\t    /* Defined package ID */\n+\n+  tree  incomplete_class;\t    /* List of non-complete classes */\n+  tree  current_parsed_class;\t    /* Class currently parsed */\n+  tree  class_list;\t\t    /* List of classes in a CU */\n+  jdeplist *classd_list;\t    /* Classe dependencies in a CU */\n+  \n+  tree non_static_initialized;\t    /* List of non static initialized fields */\n+  tree static_initialized;\t    /* List of static non final initialized */\n+\n+  tree import_list;\t\t    /* List of import */\n+  tree import_demand_list;\t    /* List of import on demand */\n+\n+  tree current_loop;\t\t     /* List of the currently nested loops */\n+  tree current_labeled_block;\t     /* List of currently nested\n+\t\t\t\t\tlabeled blocks. */\n+\n+  int pending_block;\t\t     /* Pending block to close */\n+#endif /* JC1_LITE */\n+};\n+\n+/* Functions declarations */\n+#ifndef JC1_LITE\n+static char *java_accstring_lookup PROTO ((int));\n+static void  parse_error PROTO ((char *));\n+static void  redefinition_error PROTO ((char *,tree, tree, tree));\n+static void  check_modifiers PROTO ((char *, int, int));\n+static tree  create_class PROTO ((int, tree, tree, tree));\n+static tree  create_interface PROTO ((int, tree, tree));\n+static tree  find_field PROTO ((tree, tree));\n+static tree lookup_field_wrapper PROTO ((tree, tree));\n+static int   duplicate_declaration_error PROTO ((tree, tree, tree, tree));\n+static void  register_fields PROTO ((int, tree, tree));\n+static tree parser_qualified_classname PROTO ((tree));\n+static int  parser_check_super PROTO ((tree, tree, tree));\n+static int  parser_check_super_interface PROTO ((tree, tree, tree));\n+static void check_modifiers_consistency PROTO ((int));\n+static tree lookup_cl PROTO ((tree));\n+static tree lookup_java_method2 PROTO ((tree, tree, int));\n+static tree method_header PROTO ((int, tree, tree, tree));\n+static tree method_declarator PROTO ((tree, tree));\n+static void parse_error_context VPROTO ((tree cl, char *msg, ...));\n+static void parse_warning_context VPROTO ((tree cl, char *msg, ...));\n+static void complete_class_report_errors PROTO ((jdep *));\n+static int process_imports PROTO ((void));\n+static void read_import_dir PROTO ((tree));\n+static int find_in_imports_on_demand PROTO ((tree));\n+static int find_in_imports PROTO ((tree));\n+static int check_pkg_class_access PROTO ((tree, tree));\n+static tree resolve_class PROTO ((tree, tree, tree));\n+static tree do_resolve_class PROTO ((tree, tree, tree));\n+static void declare_local_variables PROTO ((int, tree, tree));\n+static void source_start_java_method PROTO ((tree));\n+static void source_end_java_method PROTO ((void));\n+static void expand_start_java_method PROTO ((tree));\n+static tree find_name_in_single_imports PROTO ((tree));\n+static void check_abstract_method_header PROTO ((tree));\n+static tree lookup_java_interface_method2 PROTO ((tree, tree));\n+static tree resolve_expression_name PROTO ((tree));\n+static tree maybe_create_class_interface_decl PROTO ((tree, tree, tree));\n+static int check_class_interface_creation PROTO ((int, int, tree, tree, tree, tree));\n+static tree patch_method_invocation_stmt PROTO ((tree, tree, tree, int *));\n+static int breakdown_qualified PROTO ((tree *, tree *, tree));\n+static tree resolve_and_layout PROTO ((tree, tree));\n+static tree resolve_no_layout PROTO ((tree, tree));\n+static int identical_subpath_p PROTO ((tree, tree));\n+static int invocation_mode PROTO ((tree, int));\n+static tree refine_accessible_methods_list PROTO ((int, tree));\n+static tree patch_invoke PROTO ((tree, tree, tree, tree));\n+static tree lookup_method_invoke PROTO ((int, tree, tree, tree, tree));\n+static tree register_incomplete_type PROTO ((int, tree, tree, tree));\n+static tree obtain_incomplete_type PROTO ((tree));\n+static tree java_complete_tree PROTO ((tree));\n+static void java_complete_expand_method PROTO ((tree));\n+static int  unresolved_type_p PROTO ((tree, tree *));\n+static void create_jdep_list PROTO ((struct parser_ctxt *));\n+static tree build_expr_block PROTO ((tree, tree));\n+static tree enter_block PROTO ((void));\n+static tree exit_block PROTO ((void));\n+static tree lookup_name_in_blocks PROTO ((tree));\n+static void maybe_absorb_scoping_blocks PROTO ((void));\n+static tree build_method_invocation PROTO ((tree, tree));\n+static tree build_assignment PROTO ((int, int, tree, tree));\n+static tree build_binop PROTO ((enum tree_code, int, tree, tree));\n+static tree patch_assignment PROTO ((tree, tree, tree ));\n+static tree patch_binop PROTO ((tree, tree, tree));\n+static tree build_unaryop PROTO ((int, int, tree));\n+static tree build_incdec PROTO ((int, int, tree, int));\n+static tree patch_unaryop PROTO ((tree, tree));\n+static tree build_cast PROTO ((int, tree, tree));\n+static tree patch_cast PROTO ((tree, tree, tree));\n+static int valid_ref_assignconv_cast_p PROTO ((tree, tree, int));\n+static int can_cast_to_p PROTO ((tree, tree));\n+static tree build_unresolved_array_type PROTO ((tree));\n+static tree build_array_ref PROTO ((int, tree, tree));\n+static tree patch_array_ref PROTO ((tree, tree, tree));\n+static tree make_qualified_name PROTO ((tree, tree, int));\n+static tree merge_qualified_name PROTO ((tree, tree));\n+static tree make_qualified_primary PROTO ((tree, tree, int));\n+static int resolve_qualified_expression_name PROTO ((tree, tree *, tree *, tree *));\n+static void qualify_ambiguous_name PROTO ((tree));\n+static void maybe_generate_clinit PROTO ((void));\n+static tree resolve_field_access PROTO ((tree, tree *, tree *));\n+static tree build_newarray_node PROTO ((tree, tree, int));\n+static tree patch_newarray PROTO ((tree));\n+static tree resolve_type_during_patch PROTO ((tree));\n+static int not_initialized_as_it_should_p PROTO ((tree));\n+static tree build_this PROTO ((int));\n+static tree build_return PROTO ((int, tree));\n+static tree patch_return PROTO ((tree));\n+static tree maybe_access_field PROTO ((tree, tree, tree));\n+static int complete_function_arguments PROTO ((tree));\n+static int check_for_static_method_reference PROTO ((tree, tree, tree, tree, tree));\n+static int not_accessible_p PROTO ((tree, tree, int));\n+static int class_in_current_package PROTO ((tree));\n+static tree build_if_else_statement PROTO ((int, tree, tree, tree));\n+static tree patch_if_else_statement PROTO ((tree));\n+static tree add_stmt_to_compound PROTO ((tree, tree, tree));\n+static tree patch_exit_expr PROTO ((tree));\n+static tree build_labeled_block PROTO ((int, tree, tree));\n+static tree generate_labeled_block PROTO (());\n+static tree complete_labeled_statement PROTO ((tree, tree));\n+static tree build_bc_statement PROTO ((int, int, tree));\n+static tree patch_bc_statement PROTO ((tree));\n+static tree patch_loop_statement PROTO ((tree));\n+static tree build_new_loop PROTO ((tree));\n+static tree build_loop_body PROTO ((int, tree, int));\n+static tree complete_loop_body PROTO ((int, tree, tree, int));\n+static tree build_debugable_stmt PROTO ((int, tree));\n+static tree complete_for_loop PROTO ((int, tree, tree, tree));\n+\n+void safe_layout_class PROTO ((tree));\n+void java_complete_class PROTO ((void));\n+void java_check_circular_reference PROTO ((void));\n+void java_check_final PROTO ((void));\n+void java_check_methods PROTO ((void));\n+void java_layout_classes PROTO ((void));\n+tree java_method_add_stmt PROTO ((tree, tree));\n+char *java_get_line_col PROTO ((char *, int, int));\n+#endif /* JC1_LITE */\n+\n+/* Always in use, no matter what you compile */\n+\n+void java_push_parser_context PROTO ((void));\n+void java_init_lex PROTO ((void));\n+int yyparse PROTO ((void));\n+int yylex ();\n+void yyerror PROTO ((char *));\n+\n+#endif"}, {"sha": "50a467962fc2fb25eb30e59e095917a3b9202a5e", "filename": "gcc/java/parse.y", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=e04a16fbeee9504247e0d069171a627096225028"}, {"sha": "211e4b69cc47680ea32eb6ad1c735cc42285dab9", "filename": "gcc/java/typeck.c", "status": "added", "additions": 785, "deletions": 0, "changes": 785, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=e04a16fbeee9504247e0d069171a627096225028"}, {"sha": "82a081f079c0476d2faa14307870c759abc98a26", "filename": "gcc/java/verify.c", "status": "added", "additions": 1239, "deletions": 0, "changes": 1239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=e04a16fbeee9504247e0d069171a627096225028"}, {"sha": "39bb06c12517ff665a124e5562484f5618df6731", "filename": "gcc/java/zextract.c", "status": "added", "additions": 350, "deletions": 0, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fzextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fzextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fzextract.c?ref=e04a16fbeee9504247e0d069171a627096225028"}, {"sha": "5d71184139b7b1086ade92a47433b80e4c71c443", "filename": "gcc/java/zipfile.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fzipfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04a16fbeee9504247e0d069171a627096225028/gcc%2Fjava%2Fzipfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fzipfile.h?ref=e04a16fbeee9504247e0d069171a627096225028"}]}