{"sha": "9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "node_id": "C_kwDOANBUbNoAKDllZjU0N2E3YTk5NTIyZGI4ZjBmMDI4YmRlOGZlYmM4ZjFhZDhiYjg", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2022-11-04T13:22:05Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2023-01-05T14:30:00Z"}, "message": "ada: INOX: prototype RFC on String Interpolation\n\nThis patch incorporates a prototype for a new string literal syntax\nwhich supports the use of \"string interpolation,\" where the names\nof variables or expressions can be used directly within the string\nliteral, such that the value of the variable or the expression is\n\"interpolated\" directly into the value of the enclosing string\nupon use at run-time.\n\ngcc/ada/\n\n\t* scans.ads (Tok_Left_Curly_Bracket, Tok_Right_Curly_Bracket)\n\t(Tok_Left_Interpolated_String): Placed in no category since they\n\tdon't fit well in the existing categories. Fix typo in comment.\n\t(Inside_Interpolated_String_Literal): New scan state variable.\n\t* scng.adb (Slit): Scan interpolated string literals,\n\tcontinuations of interpolated string literals and escaped\n\tcharacters found in interpolated string literals.\n\t(Scan): Handle consecutive interpolated expressions. Handle ending\n\tdelimiter placed immediately after an interpolated expression.\n\tHandle string literal placed after interpolated expression. Handle\n\tleft and right curly brackets; when extensions are not allowed\n\tthey are treated as left and right paren; when extensions are\n\tallowed they are handled as delimiters of interpolated string\n\tliterals.\n\t* sinfo.ads (N_Interpolated_String_Literal): New node.\n\t* gen_il-gen-gen_nodes.adb (N_Interpolated_String_Literal): Define\n\tN_String_Literal node.\n\t* gen_il-types.ads (Opt_Type_Enum): Define N_String_Literal as\n\tconcrete node type.\n\t* par-ch2.adb (P_Interpolated_String_Literal): New subprogram.\n\t* par-ch4.adb (P_Simple_Expression): Handle '}' as expression\n\tterminator when scanning an interpolated expression; disable error\n\trecovery machinery for binary operator when we are processing an\n\tinterpolated string literal and reach the expression terminator\n\t'}'.\n\t(P_Primary): Call P_Interpolated_String_Literal when the opening\n\tinterpolated-string-literal delimiter is found (that is, the left\n\tcurly bracket '{').\n\t* par-tchk.adb (T_Right_Curly_Bracket): New subprogram.\n\t* par.adb (P_Interpolated_String_Literal): New declaration.\n\t(T_Right_Curly_Bracket): New declaration.\n\t* sem.adb (Analyze): Call Analyze_Interpolated_String_Literal.\n\t* sem_ch2.ads (Analyze_Interpolated_String_Literal): New\n\tsubprogram\n\t* sem_ch2.adb (Analyze_Interpolated_String_Literal): Likewise.\n\t* sem_util.adb (Is_User_Defined_Literal): Complete mapping of\n\tliteral aspects adding that interpolated string literals have no\n\tcorrespondence with any aspect.\n\t* sem_res.adb (Resolve_Interpolated_String_Literal): New\n\tsubprogram.\n\t(Has_Applicable_User_Defined_Literal): Complete mapping of literal\n\taspects adding that interpolated string literals have no\n\tcorrespondency with any aspect.\n\t* expander.adb (Expand): Add call to\n\tExpand_N_Interpolated_String_Literal.\n\t* exp_util.adb (Insert_Actions): Handle\n\tN_Interpolated_String_Literal nodes; that is, continue climbing.\n\t* exp_ch2.ads (Expand_N_Interpolated_String_Literal): New\n\tsubprogram.\n\t* exp_ch2.adb (Expand_N_Interpolated_String_Literal): Likewise.\n\t* exp_put_image.adb (Build_Elementary_Put_Image_Call): Add missing\n\tconversion to force dispatching call. Required to handle calls to\n\tdescendants.\n\t(Build_String_Put_Image_Call): Do not output string delimiters\n\twhen the put_image call is part of an interpolated string literal.\n\t* rtsfind.ads (RTU_Id): Add RE_Set_Trim_Leading_Spaces.\n\t* sprint.adb (Sprint_Node): Output interpolated string contents.\n\t* libgnat/a-stbubo.adb (Get_UTF_8): Add default value for\n\tTrim_Leading_White_Spaces component in aggregate.\n\t(Buffer_Type_Implementation): Update Trim_Leading_White_Spaces.\n\t* libgnat/a-stbuun.adb (Get_UTF_8): Likewise.\n\t(Buffer_Type_Implementation): Likewise.\n\t* libgnat/a-sttebu.ads (Set_Trim_Leading_Spaces): New subprogram.\n\t(Trim_Leading_Spaces): New subprogram.\n\t(Root_Buffer_Type): Adding Trim_Leading_While_Spaces component.\n\t* libgnat/a-sttebu.adb (procedure Set_Trim_Leading_Spaces): New\n\tsubprogram.\n\t(Trim_Leading_Space): New subprogram.\n\t(Put_UTF_8): Handle Trim_Leading_White_Spaces.\n\t(New_Line): Likewise.\n\t* libgnat/s-putima.ads (Put_Image_String): Adding formal\n\t(with_delimiters).\n\t(Put_Image_Wide_String): Likewise.\n\t(Put_Image_Wide_Wide_String): Likewise.\n\t* libgnat/s-putima.adb (Put_Image_String): Adding support for new\n\tformal.\n\t(Put_Image_Wide_String): Likewise.\n\t(Put_Image_Wide_Wide_String): Likewise.", "tree": {"sha": "c13d0f005e9de9b4d6bed96dff970c446b03a26e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c13d0f005e9de9b4d6bed96dff970c446b03a26e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e45bef1ec6712be5c4566fd0782d58d4b70b3787", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e45bef1ec6712be5c4566fd0782d58d4b70b3787", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e45bef1ec6712be5c4566fd0782d58d4b70b3787"}], "stats": {"total": 766, "additions": 689, "deletions": 77}, "files": [{"sha": "f5cebb7c07b772eeb2778cbf4b948050e3559565", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;        use Aspects;\n with Atree;          use Atree;\n with Checks;         use Checks;\n with Debug;          use Debug;\n@@ -34,9 +35,11 @@ with Exp_Smem;       use Exp_Smem;\n with Exp_Tss;        use Exp_Tss;\n with Exp_Util;       use Exp_Util;\n with Namet;          use Namet;\n+with Nlists;         use Nlists;\n with Nmake;          use Nmake;\n with Opt;            use Opt;\n with Output;         use Output;\n+with Rtsfind;        use Rtsfind;\n with Sem;            use Sem;\n with Sem_Eval;       use Sem_Eval;\n with Sem_Res;        use Sem_Res;\n@@ -47,6 +50,7 @@ with Sinfo.Nodes;    use Sinfo.Nodes;\n with Sinfo.Utils;    use Sinfo.Utils;\n with Sinput;         use Sinput;\n with Snames;         use Snames;\n+with Stand;\n with Tbuild;         use Tbuild;\n \n package body Exp_Ch2 is\n@@ -711,4 +715,117 @@ package body Exp_Ch2 is\n       Analyze_And_Resolve (N, T);\n    end Expand_Renaming;\n \n+   ------------------------------------------\n+   -- Expand_N_Interpolated_String_Literal --\n+   ------------------------------------------\n+\n+   procedure Expand_N_Interpolated_String_Literal (N : Node_Id) is\n+\n+      function Build_Interpolated_String_Image (N : Node_Id) return Node_Id;\n+      --  Build the following Expression_With_Actions node:\n+      --     do\n+      --        Sink : Buffer;\n+      --        [ Set_Trim_Leading_Spaces (Sink); ]\n+      --        Type'Put_Image (Sink, X);\n+      --        { [ Set_Trim_Leading_Spaces (Sink); ]\n+      --          Type'Put_Image (Sink, X); }\n+      --        Result : constant String := Get (Sink);\n+      --        Destroy (Sink);\n+      --     in Result end\n+\n+      -------------------------------------\n+      -- Build_Interpolated_String_Image --\n+      -------------------------------------\n+\n+      function Build_Interpolated_String_Image (N : Node_Id) return Node_Id\n+      is\n+         Loc           : constant Source_Ptr := Sloc (N);\n+         Sink_Entity   : constant Entity_Id  := Make_Temporary (Loc, 'S');\n+         Sink_Decl     : constant Node_Id :=\n+                           Make_Object_Declaration (Loc,\n+                             Defining_Identifier => Sink_Entity,\n+                             Object_Definition =>\n+                               New_Occurrence_Of (RTE (RE_Buffer_Type), Loc));\n+\n+         Get_Id        : constant RE_Id :=\n+                           (if Etype (N) = Stand.Standard_String then\n+                               RE_Get\n+                            elsif Etype (N) = Stand.Standard_Wide_String then\n+                               RE_Wide_Get\n+                            else\n+                               RE_Wide_Wide_Get);\n+\n+         Result_Entity : constant Entity_Id := Make_Temporary (Loc, 'R');\n+         Result_Decl   : constant Node_Id :=\n+                           Make_Object_Declaration (Loc,\n+                             Defining_Identifier => Result_Entity,\n+                             Object_Definition =>\n+                               New_Occurrence_Of (Etype (N), Loc),\n+                             Expression =>\n+                               Make_Function_Call (Loc,\n+                                 Name => New_Occurrence_Of (RTE (Get_Id), Loc),\n+                                 Parameter_Associations => New_List (\n+                                   New_Occurrence_Of (Sink_Entity, Loc))));\n+\n+         Actions  : constant List_Id := New_List;\n+         Elem_Typ : Entity_Id;\n+         Str_Elem : Node_Id;\n+\n+      begin\n+         pragma Assert (Etype (N) /= Stand.Any_String);\n+\n+         Append_To (Actions, Sink_Decl);\n+\n+         Str_Elem := First (Expressions (N));\n+         while Present (Str_Elem) loop\n+            Elem_Typ := Etype (Str_Elem);\n+\n+            --  If the type is numeric or has a specified Integer_Literal or\n+            --  Real_Literal aspect, then prior to invoking Put_Image, the\n+            --  Trim_Leading_Spaces flag is set on the text buffer.\n+\n+            if Is_Numeric_Type (Underlying_Type (Elem_Typ))\n+              or else Has_Aspect (Elem_Typ, Aspect_Integer_Literal)\n+              or else Has_Aspect (Elem_Typ, Aspect_Real_Literal)\n+            then\n+               Append_To (Actions,\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name                   =>\n+                     New_Occurrence_Of\n+                       (RTE (RE_Set_Trim_Leading_Spaces), Loc),\n+                   Parameter_Associations => New_List (\n+                     Convert_To (RTE (RE_Root_Buffer_Type),\n+                       New_Occurrence_Of (Sink_Entity, Loc)),\n+                     New_Occurrence_Of (Stand.Standard_True, Loc))));\n+            end if;\n+\n+            Append_To (Actions,\n+              Make_Attribute_Reference (Loc,\n+                Prefix         => New_Occurrence_Of (Elem_Typ, Loc),\n+                Attribute_Name => Name_Put_Image,\n+                Expressions    => New_List (\n+                  New_Occurrence_Of (Sink_Entity, Loc),\n+                  Duplicate_Subexpr (Str_Elem))));\n+\n+            Next (Str_Elem);\n+         end loop;\n+\n+         Append_To (Actions, Result_Decl);\n+\n+         return Make_Expression_With_Actions (Loc,\n+           Actions    => Actions,\n+           Expression => New_Occurrence_Of (Result_Entity, Loc));\n+      end Build_Interpolated_String_Image;\n+\n+      --  Local variables\n+\n+      Typ : constant Entity_Id := Etype (N);\n+\n+   --  Start of processing for Expand_N_Interpolated_String_Literal\n+\n+   begin\n+      Rewrite (N, Build_Interpolated_String_Image (N));\n+      Analyze_And_Resolve (N, Typ);\n+   end Expand_N_Interpolated_String_Literal;\n+\n end Exp_Ch2;"}, {"sha": "40df79c2a6e55ea37c8e6b168c68a5f0ceb96916", "filename": "gcc/ada/exp_ch2.ads", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fexp_ch2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fexp_ch2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.ads?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -28,8 +28,9 @@\n with Types; use Types;\n package Exp_Ch2 is\n \n-   procedure Expand_N_Expanded_Name  (N : Node_Id);\n-   procedure Expand_N_Identifier     (N : Node_Id);\n-   procedure Expand_N_Real_Literal   (N : Node_Id);\n+   procedure Expand_N_Expanded_Name               (N : Node_Id);\n+   procedure Expand_N_Identifier                  (N : Node_Id);\n+   procedure Expand_N_Interpolated_String_Literal (N : Node_Id);\n+   procedure Expand_N_Real_Literal                (N : Node_Id);\n \n end Exp_Ch2;"}, {"sha": "9c2554fa1e950b4f33285cd551058d07d5350543", "filename": "gcc/ada/exp_put_image.adb", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fexp_put_image.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fexp_put_image.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_put_image.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -338,7 +338,8 @@ package body Exp_Put_Image is\n \n          --  For other elementary types, generate:\n          --\n-         --     Wide_Wide_Put (Sink, U_Type'Wide_Wide_Image (Item));\n+         --     Wide_Wide_Put (Root_Buffer_Type'Class (Sink),\n+         --       U_Type'Wide_Wide_Image (Item));\n          --\n          --  It would be more elegant to do it the other way around (define\n          --  '[[Wide_]Wide_]Image in terms of 'Put_Image). But this is easier\n@@ -362,13 +363,23 @@ package body Exp_Put_Image is\n                 Prefix => New_Occurrence_Of (U_Type, Loc),\n                 Attribute_Name => Name_Wide_Wide_Image,\n                 Expressions => New_List (Relocate_Node (Item)));\n+            Sink_Exp : constant Node_Id :=\n+              Make_Type_Conversion (Loc,\n+                Subtype_Mark =>\n+                  New_Occurrence_Of\n+                    (Class_Wide_Type (RTE (RE_Root_Buffer_Type)), Loc),\n+                Expression   => Relocate_Node (Sink));\n             Put_Call : constant Node_Id :=\n               Make_Procedure_Call_Statement (Loc,\n                 Name =>\n                   New_Occurrence_Of (RTE (RE_Wide_Wide_Put), Loc),\n                 Parameter_Associations => New_List\n-                  (Relocate_Node (Sink), Image));\n+                  (Sink_Exp, Image));\n          begin\n+            --  We have built a dispatching call to handle calls to\n+            --  descendants (since they are not available through rtsfind).\n+            --  Further details available in the body of Put_String_Exp.\n+\n             return Put_Call;\n          end;\n       end if;\n@@ -427,12 +438,28 @@ package body Exp_Put_Image is\n             (Etype (Next_Formal (First_Formal (Libent))),\n              Relocate_Node (Item));\n       begin\n-         return\n-           Make_Procedure_Call_Statement (Loc,\n-             Name => New_Occurrence_Of (Libent, Loc),\n-             Parameter_Associations => New_List (\n-               Relocate_Node (Sink),\n-               Conv));\n+         --  Do not output string delimiters if this is part of an\n+         --  interpolated string literal.\n+\n+         if Nkind (Parent (N)) = N_Expression_With_Actions\n+           and then Nkind (Original_Node (Parent (N)))\n+                      = N_Interpolated_String_Literal\n+         then\n+            return\n+              Make_Procedure_Call_Statement (Loc,\n+                Name => New_Occurrence_Of (Libent, Loc),\n+                Parameter_Associations => New_List (\n+                  Relocate_Node (Sink),\n+                  Conv,\n+                  New_Occurrence_Of (Stand.Standard_False, Loc)));\n+         else\n+            return\n+              Make_Procedure_Call_Statement (Loc,\n+                Name => New_Occurrence_Of (Libent, Loc),\n+                Parameter_Associations => New_List (\n+                  Relocate_Node (Sink),\n+                  Conv));\n+         end if;\n       end;\n    end Build_String_Put_Image_Call;\n "}, {"sha": "74cd99cade22123a8ff40267e32ec964798beae1", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -7913,6 +7913,7 @@ package body Exp_Util is\n                | N_Indexed_Component\n                | N_Integer_Literal\n                | N_Iterator_Specification\n+               | N_Interpolated_String_Literal\n                | N_Itype_Reference\n                | N_Label\n                | N_Loop_Parameter_Specification"}, {"sha": "4687cedc99d27d87a72631a7aafa210481ff8cb7", "filename": "gcc/ada/expander.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fexpander.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fexpander.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpander.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -515,6 +515,9 @@ package body Expander is\n                when N_Variant_Part =>\n                   Expand_N_Variant_Part (N);\n \n+               when N_Interpolated_String_Literal =>\n+                  Expand_N_Interpolated_String_Literal (N);\n+\n                --  For all other node kinds, no expansion activity required\n \n                when others =>"}, {"sha": "fa73b6fecc16348365e8c340448a4a5f2472f6c6", "filename": "gcc/ada/gen_il-gen-gen_nodes.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -441,6 +441,9 @@ begin -- Gen_IL.Gen.Gen_Nodes\n         Sm (Has_Wide_Character, Flag),\n         Sm (Has_Wide_Wide_Character, Flag)));\n \n+   Cc (N_Interpolated_String_Literal, N_Numeric_Or_String_Literal,\n+       (Sy (Expressions, List_Id, Default_No_List)));\n+\n    Cc (N_Explicit_Dereference, N_Subexpr,\n        (Sy (Prefix, Node_Id),\n         Sm (Actual_Designated_Subtype, Node_Id),"}, {"sha": "8634a05cd4f033e4f10da71668bc147b2c660dae", "filename": "gcc/ada/gen_il-types.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fgen_il-types.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fgen_il-types.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-types.ads?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -250,6 +250,7 @@ package Gen_IL.Types is\n       N_Expression_With_Actions,\n       N_If_Expression,\n       N_Indexed_Component,\n+      N_Interpolated_String_Literal,\n       N_Null,\n       N_Qualified_Expression,\n       N_Quantified_Expression,"}, {"sha": "3f4bd90e31fbe226dbfc243c61f6e12ddcda6d2c", "filename": "gcc/ada/libgnat/a-stbubo.adb", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Flibgnat%2Fa-stbubo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Flibgnat%2Fa-stbubo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stbubo.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -29,6 +29,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Ada.Characters.Handling;\n with Ada.Strings.UTF_Encoding.Conversions;\n with Ada.Strings.UTF_Encoding.Strings;\n with Ada.Strings.UTF_Encoding.Wide_Strings;\n@@ -91,9 +92,16 @@ package body Ada.Strings.Text_Buffers.Bounded is\n             --  forget to add corresponding assignment statement below.\n             Dummy : array (1 .. 0) of Buffer_Type (0) :=\n               [others =>\n-                 (Max_Characters => 0, Chars => <>, Indentation => <>,\n-                  Indent_Pending => <>, UTF_8_Length => <>, UTF_8_Column => <>,\n-                  All_7_Bits     => <>, All_8_Bits => <>, Truncated => <>)];\n+                 (Max_Characters            => 0,\n+                  Chars                     => <>,\n+                  Indentation               => <>,\n+                  Indent_Pending            => <>,\n+                  UTF_8_Length              => <>,\n+                  UTF_8_Column              => <>,\n+                  Trim_Leading_White_Spaces => <>,\n+                  All_7_Bits                => <>,\n+                  All_8_Bits                => <>,\n+                  Truncated                 => <>)];\n          begin\n             Buffer.Indentation    := Defaulted.Indentation;\n             Buffer.Indent_Pending := Defaulted.Indent_Pending;\n@@ -131,7 +139,10 @@ package body Ada.Strings.Text_Buffers.Bounded is\n                return;\n             end if;\n \n-            Buffer.All_7_Bits := @ and then Character'Pos (Char) < 128;\n+            Buffer.All_7_Bits :=\n+              @ and then Character'Pos (Char) < 128;\n+            Buffer.Trim_Leading_White_Spaces :=\n+              @ and then Characters.Handling.Is_Space (Char);\n \n             Buffer.UTF_8_Length                                    := @ + 1;\n             Buffer.UTF_8_Column                                    := @ + 1;"}, {"sha": "54449fb90333d3223d5523320034feef6a055494", "filename": "gcc/ada/libgnat/a-stbuun.adb", "status": "modified", "additions": 44, "deletions": 24, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Flibgnat%2Fa-stbuun.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Flibgnat%2Fa-stbuun.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stbuun.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -29,6 +29,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Ada.Characters.Handling;\n with Ada.Unchecked_Deallocation;\n with Ada.Strings.UTF_Encoding.Conversions;\n with Ada.Strings.UTF_Encoding.Strings;\n@@ -104,9 +105,15 @@ package body Ada.Strings.Text_Buffers.Unbounded is\n             --  forget to add corresponding assignment statement below.\n             Dummy : array (1 .. 0) of Buffer_Type :=\n               [others =>\n-                 (Indentation  => <>, Indent_Pending => <>, UTF_8_Length => <>,\n-                  UTF_8_Column => <>, All_7_Bits => <>, All_8_Bits => <>,\n-                  List         => <>, Last_Used => <>)];\n+                 (Indentation               => <>,\n+                  Indent_Pending            => <>,\n+                  UTF_8_Length              => <>,\n+                  UTF_8_Column              => <>,\n+                  All_7_Bits                => <>,\n+                  All_8_Bits                => <>,\n+                  Trim_Leading_White_Spaces => <>,\n+                  List                      => <>,\n+                  Last_Used                 => <>)];\n          begin\n             Buffer.Indentation    := Defaulted.Indentation;\n             Buffer.Indent_Pending := Defaulted.Indent_Pending;\n@@ -140,28 +147,41 @@ package body Ada.Strings.Text_Buffers.Unbounded is\n       procedure Buffer_Type_Implementation (Buffer : in out Buffer_Type) is\n       begin\n          for Char of Item loop\n-            Buffer.All_7_Bits := @ and then Character'Pos (Char) < 128;\n-\n-            if Buffer.Last_Used = Buffer.List.Current_Chunk.Length then\n-               --  Current chunk is full; allocate a new one with doubled size\n-\n-               declare\n-                  Cc     : Chunk renames Buffer.List.Current_Chunk.all;\n-                  Max    : constant Positive := Integer'Last / 2;\n-                  Length : constant Natural  :=\n-                    Integer'Min (Max, 2 * Cc.Length);\n-               begin\n-                  pragma Assert (Cc.Next = null);\n-                  Cc.Next                   := new Chunk (Length => Length);\n-                  Buffer.List.Current_Chunk := Cc.Next;\n-                  Buffer.Last_Used          := 0;\n-               end;\n-            end if;\n \n-            Buffer.UTF_8_Length                                := @ + 1;\n-            Buffer.UTF_8_Column                                := @ + 1;\n-            Buffer.Last_Used                                   := @ + 1;\n-            Buffer.List.Current_Chunk.Chars (Buffer.Last_Used) := Char;\n+            --  The Trim_Leading_Space flag, which can be set prior to calling\n+            --  any of the Put operations, which will cause white space\n+            --  characters to be discarded by any Put operation until a\n+            --  non-white-space character is encountered, at which point\n+            --  the flag will be reset.\n+\n+            if not Buffer.Trim_Leading_White_Spaces\n+              or else not Characters.Handling.Is_Space (Char)\n+            then\n+               Buffer.All_7_Bits := @ and then Character'Pos (Char) < 128;\n+               Buffer.Trim_Leading_White_Spaces := False;\n+\n+               if Buffer.Last_Used = Buffer.List.Current_Chunk.Length then\n+                  --  Current chunk is full; allocate a new one with doubled\n+                  --  size\n+\n+                  declare\n+                     Cc     : Chunk renames Buffer.List.Current_Chunk.all;\n+                     Max    : constant Positive := Integer'Last / 2;\n+                     Length : constant Natural  :=\n+                                Integer'Min (Max, 2 * Cc.Length);\n+                  begin\n+                     pragma Assert (Cc.Next = null);\n+                     Cc.Next                   := new Chunk (Length => Length);\n+                     Buffer.List.Current_Chunk := Cc.Next;\n+                     Buffer.Last_Used          := 0;\n+                  end;\n+               end if;\n+\n+               Buffer.UTF_8_Length                                := @ + 1;\n+               Buffer.UTF_8_Column                                := @ + 1;\n+               Buffer.Last_Used                                   := @ + 1;\n+               Buffer.List.Current_Chunk.Chars (Buffer.Last_Used) := Char;\n+            end if;\n          end loop;\n       end Buffer_Type_Implementation;\n    begin"}, {"sha": "182c1310bdecb6077a108f41c0c44b36660d610f", "filename": "gcc/ada/libgnat/a-sttebu.adb", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Flibgnat%2Fa-sttebu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Flibgnat%2Fa-sttebu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-sttebu.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -54,6 +54,19 @@ package body Ada.Strings.Text_Buffers is\n       Buffer.Indentation := @ - Natural (Amount);\n    end Decrease_Indent;\n \n+   procedure Set_Trim_Leading_Spaces\n+     (Buffer : in out Root_Buffer_Type;\n+      Trim   : Boolean := True) is\n+   begin\n+      Buffer.Trim_Leading_White_Spaces := Trim;\n+   end Set_Trim_Leading_Spaces;\n+\n+   function Trim_Leading_Spaces\n+     (Buffer : Root_Buffer_Type) return Boolean is\n+   begin\n+      return Buffer.Trim_Leading_White_Spaces;\n+   end Trim_Leading_Spaces;\n+\n    package body Output_Mapping is\n       --  Implement indentation in Put_UTF_8 and New_Line.\n       --  Implement other output procedures using Put_UTF_8.\n@@ -91,7 +104,9 @@ package body Ada.Strings.Text_Buffers is\n             return;\n          end if;\n \n-         if Buffer.Indent_Pending then\n+         if Buffer.Indent_Pending\n+           and then not Buffer.Trim_Leading_White_Spaces\n+         then\n             Buffer.Indent_Pending := False;\n             if Buffer.Indentation > 0 then\n                Put_UTF_8_Implementation\n@@ -113,8 +128,9 @@ package body Ada.Strings.Text_Buffers is\n       begin\n          Buffer.Indent_Pending := False; --  just for a moment\n          Put (Buffer, [ASCII.LF]);\n-         Buffer.Indent_Pending := True;\n-         Buffer.UTF_8_Column   := 1;\n+         Buffer.Indent_Pending            := True;\n+         Buffer.UTF_8_Column              := 1;\n+         Buffer.Trim_Leading_White_Spaces := False;\n       end New_Line;\n \n    end Output_Mapping;"}, {"sha": "a97477dec5dabfe8a31bf9d8c221b5078713847b", "filename": "gcc/ada/libgnat/a-sttebu.ads", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Flibgnat%2Fa-sttebu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Flibgnat%2Fa-sttebu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-sttebu.ads?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -64,6 +64,16 @@ is\n       Post'Class => Current_Indent (Buffer) =\n       Current_Indent (Buffer)'Old - Amount;\n \n+   procedure Set_Trim_Leading_Spaces\n+     (Buffer : in out Root_Buffer_Type;\n+      Trim   : Boolean := True) with\n+      Post   => Trim_Leading_Spaces (Buffer) = Trim,\n+      Inline => True;\n+\n+   function Trim_Leading_Spaces\n+     (Buffer : Root_Buffer_Type) return Boolean\n+     with Inline;\n+\n private\n \n    type Root_Buffer_Type is abstract tagged limited record\n@@ -85,6 +95,12 @@ private\n       All_8_Bits : Boolean := True;\n       --  True if all characters seen so far fit in 8 bits\n \n+      Trim_Leading_White_Spaces : Boolean := False;\n+      --  Flag set prior to calling any of the Put operations, which will\n+      --  cause white space characters to be discarded by any Put operation\n+      --  until a non-white-space character is encountered, at which point\n+      --  the flag will be reset.\n+\n    end record;\n \n    generic"}, {"sha": "d3261fd389af069de5be93b12742475478c5faaa", "filename": "gcc/ada/libgnat/s-putima.adb", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Flibgnat%2Fs-putima.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Flibgnat%2Fs-putima.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-putima.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -174,41 +174,67 @@ package body System.Put_Images is\n       Thin_Instance (S, X, \"access protected subprogram\");\n    end Put_Image_Access_Prot_Subp;\n \n-   procedure Put_Image_String (S : in out Sink'Class; X : String) is\n+   procedure Put_Image_String\n+     (S               : in out Sink'Class;\n+      X               : String;\n+      With_Delimiters : Boolean := True) is\n    begin\n-      Put_UTF_8 (S, \"\"\"\");\n+      if With_Delimiters then\n+         Put_UTF_8 (S, \"\"\"\");\n+      end if;\n+\n       for C of X loop\n-         if C = '\"' then\n+         if C = '\"' and then With_Delimiters then\n             Put_UTF_8 (S, \"\"\"\");\n          end if;\n          Put_Character (S, C);\n       end loop;\n-      Put_UTF_8 (S, \"\"\"\");\n+\n+      if With_Delimiters then\n+         Put_UTF_8 (S, \"\"\"\");\n+      end if;\n    end Put_Image_String;\n \n-   procedure Put_Image_Wide_String (S : in out Sink'Class; X : Wide_String) is\n+   procedure Put_Image_Wide_String\n+     (S               : in out Sink'Class;\n+      X               : Wide_String;\n+      With_Delimiters : Boolean := True) is\n    begin\n-      Put_UTF_8 (S, \"\"\"\");\n+      if With_Delimiters then\n+         Put_UTF_8 (S, \"\"\"\");\n+      end if;\n+\n       for C of X loop\n-         if C = '\"' then\n+         if C = '\"' and then With_Delimiters then\n             Put_UTF_8 (S, \"\"\"\");\n          end if;\n          Put_Wide_Character (S, C);\n       end loop;\n-      Put_UTF_8 (S, \"\"\"\");\n+\n+      if With_Delimiters then\n+         Put_UTF_8 (S, \"\"\"\");\n+      end if;\n    end Put_Image_Wide_String;\n \n    procedure Put_Image_Wide_Wide_String\n-     (S : in out Sink'Class; X : Wide_Wide_String) is\n+     (S               : in out Sink'Class;\n+      X               : Wide_Wide_String;\n+      With_Delimiters : Boolean := True) is\n    begin\n-      Put_UTF_8 (S, \"\"\"\");\n+      if With_Delimiters then\n+         Put_UTF_8 (S, \"\"\"\");\n+      end if;\n+\n       for C of X loop\n-         if C = '\"' then\n+         if C = '\"' and then With_Delimiters then\n             Put_UTF_8 (S, \"\"\"\");\n          end if;\n          Put_Wide_Wide_Character (S, C);\n       end loop;\n-      Put_UTF_8 (S, \"\"\"\");\n+\n+      if With_Delimiters then\n+         Put_UTF_8 (S, \"\"\"\");\n+      end if;\n    end Put_Image_Wide_Wide_String;\n \n    procedure Array_Before (S : in out Sink'Class) is"}, {"sha": "1bcec3113d8452a8394569373b36f8aa194c6fc8", "filename": "gcc/ada/libgnat/s-putima.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Flibgnat%2Fs-putima.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Flibgnat%2Fs-putima.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-putima.ads?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -84,10 +84,20 @@ package System.Put_Images with Pure is\n      (S : in out Sink'Class; X : Thin_Pointer);\n    --  For access-to-protected-subprogram types\n \n-   procedure Put_Image_String (S : in out Sink'Class; X : String);\n-   procedure Put_Image_Wide_String (S : in out Sink'Class; X : Wide_String);\n+   procedure Put_Image_String\n+     (S               : in out Sink'Class;\n+      X               : String;\n+      With_Delimiters : Boolean := True);\n+\n+   procedure Put_Image_Wide_String\n+     (S               : in out Sink'Class;\n+      X               : Wide_String;\n+      With_Delimiters : Boolean := True);\n+\n    procedure Put_Image_Wide_Wide_String\n-     (S : in out Sink'Class; X : Wide_Wide_String);\n+     (S               : in out Sink'Class;\n+      X               : Wide_Wide_String;\n+      With_Delimiters : Boolean := True);\n \n    procedure Array_Before (S : in out Sink'Class);\n    procedure Array_Between (S : in out Sink'Class);"}, {"sha": "3d369baa7601c16d928e4f7c9d302fab9f9caf68", "filename": "gcc/ada/par-ch2.adb", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fpar-ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fpar-ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch2.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -199,6 +199,79 @@ package body Ch2 is\n \n    --  Handled by scanner as part of string literal handling (see 2.4)\n \n+   ---------------------------------------\n+   --  2.6  Interpolated String Literal --\n+   ---------------------------------------\n+\n+   --  INTERPOLATED_STRING_LITERAL ::=\n+   --    'f' \"{INTERPOLATED_STRING_ELEMENT}\" {\n+   --        \"{INTERPOLATED_STRING_ELEMENT}\" }\n+\n+   --  INTERPOLATED_STRING_ELEMENT ::=\n+   --     ESCAPED_CHARACTER | INTERPOLATED_EXPRESSION\n+   --   | non_quotation_mark_non_left_brace_GRAPHIC_CHARACTER\n+\n+   --  ESCAPED_CHARACTER ::= '\\GRAPHIC_CHARACTER'\n+\n+   --  INTERPOLATED_EXPRESSION ::= '{' EXPRESSION '}'\n+\n+   --  Interpolated string element and escaped character rules are handled by\n+   --  scanner as part of string literal handling.\n+\n+   -----------------------------------\n+   -- P_Interpolated_String_Literal --\n+   -----------------------------------\n+\n+   function P_Interpolated_String_Literal return Node_Id is\n+      Elements_List : constant List_Id := New_List;\n+      NL_Node       : Node_Id;\n+      String_Node   : Node_Id;\n+\n+   begin\n+      String_Node := New_Node (N_Interpolated_String_Literal, Token_Ptr);\n+      Inside_Interpolated_String_Literal := True;\n+\n+      Scan;   --  past 'f'\n+\n+      if Token /= Tok_String_Literal then\n+         Error_Msg_SC (\"string literal expected\");\n+\n+      else\n+         Append_To (Elements_List, Token_Node);\n+         Scan;  --  past string_literal\n+\n+         while Token in Tok_Left_Curly_Bracket | Tok_String_Literal loop\n+\n+            --  Interpolated expression\n+\n+            if Token = Tok_Left_Curly_Bracket then\n+               Scan; --  past '{'\n+               Append_To (Elements_List, P_Expression);\n+               T_Right_Curly_Bracket;\n+            else\n+               if Prev_Token = Tok_String_Literal then\n+                  NL_Node := New_Node (N_String_Literal, Token_Ptr);\n+                  Set_Has_Wide_Character (NL_Node, False);\n+                  Set_Has_Wide_Wide_Character (NL_Node, False);\n+\n+                  Start_String;\n+                  Store_String_Char (Get_Char_Code (ASCII.LF));\n+                  Set_Strval (NL_Node, End_String);\n+                  Append_To (Elements_List, NL_Node);\n+               end if;\n+\n+               Append_To (Elements_List, Token_Node);\n+               Scan; --  past string_literal\n+            end if;\n+         end loop;\n+      end if;\n+\n+      Inside_Interpolated_String_Literal := False;\n+      Set_Expressions (String_Node, Elements_List);\n+\n+      return String_Node;\n+   end P_Interpolated_String_Literal;\n+\n    ------------------\n    -- 2.7  Comment --\n    ------------------"}, {"sha": "f5a34ec7e9ff8fa93b25b21aba5e410440e9e41b", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -2319,6 +2319,14 @@ package body Ch4 is\n          if Token in Token_Class_Sterm then\n             null;\n \n+         --  Handle '}' as expression terminator of an interpolated\n+         --  expression.\n+\n+         elsif Inside_Interpolated_String_Literal\n+           and then Token = Tok_Right_Curly_Bracket\n+         then\n+            null;\n+\n          --  If we do not have an expression terminator, then complete the\n          --  scan of a simple expression. This code duplicates the code\n          --  found in P_Term and P_Factor.\n@@ -2557,8 +2565,13 @@ package body Ch4 is\n       --  an expression terminator, and is not in Token_Class_Sterm, but\n       --  in this special case we know that the expression is complete.\n \n+      --  We disable this error recovery machinery when we are processing an\n+      --  interpolated string and we reach the expression terminator '}'.\n+\n       if not Token_Is_At_Start_Of_Line\n          and then Token not in Token_Class_Sterm\n+         and then not (Inside_Interpolated_String_Literal\n+                         and then Token = Tok_Right_Curly_Bracket)\n       then\n          --  Normally the right error message is indeed that we expected a\n          --  binary operator, but in the case of being between a right and left\n@@ -2851,6 +2864,9 @@ package body Ch4 is\n             when Tok_Left_Bracket =>\n                return P_Aggregate;\n \n+            when Tok_Left_Interpolated_String =>\n+               return P_Interpolated_String_Literal;\n+\n             --  Allocator\n \n             when Tok_New =>"}, {"sha": "24ab75b1229c39817fb0c0c7f1c042d9946daa4f", "filename": "gcc/ada/par-tchk.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fpar-tchk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fpar-tchk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-tchk.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -402,6 +402,20 @@ package body Tchk is\n       Check_Token (Tok_Record, AP);\n    end T_Record;\n \n+   ---------------------------\n+   -- T_Right_Curly_Bracket --\n+   ---------------------------\n+\n+   procedure T_Right_Curly_Bracket is\n+   begin\n+      if Token = Tok_Right_Curly_Bracket then\n+         Scan;\n+      else\n+         Error_Msg_AP\n+           (\"|missing \"\"'}'\"\"\");\n+      end if;\n+   end T_Right_Curly_Bracket;\n+\n    ---------------------\n    -- T_Right_Bracket --\n    ---------------------"}, {"sha": "5fbdbbd02eb5d20e9ef2da29dc25d6ac0b193c76", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -48,6 +48,7 @@ with Sinfo;          use Sinfo;\n with Sinfo.Nodes;    use Sinfo.Nodes;\n with Sinfo.Utils;    use Sinfo.Utils;\n with Snames;         use Snames;\n+with Stringt;        use Stringt;\n with Style;\n with Stylesw;        use Stylesw;\n with Table;\n@@ -652,6 +653,8 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  if either this is the first occurrence of misuse of this identifier,\n       --  or if Force_Msg is True.\n \n+      function P_Interpolated_String_Literal return Node_Id;\n+\n       function P_Pragmas_Opt return List_Id;\n       --  This function scans for a sequence of pragmas in other than a\n       --  declaration sequence or statement sequence context. All pragmas\n@@ -1238,6 +1241,7 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       procedure T_Range;\n       procedure T_Record;\n       procedure T_Right_Bracket;\n+      procedure T_Right_Curly_Bracket;\n       procedure T_Right_Paren;\n       procedure T_Semicolon;\n       procedure T_Then;"}, {"sha": "86dbb622d64ad121c4d5f8f9e4864444f56b41b1", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -605,6 +605,7 @@ package Rtsfind is\n \n      RE_Root_Buffer_Type,                -- Ada.Strings.Text_Buffers\n      RE_Put_UTF_8,                       -- Ada.Strings.Text_Buffers\n+     RE_Set_Trim_Leading_Spaces,         -- Ada.Strings.Text_Buffers\n      RE_Wide_Wide_Put,                   -- Ada.Strings.Text_Buffers\n \n      RE_Buffer_Type,                     -- Ada.Strings.Text_Buffers.Unbounded\n@@ -2243,6 +2244,7 @@ package Rtsfind is\n \n      RE_Root_Buffer_Type                 => Ada_Strings_Text_Buffers,\n      RE_Put_UTF_8                        => Ada_Strings_Text_Buffers,\n+     RE_Set_Trim_Leading_Spaces          => Ada_Strings_Text_Buffers,\n      RE_Wide_Wide_Put                    => Ada_Strings_Text_Buffers,\n \n      RE_Buffer_Type                      => Ada_Strings_Text_Buffers_Unbounded,"}, {"sha": "c59ff189048e9aababdb74381e0dd79a0e032021", "filename": "gcc/ada/scans.ads", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fscans.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fscans.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscans.ads?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -84,12 +84,19 @@ package Scans is\n       --  Ada 2022 introduces square brackets as delimiters for array and\n       --  container aggregates.\n \n-      Tok_Raise,           -- RAISE\n+      --  The left delimiter token of interpolated strings, and tokens { and }\n+      --  of interpolated expressions are currently placed in no category since\n+      --  they don't fit well in the existing categories.\n+\n+      Tok_Left_Interpolated_String, -- f\"\n+      Tok_Left_Curly_Bracket,       -- {\n+      Tok_Raise,                    -- RAISE\n+      Tok_Right_Curly_Bracket,      -- }\n \n       Tok_Dot,             -- .            Namext\n       Tok_Apostrophe,      -- '            Namext\n \n-      Tok_Left_Bracket,    -- [            Namest\n+      Tok_Left_Bracket,    -- [            Namext\n       Tok_Left_Paren,      -- (            Namext, Consk\n \n       Tok_Delta,           -- DELTA        Atkwd, Sterm, Consk\n@@ -475,6 +482,9 @@ package Scans is\n    --  or aspect. Used to allow/require nonstandard style rules for =>+ with\n    --  -gnatyt.\n \n+   Inside_Interpolated_String_Literal : Boolean := False;\n+   --  True while parsing an interpolated string literal\n+\n    Inside_If_Expression : Nat := 0;\n    --  This is a counter that is set non-zero while scanning out an if\n    --  expression (incremented on entry, decremented on exit). It is used to"}, {"sha": "0ee71fbf043b9511073ee426e9ed5741535a99ca", "filename": "gcc/ada/scng.adb", "status": "modified", "additions": 129, "deletions": 7, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fscng.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fscng.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -1077,8 +1077,20 @@ package body Scng is\n \n          String_Start := Scan_Ptr;\n \n-         Delimiter := Source (Scan_Ptr);\n-         Accumulate_Checksum (Delimiter);\n+         --  Continuation of interpolated string literal\n+\n+         if Inside_Interpolated_String_Literal\n+           and then Prev_Token = Tok_Right_Curly_Bracket\n+         then\n+            Scan_Ptr := Scan_Ptr - 1;\n+            Delimiter := '\"';\n+\n+         --  Common case\n+\n+         else\n+            Delimiter := Source (Scan_Ptr);\n+            Accumulate_Checksum (Delimiter);\n+         end if;\n \n          Start_String;\n          Wide_Character_Found      := False;\n@@ -1094,6 +1106,15 @@ package body Scng is\n                Accumulate_Checksum (C);\n                Scan_Ptr := Scan_Ptr + 1;\n                exit when Source (Scan_Ptr) /= Delimiter;\n+\n+               --  Unlike normal string literals, doubled delimiter has no\n+               --  special significance in interpolated string literals.\n+\n+               if Inside_Interpolated_String_Literal then\n+                  Error_Msg_S\n+                    (\"double quotations not allowed in interpolated string\");\n+               end if;\n+\n                Code := Get_Char_Code (C);\n                Accumulate_Checksum (C);\n                Scan_Ptr := Scan_Ptr + 1;\n@@ -1105,6 +1126,40 @@ package body Scng is\n                   Code := Get_Char_Code (C);\n                   Scan_Ptr := Scan_Ptr + 1;\n \n+               --  Found interpolated expression\n+\n+               elsif Inside_Interpolated_String_Literal\n+                 and then C = '{'\n+               then\n+                  Accumulate_Checksum (C);\n+                  exit;\n+\n+               --  Escaped character in interpolated string literal\n+\n+               elsif Inside_Interpolated_String_Literal\n+                 and then C = '\\'\n+               then\n+                  Accumulate_Checksum (C);\n+                  Scan_Ptr := Scan_Ptr + 1;\n+                  C := Source (Scan_Ptr);\n+                  Accumulate_Checksum (C);\n+                  Scan_Ptr := Scan_Ptr + 1;\n+\n+                  case C is\n+                     when 'a' => Code := Get_Char_Code (ASCII.BEL);\n+                     when 'b' => Code := Get_Char_Code (ASCII.BS);\n+                     when 'f' => Code := Get_Char_Code (ASCII.FF);\n+                     when 'n' => Code := Get_Char_Code (ASCII.LF);\n+                     when 'r' => Code := Get_Char_Code (ASCII.CR);\n+                     when 't' => Code := Get_Char_Code (ASCII.HT);\n+                     when 'v' => Code := Get_Char_Code (ASCII.VT);\n+                     when '0' => Code := Get_Char_Code (ASCII.NUL);\n+                     when '\\' | '\"' | '{' | '}'\n+                              => Code := Get_Char_Code (C);\n+                     when others =>\n+                        Error_Msg_S (\"illegal escaped character\");\n+                  end case;\n+\n                elsif Start_Of_Wide_Character then\n                   Wptr := Scan_Ptr;\n                   Scan_Wide (Source, Scan_Ptr, Code, Err);\n@@ -1234,6 +1289,29 @@ package body Scng is\n       Prev_Token_Ptr := Token_Ptr;\n       Token_Name := Error_Name;\n \n+      if Inside_Interpolated_String_Literal\n+        and then Prev_Token = Tok_Right_Curly_Bracket\n+      then\n+         --  Consecutive interpolated expressions\n+\n+         if Source (Scan_Ptr) = '{' then\n+            null;\n+\n+         --  Ending delimiter placed immediately after interpolated expression\n+\n+         elsif Source (Scan_Ptr) = '\"' then\n+            Scan_Ptr := Scan_Ptr + 1;\n+            Prev_Token := Tok_String_Literal;\n+\n+         --  String literal placed after interpolated expression\n+\n+         else\n+            Slit;\n+            Post_Scan;\n+            return;\n+         end if;\n+      end if;\n+\n       --  The following loop runs more than once only if a format effector\n       --  (tab, vertical tab, form  feed, line feed, carriage return) is\n       --  encountered and skipped, or some error situation, such as an\n@@ -1448,12 +1526,20 @@ package body Scng is\n                return;\n             end if;\n \n-         --  Left brace\n+         --  Left curly bracket, treated as right paren but proper delimiter\n+         --  of interpolated string literals when all extensions are allowed.\n \n          when '{' =>\n-            Error_Msg_S (\"illegal character, replaced by \"\"(\"\"\");\n-            Scan_Ptr := Scan_Ptr + 1;\n-            Token := Tok_Left_Paren;\n+            if All_Extensions_Allowed then\n+               Scan_Ptr := Scan_Ptr + 1;\n+               Token := Tok_Left_Curly_Bracket;\n+\n+            else\n+               Error_Msg_S (\"illegal character, replaced by \"\"(\"\"\");\n+               Scan_Ptr := Scan_Ptr + 1;\n+               Token := Tok_Left_Paren;\n+            end if;\n+\n             return;\n \n          --  Comma\n@@ -1863,7 +1949,7 @@ package body Scng is\n          --  Right bracket or right brace, treated as right paren but proper\n          --  aggregate delimiter in Ada 2022.\n \n-         when ']' | '}' =>\n+         when ']' =>\n             if Ada_Version >= Ada_2022 then\n                Token := Tok_Right_Bracket;\n \n@@ -1875,6 +1961,21 @@ package body Scng is\n             Scan_Ptr := Scan_Ptr + 1;\n             return;\n \n+         --  Right curly bracket, treated as right paren but proper delimiter\n+         --  of interpolated string literals when all extensions are allowed.\n+\n+         when '}' =>\n+            if All_Extensions_Allowed then\n+               Token := Tok_Right_Curly_Bracket;\n+\n+            else\n+               Error_Msg_S (\"illegal character, replaced by \"\")\"\"\");\n+               Token := Tok_Right_Paren;\n+            end if;\n+\n+            Scan_Ptr := Scan_Ptr + 1;\n+            return;\n+\n          --  Slash (can be division operator or first character of not equal)\n \n          when '/' =>\n@@ -2024,6 +2125,16 @@ package body Scng is\n          --  Lower case letters\n \n          when 'a' .. 'z' =>\n+            if All_Extensions_Allowed\n+              and then Source (Scan_Ptr) = 'f'\n+              and then Source (Scan_Ptr + 1) = '\"'\n+            then\n+               Scan_Ptr := Scan_Ptr + 1;\n+               Accumulate_Checksum (Source (Scan_Ptr));\n+               Token := Tok_Left_Interpolated_String;\n+               return;\n+            end if;\n+\n             Name_Len := 1;\n             Underline_Found := False;\n             Name_Buffer (1) := Source (Scan_Ptr);\n@@ -2034,6 +2145,17 @@ package body Scng is\n          --  Upper case letters\n \n          when 'A' .. 'Z' =>\n+            if All_Extensions_Allowed\n+              and then Source (Scan_Ptr) = 'F'\n+              and then Source (Scan_Ptr + 1) = '\"'\n+            then\n+               Error_Msg_S\n+                 (\"delimiter of interpolated string must be in lowercase\");\n+               Scan_Ptr := Scan_Ptr + 1;\n+               Token := Tok_Left_Interpolated_String;\n+               return;\n+            end if;\n+\n             Token_Contains_Uppercase := True;\n             Name_Len := 1;\n             Underline_Found := False;"}, {"sha": "42dca131ddc05575c5fc0ee45709e91f193ab777", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -557,6 +557,9 @@ package body Sem is\n          when N_String_Literal =>\n             Analyze_String_Literal (N);\n \n+         when N_Interpolated_String_Literal =>\n+            Analyze_Interpolated_String_Literal (N);\n+\n          when N_Subprogram_Body =>\n             Analyze_Subprogram_Body (N);\n "}, {"sha": "69a65c481bebd2376d540be5b4b5192a840ff540", "filename": "gcc/ada/sem_ch2.adb", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fsem_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fsem_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch2.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -28,9 +28,11 @@ with Einfo;          use Einfo;\n with Einfo.Utils;    use Einfo.Utils;\n with Ghost;          use Ghost;\n with Namet;          use Namet;\n+with Nlists;         use Nlists;\n with Opt;            use Opt;\n with Restrict;       use Restrict;\n with Rident;         use Rident;\n+with Sem;            use Sem;\n with Sem_Ch8;        use Sem_Ch8;\n with Sem_Dim;        use Sem_Dim;\n with Sinfo;          use Sinfo;\n@@ -119,6 +121,23 @@ package body Sem_Ch2 is\n       Set_Is_Static_Expression (N);\n    end Analyze_Integer_Literal;\n \n+   -----------------------------------------\n+   -- Analyze_Interpolated_String_Literal --\n+   -----------------------------------------\n+\n+   procedure Analyze_Interpolated_String_Literal (N : Node_Id) is\n+      Str_Elem : Node_Id;\n+\n+   begin\n+      Set_Etype (N, Any_String);\n+\n+      Str_Elem := First (Expressions (N));\n+      while Present (Str_Elem) loop\n+         Analyze (Str_Elem);\n+         Next (Str_Elem);\n+      end loop;\n+   end Analyze_Interpolated_String_Literal;\n+\n    --------------------------\n    -- Analyze_Real_Literal --\n    --------------------------"}, {"sha": "fb64a334992f43c18273c37eacd99edc4564ebf6", "filename": "gcc/ada/sem_ch2.ads", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fsem_ch2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fsem_ch2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch2.ads?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -27,11 +27,12 @@ with Types; use Types;\n \n package Sem_Ch2 is\n \n-   procedure Analyze_Character_Literal (N : Node_Id);\n-   procedure Analyze_Identifier        (N : Node_Id);\n-   procedure Analyze_Integer_Literal   (N : Node_Id);\n-   procedure Analyze_Real_Literal      (N : Node_Id);\n-   procedure Analyze_String_Literal    (N : Node_Id);\n+   procedure Analyze_Character_Literal           (N : Node_Id);\n+   procedure Analyze_Identifier                  (N : Node_Id);\n+   procedure Analyze_Integer_Literal             (N : Node_Id);\n+   procedure Analyze_Interpolated_String_Literal (N : Node_Id);\n+   procedure Analyze_Real_Literal                (N : Node_Id);\n+   procedure Analyze_String_Literal              (N : Node_Id);\n \n private\n    pragma Inline (Analyze_Character_Literal);"}, {"sha": "9fcbba7384ef644144e7d3bd781b86f2c2c6a4a6", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -212,6 +212,9 @@ package body Sem_Res is\n    procedure Resolve_Generalized_Indexing      (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Indexed_Component         (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Integer_Literal           (N : Node_Id; Typ : Entity_Id);\n+   procedure Resolve_Interpolated_String_Literal\n+     (N   : Node_Id;\n+      Typ : Entity_Id);\n    procedure Resolve_Logical_Op                (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Membership_Op             (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Null                      (N : Node_Id; Typ : Entity_Id);\n@@ -449,9 +452,10 @@ package body Sem_Res is\n       Loc  : constant Source_Ptr := Sloc (N);\n       Literal_Aspect_Map :\n         constant array (N_Numeric_Or_String_Literal) of Aspect_Id :=\n-          (N_Integer_Literal => Aspect_Integer_Literal,\n-           N_Real_Literal    => Aspect_Real_Literal,\n-           N_String_Literal  => Aspect_String_Literal);\n+          (N_Integer_Literal             => Aspect_Integer_Literal,\n+           N_Interpolated_String_Literal => No_Aspect,\n+           N_Real_Literal                => Aspect_Real_Literal,\n+           N_String_Literal              => Aspect_String_Literal);\n \n       Named_Number_Aspect_Map : constant array (Named_Kind) of Aspect_Id :=\n         (E_Named_Integer => Aspect_Integer_Literal,\n@@ -3437,6 +3441,9 @@ package body Sem_Res is\n             when N_String_Literal =>\n                Resolve_String_Literal            (N, Ctx_Type);\n \n+            when N_Interpolated_String_Literal =>\n+               Resolve_Interpolated_String_Literal (N, Ctx_Type);\n+\n             when N_Target_Name =>\n                Resolve_Target_Name               (N, Ctx_Type);\n \n@@ -9672,6 +9679,35 @@ package body Sem_Res is\n       Eval_Integer_Literal (N);\n    end Resolve_Integer_Literal;\n \n+   -----------------------------------------\n+   -- Resolve_Interpolated_String_Literal --\n+   -----------------------------------------\n+\n+   procedure Resolve_Interpolated_String_Literal (N : Node_Id; Typ : Entity_Id)\n+   is\n+      Str_Elem : Node_Id;\n+\n+   begin\n+      Str_Elem := First (Expressions (N));\n+      pragma Assert (Nkind (Str_Elem) = N_String_Literal);\n+\n+      while Present (Str_Elem) loop\n+\n+         --  Resolve string elements using the context type; for interpolated\n+         --  expressions there is no need to check if their type has a suitable\n+         --  image function because under Ada 2022 all the types have such\n+         --  function available.\n+\n+         if Etype (Str_Elem) = Any_String then\n+            Resolve (Str_Elem, Typ);\n+         end if;\n+\n+         Next (Str_Elem);\n+      end loop;\n+\n+      Set_Etype (N, Typ);\n+   end Resolve_Interpolated_String_Literal;\n+\n    --------------------------------\n    -- Resolve_Intrinsic_Operator --\n    --------------------------------"}, {"sha": "934979e17abea85e97c9feae6c68908a7e86ce2a", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -20785,9 +20785,10 @@ package body Sem_Util is\n    is\n       Literal_Aspect_Map :\n         constant array (N_Numeric_Or_String_Literal) of Aspect_Id :=\n-          (N_Integer_Literal => Aspect_Integer_Literal,\n-           N_Real_Literal    => Aspect_Real_Literal,\n-           N_String_Literal  => Aspect_String_Literal);\n+          (N_Integer_Literal             => Aspect_Integer_Literal,\n+           N_Interpolated_String_Literal => No_Aspect,\n+           N_Real_Literal                => Aspect_Real_Literal,\n+           N_String_Literal              => Aspect_String_Literal);\n \n    begin\n       --  Return True when N is either a literal or a named number and the"}, {"sha": "722e6d4e929202ae8cf4412b12af731b7f50d9d2", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -2618,6 +2618,33 @@ package Sinfo is\n       --  Is_Folded_In_Parser\n       --  plus fields for expression\n \n+      ---------------------------------------\n+      --  2.6  Interpolated String Literal --\n+      ---------------------------------------\n+\n+      --  INTERPOLATED_STRING_LITERAL ::=\n+      --    '{' \"{INTERPOLATED_STRING_ELEMENT}\" {\n+      --        \"{INTERPOLATED_STRING_ELEMENT}\" } '}'\n+\n+      --  INTERPOLATED_STRING_ELEMENT ::=\n+      --      ESCAPED_CHARACTER | INTERPOLATED_EXPRESSION\n+      --    | non_quotation_mark_non_left_brace_GRAPHIC_CHARACTER\n+\n+      --  ESCAPED_CHARACTER ::= '\\GRAPHIC_CHARACTER'\n+\n+      --  INTERPOLATED_EXPRESSION ::= '{' EXPRESSION '}'\n+\n+      --  Most of these syntax rules are omitted as tree nodes to simplify\n+      --  semantic processing. The scanner handles escaped characters as part\n+      --  of processing an interpolated string literal, and the parser stores\n+      --  in the Expressions field of this node a list containing the sequence\n+      --  of string literals and the roots of the interpolated expressions.\n+\n+      --  N_Interpolated_String_Literal\n+      --  Sloc points to literal\n+      --  Expressions\n+      --  plus fields for expression\n+\n       ------------------\n       -- 2.7  Comment --\n       ------------------"}, {"sha": "19a9a43c42685ad5ab5e1ccf6e4394a6c441f708", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ef547a7a99522db8f0f028bde8febc8f1ad8bb8/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=9ef547a7a99522db8f0f028bde8febc8f1ad8bb8", "patch": "@@ -3313,6 +3313,38 @@ package body Sprint is\n             Set_Debug_Sloc;\n             Write_String_Table_Entry (Strval (Node));\n \n+         when N_Interpolated_String_Literal =>\n+            Write_Char ('{');\n+\n+            declare\n+               Str_Elem : Node_Id := First (Expressions (Node));\n+               Is_First : Boolean := True;\n+\n+            begin\n+               while Present (Str_Elem) loop\n+                  if not Is_First then\n+                     Write_Str (\" & \");\n+                  end if;\n+\n+                  if Nkind (Str_Elem) = N_String_Literal then\n+                     Sprint_Node (Str_Elem);\n+\n+                  else\n+                     Write_Char ('\"');\n+                     Write_Char ('{');\n+                     Sprint_Node (Str_Elem);\n+                     Write_Char ('}');\n+                     Write_Char ('\"');\n+                  end if;\n+\n+                  Is_First := False;\n+\n+                  Next (Str_Elem);\n+               end loop;\n+            end;\n+\n+            Write_Char ('}');\n+\n          when N_Subprogram_Body =>\n \n             --  Output extra blank line unless we are in freeze actions"}]}