{"sha": "d951e75dfe83b86dd2c46c7835e03bbf04b29278", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk1MWU3NWRmZTgzYjg2ZGQyYzQ2Yzc4MzVlMDNiYmYwNGIyOTI3OA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2017-03-17T19:28:05Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2017-03-17T19:28:05Z"}, "message": "Fix alignment bugs in std::codecvt_utf16\n\n\t* src/c++11/codecvt.cc (range): Add non-type template parameter and\n\tdefine oerloaded operators for reading and writing code units.\n\t(range<Elem, false>): Define partial specialization for accessing\n\twide characters in potentially unaligned byte ranges.\n\t(ucs2_span(const char16_t*, const char16_t*, ...))\n\t(ucs4_span(const char16_t*, const char16_t*, ...)): Change parameters\n\tto range<const char16_t, false> in order to avoid unaligned reads.\n\t(__codecvt_utf16_base<char16_t>::do_out)\n\t(__codecvt_utf16_base<char32_t>::do_out)\n\t(__codecvt_utf16_base<wchar_t>::do_out): Use range specialization for\n\tunaligned data to avoid unaligned writes.\n\t(__codecvt_utf16_base<char16_t>::do_in)\n\t(__codecvt_utf16_base<char32_t>::do_in)\n\t(__codecvt_utf16_base<wchar_t>::do_in): Likewise for writes. Return\n\terror if there are unprocessable trailing bytes.\n\t(__codecvt_utf16_base<char16_t>::do_length)\n\t(__codecvt_utf16_base<char32_t>::do_length)\n\t(__codecvt_utf16_base<wchar_t>::do_length): Pass arguments of type\n\trange<const char16_t, false> to span functions.\n\t* testsuite/22_locale/codecvt/codecvt_utf16/misaligned.cc: New test.\n\nFrom-SVN: r246245", "tree": {"sha": "0e22d701b0437cb98ff145680df2d6dab207e8bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e22d701b0437cb98ff145680df2d6dab207e8bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d951e75dfe83b86dd2c46c7835e03bbf04b29278", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d951e75dfe83b86dd2c46c7835e03bbf04b29278", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d951e75dfe83b86dd2c46c7835e03bbf04b29278", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d951e75dfe83b86dd2c46c7835e03bbf04b29278/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1a73b0baead836a8d813a6a63459ef87a270bba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1a73b0baead836a8d813a6a63459ef87a270bba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1a73b0baead836a8d813a6a63459ef87a270bba"}], "stats": {"total": 731, "additions": 574, "deletions": 157}, "files": [{"sha": "6b858d1a14ab47a33577f4a40801cc2f7ece1743", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d951e75dfe83b86dd2c46c7835e03bbf04b29278/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d951e75dfe83b86dd2c46c7835e03bbf04b29278/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d951e75dfe83b86dd2c46c7835e03bbf04b29278", "patch": "@@ -1,3 +1,26 @@\n+2017-03-17  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* src/c++11/codecvt.cc (range): Add non-type template parameter and\n+\tdefine oerloaded operators for reading and writing code units.\n+\t(range<Elem, false>): Define partial specialization for accessing\n+\twide characters in potentially unaligned byte ranges.\n+\t(ucs2_span(const char16_t*, const char16_t*, ...))\n+\t(ucs4_span(const char16_t*, const char16_t*, ...)): Change parameters\n+\tto range<const char16_t, false> in order to avoid unaligned reads.\n+\t(__codecvt_utf16_base<char16_t>::do_out)\n+\t(__codecvt_utf16_base<char32_t>::do_out)\n+\t(__codecvt_utf16_base<wchar_t>::do_out): Use range specialization for\n+\tunaligned data to avoid unaligned writes.\n+\t(__codecvt_utf16_base<char16_t>::do_in)\n+\t(__codecvt_utf16_base<char32_t>::do_in)\n+\t(__codecvt_utf16_base<wchar_t>::do_in): Likewise for writes. Return\n+\terror if there are unprocessable trailing bytes.\n+\t(__codecvt_utf16_base<char16_t>::do_length)\n+\t(__codecvt_utf16_base<char32_t>::do_length)\n+\t(__codecvt_utf16_base<wchar_t>::do_length): Pass arguments of type\n+\trange<const char16_t, false> to span functions.\n+\t* testsuite/22_locale/codecvt/codecvt_utf16/misaligned.cc: New test.\n+\n 2017-03-16  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/79980"}, {"sha": "11873397341114f0693946ed46578e5e6f720f08", "filename": "libstdc++-v3/src/c++11/codecvt.cc", "status": "modified", "additions": 235, "deletions": 157, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d951e75dfe83b86dd2c46c7835e03bbf04b29278/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcodecvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d951e75dfe83b86dd2c46c7835e03bbf04b29278/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcodecvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcodecvt.cc?ref=d951e75dfe83b86dd2c46c7835e03bbf04b29278", "patch": "@@ -57,35 +57,142 @@ namespace\n   const char32_t incomplete_mb_character = char32_t(-2);\n   const char32_t invalid_mb_sequence = char32_t(-1);\n \n-  template<typename Elem>\n+  // Utility type for reading and writing code units of type Elem from\n+  // a range defined by a pair of pointers.\n+  template<typename Elem, bool Aligned = true>\n     struct range\n     {\n       Elem* next;\n       Elem* end;\n \n+      // Write a code unit.\n+      range& operator=(Elem e)\n+      {\n+\t*next++ = e;\n+\treturn *this;\n+      }\n+\n+      // Read the next code unit.\n       Elem operator*() const { return *next; }\n \n-      range& operator++() { ++next; return *this; }\n+      // Read the Nth code unit.\n+      Elem operator[](size_t n) const { return next[n]; }\n+\n+      // Move to the next code unit.\n+      range& operator++()\n+      {\n+\t++next;\n+\treturn *this;\n+      }\n+\n+      // Move to the Nth code unit.\n+      range& operator+=(size_t n)\n+      {\n+\tnext += n;\n+\treturn *this;\n+      }\n \n+      // The number of code units remaining.\n       size_t size() const { return end - next; }\n+\n+      // The number of bytes remaining.\n+      size_t nbytes() const { return (const char*)end - (const char*)next; }\n+    };\n+\n+  // This specialization is used when accessing char16_t values through\n+  // pointers to char, which might not be correctly aligned for char16_t.\n+  template<typename Elem>\n+    struct range<Elem, false>\n+    {\n+      using value_type = typename remove_const<Elem>::type;\n+\n+      using char_pointer = typename\n+\tconditional<is_const<Elem>::value, const char*, char*>::type;\n+\n+      char_pointer next;\n+      char_pointer end;\n+\n+      // Write a code unit.\n+      range& operator=(Elem e)\n+      {\n+\tmemcpy(next, &e, sizeof(Elem));\n+\t++*this;\n+\treturn *this;\n+      }\n+\n+      // Read the next code unit.\n+      Elem operator*() const\n+      {\n+\tvalue_type e;\n+\tmemcpy(&e, next, sizeof(Elem));\n+\treturn e;\n+      }\n+\n+      // Read the Nth code unit.\n+      Elem operator[](size_t n) const\n+      {\n+\tvalue_type e;\n+\tmemcpy(&e, next + n * sizeof(Elem), sizeof(Elem));\n+\treturn e;\n+      }\n+\n+      // Move to the next code unit.\n+      range& operator++()\n+      {\n+\tnext += sizeof(Elem);\n+\treturn *this;\n+      }\n+\n+      // Move to the Nth code unit.\n+      range& operator+=(size_t n)\n+      {\n+\tnext += n * sizeof(Elem);\n+\treturn *this;\n+      }\n+\n+      // The number of code units remaining.\n+      size_t size() const { return nbytes() / sizeof(Elem); }\n+\n+      // The number of bytes remaining.\n+      size_t nbytes() const { return end - next; }\n     };\n \n   // Multibyte sequences can have \"header\" consisting of Byte Order Mark\n   const unsigned char utf8_bom[3] = { 0xEF, 0xBB, 0xBF };\n   const unsigned char utf16_bom[2] = { 0xFE, 0xFF };\n   const unsigned char utf16le_bom[2] = { 0xFF, 0xFE };\n \n-  template<size_t N>\n-    inline bool\n-    write_bom(range<char>& to, const unsigned char (&bom)[N])\n+  // Write a BOM (space permitting).\n+  template<typename C, bool A, size_t N>\n+    bool\n+    write_bom(range<C, A>& to, const unsigned char (&bom)[N])\n     {\n-      if (to.size() < N)\n+      static_assert( (N / sizeof(C)) != 0, \"\" );\n+      static_assert( (N % sizeof(C)) == 0, \"\" );\n+\n+      if (to.nbytes() < N)\n \treturn false;\n       memcpy(to.next, bom, N);\n-      to.next += N;\n+      to += (N / sizeof(C));\n       return true;\n     }\n \n+  // Try to read a BOM.\n+  template<typename C, bool A, size_t N>\n+    bool\n+    read_bom(range<C, A>& from, const unsigned char (&bom)[N])\n+    {\n+      static_assert( (N / sizeof(C)) != 0, \"\" );\n+      static_assert( (N % sizeof(C)) == 0, \"\" );\n+\n+      if (from.nbytes() >= N && !memcmp(from.next, bom, N))\n+\t{\n+\t  from += (N / sizeof(C));\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n   // If generate_header is set in mode write out UTF-8 BOM.\n   bool\n   write_utf8_bom(range<char>& to, codecvt_mode mode)\n@@ -97,32 +204,20 @@ namespace\n \n   // If generate_header is set in mode write out the UTF-16 BOM indicated\n   // by whether little_endian is set in mode.\n+  template<bool Aligned>\n   bool\n-  write_utf16_bom(range<char16_t>& to, codecvt_mode mode)\n+  write_utf16_bom(range<char16_t, Aligned>& to, codecvt_mode mode)\n   {\n     if (mode & generate_header)\n     {\n-      if (!to.size())\n-\treturn false;\n-      auto* bom = (mode & little_endian) ? utf16le_bom : utf16_bom;\n-      std::memcpy(to.next, bom, 2);\n-      ++to.next;\n+      if (mode & little_endian)\n+\treturn write_bom(to, utf16le_bom);\n+      else\n+\treturn write_bom(to, utf16_bom);\n     }\n     return true;\n   }\n \n-  template<size_t N>\n-    inline bool\n-    read_bom(range<const char>& from, const unsigned char (&bom)[N])\n-    {\n-      if (from.size() >= N && !memcmp(from.next, bom, N))\n-\t{\n-\t  from.next += N;\n-\t  return true;\n-\t}\n-      return false;\n-    }\n-\n   // If consume_header is set in mode update from.next to after any BOM.\n   void\n   read_utf8_bom(range<const char>& from, codecvt_mode mode)\n@@ -135,21 +230,16 @@ namespace\n   // Otherwise, if *from.next is a UTF-16 BOM increment from.next and then:\n   // - if the UTF-16BE BOM was found unset little_endian in mode, or\n   // - if the UTF-16LE BOM was found set little_endian in mode.\n+  template<bool Aligned>\n   void\n-  read_utf16_bom(range<const char16_t>& from, codecvt_mode& mode)\n+  read_utf16_bom(range<const char16_t, Aligned>& from, codecvt_mode& mode)\n   {\n-    if (mode & consume_header && from.size())\n+    if (mode & consume_header)\n       {\n-\tif (!memcmp(from.next, utf16_bom, 2))\n-\t  {\n-\t    ++from.next;\n-\t    mode &= ~little_endian;\n-\t  }\n-\telse if (!memcmp(from.next, utf16le_bom, 2))\n-\t  {\n-\t    ++from.next;\n-\t    mode |= little_endian;\n-\t  }\n+\tif (read_bom(from, utf16_bom))\n+\t  mode &= ~little_endian;\n+\telse if (read_bom(from, utf16le_bom))\n+\t  mode |= little_endian;\n       }\n   }\n \n@@ -162,11 +252,11 @@ namespace\n     const size_t avail = from.size();\n     if (avail == 0)\n       return incomplete_mb_character;\n-    unsigned char c1 = from.next[0];\n+    unsigned char c1 = from[0];\n     // https://en.wikipedia.org/wiki/UTF-8#Sample_code\n     if (c1 < 0x80)\n     {\n-      ++from.next;\n+      ++from;\n       return c1;\n     }\n     else if (c1 < 0xC2) // continuation or overlong 2-byte sequence\n@@ -175,51 +265,51 @@ namespace\n     {\n       if (avail < 2)\n \treturn incomplete_mb_character;\n-      unsigned char c2 = from.next[1];\n+      unsigned char c2 = from[1];\n       if ((c2 & 0xC0) != 0x80)\n \treturn invalid_mb_sequence;\n       char32_t c = (c1 << 6) + c2 - 0x3080;\n       if (c <= maxcode)\n-\tfrom.next += 2;\n+\tfrom += 2;\n       return c;\n     }\n     else if (c1 < 0xF0) // 3-byte sequence\n     {\n       if (avail < 3)\n \treturn incomplete_mb_character;\n-      unsigned char c2 = from.next[1];\n+      unsigned char c2 = from[1];\n       if ((c2 & 0xC0) != 0x80)\n \treturn invalid_mb_sequence;\n       if (c1 == 0xE0 && c2 < 0xA0) // overlong\n \treturn invalid_mb_sequence;\n-      unsigned char c3 = from.next[2];\n+      unsigned char c3 = from[2];\n       if ((c3 & 0xC0) != 0x80)\n \treturn invalid_mb_sequence;\n       char32_t c = (c1 << 12) + (c2 << 6) + c3 - 0xE2080;\n       if (c <= maxcode)\n-\tfrom.next += 3;\n+\tfrom += 3;\n       return c;\n     }\n     else if (c1 < 0xF5) // 4-byte sequence\n     {\n       if (avail < 4)\n \treturn incomplete_mb_character;\n-      unsigned char c2 = from.next[1];\n+      unsigned char c2 = from[1];\n       if ((c2 & 0xC0) != 0x80)\n \treturn invalid_mb_sequence;\n       if (c1 == 0xF0 && c2 < 0x90) // overlong\n \treturn invalid_mb_sequence;\n       if (c1 == 0xF4 && c2 >= 0x90) // > U+10FFFF\n       return invalid_mb_sequence;\n-      unsigned char c3 = from.next[2];\n+      unsigned char c3 = from[2];\n       if ((c3 & 0xC0) != 0x80)\n \treturn invalid_mb_sequence;\n-      unsigned char c4 = from.next[3];\n+      unsigned char c4 = from[3];\n       if ((c4 & 0xC0) != 0x80)\n \treturn invalid_mb_sequence;\n       char32_t c = (c1 << 18) + (c2 << 12) + (c3 << 6) + c4 - 0x3C82080;\n       if (c <= maxcode)\n-\tfrom.next += 4;\n+\tfrom += 4;\n       return c;\n     }\n     else // > U+10FFFF\n@@ -233,31 +323,31 @@ namespace\n       {\n \tif (to.size() < 1)\n \t  return false;\n-\t*to.next++ = code_point;\n+\tto = code_point;\n       }\n     else if (code_point <= 0x7FF)\n       {\n \tif (to.size() < 2)\n \t  return false;\n-\t*to.next++ = (code_point >> 6) + 0xC0;\n-\t*to.next++ = (code_point & 0x3F) + 0x80;\n+\tto = (code_point >> 6) + 0xC0;\n+\tto = (code_point & 0x3F) + 0x80;\n       }\n     else if (code_point <= 0xFFFF)\n       {\n \tif (to.size() < 3)\n \t  return false;\n-\t*to.next++ = (code_point >> 12) + 0xE0;\n-\t*to.next++ = ((code_point >> 6) & 0x3F) + 0x80;\n-\t*to.next++ = (code_point & 0x3F) + 0x80;\n+\tto = (code_point >> 12) + 0xE0;\n+\tto = ((code_point >> 6) & 0x3F) + 0x80;\n+\tto = (code_point & 0x3F) + 0x80;\n       }\n     else if (code_point <= 0x10FFFF)\n       {\n \tif (to.size() < 4)\n \t  return false;\n-\t*to.next++ = (code_point >> 18) + 0xF0;\n-\t*to.next++ = ((code_point >> 12) & 0x3F) + 0x80;\n-\t*to.next++ = ((code_point >> 6) & 0x3F) + 0x80;\n-\t*to.next++ = (code_point & 0x3F) + 0x80;\n+\tto = (code_point >> 18) + 0xF0;\n+\tto = ((code_point >> 12) & 0x3F) + 0x80;\n+\tto = ((code_point >> 6) & 0x3F) + 0x80;\n+\tto = (code_point & 0x3F) + 0x80;\n       }\n     else\n       return false;\n@@ -298,47 +388,47 @@ namespace\n   // The sequence's endianness is indicated by (mode & little_endian).\n   // Updates from.next if the codepoint is not greater than maxcode.\n   // Returns invalid_mb_sequence, incomplete_mb_character or the code point.\n-  char32_t\n-  read_utf16_code_point(range<const char16_t>& from, unsigned long maxcode,\n-\t\t\tcodecvt_mode mode)\n-  {\n-    const size_t avail = from.size();\n-    if (avail == 0)\n-      return incomplete_mb_character;\n-    int inc = 1;\n-    char32_t c = adjust_byte_order(from.next[0], mode);\n-    if (is_high_surrogate(c))\n-      {\n-\tif (avail < 2)\n-\t  return incomplete_mb_character;\n-\tconst char16_t c2 = adjust_byte_order(from.next[1], mode);\n-\tif (is_low_surrogate(c2))\n-\t  {\n-\t    c = surrogate_pair_to_code_point(c, c2);\n-\t    inc = 2;\n-\t  }\n-\telse\n-\t  return invalid_mb_sequence;\n-      }\n-    else if (is_low_surrogate(c))\n-      return invalid_mb_sequence;\n-    if (c <= maxcode)\n-      from.next += inc;\n-    return c;\n-  }\n+  template<bool Aligned>\n+    char32_t\n+    read_utf16_code_point(range<const char16_t, Aligned>& from,\n+\t\t\t  unsigned long maxcode, codecvt_mode mode)\n+    {\n+      const size_t avail = from.size();\n+      if (avail == 0)\n+\treturn incomplete_mb_character;\n+      int inc = 1;\n+      char32_t c = adjust_byte_order(from[0], mode);\n+      if (is_high_surrogate(c))\n+\t{\n+\t  if (avail < 2)\n+\t    return incomplete_mb_character;\n+\t  const char16_t c2 = adjust_byte_order(from[1], mode);\n+\t  if (is_low_surrogate(c2))\n+\t    {\n+\t      c = surrogate_pair_to_code_point(c, c2);\n+\t      inc = 2;\n+\t    }\n+\t  else\n+\t    return invalid_mb_sequence;\n+\t}\n+      else if (is_low_surrogate(c))\n+\treturn invalid_mb_sequence;\n+      if (c <= maxcode)\n+\tfrom += inc;\n+      return c;\n+    }\n \n-  template<typename C>\n+  template<typename C, bool A>\n   bool\n-  write_utf16_code_point(range<C>& to, char32_t codepoint, codecvt_mode mode)\n+  write_utf16_code_point(range<C, A>& to, char32_t codepoint, codecvt_mode mode)\n   {\n     static_assert(sizeof(C) >= 2, \"a code unit must be at least 16-bit\");\n \n     if (codepoint <= max_single_utf16_unit)\n       {\n \tif (to.size() > 0)\n \t  {\n-\t    *to.next = adjust_byte_order(codepoint, mode);\n-\t    ++to.next;\n+\t    to = adjust_byte_order(codepoint, mode);\n \t    return true;\n \t  }\n       }\n@@ -348,9 +438,8 @@ namespace\n \tconst char32_t LEAD_OFFSET = 0xD800 - (0x10000 >> 10);\n \tchar16_t lead = LEAD_OFFSET + (codepoint >> 10);\n \tchar16_t trail = 0xDC00 + (codepoint & 0x3FF);\n-\tto.next[0] = adjust_byte_order(lead, mode);\n-\tto.next[1] = adjust_byte_order(trail, mode);\n-\tto.next += 2;\n+\tto = adjust_byte_order(lead, mode);\n+\tto = adjust_byte_order(trail, mode);\n \treturn true;\n       }\n     return false;\n@@ -369,7 +458,7 @@ namespace\n \t  return codecvt_base::partial;\n \tif (codepoint > maxcode)\n \t  return codecvt_base::error;\n-\t*to.next++ = codepoint;\n+\tto = codepoint;\n       }\n     return from.size() ? codecvt_base::partial : codecvt_base::ok;\n   }\n@@ -383,19 +472,19 @@ namespace\n       return codecvt_base::partial;\n     while (from.size())\n       {\n-\tconst char32_t c = from.next[0];\n+\tconst char32_t c = from[0];\n \tif (c > maxcode)\n \t  return codecvt_base::error;\n \tif (!write_utf8_code_point(to, c))\n \t  return codecvt_base::partial;\n-\t++from.next;\n+\t++from;\n       }\n     return codecvt_base::ok;\n   }\n \n   // utf16 -> ucs4\n   codecvt_base::result\n-  ucs4_in(range<const char16_t>& from, range<char32_t>& to,\n+  ucs4_in(range<const char16_t, false>& from, range<char32_t>& to,\n           unsigned long maxcode = max_code_point, codecvt_mode mode = {})\n   {\n     read_utf16_bom(from, mode);\n@@ -406,26 +495,26 @@ namespace\n \t  return codecvt_base::partial;\n \tif (codepoint > maxcode)\n \t  return codecvt_base::error;\n-\t*to.next++ = codepoint;\n+\tto = codepoint;\n       }\n     return from.size() ? codecvt_base::partial : codecvt_base::ok;\n   }\n \n   // ucs4 -> utf16\n   codecvt_base::result\n-  ucs4_out(range<const char32_t>& from, range<char16_t>& to,\n+  ucs4_out(range<const char32_t>& from, range<char16_t, false>& to,\n            unsigned long maxcode = max_code_point, codecvt_mode mode = {})\n   {\n     if (!write_utf16_bom(to, mode))\n       return codecvt_base::partial;\n     while (from.size())\n       {\n-\tconst char32_t c = from.next[0];\n+\tconst char32_t c = from[0];\n \tif (c > maxcode)\n \t  return codecvt_base::error;\n \tif (!write_utf16_code_point(to, c, mode))\n \t  return codecvt_base::partial;\n-\t++from.next;\n+\t++from;\n       }\n     return codecvt_base::ok;\n   }\n@@ -443,7 +532,7 @@ namespace\n     read_utf8_bom(from, mode);\n     while (from.size() && to.size())\n       {\n-\tconst char* const first = from.next;\n+\tauto orig = from;\n \tconst char32_t codepoint = read_utf8_code_point(from, maxcode);\n \tif (codepoint == incomplete_mb_character)\n \t  {\n@@ -456,7 +545,7 @@ namespace\n \t  return codecvt_base::error;\n \tif (!write_utf16_code_point(to, codepoint, mode))\n \t  {\n-\t    from.next = first;\n+\t    from = orig; // rewind to previous position\n \t    return codecvt_base::partial;\n \t  }\n       }\n@@ -474,7 +563,7 @@ namespace\n       return codecvt_base::partial;\n     while (from.size())\n       {\n-\tchar32_t c = from.next[0];\n+\tchar32_t c = from[0];\n \tint inc = 1;\n \tif (is_high_surrogate(c))\n \t  {\n@@ -484,7 +573,7 @@ namespace\n \t    if (from.size() < 2)\n \t      return codecvt_base::ok; // stop converting at this point\n \n-\t    const char32_t c2 = from.next[1];\n+\t    const char32_t c2 = from[1];\n \t    if (is_low_surrogate(c2))\n \t      {\n \t\tc = surrogate_pair_to_code_point(c, c2);\n@@ -499,7 +588,7 @@ namespace\n \t  return codecvt_base::error;\n \tif (!write_utf8_code_point(to, c))\n \t  return codecvt_base::partial;\n-\tfrom.next += inc;\n+\tfrom += inc;\n       }\n     return codecvt_base::ok;\n   }\n@@ -548,27 +637,27 @@ namespace\n \n   // ucs2 -> utf16\n   codecvt_base::result\n-  ucs2_out(range<const char16_t>& from, range<char16_t>& to,\n+  ucs2_out(range<const char16_t>& from, range<char16_t, false>& to,\n \t   char32_t maxcode = max_code_point, codecvt_mode mode = {})\n   {\n     if (!write_utf16_bom(to, mode))\n       return codecvt_base::partial;\n     while (from.size() && to.size())\n       {\n-\tchar16_t c = from.next[0];\n+\tchar16_t c = from[0];\n \tif (is_high_surrogate(c))\n \t  return codecvt_base::error;\n \tif (c > maxcode)\n \t  return codecvt_base::error;\n-\t*to.next++ = adjust_byte_order(c, mode);\n-\t++from.next;\n+\tto = adjust_byte_order(c, mode);\n+\t++from;\n       }\n     return from.size() == 0 ? codecvt_base::ok : codecvt_base::partial;\n   }\n \n   // utf16 -> ucs2\n   codecvt_base::result\n-  ucs2_in(range<const char16_t>& from, range<char16_t>& to,\n+  ucs2_in(range<const char16_t, false>& from, range<char16_t>& to,\n \t  char32_t maxcode = max_code_point, codecvt_mode mode = {})\n   {\n     read_utf16_bom(from, mode);\n@@ -581,23 +670,22 @@ namespace\n \t  return codecvt_base::error; // UCS-2 only supports single units.\n \tif (c > maxcode)\n \t  return codecvt_base::error;\n-\t*to.next++ = c;\n+\tto = c;\n       }\n     return from.size() == 0 ? codecvt_base::ok : codecvt_base::partial;\n   }\n \n   const char16_t*\n-  ucs2_span(const char16_t* begin, const char16_t* end, size_t max,\n+  ucs2_span(range<const char16_t, false>& from, size_t max,\n             char32_t maxcode, codecvt_mode mode)\n   {\n-    range<const char16_t> from{ begin, end };\n     read_utf16_bom(from, mode);\n     // UCS-2 only supports characters in the BMP, i.e. one UTF-16 code unit:\n     maxcode = std::min(max_single_utf16_unit, maxcode);\n     char32_t c = 0;\n     while (max-- && c <= maxcode)\n       c = read_utf16_code_point(from, maxcode, mode);\n-    return from.next;\n+    return reinterpret_cast<const char16_t*>(from.next);\n   }\n \n   const char*\n@@ -629,15 +717,14 @@ namespace\n \n   // return pos such that [begin,pos) is valid UCS-4 string no longer than max\n   const char16_t*\n-  ucs4_span(const char16_t* begin, const char16_t* end, size_t max,\n+  ucs4_span(range<const char16_t, false>& from, size_t max,\n             char32_t maxcode = max_code_point, codecvt_mode mode = {})\n   {\n-    range<const char16_t> from{ begin, end };\n     read_utf16_bom(from, mode);\n     char32_t c = 0;\n     while (max-- && c <= maxcode)\n       c = read_utf16_code_point(from, maxcode, mode);\n-    return from.next;\n+    return reinterpret_cast<const char16_t*>(from.next);\n   }\n }\n \n@@ -937,6 +1024,13 @@ __codecvt_utf8_base<char32_t>::do_max_length() const throw()\n }\n \n #ifdef _GLIBCXX_USE_WCHAR_T\n+\n+#if __SIZEOF_WCHAR_T__ == 2\n+static_assert(sizeof(wchar_t) == sizeof(char16_t), \"\");\n+#elif __SIZEOF_WCHAR_T__ == 4\n+static_assert(sizeof(wchar_t) == sizeof(char32_t), \"\");\n+#endif\n+\n // Define members of codecvt_utf8<wchar_t> base class implementation.\n // Converts from UTF-8 to UCS-2 or UCS-4 depending on sizeof(wchar_t).\n \n@@ -1057,10 +1151,7 @@ do_out(state_type&, const intern_type* __from, const intern_type* __from_end,\n        extern_type*& __to_next) const\n {\n   range<const char16_t> from{ __from, __from_end };\n-  range<char16_t> to{\n-    reinterpret_cast<char16_t*>(__to),\n-    reinterpret_cast<char16_t*>(__to_end)\n-  };\n+  range<char16_t, false> to{ __to, __to_end };\n   auto res = ucs2_out(from, to, _M_maxcode, _M_mode);\n   __from_next = from.next;\n   __to_next = reinterpret_cast<char*>(to.next);\n@@ -1083,14 +1174,13 @@ do_in(state_type&, const extern_type* __from, const extern_type* __from_end,\n       intern_type* __to, intern_type* __to_end,\n       intern_type*& __to_next) const\n {\n-  range<const char16_t> from{\n-    reinterpret_cast<const char16_t*>(__from),\n-    reinterpret_cast<const char16_t*>(__from_end)\n-  };\n+  range<const char16_t, false> from{ __from, __from_end };\n   range<char16_t> to{ __to, __to_end };\n   auto res = ucs2_in(from, to, _M_maxcode, _M_mode);\n   __from_next = reinterpret_cast<const char*>(from.next);\n   __to_next = to.next;\n+  if (res == codecvt_base::ok && __from_next != __from_end)\n+    res = codecvt_base::error;\n   return res;\n }\n \n@@ -1107,9 +1197,8 @@ __codecvt_utf16_base<char16_t>::\n do_length(state_type&, const extern_type* __from,\n \t  const extern_type* __end, size_t __max) const\n {\n-  auto next = reinterpret_cast<const char16_t*>(__from);\n-  next = ucs2_span(next, reinterpret_cast<const char16_t*>(__end), __max,\n-\t\t   _M_maxcode, _M_mode);\n+  range<const char16_t, false> from{ __from, __end };\n+  const char16_t* next = ucs2_span(from, __max, _M_maxcode, _M_mode);\n   return reinterpret_cast<const char*>(next) - __from;\n }\n \n@@ -1137,10 +1226,7 @@ do_out(state_type&, const intern_type* __from, const intern_type* __from_end,\n        extern_type*& __to_next) const\n {\n   range<const char32_t> from{ __from, __from_end };\n-  range<char16_t> to{\n-    reinterpret_cast<char16_t*>(__to),\n-    reinterpret_cast<char16_t*>(__to_end)\n-  };\n+  range<char16_t, false> to{ __to, __to_end };\n   auto res = ucs4_out(from, to, _M_maxcode, _M_mode);\n   __from_next = from.next;\n   __to_next = reinterpret_cast<char*>(to.next);\n@@ -1163,14 +1249,13 @@ do_in(state_type&, const extern_type* __from, const extern_type* __from_end,\n       intern_type* __to, intern_type* __to_end,\n       intern_type*& __to_next) const\n {\n-  range<const char16_t> from{\n-    reinterpret_cast<const char16_t*>(__from),\n-    reinterpret_cast<const char16_t*>(__from_end)\n-  };\n+  range<const char16_t, false> from{ __from, __from_end };\n   range<char32_t> to{ __to, __to_end };\n   auto res = ucs4_in(from, to, _M_maxcode, _M_mode);\n   __from_next = reinterpret_cast<const char*>(from.next);\n   __to_next = to.next;\n+  if (res == codecvt_base::ok && __from_next != __from_end)\n+    res = codecvt_base::error;\n   return res;\n }\n \n@@ -1187,9 +1272,8 @@ __codecvt_utf16_base<char32_t>::\n do_length(state_type&, const extern_type* __from,\n \t  const extern_type* __end, size_t __max) const\n {\n-  auto next = reinterpret_cast<const char16_t*>(__from);\n-  next = ucs4_span(next, reinterpret_cast<const char16_t*>(__end), __max,\n-\t\t   _M_maxcode, _M_mode);\n+  range<const char16_t, false> from{ __from, __end };\n+  const char16_t* next = ucs4_span(from, __max, _M_maxcode, _M_mode);\n   return reinterpret_cast<const char*>(next) - __from;\n }\n \n@@ -1217,20 +1301,17 @@ do_out(state_type&, const intern_type* __from, const intern_type* __from_end,\n        extern_type* __to, extern_type* __to_end,\n        extern_type*& __to_next) const\n {\n-  range<char16_t> to{\n-    reinterpret_cast<char16_t*>(__to),\n-    reinterpret_cast<char16_t*>(__to_end)\n-  };\n+  range<char16_t, false> to{ __to, __to_end };\n #if __SIZEOF_WCHAR_T__ == 2\n   range<const char16_t> from{\n     reinterpret_cast<const char16_t*>(__from),\n-    reinterpret_cast<const char16_t*>(__from_end)\n+    reinterpret_cast<const char16_t*>(__from_end),\n   };\n   auto res = ucs2_out(from, to, _M_maxcode, _M_mode);\n #elif __SIZEOF_WCHAR_T__ == 4\n   range<const char32_t> from{\n     reinterpret_cast<const char32_t*>(__from),\n-    reinterpret_cast<const char32_t*>(__from_end)\n+    reinterpret_cast<const char32_t*>(__from_end),\n   };\n   auto res = ucs4_out(from, to, _M_maxcode, _M_mode);\n #else\n@@ -1257,27 +1338,26 @@ do_in(state_type&, const extern_type* __from, const extern_type* __from_end,\n       intern_type* __to, intern_type* __to_end,\n       intern_type*& __to_next) const\n {\n-  range<const char16_t> from{\n-    reinterpret_cast<const char16_t*>(__from),\n-    reinterpret_cast<const char16_t*>(__from_end)\n-  };\n+  range<const char16_t, false> from{ __from, __from_end };\n #if __SIZEOF_WCHAR_T__ == 2\n   range<char16_t> to{\n     reinterpret_cast<char16_t*>(__to),\n-    reinterpret_cast<char16_t*>(__to_end)\n+    reinterpret_cast<char16_t*>(__to_end),\n   };\n   auto res = ucs2_in(from, to, _M_maxcode, _M_mode);\n #elif __SIZEOF_WCHAR_T__ == 4\n   range<char32_t> to{\n     reinterpret_cast<char32_t*>(__to),\n-    reinterpret_cast<char32_t*>(__to_end)\n+    reinterpret_cast<char32_t*>(__to_end),\n   };\n   auto res = ucs4_in(from, to, _M_maxcode, _M_mode);\n #else\n   return codecvt_base::error;\n #endif\n   __from_next = reinterpret_cast<const char*>(from.next);\n   __to_next = reinterpret_cast<wchar_t*>(to.next);\n+  if (res == codecvt_base::ok && __from_next != __from_end)\n+    res = codecvt_base::error;\n   return res;\n }\n \n@@ -1294,13 +1374,11 @@ __codecvt_utf16_base<wchar_t>::\n do_length(state_type&, const extern_type* __from,\n \t  const extern_type* __end, size_t __max) const\n {\n-  auto next = reinterpret_cast<const char16_t*>(__from);\n+  range<const char16_t, false> from{ __from, __end };\n #if __SIZEOF_WCHAR_T__ == 2\n-  next = ucs2_span(next, reinterpret_cast<const char16_t*>(__end), __max,\n-\t\t   _M_maxcode, _M_mode);\n+  const char16_t* next = ucs2_span(from, __max, _M_maxcode, _M_mode);\n #elif __SIZEOF_WCHAR_T__ == 4\n-  next = ucs4_span(next, reinterpret_cast<const char16_t*>(__end), __max,\n-\t\t   _M_maxcode, _M_mode);\n+  const char16_t* next = ucs4_span(from, __max, _M_maxcode, _M_mode);\n #endif\n   return reinterpret_cast<const char*>(next) - __from;\n }"}, {"sha": "d8b9729ed5b2d44fde7cb941640822cd5f566c74", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf16/79980.cc", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d951e75dfe83b86dd2c46c7835e03bbf04b29278/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf16%2F79980.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d951e75dfe83b86dd2c46c7835e03bbf04b29278/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf16%2F79980.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf16%2F79980.cc?ref=d951e75dfe83b86dd2c46c7835e03bbf04b29278", "patch": "@@ -103,6 +103,31 @@ test07()\n   VERIFY( conv.converted() == 5 );\n }\n \n+void\n+test08()\n+{\n+  // Read/write UTF-16 code units from data not correctly aligned for char16_t\n+  Conv<char16_t, 0x10FFFF, std::generate_header> conv;\n+  const char src[] = \"-\\xFE\\xFF\\0\\x61\\xAB\\xCD\";\n+  auto out = conv.from_bytes(src + 1, src + 7);\n+  VERIFY( out[0] == 0x0061 );\n+  VERIFY( out[1] == 0xabcd );\n+  auto bytes = conv.to_bytes(out);\n+  VERIFY( bytes == std::string(src + 1, 6) );\n+}\n+\n+void\n+test09()\n+{\n+  // Read/write UTF-16 code units from data not correctly aligned for char16_t\n+  Conv<char32_t, 0x10FFFF, std::generate_header> conv;\n+  const char src[] = \"-\\xFE\\xFF\\xD8\\x08\\xDF\\x45\";\n+  auto out = conv.from_bytes(src + 1, src + 7);\n+  VERIFY( out == U\"\\U00012345\" );\n+  auto bytes = conv.to_bytes(out);\n+  VERIFY( bytes == std::string(src + 1, 6) );\n+}\n+\n int main()\n {\n   test01();\n@@ -112,4 +137,6 @@ int main()\n   test05();\n   test06();\n   test07();\n+  test08();\n+  test09();\n }"}, {"sha": "0179c184c202c9824426309cb7d7501241162963", "filename": "libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf16/misaligned.cc", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d951e75dfe83b86dd2c46c7835e03bbf04b29278/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf16%2Fmisaligned.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d951e75dfe83b86dd2c46c7835e03bbf04b29278/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf16%2Fmisaligned.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt%2Fcodecvt_utf16%2Fmisaligned.cc?ref=d951e75dfe83b86dd2c46c7835e03bbf04b29278", "patch": "@@ -0,0 +1,289 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <locale>\n+#include <codecvt>\n+#include <testsuite_hooks.h>\n+\n+using std::codecvt_base;\n+using std::codecvt_mode;\n+using std::codecvt_utf16;\n+using std::wstring_convert;\n+using std::mbstate_t;\n+\n+constexpr codecvt_mode\n+operator|(codecvt_mode m1, codecvt_mode m2)\n+{\n+  using underlying = std::underlying_type<codecvt_mode>::type;\n+  return static_cast<codecvt_mode>(static_cast<underlying>(m1) | m2);\n+}\n+\n+// Read/write UTF-16 code units from data not correctly aligned for char16_t\n+\n+void\n+test01()\n+{\n+  mbstate_t st;\n+  constexpr codecvt_mode m = std::consume_header|std::generate_header;\n+  codecvt_utf16<char16_t, 0x10FFFF, m> conv;\n+  const char src[] = \"-\\xFE\\xFF\\0\\x61\\xAB\\xCD\";\n+  const char* const src_end = src + 7;\n+\n+  int len = conv.length(st, src + 1, src_end, 1);\n+  VERIFY( len == 4 );\n+  len = conv.length(st, src + 1, src_end, 2);\n+  VERIFY( len == 6 );\n+\n+  char16_t dst[2];\n+  char16_t* const dst_end = dst + 2;\n+  char16_t* dst_next;\n+  const char* src_cnext;\n+  auto res = conv.in(st, src + 1, src_end, src_cnext, dst, dst_end, dst_next);\n+  VERIFY( res == codecvt_base::ok );\n+  VERIFY( dst[0] == 0x0061 );\n+  VERIFY( dst[1] == 0xabcd );\n+  VERIFY( src_cnext == src_end );\n+  VERIFY( dst_next == dst_end );\n+\n+  char out[sizeof(src)] = { src[0] };\n+  char* const out_end = out + 7;\n+  char* out_next;\n+  const char16_t* dst_cnext;\n+  res = conv.out(st, dst, dst_end, dst_cnext, out + 1, out_end, out_next);\n+  VERIFY( res == codecvt_base::ok );\n+  VERIFY( out_next == out_end );\n+  VERIFY( dst_cnext == dst_end );\n+  VERIFY( out[1] == src[1] );\n+  VERIFY( out[2] == src[2] );\n+  VERIFY( out[3] == src[3] );\n+  VERIFY( out[4] == src[4] );\n+  VERIFY( out[5] == src[5] );\n+  VERIFY( out[6] == src[6] );\n+\n+  codecvt_utf16<char16_t, 0x10FFFF, m|std::little_endian> conv_le;\n+\n+  len = conv_le.length(st, src + 1, src_end, 1);\n+  VERIFY( len == 4 );\n+  len = conv_le.length(st, src + 1, src_end, 2);\n+  VERIFY( len == 6 );\n+\n+  res = conv_le.in(st, src + 1, src_end, src_cnext, dst, dst_end, dst_next);\n+  VERIFY( res == codecvt_base::ok );\n+  VERIFY( dst[0] == 0x0061 );\n+  VERIFY( dst[1] == 0xabcd );\n+  VERIFY( src_cnext == src_end );\n+  VERIFY( dst_next == dst_end );\n+\n+  res = conv_le.out(st, dst, dst_end, dst_cnext, out + 1, out_end, out_next);\n+  VERIFY( res == codecvt_base::ok );\n+  VERIFY( out_next == out_end );\n+  VERIFY( dst_cnext == dst_end );\n+  VERIFY( out[1] == src[2] );\n+  VERIFY( out[2] == src[1] );\n+  VERIFY( out[3] == src[4] );\n+  VERIFY( out[4] == src[3] );\n+  VERIFY( out[5] == src[6] );\n+  VERIFY( out[6] == src[5] );\n+}\n+\n+void\n+test02()\n+{\n+  mbstate_t st;\n+  constexpr codecvt_mode m = std::consume_header|std::generate_header;\n+  codecvt_utf16<char32_t, 0x10FFFF, m> conv;\n+  const char src[] = \"-\\xFE\\xFF\\0\\x61\\xAB\\xCD\\xD8\\x08\\xDF\\x45\";\n+  const char* const src_end = src + 11;\n+\n+  int len = conv.length(st, src + 1, src_end, 1);\n+  VERIFY( len == 4 );\n+  len = conv.length(st, src + 1, src_end, 2);\n+  VERIFY( len == 6 );\n+  len = conv.length(st, src + 1, src_end, -1ul);\n+  VERIFY( len == 10 );\n+\n+  char32_t dst[3];\n+  char32_t* const dst_end = dst + 3;\n+  char32_t* dst_next;\n+  const char* src_cnext;\n+  auto res = conv.in(st, src + 1, src_end, src_cnext, dst, dst_end, dst_next);\n+  VERIFY( res == codecvt_base::ok );\n+  VERIFY( dst[0] == 0x0061 );\n+  VERIFY( dst[1] == 0xabcd );\n+  VERIFY( dst[2] == 0x012345 );\n+  VERIFY( src_cnext == src_end );\n+  VERIFY( dst_next == dst_end );\n+\n+  char out[sizeof(src)] = { src[0] };\n+  char* const out_end = out + 11;\n+  char* out_next;\n+  const char32_t* dst_cnext;\n+  res = conv.out(st, dst, dst_end, dst_cnext, out + 1, out_end, out_next);\n+  VERIFY( res == codecvt_base::ok );\n+  VERIFY( out_next == out_end );\n+  VERIFY( dst_cnext == dst_end );\n+  VERIFY( out[1] == src[1] );\n+  VERIFY( out[2] == src[2] );\n+  VERIFY( out[3] == src[3] );\n+  VERIFY( out[4] == src[4] );\n+  VERIFY( out[5] == src[5] );\n+  VERIFY( out[6] == src[6] );\n+  VERIFY( out[7] == src[7] );\n+  VERIFY( out[8] == src[8] );\n+  VERIFY( out[9] == src[9] );\n+  VERIFY( out[10] == src[10] );\n+\n+  codecvt_utf16<char32_t, 0x10FFFF, m|std::little_endian> conv_le;\n+\n+  len = conv_le.length(st, src + 1, src_end, 1);\n+  VERIFY( len == 4 );\n+  len = conv_le.length(st, src + 1, src_end, 2);\n+  VERIFY( len == 6 );\n+  len = conv.length(st, src + 1, src_end, -1ul);\n+  VERIFY( len == 10 );\n+\n+  res = conv_le.in(st, src + 1, src_end, src_cnext, dst, dst_end, dst_next);\n+  VERIFY( res == codecvt_base::ok );\n+  VERIFY( dst[0] == 0x0061 );\n+  VERIFY( dst[1] == 0xabcd );\n+  VERIFY( dst[2] == 0x012345 );\n+  VERIFY( src_cnext == src_end );\n+  VERIFY( dst_next == dst_end );\n+\n+  res = conv_le.out(st, dst, dst_end, dst_cnext, out + 1, out_end, out_next);\n+  VERIFY( res == codecvt_base::ok );\n+  VERIFY( out_next == out_end );\n+  VERIFY( dst_cnext == dst_end );\n+  VERIFY( out[1] == src[2] );\n+  VERIFY( out[2] == src[1] );\n+  VERIFY( out[3] == src[4] );\n+  VERIFY( out[4] == src[3] );\n+  VERIFY( out[5] == src[6] );\n+  VERIFY( out[6] == src[5] );\n+  VERIFY( out[7] == src[8] );\n+  VERIFY( out[8] == src[7] );\n+  VERIFY( out[9] == src[10] );\n+  VERIFY( out[10] == src[9] );\n+}\n+\n+void\n+test03()\n+{\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  mbstate_t st;\n+  constexpr codecvt_mode m = std::consume_header|std::generate_header;\n+  codecvt_utf16<wchar_t, 0x10FFFF, m> conv;\n+  const char src[] = \"-\\xFE\\xFF\\0\\x61\\xAB\\xCD\\xD8\\x08\\xDF\\x45\";\n+  const size_t in_len = sizeof(wchar_t) == 4 ? 11 : 7;\n+  const size_t out_len = sizeof(wchar_t) == 4 ? 3 : 2;\n+  const char* const src_end = src + in_len;\n+\n+  int len = conv.length(st, src + 1, src_end, 1);\n+  VERIFY( len == 4 );\n+  len = conv.length(st, src + 1, src_end, 2);\n+  VERIFY( len == 6 );\n+  if (sizeof(wchar_t) == 4)\n+  {\n+    len = conv.length(st, src + 1, src_end, -1ul);\n+    VERIFY( len == 10 );\n+  }\n+\n+  wchar_t dst[out_len];\n+  wchar_t* const dst_end = dst + out_len;\n+  wchar_t* dst_next;\n+  const char* src_cnext;\n+  auto res = conv.in(st, src + 1, src_end, src_cnext, dst, dst_end, dst_next);\n+  VERIFY( res == codecvt_base::ok );\n+  VERIFY( dst[0] == 0x0061 );\n+  VERIFY( dst[1] == 0xabcd );\n+  if (sizeof(wchar_t) == 4)\n+    VERIFY( dst[2] == 0x012345 );\n+  VERIFY( src_cnext == src_end );\n+  VERIFY( dst_next == dst_end );\n+\n+  char out[sizeof(src)] = { src[0] };\n+  char* const out_end = out + in_len;\n+  char* out_next;\n+  const wchar_t* dst_cnext;\n+  res = conv.out(st, dst, dst_end, dst_cnext, out + 1, out_end, out_next);\n+  VERIFY( res == codecvt_base::ok );\n+  VERIFY( out_next == out_end );\n+  VERIFY( dst_cnext == dst_end );\n+  VERIFY( out[1] == src[1] );\n+  VERIFY( out[2] == src[2] );\n+  VERIFY( out[3] == src[3] );\n+  VERIFY( out[4] == src[4] );\n+  VERIFY( out[5] == src[5] );\n+  VERIFY( out[6] == src[6] );\n+  if (sizeof(wchar_t) == 4)\n+  {\n+    VERIFY( out[7] == src[7] );\n+    VERIFY( out[8] == src[8] );\n+    VERIFY( out[9] == src[9] );\n+    VERIFY( out[10] == src[10] );\n+  }\n+\n+  codecvt_utf16<wchar_t, 0x10FFFF, m|std::little_endian> conv_le;\n+\n+  len = conv_le.length(st, src + 1, src_end, 1);\n+  VERIFY( len == 4 );\n+  len = conv_le.length(st, src + 1, src_end, 2);\n+  VERIFY( len == 6 );\n+  if (sizeof(wchar_t) == 4)\n+  {\n+    len = conv.length(st, src + 1, src_end, -1ul);\n+    VERIFY( len == 10 );\n+  }\n+\n+  res = conv_le.in(st, src + 1, src_end, src_cnext, dst, dst_end, dst_next);\n+  VERIFY( res == codecvt_base::ok );\n+  VERIFY( dst[0] == 0x0061 );\n+  VERIFY( dst[1] == 0xabcd );\n+  if (sizeof(wchar_t) == 4)\n+    VERIFY( dst[2] == 0x012345 );\n+  VERIFY( src_cnext == src_end );\n+  VERIFY( dst_next == dst_end );\n+\n+  res = conv_le.out(st, dst, dst_end, dst_cnext, out + 1, out_end, out_next);\n+  VERIFY( res == codecvt_base::ok );\n+  VERIFY( out_next == out_end );\n+  VERIFY( dst_cnext == dst_end );\n+  VERIFY( out[1] == src[2] );\n+  VERIFY( out[2] == src[1] );\n+  VERIFY( out[3] == src[4] );\n+  VERIFY( out[4] == src[3] );\n+  VERIFY( out[5] == src[6] );\n+  VERIFY( out[6] == src[5] );\n+  if (sizeof(wchar_t) == 4)\n+  {\n+    VERIFY( out[7] == src[8] );\n+    VERIFY( out[8] == src[7] );\n+    VERIFY( out[9] == src[10] );\n+    VERIFY( out[10] == src[9] );\n+  }\n+#endif\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}]}