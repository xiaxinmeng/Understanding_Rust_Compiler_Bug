{"sha": "ea725d4524db8fa1bc593f5aa0e297a01ab721f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE3MjVkNDUyNGRiOGZhMWJjNTkzZjVhYTBlMjk3YTAxYWI3MjFmMw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2006-03-10T23:09:23Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2006-03-10T23:09:23Z"}, "message": "re PR libgcj/25713 (GZIPOutputStream bad checksum)\n\nlibjava\n\tPR libgcj/25713:\n\t* java/util/zip/Deflater.java (flush): New method.\n\t* sources.am, Makefile.in: Rebuilt.\n\t* java/util/zip/DeflaterOutputStream.java: Removed.\n\t* java/util/zip/InflaterInputStream.java: Likewise.\n\t* java/util/zip/GZIPInputStream.java: Likewise.\n\t* java/util/zip/GZIPOutputStream.java: Likewise.\nlibjava/classpath\n\tFor PR libgcj/25713:\n\t* java/util/zip/InflaterInputStream.java (read): Replaced with\n\tlibgcj implementation.\n\nFrom-SVN: r111949", "tree": {"sha": "61a09663191772cb2d0e99154b48b8c6269350fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61a09663191772cb2d0e99154b48b8c6269350fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea725d4524db8fa1bc593f5aa0e297a01ab721f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea725d4524db8fa1bc593f5aa0e297a01ab721f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea725d4524db8fa1bc593f5aa0e297a01ab721f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea725d4524db8fa1bc593f5aa0e297a01ab721f3/comments", "author": null, "committer": null, "parents": [{"sha": "21f9ec0c6ad431e25e58dee6b9e6759ab7e74003", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21f9ec0c6ad431e25e58dee6b9e6759ab7e74003", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21f9ec0c6ad431e25e58dee6b9e6759ab7e74003"}], "stats": {"total": 926, "additions": 48, "deletions": 878}, "files": [{"sha": "d08bf1612c82940d51e3b8dfe455b634b6208f7c", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea725d4524db8fa1bc593f5aa0e297a01ab721f3/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea725d4524db8fa1bc593f5aa0e297a01ab721f3/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ea725d4524db8fa1bc593f5aa0e297a01ab721f3", "patch": "@@ -1,3 +1,13 @@\n+2006-03-10  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR libgcj/25713:\n+\t* java/util/zip/Deflater.java (flush): New method.\n+\t* sources.am, Makefile.in: Rebuilt.\n+\t* java/util/zip/DeflaterOutputStream.java: Removed.\n+\t* java/util/zip/InflaterInputStream.java: Likewise.\n+\t* java/util/zip/GZIPInputStream.java: Likewise.\n+\t* java/util/zip/GZIPOutputStream.java: Likewise.\n+\n 2006-03-10  Andreas Tobler  <a.tobler@schweiz.ch>\n \n \t* include/powerpc-signal.h: Fix typo in comment."}, {"sha": "d784fcc740f8ebb24647b4bb7d805faf31d90ebf", "filename": "libjava/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea725d4524db8fa1bc593f5aa0e297a01ab721f3/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea725d4524db8fa1bc593f5aa0e297a01ab721f3/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=ea725d4524db8fa1bc593f5aa0e297a01ab721f3", "patch": "@@ -4254,11 +4254,11 @@ classpath/java/util/zip/CheckedOutputStream.java \\\n classpath/java/util/zip/Checksum.java \\\n classpath/java/util/zip/DataFormatException.java \\\n java/util/zip/Deflater.java \\\n-java/util/zip/DeflaterOutputStream.java \\\n-java/util/zip/GZIPInputStream.java \\\n-java/util/zip/GZIPOutputStream.java \\\n+classpath/java/util/zip/DeflaterOutputStream.java \\\n+classpath/java/util/zip/GZIPInputStream.java \\\n+classpath/java/util/zip/GZIPOutputStream.java \\\n java/util/zip/Inflater.java \\\n-java/util/zip/InflaterInputStream.java \\\n+classpath/java/util/zip/InflaterInputStream.java \\\n classpath/java/util/zip/ZipConstants.java \\\n classpath/java/util/zip/ZipEntry.java \\\n classpath/java/util/zip/ZipException.java \\"}, {"sha": "f1901eb17cf25f0fd9f3670b06f3fd5b2907c2b0", "filename": "libjava/classpath/ChangeLog.gcj", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea725d4524db8fa1bc593f5aa0e297a01ab721f3/libjava%2Fclasspath%2FChangeLog.gcj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea725d4524db8fa1bc593f5aa0e297a01ab721f3/libjava%2Fclasspath%2FChangeLog.gcj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog.gcj?ref=ea725d4524db8fa1bc593f5aa0e297a01ab721f3", "patch": "@@ -1,3 +1,9 @@\n+2006-03-10  Tom Tromey  <tromey@redhat.com>\n+\n+\tFor PR libgcj/25713:\n+\t* java/util/zip/InflaterInputStream.java (read): Replaced with\n+\tlibgcj implementation.\n+\n 2006-03-08  Tom Tromey  <tromey@redhat.com>\n \n \tPR libgcj/24183:"}, {"sha": "08c1fd75a0bc2493c6b095a801fc824ea317b165", "filename": "libjava/classpath/java/util/zip/InflaterInputStream.java", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea725d4524db8fa1bc593f5aa0e297a01ab721f3/libjava%2Fclasspath%2Fjava%2Futil%2Fzip%2FInflaterInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea725d4524db8fa1bc593f5aa0e297a01ab721f3/libjava%2Fclasspath%2Fjava%2Futil%2Fzip%2FInflaterInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Futil%2Fzip%2FInflaterInputStream.java?ref=ea725d4524db8fa1bc593f5aa0e297a01ab721f3", "patch": "@@ -1,5 +1,5 @@\n /* InflaterInputStream.java - Input stream filter for decompressing\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2006\n    Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -186,31 +186,35 @@ public int read(byte[] b, int off, int len) throws IOException\n       throw new IOException(\"stream closed\");\n     if (len == 0)\n       return 0;\n+    if (inf.finished())\n+      return -1;\n \n     int count = 0;\n-    for (;;)\n+    while (count == 0)\n       {\n+\tif (inf.needsInput())\n+\t  fill();\n \t\n \ttry\n \t  {\n \t    count = inf.inflate(b, off, len);\n+\t    if (count == 0)\n+\t      {\n+\t\tif (this.len == -1)\n+\t\t  {\n+\t\t    // Couldn't get any more data to feed to the Inflater\n+\t\t    return -1;\n+\t\t  }\n+\t\tif (inf.needsDictionary())\n+\t\t  throw new ZipException(\"Inflater needs Dictionary\");\n+\t      }\n \t  } \n \tcatch (DataFormatException dfe) \n \t  {\n \t    throw new ZipException(dfe.getMessage());\n \t  }\n-\n-\tif (count > 0)\n-\t  return count;\n-\t\n-\tif (inf.needsDictionary()\n-\t    | inf.finished())\n-\t  return -1;\n-\telse if (inf.needsInput())\n-\t  fill();\n-\telse\n-\t  throw new InternalError(\"Don't know what to do\");\n       }\n+    return count;\n   }\n \n   /**"}, {"sha": "8ac8a34a6ae2e50d632e98915a469e9dae4de5aa", "filename": "libjava/java/util/zip/Deflater.java", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea725d4524db8fa1bc593f5aa0e297a01ab721f3/libjava%2Fjava%2Futil%2Fzip%2FDeflater.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea725d4524db8fa1bc593f5aa0e297a01ab721f3/libjava%2Fjava%2Futil%2Fzip%2FDeflater.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FDeflater.java?ref=ea725d4524db8fa1bc593f5aa0e297a01ab721f3", "patch": "@@ -1,5 +1,5 @@\n /* Deflater.java - Compress a data stream\n-   Copyright (C) 1999, 2000, 2001, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2004, 2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -325,4 +325,10 @@ public void setDictionary(byte[] dict)\n    * already called or another dictionary was already set.\n    */\n   public native void setDictionary(byte[] buf, int off, int len);\n+\n+  // Classpath's compression library supports flushing, but we\n+  // don't.  So this is a no-op here.\n+  void flush()\n+  {\n+  }\n }"}, {"sha": "37a3f9896ff655d058a8a8b9b889191d0fef922e", "filename": "libjava/java/util/zip/DeflaterOutputStream.java", "status": "removed", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f9ec0c6ad431e25e58dee6b9e6759ab7e74003/libjava%2Fjava%2Futil%2Fzip%2FDeflaterOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f9ec0c6ad431e25e58dee6b9e6759ab7e74003/libjava%2Fjava%2Futil%2Fzip%2FDeflaterOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FDeflaterOutputStream.java?ref=21f9ec0c6ad431e25e58dee6b9e6759ab7e74003", "patch": "@@ -1,194 +0,0 @@\n-/* DeflaterOutputStream.java - Output filter for compressing.\n-   Copyright (C) 1999, 2000, 2001, 2004 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package java.util.zip;\n-\n-import java.io.FilterOutputStream;\n-import java.io.IOException;\n-import java.io.OutputStream;\n-\n-/* Written using on-line Java Platform 1.2 API Specification\n- * and JCL book.\n- * Believed complete and correct.\n- */\n-\n-/**\n- * This is a special FilterOutputStream deflating the bytes that are\n- * written through it.  It uses the Deflater for deflating.\n- *\n- * A special thing to be noted is that flush() doesn't flush\n- * everything in Sun's JDK, but it does so in jazzlib. This is because\n- * Sun's Deflater doesn't have a way to flush() everything, without\n- * finishing the stream.\n- *\n- * @author Tom Tromey, Jochen Hoenicke\n- * @date Jan 11, 2001 \n- */\n-public class DeflaterOutputStream extends FilterOutputStream\n-{\n-  /** \n-   * This buffer is used temporarily to retrieve the bytes from the\n-   * deflater and write them to the underlying output stream.  \n-   */\n-  protected byte[] buf;\n-\n-  /** \n-   * The deflater which is used to deflate the stream.\n-   */\n-  protected Deflater def;\n-  \n-  /**\n-   * Deflates everything in the def's input buffers.  This will call\n-   * <code>def.deflate()</code> until all bytes from the input buffers\n-   * are processed.\n-   */\n-  protected void deflate() throws IOException\n-  {\n-    while (! def.needsInput())\n-      {\n-\tint len = def.deflate(buf, 0, buf.length);\n-\tif (len > 0)\n-\t  out.write(buf, 0, len);\n-       }\n-  }\n-\n-  /** \n-   * Creates a new DeflaterOutputStream with a default Deflater and\n-   * default buffer size.\n-   * @param out the output stream where deflated output should be written.\n-   */\n-  public DeflaterOutputStream(OutputStream out)\n-  {\n-    this(out, new Deflater(), 512);\n-  }\n-\n-  /** \n-   * Creates a new DeflaterOutputStream with the given Deflater and\n-   * default buffer size.\n-   * @param out the output stream where deflated output should be written.\n-   * @param defl the underlying deflater.\n-   */\n-  public DeflaterOutputStream(OutputStream out, Deflater defl)\n-  {\n-    this(out, defl, 512);\n-  }\n-\n-  /** \n-   * Creates a new DeflaterOutputStream with the given Deflater and\n-   * buffer size.\n-   * @param out the output stream where deflated output should be written.\n-   * @param defl the underlying deflater.\n-   * @param bufsize the buffer size.\n-   * @exception IllegalArgumentException if bufsize isn't positive.\n-   */\n-  public DeflaterOutputStream(OutputStream out, Deflater defl, int bufsize)\n-  {\n-    super(out);\n-    if (bufsize <= 0)\n-      throw new IllegalArgumentException(\"bufsize <= 0\");\n-    buf = new byte[bufsize];\n-    def = defl;\n-  }\n-\n-  /**\n-   * Finishes the stream by calling finish() on the deflater.  This\n-   * was the only way to ensure that all bytes are flushed in Sun's\n-   * JDK.  \n-   */\n-  public void finish() throws IOException\n-  {\n-    inbufWrite();\n-    def.finish();\n-    while (! def.finished())\n-      {\n-\tint len = def.deflate(buf, 0, buf.length);\n-\tif (len > 0)\n-\t  out.write(buf, 0, len);\n-      }\n-  }\n-\n-  /**\n-   * Calls finish() and closes the stream. \n-   */\n-  public void close() throws IOException\n-  {\n-    finish();\n-    out.close();\n-  }\n-\n-  /**\n-   * Writes a single byte to the compressed output stream.\n-   * @param bval the byte value.\n-   */\n-  public void write(int bval) throws IOException\n-  {\n-    if (inbuf == null)\n-      inbuf = new byte[128];\n-    else if (inbufLength == inbuf.length)\n-      inbufWrite();\n-    inbuf[inbufLength++] = (byte) bval;\n-  }\n-\n-  /**\n-   * Writes a len bytes from an array to the compressed stream.\n-   * @param buf the byte array.\n-   * @param off the offset into the byte array where to start.\n-   * @param len the number of bytes to write.\n-   */\n-  public void write(byte[] buf, int off, int len) throws IOException\n-  {\n-    inbufWrite();\n-    def.setInput(buf, off, len);\n-    deflate();\n-  }\n-\n-  private void inbufWrite() throws IOException\n-  {\n-    if (inbufLength > 0)\n-      {\n-\tint size = inbufLength;\n-\tinbufLength = 0;\n-\twrite(inbuf, 0, size);\n-      }\n-  }\n-\n-  // Used, if needed, for write(int).\n-  private byte[] inbuf;\n-  // Used length of inbuf.\n-  private int inbufLength;\n-}"}, {"sha": "d0a053a2a4a01297110e3d3a261ab93077240561", "filename": "libjava/java/util/zip/GZIPInputStream.java", "status": "removed", "additions": 0, "deletions": 252, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f9ec0c6ad431e25e58dee6b9e6759ab7e74003/libjava%2Fjava%2Futil%2Fzip%2FGZIPInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f9ec0c6ad431e25e58dee6b9e6759ab7e74003/libjava%2Fjava%2Futil%2Fzip%2FGZIPInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FGZIPInputStream.java?ref=21f9ec0c6ad431e25e58dee6b9e6759ab7e74003", "patch": "@@ -1,252 +0,0 @@\n-/* GZIPInputStream.java - Input filter for reading gzip file\n-   Copyright (C) 1999, 2000, 2001, 2002, 2004 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n- \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-package java.util.zip;\n-\n-import java.io.InputStream;\n-import java.io.IOException;\n-\n-/**\n- * This filter stream is used to decompress a \"GZIP\" format stream. \n- * The \"GZIP\" format is described in RFC 1952.\n- *\n- * @author John Leuner\n- * @author Tom Tromey\n- * @since JDK 1.1\n- */\n-public class GZIPInputStream\n-  extends InflaterInputStream\n-{\n-  /**\n-   * The magic number found at the start of a GZIP stream.\n-   */\n-  public static final int GZIP_MAGIC = 0x8b1f;\n-\n-  static final int Z_DEFLATED = 8;\n-\n-  /**\n-   * The mask for bit 1 of the flag byte.\n-   */\n-  static final int HEAD_CRC = 0x02;\n-\n-  /**\n-   * The mask for bit 2 of the flag byte.\n-   */\n-  static final int EXTRA_FIELD = 0x04;\n-\n-  /**\n-   * The mask for bit 3 of the flag byte.\n-   */\n-  static final int ORIG_NAME = 0x08;\n-\n-  /**\n-   * The mask for bit 4 of the flag byte.\n-   */\n-  static final int COMMENT = 0x10;\n-\n-  /**\n-   * The mask for all reserved bits of the flag byte.\n-   */\n-  static final int RESERVED = 0xe0;\n-  \n-  /**\n-   * The CRC-32 checksum value for uncompressed data.\n-   */\n-  protected CRC32 crc; \n-\n-  /**\n-   * Indicates whether or not the end of the stream has been reached.\n-   */  \n-  protected boolean eos;\n-\n-  /**\n-   * Creates a GZIPInputStream with the default buffer size.\n-   *\n-   * @param in The stream to read compressed data from \n-   *           (in GZIP format).\n-   *\n-   * @throws IOException if an error occurs during an I/O operation.\n-   */\n-  public GZIPInputStream(InputStream in)\n-    throws IOException\n-  {\n-    this(in, 4096);\n-  }\n-\n-  /**\n-   * Creates a GZIPInputStream with the specified buffer size.\n-   *\n-   * @param in The stream to read compressed data from \n-   *           (in GZIP format).\n-   * @param size The size of the buffer to use.\n-   *\n-   * @throws IOException if an error occurs during an I/O operation.\n-   * @throws IllegalArgumentException if <code>size</code>\n-   * is less than or equal to 0.\n-   */\n-  public GZIPInputStream(InputStream in, int size)\n-    throws IOException\n-  {\n-    super(in, new Inflater(true), size);\n-\n-    // NOTE: header reading code taken from zlib's gzio.c.\n-\n-    // Read the magic number.\n-    int magic = eof_read() | (eof_read() << 8);\n-    if (magic != GZIP_MAGIC)\n-      throw new ZipException(\"gzip header corrupted\");\n-\n-    int method = eof_read();\n-    int flags = eof_read();\n-    // Test from zlib.\n-    if (method != Z_DEFLATED || (flags & RESERVED) != 0)\n-      throw new ZipException(\"gzip header corrupted\");\n-\n-    // Discard time, xflags, OS code.\n-    for (int i = 0; i < 6; ++i)\n-      eof_read();\n-\n-    // Skip the extra field.\n-    if ((flags & EXTRA_FIELD) != 0)\n-      {\n-\tint len = eof_read() | (eof_read() << 8);\n-\twhile (len-- != 0)\n-\t  eof_read();\n-      }\n-\n-    if ((flags & ORIG_NAME) != 0)\n-      {\n-\twhile (true)\n-\t  {\n-\t    int c = eof_read();\n-\t    if (c == 0)\n-\t      break;\n-\t  }\n-      }\n-\n-    if ((flags & COMMENT) != 0)\n-      {\n-\twhile (true)\n-\t  {\n-\t    int c = eof_read();\n-\t    if (c == 0)\n-\t      break;\n-\t  }\n-      }\n-\n-    if ((flags & HEAD_CRC) != 0)\n-      {\n-\t// FIXME: consider checking CRC of the header.\n-\teof_read();\n-\teof_read();\n-      }\n-\n-    crc = new CRC32();\n-  }\n-\n-  /**\n-   * Closes the input stream.\n-   *\n-   * @throws IOException if an error occurs during an I/O operation.\n-   */\n-  public void close()\n-    throws IOException\n-  {\n-    // Nothing to do here.\n-    super.close();\n-  }\n-\n-  private final int eof_read() throws IOException\n-  {\n-    int r = in.read();\n-    if (r == -1)\n-      throw new ZipException(\"gzip header corrupted\");\n-    return r & 0xff;\n-  }\n-\n-  /**\n-   * Reads in GZIP-compressed data and stores it in uncompressed form\n-   * into an array of bytes.  The method will block until either\n-   * enough input data becomes available or the compressed stream\n-   * reaches its end.\n-   *\n-   * @param buf the buffer into which the uncompressed data will\n-   *            be stored.\n-   * @param offset the offset indicating where in <code>buf</code>\n-   *               the uncompressed data should be placed.\n-   * @param len the number of uncompressed bytes to be read.\n-   */\n-  public int read(byte[] buf, int offset, int len) throws IOException\n-  {\n-    if (eos)\n-      return -1;\n-    int r = super.read(buf, offset, len);\n-    if (r == -1)\n-      {\n-\teos = true;\n-\n-\tbyte[] tmp = new byte[8];\n-\t// First copy remaining bytes from inflater input buffer.\n-\tint avail = inf.getRemaining();\n-\tSystem.arraycopy(this.buf, this.len - avail, tmp, 0, avail);\n-\n-\t// Now read remaining bytes from wrapped input stream.\n-\tfor (int i = avail; i < 8; ++i)\n-\t  {\n-\t    tmp[i] = (byte) eof_read();\n-\t  }\n-\n-\t// Be careful to avoid sign extension here; CRC32.getValue()\n-\t// returns a long.\n-\tlong header_crc = read4(tmp, 0) & 0xffffffffL;\n-\tif (crc.getValue() != header_crc)\n-\t  throw new ZipException(\"corrupted gzip file - crc mismatch\");\n-\tint isize = read4(tmp, 4);\n-\tif (inf.getTotalOut() != isize)\n-\t  throw new ZipException(\"corrupted gzip file - size mismatch\");\n-\treturn -1;\n-      }\n-    crc.update(buf, offset, r);\n-    return r;\n-  }\n-\n-  private final int read4(byte[] buf, int offset) throws IOException\n-  {\n-    return (((buf[offset + 3] & 0xFF) << 24) + ((buf[offset + 2] & 0xFF) << 16)\n-\t    + ((buf[offset + 1] & 0xFF) << 8) + (buf[offset] & 0xFF));\n-  }\n-}"}, {"sha": "260911a22154762178b6a4699973aad15a7cdb85", "filename": "libjava/java/util/zip/GZIPOutputStream.java", "status": "removed", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f9ec0c6ad431e25e58dee6b9e6759ab7e74003/libjava%2Fjava%2Futil%2Fzip%2FGZIPOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f9ec0c6ad431e25e58dee6b9e6759ab7e74003/libjava%2Fjava%2Futil%2Fzip%2FGZIPOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FGZIPOutputStream.java?ref=21f9ec0c6ad431e25e58dee6b9e6759ab7e74003", "patch": "@@ -1,146 +0,0 @@\n-/* GZIPOutputStream.java - Create a file in gzip format\n-   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n- \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-package java.util.zip;\n-\n-import java.io.IOException;\n-import java.io.OutputStream;\n-\n-/**\n- * This filter stream is used to compress a stream into a \"GZIP\" stream. \n- * The \"GZIP\" format is described in RFC 1952.\n- *\n- * @author John Leuner\n- * @author Tom Tromey\n- * @since JDK 1.1\n- */\n-\n-/* Written using on-line Java Platform 1.2 API Specification\n- * and JCL book.\n- * Believed complete and correct.\n- */\n-\n-public class GZIPOutputStream extends DeflaterOutputStream\n-{\n-  /**\n-   * CRC-32 value for uncompressed data\n-   */\n-  protected CRC32 crc;\n-\n-  /**\n-   * Creates a GZIPOutputStream with the default buffer size\n-   *\n-   * @param out The stream to read data (to be compressed) from \n-   * \n-   */\n-  public GZIPOutputStream(OutputStream out) throws IOException\n-  {\n-    this(out, 4096);\n-  }\n-\n-  /**\n-   * Creates a GZIPOutputStream with the specified buffer size\n-   *\n-   * @param out The stream to read compressed data from \n-   * @param size Size of the buffer to use \n-   */\n-  public GZIPOutputStream(OutputStream out, int size) throws IOException\n-  {\n-    super(out, new Deflater(Deflater.DEFAULT_COMPRESSION, true), size);\n-    crc = new CRC32();\n-    put2(GZIPInputStream.GZIP_MAGIC);\n-    out.write(GZIPInputStream.Z_DEFLATED);\n-    // No flags for now.\n-    out.write(0);\n-    // No time either.\n-    put2(0);\n-    put2(0);\n-    // No xflags either.\n-    out.write(0);\n-    // FIXME: unknown OS.\n-    out.write(255);\n-  }\n-\n-  public synchronized void write(int bval) throws IOException\n-  {\n-    super.write(bval);\n-    crc.update(bval);\n-  }\n-\n-  public synchronized void write(byte[] buf) throws IOException\n-  {\n-    write(buf, 0, buf.length);\n-  }\n-\n-  public synchronized void write(byte[] buf, int off, int len)\n-    throws IOException\n-  {\n-    super.write(buf, off, len);\n-    crc.update(buf, off, len);\n-  }\n-\n-  /**\n-   * Writes remaining compressed output data to the output stream\n-   * and closes it.\n-   */\n-  public void close() throws IOException\n-  {\n-    finish();\n-    out.close();\n-  }\n-\n-  public void finish() throws IOException\n-  {\n-    super.finish();\n-    put4((int) crc.getValue());\n-    put4(def.getTotalIn());\n-  }\n-\n-  private final void put2(int i) throws IOException\n-  {\n-    out.write(i);\n-    out.write(i >> 8);\n-  }\n-\n-  private final void put4 (int i) throws IOException\n-  {\n-    out.write(i);\n-    out.write(i >> 8);\n-    out.write(i >> 16);\n-    out.write(i >> 24);\n-  }\n-}"}, {"sha": "11b06d24a28a41e0d564fc544295128325b1d2eb", "filename": "libjava/java/util/zip/InflaterInputStream.java", "status": "removed", "additions": 0, "deletions": 264, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21f9ec0c6ad431e25e58dee6b9e6759ab7e74003/libjava%2Fjava%2Futil%2Fzip%2FInflaterInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21f9ec0c6ad431e25e58dee6b9e6759ab7e74003/libjava%2Fjava%2Futil%2Fzip%2FInflaterInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FInflaterInputStream.java?ref=21f9ec0c6ad431e25e58dee6b9e6759ab7e74003", "patch": "@@ -1,264 +0,0 @@\n-/* InflaterInputStream.java - Input stream filter for decompressing\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n- \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package java.util.zip;\n-\n-import java.io.FilterInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-\n-/**\n- * This filter stream is used to decompress data compressed in the \"deflate\"\n- * format. The \"deflate\" format is described in RFC 1951.\n- *\n- * This stream may form the basis for other decompression filters, such\n- * as the <code>GZIPInputStream</code>.\n- *\n- * @author John Leuner\n- * @author Tom Tromey\n- * @since 1.1\n- */\n-public class InflaterInputStream extends FilterInputStream\n-{\n-  /**\n-   * Decompressor for this filter \n-   */\n-  protected Inflater inf;\n-\n-  /**\n-   * Byte array used as a buffer \n-   */\n-  protected byte[] buf;\n-\n-  /**\n-   * Size of buffer   \n-   */\n-  protected int len;\n-\n-  // We just use this if we are decoding one byte at a time with the\n-  // read() call.\n-  private byte[] onebytebuffer = new byte[1];\n-\n-  /**\n-   * Create an InflaterInputStream with the default decompresseor\n-   * and a default buffer size.\n-   *\n-   * @param in the InputStream to read bytes from\n-   */\n-  public InflaterInputStream(InputStream in) \n-  {\n-    this(in, new Inflater(), 4096);\n-  }\n-\n-  /**\n-   * Create an InflaterInputStream with the specified decompresseor\n-   * and a default buffer size.\n-   *\n-   * @param in the InputStream to read bytes from\n-   * @param inf the decompressor used to decompress data read from in\n-   */\n-  public InflaterInputStream(InputStream in, Inflater inf) \n-  {\n-    this(in, inf, 4096);\n-  }\n-\n-  /**\n-   * Create an InflaterInputStream with the specified decompresseor\n-   * and a specified buffer size.\n-   *\n-   * @param in the InputStream to read bytes from\n-   * @param inf the decompressor used to decompress data read from in\n-   * @param size size of the buffer to use\n-   */\n-  public InflaterInputStream(InputStream in, Inflater inf, int size) \n-  {\n-    super(in);\n-\n-    if (in == null)\n-      throw new NullPointerException(\"in may not be null\");\n-    if (inf == null)\n-      throw new NullPointerException(\"inf may not be null\");\n-    if (size < 0)\n-      throw new IllegalArgumentException(\"size may not be negative\");\n-    \n-    this.inf = inf;\n-    this.buf = new byte [size];\n-  }\n-\n-  /**\n-   * Returns 0 once the end of the stream (EOF) has been reached.\n-   * Otherwise returns 1.\n-   */\n-  public int available() throws IOException\n-  {\n-    // According to the JDK 1.2 docs, this should only ever return 0\n-    // or 1 and should not be relied upon by Java programs.\n-    if (inf == null)\n-      throw new IOException(\"stream closed\");\n-    return inf.finished() ? 0 : 1;\n-  }\n-\n-  /**\n-   * Closes the input stream\n-   */\n-  public synchronized void close() throws IOException\n-  {\n-    inf = null;\n-    super.close();\n-  }\n-\n-  /**\n-   * Fills the buffer with more data to decompress.\n-   */\n-  protected void fill() throws IOException\n-  {\n-    if (in == null)\n-      throw new ZipException (\"InflaterInputStream is closed\");\n-    \n-    len = in.read(buf, 0, buf.length);\n-\n-    if (len < 0)\n-      throw new ZipException(\"Deflated stream ends early.\");\n-    \n-    inf.setInput(buf, 0, len);\n-  }\n-\n-  /**\n-   * Reads one byte of decompressed data.\n-   *\n-   * The byte is in the lower 8 bits of the int.\n-   */\n-  public int read() throws IOException\n-  { \n-    int nread = read(onebytebuffer, 0, 1);\n-    if (nread > 0)\n-      return onebytebuffer[0] & 0xff;\n-    return -1;\n-  }\n-\n-  /**\n-   * Decompresses data into the byte array\n-   *\n-   * @param b the array to read and decompress data into\n-   * @param off the offset indicating where the data should be placed\n-   * @param len the number of bytes to decompress\n-   */\n-  public int read(byte[] b, int off, int len) throws IOException\n-  {\n-    if (inf == null)\n-      throw new IOException(\"stream closed\");\n-    if (len == 0)\n-      return 0;\n-    if (inf.finished())\n-      return -1;\n-\n-    int count = 0;\n-    while (count == 0)\n-      {\n-\tif (inf.needsInput())\n-\t  fill();\n-\t\n-\ttry\n-\t  {\n-\t    count = inf.inflate(b, off, len);\n-\t    if (count == 0)\n-\t      {\n-\t\tif (this.len == -1)\n-\t\t  {\n-\t\t    // Couldn't get any more data to feed to the Inflater\n-\t\t    return -1;\n-\t\t  }\n-\t\tif (inf.needsDictionary())\n-\t\t  throw new ZipException(\"Inflater needs Dictionary\");\n-\t      }\n-\t  } \n-\tcatch (DataFormatException dfe) \n-\t  {\n-\t    throw new ZipException(dfe.getMessage());\n-\t  }\n-      }\n-    return count;\n-  }\n-\n-  /**\n-   * Skip specified number of bytes of uncompressed data\n-   *\n-   * @param n number of bytes to skip\n-   */\n-  public long skip(long n) throws IOException\n-  {\n-    if (inf == null)\n-      throw new IOException(\"stream closed\");\n-    if (n < 0)\n-      throw new IllegalArgumentException();\n-\n-    if (n == 0)\n-      return 0;\n-\n-    int buflen = (int) Math.min(n, 2048);\n-    byte[] tmpbuf = new byte[buflen];\n-\n-    long skipped = 0L;\n-    while (n > 0L)\n-      {\n-\tint numread = read(tmpbuf, 0, buflen);\n-\tif (numread <= 0)\n-\t  break;\n-\tn -= numread;\n-\tskipped += numread;\n-\tbuflen = (int) Math.min(n, 2048);\n-      }\n-\n-    return skipped;\n- }\n-\n-  public boolean markSupported()\n-  {\n-    return false;\n-  }\n-\n-  public void mark(int readLimit)\n-  {\n-  }\n-\n-  public void reset() throws IOException\n-  {\n-    throw new IOException(\"reset not supported\");\n-  }\n-}"}, {"sha": "e9014b6f01da02c6b3d1f7000d59a0991883e221", "filename": "libjava/sources.am", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea725d4524db8fa1bc593f5aa0e297a01ab721f3/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea725d4524db8fa1bc593f5aa0e297a01ab721f3/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=ea725d4524db8fa1bc593f5aa0e297a01ab721f3", "patch": "@@ -5203,11 +5203,11 @@ classpath/java/util/zip/CheckedOutputStream.java \\\n classpath/java/util/zip/Checksum.java \\\n classpath/java/util/zip/DataFormatException.java \\\n java/util/zip/Deflater.java \\\n-java/util/zip/DeflaterOutputStream.java \\\n-java/util/zip/GZIPInputStream.java \\\n-java/util/zip/GZIPOutputStream.java \\\n+classpath/java/util/zip/DeflaterOutputStream.java \\\n+classpath/java/util/zip/GZIPInputStream.java \\\n+classpath/java/util/zip/GZIPOutputStream.java \\\n java/util/zip/Inflater.java \\\n-java/util/zip/InflaterInputStream.java \\\n+classpath/java/util/zip/InflaterInputStream.java \\\n classpath/java/util/zip/ZipConstants.java \\\n classpath/java/util/zip/ZipEntry.java \\\n classpath/java/util/zip/ZipException.java \\"}]}