{"sha": "8aeb42d06b31988d1cae8c5c8200fc2650d3e16a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFlYjQyZDA2YjMxOTg4ZDFjYWU4YzVjODIwMGZjMjY1MGQzZTE2YQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-11-19T00:13:36Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-11-19T00:13:36Z"}, "message": "re PR java/1401 (+= semantics not correct (when generating bytecode))\n\n\tFix for PR java/1401:\n\t* jcf-write.c (generate_bytecode_insns) [binop]: Handle case where\n\targ0 is null.\n\t(generate_bytecode_insns) [MODIFY_EXPR]: Handle `OP=' case\n\tcorrectly.\n\nFrom-SVN: r47156", "tree": {"sha": "74f7255a1621b75d125be3749271ff8bdc41d0f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74f7255a1621b75d125be3749271ff8bdc41d0f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8aeb42d06b31988d1cae8c5c8200fc2650d3e16a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aeb42d06b31988d1cae8c5c8200fc2650d3e16a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aeb42d06b31988d1cae8c5c8200fc2650d3e16a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aeb42d06b31988d1cae8c5c8200fc2650d3e16a/comments", "author": null, "committer": null, "parents": [{"sha": "604407070be6a945b7ccfe3fa89e51cfe112614f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/604407070be6a945b7ccfe3fa89e51cfe112614f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/604407070be6a945b7ccfe3fa89e51cfe112614f"}], "stats": {"total": 69, "additions": 68, "deletions": 1}, "files": [{"sha": "8c0a1064e4e51553658f0d745acccda2d1dd6e06", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeb42d06b31988d1cae8c5c8200fc2650d3e16a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeb42d06b31988d1cae8c5c8200fc2650d3e16a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=8aeb42d06b31988d1cae8c5c8200fc2650d3e16a", "patch": "@@ -1,3 +1,11 @@\n+2001-11-18  Tom Tromey  <tromey@redhat.com>\n+\n+\tFix for PR java/1401:\n+\t* jcf-write.c (generate_bytecode_insns) [binop]: Handle case where\n+\targ0 is null.\n+\t(generate_bytecode_insns) [MODIFY_EXPR]: Handle `OP=' case\n+\tcorrectly.\n+\n 2001-11-18  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* lang.c (finish_parse): Rename to java_finish."}, {"sha": "2d3e333100faebc6541631b9b92747a85948c769", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aeb42d06b31988d1cae8c5c8200fc2650d3e16a/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aeb42d06b31988d1cae8c5c8200fc2650d3e16a/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=8aeb42d06b31988d1cae8c5c8200fc2650d3e16a", "patch": "@@ -2034,6 +2034,61 @@ generate_bytecode_insns (exp, target, state)\n \t  }\n \telse\n \t  offset = 0;\n+\n+\t/* If the rhs is a binary expression and the left operand is\n+\t   `==' to the lhs then we have an OP= expression.  In this\n+\t   case we must do some special processing.  */\n+\tif (TREE_CODE_CLASS (TREE_CODE (rhs)) == '2'\n+\t    && lhs == TREE_OPERAND (rhs, 0))\n+\t  {\n+\t    if (TREE_CODE (lhs) == COMPONENT_REF)\n+\t      {\n+\t\ttree field = TREE_OPERAND (lhs, 1);\n+\t\tif (! FIELD_STATIC (field))\n+\t\t  {\n+\t\t    /* Duplicate the object reference so we can get\n+\t\t       the field.  */\n+\t\t    emit_dup (TYPE_IS_WIDE (field) ? 2 : 1, 0, state);\n+\t\t    NOTE_POP (1);\n+\t\t  }\n+\t\tfield_op (field, (FIELD_STATIC (field)\n+\t\t\t\t  ? OPCODE_getstatic\n+\t\t\t\t  : OPCODE_getfield),\n+\t\t\t  state);\n+\n+\t\tNOTE_PUSH (TYPE_IS_WIDE (TREE_TYPE (field)) ? 2 : 1);\n+\t      }\n+\t    else if (TREE_CODE (lhs) == VAR_DECL\n+\t\t     || TREE_CODE (lhs) == PARM_DECL)\n+\t      {\n+\t\tif (FIELD_STATIC (lhs))\n+\t\t  {\n+\t\t    field_op (lhs, OPCODE_getstatic, state);\n+\t\t    NOTE_PUSH (TYPE_IS_WIDE (TREE_TYPE (lhs)) ? 2 : 1);\n+\t\t  }\n+\t\telse\n+\t\t  emit_load (lhs, state);\n+\t      }\n+\t    else if (TREE_CODE (lhs) == ARRAY_REF)\n+\t      {\n+\t\t/* Duplicate the array and index, which are on the\n+\t\t   stack, so that we can load the old value.  */\n+\t\temit_dup (2, 0, state);\n+\t\tNOTE_POP (2);\n+\t\tjopcode = OPCODE_iaload + adjust_typed_op (TREE_TYPE (lhs), 7);\n+\t\tRESERVE (1);\n+\t\tOP1 (jopcode);\n+\t\tNOTE_PUSH (TYPE_IS_WIDE (TREE_TYPE (lhs)) ? 2 : 1);\n+\t      }\n+\t    else\n+\t      abort ();\n+\n+\t    /* This function correctly handles the case where the LHS\n+\t       of a binary expression is NULL_TREE.  */\n+\t    rhs = build (TREE_CODE (rhs), TREE_TYPE (rhs),\n+\t\t\t NULL_TREE, TREE_OPERAND (rhs, 1));\n+\t  }\n+\n \tgenerate_bytecode_insns (rhs, STACK_TARGET, state);\n \tif (target != IGNORE_TARGET)\n \t  emit_dup (TYPE_IS_WIDE (type) ? 2 : 1 , offset, state);\n@@ -2112,7 +2167,11 @@ generate_bytecode_insns (exp, target, state)\n \t}\n       else\n \t{\n-\t  generate_bytecode_insns (arg0, target, state);\n+\t  /* ARG0 will be NULL_TREE if we're handling an `OP='\n+\t     expression.  In this case the stack already holds the\n+\t     LHS.  See the MODIFY_EXPR case.  */\n+\t  if (arg0 != NULL_TREE)\n+\t    generate_bytecode_insns (arg0, target, state);\n \t  if (jopcode >= OPCODE_lshl && jopcode <= OPCODE_lushr)\n \t    arg1 = convert (int_type_node, arg1);\n \t  generate_bytecode_insns (arg1, target, state);"}]}