{"sha": "39da58667d94ab210cb6918fb8f528aa6aabfbb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlkYTU4NjY3ZDk0YWIyMTBjYjY5MThmYjhmNTI4YWE2YWFiZmJiMg==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-12-09T12:32:50Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-12-09T12:32:50Z"}, "message": "trans-array.c (gfc_array_deallocate): Remove wrapper.\n\ngcc/fortran/ChangeLog:\n\n2016-12-09  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* trans-array.c (gfc_array_deallocate): Remove wrapper.\n\t(gfc_trans_dealloc_allocated): Same.\n\t(structure_alloc_comps): Restructure deallocation of (nested)\n\tallocatable components.  Insert dealloc of sub-component into the block\n\tguarded by the if != NULL for the component.\n\t(gfc_trans_deferred_array): Use the almightly deallocate_with_status.\n\t* trans-array.h: Remove prototypes.\n\t* trans-expr.c (gfc_conv_procedure_call): Use the almighty deallocate_\n\twith_status.\n\t* trans-openmp.c (gfc_walk_alloc_comps): Likewise.\n\t(gfc_omp_clause_assign_op): Likewise. \n\t(gfc_omp_clause_dtor): Likewise.\n\t* trans-stmt.c (gfc_trans_deallocate): Likewise.\n\t* trans.c (gfc_deallocate_with_status): Allow deallocation of scalar\n\tand arrays as well as coarrays.\n\t(gfc_deallocate_scalar_with_status): Get the data member for coarrays\n\tonly when freeing an array with descriptor.  And set correct caf_mode\n\twhen freeing components of coarrays.\n\t* trans.h: Change prototype of gfc_deallocate_with_status to allow\n\tadding statements into the block guarded by the if (pointer != 0) and\n\tsupply a coarray handle.\n\ngcc/testsuite/ChangeLog:\n\n2016-12-09  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* gfortran.dg/coarray_alloc_comp_3.f08: New test.\n\t* gfortran.dg/coarray_alloc_comp_4.f08: New test.\n\t* gfortran.dg/finalize_18.f90: Add count for additional guard against\n\taccessing null-pointer.\n\t* gfortran.dg/proc_ptr_comp_47.f90: New test.\n\nFrom-SVN: r243480", "tree": {"sha": "1bda74174ae46af10d3138cf905d8b73784c27ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bda74174ae46af10d3138cf905d8b73784c27ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39da58667d94ab210cb6918fb8f528aa6aabfbb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39da58667d94ab210cb6918fb8f528aa6aabfbb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39da58667d94ab210cb6918fb8f528aa6aabfbb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39da58667d94ab210cb6918fb8f528aa6aabfbb2/comments", "author": null, "committer": null, "parents": [{"sha": "32913637718983cf04b8225ee778d5e96ae71d7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32913637718983cf04b8225ee778d5e96ae71d7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32913637718983cf04b8225ee778d5e96ae71d7c"}], "stats": {"total": 641, "additions": 366, "deletions": 275}, "files": [{"sha": "fe68bf45cfbb39dffedc4f1bd3fb530d5811c221", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=39da58667d94ab210cb6918fb8f528aa6aabfbb2", "patch": "@@ -1,3 +1,27 @@\n+2016-12-09  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* trans-array.c (gfc_array_deallocate): Remove wrapper.\n+\t(gfc_trans_dealloc_allocated): Same.\n+\t(structure_alloc_comps): Restructure deallocation of (nested)\n+\tallocatable components.  Insert dealloc of sub-component into the block\n+\tguarded by the if != NULL for the component.\n+\t(gfc_trans_deferred_array): Use the almightly deallocate_with_status.\n+\t* trans-array.h: Remove prototypes.\n+\t* trans-expr.c (gfc_conv_procedure_call): Use the almighty deallocate_\n+\twith_status.\n+\t* trans-openmp.c (gfc_walk_alloc_comps): Likewise.\n+\t(gfc_omp_clause_assign_op): Likewise. \n+\t(gfc_omp_clause_dtor): Likewise.\n+\t* trans-stmt.c (gfc_trans_deallocate): Likewise.\n+\t* trans.c (gfc_deallocate_with_status): Allow deallocation of scalar\n+\tand arrays as well as coarrays.\n+\t(gfc_deallocate_scalar_with_status): Get the data member for coarrays\n+\tonly when freeing an array with descriptor.  And set correct caf_mode\n+\twhen freeing components of coarrays.\n+\t* trans.h: Change prototype of gfc_deallocate_with_status to allow\n+\tadding statements into the block guarded by the if (pointer != 0) and\n+\tsupply a coarray handle.\n+\n 2016-12-09  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/44265"}, {"sha": "8753cbf4660404a7a6fb06728899414a688d2b97", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 103, "deletions": 219, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=39da58667d94ab210cb6918fb8f528aa6aabfbb2", "patch": "@@ -5652,53 +5652,6 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n }\n \n \n-/* Deallocate an array variable.  Also used when an allocated variable goes\n-   out of scope.  */\n-/*GCC ARRAYS*/\n-\n-tree\n-gfc_array_deallocate (tree descriptor, tree pstat, tree errmsg, tree errlen,\n-\t\t      tree label_finish, gfc_expr* expr,\n-\t\t      int coarray_dealloc_mode)\n-{\n-  tree var;\n-  tree tmp;\n-  stmtblock_t block;\n-  bool coarray = coarray_dealloc_mode != GFC_CAF_COARRAY_NOCOARRAY;\n-\n-  gfc_start_block (&block);\n-\n-  /* Get a pointer to the data.  */\n-  var = gfc_conv_descriptor_data_get (descriptor);\n-  STRIP_NOPS (var);\n-\n-  /* Parameter is the address of the data component.  */\n-  tmp = gfc_deallocate_with_status (coarray ? descriptor : var, pstat, errmsg,\n-\t\t\t\t    errlen, label_finish, false, expr,\n-\t\t\t\t    coarray_dealloc_mode);\n-  gfc_add_expr_to_block (&block, tmp);\n-\n-  /* Zero the data pointer; only for coarrays an error can occur and then\n-     the allocation status may not be changed.  */\n-  tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n-\t\t\t var, build_int_cst (TREE_TYPE (var), 0));\n-  if (pstat != NULL_TREE && coarray && flag_coarray == GFC_FCOARRAY_LIB)\n-    {\n-      tree cond;\n-      tree stat = build_fold_indirect_ref_loc (input_location, pstat);\n-\n-      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n-\t\t\t      stat, build_int_cst (TREE_TYPE (stat), 0));\n-      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t     cond, tmp, build_empty_stmt (input_location));\n-    }\n-\n-  gfc_add_expr_to_block (&block, tmp);\n-\n-  return gfc_finish_block (&block);\n-}\n-\n-\n /* Create an array constructor from an initialization expression.\n    We assume the frontend already did any expansions and conversions.  */\n \n@@ -7806,39 +7759,6 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,\n }\n \n \n-/* Generate code to deallocate an array, if it is allocated.  */\n-\n-tree\n-gfc_trans_dealloc_allocated (tree descriptor, gfc_expr *expr,\n-\t\t\t     int coarray_dealloc_mode)\n-{\n-  tree tmp;\n-  tree var;\n-  stmtblock_t block;\n-  bool coarray = coarray_dealloc_mode != GFC_CAF_COARRAY_NOCOARRAY;\n-\n-  gfc_start_block (&block);\n-\n-  var = gfc_conv_descriptor_data_get (descriptor);\n-  STRIP_NOPS (var);\n-\n-  /* Call array_deallocate with an int * present in the second argument.\n-     Although it is ignored here, it's presence ensures that arrays that\n-     are already deallocated are ignored.  */\n-  tmp = gfc_deallocate_with_status (coarray ? descriptor : var, NULL_TREE,\n-\t\t\t\t    NULL_TREE, NULL_TREE, NULL_TREE, true, expr,\n-\t\t\t\t    coarray_dealloc_mode);\n-  gfc_add_expr_to_block (&block, tmp);\n-\n-  /* Zero the data pointer.  */\n-  tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n-\t\t\t var, build_int_cst (TREE_TYPE (var), 0));\n-  gfc_add_expr_to_block (&block, tmp);\n-\n-  return gfc_finish_block (&block);\n-}\n-\n-\n /* This helper function calculates the size in words of a full array.  */\n \n tree\n@@ -8157,8 +8077,11 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n   tree null_cond = NULL_TREE;\n   tree add_when_allocated;\n   tree dealloc_fndecl;\n-  bool called_dealloc_with_status;\n+  tree caf_token;\n   gfc_symbol *vtab;\n+  int caf_dereg_mode;\n+  symbol_attribute *attr;\n+  bool deallocate_called;\n \n   gfc_init_block (&fnblock);\n \n@@ -8265,7 +8188,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n       bool cmp_has_alloc_comps = (c->ts.type == BT_DERIVED\n \t\t\t\t  || c->ts.type == BT_CLASS)\n \t\t\t\t    && c->ts.u.derived->attr.alloc_comp;\n-      bool same_type = c->ts.type == BT_DERIVED && der_type == c->ts.u.derived;\n+      bool same_type = (c->ts.type == BT_DERIVED && der_type == c->ts.u.derived)\n+\t|| (c->ts.type == BT_CLASS && der_type == CLASS_DATA (c)->ts.u.derived);\n \n       cdecl = c->backend_decl;\n       ctype = TREE_TYPE (cdecl);\n@@ -8274,112 +8198,118 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t{\n \tcase DEALLOCATE_ALLOC_COMP:\n \n-\t  /* gfc_deallocate_scalar_with_status calls gfc_deallocate_alloc_comp\n-\t     (i.e. this function) so generate all the calls and suppress the\n-\t     recursion from here, if necessary.  */\n-\t  called_dealloc_with_status = false;\n \t  gfc_init_block (&tmpblock);\n \n+\t  comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t  decl, cdecl, NULL_TREE);\n+\n+\t  /* Shortcut to get the attributes of the component.  */\n+\t  if (c->ts.type == BT_CLASS)\n+\t    attr = &CLASS_DATA (c)->attr;\n+\t  else\n+\t    attr = &c->attr;\n+\n \t  if ((c->ts.type == BT_DERIVED && !c->attr.pointer)\n-\t      || (c->ts.type == BT_CLASS && !CLASS_DATA (c)->attr.class_pointer))\n-\t    {\n-\t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n-\t\t\t\t      decl, cdecl, NULL_TREE);\n+\t     || (c->ts.type == BT_CLASS && !CLASS_DATA (c)->attr.class_pointer))\n+\t    /* Call the finalizer, which will free the memory and nullify the\n+\t       pointer of an array.  */\n+\t    deallocate_called = gfc_add_comp_finalizer_call (&tmpblock, comp, c,\n+\t\t\t\t\t\t\t caf_enabled (caf_mode))\n+\t\t&& attr->dimension;\n+\t  else\n+\t    deallocate_called = false;\n+\n+\t  /* Add the _class ref for classes.  */\n+\t  if (c->ts.type == BT_CLASS && attr->allocatable)\n+\t    comp = gfc_class_data_get (comp);\n \n-\t      /* The finalizer frees allocatable components.  */\n-\t      called_dealloc_with_status\n-\t\t= gfc_add_comp_finalizer_call (&tmpblock, comp, c,\n-\t\t\t\t\t       purpose == DEALLOCATE_ALLOC_COMP\n-\t\t\t\t\t       && caf_enabled (caf_mode));\n+\t  add_when_allocated = NULL_TREE;\n+\t  if (cmp_has_alloc_comps\n+\t      && !c->attr.pointer && !c->attr.proc_pointer\n+\t      && !same_type\n+\t      && !deallocate_called)\n+\t    {\n+\t      /* Add checked deallocation of the components.  This code is\n+\t\t obviously added because the finalizer is not trusted to free\n+\t\t all memory.  */\n+\t      if (c->ts.type == BT_CLASS)\n+\t\t{\n+\t\t  rank = CLASS_DATA (c)->as ? CLASS_DATA (c)->as->rank : 0;\n+\t\t  add_when_allocated\n+\t\t      = structure_alloc_comps (CLASS_DATA (c)->ts.u.derived,\n+\t\t\t\t\t       comp, NULL_TREE, rank, purpose,\n+\t\t\t\t\t       caf_mode);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rank = c->as ? c->as->rank : 0;\n+\t\t  add_when_allocated = structure_alloc_comps (c->ts.u.derived,\n+\t\t\t\t\t\t\t      comp, NULL_TREE,\n+\t\t\t\t\t\t\t      rank, purpose,\n+\t\t\t\t\t\t\t      caf_mode);\n+\t\t}\n \t    }\n-\t  else\n-\t    comp = NULL_TREE;\n \n-\t  if (c->attr.allocatable && !c->attr.proc_pointer && !same_type\n-\t      && (c->attr.dimension\n-\t\t  || (caf_enabled (caf_mode)\n-\t\t      && (caf_in_coarray (caf_mode) || c->attr.codimension))))\n+\t  if (attr->allocatable && !same_type\n+\t      && (!attr->codimension || caf_enabled (caf_mode)))\n \t    {\n-\t      /* Allocatable arrays or coarray'ed components (scalar or\n-\t\t array).  */\n-\t      int caf_dereg_mode\n-\t\t  = (caf_in_coarray (caf_mode) || c->attr.codimension)\n+\t      /* Handle all types of components besides components of the\n+\t\t same_type as the current one, because those would create an\n+\t\t endless loop.  */\n+\t      caf_dereg_mode\n+\t\t  = (caf_in_coarray (caf_mode) || attr->codimension)\n \t\t  ? (gfc_caf_is_dealloc_only (caf_mode)\n \t\t     ? GFC_CAF_COARRAY_DEALLOCATE_ONLY\n \t\t     : GFC_CAF_COARRAY_DEREGISTER)\n \t\t  : GFC_CAF_COARRAY_NOCOARRAY;\n-\t      if (comp == NULL_TREE)\n-\t\tcomp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n-\t\t\t\t\tdecl, cdecl, NULL_TREE);\n \n-\t      if (c->attr.dimension || c->attr.codimension)\n-\t\t/* Deallocate array.  */\n-\t\ttmp = gfc_trans_dealloc_allocated (comp, NULL, caf_dereg_mode);\n-\t      else\n+\t      caf_token = NULL_TREE;\n+\t      /* Coarray components are handled directly by\n+\t\t deallocate_with_status.  */\n+\t      if (!attr->codimension\n+\t\t  && caf_dereg_mode != GFC_CAF_COARRAY_NOCOARRAY)\n \t\t{\n-\t\t  /* Deallocate scalar.  */\n-\t\t  tree cond = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\t       boolean_type_node, comp,\n-\t\t\t\t\t       build_int_cst (TREE_TYPE (comp),\n-\t\t\t\t\t\t\t      0));\n-\n-\t\t  tmp = fold_build3_loc (input_location, COMPONENT_REF,\n-\t\t\t\t\t pvoid_type_node, decl, c->caf_token,\n-\t\t\t\t\t NULL_TREE);\n-\t\t  tmp = build_call_expr_loc (input_location,\n-\t\t\t\t\t     gfor_fndecl_caf_deregister, 5,\n-\t\t\t\t\t     gfc_build_addr_expr (NULL_TREE,\n-\t\t\t\t\t\t\t\t  tmp),\n-\t\t\t\t\t     build_int_cst (integer_type_node,\n-\t\t\t\t\t\t\t    caf_dereg_mode),\n-\t\t\t\t\t     null_pointer_node,\n-\t\t\t\t\t     null_pointer_node,\n-\t\t\t\t\t     integer_zero_node);\n-\t\t  tmp = fold_build3_loc (input_location, COND_EXPR,\n-\t\t\t\t\t void_type_node, cond, tmp,\n-\t\t\t\t\t build_empty_stmt (input_location));\n+\t\t  if (c->caf_token)\n+\t\t    caf_token = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t\t\t TREE_TYPE (c->caf_token),\n+\t\t\t\t\t\t decl, c->caf_token, NULL_TREE);\n+\t\t  else if (attr->dimension && !attr->proc_pointer)\n+\t\t    caf_token = gfc_conv_descriptor_token (comp);\n \t\t}\n+\t      if (attr->dimension && !attr->codimension && !attr->proc_pointer)\n+\t\t/* When this is an array but not in conjunction with a coarray\n+\t\t   then add the data-ref.  For coarray'ed arrays the data-ref\n+\t\t   is added by deallocate_with_status.  */\n+\t\tcomp = gfc_conv_descriptor_data_get (comp);\n \n-\t      gfc_add_expr_to_block (&tmpblock, tmp);\n-\t    }\n-\t  else if (c->attr.allocatable && !c->attr.codimension && !same_type)\n-\t    {\n-\t      /* Allocatable scalar components.  */\n-\t      if (comp == NULL_TREE)\n-\t\tcomp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n-\t\t\t\t\tdecl, cdecl, NULL_TREE);\n-\n-\t      tmp = gfc_deallocate_scalar_with_status (comp, NULL_TREE,\n-\t\t\t\t\t\t       NULL_TREE, true, NULL,\n-\t\t\t\t\t\t       c->ts);\n-\t      gfc_add_expr_to_block (&tmpblock, tmp);\n-\t      called_dealloc_with_status = true;\n+\t      tmp = gfc_deallocate_with_status (comp, NULL_TREE, NULL_TREE,\n+\t\t\t\t\t\tNULL_TREE, NULL_TREE, true,\n+\t\t\t\t\t\tNULL, caf_dereg_mode,\n+\t\t\t\t\t\tadd_when_allocated, caf_token);\n \n-\t      tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n-\t\t\t\t     void_type_node, comp,\n-\t\t\t\t     build_int_cst (TREE_TYPE (comp), 0));\n \t      gfc_add_expr_to_block (&tmpblock, tmp);\n \t    }\n-\t  else if (c->attr.allocatable && !c->attr.codimension)\n+\t  else if (attr->allocatable && !attr->codimension\n+\t\t   && !deallocate_called)\n \t    {\n \t      /* Case of recursive allocatable derived types.  */\n \t      tree is_allocated;\n \t      tree ubound;\n \t      tree cdesc;\n-\t      tree data;\n \t      stmtblock_t dealloc_block;\n \n \t      gfc_init_block (&dealloc_block);\n+\t      if (add_when_allocated)\n+\t\tgfc_add_expr_to_block (&dealloc_block, add_when_allocated);\n \n \t      /* Convert the component into a rank 1 descriptor type.  */\n-\t      if (comp == NULL_TREE)\n-\t\tcomp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n-\t\t\t\t\tdecl, cdecl, NULL_TREE);\n-\n-\t      if (c->attr.dimension)\n+\t      if (attr->dimension)\n \t\t{\n \t\t  tmp = gfc_get_element_type (TREE_TYPE (comp));\n-\t\t  ubound = gfc_full_array_size (&dealloc_block, comp, c->as->rank);\n+\t\t  ubound = gfc_full_array_size (&dealloc_block, comp,\n+\t\t\t\t\t\tc->ts.type == BT_CLASS\n+\t\t\t\t\t\t? CLASS_DATA (c)->as->rank\n+\t\t\t\t\t\t: c->as->rank);\n \t\t}\n \t      else\n \t\t{\n@@ -8405,12 +8335,10 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      gfc_conv_descriptor_ubound_set (&dealloc_block, cdesc,\n \t\t\t\t\t      gfc_index_zero_node, ubound);\n \n-\t      if (c->attr.dimension)\n-\t\tdata = gfc_conv_descriptor_data_get (comp);\n-\t      else\n-\t\tdata = comp;\n+\t      if (attr->dimension)\n+\t\tcomp = gfc_conv_descriptor_data_get (comp);\n \n-\t      gfc_conv_descriptor_data_set (&dealloc_block, cdesc, data);\n+\t      gfc_conv_descriptor_data_set (&dealloc_block, cdesc, comp);\n \n \t      /* Now call the deallocator.  */\n \t      vtab = gfc_find_vtab (&c->ts);\n@@ -8420,10 +8348,10 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      dealloc_fndecl = gfc_vptr_deallocate_get (tmp);\n \t      dealloc_fndecl = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\t\t    dealloc_fndecl);\n-\t      tmp = build_int_cst (TREE_TYPE (data), 0);\n+\t      tmp = build_int_cst (TREE_TYPE (comp), 0);\n \t      is_allocated = fold_build2_loc (input_location, NE_EXPR,\n \t\t\t\t\t      boolean_type_node, tmp,\n-\t\t\t\t\t      data);\n+\t\t\t\t\t      comp);\n \t      cdesc = gfc_build_addr_expr (NULL_TREE, cdesc);\n \n \t      tmp = build_call_expr_loc (input_location,\n@@ -8438,49 +8366,20 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t     build_empty_stmt (input_location));\n \n \t      gfc_add_expr_to_block (&tmpblock, tmp);\n-\n-\t      gfc_add_modify (&tmpblock, data,\n-\t\t\t      build_int_cst (TREE_TYPE (data), 0));\n \t    }\n+\t  else if (add_when_allocated)\n+\t    gfc_add_expr_to_block (&tmpblock, add_when_allocated);\n \n-\t  else if (c->ts.type == BT_CLASS && CLASS_DATA (c)->attr.allocatable\n-\t\t   && (!CLASS_DATA (c)->attr.codimension\n-\t\t    || !caf_enabled (caf_mode)))\n+\t  if (c->ts.type == BT_CLASS && attr->allocatable\n+\t      && (!attr->codimension || !caf_enabled (caf_mode)))\n \t    {\n-\t      /* Allocatable CLASS components.  */\n-\n-\t      /* Add reference to '_data' component.  */\n-\t      tmp = CLASS_DATA (c)->backend_decl;\n-\t      comp = fold_build3_loc (input_location, COMPONENT_REF,\n-\t\t\t\t      TREE_TYPE (tmp), comp, tmp, NULL_TREE);\n-\n-\t      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (comp)))\n-\t\ttmp = gfc_trans_dealloc_allocated (comp, NULL,\n-\t\t\t\t\t\tCLASS_DATA (c)->attr.codimension\n-\t\t\t\t\t\t? GFC_CAF_COARRAY_DEREGISTER\n-\t\t\t\t\t\t: GFC_CAF_COARRAY_NOCOARRAY);\n-\t      else\n-\t\t{\n-\t\t  tmp = gfc_deallocate_scalar_with_status (comp, NULL_TREE,\n-\t\t\t\t\t\t\t   NULL_TREE, true,\n-\t\t\t\t\t\t\t   NULL,\n-\t\t\t\t\t\t\t   CLASS_DATA (c)->ts);\n-\t\t  gfc_add_expr_to_block (&tmpblock, tmp);\n-\t\t  called_dealloc_with_status = true;\n-\n-\t\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n-\t\t\t\t\t void_type_node, comp,\n-\t\t\t\t\t build_int_cst (TREE_TYPE (comp), 0));\n-\t\t}\n-\t      gfc_add_expr_to_block (&tmpblock, tmp);\n-\n \t      /* Finally, reset the vptr to the declared type vtable and, if\n \t\t necessary reset the _len field.\n \n \t\t First recover the reference to the component and obtain\n \t\t the vptr.  */\n \t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n-\t\t\t\t     decl, cdecl, NULL_TREE);\n+\t\t\t\t      decl, cdecl, NULL_TREE);\n \t      tmp = gfc_class_vptr_get (comp);\n \n \t      if (UNLIMITED_POLY (c))\n@@ -8507,22 +8406,6 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t}\n \t    }\n \n-\t  if (cmp_has_alloc_comps\n-\t\t&& !c->attr.pointer && !c->attr.proc_pointer\n-\t\t&& !same_type\n-\t\t&& !called_dealloc_with_status)\n-\t    {\n-\t      /* Do not deallocate the components of ultimate pointer\n-\t\t components or iteratively call self if call has been made\n-\t\t to gfc_trans_dealloc_allocated  */\n-\t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n-\t\t\t\t      decl, cdecl, NULL_TREE);\n-\t      rank = c->as ? c->as->rank : 0;\n-\t      tmp = structure_alloc_comps (c->ts.u.derived, comp, NULL_TREE,\n-\t\t\t\t\t   rank, purpose, caf_mode);\n-\t      gfc_add_expr_to_block (&fnblock, tmp);\n-\t    }\n-\n \t  /* Now add the deallocation of this component.  */\n \t  gfc_add_block_to_block (&fnblock, &tmpblock);\n \t  break;\n@@ -9723,10 +9606,11 @@ gfc_trans_deferred_array (gfc_symbol * sym, gfc_wrapped_block * block)\n     {\n       gfc_expr *e;\n       e = has_finalizer ? gfc_lval_expr_from_sym (sym) : NULL;\n-      tmp = gfc_trans_dealloc_allocated (sym->backend_decl, e,\n-\t\t\t\t\t sym->attr.codimension\n-\t\t\t\t\t ? GFC_CAF_COARRAY_DEREGISTER\n-\t\t\t\t\t : GFC_CAF_COARRAY_NOCOARRAY);\n+      tmp = gfc_deallocate_with_status (sym->backend_decl, NULL_TREE, NULL_TREE,\n+\t\t\t\t\tNULL_TREE, NULL_TREE, true, e,\n+\t\t\t\t\tsym->attr.codimension\n+\t\t\t\t\t? GFC_CAF_COARRAY_DEREGISTER\n+\t\t\t\t\t: GFC_CAF_COARRAY_NOCOARRAY);\n       if (e)\n \tgfc_free_expr (e);\n       gfc_add_expr_to_block (&cleanup, tmp);"}, {"sha": "ab0a6dee972ae056792d253a0e9f40be436174cf", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=39da58667d94ab210cb6918fb8f528aa6aabfbb2", "patch": "@@ -18,9 +18,6 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* Generate code to free an array.  */\n-tree gfc_array_deallocate (tree, tree, tree, tree, tree, gfc_expr*, int c = -2);\n-\n /* Generate code to initialize and allocate an array.  Statements are added to\n    se, which should contain an expression for the array descriptor.  */\n bool gfc_array_allocate (gfc_se *, gfc_expr *, tree, tree, tree, tree,\n@@ -41,8 +38,6 @@ void gfc_trans_auto_array_allocation (tree, gfc_symbol *, gfc_wrapped_block *);\n void gfc_trans_dummy_array_bias (gfc_symbol *, tree, gfc_wrapped_block *);\n /* Generate entry and exit code for g77 calling convention arrays.  */\n void gfc_trans_g77_array (gfc_symbol *, gfc_wrapped_block *);\n-/* Generate code to deallocate an array, if it is allocated.  */\n-tree gfc_trans_dealloc_allocated (tree, gfc_expr *, int);\n \n tree gfc_full_array_size (stmtblock_t *, tree, int);\n "}, {"sha": "cbfad0babd90a6feabad86668f9bd0e2aefaa2f5", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=39da58667d94ab210cb6918fb8f528aa6aabfbb2", "patch": "@@ -5451,8 +5451,12 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t{\n \t\t  tmp = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\t     parmse.expr);\n-\t\t  tmp = gfc_trans_dealloc_allocated (tmp, e,\n-\t\t\t\t\t\t     GFC_CAF_COARRAY_NOCOARRAY);\n+\t\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))\n+\t\t    tmp = gfc_conv_descriptor_data_get (tmp);\n+\t\t  tmp = gfc_deallocate_with_status (tmp, NULL_TREE, NULL_TREE,\n+\t\t\t\t\t\t    NULL_TREE, NULL_TREE, true,\n+\t\t\t\t\t\t    e,\n+\t\t\t\t\t\t    GFC_CAF_COARRAY_NOCOARRAY);\n \t\t  if (fsym->attr.optional\n \t\t      && e->expr_type == EXPR_VARIABLE\n \t\t      && e->symtree->n.sym->attr.optional)"}, {"sha": "6bc2dcdbaebeb8b978cba1905b6d0aeb03c52ac4", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=39da58667d94ab210cb6918fb8f528aa6aabfbb2", "patch": "@@ -420,8 +420,11 @@ gfc_walk_alloc_comps (tree decl, tree dest, tree var,\n \t  if (GFC_DESCRIPTOR_TYPE_P (ftype)\n \t      && GFC_TYPE_ARRAY_AKIND (ftype) == GFC_ARRAY_ALLOCATABLE)\n \t    {\n-\t      tem = gfc_trans_dealloc_allocated (unshare_expr (declf), NULL,\n-\t\t\t\t\t\t GFC_CAF_COARRAY_NOCOARRAY);\n+\t      tem = gfc_conv_descriptor_data_get (unshare_expr (declf));\n+\t      tem = gfc_deallocate_with_status (tem, NULL_TREE, NULL_TREE,\n+\t\t\t\t\t\tNULL_TREE, NULL_TREE, true,\n+\t\t\t\t\t\tNULL,\n+\t\t\t\t\t\tGFC_CAF_COARRAY_NOCOARRAY);\n \t      gfc_add_expr_to_block (&block, gfc_omp_unshare_expr (tem));\n \t    }\n \t  else if (GFC_DECL_GET_SCALAR_ALLOCATABLE (field))\n@@ -810,10 +813,13 @@ gfc_omp_clause_assign_op (tree clause, tree dest, tree src)\n     {\n       gfc_init_block (&cond_block);\n       if (GFC_DESCRIPTOR_TYPE_P (type))\n-\tgfc_add_expr_to_block (&cond_block,\n-\t\t\t       gfc_trans_dealloc_allocated (unshare_expr (dest),\n-\t\t\t\t\t\t\t    NULL,\n-\t\t\t\t\t\t    GFC_CAF_COARRAY_NOCOARRAY));\n+\t{\n+\t  tree tmp = gfc_conv_descriptor_data_get (unshare_expr (dest));\n+\t  tmp = gfc_deallocate_with_status (tmp, NULL_TREE, NULL_TREE,\n+\t\t\t\t\t    NULL_TREE, NULL_TREE, true, NULL,\n+\t\t\t\t\t    GFC_CAF_COARRAY_NOCOARRAY);\n+\t  gfc_add_expr_to_block (&cond_block, tmp);\n+\t}\n       else\n \t{\n \t  destptr = gfc_evaluate_now (destptr, &cond_block);\n@@ -987,9 +993,14 @@ gfc_omp_clause_dtor (tree clause, tree decl)\n     }\n \n   if (GFC_DESCRIPTOR_TYPE_P (type))\n-    /* Allocatable arrays in FIRSTPRIVATE/LASTPRIVATE etc. clauses need\n-       to be deallocated if they were allocated.  */\n-    tem = gfc_trans_dealloc_allocated (decl, NULL, GFC_CAF_COARRAY_NOCOARRAY);\n+    {\n+      /* Allocatable arrays in FIRSTPRIVATE/LASTPRIVATE etc. clauses need\n+\t to be deallocated if they were allocated.  */\n+      tem = gfc_conv_descriptor_data_get (decl);\n+      tem = gfc_deallocate_with_status (tem, NULL_TREE, NULL_TREE, NULL_TREE,\n+\t\t\t\t\tNULL_TREE, true, NULL,\n+\t\t\t\t\tGFC_CAF_COARRAY_NOCOARRAY);\n+    }\n   else\n     tem = gfc_call_free (decl);\n   tem = gfc_omp_unshare_expr (tem);"}, {"sha": "5ca716bebebfef02fd57650452037ce9649f2456", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=39da58667d94ab210cb6918fb8f528aa6aabfbb2", "patch": "@@ -6489,8 +6489,9 @@ gfc_trans_deallocate (gfc_code *code)\n \t\t    : GFC_CAF_COARRAY_DEREGISTER;\n \t      else\n \t\tcaf_dtype = GFC_CAF_COARRAY_NOCOARRAY;\n-\t      tmp = gfc_array_deallocate (se.expr, pstat, errmsg, errlen,\n-\t\t\t\t\t  label_finish, expr, caf_dtype);\n+\t      tmp = gfc_deallocate_with_status (se.expr, pstat, errmsg, errlen,\n+\t\t\t\t\t\tlabel_finish, false, expr,\n+\t\t\t\t\t\tcaf_dtype);\n \t      gfc_add_expr_to_block (&se.pre, tmp);\n \t    }\n \t  else if (TREE_CODE (se.expr) == COMPONENT_REF"}, {"sha": "e5dd98695fe1ff16f888332c5544b843d2b2ac1e", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 63, "deletions": 35, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=39da58667d94ab210cb6918fb8f528aa6aabfbb2", "patch": "@@ -1281,31 +1281,58 @@ tree\n gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n \t\t\t    tree errlen, tree label_finish,\n \t\t\t    bool can_fail, gfc_expr* expr,\n-\t\t\t    int coarray_dealloc_mode)\n+\t\t\t    int coarray_dealloc_mode, tree add_when_allocated,\n+\t\t\t    tree caf_token)\n {\n   stmtblock_t null, non_null;\n   tree cond, tmp, error;\n   tree status_type = NULL_TREE;\n-  tree caf_decl = NULL_TREE;\n+  tree token = NULL_TREE;\n   gfc_coarray_deregtype caf_dereg_type = GFC_CAF_COARRAY_DEREGISTER;\n \n   if (coarray_dealloc_mode >= GFC_CAF_COARRAY_ANALYZE)\n     {\n-      gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (pointer)));\n-      caf_decl = pointer;\n-      pointer = gfc_conv_descriptor_data_get (caf_decl);\n-      STRIP_NOPS (pointer);\n-      if (coarray_dealloc_mode == GFC_CAF_COARRAY_ANALYZE)\n+      if (flag_coarray == GFC_FCOARRAY_LIB)\n \t{\n-\t  bool comp_ref;\n-\t  if (expr && !gfc_caf_attr (expr, false, &comp_ref).coarray_comp\n-\t      && comp_ref)\n-\t    caf_dereg_type = GFC_CAF_COARRAY_DEALLOCATE_ONLY;\n-\t  // else do a deregister as set by default.\n+\t  if (caf_token)\n+\t    token = caf_token;\n+\t  else\n+\t    {\n+\t      tree caf_type, caf_decl = pointer;\n+\t      pointer = gfc_conv_descriptor_data_get (caf_decl);\n+\t      caf_type = TREE_TYPE (caf_decl);\n+\t      STRIP_NOPS (pointer);\n+\t      if (GFC_DESCRIPTOR_TYPE_P (caf_type)\n+\t\t  && GFC_TYPE_ARRAY_AKIND (caf_type) == GFC_ARRAY_ALLOCATABLE)\n+\t\ttoken = gfc_conv_descriptor_token (caf_decl);\n+\t      else if (DECL_LANG_SPECIFIC (caf_decl)\n+\t\t       && GFC_DECL_TOKEN (caf_decl) != NULL_TREE)\n+\t\ttoken = GFC_DECL_TOKEN (caf_decl);\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (GFC_ARRAY_TYPE_P (caf_type)\n+\t\t\t      && GFC_TYPE_ARRAY_CAF_TOKEN (caf_type)\n+\t\t\t\t != NULL_TREE);\n+\t\t  token = GFC_TYPE_ARRAY_CAF_TOKEN (caf_type);\n+\t\t}\n+\t    }\n+\n+\t  if (coarray_dealloc_mode == GFC_CAF_COARRAY_ANALYZE)\n+\t    {\n+\t      bool comp_ref;\n+\t      if (expr && !gfc_caf_attr (expr, false, &comp_ref).coarray_comp\n+\t\t  && comp_ref)\n+\t\tcaf_dereg_type = GFC_CAF_COARRAY_DEALLOCATE_ONLY;\n+\t      // else do a deregister as set by default.\n+\t    }\n+\t  else\n+\t    caf_dereg_type = (enum gfc_coarray_deregtype) coarray_dealloc_mode;\n \t}\n-      else\n-\tcaf_dereg_type = (enum gfc_coarray_deregtype) coarray_dealloc_mode;\n+      else if (flag_coarray == GFC_FCOARRAY_SINGLE)\n+\tpointer = gfc_conv_descriptor_data_get (pointer);\n     }\n+  else if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (pointer)))\n+    pointer = gfc_conv_descriptor_data_get (pointer);\n \n   cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, pointer,\n \t\t\t  build_int_cst (TREE_TYPE (pointer), 0));\n@@ -1348,6 +1375,8 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n \n   /* When POINTER is not NULL, we free it.  */\n   gfc_start_block (&non_null);\n+  if (add_when_allocated)\n+    gfc_add_expr_to_block (&non_null, add_when_allocated);\n   gfc_add_finalizer_call (&non_null, expr);\n   if (coarray_dealloc_mode == GFC_CAF_COARRAY_NOCOARRAY\n       || flag_coarray != GFC_FCOARRAY_LIB)\n@@ -1356,6 +1385,8 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n \t\t\t\t builtin_decl_explicit (BUILT_IN_FREE), 1,\n \t\t\t\t fold_convert (pvoid_type_node, pointer));\n       gfc_add_expr_to_block (&non_null, tmp);\n+      gfc_add_modify (&non_null, pointer, build_int_cst (TREE_TYPE (pointer),\n+\t\t\t\t\t\t\t 0));\n \n       if (status != NULL_TREE && !integer_zerop (status))\n \t{\n@@ -1378,8 +1409,7 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n     }\n   else\n     {\n-      tree caf_type, token, cond2;\n-      tree pstat = null_pointer_node;\n+      tree cond2, pstat = null_pointer_node;\n \n       if (errmsg == NULL_TREE)\n \t{\n@@ -1394,27 +1424,12 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n \t    errmsg = gfc_build_addr_expr (NULL_TREE, errmsg);\n \t}\n \n-      caf_type = TREE_TYPE (caf_decl);\n-\n       if (status != NULL_TREE && !integer_zerop (status))\n \t{\n \t  gcc_assert (status_type == integer_type_node);\n \t  pstat = status;\n \t}\n \n-      if (GFC_DESCRIPTOR_TYPE_P (caf_type)\n-\t  && GFC_TYPE_ARRAY_AKIND (caf_type) == GFC_ARRAY_ALLOCATABLE)\n-\ttoken = gfc_conv_descriptor_token (caf_decl);\n-      else if (DECL_LANG_SPECIFIC (caf_decl)\n-\t       && GFC_DECL_TOKEN (caf_decl) != NULL_TREE)\n-\ttoken = GFC_DECL_TOKEN (caf_decl);\n-      else\n-\t{\n-\t  gcc_assert (GFC_ARRAY_TYPE_P (caf_type)\n-\t\t      && GFC_TYPE_ARRAY_CAF_TOKEN (caf_type) != NULL_TREE);\n-\t  token = GFC_TYPE_ARRAY_CAF_TOKEN (caf_type);\n-\t}\n-\n       token = gfc_build_addr_expr  (NULL_TREE, token);\n       gcc_assert (caf_dereg_type > GFC_CAF_COARRAY_ANALYZE);\n       tmp = build_call_expr_loc (input_location,\n@@ -1435,16 +1450,23 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n       if (status != NULL_TREE)\n \t{\n \t  tree stat = build_fold_indirect_ref_loc (input_location, status);\n+\t  tree nullify = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t\t  void_type_node, pointer,\n+\t\t\t\t\t  build_int_cst (TREE_TYPE (pointer),\n+\t\t\t\t\t\t\t 0));\n \n \t  TREE_USED (label_finish) = 1;\n \t  tmp = build1_v (GOTO_EXPR, label_finish);\n \t  cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n \t\t\t\t   stat, build_zero_cst (TREE_TYPE (stat)));\n \t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n \t\t\t\t gfc_unlikely (cond2, PRED_FORTRAN_REALLOC),\n-\t\t\t\t tmp, build_empty_stmt (input_location));\n+\t\t\t\t tmp, nullify);\n \t  gfc_add_expr_to_block (&non_null, tmp);\n \t}\n+      else\n+\tgfc_add_modify (&non_null, pointer, build_int_cst (TREE_TYPE (pointer),\n+\t\t\t\t\t\t\t   0));\n     }\n \n   return fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n@@ -1516,11 +1538,17 @@ gfc_deallocate_scalar_with_status (tree pointer, tree status, tree label_finish,\n   finalizable = gfc_add_finalizer_call (&non_null, expr);\n   if (!finalizable && ts.type == BT_DERIVED && ts.u.derived->attr.alloc_comp)\n     {\n-      if (coarray)\n+      int caf_mode = coarray\n+\t  ? ((caf_dereg_type == GFC_CAF_COARRAY_DEALLOCATE_ONLY\n+\t      ? GFC_STRUCTURE_CAF_MODE_DEALLOC_ONLY : 0)\n+\t     | GFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY\n+\t     | GFC_STRUCTURE_CAF_MODE_IN_COARRAY)\n+\t  : 0;\n+      if (coarray && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (pointer)))\n \ttmp = gfc_conv_descriptor_data_get (pointer);\n       else\n \ttmp = build_fold_indirect_ref_loc (input_location, pointer);\n-      tmp = gfc_deallocate_alloc_comp (ts.u.derived, tmp, 0);\n+      tmp = gfc_deallocate_alloc_comp (ts.u.derived, tmp, 0, caf_mode);\n       gfc_add_expr_to_block (&non_null, tmp);\n     }\n \n@@ -1573,7 +1601,7 @@ gfc_deallocate_scalar_with_status (tree pointer, tree status, tree label_finish,\n       gfc_add_expr_to_block (&non_null, tmp);\n \n       /* It guarantees memory consistency within the same segment.  */\n-      tmp = gfc_build_string_const (strlen (\"memory\")+1, \"memory\"),\n+      tmp = gfc_build_string_const (strlen (\"memory\")+1, \"memory\");\n       tmp = build5_loc (input_location, ASM_EXPR, void_type_node,\n \t\t\tgfc_build_string_const (1, \"\"), NULL_TREE, NULL_TREE,\n \t\t\ttree_cons (NULL_TREE, tmp, NULL_TREE), NULL_TREE);"}, {"sha": "bfc2a24d0fa0a5b55652ce31a58fbf49bb74d610", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=39da58667d94ab210cb6918fb8f528aa6aabfbb2", "patch": "@@ -719,7 +719,8 @@ void gfc_allocate_using_malloc (stmtblock_t *, tree, tree, tree);\n \n /* Generate code to deallocate an array.  */\n tree gfc_deallocate_with_status (tree, tree, tree, tree, tree, bool,\n-\t\t\t\t gfc_expr *, int);\n+\t\t\t\t gfc_expr *, int, tree a = NULL_TREE,\n+\t\t\t\t tree c = NULL_TREE);\n tree gfc_deallocate_scalar_with_status (tree, tree, tree, bool, gfc_expr*,\n \t\t\t\t\tgfc_typespec, bool c = false);\n "}, {"sha": "33e5b378800a0efb5acc0ac80c6d6a7a49c391ba", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=39da58667d94ab210cb6918fb8f528aa6aabfbb2", "patch": "@@ -1,3 +1,11 @@\n+2016-12-09  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* gfortran.dg/coarray_alloc_comp_3.f08: New test.\n+\t* gfortran.dg/coarray_alloc_comp_4.f08: New test.\n+\t* gfortran.dg/finalize_18.f90: Add count for additional guard against\n+\taccessing null-pointer.\n+\t* gfortran.dg/proc_ptr_comp_47.f90: New test.\n+\n 2016-12-09  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/78550"}, {"sha": "8d2e7939b6e0920e93a13befb9a5e5c9cab45289", "filename": "gcc/testsuite/gfortran.dg/coarray_alloc_comp_3.f08", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_3.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_3.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_3.f08?ref=39da58667d94ab210cb6918fb8f528aa6aabfbb2", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=lib -lcaf_single\" }\n+!\n+! Contributed by Andre Vehreschild\n+! Check that manually freeing components does not lead to a runtime crash,\n+! when the auto-deallocation is taking care.\n+\n+program coarray_alloc_comp_3\n+  implicit none\n+\n+  type dt\n+    integer, allocatable :: i\n+  end type dt\n+\n+  type linktype\n+    type(dt), allocatable :: link\n+  end type linktype\n+\n+  type(linktype), allocatable :: obj[:]\n+\n+  allocate(obj[*])\n+  allocate(obj%link)\n+\n+  if (.not. allocated(obj)) error stop \"Test failed. 'obj' not allocated.\"\n+  if (.not. allocated(obj%link)) error stop \"Test failed. 'obj%link' not allocated.\"\n+  if (allocated(obj%link%i)) error stop \"Test failed. 'obj%link%i' already allocated.\"\n+\n+  allocate(obj%link%i, source = 42)\n+\n+  if (.not. allocated(obj)) error stop \"Test failed. 'obj' not allocated.\"\n+  if (.not. allocated(obj%link)) error stop \"Test failed. 'obj%link' not allocated.\"\n+  if (.not. allocated(obj%link%i)) error stop \"Test failed. 'obj%link%i' not allocated.\"\n+  if (obj%link%i /= 42) error stop \"Test failed. obj%link%i /= 42.\"\n+\n+  deallocate(obj%link%i)\n+\n+  if (allocated(obj%link%i)) error stop \"Test failed. 'obj%link%i' still allocated.\"\n+  if (.not. allocated(obj%link)) error stop \"Test failed. 'obj%link' no longer allocated.\"\n+  if (.not. allocated(obj)) error stop \"Test failed. 'obj' no longer allocated.\"\n+\n+  ! Freeing this object, lead to crash with older gfortran...\n+  deallocate(obj%link)\n+\n+  if (allocated(obj%link)) error stop \"Test failed. 'obj%link' still allocated.\"\n+  if (.not. allocated(obj)) error stop \"Test failed. 'obj' no longer allocated.\"\n+\n+  ! ... when auto-deallocating the allocated components.\n+  deallocate(obj)\n+\n+  if (allocated(obj)) error stop \"Test failed. 'obj' still allocated.\"\n+end program"}, {"sha": "517bb188733887e4ea1806a4ee61ee2bf68fd5ec", "filename": "gcc/testsuite/gfortran.dg/coarray_alloc_comp_4.f08", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_4.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_4.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_4.f08?ref=39da58667d94ab210cb6918fb8f528aa6aabfbb2", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=lib -fdump-tree-original\" }\n+!\n+! Contributed by Andre Vehreschild\n+! Check that sub-components are caf_deregistered and not freed.\n+\n+program coarray_alloc_comp_3\n+  implicit none\n+\n+  type dt\n+    integer, allocatable :: i\n+  end type dt\n+\n+  type linktype\n+    type(dt), allocatable :: link\n+  end type linktype\n+\n+  type(linktype) :: obj[*]\n+\n+  allocate(obj%link)\n+\n+  if (.not. allocated(obj%link)) error stop \"Test failed. 'obj%link' not allocated.\"\n+  if (allocated(obj%link%i)) error stop \"Test failed. 'obj%link%i' already allocated.\"\n+\n+  allocate(obj%link%i, source = 42)\n+\n+  if (.not. allocated(obj%link)) error stop \"Test failed. 'obj%link' not allocated.\"\n+  if (.not. allocated(obj%link%i)) error stop \"Test failed. 'obj%link%i' not allocated.\"\n+  if (obj%link%i /= 42) error stop \"Test failed. obj%link%i /= 42.\"\n+\n+  deallocate(obj%link%i)\n+\n+  if (allocated(obj%link%i)) error stop \"Test failed. 'obj%link%i' still allocated.\"\n+  if (.not. allocated(obj%link)) error stop \"Test failed. 'obj%link' no longer allocated.\"\n+\n+  ! Freeing this object, lead to crash with older gfortran...\n+  deallocate(obj%link)\n+\n+  if (allocated(obj%link)) error stop \"Test failed. 'obj%link' still allocated.\"\n+end program\n+! Ensure, that three calls to deregister are present.\n+! { dg-final { scan-tree-dump-times \"_caf_deregister\" 3 \"original\" } }\n+! And ensure that no calls to builtin_free are made.\n+! { dg-final { scan-tree-dump-not \"_builtin_free\" \"original\" } }"}, {"sha": "3e6433276286ea4f2ac26f64b47eb1768ad67014", "filename": "gcc/testsuite/gfortran.dg/finalize_18.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_18.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_18.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_18.f90?ref=39da58667d94ab210cb6918fb8f528aa6aabfbb2", "patch": "@@ -33,8 +33,8 @@ end module m\n \n ! { dg-final { scan-tree-dump-times \"if \\\\(y.aa != 0B\\\\)\" 2 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"if \\\\(y.cc._data != 0B\\\\)\" 2 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"if \\\\(\\\\(struct t\\\\\\[0:\\\\\\] . restrict\\\\) y.bb.data != 0B\\\\)\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"if \\\\(\\\\(struct t\\\\\\[0:\\\\\\] . restrict\\\\) y.dd._data.data != 0B\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"if \\\\(\\\\(struct t\\\\\\[0:\\\\\\] . restrict\\\\) y.bb.data != 0B\\\\)\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"if \\\\(\\\\(struct t\\\\\\[0:\\\\\\] . restrict\\\\) y.dd._data.data != 0B\\\\)\" 2 \"original\" } }\n \n ! { dg-final { scan-tree-dump-times \"desc.\\[0-9\\]+.data = \\\\(void . restrict\\\\) y.aa;\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"desc.\\[0-9\\]+.data = \\\\(void . restrict\\\\) y.cc._data;\" 1 \"original\" } }"}, {"sha": "1d5210019ffffef97957d2df0b59ff6ee045a9b1", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_47.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_47.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39da58667d94ab210cb6918fb8f528aa6aabfbb2/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_47.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_47.f90?ref=39da58667d94ab210cb6918fb8f528aa6aabfbb2", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do run }\n+\n+MODULE distribution_types\n+  ABSTRACT INTERFACE\n+     FUNCTION dist_map_blk_to_proc_func ( row, col, nrow_tot, ncol_tot, proc_grid ) RESULT( reslt )\n+       INTEGER, INTENT( IN ) :: row, col, nrow_tot, ncol_tot\n+       INTEGER, DIMENSION( : ), INTENT( IN ) :: proc_grid\n+       INTEGER, DIMENSION( : ), ALLOCATABLE :: reslt\n+     END FUNCTION dist_map_blk_to_proc_func\n+  END INTERFACE\n+  TYPE, PUBLIC :: dist_type\n+     INTEGER, DIMENSION( : ), ALLOCATABLE :: task_coords\n+     PROCEDURE( dist_map_blk_to_proc_func ), NOPASS, POINTER :: map_blk_to_proc => NULL( )\n+  END TYPE dist_type\n+END MODULE distribution_types\n+\n+MODULE sparse_matrix_types\n+  USE distribution_types,  ONLY : dist_type\n+  TYPE, PUBLIC :: sm_type\n+     TYPE( dist_type ) :: dist\n+  END TYPE sm_type\n+END MODULE sparse_matrix_types\n+\n+PROGRAM comp_proc_ptr_test\n+  USE sparse_matrix_types,      ONLY : sm_type\n+\n+ call  sm_multiply_a ()\n+CONTAINS\n+  SUBROUTINE sm_multiply_a (  )\n+    INTEGER :: n_push_tot, istat\n+    TYPE( sm_type ), DIMENSION( : ), ALLOCATABLE :: matrices_a, matrices_b\n+    n_push_tot =2\n+    ALLOCATE( matrices_a( n_push_tot + 1 ), matrices_b( n_push_tot + 1), STAT=istat )\n+    if (istat /= 0) call abort()\n+    if (.not. allocated(matrices_a)) call abort()\n+    if (.not. allocated(matrices_b)) call abort()\n+    if (associated(matrices_a(1)%dist%map_blk_to_proc)) call abort()\n+  END SUBROUTINE sm_multiply_a\n+END PROGRAM comp_proc_ptr_test\n+"}]}