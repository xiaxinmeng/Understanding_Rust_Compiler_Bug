{"sha": "e3884b71825937aa8f9dcf7ae75f1ff78748984c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM4ODRiNzE4MjU5MzdhYThmOWRjZjdhZTc1ZjFmZjc4NzQ4OTg0Yw==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1999-02-16T10:26:57Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1999-02-16T10:26:57Z"}, "message": "parse.y (valid_builtin_assignconv_identity_widening_p): Got rid of an ancient workaround.\n\nThu Feb 11 21:25:51 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \t* parse.y (valid_builtin_assignconv_identity_widening_p): Got rid\n \tof an ancient workaround.\n\nFrom-SVN: r25238", "tree": {"sha": "ac2a6e215bf9538c8dbe7a7ce4373b20dffaea45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac2a6e215bf9538c8dbe7a7ce4373b20dffaea45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3884b71825937aa8f9dcf7ae75f1ff78748984c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3884b71825937aa8f9dcf7ae75f1ff78748984c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3884b71825937aa8f9dcf7ae75f1ff78748984c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3884b71825937aa8f9dcf7ae75f1ff78748984c/comments", "author": null, "committer": null, "parents": [{"sha": "d462a870b73d19c262574cb3ae2c7a72b5b93ecf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d462a870b73d19c262574cb3ae2c7a72b5b93ecf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d462a870b73d19c262574cb3ae2c7a72b5b93ecf"}], "stats": {"total": 24, "additions": 8, "deletions": 16}, "files": [{"sha": "6b4035c17e8ca2dc8425371ab24740bedde49029", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3884b71825937aa8f9dcf7ae75f1ff78748984c/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3884b71825937aa8f9dcf7ae75f1ff78748984c/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=e3884b71825937aa8f9dcf7ae75f1ff78748984c", "patch": "@@ -1,3 +1,8 @@\n+Thu Feb 11 21:25:51 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+ \n+ \t* parse.y (valid_builtin_assignconv_identity_widening_p): Got rid\n+ \tof an ancient workaround.\n+\n Wed Feb 10 23:27:33 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* jvspec.c (xmalloc): Kill the prototype.  It does not belong"}, {"sha": "3a21252354827caba02f2da1dcc0cf5753a54d57", "filename": "gcc/java/parse.y", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3884b71825937aa8f9dcf7ae75f1ff78748984c/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3884b71825937aa8f9dcf7ae75f1ff78748984c/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=e3884b71825937aa8f9dcf7ae75f1ff78748984c", "patch": "@@ -7051,13 +7051,9 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n   /* Fix the arguments */\n   for (node = arg_list; node; node = TREE_CHAIN (node))\n     {\n-      tree current_arg = TREE_VALUE (node);\n-      /* Integer constant 0 passed as itself, not as a type */\n-      if (current_arg != integer_zero_node)\n-\tcurrent_arg = TREE_TYPE (TREE_VALUE (node));\n+      tree current_arg = TREE_TYPE (TREE_VALUE (node));\n       /* Non primitive type may have to be resolved */\n-      if (current_arg != integer_zero_node \n-\t  && !JPRIMITIVE_TYPE_P (current_arg))\n+      if (!JPRIMITIVE_TYPE_P (current_arg))\n \tresolve_and_layout (current_arg, NULL_TREE);\n       /* And promoted */\n       if (TREE_CODE (current_arg) == RECORD_TYPE)\n@@ -7097,9 +7093,6 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n       candidates = obstack_finish (&temporary_obstack);\n     }\n   /* Issue the error message */\n-  for (node = atl; node; node = TREE_CHAIN (node))\n-    if (TREE_VALUE (node) == integer_zero_node)\n-      TREE_VALUE (node) = long_type_node;\n   method = make_node (FUNCTION_TYPE);\n   TYPE_ARG_TYPES (method) = atl;\n   signature = build_java_argument_signature (method);\n@@ -8602,11 +8595,6 @@ valid_builtin_assignconv_identity_widening_p (lhs_type, rhs_type)\n   if (lhs_type == rhs_type)\n     return 1;\n \n-  /* Sometimes, instead of passing a type, we pass integer_zero_node\n-     so we know that a numeric type can accomodate it */\n-  if (JNUMERIC_TYPE_P (lhs_type) && (rhs_type == integer_zero_node))\n-    return 1;\n-\n   /* Reject non primitive types */\n   if (!JPRIMITIVE_TYPE_P (lhs_type) || !JPRIMITIVE_TYPE_P (rhs_type))\n     return 0;\n@@ -8793,8 +8781,7 @@ static int\n valid_method_invocation_conversion_p (dest, source)\n      tree dest, source;\n {\n-  return (((JPRIMITIVE_TYPE_P (source) || (source == integer_zero_node))\n-\t   && JPRIMITIVE_TYPE_P (dest)\n+  return ((JPRIMITIVE_TYPE_P (source) && JPRIMITIVE_TYPE_P (dest)\n \t   && valid_builtin_assignconv_identity_widening_p (dest, source))\n \t  || ((JREFERENCE_TYPE_P (source) || JNULLP_TYPE_P (source))\n \t      && (JREFERENCE_TYPE_P (dest) || JNULLP_TYPE_P (dest))"}]}