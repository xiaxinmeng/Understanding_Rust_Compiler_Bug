{"sha": "6e56633daae79f514b0e71f4d9849bcd8d9ce71f", "node_id": "C_kwDOANBUbNoAKDZlNTY2MzNkYWFlNzlmNTE0YjBlNzFmNGQ5ODQ5YmNkOGQ5Y2U3MWY", "commit": {"author": {"name": "Thomas Neumann", "email": "tneumann@users.sourceforge.net", "date": "2022-12-09T17:23:44Z"}, "committer": {"name": "Thomas Neumann", "email": "tneumann@users.sourceforge.net", "date": "2022-12-16T23:48:25Z"}, "message": "initialize fde objects lazily\n\nWhen registering an unwind frame with __register_frame_info_bases\nwe currently initialize that fde object eagerly. This has the\nadvantage that it is immutable afterwards and we can safely\naccess it from multiple threads, but it has the disadvantage\nthat we pay the initialization cost even if the application\nnever throws an exception.\n\nThis commit changes the logic to initialize the objects lazily.\nThe objects themselves are inserted into the b-tree when\nregistering the frame, but the sorted fde_vector is\nnot constructed yet. Only on the first time that an\nexception tries to pass through the registered code the\nobject is initialized. We notice that with a double checking,\nfirst doing a relaxed load of the sorted bit and then re-checking\nunder a mutex when the object was not initialized yet.\n\nNote that the check must implicitly be safe concering a concurrent\nframe deregistration, as trying the deregister a frame that is\non the unwinding path of a concurrent exception is inherently racy.\n\nlibgcc/ChangeLog:\n\t* unwind-dw2-fde.c: Initialize fde object lazily when\n\tthe first exception tries to pass through.", "tree": {"sha": "ca386c29cd4093b38d5b84ac429157550b2edc50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca386c29cd4093b38d5b84ac429157550b2edc50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e56633daae79f514b0e71f4d9849bcd8d9ce71f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e56633daae79f514b0e71f4d9849bcd8d9ce71f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e56633daae79f514b0e71f4d9849bcd8d9ce71f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e56633daae79f514b0e71f4d9849bcd8d9ce71f/comments", "author": {"login": "neumannt", "id": 25097991, "node_id": "MDQ6VXNlcjI1MDk3OTkx", "avatar_url": "https://avatars.githubusercontent.com/u/25097991?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neumannt", "html_url": "https://github.com/neumannt", "followers_url": "https://api.github.com/users/neumannt/followers", "following_url": "https://api.github.com/users/neumannt/following{/other_user}", "gists_url": "https://api.github.com/users/neumannt/gists{/gist_id}", "starred_url": "https://api.github.com/users/neumannt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neumannt/subscriptions", "organizations_url": "https://api.github.com/users/neumannt/orgs", "repos_url": "https://api.github.com/users/neumannt/repos", "events_url": "https://api.github.com/users/neumannt/events{/privacy}", "received_events_url": "https://api.github.com/users/neumannt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "neumannt", "id": 25097991, "node_id": "MDQ6VXNlcjI1MDk3OTkx", "avatar_url": "https://avatars.githubusercontent.com/u/25097991?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neumannt", "html_url": "https://github.com/neumannt", "followers_url": "https://api.github.com/users/neumannt/followers", "following_url": "https://api.github.com/users/neumannt/following{/other_user}", "gists_url": "https://api.github.com/users/neumannt/gists{/gist_id}", "starred_url": "https://api.github.com/users/neumannt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neumannt/subscriptions", "organizations_url": "https://api.github.com/users/neumannt/orgs", "repos_url": "https://api.github.com/users/neumannt/repos", "events_url": "https://api.github.com/users/neumannt/events{/privacy}", "received_events_url": "https://api.github.com/users/neumannt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c118c9970600117700cc12284587e0238de6bbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c118c9970600117700cc12284587e0238de6bbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c118c9970600117700cc12284587e0238de6bbe"}], "stats": {"total": 52, "additions": 41, "deletions": 11}, "files": [{"sha": "b49ee3829d5d0ef32b1a1b402e756e9a2e383994", "filename": "libgcc/unwind-dw2-fde.c", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e56633daae79f514b0e71f4d9849bcd8d9ce71f/libgcc%2Funwind-dw2-fde.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e56633daae79f514b0e71f4d9849bcd8d9ce71f/libgcc%2Funwind-dw2-fde.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind-dw2-fde.c?ref=6e56633daae79f514b0e71f4d9849bcd8d9ce71f", "patch": "@@ -63,8 +63,6 @@ release_registered_frames (void)\n \n static void\n get_pc_range (const struct object *ob, uintptr_type *range);\n-static void\n-init_object (struct object *ob);\n \n #else\n /* Without fast path frame deregistration must always succeed.  */\n@@ -76,6 +74,7 @@ static const int in_shutdown = 0;\n    by decreasing value of pc_begin.  */\n static struct object *unseen_objects;\n static struct object *seen_objects;\n+#endif\n \n #ifdef __GTHREAD_MUTEX_INIT\n static __gthread_mutex_t object_mutex = __GTHREAD_MUTEX_INIT;\n@@ -103,7 +102,6 @@ init_object_mutex_once (void)\n static __gthread_mutex_t object_mutex;\n #endif\n #endif\n-#endif\n \n /* Called from crtbegin.o to register the unwind info for an object.  */\n \n@@ -126,10 +124,7 @@ __register_frame_info_bases (const void *begin, struct object *ob,\n #endif\n \n #ifdef ATOMIC_FDE_FAST_PATH\n-  // Initialize eagerly to avoid locking later\n-  init_object (ob);\n-\n-  // And register the frame\n+  // Register the frame in the b-tree\n   uintptr_type range[2];\n   get_pc_range (ob, range);\n   btree_insert (&registered_frames, range[0], range[1] - range[0], ob);\n@@ -180,10 +175,7 @@ __register_frame_info_table_bases (void *begin, struct object *ob,\n   ob->s.b.encoding = DW_EH_PE_omit;\n \n #ifdef ATOMIC_FDE_FAST_PATH\n-  // Initialize eagerly to avoid locking later\n-  init_object (ob);\n-\n-  // And register the frame\n+  // Register the frame in the b-tree\n   uintptr_type range[2];\n   get_pc_range (ob, range);\n   btree_insert (&registered_frames, range[0], range[1] - range[0], ob);\n@@ -926,7 +918,15 @@ init_object (struct object* ob)\n   accu.linear->orig_data = ob->u.single;\n   ob->u.sort = accu.linear;\n \n+#ifdef ATOMIC_FDE_FAST_PATH\n+  // We must update the sorted bit with an atomic operation\n+  struct object tmp;\n+  tmp.s.b = ob->s.b;\n+  tmp.s.b.sorted = 1;\n+  __atomic_store (&(ob->s.b), &(tmp.s.b), __ATOMIC_RELEASE);\n+#else\n   ob->s.b.sorted = 1;\n+#endif\n }\n \n #ifdef ATOMIC_FDE_FAST_PATH\n@@ -1164,6 +1164,21 @@ search_object (struct object* ob, void *pc)\n     }\n }\n \n+#ifdef ATOMIC_FDE_FAST_PATH\n+\n+// Check if the object was already initialized\n+static inline bool\n+is_object_initialized (struct object *ob)\n+{\n+  // We have to use acquire atomics for the read, which\n+  // is a bit involved as we read from a bitfield\n+  struct object tmp;\n+  __atomic_load (&(ob->s.b), &(tmp.s.b), __ATOMIC_ACQUIRE);\n+  return tmp.s.b.sorted;\n+}\n+\n+#endif\n+\n const fde *\n _Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)\n {\n@@ -1175,6 +1190,21 @@ _Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)\n   if (!ob)\n     return NULL;\n \n+  // Initialize the object lazily\n+  if (!is_object_initialized (ob))\n+    {\n+      // Check again under mutex\n+      init_object_mutex_once ();\n+      __gthread_mutex_lock (&object_mutex);\n+\n+      if (!ob->s.b.sorted)\n+\t{\n+\t  init_object (ob);\n+\t}\n+\n+      __gthread_mutex_unlock (&object_mutex);\n+    }\n+\n   f = search_object (ob, pc);\n #else\n "}]}