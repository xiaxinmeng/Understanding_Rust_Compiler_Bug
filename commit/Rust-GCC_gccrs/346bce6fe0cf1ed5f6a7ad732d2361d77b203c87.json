{"sha": "346bce6fe0cf1ed5f6a7ad732d2361d77b203c87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ2YmNlNmZlMGNmMWVkNWY2YTdhZDczMmQyMzYxZDc3YjIwM2M4Nw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2020-06-29T16:33:23Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2020-06-29T16:37:51Z"}, "message": "middle-end: Optimize (A&C)^(B&C) to (A^B)&C in simplify_rtx (take 3).\n\n2020-06-29  Roger Sayle  <roger@nextmovesoftware.com>\ngcc/ChangeLog:\n\t* simplify-rtx.c (simplify_distributive_operation): New function\n\tto un-distribute a binary operation of two binary operations.\n\t(X & C) ^ (Y & C) to (X ^ Y) & C, when C is simple (i.e. a constant).\n\t(simplify_binary_operation_1) <IOR, XOR, AND>: Call it from here\n\twhen appropriate.\n\t(test_scalar_int_ops): New function for unit self-testing\n\tscalar integer transformations in simplify-rtx.c.\n\t(test_scalar_ops): Call test_scalar_int_ops for each integer mode.\n\t(simplify_rtx_c_tests): Call test_scalar_ops.", "tree": {"sha": "72d205ac4385f305e7d5b52f1185c33c5025389e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72d205ac4385f305e7d5b52f1185c33c5025389e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/346bce6fe0cf1ed5f6a7ad732d2361d77b203c87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/346bce6fe0cf1ed5f6a7ad732d2361d77b203c87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/346bce6fe0cf1ed5f6a7ad732d2361d77b203c87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/346bce6fe0cf1ed5f6a7ad732d2361d77b203c87/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54980635c537f3130481da2d8b1109c775db8bb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54980635c537f3130481da2d8b1109c775db8bb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54980635c537f3130481da2d8b1109c775db8bb0"}], "stats": {"total": 169, "additions": 169, "deletions": 0}, "files": [{"sha": "e631da48477cac96cd5ead62795ee91b72991a9b", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/346bce6fe0cf1ed5f6a7ad732d2361d77b203c87/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/346bce6fe0cf1ed5f6a7ad732d2361d77b203c87/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=346bce6fe0cf1ed5f6a7ad732d2361d77b203c87", "patch": "@@ -2396,6 +2396,54 @@ simplify_binary_operation_series (rtx_code code, machine_mode mode,\n   return gen_vec_series (mode, new_base, new_step);\n }\n \n+/* Subroutine of simplify_binary_operation_1.  Un-distribute a binary\n+   operation CODE with result mode MODE, operating on OP0 and OP1.\n+   e.g. simplify (xor (and A C) (and (B C)) to (and (xor (A B) C).\n+   Returns NULL_RTX if no simplification is possible.  */\n+\n+static rtx\n+simplify_distributive_operation (enum rtx_code code, machine_mode mode,\n+\t\t\t\t rtx op0, rtx op1)\n+{\n+  enum rtx_code op = GET_CODE (op0);\n+  gcc_assert (GET_CODE (op1) == op);\n+\n+  if (rtx_equal_p (XEXP (op0, 1), XEXP (op1, 1))\n+      && ! side_effects_p (XEXP (op0, 1)))\n+    return simplify_gen_binary (op, mode,\n+\t\t\t\tsimplify_gen_binary (code, mode,\n+\t\t\t\t\t\t     XEXP (op0, 0),\n+\t\t\t\t\t\t     XEXP (op1, 0)),\n+\t\t\t\tXEXP (op0, 1));\n+\n+  if (GET_RTX_CLASS (op) == RTX_COMM_ARITH)\n+    {\n+      if (rtx_equal_p (XEXP (op0, 0), XEXP (op1, 0))\n+\t  && ! side_effects_p (XEXP (op0, 0)))\n+\treturn simplify_gen_binary (op, mode,\n+\t\t\t\t    simplify_gen_binary (code, mode,\n+\t\t\t\t\t\t\t XEXP (op0, 1),\n+\t\t\t\t\t\t\t XEXP (op1, 1)),\n+\t\t\t\t    XEXP (op0, 0));\n+      if (rtx_equal_p (XEXP (op0, 0), XEXP (op1, 1))\n+\t  && ! side_effects_p (XEXP (op0, 0)))\n+\treturn simplify_gen_binary (op, mode,\n+\t\t\t\t    simplify_gen_binary (code, mode,\n+\t\t\t\t\t\t\t XEXP (op0, 1),\n+\t\t\t\t\t\t\t XEXP (op1, 0)),\n+\t\t\t\t    XEXP (op0, 0));\n+      if (rtx_equal_p (XEXP (op0, 1), XEXP (op1, 0))\n+\t  && ! side_effects_p (XEXP (op0, 1)))\n+\treturn simplify_gen_binary (op, mode,\n+\t\t\t\t    simplify_gen_binary (code, mode,\n+\t\t\t\t\t\t\t XEXP (op0, 0),\n+\t\t\t\t\t\t\t XEXP (op1, 1)),\n+\t\t\t\t    XEXP (op0, 1));\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n /* Subroutine of simplify_binary_operation.  Simplify a binary operation\n    CODE with result mode MODE, operating on OP0 and OP1.  If OP0 and/or\n    OP1 are constant pool references, TRUEOP0 and TRUEOP1 represent the\n@@ -3068,6 +3116,21 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t    }\n \t}\n \n+      /* Convert (ior (and A C) (and B C)) into (and (ior A B) C).  */\n+      if (GET_CODE (op0) == GET_CODE (op1)\n+\t  && (GET_CODE (op0) == AND\n+\t      || GET_CODE (op0) == IOR\n+\t      || GET_CODE (op0) == LSHIFTRT\n+\t      || GET_CODE (op0) == ASHIFTRT\n+\t      || GET_CODE (op0) == ASHIFT\n+\t      || GET_CODE (op0) == ROTATE\n+\t      || GET_CODE (op0) == ROTATERT))\n+\t{\n+\t  tem = simplify_distributive_operation (code, mode, op0, op1);\n+\t  if (tem)\n+\t    return tem;\n+\t}\n+\n       tem = simplify_byte_swapping_operation (code, mode, op0, op1);\n       if (tem)\n \treturn tem;\n@@ -3306,6 +3369,21 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t  && (reversed = reversed_comparison (op0, int_mode)))\n \treturn reversed;\n \n+      /* Convert (xor (and A C) (and B C)) into (and (xor A B) C).  */\n+      if (GET_CODE (op0) == GET_CODE (op1)\n+\t  && (GET_CODE (op0) == AND\n+\t      || GET_CODE (op0) == XOR\n+\t      || GET_CODE (op0) == LSHIFTRT\n+\t      || GET_CODE (op0) == ASHIFTRT\n+\t      || GET_CODE (op0) == ASHIFT\n+\t      || GET_CODE (op0) == ROTATE\n+\t      || GET_CODE (op0) == ROTATERT))\n+\t{\n+\t  tem = simplify_distributive_operation (code, mode, op0, op1);\n+\t  if (tem)\n+\t    return tem;\n+\t}\n+\n       tem = simplify_byte_swapping_operation (code, mode, op0, op1);\n       if (tem)\n \treturn tem;\n@@ -3504,6 +3582,21 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t  && rtx_equal_p (op1, XEXP (XEXP (op0, 1), 0)))\n \treturn simplify_gen_binary (AND, mode, op1, XEXP (op0, 0));\n \n+      /* Convert (and (ior A C) (ior B C)) into (ior (and A B) C).  */\n+      if (GET_CODE (op0) == GET_CODE (op1)\n+\t  && (GET_CODE (op0) == AND\n+\t      || GET_CODE (op0) == IOR\n+\t      || GET_CODE (op0) == LSHIFTRT\n+\t      || GET_CODE (op0) == ASHIFTRT\n+\t      || GET_CODE (op0) == ASHIFT\n+\t      || GET_CODE (op0) == ROTATE\n+\t      || GET_CODE (op0) == ROTATERT))\n+\t{\n+\t  tem = simplify_distributive_operation (code, mode, op0, op1);\n+\t  if (tem)\n+\t    return tem;\n+\t}\n+\n       tem = simplify_byte_swapping_operation (code, mode, op0, op1);\n       if (tem)\n \treturn tem;\n@@ -7224,6 +7317,81 @@ make_test_reg (machine_mode mode)\n   return gen_rtx_REG (mode, test_reg_num++);\n }\n \n+static void\n+test_scalar_int_ops (machine_mode mode)\n+{\n+  rtx op0 = make_test_reg (mode);\n+  rtx op1 = make_test_reg (mode);\n+  rtx six = GEN_INT (6);\n+\n+  rtx neg_op0 = simplify_gen_unary (NEG, mode, op0, mode);\n+  rtx not_op0 = simplify_gen_unary (NOT, mode, op0, mode);\n+  rtx bswap_op0 = simplify_gen_unary (BSWAP, mode, op0, mode);\n+\n+  rtx and_op0_op1 = simplify_gen_binary (AND, mode, op0, op1);\n+  rtx ior_op0_op1 = simplify_gen_binary (IOR, mode, op0, op1);\n+  rtx xor_op0_op1 = simplify_gen_binary (XOR, mode, op0, op1);\n+\n+  rtx and_op0_6 = simplify_gen_binary (AND, mode, op0, six);\n+  rtx and_op1_6 = simplify_gen_binary (AND, mode, op1, six);\n+\n+  /* Test some binary identities.  */\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (PLUS, mode, op0, const0_rtx));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (PLUS, mode, const0_rtx, op0));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (MINUS, mode, op0, const0_rtx));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (MULT, mode, op0, const1_rtx));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (MULT, mode, const1_rtx, op0));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (DIV, mode, op0, const1_rtx));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (AND, mode, op0, constm1_rtx));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (AND, mode, constm1_rtx, op0));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (IOR, mode, op0, const0_rtx));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (IOR, mode, const0_rtx, op0));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (XOR, mode, op0, const0_rtx));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (XOR, mode, const0_rtx, op0));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (ASHIFT, mode, op0, const0_rtx));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (ROTATE, mode, op0, const0_rtx));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (ASHIFTRT, mode, op0, const0_rtx));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (LSHIFTRT, mode, op0, const0_rtx));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (ROTATERT, mode, op0, const0_rtx));\n+\n+  /* Test some self-inverse operations.  */\n+  ASSERT_RTX_EQ (op0, simplify_gen_unary (NEG, mode, neg_op0, mode));\n+  ASSERT_RTX_EQ (op0, simplify_gen_unary (NOT, mode, not_op0, mode));\n+  ASSERT_RTX_EQ (op0, simplify_gen_unary (BSWAP, mode, bswap_op0, mode));\n+\n+  /* Test some reflexive operations.  */\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (AND, mode, op0, op0));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (IOR, mode, op0, op0));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (SMIN, mode, op0, op0));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (SMAX, mode, op0, op0));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (UMIN, mode, op0, op0));\n+  ASSERT_RTX_EQ (op0, simplify_gen_binary (UMAX, mode, op0, op0));\n+\n+  ASSERT_RTX_EQ (const0_rtx, simplify_gen_binary (MINUS, mode, op0, op0));\n+  ASSERT_RTX_EQ (const0_rtx, simplify_gen_binary (XOR, mode, op0, op0));\n+\n+  /* Test simplify_distributive_operation.  */\n+  ASSERT_RTX_EQ (simplify_gen_binary (AND, mode, xor_op0_op1, six),\n+\t\t simplify_gen_binary (XOR, mode, and_op0_6, and_op1_6));\n+  ASSERT_RTX_EQ (simplify_gen_binary (AND, mode, ior_op0_op1, six),\n+\t\t simplify_gen_binary (IOR, mode, and_op0_6, and_op1_6));\n+  ASSERT_RTX_EQ (simplify_gen_binary (AND, mode, and_op0_op1, six),\n+\t\t simplify_gen_binary (AND, mode, and_op0_6, and_op1_6));\n+}\n+\n+/* Verify some simplifications involving scalar expressions.  */\n+\n+static void\n+test_scalar_ops ()\n+{\n+  for (unsigned int i = 0; i < NUM_MACHINE_MODES; ++i)\n+    {\n+      machine_mode mode = (machine_mode) i;\n+      if (SCALAR_INT_MODE_P (mode) && mode != BImode)\n+\ttest_scalar_int_ops (mode);\n+    }\n+}\n+\n /* Test vector simplifications involving VEC_DUPLICATE in which the\n    operands and result have vector mode MODE.  SCALAR_REG is a pseudo\n    register that holds one element of MODE.  */\n@@ -7741,6 +7909,7 @@ simplify_const_poly_int_tests<N>::run ()\n void\n simplify_rtx_c_tests ()\n {\n+  test_scalar_ops ();\n   test_vector_ops ();\n   simplify_const_poly_int_tests<NUM_POLY_INT_COEFFS>::run ();\n }"}]}