{"sha": "5d0f30f711ced9cdc1ab5bc2239311a4c35e4d0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQwZjMwZjcxMWNlZDljZGMxYWI1YmMyMjM5MzExYTRjMzVlNGQwYg==", "commit": {"author": {"name": "Kresten Krab Thorup", "email": "krab@gcc.gnu.org", "date": "1994-06-30T16:17:36Z"}, "committer": {"name": "Kresten Krab Thorup", "email": "krab@gcc.gnu.org", "date": "1994-06-30T16:17:36Z"}, "message": "objc-act.c (get_proto_encoding, [...]): New fucnctions.\n\n        * objc-act.c (get_proto_encoding, build_typed_selector_reference):\n        New fucnctions. (UTAG_PROTOCOL): New define.\n        (objc_selector_template, flag_typed_selectors): New variables.\n        (objc_init): set flag_typed_selectors if -fgnu-runtime.\n        (synth_module_prologue): Change declaration of\n        _OBJC_SELECTOR_TABLE when flag_typed_selectors is non-null.\n        (build_module_descriptor): Make sure the generated constructor\n        function is declared public.\n        (build_selector): Only cast to SEL when not doing typed selectors.\n        (build_selector_translation_table): Rewrite initialization.\n        (build_tmp_function_decl): Make up new name when called, since it\n        may now be called multiple times.\n        (hack_method_prototype): Use init_function_start to reinit args\n        machinery.  Also set current_function_decl before calling\n        assign_parms.\n        (generate_protocols):  Don't generate encoding twice.\n        (build_selector_template): New function.\n        (build_method_list_template): Generate (void*)0 as first element,\n        not (int)0.\n        (build_message_expr): move the call to build_selector_reference\n        towards the end, where we have determined the function prototype.\n\nFrom-SVN: r7620", "tree": {"sha": "8b96de5d2386b53b8393e2dac76603c23c5cfd4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b96de5d2386b53b8393e2dac76603c23c5cfd4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d0f30f711ced9cdc1ab5bc2239311a4c35e4d0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d0f30f711ced9cdc1ab5bc2239311a4c35e4d0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d0f30f711ced9cdc1ab5bc2239311a4c35e4d0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d0f30f711ced9cdc1ab5bc2239311a4c35e4d0b/comments", "author": null, "committer": null, "parents": [{"sha": "bd4d60ce718459dae37f66627fb57035f2839fe0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd4d60ce718459dae37f66627fb57035f2839fe0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd4d60ce718459dae37f66627fb57035f2839fe0"}], "stats": {"total": 212, "additions": 178, "deletions": 34}, "files": [{"sha": "58d7279dea105474bce08388997e7f9524ed57cb", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 178, "deletions": 34, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d0f30f711ced9cdc1ab5bc2239311a4c35e4d0b/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d0f30f711ced9cdc1ab5bc2239311a4c35e4d0b/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=5d0f30f711ced9cdc1ab5bc2239311a4c35e4d0b", "patch": "@@ -47,6 +47,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"input.h\"\n #include \"function.h\"\n \n+\n /* This is the default way of generating a method name.  */\n /* I am not sure it is really correct.\n    Perhaps there's a danger that it will make name conflicts\n@@ -127,7 +128,7 @@ char *util_firstobj;\n #include \"rtl.h\"\n #include \"c-parse.h\"\n \n-#define OBJC_VERSION\t5\n+#define OBJC_VERSION\t6\n #define PROTOCOL_VERSION 2\n \n #define NULLT\t(tree) 0\n@@ -150,13 +151,15 @@ static char *build_module_descriptor\t\tPROTO((void));\n static tree init_module_descriptor\t\tPROTO((tree));\n static tree build_objc_method_call\t\tPROTO((int, tree, tree, tree, tree, tree));\n static void generate_strings\t\t\tPROTO((void));\n+static tree get_proto_encoding \t\t\tPROTO((tree));\n static void build_selector_translation_table\tPROTO((void));\n static tree build_ivar_chain\t\t\tPROTO((tree, int));\n \n static tree build_ivar_template\t\t\tPROTO((void));\n static tree build_method_template\t\tPROTO((void));\n static tree build_private_template\t\tPROTO((tree));\n static void build_class_template\t\tPROTO((void));\n+static void build_selector_template\t\tPROTO((void));\n static void build_category_template\t\tPROTO((void));\n static tree build_super_template\t\tPROTO((void));\n static tree build_category_initializer\t\tPROTO((tree, tree, tree, tree, tree, tree));\n@@ -263,6 +266,7 @@ static void forward_declare_categories\t\tPROTO((void));\n static void generate_objc_symtab_decl\t\tPROTO((void));\n static tree build_selector\t\t\tPROTO((tree));\n static tree build_msg_pool_reference\t\tPROTO((int));\n+static tree build_typed_selector_reference     \tPROTO((tree, tree));\n static tree build_selector_reference\t\tPROTO((tree));\n static tree build_class_reference_decl\t\tPROTO((tree));\n static void add_class_reference\t\t\tPROTO((tree));\n@@ -319,6 +323,7 @@ static void handle_class_ref\t\t\tPROTO((tree));\n #define UTAG_MODULE\t\t\"_objc_module\"\n #define UTAG_SYMTAB\t\t\"_objc_symtab\"\n #define UTAG_SUPER\t\t\"_objc_super\"\n+#define UTAG_SELECTOR\t\t\"_objc_selector\"\n \n #define UTAG_PROTOCOL\t\t\"_objc_protocol\"\n #define UTAG_PROTOCOL_LIST\t\"_objc_protocol_list\"\n@@ -414,7 +419,7 @@ static int imp_count = 0;\t/* `@implementation' */\n static int cat_count = 0;\t/* `@category' */\n \n static tree objc_class_template, objc_category_template, uprivate_record;\n-static tree objc_protocol_template;\n+static tree objc_protocol_template, objc_selector_template;\n static tree ucls_super_ref, uucls_super_ref;\n \n static tree objc_method_template, objc_ivar_template;\n@@ -436,6 +441,7 @@ static char *errbuf;\t/* a buffer for error diagnostics */\n /* data imported from tree.c */\n \n extern struct obstack permanent_obstack, *current_obstack, *rtl_obstack;\n+extern enum debug_info_type write_symbols;\n \n /* data imported from toplev.c  */\n \n@@ -449,6 +455,8 @@ int flag_next_runtime = 1;\n int flag_next_runtime = 0;\n #endif\n \n+int flag_typed_selectors;\n+\n /* Open and close the file for outputting class declarations, if requested.  */\n \n int flag_gen_declaration = 0;\n@@ -509,6 +517,7 @@ lang_init ()\n       TAG_MSGSEND = \"objc_msg_lookup\";\n       TAG_MSGSENDSUPER = \"objc_msg_lookup_super\";\n       TAG_EXECCLASS = \"__objc_exec_class\";\n+      flag_typed_selectors = 1;\n     }\n \n   if (doing_objc_thang)\n@@ -1086,12 +1095,29 @@ synth_module_prologue ()\n \n   /* static SEL _OBJC_SELECTOR_TABLE[]; */\n \n-  temp_type = build_array_type (selector_type, NULLT);\n-  layout_type (temp_type);\n   if (! flag_next_runtime)\n-    UOBJC_SELECTOR_TABLE_decl\n-      = create_builtin_decl (VAR_DECL, temp_type,\n-\t\t\t     \"_OBJC_SELECTOR_TABLE\");\n+    {\n+      if (flag_typed_selectors)\n+\t{\n+\t  /* supress outputting debug symbols, because\n+\t     dbxout_init hasn'r been called yet... */\n+\t  enum debug_info_type save_write_symbols = write_symbols;\n+\t  write_symbols = NO_DEBUG;\n+\n+\t  build_selector_template ();\n+\t  temp_type = build_array_type (objc_selector_template, NULLT);\n+\n+\t  write_symbols = save_write_symbols;\n+\t}\n+      else\n+\ttemp_type = build_array_type (selector_type, NULLT);\n+\n+      layout_type (temp_type);\n+      UOBJC_SELECTOR_TABLE_decl\n+\t= create_builtin_decl (VAR_DECL, temp_type,\n+\t\t\t       \"_OBJC_SELECTOR_TABLE\");\n+    }\n+\n \n   generate_forward_declaration_to_string_table ();\n \n@@ -1510,6 +1536,7 @@ build_module_descriptor ()\n \t\t\t\tfunction_type);\n     DECL_EXTERNAL (function_decl) = 1;\n     TREE_PUBLIC (function_decl) = 1;\n+\n     pushdecl (function_decl);\n     rest_of_decl_compilation (function_decl, 0, 0, 0);\n \n@@ -1540,6 +1567,9 @@ build_module_descriptor ()\n     assemble_external (function_decl);\n     c_expand_expr_stmt (decelerator);\n \n+    TREE_PUBLIC (current_function_decl) = 1;\n+    DECL_EXTERNAL (current_function_decl) = 1;\n+\n     finish_function (0);\n \n     /* Return the name of the constructor function.  */\n@@ -1652,8 +1682,10 @@ build_selector (ident)\n      tree ident;\n {\n   tree expr = add_objc_string (ident, meth_var_names);\n-\n-  return build_c_cast (selector_type, expr); /* cast! */\n+  if (flag_typed_selectors)\n+    return expr;\n+  else\n+    return build_c_cast (selector_type, expr); /* cast! */\n }\n \n /* Synthesize the following expr: (char *)&_OBJC_STRINGS[<offset>]\n@@ -1729,8 +1761,20 @@ build_selector_translation_table ()\n \t  end_temporary_allocation ();\n \t  finish_decl (decl, expr, NULLT);\n \t}\n-      else\n-\tinitlist = tree_cons (NULLT, expr, initlist);\n+      else \n+\t{\n+\t  if (flag_typed_selectors)\n+\t    {\n+\t      tree eltlist = NULLT;\n+\t      tree encoding = get_proto_encoding (TREE_PURPOSE (chain));\n+\t      eltlist = tree_cons (NULLT, expr, NULLT);\n+\t      eltlist = tree_cons (NULLT, encoding, eltlist);\n+\t      expr = build_constructor (objc_selector_template,\n+\t\t\t\t\tnreverse (eltlist));\n+\t    }\n+\t  initlist = tree_cons (NULLT, expr, initlist);\n+\t  \n+\t}\n     }\n \n   if (! flag_next_runtime)\n@@ -1747,15 +1791,67 @@ build_selector_translation_table ()\n     }\n }\n \n+\n+static tree\n+get_proto_encoding (proto)\n+     tree proto;\n+{\n+  tree encoding;\n+  if (proto)\n+    {\n+      tree tmp_decl;\n+\n+      if (! METHOD_ENCODING (proto))\n+\t{\n+\t    tmp_decl = build_tmp_function_decl ();\n+\t    hack_method_prototype (proto, tmp_decl);\n+\t    encoding = encode_method_prototype (proto, tmp_decl);\n+\t    METHOD_ENCODING (proto) = encoding;\n+\t  }\n+      else\n+\tencoding = METHOD_ENCODING (proto);\n+\n+      return add_objc_string (encoding, meth_var_types);\n+    }\n+  else\n+    return build_int_2 (0, 0);\n+}\n+\n /* sel_ref_chain is a list whose \"value\" fields will be instances of\n    identifier_node that represent the selector.  */\n \n+static tree\n+build_typed_selector_reference (ident, proto)\n+     tree ident, proto;\n+{\n+  tree *chain = &sel_ref_chain;\n+  tree expr;\n+  int index = 0;\n+\n+  while (*chain)\n+    {\n+      if (TREE_PURPOSE (*chain) == ident && TREE_VALUE (*chain) == proto)\n+\tgoto return_at_index;\n+      index++;\n+      chain = &TREE_CHAIN (*chain);\n+    }\n+\n+  *chain = perm_tree_cons (proto, ident, NULLT);\n+\n+ return_at_index:\n+  expr = build_unary_op (ADDR_EXPR,\n+\t\t\t build_array_ref (UOBJC_SELECTOR_TABLE_decl,\n+\t\t\t\t\t  build_int_2 (index, 0)),\n+\t\t\t 1);\n+  return build_c_cast (selector_type, expr);\n+}\n+\n static tree\n build_selector_reference (ident)\n      tree ident;\n {\n   tree *chain = &sel_ref_chain;\n-  tree decl;\n+  tree expr;\n   int index = 0;\n \n   while (*chain)\n@@ -1770,12 +1866,12 @@ build_selector_reference (ident)\n       chain = &TREE_CHAIN (*chain);\n     }\n \n-  decl = build_selector_reference_decl (ident);\n+  expr = build_selector_reference_decl (ident);\n \n-  *chain = perm_tree_cons (decl, ident, NULLT);\n+  *chain = perm_tree_cons (expr, ident, NULLT);\n \n   return (flag_next_runtime\n-\t  ? decl\n+\t  ? expr\n \t  : build_array_ref (UOBJC_SELECTOR_TABLE_decl,\n \t\t\t     build_int_2 (index, 0)));\n }\n@@ -2531,6 +2627,8 @@ static tree\n build_tmp_function_decl ()\n {\n   tree decl_specs, expr_decl, parms;\n+  static int xxx = 0;\n+  char buffer[80];\n \n   /* struct objc_object *objc_xxx (id, SEL, ...); */\n   pushlevel (0);\n@@ -2547,7 +2645,8 @@ build_tmp_function_decl ()\n   poplevel (0, 0, 0);\n \n   decl_specs = build_tree_list (NULLT, objc_object_reference);\n-  expr_decl = build_nt (CALL_EXPR, get_identifier (\"objc_xxx\"), parms, NULLT);\n+  sprintf (buffer, \"__objc_tmp_%x\", xxx++);\n+  expr_decl = build_nt (CALL_EXPR, get_identifier (buffer), parms, NULLT);\n   expr_decl = build1 (INDIRECT_REF, NULLT, expr_decl);\n \n   return define_decl (expr_decl, decl_specs);\n@@ -2574,9 +2673,8 @@ hack_method_prototype (nst_methods, tmp_decl)\n \n   /* Usually called from store_parm_decls -> init_function_start.  */\n \n-  init_emit ();\t/* needed to make assign_parms work (with -O).  */\n-\n   DECL_ARGUMENTS (tmp_decl) = TREE_PURPOSE (parms);\n+  current_function_decl = tmp_decl;\n \n   {\n     /* Code taken from start_function.  */\n@@ -2588,11 +2686,14 @@ hack_method_prototype (nst_methods, tmp_decl)\n     DECL_RESULT (tmp_decl) = build_decl (RESULT_DECL, 0, restype);\n   }\n \n+  init_function_start (tmp_decl, \"objc-act\", 0);\n+\n   /* Typically called from expand_function_start for function definitions.  */\n   assign_parms (tmp_decl, 0);\n \n   /* install return type */\n   TREE_TYPE (TREE_TYPE (tmp_decl)) = groktypename (TREE_TYPE (nst_methods));\n+\n }\n \n static void\n@@ -2650,18 +2751,23 @@ generate_protocols ()\n \n       while (nst_methods)\n \t{\n-\t  hack_method_prototype (nst_methods, tmp_decl);\n-\t  encoding = encode_method_prototype (nst_methods, tmp_decl);\n-\t  METHOD_ENCODING (nst_methods) = encoding;\n-\n+\t  if (! METHOD_ENCODING (nst_methods))\n+\t    {\n+\t      hack_method_prototype (nst_methods, tmp_decl);\n+\t      encoding = encode_method_prototype (nst_methods, tmp_decl);\n+\t      METHOD_ENCODING (nst_methods) = encoding;\n+\t    }\n \t  nst_methods = TREE_CHAIN (nst_methods);\n \t}\n \n       while (cls_methods)\n \t{\n-\t  hack_method_prototype (cls_methods, tmp_decl);\n-\t  encoding = encode_method_prototype (cls_methods, tmp_decl);\n-\t  METHOD_ENCODING (cls_methods) = encoding;\n+\t  if (! METHOD_ENCODING (cls_methods))\n+\t    {\n+\t      hack_method_prototype (cls_methods, tmp_decl);\n+\t      encoding = encode_method_prototype (cls_methods, tmp_decl);\n+\t      METHOD_ENCODING (cls_methods) = encoding;\n+\t    }\n \n \t  cls_methods = TREE_CHAIN (cls_methods);\n \t}\n@@ -2815,6 +2921,37 @@ build_category_template ()\n   finish_struct (objc_category_template, field_decl_chain);\n }\n \n+/* struct objc_selector {\n+     void *sel_id;\n+     char *sel_type;\n+   }; */\n+\n+static void\n+build_selector_template ()\n+{\n+\n+  tree decl_specs, field_decl, field_decl_chain;\n+\n+  objc_selector_template \n+    = start_struct (RECORD_TYPE, get_identifier (UTAG_SELECTOR));\n+\n+  /* void *sel_id; */\n+\n+  decl_specs = build_tree_list (NULLT, ridpointers[(int) RID_VOID]);\n+  field_decl = build1 (INDIRECT_REF, NULLT, get_identifier (\"sel_id\"));\n+  field_decl = grokfield (input_filename, lineno, field_decl, decl_specs, NULLT);\n+  field_decl_chain = field_decl;\n+\n+  /* char *sel_type; */\n+\n+  decl_specs = build_tree_list (NULLT, ridpointers[(int) RID_CHAR]);\n+  field_decl = build1 (INDIRECT_REF, NULLT, get_identifier (\"sel_type\"));\n+  field_decl = grokfield (input_filename, lineno, field_decl, decl_specs, NULLT);\n+  chainon (field_decl_chain, field_decl);\n+\n+  finish_struct (objc_selector_template, field_decl_chain);\n+}\n+\n /* struct objc_class {\n      struct objc_class *isa;\n      struct objc_class *super_class;\n@@ -3193,9 +3330,10 @@ build_method_list_template (list_type, size)\n \n   /* int method_next; */\n \n-  decl_specs = build_tree_list (NULLT, ridpointers[(int) RID_INT]);\n-  field_decl = get_identifier (\"method_next\");\n-\n+  decl_specs = build_tree_list (NULLT, \n+\t\t\t\txref_tag (RECORD_TYPE,\n+\t\t\t\t\t  get_identifier (UTAG_METHOD_PROTOTYPE_LIST)));\n+  field_decl = build1 (INDIRECT_REF, NULLT, get_identifier (\"method_next\"));\n   field_decl = grokfield (input_filename, lineno, field_decl, decl_specs, NULLT);\n   field_decl_chain = field_decl;\n \n@@ -4343,11 +4481,6 @@ build_message_expr (mess)\n   else if (TREE_CODE (args) == TREE_LIST)\n     sel_name = build_keyword_selector (args);\n \n-  /* Build the parameters list for looking up the method.\n-     These are the object itself and the selector.  */\n-\n-  selector = build_selector_reference (sel_name);\n-\n   /* Build the parameter list to give to the method.  */\n \n   method_params = NULLT;\n@@ -4544,6 +4677,14 @@ build_message_expr (mess)\n   /* Save the selector name for printing error messages.  */\n   building_objc_message_expr = sel_name;\n \n+  /* Build the parameters list for looking up the method.\n+     These are the object itself and the selector.  */\n+\n+  if (flag_typed_selectors)\n+    selector = build_typed_selector_reference (sel_name, method_prototype);\n+  else\n+    selector = build_selector_reference (sel_name);\n+\n   retval = build_objc_method_call (super, method_prototype,\n \t\t\t\t   receiver, self_object,\n \t\t\t\t   selector, method_params);\n@@ -4744,7 +4885,10 @@ build_selector_expr (selnamelist)\n   else if (TREE_CODE (selnamelist) == TREE_LIST)\n     selname = build_keyword_selector (selnamelist);\n \n-  return build_selector_reference (selname);\n+  if (flag_typed_selectors)\n+    return build_typed_selector_reference (selname, 0);\n+  else\n+    return build_selector_reference (selname);\n }\n \n tree"}]}