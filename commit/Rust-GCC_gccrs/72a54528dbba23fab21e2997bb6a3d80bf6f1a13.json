{"sha": "72a54528dbba23fab21e2997bb6a3d80bf6f1a13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJhNTQ1MjhkYmJhMjNmYWIyMWUyOTk3YmI2YTNkODBiZjZmMWExMw==", "commit": {"author": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2009-01-29T10:53:15Z"}, "committer": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2009-01-29T10:53:15Z"}, "message": "[multiple changes]\n\n2009-01-29  Andrey Belevantsev  <abel@ispras.ru>\n\t    Alexander Monakov  <amonakov@ispras.ru>\n\n\tPR middle-end/38857\n\t* sel-sched.c (count_occurrences_1): Check that *cur_rtx is a hard\n\tregister.\n\t(move_exprs_to_boundary): Change return type and pass through\n\tshould_move from move_op.  Relax assert.  Update usage ...\n\t(schedule_expr_on_boundary): ... here.  Use should_move instead of\n\tcant_move.\n\t(move_op_orig_expr_found): Indicate that insn was disconnected from\n\tstream.\n\t(code_motion_process_successors): Do not call after_merge_succs\n\tcallback if original expression was not found when traversing any of\n\tthe branches.\n\t(code_motion_path_driver): Change return type.  Update prototype.\n\t(move_op): Update comment.  Add a new parameter (should_move).  Update\n\tprototype.  Set *should_move based on indication provided by\n\tmove_op_orig_expr_found.\n\n2009-01-29  Steve Ellcey  <sje@cup.hp.com>\n\n\tPR middle-end/38857\n\t* gcc.c-torture/compile/pr38857.c: New test.\n\nFrom-SVN: r143753", "tree": {"sha": "e1c0f02d0bea7bb353dc7730715660e5d5155263", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1c0f02d0bea7bb353dc7730715660e5d5155263"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72a54528dbba23fab21e2997bb6a3d80bf6f1a13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72a54528dbba23fab21e2997bb6a3d80bf6f1a13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72a54528dbba23fab21e2997bb6a3d80bf6f1a13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72a54528dbba23fab21e2997bb6a3d80bf6f1a13/comments", "author": null, "committer": null, "parents": [{"sha": "d748c4062c7c457d19048217b0adb28021d4b058", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d748c4062c7c457d19048217b0adb28021d4b058", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d748c4062c7c457d19048217b0adb28021d4b058"}], "stats": {"total": 94, "additions": 74, "deletions": 20}, "files": [{"sha": "9de4aa56ea7a30b140bbd10b44d8d1de361222cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a54528dbba23fab21e2997bb6a3d80bf6f1a13/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a54528dbba23fab21e2997bb6a3d80bf6f1a13/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72a54528dbba23fab21e2997bb6a3d80bf6f1a13", "patch": "@@ -1,3 +1,23 @@\n+2009-01-29  Andrey Belevantsev  <abel@ispras.ru>\n+\t    Alexander Monakov  <amonakov@ispras.ru>\n+\n+\tPR middle-end/38857\n+\t* sel-sched.c (count_occurrences_1): Check that *cur_rtx is a hard\n+\tregister.\n+\t(move_exprs_to_boundary): Change return type and pass through\n+\tshould_move from move_op.  Relax assert.  Update usage ...\n+\t(schedule_expr_on_boundary): ... here.  Use should_move instead of\n+\tcant_move.\n+\t(move_op_orig_expr_found): Indicate that insn was disconnected from\n+\tstream.\n+\t(code_motion_process_successors): Do not call after_merge_succs\n+\tcallback if original expression was not found when traversing any of\n+\tthe branches.\n+\t(code_motion_path_driver): Change return type.  Update prototype.\n+\t(move_op): Update comment.  Add a new parameter (should_move).  Update\n+\tprototype.  Set *should_move based on indication provided by\n+\tmove_op_orig_expr_found.\n+\n 2009-01-28  Pat Haugen  <pthaugen@us.ibm.com>\n \n \t* doc/invoke.texi (avoid-indexed-addresses): Document new option."}, {"sha": "172bb3ebb5ac5bc34a0f0cd6fe1d1a5e02909146", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a54528dbba23fab21e2997bb6a3d80bf6f1a13/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a54528dbba23fab21e2997bb6a3d80bf6f1a13/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=72a54528dbba23fab21e2997bb6a3d80bf6f1a13", "patch": "@@ -562,9 +562,9 @@ static rtx get_dest_from_orig_ops (av_set_t);\n static basic_block generate_bookkeeping_insn (expr_t, edge, edge);\n static bool find_used_regs (insn_t, av_set_t, regset, struct reg_rename *, \n                             def_list_t *);\n-static bool move_op (insn_t, av_set_t, expr_t, rtx, expr_t);\n-static bool code_motion_path_driver (insn_t, av_set_t, ilist_t,\n-                                     cmpd_local_params_p, void *);\n+static bool move_op (insn_t, av_set_t, expr_t, rtx, expr_t, bool*);\n+static int code_motion_path_driver (insn_t, av_set_t, ilist_t,\n+                                    cmpd_local_params_p, void *);\n static void sel_sched_region_1 (void);\n static void sel_sched_region_2 (int);\n static av_set_t compute_av_set_inside_bb (insn_t, ilist_t, int, bool);\n@@ -819,6 +819,7 @@ count_occurrences_1 (rtx *cur_rtx, void *arg)\n     {\n       /* Bail out if we occupy more than one register.  */\n       if (REG_P (*cur_rtx)\n+          && HARD_REGISTER_P (*cur_rtx)\n           && hard_regno_nregs[REGNO(*cur_rtx)][GET_MODE (*cur_rtx)] > 1)\n         {\n           p->n = 0;\n@@ -4947,11 +4948,11 @@ prepare_place_to_insert (bnd_t bnd)\n \n /* Find original instructions for EXPR_SEQ and move it to BND boundary.  \n    Return the expression to emit in C_EXPR.  */\n-static void\n+static bool\n move_exprs_to_boundary (bnd_t bnd, expr_t expr_vliw, \n                         av_set_t expr_seq, expr_t c_expr)\n {\n-  bool b;\n+  bool b, should_move;\n   unsigned book_uid;\n   bitmap_iterator bi;\n   int n_bookkeeping_copies_before_moveop;\n@@ -4966,11 +4967,11 @@ move_exprs_to_boundary (bnd_t bnd, expr_t expr_vliw,\n   bitmap_clear (current_originators);\n \n   b = move_op (BND_TO (bnd), expr_seq, expr_vliw, \n-               get_dest_from_orig_ops (expr_seq), c_expr);\n+               get_dest_from_orig_ops (expr_seq), c_expr, &should_move);\n \n   /* We should be able to find the expression we've chosen for \n      scheduling.  */\n-  gcc_assert (b == 1);\n+  gcc_assert (b);\n   \n   if (stat_bookkeeping_copies > n_bookkeeping_copies_before_moveop)\n     stat_insns_needed_bookkeeping++;\n@@ -4984,6 +4985,8 @@ move_exprs_to_boundary (bnd_t bnd, expr_t expr_vliw,\n       bitmap_copy (INSN_ORIGINATORS_BY_UID (book_uid), \n                    current_originators);\n     }\n+\n+  return should_move;\n }\n \n \n@@ -5130,7 +5133,7 @@ schedule_expr_on_boundary (bnd_t bnd, expr_t expr_vliw, int seqno)\n   expr_t c_expr = XALLOCA (expr_def);\n   insn_t place_to_insert;\n   insn_t insn;\n-  bool cant_move;\n+  bool should_move;\n \n   expr_seq = find_sequential_best_exprs (bnd, expr_vliw, true);\n \n@@ -5147,13 +5150,9 @@ schedule_expr_on_boundary (bnd_t bnd, expr_t expr_vliw, int seqno)\n         move_cond_jump (insn, bnd);\n     }\n \n-  /* Calculate cant_move now as EXPR_WAS_RENAMED can change after move_op \n-     meaning that there was *any* renaming somewhere.  */\n-  cant_move = EXPR_WAS_CHANGED (expr_vliw) || EXPR_WAS_RENAMED (expr_vliw);\n-\n   /* Find a place for C_EXPR to schedule.  */\n   place_to_insert = prepare_place_to_insert (bnd);\n-  move_exprs_to_boundary (bnd, expr_vliw, expr_seq, c_expr);\n+  should_move = move_exprs_to_boundary (bnd, expr_vliw, expr_seq, c_expr);\n   clear_expr (c_expr);\n             \n   /* Add the instruction.  The corner case to care about is when \n@@ -5166,13 +5165,13 @@ schedule_expr_on_boundary (bnd_t bnd, expr_t expr_vliw, int seqno)\n       \n       vinsn_new = vinsn_copy (EXPR_VINSN (expr_vliw), false);\n       change_vinsn_in_expr (expr_vliw, vinsn_new);\n-      cant_move = 1;\n+      should_move = false;\n     }\n-  if (cant_move)\n+  if (should_move)\n+    insn = sel_move_insn (expr_vliw, seqno, place_to_insert);\n+  else\n     insn = emit_insn_from_expr_after (expr_vliw, NULL, seqno, \n                                       place_to_insert);\n-  else\n-    insn = sel_move_insn (expr_vliw, seqno, place_to_insert);\n \n   /* Return the nops generated for preserving of data sets back\n      into pool.  */\n@@ -5671,6 +5670,10 @@ move_op_orig_expr_found (insn_t insn, expr_t expr,\n   insn_emitted = handle_emitting_transformations (insn, expr, params);\n   only_disconnect = (params->uid == INSN_UID (insn)\n                      && ! insn_emitted  && ! EXPR_WAS_CHANGED (expr));\n+\n+  /* Mark that we've disconnected an insn.  */\n+  if (only_disconnect)\n+    params->uid = -1;\n   remove_insn_from_stream (insn, only_disconnect);\n }\n \n@@ -6053,7 +6056,7 @@ code_motion_process_successors (insn_t insn, av_set_t orig_ops,\n #endif\n   \n   /* Merge data, clean up, etc.  */\n-  if (code_motion_path_driver_info->after_merge_succs)\n+  if (res != -1 && code_motion_path_driver_info->after_merge_succs)\n     code_motion_path_driver_info->after_merge_succs (&lparams, static_params);\n \n   return res;\n@@ -6081,7 +6084,7 @@ code_motion_path_driver_cleanup (av_set_t *orig_ops_p, ilist_t *path_p)\n \n    Returns whether original instructions were found.  Note that top-level\n    code_motion_path_driver always returns true.  */\n-static bool\n+static int\n code_motion_path_driver (insn_t insn, av_set_t orig_ops, ilist_t path, \n \t\t\t cmpd_local_params_p local_params_in, \n \t\t\t void *static_params)\n@@ -6315,12 +6318,14 @@ code_motion_path_driver (insn_t insn, av_set_t orig_ops, ilist_t path,\n    DEST is the register chosen for scheduling the current expr.  Insert\n    bookkeeping code in the join points.  EXPR_VLIW is the chosen expression,\n    C_EXPR is how it looks like at the given cfg point.  \n+   Set *SHOULD_MOVE to indicate whether we have only disconnected\n+   one of the insns found.\n \n    Returns whether original instructions were found, which is asserted \n    to be true in the caller.  */\n static bool\n move_op (insn_t insn, av_set_t orig_ops, expr_t expr_vliw,\n-         rtx dest, expr_t c_expr)\n+         rtx dest, expr_t c_expr, bool *should_move)\n {\n   struct moveop_static_params sparams;\n   struct cmpd_local_params lparams;\n@@ -6346,6 +6351,8 @@ move_op (insn_t insn, av_set_t orig_ops, expr_t expr_vliw,\n   if (sparams.was_renamed)\n     EXPR_WAS_RENAMED (expr_vliw) = true;\n \n+  *should_move = (sparams.uid == -1);\n+\n   return res;\n }\n \f"}, {"sha": "b609538867c03b94a6332bcdfdc69f92474bbea2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a54528dbba23fab21e2997bb6a3d80bf6f1a13/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a54528dbba23fab21e2997bb6a3d80bf6f1a13/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=72a54528dbba23fab21e2997bb6a3d80bf6f1a13", "patch": "@@ -1,3 +1,8 @@\n+2009-01-29  Steve Ellcey  <sje@cup.hp.com>\n+\n+\tPR middle-end/38857\n+\t* gcc.c-torture/compile/pr38857.c: New test.\n+\n 2009-01-28  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/38852"}, {"sha": "2492b77a131b3a3e0797fed65faffc480bbb5095", "filename": "gcc/testsuite/gcc.c-torture/compile/pr38857.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a54528dbba23fab21e2997bb6a3d80bf6f1a13/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr38857.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a54528dbba23fab21e2997bb6a3d80bf6f1a13/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr38857.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr38857.c?ref=72a54528dbba23fab21e2997bb6a3d80bf6f1a13", "patch": "@@ -0,0 +1,22 @@\n+static const int vs_total_ac_bits = 2680;\n+typedef struct EncBlockInfo {\n+      short mb[64];\n+      unsigned char next[64];\n+} EncBlockInfo;\n+inline void dv_guess_qnos(EncBlockInfo* blks, int* qnos) {\n+      int size[5];\n+      int j, k, a, prev;\n+      EncBlockInfo* b;\n+      for(a=2; a==2 || vs_total_ac_bits < size[0]; a+=a){\n+\t for (j=0; j<6*5; j++, b++) {\n+\t     for (k= b->next[prev]; k<64; k= b->next[k]) {\n+\t\t if(b->mb[k] < a && b->mb[k] > -a){\n+\t\t     b->next[prev] = b->next[k];\n+\t\t }\n+\t\t else{\n+\t\t     prev = k;\n+\t\t }\n+\t     }\n+\t }\n+     }\n+}"}]}