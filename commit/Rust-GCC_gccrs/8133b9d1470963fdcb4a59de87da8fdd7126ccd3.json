{"sha": "8133b9d1470963fdcb4a59de87da8fdd7126ccd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODEzM2I5ZDE0NzA5NjNmZGNiNGE1OWRlODdkYThmZGQ3MTI2Y2NkMw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-08-14T08:37:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:37:41Z"}, "message": "atree.ads, atree.adb (New_Copy_Tree): If hash table is being used and itype is visited...\n\n2007-08-14  Ed Schonberg  <schonberg@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\n\t* atree.ads, atree.adb (New_Copy_Tree): If hash table is being used and\n\titype is visited, make an entry into table to link associated node and\n\tnew itype.\n\tAdd comments and correct harmless error in Build_NCT_Hash_Tables\n\t(Array_Aggr_Subtype): Associate each itype created for an index type to\n\tthe corresponding range construct, and not to the aggregate itself. to\n\tmaintain a one-to-one correspondence between itype and its associated\n\tnode, to prevent errors when complex expression is copied.\n\tFix mishandling of multiple levels of parens\n\n\t* sem_aggr.adb: Create a limited view of an incomplete type, to make\n\ttreatment of limited views uniform for all visible declarations in a\n\tlimited_withed package.\n\t(New_Copy_Tree): If hash table is being used and itype is visited,\n\tmake an entry into table to link associated node and new itype.\n\t(Resolve_Record_Aggregate): Do not add an others box association for a\n\tdiscriminated record component that has only discriminants, when there\n\tis a box association for the component itself.\n\n\t* par-ch4.adb: Fix mishandling of multiple levels of parens\n\nFrom-SVN: r127412", "tree": {"sha": "eeb7028ea7bb45439250ba54a1e86ad8d3faf240", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eeb7028ea7bb45439250ba54a1e86ad8d3faf240"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8133b9d1470963fdcb4a59de87da8fdd7126ccd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8133b9d1470963fdcb4a59de87da8fdd7126ccd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8133b9d1470963fdcb4a59de87da8fdd7126ccd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8133b9d1470963fdcb4a59de87da8fdd7126ccd3/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d766cee3c3df3a0a6f5893f7f262dc10d150c85e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d766cee3c3df3a0a6f5893f7f262dc10d150c85e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d766cee3c3df3a0a6f5893f7f262dc10d150c85e"}], "stats": {"total": 566, "additions": 378, "deletions": 188}, "files": [{"sha": "f274bc8b623b71c7d434a0b1b86cc43e27e1ceb8", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 229, "deletions": 111, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8133b9d1470963fdcb4a59de87da8fdd7126ccd3/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8133b9d1470963fdcb4a59de87da8fdd7126ccd3/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=8133b9d1470963fdcb4a59de87da8fdd7126ccd3", "patch": "@@ -535,6 +535,32 @@ package body Atree is\n    subtype NCT_Header_Num is Int range 0 .. 511;\n    --  Defines range of headers in hash tables (512 headers)\n \n+   --------------------------\n+   -- Paren_Count Handling --\n+   --------------------------\n+\n+   --  As noted in the spec, the paren count in a sub-expression node has\n+   --  four possible values 0,1,2, and 3. The value 3 really means 3 or more,\n+   --  and we use an auxiliary serially scanned table to record the actual\n+   --  count. A serial search is fine, only pathological programs will use\n+   --  entries in this table. Normal programs won't use it at all.\n+\n+   type Paren_Count_Entry is record\n+      Nod   : Node_Id;\n+      --  The node to which this count applies\n+\n+      Count : Nat range 3 .. Nat'Last;\n+      --  The count of parentheses, which will be in the indicated range\n+   end record;\n+\n+   package Paren_Counts is new Table.Table (\n+     Table_Component_Type => Paren_Count_Entry,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 0,\n+     Table_Initial        => 10,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Paren_Counts\");\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -590,6 +616,15 @@ package body Atree is\n          Node_Count := Node_Count + 1;\n       end if;\n \n+      --  Specifically copy Paren_Count to deal with creating new table entry\n+      --  if the parentheses count is at the maximum possible value already.\n+\n+      if Present (Src) and then Nkind (Src) in N_Subexpr then\n+         Set_Paren_Count (New_Id, Paren_Count (Src));\n+      end if;\n+\n+      --  Set extension nodes if required\n+\n       if With_Extension then\n          Nodes.Append (Ext1);\n          Nodes.Append (Ext2);\n@@ -608,7 +643,7 @@ package body Atree is\n \n    function Analyzed (N : Node_Id) return Boolean is\n    begin\n-      pragma Assert (N in Nodes.First .. Nodes.Last);\n+      pragma Assert (N <= Nodes.Last);\n       return Nodes.Table (N).Analyzed;\n    end Analyzed;\n \n@@ -622,7 +657,7 @@ package body Atree is\n       Save_Link    : constant Union_Id   := Nodes.Table (N).Link;\n       Save_CFS     : constant Boolean    := Nodes.Table (N).Comes_From_Source;\n       Save_Posted  : constant Boolean    := Nodes.Table (N).Error_Posted;\n-      Par_Count    : Paren_Count_Type    := 0;\n+      Par_Count    : Nat                 := 0;\n \n    begin\n       if Nkind (N) in N_Subexpr then\n@@ -648,7 +683,7 @@ package body Atree is\n \n    function Comes_From_Source (N : Node_Id) return Boolean is\n    begin\n-      pragma Assert (N in Nodes.First .. Nodes.Last);\n+      pragma Assert (N <= Nodes.Last);\n       return Nodes.Table (N).Comes_From_Source;\n    end Comes_From_Source;\n \n@@ -675,6 +710,15 @@ package body Atree is\n       Nodes.Table (Destination).In_List := Save_In_List;\n       Nodes.Table (Destination).Link    := Save_Link;\n \n+      --  Specifically set Paren_Count to make sure auxiliary table entry\n+      --  gets correctly made if the parentheses count is at the max value.\n+\n+      if Nkind (Destination) in N_Subexpr then\n+         Set_Paren_Count (Destination, Paren_Count (Source));\n+      end if;\n+\n+      --  Deal with copying extension nodes if present\n+\n       if Has_Extension (Source) then\n          pragma Assert (Has_Extension (Destination));\n          Nodes.Table (Destination + 1) := Nodes.Table (Source + 1);\n@@ -923,7 +967,7 @@ package body Atree is\n \n    function Error_Posted (N : Node_Id) return Boolean is\n    begin\n-      pragma Assert (N in Nodes.First .. Nodes.Last);\n+      pragma Assert (N <= Nodes.Last);\n       return Nodes.Table (N).Error_Posted;\n    end Error_Posted;\n \n@@ -1092,6 +1136,7 @@ package body Atree is\n       Node_Count := 0;\n       Atree_Private_Part.Nodes.Init;\n       Orig_Nodes.Init;\n+      Paren_Counts.Init;\n \n       --  Allocate Empty node\n \n@@ -1360,9 +1405,11 @@ package body Atree is\n          Elmt := First_Elmt (Actual_Map);\n          while Present (Elmt) loop\n             Ent := Node (Elmt);\n+\n+            --  Get new entity, and associate old and new\n+\n             Next_Elmt (Elmt);\n             NCT_Assoc.Set (Ent, Node (Elmt));\n-            Next_Elmt (Elmt);\n \n             if Is_Type (Ent) then\n                declare\n@@ -1371,10 +1418,17 @@ package body Atree is\n \n                begin\n                   if Present (Anode) then\n+\n+                     --  Enter a link between the associated node of the\n+                     --  old Itype and the new Itype, for updating later\n+                     --  when node is copied.\n+\n                      NCT_Itype_Assoc.Set (Anode, Node (Elmt));\n                   end if;\n                end;\n             end if;\n+\n+            Next_Elmt (Elmt);\n          end loop;\n \n          NCT_Hash_Tables_Used := True;\n@@ -1877,13 +1931,21 @@ package body Atree is\n             if NCT_Hash_Tables_Used then\n \n                Ent := NCT_Assoc.Get (Associated_Node_For_Itype (Old_Itype));\n+\n                if Present (Ent) then\n                   Set_Associated_Node_For_Itype (New_Itype, Ent);\n                end if;\n \n                Ent := NCT_Itype_Assoc.Get (Old_Itype);\n                if Present (Ent) then\n                   Set_Associated_Node_For_Itype (Ent, New_Itype);\n+\n+               --  If the hash table has no association for this Itype and\n+               --  its associated node, enter one now.\n+\n+               else\n+                  NCT_Itype_Assoc.Set\n+                    (Associated_Node_For_Itype (Old_Itype), New_Itype);\n                end if;\n \n             --  Case of hash tables not used\n@@ -2251,11 +2313,11 @@ package body Atree is\n    -- Paren_Count --\n    -----------------\n \n-   function Paren_Count (N : Node_Id) return Paren_Count_Type is\n-      C : Paren_Count_Type := 0;\n+   function Paren_Count (N : Node_Id) return Nat is\n+      C : Nat := 0;\n \n    begin\n-      pragma Assert (N in Nodes.First .. Nodes.Last);\n+      pragma Assert (N <= Nodes.Last);\n \n       if Nodes.Table (N).Pflag1 then\n          C := C + 1;\n@@ -2265,7 +2327,22 @@ package body Atree is\n          C := C + 2;\n       end if;\n \n-      return C;\n+      --  Value of 0,1,2 returned as is\n+\n+      if C <= 2 then\n+         return C;\n+\n+      --  Value of 3 means we search the table, and we must find an entry\n+\n+      else\n+         for J in Paren_Counts.First .. Paren_Counts.Last loop\n+            if N = Paren_Counts.Table (J).Nod then\n+               return Paren_Counts.Table (J).Count;\n+            end if;\n+         end loop;\n+\n+         raise Program_Error;\n+      end if;\n    end Paren_Count;\n \n    ------------\n@@ -2375,11 +2452,10 @@ package body Atree is\n    -------------\n \n    procedure Rewrite (Old_Node, New_Node : Node_Id) is\n-\n       Old_Error_P : constant Boolean  := Nodes.Table (Old_Node).Error_Posted;\n       --  This fields is always preserved in the new node\n \n-      Old_Paren_Count     : Paren_Count_Type;\n+      Old_Paren_Count     : Nat;\n       Old_Must_Not_Freeze : Boolean;\n       --  These fields are preserved in the new node only if the new node\n       --  and the old node are both subexpression nodes.\n@@ -2443,7 +2519,7 @@ package body Atree is\n \n    procedure Set_Comes_From_Source (N : Node_Id; Val : Boolean) is\n    begin\n-      pragma Assert (N in Nodes.First .. Nodes.Last);\n+      pragma Assert (N <= Nodes.Last);\n       Nodes.Table (N).Comes_From_Source := Val;\n    end Set_Comes_From_Source;\n \n@@ -2492,11 +2568,31 @@ package body Atree is\n    -- Set_Paren_Count --\n    ---------------------\n \n-   procedure Set_Paren_Count (N : Node_Id; Val : Paren_Count_Type) is\n+   procedure Set_Paren_Count (N : Node_Id; Val : Nat) is\n    begin\n       pragma Assert (Nkind (N) in N_Subexpr);\n-      Nodes.Table (N).Pflag1 := (Val mod 2 /= 0);\n-      Nodes.Table (N).Pflag2 := (Val >= 2);\n+\n+      --  Value of 0,1,2 stored as is\n+\n+      if Val <= 2 then\n+         Nodes.Table (N).Pflag1 := (Val mod 2 /= 0);\n+         Nodes.Table (N).Pflag2 := (Val = 2);\n+\n+      --  Value of 3 or greater stores 3 in node and makes table entry\n+\n+      else\n+         Nodes.Table (N).Pflag1 := True;\n+         Nodes.Table (N).Pflag2 := True;\n+\n+         for J in Paren_Counts.First .. Paren_Counts.Last loop\n+            if N = Paren_Counts.Table (J).Nod then\n+               Paren_Counts.Table (J).Count := Val;\n+               return;\n+            end if;\n+         end loop;\n+\n+         Paren_Counts.Append ((Nod => N, Count => Val));\n+      end if;\n    end Set_Paren_Count;\n \n    ----------------\n@@ -2673,6 +2769,7 @@ package body Atree is\n       Tree_Read_Int (Node_Count);\n       Nodes.Tree_Read;\n       Orig_Nodes.Tree_Read;\n+      Paren_Counts.Tree_Read;\n    end Tree_Read;\n \n    ----------------\n@@ -2684,6 +2781,7 @@ package body Atree is\n       Tree_Write_Int (Node_Count);\n       Nodes.Tree_Write;\n       Orig_Nodes.Tree_Write;\n+      Paren_Counts.Tree_Write;\n    end Tree_Write;\n \n    ------------------------------\n@@ -2694,31 +2792,31 @@ package body Atree is\n \n       function Field1 (N : Node_Id) return Union_Id is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Field1;\n       end Field1;\n \n       function Field2 (N : Node_Id) return Union_Id is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Field2;\n       end Field2;\n \n       function Field3 (N : Node_Id) return Union_Id is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Field3;\n       end Field3;\n \n       function Field4 (N : Node_Id) return Union_Id is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Field4;\n       end Field4;\n \n       function Field5 (N : Node_Id) return Union_Id is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Field5;\n       end Field5;\n \n@@ -2862,31 +2960,31 @@ package body Atree is\n \n       function Node1 (N : Node_Id) return Node_Id is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Node_Id (Nodes.Table (N).Field1);\n       end Node1;\n \n       function Node2 (N : Node_Id) return Node_Id is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Node_Id (Nodes.Table (N).Field2);\n       end Node2;\n \n       function Node3 (N : Node_Id) return Node_Id is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Node_Id (Nodes.Table (N).Field3);\n       end Node3;\n \n       function Node4 (N : Node_Id) return Node_Id is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Node_Id (Nodes.Table (N).Field4);\n       end Node4;\n \n       function Node5 (N : Node_Id) return Node_Id is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Node_Id (Nodes.Table (N).Field5);\n       end Node5;\n \n@@ -3030,31 +3128,31 @@ package body Atree is\n \n       function List1 (N : Node_Id) return List_Id is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return List_Id (Nodes.Table (N).Field1);\n       end List1;\n \n       function List2 (N : Node_Id) return List_Id is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return List_Id (Nodes.Table (N).Field2);\n       end List2;\n \n       function List3 (N : Node_Id) return List_Id is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return List_Id (Nodes.Table (N).Field3);\n       end List3;\n \n       function List4 (N : Node_Id) return List_Id is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return List_Id (Nodes.Table (N).Field4);\n       end List4;\n \n       function List5 (N : Node_Id) return List_Id is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return List_Id (Nodes.Table (N).Field5);\n       end List5;\n \n@@ -3071,7 +3169,7 @@ package body Atree is\n       end List14;\n \n       function Elist1 (N : Node_Id) return Elist_Id is\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Value : constant Union_Id := Nodes.Table (N).Field1;\n       begin\n          if Value = 0 then\n@@ -3082,7 +3180,7 @@ package body Atree is\n       end Elist1;\n \n       function Elist2 (N : Node_Id) return Elist_Id is\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Value : constant Union_Id := Nodes.Table (N).Field2;\n       begin\n          if Value = 0 then\n@@ -3093,7 +3191,7 @@ package body Atree is\n       end Elist2;\n \n       function Elist3 (N : Node_Id) return Elist_Id is\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Value : constant Union_Id := Nodes.Table (N).Field3;\n       begin\n          if Value = 0 then\n@@ -3104,7 +3202,7 @@ package body Atree is\n       end Elist3;\n \n       function Elist4 (N : Node_Id) return Elist_Id is\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Value : constant Union_Id := Nodes.Table (N).Field4;\n       begin\n          if Value = 0 then\n@@ -3204,24 +3302,24 @@ package body Atree is\n \n       function Name1 (N : Node_Id) return Name_Id is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Name_Id (Nodes.Table (N).Field1);\n       end Name1;\n \n       function Name2 (N : Node_Id) return Name_Id is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Name_Id (Nodes.Table (N).Field2);\n       end Name2;\n \n       function Str3 (N : Node_Id) return String_Id is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return String_Id (Nodes.Table (N).Field3);\n       end Str3;\n \n       function Uint2 (N : Node_Id) return Uint is\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          U : constant Union_Id := Nodes.Table (N).Field2;\n       begin\n          if U = 0 then\n@@ -3232,7 +3330,7 @@ package body Atree is\n       end Uint2;\n \n       function Uint3 (N : Node_Id) return Uint is\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          U : constant Union_Id := Nodes.Table (N).Field3;\n       begin\n          if U = 0 then\n@@ -3243,7 +3341,7 @@ package body Atree is\n       end Uint3;\n \n       function Uint4 (N : Node_Id) return Uint is\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          U : constant Union_Id := Nodes.Table (N).Field4;\n       begin\n          if U = 0 then\n@@ -3254,7 +3352,7 @@ package body Atree is\n       end Uint4;\n \n       function Uint5 (N : Node_Id) return Uint is\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          U : constant Union_Id := Nodes.Table (N).Field5;\n       begin\n          if U = 0 then\n@@ -3387,7 +3485,7 @@ package body Atree is\n \n       function Ureal3 (N : Node_Id) return Ureal is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return From_Union (Nodes.Table (N).Field3);\n       end Ureal3;\n \n@@ -3405,91 +3503,91 @@ package body Atree is\n \n       function Flag4 (N : Node_Id) return Boolean is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Flag4;\n       end Flag4;\n \n       function Flag5 (N : Node_Id) return Boolean is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Flag5;\n       end Flag5;\n \n       function Flag6 (N : Node_Id) return Boolean is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Flag6;\n       end Flag6;\n \n       function Flag7 (N : Node_Id) return Boolean is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Flag7;\n       end Flag7;\n \n       function Flag8 (N : Node_Id) return Boolean is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Flag8;\n       end Flag8;\n \n       function Flag9 (N : Node_Id) return Boolean is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Flag9;\n       end Flag9;\n \n       function Flag10 (N : Node_Id) return Boolean is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Flag10;\n       end Flag10;\n \n       function Flag11 (N : Node_Id) return Boolean is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Flag11;\n       end Flag11;\n \n       function Flag12 (N : Node_Id) return Boolean is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Flag12;\n       end Flag12;\n \n       function Flag13 (N : Node_Id) return Boolean is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Flag13;\n       end Flag13;\n \n       function Flag14 (N : Node_Id) return Boolean is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Flag14;\n       end Flag14;\n \n       function Flag15 (N : Node_Id) return Boolean is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Flag15;\n       end Flag15;\n \n       function Flag16 (N : Node_Id) return Boolean is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Flag16;\n       end Flag16;\n \n       function Flag17 (N : Node_Id) return Boolean is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Flag17;\n       end Flag17;\n \n       function Flag18 (N : Node_Id) return Boolean is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          return Nodes.Table (N).Flag18;\n       end Flag18;\n \n@@ -4767,37 +4865,37 @@ package body Atree is\n \n       procedure Set_Nkind (N : Node_Id; Val : Node_Kind) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Nkind := Val;\n       end Set_Nkind;\n \n       procedure Set_Field1 (N : Node_Id; Val : Union_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field1 := Val;\n       end Set_Field1;\n \n       procedure Set_Field2 (N : Node_Id; Val : Union_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field2 := Val;\n       end Set_Field2;\n \n       procedure Set_Field3 (N : Node_Id; Val : Union_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field3 := Val;\n       end Set_Field3;\n \n       procedure Set_Field4 (N : Node_Id; Val : Union_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field4 := Val;\n       end Set_Field4;\n \n       procedure Set_Field5 (N : Node_Id; Val : Union_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field5 := Val;\n       end Set_Field5;\n \n@@ -4941,31 +5039,31 @@ package body Atree is\n \n       procedure Set_Node1 (N : Node_Id; Val : Node_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field1 := Union_Id (Val);\n       end Set_Node1;\n \n       procedure Set_Node2 (N : Node_Id; Val : Node_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field2 := Union_Id (Val);\n       end Set_Node2;\n \n       procedure Set_Node3 (N : Node_Id; Val : Node_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field3 := Union_Id (Val);\n       end Set_Node3;\n \n       procedure Set_Node4 (N : Node_Id; Val : Node_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field4 := Union_Id (Val);\n       end Set_Node4;\n \n       procedure Set_Node5 (N : Node_Id; Val : Node_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field5 := Union_Id (Val);\n       end Set_Node5;\n \n@@ -5109,31 +5207,31 @@ package body Atree is\n \n       procedure Set_List1 (N : Node_Id; Val : List_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field1 := Union_Id (Val);\n       end Set_List1;\n \n       procedure Set_List2 (N : Node_Id; Val : List_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field2 := Union_Id (Val);\n       end Set_List2;\n \n       procedure Set_List3 (N : Node_Id; Val : List_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field3 := Union_Id (Val);\n       end Set_List3;\n \n       procedure Set_List4 (N : Node_Id; Val : List_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field4 := Union_Id (Val);\n       end Set_List4;\n \n       procedure Set_List5 (N : Node_Id; Val : List_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field5 := Union_Id (Val);\n       end Set_List5;\n \n@@ -5219,43 +5317,43 @@ package body Atree is\n \n       procedure Set_Name1 (N : Node_Id; Val : Name_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field1 := Union_Id (Val);\n       end Set_Name1;\n \n       procedure Set_Name2 (N : Node_Id; Val : Name_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field2 := Union_Id (Val);\n       end Set_Name2;\n \n       procedure Set_Str3 (N : Node_Id; Val : String_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field3 := Union_Id (Val);\n       end Set_Str3;\n \n       procedure Set_Uint2 (N : Node_Id; Val : Uint) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field2 := To_Union (Val);\n       end Set_Uint2;\n \n       procedure Set_Uint3 (N : Node_Id; Val : Uint) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field3 := To_Union (Val);\n       end Set_Uint3;\n \n       procedure Set_Uint4 (N : Node_Id; Val : Uint) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field4 := To_Union (Val);\n       end Set_Uint4;\n \n       procedure Set_Uint5 (N : Node_Id; Val : Uint) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field5 := To_Union (Val);\n       end Set_Uint5;\n \n@@ -5327,7 +5425,7 @@ package body Atree is\n \n       procedure Set_Ureal3 (N : Node_Id; Val : Ureal) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Field3 := To_Union (Val);\n       end Set_Ureal3;\n \n@@ -5345,91 +5443,91 @@ package body Atree is\n \n       procedure Set_Flag4 (N : Node_Id; Val : Boolean) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Flag4 := Val;\n       end Set_Flag4;\n \n       procedure Set_Flag5 (N : Node_Id; Val : Boolean) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Flag5 := Val;\n       end Set_Flag5;\n \n       procedure Set_Flag6 (N : Node_Id; Val : Boolean) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Flag6 := Val;\n       end Set_Flag6;\n \n       procedure Set_Flag7 (N : Node_Id; Val : Boolean) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Flag7 := Val;\n       end Set_Flag7;\n \n       procedure Set_Flag8 (N : Node_Id; Val : Boolean) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Flag8 := Val;\n       end Set_Flag8;\n \n       procedure Set_Flag9 (N : Node_Id; Val : Boolean) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Flag9 := Val;\n       end Set_Flag9;\n \n       procedure Set_Flag10 (N : Node_Id; Val : Boolean) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Flag10 := Val;\n       end Set_Flag10;\n \n       procedure Set_Flag11 (N : Node_Id; Val : Boolean) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Flag11 := Val;\n       end Set_Flag11;\n \n       procedure Set_Flag12 (N : Node_Id; Val : Boolean) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Flag12 := Val;\n       end Set_Flag12;\n \n       procedure Set_Flag13 (N : Node_Id; Val : Boolean) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Flag13 := Val;\n       end Set_Flag13;\n \n       procedure Set_Flag14 (N : Node_Id; Val : Boolean) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Flag14 := Val;\n       end Set_Flag14;\n \n       procedure Set_Flag15 (N : Node_Id; Val : Boolean) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Flag15 := Val;\n       end Set_Flag15;\n \n       procedure Set_Flag16 (N : Node_Id; Val : Boolean) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Flag16 := Val;\n       end Set_Flag16;\n \n       procedure Set_Flag17 (N : Node_Id; Val : Boolean) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Flag17 := Val;\n       end Set_Flag17;\n \n       procedure Set_Flag18 (N : Node_Id; Val : Boolean) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          Nodes.Table (N).Flag18 := Val;\n       end Set_Flag18;\n \n@@ -6993,42 +7091,62 @@ package body Atree is\n \n       procedure Set_Node1_With_Parent (N : Node_Id; Val : Node_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n-         if Val > Error then Set_Parent (Val, N); end if;\n+         pragma Assert (N <= Nodes.Last);\n+\n+         if Val > Error then\n+            Set_Parent (Val, N);\n+         end if;\n+\n          Set_Node1 (N, Val);\n       end Set_Node1_With_Parent;\n \n       procedure Set_Node2_With_Parent (N : Node_Id; Val : Node_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n-         if Val > Error then Set_Parent (Val, N); end if;\n+         pragma Assert (N <= Nodes.Last);\n+\n+         if Val > Error then\n+            Set_Parent (Val, N);\n+         end if;\n+\n          Set_Node2 (N, Val);\n       end Set_Node2_With_Parent;\n \n       procedure Set_Node3_With_Parent (N : Node_Id; Val : Node_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n-         if Val > Error then Set_Parent (Val, N); end if;\n+         pragma Assert (N <= Nodes.Last);\n+\n+         if Val > Error then\n+            Set_Parent (Val, N);\n+         end if;\n+\n          Set_Node3 (N, Val);\n       end Set_Node3_With_Parent;\n \n       procedure Set_Node4_With_Parent (N : Node_Id; Val : Node_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n-         if Val > Error then Set_Parent (Val, N); end if;\n+         pragma Assert (N <= Nodes.Last);\n+\n+         if Val > Error then\n+            Set_Parent (Val, N);\n+         end if;\n+\n          Set_Node4 (N, Val);\n       end Set_Node4_With_Parent;\n \n       procedure Set_Node5_With_Parent (N : Node_Id; Val : Node_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n-         if Val > Error then Set_Parent (Val, N); end if;\n+         pragma Assert (N <= Nodes.Last);\n+\n+         if Val > Error then\n+            Set_Parent (Val, N);\n+         end if;\n+\n          Set_Node5 (N, Val);\n       end Set_Node5_With_Parent;\n \n       procedure Set_List1_With_Parent (N : Node_Id; Val : List_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          if Val /= No_List and then Val /= Error_List then\n             Set_Parent (Val, N);\n          end if;\n@@ -7037,7 +7155,7 @@ package body Atree is\n \n       procedure Set_List2_With_Parent (N : Node_Id; Val : List_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          if Val /= No_List and then Val /= Error_List then\n             Set_Parent (Val, N);\n          end if;\n@@ -7046,7 +7164,7 @@ package body Atree is\n \n       procedure Set_List3_With_Parent (N : Node_Id; Val : List_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          if Val /= No_List and then Val /= Error_List then\n             Set_Parent (Val, N);\n          end if;\n@@ -7055,7 +7173,7 @@ package body Atree is\n \n       procedure Set_List4_With_Parent (N : Node_Id; Val : List_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          if Val /= No_List and then Val /= Error_List then\n             Set_Parent (Val, N);\n          end if;\n@@ -7064,7 +7182,7 @@ package body Atree is\n \n       procedure Set_List5_With_Parent (N : Node_Id; Val : List_Id) is\n       begin\n-         pragma Assert (N in Nodes.First .. Nodes.Last);\n+         pragma Assert (N <= Nodes.Last);\n          if Val /= No_List and then Val /= Error_List then\n             Set_Parent (Val, N);\n          end if;"}, {"sha": "5e2cba6857c809b5b957afea8b22b4ab84836b6e", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8133b9d1470963fdcb4a59de87da8fdd7126ccd3/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8133b9d1470963fdcb4a59de87da8fdd7126ccd3/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=8133b9d1470963fdcb4a59de87da8fdd7126ccd3", "patch": "@@ -94,12 +94,11 @@ package Atree is\n    --   Rewrite_Ins   A flag set if a node is marked as a rewrite inserted\n    --                 node as a result of a call to Mark_Rewrite_Insertion.\n \n-   --   Paren_Count   A 2-bit count used on expression nodes to indicate\n-   --                 the level of parentheses. Up to 3 levels can be\n-   --                 accomodated. Anything more than 3 levels is treated\n-   --                 as 3 levels (conformance tests that complain about\n-   --                 this are hereby deemed pathological!). Set to zero\n-   --                 for non-subexpression nodes.\n+   --   Paren_Count   A 2-bit count used in sub-expression nodes to indicate\n+   --                 the level of parentheses. The settings are 0,1,2 and\n+   --                 3 for many. If the value is 3, then an auxiliary table\n+   --                 is used to indicate the real value. Set to zero for\n+   --                 non-subexpression nodes.\n \n    --   Comes_From_Source\n    --                 This flag is present in all nodes. It is set if the\n@@ -203,10 +202,6 @@ package Atree is\n    --   Elist7-Elist28, Uint7-Uint28, Ureal7-Ureal28). Note that not all\n    --   these functions are defined, only the ones that are actually used.\n \n-   type Paren_Count_Type is mod 4;\n-   for Paren_Count_Type'Size use 2;\n-   --  Type used for Paren_Count field\n-\n    function Last_Node_Id return Node_Id;\n    pragma Inline (Last_Node_Id);\n    --  Returns Id of last allocated node Id\n@@ -548,7 +543,7 @@ package Atree is\n \n    --  The result returned by Traverse is Abandon if processing was terminated\n    --  by a call to Process returning Abandon, otherwise it is OK (meaning that\n-   --  all calls to process returned either OK or Skip).\n+   --  all calls to process returned either OK, OK_Orig, or Skip).\n \n    generic\n      with function Process (N : Node_Id) return Traverse_Result is <>;\n@@ -579,7 +574,7 @@ package Atree is\n    function Sloc              (N : Node_Id) return Source_Ptr;\n    pragma Inline (Sloc);\n \n-   function Paren_Count       (N : Node_Id) return Paren_Count_Type;\n+   function Paren_Count       (N : Node_Id) return Nat;\n    pragma Inline (Paren_Count);\n \n    function Parent            (N : Node_Id) return Node_Id;\n@@ -623,7 +618,7 @@ package Atree is\n    procedure Set_Sloc         (N : Node_Id; Val : Source_Ptr);\n    pragma Inline (Set_Sloc);\n \n-   procedure Set_Paren_Count  (N : Node_Id; Val : Paren_Count_Type);\n+   procedure Set_Paren_Count  (N : Node_Id; Val : Nat);\n    pragma Inline (Set_Paren_Count);\n \n    procedure Set_Parent       (N : Node_Id; Val : Node_Id);"}, {"sha": "2d1adcdbb9d092edd6f52c6694a4af622e9e48ba", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 99, "deletions": 21, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8133b9d1470963fdcb4a59de87da8fdd7126ccd3/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8133b9d1470963fdcb4a59de87da8fdd7126ccd3/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=8133b9d1470963fdcb4a59de87da8fdd7126ccd3", "patch": "@@ -69,7 +69,7 @@ package body Ch4 is\n \n    procedure Bad_Range_Attribute (Loc : Source_Ptr) is\n    begin\n-      Error_Msg (\"range attribute cannot be used in expression\", Loc);\n+      Error_Msg (\"range attribute cannot be used in expression!\", Loc);\n       Resync_Expression;\n    end Bad_Range_Attribute;\n \n@@ -1267,18 +1267,14 @@ package body Ch4 is\n             then\n                Error_Msg\n                  (\"|parentheses not allowed for range attribute\", Lparen_Sloc);\n+               Scan; -- past right paren\n                return Expr_Node;\n             end if;\n \n-            --  Bump paren count of expression, note that if the paren count\n-            --  is already at the maximum, then we leave it alone. This will\n-            --  cause some failures in pathalogical conformance tests, which\n-            --  we do not shed a tear over!\n+            --  Bump paren count of expression\n \n             if Expr_Node /= Error then\n-               if Paren_Count (Expr_Node) /= Paren_Count_Type'Last then\n-                  Set_Paren_Count (Expr_Node, Paren_Count (Expr_Node) + 1);\n-               end if;\n+               Set_Paren_Count (Expr_Node, Paren_Count (Expr_Node) + 1);\n             end if;\n \n             T_Right_Paren; -- past right paren (error message if none)\n@@ -1577,11 +1573,13 @@ package body Ch4 is\n    --  called in all contexts where a right parenthesis cannot legitimately\n    --  follow an expression.\n \n-   --  Error recovery: can raise Error_Resync\n+   --  Error recovery: can not raise Error_Resync\n \n    function P_Expression_No_Right_Paren return Node_Id is\n+      Expr : constant Node_Id := P_Expression;\n    begin\n-      return No_Right_Paren (P_Expression);\n+      Check_No_Right_Paren;\n+      return Expr;\n    end P_Expression_No_Right_Paren;\n \n    ----------------------------------------\n@@ -1805,7 +1803,10 @@ package body Ch4 is\n \n          else\n             if Token = Tok_Double_Asterisk then\n-               if Style_Check then Style.Check_Exponentiation_Operator; end if;\n+               if Style_Check then\n+                  Style.Check_Exponentiation_Operator;\n+               end if;\n+\n                Node2 := New_Node (N_Op_Expon, Token_Ptr);\n                Scan; -- past **\n                Set_Left_Opnd (Node2, Node1);\n@@ -1818,7 +1819,11 @@ package body Ch4 is\n                exit when Token not in Token_Class_Mulop;\n                Tokptr := Token_Ptr;\n                Node2 := New_Node (P_Multiplying_Operator, Tokptr);\n-               if Style_Check then Style.Check_Binary_Operator; end if;\n+\n+               if Style_Check then\n+                  Style.Check_Binary_Operator;\n+               end if;\n+\n                Scan; -- past operator\n                Set_Left_Opnd (Node2, Node1);\n                Set_Right_Opnd (Node2, P_Factor);\n@@ -1830,7 +1835,11 @@ package body Ch4 is\n                exit when Token not in Token_Class_Binary_Addop;\n                Tokptr := Token_Ptr;\n                Node2 := New_Node (P_Binary_Adding_Operator, Tokptr);\n-               if Style_Check then Style.Check_Binary_Operator; end if;\n+\n+               if Style_Check then\n+                  Style.Check_Binary_Operator;\n+               end if;\n+\n                Scan; -- past operator\n                Set_Left_Opnd (Node2, Node1);\n                Set_Right_Opnd (Node2, P_Term);\n@@ -1849,7 +1858,11 @@ package body Ch4 is\n          if Token in Token_Class_Unary_Addop then\n             Tokptr := Token_Ptr;\n             Node1 := New_Node (P_Unary_Adding_Operator, Tokptr);\n-            if Style_Check then Style.Check_Unary_Plus_Or_Minus; end if;\n+\n+            if Style_Check then\n+               Style.Check_Unary_Plus_Or_Minus;\n+            end if;\n+\n             Scan; -- past operator\n             Set_Right_Opnd (Node1, P_Term);\n             Set_Op_Name (Node1);\n@@ -1951,6 +1964,39 @@ package body Ch4 is\n       Attr_Node : Node_Id;\n \n    begin\n+      --  We don't just want to roar ahead and call P_Simple_Expression\n+      --  here, since we want to handle the case of a parenthesized range\n+      --  attribute cleanly.\n+\n+      if Token = Tok_Left_Paren then\n+         declare\n+            Lptr       : constant Source_Ptr := Token_Ptr;\n+            Scan_State : Saved_Scan_State;\n+\n+         begin\n+            Save_Scan_State (Scan_State);\n+            Scan; -- past left paren\n+            Sexpr := P_Simple_Expression;\n+\n+            if Token = Tok_Apostrophe then\n+               Attr_Node := P_Range_Attribute_Reference (Sexpr);\n+               Expr_Form := EF_Range_Attr;\n+\n+               if Token = Tok_Right_Paren then\n+                  Scan; -- scan past right paren if present\n+               end if;\n+\n+               Error_Msg (\"parentheses not allowed for range attribute\", Lptr);\n+\n+               return Attr_Node;\n+            end if;\n+\n+            Restore_Scan_State (Scan_State);\n+         end;\n+      end if;\n+\n+      --  Here after dealing with parenthesized range attribute\n+\n       Sexpr := P_Simple_Expression;\n \n       if Token = Tok_Apostrophe then\n@@ -2007,15 +2053,23 @@ package body Ch4 is\n    begin\n       if Token = Tok_Abs then\n          Node1 := New_Node (N_Op_Abs, Token_Ptr);\n-         if Style_Check then Style.Check_Abs_Not; end if;\n+\n+         if Style_Check then\n+            Style.Check_Abs_Not;\n+         end if;\n+\n          Scan; -- past ABS\n          Set_Right_Opnd (Node1, P_Primary);\n          Set_Op_Name (Node1);\n          return Node1;\n \n       elsif Token = Tok_Not then\n          Node1 := New_Node (N_Op_Not, Token_Ptr);\n-         if Style_Check then Style.Check_Abs_Not; end if;\n+\n+         if Style_Check then\n+            Style.Check_Abs_Not;\n+         end if;\n+\n          Scan; -- past NOT\n          Set_Right_Opnd (Node1, P_Primary);\n          Set_Op_Name (Node1);\n@@ -2116,7 +2170,18 @@ package body Ch4 is\n             --  Left paren, starts aggregate or parenthesized expression\n \n             when Tok_Left_Paren =>\n-               return P_Aggregate_Or_Paren_Expr;\n+               declare\n+                  Expr : constant Node_Id := P_Aggregate_Or_Paren_Expr;\n+\n+               begin\n+                  if Nkind (Expr) = N_Attribute_Reference\n+                    and then Attribute_Name (Expr) = Name_Range\n+                  then\n+                     Bad_Range_Attribute (Sloc (Expr));\n+                  end if;\n+\n+                  return Expr;\n+               end;\n \n             --  Allocator\n \n@@ -2174,7 +2239,10 @@ package body Ch4 is\n    function P_Logical_Operator return Node_Kind is\n    begin\n       if Token = Tok_And then\n-         if Style_Check then Style.Check_Binary_Operator; end if;\n+         if Style_Check then\n+            Style.Check_Binary_Operator;\n+         end if;\n+\n          Scan; -- past AND\n \n          if Token = Tok_Then then\n@@ -2185,7 +2253,10 @@ package body Ch4 is\n          end if;\n \n       elsif Token = Tok_Or then\n-         if Style_Check then Style.Check_Binary_Operator; end if;\n+         if Style_Check then\n+            Style.Check_Binary_Operator;\n+         end if;\n+\n          Scan; -- past OR\n \n          if Token = Tok_Else then\n@@ -2196,7 +2267,10 @@ package body Ch4 is\n          end if;\n \n       else -- Token = Tok_Xor\n-         if Style_Check then Style.Check_Binary_Operator; end if;\n+         if Style_Check then\n+            Style.Check_Binary_Operator;\n+         end if;\n+\n          Scan; -- past XOR\n          return N_Op_Xor;\n       end if;\n@@ -2235,7 +2309,11 @@ package body Ch4 is\n       end if;\n \n       Op_Kind := Relop_Node (Token);\n-      if Style_Check then Style.Check_Binary_Operator; end if;\n+\n+      if Style_Check then\n+         Style.Check_Binary_Operator;\n+      end if;\n+\n       Scan; -- past operator token\n \n       if Prev_Token = Tok_Not then"}, {"sha": "491d3487b0c2c9a5dd593c5b0f44d88913564650", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 42, "deletions": 43, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8133b9d1470963fdcb4a59de87da8fdd7126ccd3/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8133b9d1470963fdcb4a59de87da8fdd7126ccd3/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=8133b9d1470963fdcb4a59de87da8fdd7126ccd3", "patch": "@@ -39,11 +39,9 @@ with Namet;    use Namet;\n with Nmake;    use Nmake;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n-with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch3;  use Sem_Ch3;\n-with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n@@ -88,7 +86,7 @@ package body Sem_Aggr is\n    --  E_Component/E_Discriminant entity in the record case, in which case the\n    --  type of the component will be used for the test. If Typ is any other\n    --  kind of entity, the call is ignored. Expr is the component node in the\n-   --  aggregate which is an explicit occurrence of NULL. An error will be\n+   --  aggregate which is known to have a null value. A warning message will be\n    --  issued if the component is null excluding.\n    --\n    --  It would be better to pass the proper type for Typ ???\n@@ -639,9 +637,11 @@ package body Sem_Aggr is\n             Index_Typ  : Entity_Id;\n \n          begin\n-            --  Construct the Index subtype\n+            --  Construct the Index subtype, and associate it with the range\n+            --  construct that generates it.\n \n-            Index_Typ := Create_Itype (Subtype_Kind (Ekind (Index_Base)), N);\n+            Index_Typ :=\n+              Create_Itype (Subtype_Kind (Ekind (Index_Base)), Aggr_Range (J));\n \n             Set_Etype (Index_Typ, Index_Base);\n \n@@ -684,32 +684,15 @@ package body Sem_Aggr is\n       Set_Is_Internal    (Itype, True);\n       Init_Size_Align    (Itype);\n \n-      --  Handle aggregate initializing statically allocated dispatch table\n-\n-      if Static_Dispatch_Tables\n-        and then VM_Target = No_VM\n-        and then RTU_Loaded (Ada_Tags)\n-\n-         --  Avoid circularity when rebuilding the compiler\n-\n-        and then Cunit_Entity (Get_Source_Unit (N)) /= RTU_Entity (Ada_Tags)\n-        and then (Etype (N) = RTE (RE_Address_Array)\n-                    or else\n-                  Base_Type (Etype (N)) = RTE (RE_Tag_Table))\n-      then\n-         Set_Size_Known_At_Compile_Time (Itype);\n-\n       --  A simple optimization: purely positional aggregates of static\n       --  components should be passed to gigi unexpanded whenever possible,\n       --  and regardless of the staticness of the bounds themselves. Subse-\n       --  quent checks in exp_aggr verify that type is not packed, etc.\n \n-      else\n-         Set_Size_Known_At_Compile_Time (Itype,\n-            Is_Fully_Positional\n-              and then Comes_From_Source (N)\n-              and then Size_Known_At_Compile_Time (Component_Type (Typ)));\n-      end if;\n+      Set_Size_Known_At_Compile_Time (Itype,\n+         Is_Fully_Positional\n+           and then Comes_From_Source (N)\n+           and then Size_Known_At_Compile_Time (Component_Type (Typ)));\n \n       --  We always need a freeze node for a packed array subtype, so that\n       --  we can build the Packed_Array_Type corresponding to the subtype.\n@@ -1022,7 +1005,7 @@ package body Sem_Aggr is\n                Pkind = N_Procedure_Call_Statement  or else\n                Pkind = N_Generic_Association       or else\n                Pkind = N_Formal_Object_Declaration or else\n-               Pkind = N_Return_Statement          or else\n+               Pkind = N_Simple_Return_Statement   or else\n                Pkind = N_Object_Declaration        or else\n                Pkind = N_Component_Declaration     or else\n                Pkind = N_Parameter_Specification   or else\n@@ -1719,7 +1702,7 @@ package body Sem_Aggr is\n                --  Ada 2005 (AI-231)\n \n                if Ada_Version >= Ada_05\n-                 and then Nkind (Expression (Assoc)) = N_Null\n+                 and then Known_Null (Expression (Assoc))\n                then\n                   Check_Can_Never_Be_Null (Etype (N), Expression (Assoc));\n                end if;\n@@ -1851,7 +1834,7 @@ package body Sem_Aggr is\n             --  Ada 2005 (AI-231)\n \n             if Ada_Version >= Ada_05\n-              and then Nkind (Expr) = N_Null\n+              and then Known_Null (Expr)\n             then\n                Check_Can_Never_Be_Null (Etype (N), Expr);\n             end if;\n@@ -1869,7 +1852,7 @@ package body Sem_Aggr is\n             --  Ada 2005 (AI-231)\n \n             if Ada_Version >= Ada_05\n-              and then Nkind (Assoc) = N_Null\n+              and then Known_Null (Assoc)\n             then\n                Check_Can_Never_Be_Null (Etype (N), Expression (Assoc));\n             end if;\n@@ -2401,7 +2384,7 @@ package body Sem_Aggr is\n                      --  Ada 2005 (AI-231)\n \n                      if Ada_Version >= Ada_05\n-                       and then Nkind (Expression (Assoc)) = N_Null\n+                       and then Known_Null (Expression (Assoc))\n                      then\n                         Check_Can_Never_Be_Null (Compon, Expression (Assoc));\n                      end if;\n@@ -2731,7 +2714,7 @@ package body Sem_Aggr is\n                --  Ada 2005 (AI-231)\n \n                if Ada_Version >= Ada_05\n-                 and then Nkind (Positional_Expr) = N_Null\n+                 and then Known_Null (Positional_Expr)\n                then\n                   Check_Can_Never_Be_Null (Discrim, Positional_Expr);\n                end if;\n@@ -2969,7 +2952,7 @@ package body Sem_Aggr is\n          --  Ada 2005 (AI-231)\n \n          if Ada_Version >= Ada_05\n-           and then Nkind (Positional_Expr) = N_Null\n+           and then Known_Null (Positional_Expr)\n          then\n             Check_Can_Never_Be_Null (Component, Positional_Expr);\n          end if;\n@@ -3052,7 +3035,7 @@ package body Sem_Aggr is\n                   then\n                      --  We build a partially initialized aggregate with the\n                      --  values of the discriminants and box initialization\n-                     --  for the rest.\n+                     --  for the rest, if other components are present.\n \n                      declare\n                         Loc        : constant Source_Ptr := Sloc (N);\n@@ -3085,13 +3068,29 @@ package body Sem_Aggr is\n                            Next_Elmt (Discr_Elmt);\n                         end loop;\n \n-                        Append\n-                          (Make_Component_Association (Loc,\n-                             Choices     =>\n-                               New_List (Make_Others_Choice (Loc)),\n-                             Expression  => Empty,\n-                             Box_Present => True),\n-                           Component_Associations (Expr));\n+                        declare\n+                           Comp : Entity_Id;\n+\n+                        begin\n+                           --  Look for a component that is not a discriminant\n+                           --  before creating an others box association.\n+\n+                           Comp := First_Component (Ctyp);\n+                           while Present (Comp) loop\n+                              if Ekind (Comp) = E_Component then\n+                                 Append\n+                                   (Make_Component_Association (Loc,\n+                                      Choices     =>\n+                                        New_List (Make_Others_Choice (Loc)),\n+                                      Expression  => Empty,\n+                                      Box_Present => True),\n+                                    Component_Associations (Expr));\n+                                 exit;\n+                              end if;\n+\n+                              Next_Component (Comp);\n+                           end loop;\n+                        end;\n \n                         Add_Association\n                           (Component      => Component,\n@@ -3271,7 +3270,7 @@ package body Sem_Aggr is\n       pragma Assert\n         (Ada_Version >= Ada_05\n           and then Present (Expr)\n-          and then Nkind (Expr) = N_Null);\n+          and then Known_Null (Expr));\n \n       case Ekind (Typ) is\n          when E_Array_Type  =>\n@@ -3295,7 +3294,7 @@ package body Sem_Aggr is\n          Insert_Action\n            (Compile_Time_Constraint_Error\n               (Expr,\n-               \"(Ada 2005) NULL not allowed in null-excluding components?\"),\n+               \"(Ada 2005) null not allowed in null-excluding component?\"),\n             Make_Raise_Constraint_Error (Sloc (Expr),\n               Reason => CE_Access_Check_Failed));\n "}]}