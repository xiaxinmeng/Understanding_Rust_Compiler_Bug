{"sha": "c7222c02245141fe7dbe018593717e1b63389d23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzcyMjJjMDIyNDUxNDFmZTdkYmUwMTg1OTM3MTdlMWI2MzM4OWQyMw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-10-07T17:48:36Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-10-07T17:48:36Z"}, "message": "cp-tree.h (ICS_USER_FLAG): Remove comment about obsolete flag.\n\n\t* cp-tree.h (ICS_USER_FLAG): Remove comment about obsolete flag.\n\t(DECL_MEMBER_TEMPLATE_P): New macro.\n\t(is_member_template): Remove.\n\t(class_method_index_for_fn): New function.\n\t* pt.c (build_over_call): Use DECL_MEMBER_TEMPLATE_P.\n\t* class.c (finish_struct_methods): Remove out-of-date comment.\n\t* decl.c (copy_fn_p): Use DECL_MBMER_TEMPLATE_P.\n\t* decl2.c (check_classfn): Use DECL_MEMBER_TEMPLATE_P and\n\tclass_method_index_for_fn.\n\t* pt.c (is_member_template): Remove.\n\t(is_member_template_class): Likewise.\n\t(optimize_specialization_lookup_p): New function.\n\t(retrieve_specialization): Optimize lookups for members that are\n\tnot member templates.\n\t(register_specialization): Adjust accordingly.\n\t(build_template_decl): Add member_template_p parameter.  Set\n\tDECL_MEMBER_TEMPLATE_P.\n\t(process_partial_specialization): Adjust call to\n\tretrieve_specialization.\n\t(push_template_decl_real): Determine whether the template is a\n\tmember template.\n\t(lookup_template_class): Use retrieve_specialization.\n\t(tsubst_decl): Adjust call to retrieve_specialization.\n\t(tsubst_exception_specification): New function.\n\t(tsubst): Use it.\n\t(tsubst_copy): Use DECL_MEMBER_TEMPLATE_P.\n\t(instantiate_template): Adjust call to retrieve_specialization.\n\t(regenerate_decl_from_template): Do not actually generate a new\n\tDECL.\n\t(instantiate_decl): Adjust call to retrieve_specialization.\n\t(class_method_index_for_fn): New method.\n\nFrom-SVN: r88697", "tree": {"sha": "8114b15819ae2f47168dcdfac92c99c8df72ce80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8114b15819ae2f47168dcdfac92c99c8df72ce80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7222c02245141fe7dbe018593717e1b63389d23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7222c02245141fe7dbe018593717e1b63389d23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7222c02245141fe7dbe018593717e1b63389d23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7222c02245141fe7dbe018593717e1b63389d23/comments", "author": null, "committer": null, "parents": [{"sha": "d0e75c71c9a2586b0de06873febcdddd0eb7f01b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0e75c71c9a2586b0de06873febcdddd0eb7f01b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0e75c71c9a2586b0de06873febcdddd0eb7f01b"}], "stats": {"total": 605, "additions": 345, "deletions": 260}, "files": [{"sha": "8b104c7634676919a5189f16805fc53388741291", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7222c02245141fe7dbe018593717e1b63389d23/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7222c02245141fe7dbe018593717e1b63389d23/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c7222c02245141fe7dbe018593717e1b63389d23", "patch": "@@ -1,3 +1,37 @@\n+2004-10-07  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (ICS_USER_FLAG): Remove comment about obsolete flag.\n+\t(DECL_MEMBER_TEMPLATE_P): New macro.\n+\t(is_member_template): Remove.\n+\t(class_method_index_for_fn): New function.\n+\t* pt.c (build_over_call): Use DECL_MEMBER_TEMPLATE_P.\n+\t* class.c (finish_struct_methods): Remove out-of-date comment.\n+\t* decl.c (copy_fn_p): Use DECL_MBMER_TEMPLATE_P.\n+\t* decl2.c (check_classfn): Use DECL_MEMBER_TEMPLATE_P and\n+\tclass_method_index_for_fn.\n+\t* pt.c (is_member_template): Remove.\n+\t(is_member_template_class): Likewise.\n+\t(optimize_specialization_lookup_p): New function.\n+\t(retrieve_specialization): Optimize lookups for members that are\n+\tnot member templates.\n+\t(register_specialization): Adjust accordingly.\n+\t(build_template_decl): Add member_template_p parameter.  Set\n+\tDECL_MEMBER_TEMPLATE_P.\n+\t(process_partial_specialization): Adjust call to\n+\tretrieve_specialization.\n+\t(push_template_decl_real): Determine whether the template is a\n+\tmember template.\n+\t(lookup_template_class): Use retrieve_specialization.\n+\t(tsubst_decl): Adjust call to retrieve_specialization.\n+\t(tsubst_exception_specification): New function.\n+\t(tsubst): Use it.\n+\t(tsubst_copy): Use DECL_MEMBER_TEMPLATE_P.\n+\t(instantiate_template): Adjust call to retrieve_specialization.\n+\t(regenerate_decl_from_template): Do not actually generate a new\n+\tDECL.\n+\t(instantiate_decl): Adjust call to retrieve_specialization.\n+\t(class_method_index_for_fn): New method.\n+\n 2004-10-07  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* parser.c (cp_parser_asm_definition): Look passed the"}, {"sha": "7d4e9634e4c0f6fedd5a14d3a4a909455d86253e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7222c02245141fe7dbe018593717e1b63389d23/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7222c02245141fe7dbe018593717e1b63389d23/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=c7222c02245141fe7dbe018593717e1b63389d23", "patch": "@@ -4614,7 +4614,7 @@ build_over_call (struct z_candidate *cand, int flags)\n \t primary template because `B<T>::g' and `B<int>::g' may have\n \t different access.  */\n       if (DECL_TEMPLATE_INFO (fn)\n-\t  && is_member_template (DECL_TI_TEMPLATE (fn)))\n+\t  && DECL_MEMBER_TEMPLATE_P (DECL_TI_TEMPLATE (fn)))\n \tperform_or_defer_access_check (cand->access_path,\n \t\t\t\t       DECL_TI_TEMPLATE (fn));\n       else"}, {"sha": "e955560ffcdf57a428676fa30e3f367078cbcc14", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7222c02245141fe7dbe018593717e1b63389d23/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7222c02245141fe7dbe018593717e1b63389d23/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c7222c02245141fe7dbe018593717e1b63389d23", "patch": "@@ -1657,17 +1657,7 @@ resort_type_method_vec (void* obj,\n     }\n }\n \n-/* Warn about duplicate methods in fn_fields.  Also compact method\n-   lists so that lookup can be made faster.\n-\n-   Data Structure: List of method lists.  The outer list is a\n-   TREE_LIST, whose TREE_PURPOSE field is the field name and the\n-   TREE_VALUE is the DECL_CHAIN of the FUNCTION_DECLs.  TREE_CHAIN\n-   links the entire list of methods for TYPE_METHODS.  Friends are\n-   chained in the same way as member functions (? TREE_CHAIN or\n-   DECL_CHAIN), but they live in the TREE_TYPE field of the outer\n-   list.  That allows them to be quickly deleted, and requires no\n-   extra storage.\n+/* Warn about duplicate methods in fn_fields.\n \n    Sort methods that are not special (i.e., constructors, destructors,\n    and type conversion operators) so that we can find them faster in\n@@ -1686,11 +1676,9 @@ finish_struct_methods (tree t)\n \n   len = VEC_length (tree, method_vec);\n \n-  /* First fill in entry 0 with the constructors, entry 1 with destructors,\n-     and the next few with type conversion operators (if any).  */\n+  /* Clear DECL_IN_AGGR_P for all functions.  */\n   for (fn_fields = TYPE_METHODS (t); fn_fields; \n        fn_fields = TREE_CHAIN (fn_fields))\n-    /* Clear out this flag.  */\n     DECL_IN_AGGR_P (fn_fields) = 0;\n \n   if (TYPE_HAS_DESTRUCTOR (t) && !CLASSTYPE_DESTRUCTORS (t))"}, {"sha": "58dae736170c9ccf4babaf9b0c8248b17ca459c2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7222c02245141fe7dbe018593717e1b63389d23/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7222c02245141fe7dbe018593717e1b63389d23/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c7222c02245141fe7dbe018593717e1b63389d23", "patch": "@@ -39,7 +39,6 @@ struct diagnostic_context;\n       DELETE_EXPR_USE_GLOBAL (in DELETE_EXPR).\n       COMPOUND_EXPR_OVERLOADED (in COMPOUND_EXPR).\n       TREE_INDIRECT_USING (in NAMESPACE_DECL).\n-      ICS_USER_FLAG (in _CONV)\n       CLEANUP_P (in TRY_BLOCK)\n       AGGR_INIT_VIA_CTOR_P (in AGGR_INIT_EXPR)\n       PTRMEM_OK_P (in ADDR_EXPR, OFFSET_REF)\n@@ -90,6 +89,7 @@ struct diagnostic_context;\n       DECL_MUTABLE_P (in FIELD_DECL)\n    1: C_TYPEDEF_EXPLICITLY_SIGNED (in TYPE_DECL).\n       DECL_TEMPLATE_INSTANTIATED (in a VAR_DECL or a FUNCTION_DECL)\n+      DECL_MEMBER_TEMPLATE_P (in TEMPLATE_DECL)\n    2: DECL_THIS_EXTERN (in VAR_DECL or FUNCTION_DECL).\n       DECL_IMPLICIT_TYPEDEF_P (in a TYPE_DECL)\n    3: DECL_IN_AGGR_P.\n@@ -2177,6 +2177,11 @@ struct lang_decl GTY(())\n \n #define INNERMOST_TEMPLATE_PARMS(NODE)  TREE_VALUE (NODE)\n \n+/* Nonzero if NODE (a TEMPLATE_DECL) is a member template, in the\n+   sense of [temp.mem].  */\n+#define DECL_MEMBER_TEMPLATE_P(NODE) \\\n+  (DECL_LANG_FLAG_1 (TEMPLATE_DECL_CHECK (NODE)))\n+\n /* Nonzero if the NODE corresponds to the template parameters for a\n    member template, whose inline definition is being processed after\n    the class definition is complete.  */\n@@ -3930,7 +3935,6 @@ extern tree instantiate_decl\t\t\t(tree, int, int);\n extern int push_tinst_level\t\t\t(tree);\n extern void pop_tinst_level\t\t\t(void);\n extern int more_specialized_class\t\t(tree, tree, tree);\n-extern int is_member_template                   (tree);\n extern int comp_template_parms                  (tree, tree);\n extern int template_class_depth                 (tree);\n extern int is_specialization_of                 (tree, tree);\n@@ -3990,6 +3994,7 @@ extern int accessible_p                         (tree, tree);\n extern tree lookup_field_1                      (tree, tree, bool);\n extern tree lookup_field\t\t\t(tree, tree, int, bool);\n extern int lookup_fnfields_1                    (tree, tree);\n+extern int class_method_index_for_fn            (tree, tree);\n extern tree lookup_fnfields\t\t\t(tree, tree, int);\n extern tree lookup_member\t\t\t(tree, tree, int, bool);\n extern int look_for_overrides\t\t\t(tree, tree);"}, {"sha": "919b619cc8355b8ff9d2afa9ffc51317fee481a3", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7222c02245141fe7dbe018593717e1b63389d23/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7222c02245141fe7dbe018593717e1b63389d23/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c7222c02245141fe7dbe018593717e1b63389d23", "patch": "@@ -8477,7 +8477,8 @@ copy_fn_p (tree d)\n \n   gcc_assert (DECL_FUNCTION_MEMBER_P (d));\n \n-  if (DECL_TEMPLATE_INFO (d) && is_member_template (DECL_TI_TEMPLATE (d)))\n+  if (DECL_TEMPLATE_INFO (d) \n+      && DECL_MEMBER_TEMPLATE_P (DECL_TI_TEMPLATE (d)))\n     /* Instantiations of template member functions are never copy\n        functions.  Note that member functions of templated classes are\n        represented as template functions internally, and we must"}, {"sha": "896fdfc1834560053fbc50eaa72f06de7e0025fc", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7222c02245141fe7dbe018593717e1b63389d23/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7222c02245141fe7dbe018593717e1b63389d23/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=c7222c02245141fe7dbe018593717e1b63389d23", "patch": "@@ -596,7 +596,7 @@ check_classfn (tree ctype, tree function, tree template_parms)\n   if (DECL_USE_TEMPLATE (function)\n       && !(TREE_CODE (function) == TEMPLATE_DECL\n \t   && DECL_TEMPLATE_SPECIALIZATION (function))\n-      && is_member_template (DECL_TI_TEMPLATE (function)))\n+      && DECL_MEMBER_TEMPLATE_P (DECL_TI_TEMPLATE (function)))\n     /* Since this is a specialization of a member template,\n        we're not going to find the declaration in the class.\n        For example, in:\n@@ -622,11 +622,7 @@ check_classfn (tree ctype, tree function, tree template_parms)\n   /* OK, is this a definition of a member template?  */\n   is_template = (template_parms != NULL_TREE);\n \n-  ix = lookup_fnfields_1 (complete_type (ctype),\n-\t\t\t  DECL_CONSTRUCTOR_P (function) ? ctor_identifier :\n-\t\t\t  DECL_DESTRUCTOR_P (function) ? dtor_identifier :\n-\t\t\t  DECL_NAME (function));\n-\n+  ix = class_method_index_for_fn (complete_type (ctype), function);\n   if (ix >= 0)\n     {\n       VEC(tree) *methods = CLASSTYPE_METHOD_VEC (ctype);"}, {"sha": "0d24d06869a38da65cddd1ac8637326ae7cdb182", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 281, "deletions": 236, "changes": 517, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7222c02245141fe7dbe018593717e1b63389d23/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7222c02245141fe7dbe018593717e1b63389d23/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c7222c02245141fe7dbe018593717e1b63389d23", "patch": "@@ -117,12 +117,9 @@ static int for_each_template_parm (tree, tree_fn_t, void*, htab_t);\n static tree build_template_parm_index (int, int, int, tree, tree);\n static int inline_needs_template_parms (tree);\n static void push_inline_template_parms_recursive (tree, int);\n-static tree retrieve_specialization (tree, tree);\n static tree retrieve_local_specialization (tree);\n-static tree register_specialization (tree, tree, tree);\n static void register_local_specialization (tree, tree);\n static tree reduce_template_parm_level (tree, tree, int);\n-static tree build_template_decl (tree, tree);\n static int mark_template_parm (tree, void *);\n static int template_parm_this_level_p (tree, void *);\n static tree tsubst_friend_function (tree, tree);\n@@ -441,67 +438,6 @@ maybe_end_member_template_processing (void)\n     }\n }\n \n-/* Returns nonzero iff T is a member template function.  We must be\n-   careful as in\n-\n-     template <class T> class C { void f(); }\n-\n-   Here, f is a template function, and a member, but not a member\n-   template.  This function does not concern itself with the origin of\n-   T, only its present state.  So if we have \n-\n-     template <class T> class C { template <class U> void f(U); }\n-\n-   then neither C<int>::f<char> nor C<T>::f<double> is considered\n-   to be a member template.  But, `template <class U> void\n-   C<int>::f(U)' is considered a member template.  */\n-\n-int\n-is_member_template (tree t)\n-{\n-  if (!DECL_FUNCTION_TEMPLATE_P (t))\n-    /* Anything that isn't a function or a template function is\n-       certainly not a member template.  */\n-    return 0;\n-\n-  /* A local class can't have member templates.  */\n-  if (decl_function_context (t))\n-    return 0;\n-\n-  return (DECL_FUNCTION_MEMBER_P (DECL_TEMPLATE_RESULT (t))\n-\t  /* If there are more levels of template parameters than\n-\t     there are template classes surrounding the declaration,\n-\t     then we have a member template.  */\n-\t  && (TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (t)) > \n-\t      template_class_depth (DECL_CONTEXT (t))));\n-}\n-\n-#if 0 /* UNUSED */\n-/* Returns nonzero iff T is a member template class.  See\n-   is_member_template for a description of what precisely constitutes\n-   a member template.  */\n-\n-int\n-is_member_template_class (tree t)\n-{\n-  if (!DECL_CLASS_TEMPLATE_P (t))\n-    /* Anything that isn't a class template, is certainly not a member\n-       template.  */\n-    return 0;\n-\n-  if (!DECL_CLASS_SCOPE_P (t))\n-    /* Anything whose context isn't a class type is surely not a\n-       member template.  */\n-    return 0;\n-\n-  /* If there are more levels of template parameters than there are\n-     template classes surrounding the declaration, then we have a\n-     member template.  */\n-  return  (TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (t)) > \n-\t   template_class_depth (DECL_CONTEXT (t)));\n-}\n-#endif\n-\n /* Return a new template argument vector which contains all of ARGS,\n    but has as its innermost set of arguments the EXTRA_ARGS.  */\n \n@@ -826,30 +762,122 @@ maybe_process_partial_specialization (tree type)\n     error (\"explicit specialization of non-template %qT\", type);\n }\n \n+/* Returns onzero if we can optimize the retrieval of specializations\n+   for TMPL, a TEMPLATE_DECL.  In particular, for such a template, we\n+   do not use DECL_TEMPLATE_SPECIALIZATIONS at all.  */\n+\n+static inline bool \n+optimize_specialization_lookup_p (tree tmpl)\n+{\n+  return (DECL_FUNCTION_TEMPLATE_P (tmpl)\n+\t  && DECL_CLASS_SCOPE_P (tmpl)\n+\t  /* DECL_CLASS_SCOPE_P holds of T::f even if T is a template\n+\t     parameter.  */\n+\t  && CLASS_TYPE_P (DECL_CONTEXT (tmpl))\n+\t  && !DECL_MEMBER_TEMPLATE_P (tmpl)\n+\t  && !DECL_CONV_FN_P (tmpl)\n+\t  /* It is possible to have a template that is not a member\n+\t     template and is not a member of a template class:\n+\t     \n+\t     template <typename T> \n+\t     struct S { friend A::f(); };\n+\t     \n+\t     Here, the friend function is a template, but the context does\n+\t     not have template information.  The optimized lookup relies\n+\t     on having ARGS be the template arguments for both the class\n+\t     and the function template.  */\n+\t  && !DECL_FRIEND_P (DECL_TEMPLATE_RESULT (tmpl)));\n+}\n+\n /* Retrieve the specialization (in the sense of [temp.spec] - a\n    specialization is either an instantiation or an explicit\n    specialization) of TMPL for the given template ARGS.  If there is\n    no such specialization, return NULL_TREE.  The ARGS are a vector of\n    arguments, or a vector of vectors of arguments, in the case of\n-   templates with more than one level of parameters.  */\n+   templates with more than one level of parameters.  \n+\n+   If TMPL is a type template and CLASS_SPECIALIZATIONS_P is true,\n+   then we search for a partial specialization matching ARGS.  This\n+   parameter is ignored if TMPL is not a class template.  */\n    \n static tree\n-retrieve_specialization (tree tmpl, tree args)\n+retrieve_specialization (tree tmpl, tree args, \n+\t\t\t bool class_specializations_p)\n {\n-  tree s;\n-\n   gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL);\n \n   /* There should be as many levels of arguments as there are\n      levels of parameters.  */\n   gcc_assert (TMPL_ARGS_DEPTH (args) \n \t      == TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (tmpl)));\n-\t\t      \n-  for (s = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n-       s != NULL_TREE;\n-       s = TREE_CHAIN (s))\n-    if (comp_template_args (TREE_PURPOSE (s), args))\n-      return TREE_VALUE (s);\n+\t\t\n+  if (optimize_specialization_lookup_p (tmpl))\n+    {\n+      tree class_template;\n+      tree class_specialization;\n+      VEC(tree) *methods;\n+      tree fns;\n+      int idx;\n+\n+      /* The template arguments actually apply to the containing\n+\t class.  Find the class specialization with those\n+\t arguments.  */\n+      class_template = CLASSTYPE_TI_TEMPLATE (DECL_CONTEXT (tmpl));\n+      class_specialization \n+\t= retrieve_specialization (class_template, args,\n+\t\t\t\t   /*class_specializations_p=*/false);\n+      if (!class_specialization)\n+\treturn NULL_TREE;\n+      /* Now, find the appropriate entry in the CLASSTYPE_METHOD_VEC\n+\t for the specialization.  */\n+      idx = class_method_index_for_fn (class_specialization, tmpl);\n+      if (idx == -1)\n+\treturn NULL_TREE;\n+      /* Iterate through the methods with the indicated name, looking\n+\t for the one that has an instance of TMPL.  */\n+      methods = CLASSTYPE_METHOD_VEC (class_specialization);\n+      for (fns = VEC_index (tree, methods, idx); fns; fns = OVL_NEXT (fns))\n+\t{\n+\t  tree fn = OVL_CURRENT (fns);\n+\t  if (DECL_TEMPLATE_INFO (fn) && DECL_TI_TEMPLATE (fn) == tmpl)\n+\t    return fn;\n+\t}\n+      return NULL_TREE;\n+    }\n+  else\n+    {\n+      tree *sp;\n+      tree *head;\n+\n+      /* Class templates store their instantiations on the\n+\t DECL_TEMPLATE_INSTANTIATIONS list; other templates use the\n+\t DECL_TEMPLATE_SPECIALIZATIONS list.  */\n+      if (!class_specializations_p\n+\t  && TREE_CODE (DECL_TEMPLATE_RESULT (tmpl)) == TYPE_DECL)\n+\tsp = &DECL_TEMPLATE_INSTANTIATIONS (tmpl);\n+      else\n+\tsp = &DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n+      head = sp;\n+      /* Iterate through the list until we find a matching template.  */\n+      while (*sp != NULL_TREE)\n+\t{\n+\t  tree spec = *sp;\n+\t      \n+\t  if (comp_template_args (TREE_PURPOSE (spec), args))\n+\t    {\n+\t      /* Use the move-to-front heuristic to speed up future\n+\t\t searches.  */ \n+\t      if (spec != *head)\n+\t\t{\n+\t\t  *sp = TREE_CHAIN (*sp);\n+\t\t  TREE_CHAIN (spec) = *head;\n+\t\t  *head = spec;\n+\t\t}\n+\t      return TREE_VALUE (spec);\n+\t    }\n+\t  sp = &TREE_CHAIN (spec);\n+\t}\n+    }\n \n   return NULL_TREE;\n }\n@@ -1035,7 +1063,7 @@ is_specialization_of_friend (tree decl, tree friend)\n static tree\n register_specialization (tree spec, tree tmpl, tree args)\n {\n-  tree s;\n+  tree fn;\n \n   gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL);\n \n@@ -1059,73 +1087,67 @@ register_specialization (tree spec, tree tmpl, tree args)\n   gcc_assert (TMPL_ARGS_DEPTH (args) \n \t      == TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (tmpl)));\n \n-  for (s = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n-       s != NULL_TREE;\n-       s = TREE_CHAIN (s))\n+  fn = retrieve_specialization (tmpl, args, \n+\t\t\t\t/*class_specializations_p=*/false);\n+  /* We can sometimes try to re-register a specialization that we've\n+     already got.  In particular, regenerate_decl_from_template calls\n+     duplicate_decls which will update the specialization list.  But,\n+     we'll still get called again here anyhow.  It's more convenient\n+     to simply allow this than to try to prevent it.  */\n+  if (fn == spec)\n+    return spec;\n+  else if (fn && DECL_TEMPLATE_SPECIALIZATION (spec))\n     {\n-      tree fn = TREE_VALUE (s);\n-\n-      /* We can sometimes try to re-register a specialization that we've\n-\t already got.  In particular, regenerate_decl_from_template\n-\t calls duplicate_decls which will update the specialization\n-\t list.  But, we'll still get called again here anyhow.  It's\n-\t more convenient to simply allow this than to try to prevent it.  */\n-      if (fn == spec)\n-\treturn spec;\n-      else if (DECL_TEMPLATE_SPECIALIZATION (spec)\n-\t       && comp_template_args (TREE_PURPOSE (s), args))\n+      if (DECL_TEMPLATE_INSTANTIATION (fn))\n \t{\n-\t  if (DECL_TEMPLATE_INSTANTIATION (fn))\n+\t  if (TREE_USED (fn) \n+\t      || DECL_EXPLICIT_INSTANTIATION (fn))\n \t    {\n-\t      if (TREE_USED (fn) \n-\t\t  || DECL_EXPLICIT_INSTANTIATION (fn))\n-\t\t{\n-\t\t  error (\"specialization of %qD after instantiation\", fn);\n-\t\t  return spec;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* This situation should occur only if the first\n-\t\t     specialization is an implicit instantiation, the\n-\t\t     second is an explicit specialization, and the\n-\t\t     implicit instantiation has not yet been used.\n-\t\t     That situation can occur if we have implicitly\n-\t\t     instantiated a member function and then\n-\t\t     specialized it later.\n-\n-\t\t     We can also wind up here if a friend declaration\n-\t\t     that looked like an instantiation turns out to be\n-\t\t     a specialization:\n-\n-\t\t       template <class T> void foo(T);\n-\t\t       class S { friend void foo<>(int) };\n-\t\t       template <> void foo(int);  \n-\n-\t\t     We transform the existing DECL in place so that\n-\t\t     any pointers to it become pointers to the updated\n-\t\t     declaration.\n-\n-\t\t     If there was a definition for the template, but\n-\t\t     not for the specialization, we want this to look\n-\t\t     as if there were no definition, and vice\n-\t\t     versa.  */\n-\t\t  DECL_INITIAL (fn) = NULL_TREE;\n-\t\t  duplicate_decls (spec, fn);\n-\t\t  \n-\t\t  return fn;\n-\t\t}\n+\t      error (\"specialization of %qD after instantiation\",\n+\t\t     fn);\n+\t      return spec;\n \t    }\n-\t  else if (DECL_TEMPLATE_SPECIALIZATION (fn))\n+\t  else\n \t    {\n-\t      if (!duplicate_decls (spec, fn) && DECL_INITIAL (spec))\n-\t\t/* Dup decl failed, but this is a new definition. Set\n-\t\t   the line number so any errors match this new\n-\t\t   definition.  */\n-\t\tDECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (spec);\n+\t      /* This situation should occur only if the first\n+\t\t specialization is an implicit instantiation, the\n+\t\t second is an explicit specialization, and the\n+\t\t implicit instantiation has not yet been used.  That\n+\t\t situation can occur if we have implicitly\n+\t\t instantiated a member function and then specialized\n+\t\t it later.\n+\t\t \n+\t\t We can also wind up here if a friend declaration that\n+\t\t looked like an instantiation turns out to be a\n+\t\t specialization:\n+\t\t \n+\t\t   template <class T> void foo(T);\n+\t\t   class S { friend void foo<>(int) };\n+\t\t   template <> void foo(int);  \n+\t\t \n+\t\t We transform the existing DECL in place so that any\n+\t\t pointers to it become pointers to the updated\n+\t\t declaration.\n+\n+\t\t If there was a definition for the template, but not\n+\t\t for the specialization, we want this to look as if\n+\t\t there were no definition, and vice versa.  */\n+\t      DECL_INITIAL (fn) = NULL_TREE;\n+\t      duplicate_decls (spec, fn);\n \t      \n \t      return fn;\n \t    }\n \t}\n+      else if (DECL_TEMPLATE_SPECIALIZATION (fn))\n+\t{\n+\t  if (!duplicate_decls (spec, fn) && DECL_INITIAL (spec))\n+\t    /* Dup decl failed, but this is a new definition. Set the\n+\t       line number so any errors match this new\n+\t       definition.  */\n+\t    DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (spec);\n+\t  \n+\t  return fn;\n+\t}\n     }\n \n   /* A specialization must be declared in the same namespace as the\n@@ -1134,8 +1156,9 @@ register_specialization (tree spec, tree tmpl, tree args)\n       && !check_specialization_namespace (tmpl))\n     DECL_CONTEXT (spec) = decl_namespace_context (tmpl);\n \n-  DECL_TEMPLATE_SPECIALIZATIONS (tmpl)\n-     = tree_cons (args, spec, DECL_TEMPLATE_SPECIALIZATIONS (tmpl));\n+  if (!optimize_specialization_lookup_p (tmpl))\n+    DECL_TEMPLATE_SPECIALIZATIONS (tmpl)\n+      = tree_cons (args, spec, DECL_TEMPLATE_SPECIALIZATIONS (tmpl));\n \n   return spec;\n }\n@@ -2393,14 +2416,16 @@ current_template_args (void)\n }\n \n /* Return a TEMPLATE_DECL corresponding to DECL, using the indicated\n-   template PARMS.  Used by push_template_decl below.  */\n+   template PARMS.  If MEMBER_TEMPLATE_P is true, the new template is\n+   a mebmer template.  Used by push_template_decl below.  */\n \n static tree\n-build_template_decl (tree decl, tree parms)\n+build_template_decl (tree decl, tree parms, bool member_template_p)\n {\n   tree tmpl = build_lang_decl (TEMPLATE_DECL, DECL_NAME (decl), NULL_TREE);\n   DECL_TEMPLATE_PARMS (tmpl) = parms;\n   DECL_CONTEXT (tmpl) = DECL_CONTEXT (decl);\n+  DECL_MEMBER_TEMPLATE_P (tmpl) = member_template_p;\n   if (DECL_LANG_SPECIFIC (decl))\n     {\n       DECL_STATIC_FUNCTION_P (tmpl) = DECL_STATIC_FUNCTION_P (decl);\n@@ -2636,7 +2661,8 @@ process_partial_specialization (tree decl)\n \t}\n     }\n \n-  if (retrieve_specialization (maintmpl, specargs))\n+  if (retrieve_specialization (maintmpl, specargs, \n+\t\t\t       /*class_specializations_p=*/true))\n     /* We've already got this specialization.  */\n     return decl;\n \n@@ -2826,6 +2852,9 @@ push_template_decl_real (tree decl, int is_friend)\n   int primary;\n   int is_partial;\n   int new_template_p = 0;\n+  /* True if the template is a member template, in the sense of\n+     [temp.mem].  */\n+  bool member_template_p = false;\n \n   if (decl == error_mark_node)\n     return decl;\n@@ -2862,6 +2891,8 @@ push_template_decl_real (tree decl, int is_friend)\n \n   if (primary)\n     {\n+      if (DECL_CLASS_SCOPE_P (decl))\n+\tmember_template_p = true;\n       if (current_lang_name == lang_name_c)\n \terror (\"template with C linkage\");\n       else if (TREE_CODE (decl) == TYPE_DECL \n@@ -2941,7 +2972,8 @@ push_template_decl_real (tree decl, int is_friend)\n \t}\n       else\n \t{\n-\t  tmpl = build_template_decl (decl, current_template_parms);\n+\t  tmpl = build_template_decl (decl, current_template_parms,\n+\t\t\t\t      member_template_p);\n \t  new_template_p = 1;\n \n \t  if (DECL_LANG_SPECIFIC (decl)\n@@ -2984,7 +3016,7 @@ push_template_decl_real (tree decl, int is_friend)\n       if (DECL_FUNCTION_TEMPLATE_P (tmpl)\n \t  && DECL_TEMPLATE_INFO (decl) && DECL_TI_ARGS (decl) \n \t  && DECL_TEMPLATE_SPECIALIZATION (decl)\n-\t  && is_member_template (tmpl))\n+\t  && DECL_MEMBER_TEMPLATE_P (tmpl))\n \t{\n \t  tree new_tmpl;\n \n@@ -2996,7 +3028,8 @@ push_template_decl_real (tree decl, int is_friend)\n \t  args = DECL_TI_ARGS (decl);\n \n \t  new_tmpl \n-\t    = build_template_decl (decl, current_template_parms);\n+\t    = build_template_decl (decl, current_template_parms,\n+\t\t\t\t   member_template_p);\n \t  DECL_TEMPLATE_RESULT (new_tmpl) = decl;\n \t  TREE_TYPE (new_tmpl) = TREE_TYPE (decl);\n \t  DECL_TI_TEMPLATE (decl) = new_tmpl;\n@@ -4342,7 +4375,6 @@ lookup_template_class (tree d1,\n       tree gen_tmpl;\n       tree type_decl;\n       tree found = NULL_TREE;\n-      tree *tp;\n       int arg_depth;\n       int parm_depth;\n       int is_partial_instantiation;\n@@ -4466,22 +4498,11 @@ lookup_template_class (tree d1,\n       if (found)\n         POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, found);\n \n-      for (tp = &DECL_TEMPLATE_INSTANTIATIONS (template);\n-\t   *tp;\n-\t   tp = &TREE_CHAIN (*tp))\n-\tif (comp_template_args (TREE_PURPOSE (*tp), arglist))\n-\t  {\n-\t    found = *tp;\n-\n-\t    /* Use the move-to-front heuristic to speed up future\n-\t       searches.  */\n-\t    *tp = TREE_CHAIN (*tp);\n-\t    TREE_CHAIN (found) \n-\t      = DECL_TEMPLATE_INSTANTIATIONS (template);\n-\t    DECL_TEMPLATE_INSTANTIATIONS (template) = found;\n-\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, TREE_VALUE (found));\n-\t  }\n+      /* If we already have this specialization, return it.  */\n+      found = retrieve_specialization (template, arglist,\n+\t\t\t\t       /*class_specializations_p=*/false);\n+      if (found)\n+\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, found);\n \n       /* This type is a \"partial instantiation\" if any of the template\n \t arguments still involve template parameters.  Note that we set\n@@ -6069,7 +6090,8 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \t       changed.  */\n \t    gcc_assert (full_args != tmpl_args);\n \n-\t    spec = retrieve_specialization (t, full_args);\n+\t    spec = retrieve_specialization (t, full_args,\n+\t\t\t\t\t    /*class_specializations_p=*/true);\n \t    if (spec != NULL_TREE)\n \t      {\n \t\tr = spec;\n@@ -6181,7 +6203,8 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \t\t\t\t\t   args, complain, in_decl); \n \n \t    /* Check to see if we already have this specialization.  */\n-\t    spec = retrieve_specialization (gen_tmpl, argvec);\n+\t    spec = retrieve_specialization (gen_tmpl, argvec,\n+\t\t\t\t\t    /*class_specializations_p=*/false);\n \n \t    if (spec)\n \t      {\n@@ -6467,7 +6490,8 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \t    tmpl = DECL_TI_TEMPLATE (t);\n \t    gen_tmpl = most_general_template (tmpl);\n \t    argvec = tsubst (DECL_TI_ARGS (t), args, complain, in_decl);\n-\t    spec = retrieve_specialization (gen_tmpl, argvec);\n+\t    spec = retrieve_specialization (gen_tmpl, argvec,\n+\t\t\t\t\t    /*class_specializations_p=*/false);\n \t  }\n \telse\n \t  spec = retrieve_local_specialization (t);\n@@ -6657,6 +6681,39 @@ tsubst_function_type (tree t,\n   return fntype;  \n }\n \n+/* FNTYPE is a FUNCTION_TYPE or METHOD_TYPE.  Substitute the template\n+   ARGS into that specification, and return the substituted\n+   specification.  If there is no specification, return NULL_TREE.  */\n+\n+static tree\n+tsubst_exception_specification (tree fntype, \n+\t\t\t\ttree args, \n+\t\t\t\ttsubst_flags_t complain,\n+\t\t\t\ttree in_decl)\n+{\n+  tree specs;\n+  tree new_specs;\n+\n+  specs = TYPE_RAISES_EXCEPTIONS (fntype);\n+  new_specs = NULL_TREE;\n+  if (specs)\n+    {\n+      if (! TREE_VALUE (specs))\n+\tnew_specs = specs;\n+      else\n+\twhile (specs)\n+\t  {\n+\t    tree spec;\n+\t    spec = tsubst (TREE_VALUE (specs), args, complain, in_decl);\n+\t    if (spec == error_mark_node)\n+\t      return spec;\n+\t    new_specs = add_exception_specifier (new_specs, spec, complain);\n+\t    specs = TREE_CHAIN (specs);\n+\t  }\n+    }\n+  return new_specs;\n+}\n+\n /* Substitute into the PARMS of a call-declarator.  */\n \n static tree\n@@ -7089,32 +7146,16 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case METHOD_TYPE:\n       {\n \ttree fntype;\n-\ttree raises;\n-\n+\ttree specs;\n \tfntype = tsubst_function_type (t, args, complain, in_decl);\n \tif (fntype == error_mark_node)\n \t  return error_mark_node;\n \n \t/* Substitute the exception specification.  */\n-\traises = TYPE_RAISES_EXCEPTIONS (t);\n-\tif (raises)\n-\t  {\n-\t    tree   list = NULL_TREE;\n-\t    \n-\t    if (! TREE_VALUE (raises))\n-\t      list = raises;\n-\t    else\n-\t      for (; raises != NULL_TREE; raises = TREE_CHAIN (raises))\n-\t        {\n-\t          tree spec = TREE_VALUE (raises);\n-\t          \n-\t          spec = tsubst (spec, args, complain, in_decl);\n-\t          if (spec == error_mark_node)\n-\t            return spec;\n-\t          list = add_exception_specifier (list, spec, complain);\n-\t        }\n-\t    fntype = build_exception_variant (fntype, list);\n-\t  }\n+\tspecs = tsubst_exception_specification (t, args, complain, \n+\t\t\t\t\t\tin_decl);\n+\tif (specs)\n+\t  fntype = build_exception_variant (fntype, specs);\n \treturn fntype;\n       }\n     case ARRAY_TYPE:\n@@ -7537,7 +7578,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       if (DECL_TEMPLATE_TEMPLATE_PARM_P (t))\n \treturn tsubst (TREE_TYPE (DECL_TEMPLATE_RESULT (t)), \n \t\t       args, complain, in_decl);\n-      else if (is_member_template (t))\n+      else if (DECL_FUNCTION_TEMPLATE_P (t) && DECL_MEMBER_TEMPLATE_P (t))\n \treturn tsubst (t, args, complain, in_decl);\n       else if (DECL_CLASS_SCOPE_P (t)\n \t       && uses_template_parms (DECL_CONTEXT (t)))\n@@ -8736,7 +8777,8 @@ instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n     }\n   \n   /* Check to see if we already have this specialization.  */\n-  spec = retrieve_specialization (tmpl, targ_ptr);\n+  spec = retrieve_specialization (tmpl, targ_ptr, \n+\t\t\t\t  /*class_specializations_p=*/false);\n   if (spec != NULL_TREE)\n     return spec;\n \n@@ -8750,7 +8792,8 @@ instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n \t\t\t\t\t      targ_ptr);\n \n       /* Check to see if we already have this specialization.  */\n-      spec = retrieve_specialization (gen_tmpl, targ_ptr);\n+      spec = retrieve_specialization (gen_tmpl, targ_ptr,\n+\t\t\t\t      /*class_specializations_p=*/false);\n       if (spec != NULL_TREE)\n \treturn spec;\n     }\n@@ -10808,75 +10851,76 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n static void\n regenerate_decl_from_template (tree decl, tree tmpl)\n {\n-  /* The most general version of TMPL.  */\n-  tree gen_tmpl;\n   /* The arguments used to instantiate DECL, from the most general\n      template.  */\n   tree args;\n   tree code_pattern;\n-  tree new_decl;\n-  bool unregistered;\n \n   args = DECL_TI_ARGS (decl);\n   code_pattern = DECL_TEMPLATE_RESULT (tmpl);\n \n-  /* Unregister the specialization so that when we tsubst we will not\n-     just return DECL.  We don't have to unregister DECL from TMPL\n-     because if would only be registered there if it were a partial\n-     instantiation of a specialization, which it isn't: it's a full\n-     instantiation.  */\n-  gen_tmpl = most_general_template (tmpl);\n-  unregistered = reregister_specialization (decl, gen_tmpl,\n-\t\t\t\t\t    /*new_spec=*/NULL_TREE);\n-\n-  /* If the DECL was not unregistered then something peculiar is\n-     happening: we created a specialization but did not call\n-     register_specialization for it.  */\n-  gcc_assert (unregistered);\n-\n   /* Make sure that we can see identifiers, and compute access\n      correctly.  */\n   push_access_scope (decl);\n \n-  /* Do the substitution to get the new declaration.  */\n-  new_decl = tsubst (code_pattern, args, tf_error, NULL_TREE);\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      tree decl_parm;\n+      tree pattern_parm;\n+      tree specs;\n+      int args_depth;\n+      int parms_depth;\n+      \n+      args_depth = TMPL_ARGS_DEPTH (args);\n+      parms_depth = TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (tmpl)); \n+      if (args_depth > parms_depth)\n+\targs = get_innermost_template_args (args, parms_depth);\n+\n+      specs = tsubst_exception_specification (TREE_TYPE (code_pattern),\n+\t\t\t\t\t      args, tf_error, NULL_TREE);\n+      if (specs)\n+\tTREE_TYPE (decl) = build_exception_variant (TREE_TYPE (decl),\n+\t\t\t\t\t\t    specs);\n+\n+      /* Merge parameter declarations.  */\n+      decl_parm = skip_artificial_parms_for (decl, \n+\t\t\t\t\t     DECL_ARGUMENTS (decl));\n+      pattern_parm \n+\t= skip_artificial_parms_for (code_pattern,\n+\t\t\t\t     DECL_ARGUMENTS (code_pattern));\n+      while (decl_parm)\n+\t{\n+\t  tree parm_type;\n+\n+\t  if (DECL_NAME (decl_parm) != DECL_NAME (pattern_parm))\n+\t    DECL_NAME (decl_parm) = DECL_NAME (pattern_parm);\n+\t  parm_type = tsubst (TREE_TYPE (pattern_parm), args, tf_error,\n+\t\t\t      NULL_TREE);\n+\t  if (!same_type_p (TREE_TYPE (decl_parm), parm_type))\n+\t    TREE_TYPE (decl_parm) = parm_type;\n+\t  decl_parm = TREE_CHAIN (decl_parm);\n+\t  pattern_parm = TREE_CHAIN (pattern_parm);\n+\t}\n \n-  if (TREE_CODE (decl) == VAR_DECL)\n+      /* Merge additional specifiers from the CODE_PATTERN.  */\n+      if (DECL_DECLARED_INLINE_P (code_pattern)\n+\t  && !DECL_DECLARED_INLINE_P (decl))\n+\tDECL_DECLARED_INLINE_P (decl) = 1;\n+      if (DECL_INLINE (code_pattern) && !DECL_INLINE (decl))\n+\tDECL_INLINE (decl) = 1;\n+    }\n+  else if (TREE_CODE (decl) == VAR_DECL)\n     {\n-      /* Set up DECL_INITIAL, since tsubst doesn't.  */\n-      if (!DECL_INITIALIZED_IN_CLASS_P (decl))\n-\tDECL_INITIAL (new_decl) = \n+      if (!DECL_INITIALIZED_IN_CLASS_P (decl)\n+\t  && DECL_INITIAL (code_pattern))\n+\tDECL_INITIAL (decl) = \n \t  tsubst_expr (DECL_INITIAL (code_pattern), args, \n \t\t       tf_error, DECL_TI_TEMPLATE (decl));\n     }\n-  else if (TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      /* Convince duplicate_decls to use the DECL_ARGUMENTS from the\n-\t new decl.  */ \n-      DECL_INITIAL (new_decl) = error_mark_node;\n-      /* And don't complain about a duplicate definition.  */\n-      DECL_INITIAL (decl) = NULL_TREE;\n-    }\n+  else\n+    gcc_unreachable ();\n \n   pop_access_scope (decl);\n-\n-  /* The immediate parent of the new template is still whatever it was\n-     before, even though tsubst sets DECL_TI_TEMPLATE up as the most\n-     general template.  We also reset the DECL_ASSEMBLER_NAME since\n-     tsubst always calculates the name as if the function in question\n-     were really a template instance, and sometimes, with friend\n-     functions, this is not so.  See tsubst_friend_function for\n-     details.  */\n-  DECL_TI_TEMPLATE (new_decl) = DECL_TI_TEMPLATE (decl);\n-  COPY_DECL_ASSEMBLER_NAME (decl, new_decl);\n-  COPY_DECL_RTL (decl, new_decl);\n-  DECL_USE_TEMPLATE (new_decl) = DECL_USE_TEMPLATE (decl);\n-\n-  /* Call duplicate decls to merge the old and new declarations.  */\n-  duplicate_decls (new_decl, decl);\n-\n-  /* Now, re-register the specialization.  */\n-  register_specialization (decl, gen_tmpl, args);\n }\n \n /* Return the TEMPLATE_DECL into which DECL_TI_ARGS(DECL) should be\n@@ -10994,7 +11038,8 @@ instantiate_decl (tree d, int defer_ok, int undefined_ok)\n      DECL_TEMPLATE_SPECIALIZATION.  */\n   gen_tmpl = most_general_template (tmpl);\n   gen_args = DECL_TI_ARGS (d);\n-  spec = retrieve_specialization (gen_tmpl, gen_args);\n+  spec = retrieve_specialization (gen_tmpl, gen_args,\n+\t\t\t\t  /*class_specializations_p=*/false);\n   if (spec != NULL_TREE && DECL_TEMPLATE_SPECIALIZATION (spec))\n     return spec;\n "}, {"sha": "514f868692d19718bc77b47ae6c42658aae01443", "filename": "gcc/cp/search.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7222c02245141fe7dbe018593717e1b63389d23/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7222c02245141fe7dbe018593717e1b63389d23/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=c7222c02245141fe7dbe018593717e1b63389d23", "patch": "@@ -1464,6 +1464,22 @@ lookup_fnfields_1 (tree type, tree name)\n   return -1;\n }\n \n+/* Like lookup_fnfields_1, except that the name is extracted from\n+   FUNCTION, which is a FUNCTION_DECL or a TEMPLATE_DECL.  */\n+\n+int\n+class_method_index_for_fn (tree class_type, tree function)\n+{\n+  gcc_assert (TREE_CODE (function) == FUNCTION_DECL\n+\t      || DECL_FUNCTION_TEMPLATE_P (function));\n+\n+  return lookup_fnfields_1 (class_type,\n+\t\t\t    DECL_CONSTRUCTOR_P (function) ? ctor_identifier :\n+\t\t\t    DECL_DESTRUCTOR_P (function) ? dtor_identifier :\n+\t\t\t    DECL_NAME (function));\n+}\n+\n+\n /* DECL is the result of a qualified name lookup.  QUALIFYING_SCOPE is\n    the class or namespace used to qualify the name.  CONTEXT_CLASS is\n    the class corresponding to the object in which DECL will be used."}]}