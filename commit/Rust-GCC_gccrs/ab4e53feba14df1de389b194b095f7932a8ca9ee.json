{"sha": "ab4e53feba14df1de389b194b095f7932a8ca9ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI0ZTUzZmViYTE0ZGYxZGUzODliMTk0YjA5NWY3OTMyYThjYTllZQ==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2014-07-17T02:03:52Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2014-07-17T02:03:52Z"}, "message": "re PR target/61737 (ICE when building libgcc for cris cross-compiler)\n\n\tPR target/61737.\n\t* config/cris/cris.c (TARGET_LEGITIMATE_CONSTANT_P)\n\t(TARGET_CANNOT_FORCE_CONST_MEM): Define.\n\t(cris_cannot_force_const_mem, cris_legitimate_constant_p): New\n\tfunctions.\n\t(cris_print_index, cris_print_operand, cris_constant_index_p)\n\t(cris_side_effect_mode_ok): Replace CONSTANT_P with CRIS_CONSTANT_P.\n\t(cris_address_cost): Ditto last CONSTANT_P.\n\t(cris_symbol_type_of): Rename from cris_pic_symbol_type_of.  All\n        callers changed.  Yield cris_offsettable_symbol for non-PIC\n        constant symbolic expressions including labels.  Yield cris_unspec\n\tfor all unspecs.\n\t(cris_expand_pic_call_address): New parameter MARKERP.  Set its\n        target to pic_offset_table_rtx for calls that will likely go\n        through PLT, const0_rtx when they can't.  All callers changed.\n\tAssert flag_pic.  Use CONSTANT_P, not CONSTANT_ADDRESS_P, for\n\tsymbolic expressions to be PICified.  Remove second, redundant,\n\tassert on can_create_pseudo_p returning non-zero.  Use\n\treplace_equiv_address_nv, not replace_equiv_address, for final\n\toperand update.\n\t* config/cris/cris.md (\"movsi\"): Move variable t to pattern\n\ttoplevel. Adjust assert for new cris_symbol_type member.  Use\n\tCONSTANT_P instead of CONSTANT_ADDRESS_P.\n\t(\"*movsi_internal\") <case 9>: Make check for valid unspec operands\n\tfor lapc stricter.\n\t<case CRIS_UNSPEC_PCREL, CRIS_UNSPEC_PLT_PCREL>: Clear condition\n\tcodes.\n\t(\"call\", \"call_value\"): Use second incoming operand as a marker\n\tfor pic-offset-table-register being used.\n\t(\"*expanded_call_non_v32\", \"*expanded_call_v32\")\n        (\"*expanded_call_value_non_v32\", \"*expanded_call_value_v32\"): For\n\tsecond incoming operand to CALL, match cris_call_type_marker.\n\t(\"*expanded_call_value_side\"): Ditto.  Disable before\n\treload_completed.\n\t(\"*expanded_call_side\"): Ditto.  Fix typo in comment.\n\t(moverside, movemside peepholes): Check for CRIS_CONSTANT_P, not\n\tCONSTANT_P.\n\t* config/cris/predicates.md (\"cris_call_type_marker\"): New predicate.\n\t* config/cris/cris.h (CRIS_CONSTANT_P): New macro.\n\t(enum cris_symbol_type): Rename from cris_pic_symbol_type.  All\n        users changed.  Add members cris_offsettable_symbol and\n\tcris_unspec.\n\t(cris_symbol_type): Rename from cris_pic_symbol_type.\n\t* config/cris/constraints.md (\"T\"): Use CRIS_CONSTANT_P, not\n        just CONSTANT_P.\n\t* config/cris/cris-protos.h (cris_symbol_type_of,\n\tcris_expand_pic_call_address): Adjust prototypes.\n\t(cris_legitimate_constant_p): New prototype.\n\nFrom-SVN: r212708", "tree": {"sha": "0c35ab6538fcb96aedfb1eebc55dd4b86b30162c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c35ab6538fcb96aedfb1eebc55dd4b86b30162c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab4e53feba14df1de389b194b095f7932a8ca9ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab4e53feba14df1de389b194b095f7932a8ca9ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab4e53feba14df1de389b194b095f7932a8ca9ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab4e53feba14df1de389b194b095f7932a8ca9ee/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3a213afbb56ec69625a816642391f0b7294b797a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a213afbb56ec69625a816642391f0b7294b797a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a213afbb56ec69625a816642391f0b7294b797a"}], "stats": {"total": 263, "additions": 208, "deletions": 55}, "files": [{"sha": "563d3d55c40fe515c06de35b3bdcb8072f2454ba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab4e53feba14df1de389b194b095f7932a8ca9ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab4e53feba14df1de389b194b095f7932a8ca9ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab4e53feba14df1de389b194b095f7932a8ca9ee", "patch": "@@ -1,5 +1,54 @@\n 2014-07-16  Hans-Peter Nilsson  <hp@axis.com>\n \n+\tPR target/61737.\n+\t* config/cris/cris.c (TARGET_LEGITIMATE_CONSTANT_P)\n+\t(TARGET_CANNOT_FORCE_CONST_MEM): Define.\n+\t(cris_cannot_force_const_mem, cris_legitimate_constant_p): New\n+\tfunctions.\n+\t(cris_print_index, cris_print_operand, cris_constant_index_p)\n+\t(cris_side_effect_mode_ok): Replace CONSTANT_P with CRIS_CONSTANT_P.\n+\t(cris_address_cost): Ditto last CONSTANT_P.\n+\t(cris_symbol_type_of): Rename from cris_pic_symbol_type_of.  All\n+        callers changed.  Yield cris_offsettable_symbol for non-PIC\n+        constant symbolic expressions including labels.  Yield cris_unspec\n+\tfor all unspecs.\n+\t(cris_expand_pic_call_address): New parameter MARKERP.  Set its\n+        target to pic_offset_table_rtx for calls that will likely go\n+        through PLT, const0_rtx when they can't.  All callers changed.\n+\tAssert flag_pic.  Use CONSTANT_P, not CONSTANT_ADDRESS_P, for\n+\tsymbolic expressions to be PICified.  Remove second, redundant,\n+\tassert on can_create_pseudo_p returning non-zero.  Use\n+\treplace_equiv_address_nv, not replace_equiv_address, for final\n+\toperand update.\n+\t* config/cris/cris.md (\"movsi\"): Move variable t to pattern\n+\ttoplevel. Adjust assert for new cris_symbol_type member.  Use\n+\tCONSTANT_P instead of CONSTANT_ADDRESS_P.\n+\t(\"*movsi_internal\") <case 9>: Make check for valid unspec operands\n+\tfor lapc stricter.\n+\t<case CRIS_UNSPEC_PCREL, CRIS_UNSPEC_PLT_PCREL>: Clear condition\n+\tcodes.\n+\t(\"call\", \"call_value\"): Use second incoming operand as a marker\n+\tfor pic-offset-table-register being used.\n+\t(\"*expanded_call_non_v32\", \"*expanded_call_v32\")\n+        (\"*expanded_call_value_non_v32\", \"*expanded_call_value_v32\"): For\n+\tsecond incoming operand to CALL, match cris_call_type_marker.\n+\t(\"*expanded_call_value_side\"): Ditto.  Disable before\n+\treload_completed.\n+\t(\"*expanded_call_side\"): Ditto.  Fix typo in comment.\n+\t(moverside, movemside peepholes): Check for CRIS_CONSTANT_P, not\n+\tCONSTANT_P.\n+\t* config/cris/predicates.md (\"cris_call_type_marker\"): New predicate.\n+\t* config/cris/cris.h (CRIS_CONSTANT_P): New macro.\n+\t(enum cris_symbol_type): Rename from cris_pic_symbol_type.  All\n+        users changed.  Add members cris_offsettable_symbol and\n+\tcris_unspec.\n+\t(cris_symbol_type): Rename from cris_pic_symbol_type.\n+\t* config/cris/constraints.md (\"T\"): Use CRIS_CONSTANT_P, not\n+        just CONSTANT_P.\n+\t* config/cris/cris-protos.h (cris_symbol_type_of,\n+\tcris_expand_pic_call_address): Adjust prototypes.\n+\t(cris_legitimate_constant_p): New prototype.\n+\n \t* config.gcc (crisv32-*-linux* | cris-*-linux*): Do not override\n \tan existing tmake_file.  Don't add t-slibgcc and t-linux.\n "}, {"sha": "f927ccaaa0feb676104b6f96ce5159973ac8dd69", "filename": "gcc/config/cris/constraints.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab4e53feba14df1de389b194b095f7932a8ca9ee/gcc%2Fconfig%2Fcris%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab4e53feba14df1de389b194b095f7932a8ca9ee/gcc%2Fconfig%2Fcris%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fconstraints.md?ref=ab4e53feba14df1de389b194b095f7932a8ca9ee", "patch": "@@ -118,7 +118,7 @@\n \t\t\t\t\t\t       reload_in_progress\n \t\t\t\t\t\t       || reload_completed)\"))\n \t    ;; Just an explicit indirect reference: [const]?\n-\t    (match_test \"CONSTANT_P (XEXP (op, 0))\")\n+\t    (match_test \"CRIS_CONSTANT_P (XEXP (op, 0))\")\n \t    ;; Something that is indexed; [...+...]?\n \t    (and (match_code \"plus\" \"0\")\n \t\t      ;; A BDAP constant: [reg+(8|16|32)bit offset]?\n@@ -159,6 +159,8 @@\n (define_constraint \"U\"\n   \"@internal\"\n   (and (match_test \"flag_pic\")\n+       ;; We're just interested in the ..._or_callable_symbol part.\n+       ;; (Using CRIS_CONSTANT_P would exclude that too.)\n        (match_test \"CONSTANT_P (op)\")\n        (match_operand 0 \"cris_nonmemory_operand_or_callable_symbol\")))\n "}, {"sha": "b09babd6991bc332d49615a92ee368029de8e491", "filename": "gcc/config/cris/cris-protos.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab4e53feba14df1de389b194b095f7932a8ca9ee/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab4e53feba14df1de389b194b095f7932a8ca9ee/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris-protos.h?ref=ab4e53feba14df1de389b194b095f7932a8ca9ee", "patch": "@@ -31,8 +31,9 @@ extern bool cris_cc0_user_requires_cmp (rtx);\n extern rtx cris_return_addr_rtx (int, rtx);\n extern rtx cris_split_movdx (rtx *);\n extern int cris_legitimate_pic_operand (rtx);\n-extern enum cris_pic_symbol_type cris_pic_symbol_type_of (const_rtx);\n+extern enum cris_symbol_type cris_symbol_type_of (const_rtx);\n extern bool cris_valid_pic_const (const_rtx, bool);\n+extern bool cris_legitimate_constant_p (enum machine_mode, rtx);\n extern bool cris_constant_index_p (const_rtx);\n extern bool cris_base_p (const_rtx, bool);\n extern bool cris_base_or_autoincr_p (const_rtx, bool);\n@@ -46,7 +47,7 @@ extern int cris_cfun_uses_pic_table (void);\n extern void cris_asm_output_case_end (FILE *, int, rtx);\n extern rtx cris_gen_movem_load (rtx, rtx, int);\n extern rtx cris_emit_movem_store (rtx, rtx, int, bool);\n-extern void cris_expand_pic_call_address (rtx *);\n+extern void cris_expand_pic_call_address (rtx *, rtx *);\n extern void cris_order_for_addsi3 (rtx *, int);\n extern void cris_emit_trap_for_misalignment (rtx);\n #endif /* RTX_CODE */"}, {"sha": "4a2e387a3dd454ba7790f74b11a56e703380f0e2", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 91, "deletions": 29, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab4e53feba14df1de389b194b095f7932a8ca9ee/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab4e53feba14df1de389b194b095f7932a8ca9ee/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=ab4e53feba14df1de389b194b095f7932a8ca9ee", "patch": "@@ -148,6 +148,7 @@ static rtx cris_function_incoming_arg (cumulative_args_t,\n static void cris_function_arg_advance (cumulative_args_t, enum machine_mode,\n \t\t\t\t       const_tree, bool);\n static tree cris_md_asm_clobbers (tree, tree, tree);\n+static bool cris_cannot_force_const_mem (enum machine_mode, rtx);\n \n static void cris_option_override (void);\n \n@@ -215,6 +216,9 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n #undef TARGET_LEGITIMATE_ADDRESS_P\n #define TARGET_LEGITIMATE_ADDRESS_P cris_legitimate_address_p\n \n+#undef TARGET_LEGITIMATE_CONSTANT_P\n+#define TARGET_LEGITIMATE_CONSTANT_P cris_legitimate_constant_p\n+\n #undef TARGET_PREFERRED_RELOAD_CLASS\n #define TARGET_PREFERRED_RELOAD_CLASS cris_preferred_reload_class\n \n@@ -249,6 +253,10 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n #define TARGET_FUNCTION_ARG_ADVANCE cris_function_arg_advance\n #undef TARGET_MD_ASM_CLOBBERS\n #define TARGET_MD_ASM_CLOBBERS cris_md_asm_clobbers\n+\n+#undef TARGET_CANNOT_FORCE_CONST_MEM\n+#define TARGET_CANNOT_FORCE_CONST_MEM cris_cannot_force_const_mem\n+\n #undef TARGET_FRAME_POINTER_REQUIRED\n #define TARGET_FRAME_POINTER_REQUIRED cris_frame_pointer_required\n \n@@ -507,6 +515,21 @@ cris_cfun_uses_pic_table (void)\n   return crtl->uses_pic_offset_table;\n }\n \n+/* Worker function for TARGET_CANNOT_FORCE_CONST_MEM.\n+   We can't put PIC addresses in the constant pool, not even the ones that\n+   can be reached as pc-relative as we can't tell when or how to do that.  */\n+\n+static bool\n+cris_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+{\n+  enum cris_symbol_type t = cris_symbol_type_of (x);\n+\n+  return\n+    t == cris_unspec\n+    || t == cris_got_symbol\n+    || t == cris_rel_symbol;\n+}\n+\n /* Given an rtx, return the text string corresponding to the CODE of X.\n    Intended for use in the assembly language output section of a\n    define_insn.  */\n@@ -602,7 +625,7 @@ cris_print_index (rtx index, FILE *file)\n \n   if (REG_P (index))\n     fprintf (file, \"$%s.b\", reg_names[REGNO (index)]);\n-  else if (CONSTANT_P (index))\n+  else if (CRIS_CONSTANT_P (index))\n     cris_output_addr_const (file, index);\n   else if (GET_CODE (index) == MULT)\n     {\n@@ -1042,7 +1065,7 @@ cris_print_operand (FILE *file, rtx x, int code)\n       /* If this is a GOT symbol, force it to be emitted as :GOT and\n \t :GOTPLT regardless of -fpic (i.e. not as :GOT16, :GOTPLT16).\n \t Avoid making this too much of a special case.  */\n-      if (flag_pic == 1 && CONSTANT_P (operand))\n+      if (flag_pic == 1 && CRIS_CONSTANT_P (operand))\n \t{\n \t  int flag_pic_save = flag_pic;\n \n@@ -1162,7 +1185,7 @@ cris_print_operand (FILE *file, rtx x, int code)\n     default:\n       /* No need to handle all strange variants, let output_addr_const\n \t do it for us.  */\n-      if (CONSTANT_P (operand))\n+      if (CRIS_CONSTANT_P (operand))\n \t{\n \t  cris_output_addr_const (file, operand);\n \t  return;\n@@ -1359,7 +1382,7 @@ reg_ok_for_index_p (const_rtx x, bool strict)\n bool\n cris_constant_index_p (const_rtx x)\n {\n-  return (CONSTANT_P (x) && (!flag_pic || cris_valid_pic_const (x, true)));\n+  return (CRIS_CONSTANT_P (x) && (!flag_pic || cris_valid_pic_const (x, true)));\n }\n \n /* True if X is a valid base register.  */\n@@ -1468,6 +1491,29 @@ cris_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n   return false;\n }\n \n+/* Worker function for TARGET_LEGITIMATE_CONSTANT_P.  We have to handle\n+   PIC constants that aren't legitimized.  FIXME: there used to be a\n+   guarantee that the target LEGITIMATE_CONSTANT_P didn't have to handle\n+   PIC constants, but no more (4.7 era); testcase: glibc init-first.c.\n+   While that may be seen as a bug, that guarantee seems a wart by design,\n+   so don't bother; fix the documentation instead.  */\n+\n+bool\n+cris_legitimate_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+{\n+  enum cris_symbol_type t;\n+\n+  if (flag_pic)\n+    return LEGITIMATE_PIC_OPERAND_P (x);\n+\n+  t = cris_symbol_type_of (x);\n+\n+  return\n+    t == cris_no_symbol\n+    || t == cris_offsettable_symbol\n+    || t == cris_unspec;\n+}\n+\n /* Worker function for LEGITIMIZE_RELOAD_ADDRESS.  */\n \n bool\n@@ -2215,7 +2261,7 @@ cris_address_cost (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED,\n \treturn (2 + 2) / 2;\n \n       /* A BDAP with some other constant is 2 bytes extra.  */\n-      if (CONSTANT_P (tem2))\n+      if (CRIS_CONSTANT_P (tem2))\n \treturn (2 + 2 + 2) / 2;\n \n       /* BDAP with something indirect should have a higher cost than\n@@ -2313,7 +2359,7 @@ cris_side_effect_mode_ok (enum rtx_code code, rtx *ops,\n \treturn 0;\n \n       /* Check allowed cases, like [r(+)?].[bwd] and const.  */\n-      if (CONSTANT_P (val_rtx))\n+      if (CRIS_CONSTANT_P (val_rtx))\n \treturn 1;\n \n       if (MEM_P (val_rtx)\n@@ -2465,32 +2511,34 @@ cris_valid_pic_const (const_rtx x, bool any_operand)\n \tgcc_unreachable ();\n       }\n \n-  return cris_pic_symbol_type_of (x) == cris_no_symbol;\n+  return cris_symbol_type_of (x) == cris_no_symbol;\n }\n \n-/* Helper function to find the right PIC-type symbol to generate,\n+/* Helper function to find the right symbol-type to generate,\n    given the original (non-PIC) representation.  */\n \n-enum cris_pic_symbol_type\n-cris_pic_symbol_type_of (const_rtx x)\n+enum cris_symbol_type\n+cris_symbol_type_of (const_rtx x)\n {\n   switch (GET_CODE (x))\n     {\n     case SYMBOL_REF:\n-      return SYMBOL_REF_LOCAL_P (x)\n-\t? cris_rel_symbol : cris_got_symbol;\n+      return flag_pic\n+\t? (SYMBOL_REF_LOCAL_P (x)\n+\t   ? cris_rel_symbol : cris_got_symbol)\n+\t: cris_offsettable_symbol;\n \n     case LABEL_REF:\n-      return cris_rel_symbol;\n+      return flag_pic ? cris_rel_symbol : cris_offsettable_symbol;\n \n     case CONST:\n-      return cris_pic_symbol_type_of (XEXP (x, 0));\n+      return cris_symbol_type_of (XEXP (x, 0));\n \n     case PLUS:\n     case MINUS:\n       {\n-\tenum cris_pic_symbol_type t1 = cris_pic_symbol_type_of (XEXP (x, 0));\n-\tenum cris_pic_symbol_type t2 = cris_pic_symbol_type_of (XEXP (x, 1));\n+\tenum cris_symbol_type t1 = cris_symbol_type_of (XEXP (x, 0));\n+\tenum cris_symbol_type t2 = cris_symbol_type_of (XEXP (x, 1));\n \n \tgcc_assert (t1 == cris_no_symbol || t2 == cris_no_symbol);\n \n@@ -2505,9 +2553,7 @@ cris_pic_symbol_type_of (const_rtx x)\n       return cris_no_symbol;\n \n     case UNSPEC:\n-      /* Likely an offsettability-test attempting to add a constant to\n-\t a GOTREAD symbol, which can't be handled.  */\n-      return cris_invalid_pic_symbol;\n+      return cris_unspec;\n \n     default:\n       fatal_insn (\"unrecognized supposed constant\", x);\n@@ -3715,19 +3761,19 @@ cris_emit_movem_store (rtx dest, rtx nregs_rtx, int increment,\n /* Worker function for expanding the address for PIC function calls.  */\n \n void\n-cris_expand_pic_call_address (rtx *opp)\n+cris_expand_pic_call_address (rtx *opp, rtx *markerp)\n {\n   rtx op = *opp;\n \n-  gcc_assert (MEM_P (op));\n+  gcc_assert (flag_pic && MEM_P (op));\n   op = XEXP (op, 0);\n \n   /* It might be that code can be generated that jumps to 0 (or to a\n      specific address).  Don't die on that.  (There is a\n      testcase.)  */\n-  if (CONSTANT_ADDRESS_P (op) && !CONST_INT_P (op))\n+  if (CONSTANT_P (op) && !CONST_INT_P (op))\n     {\n-      enum cris_pic_symbol_type t = cris_pic_symbol_type_of (op);\n+      enum cris_symbol_type t = cris_symbol_type_of (op);\n \n       CRIS_ASSERT (can_create_pseudo_p ());\n \n@@ -3753,18 +3799,21 @@ cris_expand_pic_call_address (rtx *opp)\n \t    }\n \t  else\n \t    op = force_reg (Pmode, op);\n+\n+\t  /* A local call.  */\n+\t  *markerp = const0_rtx;\n \t}\n       else if (t == cris_got_symbol)\n \t{\n \t  if (TARGET_AVOID_GOTPLT)\n \t    {\n \t      /* Change a \"jsr sym\" into (allocate register rM, rO)\n-\t\t \"move.d (const (unspec [sym rPIC] CRIS_UNSPEC_PLT_GOTREL)),rM\"\n+\t\t \"move.d (const (unspec [sym] CRIS_UNSPEC_PLT_GOTREL)),rM\"\n \t\t \"add.d rPIC,rM,rO\", \"jsr rO\" for pre-v32 and\n-\t\t \"jsr (const (unspec [sym rPIC] CRIS_UNSPEC_PLT_PCREL))\"\n+\t\t \"jsr (const (unspec [sym] CRIS_UNSPEC_PLT_PCREL))\"\n \t\t for v32.  */\n \t      rtx tem, rm, ro;\n-\t      gcc_assert (can_create_pseudo_p ());\n+\n \t      crtl->uses_pic_offset_table = 1;\n \t      tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op),\n \t\t\t\t    TARGET_V32\n@@ -3818,14 +3867,27 @@ cris_expand_pic_call_address (rtx *opp)\n \t      MEM_NOTRAP_P (mem) = 1;\n \t      op = mem;\n \t    }\n+\n+\t  /* We need to prepare this call to go through the PLT; we\n+\t     need to make GOT available.  */\n+\t  *markerp = pic_offset_table_rtx;\n \t}\n       else\n-\t/* Can't possibly get a GOT-needing-fixup for a function-call,\n-\t   right?  */\n+\t/* Can't possibly get anything else for a function-call, right?  */\n \tfatal_insn (\"unidentifiable call op\", op);\n \n-      *opp = replace_equiv_address (*opp, op);\n+      /* If the validizing variant is called, it will try to validize\n+\t the address as a valid any-operand constant, but as it's only\n+\t valid for calls and moves, it will fail and always be forced\n+\t into a register.  */\n+      *opp = replace_equiv_address_nv (*opp, op);\n     }\n+  else\n+    /* Can't tell what locality a call to a non-constant address has;\n+       better make the GOT register alive at it.\n+       FIXME: Can we see whether the register has known constant\n+       contents?  */\n+    *markerp = pic_offset_table_rtx;\n }\n \n /* Make sure operands are in the right order for an addsi3 insn as"}, {"sha": "c5aa83edba37f2e90ccd151ce2fea54e7cabb86b", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab4e53feba14df1de389b194b095f7932a8ca9ee/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab4e53feba14df1de389b194b095f7932a8ca9ee/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=ab4e53feba14df1de389b194b095f7932a8ca9ee", "patch": "@@ -794,6 +794,12 @@ struct cum_args {int regs;};\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n+/* The mode argument to cris_legitimate_constant_p isn't used, so just\n+   pass a cheap dummy.  N.B. we have to cast away const from the\n+   parameter rather than adjust the parameter, as it's type is mandated\n+   by the TARGET_LEGITIMATE_CONSTANT_P target hook interface.  */\n+#define CRIS_CONSTANT_P(X) \\\n+  (CONSTANT_P (X) && cris_legitimate_constant_p (VOIDmode, CONST_CAST_RTX (X)))\n \n /* Node: Condition Code */\n \n@@ -833,13 +839,14 @@ struct cum_args {int regs;};\n \n /* Helper type.  */\n \n-enum cris_pic_symbol_type\n+enum cris_symbol_type\n   {\n     cris_no_symbol = 0,\n     cris_got_symbol = 1,\n     cris_rel_symbol = 2,\n     cris_got_symbol_needing_fixup = 3,\n-    cris_invalid_pic_symbol = 4\n+    cris_unspec = 7,\n+    cris_offsettable_symbol = 8\n   };\n \n #define PIC_OFFSET_TABLE_REGNUM (flag_pic ? CRIS_GOT_REGNUM : INVALID_REGNUM)"}, {"sha": "18b9787866343a702cb256a40c4c1031ce8f4be9", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 40, "deletions": 20, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab4e53feba14df1de389b194b095f7932a8ca9ee/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab4e53feba14df1de389b194b095f7932a8ca9ee/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=ab4e53feba14df1de389b194b095f7932a8ca9ee", "patch": "@@ -919,6 +919,8 @@\n     (match_operand:SI 1 \"cris_general_operand_or_symbol\" \"\"))]\n   \"\"\n {\n+  enum cris_symbol_type t;\n+\n   /* If the output goes to a MEM, make sure we have zero or a register as\n      input.  */\n   if (MEM_P (operands[0])\n@@ -934,12 +936,12 @@\n      valid symbol?  Can we exclude global PIC addresses with an added\n      offset?  */\n     if (flag_pic\n-\t&& CONSTANT_ADDRESS_P (operands[1])\n+\t&& CONSTANT_P (operands[1])\n \t&& !cris_valid_pic_const (operands[1], false))\n       {\n-\tenum cris_pic_symbol_type t = cris_pic_symbol_type_of (operands[1]);\n+\tt = cris_symbol_type_of (operands[1]);\n \n-\tgcc_assert (t != cris_no_symbol);\n+\tgcc_assert (t != cris_no_symbol && t != cris_offsettable_symbol);\n \n \tif (! REG_S_P (operands[0]))\n \t  {\n@@ -1086,7 +1088,12 @@\n \t if (!flag_pic\n \t     && (GET_CODE (operands[1]) == SYMBOL_REF\n \t\t || GET_CODE (operands[1]) == LABEL_REF\n-\t\t || GET_CODE (operands[1]) == CONST))\n+\t\t || (GET_CODE (operands[1]) == CONST\n+\t\t     && (GET_CODE (XEXP (operands[1], 0)) != UNSPEC\n+\t\t\t || (XINT (XEXP (operands[1], 0), 1)\n+\t\t\t     == CRIS_UNSPEC_PLT_PCREL)\n+\t\t\t || (XINT (XEXP (operands[1], 0), 1)\n+\t\t\t     == CRIS_UNSPEC_PCREL)))))\n \t   {\n \t     /* FIXME: Express this through (set_attr cc none) instead,\n \t\tsince we can't express the ``none'' at this point.  FIXME:\n@@ -1169,6 +1176,12 @@\n \t  case CRIS_UNSPEC_PCREL:\n \t  case CRIS_UNSPEC_PLT_PCREL:\n \t    gcc_assert (TARGET_V32);\n+\t    /* LAPC doesn't set condition codes; clear them to make the\n+\t       (equivalence-marked) result of this insn not presumed\n+\t       present.  This instruction can be a PIC symbol load (for\n+\t       a hidden symbol) which for weak symbols will be followed\n+\t       by a test for NULL.  */\n+\t    CC_STATUS_INIT;\n \t    return \"lapc %1,%0\";\n \n \t  default:\n@@ -3710,15 +3723,16 @@\n {\n   gcc_assert (MEM_P (operands[0]));\n   if (flag_pic)\n-    cris_expand_pic_call_address (&operands[0]);\n+    cris_expand_pic_call_address (&operands[0], &operands[1]);\n+  else\n+    operands[1] = const0_rtx;\n })\n \n-;; Accept *anything* as operand 1.  Accept operands for operand 0 in\n-;; order of preference.\n+;; Accept operands for operand 0 in order of preference.\n \n (define_insn \"*expanded_call_non_v32\"\n   [(call (mem:QI (match_operand:SI 0 \"general_operand\" \"r,Q>,g\"))\n-\t (match_operand 1 \"\" \"\"))\n+\t (match_operand:SI 1 \"cris_call_type_marker\" \"rM,rM,rM\"))\n    (clobber (reg:SI CRIS_SRP_REGNUM))]\n   \"!TARGET_V32\"\n   \"jsr %0\")\n@@ -3727,7 +3741,7 @@\n   [(call\n     (mem:QI\n      (match_operand:SI 0 \"cris_nonmemory_operand_or_callable_symbol\" \"n,r,U,i\"))\n-    (match_operand 1 \"\" \"\"))\n+    (match_operand:SI 1 \"cris_call_type_marker\" \"rM,rM,rM,rM\"))\n    (clobber (reg:SI CRIS_SRP_REGNUM))]\n   \"TARGET_V32\"\n   \"@\n@@ -3740,19 +3754,21 @@\n ;; Parallel when calculating and reusing address of indirect pointer\n ;; with simple offset.  (Makes most sense with PIC.)  It looks a bit\n ;; wrong not to have the clobber last, but that's the way combine\n-;; generates it (except it doesn' look into the *inner* mem, so this\n+;; generates it (except it doesn't look into the *inner* mem, so this\n ;; just matches a peephole2).  FIXME: investigate that.\n (define_insn \"*expanded_call_side\"\n   [(call (mem:QI\n \t  (mem:SI\n \t   (plus:SI (match_operand:SI 0 \"cris_bdap_operand\" \"%r,  r,r\")\n \t\t    (match_operand:SI 1 \"cris_bdap_operand\" \"r>Rn,r,>Rn\"))))\n-\t (match_operand 2 \"\" \"\"))\n+\t (match_operand:SI 2 \"cris_call_type_marker\" \"rM,rM,rM\"))\n    (clobber (reg:SI CRIS_SRP_REGNUM))\n    (set (match_operand:SI 3 \"register_operand\" \"=*0,r,r\")\n \t(plus:SI (match_dup 0)\n \t\t (match_dup 1)))]\n-  \"!TARGET_AVOID_GOTPLT && !TARGET_V32\"\n+  ;; Disabled until after reload until we can avoid an output reload for\n+  ;; operand 3 (being forbidden for call insns).\n+  \"reload_completed && !TARGET_AVOID_GOTPLT && !TARGET_V32\"\n   \"jsr [%3=%0%S1]\")\n \n (define_expand \"call_value\"\n@@ -3764,10 +3780,12 @@\n {\n   gcc_assert (MEM_P (operands[1]));\n   if (flag_pic)\n-    cris_expand_pic_call_address (&operands[1]);\n+    cris_expand_pic_call_address (&operands[1], &operands[2]);\n+  else\n+    operands[2] = const0_rtx;\n })\n \n-;; Accept *anything* as operand 2.  The validity other than \"general\" of\n+;; The validity other than \"general\" of\n ;; operand 0 will be checked elsewhere.  Accept operands for operand 1 in\n ;; order of preference (Q includes r, but r is shorter, faster).\n ;;  We also accept a PLT symbol.  We output it as [rPIC+sym:GOTPLT] rather\n@@ -3776,7 +3794,7 @@\n (define_insn \"*expanded_call_value_non_v32\"\n   [(set (match_operand 0 \"nonimmediate_operand\" \"=g,g,g\")\n \t(call (mem:QI (match_operand:SI 1 \"general_operand\" \"r,Q>,g\"))\n-\t      (match_operand 2 \"\" \"\")))\n+\t      (match_operand:SI 2 \"cris_call_type_marker\" \"rM,rM,rM\")))\n    (clobber (reg:SI CRIS_SRP_REGNUM))]\n   \"!TARGET_V32\"\n   \"Jsr %1\"\n@@ -3790,12 +3808,14 @@\n \t  (mem:SI\n \t   (plus:SI (match_operand:SI 1 \"cris_bdap_operand\" \"%r,  r,r\")\n \t\t    (match_operand:SI 2 \"cris_bdap_operand\" \"r>Rn,r,>Rn\"))))\n-\t      (match_operand 3 \"\" \"\")))\n+\t (match_operand:SI 3 \"cris_call_type_marker\" \"rM,rM,rM\")))\n    (clobber (reg:SI CRIS_SRP_REGNUM))\n    (set (match_operand:SI 4 \"register_operand\" \"=*1,r,r\")\n \t(plus:SI (match_dup 1)\n \t\t (match_dup 2)))]\n-  \"!TARGET_AVOID_GOTPLT && !TARGET_V32\"\n+  ;; Disabled until after reload until we can avoid an output reload for\n+  ;; operand 4 (being forbidden for call insns).\n+  \"reload_completed && !TARGET_AVOID_GOTPLT && !TARGET_V32\"\n   \"Jsr [%4=%1%S2]\"\n   [(set_attr \"cc\" \"clobber\")])\n \n@@ -3805,7 +3825,7 @@\n     (call\n      (mem:QI\n       (match_operand:SI 1 \"cris_nonmemory_operand_or_callable_symbol\" \"n,r,U,i\"))\n-     (match_operand 2 \"\" \"\")))\n+     (match_operand:SI 2 \"cris_call_type_marker\" \"rM,rM,rM,rM\")))\n    (clobber (reg:SI 16))]\n   \"TARGET_V32\"\n   \"@\n@@ -4827,7 +4847,7 @@\n   /* Make sure we have canonical RTX so we match the insn pattern -\n      not a constant in the first operand.  We also require the order\n      (plus reg mem) to match the final pattern.  */\n-  if (CONSTANT_P (otherop) || MEM_P (otherop))\n+  if (CRIS_CONSTANT_P (otherop) || MEM_P (otherop))\n     {\n       operands[7] = operands[1];\n       operands[8] = otherop;\n@@ -4878,7 +4898,7 @@\n   /* Make sure we have canonical RTX so we match the insn pattern -\n      not a constant in the first operand.  We also require the order\n      (plus reg mem) to match the final pattern.  */\n-  if (CONSTANT_P (otherop) || MEM_P (otherop))\n+  if (CRIS_CONSTANT_P (otherop) || MEM_P (otherop))\n     {\n       operands[7] = operands[1];\n       operands[8] = otherop;"}, {"sha": "ddb090eab71b5b3160a4a962c71119f8d97267e1", "filename": "gcc/config/cris/predicates.md", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab4e53feba14df1de389b194b095f7932a8ca9ee/gcc%2Fconfig%2Fcris%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab4e53feba14df1de389b194b095f7932a8ca9ee/gcc%2Fconfig%2Fcris%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fpredicates.md?ref=ab4e53feba14df1de389b194b095f7932a8ca9ee", "patch": "@@ -142,7 +142,7 @@\n   (ior (match_operand 0 \"general_operand\")\n        (and (match_code \"const, symbol_ref, label_ref\")\n        \t    ; The following test is actually just an assertion.\n-\t    (match_test \"cris_pic_symbol_type_of (op) != cris_no_symbol\"))))\n+\t    (match_test \"cris_symbol_type_of (op) != cris_no_symbol\"))))\n \n ;; A predicate for the anon movsi expansion, one that fits a PCREL\n ;; operand as well as general_operand.\n@@ -176,3 +176,15 @@\n        (ior (match_operand 0 \"memory_operand\")\n \t    (match_test \"cris_general_operand_or_symbol (XEXP (op, 0),\n \t\t\t\t\t\t\t Pmode)\"))))\n+\n+;; A marker for the call-insn: (const_int 0) for a call to a\n+;; hidden or static function and non-pic and\n+;; pic_offset_table_rtx for a call that *might* go through the\n+;; PLT.\n+\n+(define_predicate \"cris_call_type_marker\"\n+  (ior (and (match_operand 0 \"const_int_operand\")\n+\t    (match_test \"op == const0_rtx\"))\n+       (and (and (match_operand 0 \"register_operand\")\n+\t\t (match_test \"op == pic_offset_table_rtx\"))\n+\t    (match_test \"flag_pic != 0\"))))"}]}