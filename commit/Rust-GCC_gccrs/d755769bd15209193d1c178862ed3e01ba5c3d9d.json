{"sha": "d755769bd15209193d1c178862ed3e01ba5c3d9d", "node_id": "C_kwDOANBUbNoAKGQ3NTU3NjliZDE1MjA5MTkzZDFjMTc4ODYyZWQzZTAxYmE1YzNkOWQ", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-10-15T17:02:51Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-10-22T09:34:31Z"}, "message": "BugFix: TypePath resolution to handle associated types\n\nTypePath's can be fully resolved at name resolution time for example a\nprimitive types are single segments which can be resolved. But in the event\nof a generic TypeBound path such as: T::A where T is the generic type param\nin a function and A is its own associated type this require's the\nresolution to be split over the name resolver and type resolver.\n\nLike PathInExpression's the name resolver is able to resolve the root\nsegment of 'T' but requires a path probe on the type-bounds of T to find\nthe associated type 'A'.\n\nFixes #746", "tree": {"sha": "de4344d1cd0cfc3204cd0816fdf2678c02a52896", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de4344d1cd0cfc3204cd0816fdf2678c02a52896"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d755769bd15209193d1c178862ed3e01ba5c3d9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d755769bd15209193d1c178862ed3e01ba5c3d9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d755769bd15209193d1c178862ed3e01ba5c3d9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d755769bd15209193d1c178862ed3e01ba5c3d9d/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a80bcfc5b1cb471d904ae9135256d9d0b0d77cd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a80bcfc5b1cb471d904ae9135256d9d0b0d77cd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a80bcfc5b1cb471d904ae9135256d9d0b0d77cd4"}], "stats": {"total": 454, "additions": 396, "deletions": 58}, "files": [{"sha": "a04398e7ef4c6dfab0652433340532bc2ff2fb54", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=d755769bd15209193d1c178862ed3e01ba5c3d9d", "patch": "@@ -420,6 +420,11 @@ class TypePathSegment\n   const Analysis::NodeMapping &get_mappings () const { return mappings; }\n \n   const PathIdentSegment &get_ident_segment () const { return ident_segment; }\n+\n+  bool is_generic_segment () const\n+  {\n+    return get_type () == SegmentType::GENERIC;\n+  }\n };\n \n // Segment used in type path with generic args"}, {"sha": "71085f675bb834e32941cc446508460dd4fb7ac2", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=d755769bd15209193d1c178862ed3e01ba5c3d9d", "patch": "@@ -591,7 +591,7 @@ class ResolveItem : public ResolverBase\n \n     // Self is an implicit TypeParam so lets mark it as such\n     resolver->get_type_scope ().append_reference_for_def (\n-      Self.get_id (), implicit_self->get_node_id ());\n+      Self.get_node_id (), implicit_self->get_node_id ());\n \n     if (trait.has_type_param_bounds ())\n       {"}, {"sha": "2dc7fbf10c0a77d113952c4f7c82469e7819c6f1", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 52, "deletions": 34, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=d755769bd15209193d1c178862ed3e01ba5c3d9d", "patch": "@@ -188,35 +188,6 @@ class ResolveRelativeTypePath : public ResolveTypeToCanonicalPath\n   using ResolveTypeToCanonicalPath::visit;\n \n public:\n-  static NodeId go (AST::TypePath &path, NodeId parent,\n-\t\t    bool canonicalize_type_with_generics)\n-  {\n-    CanonicalPath canonical_path\n-      = ResolveTypeToCanonicalPath::resolve (path,\n-\t\t\t\t\t     canonicalize_type_with_generics,\n-\t\t\t\t\t     true);\n-    if (canonical_path.is_empty ())\n-      {\n-\trust_error_at (path.get_locus (),\n-\t\t       \"Failed to resolve canonical path for TypePath\");\n-\treturn UNKNOWN_NODEID;\n-      }\n-\n-    auto resolver = Resolver::get ();\n-    NodeId resolved_node = UNKNOWN_NODEID;\n-\n-    // We may need to change how names are resolved, like described in :\n-    // https://github.com/rust-lang/rust/blob/1f94abcda6884893d4723304102089198caa0839/compiler/rustc_resolve/src/lib.rs#L1722\n-    if (!resolver->get_type_scope ().lookup (canonical_path, &resolved_node))\n-      {\n-\trust_error_at (path.get_locus (), \"failed to resolve TypePath: %s\",\n-\t\t       canonical_path.get ().c_str ());\n-\treturn UNKNOWN_NODEID;\n-      }\n-\n-    return resolved_node;\n-  }\n-\n   static NodeId go (AST::QualifiedPathInType &path, NodeId parent,\n \t\t    bool canonicalize_type_with_generics)\n   {\n@@ -316,11 +287,58 @@ class ResolveType : public ResolverBase\n \n   void visit (AST::TypePath &path) override\n   {\n-    resolved_node\n-      = ResolveRelativeTypePath::go (path, parent,\n-\t\t\t\t     canonicalize_type_with_generics);\n-    ok = resolved_node != UNKNOWN_NODEID;\n-    if (ok)\n+    auto canonical_path\n+      = ResolveTypeToCanonicalPath::resolve (path,\n+\t\t\t\t\t     canonicalize_type_with_generics,\n+\t\t\t\t\t     true);\n+    if (canonical_path.is_empty ())\n+      {\n+\trust_error_at (path.get_locus (),\n+\t\t       \"Failed to resolve canonical path for TypePath\");\n+\treturn;\n+      }\n+\n+    ok = !canonical_path.is_empty ();\n+\n+    // lets try and resolve in one go else leave it up to the type resolver to\n+    // figure outer\n+\n+    if (resolver->get_type_scope ().lookup (canonical_path, &resolved_node))\n+      {\n+\tresolver->insert_resolved_type (path.get_node_id (), resolved_node);\n+\tresolver->insert_new_definition (path.get_node_id (),\n+\t\t\t\t\t Definition{path.get_node_id (),\n+\t\t\t\t\t\t    parent});\n+\treturn;\n+      }\n+\n+    // lets resolve as many segments as we can and leave it up to the type\n+    // resolver otherwise\n+    size_t nprocessed = 0;\n+    canonical_path.iterate ([&] (const CanonicalPath &seg) -> bool {\n+      resolved_node = UNKNOWN_NODEID;\n+\n+      if (!resolver->get_type_scope ().lookup (seg, &resolved_node))\n+\treturn false;\n+\n+      resolver->insert_resolved_type (seg.get_node_id (), resolved_node);\n+      resolver->insert_new_definition (seg.get_node_id (),\n+\t\t\t\t       Definition{path.get_node_id (), parent});\n+      nprocessed++;\n+      return true;\n+    });\n+\n+    if (nprocessed == 0)\n+      {\n+\trust_error_at (path.get_locus (), \"failed to resolve TypePath: %s\",\n+\t\t       path.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    // its ok if this fails since the type resolver sometimes will need to\n+    // investigate the bounds of a type for the associated type for example see:\n+    // https://github.com/Rust-GCC/gccrs/issues/746\n+    if (nprocessed == canonical_path.size ())\n       {\n \tresolver->insert_resolved_type (path.get_node_id (), resolved_node);\n \tresolver->insert_new_definition (path.get_node_id (),"}, {"sha": "0aea8ca669a8a4baf422e7e4fb8115b52fb7ee11", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=d755769bd15209193d1c178862ed3e01ba5c3d9d", "patch": "@@ -41,6 +41,7 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n \n       resolve_segments (root_resolved_node_id, expr.get_segments (), 0, root,\n \t\t\texpr.get_mappings (), expr.get_locus ());\n+      return;\n     }\n \n   // Resolve the trait now"}, {"sha": "a4795813a57857c94b48aff3559adb3cacc16a73", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 314, "deletions": 11, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=d755769bd15209193d1c178862ed3e01ba5c3d9d", "patch": "@@ -28,10 +28,26 @@ TypeCheckType::visit (HIR::TypePath &path)\n   // lookup the Node this resolves to\n   NodeId ref;\n   auto nid = path.get_mappings ().get_nodeid ();\n-  if (!resolver->lookup_resolved_type (nid, &ref))\n+  bool is_fully_resolved = resolver->lookup_resolved_type (nid, &ref);\n+\n+  TyTy::BaseType *lookup = nullptr;\n+  if (!is_fully_resolved)\n     {\n-      rust_fatal_error (path.get_locus (), \"failed to resolve node '%d' to HIR\",\n-\t\t\tnid);\n+      // this can happen so we need to look up the root then resolve the\n+      // remaining segments if possible\n+      size_t offset = 0;\n+      NodeId resolved_node_id = UNKNOWN_NODEID;\n+      TyTy::BaseType *root\n+\t= resolve_root_path (path, &offset, &resolved_node_id);\n+\n+      rust_assert (root != nullptr);\n+      if (root->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn;\n+\n+      translated\n+\t= resolve_segments (resolved_node_id, path.get_mappings ().get_hirid (),\n+\t\t\t    path.get_segments (), offset, root,\n+\t\t\t    path.get_mappings (), path.get_locus ());\n       return;\n     }\n \n@@ -43,7 +59,6 @@ TypeCheckType::visit (HIR::TypePath &path)\n       return;\n     }\n \n-  TyTy::BaseType *lookup = nullptr;\n   if (!context->lookup_type (hir_lookup, &lookup))\n     {\n       rust_error_at (path.get_locus (), \"failed to lookup HIR TyTy\");\n@@ -109,8 +124,12 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n \t&root_resolved_node_id);\n       rust_assert (ok);\n \n-      resolve_segments (root_resolved_node_id, path.get_segments (), 0,\n-\t\t\ttranslated, path.get_mappings (), path.get_locus ());\n+      translated = resolve_segments (root_resolved_node_id,\n+\t\t\t\t     path.get_mappings ().get_hirid (),\n+\t\t\t\t     path.get_segments (), 0, translated,\n+\t\t\t\t     path.get_mappings (), path.get_locus ());\n+\n+      return;\n     }\n \n   // Resolve the trait now\n@@ -207,18 +226,302 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n       return;\n     }\n \n-  resolve_segments (root_resolved_node_id, path.get_segments (), 0, translated,\n-\t\t    path.get_mappings (), path.get_locus ());\n+  translated\n+    = resolve_segments (root_resolved_node_id,\n+\t\t\tpath.get_mappings ().get_hirid (), path.get_segments (),\n+\t\t\t0, translated, path.get_mappings (), path.get_locus ());\n }\n \n-void\n+TyTy::BaseType *\n+TypeCheckType::resolve_root_path (HIR::TypePath &path, size_t *offset,\n+\t\t\t\t  NodeId *root_resolved_node_id)\n+{\n+  TyTy::BaseType *root_tyty = nullptr;\n+  *offset = 0;\n+  for (size_t i = 0; i < path.get_num_segments (); i++)\n+    {\n+      std::unique_ptr<HIR::TypePathSegment> &seg = path.get_segments ().at (i);\n+\n+      bool have_more_segments = (path.get_num_segments () - 1 != i);\n+      bool is_root = *offset == 0;\n+      NodeId ast_node_id = seg->get_mappings ().get_nodeid ();\n+\n+      // then lookup the reference_node_id\n+      NodeId ref_node_id = UNKNOWN_NODEID;\n+      if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+\t{\n+\t  // these ref_node_ids will resolve to a pattern declaration but we\n+\t  // are interested in the definition that this refers to get the\n+\t  // parent id\n+\t  Definition def;\n+\t  if (!resolver->lookup_definition (ref_node_id, &def))\n+\t    {\n+\t      rust_error_at (path.get_locus (),\n+\t\t\t     \"unknown reference for resolved name\");\n+\t      return new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n+\t    }\n+\t  ref_node_id = def.parent;\n+\t}\n+      else\n+\t{\n+\t  resolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n+\t}\n+\n+      // ref_node_id is the NodeId that the segments refers to.\n+      if (ref_node_id == UNKNOWN_NODEID)\n+\t{\n+\t  if (is_root)\n+\t    {\n+\t      rust_error_at (seg->get_locus (),\n+\t\t\t     \"failed to type resolve root segment\");\n+\t      return new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n+\t    }\n+\t  return root_tyty;\n+\t}\n+\n+      // node back to HIR\n+      HirId ref;\n+      if (!mappings->lookup_node_to_hir (path.get_mappings ().get_crate_num (),\n+\t\t\t\t\t ref_node_id, &ref))\n+\t{\n+\t  if (is_root)\n+\t    {\n+\t      rust_error_at (seg->get_locus (), \"789 reverse lookup failure\");\n+\t      rust_debug_loc (\n+\t\tseg->get_locus (),\n+\t\t\"failure with [%s] mappings [%s] ref_node_id [%u]\",\n+\t\tseg->as_string ().c_str (),\n+\t\tseg->get_mappings ().as_string ().c_str (), ref_node_id);\n+\n+\t      return new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n+\t    }\n+\n+\t  return root_tyty;\n+\t}\n+\n+      auto seg_is_module\n+\t= (nullptr\n+\t   != mappings->lookup_module (path.get_mappings ().get_crate_num (),\n+\t\t\t\t       ref));\n+\n+      if (seg_is_module)\n+\t{\n+\t  // A::B::C::this_is_a_module::D::E::F\n+\t  //          ^^^^^^^^^^^^^^^^\n+\t  //          Currently handling this.\n+\t  if (have_more_segments)\n+\t    {\n+\t      (*offset)++;\n+\t      continue;\n+\t    }\n+\n+\t  // In the case of :\n+\t  // A::B::C::this_is_a_module\n+\t  //          ^^^^^^^^^^^^^^^^\n+\t  // This is an error, we are not expecting a module.\n+\t  rust_error_at (seg->get_locus (), \"expected value\");\n+\t  return new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n+\t}\n+\n+      TyTy::BaseType *lookup = nullptr;\n+      if (!context->lookup_type (ref, &lookup))\n+\t{\n+\t  if (is_root)\n+\t    {\n+\t      rust_error_at (seg->get_locus (),\n+\t\t\t     \"failed to resolve root segment\");\n+\t      return new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n+\t    }\n+\t  return root_tyty;\n+\t}\n+\n+      // if we have a previous segment type\n+      if (root_tyty != nullptr)\n+\t{\n+\t  // if this next segment needs substitution we must apply the\n+\t  // previous type arguments\n+\t  //\n+\t  // such as: GenericStruct::<_>::new(123, 456)\n+\t  if (lookup->needs_generic_substitutions ())\n+\t    {\n+\t      if (!root_tyty->needs_generic_substitutions ())\n+\t\t{\n+\t\t  auto used_args_in_prev_segment\n+\t\t    = GetUsedSubstArgs::From (root_tyty);\n+\t\t  lookup\n+\t\t    = SubstMapperInternal::Resolve (lookup,\n+\t\t\t\t\t\t    used_args_in_prev_segment);\n+\t\t}\n+\t    }\n+\t}\n+\n+      // turbo-fish segment path::<ty>\n+      if (seg->is_generic_segment ())\n+\t{\n+\t  HIR::TypePathSegmentGeneric *generic_segment\n+\t    = static_cast<HIR::TypePathSegmentGeneric *> (seg.get ());\n+\n+\t  if (!lookup->can_substitute ())\n+\t    {\n+\t      rust_error_at (seg->get_locus (),\n+\t\t\t     \"substitutions not supported for %s\",\n+\t\t\t     lookup->as_string ().c_str ());\n+\t      return new TyTy::ErrorType (lookup->get_ref ());\n+\t    }\n+\t  lookup = SubstMapper::Resolve (lookup, path.get_locus (),\n+\t\t\t\t\t &generic_segment->get_generic_args ());\n+\t}\n+\n+      *root_resolved_node_id = ref_node_id;\n+      *offset = *offset + 1;\n+      root_tyty = lookup;\n+    }\n+\n+  return root_tyty;\n+}\n+\n+TyTy::BaseType *\n TypeCheckType::resolve_segments (\n-  NodeId root_resolved_node_id,\n+  NodeId root_resolved_node_id, HirId expr_id,\n   std::vector<std::unique_ptr<HIR::TypePathSegment>> &segments, size_t offset,\n   TyTy::BaseType *tyseg, const Analysis::NodeMapping &expr_mappings,\n   Location expr_locus)\n {\n-  gcc_unreachable ();\n+  NodeId resolved_node_id = root_resolved_node_id;\n+  TyTy::BaseType *prev_segment = tyseg;\n+  for (size_t i = offset; i < segments.size (); i++)\n+    {\n+      std::unique_ptr<HIR::TypePathSegment> &seg = segments.at (i);\n+\n+      bool reciever_is_generic\n+\t= prev_segment->get_kind () == TyTy::TypeKind::PARAM;\n+      bool probe_bounds = true;\n+      bool probe_impls = !reciever_is_generic;\n+      bool ignore_mandatory_trait_items = !reciever_is_generic;\n+\n+      // probe the path is done in two parts one where we search impls if no\n+      // candidate is found then we search extensions from traits\n+      auto candidates\n+\t= PathProbeType::Probe (prev_segment, seg->get_ident_segment (),\n+\t\t\t\tprobe_impls, false,\n+\t\t\t\tignore_mandatory_trait_items);\n+      if (candidates.size () == 0)\n+\t{\n+\t  candidates\n+\t    = PathProbeType::Probe (prev_segment, seg->get_ident_segment (),\n+\t\t\t\t    false, probe_bounds,\n+\t\t\t\t    ignore_mandatory_trait_items);\n+\n+\t  if (candidates.size () == 0)\n+\t    {\n+\t      rust_error_at (\n+\t\tseg->get_locus (),\n+\t\t\"failed to resolve path segment using an impl Probe\");\n+\t      return new TyTy::ErrorType (expr_id);\n+\t    }\n+\t}\n+\n+      if (candidates.size () > 1)\n+\t{\n+\t  ReportMultipleCandidateError::Report (candidates,\n+\t\t\t\t\t\tseg->get_ident_segment (),\n+\t\t\t\t\t\tseg->get_locus ());\n+\t  return new TyTy::ErrorType (expr_id);\n+\t}\n+\n+      auto &candidate = candidates.at (0);\n+      prev_segment = tyseg;\n+      tyseg = candidate.ty;\n+\n+      if (candidate.is_impl_candidate ())\n+\t{\n+\t  resolved_node_id\n+\t    = candidate.item.impl.impl_item->get_impl_mappings ().get_nodeid ();\n+\t}\n+      else\n+\t{\n+\t  resolved_node_id\n+\t    = candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n+\n+\t  // lookup the associated-impl-trait\n+\t  HIR::ImplBlock *impl = candidate.item.trait.impl;\n+\t  if (impl != nullptr)\n+\t    {\n+\t      AssociatedImplTrait *lookup_associated = nullptr;\n+\t      bool found_impl_trait = context->lookup_associated_trait_impl (\n+\t\timpl->get_mappings ().get_hirid (), &lookup_associated);\n+\t      rust_assert (found_impl_trait);\n+\n+\t      lookup_associated->setup_associated_types ();\n+\n+\t      // we need a new ty_ref_id for this trait item\n+\t      tyseg = tyseg->clone ();\n+\t      tyseg->set_ty_ref (mappings->get_next_hir_id ());\n+\t    }\n+\t}\n+\n+      if (seg->is_generic_segment ())\n+\t{\n+\t  HIR::TypePathSegmentGeneric *generic_segment\n+\t    = static_cast<HIR::TypePathSegmentGeneric *> (seg.get ());\n+\n+\t  if (!tyseg->can_substitute ())\n+\t    {\n+\t      rust_error_at (expr_locus, \"substitutions not supported for %s\",\n+\t\t\t     tyseg->as_string ().c_str ());\n+\t      return new TyTy::ErrorType (expr_id);\n+\t    }\n+\n+\t  tyseg = SubstMapper::Resolve (tyseg, expr_locus,\n+\t\t\t\t\t&generic_segment->get_generic_args ());\n+\t  if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\t    return new TyTy::ErrorType (expr_id);\n+\t}\n+    }\n+\n+  context->insert_receiver (expr_mappings.get_hirid (), prev_segment);\n+  if (tyseg->needs_generic_substitutions ())\n+    {\n+      Location locus = segments.back ()->get_locus ();\n+      if (!prev_segment->needs_generic_substitutions ())\n+\t{\n+\t  auto used_args_in_prev_segment\n+\t    = GetUsedSubstArgs::From (prev_segment);\n+\t  if (!used_args_in_prev_segment.is_error ())\n+\t    tyseg\n+\t      = SubstMapperInternal::Resolve (tyseg, used_args_in_prev_segment);\n+\t}\n+      else\n+\t{\n+\t  tyseg = SubstMapper::InferSubst (tyseg, locus);\n+\t}\n+\n+      if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn new TyTy::ErrorType (expr_id);\n+    }\n+\n+  rust_assert (resolved_node_id != UNKNOWN_NODEID);\n+\n+  // lookup if the name resolver was able to canonically resolve this or not\n+  NodeId path_resolved_id = UNKNOWN_NODEID;\n+  if (resolver->lookup_resolved_name (expr_mappings.get_nodeid (),\n+\t\t\t\t      &path_resolved_id))\n+    {\n+      rust_assert (path_resolved_id == resolved_node_id);\n+    }\n+  // check the type scope\n+  else if (resolver->lookup_resolved_type (expr_mappings.get_nodeid (),\n+\t\t\t\t\t   &path_resolved_id))\n+    {\n+      rust_assert (path_resolved_id == resolved_node_id);\n+    }\n+  else\n+    {\n+      resolver->insert_resolved_name (expr_mappings.get_nodeid (),\n+\t\t\t\t      resolved_node_id);\n+    }\n+\n+  return tyseg;\n }\n \n void"}, {"sha": "e0c0e91063295f504963786c021d9111e27dd161", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=d755769bd15209193d1c178862ed3e01ba5c3d9d", "patch": "@@ -185,8 +185,11 @@ class TypeCheckType : public TypeCheckBase\n       }\n   }\n \n-  void resolve_segments (\n-    NodeId root_resolved_node_id,\n+  TyTy::BaseType *resolve_root_path (HIR::TypePath &path, size_t *offset,\n+\t\t\t\t     NodeId *root_resolved_node_id);\n+\n+  TyTy::BaseType *resolve_segments (\n+    NodeId root_resolved_node_id, HirId expr_id,\n     std::vector<std::unique_ptr<HIR::TypePathSegment>> &segments, size_t offset,\n     TyTy::BaseType *tyseg, const Analysis::NodeMapping &expr_mappings,\n     Location expr_locus);"}, {"sha": "6b4bfa188c0665647dd83d566bd526b9092011a1", "filename": "gcc/rust/util/rust-canonical-path.h", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Frust%2Futil%2Frust-canonical-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Frust%2Futil%2Frust-canonical-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-canonical-path.h?ref=d755769bd15209193d1c178862ed3e01ba5c3d9d", "patch": "@@ -95,7 +95,12 @@ class CanonicalPath\n   }\n \n   // if we have the path A::B::C this will give a callback for each segment\n-  // example:\n+  // including the prefix, example:\n+  //\n+  // path:\n+  //   A::B::C\n+  //\n+  // iterate:\n   //   A\n   //   A::B\n   //   A::B::C\n@@ -110,6 +115,16 @@ class CanonicalPath\n       }\n   }\n \n+  // if we have the path A::B::C this will give a callback for each segment\n+  // example:\n+  //\n+  // path:\n+  //   A::B::C\n+  //\n+  // iterate:\n+  //   A\n+  //      B\n+  //         C\n   void iterate_segs (std::function<bool (const CanonicalPath &)> cb) const\n   {\n     for (auto &seg : segs)\n@@ -123,7 +138,7 @@ class CanonicalPath\n \n   size_t size () const { return segs.size (); }\n \n-  NodeId get_id () const\n+  NodeId get_node_id () const\n   {\n     rust_assert (!segs.empty ());\n     return segs.back ().first;"}, {"sha": "0a132bf5d6bf2c51314fbacd49419617b8642132", "filename": "gcc/testsuite/rust/compile/generic-default1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgeneric-default1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgeneric-default1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgeneric-default1.rs?ref=d755769bd15209193d1c178862ed3e01ba5c3d9d", "patch": "@@ -1,5 +1,3 @@\n-// { dg-error \"unresolved type\" \"\" { target *-*-* } 0 }\n-\n struct Foo<A = i321>(A);\n // { dg-error \"failed to resolve TypePath: i321\" \"\" { target *-*-* } .-1 }\n "}, {"sha": "6c847b5a29b5ed57cac2a2cfe1bfbbe19c863e6f", "filename": "gcc/testsuite/rust/compile/generics5.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics5.rs?ref=d755769bd15209193d1c178862ed3e01ba5c3d9d", "patch": "@@ -1,12 +1,9 @@\n-// Current errors are too noisy to match specific ones.\n-// { dg-error \"failed to resolve TypePath: T\" \"\" { target *-*-* } 0 }\n-// { dg-error \"unresolved type\" \"\" { target *-*-* } 0 }\n-\n struct GenericStruct<T>(T, usize);\n \n fn main() {\n     let a2;\n     a2 = GenericStruct::<i8, T>(1, 456);\n+    // { dg-error \"failed to resolve TypePath: T\" \"\" { target *-*-* } .-1 }\n \n     let b2: i32 = a2.0;\n     let c2: usize = a2.1;"}, {"sha": "3766703431eca114b84bac2a8e5e80123202fdbb", "filename": "gcc/testsuite/rust/compile/generics9.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics9.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics9.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics9.rs?ref=d755769bd15209193d1c178862ed3e01ba5c3d9d", "patch": "@@ -1,6 +1,5 @@\n struct Foo<A, B = (A, B)>(A, B);\n // { dg-error \"failed to resolve TypePath: B\" \"\" { target *-*-* } .-1 }\n-// { dg-error \"unresolved type\" \"\" { target *-*-* } .-2 }\n \n fn main() {\n     let a: Foo<bool>;"}, {"sha": "c8699f77c6ab55d418bf638601f3bad06d5cbd05", "filename": "gcc/testsuite/rust/compile/method2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmethod2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d755769bd15209193d1c178862ed3e01ba5c3d9d/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmethod2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmethod2.rs?ref=d755769bd15209193d1c178862ed3e01ba5c3d9d", "patch": "@@ -13,5 +13,4 @@ fn main() {\n     let b;\n     b = a.test::<asfasfr>(false);\n     // { dg-error \"failed to resolve TypePath: asfasfr\" \"\" { target *-*-* } .-1 }\n-    // { dg-error \"unresolved type\" \"\" { target *-*-* } .-2 }\n }"}]}