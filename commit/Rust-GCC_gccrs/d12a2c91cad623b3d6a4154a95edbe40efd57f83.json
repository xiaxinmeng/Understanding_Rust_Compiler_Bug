{"sha": "d12a2c91cad623b3d6a4154a95edbe40efd57f83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDEyYTJjOTFjYWQ2MjNiM2Q2YTQxNTRhOTVlZGJlNDBlZmQ1N2Y4Mw==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1992-03-14T05:15:35Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1992-03-14T05:15:35Z"}, "message": "Initial revision\n\nFrom-SVN: r474", "tree": {"sha": "d7d905236a47e2ea6c34500a5dfd9bdf6c0bb7d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7d905236a47e2ea6c34500a5dfd9bdf6c0bb7d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d12a2c91cad623b3d6a4154a95edbe40efd57f83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d12a2c91cad623b3d6a4154a95edbe40efd57f83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d12a2c91cad623b3d6a4154a95edbe40efd57f83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d12a2c91cad623b3d6a4154a95edbe40efd57f83/comments", "author": null, "committer": null, "parents": [{"sha": "448ff736e264dda31cce6816b712ddf96dbec057", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/448ff736e264dda31cce6816b712ddf96dbec057", "html_url": "https://github.com/Rust-GCC/gccrs/commit/448ff736e264dda31cce6816b712ddf96dbec057"}], "stats": {"total": 2660, "additions": 2660, "deletions": 0}, "files": [{"sha": "deb929ae9da7f55a8f2322ce92105bac4f267567", "filename": "gcc/config/gmicro/gmicro.md", "status": "added", "additions": 2660, "deletions": 0, "changes": 2660, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d12a2c91cad623b3d6a4154a95edbe40efd57f83/gcc%2Fconfig%2Fgmicro%2Fgmicro.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d12a2c91cad623b3d6a4154a95edbe40efd57f83/gcc%2Fconfig%2Fgmicro%2Fgmicro.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgmicro%2Fgmicro.md?ref=d12a2c91cad623b3d6a4154a95edbe40efd57f83", "patch": "@@ -0,0 +1,2660 @@\n+;;- Machine description for GNU compiler\n+;;- Fujitsu Gmicro Version\n+;;- Ported by M.Yuhara, Fujitsu Laboratories LTD.\n+;;\n+;;   Copyright (C) 1990 Free Software Foundation, Inc.\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;; Among other things, the copyright\n+;; notice and this notice must be preserved on all copies.\n+\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+\n+;;- instruction definitions\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;;- When naming insn's (operand 0 of define_insn) be careful about using\n+;;- names from other targets machine descriptions.\n+\n+;;- cpp macro #define NOTICE_UPDATE_CC is essentially a no-op for the \n+;;- gmicro; no compares are eliminated.\n+\n+;;- The original structure of this file is m68k.md.\n+\n+;; ??? Work to be done:\n+;; Add patterns for ACB and SCB instructions.\n+;; Add define_insn patterns to recognize the insns that extend a byte\n+;; to a word and add it into a word, etc.\n+\n+;;- Some of these insn's are composites of several Gmicro op codes.\n+;;- The assembler (or final @@??) insures that the appropriate one is\n+;;- selected.\n+\f\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"push_operand\" \"=m\")\n+\t(match_operand:DF 1 \"general_operand\" \"rmfF\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FPU_REG_P (operands[1]))\n+    return \\\"fmov.d %f1,%0\\\";\n+  return output_move_double (operands);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"push_operand\" \"=m\")\n+\t(match_operand:DF 1 \"general_operand\" \"rmF\"))]\n+  \"\"\n+  \"*\n+{\n+  return output_move_double (operands);\n+}\")\n+\f\n+;; We don't want to allow a constant operand for test insns because\n+;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n+;; be folded while optimizing anyway.\n+\n+(define_insn \"tstsi\"\n+  [(set (cc0)\n+\t(match_operand:SI 0 \"nonimmediate_operand\" \"rm\"))]\n+  \"\"\n+  \"cmp:z.w #0,%0\")\n+\n+(define_insn \"tsthi\"\n+  [(set (cc0)\n+\t(match_operand:HI 0 \"nonimmediate_operand\" \"rm\"))]\n+  \"\"\n+  \"cmp:z.h #0,%0\")\n+\n+(define_insn \"tstqi\"\n+  [(set (cc0)\n+\t(match_operand:QI 0 \"nonimmediate_operand\" \"rm\"))]\n+  \"\"\n+  \"cmp:z.b #0,%0\")\n+  \n+\n+(define_insn \"tstsf\"\n+  [(set (cc0)\n+\t(match_operand:SF 0 \"general_operand\" \"fmF\"))]\n+  \"TARGET_FPU\"\n+  \"*\n+{\n+  cc_status.flags = CC_IN_FPU;\n+  return \\\"ftst.s %0\\\";\n+}\")\n+\n+\n+(define_insn \"tstdf\"\n+  [(set (cc0)\n+\t(match_operand:DF 0 \"general_operand\" \"fmF\"))]\n+  \"TARGET_FPU\"\n+  \"*\n+{\n+  cc_status.flags = CC_IN_FPU;\n+  return \\\"ftst.d %0\\\";\n+}\")\n+\f\n+;; compare instructions.\n+\n+;; (operand0 - operand1)\n+(define_insn \"cmpsi\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"ri,rm\")\n+\t\t (match_operand:SI 1 \"general_operand\" \"rm,rmi\")))]\n+  \"\"\n+  \"*\n+{\n+  int signed_flag = my_signed_comp (insn);\n+\n+  if (which_alternative == 0)\n+    {\n+      cc_status.flags |= CC_REVERSED;\n+      if (signed_flag && GET_CODE (operands[0]) == CONST_INT)\n+\t{\n+\t  register rtx xfoo;\n+\t  xfoo = operands[1];\n+\t  operands[0] = operands[1];\n+\t  operands[1] = xfoo;\n+\t  return cmp_imm_word (INTVAL (operands[1]), operands[0]);\n+\t}\n+      if (signed_flag)\n+\treturn \\\"cmp.w %0,%1\\\"; \n+      return \\\"cmpu.w %0,%1\\\"; \n+    }\n+  if (signed_flag)\n+    {\n+      if (GET_CODE (operands[1]) == CONST_INT)\n+\treturn cmp_imm_word (INTVAL (operands[1]), operands[0]);\n+      return \\\"cmp.w %1,%0\\\"; \n+    }\n+  else\n+    return \\\"cmpu.w %1,%0\\\"; \n+}\")\n+\n+(define_insn \"cmphi\"\n+  [(set (cc0)\n+\t(compare (match_operand:HI 0 \"nonimmediate_operand\" \"ri,rm\")\n+\t\t (match_operand:HI 1 \"general_operand\" \"rm,rmi\")))]\n+  \"\"\n+  \"*\n+{\n+  int signed_flag = my_signed_comp (insn);\n+\n+  if (which_alternative == 0)\n+    {\n+      cc_status.flags |= CC_REVERSED;\n+      if (signed_flag)\n+\treturn \\\"cmp.h %0,%1\\\"; \n+      return \\\"cmpu.h %0,%1\\\"; \n+    }\n+  if (signed_flag)\n+    return \\\"cmp.h %1,%0\\\"; \n+  return \\\"cmpu.h %1,%0\\\"; \n+}\")\n+\n+(define_insn \"cmpqi\"\n+  [(set (cc0)\n+\t(compare (match_operand:QI 0 \"nonimmediate_operand\" \"ri,rm\")\n+\t\t (match_operand:QI 1 \"general_operand\" \"rm,rmi\")))]\n+  \"\"\n+  \"*\n+{\n+  int signed_flag = my_signed_comp (insn);\n+\n+  if (which_alternative == 0)\n+    {\n+      cc_status.flags |= CC_REVERSED;\n+      if (signed_flag)\n+\treturn \\\"cmp.b %0,%1\\\"; \n+      return \\\"cmpu.b %0,%1\\\"; \n+    }\n+  if (signed_flag)\n+    return \\\"cmp.b %1,%0\\\"; \n+  return \\\"cmpu.b %1,%0\\\"; \n+}\")\n+\n+\n+(define_insn \"cmpdf\"\n+  [(set (cc0)\n+\t(compare (match_operand:DF 0 \"general_operand\" \"f,mG\")\n+\t\t (match_operand:DF 1 \"general_operand\" \"fmG,f\")))]\n+  \"TARGET_FPU\"\n+  \"*\n+{\n+  cc_status.flags = CC_IN_FPU;\n+\n+  if (FPU_REG_P (operands[0]))\n+    return \\\"fcmp.d %f1,%f0\\\";\n+  cc_status.flags |= CC_REVERSED;\n+  return \\\"fcmp.d %f0,%f1\\\";\n+}\")\n+\n+\n+(define_insn \"cmpsf\"\n+  [(set (cc0)\n+\t(compare (match_operand:SF 0 \"general_operand\" \"f,mG\")\n+\t\t (match_operand:SF 1 \"general_operand\" \"fmG,f\")))]\n+  \"TARGET_FPU\"\n+  \"*\n+{\n+  cc_status.flags = CC_IN_FPU;\n+  if (FPU_REG_P (operands[0]))\n+    return \\\"fcmp.s %f1,%0\\\";\n+  cc_status.flags |= CC_REVERSED;\n+  return \\\"fcmp.s %f0,%1\\\";\n+}\")\n+\f\n+;; Recognizers for btst instructions.\n+\n+(define_insn \"\"\n+  [(set (cc0) (zero_extract (match_operand:QI 0 \"nonimmediate_operand\" \"rm\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (match_operand:SI 1 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"btst %1.w,%0.b\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (zero_extract (match_operand:HI 0 \"nonimmediate_operand\" \"rm\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (match_operand:SI 1 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"btst %1.w,%0.h\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (zero_extract (match_operand:SI 0 \"nonimmediate_operand\" \"rm\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (match_operand:SI 1 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"btst %1.w,%0.w\")\n+\n+;; The following two patterns are like the previous two\n+;; except that they use the fact that bit-number operands (offset)\n+;; are automatically masked to 3 or 5 bits when the base is a register.\n+\n+(define_insn \"\"\n+  [(set (cc0) (zero_extract (match_operand:QI 0 \"nonimmediate_operand\" \"r\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (and:SI\n+\t\t\t       (match_operand:SI 1 \"general_operand\" \"rmi\")\n+\t\t\t       (const_int 7))))]\n+  \"\"\n+  \"btst %1.w,%0.b\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (zero_extract (match_operand:SI 0 \"nonimmediate_operand\" \"r\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (and:SI\n+\t\t\t       (match_operand:SI 1 \"general_operand\" \"rmi\")\n+\t\t\t       (const_int 31))))]\n+  \"\"\n+  \"btst %1.w,%0.w\")\n+\n+; More various size-patterns are allowed for btst, but not\n+; included yet.  M.Yuhara\n+\n+\n+(define_insn \"\"\n+  [(set (cc0) (and:SI (sign_extend:SI (sign_extend:HI (match_operand:QI 0 \"nonimmediate_operand\" \"rm\")))\n+\t\t      (match_operand:SI 1 \"general_operand\" \"i\")))]\n+  \"(GET_CODE (operands[1]) == CONST_INT\n+    && (unsigned) INTVAL (operands[1]) < 0x100\n+    && exact_log2 (INTVAL (operands[1])) >= 0)\"\n+  \"*\n+{\n+  register int log = exact_log2 (INTVAL (operands[1]));\n+  operands[1] = gen_rtx (CONST_INT, VOIDmode, log);\n+  return \\\"btst %1,%0.b\\\";\n+}\")\n+\n+; I can add more patterns like above. But not yet.  M.Yuhara\n+\n+\n+; mtst is supported only by G/300.\n+\n+(define_insn \"\"\n+  [(set (cc0) \n+\t(and:SI (match_operand:SI 0 \"general_operand\" \"%rmi\")\n+\t\t(match_operand:SI 1 \"general_operand\" \"rm\")))]\n+  \"TARGET_G300\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == CONST_INT)\n+    return \\\"mtst.w %0,%1\\\";\n+  return \\\"mtst.w %1,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0) \n+\t(and:HI (match_operand:HI 0 \"general_operand\" \"%rmi\")\n+\t\t(match_operand:HI 1 \"general_operand\" \"rm\")))]\n+  \"TARGET_G300\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == CONST_INT)\n+    return \\\"mtst.h %0,%1\\\";\n+  return \\\"mtst.h %1,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0) \n+\t(and:QI (match_operand:QI 0 \"general_operand\" \"%rmi\")\n+\t\t(match_operand:QI 1 \"general_operand\" \"rm\")))]\n+  \"TARGET_G300\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == CONST_INT)\n+    return \\\"mtst.b %0,%1\\\";\n+  return \\\"mtst.b %1,%0\\\";\n+}\")\n+\n+\n+\f\n+;; move instructions\n+\n+/* added by M.Yuhara */\n+;; 1.35.04 89.08.28 modification start\n+;; register_operand -> general_operand\n+;; ashift -> mult \n+\n+(define_insn \"\"\n+  [(set (mem:SI (plus:SI\n+\t\t  (match_operand:SI 0 \"general_operand\" \"r\")\n+\t\t  (ashift:SI\n+\t\t      (match_operand:SI 1 \"general_operand\" \"r\")\n+\t\t      (const_int 2))))\n+\t(match_operand:SI 2 \"general_operand\" \"rmi\"))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"mov.w %2,@(%0:b,%1*4)\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (mem:SI (plus:SI\n+\t\t  (ashift:SI\n+\t\t      (match_operand:SI 0 \"general_operand\" \"r\")\n+\t\t      (const_int 2))\n+\t\t  (match_operand:SI 1 \"general_operand\" \"r\")))\n+\t(match_operand:SI 2 \"general_operand\" \"rmi\"))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"mov.w %2,@(%1:b,%0*4)\\\";\n+}\")\n+\n+\n+(define_insn \"\"\n+  [(set (mem:SI (plus:SI\n+\t\t  (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t  (mult:SI\n+\t\t      (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t      (const_int 4))))\n+\t(match_operand:SI 2 \"general_operand\" \"rmi\"))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"mov.w %2,@(%0:b,%1*4)\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (mem:SI (plus:SI\n+\t\t  (mult:SI\n+\t\t      (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t      (const_int 4))\n+\t\t  (match_operand:SI 1 \"register_operand\" \"r\")))\n+\t(match_operand:SI 2 \"general_operand\" \"rmi\"))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"mov.w %2,@(%1:b,%0*4)\\\";\n+}\")\n+\n+\n+(define_insn \"\"\n+  [(set (mem:SI (plus:SI\n+\t\t  (match_operand:SI 0 \"general_operand\" \"r\")\n+\t\t  (plus:SI\n+\t\t      (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t      (match_operand:SI 2 \"register_operand\" \"i\"))))\n+\t(match_operand:SI 3 \"general_operand\" \"rmi\"))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"mov.w %3,@(%c2,%0,%1)\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (mem:SI (plus:SI\n+\t\t  (plus:SI\n+\t\t      (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t      (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t  (match_operand:SI 2 \"general_operand\" \"i\")))\n+\t(match_operand:SI 3 \"general_operand\" \"rmi\"))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"mov.w %3,@(%c2,%0,%1)\\\";\n+}\")\n+\n+\n+(define_insn \"\"\n+  [(set (mem:SI (plus:SI\n+\t\t  (match_operand:SI 0 \"general_operand\" \"i\")\n+\t\t  (plus:SI\n+\t\t      (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t      (mult:SI\n+\t\t\t  (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t  (const_int 4)))))\n+\t(match_operand:SI 3 \"general_operand\" \"rmi\"))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"mov.w %3,@(%1:b,%0,%2*4)\\\";\n+}\")\n+\n+;; 89.08.28 1.35.04 modification end\n+\n+;; Should add \"!\" to op2 ??\n+\n+;; General move-address-to-operand should handle these.\n+;; If that does not work, please figure out why.\n+\n+;(define_insn \"\"\n+;  [(set (match_operand:SI 0 \"push_operand\" \"=m\")\n+;\t(plus:SI\n+;\t    (match_operand:SI 1 \"immediate_operand\" \"i\")\n+;\t    (match_operand:SI 2 \"general_operand\" \"r\")))]\n+;  \"\"\n+;  \"mova.w @(%c1,%2),%-\")\n+\n+;(define_insn \"\"\n+;  [(set (match_operand:SI 0 \"push_operand\" \"=m\")\n+;\t(plus:SI\n+;\t    (match_operand:SI 1 \"general_operand\" \"r\")\n+;\t    (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+;  \"\"\n+;  \"mova.w @(%c2,%1),%-\")\n+\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=m\")\n+\t(minus:SI\n+\t    (match_operand:SI 1 \"general_operand\" \"r\")\n+\t    (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"mova.w @(%n2,%1),%-\")\n+\n+\n+\n+;; General case of fullword move.\n+\n+(define_insn \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(match_operand:SI 1 \"general_operand\" \"rmi\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    return mov_imm_word (INTVAL (operands[1]), operands[0]);\n+  /* if (address_operand (operands[1], SImode))\n+     return \\\"mova.w %1,%0\\\"; */\n+  if (push_operand (operands[0], SImode))\n+    return \\\"mov.w %1,%-\\\";\n+  return \\\"mov.w %1,%0\\\";\n+}\")\n+\n+/* pushsi 89.08.10 for test M.Yuhara */\n+/*\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=m\")\n+\t(match_operand:SI 1 \"general_operand\" \"rmi\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    return mov_imm_word (INTVAL (operands[1]), operands[0]);\n+  if (push_operand (operands[0], SImode))\n+    return \\\"mov.w %1,%-\\\";\n+  return \\\"mov.w %1,%0\\\";\n+}\")\n+*/\n+\n+\n+(define_insn \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(match_operand:HI 1 \"general_operand\" \"rmi\"))]\n+  \"\"\n+  \"*\n+{\n+  if (push_operand (operands[0], SImode))\n+    return \\\"mov.h %1,%-\\\";\n+  return \\\"mov.h %1,%0\\\";\n+}\")\n+\n+;; Is the operand constraint \"+\" necessary ????\n+;; Should I check push_operand ????\n+\n+(define_insn \"movstricthi\"\n+  [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+rm\"))\n+\t(match_operand:HI 1 \"general_operand\" \"rmi\"))]\n+  \"\"\n+  \"mov.h %1,%0\");\n+\n+(define_insn \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(match_operand:QI 1 \"general_operand\" \"rmi\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GREG_P (operands[0]))\n+    {\n+      if (CONSTANT_P (operands[1]))\n+\treturn \\\"mov:l %1,%0.w\\\";\n+      else\n+\treturn \\\"mov:l %1.b,%0.w\\\";\n+    }\n+  if (GREG_P (operands[1]))\n+    return \\\"mov:s %1.w,%0.b\\\";\n+  return \\\"mov.b %1,%0\\\";\n+}\")\n+\n+(define_insn \"movstrictqi\"\n+  [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+rm\"))\n+\t(match_operand:QI 1 \"general_operand\" \"rmi\"))]\n+  \"\"\n+  \"mov.b %1,%0\")\n+\n+\n+(define_insn \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=f,mf,rm,fr\")\n+\t(match_operand:SF 1 \"general_operand\" \"mfF,f,rmF,fr\"))]\n+  \"\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\treturn output_move_const_single (operands);\n+      return \\\"fmov.s %1,%0\\\";\n+    case 1:\n+      return \\\"fmov.s %1,%0\\\";\n+    case 2:\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\treturn output_move_const_single (operands);\n+      return \\\"mov.w %1,%0\\\";\n+    case 3:\n+      if (FPU_REG_P (operands[0]))\n+\treturn \\\"mov.w %1,%-\\\\n\\\\tfmov.s %+,%0\\\";\n+      return \\\"fmov.s %1,%-\\\\n\\\\tmov.w %+,%0\\\";\n+    }\n+}\")\n+\n+(define_insn \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=f,mf,rm,fr\")\n+\t(match_operand:DF 1 \"general_operand\" \"mfF,f,rmF,fr\"))]\n+  \"\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\treturn output_move_const_double (operands);\n+      return \\\"fmov.d %1,%0\\\";\n+    case 1:\n+      return \\\"fmov.d %1,%0\\\";\n+    case 2:\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\treturn output_move_const_double (operands);\n+      return output_move_double (operands);\n+    case 3:\n+      if (FPU_REG_P (operands[0]))\n+\t{\n+\t  rtx xoperands[2];\n+\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t  output_asm_insn (\\\"mov.w %1,%-\\\", xoperands);\n+\t  output_asm_insn (\\\"mov.w %1,%-\\\", operands);\n+\t  return \\\"fmov.d %+,%0\\\";\n+\t}\n+      else\n+\t{\n+\t  output_asm_insn (\\\"fmov.d %f1,%-\\\", operands);\n+\t  output_asm_insn (\\\"mov.w %+,%0\\\", operands);\n+\t  operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  return \\\"mov.w %+,%0\\\";\n+\t}\n+    }\n+}\")\n+\n+\n+;; movdi can apply to fp regs in some cases\n+;; Must check again.  you can use fsti/fldi, etc.\n+;; FPU reg should be included ??\n+;; 89.12.13 for test\n+\n+(define_insn \"movdi\"\n+  ;; Let's see if it really still needs to handle fp regs, and, if so, why.\n+  [(set (match_operand:DI 0 \"general_operand\" \"=rm,&r,&ro\")\n+\t(match_operand:DI 1 \"general_operand\" \"rF,m,roiF\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FPU_REG_P (operands[0]))\n+    {\n+      if (FPU_REG_P (operands[1]))\n+\treturn \\\"fmov.d %1,%0\\\";\n+      if (REG_P (operands[1]))\n+\t{\n+\t  rtx xoperands[2];\n+\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t  output_asm_insn (\\\"mov.w %1,%-\\\", xoperands);\n+\t  output_asm_insn (\\\"mov.w %1,%-\\\", operands);\n+\t  return \\\"fmov.d %+,%0\\\";\n+\t}\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\treturn output_move_const_double (operands);\n+      return \\\"fmov.d %f1,%0\\\";\n+    }\n+  else if (FPU_REG_P (operands[1]))\n+    {\n+      if (REG_P (operands[0]))\n+\t{\n+\t  output_asm_insn (\\\"fmov.d %f1,%-\\;mov.w %+,%0\\\", operands);\n+\t  operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  return \\\"mov.w %+,%0\\\";\n+\t}\n+      else\n+        return \\\"fmov.d %f1,%0\\\";\n+    }\n+  return output_move_double (operands);\n+}\n+\")\n+\n+\n+;; The definition of this insn does not really explain what it does,\n+;; but it should suffice\n+;; that anything generated as this insn will be recognized as one\n+;; and that it won't successfully combine with anything.\n+\n+;; This is dangerous when %0 and %1 overlapped !!!!!\n+;; Ugly code...\n+\n+(define_insn \"movstrhi\"\n+  [(set (match_operand:BLK 0 \"general_operand\" \"=m\")\n+\t(match_operand:BLK 1 \"general_operand\" \"m\"))\n+   (use (match_operand:HI 2 \"general_operand\" \"rmi\"))\n+   (clobber (reg:SI 0))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))]\n+  \"\"\n+  \"*\n+{\n+  int op2const;\n+  rtx tmpx;\n+\n+  if (CONSTANT_P (operands[1]))\n+    {\n+      fprintf (stderr, \\\"smov 1 const err \\\");\n+      abort ();\n+    }\n+  else if (GET_CODE (operands[1]) == REG)\n+    {\n+      fprintf (stderr, \\\"smov 1 reg err \\\");\n+      abort ();\n+    }\n+  else if (GET_CODE (operands[1]) == MEM)\n+    {\n+      tmpx = XEXP (operands[1], 0);\n+      if (CONSTANT_ADDRESS_P (tmpx) || GREG_P (tmpx))\n+\t{\n+\t  operands[1] = tmpx;\n+\t  output_asm_insn (\\\"mov.w %1,r0\\\", operands);\n+\t}\n+      else\n+\t{\n+\t  output_asm_insn (\\\"mova %1,r0\\\", operands);\n+\t}\n+    }\n+  else\n+    {\n+      fprintf (stderr, \\\"smov 1 else err \\\");\n+      abort ();\n+      output_asm_insn (\\\"mova.w %p1,r0\\\", operands);\n+    }\n+    \n+  if (CONSTANT_P (operands[0]))\n+    {\n+      fprintf (stderr, \\\"smov 0 const err \\\");\n+      abort ();\n+    }\n+  else if (GET_CODE (operands[0]) == REG)\n+    {\n+      fprintf (stderr, \\\"smov 0 reg err \\\");\n+      abort ();\n+    }\n+  else if (GET_CODE (operands[0]) == MEM)\n+    {\n+      tmpx = XEXP (operands[0], 0);\n+      if (CONSTANT_ADDRESS_P (tmpx) || GREG_P (tmpx))\n+\t{\n+\t  operands[0] = tmpx;\n+\t  output_asm_insn (\\\"mov.w %0,r1\\\", operands);\n+\t}\n+      else\n+\t{\n+\t  output_asm_insn (\\\"mova %0,r1\\\", operands);\n+\t}\n+    }\n+  else\n+    {\n+      fprintf (stderr, \\\"smov 0 else err \\\");\n+      abort ();\n+    }\n+    \n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      op2const = INTVAL (operands[2]);\n+      if (op2const % 4 != 0)\n+\t{\n+\t  output_asm_insn (\\\"mov.w %2,r2\\\", operands);\n+\t  return \\\"smov/n/f.b\\\";\n+\t}\n+      op2const = op2const / 4;\n+      if (op2const <= 4)\n+\t{\n+\t  if (op2const == 0)\n+\t    abort (0);\n+\t  if (op2const == 1)\n+\t    return \\\"mov.w @r0,@r1\\\";\n+\t  output_asm_insn (\\\"mov.w @r0,@r1\\\", operands);\n+\t  if (op2const == 2)\n+\t    return \\\"mov.w @(4,r0),@(4,r1)\\\";\n+\t  output_asm_insn (\\\"mov.w @(4,r0),@(4,r1)\\\", operands);\n+\t  if (op2const == 3)\n+\t    return \\\"mov.w @(8,r0),@(8,r1)\\\";\n+\t  output_asm_insn (\\\"mov.w @(8,r0),@(8,r1)\\\", operands);\n+\t  return \\\"mov.w @(12,r0),@(12,r1)\\\";\n+\t}\n+\t    \n+      operands[2] =\n+\tgen_rtx (CONST_INT, VOIDmode, op2const);\n+      output_asm_insn (\\\"mov.w %2,r2\\\", operands);\n+      return \\\"smov/n/f.w\\\";\n+    }\n+  else\n+    {\n+      fprintf (stderr, \\\"smov 0 else err \\\");\n+      abort ();\n+      output_asm_insn (\\\"mov %2.h,r2.w\\\", operands);\n+      return \\\"smov/n/f.b\\\";\n+    }\n+\n+}\")\n+\f\n+;; M.Yuhara 89.08.24\n+;; experiment on the built-in strcpy (__builtin_smov)\n+;;\n+;; len = 0 means unknown string length.\n+;;\n+;; mem:SI is dummy. Necessary so as not to be deleted by optimization.\n+;; Use of BLKmode would be better...\n+;;\n+;;\n+(define_insn \"smovsi\"\n+  [(set (mem:SI (match_operand:SI 0 \"general_operand\" \"=rm\"))\n+\t(mem:SI (match_operand:SI 1 \"general_operand\" \"rm\")))\n+   (use (match_operand:SI 2 \"general_operand\" \"i\"))\n+   (clobber (reg:SI 0))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))\n+   (clobber (reg:SI 3))]\n+  \"\"\n+  \"*\n+{\n+  int len, wlen, blen, offset;\n+  char tmpstr[128];\n+  rtx xoperands[1];\n+\n+  len = INTVAL (operands[2]);\n+  output_asm_insn (\\\"mov.w %1,r0\\\\t; begin built-in strcpy\\\", operands);\n+  output_asm_insn (\\\"mov.w %0,r1\\\", operands);\n+\n+  if (len == 0)\n+    {\n+      output_asm_insn (\\\"mov:z.w #0,r2\\\", operands);\n+      output_asm_insn (\\\"mov:z.w #0,r3\\\", operands);\n+      return \\\"smov/eq/f.b\\\\t; end built-in strcpy\\\";\n+    }\n+\n+  wlen = len / 4;\n+  blen = len - wlen * 4;\n+\n+  if (wlen > 0)\n+    {\n+      if (len <= 40 && !TARGET_FORCE_SMOV)\n+\t{\n+\t  output_asm_insn (\\\"mov.w @r0,@r1\\\", operands);\n+\t  offset = 4;\n+\t  while ( (blen = len - offset) > 0)\n+\t    {\n+\t      if (blen >= 4)\n+\t\t{\n+\t\t  sprintf (tmpstr, \\\"mov.w @(%d,r0),@(%d,r1)\\\",\n+\t\t\t   offset, offset);\n+\t\t  output_asm_insn (tmpstr, operands);\n+\t\t  offset += 4;\n+\t\t}\n+\t      else if (blen >= 2)\n+\t\t{\n+\t\t  sprintf (tmpstr, \\\"mov.h @(%d,r0),@(%d,r1)\\\",\n+\t\t\t   offset, offset);\n+\t\t  output_asm_insn (tmpstr, operands);\n+\t\t  offset += 2;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  sprintf (tmpstr, \\\"mov.b @(%d,r0),@(%d,r1)\\\",\n+\t\t\t   offset, offset);\n+\t\t  output_asm_insn (tmpstr, operands);\n+\t\t  offset++;\n+\t\t}\n+\t    }\n+\t  return \\\"\\\\t\\\\t; end built-in strcpy\\\";\n+\t}\n+      else\n+\t{\n+\t  xoperands[0] = gen_rtx (CONST_INT, VOIDmode, wlen);\n+\t  output_asm_insn (\\\"mov.w %0,r2\\\", xoperands);\n+\t  output_asm_insn (\\\"smov/n/f.w\\\", operands);\n+\t}\n+    }\n+\n+  if (blen >= 2)\n+    {\n+      output_asm_insn (\\\"mov.h @r0,@r1\\\", operands);\n+      if (blen == 3)\n+\toutput_asm_insn (\\\"mov.b @(2,r0),@(2,r1)\\\", operands);\n+    }\n+  else if (blen == 1)\n+    {\n+      output_asm_insn (\\\"mov.b @r0,@r1\\\", operands);\n+    }\n+\n+  return \\\"\\\\t\\\\t; end built-in strcpy\\\";\n+}\")\n+\f\n+;; truncation instructions\n+(define_insn \"truncsiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(truncate:QI\n+\t (match_operand:SI 1 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"mov %1.w,%0.b\")\n+;  \"*\n+;{\n+;  if (GET_CODE (operands[0]) == REG)\n+;    return \\\"mov.w %1,%0\\\";\n+;  if (GET_CODE (operands[1]) == MEM)\n+;    operands[1] = adj_offsettable_operand (operands[1], 3);\n+;  return \\\"mov.b %1,%0\\\";\n+;}\")\n+\n+(define_insn \"trunchiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(truncate:QI\n+\t (match_operand:HI 1 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"mov %1.h,%0.b\")\n+;  \"*\n+;{\n+;  if (GET_CODE (operands[0]) == REG)\n+;    return \\\"mov.h %1,%0\\\";\n+;  if (GET_CODE (operands[1]) == MEM)\n+;    operands[1] = adj_offsettable_operand (operands[1], 1);\n+;  return \\\"mov.b %1,%0\\\";\n+;}\")\n+\n+(define_insn \"truncsihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(truncate:HI\n+\t (match_operand:SI 1 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"mov %1.w,%0.h\")\n+;  \"*\n+;{\n+;  if (GET_CODE (operands[0]) == REG)\n+;    return \\\"mov.w %1,%0\\\";\n+;  if (GET_CODE (operands[1]) == MEM)\n+;    operands[1] = adj_offsettable_operand (operands[1], 2);\n+;  return \\\"mov.h %1,%0\\\";\n+;}\")\n+\f\n+;; zero extension instructions\n+;; define_expand (68k) -> define_insn (Gmicro)\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+        (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"rm\")))]\n+  \"\"\n+  \"movu %1.h,%0.w\")\n+\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+        (zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"rm\")))]\n+  \"\"\n+  \"movu %1.b,%0.h\")\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+        (zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"rm\")))]\n+  \"\"\n+  \"movu %1.b,%0.w\")\n+\n+\f\n+;; sign extension instructions\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+        (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"rm\")))]\n+  \"\"\n+  \"mov %1.h,%0.w\")\n+\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+        (sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"rm\")))]\n+  \"\"\n+  \"mov %1.b,%0.h\")\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+        (sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"rm\")))]\n+  \"\"\n+  \"mov %1.b,%0.w\")\n+\n+\n+\f\n+;; Conversions between float and double.\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=*frm,f\")\n+\t(float_extend:DF\n+\t  (match_operand:SF 1 \"general_operand\" \"f,rmF\")))]\n+  \"TARGET_FPU\"\n+  \"*\n+{\n+  if (FPU_REG_P (operands[0]))\n+    {\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\treturn output_move_const_double (operands);\n+      if (GREG_P (operands[1]))\n+\t{\n+\t  output_asm_insn (\\\"mov.w %1,%-\\\", operands);\n+\t  return \\\"fmov %+.s,%0.d\\\";\n+\t}\n+      return \\\"fmov %1.s,%0.d\\\";\n+    }\n+  else\n+    {\n+      if (GREG_P (operands[0]))\n+\t{\n+\t  output_asm_insn (\\\"fmov %1.s,%-.d\\\", operands);\n+\t  output_asm_insn (\\\"mov.w %+,%0\\\", operands);\n+\t  operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  return \\\"mov.w %+,%0\\\";\n+\t}\n+      return \\\"fmov %1.s,%0.d\\\";\n+    }\n+}\")\n+\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=rfm\")\n+\t(float_truncate:SF\n+\t  (match_operand:DF 1 \"general_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"*\n+{\n+  if (GREG_P (operands[0]))\n+    {\n+      output_asm_insn (\\\"fmov %1.d,%-.s\\\", operands);\n+      return \\\"mov.w %+,%0\\\";\n+    }\n+  return \\\"fmov %1.d,%0.s\\\";\n+}\")\n+\f\n+;; Conversion between fixed point and floating point.\n+;; Note that among the fix-to-float insns\n+;; the ones that start with SImode come first.\n+;; That is so that an operand that is a CONST_INT\n+;; (and therefore lacks a specific machine mode).\n+;; will be recognized as SImode (which is always valid)\n+;; rather than as QImode or HImode.\n+\n+\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n+\t(float:SF (match_operand:SI 1 \"general_operand\" \"rmi\")))]\n+  \"TARGET_FPU\"\n+  \"fldi %1.w,%0.s\")\n+\n+(define_insn \"floatsidf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n+\t(float:DF (match_operand:SI 1 \"general_operand\" \"rmi\")))]\n+  \"TARGET_FPU\"\n+  \"fldi %1.w,%0.d\")\n+\n+(define_insn \"floathisf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n+\t(float:SF (match_operand:HI 1 \"general_operand\" \"rmi\")))]\n+  \"TARGET_FPU\"\n+  \"fldi %1.h,%0.s\")\n+\n+(define_insn \"floathidf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n+\t(float:DF (match_operand:HI 1 \"general_operand\" \"rmi\")))]\n+  \"TARGET_FPU\"\n+  \"fldi %1.h,%0.d\")\n+\n+(define_insn \"floatqisf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n+\t(float:SF (match_operand:QI 1 \"general_operand\" \"rmi\")))]\n+  \"TARGET_FPU\"\n+  \"fldi %1.b,%0.s\")\n+\n+(define_insn \"floatqidf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n+\t(float:DF (match_operand:QI 1 \"general_operand\" \"rmi\")))]\n+  \"TARGET_FPU\"\n+  \"fldi %1.b,%0.d\")\n+\n+;;; Convert a float to a float whose value is an integer.\n+;;; This is the first stage of converting it to an integer type.\n+;\n+;(define_insn \"ftruncdf2\"\n+;  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n+;\t(fix:DF (match_operand:DF 1 \"general_operand\" \"fFm\")))]\n+;  \"TARGET_FPU\"\n+;  \"*\n+;{\n+;  return \\\"fintrz.d %f1,%0\\\";\n+;}\")\n+;\n+;(define_insn \"ftruncsf2\"\n+;  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n+;\t(fix:SF (match_operand:SF 1 \"general_operand\" \"fFm\")))]\n+;  \"TARGET_FPU\"\n+;  \"*\n+;{\n+;  return \\\"fintrz.s %f1,%0\\\";\n+;}\")\n+\n+;; Convert a float to an integer.\n+\n+(define_insn \"fix_truncsfqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(fix:QI (fix:SF (match_operand:SF 1 \"general_operand\" \"f\"))))]\n+  \"TARGET_FPU\"\n+  \"fsti %1.s,%0.b\")\n+\n+(define_insn \"fix_truncsfhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(fix:HI (fix:SF (match_operand:SF 1 \"general_operand\" \"f\"))))]\n+  \"TARGET_FPU\"\n+  \"fsti %1.s,%0.h\")\n+\n+(define_insn \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(fix:SI (fix:SF (match_operand:SF 1 \"general_operand\" \"f\"))))]\n+  \"TARGET_FPU\"\n+  \"fsti %1.s,%0.w\")\n+\n+(define_insn \"fix_truncdfqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(fix:QI (fix:DF (match_operand:DF 1 \"general_operand\" \"f\"))))]\n+  \"TARGET_FPU\"\n+  \"fsti %1.d,%0.b\")\n+\n+(define_insn \"fix_truncdfhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(fix:HI (fix:DF (match_operand:DF 1 \"general_operand\" \"f\"))))]\n+  \"TARGET_FPU\"\n+  \"fsti %1.d,%0.h\")\n+\n+(define_insn \"fix_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(fix:SI (fix:DF (match_operand:DF 1 \"general_operand\" \"f\"))))]\n+  \"TARGET_FPU\"\n+  \"fsti %1.d,%0.w\")\n+\n+\f\n+;;; Special add patterns\n+;;; 89.09.28\n+\n+;; This should be redundant; please find out why regular addsi3\n+;; fails to match this case.\n+\n+;(define_insn \"\"\n+;  [(set (mem:SI (plus:SI\n+;\t\t    (plus:SI (match_operand 0 \"general_operand\" \"r\")\n+;\t\t\t     (match_operand 1 \"general_operand\" \"r\"))\n+;\t\t    (match_operand 2 \"general_operand\" \"i\")))\n+;\t(plus:SI\n+;\t    (mem:SI (plus:SI\n+;\t\t\t(plus:SI (match_dup 0)\n+;\t\t\t\t (match_dup 1))\n+;\t\t\t(match_dup 2)))\n+;\t    (match_operand 3 \"general_operand\" \"rmi\")))]\n+;  \"\"\n+;  \"add.w %3,@(%c2,%0,%1)\")\n+\n+\f\n+;; add instructions\n+\n+;; Note that the last two alternatives are near-duplicates\n+;; in order to handle insns generated by reload.\n+;; This is needed since they are not themselves reloaded,\n+;; so commutativity won't apply to them.\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm,!r,!r\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,r,ri\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"rmi,ri,r\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    {\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+\t{\n+\t  operands[1] = operands[2];\n+\t  return add_imm_word (INTVAL (operands[1]), operands[0], &operands[1]);\n+\t}\n+      else\n+\treturn \\\"add.w %2,%0\\\";\n+    }\n+  else\n+    {\n+      if (GET_CODE (operands[1]) == REG\n+\t  && REGNO (operands[0]) == REGNO (operands[1]))\n+\treturn \\\"add.w %2,%0\\\";\n+      if (GET_CODE (operands[2]) == REG\n+\t  && REGNO (operands[0]) == REGNO (operands[2]))\n+\treturn \\\"add.w %1,%0\\\";\n+\n+      if (GET_CODE (operands[1]) == REG)\n+\t{\n+\t  if (GET_CODE (operands[2]) == REG)\n+\t    return \\\"mova.w @(%1,%2),%0\\\";\n+\t  else\n+\t    return \\\"mova.w @(%c2,%1),%0\\\";\n+\t}\n+      else\n+\treturn \\\"mova.w @(%c1,%2),%0\\\";\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t (sign_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"rmi\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (CONSTANT_P (operands[2]))\n+    {\n+      operands[1] = operands[2];\n+      return add_imm_word (INTVAL (operands[1]), operands[0], &operands[1]);\n+    }\n+  else\n+    return \\\"add %2.h,%0.w\\\";\n+}\")\n+\n+(define_insn \"addhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(plus:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) < 0)\n+    return \\\"sub.h #%n2,%0\\\";\n+  if (GREG_P (operands[0]))\n+    {\n+      if (CONSTANT_P (operands[2]))\n+\treturn \\\"add:l %2,%0.w\\\";\n+      else\n+\treturn \\\"add:l %2.h,%0.w\\\";\n+    }\n+  return \\\"add.h %2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+rm\"))\n+\t(plus:HI (match_dup 0)\n+\t\t (match_operand:HI 1 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"add.h %1,%0\")\n+\n+(define_insn \"addqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(plus:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) < 0)\n+    return \\\"sub.b #%n2,%0\\\";\n+  if (GREG_P (operands[0]))\n+    {\n+      if (CONSTANT_P (operands[2]))\n+\treturn \\\"add:l %2,%0.w\\\";\n+      else\n+\treturn \\\"add:l %2.b,%0.w\\\";\n+    }\n+  return \\\"add.b %2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+rm\"))\n+\t(plus:QI (match_dup 0)\n+\t\t (match_operand:QI 1 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"add.b %1,%0\")\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n+\t(plus:DF (match_operand:DF 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:DF 2 \"general_operand\" \"fmG\")))]\n+  \"TARGET_FPU\"\n+  \"fadd.d %f2,%0\")\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n+\t(plus:SF (match_operand:SF 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:SF 2 \"general_operand\" \"fmG\")))]\n+  \"TARGET_FPU\"\n+  \"fadd.s %f2,%0\")\n+\f\n+;; subtract instructions\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm,!r\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,r\")\n+\t\t  (match_operand:SI 2 \"general_operand\" \"rmi,i\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0\n+      || (GET_CODE (operands[1]) == REG\n+\t  && REGNO (operands[0]) == REGNO (operands[1])))\n+    {\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+\t{\n+\t  operands[1] = operands[2];\n+\t  return sub_imm_word (INTVAL (operands[1]),\n+\t\t\t       operands[0], &operands[1]);\n+\t}\n+      else\n+\treturn \\\"sub.w %2,%0\\\";\n+    }\n+  else\n+    return \\\"mova.w @(%n2,%1),%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t  (sign_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"rmi\"))))]\n+  \"\"\n+  \"sub %2.h,%0.w\")\n+\n+(define_insn \"subhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t  (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) < 0\n+      && INTVAL (operands[2]) != 0x8000)\n+    return \\\"add.h #%n2,%0\\\";\n+  return \\\"sub.h %2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+rm\"))\n+\t(minus:HI (match_dup 0)\n+\t\t  (match_operand:HI 1 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"sub.h %1,%0\")\n+\n+(define_insn \"subqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(minus:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t  (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) < 0\n+      && INTVAL (operands[2]) != 0x80)\n+    return \\\"add.b #%n2,%0\\\";\n+  return \\\"sub.b %2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+rm\"))\n+\t(minus:QI (match_dup 0)\n+\t\t  (match_operand:QI 1 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"sub.b %1,%0\")\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n+\t(minus:DF (match_operand:DF 1 \"general_operand\" \"0\")\n+\t\t  (match_operand:DF 2 \"general_operand\" \"fmG\")))]\n+  \"TARGET_FPU\"\n+  \"fsub.d %f2,%0\")\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n+\t(minus:SF (match_operand:SF 1 \"general_operand\" \"0\")\n+\t\t  (match_operand:SF 2 \"general_operand\" \"fmG\")))]\n+  \"TARGET_FPU\"\n+  \"fsub.s %f2,%0\")\n+\n+\f\n+;; multiply instructions\n+\n+(define_insn \"mulqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(mult:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"mul.b %2,%0\")\n+\n+\n+(define_insn \"mulhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(mult:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"mul.h %2,%0\")\n+\n+;; define_insn \"mulhisi3\"\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(mult:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"mul.w %2,%0\")\n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n+\t(mult:DF (match_operand:DF 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:DF 2 \"general_operand\" \"fmG\")))]\n+  \"TARGET_FPU\"\n+  \"fmul.d %f2,%0\")\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n+\t(mult:SF (match_operand:SF 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:SF 2 \"general_operand\" \"fmG\")))]\n+  \"TARGET_FPU\"\n+  \"fmul.s %f2,%0\")\n+\n+\f\n+;; divide instructions\n+\n+(define_insn \"divqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(div:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"div.b %2,%0\")\n+\n+(define_insn \"divhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(div:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"div.h %2,%0\")\n+\n+(define_insn \"divhisi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n+\t(div:HI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"div %2.h,%0.w\")\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"div.w %2,%0\")\n+\n+(define_insn \"udivqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(udiv:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"divu.b %2,%0\")\n+\n+(define_insn \"udivhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(udiv:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"divu.h %2,%0\")\n+\n+(define_insn \"udivhisi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n+\t(udiv:HI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"divu %2.h,%0.w\")\n+\n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(udiv:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"divu.w %2,%0\")\n+\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n+\t(div:DF (match_operand:DF 1 \"general_operand\" \"0\")\n+\t\t(match_operand:DF 2 \"general_operand\" \"fmG\")))]\n+  \"TARGET_FPU\"\n+  \"fdiv.d %f2,%0\")\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n+\t(div:SF (match_operand:SF 1 \"general_operand\" \"0\")\n+\t\t(match_operand:SF 2 \"general_operand\" \"fmG\")))]\n+  \"TARGET_FPU\"\n+  \"fdiv.s %f2,%0\")\n+\f\n+;; Remainder instructions.\n+\n+(define_insn \"modqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(mod:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"rem.b %2,%0\")\n+\n+(define_insn \"modhisi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n+\t(mod:HI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"rem.h %2,%0\")\n+\n+(define_insn \"umodqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(umod:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"remu.b %2,%0\")\n+\n+(define_insn \"umodhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(umod:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"remu.h %2,%0\")\n+\n+(define_insn \"umodhisi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n+\t(umod:HI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"remu %2.h,%0.w\")\n+\n+;; define_insn \"divmodsi4\"\n+\n+(define_insn \"udivmodsi4\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(udiv:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"rmi\")))\n+   (set (match_operand:SI 3 \"general_operand\" \"=r\")\n+\t(umod:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"mov.w #0,%3;divx.w %2,%0,%3\")\n+\f\n+;; logical-and instructions\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(and:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && (INTVAL (operands[2]) | 0xffff) == 0xffffffff\n+      && (GREG_P (operands[0])\n+\t  || offsettable_memref_p (operands[0])))\n+   \n+    { \n+      if (GET_CODE (operands[0]) != REG)\n+        operands[0] = adj_offsettable_operand (operands[0], 2);\n+      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t     INTVAL (operands[2]) & 0xffff);\n+      /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n+      CC_STATUS_INIT;\n+      return \\\"and.h %2,%0\\\";\n+    }\n+  return \\\"and.w %2,%0\\\";\n+}\")\n+\n+(define_insn \"andhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(and:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"and.h %2,%0\")\n+\n+(define_insn \"andqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(and:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"and.b %2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n+\t(and:SI (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"rm\"))\n+\t\t(match_operand:SI 2 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    return \\\"and %1,%0.w\\\";\n+  return \\\"and %1.h,%0.w\\\";\n+}\")\n+\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n+\t(and:SI (zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"rm\"))\n+\t\t(match_operand:SI 2 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    return \\\"and %1,%0.w\\\";\n+  return \\\"and %1.b,%0.w\\\";\n+}\")\n+\f\n+;; inclusive-or instructions\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(ior:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"*\n+{\n+  register int logval;\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) >> 16 == 0\n+      && (GREG_P (operands[0])\n+\t  || offsettable_memref_p (operands[0])))\n+    { \n+      if (GET_CODE (operands[0]) != REG)\n+        operands[0] = adj_offsettable_operand (operands[0], 2);\n+      /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n+      CC_STATUS_INIT;\n+      return \\\"or.h %2,%0\\\";\n+    }\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && (logval = exact_log2 (INTVAL (operands[2]))) >= 0\n+      && (GREG_P (operands[0])\n+\t  || offsettable_memref_p (operands[0])))\n+    { \n+      if (GREG_P (operands[0]))\n+\t{\n+\t  if (logval < 7)\n+\t    {\n+\t      operands[1] = gen_rtx (CONST_INT, VOIDmode, 7 - logval);\n+\t      return \\\"bset.b %1,%0\\\";\n+\t    }\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, 31 - logval);\n+\t  return \\\"bset.w %1,%0\\\";\n+\t}\n+      else\n+        {\n+\t  operands[0] = adj_offsettable_operand (operands[0], 3 - (logval / 8));\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, 7 - (logval % 8));\n+\t}\n+      return \\\"bset.b %1,%0\\\";\n+    }\n+  return \\\"or.w %2,%0\\\";\n+}\")\n+\n+(define_insn \"iorhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(ior:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"or.h %2,%0\")\n+\n+(define_insn \"iorqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(ior:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"or.b %2,%0\")\n+\f\n+;; xor instructions\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(xor:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) >> 16 == 0\n+      && (offsettable_memref_p (operands[0]) || GREG_P (operands[0])))\n+    { \n+      if (! GREG_P (operands[0]))\n+\toperands[0] = adj_offsettable_operand (operands[0], 2);\n+      /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n+      CC_STATUS_INIT;\n+      return \\\"xor.h %2,%0\\\";\n+    }\n+  return \\\"xor.w %2,%0\\\";\n+}\")\n+\n+(define_insn \"xorhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"xor.h %2,%0\")\n+\n+(define_insn \"xorqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(xor:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"xor.b %2,%0\")\n+\f\n+;; negation instructions\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(neg:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"neg.w %0\")\n+\n+(define_insn \"neghi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(neg:HI (match_operand:HI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"neg.h %0\")\n+\n+(define_insn \"negqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(neg:QI (match_operand:QI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"neg.b %0\")\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"f\")\n+\t(neg:SF (match_operand:SF 1 \"general_operand\" \"fmF\")))]\n+  \"TARGET_FPU\"\n+  \"fneg.s %f1,%0\")\n+\n+\n+(define_insn \"negdf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"f\")\n+\t(neg:DF (match_operand:DF 1 \"general_operand\" \"fmF\")))]\n+  \"TARGET_FPU\"\n+  \"fneg.d %f1,%0\")\n+\n+\f\n+;; Absolute value instructions\n+\n+(define_insn \"abssf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"f\")\n+\t(abs:SF (match_operand:SF 1 \"general_operand\" \"fmF\")))]\n+  \"TARGET_FPU\"\n+  \"fabs.s %f1,%0\")\n+\n+(define_insn \"absdf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"f\")\n+\t(abs:DF (match_operand:DF 1 \"general_operand\" \"fmF\")))]\n+  \"TARGET_FPU\"\n+  \"fabs.d %f1,%0\")\n+\n+\f\n+;; one complement instructions\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(not:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"not.w %0\")\n+\n+(define_insn \"one_cmplhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(not:HI (match_operand:HI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"not.h %0\")\n+\n+(define_insn \"one_cmplqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(not:QI (match_operand:QI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"not.b %0\")\n+\f\n+;; Optimized special case of shifting.\n+;; Must precede the general case.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"memory_operand\" \"m\")\n+\t\t     (const_int 24)))]\n+  \"GET_CODE (XEXP (operands[1], 0)) != POST_INC\n+   && GET_CODE (XEXP (operands[1], 0)) != PRE_DEC\"\n+  \"mov:l %1.b,%0.w\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"memory_operand\" \"m\")\n+\t\t     (const_int 24)))]\n+  \"GET_CODE (XEXP (operands[1], 0)) != POST_INC\n+   && GET_CODE (XEXP (operands[1], 0)) != PRE_DEC\"\n+  \"movu %1.b,%0.w\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (compare (match_operand:QI 0 \"general_operand\" \"i\")\n+\t\t       (lshiftrt:SI (match_operand:SI 1 \"memory_operand\" \"m\")\n+\t\t\t\t    (const_int 24))))]\n+  \"(GET_CODE (operands[0]) == CONST_INT\n+    && (INTVAL (operands[0]) & ~0xff) == 0)\"\n+  \"*\n+{\n+  cc_status.flags |= CC_REVERSED;\n+  if (my_signed_comp (insn))\n+    return \\\"cmp.b %0,%1\\\";\n+  return \\\"cmpu.b %0,%1\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (compare (lshiftrt:SI (match_operand:SI 0 \"memory_operand\" \"m\")\n+\t\t\t\t    (const_int 24))\n+\t\t       (match_operand:QI 1 \"general_operand\" \"i\")))]\n+  \"(GET_CODE (operands[1]) == CONST_INT\n+    && (INTVAL (operands[1]) & ~0xff) == 0)\"\n+  \"*\n+  if (my_signed_comp (insn))\n+\treturn \\\"cmp.b %1,%0\\\";\n+  return \\\"cmpu.b %1,%0\\\";\n+\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (compare (match_operand:QI 0 \"general_operand\" \"i\")\n+\t\t       (ashiftrt:SI (match_operand:SI 1 \"memory_operand\" \"m\")\n+\t\t\t\t    (const_int 24))))]\n+  \"(GET_CODE (operands[0]) == CONST_INT\n+    && ((INTVAL (operands[0]) + 0x80) & ~0xff) == 0)\"\n+  \"*\n+  cc_status.flags |= CC_REVERSED;\n+  if (my_signed_comp (insn))\n+\treturn \\\"cmp.b %0,%1\\\";\n+  return \\\"cmpu.b %0,%1\\\";\n+\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (compare (ashiftrt:SI (match_operand:SI 0 \"memory_operand\" \"m\")\n+\t\t\t\t    (const_int 24))\n+\t\t       (match_operand:QI 1 \"general_operand\" \"i\")))]\n+  \"(GET_CODE (operands[1]) == CONST_INT\n+    && ((INTVAL (operands[1]) + 0x80) & ~0xff) == 0)\"\n+  \"*\n+  if (my_signed_comp (insn))\n+\treturn \\\"cmp.b %1,%0\\\";\n+  return \\\"cmpu.b %1,%0\\\";\n+\")\n+\f\n+;; arithmetic shift instructions\n+;; We don't need the shift memory by 1 bit instruction\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"sha.w %2,%0\")\n+\n+(define_insn \"ashlhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"sha.h %2,%0\")\n+\n+(define_insn \"ashlqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(ashift:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"sha.b %2,%0\")\n+\n+;; Arithmetic right shift on the Gmicro works by negating the shift count\n+\n+;; ashiftrt -> ashift\n+(define_expand \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"{ operands[2] = negate_rtx (SImode, operands[2]); }\")\n+\n+;; ashiftrt -> ashift\n+(define_expand \"ashrhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \" { operands[2] = negate_rtx (HImode, operands[2]); }\")\n+\n+;; ashiftrt -> ashift\n+(define_expand \"ashrqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(ashift:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \" { operands[2] = negate_rtx (QImode, operands[2]); }\")\n+\f\n+;; logical shift instructions\n+\n+(define_insn \"lshlsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(lshift:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"shl.w %2,%0\")\n+\n+(define_insn \"lshlhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(lshift:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"shl.h %2,%0\")\n+\n+(define_insn \"lshlqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(lshift:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"shl.b %2,%0\")\n+\n+;; lshiftrt -> lshift\n+(define_expand \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(lshift:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \" { operands[2] = negate_rtx (SImode, operands[2]); }\")\n+\n+;; lshiftrt -> lshift\n+(define_expand \"lshrhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(lshift:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \" { operands[2] = negate_rtx (HImode, operands[2]); }\")\n+\n+;; lshiftrt -> lshift\n+(define_expand \"lshrqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(lshift:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \" { operands[2] = negate_rtx (QImode, operands[2]); }\")\n+\f\n+;; rotate instructions\n+\n+(define_insn \"rotlsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(rotate:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"rol.w %2,%0\")\n+\n+(define_insn \"rotlhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(rotate:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"rol.h %2,%0\")\n+\n+(define_insn \"rotlqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(rotate:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"rol.b %2,%0\")\n+\n+(define_expand \"rotrsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \" { operands[2] = negate_rtx (SImode, operands[2]); }\")\n+\n+(define_expand \"rotrhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n+\t(rotatert:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \" { operands[2] = negate_rtx (HImode, operands[2]); }\")\n+\n+(define_expand \"rotrqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n+\t(rotatert:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \" { operands[2] = negate_rtx (QImode, operands[2]); }\")\n+\f\n+;; Special cases of bit-field insns which we should\n+;; recognize in preference to the general case.\n+;; These handle aligned 8-bit and 16-bit fields,\n+;; which can usually be done with move instructions.\n+\n+;; Should I add  mode_dependent_address_p ????\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+rm\")\n+\t\t\t (match_operand:SI 1 \"immediate_operand\" \"i\")\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"i\"))\n+\t(match_operand:SI 3 \"general_operand\" \"rm\"))]\n+  \"TARGET_BITFIELD\n+   && GET_CODE (operands[1]) == CONST_INT\n+   && (INTVAL (operands[1]) == 8 || INTVAL (operands[1]) == 16)\n+   && GET_CODE (operands[2]) == CONST_INT\n+   && INTVAL (operands[2]) % INTVAL (operands[1]) == 0\n+   && (GET_CODE (operands[0]) != REG\n+       || ( INTVAL (operands[1]) + INTVAL (operands[2]) == 32))\"\n+  \"*\n+{\n+  if (GET_CODE (operands[3]) == MEM)\n+    operands[3] = adj_offsettable_operand (operands[3],\n+\t\t\t\t\t   (32 - INTVAL (operands[1])) / 8);\n+\n+  if (GET_CODE (operands[0]) == REG)\n+    {\n+      if (INTVAL (operands[1]) == 8)\n+\treturn \\\"movu %3.b,%0.w\\\";\n+      return \\\"movu %3.h,%0.w\\\";\n+    }\n+  else\n+    {\n+      operands[0]\n+\t= adj_offsettable_operand (operands[0], INTVAL (operands[2]) / 8);\n+      if (INTVAL (operands[1]) == 8)\n+\treturn \\\"mov.b %3,%0\\\";\n+      return \\\"mov.h %3,%0\\\";\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=&r\")\n+\t(zero_extract:SI (match_operand:SI 1 \"nonimmediate_operand\" \"rm\")\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")\n+\t\t\t (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n+  \"TARGET_BITFIELD\n+   && GET_CODE (operands[2]) == CONST_INT\n+   && (INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n+   && GET_CODE (operands[3]) == CONST_INT\n+   && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\"\n+  \"*\n+{\n+  if (!REG_P (operands[1]))\n+    operands[1]\n+      = adj_offsettable_operand (operands[1], INTVAL (operands[3]) / 8);\n+\n+  if (REG_P (operands[0]))\n+    {\n+      if (REG_P (operands[1]))\n+\t{\n+\t  if (INTVAL (operands[2]) == 8)\n+\t    {\t\t\t/* width == 8 */\n+\t      switch (INTVAL (operands[3]))\n+\t\t{\n+\t\tcase 0:\n+\t\t  return \\\"mov.w %1,%0;shl.w #-24,%0\\\";\n+\t\t  break;\n+\t\tcase 8:\n+\t\t  return \\\"mov.w %1,%0;shl.w #8,%0;shl.w #-24,%0\\\";\n+\t\t  break;\n+\t\tcase 16:\n+\t\t  return \\\"mov.w %1,%0;shl.w #16,%0;shl.w #-24,%0\\\";\n+\t\t  break;\n+\t\tcase 24:\n+\t\t  return \\\"movu %1.b,%0.w\\\";\n+\t\t  break;\n+\t\tdefault:\n+\t\t  myabort (2);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      switch (INTVAL (operands[3]))\n+\t\t{\n+\t\tcase 0:\n+\t\t  return \\\"mov.w %1,%0;shl.w #-16,%0\\\";\n+\t\t  break;\n+\t\tcase 16:\n+\t\t  return \\\"movu %1.h,%0.w\\\";\n+\t\t  break;\n+\t\tdefault:\n+\t\t  myabort (3);\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (INTVAL (operands[2]) == 8)\n+\t    return \\\"movu %1.h,%0.w\\\";\n+\t  else\n+\t    return \\\"movu %1.b,%0.w\\\";\n+\t}\n+    }\n+  else\n+    {\t\t\t\t/* op[0] == MEM */\n+      if (INTVAL (operands[2]) == 8)\n+\treturn \\\"movu %1.b,%0.w\\\";\n+      return \\\"movu %1.h,%0.w\\\";\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n+\t(sign_extract:SI (match_operand:SI 1 \"nonimmediate_operand\" \"ro\")\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")\n+\t\t\t (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n+  \"TARGET_BITFIELD\n+   && GET_CODE (operands[2]) == CONST_INT\n+   && (INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n+   && GET_CODE (operands[3]) == CONST_INT\n+   && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\"\n+  \"*\n+{\n+  if (!REG_P (operands[1]))\n+    operands[1]\n+      = adj_offsettable_operand (operands[1], INTVAL (operands[3]) / 8);\n+\n+  if (REG_P (operands[0]))\n+    {\n+      if (REG_P (operands[1]))\n+\t{\n+\t  if (INTVAL (operands[2]) == 8)\n+\t    {\t\t\t/* width == 8 */\n+\t      switch (INTVAL (operands[3]))\n+\t\t{\n+\t\tcase 0:\n+\t\t  return \\\"mov.w %1,%0;sha.w #-24,%0\\\";\n+\t\t  break;\n+\t\tcase 8:\n+\t\t  return \\\"mov.w %1,%0;shl.w #8,%0;sha.w #-24,%0\\\";\n+\t\t  break;\n+\t\tcase 16:\n+\t\t  return \\\"mov.w %1,%0;shl.w #16,%0;sha.w #-24,%0\\\";\n+\t\t  break;\n+\t\tcase 24:\n+\t\t  return \\\"mov %1.b,%0.w\\\";\n+\t\t  break;\n+\t\tdefault:\n+\t\t  myabort (4);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      switch (INTVAL (operands[3]))\n+\t\t{\n+\t\tcase 0:\n+\t\t  return \\\"mov.w %1,%0;sha.w #-16,%0\\\";\n+\t\t  break;\n+\t\tcase 16:\n+\t\t  return \\\"mov %1.h,%0.w\\\";\n+\t\t  break;\n+\t\tdefault:\n+\t\t  myabort (5);\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (INTVAL (operands[2]) == 8)\n+\t    return \\\"mov %1.h,%0.w\\\";\n+\t  else\n+\t    return \\\"mov %1.b,%0.w\\\";\n+\t}\n+    }\n+  else\n+    {\t\t\t\t/* op[0] == MEM */\n+      if (INTVAL (operands[2]) == 8)\n+\treturn \\\"mov %1.b,%0.w\\\";\n+      return \\\"mov %1.h,%0.w\\\";\n+    }\n+}\")\n+\f\n+;; Bit field instructions, general cases.\n+;; \"o,d\" constraint causes a nonoffsettable memref to match the \"o\"\n+;; so that its address is reloaded.\n+\n+;; extv dest:SI src(:QI/:SI) width:SI pos:SI\n+;;        r.w    m            r.w/#    rmi  \n+;;        %0     %1           %2       %3\n+\n+(define_insn \"extv\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n+\t(sign_extract:SI (match_operand:QI 1 \"nonimmediate_operand\" \"m\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"ri\")\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"rmi\")))]\n+  \"TARGET_BITFIELD\"\n+  \"bfext %3,%2,%1,%0\")\n+\n+\n+(define_insn \"extzv\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n+\t(zero_extract:SI (match_operand:QI 1 \"nonimmediate_operand\" \"m\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"ri\")\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"rmi\")))]\n+  \"TARGET_BITFIELD\"\n+  \"bfextu %3,%2,%1,%0\")\n+\n+;; There is no insn on the Gmicro to NOT/SET/CLR bitfield.\n+\n+\n+;; insv dest(BF):QI/SI  width:SI  pos:SI  src:SI\n+;;        m                r.w      rmi     r.w/i\n+;;        0                1        2       3\n+\n+\n+(define_insn \"insv\"\n+  [(set (zero_extract:SI (match_operand:QI 0 \"nonimmediate_operand\" \"+m,m\")\n+\t\t\t (match_operand:SI 1 \"general_operand\" \"r,i\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"rmi,i\"))\n+\t(match_operand:SI 3 \"general_operand\" \"ri,ri\"))]\n+  \"TARGET_BITFIELD\"\n+  \"bfinsu %3,%2,%1,%0\")\n+;;; bfins/bfinsu ????????\n+\n+;; == == == == == == == == == == == == == \n+\n+;; Now recognize bit field insns that operate on registers\n+;; (or at least were intended to do so).\n+\n+;; On the Gmicro/300,\n+;; bitfield instructions are not applicable to registers ;-<\n+;; But I write the register cases, because without them the gcc\n+;; seems to use \"and\" instruction with some other instructions\n+;; instead of using a shift instruction.\n+;; It is because on many processors shift instructions are slower.\n+;; On the Gmicro/300 which has a barrel shifter,\n+;; it is faster to use a shift instruction.\n+;;\n+;; Restricts width and offset to be immediates.\n+;;\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n+\t(sign_extract:SI (match_operand:SI 1 \"nonimmediate_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")\n+\t\t\t (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n+  \"TARGET_BITFIELD\"\n+  \"*\n+{\n+  if (REGNO (operands[0]) != REGNO (operands[1]))\n+    output_asm_insn (\\\"mov.w %1,%0\\\", operands);\n+  if (INTVAL (operands[3]) != 0)\n+    output_asm_insn (\\\"shl.w %3,%0\\\", operands);\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode, -(32 - INTVAL (operands[2])));\n+  return \\\"sha.w %3,%0\\\";\n+}\")\n+    \n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n+\t(zero_extract:SI (match_operand:SI 1 \"nonimmediate_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")\n+\t\t\t (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n+  \"TARGET_BITFIELD\"\n+  \"*\n+{\n+  if (REGNO (operands[0]) != REGNO (operands[1]))\n+    output_asm_insn (\\\"mov.w %1,%0\\\", operands);\n+  if (INTVAL (operands[3]) != 0)\n+    output_asm_insn (\\\"shl.w %3,%0\\\", operands);\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode, -(32 - INTVAL (operands[2])));\n+  return \\\"shl.w %3,%0\\\";\n+}\")\n+\n+\n+;; There are more descriptions for m68k, but not yet for the Gmicro.\n+;;\n+\f\n+;; Basic conditional jump instructions.\n+\n+\n+(define_insn \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{\n+  OUTPUT_JUMP (\\\"beq %b0\\\", \\\"fbeq %b0\\\", \\\"beq %b0\\\");\n+}\")\n+\n+(define_insn \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{\n+  OUTPUT_JUMP (\\\"bne %b0\\\", \\\"fbne %b0\\\", \\\"bne %b0\\\");\n+}\")\n+\n+(define_insn \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+  OUTPUT_JUMP (\\\"bgt %b0\\\", \\\"fbgt %b0\\\", 0);\n+\")\n+\n+(define_insn \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"bgt %b0\")\n+\n+(define_insn \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+  OUTPUT_JUMP (\\\"blt %b0\\\", \\\"fblt %b0\\\", \\\"bms %b0\\\");\n+\")\n+\n+;; bms ?????\n+;; \n+\n+(define_insn \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"blt %b0\")\n+\n+(define_insn \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+  OUTPUT_JUMP (\\\"bge %b0\\\", \\\"fbge %b0\\\", \\\"bmc %b0\\\");\n+\")\n+\n+;; bmc ??\n+\n+(define_insn \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"bge %b0\")\n+\n+(define_insn \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"ble %b0\")\n+\n+(define_insn \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"ble %b0\")\n+\f\n+;; Negated conditional jump instructions.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  OUTPUT_JUMP (\\\"bne %b0\\\", \\\"fbne %b0\\\", \\\"bne %b0\\\");\n+}\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  OUTPUT_JUMP (\\\"beq %b0\\\", \\\"fbeq %b0\\\", \\\"beq %b0\\\");\n+}\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  OUTPUT_JUMP (\\\"ble %b0\\\", \\\"fbngt %b0\\\", 0);\n+\")\n+;; fbngt ???\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"ble %b0\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  OUTPUT_JUMP (\\\"bge %b0\\\", \\\"fbnlt %b0\\\", \\\"jbmc %b0\\\");\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"blt %b0\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  OUTPUT_JUMP (\\\"blt %b0\\\", \\\"fbnge %b0\\\", \\\"jbms %b0\\\");\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"blt %b0\")\n+;; ????\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  OUTPUT_JUMP (\\\"bgt %b0\\\", \\\"fbnle %b0\\\", 0);\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"bgt %b0\")\n+\f\n+;; Unconditional and other jump instructions\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"bra %b0\")\n+\n+(define_insn \"tablejump\"\n+  [(set (pc)\n+\t(plus:SI (pc) (match_operand:SI 0 \"general_operand\" \"r\")))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"jmp @(pc:b,4:4,%0)\")\n+\n+;;\n+;; Should Add code for \"ACB\", \"SCB\". !!! ????\n+;; See m68k.h (dbra)\n+;;\n+\n+;; Call subroutine with no return value.\n+(define_insn \"call\"\n+  [(call (match_operand:QI 0 \"general_operand\" \"m\")\n+\t (match_operand:SI 1 \"general_operand\" \"rmi\"))]\n+  ;; Operand 1 not really used on the Gmicro.\n+\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM\n+      && GET_CODE (XEXP (operands[0],0)) == SYMBOL_REF)\n+    return \\\"bsr %b0\\\";\n+  return \\\"jsr %0\\\";\n+}\")\n+\n+;; Call subroutine, returning value in operand 0\n+;; (which must be a hard register).\n+(define_insn \"call_value\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (match_operand:QI 1 \"general_operand\" \"m\")\n+\t      (match_operand:SI 2 \"general_operand\" \"rmi\")))]\n+  ;; Operand 2 not really used on the Gmicro.\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == MEM\n+      && GET_CODE (XEXP (operands[1],0)) == SYMBOL_REF)\n+    return \\\"bsr %b1\\\";\n+  return \\\"jsr %1\\\";\n+}\")\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+    \"\"\n+    \"nop\")\n+\f\n+;; Turned off because the general move-an-address pattern handles it.\n+;; \n+;; Thus goes after the move instructions\n+;; because the move instructions are better (require no spilling)\n+;; when they can apply. \n+;; After add/sub now !!\n+\n+;(define_insn \"pushasi\"\n+;  [(set (match_operand:SI 0 \"push_operand\" \"=m\")\n+;\t(match_operand:SI 1 \"address_operand\" \"p\"))]\n+;  \"\"\n+;  \"*\n+;{\n+;  if (GET_CODE (operands[1]) == CONST_INT)\n+;    return push_imm_word (INTVAL (operands[1]), operands[0]);\n+;  if (CONSTANT_P (operands[1]))\n+;    return \\\"mov.w %1,%-\\\";\n+;  if (GET_CODE (operands[1]) == REG)\n+;    return \\\"mov.w %1,%-\\\";\n+;  else if (GET_CODE (operands[1]) == MEM)\n+;    {\n+;      return \\\"mov.w %1,%-\\\";\n+;    }\n+;  else\n+;    return \\\"mova.w %p1,%-\\\";\n+;}\")\n+\f\n+;; This should not be used unless the add/sub insns can't be.\n+\n+/* mova.[whq] 89.08.11 for test M.Yuhara */\n+;(define_insn \"\"\n+;  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+;\t(address (match_operand:SI 1 \"address_operand\" \"p\")))]\n+;  \"\"\n+;  \"*\n+;{\n+;    if (GET_CODE (operands[1]) == CONST_INT)\n+;        return mov_imm_word (INTVAL (operands[1]), operands[0]);\n+;    if (CONSTANT_P (operands[1]))\n+;        return \\\"mov.w %1,%0\\\";\n+;    if (GET_CODE (operands[1]) == REG)\n+;        return \\\"mov.w %1,%0\\\";\n+;    else  if (GET_CODE (operands[1]) == MEM) {\n+;\toperands[1] = XEXP (operands[1],0);\n+;        return \\\"mov.w %1,%0\\\";\n+;    }\n+;    else\n+;        return \\\"mova.w %p1,%0\\\";\n+;}\")\n+\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(address (match_operand:HI 1 \"address_operand\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    return mov_imm_word (INTVAL (operands[1]), operands[0]);\n+  if (CONSTANT_P (operands[1]))\n+    return \\\"mov.w %1,%0\\\";\n+  if (GET_CODE (operands[1]) == REG)\n+    return \\\"mov.w %1,%0\\\";\n+  else  if (GET_CODE (operands[1]) == MEM)\n+    {\n+      operands[1] = XEXP (operands[1],0);\n+      return \\\"mov.w %1,%0\\\";\t/* OK ? */\n+    }\n+  else\n+    return \\\"mova.w %p1,%0\\\";\n+}\")\n+\n+;(define_insn \"\"\n+;  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+;\t(match_operand:QI 1 \"address_operand\" \"p\"))]\n+;  \"\"\n+;  \"*\n+;{\n+;  if (push_operand (operands[0], SImode))\n+;    return \\\"mova %1,%-\\\";\n+;  return \\\"mova %1,%0\\\";\n+;}\")\n+\n+;(define_insn \"\"\n+;  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+;\t(match_operand:QI 1 \"address_operand\" \"p\"))]\n+;  \"\"\n+;  \"*\n+;{\n+;  if (CONSTANT_P (operands[1]))\n+;    return \\\"mov.w %1,%0\\\";\n+;  else if (GET_CODE (operands[1]) == REG)\n+;    return \\\"mov.w %1,%0\\\";\n+;  else if (GET_CODE (operands[1]) == MEM)\n+;    {\n+;      operands[1] = XEXP (operands[1],0);\n+;      return \\\"mov.w %1,%0 ; OK?\\\";\n+;    }\n+;  else if (GET_CODE (operands[0]) == REG\n+;\t   && GET_CODE (operands[1]) == PLUS)\n+;    {\n+;      rtx xreg, xdisp;\n+;\n+;      if (GET_CODE (XEXP (operands[1], 0)) == REG \n+;\t  && REGNO (XEXP (operands[1], 0)) == REGNO (operands[0]))\n+;\t{\n+;\t  xreg = XEXP (operands[1], 0);\n+;\t  xdisp = XEXP (operands[1],1);\n+;\t}\n+;      else\n+;\t{\n+;\t  xreg = XEXP (operands[1], 1);\n+;\t  xdisp = XEXP (operands[1],0);\n+;\t}\n+;\n+;      if (GET_CODE (xreg) == REG\n+;\t  && REGNO (xreg) == REGNO (operands[0])\n+;\t  && (CONSTANT_P (xdisp) || GET_CODE (xdisp) == REG))\n+;\t{\n+;\t  operands[1] = xdisp;\n+;\t  if (CONSTANT_P (xdisp))\n+;\t    return add_imm_word (INTVAL (xdisp), xreg, &operands[1]);\n+;\t  else\n+;\t    return \\\"add.w %1,%0\\\";\n+;\t}\n+;    }\n+;  return \\\"mova.w %p1,%0\\\";\n+;}\")\n+\f\n+;; This is the first machine-dependent peephole optimization.\n+;; It is useful when a floating value is returned from a function call\n+;; and then is moved into an FP register.\n+;; But it is mainly intended to test the support for these optimizations.\n+\n+(define_peephole\n+  [(set (reg:SI 15) (plus:SI (reg:SI 15) (const_int 4)))\n+   (set (match_operand:DF 0 \"register_operand\" \"f\")\n+\t(match_operand:DF 1 \"register_operand\" \"r\"))]\n+  \"FPU_REG_P (operands[0]) && ! FPU_REG_P (operands[1])\"\n+  \"*\n+{\n+  rtx xoperands[2];\n+  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  output_asm_insn (\\\"mov.w %1,@sp\\\", xoperands);\n+  output_asm_insn (\\\"mov.w %1,%-\\\", operands);\n+  return \\\"fmov.d %+,%0\\\";\n+}\n+\")\n+\f\n+\n+;;- Local variables:\n+;;- mode:emacs-lisp\n+;;- comment-start: \";;- \"\n+;;- comment-start-skip: \";+- *\"\n+;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\n+;;- eval: (modify-syntax-entry ?[ \"(]\")\n+;;- eval: (modify-syntax-entry ?] \")[\")\n+;;- eval: (modify-syntax-entry ?{ \"(}\")\n+;;- eval: (modify-syntax-entry ?} \"){\")\n+;;- End:"}]}