{"sha": "c2ea3a40d9d7f302ba6f9279163d201410b39a4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJlYTNhNDBkOWQ3ZjMwMmJhNmY5Mjc5MTYzZDIwMTQxMGIzOWE0Yw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2002-02-07T20:51:15Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2002-02-07T20:51:15Z"}, "message": "Rename instantiate_type_flags to tsubst_flags_t & expand use.\n\n\t* cp-tree.h (instantiate_type_flags): Rename to ...\n\t(tsubst_flags_t): ... here. Rename itf_complain to tf_error,\n\tadd tf_warning flag.\n\t(instantiate_type): Adjust prototype.\n\t(tsubst, tsubst_expr, tsubst_copy, lookup_template_class,\n\tdo_type_instantiation, cp_build_qualified_type_real): Likewise.\n\tcp_build_qualified_type: Adjust.\n\t* class.c (instantiate_type): Adjust parameter. Rename itf_* to\n\ttf_*.\n\t* call.c (standard_conversion): Rename itf_* to tf_*.\n\t(reference_binding): Likewise.\n\t(convert_like_real): Likewise.\n\t* cvt.c (cp_convert_to_pointer): Likewise.\n\t(convert_to_reference): Likewise.\n\t* decl.c (lookup_namespace_name): Use tf_* flags.\n\t(make_typename_type): Likewise.\n\t(grokdeclarator): Likewise.\n\t* pt.c (convert_nontype_argument): Adjust COMPLAIN usage.\n\t(coerce_template_template_parms, convert_template_argument,\n\tcoerce_template_parms, maybe_get_template_decl_from_type_decl,\n\tlookup_template_class, tsubst_friend_function, tsubst_friend_class,\n\tinstantiate_class_template, tsubst_template_arg_vector,\n\ttsubst_template_parms, tsubst_aggr_type, tsubst_default_argument,\n\ttsubst_decl, tsubst_arg_types, tsubst_function_type,\n\ttsubst_call_declarator_parms, tsubst, tsubst_copy, tsubst_expr,\n\tinstantiate_template, fn_type_unification,\n\tresolve_overloaded_unification, verify_class_unification,\n\tunify, get_bindings_real, do_type_instantiation,\n\tregenerate_decl_from_template, instantiate_decl,\n\ttsubst_initializer_list, tsubst_enum,\n\tget_mostly_instantiated_function_type,\n\tinvalid_nontype_parm_type_p): Likewise.\n\t* tree.c (cp_build_qualified_type_real): Likewise.\n\t* typeck.c (build_binary_op): Rename itf_* to tf_*.\n\t(build_ptrmemfunc): Likewise.\n\t(convert_for_assignment): Likewise.\n\nFrom-SVN: r49591", "tree": {"sha": "53f5bd8a588ac97b8f047d7835a6c4f71ec062a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53f5bd8a588ac97b8f047d7835a6c4f71ec062a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2ea3a40d9d7f302ba6f9279163d201410b39a4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2ea3a40d9d7f302ba6f9279163d201410b39a4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2ea3a40d9d7f302ba6f9279163d201410b39a4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/comments", "author": null, "committer": null, "parents": [{"sha": "3ab57fab23a0e65a4acbee0aac497b92ec8cb9f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ab57fab23a0e65a4acbee0aac497b92ec8cb9f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ab57fab23a0e65a4acbee0aac497b92ec8cb9f8"}], "stats": {"total": 487, "additions": 258, "deletions": 229}, "files": [{"sha": "ad7dd540dcede4266d70de36c72c8027c32c3aad", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c2ea3a40d9d7f302ba6f9279163d201410b39a4c", "patch": "@@ -1,3 +1,43 @@\n+2002-02-07  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tRename instantiate_type_flags to tsubst_flags_t & expand use.\n+\t* cp-tree.h (instantiate_type_flags): Rename to ...\n+\t(tsubst_flags_t): ... here. Rename itf_complain to tf_error,\n+\tadd tf_warning flag.\n+\t(instantiate_type): Adjust prototype.\n+\t(tsubst, tsubst_expr, tsubst_copy, lookup_template_class,\n+\tdo_type_instantiation, cp_build_qualified_type_real): Likewise.\n+\tcp_build_qualified_type: Adjust.\n+\t* class.c (instantiate_type): Adjust parameter. Rename itf_* to\n+\ttf_*.\n+\t* call.c (standard_conversion): Rename itf_* to tf_*.\n+\t(reference_binding): Likewise.\n+\t(convert_like_real): Likewise.\n+\t* cvt.c (cp_convert_to_pointer): Likewise.\n+\t(convert_to_reference): Likewise.\n+\t* decl.c (lookup_namespace_name): Use tf_* flags.\n+\t(make_typename_type): Likewise.\n+\t(grokdeclarator): Likewise.\n+\t* pt.c (convert_nontype_argument): Adjust COMPLAIN usage.\n+\t(coerce_template_template_parms, convert_template_argument,\n+\tcoerce_template_parms, maybe_get_template_decl_from_type_decl,\n+\tlookup_template_class, tsubst_friend_function, tsubst_friend_class,\n+\tinstantiate_class_template, tsubst_template_arg_vector, \n+\ttsubst_template_parms, tsubst_aggr_type, tsubst_default_argument, \n+\ttsubst_decl, tsubst_arg_types, tsubst_function_type,\n+\ttsubst_call_declarator_parms, tsubst, tsubst_copy, tsubst_expr, \n+\tinstantiate_template, fn_type_unification,\n+\tresolve_overloaded_unification, verify_class_unification, \n+\tunify, get_bindings_real, do_type_instantiation, \n+\tregenerate_decl_from_template, instantiate_decl, \n+\ttsubst_initializer_list, tsubst_enum,\n+\tget_mostly_instantiated_function_type,\n+\tinvalid_nontype_parm_type_p): Likewise.\n+\t* tree.c (cp_build_qualified_type_real): Likewise.\n+\t* typeck.c (build_binary_op): Rename itf_* to tf_*.\n+\t(build_ptrmemfunc): Likewise.\n+\t(convert_for_assignment): Likewise.\n+\n 2002-02-07  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/109"}, {"sha": "29e0c72caeaf991ae67a2aae2a60a818d699bd63", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=c2ea3a40d9d7f302ba6f9279163d201410b39a4c", "patch": "@@ -705,7 +705,7 @@ standard_conversion (to, from, expr)\n   if ((TYPE_PTRFN_P (to) || TYPE_PTRMEMFUNC_P (to))\n       && expr && type_unknown_p (expr))\n     {\n-      expr = instantiate_type (to, expr, itf_none);\n+      expr = instantiate_type (to, expr, tf_none);\n       if (expr == error_mark_node)\n \treturn NULL_TREE;\n       from = TREE_TYPE (expr);\n@@ -1108,7 +1108,7 @@ reference_binding (rto, rfrom, expr, flags)\n \n   if (TREE_CODE (to) == FUNCTION_TYPE && expr && type_unknown_p (expr))\n     {\n-      expr = instantiate_type (to, expr, itf_none);\n+      expr = instantiate_type (to, expr, tf_none);\n       if (expr == error_mark_node)\n \treturn NULL_TREE;\n       from = TREE_TYPE (expr);\n@@ -3864,7 +3864,7 @@ convert_like_real (convs, expr, fn, argnum, inner)\n       }\n     case IDENTITY_CONV:\n       if (type_unknown_p (expr))\n-\texpr = instantiate_type (totype, expr, itf_complain);\n+\texpr = instantiate_type (totype, expr, tf_error | tf_warning);\n       return expr;\n     case AMBIG_CONV:\n       /* Call build_user_type_conversion again for the error.  */"}, {"sha": "40702867405acdbe5cba15459840f2c66f3cdf43", "filename": "gcc/cp/class.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c2ea3a40d9d7f302ba6f9279163d201410b39a4c", "patch": "@@ -6043,14 +6043,14 @@ cannot resolve overloaded function `%D' based on conversion to type `%T'\",\n tree\n instantiate_type (lhstype, rhs, flags)\n      tree lhstype, rhs;\n-     enum instantiate_type_flags flags;\n+     tsubst_flags_t flags;\n {\n-  int complain = (flags & itf_complain);\n-  int strict = (flags & itf_no_attributes)\n+  int complain = (flags & tf_error);\n+  int strict = (flags & tf_no_attributes)\n                ? COMPARE_NO_ATTRIBUTES : COMPARE_STRICT;\n-  int allow_ptrmem = flags & itf_ptrmem_ok;\n+  int allow_ptrmem = flags & tf_ptrmem_ok;\n   \n-  flags &= ~itf_ptrmem_ok;\n+  flags &= ~tf_ptrmem_ok;\n   \n   if (TREE_CODE (lhstype) == UNKNOWN_TYPE)\n     {\n@@ -6257,7 +6257,7 @@ instantiate_type (lhstype, rhs, flags)\n     case ADDR_EXPR:\n     {\n       if (PTRMEM_OK_P (rhs))\n-        flags |= itf_ptrmem_ok;\n+        flags |= tf_ptrmem_ok;\n       \n       return instantiate_type (lhstype, TREE_OPERAND (rhs, 0), flags);\n     }"}, {"sha": "169d1a2ecefef35e3da9be884316c1d42ea47012", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c2ea3a40d9d7f302ba6f9279163d201410b39a4c", "patch": "@@ -3063,13 +3063,16 @@ typedef enum linkage_kind {\n   lk_external              /* External linkage.  */\n } linkage_kind;\n \n-/* Bitmask flags to pass to instantiate_type.  */\n-typedef enum instantiate_type_flags {\n-  itf_none = 0,               /* nothing special */\n-  itf_complain = 1 << 0,      /* complain about errors */\n-  itf_no_attributes = 1 << 1, /* ignore attributes on comparisons */\n-  itf_ptrmem_ok = 1 << 2,     /* pointers to member ok (internal use) */\n-} instantiate_type_flags;\n+/* Bitmask flags to control type substitution.  */\n+typedef enum tsubst_flags_t {\n+  tf_none = 0,               /* nothing special */\n+  tf_error = 1 << 0,         /* give error messages  */\n+  tf_warning = 1 << 1,       /* give warnings too  */\n+  tf_no_attributes = 1 << 2, /* ignore attributes on comparisons\n+\t\t\t\t(instantiate_type use) */\n+  tf_ptrmem_ok = 1 << 3      /* pointers to member ok (internal\n+\t\t\t\tinstantiate_type use) */\n+} tsubst_flags_t;\n \n /* The kind of checking we can do looking in a class hierarchy. */\n typedef enum base_access {\n@@ -3598,7 +3601,7 @@ extern void pop_nested_class\t\t\tPARAMS ((void));\n extern int current_lang_depth\t\t\tPARAMS ((void));\n extern void push_lang_context\t\t\tPARAMS ((tree));\n extern void pop_lang_context\t\t\tPARAMS ((void));\n-extern tree instantiate_type\t\t\tPARAMS ((tree, tree, enum instantiate_type_flags));\n+extern tree instantiate_type\t\t\tPARAMS ((tree, tree, tsubst_flags_t));\n extern void print_class_statistics              PARAMS ((void));\n extern void cxx_print_statistics\t\tPARAMS ((void));\n extern void cxx_print_xnode\t\t\tPARAMS ((FILE *, tree, int));\n@@ -3972,9 +3975,9 @@ extern int maybe_clone_body                     PARAMS ((tree));\n extern void init_pt                             PARAMS ((void));\n extern void check_template_shadow\t\tPARAMS ((tree));\n extern tree get_innermost_template_args         PARAMS ((tree, int));\n-extern tree tsubst\t\t\t\tPARAMS ((tree, tree, int, tree));\n-extern tree tsubst_expr\t\t\t\tPARAMS ((tree, tree, int, tree));\n-extern tree tsubst_copy\t\t\t\tPARAMS ((tree, tree, int, tree));\n+extern tree tsubst\t\t\t\tPARAMS ((tree, tree, tsubst_flags_t, tree));\n+extern tree tsubst_expr\t\t\t\tPARAMS ((tree, tree, tsubst_flags_t, tree));\n+extern tree tsubst_copy\t\t\t\tPARAMS ((tree, tree, tsubst_flags_t, tree));\n extern void maybe_begin_member_template_processing PARAMS ((tree));\n extern void maybe_end_member_template_processing PARAMS ((void));\n extern tree finish_member_template_decl         PARAMS ((tree));\n@@ -3992,7 +3995,7 @@ extern tree current_template_args\t\tPARAMS ((void));\n extern tree push_template_decl\t\t\tPARAMS ((tree));\n extern tree push_template_decl_real             PARAMS ((tree, int));\n extern void redeclare_class_template            PARAMS ((tree, tree));\n-extern tree lookup_template_class\t\tPARAMS ((tree, tree, tree, tree, int, int));\n+extern tree lookup_template_class\t\tPARAMS ((tree, tree, tree, tree, int, tsubst_flags_t));\n extern tree lookup_template_function            PARAMS ((tree, tree));\n extern int uses_template_parms\t\t\tPARAMS ((tree));\n extern tree instantiate_class_template\t\tPARAMS ((tree));\n@@ -4003,7 +4006,7 @@ extern void mark_decl_instantiated\t\tPARAMS ((tree, int));\n extern int more_specialized\t\t\tPARAMS ((tree, tree, int, int));\n extern void mark_class_instantiated\t\tPARAMS ((tree, int));\n extern void do_decl_instantiation\t\tPARAMS ((tree, tree, tree));\n-extern void do_type_instantiation\t\tPARAMS ((tree, tree, int));\n+extern void do_type_instantiation\t\tPARAMS ((tree, tree, tsubst_flags_t));\n extern tree instantiate_decl\t\t\tPARAMS ((tree, int));\n extern tree get_bindings\t\t\tPARAMS ((tree, tree, tree));\n extern int push_tinst_level\t\t\tPARAMS ((tree));\n@@ -4262,9 +4265,9 @@ extern tree maybe_dummy_object\t\t\tPARAMS ((tree, tree *));\n extern int is_dummy_object\t\t\tPARAMS ((tree));\n extern const struct attribute_spec cp_attribute_table[];\n extern tree make_ptrmem_cst                     PARAMS ((tree, tree));\n-extern tree cp_build_qualified_type_real        PARAMS ((tree, int, int));\n+extern tree cp_build_qualified_type_real        PARAMS ((tree, int, tsubst_flags_t));\n #define cp_build_qualified_type(TYPE, QUALS) \\\n-  cp_build_qualified_type_real ((TYPE), (QUALS), /*complain=*/1)\n+  cp_build_qualified_type_real ((TYPE), (QUALS), tf_error | tf_warning)\n extern tree build_shared_int_cst                PARAMS ((int));\n extern special_function_kind special_function_p PARAMS ((tree));\n extern int count_trees                          PARAMS ((tree));"}, {"sha": "1d5dc90955eabe36b4f36dc49ab73058fff4cc23", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=c2ea3a40d9d7f302ba6f9279163d201410b39a4c", "patch": "@@ -267,7 +267,7 @@ cp_convert_to_pointer (type, expr, force)\n     }\n \n   if (type_unknown_p (expr))\n-    return instantiate_type (type, expr, itf_complain);\n+    return instantiate_type (type, expr, tf_error | tf_warning);\n \n   error (\"cannot convert `%E' from type `%T' to type `%T'\",\n \t    expr, intype, type);\n@@ -478,7 +478,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n     {\n       expr = instantiate_type (type, expr, \n \t\t\t       (flags & LOOKUP_COMPLAIN)\n-\t                       ? itf_complain : itf_none);\n+\t                       ? tf_error | tf_warning : tf_none);\n       if (expr == error_mark_node)\n \treturn error_mark_node;\n "}, {"sha": "158dc8f7c51def77ff2da8844a46c0ffc59da685", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c2ea3a40d9d7f302ba6f9279163d201410b39a4c", "patch": "@@ -5491,7 +5491,7 @@ lookup_namespace_name (namespace, name)\n \t\t\t\t\t /*in_decl=*/NULL_TREE,\n \t\t\t\t\t /*context=*/NULL_TREE,\n \t\t\t\t\t /*entering_scope=*/0,\n-\t                                 /*complain=*/1);\n+\t                                 tf_error | tf_warning);\n \t  else if (DECL_FUNCTION_TEMPLATE_P (val)\n \t\t   || TREE_CODE (val) == OVERLOAD)\n \t    val = lookup_template_function (val,\n@@ -5680,7 +5680,7 @@ make_typename_type (context, name, complain)\n \t\t\t\t\tTREE_OPERAND (fullname, 1),\n \t\t\t\t\tNULL_TREE, context,\n \t\t\t\t\t/*entering_scope=*/0,\n-\t                                /*complain=*/1);\n+\t                                tf_error | tf_warning);\n \t}\n       else\n \t{\n@@ -10906,7 +10906,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t    && uses_template_parms (current_class_type))\n \t\t  {\n \t\t    tree args = current_template_args ();\n-\t\t    type = tsubst (type, args, /*complain=*/1, NULL_TREE);\n+\t\t    type = tsubst (type, args, tf_error | tf_warning,\n+\t\t\t\t   NULL_TREE);\n \t\t  }\n \n \t\t/* This pop_nested_class corresponds to the"}, {"sha": "d963a79cf226e5ce2e61afd0837393ae23b8ddf6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 175, "deletions": 189, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c2ea3a40d9d7f302ba6f9279163d201410b39a4c", "patch": "@@ -93,30 +93,32 @@ static htab_t local_specializations;\n \t\t\t     type with the desired type.  */\n \n static int resolve_overloaded_unification PARAMS ((tree, tree, tree, tree,\n-\t\t\t\t\t\t unification_kind_t, int));\n+\t\t\t\t\t\t   unification_kind_t, int));\n static int try_one_overload PARAMS ((tree, tree, tree, tree, tree,\n-\t\t\t\t   unification_kind_t, int));\n+\t\t\t\t     unification_kind_t, int));\n static int unify PARAMS ((tree, tree, tree, tree, int));\n static void add_pending_template PARAMS ((tree));\n static void reopen_tinst_level PARAMS ((tree));\n static tree classtype_mangled_name PARAMS ((tree));\n-static char *mangle_class_name_for_template PARAMS ((const char *, tree, tree));\n+static char *mangle_class_name_for_template PARAMS ((const char *,\n+\t\t\t\t\t\t     tree, tree));\n static tree tsubst_initializer_list PARAMS ((tree, tree));\n static int list_eq PARAMS ((tree, tree));\n static tree get_class_bindings PARAMS ((tree, tree, tree));\n-static tree coerce_template_parms PARAMS ((tree, tree, tree, int, int));\n+static tree coerce_template_parms PARAMS ((tree, tree, tree,\n+\t\t\t\t\t   tsubst_flags_t, int));\n static void tsubst_enum\tPARAMS ((tree, tree, tree));\n static tree add_to_template_args PARAMS ((tree, tree));\n static tree add_outermost_template_args PARAMS ((tree, tree));\n static int maybe_adjust_types_for_deduction PARAMS ((unification_kind_t, tree*,\n-\t\t\t\t\t\t    tree*)); \n+\t\t\t\t\t\t     tree*)); \n static int  type_unification_real PARAMS ((tree, tree, tree, tree,\n-\t\t\t\t\t int, unification_kind_t, int, int));\n+\t\t\t\t\t   int, unification_kind_t, int, int));\n static void note_template_header PARAMS ((int));\n static tree maybe_fold_nontype_arg PARAMS ((tree));\n static tree convert_nontype_argument PARAMS ((tree, tree));\n-static tree convert_template_argument PARAMS ((tree, tree, tree, int,\n-\t\t\t\t\t      int , tree));\n+static tree convert_template_argument PARAMS ((tree, tree, tree,\n+\t\t\t\t\t       tsubst_flags_t, int, tree));\n static tree get_bindings_overload PARAMS ((tree, tree, tree));\n static int for_each_template_parm PARAMS ((tree, tree_fn_t, void*));\n static tree build_template_parm_index PARAMS ((int, int, int, tree, tree));\n@@ -136,35 +138,36 @@ static tree get_bindings_real PARAMS ((tree, tree, tree, int, int, int));\n static int template_decl_level PARAMS ((tree));\n static tree maybe_get_template_decl_from_type_decl PARAMS ((tree));\n static int check_cv_quals_for_unify PARAMS ((int, tree, tree));\n-static tree tsubst_template_arg_vector PARAMS ((tree, tree, int));\n-static tree tsubst_template_parms PARAMS ((tree, tree, int));\n+static tree tsubst_template_arg_vector PARAMS ((tree, tree, tsubst_flags_t));\n+static tree tsubst_template_parms PARAMS ((tree, tree, tsubst_flags_t));\n static void regenerate_decl_from_template PARAMS ((tree, tree));\n static tree most_specialized PARAMS ((tree, tree, tree));\n static tree most_specialized_class PARAMS ((tree, tree));\n static int template_class_depth_real PARAMS ((tree, int));\n-static tree tsubst_aggr_type PARAMS ((tree, tree, int, tree, int));\n-static tree tsubst_decl PARAMS ((tree, tree, tree));\n-static tree tsubst_arg_types PARAMS ((tree, tree, int, tree));\n-static tree tsubst_function_type PARAMS ((tree, tree, int, tree));\n+static tree tsubst_aggr_type PARAMS ((tree, tree, tsubst_flags_t, tree, int));\n+static tree tsubst_decl PARAMS ((tree, tree, tree, tsubst_flags_t));\n+static tree tsubst_arg_types PARAMS ((tree, tree, tsubst_flags_t, tree));\n+static tree tsubst_function_type PARAMS ((tree, tree, tsubst_flags_t, tree));\n static void check_specialization_scope PARAMS ((void));\n static tree process_partial_specialization PARAMS ((tree));\n static void set_current_access_from_decl PARAMS ((tree));\n static void check_default_tmpl_args PARAMS ((tree, tree, int, int));\n-static tree tsubst_call_declarator_parms PARAMS ((tree, tree, int, tree));\n+static tree tsubst_call_declarator_parms PARAMS ((tree, tree,\n+\t\t\t\t\t\t  tsubst_flags_t, tree));\n static tree get_template_base_recursive PARAMS ((tree, tree,\n-\t\t\t\t\t       tree, tree, tree, int)); \n+\t\t\t\t\t\t tree, tree, tree, int)); \n static tree get_template_base PARAMS ((tree, tree, tree, tree));\n static int verify_class_unification PARAMS ((tree, tree, tree));\n static tree try_class_unification PARAMS ((tree, tree, tree, tree));\n-static int coerce_template_template_parms PARAMS ((tree, tree, int,\n-\t\t\t\t\t\t tree, tree));\n+static int coerce_template_template_parms PARAMS ((tree, tree, tsubst_flags_t,\n+\t\t\t\t\t\t   tree, tree));\n static tree determine_specialization PARAMS ((tree, tree, tree *, int));\n static int template_args_equal PARAMS ((tree, tree));\n static void tsubst_default_arguments PARAMS ((tree));\n static tree for_each_template_parm_r PARAMS ((tree *, int *, void *));\n static tree copy_default_args_to_explicit_spec_1 PARAMS ((tree, tree));\n static void copy_default_args_to_explicit_spec PARAMS ((tree));\n-static int invalid_nontype_parm_type_p PARAMS ((tree, int));\n+static int invalid_nontype_parm_type_p PARAMS ((tree, tsubst_flags_t));\n \n /* Called once to initialize pt.c.  */\n \n@@ -3013,7 +3016,7 @@ convert_nontype_argument (type, expr)\n \t    else\n \t      fns = expr;\n \n-\t    fn = instantiate_type (type_pointed_to, fns, itf_none);\n+\t    fn = instantiate_type (type_pointed_to, fns, tf_none);\n \n \t    if (fn == error_mark_node)\n \t      return error_mark_node;\n@@ -3078,7 +3081,7 @@ convert_nontype_argument (type, expr)\n \t       set (_over.over_).  */\n \t    tree fn;\n \n-\t    fn = instantiate_type (type_referred_to, expr, itf_none);\n+\t    fn = instantiate_type (type_referred_to, expr, tf_none);\n \n \t    if (fn == error_mark_node)\n \t      return error_mark_node;\n@@ -3147,7 +3150,7 @@ convert_nontype_argument (type, expr)\n \tif (TREE_CODE (expr) != ADDR_EXPR)\n \t  return error_mark_node;\n \n-\texpr = instantiate_type (type, expr, itf_none);\n+\texpr = instantiate_type (type, expr, tf_none);\n \t\n \tif (expr == error_mark_node)\n \t  return error_mark_node;\n@@ -3188,7 +3191,7 @@ static int\n coerce_template_template_parms (parm_parms, arg_parms, complain, \n \t\t\t\tin_decl, outer_args)\n      tree parm_parms, arg_parms;\n-     int complain;\n+     tsubst_flags_t complain;\n      tree in_decl, outer_args;\n {\n   int nparms, nargs, i;\n@@ -3257,17 +3260,17 @@ coerce_template_template_parms (parm_parms, arg_parms, complain,\n \n /* Convert the indicated template ARG as necessary to match the\n    indicated template PARM.  Returns the converted ARG, or\n-   error_mark_node if the conversion was unsuccessful.  Error messages\n-   are issued if COMPLAIN is non-zero.  This conversion is for the Ith\n-   parameter in the parameter list.  ARGS is the full set of template\n-   arguments deduced so far.  */\n+   error_mark_node if the conversion was unsuccessful.  Error and\n+   warning messages are issued under control of COMPLAIN.  This\n+   conversion is for the Ith parameter in the parameter list.  ARGS is\n+   the full set of template arguments deduced so far.  */\n \n static tree\n convert_template_argument (parm, arg, args, complain, i, in_decl)\n      tree parm;\n      tree arg;\n      tree args;\n-     int complain;\n+     tsubst_flags_t complain;\n      int i;\n      tree in_decl;\n {\n@@ -3331,14 +3334,16 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n       \n       arg = make_typename_type (TREE_OPERAND (arg, 0),\n \t\t\t\tTREE_OPERAND (arg, 1),\n-\t\t\t\tcomplain);\n+\t\t\t\tcomplain & tf_error);\n+      if (TREE_CODE (arg) == TYPE_DECL)\n+\targ = TREE_TYPE (arg);\n       is_type = 1;\n     }\n   if (is_type != requires_type)\n     {\n       if (in_decl)\n \t{\n-\t  if (complain)\n+\t  if (complain & tf_error)\n \t    {\n \t      error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n \t\t\ti + 1, in_decl);\n@@ -3354,7 +3359,7 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n     }\n   if (is_tmpl_type ^ requires_tmpl_type)\n     {\n-      if (in_decl && complain)\n+      if (in_decl && (complain & tf_error))\n \t{\n \t  error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n \t\t    i + 1, in_decl);\n@@ -3393,7 +3398,7 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (in_decl && complain)\n+\t\t  if (in_decl && (complain & tf_error))\n \t\t    {\n \t\t      error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n \t\t\t\ti + 1, in_decl);\n@@ -3456,7 +3461,7 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n \n       if (val == NULL_TREE)\n \tval = error_mark_node;\n-      else if (val == error_mark_node && complain)\n+      else if (val == error_mark_node && (complain & tf_error))\n \terror (\"could not convert template argument `%E' to `%T'\", \n \t\t  arg, t);\n     }\n@@ -3466,10 +3471,10 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n \n /* Convert all template arguments to their appropriate types, and\n    return a vector containing the innermost resulting template\n-   arguments.  If any error occurs, return error_mark_node, and, if\n-   COMPLAIN is non-zero, issue an error message.  Some error messages\n-   are issued even if COMPLAIN is zero; for instance, if a template\n-   argument is composed from a local class.\n+   arguments.  If any error occurs, return error_mark_node. Error and\n+   warning messages are issued under control of COMPLAIN.  Some error\n+   messages are issued even if COMPLAIN is zero; for instance, if a\n+   template argument is composed from a local class.\n \n    If REQUIRE_ALL_ARGUMENTS is non-zero, all arguments must be\n    provided in ARGLIST, or else trailing parameters must have default\n@@ -3482,7 +3487,7 @@ coerce_template_parms (parms, args, in_decl,\n \t\t       require_all_arguments)\n      tree parms, args;\n      tree in_decl;\n-     int complain;\n+     tsubst_flags_t complain;\n      int require_all_arguments;\n {\n   int nparms, nargs, i, lost = 0;\n@@ -3499,7 +3504,7 @@ coerce_template_parms (parms, args, in_decl,\n \t  && require_all_arguments\n \t  && TREE_PURPOSE (TREE_VEC_ELT (parms, nargs)) == NULL_TREE))\n     {\n-      if (complain) \n+      if (complain & tf_error) \n \t{\n \t  error (\"wrong number of template arguments (%d, should be %d)\",\n \t\t    nargs, nparms);\n@@ -3831,7 +3836,7 @@ maybe_get_template_decl_from_type_decl (decl)\n    If ENTERING_SCOPE is non-zero, we are about to enter the scope of\n    the class we are looking up.\n    \n-   If COMPLAIN is non-zero, issue error messages.\n+   Issue error and warning messages under control of COMPLAIN.\n \n    If the template class is really a local class in a template\n    function, then the FUNCTION_CONTEXT is the function in which it is\n@@ -3843,7 +3848,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n      tree in_decl;\n      tree context;\n      int entering_scope;\n-     int complain;\n+     tsubst_flags_t complain;\n {\n   tree template = NULL_TREE, parmlist;\n   tree t;\n@@ -3901,7 +3906,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n      crash. Alternatively D1 might not be a template type at all.  */\n   if (! template)\n     {\n-      if (complain)\n+      if (complain & tf_error)\n         error (\"`%T' is not a template\", d1);\n       return error_mark_node;\n     }\n@@ -3913,7 +3918,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n           && !DECL_TEMPLATE_PARM_P (template)\n           && !PRIMARY_TEMPLATE_P (template)))\n     {\n-      if (complain)\n+      if (complain & tf_error)\n         {\n           error (\"non-template type `%T' used as a template\", d1);\n           if (in_decl)\n@@ -4111,7 +4116,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n \t}\n       \n       context = tsubst (DECL_CONTEXT (template), arglist,\n-\t\t\t/*complain=*/0, in_decl);\n+\t\t\tcomplain, in_decl);\n       if (!context)\n \tcontext = global_namespace;\n \n@@ -4218,7 +4223,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n                  Create the partial instantiation.\n                */\n               TREE_VEC_LENGTH (arglist)--;\n-              found = tsubst (template, arglist, /*complain=*/0, NULL_TREE);\n+              found = tsubst (template, arglist, complain, NULL_TREE);\n               TREE_VEC_LENGTH (arglist)++;\n             }\n \t}\n@@ -4592,21 +4597,21 @@ tsubst_friend_function (decl, args)\n          current cless with same name.  */\n       push_nested_namespace (ns);\n       fns = tsubst_expr (DECL_TI_TEMPLATE (decl), args,\n-                         /*complain=*/1, NULL_TREE);\n+                         tf_error | tf_warning, NULL_TREE);\n       pop_nested_namespace (ns);\n       arglist = tsubst (DECL_TI_ARGS (decl), args,\n-                        /*complain=*/1, NULL_TREE);\n+                        tf_error | tf_warning, NULL_TREE);\n       template_id = lookup_template_function (fns, arglist);\n       \n-      new_friend = tsubst (decl, args, /*complain=*/1, NULL_TREE);\n+      new_friend = tsubst (decl, args, tf_error | tf_warning, NULL_TREE);\n       tmpl = determine_specialization (template_id, new_friend,\n \t\t\t\t       &new_args, \n \t\t\t\t       /*need_member_template=*/0);\n       new_friend = instantiate_template (tmpl, new_args);\n       goto done;\n     }\n \n-  new_friend = tsubst (decl, args, /*complain=*/1, NULL_TREE);\n+  new_friend = tsubst (decl, args, tf_error | tf_warning, NULL_TREE);\n \t\n   /* The NEW_FRIEND will look like an instantiation, to the\n      compiler, but is not an instantiation from the point of view of\n@@ -4824,7 +4829,7 @@ tsubst_friend_class (friend_tmpl, args)\n \t at.  */\n       tree parms \n \t= tsubst_template_parms (DECL_TEMPLATE_PARMS (friend_tmpl),\n-\t\t\t\t args, /*complain=*/1);\n+\t\t\t\t args, tf_error | tf_warning);\n       if (!parms)\n         return error_mark_node;\n       redeclare_class_template (TREE_TYPE (tmpl), parms);\n@@ -4835,7 +4840,7 @@ tsubst_friend_class (friend_tmpl, args)\n       /* The friend template has not already been declared.  In this\n \t case, the instantiation of the template class will cause the\n \t injection of this template into the global scope.  */\n-      tmpl = tsubst (friend_tmpl, args, /*complain=*/1, NULL_TREE);\n+      tmpl = tsubst (friend_tmpl, args, tf_error | tf_warning, NULL_TREE);\n \n       /* The new TMPL is not an instantiation of anything, so we\n  \t forget its origins.  We don't reset CLASSTYPE_TI_TEMPLATE for\n@@ -5062,8 +5067,7 @@ instantiate_class_template (type)\n \t  pbase = TREE_VEC_ELT (pbases, i);\n \n \t  /* Substitute to figure out the base class.  */\n-\t  base = tsubst (BINFO_TYPE (pbase), args, \n-\t\t\t /*complain=*/1, NULL_TREE);\n+\t  base = tsubst (BINFO_TYPE (pbase), args, tf_error, NULL_TREE);\n \t  if (base == error_mark_node)\n \t    continue;\n \n@@ -5117,7 +5121,7 @@ instantiate_class_template (type)\n       tree name = TYPE_IDENTIFIER (tag);\n       tree newtag;\n \n-      newtag = tsubst (tag, args, /*complain=*/1, NULL_TREE);\n+      newtag = tsubst (tag, args, tf_error, NULL_TREE);\n       my_friendly_assert (newtag != error_mark_node, 20010206);\n       if (TREE_CODE (newtag) != ENUMERAL_TYPE)\n \t{\n@@ -5155,14 +5159,14 @@ instantiate_class_template (type)\n \tlineno = DECL_SOURCE_LINE (t);\n \tinput_filename = DECL_SOURCE_FILE (t);\n \n-\tr = tsubst (t, args, /*complain=*/1, NULL_TREE);\n+\tr = tsubst (t, args, tf_error | tf_warning, NULL_TREE);\n \tif (TREE_CODE (r) == VAR_DECL)\n \t  {\n \t    tree init;\n \n \t    if (DECL_INITIALIZED_IN_CLASS_P (r))\n \t      init = tsubst_expr (DECL_INITIAL (t), args,\n-\t\t\t\t  /*complain=*/1, NULL_TREE);\n+\t\t\t\t  tf_error | tf_warning, NULL_TREE);\n \t    else\n \t      init = NULL_TREE;\n \n@@ -5190,7 +5194,7 @@ instantiate_class_template (type)\n      for this instantiation.  */\n   for (t = TYPE_METHODS (pattern); t; t = TREE_CHAIN (t))\n     {\n-      tree r = tsubst (t, args, /*complain=*/1, NULL_TREE);\n+      tree r = tsubst (t, args, tf_error, NULL_TREE);\n       set_current_access_from_decl (r);\n       grok_special_member_properties (r);\n       finish_member_declaration (r);\n@@ -5225,8 +5229,8 @@ instantiate_class_template (type)\n       if (TREE_CODE (friend_type) == TEMPLATE_DECL)\n \tnew_friend_type = tsubst_friend_class (friend_type, args);\n       else if (uses_template_parms (friend_type))\n-\tnew_friend_type = tsubst (friend_type, args, /*complain=*/1,\n-\t\t\t\t  NULL_TREE);\n+\tnew_friend_type = tsubst (friend_type, args,\n+\t\t\t\t  tf_error | tf_warning, NULL_TREE);\n       else \n \t{\n \t  tree ns = decl_namespace_context (TYPE_MAIN_DECL (friend_type));\n@@ -5350,7 +5354,7 @@ static tree\n tsubst_template_arg_vector (t, args, complain)\n      tree t;\n      tree args;\n-     int complain;\n+     tsubst_flags_t complain;\n {\n   int len = TREE_VEC_LENGTH (t), need_new = 0, i;\n   tree *elts = (tree *) alloca (len * sizeof (tree));\n@@ -5396,7 +5400,7 @@ static tree\n tsubst_template_parms (parms, args, complain)\n      tree parms;\n      tree args;\n-     int complain;\n+     tsubst_flags_t complain;\n {\n   tree r = NULL_TREE;\n   tree* new_parms;\n@@ -5443,7 +5447,7 @@ static tree\n tsubst_aggr_type (t, args, complain, in_decl, entering_scope)\n      tree t;\n      tree args;\n-     int complain;\n+     tsubst_flags_t complain;\n      tree in_decl;\n      int entering_scope;\n {\n@@ -5491,8 +5495,7 @@ tsubst_aggr_type (t, args, complain, in_decl, entering_scope)\n   \t  r = lookup_template_class (t, argvec, in_decl, context,\n \t\t\t\t     entering_scope, complain);\n \n-\t  return cp_build_qualified_type_real (r, TYPE_QUALS (t),\n-\t\t\t\t\t       complain);\n+\t  return cp_build_qualified_type_real (r, TYPE_QUALS (t), complain);\n \t}\n       else \n \t/* This is not a template type, so there's nothing to do.  */\n@@ -5527,7 +5530,8 @@ tsubst_default_argument (fn, type, arg)\n   if (DECL_CLASS_SCOPE_P (fn))\n     pushclass (DECL_CONTEXT (fn), 2);\n \n-  arg = tsubst_expr (arg, DECL_TI_ARGS (fn), /*complain=*/1, NULL_TREE);\n+  arg = tsubst_expr (arg, DECL_TI_ARGS (fn),\n+\t\t     tf_error | tf_warning, NULL_TREE);\n   \n   if (DECL_CLASS_SCOPE_P (fn))\n     popclass ();\n@@ -5565,19 +5569,23 @@ tsubst_default_arguments (fn)\n \n /* Substitute the ARGS into the T, which is a _DECL.  TYPE is the\n    (already computed) substitution of ARGS into TREE_TYPE (T), if\n-   appropriate.  Return the result of the substitution.  */\n+   appropriate.  Return the result of the substitution.  Issue error\n+   and warning messages under control of COMPLAIN.  */\n \n static tree\n-tsubst_decl (t, args, type)\n+tsubst_decl (t, args, type, complain)\n      tree t;\n      tree args;\n      tree type;\n+     tsubst_flags_t complain;\n {\n   int saved_lineno;\n   const char *saved_filename;\n   tree r = NULL_TREE;\n   tree in_decl = t;\n \n+  my_friendly_assert (complain & tf_error, 20011214);\n+  \n   /* Set the filename and linenumber to improve error-reporting.  */\n   saved_lineno = lineno;\n   saved_filename = input_filename;\n@@ -5606,7 +5614,7 @@ tsubst_decl (t, args, type)\n \t    tree full_args;\n \t    \n \t    full_args = tsubst_template_arg_vector (tmpl_args, args,\n-\t\t\t\t\t\t    /*complain=*/1);\n+\t\t\t\t\t\t    complain);\n \n \t    /* tsubst_template_arg_vector doesn't copy the vector if\n \t       nothing changed.  But, *something* should have\n@@ -5632,34 +5640,33 @@ tsubst_decl (t, args, type)\n \n \tif (is_template_template_parm)\n \t  {\n-\t    tree new_decl = tsubst (decl, args, /*complain=*/1, in_decl);\n+\t    tree new_decl = tsubst (decl, args, complain, in_decl);\n \t    DECL_TEMPLATE_RESULT (r) = new_decl;\n \t    TREE_TYPE (r) = TREE_TYPE (new_decl);\n \t    break;\n \t  }\n \n \tDECL_CONTEXT (r) \n \t  = tsubst_aggr_type (DECL_CONTEXT (t), args, \n-\t\t\t      /*complain=*/1, in_decl, \n+\t\t\t      complain, in_decl, \n \t\t\t      /*entering_scope=*/1); \n \tDECL_VIRTUAL_CONTEXT (r) \n \t  = tsubst_aggr_type (DECL_VIRTUAL_CONTEXT (t), args, \n-\t\t\t      /*complain=*/1, in_decl, \n+\t\t\t      complain, in_decl, \n \t\t\t      /*entering_scope=*/1);\n \tDECL_TEMPLATE_INFO (r) = build_tree_list (t, args);\n \n \tif (TREE_CODE (decl) == TYPE_DECL)\n \t  {\n-\t    tree new_type = tsubst (TREE_TYPE (t), args,\n-\t\t\t\t    /*complain=*/1, in_decl);\n+\t    tree new_type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n \t    TREE_TYPE (r) = new_type;\n \t    CLASSTYPE_TI_TEMPLATE (new_type) = r;\n \t    DECL_TEMPLATE_RESULT (r) = TYPE_MAIN_DECL (new_type);\n \t    DECL_TI_ARGS (r) = CLASSTYPE_TI_ARGS (new_type);\n \t  }\n \telse\n \t  {\n-\t    tree new_decl = tsubst (decl, args, /*complain=*/1, in_decl);\n+\t    tree new_decl = tsubst (decl, args, complain, in_decl);\n \n \t    DECL_TEMPLATE_RESULT (r) = new_decl;\n \t    DECL_TI_TEMPLATE (new_decl) = r;\n@@ -5676,7 +5683,7 @@ tsubst_decl (t, args, type)\n \t   outermost level of parameters. */\n \tDECL_TEMPLATE_PARMS (r) \n \t  = tsubst_template_parms (DECL_TEMPLATE_PARMS (t), args,\n-\t\t\t\t   /*complain=*/1);\n+\t\t\t\t   complain);\n \n \tif (PRIMARY_TEMPLATE_P (t))\n \t  DECL_PRIMARY_TEMPLATE (r) = r;\n@@ -5716,7 +5723,7 @@ tsubst_decl (t, args, type)\n \t    argvec \n \t      = tsubst_template_arg_vector (DECL_TI_ARGS \n \t\t\t\t\t    (DECL_TEMPLATE_RESULT (gen_tmpl)),\n-\t\t\t\t\t    args, /*complain=*/1); \n+\t\t\t\t\t    args, complain); \n \n \t    /* Check to see if we already have this specialization.  */\n \t    spec = retrieve_specialization (gen_tmpl, argvec);\n@@ -5793,15 +5800,15 @@ tsubst_decl (t, args, type)\n \t    else\n \t      member = 1;\n \t    ctx = tsubst_aggr_type (DECL_CONTEXT (t), args, \n-\t\t\t\t    /*complain=*/1, t, \n+\t\t\t\t    complain, t, \n \t\t\t\t    /*entering_scope=*/1);\n \t  }\n \telse\n \t  {\n \t    member = 0;\n \t    ctx = DECL_CONTEXT (t);\n \t  }\n-\ttype = tsubst (type, args, /*complain=*/1, in_decl);\n+\ttype = tsubst (type, args, complain, in_decl);\n \tif (type == error_mark_node)\n \t  return error_mark_node;\n \n@@ -5819,7 +5826,7 @@ tsubst_decl (t, args, type)\n \tDECL_CONTEXT (r) = ctx;\n \tDECL_VIRTUAL_CONTEXT (r)\n \t  = tsubst_aggr_type (DECL_VIRTUAL_CONTEXT (t), args, \n-\t\t\t      /*complain=*/1, t,\n+\t\t\t      complain, t,\n \t\t\t      /*entering_scope=*/1);\n \n \tif (member && DECL_CONV_FN_P (r)) \n@@ -5828,7 +5835,7 @@ tsubst_decl (t, args, type)\n \t  DECL_NAME (r) = mangle_conv_op_name_for_type (TREE_TYPE (type));\n \n \tDECL_ARGUMENTS (r) = tsubst (DECL_ARGUMENTS (t), args,\n-\t\t\t\t     /*complain=*/1, t);\n+\t\t\t\t     complain, t);\n \tDECL_RESULT (r) = NULL_TREE;\n \n \tTREE_STATIC (r) = 0;\n@@ -5844,7 +5851,7 @@ tsubst_decl (t, args, type)\n \tif (DECL_CLONED_FUNCTION (r))\n \t  {\n \t    DECL_CLONED_FUNCTION (r) = tsubst (DECL_CLONED_FUNCTION (t),\n-\t\t\t\t\t       args, /*complain=*/1, t);\n+\t\t\t\t\t       args, complain, t);\n \t    TREE_CHAIN (r) = TREE_CHAIN (DECL_CLONED_FUNCTION (r));\n \t    TREE_CHAIN (DECL_CLONED_FUNCTION (r)) = r;\n \t  }\n@@ -5883,7 +5890,7 @@ tsubst_decl (t, args, type)\n \t  {\n \t    *friends = copy_node (*friends);\n \t    TREE_VALUE (*friends) = tsubst (TREE_VALUE (*friends),\n-\t\t\t\t\t    args, /*complain=*/1, \n+\t\t\t\t\t    args, complain,\n \t\t\t\t\t    in_decl);\n \t  }\n \n@@ -5916,7 +5923,7 @@ tsubst_decl (t, args, type)\n \t  DECL_INITIAL (r) = TREE_TYPE (r);\n \telse\n \t  DECL_INITIAL (r) = tsubst (DECL_INITIAL (r), args,\n-\t\t\t\t     /*complain=*/1, in_decl);\n+\t\t\t\t     complain, in_decl);\n \n \tDECL_CONTEXT (r) = NULL_TREE;\n \tif (!DECL_TEMPLATE_PARM_P (r) && PROMOTE_PROTOTYPES\n@@ -5925,7 +5932,7 @@ tsubst_decl (t, args, type)\n \t  DECL_ARG_TYPE (r) = integer_type_node;\n \tif (TREE_CHAIN (t))\n \t  TREE_CHAIN (r) = tsubst (TREE_CHAIN (t), args,\n-\t\t\t\t   /*complain=*/1, TREE_CHAIN (t));\n+\t\t\t\t   complain, TREE_CHAIN (t));\n       }\n       break;\n \n@@ -5938,7 +5945,7 @@ tsubst_decl (t, args, type)\n \t/* We don't have to set DECL_CONTEXT here; it is set by\n \t   finish_member_declaration.  */\n \tDECL_INITIAL (r) = tsubst_expr (DECL_INITIAL (t), args,\n-\t\t\t\t\t/*complain=*/1, in_decl);\n+\t\t\t\t\tcomplain, in_decl);\n \tTREE_CHAIN (r) = NULL_TREE;\n \tif (VOID_TYPE_P (type)) \n \t  cp_error_at (\"instantiation of `%D' as type `%T'\", r, type);\n@@ -5949,7 +5956,7 @@ tsubst_decl (t, args, type)\n       {\n \tr = copy_node (t);\n \tDECL_INITIAL (r)\n-\t  = tsubst_copy (DECL_INITIAL (t), args, /*complain=*/1, in_decl);\n+\t  = tsubst_copy (DECL_INITIAL (t), args, complain, in_decl);\n \tTREE_CHAIN (r) = NULL_TREE;\n       }\n       break;\n@@ -5982,7 +5989,7 @@ tsubst_decl (t, args, type)\n \n \tif (TYPE_P (CP_DECL_CONTEXT (t)))\n \t  ctx = tsubst_aggr_type (DECL_CONTEXT (t), args, \n-\t\t\t\t  /*complain=*/1,\n+\t\t\t\t  complain,\n \t\t\t\t  in_decl, /*entering_scope=*/1);\n \telse if (DECL_NAMESPACE_SCOPE_P (t))\n \t  ctx = DECL_CONTEXT (t);\n@@ -5998,7 +6005,7 @@ tsubst_decl (t, args, type)\n \t  {\n \t    tmpl = DECL_TI_TEMPLATE (t);\n \t    gen_tmpl = most_general_template (tmpl);\n-\t    argvec = tsubst (DECL_TI_ARGS (t), args, /*complain=*/1, in_decl);\n+\t    argvec = tsubst (DECL_TI_ARGS (t), args, complain, in_decl);\n \t    spec = retrieve_specialization (gen_tmpl, argvec);\n \t  }\n \telse\n@@ -6076,7 +6083,7 @@ static tree\n tsubst_arg_types (arg_types, args, complain, in_decl)\n      tree arg_types;\n      tree args;\n-     int complain;\n+     tsubst_flags_t complain;\n      tree in_decl;\n {\n   tree remaining_arg_types;\n@@ -6095,7 +6102,7 @@ tsubst_arg_types (arg_types, args, complain, in_decl)\n     return error_mark_node;\n   if (VOID_TYPE_P (type))\n     {\n-      if (complain)\n+      if (complain & tf_error)\n         {\n           error (\"invalid parameter type `%T'\", type);\n           if (in_decl)\n@@ -6137,7 +6144,7 @@ static tree\n tsubst_function_type (t, args, complain, in_decl)\n      tree t;\n      tree args;\n-     int complain;\n+     tsubst_flags_t complain;\n      tree in_decl;\n {\n   tree return_type;\n@@ -6173,7 +6180,7 @@ tsubst_function_type (t, args, complain, in_decl)\n \t     \n \t     -- Attempting to create \"pointer to member of T\" when T\n \t     is not a class type.  */\n-\t  if (complain)\n+\t  if (complain & tf_error)\n \t    error (\"creating pointer to member function of non-class type `%T'\",\n \t\t      r);\n \t  return error_mark_node;\n@@ -6182,7 +6189,7 @@ tsubst_function_type (t, args, complain, in_decl)\n       fntype = build_cplus_method_type (r, return_type, TREE_CHAIN\n \t\t\t\t\t(arg_types));\n     }\n-  fntype = build_qualified_type (fntype, TYPE_QUALS (t));\n+  fntype = cp_build_qualified_type_real (fntype, TYPE_QUALS (t), complain);\n   fntype = build_type_attribute_variant (fntype, TYPE_ATTRIBUTES (t));\n   \n   return fntype;  \n@@ -6194,7 +6201,7 @@ static tree\n tsubst_call_declarator_parms (parms, args, complain, in_decl)\n      tree parms;\n      tree args;\n-     int complain;\n+     tsubst_flags_t complain;\n      tree in_decl;\n {\n   tree new_parms;\n@@ -6228,23 +6235,23 @@ tsubst_call_declarator_parms (parms, args, complain, in_decl)\n /* Take the tree structure T and replace template parameters used\n    therein with the argument vector ARGS.  IN_DECL is an associated\n    decl for diagnostics.  If an error occurs, returns ERROR_MARK_NODE.\n-   An appropriate error message is issued only if COMPLAIN is\n-   non-zero.  Note that we must be relatively non-tolerant of\n-   extensions here, in order to preserve conformance; if we allow\n-   substitutions that should not be allowed, we may allow argument\n-   deductions that should not succeed, and therefore report ambiguous\n-   overload situations where there are none.  In theory, we could\n-   allow the substitution, but indicate that it should have failed,\n-   and allow our caller to make sure that the right thing happens, but\n-   we don't try to do this yet.\n+   Issue error and warning messages under control of COMPLAIN.  Note\n+   that we must be relatively non-tolerant of extensions here, in\n+   order to preserve conformance; if we allow substitutions that\n+   should not be allowed, we may allow argument deductions that should\n+   not succeed, and therefore report ambiguous overload situations\n+   where there are none.  In theory, we could allow the substitution,\n+   but indicate that it should have failed, and allow our caller to\n+   make sure that the right thing happens, but we don't try to do this\n+   yet.\n \n    This function is used for dealing with types, decls and the like;\n    for expressions, use tsubst_expr or tsubst_copy.  */\n \n tree\n tsubst (t, args, complain, in_decl)\n      tree t, args;\n-     int complain;\n+     tsubst_flags_t complain;\n      tree in_decl;\n {\n   tree type, r;\n@@ -6274,7 +6281,7 @@ tsubst (t, args, complain, in_decl)\n     return error_mark_node;\n \n   if (DECL_P (t))\n-    return tsubst_decl (t, args, type);\n+    return tsubst_decl (t, args, type, complain);\n \n   switch (TREE_CODE (t))\n     {\n@@ -6350,7 +6357,7 @@ tsubst (t, args, complain, in_decl)\n \n \t\t Attempting to create an array with a size that is\n \t\t zero or negative.  */\n-\t    if (complain)\n+\t    if (complain & tf_error)\n \t      error (\"creating array with size zero (`%E')\", max);\n \n \t    return error_mark_node;\n@@ -6424,9 +6431,8 @@ tsubst (t, args, complain, in_decl)\n \t\t\t\t\t       DECL_CONTEXT (arg),\n \t\t\t\t\t       /*entering_scope=*/0,\n \t                                       complain);\n-\t\t    return cp_build_qualified_type_real (r, \n-\t\t\t\t\t\t         TYPE_QUALS (t),\n-\t\t\t\t\t\t         complain);\n+\t\t    return cp_build_qualified_type_real\n+\t\t      (r, TYPE_QUALS (t), complain);\n \t\t  }\n \t\telse\n \t\t  /* TEMPLATE_TEMPLATE_PARM or TEMPLATE_PARM_INDEX.  */\n@@ -6453,8 +6459,8 @@ tsubst (t, args, complain, in_decl)\n \t    if (cp_type_quals (t))\n \t      {\n \t\tr = tsubst (TYPE_MAIN_VARIANT (t), args, complain, in_decl);\n-\t\tr = cp_build_qualified_type_real (r, cp_type_quals (t),\n-\t\t\t\t\t\t  complain);\n+\t\tr = cp_build_qualified_type_real\n+\t\t  (r, cp_type_quals (t), complain);\n \t      }\n \t    else\n \t      {\n@@ -6585,8 +6591,8 @@ tsubst (t, args, complain, in_decl)\n \t    /* We keep track of the last time we issued this error\n \t       message to avoid spewing a ton of messages during a\n \t       single bad template instantiation.  */\n-\t    if (complain && (last_line != lineno ||\n-\t\t\t     last_file != input_filename))\n+\t    if (complain & tf_error\n+\t\t&& (last_line != lineno || last_file != input_filename))\n \t      {\n \t\tif (TREE_CODE (type) == VOID_TYPE)\n \t\t  error (\"forming reference to void\");\n@@ -6628,9 +6634,8 @@ tsubst (t, args, complain, in_decl)\n \t       \n \t       -- Attempting to create \"pointer to member of T\" when T\n \t          is not a class type.  */\n-\t    if (complain)\n-\t      error (\"creating pointer to member of non-class type `%T'\", \n-\t\t\tr);\n+\t    if (complain & tf_error)\n+\t      error (\"creating pointer to member of non-class type `%T'\", r);\n \t    return error_mark_node;\n \t  }\n \tif (TREE_CODE (type) == REFERENCE_TYPE)\n@@ -6713,7 +6718,7 @@ tsubst (t, args, complain, in_decl)\n \t    || TREE_CODE (type) == FUNCTION_TYPE\n \t    || TREE_CODE (type) == REFERENCE_TYPE)\n \t  {\n-\t    if (complain)\n+\t    if (complain & tf_error)\n \t      error (\"creating array of `%T'\", type);\n \t    return error_mark_node;\n \t  }\n@@ -6725,10 +6730,8 @@ tsubst (t, args, complain, in_decl)\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n       {\n-\ttree e1 = tsubst (TREE_OPERAND (t, 0), args, complain,\n-\t\t\t  in_decl);\n-\ttree e2 = tsubst (TREE_OPERAND (t, 1), args, complain,\n-\t\t\t  in_decl);\n+\ttree e1 = tsubst (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\ttree e2 = tsubst (TREE_OPERAND (t, 1), args, complain, in_decl);\n \n \tif (e1 == error_mark_node || e2 == error_mark_node)\n \t  return error_mark_node;\n@@ -6739,8 +6742,7 @@ tsubst (t, args, complain, in_decl)\n     case NEGATE_EXPR:\n     case NOP_EXPR:\n       {\n-\ttree e = tsubst (TREE_OPERAND (t, 0), args, complain,\n-\t\t\t  in_decl);\n+\ttree e = tsubst (TREE_OPERAND (t, 0), args, complain, in_decl);\n \tif (e == error_mark_node)\n \t  return error_mark_node;\n \n@@ -6759,7 +6761,7 @@ tsubst (t, args, complain, in_decl)\n \n \tif (!IS_AGGR_TYPE (ctx))\n \t  {\n-\t    if (complain)\n+\t    if (complain & tf_error)\n \t      error (\"`%T' is not a class, struct, or union type\",\n \t\t\tctx);\n \t    return error_mark_node;\n@@ -6777,21 +6779,19 @@ tsubst (t, args, complain, in_decl)\n \t    ctx = complete_type (ctx);\n \t    if (!COMPLETE_TYPE_P (ctx))\n \t      {\n-\t\tif (complain)\n+\t\tif (complain & tf_error)\n \t\t  incomplete_type_error (NULL_TREE, ctx);\n \t\treturn error_mark_node;\n \t      }\n \t  }\n \n-\tf = make_typename_type (ctx, f, complain);\n+\tf = make_typename_type (ctx, f, complain & tf_error);\n \tif (f == error_mark_node)\n \t  return f;\n-\treturn cp_build_qualified_type_real (f, \n-\t\t\t\t\t     cp_type_quals (f) \n-\t\t\t\t\t     | cp_type_quals (t),\n-\t\t\t\t\t     complain);\n+\treturn cp_build_qualified_type_real\n+\t  (f, cp_type_quals (f) | cp_type_quals (t), complain);\n       }\n-\n+\t       \n     case UNBOUND_CLASS_TEMPLATE:\n       {\n \ttree ctx = tsubst_aggr_type (TYPE_CONTEXT (t), args, complain,\n@@ -6806,28 +6806,24 @@ tsubst (t, args, complain, in_decl)\n \n     case INDIRECT_REF:\n       {\n-\ttree e = tsubst (TREE_OPERAND (t, 0), args, complain,\n-\t\t\t in_decl);\n+\ttree e = tsubst (TREE_OPERAND (t, 0), args, complain, in_decl);\n \tif (e == error_mark_node)\n \t  return error_mark_node;\n \treturn make_pointer_declarator (type, e);\n       }\n \n     case ADDR_EXPR:\n       {\n-\ttree e = tsubst (TREE_OPERAND (t, 0), args, complain,\n-\t\t\t in_decl);\n+\ttree e = tsubst (TREE_OPERAND (t, 0), args, complain, in_decl);\n \tif (e == error_mark_node)\n \t  return error_mark_node;\n \treturn make_reference_declarator (type, e);\n       }\n \n     case ARRAY_REF:\n       {\n-\ttree e1 = tsubst (TREE_OPERAND (t, 0), args, complain,\n-\t\t\t  in_decl);\n-\ttree e2 = tsubst_expr (TREE_OPERAND (t, 1), args, complain,\n-\t\t\t       in_decl);\n+\ttree e1 = tsubst (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\ttree e2 = tsubst_expr (TREE_OPERAND (t, 1), args, complain, in_decl);\n \tif (e1 == error_mark_node || e2 == error_mark_node)\n \t  return error_mark_node;\n \n@@ -6836,8 +6832,7 @@ tsubst (t, args, complain, in_decl)\n \n     case CALL_EXPR:\n       {\n-\ttree e1 = tsubst (TREE_OPERAND (t, 0), args, complain,\n-\t\t\t  in_decl);\n+\ttree e1 = tsubst (TREE_OPERAND (t, 0), args, complain, in_decl);\n \ttree e2 = (tsubst_call_declarator_parms\n \t\t   (CALL_DECLARATOR_PARMS (t), args, complain, in_decl));\n \ttree e3 = tsubst (CALL_DECLARATOR_EXCEPTION_SPEC (t), args,\n@@ -6852,8 +6847,7 @@ tsubst (t, args, complain, in_decl)\n \n     case SCOPE_REF:\n       {\n-\ttree e1 = tsubst (TREE_OPERAND (t, 0), args, complain,\n-\t\t\t\t  in_decl);\n+\ttree e1 = tsubst (TREE_OPERAND (t, 0), args, complain, in_decl);\n \ttree e2 = tsubst (TREE_OPERAND (t, 1), args, complain, in_decl);\n \tif (e1 == error_mark_node || e2 == error_mark_node)\n \t  return error_mark_node;\n@@ -6863,8 +6857,7 @@ tsubst (t, args, complain, in_decl)\n \n     case TYPEOF_TYPE:\n       {\n-\ttree e1 = tsubst_expr (TYPE_FIELDS (t), args, complain,\n-\t\t\t       in_decl);\n+\ttree e1 = tsubst_expr (TYPE_FIELDS (t), args, complain, in_decl);\n \tif (e1 == error_mark_node)\n \t  return error_mark_node;\n \n@@ -6885,7 +6878,7 @@ tsubst (t, args, complain, in_decl)\n tree\n tsubst_copy (t, args, complain, in_decl)\n      tree t, args;\n-     int complain;\n+     tsubst_flags_t complain;\n      tree in_decl;\n {\n   enum tree_code code;\n@@ -7104,8 +7097,7 @@ tsubst_copy (t, args, complain, in_decl)\n       if (!processing_template_decl)\n \t{\n \t  tree stmt_expr = begin_stmt_expr ();\n-\t  tsubst_expr (STMT_EXPR_STMT (t), args,\n-\t\t       complain, in_decl);\n+\t  tsubst_expr (STMT_EXPR_STMT (t), args, complain, in_decl);\n \t  return finish_stmt_expr (stmt_expr);\n \t}\n       \n@@ -7230,8 +7222,8 @@ tsubst_copy (t, args, complain, in_decl)\n \n     case VA_ARG_EXPR:\n       return build_x_va_arg (tsubst_copy (TREE_OPERAND (t, 0), args, complain,\n-\t\t\t\t\tin_decl),\n-\t\t\t   tsubst (TREE_TYPE (t), args, complain, in_decl));\n+\t\t\t\t\t  in_decl),\n+\t\t\t     tsubst (TREE_TYPE (t), args, complain, in_decl));\n \n     default:\n       return t;\n@@ -7243,7 +7235,7 @@ tsubst_copy (t, args, complain, in_decl)\n tree\n tsubst_expr (t, args, complain, in_decl)\n      tree t, args;\n-     int complain;\n+     tsubst_flags_t complain;\n      tree in_decl;\n {\n   tree stmt, tmp;\n@@ -7263,7 +7255,7 @@ tsubst_expr (t, args, complain, in_decl)\n       prep_stmt (t);\n       finish_named_return_value\n \t(TREE_OPERAND (t, 0),\n-\t tsubst_expr (TREE_OPERAND (t, 1), args, /*complain=*/1, in_decl));\n+\t tsubst_expr (TREE_OPERAND (t, 1), args, complain, in_decl));\n       break;\n \n     case CTOR_INITIALIZER:\n@@ -7357,8 +7349,8 @@ tsubst_expr (t, args, complain, in_decl)\n \tstmt = begin_for_stmt ();\n \ttsubst_expr (FOR_INIT_STMT (t), args, complain, in_decl);\n \tfinish_for_init_stmt (stmt);\n-\tfinish_for_cond (tsubst_expr (FOR_COND (t), args,\n-\t\t\t\t      complain, in_decl),\n+\tfinish_for_cond (tsubst_expr (FOR_COND (t),\n+\t\t\t\t      args, complain, in_decl),\n \t\t\t stmt);\n \ttmp = tsubst_expr (FOR_EXPR (t), args, complain, in_decl);\n \tfinish_for_expr (tmp, stmt);\n@@ -7385,8 +7377,8 @@ tsubst_expr (t, args, complain, in_decl)\n \tstmt = begin_do_stmt ();\n \ttsubst_expr (DO_BODY (t), args, complain, in_decl);\n \tfinish_do_body (stmt);\n-\tfinish_do_stmt (tsubst_expr (DO_COND (t), args,\n-\t\t\t\t     complain, in_decl),\n+\tfinish_do_stmt (tsubst_expr (DO_COND (t),\n+\t\t\t\t     args, complain, in_decl),\n \t\t\tstmt);\n       }\n       break;\n@@ -7638,7 +7630,7 @@ instantiate_template (tmpl, targ_ptr)\n \n   /* substitute template parameters */\n   fndecl = tsubst (DECL_TEMPLATE_RESULT (gen_tmpl),\n-\t\t   targ_ptr, /*complain=*/1, gen_tmpl);\n+\t\t   targ_ptr, tf_error, gen_tmpl);\n   /* The DECL_TI_TEMPLATE should always be the immediate parent\n      template, not the most general template.  */\n   DECL_TI_TEMPLATE (fndecl) = tmpl;\n@@ -7735,12 +7727,12 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n \n       converted_args\n \t= (coerce_template_parms (DECL_INNERMOST_TEMPLATE_PARMS (fn), \n-\t\t\t\t  explicit_targs, NULL_TREE, /*complain=*/0, \n+\t\t\t\t  explicit_targs, NULL_TREE, tf_none, \n \t\t\t\t  /*require_all_arguments=*/0));\n       if (converted_args == error_mark_node)\n \treturn 1;\n \n-      fntype = tsubst (fntype, converted_args, /*complain=*/0, NULL_TREE);\n+      fntype = tsubst (fntype, converted_args, tf_none, NULL_TREE);\n       if (fntype == error_mark_node)\n \treturn 1;\n \n@@ -7781,7 +7773,7 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n        the corresponding deduced argument values.  If the\n        substitution results in an invalid type, as described above,\n        type deduction fails.  */\n-    if (tsubst (TREE_TYPE (fn), targs, /*complain=*/0, NULL_TREE)\n+    if (tsubst (TREE_TYPE (fn), targs, tf_none, NULL_TREE)\n \t== error_mark_node)\n       return 1;\n \n@@ -8117,8 +8109,7 @@ resolve_overloaded_unification (tparms, targs, parm, arg, strict,\n \t\t\t\t\t   expl_subargs);\n \t  if (subargs)\n \t    {\n-\t      elem = tsubst (TREE_TYPE (fn), subargs, /*complain=*/0,\n-\t\t\t     NULL_TREE);\n+\t      elem = tsubst (TREE_TYPE (fn), subargs, tf_none, NULL_TREE);\n \t      if (TREE_CODE (elem) == METHOD_TYPE)\n \t\telem = build_ptrmemfunc_type (build_pointer_type (elem));\n \t      good += try_one_overload (tparms, targs, tempargs, parm, elem,\n@@ -8256,7 +8247,7 @@ verify_class_unification (targs, parms, args)\n   int i;\n   int nparms = TREE_VEC_LENGTH (parms);\n   tree new_parms = tsubst (parms, add_outermost_template_args (args, targs),\n-  \t\t\t   /*complain=*/0, NULL_TREE);\n+  \t\t\t   tf_none, NULL_TREE);\n   if (new_parms == error_mark_node)\n     return 1;\n \n@@ -8680,11 +8671,8 @@ unify (tparms, targs, parm, arg, strict)\n \n \t  /* Consider the case where ARG is `const volatile int' and\n \t     PARM is `const T'.  Then, T should be `volatile int'.  */\n-\t  arg = \n-\t    cp_build_qualified_type_real (arg,\n-\t\t\t\t\t  cp_type_quals (arg) \n-\t\t\t\t\t  & ~cp_type_quals (parm),\n-\t\t\t\t\t  /*complain=*/0);\n+\t  arg = cp_build_qualified_type_real\n+\t    (arg, cp_type_quals (arg) & ~cp_type_quals (parm), tf_none);\n \t  if (arg == error_mark_node)\n \t    return 1;\n \n@@ -9154,13 +9142,11 @@ get_bindings_real (fn, decl, explicit_args, check_rettype, deduce, len)\n       converted_args\n \t= (coerce_template_parms (DECL_INNERMOST_TEMPLATE_PARMS (tmpl),\n \t\t\t\t  explicit_args, NULL_TREE,\n-\t\t\t\t  /*complain=*/0, \n-\t\t\t\t  /*require_all_arguments=*/0));\n+\t\t\t\t  tf_none, /*require_all_arguments=*/0));\n       if (converted_args == error_mark_node)\n \treturn NULL_TREE;\n       \n-      decl_type = tsubst (decl_type, converted_args, /*complain=*/0, \n-\t\t\t  NULL_TREE); \n+      decl_type = tsubst (decl_type, converted_args, tf_none, NULL_TREE); \n       if (decl_type == error_mark_node)\n \treturn NULL_TREE;\n     }\n@@ -9555,7 +9541,7 @@ mark_class_instantiated (t, extern_p)\n void\n do_type_instantiation (t, storage, complain)\n      tree t, storage;\n-     int complain;\n+     tsubst_flags_t complain;\n {\n   int extern_p = 0;\n   int nomem_p = 0;\n@@ -9579,7 +9565,7 @@ do_type_instantiation (t, storage, complain)\n \n   if (!COMPLETE_TYPE_P (t))\n     {\n-      if (complain)\n+      if (complain & tf_error)\n \terror (\"explicit instantiation of `%#T' before definition of template\",\n \t\t  t);\n       return;\n@@ -9611,7 +9597,7 @@ do_type_instantiation (t, storage, complain)\n \n \t No program shall both explicitly instantiate and explicitly\n \t specialize a template.  */\n-      if (complain)\n+      if (complain & tf_error)\n \t{\n \t  error (\"explicit instantiation of `%#T' after\", t);\n \t  cp_error_at (\"explicit specialization here\", t);\n@@ -9630,7 +9616,7 @@ do_type_instantiation (t, storage, complain)\n \t are we already got marked as an explicit instantiation because of the\n \t repo file.  All these cases are OK.  */\n       if (!CLASSTYPE_INTERFACE_ONLY (t) && !extern_p && !flag_use_repository\n-\t  && complain)\n+\t  && (complain & tf_error))\n \tpedwarn (\"duplicate explicit instantiation of `%#T'\", t);\n       \n       /* If we've already instantiated the template, just return now.  */\n@@ -9750,14 +9736,14 @@ regenerate_decl_from_template (decl, tmpl)\n     pushclass (DECL_CONTEXT (decl), 2);\n \n   /* Do the substitution to get the new declaration.  */\n-  new_decl = tsubst (code_pattern, args, /*complain=*/1, NULL_TREE);\n+  new_decl = tsubst (code_pattern, args, tf_error, NULL_TREE);\n \n   if (TREE_CODE (decl) == VAR_DECL)\n     {\n       /* Set up DECL_INITIAL, since tsubst doesn't.  */\n       DECL_INITIAL (new_decl) = \n \ttsubst_expr (DECL_INITIAL (code_pattern), args, \n-\t\t     /*complain=*/1, DECL_TI_TEMPLATE (decl));\n+\t\t     tf_error, DECL_TI_TEMPLATE (decl));\n       /* Pop the class context we pushed above.  */\n       popclass ();\n     }\n@@ -10027,7 +10013,7 @@ instantiate_decl (d, defer_ok)\n \n       /* Substitute into the body of the function.  */\n       tsubst_expr (DECL_SAVED_TREE (code_pattern), args,\n-\t\t   /*complain=*/1, tmpl);\n+\t\t   tf_error | tf_warning, tmpl);\n \n       /* We don't need the local specializations any more.  */\n       htab_delete (local_specializations);\n@@ -10159,9 +10145,9 @@ tsubst_initializer_list (t, argvec)\n       tree init;\n       tree val;\n \n-      decl = tsubst_copy (TREE_PURPOSE (t), argvec, /*complain=*/1,\n+      decl = tsubst_copy (TREE_PURPOSE (t), argvec, tf_error | tf_warning,\n \t\t\t  NULL_TREE);\n-      init = tsubst_expr (TREE_VALUE (t), argvec, /*complain=*/1,\n+      init = tsubst_expr (TREE_VALUE (t), argvec, tf_error | tf_warning,\n \t\t\t  NULL_TREE);\n \n       if (!init)\n@@ -10211,7 +10197,7 @@ tsubst_enum (tag, newtag, args)\n       /* Note that in a template enum, the TREE_VALUE is the\n \t CONST_DECL, not the corresponding INTEGER_CST.  */\n       value = tsubst_expr (DECL_INITIAL (TREE_VALUE (e)), \n-\t\t\t   args, /*complain=*/1,\n+\t\t\t   args, tf_error | tf_warning,\n \t\t\t   NULL_TREE);\n \n       /* Give this enumeration constant the correct access.  */\n@@ -10280,16 +10266,16 @@ get_mostly_instantiated_function_type (decl, contextp, tparmsp)\n \n       /* Now, do the (partial) substitution to figure out the\n \t appropriate function type.  */\n-      fn_type = tsubst (fn_type, partial_args, /*complain=*/1, NULL_TREE);\n+      fn_type = tsubst (fn_type, partial_args, tf_error, NULL_TREE);\n       if (DECL_STATIC_FUNCTION_P (decl))\n-\tcontext = tsubst (context, partial_args, /*complain=*/1, NULL_TREE);\n+\tcontext = tsubst (context, partial_args, tf_error, NULL_TREE);\n \n       /* Substitute into the template parameters to obtain the real\n \t innermost set of parameters.  This step is important if the\n \t innermost set of template parameters contains value\n \t parameters whose types depend on outer template parameters.  */\n       TREE_VEC_LENGTH (partial_args)--;\n-      tparms = tsubst_template_parms (tparms, partial_args, /*complain=*/1);\n+      tparms = tsubst_template_parms (tparms, partial_args, tf_error);\n     }\n \n   if (contextp)\n@@ -10322,13 +10308,13 @@ current_instantiation ()\n }\n \n /* [temp.param] Check that template non-type parm TYPE is of an allowable\n-   type. Return zero for ok, non-zero for disallowed. If COMPLAIN is\n-   non-zero, then complain. */\n+   type. Return zero for ok, non-zero for disallowed. Issue error and\n+   warning messages under control of COMPLAIN.  */\n \n static int\n invalid_nontype_parm_type_p (type, complain)\n      tree type;\n-     int complain;\n+     tsubst_flags_t complain;\n {\n   if (INTEGRAL_TYPE_P (type))\n     return 0;\n@@ -10343,7 +10329,7 @@ invalid_nontype_parm_type_p (type, complain)\n   else if (TREE_CODE (type) == TYPENAME_TYPE)\n     return 0;\n            \n-  if (complain)\n+  if (complain & tf_error)\n     error (\"`%#T' is not a valid type for a template constant parameter\",\n               type);\n   return 1;"}, {"sha": "2d99e029fe9261412bb6109c1a8d2354b228803d", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=c2ea3a40d9d7f302ba6f9279163d201410b39a4c", "patch": "@@ -505,16 +505,15 @@ build_cplus_array_type (elt_type, index_type)\n \f\n /* Make a variant of TYPE, qualified with the TYPE_QUALS.  Handles\n    arrays correctly.  In particular, if TYPE is an array of T's, and\n-   TYPE_QUALS is non-empty, returns an array of qualified T's.  If\n-   at attempt is made to qualify a type illegally, and COMPLAIN is\n-   non-zero, an error is issued.  If COMPLAIN is zero, error_mark_node\n-   is returned.  */\n+   TYPE_QUALS is non-empty, returns an array of qualified T's.\n+   Errors are emitted under control of COMPLAIN. If COMPLAIN is zero,\n+   error_mark_node is returned for bad qualifiers.  */\n \n tree\n cp_build_qualified_type_real (type, type_quals, complain)\n      tree type;\n      int type_quals;\n-     int complain;\n+     tsubst_flags_t complain;\n {\n   tree result;\n \n@@ -532,7 +531,7 @@ cp_build_qualified_type_real (type, type_quals, complain)\n \t  || TYPE_PTRMEM_P (type)\n \t  || TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE))\n     {\n-      if (complain)\n+      if (complain & tf_error)\n \terror (\"`%T' cannot be `restrict'-qualified\", type);\n       else\n \treturn error_mark_node;\n@@ -543,7 +542,7 @@ cp_build_qualified_type_real (type, type_quals, complain)\n   if (type_quals != TYPE_UNQUALIFIED\n       && TREE_CODE (type) == FUNCTION_TYPE)\n     {\n-      if (complain)\n+      if (complain & tf_error)\n \terror (\"`%T' cannot be `const'-, `volatile'-, or `restrict'-qualified\", type);\n       else\n \treturn error_mark_node;"}, {"sha": "4d0cf786ecf0b64c80d245fa58a2deb0819982e9", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2ea3a40d9d7f302ba6f9279163d201410b39a4c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c2ea3a40d9d7f302ba6f9279163d201410b39a4c", "patch": "@@ -3414,7 +3414,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n   /* DTRT if one side is an overloaded function, but complain about it.  */\n   if (type_unknown_p (op0))\n     {\n-      tree t = instantiate_type (TREE_TYPE (op1), op0, itf_none);\n+      tree t = instantiate_type (TREE_TYPE (op1), op0, tf_none);\n       if (t != error_mark_node)\n \t{\n \t  pedwarn (\"assuming cast to type `%T' from overloaded function\",\n@@ -3424,7 +3424,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n     }\n   if (type_unknown_p (op1))\n     {\n-      tree t = instantiate_type (TREE_TYPE (op0), op1, itf_none);\n+      tree t = instantiate_type (TREE_TYPE (op0), op1, tf_none);\n       if (t != error_mark_node)\n \t{\n \t  pedwarn (\"assuming cast to type `%T' from overloaded function\",\n@@ -6106,7 +6106,7 @@ build_ptrmemfunc (type, pfn, force)\n     }\n \n   if (type_unknown_p (pfn))\n-    return instantiate_type (type, pfn, itf_complain);\n+    return instantiate_type (type, pfn, tf_error | tf_warning);\n \n   fn = TREE_OPERAND (pfn, 0);\n   my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 0);\n@@ -6334,7 +6334,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t     overloaded function.  Call instantiate_type to get error\n \t     messages.  */\n \t  if (rhstype == unknown_type_node)\n-\t    instantiate_type (type, rhs, itf_complain);\n+\t    instantiate_type (type, rhs, tf_error | tf_warning);\n \t  else if (fndecl)\n \t    error (\"cannot convert `%T' to `%T' for argument `%P' to `%D'\",\n \t\t      rhstype, type, parmnum, fndecl);"}]}