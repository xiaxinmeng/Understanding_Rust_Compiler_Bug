{"sha": "0ff15d21c8602ad78129c0a6baab821c4090de71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZmMTVkMjFjODYwMmFkNzgxMjljMGE2YmFhYjgyMWM0MDkwZGU3MQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-11-13T16:26:18Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-11-13T16:26:18Z"}, "message": "libsupc++: Implement comparison algorithms for C++20\n\nThis is incomplete because std::strong_order doesn't support\nfloating-point types.\n\nThe partial_order and weak_order tests use VERIFY instead of\nstatic_assert because of PR 92431.\n\n\t* libsupc++/compare (strong_order, weak_order, partial_order)\n\t(compare_strong_order_fallback, compare_weak_order_fallback)\n\t(compare_partial_order_fallback): Define customization point objects\n\tfor C++20.\n\t* testsuite/18_support/comparisons/algorithms/partial_order.cc: New\n\ttest.\n\t* testsuite/18_support/comparisons/algorithms/strong_order.cc: New\n\ttest.\n\t* testsuite/18_support/comparisons/algorithms/weak_order.cc: New test.\n\nFrom-SVN: r278149", "tree": {"sha": "b005ed160604bbf471c4acf6a754ffef95d9bc52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b005ed160604bbf471c4acf6a754ffef95d9bc52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ff15d21c8602ad78129c0a6baab821c4090de71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff15d21c8602ad78129c0a6baab821c4090de71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ff15d21c8602ad78129c0a6baab821c4090de71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff15d21c8602ad78129c0a6baab821c4090de71/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d46287769a5224d7d3495b54e64da25fc76f01a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d46287769a5224d7d3495b54e64da25fc76f01a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d46287769a5224d7d3495b54e64da25fc76f01a"}], "stats": {"total": 651, "additions": 641, "deletions": 10}, "files": [{"sha": "b073c688187a04eaf20c4baf5cebfba68e9745e4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff15d21c8602ad78129c0a6baab821c4090de71/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff15d21c8602ad78129c0a6baab821c4090de71/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0ff15d21c8602ad78129c0a6baab821c4090de71", "patch": "@@ -1,3 +1,15 @@\n+2019-11-13  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* libsupc++/compare (strong_order, weak_order, partial_order)\n+\t(compare_strong_order_fallback, compare_weak_order_fallback)\n+\t(compare_partial_order_fallback): Define customization point objects\n+\tfor C++20.\n+\t* testsuite/18_support/comparisons/algorithms/partial_order.cc: New\n+\ttest.\n+\t* testsuite/18_support/comparisons/algorithms/strong_order.cc: New\n+\ttest.\n+\t* testsuite/18_support/comparisons/algorithms/weak_order.cc: New test.\n+\n 2019-11-11  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* doc/xml/gnu/gpl-3.0.xml: Adjust link to \"Why not LGPL\"."}, {"sha": "289145dea5644b0ef5f70d8f37bf09327aafddd5", "filename": "libstdc++-v3/libsupc++/compare", "status": "modified", "additions": 336, "deletions": 10, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff15d21c8602ad78129c0a6baab821c4090de71/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff15d21c8602ad78129c0a6baab821c4090de71/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare?ref=0ff15d21c8602ad78129c0a6baab821c4090de71", "patch": "@@ -576,20 +576,346 @@ namespace std\n     using is_transparent = void;\n   };\n \n+  namespace __cmp_cust\n+  {\n+    template<floating_point _Tp>\n+      constexpr weak_ordering\n+      __fp_weak_ordering(_Tp __e, _Tp __f)\n+      {\n+\t// Returns an integer with the same sign as the argument, and magnitude\n+\t// indicating the classification: zero=1 subnorm=2 norm=3 inf=4 nan=5\n+\tauto __cat = [](_Tp __fp) -> int {\n+\t  const int __sign = __builtin_signbit(__fp) ? -1 : 1;\n+\t  if (__builtin_isnormal(__fp))\n+\t    return (__fp == 0 ? 1 : 3) * __sign;\n+\t  if (__builtin_isnan(__fp))\n+\t    return 5 * __sign;\n+\t  if (int __inf = __builtin_isinf_sign(__fp))\n+\t    return 4 * __inf;\n+\t  return 2 * __sign;\n+\t};\n+\n+\tauto __po = __e <=> __f;\n+\tif (is_lt(__po))\n+\t  return weak_ordering::less;\n+\telse if (is_gt(__po))\n+\t  return weak_ordering::greater;\n+\telse if (__po == partial_ordering::equivalent)\n+\t  return weak_ordering::equivalent;\n+\telse  // unordered, at least one argument is NaN\n+\t  {\n+\t    // return -1 for negative nan, +1 for positive nan, 0 otherwise.\n+\t    auto __isnan_sign = [](_Tp __fp) -> int {\n+\t      return __builtin_isnan(__fp)\n+\t\t? __builtin_signbit(__fp) ? -1 : 1\n+\t\t: 0;\n+\t    };\n+\t    auto __ord = __isnan_sign(__e) <=> __isnan_sign(__f);\n+\t    if (is_eq(__ord))\n+\t      return weak_ordering::equivalent;\n+\t    else if (is_lt(__ord))\n+\t      return weak_ordering::less;\n+\t    else\n+\t      return weak_ordering::greater;\n+\t  }\n+      }\n+\n+    template<typename _Tp, typename _Up>\n+      concept __adl_strong = requires(_Tp&& __t, _Up&& __u)\n+\t{\n+\t  strong_ordering(strong_order(static_cast<_Tp&&>(__t),\n+\t\t\t\t       static_cast<_Up&&>(__u)));\n+\t};\n+\n+    template<typename _Tp, typename _Up>\n+      concept __adl_weak = requires(_Tp&& __t, _Up&& __u)\n+\t{\n+\t  weak_ordering(weak_order(static_cast<_Tp&&>(__t),\n+\t\t\t\t   static_cast<_Up&&>(__u)));\n+\t};\n+\n+    template<typename _Tp, typename _Up>\n+      concept __adl_partial = requires(_Tp&& __t, _Up&& __u)\n+\t{\n+\t  partial_ordering(partial_order(static_cast<_Tp&&>(__t),\n+\t\t\t\t\t static_cast<_Up&&>(__u)));\n+\t};\n+\n+    template<typename _Ord, typename _Tp, typename _Up>\n+      concept __op_cmp = requires(_Tp&& __t, _Up&& __u)\n+\t{\n+\t  _Ord(static_cast<_Tp&&>(__t) <=> static_cast<_Up&&>(__u));\n+\t};\n+\n+    template<typename _Tp, typename _Up>\n+      concept __strongly_ordered\n+\t= __adl_strong<_Tp, _Up>\n+\t  // FIXME: || floating_point<remove_reference_t<_Tp>>\n+\t  || __op_cmp<strong_ordering, _Tp, _Up>;\n+\n+    class _Strong_order\n+    {\n+      template<typename _Tp, typename _Up>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (floating_point<decay_t<_Tp>>)\n+\t    return true;\n+\t  else if constexpr (__adl_strong<_Tp, _Up>)\n+\t    return noexcept(strong_ordering(strong_order(std::declval<_Tp>(),\n+\t\t\t\t\t\t\t std::declval<_Up>())));\n+\t  else if constexpr (__op_cmp<strong_ordering, _Tp, _Up>)\n+\t    return noexcept(std::declval<_Tp>() <=> std::declval<_Up>());\n+\t}\n+\n+      friend class _Weak_order;\n+      friend class _Strong_fallback;\n+\n+    public:\n+      template<typename _Tp, typename _Up>\n+\trequires __strongly_ordered<_Tp, _Up>\n+\tconstexpr strong_ordering\n+\toperator()(_Tp&& __e, _Up&& __f) const\n+\tnoexcept(_S_noexcept<_Tp, _Up>())\n+\t{\n+\t  static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);\n+\n+\t  /* FIXME:\n+\t  if constexpr (floating_point<decay_t<_Tp>>)\n+\t    return __cmp_cust::__fp_strong_order(__e, __f);\n+\t  else */ if constexpr (__adl_strong<_Tp, _Up>)\n+\t    return strong_ordering(strong_order(static_cast<_Tp&&>(__e),\n+\t\t\t\t\t\tstatic_cast<_Up&&>(__f)));\n+\t  else if constexpr (__op_cmp<strong_ordering, _Tp, _Up>)\n+\t    return static_cast<_Tp&&>(__e) <=> static_cast<_Up&&>(__f);\n+\t}\n+    };\n+\n+    template<typename _Tp, typename _Up>\n+      concept __weakly_ordered\n+\t= floating_point<remove_reference_t<_Tp>>\n+\t  || __adl_weak<_Tp, _Up>\n+\t  || __op_cmp<weak_ordering, _Tp, _Up>\n+\t  || __strongly_ordered<_Tp, _Up>;\n+\n+    class _Weak_order\n+    {\n+      template<typename _Tp, typename _Up>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (floating_point<decay_t<_Tp>>)\n+\t    return true;\n+\t  else if constexpr (__adl_weak<_Tp, _Up>)\n+\t    return noexcept(weak_ordering(weak_order(std::declval<_Tp>(),\n+\t\t\t\t\t\t     std::declval<_Up>())));\n+\t  else if constexpr (__op_cmp<weak_ordering, _Tp, _Up>)\n+\t    return noexcept(std::declval<_Tp>() <=> std::declval<_Up>());\n+\t  else if constexpr (__strongly_ordered<_Tp, _Up>)\n+\t    return _Strong_order::_S_noexcept<_Tp, _Up>();\n+\t}\n+\n+      friend class _Partial_order;\n+      friend class _Weak_fallback;\n+\n+    public:\n+      template<typename _Tp, typename _Up>\n+\trequires __weakly_ordered<_Tp, _Up>\n+\tconstexpr weak_ordering\n+\toperator()(_Tp&& __e, _Up&& __f) const\n+\tnoexcept(_S_noexcept<_Tp, _Up>())\n+\t{\n+\t  static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);\n+\n+\t  if constexpr (floating_point<decay_t<_Tp>>)\n+\t    return __cmp_cust::__fp_weak_ordering(__e, __f);\n+\t  else if constexpr (__adl_weak<_Tp, _Up>)\n+\t    return weak_ordering(weak_order(static_cast<_Tp&&>(__e),\n+\t\t\t\t\t    static_cast<_Up&&>(__f)));\n+\t  else if constexpr (__op_cmp<weak_ordering, _Tp, _Up>)\n+\t    return static_cast<_Tp&&>(__e) <=> static_cast<_Up&&>(__f);\n+\t  else if constexpr (__strongly_ordered<_Tp, _Up>)\n+\t    return _Strong_order{}(static_cast<_Tp&&>(__e),\n+\t\t\t\t   static_cast<_Up&&>(__f));\n+\t}\n+    };\n+\n+    template<typename _Tp, typename _Up>\n+      concept __partially_ordered\n+\t= __adl_partial<_Tp, _Up>\n+\t|| __op_cmp<partial_ordering, _Tp, _Up>\n+\t|| __weakly_ordered<_Tp, _Up>;\n+\n+    class _Partial_order\n+    {\n+      template<typename _Tp, typename _Up>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (__adl_partial<_Tp, _Up>)\n+\t    return noexcept(partial_ordering(partial_order(std::declval<_Tp>(),\n+\t\t\t\t\t\t\t std::declval<_Up>())));\n+\t  else if constexpr (__op_cmp<partial_ordering, _Tp, _Up>)\n+\t    return noexcept(std::declval<_Tp>() <=> std::declval<_Up>());\n+\t  else if constexpr (__weakly_ordered<_Tp, _Up>)\n+\t    return _Weak_order::_S_noexcept<_Tp, _Up>();\n+\t}\n+\n+      friend class _Partial_fallback;\n+\n+    public:\n+      template<typename _Tp, typename _Up>\n+\trequires __partially_ordered<_Tp, _Up>\n+\tconstexpr partial_ordering\n+\toperator()(_Tp&& __e, _Up&& __f) const\n+\tnoexcept(_S_noexcept<_Tp, _Up>())\n+\t{\n+\t  static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);\n+\n+\t  if constexpr (__adl_partial<_Tp, _Up>)\n+\t    return partial_ordering(partial_order(static_cast<_Tp&&>(__e),\n+\t\t\t\t\t\t  static_cast<_Up&&>(__f)));\n+\t  else if constexpr (__op_cmp<partial_ordering, _Tp, _Up>)\n+\t    return static_cast<_Tp&&>(__e) <=> static_cast<_Up&&>(__f);\n+\t  else if constexpr (__weakly_ordered<_Tp, _Up>)\n+\t    return _Weak_order{}(static_cast<_Tp&&>(__e),\n+\t\t\t\t static_cast<_Up&&>(__f));\n+\t}\n+    };\n+\n+    template<typename _Tp, typename _Up>\n+      concept __op_eq_lt = requires(_Tp&& __t, _Up&& __u)\n+\t{\n+\t  { static_cast<_Tp&&>(__t) == static_cast<_Up&&>(__u) }\n+\t    -> convertible_to<bool>;\n+\t  { static_cast<_Tp&&>(__t) < static_cast<_Up&&>(__u) }\n+\t    -> convertible_to<bool>;\n+\t};\n+\n+    class _Strong_fallback\n+    {\n+      template<typename _Tp, typename _Up>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (__strongly_ordered<_Tp, _Up>)\n+\t    return _Strong_order::_S_noexcept<_Tp, _Up>();\n+\t  else\n+\t    return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>()))\n+\t      && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));\n+\t}\n+\n+    public:\n+      template<typename _Tp, typename _Up>\n+\trequires __strongly_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>\n+\tconstexpr decltype(auto)\n+\toperator()(_Tp&& __e, _Up&& __f) const\n+\tnoexcept(_S_noexcept<_Tp, _Up>())\n+\t{\n+\t  static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);\n+\n+\t  if constexpr (__strongly_ordered<_Tp, _Up>)\n+\t    return _Strong_order{}(static_cast<_Tp&&>(__e),\n+\t\t\t\t   static_cast<_Up&&>(__f));\n+\t  else if constexpr (__op_eq_lt<_Tp, _Up>)\n+\t    return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)\n+\t      ? strong_ordering::equal\n+\t      : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)\n+\t      ? strong_ordering::less\n+\t      : strong_ordering::greater;\n+\t}\n+    };\n+\n+    class _Weak_fallback\n+    {\n+      template<typename _Tp, typename _Up>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (__weakly_ordered<_Tp, _Up>)\n+\t    return _Weak_order::_S_noexcept<_Tp, _Up>();\n+\t  else\n+\t    return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>()))\n+\t      && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));\n+\t}\n+\n+    public:\n+      template<typename _Tp, typename _Up>\n+\trequires __weakly_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>\n+\tconstexpr decltype(auto)\n+\toperator()(_Tp&& __e, _Up&& __f) const\n+\tnoexcept(_S_noexcept<_Tp, _Up>())\n+\t{\n+\t  static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);\n+\n+\t  if constexpr (__weakly_ordered<_Tp, _Up>)\n+\t    return _Weak_order{}(static_cast<_Tp&&>(__e),\n+\t\t\t\t static_cast<_Up&&>(__f));\n+\t  else if constexpr (__op_eq_lt<_Tp, _Up>)\n+\t    return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)\n+\t      ? weak_ordering::equivalent\n+\t      : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)\n+\t      ? weak_ordering::less\n+\t      : weak_ordering::greater;\n+\t}\n+    };\n+\n+    class _Partial_fallback\n+    {\n+      template<typename _Tp, typename _Up>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (__partially_ordered<_Tp, _Up>)\n+\t    return _Partial_order::_S_noexcept<_Tp, _Up>();\n+\t  else\n+\t    return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>()))\n+\t      && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));\n+\t}\n+\n+    public:\n+      template<typename _Tp, typename _Up>\n+\trequires __partially_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>\n+\tconstexpr decltype(auto)\n+\toperator()(_Tp&& __e, _Up&& __f) const\n+\tnoexcept(_S_noexcept<_Tp, _Up>())\n+\t{\n+\t  static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);\n+\n+\t  if constexpr (__partially_ordered<_Tp, _Up>)\n+\t    return _Partial_order{}(static_cast<_Tp&&>(__e),\n+\t\t\t\t    static_cast<_Up&&>(__f));\n+\t  else if constexpr (__op_eq_lt<_Tp, _Up>)\n+\t    return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)\n+\t      ? partial_ordering::equivalent\n+\t      : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)\n+\t      ? partial_ordering::less\n+\t      : static_cast<_Up&&>(__f) < static_cast<_Tp&&>(__e)\n+\t      ? partial_ordering::greater\n+\t      : partial_ordering::unordered;\n+\t}\n+    };\n+  } // namespace __cmp_cust\n+\n   // [cmp.alg], comparison algorithms\n   inline namespace __cmp_alg\n   {\n-    // TODO\n-#if 0\n-    inline constexpr unspecified strong_order = unspecified;\n-    inline constexpr unspecified weak_order = unspecified;\n-    inline constexpr unspecified partial_order = unspecified;\n-    inline constexpr unspecified compare_strong_order_fallback = unspecified;\n-    inline constexpr unspecified compare_weak_order_fallback = unspecified;\n-    inline constexpr unspecified compare_partial_order_fallback = unspecified;\n-#endif\n+    inline constexpr __cmp_cust::_Strong_order strong_order{};\n+\n+    inline constexpr __cmp_cust::_Weak_order weak_order{};\n+\n+    inline constexpr __cmp_cust::_Partial_order partial_order{};\n+\n+    inline constexpr __cmp_cust::_Strong_fallback\n+    compare_strong_order_fallback{};\n+\n+    inline constexpr __cmp_cust::_Weak_fallback\n+    compare_weak_order_fallback{};\n+\n+    inline constexpr __cmp_cust::_Partial_fallback\n+    compare_partial_order_fallback{};\n   }\n-#endif\n+#endif // concepts\n } // namespace std\n \n #pragma GCC visibility pop"}, {"sha": "ec85996e16d4c915d03c3f796d6ee3db36458599", "filename": "libstdc++-v3/testsuite/18_support/comparisons/algorithms/partial_order.cc", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff15d21c8602ad78129c0a6baab821c4090de71/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fpartial_order.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff15d21c8602ad78129c0a6baab821c4090de71/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fpartial_order.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fpartial_order.cc?ref=0ff15d21c8602ad78129c0a6baab821c4090de71", "patch": "@@ -0,0 +1,118 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <compare>\n+#include <limits>\n+#include <testsuite_hooks.h>\n+\n+using std::partial_order;\n+using std::partial_ordering;\n+\n+void\n+test01()\n+{\n+  int one = 1, two = 2;\n+\n+  VERIFY( partial_order(one, two) == partial_ordering::less );\n+  VERIFY( partial_order(one, one) == partial_ordering::equivalent );\n+  VERIFY( partial_order(two, one) == partial_ordering::greater );\n+  static_assert( noexcept(partial_order(1, 1)) );\n+}\n+\n+constexpr partial_ordering different_cv_quals(int i, const int j)\n+{\n+  return partial_order(i, j);\n+}\n+\n+void\n+test02()\n+{\n+  int fortytwo = 42, nines = 999, lots = 1000;\n+  VERIFY( different_cv_quals(fortytwo, nines) == partial_ordering::less );\n+  VERIFY( different_cv_quals(-nines, -nines) == partial_ordering::equivalent );\n+  VERIFY( different_cv_quals(-nines, -lots) == partial_ordering::greater );\n+}\n+\n+void\n+test03()\n+{\n+  double zero = 0.0;\n+  VERIFY( partial_order(zero, zero) == partial_ordering::equivalent );\n+  VERIFY( partial_order(-zero, -zero) == partial_ordering::equivalent );\n+  VERIFY( partial_order(-zero, zero) == partial_ordering::equivalent );\n+  VERIFY( partial_order(zero, -zero) == partial_ordering::equivalent );\n+  static_assert( noexcept(partial_order(zero, 1.0)) );\n+  static_assert( partial_order(0.0, 1.0) == std::partial_ordering::less );\n+\n+  double min = std::numeric_limits<double>::lowest();\n+  double max = std::numeric_limits<double>::max();\n+  double nan = std::numeric_limits<double>::quiet_NaN();\n+  double inf = std::numeric_limits<double>::infinity();\n+  double denorm = std::numeric_limits<double>::denorm_min();\n+  double smallest = std::numeric_limits<double>::min();\n+  double epsilon = std::numeric_limits<double>::epsilon();\n+  VERIFY( partial_order(denorm, smallest) == partial_ordering::less );\n+  VERIFY( partial_order(denorm, 0.0) == partial_ordering::greater );\n+  VERIFY( partial_order(0.0, nan) == partial_ordering::unordered );\n+  VERIFY( partial_order(nan, nan) == partial_ordering::unordered );\n+  VERIFY( partial_order(nan, 0.0) == partial_ordering::unordered );\n+  VERIFY( partial_order(-nan, 0.0) == partial_ordering::unordered );\n+  VERIFY( partial_order(-nan, min) == partial_ordering::unordered );\n+  VERIFY( partial_order(-inf, min) == partial_ordering::less );\n+  VERIFY( partial_order(-nan, -inf) == partial_ordering::unordered );\n+  VERIFY( partial_order(-inf, -nan) == partial_ordering::unordered );\n+  VERIFY( partial_order(max, inf) == partial_ordering::less );\n+  VERIFY( partial_order(inf, max) == partial_ordering::greater );\n+  VERIFY( partial_order(inf, nan) == partial_ordering::unordered );\n+  VERIFY( partial_order(1.0, 1.0+epsilon) == partial_ordering::less );\n+}\n+\n+namespace N\n+{\n+  struct X { int i; };\n+\n+  constexpr partial_ordering operator<=>(X l, X r)\n+  {\n+    if (l.i < 0 && r.i < 0)\n+      return partial_ordering::equivalent;\n+    return r.i <=> l.i;\n+  }\n+}\n+\n+void\n+test04()\n+{\n+  using N::X;\n+  X one{1};\n+  X negone{-1};\n+\n+  VERIFY( partial_order(one, X{1}) == partial_ordering::equivalent );\n+  VERIFY( partial_order(negone, X{-2}) == partial_ordering::equivalent );\n+  VERIFY( partial_order(one, X{2}) == partial_ordering::greater );\n+  static_assert( !noexcept(partial_order(X{1}, X{2})) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "2c813494ce7df0ddb4ffbc218ce4a2cfd0532a59", "filename": "libstdc++-v3/testsuite/18_support/comparisons/algorithms/strong_order.cc", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff15d21c8602ad78129c0a6baab821c4090de71/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fstrong_order.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff15d21c8602ad78129c0a6baab821c4090de71/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fstrong_order.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fstrong_order.cc?ref=0ff15d21c8602ad78129c0a6baab821c4090de71", "patch": "@@ -0,0 +1,56 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <compare>\n+#include <limits>\n+\n+using std::strong_order;\n+using std::strong_ordering;\n+\n+static_assert( strong_order(1, 2) == strong_ordering::less );\n+static_assert( strong_order(1, 1) == strong_ordering::equal );\n+static_assert( strong_order(2, 1) == strong_ordering::greater );\n+static_assert( noexcept(strong_order(1, 1)) );\n+\n+constexpr strong_ordering different_cv_quals(int i, const int j)\n+{\n+  return strong_order(i, j);\n+}\n+static_assert( different_cv_quals(42, 999) == strong_ordering::less );\n+static_assert( different_cv_quals(-999, -999) == strong_ordering::equal );\n+static_assert( different_cv_quals(-99, -111) == strong_ordering::greater );\n+\n+namespace N\n+{\n+  struct X { int i; };\n+\n+  constexpr strong_ordering operator<=>(X l, X r)\n+  {\n+    if (l.i < 0 && r.i < 0)\n+      return strong_ordering::equivalent;\n+    return r.i <=> l.i;\n+  }\n+}\n+using N::X;\n+\n+static_assert( strong_order(X{1}, X{1}) == strong_ordering::equal );\n+static_assert( strong_order(X{-1}, X{-2}) == strong_ordering::equivalent );\n+static_assert( strong_order(X{1}, X{2}) == strong_ordering::greater );\n+static_assert( !noexcept(strong_order(X{1}, X{2})) );"}, {"sha": "03a162b86d56c63766d049fa9048add1bb5bf1ea", "filename": "libstdc++-v3/testsuite/18_support/comparisons/algorithms/weak_order.cc", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff15d21c8602ad78129c0a6baab821c4090de71/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fweak_order.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff15d21c8602ad78129c0a6baab821c4090de71/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fweak_order.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fweak_order.cc?ref=0ff15d21c8602ad78129c0a6baab821c4090de71", "patch": "@@ -0,0 +1,119 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <compare>\n+#include <limits>\n+#include <testsuite_hooks.h>\n+\n+using std::weak_order;\n+using std::weak_ordering;\n+\n+void\n+test01()\n+{\n+  int one = 1, two = 2;\n+\n+  VERIFY( weak_order(one, two) == weak_ordering::less );\n+  VERIFY( weak_order(one, one) == weak_ordering::equivalent );\n+  VERIFY( weak_order(two, one) == weak_ordering::greater );\n+  static_assert( noexcept(weak_order(1, 1)) );\n+}\n+\n+constexpr weak_ordering different_cv_quals(int i, const int j)\n+{\n+  return weak_order(i, j);\n+}\n+\n+void\n+test02()\n+{\n+  int fortytwo = 42, nines = 999, lots = 1000;\n+\n+  VERIFY( different_cv_quals(fortytwo, nines) == weak_ordering::less );\n+  VERIFY( different_cv_quals(-nines, -nines) == weak_ordering::equivalent );\n+  VERIFY( different_cv_quals(-nines, -lots) == weak_ordering::greater );\n+}\n+\n+void\n+test03()\n+{\n+  double zero = 0.0;\n+  VERIFY( weak_order(zero, zero) == weak_ordering::equivalent );\n+  VERIFY( weak_order(-zero, -zero) == weak_ordering::equivalent );\n+  VERIFY( weak_order(-zero, zero) == weak_ordering::equivalent );\n+  VERIFY( weak_order(zero, -zero) == weak_ordering::equivalent );\n+\n+  double min = std::numeric_limits<double>::lowest();\n+  double max = std::numeric_limits<double>::max();\n+  double nan = std::numeric_limits<double>::quiet_NaN();\n+  double inf = std::numeric_limits<double>::infinity();\n+  double denorm = std::numeric_limits<double>::denorm_min();\n+  double smallest = std::numeric_limits<double>::min();\n+  double epsilon = std::numeric_limits<double>::epsilon();\n+  VERIFY( weak_order(denorm, smallest) == weak_ordering::less );\n+  VERIFY( weak_order(denorm, 0.0) == weak_ordering::greater );\n+  VERIFY( weak_order(0.0, nan) == weak_ordering::less );\n+  VERIFY( weak_order(nan, nan) == weak_ordering::equivalent );\n+  VERIFY( weak_order(nan, -nan) == weak_ordering::greater );\n+  VERIFY( weak_order(-nan, nan) == weak_ordering::less );\n+  VERIFY( weak_order(nan, 0.0) == weak_ordering::greater );\n+  VERIFY( weak_order(-nan, 0.0) == weak_ordering::less );\n+  VERIFY( weak_order(-nan, min) == weak_ordering::less );\n+  VERIFY( weak_order(-inf, min) == weak_ordering::less );\n+  VERIFY( weak_order(-nan, -inf) == weak_ordering::less );\n+  VERIFY( weak_order(-inf, -nan) == weak_ordering::greater );\n+  VERIFY( weak_order(max, inf) == weak_ordering::less );\n+  VERIFY( weak_order(inf, max) == weak_ordering::greater );\n+  VERIFY( weak_order(inf, nan) == weak_ordering::less );\n+  VERIFY( weak_order(1.0, 1.0+epsilon) == weak_ordering::less );\n+}\n+\n+namespace N\n+{\n+  struct X { int i; };\n+\n+  constexpr weak_ordering operator<=>(X l, X r)\n+  {\n+    if (l.i < 0 && r.i < 0)\n+      return weak_ordering::equivalent;\n+    return r.i <=> l.i;\n+  }\n+}\n+\n+void\n+test04()\n+{\n+  using N::X;\n+  X one{1};\n+  X negone{-1};\n+\n+  VERIFY( weak_order(one, X{1}) == weak_ordering::equivalent );\n+  VERIFY( weak_order(negone, X{-2}) == weak_ordering::equivalent );\n+  VERIFY( weak_order(one, X{2}) == weak_ordering::greater );\n+  static_assert( !noexcept(weak_order(X{1}, X{2})) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}]}