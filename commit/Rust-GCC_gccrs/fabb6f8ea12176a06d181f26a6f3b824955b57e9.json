{"sha": "fabb6f8ea12176a06d181f26a6f3b824955b57e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFiYjZmOGVhMTIxNzZhMDZkMTgxZjI2YTZmM2I4MjQ5NTViNTdlOQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-01-31T19:13:13Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-01-31T19:13:13Z"}, "message": "re PR fortran/47519 (Deferred-length string wrong results with character intrinsic functions)\n\n2011-01-31  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/47519\n\t* trans-stmt.c (gfc_trans_allocate): Improve handling of\n\tdeferred character lengths with SOURCE.\n\t* iresolve.c (gfc_resolve_repeat): Calculate character\n\tlength from source length and ncopies.\n\t* dump-parse-tree.c (show_code_node): Show MOLD and SOURCE\n\texpressions for ALLOCATE.\n\n\n2011-01-31  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/47519\n\t* gfortran.dg/allocate_deferred_char_scalar_2.f03: New test.\n\nFrom-SVN: r169444", "tree": {"sha": "05fa8bedfa01cd41411713a530eb7ef6c57e85ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05fa8bedfa01cd41411713a530eb7ef6c57e85ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fabb6f8ea12176a06d181f26a6f3b824955b57e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fabb6f8ea12176a06d181f26a6f3b824955b57e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fabb6f8ea12176a06d181f26a6f3b824955b57e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fabb6f8ea12176a06d181f26a6f3b824955b57e9/comments", "author": null, "committer": null, "parents": [{"sha": "b6c77bcb57974ccbb49f5651f9ba0e443b864d1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6c77bcb57974ccbb49f5651f9ba0e443b864d1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6c77bcb57974ccbb49f5651f9ba0e443b864d1d"}], "stats": {"total": 120, "additions": 99, "deletions": 21}, "files": [{"sha": "ae08fdc6a87996795ffc78c7d4736d6b755e3a18", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabb6f8ea12176a06d181f26a6f3b824955b57e9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabb6f8ea12176a06d181f26a6f3b824955b57e9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fabb6f8ea12176a06d181f26a6f3b824955b57e9", "patch": "@@ -1,3 +1,13 @@\n+2011-01-31  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/47519\n+\t* trans-stmt.c (gfc_trans_allocate): Improve handling of\n+\tdeferred character lengths with SOURCE.\n+\t* iresolve.c (gfc_resolve_repeat): Calculate character\n+\tlength from source length and ncopies.\n+\t* dump-parse-tree.c (show_code_node): Show MOLD and SOURCE\n+\texpressions for ALLOCATE.\n+\n 2011-01-31  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/47463"}, {"sha": "424feb1e68e61c084c30150fcd241e06d07882eb", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabb6f8ea12176a06d181f26a6f3b824955b57e9/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabb6f8ea12176a06d181f26a6f3b824955b57e9/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=fabb6f8ea12176a06d181f26a6f3b824955b57e9", "patch": "@@ -1605,6 +1605,15 @@ show_code_node (int level, gfc_code *c)\n \t  show_expr (c->expr2);\n \t}\n \n+      if (c->expr3)\n+\t{\n+\t  if (c->expr3->mold)\n+\t    fputs (\" MOLD=\", dumpfile);\n+\t  else\n+\t    fputs (\" SOURCE=\", dumpfile);\n+\t  show_expr (c->expr3);\n+\t}\n+\n       for (a = c->ext.alloc.list; a; a = a->next)\n \t{\n \t  fputc (' ', dumpfile);"}, {"sha": "d8309d27f85705c0191e9559f2230208845ebd47", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabb6f8ea12176a06d181f26a6f3b824955b57e9/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabb6f8ea12176a06d181f26a6f3b824955b57e9/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=fabb6f8ea12176a06d181f26a6f3b824955b57e9", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gfortran.h\"\n #include \"intrinsic.h\"\n #include \"constructor.h\"\n+#include \"arith.h\"\n \n /* Given printf-like arguments, return a stable version of the result string. \n \n@@ -2044,11 +2045,31 @@ gfc_resolve_rename (gfc_expr *f, gfc_expr *p1 ATTRIBUTE_UNUSED,\n \n void\n gfc_resolve_repeat (gfc_expr *f, gfc_expr *string,\n-\t\t    gfc_expr *ncopies ATTRIBUTE_UNUSED)\n+\t\t    gfc_expr *ncopies)\n {\n+  int len;\n+  gfc_expr *tmp;\n   f->ts.type = BT_CHARACTER;\n   f->ts.kind = string->ts.kind;\n   f->value.function.name = gfc_get_string (\"__repeat_%d\", string->ts.kind);\n+\n+  /* If possible, generate a character length.  */\n+  if (f->ts.u.cl == NULL)\n+    f->ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);\n+\n+  tmp = NULL;\n+  if (string->expr_type == EXPR_CONSTANT)\n+    {\n+      len = string->value.character.length;\n+      tmp = gfc_get_int_expr (gfc_default_integer_kind, NULL , len);\n+    }\n+  else if (string->ts.u.cl && string->ts.u.cl->length)\n+    {\n+      tmp = gfc_copy_expr (string->ts.u.cl->length);\n+    }\n+\n+  if (tmp)\n+    f->ts.u.cl->length = gfc_multiply (tmp, gfc_copy_expr (ncopies));\n }\n \n "}, {"sha": "2ac6989a2e6614df836fcee9dd01001adac4f355", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabb6f8ea12176a06d181f26a6f3b824955b57e9/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabb6f8ea12176a06d181f26a6f3b824955b57e9/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=fabb6f8ea12176a06d181f26a6f3b824955b57e9", "patch": "@@ -4522,15 +4522,30 @@ gfc_trans_allocate (gfc_code * code)\n \t\t      gfc_conv_expr (&se_sz, code->expr3);\n \t\t      memsz = se_sz.string_length;\n \t\t    }\n-\t\t  else\n+\t\t  else if (code->expr3->ts.u.cl\n+\t\t\t     && code->expr3->ts.u.cl->length)\n+\t\t    {\n+\t\t      gfc_conv_expr (&se_sz, code->expr3->ts.u.cl->length);\n+\t\t      gfc_add_block_to_block (&se.pre, &se_sz.pre);\n+\t\t      se_sz.expr = gfc_evaluate_now (se_sz.expr, &se.pre);\n+\t\t      gfc_add_block_to_block (&se.pre, &se_sz.post);\n+\t\t      memsz = se_sz.expr;\n+\t\t    }\n+\t\t  else if (code->ext.alloc.ts.u.cl\n+\t\t\t     && code->ext.alloc.ts.u.cl->length)\n \t\t    {\n \t\t      gfc_conv_expr (&se_sz, code->ext.alloc.ts.u.cl->length);\n \t\t      memsz = se_sz.expr;\n \t\t    }\n-\t\t  if (TREE_CODE (se.string_length) == VAR_DECL)\n-                    gfc_add_modify (&block, se.string_length,\n-\t\t\t\t    fold_convert (TREE_TYPE (se.string_length),\n-\t\t\t\t\t\t  memsz));\n+\t\t  else\n+\t\t    {\n+\t\t      /* This is likely to be inefficient.  */\n+\t\t      gfc_conv_expr (&se_sz, code->expr3);\n+\t\t      gfc_add_block_to_block (&se.pre, &se_sz.pre);\n+\t\t      se_sz.expr = gfc_evaluate_now (se_sz.expr, &se.pre);\n+\t\t      gfc_add_block_to_block (&se.pre, &se_sz.post);\n+\t\t      memsz = se_sz.string_length;\n+\t\t    }\n \t\t}\n \t      else\n \t\t/* Otherwise use the stored string length.  */\n@@ -4539,7 +4554,7 @@ gfc_trans_allocate (gfc_code * code)\n \n \t      /* Store the string length.  */\n \t      if (tmp && TREE_CODE (tmp) == VAR_DECL)\n-\t\tgfc_add_modify (&block, tmp, fold_convert (TREE_TYPE (tmp),\n+\t\tgfc_add_modify (&se.pre, tmp, fold_convert (TREE_TYPE (tmp),\n \t\t\t\tmemsz));\n \n \t      /* Convert to size in bytes, using the character KIND.  */\n@@ -4556,18 +4571,8 @@ gfc_trans_allocate (gfc_code * code)\n \n \t  if (expr->ts.type == BT_CHARACTER && memsz == NULL_TREE)\n \t    {\n-\t      if (expr->ts.deferred)\n-\t\t{\n-\t\t  gfc_se se_sz;\n-\t\t  gfc_init_se (&se_sz, NULL);\n-\t\t  gfc_conv_expr (&se_sz, code->ext.alloc.ts.u.cl->length);\n-\t\t  memsz = se_sz.expr;\n-                  gfc_add_modify (&block, se.string_length,\n-\t\t\t\t  fold_convert (TREE_TYPE (se.string_length),\n-\t\t\t\t\t\tmemsz));\n-\t\t}\n-\t      else\n-\t\tmemsz = se.string_length;\n+\t      memsz = se.string_length;\n+\n \t      /* Convert to size in bytes, using the character KIND.  */\n \t      tmp = TREE_TYPE (gfc_typenode_for_spec (&code->ext.alloc.ts));\n \t      tmp = TYPE_SIZE_UNIT (tmp);\n@@ -4664,8 +4669,15 @@ gfc_trans_allocate (gfc_code * code)\n \t      tmp = gfc_finish_block (&call.pre);\n \t    }\n \t  else\n-\t    tmp = gfc_trans_assignment (gfc_expr_to_initialize (expr),\n-\t\t\t\t\trhs, false, false);\n+\t    {\n+\t      /* Switch off automatic reallocation since we have just done\n+\t\t the ALLOCATE.  */\n+\t      int realloc_lhs = gfc_option.flag_realloc_lhs;\n+\t      gfc_option.flag_realloc_lhs = 0;\n+\t      tmp = gfc_trans_assignment (gfc_expr_to_initialize (expr),\n+\t\t\t\t\t  rhs, false, false);\n+\t      gfc_option.flag_realloc_lhs = realloc_lhs;\n+\t    }\n \t  gfc_free_expr (rhs);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}"}, {"sha": "824f3ca5cf8d5ae6de809077351d97419ed7a2d0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabb6f8ea12176a06d181f26a6f3b824955b57e9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabb6f8ea12176a06d181f26a6f3b824955b57e9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fabb6f8ea12176a06d181f26a6f3b824955b57e9", "patch": "@@ -1,3 +1,8 @@\n+2011-01-31  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/47519\n+\t* gfortran.dg/allocate_deferred_char_scalar_2.f03: New test.\n+\n 2011-01-31  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/47463"}, {"sha": "1f0f433010516739a58ceacca9bc146a22274dc8", "filename": "gcc/testsuite/gfortran.dg/allocate_deferred_char_scalar_2.f03", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabb6f8ea12176a06d181f26a6f3b824955b57e9/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_deferred_char_scalar_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabb6f8ea12176a06d181f26a6f3b824955b57e9/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_deferred_char_scalar_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_deferred_char_scalar_2.f03?ref=fabb6f8ea12176a06d181f26a6f3b824955b57e9", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do run }\n+! Test the fix for PR47519, in which the character length was not\n+! calculated for the SOURCE expressions below and an ICE resulted. \n+!\n+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+program note7_35\n+   implicit none\n+   character(:), allocatable :: name\n+   character(:), allocatable :: src\n+   integer n\n+   n = 10\n+   allocate(name, SOURCE=repeat('x',n))\n+   if (name .ne. 'xxxxxxxxxx') call abort\n+   if (len (name) .ne. 10 ) call abort\n+   deallocate(name)\n+   src = 'xyxy'\n+   allocate(name, SOURCE=repeat(src,n))\n+   if (name(37:40) .ne. 'xyxy') call abort\n+   if (len (name) .ne. 40 ) call abort\n+end program note7_35"}]}