{"sha": "6e02de946125c36871bd4d8eff21f7f88f01a8aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUwMmRlOTQ2MTI1YzM2ODcxYmQ0ZDhlZmYyMWY3Zjg4ZjAxYThhYQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-10-19T23:04:40Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-10-19T23:11:17Z"}, "message": "Use precision and sign to compare types for ranges\n\nSanity check ranges by comparing just SIGN and PRECISION.\n\n\tgcc/\n\tPR tree-optimization/97360\n\t* gimple-range.h (range_compatible_p): New.\n\t* gimple-range-gori.cc (is_gimple_logical_p): Use range_compatible_p.\n\t(range_is_either_true_or_false): Ditto.\n\t(gori_compute::outgoing_edge_range_p): Cast result to the correct\n\ttype if necessary.\n\t(logical_stmt_cache::cacheable_p): Use range_compatible_p.\n\t* gimple-range.cc (gimple_ranger::calc_stmt): Check range_compatible_p\n\tbefore casting the range.\n\t(gimple_ranger::range_on_exit): Use range_compatible_p.\n\t(gimple_ranger::range_on_edge): Ditto.\n\n\tgcc/testsuite/\n\t* gcc.dg/pr97360-2.c: New test.", "tree": {"sha": "d56c07a37e03501257e2682ecccc234d5a29cdff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d56c07a37e03501257e2682ecccc234d5a29cdff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e02de946125c36871bd4d8eff21f7f88f01a8aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e02de946125c36871bd4d8eff21f7f88f01a8aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e02de946125c36871bd4d8eff21f7f88f01a8aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e02de946125c36871bd4d8eff21f7f88f01a8aa/comments", "author": null, "committer": null, "parents": [{"sha": "f000b7c436e62c52798187d8150216569eef17b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f000b7c436e62c52798187d8150216569eef17b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f000b7c436e62c52798187d8150216569eef17b5"}], "stats": {"total": 63, "additions": 52, "deletions": 11}, "files": [{"sha": "983f4c97e8790f0f0bb1b2114895acf4fd8b2fc4", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e02de946125c36871bd4d8eff21f7f88f01a8aa/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e02de946125c36871bd4d8eff21f7f88f01a8aa/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=6e02de946125c36871bd4d8eff21f7f88f01a8aa", "patch": "@@ -552,7 +552,7 @@ is_gimple_logical_p (const gimple *gs)\n \tcase BIT_AND_EXPR:\n \tcase BIT_IOR_EXPR:\n \t  // Bitwise operations on single bits are logical too.\n-\t  if (types_compatible_p (TREE_TYPE (gimple_assign_rhs1 (gs)),\n+\t  if (range_compatible_p (TREE_TYPE (gimple_assign_rhs1 (gs)),\n \t\t\t\t  boolean_type_node))\n \t    return true;\n \t  break;\n@@ -618,7 +618,7 @@ range_is_either_true_or_false (const irange &r)\n   // This is complicated by the fact that Ada has multi-bit booleans,\n   // so true can be ~[0, 0] (i.e. [1,MAX]).\n   tree type = r.type ();\n-  gcc_checking_assert (types_compatible_p (type, boolean_type_node));\n+  gcc_checking_assert (range_compatible_p (type, boolean_type_node));\n   return (r.singleton_p () || !r.contains_p (build_zero_cst (type)));\n }\n \n@@ -999,11 +999,20 @@ gori_compute::outgoing_edge_range_p (irange &r, edge e, tree name)\n \n   // If NAME can be calculated on the edge, use that.\n   if (m_gori_map->is_export_p (name, e->src))\n-    return compute_operand_range (r, stmt, lhs, name);\n-\n-  // Otherwise see if NAME is derived from something that can be\n-  // calculated.  This performs no dynamic lookups whatsover, so it is\n-  // low cost.\n+    {\n+      if (compute_operand_range (r, stmt, lhs, name))\n+\t{\n+\t  // Sometimes compatible types get interchanged. See PR97360.\n+\t  // Make sure we are returning the type of the thing we asked for.\n+\t  if (!r.undefined_p () && r.type () != TREE_TYPE (name))\n+\t    {\n+\t      gcc_checking_assert (range_compatible_p (r.type (),\n+\t\t\t\t\t\t       TREE_TYPE (name)));\n+\t      range_cast (r, TREE_TYPE (name));\n+\t    }\n+\t  return true;\n+\t}\n+    }\n   return false;\n }\n \n@@ -1156,7 +1165,7 @@ bool\n logical_stmt_cache::cacheable_p (gimple *stmt, const irange *lhs_range) const\n {\n   if (gimple_code (stmt) == GIMPLE_ASSIGN\n-      && types_compatible_p (TREE_TYPE (gimple_assign_lhs (stmt)),\n+      && range_compatible_p (TREE_TYPE (gimple_assign_lhs (stmt)),\n \t\t\t     boolean_type_node)\n       && TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME)\n     {"}, {"sha": "e4864ba60f6408e74c689d6c9fd72cbf76c19acd", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e02de946125c36871bd4d8eff21f7f88f01a8aa/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e02de946125c36871bd4d8eff21f7f88f01a8aa/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=6e02de946125c36871bd4d8eff21f7f88f01a8aa", "patch": "@@ -392,8 +392,14 @@ gimple_ranger::calc_stmt (irange &r, gimple *s, tree name)\n     {\n       if (r.undefined_p ())\n \treturn true;\n+      // We sometimes get compatible types copied from operands, make sure\n+      // the correct type is being returned.\n       if (name && TREE_TYPE (name) != r.type ())\n-\trange_cast (r, TREE_TYPE (name));\n+\t{\n+\t  gcc_checking_assert (range_compatible_p (r.type (),\n+\t\t\t\t\t\t   TREE_TYPE (name)));\n+\t  range_cast (r, TREE_TYPE (name));\n+\t}\n       return true;\n     }\n   return false;\n@@ -928,7 +934,7 @@ gimple_ranger::range_on_exit (irange &r, basic_block bb, tree name)\n   else\n     gcc_assert (range_of_expr (r, name, s));\n   gcc_checking_assert (r.undefined_p ()\n-\t\t       || types_compatible_p (r.type(), TREE_TYPE (name)));\n+\t\t       || range_compatible_p (r.type (), TREE_TYPE (name)));\n }\n \n // Calculate a range for NAME on edge E and return it in R.\n@@ -948,7 +954,7 @@ gimple_ranger::range_on_edge (irange &r, edge e, tree name)\n \n   range_on_exit (r, e->src, name);\n   gcc_checking_assert  (r.undefined_p ()\n-\t\t\t|| types_compatible_p (r.type(), TREE_TYPE (name)));\n+\t\t\t|| range_compatible_p (r.type(), TREE_TYPE (name)));\n \n   // Check to see if NAME is defined on edge e.\n   if (m_cache.outgoing_edge_range_p (edge_range, e, name))"}, {"sha": "a6e8793f2840782216a4d83fc71a08f53cffc862", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e02de946125c36871bd4d8eff21f7f88f01a8aa/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e02de946125c36871bd4d8eff21f7f88f01a8aa/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=6e02de946125c36871bd4d8eff21f7f88f01a8aa", "patch": "@@ -115,6 +115,18 @@ gimple_range_ssa_p (tree exp)\n   return NULL_TREE;\n }\n \n+// Return true if TYPE1 and TYPE2 are compatible range types.\n+\n+static inline bool\n+range_compatible_p (tree type1, tree type2)\n+{\n+  // types_compatible_p requires conversion in both directions to be useless.\n+  // GIMPLE only requires a cast one way in order to be compatible.\n+  // Ranges really only need the sign and precision to be the same.\n+  return (TYPE_PRECISION (type1) == TYPE_PRECISION (type2)\n+\t  && TYPE_SIGN (type1) == TYPE_SIGN (type2));\n+}\n+\n // Return the legacy GCC global range for NAME if it has one, otherwise\n // return VARYING.\n "}, {"sha": "48aebf1b100c41427d2fda6a8a4cae78cd4afc2a", "filename": "gcc/testsuite/gcc.dg/pr97360-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e02de946125c36871bd4d8eff21f7f88f01a8aa/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97360-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e02de946125c36871bd4d8eff21f7f88f01a8aa/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97360-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97360-2.c?ref=6e02de946125c36871bd4d8eff21f7f88f01a8aa", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 \" } */\n+\n+void *a;\n+void *b(void);\n+void *e(void);\n+\n+void *\n+c() {\n+  void *d;\n+  if (d == b && e())\n+    d = a;\n+  return d;\n+}"}]}