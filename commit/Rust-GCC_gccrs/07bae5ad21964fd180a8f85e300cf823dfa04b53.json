{"sha": "07bae5ad21964fd180a8f85e300cf823dfa04b53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdiYWU1YWQyMTk2NGZkMTgwYThmODVlMzAwY2Y4MjNkZmEwNGI1Mw==", "commit": {"author": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-06-06T12:36:26Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-06-06T12:36:26Z"}, "message": "fold-const.c (fold <ABS_EXPR>): Re-fold the result of folding fabs(-x) into fabs(x).\n\n\n\t* fold-const.c (fold <ABS_EXPR>):  Re-fold the result of folding\n\tfabs(-x) into fabs(x).  Use tree_expr_nonnegative_p to determine\n\twhen the ABS_EXPR (fabs or abs) is not required.\n  \t(tree_expr_nonnegative_p): Move the logic that sqrt and exp are\n\talways nonnegative from fold to here.  Additionally, cabs and fabs\n\tare always non-negative, and pow and atan are non-negative if\n\ttheir first argument is non-negative.\n\n\t* builtins.c (fold_builtin_cabs): New function to fold cabs{,f,l}.\n\tEvaluate cabs of a constant at compile-time.  Convert cabs of a\n\tnon-complex argument into fabs.  Convert cabs(z) into\n\tsqrt(z.r*z.r + z.i*z.i) at the tree-level with -ffast-math or\n\t-funsafe-math-optimizations or -ffast-math.\n\t(fold_builtin): Convert BUILT_IN_FABS{,F,L} into an ABS_EXPR.\n\tFold BUILT_IN_CABS{,F,L} using fold_builtin_cabs.\n\n\t* gcc.dg/builtins-2.c: Add some more tests.\n\t* gcc.dg/builtins-18.c: New test case.\n\t* gcc.dg/builtins-19.c: New test case.\n\nFrom-SVN: r67541", "tree": {"sha": "853d13ba808d4dc5f75ea461cff59feb4787b64b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/853d13ba808d4dc5f75ea461cff59feb4787b64b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07bae5ad21964fd180a8f85e300cf823dfa04b53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07bae5ad21964fd180a8f85e300cf823dfa04b53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07bae5ad21964fd180a8f85e300cf823dfa04b53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07bae5ad21964fd180a8f85e300cf823dfa04b53/comments", "author": null, "committer": null, "parents": [{"sha": "84cd52a9a95c0737455364222901afb418f7c345", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84cd52a9a95c0737455364222901afb418f7c345", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84cd52a9a95c0737455364222901afb418f7c345"}], "stats": {"total": 333, "additions": 316, "deletions": 17}, "files": [{"sha": "cc46df80755ce57fae2b26e6e58f9c40295759de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07bae5ad21964fd180a8f85e300cf823dfa04b53/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07bae5ad21964fd180a8f85e300cf823dfa04b53/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07bae5ad21964fd180a8f85e300cf823dfa04b53", "patch": "@@ -1,11 +1,30 @@\n+2003-06-06  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (fold <ABS_EXPR>):  Re-fold the result of folding\n+\tfabs(-x) into fabs(x).  Use tree_expr_nonnegative_p to determine\n+\twhen the ABS_EXPR (fabs or abs) is not required.\n+  \t(tree_expr_nonnegative_p): Move the logic that sqrt and exp are\n+\talways nonnegative from fold to here.  Additionally, cabs and fabs\n+\tare always non-negative, and pow and atan are non-negative if\n+\ttheir first argument is non-negative.\n+\n+\t* builtins.c (fold_builtin_cabs): New function to fold cabs{,f,l}.\n+\tEvaluate cabs of a constant at compile-time.  Convert cabs of a\n+\tnon-complex argument into fabs.  Convert cabs(z) into\n+\tsqrt(z.r*z.r + z.i*z.i) at the tree-level with -ffast-math or\n+\t-funsafe-math-optimizations or -ffast-math.\n+\t(fold_builtin): Convert BUILT_IN_FABS{,F,L} into an ABS_EXPR.\n+\tFold BUILT_IN_CABS{,F,L} using fold_builtin_cabs.\n+\n Thu Jun  5 20:51:09 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* sourcebuild.texi (Front End Directory): Document new hooks.\n \n Fri Jun  6 11:02:35 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* function.c (FLOOR_ROUND, CEIL_ROUND): Fix.\n-\t* i386.md (gen_pro_epilogue_adjust_stack): Deal with gigantic stack frames.\n+\t* i386.md (gen_pro_epilogue_adjust_stack): Deal with gigantic\n+\tstack frames.\n \t(pro_epilogue_adjust_stack_rex64_2): New pattern\n \n Fri Jun  6 11:03:14 CEST 2003  Jan Hubicka  <jh@suse.cz>"}, {"sha": "79d46bce2a0e9fc3d6e72fb6c7d0c101710fe64b", "filename": "gcc/builtins.c", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07bae5ad21964fd180a8f85e300cf823dfa04b53/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07bae5ad21964fd180a8f85e300cf823dfa04b53/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=07bae5ad21964fd180a8f85e300cf823dfa04b53", "patch": "@@ -177,6 +177,7 @@ static bool readonly_data_expr\t\tPARAMS ((tree));\n static rtx expand_builtin_fabs\t\tPARAMS ((tree, rtx, rtx));\n static rtx expand_builtin_cabs\t\tPARAMS ((tree, rtx));\n static void init_builtin_dconsts\tPARAMS ((void));\n+static tree fold_builtin_cabs\t\tPARAMS ((tree, tree, tree));\n \n /* Initialize mathematical constants for constant folding builtins.\n    These constants need to be given to atleast 160 bits precision.  */\n@@ -5135,6 +5136,92 @@ fold_trunc_transparent_mathfn (exp)\n   return 0;\n }\n \n+/* Fold function call to builtin cabs, cabsf or cabsl.  FNDECL is the\n+   function's DECL, ARGLIST is the argument list and TYPE is the return\n+   type.  Return NULL_TREE if no simplification can be made.  */\n+\n+static tree\n+fold_builtin_cabs (fndecl, arglist, type)\n+     tree fndecl, arglist, type;\n+{\n+  tree arg;\n+\n+  if (!arglist || TREE_CHAIN (arglist))\n+    return NULL_TREE;\n+\n+  arg = TREE_VALUE (arglist);\n+  if (TREE_CODE (TREE_TYPE (arg)) != COMPLEX_TYPE\n+      || TREE_CODE (TREE_TYPE (TREE_TYPE (arg))) != REAL_TYPE)\n+    return NULL_TREE;\n+\n+  /* Evaluate cabs of a constant at compile-time.  */\n+  if (flag_unsafe_math_optimizations\n+      && TREE_CODE (arg) == COMPLEX_CST\n+      && TREE_CODE (TREE_REALPART (arg)) == REAL_CST\n+      && TREE_CODE (TREE_IMAGPART (arg)) == REAL_CST\n+      && ! TREE_CONSTANT_OVERFLOW (TREE_REALPART (arg))\n+      && ! TREE_CONSTANT_OVERFLOW (TREE_IMAGPART (arg)))\n+    {\n+      REAL_VALUE_TYPE r, i;\n+\n+      r = TREE_REAL_CST (TREE_REALPART (arg));\n+      i = TREE_REAL_CST (TREE_IMAGPART (arg));\n+\n+      real_arithmetic (&r, MULT_EXPR, &r, &r);\n+      real_arithmetic (&i, MULT_EXPR, &i, &i);\n+      real_arithmetic (&r, PLUS_EXPR, &r, &i);\n+      if (real_sqrt (&r, TYPE_MODE (type), &r)\n+\t  || ! flag_trapping_math)\n+\treturn build_real (type, r);\n+    }\n+\n+  /* If either part is zero, cabs is fabs of the other.  */\n+  if (TREE_CODE (arg) == COMPLEX_EXPR\n+      && real_zerop (TREE_OPERAND (arg, 0)))\n+    return fold (build1 (ABS_EXPR, type, TREE_OPERAND (arg, 1)));\n+  if (TREE_CODE (arg) == COMPLEX_EXPR\n+      && real_zerop (TREE_OPERAND (arg, 1)))\n+    return fold (build1 (ABS_EXPR, type, TREE_OPERAND (arg, 0)));\n+\n+  if (flag_unsafe_math_optimizations)\n+    {\n+      enum built_in_function fcode;\n+      tree sqrtfn;\n+\n+      fcode = DECL_FUNCTION_CODE (fndecl);\n+      if (fcode == BUILT_IN_CABS)\n+\tsqrtfn = implicit_built_in_decls[BUILT_IN_SQRT];\n+      else if (fcode == BUILT_IN_CABSF)\n+\tsqrtfn = implicit_built_in_decls[BUILT_IN_SQRTF];\n+      else if (fcode == BUILT_IN_CABSL)\n+\tsqrtfn = implicit_built_in_decls[BUILT_IN_SQRTL];\n+      else\n+\tsqrtfn = NULL_TREE;\n+\n+      if (sqrtfn != NULL_TREE)\n+\t{\n+\t  tree rpart, ipart, result, arglist;\n+\n+\t  rpart = fold (build1 (REALPART_EXPR, type, arg));\n+\t  ipart = fold (build1 (IMAGPART_EXPR, type, arg));\n+\n+\t  rpart = save_expr (rpart);\n+\t  ipart = save_expr (ipart);\n+\n+\t  result = fold (build (PLUS_EXPR, type,\n+\t\t\t\tfold (build (MULT_EXPR, type,\n+\t\t\t\t\t     rpart, rpart)),\n+\t\t\t\tfold (build (MULT_EXPR, type,\n+\t\t\t\t\t     ipart, ipart))));\n+\n+\t  arglist = build_tree_list (NULL_TREE, result);\n+\t  return build_function_call_expr (sqrtfn, arglist);\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Used by constant folding to eliminate some builtin calls early.  EXP is\n    the CALL_EXPR of a call to a builtin function.  */\n \n@@ -5171,6 +5258,18 @@ fold_builtin (exp)\n \t}\n       break;\n \n+    case BUILT_IN_FABS:\n+    case BUILT_IN_FABSF:\n+    case BUILT_IN_FABSL:\n+      if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+\treturn fold (build1 (ABS_EXPR, type, TREE_VALUE (arglist)));\n+      break;\n+\n+    case BUILT_IN_CABS:\n+    case BUILT_IN_CABSF:\n+    case BUILT_IN_CABSL:\n+      return fold_builtin_cabs (fndecl, arglist, type);\n+\n     case BUILT_IN_SQRT:\n     case BUILT_IN_SQRTF:\n     case BUILT_IN_SQRTL:"}, {"sha": "aa99e40aaac55548afcc27f4b19e9df82fd05d34", "filename": "gcc/fold-const.c", "status": "modified", "additions": 47, "deletions": 16, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07bae5ad21964fd180a8f85e300cf823dfa04b53/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07bae5ad21964fd180a8f85e300cf823dfa04b53/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=07bae5ad21964fd180a8f85e300cf823dfa04b53", "patch": "@@ -5405,29 +5405,19 @@ fold (expr)\n \t\t\t\tREAL_VALUE_NEGATE (TREE_REAL_CST (arg0)));\n \t    }\n \t}\n-      else if (TREE_CODE (arg0) == ABS_EXPR || TREE_CODE (arg0) == NEGATE_EXPR)\n-\treturn build1 (ABS_EXPR, type, TREE_OPERAND (arg0, 0));\n+      else if (TREE_CODE (arg0) == NEGATE_EXPR)\n+\treturn fold (build1 (ABS_EXPR, type, TREE_OPERAND (arg0, 0)));\n       /* Convert fabs((double)float) into (double)fabsf(float).  */\n       else if (TREE_CODE (arg0) == NOP_EXPR\n \t       && TREE_CODE (type) == REAL_TYPE)\n \t{\n \t  tree targ0 = strip_float_extensions (arg0);\n \t  if (targ0 != arg0)\n-\t    return convert (type, build1 (ABS_EXPR, TREE_TYPE (targ0), targ0));\n-\t\t\t   \n-\t}\n-      else\n-\t{\n-\t  /* fabs(sqrt(x)) = sqrt(x) and fabs(exp(x)) = exp(x).  */\n-\t  enum built_in_function fcode = builtin_mathfn_code (arg0);\n-\t  if (fcode == BUILT_IN_SQRT\n-\t      || fcode == BUILT_IN_SQRTF\n-\t      || fcode == BUILT_IN_SQRTL\n-\t      || fcode == BUILT_IN_EXP\n-\t      || fcode == BUILT_IN_EXPF\n-\t      || fcode == BUILT_IN_EXPL)\n-\t    t = arg0;\n+\t    return convert (type, fold (build1 (ABS_EXPR, TREE_TYPE (targ0),\n+\t\t\t\t\t\ttarg0)));\n \t}\n+      else if (tree_expr_nonnegative_p (arg0))\n+\treturn arg0;\n       return t;\n \n     case CONJ_EXPR:\n@@ -7928,6 +7918,47 @@ tree_expr_nonnegative_p (t)\n     case RTL_EXPR:\n       return rtl_expr_nonnegative_p (RTL_EXPR_RTL (t));\n \n+    case CALL_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR)\n+\t{\n+\t  tree fndecl = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n+\t  tree arglist = TREE_OPERAND (t, 1);\n+\t  if (TREE_CODE (fndecl) == FUNCTION_DECL\n+\t      && DECL_BUILT_IN (fndecl)\n+\t      && DECL_BUILT_IN_CLASS (fndecl) != BUILT_IN_MD)\n+\t    switch (DECL_FUNCTION_CODE (fndecl))\n+\t      {\n+\t      case BUILT_IN_CABS:\n+\t      case BUILT_IN_CABSL:\n+\t      case BUILT_IN_CABSF:\n+\t      case BUILT_IN_EXP:\n+\t      case BUILT_IN_EXPF:\n+\t      case BUILT_IN_EXPL:\n+\t      case BUILT_IN_FABS:\n+\t      case BUILT_IN_FABSF:\n+\t      case BUILT_IN_FABSL:\n+\t      case BUILT_IN_SQRT:\n+\t      case BUILT_IN_SQRTF:\n+\t      case BUILT_IN_SQRTL:\n+\t\treturn 1;\n+\n+\t      case BUILT_IN_ATAN:\n+\t      case BUILT_IN_ATANF:\n+\t      case BUILT_IN_ATANL:\n+\t\treturn tree_expr_nonnegative_p (TREE_VALUE (arglist));\n+\n+\t      case BUILT_IN_POW:\n+\t      case BUILT_IN_POWF:\n+\t      case BUILT_IN_POWL:\n+\t\treturn tree_expr_nonnegative_p (TREE_VALUE (arglist));\n+\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t}\n+\n+      /* ... fall through ... */\n+\n     default:\n       if (truth_value_p (TREE_CODE (t)))\n \t/* Truth values evaluate to 0 or 1, which is nonnegative.  */"}, {"sha": "0454ea51aa1ab546ce6ef6e74cd54776e082bd90", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07bae5ad21964fd180a8f85e300cf823dfa04b53/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07bae5ad21964fd180a8f85e300cf823dfa04b53/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=07bae5ad21964fd180a8f85e300cf823dfa04b53", "patch": "@@ -1,3 +1,9 @@\n+2003-06-06  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.dg/builtins-2.c: Add some more tests.\n+\t* gcc.dg/builtins-18.c: New test case.\n+\t* gcc.dg/builtins-19.c: New test case.\n+\n 2003-06-06  Roger Sayle  <roger@eyesopen.com>\n \t    Jim Wilson  <wilson@tuliptree.org>\n "}, {"sha": "86338c03e0968a13871f75debc14ee3a9b14857a", "filename": "gcc/testsuite/gcc.dg/builtins-18.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07bae5ad21964fd180a8f85e300cf823dfa04b53/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07bae5ad21964fd180a8f85e300cf823dfa04b53/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-18.c?ref=07bae5ad21964fd180a8f85e300cf823dfa04b53", "patch": "@@ -0,0 +1,58 @@\n+/* Copyright (C) 2003 Free Software Foundation.\n+\n+   Check that built-in cabs, cabsf and cabsl functions don't\n+   break anything and produces the expected results.\n+\n+   Written by Roger Sayle, 1st June 2003.  */\n+\n+/* { dg-do link } */\n+/* { dg-options \"-O2 -ffast-math\" } */\n+\n+extern void link_error(void);\n+\n+extern float cabsf (float _Complex);\n+extern double cabs (double _Complex);\n+extern long double cabsl (long double _Complex);\n+\n+int\n+main (void)\n+{\n+  /* For each type, test both runtime and compile time (constant folding)\n+     optimization.  */\n+  float _Complex fc = 3.0F + 4.0iF;\n+  double _Complex dc = 3.0 + 4.0i;\n+  long double _Complex ldc = 3.0L + 4.0iL;\n+\n+  /* Test floats.  */\n+  if (cabsf (fc) != 5.0F)\n+    link_error ();\n+  if (__builtin_cabsf (fc) != 5.0F)\n+    link_error ();\n+  if (cabsf (3.0F + 4.0iF) != 5.0F)\n+    link_failure ();\n+  if (__builtin_cabsf (3.0F + 4.0iF) != 5.0F)\n+    link_failure ();\n+\n+  /* Test doubles.  */\n+  if (cabs (dc) != 5.0)\n+    link_error ();\n+  if (__builtin_cabs (dc) != 5.0)\n+    link_error ();\n+  if (cabs (3.0 + 4.0i) != 5.0)\n+    link_failure ();\n+  if (__builtin_cabs (3.0 + 4.0i) != 5.0)\n+    link_failure ();\n+\n+  /* Test long doubles.  */\n+  if (cabsl (ldc) != 5.0L)\n+    link_error ();\n+  if (__builtin_cabsl (ldc) != 5.0L)\n+    link_error ();\n+  if (cabsl (3.0L + 4.0iL) != 5.0L)\n+    link_failure ();\n+  if (__builtin_cabsl (3.0L + 4.0iL) != 5.0L)\n+    link_failure ();\n+\n+  return 0;\n+}\n+"}, {"sha": "064321f321429c902e9f1dad17e6d8cab433db4c", "filename": "gcc/testsuite/gcc.dg/builtins-19.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07bae5ad21964fd180a8f85e300cf823dfa04b53/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07bae5ad21964fd180a8f85e300cf823dfa04b53/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-19.c?ref=07bae5ad21964fd180a8f85e300cf823dfa04b53", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 2003  Free Software Foundation.\n+\n+   Check that cabs of a non-complex argument is converted into fabs.\n+\n+   Written by Roger Sayle, 1st June 2003.  */\n+\n+/* { dg-do link } */\n+/* { dg-options \"-O2 -ansi\" } */\n+\n+double cabs (__complex__ double);\n+float cabsf (__complex__ float);\n+long double cabsl (__complex__ long double);\n+\n+void link_error (void);\n+\n+void test (double x)\n+{\n+  if (cabs (x) != fabs (x))\n+    link_error ();\n+}\n+\n+void testf (float x)\n+{\n+  if (cabsf (x) != fabsf (x))\n+    link_error ();\n+}\n+\n+void testl (long double x)\n+{\n+  if (cabsl (x) != fabsl (x))\n+    link_error ();\n+}\n+\n+int main ()\n+{\n+  test (1.0);\n+  testf (1.0f);\n+  testl (1.0l);\n+  return 0;\n+}\n+"}, {"sha": "895b80a2ef98d235dc494eebd3f225e568b3802d", "filename": "gcc/testsuite/gcc.dg/builtins-2.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07bae5ad21964fd180a8f85e300cf823dfa04b53/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07bae5ad21964fd180a8f85e300cf823dfa04b53/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-2.c?ref=07bae5ad21964fd180a8f85e300cf823dfa04b53", "patch": "@@ -58,6 +58,21 @@ double test10(double x)\n   return tan(atan(x));\n }\n \n+double test11(double x)\n+{\n+  return fabs(fabs(x));\n+}\n+\n+double test12(double x)\n+{\n+  return fabs(atan(x));\n+}\n+\n+double test13(double x)\n+{\n+  return fabs(pow(2.0,x));\n+}\n+\n float test1f(float x)\n {\n   return logf(expf(x));\n@@ -108,6 +123,21 @@ float test10f(float x)\n   return tanf(atanf(x));\n }\n \n+floatf test11f(float x)\n+{\n+  return fabsf(fabsf(x));\n+}\n+\n+floatf test12f(float x)\n+{\n+  return fabsf(atanf(x));\n+}\n+\n+float test13f(float x)\n+{\n+  return fabsf(powf(2.0f,x));\n+}\n+\n long double test1l(long double x)\n {\n   return logl(expl(x));\n@@ -158,3 +188,18 @@ long double test10l(long double x)\n   return tanl(atanl(x));\n }\n \n+long double test11l(long double x)\n+{\n+  return fabsl(fabsl(x));\n+}\n+\n+long double test12l(long double x)\n+{\n+  return fabsl(atanl(x));\n+}\n+\n+long double test13l(long double x)\n+{\n+  return fabsl(powl(2.0l,x));\n+}\n+"}]}