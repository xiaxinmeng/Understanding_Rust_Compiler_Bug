{"sha": "714445ae04640bc096693623fb805bcf14148663", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE0NDQ1YWUwNDY0MGJjMDk2NjkzNjIzZmI4MDViY2YxNDE0ODY2Mw==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-12-02T14:13:11Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-12-02T14:13:11Z"}, "message": "match.pd: Add new pattern: (cond (cmp (convert?\n\n\t* match.pd: Add new pattern:\n\t(cond (cmp (convert? x) c1) (op x c2) c3) -> (op (minmax x c1) c2).\n\tgcc/testsuite\n\t* gcc.dg/fold-bopcond-1.c: New test.\n\t* gcc.dg/fold-bopcond-2.c: New test.\n\nFrom-SVN: r243180", "tree": {"sha": "cdfa44848ffd774d45ea67c233edfb0982bdf3d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cdfa44848ffd774d45ea67c233edfb0982bdf3d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/714445ae04640bc096693623fb805bcf14148663", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/714445ae04640bc096693623fb805bcf14148663", "html_url": "https://github.com/Rust-GCC/gccrs/commit/714445ae04640bc096693623fb805bcf14148663", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/714445ae04640bc096693623fb805bcf14148663/comments", "author": null, "committer": null, "parents": [{"sha": "d313d52cd5fff9374f01967fb7964b6633df219c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d313d52cd5fff9374f01967fb7964b6633df219c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d313d52cd5fff9374f01967fb7964b6633df219c"}], "stats": {"total": 206, "additions": 206, "deletions": 0}, "files": [{"sha": "85b4bdb0ae0fbd76cd45772e67f907781c9bd9aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/714445ae04640bc096693623fb805bcf14148663/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/714445ae04640bc096693623fb805bcf14148663/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=714445ae04640bc096693623fb805bcf14148663", "patch": "@@ -1,3 +1,8 @@\n+2016-12-02  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* match.pd: Add new pattern:\n+\t(cond (cmp (convert? x) c1) (op x c2) c3) -> (op (minmax x c1) c2).\n+\n 2016-12-02  Nathan Sidwell  <nathan@acm.org>\n \n \t* diagnostic.c (diagnostic_report_diagnostic): Remove extraneous"}, {"sha": "dbb91034e95a3b71af5b717cec86a0025a0c8cf6", "filename": "gcc/match.pd", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/714445ae04640bc096693623fb805bcf14148663/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/714445ae04640bc096693623fb805bcf14148663/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=714445ae04640bc096693623fb805bcf14148663", "patch": "@@ -2038,6 +2038,106 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n       (convert (cond (eq @1 (convert @3))\n \t\t     (convert:from_type @3) (convert:from_type @2)))))))))\n \n+/* (cond (cmp (convert? x) c1) (op x c2) c3) -> (op (minmax x c1) c2) if:\n+\n+     1) OP is PLUS or MINUS.\n+     2) CMP is LT, LE, GT or GE.\n+     3) C3 == (C1 op C2), and computation doesn't have undefined behavior.\n+\n+   This pattern also handles special cases like:\n+\n+     A) Operand x is a unsigned to signed type conversion and c1 is\n+\tinteger zero.  In this case,\n+\t  (signed type)x  < 0  <=>  x  > MAX_VAL(signed type)\n+\t  (signed type)x >= 0  <=>  x <= MAX_VAL(signed type)\n+     B) Const c1 may not equal to (C3 op' C2).  In this case we also\n+\tcheck equality for (c1+1) and (c1-1) by adjusting comparison\n+\tcode.\n+\n+   TODO: Though signed type is handled by this pattern, it cannot be\n+   simplified at the moment because C standard requires additional\n+   type promotion.  In order to match&simplify it here, the IR needs\n+   to be cleaned up by other optimizers, i.e, VRP.  */\n+(for op (plus minus)\n+ (for cmp (lt le gt ge)\n+  (simplify\n+   (cond (cmp (convert? @X) INTEGER_CST@1) (op @X INTEGER_CST@2) INTEGER_CST@3)\n+   (with { tree from_type = TREE_TYPE (@X), to_type = TREE_TYPE (@1); }\n+    (if (types_match (from_type, to_type)\n+\t /* Check if it is special case A).  */\n+\t || (TYPE_UNSIGNED (from_type)\n+\t     && !TYPE_UNSIGNED (to_type)\n+\t     && TYPE_PRECISION (from_type) == TYPE_PRECISION (to_type)\n+\t     && integer_zerop (@1)\n+\t     && (cmp == LT_EXPR || cmp == GE_EXPR)))\n+     (with\n+      {\n+\tbool overflow = false;\n+\tenum tree_code code, cmp_code = cmp;\n+\twide_int real_c1, c1 = @1, c2 = @2, c3 = @3;\n+\tsignop sgn = TYPE_SIGN (from_type);\n+\n+\t/* Handle special case A), given x of unsigned type:\n+\t    ((signed type)x  < 0) <=> (x  > MAX_VAL(signed type))\n+\t    ((signed type)x >= 0) <=> (x <= MAX_VAL(signed type))  */\n+\tif (!types_match (from_type, to_type))\n+\t  {\n+\t    if (cmp_code == LT_EXPR)\n+\t      cmp_code = GT_EXPR;\n+\t    if (cmp_code == GE_EXPR)\n+\t      cmp_code = LE_EXPR;\n+\t    c1 = wi::max_value (to_type);\n+\t  }\n+\t/* To simplify this pattern, we require c3 = (c1 op c2).  Here we\n+\t   compute (c3 op' c2) and check if it equals to c1 with op' being\n+\t   the inverted operator of op.  Make sure overflow doesn't happen\n+\t   if it is undefined.  */\n+\tif (op == PLUS_EXPR)\n+\t  real_c1 = wi::sub (c3, c2, sgn, &overflow);\n+\telse\n+\t  real_c1 = wi::add (c3, c2, sgn, &overflow);\n+\n+\tcode = cmp_code;\n+\tif (!overflow || !TYPE_OVERFLOW_UNDEFINED (from_type))\n+\t  {\n+\t    /* Check if c1 equals to real_c1.  Boundary condition is handled\n+\t       by adjusting comparison operation if necessary.  */\n+\t    if (!wi::cmp (wi::sub (real_c1, 1, sgn, &overflow), c1, sgn)\n+\t\t&& !overflow)\n+\t      {\n+\t\t/* X <= Y - 1 equals to X < Y.  */\n+\t\tif (cmp_code == LE_EXPR)\n+\t\t  code = LT_EXPR;\n+\t\t/* X > Y - 1 equals to X >= Y.  */\n+\t\tif (cmp_code == GT_EXPR)\n+\t\t  code = GE_EXPR;\n+\t      }\n+\t    if (!wi::cmp (wi::add (real_c1, 1, sgn, &overflow), c1, sgn)\n+\t\t&& !overflow)\n+\t      {\n+\t\t/* X < Y + 1 equals to X <= Y.  */\n+\t\tif (cmp_code == LT_EXPR)\n+\t\t  code = LE_EXPR;\n+\t\t/* X >= Y + 1 equals to X > Y.  */\n+\t\tif (cmp_code == GE_EXPR)\n+\t\t  code = GT_EXPR;\n+\t      }\n+\t    if (code != cmp_code || !wi::cmp (real_c1, c1, sgn))\n+\t      {\n+\t\tif (cmp_code == LT_EXPR || cmp_code == LE_EXPR)\n+\t\t  code = MIN_EXPR;\n+\t\tif (cmp_code == GT_EXPR || cmp_code == GE_EXPR)\n+\t\t  code = MAX_EXPR;\n+\t      }\n+\t  }\n+      }\n+      (if (code == MAX_EXPR)\n+       (op (max @X { wide_int_to_tree (from_type, real_c1); })\n+\t   { wide_int_to_tree (from_type, c2); })\n+       (if (code == MIN_EXPR)\n+\t(op (min @X { wide_int_to_tree (from_type, real_c1); })\n+\t    { wide_int_to_tree (from_type, c2); })))))))))\n+\n (for cnd (cond vec_cond)\n  /* A ? B : (A ? X : C) -> A ? B : C.  */\n  (simplify"}, {"sha": "143687de60d4643cce58cd42da85eece6bf2f5cb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/714445ae04640bc096693623fb805bcf14148663/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/714445ae04640bc096693623fb805bcf14148663/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=714445ae04640bc096693623fb805bcf14148663", "patch": "@@ -1,3 +1,8 @@\n+2016-12-02  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/fold-bopcond-1.c: New test.\n+\t* gcc.dg/fold-bopcond-2.c: New test.\n+\n 2016-12-02  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n \n \t* gcc.target/s390/md/setmem_long-1.c: Fix test."}, {"sha": "7324c166c8e702ad6c21daa60dab1f915364e5cb", "filename": "gcc/testsuite/gcc.dg/fold-bopcond-1.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/714445ae04640bc096693623fb805bcf14148663/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-bopcond-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/714445ae04640bc096693623fb805bcf14148663/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-bopcond-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-bopcond-1.c?ref=714445ae04640bc096693623fb805bcf14148663", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-ifcvt\" } */\n+\n+int foo1 (unsigned short a[], unsigned int x)\n+{\n+  unsigned int i;\n+  for (i = 0; i < 1000; i++)\n+    {\n+      x = a[i];\n+      a[i] = (unsigned short)(x <= 32768 ? x + 32768 : 0);\n+    }\n+  return x;\n+}\n+\n+int foo2 (unsigned short a[], unsigned int x)\n+{\n+  unsigned int i;\n+  for (i = 0; i < 1000; i++)\n+    {\n+      x = a[i];\n+      a[i] = (unsigned short)(x < 32768 ? x + 32768 : 0);\n+    }\n+  return x;\n+}\n+\n+int foo3 (unsigned short a[], unsigned int x)\n+{\n+  unsigned int i;\n+  for (i = 0; i < 1000; i++)\n+    {\n+      x = a[i];\n+      a[i] = (unsigned short)(x < 1000 ? x - 1000 : 0);\n+    }\n+  return x;\n+}\n+\n+int foo4 (unsigned short a[], unsigned int x)\n+{\n+  unsigned int i;\n+  for (i = 0; i < 1000; i++)\n+    {\n+      x = a[i];\n+      a[i] = (unsigned short)(x <= 2 ? x + 999 : 1001);\n+    }\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"MIN_EXPR \" 4 \"ifcvt\" } } */"}, {"sha": "7a47449f93c6d7e8c4d353f470258cb5047c55e9", "filename": "gcc/testsuite/gcc.dg/fold-bopcond-2.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/714445ae04640bc096693623fb805bcf14148663/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-bopcond-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/714445ae04640bc096693623fb805bcf14148663/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-bopcond-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-bopcond-2.c?ref=714445ae04640bc096693623fb805bcf14148663", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-ifcvt\" } */\n+\n+int foo1 (unsigned short a[], unsigned int x)\n+{\n+  unsigned int i;\n+  for (i = 0; i < 1000; i++)\n+    {\n+      x = a[i];\n+      a[i] = (unsigned short)(x >= 32768 ? x - 32768 : 0);\n+    }\n+  return x;\n+}\n+\n+int foo2 (unsigned short a[], unsigned int x)\n+{\n+  unsigned int i;\n+  for (i = 0; i < 1000; i++)\n+    {\n+      x = a[i];\n+      a[i] = (unsigned short)(x > 32768 ? x - 32768 : 0);\n+    }\n+  return x;\n+}\n+\n+int foo3 (unsigned short a[], unsigned int x)\n+{\n+  unsigned int i;\n+  for (i = 0; i < 1000; i++)\n+    {\n+      x = a[i];\n+      a[i] = (unsigned short)(x > 1000 ? x - 1000 : 0);\n+    }\n+  return x;\n+}\n+\n+int foo4 (unsigned short a[], unsigned int x)\n+{\n+  unsigned int i;\n+  for (i = 0; i < 1000; i++)\n+    {\n+      x = a[i];\n+      a[i] = (unsigned short)(x >= 2 ? x - 32768 : 32770);\n+    }\n+  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"MAX_EXPR \" 4 \"ifcvt\" } } */"}]}