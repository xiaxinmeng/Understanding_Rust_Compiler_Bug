{"sha": "05dbb83f9e3b783de3d666348b1d1a0e7895b09f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVkYmI4M2Y5ZTNiNzgzZGUzZDY2NjM0OGIxZDFhMGU3ODk1YjA5Zg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-05-02T09:17:13Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-05-02T09:17:13Z"}, "message": "[multiple changes]\n\n2017-05-02  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* einfo.ads (Corresponding_Record_Component): New alias\n\tfor Node21 used for E_Component and E_Discriminant.\n\t* einfo.adb (Corresponding_Record_Component): New function.\n\t(Set_Corresponding_Record_Component): New procedure.\n\t(Write_Field21_Name): Handle Corresponding_Record_Component.\n\t* sem_ch3.adb (Inherit_Component): Set\n\tCorresponding_Record_Component for every component in\n\tthe untagged case.  Clear it afterwards for non-girder\n\tdiscriminants.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity)\n\t<E_Record_Type>: For a derived untagged type with discriminants\n\tand constraints, apply the constraints to the layout of the\n\tparent type to deduce the layout.\n\t(field_is_aliased): Delete.\n\t(components_to_record): Test DECL_ALIASED_P directly.\n\t(annotate_rep): Check that fields are present except for\n\tan extension.\n\t(create_field_decl_from): Add DEBUG_INFO_P\n\tparameter and pass it in recursive and other calls.  Add guard\n\tfor the manual CSE on the size.\n\t(is_stored_discriminant): New predicate.\n\t(copy_and_substitute_in_layout): Consider only\n\tstored discriminants and check that original fields are present\n\tin the old type.  Deal with derived types.  Adjust call to\n\tcreate_variant_part_from.\n\n2017-05-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch6.adb (Expand_Call_Helper): When locating the\n\taccessibility entity created for an access parameter, handle\n\tproperly a reference to a formal of an enclosing subprogram. if\n\tthe reference appears in an inherited class-wide condition, it\n\tis the rewriting of the reference in the ancestor expression,\n\tbut the accessibility entity must be that of the current formal.\n\n2017-05-02  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch4.adb (Expand_Non_Binary_Modular_Op): New subprogram.\n\t(Expand_N_Op_Add, Expand_N_Op_Divide, Expand_N_Op_Minus,\n\tExpand_N_Op_Multiply, Expand_N_Op_Or, Expand_N_Op_Subtract):\n\tCall Expand_Non_Binary_Modular_Op.\n\nFrom-SVN: r247482", "tree": {"sha": "03003c1d82165fde90d6368af3d8dc265453c7ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03003c1d82165fde90d6368af3d8dc265453c7ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05dbb83f9e3b783de3d666348b1d1a0e7895b09f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05dbb83f9e3b783de3d666348b1d1a0e7895b09f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05dbb83f9e3b783de3d666348b1d1a0e7895b09f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05dbb83f9e3b783de3d666348b1d1a0e7895b09f/comments", "author": null, "committer": null, "parents": [{"sha": "f934fd02a09a3f8ec105fb0b39708386cc202c5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f934fd02a09a3f8ec105fb0b39708386cc202c5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f934fd02a09a3f8ec105fb0b39708386cc202c5b"}], "stats": {"total": 1138, "additions": 756, "deletions": 382}, "files": [{"sha": "7892b6953a10c28e76cf1cb402430c5da4068011", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dbb83f9e3b783de3d666348b1d1a0e7895b09f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dbb83f9e3b783de3d666348b1d1a0e7895b09f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=05dbb83f9e3b783de3d666348b1d1a0e7895b09f", "patch": "@@ -1,3 +1,47 @@\n+2017-05-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* einfo.ads (Corresponding_Record_Component): New alias\n+\tfor Node21 used for E_Component and E_Discriminant.\n+\t* einfo.adb (Corresponding_Record_Component): New function.\n+\t(Set_Corresponding_Record_Component): New procedure.\n+\t(Write_Field21_Name): Handle Corresponding_Record_Component.\n+\t* sem_ch3.adb (Inherit_Component): Set\n+\tCorresponding_Record_Component for every component in\n+\tthe untagged case.  Clear it afterwards for non-girder\n+\tdiscriminants.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity)\n+\t<E_Record_Type>: For a derived untagged type with discriminants\n+\tand constraints, apply the constraints to the layout of the\n+\tparent type to deduce the layout.\n+\t(field_is_aliased): Delete.\n+\t(components_to_record): Test DECL_ALIASED_P directly.\n+\t(annotate_rep): Check that fields are present except for\n+\tan extension.\n+\t(create_field_decl_from): Add DEBUG_INFO_P\n+\tparameter and pass it in recursive and other calls.  Add guard\n+\tfor the manual CSE on the size.\n+\t(is_stored_discriminant): New predicate.\n+\t(copy_and_substitute_in_layout): Consider only\n+\tstored discriminants and check that original fields are present\n+\tin the old type.  Deal with derived types.  Adjust call to\n+\tcreate_variant_part_from.\n+\n+2017-05-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Call_Helper): When locating the\n+\taccessibility entity created for an access parameter, handle\n+\tproperly a reference to a formal of an enclosing subprogram. if\n+\tthe reference appears in an inherited class-wide condition, it\n+\tis the rewriting of the reference in the ancestor expression,\n+\tbut the accessibility entity must be that of the current formal.\n+\n+2017-05-02  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Non_Binary_Modular_Op): New subprogram.\n+\t(Expand_N_Op_Add, Expand_N_Op_Divide, Expand_N_Op_Minus,\n+\tExpand_N_Op_Multiply, Expand_N_Op_Or, Expand_N_Op_Subtract):\n+\tCall Expand_Non_Binary_Modular_Op.\n+\n 2017-05-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* sem_ch3.adb (Build_Derived_Private_Type): If the parent type"}, {"sha": "1a4621e7c1a713fc661e8a83d33ff952f4bc80df", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dbb83f9e3b783de3d666348b1d1a0e7895b09f/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dbb83f9e3b783de3d666348b1d1a0e7895b09f/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=05dbb83f9e3b783de3d666348b1d1a0e7895b09f", "patch": "@@ -185,6 +185,7 @@ package body Einfo is\n    --    Scalar_Range                    Node20\n \n    --    Accept_Address                  Elist21\n+   --    Corresponding_Record_Component  Node21\n    --    Default_Expr_Function           Node21\n    --    Discriminant_Constraint         Elist21\n    --    Interface_Name                  Node21\n@@ -950,6 +951,12 @@ package body Einfo is\n       return Node18 (Id);\n    end Corresponding_Protected_Entry;\n \n+   function Corresponding_Record_Component (Id : E) return E is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Component, E_Discriminant));\n+      return Node21 (Id);\n+   end Corresponding_Record_Component;\n+\n    function Corresponding_Record_Type (Id : E) return E is\n    begin\n       pragma Assert (Is_Concurrent_Type (Id));\n@@ -4083,6 +4090,12 @@ package body Einfo is\n       Set_Node18 (Id, V);\n    end Set_Corresponding_Protected_Entry;\n \n+   procedure Set_Corresponding_Record_Component (Id : E; V : E) is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Component, E_Discriminant));\n+      Set_Node21 (Id, V);\n+   end Set_Corresponding_Record_Component;\n+\n    procedure Set_Corresponding_Record_Type (Id : E; V : E) is\n    begin\n       pragma Assert (Is_Concurrent_Type (Id));\n@@ -10402,6 +10415,11 @@ package body Einfo is\n          when Entry_Kind =>\n             Write_Str (\"Accept_Address\");\n \n+         when E_Component\n+            | E_Discriminant\n+         =>\n+            Write_Str (\"Corresponding_Record_Component\");\n+\n          when E_In_Parameter =>\n             Write_Str (\"Default_Expr_Function\");\n "}, {"sha": "176685ea286ce92c3e4f2c937c9e0edb84409b36", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dbb83f9e3b783de3d666348b1d1a0e7895b09f/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dbb83f9e3b783de3d666348b1d1a0e7895b09f/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=05dbb83f9e3b783de3d666348b1d1a0e7895b09f", "patch": "@@ -762,6 +762,14 @@ package Einfo is\n --       Defined in subprogram bodies. Set for subprogram bodies that implement\n --       a protected type entry to point to the entity for the entry.\n \n+--    Corresponding_Record_Component (Node21)\n+--       Defined in components of a derived untagged record type, including\n+--       discriminants. For a regular component or a girder discriminant,\n+--       points to the corresponding component in the parent type. Set to\n+--       Empty for a non-girder discriminant. It is used by the back end to\n+--       ensure the layout of the derived type matches that of the parent\n+--       type when there is no representation clause on the derived type.\n+\n --    Corresponding_Record_Type (Node18)\n --       Defined in protected and task types and subtypes. References the\n --       entity for the corresponding record type constructed by the expander\n@@ -5815,6 +5823,7 @@ package Einfo is\n    --    Prival                              (Node17)\n    --    Renamed_Object                      (Node18)   (always Empty)\n    --    Discriminant_Checking_Func          (Node20)\n+   --    Corresponding_Record_Component      (Node21)\n    --    Original_Record_Component           (Node22)\n    --    DT_Offset_To_Top_Func               (Node25)\n    --    Related_Type                        (Node27)\n@@ -5908,6 +5917,7 @@ package Einfo is\n    --    Renamed_Object                      (Node18)   (always Empty)\n    --    Corresponding_Discriminant          (Node19)\n    --    Discriminant_Default_Value          (Node20)\n+   --    Corresponding_Record_Component      (Node21)\n    --    Original_Record_Component           (Node22)\n    --    CR_Discriminant                     (Node23)\n    --    Is_Completely_Hidden                (Flag103)\n@@ -6943,6 +6953,7 @@ package Einfo is\n    function Corresponding_Function              (Id : E) return E;\n    function Corresponding_Procedure             (Id : E) return E;\n    function Corresponding_Protected_Entry       (Id : E) return E;\n+   function Corresponding_Record_Component      (Id : E) return E;\n    function Corresponding_Record_Type           (Id : E) return E;\n    function Corresponding_Remote_Type           (Id : E) return E;\n    function CR_Discriminant                     (Id : E) return E;\n@@ -7632,6 +7643,7 @@ package Einfo is\n    procedure Set_Corresponding_Function          (Id : E; V : E);\n    procedure Set_Corresponding_Procedure         (Id : E; V : E);\n    procedure Set_Corresponding_Protected_Entry   (Id : E; V : E);\n+   procedure Set_Corresponding_Record_Component  (Id : E; V : E);\n    procedure Set_Corresponding_Record_Type       (Id : E; V : E);\n    procedure Set_Corresponding_Remote_Type       (Id : E; V : E);\n    procedure Set_CR_Discriminant                 (Id : E; V : E);\n@@ -8435,6 +8447,7 @@ package Einfo is\n    pragma Inline (Corresponding_Discriminant);\n    pragma Inline (Corresponding_Equality);\n    pragma Inline (Corresponding_Protected_Entry);\n+   pragma Inline (Corresponding_Record_Component);\n    pragma Inline (Corresponding_Record_Type);\n    pragma Inline (Corresponding_Remote_Type);\n    pragma Inline (CR_Discriminant);\n@@ -8960,6 +8973,7 @@ package Einfo is\n    pragma Inline (Set_Corresponding_Discriminant);\n    pragma Inline (Set_Corresponding_Equality);\n    pragma Inline (Set_Corresponding_Protected_Entry);\n+   pragma Inline (Set_Corresponding_Record_Component);\n    pragma Inline (Set_Corresponding_Record_Type);\n    pragma Inline (Set_Corresponding_Remote_Type);\n    pragma Inline (Set_CR_Discriminant);"}, {"sha": "cc797a01a61cb2251656999dce597f22abef9156", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dbb83f9e3b783de3d666348b1d1a0e7895b09f/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dbb83f9e3b783de3d666348b1d1a0e7895b09f/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=05dbb83f9e3b783de3d666348b1d1a0e7895b09f", "patch": "@@ -128,6 +128,11 @@ package body Exp_Ch4 is\n    --  Common expansion processing for Boolean operators (And, Or, Xor) for the\n    --  case of array type arguments.\n \n+   procedure Expand_Non_Binary_Modular_Op (N : Node_Id);\n+   --  Generating C code convert non-binary modular arithmetic operations into\n+   --  code that relies on the frontend expansion of operator Mod. No expansion\n+   --  is performed if N is not a non-binary modular operand.\n+\n    procedure Expand_Short_Circuit_Operator (N : Node_Id);\n    --  Common expansion processing for short-circuit boolean operators\n \n@@ -3957,6 +3962,217 @@ package body Exp_Ch4 is\n       end if;\n    end Expand_Membership_Minimize_Eliminate_Overflow;\n \n+   ----------------------------------\n+   -- Expand_Non_Binary_Modular_Op --\n+   ----------------------------------\n+\n+   procedure Expand_Non_Binary_Modular_Op (N : Node_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n+      Typ : constant Entity_Id  := Etype (N);\n+\n+      procedure Expand_Modular_Addition;\n+      --  Expand the modular addition handling the special case of adding a\n+      --  constant.\n+\n+      procedure Expand_Modular_Op;\n+      --  Compute the general rule: (lhs OP rhs) mod Modulus\n+\n+      procedure Expand_Modular_Subtraction;\n+      --  Expand the modular addition handling the special case of subtracting\n+      --  a constant.\n+\n+      -----------------------------\n+      -- Expand_Modular_Addition --\n+      -----------------------------\n+\n+      procedure Expand_Modular_Addition is\n+      begin\n+         --  If this is not the addition of a constant then compute it using\n+         --  the general rule: (lhs + rhs) mod Modulus\n+\n+         if Nkind (Right_Opnd (N)) /= N_Integer_Literal then\n+            Expand_Modular_Op;\n+\n+         --  If this is an addition of a constant, convert it to a subtraction\n+         --  plus a conditional expression since we can compute it faster than\n+         --  computing the modulus.\n+\n+         --      modMinusRhs = Modulus - rhs\n+         --      if lhs < modMinusRhs then lhs + rhs\n+         --                           else lhs - modMinusRhs\n+\n+         else\n+            declare\n+               Mod_Minus_Right : constant Uint :=\n+                                   Modulus (Typ) - Intval (Right_Opnd (N));\n+\n+               Exprs     : constant List_Id := New_List;\n+               Cond_Expr : constant Node_Id := New_Op_Node (N_Op_Lt, Loc);\n+               Then_Expr : constant Node_Id := New_Op_Node (N_Op_Add, Loc);\n+               Else_Expr : constant Node_Id := New_Op_Node (N_Op_Subtract,\n+                                                            Loc);\n+            begin\n+               Set_Left_Opnd (Cond_Expr,\n+                 New_Copy_Tree (Left_Opnd (N)));\n+               Set_Right_Opnd (Cond_Expr,\n+                 Make_Integer_Literal (Loc, Mod_Minus_Right));\n+               Append_To (Exprs, Cond_Expr);\n+\n+               Set_Left_Opnd (Then_Expr,\n+                 Unchecked_Convert_To (Standard_Unsigned,\n+                   New_Copy_Tree (Left_Opnd (N))));\n+               Set_Right_Opnd (Then_Expr,\n+                 Make_Integer_Literal (Loc, Intval (Right_Opnd (N))));\n+               Append_To (Exprs, Then_Expr);\n+\n+               Set_Left_Opnd (Else_Expr,\n+                 Unchecked_Convert_To (Standard_Unsigned,\n+                   New_Copy_Tree (Left_Opnd (N))));\n+               Set_Right_Opnd (Else_Expr,\n+                 Make_Integer_Literal (Loc, Mod_Minus_Right));\n+               Append_To (Exprs, Else_Expr);\n+\n+               Rewrite (N,\n+                 Unchecked_Convert_To (Typ,\n+                   Make_If_Expression (Loc, Expressions => Exprs)));\n+            end;\n+         end if;\n+      end Expand_Modular_Addition;\n+\n+      -----------------------\n+      -- Expand_Modular_Op --\n+      -----------------------\n+\n+      procedure Expand_Modular_Op is\n+         Op_Expr  : constant Node_Id := New_Op_Node (Nkind (N), Loc);\n+         Mod_Expr : constant Node_Id := New_Op_Node (N_Op_Mod, Loc);\n+\n+      begin\n+         --  Convert non-binary modular type operands into integer or integer\n+         --  values. Thus we avoid never-ending loops expanding them, and we\n+         --  also ensure that the backend never receives non-binary modular\n+         --  type expressions.\n+\n+         if Nkind_In (Nkind (N), N_Op_And, N_Op_Or) then\n+            Set_Left_Opnd (Op_Expr,\n+              Unchecked_Convert_To (Standard_Unsigned,\n+                New_Copy_Tree (Left_Opnd (N))));\n+            Set_Right_Opnd (Op_Expr,\n+              Unchecked_Convert_To (Standard_Unsigned,\n+                New_Copy_Tree (Right_Opnd (N))));\n+            Set_Left_Opnd (Mod_Expr,\n+              Unchecked_Convert_To (Standard_Integer, Op_Expr));\n+         else\n+            Set_Left_Opnd (Op_Expr,\n+              Unchecked_Convert_To (Standard_Integer,\n+                New_Copy_Tree (Left_Opnd (N))));\n+            Set_Right_Opnd (Op_Expr,\n+              Unchecked_Convert_To (Standard_Integer,\n+                New_Copy_Tree (Right_Opnd (N))));\n+            Set_Left_Opnd (Mod_Expr, Op_Expr);\n+         end if;\n+\n+         Set_Right_Opnd (Mod_Expr,\n+           Make_Integer_Literal (Loc, Modulus (Typ)));\n+\n+         Rewrite (N,\n+           Unchecked_Convert_To (Typ, Mod_Expr));\n+      end Expand_Modular_Op;\n+\n+      --------------------------------\n+      -- Expand_Modular_Subtraction --\n+      --------------------------------\n+\n+      procedure Expand_Modular_Subtraction is\n+      begin\n+         --  If this is not the addition of a constant then compute it using\n+         --  the general rule: (lhs + rhs) mod Modulus\n+\n+         if Nkind (Right_Opnd (N)) /= N_Integer_Literal then\n+            Expand_Modular_Op;\n+\n+         --  If this is an addition of a constant, convert it to a subtraction\n+         --  plus a conditional expression since we can compute it faster than\n+         --  computing the modulus.\n+\n+         --      modMinusRhs = Modulus - rhs\n+         --      if lhs < rhs then lhs + modMinusRhs\n+         --                   else lhs - rhs\n+\n+         else\n+            declare\n+               Mod_Minus_Right : constant Uint :=\n+                                   Modulus (Typ) - Intval (Right_Opnd (N));\n+\n+               Exprs     : constant List_Id := New_List;\n+               Cond_Expr : constant Node_Id := New_Op_Node (N_Op_Lt, Loc);\n+               Then_Expr : constant Node_Id := New_Op_Node (N_Op_Add, Loc);\n+               Else_Expr : constant Node_Id := New_Op_Node (N_Op_Subtract,\n+                                                            Loc);\n+            begin\n+               Set_Left_Opnd (Cond_Expr,\n+                 New_Copy_Tree (Left_Opnd (N)));\n+               Set_Right_Opnd (Cond_Expr,\n+                 Make_Integer_Literal (Loc, Intval (Right_Opnd (N))));\n+               Append_To (Exprs, Cond_Expr);\n+\n+               Set_Left_Opnd (Then_Expr,\n+                 Unchecked_Convert_To (Standard_Unsigned,\n+                   New_Copy_Tree (Left_Opnd (N))));\n+               Set_Right_Opnd (Then_Expr,\n+                 Make_Integer_Literal (Loc, Mod_Minus_Right));\n+               Append_To (Exprs, Then_Expr);\n+\n+               Set_Left_Opnd (Else_Expr,\n+                 Unchecked_Convert_To (Standard_Unsigned,\n+                   New_Copy_Tree (Left_Opnd (N))));\n+               Set_Right_Opnd (Else_Expr,\n+                 Unchecked_Convert_To (Standard_Unsigned,\n+                   New_Copy_Tree (Right_Opnd (N))));\n+               Append_To (Exprs, Else_Expr);\n+\n+               Rewrite (N,\n+                 Unchecked_Convert_To (Typ,\n+                   Make_If_Expression (Loc, Expressions => Exprs)));\n+            end;\n+         end if;\n+      end Expand_Modular_Subtraction;\n+\n+   --  Start of processing for Expand_Non_Binary_Modular_Op\n+\n+   begin\n+      --  No action needed if we are not generating C code for a non-binary\n+      --  modular operand.\n+\n+      if not Modify_Tree_For_C\n+        or else not Non_Binary_Modulus (Typ)\n+      then\n+         return;\n+      end if;\n+\n+      case Nkind (N) is\n+         when N_Op_Add =>\n+            Expand_Modular_Addition;\n+\n+         when N_Op_Subtract =>\n+            Expand_Modular_Subtraction;\n+\n+         when N_Op_Minus =>\n+            --  Expand -expr into (0 - expr)\n+\n+            Rewrite (N,\n+              Make_Op_Subtract (Loc,\n+                Left_Opnd  => Make_Integer_Literal (Loc, 0),\n+                Right_Opnd => Right_Opnd (N)));\n+            Analyze_And_Resolve (N, Typ);\n+\n+         when others =>\n+            Expand_Modular_Op;\n+      end case;\n+\n+      Analyze_And_Resolve (N, Typ);\n+   end Expand_Non_Binary_Modular_Op;\n+\n    ------------------------\n    -- Expand_N_Allocator --\n    ------------------------\n@@ -6639,6 +6855,13 @@ package body Exp_Ch4 is\n       --  Overflow checks for floating-point if -gnateF mode active\n \n       Check_Float_Op_Overflow (N);\n+\n+      --  Generating C code convert non-binary modular additions into code that\n+      --  relies on the frontend expansion of operator Mod.\n+\n+      if Modify_Tree_For_C then\n+         Expand_Non_Binary_Modular_Op (N);\n+      end if;\n    end Expand_N_Op_Add;\n \n    ---------------------\n@@ -6662,7 +6885,13 @@ package body Exp_Ch4 is\n \n       elsif Is_Intrinsic_Subprogram (Entity (N)) then\n          Expand_Intrinsic_Call (N, Entity (N));\n+      end if;\n+\n+      --  Generating C code convert non-binary modular operators into code that\n+      --  relies on the frontend expansion of operator Mod.\n \n+      if Modify_Tree_For_C then\n+         Expand_Non_Binary_Modular_Op (N);\n       end if;\n    end Expand_N_Op_And;\n \n@@ -6904,6 +7133,13 @@ package body Exp_Ch4 is\n       --  Overflow checks for floating-point if -gnateF mode active\n \n       Check_Float_Op_Overflow (N);\n+\n+      --  Generating C code convert non-binary modular divisions into code that\n+      --  relies on the frontend expansion of operator Mod.\n+\n+      if Modify_Tree_For_C then\n+         Expand_Non_Binary_Modular_Op (N);\n+      end if;\n    end Expand_N_Op_Divide;\n \n    --------------------\n@@ -8406,6 +8642,13 @@ package body Exp_Ch4 is\n \n          Analyze_And_Resolve (N, Typ);\n       end if;\n+\n+      --  Generating C code convert non-binary modular minus into code that\n+      --  relies on the frontend expansion of operator Mod.\n+\n+      if Modify_Tree_For_C then\n+         Expand_Non_Binary_Modular_Op (N);\n+      end if;\n    end Expand_N_Op_Minus;\n \n    ---------------------\n@@ -8882,6 +9125,13 @@ package body Exp_Ch4 is\n       --  Overflow checks for floating-point if -gnateF mode active\n \n       Check_Float_Op_Overflow (N);\n+\n+      --  Generating C code convert non-binary modular multiplications into\n+      --  code that relies on the frontend expansion of operator Mod.\n+\n+      if Modify_Tree_For_C then\n+         Expand_Non_Binary_Modular_Op (N);\n+      end if;\n    end Expand_N_Op_Multiply;\n \n    --------------------\n@@ -9191,7 +9441,13 @@ package body Exp_Ch4 is\n \n       elsif Is_Intrinsic_Subprogram (Entity (N)) then\n          Expand_Intrinsic_Call (N, Entity (N));\n+      end if;\n+\n+      --  Generating C code convert non-binary modular operators into code that\n+      --  relies on the frontend expansion of operator Mod.\n \n+      if Modify_Tree_For_C then\n+         Expand_Non_Binary_Modular_Op (N);\n       end if;\n    end Expand_N_Op_Or;\n \n@@ -9625,6 +9881,13 @@ package body Exp_Ch4 is\n       --  Overflow checks for floating-point if -gnateF mode active\n \n       Check_Float_Op_Overflow (N);\n+\n+      --  Generating C code convert non-binary modular subtractions into code\n+      --  that relies on the frontend expansion of operator Mod.\n+\n+      if Modify_Tree_For_C then\n+         Expand_Non_Binary_Modular_Op (N);\n+      end if;\n    end Expand_N_Op_Subtract;\n \n    ---------------------"}, {"sha": "3fb546805ff39b65e9aa733c5284c9e5a1bcdc67", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dbb83f9e3b783de3d666348b1d1a0e7895b09f/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dbb83f9e3b783de3d666348b1d1a0e7895b09f/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=05dbb83f9e3b783de3d666348b1d1a0e7895b09f", "patch": "@@ -2938,6 +2938,16 @@ package body Exp_Ch6 is\n               and then Is_Aliased_View (Prev_Orig)\n             then\n                Prev_Orig := Prev;\n+\n+            --  If the actual is a formal of an enclosing subprogram it is\n+            --  the right entity, even if it is a rewriting. This happens\n+            --  when the call is within an inherited condition or predicate.\n+\n+            elsif Is_Entity_Name (Actual)\n+              and then Is_Formal (Entity (Actual))\n+              and then In_Open_Scopes (Scope (Entity (Actual)))\n+            then\n+               Prev_Orig := Prev;\n             end if;\n \n             --  Ada 2005 (AI-251): Thunks must propagate the extra actuals of"}, {"sha": "af4574d2c622bd8e348766d8b2b049c9a28bc879", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 405, "deletions": 382, "changes": 787, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dbb83f9e3b783de3d666348b1d1a0e7895b09f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dbb83f9e3b783de3d666348b1d1a0e7895b09f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=05dbb83f9e3b783de3d666348b1d1a0e7895b09f", "patch": "@@ -224,20 +224,21 @@ static Uint annotate_value (tree);\n static void annotate_rep (Entity_Id, tree);\n static tree build_position_list (tree, bool, tree, tree, unsigned int, tree);\n static vec<subst_pair> build_subst_list (Entity_Id, Entity_Id, bool);\n-static vec<variant_desc> build_variant_list (tree,\n-\t\t\t\t\t\t   vec<subst_pair> ,\n-\t\t\t\t\t\t   vec<variant_desc> );\n+static vec<variant_desc> build_variant_list (tree, vec<subst_pair>,\n+\t\t\t\t\t     vec<variant_desc>);\n static tree validate_size (Uint, tree, Entity_Id, enum tree_code, bool, bool);\n static void set_rm_size (Uint, tree, Entity_Id);\n static unsigned int validate_alignment (Uint, Entity_Id, unsigned int);\n static void check_ok_for_atomic_type (tree, Entity_Id, bool);\n static tree create_field_decl_from (tree, tree, tree, tree, tree,\n-\t\t\t\t    vec<subst_pair> );\n+\t\t\t\t    vec<subst_pair>);\n static tree create_rep_part (tree, tree, tree);\n static tree get_rep_part (tree);\n-static tree create_variant_part_from (tree, vec<variant_desc> , tree,\n-\t\t\t\t      tree, vec<subst_pair> );\n-static void copy_and_substitute_in_size (tree, tree, vec<subst_pair> );\n+static tree create_variant_part_from (tree, vec<variant_desc>, tree,\n+\t\t\t\t      tree, vec<subst_pair>, bool);\n+static void copy_and_substitute_in_size (tree, tree, vec<subst_pair>);\n+static void copy_and_substitute_in_layout (Entity_Id, Entity_Id, tree, tree,\n+\t\t\t\t\t   vec<subst_pair>, bool);\n static void associate_original_type_to_packed_array (tree, Entity_Id);\n static const char *get_entity_char (Entity_Id);\n \n@@ -486,8 +487,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n \t/* If the entity is a discriminant of an extended tagged type used to\n \t   rename a discriminant of the parent type, return the latter.  */\n-\tif (Is_Tagged_Type (gnat_record)\n-\t    && Present (Corresponding_Discriminant (gnat_entity)))\n+\tif (kind == E_Discriminant\n+\t    && Present (Corresponding_Discriminant (gnat_entity))\n+\t    && Is_Tagged_Type (gnat_record))\n \t  {\n \t    gnu_decl\n \t      = gnat_to_gnu_entity (Corresponding_Discriminant (gnat_entity),\n@@ -507,7 +509,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    gnu_decl\n \t      = gnat_to_gnu_entity (Original_Record_Component (gnat_entity),\n \t\t\t\t    gnu_expr, definition);\n-\t    saved = true;\n+\t    /* GNU_DECL contains a PLACEHOLDER_EXPR for discriminants.  */\n+\t    if (kind == E_Discriminant)\n+\t      saved = true;\n \t    break;\n \t  }\n \n@@ -2995,7 +2999,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \tNode_Id full_definition = Declaration_Node (gnat_entity);\n \tNode_Id record_definition = Type_Definition (full_definition);\n \tNode_Id gnat_constr;\n-\tEntity_Id gnat_field;\n+\tEntity_Id gnat_field, gnat_parent_type;\n \ttree gnu_field, gnu_field_list = NULL_TREE;\n \ttree gnu_get_parent;\n \t/* Set PACKED in keeping with gnat_to_gnu_field.  */\n@@ -3229,15 +3233,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    {\n \t      /* If this is a record extension and this discriminant is the\n \t\t renaming of another discriminant, we've handled it above.  */\n-\t      if (Present (Parent_Subtype (gnat_entity))\n-\t\t  && Present (Corresponding_Discriminant (gnat_field)))\n-\t\tcontinue;\n-\n-\t      /* However, if we are just annotating types, the Parent_Subtype\n-\t\t doesn't exist so we need skip the discriminant altogether.  */\n-\t      if (type_annotate_only\n-\t\t  && Is_Tagged_Type (gnat_entity)\n-\t\t  && Is_Derived_Type (gnat_entity)\n+\t      if (is_extension\n \t\t  && Present (Corresponding_Discriminant (gnat_field)))\n \t\tcontinue;\n \n@@ -3262,7 +3258,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    }\n \n \t/* If we have a derived untagged type that renames discriminants in\n-\t   the root type, the (stored) discriminants are a just copy of the\n+\t   the root type, the (stored) discriminants are just a copy of the\n \t   discriminants of the root type.  This means that any constraints\n \t   added by the renaming in the derivation are disregarded as far\n \t   as the layout of the derived type is concerned.  To rescue them,\n@@ -3280,30 +3276,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t&& Ekind (Entity (Node (gnat_constr))) == E_Discriminant)\n \t      {\n \t\tEntity_Id gnat_discr = Entity (Node (gnat_constr));\n-\t\ttree gnu_discr_type, gnu_ref;\n-\n-\t\t/* If the scope of the discriminant is not the record type,\n-\t\t   this means that we're processing the implicit full view\n-\t\t   of a type derived from a private discriminated type: in\n-\t\t   this case, the Stored_Constraint list is simply copied\n-\t\t   from the partial view, see Build_Derived_Private_Type.\n-\t\t   So we need to retrieve the corresponding discriminant\n-\t\t   of the implicit full view, otherwise we will abort.  */\n-\t\tif (Scope (gnat_discr) != gnat_entity)\n-\t\t  {\n-\t\t    Entity_Id field;\n-\t\t    for (field = First_Entity (gnat_entity);\n-\t\t\t Present (field);\n-\t\t\t field = Next_Entity (field))\n-\t\t      if (Ekind (field) == E_Discriminant\n-\t\t\t  && same_discriminant_p (gnat_discr, field))\n-\t\t\tbreak;\n-\t\t    gcc_assert (Present (field));\n-\t\t    gnat_discr = field;\n-\t\t  }\n-\n-\t\tgnu_discr_type = gnat_to_gnu_type (Etype (gnat_discr));\n-\t\tgnu_ref\n+\t\ttree gnu_discr_type = gnat_to_gnu_type (Etype (gnat_discr));\n+\t\ttree gnu_ref\n \t\t  = gnat_to_gnu_entity (Original_Record_Component (gnat_discr),\n \t\t\t\t\tNULL_TREE, false);\n \n@@ -3328,28 +3302,59 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t  }\n \t      }\n \n-\t/* Add the fields into the record type and finish it up.  */\n-\tcomponents_to_record (Component_List (record_definition), gnat_entity,\n-\t\t\t      gnu_field_list, gnu_type, packed, definition,\n-\t\t\t      false, all_rep, is_unchecked_union, artificial_p,\n-\t\t\t      debug_info_p, false,\n-\t\t\t      all_rep ? NULL_TREE : bitsize_zero_node, NULL);\n+\t/* If this is a derived type with discriminants and these discriminants\n+\t   affect the initial shape it has inherited, factor them in.  But for\n+\t   an Unchecked_Union (it must be an Itype), just process the type.  */\n+\tif (has_discr\n+\t    && !is_extension\n+\t    && !Has_Record_Rep_Clause (gnat_entity)\n+\t    && Stored_Constraint (gnat_entity) != No_Elist\n+\t    && (gnat_parent_type = Underlying_Type (Etype (gnat_entity)))\n+\t    && Is_Record_Type (gnat_parent_type)\n+\t    && !Is_Unchecked_Union (gnat_parent_type))\n+\t  {\n+\t    tree gnu_parent_type\n+\t      = TYPE_MAIN_VARIANT (gnat_to_gnu_type (gnat_parent_type));\n+\n+\t    if (TYPE_IS_PADDING_P (gnu_parent_type))\n+\t      gnu_parent_type = TREE_TYPE (TYPE_FIELDS (gnu_parent_type));\n+\n+\t    vec<subst_pair> gnu_subst_list\n+\t      = build_subst_list (gnat_entity, gnat_parent_type, definition);\n+\n+\t    /* Set the layout of the type to match that of the parent type,\n+\t       doing required substitutions.  */\n+\t    copy_and_substitute_in_layout (gnat_entity, gnat_parent_type,\n+\t\t\t\t\t   gnu_type, gnu_parent_type,\n+\t\t\t\t\t   gnu_subst_list, debug_info_p);\n+\t  }\n+\telse\n+\t  {\n+\t    /* Add the fields into the record type and finish it up.  */\n+\t    components_to_record (Component_List (record_definition),\n+\t\t\t\t  gnat_entity, gnu_field_list, gnu_type,\n+\t\t\t\t  packed, definition, false, all_rep,\n+\t\t\t\t  is_unchecked_union, artificial_p,\n+\t\t\t\t  debug_info_p, false,\n+\t\t\t\t  all_rep ? NULL_TREE : bitsize_zero_node,\n+\t\t\t\t  NULL);\n+\n+\t    /* If there are entities in the chain corresponding to components\n+\t       that we did not elaborate, ensure we elaborate their types if\n+\t       they are Itypes.  */\n+\t    for (gnat_temp = First_Entity (gnat_entity);\n+\t\t Present (gnat_temp);\n+\t\t gnat_temp = Next_Entity (gnat_temp))\n+\t      if ((Ekind (gnat_temp) == E_Component\n+\t\t   || Ekind (gnat_temp) == E_Discriminant)\n+\t\t  && Is_Itype (Etype (gnat_temp))\n+\t\t  && !present_gnu_tree (gnat_temp))\n+\t\tgnat_to_gnu_entity (Etype (gnat_temp), NULL_TREE, false);\n+\t  }\n \n \t/* Fill in locations of fields.  */\n \tannotate_rep (gnat_entity, gnu_type);\n \n-\t/* If there are any entities in the chain corresponding to components\n-\t   that we did not elaborate, ensure we elaborate their types if they\n-\t   are Itypes.  */\n-\tfor (gnat_temp = First_Entity (gnat_entity);\n-\t     Present (gnat_temp);\n-\t     gnat_temp = Next_Entity (gnat_temp))\n-\t  if ((Ekind (gnat_temp) == E_Component\n-\t       || Ekind (gnat_temp) == E_Discriminant)\n-\t      && Is_Itype (Etype (gnat_temp))\n-\t      && !present_gnu_tree (gnat_temp))\n-\t    gnat_to_gnu_entity (Etype (gnat_temp), NULL_TREE, false);\n-\n \t/* If this is a record type associated with an exception definition,\n \t   equate its fields to those of the standard exception type.  This\n \t   will make it possible to convert between them.  */\n@@ -3403,15 +3408,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n       else\n \t{\n \t  Entity_Id gnat_base_type = Implementation_Base_Type (gnat_entity);\n-\t  tree gnu_base_type;\n \n \t  if (!definition)\n \t    {\n \t      defer_incomplete_level++;\n \t      this_deferred = true;\n \t    }\n \n-\t  gnu_base_type\n+\t  tree gnu_base_type\n \t    = TYPE_MAIN_VARIANT (gnat_to_gnu_type (gnat_base_type));\n \n \t  if (present_gnu_tree (gnat_entity))\n@@ -3436,24 +3440,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n \t  /* When the subtype has discriminants and these discriminants affect\n \t     the initial shape it has inherited, factor them in.  But for an\n-\t     Unchecked_Union (it must be an Itype), just return the type.\n-\t     We can't just test Is_Constrained because private subtypes without\n-\t     discriminants of types with discriminants with default expressions\n-\t     are Is_Constrained but aren't constrained!  */\n-\t  if (IN (Ekind (gnat_base_type), Record_Kind)\n-\t      && !Is_Unchecked_Union (gnat_base_type)\n+\t     Unchecked_Union (it must be an Itype), just return the type.  */\n+\t  if (Has_Discriminants (gnat_entity)\n+\t      && Stored_Constraint (gnat_entity) != No_Elist\n \t      && !Is_For_Access_Subtype (gnat_entity)\n-\t      && Has_Discriminants (gnat_entity)\n-\t      && Is_Constrained (gnat_entity)\n-\t      && Stored_Constraint (gnat_entity) != No_Elist)\n+\t      && Is_Record_Type (gnat_base_type)\n+\t      && !Is_Unchecked_Union (gnat_base_type))\n \t    {\n \t      vec<subst_pair> gnu_subst_list\n \t\t= build_subst_list (gnat_entity, gnat_base_type, definition);\n-\t      tree gnu_unpad_base_type, gnu_rep_part, gnu_variant_part;\n-\t      tree gnu_pos_list, gnu_field_list = NULL_TREE;\n-\t      bool selected_variant = false, all_constant_pos = true;\n-\t      Entity_Id gnat_field;\n-\t      vec<variant_desc> gnu_variant_list;\n+\t      tree gnu_unpad_base_type;\n \n \t      gnu_type = make_node (RECORD_TYPE);\n \t      TYPE_NAME (gnu_type) = gnu_entity_name;\n@@ -3464,8 +3460,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t= Reverse_Storage_Order (gnat_entity);\n \t      process_attributes (&gnu_type, &attr_list, true, gnat_entity);\n \n-\t      /* Set the size, alignment and alias set of the new type to\n-\t\t match that of the old one, doing required substitutions.  */\n+\t      /* Set the size, alignment and alias set of the type to match\n+\t\t those of the base type, doing required substitutions.  */\n \t      copy_and_substitute_in_size (gnu_type, gnu_base_type,\n \t\t\t\t\t   gnu_subst_list);\n \n@@ -3474,265 +3470,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t      else\n \t\tgnu_unpad_base_type = gnu_base_type;\n \n-\t      /* Look for REP and variant parts in the base type.  */\n-\t      gnu_rep_part = get_rep_part (gnu_unpad_base_type);\n-\t      gnu_variant_part = get_variant_part (gnu_unpad_base_type);\n-\n-\t      /* If there is a variant part, we must compute whether the\n-\t\t constraints statically select a particular variant.  If\n-\t\t so, we simply drop the qualified union and flatten the\n-\t\t list of fields.  Otherwise we'll build a new qualified\n-\t\t union for the variants that are still relevant.  */\n-\t      if (gnu_variant_part)\n-\t\t{\n-\t\t  variant_desc *v;\n-\t\t  unsigned int i;\n-\n-\t\t  gnu_variant_list\n-\t\t    = build_variant_list (TREE_TYPE (gnu_variant_part),\n-\t\t\t\t\t  gnu_subst_list,\n-\t\t\t\t\t  vNULL);\n-\n-\t\t  /* If all the qualifiers are unconditionally true, the\n-\t\t     innermost variant is statically selected.  */\n-\t\t  selected_variant = true;\n-\t\t  FOR_EACH_VEC_ELT (gnu_variant_list, i, v)\n-\t\t    if (!integer_onep (v->qual))\n-\t\t      {\n-\t\t\tselected_variant = false;\n-\t\t\tbreak;\n-\t\t      }\n-\n-\t\t  /* Otherwise, create the new variants.  */\n-\t\t  if (!selected_variant)\n-\t\t    FOR_EACH_VEC_ELT (gnu_variant_list, i, v)\n-\t\t      {\n-\t\t\ttree old_variant = v->type;\n-\t\t\ttree new_variant = make_node (RECORD_TYPE);\n-\t\t\ttree suffix\n-\t\t\t  = concat_name (DECL_NAME (gnu_variant_part),\n-\t\t\t\t\t IDENTIFIER_POINTER\n-\t\t\t\t\t (DECL_NAME (v->field)));\n-\t\t\tTYPE_NAME (new_variant)\n-\t\t\t  = concat_name (TYPE_NAME (gnu_type),\n-\t\t\t\t\t IDENTIFIER_POINTER (suffix));\n-\t\t\tTYPE_REVERSE_STORAGE_ORDER (new_variant)\n-\t\t\t  = TYPE_REVERSE_STORAGE_ORDER (gnu_type);\n-\t\t\tcopy_and_substitute_in_size (new_variant, old_variant,\n-\t\t\t\t\t\t     gnu_subst_list);\n-\t\t\tv->new_type = new_variant;\n-\t\t      }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  gnu_variant_list.create (0);\n-\t\t  selected_variant = false;\n-\t\t}\n-\n-\t      /* Make a list of fields and their position in the base type.  */\n-\t      gnu_pos_list\n-\t\t= build_position_list (gnu_unpad_base_type,\n-\t\t\t\t       gnu_variant_list.exists ()\n-\t\t\t\t       && !selected_variant,\n-\t\t\t\t       size_zero_node, bitsize_zero_node,\n-\t\t\t\t       BIGGEST_ALIGNMENT, NULL_TREE);\n-\n-\t      /* Now go down every component in the subtype and compute its\n-\t\t size and position from those of the component in the base\n-\t\t type and from the constraints of the subtype.  */\n-\t      for (gnat_field = First_Entity (gnat_entity);\n-\t\t   Present (gnat_field);\n-\t\t   gnat_field = Next_Entity (gnat_field))\n-\t\tif ((Ekind (gnat_field) == E_Component\n-\t\t     || Ekind (gnat_field) == E_Discriminant)\n-\t\t    && !(Present (Corresponding_Discriminant (gnat_field))\n-\t\t\t && Is_Tagged_Type (gnat_base_type))\n-\t\t    && Underlying_Type\n-\t\t       (Scope (Original_Record_Component (gnat_field)))\n-\t\t       == gnat_base_type)\n-\t\t  {\n-\t\t    Name_Id gnat_name = Chars (gnat_field);\n-\t\t    Entity_Id gnat_old_field\n-\t\t      = Original_Record_Component (gnat_field);\n-\t\t    tree gnu_old_field\n-\t\t      = gnat_to_gnu_field_decl (gnat_old_field);\n-\t\t    tree gnu_context = DECL_CONTEXT (gnu_old_field);\n-\t\t    tree gnu_field, gnu_field_type, gnu_size, gnu_pos;\n-\t\t    tree gnu_cont_type, gnu_last = NULL_TREE;\n-\n-\t\t    /* If the type is the same, retrieve the GCC type from the\n-\t\t       old field to take into account possible adjustments.  */\n-\t\t    if (Etype (gnat_field) == Etype (gnat_old_field))\n-\t\t      gnu_field_type = TREE_TYPE (gnu_old_field);\n-\t\t    else\n-\t\t      gnu_field_type = gnat_to_gnu_type (Etype (gnat_field));\n-\n-\t\t    /* If there was a component clause, the field types must be\n-\t\t       the same for the type and subtype, so copy the data from\n-\t\t       the old field to avoid recomputation here.  Also if the\n-\t\t       field is justified modular and the optimization in\n-\t\t       gnat_to_gnu_field was applied.  */\n-\t\t    if (Present (Component_Clause (gnat_old_field))\n-\t\t\t|| (TREE_CODE (gnu_field_type) == RECORD_TYPE\n-\t\t\t    && TYPE_JUSTIFIED_MODULAR_P (gnu_field_type)\n-\t\t\t    && TREE_TYPE (TYPE_FIELDS (gnu_field_type))\n-\t\t\t       == TREE_TYPE (gnu_old_field)))\n-\t\t      {\n-\t\t\tgnu_size = DECL_SIZE (gnu_old_field);\n-\t\t\tgnu_field_type = TREE_TYPE (gnu_old_field);\n-\t\t      }\n-\n-\t\t    /* If the old field was packed and of constant size, we\n-\t\t       have to get the old size here, as it might differ from\n-\t\t       what the Etype conveys and the latter might overlap\n-\t\t       onto the following field.  Try to arrange the type for\n-\t\t       possible better packing along the way.  */\n-\t\t    else if (DECL_PACKED (gnu_old_field)\n-\t\t\t     && TREE_CODE (DECL_SIZE (gnu_old_field))\n-\t\t\t        == INTEGER_CST)\n-\t\t      {\n-\t\t\tgnu_size = DECL_SIZE (gnu_old_field);\n-\t\t\tif (RECORD_OR_UNION_TYPE_P (gnu_field_type)\n-\t\t\t    && !TYPE_FAT_POINTER_P (gnu_field_type)\n-\t\t\t    && tree_fits_uhwi_p (TYPE_SIZE (gnu_field_type)))\n-\t\t\t  gnu_field_type\n-\t\t\t    = make_packable_type (gnu_field_type, true);\n-\t\t      }\n-\n-\t\t    else\n-\t\t      gnu_size = TYPE_SIZE (gnu_field_type);\n-\n-\t\t    /* If the context of the old field is the base type or its\n-\t\t       REP part (if any), put the field directly in the new\n-\t\t       type; otherwise look up the context in the variant list\n-\t\t       and put the field either in the new type if there is a\n-\t\t       selected variant or in one of the new variants.  */\n-\t\t    if (gnu_context == gnu_unpad_base_type\n-\t\t        || (gnu_rep_part\n-\t\t\t    && gnu_context == TREE_TYPE (gnu_rep_part)))\n-\t\t      gnu_cont_type = gnu_type;\n-\t\t    else\n-\t\t      {\n-\t\t\tvariant_desc *v;\n-\t\t\tunsigned int i;\n-\t\t\ttree rep_part;\n-\n-\t\t\tFOR_EACH_VEC_ELT (gnu_variant_list, i, v)\n-\t\t\t  if (gnu_context == v->type\n-\t\t\t      || ((rep_part = get_rep_part (v->type))\n-\t\t\t\t  && gnu_context == TREE_TYPE (rep_part)))\n-\t\t\t    break;\n-\t\t\tif (v)\n-\t\t\t  {\n-\t\t\t    if (selected_variant)\n-\t\t\t      gnu_cont_type = gnu_type;\n-\t\t\t    else\n-\t\t\t      gnu_cont_type = v->new_type;\n-\t\t\t  }\n-\t\t\telse\n-\t\t\t  /* The front-end may pass us \"ghost\" components if\n-\t\t\t     it fails to recognize that a constrained subtype\n-\t\t\t     is statically constrained.  Discard them.  */\n-\t\t\t  continue;\n-\t\t      }\n-\n-\t\t    /* Now create the new field modeled on the old one.  */\n-\t\t    gnu_field\n-\t\t      = create_field_decl_from (gnu_old_field, gnu_field_type,\n-\t\t\t\t\t\tgnu_cont_type, gnu_size,\n-\t\t\t\t\t\tgnu_pos_list, gnu_subst_list);\n-\t\t    gnu_pos = DECL_FIELD_OFFSET (gnu_field);\n-\n-\t\t    /* Put it in one of the new variants directly.  */\n-\t\t    if (gnu_cont_type != gnu_type)\n-\t\t      {\n-\t\t\tDECL_CHAIN (gnu_field) = TYPE_FIELDS (gnu_cont_type);\n-\t\t\tTYPE_FIELDS (gnu_cont_type) = gnu_field;\n-\t\t      }\n-\n-\t\t    /* To match the layout crafted in components_to_record,\n-\t\t       if this is the _Tag or _Parent field, put it before\n-\t\t       any other fields.  */\n-\t\t    else if (gnat_name == Name_uTag\n-\t\t\t     || gnat_name == Name_uParent)\n-\t\t      gnu_field_list = chainon (gnu_field_list, gnu_field);\n-\n-\t\t    /* Similarly, if this is the _Controller field, put\n-\t\t       it before the other fields except for the _Tag or\n-\t\t       _Parent field.  */\n-\t\t    else if (gnat_name == Name_uController && gnu_last)\n-\t\t      {\n-\t\t\tDECL_CHAIN (gnu_field) = DECL_CHAIN (gnu_last);\n-\t\t\tDECL_CHAIN (gnu_last) = gnu_field;\n-\t\t      }\n-\n-\t\t    /* Otherwise, if this is a regular field, put it after\n-\t\t       the other fields.  */\n-\t\t    else\n-\t\t      {\n-\t\t\tDECL_CHAIN (gnu_field) = gnu_field_list;\n-\t\t\tgnu_field_list = gnu_field;\n-\t\t\tif (!gnu_last)\n-\t\t\t  gnu_last = gnu_field;\n-\t\t\tif (TREE_CODE (gnu_pos) != INTEGER_CST)\n-\t\t\t  all_constant_pos = false;\n-\t\t      }\n-\n-\t\t    save_gnu_tree (gnat_field, gnu_field, false);\n-\t\t  }\n-\n-\t      /* If there is a variant list, a selected variant and the fields\n-\t\t all have a constant position, put them in order of increasing\n-\t\t position to match that of constant CONSTRUCTORs.  Likewise if\n-\t\t there is no variant list but a REP part, since the latter has\n-\t\t been flattened in the process.  */\n-\t      if (((gnu_variant_list.exists () && selected_variant)\n-\t\t   || (!gnu_variant_list.exists () && gnu_rep_part))\n-\t\t  && all_constant_pos)\n-\t\t{\n-\t\t  const int len = list_length (gnu_field_list);\n-\t\t  tree *field_arr = XALLOCAVEC (tree, len), t;\n-\t\t  int i;\n-\n-\t\t  for (t = gnu_field_list, i = 0; t; t = DECL_CHAIN (t), i++)\n-\t\t    field_arr[i] = t;\n-\n-\t\t  qsort (field_arr, len, sizeof (tree), compare_field_bitpos);\n-\n-\t\t  gnu_field_list = NULL_TREE;\n-\t\t  for (i = 0; i < len; i++)\n-\t\t    {\n-\t\t      DECL_CHAIN (field_arr[i]) = gnu_field_list;\n-\t\t      gnu_field_list = field_arr[i];\n-\t\t    }\n-\t\t}\n-\n-\t      /* If there is a variant list and no selected variant, we need\n-\t\t to create the nest of variant parts from the old nest.  */\n-\t      else if (gnu_variant_list.exists () && !selected_variant)\n-\t\t{\n-\t\t  tree new_variant_part\n-\t\t    = create_variant_part_from (gnu_variant_part,\n-\t\t\t\t\t\tgnu_variant_list, gnu_type,\n-\t\t\t\t\t\tgnu_pos_list, gnu_subst_list);\n-\t\t  DECL_CHAIN (new_variant_part) = gnu_field_list;\n-\t\t  gnu_field_list = new_variant_part;\n-\t\t}\n-\n-\t      /* Now go through the entities again looking for Itypes that\n-\t\t we have not elaborated but should (e.g., Etypes of fields\n-\t\t that have Original_Components).  */\n-\t      for (gnat_field = First_Entity (gnat_entity);\n-\t\t   Present (gnat_field); gnat_field = Next_Entity (gnat_field))\n-\t\tif ((Ekind (gnat_field) == E_Discriminant\n-\t\t     || Ekind (gnat_field) == E_Component)\n-\t\t    && !present_gnu_tree (Etype (gnat_field)))\n-\t\t  gnat_to_gnu_entity (Etype (gnat_field), NULL_TREE, false);\n-\n-\t      /* We will output additional debug info manually below.  */\n-\t      finish_record_type (gnu_type, nreverse (gnu_field_list), 2,\n-\t\t\t\t  false);\n-\t      compute_record_mode (gnu_type);\n+\t      /* Set the layout of the type to match that of the base type,\n+\t         doing required substitutions.  We will output debug info\n+\t         manually below so pass false as last argument.  */\n+\t      copy_and_substitute_in_layout (gnat_entity, gnat_base_type,\n+\t\t\t\t\t     gnu_type, gnu_unpad_base_type,\n+\t\t\t\t\t     gnu_subst_list, false);\n \n \t      /* Fill in locations of fields.  */\n \t      annotate_rep (gnat_entity, gnu_type);\n@@ -3772,9 +3515,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t\t\t true, debug_info_p,\n \t\t\t\t\t NULL, gnat_entity);\n \t\t}\n-\n-\t      gnu_variant_list.release ();\n-\t      gnu_subst_list.release ();\n \t    }\n \n \t  /* Otherwise, go down all the components in the new type and make\n@@ -7410,17 +7150,6 @@ field_is_artificial (tree field)\n   return false;\n }\n \n-/* Return true if FIELD is a non-artificial aliased field.  */\n-\n-static bool\n-field_is_aliased (tree field)\n-{\n-  if (field_is_artificial (field))\n-    return false;\n-\n-  return DECL_ALIASED_P (field);\n-}\n-\n /* Return true if FIELD is a non-artificial field with self-referential\n    size.  */\n \n@@ -7655,7 +7384,7 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n \t\t/* And record information for the final layout.  */\n \t\tif (field_has_self_size (gnu_field))\n \t\t  has_self_field = true;\n-\t\telse if (has_self_field && field_is_aliased (gnu_field))\n+\t\telse if (has_self_field && DECL_ALIASED_P (gnu_field))\n \t\t  has_aliased_after_self_field = true;\n \t      }\n \t  }\n@@ -8003,7 +7732,7 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n \t  DECL_FIELD_OFFSET (gnu_field) = size_zero_node;\n \t  SET_DECL_OFFSET_ALIGN (gnu_field, BIGGEST_ALIGNMENT);\n \t  DECL_FIELD_BIT_OFFSET (gnu_field) = bitsize_zero_node;\n-\t  if (field_is_aliased (gnu_field))\n+\t  if (DECL_ALIASED_P (gnu_field))\n \t    SET_TYPE_ALIGN (gnu_record_type,\n \t\t\t    MAX (TYPE_ALIGN (gnu_record_type),\n \t\t\t\t TYPE_ALIGN (TREE_TYPE (gnu_field))));\n@@ -8505,19 +8234,22 @@ purpose_member_field (const_tree elem, tree list)\n static void\n annotate_rep (Entity_Id gnat_entity, tree gnu_type)\n {\n-  Entity_Id gnat_field;\n-  tree gnu_list;\n+  /* For an extension, the inherited components have not been translated because\n+     they are fetched from the _Parent component on the fly.  */\n+  const bool is_extension\n+    = Is_Tagged_Type (gnat_entity) && Is_Derived_Type (gnat_entity);\n \n   /* We operate by first making a list of all fields and their position (we\n      can get the size easily) and then update all the sizes in the tree.  */\n-  gnu_list\n+  tree gnu_list\n     = build_position_list (gnu_type, false, size_zero_node, bitsize_zero_node,\n \t\t\t   BIGGEST_ALIGNMENT, NULL_TREE);\n \n-  for (gnat_field = First_Entity (gnat_entity);\n+  for (Entity_Id gnat_field = First_Entity (gnat_entity);\n        Present (gnat_field);\n        gnat_field = Next_Entity (gnat_field))\n-    if (Ekind (gnat_field) == E_Component\n+    if ((Ekind (gnat_field) == E_Component\n+\t && (is_extension || present_gnu_tree (gnat_field)))\n \t|| (Ekind (gnat_field) == E_Discriminant\n \t    && !Is_Unchecked_Union (Scope (gnat_field))))\n       {\n@@ -8564,7 +8296,7 @@ annotate_rep (Entity_Id gnat_entity, tree gnu_type)\n \t    Set_Esize (gnat_field,\n \t\t       annotate_value (DECL_SIZE (TREE_PURPOSE (t))));\n \t  }\n-\telse if (Is_Tagged_Type (gnat_entity) && Is_Derived_Type (gnat_entity))\n+\telse if (is_extension)\n \t  {\n \t    /* If there is no entry, this is an inherited component whose\n \t       position is the same as in the parent type.  */\n@@ -8665,7 +8397,7 @@ build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)\n \t\t\t\t    (Node (gnat_constr), gnat_subtype,\n \t\t\t\t     get_entity_char (gnat_discrim),\n \t\t\t\t     definition, true, false));\n-\tsubst_pair s = {gnu_field, replacement};\n+\tsubst_pair s = { gnu_field, replacement };\n \tgnu_list.safe_push (s);\n       }\n \n@@ -8699,7 +8431,7 @@ build_variant_list (tree qual_union_type, vec<subst_pair> subst_list,\n       if (!integer_zerop (qual))\n \t{\n \t  tree variant_type = TREE_TYPE (gnu_field), variant_subpart;\n-\t  variant_desc v = {variant_type, gnu_field, qual, NULL_TREE};\n+\t  variant_desc v = { variant_type, gnu_field, qual, NULL_TREE };\n \n \t  gnu_list.safe_push (v);\n \n@@ -9350,13 +9082,14 @@ get_variant_part (tree record_type)\n    the list of variants to be used and RECORD_TYPE is the type of the parent.\n    POS_LIST is a position list describing the layout of fields present in\n    OLD_VARIANT_PART and SUBST_LIST a substitution list to be applied to this\n-   layout.  */\n+   layout.  DEBUG_INFO_P is true if we need to write debug information.  */\n \n static tree\n create_variant_part_from (tree old_variant_part,\n \t\t\t  vec<variant_desc> variant_list,\n \t\t\t  tree record_type, tree pos_list,\n-\t\t\t  vec<subst_pair> subst_list)\n+\t\t\t  vec<subst_pair> subst_list,\n+\t\t\t  bool debug_info_p)\n {\n   tree offset = DECL_FIELD_OFFSET (old_variant_part);\n   tree old_union_type = TREE_TYPE (old_variant_part);\n@@ -9374,7 +9107,9 @@ create_variant_part_from (tree old_variant_part,\n   /* If the position of the variant part is constant, subtract it from the\n      size of the type of the parent to get the new size.  This manual CSE\n      reduces the code size when not optimizing.  */\n-  if (TREE_CODE (offset) == INTEGER_CST)\n+  if (TREE_CODE (offset) == INTEGER_CST\n+      && TYPE_SIZE (record_type)\n+      && TYPE_SIZE_UNIT (record_type))\n     {\n       tree bitpos = DECL_FIELD_BIT_OFFSET (old_variant_part);\n       tree first_bit = bit_from_pos (offset, bitpos);\n@@ -9414,17 +9149,17 @@ create_variant_part_from (tree old_variant_part,\n \t{\n \t  tree new_variant_subpart\n \t    = create_variant_part_from (old_variant_subpart, variant_list,\n-\t\t\t\t\tnew_variant, pos_list, subst_list);\n+\t\t\t\t\tnew_variant, pos_list, subst_list,\n+\t\t\t\t\tdebug_info_p);\n \t  DECL_CHAIN (new_variant_subpart) = field_list;\n \t  field_list = new_variant_subpart;\n \t}\n \n-      /* Finish up the new variant and create the field.  No need for debug\n-\t info thanks to the XVS type.  */\n-      finish_record_type (new_variant, nreverse (field_list), 2, false);\n+      /* Finish up the new variant and create the field.  */\n+      finish_record_type (new_variant, nreverse (field_list), 2, debug_info_p);\n       compute_record_mode (new_variant);\n-      create_type_decl (TYPE_NAME (new_variant), new_variant, true, false,\n-\t\t\tEmpty);\n+      create_type_decl (TYPE_NAME (new_variant), new_variant, true,\n+\t\t\tdebug_info_p, Empty);\n \n       new_field\n \t= create_field_decl_from (old_field, new_variant, new_union_type,\n@@ -9436,13 +9171,13 @@ create_variant_part_from (tree old_variant_part,\n       union_field_list = new_field;\n     }\n \n-  /* Finish up the union type and create the variant part.  No need for debug\n-     info thanks to the XVS type.  Note that we don't reverse the field list\n-     because VARIANT_LIST has been traversed in reverse order.  */\n-  finish_record_type (new_union_type, union_field_list, 2, false);\n+  /* Finish up the union type and create the variant part.  Note that we don't\n+     reverse the field list because VARIANT_LIST has been traversed in reverse\n+     order.  */\n+  finish_record_type (new_union_type, union_field_list, 2, debug_info_p);\n   compute_record_mode (new_union_type);\n-  create_type_decl (TYPE_NAME (new_union_type), new_union_type, true, false,\n-\t\t    Empty);\n+  create_type_decl (TYPE_NAME (new_union_type), new_union_type, true,\n+\t\t    debug_info_p, Empty);\n \n   new_variant_part\n     = create_field_decl_from (old_variant_part, new_union_type, record_type,\n@@ -9509,6 +9244,294 @@ copy_and_substitute_in_size (tree new_type, tree old_type,\n   TYPE_SIZE_UNIT (new_type) = variable_size (TYPE_SIZE_UNIT (new_type));\n }\n \n+/* Return true if DISC is a stored discriminant of RECORD_TYPE.  */\n+\n+static inline bool\n+is_stored_discriminant (Entity_Id discr, Entity_Id record_type)\n+{\n+  if (Is_Tagged_Type (record_type))\n+    return No (Corresponding_Discriminant (discr));\n+  else if (Ekind (record_type) == E_Record_Type)\n+    return Original_Record_Component (discr) == discr;\n+  else\n+    return true;\n+}\n+\n+/* Copy the layout from {GNAT,GNU}_OLD_TYPE to {GNAT,GNU}_NEW_TYPE, which are\n+   both record types, after applying the substitutions described in SUBST_LIST.\n+   DEBUG_INFO_P is true if we need to write debug information for NEW_TYPE.  */\n+\n+static void\n+copy_and_substitute_in_layout (Entity_Id gnat_new_type,\n+\t\t\t       Entity_Id gnat_old_type,\n+\t\t\t       tree gnu_new_type,\n+\t\t\t       tree gnu_old_type,\n+\t\t\t       vec<subst_pair> gnu_subst_list,\n+\t\t\t       bool debug_info_p)\n+{\n+  const bool is_subtype = (Ekind (gnat_new_type) == E_Record_Subtype);\n+  tree gnu_field_list = NULL_TREE;\n+  bool selected_variant, all_constant_pos = true;\n+  vec<variant_desc> gnu_variant_list;\n+\n+  /* Look for REP and variant parts in the old type.  */\n+  tree gnu_rep_part = get_rep_part (gnu_old_type);\n+  tree gnu_variant_part = get_variant_part (gnu_old_type);\n+\n+  /* If there is a variant part, we must compute whether the constraints\n+     statically select a particular variant.  If so, we simply drop the\n+     qualified union and flatten the list of fields.  Otherwise we will\n+     build a new qualified union for the variants that are still relevant.  */\n+  if (gnu_variant_part)\n+    {\n+      variant_desc *v;\n+      unsigned int i;\n+\n+      gnu_variant_list = build_variant_list (TREE_TYPE (gnu_variant_part),\n+\t\t\t\t\t     gnu_subst_list, vNULL);\n+\n+      /* If all the qualifiers are unconditionally true, the innermost variant\n+\t is statically selected.  */\n+      selected_variant = true;\n+      FOR_EACH_VEC_ELT (gnu_variant_list, i, v)\n+\tif (!integer_onep (v->qual))\n+\t  {\n+\t    selected_variant = false;\n+\t    break;\n+\t  }\n+\n+      /* Otherwise, create the new variants.  */\n+      if (!selected_variant)\n+\tFOR_EACH_VEC_ELT (gnu_variant_list, i, v)\n+\t  {\n+\t    tree old_variant = v->type;\n+\t    tree new_variant = make_node (RECORD_TYPE);\n+\t    tree suffix\n+\t      = concat_name (DECL_NAME (gnu_variant_part),\n+\t\t\t     IDENTIFIER_POINTER (DECL_NAME (v->field)));\n+\t    TYPE_NAME (new_variant)\n+\t      = concat_name (TYPE_NAME (gnu_new_type),\n+\t\t\t     IDENTIFIER_POINTER (suffix));\n+\t    TYPE_REVERSE_STORAGE_ORDER (new_variant)\n+\t      = TYPE_REVERSE_STORAGE_ORDER (gnu_new_type);\n+\t    copy_and_substitute_in_size (new_variant, old_variant,\n+\t\t\t\t\t gnu_subst_list);\n+\t    v->new_type = new_variant;\n+\t  }\n+    }\n+  else\n+    {\n+      gnu_variant_list.create (0);\n+      selected_variant = false;\n+    }\n+\n+  /* Make a list of fields and their position in the old type.  */\n+  tree gnu_pos_list\n+    = build_position_list (gnu_old_type,\n+\t\t\t   gnu_variant_list.exists () && !selected_variant,\n+\t\t\t   size_zero_node, bitsize_zero_node,\n+\t\t\t   BIGGEST_ALIGNMENT, NULL_TREE);\n+\n+  /* Now go down every component in the new type and compute its size and\n+     position from those of the component in the old type and the stored\n+     constraints of the new type.  */\n+  Entity_Id gnat_field, gnat_old_field;\n+  for (gnat_field = First_Entity (gnat_new_type);\n+       Present (gnat_field);\n+       gnat_field = Next_Entity (gnat_field))\n+    if ((Ekind (gnat_field) == E_Component\n+\t || (Ekind (gnat_field) == E_Discriminant\n+\t     && is_stored_discriminant (gnat_field, gnat_new_type)))\n+        && (gnat_old_field = is_subtype\n+\t\t\t     ? Original_Record_Component (gnat_field)\n+\t\t\t     : Corresponding_Record_Component (gnat_field))\n+\t&& Underlying_Type (Scope (gnat_old_field)) == gnat_old_type\n+\t&& present_gnu_tree (gnat_old_field))\n+      {\n+\tName_Id gnat_name = Chars (gnat_field);\n+\ttree gnu_old_field = get_gnu_tree (gnat_old_field);\n+\tif (TREE_CODE (gnu_old_field) == COMPONENT_REF)\n+\t  gnu_old_field = TREE_OPERAND (gnu_old_field, 1);\n+        tree gnu_context = DECL_CONTEXT (gnu_old_field);\n+\ttree gnu_field, gnu_field_type, gnu_size, gnu_pos;\n+\ttree gnu_cont_type, gnu_last = NULL_TREE;\n+\n+\t/* If the type is the same, retrieve the GCC type from the\n+\t   old field to take into account possible adjustments.  */\n+\tif (Etype (gnat_field) == Etype (gnat_old_field))\n+\t  gnu_field_type = TREE_TYPE (gnu_old_field);\n+\telse\n+\t  gnu_field_type = gnat_to_gnu_type (Etype (gnat_field));\n+\n+\t/* If there was a component clause, the field types must be the same\n+\t   for the old and new types, so copy the data from the old field to\n+\t   avoid recomputation here.  Also if the field is justified modular\n+\t   and the optimization in gnat_to_gnu_field was applied.  */\n+\tif (Present (Component_Clause (gnat_old_field))\n+\t    || (TREE_CODE (gnu_field_type) == RECORD_TYPE\n+\t\t&& TYPE_JUSTIFIED_MODULAR_P (gnu_field_type)\n+\t\t&& TREE_TYPE (TYPE_FIELDS (gnu_field_type))\n+\t\t   == TREE_TYPE (gnu_old_field)))\n+\t  {\n+\t    gnu_size = DECL_SIZE (gnu_old_field);\n+\t    gnu_field_type = TREE_TYPE (gnu_old_field);\n+\t  }\n+\n+\t/* If the old field was packed and of constant size, we have to get the\n+\t   old size here as it might differ from what the Etype conveys and the\n+\t   latter might overlap with the following field.  Try to arrange the\n+\t   type for possible better packing along the way.  */\n+\telse if (DECL_PACKED (gnu_old_field)\n+\t\t && TREE_CODE (DECL_SIZE (gnu_old_field)) == INTEGER_CST)\n+\t  {\n+\t    gnu_size = DECL_SIZE (gnu_old_field);\n+\t    if (RECORD_OR_UNION_TYPE_P (gnu_field_type)\n+\t\t&& !TYPE_FAT_POINTER_P (gnu_field_type)\n+\t\t&& tree_fits_uhwi_p (TYPE_SIZE (gnu_field_type)))\n+\t      gnu_field_type = make_packable_type (gnu_field_type, true);\n+\t  }\n+\n+\telse\n+\t  gnu_size = TYPE_SIZE (gnu_field_type);\n+\n+\t/* If the context of the old field is the old type or its REP part,\n+\t   put the field directly in the new type; otherwise look up the\n+\t   context in the variant list and put the field either in the new\n+\t   type if there is a selected variant or in one new variant.  */\n+\tif (gnu_context == gnu_old_type\n+\t    || (gnu_rep_part && gnu_context == TREE_TYPE (gnu_rep_part)))\n+\t  gnu_cont_type = gnu_new_type;\n+\telse\n+\t  {\n+\t    variant_desc *v;\n+\t    unsigned int i;\n+\t    tree rep_part;\n+\n+\t    FOR_EACH_VEC_ELT (gnu_variant_list, i, v)\n+\t      if (gnu_context == v->type\n+\t\t  || ((rep_part = get_rep_part (v->type))\n+\t\t      && gnu_context == TREE_TYPE (rep_part)))\n+\t\tbreak;\n+\n+\t    if (v)\n+\t      gnu_cont_type = selected_variant ? gnu_new_type : v->new_type;\n+\t    else\n+\t      /* The front-end may pass us \"ghost\" components if it fails to\n+\t\t recognize that a constrain statically selects a particular\n+\t\t variant.  Discard them.  */\n+\t      continue;\n+\t  }\n+\n+\t/* Now create the new field modeled on the old one.  */\n+\tgnu_field\n+\t  = create_field_decl_from (gnu_old_field, gnu_field_type,\n+\t\t\t\t    gnu_cont_type, gnu_size,\n+\t\t\t\t    gnu_pos_list, gnu_subst_list);\n+\tgnu_pos = DECL_FIELD_OFFSET (gnu_field);\n+\n+\t/* If the context is a variant, put it in the new variant directly.  */\n+\tif (gnu_cont_type != gnu_new_type)\n+\t  {\n+\t    DECL_CHAIN (gnu_field) = TYPE_FIELDS (gnu_cont_type);\n+\t    TYPE_FIELDS (gnu_cont_type) = gnu_field;\n+\t  }\n+\n+\t/* To match the layout crafted in components_to_record, if this is\n+\t   the _Tag or _Parent field, put it before any other fields.  */\n+\telse if (gnat_name == Name_uTag || gnat_name == Name_uParent)\n+\t  gnu_field_list = chainon (gnu_field_list, gnu_field);\n+\n+\t/* Similarly, if this is the _Controller field, put it before the\n+\t   other fields except for the _Tag or _Parent field.  */\n+\telse if (gnat_name == Name_uController && gnu_last)\n+\t  {\n+\t    DECL_CHAIN (gnu_field) = DECL_CHAIN (gnu_last);\n+\t    DECL_CHAIN (gnu_last) = gnu_field;\n+\t  }\n+\n+\t/* Otherwise, put it after the other fields.  */\n+\telse\n+\t  {\n+\t    DECL_CHAIN (gnu_field) = gnu_field_list;\n+\t    gnu_field_list = gnu_field;\n+\t    if (!gnu_last)\n+\t      gnu_last = gnu_field;\n+\t    if (TREE_CODE (gnu_pos) != INTEGER_CST)\n+\t      all_constant_pos = false;\n+\t  }\n+\n+\t/* For a stored discriminant in a derived type, replace the field.  */\n+\tif (!is_subtype && Ekind (gnat_field) == E_Discriminant)\n+\t  {\n+\t    tree gnu_ref = get_gnu_tree (gnat_field);\n+\t    TREE_OPERAND (gnu_ref, 1) = gnu_field;\n+\t  }\n+\telse\n+\t  save_gnu_tree (gnat_field, gnu_field, false);\n+      }\n+\n+  /* If there is a variant list, a selected variant and the fields all have a\n+     constant position, put them in order of increasing position to match that\n+     of constant CONSTRUCTORs.  Likewise if there is no variant list but a REP\n+     part, since the latter has been flattened in the process.  */\n+  if ((gnu_variant_list.exists () ? selected_variant : gnu_rep_part != NULL)\n+      && all_constant_pos)\n+    {\n+      const int len = list_length (gnu_field_list);\n+      tree *field_arr = XALLOCAVEC (tree, len), t = gnu_field_list;\n+\n+      for (int i = 0; t; t = DECL_CHAIN (t), i++)\n+\tfield_arr[i] = t;\n+\n+      qsort (field_arr, len, sizeof (tree), compare_field_bitpos);\n+\n+      gnu_field_list = NULL_TREE;\n+      for (int i = 0; i < len; i++)\n+\t{\n+\t  DECL_CHAIN (field_arr[i]) = gnu_field_list;\n+\t  gnu_field_list = field_arr[i];\n+\t}\n+    }\n+\n+  /* If there is a variant list and no selected variant, we need to create the\n+     nest of variant parts from the old nest.  */\n+  else if (gnu_variant_list.exists () && !selected_variant)\n+    {\n+      tree new_variant_part\n+\t= create_variant_part_from (gnu_variant_part, gnu_variant_list,\n+\t\t\t\t    gnu_new_type, gnu_pos_list,\n+\t\t\t\t    gnu_subst_list, debug_info_p);\n+      DECL_CHAIN (new_variant_part) = gnu_field_list;\n+      gnu_field_list = new_variant_part;\n+    }\n+\n+  gnu_variant_list.release ();\n+  gnu_subst_list.release ();\n+\n+  gnu_field_list = nreverse (gnu_field_list);\n+\n+  /* If NEW_TYPE is a subtype, it inherits all the attributes from OLD_TYPE.\n+     Otherwise sizes and alignment must be computed independently.  */\n+  if (is_subtype)\n+    {\n+      finish_record_type (gnu_new_type, gnu_field_list, 2, debug_info_p);\n+      compute_record_mode (gnu_new_type);\n+    }\n+  else\n+    finish_record_type (gnu_new_type, gnu_field_list, 1, debug_info_p);\n+\n+  /* Now go through the entities again looking for Itypes that we have not yet\n+     elaborated (e.g. Etypes of fields that have Original_Components).  */\n+  for (Entity_Id gnat_field = First_Entity (gnat_new_type);\n+       Present (gnat_field);\n+       gnat_field = Next_Entity (gnat_field))\n+    if ((Ekind (gnat_field) == E_Component\n+\t || Ekind (gnat_field) == E_Discriminant)\n+\t&& Is_Itype (Etype (gnat_field))\n+\t&& !present_gnu_tree (Etype (gnat_field)))\n+      gnat_to_gnu_entity (Etype (gnat_field), NULL_TREE, false);\n+}\n+\n /* Associate to GNU_TYPE, the translation of GNAT_ENTITY, which is\n    the implementation type of a packed array type (Is_Packed_Array_Impl_Type),\n    the original array type if it has been translated.  This association is a\n@@ -9544,9 +9567,9 @@ associate_original_type_to_packed_array (tree gnu_type, Entity_Id gnat_entity)\n     add_parallel_type (gnu_type, gnu_original_array_type);\n }\n \f\n-/* Given a type T, a FIELD_DECL F, and a replacement value R, return a\n-   type with all size expressions that contain F in a PLACEHOLDER_EXPR\n-   updated by replacing F with R.\n+/* Given a type T, a FIELD_DECL F, and a replacement value R, return an\n+   equivalent type with adjusted size expressions where all occurrences\n+   of references to F in a PLACEHOLDER_EXPR have been replaced by R.\n \n    The function doesn't update the layout of the type, i.e. it assumes\n    that the substitution is purely formal.  That's why the replacement"}, {"sha": "fcbf86e8cc4bbbb4dc783068430e4b557e18cdf5", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dbb83f9e3b783de3d666348b1d1a0e7895b09f/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dbb83f9e3b783de3d666348b1d1a0e7895b09f/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=05dbb83f9e3b783de3d666348b1d1a0e7895b09f", "patch": "@@ -18147,6 +18147,7 @@ package body Sem_Ch3 is\n \n          if not Is_Tagged then\n             Set_Original_Record_Component (New_C, New_C);\n+            Set_Corresponding_Record_Component (New_C, Old_C);\n          end if;\n \n          --  Set the proper type of an access discriminant\n@@ -18245,6 +18246,7 @@ package body Sem_Ch3 is\n                  and then Original_Record_Component (Corr_Discrim) = Old_C\n                then\n                   Set_Original_Record_Component (Discrim, New_C);\n+                  Set_Corresponding_Record_Component (Discrim, Empty);\n                end if;\n \n                Next_Discriminant (Discrim);"}]}