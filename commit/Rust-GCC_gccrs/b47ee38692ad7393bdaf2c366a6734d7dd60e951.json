{"sha": "b47ee38692ad7393bdaf2c366a6734d7dd60e951", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ3ZWUzODY5MmFkNzM5M2JkYWYyYzM2NmE2NzM0ZDdkZDYwZTk1MQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-04-03T09:33:27Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-04-03T09:33:27Z"}, "message": "tree-vrp.c (extract_range_from_unary_expr): Handle all conversions.\n\n2008-04-03  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vrp.c (extract_range_from_unary_expr): Handle all\n\tconversions.  Simplify code.\n\n\t* gcc.dg/tree-ssa/vrp43.c: New testcase.\n\t* gcc.dg/tree-ssa/vrp44.c: Likewise.\n\t* gcc.dg/tree-ssa/vrp45.c: Likewise.\n\nFrom-SVN: r133866", "tree": {"sha": "a2ae95848ad29834c4aebe2e2796e4c90590e0cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2ae95848ad29834c4aebe2e2796e4c90590e0cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b47ee38692ad7393bdaf2c366a6734d7dd60e951", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b47ee38692ad7393bdaf2c366a6734d7dd60e951", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b47ee38692ad7393bdaf2c366a6734d7dd60e951", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b47ee38692ad7393bdaf2c366a6734d7dd60e951/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2a7428c0c57b74cb4f0d7b497ec870132a3fb5d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a7428c0c57b74cb4f0d7b497ec870132a3fb5d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a7428c0c57b74cb4f0d7b497ec870132a3fb5d7"}], "stats": {"total": 184, "additions": 129, "deletions": 55}, "files": [{"sha": "321dfb04d0f447c7f662674f7dcf3ce1c663a341", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47ee38692ad7393bdaf2c366a6734d7dd60e951/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47ee38692ad7393bdaf2c366a6734d7dd60e951/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b47ee38692ad7393bdaf2c366a6734d7dd60e951", "patch": "@@ -1,3 +1,8 @@\n+2008-04-03  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (extract_range_from_unary_expr): Handle all\n+\tconversions.  Simplify code.\n+\n 2008-04-03  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.c (sh_output_mi_thunk): Free cfun."}, {"sha": "59bc95a8e9e826351d668c2d070e9d7dce013b90", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47ee38692ad7393bdaf2c366a6734d7dd60e951/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47ee38692ad7393bdaf2c366a6734d7dd60e951/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b47ee38692ad7393bdaf2c366a6734d7dd60e951", "patch": "@@ -1,3 +1,9 @@\n+2008-04-03  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/vrp43.c: New testcase.\n+\t* gcc.dg/tree-ssa/vrp44.c: Likewise.\n+\t* gcc.dg/tree-ssa/vrp45.c: Likewise.\n+\n 2008-04-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/35741"}, {"sha": "f475354dcfe1e8210fed27e6c4f63cd086dd9e95", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp43.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47ee38692ad7393bdaf2c366a6734d7dd60e951/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47ee38692ad7393bdaf2c366a6734d7dd60e951/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp43.c?ref=b47ee38692ad7393bdaf2c366a6734d7dd60e951", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+int __attribute__((noinline))\n+foo(int i)\n+{\n+  if (i != 0)\n+    {\n+      char c = (char)i;\n+      return c != 0;\n+    }\n+  return 0;\n+}\n+\n+extern void abort (void);\n+\n+int main()\n+{\n+  if (foo(0xff00))\n+    abort ();\n+  return 0;\n+}"}, {"sha": "a2df852c7bf4f38c4a2198a68c74d4deded0ead9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp44.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47ee38692ad7393bdaf2c366a6734d7dd60e951/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp44.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47ee38692ad7393bdaf2c366a6734d7dd60e951/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp44.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp44.c?ref=b47ee38692ad7393bdaf2c366a6734d7dd60e951", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do link } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void link_error (void);\n+\n+void test1(int i)\n+{\n+  if (i >= -5 && i <= 8)\n+    {\n+      unsigned int j = i + 1;\n+      if (j == -5)\n+\tlink_error ();\n+      if (j == 10)\n+\tlink_error ();\n+    }\n+}\n+\n+void test2(unsigned int i)\n+{\n+  if (i >= -5 || i <= 8)\n+    {\n+      int j = i;\n+      if (j == -6)\n+\tlink_error ();\n+      if (j == 9)\n+\tlink_error ();\n+    }\n+}\n+\n+int main() { return 0; }"}, {"sha": "7916d2da880a5bd5c7067220e148604f6e118720", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp45.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47ee38692ad7393bdaf2c366a6734d7dd60e951/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp45.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47ee38692ad7393bdaf2c366a6734d7dd60e951/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp45.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp45.c?ref=b47ee38692ad7393bdaf2c366a6734d7dd60e951", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do link } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void link_error (void);\n+\n+void foo (int i)\n+{\n+  if (i > -128 && i < 127)\n+    {\n+      unsigned char k = i;\n+      if (k == 0x80)\n+        link_error ();\n+      if (k == 0x7f)\n+        link_error ();\n+    }\n+}\n+\n+int main() { return 0; }\n+"}, {"sha": "9741262dba23c4eda570bae2038d0da10a0761dd", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 47, "deletions": 55, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47ee38692ad7393bdaf2c366a6734d7dd60e951/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47ee38692ad7393bdaf2c366a6734d7dd60e951/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=b47ee38692ad7393bdaf2c366a6734d7dd60e951", "patch": "@@ -2350,71 +2350,63 @@ extract_range_from_unary_expr (value_range_t *vr, enum tree_code code,\n     }\n \n   /* Handle unary expressions on integer ranges.  */\n-  if (code == NOP_EXPR || code == CONVERT_EXPR)\n+  if ((code == NOP_EXPR\n+       || code == CONVERT_EXPR)\n+      && INTEGRAL_TYPE_P (type)\n+      && INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n     {\n       tree inner_type = TREE_TYPE (op0);\n       tree outer_type = type;\n \n-      /* If VR0 represents a simple range, then try to convert\n-\t the min and max values for the range to the same type\n-\t as OUTER_TYPE.  If the results compare equal to VR0's\n-\t min and max values and the new min is still less than\n-\t or equal to the new max, then we can safely use the newly\n-\t computed range for EXPR.  This allows us to compute\n-\t accurate ranges through many casts.  */\n-      if ((vr0.type == VR_RANGE\n-\t   && !overflow_infinity_range_p (&vr0))\n-\t  || (vr0.type == VR_VARYING\n-\t      && TYPE_PRECISION (outer_type) > TYPE_PRECISION (inner_type)))\n+      /* Always use base-types here.  This is important for the\n+\t correct signedness.  */\n+      if (TREE_TYPE (inner_type))\n+\tinner_type = TREE_TYPE (inner_type);\n+      if (TREE_TYPE (outer_type))\n+\touter_type = TREE_TYPE (outer_type);\n+\n+      /* If VR0 is varying and we increase the type precision, assume\n+\t a full range for the following transformation.  */\n+      if (vr0.type == VR_VARYING\n+\t  && TYPE_PRECISION (inner_type) < TYPE_PRECISION (outer_type))\n \t{\n-\t  tree new_min, new_max, orig_min, orig_max;\n-\n-\t  /* Convert the input operand min/max to OUTER_TYPE.   If\n-\t     the input has no range information, then use the min/max\n-\t     for the input's type.  */\n-\t  if (vr0.type == VR_RANGE)\n-\t    {\n-\t      orig_min = vr0.min;\n-\t      orig_max = vr0.max;\n-\t    }\n-\t  else\n-\t    {\n-\t      orig_min = TYPE_MIN_VALUE (inner_type);\n-\t      orig_max = TYPE_MAX_VALUE (inner_type);\n-\t    }\n-\n-\t  new_min = fold_convert (outer_type, orig_min);\n-\t  new_max = fold_convert (outer_type, orig_max);\n-\n-\t  /* Verify the new min/max values are gimple values and\n-\t     that they compare equal to the original input's\n-\t     min/max values.  */\n-\t  if (is_gimple_val (new_min)\n-\t      && is_gimple_val (new_max)\n-\t      && tree_int_cst_equal (new_min, orig_min)\n-\t      && tree_int_cst_equal (new_max, orig_max)\n-\t      && (!is_overflow_infinity (new_min)\n-\t\t  || !is_overflow_infinity (new_max))\n-\t      && (cmp = compare_values (new_min, new_max)) <= 0\n-\t      && cmp >= -1)\n-\t    {\n-\t      set_value_range (vr, VR_RANGE, new_min, new_max, vr->equiv);\n-\t      return;\n-\t    }\n+\t  vr0.type = VR_RANGE;\n+\t  vr0.min = TYPE_MIN_VALUE (inner_type);\n+\t  vr0.max = TYPE_MAX_VALUE (inner_type);\n \t}\n \n-      /* When converting types of different sizes, set the result to\n-\t VARYING.  Things like sign extensions and precision loss may\n-\t change the range.  For instance, if x_3 is of type 'long long\n-\t int' and 'y_5 = (unsigned short) x_3', if x_3 is ~[0, 0], it\n-\t is impossible to know at compile time whether y_5 will be\n-\t ~[0, 0].  */\n-      if (TYPE_SIZE (inner_type) != TYPE_SIZE (outer_type)\n-\t  || TYPE_PRECISION (inner_type) != TYPE_PRECISION (outer_type))\n+      /* If VR0 is a constant range or anti-range and the conversion is\n+\t not truncating we can convert the min and max values and\n+\t canonicalize the resulting range.  Otherwise we can do the\n+\t conversion if the size of the range is less than what the\n+\t precision of the target type can represent and the range is\n+\t not an anti-range.  */\n+      if ((vr0.type == VR_RANGE\n+\t   || vr0.type == VR_ANTI_RANGE)\n+\t  && TREE_CODE (vr0.min) == INTEGER_CST\n+\t  && TREE_CODE (vr0.max) == INTEGER_CST\n+\t  && !is_overflow_infinity (vr0.min)\n+\t  && !is_overflow_infinity (vr0.max)\n+\t  && (TYPE_PRECISION (outer_type) >= TYPE_PRECISION (inner_type)\n+\t      || (vr0.type == VR_RANGE\n+\t\t  && integer_zerop (int_const_binop (RSHIFT_EXPR,\n+\t\t       int_const_binop (MINUS_EXPR, vr0.max, vr0.min, 0),\n+\t\t         size_int (TYPE_PRECISION (outer_type)), 0)))))\n \t{\n-\t  set_value_range_to_varying (vr);\n+\t  tree new_min, new_max;\n+\t  new_min = force_fit_type_double (outer_type,\n+\t\t\t\t\t   TREE_INT_CST_LOW (vr0.min),\n+\t\t\t\t\t   TREE_INT_CST_HIGH (vr0.min), 0, 0);\n+\t  new_max = force_fit_type_double (outer_type,\n+\t\t\t\t\t   TREE_INT_CST_LOW (vr0.max),\n+\t\t\t\t\t   TREE_INT_CST_HIGH (vr0.max), 0, 0);\n+\t  set_and_canonicalize_value_range (vr, vr0.type,\n+\t\t\t\t\t    new_min, new_max, NULL);\n \t  return;\n \t}\n+\n+      set_value_range_to_varying (vr);\n+      return;\n     }\n \n   /* Conversion of a VR_VARYING value to a wider type can result"}]}