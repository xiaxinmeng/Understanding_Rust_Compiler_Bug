{"sha": "0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJlN2U3YTZkYmI0Y2RmNDhlNzZiZjliMzhmNDJiOTVlYmY0ZDc1Mg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-23T19:44:19Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-23T19:44:19Z"}, "message": "bb-reorder: Split EH edges crossing partitions.\n\nFrom-SVN: r176696", "tree": {"sha": "389d88dc095866e7b7f73e8f1553aa55bd3617a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/389d88dc095866e7b7f73e8f1553aa55bd3617a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/comments", "author": null, "committer": null, "parents": [{"sha": "e01705517ac38e207e8f52610a46ad0c4aca61e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e01705517ac38e207e8f52610a46ad0c4aca61e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e01705517ac38e207e8f52610a46ad0c4aca61e0"}], "stats": {"total": 450, "additions": 276, "deletions": 174}, "files": [{"sha": "560715af90c067d9911891d940193f0f1fcbbdd1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752", "patch": "@@ -1,3 +1,23 @@\n+2011-07-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* basic-block.h (EDGE_PRESERVE): New.\n+\t(EDGE_ALL_FLAGS, EDGE_COMPLEX): Include it.\n+\t* bb-reorder.c: Include except.h.\n+\t(fix_up_crossing_landing_pad): New.\n+\t(find_rarely_executed_basic_blocks_and_crossing_edges): Place \n+\tlanding pads in the right partition.  Duplicate as necessary.\n+\t(partition_hot_cold_basic_blocks): Fix up DF info after\n+\tduplicating landing pads.\n+\t* cfg.c (dump_edge_info): Add crossing and preserve to bitnames.\n+\t* cfgrtl.c (rtl_verify_flow_info_1): Validate that EDGE_CROSSING\n+\tis set properly.  Validate that EH edges are not CROSSING.\n+\t* except.c (expand_dw2_landing_pad_for_region): Split out from ...\n+\t(dw2_build_landing_pads): ... here.\n+\t(convert_to_eh_region_ranges): Remove code to fixup crossing\n+\tlanding pads.\n+\t* except.h (expand_dw2_landing_pad_for_region): Declare.\n+\t* tree-cfg.c (gimple_can_merge_blocks_p): Don't merge PRESERVE edges.\n+\n 2011-07-23  Richard Earnshaw  <rearnsha@arm.com>\n \n \tPR target/49816"}, {"sha": "2f8d08fedf13b365f02779cbf9fc4802d42c98b9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752", "patch": "@@ -3464,7 +3464,7 @@ bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(FLAGS_H) $(TIMEVAR_H) output.h $(CFGLAYOUT_H) $(FIBHEAP_H) \\\n    $(TARGET_H) $(FUNCTION_H) $(TM_P_H) $(OBSTACK_H) $(EXPR_H) $(REGS_H) \\\n    $(PARAMS_H) toplev.h $(DIAGNOSTIC_CORE_H) $(TREE_PASS_H) $(DF_H) \\\n-   bb-reorder.h\n+   $(EXCEPT_H) bb-reorder.h\n tracer.o : tracer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(BASIC_BLOCK_H) hard-reg-set.h output.h $(CFGLAYOUT_H) \\\n    $(FLAGS_H) $(TIMEVAR_H) $(PARAMS_H) $(COVERAGE_H) $(FIBHEAP_H) \\"}, {"sha": "c03129c6abfa62375620ad8190e7cea1689ae5c0", "filename": "gcc/basic-block.h", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752", "patch": "@@ -65,31 +65,34 @@ DEF_VEC_P(edge);\n DEF_VEC_ALLOC_P(edge,gc);\n DEF_VEC_ALLOC_P(edge,heap);\n \n-#define EDGE_FALLTHRU\t\t1\t/* 'Straight line' flow */\n-#define EDGE_ABNORMAL\t\t2\t/* Strange flow, like computed\n+/* Always update the table in cfg.c dump_edge_info.  */\n+#define EDGE_FALLTHRU\t\t0x0001\t/* 'Straight line' flow */\n+#define EDGE_ABNORMAL\t\t0x0002\t/* Strange flow, like computed\n \t\t\t\t\t   label, or eh */\n-#define EDGE_ABNORMAL_CALL\t4\t/* Call with abnormal exit\n+#define EDGE_ABNORMAL_CALL\t0x0004\t/* Call with abnormal exit\n \t\t\t\t\t   like an exception, or sibcall */\n-#define EDGE_EH\t\t\t8\t/* Exception throw */\n-#define EDGE_FAKE\t\t16\t/* Not a real edge (profile.c) */\n-#define EDGE_DFS_BACK\t\t32\t/* A backwards edge */\n-#define EDGE_CAN_FALLTHRU\t64\t/* Candidate for straight line\n+#define EDGE_EH\t\t\t0x0008\t/* Exception throw */\n+#define EDGE_FAKE\t\t0x0010\t/* Not a real edge (profile.c) */\n+#define EDGE_DFS_BACK\t\t0x0020\t/* A backwards edge */\n+#define EDGE_CAN_FALLTHRU\t0x0040\t/* Candidate for straight line\n \t\t\t\t\t   flow.  */\n-#define EDGE_IRREDUCIBLE_LOOP\t128\t/* Part of irreducible loop.  */\n-#define EDGE_SIBCALL\t\t256\t/* Edge from sibcall to exit.  */\n-#define EDGE_LOOP_EXIT\t\t512\t/* Exit of a loop.  */\n-#define EDGE_TRUE_VALUE\t\t1024\t/* Edge taken when controlling\n+#define EDGE_IRREDUCIBLE_LOOP\t0x0080\t/* Part of irreducible loop.  */\n+#define EDGE_SIBCALL\t\t0x0100\t/* Edge from sibcall to exit.  */\n+#define EDGE_LOOP_EXIT\t\t0x0200\t/* Exit of a loop.  */\n+#define EDGE_TRUE_VALUE\t\t0x0400\t/* Edge taken when controlling\n \t\t\t\t\t   predicate is nonzero.  */\n-#define EDGE_FALSE_VALUE\t2048\t/* Edge taken when controlling\n+#define EDGE_FALSE_VALUE\t0x0800\t/* Edge taken when controlling\n \t\t\t\t\t   predicate is zero.  */\n-#define EDGE_EXECUTABLE\t\t4096\t/* Edge is executable.  Only\n+#define EDGE_EXECUTABLE\t\t0x1000\t/* Edge is executable.  Only\n \t\t\t\t\t   valid during SSA-CCP.  */\n-#define EDGE_CROSSING\t\t8192    /* Edge crosses between hot\n+#define EDGE_CROSSING\t\t0x2000\t/* Edge crosses between hot\n \t\t\t\t\t   and cold sections, when we\n \t\t\t\t\t   do partitioning.  */\n-#define EDGE_ALL_FLAGS\t       16383\n+#define EDGE_PRESERVE\t\t0x4000\t/* Never merge blocks via this edge. */\n+#define EDGE_ALL_FLAGS\t\t0x7fff\n \n-#define EDGE_COMPLEX\t(EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH)\n+#define EDGE_COMPLEX \\\n+  (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH | EDGE_PRESERVE)\n \n /* Counter summary from the last set of coverage counts read by\n    profile.c.  */\n@@ -203,7 +206,9 @@ DEF_VEC_ALLOC_P(basic_block,heap);\n    the compilation, so they are never cleared.\n \n    All other flags may be cleared by clear_bb_flags().  It is generally\n-   a bad idea to rely on any flags being up-to-date.  */\n+   a bad idea to rely on any flags being up-to-date.\n+\n+   Always update the table in cfg.c dump_bb_info.  */\n \n enum bb_flags\n {"}, {"sha": "11423fed29a0985295dd0112f06622ad83b32f41", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 166, "deletions": 20, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752", "patch": "@@ -87,6 +87,7 @@\n #include \"tree-pass.h\"\n #include \"df.h\"\n #include \"bb-reorder.h\"\n+#include \"except.h\"\n \n /* The number of rounds.  In most cases there will only be 4 rounds, but\n    when partitioning hot and cold basic blocks into separate sections of\n@@ -1208,6 +1209,79 @@ get_uncond_jump_length (void)\n   return length;\n }\n \n+/* Emit a barrier into the footer of BB.  */\n+\n+static void\n+emit_barrier_after_bb (basic_block bb)\n+{\n+  rtx barrier = emit_barrier_after (BB_END (bb));\n+  bb->il.rtl->footer = unlink_insn_chain (barrier, barrier);\n+}\n+\n+/* The landing pad OLD_LP, in block OLD_BB, has edges from both partitions.\n+   Duplicate the landing pad and split the edges so that no EH edge\n+   crosses partitions.  */\n+\n+static void\n+fix_up_crossing_landing_pad (eh_landing_pad old_lp, basic_block old_bb)\n+{\n+  eh_landing_pad new_lp;\n+  basic_block new_bb, last_bb, post_bb;\n+  rtx new_label, jump, post_label;\n+  unsigned new_partition;\n+  edge_iterator ei;\n+  edge e;\n+\n+  /* Generate the new landing-pad structure.  */\n+  new_lp = gen_eh_landing_pad (old_lp->region);\n+  new_lp->post_landing_pad = old_lp->post_landing_pad;\n+  new_lp->landing_pad = gen_label_rtx ();\n+  LABEL_PRESERVE_P (new_lp->landing_pad) = 1;\n+\n+  /* Put appropriate instructions in new bb.  */\n+  new_label = emit_label (new_lp->landing_pad);\n+\n+  expand_dw2_landing_pad_for_region (old_lp->region);\n+\n+  post_bb = BLOCK_FOR_INSN (old_lp->landing_pad);\n+  post_bb = single_succ (post_bb);\n+  post_label = block_label (post_bb);\n+  jump = emit_jump_insn (gen_jump (post_label));\n+  JUMP_LABEL (jump) = post_label;\n+\n+  /* Create new basic block to be dest for lp.  */\n+  last_bb = EXIT_BLOCK_PTR->prev_bb;\n+  new_bb = create_basic_block (new_label, jump, last_bb);\n+  new_bb->aux = last_bb->aux;\n+  last_bb->aux = new_bb;\n+\n+  emit_barrier_after_bb (new_bb);\n+\n+  make_edge (new_bb, post_bb, 0);\n+\n+  /* Make sure new bb is in the other partition.  */\n+  new_partition = BB_PARTITION (old_bb);\n+  new_partition ^= BB_HOT_PARTITION | BB_COLD_PARTITION;\n+  BB_SET_PARTITION (new_bb, new_partition);\n+\n+  /* Fix up the edges.  */\n+  for (ei = ei_start (old_bb->preds); (e = ei_safe_edge (ei)) != NULL; )\n+    if (BB_PARTITION (e->src) == new_partition)\n+      {\n+\trtx insn = BB_END (e->src);\n+\trtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n+\n+\tgcc_assert (note != NULL);\n+\tgcc_checking_assert (INTVAL (XEXP (note, 0)) == old_lp->index);\n+\tXEXP (note, 0) = GEN_INT (new_lp->index);\n+\n+\t/* Adjust the edge to the new destination.  */\n+\tredirect_edge_succ (e, new_bb);\n+      }\n+    else\n+      ei_next (&ei);\n+}\n+\n /* Find the basic blocks that are rarely executed and need to be moved to\n    a separate section of the .o file (to cut down on paging and improve\n    cache locality).  Return a vector of all edges that cross.  */\n@@ -1221,7 +1295,6 @@ find_rarely_executed_basic_blocks_and_crossing_edges (void)\n   edge_iterator ei;\n \n   /* Mark which partition (hot/cold) each basic block belongs in.  */\n-\n   FOR_EACH_BB (bb)\n     {\n       if (probably_never_executed_bb_p (bb))\n@@ -1230,32 +1303,71 @@ find_rarely_executed_basic_blocks_and_crossing_edges (void)\n \tBB_SET_PARTITION (bb, BB_HOT_PARTITION);\n     }\n \n-  /* Mark every edge that crosses between sections.  */\n-\n-  FOR_EACH_BB (bb)\n-    FOR_EACH_EDGE (e, ei, bb->succs)\n+  /* The format of .gcc_except_table does not allow landing pads to\n+     be in a different partition as the throw.  Fix this by either\n+     moving or duplicating the landing pads.  */\n+  if (cfun->eh->lp_array)\n     {\n-      if (e->src != ENTRY_BLOCK_PTR\n-\t  && e->dest != EXIT_BLOCK_PTR\n-\t  && BB_PARTITION (e->src) != BB_PARTITION (e->dest))\n+      unsigned i;\n+      eh_landing_pad lp;\n+\n+      FOR_EACH_VEC_ELT (eh_landing_pad, cfun->eh->lp_array, i, lp)\n \t{\n-\t  e->flags |= EDGE_CROSSING;\n-\t  VEC_safe_push (edge, heap, crossing_edges, e);\n+\t  bool all_same, all_diff;\n+\n+\t  if (lp == NULL)\n+\t    continue;\n+\n+\t  all_same = all_diff = true;\n+\t  bb = BLOCK_FOR_INSN (lp->landing_pad);\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    {\n+\t      gcc_assert (e->flags & EDGE_EH);\n+\t      if (BB_PARTITION (bb) == BB_PARTITION (e->src))\n+\t\tall_diff = false;\n+\t      else\n+\t\tall_same = false;\n+\t    }\n+\n+\t  if (all_same)\n+\t    ;\n+\t  else if (all_diff)\n+\t    {\n+\t      int which = BB_PARTITION (bb);\n+\t      which ^= BB_HOT_PARTITION | BB_COLD_PARTITION;\n+\t      BB_SET_PARTITION (bb, which);\n+\t    }\n+\t  else\n+\t    fix_up_crossing_landing_pad (lp, bb);\n \t}\n-      else\n-\te->flags &= ~EDGE_CROSSING;\n     }\n \n-  return crossing_edges;\n-}\n+  /* Mark every edge that crosses between sections.  */\n \n-/* Emit a barrier into the footer of BB.  */\n+  FOR_EACH_BB (bb)\n+    FOR_EACH_EDGE (e, ei, bb->succs)\n+      {\n+\tunsigned int flags = e->flags;\n+      \n+        /* We should never have EDGE_CROSSING set yet.  */\n+\tgcc_checking_assert ((flags & EDGE_CROSSING) == 0);\n+\n+\tif (e->src != ENTRY_BLOCK_PTR\n+\t    && e->dest != EXIT_BLOCK_PTR\n+\t    && BB_PARTITION (e->src) != BB_PARTITION (e->dest))\n+\t  {\n+\t    VEC_safe_push (edge, heap, crossing_edges, e);\n+\t    flags |= EDGE_CROSSING;\n+\t  }\n \n-static void\n-emit_barrier_after_bb (basic_block bb)\n-{\n-  rtx barrier = emit_barrier_after (BB_END (bb));\n-  bb->il.rtl->footer = unlink_insn_chain (barrier, barrier);\n+\t/* Now that we've split eh edges as appropriate, allow landing pads\n+\t   to be merged with the post-landing pads.  */\n+\tflags &= ~EDGE_PRESERVE;\n+\n+\te->flags = flags;\n+      }\n+\n+  return crossing_edges;\n }\n \n /* If any destination of a crossing edge does not have a label, add label;\n@@ -2108,6 +2220,8 @@ partition_hot_cold_basic_blocks (void)\n   if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n     return 0;\n \n+  df_set_flags (DF_DEFER_INSN_RESCAN);\n+\n   crossing_edges = find_rarely_executed_basic_blocks_and_crossing_edges ();\n   if (crossing_edges == NULL)\n     return 0;\n@@ -2139,6 +2253,38 @@ partition_hot_cold_basic_blocks (void)\n \n   VEC_free (edge, heap, crossing_edges);\n \n+  /* ??? FIXME: DF generates the bb info for a block immediately.\n+     And by immediately, I mean *during* creation of the block.\n+\n+\t#0  df_bb_refs_collect\n+\t#1  in df_bb_refs_record\n+\t#2  in create_basic_block_structure\n+\n+     Which means that the bb_has_eh_pred test in df_bb_refs_collect\n+     will *always* fail, because no edges can have been added to the\n+     block yet.  Which of course means we don't add the right \n+     artificial refs, which means we fail df_verify (much) later.\n+\n+     Cleanest solution would seem to make DF_DEFER_INSN_RESCAN imply\n+     that we also shouldn't grab data from the new blocks those new\n+     insns are in either.  In this way one can create the block, link\n+     it up properly, and have everything Just Work later, when deferred\n+     insns are processed.\n+\n+     In the meantime, we have no other option but to throw away all\n+     of the DF data and recompute it all.  */\n+  if (cfun->eh->lp_array)\n+    {\n+      df_finish_pass (true);\n+      df_scan_alloc (NULL);\n+      df_scan_blocks ();\n+      /* Not all post-landing pads use all of the EH_RETURN_DATA_REGNO\n+\t data.  We blindly generated all of them when creating the new\n+\t landing pad.  Delete those assignments we don't use.  */\n+      df_set_flags (DF_LR_RUN_DCE);\n+      df_analyze ();\n+    }\n+\n   return TODO_verify_flow | TODO_verify_rtl_sharing;\n }\n \f"}, {"sha": "ca04c94770e71f2c789e60aa85ffc7ca2e31271e", "filename": "gcc/cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752", "patch": "@@ -720,7 +720,7 @@ dump_edge_info (FILE *file, edge e, int do_succ)\n       static const char * const bitnames[] = {\n \t\"fallthru\", \"ab\", \"abcall\", \"eh\", \"fake\", \"dfs_back\",\n \t\"can_fallthru\", \"irreducible\", \"sibcall\", \"loop_exit\",\n-\t\"true\", \"false\", \"exec\"\n+\t\"true\", \"false\", \"exec\", \"crossing\", \"preserve\"\n       };\n       int comma = 0;\n       int i, flags = e->flags;"}, {"sha": "076ff03d056cd46eb9b93a7ed1c75cf04c02753b", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752", "patch": "@@ -1820,18 +1820,38 @@ rtl_verify_flow_info_1 (void)\n \t}\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n+\t  bool is_crossing;\n+\n \t  if (e->flags & EDGE_FALLTHRU)\n+\t    n_fallthru++, fallthru = e;\n+\n+\t  is_crossing = (BB_PARTITION (e->src) != BB_PARTITION (e->dest)\n+\t\t\t && e->src != ENTRY_BLOCK_PTR\n+\t\t\t && e->dest != EXIT_BLOCK_PTR);\n+\t  if (e->flags & EDGE_CROSSING)\n \t    {\n-\t      n_fallthru++, fallthru = e;\n-\t      if ((e->flags & EDGE_CROSSING)\n-\t\t  || (BB_PARTITION (e->src) != BB_PARTITION (e->dest)\n-\t\t      && e->src != ENTRY_BLOCK_PTR\n-\t\t      && e->dest != EXIT_BLOCK_PTR))\n-\t    {\n+\t      if (!is_crossing)\n+\t\t{\n+\t\t  error (\"EDGE_CROSSING incorrectly set across same section\");\n+\t\t  err = 1;\n+\t\t}\n+\t      if (e->flags & EDGE_FALLTHRU)\n+\t\t{\n \t\t  error (\"fallthru edge crosses section boundary (bb %i)\",\n \t\t\t e->src->index);\n \t\t  err = 1;\n \t\t}\n+\t      if (e->flags & EDGE_EH)\n+\t\t{\n+\t\t  error (\"EH edge crosses section boundary (bb %i)\",\n+\t\t\t e->src->index);\n+\t\t  err = 1;\n+\t\t}\n+\t    }\n+\t  else if (is_crossing)\n+\t    {\n+\t      error (\"EDGE_CROSSING missing across section boundary\");\n+\t      err = 1;\n \t    }\n \n \t  if ((e->flags & ~(EDGE_DFS_BACK"}, {"sha": "8d56e105fbee8896a1e66b8c64b621f753825428", "filename": "gcc/except.c", "status": "modified", "additions": 38, "deletions": 128, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752", "patch": "@@ -919,17 +919,52 @@ emit_to_new_bb_before (rtx seq, rtx insn)\n   return bb;\n }\n \f\n+/* A subroutine of dw2_build_landing_pads, also used for edge splitting\n+   at the rtl level.  Emit the code required by the target at a landing\n+   pad for the given region.  */\n+\n+void\n+expand_dw2_landing_pad_for_region (eh_region region)\n+{\n+#ifdef HAVE_exception_receiver\n+  if (HAVE_exception_receiver)\n+    emit_insn (gen_exception_receiver ());\n+  else\n+#endif\n+#ifdef HAVE_nonlocal_goto_receiver\n+  if (HAVE_nonlocal_goto_receiver)\n+    emit_insn (gen_nonlocal_goto_receiver ());\n+  else\n+#endif\n+    { /* Nothing */ }\n+\n+  if (region->exc_ptr_reg)\n+    emit_move_insn (region->exc_ptr_reg,\n+\t\t    gen_rtx_REG (ptr_mode, EH_RETURN_DATA_REGNO (0)));\n+  if (region->filter_reg)\n+    emit_move_insn (region->filter_reg,\n+\t\t    gen_rtx_REG (targetm.eh_return_filter_mode (),\n+\t\t\t\t EH_RETURN_DATA_REGNO (1)));\n+}\n+\n /* Expand the extra code needed at landing pads for dwarf2 unwinding.  */\n \n static void\n dw2_build_landing_pads (void)\n {\n   int i;\n   eh_landing_pad lp;\n+  int e_flags = EDGE_FALLTHRU;\n+\n+  /* If we're going to partition blocks, we need to be able to add\n+     new landing pads later, which means that we need to hold on to\n+     the post-landing-pad block.  Prevent it from being merged away.\n+     We'll remove this bit after partitioning.  */\n+  if (flag_reorder_blocks_and_partition)\n+    e_flags |= EDGE_PRESERVE;\n \n   for (i = 1; VEC_iterate (eh_landing_pad, cfun->eh->lp_array, i, lp); ++i)\n     {\n-      eh_region region;\n       basic_block bb;\n       rtx seq;\n       edge e;\n@@ -943,32 +978,13 @@ dw2_build_landing_pads (void)\n       emit_label (lp->landing_pad);\n       LABEL_PRESERVE_P (lp->landing_pad) = 1;\n \n-#ifdef HAVE_exception_receiver\n-      if (HAVE_exception_receiver)\n-\temit_insn (gen_exception_receiver ());\n-      else\n-#endif\n-#ifdef HAVE_nonlocal_goto_receiver\n-\tif (HAVE_nonlocal_goto_receiver)\n-\t  emit_insn (gen_nonlocal_goto_receiver ());\n-\telse\n-#endif\n-\t  { /* Nothing */ }\n-\n-      region = lp->region;\n-      if (region->exc_ptr_reg)\n-\temit_move_insn (region->exc_ptr_reg,\n-\t\t\tgen_rtx_REG (ptr_mode, EH_RETURN_DATA_REGNO (0)));\n-      if (region->filter_reg)\n-\temit_move_insn (region->filter_reg,\n-\t\t\tgen_rtx_REG (targetm.eh_return_filter_mode (),\n-\t\t\t\t     EH_RETURN_DATA_REGNO (1)));\n+      expand_dw2_landing_pad_for_region (lp->region);\n \n       seq = get_insns ();\n       end_sequence ();\n \n       bb = emit_to_new_bb_before (seq, label_rtx (lp->post_landing_pad));\n-      e = make_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n+      e = make_edge (bb, bb->next_bb, e_flags);\n       e->count = bb->count;\n       e->probability = REG_BR_PROB_BASE;\n     }\n@@ -2388,9 +2404,6 @@ convert_to_eh_region_ranges (void)\n   rtx section_switch_note = NULL_RTX;\n   rtx first_no_action_insn_before_switch = NULL_RTX;\n   rtx last_no_action_insn_before_switch = NULL_RTX;\n-  rtx *pad_map = NULL;\n-  sbitmap pad_loc = NULL;\n-  int min_labelno = 0, max_labelno = 0;\n   int saved_call_site_base = call_site_base;\n \n   crtl->eh.action_record_data = VEC_alloc (uchar, gc, 64);\n@@ -2523,13 +2536,7 @@ convert_to_eh_region_ranges (void)\n \tgcc_assert (crtl->eh.call_site_record[cur_sec] == NULL);\n \tcrtl->eh.call_site_record[cur_sec]\n \t  = VEC_alloc (call_site_record, gc, 10);\n-\tmax_labelno = max_label_num ();\n-\tmin_labelno = get_first_label_num ();\n-\tpad_map = XCNEWVEC (rtx, max_labelno - min_labelno + 1);\n-\tpad_loc = sbitmap_alloc (max_labelno - min_labelno + 1);\n       }\n-    else if (LABEL_P (iter) && pad_map)\n-      SET_BIT (pad_loc, CODE_LABEL_NUMBER (iter) - min_labelno);\n \n   if (last_action >= -1 && ! first_no_action_insn)\n     {\n@@ -2539,103 +2546,6 @@ convert_to_eh_region_ranges (void)\n \n   call_site_base = saved_call_site_base;\n \n-  if (pad_map)\n-    {\n-      /* When doing hot/cold partitioning, ensure landing pads are\n-\t always in the same section as the EH region, .gcc_except_table\n-\t can't express it otherwise.  */\n-      for (cur_sec = 0; cur_sec < 2; cur_sec++)\n-\t{\n-\t  int i, idx;\n-\t  int n = VEC_length (call_site_record,\n-\t\t\t      crtl->eh.call_site_record[cur_sec]);\n-\t  basic_block prev_bb = NULL, padbb;\n-\n-\t  for (i = 0; i < n; ++i)\n-\t    {\n-\t      struct call_site_record_d *cs =\n-\t\tVEC_index (call_site_record,\n-\t\t\t   crtl->eh.call_site_record[cur_sec], i);\n-\t      rtx jump, note;\n-\n-\t      if (cs->landing_pad == NULL_RTX)\n-\t\tcontinue;\n-\t      idx = CODE_LABEL_NUMBER (cs->landing_pad) - min_labelno;\n-\t      /* If the landing pad is in the correct section, nothing\n-\t\t is needed.  */\n-\t      if (TEST_BIT (pad_loc, idx) ^ (cur_sec == 0))\n-\t\tcontinue;\n-\t      /* Otherwise, if we haven't seen this pad yet, we need to\n-\t\t add a new label and jump to the correct section.  */\n-\t      if (pad_map[idx] == NULL_RTX)\n-\t\t{\n-\t\t  pad_map[idx] = gen_label_rtx ();\n-\t\t  if (prev_bb == NULL)\n-\t\t    for (iter = section_switch_note;\n-\t\t\t iter; iter = PREV_INSN (iter))\n-\t\t      if (NOTE_INSN_BASIC_BLOCK_P (iter))\n-\t\t\t{\n-\t\t\t  prev_bb = NOTE_BASIC_BLOCK (iter);\n-\t\t\t  break;\n-\t\t\t}\n-\t\t  if (cur_sec == 0)\n-\t\t    {\n-\t\t      note = emit_label_before (pad_map[idx],\n-\t\t\t\t\t\tsection_switch_note);\n-\t\t      jump = emit_jump_insn_before (gen_jump (cs->landing_pad),\n-\t\t\t\t\t\t    section_switch_note);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      jump = emit_jump_insn_after (gen_jump (cs->landing_pad),\n-\t\t\t\t\t\t   section_switch_note);\n-\t\t      note = emit_label_after (pad_map[idx],\n-\t\t\t\t\t       section_switch_note);\n-\t\t    }\n-\t\t  JUMP_LABEL (jump) = cs->landing_pad;\n-\t\t  add_reg_note (jump, REG_CROSSING_JUMP, NULL_RTX);\n-\t\t  iter = NEXT_INSN (cs->landing_pad);\n-\t\t  if (iter && NOTE_INSN_BASIC_BLOCK_P (iter))\n-\t\t    padbb = NOTE_BASIC_BLOCK (iter);\n-\t\t  else\n-\t\t    padbb = NULL;\n-\t\t  if (padbb && prev_bb\n-\t\t      && BB_PARTITION (padbb) != BB_UNPARTITIONED)\n-\t\t    {\n-\t\t      basic_block bb;\n-\t\t      int part\n-\t\t\t= BB_PARTITION (padbb) == BB_COLD_PARTITION\n-\t\t\t  ? BB_HOT_PARTITION : BB_COLD_PARTITION;\n-\t\t      edge_iterator ei;\n-\t\t      edge e;\n-\n-\t\t      bb = create_basic_block (note, jump, prev_bb);\n-\t\t      make_single_succ_edge (bb, padbb, EDGE_CROSSING);\n-\t\t      BB_SET_PARTITION (bb, part);\n-\t\t      for (ei = ei_start (padbb->preds);\n-\t\t\t   (e = ei_safe_edge (ei)); )\n-\t\t\t{\n-\t\t\t  if ((e->flags & (EDGE_EH|EDGE_CROSSING))\n-\t\t\t      == (EDGE_EH|EDGE_CROSSING))\n-\t\t\t    {\n-\t\t\t      redirect_edge_succ (e, bb);\n-\t\t\t      e->flags &= ~EDGE_CROSSING;\n-\t\t\t    }\n-\t\t\t  else\n-\t\t\t    ei_next (&ei);\n-\t\t\t}\n-\t\t      if (cur_sec == 0)\n-\t\t\tprev_bb = bb;\n-\t\t    }\n-\t\t}\n-\t      cs->landing_pad = pad_map[idx];\n-\t    }\n-\t}\n-\n-      sbitmap_free (pad_loc);\n-      XDELETEVEC (pad_map);\n-    }\n-\n   htab_delete (ar_hash);\n   return 0;\n }"}, {"sha": "5d461d7000b651e1016561a8f2e44ffeccf487f9", "filename": "gcc/except.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752", "patch": "@@ -253,6 +253,7 @@ extern rtx expand_builtin_dwarf_sp_column (void);\n extern void expand_builtin_eh_return (tree, tree);\n extern void expand_eh_return (void);\n extern rtx expand_builtin_extend_pointer (tree);\n+extern void expand_dw2_landing_pad_for_region (eh_region);\n \n typedef tree (*duplicate_eh_regions_map) (tree, void *);\n extern struct pointer_map_t *duplicate_eh_regions"}, {"sha": "120790819140512995864cd4e3d014856e28b2ae", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752", "patch": "@@ -1421,7 +1421,7 @@ gimple_can_merge_blocks_p (basic_block a, basic_block b)\n   if (!single_succ_p (a))\n     return false;\n \n-  if (single_succ_edge (a)->flags & (EDGE_ABNORMAL | EDGE_EH))\n+  if (single_succ_edge (a)->flags & (EDGE_ABNORMAL | EDGE_EH | EDGE_PRESERVE))\n     return false;\n \n   if (single_succ (a) != b)"}]}