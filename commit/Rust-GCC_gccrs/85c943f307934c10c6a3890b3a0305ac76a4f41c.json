{"sha": "85c943f307934c10c6a3890b3a0305ac76a4f41c", "node_id": "C_kwDOANBUbNoAKDg1Yzk0M2YzMDc5MzRjMTBjNmEzODkwYjNhMDMwNWFjNzZhNGY0MWM", "commit": {"author": {"name": "marxin", "email": "mliska@suse.cz", "date": "2022-07-25T12:39:46Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2022-07-28T10:37:03Z"}, "message": "jit,docs: use :expr:`type *` for pointers to a type\n\ngcc/jit/ChangeLog:\n\n\t* docs/cp/intro/tutorial02.rst: Use :expr:`type *` for pointers to a type\n\t* docs/cp/topics/asm.rst: Likewise.\n\t* docs/cp/topics/contexts.rst: Likewise.\n\t* docs/cp/topics/expressions.rst: Likewise.\n\t* docs/cp/topics/functions.rst: Likewise.\n\t* docs/cp/topics/objects.rst: Likewise.\n\t* docs/intro/tutorial02.rst: Likewise.\n\t* docs/intro/tutorial03.rst: Likewise.\n\t* docs/intro/tutorial04.rst: Likewise.\n\t* docs/intro/tutorial05.rst: Likewise.\n\t* docs/topics/compilation.rst: Likewise.\n\t* docs/topics/contexts.rst: Likewise.\n\t* docs/topics/objects.rst: Likewise.", "tree": {"sha": "0866ddfcacb866146e8d9ede0e920a706d40b8f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0866ddfcacb866146e8d9ede0e920a706d40b8f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85c943f307934c10c6a3890b3a0305ac76a4f41c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85c943f307934c10c6a3890b3a0305ac76a4f41c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85c943f307934c10c6a3890b3a0305ac76a4f41c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85c943f307934c10c6a3890b3a0305ac76a4f41c/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85cf5a23772ee14b1b19320f19a4749f874854d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85cf5a23772ee14b1b19320f19a4749f874854d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85cf5a23772ee14b1b19320f19a4749f874854d7"}], "stats": {"total": 90, "additions": 45, "deletions": 45}, "files": [{"sha": "9f9a7f3858e309c783e2f31bc9e0bc0e762c9e4f", "filename": "gcc/jit/docs/cp/intro/tutorial02.rst", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fcp%2Fintro%2Ftutorial02.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fcp%2Fintro%2Ftutorial02.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Fintro%2Ftutorial02.rst?ref=85c943f307934c10c6a3890b3a0305ac76a4f41c", "patch": "@@ -39,7 +39,7 @@ First we need to include the relevant header:\n \n All state associated with compilation is associated with a\n :type:`gccjit::context`, which is a thin C++ wrapper around the C API's\n-:c:type:`gcc_jit_context *`.\n+:c:expr:`gcc_jit_context *`.\n \n Create one using :func:`gccjit::context::acquire`:\n \n@@ -194,7 +194,7 @@ OK, we've populated the context.  We can now compile it using\n    gcc_jit_result *result;\n    result = ctxt.compile ();\n \n-and get a :c:type:`gcc_jit_result *`.\n+and get a :c:expr:`gcc_jit_result *`.\n \n We can now use :c:func:`gcc_jit_result_get_code` to look up a specific\n machine code routine within the result, in this case, the function we"}, {"sha": "0d63da3d59e823a55fc9afe450fb41ee9d87d286", "filename": "gcc/jit/docs/cp/topics/asm.rst", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fasm.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fasm.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fasm.rst?ref=85c943f307934c10c6a3890b3a0305ac76a4f41c", "patch": "@@ -43,7 +43,7 @@ Adding assembler instructions within a function\n    to outputs.\n \n    :class:`gccjit::extended_asm` is a subclass of :class:`gccjit::object`.\n-   It is a thin wrapper around the C API's :c:type:`gcc_jit_extended_asm *`.\n+   It is a thin wrapper around the C API's :c:expr:`gcc_jit_extended_asm *`.\n \n    To avoid having an API entrypoint with a very large number of\n    parameters, an extended ``asm`` statement is made in stages:"}, {"sha": "2f2456a9c0d583fdfe055da00b0bfba78dba5ab0", "filename": "gcc/jit/docs/cp/topics/contexts.rst", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fcontexts.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fcontexts.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fcontexts.rst?ref=85c943f307934c10c6a3890b3a0305ac76a4f41c", "patch": "@@ -29,9 +29,9 @@ compilation.\n \n You can set up options on it, and add types, functions and code.\n Invoking :func:`gccjit::context::compile` on it gives you a\n-:c:type:`gcc_jit_result *`.\n+:c:expr:`gcc_jit_result *`.\n \n-It is a thin wrapper around the C API's :c:type:`gcc_jit_context *`.\n+It is a thin wrapper around the C API's :c:expr:`gcc_jit_context *`.\n \n Lifetime-management\n -------------------\n@@ -48,7 +48,7 @@ cleanup of such objects is done for you when the context is released.\n .. function:: void gccjit::context::release ()\n \n   This function releases all resources associated with the given context.\n-  Both the context itself and all of its :c:type:`gccjit::object *`\n+  Both the context itself and all of its :expr:`gccjit::object *`\n   instances are cleaned up.  It should be called exactly once on a given\n   context.\n "}, {"sha": "01eb2898d0db4d838685cd87b1bee22a4ba564b1", "filename": "gcc/jit/docs/cp/topics/expressions.rst", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fexpressions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fexpressions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fexpressions.rst?ref=85c943f307934c10c6a3890b3a0305ac76a4f41c", "patch": "@@ -26,7 +26,7 @@ Rvalues\n \n A :class:`gccjit::rvalue` is an expression that can be computed.  It is a\n subclass of :class:`gccjit::object`, and is a thin wrapper around\n-:c:type:`gcc_jit_rvalue *` from the C API.\n+:c:expr:`gcc_jit_rvalue *` from the C API.\n \n It can be simple, e.g.:\n \n@@ -491,7 +491,7 @@ a storage area (such as a variable).  It is a subclass of\n :class:`gccjit::rvalue`, where the rvalue is computed by reading from the\n storage area.\n \n-It iss a thin wrapper around :c:type:`gcc_jit_lvalue *` from the C API.\n+It iss a thin wrapper around :c:expr:`gcc_jit_lvalue *` from the C API.\n \n .. function:: gccjit::rvalue \\\n               gccjit::lvalue::get_address (gccjit::location loc)"}, {"sha": "24534cc5d4f9cdbde7005fddca58344f0a016758", "filename": "gcc/jit/docs/cp/topics/functions.rst", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Ffunctions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Ffunctions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Ffunctions.rst?ref=85c943f307934c10c6a3890b3a0305ac76a4f41c", "patch": "@@ -36,7 +36,7 @@ Params\n \n :class:`gccjit::param` is a subclass of :class:`gccjit::lvalue` (and thus\n of :class:`gccjit::rvalue` and :class:`gccjit::object`).  It is a thin\n-wrapper around the C API's :c:type:`gcc_jit_param *`.\n+wrapper around the C API's :c:expr:`gcc_jit_param *`.\n \n Functions\n ---------"}, {"sha": "ca9243b1c71089ac83ef5ef5921027b778268373", "filename": "gcc/jit/docs/cp/topics/objects.rst", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fobjects.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fobjects.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fobjects.rst?ref=85c943f307934c10c6a3890b3a0305ac76a4f41c", "patch": "@@ -23,7 +23,7 @@ Objects\n .. class:: gccjit::object\n \n Almost every entity in the API (with the exception of\n-:class:`gccjit::context` and :c:type:`gcc_jit_result *`) is a\n+:class:`gccjit::context` and :c:expr:`gcc_jit_result *`) is a\n \"contextual\" object, a :class:`gccjit::object`.\n \n A JIT object:"}, {"sha": "9fcaad5518cecf64aa805edc236ca9e49808ddcd", "filename": "gcc/jit/docs/intro/tutorial02.rst", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial02.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial02.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial02.rst?ref=85c943f307934c10c6a3890b3a0305ac76a4f41c", "patch": "@@ -38,7 +38,7 @@ First we need to include the relevant header:\n   #include <libgccjit.h>\n \n All state associated with compilation is associated with a\n-:c:type:`gcc_jit_context *`.\n+:c:expr:`gcc_jit_context *`.\n \n Create one using :c:func:`gcc_jit_context_acquire`:\n \n@@ -50,16 +50,16 @@ Create one using :c:func:`gcc_jit_context_acquire`:\n The JIT library has a system of types.  It is statically-typed: every\n expression is of a specific type, fixed at compile-time.  In our example,\n all of the expressions are of the C `int` type, so let's obtain this from\n-the context, as a :c:type:`gcc_jit_type *`, using\n+the context, as a :c:expr:`gcc_jit_type *`, using\n :c:func:`gcc_jit_context_get_type`:\n \n .. code-block:: c\n \n   gcc_jit_type *int_type =\n     gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n \n-:c:type:`gcc_jit_type *` is an example of a \"contextual\" object: every\n-entity in the API is associated with a :c:type:`gcc_jit_context *`.\n+:c:expr:`gcc_jit_type *` is an example of a \"contextual\" object: every\n+entity in the API is associated with a :c:expr:`gcc_jit_context *`.\n \n Memory management is easy: all such \"contextual\" objects are automatically\n cleaned up for you when the context is released, using\n@@ -93,7 +93,7 @@ For example, :c:func:`gcc_jit_type_as_object`:\n \n    gcc_jit_object *obj = gcc_jit_type_as_object (int_type);\n \n-One thing you can do with a :c:type:`gcc_jit_object *` is\n+One thing you can do with a :c:expr:`gcc_jit_object *` is\n to ask it for a human-readable description, using\n :c:func:`gcc_jit_object_get_debug_string`:\n \n@@ -157,8 +157,8 @@ We can build the expression using :c:func:`gcc_jit_context_new_binary_op`:\n        gcc_jit_param_as_rvalue (param_i),\n        gcc_jit_param_as_rvalue (param_i));\n \n-A :c:type:`gcc_jit_rvalue *` is another example of a\n-:c:type:`gcc_jit_object *` subclass.  We can upcast it using\n+A :c:expr:`gcc_jit_rvalue *` is another example of a\n+:c:expr:`gcc_jit_object *` subclass.  We can upcast it using\n :c:func:`gcc_jit_rvalue_as_object` and as before print it with\n :c:func:`gcc_jit_object_get_debug_string`.\n \n@@ -190,7 +190,7 @@ OK, we've populated the context.  We can now compile it using\n    gcc_jit_result *result;\n    result = gcc_jit_context_compile (ctxt);\n \n-and get a :c:type:`gcc_jit_result *`.\n+and get a :c:expr:`gcc_jit_result *`.\n \n At this point we're done with the context; we can release it:\n "}, {"sha": "478ea2721de6e805a2748b650a4432469c8fd152", "filename": "gcc/jit/docs/intro/tutorial03.rst", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial03.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial03.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial03.rst?ref=85c943f307934c10c6a3890b3a0305ac76a4f41c", "patch": "@@ -55,7 +55,7 @@ Here's what the final control flow graph will look like:\n       :alt: image of a control flow graph\n \n As before, we include the libgccjit header and make a\n-:c:type:`gcc_jit_context *`.\n+:c:expr:`gcc_jit_context *`.\n \n .. code-block:: c\n \n@@ -98,14 +98,14 @@ Let's build the function:\n Expressions: lvalues and rvalues\n ********************************\n \n-The base class of expression is the :c:type:`gcc_jit_rvalue *`,\n+The base class of expression is the :c:expr:`gcc_jit_rvalue *`,\n representing an expression that can be on the *right*-hand side of\n an assignment: a value that can be computed somehow, and assigned\n *to* a storage area (such as a variable).  It has a specific\n-:c:type:`gcc_jit_type *`.\n+:c:expr:`gcc_jit_type *`.\n \n-Anothe important class is :c:type:`gcc_jit_lvalue *`.\n-A :c:type:`gcc_jit_lvalue *`. is something that can of the *left*-hand\n+Anothe important class is :c:expr:`gcc_jit_lvalue *`.\n+A :c:expr:`gcc_jit_lvalue *`. is something that can of the *left*-hand\n side of an assignment: a storage area (such as a variable).\n \n In other words, every assignment can be thought of as:\n@@ -114,8 +114,8 @@ In other words, every assignment can be thought of as:\n \n    LVALUE = RVALUE;\n \n-Note that :c:type:`gcc_jit_lvalue *` is a subclass of\n-:c:type:`gcc_jit_rvalue *`, where in an assignment of the form:\n+Note that :c:expr:`gcc_jit_lvalue *` is a subclass of\n+:c:expr:`gcc_jit_rvalue *`, where in an assignment of the form:\n \n .. code-block:: c\n \n@@ -135,10 +135,10 @@ So far the only expressions we've seen are `i * i`:\n        gcc_jit_param_as_rvalue (param_i),\n        gcc_jit_param_as_rvalue (param_i));\n \n-which is a :c:type:`gcc_jit_rvalue *`, and the various function\n+which is a :c:expr:`gcc_jit_rvalue *`, and the various function\n parameters: `param_i` and `param_n`, instances of\n-:c:type:`gcc_jit_param *`, which is a subclass of\n-:c:type:`gcc_jit_lvalue *` (and, in turn, of :c:type:`gcc_jit_rvalue *`):\n+:c:expr:`gcc_jit_param *`, which is a subclass of\n+:c:expr:`gcc_jit_lvalue *` (and, in turn, of :c:expr:`gcc_jit_rvalue *`):\n we can both read from and write to function parameters within the\n body of a function.\n \n@@ -154,7 +154,7 @@ name:\n   gcc_jit_lvalue *sum =\n     gcc_jit_function_new_local (func, NULL, the_type, \"sum\");\n \n-These are instances of :c:type:`gcc_jit_lvalue *` - they can be read from\n+These are instances of :c:expr:`gcc_jit_lvalue *` - they can be read from\n and written to.\n \n Note that there is no precanned way to create *and* initialize a variable\n@@ -178,8 +178,8 @@ handle the control flow.  In this case, we need 4 blocks:\n 3. the body of the loop\n 4. after the loop terminates (`return sum`)\n \n-so we create these as :c:type:`gcc_jit_block *` instances within the\n-:c:type:`gcc_jit_function *`:\n+so we create these as :c:expr:`gcc_jit_block *` instances within the\n+:c:expr:`gcc_jit_function *`:\n \n .. code-block:: c\n \n@@ -224,7 +224,7 @@ We can then terminate the entry block by jumping to the conditional:\n The conditional block is equivalent to the line `while (i < n)` from our\n C example. It contains a single statement: a conditional, which jumps to\n one of two destination blocks depending on a boolean\n-:c:type:`gcc_jit_rvalue *`, in this case the comparison of `i` and `n`.\n+:c:expr:`gcc_jit_rvalue *`, in this case the comparison of `i` and `n`.\n We build the comparison using :c:func:`gcc_jit_context_new_comparison`:\n \n .. code-block:: c"}, {"sha": "a08119f51b13e0be4a65aef4fe2e9329bfa0a7cf", "filename": "gcc/jit/docs/intro/tutorial04.rst", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial04.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial04.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial04.rst?ref=85c943f307934c10c6a3890b3a0305ac76a4f41c", "patch": "@@ -126,7 +126,7 @@ then directly executed in-process:\n     :end-before: enum opcode\n     :language: c\n \n-The lifetime of the code is tied to that of a :c:type:`gcc_jit_result *`.\n+The lifetime of the code is tied to that of a :c:expr:`gcc_jit_result *`.\n We'll handle this by bundling them up in a structure, so that we can\n clean them up together by calling :c:func:`gcc_jit_result_release`:\n "}, {"sha": "1c4774486be7698c9e7b5541c400fc95e3169474", "filename": "gcc/jit/docs/intro/tutorial05.rst", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial05.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial05.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fintro%2Ftutorial05.rst?ref=85c943f307934c10c6a3890b3a0305ac76a4f41c", "patch": "@@ -95,7 +95,7 @@ Here's what a simple ``.bf`` script looks like:\n Converting a brainf script to libgccjit IR\n ******************************************\n \n-As before we write simple code to populate a :c:type:`gcc_jit_context *`.\n+As before we write simple code to populate a :c:expr:`gcc_jit_context *`.\n \n    .. literalinclude:: ../examples/tut05-bf.c\n     :start-after: #define MAX_OPEN_PARENS 16\n@@ -261,7 +261,7 @@ state ``idx`` and ``data_cells``:\n Other forms of ahead-of-time-compilation\n ****************************************\n \n-The above demonstrates compiling a :c:type:`gcc_jit_context *` directly\n+The above demonstrates compiling a :c:expr:`gcc_jit_context *` directly\n to an executable.  It's also possible to compile it to an object file,\n and to a dynamic library.  See the documentation of\n :c:func:`gcc_jit_context_compile_to_file` for more information."}, {"sha": "3dd9bc6f5f72e84e4dd63d795d3b27f5167a6196", "filename": "gcc/jit/docs/topics/compilation.rst", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompilation.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompilation.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompilation.rst?ref=85c943f307934c10c6a3890b3a0305ac76a4f41c", "patch": "@@ -20,7 +20,7 @@\n Compiling a context\n ===================\n \n-Once populated, a :c:type:`gcc_jit_context *` can be compiled to\n+Once populated, a :c:expr:`gcc_jit_context *` can be compiled to\n machine code, either in-memory via :c:func:`gcc_jit_context_compile` or\n to disk via :c:func:`gcc_jit_context_compile_to_file`.\n \n@@ -80,7 +80,7 @@ In-memory compilation\n \n    Note that the resulting machine code becomes invalid after\n    :func:`gcc_jit_result_release` is called on the\n-   :type:`gcc_jit_result *`; attempting to call it after that may lead\n+   :expr:`gcc_jit_result *`; attempting to call it after that may lead\n    to a segmentation fault.\n \n .. function:: void *\\\n@@ -125,7 +125,7 @@ In-memory compilation\n \n    Note that the resulting address becomes invalid after\n    :func:`gcc_jit_result_release` is called on the\n-   :type:`gcc_jit_result *`; attempting to use it after that may lead\n+   :expr:`gcc_jit_result *`; attempting to use it after that may lead\n    to a segmentation fault.\n \n .. function:: void\\\n@@ -153,7 +153,7 @@ For linking in object files, use :c:func:`gcc_jit_context_add_driver_option`.\n                                                enum gcc_jit_output_kind output_kind,\\\n                                                const char *output_path)\n \n-   Compile the :c:type:`gcc_jit_context *` to a file of the given\n+   Compile the :c:expr:`gcc_jit_context *` to a file of the given\n    kind.\n \n :c:func:`gcc_jit_context_compile_to_file` ignores the suffix of"}, {"sha": "f746e2819d2b8f0d568ec9c4a93fa743713d8902", "filename": "gcc/jit/docs/topics/contexts.rst", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst?ref=85c943f307934c10c6a3890b3a0305ac76a4f41c", "patch": "@@ -39,14 +39,14 @@ cleanup of such objects is done for you when the context is released.\n \n .. function:: gcc_jit_context *gcc_jit_context_acquire (void)\n \n-  This function acquires a new :c:type:`gcc_jit_context *` instance,\n+  This function acquires a new :c:expr:`gcc_jit_context *` instance,\n   which is independent of any others that may be present within this\n   process.\n \n .. function:: void gcc_jit_context_release (gcc_jit_context *ctxt)\n \n   This function releases all resources associated with the given context.\n-  Both the context itself and all of its :c:type:`gcc_jit_object *`\n+  Both the context itself and all of its :c:expr:`gcc_jit_object *`\n   instances are cleaned up.  It should be called exactly once on a given\n   context.\n \n@@ -89,7 +89,7 @@ cleanup of such objects is done for you when the context is released.\n \n Thread-safety\n -------------\n-Instances of :c:type:`gcc_jit_context *` created via\n+Instances of :c:expr:`gcc_jit_context *` created via\n :c:func:`gcc_jit_context_acquire` are independent from each other:\n only one thread may use a given context at once, but multiple threads\n could each have their own contexts without needing locks."}, {"sha": "42f3675cd1accbed8e8aaf6b230808d27431b7c7", "filename": "gcc/jit/docs/topics/objects.rst", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Ftopics%2Fobjects.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c943f307934c10c6a3890b3a0305ac76a4f41c/gcc%2Fjit%2Fdocs%2Ftopics%2Fobjects.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fobjects.rst?ref=85c943f307934c10c6a3890b3a0305ac76a4f41c", "patch": "@@ -23,12 +23,12 @@ Objects\n .. type:: gcc_jit_object\n \n Almost every entity in the API (with the exception of\n-:c:type:`gcc_jit_context *` and :c:type:`gcc_jit_result *`) is a\n-\"contextual\" object, a :c:type:`gcc_jit_object *`\n+:c:expr:`gcc_jit_context *` and :c:expr:`gcc_jit_result *`) is a\n+\"contextual\" object, a :c:expr:`gcc_jit_object *`\n \n A JIT object:\n \n-  * is associated with a :c:type:`gcc_jit_context *`.\n+  * is associated with a :c:expr:`gcc_jit_context *`.\n \n   * is automatically cleaned up for you when its context is released so\n     you don't need to manually track and cleanup all objects, just the"}]}