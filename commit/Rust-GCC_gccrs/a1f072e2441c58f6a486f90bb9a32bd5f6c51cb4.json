{"sha": "a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFmMDcyZTI0NDFjNThmNmE0ODZmOTBiYjlhMzJiZDVmNmM1MWNiNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-10-26T07:38:59Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-10-26T07:38:59Z"}, "message": "re PR tree-optimization/87105 (Autovectorization [X86, SSE2, AVX2, DoublePrecision])\n\n2018-10-26  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/87105\n\t* tree-vectorizer.h (_slp_tree::refcnt): New member.\n\t* tree-vect-slp.c (vect_free_slp_tree): Decrement and honor\n\trefcnt.\n\t(vect_create_new_slp_node): Initialize refcnt to one.\n\t(bst_traits): Move.\n\t(scalar_stmts_set_t, bst_fail): Remove.\n\t(vect_build_slp_tree_2): Add bst_map argument and adjust calls.\n\t(vect_build_slp_tree): Add bst_map argument and lookup\n\talready created SLP nodes.\n\t(vect_print_slp_tree): Handle a SLP graph, print SLP node\n\taddresses.\n\t(vect_slp_rearrange_stmts): Handle a SLP graph.\n\t(vect_analyze_slp_instance): Adjust and free SLP nodes from\n\tthe CSE map.  Fix indenting.\n\t(vect_schedule_slp_instance): Add short-cut.\n\n\t* g++.dg/vect/slp-pr87105.cc: Adjust.\n\t* gcc.dg/torture/20181024-1.c: New testcase.\n\t* g++.dg/opt/20181025-1.C: Likewise.\n\nFrom-SVN: r265522", "tree": {"sha": "9d618aa607519185f0bde590ce1b6b862c7ff3b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d618aa607519185f0bde590ce1b6b862c7ff3b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "74ca1c01d02e548f32aa26f9a887dcc0730703fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74ca1c01d02e548f32aa26f9a887dcc0730703fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74ca1c01d02e548f32aa26f9a887dcc0730703fb"}], "stats": {"total": 390, "additions": 263, "deletions": 127}, "files": [{"sha": "d46a3b47a55718865bbfab3117655f752a02347e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4", "patch": "@@ -1,3 +1,22 @@\n+2018-10-26  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/87105\n+\t* tree-vectorizer.h (_slp_tree::refcnt): New member.\n+\t* tree-vect-slp.c (vect_free_slp_tree): Decrement and honor\n+\trefcnt.\n+\t(vect_create_new_slp_node): Initialize refcnt to one.\n+\t(bst_traits): Move.\n+\t(scalar_stmts_set_t, bst_fail): Remove.\n+\t(vect_build_slp_tree_2): Add bst_map argument and adjust calls.\n+\t(vect_build_slp_tree): Add bst_map argument and lookup\n+\talready created SLP nodes.\n+\t(vect_print_slp_tree): Handle a SLP graph, print SLP node\n+\taddresses.\n+\t(vect_slp_rearrange_stmts): Handle a SLP graph.\n+\t(vect_analyze_slp_instance): Adjust and free SLP nodes from\n+\tthe CSE map.  Fix indenting.\n+\t(vect_schedule_slp_instance): Add short-cut.\n+\n 2018-10-26  Martin Liska  <mliska@suse.cz>\n \n \tPR testsuite/86158"}, {"sha": "36627afeaa366622f736644bed60ece0ca415e80", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4", "patch": "@@ -1,3 +1,10 @@\n+2018-10-26  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/87105\n+\t* g++.dg/vect/slp-pr87105.cc: Adjust.\n+\t* gcc.dg/torture/20181024-1.c: New testcase.\n+\t* g++.dg/opt/20181025-1.C: Likewise.\n+\n 2018-10-26  Richard Biener  <rguenther@suse.de>\n \n \tPR testsuite/87754"}, {"sha": "43d1614f02305f00bb7f6de36e1cda3c8076519f", "filename": "gcc/testsuite/g++.dg/opt/20181025-1.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2F20181025-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2F20181025-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2F20181025-1.C?ref=a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4", "patch": "@@ -0,0 +1,31 @@\n+// { dg-do compile }\n+// { dg-options \"-Ofast\" }\n+\n+template <typename Number>\n+class Vector {\n+    typedef Number value_type;\n+    typedef const value_type *const_iterator;\n+    Number norm_sqr () const;\n+    const_iterator begin () const;\n+    unsigned int dim;\n+};\n+template <typename Number>\n+static inline Number\n+local_sqr (const Number x)\n+{\n+  return x*x;\n+}\n+template <typename Number>\n+Number\n+Vector<Number>::norm_sqr () const\n+{\n+  Number sum0 = 0, sum1 = 0, sum2 = 0, sum3 = 0;\n+  const_iterator ptr = begin(), eptr = ptr + (dim/4)*4;\n+  while (ptr!=eptr) \n+    {\n+      sum0 += ::local_sqr(*ptr++);\n+      sum1 += ::local_sqr(*ptr++);\n+    }\n+  return sum0+sum1+sum2+sum3;\n+}\n+template class Vector<double>;"}, {"sha": "949b16c848f6717c04b35beaeafadf7f211f03ce", "filename": "gcc/testsuite/g++.dg/vect/slp-pr87105.cc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fslp-pr87105.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fslp-pr87105.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fslp-pr87105.cc?ref=a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4", "patch": "@@ -2,7 +2,7 @@\n // { dg-require-effective-target c++11 }\n // { dg-require-effective-target vect_double }\n // For MIN/MAX recognition\n-// { dg-additional-options \"-ffast-math -fvect-cost-model\" }\n+// { dg-additional-options \"-ffast-math\" }\n \n #include <algorithm>\n #include <cmath>\n@@ -99,6 +99,7 @@ void quadBoundingBoxA(const Point bez[3], Box& bBox) noexcept {\n \n // We should have if-converted everything down to straight-line code\n // { dg-final { scan-tree-dump-times \"<bb \\[0-9\\]+>\" 1 \"slp2\" } }\n-// We fail to elide an earlier store which makes us not handle a later\n-// duplicate one for vectorization.\n-// { dg-final { scan-tree-dump-times \"basic block part vectorized\" 1 \"slp2\" { xfail *-*-* } } }\n+// { dg-final { scan-tree-dump-times \"basic block part vectorized\" 1 \"slp2\" } }\n+// It's a bit awkward to detect that all stores were vectorized but the\n+// following more or less does the trick\n+// { dg-final { scan-tree-dump \"vect_iftmp\\[^\\r\\m\\]* = MIN\" \"slp2\" } }"}, {"sha": "f2cfe7f6d67b2286e07f36ee3fc258dee8b42dfa", "filename": "gcc/testsuite/gcc.dg/torture/20181024-1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20181024-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20181024-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20181024-1.c?ref=a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-march=core-avx2\" { target { x86_64-*-* i?86-*-* } } } */\n+\n+typedef enum {\n+ C = 0,               N, S, E, W, T, B,               NE, NW, SE, SW,               NT, NB, ST, SB,               ET, EB, WT, WB,               FLAGS, N_CELL_ENTRIES} CELL_ENTRIES;\n+typedef double LBM_Grid[(130)*100*100*N_CELL_ENTRIES];\n+void foo( LBM_Grid srcGrid )\n+{\n+  double ux , uy , uz , rho ,         ux1, uy1, uz1, rho1,         ux2, uy2, uz2, rho2,         u2, px, py;\n+  int i;\n+  for( i = 0;\n+       i < (N_CELL_ENTRIES*( 100*100));\n+       i += N_CELL_ENTRIES )\n+    {\n+      rho1 = + ((srcGrid)[((C)+N_CELL_ENTRIES*( 100*100))+(i)])\n+\t  + ((srcGrid)[((N)+N_CELL_ENTRIES*( 100*100))+(i)])\n+\t  + ((srcGrid)[((S)+N_CELL_ENTRIES*( 100*100))+(i)])\n+\t  + ((srcGrid)[((E)+N_CELL_ENTRIES*( 100*100))+(i)])\n+\t  + ((srcGrid)[((W)+N_CELL_ENTRIES*( 100*100))+(i)])\n+\t  + ((srcGrid)[((T)+N_CELL_ENTRIES*( 100*100))+(i)])\n+\t  + ((srcGrid)[((B)+N_CELL_ENTRIES*( 100*100))+(i)])\n+\t  + ((srcGrid)[((NE)+N_CELL_ENTRIES*( 100*100))+(i)]) \n+\t  + ((srcGrid)[((NW)+N_CELL_ENTRIES*( 100*100))+(i)])\n+\t  + ((srcGrid)[((SE)+N_CELL_ENTRIES*( 100*100))+(i)])\n+\t  + ((srcGrid)[((SW)+N_CELL_ENTRIES*( 100*100))+(i)])\n+\t  + ((srcGrid)[((NT)+N_CELL_ENTRIES*( 100*100))+(i)])\n+\t  + ((srcGrid)[((NB)+N_CELL_ENTRIES*( 100*100))+(i)])\n+\t  + ((srcGrid)[((ST)+N_CELL_ENTRIES*( 100*100))+(i)])\n+\t  + ((srcGrid)[((SB)+N_CELL_ENTRIES*( 100*100))+(i)])\n+\t  + ((srcGrid)[((ET)+N_CELL_ENTRIES*( 100*100))+(i)])\n+\t  + ((srcGrid)[((EB)+N_CELL_ENTRIES*( 100*100))+(i)])\n+\t  + ((srcGrid)[((WT)+N_CELL_ENTRIES*( 100*100))+(i)])\n+\t  + ((srcGrid)[((WB)+N_CELL_ENTRIES*( 100*100))+(i)]);\n+      rho = 2.0*rho1 - rho2;\n+      px = (((i / N_CELL_ENTRIES) % 100) / (0.5*(100-1))) - 1.0;\n+      uz = 0.01 * (1.0-px*px) * (1.0-py*py);\n+      u2 = 1.5 * (ux*ux + uy*uy + uz*uz);\n+      (((srcGrid)[((C))+(i)])) = (1.0/ 3.0)*rho*(1.0 - u2);\n+      (((srcGrid)[((N))+(i)])) = (1.0/18.0)*rho*(1.0 + uy*(4.5*uy + 3.0) - u2);\n+    }\n+}"}, {"sha": "ab8504a10bd18a6be4fa0c6741c7c0046c102caf", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 158, "deletions": 123, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4", "patch": "@@ -57,6 +57,9 @@ vect_free_slp_tree (slp_tree node, bool final_p)\n   int i;\n   slp_tree child;\n \n+  if (--node->refcnt != 0)\n+    return;\n+\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     vect_free_slp_tree (child, final_p);\n \n@@ -82,7 +85,6 @@ vect_free_slp_tree (slp_tree node, bool final_p)\n   free (node);\n }\n \n-\n /* Free the memory allocated for the SLP instance.  FINAL_P is true if we\n    have vectorized the instance or if we have made a final decision not\n    to vectorize the statements in any way.  */\n@@ -126,6 +128,7 @@ vect_create_new_slp_node (vec<stmt_vec_info> scalar_stmts)\n   SLP_TREE_LOAD_PERMUTATION (node) = vNULL;\n   SLP_TREE_TWO_OPERATORS (node) = false;\n   SLP_TREE_DEF_TYPE (node) = vect_internal_def;\n+  node->refcnt = 1;\n \n   unsigned i;\n   FOR_EACH_VEC_ELT (scalar_stmts, i, stmt_info)\n@@ -1021,9 +1024,6 @@ bst_traits::equal (value_type existing, value_type candidate)\n   return true;\n }\n \n-typedef hash_set <vec <gimple *>, bst_traits> scalar_stmts_set_t;\n-static scalar_stmts_set_t *bst_fail;\n-\n typedef hash_map <vec <gimple *>, slp_tree,\n \t\t  simple_hashmap_traits <bst_traits, slp_tree> >\n   scalar_stmts_to_slp_tree_map_t;\n@@ -1034,30 +1034,33 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t       poly_uint64 *max_nunits,\n \t\t       vec<slp_tree> *loads,\n \t\t       bool *matches, unsigned *npermutes, unsigned *tree_size,\n-\t\t       unsigned max_tree_size);\n+\t\t       unsigned max_tree_size,\n+\t\t       scalar_stmts_to_slp_tree_map_t *bst_map);\n \n static slp_tree\n vect_build_slp_tree (vec_info *vinfo,\n \t\t     vec<stmt_vec_info> stmts, unsigned int group_size,\n \t\t     poly_uint64 *max_nunits, vec<slp_tree> *loads,\n \t\t     bool *matches, unsigned *npermutes, unsigned *tree_size,\n-\t\t     unsigned max_tree_size)\n+\t\t     unsigned max_tree_size,\n+\t\t     scalar_stmts_to_slp_tree_map_t *bst_map)\n {\n-  if (bst_fail->contains (stmts))\n-    return NULL;\n-  slp_tree res = vect_build_slp_tree_2 (vinfo, stmts, group_size, max_nunits,\n-\t\t\t\t\tloads, matches, npermutes, tree_size,\n-\t\t\t\t\tmax_tree_size);\n-  /* When SLP build fails for stmts record this, otherwise SLP build\n-     can be exponential in time when we allow to construct parts from\n-     scalars, see PR81723.  */\n-  if (! res)\n+  if (slp_tree *leader = bst_map->get (stmts))\n     {\n-      vec <stmt_vec_info> x;\n-      x.create (stmts.length ());\n-      x.splice (stmts);\n-      bst_fail->add (x);\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"re-using %sSLP tree %p\\n\",\n+\t\t\t *leader ? \"\" : \"failed \", *leader);\n+      if (*leader)\n+\t(*leader)->refcnt++;\n+      return *leader;\n     }\n+  slp_tree res = vect_build_slp_tree_2 (vinfo, stmts, group_size, max_nunits,\n+\t\t\t\t\tloads, matches, npermutes, tree_size,\n+\t\t\t\t\tmax_tree_size, bst_map);\n+  /* Keep a reference for the bst_map use.  */\n+  if (res)\n+    res->refcnt++;\n+  bst_map->put (stmts.copy (), res);\n   return res;\n }\n \n@@ -1074,7 +1077,8 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t       poly_uint64 *max_nunits,\n \t\t       vec<slp_tree> *loads,\n \t\t       bool *matches, unsigned *npermutes, unsigned *tree_size,\n-\t\t       unsigned max_tree_size)\n+\t\t       unsigned max_tree_size,\n+\t\t       scalar_stmts_to_slp_tree_map_t *bst_map)\n {\n   unsigned nops, i, this_tree_size = 0;\n   poly_uint64 this_max_nunits = *max_nunits;\n@@ -1205,7 +1209,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t\t\t\tgroup_size, &this_max_nunits,\n \t\t\t\t\t&this_loads, matches, npermutes,\n \t\t\t\t\t&this_tree_size,\n-\t\t\t\t\tmax_tree_size)) != NULL)\n+\t\t\t\t\tmax_tree_size, bst_map)) != NULL)\n \t{\n \t  /* If we have all children of child built up from scalars then just\n \t     throw that away and build it up this node from scalars.  */\n@@ -1348,7 +1352,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t\t\t\t    group_size, &this_max_nunits,\n \t\t\t\t\t    &this_loads, tem, npermutes,\n \t\t\t\t\t    &this_tree_size,\n-\t\t\t\t\t    max_tree_size)) != NULL)\n+\t\t\t\t\t    max_tree_size, bst_map)) != NULL)\n \t    {\n \t      /* ... so if successful we can apply the operand swapping\n \t\t to the GIMPLE IL.  This is necessary because for example\n@@ -1441,21 +1445,37 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \n static void\n vect_print_slp_tree (dump_flags_t dump_kind, dump_location_t loc,\n-\t\t     slp_tree node)\n+\t\t     slp_tree node, hash_set<slp_tree> &visited)\n {\n   int i;\n   stmt_vec_info stmt_info;\n   slp_tree child;\n \n-  dump_printf_loc (dump_kind, loc, \"node%s\\n\",\n+  if (visited.add (node))\n+    return;\n+\n+  dump_printf_loc (dump_kind, loc, \"node%s %p\\n\",\n \t\t   SLP_TREE_DEF_TYPE (node) != vect_internal_def\n-\t\t   ? \" (external)\" : \"\");\n+\t\t   ? \" (external)\" : \"\", node);\n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n     dump_printf_loc (dump_kind, loc, \"\\tstmt %d %G\", i, stmt_info->stmt);\n+  if (SLP_TREE_CHILDREN (node).is_empty ())\n+    return;\n+  dump_printf_loc (dump_kind, loc, \"\\tchildren\");\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_print_slp_tree (dump_kind, loc, child);\n+    dump_printf (dump_kind, \" %p\", (void *)child);\n+  dump_printf (dump_kind, \"\\n\");\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+    vect_print_slp_tree (dump_kind, loc, child, visited);\n }\n \n+static void\n+vect_print_slp_tree (dump_flags_t dump_kind, dump_location_t loc,\n+\t\t     slp_tree node)\n+{\n+  hash_set<slp_tree> visited;\n+  vect_print_slp_tree (dump_kind, loc, node, visited);\n+}\n \n /* Mark the tree rooted at NODE with MARK (PURE_SLP or HYBRID).\n    If MARK is HYBRID, it refers to a specific stmt in NODE (the stmt at index\n@@ -1509,15 +1529,19 @@ vect_mark_slp_stmts_relevant (slp_tree node)\n \n static void\n vect_slp_rearrange_stmts (slp_tree node, unsigned int group_size,\n-                          vec<unsigned> permutation)\n+                          vec<unsigned> permutation,\n+\t\t\t  hash_set<slp_tree> &visited)\n {\n   stmt_vec_info stmt_info;\n   vec<stmt_vec_info> tmp_stmts;\n   unsigned int i;\n   slp_tree child;\n \n+  if (visited.add (node))\n+    return;\n+\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_slp_rearrange_stmts (child, group_size, permutation);\n+    vect_slp_rearrange_stmts (child, group_size, permutation, visited);\n \n   gcc_assert (group_size == SLP_TREE_SCALAR_STMTS (node).length ());\n   tmp_stmts.create (group_size);\n@@ -1578,8 +1602,9 @@ vect_attempt_slp_rearrange_stmts (slp_instance slp_instn)\n      statements in the nodes is not important unless they are memory\n      accesses, we can rearrange the statements in all the nodes\n      according to the order of the loads.  */\n+  hash_set<slp_tree> visited;\n   vect_slp_rearrange_stmts (SLP_INSTANCE_TREE (slp_instn), group_size,\n-\t\t\t    node->load_permutation);\n+\t\t\t    node->load_permutation, visited);\n \n   /* We are done, no actual permutations need to be generated.  */\n   poly_uint64 unrolling_factor = SLP_INSTANCE_UNROLLING_FACTOR (slp_instn);\n@@ -1889,12 +1914,18 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   /* Build the tree for the SLP instance.  */\n   bool *matches = XALLOCAVEC (bool, group_size);\n   unsigned npermutes = 0;\n-  bst_fail = new scalar_stmts_set_t ();\n+  scalar_stmts_to_slp_tree_map_t *bst_map\n+    = new scalar_stmts_to_slp_tree_map_t ();\n   poly_uint64 max_nunits = nunits;\n   node = vect_build_slp_tree (vinfo, scalar_stmts, group_size,\n \t\t\t      &max_nunits, &loads, matches, &npermutes,\n-\t\t\t      NULL, max_tree_size);\n-  delete bst_fail;\n+\t\t\t      NULL, max_tree_size, bst_map);\n+  /* The map keeps a reference on SLP nodes built, release that.  */\n+  for (scalar_stmts_to_slp_tree_map_t::iterator it = bst_map->begin ();\n+       it != bst_map->end (); ++it)\n+    if ((*it).second)\n+      vect_free_slp_tree ((*it).second, false);\n+  delete bst_map;\n   if (node != NULL)\n     {\n       /* Calculate the unrolling factor based on the smallest type.  */\n@@ -1924,109 +1955,109 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t}\n       else\n \t{\n-      /* Create a new SLP instance.  */\n-      new_instance = XNEW (struct _slp_instance);\n-      SLP_INSTANCE_TREE (new_instance) = node;\n-      SLP_INSTANCE_GROUP_SIZE (new_instance) = group_size;\n-      SLP_INSTANCE_UNROLLING_FACTOR (new_instance) = unrolling_factor;\n-      SLP_INSTANCE_LOADS (new_instance) = loads;\n-\n-      /* Compute the load permutation.  */\n-      slp_tree load_node;\n-      bool loads_permuted = false;\n-      FOR_EACH_VEC_ELT (loads, i, load_node)\n-\t{\n-\t  vec<unsigned> load_permutation;\n-\t  int j;\n-\t  stmt_vec_info load_info;\n-\t  bool this_load_permuted = false;\n-\t  load_permutation.create (group_size);\n-\t  stmt_vec_info first_stmt_info = DR_GROUP_FIRST_ELEMENT\n-\t    (SLP_TREE_SCALAR_STMTS (load_node)[0]);\n-\t  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (load_node), j, load_info)\n+\t  /* Create a new SLP instance.  */\n+\t  new_instance = XNEW (struct _slp_instance);\n+\t  SLP_INSTANCE_TREE (new_instance) = node;\n+\t  SLP_INSTANCE_GROUP_SIZE (new_instance) = group_size;\n+\t  SLP_INSTANCE_UNROLLING_FACTOR (new_instance) = unrolling_factor;\n+\t  SLP_INSTANCE_LOADS (new_instance) = loads;\n+\n+\t  /* Compute the load permutation.  */\n+\t  slp_tree load_node;\n+\t  bool loads_permuted = false;\n+\t  FOR_EACH_VEC_ELT (loads, i, load_node)\n \t    {\n-\t      int load_place = vect_get_place_in_interleaving_chain\n-\t\t(load_info, first_stmt_info);\n-\t      gcc_assert (load_place != -1);\n-\t      if (load_place != j)\n-\t\tthis_load_permuted = true;\n-\t      load_permutation.safe_push (load_place);\n+\t      vec<unsigned> load_permutation;\n+\t      int j;\n+\t      stmt_vec_info load_info;\n+\t      bool this_load_permuted = false;\n+\t      load_permutation.create (group_size);\n+\t      stmt_vec_info first_stmt_info = DR_GROUP_FIRST_ELEMENT\n+\t\t  (SLP_TREE_SCALAR_STMTS (load_node)[0]);\n+\t      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (load_node), j, load_info)\n+\t\t{\n+\t\t  int load_place = vect_get_place_in_interleaving_chain\n+\t\t      (load_info, first_stmt_info);\n+\t\t  gcc_assert (load_place != -1);\n+\t\t  if (load_place != j)\n+\t\t    this_load_permuted = true;\n+\t\t  load_permutation.safe_push (load_place);\n+\t\t}\n+\t      if (!this_load_permuted\n+\t\t  /* The load requires permutation when unrolling exposes\n+\t\t     a gap either because the group is larger than the SLP\n+\t\t     group-size or because there is a gap between the groups.  */\n+\t\t  && (known_eq (unrolling_factor, 1U)\n+\t\t      || (group_size == DR_GROUP_SIZE (first_stmt_info)\n+\t\t\t  && DR_GROUP_GAP (first_stmt_info) == 0)))\n+\t\t{\n+\t\t  load_permutation.release ();\n+\t\t  continue;\n+\t\t}\n+\t      SLP_TREE_LOAD_PERMUTATION (load_node) = load_permutation;\n+\t      loads_permuted = true;\n \t    }\n-\t  if (!this_load_permuted\n-\t      /* The load requires permutation when unrolling exposes\n-\t         a gap either because the group is larger than the SLP\n-\t\t group-size or because there is a gap between the groups.  */\n-\t      && (known_eq (unrolling_factor, 1U)\n-\t\t  || (group_size == DR_GROUP_SIZE (first_stmt_info)\n-\t\t      && DR_GROUP_GAP (first_stmt_info) == 0)))\n+\n+\t  if (loads_permuted)\n \t    {\n-\t      load_permutation.release ();\n-\t      continue;\n+\t      if (!vect_supported_load_permutation_p (new_instance))\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"Build SLP failed: unsupported load \"\n+\t\t\t\t     \"permutation %G\", stmt_info->stmt);\n+\t\t  vect_free_slp_instance (new_instance, false);\n+\t\t  return false;\n+\t\t}\n \t    }\n-\t  SLP_TREE_LOAD_PERMUTATION (load_node) = load_permutation;\n-\t  loads_permuted = true;\n-\t}\n-\n-      if (loads_permuted)\n-        {\n-          if (!vect_supported_load_permutation_p (new_instance))\n-            {\n-              if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"Build SLP failed: unsupported load \"\n-\t\t\t\t \"permutation %G\", stmt_info->stmt);\n-\t      vect_free_slp_instance (new_instance, false);\n-              return false;\n-            }\n-        }\n \n \t  /* If the loads and stores can be handled with load/store-lan\n-\t instructions do not generate this SLP instance.  */\n-      if (is_a <loop_vec_info> (vinfo)\n-\t  && loads_permuted\n-\t  && dr && vect_store_lanes_supported (vectype, group_size, false))\n-\t{\n-\t  slp_tree load_node;\n-\t  FOR_EACH_VEC_ELT (loads, i, load_node)\n+\t     instructions do not generate this SLP instance.  */\n+\t  if (is_a <loop_vec_info> (vinfo)\n+\t      && loads_permuted\n+\t      && dr && vect_store_lanes_supported (vectype, group_size, false))\n \t    {\n-\t      stmt_vec_info stmt_vinfo = DR_GROUP_FIRST_ELEMENT\n-\t\t(SLP_TREE_SCALAR_STMTS (load_node)[0]);\n-\t      /* Use SLP for strided accesses (or if we can't load-lanes).  */\n-\t      if (STMT_VINFO_STRIDED_P (stmt_vinfo)\n-\t\t  || ! vect_load_lanes_supported\n-\t\t\t(STMT_VINFO_VECTYPE (stmt_vinfo),\n-\t\t\t DR_GROUP_SIZE (stmt_vinfo), false))\n-\t\tbreak;\n+\t      slp_tree load_node;\n+\t      FOR_EACH_VEC_ELT (loads, i, load_node)\n+\t\t{\n+\t\t  stmt_vec_info stmt_vinfo = DR_GROUP_FIRST_ELEMENT\n+\t\t      (SLP_TREE_SCALAR_STMTS (load_node)[0]);\n+\t\t  /* Use SLP for strided accesses (or if we can't load-lanes).  */\n+\t\t  if (STMT_VINFO_STRIDED_P (stmt_vinfo)\n+\t\t      || ! vect_load_lanes_supported\n+\t\t      (STMT_VINFO_VECTYPE (stmt_vinfo),\n+\t\t       DR_GROUP_SIZE (stmt_vinfo), false))\n+\t\t    break;\n+\t\t}\n+\t      if (i == loads.length ())\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"Built SLP cancelled: can use \"\n+\t\t\t\t     \"load/store-lanes\\n\");\n+\t\t  vect_free_slp_instance (new_instance, false);\n+\t\t  return false;\n+\t\t}\n \t    }\n-\t  if (i == loads.length ())\n+\n+\t  vinfo->slp_instances.safe_push (new_instance);\n+\n+\t  if (dump_enabled_p ())\n \t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"Built SLP cancelled: can use \"\n-\t\t\t\t \"load/store-lanes\\n\");\n-\t      vect_free_slp_instance (new_instance, false);\n-\t      return false;\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"Final SLP tree for instance:\\n\");\n+\t      vect_print_slp_tree (MSG_NOTE, vect_location, node);\n \t    }\n-\t}\n \n-      vinfo->slp_instances.safe_push (new_instance);\n-\n-      if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"Final SLP tree for instance:\\n\");\n-\t  vect_print_slp_tree (MSG_NOTE, vect_location, node);\n+\t  return true;\n \t}\n-\n-      return true;\n-    }\n     }\n   else\n     {\n-  /* Failed to SLP.  */\n-  /* Free the allocated memory.  */\n-  scalar_stmts.release ();\n-  loads.release ();\n+      /* Failed to SLP.  */\n+      /* Free the allocated memory.  */\n+      scalar_stmts.release ();\n+      loads.release ();\n     }\n \n   /* For basic block SLP, try to break the group up into multiples of the\n@@ -3749,8 +3780,13 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   if (SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n     return;\n \n+  /* See if we have already vectorized the node in the graph of the\n+     SLP instance.  */\n+  if (SLP_TREE_VEC_STMTS (node).exists ())\n+    return;\n+\n   /* See if we have already vectorized the same set of stmts and reuse their\n-     vectorized stmts.  */\n+     vectorized stmts across instances.  */\n   if (slp_tree *leader = bst_map->get (SLP_TREE_SCALAR_STMTS (node)))\n     {\n       SLP_TREE_VEC_STMTS (node).safe_splice (SLP_TREE_VEC_STMTS (*leader));\n@@ -3778,8 +3814,7 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   group_size = SLP_INSTANCE_GROUP_SIZE (instance);\n \n   gcc_assert (SLP_TREE_NUMBER_OF_VEC_STMTS (node) != 0);\n-  if (!SLP_TREE_VEC_STMTS (node).exists ())\n-    SLP_TREE_VEC_STMTS (node).create (SLP_TREE_NUMBER_OF_VEC_STMTS (node));\n+  SLP_TREE_VEC_STMTS (node).create (SLP_TREE_NUMBER_OF_VEC_STMTS (node));\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,"}, {"sha": "e1292aa6eb6b743844869c5343b2c462429757f2", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=a1f072e2441c58f6a486f90bb9a32bd5f6c51cb4", "patch": "@@ -130,6 +130,8 @@ struct _slp_tree {\n      scalar elements in one scalar iteration (GROUP_SIZE) multiplied by VF\n      divided by vector size.  */\n   unsigned int vec_stmts_size;\n+  /* Reference count in the SLP graph.  */\n+  unsigned int refcnt;\n   /* Whether the scalar computations use two different operators.  */\n   bool two_operators;\n   /* The DEF type of this node.  */"}]}