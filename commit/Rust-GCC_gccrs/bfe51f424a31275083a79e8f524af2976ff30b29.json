{"sha": "bfe51f424a31275083a79e8f524af2976ff30b29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZlNTFmNDI0YTMxMjc1MDgzYTc5ZThmNTI0YWYyOTc2ZmYzMGIyOQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2014-05-26T13:09:48Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2014-05-26T13:09:48Z"}, "message": "re PR target/61098 (Poor code setting count register for large loops)\n\n\tPR target/61098\n\t* config/rs6000/rs6000.c (rs6000_emit_set_const): Remove unneeded\n\tparams and return a bool.  Remove dead code.  Update comment.\n\tAssert we have a const_int source.  Remove bogus code from\n\t32-bit HWI days.  Move !TARGET_POWERPC64 handling, and correct\n\thandling of constants > 2G and reg_equal note, from..\n\t(rs6000_emit_set_long_const): ..here.  Remove unneeded param and\n\treturn value.  Update comment.  If we can, use a new pseudo\n\tfor intermediate calculations.\n\t* config/rs6000/rs6000-protos.h (rs6000_emit_set_const): Update\n\tprototype.\n\t* config/rs6000/rs6000.md (movsi_internal1_single+1): Update\n\tcall to rs6000_emit_set_const in splitter.\n\t(movdi_internal64+2, +3): Likewise.\n\nFrom-SVN: r210932", "tree": {"sha": "8d79f014d1e738377c94c4520bbddc32df573189", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d79f014d1e738377c94c4520bbddc32df573189"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfe51f424a31275083a79e8f524af2976ff30b29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfe51f424a31275083a79e8f524af2976ff30b29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfe51f424a31275083a79e8f524af2976ff30b29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfe51f424a31275083a79e8f524af2976ff30b29/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a9243bfced3137c8fc9830b7c43c4cdabc313cc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9243bfced3137c8fc9830b7c43c4cdabc313cc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9243bfced3137c8fc9830b7c43c4cdabc313cc6"}], "stats": {"total": 275, "additions": 141, "deletions": 134}, "files": [{"sha": "ac70e16b2c9d71977905dbcb5f2fe8c7c2e1183a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe51f424a31275083a79e8f524af2976ff30b29/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe51f424a31275083a79e8f524af2976ff30b29/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bfe51f424a31275083a79e8f524af2976ff30b29", "patch": "@@ -1,3 +1,20 @@\n+2014-05-26  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/61098\n+\t* config/rs6000/rs6000.c (rs6000_emit_set_const): Remove unneeded\n+\tparams and return a bool.  Remove dead code.  Update comment.\n+\tAssert we have a const_int source.  Remove bogus code from\n+\t32-bit HWI days.  Move !TARGET_POWERPC64 handling, and correct\n+\thandling of constants > 2G and reg_equal note, from..\n+\t(rs6000_emit_set_long_const): ..here.  Remove unneeded param and\n+\treturn value.  Update comment.  If we can, use a new pseudo\n+\tfor intermediate calculations.\n+\t* config/rs6000/rs6000-protos.h (rs6000_emit_set_const): Update\n+\tprototype.\n+\t* config/rs6000/rs6000.md (movsi_internal1_single+1): Update\n+\tcall to rs6000_emit_set_const in splitter.\n+\t(movdi_internal64+2, +3): Likewise.\n+\n 2014-05-26  Richard Biener  <rguenther@suse.de>\n \n \t* system.h: Define __STDC_FORMAT_MACROS before"}, {"sha": "bbcc1df471be278b25bba891dd726c1e9f77cfbb", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe51f424a31275083a79e8f524af2976ff30b29/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe51f424a31275083a79e8f524af2976ff30b29/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=bfe51f424a31275083a79e8f524af2976ff30b29", "patch": "@@ -114,7 +114,7 @@ extern void rs6000_emit_cbranch (enum machine_mode, rtx[]);\n extern char * output_cbranch (rtx, const char *, int, rtx);\n extern char * output_e500_flip_gt_bit (rtx, rtx);\n extern const char * output_probe_stack_range (rtx, rtx);\n-extern rtx rs6000_emit_set_const (rtx, enum machine_mode, rtx, int);\n+extern bool rs6000_emit_set_const (rtx, rtx);\n extern int rs6000_emit_cmove (rtx, rtx, rtx, rtx);\n extern int rs6000_emit_vector_cond_expr (rtx, rtx, rtx, rtx, rtx, rtx);\n extern void rs6000_emit_minmax (rtx, enum rtx_code, rtx, rtx);"}, {"sha": "8d80146781913dc8c5b71b18c0f861083304b76b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 117, "deletions": 124, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe51f424a31275083a79e8f524af2976ff30b29/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe51f424a31275083a79e8f524af2976ff30b29/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=bfe51f424a31275083a79e8f524af2976ff30b29", "patch": "@@ -1068,7 +1068,7 @@ static tree rs6000_handle_longcall_attribute (tree *, tree, tree, int, bool *);\n static tree rs6000_handle_altivec_attribute (tree *, tree, tree, int, bool *);\n static tree rs6000_handle_struct_attribute (tree *, tree, tree, int, bool *);\n static tree rs6000_builtin_vectorized_libmass (tree, tree, tree);\n-static rtx rs6000_emit_set_long_const (rtx, HOST_WIDE_INT, HOST_WIDE_INT);\n+static void rs6000_emit_set_long_const (rtx, HOST_WIDE_INT);\n static int rs6000_memory_move_cost (enum machine_mode, reg_class_t, bool);\n static bool rs6000_debug_rtx_costs (rtx, int, int, int, int *, bool);\n static int rs6000_debug_address_cost (rtx, enum machine_mode, addr_space_t,\n@@ -7849,53 +7849,50 @@ rs6000_conditional_register_usage (void)\n }\n \n \f\n-/* Try to output insns to set TARGET equal to the constant C if it can\n-   be done in less than N insns.  Do all computations in MODE.\n-   Returns the place where the output has been placed if it can be\n-   done and the insns have been emitted.  If it would take more than N\n-   insns, zero is returned and no insns and emitted.  */\n+/* Output insns to set DEST equal to the constant SOURCE as a series of\n+   lis, ori and shl instructions and return TRUE.  */\n \n-rtx\n-rs6000_emit_set_const (rtx dest, enum machine_mode mode,\n-\t\t       rtx source, int n ATTRIBUTE_UNUSED)\n+bool\n+rs6000_emit_set_const (rtx dest, rtx source)\n {\n-  rtx result, insn, set;\n-  HOST_WIDE_INT c0, c1;\n+  enum machine_mode mode = GET_MODE (dest);\n+  rtx temp, insn, set;\n+  HOST_WIDE_INT c;\n \n+  gcc_checking_assert (CONST_INT_P (source));\n+  c = INTVAL (source);\n   switch (mode)\n     {\n-    case  QImode:\n+    case QImode:\n     case HImode:\n-      if (dest == NULL)\n-\tdest = gen_reg_rtx (mode);\n       emit_insn (gen_rtx_SET (VOIDmode, dest, source));\n-      return dest;\n+      return true;\n \n     case SImode:\n-      result = !can_create_pseudo_p () ? dest : gen_reg_rtx (SImode);\n+      temp = !can_create_pseudo_p () ? dest : gen_reg_rtx (SImode);\n \n-      emit_insn (gen_rtx_SET (VOIDmode, copy_rtx (result),\n-\t\t\t      GEN_INT (INTVAL (source)\n-\t\t\t\t       & (~ (HOST_WIDE_INT) 0xffff))));\n+      emit_insn (gen_rtx_SET (VOIDmode, copy_rtx (temp),\n+\t\t\t      GEN_INT (c & ~(HOST_WIDE_INT) 0xffff)));\n       emit_insn (gen_rtx_SET (VOIDmode, dest,\n-\t\t\t      gen_rtx_IOR (SImode, copy_rtx (result),\n-\t\t\t\t\t   GEN_INT (INTVAL (source) & 0xffff))));\n-      result = dest;\n+\t\t\t      gen_rtx_IOR (SImode, copy_rtx (temp),\n+\t\t\t\t\t   GEN_INT (c & 0xffff))));\n       break;\n \n     case DImode:\n-      switch (GET_CODE (source))\n+      if (!TARGET_POWERPC64)\n \t{\n-\tcase CONST_INT:\n-\t  c0 = INTVAL (source);\n-\t  c1 = -(c0 < 0);\n-\t  break;\n+\t  rtx hi, lo;\n \n-\tdefault:\n-\t  gcc_unreachable ();\n+\t  hi = operand_subword_force (copy_rtx (dest), WORDS_BIG_ENDIAN == 0,\n+\t\t\t\t      DImode);\n+\t  lo = operand_subword_force (dest, WORDS_BIG_ENDIAN != 0,\n+\t\t\t\t      DImode);\n+\t  emit_move_insn (hi, GEN_INT (c >> 32));\n+\t  c = ((c & 0xffffffff) ^ 0x80000000) - 0x80000000;\n+\t  emit_move_insn (lo, GEN_INT (c));\n \t}\n-\n-      result = rs6000_emit_set_long_const (dest, c0, c1);\n+      else\n+\trs6000_emit_set_long_const (dest, c);\n       break;\n \n     default:\n@@ -7905,107 +7902,103 @@ rs6000_emit_set_const (rtx dest, enum machine_mode mode,\n   insn = get_last_insn ();\n   set = single_set (insn);\n   if (! CONSTANT_P (SET_SRC (set)))\n-    set_unique_reg_note (insn, REG_EQUAL, source);\n+    set_unique_reg_note (insn, REG_EQUAL, GEN_INT (c));\n \n-  return result;\n+  return true;\n }\n \n-/* Having failed to find a 3 insn sequence in rs6000_emit_set_const,\n-   fall back to a straight forward decomposition.  We do this to avoid\n-   exponential run times encountered when looking for longer sequences\n-   with rs6000_emit_set_const.  */\n-static rtx\n-rs6000_emit_set_long_const (rtx dest, HOST_WIDE_INT c1, HOST_WIDE_INT c2)\n-{\n-  if (!TARGET_POWERPC64)\n-    {\n-      rtx operand1, operand2;\n+/* Subroutine of rs6000_emit_set_const, handling PowerPC64 DImode.\n+   Output insns to set DEST equal to the constant C as a series of\n+   lis, ori and shl instructions.  */\n \n-      operand1 = operand_subword_force (dest, WORDS_BIG_ENDIAN == 0,\n-\t\t\t\t\tDImode);\n-      operand2 = operand_subword_force (copy_rtx (dest), WORDS_BIG_ENDIAN != 0,\n-\t\t\t\t\tDImode);\n-      emit_move_insn (operand1, GEN_INT (c1));\n-      emit_move_insn (operand2, GEN_INT (c2));\n+static void\n+rs6000_emit_set_long_const (rtx dest, HOST_WIDE_INT c)\n+{\n+  rtx temp;\n+  HOST_WIDE_INT ud1, ud2, ud3, ud4;\n+\n+  ud1 = c & 0xffff;\n+  c = c >> 16;\n+  ud2 = c & 0xffff;\n+  c = c >> 16;\n+  ud3 = c & 0xffff;\n+  c = c >> 16;\n+  ud4 = c & 0xffff;\n+\n+  if ((ud4 == 0xffff && ud3 == 0xffff && ud2 == 0xffff && (ud1 & 0x8000))\n+      || (ud4 == 0 && ud3 == 0 && ud2 == 0 && ! (ud1 & 0x8000)))\n+    emit_move_insn (dest, GEN_INT ((ud1 ^ 0x8000) - 0x8000));\n+\n+  else if ((ud4 == 0xffff && ud3 == 0xffff && (ud2 & 0x8000))\n+\t   || (ud4 == 0 && ud3 == 0 && ! (ud2 & 0x8000)))\n+    {\n+      temp = !can_create_pseudo_p () ? dest : gen_reg_rtx (DImode);\n+\n+      emit_move_insn (ud1 != 0 ? copy_rtx (temp) : dest,\n+\t\t      GEN_INT (((ud2 << 16) ^ 0x80000000) - 0x80000000));\n+      if (ud1 != 0)\n+\temit_move_insn (dest,\n+\t\t\tgen_rtx_IOR (DImode, copy_rtx (temp),\n+\t\t\t\t     GEN_INT (ud1)));\n+    }\n+  else if (ud3 == 0 && ud4 == 0)\n+    {\n+      temp = !can_create_pseudo_p () ? dest : gen_reg_rtx (DImode);\n+\n+      gcc_assert (ud2 & 0x8000);\n+      emit_move_insn (copy_rtx (temp),\n+\t\t      GEN_INT (((ud2 << 16) ^ 0x80000000) - 0x80000000));\n+      if (ud1 != 0)\n+\temit_move_insn (copy_rtx (temp),\n+\t\t\tgen_rtx_IOR (DImode, copy_rtx (temp),\n+\t\t\t\t     GEN_INT (ud1)));\n+      emit_move_insn (dest,\n+\t\t      gen_rtx_ZERO_EXTEND (DImode,\n+\t\t\t\t\t   gen_lowpart (SImode,\n+\t\t\t\t\t\t\tcopy_rtx (temp))));\n+    }\n+  else if ((ud4 == 0xffff && (ud3 & 0x8000))\n+\t   || (ud4 == 0 && ! (ud3 & 0x8000)))\n+    {\n+      temp = !can_create_pseudo_p () ? dest : gen_reg_rtx (DImode);\n+\n+      emit_move_insn (copy_rtx (temp),\n+\t\t      GEN_INT (((ud3 << 16) ^ 0x80000000) - 0x80000000));\n+      if (ud2 != 0)\n+\temit_move_insn (copy_rtx (temp),\n+\t\t\tgen_rtx_IOR (DImode, copy_rtx (temp),\n+\t\t\t\t     GEN_INT (ud2)));\n+      emit_move_insn (ud1 != 0 ? copy_rtx (temp) : dest,\n+\t\t      gen_rtx_ASHIFT (DImode, copy_rtx (temp),\n+\t\t\t\t      GEN_INT (16)));\n+      if (ud1 != 0)\n+\temit_move_insn (dest,\n+\t\t\tgen_rtx_IOR (DImode, copy_rtx (temp),\n+\t\t\t\t     GEN_INT (ud1)));\n     }\n   else\n     {\n-      HOST_WIDE_INT ud1, ud2, ud3, ud4;\n-\n-      ud1 = c1 & 0xffff;\n-      ud2 = (c1 & 0xffff0000) >> 16;\n-      c2 = c1 >> 32;\n-      ud3 = c2 & 0xffff;\n-      ud4 = (c2 & 0xffff0000) >> 16;\n-\n-      if ((ud4 == 0xffff && ud3 == 0xffff && ud2 == 0xffff && (ud1 & 0x8000))\n-\t  || (ud4 == 0 && ud3 == 0 && ud2 == 0 && ! (ud1 & 0x8000)))\n-\temit_move_insn (dest, GEN_INT ((ud1 ^ 0x8000) - 0x8000));\n-\n-      else if ((ud4 == 0xffff && ud3 == 0xffff && (ud2 & 0x8000))\n-\t       || (ud4 == 0 && ud3 == 0 && ! (ud2 & 0x8000)))\n-\t{\n-\t  emit_move_insn (dest, GEN_INT (((ud2 << 16) ^ 0x80000000)\n-\t\t\t\t\t - 0x80000000));\n-\t  if (ud1 != 0)\n-\t    emit_move_insn (copy_rtx (dest),\n-\t\t\t    gen_rtx_IOR (DImode, copy_rtx (dest),\n-\t\t\t\t\t GEN_INT (ud1)));\n-\t}\n-      else if (ud3 == 0 && ud4 == 0)\n-\t{\n-\t  gcc_assert (ud2 & 0x8000);\n-\t  emit_move_insn (dest, GEN_INT (((ud2 << 16) ^ 0x80000000)\n-\t\t\t\t\t - 0x80000000));\n-\t  if (ud1 != 0)\n-\t    emit_move_insn (copy_rtx (dest),\n-\t\t\t    gen_rtx_IOR (DImode, copy_rtx (dest),\n-\t\t\t\t\t GEN_INT (ud1)));\n-\t  emit_move_insn (copy_rtx (dest),\n-\t\t\t  gen_rtx_ZERO_EXTEND (DImode,\n-\t\t\t\t\t       gen_lowpart (SImode,\n-\t\t\t\t\t\t\t    copy_rtx (dest))));\n-\t}\n-      else if ((ud4 == 0xffff && (ud3 & 0x8000))\n-\t       || (ud4 == 0 && ! (ud3 & 0x8000)))\n-\t{\n-\t  emit_move_insn (dest, GEN_INT (((ud3 << 16) ^ 0x80000000)\n-\t\t\t\t\t - 0x80000000));\n-\t  if (ud2 != 0)\n-\t    emit_move_insn (copy_rtx (dest),\n-\t\t\t    gen_rtx_IOR (DImode, copy_rtx (dest),\n-\t\t\t\t\t GEN_INT (ud2)));\n-\t  emit_move_insn (copy_rtx (dest),\n-\t\t\t  gen_rtx_ASHIFT (DImode, copy_rtx (dest),\n-\t\t\t\t\t  GEN_INT (16)));\n-\t  if (ud1 != 0)\n-\t    emit_move_insn (copy_rtx (dest),\n-\t\t\t    gen_rtx_IOR (DImode, copy_rtx (dest),\n-\t\t\t\t\t GEN_INT (ud1)));\n-\t}\n-      else\n-\t{\n-\t  emit_move_insn (dest, GEN_INT (((ud4 << 16) ^ 0x80000000)\n-\t\t\t\t\t - 0x80000000));\n-\t  if (ud3 != 0)\n-\t    emit_move_insn (copy_rtx (dest),\n-\t\t\t    gen_rtx_IOR (DImode, copy_rtx (dest),\n-\t\t\t\t\t GEN_INT (ud3)));\n-\n-\t  emit_move_insn (copy_rtx (dest),\n-\t\t\t  gen_rtx_ASHIFT (DImode, copy_rtx (dest),\n-\t\t\t\t\t  GEN_INT (32)));\n-\t  if (ud2 != 0)\n-\t    emit_move_insn (copy_rtx (dest),\n-\t\t\t    gen_rtx_IOR (DImode, copy_rtx (dest),\n-\t\t\t\t\t GEN_INT (ud2 << 16)));\n-\t  if (ud1 != 0)\n-\t    emit_move_insn (copy_rtx (dest),\n-\t\t\t    gen_rtx_IOR (DImode, copy_rtx (dest),\n-\t\t\t\t\t GEN_INT (ud1)));\n-\t}\n+      temp = !can_create_pseudo_p () ? dest : gen_reg_rtx (DImode);\n+\n+      emit_move_insn (copy_rtx (temp),\n+\t\t      GEN_INT (((ud4 << 16) ^ 0x80000000) - 0x80000000));\n+      if (ud3 != 0)\n+\temit_move_insn (copy_rtx (temp),\n+\t\t\tgen_rtx_IOR (DImode, copy_rtx (temp),\n+\t\t\t\t     GEN_INT (ud3)));\n+\n+      emit_move_insn (ud2 != 0 || ud1 != 0 ? copy_rtx (temp) : dest,\n+\t\t      gen_rtx_ASHIFT (DImode, copy_rtx (temp),\n+\t\t\t\t      GEN_INT (32)));\n+      if (ud2 != 0)\n+\temit_move_insn (ud1 != 0 ? copy_rtx (temp) : dest,\n+\t\t\tgen_rtx_IOR (DImode, copy_rtx (temp),\n+\t\t\t\t     GEN_INT (ud2 << 16)));\n+      if (ud1 != 0)\n+\temit_move_insn (dest,\n+\t\t\tgen_rtx_IOR (DImode, copy_rtx (temp),\n+\t\t\t\t     GEN_INT (ud1)));\n     }\n-  return dest;\n }\n \n /* Helper for the following.  Get rid of [r+r] memory refs"}, {"sha": "f74d313610c17c3e4998b2be27a06140ff560ba5", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfe51f424a31275083a79e8f524af2976ff30b29/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfe51f424a31275083a79e8f524af2976ff30b29/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=bfe51f424a31275083a79e8f524af2976ff30b29", "patch": "@@ -9064,9 +9064,8 @@\n \t(ior:SI (match_dup 0)\n \t\t(match_dup 3)))]\n   \"\n-{ rtx tem = rs6000_emit_set_const (operands[0], SImode, operands[1], 2);\n-\n-  if (tem == operands[0])\n+{\n+  if (rs6000_emit_set_const (operands[0], operands[1]))\n     DONE;\n   else\n     FAIL;\n@@ -10137,9 +10136,8 @@\n   [(set (match_dup 0) (match_dup 2))\n    (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 3)))]\n   \"\n-{ rtx tem = rs6000_emit_set_const (operands[0], DImode, operands[1], 5);\n-\n-  if (tem == operands[0])\n+{\n+  if (rs6000_emit_set_const (operands[0], operands[1]))\n     DONE;\n   else\n     FAIL;\n@@ -10152,9 +10150,8 @@\n   [(set (match_dup 0) (match_dup 2))\n    (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 3)))]\n   \"\n-{ rtx tem = rs6000_emit_set_const (operands[0], DImode, operands[1], 5);\n-\n-  if (tem == operands[0])\n+{\n+  if (rs6000_emit_set_const (operands[0], operands[1]))\n     DONE;\n   else\n     FAIL;"}]}