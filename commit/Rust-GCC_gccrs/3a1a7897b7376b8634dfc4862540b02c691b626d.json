{"sha": "3a1a7897b7376b8634dfc4862540b02c691b626d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ExYTc4OTdiNzM3NmI4NjM0ZGZjNDg2MjU0MGIwMmM2OTFiNjI2ZA==", "commit": {"author": {"name": "Christian Bruel", "email": "christian.bruel@st.com", "date": "2013-11-06T08:49:15Z"}, "committer": {"name": "Christian Bruel", "email": "chrbr@gcc.gnu.org", "date": "2013-11-06T08:49:15Z"}, "message": "sh-mem.cc (sh_expand_cmpnstr, [...]): Factorize probabilities...\n\n2013-11-06  Christian Bruel  <christian.bruel@st.com>\n\n\t* gcc/config/sh/sh-mem.cc (sh_expand_cmpnstr, sh_expand_cmpstr):\n\tFactorize probabilities, Use adjust_address instead of\n\tadjust_automodify_address when possible. Enable for optimize.\n\t(sh_expand_strlen): New function.\n\t* gcc/config/sh/sh-protos.h (sh_expand_strlen): Declare.\n\t* gcc/config/sh/sh.md (strlensi): New pattern.\n\t(UNSPEC_BUILTIN_STRLEN): Define.\n\nFrom-SVN: r204445", "tree": {"sha": "23b7846a855026c24877941eabd64fa7b50c6aa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23b7846a855026c24877941eabd64fa7b50c6aa9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a1a7897b7376b8634dfc4862540b02c691b626d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a1a7897b7376b8634dfc4862540b02c691b626d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a1a7897b7376b8634dfc4862540b02c691b626d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a1a7897b7376b8634dfc4862540b02c691b626d/comments", "author": null, "committer": null, "parents": [{"sha": "fda1ba0aeacbbe986bd29677a8165e23a0d7d178", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fda1ba0aeacbbe986bd29677a8165e23a0d7d178", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fda1ba0aeacbbe986bd29677a8165e23a0d7d178"}], "stats": {"total": 248, "additions": 187, "deletions": 61}, "files": [{"sha": "24d25df4d0693d8e8055d7ffad4ee392a2d9d0ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a1a7897b7376b8634dfc4862540b02c691b626d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a1a7897b7376b8634dfc4862540b02c691b626d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a1a7897b7376b8634dfc4862540b02c691b626d", "patch": "@@ -1,3 +1,13 @@\n+2013-11-06  Christian Bruel  <christian.bruel@st.com>\n+\n+\t* gcc/config/sh/sh-mem.cc (sh_expand_cmpnstr, sh_expand_cmpstr):\n+\tFactorize probabilities, Use adjust_address instead of\n+\tadjust_automodify_address when possible. Enable for optimize.\n+\t(sh_expand_strlen): New function.\n+\t* gcc/config/sh/sh-protos.h (sh_expand_strlen): Declare.\n+\t* gcc/config/sh/sh.md (strlensi): New pattern.\n+\t(UNSPEC_BUILTIN_STRLEN): Define.\n+\n 2013-11-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/58970"}, {"sha": "729e848586df796278662d7eb48f0bf9916a79ec", "filename": "gcc/config/sh/sh-mem.cc", "status": "modified", "additions": 134, "deletions": 59, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a1a7897b7376b8634dfc4862540b02c691b626d/gcc%2Fconfig%2Fsh%2Fsh-mem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a1a7897b7376b8634dfc4862540b02c691b626d/gcc%2Fconfig%2Fsh%2Fsh-mem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-mem.cc?ref=3a1a7897b7376b8634dfc4862540b02c691b626d", "patch": "@@ -179,32 +179,31 @@ expand_block_move (rtx *operands)\n   return false;\n }\n \n+static int prob_unlikely = REG_BR_PROB_BASE / 10;\n+static int prob_likely = REG_BR_PROB_BASE / 4;\n+\n /* Emit code to perform a strcmp.\n \n    OPERANDS[0] is the destination.\n    OPERANDS[1] is the first string.\n    OPERANDS[2] is the second string.\n-   OPERANDS[3] is the align.  */\n+   OPERANDS[3] is the known alignment.  */\n bool\n sh_expand_cmpstr (rtx *operands)\n {\n-  rtx s1 = copy_rtx (operands[1]);\n-  rtx s2 = copy_rtx (operands[2]);\n-  rtx s1_addr = copy_addr_to_reg (XEXP (s1, 0));\n-  rtx s2_addr = copy_addr_to_reg (XEXP (s2, 0));\n+  rtx addr1 = operands[1];\n+  rtx addr2 = operands[2];\n+  rtx s1_addr = copy_addr_to_reg (XEXP (addr1, 0));\n+  rtx s2_addr = copy_addr_to_reg (XEXP (addr2, 0));\n   rtx tmp0 = gen_reg_rtx (SImode);\n   rtx tmp1 = gen_reg_rtx (SImode);\n   rtx tmp2 = gen_reg_rtx (SImode);\n   rtx tmp3 = gen_reg_rtx (SImode);\n \n+  rtx jump;\n   rtx L_return = gen_label_rtx ();\n   rtx L_loop_byte = gen_label_rtx ();\n   rtx L_end_loop_byte = gen_label_rtx ();\n-\n-  rtx jump, addr1, addr2;\n-  int prob_unlikely = REG_BR_PROB_BASE / 10;\n-  int prob_likely = REG_BR_PROB_BASE / 4;\n-\n   rtx L_loop_long = gen_label_rtx ();\n   rtx L_end_loop_long = gen_label_rtx ();\n \n@@ -220,8 +219,8 @@ sh_expand_cmpstr (rtx *operands)\n       add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n     }\n \n-  addr1 = adjust_automodify_address (s1, SImode, s1_addr, 0);\n-  addr2 = adjust_automodify_address (s2, SImode, s2_addr, 0);\n+  addr1 = adjust_automodify_address (addr1, SImode, s1_addr, 0);\n+  addr2 = adjust_automodify_address (addr2, SImode, s2_addr, 0);\n \n   /* tmp2 is aligned, OK to load.  */\n   emit_move_insn (tmp3, addr2);\n@@ -276,8 +275,8 @@ sh_expand_cmpstr (rtx *operands)\n   emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr, -4));\n \n   /* start byte loop.  */\n-  addr1 = adjust_automodify_address (s1, QImode, s1_addr, 0);\n-  addr2 = adjust_automodify_address (s2, QImode, s2_addr, 0);\n+  addr1 = adjust_address (addr1, QImode, 0);\n+  addr2 = adjust_address (addr2, QImode, 0);\n \n   emit_label (L_loop_byte);\n \n@@ -317,27 +316,23 @@ sh_expand_cmpstr (rtx *operands)\n    OPERANDS[1] is the first string.\n    OPERANDS[2] is the second string.\n    OPERANDS[3] is the length.\n-   OPERANDS[4] is the align.  */\n+   OPERANDS[4] is the known alignment.  */\n bool\n sh_expand_cmpnstr (rtx *operands)\n {\n-  rtx s1 = copy_rtx (operands[1]);\n-  rtx s2 = copy_rtx (operands[2]);\n-\n-  rtx s1_addr = copy_addr_to_reg (XEXP (s1, 0));\n-  rtx s2_addr = copy_addr_to_reg (XEXP (s2, 0));\n+  rtx addr1 = operands[1];\n+  rtx addr2 = operands[2];\n+  rtx s1_addr = copy_addr_to_reg (XEXP (addr1, 0));\n+  rtx s2_addr = copy_addr_to_reg (XEXP (addr2, 0));\n   rtx tmp0 = gen_reg_rtx (SImode);\n   rtx tmp1 = gen_reg_rtx (SImode);\n   rtx tmp2 = gen_reg_rtx (SImode);\n \n+  rtx jump;\n   rtx L_return = gen_label_rtx ();\n   rtx L_loop_byte = gen_label_rtx ();\n   rtx L_end_loop_byte = gen_label_rtx ();\n \n-  rtx jump, addr1, addr2;\n-  int prob_unlikely = REG_BR_PROB_BASE / 10;\n-  int prob_likely = REG_BR_PROB_BASE / 4;\n-\n   rtx len = force_reg (SImode, operands[3]);\n   int constp = (CONST_INT_P (operands[3]));\n   int bytes = (constp ? INTVAL (operands[3]) : 0);\n@@ -366,10 +361,10 @@ sh_expand_cmpnstr (rtx *operands)\n \t  add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n \t}\n \n-      addr1 = adjust_automodify_address (s1, SImode, s1_addr, 0);\n-      addr2 = adjust_automodify_address (s2, SImode, s2_addr, 0);\n+      addr1 = adjust_automodify_address (addr1, SImode, s1_addr, 0);\n+      addr2 = adjust_automodify_address (addr2, SImode, s2_addr, 0);\n \n-      /* words count.  */\n+      /* word count. Do we have iterations ? */\n       emit_insn (gen_lshrsi3 (lenw, len, GEN_INT (2)));\n \n       /*start long loop.  */\n@@ -429,48 +424,128 @@ sh_expand_cmpnstr (rtx *operands)\n       emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr, -4));\n     }\n \n-    addr1 = adjust_automodify_address (s1, QImode, s1_addr, 0);\n-    addr2 = adjust_automodify_address (s2, QImode, s2_addr, 0);\n+  addr1 = adjust_address (addr1, QImode, 0);\n+  addr2 = adjust_address (addr2, QImode, 0);\n+\n+  emit_label (L_loop_byte);\n+\n+  emit_insn (gen_extendqisi2 (tmp2, addr2));\n+  emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr, 1));\n+\n+  emit_insn (gen_extendqisi2 (tmp1, addr1));\n+  emit_move_insn (s1_addr, plus_constant (Pmode, s1_addr, 1));\n+\n+  emit_insn (gen_cmpeqsi_t (tmp2, const0_rtx));\n+  jump = emit_jump_insn (gen_branch_true (L_end_loop_byte));\n+  add_int_reg_note (jump, REG_BR_PROB, prob_unlikely);\n+\n+  emit_insn (gen_cmpeqsi_t (tmp1, tmp2));\n+  if (flag_delayed_branch)\n+    emit_insn (gen_zero_extendqisi2 (tmp2, gen_lowpart (QImode, tmp2)));\n+  jump = emit_jump_insn (gen_branch_false (L_end_loop_byte));\n+  add_int_reg_note (jump, REG_BR_PROB, prob_unlikely);\n+\n+  if (TARGET_SH2)\n+    emit_insn (gen_dect (len, len));\n+  else\n+    {\n+      emit_insn (gen_addsi3 (len, len, GEN_INT (-1)));\n+      emit_insn (gen_tstsi_t (len, len));\n+    }\n+\n+  jump = emit_jump_insn (gen_branch_false (L_loop_byte));\n+  add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n+  /* end byte loop.  */\n+\n+  emit_label (L_end_loop_byte);\n+\n+  if (! flag_delayed_branch)\n+    emit_insn (gen_zero_extendqisi2 (tmp2, gen_lowpart (QImode, tmp2)));\n+  emit_insn (gen_zero_extendqisi2 (tmp1, gen_lowpart (QImode, tmp1)));\n+\n+  emit_label (L_return);\n+\n+  emit_insn (gen_subsi3 (operands[0], tmp1, tmp2));\n+\n+  return true;\n+}\n+\n+/* Emit code to perform a strlen\n+\n+   OPERANDS[0] is the destination.\n+   OPERANDS[1] is the string.\n+   OPERANDS[2] is the char to search.\n+   OPERANDS[3] is the alignment.  */\n+bool\n+sh_expand_strlen (rtx *operands)\n+{\n+  rtx addr1 = operands[1];\n+  rtx current_addr = copy_addr_to_reg (XEXP (addr1, 0));\n+  rtx start_addr = gen_reg_rtx (Pmode);\n+  rtx tmp0 = gen_reg_rtx (SImode);\n+  rtx tmp1 = gen_reg_rtx (SImode);\n+  rtx L_return = gen_label_rtx ();\n+  rtx L_loop_byte = gen_label_rtx ();\n+\n+  rtx jump;\n+  rtx L_loop_long = gen_label_rtx ();\n+  rtx L_end_loop_long = gen_label_rtx ();\n+\n+  int align = INTVAL (operands[3]);\n+\n+  emit_move_insn (operands[0], GEN_INT (-1));\n+\n+  /* remember start of string.  */\n+  emit_move_insn (start_addr, current_addr);\n+\n+  if (align < 4)\n+    {\n+      emit_insn (gen_tstsi_t (GEN_INT (3), current_addr));\n+      jump = emit_jump_insn (gen_branch_false (L_loop_byte));\n+      add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n+    }\n+\n+  emit_move_insn (tmp0, operands[2]);\n+\n+  addr1 = adjust_automodify_address (addr1, SImode, current_addr, 0);\n+\n+  /*start long loop.  */\n+  emit_label (L_loop_long);\n+\n+  /* tmp1 is aligned, OK to load.  */\n+  emit_move_insn (tmp1, addr1);\n+  emit_move_insn (current_addr, plus_constant (Pmode, current_addr, 4));\n+\n+  /* Is there a 0 byte ?  */\n+  emit_insn (gen_cmpstr_t (tmp0, tmp1));\n \n-    emit_label (L_loop_byte);\n+  jump = emit_jump_insn (gen_branch_false (L_loop_long));\n+  add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n+  /* end loop.  */\n \n-    emit_insn (gen_extendqisi2 (tmp2, addr2));\n-    emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr, 1));\n+  emit_label (L_end_loop_long);\n \n-    emit_insn (gen_extendqisi2 (tmp1, addr1));\n-    emit_move_insn (s1_addr, plus_constant (Pmode, s1_addr, 1));\n+  emit_move_insn (current_addr, plus_constant (Pmode, current_addr, -4));\n \n-    emit_insn (gen_cmpeqsi_t (tmp2, const0_rtx));\n-    jump = emit_jump_insn (gen_branch_true (L_end_loop_byte));\n-    add_int_reg_note (jump, REG_BR_PROB, prob_unlikely);\n+  /* start byte loop.  */\n+  addr1 = adjust_address (addr1, QImode, 0);\n \n-    emit_insn (gen_cmpeqsi_t (tmp1, tmp2));\n-    if (flag_delayed_branch)\n-      emit_insn (gen_zero_extendqisi2 (tmp2, gen_lowpart (QImode, tmp2)));\n-    jump = emit_jump_insn (gen_branch_false (L_end_loop_byte));\n-    add_int_reg_note (jump, REG_BR_PROB, prob_unlikely);\n+  emit_label (L_loop_byte);\n \n-    if (TARGET_SH2)\n-      emit_insn (gen_dect (len, len));\n-    else\n-      {\n-\temit_insn (gen_addsi3 (len, len, GEN_INT (-1)));\n-\temit_insn (gen_tstsi_t (len, len));\n-      }\n+  emit_insn (gen_extendqisi2 (tmp1, addr1));\n+  emit_move_insn (current_addr, plus_constant (Pmode, current_addr, 1));\n \n-    jump = emit_jump_insn (gen_branch_false (L_loop_byte));\n-    add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n-    /* end byte loop.  */\n+  emit_insn (gen_cmpeqsi_t (tmp1, const0_rtx));\n+  jump = emit_jump_insn (gen_branch_false (L_loop_byte));\n+  add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n \n-    emit_label (L_end_loop_byte);\n+  /* end loop.  */\n \n-    if (! flag_delayed_branch)\n-      emit_insn (gen_zero_extendqisi2 (tmp2, gen_lowpart (QImode, tmp2)));\n-    emit_insn (gen_zero_extendqisi2 (tmp1, gen_lowpart (QImode, tmp1)));\n+  emit_label (L_return);\n \n-    emit_label (L_return);\n+  emit_insn (gen_addsi3 (start_addr, start_addr, GEN_INT (1)));\n \n-    emit_insn (gen_subsi3 (operands[0], tmp1, tmp2));\n+  emit_insn (gen_subsi3 (operands[0], current_addr, start_addr));\n \n-    return true;\n+  return true;\n }"}, {"sha": "11877e58b522074da417a8cf8a8b33e94d210bf3", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a1a7897b7376b8634dfc4862540b02c691b626d/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a1a7897b7376b8634dfc4862540b02c691b626d/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=3a1a7897b7376b8634dfc4862540b02c691b626d", "patch": "@@ -118,6 +118,7 @@ extern bool expand_block_move (rtx *);\n extern void prepare_move_operands (rtx[], enum machine_mode mode);\n extern bool sh_expand_cmpstr (rtx *);\n extern bool sh_expand_cmpnstr (rtx *);\n+extern bool sh_expand_strlen  (rtx *);\n extern enum rtx_code prepare_cbranch_operands (rtx *, enum machine_mode mode,\n \t\t\t\t\t       enum rtx_code comparison);\n extern void expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int);"}, {"sha": "1dd288c4833137c2cd18d12a5fd04b81571ed056", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a1a7897b7376b8634dfc4862540b02c691b626d/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a1a7897b7376b8634dfc4862540b02c691b626d/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=3a1a7897b7376b8634dfc4862540b02c691b626d", "patch": "@@ -161,6 +161,9 @@\n   ;; (unspec [OFFSET ANCHOR] UNSPEC_PCREL_SYMOFF) == OFFSET - (ANCHOR - .).\n   (UNSPEC_PCREL_SYMOFF\t46)\n \n+  ;; Misc builtins\n+  (UNSPEC_BUILTIN_STRLEN 47)\n+\n   ;; These are used with unspec_volatile.\n   (UNSPECV_BLOCKAGE\t0)\n   (UNSPECV_ALIGN\t1)\n@@ -12059,7 +12062,7 @@ label:\n \t(compare:SI (match_operand:BLK 1 \"memory_operand\")\n \t\t    (match_operand:BLK 2 \"memory_operand\")))\n    (use (match_operand 3 \"immediate_operand\"))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && optimize\"\n {\n   if (! optimize_insn_for_size_p () && sh_expand_cmpstr (operands))\n     DONE;\n@@ -12073,14 +12076,28 @@ label:\n \t\t    (match_operand:BLK 2 \"memory_operand\")))\n    (use (match_operand:SI 3 \"immediate_operand\"))\n    (use (match_operand:SI 4 \"immediate_operand\"))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && optimize\"\n {\n   if (! optimize_insn_for_size_p () && sh_expand_cmpnstr (operands))\n     DONE;\n   else\n     FAIL;\n })\n \n+(define_expand \"strlensi\"\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(unspec:SI [(match_operand:BLK 1 \"memory_operand\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\")\n+\t\t   (match_operand:SI 3 \"immediate_operand\")]\n+\t\t  UNSPEC_BUILTIN_STRLEN))]\n+  \"TARGET_SH1 && optimize\"\n+{\n+ if (! optimize_insn_for_size_p () && sh_expand_strlen (operands))\n+   DONE;\n+ else\n+   FAIL;\n+})\n+\n \f\n ;; -------------------------------------------------------------------------\n ;; Floating point instructions."}, {"sha": "8460edb8d0a0c932442d09985bfa8384c2d68f63", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a1a7897b7376b8634dfc4862540b02c691b626d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a1a7897b7376b8634dfc4862540b02c691b626d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3a1a7897b7376b8634dfc4862540b02c691b626d", "patch": "@@ -1,3 +1,7 @@\n+2013-11-06  Christian Bruel  <christian.bruel@st.com>\n+\n+\t* gcc.target/sh/strlen.c: New test.\n+\n 2013-11-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/58970"}, {"sha": "8a99781f3b44dedde0575064960c4850645d65c2", "filename": "gcc/testsuite/gcc.target/sh/strlen.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a1a7897b7376b8634dfc4862540b02c691b626d/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fstrlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a1a7897b7376b8634dfc4862540b02c691b626d/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fstrlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fstrlen.c?ref=3a1a7897b7376b8634dfc4862540b02c691b626d", "patch": "@@ -0,0 +1,19 @@\n+/* Check that the __builtin_strlen function is inlined with cmp/str\n+   when optimizing for speed.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n+/* { dg-final { scan-assembler-not \"jmp\" } } */\n+/* { dg-final { scan-assembler-times \"cmp/str\" 2 } } */\n+/* { dg-final { scan-assembler-times \"tst\\t#3\" 1 } } */\n+\n+test00 (const char *s1)\n+{\n+  return __builtin_strlen (s1);\n+}\n+\n+/* Check that no test for alignment is needed.  */\n+test03(const char *s1)\n+{\n+  return __builtin_strlen (__builtin_assume_aligned (s1, 4));\n+}"}]}