{"sha": "79896351cbd1ba94a66b867694b335127ee72449", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk4OTYzNTFjYmQxYmE5NGE2NmI4Njc2OTRiMzM1MTI3ZWU3MjQ0OQ==", "commit": {"author": {"name": "Mark Wielaard", "email": "mjw@redhat.com", "date": "2014-04-17T10:36:21Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2014-04-17T10:36:21Z"}, "message": "dwarf2out: Use normal constant values in bound_info if possible.\n\n\t* dwarf2out.c (add_bound_info): If HOST_WIDE_INT is big enough,\n\tthen represent the bound as normal constant value.\n\nFrom-SVN: r209473", "tree": {"sha": "02a6ce36888dc53bf3d9792ae15e9a33926c21d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02a6ce36888dc53bf3d9792ae15e9a33926c21d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79896351cbd1ba94a66b867694b335127ee72449", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79896351cbd1ba94a66b867694b335127ee72449", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79896351cbd1ba94a66b867694b335127ee72449", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79896351cbd1ba94a66b867694b335127ee72449/comments", "author": null, "committer": null, "parents": [{"sha": "5a65129e4ea51ffa1a6720a0dbea7aeb78ab60fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a65129e4ea51ffa1a6720a0dbea7aeb78ab60fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a65129e4ea51ffa1a6720a0dbea7aeb78ab60fa"}], "stats": {"total": 39, "additions": 27, "deletions": 12}, "files": [{"sha": "1d89cebbae7ac576801a916745250fbefd8c3e67", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79896351cbd1ba94a66b867694b335127ee72449/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79896351cbd1ba94a66b867694b335127ee72449/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79896351cbd1ba94a66b867694b335127ee72449", "patch": "@@ -1,3 +1,8 @@\n+2014-03-20  Mark Wielaard  <mjw@redhat.com>\n+\n+\t* dwarf2out.c (add_bound_info): If HOST_WIDE_INT is big enough,\n+\tthen represent the bound as normal constant value.\n+\n 2014-04-17  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/60847"}, {"sha": "8caf940c69ef80f5d4a3560053f3291943651b51", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79896351cbd1ba94a66b867694b335127ee72449/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79896351cbd1ba94a66b867694b335127ee72449/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=79896351cbd1ba94a66b867694b335127ee72449", "patch": "@@ -16203,21 +16203,31 @@ add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr, tree b\n \t    && tree_to_shwi (bound) == dflt)\n \t  ;\n \n-\t/* Otherwise represent the bound as an unsigned value with the\n-\t   precision of its type.  The precision and signedness of the\n-\t   type will be necessary to re-interpret it unambiguously.  */\n-\telse if (prec < HOST_BITS_PER_WIDE_INT)\n+\t/* If HOST_WIDE_INT is big enough then represent the bound as\n+\t   a constant value.  We need to choose a form based on\n+\t   whether the type is signed or unsigned.  We cannot just\n+\t   call add_AT_unsigned if the value itself is positive\n+\t   (add_AT_unsigned might add the unsigned value encoded as\n+\t   DW_FORM_data[1248]).  Some DWARF consumers will lookup the\n+\t   bounds type and then sign extend any unsigned values found\n+\t   for signed types.  This is needed only for\n+\t   DW_AT_{lower,upper}_bound, since for most other attributes,\n+\t   consumers will treat DW_FORM_data[1248] as unsigned values,\n+\t   regardless of the underlying type.  */\n+\telse if (prec <= HOST_BITS_PER_WIDE_INT\n+\t\t || TREE_INT_CST_HIGH (bound) == 0)\n \t  {\n-\t    unsigned HOST_WIDE_INT mask\n-\t      = ((unsigned HOST_WIDE_INT) 1 << prec) - 1;\n-\t    add_AT_unsigned (subrange_die, bound_attr,\n-\t\t  \t     TREE_INT_CST_LOW (bound) & mask);\n+\t    if (TYPE_UNSIGNED (TREE_TYPE (bound)))\n+\t      add_AT_unsigned (subrange_die, bound_attr,\n+\t\t\t       TREE_INT_CST_LOW (bound));\n+\t    else\n+\t      add_AT_int (subrange_die, bound_attr, TREE_INT_CST_LOW (bound));\n \t  }\n-\telse if (prec == HOST_BITS_PER_WIDE_INT\n-\t\t || TREE_INT_CST_HIGH (bound) == 0)\n-\t  add_AT_unsigned (subrange_die, bound_attr,\n-\t\t  \t   TREE_INT_CST_LOW (bound));\n \telse\n+\t  /* Otherwise represent the bound as an unsigned value with\n+\t     the precision of its type.  The precision and signedness\n+\t     of the type will be necessary to re-interpret it\n+\t     unambiguously.  */\n \t  add_AT_double (subrange_die, bound_attr, TREE_INT_CST_HIGH (bound),\n \t\t         TREE_INT_CST_LOW (bound));\n       }"}]}