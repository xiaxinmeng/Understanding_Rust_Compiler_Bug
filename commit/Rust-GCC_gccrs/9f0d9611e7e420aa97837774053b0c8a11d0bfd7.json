{"sha": "9f0d9611e7e420aa97837774053b0c8a11d0bfd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWYwZDk2MTFlN2U0MjBhYTk3ODM3Nzc0MDUzYjBjOGExMWQwYmZkNw==", "commit": {"author": {"name": "Tim Shen", "email": "timshen91@gmail.com", "date": "2013-10-26T16:09:28Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2013-10-26T16:09:28Z"}, "message": "regex.h: Remove unnecessary friends.\n\n2013-10-26  Tim Shen  <timshen91@gmail.com>\n\n\t* include/bits/regex.h: Remove unnecessary friends.\n\t* include/bits/regex.tcc (__regex_algo_impl<>): Move __get_executor\n\tto here.\n\t* include/bits/regex_executor.h: Remove _DFSExecutor and _BFSExecutor;\n\tthey are merged into _Executor. Eliminate quantifier tracking part, so\n\tit's faster.\n\t* include/bits/regex_executor.tcc: Implement _Executor.\n\t* testsuite/28_regex/algorithms/regex_match/ecma/char/ungreedy.cc: New.\n\t* testsuite/28_regex/algorithms/regex_search/ecma/greedy.cc: Adjust\n\tduplicate testcases.\n\t* testsuite/performance/28_regex/split.h: New.\n\t* testsuite/performance/28_regex/split_bfs.cc: New.\n\t* testsuite/util/testsuite_regex.h: Adjust behavior of two-executors\n\tagreement judger: do not compare match_results when executor return\n\tfalse.\n\nFrom-SVN: r204093", "tree": {"sha": "ed9926c18c61592e28734e2226b4d5ab7fb3fcf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed9926c18c61592e28734e2226b4d5ab7fb3fcf0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f0d9611e7e420aa97837774053b0c8a11d0bfd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f0d9611e7e420aa97837774053b0c8a11d0bfd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f0d9611e7e420aa97837774053b0c8a11d0bfd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5d905bb6131f34cc21461c111e1afc95fb85b7eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d905bb6131f34cc21461c111e1afc95fb85b7eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d905bb6131f34cc21461c111e1afc95fb85b7eb"}], "stats": {"total": 1286, "additions": 503, "deletions": 783}, "files": [{"sha": "7672b08f40cf257f16f172b2f5b3bcd6b48e52ea", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9f0d9611e7e420aa97837774053b0c8a11d0bfd7", "patch": "@@ -1,3 +1,21 @@\n+2013-10-26  Tim Shen  <timshen91@gmail.com>\n+\n+\t* include/bits/regex.h: Remove unnecessary friends.\n+\t* include/bits/regex.tcc (__regex_algo_impl<>): Move __get_executor\n+\tto here.\n+\t* include/bits/regex_executor.h: Remove _DFSExecutor and _BFSExecutor;\n+\tthey are merged into _Executor. Eliminate quantifier tracking part, so\n+\tit's faster.\n+\t* include/bits/regex_executor.tcc: Implement _Executor.\n+\t* testsuite/28_regex/algorithms/regex_match/ecma/char/ungreedy.cc: New.\n+\t* testsuite/28_regex/algorithms/regex_search/ecma/greedy.cc: Adjust\n+\tduplicate testcases.\n+\t* testsuite/performance/28_regex/split.h: New.\n+\t* testsuite/performance/28_regex/split_bfs.cc: New.\n+\t* testsuite/util/testsuite_regex.h: Adjust behavior of two-executors\n+\tagreement judger: do not compare match_results when executor return\n+\tfalse.\n+\n 2013-10-25  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \t* include/debug/formatter.h (__check_singular): Add const on"}, {"sha": "b1bda462be1f184d5403685fd67022ee6354c4e5", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 5, "deletions": 25, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=9f0d9611e7e420aa97837774053b0c8a11d0bfd7", "patch": "@@ -36,6 +36,9 @@ namespace __detail\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  enum class _RegexExecutorPolicy : int\n+    { _S_auto, _S_alternate };\n+\n   template<typename _BiIter, typename _Alloc,\n \t   typename _CharT, typename _TraitsT,\n \t   _RegexExecutorPolicy __policy,\n@@ -730,33 +733,16 @@ _GLIBCXX_END_NAMESPACE_VERSION\n       typedef std::shared_ptr<__detail::_NFA<_Ch_type, _Rx_traits>>\n \t_AutomatonPtr;\n \n-      template<typename _BiIter, typename _Alloc,\n-\ttypename _CharT, typename _TraitsT,\n-\t__detail::_RegexExecutorPolicy __policy>\n-\tfriend std::unique_ptr<\n-\t  __detail::_Executor<_BiIter, _Alloc, _CharT, _TraitsT>>\n-\t__detail::__get_executor(_BiIter,\n-\t\t\t\t _BiIter,\n-\t\t\t\t std::vector<sub_match<_BiIter>, _Alloc>&,\n-\t\t\t\t const basic_regex<_CharT, _TraitsT>&,\n-\t\t\t\t regex_constants::match_flag_type);\n-\n       template<typename _Bp, typename _Ap, typename _Cp, typename _Rp,\n \t__detail::_RegexExecutorPolicy, bool>\n \tfriend bool\n \t__detail::__regex_algo_impl(_Bp, _Bp, match_results<_Bp, _Ap>&,\n \t\t\t\t    const basic_regex<_Cp, _Rp>&,\n \t\t\t\t    regex_constants::match_flag_type);\n \n-      template<typename, typename, typename, typename>\n+      template<typename, typename, typename, bool>\n \tfriend class __detail::_Executor;\n \n-      template<typename, typename, typename, typename>\n-\tfriend class __detail::_DFSExecutor;\n-\n-      template<typename, typename, typename, typename>\n-\tfriend class __detail::_BFSExecutor;\n-\n       flag_type     _M_flags;\n       _Rx_traits    _M_traits;\n       _AutomatonPtr _M_automaton;\n@@ -1851,15 +1837,9 @@ _GLIBCXX_END_NAMESPACE_VERSION\n       //@}\n \n     private:\n-      template<typename, typename, typename, typename>\n+      template<typename, typename, typename, bool>\n \tfriend class __detail::_Executor;\n \n-      template<typename, typename, typename, typename>\n-\tfriend class __detail::_DFSExecutor;\n-\n-      template<typename, typename, typename, typename>\n-\tfriend class __detail::_BFSExecutor;\n-\n       template<typename, typename, typename>\n \tfriend class regex_iterator;\n "}, {"sha": "2ac095d9881c2875a5e20962e830b3400dbaaca2", "filename": "libstdc++-v3/include/bits/regex.tcc", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.tcc?ref=9f0d9611e7e420aa97837774053b0c8a11d0bfd7", "patch": "@@ -28,6 +28,13 @@\n  *  Do not attempt to use it directly. @headername{regex}\n  */\n \n+// See below __regex_algo_impl to get what this is talking about. The default\n+// value 1 indicated a conservative optimization without giving up worst case\n+// performance.\n+#ifndef _GLIBCXX_REGEX_DFS_QUANTIFIERS_LIMIT\n+#define _GLIBCXX_REGEX_DFS_QUANTIFIERS_LIMIT 1\n+#endif\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -61,14 +68,41 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       for (auto& __it : __res)\n \t__it.matched = false;\n \n-      auto __executor = __get_executor<_BiIter, _Alloc, _CharT, _TraitsT,\n-\t   __policy>(__s, __e, __res, __re, __flags);\n-\n+      // This function decide which executor to use under given circumstances.\n+      // The _S_auto policy now is the following: if a NFA has no\n+      // back-references and has more than _GLIBCXX_REGEX_DFS_QUANTIFIERS_LIMIT\n+      // quantifiers (*, +, ?), the BFS executor will be used, other wise\n+      // DFS executor. This is because DFS executor has a exponential upper\n+      // bound, but better best-case performace. Meanwhile, BFS executor can\n+      // effectively prevent from exponential-long time matching (which must\n+      // contains many quantifiers), but it's slower in average.\n+      //\n+      // For simple regex, BFS executor could be 2 or more times slower than\n+      // DFS executor.\n+      //\n+      // Of course, BFS executor cannot handle back-references.\n       bool __ret;\n-      if (__match_mode)\n-\t__ret = __executor->_M_match();\n+      if (!__re._M_automaton->_M_has_backref\n+\t  && (__policy == _RegexExecutorPolicy::_S_alternate\n+\t      || __re._M_automaton->_M_quant_count\n+\t\t> _GLIBCXX_REGEX_DFS_QUANTIFIERS_LIMIT))\n+\t{\n+\t  _Executor<_BiIter, _Alloc, _TraitsT, false>\n+\t    __executor(__s, __e, __m, __re, __flags);\n+\t  if (__match_mode)\n+\t    __ret = __executor._M_match();\n+\t  else\n+\t    __ret = __executor._M_search();\n+\t}\n       else\n-\t__ret = __executor->_M_search();\n+\t{\n+\t  _Executor<_BiIter, _Alloc, _TraitsT, true>\n+\t    __executor(__s, __e, __m, __re, __flags);\n+\t  if (__match_mode)\n+\t    __ret = __executor._M_match();\n+\t  else\n+\t    __ret = __executor._M_search();\n+\t}\n       if (__ret)\n \t{\n \t  for (auto __it : __res)"}, {"sha": "12db47b9a6376a08f1a4f26e01486ff1d379a3cb", "filename": "libstdc++-v3/include/bits/regex_executor.h", "status": "modified", "additions": 44, "deletions": 318, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h?ref=9f0d9611e7e420aa97837774053b0c8a11d0bfd7", "patch": "@@ -30,10 +30,6 @@\n \n // FIXME convert comments to doxygen format.\n \n-// TODO Put _DFSExecutor and _BFSExecutor into one class. They are becoming\n-// much more similar. Also, make grouping seperated. The\n-// regex_constants::nosubs enables much more simpler execution.\n-\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -56,15 +52,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @{\n    */\n \n-  template<typename _BiIter, typename _Alloc,\n-    typename _CharT, typename _TraitsT>\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+    bool __dfs_mode>\n     class _Executor\n     {\n     public:\n-      typedef basic_regex<_CharT, _TraitsT>           _RegexT;\n-      typedef std::vector<sub_match<_BiIter>, _Alloc> _ResultsVec;\n-      typedef regex_constants::match_flag_type        _FlagT;\n-      typedef typename _TraitsT::char_class_type      _ClassT;\n+      typedef typename iterator_traits<_BiIter>::value_type _CharT;\n+      typedef basic_regex<_CharT, _TraitsT>                 _RegexT;\n+      typedef std::vector<sub_match<_BiIter>, _Alloc>       _ResultsVec;\n+      typedef regex_constants::match_flag_type              _FlagT;\n+      typedef typename _TraitsT::char_class_type            _ClassT;\n+      typedef _NFA<_CharT, _TraitsT>                        _NFAT;\n \n     public:\n       _Executor(_BiIter         __begin,\n@@ -75,39 +73,47 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       : _M_begin(__begin),\n       _M_end(__end),\n       _M_re(__re),\n+      _M_nfa(*__re._M_automaton),\n       _M_results(__results),\n+      _M_match_queue(__dfs_mode ? nullptr\n+\t\t     : new queue<pair<_StateIdT, _ResultsVec>>()),\n+      _M_visited(__dfs_mode ? nullptr : new vector<bool>(_M_nfa.size())),\n       _M_flags((__flags & regex_constants::match_prev_avail)\n \t       ? (__flags\n \t\t  & ~regex_constants::match_not_bol\n \t\t  & ~regex_constants::match_not_bow)\n-\t       : __flags)\n-      { }\n-\n-      virtual\n-      ~_Executor()\n+\t       : __flags),\n+      _M_start_state(_M_nfa._M_start())\n       { }\n \n       // Set matched when string exactly match the pattern.\n       bool\n       _M_match()\n       {\n-\t_M_match_mode = true;\n-\t_M_init(_M_begin);\n-\treturn _M_main();\n+\t_M_current = _M_begin;\n+\treturn _M_main<true>();\n       }\n \n       // Set matched when some prefix of the string matches the pattern.\n       bool\n       _M_search_from_first()\n       {\n-\t_M_match_mode = false;\n-\t_M_init(_M_begin);\n-\treturn _M_main();\n+\t_M_current = _M_begin;\n+\treturn _M_main<false>();\n       }\n \n       bool\n       _M_search();\n \n+    private:\n+      template<bool __match_mode>\n+\tvoid\n+\t_M_dfs(_StateIdT __start);\n+\n+      template<bool __match_mode>\n+\tbool\n+\t_M_main();\n+\n       bool\n       _M_is_word(_CharT __ch) const\n       {\n@@ -134,307 +140,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool\n       _M_word_boundry(_State<_CharT, _TraitsT> __state) const;\n \n-      virtual std::unique_ptr<_Executor>\n-      _M_clone() const = 0;\n-\n-      // Return whether now match the given sub-NFA.\n       bool\n-      _M_lookahead(_State<_CharT, _TraitsT> __state) const\n-      {\n-\tauto __sub = this->_M_clone();\n-\t__sub->_M_set_start(__state._M_alt);\n-\treturn __sub->_M_search_from_first();\n-      }\n-\n-      void\n-      _M_set_results(_ResultsVec& __cur_results);\n-\n-    public:\n-      virtual void\n-      _M_init(_BiIter __cur) = 0;\n-\n-      virtual void\n-      _M_set_start(_StateIdT __start) = 0;\n-\n-      virtual bool\n-      _M_main() = 0;\n-\n-      _BiIter         _M_current;\n-      const _BiIter   _M_begin;\n-      const _BiIter   _M_end;\n-      const _RegexT&  _M_re;\n-      _ResultsVec&    _M_results;\n-      _FlagT          _M_flags;\n-      bool            _M_match_mode;\n-    };\n-\n-  // A _DFSExecutor perform a DFS on given NFA and input string. At the very\n-  // beginning the executor stands in the start state, then it try every\n-  // possible state transition in current state recursively. Some state\n-  // transitions consume input string, say, a single-char-matcher or a\n-  // back-reference matcher; some not, like assertion or other anchor nodes.\n-  // When the input is exhausted and the current state is an accepting state,\n-  // the whole executor return true.\n-  //\n-  // TODO: This approach is exponentially slow for certain input.\n-  //       Try to compile the NFA to a DFA.\n-  //\n-  // Time complexity: o(match_length), O(2^(_M_nfa->size()))\n-  // Space complexity: \\theta(match_results.size() + match_length)\n-  template<typename _BiIter, typename _Alloc,\n-    typename _CharT, typename _TraitsT>\n-    class _DFSExecutor\n-    : public _Executor<_BiIter, _Alloc, _CharT, _TraitsT>\n-    {\n-    public:\n-      typedef _Executor<_BiIter, _Alloc, _CharT, _TraitsT> _BaseT;\n-      typedef _NFA<_CharT, _TraitsT>                       _NFAT;\n-      typedef typename _BaseT::_RegexT                     _RegexT;\n-      typedef typename _BaseT::_ResultsVec                 _ResultsVec;\n-      typedef typename _BaseT::_FlagT                      _FlagT;\n+      _M_lookahead(_State<_CharT, _TraitsT> __state);\n \n     public:\n-      _DFSExecutor(_BiIter         __begin,\n-\t\t   _BiIter         __end,\n-\t\t   _ResultsVec&    __results,\n-\t\t   const _RegexT&  __re,\n-\t\t   _FlagT          __flags)\n-      : _BaseT(__begin, __end, __results, __re, __flags),\n-      _M_nfa(__re._M_automaton), _M_start_state(_M_nfa->_M_start())\n-      { }\n-\n-    private:\n-      void\n-      _M_init(_BiIter __cur)\n-      {\n-\t_M_cur_results.resize(_M_nfa->_M_sub_count() + 2);\n-\tthis->_M_current = __cur;\n-      }\n-\n-      void\n-      _M_set_start(_StateIdT __start)\n-      { _M_start_state = __start; }\n-\n-      bool\n-      _M_main()\n-      { return _M_dfs(this->_M_start_state); }\n-\n-      bool\n-      _M_dfs(_StateIdT __start);\n-\n-      std::unique_ptr<_BaseT>\n-      _M_clone() const\n-      {\n-\treturn std::unique_ptr<_BaseT>(new _DFSExecutor(this->_M_current,\n-\t\t\t\t\t\t\tthis->_M_end,\n-\t\t\t\t\t\t\tthis->_M_results,\n-\t\t\t\t\t\t\tthis->_M_re,\n-\t\t\t\t\t\t\tthis->_M_flags));\n-      }\n-\n+      _ResultsVec                                          _M_cur_results;\n+      _BiIter                                              _M_current;\n+      const _BiIter                                        _M_begin;\n+      const _BiIter                                        _M_end;\n+      const _RegexT&                                       _M_re;\n+      const _NFAT&                                         _M_nfa;\n+      _ResultsVec&                                         _M_results;\n+      // Used in BFS, saving states that need to be considered for the next\n+      // character.\n+      std::unique_ptr<queue<pair<_StateIdT, _ResultsVec>>> _M_match_queue;\n+      // Used in BFS, indicating that which state is already visited.\n+      std::unique_ptr<vector<bool>>                        _M_visited;\n+      _FlagT                                               _M_flags;\n       // To record current solution.\n-      std::shared_ptr<_NFAT> _M_nfa;\n-      _ResultsVec            _M_cur_results;\n-      _StateIdT              _M_start_state;\n-    };\n-\n-  // Like the DFS approach, it try every possible state transition; Unlike DFS,\n-  // it uses a queue instead of a stack to store matching states. It's a BFS\n-  // approach.\n-  //\n-  // Russ Cox's article(http://swtch.com/~rsc/regexp/regexp1.html) explained\n-  // this algorithm clearly.\n-  //\n-  // Every entry of _M_covered saves the solution(grouping status) for every\n-  // matching head. When states transit, solutions will be compared and\n-  // deduplicated(based on which greedy mode we have).\n-  //\n-  // Time complexity: o(match_length * (quantifier_number\n-  //                                    + match_results.size())\n-  //                  O(match_length * _M_nfa->size()\n-  //                    * (quantifier_number + match_results.size())\n-  // Space complexity: o(quantifier_number + match_results.size())\n-  //                   O(_M_nfa->size()\n-  //                     * (quantifier_number + match_results.size())\n-  template<typename _BiIter, typename _Alloc,\n-    typename _CharT, typename _TraitsT>\n-    class _BFSExecutor\n-    : public _Executor<_BiIter, _Alloc, _CharT, _TraitsT>\n-    {\n-    public:\n-      typedef _Executor<_BiIter, _Alloc, _CharT, _TraitsT> _BaseT;\n-      typedef _NFA<_CharT, _TraitsT>                       _NFAT;\n-      typedef typename _BaseT::_RegexT                     _RegexT;\n-      typedef typename _BaseT::_ResultsVec                 _ResultsVec;\n-      typedef typename _BaseT::_FlagT                      _FlagT;\n-      // Here's a solution for greedy/ungreedy mode in BFS approach. We need to\n-      // carefully work out how to compare to conflict matching states.\n-      //\n-      // A matching state is a pair(where, when); `where` is a NFA node; `when`\n-      // is a _BiIter, indicating which char is the next to be matched. Two\n-      // matching states conflict if they have equivalent `where` and `when`.\n-      //\n-      // Now we need to drop one and keep another, because at most one of them\n-      // could be the final optimal solution. This behavior is affected by\n-      // greedy policy.\n-      //\n-      // The definition of `greedy`:\n-      // For the sequence of quantifiers in NFA sorted by their start positions,\n-      // now maintain a vector in every matching state, with length equal to\n-      // quantifier seq, recording repeating times of every quantifier. Now to\n-      // compare two matching states, we just lexically compare these two\n-      // vectors. To win the compare(to survive), one matching state needs to\n-      // make its greedy quantifier count larger, and ungreedy quantifiers\n-      // count smaller.\n-      //\n-      // In the implementation, we recorded negtive counts for greedy\n-      // quantifiers and positive counts of ungreedy ones. Now the implicit\n-      // operator<() for lexicographical_compare will emit the answer.\n-      //\n-      // When two vectors equal, it means the `where`, `when` and quantifier\n-      // counts are identical, and indicates the same solution; so\n-      // _ResultsEntry::operator<() just return false.\n-      struct _ResultsEntry\n-      : private _ResultsVec\n-      {\n-      public:\n-\t_ResultsEntry(size_t __res_sz, size_t __sz)\n-\t: _ResultsVec(__res_sz), _M_quant_keys(__sz)\n-\t{ }\n-\n-\tvoid\n-\tresize(size_t __n)\n-\t{ _ResultsVec::resize(__n); }\n-\n-\tsize_t\n-\tsize()\n-\t{ return _ResultsVec::size(); }\n-\n-\tsub_match<_BiIter>&\n-\toperator[](size_t __idx)\n-\t{ return _ResultsVec::operator[](__idx); }\n-\n-\tbool\n-\toperator<(const _ResultsEntry& __rhs) const\n-\t{\n-\t  _GLIBCXX_DEBUG_ASSERT(_M_quant_keys.size()\n-\t\t\t\t== __rhs._M_quant_keys.size());\n-\t  return lexicographical_compare(_M_quant_keys.begin(),\n-\t\t\t\t\t _M_quant_keys.end(),\n-\t\t\t\t\t __rhs._M_quant_keys.begin(),\n-\t\t\t\t\t __rhs._M_quant_keys.end());\n-\t}\n-\n-\tvoid\n-\t_M_inc(size_t __idx, bool __neg)\n-\t{ _M_quant_keys[__idx] += __neg ? 1 : -1; }\n-\n-\t_ResultsVec&\n-\t_M_get()\n-\t{ return *this; }\n-\n-      public:\n-\tstd::vector<int> _M_quant_keys;\n-      };\n-      typedef std::unique_ptr<_ResultsEntry>               _ResultsPtr;\n-\n-      class _TodoList\n-      {\n-      public:\n-\texplicit\n-\t_TodoList(size_t __sz)\n-\t: _M_states(), _M_exists(__sz, false)\n-\t{ }\n-\n-\tvoid _M_push(_StateIdT __u)\n-\t{\n-\t  _GLIBCXX_DEBUG_ASSERT(__u < _M_exists.size());\n-\t  if (!_M_exists[__u])\n-\t    {\n-\t      _M_exists[__u] = true;\n-\t      _M_states.push_back(__u);\n-\t    }\n-\t}\n-\n-\t_StateIdT _M_pop()\n-\t{\n-\t  auto __ret = _M_states.back();\n-\t  _M_states.pop_back();\n-\t  _M_exists[__ret] = false;\n-\t  return __ret;\n-\t}\n-\n-\tbool _M_empty() const\n-\t{ return _M_states.empty(); }\n-\n-\tvoid _M_clear()\n-\t{\n-\t  _M_states.clear();\n-\t  _M_exists.assign(_M_exists.size(), false);\n-\t}\n-\n-      private:\n-\tstd::vector<_StateIdT>         _M_states;\n-\tstd::vector<bool>              _M_exists;\n-      };\n-\n-    public:\n-      _BFSExecutor(_BiIter         __begin,\n-\t\t   _BiIter         __end,\n-\t\t   _ResultsVec&    __results,\n-\t\t   const _RegexT&  __re,\n-\t\t   _FlagT          __flags)\n-      : _BaseT(__begin, __end, __results, __re, __flags),\n-      _M_nfa(__re._M_automaton), _M_match_stack(_M_nfa->size()),\n-      _M_stack(_M_nfa->size()), _M_start_state(_M_nfa->_M_start())\n-      { }\n-\n-    private:\n-      void\n-      _M_init(_BiIter __cur)\n-      {\n-\tthis->_M_current = __cur;\n-\t_M_covered.clear();\n-\t_ResultsVec& __res(this->_M_results);\n-\t_M_covered[this->_M_start_state] =\n-\t  _ResultsPtr(new _ResultsEntry(__res.size(),\n-\t\t\t\t\t_M_nfa->_M_quant_count));\n-\t_M_stack._M_push(this->_M_start_state);\n-      }\n-\n-      void\n-      _M_set_start(_StateIdT __start)\n-      { _M_start_state = __start; }\n-\n-      bool\n-      _M_main();\n-\n-      void\n-      _M_e_closure();\n-\n-      void\n-      _M_move();\n-\n-      bool\n-      _M_includes_some();\n-\n-      std::unique_ptr<_BaseT>\n-      _M_clone() const\n-      {\n-\treturn std::unique_ptr<_BaseT>(new _BFSExecutor(this->_M_current,\n-\t\t\t\t\t\t\tthis->_M_end,\n-\t\t\t\t\t\t\tthis->_M_results,\n-\t\t\t\t\t\t\tthis->_M_re,\n-\t\t\t\t\t\t\tthis->_M_flags));\n-      }\n-\n-      std::shared_ptr<_NFAT>           _M_nfa;\n-      std::map<_StateIdT, _ResultsPtr> _M_covered;\n-      _TodoList                        _M_match_stack;\n-      _TodoList                        _M_stack;\n-      _StateIdT                        _M_start_state;\n-      // To record global optimal solution.\n-      _ResultsPtr                      _M_cur_results;\n+      _StateIdT                                            _M_start_state;\n+      // Do we have a solution so far?\n+      bool                                                 _M_has_sol;\n     };\n \n  //@} regex-detail"}, {"sha": "d3b9a04030962d9a1b54ba6f91798780743cdf3c", "filename": "libstdc++-v3/include/bits/regex_executor.tcc", "status": "modified", "additions": 203, "deletions": 287, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc?ref=9f0d9611e7e420aa97837774053b0c8a11d0bfd7", "patch": "@@ -28,57 +28,166 @@\n  *  Do not attempt to use it directly. @headername{regex}\n  */\n \n-// See below __get_executor to get what this is talking about. The default\n-// value 1 indicated a conservative optimization without giving up worst case\n-// performance.\n-#ifndef _GLIBCXX_REGEX_DFS_QUANTIFIERS_LIMIT\n-#define _GLIBCXX_REGEX_DFS_QUANTIFIERS_LIMIT 1\n-#endif\n-\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n namespace __detail\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n-  template<typename _BiIter, typename _Alloc,\n-    typename _CharT, typename _TraitsT>\n-    bool _Executor<_BiIter, _Alloc, _CharT, _TraitsT>::\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+    bool __dfs_mode>\n+    bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n     _M_search()\n     {\n       if (_M_flags & regex_constants::match_continuous)\n \treturn _M_search_from_first();\n       auto __cur = _M_begin;\n       do\n \t{\n-\t  _M_match_mode = false;\n-\t  _M_init(__cur);\n-\t  if (_M_main())\n+\t  _M_current = __cur;\n+\t  if (_M_main<false>())\n \t    return true;\n \t}\n       // Continue when __cur == _M_end\n       while (__cur++ != _M_end);\n       return false;\n     }\n \n-  template<typename _BiIter, typename _Alloc,\n-    typename _CharT, typename _TraitsT>\n-    bool _DFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+    bool __dfs_mode>\n+  template<bool __match_mode>\n+    bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n+    _M_main()\n+    {\n+      if (__dfs_mode)\n+\t{\n+\t  _M_has_sol = false;\n+\t  _M_cur_results = _M_results;\n+\t  _M_dfs<__match_mode>(_M_start_state);\n+\t  return _M_has_sol;\n+\t}\n+      else\n+\t{\n+\t  // Like the DFS approach, it try every possible state transition;\n+\t  // Unlike DFS, it uses a queue instead of a stack to store matching\n+\t  // states. It's a BFS approach.\n+\t  //\n+\t  // Russ Cox's article(http://swtch.com/~rsc/regexp/regexp1.html)\n+\t  // explained this algorithm clearly.\n+\t  //\n+\t  // Time complexity: o(match_length * match_results.size())\n+\t  //                  O(match_length * _M_nfa.size()\n+\t  //                    * match_results.size())\n+\t  // Space complexity: o(_M_nfa.size() + match_results.size())\n+\t  //                   O(_M_nfa.size() * match_results.size())\n+\t  _M_match_queue->push(make_pair(_M_start_state, _M_results));\n+\t  bool __ret = false;\n+\t  while (1)\n+\t    {\n+\t      _M_has_sol = false;\n+\t      if (_M_match_queue->empty())\n+\t\tbreak;\n+\t      _M_visited->assign(_M_visited->size(), false);\n+\t      auto _M_old_queue = std::move(*_M_match_queue);\n+\t      while (!_M_old_queue.empty())\n+\t\t{\n+\t\t  auto __task = _M_old_queue.front();\n+\t\t  _M_old_queue.pop();\n+\t\t  _M_cur_results = __task.second;\n+\t\t  _M_dfs<__match_mode>(__task.first);\n+\t\t}\n+\t      if (!__match_mode)\n+\t\t__ret |= _M_has_sol;\n+\t      if (_M_current == _M_end)\n+\t\tbreak;\n+\t      ++_M_current;\n+\t    }\n+\t  if (__match_mode)\n+\t    __ret = _M_has_sol;\n+\t  return __ret;\n+\t}\n+    }\n+\n+  // Return whether now match the given sub-NFA.\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+    bool __dfs_mode>\n+    bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n+    _M_lookahead(_State<_Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n+\t\t _CharT, _TraitsT> __state)\n+    {\n+      _ResultsVec __what(_M_cur_results.size());\n+      auto __sub = std::unique_ptr<_Executor>(new _Executor(_M_current,\n+\t\t\t\t\t\t\t    _M_end,\n+\t\t\t\t\t\t\t    __what,\n+\t\t\t\t\t\t\t    _M_re,\n+\t\t\t\t\t\t\t    _M_flags));\n+      __sub->_M_start_state = __state._M_alt;\n+      if (__sub->_M_search_from_first())\n+\t{\n+\t  for (size_t __i = 0; __i < __what.size(); __i++)\n+\t    if (__what[__i].matched)\n+\t      _M_cur_results[__i] = __what[__i];\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+  // A _DFSExecutor perform a DFS on given NFA and input string. At the very\n+  // beginning the executor stands in the start state, then it try every\n+  // possible state transition in current state recursively. Some state\n+  // transitions consume input string, say, a single-char-matcher or a\n+  // back-reference matcher; some not, like assertion or other anchor nodes.\n+  // When the input is exhausted and the current state is an accepting state,\n+  // the whole executor return true.\n+  //\n+  // TODO: This approach is exponentially slow for certain input.\n+  //       Try to compile the NFA to a DFA.\n+  //\n+  // Time complexity: o(match_length), O(2^(_M_nfa.size()))\n+  // Space complexity: \\theta(match_results.size() + match_length)\n+  //\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+    bool __dfs_mode>\n+  template<bool __match_mode>\n+    void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n     _M_dfs(_StateIdT __i)\n     {\n-      auto& __current = this->_M_current;\n-      const auto& __state = (*_M_nfa)[__i];\n-      bool __ret = false;\n+      if (!__dfs_mode)\n+\t{\n+\t  if ((*_M_visited)[__i])\n+\t    return;\n+\t  (*_M_visited)[__i] = true;\n+\t}\n+\n+      const auto& __state = _M_nfa[__i];\n       switch (__state._M_opcode)\n \t{\n \tcase _S_opcode_alternative:\n \t  // Greedy or not, this is a question ;)\n \t  if (!__state._M_neg)\n-\t    __ret = _M_dfs(__state._M_alt)\n-\t      || _M_dfs(__state._M_next);\n+\t    {\n+\t      _M_dfs<__match_mode>(__state._M_alt);\n+\t      if (!__dfs_mode || !_M_has_sol)\n+\t\t_M_dfs<__match_mode>(__state._M_next);\n+\t    }\n \t  else\n-\t    __ret = _M_dfs(__state._M_next)\n-\t      || _M_dfs(__state._M_alt);\n+\t    {\n+\t      if (__dfs_mode)\n+\t\t{\n+\t\t  _M_dfs<__match_mode>(__state._M_next);\n+\t\t  if (!_M_has_sol)\n+\t\t    _M_dfs<__match_mode>(__state._M_alt);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (!_M_has_sol)\n+\t\t    {\n+\t\t      _M_dfs<__match_mode>(__state._M_next);\n+\t\t      if (!_M_has_sol)\n+\t\t\t_M_dfs<__match_mode>(__state._M_alt);\n+\t\t    }\n+\t\t}\n+\t    }\n \t  break;\n \tcase _S_opcode_subexpr_begin:\n \t  // Here's the critical part: if there's nothing changed since last\n@@ -88,273 +197,128 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  // Every change on _M_cur_results will be roll back after the\n \t  // recursion step finished.\n \t  if (!_M_cur_results[__state._M_subexpr].matched\n-\t      || _M_cur_results[__state._M_subexpr].first != __current)\n+\t      || _M_cur_results[__state._M_subexpr].first != _M_current)\n \t    {\n-\t      auto __back = _M_cur_results[__state._M_subexpr].first;\n-\t      _M_cur_results[__state._M_subexpr].first = __current;\n-\t      __ret = _M_dfs(__state._M_next);\n-\t      _M_cur_results[__state._M_subexpr].first = __back;\n+\t      auto& __res = _M_cur_results[__state._M_subexpr];\n+\t      auto __back = __res.first;\n+\t      __res.first = _M_current;\n+\t      _M_dfs<__match_mode>(__state._M_next);\n+\t      __res.first = __back;\n \t    }\n \t  break;\n \tcase _S_opcode_subexpr_end:\n-\t  if (_M_cur_results[__state._M_subexpr].second != __current\n+\t  if (_M_cur_results[__state._M_subexpr].second != _M_current\n \t      || _M_cur_results[__state._M_subexpr].matched != true)\n \t    {\n-\t      auto __back = _M_cur_results[__state._M_subexpr];\n-\t      _M_cur_results[__state._M_subexpr].second = __current;\n-\t      _M_cur_results[__state._M_subexpr].matched = true;\n-\t      __ret = _M_dfs(__state._M_next);\n-\t      _M_cur_results[__state._M_subexpr] = __back;\n+\t      auto& __res = _M_cur_results[__state._M_subexpr];\n+\t      auto __back = __res;\n+\t      __res.second = _M_current;\n+\t      __res.matched = true;\n+\t      _M_dfs<__match_mode>(__state._M_next);\n+\t      __res = __back;\n \t    }\n \t  else\n-\t    __ret = _M_dfs(__state._M_next);\n+\t    _M_dfs<__match_mode>(__state._M_next);\n \t  break;\n \tcase _S_opcode_line_begin_assertion:\n-\t  if (this->_M_at_begin())\n-\t    __ret = _M_dfs(__state._M_next);\n+\t  if (_M_at_begin())\n+\t    _M_dfs<__match_mode>(__state._M_next);\n \t  break;\n \tcase _S_opcode_line_end_assertion:\n-\t  if (this->_M_at_end())\n-\t    __ret = _M_dfs(__state._M_next);\n+\t  if (_M_at_end())\n+\t    _M_dfs<__match_mode>(__state._M_next);\n \t  break;\n \tcase _S_opcode_word_boundry:\n-\t  if (this->_M_word_boundry(__state) == !__state._M_neg)\n-\t    __ret = _M_dfs(__state._M_next);\n+\t  if (_M_word_boundry(__state) == !__state._M_neg)\n+\t    _M_dfs<__match_mode>(__state._M_next);\n \t  break;\n \t  // Here __state._M_alt offers a single start node for a sub-NFA.\n \t  // We recursivly invoke our algorithm to match the sub-NFA.\n \tcase _S_opcode_subexpr_lookahead:\n-\t  if (this->_M_lookahead(__state) == !__state._M_neg)\n-\t    __ret = _M_dfs(__state._M_next);\n+\t  if (_M_lookahead(__state) == !__state._M_neg)\n+\t    _M_dfs<__match_mode>(__state._M_next);\n \t  break;\n \tcase _S_opcode_match:\n-\t  if (__current != this->_M_end && __state._M_matches(*__current))\n+\t  if (__dfs_mode)\n \t    {\n-\t      ++__current;\n-\t      __ret = _M_dfs(__state._M_next);\n-\t      --__current;\n+\t      if (_M_current != _M_end && __state._M_matches(*_M_current))\n+\t\t{\n+\t\t  ++_M_current;\n+\t\t  _M_dfs<__match_mode>(__state._M_next);\n+\t\t  --_M_current;\n+\t\t}\n \t    }\n+\t  else\n+\t    if (__state._M_matches(*_M_current))\n+\t      _M_match_queue->push(make_pair(__state._M_next, _M_cur_results));\n \t  break;\n \t// First fetch the matched result from _M_cur_results as __submatch;\n \t// then compare it with\n-\t// (__current, __current + (__submatch.second - __submatch.first))\n+\t// (_M_current, _M_current + (__submatch.second - __submatch.first))\n \t// If matched, keep going; else just return to try another state.\n \tcase _S_opcode_backref:\n \t  {\n+\t    _GLIBCXX_DEBUG_ASSERT(__dfs_mode);\n \t    auto& __submatch = _M_cur_results[__state._M_backref_index];\n \t    if (!__submatch.matched)\n \t      break;\n-\t    auto __last = __current;\n+\t    auto __last = _M_current;\n \t    for (auto __tmp = __submatch.first;\n-\t\t __last != this->_M_end && __tmp != __submatch.second;\n+\t\t __last != _M_end && __tmp != __submatch.second;\n \t\t ++__tmp)\n \t      ++__last;\n-\t    if (this->_M_re._M_traits.transform(__submatch.first,\n+\t    if (_M_re._M_traits.transform(__submatch.first,\n \t\t\t\t\t\t__submatch.second)\n-\t\t== this->_M_re._M_traits.transform(__current, __last))\n+\t\t== _M_re._M_traits.transform(_M_current, __last))\n \t      {\n-\t\tif (__last != __current)\n+\t\tif (__last != _M_current)\n \t\t  {\n-\t\t    auto __backup = __current;\n-\t\t    __current = __last;\n-\t\t    __ret = _M_dfs(__state._M_next);\n-\t\t    __current = __backup;\n+\t\t    auto __backup = _M_current;\n+\t\t    _M_current = __last;\n+\t\t    _M_dfs<__match_mode>(__state._M_next);\n+\t\t    _M_current = __backup;\n \t\t  }\n \t\telse\n-\t\t  __ret = _M_dfs(__state._M_next);\n+\t\t  _M_dfs<__match_mode>(__state._M_next);\n \t      }\n \t  }\n \t  break;\n \tcase _S_opcode_accept:\n-\t  if (this->_M_match_mode)\n-\t    __ret = __current == this->_M_end;\n-\t  else\n-\t    __ret = true;\n-\t  if (__current == this->_M_begin\n-\t      && (this->_M_flags & regex_constants::match_not_null))\n-\t    __ret = false;\n-\t  if (__ret)\n-\t    this->_M_set_results(_M_cur_results);\n-\t  break;\n-\tdefault:\n-\t  _GLIBCXX_DEBUG_ASSERT(false);\n-\t}\n-      return __ret;\n-    }\n-\n-  template<typename _BiIter, typename _Alloc,\n-    typename _CharT, typename _TraitsT>\n-    bool _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n-    _M_main()\n-    {\n-      _M_e_closure();\n-      bool __ret = false;\n-      if (!this->_M_match_mode\n-\t  && !(this->_M_flags & regex_constants::match_not_null))\n-\t__ret = _M_includes_some() || __ret;\n-      while (this->_M_current != this->_M_end)\n-\t{\n-\t  _M_move();\n-\t  ++this->_M_current;\n-\t  if (_M_stack._M_empty())\n-\t    break;\n-\t  _M_e_closure();\n-\t  if (!this->_M_match_mode)\n-\t    // To keep regex_search greedy, no \"return true\" here.\n-\t    __ret = _M_includes_some() || __ret;\n-\t}\n-      if (this->_M_match_mode)\n-\t__ret = _M_includes_some();\n-      if (__ret)\n-\tthis->_M_set_results(_M_cur_results->_M_get());\n-      _M_match_stack._M_clear();\n-      _GLIBCXX_DEBUG_ASSERT(_M_stack._M_empty());\n-      return __ret;\n-    }\n-\n-  template<typename _BiIter, typename _Alloc,\n-    typename _CharT, typename _TraitsT>\n-    void _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n-    _M_e_closure()\n-    {\n-      auto& __current = this->_M_current;\n-\n-      while (!_M_stack._M_empty())\n-\t{\n-\t  auto __u = _M_stack._M_pop();\n-\t  _GLIBCXX_DEBUG_ASSERT(_M_covered.count(__u));\n-\t  const auto& __state = (*_M_nfa)[__u];\n-\n-\t  // Can be implemented using method, but there will be too many\n-\t  // arguments. I would use macro function before C++11, but lambda is\n-\t  // a better choice, since hopefully compiler can inline it.\n-\t  auto __add_visited_state = [=](_StateIdT __v)\n-\t  {\n-\t    if (_M_covered.count(__v) == 0)\n-\t      {\n-\t\t_M_covered[__v] =\n-\t\t  _ResultsPtr(new _ResultsEntry(*_M_covered[__u]));\n-\t\t_M_stack._M_push(__v);\n-\t\treturn;\n-\t      }\n-\t    auto& __cu = _M_covered[__u];\n-\t    auto& __cv = _M_covered[__v];\n-\t    if (*__cu < *__cv)\n-\t      {\n-\t\t__cv = _ResultsPtr(new _ResultsEntry(*__cu));\n-\t\t// if a state is updated, it's outgoing neighbors should be\n-\t\t// reconsidered too. Push them to the queue.\n-\t\t_M_stack._M_push(__v);\n-\t      }\n-\t  };\n-\n-\t  // Identical to DFS's switch part.\n-\t  switch (__state._M_opcode)\n+\t  if (__dfs_mode)\n \t    {\n-\t      // Needs to maintain quantifier count vector here. A quantifier\n-\t      // must be concerned with a alt node.\n-\t      case _S_opcode_alternative:\n-\t\t{\n-\t\t  __add_visited_state(__state._M_next);\n-\t\t  auto& __cu = *_M_covered[__u];\n-\t\t  auto __back = __cu._M_quant_keys[__state._M_quant_index];\n-\t\t  __cu._M_inc(__state._M_quant_index, __state._M_neg);\n-\t\t  __add_visited_state(__state._M_alt);\n-\t\t  __cu._M_quant_keys[__state._M_quant_index] = __back;\n-\t\t}\n-\t\tbreak;\n-\t      case _S_opcode_subexpr_begin:\n-\t\t{\n-\t\t  auto& __sub = (*_M_covered[__u])[__state._M_subexpr];\n-\t\t  if (!__sub.matched || __sub.first != __current)\n-\t\t    {\n-\t\t      auto __back = __sub.first;\n-\t\t      __sub.first = __current;\n-\t\t      __add_visited_state(__state._M_next);\n-\t\t      __sub.first = __back;\n-\t\t    }\n-\t\t}\n-\t\tbreak;\n-\t      case _S_opcode_subexpr_end:\n-\t\t{\n-\t\t  auto& __cu = *_M_covered[__u];\n-\t\t  auto __back = __cu[__state._M_subexpr];\n-\t\t  __cu[__state._M_subexpr].second = __current;\n-\t\t  __cu[__state._M_subexpr].matched = true;\n-\t\t  __add_visited_state(__state._M_next);\n-\t\t  __cu[__state._M_subexpr] = __back;\n-\t\t}\n-\t\tbreak;\n-\t      case _S_opcode_line_begin_assertion:\n-\t\tif (this->_M_at_begin())\n-\t\t  __add_visited_state(__state._M_next);\n-\t\tbreak;\n-\t      case _S_opcode_line_end_assertion:\n-\t\tif (this->_M_at_end())\n-\t\t  __add_visited_state(__state._M_next);\n-\t\tbreak;\n-\t      case _S_opcode_word_boundry:\n-\t\tif (this->_M_word_boundry(__state) == !__state._M_neg)\n-\t\t  __add_visited_state(__state._M_next);\n-\t\tbreak;\n-\t      case _S_opcode_subexpr_lookahead:\n-\t\tif (this->_M_lookahead(__state) == !__state._M_neg)\n-\t\t  __add_visited_state(__state._M_next);\n-\t\tbreak;\n-\t      case _S_opcode_match:\n-\t\t_M_match_stack._M_push(__u);\n-\t\tbreak;\n-\t      case _S_opcode_accept:\n-\t\tbreak;\n-\t      default:\n-\t\t_GLIBCXX_DEBUG_ASSERT(false);\n+\t      _GLIBCXX_DEBUG_ASSERT(!_M_has_sol);\n+\t      if (__match_mode)\n+\t\t_M_has_sol = _M_current == _M_end;\n+\t      else\n+\t\t_M_has_sol = true;\n+\t      if (_M_current == _M_begin\n+\t\t  && (_M_flags & regex_constants::match_not_null))\n+\t\t_M_has_sol = false;\n+\t      if (_M_has_sol)\n+\t\t_M_results = _M_cur_results;\n \t    }\n-\t}\n-    }\n-\n-  template<typename _BiIter, typename _Alloc,\n-    typename _CharT, typename _TraitsT>\n-    void _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n-    _M_move()\n-    {\n-      decltype(_M_covered) __next;\n-      while (!_M_match_stack._M_empty())\n-\t{\n-\t  auto __u = _M_match_stack._M_pop();\n-\t  const auto& __state = (*_M_nfa)[__u];\n-\t  auto& __cu = _M_covered[__u];\n-\t  if (__state._M_matches(*this->_M_current)\n-\t      && (__next.count(__state._M_next) == 0\n-\t\t  || *__cu < *__next[__state._M_next]))\n+\t  else\n \t    {\n-\t      __next[__state._M_next] = std::move(__cu);\n-\t      _M_stack._M_push(__state._M_next);\n+\t      if (_M_current == _M_begin\n+\t\t  && (_M_flags & regex_constants::match_not_null))\n+\t\tbreak;\n+\t      if (!__match_mode || _M_current == _M_end)\n+\t\tif (!_M_has_sol)\n+\t\t  {\n+\t\t    _M_has_sol = true;\n+\t\t    _M_results = _M_cur_results;\n+\t\t  }\n \t    }\n+\t  break;\n+\tdefault:\n+\t  _GLIBCXX_DEBUG_ASSERT(false);\n \t}\n-      _M_covered = move(__next);\n-    }\n-\n-  template<typename _BiIter, typename _Alloc,\n-    typename _CharT, typename _TraitsT>\n-    bool _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT>::\n-    _M_includes_some()\n-    {\n-      bool __succ = false;\n-      for (auto __u : _M_nfa->_M_final_states())\n-\tif (_M_covered.count(__u))\n-\t  {\n-\t    __succ = true;\n-\t    auto& __cu = _M_covered[__u];\n-\t    if (_M_cur_results == nullptr || *__cu < *_M_cur_results)\n-\t      _M_cur_results = _ResultsPtr(new _ResultsEntry(*__cu));\n-\t  }\n-      return __succ;\n     }\n \n   // Return whether now is at some word boundry.\n-  template<typename _BiIter, typename _Alloc,\n-    typename _CharT, typename _TraitsT>\n-    bool _Executor<_BiIter, _Alloc, _CharT, _TraitsT>::\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+    bool __dfs_mode>\n+    bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n     _M_word_boundry(_State<_CharT, _TraitsT> __state) const\n     {\n       // By definition.\n@@ -376,54 +340,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __ans;\n     }\n \n-  template<typename _BiIter, typename _Alloc,\n-    typename _CharT, typename _TraitsT>\n-    void _Executor<_BiIter, _Alloc, _CharT, _TraitsT>::\n-    _M_set_results(_ResultsVec& __cur_results)\n-    {\n-      for (size_t __i = 0; __i < __cur_results.size(); ++__i)\n-\tif (__cur_results[__i].matched)\n-\t  _M_results[__i] = __cur_results[__i];\n-    }\n-\n-  enum class _RegexExecutorPolicy : int\n-    { _S_auto, _S_alternate };\n-\n-  // This function decide which executor to use under given circumstances.\n-  // The _S_auto policy now is the following: if a NFA has no back-references\n-  // and has more than _GLIBCXX_REGEX_DFS_QUANTIFIERS_LIMIT quantifiers\n-  // (*, +, ?), the _BFSExecutor will be used, other wise _DFSExecutor. This is\n-  // because _DFSExecutor has a exponential upper bound, but better best-case\n-  // performace. Meanwhile, _BFSExecutor can effectively prevent from\n-  // exponential-long time matching (which must contains many quantifiers), but\n-  // it's slower in average.\n-  //\n-  // For simple regex, _BFSExecutor could be 2 or more times slower than\n-  // _DFSExecutor.\n-  //\n-  // Of course, _BFSExecutor cannot handle back-references.\n-  template<typename _BiIter, typename _Alloc,\n-    typename _CharT, typename _TraitsT,\n-    _RegexExecutorPolicy __policy>\n-    std::unique_ptr<_Executor<_BiIter, _Alloc, _CharT, _TraitsT>>\n-    __get_executor(_BiIter __b,\n-\t\t   _BiIter __e,\n-\t\t   std::vector<sub_match<_BiIter>, _Alloc>& __m,\n-\t\t   const basic_regex<_CharT, _TraitsT>& __re,\n-\t\t   regex_constants::match_flag_type __flags)\n-    {\n-      typedef std::unique_ptr<_Executor<_BiIter, _Alloc, _CharT, _TraitsT>>\n-\t_ExecutorPtr;\n-      typedef _DFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT> _DFSExecutorT;\n-      typedef _BFSExecutor<_BiIter, _Alloc, _CharT, _TraitsT> _BFSExecutorT;\n-      if (!__re._M_automaton->_M_has_backref\n-\t  && (__policy == _RegexExecutorPolicy::_S_alternate\n-\t      || __re._M_automaton->_M_quant_count\n-\t\t> _GLIBCXX_REGEX_DFS_QUANTIFIERS_LIMIT))\n-\treturn _ExecutorPtr(new _BFSExecutorT(__b, __e, __m, __re, __flags));\n-      return _ExecutorPtr(new _DFSExecutorT(__b, __e, __m, __re, __flags));\n-    }\n-\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace __detail\n } // namespace"}, {"sha": "ed26ebb89f0131bcdc26d833859759667f57ca26", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/ecma/char/ungreedy.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fecma%2Fchar%2Fungreedy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fecma%2Fchar%2Fungreedy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fecma%2Fchar%2Fungreedy.cc?ref=9f0d9611e7e420aa97837774053b0c8a11d0bfd7", "patch": "@@ -0,0 +1,50 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-10-24  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests ECMAScript ungreedy match.\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+#include <testsuite_regex.h>\n+\n+using namespace __gnu_test;\n+using namespace std;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  regex re(\"(a*?)*?\");\n+  cmatch m;\n+  VERIFY(regex_match(\"a\", m, re));\n+  VERIFY(m.size() == 2);\n+  VERIFY(string(m[0].first, m[0].second) == \"a\");\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "50141f0037d73d6127709b9c5e1af5837c39470a", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/extended/string_dispatch_01.cc", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d905bb6131f34cc21461c111e1afc95fb85b7eb/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_dispatch_01.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d905bb6131f34cc21461c111e1afc95fb85b7eb/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_dispatch_01.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_dispatch_01.cc?ref=5d905bb6131f34cc21461c111e1afc95fb85b7eb", "patch": "@@ -1,72 +0,0 @@\n-// { dg-options \"-std=gnu++11\" }\n-\n-//\n-// 2013-07-29  Tim Shen <timshen91@gmail.com>\n-//\n-// Copyright (C) 2013 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-//\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-//\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-// 28.11.2 regex_match\n-// Tests Extended automatic matcher dispatching against a std::string target.\n-\n-#include <regex>\n-#include <testsuite_hooks.h>\n-\n-using namespace std;\n-\n-template<typename _Bi_iter, typename _Alloc,\n-         typename _Ch_type, typename _Rx_traits>\n-  void\n-  fake_match(_Bi_iter                                 __s,\n-             _Bi_iter                                 __e,\n-             match_results<_Bi_iter, _Alloc>&         __m,\n-             const basic_regex<_Ch_type, _Rx_traits>& __re,\n-             regex_constants::match_flag_type         __flags\n-                            = regex_constants::match_default)\n-  {\n-    using namespace __detail;\n-    auto& __res = (vector<sub_match<_Bi_iter>, _Alloc>&)(__m);\n-    VERIFY( (dynamic_cast\n-             <_DFSExecutor<_Bi_iter, _Alloc, _Ch_type, _Rx_traits>*>\n-             (&*__get_executor<_Bi_iter, _Alloc, _Ch_type, _Rx_traits,\n-\t      _RegexExecutorPolicy::_S_auto>(__s, __e, __res, __re, __flags))\n-             != nullptr) );\n-  }\n-\n-void\n-test01()\n-{\n-  bool test __attribute__((unused)) = true;\n-\n-  regex  re(\"()(one(.*))abc\\\\1\"); // backref cause DFS\n-  const string target(\"onetwoabc\");\n-  smatch m;\n-  fake_match(target.begin(), target.end(), m, re);\n-\n-  regex_match(target, m, re);\n-  VERIFY( m[2].matched );\n-  VERIFY( m[3].matched );\n-  VERIFY( std::string(m[2].first, m[2].second) == \"onetwo\" );\n-  VERIFY( std::string(m[3].first, m[3].second) == \"two\" );\n-}\n-\n-int\n-main()\n-{\n-  test01();\n-  return 0;\n-}"}, {"sha": "5821bba06b6e8c30775cbcea38c250af641b3785", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_search/ecma/greedy.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fgreedy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fgreedy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_search%2Fecma%2Fgreedy.cc?ref=9f0d9611e7e420aa97837774053b0c8a11d0bfd7", "patch": "@@ -54,9 +54,9 @@ test01()\n   VERIFY(regex_search_debug(\"aaaa\", m, regex(\"(a+)(a+)\")));\n   TEST(1, \"aaa\");\n   TEST(2, \"a\");\n-  VERIFY(regex_search_debug(\"aaaa\", m, regex(\"(a+?)(a+)\")));\n-  TEST(1, \"a\");\n-  TEST(2, \"aaa\");\n+  VERIFY(regex_search_debug(\"aaaa\", m, regex(\"(a+)(a+?)\")));\n+  TEST(1, \"aaa\");\n+  TEST(2, \"a\");\n   VERIFY(regex_search_debug(\"aaaa\", m, regex(\"(a+?)(a+)\")));\n   TEST(1, \"a\");\n   TEST(2, \"aaa\");"}, {"sha": "e94e0318c3253e4a6f74d1f37ffa5df4593ccc18", "filename": "libstdc++-v3/testsuite/performance/28_regex/split.cc", "status": "modified", "additions": 1, "deletions": 71, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F28_regex%2Fsplit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F28_regex%2Fsplit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F28_regex%2Fsplit.cc?ref=9f0d9611e7e420aa97837774053b0c8a11d0bfd7", "patch": "@@ -18,82 +18,12 @@\n // 2013-10-08  Tim Shen  <timshen91@gmail.com>\n \n #include <testsuite_performance.h>\n-#include <regex>\n+#include \"split.h\"\n \n using namespace __gnu_test;\n-using namespace std;\n-\n-void split(string s)\n-{\n-    regex re(\"\\\\s+\");\n-    for (auto it = sregex_token_iterator(s.begin(), s.end(), re, -1);\n-\t it != sregex_token_iterator();\n-\t ++it)\n-      {\n-      }\n-}\n \n int main()\n {\n-  string source = \"\\\n-// Copyright (C) 2013 Free Software Foundation, Inc.\\n\\\n-//\\n\\\n-// This file is part of the GNU ISO C++ Library.  This library is free\\n\\\n-// software; you can redistribute it and/or modify it under the\\n\\\n-// terms of the GNU General Public License as published by the\\n\\\n-// Free Software Foundation; either version 3, or (at your option)\\n\\\n-// any later version.\\n\\\n-\\n\\\n-// This library is distributed in the hope that it will be useful,\\n\\\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\\\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\\\n-// GNU General Public License for more details.\\n\\\n-\\n\\\n-// You should have received a copy of the GNU General Public License along\\n\\\n-// with this library; see the file COPYING3.  If not see\\n\\\n-// <http://www.gnu.org/licenses/>.\\n\\\n-\\n\\\n-// 2013-10-08  Tim Shen  <timshen91@gmail.com>\\n\\\n-\\n\\\n-#include <testsuite_performance.h>\\n\\\n-#include <regex>\\n\\\n-\\n\\\n-using namespace __gnu_test;\\n\\\n-using namespace std;\\n\\\n-\\n\\\n-void split(string s)\\n\\\n-{\\n\\\n-    regex re(\\\"\\\\s+\\\");\\n\\\n-    for (auto it = sregex_token_iterator(s.begin(), s.end(), re, -1);\\n\\\n-\t it != sregex_token_iterator();\\n\\\n-\t ++it)\\n\\\n-      {\\n\\\n-      }\\n\\\n-}\\n\\\n-\\n\\\n-int main()\\n\\\n-{\\n\\\n-  string source = \\\"\\\";\\n\\\n-  time_counter time;\\n\\\n-  resource_counter resource;\\n\\\n-\\n\\\n-  source = source + source;\\n\\\n-  source = source + source;\\n\\\n-  source = source + source;\\n\\\n-  source = source + source;\\n\\\n-  source = source + source;\\n\\\n-  source = source + source;\\n\\\n-  source = source + source;\\n\\\n-  source = source + source;\\n\\\n-\\n\\\n-  start_counters(time, resource);\\n\\\n-  split(source);\\n\\\n-  stop_counters(time, resource);\\n\\\n-  report_performance(__FILE__, \\\"\\\", time, resource);\\n\\\n-\\n\\\n-  return 0;\\n\\\n-}\\n\";\n-\n   time_counter time;\n   resource_counter resource;\n "}, {"sha": "d016d9208bdcb9ccab40717225daed66e9eb268a", "filename": "libstdc++-v3/testsuite/performance/28_regex/split.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F28_regex%2Fsplit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F28_regex%2Fsplit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F28_regex%2Fsplit.h?ref=9f0d9611e7e420aa97837774053b0c8a11d0bfd7", "patch": "@@ -0,0 +1,91 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 2013-10-26  Tim Shen  <timshen91@gmail.com>\n+\n+#include <regex>\n+\n+using namespace std;\n+\n+void split(string s)\n+{\n+    regex re(\"\\\\s+\");\n+    for (auto it = sregex_token_iterator(s.begin(), s.end(), re, -1);\n+\t it != sregex_token_iterator();\n+\t ++it)\n+      {\n+      }\n+}\n+\n+string source = \"\\\n+// Copyright (C) 2013 Free Software Foundation, Inc.\\n\\\n+//\\n\\\n+// This file is part of the GNU ISO C++ Library.  This library is free\\n\\\n+// software; you can redistribute it and/or modify it under the\\n\\\n+// terms of the GNU General Public License as published by the\\n\\\n+// Free Software Foundation; either version 3, or (at your option)\\n\\\n+// any later version.\\n\\\n+\\n\\\n+// This library is distributed in the hope that it will be useful,\\n\\\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\\\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\\\n+// GNU General Public License for more details.\\n\\\n+\\n\\\n+// You should have received a copy of the GNU General Public License along\\n\\\n+// with this library; see the file COPYING3.  If not see\\n\\\n+// <http://www.gnu.org/licenses/>.\\n\\\n+\\n\\\n+// 2013-10-08  Tim Shen  <timshen91@gmail.com>\\n\\\n+\\n\\\n+#include <testsuite_performance.h>\\n\\\n+#include <regex>\\n\\\n+\\n\\\n+using namespace __gnu_test;\\n\\\n+using namespace std;\\n\\\n+\\n\\\n+void split(string s)\\n\\\n+{\\n\\\n+    regex re(\\\"\\\\s+\\\");\\n\\\n+    for (auto it = sregex_token_iterator(s.begin(), s.end(), re, -1);\\n\\\n+\t it != sregex_token_iterator();\\n\\\n+\t ++it)\\n\\\n+      {\\n\\\n+      }\\n\\\n+}\\n\\\n+\\n\\\n+int main()\\n\\\n+{\\n\\\n+  string source = \\\"\\\";\\n\\\n+  time_counter time;\\n\\\n+  resource_counter resource;\\n\\\n+\\n\\\n+  source = source + source;\\n\\\n+  source = source + source;\\n\\\n+  source = source + source;\\n\\\n+  source = source + source;\\n\\\n+  source = source + source;\\n\\\n+  source = source + source;\\n\\\n+  source = source + source;\\n\\\n+  source = source + source;\\n\\\n+\\n\\\n+  start_counters(time, resource);\\n\\\n+  split(source);\\n\\\n+  stop_counters(time, resource);\\n\\\n+  report_performance(__FILE__, \\\"\\\", time, resource);\\n\\\n+\\n\\\n+  return 0;\\n\\\n+}\\n\";"}, {"sha": "de2ef76a12fb4aeae750a181648f4ae6585d23cd", "filename": "libstdc++-v3/testsuite/performance/28_regex/split_bfs.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F28_regex%2Fsplit_bfs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F28_regex%2Fsplit_bfs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F28_regex%2Fsplit_bfs.cc?ref=9f0d9611e7e420aa97837774053b0c8a11d0bfd7", "patch": "@@ -0,0 +1,46 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 2013-10-26  Tim Shen  <timshen91@gmail.com>\n+\n+#include <testsuite_performance.h>\n+#define _GLIBCXX_REGEX_DFS_QUANTIFIERS_LIMIT 0\n+#include \"split.h\"\n+\n+using namespace __gnu_test;\n+\n+int main()\n+{\n+  time_counter time;\n+  resource_counter resource;\n+\n+  source = source + source;\n+  source = source + source;\n+  source = source + source;\n+  source = source + source;\n+  source = source + source;\n+  source = source + source;\n+  source = source + source;\n+  source = source + source;\n+\n+  start_counters(time, resource);\n+  split(source);\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"\", time, resource);\n+\n+  return 0;\n+}"}, {"sha": "596781a464b30632d6c64ff46acb83f791542f2c", "filename": "libstdc++-v3/testsuite/util/testsuite_regex.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_regex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f0d9611e7e420aa97837774053b0c8a11d0bfd7/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_regex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_regex.h?ref=9f0d9611e7e420aa97837774053b0c8a11d0bfd7", "patch": "@@ -150,7 +150,8 @@ namespace __gnu_test\n       auto __res2 = __regex_algo_impl<_Bi_iter, _Alloc, _Ch_type, _Rx_traits,\n \t   _RegexExecutorPolicy::_S_alternate, true>\n \t(__s, __e, __mm, __re, __flags);\n-      if (__res1 == __res2 && __m == __mm)\n+      // __m is unspecified if return value is false.\n+      if (__res1 == __res2 && (!__res1 || __m == __mm))\n \treturn __res1;\n       throw(std::exception());\n     }"}]}