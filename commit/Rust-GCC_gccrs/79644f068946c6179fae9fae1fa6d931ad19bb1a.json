{"sha": "79644f068946c6179fae9fae1fa6d931ad19bb1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk2NDRmMDY4OTQ2YzYxNzlmYWU5ZmFlMWZhNmQ5MzFhZDE5YmIxYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-12-26T13:30:32Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-12-26T13:30:32Z"}, "message": "(count_reg_usage): Don't count a register used within a SET that sets it.\n\n(delete_dead_from_cse): Pass new parm to count_reg_usage.\n\nFrom-SVN: r6327", "tree": {"sha": "dc4988b6891a70cb149bfd5e95c1ec9a83b25ca6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc4988b6891a70cb149bfd5e95c1ec9a83b25ca6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79644f068946c6179fae9fae1fa6d931ad19bb1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79644f068946c6179fae9fae1fa6d931ad19bb1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79644f068946c6179fae9fae1fa6d931ad19bb1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79644f068946c6179fae9fae1fa6d931ad19bb1a/comments", "author": null, "committer": null, "parents": [{"sha": "c2cc077888d46ed6c75ad56599af8d78da74b317", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2cc077888d46ed6c75ad56599af8d78da74b317", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2cc077888d46ed6c75ad56599af8d78da74b317"}], "stats": {"total": 34, "additions": 20, "deletions": 14}, "files": [{"sha": "853f80cac51d98a02aca5498199b7ee77413790b", "filename": "gcc/cse.c", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79644f068946c6179fae9fae1fa6d931ad19bb1a/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79644f068946c6179fae9fae1fa6d931ad19bb1a/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=79644f068946c6179fae9fae1fa6d931ad19bb1a", "patch": "@@ -647,7 +647,7 @@ static void invalidate_skipped_block PROTO((rtx));\n static void cse_check_loop_start PROTO((rtx, rtx));\n static void cse_set_around_loop\tPROTO((rtx, rtx, rtx));\n static rtx cse_basic_block\tPROTO((rtx, rtx, struct branch_path *, int));\n-static void count_reg_usage\tPROTO((rtx, int *, int));\n+static void count_reg_usage\tPROTO((rtx, int *, rtx, int));\n \f\n /* Return an estimate of the cost of computing rtx X.\n    One use is in cse, to decide which expression to keep in the hash table.\n@@ -8282,12 +8282,17 @@ cse_basic_block (from, to, next_branch, around_loop)\n \f\n /* Count the number of times registers are used (not set) in X.\n    COUNTS is an array in which we accumulate the count, INCR is how much\n-   we count each register usage.  */\n+   we count each register usage.  \n+\n+   Don't count a usage of DEST, which is the SET_DEST of a SET which \n+   contains X in its SET_SRC.  This is because such a SET does not\n+   modify the liveness of DEST.  */\n \n static void\n-count_reg_usage (x, counts, incr)\n+count_reg_usage (x, counts, dest, incr)\n      rtx x;\n      int *counts;\n+     rtx dest;\n      int incr;\n {\n   enum rtx_code code = GET_CODE (x);\n@@ -8297,7 +8302,8 @@ count_reg_usage (x, counts, incr)\n   switch (code)\n     {\n     case REG:\n-      counts[REGNO (x)] += incr;\n+      if (x != dest)\n+\tcounts[REGNO (x)] += incr;\n       return;\n \n     case PC:\n@@ -8313,39 +8319,39 @@ count_reg_usage (x, counts, incr)\n     case SET:\n       /* Unless we are setting a REG, count everything in SET_DEST.  */\n       if (GET_CODE (SET_DEST (x)) != REG)\n-\tcount_reg_usage (SET_DEST (x), counts, incr);\n-      count_reg_usage (SET_SRC (x), counts, incr);\n+\tcount_reg_usage (SET_DEST (x), counts, NULL_RTX, incr);\n+      count_reg_usage (SET_SRC (x), counts, SET_DEST (x), incr);\n       return;\n \n     case INSN:\n     case JUMP_INSN:\n     case CALL_INSN:\n-      count_reg_usage (PATTERN (x), counts, incr);\n+      count_reg_usage (PATTERN (x), counts, NULL_RTX, incr);\n \n       /* Things used in a REG_EQUAL note aren't dead since loop may try to\n \t use them.  */\n \n       if (REG_NOTES (x))\n-\tcount_reg_usage (REG_NOTES (x), counts, incr);\n+\tcount_reg_usage (REG_NOTES (x), counts, NULL_RTX, incr);\n       return;\n \n     case EXPR_LIST:\n     case INSN_LIST:\n       if (REG_NOTE_KIND (x) == REG_EQUAL)\n-\tcount_reg_usage (XEXP (x, 0), counts, incr);\n+\tcount_reg_usage (XEXP (x, 0), counts, NULL_RTX, incr);\n       if (XEXP (x, 1))\n-\tcount_reg_usage (XEXP (x, 1), counts, incr);\n+\tcount_reg_usage (XEXP (x, 1), counts, NULL_RTX, incr);\n       return;\n     }\n \n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tcount_reg_usage (XEXP (x, i), counts, incr);\n+\tcount_reg_usage (XEXP (x, i), counts, dest, incr);\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  count_reg_usage (XVECEXP (x, i, j), counts, incr);\n+\t  count_reg_usage (XVECEXP (x, i, j), counts, dest, incr);\n     }\n }\n \f\n@@ -8371,7 +8377,7 @@ delete_dead_from_cse (insns, nreg)\n   /* First count the number of times each register is used.  */\n   bzero (counts, sizeof (int) * nreg);\n   for (insn = next_real_insn (insns); insn; insn = next_real_insn (insn))\n-    count_reg_usage (insn, counts, 1);\n+    count_reg_usage (insn, counts, NULL_RTX, 1);\n \n   /* Go from the last insn to the first and delete insns that only set unused\n      registers or copy a register to itself.  As we delete an insn, remove\n@@ -8446,7 +8452,7 @@ delete_dead_from_cse (insns, nreg)\n \n       if (! live_insn)\n \t{\n-\t  count_reg_usage (insn, counts, -1);\n+\t  count_reg_usage (insn, counts, NULL_RTX, -1);\n \t  delete_insn (insn);\n \t}\n "}]}