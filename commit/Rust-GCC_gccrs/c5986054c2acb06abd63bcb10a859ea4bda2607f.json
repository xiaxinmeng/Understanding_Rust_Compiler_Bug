{"sha": "c5986054c2acb06abd63bcb10a859ea4bda2607f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU5ODYwNTRjMmFjYjA2YWJkNjNiY2IxMGE4NTllYTRiZGEyNjA3Zg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-12T17:16:21Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-12T17:16:21Z"}, "message": "Initial revision\n\nFrom-SVN: r308", "tree": {"sha": "1ea1186cd67e92ed40598e3754b8c57a6e0c246b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ea1186cd67e92ed40598e3754b8c57a6e0c246b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5986054c2acb06abd63bcb10a859ea4bda2607f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5986054c2acb06abd63bcb10a859ea4bda2607f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5986054c2acb06abd63bcb10a859ea4bda2607f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5986054c2acb06abd63bcb10a859ea4bda2607f/comments", "author": null, "committer": null, "parents": [{"sha": "4f64a10b5a963fe4ed722510a0ccc88bf4569d98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f64a10b5a963fe4ed722510a0ccc88bf4569d98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f64a10b5a963fe4ed722510a0ccc88bf4569d98"}], "stats": {"total": 568, "additions": 568, "deletions": 0}, "files": [{"sha": "3d1c58486f7e6720d73ff1bbe9af6fbf3f5d4039", "filename": "gcc/caller-save.c", "status": "added", "additions": 568, "deletions": 0, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5986054c2acb06abd63bcb10a859ea4bda2607f/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5986054c2acb06abd63bcb10a859ea4bda2607f/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=c5986054c2acb06abd63bcb10a859ea4bda2607f", "patch": "@@ -0,0 +1,568 @@\n+/* Save and restore call-clobbered registers which are live across a call.\n+   Copyright (C) 1989, 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"insn-config.h\"\n+#include \"flags.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"recog.h\"\n+#include \"basic-block.h\"\n+#include \"reload.h\"\n+#include \"expr.h\"\n+\n+/* A mode for each hard register that we can save.  This mode is wide enough\n+   to save the entire contents of the register and will be used whenever the\n+   register must be saved because it is live.  */\n+\n+static enum machine_mode regno_save_mode[FIRST_PSEUDO_REGISTER];\n+\n+/* For each hard register, a place on the stack where it can be saved,\n+   if needed.  */\n+\n+static rtx regno_save_mem[FIRST_PSEUDO_REGISTER];\n+\n+/* We will only make a register eligible for caller-save if it can be\n+   saved in its widest mode with a simple SET insn as long as the memory\n+   address is valid.  We record the INSN_CODE is those insns here since\n+   when we emit them, the addresses might not be valid, so they might not\n+   be recognized.  */\n+\n+static enum insn_code reg_save_code[FIRST_PSEUDO_REGISTER];\n+static enum insn_code reg_restore_code[FIRST_PSEUDO_REGISTER];\n+\n+/* Set of hard regs currently live (during scan of all insns).  */\n+\n+static HARD_REG_SET hard_regs_live;\n+\n+/* Set of hard regs currently residing in save area (during insn scan).  */\n+\n+static HARD_REG_SET hard_regs_saved;\n+\n+/* Number of registers currently in hard_regs_saved.  */\n+\n+int n_regs_saved;\n+\n+static void set_reg_live ();\n+static void clear_reg_live ();\n+static void restore_referenced_regs ();\n+static void insert_save_restore ();\n+\f\n+/* Return a machine mode that is legitimate for hard reg REGNO and large\n+   enough to save the whole register.  If we can't find one, \n+   return VOIDmode.  */\n+\n+static enum machine_mode\n+choose_hard_reg_mode (regno)\n+     int regno;\n+{\n+  enum machine_mode found_mode = VOIDmode, mode;\n+\n+  /* We first look for the largest integer mode that can be validly\n+     held in REGNO.  If none, we look for the largest floating-point mode.\n+     If we still didn't find a valid mode, try CCmode.  */\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    if (HARD_REGNO_NREGS (regno, mode) == 1\n+\t&& HARD_REGNO_MODE_OK (regno, mode))\n+      found_mode = mode;\n+\n+  if (found_mode != VOIDmode)\n+    return found_mode;\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    if (HARD_REGNO_NREGS (regno, mode) == 1\n+\t&& HARD_REGNO_MODE_OK (regno, mode))\n+      found_mode = mode;\n+\n+  if (found_mode != VOIDmode)\n+    return found_mode;\n+\n+  if (HARD_REGNO_NREGS (regno, CCmode) == 1\n+      && HARD_REGNO_MODE_OK (regno, CCmode))\n+    return CCmode;\n+\n+  /* We can't find a mode valid for this register.  */\n+  return VOIDmode;\n+}\n+\f\n+/* Initialize for caller-save.\n+\n+   Look at all the hard registers that are used by a call and for which\n+   regclass.c has not already excluded from being used across a call.\n+\n+   Ensure that we can find a mode to save the register and that there is a \n+   simple insn to save and restore the register.  This latter check avoids\n+   problems that would occur if we tried to save the MQ register of some\n+   machines directly into memory.  */\n+\n+void\n+init_caller_save ()\n+{\n+  char *first_obj = (char *) oballoc (0);\n+  rtx addr_reg;\n+  int offset;\n+  rtx address;\n+  int i;\n+\n+  /* First find all the registers that we need to deal with and all\n+     the modes that they can have.  If we can't find a mode to use,\n+     we can't have the register live over calls.  */\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (call_used_regs[i] && ! call_fixed_regs[i])\n+\t{\n+\t  regno_save_mode[i] = choose_hard_reg_mode (i);\n+\t  if (regno_save_mode[i] == VOIDmode)\n+\t    {\n+\t      call_fixed_regs[i] = 1;\n+\t      SET_HARD_REG_BIT (call_fixed_reg_set, i);\n+\t    }\n+\t}\n+      else\n+\tregno_save_mode[i] = VOIDmode;\n+    }\n+\n+  /* The following code tries to approximate the conditions under which\n+     we can easily save and restore a register without scratch registers or\n+     other complexities.  It will usually work, except under conditions where\n+     the validity of an insn operand is dependent on the address offset.\n+     No such cases are currently known.\n+\n+     We first find a typical offset from some BASE_REG_CLASS register.\n+     This address is chosen by finding the first register in the class\n+     and by finding the smallest power of two that is a valid offset from\n+     that register in every mode we will use to save registers.  */\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (TEST_HARD_REG_BIT (reg_class_contents[(int) BASE_REG_CLASS], i))\n+      break;\n+\n+  if (i == FIRST_PSEUDO_REGISTER)\n+    abort ();\n+\n+  addr_reg = gen_rtx (REG, Pmode, i);\n+\n+  for (offset = 1 << (HOST_BITS_PER_INT / 2); offset; offset >>= 1)\n+    {\n+      address = gen_rtx (PLUS, Pmode, addr_reg,\n+\t\t\t gen_rtx (CONST_INT, VOIDmode, offset));\n+\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (regno_save_mode[i] != VOIDmode\n+\t    && ! strict_memory_address_p (regno_save_mode[i], address))\n+\t  break;\n+\n+      if (i == FIRST_PSEUDO_REGISTER)\n+\tbreak;\n+    }\n+\n+  /* If we didn't find a valid address, we must use register indirect.  */\n+  if (offset == 0)\n+    address = addr_reg;\n+\n+  /* Next we try to form an insn to save and restore the register.  We\n+     see if such an insn is recognized and meets its constraints.  */\n+\n+  start_sequence ();\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (regno_save_mode[i] != VOIDmode)\n+      {\n+\trtx mem = gen_rtx (MEM, regno_save_mode[i], address);\n+\trtx reg = gen_rtx (REG, regno_save_mode[i], i);\n+\trtx savepat = gen_rtx (SET, VOIDmode, mem, reg);\n+\trtx restpat = gen_rtx (SET, VOIDmode, reg, mem);\n+\trtx saveinsn = emit_insn (savepat);\n+\trtx restinsn = emit_insn (restpat);\n+\tint ok;\n+\n+\treg_save_code[i] = recog_memoized (saveinsn);\n+\treg_restore_code[i] = recog_memoized (restinsn);\n+\n+\t/* Now extract both insns and see if we can meet their constraints.  */\n+\tok = (reg_save_code[i] != -1 && reg_restore_code[i] != -1);\n+\tif (ok)\n+\t  {\n+\t    insn_extract (saveinsn);\n+\t    ok = constrain_operands (reg_save_code[i], 1);\n+\t    insn_extract (restinsn);\n+\t    ok &= constrain_operands (reg_restore_code[i], 1);\n+\t  }\n+\n+\tif (! ok)\n+\t  {\n+\t    call_fixed_regs[i] = 1;\n+\t    SET_HARD_REG_BIT (call_fixed_reg_set, i);\n+\t  }\n+      }\n+\n+  end_sequence ();\n+\n+  obfree (first_obj);\n+}\n+\f\n+/* Initialize save areas by showing that we haven't allocated any yet.  */\n+\n+void\n+init_save_areas ()\n+{\n+  int i;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    regno_save_mem[i] = 0;\n+}\n+\n+/* Allocate save areas for any hard registers that might need saving.\n+   We take a conservative approach here and look for call-clobbered hard\n+   registers that are assigned to pseudos that cross calls.  This may\n+   overestimate slightly (especially if some of these registers are later\n+   used as spill registers), but it should not be significant.\n+\n+   Then perform register elimination in the addresses of the save area\n+   locations; return 1 if all eliminated addresses are strictly valid.\n+   We assume that our caller has set up the elimination table to the\n+   worst (largest) possible offsets.\n+\n+   Set *PCHANGED to 1 if we had to allocate some memory for the save area.  */\n+\n+int\n+setup_save_areas (pchanged)\n+     int *pchanged;\n+{\n+  int ok = 1;\n+  int i;\n+\n+  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+    if (reg_renumber[i] >= 0 && reg_n_calls_crossed[i] > 0)\n+      {\n+\tint regno = reg_renumber[i];\n+\tint endregno\n+\t  = regno + HARD_REGNO_NREGS (regno, GET_MODE (regno_reg_rtx[i]));\n+\tint j;\n+\n+\tfor (j = regno; j < endregno; j++)\n+\t  if (call_used_regs[j] && regno_save_mem[j] == 0)\n+\t    {\n+\t      regno_save_mem[j]\n+\t\t= assign_stack_local (regno_save_mode[j],\n+\t\t\t\t      GET_MODE_SIZE (regno_save_mode[j]), 0);\n+\t      *pchanged = 1;\n+\t    }\n+      }\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (regno_save_mem[i] != 0)\n+      ok &= strict_memory_address_p (regno_save_mode[i],\n+\t\t\t\t     XEXP (eliminate_regs (regno_save_mem[i],\n+\t\t\t\t\t\t\t   0, 0),\n+\t\t\t\t\t   0));\n+\n+  return ok;\n+}\n+\f\n+/* Find the places where hard regs are live across calls and save them.\n+\n+   INSN_MODE is the mode to assign to any insns that we add.  This is used\n+   by reload to determine whether or not reloads or register eliminations\n+   need be done on these insns.  */\n+\n+void\n+save_call_clobbered_regs (insn_mode)\n+     enum machine_mode insn_mode;\n+{\n+  rtx insn;\n+  int b;\n+\n+  for (b = 0; b < n_basic_blocks; b++)\n+    {\n+      regset regs_live = basic_block_live_at_start[b];\n+      int offset, bit, i, j;\n+      int regno;\n+\n+      /* Compute hard regs live at start of block -- this is the\n+\t real hard regs marked live, plus live pseudo regs that\n+\t have been renumbered to hard regs.  No registers have yet been\n+\t saved because we restore all of them before the end of the basic\n+\t block.  */\n+\n+#ifdef HARD_REG_SET\n+      hard_regs_live = *regs_live;\n+#else\n+      COPY_HARD_REG_SET (hard_regs_live, regs_live);\n+#endif\n+\n+      CLEAR_HARD_REG_SET (hard_regs_saved);\n+      n_regs_saved = 0;\n+\n+      for (offset = 0, i = 0; offset < regset_size; offset++)\n+\t{\n+\t  if (regs_live[offset] == 0)\n+\t    i += HOST_BITS_PER_INT;\n+\t  else\n+\t    for (bit = 1; bit && i < max_regno; bit <<= 1, i++)\n+\t      if ((regs_live[offset] & bit)\n+\t\t  && (regno = reg_renumber[i]) >= 0)\n+\t\tfor (j = regno;\n+\t\t     j < regno + HARD_REGNO_NREGS (regno,\n+\t\t\t\t\t\t   PSEUDO_REGNO_MODE (i));\n+\t\t     j++)\n+\t\t  SET_HARD_REG_BIT (hard_regs_live, j);\n+\t}\n+\n+      /* Now scan the insns in the block, keeping track of what hard\n+\t regs are live as we go.  When we see a call, save the live\n+\t call-clobbered hard regs.  */\n+\n+      for (insn = basic_block_head[b]; ; insn = NEXT_INSN (insn))\n+\t{\n+\t  RTX_CODE code = GET_CODE (insn);\n+\n+\t  if (GET_RTX_CLASS (code) == 'i')\n+\t    {\n+\t      rtx link;\n+\n+\t      /* If some registers have been saved, see if INSN references\n+\t\t any of them.  We must restore them before the insn if so.  */\n+\n+\t      if (n_regs_saved)\n+\t\trestore_referenced_regs (PATTERN (insn), insn, insn_mode);\n+\n+\t      /* NB: the normal procedure is to first enliven any\n+\t\t registers set by insn, then deaden any registers that\n+\t\t had their last use at insn.  This is incorrect now,\n+\t\t since multiple pseudos may have been mapped to the\n+\t\t same hard reg, and the death notes are ambiguous.  So\n+\t\t it must be done in the other, safe, order.  */\n+\n+\t      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t\tif (REG_NOTE_KIND (link) == REG_DEAD)\n+\t\t  clear_reg_live (XEXP (link, 0));\n+\n+\t      /* When we reach a call, we need to save all registers that are\n+\t\t live, call-used, not fixed, and not already saved.  We must\n+\t\t test at this point because registers that die in a CALL_INSN\n+\t\t are not live across the call and likewise for registers that\n+\t\t are born in the CALL_INSN.  */\n+\n+\t      if (code == CALL_INSN)\n+\t\tfor (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t\t  if (call_used_regs[regno] && ! call_fixed_regs[regno]\n+\t\t      && TEST_HARD_REG_BIT (hard_regs_live, regno)\n+\t\t      && ! TEST_HARD_REG_BIT (hard_regs_saved, regno))\n+\t\t    insert_save_restore (insn, 1, regno, insn_mode);\n+\t      \n+\t      note_stores (PATTERN (insn), set_reg_live);\n+\n+\t      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t\tif (REG_NOTE_KIND (link) == REG_UNUSED)\n+\t\t  clear_reg_live (XEXP (link, 0));\n+\t    }\n+\n+\t  if (insn == basic_block_end[b])\n+\t    break;\n+\t}\n+\n+      /* At the end of the basic block, we must restore any registers that\n+\t remain saved.  If the last insn in the block is a JUMP_INSN, put\n+\t the restore before the insn, otherwise, put it after the insn.  */\n+\n+      if (n_regs_saved)\n+\tfor (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t  if (TEST_HARD_REG_BIT (hard_regs_saved, regno))\n+\t    insert_save_restore ((GET_CODE (insn) == JUMP_INSN\n+\t\t\t\t  ? insn : NEXT_INSN (insn)),\n+\t\t\t\t 0, regno, insn_mode);\n+    }\n+}\n+\n+/* Here from note_stores when an insn stores a value in a register.\n+   Set the proper bit or bits in hard_regs_live.  All pseudos that have\n+   been assigned hard regs have had their register number changed already,\n+   so we can ignore pseudos.  */\n+\n+static void\n+set_reg_live (reg, setter)\n+     rtx reg, setter;\n+{\n+  register int regno, endregno, i;\n+  int word = 0;\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    {\n+      word = SUBREG_WORD (reg);\n+      reg = SUBREG_REG (reg);\n+    }\n+\n+  if (GET_CODE (reg) != REG || REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n+    return;\n+\n+  regno = REGNO (reg) + word;\n+  endregno = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+\n+  for (i = regno; i < endregno; i++)\n+    SET_HARD_REG_BIT (hard_regs_live, i);\n+}\n+\n+/* Here when a REG_DEAD note records the last use of a reg.  Clear\n+   the appropriate bit or bits in hard_regs_live.  Again we can ignore\n+   pseudos.  */\n+\n+static void\n+clear_reg_live (reg)\n+     rtx reg;\n+{\n+  register int regno, endregno, i;\n+\n+  if (GET_CODE (reg) != REG || REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n+    return;\n+\n+  regno = REGNO (reg);\n+  endregno= regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+\n+  for (i = regno; i < endregno; i++)\n+    CLEAR_HARD_REG_BIT (hard_regs_live, i);\n+}      \n+\f\n+/* If any register currently residing in the save area is referenced in X,\n+   which is part of INSN, emit code to restore the register in front of INSN.\n+   INSN_MODE is the mode to assign to any insns that we add.  */\n+\n+static void\n+restore_referenced_regs (x, insn, insn_mode)\n+     rtx x;\n+     rtx insn;\n+     enum machine_mode insn_mode;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  char *fmt;\n+  int i, j;\n+\n+  if (code == REG)\n+    {\n+      int regno = REGNO (x);\n+\n+      /* If this is a pseudo, scan its memory location, since it might\n+\t involve the use of another register, which might be saved.  */\n+\n+      if (regno >= FIRST_PSEUDO_REGISTER\n+\t  && reg_equiv_mem[regno] != 0)\n+\trestore_referenced_regs (XEXP (reg_equiv_mem[regno], 0),\n+\t\t\t\t insn, insn_mode);\n+      else if (regno >= FIRST_PSEUDO_REGISTER\n+\t       && reg_equiv_address[regno] != 0)\n+\trestore_referenced_regs (XEXP (reg_equiv_address[regno], 0),\n+\t\t\t\t insn, insn_mode);\n+\n+      /* Otherwise if this is a hard register, restore any piece of it that\n+\t is currently saved.  */\n+\n+      else if (regno < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  int endregno = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\n+\t  for (i = regno; i < endregno; i ++)\n+\t    if (TEST_HARD_REG_BIT (hard_regs_saved, i))\n+\t      insert_save_restore (insn, 0, i, insn_mode);\n+\t}\n+\n+      return;\n+    }\n+\t  \n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\trestore_referenced_regs (XEXP (x, i), insn, insn_mode);\n+      else if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  restore_referenced_regs (XVECEXP (x, i, j), insn, insn_mode);\n+    }\n+}\n+\f\n+/* Insert a sequence of insns to save or restore, SAVE_P says which,\n+   REGNO.  Place these insns in front of INSN.  INSN_MODE is the mode\n+   to assign to these insns. \n+\n+   Note that we have verified in init_caller_save that we can do this\n+   with a simple SET, so use it.  Set INSN_CODE to what we save there\n+   since the address might not be valid so the insn might not be recognized.\n+   These insns will be reloaded and have register elimination done by\n+   find_reload, so we need not worry about that here.  */\n+\n+static void\n+insert_save_restore (insn, save_p, regno, insn_mode)\n+     rtx insn;\n+     int save_p;\n+     int regno;\n+     enum machine_mode insn_mode;\n+{\n+  rtx pat;\n+  enum insn_code code;\n+  int i;\n+\n+  /* If INSN is a CALL_INSN, we must insert our insns before any\n+     USE insns in front of the CALL_INSN.  */\n+\n+  if (GET_CODE (insn) == CALL_INSN)\n+    while (GET_CODE (PREV_INSN (insn)) == INSN\n+\t   && GET_CODE (PATTERN (PREV_INSN (insn))) == USE)\n+      insn = PREV_INSN (insn);\n+\n+#ifdef HAVE_cc0\n+  /* If INSN references CC0, put our insns in front of the insn that sets\n+     CC0.  This is always safe, since the only way we could be passed an\n+     insn that references CC0 is for a restore, and doing a restore earlier\n+     isn't a problem.  We do, however, assume here that CALL_INSNs don't\n+     reference CC0.  Guard against non-INSN's like CODE_LABEL.  */\n+\n+  if ((GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n+      && reg_referenced_p (cc0_rtx, PATTERN (insn)))\n+    insn = prev_nonnote_insn (insn);\n+#endif\n+\n+  /* Get the pattern to emit and update our status.  */\n+  if (save_p)\n+    {\n+      pat = gen_rtx (SET, VOIDmode, regno_save_mem[regno],\n+\t\t     gen_rtx (REG, regno_save_mode[regno], regno));\n+      code = reg_save_code[regno];\n+      SET_HARD_REG_BIT (hard_regs_saved, regno);\n+      n_regs_saved++;\n+    }\n+  else\n+    {\n+      pat = gen_rtx (SET, VOIDmode,\n+\t\t     gen_rtx (REG, regno_save_mode[regno], regno),\n+\t\t     regno_save_mem[regno]);\n+      code = reg_restore_code[regno];\n+      CLEAR_HARD_REG_BIT (hard_regs_saved, regno);\n+      n_regs_saved--;\n+    }\n+\n+  /* Emit the insn and set the code and mode.  */\n+\n+  insn = emit_insn_before (pat, insn);\n+  PUT_MODE (insn, insn_mode);\n+  INSN_CODE (insn) = code;\n+}"}]}