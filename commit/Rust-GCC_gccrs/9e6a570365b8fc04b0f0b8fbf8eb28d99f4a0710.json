{"sha": "9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU2YTU3MDM2NWI4ZmMwNGIwZjBiOGZiZjhlYjI4ZDk5ZjRhMDcxMA==", "commit": {"author": {"name": "John Carr", "email": "jfc@mit.edu", "date": "1998-06-24T14:49:51Z"}, "committer": {"name": "John Carr", "email": "jfc@gcc.gnu.org", "date": "1998-06-24T14:49:51Z"}, "message": "optabs.c: Use gen_rtx_FOO (...) instead of gen_rtx (FOO, ...).\n\n\t* optabs.c: Use gen_rtx_FOO (...) instead of gen_rtx (FOO, ...).\n\t* expr.c: Likewise.\n\t* explow.c: Likewise.\n\t* combine.c: Likewise.\n\t* reload1.c: Likewise.\n\t* gcse.c: Likewise.\n\nFrom-SVN: r20701", "tree": {"sha": "67d082a77978c7a63cfc5e94cfd3024b41140b03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67d082a77978c7a63cfc5e94cfd3024b41140b03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710/comments", "author": {"login": "VoxSciurorum", "id": 60116679, "node_id": "MDQ6VXNlcjYwMTE2Njc5", "avatar_url": "https://avatars.githubusercontent.com/u/60116679?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VoxSciurorum", "html_url": "https://github.com/VoxSciurorum", "followers_url": "https://api.github.com/users/VoxSciurorum/followers", "following_url": "https://api.github.com/users/VoxSciurorum/following{/other_user}", "gists_url": "https://api.github.com/users/VoxSciurorum/gists{/gist_id}", "starred_url": "https://api.github.com/users/VoxSciurorum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VoxSciurorum/subscriptions", "organizations_url": "https://api.github.com/users/VoxSciurorum/orgs", "repos_url": "https://api.github.com/users/VoxSciurorum/repos", "events_url": "https://api.github.com/users/VoxSciurorum/events{/privacy}", "received_events_url": "https://api.github.com/users/VoxSciurorum/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "55a6ba9ff30131802ac5896dfc3807cce3e97e09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55a6ba9ff30131802ac5896dfc3807cce3e97e09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55a6ba9ff30131802ac5896dfc3807cce3e97e09"}], "stats": {"total": 401, "additions": 209, "deletions": 192}, "files": [{"sha": "b96011120ded6798c9313eaa78c7b7b5c3901e40", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710", "patch": "@@ -6,6 +6,13 @@ Wed Jun 24 16:27:23 1998  John Carr  <jfc@mit.edu>\n \n \t* expmed.c (init_expmed): Initialize all elements of *_cost arrays.\n \n+\t* optabs.c: Use gen_rtx_FOO (...) instead of gen_rtx (FOO, ...).\n+\t* expr.c: Likewise.\n+\t* explow.c: Likewise.\n+\t* combine.c: Likewise.\n+\t* reload1.c: Likewise.\n+\t* gcse.c: Likewise.\n+\n Wed Jun 24 15:13:01 1998  Dave Brolley  <brolley@cygnus.com>\n \n \t* README.gnat: Add patch for new lang_decode_options interface."}, {"sha": "f5252292494414718f752f5d4028ee2d9dca57a7", "filename": "gcc/combine.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710", "patch": "@@ -11552,8 +11552,9 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t\t  if (! find_regno_note (tem, REG_UNUSED,\n \t\t\t\t\t\t REGNO (XEXP (note, 0))))\n \t\t\t    REG_NOTES (tem)\n-\t\t\t      = gen_rtx (EXPR_LIST, REG_UNUSED, XEXP (note, 0),\n-\t\t\t\t\t REG_NOTES (tem));\n+\t\t\t      = gen_rtx_EXPR_LIST (REG_UNUSED,\n+\t\t\t\t\t\t   XEXP (note, 0),\n+\t\t\t\t\t\t   REG_NOTES (tem));\n \t\t\t}\n \t\t      else\n \t\t\t{"}, {"sha": "7c74d6a620f4a18cb1007e4c10ff49883943a1c9", "filename": "gcc/explow.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710", "patch": "@@ -1258,9 +1258,9 @@ allocate_dynamic_stack_space (size, target, known_align)\n \t{\n  \t  rtx note_target = get_last_insn ();\n \n-\t  REG_NOTES (note_target) = gen_rtx (EXPR_LIST, REG_SAVE_AREA,\n-\t\t\t\t\t     setjmpless_size,\n-\t\t\t\t\t     REG_NOTES (note_target));\n+\t  REG_NOTES (note_target)\n+\t    = gen_rtx_EXPR_LIST (REG_SAVE_AREA, setjmpless_size,\n+\t\t\t\t REG_NOTES (note_target));\n \t}\n #endif /* SETJMP_VIA_SAVE_AREA */\n #ifdef STACK_GROWS_DOWNWARD"}, {"sha": "ddb5bbbe418018f92ca1c1f60f9bf60d256f4e1d", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710", "patch": "@@ -2289,7 +2289,7 @@ emit_move_insn_1 (x, y)\n \t{\n \t  /* Show the output dies here.  */\n \t  if (x != y)\n-\t    emit_insn (gen_rtx (CLOBBER, VOIDmode, x));\n+\t    emit_insn (gen_rtx_CLOBBER (VOIDmode, x));\n \n \t  emit_insn (GEN_FCN (mov_optab->handlers[(int) submode].insn_code)\n \t\t     (gen_realpart (submode, x), gen_realpart (submode, y)));\n@@ -2639,7 +2639,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t    {\n \t      rtx opalign = GEN_INT (align);\n \t      enum machine_mode mode;\n-\t      rtx target = gen_rtx (MEM, BLKmode, temp);\n+\t      rtx target = gen_rtx_MEM (BLKmode, temp);\n \n \t      for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n \t\t   mode != VOIDmode;"}, {"sha": "c40f68730659c7292c2cb00fb6859134f5a55ad4", "filename": "gcc/gcse.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710", "patch": "@@ -805,8 +805,8 @@ compute_can_copy ()\n #ifdef AVOID_CCMODE_COPIES\n \t  can_copy_p[i] = 0;\n #else\n-\t  reg = gen_rtx (REG, (enum machine_mode) i, LAST_VIRTUAL_REGISTER + 1);\n-\t  insn = emit_insn (gen_rtx (SET, VOIDmode, reg, reg));\n+\t  reg = gen_rtx_REG ((enum machine_mode) i, LAST_VIRTUAL_REGISTER + 1);\n+\t  insn = emit_insn (gen_rtx_SET (VOIDmode, reg, reg));\n \t  if (recog (PATTERN (insn), insn, NULL_PTR) >= 0)\n \t    can_copy_p[i] = 1;\n #endif\n@@ -3139,8 +3139,9 @@ handle_avail_expr (insn, expr)\n       /* Generate the new insn.  */\n       /* ??? If the change fails, we return 0, even though we created\n \t an insn.  I think this is ok.  */\n-      new_insn = emit_insn_after (gen_rtx (SET, VOIDmode, to,\n-\t\t\t\t\t   SET_DEST (PATTERN (insn_computes_expr))),\n+      new_insn\n+\t= emit_insn_after (gen_rtx_SET (VOIDmode, to,\n+\t\t\t\t\tSET_DEST (PATTERN (insn_computes_expr))),\n \t\t\t\t  insn_computes_expr);\n       /* Keep block number table up to date.  */\n       set_block_num (new_insn, BLOCK_NUM (insn_computes_expr));\n@@ -4321,7 +4322,7 @@ pre_insert_insn (expr, bb)\n   int regno = REGNO (reg);\n   rtx pat;\n \n-  pat = gen_rtx (SET, VOIDmode, reg, copy_rtx (expr->expr));\n+  pat = gen_rtx_SET (VOIDmode, reg, copy_rtx (expr->expr));\n \n   /* If the last insn is a jump, insert EXPR in front [taking care to\n      handle cc0, etc. properly].  */\n@@ -4443,7 +4444,7 @@ pre_insert_copy_insn (expr, insn)\n \n   if (!set)\n     abort ();\n-  new_insn = emit_insn_after (gen_rtx (SET, VOIDmode, reg, SET_DEST (set)),\n+  new_insn = emit_insn_after (gen_rtx_SET (VOIDmode, reg, SET_DEST (set)),\n \t\t\t      insn);\n   /* Keep block number table up to date.  */\n   set_block_num (new_insn, BLOCK_NUM (insn));"}, {"sha": "4b31fe0d106433960ea3f0e098e20e7d40218026", "filename": "gcc/optabs.c", "status": "modified", "additions": 185, "deletions": 177, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710", "patch": "@@ -293,13 +293,13 @@ add_equal_note (seq, target, code, op0, op1)\n \treturn 0;\n \n   if (GET_RTX_CLASS (code) == '1')\n-    note = gen_rtx (code, GET_MODE (target), copy_rtx (op0));\n+    note = gen_rtx_fmt_e (code, GET_MODE (target), copy_rtx (op0));\n   else\n-    note = gen_rtx (code, GET_MODE (target), copy_rtx (op0), copy_rtx (op1));\n+    note = gen_rtx_fmt_ee (code, GET_MODE (target), copy_rtx (op0), copy_rtx (op1));\n \n   REG_NOTES (XVECEXP (seq, 0, XVECLEN (seq, 0) - 1))\n-    = gen_rtx (EXPR_LIST, REG_EQUAL, note,\n-\t       REG_NOTES (XVECEXP (seq, 0, XVECLEN (seq, 0) - 1)));\n+    = gen_rtx_EXPR_LIST (REG_EQUAL, note,\n+\t\t\t REG_NOTES (XVECEXP (seq, 0, XVECLEN (seq, 0) - 1)));\n \n   return 1;\n }\n@@ -330,13 +330,13 @@ widen_operand (op, mode, oldmode, unsignedp, no_extend)\n   /* If MODE is no wider than a single word, we return a paradoxical\n      SUBREG.  */\n   if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD)\n-    return gen_rtx (SUBREG, mode, force_reg (GET_MODE (op), op), 0);\n+    return gen_rtx_SUBREG (mode, force_reg (GET_MODE (op), op), 0);\n \n   /* Otherwise, get an object of MODE, clobber it, and set the low-order\n      part to OP.  */\n \n   result = gen_reg_rtx (mode);\n-  emit_insn (gen_rtx (CLOBBER, VOIDmode, result));\n+  emit_insn (gen_rtx_CLOBBER (VOIDmode, result));\n   emit_move_insn (gen_lowpart (GET_MODE (op), result), op);\n   return result;\n }\n@@ -630,7 +630,8 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t{\n \t  if (binoptab->code != UNKNOWN)\n \t    equiv_value\n-\t      = gen_rtx (binoptab->code, mode, copy_rtx (op0), copy_rtx (op1));\n+\t      = gen_rtx_fmt_ee (binoptab->code, mode,\n+\t\t\t\tcopy_rtx (op0), copy_rtx (op1));\n \t  else\n \t    equiv_value = 0;\n \n@@ -749,7 +750,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       if (inter != 0)\n \t{\n \t  if (binoptab->code != UNKNOWN)\n-\t    equiv_value = gen_rtx (binoptab->code, mode, op0, op1);\n+\t    equiv_value = gen_rtx_fmt_ee (binoptab->code, mode, op0, op1);\n \t  else\n \t    equiv_value = 0;\n \n@@ -863,7 +864,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       if (inter != 0)\n \t{\n \t  if (binoptab->code != UNKNOWN)\n-\t    equiv_value = gen_rtx (binoptab->code, mode, op0, op1);\n+\t    equiv_value = gen_rtx_fmt_ee (binoptab->code, mode, op0, op1);\n \t  else\n \t    equiv_value = 0;\n \n@@ -912,7 +913,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n       /* Indicate for flow that the entire target reg is being set.  */\n       if (GET_CODE (target) == REG)\n-\temit_insn (gen_rtx (CLOBBER, VOIDmode, target));\n+\temit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n \n       /* Do the actual arithmetic.  */\n       for (i = 0; i < nwords; i++)\n@@ -981,11 +982,12 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t    {\n \t      rtx temp = emit_move_insn (target, target);\n \n-\t      REG_NOTES (temp) = gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t\t\t  gen_rtx (binoptab->code, mode,\n-\t\t\t\t\t\t   copy_rtx (xop0),\n-\t\t\t\t\t\t   copy_rtx (xop1)),\n-\t\t\t\t\t  REG_NOTES (temp));\n+\t      REG_NOTES (temp)\n+\t\t= gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t\t\t\t     gen_rtx_fmt_ee (binoptab->code, mode,\n+\t\t\t\t\t\t     copy_rtx (xop0),\n+\t\t\t\t\t\t     copy_rtx (xop1)),\n+\t\t\t\t     REG_NOTES (temp));\n \t    }\n \t  return target;\n \t}\n@@ -1163,11 +1165,12 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t      if (mov_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n \t\t{\n \t\t  temp = emit_move_insn (product, product);\n-\t\t  REG_NOTES (temp) = gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t\t\t      gen_rtx (MULT, mode,\n-\t\t\t\t\t\t       copy_rtx (op0),\n-\t\t\t\t\t\t       copy_rtx (op1)),\n-\t\t\t\t\t      REG_NOTES (temp));\n+\t\t  REG_NOTES (temp)\n+\t\t    = gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t\t\t\t\t gen_rtx_fmt_ee (MULT, mode,\n+\t\t\t\t\t\t\t copy_rtx (op0),\n+\t\t\t\t\t\t\t copy_rtx (op1)),\n+\t\t\t\t\t REG_NOTES (temp));\n \t\t}\n \t      return product;\n \t    }\n@@ -1501,7 +1504,8 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t{\n \t  if (binoptab->code != UNKNOWN)\n \t    equiv_value\n-\t      = gen_rtx (binoptab->code, mode, copy_rtx (op0), copy_rtx (op1));\n+\t      = gen_rtx_fmt_ee (binoptab->code, mode,\n+\t\t\t\tcopy_rtx (op0), copy_rtx (op1));\n \t  else\n \t    equiv_value = 0;\n \t  \n@@ -1547,7 +1551,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n       target = gen_reg_rtx (mode);\n       emit_libcall_block (insns, target, value,\n-\t\t\t  gen_rtx (binoptab->code, mode, op0, op1));\n+\t\t\t  gen_rtx_fmt_ee (binoptab->code, mode, op0, op1));\n \n       return target;\n     }\n@@ -1961,7 +1965,8 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n       end_sequence ();\n \n       emit_no_conflict_block (insns, target, op0, NULL_RTX,\n-\t\t\t      gen_rtx (unoptab->code, mode, copy_rtx (op0)));\n+\t\t\t      gen_rtx_fmt_e (unoptab->code, mode,\n+\t\t\t\t\t     copy_rtx (op0)));\n       return target;\n     }\n \n@@ -2005,7 +2010,8 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n       end_sequence ();\n \n       emit_no_conflict_block (seq, target, op0, 0,\n-\t\t\t      gen_rtx (unoptab->code, mode, copy_rtx (op0)));\n+\t\t\t      gen_rtx_fmt_e (unoptab->code, mode,\n+\t\t\t\t\t     copy_rtx (op0)));\n       return target;\n     }\n \n@@ -2026,7 +2032,7 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n \n       target = gen_reg_rtx (mode);\n       emit_libcall_block (insns, target, value,\n-\t\t\t  gen_rtx (unoptab->code, mode, op0));\n+\t\t\t  gen_rtx_fmt_e (unoptab->code, mode, op0));\n \n       return target;\n     }\n@@ -2335,7 +2341,7 @@ expand_complex_abs (mode, op0, target, unsignedp)\n \n       target = gen_reg_rtx (submode);\n       emit_libcall_block (insns, target, value,\n-\t\t\t  gen_rtx (abs_optab->code, mode, op0));\n+\t\t\t  gen_rtx_fmt_e (abs_optab->code, mode, op0));\n \n       return target;\n     }\n@@ -2511,20 +2517,20 @@ emit_no_conflict_block (insns, target, op0, op1, equiv)\n   /* Now write the CLOBBER of the output, followed by the setting of each\n      of the words, followed by the final copy.  */\n   if (target != op0 && target != op1)\n-    emit_insn (gen_rtx (CLOBBER, VOIDmode, target));\n+    emit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n \n   for (insn = insns; insn; insn = next)\n     {\n       next = NEXT_INSN (insn);\n       add_insn (insn);\n \n       if (op1 && GET_CODE (op1) == REG)\n-\tREG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_NO_CONFLICT, op1,\n-\t\t\t\t    REG_NOTES (insn));\n+\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_NO_CONFLICT, op1,\n+\t\t\t\t\t      REG_NOTES (insn));\n \n       if (op0 && GET_CODE (op0) == REG)\n-\tREG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_NO_CONFLICT, op0,\n-\t\t\t\t    REG_NOTES (insn));\n+\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_NO_CONFLICT, op0,\n+\t\t\t\t\t      REG_NOTES (insn));\n     }\n \n   if (mov_optab->handlers[(int) GET_MODE (target)].insn_code\n@@ -2533,7 +2539,7 @@ emit_no_conflict_block (insns, target, op0, op1, equiv)\n       last = emit_move_insn (target, target);\n       if (equiv)\n \tREG_NOTES (last)\n-\t  = gen_rtx (EXPR_LIST, REG_EQUAL, equiv, REG_NOTES (last));\n+\t  = gen_rtx_EXPR_LIST (REG_EQUAL, equiv, REG_NOTES (last));\n     }\n   else\n     last = get_last_insn ();\n@@ -2544,9 +2550,9 @@ emit_no_conflict_block (insns, target, op0, op1, equiv)\n     first = NEXT_INSN (prev);\n \n   /* Encapsulate the block so it gets manipulated as a unit.  */\n-  REG_NOTES (first) = gen_rtx (INSN_LIST, REG_LIBCALL, last,\n-\t\t\t       REG_NOTES (first));\n-  REG_NOTES (last) = gen_rtx (INSN_LIST, REG_RETVAL, first, REG_NOTES (last));\n+  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last,\n+\t\t\t\t\t REG_NOTES (first));\n+  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n \n   return last;\n }\n@@ -2631,18 +2637,18 @@ emit_libcall_block (insns, target, result, equiv)\n   last = emit_move_insn (target, result);\n   if (mov_optab->handlers[(int) GET_MODE (target)].insn_code\n       != CODE_FOR_nothing)\n-    REG_NOTES (last) = gen_rtx (EXPR_LIST,\n-\t\t\t\tREG_EQUAL, copy_rtx (equiv), REG_NOTES (last));\n+    REG_NOTES (last) = gen_rtx_EXPR_LIST (REG_EQUAL, copy_rtx (equiv),\n+\t\t\t\t\t  REG_NOTES (last));\n \n   if (prev == 0)\n     first = get_insns ();\n   else\n     first = NEXT_INSN (prev);\n \n   /* Encapsulate the block so it gets manipulated as a unit.  */\n-  REG_NOTES (first) = gen_rtx (INSN_LIST, REG_LIBCALL, last,\n-\t\t\t       REG_NOTES (first));\n-  REG_NOTES (last) = gen_rtx (INSN_LIST, REG_RETVAL, first, REG_NOTES (last));\n+  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last,\n+\t\t\t\t\t REG_NOTES (first));\n+  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n }\n \f\n /* Generate code to store zero in X.  */\n@@ -3376,7 +3382,7 @@ gen_move_insn (x, y)\n \t  x = gen_lowpart_common (tmode, x1);\n \t  if (x == 0 && GET_CODE (x1) == MEM)\n \t    {\n-\t      x = gen_rtx (MEM, tmode, XEXP (x1, 0));\n+\t      x = gen_rtx_MEM (tmode, XEXP (x1, 0));\n \t      RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (x1);\n \t      MEM_IN_STRUCT_P (x) = MEM_IN_STRUCT_P (x1);\n \t      MEM_VOLATILE_P (x) = MEM_VOLATILE_P (x1);\n@@ -3386,7 +3392,7 @@ gen_move_insn (x, y)\n \t  y = gen_lowpart_common (tmode, y1);\n \t  if (y == 0 && GET_CODE (y1) == MEM)\n \t    {\n-\t      y = gen_rtx (MEM, tmode, XEXP (y1, 0));\n+\t      y = gen_rtx_MEM (tmode, XEXP (y1, 0));\n \t      RTX_UNCHANGING_P (y) = RTX_UNCHANGING_P (y1);\n \t      MEM_IN_STRUCT_P (y) = MEM_IN_STRUCT_P (y1);\n \t      MEM_VOLATILE_P (y) = MEM_VOLATILE_P (y1);\n@@ -3714,7 +3720,7 @@ expand_float (to, from, unsignedp)\n       end_sequence ();\n \n       emit_libcall_block (insns, target, value,\n-\t\t\t  gen_rtx (FLOAT, GET_MODE (to), from));\n+\t\t\t  gen_rtx_FLOAT (GET_MODE (to), from));\n     }\n \n  done:\n@@ -3860,10 +3866,12 @@ expand_fix (to, from, unsignedp)\n \t    {\n \t      /* Make a place for a REG_NOTE and add it.  */\n \t      insn = emit_move_insn (to, to);\n-\t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t\t\t  gen_rtx (UNSIGNED_FIX, GET_MODE (to),\n-\t\t\t\t\t\t   copy_rtx (from)),\n-\t\t\t\t\t  REG_NOTES (insn));\n+\t      REG_NOTES (insn)\n+\t\t= gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t\t\t\t     gen_rtx_fmt_e (UNSIGNED_FIX,\n+\t\t\t\t\t\t    GET_MODE (to),\n+\t\t\t\t\t\t    copy_rtx (from)),\n+\t\t\t\t     REG_NOTES (insn));\n \t    }\n \t  return;\n \t}\n@@ -3946,8 +3954,8 @@ expand_fix (to, from, unsignedp)\n       end_sequence ();\n \n       emit_libcall_block (insns, target, value,\n-\t\t\t  gen_rtx (unsignedp ? UNSIGNED_FIX : FIX,\n-\t\t\t\t   GET_MODE (to), from));\n+\t\t\t  gen_rtx_fmt_e (unsignedp ? UNSIGNED_FIX : FIX,\n+\t\t\t\t\t GET_MODE (to), from));\n     }\n       \n   if (target != to)\n@@ -4026,7 +4034,7 @@ init_libfuncs (optable, first_mode, last_mode, opname, suffix)\n       *p++ = suffix;\n       *p++ = '\\0';\n       optable->handlers[(int) mode].libfunc\n-\t= gen_rtx (SYMBOL_REF, Pmode, libfunc_name);\n+\t= gen_rtx_SYMBOL_REF (Pmode, libfunc_name);\n     }\n }\n \n@@ -4207,181 +4215,181 @@ init_optabs ()\n \n #ifdef MULSI3_LIBCALL\n   smul_optab->handlers[(int) SImode].libfunc\n-    = gen_rtx (SYMBOL_REF, Pmode, MULSI3_LIBCALL);\n+    = gen_rtx_SYMBOL_REF (Pmode, MULSI3_LIBCALL);\n #endif\n #ifdef MULDI3_LIBCALL\n   smul_optab->handlers[(int) DImode].libfunc\n-    = gen_rtx (SYMBOL_REF, Pmode, MULDI3_LIBCALL);\n+    = gen_rtx_SYMBOL_REF (Pmode, MULDI3_LIBCALL);\n #endif\n \n #ifdef DIVSI3_LIBCALL\n   sdiv_optab->handlers[(int) SImode].libfunc\n-    = gen_rtx (SYMBOL_REF, Pmode, DIVSI3_LIBCALL);\n+    = gen_rtx_SYMBOL_REF (Pmode, DIVSI3_LIBCALL);\n #endif\n #ifdef DIVDI3_LIBCALL\n   sdiv_optab->handlers[(int) DImode].libfunc\n-    = gen_rtx (SYMBOL_REF, Pmode, DIVDI3_LIBCALL);\n+    = gen_rtx_SYMBOL_REF (Pmode, DIVDI3_LIBCALL);\n #endif\n \n #ifdef UDIVSI3_LIBCALL\n   udiv_optab->handlers[(int) SImode].libfunc\n-    = gen_rtx (SYMBOL_REF, Pmode, UDIVSI3_LIBCALL);\n+    = gen_rtx_SYMBOL_REF (Pmode, UDIVSI3_LIBCALL);\n #endif\n #ifdef UDIVDI3_LIBCALL\n   udiv_optab->handlers[(int) DImode].libfunc\n-    = gen_rtx (SYMBOL_REF, Pmode, UDIVDI3_LIBCALL);\n+    = gen_rtx_SYMBOL_REF (Pmode, UDIVDI3_LIBCALL);\n #endif\n \n #ifdef MODSI3_LIBCALL\n   smod_optab->handlers[(int) SImode].libfunc\n-    = gen_rtx (SYMBOL_REF, Pmode, MODSI3_LIBCALL);\n+    = gen_rtx_SYMBOL_REF (Pmode, MODSI3_LIBCALL);\n #endif\n #ifdef MODDI3_LIBCALL\n   smod_optab->handlers[(int) DImode].libfunc\n-    = gen_rtx (SYMBOL_REF, Pmode, MODDI3_LIBCALL);\n+    = gen_rtx_SYMBOL_REF (Pmode, MODDI3_LIBCALL);\n #endif\n \n #ifdef UMODSI3_LIBCALL\n   umod_optab->handlers[(int) SImode].libfunc\n-    = gen_rtx (SYMBOL_REF, Pmode, UMODSI3_LIBCALL);\n+    = gen_rtx_SYMBOL_REF (Pmode, UMODSI3_LIBCALL);\n #endif\n #ifdef UMODDI3_LIBCALL\n   umod_optab->handlers[(int) DImode].libfunc\n-    = gen_rtx (SYMBOL_REF, Pmode, UMODDI3_LIBCALL);\n+    = gen_rtx_SYMBOL_REF (Pmode, UMODDI3_LIBCALL);\n #endif\n \n   /* Use cabs for DC complex abs, since systems generally have cabs.\n      Don't define any libcall for SCmode, so that cabs will be used.  */\n   abs_optab->handlers[(int) DCmode].libfunc\n-    = gen_rtx (SYMBOL_REF, Pmode, \"cabs\");\n+    = gen_rtx_SYMBOL_REF (Pmode, \"cabs\");\n \n   /* The ffs function operates on `int'.  */\n #ifndef INT_TYPE_SIZE\n #define INT_TYPE_SIZE BITS_PER_WORD\n #endif\n   ffs_optab->handlers[(int) mode_for_size (INT_TYPE_SIZE, MODE_INT, 0)] .libfunc\n-    = gen_rtx (SYMBOL_REF, Pmode, \"ffs\");\n-\n-  extendsfdf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__extendsfdf2\");\n-  extendsfxf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__extendsfxf2\");\n-  extendsftf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__extendsftf2\");\n-  extenddfxf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__extenddfxf2\");\n-  extenddftf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__extenddftf2\");\n-\n-  truncdfsf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__truncdfsf2\");\n-  truncxfsf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__truncxfsf2\");\n-  trunctfsf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__trunctfsf2\");\n-  truncxfdf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__truncxfdf2\");\n-  trunctfdf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__trunctfdf2\");\n-\n-  memcpy_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"memcpy\");\n-  bcopy_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"bcopy\");\n-  memcmp_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"memcmp\");\n-  bcmp_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__gcc_bcmp\");\n-  memset_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"memset\");\n-  bzero_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"bzero\");\n-\n-  throw_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__throw\");\n-  sjthrow_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__sjthrow\");\n-  sjpopnthrow_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__sjpopnthrow\");\n-  terminate_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__terminate\");\n+    = gen_rtx_SYMBOL_REF (Pmode, \"ffs\");\n+\n+  extendsfdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__extendsfdf2\");\n+  extendsfxf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__extendsfxf2\");\n+  extendsftf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__extendsftf2\");\n+  extenddfxf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__extenddfxf2\");\n+  extenddftf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__extenddftf2\");\n+\n+  truncdfsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__truncdfsf2\");\n+  truncxfsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__truncxfsf2\");\n+  trunctfsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__trunctfsf2\");\n+  truncxfdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__truncxfdf2\");\n+  trunctfdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__trunctfdf2\");\n+\n+  memcpy_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"memcpy\");\n+  bcopy_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"bcopy\");\n+  memcmp_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"memcmp\");\n+  bcmp_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gcc_bcmp\");\n+  memset_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"memset\");\n+  bzero_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"bzero\");\n+\n+  throw_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__throw\");\n+  sjthrow_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__sjthrow\");\n+  sjpopnthrow_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__sjpopnthrow\");\n+  terminate_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__terminate\");\n #ifndef DONT_USE_BUILTIN_SETJMP\n-  setjmp_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__builtin_setjmp\");\n-  longjmp_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__builtin_longjmp\");\n+  setjmp_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__builtin_setjmp\");\n+  longjmp_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__builtin_longjmp\");\n #else\n-  setjmp_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"setjmp\");\n-  longjmp_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"longjmp\");\n+  setjmp_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"setjmp\");\n+  longjmp_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"longjmp\");\n #endif\n \n-  eqhf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__eqhf2\");\n-  nehf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__nehf2\");\n-  gthf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__gthf2\");\n-  gehf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__gehf2\");\n-  lthf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__lthf2\");\n-  lehf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__lehf2\");\n-\n-  eqsf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__eqsf2\");\n-  nesf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__nesf2\");\n-  gtsf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__gtsf2\");\n-  gesf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__gesf2\");\n-  ltsf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__ltsf2\");\n-  lesf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__lesf2\");\n-\n-  eqdf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__eqdf2\");\n-  nedf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__nedf2\");\n-  gtdf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__gtdf2\");\n-  gedf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__gedf2\");\n-  ltdf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__ltdf2\");\n-  ledf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__ledf2\");\n-\n-  eqxf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__eqxf2\");\n-  nexf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__nexf2\");\n-  gtxf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__gtxf2\");\n-  gexf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__gexf2\");\n-  ltxf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__ltxf2\");\n-  lexf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__lexf2\");\n-\n-  eqtf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__eqtf2\");\n-  netf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__netf2\");\n-  gttf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__gttf2\");\n-  getf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__getf2\");\n-  lttf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__lttf2\");\n-  letf2_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__letf2\");\n-\n-  floatsisf_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__floatsisf\");\n-  floatdisf_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__floatdisf\");\n-  floattisf_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__floattisf\");\n-\n-  floatsidf_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__floatsidf\");\n-  floatdidf_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__floatdidf\");\n-  floattidf_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__floattidf\");\n-\n-  floatsixf_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__floatsixf\");\n-  floatdixf_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__floatdixf\");\n-  floattixf_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__floattixf\");\n-\n-  floatsitf_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__floatsitf\");\n-  floatditf_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__floatditf\");\n-  floattitf_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__floattitf\");\n-\n-  fixsfsi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixsfsi\");\n-  fixsfdi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixsfdi\");\n-  fixsfti_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixsfti\");\n-\n-  fixdfsi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixdfsi\");\n-  fixdfdi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixdfdi\");\n-  fixdfti_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixdfti\");\n-\n-  fixxfsi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixxfsi\");\n-  fixxfdi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixxfdi\");\n-  fixxfti_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixxfti\");\n-\n-  fixtfsi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixtfsi\");\n-  fixtfdi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixtfdi\");\n-  fixtfti_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixtfti\");\n-\n-  fixunssfsi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixunssfsi\");\n-  fixunssfdi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixunssfdi\");\n-  fixunssfti_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixunssfti\");\n-\n-  fixunsdfsi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixunsdfsi\");\n-  fixunsdfdi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixunsdfdi\");\n-  fixunsdfti_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixunsdfti\");\n-\n-  fixunsxfsi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixunsxfsi\");\n-  fixunsxfdi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixunsxfdi\");\n-  fixunsxfti_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixunsxfti\");\n-\n-  fixunstfsi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixunstfsi\");\n-  fixunstfdi_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixunstfdi\");\n-  fixunstfti_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__fixunstfti\");\n+  eqhf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__eqhf2\");\n+  nehf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__nehf2\");\n+  gthf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gthf2\");\n+  gehf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gehf2\");\n+  lthf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__lthf2\");\n+  lehf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__lehf2\");\n+\n+  eqsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__eqsf2\");\n+  nesf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__nesf2\");\n+  gtsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gtsf2\");\n+  gesf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gesf2\");\n+  ltsf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__ltsf2\");\n+  lesf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__lesf2\");\n+\n+  eqdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__eqdf2\");\n+  nedf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__nedf2\");\n+  gtdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gtdf2\");\n+  gedf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gedf2\");\n+  ltdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__ltdf2\");\n+  ledf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__ledf2\");\n+\n+  eqxf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__eqxf2\");\n+  nexf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__nexf2\");\n+  gtxf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gtxf2\");\n+  gexf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gexf2\");\n+  ltxf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__ltxf2\");\n+  lexf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__lexf2\");\n+\n+  eqtf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__eqtf2\");\n+  netf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__netf2\");\n+  gttf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__gttf2\");\n+  getf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__getf2\");\n+  lttf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__lttf2\");\n+  letf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__letf2\");\n+\n+  floatsisf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floatsisf\");\n+  floatdisf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floatdisf\");\n+  floattisf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floattisf\");\n+\n+  floatsidf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floatsidf\");\n+  floatdidf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floatdidf\");\n+  floattidf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floattidf\");\n+\n+  floatsixf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floatsixf\");\n+  floatdixf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floatdixf\");\n+  floattixf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floattixf\");\n+\n+  floatsitf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floatsitf\");\n+  floatditf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floatditf\");\n+  floattitf_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__floattitf\");\n+\n+  fixsfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixsfsi\");\n+  fixsfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixsfdi\");\n+  fixsfti_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixsfti\");\n+\n+  fixdfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixdfsi\");\n+  fixdfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixdfdi\");\n+  fixdfti_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixdfti\");\n+\n+  fixxfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixxfsi\");\n+  fixxfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixxfdi\");\n+  fixxfti_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixxfti\");\n+\n+  fixtfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixtfsi\");\n+  fixtfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixtfdi\");\n+  fixtfti_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixtfti\");\n+\n+  fixunssfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunssfsi\");\n+  fixunssfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunssfdi\");\n+  fixunssfti_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunssfti\");\n+\n+  fixunsdfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunsdfsi\");\n+  fixunsdfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunsdfdi\");\n+  fixunsdfti_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunsdfti\");\n+\n+  fixunsxfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunsxfsi\");\n+  fixunsxfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunsxfdi\");\n+  fixunsxfti_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunsxfti\");\n+\n+  fixunstfsi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunstfsi\");\n+  fixunstfdi_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunstfdi\");\n+  fixunstfti_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"__fixunstfti\");\n \n   /* For check-memory-usage.  */\n-  chkr_check_addr_libfunc = gen_rtx (SYMBOL_REF, VOIDmode, \"chkr_check_addr\");\n-  chkr_set_right_libfunc = gen_rtx (SYMBOL_REF, VOIDmode, \"chkr_set_right\");\n-  chkr_copy_bitmap_libfunc = gen_rtx (SYMBOL_REF, VOIDmode, \"chkr_copy_bitmap\");\n-  chkr_check_exec_libfunc = gen_rtx (SYMBOL_REF, VOIDmode, \"chkr_check_exec\");\n-  chkr_check_str_libfunc = gen_rtx (SYMBOL_REF, VOIDmode, \"chkr_check_str\");\n+  chkr_check_addr_libfunc = gen_rtx_SYMBOL_REF (VOIDmode, \"chkr_check_addr\");\n+  chkr_set_right_libfunc = gen_rtx_SYMBOL_REF (VOIDmode, \"chkr_set_right\");\n+  chkr_copy_bitmap_libfunc = gen_rtx_SYMBOL_REF (VOIDmode, \"chkr_copy_bitmap\");\n+  chkr_check_exec_libfunc = gen_rtx_SYMBOL_REF (VOIDmode, \"chkr_check_exec\");\n+  chkr_check_str_libfunc = gen_rtx_SYMBOL_REF (VOIDmode, \"chkr_check_str\");\n \n #ifdef HAVE_conditional_trap\n   init_traps ();"}, {"sha": "9acf695679af997c1eeeeaeb54b59e649b963f53", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=9e6a570365b8fc04b0f0b8fbf8eb28d99f4a0710", "patch": "@@ -7478,7 +7478,7 @@ gen_reload (out, in, opnum, type)\n \t    {\n \t      /* Add a REG_EQUIV note so that find_equiv_reg can find it.  */\n \t      REG_NOTES (insn)\n-\t\t= gen_rtx (EXPR_LIST, REG_EQUIV, in, REG_NOTES (insn));\n+\t\t= gen_rtx_EXPR_LIST (REG_EQUIV, in, REG_NOTES (insn));\n \t      return insn;\n \t    }\n \t}\n@@ -7487,7 +7487,7 @@ gen_reload (out, in, opnum, type)\n \n       gen_reload (out, op1, opnum, type);\n       insn = emit_insn (gen_add2_insn (out, op0));\n-      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUIV, in, REG_NOTES (insn));\n+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUIV, in, REG_NOTES (insn));\n     }\n \n #ifdef SECONDARY_MEMORY_NEEDED"}]}