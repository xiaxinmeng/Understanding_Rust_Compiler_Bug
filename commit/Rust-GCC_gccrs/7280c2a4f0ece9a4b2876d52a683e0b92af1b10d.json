{"sha": "7280c2a4f0ece9a4b2876d52a683e0b92af1b10d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI4MGMyYTRmMGVjZTlhNGIyODc2ZDUyYTY4M2UwYjkyYWYxYjEwZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-08-11T17:13:20Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-08-11T17:13:20Z"}, "message": "(find_auto_inc): Ensure that all proposed changes to insns are valid\nbefore commiting to the auto-inc.\n\nFrom-SVN: r7889", "tree": {"sha": "daa93e7b258d3f391cc33d99d21c8b2066fd6f10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/daa93e7b258d3f391cc33d99d21c8b2066fd6f10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7280c2a4f0ece9a4b2876d52a683e0b92af1b10d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7280c2a4f0ece9a4b2876d52a683e0b92af1b10d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7280c2a4f0ece9a4b2876d52a683e0b92af1b10d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7280c2a4f0ece9a4b2876d52a683e0b92af1b10d/comments", "author": null, "committer": null, "parents": [{"sha": "70a76f06adf9437d513e97acc4a169a4a140b4bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70a76f06adf9437d513e97acc4a169a4a140b4bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70a76f06adf9437d513e97acc4a169a4a140b4bb"}], "stats": {"total": 100, "additions": 56, "deletions": 44}, "files": [{"sha": "56c5ca737e119ae6bb63bace95bad19ac3e9bec0", "filename": "gcc/flow.c", "status": "modified", "additions": 56, "deletions": 44, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7280c2a4f0ece9a4b2876d52a683e0b92af1b10d/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7280c2a4f0ece9a4b2876d52a683e0b92af1b10d/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=7280c2a4f0ece9a4b2876d52a683e0b92af1b10d", "patch": "@@ -2090,11 +2090,21 @@ find_auto_inc (needed, x, insn)\n \t  && (use = find_use_as_address (PATTERN (insn), addr, offset),\n \t      use != 0 && use != (rtx) 1))\n \t{\n-\t  int win = 0;\n \t  rtx q = SET_DEST (set);\n+\t  enum rtx_code inc_code = (INTVAL (XEXP (y, 1)) == size\n+\t\t\t\t    ? (offset ? PRE_INC : POST_INC)\n+\t\t\t\t    : (offset ? PRE_DEC : POST_DEC));\n \n \t  if (dead_or_set_p (incr, addr))\n-\t    win = 1;\n+\t    {\n+\t      /* This is the simple case.  Try to make the auto-inc.  If\n+\t\t we can't, we are done.  Otherwise, we will do any\n+\t\t needed updates below.  */\n+\t      if (! validate_change (insn, &XEXP (x, 0),\n+\t\t\t\t     gen_rtx (inc_code, Pmode, addr),\n+\t\t\t\t     0))\n+\t\treturn;\n+\t    }\n \t  else if (GET_CODE (q) == REG\n \t\t   /* PREV_INSN used here to check the semi-open interval\n \t\t      [insn,incr).  */\n@@ -2122,14 +2132,25 @@ find_auto_inc (needed, x, insn)\n \t\t  BLOCK_NUM (temp) = BLOCK_NUM (insn);\n \t\t}\n \n+\t      /* If we can't make the auto-inc, or can't make the\n+\t\t replacement into Y, exit.  There's no point in making\n+\t\t the change below if we can't do the auto-inc and doing\n+\t\t so is not correct in the pre-inc case.  */\n+\n+\t      validate_change (insn, &XEXP (x, 0),\n+\t\t\t       gen_rtx (inc_code, Pmode, q),\n+\t\t\t       1);\n+\t      validate_change (incr, &XEXP (y, 0), q, 1);\n+\t      if (! apply_change_group ())\n+\t\treturn;\n+\n+\t      /* We now know we'll be doing this change, so emit the\n+\t\t new insn(s) and do the updates.  */\n \t      emit_insns_before (insns, insn);\n \n \t      if (basic_block_head[BLOCK_NUM (insn)] == insn)\n \t\tbasic_block_head[BLOCK_NUM (insn)] = insns;\n \n-\t      XEXP (x, 0) = q;\n-\t      XEXP (y, 0) = q;\n-\n \t      /* INCR will become a NOTE and INSN won't contain a\n \t\t use of ADDR.  If a use of ADDR was just placed in\n \t\t the insn before INSN, make that the next use. \n@@ -2143,7 +2164,6 @@ find_auto_inc (needed, x, insn)\n \n \t      addr = q;\n \t      regno = REGNO (q);\n-\t      win = 1;\n \n \t      /* REGNO is now used in INCR which is below INSN, but\n \t\t it previously wasn't live here.  If we don't mark\n@@ -2159,46 +2179,38 @@ find_auto_inc (needed, x, insn)\n \t\t  reg_n_calls_crossed[regno]++;\n \t    }\n \n-\t  if (win\n-\t      /* If we have found a suitable auto-increment, do\n-\t\t POST_INC around the register here, and patch out the\n-\t\t increment instruction that follows. */\n-\t      && validate_change (insn, &XEXP (x, 0),\n-\t\t\t\t  gen_rtx ((INTVAL (XEXP (y, 1)) == size\n-\t\t\t\t\t    ? (offset ? PRE_INC : POST_INC)\n-\t\t\t\t\t    : (offset ? PRE_DEC : POST_DEC)),\n-\t\t\t\t\t   Pmode, addr), 0))\n+\t  /* If we haven't returned, it means we were able to make the\n+\t     auto-inc, so update the status.  First, record that this insn\n+\t     has an implicit side effect.  */\n+\n+\t  REG_NOTES (insn)\n+\t    = gen_rtx (EXPR_LIST, REG_INC, addr, REG_NOTES (insn));\n+\n+\t  /* Modify the old increment-insn to simply copy\n+\t     the already-incremented value of our register.  */\n+\t  if (! validate_change (incr, &SET_SRC (set), addr, 0))\n+\t    abort ();\n+\n+\t  /* If that makes it a no-op (copying the register into itself) delete\n+\t     it so it won't appear to be a \"use\" and a \"set\" of this\n+\t     register.  */\n+\t  if (SET_DEST (set) == addr)\n+\t    {\n+\t      PUT_CODE (incr, NOTE);\n+\t      NOTE_LINE_NUMBER (incr) = NOTE_INSN_DELETED;\n+\t      NOTE_SOURCE_FILE (incr) = 0;\n+\t    }\n+\n+\t  if (regno >= FIRST_PSEUDO_REGISTER)\n \t    {\n-\t      /* Record that this insn has an implicit side effect.  */\n-\t      REG_NOTES (insn)\n-\t\t= gen_rtx (EXPR_LIST, REG_INC, addr, REG_NOTES (insn));\n-\n-\t      /* Modify the old increment-insn to simply copy\n-\t\t the already-incremented value of our register.  */\n-\t      SET_SRC (set) = addr;\n-\t      /* Indicate insn must be re-recognized.  */\n-\t      INSN_CODE (incr) = -1;\n-\n-\t      /* If that makes it a no-op (copying the register into itself)\n-\t\t then delete it so it won't appear to be a \"use\" and a \"set\"\n-\t\t of this register.  */\n-\t      if (SET_DEST (set) == addr)\n-\t\t{\n-\t\t  PUT_CODE (incr, NOTE);\n-\t\t  NOTE_LINE_NUMBER (incr) = NOTE_INSN_DELETED;\n-\t\t  NOTE_SOURCE_FILE (incr) = 0;\n-\t\t}\n+\t      /* Count an extra reference to the reg.  When a reg is\n+\t\t incremented, spilling it is worse, so we want to make\n+\t\t that less likely.  */\n+\t      reg_n_refs[regno] += loop_depth;\n \n-\t      if (regno >= FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  /* Count an extra reference to the reg.  When a reg is\n-\t\t     incremented, spilling it is worse, so we want to make\n-\t\t     that less likely.  */\n-\t\t  reg_n_refs[regno] += loop_depth;\n-\t\t  /* Count the increment as a setting of the register,\n-\t\t     even though it isn't a SET in rtl.  */\n-\t\t  reg_n_sets[regno]++;\n-\t\t}\n+\t      /* Count the increment as a setting of the register,\n+\t\t even though it isn't a SET in rtl.  */\n+\t      reg_n_sets[regno]++;\n \t    }\n \t}\n     }"}]}