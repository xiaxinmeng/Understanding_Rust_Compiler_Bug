{"sha": "38217d3ee7c6e1fee58331f10e5c78e40441009b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgyMTdkM2VlN2M2ZTFmZWU1ODMzMWYxMGU1Yzc4ZTQwNDQxMDA5Yg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-10-18T09:31:21Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-10-18T09:31:21Z"}, "message": "re PR fortran/67177 (MOVE_ALLOC not automatically allocating deferred character arrays in derived types)\n\n2015-10-18  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/67177\n\tPR fortran/67977\n\t* primary.c (match_substring): Add an argument 'deferred' to\n\tflag that a substring reference with null start and end should\n\tnot be optimized away for deferred length strings.\n\t(match_string_constant, gfc_match_rvalue): Set the argument.\n\t* trans-expr.c (alloc_scalar_allocatable_for_assignment): If\n\tthere is a substring reference return.\n\t* trans-intrinsic.c (conv_intrinsic_move_alloc): For deferred\n\tcharacters, assign the 'from' string length to the 'to' string\n\tlength. If the 'from' expression is deferred, set its string\n\tlength to zero. If the 'to' expression has allocatable\n\tcomponents, deallocate them.\n\n2015-10-18  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/67177\n\t* gfortran.dg/move_alloc_15.f90: New test\n\t* gfortran.dg/move_alloc_16.f90: New test\n\n\tPR fortran/67977\n\t* gfortran.dg/deferred_character_assignment_1.f90: New test\n\nFrom-SVN: r228940", "tree": {"sha": "a0441a3335a1f9021773ff84b515947483dce8b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0441a3335a1f9021773ff84b515947483dce8b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38217d3ee7c6e1fee58331f10e5c78e40441009b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38217d3ee7c6e1fee58331f10e5c78e40441009b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38217d3ee7c6e1fee58331f10e5c78e40441009b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38217d3ee7c6e1fee58331f10e5c78e40441009b/comments", "author": null, "committer": null, "parents": [{"sha": "2fe7f26c18c36933430add48d1139030c4a2f8d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fe7f26c18c36933430add48d1139030c4a2f8d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fe7f26c18c36933430add48d1139030c4a2f8d4"}], "stats": {"total": 228, "additions": 221, "deletions": 7}, "files": [{"sha": "51b07de4f026484ea2ee78cf57c286ad69fa5891", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38217d3ee7c6e1fee58331f10e5c78e40441009b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38217d3ee7c6e1fee58331f10e5c78e40441009b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=38217d3ee7c6e1fee58331f10e5c78e40441009b", "patch": "@@ -1,8 +1,24 @@\n+2015-10-18  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/67177\n+\tPR fortran/67977\n+\t* primary.c (match_substring): Add an argument 'deferred' to\n+\tflag that a substring reference with null start and end should\n+\tnot be optimized away for deferred length strings.\n+\t(match_string_constant, gfc_match_rvalue): Set the argument.\n+\t* trans-expr.c (alloc_scalar_allocatable_for_assignment): If\n+\tthere is a substring reference return.\n+\t* trans-intrinsic.c (conv_intrinsic_move_alloc): For deferred\n+\tcharacters, assign the 'from' string length to the 'to' string\n+\tlength. If the 'from' expression is deferred, set its string\n+\tlength to zero. If the 'to' expression has allocatable\n+\tcomponents, deallocate them.\n+\n 2015-10-17  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/67987\n \t* decl.c (char_len_param_value): Unwrap unlong line.  If LEN < 0,\n-\tforce it to zero per the Fortran 90, 95, 2003, and 2008 Standards. \n+\tforce it to zero per the Fortran 90, 95, 2003, and 2008 Standards.\n \t* resolve.c (gfc_resolve_substring_charlen): Unwrap unlong line.\n \tIf 'start' is larger than 'end', length of substring is negative,\n \tso explicitly set it to zero."}, {"sha": "e39c89054d6a357547074d8e19c3050d9b404127", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38217d3ee7c6e1fee58331f10e5c78e40441009b/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38217d3ee7c6e1fee58331f10e5c78e40441009b/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=38217d3ee7c6e1fee58331f10e5c78e40441009b", "patch": "@@ -761,7 +761,7 @@ match_real_constant (gfc_expr **result, int signflag)\n \t{\n \t  if (*p == '.')\n \t    continue;\n-\t  \n+\n \t  if (*p != '0')\n \t    {\n \t      *p = '0';\n@@ -800,7 +800,7 @@ match_real_constant (gfc_expr **result, int signflag)\n /* Match a substring reference.  */\n \n static match\n-match_substring (gfc_charlen *cl, int init, gfc_ref **result)\n+match_substring (gfc_charlen *cl, int init, gfc_ref **result, bool deferred)\n {\n   gfc_expr *start, *end;\n   locus old_loc;\n@@ -852,7 +852,7 @@ match_substring (gfc_charlen *cl, int init, gfc_ref **result)\n     }\n \n   /* Optimize away the (:) reference.  */\n-  if (start == NULL && end == NULL)\n+  if (start == NULL && end == NULL && !deferred)\n     ref = NULL;\n   else\n     {\n@@ -1150,7 +1150,7 @@ match_string_constant (gfc_expr **result)\n   if (ret != -1)\n     gfc_internal_error (\"match_string_constant(): Delimiter not found\");\n \n-  if (match_substring (NULL, 0, &e->ref) != MATCH_NO)\n+  if (match_substring (NULL, 0, &e->ref, false) != MATCH_NO)\n     e->expr_type = EXPR_SUBSTRING;\n \n   *result = e;\n@@ -2133,7 +2133,8 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \n   if (primary->ts.type == BT_CHARACTER)\n     {\n-      switch (match_substring (primary->ts.u.cl, equiv_flag, &substring))\n+      bool def = primary->ts.deferred == 1;\n+      switch (match_substring (primary->ts.u.cl, equiv_flag, &substring, def))\n \t{\n \tcase MATCH_YES:\n \t  if (tail == NULL)\n@@ -3147,7 +3148,7 @@ gfc_match_rvalue (gfc_expr **result)\n \t     that we're not sure is a variable yet.  */\n \n \t  if ((implicit_char || sym->ts.type == BT_CHARACTER)\n-\t      && match_substring (sym->ts.u.cl, 0, &e->ref) == MATCH_YES)\n+\t      && match_substring (sym->ts.u.cl, 0, &e->ref, false) == MATCH_YES)\n \t    {\n \n \t      e->expr_type = EXPR_VARIABLE;"}, {"sha": "2f42c04436ad1839729b0549515fc9c649ca3b7f", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38217d3ee7c6e1fee58331f10e5c78e40441009b/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38217d3ee7c6e1fee58331f10e5c78e40441009b/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=38217d3ee7c6e1fee58331f10e5c78e40441009b", "patch": "@@ -8891,13 +8891,18 @@ alloc_scalar_allocatable_for_assignment (stmtblock_t *block,\n   tree jump_label1;\n   tree jump_label2;\n   gfc_se lse;\n+  gfc_ref *ref;\n \n   if (!expr1 || expr1->rank)\n     return;\n \n   if (!expr2 || expr2->rank)\n     return;\n \n+  for (ref = expr1->ref; ref; ref = ref->next)\n+    if (ref->type == REF_SUBSTRING)\n+      return;\n+\n   realloc_lhs_warning (expr2->ts.type, false, &expr2->where);\n \n   /* Since this is a scalar lhs, we can afford to do this.  That is,"}, {"sha": "d72ea98abf32bf35ad3e90c94897348b409405ec", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38217d3ee7c6e1fee58331f10e5c78e40441009b/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38217d3ee7c6e1fee58331f10e5c78e40441009b/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=38217d3ee7c6e1fee58331f10e5c78e40441009b", "patch": "@@ -9414,6 +9414,16 @@ conv_intrinsic_move_alloc (gfc_code *code)\n \t    }\n \t}\n \n+      if (to_expr->ts.type == BT_CHARACTER && to_expr->ts.deferred)\n+\t{\n+\t  gfc_add_modify_loc (input_location, &block, to_se.string_length,\n+\t\t\t      fold_convert (TREE_TYPE (to_se.string_length),\n+\t\t\t\t\t    from_se.string_length));\n+\t  if (from_expr->ts.deferred)\n+\t    gfc_add_modify_loc (input_location, &block, from_se.string_length,\n+\t\t\tbuild_int_cst (TREE_TYPE (from_se.string_length), 0));\n+\t}\n+\n       return gfc_finish_block (&block);\n     }\n \n@@ -9513,6 +9523,14 @@ conv_intrinsic_move_alloc (gfc_code *code)\n     }\n   else\n     {\n+      if (to_expr->ts.type == BT_DERIVED\n+\t  && to_expr->ts.u.derived->attr.alloc_comp)\n+\t{\n+\t  tmp = gfc_deallocate_alloc_comp (to_expr->ts.u.derived,\n+\t\t\t\t\t   to_se.expr, to_expr->rank);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n+\n       tmp = gfc_conv_descriptor_data_get (to_se.expr);\n       tmp = gfc_deallocate_with_status (tmp, NULL_TREE, NULL_TREE, NULL_TREE,\n \t\t\t\t\tNULL_TREE, true, to_expr, false);\n@@ -9527,6 +9545,17 @@ conv_intrinsic_move_alloc (gfc_code *code)\n   gfc_add_modify_loc (input_location, &block, tmp,\n \t\t      fold_convert (TREE_TYPE (tmp), null_pointer_node));\n \n+\n+  if (to_expr->ts.type == BT_CHARACTER && to_expr->ts.deferred)\n+    {\n+      gfc_add_modify_loc (input_location, &block, to_se.string_length,\n+\t\t\t  fold_convert (TREE_TYPE (to_se.string_length),\n+\t\t\t\t\tfrom_se.string_length));\n+      if (from_expr->ts.deferred)\n+        gfc_add_modify_loc (input_location, &block, from_se.string_length,\n+\t\t\tbuild_int_cst (TREE_TYPE (from_se.string_length), 0));\n+    }\n+\n   return gfc_finish_block (&block);\n }\n "}, {"sha": "b477f0d27f9ff7da25f3c0a97f19c13660393da0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38217d3ee7c6e1fee58331f10e5c78e40441009b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38217d3ee7c6e1fee58331f10e5c78e40441009b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=38217d3ee7c6e1fee58331f10e5c78e40441009b", "patch": "@@ -1,3 +1,12 @@\n+2015-10-18  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/67177\n+\t* gfortran.dg/move_alloc_15.f90: New test\n+\t* gfortran.dg/move_alloc_16.f90: New test\n+\n+\tPR fortran/67977\n+\t* gfortran.dg/deferred_character_assignment_1.f90: New test\n+\n 2015-10-17  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/67987"}, {"sha": "f3a739f503ddeb88dc51f3c333288677a276fcb7", "filename": "gcc/testsuite/gfortran.dg/deferred_character_assignment_1.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38217d3ee7c6e1fee58331f10e5c78e40441009b/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_assignment_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38217d3ee7c6e1fee58331f10e5c78e40441009b/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_assignment_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_assignment_1.f90?ref=38217d3ee7c6e1fee58331f10e5c78e40441009b", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+!\n+! Checks the fix for PR67977 in which automatic reallocation on assignment\n+! was performed when the lhs had a substring reference.\n+!\n+! Contributed by Anton Shterenlikht  <mexas@bristol.ac.uk>\n+!\n+  character(:), allocatable :: z\n+  integer :: length\n+  z = \"cockatoo\"\n+  length = len (z)\n+  z(:) = ''\n+  if (len(z) .ne. length) call abort\n+  if (trim (z) .ne. '') call abort\n+  z(:3) = \"foo\"\n+  if (len(z) .ne. length) call abort\n+  if (trim (z) .ne. \"foo\") call abort\n+  z(4:) = \"__bar\"\n+  if (len(z) .ne. length) call abort\n+  if (trim (z) .ne. \"foo__bar\") call abort\n+  deallocate (z)\n+end"}, {"sha": "1c96ccba1cf4e8d8b7a64194229e42ac20929f3b", "filename": "gcc/testsuite/gfortran.dg/move_alloc_15.f90", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38217d3ee7c6e1fee58331f10e5c78e40441009b/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38217d3ee7c6e1fee58331f10e5c78e40441009b/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_15.f90?ref=38217d3ee7c6e1fee58331f10e5c78e40441009b", "patch": "@@ -0,0 +1,88 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Fix for PR......\n+!\n+! The 'to' components of 'mytemp' would remain allocated after the call to\n+! MOVE_ALLOC, resulting in memory leaks.\n+!\n+! Contributed by Alberto Luaces.\n+!\n+! See https://groups.google.com/forum/#!topic/comp.lang.fortran/k3bkKUbOpFU\n+!\n+module alloctest\n+  type myallocatable\n+     integer, allocatable:: i(:)\n+  end type myallocatable\n+\n+contains\n+  subroutine f(num, array)\n+    implicit none\n+    integer, intent(in) :: num\n+    integer :: i\n+    type(myallocatable):: array(:)\n+\n+    do i = 1, num\n+       allocate(array(i)%i(5), source = [1,2,3,4,5])\n+    end do\n+\n+  end subroutine f\n+end module alloctest\n+\n+program name\n+  use alloctest\n+  implicit none\n+  type(myallocatable), allocatable:: myarray(:), mytemp(:)\n+  integer, parameter:: OLDSIZE = 7, NEWSIZE = 20\n+  logical :: flag\n+\n+  allocate(myarray(OLDSIZE))\n+  call f(size(myarray), myarray)\n+\n+  allocate(mytemp(NEWSIZE))\n+  mytemp(1:OLDSIZE) = myarray\n+\n+  flag = .false.\n+  call foo\n+  call bar\n+\n+  deallocate(myarray)\n+  if (allocated (mytemp)) deallocate (mytemp)\n+\n+  allocate(myarray(OLDSIZE))\n+  call f(size(myarray), myarray)\n+\n+  allocate(mytemp(NEWSIZE))\n+  mytemp(1:OLDSIZE) = myarray\n+\n+! Verfify that there is no segfault if the allocatable components\n+! are deallocated before the call to move_alloc\n+  flag = .true.\n+  call foo\n+  call bar\n+\n+  deallocate(myarray)\n+contains\n+  subroutine foo\n+    integer :: i\n+    if (flag) then\n+      do i = 1, OLDSIZE\n+        deallocate (mytemp(i)%i)\n+      end do\n+    end if\n+    call move_alloc(mytemp, myarray)\n+  end subroutine\n+\n+  subroutine bar\n+    integer :: i\n+    do i = 1, OLDSIZE\n+      if (.not.flag .and. allocated (myarray(i)%i)) then\n+        if (any (myarray(i)%i .ne. [1,2,3,4,5])) call abort\n+      else\n+        if (.not.flag) call abort\n+      end if\n+    end do\n+  end subroutine\n+end program name\n+! { dg-final { scan-tree-dump-times \"__builtin_malloc\" 11 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__builtin_free\" 11 \"original\" } }"}, {"sha": "fc09f7778c3834a28ef4c23660cad71d9f7ed8e9", "filename": "gcc/testsuite/gfortran.dg/move_alloc_16.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38217d3ee7c6e1fee58331f10e5c78e40441009b/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_16.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38217d3ee7c6e1fee58331f10e5c78e40441009b/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_16.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_16.f90?ref=38217d3ee7c6e1fee58331f10e5c78e40441009b", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do run }\n+!\n+! Tests the fix for PR67177 in which MOVE_ALLOC was not assigning the string\n+! length for deferred length characters.\n+!\n+! Contributed by <templed@tcd.ie>\n+!\n+program str\n+  implicit none\n+\n+  type string\n+    character(:), Allocatable :: text\n+  end type string\n+\n+  type strings\n+    type(string), allocatable, dimension(:) :: strlist\n+  end type strings\n+\n+  type(strings) :: teststrs\n+  type(string) :: tmpstr\n+  integer :: strlen = 20\n+\n+  allocate (teststrs%strlist(1))\n+  allocate (character(len=strlen) :: tmpstr%text)\n+\n+  allocate (character(len=strlen) :: teststrs%strlist(1)%text)\n+\n+! Full string reference was required because reallocation on assignment is\n+! functioning when it should not if the lhs is a substring - PR67977\n+  tmpstr%text(1:3) = 'foo'\n+\n+  if (.not.allocated (teststrs%strlist(1)%text)) call abort\n+  if (len (tmpstr%text) .ne. strlen) call abort\n+\n+  call move_alloc(tmpstr%text,teststrs%strlist(1)%text)\n+\n+  if (.not.allocated (teststrs%strlist(1)%text)) call abort\n+  if (len (teststrs%strlist(1)%text) .ne. strlen) call abort\n+  if (trim (teststrs%strlist(1)%text(1:3)) .ne. 'foo') call abort\n+\n+! Clean up so that valgrind reports all allocated memory freed.\n+  if (allocated (teststrs%strlist(1)%text)) deallocate (teststrs%strlist(1)%text)\n+  if (allocated (teststrs%strlist)) deallocate (teststrs%strlist)\n+end program str"}]}