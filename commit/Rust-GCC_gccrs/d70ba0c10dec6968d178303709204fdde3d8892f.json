{"sha": "d70ba0c10dec6968d178303709204fdde3d8892f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDcwYmEwYzEwZGVjNjk2OGQxNzgzMDM3MDkyMDRmZGRlM2Q4ODkyZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-06-17T11:36:58Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-06-17T11:36:58Z"}, "message": "gimplify.c (nonlocal_vlas): Delete.\n\n\t* gimplify.c (nonlocal_vlas): Delete.\n\t(nonlocal_vla_vars): Likewise.\n\t(gimplify_var_or_parm_decl): Do not add debug VAR_DECLs for non-local\n\treferenced VLAs.\n\t(gimplify_body): Do not create and destroy nonlocal_vlas.\n\t* tree-nested.c: Include diagnostic.h.\n\t(use_pointer_in_frame): Tweak.\n\t(lookup_field_for_decl): Add assertion and declare the transformation.\n\t(convert_nonlocal_reference_op) <PARM_DECL>: Rework and issue an\n\tinternal error when the reference is in a wrong context.  Do not\n\tcreate a debug decl by default.\n\t(note_nonlocal_block_vlas): Delete.\n\t(convert_nonlocal_reference_stmt) <GIMPLE_BIND>: Do not call it.\n\t(convert_local_reference_op) <PARM_DECL>: Skip the frame decl.  Do not\n\tcreate a debug decl by default.\n\t(convert_gimple_call) <GIMPLE_CALL>: Issue an internal error when the\n\tcall is in a wrong context.\n\t(fixup_vla_decls): New function.\n\t(finalize_nesting_tree_1): Adjust comment.  Call fixup_vla_decls if no\n\tdebug variables were created.\n\t* tree.c (decl_value_expr_lookup): Add checking assertion.\n\t(decl_value_expr_insert): Likewise.\nfortran/\n\t* fortran/trans-decl.c (nonlocal_dummy_decl_pset): Delete.\n\t(nonlocal_dummy_decls): Likewise.\n\t(gfc_nonlocal_dummy_array_decl): Likewise.\n\t(gfc_get_symbol_decl): Do not call gfc_nonlocal_dummy_array_decl.\n\t(gfc_get_fake_result_decl): Do not generate a new DECL if simply\n\treusing the result of a recursive call.\n\t(gfc_generate_function_code): Do not create, insert and destroy\n\tnonlocal_dummy_decls.\n\nFrom-SVN: r261687", "tree": {"sha": "56c61211f3f65011db6e6bf06ce42a48fe05b176", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56c61211f3f65011db6e6bf06ce42a48fe05b176"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d70ba0c10dec6968d178303709204fdde3d8892f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d70ba0c10dec6968d178303709204fdde3d8892f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d70ba0c10dec6968d178303709204fdde3d8892f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d70ba0c10dec6968d178303709204fdde3d8892f/comments", "author": null, "committer": null, "parents": [{"sha": "f6a4a25f240e79dcdbca93f613c8c6face5c1211", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6a4a25f240e79dcdbca93f613c8c6face5c1211", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6a4a25f240e79dcdbca93f613c8c6face5c1211"}], "stats": {"total": 451, "additions": 235, "deletions": 216}, "files": [{"sha": "78bfd9af82d042064250001d624ea4f689ae2f82", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ba0c10dec6968d178303709204fdde3d8892f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ba0c10dec6968d178303709204fdde3d8892f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d70ba0c10dec6968d178303709204fdde3d8892f", "patch": "@@ -1,3 +1,28 @@\n+2018-06-17  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gimplify.c (nonlocal_vlas): Delete.\n+\t(nonlocal_vla_vars): Likewise.\n+\t(gimplify_var_or_parm_decl): Do not add debug VAR_DECLs for non-local\n+\treferenced VLAs.\n+\t(gimplify_body): Do not create and destroy nonlocal_vlas.\n+\t* tree-nested.c: Include diagnostic.h.\n+\t(use_pointer_in_frame): Tweak.\n+\t(lookup_field_for_decl): Add assertion and declare the transformation.\n+\t(convert_nonlocal_reference_op) <PARM_DECL>: Rework and issue an\n+\tinternal error when the reference is in a wrong context.  Do not\n+\tcreate a debug decl by default.\n+\t(note_nonlocal_block_vlas): Delete.\n+\t(convert_nonlocal_reference_stmt) <GIMPLE_BIND>: Do not call it.\n+\t(convert_local_reference_op) <PARM_DECL>: Skip the frame decl.  Do not\n+\tcreate a debug decl by default.\n+\t(convert_gimple_call) <GIMPLE_CALL>: Issue an internal error when the\n+\tcall is in a wrong context.\n+\t(fixup_vla_decls): New function.\n+\t(finalize_nesting_tree_1): Adjust comment.  Call fixup_vla_decls if no\n+\tdebug variables were created.\n+\t* tree.c (decl_value_expr_lookup): Add checking assertion.\n+\t(decl_value_expr_insert): Likewise.\n+\n 2018-06-16  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \tPR middle-end/82479"}, {"sha": "fdf8f0aee1c86056c998ed03ad49a93c4ea320cb", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ba0c10dec6968d178303709204fdde3d8892f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ba0c10dec6968d178303709204fdde3d8892f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d70ba0c10dec6968d178303709204fdde3d8892f", "patch": "@@ -1,3 +1,14 @@\n+2018-06-17  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* fortran/trans-decl.c (nonlocal_dummy_decl_pset): Delete.\n+\t(nonlocal_dummy_decls): Likewise.\n+\t(gfc_nonlocal_dummy_array_decl): Likewise.\n+\t(gfc_get_symbol_decl): Do not call gfc_nonlocal_dummy_array_decl.\n+\t(gfc_get_fake_result_decl): Do not generate a new DECL if simply\n+\treusing the result of a recursive call.\n+\t(gfc_generate_function_code): Do not create, insert and destroy\n+\tnonlocal_dummy_decls.\n+\n 2018-06-13  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/86110"}, {"sha": "79ff01fc76dcce6e8b68cc82613cdf4d8b54c248", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 11, "deletions": 67, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ba0c10dec6968d178303709204fdde3d8892f/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ba0c10dec6968d178303709204fdde3d8892f/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=d70ba0c10dec6968d178303709204fdde3d8892f", "patch": "@@ -61,9 +61,6 @@ static GTY(()) tree parent_fake_result_decl;\n static GTY(()) tree saved_function_decls;\n static GTY(()) tree saved_parent_function_decls;\n \n-static hash_set<tree> *nonlocal_dummy_decl_pset;\n-static GTY(()) tree nonlocal_dummy_decls;\n-\n /* Holds the variable DECLs that are locals.  */\n \n static GTY(()) tree saved_local_decls;\n@@ -1284,39 +1281,6 @@ gfc_build_dummy_array_decl (gfc_symbol * sym, tree dummy)\n   return decl;\n }\n \n-/* For symbol SYM with GFC_DECL_SAVED_DESCRIPTOR used in contained\n-   function add a VAR_DECL to the current function with DECL_VALUE_EXPR\n-   pointing to the artificial variable for debug info purposes.  */\n-\n-static void\n-gfc_nonlocal_dummy_array_decl (gfc_symbol *sym)\n-{\n-  tree decl, dummy;\n-\n-  if (! nonlocal_dummy_decl_pset)\n-    nonlocal_dummy_decl_pset = new hash_set<tree>;\n-\n-  if (nonlocal_dummy_decl_pset->add (sym->backend_decl))\n-    return;\n-\n-  dummy = GFC_DECL_SAVED_DESCRIPTOR (sym->backend_decl);\n-  decl = build_decl (input_location, VAR_DECL, DECL_NAME (dummy),\n-\t\t     TREE_TYPE (sym->backend_decl));\n-  DECL_ARTIFICIAL (decl) = 0;\n-  TREE_USED (decl) = 1;\n-  TREE_PUBLIC (decl) = 0;\n-  TREE_STATIC (decl) = 0;\n-  DECL_EXTERNAL (decl) = 0;\n-  if (DECL_BY_REFERENCE (dummy))\n-    DECL_BY_REFERENCE (decl) = 1;\n-  DECL_LANG_SPECIFIC (decl) = DECL_LANG_SPECIFIC (sym->backend_decl);\n-  SET_DECL_VALUE_EXPR (decl, sym->backend_decl);\n-  DECL_HAS_VALUE_EXPR_P (decl) = 1;\n-  DECL_CONTEXT (decl) = DECL_CONTEXT (sym->backend_decl);\n-  DECL_CHAIN (decl) = nonlocal_dummy_decls;\n-  nonlocal_dummy_decls = decl;\n-}\n-\n /* Return a constant or a variable to use as a string length.  Does not\n    add the decl to the current scope.  */\n \n@@ -1643,12 +1607,6 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t  gfc_add_assign_aux_vars (sym);\n \t}\n \n-      if ((sym->attr.dimension || IS_CLASS_ARRAY (sym))\n-\t  && DECL_LANG_SPECIFIC (sym->backend_decl)\n-\t  && GFC_DECL_SAVED_DESCRIPTOR (sym->backend_decl)\n-\t  && DECL_CONTEXT (sym->backend_decl) != current_function_decl)\n-\tgfc_nonlocal_dummy_array_decl (sym);\n-\n       if (sym->ts.type == BT_CLASS && sym->backend_decl)\n \tGFC_DECL_CLASS(sym->backend_decl) = 1;\n \n@@ -2950,34 +2908,32 @@ gfc_get_fake_result_decl (gfc_symbol * sym, int parent_flag)\n       && sym->ns->proc_name->attr.entry_master\n       && sym != sym->ns->proc_name)\n     {\n-      tree t = NULL, var;\n+      tree t = NULL, var, field;\n       if (this_fake_result_decl != NULL)\n \tfor (t = TREE_CHAIN (this_fake_result_decl); t; t = TREE_CHAIN (t))\n \t  if (strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t)), sym->name) == 0)\n \t    break;\n       if (t)\n \treturn TREE_VALUE (t);\n+\n       decl = gfc_get_fake_result_decl (sym->ns->proc_name, parent_flag);\n \n       if (parent_flag)\n \tthis_fake_result_decl = parent_fake_result_decl;\n       else\n \tthis_fake_result_decl = current_fake_result_decl;\n \n-      if (decl && sym->ns->proc_name->attr.mixed_entry_master)\n-\t{\n-\t  tree field;\n+      if (!sym->ns->proc_name->attr.mixed_entry_master)\n+\treturn decl;\n \n-\t  for (field = TYPE_FIELDS (TREE_TYPE (decl));\n-\t       field; field = DECL_CHAIN (field))\n-\t    if (strcmp (IDENTIFIER_POINTER (DECL_NAME (field)),\n-\t\tsym->name) == 0)\n-\t      break;\n+      for (field = TYPE_FIELDS (TREE_TYPE (decl));\n+\t   field; field = DECL_CHAIN (field))\n+\tif (strcmp (IDENTIFIER_POINTER (DECL_NAME (field)), sym->name) == 0)\n+\t  break;\n \n-\t  gcc_assert (field != NULL_TREE);\n-\t  decl = fold_build3_loc (input_location, COMPONENT_REF,\n-\t\t\t\t  TREE_TYPE (field), decl, field, NULL_TREE);\n-\t}\n+      gcc_assert (field != NULL_TREE);\n+      decl = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t      TREE_TYPE (field), decl, field, NULL_TREE);\n \n       var = create_tmp_var_raw (TREE_TYPE (decl), sym->name);\n       if (parent_flag)\n@@ -6442,9 +6398,6 @@ gfc_generate_function_code (gfc_namespace * ns)\n \n   gfc_generate_contained_functions (ns);\n \n-  nonlocal_dummy_decls = NULL;\n-  nonlocal_dummy_decl_pset = NULL;\n-\n   has_coarray_vars = false;\n   generate_local_vars (ns);\n \n@@ -6644,15 +6597,6 @@ gfc_generate_function_code (gfc_namespace * ns)\n     = build3_v (BIND_EXPR, decl, DECL_SAVED_TREE (fndecl),\n \t\tDECL_INITIAL (fndecl));\n \n-  if (nonlocal_dummy_decls)\n-    {\n-      BLOCK_VARS (DECL_INITIAL (fndecl))\n-\t= chainon (BLOCK_VARS (DECL_INITIAL (fndecl)), nonlocal_dummy_decls);\n-      delete nonlocal_dummy_decl_pset;\n-      nonlocal_dummy_decls = NULL;\n-      nonlocal_dummy_decl_pset = NULL;\n-    }\n-\n   /* Output the GENERIC tree.  */\n   dump_function (TDI_original, fndecl);\n "}, {"sha": "4bcdf440d7677552af10df93752b3422e86f50d2", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 64, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ba0c10dec6968d178303709204fdde3d8892f/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ba0c10dec6968d178303709204fdde3d8892f/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=d70ba0c10dec6968d178303709204fdde3d8892f", "patch": "@@ -2674,12 +2674,6 @@ gimplify_conversion (tree *expr_p)\n   return GS_OK;\n }\n \n-/* Nonlocal VLAs seen in the current function.  */\n-static hash_set<tree> *nonlocal_vlas;\n-\n-/* The VAR_DECLs created for nonlocal VLAs for debug info purposes.  */\n-static tree nonlocal_vla_vars;\n-\n /* Gimplify a VAR_DECL or PARM_DECL.  Return GS_OK if we expanded a\n    DECL_VALUE_EXPR, and it's worth re-examining things.  */\n \n@@ -2710,38 +2704,7 @@ gimplify_var_or_parm_decl (tree *expr_p)\n   /* If the decl is an alias for another expression, substitute it now.  */\n   if (DECL_HAS_VALUE_EXPR_P (decl))\n     {\n-      tree value_expr = DECL_VALUE_EXPR (decl);\n-\n-      /* For referenced nonlocal VLAs add a decl for debugging purposes\n-\t to the current function.  */\n-      if (VAR_P (decl)\n-\t  && TREE_CODE (DECL_SIZE_UNIT (decl)) != INTEGER_CST\n-\t  && nonlocal_vlas != NULL\n-\t  && TREE_CODE (value_expr) == INDIRECT_REF\n-\t  && TREE_CODE (TREE_OPERAND (value_expr, 0)) == VAR_DECL\n-\t  && decl_function_context (decl) != current_function_decl)\n-\t{\n-\t  struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n-\t  while (ctx\n-\t\t && (ctx->region_type == ORT_WORKSHARE\n-\t\t     || ctx->region_type == ORT_SIMD\n-\t\t     || ctx->region_type == ORT_ACC))\n-\t    ctx = ctx->outer_context;\n-\t  if (!ctx && !nonlocal_vlas->add (decl))\n-\t    {\n-\t      tree copy = copy_node (decl);\n-\n-\t      lang_hooks.dup_lang_specific_decl (copy);\n-\t      SET_DECL_RTL (copy, 0);\n-\t      TREE_USED (copy) = 1;\n-\t      DECL_CHAIN (copy) = nonlocal_vla_vars;\n-\t      nonlocal_vla_vars = copy;\n-\t      SET_DECL_VALUE_EXPR (copy, unshare_expr (value_expr));\n-\t      DECL_HAS_VALUE_EXPR_P (copy) = 1;\n-\t    }\n-\t}\n-\n-      *expr_p = unshare_expr (value_expr);\n+      *expr_p = unshare_expr (DECL_VALUE_EXPR (decl));\n       return GS_OK;\n     }\n \n@@ -12591,7 +12554,6 @@ gimplify_body (tree fndecl, bool do_parms)\n   gimple_seq parm_stmts, parm_cleanup = NULL, seq;\n   gimple *outer_stmt;\n   gbind *outer_bind;\n-  struct cgraph_node *cgn;\n \n   timevar_push (TV_TREE_GIMPLIFY);\n \n@@ -12618,10 +12580,6 @@ gimplify_body (tree fndecl, bool do_parms)\n   unshare_body (fndecl);\n   unvisit_body (fndecl);\n \n-  cgn = cgraph_node::get (fndecl);\n-  if (cgn && cgn->origin)\n-    nonlocal_vlas = new hash_set<tree>;\n-\n   /* Make sure input_location isn't set to something weird.  */\n   input_location = DECL_SOURCE_LOCATION (fndecl);\n \n@@ -12674,27 +12632,6 @@ gimplify_body (tree fndecl, bool do_parms)\n \t  }\n     }\n \n-  if (nonlocal_vlas)\n-    {\n-      if (nonlocal_vla_vars)\n-\t{\n-\t  /* tree-nested.c may later on call declare_vars (..., true);\n-\t     which relies on BLOCK_VARS chain to be the tail of the\n-\t     gimple_bind_vars chain.  Ensure we don't violate that\n-\t     assumption.  */\n-\t  if (gimple_bind_block (outer_bind)\n-\t      == DECL_INITIAL (current_function_decl))\n-\t    declare_vars (nonlocal_vla_vars, outer_bind, true);\n-\t  else\n-\t    BLOCK_VARS (DECL_INITIAL (current_function_decl))\n-\t      = chainon (BLOCK_VARS (DECL_INITIAL (current_function_decl)),\n-\t\t\t nonlocal_vla_vars);\n-\t  nonlocal_vla_vars = NULL_TREE;\n-\t}\n-      delete nonlocal_vlas;\n-      nonlocal_vlas = NULL;\n-    }\n-\n   if ((flag_openacc || flag_openmp || flag_openmp_simd)\n       && gimplify_omp_ctxp)\n     {"}, {"sha": "dfb167bdb6009ede63808dca44b615f612c0cf33", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ba0c10dec6968d178303709204fdde3d8892f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ba0c10dec6968d178303709204fdde3d8892f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d70ba0c10dec6968d178303709204fdde3d8892f", "patch": "@@ -1,3 +1,9 @@\n+2018-06-17  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/debug/dwarf2/pr37726.c: Move to...\n+\t* gcc.dg/guality/pr37726.c: ...here and turn into GDB test.\n+\t* gnat.dg/stack_usage5.adb: New test.\n+\n 2018-06-16  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \tPR middle-end/82479"}, {"sha": "622fbcf64017b93ab1b085b56fd572dd2adca3f2", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/pr37726.c", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a4a25f240e79dcdbca93f613c8c6face5c1211/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr37726.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a4a25f240e79dcdbca93f613c8c6face5c1211/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr37726.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fpr37726.c?ref=f6a4a25f240e79dcdbca93f613c8c6face5c1211", "patch": "@@ -1,25 +0,0 @@\n-/* PR debug/37726 */\n-/* { dg-do compile } */\n-/* { dg-options \"-gdwarf -O0 -dA -fno-merge-debug-strings\" } */\n-\n-int foo (int parm)\n-{\n-  int var = 0;\n-  int bar (void)\n-  {\n-    return parm + var;\n-  }\n-  parm++;\n-  var++;\n-  return bar ();\n-}\n-\n-int\n-main (void)\n-{\n-  return foo (4) - 6;\n-}\n-\n-/* Both parm and var variables should be in debug info for both foo and bar.  */\n-/* { dg-final { scan-assembler-times \"\\\"parm\\[^\\n\\]*\\\"\\[^\\n\\]*DW_AT_name\" 2 } } */\n-/* { dg-final { scan-assembler-times \"\\\"var\\[^\\n\\]*\\\"\\[^\\n\\]*DW_AT_name\" 2 } } */"}, {"sha": "509d2d4c84a6affcb690a63d378e62101b50e23f", "filename": "gcc/testsuite/gcc.dg/guality/pr37726.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ba0c10dec6968d178303709204fdde3d8892f/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr37726.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ba0c10dec6968d178303709204fdde3d8892f/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr37726.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr37726.c?ref=d70ba0c10dec6968d178303709204fdde3d8892f", "patch": "@@ -0,0 +1,27 @@\n+/* PR debug/37726 */\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+/* { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O0\" } } */\n+\n+int foo (int parm)\n+{\n+  int var = 0;\n+  int bar (void)\n+  {\n+    return parm + var; /* BREAK */\n+  }\n+  parm++;              /* BREAK */\n+  var++;\n+  return bar ();\n+}\n+\n+int\n+main (void)\n+{\n+  return foo (4) - 6;\n+}\n+\n+/* { dg-final { gdb-test 11 \"parm\" \"5\" } } */\n+/* { dg-final { gdb-test 11 \"var\"  \"1\" } } */\n+/* { dg-final { gdb-test 13 \"parm\" \"4\" } } */\n+/* { dg-final { gdb-test 13 \"var\"  \"0\" } } */"}, {"sha": "55d0f13e1fa64d0196d90b00444f748ac8460331", "filename": "gcc/testsuite/gnat.dg/stack_usage5.adb", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ba0c10dec6968d178303709204fdde3d8892f/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_usage5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ba0c10dec6968d178303709204fdde3d8892f/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_usage5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fstack_usage5.adb?ref=d70ba0c10dec6968d178303709204fdde3d8892f", "patch": "@@ -0,0 +1,15 @@\n+-- { dg-do compile }\n+-- { dg-options \"-Wstack-usage=512\" }\n+\n+procedure Stack_Usage5 (C : Character) is\n+\n+  S : String (1 .. 300);\n+\n+  procedure Set is\n+  begin\n+    S (1) := C;\n+  end;\n+\n+begin\n+  Set;\n+end;"}, {"sha": "b335d6b0afefd0ac3077df0c48e5b693400ad68a", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 124, "deletions": 59, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ba0c10dec6968d178303709204fdde3d8892f/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ba0c10dec6968d178303709204fdde3d8892f/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=d70ba0c10dec6968d178303709204fdde3d8892f", "patch": "@@ -41,6 +41,7 @@\n #include \"langhooks.h\"\n #include \"gimple-low.h\"\n #include \"gomp-constants.h\"\n+#include \"diagnostic.h\"\n \n \n /* The object of this pass is to lower the representation of a set of nested\n@@ -236,23 +237,25 @@ get_frame_type (struct nesting_info *info)\n   return type;\n }\n \n-/* Return true if DECL should be referenced by pointer in the non-local\n-   frame structure.  */\n+/* Return true if DECL should be referenced by pointer in the non-local frame\n+   structure.  */\n \n static bool\n use_pointer_in_frame (tree decl)\n {\n   if (TREE_CODE (decl) == PARM_DECL)\n     {\n-      /* It's illegal to copy TREE_ADDRESSABLE, impossible to copy variable\n-         sized decls, and inefficient to copy large aggregates.  Don't bother\n-         moving anything but scalar variables.  */\n+      /* It's illegal to copy TREE_ADDRESSABLE, impossible to copy variable-\n+\t sized DECLs, and inefficient to copy large aggregates.  Don't bother\n+\t moving anything but scalar parameters.  */\n       return AGGREGATE_TYPE_P (TREE_TYPE (decl));\n     }\n   else\n     {\n-      /* Variable sized types make things \"interesting\" in the frame.  */\n-      return DECL_SIZE (decl) == NULL || !TREE_CONSTANT (DECL_SIZE (decl));\n+      /* Variable-sized DECLs can only come from OMP clauses at this point\n+\t since the gimplifier has already turned the regular variables into\n+\t pointers.  Do the same as the gimplifier.  */\n+      return !DECL_SIZE (decl) || TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST;\n     }\n }\n \n@@ -263,6 +266,8 @@ static tree\n lookup_field_for_decl (struct nesting_info *info, tree decl,\n \t\t       enum insert_option insert)\n {\n+  gcc_checking_assert (decl_function_context (decl) == info->context);\n+\n   if (insert == NO_INSERT)\n     {\n       tree *slot = info->field_map->get (decl);\n@@ -272,6 +277,7 @@ lookup_field_for_decl (struct nesting_info *info, tree decl,\n   tree *slot = &info->field_map->get_or_insert (decl);\n   if (!*slot)\n     {\n+      tree type = get_frame_type (info);\n       tree field = make_node (FIELD_DECL);\n       DECL_NAME (field) = DECL_NAME (decl);\n \n@@ -290,9 +296,35 @@ lookup_field_for_decl (struct nesting_info *info, tree decl,\n           TREE_ADDRESSABLE (field) = TREE_ADDRESSABLE (decl);\n           DECL_NONADDRESSABLE_P (field) = !TREE_ADDRESSABLE (decl);\n           TREE_THIS_VOLATILE (field) = TREE_THIS_VOLATILE (decl);\n+\n+\t  /* Declare the transformation and adjust the original DECL.  For a\n+\t     variable or for a parameter when not optimizing, we make it point\n+\t     to the field in the frame directly.  For a parameter, we don't do\n+\t     it when optimizing because the variable tracking pass will already\n+\t     do the job,  */\n+\t  if (VAR_P (decl) || !optimize)\n+\t    {\n+\t      tree x\n+\t\t= build3 (COMPONENT_REF, TREE_TYPE (field), info->frame_decl,\n+\t\t\t  field, NULL_TREE);\n+\n+\t      /* If the next declaration is a PARM_DECL pointing to the DECL,\n+\t\t we need to adjust its VALUE_EXPR directly, since chains of\n+\t\t VALUE_EXPRs run afoul of garbage collection.  This occurs\n+\t\t in Ada for Out parameters that aren't copied in.  */\n+\t      tree next = DECL_CHAIN (decl);\n+\t      if (next\n+\t\t  && TREE_CODE (next) == PARM_DECL\n+\t\t  && DECL_HAS_VALUE_EXPR_P (next)\n+\t\t  && DECL_VALUE_EXPR (next) == decl)\n+\t\tSET_DECL_VALUE_EXPR (next, x);\n+\n+\t      SET_DECL_VALUE_EXPR (decl, x);\n+\t      DECL_HAS_VALUE_EXPR_P (decl) = 1;\n+\t    }\n \t}\n \n-      insert_field_into_struct (get_frame_type (info), field);\n+      insert_field_into_struct (type, field);\n       *slot = field;\n \n       if (TREE_CODE (decl) == PARM_DECL)\n@@ -990,37 +1022,48 @@ convert_nonlocal_reference_op (tree *tp, int *walk_subtrees, void *data)\n       /* FALLTHRU */\n \n     case PARM_DECL:\n-      if (decl_function_context (t) != info->context)\n-\t{\n-\t  tree x;\n-\t  wi->changed = true;\n+      {\n+\ttree x, target_context = decl_function_context (t);\n \n-\t  x = get_nonlocal_debug_decl (info, t);\n-\t  if (!bitmap_bit_p (info->suppress_expansion, DECL_UID (t)))\n-\t    {\n-\t      tree target_context = decl_function_context (t);\n-\t      struct nesting_info *i;\n-\t      for (i = info->outer; i->context != target_context; i = i->outer)\n-\t\tcontinue;\n-\t      x = lookup_field_for_decl (i, t, INSERT);\n-\t      x = get_frame_field (info, target_context, x, &wi->gsi);\n-\t      if (use_pointer_in_frame (t))\n-\t\t{\n-\t\t  x = init_tmp_var (info, x, &wi->gsi);\n-\t\t  x = build_simple_mem_ref (x);\n-\t\t}\n-\t    }\n+\tif (info->context == target_context)\n+\t  break;\n \n-\t  if (wi->val_only)\n-\t    {\n-\t      if (wi->is_lhs)\n-\t\tx = save_tmp_var (info, x, &wi->gsi);\n-\t      else\n+\twi->changed = true;\n+\n+\tif (bitmap_bit_p (info->suppress_expansion, DECL_UID (t)))\n+\t  x = get_nonlocal_debug_decl (info, t);\n+\telse\n+\t  {\n+\t    struct nesting_info *i = info;\n+\t    while (i && i->context != target_context)\n+\t      i = i->outer;\n+\t    /* If none of the outer contexts is the target context, this means\n+\t       that the VAR or PARM_DECL is referenced in a wrong context.  */\n+\t    if (!i)\n+\t      internal_error (\"%s from %s referenced in %s\",\n+\t\t\t      IDENTIFIER_POINTER (DECL_NAME (t)),\n+\t\t\t      IDENTIFIER_POINTER (DECL_NAME (target_context)),\n+\t\t\t      IDENTIFIER_POINTER (DECL_NAME (info->context)));\n+\n+\t    x = lookup_field_for_decl (i, t, INSERT);\n+\t    x = get_frame_field (info, target_context, x, &wi->gsi);\n+\t    if (use_pointer_in_frame (t))\n+\t      {\n \t\tx = init_tmp_var (info, x, &wi->gsi);\n-\t    }\n+\t\tx = build_simple_mem_ref (x);\n+\t      }\n+\t  }\n \n-\t  *tp = x;\n-\t}\n+\tif (wi->val_only)\n+\t  {\n+\t    if (wi->is_lhs)\n+\t      x = save_tmp_var (info, x, &wi->gsi);\n+\t    else\n+\t      x = init_tmp_var (info, x, &wi->gsi);\n+\t  }\n+\n+\t*tp = x;\n+      }\n       break;\n \n     case LABEL_DECL:\n@@ -1406,22 +1449,6 @@ note_nonlocal_vla_type (struct nesting_info *info, tree type)\n     }\n }\n \n-/* Create nonlocal debug decls for nonlocal VLA array bounds for VLAs\n-   in BLOCK.  */\n-\n-static void\n-note_nonlocal_block_vlas (struct nesting_info *info, tree block)\n-{\n-  tree var;\n-\n-  for (var = BLOCK_VARS (block); var; var = DECL_CHAIN (var))\n-    if (VAR_P (var)\n-\t&& variably_modified_type_p (TREE_TYPE (var), NULL)\n-\t&& DECL_HAS_VALUE_EXPR_P (var)\n-\t&& decl_function_context (var) != info->context)\n-      note_nonlocal_vla_type (info, TREE_TYPE (var));\n-}\n-\n /* Callback for walk_gimple_stmt.  Rewrite all references to VAR and\n    PARM_DECLs that belong to outer functions.  This handles statements\n    that are not handled via the standard recursion done in\n@@ -1566,8 +1593,6 @@ convert_nonlocal_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n     case GIMPLE_BIND:\n       {\n       gbind *bind_stmt = as_a <gbind *> (stmt);\n-      if (!optimize && gimple_bind_block (bind_stmt))\n-\tnote_nonlocal_block_vlas (info, gimple_bind_block (bind_stmt));\n \n       for (tree var = gimple_bind_vars (bind_stmt); var; var = DECL_CHAIN (var))\n \tif (TREE_CODE (var) == NAMELIST_DECL)\n@@ -1683,7 +1708,7 @@ convert_local_reference_op (tree *tp, int *walk_subtrees, void *data)\n       /* FALLTHRU */\n \n     case PARM_DECL:\n-      if (decl_function_context (t) == info->context)\n+      if (t != info->frame_decl && decl_function_context (t) == info->context)\n \t{\n \t  /* If we copied a pointer to the frame, then the original decl\n \t     is used unchanged in the parent function.  */\n@@ -1697,8 +1722,9 @@ convert_local_reference_op (tree *tp, int *walk_subtrees, void *data)\n \t    break;\n \t  wi->changed = true;\n \n-\t  x = get_local_debug_decl (info, t, field);\n-\t  if (!bitmap_bit_p (info->suppress_expansion, DECL_UID (t)))\n+\t  if (bitmap_bit_p (info->suppress_expansion, DECL_UID (t)))\n+\t    x = get_local_debug_decl (info, t, field);\n+\t  else\n \t    x = get_frame_field (info, info->context, field, &wi->gsi);\n \n \t  if (wi->val_only)\n@@ -2620,6 +2646,17 @@ convert_gimple_call (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       target_context = decl_function_context (decl);\n       if (target_context && DECL_STATIC_CHAIN (decl))\n \t{\n+\t  struct nesting_info *i = info;\n+\t  while (i && i->context != target_context)\n+\t    i = i->outer;\n+\t  /* If none of the outer contexts is the target context, this means\n+\t     that the function is called in a wrong context.  */\n+\t  if (!i)\n+\t    internal_error (\"%s from %s called in %s\",\n+\t\t\t    IDENTIFIER_POINTER (DECL_NAME (decl)),\n+\t\t\t    IDENTIFIER_POINTER (DECL_NAME (target_context)),\n+\t\t\t    IDENTIFIER_POINTER (DECL_NAME (info->context)));\n+\n \t  gimple_call_set_chain (as_a <gcall *> (stmt),\n \t\t\t\t get_static_chain (info, target_context,\n \t\t\t\t\t\t   &wi->gsi));\n@@ -2941,6 +2978,33 @@ remap_vla_decls (tree block, struct nesting_info *root)\n   delete id.cb.decl_map;\n }\n \n+/* Fixup VLA decls in BLOCK and subblocks if remapped variables are\n+   involved.  */\n+\n+static void\n+fixup_vla_decls (tree block)\n+{\n+  for (tree var = BLOCK_VARS (block); var; var = DECL_CHAIN (var))\n+    if (VAR_P (var) && DECL_HAS_VALUE_EXPR_P (var))\n+      {\n+\ttree val = DECL_VALUE_EXPR (var);\n+\n+\tif (!(TREE_CODE (val) == INDIRECT_REF\n+\t      && VAR_P (TREE_OPERAND (val, 0))\n+\t      && DECL_HAS_VALUE_EXPR_P (TREE_OPERAND (val, 0))))\n+\t  continue;\n+\n+\t/* Fully expand value expressions.  This avoids having debug variables\n+\t   only referenced from them and that can be swept during GC.  */\n+\tval = build1 (INDIRECT_REF, TREE_TYPE (val),\n+\t\t      DECL_VALUE_EXPR (TREE_OPERAND (val, 0)));\n+\tSET_DECL_VALUE_EXPR (var, val);\n+      }\n+\n+  for (tree sub = BLOCK_SUBBLOCKS (block); sub; sub = BLOCK_CHAIN (sub))\n+    fixup_vla_decls (sub);\n+}\n+\n /* Fold the MEM_REF *E.  */\n bool\n fold_mem_refs (tree *const &e, void *data ATTRIBUTE_UNUSED)\n@@ -3065,9 +3129,8 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n \t\t    gimple_seq_first_stmt (gimple_body (context)), true);\n     }\n \n-  /* If any parameters were referenced non-locally, then we need to\n-     insert a copy.  Likewise, if any variables were referenced by\n-     pointer, we need to initialize the address.  */\n+  /* If any parameters were referenced non-locally, then we need to insert\n+     a copy or a pointer.  */\n   if (root->any_parm_remapped)\n     {\n       tree p;\n@@ -3243,6 +3306,8 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n \t  = chainon (BLOCK_VARS (DECL_INITIAL (root->context)),\n \t\t     root->debug_var_chain);\n     }\n+  else\n+    fixup_vla_decls (DECL_INITIAL (root->context));\n \n   /* Fold the rewritten MEM_REF trees.  */\n   root->mem_refs->traverse<void *, fold_mem_refs> (NULL);"}, {"sha": "8082932988ba4c8238abd1dfb6fbf69957de6677", "filename": "gcc/tree.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70ba0c10dec6968d178303709204fdde3d8892f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70ba0c10dec6968d178303709204fdde3d8892f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d70ba0c10dec6968d178303709204fdde3d8892f", "patch": "@@ -6337,7 +6337,15 @@ decl_value_expr_lookup (tree from)\n \n   h = value_expr_for_decl->find_with_hash (&in, DECL_UID (from));\n   if (h)\n-    return h->to;\n+    {\n+      /* Chains of value expressions may run afoul of garbage collection.  */\n+      gcc_checking_assert (!(h->to\n+\t\t\t     && (TREE_CODE (h->to) == PARM_DECL\n+\t\t\t\t || TREE_CODE (h->to) == VAR_DECL)\n+\t\t\t     && DECL_HAS_VALUE_EXPR_P (h->to)));\n+      return h->to;\n+    }\n+\n   return NULL_TREE;\n }\n \n@@ -6348,6 +6356,12 @@ decl_value_expr_insert (tree from, tree to)\n {\n   struct tree_decl_map *h;\n \n+  /* Chains of value expressions may run afoul of garbage collection.  */\n+  gcc_checking_assert (!(to\n+\t\t\t && (TREE_CODE (to) == PARM_DECL\n+\t\t\t     || TREE_CODE (to) == VAR_DECL)\n+\t\t\t && DECL_HAS_VALUE_EXPR_P (to)));\n+\n   h = ggc_alloc<tree_decl_map> ();\n   h->base.from = from;\n   h->to = to;"}]}