{"sha": "6cf67b62c8cda035dccaca2ae6ff94d560b37a6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNmNjdiNjJjOGNkYTAzNWRjY2FjYTJhZTZmZjk0ZDU2MGIzN2E2Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-11-10T11:25:38Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-10T11:25:38Z"}, "message": "cgraph.h (struct cgraph_node): Add ipcp_clone flag.\n\n\n\t* cgraph.h (struct cgraph_node): Add ipcp_clone flag.\n\t(cgraph_node::create_virtual_clone): Copy it.\n\t* ipa-cp.c (ipcp_versionable_function_p): Watch for missing\n\tsummaries.\n\t(ignore_edge_p): If caller has ipa-cp disabled, skip the edge, too.\n\t(ipcp_verify_propagated_values): Do not verify nodes where ipcp\n\tis disabled.\n\t(propagate_constants_across_call): If callee is not analyzed, give up.\n\t(propagate_constants_topo): Lower to bottom latties of all callees of\n\tfunctions with ipa-cp disabled.\n\t(ipcp_propagate_stage): Skip functions with ipa-cp disabled.\n\t(cgraph_edge_brings_value_p): Check for availability first.\n\t(create_specialized_node): Set ipcp_clone.\n\t(ipcp_store_bits_results): Check that info is present.\n\t* ipa-fnsummary.c (evaluate_properties_for_edge): Do not analyze\n\tthunks.\n\t(ipa_call_context::duplicate_from, ipa_call_context::equal_to): Be\n\tconservative when callee summary is missing.\n\t(remap_edge_summaries): Lookup call summary only when needed.\n\t* ipa-icf.c (sem_function::param_used_p): Be ready for missing summary.\n\t* ipa-prpo.c (ipa_alloc_node_params, ipa_initialize_node_params):\n\tUse get_create.\n\t(ipa_analyze_node): Use get_create.\n\t(propagate_controlled_uses): Do not propagate when function is not\n\tanalyzed.\n\t(ipa_propagate_indirect_call_infos): Remove summary of inline clone.\n\t(ipa_read_node_info): Use get_create.\n\t* ipa-prop.h (IPA_NODE_REF): Use get.\n\t(IPA_NODE_REF_GET_CREATE): New.\n\nFrom-SVN: r278016", "tree": {"sha": "9a7cb2284e26f6d8f59e018c743ebdf3a8f7c3ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a7cb2284e26f6d8f59e018c743ebdf3a8f7c3ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f/comments", "author": null, "committer": null, "parents": [{"sha": "64166bf04b869e93570f8e728f4a71bb06d02ab8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64166bf04b869e93570f8e728f4a71bb06d02ab8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64166bf04b869e93570f8e728f4a71bb06d02ab8"}], "stats": {"total": 172, "additions": 118, "deletions": 54}, "files": [{"sha": "280f87804349c80ec335d252775505fa5a64f1a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6cf67b62c8cda035dccaca2ae6ff94d560b37a6f", "patch": "@@ -1,3 +1,35 @@\n+2019-11-09  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cgraph.h (struct cgraph_node): Add ipcp_clone flag.\n+\t(cgraph_node::create_virtual_clone): Copy it.\n+\t* ipa-cp.c (ipcp_versionable_function_p): Watch for missing\n+\tsummaries.\n+\t(ignore_edge_p): If caller has ipa-cp disabled, skip the edge, too.\n+\t(ipcp_verify_propagated_values): Do not verify nodes where ipcp\n+\tis disabled.\n+\t(propagate_constants_across_call): If callee is not analyzed, give up.\n+\t(propagate_constants_topo): Lower to bottom latties of all callees of\n+\tfunctions with ipa-cp disabled.\n+\t(ipcp_propagate_stage): Skip functions with ipa-cp disabled.\n+\t(cgraph_edge_brings_value_p): Check for availability first.\n+\t(create_specialized_node): Set ipcp_clone.\n+\t(ipcp_store_bits_results): Check that info is present.\n+\t* ipa-fnsummary.c (evaluate_properties_for_edge): Do not analyze\n+\tthunks.\n+\t(ipa_call_context::duplicate_from, ipa_call_context::equal_to): Be\n+\tconservative when callee summary is missing.\n+\t(remap_edge_summaries): Lookup call summary only when needed.\n+\t* ipa-icf.c (sem_function::param_used_p): Be ready for missing summary.\n+\t* ipa-prpo.c (ipa_alloc_node_params, ipa_initialize_node_params):\n+\tUse get_create.\n+\t(ipa_analyze_node): Use get_create.\n+\t(propagate_controlled_uses): Do not propagate when function is not\n+\tanalyzed.\n+\t(ipa_propagate_indirect_call_infos): Remove summary of inline clone.\n+\t(ipa_read_node_info): Use get_create.\n+\t* ipa-prop.h (IPA_NODE_REF): Use get.\n+\t(IPA_NODE_REF_GET_CREATE): New.\n+\n 2019-11-09  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-fnsummary.c (evaluate_properties_for_edge): Call IPA_NODE_REF"}, {"sha": "a4f14743f00882d921672ba6542d8e0338bc61ad", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=6cf67b62c8cda035dccaca2ae6ff94d560b37a6f", "patch": "@@ -1484,6 +1484,8 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   unsigned redefined_extern_inline : 1;\n   /* True if the function may enter serial irrevocable mode.  */\n   unsigned tm_may_enter_irr : 1;\n+  /* True if this was a clone created by ipa-cp.  */\n+  unsigned ipcp_clone : 1;\n \n private:\n   /* Unique id of the node.  */"}, {"sha": "bfcebb20495b6918e58af5f6abd12f9fbff5bf79", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=6cf67b62c8cda035dccaca2ae6ff94d560b37a6f", "patch": "@@ -570,6 +570,7 @@ cgraph_node::create_virtual_clone (vec<cgraph_edge *> redirect_callers,\n      ??? We cannot use COMDAT linkage because there is no\n      ABI support for this.  */\n   set_new_clone_decl_and_node_flags (new_node);\n+  new_node->ipcp_clone = ipcp_clone;\n   new_node->clone.tree_map = tree_map;\n   if (!implicit_section)\n     new_node->set_section (get_section ());"}, {"sha": "b1d899976e80ff73e13f73dc88492c093b5559d8", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=6cf67b62c8cda035dccaca2ae6ff94d560b37a6f", "patch": "@@ -656,7 +656,7 @@ determine_versionability (struct cgraph_node *node,\n static bool\n ipcp_versionable_function_p (struct cgraph_node *node)\n {\n-  return IPA_NODE_REF (node)->versionable;\n+  return IPA_NODE_REF (node) && IPA_NODE_REF (node)->versionable;\n }\n \n /* Structure holding accumulated information about callers of a node.  */\n@@ -817,6 +817,7 @@ ignore_edge_p (cgraph_edge *e)\n     = e->callee->function_or_virtual_thunk_symbol (&avail, e->caller);\n \n   return (avail <= AVAIL_INTERPOSABLE\n+\t  || !opt_for_fn (e->caller->decl, flag_ipa_cp)\n \t  || !opt_for_fn (ultimate_target->decl, flag_ipa_cp));\n }\n \n@@ -1471,6 +1472,8 @@ ipcp_verify_propagated_values (void)\n   FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n     {\n       class ipa_node_params *info = IPA_NODE_REF (node);\n+      if (!opt_for_fn (node->decl, flag_ipa_cp))\n+\tcontinue;\n       int i, count = ipa_get_param_count (info);\n \n       for (i = 0; i < count; i++)\n@@ -2307,6 +2310,8 @@ propagate_constants_across_call (struct cgraph_edge *cs)\n     return false;\n   gcc_checking_assert (callee->has_gimple_body_p ());\n   callee_info = IPA_NODE_REF (callee);\n+  if (!callee_info)\n+    return false;\n \n   args = IPA_EDGE_REF (cs);\n   parms_count = ipa_get_param_count (callee_info);\n@@ -3233,7 +3238,17 @@ propagate_constants_topo (class ipa_topo_info *topo)\n \t until all lattices stabilize.  */\n       FOR_EACH_VEC_ELT (cycle_nodes, j, v)\n \tif (v->has_gimple_body_p ())\n-\t  push_node_to_stack (topo, v);\n+\t  {\n+\t    if (opt_for_fn (v->decl, flag_ipa_cp))\n+\t      push_node_to_stack (topo, v);\n+\t    /* When V is not optimized, we can not push it to stac, but\n+\t       still we need to set all its callees lattices to bottom.  */\n+\t    else\n+\t      {\n+\t\tfor (cgraph_edge *cs = v->callees; cs; cs = cs->next_callee)\n+\t           propagate_constants_across_call (cs);\n+\t      }\n+\t  }\n \n       v = pop_node_from_stack (topo);\n       while (v)\n@@ -3254,7 +3269,8 @@ propagate_constants_topo (class ipa_topo_info *topo)\n \t the local effects of the discovered constants and all valid values to\n \t their topological sort.  */\n       FOR_EACH_VEC_ELT (cycle_nodes, j, v)\n-\tif (v->has_gimple_body_p ())\n+\tif (v->has_gimple_body_p ()\n+\t    && opt_for_fn (v->decl, flag_ipa_cp))\n \t  {\n \t    struct cgraph_edge *cs;\n \n@@ -3333,11 +3349,10 @@ ipcp_propagate_stage (class ipa_topo_info *topo)\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n   {\n-    class ipa_node_params *info = IPA_NODE_REF (node);\n-\n-    determine_versionability (node, info);\n-    if (node->has_gimple_body_p ())\n+    if (node->has_gimple_body_p () && opt_for_fn (node->decl, flag_ipa_cp))\n       {\n+        class ipa_node_params *info = IPA_NODE_REF (node);\n+        determine_versionability (node, info);\n \tinfo->lattices = XCNEWVEC (class ipcp_param_lattices,\n \t\t\t\t   ipa_get_param_count (info));\n \tinitialize_node_lattices (node);\n@@ -3526,8 +3541,8 @@ cgraph_edge_brings_value_p (cgraph_edge *cs, ipcp_value_source<tree> *src,\n   enum availability availability;\n   cgraph_node *real_dest = cs->callee->function_symbol (&availability);\n \n-  if (!same_node_or_its_all_contexts_clone_p (real_dest, dest)\n-      || availability <= AVAIL_INTERPOSABLE\n+  if (availability <= AVAIL_INTERPOSABLE\n+      || !same_node_or_its_all_contexts_clone_p (real_dest, dest)\n       || caller_info->node_dead)\n     return false;\n \n@@ -3583,9 +3598,11 @@ cgraph_edge_brings_value_p (cgraph_edge *cs,\n \t\t\t    ipcp_value<ipa_polymorphic_call_context> *)\n {\n   class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n-  cgraph_node *real_dest = cs->callee->function_symbol ();\n+  enum availability avail;\n+  cgraph_node *real_dest = cs->callee->function_symbol (&avail);\n \n-  if (!same_node_or_its_all_contexts_clone_p (real_dest, dest)\n+  if (avail <= AVAIL_INTERPOSABLE\n+      || !same_node_or_its_all_contexts_clone_p (real_dest, dest)\n       || caller_info->node_dead)\n     return false;\n   if (!src->val)\n@@ -4018,6 +4035,7 @@ create_specialized_node (struct cgraph_node *node,\n   update_profiling_info (node, new_node);\n   new_info = IPA_NODE_REF (new_node);\n   new_info->ipcp_orig_node = node;\n+  new_node->ipcp_clone = true;\n   new_info->known_csts = known_csts;\n   new_info->known_contexts = known_contexts;\n \n@@ -5053,7 +5071,7 @@ ipcp_store_bits_results (void)\n       bool dumped_sth = false;\n       bool found_useful_result = false;\n \n-      if (!opt_for_fn (node->decl, flag_ipa_bit_cp))\n+      if (!opt_for_fn (node->decl, flag_ipa_bit_cp) || !info)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Not considering %s for ipa bitwise propagation \""}, {"sha": "686d960f75be71b216030cc2b130f3776b750504", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=6cf67b62c8cda035dccaca2ae6ff94d560b37a6f", "patch": "@@ -483,36 +483,39 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n       if (count && known_contexts_ptr)\n \tknown_contexts_ptr->safe_grow_cleared (count);\n \n-      for (i = 0; i < count; i++)\n-\t{\n-\t  struct ipa_jump_func *jf = ipa_get_ith_jump_func (args, i);\n-\t  tree cst = ipa_value_from_jfunc (caller_parms_info, jf,\n-\t\t\t\t\t   ipa_get_type (callee_pi, i));\n-\n-\t  if (!cst && e->call_stmt\n-\t      && i < (int)gimple_call_num_args (e->call_stmt))\n-\t    {\n-\t      cst = gimple_call_arg (e->call_stmt, i);\n-\t      if (!is_gimple_min_invariant (cst))\n-\t\tcst = NULL;\n-\t    }\n-\t  if (cst)\n-\t    {\n-\t      gcc_checking_assert (TREE_CODE (cst) != TREE_BINFO);\n-\t      if (known_vals.exists ())\n-\t\tknown_vals[i] = cst;\n-\t    }\n-\t  else if (inline_p && !es->param[i].change_prob)\n-\t    known_vals[i] = error_mark_node;\n-\n-\t  if (known_contexts_ptr)\n-\t    (*known_contexts_ptr)[i]\n-\t      = ipa_context_from_jfunc (caller_parms_info, e, i, jf);\n-\t  /* TODO: When IPA-CP starts propagating and merging aggregate jump\n-\t     functions, use its knowledge of the caller too, just like the\n-\t     scalar case above.  */\n-\t  known_aggs[i] = &jf->agg;\n-\t}\n+      if (callee_pi)\n+\tfor (i = 0; i < count; i++)\n+\t  {\n+\t    struct ipa_jump_func *jf = ipa_get_ith_jump_func (args, i);\n+\t    tree cst = ipa_value_from_jfunc (caller_parms_info, jf,\n+\t\t\t\t\t     ipa_get_type (callee_pi, i));\n+\n+\t    if (!cst && e->call_stmt\n+\t\t&& i < (int)gimple_call_num_args (e->call_stmt))\n+\t      {\n+\t\tcst = gimple_call_arg (e->call_stmt, i);\n+\t\tif (!is_gimple_min_invariant (cst))\n+\t\t  cst = NULL;\n+\t      }\n+\t    if (cst)\n+\t      {\n+\t\tgcc_checking_assert (TREE_CODE (cst) != TREE_BINFO);\n+\t\tif (known_vals.exists ())\n+\t\t  known_vals[i] = cst;\n+\t      }\n+\t    else if (inline_p && !es->param[i].change_prob)\n+\t      known_vals[i] = error_mark_node;\n+\n+\t    if (known_contexts_ptr)\n+\t      (*known_contexts_ptr)[i]\n+\t\t= ipa_context_from_jfunc (caller_parms_info, e, i, jf);\n+\t    /* TODO: When IPA-CP starts propagating and merging aggregate jump\n+\t       functions, use its knowledge of the caller too, just like the\n+\t       scalar case above.  */\n+\t    known_aggs[i] = &jf->agg;\n+\t  }\n+\telse\n+\t  gcc_assert (callee->thunk.thunk_p);\n     }\n   else if (e->call_stmt && !e->call_stmt_cannot_inline_p\n \t   && ((clause_ptr && info->conds) || known_vals_ptr))\n@@ -3004,7 +3007,8 @@ ipa_call_context::duplicate_from (const ipa_call_context &ctx)\n   m_possible_truths = ctx.m_possible_truths;\n   m_nonspec_possible_truths = ctx.m_nonspec_possible_truths;\n   class ipa_node_params *params_summary = IPA_NODE_REF (m_node);\n-  unsigned int nargs = ipa_get_param_count (params_summary);\n+  unsigned int nargs = params_summary\n+\t\t       ? ipa_get_param_count (params_summary) : 0;\n \n   m_inline_param_summary = vNULL;\n   /* Copy the info only if there is at least one useful entry.  */\n@@ -3093,7 +3097,8 @@ ipa_call_context::equal_to (const ipa_call_context &ctx)\n     return false;\n \n   class ipa_node_params *params_summary = IPA_NODE_REF (m_node);\n-  unsigned int nargs = ipa_get_param_count (params_summary);\n+  unsigned int nargs = params_summary\n+\t\t       ? ipa_get_param_count (params_summary) : 0;\n \n   if (m_inline_param_summary.exists () || ctx.m_inline_param_summary.exists ())\n     {\n@@ -3404,7 +3409,7 @@ inline_update_callee_summaries (struct cgraph_node *node, int depth)\n }\n \n /* Update change_prob of EDGE after INLINED_EDGE has been inlined.\n-   When functoin A is inlined in B and A calls C with parameter that\n+   When function A is inlined in B and A calls C with parameter that\n    changes with probability PROB1 and C is known to be passthroug\n    of argument if B that change with probability PROB2, the probability\n    of change is now PROB1*PROB2.  */\n@@ -3472,12 +3477,12 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n   struct cgraph_edge *e, *next;\n   for (e = node->callees; e; e = next)\n     {\n-      class ipa_call_summary *es = ipa_call_summaries->get (e);\n       predicate p;\n       next = e->next_callee;\n \n       if (e->inline_failed)\n \t{\n+          class ipa_call_summary *es = ipa_call_summaries->get (e);\n \t  remap_edge_change_prob (inlined_edge, e);\n \n \t  if (es->predicate)"}, {"sha": "10aa4b764638817c871c10fc221ea1d842db782f", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=6cf67b62c8cda035dccaca2ae6ff94d560b37a6f", "patch": "@@ -484,7 +484,7 @@ sem_function::param_used_p (unsigned int i)\n \n   class ipa_node_params *parms_info = IPA_NODE_REF (get_node ());\n \n-  if (vec_safe_length (parms_info->descriptors) <= i)\n+  if (!parms_info || vec_safe_length (parms_info->descriptors) <= i)\n     return true;\n \n   return ipa_is_param_used (IPA_NODE_REF (get_node ()), i);"}, {"sha": "eb783e66926e95b6d940c6c3843650990ecc9da9", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=6cf67b62c8cda035dccaca2ae6ff94d560b37a6f", "patch": "@@ -271,7 +271,7 @@ ipa_dump_param (FILE *file, class ipa_node_params *info, int i)\n static bool\n ipa_alloc_node_params (struct cgraph_node *node, int param_count)\n {\n-  class ipa_node_params *info = IPA_NODE_REF (node);\n+  class ipa_node_params *info = IPA_NODE_REF_GET_CREATE (node);\n \n   if (!info->descriptors && param_count)\n     {\n@@ -289,7 +289,7 @@ ipa_alloc_node_params (struct cgraph_node *node, int param_count)\n void\n ipa_initialize_node_params (struct cgraph_node *node)\n {\n-  class ipa_node_params *info = IPA_NODE_REF (node);\n+  class ipa_node_params *info = IPA_NODE_REF_GET_CREATE (node);\n \n   if (!info->descriptors\n       && ipa_alloc_node_params (node, count_formal_params (node->decl)))\n@@ -2605,7 +2605,7 @@ ipa_analyze_node (struct cgraph_node *node)\n \n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();\n-  info = IPA_NODE_REF (node);\n+  info = IPA_NODE_REF_GET_CREATE (node);\n \n   if (info->analysis_done)\n     return;\n@@ -3601,6 +3601,9 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n   class ipa_node_params *old_root_info = IPA_NODE_REF (cs->callee);\n   int count, i;\n \n+  if (!old_root_info)\n+    return;\n+\n   count = MIN (ipa_get_cs_argument_count (args),\n \t       ipa_get_param_count (old_root_info));\n   for (i = 0; i < count; i++)\n@@ -3662,8 +3665,8 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \n \t\t  clone = cs->caller;\n \t\t  while (clone->inlined_to\n-\t\t\t && clone != rdesc->cs->caller\n-\t\t\t && IPA_NODE_REF (clone)->ipcp_orig_node)\n+\t\t\t && clone->ipcp_clone\n+\t\t\t && clone != rdesc->cs->caller)\n \t\t    {\n \t\t      struct ipa_ref *ref;\n \t\t      ref = clone->find_reference (n, NULL, 0);\n@@ -3722,6 +3725,7 @@ ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n \n   propagate_controlled_uses (cs);\n   changed = propagate_info_to_inlined_callees (cs, cs->callee, new_edges);\n+  ipa_node_params_sum->remove (cs->callee);\n \n   return changed;\n }\n@@ -4507,7 +4511,8 @@ ipa_read_node_info (class lto_input_block *ib, struct cgraph_node *node,\n   struct cgraph_edge *e;\n   struct bitpack_d bp;\n   bool prevails = node->prevailing_p ();\n-  class ipa_node_params *info = prevails ? IPA_NODE_REF (node) : NULL;\n+  class ipa_node_params *info = prevails\n+\t\t\t\t? IPA_NODE_REF_GET_CREATE (node) : NULL;\n \n   int param_count = streamer_read_uhwi (ib);\n   if (prevails)"}, {"sha": "952c01209f535d717b7c5633a4fb71a7eb3068ed", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf67b62c8cda035dccaca2ae6ff94d560b37a6f/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=6cf67b62c8cda035dccaca2ae6ff94d560b37a6f", "patch": "@@ -766,7 +766,8 @@ extern GTY(()) function_summary <ipcp_transformation *> *ipcp_transformation_sum\n \n /* Return the associated parameter/argument info corresponding to the given\n    node/edge.  */\n-#define IPA_NODE_REF(NODE) (ipa_node_params_sum->get_create (NODE))\n+#define IPA_NODE_REF(NODE) (ipa_node_params_sum->get (NODE))\n+#define IPA_NODE_REF_GET_CREATE(NODE) (ipa_node_params_sum->get_create (NODE))\n #define IPA_EDGE_REF(EDGE) (ipa_edge_args_sum->get (EDGE))\n #define IPA_EDGE_REF_GET_CREATE(EDGE) (ipa_edge_args_sum->get_create (EDGE))\n /* This macro checks validity of index returned by"}]}