{"sha": "7b13ee6b3288caad803c784ce57236dd8798d09d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IxM2VlNmIzMjg4Y2FhZDgwM2M3ODRjZTU3MjM2ZGQ4Nzk4ZDA5ZA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-11-17T22:29:29Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-11-17T22:29:29Z"}, "message": "expmed.c (alg_code): Add alg_unknown.\n\n\t* expmed.c (alg_code): Add alg_unknown.\n\t(alg_hash_entry): New.\n\t(NUM_ALG_HASH_ENTRIES): Likewise.\n\t(alg_hash): Likewise.\n\t(synth_mult): Cache the result into alg_hash.\n\nFrom-SVN: r90825", "tree": {"sha": "410b91a2d81e364628f93cbd69f04e819568a313", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/410b91a2d81e364628f93cbd69f04e819568a313"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b13ee6b3288caad803c784ce57236dd8798d09d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b13ee6b3288caad803c784ce57236dd8798d09d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b13ee6b3288caad803c784ce57236dd8798d09d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b13ee6b3288caad803c784ce57236dd8798d09d/comments", "author": null, "committer": null, "parents": [{"sha": "816ea94e170fb059d35ab8e832b9617c52627fea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/816ea94e170fb059d35ab8e832b9617c52627fea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/816ea94e170fb059d35ab8e832b9617c52627fea"}], "stats": {"total": 97, "additions": 94, "deletions": 3}, "files": [{"sha": "477aef768ecda11f7e4acc63eb8d1d3357403e5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b13ee6b3288caad803c784ce57236dd8798d09d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b13ee6b3288caad803c784ce57236dd8798d09d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b13ee6b3288caad803c784ce57236dd8798d09d", "patch": "@@ -1,3 +1,11 @@\n+2004-11-17  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* expmed.c (alg_code): Add alg_unknown.\n+\t(alg_hash_entry): New.\n+\t(NUM_ALG_HASH_ENTRIES): Likewise.\n+\t(alg_hash): Likewise.\n+\t(synth_mult): Cache the result into alg_hash.\n+\n 2004-11-17  Zack Weinberg  <zack@codesourcery.com>\n \n \t* config/rs6000/t-darwin: Augment SHLIB_MAPFILES with"}, {"sha": "23ae551f01f5d692c1d6cc5a35d35289000a171d", "filename": "gcc/expmed.c", "status": "modified", "additions": 86, "deletions": 3, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b13ee6b3288caad803c784ce57236dd8798d09d/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b13ee6b3288caad803c784ce57236dd8798d09d/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=7b13ee6b3288caad803c784ce57236dd8798d09d", "patch": "@@ -2297,7 +2297,7 @@ expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n   return temp;\n }\n \f\n-enum alg_code { alg_zero, alg_m, alg_shift,\n+enum alg_code { alg_unknown, alg_zero, alg_m, alg_shift,\n \t\t  alg_add_t_m2, alg_sub_t_m2,\n \t\t  alg_add_factor, alg_sub_factor,\n \t\t  alg_add_t2_m, alg_sub_t2_m };\n@@ -2364,6 +2364,26 @@ struct algorithm\n   char log[MAX_BITS_PER_WORD];\n };\n \n+/* The entry for our multiplication cache/hash table.  */\n+struct alg_hash_entry {\n+  /* The number we are multiplying by.  */\n+  unsigned int t;\n+\n+  /* The mode in which we are multiplying something by T.  */\n+  enum machine_mode mode;\n+\n+  /* The best multiplication algorithm for t.  */\n+  enum alg_code alg;\n+};\n+\n+/* The number of cache/hash entries.  */\n+#define NUM_ALG_HASH_ENTRIES 307\n+\n+/* Each entry of ALG_HASH caches alg_code for some integer.  This is\n+   actually a hash table.  If we have a collision, that the older\n+   entry is kicked out.  */\n+static struct alg_hash_entry alg_hash[NUM_ALG_HASH_ENTRIES];\n+\n /* Indicates the type of fixup needed after a constant multiplication.\n    BASIC_VARIANT means no fixup is needed, NEGATE_VARIANT means that\n    the result should be negated, and ADD_VARIANT means that the\n@@ -2400,6 +2420,9 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n   int op_cost, op_latency;\n   unsigned HOST_WIDE_INT q;\n   int maxm = MIN (BITS_PER_WORD, GET_MODE_BITSIZE (mode));\n+  int hash_index;\n+  bool cache_hit = false;\n+  enum alg_code cache_alg = alg_zero;\n \n   /* Indicate that no algorithm is yet found.  If no algorithm\n      is found, this value will be returned and indicate failure.  */\n@@ -2445,11 +2468,46 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n   best_alg = alloca (sizeof (struct algorithm));\n   best_cost = *cost_limit;\n \n+  /* Compute the hash index.  */\n+  hash_index = (t ^ (unsigned int) mode) % NUM_ALG_HASH_ENTRIES;\n+\n+  /* See if we already know what to do for T.  */\n+  if (alg_hash[hash_index].t == t\n+      && alg_hash[hash_index].mode == mode\n+      && alg_hash[hash_index].alg != alg_unknown)\n+    {\n+      cache_hit = true;\n+      cache_alg = alg_hash[hash_index].alg;\n+      switch (cache_alg)\n+\t{\n+\tcase alg_shift:\n+\t  goto do_alg_shift;\n+\n+\tcase alg_add_t_m2:\n+\tcase alg_sub_t_m2:\n+\t  goto do_alg_addsub_t_m2;\n+\n+\tcase alg_add_factor:\n+\tcase alg_sub_factor:\n+\t  goto do_alg_addsub_factor;\n+\n+\tcase alg_add_t2_m:\n+\t  goto do_alg_add_t2_m;\n+\n+\tcase alg_sub_t2_m:\n+\t  goto do_alg_sub_t2_m;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n   /* If we have a group of zero bits at the low-order part of T, try\n      multiplying by the remaining bits and then doing a shift.  */\n \n   if ((t & 1) == 0)\n     {\n+    do_alg_shift:\n       m = floor_log2 (t & -t);\t/* m = number of low zero bits */\n       if (m < maxm)\n \t{\n@@ -2475,13 +2533,16 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t      best_alg->op[best_alg->ops] = alg_shift;\n \t    }\n \t}\n+      if (cache_hit)\n+\tgoto done;\n     }\n \n   /* If we have an odd number, add or subtract one.  */\n   if ((t & 1) != 0)\n     {\n       unsigned HOST_WIDE_INT w;\n \n+    do_alg_addsub_t_m2:\n       for (w = 1; (w & t) != 0; w <<= 1)\n \t;\n       /* If T was -1, then W will be zero after the loop.  This is another\n@@ -2533,6 +2594,8 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t      best_alg->op[best_alg->ops] = alg_add_t_m2;\n \t    }\n \t}\n+      if (cache_hit)\n+\tgoto done;\n     }\n \n   /* Look for factors of t of the form\n@@ -2545,12 +2608,14 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n      good sequence quickly, and therefore be able to prune (by decreasing\n      COST_LIMIT) the search.  */\n \n+ do_alg_addsub_factor:\n   for (m = floor_log2 (t - 1); m >= 2; m--)\n     {\n       unsigned HOST_WIDE_INT d;\n \n       d = ((unsigned HOST_WIDE_INT) 1 << m) + 1;\n-      if (t % d == 0 && t > d && m < maxm)\n+      if (t % d == 0 && t > d && m < maxm\n+\t  && (!cache_hit || cache_alg == alg_add_factor))\n \t{\n \t  /* If the target has a cheap shift-and-add instruction use\n \t     that in preference to a shift insn followed by an add insn.\n@@ -2588,7 +2653,8 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t}\n \n       d = ((unsigned HOST_WIDE_INT) 1 << m) - 1;\n-      if (t % d == 0 && t > d && m < maxm)\n+      if (t % d == 0 && t > d && m < maxm\n+\t  && (!cache_hit || cache_alg == alg_sub_factor))\n \t{\n \t  /* If the target has a cheap shift-and-subtract insn use\n \t     that in preference to a shift insn followed by a sub insn.\n@@ -2624,11 +2690,14 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t  break;\n \t}\n     }\n+  if (cache_hit)\n+    goto done;\n \n   /* Try shift-and-add (load effective address) instructions,\n      i.e. do a*3, a*5, a*9.  */\n   if ((t & 1) != 0)\n     {\n+    do_alg_add_t2_m:\n       q = t - 1;\n       q = q & -q;\n       m = exact_log2 (q);\n@@ -2650,7 +2719,10 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t      best_alg->op[best_alg->ops] = alg_add_t2_m;\n \t    }\n \t}\n+      if (cache_hit)\n+\tgoto done;\n \n+    do_alg_sub_t2_m:\n       q = t + 1;\n       q = q & -q;\n       m = exact_log2 (q);\n@@ -2672,12 +2744,23 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \t      best_alg->op[best_alg->ops] = alg_sub_t2_m;\n \t    }\n \t}\n+      if (cache_hit)\n+\tgoto done;\n     }\n \n+ done:\n   /* If best_cost has not decreased, we have not found any algorithm.  */\n   if (!CHEAPER_MULT_COST (&best_cost, cost_limit))\n     return;\n \n+  /* Cache the result.  */\n+  if (!cache_hit)\n+    {\n+      alg_hash[hash_index].t = t;\n+      alg_hash[hash_index].mode = mode;\n+      alg_hash[hash_index].alg = best_alg->op[best_alg->ops];\n+    }\n+\n   /* If we are getting a too long sequence for `struct algorithm'\n      to record, make this search fail.  */\n   if (best_alg->ops == MAX_BITS_PER_WORD)"}]}