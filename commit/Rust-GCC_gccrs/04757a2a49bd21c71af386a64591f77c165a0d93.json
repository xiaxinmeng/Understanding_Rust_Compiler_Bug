{"sha": "04757a2a49bd21c71af386a64591f77c165a0d93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ3NTdhMmE0OWJkMjFjNzFhZjM4NmE2NDU5MWY3N2MxNjVhMGQ5Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2017-11-13T22:12:55Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2017-11-13T22:12:55Z"}, "message": "Defer folding of *&.\n\n\t* typeck.c (cp_build_fold_indirect_ref): New.\n\t(cp_build_indirect_ref_1): Split out from cp_build_indirect_ref.\n\tAdd 'fold' parameter.\n\t* cp-tree.h: Declare cp_build_fold_indirect_ref.\n\t* call.c, class.c, cp-ubsan.c, decl.c, except.c, init.c, lambda.c,\n\tparser.c, rtti.c, tree.c, typeck.c, typeck2.c: Use it.\n\t* parser.c (do_range_for_auto_deduction): Use RO_UNARY_STAR.\n\t(cp_convert_range_for): Likewise.\n\t* typeck2.c (build_x_arrow): Use RO_ARROW.\n\nFrom-SVN: r254712", "tree": {"sha": "1abdf8c3ce6efdfe6e521741c681eae3a746db70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1abdf8c3ce6efdfe6e521741c681eae3a746db70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04757a2a49bd21c71af386a64591f77c165a0d93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04757a2a49bd21c71af386a64591f77c165a0d93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04757a2a49bd21c71af386a64591f77c165a0d93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04757a2a49bd21c71af386a64591f77c165a0d93/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cd920e1348eaa1100b90f378f44e110152816149", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd920e1348eaa1100b90f378f44e110152816149", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd920e1348eaa1100b90f378f44e110152816149"}], "stats": {"total": 160, "additions": 94, "deletions": 66}, "files": [{"sha": "f71506b4ac2f08257b0fba084ab2eaaf85123d69", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=04757a2a49bd21c71af386a64591f77c165a0d93", "patch": "@@ -1,5 +1,16 @@\n 2017-11-13  Jason Merrill  <jason@redhat.com>\n \n+\tDefer folding of *&.\n+\t* typeck.c (cp_build_fold_indirect_ref): New.\n+\t(cp_build_indirect_ref_1): Split out from cp_build_indirect_ref.\n+\tAdd 'fold' parameter.\n+\t* cp-tree.h: Declare cp_build_fold_indirect_ref.\n+\t* call.c, class.c, cp-ubsan.c, decl.c, except.c, init.c, lambda.c,\n+\tparser.c, rtti.c, tree.c, typeck.c, typeck2.c: Use it.\n+\t* parser.c (do_range_for_auto_deduction): Use RO_UNARY_STAR.\n+\t(cp_convert_range_for): Likewise.\n+\t* typeck2.c (build_x_arrow): Use RO_ARROW.\n+\n \t* cp-ubsan.c (cp_ubsan_check_member_access_r): Fix handling of\n \tINDIRECT_REF of ADDR_EXPR.\n "}, {"sha": "e18f0770614e0264d5fcf193b370dec07b9e56ff", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=04757a2a49bd21c71af386a64591f77c165a0d93", "patch": "@@ -8063,7 +8063,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       if (targ)\n \targ = targ;\n       else\n-\targ = cp_build_indirect_ref (arg, RO_NULL, complain);\n+\targ = cp_build_fold_indirect_ref (arg);\n \n       /* In C++17 we shouldn't be copying a TARGET_EXPR except into a base\n \t subobject.  */\n@@ -8100,9 +8100,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       else if ((trivial || TREE_CODE (arg) == TARGET_EXPR)\n \t       && !unsafe_copy_elision_p (fa, arg))\n \t{\n-\t  tree to = cp_stabilize_reference (cp_build_indirect_ref (fa,\n-\t\t\t\t\t\t\t\t   RO_NULL,\n-\t\t\t\t\t\t\t\t   complain));\n+\t  tree to = cp_stabilize_reference (cp_build_fold_indirect_ref (fa));\n \n \t  val = build2 (INIT_EXPR, DECL_CONTEXT (fn), to, arg);\n \t  return val;\n@@ -8114,7 +8112,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t   && !DECL_DELETED_FN (fn))\n     {\n       tree to = cp_stabilize_reference\n-\t(cp_build_indirect_ref (argarray[0], RO_NULL, complain));\n+\t(cp_build_fold_indirect_ref (argarray[0]));\n       tree type = TREE_TYPE (to);\n       tree as_base = CLASSTYPE_AS_BASE (type);\n       tree arg = argarray[1];\n@@ -8127,7 +8125,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t}\n       else if (tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (as_base)))\n \t{\n-\t  arg = cp_build_indirect_ref (arg, RO_NULL, complain);\n+\t  arg = cp_build_fold_indirect_ref (arg);\n \t  val = build2 (MODIFY_EXPR, TREE_TYPE (to), to, arg);\n \t  /* Handle NSDMI that refer to the object being initialized.  */\n \t  replace_placeholders (arg, to);\n@@ -8166,7 +8164,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t    return force_target_expr (DECL_CONTEXT (fn), void_node,\n \t\t\t\t      no_cleanup_complain);\n \t  else\n-\t    return cp_build_indirect_ref (argarray[0], RO_NULL, complain);\n+\t    return cp_build_fold_indirect_ref (argarray[0]);\n \t}\n     }\n "}, {"sha": "586a32c436f7960fa172d43af8d47dff15027e20", "filename": "gcc/cp/class.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=04757a2a49bd21c71af386a64591f77c165a0d93", "patch": "@@ -425,7 +425,7 @@ build_base_path (enum tree_code code,\n \t interesting to the optimizers anyway.  */\n       && !has_empty)\n     {\n-      expr = cp_build_indirect_ref (expr, RO_NULL, complain);\n+      expr = cp_build_fold_indirect_ref (expr);\n       expr = build_simple_base_path (expr, binfo);\n       if (rvalue)\n \texpr = move (expr);\n@@ -452,7 +452,7 @@ build_base_path (enum tree_code code,\n \t  t = TREE_TYPE (TYPE_VFIELD (current_class_type));\n \t  t = build_pointer_type (t);\n \t  v_offset = fold_convert (t, current_vtt_parm);\n-\t  v_offset = cp_build_indirect_ref (v_offset, RO_NULL, complain);\n+\t  v_offset = cp_build_fold_indirect_ref (v_offset);\n \t}\n       else\n \t{\n@@ -465,8 +465,7 @@ build_base_path (enum tree_code code,\n \t      if (t == NULL_TREE)\n \t\tt = expr;\n \t    }\n-\t  v_offset = build_vfield_ref (cp_build_indirect_ref (t, RO_NULL,\n-\t\t\t\t\t\t\t      complain),\n+\t  v_offset = build_vfield_ref (cp_build_fold_indirect_ref (t),\n \t  TREE_TYPE (TREE_TYPE (expr)));\n \t}\n \n@@ -477,7 +476,7 @@ build_base_path (enum tree_code code,\n       v_offset = build1 (NOP_EXPR,\n \t\t\t build_pointer_type (ptrdiff_type_node),\n \t\t\t v_offset);\n-      v_offset = cp_build_indirect_ref (v_offset, RO_NULL, complain);\n+      v_offset = cp_build_fold_indirect_ref (v_offset);\n       TREE_CONSTANT (v_offset) = 1;\n \n       offset = convert_to_integer (ptrdiff_type_node,\n@@ -516,7 +515,7 @@ build_base_path (enum tree_code code,\n  indout:\n   if (!want_pointer)\n     {\n-      expr = cp_build_indirect_ref (expr, RO_NULL, complain);\n+      expr = cp_build_fold_indirect_ref (expr);\n       if (rvalue)\n \texpr = move (expr);\n     }\n@@ -552,7 +551,7 @@ build_simple_base_path (tree expr, tree binfo)\n \t in the back end.  */\n       temp = unary_complex_lvalue (ADDR_EXPR, expr);\n       if (temp)\n-\texpr = cp_build_indirect_ref (temp, RO_NULL, tf_warning_or_error);\n+\texpr = cp_build_fold_indirect_ref (temp);\n \n       return expr;\n     }\n@@ -745,8 +744,7 @@ build_vfn_ref (tree instance_ptr, tree idx)\n {\n   tree aref;\n \n-  aref = build_vtbl_ref_1 (cp_build_indirect_ref (instance_ptr, RO_NULL,\n-                                                  tf_warning_or_error), \n+  aref = build_vtbl_ref_1 (cp_build_fold_indirect_ref (instance_ptr),\n                            idx);\n \n   /* When using function descriptors, the address of the"}, {"sha": "ea61e87b2ec81e512c0dcbfb1130d212fd94753c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=04757a2a49bd21c71af386a64591f77c165a0d93", "patch": "@@ -7056,6 +7056,7 @@ extern tree build_x_indirect_ref\t\t(location_t, tree,\n \t\t\t\t\t\t ref_operator, tsubst_flags_t);\n extern tree cp_build_indirect_ref\t\t(tree, ref_operator,\n                                                  tsubst_flags_t);\n+extern tree cp_build_fold_indirect_ref\t\t(tree);\n extern tree build_array_ref\t\t\t(location_t, tree, tree);\n extern tree cp_build_array_ref\t\t\t(location_t, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);"}, {"sha": "c87c0303f57d841f1c8b0098df5d015a851f4194", "filename": "gcc/cp/cp-ubsan.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Fcp-ubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Fcp-ubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-ubsan.c?ref=04757a2a49bd21c71af386a64591f77c165a0d93", "patch": "@@ -298,8 +298,7 @@ cp_ubsan_dfs_initialize_vtbl_ptrs (tree binfo, void *data)\n \n       /* Compute the location of the vtpr.  */\n       tree vtbl_ptr\n-\t= build_vfield_ref (cp_build_indirect_ref (base_ptr, RO_NULL,\n-\t\t\t\t\t\t   tf_warning_or_error),\n+\t= build_vfield_ref (cp_build_fold_indirect_ref (base_ptr),\n \t\t\t    TREE_TYPE (binfo));\n       gcc_assert (vtbl_ptr != error_mark_node);\n "}, {"sha": "54077d5e331aa608a97b1d568f576991b59adc98", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=04757a2a49bd21c71af386a64591f77c165a0d93", "patch": "@@ -14899,7 +14899,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n       gcc_assert (TYPE_PTR_P (TREE_TYPE (t)));\n \n       cp_function_chain->x_current_class_ref\n-\t= cp_build_indirect_ref (t, RO_NULL, tf_warning_or_error);\n+\t= cp_build_fold_indirect_ref (t);\n       /* Set this second to avoid shortcut in cp_build_indirect_ref.  */\n       cp_function_chain->x_current_class_ptr = t;\n "}, {"sha": "47f267ffb93d93063ee8892c6a2d1456ef43ae3b", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=04757a2a49bd21c71af386a64591f77c165a0d93", "patch": "@@ -664,7 +664,7 @@ build_throw (tree exp)\n       CLEANUP_EH_ONLY (allocate_expr) = 1;\n \n       object = build_nop (build_pointer_type (temp_type), ptr);\n-      object = cp_build_indirect_ref (object, RO_NULL, tf_warning_or_error);\n+      object = cp_build_fold_indirect_ref (object);\n \n       /* And initialize the exception object.  */\n       if (CLASS_TYPE_P (temp_type))"}, {"sha": "1084ab1aa013a1f51f03cec977736623730adb8a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=04757a2a49bd21c71af386a64591f77c165a0d93", "patch": "@@ -1260,8 +1260,7 @@ emit_mem_initializers (tree mem_inits)\n \t  base_addr = build_base_path (PLUS_EXPR, current_class_ptr,\n \t\t\t\t       subobject, 1, tf_warning_or_error);\n \t  expand_aggr_init_1 (subobject, NULL_TREE,\n-\t\t\t      cp_build_indirect_ref (base_addr, RO_NULL,\n-                                                     tf_warning_or_error),\n+\t\t\t      cp_build_fold_indirect_ref (base_addr),\n \t\t\t      arguments,\n \t\t\t      flags,\n                               tf_warning_or_error);\n@@ -1351,7 +1350,7 @@ expand_virtual_init (tree binfo, tree decl)\n       /* Compute the value to use, when there's a VTT.  */\n       vtt_parm = current_vtt_parm;\n       vtbl2 = fold_build_pointer_plus (vtt_parm, vtt_index);\n-      vtbl2 = cp_build_indirect_ref (vtbl2, RO_NULL, tf_warning_or_error);\n+      vtbl2 = cp_build_fold_indirect_ref (vtbl2);\n       vtbl2 = convert (TREE_TYPE (vtbl), vtbl2);\n \n       /* The actual initializer is the VTT value only in the subobject\n@@ -1361,8 +1360,7 @@ expand_virtual_init (tree binfo, tree decl)\n     }\n \n   /* Compute the location of the vtpr.  */\n-  vtbl_ptr = build_vfield_ref (cp_build_indirect_ref (decl, RO_NULL, \n-                                                      tf_warning_or_error),\n+  vtbl_ptr = build_vfield_ref (cp_build_fold_indirect_ref (decl),\n \t\t\t       TREE_TYPE (binfo));\n   gcc_assert (vtbl_ptr != error_mark_node);\n \n@@ -3268,7 +3266,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t\t\t\t\t\talloc_node, cookie_ptr);\n       size_ptr_type = build_pointer_type (sizetype);\n       cookie_ptr = fold_convert (size_ptr_type, cookie_ptr);\n-      cookie = cp_build_indirect_ref (cookie_ptr, RO_NULL, complain);\n+      cookie = cp_build_fold_indirect_ref (cookie_ptr);\n \n       cookie_expr = build2 (MODIFY_EXPR, sizetype, cookie, nelts);\n \n@@ -3280,7 +3278,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t\t\t\t\t\tNEGATE_EXPR, sizetype,\n \t\t\t\t\t\tsize_in_bytes (sizetype)));\n \n-\t  cookie = cp_build_indirect_ref (cookie_ptr, RO_NULL, complain);\n+\t  cookie = cp_build_fold_indirect_ref (cookie_ptr);\n \t  cookie = build2 (MODIFY_EXPR, sizetype, cookie,\n \t\t\t   size_in_bytes (elt_type));\n \t  cookie_expr = build2 (COMPOUND_EXPR, TREE_TYPE (cookie_expr),\n@@ -3326,7 +3324,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t     the initializer anyway since we're going to throw it away and\n \t     rebuild it at instantiation time, so just build up a single\n \t     constructor call to get any appropriate diagnostics.  */\n-\t  init_expr = cp_build_indirect_ref (data_addr, RO_NULL, complain);\n+\t  init_expr = cp_build_fold_indirect_ref (data_addr);\n \t  if (type_build_ctor_call (elt_type))\n \t    init_expr = build_special_member_call (init_expr,\n \t\t\t\t\t\t   complete_ctor_identifier,\n@@ -3384,7 +3382,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t}\n       else\n \t{\n-\t  init_expr = cp_build_indirect_ref (data_addr, RO_NULL, complain);\n+\t  init_expr = cp_build_fold_indirect_ref (data_addr);\n \n \t  if (type_build_ctor_call (type) && !explicit_value_init_p)\n \t    {\n@@ -4507,7 +4505,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n     {\n       atype = build_pointer_type (atype);\n       stmt_expr = build1 (NOP_EXPR, atype, stmt_expr);\n-      stmt_expr = cp_build_indirect_ref (stmt_expr, RO_NULL, complain);\n+      stmt_expr = cp_build_fold_indirect_ref (stmt_expr);\n       TREE_NO_WARNING (stmt_expr) = 1;\n     }\n \n@@ -4661,8 +4659,7 @@ build_delete (tree otype, tree addr, special_function_kind auto_delete,\n       /* Make sure the destructor is callable.  */\n       if (type_build_dtor_call (type))\n \t{\n-\t  expr = build_dtor_call (cp_build_indirect_ref (addr, RO_NULL,\n-\t\t\t\t\t\t\t complain),\n+\t  expr = build_dtor_call (cp_build_fold_indirect_ref (addr),\n \t\t\t\t  sfk_complete_destructor, flags, complain);\n \t  if (expr == error_mark_node)\n \t    return error_mark_node;\n@@ -4738,7 +4735,7 @@ build_delete (tree otype, tree addr, special_function_kind auto_delete,\n \t\t\t\tcomplain);\n \t}\n \n-      expr = build_dtor_call (cp_build_indirect_ref (addr, RO_NULL, complain),\n+      expr = build_dtor_call (cp_build_fold_indirect_ref (addr),\n \t\t\t      auto_delete, flags, complain);\n       if (expr == error_mark_node)\n \treturn error_mark_node;\n@@ -4918,7 +4915,7 @@ build_vec_delete (tree base, tree maxindex,\n \t\t\t\t sizetype, TYPE_SIZE_UNIT (sizetype));\n       cookie_addr = fold_build_pointer_plus (fold_convert (size_ptr_type, base),\n \t\t\t\t\t     cookie_addr);\n-      maxindex = cp_build_indirect_ref (cookie_addr, RO_NULL, complain);\n+      maxindex = cp_build_fold_indirect_ref (cookie_addr);\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {"}, {"sha": "7c8b64094096f5901f13a1866b4a36faa6915f53", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=04757a2a49bd21c71af386a64591f77c165a0d93", "patch": "@@ -557,8 +557,7 @@ add_capture (tree lambda, tree id, tree orig_init, bool by_reference_p,\n \t{\n \t  gcc_assert (POINTER_TYPE_P (type));\n \t  type = TREE_TYPE (type);\n-\t  initializer = cp_build_indirect_ref (initializer, RO_NULL,\n-\t\t\t\t\t       tf_warning_or_error);\n+\t  initializer = cp_build_fold_indirect_ref (initializer);\n \t}\n \n       if (dependent_type_p (type))\n@@ -862,8 +861,7 @@ maybe_resolve_dummy (tree object, bool add_capture_p)\n   if (tree lam = resolvable_dummy_lambda (object))\n     if (tree cap = lambda_expr_this_capture (lam, add_capture_p))\n       if (cap != error_mark_node)\n-\tobject = build_x_indirect_ref (EXPR_LOCATION (object), cap,\n-\t\t\t\t       RO_NULL, tf_warning_or_error);\n+\tobject = build_fold_indirect_ref (cap);\n \n   return object;\n }\n@@ -1154,8 +1152,7 @@ maybe_add_lambda_conv_op (tree type)\n \t return expression for a deduced return call op to allow for simple\n \t implementation of the conversion operator.  */\n \n-      tree instance = cp_build_indirect_ref (thisarg, RO_NULL,\n-\t\t\t\t\t     tf_warning_or_error);\n+      tree instance = cp_build_fold_indirect_ref (thisarg);\n       tree objfn = build_min (COMPONENT_REF, NULL_TREE,\n \t\t\t      instance, DECL_NAME (callop), NULL_TREE);\n       int nargs = list_length (DECL_ARGUMENTS (callop)) - 1;"}, {"sha": "1860bf0f175356774183fe99a5133ec70f84939a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=04757a2a49bd21c71af386a64591f77c165a0d93", "patch": "@@ -11931,7 +11931,8 @@ do_range_for_auto_deduction (tree decl, tree range_expr)\n \t{\n \t  iter_decl = build_decl (input_location, VAR_DECL, NULL_TREE,\n \t\t\t\t  iter_type);\n-\t  iter_decl = build_x_indirect_ref (input_location, iter_decl, RO_NULL,\n+\t  iter_decl = build_x_indirect_ref (input_location, iter_decl,\n+\t\t\t\t\t    RO_UNARY_STAR,\n \t\t\t\t\t    tf_warning_or_error);\n \t  TREE_TYPE (decl) = do_auto_deduction (TREE_TYPE (decl),\n \t\t\t\t\t\titer_decl, auto_node);\n@@ -12048,7 +12049,7 @@ cp_convert_range_for (tree statement, tree range_decl, tree range_expr,\n \n   /* The declaration is initialized with *__begin inside the loop body.  */\n   cp_finish_decl (range_decl,\n-\t\t  build_x_indirect_ref (input_location, begin, RO_NULL,\n+\t\t  build_x_indirect_ref (input_location, begin, RO_UNARY_STAR,\n \t\t\t\t\ttf_warning_or_error),\n \t\t  /*is_constant_init*/false, NULL_TREE,\n \t\t  LOOKUP_ONLYCONVERTING);\n@@ -20843,7 +20844,7 @@ inject_this_parameter (tree ctype, cp_cv_quals quals)\n   /* Clear this first to avoid shortcut in cp_build_indirect_ref.  */\n   current_class_ptr = NULL_TREE;\n   current_class_ref\n-    = cp_build_indirect_ref (this_parm, RO_NULL, tf_warning_or_error);\n+    = cp_build_fold_indirect_ref (this_parm);\n   current_class_ptr = this_parm;\n }\n "}, {"sha": "b158507d7a8e905dbcde902e5c2b2bbaf58053ce", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=04757a2a49bd21c71af386a64591f77c165a0d93", "patch": "@@ -206,8 +206,7 @@ build_headof (tree exp)\n   index = build_int_cst (NULL_TREE,\n \t\t\t -2 * TARGET_VTABLE_DATA_ENTRY_DISTANCE);\n \n-  offset = build_vtbl_ref (cp_build_indirect_ref (exp, RO_NULL, \n-                                                  tf_warning_or_error), \n+  offset = build_vtbl_ref (cp_build_fold_indirect_ref (exp),\n                            index);\n \n   type = cp_build_qualified_type (ptr_type_node,\n@@ -303,7 +302,7 @@ get_tinfo_decl_dynamic (tree exp, tsubst_flags_t complain)\n     /* Otherwise return the type_info for the static type of the expr.  */\n     t = get_tinfo_ptr (TYPE_MAIN_VARIANT (type));\n \n-  return cp_build_indirect_ref (t, RO_NULL, complain);\n+  return cp_build_fold_indirect_ref (t);\n }\n \n static bool\n@@ -365,7 +364,7 @@ build_typeid (tree exp, tsubst_flags_t complain)\n       exp = cp_build_addr_expr (exp, complain);\n       exp = save_expr (exp);\n       cond = cp_convert (boolean_type_node, exp, complain);\n-      exp = cp_build_indirect_ref (exp, RO_NULL, complain);\n+      exp = cp_build_fold_indirect_ref (exp);\n     }\n \n   exp = get_tinfo_decl_dynamic (exp, complain);\n@@ -529,7 +528,7 @@ get_typeid (tree type, tsubst_flags_t complain)\n   if (!type)\n     return error_mark_node;\n \n-  return cp_build_indirect_ref (get_tinfo_ptr (type), RO_NULL, complain);\n+  return cp_build_fold_indirect_ref (get_tinfo_ptr (type));\n }\n \n /* Check whether TEST is null before returning RESULT.  If TEST is used in"}, {"sha": "c60d54ab01fb498d1b030a0f2fd5a51db01c3598", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=04757a2a49bd21c71af386a64591f77c165a0d93", "patch": "@@ -3841,7 +3841,7 @@ tree\n build_dummy_object (tree type)\n {\n   tree decl = build1 (CONVERT_EXPR, build_pointer_type (type), void_node);\n-  return cp_build_indirect_ref (decl, RO_NULL, tf_warning_or_error);\n+  return cp_build_fold_indirect_ref (decl);\n }\n \n /* We've gotten a reference to a member of TYPE.  Return *this if appropriate,\n@@ -5011,7 +5011,7 @@ stabilize_expr (tree exp, tree* initp)\n       exp = cp_build_addr_expr (exp, tf_warning_or_error);\n       init_expr = get_target_expr (exp);\n       exp = TARGET_EXPR_SLOT (init_expr);\n-      exp = cp_build_indirect_ref (exp, RO_NULL, tf_warning_or_error);\n+      exp = cp_build_fold_indirect_ref (exp);\n       if (xval)\n \texp = move (exp);\n     }"}, {"sha": "f9a5f85146355082348e09531b89f82e909238bb", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 41, "deletions": 14, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=04757a2a49bd21c71af386a64591f77c165a0d93", "patch": "@@ -2356,7 +2356,7 @@ build_class_member_access_expr (cp_expr object, tree member,\n   {\n     tree temp = unary_complex_lvalue (ADDR_EXPR, object);\n     if (temp)\n-      object = cp_build_indirect_ref (temp, RO_NULL, complain);\n+      object = cp_build_fold_indirect_ref (temp);\n   }\n \n   /* In [expr.ref], there is an explicit list of the valid choices for\n@@ -3035,20 +3035,19 @@ build_x_indirect_ref (location_t loc, tree expr, ref_operator errorstring,\n     return rval;\n }\n \n-/* Helper function called from c-common.  */\n-tree\n-build_indirect_ref (location_t /*loc*/,\n-\t\t    tree ptr, ref_operator errorstring)\n-{\n-  return cp_build_indirect_ref (ptr, errorstring, tf_warning_or_error);\n-}\n+/* The implementation of the above, and of indirection implied by other\n+   constructs.  If DO_FOLD is true, fold away INDIRECT_REF of ADDR_EXPR.  */\n \n-tree\n-cp_build_indirect_ref (tree ptr, ref_operator errorstring, \n-                       tsubst_flags_t complain)\n+static tree\n+cp_build_indirect_ref_1 (tree ptr, ref_operator errorstring,\n+\t\t\t tsubst_flags_t complain, bool do_fold)\n {\n   tree pointer, type;\n \n+  /* RO_NULL should only be used with the folding entry points below, not\n+     cp_build_indirect_ref.  */\n+  gcc_checking_assert (errorstring != RO_NULL || do_fold);\n+\n   if (ptr == current_class_ptr\n       || (TREE_CODE (ptr) == NOP_EXPR\n \t  && TREE_OPERAND (ptr, 0) == current_class_ptr\n@@ -3092,7 +3091,7 @@ cp_build_indirect_ref (tree ptr, ref_operator errorstring,\n             error (\"%qT is not a pointer-to-object type\", type);\n \t  return error_mark_node;\n \t}\n-      else if (TREE_CODE (pointer) == ADDR_EXPR\n+      else if (do_fold && TREE_CODE (pointer) == ADDR_EXPR\n \t       && same_type_p (t, TREE_TYPE (TREE_OPERAND (pointer, 0))))\n \t/* The POINTER was something like `&x'.  We simplify `*&x' to\n \t   `x'.  */\n@@ -3141,6 +3140,34 @@ cp_build_indirect_ref (tree ptr, ref_operator errorstring,\n   return error_mark_node;\n }\n \n+/* Entry point used by c-common, which expects folding.  */\n+\n+tree\n+build_indirect_ref (location_t /*loc*/,\n+\t\t    tree ptr, ref_operator errorstring)\n+{\n+  return cp_build_indirect_ref_1 (ptr, errorstring, tf_warning_or_error, true);\n+}\n+\n+/* Entry point used by internal indirection needs that don't correspond to any\n+   syntactic construct.  */\n+\n+tree\n+cp_build_fold_indirect_ref (tree pointer)\n+{\n+  return cp_build_indirect_ref_1 (pointer, RO_NULL, tf_warning_or_error, true);\n+}\n+\n+/* Entry point used by indirection needs that correspond to some syntactic\n+   construct.  */\n+\n+tree\n+cp_build_indirect_ref (tree ptr, ref_operator errorstring,\n+\t\t       tsubst_flags_t complain)\n+{\n+  return cp_build_indirect_ref_1 (ptr, errorstring, complain, false);\n+}\n+\n /* This handles expressions of the form \"a[i]\", which denotes\n    an array reference.\n \n@@ -3477,13 +3504,13 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function,\n       /* Next extract the vtable pointer from the object.  */\n       vtbl = build1 (NOP_EXPR, build_pointer_type (vtbl_ptr_type_node),\n \t\t     instance_ptr);\n-      vtbl = cp_build_indirect_ref (vtbl, RO_NULL, complain);\n+      vtbl = cp_build_fold_indirect_ref (vtbl);\n       if (vtbl == error_mark_node)\n \treturn error_mark_node;\n \n       /* Finally, extract the function pointer from the vtable.  */\n       e2 = fold_build_pointer_plus_loc (input_location, vtbl, idx);\n-      e2 = cp_build_indirect_ref (e2, RO_NULL, complain);\n+      e2 = cp_build_fold_indirect_ref (e2);\n       if (e2 == error_mark_node)\n \treturn error_mark_node;\n       TREE_CONSTANT (e2) = 1;"}, {"sha": "e135b0de363503bfa1e89dcd97d977e466020c91", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04757a2a49bd21c71af386a64591f77c165a0d93/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=04757a2a49bd21c71af386a64591f77c165a0d93", "patch": "@@ -1792,7 +1792,7 @@ build_x_arrow (location_t loc, tree expr, tsubst_flags_t complain)\n \t  return expr;\n \t}\n \n-      return cp_build_indirect_ref (last_rval, RO_NULL, complain);\n+      return cp_build_indirect_ref (last_rval, RO_ARROW, complain);\n     }\n \n   if (complain & tf_error)\n@@ -1893,7 +1893,7 @@ build_m_component_ref (tree datum, tree component, tsubst_flags_t complain)\n \t value stored in the pointer-to-data-member.  */\n       ptype = build_pointer_type (type);\n       datum = fold_build_pointer_plus (fold_convert (ptype, datum), component);\n-      datum = cp_build_indirect_ref (datum, RO_NULL, complain);\n+      datum = cp_build_fold_indirect_ref (datum);\n       if (datum == error_mark_node)\n \treturn error_mark_node;\n "}]}