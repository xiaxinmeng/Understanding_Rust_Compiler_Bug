{"sha": "162871481ad35e10abf02b053a2c31d3bcf0ea7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYyODcxNDgxYWQzNWUxMGFiZjAyYjA1M2EyYzMxZDNiY2YwZWE3Yw==", "commit": {"author": {"name": "Andreas Tobler", "email": "a.tobler@schweiz.org", "date": "2007-12-01T21:00:04Z"}, "committer": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2007-12-01T21:00:04Z"}, "message": "re PR libffi/31937 (libffi doesn't support ppc without FPU)\n\n2007-12-01  Andreas Tobler  <a.tobler@schweiz.org>\n\n\tPR libffi/31937\n\t* src/powerpc/ffitarget.h: Introduce new ABI FFI_LINUX_SOFT_FLOAT.\n\tAdd local FFI_TYPE_UINT128 to handle soft-float long-double-128.\n\t* src/powerpc/ffi.c: Distinguish between __NO_FPRS__ and not and\n\tset the NUM_FPR_ARG_REGISTERS according to.\n\tAdd support for potential soft-float support under hard-float\n\tarchitecture.\n\t(ffi_prep_args_SYSV): Set NUM_FPR_ARG_REGISTERS to 0 in case of\n\tFFI_LINUX_SOFT_FLOAT, handle float, doubles and long-doubles according\n\tto the FFI_LINUX_SOFT_FLOAT ABI.\n\t(ffi_prep_cif_machdep): Likewise.\n\t(ffi_closure_helper_SYSV): Likewise.\n\t* src/powerpc/ppc_closure.S: Make sure not to store float/double\n\ton archs where __NO_FPRS__ is true.\n\tAdd FFI_TYPE_UINT128 support.\n\t* src/powerpc/sysv.S: Add support for soft-float long-double-128.\n\tAdjust copyright notice.\n\nFrom-SVN: r130559", "tree": {"sha": "73196b5cf4cff2f63d926463844136cb3c56797e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73196b5cf4cff2f63d926463844136cb3c56797e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/162871481ad35e10abf02b053a2c31d3bcf0ea7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/162871481ad35e10abf02b053a2c31d3bcf0ea7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/162871481ad35e10abf02b053a2c31d3bcf0ea7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/162871481ad35e10abf02b053a2c31d3bcf0ea7c/comments", "author": null, "committer": null, "parents": [{"sha": "e78b91ce0e473db3da75800ece2f106bac3f4c1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e78b91ce0e473db3da75800ece2f106bac3f4c1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e78b91ce0e473db3da75800ece2f106bac3f4c1c"}], "stats": {"total": 262, "additions": 222, "deletions": 40}, "files": [{"sha": "91609e3a79b0713f73e9134f8b5a8fc61dc2169e", "filename": "libffi/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162871481ad35e10abf02b053a2c31d3bcf0ea7c/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162871481ad35e10abf02b053a2c31d3bcf0ea7c/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=162871481ad35e10abf02b053a2c31d3bcf0ea7c", "patch": "@@ -1,3 +1,23 @@\n+2007-12-01  Andreas Tobler  <a.tobler@schweiz.org>\n+\n+\tPR libffi/31937\n+\t* src/powerpc/ffitarget.h: Introduce new ABI FFI_LINUX_SOFT_FLOAT.\n+\tAdd local FFI_TYPE_UINT128 to handle soft-float long-double-128.\n+\t* src/powerpc/ffi.c: Distinguish between __NO_FPRS__ and not and\n+\tset the NUM_FPR_ARG_REGISTERS according to.\n+\tAdd support for potential soft-float support under hard-float\n+\tarchitecture.\n+\t(ffi_prep_args_SYSV): Set NUM_FPR_ARG_REGISTERS to 0 in case of\n+\tFFI_LINUX_SOFT_FLOAT, handle float, doubles and long-doubles according\n+\tto the FFI_LINUX_SOFT_FLOAT ABI.\n+\t(ffi_prep_cif_machdep): Likewise.\n+\t(ffi_closure_helper_SYSV): Likewise.\n+\t* src/powerpc/ppc_closure.S: Make sure not to store float/double\n+\ton archs where __NO_FPRS__ is true.\n+\tAdd FFI_TYPE_UINT128 support.\n+\t* src/powerpc/sysv.S: Add support for soft-float long-double-128.\n+\tAdjust copyright notice.\n+\n 2007-11-25  Andreas Tobler  <a.tobler@schweiz.org>\n \n \t* src/closures.c: Move defintion of MAYBE_UNUSED from here to ..."}, {"sha": "e6b869f8737c9c287cee20ca5f5a366c0c0156ba", "filename": "libffi/src/powerpc/ffi.c", "status": "modified", "additions": 167, "deletions": 36, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162871481ad35e10abf02b053a2c31d3bcf0ea7c/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162871481ad35e10abf02b053a2c31d3bcf0ea7c/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi.c?ref=162871481ad35e10abf02b053a2c31d3bcf0ea7c", "patch": "@@ -50,10 +50,13 @@ enum {\n };\n \n /* About the SYSV ABI.  */\n-enum {\n-  NUM_GPR_ARG_REGISTERS = 8,\n-  NUM_FPR_ARG_REGISTERS = 8\n-};\n+unsigned int NUM_GPR_ARG_REGISTERS = 8;\n+#ifndef __NO_FPRS__\n+unsigned int NUM_FPR_ARG_REGISTERS = 8;\n+#else\n+unsigned int NUM_FPR_ARG_REGISTERS = 0;\n+#endif\n+\n enum { ASM_NEEDS_REGISTERS = 4 };\n \n /* ffi_prep_args_SYSV is called by the assembly routine once stack space\n@@ -116,7 +119,7 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n   /* 'next_arg' grows up as we put parameters in it.  */\n   valp next_arg;\n \n-  int i;\n+  int i, ii MAYBE_UNUSED;\n   ffi_type **ptr;\n   double double_tmp;\n   union {\n@@ -134,6 +137,9 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n   size_t struct_copy_size;\n   unsigned gprvalue;\n \n+  if (ecif->cif->abi == FFI_LINUX_SOFT_FLOAT)\n+    NUM_FPR_ARG_REGISTERS = 0;\n+\n   stacktop.c = (char *) stack + bytes;\n   gpr_base.u = stacktop.u - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS;\n   intarg_count = 0;\n@@ -165,6 +171,9 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n       switch ((*ptr)->type)\n \t{\n \tcase FFI_TYPE_FLOAT:\n+\t  /* With FFI_LINUX_SOFT_FLOAT floats are handled like UINT32.  */\n+\t  if (ecif->cif->abi == FFI_LINUX_SOFT_FLOAT)\n+\t    goto soft_float_prep;\n \t  double_tmp = **p_argv.f;\n \t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n \t    {\n@@ -178,6 +187,9 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n \t  break;\n \n \tcase FFI_TYPE_DOUBLE:\n+\t  /* With FFI_LINUX_SOFT_FLOAT doubles are handled like UINT64.  */\n+\t  if (ecif->cif->abi == FFI_LINUX_SOFT_FLOAT)\n+\t    goto soft_double_prep;\n \t  double_tmp = **p_argv.d;\n \n \t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n@@ -199,38 +211,75 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n \n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \tcase FFI_TYPE_LONGDOUBLE:\n-\t  if (ecif->cif->abi != FFI_LINUX)\n+\t  if ((ecif->cif->abi != FFI_LINUX)\n+\t\t&& (ecif->cif->abi != FFI_LINUX_SOFT_FLOAT))\n \t    goto do_struct;\n-\t  double_tmp = (*p_argv.d)[0];\n-\n-\t  if (fparg_count >= NUM_FPR_ARG_REGISTERS - 1)\n+\t  /* The soft float ABI for long doubles works like this,\n+\t     a long double is passed in four consecutive gprs if available.\n+\t     A maximum of 2 long doubles can be passed in gprs.\n+\t     If we do not have 4 gprs left, the long double is passed on the\n+\t     stack, 4-byte aligned.  */\n+\t  if (ecif->cif->abi == FFI_LINUX_SOFT_FLOAT)\n \t    {\n-\t      if (intarg_count >= NUM_GPR_ARG_REGISTERS\n-\t\t  && intarg_count % 2 != 0)\n+\t      unsigned int int_tmp = (*p_argv.ui)[0];\n+\t      if (intarg_count >= NUM_GPR_ARG_REGISTERS - 3)\n \t\t{\n-\t\t  intarg_count++;\n+\t\t  if (intarg_count < NUM_GPR_ARG_REGISTERS)\n+\t\t    intarg_count += NUM_GPR_ARG_REGISTERS - intarg_count;\n+\t\t  *next_arg.u = int_tmp;\n \t\t  next_arg.u++;\n+\t\t  for (ii = 1; ii < 4; ii++)\n+\t\t    {\n+\t\t      int_tmp = (*p_argv.ui)[ii];\n+\t\t      *next_arg.u = int_tmp;\n+\t\t      next_arg.u++;\n+\t\t    }\n \t\t}\n-\t      *next_arg.d = double_tmp;\n-\t      next_arg.u += 2;\n-\t      double_tmp = (*p_argv.d)[1];\n-\t      *next_arg.d = double_tmp;\n-\t      next_arg.u += 2;\n+\t      else\n+\t\t{\n+\t\t  *gpr_base.u++ = int_tmp;\n+\t\t  for (ii = 1; ii < 4; ii++)\n+\t\t    {\n+\t\t      int_tmp = (*p_argv.ui)[ii];\n+\t\t      *gpr_base.u++ = int_tmp;\n+\t\t    }\n+\t\t}\n+\t      intarg_count +=4;\n \t    }\n \t  else\n \t    {\n-\t      *fpr_base.d++ = double_tmp;\n-\t      double_tmp = (*p_argv.d)[1];\n-\t      *fpr_base.d++ = double_tmp;\n-\t    }\n+\t      double_tmp = (*p_argv.d)[0];\n \n-\t  fparg_count += 2;\n-\t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n+\t      if (fparg_count >= NUM_FPR_ARG_REGISTERS - 1)\n+\t\t{\n+\t\t  if (intarg_count >= NUM_GPR_ARG_REGISTERS\n+\t\t      && intarg_count % 2 != 0)\n+\t\t    {\n+\t\t      intarg_count++;\n+\t\t      next_arg.u++;\n+\t\t    }\n+\t\t  *next_arg.d = double_tmp;\n+\t\t  next_arg.u += 2;\n+\t\t  double_tmp = (*p_argv.d)[1];\n+\t\t  *next_arg.d = double_tmp;\n+\t\t  next_arg.u += 2;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  *fpr_base.d++ = double_tmp;\n+\t\t  double_tmp = (*p_argv.d)[1];\n+\t\t  *fpr_base.d++ = double_tmp;\n+\t\t}\n+\n+\t      fparg_count += 2;\n+\t      FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n+\t    }\n \t  break;\n #endif\n \n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n+\tsoft_double_prep:\n \t  if (intarg_count == NUM_GPR_ARG_REGISTERS-1)\n \t    intarg_count++;\n \t  if (intarg_count >= NUM_GPR_ARG_REGISTERS)\n@@ -293,6 +342,8 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n \tcase FFI_TYPE_UINT32:\n \tcase FFI_TYPE_SINT32:\n \tcase FFI_TYPE_POINTER:\n+\tsoft_float_prep:\n+\n \t  gprvalue = **p_argv.ui;\n \n \tputgpr:\n@@ -546,6 +597,9 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n   unsigned type = cif->rtype->type;\n   unsigned size = cif->rtype->size;\n \n+  if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n+    NUM_FPR_ARG_REGISTERS = 0;\n+\n   if (cif->abi != FFI_LINUX64)\n     {\n       /* All the machine-independent calculation of cif->bytes will be wrong.\n@@ -582,22 +636,26 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n      For LINUX64:\n      - integer values in gpr3;\n      - Structures/Unions by reference;\n-     - Single/double FP values in fpr1, long double in fpr1,fpr2.  */\n+     - Single/double FP values in fpr1, long double in fpr1,fpr2.\n+     - soft-float float/doubles are treated as UINT32/UINT64 respectivley.\n+     - soft-float long doubles are returned in gpr3-gpr6.  */\n   switch (type)\n     {\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n     case FFI_TYPE_LONGDOUBLE:\n-      if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX64)\n+      if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX64\n+\t&& cif->abi != FFI_LINUX_SOFT_FLOAT)\n \tgoto byref;\n-\n       flags |= FLAG_RETURNS_128BITS;\n       /* Fall through.  */\n #endif\n     case FFI_TYPE_DOUBLE:\n       flags |= FLAG_RETURNS_64BITS;\n       /* Fall through.  */\n     case FFI_TYPE_FLOAT:\n-      flags |= FLAG_RETURNS_FP;\n+      /* With FFI_LINUX_SOFT_FLOAT no fp registers are used.  */\n+      if (cif->abi != FFI_LINUX_SOFT_FLOAT)\n+\tflags |= FLAG_RETURNS_FP;\n       break;\n \n     case FFI_TYPE_UINT64:\n@@ -660,18 +718,36 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \tswitch ((*ptr)->type)\n \t  {\n \t  case FFI_TYPE_FLOAT:\n+\t    /* With FFI_LINUX_SOFT_FLOAT floats are handled like UINT32.  */\n+\t    if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n+\t      goto soft_float_cif;\n \t    fparg_count++;\n \t    /* floating singles are not 8-aligned on stack */\n \t    break;\n \n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \t  case FFI_TYPE_LONGDOUBLE:\n-\t    if (cif->abi != FFI_LINUX)\n+\t    if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX_SOFT_FLOAT)\n \t      goto do_struct;\n-\t    fparg_count++;\n+\t    if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n+\t      {\n+\t\tif (intarg_count >= NUM_GPR_ARG_REGISTERS - 3\n+\t\t  || intarg_count < NUM_GPR_ARG_REGISTERS)\n+\t\t  /* A long double in FFI_LINUX_SOFT_FLOAT can use only\n+\t\t     a set of four consecutive gprs. If we have not enough,\n+\t\t     we have to adjust the intarg_count value.  */\n+\t\t  intarg_count += NUM_GPR_ARG_REGISTERS - intarg_count;\n+\t\tintarg_count += 4;\n+\t\tbreak;\n+\t      }\n+\t    else\n+\t      fparg_count++;\n \t    /* Fall thru */\n #endif\n \t  case FFI_TYPE_DOUBLE:\n+\t    /* With FFI_LINUX_SOFT_FLOAT doubles are handled like UINT64.  */\n+\t    if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n+\t      goto soft_double_cif;\n \t    fparg_count++;\n \t    /* If this FP arg is going on the stack, it must be\n \t       8-byte-aligned.  */\n@@ -683,6 +759,7 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \n \t  case FFI_TYPE_UINT64:\n \t  case FFI_TYPE_SINT64:\n+\t  soft_double_cif:\n \t    /* 'long long' arguments are passed as two words, but\n \t       either both words must fit in registers or both go\n \t       on the stack.  If they go on the stack, they must\n@@ -710,6 +787,7 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \t    /* Fall through (allocate space for the pointer).  */\n \n \t  default:\n+\t  soft_float_cif:\n \t    /* Everything else is passed as a 4-byte word in a GPR, either\n \t       the object itself or a pointer to it.  */\n \t    intarg_count++;\n@@ -723,8 +801,13 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \t  {\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \t  case FFI_TYPE_LONGDOUBLE:\n-\t    fparg_count += 2;\n-\t    intarg_count += 2;\n+\t    if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n+\t      intarg_count += 4;\n+\t    else\n+\t      {\n+\t\tfparg_count += 2;\n+\t\tintarg_count += 2;\n+\t      }\n \t    break;\n #endif\n \t  case FFI_TYPE_FLOAT:\n@@ -818,6 +901,7 @@ ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n     case FFI_SYSV:\n     case FFI_GCC_SYSV:\n     case FFI_LINUX:\n+    case FFI_LINUX_SOFT_FLOAT:\n       ffi_call_SYSV (&ecif, -cif->bytes, cif->flags, ecif.rvalue, fn);\n       break;\n #else\n@@ -942,7 +1026,7 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n        && !((cif->abi == FFI_SYSV) && (size <= 8)))\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n       || (cif->rtype->type == FFI_TYPE_LONGDOUBLE\n-\t  && cif->abi != FFI_LINUX)\n+\t  && cif->abi != FFI_LINUX && cif->abi != FFI_LINUX_SOFT_FLOAT)\n #endif\n       )\n     {\n@@ -995,6 +1079,7 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n \tcase FFI_TYPE_SINT32:\n \tcase FFI_TYPE_UINT32:\n \tcase FFI_TYPE_POINTER:\n+\tsoft_float_closure:\n \t  /* there are 8 gpr registers used to pass values */\n \t  if (ng < 8)\n \t    {\n@@ -1030,6 +1115,7 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n \n \tcase FFI_TYPE_SINT64:\n \tcase FFI_TYPE_UINT64:\n+\tsoft_double_closure:\n \t  /* passing long long ints are complex, they must\n \t   * be passed in suitable register pairs such as\n \t   * (r3,r4) or (r5,r6) or (r6,r7), or (r7,r8) or (r9,r10)\n@@ -1061,6 +1147,9 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n \t  break;\n \n \tcase FFI_TYPE_FLOAT:\n+\t  /* With FFI_LINUX_SOFT_FLOAT floats are handled like UINT32.  */\n+\t  if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n+\t    goto soft_float_closure;\n \t  /* unfortunately float values are stored as doubles\n \t   * in the ffi_closure_SYSV code (since we don't check\n \t   * the type in that routine).\n@@ -1089,6 +1178,9 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n \t  break;\n \n \tcase FFI_TYPE_DOUBLE:\n+\t  /* With FFI_LINUX_SOFT_FLOAT doubles are handled like UINT64.  */\n+\t  if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n+\t    goto soft_double_closure;\n \t  /* On the outgoing stack all values are aligned to 8 */\n \t  /* there are 8 64bit floating point registers */\n \n@@ -1109,9 +1201,24 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n \n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \tcase FFI_TYPE_LONGDOUBLE:\n-\t  if (cif->abi != FFI_LINUX)\n+\t  if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX_SOFT_FLOAT)\n \t    goto do_struct;\n-\n+\t  if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n+\t    { /* Test if for the whole long double, 4 gprs are available.\n+\t\t otherwise the stuff ends up on the stack.  */\n+\t      if (ng < 5)\n+\t\t{\n+\t\t  avalue[i] = pgr;\n+\t\t  pgr += 4;\n+\t\t  ng += 4;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  avalue[i] = pst;\n+\t\t  pst += 4;\n+\t\t}\n+\t      break;\n+\t    }\n \t  if (nf < 7)\n \t    {\n \t      avalue[i] = pfr;\n@@ -1147,10 +1254,34 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n     return FFI_SYSV_TYPE_SMALL_STRUCT + size;\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n   else if (cif->rtype->type == FFI_TYPE_LONGDOUBLE\n-\t   && cif->abi != FFI_LINUX)\n+\t   && cif->abi != FFI_LINUX && cif->abi != FFI_LINUX_SOFT_FLOAT)\n     return FFI_TYPE_STRUCT;\n #endif\n-  return cif->rtype->type;\n+  /* With FFI_LINUX_SOFT_FLOAT floats and doubles are handled like UINT32\n+     respectivley UINT64.  */\n+  if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n+    {\n+      switch (cif->rtype->type)\n+\t{\n+\tcase FFI_TYPE_FLOAT:\n+\t  return FFI_TYPE_UINT32;\n+\t  break;\n+\tcase FFI_TYPE_DOUBLE:\n+\t  return FFI_TYPE_UINT64;\n+\t  break;\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  return FFI_TYPE_UINT128;\n+\t  break;\n+#endif\n+\tdefault:\n+\t  return cif->rtype->type;\n+\t}\n+    }\n+  else\n+    {\n+      return cif->rtype->type;\n+    }\n }\n \n int FFI_HIDDEN ffi_closure_helper_LINUX64 (ffi_closure *, void *,"}, {"sha": "e3fa30be6b553e61140a404b0a9f0eede5636d25", "filename": "libffi/src/powerpc/ffitarget.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162871481ad35e10abf02b053a2c31d3bcf0ea7c/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162871481ad35e10abf02b053a2c31d3bcf0ea7c/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h?ref=162871481ad35e10abf02b053a2c31d3bcf0ea7c", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------*-C-*-\n    ffitarget.h - Copyright (c) 1996-2003  Red Hat, Inc.\n+   Copyright (C) 2007 Free Software Foundation, Inc\n    Target configuration macros for PowerPC.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -44,13 +45,18 @@ typedef enum ffi_abi {\n   FFI_GCC_SYSV,\n   FFI_LINUX64,\n   FFI_LINUX,\n+  FFI_LINUX_SOFT_FLOAT,\n # ifdef POWERPC64\n   FFI_DEFAULT_ABI = FFI_LINUX64,\n # else\n-#  if __LDBL_MANT_DIG__ == 106\n+#  if (!defined(__NO_FPRS__) && (__LDBL_MANT_DIG__ == 106))\n   FFI_DEFAULT_ABI = FFI_LINUX,\n #  else\n+#   ifdef __NO_FPRS__\n+  FFI_DEFAULT_ABI = FFI_LINUX_SOFT_FLOAT,\n+#   else\n   FFI_DEFAULT_ABI = FFI_GCC_SYSV,\n+#   endif\n #  endif\n # endif\n #endif\n@@ -83,8 +89,14 @@ typedef enum ffi_abi {\n #define FFI_CLOSURES 1\n #define FFI_NATIVE_RAW_API 0\n \n+/* For additional types like the below, take care about the order in\n+   ppc_closures.S. They must follow after the FFI_TYPE_LAST.  */\n+\n+/* Needed for soft-float long-double-128 support.  */\n+#define FFI_TYPE_UINT128 (FFI_TYPE_LAST + 1)\n+\n /* Needed for FFI_SYSV small structure returns.  */\n-#define FFI_SYSV_TYPE_SMALL_STRUCT  (FFI_TYPE_LAST)\n+#define FFI_SYSV_TYPE_SMALL_STRUCT (FFI_TYPE_LAST + 2)\n \n #if defined(POWERPC64) || defined(POWERPC_AIX)\n #define FFI_TRAMPOLINE_SIZE 24"}, {"sha": "c9f5742f5aa33fe72124b71c277839f9e718cdaf", "filename": "libffi/src/powerpc/ppc_closure.S", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162871481ad35e10abf02b053a2c31d3bcf0ea7c/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162871481ad35e10abf02b053a2c31d3bcf0ea7c/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fppc_closure.S?ref=162871481ad35e10abf02b053a2c31d3bcf0ea7c", "patch": "@@ -28,6 +28,7 @@ ENTRY(ffi_closure_SYSV)\n \tstw   %r9, 40(%r1)\n \tstw   %r10,44(%r1)\n \n+#ifndef __NO_FPRS__\n \t# next save fpr 1 to fpr 8 (aligned to 8)\n \tstfd  %f1, 48(%r1)\n \tstfd  %f2, 56(%r1)\n@@ -37,6 +38,7 @@ ENTRY(ffi_closure_SYSV)\n \tstfd  %f6, 88(%r1)\n \tstfd  %f7, 96(%r1)\n \tstfd  %f8, 104(%r1)\n+#endif\n \n \t# set up registers for the routine that actually does the work\n \t# get the context pointer from the trampoline\n@@ -171,6 +173,12 @@ ENTRY(ffi_closure_SYSV)\n \taddi %r1,%r1,144\n \tblr\n \n+# case FFI_TYPE_UINT128\n+\tlwz %r3,112+0(%r1)\n+\tlwz %r4,112+4(%r1)\n+\tlwz %r5,112+8(%r1)\n+\tbl .Luint128\n+\n # The return types below are only used when the ABI type is FFI_SYSV.\n # case FFI_SYSV_TYPE_SMALL_STRUCT + 1. One byte struct.\n \tlbz %r3,112+0(%r1)\n@@ -230,6 +238,12 @@ ENTRY(ffi_closure_SYSV)\n \taddi %r1,%r1,144\n \tblr\n \n+.Luint128:\n+\tlwz %r6,112+12(%r1)\n+\tmtlr %r0\n+\taddi %r1,%r1,144\n+\tblr\n+\n END(ffi_closure_SYSV)\n \n \t.section\t\".eh_frame\",EH_FRAME_FLAGS,@progbits"}, {"sha": "21367145eb954d0faa3bff86b6aafd3f1cdd392b", "filename": "libffi/src/powerpc/sysv.S", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/162871481ad35e10abf02b053a2c31d3bcf0ea7c/libffi%2Fsrc%2Fpowerpc%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/162871481ad35e10abf02b053a2c31d3bcf0ea7c/libffi%2Fsrc%2Fpowerpc%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fsysv.S?ref=162871481ad35e10abf02b053a2c31d3bcf0ea7c", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------------\n-   sysv.h - Copyright (c) 1998 Geoffrey Keating\n+   sysv.S - Copyright (c) 1998 Geoffrey Keating\n+   Copyright (C) 2007 Free Software Foundation, Inc\n \n    PowerPC Assembly glue.\n \n@@ -98,13 +99,17 @@ ENTRY(ffi_call_SYSV)\n \tbctrl\n \n \t/* Now, deal with the return value.  */\n-\tmtcrf\t0x01,%r31\n+\tmtcrf\t0x01,%r31 /* cr7  */\n \tbt-\t31,L(small_struct_return_value)\n \tbt-\t30,L(done_return_value)\n \tbt-\t29,L(fp_return_value)\n \tstw\t%r3,0(%r30)\n \tbf+\t28,L(done_return_value)\n \tstw\t%r4,4(%r30)\n+\tmtcrf\t0x02,%r31 /* cr6  */\n+\tbf\t27,L(done_return_value)\n+\tstw     %r5,8(%r30)\n+\tstw\t%r6,12(%r30)\n \t/* Fall through...  */\n \n L(done_return_value):"}]}