{"sha": "d394a308e34df7dfe56e1b3995a2622e1ed19068", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM5NGEzMDhlMzRkZjdkZmU1NmUxYjM5OTVhMjYyMmUxZWQxOTA2OA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-01-30T10:46:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-01-30T10:46:00Z"}, "message": "tree-ssa-structalias.c (final_solutions, [...]): New pointer-map and obstack.\n\n2013-01-30  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-structalias.c (final_solutions, final_solutions_obstack):\n\tNew pointer-map and obstack.\n\t(init_alias_vars): Allocate pointer-map and obstack.\n\t(delete_points_to_sets): Free them.\n\t(find_what_var_points_to): Cache result.\n\t(find_what_p_points_to): Adjust for changed interface of\n\tfind_what_var_points_to.\n\t(compute_points_to_sets): Likewise.\n\t(ipa_pta_execute): Likewise.\n\nFrom-SVN: r195573", "tree": {"sha": "855b2af9545ee00c622559f72c0f1dc10e92cf73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/855b2af9545ee00c622559f72c0f1dc10e92cf73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d394a308e34df7dfe56e1b3995a2622e1ed19068", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d394a308e34df7dfe56e1b3995a2622e1ed19068", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d394a308e34df7dfe56e1b3995a2622e1ed19068", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d394a308e34df7dfe56e1b3995a2622e1ed19068/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "20804d96d131529e7f7f300458e02b7f1ed30d6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20804d96d131529e7f7f300458e02b7f1ed30d6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20804d96d131529e7f7f300458e02b7f1ed30d6c"}], "stats": {"total": 71, "additions": 50, "deletions": 21}, "files": [{"sha": "dbce3eb71d78784e6ef450437565d929d0a0e7c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d394a308e34df7dfe56e1b3995a2622e1ed19068/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d394a308e34df7dfe56e1b3995a2622e1ed19068/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d394a308e34df7dfe56e1b3995a2622e1ed19068", "patch": "@@ -1,3 +1,15 @@\n+2013-01-30  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-structalias.c (final_solutions, final_solutions_obstack):\n+\tNew pointer-map and obstack.\n+\t(init_alias_vars): Allocate pointer-map and obstack.\n+\t(delete_points_to_sets): Free them.\n+\t(find_what_var_points_to): Cache result.\n+\t(find_what_p_points_to): Adjust for changed interface of\n+\tfind_what_var_points_to.\n+\t(compute_points_to_sets): Likewise.\n+\t(ipa_pta_execute): Likewise.\n+\n 2013-01-30  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* configure.ac (HAVE_AS_SPARC_NOBITS): New test."}, {"sha": "1bbe1cc5ae087c2704a13199ba7d851d5c896c33", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 38, "deletions": 21, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d394a308e34df7dfe56e1b3995a2622e1ed19068/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d394a308e34df7dfe56e1b3995a2622e1ed19068/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=d394a308e34df7dfe56e1b3995a2622e1ed19068", "patch": "@@ -303,7 +303,9 @@ static inline bool type_can_have_subvars (const_tree);\n /* Pool of variable info structures.  */\n static alloc_pool variable_info_pool;\n \n-\n+/* Map varinfo to final pt_solution.  */\n+static pointer_map_t *final_solutions;\n+struct obstack final_solutions_obstack;\n \n /* Table of variable info structures for constraint variables.\n    Indexed directly by variable info id.  */\n@@ -5872,21 +5874,29 @@ set_uids_in_ptset (bitmap into, bitmap from, struct pt_solution *pt)\n \n /* Compute the points-to solution *PT for the variable VI.  */\n \n-static void\n-find_what_var_points_to (varinfo_t orig_vi, struct pt_solution *pt)\n+static struct pt_solution\n+find_what_var_points_to (varinfo_t orig_vi)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n   bitmap finished_solution;\n   bitmap result;\n   varinfo_t vi;\n-\n-  memset (pt, 0, sizeof (struct pt_solution));\n+  void **slot;\n+  struct pt_solution *pt;\n \n   /* This variable may have been collapsed, let's get the real\n      variable.  */\n   vi = get_varinfo (find (orig_vi->id));\n \n+  /* See if we have already computed the solution and return it.  */\n+  slot = pointer_map_insert (final_solutions, vi);\n+  if (*slot != NULL)\n+    return *(struct pt_solution *)*slot;\n+\n+  *slot = pt = XOBNEW (&final_solutions_obstack, struct pt_solution);\n+  memset (pt, 0, sizeof (struct pt_solution));\n+\n   /* Translate artificial variables into SSA_NAME_PTR_INFO\n      attributes.  */\n   EXECUTE_IF_SET_IN_BITMAP (vi->solution, 0, i, bi)\n@@ -5921,7 +5931,7 @@ find_what_var_points_to (varinfo_t orig_vi, struct pt_solution *pt)\n   /* Instead of doing extra work, simply do not create\n      elaborate points-to information for pt_anything pointers.  */\n   if (pt->anything)\n-    return;\n+    return *pt;\n \n   /* Share the final set of variables when possible.  */\n   finished_solution = BITMAP_GGC_ALLOC ();\n@@ -5939,6 +5949,8 @@ find_what_var_points_to (varinfo_t orig_vi, struct pt_solution *pt)\n       pt->vars = result;\n       bitmap_clear (finished_solution);\n     }\n+\n+  return *pt;\n }\n \n /* Given a pointer variable P, fill in its points-to set.  */\n@@ -5963,7 +5975,7 @@ find_what_p_points_to (tree p)\n     return;\n \n   pi = get_ptr_info (p);\n-  find_what_var_points_to (vi, &pi->pt);\n+  pi->pt = find_what_var_points_to (vi);\n }\n \n \n@@ -6480,6 +6492,9 @@ init_alias_vars (void)\n   init_base_vars ();\n \n   gcc_obstack_init (&fake_var_decl_obstack);\n+\n+  final_solutions = pointer_map_create ();\n+  gcc_obstack_init (&final_solutions_obstack);\n }\n \n /* Remove the REF and ADDRESS edges from GRAPH, as well as all the\n@@ -6638,8 +6653,7 @@ compute_points_to_sets (void)\n   solve_constraints ();\n \n   /* Compute the points-to set for ESCAPED used for call-clobber analysis.  */\n-  find_what_var_points_to (get_varinfo (escaped_id),\n-\t\t\t   &cfun->gimple_df->escaped);\n+  cfun->gimple_df->escaped = find_what_var_points_to (get_varinfo (escaped_id));\n \n   /* Make sure the ESCAPED solution (which is used as placeholder in\n      other solutions) does not reference itself.  This simplifies\n@@ -6679,7 +6693,7 @@ compute_points_to_sets (void)\n \t    memset (pt, 0, sizeof (struct pt_solution));\n \t  else if ((vi = lookup_call_use_vi (stmt)) != NULL)\n \t    {\n-\t      find_what_var_points_to (vi, pt);\n+\t      *pt = find_what_var_points_to (vi);\n \t      /* Escaped (and thus nonlocal) variables are always\n \t         implicitly used by calls.  */\n \t      /* ???  ESCAPED can be empty even though NONLOCAL\n@@ -6700,7 +6714,7 @@ compute_points_to_sets (void)\n \t    memset (pt, 0, sizeof (struct pt_solution));\n \t  else if ((vi = lookup_call_clobber_vi (stmt)) != NULL)\n \t    {\n-\t      find_what_var_points_to (vi, pt);\n+\t      *pt = find_what_var_points_to (vi);\n \t      /* Escaped (and thus nonlocal) variables are always\n \t         implicitly clobbered by calls.  */\n \t      /* ???  ESCAPED can be empty even though NONLOCAL\n@@ -6755,6 +6769,9 @@ delete_points_to_sets (void)\n   free_alloc_pool (constraint_pool);\n \n   obstack_free (&fake_var_decl_obstack, NULL);\n+\n+  pointer_map_destroy (final_solutions);\n+  obstack_free (&final_solutions_obstack, NULL);\n }\n \n \n@@ -7023,7 +7040,7 @@ ipa_pta_execute (void)\n      ???  Note that the computed escape set is not correct\n      for the whole unit as we fail to consider graph edges to\n      externally visible functions.  */\n-  find_what_var_points_to (get_varinfo (escaped_id), &ipa_escaped_pt);\n+  ipa_escaped_pt = find_what_var_points_to (get_varinfo (escaped_id));\n \n   /* Make sure the ESCAPED solution (which is used as placeholder in\n      other solutions) does not reference itself.  This simplifies\n@@ -7058,9 +7075,9 @@ ipa_pta_execute (void)\n       /* Compute the call-use and call-clobber sets for all direct calls.  */\n       fi = lookup_vi_for_tree (node->symbol.decl);\n       gcc_assert (fi->is_fn_info);\n-      find_what_var_points_to (first_vi_for_offset (fi, fi_clobbers),\n-\t\t\t       &clobbers);\n-      find_what_var_points_to (first_vi_for_offset (fi, fi_uses), &uses);\n+      clobbers\n+\t= find_what_var_points_to (first_vi_for_offset (fi, fi_clobbers));\n+      uses = find_what_var_points_to (first_vi_for_offset (fi, fi_uses));\n       for (e = node->callers; e; e = e->next_caller)\n \t{\n \t  if (!e->call_stmt)\n@@ -7097,7 +7114,7 @@ ipa_pta_execute (void)\n \t\t    memset (pt, 0, sizeof (struct pt_solution));\n \t\t  else if ((vi = lookup_call_use_vi (stmt)) != NULL)\n \t\t    {\n-\t\t      find_what_var_points_to (vi, pt);\n+\t\t      *pt = find_what_var_points_to (vi);\n \t\t      /* Escaped (and thus nonlocal) variables are always\n \t\t\t implicitly used by calls.  */\n \t\t      /* ???  ESCAPED can be empty even though NONLOCAL\n@@ -7118,7 +7135,7 @@ ipa_pta_execute (void)\n \t\t    memset (pt, 0, sizeof (struct pt_solution));\n \t\t  else if ((vi = lookup_call_clobber_vi (stmt)) != NULL)\n \t\t    {\n-\t\t      find_what_var_points_to (vi, pt);\n+\t\t      *pt = find_what_var_points_to (vi);\n \t\t      /* Escaped (and thus nonlocal) variables are always\n \t\t\t implicitly clobbered by calls.  */\n \t\t      /* ???  ESCAPED can be empty even though NONLOCAL\n@@ -7178,14 +7195,14 @@ ipa_pta_execute (void)\n \n \t\t\t  if (!uses->anything)\n \t\t\t    {\n-\t\t\t      find_what_var_points_to\n-\t\t\t\t  (first_vi_for_offset (vi, fi_uses), &sol);\n+\t\t\t      sol = find_what_var_points_to\n+\t\t\t\t      (first_vi_for_offset (vi, fi_uses));\n \t\t\t      pt_solution_ior_into (uses, &sol);\n \t\t\t    }\n \t\t\t  if (!clobbers->anything)\n \t\t\t    {\n-\t\t\t      find_what_var_points_to\n-\t\t\t\t  (first_vi_for_offset (vi, fi_clobbers), &sol);\n+\t\t\t      sol = find_what_var_points_to\n+\t\t\t\t      (first_vi_for_offset (vi, fi_clobbers));\n \t\t\t      pt_solution_ior_into (clobbers, &sol);\n \t\t\t    }\n \t\t\t}"}]}