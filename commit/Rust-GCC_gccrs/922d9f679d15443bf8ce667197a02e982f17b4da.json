{"sha": "922d9f679d15443bf8ce667197a02e982f17b4da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIyZDlmNjc5ZDE1NDQzYmY4Y2U2NjcxOTdhMDJlOTgyZjE3YjRkYQ==", "commit": {"author": {"name": "Sameera Deshpande", "email": "sameera.deshpande@arm.com", "date": "2012-10-22T09:50:47Z"}, "committer": {"name": "Greta Yorsh", "email": "gretay@gcc.gnu.org", "date": "2012-10-22T09:50:47Z"}, "message": "arm.c (thumb2_emit_strd_push): New function.\n\n2012-10-22  Sameera Deshpande  <sameera.deshpande@arm.com>\n\t    Greta Yorsh  <Greta.Yorsh@arm.com>\n\n\t* config/arm/arm.c (thumb2_emit_strd_push): New function.\n       (arm_expand_prologue): Use the new function.\n\n\nCo-Authored-By: Greta Yorsh <greta.yorsh@arm.com>\n\nFrom-SVN: r192679", "tree": {"sha": "5b1f04e0cc8efeef36135a9b5180f8a67f70a323", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b1f04e0cc8efeef36135a9b5180f8a67f70a323"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/922d9f679d15443bf8ce667197a02e982f17b4da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/922d9f679d15443bf8ce667197a02e982f17b4da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/922d9f679d15443bf8ce667197a02e982f17b4da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/922d9f679d15443bf8ce667197a02e982f17b4da/comments", "author": null, "committer": null, "parents": [{"sha": "56289ed2fbb326eebbfa582b725664d63e856aee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56289ed2fbb326eebbfa582b725664d63e856aee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56289ed2fbb326eebbfa582b725664d63e856aee"}], "stats": {"total": 147, "additions": 145, "deletions": 2}, "files": [{"sha": "d3817ddbcdbb2ef526f6b2cddff314a6cdcf352f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/922d9f679d15443bf8ce667197a02e982f17b4da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/922d9f679d15443bf8ce667197a02e982f17b4da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=922d9f679d15443bf8ce667197a02e982f17b4da", "patch": "@@ -1,3 +1,9 @@\n+2012-10-22  Sameera Deshpande  <sameera.deshpande@arm.com>\n+\t    Greta Yorsh  <Greta.Yorsh@arm.com>\n+\n+\t* config/arm/arm.c (thumb2_emit_strd_push): New function.\n+       (arm_expand_prologue): Use the new function.\n+\n 2012-10-22  Sameera Deshpande  <sameera.deshpande@arm.com>\n \t    Greta Yorsh  <Greta.Yorsh@arm.com>\n "}, {"sha": "c67a2a347e38787e761a503fc2a7856428adecd2", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 139, "deletions": 2, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/922d9f679d15443bf8ce667197a02e982f17b4da/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/922d9f679d15443bf8ce667197a02e982f17b4da/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=922d9f679d15443bf8ce667197a02e982f17b4da", "patch": "@@ -15852,6 +15852,126 @@ arm_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n     }\n }\n \n+/* Generate and emit a pattern that will be recognized as STRD pattern.  If even\n+   number of registers are being pushed, multiple STRD patterns are created for\n+   all register pairs.  If odd number of registers are pushed, emit a\n+   combination of STRDs and STR for the prologue saves.  */\n+static void\n+thumb2_emit_strd_push (unsigned long saved_regs_mask)\n+{\n+  int num_regs = 0;\n+  int i, j;\n+  rtx par = NULL_RTX;\n+  rtx insn = NULL_RTX;\n+  rtx dwarf = NULL_RTX;\n+  rtx tmp, reg, tmp1;\n+\n+  for (i = 0; i <= LAST_ARM_REGNUM; i++)\n+    if (saved_regs_mask & (1 << i))\n+      num_regs++;\n+\n+  gcc_assert (num_regs && num_regs <= 16);\n+\n+  /* Pre-decrement the stack pointer, based on there being num_regs 4-byte\n+     registers to push.  */\n+  tmp = gen_rtx_SET (VOIDmode,\n+                     stack_pointer_rtx,\n+                     plus_constant (Pmode, stack_pointer_rtx, -4 * num_regs));\n+  RTX_FRAME_RELATED_P (tmp) = 1;\n+  insn = emit_insn (tmp);\n+\n+  /* Create sequence for DWARF info.  */\n+  dwarf = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (num_regs + 1));\n+\n+  /* RTLs cannot be shared, hence create new copy for dwarf.  */\n+  tmp1 = gen_rtx_SET (VOIDmode,\n+                     stack_pointer_rtx,\n+                     plus_constant (Pmode, stack_pointer_rtx, -4 * num_regs));\n+  RTX_FRAME_RELATED_P (tmp1) = 1;\n+  XVECEXP (dwarf, 0, 0) = tmp1;\n+\n+  gcc_assert (!(saved_regs_mask & (1 << SP_REGNUM)));\n+  gcc_assert (!(saved_regs_mask & (1 << PC_REGNUM)));\n+\n+  /* Var j iterates over all the registers to gather all the registers in\n+     saved_regs_mask.  Var i gives index of register R_j in stack frame.\n+     A PARALLEL RTX of register-pair is created here, so that pattern for\n+     STRD can be matched.  If num_regs is odd, 1st register will be pushed\n+     using STR and remaining registers will be pushed with STRD in pairs.\n+     If num_regs is even, all registers are pushed with STRD in pairs.\n+     Hence, skip first element for odd num_regs.  */\n+  for (i = num_regs - 1, j = LAST_ARM_REGNUM; i >= (num_regs % 2); j--)\n+    if (saved_regs_mask & (1 << j))\n+      {\n+        /* Create RTX for store.  New RTX is created for dwarf as\n+           they are not sharable.  */\n+        reg = gen_rtx_REG (SImode, j);\n+        tmp = gen_rtx_SET (SImode,\n+                           gen_frame_mem\n+                           (SImode,\n+                            plus_constant (Pmode, stack_pointer_rtx, 4 * i)),\n+                           reg);\n+\n+        tmp1 = gen_rtx_SET (SImode,\n+                           gen_frame_mem\n+                           (SImode,\n+                            plus_constant (Pmode, stack_pointer_rtx, 4 * i)),\n+                           reg);\n+        RTX_FRAME_RELATED_P (tmp) = 1;\n+        RTX_FRAME_RELATED_P (tmp1) = 1;\n+\n+        if (((i - (num_regs % 2)) % 2) == 1)\n+          /* When (i - (num_regs % 2)) is odd, the RTX to be emitted is yet to\n+             be created.  Hence create it first.  The STRD pattern we are\n+             generating is :\n+             [ (SET (MEM (PLUS (SP) (NUM))) (reg_t1))\n+               (SET (MEM (PLUS (SP) (NUM + 4))) (reg_t2)) ]\n+             where the target registers need not be consecutive.  */\n+          par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));\n+\n+        /* Register R_j is added in PARALLEL RTX.  If (i - (num_regs % 2)) is\n+           even, the reg_j is added as 0th element and if it is odd, reg_i is\n+           added as 1st element of STRD pattern shown above.  */\n+        XVECEXP (par, 0, ((i - (num_regs % 2)) % 2)) = tmp;\n+        XVECEXP (dwarf, 0, (i + 1)) = tmp1;\n+\n+        if (((i - (num_regs % 2)) % 2) == 0)\n+          /* When (i - (num_regs % 2)) is even, RTXs for both the registers\n+             to be loaded are generated in above given STRD pattern, and the\n+             pattern can be emitted now.  */\n+          emit_insn (par);\n+\n+        i--;\n+      }\n+\n+  if ((num_regs % 2) == 1)\n+    {\n+      /* If odd number of registers are pushed, generate STR pattern to store\n+         lone register.  */\n+      for (; (saved_regs_mask & (1 << j)) == 0; j--);\n+\n+      tmp1 = gen_frame_mem (SImode, plus_constant (Pmode,\n+                                                   stack_pointer_rtx, 4 * i));\n+      reg = gen_rtx_REG (SImode, j);\n+      tmp = gen_rtx_SET (SImode, tmp1, reg);\n+      RTX_FRAME_RELATED_P (tmp) = 1;\n+\n+      emit_insn (tmp);\n+\n+      tmp1 = gen_rtx_SET (SImode,\n+                         gen_frame_mem\n+                         (SImode,\n+                          plus_constant (Pmode, stack_pointer_rtx, 4 * i)),\n+                          reg);\n+      RTX_FRAME_RELATED_P (tmp1) = 1;\n+      XVECEXP (dwarf, 0, (i + 1)) = tmp1;\n+    }\n+\n+  add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+  return;\n+}\n+\n /* Generate and emit an insn that we will recognize as a push_multi.\n    Unfortunately, since this insn does not reflect very well the actual\n    semantics of the operation, we need to annotate the insn for the benefit\n@@ -16780,8 +16900,25 @@ arm_expand_prologue (void)\n \t      saved_regs += frame;\n \t    }\n \t}\n-      insn = emit_multi_reg_push (live_regs_mask);\n-      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      if (current_tune->prefer_ldrd_strd\n+          && !optimize_function_for_size_p (cfun))\n+        {\n+          if (TARGET_THUMB2)\n+            {\n+              thumb2_emit_strd_push (live_regs_mask);\n+            }\n+          else\n+            {\n+              insn = emit_multi_reg_push (live_regs_mask);\n+              RTX_FRAME_RELATED_P (insn) = 1;\n+            }\n+        }\n+      else\n+        {\n+          insn = emit_multi_reg_push (live_regs_mask);\n+          RTX_FRAME_RELATED_P (insn) = 1;\n+        }\n     }\n \n   if (! IS_VOLATILE (func_type))"}]}