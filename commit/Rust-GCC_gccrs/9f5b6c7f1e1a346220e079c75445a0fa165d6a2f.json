{"sha": "9f5b6c7f1e1a346220e079c75445a0fa165d6a2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY1YjZjN2YxZTFhMzQ2MjIwZTA3OWM3NTQ0NWEwZmExNjVkNmEyZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-18T08:49:38Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-18T08:49:38Z"}, "message": "[multiple changes]\n\n2010-06-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch6.adb: Add extra guard.\n\n2010-06-18  Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_util.adb (Object_Access_Level): For Ada 2005, determine the\n\taccessibility level of a function call from the level of the innermost\n\tenclosing dynamic scope.\n\t(Innermost_Master_Scope_Depth): New function to find the depth of the\n\tnearest dynamic scope enclosing a node.\n\n2010-06-18  Tristan Gingold  <gingold@adacore.com>\n\n\t* adaint.c: Make ATTR_UNSET static as it is not used outside this file.\n\n2010-06-18  Thomas Quinot  <quinot@adacore.com>\n\n\t* g-socket.ads: Minor reformatting.\n\nFrom-SVN: r160964", "tree": {"sha": "ecea6f87cd606e3baa8307ea279fd944b7b1d3b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecea6f87cd606e3baa8307ea279fd944b7b1d3b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f5b6c7f1e1a346220e079c75445a0fa165d6a2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f5b6c7f1e1a346220e079c75445a0fa165d6a2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f5b6c7f1e1a346220e079c75445a0fa165d6a2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f5b6c7f1e1a346220e079c75445a0fa165d6a2f/comments", "author": null, "committer": null, "parents": [{"sha": "3e2399bafcb068ca3111b6fbc69cff38ed442bb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e2399bafcb068ca3111b6fbc69cff38ed442bb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e2399bafcb068ca3111b6fbc69cff38ed442bb8"}], "stats": {"total": 210, "additions": 166, "deletions": 44}, "files": [{"sha": "816b578c68ef8c8d0933d57e44d50ed87f88f757", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f5b6c7f1e1a346220e079c75445a0fa165d6a2f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f5b6c7f1e1a346220e079c75445a0fa165d6a2f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9f5b6c7f1e1a346220e079c75445a0fa165d6a2f", "patch": "@@ -1,3 +1,23 @@\n+2010-06-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch6.adb: Add extra guard.\n+\n+2010-06-18  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_util.adb (Object_Access_Level): For Ada 2005, determine the\n+\taccessibility level of a function call from the level of the innermost\n+\tenclosing dynamic scope.\n+\t(Innermost_Master_Scope_Depth): New function to find the depth of the\n+\tnearest dynamic scope enclosing a node.\n+\n+2010-06-18  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* adaint.c: Make ATTR_UNSET static as it is not used outside this file.\n+\n+2010-06-18  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* g-socket.ads: Minor reformatting.\n+\n 2010-06-18  Vincent Celier  <celier@adacore.com>\n \n \t* make.adb (Must_Compile): New Boolean global variable"}, {"sha": "5ceedd03543c45792f864ab2d93b5d0eb1d520fa", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f5b6c7f1e1a346220e079c75445a0fa165d6a2f/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f5b6c7f1e1a346220e079c75445a0fa165d6a2f/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=9f5b6c7f1e1a346220e079c75445a0fa165d6a2f", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2009, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2010, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -377,7 +377,7 @@ to_ptr32 (char **ptr64)\n #define MAYBE_TO_PTR32(argv) argv\n #endif\n \n-const char ATTR_UNSET = 127;\n+static const char ATTR_UNSET = 127;\n \n void\n __gnat_reset_attributes"}, {"sha": "08f7d7c89285cc8ce334e21b7d6b1161f18b8efa", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f5b6c7f1e1a346220e079c75445a0fa165d6a2f/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f5b6c7f1e1a346220e079c75445a0fa165d6a2f/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=9f5b6c7f1e1a346220e079c75445a0fa165d6a2f", "patch": "@@ -3396,6 +3396,7 @@ package body Exp_Ch6 is\n             return Skip;\n \n          elsif Is_Entity_Name (N)\n+           and then Present (Return_Object)\n            and then Chars (N) = Chars (Return_Object)\n          then\n             --  Occurrence within an extended return statement. The return"}, {"sha": "b7030c20fe30774e6b5dfcf85a8fcbaacb1421fa", "filename": "gcc/ada/g-socket.ads", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f5b6c7f1e1a346220e079c75445a0fa165d6a2f/gcc%2Fada%2Fg-socket.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f5b6c7f1e1a346220e079c75445a0fa165d6a2f/gcc%2Fada%2Fg-socket.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.ads?ref=9f5b6c7f1e1a346220e079c75445a0fa165d6a2f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2009, AdaCore                     --\n+--                     Copyright (C) 2001-2010, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -664,33 +664,33 @@ package GNAT.Sockets is\n    --  with a socket. Options may exist at multiple protocol levels in the\n    --  communication stack. Socket_Level is the uppermost socket level.\n \n-   type Level_Type is (\n-     Socket_Level,\n-     IP_Protocol_For_IP_Level,\n-     IP_Protocol_For_UDP_Level,\n-     IP_Protocol_For_TCP_Level);\n+   type Level_Type is\n+     (Socket_Level,\n+      IP_Protocol_For_IP_Level,\n+      IP_Protocol_For_UDP_Level,\n+      IP_Protocol_For_TCP_Level);\n \n    --  There are several options available to manipulate sockets. Each option\n    --  has a name and several values available. Most of the time, the value is\n    --  a boolean to enable or disable this option.\n \n-   type Option_Name is (\n-     Keep_Alive,          -- Enable sending of keep-alive messages\n-     Reuse_Address,       -- Allow bind to reuse local address\n-     Broadcast,           -- Enable datagram sockets to recv/send broadcasts\n-     Send_Buffer,         -- Set/get the maximum socket send buffer in bytes\n-     Receive_Buffer,      -- Set/get the maximum socket recv buffer in bytes\n-     Linger,              -- Shutdown wait for msg to be sent or timeout occur\n-     Error,               -- Get and clear the pending socket error\n-     No_Delay,            -- Do not delay send to coalesce data (TCP_NODELAY)\n-     Add_Membership,      -- Join a multicast group\n-     Drop_Membership,     -- Leave a multicast group\n-     Multicast_If,        -- Set default out interface for multicast packets\n-     Multicast_TTL,       -- Set the time-to-live of sent multicast packets\n-     Multicast_Loop,      -- Sent multicast packets are looped to local socket\n-     Receive_Packet_Info, -- Receive low level packet info as ancillary data\n-     Send_Timeout,        -- Set timeout value for output\n-     Receive_Timeout);    -- Set timeout value for input\n+   type Option_Name is\n+     (Keep_Alive,          -- Enable sending of keep-alive messages\n+      Reuse_Address,       -- Allow bind to reuse local address\n+      Broadcast,           -- Enable datagram sockets to recv/send broadcasts\n+      Send_Buffer,         -- Set/get the maximum socket send buffer in bytes\n+      Receive_Buffer,      -- Set/get the maximum socket recv buffer in bytes\n+      Linger,              -- Shutdown wait for msg to be sent or timeout occur\n+      Error,               -- Get and clear the pending socket error\n+      No_Delay,            -- Do not delay send to coalesce data (TCP_NODELAY)\n+      Add_Membership,      -- Join a multicast group\n+      Drop_Membership,     -- Leave a multicast group\n+      Multicast_If,        -- Set default out interface for multicast packets\n+      Multicast_TTL,       -- Set the time-to-live of sent multicast packets\n+      Multicast_Loop,      -- Sent multicast packets are looped to local socket\n+      Receive_Packet_Info, -- Receive low level packet info as ancillary data\n+      Send_Timeout,        -- Set timeout value for output\n+      Receive_Timeout);    -- Set timeout value for input\n \n    type Option_Type (Name : Option_Name := Keep_Alive) is record\n       case Name is\n@@ -740,8 +740,8 @@ package GNAT.Sockets is\n    --  socket options in that they are not specific to sockets but are\n    --  available for any device.\n \n-   type Request_Name is (\n-      Non_Blocking_IO,  --  Cause a caller not to wait on blocking operations.\n+   type Request_Name is\n+     (Non_Blocking_IO,  --  Cause a caller not to wait on blocking operations\n       N_Bytes_To_Read); --  Return the number of bytes available to read\n \n    type Request_Type (Name : Request_Name := Non_Blocking_IO) is record"}, {"sha": "fb193a565c0ba4cf6c7af8f77c7c2b9f5a01e11f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 118, "deletions": 17, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f5b6c7f1e1a346220e079c75445a0fa165d6a2f/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f5b6c7f1e1a346220e079c75445a0fa165d6a2f/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=9f5b6c7f1e1a346220e079c75445a0fa165d6a2f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -9299,7 +9299,8 @@ package body Sem_Util is\n                  or else Modification_Comes_From_Source\n                then\n                   if Has_Pragma_Unmodified (Ent) then\n-                     Error_Msg_NE (\"?pragma Unmodified given for &!\", N, Ent);\n+                     Error_Msg_NE -- CODEFIX???\n+                       (\"?pragma Unmodified given for &!\", N, Ent);\n                   end if;\n \n                   Set_Never_Set_In_Source (Ent, False);\n@@ -9354,7 +9355,7 @@ package body Sem_Util is\n                           and then Is_Entity_Name (Prefix (Exp))\n                         then\n                            Error_Msg_Sloc := Sloc (A);\n-                           Error_Msg_NE\n+                           Error_Msg_NE -- CODEFIX???\n                              (\"constant& may be modified via address clause#?\",\n                               N, Entity (Prefix (Exp)));\n                         end if;\n@@ -9493,15 +9494,112 @@ package body Sem_Util is\n       then\n          return Object_Access_Level (Expression (Obj));\n \n-      --  Function results are objects, so we get either the access level of\n-      --  the function or, in the case of an indirect call, the level of the\n-      --  access-to-subprogram type.\n-\n       elsif Nkind (Obj) = N_Function_Call then\n-         if Is_Entity_Name (Name (Obj)) then\n-            return Subprogram_Access_Level (Entity (Name (Obj)));\n+\n+         --  Function results are objects, so we get either the access level of\n+         --  the function or, in the case of an indirect call, the level of the\n+         --  access-to-subprogram type. (This code is used for Ada 95, but it\n+         --  looks wrong, because it seems that we should be checking the level\n+         --  of the call itself, even for Ada 95. However, using the Ada 2005\n+         --  version of the code causes regressions in several tests that are\n+         --  compiled with -gnat95. ???)\n+\n+         if Ada_Version < Ada_05 then\n+            if Is_Entity_Name (Name (Obj)) then\n+               return Subprogram_Access_Level (Entity (Name (Obj)));\n+            else\n+               return Type_Access_Level (Etype (Prefix (Name (Obj))));\n+            end if;\n+\n+         --  For Ada 2005, the level of the result object of a function call is\n+         --  defined to be the level of the call's innermost enclosing master.\n+         --  We determine that by querying the depth of the innermost enclosing\n+         --  dynamic scope.\n+\n          else\n-            return Type_Access_Level (Etype (Prefix (Name (Obj))));\n+            Return_Master_Scope_Depth_Of_Call : declare\n+\n+               function Innermost_Master_Scope_Depth\n+                 (N : Node_Id) return Uint;\n+               --  Returns the scope depth of the given node's innermost\n+               --  enclosing dynamic scope (effectively the accessibility\n+               --  level of the innermost enclosing master).\n+\n+               ----------------------------------\n+               -- Innermost_Master_Scope_Depth --\n+               ----------------------------------\n+\n+               function Innermost_Master_Scope_Depth\n+                 (N : Node_Id) return Uint\n+               is\n+                  Node_Par : Node_Id := Parent (N);\n+\n+               begin\n+                  --  Locate the nearest enclosing node (by traversing Parents)\n+                  --  that Defining_Entity can be applied to, and return the\n+                  --  depth of that entity's nearest enclosing dynamic scope.\n+\n+                  while Present (Node_Par) loop\n+                     case Nkind (Node_Par) is\n+                        when N_Component_Declaration           |\n+                             N_Entry_Declaration               |\n+                             N_Formal_Object_Declaration       |\n+                             N_Formal_Type_Declaration         |\n+                             N_Full_Type_Declaration           |\n+                             N_Incomplete_Type_Declaration     |\n+                             N_Loop_Parameter_Specification    |\n+                             N_Object_Declaration              |\n+                             N_Protected_Type_Declaration      |\n+                             N_Private_Extension_Declaration   |\n+                             N_Private_Type_Declaration        |\n+                             N_Subtype_Declaration             |\n+                             N_Function_Specification          |\n+                             N_Procedure_Specification         |\n+                             N_Task_Type_Declaration           |\n+                             N_Body_Stub                       |\n+                             N_Generic_Instantiation           |\n+                             N_Proper_Body                     |\n+                             N_Implicit_Label_Declaration      |\n+                             N_Package_Declaration             |\n+                             N_Single_Task_Declaration         |\n+                             N_Subprogram_Declaration          |\n+                             N_Generic_Declaration             |\n+                             N_Renaming_Declaration            |\n+                             N_Block_Statement                 |\n+                             N_Formal_Subprogram_Declaration   |\n+                             N_Abstract_Subprogram_Declaration |\n+                             N_Entry_Body                      |\n+                             N_Exception_Declaration           |\n+                             N_Formal_Package_Declaration      |\n+                             N_Number_Declaration              |\n+                             N_Package_Specification           |\n+                             N_Parameter_Specification         |\n+                             N_Single_Protected_Declaration    |\n+                             N_Subunit                         =>\n+\n+                           return Scope_Depth\n+                                    (Nearest_Dynamic_Scope\n+                                       (Defining_Entity (Node_Par)));\n+\n+                        when others =>\n+                           null;\n+                     end case;\n+\n+                     Node_Par := Parent (Node_Par);\n+                  end loop;\n+\n+                  pragma Assert (False);\n+\n+                  --  Should never reach the following return\n+\n+                  return Scope_Depth (Current_Scope) + 1;\n+               end Innermost_Master_Scope_Depth;\n+\n+            --  Start of processing for Return_Master_Scope_Depth_Of_Call\n+\n+            begin\n+               return Innermost_Master_Scope_Depth (Obj);\n+            end Return_Master_Scope_Depth_Of_Call;\n          end if;\n \n       --  For convenience we handle qualified expressions, even though\n@@ -11241,8 +11339,10 @@ package body Sem_Util is\n         and then Covers\n           (Designated_Type (Expec_Type), Designated_Type (Found_Type))\n       then\n-         Error_Msg_N (\"result must be general access type!\", Expr);\n-         Error_Msg_NE (\"add ALL to }!\", Expr, Expec_Type);\n+         Error_Msg_N -- CODEFIX\n+           (\"result must be general access type!\", Expr);\n+         Error_Msg_NE -- CODEFIX\n+           (\"add ALL to }!\", Expr, Expec_Type);\n \n       --  Another special check, if the expected type is an integer type,\n       --  but the expression is of type System.Address, and the parent is\n@@ -11262,7 +11362,7 @@ package body Sem_Util is\n          Error_Msg_N\n            (\"address arithmetic not predefined in package System\",\n             Parent (Expr));\n-         Error_Msg_N\n+         Error_Msg_N -- CODEFIX???\n            (\"\\possible missing with/use of System.Storage_Elements\",\n             Parent (Expr));\n          return;\n@@ -11289,7 +11389,8 @@ package body Sem_Util is\n             if From_With_Type (Found_Type) then\n                Error_Msg_NE (\"\\\\found incomplete}!\", Expr, Found_Type);\n                Error_Msg_Qual_Level := 99;\n-               Error_Msg_NE (\"\\\\missing `WITH &;\", Expr, Scope (Found_Type));\n+               Error_Msg_NE -- CODEFIX\n+                 (\"\\\\missing `WITH &;\", Expr, Scope (Found_Type));\n                Error_Msg_Qual_Level := 0;\n             else\n                Error_Msg_NE (\"found}!\", Expr, Found_Type);\n@@ -11350,7 +11451,7 @@ package body Sem_Util is\n               Ekind (Entity (Expr)) = E_Generic_Procedure)\n          then\n             if Ekind (Expec_Type) = E_Access_Subprogram_Type then\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"found procedure name, possibly missing Access attribute!\",\n                    Expr);\n             else\n@@ -11363,7 +11464,7 @@ package body Sem_Util is\n            and then Etype (Designated_Type (Expec_Type)) = Etype (Expr)\n            and then No (Parameter_Associations (Expr))\n          then\n-            Error_Msg_N\n+            Error_Msg_N -- CODEFIX???\n               (\"found function name, possibly missing Access attribute!\",\n                Expr);\n \n@@ -11377,7 +11478,7 @@ package body Sem_Util is\n             and then not In_Use (Expec_Type)\n             and then Has_Compatible_Type (Right_Opnd (Expr), Expec_Type)\n          then\n-            Error_Msg_N\n+            Error_Msg_N -- CODEFIX???\n               (\"operator of the type is not directly visible!\", Expr);\n \n          elsif Ekind (Found_Type) = E_Void"}]}