{"sha": "c6abdc366af68c28e3e8da236dfa7037be38971e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZhYmRjMzY2YWY2OGMyOGUzZThkYTIzNmRmYTcwMzdiZTM4OTcxZQ==", "commit": {"author": {"name": "Edward Smith-Rowland", "email": "3dw4rd@verizon.net", "date": "2014-07-13T13:36:57Z"}, "committer": {"name": "Edward Smith-Rowland", "email": "emsr@gcc.gnu.org", "date": "2014-07-13T13:36:57Z"}, "message": "PR C++/60209 - Declaration of user-defined literal operator cause error\n\ncp/\n\t\n2014-07-13  Edward Smith-Rowland  <3dw4rd@verizon.net>\n\n\tPR C++/60209 - Declaration of user-defined literal operator cause error\n\t* cp/parser.c (cp_parser_operator()): Fold treatment of strings\n\tand user-defined string literals.  Use the full string parser.\n\t(cp_parser_string_literal()): Add flag to not look for literal operator.\n\n\ntestsuite/\n\t\n2014-07-13  Edward Smith-Rowland  <3dw4rd@verizon.net>\n\n\tPR C++/60209 - Declaration of user-defined literal operator cause error\n\t* g++.dg/cpp0x/pr60209-neg.C: New.\n\t* g++.dg/cpp0x/pr60209.C: New.\n\t* g++.dg/cpp1y/udlit-empty-string-neg.C: Adjust messages.\n\nFrom-SVN: r212494", "tree": {"sha": "cd2e3b27e59a076806ec50f18f9806df1388208c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd2e3b27e59a076806ec50f18f9806df1388208c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6abdc366af68c28e3e8da236dfa7037be38971e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6abdc366af68c28e3e8da236dfa7037be38971e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6abdc366af68c28e3e8da236dfa7037be38971e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6abdc366af68c28e3e8da236dfa7037be38971e/comments", "author": {"login": "emsr", "id": 1936479, "node_id": "MDQ6VXNlcjE5MzY0Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1936479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emsr", "html_url": "https://github.com/emsr", "followers_url": "https://api.github.com/users/emsr/followers", "following_url": "https://api.github.com/users/emsr/following{/other_user}", "gists_url": "https://api.github.com/users/emsr/gists{/gist_id}", "starred_url": "https://api.github.com/users/emsr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emsr/subscriptions", "organizations_url": "https://api.github.com/users/emsr/orgs", "repos_url": "https://api.github.com/users/emsr/repos", "events_url": "https://api.github.com/users/emsr/events{/privacy}", "received_events_url": "https://api.github.com/users/emsr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ca631fc2a4a08e2910c2b643fa1428b07ccdbb29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca631fc2a4a08e2910c2b643fa1428b07ccdbb29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca631fc2a4a08e2910c2b643fa1428b07ccdbb29"}], "stats": {"total": 186, "additions": 117, "deletions": 69}, "files": [{"sha": "e873d992cef7e872040f8e06edd69075638d84f1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6abdc366af68c28e3e8da236dfa7037be38971e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6abdc366af68c28e3e8da236dfa7037be38971e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c6abdc366af68c28e3e8da236dfa7037be38971e", "patch": "@@ -1,3 +1,10 @@\n+2014-07-13  Edward Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\tPR C++/60209 - Declaration of user-defined literal operator cause error\n+\t* cp/parser.c (cp_parser_operator()): Fold treatment of strings\n+\tand user-defined string literals.  Use the full string parser.\n+\t(cp_parser_string_literal()): Add flag to not look for literal operator.\n+\n 2014-07-11  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/22434"}, {"sha": "b260b2443ab37d3c11d598adf235bff54a527df1", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 59, "deletions": 65, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6abdc366af68c28e3e8da236dfa7037be38971e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6abdc366af68c28e3e8da236dfa7037be38971e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=c6abdc366af68c28e3e8da236dfa7037be38971e", "patch": "@@ -1895,7 +1895,7 @@ static cp_parser *cp_parser_new\n static tree cp_parser_identifier\n   (cp_parser *);\n static tree cp_parser_string_literal\n-  (cp_parser *, bool, bool);\n+  (cp_parser *, bool, bool, bool);\n static tree cp_parser_userdef_char_literal\n   (cp_parser *);\n static tree cp_parser_userdef_string_literal\n@@ -3566,7 +3566,8 @@ cp_parser_identifier (cp_parser* parser)\n \n    FUTURE: ObjC++ will need to handle @-strings here.  */\n static tree\n-cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n+cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok,\n+\t\t\t  bool lookup_udlit = true)\n {\n   tree value;\n   size_t count;\n@@ -3721,7 +3722,10 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n \t{\n \t  tree literal = build_userdef_literal (suffix_id, value,\n \t\t\t\t\t\tOT_NONE, NULL_TREE);\n-\t  value = cp_parser_userdef_string_literal (literal);\n+\t  if (lookup_udlit)\n+\t    value = cp_parser_userdef_string_literal (literal);\n+\t  else\n+\t    value = literal;\n \t}\n     }\n   else\n@@ -12636,7 +12640,7 @@ cp_parser_operator (cp_parser* parser)\n {\n   tree id = NULL_TREE;\n   cp_token *token;\n-  bool bad_encoding_prefix = false;\n+  bool utf8 = false;\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -12836,83 +12840,73 @@ cp_parser_operator (cp_parser* parser)\n       cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n       return ansi_opname (ARRAY_REF);\n \n+    case CPP_UTF8STRING:\n+    case CPP_UTF8STRING_USERDEF:\n+      utf8 = true;\n+    case CPP_STRING:\n     case CPP_WSTRING:\n     case CPP_STRING16:\n     case CPP_STRING32:\n-    case CPP_UTF8STRING:\n-     bad_encoding_prefix = true;\n-      /* Fall through.  */\n-\n-    case CPP_STRING:\n-      if (cxx_dialect == cxx98)\n-\tmaybe_warn_cpp0x (CPP0X_USER_DEFINED_LITERALS);\n-      if (bad_encoding_prefix)\n-\t{\n-\t  error (\"invalid encoding prefix in literal operator\");\n-\t  return error_mark_node;\n-\t}\n-      if (TREE_STRING_LENGTH (token->u.value) > 2)\n-\t{\n-\t  error (\"expected empty string after %<operator%> keyword\");\n-\t  return error_mark_node;\n-\t}\n-      /* Consume the string.  */\n-      cp_lexer_consume_token (parser->lexer);\n-      /* Look for the suffix identifier.  */\n-      token = cp_lexer_peek_token (parser->lexer);\n-      if (token->type == CPP_NAME)\n-\t{\n-\t  id = cp_parser_identifier (parser);\n-\t  if (id != error_mark_node)\n-\t    {\n-\t      const char *name = IDENTIFIER_POINTER (id);\n-\t      return cp_literal_operator_id (name);\n-\t    }\n-\t}\n-      else if (token->type == CPP_KEYWORD)\n-\t{\n-\t  error (\"unexpected keyword;\"\n-\t\t \" remove space between quotes and suffix identifier\");\n-\t  return error_mark_node;\n-\t}\n-      else\n-\t{\n-\t  error (\"expected suffix identifier\");\n-\t  return error_mark_node;\n-\t}\n-\n+    case CPP_STRING_USERDEF:\n     case CPP_WSTRING_USERDEF:\n     case CPP_STRING16_USERDEF:\n     case CPP_STRING32_USERDEF:\n-    case CPP_UTF8STRING_USERDEF:\n-      bad_encoding_prefix = true;\n-      /* Fall through.  */\n+      {\n+\ttree str, string_tree;\n+\tint sz, len;\n \n-    case CPP_STRING_USERDEF:\n-      if (cxx_dialect == cxx98)\n-\tmaybe_warn_cpp0x (CPP0X_USER_DEFINED_LITERALS);\n-      if (bad_encoding_prefix)\n-\t{\n-\t  error (\"invalid encoding prefix in literal operator\");\n+\tif (cxx_dialect == cxx98)\n+\t  maybe_warn_cpp0x (CPP0X_USER_DEFINED_LITERALS);\n+\n+\t/* Consume the string.  */\n+\tstr = cp_parser_string_literal (parser, /*translate=*/true,\n+\t\t\t\t      /*wide_ok=*/true, /*lookup_udlit=*/false);\n+\tif (str == error_mark_node)\n \t  return error_mark_node;\n-\t}\n-      {\n-\ttree string_tree = USERDEF_LITERAL_VALUE (token->u.value);\n-\tif (TREE_STRING_LENGTH (string_tree) > 2)\n+\telse if (TREE_CODE (str) == USERDEF_LITERAL)\n+\t  {\n+\t    string_tree = USERDEF_LITERAL_VALUE (str);\n+\t    id = USERDEF_LITERAL_SUFFIX_ID (str);\n+\t  }\n+\telse\n+\t  {\n+\t    string_tree = str;\n+\t    /* Look for the suffix identifier.  */\n+\t    token = cp_lexer_peek_token (parser->lexer);\n+\t    if (token->type == CPP_NAME)\n+\t      id = cp_parser_identifier (parser);\n+\t    else if (token->type == CPP_KEYWORD)\n+\t      {\n+\t\terror (\"unexpected keyword;\"\n+\t\t       \" remove space between quotes and suffix identifier\");\n+\t\treturn error_mark_node;\n+\t      }\n+\t    else\n+\t      {\n+\t\terror (\"expected suffix identifier\");\n+\t\treturn error_mark_node;\n+\t      }\n+\t  }\n+\tsz = TREE_INT_CST_LOW (TYPE_SIZE_UNIT\n+\t\t\t       (TREE_TYPE (TREE_TYPE (string_tree))));\n+\tlen = TREE_STRING_LENGTH (string_tree) / sz - 1;\n+\tif (len != 0)\n \t  {\n \t    error (\"expected empty string after %<operator%> keyword\");\n \t    return error_mark_node;\n \t  }\n-\tid = USERDEF_LITERAL_SUFFIX_ID (token->u.value);\n-\t/* Consume the user-defined string literal.  */\n-\tcp_lexer_consume_token (parser->lexer);\n+\tif (utf8 || TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (string_tree)))\n+\t    != char_type_node)\n+\t  {\n+\t    error (\"invalid encoding prefix in literal operator\");\n+\t    return error_mark_node;\n+\t  }\n \tif (id != error_mark_node)\n \t  {\n \t    const char *name = IDENTIFIER_POINTER (id);\n-\t    return cp_literal_operator_id (name);\n+\t    id = cp_literal_operator_id (name);\n \t  }\n-\telse\n-\t  return error_mark_node;\n+\treturn id;\n       }\n \n     default:"}, {"sha": "ac434256adc288dc3cb17c995724afd4b4099c89", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6abdc366af68c28e3e8da236dfa7037be38971e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6abdc366af68c28e3e8da236dfa7037be38971e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c6abdc366af68c28e3e8da236dfa7037be38971e", "patch": "@@ -1,3 +1,10 @@\n+2014-07-13  Edward Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\tPR C++/60209 - Declaration of user-defined literal operator cause error\n+\t* g++.dg/cpp0x/pr60209-neg.C: New.\n+\t* g++.dg/cpp0x/pr60209.C: New.\n+\t* g++.dg/cpp1y/udlit-empty-string-neg.C: Adjust messages.\n+\n 2014-07-13  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/60967"}, {"sha": "77fd3d81691120276b2d15df051a71b854629344", "filename": "gcc/testsuite/g++.dg/cpp0x/pr60209-neg.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6abdc366af68c28e3e8da236dfa7037be38971e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr60209-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6abdc366af68c28e3e8da236dfa7037be38971e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr60209-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr60209-neg.C?ref=c6abdc366af68c28e3e8da236dfa7037be38971e", "patch": "@@ -0,0 +1,28 @@\n+// PR c++/60209\n+// { dg-do compile { target c++11 } }\n+\n+// http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1473\n+\n+void operator \"\" \"boo\" _ya(unsigned long long); // { dg-error \"expected empty string after\" }\n+\n+void operator \"\" \"boo\"_ya(unsigned long long); // { dg-error \"expected empty string after\" }\n+\n+void operator \"\" u\"\" _u(unsigned long long); // { dg-error \"invalid encoding prefix in literal operator\" }\n+\n+void operator u\"\" \"\" _v(unsigned long long); // { dg-error \"invalid encoding prefix in literal operator\" }\n+\n+void operator U\"\" \"\" _w(unsigned long long); // { dg-error \"invalid encoding prefix in literal operator\" }\n+\n+void operator L\"\" \"\" _x(unsigned long long); // { dg-error \"invalid encoding prefix in literal operator\" }\n+\n+void operator u8\"\" \"\" _y(unsigned long long); // { dg-error \"invalid encoding prefix in literal operator\" }\n+\n+void operator u\"\" L\"\" _z(unsigned long long); // { dg-error \"unsupported non-standard concatenation of string literals\" }\n+\n+void operator \"\"_p \"\"_q(unsigned long long); // { dg-error \"inconsistent user-defined literal suffixes\" }\n+\n+void operator \"\" \"\" while(unsigned long long); // { dg-error \"unexpected keyword; remove space between quotes and suffix identifier\" }\n+\n+void operator \"\" \"\"(unsigned long long); // { dg-error \"expected suffix identifier\" }\n+\n+// { dg-error \"invalid encoding prefix in literal operator\" \"invalid\" { target *-*-* } 20 }"}, {"sha": "6ed26e9bcc6dadbd9ec38e184905bd663aa5e71f", "filename": "gcc/testsuite/g++.dg/cpp0x/pr60209.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6abdc366af68c28e3e8da236dfa7037be38971e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr60209.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6abdc366af68c28e3e8da236dfa7037be38971e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr60209.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr60209.C?ref=c6abdc366af68c28e3e8da236dfa7037be38971e", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/60209\n+// { dg-do compile { target c++11 } }\n+\n+// http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1473\n+\n+void operator \"\" \"\" _x(unsigned long long);\n+\n+void operator \"\" \"\" \"\" _x(unsigned long long);\n+\n+void operator \"\" \"\"_w(unsigned long long);\n+\n+void operator \"\" \"\"_w \"\"(unsigned long long);"}, {"sha": "4f1a34a5cdcb9e1a3a0a631d35d99a16c556f935", "filename": "gcc/testsuite/g++.dg/cpp1y/udlit-empty-string-neg.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6abdc366af68c28e3e8da236dfa7037be38971e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fudlit-empty-string-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6abdc366af68c28e3e8da236dfa7037be38971e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fudlit-empty-string-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fudlit-empty-string-neg.C?ref=c6abdc366af68c28e3e8da236dfa7037be38971e", "patch": "@@ -5,17 +5,17 @@ operator \"*\"_s(unsigned long long) // { dg-error \"expected empty string after 'o\n { return 0; }\n \n int\n-operator L\"*\"_Ls(unsigned long long) // { dg-error \"invalid encoding prefix in literal operator\" }\n+operator L\"*\"_Ls(unsigned long long) // { dg-error \"expected empty string after 'operator'\" }\n { return 0; }\n \n int\n-operator u\"*\"_s16(unsigned long long) // { dg-error \"invalid encoding prefix in literal operator\" }\n+operator u\"*\"_s16(unsigned long long) // { dg-error \"expected empty string after 'operator'\" }\n { return 0; }\n \n int\n-operator U\"*\"_s32(unsigned long long) // { dg-error \"invalid encoding prefix in literal operator\" }\n+operator U\"*\"_s32(unsigned long long) // { dg-error \"expected empty string after 'operator'\" }\n { return 0; }\n \n int\n-operator u8\"*\"_u8s(unsigned long long) // { dg-error \"invalid encoding prefix in literal operator\" }\n+operator u8\"*\"_u8s(unsigned long long) // { dg-error \"expected empty string after 'operator'\" }\n { return 0; }"}]}