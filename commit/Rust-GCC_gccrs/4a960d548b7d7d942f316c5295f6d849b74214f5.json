{"sha": "4a960d548b7d7d942f316c5295f6d849b74214f5", "node_id": "C_kwDOANBUbNoAKDRhOTYwZDU0OGI3ZDdkOTQyZjMxNmM1Mjk1ZjZkODQ5Yjc0MjE0ZjU", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-23T08:59:24Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-24T06:25:42Z"}, "message": "Avoid invalid loop transformations in jump threading registry.\n\nMy upcoming improvements to the forward jump threader make it thread\nmore aggressively.  In investigating some \"regressions\", I noticed\nthat it has always allowed threading through empty latches and across\nloop boundaries.  As we have discussed recently, this should be avoided\nuntil after loop optimizations have run their course.\n\nNote that this wasn't much of a problem before because DOM/VRP\ncouldn't find these opportunities, but with a smarter solver, we trip\nover them more easily.\n\nBecause the forward threader doesn't have an independent localized cost\nmodel like the new threader (profitable_path_p), it is difficult to\ncatch these things at discovery.  However, we can catch them at\nregistration time, with the added benefit that all the threaders\n(forward and backward) can share the handcuffs.\n\nThis patch is an adaptation of what we do in the backward threader, but\nit is not meant to catch everything we do there, as some of the\nrestrictions there are due to limitations of the different block\ncopiers (for example, the generic copier does not re-use existing\nthreading paths).\n\nWe could ideally remove the now redundant bits in profitable_path_p, but\nI would prefer not to for two reasons.  First, the backward threader uses\nprofitable_path_p as it discovers paths to avoid discovering paths in\nunprofitable directions.  Second, I would like to merge all the forward\ncost restrictions into the profitability class in the backward threader,\nnot the other way around.  Alas, that reshuffling will have to wait for\nthe next release.\n\nAs usual, there are quite a few tests that needed adjustments.  It seems\nwe were quite happily threading improper scenarios.  With most of them,\nas can be seen in pr77445-2.c, we're merely shifting the threading to\nafter loop optimizations.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-threadupdate.c (jt_path_registry::cancel_invalid_paths):\n\tNew.\n\t(jt_path_registry::register_jump_thread): Call\n\tcancel_invalid_paths.\n\t* tree-ssa-threadupdate.h (class jt_path_registry): Add\n\tcancel_invalid_paths.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/20030714-2.c: Adjust.\n\t* gcc.dg/tree-ssa/pr66752-3.c: Adjust.\n\t* gcc.dg/tree-ssa/pr77445-2.c: Adjust.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-18.c: Adjust.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-7.c: Adjust.\n\t* gcc.dg/vect/bb-slp-16.c: Adjust.", "tree": {"sha": "2bb1ed9fcf27bd928129ef4a49b7ad379407307d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bb1ed9fcf27bd928129ef4a49b7ad379407307d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a960d548b7d7d942f316c5295f6d849b74214f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a960d548b7d7d942f316c5295f6d849b74214f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a960d548b7d7d942f316c5295f6d849b74214f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a960d548b7d7d942f316c5295f6d849b74214f5/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29c92857039d0a105281be61c10c9e851aaeea4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29c92857039d0a105281be61c10c9e851aaeea4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29c92857039d0a105281be61c10c9e851aaeea4a"}], "stats": {"total": 113, "additions": 78, "deletions": 35}, "files": [{"sha": "9585ff11307bd8de395ccdee724dd94a6700ec94", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030714-2.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a960d548b7d7d942f316c5295f6d849b74214f5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030714-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a960d548b7d7d942f316c5295f6d849b74214f5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030714-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030714-2.c?ref=4a960d548b7d7d942f316c5295f6d849b74214f5", "patch": "@@ -32,7 +32,8 @@ get_alias_set (t)\n     }\n }\n \n-/* There should be exactly three IF conditionals if we thread jumps\n-   properly.  */\n-/* { dg-final { scan-tree-dump-times \"if \" 3 \"dom2\"} } */\n+/* There should be exactly 4 IF conditionals if we thread jumps\n+   properly.  There used to be 3, but one thread was crossing\n+   loops.  */\n+/* { dg-final { scan-tree-dump-times \"if \" 4 \"dom2\"} } */\n  "}, {"sha": "922a331b2179c206b979b89a037fec5bad2c20c5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr66752-3.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a960d548b7d7d942f316c5295f6d849b74214f5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66752-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a960d548b7d7d942f316c5295f6d849b74214f5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66752-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66752-3.c?ref=4a960d548b7d7d942f316c5295f6d849b74214f5", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-thread1-details -fdump-tree-dce2\" } */\n+/* { dg-options \"-O2 -fdump-tree-thread1-details -fdump-tree-thread3\" } */\n \n extern int status, pt;\n extern int count;\n@@ -32,10 +32,15 @@ foo (int N, int c, int b, int *a)\n    pt--;\n }\n \n-/* There are 4 jump threading opportunities, all of which will be\n-   realized, which will eliminate testing of FLAG, completely.  */\n-/* { dg-final { scan-tree-dump-times \"Registering jump\" 4 \"thread1\"} } */\n+/* There are 2 jump threading opportunities (which don't cross loops),\n+   all of which will be realized, which will eliminate testing of\n+   FLAG, completely.  */\n+/* { dg-final { scan-tree-dump-times \"Registering jump\" 2 \"thread1\"} } */\n \n-/* There should be no assignments or references to FLAG, verify they're\n-   eliminated as early as possible.  */\n-/* { dg-final { scan-tree-dump-not \"if .flag\" \"dce2\"} } */\n+/* We used to remove references to FLAG by DCE2, but this was\n+   depending on early threaders threading through loop boundaries\n+   (which we shouldn't do).  However, the late threading passes, which\n+   run after loop optimizations , can successfully eliminate the\n+   references to FLAG.  Verify that ther are no references by the late\n+   threading passes.  */\n+/* { dg-final { scan-tree-dump-not \"if .flag\" \"thread3\"} } */"}, {"sha": "01a0f1f197da83a85bc9c5a928fc542059af67f5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr77445-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a960d548b7d7d942f316c5295f6d849b74214f5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77445-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a960d548b7d7d942f316c5295f6d849b74214f5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77445-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77445-2.c?ref=4a960d548b7d7d942f316c5295f6d849b74214f5", "patch": "@@ -123,8 +123,8 @@ enum STATES FMS( u8 **in , u32 *transitions) {\n    aarch64 has the highest CASE_VALUES_THRESHOLD in GCC.  It's high enough\n    to change decisions in switch expansion which in turn can expose new\n    jump threading opportunities.  Skip the later tests on aarch64.  */\n-/* { dg-final { scan-tree-dump \"Jumps threaded: 1\\[1-9\\]\" \"thread1\" } } */\n-/* { dg-final { scan-tree-dump-times \"Invalid sum\" 4 \"thread1\" } } */\n+/* { dg-final { scan-tree-dump \"Jumps threaded: 9\" \"thread1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Invalid sum\" 1 \"thread1\" } } */\n /* { dg-final { scan-tree-dump-not \"optimizing for size\" \"thread1\" } } */\n /* { dg-final { scan-tree-dump-not \"optimizing for size\" \"thread2\" } } */\n /* { dg-final { scan-tree-dump-not \"optimizing for size\" \"thread3\" { target { ! aarch64*-*-* } } } } */"}, {"sha": "2d78d045516708cf45698a82759f72ba6d2ea7f9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-18.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a960d548b7d7d942f316c5295f6d849b74214f5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a960d548b7d7d942f316c5295f6d849b74214f5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-18.c?ref=4a960d548b7d7d942f316c5295f6d849b74214f5", "patch": "@@ -21,5 +21,7 @@\n \t condition.\n \n    All the cases are picked up by VRP1 as jump threads.  */\n-/* { dg-final { scan-tree-dump-times \"Registering jump\" 6 \"thread1\" } } */\n+\n+/* There used to be 6 jump threads found by thread1, but they all\n+   depended on threading through distinct loops in ethread.  */\n /* { dg-final { scan-tree-dump-times \"Threaded\" 2 \"vrp1\" } } */"}, {"sha": "16abcde50532bbc23899148d44578185f9faca21", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-7.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a960d548b7d7d942f316c5295f6d849b74214f5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a960d548b7d7d942f316c5295f6d849b74214f5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c?ref=4a960d548b7d7d942f316c5295f6d849b74214f5", "patch": "@@ -1,8 +1,8 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fdump-tree-thread1-stats -fdump-tree-thread2-stats -fdump-tree-dom2-stats -fdump-tree-thread3-stats -fdump-tree-dom3-stats -fdump-tree-vrp2-stats -fno-guess-branch-probability\" } */\n \n-/* { dg-final { scan-tree-dump \"Jumps threaded: 18\"  \"thread1\" } } */\n-/* { dg-final { scan-tree-dump \"Jumps threaded: 8\" \"thread3\" { target { ! aarch64*-*-* } } } } */\n+/* { dg-final { scan-tree-dump \"Jumps threaded: 12\"  \"thread1\" } } */\n+/* { dg-final { scan-tree-dump \"Jumps threaded: 5\" \"thread3\" { target { ! aarch64*-*-* } } } } */\n /* { dg-final { scan-tree-dump-not \"Jumps threaded\"  \"dom2\" } } */\n \n /* aarch64 has the highest CASE_VALUES_THRESHOLD in GCC.  It's high enough"}, {"sha": "e68a9b6253534be8b35ee0e8961dd66dff68c63c", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-16.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a960d548b7d7d942f316c5295f6d849b74214f5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a960d548b7d7d942f316c5295f6d849b74214f5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-16.c?ref=4a960d548b7d7d942f316c5295f6d849b74214f5", "patch": "@@ -1,8 +1,5 @@\n /* { dg-require-effective-target vect_int } */\n \n-/* See note below as to why we disable threading.  */\n-/* { dg-additional-options \"-fdisable-tree-thread1\" } */\n-\n #include <stdarg.h>\n #include \"tree-vect.h\"\n \n@@ -30,10 +27,6 @@ main1 (int dummy)\n       *pout++ = *pin++ + a;\n       *pout++ = *pin++ + a;\n       *pout++ = *pin++ + a;\n-      /* In some architectures like ppc64, jump threading may thread\n-\t the iteration where i==0 such that we no longer optimize the\n-\t BB.  Another alternative to disable jump threading would be\n-\t to wrap the read from `i' into a function returning i.  */\n       if (arr[i] = i)\n         a = i;\n       else"}, {"sha": "2b9b8f8127489e06c24d8349fd4aa042baa2e278", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 54, "deletions": 13, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a960d548b7d7d942f316c5295f6d849b74214f5/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a960d548b7d7d942f316c5295f6d849b74214f5/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=4a960d548b7d7d942f316c5295f6d849b74214f5", "patch": "@@ -2757,6 +2757,58 @@ fwd_jt_path_registry::update_cfg (bool may_peel_loop_headers)\n   return retval;\n }\n \n+bool\n+jt_path_registry::cancel_invalid_paths (vec<jump_thread_edge *> &path)\n+{\n+  gcc_checking_assert (!path.is_empty ());\n+  edge taken_edge = path[path.length () - 1]->e;\n+  loop_p loop = taken_edge->src->loop_father;\n+  bool seen_latch = false;\n+  bool path_crosses_loops = false;\n+\n+  for (unsigned int i = 0; i < path.length (); i++)\n+    {\n+      edge e = path[i]->e;\n+\n+      if (e == NULL)\n+\t{\n+\t  // NULL outgoing edges on a path can happen for jumping to a\n+\t  // constant address.\n+\t  cancel_thread (&path, \"Found NULL edge in jump threading path\");\n+\t  return true;\n+\t}\n+\n+      if (loop->latch == e->src || loop->latch == e->dest)\n+\tseen_latch = true;\n+\n+      // The first entry represents the block with an outgoing edge\n+      // that we will redirect to the jump threading path.  Thus we\n+      // don't care about that block's loop father.\n+      if ((i > 0 && e->src->loop_father != loop)\n+\t  || e->dest->loop_father != loop)\n+\tpath_crosses_loops = true;\n+\n+      if (flag_checking && !m_backedge_threads)\n+\tgcc_assert ((path[i]->e->flags & EDGE_DFS_BACK) == 0);\n+    }\n+\n+  if (cfun->curr_properties & PROP_loop_opts_done)\n+    return false;\n+\n+  if (seen_latch && empty_block_p (loop->latch))\n+    {\n+      cancel_thread (&path, \"Threading through latch before loop opts \"\n+\t\t     \"would create non-empty latch\");\n+      return true;\n+    }\n+  if (path_crosses_loops)\n+    {\n+      cancel_thread (&path, \"Path crosses loops\");\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Register a jump threading opportunity.  We queue up all the jump\n    threading opportunities discovered by a pass and update the CFG\n    and SSA form all at once.\n@@ -2776,19 +2828,8 @@ jt_path_registry::register_jump_thread (vec<jump_thread_edge *> *path)\n       return false;\n     }\n \n-  /* First make sure there are no NULL outgoing edges on the jump threading\n-     path.  That can happen for jumping to a constant address.  */\n-  for (unsigned int i = 0; i < path->length (); i++)\n-    {\n-      if ((*path)[i]->e == NULL)\n-\t{\n-\t  cancel_thread (path, \"Found NULL edge in jump threading path\");\n-\t  return false;\n-\t}\n-\n-      if (flag_checking && !m_backedge_threads)\n-\tgcc_assert (((*path)[i]->e->flags & EDGE_DFS_BACK) == 0);\n-    }\n+  if (cancel_invalid_paths (*path))\n+    return false;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_jump_thread_path (dump_file, *path, true);"}, {"sha": "d68795c9f278e5646fa07c853f58878eaff8ab8e", "filename": "gcc/tree-ssa-threadupdate.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a960d548b7d7d942f316c5295f6d849b74214f5/gcc%2Ftree-ssa-threadupdate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a960d548b7d7d942f316c5295f6d849b74214f5/gcc%2Ftree-ssa-threadupdate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.h?ref=4a960d548b7d7d942f316c5295f6d849b74214f5", "patch": "@@ -75,6 +75,7 @@ class jt_path_registry\n   unsigned long m_num_threaded_edges;\n private:\n   virtual bool update_cfg (bool peel_loop_headers) = 0;\n+  bool cancel_invalid_paths (vec<jump_thread_edge *> &path);\n   jump_thread_path_allocator m_allocator;\n   // True if threading through back edges is allowed.  This is only\n   // allowed in the generic copier in the backward threader."}]}