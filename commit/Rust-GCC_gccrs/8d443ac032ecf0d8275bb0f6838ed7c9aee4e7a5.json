{"sha": "8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5", "node_id": "C_kwDOANBUbNoAKDhkNDQzYWMwMzJlY2YwZDgyNzViYjBmNjgzOGVkN2M5YWVlNGU3YTU", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-12-15T07:02:24Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-12-15T07:02:24Z"}, "message": "Generate XXSPLTIDP for vectors on power10.\n\nThis patch implements XXSPLTIDP support for all vector constants.  The\nXXSPLTIDP instruction is given a 32-bit immediate that is converted to a vector\nof two DFmode constants.  The immediate is in SFmode format, so only constants\nthat fit as SFmode values can be loaded with XXSPLTIDP.\n\nThe constraint (eP) added in the previous patch for XXSPLTIW is also used\nfor XXSPLTIDP.\n\nDImode scalar constants are not handled.  This is due to the majority of DImode\nconstants will be in the GPR registers.  With vector registers, you have the\nproblem that XXSPLTIDP splats the double word into both elements of the\nvector.  However, if TImode is loaded with an integer constant, it wants a full\n128-bit constant.\n\nSFmode and DFmode scalar constants are not handled in this patch.  The\nsupport for for those constants will be in the next patch.\n\nI have added a temporary switch (-msplat-float-constant) to control whether or\nnot the XXSPLTIDP instruction is generated.\n\nI added 2 new tests to test loading up V2DI and V2DF vector constants.\n\n2021-12-14  Michael Meissner  <meissner@the-meissners.org>\n\ngcc/\n\n\t* config/rs6000/predicates.md (easy_fp_constant): Add support for\n\tgenerating XXSPLTIDP.\n\t(vsx_prefixed_constant): Likewise.\n\t(easy_vector_constant): Likewise.\n\t* config/rs6000/rs6000-protos.h (constant_generates_xxspltidp):\n\tNew declaration.\n\t* config/rs6000/rs6000.c (output_vec_const_move): Add support for\n\tgenerating XXSPLTIDP.\n\t(prefixed_xxsplti_p): Likewise.\n\t(constant_generates_xxspltidp): New function.\n\t* config/rs6000/rs6000.opt (-msplat-float-constant): New debug option.\n\ngcc/testsuite/\n\n\t* gcc.target/powerpc/pr86731-fwrapv-longlong.c: Update insn\n\tregex for power10.\n\t* gcc.target/powerpc/vec-splat-constant-v2df.c: New test.\n\t* gcc.target/powerpc/vec-splat-constant-v2di.c: New test.", "tree": {"sha": "337f7f1c6573c0d4265c9497123312e9e4a9ef7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/337f7f1c6573c0d4265c9497123312e9e4a9ef7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5/comments", "author": null, "committer": null, "parents": [{"sha": "d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d730aa8a9ff26a36c3b480402c1507f3d2e48db9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d730aa8a9ff26a36c3b480402c1507f3d2e48db9"}], "stats": {"total": 245, "additions": 241, "deletions": 4}, "files": [{"sha": "0d9f6a6fb72b8dab2aaaa1d1110994020761cb02", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5", "patch": "@@ -610,6 +610,9 @@\n \n       if (constant_generates_xxspltiw (&vsx_const))\n \treturn true;\n+\n+      if (constant_generates_xxspltidp (&vsx_const))\n+\treturn true;\n     }\n \n   /* Otherwise consider floating point constants hard, so that the\n@@ -653,6 +656,9 @@\n   if (constant_generates_xxspltiw (&vsx_const))\n     return true;\n \n+  if (constant_generates_xxspltidp (&vsx_const))\n+    return true;\n+\n   return false;\n })\n \n@@ -727,6 +733,9 @@\n \n \t  if (constant_generates_xxspltiw (&vsx_const))\n \t    return true;\n+\n+\t  if (constant_generates_xxspltidp (&vsx_const))\n+\t    return true;\n \t}\n \n       if (TARGET_P9_VECTOR"}, {"sha": "3e03d37ac7ce7dec648fe1c2e3f5a9db512862df", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5", "patch": "@@ -253,6 +253,7 @@ extern bool vec_const_128bit_to_bytes (rtx, machine_mode,\n \t\t\t\t       vec_const_128bit_type *);\n extern unsigned constant_generates_lxvkq (vec_const_128bit_type *);\n extern unsigned constant_generates_xxspltiw (vec_const_128bit_type *);\n+extern unsigned constant_generates_xxspltidp (vec_const_128bit_type *);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE"}, {"sha": "e82a47f4c0ebb47ec91092f9eb87c4591efc04c7", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5", "patch": "@@ -6723,6 +6723,13 @@ output_vec_const_move (rtx *operands)\n \t      operands[2] = GEN_INT (imm);\n \t      return \"xxspltiw %x0,%2\";\n \t    }\n+\n+\t  imm = constant_generates_xxspltidp (&vsx_const);\n+\t  if (imm)\n+\t    {\n+\t      operands[2] = GEN_INT (imm);\n+\t      return \"xxspltidp %x0,%2\";\n+\t    }\n \t}\n \n       if (TARGET_P9_VECTOR\n@@ -26524,6 +26531,9 @@ prefixed_xxsplti_p (rtx_insn *insn)\n     {\n       if (constant_generates_xxspltiw (&vsx_const))\n \treturn true;\n+\n+      if (constant_generates_xxspltidp (&vsx_const))\n+\treturn true;\n     }\n \n   return false;\n@@ -28731,6 +28741,104 @@ constant_generates_xxspltiw (vec_const_128bit_type *vsx_const)\n   return vsx_const->words[0];\n }\n \n+/* Determine if a vector constant can be loaded with XXSPLTIDP.  Return zero if\n+   the XXSPLTIDP instruction cannot be used.  Otherwise return the immediate\n+   value to be used with the XXSPLTIDP instruction.  */\n+\n+unsigned\n+constant_generates_xxspltidp (vec_const_128bit_type *vsx_const)\n+{\n+  if (!TARGET_SPLAT_FLOAT_CONSTANT || !TARGET_PREFIXED || !TARGET_VSX)\n+    return 0;\n+\n+  /* Reject if the two 64-bit segments are not the same.  */\n+  if (!vsx_const->all_double_words_same)\n+    return 0;\n+\n+  /* If the bytes, half words, or words are all the same, don't use XXSPLTIDP.\n+     Use a simpler instruction (XXSPLTIB, VSPLTISB, VSPLTISH, or VSPLTISW).  */\n+  if (vsx_const->all_bytes_same\n+      || vsx_const->all_half_words_same\n+      || vsx_const->all_words_same)\n+    return 0;\n+\n+  unsigned HOST_WIDE_INT value = vsx_const->double_words[0];\n+\n+  /* Avoid values that look like DFmode NaN's, except for the normal NaN bit\n+     pattern and the signalling NaN bit pattern.  Recognize infinity and\n+     negative infinity.  */\n+\n+  /* Bit representation of DFmode normal quiet NaN.  */\n+#define RS6000_CONST_DF_NAN\tHOST_WIDE_INT_UC (0x7ff8000000000000)\n+\n+  /* Bit representation of DFmode normal signaling NaN.  */\n+#define RS6000_CONST_DF_NANS\tHOST_WIDE_INT_UC (0x7ff4000000000000)\n+\n+  /* Bit representation of DFmode positive infinity.  */\n+#define RS6000_CONST_DF_INF\tHOST_WIDE_INT_UC (0x7ff0000000000000)\n+\n+  /* Bit representation of DFmode negative infinity.  */\n+#define RS6000_CONST_DF_NEG_INF\tHOST_WIDE_INT_UC (0xfff0000000000000)\n+\n+  if (value != RS6000_CONST_DF_NAN\n+      && value != RS6000_CONST_DF_NANS\n+      && value != RS6000_CONST_DF_INF\n+      && value != RS6000_CONST_DF_NEG_INF)\n+    {\n+      /* The IEEE 754 64-bit floating format has 1 bit for sign, 11 bits for\n+\t the exponent, and 52 bits for the mantissa (not counting the hidden\n+\t bit used for normal numbers).  NaN values have the exponent set to all\n+\t 1 bits, and the mantissa non-zero (mantissa == 0 is infinity).  */\n+\n+      int df_exponent = (value >> 52) & 0x7ff;\n+      unsigned HOST_WIDE_INT\n+\tdf_mantissa = value & ((HOST_WIDE_INT_1U << 52) - HOST_WIDE_INT_1U);\n+\n+      if (df_exponent == 0x7ff && df_mantissa != 0)\t/* other NaNs.  */\n+\treturn 0;\n+\n+      /* Avoid values that are DFmode subnormal values.  Subnormal numbers have\n+\t the exponent all 0 bits, and the mantissa non-zero.  If the value is\n+\t subnormal, then the hidden bit in the mantissa is not set.  */\n+      if (df_exponent == 0 && df_mantissa != 0)\t\t/* subnormal.  */\n+\treturn 0;\n+    }\n+\n+  /* Change the representation to DFmode constant.  */\n+  long df_words[2] = { vsx_const->words[0], vsx_const->words[1] };\n+\n+  /* real_from_target takes the target words in target order.  */\n+  if (!BYTES_BIG_ENDIAN)\n+    std::swap (df_words[0], df_words[1]);\n+\n+  REAL_VALUE_TYPE rv_type;\n+  real_from_target (&rv_type, df_words, DFmode);\n+\n+  const REAL_VALUE_TYPE *rv = &rv_type;\n+\n+  /* Validate that the number can be stored as a SFmode value.  */\n+  if (!exact_real_truncate (SFmode, rv))\n+    return 0;\n+\n+  /* Validate that the number is not a SFmode subnormal value (exponent is 0,\n+     mantissa field is non-zero) which is undefined for the XXSPLTIDP\n+     instruction.  */\n+  long sf_value;\n+  real_to_target (&sf_value, rv, SFmode);\n+\n+  /* IEEE 754 32-bit values have 1 bit for the sign, 8 bits for the exponent,\n+     and 23 bits for the mantissa.  Subnormal numbers have the exponent all\n+     0 bits, and the mantissa non-zero.  */\n+  long sf_exponent = (sf_value >> 23) & 0xFF;\n+  long sf_mantissa = sf_value & 0x7FFFFF;\n+\n+  if (sf_exponent == 0 && sf_mantissa != 0)\n+    return 0;\n+\n+  /* Return the immediate to be used.  */\n+  return sf_value;\n+}\n+\n \f\n struct gcc_target targetm = TARGET_INITIALIZER;\n "}, {"sha": "c1d661d7e6bc0fb8d932b5b921ecc598e4d94227", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5", "patch": "@@ -644,6 +644,10 @@ msplat-word-constant\n Target Var(TARGET_SPLAT_WORD_CONSTANT) Init(1) Save\n Generate (do not generate) code that uses the XXSPLTIW instruction.\n \n+msplat-float-constant\n+Target Var(TARGET_SPLAT_FLOAT_CONSTANT) Init(1) Save\n+Generate (do not generate) code that uses the XXSPLTIDP instruction.\n+\n mieee128-constant\n Target Var(TARGET_IEEE128_CONSTANT) Init(1) Save\n Generate (do not generate) code that uses the LXVKQ instruction."}, {"sha": "dcb30e1d8865eee19cb57f1d9b9ade9dbc364504", "filename": "gcc/testsuite/gcc.target/powerpc/pr86731-fwrapv-longlong.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731-fwrapv-longlong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731-fwrapv-longlong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731-fwrapv-longlong.c?ref=8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5", "patch": "@@ -24,11 +24,12 @@ vector signed long long splats4(void)\n         return (vector signed long long) vec_sl(mzero, mzero);\n }\n \n-/* Codegen will consist of splat and shift instructions for most types.\n-   If folding is enabled, the vec_sl tests using vector long long type will\n-   generate a lvx instead of a vspltisw+vsld pair.  */\n+/* Codegen will consist of splat and shift instructions for most types.  If\n+   folding is enabled, the vec_sl tests using vector long long type will\n+   generate a lvx instead of a vspltisw+vsld pair.  On power10, it will\n+   generate a xxspltidp instruction instead of the lvx.  */\n \n /* { dg-final { scan-assembler-times {\\mvspltis[bhw]\\M} 0 } } */\n /* { dg-final { scan-assembler-times {\\mvsl[bhwd]\\M} 0 } } */\n-/* { dg-final { scan-assembler-times {\\mp?lxv\\M|\\mlxv\\M|\\mlxvd2x\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mp?lxv\\M|\\mlxv\\M|\\mlxvd2x\\M|\\mxxspltidp\\M} 2 } } */\n "}, {"sha": "82ffc86f8aaf322e887bcf3625ea71ec8fd07f0a", "filename": "gcc/testsuite/gcc.target/powerpc/vec-splat-constant-v2df.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-v2df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-v2df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-v2df.c?ref=8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+#include <math.h>\n+\n+/* Test generating V2DFmode constants with the ISA 3.1 (power10) XXSPLTIDP\n+   instruction.  */\n+\n+vector double\n+v2df_double_0 (void)\n+{\n+  return (vector double) { 0.0, 0.0 };\t\t\t/* XXSPLTIB or XXLXOR.  */\n+}\n+\n+vector double\n+v2df_double_1 (void)\n+{\n+  return (vector double) { 1.0, 1.0 };\t\t\t/* XXSPLTIDP.  */\n+}\n+\n+#ifndef __FAST_MATH__\n+vector double\n+v2df_double_m0 (void)\n+{\n+  return (vector double) { -0.0, -0.0 };\t\t/* XXSPLTIDP.  */\n+}\n+\n+vector double\n+v2df_double_nan (void)\n+{\n+  return (vector double) { __builtin_nan (\"\"),\n+\t\t\t   __builtin_nan (\"\") };\t/* XXSPLTIDP.  */\n+}\n+\n+vector double\n+v2df_double_inf (void)\n+{\n+  return (vector double) { __builtin_inf (),\n+\t\t\t   __builtin_inf () };\t\t/* XXSPLTIDP.  */\n+}\n+\n+vector double\n+v2df_double_m_inf (void)\n+{\n+  return (vector double) { - __builtin_inf (),\n+\t\t\t   - __builtin_inf () };\t/* XXSPLTIDP.  */\n+}\n+#endif\n+\n+vector double\n+v2df_double_pi (void)\n+{\n+  return (vector double) { M_PI, M_PI };\t\t/* PLVX.  */\n+}\n+\n+vector double\n+v2df_double_denorm (void)\n+{\n+  return (vector double) { (double)0x1p-149f,\n+\t\t\t   (double)0x1p-149f };\t\t/* PLVX.  */\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxspltidp\\M} 5 } } */"}, {"sha": "4d44f943d266b03d4cbc3e9c408f4805e6fa7f3f", "filename": "gcc/testsuite/gcc.target/powerpc/vec-splat-constant-v2di.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-v2di.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-v2di.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvec-splat-constant-v2di.c?ref=8d443ac032ecf0d8275bb0f6838ed7c9aee4e7a5", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+/* Test generating V2DImode constants that have the same bit pattern as\n+   V2DFmode constants that can be loaded with the XXSPLTIDP instruction with\n+   the ISA 3.1 (power10).  */\n+\n+vector long long\n+vector_0 (void)\n+{\n+  /* XXSPLTIB or XXLXOR.  */\n+  return (vector long long) { 0LL, 0LL };\n+}\n+\n+vector long long\n+vector_1 (void)\n+{\n+  /* XXSPLTIB and VEXTSB2D.  */\n+  return (vector long long) { 1LL, 1LL };\n+}\n+\n+/* 0x8000000000000000LL is the bit pattern for -0.0, which can be generated\n+   with XXSPLTISDP.  */\n+vector long long\n+vector_float_neg_0 (void)\n+{\n+  /* XXSPLTIDP.  */\n+  return (vector long long) { 0x8000000000000000LL, 0x8000000000000000LL };\n+}\n+\n+/* 0x3ff0000000000000LL is the bit pattern for 1.0 which can be generated with\n+   XXSPLTISDP.  */\n+vector long long\n+vector_float_1_0 (void)\n+{\n+  /* XXSPLTIDP.  */\n+  return (vector long long) { 0x3ff0000000000000LL, 0x3ff0000000000000LL };\n+}\n+\n+/* 0x400921fb54442d18LL is the bit pattern for PI, which cannot be generated\n+   with XXSPLTIDP.  */\n+vector long long\n+scalar_pi (void)\n+{\n+  /* PLXV.  */\n+  return (vector long long) { 0x400921fb54442d18LL, 0x400921fb54442d18LL };\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxxspltidp\\M} 2 } } */"}]}