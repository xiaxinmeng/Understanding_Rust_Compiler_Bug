{"sha": "04077c530d2a43a9a16710dca096a14a2d8b9a8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQwNzdjNTMwZDJhNDNhOWExNjcxMGRjYTA5NmExNGEyZDhiOWE4Yw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-05T19:41:17Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-05T19:41:17Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1443", "tree": {"sha": "9ddc326136cdd252e39a8986ed57df7fa715331f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ddc326136cdd252e39a8986ed57df7fa715331f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04077c530d2a43a9a16710dca096a14a2d8b9a8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04077c530d2a43a9a16710dca096a14a2d8b9a8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04077c530d2a43a9a16710dca096a14a2d8b9a8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04077c530d2a43a9a16710dca096a14a2d8b9a8c/comments", "author": null, "committer": null, "parents": [{"sha": "c767f54b88953760289ecb529621e91c4247e3db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c767f54b88953760289ecb529621e91c4247e3db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c767f54b88953760289ecb529621e91c4247e3db"}], "stats": {"total": 110, "additions": 102, "deletions": 8}, "files": [{"sha": "92978ac5a84565bd9ed994217ad2a883fbe647a3", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 102, "deletions": 8, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04077c530d2a43a9a16710dca096a14a2d8b9a8c/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04077c530d2a43a9a16710dca096a14a2d8b9a8c/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=04077c530d2a43a9a16710dca096a14a2d8b9a8c", "patch": "@@ -537,6 +537,9 @@ static unsigned lookup_filename ();\n #ifndef TYPE_NAME_FMT\n #define TYPE_NAME_FMT\t\t\".L_T%u\"\n #endif\n+#ifndef DECL_NAME_FMT\n+#define DECL_NAME_FMT\t\t\".L_E%u\"\n+#endif\n #ifndef LINE_CODE_LABEL_FMT\n #define LINE_CODE_LABEL_FMT\t\".L_LC%u\"\n #endif\n@@ -798,7 +801,7 @@ dwarf_tag_name (tag)\n     case TAG_function_template:\t\treturn \"TAG_function_template\";\n     case TAG_class_template:\t\treturn \"TAG_class_template\";\n \n-    default:\t\t\t\treturn \"<unknown tag>\";\n+    default:\t\t\t\treturn \"TAG_<unknown>\";\n     }\n }\n \n@@ -858,7 +861,7 @@ dwarf_attr_name (attr)\n     case AT_public:\t\t\treturn \"AT_public\";\n     case AT_pure_virtual:\t\treturn \"AT_pure_virtual\";\n     case AT_return_addr:\t\treturn \"AT_return_addr\";\n-    case AT_specification:\t\treturn \"AT_specification\";\n+    case AT_abstract_origin:\t\treturn \"AT_abstract_origin\";\n     case AT_start_scope:\t\treturn \"AT_start_scope\";\n     case AT_stride_size:\t\treturn \"AT_stride_size\";\n     case AT_upper_bound_ref:\t\treturn \"AT_upper_bound_ref\";\n@@ -874,7 +877,7 @@ dwarf_attr_name (attr)\n     case AT_mac_info:\t\t\treturn \"AT_mac_info\";\n     case AT_src_coords:\t\t\treturn \"AT_src_coords\";\n \n-    default:\t\t\t\treturn \"<unknown attribute>\";\n+    default:\t\t\t\treturn \"AT_<unknown>\";\n     }\n }\n \n@@ -891,7 +894,7 @@ dwarf_stack_op_name (op)\n     case OP_DEREF2:\t\treturn \"OP_DEREF2\";\n     case OP_DEREF4:\t\treturn \"OP_DEREF4\";\n     case OP_ADD:\t\treturn \"OP_ADD\";\n-    default:\t\t\treturn \"<unknown stack operator>\";\n+    default:\t\t\treturn \"OP_<unknown>\";\n     }\n }\n \n@@ -905,7 +908,7 @@ dwarf_typemod_name (mod)\n     case MOD_reference_to:\treturn \"MOD_reference_to\";\n     case MOD_const:\t\treturn \"MOD_const\";\n     case MOD_volatile:\t\treturn \"MOD_volatile\";\n-    default:\t\t\treturn \"<unknown modifier>\";\n+    default:\t\t\treturn \"MOD_<unknown>\";\n     }\n }\n \n@@ -924,7 +927,7 @@ dwarf_fmt_byte_name (fmt)\n     case FMT_UT_X_C:\treturn \"FMT_UT_X_C\";\n     case FMT_UT_X_X:\treturn \"FMT_UT_X_X\";\n     case FMT_ET:\treturn \"FMT_ET\";\n-    default:\t\treturn \"<unknown array bound format byte>\";\n+    default:\t\treturn \"FMT_<unknown>\";\n     }\n }\n static char *\n@@ -986,6 +989,26 @@ dwarf_fund_type_name (ft)\n \f\n /**************** utility functions for attribute functions ******************/\n \n+/* Given a pointer to a BLOCK node return non-zero if (and only if) the\n+   node in question represents the outermost block (i.e. the \"body block\")\n+   of a function or method.\n+\n+   For any BLOCK node representing a \"body block\", the BLOCK_SUPERCONTEXT\n+   of the node will point to another BLOCK node which represents the outer-\n+   most (function) scope for the function or method.  The BLOCK_SUPERCONTEXT\n+   of that node in turn will point to the relevant FUNCTION_DECL node.\n+*/\n+\n+inline int\n+is_body_block (stmt)\n+     register tree stmt;\n+{\n+  register enum tree_code code\n+    = TREE_CODE (BLOCK_SUPERCONTEXT (BLOCK_SUPERCONTEXT (stmt)));\n+\n+  return (code == FUNCTION_DECL);\n+}\n+\n /* Given a pointer to a tree node for some type, return a Dwarf fundamental\n    type code for the given type.\n \n@@ -1228,9 +1251,40 @@ type_is_fundamental (type)\n   return 0;\n }\n \n+/* Given a pointer to some ..._DECL tree node, generate an assembly language\n+   equate directive which will associate a symbolic name with the current DIE.\n+\n+   The name used is an artificial label generated from the DECL_UID number\n+   associated with the given decl node.  The name it gets equated to is the\n+   symbolic label that we (previously) output at the start of the DIE that\n+   we are currently generating.\n+\n+   Calling this function while generating some \"decl related\" form of DIE\n+   makes it possible to later refer to the DIE which represents the given\n+   decl simply by re-generating the symbolic name from the ..._DECL node's\n+   UID number.\t*/\n+\n+static void\n+equate_decl_number_to_die_number (decl)\n+     register tree decl;\n+{\n+  /* In the case where we are generating a DIE for some ..._DECL node\n+     which represents either some inline function declaration or some\n+     entity declared within an inline function declaration/definition,\n+     setup a symbolic name for the current DIE so that we have a name\n+     for this DIE that we can easily refer to later on within\n+     AT_abstract_origin attributes.  */\n+\n+  char decl_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+  char die_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+  sprintf (decl_label, DECL_NAME_FMT, DECL_UID (decl));\n+  sprintf (die_label, DIE_BEGIN_LABEL_FMT, current_dienum);\n+  ASM_OUTPUT_DEF (asm_out_file, decl_label, die_label);\n+}\n+\n /* Given a pointer to some ..._TYPE tree node, generate an assembly language\n-   equate directive which will associate an easily remembered symbolic name\n-   with the current DIE.\n+   equate directive which will associate a symbolic name with the current DIE.\n \n    The name used is an artificial label generated from the TYPE_UID number\n    associated with the given type node.  The name it gets equated to is the\n@@ -2371,6 +2425,31 @@ containing_type_attribute (containing_type)\n   ASM_OUTPUT_DWARF_REF (asm_out_file, label);\n }\n \n+inline void\n+abstract_origin_attribute (origin)\n+     register tree origin;\n+{\n+  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+  ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_abstract_origin);\n+  switch (TREE_CODE_CLASS (TREE_CODE (origin)))\n+    {\n+    case 'd':\n+      sprintf (label, DECL_NAME_FMT, DECL_UID (origin));\n+      break;\n+\n+    case 't':\n+      sprintf (label, TYPE_NAME_FMT, TYPE_UID (origin));\n+      break;\n+\n+    default:\n+      abort ();\t\t/* Should never happen.  */\n+\n+    }\n+  ASM_OUTPUT_DWARF_REF (asm_out_file, label);\n+}\n+\n+#ifdef DWARF_DECL_COORDINATES\n inline void\n src_coords_attribute (src_fileno, src_lineno)\n      register unsigned src_fileno;\n@@ -2380,6 +2459,21 @@ src_coords_attribute (src_fileno, src_lineno)\n   ASM_OUTPUT_DWARF_DATA2 (asm_out_file, src_fileno);\n   ASM_OUTPUT_DWARF_DATA2 (asm_out_file, src_lineno);\n }\n+#endif /* defined(DWARF_DECL_COORDINATES) */\n+\n+inline void\n+pure_or_virtual_attribute (func_decl)\n+     register tree func_decl;\n+{\n+  if (DECL_VIRTUAL_P (func_decl))\n+    {\n+      if (DECL_ABSTRACT_VIRTUAL_P (func_decl))\n+        ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_pure_virtual);\n+      else\n+        ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_virtual);\n+      ASM_OUTPUT_DWARF_STRING (asm_out_file, \"\");\n+    }\n+}\n \n /************************* end of attributes *****************************/\n "}]}