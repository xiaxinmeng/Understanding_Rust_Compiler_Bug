{"sha": "aeedc93fbae3f9aa761121167020569b65fb01d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVlZGM5M2ZiYWUzZjlhYTc2MTEyMTE2NzAyMDU2OWI2NWZiMDFkOQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-18T19:40:49Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-18T19:40:49Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r779", "tree": {"sha": "f5013dec08b4c937d6c6aa7c98083612b3bb26bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5013dec08b4c937d6c6aa7c98083612b3bb26bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aeedc93fbae3f9aa761121167020569b65fb01d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeedc93fbae3f9aa761121167020569b65fb01d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aeedc93fbae3f9aa761121167020569b65fb01d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeedc93fbae3f9aa761121167020569b65fb01d9/comments", "author": null, "committer": null, "parents": [{"sha": "19c98942d885cae75f270e5cc2545a4a5daa1c4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19c98942d885cae75f270e5cc2545a4a5daa1c4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19c98942d885cae75f270e5cc2545a4a5daa1c4a"}], "stats": {"total": 34, "additions": 19, "deletions": 15}, "files": [{"sha": "4b0f77daa6a0ce342167ed086f024ffb89085349", "filename": "gcc/expmed.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeedc93fbae3f9aa761121167020569b65fb01d9/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeedc93fbae3f9aa761121167020569b65fb01d9/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=aeedc93fbae3f9aa761121167020569b65fb01d9", "patch": "@@ -66,26 +66,26 @@ init_expmed ()\n   rtx lea;\n   int i, dummy;\n \n-  add_cost = rtx_cost (gen_rtx (PLUS, word_mode, reg, reg));\n+  add_cost = rtx_cost (gen_rtx (PLUS, word_mode, reg, reg), SET);\n   shift_cost = rtx_cost (gen_rtx (LSHIFT, word_mode, reg,\n \t\t\t\t  /* Using a constant gives better\n \t\t\t\t     estimate of typical costs.\n \t\t\t\t     1 or 2 might have quirks.  */\n-\t\t\t\t  gen_rtx (CONST_INT, VOIDmode, 3)));\n-  mult_cost = rtx_cost (gen_rtx (MULT, word_mode, reg, reg));\n-  negate_cost = rtx_cost (gen_rtx (NEG, word_mode, reg));\n+\t\t\t\t  gen_rtx (CONST_INT, VOIDmode, 3)), SET);\n+  mult_cost = rtx_cost (gen_rtx (MULT, word_mode, reg, reg), SET);\n+  negate_cost = rtx_cost (gen_rtx (NEG, word_mode, reg), SET);\n \n   /* 999999 is chosen to avoid any plausible faster special case.  */\n   mult_is_very_cheap\n     = (rtx_cost (gen_rtx (MULT, word_mode, reg,\n-\t\t\t  gen_rtx (CONST_INT, VOIDmode, 999999)))\n+\t\t\t  gen_rtx (CONST_INT, VOIDmode, 999999)), SET)\n        < rtx_cost (gen_rtx (LSHIFT, word_mode, reg,\n-\t\t\t    gen_rtx (CONST_INT, VOIDmode, 7))));\n+\t\t\t    gen_rtx (CONST_INT, VOIDmode, 7)), SET));\n \n   sdiv_pow2_cheap\n-    = rtx_cost (gen_rtx (DIV, word_mode, reg, pow2)) <= 2 * add_cost;\n+    = rtx_cost (gen_rtx (DIV, word_mode, reg, pow2), SET) <= 2 * add_cost;\n   smod_pow2_cheap\n-    = rtx_cost (gen_rtx (MOD, word_mode, reg, pow2)) <= 2 * add_cost;\n+    = rtx_cost (gen_rtx (MOD, word_mode, reg, pow2), SET) <= 2 * add_cost;\n \n   init_recog ();\n   for (i = 2;; i <<= 1)\n@@ -100,7 +100,7 @@ init_expmed ()\n       if (recog (lea, 0, &dummy) < 0)\n \tbreak;\n       lea_max_mul = i;\n-      lea_cost = rtx_cost (SET_SRC (lea));\n+      lea_cost = rtx_cost (SET_SRC (lea), SET);\n     }\n \n   /* Free the objects we just allocated.  */"}, {"sha": "7640c4f2d62852b14d34d85c19e6f9239f149e09", "filename": "gcc/optabs.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeedc93fbae3f9aa761121167020569b65fb01d9/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeedc93fbae3f9aa761121167020569b65fb01d9/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=aeedc93fbae3f9aa761121167020569b65fb01d9", "patch": "@@ -229,10 +229,12 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n   /* If we are inside an appropriately-short loop and one operand is an\n      expensive constant, force it into a register.  */\n-  if (CONSTANT_P (op0) && preserve_subexpressions_p () && rtx_cost (op0) > 2)\n+  if (CONSTANT_P (op0) && preserve_subexpressions_p ()\n+      && rtx_cost (op0, binoptab->code) > 2)\n     op0 = force_reg (mode, op0);\n \n-  if (CONSTANT_P (op1) && preserve_subexpressions_p () && rtx_cost (op1) > 2)\n+  if (CONSTANT_P (op1) && preserve_subexpressions_p ()\n+      && rtx_cost (op1, binoptab->code) > 2)\n     op1 = force_reg (shift_op ? word_mode : mode, op1);\n \n #if 0  /* Turned off because it seems to be a kludgy method.  */\n@@ -871,10 +873,12 @@ expand_twoval_binop (binoptab, op0, op1, targ0, targ1, unsignedp)\n \n   /* If we are inside an appropriately-short loop and one operand is an\n      expensive constant, force it into a register.  */\n-  if (CONSTANT_P (op0) && preserve_subexpressions_p () && rtx_cost (op0) > 2)\n+  if (CONSTANT_P (op0) && preserve_subexpressions_p ()\n+      && rtx_cost (op0, binoptab->code) > 2)\n     op0 = force_reg (mode, op0);\n \n-  if (CONSTANT_P (op1) && preserve_subexpressions_p () && rtx_cost (op1) > 2)\n+  if (CONSTANT_P (op1) && preserve_subexpressions_p ()\n+      && rtx_cost (op1, binoptab->code) > 2)\n     op1 = force_reg (mode, op1);\n \n   if (targ0)\n@@ -1450,10 +1454,10 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n \n   /* If we are inside an appropriately-short loop and one operand is an\n      expensive constant, force it into a register.  */\n-  if (CONSTANT_P (x) && preserve_subexpressions_p () && rtx_cost (x) > 2)\n+  if (CONSTANT_P (x) && preserve_subexpressions_p () && rtx_cost (x, COMPARE) > 2)\n     x = force_reg (mode, x);\n \n-  if (CONSTANT_P (y) && preserve_subexpressions_p () && rtx_cost (y) > 2)\n+  if (CONSTANT_P (y) && preserve_subexpressions_p () && rtx_cost (y, COMPARE) > 2)\n     y = force_reg (mode, y);\n \n   /* Don't let both operands fail to indicate the mode.  */"}]}