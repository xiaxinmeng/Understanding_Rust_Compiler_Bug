{"sha": "79802c5dcc043a515f429bb2bec7573b8537c32a", "node_id": "C_kwDOANBUbNoAKDc5ODAyYzVkY2MwNDNhNTE1ZjQyOWJiMmJlYzc1NzNiODUzN2MzMmE", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-09-28T14:02:04Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-10-15T20:12:56Z"}, "message": "c++: array cv-quals and template specialization [PR101402]\n\nPRs 101402, 102033, etc. demonstrated that the fix for PR92010 wasn't\nhandling all cases of the CWG1001/1322 issue with parameter type qual\nstripping and arrays with templates.  The problem turned out to be in\ndetermine_specialization, which did an extra substitution without the 92010\nfix and then complained that the result didn't match.\n\nBut just removing that wrong/redundant code meant that we were accepting\nspecializations with different numbers of parameters, because the code in\nfn_type_unification that compares types in this case wasn't checking for\nlength mismatch.\n\nAfter fixing that, I realized that fn_type_unification couldn't tell the\ndifference between variadic and non-variadic function types, because the\nargs array doesn't include the terminal void we use to indicate non-variadic\nfunction type.  So I added it, and made the necessary adjustments.\n\nThanks to qingzhe \"nick\" huang <nickhuang99@hotmail.com> for the patch that\nled me to dig more into this, and the extensive testcases.\n\n\tPR c++/51851\n\tPR c++/101402\n\tPR c++/102033\n\tPR c++/102034\n\tPR c++/102039\n\tPR c++/102044\n\ngcc/cp/ChangeLog:\n\n\t* pt.c (determine_specialization): Remove redundant code.\n\t(fn_type_unification): Check for mismatched length.\n\t(type_unification_real): Ignore terminal void.\n\t(get_bindings): Don't stop at void_list_node.\n\t* class.c (resolve_address_of_overloaded_function): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/template/fnspec2.C: New test.\n\t* g++.dg/template/parm-cv1.C: New test.\n\t* g++.dg/template/parm-cv2.C: New test.\n\t* g++.dg/template/parm-cv3.C: New test.", "tree": {"sha": "71072d90ddd7604362cfd0deecab92e1093116f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71072d90ddd7604362cfd0deecab92e1093116f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79802c5dcc043a515f429bb2bec7573b8537c32a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79802c5dcc043a515f429bb2bec7573b8537c32a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79802c5dcc043a515f429bb2bec7573b8537c32a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79802c5dcc043a515f429bb2bec7573b8537c32a/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e819bd95ebeefc1dc469daa1855ce005cb77822", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e819bd95ebeefc1dc469daa1855ce005cb77822", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e819bd95ebeefc1dc469daa1855ce005cb77822"}], "stats": {"total": 221, "additions": 204, "deletions": 17}, "files": [{"sha": "f16e50b9de9d7dba8ebfffbdaf69365cbb09ff2c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79802c5dcc043a515f429bb2bec7573b8537c32a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79802c5dcc043a515f429bb2bec7573b8537c32a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=79802c5dcc043a515f429bb2bec7573b8537c32a", "patch": "@@ -8382,7 +8382,7 @@ resolve_address_of_overloaded_function (tree target_type,\n       nargs = list_length (target_arg_types);\n       args = XALLOCAVEC (tree, nargs);\n       for (arg = target_arg_types, ia = 0;\n-\t   arg != NULL_TREE && arg != void_list_node;\n+\t   arg != NULL_TREE;\n \t   arg = TREE_CHAIN (arg), ++ia)\n \targs[ia] = TREE_VALUE (arg);\n       nargs = ia;"}, {"sha": "287cf4ce9d06a009473f90052d3b10e214501332", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79802c5dcc043a515f429bb2bec7573b8537c32a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79802c5dcc043a515f429bb2bec7573b8537c32a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=79802c5dcc043a515f429bb2bec7573b8537c32a", "patch": "@@ -2230,7 +2230,6 @@ determine_specialization (tree template_id,\n \t{\n \t  tree decl_arg_types;\n \t  tree fn_arg_types;\n-\t  tree insttype;\n \n \t  /* In case of explicit specialization, we need to check if\n \t     the number of template headers appearing in the specialization\n@@ -2356,20 +2355,6 @@ determine_specialization (tree template_id,\n \t       template argument.  */\n \t    continue;\n \n-          /* Remove, from the set of candidates, all those functions\n-             whose constraints are not satisfied. */\n-          if (flag_concepts && !constraints_satisfied_p (fn, targs))\n-            continue;\n-\n-          // Then, try to form the new function type.\n-\t  insttype = tsubst (TREE_TYPE (fn), targs, tf_fndecl_type, NULL_TREE);\n-\t  if (insttype == error_mark_node)\n-\t    continue;\n-\t  fn_arg_types\n-\t    = skip_artificial_parms_for (fn, TYPE_ARG_TYPES (insttype));\n-\t  if (!compparms (fn_arg_types, decl_arg_types))\n-\t    continue;\n-\n \t  /* Save this template, and the arguments deduced.  */\n \t  templates = tree_cons (targs, fn, templates);\n \t}\n@@ -21862,6 +21847,15 @@ fn_type_unification (tree fn,\n \t\t\t\t TREE_VALUE (sarg));\n \t    goto fail;\n \t  }\n+      if ((i < nargs || sarg)\n+\t  /* add_candidates uses DEDUCE_EXACT for x.operator foo(), but args\n+\t     doesn't contain the trailing void, and conv fns are always ().  */\n+\t  && !DECL_CONV_FN_P (decl))\n+\t{\n+\t  unsigned nsargs = i + list_length (sarg);\n+\t  unify_arity (explain_p, nargs, nsargs);\n+\t  goto fail;\n+\t}\n     }\n \n   /* After doing deduction with the inherited constructor, actually return an\n@@ -22385,6 +22379,10 @@ type_unification_real (tree tparms,\n   args = xargs;\n   nargs = xnargs;\n \n+  /* Only fn_type_unification cares about terminal void.  */\n+  if (nargs && args[nargs-1] == void_type_node)\n+    --nargs;\n+\n   ia = 0;\n   while (parms && parms != void_list_node\n \t && ia < nargs)\n@@ -24886,7 +24884,7 @@ get_bindings (tree fn, tree decl, tree explicit_args, bool check_rettype)\n   nargs = list_length (decl_arg_types);\n   args = XALLOCAVEC (tree, nargs);\n   for (arg = decl_arg_types, ix = 0;\n-       arg != NULL_TREE && arg != void_list_node;\n+       arg != NULL_TREE;\n        arg = TREE_CHAIN (arg), ++ix)\n     args[ix] = TREE_VALUE (arg);\n "}, {"sha": "7a4b1012d899c37e2e72c6d6649d6596da3e1afc", "filename": "gcc/testsuite/g++.dg/template/fnspec2.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79802c5dcc043a515f429bb2bec7573b8537c32a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffnspec2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79802c5dcc043a515f429bb2bec7573b8537c32a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffnspec2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffnspec2.C?ref=79802c5dcc043a515f429bb2bec7573b8537c32a", "patch": "@@ -0,0 +1,9 @@\n+template <class T>\n+void f(T);\n+\n+template<> void f(int, ...);\t// { dg-error \"match\" }\n+\n+template <class T>\n+void g(T, ...);\n+\n+template<> void g(int);\t\t// { dg-error \"match\" }"}, {"sha": "2677992770d340cc1adcc15143f7166663ead1c9", "filename": "gcc/testsuite/g++.dg/template/parm-cv1.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79802c5dcc043a515f429bb2bec7573b8537c32a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fparm-cv1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79802c5dcc043a515f429bb2bec7573b8537c32a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fparm-cv1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fparm-cv1.C?ref=79802c5dcc043a515f429bb2bec7573b8537c32a", "patch": "@@ -0,0 +1,15 @@\n+// CWG 1001\n+\n+template<class T> struct A {\n+  typedef T arr[3];\n+};\n+\n+template<class T> void f(const typename A<T>::arr) { } // #1\n+\n+template void f<int>(const A<int>::arr);\n+\n+template <class T> struct B {\n+  void g(T);\n+};\n+\n+template <class T> void B<T>::g(const T) { } // #2"}, {"sha": "cd40e8680179f4074da948e7a5ce8d01e69e4816", "filename": "gcc/testsuite/g++.dg/template/parm-cv2.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79802c5dcc043a515f429bb2bec7573b8537c32a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fparm-cv2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79802c5dcc043a515f429bb2bec7573b8537c32a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fparm-cv2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fparm-cv2.C?ref=79802c5dcc043a515f429bb2bec7573b8537c32a", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/51851\n+\n+template<class T>\n+struct A\n+{\n+  typedef double Point[2];\n+  virtual double calculate(const Point point) const = 0;\n+};\n+\n+template<class T>\n+struct B : public A<T>\n+{\n+  virtual double calculate(const typename A<T>::Point point) const\n+  {\n+    return point[0];\n+  }\n+};\n+\n+int main()\n+{\n+  B<int> b;\n+  return 0;\n+}"}, {"sha": "1b69c3b2a48ac9cc0766c6a5192388314c1e8e23", "filename": "gcc/testsuite/g++.dg/template/parm-cv3.C", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79802c5dcc043a515f429bb2bec7573b8537c32a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fparm-cv3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79802c5dcc043a515f429bb2bec7573b8537c32a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fparm-cv3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fparm-cv3.C?ref=79802c5dcc043a515f429bb2bec7573b8537c32a", "patch": "@@ -0,0 +1,142 @@\n+// CWG 1001/1322\n+\n+// PR c++/101402\n+// PR c++/102033\n+// PR c++/102034\n+// PR c++/102039\n+// PR c++/102044\n+\n+namespace test2{\n+template <class T>\n+void f(const T);\n+\n+template<>\n+void f<int[]>(const int*){}\n+}\n+\n+namespace test3{\n+template <class T>\n+struct A{\n+void f(T);\n+};\n+\n+template<class T>\n+void A<T>::f(const T){}\n+\n+template<>\n+void A<int[3]>::f(const int*){}\n+}\n+\n+namespace test4 {\n+template<class TA>\n+struct A{\n+  template<class TB>\n+  struct B{\n+    typedef TB Arr3[3];\n+  };\n+};\n+template<class TA, class TB>\n+void f(const typename A<TA>::template B<TB>::Arr3){}\n+template <>\n+void f<int, char>(const typename A<int>::B<char>::Arr3){}\n+}\n+\n+namespace test5\n+{\n+struct A{\n+  typedef int Arr3[3];\n+};\n+\n+template<class T>\n+void f(const typename T::Arr3){}\n+\n+template<>\n+void f<A>(const int[3]){}\n+}\n+\n+namespace test6\n+{\n+struct A{\n+  typedef int Arr3[3];\n+};\n+template<class T>\n+void f(const typename T::Arr3){}\n+template<>\n+void f<A>(const int*){}\n+}\n+\n+#if __cpp_alias_templates\n+namespace test7\n+{\n+template<class TA>\n+struct A{\n+  template<class TB>\n+  using Type=TB[3];\n+};\n+template<class TA, class TB>\n+void f(const typename A<TA>::template Type<TB>){}\n+template <>\n+void f<int, char>(const typename A<int>::template Type<char>){}\n+}\n+namespace test8\n+{\n+template<class TA>\n+struct A{\n+  template<class TB>\n+  struct B{\n+    using TB_Alias=TB;\n+    template<class TC=TB_Alias>\n+    struct C{\n+      typedef TC Arr3[3];\n+    };\n+  };\n+};\n+template<class TA, class TB>\n+void f(const typename A<TA>::template B<TB>::template C<>::Arr3){}\n+template <>\n+void f<int, char>(const typename A<int>::template B<char>::template C<>::Arr3){}\n+}\n+#endif\n+\n+#if __cpp_decltype\n+namespace test0\n+{\n+template <class T>\n+struct A{\n+  T arr3[3];\n+};\n+template <class T>\n+void f(const decltype(A<T>::arr3)){}\n+template <>\n+void f<int>(const int[3]){}\n+}\n+\n+#if __cpp_variable_templates\n+namespace test9\n+{\n+template<unsigned int N, class T>\n+void f(const T[N]){}\n+\n+template<unsigned int N, class T>\n+using fPtr=decltype(f<N,T>)*;\n+\n+template<unsigned int N, class T>\n+fPtr<N,T> af[N]={&f<N,T>};\n+\n+template<unsigned int N, class T>\n+void g(const decltype(af<N,T>)){}\n+\n+template<>\n+void g<1,int>(const fPtr<1,int>[1]){}\n+}\n+#endif\n+#endif\n+\n+#if __cpp_concepts\n+template<class T>\n+concept IsLambdaAry3=__is_same(T, decltype(+[]{})[3]);\n+template<IsLambdaAry3 T>\n+void bar(const T){}\n+template<>\n+void bar<decltype(+[]{})[3]>(const decltype(+[]{})[3]){}\n+#endif"}]}