{"sha": "92af500d3e3f3ae08792a6e4446356321ec3ae65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJhZjUwMGQzZTNmM2FlMDg3OTJhNmU0NDQ2MzU2MzIxZWMzYWU2NQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-09-11T15:18:52Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-09-11T15:18:52Z"}, "message": "re PR c++/11788 (missing implicit instantiation of static member function)\n\ncp:\n\tPR c++/11788\n\t* typeck.c (build_address): If it is a function, mark it used.\n\t(build_unary_op): Do not lose object's side-effects when taking\n\taddress of static member function.\n\t* class.c (resolve_address_of_overloaded_function): Use\n\ttsubst_flags_t parameter. Only expect overload sets. Adjust.\n\t(instantiate_type): Adjust flags passing. Do not lose object's\n\tside-effects when taking address of static member function.\ntestsuite:\n\tPR c++/11788\n\t* g++.dg/overload/addr1.C: New test.\n\nFrom-SVN: r71304", "tree": {"sha": "b14f1b554715b424610a1a525deb66ce4aeb3b23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b14f1b554715b424610a1a525deb66ce4aeb3b23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92af500d3e3f3ae08792a6e4446356321ec3ae65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92af500d3e3f3ae08792a6e4446356321ec3ae65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92af500d3e3f3ae08792a6e4446356321ec3ae65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92af500d3e3f3ae08792a6e4446356321ec3ae65/comments", "author": null, "committer": null, "parents": [{"sha": "9bdca184d65ece8fb958b736d092e65a72f114d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bdca184d65ece8fb958b736d092e65a72f114d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bdca184d65ece8fb958b736d092e65a72f114d0"}], "stats": {"total": 168, "additions": 121, "deletions": 47}, "files": [{"sha": "2f3461a254c99106d0a87bfe7c4c3850c31e573b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92af500d3e3f3ae08792a6e4446356321ec3ae65/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92af500d3e3f3ae08792a6e4446356321ec3ae65/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=92af500d3e3f3ae08792a6e4446356321ec3ae65", "patch": "@@ -1,3 +1,14 @@\n+2003-09-10  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/11788\n+\t* typeck.c (build_address): If it is a function, mark it used.\n+\t(build_unary_op): Do not lose object's side-effects when taking\n+\taddress of static member function.\n+\t* class.c (resolve_address_of_overloaded_function): Use\n+\ttsubst_flags_t parameter. Only expect overload sets. Adjust.\n+\t(instantiate_type): Adjust flags passing. Do not lose object's\n+\tside-effects when taking address of static member function.\n+\n 2003-09-11  Richard Henderson  <rth@redhat.com>\n \n \t* semantics.c (expand_or_defer_fn): Update for new"}, {"sha": "485e9ad3f6886c9867149fc0c86a44094805a39e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 38, "deletions": 40, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92af500d3e3f3ae08792a6e4446356321ec3ae65/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92af500d3e3f3ae08792a6e4446356321ec3ae65/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=92af500d3e3f3ae08792a6e4446356321ec3ae65", "patch": "@@ -129,8 +129,8 @@ static int method_name_cmp (const void *, const void *);\n static int resort_method_name_cmp (const void *, const void *);\n static void add_implicitly_declared_members (tree, int, int, int);\n static tree fixed_type_or_null (tree, int *, int *);\n-static tree resolve_address_of_overloaded_function (tree, tree, int,\n-\t\t\t\t\t\t\t  int, int, tree);\n+static tree resolve_address_of_overloaded_function (tree, tree, tsubst_flags_t,\n+\t\t\t\t\t\t    bool, tree);\n static tree build_vtbl_ref_1 (tree, tree);\n static tree build_vtbl_initializer (tree, tree, tree, tree, int *);\n static int count_fields (tree);\n@@ -5675,18 +5675,17 @@ pop_lang_context (void)\n \n /* Given an OVERLOAD and a TARGET_TYPE, return the function that\n    matches the TARGET_TYPE.  If there is no satisfactory match, return\n-   error_mark_node, and issue an error message if COMPLAIN is\n-   nonzero.  Permit pointers to member function if PTRMEM is nonzero.\n-   If TEMPLATE_ONLY, the name of the overloaded function\n-   was a template-id, and EXPLICIT_TARGS are the explicitly provided\n+   error_mark_node, and issue a error & warning messages under control\n+   of FLAGS.  Permit pointers to member function if FLAGS permits.  If\n+   TEMPLATE_ONLY, the name of the overloaded function was a\n+   template-id, and EXPLICIT_TARGS are the explicitly provided\n    template arguments.  */\n \n static tree\n resolve_address_of_overloaded_function (tree target_type, \n \t\t\t\t\ttree overload,\n-\t\t\t\t\tint complain,\n-\t                                int ptrmem,\n-\t\t\t\t\tint template_only,\n+\t\t\t\t\ttsubst_flags_t flags,\n+\t\t\t\t\tbool template_only,\n \t\t\t\t\ttree explicit_targs)\n {\n   /* Here's what the standard says:\n@@ -5730,9 +5729,8 @@ resolve_address_of_overloaded_function (tree target_type,\n \t\t\t&& (TREE_CODE (TREE_TYPE (target_type)) \n \t\t\t    == METHOD_TYPE)), 0);\n \n-  if (TREE_CODE (overload) == COMPONENT_REF)\n-    overload = TREE_OPERAND (overload, 1);\n-\n+  my_friendly_assert (is_overloaded_fn (overload), 20030910);\n+  \n   /* Check that the TARGET_TYPE is reasonable.  */\n   if (TYPE_PTRFN_P (target_type))\n     /* This is OK.  */;\n@@ -5748,7 +5746,7 @@ resolve_address_of_overloaded_function (tree target_type,\n     }\n   else \n     {\n-      if (complain)\n+      if (flags & tf_error)\n \terror (\"\\\n cannot resolve overloaded function `%D' based on conversion to type `%T'\", \n \t\t  DECL_NAME (OVL_FUNCTION (overload)), target_type);\n@@ -5842,8 +5840,7 @@ cannot resolve overloaded function `%D' based on conversion to type `%T'\",\n \t    continue;\n \n \t  /* Instantiate the template.  */\n-\t  instantiation = instantiate_template (fn, targs,\n-\t\t\t\t\t\tcomplain ? tf_error : tf_none);\n+\t  instantiation = instantiate_template (fn, targs, flags);\n \t  if (instantiation == error_mark_node)\n \t    /* Instantiation failed.  */\n \t    continue;\n@@ -5873,7 +5870,7 @@ cannot resolve overloaded function `%D' based on conversion to type `%T'\",\n   if (matches == NULL_TREE)\n     {\n       /* There were *no* matches.  */\n-      if (complain)\n+      if (flags & tf_error)\n \t{\n  \t  error (\"no matches converting function `%D' to type `%#T'\", \n \t\t    DECL_NAME (OVL_FUNCTION (overload)),\n@@ -5894,7 +5891,7 @@ cannot resolve overloaded function `%D' based on conversion to type `%T'\",\n     {\n       /* There were too many matches.  */\n \n-      if (complain)\n+      if (flags & tf_error)\n \t{\n \t  tree match;\n \n@@ -5917,11 +5914,11 @@ cannot resolve overloaded function `%D' based on conversion to type `%T'\",\n   fn = TREE_PURPOSE (matches);\n \n   if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)\n-      && !ptrmem && !flag_ms_extensions)\n+      && !(flags & tf_ptrmem_ok) && !flag_ms_extensions)\n     {\n       static int explained;\n       \n-      if (!complain)\n+      if (!(flags & tf_error))\n         return error_mark_node;\n \n       pedwarn (\"assuming pointer to member `%D'\", fn);\n@@ -5948,7 +5945,7 @@ cannot resolve overloaded function `%D' based on conversion to type `%T'\",\n \n /* This function will instantiate the type of the expression given in\n    RHS to match the type of LHSTYPE.  If errors exist, then return\n-   error_mark_node. FLAGS is a bit mask.  If ITF_COMPLAIN is set, then\n+   error_mark_node. FLAGS is a bit mask.  If TF_ERROR is set, then\n    we complain on errors.  If we are not complaining, never modify rhs,\n    as overload resolution wants to try many possible instantiations, in\n    the hope that at least one will work.\n@@ -5959,14 +5956,13 @@ cannot resolve overloaded function `%D' based on conversion to type `%T'\",\n tree\n instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n {\n-  int complain = (flags & tf_error);\n-  int allow_ptrmem = flags & tf_ptrmem_ok;\n+  tsubst_flags_t flags_in = flags;\n   \n   flags &= ~tf_ptrmem_ok;\n   \n   if (TREE_CODE (lhstype) == UNKNOWN_TYPE)\n     {\n-      if (complain)\n+      if (flags & tf_error)\n \terror (\"not enough type information\");\n       return error_mark_node;\n     }\n@@ -5983,7 +5979,7 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n \t;\n       else\n \t{\n-\t  if (complain)\n+\t  if (flags & tf_error)\n \t    error (\"argument of type `%T' does not match `%T'\",\n \t\t   TREE_TYPE (rhs), lhstype);\n \t  return error_mark_node;\n@@ -6034,13 +6030,21 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n       return instantiate_type (lhstype, rhs, flags);\n \n     case COMPONENT_REF:\n-      return instantiate_type (lhstype, TREE_OPERAND (rhs, 1), flags);\n+      {\n+\ttree addr = instantiate_type (lhstype, TREE_OPERAND (rhs, 1), flags);\n+\n+\tif (addr != error_mark_node\n+\t    && TREE_SIDE_EFFECTS (TREE_OPERAND (rhs, 0)))\n+\t  /* Do not lose object's side effects. */\n+\t  addr = build (COMPOUND_EXPR, TREE_TYPE (addr),\n+\t\t\tTREE_OPERAND (rhs, 0), addr);\n+\treturn addr;\n+      }\n \n     case OFFSET_REF:\n       rhs = TREE_OPERAND (rhs, 1);\n       if (BASELINK_P (rhs))\n-\treturn instantiate_type (lhstype, BASELINK_FUNCTIONS (rhs),\n-\t                         flags | allow_ptrmem);\n+\treturn instantiate_type (lhstype, BASELINK_FUNCTIONS (rhs), flags_in);\n \n       /* This can happen if we are forming a pointer-to-member for a\n \t member template.  */\n@@ -6054,22 +6058,16 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n \ttree args = TREE_OPERAND (rhs, 1);\n \n \treturn\n-\t  resolve_address_of_overloaded_function (lhstype,\n-\t\t\t\t\t\t  fns,\n-\t\t\t\t\t\t  complain,\n-\t                                          allow_ptrmem,\n-\t\t\t\t\t\t  /*template_only=*/1,\n+\t  resolve_address_of_overloaded_function (lhstype, fns, flags_in,\n+\t\t\t\t\t\t  /*template_only=*/true,\n \t\t\t\t\t\t  args);\n       }\n \n     case OVERLOAD:\n     case FUNCTION_DECL:\n       return \n-\tresolve_address_of_overloaded_function (lhstype, \n-\t\t\t\t\t\trhs,\n-\t\t\t\t\t\tcomplain,\n-\t                                        allow_ptrmem,\n-\t\t\t\t\t\t/*template_only=*/0,\n+\tresolve_address_of_overloaded_function (lhstype, rhs, flags_in,\n+\t\t\t\t\t\t/*template_only=*/false,\n \t\t\t\t\t\t/*explicit_targs=*/NULL_TREE);\n \n     case TREE_LIST:\n@@ -6131,7 +6129,7 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n     case PREDECREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n-      if (complain)\n+      if (flags & tf_error)\n \terror (\"invalid operation on uninstantiated type\");\n       return error_mark_node;\n \n@@ -6147,14 +6145,14 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_ORIF_EXPR:\n     case TRUTH_NOT_EXPR:\n-      if (complain)\n+      if (flags & tf_error)\n \terror (\"not enough type information\");\n       return error_mark_node;\n \n     case COND_EXPR:\n       if (type_unknown_p (TREE_OPERAND (rhs, 0)))\n \t{\n-\t  if (complain)\n+\t  if (flags & tf_error)\n \t    error (\"not enough type information\");\n \t  return error_mark_node;\n \t}"}, {"sha": "32ec44b46792161b447d88f66ef2777351f5433d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92af500d3e3f3ae08792a6e4446356321ec3ae65/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92af500d3e3f3ae08792a6e4446356321ec3ae65/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=92af500d3e3f3ae08792a6e4446356321ec3ae65", "patch": "@@ -3581,9 +3581,7 @@ build_address (tree t)\n   if (error_operand_p (t) || !cxx_mark_addressable (t))\n     return error_mark_node;\n \n-  addr = build1 (ADDR_EXPR, \n-\t\t build_pointer_type (TREE_TYPE (t)),\n-\t\t t);\n+  addr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (t)), t);\n   if (staticp (t))\n     TREE_CONSTANT (addr) = 1;\n \n@@ -4003,12 +4001,24 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n       {\n \ttree addr;\n \n-\tif (TREE_CODE (arg) == COMPONENT_REF\n-\t    && TREE_CODE (TREE_OPERAND (arg, 1)) == BASELINK)\n-\t  arg = BASELINK_FUNCTIONS (TREE_OPERAND (arg, 1));\n-\n \tif (TREE_CODE (arg) != COMPONENT_REF)\n \t  addr = build_address (arg);\n+\telse if (TREE_CODE (TREE_OPERAND (arg, 1)) == BASELINK)\n+\t  {\n+\t    tree fn = BASELINK_FUNCTIONS (TREE_OPERAND (arg, 1));\n+\n+\t    /* We can only get here with a single static member\n+\t       function.  */\n+\t    my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL\n+\t\t\t\t&& DECL_STATIC_FUNCTION_P (fn),\n+\t\t\t\t20030906);\n+\t    mark_used (fn);\n+\t    addr = build_address (fn);\n+\t    if (TREE_SIDE_EFFECTS (TREE_OPERAND (arg, 0)))\n+\t      /* Do not lose object's side effects.  */\n+\t      addr = build (COMPOUND_EXPR, TREE_TYPE (addr),\n+\t\t\t    TREE_OPERAND (arg, 0), addr);\n+\t  }\n \telse if (DECL_C_BIT_FIELD (TREE_OPERAND (arg, 1)))\n \t  {\n \t    error (\"attempt to take address of bit-field structure member `%D'\","}, {"sha": "4d0d6fe916d51122b7e8088df5f311f61ab6bd62", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92af500d3e3f3ae08792a6e4446356321ec3ae65/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92af500d3e3f3ae08792a6e4446356321ec3ae65/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=92af500d3e3f3ae08792a6e4446356321ec3ae65", "patch": "@@ -1,3 +1,8 @@\n+2003-09-11  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/11788\n+\t* g++.dg/overload/addr1.C: New test.\n+\n 2003-09-10  Ian Lance Taylor  <ian@wasabisystems.com>\n \n \t* gcc.dg/20030909-1.c: New test."}, {"sha": "25856a20fc62382eb65d27b15897460e2548d68b", "filename": "gcc/testsuite/g++.dg/overload/addr1.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92af500d3e3f3ae08792a6e4446356321ec3ae65/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Faddr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92af500d3e3f3ae08792a6e4446356321ec3ae65/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Faddr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Faddr1.C?ref=92af500d3e3f3ae08792a6e4446356321ec3ae65", "patch": "@@ -0,0 +1,50 @@\n+// { dg-do run }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 6 Sep 2003 <nathan@codesourcery.com>\n+// Origin: Volker Reichelt <reichelt@igpm.rwth-aachen.de>\n+\n+// PR c++/11788 we failed to instantiate a decl, and we lost some side\n+// effects\n+\n+static int flag = 0;\n+\n+template <typename> struct A\n+{\n+  A &active ()  { flag++;}\n+  \n+  static void foo() {}\n+\n+  static void bar () {}\n+  static void bar (int) {}\n+\n+  int m;\n+};\n+\n+void (*baz ()) ()\n+{\n+    A<int> a;\n+    return &a.active ().foo;\n+}\n+\n+void (*boz ()) ()\n+{\n+    A<int> a;\n+    return &a.active ().bar;\n+}\n+\n+int *buz ()\n+{\n+  A<int> a;\n+  \n+  return &a.active ().m;\n+}\n+\n+int main ()\n+{\n+  baz ();\n+  boz ();\n+  buz ();\n+  \n+  return flag != 3;\n+}"}]}