{"sha": "ee9609391b6e1bd4d026b86cf79bced76e1baa5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU5NjA5MzkxYjZlMWJkNGQwMjZiODZjZjc5YmNlZDc2ZTFiYWE1Yg==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@act-europe.fr", "date": "2003-05-03T14:25:22Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2003-05-03T14:25:22Z"}, "message": "emit-rtl.c (last_call_insn, [...]): New functions.\n\n\t* emit-rtl.c (last_call_insn, add_function_usage_to): New functions.\n\t* rtl.h (last_call_insn, add_function_usage_to): New prototypes.\n\t* builtins.c (expand_builtin_apply): Use the new emit-rtl functions.\n\t* calls.c (emit_call_1): Likewise.\n\t(expand_call): For calls initializing constant memory, replace\n\temission of standalone mem /u clobber with function usage entry.\n\t* expr.c (emit_block_move_via_libcall): Likewise.\n\t* cse.c (count_reg_usage, case EXPR_LIST): New case.\n\t* flow.c (propagate_one_insn): Pass entire operand of\n\tCALL_INSN_FUNCTION_USAGE to mark_used_regs.\n\t* integrate.c (try_constants): For CALL_INSNs, substitute constants\n\twithin the FUNCTION_USAGE also.\n\t* loop.c (prescan_loop): Note clobbers of const mem mentioned in\n\tFUNCTION_USAGE lists.\n\t* reload1.c (replace_pseudos_in): Renamed.\n\t(reload): Use it for clobbers surviving until the end of the reload.\n\nFrom-SVN: r66429", "tree": {"sha": "7ad4bd29e44c9c37b87311753f154d5fa72e515b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ad4bd29e44c9c37b87311753f154d5fa72e515b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee9609391b6e1bd4d026b86cf79bced76e1baa5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee9609391b6e1bd4d026b86cf79bced76e1baa5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee9609391b6e1bd4d026b86cf79bced76e1baa5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/comments", "author": null, "committer": null, "parents": [{"sha": "3923e4102fcfa593de9148a4855ca54d8466fbe7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3923e4102fcfa593de9148a4855ca54d8466fbe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3923e4102fcfa593de9148a4855ca54d8466fbe7"}], "stats": {"total": 283, "additions": 188, "deletions": 95}, "files": [{"sha": "58469126a53f673004ef10cd92cc69d72bbb1cff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee9609391b6e1bd4d026b86cf79bced76e1baa5b", "patch": "@@ -1,3 +1,22 @@\n+2003-05-03  Olivier Hainque  <hainque@act-europe.fr>\n+\n+\t* emit-rtl.c (last_call_insn, add_function_usage_to): New functions.\n+\t* rtl.h (last_call_insn, add_function_usage_to): New prototypes.\n+\t* builtins.c (expand_builtin_apply): Use the new emit-rtl functions.\n+\t* calls.c (emit_call_1): Likewise.\n+\t(expand_call): For calls initializing constant memory, replace \n+\temission of standalone mem /u clobber with function usage entry.\n+\t* expr.c (emit_block_move_via_libcall): Likewise.\n+\t* cse.c (count_reg_usage, case EXPR_LIST): New case.\n+\t* flow.c (propagate_one_insn): Pass entire operand of\n+\tCALL_INSN_FUNCTION_USAGE to mark_used_regs.\n+\t* integrate.c (try_constants): For CALL_INSNs, substitute constants\n+\twithin the FUNCTION_USAGE also.\n+\t* loop.c (prescan_loop): Note clobbers of const mem mentioned in\n+\tFUNCTION_USAGE lists.\n+\t* reload1.c (replace_pseudos_in): Renamed.\n+\t(reload): Use it for clobbers surviving until the end of the reload.\n+\n 2003-05-03  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* stor-layout.c (place_field): When adjusting offset_align, use"}, {"sha": "969162b892201092923d1b8477088bfa15b8f338", "filename": "gcc/builtins.c", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ee9609391b6e1bd4d026b86cf79bced76e1baa5b", "patch": "@@ -1323,29 +1323,10 @@ expand_builtin_apply (function, arguments, argsize)\n #endif\n     abort ();\n \n-  /* Find the CALL insn we just emitted.  */\n-  for (call_insn = get_last_insn ();\n-       call_insn && GET_CODE (call_insn) != CALL_INSN;\n-       call_insn = PREV_INSN (call_insn))\n-    ;\n-\n-  if (! call_insn)\n-    abort ();\n-\n-  /* Put the register usage information on the CALL.  If there is already\n-     some usage information, put ours at the end.  */\n-  if (CALL_INSN_FUNCTION_USAGE (call_insn))\n-    {\n-      rtx link;\n-\n-      for (link = CALL_INSN_FUNCTION_USAGE (call_insn); XEXP (link, 1) != 0;\n-\t   link = XEXP (link, 1))\n-\t;\n-\n-      XEXP (link, 1) = call_fusage;\n-    }\n-  else\n-    CALL_INSN_FUNCTION_USAGE (call_insn) = call_fusage;\n+  /* Find the CALL insn we just emitted, and attach the register usage\n+     information.  */\n+  call_insn = last_call_insn ();\n+  add_function_usage_to (call_insn, call_fusage);\n \n   /* Restore the stack.  */\n #ifdef HAVE_save_stack_nonlocal"}, {"sha": "70883ee38354cb0b657d36d9a9cec736f0bb6205", "filename": "gcc/calls.c", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=ee9609391b6e1bd4d026b86cf79bced76e1baa5b", "patch": "@@ -536,14 +536,8 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n #endif\n     abort ();\n \n-  /* Find the CALL insn we just emitted.  */\n-  for (call_insn = get_last_insn ();\n-       call_insn && GET_CODE (call_insn) != CALL_INSN;\n-       call_insn = PREV_INSN (call_insn))\n-    ;\n-\n-  if (! call_insn)\n-    abort ();\n+  /* Find the call we just emitted.  */\n+  call_insn = last_call_insn ();\n \n   /* Mark memory as used for \"pure\" function call.  */\n   if (ecf_flags & ECF_PURE)\n@@ -554,20 +548,8 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n \t\t      gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode))),\n \t call_fusage);\n \n-  /* Put the register usage information on the CALL.  If there is already\n-     some usage information, put ours at the end.  */\n-  if (CALL_INSN_FUNCTION_USAGE (call_insn))\n-    {\n-      rtx link;\n-\n-      for (link = CALL_INSN_FUNCTION_USAGE (call_insn); XEXP (link, 1) != 0;\n-\t   link = XEXP (link, 1))\n-\t;\n-\n-      XEXP (link, 1) = call_fusage;\n-    }\n-  else\n-    CALL_INSN_FUNCTION_USAGE (call_insn) = call_fusage;\n+  /* Put the register usage information there.  */\n+  add_function_usage_to (call_insn, call_fusage);\n \n   /* If this is a const call, then set the insn's unchanging bit.  */\n   if (ecf_flags & (ECF_CONST | ECF_PURE))\n@@ -3166,14 +3148,6 @@ expand_call (exp, target, ignore)\n       if (flags & ECF_LONGJMP)\n \tcurrent_function_calls_longjmp = 1;\n \n-      /* If this function is returning into a memory location marked as\n-\t readonly, it means it is initializing that location.  But we normally\n-\t treat functions as not clobbering such locations, so we need to\n-\t specify that this one does.  */\n-      if (target != 0 && GET_CODE (target) == MEM\n-\t  && structure_value_addr != 0 && RTX_UNCHANGING_P (target))\n-\temit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n-\n       /* If value type not void, return an rtx for the value.  */\n \n       /* If there are cleanups to be called, don't use a hard reg as target.\n@@ -3355,6 +3329,22 @@ expand_call (exp, target, ignore)\n \t  expand_end_target_temps ();\n \t}\n \n+      /* If this function is returning into a memory location marked as\n+\t readonly, it means it is initializing that location. We normally treat\n+\t functions as not clobbering such locations, so we need to specify that\n+\t this one does. We do this by adding the appropriate CLOBBER to the\n+\t CALL_INSN function usage list.  This cannot be done by emitting a\n+\t standalone CLOBBER after the call because the latter would be ignored\n+\t by at least the delay slot scheduling pass. We do this now instead of\n+\t adding to call_fusage before the call to emit_call_1 because TARGET\n+\t may be modified in the meantime.  */\n+      if (structure_value_addr != 0 && target != 0 \n+\t  && GET_CODE (target) == MEM && RTX_UNCHANGING_P (target))\n+\tadd_function_usage_to\n+\t  (last_call_insn (),\n+\t   gen_rtx_EXPR_LIST (VOIDmode, gen_rtx_CLOBBER (VOIDmode, target),\n+\t\t\t      NULL_RTX));\n+      \n       insns = get_insns ();\n       end_sequence ();\n "}, {"sha": "01c583cae075751c5f441639b67a5897b31799a9", "filename": "gcc/cse.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=ee9609391b6e1bd4d026b86cf79bced76e1baa5b", "patch": "@@ -7515,6 +7515,17 @@ count_reg_usage (x, counts, dest, incr)\n         count_reg_usage (XEXP (note, 0), counts, NULL_RTX, incr);\n       return;\n \n+    case EXPR_LIST:\n+      if (REG_NOTE_KIND (x) == REG_EQUAL\n+\t  || (REG_NOTE_KIND (x) != REG_NONNEG && GET_CODE (XEXP (x,0)) == USE)\n+\t  /* FUNCTION_USAGE expression lists may include (CLOBBER (mem /u)),\n+\t     involving registers in the address.  */\n+\t  || GET_CODE (XEXP (x, 0)) == CLOBBER)\n+\tcount_reg_usage (XEXP (x, 0), counts, NULL_RTX, incr);\n+\n+      count_reg_usage (XEXP (x, 1), counts, NULL_RTX, incr);\n+      return;\n+\n     case INSN_LIST:\n       abort ();\n "}, {"sha": "a000551dc2ee16aa53325cb5056c9444ab66b132", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ee9609391b6e1bd4d026b86cf79bced76e1baa5b", "patch": "@@ -3191,6 +3191,22 @@ prev_real_insn (insn)\n   return insn;\n }\n \n+/* Return the last CALL_INSN in the current list, or 0 if there is none.\n+   This routine does not look inside SEQUENCEs.  */\n+\n+rtx\n+last_call_insn ()\n+{\n+  rtx insn;\n+\n+  for (insn = get_last_insn ();\n+       insn && GET_CODE (insn) != CALL_INSN;\n+       insn = PREV_INSN (insn))\n+    ;\n+\n+  return insn;\n+}\n+\n /* Find the next insn after INSN that really does something.  This routine\n    does not look inside SEQUENCEs.  Until reload has completed, this is the\n    same as next_real_insn.  */\n@@ -3850,6 +3866,31 @@ remove_insn (insn)\n     }\n }\n \n+/* Append CALL_FUSAGE to the CALL_INSN_FUNCTION_USAGE for CALL_INSN.  */\n+\n+void\n+add_function_usage_to (call_insn, call_fusage)\n+     rtx call_insn, call_fusage;\n+{\n+  if (! call_insn || GET_CODE (call_insn) != CALL_INSN)\n+    abort ();\n+\n+  /* Put the register usage information on the CALL.  If there is already\n+     some usage information, put ours at the end.  */\n+  if (CALL_INSN_FUNCTION_USAGE (call_insn))\n+    {\n+      rtx link;\n+\n+      for (link = CALL_INSN_FUNCTION_USAGE (call_insn); XEXP (link, 1) != 0;\n+\t   link = XEXP (link, 1))\n+\t;\n+\n+      XEXP (link, 1) = call_fusage;\n+    }\n+  else\n+    CALL_INSN_FUNCTION_USAGE (call_insn) = call_fusage;\n+}\n+\n /* Delete all insns made since FROM.\n    FROM becomes the new last instruction.  */\n "}, {"sha": "b64319a08a70660b3b13840ce0ef0e782a95200f", "filename": "gcc/expr.c", "status": "modified", "additions": 39, "deletions": 27, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ee9609391b6e1bd4d026b86cf79bced76e1baa5b", "patch": "@@ -1839,16 +1839,16 @@ emit_block_move_via_movstr (x, y, size, align)\n      rtx x, y, size;\n      unsigned int align;\n {\n-  /* Try the most limited insn first, because there's no point\n-     including more than one in the machine description unless\n-     the more limited one has some advantage.  */\n-\n   rtx opalign = GEN_INT (align / BITS_PER_UNIT);\n   enum machine_mode mode;\n \n   /* Since this is a move insn, we don't care about volatility.  */\n   volatile_ok = 1;\n \n+  /* Try the most limited insn first, because there's no point\n+     including more than one in the machine description unless\n+     the more limited one has some advantage.  */\n+\n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     {\n@@ -1908,38 +1908,48 @@ static rtx\n emit_block_move_via_libcall (dst, src, size)\n      rtx dst, src, size;\n {\n+  rtx dst_addr, src_addr;\n   tree call_expr, arg_list, fn, src_tree, dst_tree, size_tree;\n   enum machine_mode size_mode;\n   rtx retval;\n \n   /* DST, SRC, or SIZE may have been passed through protect_from_queue.\n \n-     It is unsafe to save the value generated by protect_from_queue\n-     and reuse it later.  Consider what happens if emit_queue is\n-     called before the return value from protect_from_queue is used.\n+     It is unsafe to save the value generated by protect_from_queue and reuse\n+     it later.  Consider what happens if emit_queue is called before the\n+     return value from protect_from_queue is used.\n \n-     Expansion of the CALL_EXPR below will call emit_queue before\n-     we are finished emitting RTL for argument setup.  So if we are\n-     not careful we could get the wrong value for an argument.\n+     Expansion of the CALL_EXPR below will call emit_queue before we are\n+     finished emitting RTL for argument setup.  So if we are not careful we\n+     could get the wrong value for an argument.\n \n-     To avoid this problem we go ahead and emit code to copy X, Y &\n-     SIZE into new pseudos.  We can then place those new pseudos\n-     into an RTL_EXPR and use them later, even after a call to\n+     To avoid this problem we go ahead and emit code to copy the addresses of\n+     DST and SRC and SIZE into new pseudos.  We can then place those new\n+     pseudos into an RTL_EXPR and use them later, even after a call to\n      emit_queue.\n \n-     Note this is not strictly needed for library calls since they\n-     do not call emit_queue before loading their arguments.  However,\n-     we may need to have library calls call emit_queue in the future\n-     since failing to do so could cause problems for targets which\n-     define SMALL_REGISTER_CLASSES and pass arguments in registers.  */\n+     Note this is not strictly needed for library calls since they do not call\n+     emit_queue before loading their arguments.  However, we may need to have\n+     library calls call emit_queue in the future since failing to do so could\n+     cause problems for targets which define SMALL_REGISTER_CLASSES and pass\n+     arguments in registers.  */\n+\n+  dst_addr = copy_to_mode_reg (Pmode, XEXP (dst, 0));\n+  src_addr = copy_to_mode_reg (Pmode, XEXP (src, 0));\n+\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+  dst_addr = convert_memory_address (ptr_mode, dst_addr);\n+  src_addr = convert_memory_address (ptr_mode, src_addr);\n+#endif\n \n-  dst = copy_to_mode_reg (Pmode, XEXP (dst, 0));\n-  src = copy_to_mode_reg (Pmode, XEXP (src, 0));\n+  dst_tree = make_tree (ptr_type_node, dst_addr);\n+  src_tree = make_tree (ptr_type_node, src_addr);\n \n   if (TARGET_MEM_FUNCTIONS)\n     size_mode = TYPE_MODE (sizetype);\n   else\n     size_mode = TYPE_MODE (unsigned_type_node);\n+\n   size = convert_to_mode (size_mode, size, 1);\n   size = copy_to_mode_reg (size_mode, size);\n \n@@ -1951,8 +1961,6 @@ emit_block_move_via_libcall (dst, src, size)\n \n      For convenience, we generate the call to bcopy this way as well.  */\n \n-  dst_tree = make_tree (ptr_type_node, dst);\n-  src_tree = make_tree (ptr_type_node, src);\n   if (TARGET_MEM_FUNCTIONS)\n     size_tree = make_tree (sizetype, size);\n   else\n@@ -1979,13 +1987,17 @@ emit_block_move_via_libcall (dst, src, size)\n \n   retval = expand_expr (call_expr, NULL_RTX, VOIDmode, 0);\n \n-  /* If we are initializing a readonly value, show the above call\n-     clobbered it.  Otherwise, a load from it may erroneously be\n-     hoisted from a loop.  */\n+  /* If we are initializing a readonly value, show the above call clobbered\n+     it. Otherwise, a load from it may erroneously be hoisted from a loop, or\n+     the delay slot scheduler might overlook conflicts and take nasty\n+     decisions.  */\n   if (RTX_UNCHANGING_P (dst))\n-    emit_insn (gen_rtx_CLOBBER (VOIDmode, dst));\n+    add_function_usage_to\n+      (last_call_insn (), gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t     gen_rtx_CLOBBER (VOIDmode, dst),\n+\t\t\t\t\t     NULL_RTX));\n \n-  return (TARGET_MEM_FUNCTIONS ? retval : NULL_RTX);\n+  return TARGET_MEM_FUNCTIONS ? retval : NULL_RTX;\n }\n \n /* A subroutine of emit_block_move_via_libcall.  Create the tree node"}, {"sha": "f2f43204c4bf5c15f300f1da28274ce216f6a5d6", "filename": "gcc/flow.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=ee9609391b6e1bd4d026b86cf79bced76e1baa5b", "patch": "@@ -1832,13 +1832,14 @@ propagate_one_insn (pbi, insn)\n \t  if (GET_CODE (PATTERN (insn)) == COND_EXEC)\n \t    cond = COND_EXEC_TEST (PATTERN (insn));\n \n-\t  /* Calls use their arguments.  */\n+\t  /* Calls use their arguments, and may clobber memory which\n+\t     address involves some register.  */\n \t  for (note = CALL_INSN_FUNCTION_USAGE (insn);\n \t       note;\n \t       note = XEXP (note, 1))\n-\t    if (GET_CODE (XEXP (note, 0)) == USE)\n-\t      mark_used_regs (pbi, XEXP (XEXP (note, 0), 0),\n-\t\t\t      cond, insn);\n+\t    /* We find USE or CLOBBER entities in a FUNCTION_USAGE list: both\n+\t       of which mark_used_regs knows how to handle.  */\n+\t    mark_used_regs (pbi, XEXP (XEXP (note, 0), 0), cond, insn);\n \n \t  /* The stack ptr is used (honorarily) by a CALL insn.  */\n \t  SET_REGNO_REG_SET (pbi->reg_live, STACK_POINTER_REGNUM);"}, {"sha": "0fd108f2b1d861fa019f166674b611b729fcea5d", "filename": "gcc/integrate.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=ee9609391b6e1bd4d026b86cf79bced76e1baa5b", "patch": "@@ -2463,6 +2463,14 @@ try_constants (insn, map)\n   apply_change_group ();\n   subst_constants (&PATTERN (insn), insn, map, 0);\n   apply_change_group ();\n+  \n+  /* Enforce consistency between the addresses in the regular insn flow\n+     and the ones in CALL_INSN_FUNCTION_USAGE lists, if any.  */\n+  if (GET_CODE (insn) == CALL_INSN && CALL_INSN_FUNCTION_USAGE (insn))\n+    {\n+      subst_constants (&CALL_INSN_FUNCTION_USAGE (insn), insn, map, 1);\n+      apply_change_group ();\n+    }\n \n   /* Show we don't know the value of anything stored or clobbered.  */\n   note_stores (PATTERN (insn), mark_stores, NULL);"}, {"sha": "b74d6adc0d9baa0bdf9d8cc1434843e1f2abf0d7", "filename": "gcc/loop.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=ee9609391b6e1bd4d026b86cf79bced76e1baa5b", "patch": "@@ -2575,6 +2575,30 @@ prescan_loop (loop)\n \t  loop_info->has_call = 1;\n \t  if (can_throw_internal (insn))\n \t    loop_info->has_multiple_exit_targets = 1;\n+\n+\t  /* Calls initializing constant objects have CLOBBER of MEM /u in the\n+\t     attached FUNCTION_USAGE expression list, not accounted for by the\n+\t     code above. We should note these to avoid missing dependencies in\n+\t     later references.  */\n+\t  {\n+\t    rtx fusage_entry;\n+\t    \n+\t    for (fusage_entry = CALL_INSN_FUNCTION_USAGE (insn); \n+\t\t fusage_entry; fusage_entry = XEXP (fusage_entry, 1))\n+\t      {\n+\t\trtx fusage = XEXP (fusage_entry, 0);\n+\n+\t\tif (GET_CODE (fusage) == CLOBBER\n+\t\t    && GET_CODE (XEXP (fusage, 0)) == MEM\n+\t\t    && RTX_UNCHANGING_P (XEXP (fusage, 0)))\n+\t\t  {\n+\t\t    note_stores (fusage, note_addr_stored, loop_info);\n+\t\t    if (! loop_info->first_loop_store_insn\n+\t\t\t&& loop_info->store_mems)\n+\t\t      loop_info->first_loop_store_insn = insn;\n+\t\t  }\n+\t      }\n+\t  }\n \t  break;\n \n \tcase JUMP_INSN:"}, {"sha": "792dd467e8949c8bd722d7f1965b07423b959fcb", "filename": "gcc/reload1.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ee9609391b6e1bd4d026b86cf79bced76e1baa5b", "patch": "@@ -369,9 +369,7 @@ static int (*offsets_at)[NUM_ELIMINABLE_REGS];\n \n static int num_labels;\n \f\n-static void replace_pseudos_in_call_usage\tPARAMS ((rtx *,\n-\t\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t\t rtx));\n+static void replace_pseudos_in\tPARAMS ((rtx *, enum machine_mode, rtx));\n static void maybe_fix_stack_asms\tPARAMS ((void));\n static void copy_reloads\t\tPARAMS ((struct insn_chain *));\n static void calculate_needs_all_insns\tPARAMS ((int));\n@@ -583,7 +581,7 @@ compute_use_by_pseudos (to, from)\n    equivalences.  */\n \n static void\n-replace_pseudos_in_call_usage (loc, mem_mode, usage)\n+replace_pseudos_in (loc, mem_mode, usage)\n      rtx *loc;\n      enum machine_mode mem_mode;\n      rtx usage;\n@@ -608,7 +606,7 @@ replace_pseudos_in_call_usage (loc, mem_mode, usage)\n       if (x != *loc)\n \t{\n \t  *loc = x;\n-\t  replace_pseudos_in_call_usage (loc, mem_mode, usage);\n+\t  replace_pseudos_in (loc, mem_mode, usage);\n \t  return;\n \t}\n \n@@ -628,18 +626,18 @@ replace_pseudos_in_call_usage (loc, mem_mode, usage)\n     }\n   else if (code == MEM)\n     {\n-      replace_pseudos_in_call_usage (& XEXP (x, 0), GET_MODE (x), usage);\n+      replace_pseudos_in (& XEXP (x, 0), GET_MODE (x), usage);\n       return;\n     }\n \n   /* Process each of our operands recursively.  */\n   fmt = GET_RTX_FORMAT (code);\n   for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n     if (*fmt == 'e')\n-      replace_pseudos_in_call_usage (&XEXP (x, i), mem_mode, usage);\n+      replace_pseudos_in (&XEXP (x, i), mem_mode, usage);\n     else if (*fmt == 'E')\n       for (j = 0; j < XVECLEN (x, i); j++)\n-\treplace_pseudos_in_call_usage (& XVECEXP (x, i, j), mem_mode, usage);\n+\treplace_pseudos_in (& XVECEXP (x, i, j), mem_mode, usage);\n }\n \n \f\n@@ -1192,9 +1190,8 @@ reload (first, global)\n \trtx *pnote;\n \n \tif (GET_CODE (insn) == CALL_INSN)\n-\t  replace_pseudos_in_call_usage (& CALL_INSN_FUNCTION_USAGE (insn),\n-\t\t\t\t\t VOIDmode,\n-\t\t\t\t\t CALL_INSN_FUNCTION_USAGE (insn));\n+\t  replace_pseudos_in (& CALL_INSN_FUNCTION_USAGE (insn),\n+\t\t\t      VOIDmode, CALL_INSN_FUNCTION_USAGE (insn));\n \n \tif ((GET_CODE (PATTERN (insn)) == USE\n \t     /* We mark with QImode USEs introduced by reload itself.  */\n@@ -1213,6 +1210,13 @@ reload (first, global)\n \t    continue;\n \t  }\n \n+\t/* Some CLOBBERs may survive until here and still reference unassigned\n+\t   pseudos with const equivalent, which may in turn cause ICE in later\n+\t   passes if the reference remains in place.  */\n+\tif (GET_CODE (PATTERN (insn)) == CLOBBER)\n+\t  replace_pseudos_in (& XEXP (PATTERN (insn), 0),\n+\t\t\t      VOIDmode, PATTERN (insn));\n+\n \tpnote = &REG_NOTES (insn);\n \twhile (*pnote != 0)\n \t  {"}, {"sha": "bc6f3929298bc1d096cfbd3a9bfaaf1cbf6e0918", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9609391b6e1bd4d026b86cf79bced76e1baa5b/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ee9609391b6e1bd4d026b86cf79bced76e1baa5b", "patch": "@@ -1538,6 +1538,8 @@ extern rtx emit_line_note\t\tPARAMS ((const char *, int));\n extern rtx emit_note\t\t\tPARAMS ((const char *, int));\n extern rtx emit_line_note_force\t\tPARAMS ((const char *, int));\n extern rtx make_insn_raw\t\tPARAMS ((rtx));\n+extern void add_function_usage_to       PARAMS ((rtx, rtx));\n+extern rtx last_call_insn               PARAMS ((void));\n extern rtx previous_insn\t\tPARAMS ((rtx));\n extern rtx next_insn\t\t\tPARAMS ((rtx));\n extern rtx prev_nonnote_insn\t\tPARAMS ((rtx));"}]}