{"sha": "d190d56b7e7921a58656cded35fe4722c57c9bb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE5MGQ1NmI3ZTc5MjFhNTg2NTZjZGVkMzVmZTQ3MjJjNTdjOWJiOA==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@au.ibm.com", "date": "2006-01-18T00:39:23Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2006-01-18T00:39:23Z"}, "message": "Makefile.in (D32PBIT_FUNCS): New.\n\n\t* Makefile.in (D32PBIT_FUNCS): New.\n\t(D64PBIT_FUNCS, D128PBIT_FUNCS): Likewise.\n\t(libgcc.mk): Set D32PBIT, D64PBIT, D128PBIT, D32PBIT_FUNCS,\n\tD64PBIT_FUNCS and D128PBIT_FUNCS.\n\t(LIBGCC_DEPS): Include $(D32PBIT), $(D64PBIT), $(D128PBIT).\n\t* mklibgcc.in Bring in the DFP support code if D32PBIT, D64PBIT or\n\tD128PBIT are set.\n\t(decnumber_dep): Define.\n\t* doc/libgcc.texi (Decimal float library routines): New node.\n\t* config/dfp-bit.h, config/dfp-bit.c: New files.\n\nFrom-SVN: r109856", "tree": {"sha": "a4e9f0e450527bbfd03032f71afeae530de8a991", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4e9f0e450527bbfd03032f71afeae530de8a991"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d190d56b7e7921a58656cded35fe4722c57c9bb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d190d56b7e7921a58656cded35fe4722c57c9bb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d190d56b7e7921a58656cded35fe4722c57c9bb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d190d56b7e7921a58656cded35fe4722c57c9bb8/comments", "author": null, "committer": null, "parents": [{"sha": "242f8e90d075b38403a00fe30a3610aa8df60701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/242f8e90d075b38403a00fe30a3610aa8df60701", "html_url": "https://github.com/Rust-GCC/gccrs/commit/242f8e90d075b38403a00fe30a3610aa8df60701"}], "stats": {"total": 1350, "additions": 1350, "deletions": 0}, "files": [{"sha": "a096147bf73ac3fb789f87047dbf23d9bcff2af1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d190d56b7e7921a58656cded35fe4722c57c9bb8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d190d56b7e7921a58656cded35fe4722c57c9bb8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d190d56b7e7921a58656cded35fe4722c57c9bb8", "patch": "@@ -1,3 +1,16 @@\n+2006-01-18  Ben Elliston  <bje@au.ibm.com>\t\n+\n+\t* Makefile.in (D32PBIT_FUNCS): New.\n+\t(D64PBIT_FUNCS, D128PBIT_FUNCS): Likewise.\n+\t(libgcc.mk): Set D32PBIT, D64PBIT, D128PBIT, D32PBIT_FUNCS,\n+\tD64PBIT_FUNCS and D128PBIT_FUNCS.\n+\t(LIBGCC_DEPS): Include $(D32PBIT), $(D64PBIT), $(D128PBIT).\n+\t* mklibgcc.in Bring in the DFP support code if D32PBIT, D64PBIT or\n+\tD128PBIT are set.\n+\t(decnumber_dep): Define.\n+\t* doc/libgcc.texi (Decimal float library routines): New node.\n+\t* config/dfp-bit.h, config/dfp-bit.c: New files.\n+\n 2006-01-18  Ben Elliston  <bje@au.ibm.com>\t\n \n \t* expr.c (emit_move_change_mode): Always adjust addresses, not"}, {"sha": "a993f971eebfaf760427d050733180c2045e8ed1", "filename": "gcc/Makefile.in", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d190d56b7e7921a58656cded35fe4722c57c9bb8/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d190d56b7e7921a58656cded35fe4722c57c9bb8/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d190d56b7e7921a58656cded35fe4722c57c9bb8", "patch": "@@ -1055,6 +1055,29 @@ TPBIT_FUNCS = _pack_tf _unpack_tf _addsub_tf _mul_tf _div_tf \\\n     _lt_tf _le_tf _unord_tf _si_to_tf _tf_to_si _negate_tf _make_tf \\\n     _tf_to_df _tf_to_sf _thenan_tf _tf_to_usi _usi_to_tf\n \n+D32PBIT_FUNCS = _addsub_sd _div_sd _mul_sd _plus_sd _minus_sd \\\n+\t_eq_sd _ne_sd _lt_sd _gt_sd _le_sd _ge_sd \\\n+\t_sd_to_si _sd_to_di _sd_to_usi _sd_to_udi \\\n+\t_si_to_sd _di_to_sd _usi_to_sd _udi_to_sd \\\n+\t_sd_to_sf _sd_to_df _sd_to_xf _sf_to_sd _df_to_sd _xf_to_sd \\\n+\t_sd_to_dd _sd_to_td _unord_sd _conv_sd\n+\n+D64PBIT_FUNCS = _addsub_dd _div_dd _mul_dd _plus_dd _minus_dd \\\n+\t_eq_dd _ne_dd _lt_dd _gt_dd _le_dd _ge_dd \\\n+\t_dd_to_si _dd_to_di _dd_to_usi _dd_to_udi \\\n+\t_si_to_dd _di_to_dd _usi_to_dd _udi_to_dd \\\n+\t_dd_to_sf _dd_to_df _dd_to_xf \\\n+\t_sf_to_dd _df_to_dd _xf_to_dd \\\n+\t_dd_to_sd _dd_to_td _unord_dd _conv_dd\n+\n+D128PBIT_FUNCS = _addsub_td _div_td _mul_td _plus_td _minus_td \\\n+\t_eq_td _ne_td _lt_td _gt_td _le_td _ge_td \\\n+\t_td_to_si _td_to_di _td_to_usi _td_to_udi \\\n+\t_si_to_td _di_to_td _usi_to_td _udi_to_td \\\n+\t_td_to_sf _td_to_df _td_to_xf \\\n+\t_sf_to_td _df_to_td _xf_to_td \\\n+\t_td_to_sd _td_to_dd _unord_td _conv_td\n+\n # These might cause a divide overflow trap and so are compiled with\n # unwinder info.\n LIB2_DIVMOD_FUNCS = _divdi3 _moddi3 _udivdi3 _umoddi3 _udiv_w_sdiv _udivmoddi4\n@@ -1393,6 +1416,12 @@ libgcc.mk: config.status Makefile mklibgcc $(LIB2ADD) $(LIB2ADD_ST) specs \\\n \tDPBIT_FUNCS='$(DPBIT_FUNCS)' \\\n \tTPBIT='$(TPBIT)' \\\n \tTPBIT_FUNCS='$(TPBIT_FUNCS)' \\\n+\tD32PBIT='$(D32PBIT)' \\\n+\tD32PBIT_FUNCS='$(D32PBIT_FUNCS)' \\\n+\tD64PBIT='$(D64PBIT)' \\\n+\tD64PBIT_FUNCS='$(D64PBIT_FUNCS)' \\\n+\tD128PBIT='$(D128PBIT)' \\\n+\tD128PBIT_FUNCS='$(D128PBIT_FUNCS)' \\\n \tMULTILIBS=`$(GCC_FOR_TARGET) --print-multi-lib` \\\n \tEXTRA_MULTILIB_PARTS='$(EXTRA_MULTILIB_PARTS)' \\\n \tSHLIB_LINK='$(SHLIB_LINK)' \\\n@@ -1415,6 +1444,7 @@ LIBGCC_DEPS = $(GCC_PASSES) $(LANGUAGES) stmp-int-hdrs $(STMP_FIXPROTO) \\\n \tlibgcc.mk $(srcdir)/libgcc2.c $(srcdir)/libgcov.c $(TCONFIG_H) \\\n \t$(MACHMODE_H) longlong.h gbl-ctors.h config.status $(srcdir)/libgcc2.h \\\n \ttsystem.h $(FPBIT) $(DPBIT) $(TPBIT) $(LIB2ADD) \\\n+\t$(D32PBIT) $(D64PBIT) $(D128PBIT) \\\n \t$(LIB2ADD_ST) $(LIB2ADDEH) $(LIB2ADDEHDEP) $(EXTRA_PARTS) \\\n \t$(srcdir)/config/$(LIB1ASMSRC) \\\n \t$(srcdir)/gcov-io.h $(srcdir)/gcov-io.c gcov-iov.h"}, {"sha": "835586b81cec51217a9b69bd5a2690e9be7aff4e", "filename": "gcc/config/dfp-bit.c", "status": "added", "additions": 541, "deletions": 0, "changes": 541, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d190d56b7e7921a58656cded35fe4722c57c9bb8/gcc%2Fconfig%2Fdfp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d190d56b7e7921a58656cded35fe4722c57c9bb8/gcc%2Fconfig%2Fdfp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdfp-bit.c?ref=d190d56b7e7921a58656cded35fe4722c57c9bb8", "patch": "@@ -0,0 +1,541 @@\n+/* This is a software decimal floating point library.\n+   Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/* This implements IEEE 754R decimal floating point arithmetic, but\n+   does not provide a mechanism for setting the rounding mode, or for\n+   generating or handling exceptions.  Conversions between decimal\n+   floating point types and other types depend on C library functions.\n+\n+   Contributed by Ben Elliston  <bje@au.ibm.com>.  */\n+\n+/* The intended way to use this file is to make two copies, add `#define '\n+   to one copy, then compile both copies and add them to libgcc.a.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <limits.h>\n+\n+#include \"config/dfp-bit.h\"\n+\n+/* Forward declarations.  */\n+#if WIDTH == 32 || WIDTH_TO == 32\n+void __host_to_ieee_32 (_Decimal32 in, decimal32 *out);\n+void __ieee_to_host_32 (decimal32 in, _Decimal32 *out);\n+#endif\n+#if WIDTH == 64 || WIDTH_TO == 64\n+void __host_to_ieee_64 (_Decimal64 in, decimal64 *out);\n+void __ieee_to_host_64 (decimal64 in, _Decimal64 *out);\n+#endif\n+#if WIDTH == 128 || WIDTH_TO == 128\n+void __host_to_ieee_128 (_Decimal128 in, decimal128 *out);\n+void __ieee_to_host_128 (decimal128 in, _Decimal128 *out);\n+#endif\n+\n+/* A pointer to a unary decNumber operation.  */\n+typedef decNumber* (*dfp_unary_func)\n+     (decNumber *, decNumber *, decContext *);\n+\n+/* A pointer to a binary decNumber operation.  */\n+typedef decNumber* (*dfp_binary_func)\n+     (decNumber *, decNumber *, decNumber *, decContext *);\n+\n+extern unsigned long __dec_byte_swap (unsigned long);\n+\f\n+/* Unary operations.  */\n+\n+static inline DFP_C_TYPE\n+dfp_unary_op (dfp_unary_func op, DFP_C_TYPE arg)\n+{\n+  DFP_C_TYPE result;\n+  decContext context;\n+  decNumber arg1, res;\n+  IEEE_TYPE a, encoded_result;\n+\n+  HOST_TO_IEEE (arg, &a);\n+\n+  decContextDefault (&context, CONTEXT_INIT);\n+  context.round = CONTEXT_ROUND;\n+\n+  TO_INTERNAL (&a, &arg1);\n+\n+  /* Perform the operation.  */\n+  op (&res, &arg1, &context);\n+\n+  if (CONTEXT_TRAPS && CONTEXT_ERRORS (context))\n+    DFP_RAISE (0);\n+\n+  TO_ENCODED (&encoded_result, &res, &context);\n+  IEEE_TO_HOST (encoded_result, &result);\n+  return result;\n+}\n+\n+/* Binary operations.  */\n+\n+static inline DFP_C_TYPE\n+dfp_binary_op (dfp_binary_func op, DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  DFP_C_TYPE result;\n+  decContext context;\n+  decNumber arg1, arg2, res;\n+  IEEE_TYPE a, b, encoded_result;\n+\n+  HOST_TO_IEEE (arg_a, &a);\n+  HOST_TO_IEEE (arg_b, &b);\n+\n+  decContextDefault (&context, CONTEXT_INIT);\n+  context.round = CONTEXT_ROUND;\n+\n+  TO_INTERNAL (&a, &arg1);\n+  TO_INTERNAL (&b, &arg2);\n+\n+  /* Perform the operation.  */\n+  op (&res, &arg1, &arg2, &context);\n+\n+  if (CONTEXT_TRAPS && CONTEXT_ERRORS (context))\n+    DFP_RAISE (0);\n+\n+  TO_ENCODED (&encoded_result, &res, &context);\n+  IEEE_TO_HOST (encoded_result, &result);\n+  return result;\n+}\n+\n+/* Comparison operations.  */\n+\n+static inline int\n+dfp_compare_op (dfp_binary_func op, DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  IEEE_TYPE a, b;\n+  decContext context;\n+  decNumber arg1, arg2, res;\n+  int result;\n+\n+  HOST_TO_IEEE (arg_a, &a);\n+  HOST_TO_IEEE (arg_b, &b);\n+\n+  decContextDefault (&context, CONTEXT_INIT);\n+  context.round = CONTEXT_ROUND;\n+\n+  TO_INTERNAL (&a, &arg1);\n+  TO_INTERNAL (&b, &arg2);\n+\n+  /* Perform the comparison.  */\n+  op (&res, &arg1, &arg2, &context);\n+\n+  if (CONTEXT_TRAPS && CONTEXT_ERRORS (context))\n+    DFP_RAISE (0);\n+\n+  if (decNumberIsNegative (&res))\n+    result = -1;\n+  else if (decNumberIsZero (&res))\n+    result = 0;\n+  else\n+    result = 1;\n+\n+  return result;\n+}\n+\n+\f\n+#if defined(L_conv_sd)\n+void\n+__host_to_ieee_32 (_Decimal32 in, decimal32 *out)\n+{\n+  uint32_t t;\n+\n+  if (!LIBGCC2_FLOAT_WORDS_BIG_ENDIAN)\n+    {\n+      memcpy (&t, &in, 4);\n+      t = __dec_byte_swap (t);\n+      memcpy (out, &t, 4);\n+    }\n+  else\n+    memcpy (out, &in, 4);\n+}\n+\n+void\n+__ieee_to_host_32 (decimal32 in, _Decimal32 *out)\n+{\n+  uint32_t t;\n+\n+  if (!LIBGCC2_FLOAT_WORDS_BIG_ENDIAN)\n+    {\n+      memcpy (&t, &in, 4);\n+      t = __dec_byte_swap (t);\n+      memcpy (out, &t, 4);\n+    }\n+  else\n+    memcpy (out, &in, 4);\n+}\n+#endif /* L_conv_sd */\n+\n+#if defined(L_conv_dd)\n+static void\n+__swap64 (char *src, char *dst)\n+{\n+  uint32_t t1, t2;\n+\n+  if (!LIBGCC2_FLOAT_WORDS_BIG_ENDIAN) \n+    {\n+      memcpy (&t1, src, 4);\n+      memcpy (&t2, src + 4, 4);\n+      t1 = __dec_byte_swap (t1);\n+      t2 = __dec_byte_swap (t2);\n+      memcpy (dst, &t2, 4);\n+      memcpy (dst + 4, &t1, 4);\n+    }\n+  else\n+    memcpy (dst, src, 8);\n+}\n+\n+void\n+__host_to_ieee_64 (_Decimal64 in, decimal64 *out)\n+{\n+  __swap64 ((char *) &in, (char *) out);\n+}\n+\n+void\n+__ieee_to_host_64 (decimal64 in, _Decimal64 *out)\n+{\n+  __swap64 ((char *) &in, (char *) out);\n+}\n+#endif /* L_conv_dd */\n+\n+#if defined(L_conv_td)\n+static void\n+__swap128 (char *src, char *dst)\n+{\n+  uint32_t t1, t2, t3, t4;\n+\n+  if (!LIBGCC2_FLOAT_WORDS_BIG_ENDIAN)\n+    {\n+      memcpy (&t1, src, 4);\n+      memcpy (&t2, src + 4, 4);\n+      memcpy (&t3, src + 8, 4);\n+      memcpy (&t4, src + 12, 4);\n+      t1 = __dec_byte_swap (t1);\n+      t2 = __dec_byte_swap (t2);\n+      t3 = __dec_byte_swap (t3);\n+      t4 = __dec_byte_swap (t4);\n+      memcpy (dst, &t4, 4);\n+      memcpy (dst + 4, &t3, 4);\n+      memcpy (dst + 8, &t2, 4);\n+      memcpy (dst + 12, &t1, 4);\n+    }\n+  else\n+    memcpy (dst, src, 16);\n+}\n+\n+void\n+__host_to_ieee_128 (_Decimal128 in, decimal128 *out)\n+{\n+  __swap128 ((char *) &in, (char *) out);\n+}\n+\n+void\n+__ieee_to_host_128 (decimal128 in, _Decimal128 *out)\n+{\n+  __swap128 ((char *) &in, (char *) out);\n+}\n+#endif /* L_conv_td */\n+\n+#if defined(L_addsub_sd) || defined(L_addsub_dd) || defined(L_addsub_td)\n+DFP_C_TYPE\n+DFP_ADD (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  return dfp_binary_op (decNumberAdd, arg_a, arg_b);\n+}\n+\n+DFP_C_TYPE\n+DFP_SUB (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  return dfp_binary_op (decNumberSubtract, arg_a, arg_b);\n+}\n+#endif /* L_addsub */\n+\n+#if defined(L_mul_sd) || defined(L_mul_dd) || defined(L_mul_td)\n+DFP_C_TYPE\n+DFP_MULTIPLY (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  return dfp_binary_op (decNumberMultiply, arg_a, arg_b);\n+}\n+#endif /* L_mul */\n+\n+#if defined(L_div_sd) || defined(L_div_dd) || defined(L_div_td)\n+DFP_C_TYPE\n+DFP_DIVIDE (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  return dfp_binary_op (decNumberDivide, arg_a, arg_b);\n+}\n+#endif /* L_div */\n+\n+#if defined (L_eq_sd) || defined (L_eq_dd) || defined (L_eq_td)\n+CMPtype\n+DFP_EQ (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  int stat;\n+  stat = dfp_compare_op (decNumberCompare, arg_a, arg_b);\n+  /* For EQ return zero for true, nonzero for false.  */\n+  return stat != 0;\n+}\n+#endif /* L_eq */\n+\n+#if defined (L_ne_sd) || defined (L_ne_dd) || defined (L_ne_td)\n+CMPtype\n+DFP_NE (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  int stat;\n+  stat = dfp_compare_op (decNumberCompare, arg_a, arg_b);\n+  /* For NE return nonzero for true, zero for false.  */\n+  return stat != 0;\n+}\n+#endif /* L_ne */\n+\n+#if defined (L_lt_sd) || defined (L_lt_dd) || defined (L_lt_td)\n+CMPtype\n+DFP_LT (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  int stat;\n+  stat = dfp_compare_op (decNumberCompare, arg_a, arg_b);\n+  /* For LT return -1 (<0) for true, 1 for false.  */\n+  return (stat == -1) ? -1 : 1;\n+}\n+#endif /* L_lt */\n+\n+#if defined (L_gt_sd) || defined (L_gt_dd) || defined (L_gt_td)\n+CMPtype\n+DFP_GT (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  int stat;\n+  stat = dfp_compare_op (decNumberCompare, arg_a, arg_b);\n+  /* For GT return 1 (>0) for true, -1 for false.  */\n+  return (stat == 1) ? 1 : -1;\n+}\n+#endif\n+\n+#if defined (L_le_sd) || defined (L_le_dd) || defined (L_le_td)\n+CMPtype\n+DFP_LE (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  int stat;\n+  stat = dfp_compare_op (decNumberCompare, arg_a, arg_b);\n+  /* For LE return 0 (<= 0) for true, 1 for false.  */\n+  return stat == 1;\n+}\n+#endif /* L_le */\n+\n+#if defined (L_ge_sd) || defined (L_ge_dd) || defined (L_ge_td)\n+CMPtype\n+DFP_GE (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  int stat;\n+  stat = dfp_compare_op (decNumberCompare, arg_a, arg_b);\n+  /* For GE return 1 (>=0) for true, -1 for false.  */\n+  return (stat != -1) ? 1 : -1;\n+}\n+#endif /* L_ge */\n+\n+#define BUFMAX 128\n+\n+#if defined (L_sd_to_dd) || defined (L_sd_to_td) || defined (L_dd_to_sd) \\\n+ || defined (L_dd_to_td) || defined (L_td_to_sd) || defined (L_td_to_dd)\n+DFP_C_TYPE_TO\n+DFP_TO_DFP (DFP_C_TYPE f_from)\n+{\n+  DFP_C_TYPE_TO f_to;\n+  IEEE_TYPE s_from;\n+  IEEE_TYPE_TO s_to;\n+  decNumber d;\n+  decContext context;\n+\n+  decContextDefault (&context, CONTEXT_INIT);\n+  context.round = CONTEXT_ROUND;\n+\n+  HOST_TO_IEEE (f_from, &s_from);\n+  TO_INTERNAL (&s_from, &d);\n+  TO_ENCODED_TO (&s_to, &d, &context);\n+  if (CONTEXT_TRAPS && (context.status & DEC_Inexact) != 0)\n+    DFP_RAISE (DEC_Inexact);\n+\n+  IEEE_TO_HOST_TO (s_to, &f_to);\n+  return f_to;\n+}\n+#endif\n+\n+#if defined (L_sd_to_si) || defined (L_dd_to_si) || defined (L_td_to_si) \\\n+  || defined (L_sd_to_di) || defined (L_dd_to_di) || defined (L_td_to_di) \\\n+  || defined (L_sd_to_usi) || defined (L_dd_to_usi) || defined (L_td_to_usi) \\\n+  || defined (L_sd_to_udi) || defined (L_dd_to_udi) || defined (L_td_to_udi)\n+INT_TYPE\n+DFP_TO_INT (DFP_C_TYPE x)\n+{\n+  /* decNumber's decimal* types have the same format as C's _Decimal*\n+     types, but they have different calling conventions.  */\n+\n+  IEEE_TYPE s;\n+  char buf[BUFMAX];\n+  char *pos;\n+  decNumber qval, n1, n2;\n+  decContext context;\n+\n+  decContextDefault (&context, CONTEXT_INIT);\n+  /* Need non-default rounding mode here.  */\n+  context.round = DEC_ROUND_DOWN;\n+\n+  HOST_TO_IEEE (x, &s);\n+  TO_INTERNAL (&s, &n1);\n+  /* Rescale if the exponent is less than zero.  */\n+  decNumberToIntegralValue (&n2, &n1, &context);\n+  /* Get a value to use for the quanitize call.  */\n+  decNumberFromString (&qval, (char *) \"1.0\", &context);\n+  /* Force the exponent to zero.  */\n+  decNumberQuantize (&n1, &n2, &qval, &context);\n+  /* This is based on text in N1107 secton 5.1; it might turn out to be\n+     undefined behavior instead.  */\n+  if (context.status & DEC_Invalid_operation)\n+    {\n+#if defined (L_sd_to_si) || defined (L_dd_to_si) || defined (L_td_to_si)\n+      if (decNumberIsNegative(&n2))\n+        return INT_MIN;\n+      else\n+        return INT_MAX;\n+#elif defined (L_sd_to_di) || defined (L_dd_to_di) || defined (L_td_to_di)\n+      if (decNumberIsNegative(&n2))\n+        /* Find a defined constant that will work here.  */\n+        return (-9223372036854775807LL - 1LL);\n+      else\n+        /* Find a defined constant that will work here.  */\n+        return 9223372036854775807LL;\n+#elif defined (L_sd_to_usi) || defined (L_dd_to_usi) || defined (L_td_to_usi)\n+      return UINT_MAX;\n+#elif defined (L_sd_to_udi) || defined (L_dd_to_udi) || defined (L_td_to_udi)\n+        /* Find a defined constant that will work here.  */\n+      return 18446744073709551615ULL;\n+#endif\n+    }\n+  /* Get a string, which at this point will not include an exponent.  */\n+  decNumberToString (&n1, buf);\n+  /* Ignore the fractional part.  */\n+  pos = strchr (buf, '.');\n+  if (pos)\n+    *pos = 0;\n+  /* Use a C library function to convert to the integral type.  */\n+  return STR_TO_INT (buf, NULL, 10);\n+}\n+#endif\n+\n+#if defined (L_si_to_sd) || defined (L_si_to_dd) || defined (L_si_to_td) \\\n+  || defined (L_di_to_sd) || defined (L_di_to_dd) || defined (L_di_to_td) \\\n+  || defined (L_usi_to_sd) || defined (L_usi_to_dd) || defined (L_usi_to_td) \\\n+  || defined (L_udi_to_sd) || defined (L_udi_to_dd) || defined (L_udi_to_td)\n+DFP_C_TYPE\n+INT_TO_DFP (INT_TYPE i)\n+{\n+  DFP_C_TYPE f;\n+  IEEE_TYPE s;\n+  char buf[BUFMAX];\n+  decContext context;\n+\n+  decContextDefault (&context, CONTEXT_INIT);\n+  context.round = CONTEXT_ROUND;\n+\n+  /* Use a C library function to get a floating point string.  */\n+  sprintf (buf, INT_FMT \".0\", CAST_FOR_FMT(i));\n+  /* Convert from the floating point string to a decimal* type.  */\n+  FROM_STRING (&s, buf, &context);\n+  IEEE_TO_HOST (s, &f);\n+  if (CONTEXT_TRAPS && (context.status & DEC_Inexact) != 0)\n+    DFP_RAISE (DEC_Inexact);\n+  return f;\n+}\n+#endif\n+\n+#if defined (L_sd_to_sf) || defined (L_dd_to_sf) || defined (L_td_to_sf) \\\n+ || defined (L_sd_to_df) || defined (L_dd_to_df) || defined (L_td_to_df) \\\n+ || ((defined (L_sd_to_xf) || defined (L_dd_to_xf) || defined (L_td_to_xf)) \\\n+     && LIBGCC2_HAS_XF_MODE)\n+BFP_TYPE\n+DFP_TO_BFP (DFP_C_TYPE f)\n+{\n+  IEEE_TYPE s;\n+  char buf[BUFMAX];\n+\n+  HOST_TO_IEEE (f, &s);\n+  /* Write the value to a string.  */\n+  TO_STRING (&s, buf);\n+  /* Read it as the binary floating point type and return that.  */\n+  return STR_TO_BFP (buf, NULL);\n+}\n+#endif\n+                                                                                \n+#if defined (L_sf_to_sd) || defined (L_sf_to_dd) || defined (L_sf_to_td) \\\n+ || defined (L_df_to_sd) || defined (L_df_to_dd) || defined (L_df_to_td) \\\n+ || ((defined (L_xf_to_sd) || defined (L_xf_to_dd) || defined (L_xf_to_td)) \\\n+     && LIBGCC2_HAS_XF_MODE)\n+DFP_C_TYPE\n+BFP_TO_DFP (BFP_TYPE x)\n+{\n+  DFP_C_TYPE f;\n+  IEEE_TYPE s;\n+  char buf[BUFMAX];\n+  decContext context;\n+\n+  decContextDefault (&context, CONTEXT_INIT);\n+  context.round = CONTEXT_ROUND;\n+\n+  /* Use a C library function to write the floating point value to a string.  */\n+#ifdef BFP_VIA_TYPE\n+  /* FIXME: Is threre a better way to output an XFmode variable in C?  */\n+  sprintf (buf, BFP_FMT, (BFP_VIA_TYPE) x);\n+#else\n+  sprintf (buf, BFP_FMT, x);\n+#endif\n+\n+  /* Convert from the floating point string to a decimal* type.  */\n+  FROM_STRING (&s, buf, &context);\n+  IEEE_TO_HOST (s, &f);\n+  if (CONTEXT_TRAPS && (context.status & DEC_Inexact) != 0)\n+    DFP_RAISE (DEC_Inexact);\n+  return f;\n+}\n+#endif\n+\n+#if defined (L_unord_sd) || defined (L_unord_dd) || defined (L_unord_td)\n+CMPtype\n+DFP_UNORD (DFP_C_TYPE arg_a, DFP_C_TYPE arg_b)\n+{\n+  decNumber arg1, arg2;\n+  IEEE_TYPE a, b;\n+\n+  HOST_TO_IEEE (arg_a, &a);\n+  HOST_TO_IEEE (arg_b, &b);\n+  TO_INTERNAL (&a, &arg1);\n+  TO_INTERNAL (&b, &arg2);\n+  return (decNumberIsNaN (&arg1) || decNumberIsNaN (&arg2));\n+}\n+#endif /* L_unord_sd || L_unord_dd || L_unord_td */"}, {"sha": "5f3a04ee3b802e157239db91af93638b32070e0d", "filename": "gcc/config/dfp-bit.h", "status": "added", "additions": 511, "deletions": 0, "changes": 511, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d190d56b7e7921a58656cded35fe4722c57c9bb8/gcc%2Fconfig%2Fdfp-bit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d190d56b7e7921a58656cded35fe4722c57c9bb8/gcc%2Fconfig%2Fdfp-bit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdfp-bit.h?ref=d190d56b7e7921a58656cded35fe4722c57c9bb8", "patch": "@@ -0,0 +1,511 @@\n+/* Header file for dfp-bit.c.\n+   Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#ifndef _DFPBIT_H\n+#define _DFPBIT_H\n+\n+#include \"tconfig.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+\n+#ifndef LIBGCC2_FLOAT_WORDS_BIG_ENDIAN\n+#define LIBGCC2_FLOAT_WORDS_BIG_ENDIAN LIBGCC2_WORDS_BIG_ENDIAN\n+#endif\n+\n+#ifndef LIBGCC2_LONG_DOUBLE_TYPE_SIZE\n+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE LONG_DOUBLE_TYPE_SIZE\n+#endif\n+\n+#ifndef LIBGCC2_HAS_XF_MODE\n+#define LIBGCC2_HAS_XF_MODE \\\n+  (BITS_PER_UNIT == 8 && LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 80)\n+#endif\n+\n+/* Depending on WIDTH, define a number of macros:\n+\n+   DFP_C_TYPE: type of the arguments to the libgcc functions;\n+\t(eg _Decimal32)\n+\n+   IEEE_TYPE: the corresponding (encoded) IEEE754R type;\n+\t(eg decimal32)\n+   \n+   TO_INTERNAL: the name of the decNumber function to convert an\n+   encoded value into the decNumber internal representation;\n+\n+   TO_ENCODED: the name of the decNumber function to convert an\n+   internally represented decNumber into the encoded\n+   representation.\n+\n+   FROM_STRING: the name of the decNumber function to read an\n+   encoded value from a string.\n+\n+   TO_STRING: the name of the decNumber function to write an\n+   encoded value to a string.  */\n+\n+#if WIDTH == 32\n+#define DFP_C_TYPE\t_Decimal32\n+#define IEEE_TYPE\tdecimal32\n+#define HOST_TO_IEEE\t__host_to_ieee_32\n+#define IEEE_TO_HOST\t__ieee_to_host_32\n+#define TO_INTERNAL\t__decimal32ToNumber\n+#define TO_ENCODED\t__decimal32FromNumber\n+#define FROM_STRING\t__decimal32FromString\n+#define TO_STRING\t__decimal32ToString\n+#elif WIDTH == 64\n+#define DFP_C_TYPE\t_Decimal64\n+#define IEEE_TYPE\tdecimal64\n+#define HOST_TO_IEEE\t__host_to_ieee_64\n+#define IEEE_TO_HOST\t__ieee_to_host_64\n+#define TO_INTERNAL\t__decimal64ToNumber\n+#define TO_ENCODED\t__decimal64FromNumber\n+#define FROM_STRING\t__decimal64FromString\n+#define TO_STRING\t__decimal64ToString\n+#elif WIDTH == 128\n+#define DFP_C_TYPE\t_Decimal128\n+#define IEEE_TYPE\tdecimal128\n+#define HOST_TO_IEEE\t__host_to_ieee_128\n+#define IEEE_TO_HOST\t__ieee_to_host_128\n+#define TO_INTERNAL\t__decimal128ToNumber\n+#define TO_ENCODED\t__decimal128FromNumber\n+#define FROM_STRING\t__decimal128FromString\n+#define TO_STRING\t__decimal128ToString\n+#else\n+#error invalid decimal float word width\n+#endif\n+\n+/* We define __DEC_EVAL_METHOD__ to 2, saying that we evaluate all\n+   operations and constants to the range and precision of the _Decimal128\n+   type.  Make it so.  */\n+#if WIDTH == 32\n+#define CONTEXT_INIT DEC_INIT_DECIMAL32\n+#elif WIDTH == 64\n+#define CONTEXT_INIT DEC_INIT_DECIMAL64\n+#elif WIDTH == 128\n+#define CONTEXT_INIT DEC_INIT_DECIMAL128\n+#endif\n+\n+/* Define CONTEXT_ROUND to obtain the current decNumber rounding mode.  */\n+extern enum rounding\t__decGetRound (void);\n+#define CONTEXT_ROUND\t__decGetRound ()\n+\n+extern int __dfp_traps;\n+#define CONTEXT_TRAPS\t__dfp_traps\n+#define CONTEXT_ERRORS(context)\tcontext.status & DEC_Errors\n+extern void __dfp_raise (int);\n+#define DFP_RAISE(A)\t__dfp_raise(A)\n+\n+/* Conversions between different decimal float types use WIDTH_TO to\n+   determine additional macros to define.  */\n+\n+#if defined (L_dd_to_sd) || defined (L_td_to_sd)\n+#define WIDTH_TO 32\n+#elif defined (L_sd_to_dd) || defined (L_td_to_dd)\n+#define WIDTH_TO 64\n+#elif defined (L_sd_to_td) || defined (L_dd_to_td)\n+#define WIDTH_TO 128\n+#endif\n+\n+/* If WIDTH_TO is defined, define additional macros:\n+\n+   DFP_C_TYPE_TO: type of the result of dfp to dfp conversion.\n+\n+   IEEE_TYPE_TO: the corresponding (encoded) IEEE754R type.\n+\n+   TO_ENCODED_TO: the name of the decNumber function to convert an\n+   internally represented decNumber into the encoded representation\n+   for the destination.  */\n+\n+#if WIDTH_TO == 32\n+#define DFP_C_TYPE_TO\t_Decimal32\n+#define IEEE_TYPE_TO\tdecimal32\n+#define TO_ENCODED_TO\t__decimal32FromNumber\n+#define IEEE_TO_HOST_TO __ieee_to_host_32\n+#elif WIDTH_TO == 64\n+#define DFP_C_TYPE_TO\t_Decimal64\n+#define IEEE_TYPE_TO\tdecimal64\n+#define TO_ENCODED_TO\t__decimal64FromNumber\n+#define IEEE_TO_HOST_TO __ieee_to_host_64\n+#elif WIDTH_TO == 128\n+#define DFP_C_TYPE_TO\t_Decimal128\n+#define IEEE_TYPE_TO\tdecimal128\n+#define TO_ENCODED_TO\t__decimal128FromNumber\n+#define IEEE_TO_HOST_TO __ieee_to_host_128\n+#endif\n+\n+/* Conversions between decimal float types and integral types use INT_KIND\n+   to determine the data type and C functions to use.  */\n+\n+#if defined (L_sd_to_si) || defined (L_dd_to_si) || defined (L_td_to_si)  \\\n+   || defined (L_si_to_sd) || defined (L_si_to_dd) || defined (L_si_to_td)\n+#define INT_KIND 1\n+#elif defined (L_sd_to_di) || defined (L_dd_to_di) || defined (L_td_to_di) \\\n+   || defined (L_di_to_sd) || defined (L_di_to_dd) || defined (L_di_to_td)\n+#define INT_KIND 2\n+#elif defined (L_sd_to_usi) || defined (L_dd_to_usi) || defined (L_td_to_usi) \\\n+   || defined (L_usi_to_sd) || defined (L_usi_to_dd) || defined (L_usi_to_td)\n+#define INT_KIND 3\n+#elif defined (L_sd_to_udi) || defined (L_dd_to_udi) || defined (L_td_to_udi) \\\n+   || defined (L_udi_to_sd) || defined (L_udi_to_dd) || defined (L_udi_to_td)\n+#define INT_KIND 4\n+#endif\n+\n+/*  If INT_KIND is defined, define additional macros:\n+\n+    INT_TYPE: The integer data type.\n+\n+    INT_FMT: The format string for writing the integer to a string.\n+\n+    CAST_FOR_FMT: Cast variable of INT_KIND to C type for sprintf.\n+    This works for ILP32 and LP64, won't for other type size systems.\n+\n+    STR_TO_INT: The function to read the integer from a string.  */\n+\n+#if INT_KIND == 1\n+#define INT_TYPE SItype\n+#define INT_FMT \"%d\"\n+#define CAST_FOR_FMT(A) (int)A\n+#define STR_TO_INT strtol\n+#elif INT_KIND == 2\n+#define INT_TYPE DItype\n+#define INT_FMT \"%lld\"\n+#define CAST_FOR_FMT(A) (long long)A\n+#define STR_TO_INT strtoll\n+#elif INT_KIND == 3\n+#define INT_TYPE USItype\n+#define INT_FMT \"%u\"\n+#define CAST_FOR_FMT(A) (unsigned int)A\n+#define STR_TO_INT strtoul\n+#elif INT_KIND == 4\n+#define INT_TYPE UDItype\n+#define INT_FMT \"%llu\"\n+#define CAST_FOR_FMT(A) (unsigned long long)A\n+#define STR_TO_INT strtoull\n+#endif\n+\n+/* Conversions between decimal float types and binary float types use\n+   BFP_KIND to determine the data type and C functions to use.  */\n+\n+#if defined (L_sd_to_sf) || defined (L_dd_to_sf) || defined (L_td_to_sf) \\\n+ || defined (L_sf_to_sd) || defined (L_sf_to_dd) || defined (L_sf_to_td)\n+#define BFP_KIND 1\n+#elif defined (L_sd_to_df) || defined (L_dd_to_df ) || defined (L_td_to_df) \\\n+ ||   defined (L_df_to_sd) || defined (L_df_to_dd) || defined (L_df_to_td)\n+#define BFP_KIND 2\n+#elif defined (L_sd_to_xf) || defined (L_dd_to_xf ) || defined (L_td_to_xf) \\\n+ ||   defined (L_xf_to_sd) || defined (L_xf_to_dd) || defined (L_xf_to_td)\n+#define BFP_KIND 3\n+#endif\n+\n+/*  If BFP_KIND is defined, define additional macros:\n+\n+    BFP_TYPE: The binary floating point data type.\n+\n+    BFP_FMT: The format string for writing the value to a string.\n+\n+    STR_TO_BFP: The function to read the value from a string.  */\n+\n+#if BFP_KIND == 1\n+/* strtof is declared in <stdlib.h> only for C99.  */\n+extern float strtof (const char *, char **);\n+#define BFP_TYPE SFtype\n+#define BFP_FMT \"%e\"\n+#define STR_TO_BFP strtof\n+\n+#elif BFP_KIND == 2\n+#define BFP_TYPE DFtype\n+#define BFP_FMT \"%e\"\n+#define STR_TO_BFP strtod\n+\n+#elif BFP_KIND == 3\n+#if LIBGCC2_HAS_XF_MODE\n+/* These aren't used if XF mode is not supported.  */\n+#define BFP_TYPE XFtype\n+#define BFP_FMT \"%e\"\n+#define BFP_VIA_TYPE double\n+#define STR_TO_BFP strtod\n+#endif\n+\n+#endif /* BFP_KIND */\n+\n+#if WIDTH == 128 || WIDTH_TO == 128\n+#include \"decimal128.h\"\n+#endif\n+#if WIDTH == 64 || WIDTH_TO == 64\n+#include \"decimal64.h\"\n+#endif\n+#if WIDTH == 32 || WIDTH_TO == 32\n+#include \"decimal32.h\"\n+#endif\n+#include \"decNumber.h\"\n+\n+/* Names of arithmetic functions.  */\n+\n+#if WIDTH == 32\n+#define DFP_ADD\t\t__addsd3\n+#define DFP_SUB\t\t__subsd3\n+#define DFP_MULTIPLY\t__mulsd3\n+#define DFP_DIVIDE\t__divsd3\n+#define DFP_EQ\t\t__eqsd2\n+#define DFP_NE\t\t__nesd2\n+#define DFP_LT\t\t__ltsd2\n+#define DFP_GT\t\t__gtsd2\n+#define DFP_LE\t\t__lesd2\n+#define DFP_GE\t\t__gesd2\n+#define DFP_UNORD\t__unordsd2\n+#elif WIDTH == 64\n+#define DFP_ADD\t\t__adddd3\n+#define DFP_SUB\t\t__subdd3\n+#define DFP_MULTIPLY\t__muldd3\n+#define DFP_DIVIDE\t__divdd3\n+#define DFP_EQ\t\t__eqdd2\n+#define DFP_NE\t\t__nedd2\n+#define DFP_LT\t\t__ltdd2\n+#define DFP_GT\t\t__gtdd2\n+#define DFP_LE\t\t__ledd2\n+#define DFP_GE\t\t__gedd2\n+#define DFP_UNORD\t__unorddd2\n+#elif WIDTH == 128\n+#define DFP_ADD\t\t__addtd3\n+#define DFP_SUB\t\t__subtd3\n+#define DFP_MULTIPLY\t__multd3\n+#define DFP_DIVIDE\t__divtd3\n+#define DFP_EQ\t\t__eqtd2\n+#define DFP_NE\t\t__netd2\n+#define DFP_LT\t\t__lttd2\n+#define DFP_GT\t\t__gttd2\n+#define DFP_LE\t\t__letd2\n+#define DFP_GE\t\t__getd2\n+#define DFP_UNORD\t__unordtd2\n+#endif\n+\n+/* Names of functions to convert between different decimal float types.  */\n+\n+#if WIDTH == 32\n+#if WIDTH_TO == 64\n+#define DFP_TO_DFP\t__extendsddd2\n+#elif WIDTH_TO == 128\n+#define DFP_TO_DFP\t__extendsdtd2\n+#endif\n+#elif WIDTH == 64\t\n+#if WIDTH_TO == 32\n+#define DFP_TO_DFP\t__truncddsd2\n+#elif WIDTH_TO == 128\n+#define DFP_TO_DFP\t__extendddtd2\n+#endif\n+#elif WIDTH == 128\n+#if WIDTH_TO == 32\n+#define DFP_TO_DFP\t__trunctdsd2\n+#elif WIDTH_TO == 64\n+#define DFP_TO_DFP\t__trunctddd2\n+#endif\n+#endif\n+\n+/* Names of functions to convert between decimal float and integers.  */\n+\n+#if WIDTH == 32\n+#if INT_KIND == 1\n+#define INT_TO_DFP\t__floatsisd\n+#define DFP_TO_INT\t__fixsdsi\n+#elif INT_KIND == 2\n+#define INT_TO_DFP\t__floatdisd\n+#define DFP_TO_INT\t__fixsddi\n+#elif INT_KIND == 3\n+#define INT_TO_DFP\t__floatunssisd\n+#define DFP_TO_INT\t__fixunssdsi\n+#elif INT_KIND == 4\n+#define INT_TO_DFP\t__floatunsdisd\n+#define DFP_TO_INT\t__fixunssddi\n+#endif\n+#elif WIDTH == 64\n+#if INT_KIND == 1\n+#define INT_TO_DFP\t__floatsidd\n+#define DFP_TO_INT\t__fixddsi\n+#elif INT_KIND == 2\n+#define INT_TO_DFP\t__floatdidd\n+#define DFP_TO_INT\t__fixdddi\n+#elif INT_KIND == 3\n+#define INT_TO_DFP\t__floatunssidd\n+#define DFP_TO_INT\t__fixunsddsi\n+#elif INT_KIND == 4\n+#define INT_TO_DFP\t__floatunsdidd\n+#define DFP_TO_INT\t__fixunsdddi\n+#endif\n+#elif WIDTH == 128\n+#if INT_KIND == 1\n+#define INT_TO_DFP\t__floatsitd\n+#define DFP_TO_INT\t__fixtdsi\n+#elif INT_KIND == 2\n+#define INT_TO_DFP\t__floatditd\n+#define DFP_TO_INT\t__fixtddi\n+#elif INT_KIND == 3\n+#define INT_TO_DFP\t__floatunssitd\n+#define DFP_TO_INT\t__fixunstdsi\n+#elif INT_KIND == 4\n+#define INT_TO_DFP\t__floatunsditd\n+#define DFP_TO_INT\t__fixunstddi\n+#endif\n+#endif\n+\n+/* Names of functions to convert between decimal float and binary float.  */\n+\n+#if WIDTH == 32\n+#if BFP_KIND == 1\n+#define BFP_TO_DFP\t__extendsfsd\n+#define DFP_TO_BFP\t__truncsdsf\n+#elif BFP_KIND == 2\n+#define BFP_TO_DFP\t__truncdfsd\n+#define DFP_TO_BFP\t__extendsddf\n+#elif BFP_KIND == 3\n+#define BFP_TO_DFP\t__truncxfsd\n+#define DFP_TO_BFP\t__extendsdxf\n+#endif /* BFP_KIND */\n+\n+#elif WIDTH == 64\n+#if BFP_KIND == 1\n+#define BFP_TO_DFP\t__extendsfdd\n+#define DFP_TO_BFP\t__truncddsf\n+#elif BFP_KIND == 2\n+#define BFP_TO_DFP\t__extenddfdd\n+#define DFP_TO_BFP\t__truncdddf\n+#elif BFP_KIND == 3\n+#define BFP_TO_DFP\t__truncxfdd\n+#define DFP_TO_BFP\t__extendddxf\n+#endif /* BFP_KIND */\n+\n+#elif WIDTH == 128\n+#if BFP_KIND == 1\n+#define BFP_TO_DFP\t__extendsftd\n+#define DFP_TO_BFP\t__trunctdsf\n+#elif BFP_KIND == 2\n+#define BFP_TO_DFP\t__extenddftd\n+#define DFP_TO_BFP\t__trunctddf\n+#elif BFP_KIND == 3\n+#define BFP_TO_DFP\t__extendxftd\n+#define DFP_TO_BFP\t__trunctdxf\n+#endif /* BFP_KIND */\n+\n+#endif /* WIDTH */\n+\n+/* Some handy typedefs.  */\n+\n+typedef float SFtype __attribute__ ((mode (SF)));\n+typedef float DFtype __attribute__ ((mode (DF)));\n+#if LIBGCC2_HAS_XF_MODE\n+typedef float XFtype __attribute__ ((mode (XF)));\n+#endif /* LIBGCC2_HAS_XF_MODE */\n+\n+typedef int SItype __attribute__ ((mode (SI)));\n+typedef int DItype __attribute__ ((mode (DI)));\n+typedef unsigned int USItype __attribute__ ((mode (SI)));\n+typedef unsigned int UDItype __attribute__ ((mode (DI)));\n+\n+/* The type of the result of a decimal float comparison.  This must\n+   match `word_mode' in GCC for the target.  Default to SItype.  */\n+\n+#ifndef CMPtype\n+#define CMPtype SItype\n+#endif\n+\n+/* Prototypes.  */\n+\n+#if defined (L_mul_sd) || defined (L_mul_dd) || defined (L_mul_td)\n+extern DFP_C_TYPE DFP_MULTIPLY (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_div_sd) || defined (L_div_dd) || defined (L_div_td)\n+extern DFP_C_TYPE DFP_DIVIDE (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_addsub_sd) || defined (L_addsub_dd) || defined (L_addsub_td)\n+extern DFP_C_TYPE DFP_ADD (DFP_C_TYPE, DFP_C_TYPE);\n+extern DFP_C_TYPE DFP_SUB (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_eq_sd) || defined (L_eq_dd) || defined (L_eq_td)\n+extern CMPtype DFP_EQ (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_ne_sd) || defined (L_ne_dd) || defined (L_ne_td)\n+extern CMPtype DFP_NE (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_lt_sd) || defined (L_lt_dd) || defined (L_lt_td)\n+extern CMPtype DFP_LT (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_gt_sd) || defined (L_gt_dd) || defined (L_gt_td)\n+extern CMPtype DFP_GT (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_le_sd) || defined (L_le_dd) || defined (L_le_td)\n+extern CMPtype DFP_LE (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_ge_sd) || defined (L_ge_dd) || defined (L_ge_td)\n+extern CMPtype DFP_GE (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_unord_sd) || defined (L_unord_dd) || defined (L_unord_td)\n+extern CMPtype DFP_UNORD (DFP_C_TYPE, DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_sd_to_dd) || defined (L_sd_to_td) || defined (L_dd_to_sd) \\\n+ || defined (L_dd_to_td) || defined (L_td_to_sd) || defined (L_td_to_dd)\n+extern DFP_C_TYPE_TO DFP_TO_DFP (DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_sd_to_si) || defined (L_dd_to_si) || defined (L_td_to_si) \\\n+ || defined (L_sd_to_di) || defined (L_dd_to_di) || defined (L_td_to_di) \\\n+ || defined (L_sd_to_usi) || defined (L_dd_to_usi) || defined (L_td_to_usi) \\\n+ || defined (L_sd_to_udi) || defined (L_dd_to_udi) || defined (L_td_to_udi)\n+extern INT_TYPE DFP_TO_INT (DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_si_to_sd) || defined (L_si_to_dd) || defined (L_si_to_td) \\\n+ || defined (L_di_to_sd) || defined (L_di_to_dd) || defined (L_di_to_td) \\\n+ || defined (L_usi_to_sd) || defined (L_usi_to_dd) || defined (L_usi_to_td) \\\n+ || defined (L_udi_to_sd) || defined (L_udi_to_dd) || defined (L_udi_to_td)\n+extern DFP_C_TYPE INT_TO_DFP (INT_TYPE);\n+#endif\n+\n+#if defined (L_sd_to_sf) || defined (L_dd_to_sf) || defined (L_td_to_sf) \\\n+ || defined (L_sd_to_df) || defined (L_dd_to_df) || defined (L_td_to_df) \\\n+ || ((defined (L_sd_to_xf) || defined (L_dd_to_xf) || defined (L_td_to_xf)) \\\n+     && LIBGCC2_HAS_XF_MODE)\n+extern BFP_TYPE DFP_TO_BFP (DFP_C_TYPE);\n+#endif\n+\n+#if defined (L_sf_to_sd) || defined (L_sf_to_dd) || defined (L_sf_to_td) \\\n+ || defined (L_df_to_sd) || defined (L_df_to_dd) || defined (L_df_to_td) \\\n+ || ((defined (L_xf_to_sd) || defined (L_xf_to_dd) || defined (L_xf_to_td)) \\\n+     && LIBGCC2_HAS_XF_MODE)\n+extern DFP_C_TYPE BFP_TO_DFP (BFP_TYPE);\n+#endif\n+\n+#endif /* _DFPBIT_H */"}, {"sha": "f67b117f06d26bf48b32ffd995310dbddf7c5d66", "filename": "gcc/doc/libgcc.texi", "status": "modified", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d190d56b7e7921a58656cded35fe4722c57c9bb8/gcc%2Fdoc%2Flibgcc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d190d56b7e7921a58656cded35fe4722c57c9bb8/gcc%2Fdoc%2Flibgcc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Flibgcc.texi?ref=d190d56b7e7921a58656cded35fe4722c57c9bb8", "patch": "@@ -39,6 +39,7 @@ and @code{@w{unsigned int}} correspond to @code{SImode}; @code{long} and\n @menu\n * Integer library routines::\n * Soft float library routines::\n+* Decimal float library routines::\n * Exception handling routines::\n * Miscellaneous routines::\n @end menu\n@@ -485,6 +486,205 @@ These functions return the quotient of @math{@var{a} + i@var{b}} and\n + i@var{d})}), following the rules of C99 Annex G@.\n @end deftypefn\n \n+@node Decimal float library routines\n+@section Routines for decimal floating point emulation\n+@cindex decimal float library\n+@cindex IEEE-754R\n+\n+The software decimal floating point library implements IEEE 754R\n+decimal floating point arithmetic and is only activated on selected\n+targets.\n+\n+@subsection Arithmetic functions\n+\n+@deftypefn {Runtime Function} _Decimal32 __addsd3 (_Decimal32 @var{a}, _Decimal32 @var{b})\n+@deftypefnx {Runtime Function} _Decimal64 __adddd3 (_Decimal64 @var{a}, _Decimal64 @var{b})\n+@deftypefnx {Runtime Function} _Decimal128 __addtd3 (_Decimal128 @var{a}, _Decimal128 @var{b})\n+These functions return the sum of @var{a} and @var{b}.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} _Decimal32 __subsd3 (_Decimal32 @var{a}, _Decimal32 @var{b})\n+@deftypefnx {Runtime Function} _Decimal64 __subdd3 (_Decimal64 @var{a}, _Decimal64 @var{b})\n+@deftypefnx {Runtime Function} _Decimal128 __subtd3 (_Decimal128 @var{a}, _Decimal128 @var{b})\n+These functions return the difference between @var{b} and @var{a};\n+that is, @w{@math{@var{a} - @var{b}}}.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} _Decimal32 __mulsd3 (_Decimal32 @var{a}, _Decimal32 @var{b})\n+@deftypefnx {Runtime Function} _Decimal64 __muldd3 (_Decimal64 @var{a}, _Decimal64 @var{b})\n+@deftypefnx {Runtime Function} _Decimal128 __multd3 (_Decimal128 @var{a}, _Decimal128 @var{b})\n+These functions return the product of @var{a} and @var{b}.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} _Decimal32 __divsd3 (_Decimal32 @var{a}, _Decimal32 @var{b})\n+@deftypefnx {Runtime Function} _Decimal64 __divdd3 (_Decimal64 @var{a}, _Decimal64 @var{b})\n+@deftypefnx {Runtime Function} _Decimal128 __divtd3 (_Decimal128 @var{a}, _Decimal128 @var{b})\n+These functions return the quotient of @var{a} and @var{b}; that is,\n+@w{@math{@var{a} / @var{b}}}.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} _Decimal32 __negsd2 (_Decimal32 @var{a})\n+@deftypefnx {Runtime Function} _Decimal64 __negdd2 (_Decimal64 @var{a})\n+@deftypefnx {Runtime Function} _Decimal128 __negtd2 (_Decimal128 @var{a})\n+These functions return the negation of @var{a}.  They simply flip the\n+sign bit, so they can produce negative zero and negative NaN@.\n+@end deftypefn\n+\n+@subsection Conversion functions\n+\n+@c DFP/DFP conversions\n+@deftypefn {Runtime Function} _Decimal64 __extendsddd2 (_Decimal32 @var{a})\n+@deftypefnx {Runtime Function} _Decimal128 __extendsdtd2 (_Decimal32 @var{a})\n+@deftypefnx {Runtime Function} _Decimal128 __extendddtd2 (_Decimal64 @var{a})\n+@c DFP/binary FP conversions\n+@deftypefnx {Runtime Function} _Decimal32 __extendsfsd (float @var{a})\n+@deftypefnx {Runtime Function} double __extendsddf (_Decimal32 @var{a})\n+@deftypefnx {Runtime Function} {long double} __extendsdxf (_Decimal32 @var{a})\n+@deftypefnx {Runtime Function} _Decimal64 __extendsfdd (float @var{a})\n+@deftypefnx {Runtime Function} _Decimal64 __extenddfdd (double @var{a})\n+@deftypefnx {Runtime Function} {long double} __extendddxf (_Decimal64 @var{a})\n+@deftypefnx {Runtime Function} _Decimal128 __extendsftd (float @var{a})\n+@deftypefnx {Runtime Function} _Decimal128 __extenddftd (double @var{a})\n+@deftypefnx {Runtime Function} _Decimal128 __extendxftd ({long double} @var{a})\n+These functions extend @var{a} to the wider mode of their return type.\n+@end deftypefn\n+\n+@c DFP/DFP conversions\n+@deftypefn {Runtime Function} _Decimal32 __truncddsd2 (_Decimal64 @var{a})\n+@deftypefnx {Runtime Function} _Decimal32 __trunctdsd2 (_Decimal128 @var{a})\n+@deftypefnx {Runtime Function} _Decimal64 __trunctddd2 (_Decimal128 @var{a})\n+@c DFP/binary FP conversions\n+@deftypefnx {Runtime Function} float __truncsdsf (_Decimal32 @var{a})\n+@deftypefnx {Runtime Function} _Decimal32 __truncdfsd (double @var{a})\n+@deftypefnx {Runtime Function} _Decimal32 __truncxfsd ({long double} @var{a})\n+@deftypefnx {Runtime Function} float __truncddsf (_Decimal64 @var{a})\n+@deftypefnx {Runtime Function} double __truncdddf (_Decimal64 @var{a})\n+@deftypefnx {Runtime Function} _Decimal64 __truncxfdd ({long double} @var{a})\n+@deftypefnx {Runtime Function} float __trunctdsf (_Decimal128 @var{a})\n+@deftypefnx {Runtime Function} double __trunctddf (_Decimal128 @var{a})\n+@deftypefnx {Runtime Function} {long double} __trunctdxf (_Decimal128 @var{a})\n+These functions truncate @var{a} to the narrower mode of their return\n+type.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __fixsdsi (_Decimal32 @var{a})\n+@deftypefnx {Runtime Function} int __fixddsi (_Decimal64 @var{a})\n+@deftypefnx {Runtime Function} int __fixtdsi (_Decimal128 @var{a})\n+These functions convert @var{a} to a signed integer.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} long __fixsddi (_Decimal32 @var{a})\n+@deftypefnx {Runtime Function} long __fixdddi (_Decimal64 @var{a})\n+@deftypefnx {Runtime Function} long __fixtddi (_Decimal128 @var{a})\n+These functions convert @var{a} to a signed long.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} {unsigned int} __fixunssdsi (_Decimal32 @var{a})\n+@deftypefnx {Runtime Function} {unsigned int} __fixunsddsi (_Decimal64 @var{a})\n+@deftypefnx {Runtime Function} {unsigned int} __fixunstdsi (_Decimal128 @var{a})\n+These functions convert @var{a} to an unsigned integer.  Negative values all become zero.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} {unsigned long} __fixunssddi (_Decimal32 @var{a})\n+@deftypefnx {Runtime Function} {unsigned long} __fixunsdddi (_Decimal64 @var{a})\n+@deftypefnx {Runtime Function} {unsigned long} __fixunstddi (_Decimal128 @var{a})\n+These functions convert @var{a} to an unsigned long.  Negative values\n+all become zero.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} _Decimal32 __floatsisd (int @var{i})\n+@deftypefnx {Runtime Function} _Decimal64 __floatsidd (int @var{i})\n+@deftypefnx {Runtime Function} _Decimal128 __floatsitd (int @var{i})\n+These functions convert @var{i}, a signed integer, to decimal floating point.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} _Decimal32 __floatdisd (long @var{i})\n+@deftypefnx {Runtime Function} _Decimal64 __floatdidd (long @var{i})\n+@deftypefnx {Runtime Function} _Decimal128 __floatditd (long @var{i})\n+These functions convert @var{i}, a signed long, to decimal floating point.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} _Decimal32 __floatunssisd (unsigned int @var{i})\n+@deftypefnx {Runtime Function} _Decimal64 __floatunssidd (unsigned int @var{i})\n+@deftypefnx {Runtime Function} _Decimal128 __floatunssitd (unsigned int @var{i})\n+These functions convert @var{i}, an unsigned integer, to decimal floating point.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} _Decimal32 __floatunsdisd (unsigned long @var{i})\n+@deftypefnx {Runtime Function} _Decimal64 __floatunsdidd (unsigned long @var{i})\n+@deftypefnx {Runtime Function} _Decimal128 __floatunsditd (unsigned long @var{i})\n+These functions convert @var{i}, an unsigned long, to decimal floating point.\n+@end deftypefn\n+\n+@subsection Comparison functions\n+\n+@deftypefn {Runtime Function} int __unordsd2 (_Decimal32 @var{a}, _Decimal32 @var{b})\n+@deftypefnx {Runtime Function} int __unorddd2 (_Decimal64 @var{a}, _Decimal64 @var{b})\n+@deftypefnx {Runtime Function} int __unordtd2 (_Decimal128 @var{a}, _Decimal128 @var{b})\n+These functions return a nonzero value if either argument is NaN, otherwise 0.\n+@end deftypefn\n+\n+There is also a complete group of higher level functions which\n+correspond directly to comparison operators.  They implement the ISO C\n+semantics for floating-point comparisons, taking NaN into account.\n+Pay careful attention to the return values defined for each set.\n+Under the hood, all of these routines are implemented as\n+\n+@smallexample\n+  if (__unord@var{X}d2 (a, b))\n+    return @var{E};\n+  return __cmp@var{X}d2 (a, b);\n+@end smallexample\n+\n+@noindent\n+where @var{E} is a constant chosen to give the proper behavior for\n+NaN@.  Thus, the meaning of the return value is different for each set.\n+Do not rely on this implementation; only the semantics documented\n+below are guaranteed.\n+\n+@deftypefn {Runtime Function} int __eqsd2 (_Decimal32 @var{a}, _Decimal32 @var{b})\n+@deftypefnx {Runtime Function} int __eqdd2 (_Decimal64 @var{a}, _Decimal64 @var{b})\n+@deftypefnx {Runtime Function} int __eqtd2 (_Decimal128 @var{a}, _Decimal128 @var{b})\n+These functions return zero if neither argument is NaN, and @var{a} and\n+@var{b} are equal.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __nesd2 (_Decimal32 @var{a}, _Decimal32 @var{b})\n+@deftypefnx {Runtime Function} int __nedd2 (_Decimal64 @var{a}, _Decimal64 @var{b})\n+@deftypefnx {Runtime Function} int __netd2 (_Decimal128 @var{a}, _Decimal128 @var{b})\n+These functions return a nonzero value if either argument is NaN, or\n+if @var{a} and @var{b} are unequal.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __gesd2 (_Decimal32 @var{a}, _Decimal32 @var{b})\n+@deftypefnx {Runtime Function} int __gedd2 (_Decimal64 @var{a}, _Decimal64 @var{b})\n+@deftypefnx {Runtime Function} int __getd2 (_Decimal128 @var{a}, _Decimal128 @var{b})\n+These functions return a value greater than or equal to zero if\n+neither argument is NaN, and @var{a} is greater than or equal to\n+@var{b}.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __ltsd2 (_Decimal32 @var{a}, _Decimal32 @var{b})\n+@deftypefnx {Runtime Function} int __ltdd2 (_Decimal64 @var{a}, _Decimal64 @var{b})\n+@deftypefnx {Runtime Function} int __lttd2 (_Decimal128 @var{a}, _Decimal128 @var{b})\n+These functions return a value less than zero if neither argument is\n+NaN, and @var{a} is strictly less than @var{b}.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __lesd2 (_Decimal32 @var{a}, _Decimal32 @var{b})\n+@deftypefnx {Runtime Function} int __ledd2 (_Decimal64 @var{a}, _Decimal64 @var{b})\n+@deftypefnx {Runtime Function} int __letd2 (_Decimal128 @var{a}, _Decimal128 @var{b})\n+These functions return a value less than or equal to zero if neither\n+argument is NaN, and @var{a} is less than or equal to @var{b}.\n+@end deftypefn\n+\n+@deftypefn {Runtime Function} int __gtsd2 (_Decimal32 @var{a}, _Decimal32 @var{b})\n+@deftypefnx {Runtime Function} int __gtdd2 (_Decimal64 @var{a}, _Decimal64 @var{b})\n+@deftypefnx {Runtime Function} int __gttd2 (_Decimal128 @var{a}, _Decimal128 @var{b})\n+These functions return a value greater than zero if neither argument\n+is NaN, and @var{a} is strictly greater than @var{b}.\n+@end deftypefn\n+\n @node Exception handling routines\n @section Language-independent routines for exception handling\n "}, {"sha": "2162c051a91a1f5769e00315b2696a75e5cea7bc", "filename": "gcc/mklibgcc.in", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d190d56b7e7921a58656cded35fe4722c57c9bb8/gcc%2Fmklibgcc.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d190d56b7e7921a58656cded35fe4722c57c9bb8/gcc%2Fmklibgcc.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmklibgcc.in?ref=d190d56b7e7921a58656cded35fe4722c57c9bb8", "patch": "@@ -28,6 +28,12 @@\n # DPBIT_FUNCS\n # TPBIT\n # TPBIT_FUNCS\n+# D32PBIT\n+# D32PBIT_FUNCS\n+# D64PBIT\n+# D64PBIT_FUNCS\n+# D128PBIT\n+# D128PBIT_FUNCS\n # LIBGCC\n # MULTILIBS\n # EXTRA_MULTILIB_PARTS\n@@ -96,6 +102,12 @@ libgcov_c_dep='stmp-dirs $(srcdir)/libgcov.c $(srcdir)/gcov-io.h $(srcdir)/gcov-\n # Dependencies for fp-bit.c\n fpbit_c_dep='stmp-dirs config.status tsystem.h'\n \n+# Dependencies for decnumber and friends.  This is an overzealous set,\n+# but at least we can be sure to recompile if anything gets modified.\n+decnumber_dep='stmp-dirs $(srcdir)/../libdecnumber/decContext.h $(srcdir)/../libdecnumber/decNumber.h\n+\t$(srcdir)/../libdecnumber/decNumberLocal.h $(srcdir)/../libdecnumber/decimal32.h $(srcdir)/../libdecnumber/decimal64.h\n+\t$(srcdir)/../libdecnumber/decimal128.h $(srcdir)/../libdecnumber/decDPD.h $(srcdir)/../libdecnumber/decUtility.h'\n+\n # Flag whether we need eh_dummy.c\n need_eh_dummy=\n \n@@ -349,6 +361,49 @@ for ml in $MULTILIBS; do\n       fi\n   done\n \n+  if [ \"@enable_decimal_float@\" = \"yes\" -a -z \"$libgcc_so\" ]; then\n+    # Bring in the DFP support code if D32PBIT, D64PBIT or D128PBIT are set.\n+    if [ -n \"$D32PBIT\" -o -n \"$D64PBIT\" -o -n \"$D128PBIT\" ] ; then\n+      dec_filenames=\"decContext decNumber decRound decLibrary decUtility\"\n+    fi\n+\n+    # Only bring in decimal*.c files for types we support.\n+    if [ -n \"$D32PBIT\" ] ; then\n+      dec_filenames=\"$dec_filenames decimal32\"\n+    fi\n+    if [ -n \"$D64PBIT\" ] ; then\n+      dec_filenames=\"$dec_filenames decimal64\"\n+    fi\n+    if [ -n \"$D128PBIT\" ] ; then\n+      dec_filenames=\"$dec_filenames decimal128\"\n+    fi\n+\n+    for name in $dec_filenames ; do\n+      out=\"libgcc/${dir}/${name}${objext}\"\n+      echo $out: \"\\$(srcdir)/../libdecnumber/${name}.c\" $decnumber_dep\n+      echo \"\t$gcc_compile\" $flags -c \"\\$(srcdir)/../libdecnumber/${name}.c\" -o $out\n+      echo $libgcc_a: $out\n+    done\n+\n+    # For individual functions, loop over each variable by name.\n+    for dpbit_var in D32PBIT D64PBIT D128PBIT ; do\n+      dpfuncs_var=\"${dpbit_var}_FUNCS\"\n+      eval dpbit=\\$$dpbit_var\n+      eval dpfuncs=\\$$dpfuncs_var\n+\n+      if [ \"$dpbit\" ]; then\n+        for name in $dpfuncs; do\n+          out=\"libgcc/${dir}/${name}${objext}\"\n+\t  echo $out: $dpbit $fpbit_c_dep\n+\t  echo \"\t$gcc_compile\" -DFINE_GRAINED_LIBRARIES $flags -DL$name \\\n+\t    -c $dpbit -o $out\n+\n+\t  echo $libgcc_a: $out\n+        done\n+      fi\n+    done\n+  fi\n+\n   for file in $LIB2ADD; do\n     name=`echo $file | sed -e 's/[.][cS]$//' -e 's/[.]asm$//'`\n     oname=`echo $name | sed -e 's,.*/,,'`"}]}