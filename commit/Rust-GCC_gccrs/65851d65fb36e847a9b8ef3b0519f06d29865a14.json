{"sha": "65851d65fb36e847a9b8ef3b0519f06d29865a14", "node_id": "C_kwDOANBUbNoAKDY1ODUxZDY1ZmIzNmU4NDdhOWI4ZWYzYjA1MTlmMDZkMjk4NjVhMTQ", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-03-08T18:53:39Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-05-18T10:58:55Z"}, "message": "demangler: Reorganize for module demangling\n\nModule demangling requires some changes in how substitutions are\nhandled.  This adjusts things to make that possible.\n\n\tlibiberty/\n\t* cp-demangle.c (d_name): Add SUBSTABLE parameter,\n\tpush substitution if requested. Adjust unscoped name handling.\n\t(d_prefix): Reorder main loop. Adjust all calls.\n\t(d_unqualified_name): Add SCOPE parameter, create qualified\n\tname here. Adjust all calls.\n\t(cplus_demangle_type): Do not handle 'S' here, leave all\n\tto d_class_enum_type.\n\t(d_class_enum_type): Add SUBSTABLE parameter.", "tree": {"sha": "47d29098e9f89fc6696255364f0f7e147ea726ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47d29098e9f89fc6696255364f0f7e147ea726ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65851d65fb36e847a9b8ef3b0519f06d29865a14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65851d65fb36e847a9b8ef3b0519f06d29865a14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65851d65fb36e847a9b8ef3b0519f06d29865a14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65851d65fb36e847a9b8ef3b0519f06d29865a14/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86f64400a5692499856d41462461327b93f82b8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86f64400a5692499856d41462461327b93f82b8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86f64400a5692499856d41462461327b93f82b8d"}], "stats": {"total": 222, "additions": 83, "deletions": 139}, "files": [{"sha": "cf451c5aff21ffbd245fdbf849a6a75735504f54", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 83, "deletions": 139, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65851d65fb36e847a9b8ef3b0519f06d29865a14/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65851d65fb36e847a9b8ef3b0519f06d29865a14/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=65851d65fb36e847a9b8ef3b0519f06d29865a14", "patch": "@@ -425,13 +425,14 @@ is_ctor_dtor_or_conversion (struct demangle_component *);\n \n static struct demangle_component *d_encoding (struct d_info *, int);\n \n-static struct demangle_component *d_name (struct d_info *);\n+static struct demangle_component *d_name (struct d_info *, int substable);\n \n static struct demangle_component *d_nested_name (struct d_info *);\n \n static struct demangle_component *d_prefix (struct d_info *, int);\n \n-static struct demangle_component *d_unqualified_name (struct d_info *);\n+static struct demangle_component *d_unqualified_name (struct d_info *,\n+\t\t\t\t\t\t      struct demangle_component *scope);\n \n static struct demangle_component *d_source_name (struct d_info *);\n \n@@ -462,7 +463,7 @@ static struct demangle_component *\n d_bare_function_type (struct d_info *, int);\n \n static struct demangle_component *\n-d_class_enum_type (struct d_info *);\n+d_class_enum_type (struct d_info *, int);\n \n static struct demangle_component *d_array_type (struct d_info *);\n \n@@ -1323,7 +1324,7 @@ d_encoding (struct d_info *di, int top_level)\n     dc = d_special_name (di);\n   else\n     {\n-      dc = d_name (di);\n+      dc = d_name (di, 0);\n \n       if (!dc)\n \t/* Failed already.  */;\n@@ -1417,80 +1418,64 @@ d_abi_tags (struct d_info *di, struct demangle_component *dc)\n */\n \n static struct demangle_component *\n-d_name (struct d_info *di)\n+d_name (struct d_info *di, int substable)\n {\n   char peek = d_peek_char (di);\n-  struct demangle_component *dc;\n+  struct demangle_component *dc = NULL;\n+  int subst = 0;\n \n   switch (peek)\n     {\n     case 'N':\n-      return d_nested_name (di);\n+      dc = d_nested_name (di);\n+      break;\n \n     case 'Z':\n-      return d_local_name (di);\n+      dc = d_local_name (di);\n+      break;\n \n     case 'U':\n-      return d_unqualified_name (di);\n+      dc = d_unqualified_name (di, NULL);\n+      break;\n \n     case 'S':\n       {\n-\tint subst;\n-\n-\tif (d_peek_next_char (di) != 't')\n-\t  {\n-\t    dc = d_substitution (di, 0);\n-\t    subst = 1;\n-\t  }\n-\telse\n+\tif (d_peek_next_char (di) == 't')\n \t  {\n \t    d_advance (di, 2);\n-\t    dc = d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME,\n-\t\t\t      d_make_name (di, \"std\", 3),\n-\t\t\t      d_unqualified_name (di));\n+\t    dc = d_make_name (di, \"std\", 3);\n \t    di->expansion += 3;\n-\t    subst = 0;\n-\t  }\n-\n-\tif (d_peek_char (di) != 'I')\n-\t  {\n-\t    /* The grammar does not permit this case to occur if we\n-\t       called d_substitution() above (i.e., subst == 1).  We\n-\t       don't bother to check.  */\n \t  }\n \telse\n \t  {\n-\t    /* This is <template-args>, which means that we just saw\n-\t       <unscoped-template-name>, which is a substitution\n-\t       candidate if we didn't just get it from a\n-\t       substitution.  */\n-\t    if (! subst)\n-\t      {\n-\t\tif (! d_add_substitution (di, dc))\n-\t\t  return NULL;\n-\t      }\n-\t    dc = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, dc,\n-\t\t\t      d_template_args (di));\n+\t    dc = d_substitution (di, 0);\n+\t    if (!dc)\n+\t      return NULL;\n+\t    subst = 1;\n \t  }\n-\n-\treturn dc;\n       }\n+      /* FALLTHROUGH */\n \n     case 'L':\n     default:\n-      dc = d_unqualified_name (di);\n+      if (!subst)\n+\tdc = d_unqualified_name (di, dc);\n       if (d_peek_char (di) == 'I')\n \t{\n \t  /* This is <template-args>, which means that we just saw\n \t     <unscoped-template-name>, which is a substitution\n \t     candidate.  */\n-\t  if (! d_add_substitution (di, dc))\n+\t  if (!subst && !d_add_substitution (di, dc))\n \t    return NULL;\n \t  dc = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, dc,\n \t\t\t    d_template_args (di));\n+\t  subst = 0;\n \t}\n-      return dc;\n+      break;\n     }\n+  if (substable && !subst && !d_add_substitution (di, dc))\n+    return NULL;\n+  return dc;\n }\n \n /* <nested-name> ::= N [<CV-qualifiers>] [<ref-qualifier>] <prefix> <unqualified-name> E\n@@ -1546,54 +1531,51 @@ d_nested_name (struct d_info *di)\n    if not (in an unresolved-name).  */\n \n static struct demangle_component *\n-d_prefix (struct d_info *di, int subst)\n+d_prefix (struct d_info *di, int substable)\n {\n   struct demangle_component *ret = NULL;\n \n-  while (1)\n+  for (;;)\n     {\n-      char peek;\n-      enum demangle_component_type comb_type;\n-      struct demangle_component *dc;\n-\n-      peek = d_peek_char (di);\n-      if (peek == '\\0')\n-\treturn NULL;\n+      char peek = d_peek_char (di);\n \n       /* The older code accepts a <local-name> here, but I don't see\n \t that in the grammar.  The older code does not accept a\n \t <template-param> here.  */\n \n-      comb_type = DEMANGLE_COMPONENT_QUAL_NAME;\n-      if (peek == 'D')\n+      if (peek == 'D'\n+\t  && (d_peek_next_char (di) == 'T'\n+\t      || d_peek_next_char (di) == 't'))\n \t{\n-\t  char peek2 = d_peek_next_char (di);\n-\t  if (peek2 == 'T' || peek2 == 't')\n-\t    /* Decltype.  */\n-\t    dc = cplus_demangle_type (di);\n-\t  else\n-\t    /* Destructor name.  */\n-\t    dc = d_unqualified_name (di);\n+\t  /* Decltype.  */\n+\t  if (ret)\n+\t    return NULL;\n+\t  ret = cplus_demangle_type (di);\n \t}\n-      else if (IS_DIGIT (peek)\n-\t  || IS_LOWER (peek)\n-\t  || peek == 'C'\n-\t  || peek == 'U'\n-\t  || peek == 'L')\n-\tdc = d_unqualified_name (di);\n       else if (peek == 'S')\n-\tdc = d_substitution (di, 1);\n+\t{\n+\t  if (ret)\n+\t    return NULL;\n+\t  ret = d_substitution (di, 1);\n+\t  if (!ret)\n+\t    return NULL;\n+\t  continue;\n+\t}\n       else if (peek == 'I')\n \t{\n \t  if (ret == NULL)\n \t    return NULL;\n-\t  comb_type = DEMANGLE_COMPONENT_TEMPLATE;\n-\t  dc = d_template_args (di);\n+\t  struct demangle_component *dc = d_template_args (di);\n+\t  if (!dc)\n+\t    return NULL;\n+\t  ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret, dc);\n \t}\n       else if (peek == 'T')\n-\tdc = d_template_param (di);\n-      else if (peek == 'E')\n-\treturn ret;\n+\t{\n+\t  if (ret)\n+\t    return NULL;\n+\t  ret = d_template_param (di);\n+\t}\n       else if (peek == 'M')\n \t{\n \t  /* Initializer scope for a lambda.  We don't need to represent\n@@ -1602,22 +1584,21 @@ d_prefix (struct d_info *di, int subst)\n \t  if (ret == NULL)\n \t    return NULL;\n \t  d_advance (di, 1);\n-\t  continue;\n \t}\n       else\n-\treturn NULL;\n+\tret = d_unqualified_name (di, ret);\n \n-      if (ret == NULL)\n-\tret = dc;\n-      else\n-\tret = d_make_comp (di, comb_type, ret, dc);\n+      if (!ret)\n+\tbreak;\n \n-      if (peek != 'S' && d_peek_char (di) != 'E' && subst)\n-\t{\n-\t  if (! d_add_substitution (di, ret))\n-\t    return NULL;\n-\t}\n+      if (d_peek_char (di) == 'E')\n+\tbreak;\n+\n+      if (substable && !d_add_substitution (di, ret))\n+\treturn NULL;\n     }\n+\n+  return ret;\n }\n \n /* <unqualified-name> ::= <operator-name> [<abi-tags>]\n@@ -1629,7 +1610,7 @@ d_prefix (struct d_info *di, int subst)\n */\n \n static struct demangle_component *\n-d_unqualified_name (struct d_info *di)\n+d_unqualified_name (struct d_info *di, struct demangle_component *scope)\n {\n   struct demangle_component *ret;\n   char peek;\n@@ -1709,6 +1690,9 @@ d_unqualified_name (struct d_info *di)\n \n   if (d_peek_char (di) == 'B')\n     ret = d_abi_tags (di, ret);\n+  if (scope)\n+    ret = d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, scope, ret);\n+\n   return ret;\n }\n \n@@ -2149,11 +2133,11 @@ d_special_name (struct d_info *di)\n \n \tcase 'H':\n \t  return d_make_comp (di, DEMANGLE_COMPONENT_TLS_INIT,\n-\t\t\t      d_name (di), NULL);\n+\t\t\t      d_name (di, 0), NULL);\n \n \tcase 'W':\n \t  return d_make_comp (di, DEMANGLE_COMPONENT_TLS_WRAPPER,\n-\t\t\t      d_name (di), NULL);\n+\t\t\t      d_name (di, 0), NULL);\n \n \tcase 'A':\n \t  return d_make_comp (di, DEMANGLE_COMPONENT_TPARM_OBJ,\n@@ -2169,11 +2153,11 @@ d_special_name (struct d_info *di)\n \t{\n \tcase 'V':\n \t  return d_make_comp (di, DEMANGLE_COMPONENT_GUARD,\n-\t\t\t      d_name (di), NULL);\n+\t\t\t      d_name (di, 0), NULL);\n \n \tcase 'R':\n \t  {\n-\t    struct demangle_component *name = d_name (di);\n+\t    struct demangle_component *name = d_name (di, 0);\n \t    return d_make_comp (di, DEMANGLE_COMPONENT_REFTEMP, name,\n \t\t\t\td_number_component (di));\n \t  }\n@@ -2504,13 +2488,6 @@ cplus_demangle_type (struct d_info *di)\n       ret = d_function_type (di);\n       break;\n \n-    case '0': case '1': case '2': case '3': case '4':\n-    case '5': case '6': case '7': case '8': case '9':\n-    case 'N':\n-    case 'Z':\n-      ret = d_class_enum_type (di);\n-      break;\n-\n     case 'A':\n       ret = d_array_type (di);\n       break;\n@@ -2581,39 +2558,6 @@ cplus_demangle_type (struct d_info *di)\n \t}\n       break;\n \n-    case 'S':\n-      /* If this is a special substitution, then it is the start of\n-\t <class-enum-type>.  */\n-      {\n-\tchar peek_next;\n-\n-\tpeek_next = d_peek_next_char (di);\n-\tif (IS_DIGIT (peek_next)\n-\t    || peek_next == '_'\n-\t    || IS_UPPER (peek_next))\n-\t  {\n-\t    ret = d_substitution (di, 0);\n-\t    /* The substituted name may have been a template name and\n-\t       may be followed by tepmlate args.  */\n-\t    if (d_peek_char (di) == 'I')\n-\t      ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,\n-\t\t\t\t d_template_args (di));\n-\t    else\n-\t      can_subst = 0;\n-\t  }\n-\telse\n-\t  {\n-\t    ret = d_class_enum_type (di);\n-\t    /* If the substitution was a complete type, then it is not\n-\t       a new substitution candidate.  However, if the\n-\t       substitution was followed by template arguments, then\n-\t       the whole thing is a substitution candidate.  */\n-\t    if (ret != NULL && ret->type == DEMANGLE_COMPONENT_SUB_STD)\n-\t      can_subst = 0;\n-\t  }\n-      }\n-      break;\n-\n     case 'O':\n       d_advance (di, 1);\n       ret = d_make_comp (di, DEMANGLE_COMPONENT_RVALUE_REFERENCE,\n@@ -2754,7 +2698,7 @@ cplus_demangle_type (struct d_info *di)\n       break;\n \n     default:\n-      return NULL;\n+      return d_class_enum_type (di, 1);\n     }\n \n   if (can_subst)\n@@ -3027,9 +2971,9 @@ d_bare_function_type (struct d_info *di, int has_return_type)\n /* <class-enum-type> ::= <name>  */\n \n static struct demangle_component *\n-d_class_enum_type (struct d_info *di)\n+d_class_enum_type (struct d_info *di, int substable)\n {\n-  return d_name (di);\n+  return d_name (di, substable);\n }\n \n /* <array-type> ::= A <(positive dimension) number> _ <(element) type>\n@@ -3358,11 +3302,11 @@ d_unresolved_name (struct d_info *di)\n     }\n   else\n     type = cplus_demangle_type (di);\n-  name = d_unqualified_name (di);\n+  name = d_unqualified_name (di, type);\n   if (d_peek_char (di) == 'I')\n     name = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,\n \t\t\td_template_args (di));\n-  return d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type, name);\n+  return name;\n }\n \n /* <expression> ::= <(unary) operator-name> <expression>\n@@ -3431,7 +3375,7 @@ d_expression_1 (struct d_info *di)\n \t/* operator-function-id, i.e. operator+(t).  */\n \td_advance (di, 2);\n \n-      name = d_unqualified_name (di);\n+      name = d_unqualified_name (di, NULL);\n       if (name == NULL)\n \treturn NULL;\n       if (d_peek_char (di) == 'I')\n@@ -3539,7 +3483,7 @@ d_expression_1 (struct d_info *di)\n \t      /* fold-expression.  */\n \t      left = d_operator_name (di);\n \t    else if (!strcmp (code, \"di\"))\n-\t      left = d_unqualified_name (di);\n+\t      left = d_unqualified_name (di, NULL);\n \t    else\n \t      left = d_expression_1 (di);\n \t    if (!strcmp (code, \"cl\"))\n@@ -3557,7 +3501,7 @@ d_expression_1 (struct d_info *di)\n \t\t       d_unqualified_name rather than d_expression_1 here for\n \t\t       old mangled names that didn't add 'on' before operator\n \t\t       names.  */\n-\t\t    right = d_unqualified_name (di);\n+\t\t    right = d_unqualified_name (di, NULL);\n \t\t    if (d_peek_char (di) == 'I')\n \t\t      right = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE,\n \t\t\t\t\t   right, d_template_args (di));\n@@ -3767,7 +3711,7 @@ d_local_name (struct d_info *di)\n \t    return NULL;\n \t}\n \n-      name = d_name (di);\n+      name = d_name (di, 0);\n \n       if (name\n \t  /* Lambdas and unnamed types have internal discriminators"}]}