{"sha": "1ecea86fd20e61d70c22dfb39974a935a0dba6c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVjZWE4NmZkMjBlNjFkNzBjMjJkZmIzOTk3NGE5MzVhMGRiYTZjMg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-16T23:02:35Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-16T23:02:35Z"}, "message": "Initial revision\n\nFrom-SVN: r332", "tree": {"sha": "b5c0715fc04c81cfdf2a9739d9e16ec2655e756c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5c0715fc04c81cfdf2a9739d9e16ec2655e756c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ecea86fd20e61d70c22dfb39974a935a0dba6c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ecea86fd20e61d70c22dfb39974a935a0dba6c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ecea86fd20e61d70c22dfb39974a935a0dba6c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ecea86fd20e61d70c22dfb39974a935a0dba6c2/comments", "author": null, "committer": null, "parents": [{"sha": "37114d0dbc247dd1cf79dd74d9813bf8ea0a84c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37114d0dbc247dd1cf79dd74d9813bf8ea0a84c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37114d0dbc247dd1cf79dd74d9813bf8ea0a84c4"}], "stats": {"total": 420, "additions": 420, "deletions": 0}, "files": [{"sha": "8257ae5635d4753c1d7686c65683eac30915ff2e", "filename": "gcc/config/m68k/news.h", "status": "added", "additions": 420, "deletions": 0, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ecea86fd20e61d70c22dfb39974a935a0dba6c2/gcc%2Fconfig%2Fm68k%2Fnews.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ecea86fd20e61d70c22dfb39974a935a0dba6c2/gcc%2Fconfig%2Fm68k%2Fnews.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnews.h?ref=1ecea86fd20e61d70c22dfb39974a935a0dba6c2", "patch": "@@ -0,0 +1,420 @@\n+/* Definitions of target machine for GNU compiler.  SONY NEWS-OS 3.0 version.\n+   Copyright (C) 1987, 1989 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifndef USE_GAS\n+/* This controls conditionals in m68k.h.  */\n+#define MOTOROLA\t\t/* Use Motorola syntax rather than \"MIT\" */\n+#define SGS_NO_LI\t\t/* Suppress jump table label usage */\n+#endif\n+\n+#include \"m68k.h\"\n+\n+/* See m68k.h.  7 means 68020 with 68881.  */\n+\n+#define TARGET_DEFAULT 7\n+\n+/* Define __HAVE_68881__ in preprocessor, unless -msoft-float is specified.\n+   This will control the use of inline 68881 insns in certain macros.  */\n+\n+#define CPP_SPEC \"%{!msoft-float:-D__HAVE_68881__}\"\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+/* These are the ones defined by Sony, plus mc68000 for uniformity with\n+   GCC on other 68000 systems.  */\n+\n+#define CPP_PREDEFINES \"-Dunix -Dbsd43 -Dsony -Dsony_news -Dmc68000 -Dmc68020 -Dnews700\"\n+\n+/* These conditionals tested for different submodels,\n+   but they were incorrect since they tested the host rather than the target.\n+   The choice of model shouldn't actually matter.  */\n+\n+#if 0\n+#ifdef news800\n+#define CPP_PREDEFINES \"-Dunix -Dbsd43 -Dsony -Dsony_news -Dmc68000 -Dmc68020 -Dnews800\"\n+#endif\n+#ifdef news900\n+#define CPP_PREDEFINES \"-Dunix -Dbsd43 -Dsony -Dsony_news -Dmc68000 -Dmc68020 -Dnews900\"\n+#endif\n+#ifdef news1500\n+#define CPP_PREDEFINES \"-Dunix -Dbsd43 -Dsony -Dsony_news -Dmc68000 -Dmc68020 -Dmc68030 -Dnews1500\"\n+#endif\n+#ifdef news1700\n+#define CPP_PREDEFINES \"-Dunix -Dbsd43 -Dsony -Dsony_news -Dmc68000 -Dmc68020 -Dmc68030 -Dnews1700\"\n+#endif\n+#ifdef news1800\n+#define CPP_PREDEFINES \"-Dunix -Dbsd43 -Dsony -Dsony_news -Dmc68000 -Dmc68020 -Dmc68030 -Dnews1800\"\n+#endif\n+#ifdef news1900\n+#define CPP_PREDEFINES \"-Dunix -Dbsd43 -Dsony -Dsony_news -Dmc68000 -Dmc68020 -Dmc68030 -Dnews1900\"\n+#endif\n+#endif\n+\n+/* Link with libg.a when debugging, for dbx's sake.  */\n+\n+#define LIB_SPEC \"%{g:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \"\n+\n+/* This is BSD, so it wants DBX format.  */\n+\n+#define DBX_DEBUGGING_INFO\n+\n+#if 0\n+/* This is to be compatible with types.h.\n+   It was found to be necessary with Newsos 3.  */\n+\n+#define SIZE_TYPE \"long int\"\n+#endif\n+\f\n+/* Override parts of m68k.h to fit Sony's assembler syntax.  */\n+\n+#undef BIGGEST_ALIGNMENT\n+#undef CALL_USED_REGISTERS\n+#undef FUNCTION_VALUE\n+#undef LIBCALL_VALUE\n+#undef FUNCTION_PROFILER\n+\n+#ifdef MOTOROLA\n+#undef FUNCTION_PROLOGUE\n+#undef FUNCTION_EPILOGUE\n+#undef REGISTER_NAMES\n+#undef ASM_OUTPUT_REG_PUSH\n+#undef ASM_OUTPUT_REG_POP\n+#undef ASM_OUTPUT_DOUBLE\n+#undef ASM_OUTPUT_SKIP\n+#undef ASM_FORMAT_PRIVATE_NAME\n+#undef PRINT_OPERAND\n+#undef PRINT_OPERAND_ADDRESS\n+#endif  \n+\n+#undef ASM_OUTPUT_ALIGN\n+\n+/* There is no point aligning anything to a rounder boundary than this.  */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* A bitfield declared as `int' forces `int' alignment for the struct.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+  \n+/* NEWS makes d2, d3, fp2 and fp3 unsaved registers, unlike the Sun system.  */\n+  \n+#define CALL_USED_REGISTERS \\\n+ {1, 1, 1, 1, 0, 0, 0, 0, \\\n+  1, 1, 0, 0, 0, 0, 0, 1, \\\n+  1, 1, 1, 1, 0, 0, 0, 0}\n+\n+/* NEWS returns floats and doubles in fp0, not d0/d1.  */\n+\n+#define FUNCTION_VALUE(VALTYPE,FUNC) LIBCALL_VALUE (TYPE_MODE (VALTYPE))\n+\n+#define LIBCALL_VALUE(MODE) \\\n+ gen_rtx (REG, (MODE), ((TARGET_68881 && ((MODE) == SFmode || (MODE) == DFmode)) ? 16 : 0))\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n+\f\n+#ifdef MOTOROLA\n+\n+/* Don't try to define `gcc_compiled.' since the assembler does not\n+   accept symbols with periods.  This is no real loss since GDB only\n+   really needs it for parms passed in registers.  */\n+#define ASM_IDENTIFY_GCC(FILE)\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n+{ register int regno;\t\t\t\t\t\t\\\n+  register int mask = 0;\t\t\t\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  int fsize = ((SIZE) + 3) & -4;\t\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    { if (fsize < 0x8000)\t\t\t                \\\n+        fprintf (FILE, \"\\tlink fp,#%d\\n\", -fsize);\t\t\\\n+      else if (TARGET_68020)                                    \\\n+        fprintf (FILE, \"\\tlink.l fp,#%d\\n\", -fsize);            \\\n+      else\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tlink fp,#0\\n\\tsub.l #%d,sp\\n\", fsize); }  \\\n+  for (regno = 16; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+       mask |= 1 << (regno - 16);\t\t\t\t\\\n+  if (mask != 0)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tfmovem.x #0x%x,-(sp)\\n\", mask & 0xff);    \\\n+  mask = 0;\t\t\t\t\t\t\t\\\n+  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+       mask |= 1 << (15 - regno);\t\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    mask &= ~ (1 << (15-FRAME_POINTER_REGNUM));\t\t\t\\\n+  if (exact_log2 (mask) >= 0)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tmove.l %s,-(sp)\\n\", reg_names[15 - exact_log2 (mask)]);  \\\n+  else if (mask) fprintf (FILE, \"\\tmovem.l #0x%x,-(sp)\\n\", mask); }\n+\n+#define FUNCTION_PROFILER(FILE, LABEL_NO) \\\n+   fprintf (FILE, \"\\tmove.l #LP%d,d0\\n\\tjsr mcount\\n\", (LABEL_NO));\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n+{ register int regno;\t\t\t\t\t\t\\\n+  register int mask, fmask;\t\t\t\t\t\\\n+  register int nregs;\t\t\t\t\t\t\\\n+  int offset, foffset;\t\t\t\t\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  int fsize = ((SIZE) + 3) & -4;\t\t\t\t\\\n+  int big = 0;\t\t\t\t\t\t\t\\\n+  nregs = 0;  fmask = 0;\t\t\t\t\t\\\n+  for (regno = 16; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      { nregs++; fmask |= 1 << (23 - regno); }\t\t\t\\\n+  foffset = nregs * 12;\t\t\t\t\t\t\\\n+  nregs = 0;  mask = 0;\t\t\t\t\t\t\\\n+  if (frame_pointer_needed) regs_ever_live[FRAME_POINTER_REGNUM] = 0; \\\n+  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      { nregs++; mask |= 1 << regno; }\t\t\t\t\\\n+  offset = foffset + nregs * 4;\t\t\t\t\t\\\n+  if (offset + fsize >= 0x8000 \t\t\t\t\t\\\n+      && frame_pointer_needed\t\t\t\t\t\\\n+      && (mask || fmask))\t\t\t\t\t\\\n+    { fprintf (FILE, \"\\tmove.l #%d,a0\\n\", -fsize);\t\t\\\n+      fsize = 0, big = 1; }\t\t\t\t\t\\\n+  if (exact_log2 (mask) >= 0) {\t\t\t\t\t\\\n+    if (big)\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmove.l (-%d,fp,a0.l),%s\\n\",\t\t\\\n+\t       offset + fsize, reg_names[exact_log2 (mask)]);\t\\\n+    else if (! frame_pointer_needed)\t\t\t\t\\\n+      fprintf (FILE, \"\\tmove.l (sp)+,%s\\n\",\t\t\t\\\n+\t       reg_names[exact_log2 (mask)]);\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmove.l (-%d,fp),%s\\n\",\t\t\t\\\n+\t       offset + fsize, reg_names[exact_log2 (mask)]); }\t\\\n+  else if (mask) {\t\t\t\t\t\t\\\n+    if (big)\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovem.l (-%d,fp,a0.l),#0x%x\\n\",\t\t\\\n+\t       offset + fsize, mask);\t\t\t\t\\\n+    else if (! frame_pointer_needed)\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovem.l (sp)+,#0x%x\\n\", mask);\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovem.l (-%d,fp),#0x%x\\n\",\t\t\\\n+\t       offset + fsize, mask); }\t\t\t\t\\\n+  if (fmask) {\t\t\t\t\t\t\t\\\n+    if (big)\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tfmovem.x (-%d,fp,a0.l),#0x%x\\n\",\t\\\n+\t       foffset + fsize, fmask);\t\t\t\t\\\n+    else if (! frame_pointer_needed)\t\t\t\t\\\n+      fprintf (FILE, \"\\tfmovem.x (sp)+,#0x%x\\n\", fmask);\t\\\n+    else\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tfmovem.x (-%d,fp),#0x%x\\n\",\t\t\\\n+\t       foffset + fsize, fmask); }\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tunlk fp\\n\");\t\t\t\t\\\n+  if (current_function_pops_args)\t\t\t\t\\\n+    fprintf (FILE, \"\\trtd #%d\\n\", current_function_pops_args);\t\\\n+  else fprintf (FILE, \"\\trts\\n\"); }\n+\n+/* Difference from m68k.h is in `fp' instead of `a6'.  */\n+\n+#define REGISTER_NAMES \\\n+{\"d0\", \"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\",\t\\\n+ \"a0\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"fp\", \"sp\",\t\\\n+ \"fp0\", \"fp1\", \"fp2\", \"fp3\", \"fp4\", \"fp5\", \"fp6\", \"fp7\"}\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tmove.l %s,-(sp)\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tmove.l (sp)+,%s\\n\", reg_names[REGNO])\n+  \n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.double 0d%.20e\\n\", (VALUE))\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.space %u\\n\", (SIZE))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 13),\t\\\n+  sprintf ((OUTPUT), \"%s$$$%d\", (NAME), (LABELNO)))\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  \\\n+{ if (CODE == '.') fprintf (FILE, \".\");\t\t\t\t\t\\\n+  else if (CODE == '#') fprintf (FILE, \"#\");\t\t\t\t\\\n+  else if (CODE == '-') fprintf (FILE, \"-(sp)\");\t\t\t\\\n+  else if (CODE == '+') fprintf (FILE, \"(sp)+\");\t\t\t\\\n+  else if (CODE == '@') fprintf (FILE, \"(sp)\");\t\t\t\t\\\n+  else if (CODE == '!') fprintf (FILE, \"ccr\");\t\t\t\t\\\n+  else if (CODE == '$') {if (TARGET_68040_ONLY) fprintf (FILE, \"s\");}\t\\\n+  else if (CODE == '&') {if (TARGET_68040_ONLY) fprintf (FILE, \"d\");}\t\\\n+  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    output_address (XEXP (X, 0));\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n+    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n+      union { float f; int i; } u1;\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+      u1.f = u.d;\t\t\t\t\t\t\t\\\n+      if (CODE == 'f')\t\t\t\t\t\t\t\\\n+        fprintf (FILE, \"#0f%.9e\", u1.f);\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        fprintf (FILE, \"#0x%x\", u1.i); }\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != DImode)\t\\\n+    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+      fprintf (FILE, \"#0d%.20e\", u.d); }\t\t\t\t\\\n+  else if (CODE == 'b') output_addr_const (FILE, X);\t\t\t\\\n+  else { putc ('#', FILE); output_addr_const (FILE, X); }}\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+{ register rtx reg1, reg2, breg, ireg;\t\t\t\t\t\\\n+  register rtx addr = ADDR;\t\t\t\t\t\t\\\n+  rtx offset;\t\t\t\t\t\t\t\t\\\n+  switch (GET_CODE (addr))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+    case REG:\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"(%s)\", reg_names[REGNO (addr)]);\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case PRE_DEC:\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"-(%s)\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case POST_INC:\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"(%s)+\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case PLUS:\t\t\t\t\t\t\t\t\\\n+      reg1 = 0;\treg2 = 0;\t\t\t\t\t\t\\\n+      ireg = 0;\tbreg = 0;\t\t\t\t\t\t\\\n+      offset = 0;\t\t\t\t\t\t\t\\\n+      if (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) != PLUS) ;\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == SIGN_EXTEND)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == SIGN_EXTEND)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == MULT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == MULT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT\t\t\\\n+\t  || GET_CODE (addr) == SIGN_EXTEND)\t\t\t\t\\\n+\t{ if (reg1 == 0) reg1 = addr; else reg2 = addr; addr = 0; }\t\\\n+      if (offset != 0) { if (addr != 0) abort (); addr = offset; }\t\\\n+      if ((reg1 && (GET_CODE (reg1) == SIGN_EXTEND\t\t\t\\\n+\t\t    || GET_CODE (reg1) == MULT))\t\t\t\\\n+\t  || (reg2 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg2))))\t\t\\\n+\t{ breg = reg2; ireg = reg1; }\t\t\t\t\t\\\n+      else if (reg1 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg1)))\t\t\\\n+\t{ breg = reg1; ireg = reg2; }\t\t\t\t\t\\\n+      if (ireg != 0 && breg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n+        { int scale = 1;\t\t\t\t\t\t\\\n+\t  if (GET_CODE (ireg) == MULT)\t\t\t\t\t\\\n+\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n+\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n+\t  if (GET_CODE (ireg) == SIGN_EXTEND)\t\t\t\t\\\n+\t    fprintf (FILE, \"(L%d.b,pc,%s.w\",\t\t\t\t\\\n+\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n+\t\t     reg_names[REGNO (XEXP (ireg, 0))]); \t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"(L%d.b,pc,%s.l\",\t\t\t\t\\\n+\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n+\t\t     reg_names[REGNO (ireg)]);\t\t\t\t\\\n+\t  if (scale != 1) fprintf (FILE, \"*%d\", scale);\t\t\t\\\n+\t  putc (')', FILE);\t\t\t\t\t\t\\\n+\t  break; }\t\t\t\t\t\t\t\\\n+      if (breg != 0 && ireg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n+        { fprintf (FILE, \"(L%d.b,pc,%s.l\",\t\t\t\t\\\n+\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n+\t\t   reg_names[REGNO (breg)]);\t\t\t\t\\\n+\t  putc (')', FILE);\t\t\t\t\t\t\\\n+\t  break; }\t\t\t\t\t\t\t\\\n+      if (ireg != 0 || breg != 0)\t\t\t\t\t\\\n+\t{ int scale = 1;\t\t\t\t\t\t\\\n+\t  if (breg == 0)\t\t\t\t\t\t\\\n+\t    abort ();\t\t\t\t\t\t\t\\\n+\t  if (addr && GET_CODE (addr) == LABEL_REF) abort ();\t\t\\\n+\t  fprintf (FILE, \"(\");\t\t\t\t\t\t\\\n+\t  if (addr != 0) {\t\t\t\t\t\t\\\n+\t    output_addr_const (FILE, addr);\t\t\t\t\\\n+\t    putc (',', FILE); }\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"%s\", reg_names[REGNO (breg)]);\t\t\\\n+\t  if (ireg != 0)\t\t\t\t\t\t\\\n+\t    putc (',', FILE);\t\t\t\t\t\t\\\n+\t  if (ireg != 0 && GET_CODE (ireg) == MULT)\t\t\t\\\n+\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n+\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n+\t  if (ireg != 0 && GET_CODE (ireg) == SIGN_EXTEND)\t\t\\\n+\t    fprintf (FILE, \"%s.w\", reg_names[REGNO (XEXP (ireg, 0))]);\t\\\n+\t  else if (ireg != 0)\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"%s.l\", reg_names[REGNO (ireg)]);\t\t\\\n+\t  if (scale != 1) fprintf (FILE, \"*%d\", scale);\t\t\t\\\n+\t  putc (')', FILE);\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (reg1 != 0 && GET_CODE (addr) == LABEL_REF)\t\t\\\n+\t{ fprintf (FILE, \"(L%d.b,pc,%s.l)\",\t\t\t\t\\\n+\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n+\t\t   reg_names[REGNO (reg1)]);\t\t\t\t\\\n+\t  break; }\t\t\t\t\t\t\t\\\n+    default:\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) == CONST_INT\t\t\t\t\t\\\n+\t  && INTVAL (addr) < 0x8000\t\t\t\t\t\\\n+\t  && INTVAL (addr) >= -0x8000)\t\t\t\t\t\\\n+\tfprintf (FILE, \"%d.w\", INTVAL (addr));\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        output_addr_const (FILE, addr);\t\t\t\t\t\\\n+    }}\n+\n+#else /* Using GAS, which uses the MIT assembler syntax, like a Sun.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABEL_NO) \\\n+   fprintf (FILE, \"\\tmovl #LP%d,d0\\n\\tjsr mcount\\n\", (LABEL_NO));\n+\n+#endif /* MOTOROLA */"}]}