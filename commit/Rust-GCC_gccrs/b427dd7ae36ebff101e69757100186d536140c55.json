{"sha": "b427dd7ae36ebff101e69757100186d536140c55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQyN2RkN2FlMzZlYmZmMTAxZTY5NzU3MTAwMTg2ZDUzNjE0MGM1NQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2012-04-25T02:32:56Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2012-04-25T02:32:56Z"}, "message": "rs6000 (SAVE_INLINE_VRS, [...]): Define.\n\ngcc/\n\t* config/rs6000/rs6000 (SAVE_INLINE_VRS, REST_INLINE_VRS,\n\tV_SAVE_INLINE, SAVRES_LR, SAVRES_SAVE, SAVRES_REG,\n\tSAVRES_GPR, SAVRES_FPR, SAVRES_VR): Define.\n\t(no_global_regs_above): Delete.\n\t(no_global_regs): New function.\n\t(rs6000_savres_strategy): Handle vector regs.  Use proper lr_save_p\n\tvalue for load multiple test.\n\t(savres_routine_syms): Increase size.\n\t(rs6000_savres_routine_name, rs6000_savres_routine_sym,\n\tptr_regno_for_savres, rs6000_emit_savres_rtx): Pass in int selector\n\trather than a number of boolean flags.  Update all callers.\n\t(rs6000_savres_routine_name): Generate vector save/restore names.\n\t(rs6000_savres_routine_sym): Handle vector regs.  Delete forward decl.\n\t(ptr_regno_for_savres, rs6000_emit_savres_rtx): Likewise.\n\t(rs6000_emit_prologue): Delete saving_FPRs_inline, saving_GPRs_inline\n\tand using_store_multiple.  Expand uses.  Don't always use r11 as\n\tframe reg when needed for out-of-line saves.  Set up initial offset\n\tfor out-of-line vector saves when buying stack frame.  Handle pointer\n\treg setup for out-of-line fp save.  Emit call to out-of-line vector\n\tsave function.  Choose r11 or r12 for vrsave reg when available for\n\tbetter scheduling.\n\t(rs6000_output_function_prologue): Don't emit .extern for ELF.\n\t(rs6000_emit_epilogue): Choose a better frame reg when restoring\n\tfrom back-chain to suit out-of-line vector restore functions.  Emit\n\tcall to out-of-line vector restore function.  Adjust register used\n\tfor cr restore.  Tweak pointer register setup for gpr restore.\n\t* config/rs6000/rs6000.h (FIRST_SAVED_GP_REGNO): Take into account\n\tFIXED_R13.\n\t* config/rs6000/sysv4.h (FP_SAVE_INLINE, GP_SAVE_INLINE): Simplify.\n\t(V_SAVE_INLINE): Define.\n\t* config/rs6000/altivec.md (save_vregs_*, restore_vregs_*): New insns.\nlibgcc/\n\t* config/rs6000/crtsavevr.S: New file.\n\t* config/rs6000/crtrestvr.S: New file.\n\t* config/rs6000/t-savresfgpr: Build the above.\n\t* config/rs6000/t-netbsd: Likewise.\n\nFrom-SVN: r186800", "tree": {"sha": "ca7ce0ff5e24f9843632cabb82dece865bffe38a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca7ce0ff5e24f9843632cabb82dece865bffe38a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b427dd7ae36ebff101e69757100186d536140c55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b427dd7ae36ebff101e69757100186d536140c55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b427dd7ae36ebff101e69757100186d536140c55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b427dd7ae36ebff101e69757100186d536140c55/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1bf7c2a71c1de08df6772d0d9f4b2e0d357f0e11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bf7c2a71c1de08df6772d0d9f4b2e0d357f0e11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bf7c2a71c1de08df6772d0d9f4b2e0d357f0e11"}], "stats": {"total": 960, "additions": 749, "deletions": 211}, "files": [{"sha": "4daecb4776ece5c369352534919f26c80c831830", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b427dd7ae36ebff101e69757100186d536140c55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b427dd7ae36ebff101e69757100186d536140c55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b427dd7ae36ebff101e69757100186d536140c55", "patch": "@@ -1,3 +1,37 @@\n+2012-04-25  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/rs6000 (SAVE_INLINE_VRS, REST_INLINE_VRS,\n+\tV_SAVE_INLINE, SAVRES_LR, SAVRES_SAVE, SAVRES_REG,\n+\tSAVRES_GPR, SAVRES_FPR, SAVRES_VR): Define.\n+\t(no_global_regs_above): Delete.\n+\t(no_global_regs): New function.\n+\t(rs6000_savres_strategy): Handle vector regs.  Use proper lr_save_p\n+\tvalue for load multiple test.\n+\t(savres_routine_syms): Increase size.\n+\t(rs6000_savres_routine_name, rs6000_savres_routine_sym,\n+\tptr_regno_for_savres, rs6000_emit_savres_rtx): Pass in int selector\n+\trather than a number of boolean flags.  Update all callers.\n+\t(rs6000_savres_routine_name): Generate vector save/restore names.\n+\t(rs6000_savres_routine_sym): Handle vector regs.  Delete forward decl.\n+\t(ptr_regno_for_savres, rs6000_emit_savres_rtx): Likewise.\n+\t(rs6000_emit_prologue): Delete saving_FPRs_inline, saving_GPRs_inline\n+\tand using_store_multiple.  Expand uses.  Don't always use r11 as\n+\tframe reg when needed for out-of-line saves.  Set up initial offset\n+\tfor out-of-line vector saves when buying stack frame.  Handle pointer\n+\treg setup for out-of-line fp save.  Emit call to out-of-line vector\n+\tsave function.  Choose r11 or r12 for vrsave reg when available for\n+\tbetter scheduling.\n+\t(rs6000_output_function_prologue): Don't emit .extern for ELF.\n+\t(rs6000_emit_epilogue): Choose a better frame reg when restoring\n+\tfrom back-chain to suit out-of-line vector restore functions.  Emit\n+\tcall to out-of-line vector restore function.  Adjust register used\n+\tfor cr restore.  Tweak pointer register setup for gpr restore.\n+\t* config/rs6000/rs6000.h (FIRST_SAVED_GP_REGNO): Take into account\n+\tFIXED_R13.\n+\t* config/rs6000/sysv4.h (FP_SAVE_INLINE, GP_SAVE_INLINE): Simplify.\n+\t(V_SAVE_INLINE): Define.\n+\t* config/rs6000/altivec.md (save_vregs_*, restore_vregs_*): New insns.\n+\n 2012-04-25  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/rs6000.c (rs6000_savres_strategy): Allow"}, {"sha": "42e8dd6a9d4395f89dce7387a798f01a59829e16", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b427dd7ae36ebff101e69757100186d536140c55/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b427dd7ae36ebff101e69757100186d536140c55/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=b427dd7ae36ebff101e69757100186d536140c55", "patch": "@@ -313,6 +313,68 @@\n  \"TARGET_MACHO && (DEFAULT_ABI == ABI_DARWIN) && TARGET_32BIT\"\n  \"b %z1\")\n \n+;; The save_vregs and restore_vregs patterns don't use memory_operand\n+;; because (plus (reg) (const_int)) is not a valid vector address.\n+;; This way is more compact than describing exactly what happens in\n+;; the out-of-line functions, ie. loading the constant into r11/r12\n+;; then using indexed addressing, and requires less editing of rtl\n+;; to describe the operation to dwarf2out_frame_debug_expr.\n+(define_insn \"*save_vregs_<mode>_r11\"\n+  [(match_parallel 0 \"any_parallel_operand\"\n+     [(clobber (reg:P 65))\n+      (use (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n+      (clobber (reg:P 11))\n+      (use (reg:P 0))\n+      (set (mem:V4SI (plus:P (match_operand:P 2 \"gpc_reg_operand\" \"b\")\n+\t\t\t     (match_operand:P 3 \"short_cint_operand\" \"I\")))\n+\t   (match_operand:V4SI 4 \"gpc_reg_operand\" \"v\"))])]\n+  \"\"\n+  \"bl %1\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*save_vregs_<mode>_r12\"\n+  [(match_parallel 0 \"any_parallel_operand\"\n+     [(clobber (reg:P 65))\n+      (use (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n+      (clobber (reg:P 12))\n+      (use (reg:P 0))\n+      (set (mem:V4SI (plus:P (match_operand:P 2 \"gpc_reg_operand\" \"b\")\n+\t\t\t     (match_operand:P 3 \"short_cint_operand\" \"I\")))\n+\t   (match_operand:V4SI 4 \"gpc_reg_operand\" \"v\"))])]\n+  \"\"\n+  \"bl %1\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*restore_vregs_<mode>_r11\"\n+  [(match_parallel 0 \"any_parallel_operand\"\n+     [(clobber (reg:P 65))\n+      (use (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n+      (clobber (reg:P 11))\n+      (use (reg:P 0))\n+      (set (match_operand:V4SI 2 \"gpc_reg_operand\" \"=v\")\n+\t   (mem:V4SI (plus:P (match_operand:P 3 \"gpc_reg_operand\" \"b\")\n+\t\t\t     (match_operand:P 4 \"short_cint_operand\" \"I\"))))])]\n+  \"\"\n+  \"bl %1\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*restore_vregs_<mode>_r12\"\n+  [(match_parallel 0 \"any_parallel_operand\"\n+     [(clobber (reg:P 65))\n+      (use (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n+      (clobber (reg:P 12))\n+      (use (reg:P 0))\n+      (set (match_operand:V4SI 2 \"gpc_reg_operand\" \"=v\")\n+\t   (mem:V4SI (plus:P (match_operand:P 3 \"gpc_reg_operand\" \"b\")\n+\t\t\t     (match_operand:P 4 \"short_cint_operand\" \"I\"))))])]\n+  \"\"\n+  \"bl %1\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4\")])\n+\n ;; Simple binary operations.\n \n ;; add"}, {"sha": "eccbbdfc45ae8330f789937042d2457ee556aa7e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 454, "deletions": 202, "changes": 656, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b427dd7ae36ebff101e69757100186d536140c55/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b427dd7ae36ebff101e69757100186d536140c55/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b427dd7ae36ebff101e69757100186d536140c55", "patch": "@@ -937,7 +937,6 @@ static bool legitimate_small_data_p (enum machine_mode, rtx);\n static bool legitimate_lo_sum_address_p (enum machine_mode, rtx, int);\n static struct machine_function * rs6000_init_machine_status (void);\n static bool rs6000_assemble_integer (rtx, unsigned int, int);\n-static bool no_global_regs_above (int, bool);\n #if defined (HAVE_GAS_HIDDEN) && !TARGET_MACHO\n static void rs6000_assemble_visibility (tree, int);\n #endif\n@@ -950,7 +949,6 @@ static tree rs6000_handle_struct_attribute (tree *, tree, tree, int, bool *);\n static void rs6000_eliminate_indexed_memrefs (rtx operands[2]);\n static const char *rs6000_mangle_type (const_tree);\n static void rs6000_set_default_type_attributes (tree);\n-static rtx rs6000_savres_routine_sym (rs6000_stack_t *, bool, bool, bool);\n static bool rs6000_reg_live_or_pic_offset_p (int);\n static tree rs6000_builtin_vectorized_libmass (tree, tree, tree);\n static tree rs6000_builtin_vectorized_function (tree, tree, tree);\n@@ -17405,6 +17403,21 @@ is_altivec_return_reg (rtx reg, void *xyes)\n }\n \n \f\n+/* Look for user-defined global regs in the range FIRST to LAST-1.\n+   We should not restore these, and so cannot use lmw or out-of-line\n+   restore functions if there are any.  We also can't save them\n+   (well, emit frame notes for them), because frame unwinding during\n+   exception handling will restore saved registers.  */\n+\n+static bool\n+global_regs_p (unsigned first, unsigned last)\n+{\n+  while (first < last)\n+    if (global_regs[first++])\n+      return true;\n+  return false;\n+}\n+\n /* Determine the strategy for savings/restoring registers.  */\n \n enum {\n@@ -17415,56 +17428,80 @@ enum {\n   REST_INLINE_GPRS = 0x10,\n   SAVE_NOINLINE_GPRS_SAVES_LR = 0x20,\n   SAVE_NOINLINE_FPRS_SAVES_LR = 0x40,\n-  REST_NOINLINE_FPRS_DOESNT_RESTORE_LR = 0x80\n+  REST_NOINLINE_FPRS_DOESNT_RESTORE_LR = 0x80,\n+  SAVE_INLINE_VRS = 0x100,\n+  REST_INLINE_VRS = 0x200\n };\n \n+#ifndef V_SAVE_INLINE\n+#define V_SAVE_INLINE(FIRST_REG) 1\n+#endif\n+\n static int\n rs6000_savres_strategy (rs6000_stack_t *info,\n \t\t\tbool using_static_chain_p)\n {\n   int strategy = 0;\n+  bool lr_save_p;\n \n   if (TARGET_MULTIPLE\n       && !TARGET_POWERPC64\n       && !(TARGET_SPE_ABI && info->spe_64bit_regs_used)\n       && info->first_gp_reg_save < 31\n-      && no_global_regs_above (info->first_gp_reg_save, /*gpr=*/true))\n+      && !global_regs_p (info->first_gp_reg_save, 32))\n     strategy |= SAVRES_MULTIPLE;\n \n   if (crtl->calls_eh_return\n       || cfun->machine->ra_need_lr)\n     strategy |= (SAVE_INLINE_FPRS | REST_INLINE_FPRS\n-\t\t | SAVE_INLINE_GPRS | REST_INLINE_GPRS);\n+\t\t | SAVE_INLINE_GPRS | REST_INLINE_GPRS\n+\t\t | SAVE_INLINE_VRS | REST_INLINE_VRS);\n \n   if (info->first_fp_reg_save == 64\n       || FP_SAVE_INLINE (info->first_fp_reg_save)\n       /* The out-of-line FP routines use double-precision stores;\n \t we can't use those routines if we don't have such stores.  */\n       || (TARGET_HARD_FLOAT && !TARGET_DOUBLE_FLOAT)\n-      || !no_global_regs_above (info->first_fp_reg_save, /*gpr=*/false))\n+      || global_regs_p (info->first_fp_reg_save, 64))\n     strategy |= SAVE_INLINE_FPRS | REST_INLINE_FPRS;\n \n   if (info->first_gp_reg_save == 32\n       || GP_SAVE_INLINE (info->first_gp_reg_save)\n-      || !((strategy & SAVRES_MULTIPLE)\n-\t   || no_global_regs_above (info->first_gp_reg_save, /*gpr=*/true)))\n+      || (!(strategy & SAVRES_MULTIPLE)\n+\t  && global_regs_p (info->first_gp_reg_save, 32)))\n     strategy |= SAVE_INLINE_GPRS | REST_INLINE_GPRS;\n \n+  if (info->first_altivec_reg_save == LAST_ALTIVEC_REGNO + 1\n+      || V_SAVE_INLINE (info->first_altivec_reg_save)\n+      || global_regs_p (info->first_altivec_reg_save, LAST_ALTIVEC_REGNO + 1))\n+    strategy |= SAVE_INLINE_VRS | REST_INLINE_VRS;\n+\n   /* Don't bother to try to save things out-of-line if r11 is occupied\n      by the static chain.  It would require too much fiddling and the\n      static chain is rarely used anyway.  FPRs are saved w.r.t the stack\n      pointer on Darwin, and AIX uses r1 or r12.  */\n   if (using_static_chain_p && DEFAULT_ABI != ABI_AIX)\n     strategy |= ((DEFAULT_ABI == ABI_DARWIN\n \t\t  ? 0 : SAVE_INLINE_FPRS | REST_INLINE_FPRS)\n-\t\t | SAVE_INLINE_GPRS);\n+\t\t | SAVE_INLINE_GPRS\n+\t\t | SAVE_INLINE_VRS | REST_INLINE_VRS);\n \n   /* If we are going to use store multiple, then don't even bother\n      with the out-of-line routines, since the store-multiple\n      instruction will always be smaller.  */\n   if ((strategy & SAVRES_MULTIPLE))\n     strategy |= SAVE_INLINE_GPRS;\n \n+  /* info->lr_save_p isn't yet set if the only reason lr needs to be\n+     saved is an out-of-line save or restore.  Set up the value for\n+     the next test (excluding out-of-line gpr restore).  */\n+  lr_save_p = (info->lr_save_p\n+\t       || !(strategy & SAVE_INLINE_GPRS)\n+\t       || !(strategy & SAVE_INLINE_FPRS)\n+\t       || !(strategy & SAVE_INLINE_VRS)\n+\t       || !(strategy & REST_INLINE_FPRS)\n+\t       || !(strategy & REST_INLINE_VRS));\n+\n   /* The situation is more complicated with load multiple.  We'd\n      prefer to use the out-of-line routines for restores, since the\n      \"exit\" out-of-line routines can handle the restore of LR and the\n@@ -17474,7 +17511,7 @@ rs6000_savres_strategy (rs6000_stack_t *info,\n      have saved some fprs; In those cases it is advantageous to use\n      load multiple when available.  */\n   if ((strategy & SAVRES_MULTIPLE)\n-      && (!info->lr_save_p\n+      && (!lr_save_p\n \t  || info->first_fp_reg_save != 64))\n     strategy |= REST_INLINE_GPRS;\n \n@@ -17868,8 +17905,10 @@ rs6000_stack_info (void)\n \n   if (!(info_ptr->savres_strategy & SAVE_INLINE_GPRS)\n       || !(info_ptr->savres_strategy & SAVE_INLINE_FPRS)\n+      || !(info_ptr->savres_strategy & SAVE_INLINE_VRS)\n       || !(info_ptr->savres_strategy & REST_INLINE_GPRS)\n-      || !(info_ptr->savres_strategy & REST_INLINE_FPRS))\n+      || !(info_ptr->savres_strategy & REST_INLINE_FPRS)\n+      || !(info_ptr->savres_strategy & REST_INLINE_VRS))\n     info_ptr->lr_save_p = 1;\n \n   if (info_ptr->lr_save_p)\n@@ -18965,30 +19004,25 @@ gen_frame_mem_offset (enum machine_mode mode, rtx reg, int offset)\n   return gen_frame_mem (mode, gen_rtx_PLUS (Pmode, reg, offset_rtx));\n }\n \n-/* Look for user-defined global regs.  We should not save and restore these,\n-   and cannot use stmw/lmw if there are any in its range.  */\n-\n-static bool\n-no_global_regs_above (int first, bool gpr)\n-{\n-  int i;\n-  int last = gpr ? 32 : 64;\n-  for (i = first; i < last; i++)\n-    if (global_regs[i])\n-      return false;\n-  return true;\n-}\n-\n #ifndef TARGET_FIX_AND_CONTINUE\n #define TARGET_FIX_AND_CONTINUE 0\n #endif\n \n-/* It's really GPR 13 and FPR 14, but we need the smaller of the two.  */\n+/* It's really GPR 13 or 14, FPR 14 and VR 20.  We need the smallest.  */\n #define FIRST_SAVRES_REGISTER FIRST_SAVED_GP_REGNO\n #define LAST_SAVRES_REGISTER 31\n #define N_SAVRES_REGISTERS (LAST_SAVRES_REGISTER - FIRST_SAVRES_REGISTER + 1)\n \n-static GTY(()) rtx savres_routine_syms[N_SAVRES_REGISTERS][8];\n+enum {\n+  SAVRES_LR = 0x1,\n+  SAVRES_SAVE = 0x2,\n+  SAVRES_REG = 0x0c,\n+  SAVRES_GPR = 0,\n+  SAVRES_FPR = 4,\n+  SAVRES_VR  = 8\n+};\n+\n+static GTY(()) rtx savres_routine_syms[N_SAVRES_REGISTERS][12];\n \n /* Temporary holding space for an out-of-line register save/restore\n    routine name.  */\n@@ -18998,8 +19032,7 @@ static char savres_routine_name[30];\n    We are saving/restoring GPRs if GPR is true.  */\n \n static char *\n-rs6000_savres_routine_name (rs6000_stack_t *info, int regno,\n-\t\t\t    bool savep, bool gpr, bool lr)\n+rs6000_savres_routine_name (rs6000_stack_t *info, int regno, int sel)\n {\n   const char *prefix = \"\";\n   const char *suffix = \"\";\n@@ -19035,50 +19068,61 @@ rs6000_savres_routine_name (rs6000_stack_t *info, int regno,\n   if (TARGET_SPE)\n     {\n       /* No floating point saves on the SPE.  */\n-      gcc_assert (gpr);\n+      gcc_assert ((sel & SAVRES_REG) == SAVRES_GPR);\n \n-      if (savep)\n+      if ((sel & SAVRES_SAVE))\n \tprefix = info->spe_64bit_regs_used ? \"_save64gpr_\" : \"_save32gpr_\";\n       else\n \tprefix = info->spe_64bit_regs_used ? \"_rest64gpr_\" : \"_rest32gpr_\";\n \n-      if (lr)\n+      if ((sel & SAVRES_LR))\n \tsuffix = \"_x\";\n     }\n   else if (DEFAULT_ABI == ABI_V4)\n     {\n       if (TARGET_64BIT)\n \tgoto aix_names;\n \n-      if (gpr)\n-\tprefix = savep ? \"_savegpr_\" : \"_restgpr_\";\n+      if ((sel & SAVRES_REG) == SAVRES_GPR)\n+\tprefix = (sel & SAVRES_SAVE) ? \"_savegpr_\" : \"_restgpr_\";\n+      else if ((sel & SAVRES_REG) == SAVRES_FPR)\n+\tprefix = (sel & SAVRES_SAVE) ? \"_savefpr_\" : \"_restfpr_\";\n+      else if ((sel & SAVRES_REG) == SAVRES_VR)\n+\tprefix = (sel & SAVRES_SAVE) ? \"_savevr_\" : \"_restvr_\";\n       else\n-\tprefix = savep ? \"_savefpr_\" : \"_restfpr_\";\n+\tabort ();\n \n-      if (lr)\n+      if ((sel & SAVRES_LR))\n \tsuffix = \"_x\";\n     }\n   else if (DEFAULT_ABI == ABI_AIX)\n     {\n #if !defined (POWERPC_LINUX) && !defined (POWERPC_FREEBSD)\n       /* No out-of-line save/restore routines for GPRs on AIX.  */\n-      gcc_assert (!TARGET_AIX || !gpr);\n+      gcc_assert (!TARGET_AIX || (sel & SAVRES_REG) != SAVRES_GPR);\n #endif\n \n     aix_names:\n-      if (gpr)\n-\tprefix = (savep\n-\t\t  ? (lr ? \"_savegpr0_\" : \"_savegpr1_\")\n-\t\t  : (lr ? \"_restgpr0_\" : \"_restgpr1_\"));\n+      if ((sel & SAVRES_REG) == SAVRES_GPR)\n+\tprefix = ((sel & SAVRES_SAVE)\n+\t\t  ? ((sel & SAVRES_LR) ? \"_savegpr0_\" : \"_savegpr1_\")\n+\t\t  : ((sel & SAVRES_LR) ? \"_restgpr0_\" : \"_restgpr1_\"));\n+      else if ((sel & SAVRES_REG) == SAVRES_FPR)\n+\t{\n #if defined (POWERPC_LINUX) || defined (POWERPC_FREEBSD)\n-      else if (lr)\n-\tprefix = (savep ? \"_savefpr_\" : \"_restfpr_\");\n+\t  if ((sel & SAVRES_LR))\n+\t    prefix = ((sel & SAVRES_SAVE) ? \"_savefpr_\" : \"_restfpr_\");\n+\t  else\n #endif\n-      else\n-\t{\n-\t  prefix = savep ? SAVE_FP_PREFIX : RESTORE_FP_PREFIX;\n-\t  suffix = savep ? SAVE_FP_SUFFIX : RESTORE_FP_SUFFIX;\n+\t    {\n+\t      prefix = (sel & SAVRES_SAVE) ? SAVE_FP_PREFIX : RESTORE_FP_PREFIX;\n+\t      suffix = (sel & SAVRES_SAVE) ? SAVE_FP_SUFFIX : RESTORE_FP_SUFFIX;\n+\t    }\n \t}\n+      else if ((sel & SAVRES_REG) == SAVRES_VR)\n+\tprefix = (sel & SAVRES_SAVE) ? \"_savevr_\" : \"_restvr_\";\n+      else\n+\tabort ();\n     }\n \n    if (DEFAULT_ABI == ABI_DARWIN)\n@@ -19088,14 +19132,19 @@ rs6000_savres_routine_name (rs6000_stack_t *info, int regno,\n \t single symbol for the start of save sequence, and the code here\n \t embeds an offset into that code on the basis of the first register\n \t to be saved.  */\n-      prefix = savep ? \"save\" : \"rest\" ;\n-      if (gpr)\n-\tsprintf (savres_routine_name, \"*%sGPR%s%s%.0d ; %s r%d-r31\",\n-\t       prefix, (lr ? \"x\" : \"\"), (regno == 13 ? \"\" : \"+\"),\n-\t       (regno-13) * 4, prefix, regno);\n+      prefix = (sel & SAVRES_SAVE) ? \"save\" : \"rest\" ;\n+      if ((sel & SAVRES_REG) == SAVRES_GPR)\n+\tsprintf (savres_routine_name, \"*%sGPR%s%s%.0d ; %s r%d-r31\", prefix,\n+\t\t ((sel & SAVRES_LR) ? \"x\" : \"\"), (regno == 13 ? \"\" : \"+\"),\n+\t\t (regno - 13) * 4, prefix, regno);\n+      else if ((sel & SAVRES_REG) == SAVRES_FPR)\n+\tsprintf (savres_routine_name, \"*%sFP%s%.0d ; %s f%d-f31\", prefix,\n+\t\t (regno == 14 ? \"\" : \"+\"), (regno - 14) * 4, prefix, regno);\n+      else if ((sel & SAVRES_REG) == SAVRES_VR)\n+\tsprintf (savres_routine_name, \"*%sVEC%s%.0d ; %s v%d-v31\", prefix,\n+\t\t (regno == 20 ? \"\" : \"+\"), (regno - 20) * 8, prefix, regno);\n       else\n-\tsprintf (savres_routine_name, \"*%sFP%s%.0d ; %s f%d-f31\",\n-\t       prefix, (regno == 14 ? \"\" : \"+\"),  (regno-14) * 4, prefix, regno);\n+\tabort ();\n     }\n   else\n     sprintf (savres_routine_name, \"%s%d%s\", prefix, regno, suffix);\n@@ -19107,30 +19156,36 @@ rs6000_savres_routine_name (rs6000_stack_t *info, int regno,\n    We are saving/restoring GPRs if GPR is true.  */\n \n static rtx\n-rs6000_savres_routine_sym (rs6000_stack_t *info, bool savep,\n-\t\t\t   bool gpr, bool lr)\n+rs6000_savres_routine_sym (rs6000_stack_t *info, int sel)\n {\n-  int regno = gpr ? info->first_gp_reg_save : (info->first_fp_reg_save - 32);\n+  int regno = ((sel & SAVRES_REG) == SAVRES_GPR\n+\t       ? info->first_gp_reg_save\n+\t       : (sel & SAVRES_REG) == SAVRES_FPR\n+\t       ? info->first_fp_reg_save - 32\n+\t       : (sel & SAVRES_REG) == SAVRES_VR\n+\t       ? info->first_altivec_reg_save - FIRST_ALTIVEC_REGNO\n+\t       : -1);\n   rtx sym;\n-  int select = ((savep ? 1 : 0) << 2\n-\t\t| ((TARGET_SPE_ABI\n-\t\t    /* On the SPE, we never have any FPRs, but we do have\n-\t\t       32/64-bit versions of the routines.  */\n-\t\t    ? (info->spe_64bit_regs_used ? 1 : 0)\n-\t\t    : (gpr ? 1 : 0)) << 1)\n-\t\t| (lr ? 1: 0));\n+  int select = sel;\n+\n+  /* On the SPE, we never have any FPRs, but we do have 32/64-bit\n+     versions of the gpr routines.  */\n+  if (TARGET_SPE_ABI && (sel & SAVRES_REG) == SAVRES_GPR\n+      && info->spe_64bit_regs_used)\n+    select ^= SAVRES_FPR ^ SAVRES_GPR;\n \n   /* Don't generate bogus routine names.  */\n   gcc_assert (FIRST_SAVRES_REGISTER <= regno\n-\t      && regno <= LAST_SAVRES_REGISTER);\n+\t      && regno <= LAST_SAVRES_REGISTER\n+\t      && select >= 0 && select <= 12);\n \n   sym = savres_routine_syms[regno-FIRST_SAVRES_REGISTER][select];\n \n   if (sym == NULL)\n     {\n       char *name;\n \n-      name = rs6000_savres_routine_name (info, regno, savep, gpr, lr);\n+      name = rs6000_savres_routine_name (info, regno, sel);\n \n       sym = savres_routine_syms[regno-FIRST_SAVRES_REGISTER][select]\n \t= gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n@@ -19176,11 +19231,11 @@ rs6000_emit_stack_reset (rs6000_stack_t *info,\n }\n \n static inline unsigned\n-ptr_regno_for_savres (bool gpr, bool lr)\n+ptr_regno_for_savres (int sel)\n {\n   if (DEFAULT_ABI == ABI_AIX)\n-    return !gpr || lr ? 1 : 12;\n-  return DEFAULT_ABI == ABI_DARWIN && !gpr ? 1 : 11;\n+    return (sel & SAVRES_REG) == SAVRES_FPR || (sel & SAVRES_LR) ? 1 : 12;\n+  return DEFAULT_ABI == ABI_DARWIN && (sel & SAVRES_REG) == SAVRES_FPR ? 1 : 11;\n }\n \n /* Construct a parallel rtx describing the effect of a call to an\n@@ -19190,8 +19245,7 @@ ptr_regno_for_savres (bool gpr, bool lr)\n static rtx\n rs6000_emit_savres_rtx (rs6000_stack_t *info,\n \t\t\trtx frame_reg_rtx, int save_area_offset, int lr_offset,\n-\t\t\tenum machine_mode reg_mode,\n-\t\t\tbool savep, bool gpr, bool lr)\n+\t\t\tenum machine_mode reg_mode, int sel)\n {\n   int i;\n   int offset, start_reg, end_reg, n_regs, use_reg;\n@@ -19201,25 +19255,46 @@ rs6000_emit_savres_rtx (rs6000_stack_t *info,\n   rtx par, insn;\n \n   offset = 0;\n-  start_reg = (gpr\n+  start_reg = ((sel & SAVRES_REG) == SAVRES_GPR\n \t       ? info->first_gp_reg_save\n-\t       : info->first_fp_reg_save);\n-  end_reg = gpr ? 32 : 64;\n+\t       : (sel & SAVRES_REG) == SAVRES_FPR\n+\t       ? info->first_fp_reg_save\n+\t       : (sel & SAVRES_REG) == SAVRES_VR\n+\t       ? info->first_altivec_reg_save\n+\t       : -1);\n+  end_reg = ((sel & SAVRES_REG) == SAVRES_GPR\n+\t     ? 32\n+\t     : (sel & SAVRES_REG) == SAVRES_FPR\n+\t     ? 64\n+\t     : (sel & SAVRES_REG) == SAVRES_VR\n+\t     ? LAST_ALTIVEC_REGNO + 1\n+\t     : -1);\n   n_regs = end_reg - start_reg;\n-  p = rtvec_alloc ((lr ? 4 : 3) + n_regs);\n+  p = rtvec_alloc (3 + ((sel & SAVRES_LR) ? 1 : 0)\n+\t\t   + ((sel & SAVRES_REG) == SAVRES_VR ? 1 : 0)\n+\t\t   + n_regs);\n \n-  if (!savep && lr)\n+  if (!(sel & SAVRES_SAVE) && (sel & SAVRES_LR))\n     RTVEC_ELT (p, offset++) = ret_rtx;\n \n   RTVEC_ELT (p, offset++)\n     = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, LR_REGNO));\n \n-  sym = rs6000_savres_routine_sym (info, savep, gpr, lr);\n+  sym = rs6000_savres_routine_sym (info, sel);\n   RTVEC_ELT (p, offset++) = gen_rtx_USE (VOIDmode, sym);\n-  use_reg = ptr_regno_for_savres (gpr, lr);\n-  RTVEC_ELT (p, offset++)\n-    = gen_rtx_USE (VOIDmode,\n-\t\t   gen_rtx_REG (Pmode, use_reg));\n+\n+  use_reg = ptr_regno_for_savres (sel);\n+  if ((sel & SAVRES_REG) == SAVRES_VR)\n+    {\n+      /* Vector regs are saved/restored using [reg+reg] addressing.  */\n+      RTVEC_ELT (p, offset++)\n+\t= gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, use_reg));\n+      RTVEC_ELT (p, offset++)\n+\t= gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, 0));\n+    }\n+  else\n+    RTVEC_ELT (p, offset++)\n+      = gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, use_reg));\n \n   for (i = 0; i < end_reg - start_reg; i++)\n     {\n@@ -19230,11 +19305,11 @@ rs6000_emit_savres_rtx (rs6000_stack_t *info,\n       mem = gen_frame_mem (reg_mode, addr);\n \n       RTVEC_ELT (p, i + offset) = gen_rtx_SET (VOIDmode,\n-\t\t\t\t\t       savep ? mem : reg,\n-\t\t\t\t\t       savep ? reg : mem);\n+\t\t\t\t\t       (sel & SAVRES_SAVE) ? mem : reg,\n+\t\t\t\t\t       (sel & SAVRES_SAVE) ? reg : mem);\n     }\n \n-  if (savep && lr)\n+  if ((sel & SAVRES_SAVE) && (sel & SAVRES_LR))\n     {\n       rtx addr, reg, mem;\n       reg = gen_rtx_REG (Pmode, 0);\n@@ -19246,7 +19321,7 @@ rs6000_emit_savres_rtx (rs6000_stack_t *info,\n \n   par = gen_rtx_PARALLEL (VOIDmode, p);\n \n-  if (!savep && lr)\n+  if (!(sel & SAVRES_SAVE) && (sel & SAVRES_LR))\n     {\n       insn = emit_jump_insn (par);\n       JUMP_LABEL (insn) = ret_rtx;\n@@ -19291,9 +19366,6 @@ rs6000_emit_prologue (void)\n   rtx cr_save_rtx = NULL_RTX;\n   rtx insn;\n   int strategy;\n-  int saving_FPRs_inline;\n-  int saving_GPRs_inline;\n-  int using_store_multiple;\n   int using_static_chain_p = (cfun->static_chain_decl != NULL_TREE\n \t\t\t      && df_regs_ever_live_p (STATIC_CHAIN_REGNUM)\n \t\t\t      && call_used_regs[STATIC_CHAIN_REGNUM]);\n@@ -19469,9 +19541,6 @@ rs6000_emit_prologue (void)\n     }\n \n   strategy = info->savres_strategy;\n-  using_store_multiple = strategy & SAVRES_MULTIPLE;\n-  saving_FPRs_inline = strategy & SAVE_INLINE_FPRS;\n-  saving_GPRs_inline = strategy & SAVE_INLINE_GPRS;\n \n   /* For V.4, update stack before we do any saving and set back pointer.  */\n   if (! WORLD_SAVE_P (info)\n@@ -19480,29 +19549,27 @@ rs6000_emit_prologue (void)\n \t  || crtl->calls_eh_return))\n     {\n       bool need_r11 = (TARGET_SPE\n-\t\t       ? (!saving_GPRs_inline\n+\t\t       ? (!(strategy & SAVE_INLINE_GPRS)\n \t\t\t  && info->spe_64bit_regs_used == 0)\n-\t\t       : (!saving_FPRs_inline || !saving_GPRs_inline));\n+\t\t       : (!(strategy & SAVE_INLINE_FPRS)\n+\t\t\t  || !(strategy & SAVE_INLINE_GPRS)\n+\t\t\t  || !(strategy & SAVE_INLINE_VRS)));\n+      int ptr_regno = -1;\n       rtx ptr_reg = NULL_RTX;\n+      int ptr_off = 0;\n \n-      if (need_r11)\n-\t{\n-\t  ptr_reg = gen_rtx_REG (Pmode, 11);\n-\t  START_USE (11);\n-\t}\n-      else if (info->total_size < 32767)\n+      if (info->total_size < 32767)\n \tframe_off = info->total_size;\n+      else if (need_r11)\n+\tptr_regno = 11;\n       else if (info->cr_save_p\n \t       || info->lr_save_p\n \t       || info->first_fp_reg_save < 64\n \t       || info->first_gp_reg_save < 32\n \t       || info->altivec_size != 0\n \t       || info->vrsave_mask != 0\n \t       || crtl->calls_eh_return)\n-\t{\n-\t  ptr_reg = gen_rtx_REG (Pmode, 12);\n-\t  START_USE (12);\n-\t}\n+\tptr_regno = 12;\n       else\n \t{\n \t  /* The prologue won't be saving any regs so there is no need\n@@ -19512,17 +19579,22 @@ rs6000_emit_prologue (void)\n \t     changes to this function.  */\n \t  frame_off = info->total_size;\n \t}\n-      if (ptr_reg != NULL_RTX)\n+      if (ptr_regno != -1)\n \t{\n \t  /* Set up the frame offset to that needed by the first\n \t     out-of-line save function.  */\n+\t  START_USE (ptr_regno);\n+\t  ptr_reg = gen_rtx_REG (Pmode, ptr_regno);\n \t  frame_reg_rtx = ptr_reg;\n-\t  if (!saving_FPRs_inline && info->first_fp_reg_save < 64)\n+\t  if (!(strategy & SAVE_INLINE_FPRS) && info->fp_size != 0)\n \t    gcc_checking_assert (info->fp_save_offset + info->fp_size == 0);\n-\t  else if (!saving_GPRs_inline && info->first_gp_reg_save < 32)\n-\t    frame_off = -(info->gp_save_offset + info->gp_size);\n+\t  else if (!(strategy & SAVE_INLINE_GPRS) && info->first_gp_reg_save < 32)\n+\t    ptr_off = info->gp_save_offset + info->gp_size;\n+\t  else if (!(strategy & SAVE_INLINE_VRS) && info->altivec_size != 0)\n+\t    ptr_off = info->altivec_save_offset + info->altivec_size;\n+\t  frame_off = -ptr_off;\n \t}\n-      rs6000_emit_allocate_stack (info->total_size, ptr_reg, -frame_off);\n+      rs6000_emit_allocate_stack (info->total_size, ptr_reg, ptr_off);\n       sp_off = info->total_size;\n       if (frame_reg_rtx != sp_reg_rtx)\n \trs6000_emit_stack_tie (frame_reg_rtx, false);\n@@ -19560,7 +19632,6 @@ rs6000_emit_prologue (void)\n \t\t   && !(strategy & (SAVE_INLINE_GPRS\n \t\t\t\t    | SAVE_NOINLINE_GPRS_SAVES_LR))\n \t\t   ? 11 : 12);\n-  cr_save_regno = DEFAULT_ABI == ABI_AIX && !saving_GPRs_inline ? 11 : 12;\n   if (!WORLD_SAVE_P (info)\n       && info->cr_save_p\n       && REGNO (frame_reg_rtx) != cr_save_regno\n@@ -19585,7 +19656,7 @@ rs6000_emit_prologue (void)\n \n   /* Do any required saving of fpr's.  If only one or two to save, do\n      it ourselves.  Otherwise, call function.  */\n-  if (!WORLD_SAVE_P (info) && saving_FPRs_inline)\n+  if (!WORLD_SAVE_P (info) && (strategy & SAVE_INLINE_FPRS))\n     {\n       int i;\n       for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n@@ -19601,17 +19672,24 @@ rs6000_emit_prologue (void)\n   else if (!WORLD_SAVE_P (info) && info->first_fp_reg_save != 64)\n     {\n       bool lr = (strategy & SAVE_NOINLINE_FPRS_SAVES_LR) != 0;\n-      unsigned ptr_regno = ptr_regno_for_savres (/*gpr=*/false, lr);\n+      int sel = SAVRES_SAVE | SAVRES_FPR | (lr ? SAVRES_LR : 0);\n+      unsigned ptr_regno = ptr_regno_for_savres (sel);\n+      rtx ptr_reg = frame_reg_rtx;\n \n-      gcc_checking_assert (ptr_regno == REGNO (frame_reg_rtx)\n-\t\t\t   && info->fp_save_offset + info->fp_size == 0\n-\t\t\t   && frame_off == 0);\n-      insn = rs6000_emit_savres_rtx (info, frame_reg_rtx,\n+      if (REGNO (frame_reg_rtx) == ptr_regno)\n+\tgcc_checking_assert (frame_off == 0);\n+      else\n+\t{\n+\t  ptr_reg = gen_rtx_REG (Pmode, ptr_regno);\n+\t  NOT_INUSE (ptr_regno);\n+\t  emit_insn (gen_add3_insn (ptr_reg,\n+\t\t\t\t    frame_reg_rtx, GEN_INT (frame_off)));\n+\t}\n+      insn = rs6000_emit_savres_rtx (info, ptr_reg,\n \t\t\t\t     info->fp_save_offset,\n \t\t\t\t     info->lr_save_offset,\n-\t\t\t\t     DFmode,\n-\t\t\t\t     /*savep=*/true, /*gpr=*/false, lr);\n-      rs6000_frame_related (insn, frame_reg_rtx, sp_off,\n+\t\t\t\t     DFmode, sel);\n+      rs6000_frame_related (insn, ptr_reg, sp_off,\n \t\t\t    NULL_RTX, NULL_RTX);\n       if (lr)\n \tEND_USE (0);\n@@ -19635,7 +19713,7 @@ rs6000_emit_prologue (void)\n       int spe_regs_addressable\n \t= (SPE_CONST_OFFSET_OK (info->spe_gp_save_offset + frame_off\n \t\t\t\t+ reg_size * (32 - info->first_gp_reg_save - 1))\n-\t   && saving_GPRs_inline);\n+\t   && (strategy & SAVE_INLINE_GPRS));\n \n       if (spe_regs_addressable)\n \t{\n@@ -19649,7 +19727,7 @@ rs6000_emit_prologue (void)\n \t     it is, then temporarily save it in r0.  */\n \t  HOST_WIDE_INT offset;\n \n-\t  if (!saving_GPRs_inline)\n+\t  if (!(strategy & SAVE_INLINE_GPRS))\n \t    ool_adjust = 8 * (info->first_gp_reg_save\n \t\t\t      - (FIRST_SAVRES_REGISTER + 1));\n \t  offset = info->spe_gp_save_offset + frame_off - ool_adjust;\n@@ -19674,7 +19752,7 @@ rs6000_emit_prologue (void)\n \t    frame_off = -info->spe_gp_save_offset + ool_adjust;\n \t}\n \n-      if (saving_GPRs_inline)\n+      if ((strategy & SAVE_INLINE_GPRS))\n \t{\n \t  for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n \t    if (rs6000_reg_live_or_pic_offset_p (info->first_gp_reg_save + i))\n@@ -19688,10 +19766,8 @@ rs6000_emit_prologue (void)\n \t{\n \t  insn = rs6000_emit_savres_rtx (info, spe_save_area_ptr,\n \t\t\t\t\t info->spe_gp_save_offset + save_off,\n-\t\t\t\t\t info->lr_save_offset + save_off,\n-\t\t\t\t\t reg_mode,\n-\t\t\t\t\t /*savep=*/true, /*gpr=*/true,\n-\t\t\t\t\t /*lr=*/false);\n+\t\t\t\t\t 0, reg_mode,\n+\t\t\t\t\t SAVRES_SAVE | SAVRES_GPR);\n \n \t  rs6000_frame_related (insn, spe_save_area_ptr, sp_off - save_off,\n \t\t\t\tNULL_RTX, NULL_RTX);\n@@ -19709,10 +19785,11 @@ rs6000_emit_prologue (void)\n \t    END_USE (11);\n \t}\n     }\n-  else if (!WORLD_SAVE_P (info) && !saving_GPRs_inline)\n+  else if (!WORLD_SAVE_P (info) && !(strategy & SAVE_INLINE_GPRS))\n     {\n       bool lr = (strategy & SAVE_NOINLINE_GPRS_SAVES_LR) != 0;\n-      unsigned ptr_regno = ptr_regno_for_savres (/*gpr=*/true, lr);\n+      int sel = SAVRES_SAVE | SAVRES_GPR | (lr ? SAVRES_LR : 0);\n+      unsigned ptr_regno = ptr_regno_for_savres (sel);\n       rtx ptr_reg = frame_reg_rtx;\n       bool ptr_set_up = REGNO (ptr_reg) == ptr_regno;\n       int end_save = info->gp_save_offset + info->gp_size;\n@@ -19741,14 +19818,13 @@ rs6000_emit_prologue (void)\n       insn = rs6000_emit_savres_rtx (info, ptr_reg,\n \t\t\t\t     info->gp_save_offset + ptr_off,\n \t\t\t\t     info->lr_save_offset + ptr_off,\n-\t\t\t\t     reg_mode,\n-\t\t\t\t     /*savep=*/true, /*gpr=*/true, lr);\n+\t\t\t\t     reg_mode, sel);\n       rs6000_frame_related (insn, ptr_reg, sp_off - ptr_off,\n \t\t\t    NULL_RTX, NULL_RTX);\n       if (lr)\n \tEND_USE (0);\n     }\n-  else if (!WORLD_SAVE_P (info) && using_store_multiple)\n+  else if (!WORLD_SAVE_P (info) && (strategy & SAVRES_MULTIPLE))\n     {\n       rtvec p;\n       int i;\n@@ -19908,24 +19984,31 @@ rs6000_emit_prologue (void)\n       && !(DEFAULT_ABI == ABI_V4 || crtl->calls_eh_return))\n     {\n       rtx ptr_reg = NULL;\n+      int ptr_off = 0;\n \n       /* If saving altivec regs we need to be able to address all save\n \t locations using a 16-bit offset.  */\n-      if ((info->altivec_size != 0\n-\t   && (info->altivec_save_offset + info->altivec_size - 16\n-\t       + info->total_size - frame_off) > 32767)\n+      if ((strategy & SAVE_INLINE_VRS) == 0\n+\t  || (info->altivec_size != 0\n+\t      && (info->altivec_save_offset + info->altivec_size - 16\n+\t\t  + info->total_size - frame_off) > 32767)\n \t  || (info->vrsave_mask != 0\n \t      && (info->vrsave_save_offset\n \t\t  + info->total_size - frame_off) > 32767))\n \t{\n-\t  START_USE (12);\n-\t  ptr_reg = gen_rtx_REG (Pmode, 12);\n+\t  int sel = SAVRES_SAVE | SAVRES_VR;\n+\t  unsigned ptr_regno = ptr_regno_for_savres (sel);\n+\n+\t  if (REGNO (frame_reg_rtx) != ptr_regno)\n+\t    START_USE (ptr_regno);\n+\t  ptr_reg = gen_rtx_REG (Pmode, ptr_regno);\n \t  frame_reg_rtx = ptr_reg;\n-\t  frame_off = -(info->altivec_save_offset + info->altivec_size);\n+\t  ptr_off = info->altivec_save_offset + info->altivec_size;\n+\t  frame_off = -ptr_off;\n \t}\n       else if (REGNO (frame_reg_rtx) == 1)\n \tframe_off = info->total_size;\n-      rs6000_emit_allocate_stack (info->total_size, ptr_reg, -frame_off);\n+      rs6000_emit_allocate_stack (info->total_size, ptr_reg, ptr_off);\n       sp_off = info->total_size;\n       if (frame_reg_rtx != sp_reg_rtx)\n \trs6000_emit_stack_tie (frame_reg_rtx, false);\n@@ -19940,13 +20023,48 @@ rs6000_emit_prologue (void)\n     }\n \n   /* Save AltiVec registers if needed.  Save here because the red zone does\n-     not include AltiVec registers.  */\n-  if (!WORLD_SAVE_P (info) && TARGET_ALTIVEC_ABI && info->altivec_size != 0)\n+     not always include AltiVec registers.  */\n+  if (!WORLD_SAVE_P (info) && TARGET_ALTIVEC_ABI\n+      && info->altivec_size != 0 && (strategy & SAVE_INLINE_VRS) == 0)\n+    {\n+      int end_save = info->altivec_save_offset + info->altivec_size;\n+      int ptr_off;\n+      /* Oddly, the vector save/restore functions point r0 at the end\n+\t of the save area, then use r11 or r12 to load offsets for\n+\t [reg+reg] addressing.  */\n+      rtx ptr_reg = gen_rtx_REG (Pmode, 0);\n+      int scratch_regno = ptr_regno_for_savres (SAVRES_SAVE | SAVRES_VR);\n+      rtx scratch_reg = gen_rtx_REG (Pmode, scratch_regno);\n+\n+      gcc_checking_assert (scratch_regno == 11 || scratch_regno == 12);\n+      NOT_INUSE (0);\n+      if (end_save + frame_off != 0)\n+\t{\n+\t  rtx offset = GEN_INT (end_save + frame_off);\n+\n+\t  emit_insn (gen_add3_insn (ptr_reg, frame_reg_rtx, offset));\n+\t}\n+      else\n+\temit_move_insn (ptr_reg, frame_reg_rtx);\n+\n+      ptr_off = -end_save;\n+      insn = rs6000_emit_savres_rtx (info, scratch_reg,\n+\t\t\t\t     info->altivec_save_offset + ptr_off,\n+\t\t\t\t     0, V4SImode, SAVRES_SAVE | SAVRES_VR);\n+      rs6000_frame_related (insn, scratch_reg, sp_off - ptr_off,\n+\t\t\t    NULL_RTX, NULL_RTX);\n+      if (REGNO (frame_reg_rtx) == REGNO (scratch_reg))\n+\t{\n+\t  /* The oddity mentioned above clobbered our frame reg.  */\n+\t  emit_move_insn (frame_reg_rtx, ptr_reg);\n+\t  frame_off = ptr_off;\n+\t}\n+    }\n+  else if (!WORLD_SAVE_P (info) && TARGET_ALTIVEC_ABI\n+\t   && info->altivec_size != 0)\n     {\n       int i;\n \n-      /* There should be a non inline version of this, for when we\n-\t are saving lots of vector registers.  */\n       for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)\n \tif (info->vrsave_mask & ALTIVEC_REG_BIT (i))\n \t  {\n@@ -19987,12 +20105,23 @@ rs6000_emit_prologue (void)\n     {\n       rtx reg, mem, vrsave;\n       int offset;\n+      int save_regno;\n \n       /* Get VRSAVE onto a GPR.  Note that ABI_V4 might be using r12\n \t as frame_reg_rtx and r11 as the static chain pointer for\n \t nested functions.  */\n-      NOT_INUSE (0);\n-      reg = gen_rtx_REG (SImode, 0);\n+      save_regno = 12;\n+      if (DEFAULT_ABI == ABI_AIX && !using_static_chain_p)\n+\tsave_regno = 11;\n+      else if (REGNO (frame_reg_rtx) == 12)\n+\t{\n+\t  save_regno = 11;\n+\t  if (using_static_chain_p)\n+\t    save_regno = 0;\n+\t}\n+\n+      NOT_INUSE (save_regno);\n+      reg = gen_rtx_REG (SImode, save_regno);\n       vrsave = gen_rtx_REG (SImode, VRSAVE_REGNO);\n       if (TARGET_MACHO)\n \temit_insn (gen_get_vrsave_internal (reg));\n@@ -20105,21 +20234,25 @@ rs6000_output_function_prologue (FILE *file,\n   /* Write .extern for any function we will call to save and restore\n      fp values.  */\n   if (info->first_fp_reg_save < 64\n-      && !TARGET_MACHO)\n+      && !TARGET_MACHO\n+      && !TARGET_ELF)\n     {\n       char *name;\n       int regno = info->first_fp_reg_save - 32;\n \n       if ((info->savres_strategy & SAVE_INLINE_FPRS) == 0)\n \t{\n-\t  name = rs6000_savres_routine_name (info, regno, /*savep=*/true,\n-\t\t\t\t\t     /*gpr=*/false, /*lr=*/false);\n+\t  bool lr = (info->savres_strategy & SAVE_NOINLINE_FPRS_SAVES_LR) != 0;\n+\t  int sel = SAVRES_SAVE | SAVRES_FPR | (lr ? SAVRES_LR : 0);\n+\t  name = rs6000_savres_routine_name (info, regno, sel);\n \t  fprintf (file, \"\\t.extern %s\\n\", name);\n \t}\n       if ((info->savres_strategy & REST_INLINE_FPRS) == 0)\n \t{\n-\t  name = rs6000_savres_routine_name (info, regno, /*savep=*/false,\n-\t\t\t\t\t     /*gpr=*/false, /*lr=*/true);\n+\t  bool lr = (info->savres_strategy\n+\t\t     & REST_NOINLINE_FPRS_DOESNT_RESTORE_LR) == 0;\n+\t  int sel = SAVRES_FPR | (lr ? SAVRES_LR : 0);\n+\t  name = rs6000_savres_routine_name (info, regno, sel);\n \t  fprintf (file, \"\\t.extern %s\\n\", name);\n \t}\n     }\n@@ -20398,40 +20531,80 @@ rs6000_emit_epilogue (int sibcall)\n \t      && offset_below_red_zone_p (info->altivec_save_offset))))\n     {\n       int i;\n+      int scratch_regno = ptr_regno_for_savres (SAVRES_VR);\n \n+      gcc_checking_assert (scratch_regno == 11 || scratch_regno == 12);\n       if (use_backchain_to_restore_sp)\n \t{\n-\t  frame_reg_rtx = gen_rtx_REG (Pmode, 11);\n+\t  int frame_regno = 11;\n+\n+\t  if ((strategy & REST_INLINE_VRS) == 0)\n+\t    {\n+\t      /* Of r11 and r12, select the one not clobbered by an\n+\t\t out-of-line restore function for the frame register.  */\n+\t      frame_regno = 11 + 12 - scratch_regno;\n+\t    }\n+\t  frame_reg_rtx = gen_rtx_REG (Pmode, frame_regno);\n \t  emit_move_insn (frame_reg_rtx,\n \t\t\t  gen_rtx_MEM (Pmode, sp_reg_rtx));\n \t  frame_off = 0;\n \t}\n       else if (frame_pointer_needed)\n \tframe_reg_rtx = hard_frame_pointer_rtx;\n \n-      for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)\n-\tif (info->vrsave_mask & ALTIVEC_REG_BIT (i))\n-\t  {\n-\t    rtx addr, areg, mem, reg;\n+      if ((strategy & REST_INLINE_VRS) == 0)\n+\t{\n+\t  int end_save = info->altivec_save_offset + info->altivec_size;\n+\t  int ptr_off;\n+\t  rtx ptr_reg = gen_rtx_REG (Pmode, 0);\n+\t  rtx scratch_reg = gen_rtx_REG (Pmode, scratch_regno);\n \n-\t    areg = gen_rtx_REG (Pmode, 0);\n-\t    emit_move_insn\n-\t      (areg, GEN_INT (info->altivec_save_offset\n-\t\t\t      + frame_off\n-\t\t\t      + 16 * (i - info->first_altivec_reg_save)));\n+\t  if (end_save + frame_off != 0)\n+\t    {\n+\t      rtx offset = GEN_INT (end_save + frame_off);\n \n-\t    /* AltiVec addressing mode is [reg+reg].  */\n-\t    addr = gen_rtx_PLUS (Pmode, frame_reg_rtx, areg);\n-\t    mem = gen_frame_mem (V4SImode, addr);\n+\t      emit_insn (gen_add3_insn (ptr_reg, frame_reg_rtx, offset));\n+\t    }\n+\t  else\n+\t    emit_move_insn (ptr_reg, frame_reg_rtx);\n \n-\t    reg = gen_rtx_REG (V4SImode, i);\n-\t    emit_move_insn (reg, mem);\n-\t    if (flag_shrink_wrap\n-\t\t|| offset_below_red_zone_p (info->altivec_save_offset\n-\t\t\t\t\t    + (i - info->first_altivec_reg_save)\n-\t\t\t\t\t    * 16))\n-\t      cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n-\t\t\t\t\t     cfa_restores);\n+\t  ptr_off = -end_save;\n+\t  insn = rs6000_emit_savres_rtx (info, scratch_reg,\n+\t\t\t\t\t info->altivec_save_offset + ptr_off,\n+\t\t\t\t\t 0, V4SImode, SAVRES_VR);\n+\t}\n+      else\n+\t{\n+\t  for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)\n+\t    if (info->vrsave_mask & ALTIVEC_REG_BIT (i))\n+\t      {\n+\t\trtx addr, areg, mem, reg;\n+\n+\t\tareg = gen_rtx_REG (Pmode, 0);\n+\t\temit_move_insn\n+\t\t  (areg, GEN_INT (info->altivec_save_offset\n+\t\t\t\t  + frame_off\n+\t\t\t\t  + 16 * (i - info->first_altivec_reg_save)));\n+\n+\t\t/* AltiVec addressing mode is [reg+reg].  */\n+\t\taddr = gen_rtx_PLUS (Pmode, frame_reg_rtx, areg);\n+\t\tmem = gen_frame_mem (V4SImode, addr);\n+\n+\t\treg = gen_rtx_REG (V4SImode, i);\n+\t\temit_move_insn (reg, mem);\n+\t      }\n+\t}\n+\n+      for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)\n+\tif (((strategy & REST_INLINE_VRS) == 0\n+\t     || (info->vrsave_mask & ALTIVEC_REG_BIT (i)) != 0)\n+\t    && (flag_shrink_wrap\n+\t\t|| (offset_below_red_zone_p\n+\t\t    (info->altivec_save_offset\n+\t\t     + 16 * (i - info->first_altivec_reg_save)))))\n+\t  {\n+\t    rtx reg = gen_rtx_REG (V4SImode, i);\n+\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t  }\n     }\n \n@@ -20541,26 +20714,94 @@ rs6000_emit_epilogue (int sibcall)\n     {\n       int i;\n \n-      for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)\n-\tif (info->vrsave_mask & ALTIVEC_REG_BIT (i))\n-\t  {\n-\t    rtx addr, areg, mem, reg;\n+      if ((strategy & REST_INLINE_VRS) == 0)\n+\t{\n+\t  int end_save = info->altivec_save_offset + info->altivec_size;\n+\t  int ptr_off;\n+\t  rtx ptr_reg = gen_rtx_REG (Pmode, 0);\n+\t  int scratch_regno = ptr_regno_for_savres (SAVRES_VR);\n+\t  rtx scratch_reg = gen_rtx_REG (Pmode, scratch_regno);\n \n-\t    areg = gen_rtx_REG (Pmode, 0);\n-\t    emit_move_insn\n-\t      (areg, GEN_INT (info->altivec_save_offset\n-\t\t\t      + frame_off\n-\t\t\t      + 16 * (i - info->first_altivec_reg_save)));\n+\t  if (end_save + frame_off != 0)\n+\t    {\n+\t      rtx offset = GEN_INT (end_save + frame_off);\n \n-\t    /* AltiVec addressing mode is [reg+reg].  */\n-\t    addr = gen_rtx_PLUS (Pmode, frame_reg_rtx, areg);\n-\t    mem = gen_frame_mem (V4SImode, addr);\n+\t      emit_insn (gen_add3_insn (ptr_reg, frame_reg_rtx, offset));\n+\t    }\n+\t  else\n+\t    emit_move_insn (ptr_reg, frame_reg_rtx);\n \n-\t    reg = gen_rtx_REG (V4SImode, i);\n-\t    emit_move_insn (reg, mem);\n-\t    if (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap)\n-\t      cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg,\n-\t\t\t\t\t     cfa_restores);\n+\t  ptr_off = -end_save;\n+\t  insn = rs6000_emit_savres_rtx (info, scratch_reg,\n+\t\t\t\t\t info->altivec_save_offset + ptr_off,\n+\t\t\t\t\t 0, V4SImode, SAVRES_VR);\n+\t  if (REGNO (frame_reg_rtx) == REGNO (scratch_reg))\n+\t    {\n+\t      /* Frame reg was clobbered by out-of-line save.  Restore it\n+\t\t from ptr_reg, and if we are calling out-of-line gpr or\n+\t\t fpr restore set up the correct pointer and offset.  */\n+\t      unsigned newptr_regno = 1;\n+\t      if (!restoring_GPRs_inline)\n+\t\t{\n+\t\t  bool lr = info->gp_save_offset + info->gp_size == 0;\n+\t\t  int sel = SAVRES_GPR | (lr ? SAVRES_LR : 0);\n+\t\t  newptr_regno = ptr_regno_for_savres (sel);\n+\t\t  end_save = info->gp_save_offset + info->gp_size;\n+\t\t}\n+\t      else if (!restoring_FPRs_inline)\n+\t\t{\n+\t\t  bool lr = !(strategy & REST_NOINLINE_FPRS_DOESNT_RESTORE_LR);\n+\t\t  int sel = SAVRES_FPR | (lr ? SAVRES_LR : 0);\n+\t\t  newptr_regno = ptr_regno_for_savres (sel);\n+\t\t  end_save = info->gp_save_offset + info->gp_size;\n+\t\t}\n+\n+\t      if (newptr_regno != 1 && REGNO (frame_reg_rtx) != newptr_regno)\n+\t\tframe_reg_rtx = gen_rtx_REG (Pmode, newptr_regno);\n+\t\t\n+\t      if (end_save + ptr_off != 0)\n+\t\t{\n+\t\t  rtx offset = GEN_INT (end_save + ptr_off);\n+\n+\t\t  frame_off = -end_save;\n+\t\t  emit_insn (gen_add3_insn (frame_reg_rtx, ptr_reg, offset));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  frame_off = ptr_off;\n+\t\t  emit_move_insn (frame_reg_rtx, ptr_reg);\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)\n+\t    if (info->vrsave_mask & ALTIVEC_REG_BIT (i))\n+\t      {\n+\t\trtx addr, areg, mem, reg;\n+\n+\t\tareg = gen_rtx_REG (Pmode, 0);\n+\t\temit_move_insn\n+\t\t  (areg, GEN_INT (info->altivec_save_offset\n+\t\t\t\t  + frame_off\n+\t\t\t\t  + 16 * (i - info->first_altivec_reg_save)));\n+\n+\t\t/* AltiVec addressing mode is [reg+reg].  */\n+\t\taddr = gen_rtx_PLUS (Pmode, frame_reg_rtx, areg);\n+\t\tmem = gen_frame_mem (V4SImode, addr);\n+\n+\t\treg = gen_rtx_REG (V4SImode, i);\n+\t\temit_move_insn (reg, mem);\n+\t      }\n+\t}\n+\n+      for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)\n+\tif (((strategy & REST_INLINE_VRS) == 0\n+\t     || (info->vrsave_mask & ALTIVEC_REG_BIT (i)) != 0)\n+\t    && (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap))\n+\t  {\n+\t    rtx reg = gen_rtx_REG (V4SImode, i);\n+\t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t  }\n     }\n \n@@ -20599,12 +20840,24 @@ rs6000_emit_epilogue (int sibcall)\n       rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n \t\t\t       GEN_INT (info->cr_save_offset + frame_off));\n       rtx mem = gen_frame_mem (SImode, addr);\n+      unsigned cr_save_regno = 12;\n+\n+      if (!restoring_GPRs_inline)\n+\t{\n+\t  /* Ensure we don't use the register used by the out-of-line\n+\t     gpr register restore below.  */\n+\t  bool lr = info->gp_save_offset + info->gp_size == 0;\n+\t  int sel = SAVRES_GPR | (lr ? SAVRES_LR : 0);\n+\t  int gpr_ptr_regno = ptr_regno_for_savres (sel);\n+\n+\t  if (gpr_ptr_regno == 12)\n+\t    cr_save_regno = 11;\n+\t  gcc_checking_assert (REGNO (frame_reg_rtx) != cr_save_regno);\n+\t}\n+      else if (REGNO (frame_reg_rtx) == 12)\n+\tcr_save_regno = 11;\n \n-      cr_save_reg = gen_rtx_REG (SImode,\n-\t\t\t\t DEFAULT_ABI == ABI_AIX\n-\t\t\t\t && !restoring_GPRs_inline\n-\t\t\t\t && info->first_fp_reg_save < 64\n-\t\t\t\t ? 11 : 12);\n+      cr_save_reg = gen_rtx_REG (SImode, cr_save_regno);\n       emit_move_insn (cr_save_reg, mem);\n     }\n \n@@ -20705,25 +20958,27 @@ rs6000_emit_epilogue (int sibcall)\n \t\t\t\tinfo->spe_gp_save_offset + frame_off,\n \t\t\t\tinfo->lr_save_offset + frame_off,\n \t\t\t\treg_mode,\n-\t\t\t\t/*savep=*/false, /*gpr=*/true,\n-\t\t\t\t/*lr=*/true);\n+\t\t\t\tSAVRES_GPR | SAVRES_LR);\n     }\n   else if (!restoring_GPRs_inline)\n     {\n       /* We are jumping to an out-of-line function.  */\n       rtx ptr_reg;\n       int end_save = info->gp_save_offset + info->gp_size;\n       bool can_use_exit = end_save == 0;\n+      int sel = SAVRES_GPR | (can_use_exit ? SAVRES_LR : 0);\n       int ptr_off;\n \n       /* Emit stack reset code if we need it.  */\n-      ptr_regno = ptr_regno_for_savres (/*gpr=*/true, can_use_exit);\n+      ptr_regno = ptr_regno_for_savres (sel);\n       ptr_reg = gen_rtx_REG (Pmode, ptr_regno);\n       if (can_use_exit)\n \trs6000_emit_stack_reset (info, frame_reg_rtx, frame_off, ptr_regno);\n-      else\n+      else if (end_save + frame_off != 0)\n \temit_insn (gen_add3_insn (ptr_reg, frame_reg_rtx,\n \t\t\t\t  GEN_INT (end_save + frame_off)));\n+      else if (REGNO (frame_reg_rtx) != ptr_regno)\n+\temit_move_insn (ptr_reg, frame_reg_rtx);\n       if (REGNO (frame_reg_rtx) == ptr_regno)\n \tframe_off = -end_save;\n \n@@ -20734,9 +20989,7 @@ rs6000_emit_epilogue (int sibcall)\n       rs6000_emit_savres_rtx (info, ptr_reg,\n \t\t\t      info->gp_save_offset + ptr_off,\n \t\t\t      info->lr_save_offset + ptr_off,\n-\t\t\t      reg_mode,\n-\t\t\t      /*savep=*/false, /*gpr=*/true,\n-\t\t\t      /*lr=*/can_use_exit);\n+\t\t\t      reg_mode, sel);\n     }\n   else if (using_load_multiple)\n     {\n@@ -20873,7 +21126,8 @@ rs6000_emit_epilogue (int sibcall)\n   if (!restoring_FPRs_inline)\n     {\n       bool lr = (strategy & REST_NOINLINE_FPRS_DOESNT_RESTORE_LR) == 0;\n-      ptr_regno = ptr_regno_for_savres (/*gpr=*/false, lr);\n+      int sel = SAVRES_FPR | (lr ? SAVRES_LR : 0);\n+      ptr_regno = ptr_regno_for_savres (sel);\n     }\n \n   insn = rs6000_emit_stack_reset (info, frame_reg_rtx, frame_off, ptr_regno);\n@@ -20951,9 +21205,7 @@ rs6000_emit_epilogue (int sibcall)\n \t\t\t\t\t   cfa_restores);\n \n \t  sym = rs6000_savres_routine_sym (info,\n-\t\t\t\t\t   /*savep=*/false,\n-\t\t\t\t\t   /*gpr=*/false,\n-\t\t\t\t\t   /*lr=*/lr);\n+\t\t\t\t\t   SAVRES_FPR | (lr ? SAVRES_LR : 0));\n \t  RTVEC_ELT (p, 2) = gen_rtx_USE (VOIDmode, sym);\n \t  RTVEC_ELT (p, 3) = gen_rtx_USE (VOIDmode,\n \t\t\t\t\t  gen_rtx_REG (Pmode,"}, {"sha": "561c623d44f29e0ddcd32f8d8c1a16dc16704ba4", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b427dd7ae36ebff101e69757100186d536140c55/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b427dd7ae36ebff101e69757100186d536140c55/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=b427dd7ae36ebff101e69757100186d536140c55", "patch": "@@ -909,8 +909,8 @@ extern unsigned rs6000_pointer_size;\n #define TOTAL_ALTIVEC_REGS\t(LAST_ALTIVEC_REGNO - FIRST_ALTIVEC_REGNO + 1)\n \n #define FIRST_SAVED_ALTIVEC_REGNO (FIRST_ALTIVEC_REGNO+20)\n-#define FIRST_SAVED_FP_REGNO    (14+32)\n-#define FIRST_SAVED_GP_REGNO 13\n+#define FIRST_SAVED_FP_REGNO\t  (14+32)\n+#define FIRST_SAVED_GP_REGNO\t  (FIXED_R13 ? 14 : 13)\n \n /* List the order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS."}, {"sha": "8737bb14ee0e6b408800da5b0f6da905385c30b0", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b427dd7ae36ebff101e69757100186d536140c55/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b427dd7ae36ebff101e69757100186d536140c55/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=b427dd7ae36ebff101e69757100186d536140c55", "patch": "@@ -245,13 +245,16 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* Define cutoff for using external functions to save floating point.\n    When optimizing for size, use external functions when profitable.  */\n-#define FP_SAVE_INLINE(FIRST_REG) (optimize_size\t\t\t\\\n-\t\t\t\t   ? ((FIRST_REG) == 62\t\t\t\\\n-\t\t\t\t      || (FIRST_REG) == 63)\t\t\\\n-\t\t\t\t   : (FIRST_REG) < 64)\n+#define FP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) == 62\t\t\t\\\n+\t\t\t\t   || (FIRST_REG) == 63\t\t\t\\\n+\t\t\t\t   || !optimize_size)\n+\n /* And similarly for general purpose registers.  */\n-#define GP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) < 32\t\\\n-\t\t\t\t   && !optimize_size)\n+#define GP_SAVE_INLINE(FIRST_REG) (!optimize_size)\n+\n+/* And vector registers.  */\n+#define V_SAVE_INLINE(FIRST_REG) ((FIRST_REG) == LAST_ALTIVEC_REGNO\t\\\n+\t\t\t\t  || !optimize_size)\n \n /* Put jump tables in read-only memory, rather than in .text.  */\n #define JUMP_TABLES_IN_TEXT_SECTION 0"}, {"sha": "831fa12203a22819163bc9f2943dbd661358f3e7", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b427dd7ae36ebff101e69757100186d536140c55/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b427dd7ae36ebff101e69757100186d536140c55/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=b427dd7ae36ebff101e69757100186d536140c55", "patch": "@@ -1,3 +1,10 @@\n+2012-04-25  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/crtsavevr.S: New file.\n+\t* config/rs6000/crtrestvr.S: New file.\n+\t* config/rs6000/t-savresfgpr: Build the above.\n+\t* config/rs6000/t-netbsd: Likewise.\n+\n 2012-04-24  Sriraman Tallam  <tmsriram@google.com>\n \n \t* libgcc/config/i386/i386-cpuinfo.c: Set __cpu_vendor always."}, {"sha": "21c4ed08931e8f88005adc02bb0c6c26549de33e", "filename": "libgcc/config/rs6000/crtrestvr.S", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b427dd7ae36ebff101e69757100186d536140c55/libgcc%2Fconfig%2Frs6000%2Fcrtrestvr.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b427dd7ae36ebff101e69757100186d536140c55/libgcc%2Fconfig%2Frs6000%2Fcrtrestvr.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Fcrtrestvr.S?ref=b427dd7ae36ebff101e69757100186d536140c55", "patch": "@@ -0,0 +1,88 @@\n+/* Routines for restoring vector registers.\n+\n+   Copyright (C) 2012\n+   Free Software Foundation, Inc.\n+   Written by Alan Modra, IBM\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* On PowerPC64 Linux, these functions are provided by the linker.  */\n+#ifndef __powerpc64__\n+\n+#undef __ALTIVEC__\n+#define __ALTIVEC__ 1\n+\t#include \"ppc-asm.h\"\n+\n+/* Called with r0 pointing just beyond the end of the vector save area.  */\n+\n+\t.section \".text\"\n+CFI_STARTPROC\n+HIDDEN_FUNC(_restvr_20)\n+\tli r11,-192\n+\tlvx v20,r11,r0\n+HIDDEN_FUNC(_restvr_21)\n+\tli r11,-176\n+\tlvx v21,r11,r0\n+HIDDEN_FUNC(_restvr_22)\n+\tli r11,-160\n+\tlvx v22,r11,r0\n+HIDDEN_FUNC(_restvr_23)\n+\tli r11,-144\n+\tlvx v23,r11,r0\n+HIDDEN_FUNC(_restvr_24)\n+\tli r11,-128\n+\tlvx v24,r11,r0\n+HIDDEN_FUNC(_restvr_25)\n+\tli r11,-112\n+\tlvx v25,r11,r0\n+HIDDEN_FUNC(_restvr_26)\n+\tli r11,-96\n+\tlvx v26,r11,r0\n+HIDDEN_FUNC(_restvr_27)\n+\tli r11,-80\n+\tlvx v27,r11,r0\n+HIDDEN_FUNC(_restvr_28)\n+\tli r11,-64\n+\tlvx v28,r11,r0\n+HIDDEN_FUNC(_restvr_29)\n+\tli r11,-48\n+\tlvx v29,r11,r0\n+HIDDEN_FUNC(_restvr_30)\n+\tli r11,-32\n+\tlvx v30,r11,r0\n+HIDDEN_FUNC(_restvr_31)\n+\tli r11,-16\n+\tlvx v31,r11,r0\n+\tblr\n+FUNC_END(_restvr_31)\n+FUNC_END(_restvr_30)\n+FUNC_END(_restvr_29)\n+FUNC_END(_restvr_28)\n+FUNC_END(_restvr_27)\n+FUNC_END(_restvr_26)\n+FUNC_END(_restvr_25)\n+FUNC_END(_restvr_24)\n+FUNC_END(_restvr_23)\n+FUNC_END(_restvr_22)\n+FUNC_END(_restvr_21)\n+FUNC_END(_restvr_20)\n+CFI_ENDPROC\n+\n+#endif"}, {"sha": "072c7b8eb9a1597cf4d8472f8ddf8a0ce266d7b9", "filename": "libgcc/config/rs6000/crtsavevr.S", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b427dd7ae36ebff101e69757100186d536140c55/libgcc%2Fconfig%2Frs6000%2Fcrtsavevr.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b427dd7ae36ebff101e69757100186d536140c55/libgcc%2Fconfig%2Frs6000%2Fcrtsavevr.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Fcrtsavevr.S?ref=b427dd7ae36ebff101e69757100186d536140c55", "patch": "@@ -0,0 +1,88 @@\n+/* Routines for saving vector registers.\n+\n+   Copyright (C) 2012\n+   Free Software Foundation, Inc.\n+   Written by Alan Modra, IBM\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* On PowerPC64 Linux, these functions are provided by the linker.  */\n+#ifndef __powerpc64__\n+\n+#undef __ALTIVEC__\n+#define __ALTIVEC__ 1\n+\t#include \"ppc-asm.h\"\n+\n+/* Called with r0 pointing just beyond the end of the vector save area.  */\n+\n+\t.section \".text\"\n+CFI_STARTPROC\n+HIDDEN_FUNC(_savevr_20)\n+\tli r11,-192\n+\tstvx v20,r11,r0\n+HIDDEN_FUNC(_savevr_21)\n+\tli r11,-176\n+\tstvx v21,r11,r0\n+HIDDEN_FUNC(_savevr_22)\n+\tli r11,-160\n+\tstvx v22,r11,r0\n+HIDDEN_FUNC(_savevr_23)\n+\tli r11,-144\n+\tstvx v23,r11,r0\n+HIDDEN_FUNC(_savevr_24)\n+\tli r11,-128\n+\tstvx v24,r11,r0\n+HIDDEN_FUNC(_savevr_25)\n+\tli r11,-112\n+\tstvx v25,r11,r0\n+HIDDEN_FUNC(_savevr_26)\n+\tli r11,-96\n+\tstvx v26,r11,r0\n+HIDDEN_FUNC(_savevr_27)\n+\tli r11,-80\n+\tstvx v27,r11,r0\n+HIDDEN_FUNC(_savevr_28)\n+\tli r11,-64\n+\tstvx v28,r11,r0\n+HIDDEN_FUNC(_savevr_29)\n+\tli r11,-48\n+\tstvx v29,r11,r0\n+HIDDEN_FUNC(_savevr_30)\n+\tli r11,-32\n+\tstvx v30,r11,r0\n+HIDDEN_FUNC(_savevr_31)\n+\tli r11,-16\n+\tstvx v31,r11,r0\n+\tblr\n+FUNC_END(_savevr_31)\n+FUNC_END(_savevr_30)\n+FUNC_END(_savevr_29)\n+FUNC_END(_savevr_28)\n+FUNC_END(_savevr_27)\n+FUNC_END(_savevr_26)\n+FUNC_END(_savevr_25)\n+FUNC_END(_savevr_24)\n+FUNC_END(_savevr_23)\n+FUNC_END(_savevr_22)\n+FUNC_END(_savevr_21)\n+FUNC_END(_savevr_20)\n+CFI_ENDPROC\n+\n+#endif"}, {"sha": "7be8e5e6700cad2eb7bcc00fa8077445273f94b1", "filename": "libgcc/config/rs6000/t-netbsd", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b427dd7ae36ebff101e69757100186d536140c55/libgcc%2Fconfig%2Frs6000%2Ft-netbsd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b427dd7ae36ebff101e69757100186d536140c55/libgcc%2Fconfig%2Frs6000%2Ft-netbsd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ft-netbsd?ref=b427dd7ae36ebff101e69757100186d536140c55", "patch": "@@ -6,4 +6,6 @@ LIB2ADD_ST = \\\n \t$(srcdir)/config/rs6000/crtsavgpr.S \\\n \t$(srcdir)/config/rs6000/crtresgpr.S \\\n \t$(srcdir)/config/rs6000/crtresxfpr.S \\\n-\t$(srcdir)/config/rs6000/crtresxgpr.S\n+\t$(srcdir)/config/rs6000/crtresxgpr.S \\\n+\t$(srcdir)/config/rs6000/crtsavevr.S \\\n+\t$(srcdir)/config/rs6000/crtrestvr.S"}, {"sha": "a8455ae1af91153cf6b352e03149ce1f613f36d5", "filename": "libgcc/config/rs6000/t-savresfgpr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b427dd7ae36ebff101e69757100186d536140c55/libgcc%2Fconfig%2Frs6000%2Ft-savresfgpr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b427dd7ae36ebff101e69757100186d536140c55/libgcc%2Fconfig%2Frs6000%2Ft-savresfgpr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ft-savresfgpr?ref=b427dd7ae36ebff101e69757100186d536140c55", "patch": "@@ -6,6 +6,8 @@ LIB2ADD_ST += \\\n \t   $(srcdir)/config/rs6000/crtresgpr.S \\\n \t   $(srcdir)/config/rs6000/crtresxfpr.S \\\n \t   $(srcdir)/config/rs6000/crtresxgpr.S \\\n+\t   $(srcdir)/config/rs6000/crtsavevr.S \\\n+\t   $(srcdir)/config/rs6000/crtrestvr.S \\\n \t   $(srcdir)/config/rs6000/e500crtres32gpr.S \\\n \t   $(srcdir)/config/rs6000/e500crtres64gpr.S \\\n \t   $(srcdir)/config/rs6000/e500crtres64gprctr.S \\"}]}