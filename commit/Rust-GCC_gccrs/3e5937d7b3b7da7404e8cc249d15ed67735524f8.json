{"sha": "3e5937d7b3b7da7404e8cc249d15ed67735524f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U1OTM3ZDdiM2I3ZGE3NDA0ZThjYzI0OWQxNWVkNjc3MzU1MjRmOA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2007-01-18T21:30:38Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2007-01-18T21:30:38Z"}, "message": "tree-ssa-structalias.c: Update comments.\n\n2007-01-18  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree-ssa-structalias.c: Update comments.\n\t(ptabitmap_obstack): Removed.\n\t(pta_obstack): New.\n\t(oldpta_obstack): Ditto.\n\t(stats): Add a few members.\n\t(struct variable_info): Remove node, complex, address_taken, and\n\tindirect_target members. Add oldsolution member.\n\t(new_var_info): Do not initialize removed members.\n\t(constraint_expr_type): Remove INCLUDES.\n\t(constraint_graph): Add size, implicit_preds, rep,\n\tindirect_cycles, eq_rep, label, direct_nodes, and complex members.\n\t(FIRST_REF_NODE): New macro.\n\t(LAST_REF_NODE): Ditto.\n\t(FIRST_ADDR_NODE): Ditto.\n\t(find): New function.\n\t(unite): Ditto.\n\t(dump_constraint): Do not handle INCLUDES.\n\t(insert_into_complex): Do not insert duplicate constraints.\n\t(condense_varmap_nodes): Renamed and rewritten into ...\n\t(merge_node_constraints): This. Also fix bug in handling of\n\toffseted copy constraints.\n\t(clear_edges_for_node): No longer need to deal with preds at all,\n\tor removing associated preds/succs. \n\t(merge_graph_nodes): Deal with indirect_cycles.\n\tDon't deal with predecessors.\n\t(add_implicit_graph_edge): New function.\n\t(add_pred_graph_edge): Ditto.\n\t(add_graph_edge): Don't deal with predecessors.\n\t(build_constraint_graph): Removed.\n\t(build_pred_graph): New function.\n\t(build_succ_graph): Ditto.\n\t(struct scc_info): Removed in_component. Added roots, dfs, and\n\tnode_mapping. Remove visited_index, unification_queue.\n\t(scc_visit): Deal with union-find we do now.\n\tDeal with cycles with REF nodes.\n\t(collapse_nodes): Renamed and rewritten to ...\n\t(unify_nodes): This.\n\t(process_unification_queue): Removed.\n\t(topo_visit): Cleanup\n\t(do_da_constraint): Use find.\n\t(do_sd_constraint): Ditto.\n\t(do_ds_constraint): Ditto.\n\t(do_complex_constraint): Ditto.\n\t(init_scc_info): Update for removed and added members.\n\t(find_and_collapse_graph_cycles): Renamed and rewritten into ...\n\t(find_indirect_cycles): This.\n\t(equivalence_class): New variable.\n\t(label_visit): New function.\n\t(perform_variable_substitution): Rewritten.\n\t(free_var_substitution_info): New function.\n\t(find_equivalent_node): Ditto.\n\t(move_complex_constraints): Ditto.\n\t(eliminate_indirect_cycles): Ditto.\n\t(solve_graph): Only propagate changed bits.\n\tUse indirect cycle elimination.\n\tUse find.\n\t(tree_id_t): Rename to tree_vi_t, delete id member, add vi member.\n\t(tree_id_eq): Renamed to ...\n\t(tree_vi_eq): This. Update for member change\n\t(insert_id_for_tree): Renamed and rewritten to ...\n\t(insert_vi_for_tree): This.\n\t(lookup_id_for_tree): Renamed and rewritten to ...\n\t(lookup_vi_for_tree): This.\n\t(get_id_for_tree): Renamed and rewritten to ...\n\t(get_vi_for_tree): Ditto.\n\t(get_constraint_exp_from_ssa_var): Update to use get_vi_for_tree.\n\t(process_constraint): Don't handle INCLUDES.\n\tRemove special ADDRESSOF case.\n\t(find_func_aliases): Rewrite to use vi functions instead of id\n\tones.\n\t(create_function_info_for): Ditto.\n\t(create_variable_info_for): Ditto.\n\t(intra_create_variable_infos): Ditto.\n\t(merge_smts_into): Ditto.\n\t(find_what_p_points_to): Ditto.\n\t(init_base_vars): Ditto.\n\t(init_alias_vars): Ditto.\n\t(remove_preds_and_fake_succs): New function.\n\t(dump_sa_points_to_info): Dump new stats.\n\t(dump_solution_for_var): Use find.\n\t(set_used_smts): Fix formatting.\n\t(compute_points_to_sets): Updated for new functions.\n\t(ipa_pta_execute): Ditto.\n\nFrom-SVN: r120931", "tree": {"sha": "4806ffed08559623237fcf6a4b47068f63351253", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4806ffed08559623237fcf6a4b47068f63351253"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e5937d7b3b7da7404e8cc249d15ed67735524f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e5937d7b3b7da7404e8cc249d15ed67735524f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e5937d7b3b7da7404e8cc249d15ed67735524f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e5937d7b3b7da7404e8cc249d15ed67735524f8/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7896beb27a4556485b50e82e6196f2b8f0e1146a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7896beb27a4556485b50e82e6196f2b8f0e1146a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7896beb27a4556485b50e82e6196f2b8f0e1146a"}], "stats": {"total": 1619, "additions": 1086, "deletions": 533}, "files": [{"sha": "983e3d9dcbf467c2f6e431cd449b017089dee4e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e5937d7b3b7da7404e8cc249d15ed67735524f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e5937d7b3b7da7404e8cc249d15ed67735524f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3e5937d7b3b7da7404e8cc249d15ed67735524f8", "patch": "@@ -1,3 +1,89 @@\n+2007-01-18  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree-ssa-structalias.c: Update comments.\n+\t(ptabitmap_obstack): Removed.\n+\t(pta_obstack): New.\n+\t(oldpta_obstack): Ditto.\n+\t(stats): Add a few members.\n+\t(struct variable_info): Remove node, complex, address_taken, and\n+\tindirect_target members. Add oldsolution member.\n+\t(new_var_info): Do not initialize removed members.\n+\t(constraint_expr_type): Remove INCLUDES.\n+\t(constraint_graph): Add size, implicit_preds, rep,\n+\tindirect_cycles, eq_rep, label, direct_nodes, and complex members.\n+\t(FIRST_REF_NODE): New macro.\n+\t(LAST_REF_NODE): Ditto.\n+\t(FIRST_ADDR_NODE): Ditto.\n+\t(find): New function.\n+\t(unite): Ditto.\n+\t(dump_constraint): Do not handle INCLUDES.\n+\t(insert_into_complex): Do not insert duplicate constraints.\n+\t(condense_varmap_nodes): Renamed and rewritten into ...\n+\t(merge_node_constraints): This. Also fix bug in handling of\n+\toffseted copy constraints.\n+\t(clear_edges_for_node): No longer need to deal with preds at all,\n+\tor removing associated preds/succs. \n+\t(merge_graph_nodes): Deal with indirect_cycles.\n+\tDon't deal with predecessors.\n+\t(add_implicit_graph_edge): New function.\n+\t(add_pred_graph_edge): Ditto.\n+\t(add_graph_edge): Don't deal with predecessors.\n+\t(build_constraint_graph): Removed.\n+\t(build_pred_graph): New function.\n+\t(build_succ_graph): Ditto.\n+\t(struct scc_info): Removed in_component. Added roots, dfs, and\n+\tnode_mapping. Remove visited_index, unification_queue.\n+\t(scc_visit): Deal with union-find we do now.\n+\tDeal with cycles with REF nodes.\n+\t(collapse_nodes): Renamed and rewritten to ...\n+\t(unify_nodes): This.\n+\t(process_unification_queue): Removed.\n+\t(topo_visit): Cleanup\n+\t(do_da_constraint): Use find.\n+\t(do_sd_constraint): Ditto.\n+\t(do_ds_constraint): Ditto.\n+\t(do_complex_constraint): Ditto.\n+\t(init_scc_info): Update for removed and added members.\n+\t(find_and_collapse_graph_cycles): Renamed and rewritten into ...\n+\t(find_indirect_cycles): This.\n+\t(equivalence_class): New variable.\n+\t(label_visit): New function.\n+\t(perform_variable_substitution): Rewritten.\n+\t(free_var_substitution_info): New function.\n+\t(find_equivalent_node): Ditto.\n+\t(move_complex_constraints): Ditto.\n+\t(eliminate_indirect_cycles): Ditto.\n+\t(solve_graph): Only propagate changed bits.\n+\tUse indirect cycle elimination.\n+\tUse find.\n+\t(tree_id_t): Rename to tree_vi_t, delete id member, add vi member.\n+\t(tree_id_eq): Renamed to ...\n+\t(tree_vi_eq): This. Update for member change\n+\t(insert_id_for_tree): Renamed and rewritten to ...\n+\t(insert_vi_for_tree): This.\n+\t(lookup_id_for_tree): Renamed and rewritten to ...\n+\t(lookup_vi_for_tree): This.\n+\t(get_id_for_tree): Renamed and rewritten to ...\n+\t(get_vi_for_tree): Ditto.\n+\t(get_constraint_exp_from_ssa_var): Update to use get_vi_for_tree.\n+\t(process_constraint): Don't handle INCLUDES.\n+\tRemove special ADDRESSOF case.\n+\t(find_func_aliases): Rewrite to use vi functions instead of id\n+\tones.\n+\t(create_function_info_for): Ditto.\n+\t(create_variable_info_for): Ditto.\n+\t(intra_create_variable_infos): Ditto.\n+\t(merge_smts_into): Ditto.\n+\t(find_what_p_points_to): Ditto.\n+\t(init_base_vars): Ditto.\n+\t(init_alias_vars): Ditto.\n+\t(remove_preds_and_fake_succs): New function.\n+\t(dump_sa_points_to_info): Dump new stats.\n+\t(dump_solution_for_var): Use find.\n+\t(set_used_smts): Fix formatting.\n+\t(compute_points_to_sets): Updated for new functions.\n+\t(ipa_pta_execute): Ditto.\n+\n 2007-01-18  Kazu Hirata  <kazu@codesourcery.com>\n \t    Richard Sandiford  <richard@codesourcery.com>\n "}, {"sha": "e6e1c81639d481a01ca793eb88fc29fc2d0723a1", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 1000, "deletions": 533, "changes": 1533, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e5937d7b3b7da7404e8cc249d15ed67735524f8/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e5937d7b3b7da7404e8cc249d15ed67735524f8/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=3e5937d7b3b7da7404e8cc249d15ed67735524f8", "patch": "@@ -75,8 +75,7 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n    http://citeseer.ist.psu.edu/heintze01ultrafast.html\n \n    There are three types of real constraint expressions, DEREF,\n-   ADDRESSOF, and SCALAR.  There is one type of fake constraint\n-   expression, called INCLUDES.  Each constraint expression consists\n+   ADDRESSOF, and SCALAR.  Each constraint expression consists\n    of a constraint type, a variable, and an offset.\n \n    SCALAR is a constraint expression type used to represent x, whether\n@@ -85,10 +84,6 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n    it appears on the LHS or the RHS of a statement.\n    ADDRESSOF is a constraint expression used to represent &x, whether\n    it appears on the LHS or the RHS of a statement.\n-   INCLUDES is a constraint expression type used to represent just a\n-   setting of a bit in the points-to set without having the address\n-   taken.  It exists mainly for abstraction sake, and is used for\n-   initializing fake variables like the ESCAPED_VARS set.\n \n    Each pointer variable in the program is assigned an integer id, and\n    each field of a structure variable is assigned an integer id as well.\n@@ -174,12 +169,22 @@ htab_t heapvar_for_stmt;\n \n static bool use_field_sensitive = true;\n static int in_ipa_mode = 0;\n+\n+/* Used for predecessor bitmaps. */\n static bitmap_obstack predbitmap_obstack;\n-static bitmap_obstack ptabitmap_obstack;\n+\n+/* Used for points-to sets.  */\n+static bitmap_obstack pta_obstack;\n+\n+/* Used for oldsolution members of variables. */\n+static bitmap_obstack oldpta_obstack;\n+\n+/* Used for per-solver-iteration bitmaps.  */\n static bitmap_obstack iteration_obstack;\n \n static unsigned int create_variable_info_for (tree, const char *);\n-static void build_constraint_graph (void);\n+typedef struct constraint_graph *constraint_graph_t;\n+static void unify_nodes (constraint_graph_t, unsigned int, unsigned int, bool);\n \n DEF_VEC_P(constraint_t);\n DEF_VEC_ALLOC_P(constraint_t,heap);\n@@ -191,11 +196,13 @@ DEF_VEC_ALLOC_P(constraint_t,heap);\n static struct constraint_stats\n {\n   unsigned int total_vars;\n-  unsigned int collapsed_vars;\n+  unsigned int nonpointer_vars;\n   unsigned int unified_vars_static;\n   unsigned int unified_vars_dynamic;\n   unsigned int iterations;\n   unsigned int num_edges;\n+  unsigned int num_implicit_edges;\n+  unsigned int points_to_sets_created;\n } stats;\n \n struct variable_info\n@@ -221,22 +228,9 @@ struct variable_info\n   /* A link to the variable for the next field in this structure.  */\n   struct variable_info *next;\n \n-  /* Node in the graph that represents the constraints and points-to\n-     solution for the variable.  */\n-  unsigned int node;\n-\n-  /* True if the address of this variable is taken.  Needed for\n-     variable substitution.  */\n-  unsigned int address_taken:1;\n-\n-  /* True if this variable is the target of a dereference.  Needed for\n-     variable substitution.  */\n-  unsigned int indirect_target:1;\n-\n   /* True if the variable is directly the target of a dereference.\n      This is used to track which variables are *actually* dereferenced\n-     so we can prune their points to listed. This is equivalent to the\n-     indirect_target flag when no merging of variables happens.  */\n+     so we can prune their points to listed. */\n   unsigned int directly_dereferenced:1;\n \n   /* True if this is a variable created by the constraint analysis, such as\n@@ -259,20 +253,19 @@ struct variable_info\n   /* Points-to set for this variable.  */\n   bitmap solution;\n \n+  /* Old points-to set for this variable.  */\n+  bitmap oldsolution;\n+\n   /* Finished points-to set for this variable (IE what is returned\n      from find_what_p_points_to.  */\n   bitmap finished_solution;\n \n   /* Variable ids represented by this node.  */\n   bitmap variables;\n \n-  /* Vector of complex constraints for this node.  Complex\n-     constraints are those involving dereferences.  */\n-  VEC(constraint_t,heap) *complex;\n-\n-  /* Variable id this was collapsed to due to type unsafety.\n-     This should be unused completely after build_constraint_graph, or\n-     something is broken.  */\n+  /* Variable id this was collapsed to due to type unsafety.  This\n+     should be unused completely after build_succ_graph, or something\n+     is broken.  */\n   struct variable_info *collapsed_to;\n };\n typedef struct variable_info *varinfo_t;\n@@ -366,32 +359,28 @@ heapvar_insert (tree from, tree to)\n    named NAME, and using constraint graph node NODE.  */\n \n static varinfo_t\n-new_var_info (tree t, unsigned int id, const char *name, unsigned int node)\n+new_var_info (tree t, unsigned int id, const char *name)\n {\n   varinfo_t ret = pool_alloc (variable_info_pool);\n \n   ret->id = id;\n   ret->name = name;\n   ret->decl = t;\n-  ret->node = node;\n-  ret->address_taken = false;\n-  ret->indirect_target = false;\n   ret->directly_dereferenced = false;\n   ret->is_artificial_var = false;\n   ret->is_heap_var = false;\n   ret->is_special_var = false;\n   ret->is_unknown_size_var = false;\n   ret->has_union = false;\n-  ret->solution = BITMAP_ALLOC (&ptabitmap_obstack);\n-  ret->variables = BITMAP_ALLOC (&ptabitmap_obstack);\n+  ret->solution = BITMAP_ALLOC (&pta_obstack);\n+  ret->oldsolution = BITMAP_ALLOC (&oldpta_obstack);\n   ret->finished_solution = NULL;\n-  ret->complex = NULL;\n   ret->next = NULL;\n   ret->collapsed_to = NULL;\n   return ret;\n }\n \n-typedef enum {SCALAR, DEREF, ADDRESSOF, INCLUDES} constraint_expr_type;\n+typedef enum {SCALAR, DEREF, ADDRESSOF} constraint_expr_type;\n \n /* An expression that appears in a constraint.  */\n \n@@ -435,19 +424,94 @@ static VEC(constraint_t,heap) *constraints;\n static alloc_pool constraint_pool;\n \n \n+DEF_VEC_I(int);\n+DEF_VEC_ALLOC_I(int, heap);\n+\n /* The constraint graph is represented as an array of bitmaps\n    containing successor nodes.  */\n \n struct constraint_graph\n {\n+  /* Size of this graph, which may be different than the number of\n+     nodes in the variable map.  */\n+  unsigned int size;\n+\n+  /* Explicit successors of each node. */\n   bitmap *succs;\n+\n+  /* Implicit predecessors of each node (Used for variable\n+     substitution). */\n+  bitmap *implicit_preds;\n+\n+  /* Explicit predecessors of each node (Used for variable substitution).  */\n   bitmap *preds;\n-};\n \n-typedef struct constraint_graph *constraint_graph_t;\n+  /* Indirect cycle representatives, or -1 if the node has no indirect\n+     cycles.  */\n+  int *indirect_cycles;\n+\n+  /* Representative node for a node.  rep[a] == a unless the node has\n+     been unified. */\n+  unsigned int *rep;\n+\n+  /* Equivalence class representative for a node.  This is used for\n+     variable substitution.  */\n+  int *eq_rep;\n+\n+  /* Label for each node, used during variable substitution.  */\n+  unsigned int *label;\n+\n+  /* Bitmap of nodes where the bit is set if the node is a direct\n+     node.  Used for variable substitution.  */\n+  sbitmap direct_nodes;\n+\n+  /* Vector of complex constraints for each graph node.  Complex\n+     constraints are those involving dereferences or offsets that are\n+     not 0.  */\n+  VEC(constraint_t,heap) **complex;\n+};\n \n static constraint_graph_t graph;\n \n+/* During variable substitution and the offline version of indirect\n+   cycle finding, we create nodes to represent dereferences and\n+   address taken constraints.  These represent where these start and\n+   end.  */\n+#define FIRST_REF_NODE (VEC_length (varinfo_t, varmap))\n+#define LAST_REF_NODE (FIRST_REF_NODE + (FIRST_REF_NODE - 1))\n+#define FIRST_ADDR_NODE (LAST_REF_NODE + 1)\n+\n+/* Return the representative node for NODE, if NODE has been unioned\n+   with another NODE.\n+   This function performs path compression along the way to finding\n+   the representative.  */\n+\n+static unsigned int\n+find (unsigned int node)\n+{\n+  gcc_assert (node < graph->size);\n+  if (graph->rep[node] != node)\n+    return graph->rep[node] = find (graph->rep[node]);\n+  return node;\n+}\n+\n+/* Union the TO and FROM nodes to the TO nodes.\n+   Note that at some point in the future, we may want to do\n+   union-by-rank, in which case we are going to have to return the\n+   node we unified to.  */\n+\n+static bool\n+unite (unsigned int to, unsigned int from)\n+{\n+  gcc_assert (to < graph->size && from < graph->size);\n+  if (to != from && graph->rep[from] != to)\n+    {\n+      graph->rep[from] = to;\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Create a new constraint consisting of LHS and RHS expressions.  */\n \n static constraint_t\n@@ -477,13 +541,9 @@ dump_constraint (FILE *file, constraint_t c)\n     fprintf (file, \"&\");\n   else if (c->rhs.type == DEREF)\n     fprintf (file, \"*\");\n-  else if (c->rhs.type == INCLUDES)\n-    fprintf (file, \"{\");\n   fprintf (file, \"%s\", get_varinfo_fc (c->rhs.var)->name);\n   if (c->rhs.offset != 0)\n     fprintf (file, \" + \" HOST_WIDE_INT_PRINT_DEC, c->rhs.offset);\n-  if (c->rhs.type == INCLUDES)\n-    fprintf (file, \"}\");\n   fprintf (file, \"\\n\");\n }\n \n@@ -519,10 +579,11 @@ debug_constraints (void)\n    The solver is a simple worklist solver, that works on the following\n    algorithm:\n \n-   sbitmap changed_nodes = all ones;\n-   changed_count = number of nodes;\n-   For each node that was already collapsed:\n-       changed_count--;\n+   sbitmap changed_nodes = all zeroes;\n+   changed_count = 0;\n+   For each node that is not already collapsed:\n+       changed_count++;\n+       set bit in changed nodes\n \n    while (changed_count > 0)\n    {\n@@ -691,54 +752,53 @@ set_union_with_increment  (bitmap to, bitmap from, unsigned HOST_WIDE_INT inc)\n     }\n }\n \n-/* Insert constraint C into the list of complex constraints for VAR.  */\n+/* Insert constraint C into the list of complex constraints for graph\n+   node VAR.  */\n \n static void\n-insert_into_complex (unsigned int var, constraint_t c)\n+insert_into_complex (constraint_graph_t graph,\n+\t\t     unsigned int var, constraint_t c)\n {\n-  varinfo_t vi = get_varinfo (var);\n-  unsigned int place = VEC_lower_bound (constraint_t, vi->complex, c,\n+  VEC (constraint_t, heap) *complex = graph->complex[var];\n+  unsigned int place = VEC_lower_bound (constraint_t, complex, c,\n \t\t\t\t\tconstraint_less);\n-  VEC_safe_insert (constraint_t, heap, vi->complex, place, c);\n+\n+  /* Only insert constraints that do not already exist.  */\n+  if (place >= VEC_length (constraint_t, complex)\n+      || !constraint_equal (*c, *VEC_index (constraint_t, complex, place)))\n+    VEC_safe_insert (constraint_t, heap, graph->complex[var], place, c);\n }\n \n \n /* Condense two variable nodes into a single variable node, by moving\n    all associated info from SRC to TO.  */\n \n static void\n-condense_varmap_nodes (unsigned int to, unsigned int src)\n+merge_node_constraints (constraint_graph_t graph, unsigned int to,\n+\t\t\tunsigned int from)\n {\n-  varinfo_t tovi = get_varinfo (to);\n-  varinfo_t srcvi = get_varinfo (src);\n   unsigned int i;\n   constraint_t c;\n-  bitmap_iterator bi;\n \n-  /* the src node, and all its variables, are now the to node.  */\n-  srcvi->node = to;\n-  EXECUTE_IF_SET_IN_BITMAP (srcvi->variables, 0, i, bi)\n-    get_varinfo (i)->node = to;\n-\n-  /* Merge the src node variables and the to node variables.  */\n-  bitmap_set_bit (tovi->variables, src);\n-  bitmap_ior_into (tovi->variables, srcvi->variables);\n-  bitmap_clear (srcvi->variables);\n+  gcc_assert (find (from) == to);\n \n   /* Move all complex constraints from src node into to node  */\n-  for (i = 0; VEC_iterate (constraint_t, srcvi->complex, i, c); i++)\n+  for (i = 0; VEC_iterate (constraint_t, graph->complex[from], i, c); i++)\n     {\n       /* In complex constraints for node src, we may have either\n-\t a = *src, and *src = a.  */\n+\t a = *src, and *src = a, or an offseted constraint which are\n+\t always added to the rhs node's constraints.  */\n \n       if (c->rhs.type == DEREF)\n \tc->rhs.var = to;\n-      else\n+      else if (c->lhs.type == DEREF)\n \tc->lhs.var = to;\n+      else\n+\tc->rhs.var = to;\n     }\n-  constraint_set_union (&tovi->complex, &srcvi->complex);\n-  VEC_free (constraint_t, heap, srcvi->complex);\n-  srcvi->complex = NULL;\n+  constraint_set_union (&graph->complex[to], &graph->complex[from]);\n+  VEC_free (constraint_t, heap, graph->complex[from]);\n+  graph->complex[from] = NULL;\n }\n \n \n@@ -747,83 +807,86 @@ condense_varmap_nodes (unsigned int to, unsigned int src)\n static void\n clear_edges_for_node (constraint_graph_t graph, unsigned int node)\n {\n-  bitmap_iterator bi;\n-  unsigned int j;\n-\n-  /* Walk the successors, erase the associated preds.  */\n-\n-  EXECUTE_IF_IN_NONNULL_BITMAP (graph->succs[node], 0, j, bi)\n-    if (j != node)\n-      bitmap_clear_bit (graph->preds[j], node);\n-\n-\n-  /* Walk the preds, erase the associated succs.  */\n-\n-  EXECUTE_IF_IN_NONNULL_BITMAP (graph->preds[node], 0, j, bi)\n-    if (j != node)\n-      bitmap_clear_bit (graph->succs[j], node);\n-\n-\n-  if (graph->preds[node])\n-    {\n-      BITMAP_FREE (graph->preds[node]);\n-      graph->preds[node] = NULL;\n-    }\n-\n   if (graph->succs[node])\n-    {\n-      BITMAP_FREE (graph->succs[node]);\n-      graph->succs[node] = NULL;\n-    }\n+    BITMAP_FREE (graph->succs[node]);\n }\n \n-static bool edge_added = false;\n-\n /* Merge GRAPH nodes FROM and TO into node TO.  */\n \n static void\n merge_graph_nodes (constraint_graph_t graph, unsigned int to,\n \t\t   unsigned int from)\n {\n-  unsigned int j;\n-  bitmap_iterator bi;\n-\n-  /* Merge all the predecessor edges.  */\n-  if (graph->preds[from])\n+  if (graph->indirect_cycles[from] != -1)\n     {\n-      if (!graph->preds[to])\n-\tgraph->preds[to] = BITMAP_ALLOC (&predbitmap_obstack);\n-\n-      EXECUTE_IF_SET_IN_BITMAP (graph->preds[from], 0, j, bi)\n+      /* If we have indirect cycles with the from node, and we have\n+\t none on the to node, the to node has indirect cycles from the\n+\t from node now that they are unified.\n+\t If indirect cycles exist on both, unify the nodes that they\n+\t are in a cycle with, since we know they are in a cycle with\n+\t each other.  */\n+      if (graph->indirect_cycles[to] == -1)\n \t{\n-\t  if (j != to)\n-\t    {\n-\t      bitmap_clear_bit (graph->succs[j], from);\n-\t      bitmap_set_bit (graph->succs[j], to);\n-\t    }\n+\t  graph->indirect_cycles[to] = graph->indirect_cycles[from];\n+\t}\n+      else\n+\t{\n+\t  unsigned int tonode = find (graph->indirect_cycles[to]);\n+\t  unsigned int fromnode = find (graph->indirect_cycles[from]);\n+\n+\t  if (unite (tonode, fromnode))\n+\t    unify_nodes (graph, tonode, fromnode, true);\n \t}\n-      bitmap_ior_into (graph->preds[to],\n-\t\t       graph->preds[from]);\n     }\n \n   /* Merge all the successor edges.  */\n   if (graph->succs[from])\n     {\n       if (!graph->succs[to])\n-\tgraph->succs[to] = BITMAP_ALLOC (&ptabitmap_obstack);\n-      EXECUTE_IF_SET_IN_BITMAP (graph->succs[from], 0, j, bi)\n-\t{\n-\t  bitmap_clear_bit (graph->preds[j], from);\n-\t  bitmap_set_bit (graph->preds[j], to);\n-\t}\n+\tgraph->succs[to] = BITMAP_ALLOC (&pta_obstack);\n       bitmap_ior_into (graph->succs[to],\n \t\t       graph->succs[from]);\n     }\n \n   clear_edges_for_node (graph, from);\n }\n \n-/* Add a graph edge to GRAPH, going from TO to FROM if\n+\n+/* Add an indirect graph edge to GRAPH, going from TO to FROM if\n+   it doesn't exist in the graph already.  */\n+\n+static void\n+add_implicit_graph_edge (constraint_graph_t graph, unsigned int to,\n+\t\t\t unsigned int from)\n+{\n+  if (to == from)\n+    return;\n+\n+  if (!graph->implicit_preds[to])\n+    graph->implicit_preds[to] = BITMAP_ALLOC (&predbitmap_obstack);\n+\n+  if (!bitmap_bit_p (graph->implicit_preds[to], from))\n+    {\n+      stats.num_implicit_edges++;\n+      bitmap_set_bit (graph->implicit_preds[to], from);\n+    }\n+}\n+\n+/* Add a predecessor graph edge to GRAPH, going from TO to FROM if\n+   it doesn't exist in the graph already.\n+   Return false if the edge already existed, true otherwise.  */\n+\n+static void\n+add_pred_graph_edge (constraint_graph_t graph, unsigned int to,\n+\t\t     unsigned int from)\n+{\n+  if (!graph->preds[to])\n+    graph->preds[to] = BITMAP_ALLOC (&predbitmap_obstack);\n+  if (!bitmap_bit_p (graph->preds[to], from))\n+    bitmap_set_bit (graph->preds[to], from);\n+}\n+\n+/* Add a graph edge to GRAPH, going from FROM to TO if\n    it doesn't exist in the graph already.\n    Return false if the edge already existed, true otherwise.  */\n \n@@ -839,16 +902,13 @@ add_graph_edge (constraint_graph_t graph, unsigned int to,\n     {\n       bool r = false;\n \n-      if (!graph->preds[to])\n-\tgraph->preds[to] = BITMAP_ALLOC (&predbitmap_obstack);\n       if (!graph->succs[from])\n-\tgraph->succs[from] = BITMAP_ALLOC (&ptabitmap_obstack);\n+\tgraph->succs[from] = BITMAP_ALLOC (&pta_obstack);\n       if (!bitmap_bit_p (graph->succs[from], to))\n \t{\n-\t  edge_added = true;\n \t  r = true;\n-\t  stats.num_edges++;\n-\t  bitmap_set_bit (graph->preds[to], from);\n+\t  if (to < FIRST_REF_NODE && from < FIRST_REF_NODE)\n+\t    stats.num_edges++;\n \t  bitmap_set_bit (graph->succs[from], to);\n \t}\n       return r;\n@@ -866,19 +926,43 @@ valid_graph_edge (constraint_graph_t graph, unsigned int src,\n \t  && bitmap_bit_p (graph->succs[dest], src));\n }\n \n-/* Build the constraint graph.  */\n+/* Build the constraint graph, adding only predecessor edges right now.  */\n \n static void\n-build_constraint_graph (void)\n+build_pred_graph (void)\n {\n-  int i = 0;\n+  int i;\n   constraint_t c;\n-  int graph_size;\n+  unsigned int j;\n \n   graph = XNEW (struct constraint_graph);\n-  graph_size = VEC_length (varinfo_t, varmap) + 1;\n-  graph->succs = XCNEWVEC (bitmap, graph_size);\n-  graph->preds = XCNEWVEC (bitmap, graph_size);\n+  graph->size = (VEC_length (varinfo_t, varmap)) * 3;\n+  graph->succs = XCNEWVEC (bitmap, graph->size);\n+  graph->implicit_preds = XCNEWVEC (bitmap, graph->size);\n+  graph->preds = XCNEWVEC (bitmap, graph->size);\n+  graph->indirect_cycles = XNEWVEC (int, VEC_length (varinfo_t, varmap));\n+  graph->label = XCNEWVEC (unsigned int, graph->size);\n+  graph->rep = XNEWVEC (unsigned int, graph->size);\n+  graph->eq_rep = XNEWVEC (int, graph->size);\n+  graph->complex = XCNEWVEC (VEC(constraint_t, heap) *,\n+\t\t\t     VEC_length (varinfo_t, varmap));\n+  graph->direct_nodes = sbitmap_alloc (graph->size);\n+  sbitmap_zero (graph->direct_nodes);\n+\n+  for (j = 0; j < FIRST_REF_NODE; j++)\n+    {\n+      if (!get_varinfo (j)->is_special_var)\n+\tSET_BIT (graph->direct_nodes, j);\n+    }\n+\n+  for (j = 0; j < graph->size; j++)\n+    {\n+      graph->rep[j] = j;\n+      graph->eq_rep[j] = -1;\n+    }\n+\n+  for (j = 0; j < VEC_length (varinfo_t, varmap); j++)\n+    graph->indirect_cycles[j] = -1;\n \n   for (i = 0; VEC_iterate (constraint_t, constraints, i, c); i++)\n     {\n@@ -889,33 +973,92 @@ build_constraint_graph (void)\n \n       if (lhs.type == DEREF)\n \t{\n-\t  /* *x = y or *x = &y (complex) */\n-\t  if (rhs.type == ADDRESSOF || rhsvar > anything_id)\n-\t    insert_into_complex (lhsvar, c);\n+\t  /* *x = y.  */\n+\t  if (rhs.offset == 0 && lhs.offset == 0 && rhs.type == SCALAR)\n+\t    add_pred_graph_edge (graph, FIRST_REF_NODE + lhsvar, rhsvar);\n+\t  if (rhs.type == ADDRESSOF)\n+\t    RESET_BIT (graph->direct_nodes, rhsvar);\n \t}\n       else if (rhs.type == DEREF)\n \t{\n-\t  /* !special var= *y */\n-\t  if (!(get_varinfo (lhsvar)->is_special_var))\n-\t    insert_into_complex (rhsvar, c);\n+\t  /* x = *y */\n+\t  if (rhs.offset == 0 && lhs.offset == 0 && lhs.type == SCALAR)\n+\t    add_pred_graph_edge (graph, lhsvar, FIRST_REF_NODE + rhsvar);\n+\t  else\n+\t    RESET_BIT (graph->direct_nodes, lhsvar);\n \t}\n-      else if (rhs.type == ADDRESSOF || rhs.type == INCLUDES)\n+      else if (rhs.type == ADDRESSOF)\n \t{\n \t  /* x = &y */\n-\t  bitmap_set_bit (get_varinfo (lhsvar)->solution, rhsvar);\n+\t  add_pred_graph_edge (graph, lhsvar, FIRST_ADDR_NODE + rhsvar);\n+\t  /* Implicitly, *x = y */\n+\t  add_implicit_graph_edge (graph, FIRST_REF_NODE + lhsvar, rhsvar);\n+\n+\t  RESET_BIT (graph->direct_nodes, rhsvar);\n \t}\n-      else if (lhsvar > anything_id)\n+      else if (lhsvar > anything_id\n+\t       && lhsvar != rhsvar && lhs.offset == 0 && rhs.offset == 0)\n \t{\n-\t  /* Ignore self edges, as they can't possibly contribute\n-\t     anything */\n-\t  if (lhsvar != rhsvar || rhs.offset != 0 || lhs.offset != 0)\n-\t    {\n-\t      if (rhs.offset != 0 || lhs.offset != 0)\n-\t\tinsert_into_complex (rhsvar, c);\n-\t      else\n-\t\tadd_graph_edge (graph, lhs.var, rhs.var);\n-\t    }\n+\t  /* x = y */\n+\t  add_pred_graph_edge (graph, lhsvar, rhsvar);\n+\t  /* Implicitly, *x = *y */\n+\t  add_implicit_graph_edge (graph, FIRST_REF_NODE + lhsvar,\n+\t\t\t\t   FIRST_REF_NODE + rhsvar);\n+\t}\n+      else if (lhs.offset != 0 || rhs.offset != 0)\n+\t{\n+\t  if (rhs.offset != 0)\n+\t    RESET_BIT (graph->direct_nodes, lhs.var);\n+\t  if (lhs.offset != 0)\n+\t    RESET_BIT (graph->direct_nodes, rhs.var);\n+\t}\n+    }\n+}\n+\n+/* Build the constraint graph, adding successor edges.  */\n+\n+static void\n+build_succ_graph (void)\n+{\n+  int i;\n+  constraint_t c;\n+\n+  for (i = 0; VEC_iterate (constraint_t, constraints, i, c); i++)\n+    {\n+      struct constraint_expr lhs;\n+      struct constraint_expr rhs;\n+      unsigned int lhsvar;\n+      unsigned int rhsvar;\n+\n+      if (!c)\n+\tcontinue;\n \n+      lhs = c->lhs;\n+      rhs = c->rhs;\n+      lhsvar = find (get_varinfo_fc (lhs.var)->id);\n+      rhsvar = find (get_varinfo_fc (rhs.var)->id);\n+\n+      if (lhs.type == DEREF)\n+\t{\n+\t  if (rhs.offset == 0 && lhs.offset == 0 && rhs.type == SCALAR)\n+\t    add_graph_edge (graph, FIRST_REF_NODE + lhsvar, rhsvar);\n+\t}\n+      else if (rhs.type == DEREF)\n+\t{\n+\t  if (rhs.offset == 0 && lhs.offset == 0 && lhs.type == SCALAR)\n+\t    add_graph_edge (graph, lhsvar, FIRST_REF_NODE + rhsvar);\n+\t}\n+      else if (rhs.type == ADDRESSOF)\n+\t{\n+\t  /* x = &y */\n+\t  gcc_assert (find (get_varinfo_fc (rhs.var)->id)\n+\t\t      == get_varinfo_fc (rhs.var)->id);\n+\t  bitmap_set_bit (get_varinfo (lhsvar)->solution, rhsvar);\n+\t}\n+      else if (lhsvar > anything_id\n+\t       && lhsvar != rhsvar && lhs.offset == 0 && rhs.offset == 0)\n+\t{\n+\t  add_graph_edge (graph, lhsvar, rhsvar);\n \t}\n     }\n }\n@@ -934,11 +1077,11 @@ DEF_VEC_ALLOC_I(unsigned,heap);\n struct scc_info\n {\n   sbitmap visited;\n-  sbitmap in_component;\n+  sbitmap roots;\n+  unsigned int *dfs;\n+  unsigned int *node_mapping;\n   int current_index;\n-  unsigned int *visited_index;\n   VEC(unsigned,heap) *scc_stack;\n-  VEC(unsigned,heap) *unification_queue;\n };\n \n \n@@ -958,178 +1101,144 @@ scc_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n+  unsigned int my_dfs;\n \n-  gcc_assert (get_varinfo (n)->node == n);\n   SET_BIT (si->visited, n);\n-  RESET_BIT (si->in_component, n);\n-  si->visited_index[n] = si->current_index ++;\n+  si->dfs[n] = si->current_index ++;\n+  my_dfs = si->dfs[n];\n \n   /* Visit all the successors.  */\n   EXECUTE_IF_IN_NONNULL_BITMAP (graph->succs[n], 0, i, bi)\n     {\n-      unsigned int w = i;\n+      unsigned int w;\n+\n+      if (i > LAST_REF_NODE)\n+\tbreak;\n+\n+      w = find (i);\n+      if (TEST_BIT (si->roots, w))\n+\tcontinue;\n+\n       if (!TEST_BIT (si->visited, w))\n \tscc_visit (graph, si, w);\n-      if (!TEST_BIT (si->in_component, w))\n-\t{\n-\t  unsigned int t = get_varinfo (w)->node;\n-\t  unsigned int nnode = get_varinfo (n)->node;\n-\t  if (si->visited_index[t] < si->visited_index[nnode])\n-\t    get_varinfo (n)->node = t;\n-\t}\n+      {\n+\tunsigned int t = find (w);\n+\tunsigned int nnode = find (n);\n+\tgcc_assert(nnode == n);\n+\n+\tif (si->dfs[t] < si->dfs[nnode])\n+\t  si->dfs[n] = si->dfs[t];\n+      }\n     }\n \n   /* See if any components have been identified.  */\n-  if (get_varinfo (n)->node == n)\n+  if (si->dfs[n] == my_dfs)\n     {\n-      unsigned int t = si->visited_index[n];\n-      SET_BIT (si->in_component, n);\n-      while (VEC_length (unsigned, si->scc_stack) != 0\n-\t     && t < si->visited_index[VEC_last (unsigned, si->scc_stack)])\n+      if (VEC_length (unsigned, si->scc_stack) > 0\n+\t  && si->dfs[VEC_last (unsigned, si->scc_stack)] >= my_dfs)\n \t{\n-\t  unsigned int w = VEC_pop (unsigned, si->scc_stack);\n-\t  get_varinfo (w)->node = n;\n-\t  SET_BIT (si->in_component, w);\n-\t  /* Mark this node for collapsing.  */\n-\t  VEC_safe_push (unsigned, heap, si->unification_queue, w);\n-\t}\n-    }\n-  else\n-    VEC_safe_push (unsigned, heap, si->scc_stack, n);\n-}\n-\n+\t  bitmap scc = BITMAP_ALLOC (NULL);\n+\t  bool have_ref_node = n >= FIRST_REF_NODE;\n+\t  unsigned int lowest_node;\n+\t  bitmap_iterator bi;\n \n-/* Collapse two variables into one variable, merging solutions if\n-   requested.  */\n+\t  bitmap_set_bit (scc, n);\n \n-static void\n-collapse_nodes (constraint_graph_t graph, unsigned int to, unsigned int from,\n-\t\tbool merge_solutions)\n-{\n-  bitmap tosol, fromsol;\n+\t  while (VEC_length (unsigned, si->scc_stack) != 0\n+\t\t && si->dfs[VEC_last (unsigned, si->scc_stack)] >= my_dfs)\n+\t    {\n+\t      unsigned int w = VEC_pop (unsigned, si->scc_stack);\n \n-  merge_graph_nodes (graph, to, from);\n-  condense_varmap_nodes (to, from);\n-  if (merge_solutions)\n-    {\n-      tosol = get_varinfo (to)->solution;\n-      fromsol = get_varinfo (from)->solution;\n-      bitmap_ior_into (tosol, fromsol);\n-      BITMAP_FREE (fromsol);\n-    }\n+\t      bitmap_set_bit (scc, w);\n+\t      if (w >= FIRST_REF_NODE)\n+\t\thave_ref_node = true;\n+\t    }\n \n-  if (valid_graph_edge (graph, to, to))\n-    {\n-      if (graph->preds[to])\n-\t{\n-\t  bitmap_clear_bit (graph->preds[to], to);\n-\t  bitmap_clear_bit (graph->succs[to], to);\n+\t  lowest_node = bitmap_first_set_bit (scc);\n+\t  gcc_assert (lowest_node < FIRST_REF_NODE);\n+\t  EXECUTE_IF_SET_IN_BITMAP (scc, 0, i, bi)\n+\t    {\n+\t      if (i < FIRST_REF_NODE)\n+\t\t{\n+\t\t  /* Mark this node for collapsing.  */\n+\t\t  if (unite (lowest_node, i))\n+\t\t    unify_nodes (graph, lowest_node, i, false);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  unite (lowest_node, i);\n+\t\t  graph->indirect_cycles[i - FIRST_REF_NODE] = lowest_node;\n+\t\t}\n+\t    }\n \t}\n+      SET_BIT (si->roots, n);\n     }\n+  else\n+    VEC_safe_push (unsigned, heap, si->scc_stack, n);\n }\n \n-\n-/* Unify nodes in GRAPH that we have found to be part of a cycle.\n-   SI is the Strongly Connected Components information structure that tells us\n-   what components to unify.\n-   UPDATE_CHANGED should be set to true if the changed sbitmap and changed\n-   count should be updated to reflect the unification.  */\n+/* Unify node FROM into node TO, updating the changed count if\n+   necessary when UPDATE_CHANGED is true.  */\n \n static void\n-process_unification_queue (constraint_graph_t graph, struct scc_info *si,\n-\t\t\t   bool update_changed)\n+unify_nodes (constraint_graph_t graph, unsigned int to, unsigned int from,\n+\t     bool update_changed)\n {\n-  size_t i = 0;\n-  bitmap tmp = BITMAP_ALLOC (update_changed ? &iteration_obstack : NULL);\n-  bitmap_clear (tmp);\n-\n-  /* We proceed as follows:\n-\n-     For each component in the queue (components are delineated by\n-     when current_queue_element->node != next_queue_element->node):\n-\n-\trep = representative node for component\n-\n-\tFor each node (tounify) to be unified in the component,\n-\t   merge the solution for tounify into tmp bitmap\n-\n-\t   clear solution for tounify\n \n-\t   merge edges from tounify into rep\n+  gcc_assert (to != from && find (to) == to);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Unifying %s to %s\\n\",\n+\t     get_varinfo (from)->name,\n+\t     get_varinfo (to)->name);\n \n-\t   merge complex constraints from tounify into rep\n-\n-\t   update changed count to note that tounify will never change\n-\t   again\n+  if (update_changed)\n+    stats.unified_vars_dynamic++;\n+  else\n+    stats.unified_vars_static++;\n \n-\tMerge tmp into solution for rep, marking rep changed if this\n-\tchanged rep's solution.\n+  merge_graph_nodes (graph, to, from);\n+  merge_node_constraints (graph, to, from);\n \n-\tDelete any self-edges we now have for rep.  */\n-  while (i != VEC_length (unsigned, si->unification_queue))\n+  if (update_changed && TEST_BIT (changed, from))\n     {\n-      unsigned int tounify = VEC_index (unsigned, si->unification_queue, i);\n-      unsigned int n = get_varinfo (tounify)->node;\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"Unifying %s to %s\\n\",\n-\t\t get_varinfo (tounify)->name,\n-\t\t get_varinfo (n)->name);\n-      if (update_changed)\n-\tstats.unified_vars_dynamic++;\n+      RESET_BIT (changed, from);\n+      if (!TEST_BIT (changed, to))\n+\tSET_BIT (changed, to);\n       else\n-\tstats.unified_vars_static++;\n-      bitmap_ior_into (tmp, get_varinfo (tounify)->solution);\n-      collapse_nodes (graph, n, tounify, false);\n+\t{\n+\t  gcc_assert (changed_count > 0);\n+\t  changed_count--;\n+\t}\n+    }\n \n-      if (update_changed && TEST_BIT (changed, tounify))\n+  /* If the solution changes because of the merging, we need to mark\n+     the variable as changed.  */\n+  if (bitmap_ior_into (get_varinfo (to)->solution,\n+\t\t       get_varinfo (from)->solution))\n+    {\n+      if (update_changed && !TEST_BIT (changed, to))\n \t{\n-\t  RESET_BIT (changed, tounify);\n-\t  if (!TEST_BIT (changed, n))\n-\t    SET_BIT (changed, n);\n-\t  else\n-\t    {\n-\t      gcc_assert (changed_count > 0);\n-\t      changed_count--;\n-\t    }\n+\t  SET_BIT (changed, to);\n+\t  changed_count++;\n \t}\n+    }\n \n-      bitmap_clear (get_varinfo (tounify)->solution);\n-      ++i;\n+  BITMAP_FREE (get_varinfo (from)->solution);\n+  BITMAP_FREE (get_varinfo (from)->oldsolution);\n \n-      /* If we've either finished processing the entire queue, or\n-\t finished processing all nodes for component n, update the solution for\n-\t n.  */\n-      if (i == VEC_length (unsigned, si->unification_queue)\n-\t  || get_varinfo (VEC_index (unsigned, si->unification_queue, i))->node != n)\n-\t{\n-\t  /* If the solution changes because of the merging, we need to mark\n-\t     the variable as changed.  */\n-\t  if (bitmap_ior_into (get_varinfo (n)->solution, tmp))\n-\t    {\n-\t      if (update_changed && !TEST_BIT (changed, n))\n-\t\t{\n-\t\t  SET_BIT (changed, n);\n-\t\t  changed_count++;\n-\t\t}\n-\t    }\n-\t  bitmap_clear (tmp);\n+  if (stats.iterations > 0)\n+    {\n+      BITMAP_FREE (get_varinfo (to)->oldsolution);\n+      get_varinfo (to)->oldsolution = BITMAP_ALLOC (&oldpta_obstack);\n+    }\n \n-\t  if (valid_graph_edge (graph, n, n))\n-\t    {\n-\t      if (graph->succs[n])\n-\t\t{\n-\t\t  if (graph->preds[n])\n-\t\t    bitmap_clear_bit (graph->preds[n], n);\n-\t\t  bitmap_clear_bit (graph->succs[n], n);\n-\t\t}\n-\t    }\n-\t}\n+  if (valid_graph_edge (graph, to, to))\n+    {\n+      if (graph->succs[to])\n+\tbitmap_clear_bit (graph->succs[to], to);\n     }\n-  BITMAP_FREE (tmp);\n }\n \n-\n /* Information needed to compute the topological ordering of a graph.  */\n \n struct topo_info\n@@ -1173,19 +1282,18 @@ static void\n topo_visit (constraint_graph_t graph, struct topo_info *ti,\n \t    unsigned int n)\n {\n-  bitmap temp;\n   bitmap_iterator bi;\n   unsigned int j;\n \n   SET_BIT (ti->visited, n);\n-  temp = graph->succs[n];\n \n-  if (temp)\n-    EXECUTE_IF_SET_IN_BITMAP (temp, 0, j, bi)\n+  if (graph->succs[n])\n+    EXECUTE_IF_SET_IN_BITMAP (graph->succs[n], 0, j, bi)\n       {\n \tif (!TEST_BIT (ti->visited, j))\n \t  topo_visit (graph, ti, j);\n       }\n+\n   VEC_safe_push (unsigned, heap, ti->topo_order, n);\n }\n \n@@ -1234,7 +1342,7 @@ do_da_constraint (constraint_graph_t graph ATTRIBUTE_UNUSED,\n \t  v = first_vi_for_offset (get_varinfo (j), fieldoffset);\n \t  if (!v)\n \t    continue;\n-\t  t = v->node;\n+\t  t = find (v->id);\n \t  sol = get_varinfo (t)->solution;\n \t  if (!bitmap_bit_p (sol, rhs))\n \t    {\n@@ -1259,7 +1367,7 @@ static void\n do_sd_constraint (constraint_graph_t graph, constraint_t c,\n \t\t  bitmap delta)\n {\n-  unsigned int lhs = get_varinfo (c->lhs.var)->node;\n+  unsigned int lhs = find (c->lhs.var);\n   bool flag = false;\n   bitmap sol = get_varinfo (lhs)->solution;\n   unsigned int j;\n@@ -1286,7 +1394,7 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n \t  v = first_vi_for_offset (get_varinfo (j), fieldoffset);\n \t  if (!v)\n \t    continue;\n-\t  t = v->node;\n+\t  t = find (v->id);\n \n \t  /* Adding edges from the special vars is pointless.\n \t     They don't have sets that can change.  */\n@@ -1318,7 +1426,7 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n static void\n do_ds_constraint (constraint_t c, bitmap delta)\n {\n-  unsigned int rhs = get_varinfo (c->rhs.var)->node;\n+  unsigned int rhs = find (c->rhs.var);\n   unsigned HOST_WIDE_INT roff = c->rhs.offset;\n   bitmap sol = get_varinfo (rhs)->solution;\n   unsigned int j;\n@@ -1337,7 +1445,7 @@ do_ds_constraint (constraint_t c, bitmap delta)\n \t v = first_vi_for_offset (get_varinfo (j), fieldoffset);\n \t if (!v)\n \t   continue;\n-\t t = v->node;\n+\t t = find (v->id);\n \n \t if (!bitmap_bit_p (get_varinfo (t)->solution, anything_id))\n \t   {\n@@ -1367,7 +1475,7 @@ do_ds_constraint (constraint_t c, bitmap delta)\n \t  v = first_vi_for_offset (get_varinfo (j), fieldoffset);\n \t  if (!v)\n \t    continue;\n-\t  t = v->node;\n+\t  t = find (v->id);\n \t  tmp = get_varinfo (t)->solution;\n \n \t  if (set_union_with_increment (tmp, sol, roff))\n@@ -1387,8 +1495,8 @@ do_ds_constraint (constraint_t c, bitmap delta)\n     }\n }\n \n-/* Handle a non-simple (simple meaning requires no iteration), non-copy\n-   constraint (IE *x = &y, x = *y, and *x = y).  */\n+/* Handle a non-simple (simple meaning requires no iteration),\n+   constraint (IE *x = &y, x = *y, *x = y, and x = y with offsets involved).  */\n \n static void\n do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n@@ -1420,9 +1528,9 @@ do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n       unsigned int t;\n \n       gcc_assert(c->rhs.type == SCALAR && c->lhs.type == SCALAR);\n-      t = get_varinfo (c->rhs.var)->node;\n+      t = find (c->rhs.var);\n       solution = get_varinfo (t)->solution;\n-      t = get_varinfo (c->lhs.var)->node;\n+      t = find (c->lhs.var);\n       tmp = get_varinfo (t)->solution;\n \n       flag = set_union_with_increment (tmp, solution, c->rhs.offset);\n@@ -1442,19 +1550,23 @@ do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n /* Initialize and return a new SCC info structure.  */\n \n static struct scc_info *\n-init_scc_info (void)\n+init_scc_info (size_t size)\n {\n   struct scc_info *si = XNEW (struct scc_info);\n-  size_t size = VEC_length (varinfo_t, varmap);\n+  size_t i;\n \n   si->current_index = 0;\n   si->visited = sbitmap_alloc (size);\n   sbitmap_zero (si->visited);\n-  si->in_component = sbitmap_alloc (size);\n-  sbitmap_ones (si->in_component);\n-  si->visited_index = XCNEWVEC (unsigned int, size + 1);\n+  si->roots = sbitmap_alloc (size);\n+  sbitmap_zero (si->roots);\n+  si->node_mapping = XNEWVEC (unsigned int, size);\n+  si->dfs = XCNEWVEC (unsigned int, size);\n+\n+  for (i = 0; i < size; i++)\n+    si->node_mapping[i] = i;\n+\n   si->scc_stack = VEC_alloc (unsigned, heap, 1);\n-  si->unification_queue = VEC_alloc (unsigned, heap, 1);\n   return si;\n }\n \n@@ -1464,31 +1576,32 @@ static void\n free_scc_info (struct scc_info *si)\n {\n   sbitmap_free (si->visited);\n-  sbitmap_free (si->in_component);\n-  free (si->visited_index);\n+  sbitmap_free (si->roots);\n+  free (si->node_mapping);\n+  free (si->dfs);\n   VEC_free (unsigned, heap, si->scc_stack);\n-  VEC_free (unsigned, heap, si->unification_queue);\n-  free(si);\n+  free (si);\n }\n \n \n-/* Find cycles in GRAPH that occur, using strongly connected components, and\n-   collapse the cycles into a single representative node.  if UPDATE_CHANGED\n-   is true, then update the changed sbitmap to note those nodes whose\n-   solutions have changed as a result of collapsing.  */\n+/* Find indirect cycles in GRAPH that occur, using strongly connected\n+   components, and note them in the indirect cycles map.\n+\n+   This technique comes from Ben Hardekopf and Calvin Lin,\n+   \"It Pays to be Lazy: Fast and Accurate Pointer Analysis for Millions of\n+   Lines of Code\", submitted to PLDI 2007.  */\n \n static void\n-find_and_collapse_graph_cycles (constraint_graph_t graph, bool update_changed)\n+find_indirect_cycles (constraint_graph_t graph)\n {\n   unsigned int i;\n-  unsigned int size = VEC_length (varinfo_t, varmap);\n-  struct scc_info *si = init_scc_info ();\n+  unsigned int size = graph->size;\n+  struct scc_info *si = init_scc_info (size);\n \n-  for (i = 0; i != size; ++i)\n-    if (!TEST_BIT (si->visited, i) && get_varinfo (i)->node == i)\n+  for (i = 0; i < MIN (LAST_REF_NODE, size); i ++ )\n+    if (!TEST_BIT (si->visited, i) && find (i) == i)\n       scc_visit (graph, si, i);\n \n-  process_unification_queue (graph, si, update_changed);\n   free_scc_info (si);\n }\n \n@@ -1503,7 +1616,7 @@ compute_topo_order (constraint_graph_t graph,\n   unsigned int size = VEC_length (varinfo_t, varmap);\n \n   for (i = 0; i != size; ++i)\n-    if (!TEST_BIT (ti->visited, i) && get_varinfo (i)->node == i)\n+    if (!TEST_BIT (ti->visited, i) && find (i) == i)\n       topo_visit (graph, ti, i);\n }\n \n@@ -1515,87 +1628,374 @@ compute_topo_order (constraint_graph_t graph,\n \n    The technique is described in \"Off-line variable substitution for\n    scaling points-to analysis\" by Atanas Rountev and Satish Chandra,\n-   in \"ACM SIGPLAN Notices\" volume 35, number 5, pages 47-56.  */\n+   in \"ACM SIGPLAN Notices\" volume 35, number 5, pages 47-56.\n+\n+   There is an optimal way to do this involving hash based value\n+   numbering, once the technique is published i will implement it\n+   here.  \n+\n+   The general method of finding equivalence classes is as follows:\n+   Add fake nodes (REF nodes) and edges for *a = b and a = *b constraints.\n+   Add fake nodes (ADDRESS nodes) and edges for a = &b constraints.\n+   Initialize all non-REF/ADDRESS nodes to be direct nodes\n+   For each SCC in the predecessor graph:\n+      for each member (x) of the SCC\n+         if x is not a direct node:\n+\t   set rootnode(SCC) to be not a direct node\n+\t collapse node x into rootnode(SCC).\n+      if rootnode(SCC) is not a direct node:\n+        label rootnode(SCC) with a new equivalence class\n+      else:\n+        if all labeled predecessors of rootnode(SCC) have the same\n+\tlabel:\n+\t  label rootnode(SCC) with this label\n+\telse:\n+\t  label rootnode(SCC) with a new equivalence class\n+\n+   All direct nodes with the same equivalence class can be replaced\n+   with a single representative node.\n+   All unlabeled nodes (label == 0) are not pointers and all edges\n+   involving them can be eliminated.\n+   We perform these optimizations during move_complex_constraints.\n+*/\n+\n+static int equivalence_class;\n+\n+/* Recursive routine to find strongly connected components in GRAPH,\n+   and label it's nodes with equivalence classes.\n+   This is used during variable substitution to find cycles involving\n+   the regular or implicit predecessors, and label them as equivalent.\n+   The SCC finding algorithm used is the same as that for scc_visit.  */\n \n static void\n-perform_var_substitution (constraint_graph_t graph)\n+label_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n {\n-  struct topo_info *ti = init_topo_info ();\n+  unsigned int i;\n+  bitmap_iterator bi;\n+  unsigned int my_dfs;\n \n-  bitmap_obstack_initialize (&iteration_obstack);\n-  /* Compute the topological ordering of the graph, then visit each\n-     node in topological order.  */\n-  compute_topo_order (graph, ti);\n+  gcc_assert (si->node_mapping[n] == n);\n+  SET_BIT (si->visited, n);\n+  si->dfs[n] = si->current_index ++;\n+  my_dfs = si->dfs[n];\n \n-  while (VEC_length (unsigned, ti->topo_order) != 0)\n+  /* Visit all the successors.  */\n+  EXECUTE_IF_IN_NONNULL_BITMAP (graph->preds[n], 0, i, bi)\n     {\n-      unsigned int i = VEC_pop (unsigned, ti->topo_order);\n-      varinfo_t vi = get_varinfo (i);\n-      bool okay_to_elim = false;\n-      unsigned int root = VEC_length (varinfo_t, varmap);\n-      bitmap tmp;\n-      unsigned int k;\n-      bitmap_iterator bi;\n+      unsigned int w = si->node_mapping[i];\n \n-      /* We can't eliminate things whose address is taken, or which is\n-\t the target of a dereference.  */\n-      if (vi->address_taken || vi->indirect_target)\n+      if (TEST_BIT (si->roots, w))\n \tcontinue;\n \n-      /* See if all predecessors of I are ripe for elimination */\n-      EXECUTE_IF_IN_NONNULL_BITMAP (graph->preds[i], 0, k, bi)\n-\t  {\n-\t    unsigned int w;\n-\t    w = get_varinfo (k)->node;\n+      if (!TEST_BIT (si->visited, w))\n+\tlabel_visit (graph, si, w);\n+      {\n+\tunsigned int t = si->node_mapping[w];\n+\tunsigned int nnode = si->node_mapping[n];\n+\tgcc_assert(nnode == n);\n \n-\t    /* We can't eliminate the node if one of the predecessors is\n-\t       part of a different strongly connected component.  */\n-\t    if (!okay_to_elim)\n-\t      {\n-\t\troot = w;\n-\t\tokay_to_elim = true;\n-\t      }\n-\t    else if (w != root)\n-\t      {\n-\t\tokay_to_elim = false;\n-\t\tbreak;\n-\t      }\n+\tif (si->dfs[t] < si->dfs[nnode])\n+\t  si->dfs[n] = si->dfs[t];\n+      }\n+    }\n \n-\t    /* Theorem 4 in Rountev and Chandra: If i is a direct node,\n-\t       then Solution(i) is a subset of Solution (w), where w is a\n-\t       predecessor in the graph.\n-\t       Corollary: If all predecessors of i have the same\n-\t       points-to set, then i has that same points-to set as\n-\t       those predecessors.  */\n-\t    tmp = BITMAP_ALLOC (NULL);\n-\t    bitmap_and_compl (tmp, get_varinfo (i)->solution,\n-\t\t\t      get_varinfo (w)->solution);\n-\t    if (!bitmap_empty_p (tmp))\n-\t      {\n-\t\tokay_to_elim = false;\n-\t\tBITMAP_FREE (tmp);\n-\t\tbreak;\n-\t      }\n-\t    BITMAP_FREE (tmp);\n-\t  }\n+  /* Visit all the implicit predecessors.  */\n+  EXECUTE_IF_IN_NONNULL_BITMAP (graph->implicit_preds[n], 0, i, bi)\n+    {\n+      unsigned int w = si->node_mapping[i];\n+\n+      if (TEST_BIT (si->roots, w))\n+\tcontinue;\n+\n+      if (!TEST_BIT (si->visited, w))\n+\tlabel_visit (graph, si, w);\n+      {\n+\tunsigned int t = si->node_mapping[w];\n+\tunsigned int nnode = si->node_mapping[n];\n+\tgcc_assert (nnode == n);\n+\n+\tif (si->dfs[t] < si->dfs[nnode])\n+\t  si->dfs[n] = si->dfs[t];\n+      }\n+    }\n \n-      /* See if the root is different than the original node.\n-\t If so, we've found an equivalence.  */\n-      if (root != get_varinfo (i)->node && okay_to_elim)\n+  /* See if any components have been identified.  */\n+  if (si->dfs[n] == my_dfs)\n+    {\n+      while (VEC_length (unsigned, si->scc_stack) != 0\n+\t     && si->dfs[VEC_last (unsigned, si->scc_stack)] >= my_dfs)\n \t{\n-\t  /* Found an equivalence */\n-\t  get_varinfo (i)->node = root;\n-\t  collapse_nodes (graph, root, i, true);\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"Collapsing %s into %s\\n\",\n-\t\t     get_varinfo (i)->name,\n-\t\t     get_varinfo (root)->name);\n-\t  stats.collapsed_vars++;\n+\t  unsigned int w = VEC_pop (unsigned, si->scc_stack);\n+\t  si->node_mapping[w] = n;\n+\n+\t  if (!TEST_BIT (graph->direct_nodes, w))\n+\t    RESET_BIT (graph->direct_nodes, n);\n+\t}\n+      SET_BIT (si->roots, n);\n+\n+      if (!TEST_BIT (graph->direct_nodes, n))\n+\t{\n+\t  graph->label[n] = equivalence_class++;\n+\t}\n+      else\n+\t{\n+\t  unsigned int size = 0;\n+\t  unsigned int firstlabel = ~0;\n+\n+\t  EXECUTE_IF_IN_NONNULL_BITMAP (graph->preds[n], 0, i, bi)\n+\t    {\n+\t      unsigned int j = si->node_mapping[i];\n+\n+\t      if (j == n || graph->label[j] == 0)\n+\t\tcontinue;\n+\n+\t      if (firstlabel == (unsigned int)~0)\n+\t\t{\n+\t\t  firstlabel = graph->label[j];\n+\t\t  size++;\n+\t\t}\n+\t      else if (graph->label[j] != firstlabel)\n+\t\tsize++;\n+\t    }\n+\n+\t  if (size == 0)\n+\t    graph->label[n] = 0;\n+\t  else if (size == 1)\n+\t    graph->label[n] = firstlabel;\n+\t  else\n+\t    graph->label[n] = equivalence_class++;\n+\t}\n+    }\n+  else\n+    VEC_safe_push (unsigned, heap, si->scc_stack, n);\n+}\n+\n+/* Perform offline variable substitution, discovering equivalence\n+   classes, and eliminating non-pointer variables.  */\n+\n+static struct scc_info *\n+perform_var_substitution (constraint_graph_t graph)\n+{\n+  unsigned int i;\n+  unsigned int size = graph->size;\n+  struct scc_info *si = init_scc_info (size);\n+\n+  bitmap_obstack_initialize (&iteration_obstack);\n+  equivalence_class = 0;\n+\n+  /* We only need to visit the non-address nodes for labeling\n+     purposes, as the address nodes will never have any predecessors,\n+     because &x never appears on the LHS of a constraint.  */\n+  for (i = 0; i < LAST_REF_NODE; i++)\n+    if (!TEST_BIT (si->visited, si->node_mapping[i]))\n+      label_visit (graph, si, si->node_mapping[i]);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    for (i = 0; i < FIRST_REF_NODE; i++)\n+      {\n+\tbool direct_node = TEST_BIT (graph->direct_nodes, i);\n+\tfprintf (dump_file,\n+\t\t \"Equivalence class for %s node id %d:%s is %d\\n\",\n+\t\t direct_node ? \"Direct node\" : \"Indirect node\", i,\n+\t\t get_varinfo(i)->name,\n+\t\t graph->label[si->node_mapping[i]]);\n+      }\n+\n+  /* Quickly eliminate our non-pointer variables.  */\n+\n+  for (i = 0; i < FIRST_REF_NODE; i++)\n+    {\n+      unsigned int node = si->node_mapping[i];\n+\n+      if (graph->label[node] == 0 && TEST_BIT (graph->direct_nodes, node))\n+\t{\n+\t  if (dump_file && (dump_flags && TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"%s is a non-pointer variable, eliminating edges.\\n\",\n+\t\t     get_varinfo (node)->name);\n+\t  stats.nonpointer_vars++;\n+\t  clear_edges_for_node (graph, node);\n \t}\n     }\n+  return si;\n+}\n+\n+/* Free information that was only necessary for variable\n+   substitution.  */\n \n+static void\n+free_var_substitution_info (struct scc_info *si)\n+{\n+  free_scc_info (si);\n+  free (graph->label);\n+  free (graph->eq_rep);\n+  sbitmap_free (graph->direct_nodes);\n   bitmap_obstack_release (&iteration_obstack);\n-  free_topo_info (ti);\n+}\n+\n+/* Return an existing node that is equivalent to NODE, which has\n+   equivalence class LABEL, if one exists.  Return NODE otherwise.  */\n+\n+static unsigned int\n+find_equivalent_node (constraint_graph_t graph,\n+\t\t      unsigned int node, unsigned int label)\n+{\n+  /* If the address version of this variable is unused, we can\n+     substitute it for anything else with the same label.\n+     Otherwise, we know the pointers are equivalent, but not the\n+     locations.  */\n+\n+  if (graph->label[FIRST_ADDR_NODE + node] == 0)\n+    {\n+      gcc_assert (label < graph->size);\n+\n+      if (graph->eq_rep[label] != -1)\n+\t{\n+\t  /* Unify the two variables since we know they are equivalent.  */\n+\t  if (unite (graph->eq_rep[label], node))\n+\t    unify_nodes (graph, graph->eq_rep[label], node, false);\n+\t  return graph->eq_rep[label];\n+\t}\n+      else\n+\t{\n+\t  graph->eq_rep[label] = node;\n+\t}\n+    }\n+  return node;\n+}\n+\n+/* Move complex constraints to the appropriate nodes, and collapse\n+   variables we've discovered are equivalent during variable\n+   substitution.  SI is the SCC_INFO that is the result of\n+   perform_variable_substitution.  */\n+\n+static void\n+move_complex_constraints (constraint_graph_t graph,\n+\t\t\t  struct scc_info *si)\n+{\n+  int i;\n+  unsigned int j;\n+  constraint_t c;\n+\n+  for (j = 0; j < graph->size; j++)\n+    gcc_assert (find (j) == j);\n+\n+  for (i = 0; VEC_iterate (constraint_t, constraints, i, c); i++)\n+    {\n+      struct constraint_expr lhs = c->lhs;\n+      struct constraint_expr rhs = c->rhs;\n+      unsigned int lhsvar = find (get_varinfo_fc (lhs.var)->id);\n+      unsigned int rhsvar = find (get_varinfo_fc (rhs.var)->id);\n+      unsigned int lhsnode, rhsnode;\n+      unsigned int lhslabel, rhslabel;\n+\n+      lhsnode = si->node_mapping[lhsvar];\n+      rhsnode = si->node_mapping[rhsvar];\n+      lhslabel = graph->label[lhsnode];\n+      rhslabel = graph->label[rhsnode];\n+\n+      /* See if it is really a non-pointer variable, and if so, ignore\n+\t the constraint.  */\n+      if (lhslabel == 0)\n+\t{\n+\t  if (!TEST_BIT (graph->direct_nodes, lhsnode))\n+\t    lhslabel = graph->label[lhsnode] = equivalence_class++;\n+\t  else\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\n+\t\t  fprintf (dump_file, \"%s is a non-pointer variable,\"\n+\t\t\t   \"ignoring constraint:\",\n+\t\t\t   get_varinfo (lhs.var)->name);\n+\t\t  dump_constraint (dump_file, c);\n+\t\t}\n+\t      VEC_replace (constraint_t, constraints, i, NULL);\n+\t      continue;\n+\t    }\n+\t}\n+\n+      if (rhslabel == 0)\n+\t{\n+\t  if (!TEST_BIT (graph->direct_nodes, rhsnode))\n+\t    rhslabel = graph->label[rhsnode] = equivalence_class++;\n+\t  else\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\n+\t\t  fprintf (dump_file, \"%s is a non-pointer variable,\"\n+\t\t\t   \"ignoring constraint:\",\n+\t\t\t   get_varinfo (rhs.var)->name);\n+\t\t  dump_constraint (dump_file, c);\n+\t\t}\n+\t      VEC_replace (constraint_t, constraints, i, NULL);\n+\t      continue;\n+\t    }\n+\t}\n+\n+      lhsvar = find_equivalent_node (graph, lhsvar, lhslabel);\n+      rhsvar = find_equivalent_node (graph, rhsvar, rhslabel);\n+      c->lhs.var = lhsvar;\n+      c->rhs.var = rhsvar;\n+\n+      if (lhs.type == DEREF)\n+\t{\n+\t  if (rhs.type == ADDRESSOF || rhsvar > anything_id)\n+\t    insert_into_complex (graph, lhsvar, c);\n+\t}\n+      else if (rhs.type == DEREF)\n+\t{\n+\t  if (!(get_varinfo (lhsvar)->is_special_var))\n+\t    insert_into_complex (graph, rhsvar, c);\n+\t}\n+      else if (rhs.type != ADDRESSOF && lhsvar > anything_id\n+\t       && (lhs.offset != 0 || rhs.offset != 0))\n+\t{\n+\t  insert_into_complex (graph, rhsvar, c);\n+\t}\n+\n+    }\n+}\n+\n+/* Eliminate indirect cycles involving NODE.  Return true if NODE was\n+   part of an SCC, false otherwise.  */\n+\n+static bool\n+eliminate_indirect_cycles (unsigned int node)\n+{\n+  if (graph->indirect_cycles[node] != -1\n+      && !bitmap_empty_p (get_varinfo (node)->solution))\n+    {\n+      unsigned int i;\n+      VEC(unsigned,heap) *queue = NULL;\n+      int queuepos;\n+      unsigned int to = find (graph->indirect_cycles[node]);\n+      bitmap_iterator bi;\n+\n+      /* We can't touch the solution set and call unify_nodes\n+\t at the same time, because unify_nodes is going to do\n+\t bitmap unions into it. */\n+\n+      EXECUTE_IF_SET_IN_BITMAP (get_varinfo (node)->solution, 0, i, bi)\n+\t{\n+\t  if (find (i) == i && i != to)\n+\t    {\n+\t      if (unite (to, i))\n+\t\tVEC_safe_push (unsigned, heap, queue, i);\n+\t    }\n+\t}\n+\n+      for (queuepos = 0;\n+\t   VEC_iterate (unsigned, queue, queuepos, i);\n+\t   queuepos++)\n+\t{\n+\t  unify_nodes (graph, to, i, true);\n+\t}\n+      VEC_free (unsigned, heap, queue);\n+      return true;\n+    }\n+  return false;\n }\n \n /* Solve the constraint graph GRAPH using our worklist solver.\n@@ -1610,16 +2010,27 @@ solve_graph (constraint_graph_t graph)\n {\n   unsigned int size = VEC_length (varinfo_t, varmap);\n   unsigned int i;\n+  bitmap pts;\n \n-  changed_count = size;\n+  changed_count = 0;\n   changed = sbitmap_alloc (size);\n-  sbitmap_ones (changed);\n+  sbitmap_zero (changed);\n \n-  /* The already collapsed/unreachable nodes will never change, so we\n-     need to  account for them in changed_count.  */\n+  /* Mark all initial non-collapsed nodes as changed.  */\n   for (i = 0; i < size; i++)\n-    if (get_varinfo (i)->node != i)\n-      changed_count--;\n+    {\n+      varinfo_t ivi = get_varinfo (i);\n+      if (find (i) == i && !bitmap_empty_p (ivi->solution)\n+\t  && ((graph->succs[i] && !bitmap_empty_p (graph->succs[i]))\n+\t      || VEC_length (constraint_t, graph->complex[i]) > 0))\n+\t{\n+\t  SET_BIT (changed, i);\n+\t  changed_count++;\n+\t}\n+    }\n+\n+  /* Allocate a bitmap to be used to store the changed bits.  */\n+  pts = BITMAP_ALLOC (&pta_obstack);\n \n   while (changed_count > 0)\n     {\n@@ -1629,23 +2040,20 @@ solve_graph (constraint_graph_t graph)\n \n       bitmap_obstack_initialize (&iteration_obstack);\n \n-      if (edge_added)\n-\t{\n-\t  /* We already did cycle elimination once, when we did\n-\t     variable substitution, so we don't need it again for the\n-\t     first iteration.  */\n-\t  if (stats.iterations > 1)\n-\t    find_and_collapse_graph_cycles (graph, true);\n-\n-\t  edge_added = false;\n-\t}\n-\n       compute_topo_order (graph, ti);\n \n       while (VEC_length (unsigned, ti->topo_order) != 0)\n \t{\n+\n \t  i = VEC_pop (unsigned, ti->topo_order);\n-\t  gcc_assert (get_varinfo (i)->node == i);\n+\n+\t  /* If this variable is not a representative, skip it.  */\n+\t  if (find (i) != i)\n+\t    continue;\n+\n+\t  eliminate_indirect_cycles (i);\n+\n+\t  gcc_assert (find (i) == i);\n \n \t  /* If the node has changed, we need to process the\n \t     complex constraints and outgoing edges again.  */\n@@ -1654,13 +2062,20 @@ solve_graph (constraint_graph_t graph)\n \t      unsigned int j;\n \t      constraint_t c;\n \t      bitmap solution;\n-\t      bitmap_iterator bi;\n-\t      VEC(constraint_t,heap) *complex = get_varinfo (i)->complex;\n+\t      VEC(constraint_t,heap) *complex = graph->complex[i];\n \t      bool solution_empty;\n-\n \t      RESET_BIT (changed, i);\n \t      changed_count--;\n \n+\t      /* Compute the changed set of solution bits.  */\n+\t      bitmap_and_compl (pts, get_varinfo (i)->solution,\n+\t\t\t\tget_varinfo (i)->oldsolution);\n+\n+\t      if (bitmap_empty_p (pts))\n+\t\tcontinue;\n+\n+\t      bitmap_ior_into (get_varinfo (i)->oldsolution, pts);\n+\n \t      solution = get_varinfo (i)->solution;\n \t      solution_empty = bitmap_empty_p (solution);\n \n@@ -1672,30 +2087,38 @@ solve_graph (constraint_graph_t graph)\n \t\t     is a constraint where the lhs side is receiving\n \t\t     some set from elsewhere.  */\n \t\t  if (!solution_empty || c->lhs.type != DEREF)\n-\t\t    do_complex_constraint (graph, c, solution);\n+\t\t    do_complex_constraint (graph, c, pts);\n \t\t}\n \n \t      solution_empty = bitmap_empty_p (solution);\n \n \t      if (!solution_empty)\n \t\t{\n+\t\t  bitmap_iterator bi;\n+\n \t\t  /* Propagate solution to all successors.  */\n \t\t  EXECUTE_IF_IN_NONNULL_BITMAP (graph->succs[i],\n \t\t\t\t\t\t0, j, bi)\n \t\t    {\n-\t\t      bitmap tmp = get_varinfo (j)->solution;\n-\t\t      bool flag = false;\n+\t\t      bitmap tmp;\n+\t\t      bool flag;\n+\n+\t\t      unsigned int to = find (j);\n+\t\t      tmp = get_varinfo (to)->solution;\n+\t\t      flag = false;\n \n-\t\t      gcc_assert (get_varinfo (j)->node == j);\n+\t\t      /* Don't try to propagate to ourselves.  */\n+\t\t      if (to == i)\n+\t\t\tcontinue;\n \n-\t\t      flag = set_union_with_increment (tmp, solution, 0);\n+\t\t      flag = set_union_with_increment (tmp, pts, 0);\n \n \t\t      if (flag)\n \t\t\t{\n-\t\t\t  get_varinfo (j)->solution = tmp;\n-\t\t\t  if (!TEST_BIT (changed, j))\n+\t\t\t  get_varinfo (to)->solution = tmp;\n+\t\t\t  if (!TEST_BIT (changed, to))\n \t\t\t    {\n-\t\t\t      SET_BIT (changed, j);\n+\t\t\t      SET_BIT (changed, to);\n \t\t\t      changed_count++;\n \t\t\t    }\n \t\t\t}\n@@ -1707,73 +2130,72 @@ solve_graph (constraint_graph_t graph)\n       bitmap_obstack_release (&iteration_obstack);\n     }\n \n+  BITMAP_FREE (pts);\n   sbitmap_free (changed);\n+  bitmap_obstack_release (&oldpta_obstack);\n }\n \n+/* Map from trees to variable infos.  */\n+static htab_t vi_for_tree;\n \n-/* CONSTRAINT AND VARIABLE GENERATION FUNCTIONS */\n-\n-/* Map from trees to variable ids.  */\n-static htab_t id_for_tree;\n-\n-typedef struct tree_id\n+typedef struct tree_vi\n {\n   tree t;\n-  unsigned int id;\n-} *tree_id_t;\n+  varinfo_t vi;\n+} *tree_vi_t;\n \n /* Hash a tree id structure.  */\n \n static hashval_t\n-tree_id_hash (const void *p)\n+tree_vi_hash (const void *p)\n {\n-  const tree_id_t ta = (tree_id_t) p;\n+  const tree_vi_t ta = (tree_vi_t) p;\n   return htab_hash_pointer (ta->t);\n }\n \n /* Return true if the tree in P1 and the tree in P2 are the same.  */\n \n static int\n-tree_id_eq (const void *p1, const void *p2)\n+tree_vi_eq (const void *p1, const void *p2)\n {\n-  const tree_id_t ta1 = (tree_id_t) p1;\n-  const tree_id_t ta2 = (tree_id_t) p2;\n+  const tree_vi_t ta1 = (tree_vi_t) p1;\n+  const tree_vi_t ta2 = (tree_vi_t) p2;\n   return ta1->t == ta2->t;\n }\n \n /* Insert ID as the variable id for tree T in the hashtable.  */\n \n static void\n-insert_id_for_tree (tree t, int id)\n+insert_vi_for_tree (tree t, varinfo_t vi)\n {\n   void **slot;\n-  struct tree_id finder;\n-  tree_id_t new_pair;\n+  struct tree_vi finder;\n+  tree_vi_t new_pair;\n \n   finder.t = t;\n-  slot = htab_find_slot (id_for_tree, &finder, INSERT);\n+  slot = htab_find_slot (vi_for_tree, &finder, INSERT);\n   gcc_assert (*slot == NULL);\n-  new_pair = XNEW (struct tree_id);\n+  new_pair = XNEW (struct tree_vi);\n   new_pair->t = t;\n-  new_pair->id = id;\n+  new_pair->vi = vi;\n   *slot = (void *)new_pair;\n }\n \n-/* Find the variable id for tree T in ID_FOR_TREE.  If T does not\n+/* Find the variable info for tree T in VI_FOR_TREE.  If T does not\n    exist in the hash table, return false, otherwise, return true and\n-   set *ID to the id we found.  */\n+   set *VI to the varinfo we found.  */\n \n static bool\n-lookup_id_for_tree (tree t, unsigned int *id)\n+lookup_vi_for_tree (tree t, varinfo_t *vi)\n {\n-  tree_id_t pair;\n-  struct tree_id finder;\n+  tree_vi_t pair;\n+  struct tree_vi finder;\n \n   finder.t = t;\n-  pair = htab_find (id_for_tree,  &finder);\n+  pair = htab_find (vi_for_tree,  &finder);\n   if (pair == NULL)\n     return false;\n-  *id = pair->id;\n+  *vi = pair->vi;\n   return true;\n }\n \n@@ -1814,18 +2236,18 @@ alias_get_name (tree decl)\n /* Find the variable id for tree T in the hashtable.\n    If T doesn't exist in the hash table, create an entry for it.  */\n \n-static unsigned int\n-get_id_for_tree (tree t)\n+static varinfo_t\n+get_vi_for_tree (tree t)\n {\n-  tree_id_t pair;\n-  struct tree_id finder;\n+  tree_vi_t pair;\n+  struct tree_vi finder;\n \n   finder.t = t;\n-  pair = htab_find (id_for_tree,  &finder);\n+  pair = htab_find (vi_for_tree,  &finder);\n   if (pair == NULL)\n-    return create_variable_info_for (t, alias_get_name (t));\n+    return get_varinfo (create_variable_info_for (t, alias_get_name (t)));\n \n-  return pair->id;\n+  return pair->vi;\n }\n \n /* Get a constraint expression from an SSA_VAR_P node.  */\n@@ -1846,12 +2268,12 @@ get_constraint_exp_from_ssa_var (tree t)\n \n   cexpr.type = SCALAR;\n \n-  cexpr.var = get_id_for_tree (t);\n+  cexpr.var = get_vi_for_tree (t)->id;\n   /* If we determine the result is \"anything\", and we know this is readonly,\n      say it points to readonly memory instead.  */\n   if (cexpr.var == anything_id && TREE_READONLY (t))\n     {\n-      cexpr.type = INCLUDES;\n+      cexpr.type = ADDRESSOF;\n       cexpr.var = readonly_id;\n     }\n \n@@ -1871,8 +2293,6 @@ process_constraint (constraint_t t)\n   gcc_assert (rhs.var < VEC_length (varinfo_t, varmap));\n   gcc_assert (lhs.var < VEC_length (varinfo_t, varmap));\n \n-  gcc_assert (lhs.type != INCLUDES);\n-\n   if (lhs.type == DEREF)\n     get_varinfo (lhs.var)->directly_dereferenced = true;\n   if (rhs.type == DEREF)\n@@ -1889,8 +2309,7 @@ process_constraint (constraint_t t)\n     return;\n \n   /* If we have &ANYTHING = something, convert to SOMETHING = &ANYTHING) */\n-  else if (lhs.var == anything_id\n-\t   && (lhs.type == INCLUDES || lhs.type == ADDRESSOF))\n+  else if (lhs.var == anything_id && lhs.type == ADDRESSOF)\n     {\n       rhs = t->lhs;\n       t->lhs = t->rhs;\n@@ -1916,20 +2335,9 @@ process_constraint (constraint_t t)\n       process_constraint (new_constraint (tmplhs, rhs));\n       process_constraint (new_constraint (lhs, tmplhs));\n     }\n-  else if (rhs.type == ADDRESSOF)\n-    {\n-      varinfo_t vi;\n-      gcc_assert (rhs.offset == 0);\n-\n-      for (vi = get_varinfo (rhs.var); vi != NULL; vi = vi->next)\n-\tvi->address_taken = true;\n-\n-      VEC_safe_push (constraint_t, heap, constraints, t);\n-    }\n   else\n     {\n-      if (lhs.type != DEREF && rhs.type == DEREF)\n-\tget_varinfo (lhs.var)->indirect_target = true;\n+      gcc_assert (rhs.type != ADDRESSOF || rhs.offset == 0);\n       VEC_safe_push (constraint_t, heap, constraints, t);\n     }\n }\n@@ -2232,7 +2640,7 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n \t\tvi = get_varinfo (temp.var);\n \t\tvi->is_artificial_var = 1;\n \t\tvi->is_heap_var = 1;\n-\t\ttemp.type = INCLUDES;\n+\t\ttemp.type = ADDRESSOF;\n \t\ttemp.offset = 0;\n \t\tVEC_safe_push (ce_s, heap, *results, &temp);\n \t\treturn;\n@@ -2969,7 +3377,6 @@ find_func_aliases (tree origt)\n     {\n       tree lhsop;\n       tree rhsop;\n-      unsigned int varid;\n       tree arglist;\n       varinfo_t fi;\n       int i = 1;\n@@ -2991,17 +3398,16 @@ find_func_aliases (tree origt)\n \t we should still be able to handle.  */\n       if (decl)\n \t{\n-\t  varid = get_id_for_tree (decl);\n+\t  fi = get_vi_for_tree (decl);\n \t}\n       else\n \t{\n \t  decl = TREE_OPERAND (rhsop, 0);\n-\t  varid = get_id_for_tree (decl);\n+\t  fi = get_vi_for_tree (decl);\n \t}\n \n       /* Assign all the passed arguments to the appropriate incoming\n \t parameters of the function.  */\n-      fi = get_varinfo (varid);\n       arglist = TREE_OPERAND (rhsop, 1);\n \n       for (;arglist; arglist = TREE_CHAIN (arglist))\n@@ -3388,7 +3794,7 @@ make_constraint_from_anything (varinfo_t vi)\n \n   rhs.var = anything_id;\n   rhs.offset = 0;\n-  rhs.type = INCLUDES;\n+  rhs.type = ADDRESSOF;\n   process_constraint (new_constraint (lhs, rhs));\n }\n \n@@ -3429,13 +3835,13 @@ create_function_info_for (tree decl, const char *name)\n \n   /* Create the variable info.  */\n \n-  vi = new_var_info (decl, index, name, index);\n+  vi = new_var_info (decl, index, name);\n   vi->decl = decl;\n   vi->offset = 0;\n   vi->has_union = 0;\n   vi->size = 1;\n   vi->fullsize = count_num_arguments (decl, &is_varargs) + 1;\n-  insert_id_for_tree (vi->decl, index);\n+  insert_vi_for_tree (vi->decl, vi);\n   VEC_safe_push (varinfo_t, heap, varmap, vi);\n \n   stats.total_vars++;\n@@ -3471,7 +3877,7 @@ create_function_info_for (tree decl, const char *name)\n       newname = ggc_strdup (tempname);\n       free (tempname);\n \n-      argvi = new_var_info (argdecl, newindex,newname, newindex);\n+      argvi = new_var_info (argdecl, newindex, newname);\n       argvi->decl = argdecl;\n       VEC_safe_push (varinfo_t, heap, varmap, argvi);\n       argvi->offset = i;\n@@ -3482,7 +3888,7 @@ create_function_info_for (tree decl, const char *name)\n       stats.total_vars ++;\n       if (arg)\n \t{\n-\t  insert_id_for_tree (arg, newindex);\n+\t  insert_vi_for_tree (arg, argvi);\n \t  arg = TREE_CHAIN (arg);\n \t}\n     }\n@@ -3507,7 +3913,7 @@ create_function_info_for (tree decl, const char *name)\n       newname = ggc_strdup (tempname);\n       free (tempname);\n \n-      resultvi = new_var_info (resultdecl, newindex, newname, newindex);\n+      resultvi = new_var_info (resultdecl, newindex, newname);\n       resultvi->decl = resultdecl;\n       VEC_safe_push (varinfo_t, heap, varmap, resultvi);\n       resultvi->offset = i;\n@@ -3517,7 +3923,7 @@ create_function_info_for (tree decl, const char *name)\n       insert_into_field_list_sorted (vi, resultvi);\n       stats.total_vars ++;\n       if (DECL_RESULT (decl))\n-\tinsert_id_for_tree (DECL_RESULT (decl), newindex);\n+\tinsert_vi_for_tree (DECL_RESULT (decl), resultvi);\n     }\n   return index;\n }\n@@ -3577,7 +3983,7 @@ create_variable_info_for (tree decl, const char *name)\n   /* If the variable doesn't have subvars, we may end up needing to\n      sort the field list and create fake variables for all the\n      fields.  */\n-  vi = new_var_info (decl, index, name, index);\n+  vi = new_var_info (decl, index, name);\n   vi->decl = decl;\n   vi->offset = 0;\n   vi->has_union = hasunion;\n@@ -3596,7 +4002,7 @@ create_variable_info_for (tree decl, const char *name)\n       vi->size = vi->fullsize;\n     }\n \n-  insert_id_for_tree (vi->decl, index);\n+  insert_vi_for_tree (vi->decl, vi);\n   VEC_safe_push (varinfo_t, heap, varmap, vi);\n   if (is_global && (!flag_whole_program || !in_ipa_mode))\n     make_constraint_from_anything (vi);\n@@ -3672,7 +4078,7 @@ create_variable_info_for (tree decl, const char *name)\n \t      newname = ggc_strdup (tempname);\n \t      free (tempname);\n \t    }\n-\t  newvi = new_var_info (decl, newindex, newname, newindex);\n+\t  newvi = new_var_info (decl, newindex, newname);\n \t  newvi->offset = fo->offset;\n \t  newvi->size = TREE_INT_CST_LOW (fo->size);\n \t  newvi->fullsize = vi->fullsize;\n@@ -3697,15 +4103,15 @@ dump_solution_for_var (FILE *file, unsigned int var)\n   unsigned int i;\n   bitmap_iterator bi;\n \n-  if (vi->node != var)\n+  if (find (var) != var)\n     {\n-      varinfo_t vipt = get_varinfo (vi->node);\n+      varinfo_t vipt = get_varinfo (find (var));\n       fprintf (file, \"%s = same as %s\\n\", vi->name, vipt->name);\n     }\n   else\n     {\n       fprintf (file, \"%s = { \", vi->name);\n-      EXECUTE_IF_SET_IN_BITMAP (get_varinfo (vi->node)->solution, 0, i, bi)\n+      EXECUTE_IF_SET_IN_BITMAP (vi->solution, 0, i, bi)\n \t{\n \t  fprintf (file, \"%s \", get_varinfo (i)->name);\n \t}\n@@ -3735,13 +4141,10 @@ intra_create_variable_infos (void)\n   for (t = DECL_ARGUMENTS (current_function_decl); t; t = TREE_CHAIN (t))\n     {\n       varinfo_t p;\n-      unsigned int arg_id;\n \n       if (!could_have_pointers (t))\n \tcontinue;\n \n-      arg_id = get_id_for_tree (t);\n-\n       /* With flag_argument_noalias greater than two means that the incoming\n \t argument cannot alias anything except for itself so create a HEAP\n \t variable.  */\n@@ -3750,11 +4153,10 @@ intra_create_variable_infos (void)\n \t{\n \t  varinfo_t vi;\n \t  tree heapvar = heapvar_lookup (t);\n-\t  unsigned int id;\n \n \t  lhs.offset = 0;\n \t  lhs.type = SCALAR;\n-\t  lhs.var  = get_id_for_tree (t);\n+\t  lhs.var  = get_vi_for_tree (t)->id;\n \n \t  if (heapvar == NULL_TREE)\n \t    {\n@@ -3766,12 +4168,11 @@ intra_create_variable_infos (void)\n \t\tadd_referenced_var (heapvar);\n \t      heapvar_insert (t, heapvar);\n \t    }\n-\t  id = get_id_for_tree (heapvar);\n-\t  vi = get_varinfo (id);\n+\t  vi = get_vi_for_tree (heapvar);\n \t  vi->is_artificial_var = 1;\n \t  vi->is_heap_var = 1;\n-\t  rhs.var = id;\n-\t  rhs.type = INCLUDES;\n+\t  rhs.var = vi->id;\n+\t  rhs.type = ADDRESSOF;\n \t  rhs.offset = 0;\n \t  for (p = get_varinfo (lhs.var); p; p = p->next)\n \t    {\n@@ -3782,7 +4183,9 @@ intra_create_variable_infos (void)\n \t}\n       else\n \t{\n-\t  for (p = get_varinfo (arg_id); p; p = p->next)\n+\t  varinfo_t arg_vi = get_vi_for_tree (t);\n+\n+\t  for (p = arg_vi; p; p = p->next)\n \t    make_constraint_from_anything (p);\n \t}\n     }\n@@ -3872,15 +4275,15 @@ set_used_smts (void)\n {\n   int i;\n   varinfo_t vi;\n-  used_smts = BITMAP_ALLOC (&ptabitmap_obstack);\n+  used_smts = BITMAP_ALLOC (&pta_obstack);\n \n   for (i = 0; VEC_iterate (varinfo_t, varmap, i, vi); i++)\n     {\n       tree var = vi->decl;\n       tree smt;\n       var_ann_t va;\n       struct ptr_info_def *pi = NULL;\n-      \n+\n       /* For parm decls, the pointer info may be under the default\n \t def.  */\n       if (TREE_CODE (vi->decl) == PARM_DECL\n@@ -3891,8 +4294,9 @@ set_used_smts (void)\n \n       /* Skip the special variables and those without their own\n \t solution set.  */\n-      if (vi->is_special_var || vi->node != vi->id || !SSA_VAR_P (var)\n-\t  || (pi && !pi->is_dereferenced) \n+      if (vi->is_special_var || find (vi->id) != vi->id\n+\t  || !SSA_VAR_P (var)\n+\t  || (pi && !pi->is_dereferenced)\n \t  || (TREE_CODE (var) == VAR_DECL && !may_be_aliased (var))\n \t  || !POINTER_TYPE_P (TREE_TYPE (var)))\n \tcontinue;\n@@ -3957,7 +4361,7 @@ merge_smts_into (tree p, varinfo_t vi)\n }\n \n /* Given a pointer variable P, fill in its points-to set, or return\n-   false if we can't.  \n+   false if we can't.\n    Rather than return false for variables that point-to anything, we\n    instead find the corresponding SMT, and merge in it's aliases.  In\n    addition to these aliases, we also set the bits for the SMT's\n@@ -3970,8 +4374,8 @@ merge_smts_into (tree p, varinfo_t vi)\n bool\n find_what_p_points_to (tree p)\n {\n-  unsigned int id = 0;\n   tree lookup_p = p;\n+  varinfo_t vi;\n \n   if (!have_alias_info)\n     return false;\n@@ -3983,9 +4387,8 @@ find_what_p_points_to (tree p)\n       && SSA_NAME_IS_DEFAULT_DEF (p))\n     lookup_p = SSA_NAME_VAR (p);\n \n-  if (lookup_id_for_tree (lookup_p, &id))\n+  if (lookup_vi_for_tree (lookup_p, &vi))\n     {\n-      varinfo_t vi = get_varinfo (id);\n \n       if (vi->is_artificial_var)\n \treturn false;\n@@ -4012,7 +4415,7 @@ find_what_p_points_to (tree p)\n \n \t  /* This variable may have been collapsed, let's get the real\n \t     variable.  */\n-\t  vi = get_varinfo (vi->node);\n+\t  vi = get_varinfo (find (vi->id));\n \n \t  /* Translate artificial variables into SSA_NAME_PTR_INFO\n \t     attributes.  */\n@@ -4052,6 +4455,7 @@ find_what_p_points_to (tree p)\n \t  else\n \t    {\n \t      vi->finished_solution = BITMAP_GGC_ALLOC ();\n+\t      stats.points_to_sets_created++;\n \n \t      /* Instead of using pt_anything, we instead merge in the SMT\n \t\t aliases for the underlying SMT.  */\n@@ -4090,13 +4494,16 @@ dump_sa_points_to_info (FILE *outfile)\n     {\n       fprintf (outfile, \"Stats:\\n\");\n       fprintf (outfile, \"Total vars:               %d\\n\", stats.total_vars);\n+      fprintf (outfile, \"Non-pointer vars:          %d\\n\",\n+\t       stats.nonpointer_vars);\n       fprintf (outfile, \"Statically unified vars:  %d\\n\",\n \t       stats.unified_vars_static);\n-      fprintf (outfile, \"Collapsed vars:           %d\\n\", stats.collapsed_vars);\n       fprintf (outfile, \"Dynamically unified vars: %d\\n\",\n \t       stats.unified_vars_dynamic);\n       fprintf (outfile, \"Iterations:               %d\\n\", stats.iterations);\n       fprintf (outfile, \"Number of edges:          %d\\n\", stats.num_edges);\n+      fprintf (outfile, \"Number of implicit edges: %d\\n\",\n+\t       stats.num_implicit_edges);\n     }\n \n   for (i = 0; i < VEC_length (varinfo_t, varmap); i++)\n@@ -4124,8 +4531,8 @@ init_base_vars (void)\n   /* Create the NULL variable, used to represent that a variable points\n      to NULL.  */\n   nothing_tree = create_tmp_var_raw (void_type_node, \"NULL\");\n-  var_nothing = new_var_info (nothing_tree, 0, \"NULL\", 0);\n-  insert_id_for_tree (nothing_tree, 0);\n+  var_nothing = new_var_info (nothing_tree, 0, \"NULL\");\n+  insert_vi_for_tree (nothing_tree, var_nothing);\n   var_nothing->is_artificial_var = 1;\n   var_nothing->offset = 0;\n   var_nothing->size = ~0;\n@@ -4137,8 +4544,8 @@ init_base_vars (void)\n   /* Create the ANYTHING variable, used to represent that a variable\n      points to some unknown piece of memory.  */\n   anything_tree = create_tmp_var_raw (void_type_node, \"ANYTHING\");\n-  var_anything = new_var_info (anything_tree, 1, \"ANYTHING\", 1);\n-  insert_id_for_tree (anything_tree, 1);\n+  var_anything = new_var_info (anything_tree, 1, \"ANYTHING\");\n+  insert_vi_for_tree (anything_tree, var_anything);\n   var_anything->is_artificial_var = 1;\n   var_anything->size = ~0;\n   var_anything->offset = 0;\n@@ -4154,10 +4561,9 @@ init_base_vars (void)\n   lhs.type = SCALAR;\n   lhs.var = anything_id;\n   lhs.offset = 0;\n-  rhs.type = INCLUDES;\n+  rhs.type = ADDRESSOF;\n   rhs.var = anything_id;\n   rhs.offset = 0;\n-  var_anything->address_taken = true;\n \n   /* This specifically does not use process_constraint because\n      process_constraint ignores all anything = anything constraints, since all\n@@ -4167,14 +4573,14 @@ init_base_vars (void)\n   /* Create the READONLY variable, used to represent that a variable\n      points to readonly memory.  */\n   readonly_tree = create_tmp_var_raw (void_type_node, \"READONLY\");\n-  var_readonly = new_var_info (readonly_tree, 2, \"READONLY\", 2);\n+  var_readonly = new_var_info (readonly_tree, 2, \"READONLY\");\n   var_readonly->is_artificial_var = 1;\n   var_readonly->offset = 0;\n   var_readonly->size = ~0;\n   var_readonly->fullsize = ~0;\n   var_readonly->next = NULL;\n   var_readonly->is_special_var = 1;\n-  insert_id_for_tree (readonly_tree, 2);\n+  insert_vi_for_tree (readonly_tree, var_readonly);\n   readonly_id = 2;\n   VEC_safe_push (varinfo_t, heap, varmap, var_readonly);\n \n@@ -4185,7 +4591,7 @@ init_base_vars (void)\n   lhs.type = SCALAR;\n   lhs.var = readonly_id;\n   lhs.offset = 0;\n-  rhs.type = INCLUDES;\n+  rhs.type = ADDRESSOF;\n   rhs.var = anything_id;\n   rhs.offset = 0;\n \n@@ -4194,8 +4600,8 @@ init_base_vars (void)\n   /* Create the INTEGER variable, used to represent that a variable points\n      to an INTEGER.  */\n   integer_tree = create_tmp_var_raw (void_type_node, \"INTEGER\");\n-  var_integer = new_var_info (integer_tree, 3, \"INTEGER\", 3);\n-  insert_id_for_tree (integer_tree, 3);\n+  var_integer = new_var_info (integer_tree, 3, \"INTEGER\");\n+  insert_vi_for_tree (integer_tree, var_integer);\n   var_integer->is_artificial_var = 1;\n   var_integer->size = ~0;\n   var_integer->fullsize = ~0;\n@@ -4210,7 +4616,7 @@ init_base_vars (void)\n   lhs.type = SCALAR;\n   lhs.var = integer_id;\n   lhs.offset = 0;\n-  rhs.type = INCLUDES;\n+  rhs.type = ADDRESSOF;\n   rhs.var = anything_id;\n   rhs.offset = 0;\n   process_constraint (new_constraint (lhs, rhs));\n@@ -4221,7 +4627,8 @@ init_base_vars (void)\n static void\n init_alias_vars (void)\n {\n-  bitmap_obstack_initialize (&ptabitmap_obstack);\n+  bitmap_obstack_initialize (&pta_obstack);\n+  bitmap_obstack_initialize (&oldpta_obstack);\n   bitmap_obstack_initialize (&predbitmap_obstack);\n \n   constraint_pool = create_alloc_pool (\"Constraint pool\",\n@@ -4230,18 +4637,56 @@ init_alias_vars (void)\n \t\t\t\t\t  sizeof (struct variable_info), 30);\n   constraints = VEC_alloc (constraint_t, heap, 8);\n   varmap = VEC_alloc (varinfo_t, heap, 8);\n-  id_for_tree = htab_create (10, tree_id_hash, tree_id_eq, free);\n+  vi_for_tree = htab_create (10, tree_vi_hash, tree_vi_eq, free);\n+\n   memset (&stats, 0, sizeof (stats));\n \n   init_base_vars ();\n }\n \n+/* Remove the REF and ADDRESS edges from GRAPH, as well as all the\n+   predecessor edges.  */\n+\n+static void\n+remove_preds_and_fake_succs (constraint_graph_t graph)\n+{\n+  unsigned int i;\n+\n+  /* Clear the implicit ref and address nodes from the successor\n+     lists.  */\n+  for (i = 0; i < FIRST_REF_NODE; i++)\n+    {\n+      if (graph->succs[i])\n+\tbitmap_clear_range (graph->succs[i], FIRST_REF_NODE,\n+\t\t\t    FIRST_REF_NODE * 2);\n+    }\n+\n+  /* Free the successor list for the non-ref nodes.  */\n+  for (i = FIRST_REF_NODE; i < graph->size; i++)\n+    {\n+      if (graph->succs[i])\n+\tBITMAP_FREE (graph->succs[i]);\n+    }\n+\n+  /* Now reallocate the size of the successor list as, and blow away\n+     the predecessor bitmaps.  */\n+  graph->size = VEC_length (varinfo_t, varmap);\n+  graph->succs = xrealloc (graph->succs, graph->size * sizeof (bitmap));\n+\n+  free (graph->implicit_preds);\n+  graph->implicit_preds = NULL;\n+  free (graph->preds);\n+  graph->preds = NULL;\n+  bitmap_obstack_release (&predbitmap_obstack);\n+}\n+\n /* Create points-to sets for the current function.  See the comments\n    at the start of the file for an algorithmic overview.  */\n \n void\n compute_points_to_sets (struct alias_info *ai)\n {\n+  struct scc_info *si;\n   basic_block bb;\n \n   timevar_push (TV_TREE_PTA);\n@@ -4283,7 +4728,6 @@ compute_points_to_sets (struct alias_info *ai)\n \t}\n     }\n \n-  build_constraint_graph ();\n \n   if (dump_file)\n     {\n@@ -4295,9 +4739,17 @@ compute_points_to_sets (struct alias_info *ai)\n     fprintf (dump_file,\n \t     \"\\nCollapsing static cycles and doing variable \"\n \t     \"substitution:\\n\");\n+  build_pred_graph ();\n+  si = perform_var_substitution (graph);\n+  move_complex_constraints (graph, si);\n+  free_var_substitution_info (si);\n+\n+  build_succ_graph ();\n+  find_indirect_cycles (graph);\n \n-  find_and_collapse_graph_cycles (graph, false);\n-  perform_var_substitution (graph);\n+  /* Implicit nodes and predecessors are no longer necessary at this\n+     point. */\n+  remove_preds_and_fake_succs (graph);\n \n   if (dump_file)\n     fprintf (dump_file, \"\\nSolving graph:\\n\");\n@@ -4321,16 +4773,20 @@ delete_points_to_sets (void)\n   varinfo_t v;\n   int i;\n \n-  htab_delete (id_for_tree);\n-  bitmap_obstack_release (&ptabitmap_obstack);\n-  bitmap_obstack_release (&predbitmap_obstack);\n+  if (dump_file && (dump_flags & TDF_STATS))\n+    fprintf (dump_file, \"Points to sets created:%d\\n\",\n+\t     stats.points_to_sets_created);\n+\n+  htab_delete (vi_for_tree);\n+  bitmap_obstack_release (&pta_obstack);\n   VEC_free (constraint_t, heap, constraints);\n \n   for (i = 0; VEC_iterate (varinfo_t, varmap, i, v); i++)\n-    VEC_free (constraint_t, heap, v->complex);\n+    VEC_free (constraint_t, heap, graph->complex[i]);\n \n-  free (graph->preds);\n+  free (graph->rep);\n   free (graph->succs);\n+  free (graph->indirect_cycles);\n   free (graph);\n \n   VEC_free (varinfo_t, heap, varmap);\n@@ -4354,6 +4810,8 @@ static unsigned int\n ipa_pta_execute (void)\n {\n   struct cgraph_node *node;\n+  struct scc_info *si;\n+\n   in_ipa_mode = 1;\n   init_alias_heapvars ();\n   init_alias_vars ();\n@@ -4416,7 +4874,7 @@ ipa_pta_execute (void)\n \t}\n     }\n \n-  build_constraint_graph ();\n+\n \n   if (dump_file)\n     {\n@@ -4429,8 +4887,17 @@ ipa_pta_execute (void)\n \t     \"\\nCollapsing static cycles and doing variable \"\n \t     \"substitution:\\n\");\n \n-  find_and_collapse_graph_cycles (graph, false);\n-  perform_var_substitution (graph);\n+  build_pred_graph ();\n+  si = perform_var_substitution (graph);\n+  move_complex_constraints (graph, si);\n+  free_var_substitution_info (si);\n+\n+  build_succ_graph ();\n+  find_indirect_cycles (graph);\n+\n+  /* Implicit nodes and predecessors are no longer necessary at this\n+     point. */\n+  remove_preds_and_fake_succs (graph);\n \n   if (dump_file)\n     fprintf (dump_file, \"\\nSolving graph:\\n\");"}]}