{"sha": "b7a89c041aa1d67654f1ba7b2839e221c3e14748", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdhODljMDQxYWExZDY3NjU0ZjFiYTdiMjgzOWUyMjFjM2UxNDc0OA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-06-28T11:59:19Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-06-28T13:20:55Z"}, "message": "libstdc++: Allow unique_ptr<Incomplete[]>::operator[] [PR 101236]\n\nPR libstdc++/101236 shows that LLVM depends on being able to use\nunique_ptr<T[]>::operator[] when T is incomplete. This is undefined, but\npreviously worked with libstdc++. When I added the conditional noexcept\nto that operator we started to diagnose the incomplete type.\n\nThis change restores support for that case, by making the noexcept\ncondition check that the type is complete before checking whether\nindexing on the pointer can throw.  A workaround for PR c++/101239 is\nneeded to avoid a bogus error where G++ fails to do SFINAE on the\nill-formed p[n] expression and gets an ICE. Instead of checking that the\np[n] expression is valid in the trailing-return-type, we only check that\nthe element_type is complete.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/101236\n\t* include/bits/unique_ptr.h (unique_ptr<T[], D>::operator[]):\n\tFail gracefully if element_type is incomplete.\n\t* testsuite/20_util/unique_ptr/cons/incomplete.cc: Clarify that\n\tthe standard doesn't require this test to work for array types.\n\t* testsuite/20_util/unique_ptr/lwg2762.cc: Check that incomplete\n\ttypes can be used with array specialization.\n\t* testsuite/20_util/unique_ptr/101236.cc: New test.", "tree": {"sha": "fe538e67277bcde4e2e2df8cc6d4f39b1151193c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe538e67277bcde4e2e2df8cc6d4f39b1151193c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7a89c041aa1d67654f1ba7b2839e221c3e14748", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7a89c041aa1d67654f1ba7b2839e221c3e14748", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7a89c041aa1d67654f1ba7b2839e221c3e14748", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7a89c041aa1d67654f1ba7b2839e221c3e14748/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5c422b7d8af6f42f8ab230133210742b7ac5661", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5c422b7d8af6f42f8ab230133210742b7ac5661", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5c422b7d8af6f42f8ab230133210742b7ac5661"}], "stats": {"total": 69, "additions": 58, "deletions": 11}, "files": [{"sha": "e478056c755bcd99f6f93f699ee63b53e0161fdb", "filename": "libstdc++-v3/include/bits/unique_ptr.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a89c041aa1d67654f1ba7b2839e221c3e14748/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a89c041aa1d67654f1ba7b2839e221c3e14748/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_ptr.h?ref=b7a89c041aa1d67654f1ba7b2839e221c3e14748", "patch": "@@ -491,6 +491,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  = __and_< is_base_of<_Tp, _Up>,\n \t\t    __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;\n \n+      // This checks whether p[n] is noexcept, but fails gracefully when\n+      // element_type is incomplete. The standard requires a complete type\n+      // for unique_ptr<T[], D>, but we try to support it anyway (PR 101236).\n+      template<typename _Ptr, typename _Elt>\n+\tstatic constexpr auto\n+\t_S_nothrow_deref(size_t __n)\n+\t-> decltype(sizeof(_Elt) != 0) // PR c++/101239\n+\t{ return noexcept(std::declval<_Ptr>()[__n]); }\n+\n+      template<typename _Ptr, typename _Elt>\n+\tstatic constexpr bool\n+\t_S_nothrow_deref(...)\n+\t{ return false; }\n+\n     public:\n       using pointer\t  = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;\n       using element_type  = _Tp;\n@@ -655,7 +669,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       /// Access an element of owned array.\n       typename std::add_lvalue_reference<element_type>::type\n       operator[](size_t __i) const\n-      noexcept(noexcept(std::declval<pointer>()[std::declval<size_t&>()]))\n+      noexcept(_S_nothrow_deref<pointer, element_type>(0))\n       {\n \t__glibcxx_assert(get() != pointer());\n \treturn get()[__i];"}, {"sha": "2f55f4baf9afcc527b5ae6a5a5dbfe11a5277b5f", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/101236.cc", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a89c041aa1d67654f1ba7b2839e221c3e14748/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2F101236.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a89c041aa1d67654f1ba7b2839e221c3e14748/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2F101236.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2F101236.cc?ref=b7a89c041aa1d67654f1ba7b2839e221c3e14748", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile { target c++11 } }\n+#include <memory>\n+\n+struct Incomplete;\n+struct pr101236\n+{\n+  // The standard says \"T shall be a complete type\" for unique_ptr<T[], D>\n+  // so this is a GCC extension.\n+  std::unique_ptr<Incomplete[]> p;\n+\n+  Incomplete& f() { return p[0]; }\n+};\n+struct Incomplete { };"}, {"sha": "6b55d5744ed16d687979e23593b18546c7e5c928", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/cons/incomplete.cc", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a89c041aa1d67654f1ba7b2839e221c3e14748/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fincomplete.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a89c041aa1d67654f1ba7b2839e221c3e14748/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fincomplete.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Fcons%2Fincomplete.cc?ref=b7a89c041aa1d67654f1ba7b2839e221c3e14748", "patch": "@@ -24,9 +24,17 @@ struct Incomplete;\n void f(void** p)\n {\n   ::new (p[0]) std::unique_ptr<Incomplete>();\n-  ::new (p[1]) std::unique_ptr<Incomplete[]>();\n \n   // PR libstdc++/87704\n-  ::new (p[2]) std::unique_ptr<Incomplete>(nullptr);\n-  ::new (p[3]) std::unique_ptr<Incomplete[]>(nullptr);\n+  ::new (p[1]) std::unique_ptr<Incomplete>(nullptr);\n+}\n+\n+// The standard says \"T shall be a complete type\" for unique_ptr<T[], D>\n+// so this is a GCC extension.\n+void f_array(void** p)\n+{\n+  ::new (p[0]) std::unique_ptr<Incomplete[]>();\n+\n+  // PR libstdc++/87704\n+  ::new (p[1]) std::unique_ptr<Incomplete[]>(nullptr);\n }"}, {"sha": "c88237dd9ea1ed74a949b14bbaa7016765a595e3", "filename": "libstdc++-v3/testsuite/20_util/unique_ptr/lwg2762.cc", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a89c041aa1d67654f1ba7b2839e221c3e14748/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Flwg2762.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a89c041aa1d67654f1ba7b2839e221c3e14748/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Flwg2762.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funique_ptr%2Flwg2762.cc?ref=b7a89c041aa1d67654f1ba7b2839e221c3e14748", "patch": "@@ -32,12 +32,24 @@ template<typename T, bool Nothrow>\n   using UPtr = std::unique_ptr<T, deleter<Nothrow>>;\n \n // noexcept-specifier depends on the pointer type\n-static_assert( noexcept(*std::declval<UPtr<int, true>&>()), \"\" );\n-static_assert( ! noexcept(*std::declval<UPtr<int, false>&>()), \"\" );\n+static_assert( noexcept(*std::declval<UPtr<int, true>&>()), \"LWG 2762\" );\n+static_assert( ! noexcept(*std::declval<UPtr<int, false>&>()), \"LWG 2762\" );\n \n // This has always been required, even in C++11.\n-static_assert( noexcept(std::declval<UPtr<int, false>&>().operator->()), \"\" );\n-\n-// This is not required by the standard\n-static_assert( noexcept(std::declval<UPtr<int[], true>&>()[0]), \"\" );\n-static_assert( ! noexcept(std::declval<UPtr<int[], false>&>()[0]), \"\" );\n+static_assert( noexcept(std::declval<std::unique_ptr<long>>().operator->()),\n+\t       \"operator-> is always noexcept\" );\n+static_assert( noexcept(std::declval<UPtr<int, false>&>().operator->()),\n+\t       \"operator-> is always noexcept\" );\n+\n+// This is not required by the standard, but we make it depend on the pointer.\n+static_assert( noexcept(std::declval<std::unique_ptr<long[]>>()[0]), \"QoI\" );\n+static_assert( noexcept(std::declval<UPtr<int[], true>&>()[0]), \"QoI\" );\n+static_assert( ! noexcept(std::declval<UPtr<int[], false>&>()[0]), \"QoI\" );\n+\n+// This is forbidden by the standard (\"T shall be a complete type\")\n+// but we try to support it anyway, see PR libstdc++/101236.\n+struct Incomplete;\n+static_assert( ! noexcept(std::declval<UPtr<Incomplete[], true>>()[0]),\n+\t       \"this would be noexcept if the type was complete\");\n+static_assert( ! noexcept(std::declval<UPtr<Incomplete[], false>>()[0]),\n+\t       \"this would still be noexcept(false) if the type was complete\");"}]}