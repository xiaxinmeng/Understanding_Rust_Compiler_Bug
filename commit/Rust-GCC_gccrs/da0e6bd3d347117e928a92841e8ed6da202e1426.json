{"sha": "da0e6bd3d347117e928a92841e8ed6da202e1426", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGEwZTZiZDNkMzQ3MTE3ZTkyOGE5Mjg0MWU4ZWQ2ZGEyMDJlMTQyNg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-10-18T19:02:20Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-10-18T19:02:20Z"}, "message": "[arm] Early split subdi3\n\nThis patch adds early splitting of subdi3 so that the individual\noperations can be seen by the optimizers, particuarly combine.  This\nshould allow us to do at least as good a job as previously, but with\nfar fewer patterns in the machine description.\n\nThis is just the initial patch to add the early splitting.  The\ncleanups will follow later.\n\nA special trick is used to handle the 'reverse subtract and compare'\nwhere a register is subtracted from a constant.  The natural\ncomparison\n\n    (COMPARE (const) (reg))\n\nis not canonical in this case and combine will never correctly\ngenerate it (trying to swap the order of the operands.  To handle this\nwe write the comparison as\n\n    (COMPARE (NOT (reg)) (~const)),\n\nwhich has the same result for EQ, NE, LTU, LEU, GTU and GEU, which are\nall the cases we are really interested in here.\n\nFinally, we delete the negdi2 pattern.  The generic expanders will use\nour new subdi3 expander if this pattern is missing and that can handle\nthe negate case just fine.\n\n\t* config/arm/arm-modes.def (CC_RSB): New CC mode.\n\t* config/arm/predicates.md (arm_borrow_operation): Handle CC_RSBmode.\n\t* config/arm/arm.c (arm_select_cc_mode): Detect when we should\n\treturn CC_RSBmode.\n\t(maybe_get_arm_condition_code): Handle CC_RSBmode.\n\t* config/arm/arm.md (subsi3_carryin): Make this pattern available to\n\texpand.\n\t(subdi3): Rewrite to early-expand the sub-operations.\n\t(rsb_im_compare): New pattern.\n\t(negdi2): Delete.\n\t(negdi2_insn): Delete.\n\t(arm_negsi2): Correct type attribute to alu_imm.\n\t(negsi2_0compare): New insn pattern.\n\t(negsi2_carryin): New insn pattern.\n\nFrom-SVN: r277169", "tree": {"sha": "57a0adee5f7382d2c66e3aeb11962f8a1b432005", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57a0adee5f7382d2c66e3aeb11962f8a1b432005"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da0e6bd3d347117e928a92841e8ed6da202e1426", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da0e6bd3d347117e928a92841e8ed6da202e1426", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da0e6bd3d347117e928a92841e8ed6da202e1426", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da0e6bd3d347117e928a92841e8ed6da202e1426/comments", "author": null, "committer": null, "parents": [{"sha": "494c4921c7c7970562ab3ee3838809e8e7f0623a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/494c4921c7c7970562ab3ee3838809e8e7f0623a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/494c4921c7c7970562ab3ee3838809e8e7f0623a"}], "stats": {"total": 187, "additions": 158, "deletions": 29}, "files": [{"sha": "0f389a1f3f62bb1a4210c15f7ce469eefe02fa36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da0e6bd3d347117e928a92841e8ed6da202e1426/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da0e6bd3d347117e928a92841e8ed6da202e1426/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da0e6bd3d347117e928a92841e8ed6da202e1426", "patch": "@@ -1,3 +1,20 @@\n+2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm-modes.def (CC_RSB): New CC mode.\n+\t* config/arm/predicates.md (arm_borrow_operation): Handle CC_RSBmode.\n+\t* config/arm/arm.c (arm_select_cc_mode): Detect when we should\n+\treturn CC_RSBmode.\n+\t(maybe_get_arm_condition_code): Handle CC_RSBmode.\n+\t* config/arm/arm.md (subsi3_carryin): Make this pattern available to\n+\texpand.\n+\t(subdi3): Rewrite to early-expand the sub-operations.\n+\t(rsb_im_compare): New pattern.\n+\t(negdi2): Delete.\n+\t(negdi2_insn): Delete.\n+\t(arm_negsi2): Correct type attribute to alu_imm.\n+\t(negsi2_0compare): New insn pattern.\n+\t(negsi2_carryin): New insn pattern.\n+\n 2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm.md (addsi3_carryin_alt2): Use arm_not_operand for"}, {"sha": "4fa7f1b43e50e22e0296b0fbcc727de81d28ee7a", "filename": "gcc/config/arm/arm-modes.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da0e6bd3d347117e928a92841e8ed6da202e1426/gcc%2Fconfig%2Farm%2Farm-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da0e6bd3d347117e928a92841e8ed6da202e1426/gcc%2Fconfig%2Farm%2Farm-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-modes.def?ref=da0e6bd3d347117e928a92841e8ed6da202e1426", "patch": "@@ -36,6 +36,9 @@ ADJUST_FLOAT_FORMAT (HF, ((arm_fp16_format == ARM_FP16_FORMAT_ALTERNATIVE)\n    CC_Nmode should be used if only the N (sign) flag is set correctly\n    CC_CZmode should be used if only the C and Z flags are correct\n    (used for DImode unsigned comparisons).\n+   CC_RSBmode should be used where the comparison is set by an RSB immediate,\n+     or NEG instruction.  The form of the comparison for (const - reg) will\n+     be (COMPARE (not (reg)) (~const)).\n    CC_NCVmode should be used if only the N, C, and V flags are correct\n    (used for DImode signed comparisons).\n    CCmode should be used otherwise.  */\n@@ -45,6 +48,7 @@ CC_MODE (CC_Z);\n CC_MODE (CC_CZ);\n CC_MODE (CC_NCV);\n CC_MODE (CC_SWP);\n+CC_MODE (CC_RSB);\n CC_MODE (CCFP);\n CC_MODE (CCFPE);\n CC_MODE (CC_DNE);"}, {"sha": "41e4832f2c9a70802b80c17f60cece428ccce907", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da0e6bd3d347117e928a92841e8ed6da202e1426/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da0e6bd3d347117e928a92841e8ed6da202e1426/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=da0e6bd3d347117e928a92841e8ed6da202e1426", "patch": "@@ -15214,6 +15214,17 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n \t  || (TARGET_32BIT && GET_CODE (x) == ZERO_EXTRACT)))\n     return CC_NOOVmode;\n \n+  /* An unsigned comparison of ~reg with a const is really a special\n+     canoncialization of compare (~const, reg), which is a reverse\n+     subtract operation.  We may not get here if CONST is 0, but that\n+     doesn't matter because ~0 isn't a valid immediate for RSB.  */\n+  if (GET_MODE (x) == SImode\n+      && GET_CODE (x) == NOT\n+      && CONST_INT_P (y)\n+      && (op == EQ || op == NE\n+\t  || op == LTU || op == LEU || op == GEU || op == GTU))\n+    return CC_RSBmode;\n+\n   if (GET_MODE (x) == QImode && (op == EQ || op == NE))\n     return CC_Zmode;\n \n@@ -23629,6 +23640,18 @@ maybe_get_arm_condition_code (rtx comparison)\n \tdefault: return ARM_NV;\n \t}\n \n+    case E_CC_RSBmode:\n+      switch (comp_code)\n+\t{\n+\tcase NE: return ARM_NE;\n+\tcase EQ: return ARM_EQ;\n+\tcase GEU: return ARM_CS;\n+\tcase GTU: return ARM_HI;\n+\tcase LEU: return ARM_LS;\n+\tcase LTU: return ARM_CC;\n+\tdefault: return ARM_NV;\n+\t}\n+\n     case E_CCmode:\n       switch (comp_code)\n \t{"}, {"sha": "99d931525f85c41c4b4aaff78ed6adb953268a6a", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 113, "deletions": 28, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da0e6bd3d347117e928a92841e8ed6da202e1426/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da0e6bd3d347117e928a92841e8ed6da202e1426/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=da0e6bd3d347117e928a92841e8ed6da202e1426", "patch": "@@ -989,7 +989,7 @@\n    (set_attr \"type\" \"alus_sreg\")]\n )\n \n-(define_insn \"*subsi3_carryin\"\n+(define_insn \"subsi3_carryin\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r,r\")\n \t(minus:SI (minus:SI (match_operand:SI 1 \"reg_or_int_operand\" \"r,I,Pz\")\n \t\t\t    (match_operand:SI 2 \"s_register_operand\" \"r,r,r\"))\n@@ -1094,12 +1094,72 @@\n (define_expand \"subdi3\"\n  [(parallel\n    [(set (match_operand:DI            0 \"s_register_operand\")\n-\t  (minus:DI (match_operand:DI 1 \"s_register_operand\")\n+\t  (minus:DI (match_operand:DI 1 \"reg_or_int_operand\")\n \t\t    (match_operand:DI 2 \"s_register_operand\")))\n     (clobber (reg:CC CC_REGNUM))])]\n   \"TARGET_EITHER\"\n   \"\n-\")\n+  if (TARGET_THUMB1)\n+    {\n+      if (!REG_P (operands[1]))\n+\toperands[1] = force_reg (DImode, operands[1]);\n+    }\n+  else\n+    {\n+      rtx lo_result, hi_result, lo_dest, hi_dest;\n+      rtx lo_op1, hi_op1, lo_op2, hi_op2;\n+      rtx condition;\n+\n+      /* Since operands[1] may be an integer, pass it second, so that\n+\t any necessary simplifications will be done on the decomposed\n+\t constant.  */\n+      arm_decompose_di_binop (operands[2], operands[1], &lo_op2, &hi_op2,\n+\t\t\t      &lo_op1, &hi_op1);\n+      lo_result = lo_dest = gen_lowpart (SImode, operands[0]);\n+      hi_result = hi_dest = gen_highpart (SImode, operands[0]);\n+\n+      if (!arm_rhs_operand (lo_op1, SImode))\n+\tlo_op1 = force_reg (SImode, lo_op1);\n+\n+      if ((TARGET_THUMB2 && ! s_register_operand (hi_op1, SImode))\n+\t  || !arm_rhs_operand (hi_op1, SImode))\n+\thi_op1 = force_reg (SImode, hi_op1);\n+\n+      rtx cc_reg;\n+      if (lo_op1 == const0_rtx)\n+\t{\n+\t  cc_reg = gen_rtx_REG (CC_RSBmode, CC_REGNUM);\n+\t  emit_insn (gen_negsi2_0compare (lo_dest, lo_op2));\n+\t}\n+      else if (CONST_INT_P (lo_op1))\n+\t{\n+\t  cc_reg = gen_rtx_REG (CC_RSBmode, CC_REGNUM);\n+\t  emit_insn (gen_rsb_imm_compare (lo_dest, lo_op1, lo_op2, \n+\t\t\t\t\t  GEN_INT (~UINTVAL (lo_op1))));\n+\t}\n+      else\n+\t{\n+\t  cc_reg = gen_rtx_REG (CCmode, CC_REGNUM);\n+\t  emit_insn (gen_subsi3_compare (lo_dest, lo_op1, lo_op2));\n+\t}\n+\n+      condition = gen_rtx_LTU (SImode, cc_reg, const0_rtx);\n+\n+      if (hi_op1 == const0_rtx)\n+        emit_insn (gen_negsi2_carryin (hi_dest, hi_op2, condition));\n+      else\n+\temit_insn (gen_subsi3_carryin (hi_dest, hi_op1, hi_op2, condition));\n+\n+      if (lo_result != lo_dest)\n+\temit_move_insn (lo_result, lo_dest);\n+\n+      if (hi_result != hi_dest)\n+\temit_move_insn (hi_result, hi_dest);\n+\n+      DONE;\n+    }\n+  \"\n+)\n \n (define_insn \"*arm_subdi3\"\n   [(set (match_operand:DI 0 \"arm_general_register_operand\" \"=&r,&r,&r\")\n@@ -1213,7 +1273,23 @@\n    subs%?\\\\t%0, %1, %2\n    rsbs%?\\\\t%0, %2, %1\"\n   [(set_attr \"conds\" \"set\")\n-   (set_attr \"type\" \"alus_imm,alus_sreg,alus_sreg\")]\n+   (set_attr \"type\" \"alus_imm,alus_sreg,alus_imm\")]\n+)\n+\n+;; To keep the comparison in canonical form we express it as (~reg cmp ~0)\n+;; rather than (0 cmp reg).  This gives the same results for unsigned\n+;; and equality compares which is what we mostly need here.\n+(define_insn \"rsb_imm_compare\"\n+  [(set (reg:CC_RSB CC_REGNUM)\n+\t(compare:CC_RSB (not:SI (match_operand:SI 2 \"s_register_operand\" \"r\"))\n+\t\t\t(match_operand 3 \"const_int_operand\" \"\")))\n+   (set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(minus:SI (match_operand 1 \"arm_immediate_operand\" \"I\")\n+\t\t  (match_dup 2)))]\n+  \"TARGET_32BIT && ~UINTVAL (operands[1]) == UINTVAL (operands[3])\"\n+  \"rsbs\\\\t%0, %2, %1\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"type\" \"alus_imm\")]\n )\n \n (define_expand \"subsf3\"\n@@ -3726,29 +3802,6 @@\n    (set_attr \"type\" \"multiple\")]\n )\n \n-(define_expand \"negdi2\"\n- [(parallel\n-   [(set (match_operand:DI 0 \"s_register_operand\")\n-\t (neg:DI (match_operand:DI 1 \"s_register_operand\")))\n-    (clobber (reg:CC CC_REGNUM))])]\n-  \"TARGET_EITHER\"\n-)\n-\n-;; The constraints here are to prevent a *partial* overlap (where %Q0 == %R1).\n-(define_insn \"*negdi2_insn\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n-\t(neg:DI (match_operand:DI 1 \"s_register_operand\"  \"r,r\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_32BIT\"\n-  \"@\n-   rsbs\\\\t%Q0, %Q1, #0; rsc\\\\t%R0, %R1, #0\n-   negs\\\\t%Q0, %Q1; sbc\\\\t%R0, %R1, %R1, lsl #1\"\n-  [(set_attr \"conds\" \"clob\")\n-   (set_attr \"arch\" \"a,t2\")\n-   (set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n (define_expand \"negsi2\"\n   [(set (match_operand:SI         0 \"s_register_operand\")\n \t(neg:SI (match_operand:SI 1 \"s_register_operand\")))]\n@@ -3765,7 +3818,39 @@\n    (set_attr \"predicable_short_it\" \"yes,no\")\n    (set_attr \"arch\" \"t2,*\")\n    (set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"alu_sreg\")]\n+   (set_attr \"type\" \"alu_imm\")]\n+)\n+\n+;; To keep the comparison in canonical form we express it as (~reg cmp ~0)\n+;; rather than (0 cmp reg).  This gives the same results for unsigned\n+;; and equality compares which is what we mostly need here.\n+(define_insn \"negsi2_0compare\"\n+  [(set (reg:CC_RSB CC_REGNUM)\n+\t(compare:CC_RSB (not:SI (match_operand:SI 1 \"s_register_operand\" \"l,r\"))\n+\t\t\t(const_int -1)))\n+   (set (match_operand:SI 0 \"s_register_operand\" \"=l,r\")\n+\t(neg:SI (match_dup 1)))]\n+  \"TARGET_32BIT\"\n+  \"@\n+   negs\\\\t%0, %1\n+   rsbs\\\\t%0, %1, #0\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"arch\" \"t2,*\")\n+   (set_attr \"length\" \"2,*\")\n+   (set_attr \"type\" \"alus_imm\")]\n+)\n+\n+(define_insn \"negsi2_carryin\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n+\t(minus:SI (neg:SI (match_operand:SI 1 \"s_register_operand\" \"r,r\"))\n+\t\t  (match_operand:SI 2 \"arm_borrow_operation\" \"\")))]\n+  \"TARGET_32BIT\"\n+  \"@\n+   rsc\\\\t%0, %1, #0\n+   sbc\\\\t%0, %1, %1, lsl #1\"\n+  [(set_attr \"conds\" \"use\")\n+   (set_attr \"arch\" \"a,t2\")\n+   (set_attr \"type\" \"adc_imm,adc_reg\")]\n )\n \n (define_expand \"negsf2\""}, {"sha": "e6766a97fc41356fd5db556f2209cbac6bd98710", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da0e6bd3d347117e928a92841e8ed6da202e1426/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da0e6bd3d347117e928a92841e8ed6da202e1426/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=da0e6bd3d347117e928a92841e8ed6da202e1426", "patch": "@@ -371,7 +371,7 @@\n     machine_mode ccmode = GET_MODE (op0);\n     if (ccmode == CC_Cmode)\n       return GET_CODE (op) == GEU;\n-    else if (ccmode == CCmode)\n+    else if (ccmode == CCmode || ccmode == CC_RSBmode)\n       return GET_CODE (op) == LTU;\n     return false;\n   }"}]}