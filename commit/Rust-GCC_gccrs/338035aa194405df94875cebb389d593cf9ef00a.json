{"sha": "338035aa194405df94875cebb389d593cf9ef00a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM4MDM1YWExOTQ0MDVkZjk0ODc1Y2ViYjM4OWQ1OTNjZjllZjAwYQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2017-05-01T19:15:36Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-05-01T19:15:36Z"}, "message": "Eliminate fixit_hint class hierarchy\n\nThe original implementation of fix-it hints (r230674) had an abstract\nbase class \"fixit_hint\" and three subclasses, representing\neach of insertions, replacements, and deletions.\n\nHaving multiple classes for fix-it hints was a nuisance, as it required\nper-class logic everywhere that the hints were handled.\n\nIn r239632 I eliminated the deletion subclass in favor of replacement\nwith the empty string (two subclasses are easier than three).\n\nThis patch eliminates the class hierarchy altogether by implementing\ninsertion in terms of replacement, by representing replacements via\na half-open interval (so that for an insertion, start == next location,\nand we're effectively replacing an empty range at the insertion point\nwith the new string).\n\nThis greatly simplifies the code for handling fix-it hints; for example\nit allows removal of a parallel class hierarchy of line_event within\nedit-context.c.\n\nIt also improves consolidation of hints: we can now consolidate\ninsertions at the same location, affecting a couple of tests\n(selftest::test_one_liner_many_fixits and\ngcc.dg/Wmissing-braces-fixits.c).\n\ngcc/ChangeLog:\n\t* diagnostic-show-locus.c (layout::get_expanded_location): Rewrite\n\tto use new fixit_hint representation, using the \"replace\" logic.\n\t(get_line_span_for_fixit_hint): Likewise.\n\t(layout::print_any_fixits): Likewise.\n\t(selftest::test_one_liner_many_fixits): Rename to...\n\t(selftest::test_one_liner_many_fixits_1): ...this, and update\n\tcomment and expected output to reflect that the multiple fix-it\n\thints are now consolidated into one insertion.\n\t(selftest::test_one_liner_many_fixits_2): New test.\n\t(selftest::test_diagnostic_show_locus_one_liner): Update for\n\tabove.\n\t(selftest::test_fixit_consolidation): Update for fix-it API\n\tchange.\n\t* diagnostic.c (print_parseable_fixits): Likewise.\n\t* edit-context.c (edited_line::m_line_events): Convert from\n\tauto_vec <line_event *> to auto_vec <line_event>.\n\t(class line_event): Convert from abstract base class to a concrete\n\tclass, taking over the role of replace_event.\n\t(class insert_event): Delete.\n\t(class replace_event): Rename to class line_event.  Convert to\n\thalf-open range.\n\t(edit_context::add_fixits): Reimplement.\n\t(edit_context::apply_insert): Delete.\n\t(edit_context::apply_replace): Rename to...\n\t(edit_context::apply_fixit): ...this.  Convert to half-open range.\n\t(edited_file::apply_insert): Delete.\n\t(edited_file::apply_replace): Rename to...\n\t(edited_file::apply_fixit): ...this.\n\t(edited_line::~edited_line): Drop deletion of events.\n\t(edited_line::apply_insert): Delete.\n\t(edited_line::apply_replace): Rename to...\n\t(edited_line::apply_fixit): ...this.  Convert to half-open range.\n\tUpdate for change to type of m_line_events.\n\t* edit-context.h (edit_context::apply_insert): Delete.\n\t(edit_context::apply_replace): Rename to...\n\t(edit_context::apply_fixit): ...this.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/Wmissing-braces-fixits.c: Update expected output to\n\treflect insertion fix-it hints at the same location now being\n\tconsolidated.\n\nlibcpp/ChangeLog:\n\t* include/line-map.h (source_range::intersects_line_p): Delete.\n\t(rich_location::add_fixit): Delete.\n\t(rich_location::maybe_add_fixit): New method.\n\t(class fixit_hint): Reimplement in terms of...\n\t(class fixit_replace): ...this.\n\t(class fixit_insert): Delete.\n\t* line-map.c (linemap_position_for_loc_and_offset): Drop overzealous\n\tlinemap_assert_fails.\n\t(source_range::intersects_line_p): Rename to...\n\t(fixit_hint::affects_line_p): New function.\n\t(rich_location::add_fixit_insert_before): Reimplement in terms of\n\tmaybe_add_fixit, moving validation there.\n\t(rich_location::add_fixit_insert_after): Likewise.\n\t(column_before_p): Delete.\n\t(rich_location::add_fixit_replace): Reimplement in terms of\n\tmaybe_add_fixit, moving validation there.  Convert closed input range\n\tto half-open range.\n\t(rich_location::add_fixit): Delete.\n\t(rich_location::maybe_add_fixit): New function.\n\t(fixit_insert::fixit_insert): Delete.\n\t(fixit_insert::~fixit_insert): Delete.\n\t(fixit_insert::affects_line_p): Delete.\n\t(fixit_insert::maybe_append_replace): Delete.\n\t(fixit_replace::fixit_replace): Rename to...\n\t(fixit_hint::fixit_hint): ...this, rewriting as necessary.\n\t(fixit_replace::~fixit_replace): Delete.\n\t(fixit_replace::affects_line_p): Delete.\n\t(fixit_replace::maybe_append_replace): Rename to...\n\t(fixit_hint::maybe_append): ...this, rewriting as necessary.\n\nFrom-SVN: r247445", "tree": {"sha": "ec2f1379d4ea93aebee73e038601a72813231176", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec2f1379d4ea93aebee73e038601a72813231176"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/338035aa194405df94875cebb389d593cf9ef00a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/338035aa194405df94875cebb389d593cf9ef00a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/338035aa194405df94875cebb389d593cf9ef00a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/338035aa194405df94875cebb389d593cf9ef00a/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4d82d0bc4350ce18a5fb64049d24e98dee1235f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d82d0bc4350ce18a5fb64049d24e98dee1235f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d82d0bc4350ce18a5fb64049d24e98dee1235f9"}], "stats": {"total": 967, "additions": 329, "deletions": 638}, "files": [{"sha": "6441ac1e6887468d3e847f3a38622a6c2ef89083", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338035aa194405df94875cebb389d593cf9ef00a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338035aa194405df94875cebb389d593cf9ef00a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=338035aa194405df94875cebb389d593cf9ef00a", "patch": "@@ -1,3 +1,42 @@\n+2017-05-01  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* diagnostic-show-locus.c (layout::get_expanded_location): Rewrite\n+\tto use new fixit_hint representation, using the \"replace\" logic.\n+\t(get_line_span_for_fixit_hint): Likewise.\n+\t(layout::print_any_fixits): Likewise.\n+\t(selftest::test_one_liner_many_fixits): Rename to...\n+\t(selftest::test_one_liner_many_fixits_1): ...this, and update\n+\tcomment and expected output to reflect that the multiple fix-it\n+\thints are now consolidated into one insertion.\n+\t(selftest::test_one_liner_many_fixits_2): New test.\n+\t(selftest::test_diagnostic_show_locus_one_liner): Update for\n+\tabove.\n+\t(selftest::test_fixit_consolidation): Update for fix-it API\n+\tchange.\n+\t* diagnostic.c (print_parseable_fixits): Likewise.\n+\t* edit-context.c (edited_line::m_line_events): Convert from\n+\tauto_vec <line_event *> to auto_vec <line_event>.\n+\t(class line_event): Convert from abstract base class to a concrete\n+\tclass, taking over the role of replace_event.\n+\t(class insert_event): Delete.\n+\t(class replace_event): Rename to class line_event.  Convert to\n+\thalf-open range.\n+\t(edit_context::add_fixits): Reimplement.\n+\t(edit_context::apply_insert): Delete.\n+\t(edit_context::apply_replace): Rename to...\n+\t(edit_context::apply_fixit): ...this.  Convert to half-open range.\n+\t(edited_file::apply_insert): Delete.\n+\t(edited_file::apply_replace): Rename to...\n+\t(edited_file::apply_fixit): ...this.\n+\t(edited_line::~edited_line): Drop deletion of events.\n+\t(edited_line::apply_insert): Delete.\n+\t(edited_line::apply_replace): Rename to...\n+\t(edited_line::apply_fixit): ...this.  Convert to half-open range.\n+\tUpdate for change to type of m_line_events.\n+\t* edit-context.h (edit_context::apply_insert): Delete.\n+\t(edit_context::apply_replace): Rename to...\n+\t(edit_context::apply_fixit): ...this.\n+\n 2017-05-01  Martin Sebor  <msebor@redhat.com>\n \n \t* gimple-ssa-sprintf.c (format_integer): Set knownrange when it's"}, {"sha": "3c10b69c2326e51be207ce6940090e4ca1d92450", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 84, "deletions": 143, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338035aa194405df94875cebb389d593cf9ef00a/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338035aa194405df94875cebb389d593cf9ef00a/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=338035aa194405df94875cebb389d593cf9ef00a", "patch": "@@ -941,32 +941,10 @@ layout::get_expanded_location (const line_span *line_span) const\n bool\n layout::validate_fixit_hint_p (const fixit_hint *hint)\n {\n-  switch (hint->get_kind ())\n-    {\n-    case fixit_hint::INSERT:\n-      {\n-\tconst fixit_insert *insert = static_cast <const fixit_insert *> (hint);\n-\tlocation_t loc = insert->get_location ();\n-\tif (LOCATION_FILE (loc) != m_exploc.file)\n-\t  return false;\n-      }\n-      break;\n-\n-    case fixit_hint::REPLACE:\n-      {\n-\tconst fixit_replace *replace\n-\t  = static_cast <const fixit_replace *> (hint);\n-\tsource_range src_range = replace->get_range ();\n-\tif (LOCATION_FILE (src_range.m_start) != m_exploc.file)\n-\t  return false;\n-\tif (LOCATION_FILE (src_range.m_finish) != m_exploc.file)\n-\t  return false;\n-      }\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n+  if (LOCATION_FILE (hint->get_start_loc ()) != m_exploc.file)\n+    return false;\n+  if (LOCATION_FILE (hint->get_next_loc ()) != m_exploc.file)\n+    return false;\n \n   return true;\n }\n@@ -979,30 +957,8 @@ static line_span\n get_line_span_for_fixit_hint (const fixit_hint *hint)\n {\n   gcc_assert (hint);\n-  switch (hint->get_kind ())\n-    {\n-    case fixit_hint::INSERT:\n-      {\n-\tconst fixit_insert *insert = static_cast <const fixit_insert *> (hint);\n-\tlocation_t loc = insert->get_location ();\n-\tint line = LOCATION_LINE (loc);\n-\treturn line_span (line, line);\n-      }\n-      break;\n-\n-    case fixit_hint::REPLACE:\n-      {\n-\tconst fixit_replace *replace\n-\t  = static_cast <const fixit_replace *> (hint);\n-\tsource_range src_range = replace->get_range ();\n-\treturn line_span (LOCATION_LINE (src_range.m_start),\n-\t\t\t  LOCATION_LINE (src_range.m_finish));\n-      }\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n+  return line_span (LOCATION_LINE (hint->get_start_loc ()),\n+\t\t    LOCATION_LINE (hint->get_next_loc ()));\n }\n \n /* We want to print the pertinent source code at a diagnostic.  The\n@@ -1264,62 +1220,47 @@ layout::print_any_fixits (int row)\n       if (hint->affects_line_p (m_exploc.file, row))\n \t{\n \t  /* For now we assume each fixit hint can only touch one line.  */\n-\t  switch (hint->get_kind ())\n+\t  if (hint->insertion_p ())\n+\t    {\n+\t      /* This assumes the insertion just affects one line.  */\n+\t      int start_column = LOCATION_COLUMN (hint->get_start_loc ());\n+\t      move_to_column (&column, start_column);\n+\t      m_colorizer.set_fixit_insert ();\n+\t      pp_string (m_pp, hint->get_string ());\n+\t      m_colorizer.set_normal_text ();\n+\t      column += hint->get_length ();\n+\t    }\n+\t  else\n \t    {\n-\t    case fixit_hint::INSERT:\n-\t      {\n-\t\tconst fixit_insert *insert\n-\t\t  = static_cast <const fixit_insert *> (hint);\n-\t\t/* This assumes the insertion just affects one line.  */\n-\t\tint start_column\n-\t\t  = LOCATION_COLUMN (insert->get_location ());\n-\t\tmove_to_column (&column, start_column);\n-\t\tm_colorizer.set_fixit_insert ();\n-\t\tpp_string (m_pp, insert->get_string ());\n-\t\tm_colorizer.set_normal_text ();\n-\t\tcolumn += insert->get_length ();\n-\t      }\n-\t      break;\n-\n-\t    case fixit_hint::REPLACE:\n-\t      {\n-\t\tconst fixit_replace *replace\n-\t\t  = static_cast <const fixit_replace *> (hint);\n-\t\tsource_range src_range = replace->get_range ();\n-\t\tint line = LOCATION_LINE (src_range.m_start);\n-\t\tint start_column = LOCATION_COLUMN (src_range.m_start);\n-\t\tint finish_column = LOCATION_COLUMN (src_range.m_finish);\n-\n-\t\t/* If the range of the replacement wasn't printed in the\n-\t\t   annotation line, then print an extra underline to\n-\t\t   indicate exactly what is being replaced.\n-\t\t   Always show it for removals.  */\n-\t\tif (!annotation_line_showed_range_p (line, start_column,\n-\t\t\t\t\t\t     finish_column)\n-\t\t    || replace->get_length () == 0)\n-\t\t  {\n-\t\t    move_to_column (&column, start_column);\n-\t\t    m_colorizer.set_fixit_delete ();\n-\t\t    for (; column <= finish_column; column++)\n-\t\t      pp_character (m_pp, '-');\n-\t\t    m_colorizer.set_normal_text ();\n-\t\t  }\n-\t\t/* Print the replacement text.  REPLACE also covers\n-\t\t   removals, so only do this extra work (potentially starting\n-\t\t   a new line) if we have actual replacement text.  */\n-\t\tif (replace->get_length () > 0)\n-\t\t  {\n-\t\t    move_to_column (&column, start_column);\n-\t\t    m_colorizer.set_fixit_insert ();\n-\t\t    pp_string (m_pp, replace->get_string ());\n-\t\t    m_colorizer.set_normal_text ();\n-\t\t    column += replace->get_length ();\n-\t\t  }\n-\t      }\n-\t      break;\n-\n-\t    default:\n-\t      gcc_unreachable ();\n+\t      int line = LOCATION_LINE (hint->get_start_loc ());\n+\t      int start_column = LOCATION_COLUMN (hint->get_start_loc ());\n+\t      int finish_column = LOCATION_COLUMN (hint->get_next_loc ()) - 1;\n+\n+\t      /* If the range of the replacement wasn't printed in the\n+\t\t annotation line, then print an extra underline to\n+\t\t indicate exactly what is being replaced.\n+\t\t Always show it for removals.  */\n+\t      if (!annotation_line_showed_range_p (line, start_column,\n+\t\t\t\t\t\t   finish_column)\n+\t\t  || hint->get_length () == 0)\n+\t\t{\n+\t\t  move_to_column (&column, start_column);\n+\t\t  m_colorizer.set_fixit_delete ();\n+\t\t  for (; column <= finish_column; column++)\n+\t\t    pp_character (m_pp, '-');\n+\t\t  m_colorizer.set_normal_text ();\n+\t\t}\n+\t      /* Print the replacement text.  REPLACE also covers\n+\t\t removals, so only do this extra work (potentially starting\n+\t\t a new line) if we have actual replacement text.  */\n+\t      if (hint->get_length () > 0)\n+\t\t{\n+\t\t  move_to_column (&column, start_column);\n+\t\t  m_colorizer.set_fixit_insert ();\n+\t\t  pp_string (m_pp, hint->get_string ());\n+\t\t  m_colorizer.set_normal_text ();\n+\t\t  column += hint->get_length ();\n+\t\t}\n \t    }\n \t}\n     }\n@@ -1852,41 +1793,45 @@ test_one_liner_fixit_validation_adhoc_locations ()\n   }\n }\n \n-/* Ensure that we can add an arbitrary number of fix-it hints to a\n-   rich_location.  */\n+/* Test of consolidating insertions at the same location.  */\n \n static void\n-test_one_liner_many_fixits ()\n+test_one_liner_many_fixits_1 ()\n {\n   test_diagnostic_context dc;\n   location_t equals = linemap_position_for_column (line_table, 5);\n   rich_location richloc (line_table, equals);\n   for (int i = 0; i < 19; i++)\n     richloc.add_fixit_insert_before (\"a\");\n+  ASSERT_EQ (1, richloc.get_num_fixit_hints ());\n+  diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+  ASSERT_STREQ (\"\\n\"\n+\t\t\" foo = bar.field;\\n\"\n+\t\t\"     ^\\n\"\n+\t\t\"     aaaaaaaaaaaaaaaaaaa\\n\",\n+\t\tpp_formatted_text (dc.printer));\n+}\n+\n+/* Ensure that we can add an arbitrary number of fix-it hints to a\n+   rich_location, even if they are not consolidated.  */\n+\n+static void\n+test_one_liner_many_fixits_2 ()\n+{\n+  test_diagnostic_context dc;\n+  location_t equals = linemap_position_for_column (line_table, 5);\n+  rich_location richloc (line_table, equals);\n+  for (int i = 0; i < 19; i++)\n+    {\n+      location_t loc = linemap_position_for_column (line_table, i * 2);\n+      richloc.add_fixit_insert_before (loc, \"a\");\n+    }\n   ASSERT_EQ (19, richloc.get_num_fixit_hints ());\n   diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n   ASSERT_STREQ (\"\\n\"\n \t\t\" foo = bar.field;\\n\"\n \t\t\"     ^\\n\"\n-\t\t\"     a\\n\"\n-\t\t\"     a\\n\"\n-\t\t\"     a\\n\"\n-\t\t\"     a\\n\"\n-\t\t\"     a\\n\"\n-\t\t\"     a\\n\"\n-\t\t\"     a\\n\"\n-\t\t\"     a\\n\"\n-\t\t\"     a\\n\"\n-\t\t\"     a\\n\"\n-\t\t\"     a\\n\"\n-\t\t\"     a\\n\"\n-\t\t\"     a\\n\"\n-\t\t\"     a\\n\"\n-\t\t\"     a\\n\"\n-\t\t\"     a\\n\"\n-\t\t\"     a\\n\"\n-\t\t\"     a\\n\"\n-\t\t\"     a\\n\",\n+\t\t\"a a a a a a a a a a a a a a a a a a a\\n\",\n \t\tpp_formatted_text (dc.printer));\n }\n \n@@ -1924,7 +1869,8 @@ test_diagnostic_show_locus_one_liner (const line_table_case &case_)\n   test_one_liner_fixit_replace_non_equal_range ();\n   test_one_liner_fixit_replace_equal_secondary_range ();\n   test_one_liner_fixit_validation_adhoc_locations ();\n-  test_one_liner_many_fixits ();\n+  test_one_liner_many_fixits_1 ();\n+  test_one_liner_many_fixits_2 ();\n }\n \n /* Verify that we print fixits even if they only affect lines\n@@ -2027,6 +1973,7 @@ test_fixit_consolidation (const line_table_case &case_)\n   const location_t c16 = linemap_position_for_column (line_table, 16);\n   const location_t c17 = linemap_position_for_column (line_table, 17);\n   const location_t c20 = linemap_position_for_column (line_table, 20);\n+  const location_t c21 = linemap_position_for_column (line_table, 21);\n   const location_t caret = c10;\n \n   /* Insert + insert. */\n@@ -2105,11 +2052,9 @@ test_fixit_consolidation (const line_table_case &case_)\n \t/* They should have been merged into a single \"replace\".  */\n \tASSERT_EQ (1, richloc.get_num_fixit_hints ());\n \tconst fixit_hint *hint = richloc.get_fixit_hint (0);\n-\tASSERT_EQ (fixit_hint::REPLACE, hint->get_kind ());\n-\tconst fixit_replace *replace = (const fixit_replace *)hint;\n-\tASSERT_STREQ (\"foobar\", replace->get_string ());\n-\tASSERT_EQ (c10, replace->get_range ().m_start);\n-\tASSERT_EQ (c20, replace->get_range ().m_finish);\n+\tASSERT_STREQ (\"foobar\", hint->get_string ());\n+\tASSERT_EQ (c10, hint->get_start_loc ());\n+\tASSERT_EQ (c21, hint->get_next_loc ());\n       }\n   }\n \n@@ -2129,11 +2074,9 @@ test_fixit_consolidation (const line_table_case &case_)\n \t   range extended to cover that of the removal.  */\n \tASSERT_EQ (1, richloc.get_num_fixit_hints ());\n \tconst fixit_hint *hint = richloc.get_fixit_hint (0);\n-\tASSERT_EQ (fixit_hint::REPLACE, hint->get_kind ());\n-\tconst fixit_replace *replace = (const fixit_replace *)hint;\n-\tASSERT_STREQ (\"foo\", replace->get_string ());\n-\tASSERT_EQ (c10, replace->get_range ().m_start);\n-\tASSERT_EQ (c20, replace->get_range ().m_finish);\n+\tASSERT_STREQ (\"foo\", hint->get_string ());\n+\tASSERT_EQ (c10, hint->get_start_loc ());\n+\tASSERT_EQ (c21, hint->get_next_loc ());\n       }\n   }\n \n@@ -2151,11 +2094,9 @@ test_fixit_consolidation (const line_table_case &case_)\n \t/* They should have been merged into a single \"replace-with-empty\".  */\n \tASSERT_EQ (1, richloc.get_num_fixit_hints ());\n \tconst fixit_hint *hint = richloc.get_fixit_hint (0);\n-\tASSERT_EQ (fixit_hint::REPLACE, hint->get_kind ());\n-\tconst fixit_replace *replace = (const fixit_replace *)hint;\n-\tASSERT_STREQ (\"\", replace->get_string ());\n-\tASSERT_EQ (c10, replace->get_range ().m_start);\n-\tASSERT_EQ (c20, replace->get_range ().m_finish);\n+\tASSERT_STREQ (\"\", hint->get_string ());\n+\tASSERT_EQ (c10, hint->get_start_loc ());\n+\tASSERT_EQ (c21, hint->get_next_loc ());\n       }\n   }\n }"}, {"sha": "dc81755a6afd41afbd3c9a0e7a8570bf351ba934", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338035aa194405df94875cebb389d593cf9ef00a/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338035aa194405df94875cebb389d593cf9ef00a/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=338035aa194405df94875cebb389d593cf9ef00a", "patch": "@@ -757,43 +757,13 @@ print_parseable_fixits (pretty_printer *pp, rich_location *richloc)\n       expanded_location start_exploc = expand_location (start_loc);\n       pp_string (pp, \"fix-it:\");\n       print_escaped_string (pp, start_exploc.file);\n-      source_location end_loc;\n-\n       /* For compatibility with clang, print as a half-open range.  */\n-      if (hint->maybe_get_end_loc (&end_loc))\n-\t{\n-\t  expanded_location end_exploc = expand_location (end_loc);\n-\t  pp_printf (pp, \":{%i:%i-%i:%i}:\",\n-\t\t     start_exploc.line, start_exploc.column,\n-\t\t     end_exploc.line, end_exploc.column + 1);\n-\t}\n-      else\n-\t{\n-\t  pp_printf (pp, \":{%i:%i-%i:%i}:\",\n-\t\t     start_exploc.line, start_exploc.column,\n-\t\t     start_exploc.line, start_exploc.column);\n-\t}\n-      switch (hint->get_kind ())\n-\t{\n-\t  case fixit_hint::INSERT:\n-\t    {\n-\t      const fixit_insert *insert\n-\t\t= static_cast <const fixit_insert *> (hint);\n-\t      print_escaped_string (pp, insert->get_string ());\n-\t    }\n-\t    break;\n-\n-\t  case fixit_hint::REPLACE:\n-\t    {\n-\t      const fixit_replace *replace\n-\t\t= static_cast <const fixit_replace *> (hint);\n-\t      print_escaped_string (pp, replace->get_string ());\n-\t    }\n-\t    break;\n-\n-\t  default:\n-\t    gcc_unreachable ();\n-\t}\n+      source_location next_loc = hint->get_next_loc ();\n+      expanded_location next_exploc = expand_location (next_loc);\n+      pp_printf (pp, \":{%i:%i-%i:%i}:\",\n+\t\t start_exploc.line, start_exploc.column,\n+\t\t next_exploc.line, next_exploc.column);\n+      print_escaped_string (pp, hint->get_string ());\n       pp_newline (pp);\n     }\n }"}, {"sha": "bea8a8af688b6f1d9ef5c404ac9b8b49f7d23252", "filename": "gcc/edit-context.c", "status": "modified", "additions": 54, "deletions": 194, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338035aa194405df94875cebb389d593cf9ef00a/gcc%2Fedit-context.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338035aa194405df94875cebb389d593cf9ef00a/gcc%2Fedit-context.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fedit-context.c?ref=338035aa194405df94875cebb389d593cf9ef00a", "patch": "@@ -45,8 +45,6 @@ class edit_context;\n class edited_file;\n class edited_line;\n class line_event;\n-  class insert_event;\n-  class replace_event;\n \n /* A struct to hold the params of a print_diff call.  */\n \n@@ -71,11 +69,10 @@ class edited_file\n   const char *get_filename () const { return m_filename; }\n   char *get_content ();\n \n-  bool apply_insert (int line, int column, const char *str, int len);\n-  bool apply_replace (int line, int start_column,\n-\t\t      int finish_column,\n-\t\t      const char *replacement_str,\n-\t\t      int replacement_len);\n+  bool apply_fixit (int line, int start_column,\n+\t\t    int next_column,\n+\t\t    const char *replacement_str,\n+\t\t    int replacement_len);\n   int get_effective_column (int line, int column);\n \n   static int call_print_diff (const char *, edited_file *file,\n@@ -119,11 +116,10 @@ class edited_line\n   int get_len () const { return m_len; }\n \n   int get_effective_column (int orig_column) const;\n-  bool apply_insert (int column, const char *str, int len);\n-  bool apply_replace (int start_column,\n-\t\t      int finish_column,\n-\t\t      const char *replacement_str,\n-\t\t      int replacement_len);\n+  bool apply_fixit (int start_column,\n+\t\t    int next_column,\n+\t\t    const char *replacement_str,\n+\t\t    int replacement_len);\n \n  private:\n   void ensure_capacity (int len);\n@@ -134,55 +130,23 @@ class edited_line\n   char *m_content;\n   int m_len;\n   int m_alloc_sz;\n-  auto_vec <line_event *> m_line_events;\n+  auto_vec <line_event> m_line_events;\n };\n \n-/* Abstract base class for representing events that have occurred\n-   on one line of one file.  */\n-\n-class line_event\n-{\n- public:\n-  virtual ~line_event () {}\n-  virtual int get_effective_column (int orig_column) const = 0;\n-};\n-\n-/* Concrete subclass of line_event: an insertion of some text\n-   at some column on the line.\n+/* Class for representing edit events that have occurred on one line of\n+   one file: the replacement of some text betweeen some columns\n+   on the line.\n \n    Subsequent events will need their columns adjusting if they're\n-   are on this line and their column is >= the insertion point.  */\n+   are on this line and their column is >= the start point.  */\n \n-class insert_event : public line_event\n-{\n- public:\n-  insert_event (int column, int len) : m_column (column), m_len (len) {}\n-  int get_effective_column (int orig_column) const FINAL OVERRIDE\n-  {\n-    if (orig_column >= m_column)\n-      return orig_column + m_len;\n-    else\n-      return orig_column;\n-  }\n-\n- private:\n-  int m_column;\n-  int m_len;\n-};\n-\n-/* Concrete subclass of line_event: the replacement of some text\n-   betweeen some columns on the line.\n-\n-   Subsequent events will need their columns adjusting if they're\n-   are on this line and their column is >= the finish point.  */\n-\n-class replace_event : public line_event\n+class line_event\n {\n  public:\n-  replace_event (int start, int finish, int len) : m_start (start),\n-    m_finish (finish), m_delta (len - (finish + 1 - start)) {}\n+  line_event (int start, int next, int len) : m_start (start),\n+    m_next (next), m_delta (len - (next - start)) {}\n \n-  int get_effective_column (int orig_column) const FINAL OVERRIDE\n+  int get_effective_column (int orig_column) const\n   {\n     if (orig_column >= m_start)\n       return orig_column += m_delta;\n@@ -192,7 +156,7 @@ class replace_event : public line_event\n \n  private:\n   int m_start;\n-  int m_finish;\n+  int m_next;\n   int m_delta;\n };\n \n@@ -221,27 +185,8 @@ edit_context::add_fixits (rich_location *richloc)\n   for (unsigned i = 0; i < richloc->get_num_fixit_hints (); i++)\n     {\n       const fixit_hint *hint = richloc->get_fixit_hint (i);\n-      switch (hint->get_kind ())\n-\t{\n-\tcase fixit_hint::INSERT:\n-\t  if (!apply_insert ((const fixit_insert *)hint))\n-\t    {\n-\t      /* Failure.  */\n-\t      m_valid = false;\n-\t      return;\n-\t    }\n-\t  break;\n-\tcase fixit_hint::REPLACE:\n-\t  if (!apply_replace ((const fixit_replace *)hint))\n-\t    {\n-\t      /* Failure.  */\n-\t      m_valid = false;\n-\t      return;\n-\t    }\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n+      if (!apply_fixit (hint))\n+\tm_valid = false;\n     }\n }\n \n@@ -302,45 +247,25 @@ edit_context::print_diff (pretty_printer *pp, bool show_filenames)\n    applied, or false otherwise.  */\n \n bool\n-edit_context::apply_insert (const fixit_insert *insert)\n-{\n-  expanded_location exploc = expand_location (insert->get_location ());\n-\n-  if (exploc.column == 0)\n-    return false;\n-\n-  edited_file &file = get_or_insert_file (exploc.file);\n-  if (!m_valid)\n-    return false;\n-  return file.apply_insert (exploc.line, exploc.column, insert->get_string (),\n-\t\t\t    insert->get_length ());\n-}\n-\n-/* Attempt to apply the given fixit.  Return true if it can be\n-   applied, or false otherwise.  */\n-\n-bool\n-edit_context::apply_replace (const fixit_replace *replace)\n+edit_context::apply_fixit (const fixit_hint *hint)\n {\n-  source_range range = replace->get_range ();\n-\n-  expanded_location start = expand_location (range.m_start);\n-  expanded_location finish = expand_location (range.m_finish);\n-  if (start.file != finish.file)\n+  expanded_location start = expand_location (hint->get_start_loc ());\n+  expanded_location next_loc = expand_location (hint->get_next_loc ());\n+  if (start.file != next_loc.file)\n     return false;\n-  if (start.line != finish.line)\n+  if (start.line != next_loc.line)\n     return false;\n   if (start.column == 0)\n     return false;\n-  if (finish.column == 0)\n+  if (next_loc.column == 0)\n     return false;\n \n   edited_file &file = get_or_insert_file (start.file);\n   if (!m_valid)\n     return false;\n-  return file.apply_replace (start.line, start.column, finish.column,\n-\t\t\t     replace->get_string (),\n-\t\t\t     replace->get_length ());\n+  return file.apply_fixit (start.line, start.column, next_loc.column,\n+\t\t\t   hint->get_string (),\n+\t\t\t   hint->get_length ());\n }\n \n /* Locate the edited_file * for FILENAME, if any\n@@ -409,37 +334,21 @@ edited_file::get_content ()\n   return xstrdup (pp_formatted_text (&pp));\n }\n \n-/* Attempt to insert the string INSERT_STR with length INSERT_LEN\n-   at LINE and COLUMN, updating the in-memory copy of the line, and\n-   the record of edits to the line.  */\n-\n-bool\n-edited_file::apply_insert (int line, int column,\n-\t\t\t   const char *insert_str,\n-\t\t\t   int insert_len)\n-{\n-  edited_line *el = get_or_insert_line (line);\n-  if (!el)\n-    return false;\n-  return el->apply_insert (column, insert_str, insert_len);\n-}\n-\n-/* Attempt to replace columns START_COLUMN through FINISH_COLUMN of LINE\n-   with the string REPLACEMENT_STR of length REPLACEMENT_LEN,\n+/* Attempt to replace columns START_COLUMN up to but not including NEXT_COLUMN\n+   of LINE with the string REPLACEMENT_STR of length REPLACEMENT_LEN,\n    updating the in-memory copy of the line, and the record of edits to\n    the line.  */\n \n bool\n-edited_file::apply_replace (int line, int start_column,\n-\t\t\t    int finish_column,\n-\t\t\t    const char *replacement_str,\n-\t\t\t    int replacement_len)\n+edited_file::apply_fixit (int line, int start_column, int next_column,\n+\t\t\t  const char *replacement_str,\n+\t\t\t  int replacement_len)\n {\n   edited_line *el = get_or_insert_line (line);\n   if (!el)\n     return false;\n-  return el->apply_replace (start_column, finish_column, replacement_str,\n-\t\t\t    replacement_len);\n+  return el->apply_fixit (start_column, next_column, replacement_str,\n+\t\t\t  replacement_len);\n }\n \n /* Given line LINE, map from COLUMN in the input file to its current\n@@ -698,11 +607,6 @@ edited_line::edited_line (const char *filename, int line_num)\n edited_line::~edited_line ()\n {\n   free (m_content);\n-\n-  int i;\n-  line_event *event;\n-  FOR_EACH_VEC_ELT (m_line_events, i, event)\n-    delete event;\n }\n \n /* A callback for deleting edited_line *, for use as a\n@@ -727,85 +631,41 @@ edited_line::get_effective_column (int orig_column) const\n   return orig_column;\n }\n \n-/* Attempt to insert the string INSERT_STR with length INSERT_LEN at COLUMN\n-   of this line, updating the in-memory copy of the line, and the record\n-   of edits to it.\n-   Return true if successful; false if an error occurred.  */\n-\n-bool\n-edited_line::apply_insert (int column, const char *insert_str,\n-\t\t\t   int insert_len)\n-{\n-  column = get_effective_column (column);\n-\n-  int start_offset = column - 1;\n-  gcc_assert (start_offset >= 0);\n-  if (start_offset > m_len)\n-    return false;\n-\n-  /* Ensure buffer is big enough.  */\n-  size_t new_len = m_len + insert_len;\n-  ensure_capacity (new_len);\n-\n-  char *suffix = m_content + start_offset;\n-  gcc_assert (suffix <= m_content + m_len);\n-  size_t len_suffix = (m_content + m_len) - suffix;\n-\n-  /* Move successor content into position.  They overlap, so use memmove.  */\n-  memmove (m_content + start_offset + insert_len,\n-\t   suffix, len_suffix);\n-\n-  /* Replace target content.  They don't overlap, so use memcpy.  */\n-  memcpy (m_content + start_offset,\n-\t  insert_str,\n-\t  insert_len);\n-\n-  m_len = new_len;\n-\n-  ensure_terminated ();\n-\n-  /* Record the insertion, so that future changes to the line can have\n-     their column information adjusted accordingly.  */\n-  m_line_events.safe_push (new insert_event (column, insert_len));\n-\n-  return true;\n-}\n-\n-/* Attempt to replace columns START_COLUMN through FINISH_COLUMN of the line\n-   with the string REPLACEMENT_STR of length REPLACEMENT_LEN,\n-   updating the in-memory copy of the line, and the record of edits to\n-   the line.\n+/* Attempt to replace columns START_COLUMN up to but not including\n+   NEXT_COLUMN of the line with the string REPLACEMENT_STR of\n+   length REPLACEMENT_LEN, updating the in-memory copy of the line,\n+   and the record of edits to the line.\n    Return true if successful; false if an error occurred.  */\n \n bool\n-edited_line::apply_replace (int start_column,\n-\t\t\t    int finish_column,\n-\t\t\t    const char *replacement_str,\n-\t\t\t    int replacement_len)\n+edited_line::apply_fixit (int start_column,\n+\t\t\t  int next_column,\n+\t\t\t  const char *replacement_str,\n+\t\t\t  int replacement_len)\n {\n   start_column = get_effective_column (start_column);\n-  finish_column = get_effective_column (finish_column);\n+  next_column = get_effective_column (next_column);\n \n   int start_offset = start_column - 1;\n-  int end_offset = finish_column - 1;\n+  int next_offset = next_column - 1;\n \n   gcc_assert (start_offset >= 0);\n-  gcc_assert (end_offset >= 0);\n+  gcc_assert (next_offset >= 0);\n \n-  if (start_column > finish_column)\n+  if (start_column > next_column)\n     return false;\n-  if (start_offset >= m_len)\n+  if (start_offset >= (m_len + 1))\n     return false;\n-  if (end_offset >= m_len)\n+  if (next_offset >= (m_len + 1))\n     return false;\n \n-  size_t victim_len = end_offset - start_offset + 1;\n+  size_t victim_len = next_offset - start_offset;\n \n   /* Ensure buffer is big enough.  */\n   size_t new_len = m_len + replacement_len - victim_len;\n   ensure_capacity (new_len);\n \n-  char *suffix = m_content + end_offset + 1;\n+  char *suffix = m_content + next_offset;\n   gcc_assert (suffix <= m_content + m_len);\n   size_t len_suffix = (m_content + m_len) - suffix;\n \n@@ -824,8 +684,8 @@ edited_line::apply_replace (int start_column,\n \n   /* Record the replacement, so that future changes to the line can have\n      their column information adjusted accordingly.  */\n-  m_line_events.safe_push (new replace_event (start_column, finish_column,\n-\t\t\t\t\t      replacement_len));\n+  m_line_events.safe_push (line_event (start_column, next_column,\n+\t\t\t\t       replacement_len));\n   return true;\n }\n "}, {"sha": "402b8b1cffe28fed588251a584bf4986785aa59f", "filename": "gcc/edit-context.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338035aa194405df94875cebb389d593cf9ef00a/gcc%2Fedit-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338035aa194405df94875cebb389d593cf9ef00a/gcc%2Fedit-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fedit-context.h?ref=338035aa194405df94875cebb389d593cf9ef00a", "patch": "@@ -56,8 +56,7 @@ class edit_context\n   void print_diff (pretty_printer *pp, bool show_filenames);\n \n  private:\n-  bool apply_insert (const fixit_insert *insert);\n-  bool apply_replace (const fixit_replace *replace);\n+  bool apply_fixit (const fixit_hint *hint);\n   edited_file *get_file (const char *filename);\n   edited_file &get_or_insert_file (const char *filename);\n "}, {"sha": "dc80b563f5fa9ed9b4cf0c321e7c669ba242b9ab", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338035aa194405df94875cebb389d593cf9ef00a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338035aa194405df94875cebb389d593cf9ef00a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=338035aa194405df94875cebb389d593cf9ef00a", "patch": "@@ -1,3 +1,9 @@\n+2017-05-01  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/Wmissing-braces-fixits.c: Update expected output to\n+\treflect insertion fix-it hints at the same location now being\n+\tconsolidated.\n+\n 2017-05-01  Martin Sebor  <msebor@redhat.com>\n \n \t* tree-ssa/builtin-sprintf-warn-18.c: Adjust to avoid failures"}, {"sha": "b7d66cd6c3d2f305ccf444487b952062640e296a", "filename": "gcc/testsuite/gcc.dg/Wmissing-braces-fixits.c", "status": "modified", "additions": 12, "deletions": 50, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338035aa194405df94875cebb389d593cf9ef00a/gcc%2Ftestsuite%2Fgcc.dg%2FWmissing-braces-fixits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338035aa194405df94875cebb389d593cf9ef00a/gcc%2Ftestsuite%2Fgcc.dg%2FWmissing-braces-fixits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWmissing-braces-fixits.c?ref=338035aa194405df94875cebb389d593cf9ef00a", "patch": "@@ -48,13 +48,9 @@ int arr_2_2_3[2][2][3] = \\\n   /* { dg-begin-multiline-output \"\" }\n    { 0, 1, 2, 3, 4, 5,\n    ^\n-     {\n-     {      } {      }\n-                     }\n+     {{     } {      }}\n      6, 7, 8, 9, 10, 11};\n-     {\n-     {      } {        }\n-                       }\n+     {{     } {        }}\n      { dg-end-multiline-output \"\" } */\n \n int arr_2_3_2[2][3][2] = \\\n@@ -63,13 +59,9 @@ int arr_2_3_2[2][3][2] = \\\n   /* { dg-begin-multiline-output \"\" }\n    { 0, 1, 2, 3, 4, 5,\n    ^\n-     {\n-     {   } {   } {   }\n-                     }\n+     {{  } {   } {   }}\n      6, 7, 8, 9, 10, 11};\n-     {\n-     {   } {   } {     }\n-                       }\n+     {{  } {   } {     }}\n      { dg-end-multiline-output \"\" } */\n \n int arr_6_2[6][2] = \\\n@@ -89,15 +81,9 @@ int arr_3_2_2[3][2][2] = \\\n   /* { dg-begin-multiline-output \"\" }\n    { 0, 1, 2, 3, 4, 5,\n    ^\n-     {\n-     {   } {   }\n-               } {\n-                 {   }\n+     {{  } {   }}{{  }\n      6, 7, 8, 9, 10, 11};\n-     {   }\n-         } {\n-           {   } {     }\n-                       }\n+     {   }}{{  } {     }}\n      { dg-end-multiline-output \"\" } */\n \n int arr_3_4[3][4] = \\\n@@ -128,13 +114,9 @@ int arr_2_1_6[2][1][6] = \\\n   /* { dg-begin-multiline-output \"\" }\n    { 0, 1, 2, 3, 4, 5,\n    ^\n-     {\n-     {               }\n-                     }\n+     {{              }}\n      6, 7, 8, 9, 10, 11};\n-     {\n-     {                 }\n-                       }\n+     {{                }}\n      { dg-end-multiline-output \"\" } */\n \n struct sf2 arr_6_sf2[6] = \\\n@@ -165,21 +147,9 @@ struct sa2 arr_6_sa2[6] = \\\n   /* { dg-begin-multiline-output \"\" }\n    { 0, 1, 2, 3, 4, 5,\n    ^\n-     {\n-     {   }\n-         } {\n-           {   }\n-               } {\n-                 {   }\n-                     }\n+     {{  }}{{  }}{{  }}\n      6, 7, 8, 9, 10, 11};\n-     {\n-     {   }\n-         } {\n-           {   }\n-               } {\n-                 {     }\n-                       }\n+     {{  }}{{  }}{{    }}\n      { dg-end-multiline-output \"\" } */\n \n struct sa3 arr_4_sa3[4] = \\\n@@ -188,15 +158,7 @@ struct sa3 arr_4_sa3[4] = \\\n   /* { dg-begin-multiline-output \"\" }\n    { 0, 1, 2, 3, 4, 5,\n    ^\n-     {\n-     {      }\n-            } {\n-              {      }\n-                     }\n+     {{     }}{{     }}\n      6, 7, 8, 9, 10, 11};\n-     {\n-     {      }\n-            } {\n-              {        }\n-                       }\n+     {{     }}{{       }}\n      { dg-end-multiline-output \"\" } */"}, {"sha": "ab225d535191787451a9673733ab0882ece8e95c", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338035aa194405df94875cebb389d593cf9ef00a/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338035aa194405df94875cebb389d593cf9ef00a/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=338035aa194405df94875cebb389d593cf9ef00a", "patch": "@@ -1,3 +1,35 @@\n+2017-05-01  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* include/line-map.h (source_range::intersects_line_p): Delete.\n+\t(rich_location::add_fixit): Delete.\n+\t(rich_location::maybe_add_fixit): New method.\n+\t(class fixit_hint): Reimplement in terms of...\n+\t(class fixit_replace): ...this.\n+\t(class fixit_insert): Delete.\n+\t* line-map.c (linemap_position_for_loc_and_offset): Drop overzealous\n+\tlinemap_assert_fails.\n+\t(source_range::intersects_line_p): Rename to...\n+\t(fixit_hint::affects_line_p): New function.\n+\t(rich_location::add_fixit_insert_before): Reimplement in terms of\n+\tmaybe_add_fixit, moving validation there.\n+\t(rich_location::add_fixit_insert_after): Likewise.\n+\t(column_before_p): Delete.\n+\t(rich_location::add_fixit_replace): Reimplement in terms of\n+\tmaybe_add_fixit, moving validation there.  Convert closed input range\n+\tto half-open range.\n+\t(rich_location::add_fixit): Delete.\n+\t(rich_location::maybe_add_fixit): New function.\n+\t(fixit_insert::fixit_insert): Delete.\n+\t(fixit_insert::~fixit_insert): Delete.\n+\t(fixit_insert::affects_line_p): Delete.\n+\t(fixit_insert::maybe_append_replace): Delete.\n+\t(fixit_replace::fixit_replace): Rename to...\n+\t(fixit_hint::fixit_hint): ...this, rewriting as necessary.\n+\t(fixit_replace::~fixit_replace): Delete.\n+\t(fixit_replace::affects_line_p): Delete.\n+\t(fixit_replace::maybe_append_replace): Rename to...\n+\t(fixit_hint::maybe_append): ...this, rewriting as necessary.\n+\n 2017-04-03  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/line-map.h (LINEMAPS_MACRO_MAPS): Fix typo in comment."}, {"sha": "0c44f01b3bd544491cec2508335f0b6ebb365d6e", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 28, "deletions": 62, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338035aa194405df94875cebb389d593cf9ef00a/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338035aa194405df94875cebb389d593cf9ef00a/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=338035aa194405df94875cebb389d593cf9ef00a", "patch": "@@ -305,9 +305,6 @@ struct GTY(()) source_range\n     result.m_finish = finish;\n     return result;\n   }\n-\n-  /* Is there any part of this range on the given line?  */\n-  bool intersects_line_p (const char *file, int line) const;\n };\n \n /* Memory allocation function typedef.  Works like xrealloc.  */\n@@ -1416,8 +1413,6 @@ semi_embedded_vec<T, NUM_EMBEDDED>::truncate (int len)\n }\n \n class fixit_hint;\n-  class fixit_insert;\n-  class fixit_replace;\n \n /* A \"rich\" source code location, for use when printing diagnostics.\n    A rich_location has one or more carets&ranges, where the carets\n@@ -1667,7 +1662,9 @@ class rich_location\n private:\n   bool reject_impossible_fixit (source_location where);\n   void stop_supporting_fixits ();\n-  void add_fixit (fixit_hint *hint);\n+  void maybe_add_fixit (source_location start,\n+\t\t\tsource_location next_loc,\n+\t\t\tconst char *new_content);\n \n public:\n   static const int STATICALLY_ALLOCATED_RANGES = 3;\n@@ -1687,72 +1684,41 @@ class rich_location\n   bool m_seen_impossible_fixit;\n };\n \n-class fixit_hint\n-{\n-public:\n-  enum kind {INSERT, REPLACE};\n-\n-  virtual ~fixit_hint () {}\n-\n-  virtual enum kind get_kind () const = 0;\n-  virtual bool affects_line_p (const char *file, int line) const = 0;\n-  virtual source_location get_start_loc () const = 0;\n-  virtual bool maybe_get_end_loc (source_location *out) const = 0;\n-  /* Vfunc for consolidating successor fixits.  */\n-  virtual bool maybe_append_replace (line_maps *set,\n-\t\t\t\t     source_range src_range,\n-\t\t\t\t     const char *new_content) = 0;\n-};\n-\n-class fixit_insert : public fixit_hint\n-{\n- public:\n-  fixit_insert (source_location where,\n-\t\tconst char *new_content);\n-  ~fixit_insert ();\n-  enum kind get_kind () const { return INSERT; }\n-  bool affects_line_p (const char *file, int line) const;\n-  source_location get_start_loc () const { return m_where; }\n-  bool maybe_get_end_loc (source_location *) const { return false; }\n-  bool maybe_append_replace (line_maps *set,\n-\t\t\t     source_range src_range,\n-\t\t\t     const char *new_content);\n-\n-  source_location get_location () const { return m_where; }\n-  const char *get_string () const { return m_bytes; }\n-  size_t get_length () const { return m_len; }\n+/* A fix-it hint: a suggested insertion, replacement, or deletion of text.\n+   We handle these three types of edit with one class, by representing\n+   them as replacement of a half-open range:\n+       [start, next_loc)\n+   Insertions have start == next_loc: \"replace\" the empty string at the\n+   start location with the new string.\n+   Deletions are replacement with the empty string.  */\n \n- private:\n-  source_location m_where;\n-  char *m_bytes;\n-  size_t m_len;\n-};\n-\n-class fixit_replace : public fixit_hint\n+class fixit_hint\n {\n  public:\n-  fixit_replace (source_range src_range,\n-                 const char *new_content);\n-  ~fixit_replace ();\n+  fixit_hint (source_location start,\n+\t      source_location next_loc,\n+\t      const char *new_content);\n+  ~fixit_hint () { free (m_bytes); }\n \n-  enum kind get_kind () const { return REPLACE; }\n   bool affects_line_p (const char *file, int line) const;\n-  source_location get_start_loc () const { return m_src_range.m_start; }\n-  bool maybe_get_end_loc (source_location *out) const\n-  {\n-    *out = m_src_range.m_finish;\n-    return true;\n-  }\n-  bool maybe_append_replace (line_maps *set,\n-\t\t\t     source_range src_range,\n-\t\t\t     const char *new_content);\n+  source_location get_start_loc () const { return m_start; }\n+  source_location get_next_loc () const { return m_next_loc; }\n+  bool maybe_append (source_location start,\n+\t\t     source_location next_loc,\n+\t\t     const char *new_content);\n \n-  source_range get_range () const { return m_src_range; }\n   const char *get_string () const { return m_bytes; }\n   size_t get_length () const { return m_len; }\n \n+  bool insertion_p () const { return m_start == m_next_loc; }\n+\n  private:\n-  source_range m_src_range;\n+  /* We don't use source_range here since, unlike most places,\n+     this is a half-open/half-closed range:\n+       [start, next_loc)\n+     so that we can support insertion via start == next_loc.  */\n+  source_location m_start;\n+  source_location m_next_loc;\n   char *m_bytes;\n   size_t m_len;\n };"}, {"sha": "176e58d25451750c9c2b157ffc1eeac3452a66c4", "filename": "libcpp/line-map.c", "status": "modified", "additions": 67, "deletions": 151, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/338035aa194405df94875cebb389d593cf9ef00a/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/338035aa194405df94875cebb389d593cf9ef00a/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=338035aa194405df94875cebb389d593cf9ef00a", "patch": "@@ -881,8 +881,7 @@ linemap_position_for_loc_and_offset (struct line_maps *set,\n     loc = set->location_adhoc_data_map.data[loc & MAX_SOURCE_LOCATION].locus;\n \n   /* This function does not support virtual locations yet.  */\n-  if (linemap_assert_fails\n-      (!linemap_location_from_macro_expansion_p (set, loc)))\n+  if (linemap_location_from_macro_expansion_p (set, loc))\n     return loc;\n \n   if (column_offset == 0\n@@ -2003,28 +2002,6 @@ line_table_dump (FILE *stream, struct line_maps *set, unsigned int num_ordinary,\n     }\n }\n \n-/* struct source_range.  */\n-\n-/* Is there any part of this range on the given line?  */\n-\n-bool\n-source_range::intersects_line_p (const char *file, int line) const\n-{\n-  expanded_location exploc_start\n-    = linemap_client_expand_location_to_spelling_point (m_start);\n-  if (file != exploc_start.file)\n-    return false;\n-  if (line < exploc_start.line)\n-      return false;\n-  expanded_location exploc_finish\n-    = linemap_client_expand_location_to_spelling_point (m_finish);\n-  if (file != exploc_finish.file)\n-    return false;\n-  if (line > exploc_finish.line)\n-      return false;\n-  return true;\n-}\n-\n /* class rich_location.  */\n \n /* Construct a rich_location with location LOC as its initial range.  */\n@@ -2173,16 +2150,7 @@ rich_location::add_fixit_insert_before (source_location where,\n \t\t\t\t\tconst char *new_content)\n {\n   source_location start = get_range_from_loc (m_line_table, where).m_start;\n-\n-  if (reject_impossible_fixit (start))\n-    return;\n-  /* We do not yet support newlines within fix-it hints.  */\n-  if (strchr (new_content, '\\n'))\n-    {\n-      stop_supporting_fixits ();\n-      return;\n-    }\n-  add_fixit (new fixit_insert (start, new_content));\n+  maybe_add_fixit (start, start, new_content);\n }\n \n /* Add a fixit-hint, suggesting insertion of NEW_CONTENT\n@@ -2202,10 +2170,6 @@ rich_location::add_fixit_insert_after (source_location where,\n \t\t\t\t       const char *new_content)\n {\n   source_location finish = get_range_from_loc (m_line_table, where).m_finish;\n-\n-  if (reject_impossible_fixit (finish))\n-    return;\n-\n   source_location next_loc\n     = linemap_position_for_loc_and_offset (m_line_table, finish, 1);\n \n@@ -2217,7 +2181,7 @@ rich_location::add_fixit_insert_after (source_location where,\n       return;\n     }\n \n-  add_fixit (new fixit_insert (next_loc, new_content));\n+  maybe_add_fixit (next_loc, next_loc, new_content);\n }\n \n /* Methods for adding removal fix-it hints.  */\n@@ -2250,44 +2214,6 @@ rich_location::add_fixit_remove (source_range src_range)\n   add_fixit_replace (src_range, \"\");\n }\n \n-/* Return true iff A is in the column directly before B, on the\n-   same line of the same source file.  */\n-\n-static bool\n-column_before_p (line_maps *set, source_location a, source_location b)\n-{\n-  if (IS_ADHOC_LOC (a))\n-    a = get_location_from_adhoc_loc (set, a);\n-  if (IS_ADHOC_LOC (b))\n-    b = get_location_from_adhoc_loc (set, b);\n-\n-  /* They must both be in ordinary maps.  */\n-  const struct line_map *linemap_a = linemap_lookup (set, a);\n-  if (linemap_macro_expansion_map_p (linemap_a))\n-    return false;\n-  const struct line_map *linemap_b = linemap_lookup (set, b);\n-  if (linemap_macro_expansion_map_p (linemap_b))\n-    return false;\n-\n-  /* To be on the same line, they must be in the same ordinary map.  */\n-  if (linemap_a != linemap_b)\n-    return false;\n-\n-  linenum_type line_a\n-    = SOURCE_LINE (linemap_check_ordinary (linemap_a), a);\n-  linenum_type line_b\n-    = SOURCE_LINE (linemap_check_ordinary (linemap_b), b);\n-  if (line_a != line_b)\n-    return false;\n-\n-  linenum_type column_a\n-    = SOURCE_COLUMN (linemap_check_ordinary (linemap_a), a);\n-  linenum_type column_b\n-    = SOURCE_COLUMN (linemap_check_ordinary (linemap_b), b);\n-\n-  return column_b == column_a + 1;\n-}\n-\n /* Add a fixit-hint, suggesting replacement of the content covered\n    by range 0 with NEW_CONTENT.  */\n \n@@ -2317,28 +2243,22 @@ void\n rich_location::add_fixit_replace (source_range src_range,\n \t\t\t\t  const char *new_content)\n {\n-  src_range.m_start = get_pure_location (m_line_table, src_range.m_start);\n-  src_range.m_finish = get_pure_location (m_line_table, src_range.m_finish);\n-\n-  if (reject_impossible_fixit (src_range.m_start))\n-    return;\n-  if (reject_impossible_fixit (src_range.m_finish))\n-    return;\n+  source_location start = get_pure_location (m_line_table, src_range.m_start);\n+  source_location finish = get_pure_location (m_line_table, src_range.m_finish);\n \n-  /* We do not yet support newlines within fix-it hints.  */\n-  if (strchr (new_content, '\\n'))\n+  /* Fix-it hints use half-closed ranges, so attempt to offset the endpoint.  */\n+  source_location next_loc\n+    = linemap_position_for_loc_and_offset (m_line_table, finish, 1);\n+  /* linemap_position_for_loc_and_offset can fail, if so, it returns\n+     its input value.  */\n+  if (next_loc == finish)\n     {\n       stop_supporting_fixits ();\n       return;\n     }\n+  finish = next_loc;\n \n-  /* Consolidate neighboring fixits.  */\n-  fixit_hint *prev = get_last_fixit_hint ();\n-  if (prev)\n-    if (prev->maybe_append_replace (m_line_table, src_range, new_content))\n-      return;\n-\n-  add_fixit (new fixit_replace (src_range, new_content));\n+  maybe_add_fixit (start, finish, new_content);\n }\n \n /* Get the last fix-it hint within this rich_location, or NULL if none.  */\n@@ -2392,89 +2312,85 @@ rich_location::stop_supporting_fixits ()\n   m_fixit_hints.truncate (0);\n }\n \n-/* Add HINT to the fix-it hints in this rich_location.  */\n+/* Add HINT to the fix-it hints in this rich_location,\n+   consolidating into the prior fixit if possible.  */\n \n void\n-rich_location::add_fixit (fixit_hint *hint)\n+rich_location::maybe_add_fixit (source_location start,\n+\t\t\t\tsource_location next_loc,\n+\t\t\t\tconst char *new_content)\n {\n-  m_fixit_hints.push (hint);\n-}\n-\n-/* class fixit_insert.  */\n-\n-fixit_insert::fixit_insert (source_location where,\n-\t\t\t    const char *new_content)\n-: m_where (where),\n-  m_bytes (xstrdup (new_content)),\n-  m_len (strlen (new_content))\n-{\n-}\n-\n-fixit_insert::~fixit_insert ()\n-{\n-  free (m_bytes);\n-}\n-\n-/* Implementation of fixit_hint::affects_line_p for fixit_insert.  */\n+  if (reject_impossible_fixit (start))\n+    return;\n+  if (reject_impossible_fixit (next_loc))\n+    return;\n \n-bool\n-fixit_insert::affects_line_p (const char *file, int line) const\n-{\n-  expanded_location exploc\n-    = linemap_client_expand_location_to_spelling_point (m_where);\n-  if (file == exploc.file)\n-    if (line == exploc.line)\n-      return true;\n-  return false;\n-}\n+  /* We do not yet support newlines within fix-it hints.  */\n+  if (strchr (new_content, '\\n'))\n+    {\n+      stop_supporting_fixits ();\n+      return;\n+    }\n \n-/* Implementation of maybe_append_replace for fixit_insert.  Reject\n-   the attempt to consolidate fix-its.  */\n+  /* Consolidate neighboring fixits.  */\n+  fixit_hint *prev = get_last_fixit_hint ();\n+  if (prev)\n+    if (prev->maybe_append (start, next_loc, new_content))\n+      return;\n \n-bool\n-fixit_insert::maybe_append_replace (line_maps *, source_range, const char *)\n-{\n-  return false;\n+  m_fixit_hints.push (new fixit_hint (start, next_loc, new_content));\n }\n \n-/* class fixit_replace.  */\n+/* class fixit_hint.  */\n \n-fixit_replace::fixit_replace (source_range src_range,\n-\t\t\t      const char *new_content)\n-: m_src_range (src_range),\n+fixit_hint::fixit_hint (source_location start,\n+\t\t\tsource_location next_loc,\n+\t\t\tconst char *new_content)\n+: m_start (start),\n+  m_next_loc (next_loc),\n   m_bytes (xstrdup (new_content)),\n   m_len (strlen (new_content))\n {\n }\n \n-fixit_replace::~fixit_replace ()\n-{\n-  free (m_bytes);\n-}\n-\n-/* Implementation of fixit_hint::affects_line_p for fixit_replace.  */\n+/* Does this fix-it hint affect the given line?  */\n \n bool\n-fixit_replace::affects_line_p (const char *file, int line) const\n+fixit_hint::affects_line_p (const char *file, int line) const\n {\n-  return m_src_range.intersects_line_p (file, line);\n+  expanded_location exploc_start\n+    = linemap_client_expand_location_to_spelling_point (m_start);\n+  if (file != exploc_start.file)\n+    return false;\n+  if (line < exploc_start.line)\n+      return false;\n+  expanded_location exploc_next_loc\n+    = linemap_client_expand_location_to_spelling_point (m_next_loc);\n+  if (file != exploc_next_loc.file)\n+    return false;\n+  if (line > exploc_next_loc.line)\n+      return false;\n+  return true;\n }\n \n-/* Implementation of maybe_append_replace for fixit_replace.  If\n-   possible, merge the new replacement into this one and return true.\n+/* Method for consolidating fix-it hints, for use by\n+   rich_location::maybe_add_fixit.\n+   If possible, merge a pending fix-it hint with the given params\n+   into this one and return true.\n    Otherwise return false.  */\n \n bool\n-fixit_replace::maybe_append_replace (line_maps *set,\n-\t\t\t\t     source_range src_range,\n-\t\t\t\t     const char *new_content)\n+fixit_hint::maybe_append (source_location start,\n+\t\t\t  source_location next_loc,\n+\t\t\t  const char *new_content)\n {\n-  /* Does SRC_RANGE start immediately after this one finishes?  */\n-  if (!column_before_p (set, m_src_range.m_finish, src_range.m_start))\n+  /* For consolidation to be possible, START must be at this hint's\n+     m_next_loc.  */\n+  if (start != m_next_loc)\n     return false;\n \n-  /* We have neighboring replacements; merge them.  */\n-  m_src_range.m_finish = src_range.m_finish;\n+  /* If so, we have neighboring replacements; merge them.  */\n+  m_next_loc = next_loc;\n   size_t extra_len = strlen (new_content);\n   m_bytes = (char *)xrealloc (m_bytes, m_len + extra_len + 1);\n   memcpy (m_bytes + m_len, new_content, extra_len);"}]}