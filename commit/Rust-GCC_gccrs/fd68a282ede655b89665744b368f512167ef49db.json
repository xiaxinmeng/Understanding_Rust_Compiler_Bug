{"sha": "fd68a282ede655b89665744b368f512167ef49db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ2OGEyODJlZGU2NTViODk2NjU3NDRiMzY4ZjUxMjE2N2VmNDlkYg==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-09-20T13:19:17Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:21Z"}, "message": "Attempt consolidation of ArithmeticOrLogicalExpr parsing\n\nFixed typo of MODULUS as MODULO", "tree": {"sha": "ea36558bb5cee06899566199d31e829e91066307", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea36558bb5cee06899566199d31e829e91066307"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd68a282ede655b89665744b368f512167ef49db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd68a282ede655b89665744b368f512167ef49db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd68a282ede655b89665744b368f512167ef49db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd68a282ede655b89665744b368f512167ef49db/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f7007a777bbb3d2fbd29f66b98d71ba6849eab6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f7007a777bbb3d2fbd29f66b98d71ba6849eab6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f7007a777bbb3d2fbd29f66b98d71ba6849eab6"}], "stats": {"total": 159, "additions": 127, "deletions": 32}, "files": [{"sha": "452429a8896463aef0fdfa3d13da579207fb8801", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 123, "deletions": 32, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd68a282ede655b89665744b368f512167ef49db/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd68a282ede655b89665744b368f512167ef49db/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=fd68a282ede655b89665744b368f512167ef49db", "patch": "@@ -200,8 +200,8 @@ Parser<ManagedTokenSource>::skip_generics_right_angle ()\n #endif\n \n \t// new implementation that should be better\n-  lexer.split_current_token (RIGHT_ANGLE, RIGHT_ANGLE);\n-  lexer.skip_token ();\n+\tlexer.split_current_token (RIGHT_ANGLE, RIGHT_ANGLE);\n+\tlexer.skip_token ();\n \treturn true;\n       }\n       case GREATER_OR_EQUAL: {\n@@ -216,9 +216,9 @@ Parser<ManagedTokenSource>::skip_generics_right_angle ()\n #endif\n \n \t// new implementation that should be better\n-  lexer.split_current_token (RIGHT_ANGLE, EQUAL);\n-  lexer.skip_token ();\n-  return true;\n+\tlexer.split_current_token (RIGHT_ANGLE, EQUAL);\n+\tlexer.skip_token ();\n+\treturn true;\n       }\n       case RIGHT_SHIFT_EQ: {\n #if 0\n@@ -232,9 +232,9 @@ Parser<ManagedTokenSource>::skip_generics_right_angle ()\n #endif\n \n \t// new implementation that should be better\n-  lexer.split_current_token (RIGHT_ANGLE, GREATER_OR_EQUAL);\n-  lexer.skip_token ();\n-  return true;\n+\tlexer.split_current_token (RIGHT_ANGLE, GREATER_OR_EQUAL);\n+\tlexer.skip_token ();\n+\treturn true;\n       }\n     default:\n       rust_error_at (tok->get_locus (),\n@@ -379,11 +379,12 @@ Parser<ManagedTokenSource>::left_binding_power (const_TokenPtr token)\n     case RIGHT_SHIFT_EQ:\n       return LBP_R_SHIFT_ASSIG;\n \n-    // HACK: float literal due to lexer misidentifying a dot then an integer as\n-    // a float\n+    /* HACK: float literal due to lexer misidentifying a dot then an integer as\n+     * a float */\n     case FLOAT_LITERAL:\n       return LBP_FIELD_EXPR;\n       // field expr is same as tuple expr in precedence, i imagine\n+      // TODO: is this needed anymore? lexer shouldn't do that anymore\n \n     // anything that can't appear in an infix position is given lowest priority\n     default:\n@@ -11687,7 +11688,7 @@ Parser<ManagedTokenSource>::null_denotation (\n \t// HACK: as struct expressions should always be value expressions,\n \t// cannot be referenced\n \tParseRestrictions entered_from_unary\n-\t  = {.can_be_struct_expr = false, .entered_from_unary = true};\n+\t  = {/* can_be_struct_expr = */ false, /* entered_from_unary = */ true};\n \t/*entered_from_unary.entered_from_unary = true;\n \tentered_from_unary.can_be_struct_expr = false;*/\n \n@@ -11883,44 +11884,74 @@ Parser<ManagedTokenSource>::left_denotation (\n       }\n     case PLUS:\n       // sum expression - binary infix\n-      return parse_binary_plus_expr (tok, std::move (left),\n-\t\t\t\t     std::move (outer_attrs), restrictions);\n+      /*return parse_binary_plus_expr (tok, std::move (left),\n+\t\t\t\t     std::move (outer_attrs), restrictions);*/\n+      return parse_arithmetic_or_logical_expr (\n+\ttok, std::move (left), std::move (outer_attrs),\n+\tAST::ArithmeticOrLogicalExpr::ADD, restrictions);\n     case MINUS:\n       // difference expression - binary infix\n-      return parse_binary_minus_expr (tok, std::move (left),\n-\t\t\t\t      std::move (outer_attrs), restrictions);\n+      /*return parse_binary_minus_expr (tok, std::move (left),\n+\t\t\t\t      std::move (outer_attrs), restrictions);*/\n+      return parse_arithmetic_or_logical_expr (\n+\ttok, std::move (left), std::move (outer_attrs),\n+\tAST::ArithmeticOrLogicalExpr::SUBTRACT, restrictions);\n     case ASTERISK:\n       // product expression - binary infix\n-      return parse_binary_mult_expr (tok, std::move (left),\n-\t\t\t\t     std::move (outer_attrs), restrictions);\n+      /*return parse_binary_mult_expr (tok, std::move (left),\n+\t\t\t\t     std::move (outer_attrs), restrictions);*/\n+      return parse_arithmetic_or_logical_expr (\n+\ttok, std::move (left), std::move (outer_attrs),\n+\tAST::ArithmeticOrLogicalExpr::MULTIPLY, restrictions);\n     case DIV:\n       // quotient expression - binary infix\n-      return parse_binary_div_expr (tok, std::move (left),\n-\t\t\t\t    std::move (outer_attrs), restrictions);\n+      /*return parse_binary_div_expr (tok, std::move (left),\n+\t\t\t\t    std::move (outer_attrs), restrictions);*/\n+      return parse_arithmetic_or_logical_expr (\n+\ttok, std::move (left), std::move (outer_attrs),\n+\tAST::ArithmeticOrLogicalExpr::DIVIDE, restrictions);\n     case PERCENT:\n       // modulo expression - binary infix\n-      return parse_binary_mod_expr (tok, std::move (left),\n-\t\t\t\t    std::move (outer_attrs), restrictions);\n+      /*return parse_binary_mod_expr (tok, std::move (left),\n+\t\t\t\t    std::move (outer_attrs), restrictions);*/\n+      return parse_arithmetic_or_logical_expr (\n+\ttok, std::move (left), std::move (outer_attrs),\n+\tAST::ArithmeticOrLogicalExpr::MODULUS, restrictions);\n     case AMP:\n       // logical or bitwise and expression - binary infix\n-      return parse_bitwise_and_expr (tok, std::move (left),\n-\t\t\t\t     std::move (outer_attrs), restrictions);\n+      /*return parse_bitwise_and_expr (tok, std::move (left),\n+\t\t\t\t     std::move (outer_attrs), restrictions);*/\n+      return parse_arithmetic_or_logical_expr (\n+\ttok, std::move (left), std::move (outer_attrs),\n+\tAST::ArithmeticOrLogicalExpr::BITWISE_AND, restrictions);\n     case PIPE:\n       // logical or bitwise or expression - binary infix\n-      return parse_bitwise_or_expr (tok, std::move (left),\n-\t\t\t\t    std::move (outer_attrs), restrictions);\n+      /*return parse_bitwise_or_expr (tok, std::move (left),\n+\t\t\t\t    std::move (outer_attrs), restrictions);*/\n+      return parse_arithmetic_or_logical_expr (\n+\ttok, std::move (left), std::move (outer_attrs),\n+\tAST::ArithmeticOrLogicalExpr::BITWISE_OR, restrictions);\n     case CARET:\n       // logical or bitwise xor expression - binary infix\n-      return parse_bitwise_xor_expr (tok, std::move (left),\n-\t\t\t\t     std::move (outer_attrs), restrictions);\n+      /*return parse_bitwise_xor_expr (tok, std::move (left),\n+\t\t\t\t     std::move (outer_attrs), restrictions);*/\n+      return parse_arithmetic_or_logical_expr (\n+\ttok, std::move (left), std::move (outer_attrs),\n+\tAST::ArithmeticOrLogicalExpr::BITWISE_XOR, restrictions);\n     case LEFT_SHIFT:\n       // left shift expression - binary infix\n-      return parse_left_shift_expr (tok, std::move (left),\n-\t\t\t\t    std::move (outer_attrs), restrictions);\n+      /*return parse_left_shift_expr (tok, std::move (left),\n+\t\t\t\t    std::move (outer_attrs), restrictions);*/\n+      return parse_arithmetic_or_logical_expr (\n+\ttok, std::move (left), std::move (outer_attrs),\n+\tAST::ArithmeticOrLogicalExpr::LEFT_SHIFT, restrictions);\n     case RIGHT_SHIFT:\n       // right shift expression - binary infix\n-      return parse_right_shift_expr (tok, std::move (left),\n-\t\t\t\t     std::move (outer_attrs), restrictions);\n+      /*return parse_right_shift_expr (tok, std::move (left),\n+\t\t\t\t     std::move (outer_attrs), restrictions);*/\n+      return parse_arithmetic_or_logical_expr (\n+\ttok, std::move (left), std::move (outer_attrs),\n+\tAST::ArithmeticOrLogicalExpr::RIGHT_SHIFT, restrictions);\n     case EQUAL_EQUAL:\n       // equal to expression - binary infix (no associativity)\n       /*return parse_binary_equal_expr (tok, std::move (left),\n@@ -12106,7 +12137,7 @@ Parser<ManagedTokenSource>::left_denotation (\n \t\t\t       restrictions);\n     case FLOAT_LITERAL:\n       /* HACK: get around lexer mis-identifying '.0' or '.1' or whatever as a\n-       * float literal */\n+       * float literal - TODO does this happen anymore? It shouldn't. */\n       return parse_tuple_index_expr_float (tok, std::move (left),\n \t\t\t\t\t   std::move (outer_attrs),\n \t\t\t\t\t   restrictions);\n@@ -12118,6 +12149,66 @@ Parser<ManagedTokenSource>::left_denotation (\n     }\n }\n \n+/* Returns the left binding power for the given ArithmeticOrLogicalExpr type.\n+ * TODO make constexpr? Would that even do anything useful? */\n+inline binding_powers\n+get_lbp_for_arithmetic_or_logical_expr (\n+  AST::ArithmeticOrLogicalExpr::ExprType expr_type)\n+{\n+  switch (expr_type)\n+    {\n+    case AST::ArithmeticOrLogicalExpr::ADD:\n+      return LBP_PLUS;\n+    case AST::ArithmeticOrLogicalExpr::SUBTRACT:\n+      return LBP_MINUS;\n+    case AST::ArithmeticOrLogicalExpr::MULTIPLY:\n+      return LBP_MUL;\n+    case AST::ArithmeticOrLogicalExpr::DIVIDE:\n+      return LBP_DIV;\n+    case AST::ArithmeticOrLogicalExpr::MODULUS:\n+      return LBP_MOD;\n+    case AST::ArithmeticOrLogicalExpr::BITWISE_AND:\n+      return LBP_AMP;\n+    case AST::ArithmeticOrLogicalExpr::BITWISE_OR:\n+      return LBP_PIPE;\n+    case AST::ArithmeticOrLogicalExpr::BITWISE_XOR:\n+      return LBP_CARET;\n+    case AST::ArithmeticOrLogicalExpr::LEFT_SHIFT:\n+      return LBP_L_SHIFT;\n+    case AST::ArithmeticOrLogicalExpr::RIGHT_SHIFT:\n+      return LBP_R_SHIFT;\n+    default:\n+      // WTF? should not happen, this is an error\n+      rust_error_at (\n+\tLocation (),\n+\t\"could not get LBP for ArithmeticOrLogicalExpr - unknown ExprType!\");\n+      return LBP_PLUS;\n+    }\n+}\n+\n+// Parses an arithmetic or logical expression (with Pratt parsing).\n+template <typename ManagedTokenSource>\n+std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+Parser<ManagedTokenSource>::parse_arithmetic_or_logical_expr (\n+  const_TokenPtr, std::unique_ptr<AST::Expr> left, std::vector<AST::Attribute>,\n+  AST::ArithmeticOrLogicalExpr::ExprType expr_type,\n+  ParseRestrictions restrictions)\n+{\n+  // parse RHS (as tok has already been consumed in parse_expression)\n+  std::unique_ptr<AST::Expr> right\n+    = parse_expr (get_lbp_for_arithmetic_or_logical_expr (expr_type),\n+\t\t  std::vector<AST::Attribute> (), restrictions);\n+  if (right == nullptr)\n+    return nullptr;\n+\n+  // TODO: check types. actually, do so during semantic analysis\n+  Location locus = left->get_locus_slow ();\n+\n+  return std::unique_ptr<AST::ArithmeticOrLogicalExpr> (\n+    new AST::ArithmeticOrLogicalExpr (std::move (left), std::move (right),\n+\t\t\t\t      expr_type, locus));\n+}\n+\n // Parses a binary addition expression (with Pratt parsing).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ArithmeticOrLogicalExpr>"}, {"sha": "cbcc5ae0ab6bb9ab251008eec4a30c5b2dd3d2a8", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd68a282ede655b89665744b368f512167ef49db/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd68a282ede655b89665744b368f512167ef49db/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=fd68a282ede655b89665744b368f512167ef49db", "patch": "@@ -236,6 +236,10 @@ template <typename ManagedTokenSource> class Parser\n \t\t   = std::vector<AST::Attribute> (),\n \t\t   ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_arithmetic_or_logical_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t  std::vector<AST::Attribute> outer_attrs, AST::ArithmeticOrLogicalExpr::ExprType expr_type,\n+\t\t\t  ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n   parse_binary_plus_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n \t\t\t  std::vector<AST::Attribute> outer_attrs,\n \t\t\t  ParseRestrictions restrictions"}]}