{"sha": "bc0ec02766e456e7ba0812aac1d02ac1bafdb46e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMwZWMwMjc2NmU0NTZlN2JhMDgxMmFhYzFkMDJhYzFiYWZkYjQ2ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-08-03T11:02:37Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-08-03T11:02:37Z"}, "message": "cgraphunit.c (add_new_function): Fix logic when adding from late IPA pass.\n\n\n\t* cgraphunit.c (add_new_function): Fix logic when adding from\n\tlate IPA pass.\n\t(assemble_thunk): Rename to ...\n\t(expand_thunk); .. this one; export; get it working with general functions;\n\tmake produced gimple valid.\n\t* cgraph.h (expand_thunk): Declare.\n\nFrom-SVN: r201463", "tree": {"sha": "fd2c8e4d8d7c3285928ec7b185aa274fc22fa0be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd2c8e4d8d7c3285928ec7b185aa274fc22fa0be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc0ec02766e456e7ba0812aac1d02ac1bafdb46e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc0ec02766e456e7ba0812aac1d02ac1bafdb46e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc0ec02766e456e7ba0812aac1d02ac1bafdb46e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc0ec02766e456e7ba0812aac1d02ac1bafdb46e/comments", "author": null, "committer": null, "parents": [{"sha": "0e8853eefb91d4a81bb45eb25db4dd95dc2cf1c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e8853eefb91d4a81bb45eb25db4dd95dc2cf1c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e8853eefb91d4a81bb45eb25db4dd95dc2cf1c4"}], "stats": {"total": 144, "additions": 84, "deletions": 60}, "files": [{"sha": "1d48fc0da36938d0094469a122370b852c83df1d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0ec02766e456e7ba0812aac1d02ac1bafdb46e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0ec02766e456e7ba0812aac1d02ac1bafdb46e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc0ec02766e456e7ba0812aac1d02ac1bafdb46e", "patch": "@@ -1,3 +1,12 @@\n+2013-08-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphunit.c (add_new_function): Fix logic when adding from\n+\tlate IPA pass.\n+\t(assemble_thunk): Rename to ...\n+\t(expand_thunk); .. this one; export; get it working with general functions;\n+\tmake produced gimple valid.\n+\t* cgraph.h (expand_thunk): Declare.\n+\n 2013-08-02  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-cp.c (gather_context_independent_values): Use ipa_get_param_move_cost."}, {"sha": "734f556cd9f6bf5fa38e9b26a51ece7ec26759f0", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0ec02766e456e7ba0812aac1d02ac1bafdb46e/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0ec02766e456e7ba0812aac1d02ac1bafdb46e/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=bc0ec02766e456e7ba0812aac1d02ac1bafdb46e", "patch": "@@ -716,6 +716,7 @@ void fixup_same_cpp_alias_visibility (symtab_node, symtab_node target, tree);\n     IN_SSA is true if the gimple is in SSA.  */\n basic_block init_lowered_empty_function (tree, bool);\n void cgraph_reset_node (struct cgraph_node *);\n+void expand_thunk (struct cgraph_node *);\n \n /* In cgraphclones.c  */\n "}, {"sha": "e308b5248504036562e6c6d1fa916af4c77a2e6d", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 74, "deletions": 60, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc0ec02766e456e7ba0812aac1d02ac1bafdb46e/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc0ec02766e456e7ba0812aac1d02ac1bafdb46e/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=bc0ec02766e456e7ba0812aac1d02ac1bafdb46e", "patch": "@@ -323,13 +323,10 @@ cgraph_process_new_functions (void)\n \t  if (!node->symbol.analyzed)\n \t    analyze_function (node);\n \t  push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n-\t  if ((cgraph_state == CGRAPH_STATE_IPA_SSA\n+\t  if (cgraph_state == CGRAPH_STATE_IPA_SSA\n \t      && !gimple_in_ssa_p (DECL_STRUCT_FUNCTION (fndecl)))\n-\t      /* When not optimizing, be sure we run early local passes anyway\n-\t\t to expand OMP.  */\n-\t      || !optimize)\n \t    execute_pass_list (pass_early_local_passes.pass.sub);\n-\t  else\n+\t  else if (inline_summary_vec != NULL)\n \t    compute_inline_parameters (node, true);\n \t  free_dominance_info (CDI_POST_DOMINATORS);\n \t  free_dominance_info (CDI_DOMINATORS);\n@@ -1327,8 +1324,8 @@ thunk_adjust (gimple_stmt_iterator * bsi,\n \n /* Produce assembler for thunk NODE.  */\n \n-static void\n-assemble_thunk (struct cgraph_node *node)\n+void\n+expand_thunk (struct cgraph_node *node)\n {\n   bool this_adjusting = node->thunk.this_adjusting;\n   HOST_WIDE_INT fixed_offset = node->thunk.fixed_offset;\n@@ -1420,7 +1417,9 @@ assemble_thunk (struct cgraph_node *node)\n       /* Build call to the function being thunked.  */\n       if (!VOID_TYPE_P (restype))\n \t{\n-\t  if (!is_gimple_reg_type (restype))\n+\t  if (DECL_BY_REFERENCE (resdecl))\n+\t    restmp = gimple_fold_indirect_ref (resdecl);\n+\t  else if (!is_gimple_reg_type (restype))\n \t    {\n \t      restmp = resdecl;\n \t      add_local_decl (cfun, restmp);\n@@ -1436,83 +1435,98 @@ assemble_thunk (struct cgraph_node *node)\n       if (this_adjusting)\n         vargs.quick_push (thunk_adjust (&bsi, a, 1, fixed_offset,\n \t\t\t\t\tvirtual_offset));\n-      else\n+      else if (nargs)\n         vargs.quick_push (a);\n-      for (i = 1, arg = DECL_CHAIN (a); i < nargs; i++, arg = DECL_CHAIN (arg))\n-\tvargs.quick_push (arg);\n+\n+      if (nargs)\n+        for (i = 1, arg = DECL_CHAIN (a); i < nargs; i++, arg = DECL_CHAIN (arg))\n+\t  vargs.quick_push (arg);\n       call = gimple_build_call_vec (build_fold_addr_expr_loc (0, alias), vargs);\n       vargs.release ();\n       gimple_call_set_from_thunk (call, true);\n       if (restmp)\n-        gimple_call_set_lhs (call, restmp);\n+\t{\n+          gimple_call_set_lhs (call, restmp);\n+\t  gcc_assert (useless_type_conversion_p (TREE_TYPE (restmp),\n+\t\t\t\t\t\t TREE_TYPE (TREE_TYPE (alias))));\n+\t}\n       gsi_insert_after (&bsi, call, GSI_NEW_STMT);\n+      if (!(gimple_call_flags (call) & ECF_NORETURN))\n+\t{\n+\t  if (restmp && !this_adjusting\n+\t      && (fixed_offset || virtual_offset))\n+\t    {\n+\t      tree true_label = NULL_TREE;\n \n-      if (restmp && !this_adjusting)\n-        {\n-\t  tree true_label = NULL_TREE;\n+\t      if (TREE_CODE (TREE_TYPE (restmp)) == POINTER_TYPE)\n+\t\t{\n+\t\t  gimple stmt;\n+\t\t  /* If the return type is a pointer, we need to\n+\t\t     protect against NULL.  We know there will be an\n+\t\t     adjustment, because that's why we're emitting a\n+\t\t     thunk.  */\n+\t\t  then_bb = create_basic_block (NULL, (void *) 0, bb);\n+\t\t  return_bb = create_basic_block (NULL, (void *) 0, then_bb);\n+\t\t  else_bb = create_basic_block (NULL, (void *) 0, else_bb);\n+\t\t  add_bb_to_loop (then_bb, bb->loop_father);\n+\t\t  add_bb_to_loop (return_bb, bb->loop_father);\n+\t\t  add_bb_to_loop (else_bb, bb->loop_father);\n+\t\t  remove_edge (single_succ_edge (bb));\n+\t\t  true_label = gimple_block_label (then_bb);\n+\t\t  stmt = gimple_build_cond (NE_EXPR, restmp,\n+\t\t\t\t\t    build_zero_cst (TREE_TYPE (restmp)),\n+\t\t\t\t\t    NULL_TREE, NULL_TREE);\n+\t\t  gsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n+\t\t  make_edge (bb, then_bb, EDGE_TRUE_VALUE);\n+\t\t  make_edge (bb, else_bb, EDGE_FALSE_VALUE);\n+\t\t  make_edge (return_bb, EXIT_BLOCK_PTR, 0);\n+\t\t  make_edge (then_bb, return_bb, EDGE_FALLTHRU);\n+\t\t  make_edge (else_bb, return_bb, EDGE_FALLTHRU);\n+\t\t  bsi = gsi_last_bb (then_bb);\n+\t\t}\n \n-\t  if (TREE_CODE (TREE_TYPE (restmp)) == POINTER_TYPE)\n-\t    {\n-\t      gimple stmt;\n-\t      /* If the return type is a pointer, we need to\n-\t\t protect against NULL.  We know there will be an\n-\t\t adjustment, because that's why we're emitting a\n-\t\t thunk.  */\n-\t      then_bb = create_basic_block (NULL, (void *) 0, bb);\n-\t      return_bb = create_basic_block (NULL, (void *) 0, then_bb);\n-\t      else_bb = create_basic_block (NULL, (void *) 0, else_bb);\n-\t      add_bb_to_loop (then_bb, bb->loop_father);\n-\t      add_bb_to_loop (return_bb, bb->loop_father);\n-\t      add_bb_to_loop (else_bb, bb->loop_father);\n-\t      remove_edge (single_succ_edge (bb));\n-\t      true_label = gimple_block_label (then_bb);\n-\t      stmt = gimple_build_cond (NE_EXPR, restmp,\n-\t      \t\t\t\tbuild_zero_cst (TREE_TYPE (restmp)),\n-\t      \t\t\t        NULL_TREE, NULL_TREE);\n-\t      gsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n-\t      make_edge (bb, then_bb, EDGE_TRUE_VALUE);\n-\t      make_edge (bb, else_bb, EDGE_FALSE_VALUE);\n-\t      make_edge (return_bb, EXIT_BLOCK_PTR, 0);\n-\t      make_edge (then_bb, return_bb, EDGE_FALLTHRU);\n-\t      make_edge (else_bb, return_bb, EDGE_FALLTHRU);\n-\t      bsi = gsi_last_bb (then_bb);\n+\t      restmp = thunk_adjust (&bsi, restmp, /*this_adjusting=*/0,\n+\t\t\t\t     fixed_offset, virtual_offset);\n+\t      if (true_label)\n+\t\t{\n+\t\t  gimple stmt;\n+\t\t  bsi = gsi_last_bb (else_bb);\n+\t\t  stmt = gimple_build_assign (restmp,\n+\t\t\t\t\t      build_zero_cst (TREE_TYPE (restmp)));\n+\t\t  gsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n+\t\t  bsi = gsi_last_bb (return_bb);\n+\t\t}\n \t    }\n+\t  else\n+\t    gimple_call_set_tail (call, true);\n \n-\t  restmp = thunk_adjust (&bsi, restmp, /*this_adjusting=*/0,\n-\t\t\t         fixed_offset, virtual_offset);\n-\t  if (true_label)\n-\t    {\n-\t      gimple stmt;\n-\t      bsi = gsi_last_bb (else_bb);\n-\t      stmt = gimple_build_assign (restmp,\n-\t\t\t\t\t  build_zero_cst (TREE_TYPE (restmp)));\n-\t      gsi_insert_after (&bsi, stmt, GSI_NEW_STMT);\n-\t      bsi = gsi_last_bb (return_bb);\n-\t    }\n+\t  /* Build return value.  */\n+\t  ret = gimple_build_return (restmp);\n+\t  gsi_insert_after (&bsi, ret, GSI_NEW_STMT);\n \t}\n       else\n-        gimple_call_set_tail (call, true);\n-\n-      /* Build return value.  */\n-      ret = gimple_build_return (restmp);\n-      gsi_insert_after (&bsi, ret, GSI_NEW_STMT);\n+\t{\n+\t  gimple_call_set_tail (call, true);\n+\t  remove_edge (single_succ_edge (bb));\n+\t}\n \n       delete_unreachable_blocks ();\n       update_ssa (TODO_update_ssa);\n+#ifdef ENABLE_CHECKING\n+      verify_flow_info ();\n+#endif\n \n       /* Since we want to emit the thunk, we explicitly mark its name as\n \t referenced.  */\n       node->thunk.thunk_p = false;\n-      cgraph_node_remove_callees (node);\n+      rebuild_cgraph_edges ();\n       cgraph_add_new_function (thunk_fndecl, true);\n       bitmap_obstack_release (NULL);\n     }\n   current_function_decl = NULL;\n   set_cfun (NULL);\n }\n \n-\n-\n /* Assemble thunks and aliases associated to NODE.  */\n \n static void\n@@ -1529,7 +1543,7 @@ assemble_thunks_and_aliases (struct cgraph_node *node)\n \n \te = e->next_caller;\n \tassemble_thunks_and_aliases (thunk);\n-        assemble_thunk (thunk);\n+        expand_thunk (thunk);\n       }\n     else\n       e = e->next_caller;"}]}