{"sha": "fbc9b4531337a13e969472e6a53187b36b73c4aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJjOWI0NTMxMzM3YTEzZTk2OTQ3MmU2YTUzMTg3YjM2YjczYzRhYQ==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2004-06-29T21:18:10Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-06-29T21:18:10Z"}, "message": "dump-parse-tree.c (show_common): New function.\n\n* dump-parse-tree.c (show_common): New function.\n(gfc_show_namespace): Show commons.\n\nFrom-SVN: r83874", "tree": {"sha": "3ac65b8c246829d4466ca671981a8298b9aec421", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ac65b8c246829d4466ca671981a8298b9aec421"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbc9b4531337a13e969472e6a53187b36b73c4aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbc9b4531337a13e969472e6a53187b36b73c4aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbc9b4531337a13e969472e6a53187b36b73c4aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbc9b4531337a13e969472e6a53187b36b73c4aa/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57512331dae302ff19f29f6ca043fee2bfb1587d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57512331dae302ff19f29f6ca043fee2bfb1587d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57512331dae302ff19f29f6ca043fee2bfb1587d"}], "stats": {"total": 455, "additions": 246, "deletions": 209}, "files": [{"sha": "7861e185fce6d92304651ec16bf731f5a17175e7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc9b4531337a13e969472e6a53187b36b73c4aa/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc9b4531337a13e969472e6a53187b36b73c4aa/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fbc9b4531337a13e969472e6a53187b36b73c4aa", "patch": "@@ -1,3 +1,8 @@\n+2004-06-29  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\t* dump-parse-tree.c (show_common): New function.\n+\t(gfc_show_namespace): Show commons.\n+\n 2004-06-29  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \tAndrew Vaught  <andyv@firstinter.net>\n "}, {"sha": "e4cbe15a42bac7b91607de4652b957f0932dfd33", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 215, "deletions": 8, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc9b4531337a13e969472e6a53187b36b73c4aa/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc9b4531337a13e969472e6a53187b36b73c4aa/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=fbc9b4531337a13e969472e6a53187b36b73c4aa", "patch": "@@ -874,12 +874,12 @@ match_char_spec (gfc_typespec * ts)\n    to the matched specification.  This is necessary for FUNCTION and\n    IMPLICIT statements.\n \n-   If kind_flag is nonzero, then we check for the optional kind\n-   specification.  Not doing so is needed for matching an IMPLICIT\n+   If implicit_flag is nonzero, then we don't check for the optional \n+   kind specification.  Not doing so is needed for matching an IMPLICIT\n    statement correctly.  */\n \n-match\n-gfc_match_type_spec (gfc_typespec * ts, int kind_flag)\n+static match\n+match_type_spec (gfc_typespec * ts, int implicit_flag)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symbol *sym;\n@@ -898,7 +898,10 @@ gfc_match_type_spec (gfc_typespec * ts, int kind_flag)\n   if (gfc_match (\" character\") == MATCH_YES)\n     {\n       ts->type = BT_CHARACTER;\n-      return match_char_spec (ts);\n+      if (implicit_flag == 0)\n+\treturn match_char_spec (ts);\n+      else\n+\treturn MATCH_YES;\n     }\n \n   if (gfc_match (\" real\") == MATCH_YES)\n@@ -960,7 +963,7 @@ gfc_match_type_spec (gfc_typespec * ts, int kind_flag)\n get_kind:\n   /* For all types except double, derived and character, look for an\n      optional kind specifier.  MATCH_NO is actually OK at this point.  */\n-  if (kind_flag == 0)\n+  if (implicit_flag == 1)\n     return MATCH_YES;\n \n   if (gfc_current_form == FORM_FREE)\n@@ -982,6 +985,210 @@ gfc_match_type_spec (gfc_typespec * ts, int kind_flag)\n }\n \n \n+/* Match an IMPLICIT NONE statement.  Actually, this statement is\n+   already matched in parse.c, or we would not end up here in the\n+   first place.  So the only thing we need to check, is if there is\n+   trailing garbage.  If not, the match is successful.  */\n+\n+match\n+gfc_match_implicit_none (void)\n+{\n+\n+  return (gfc_match_eos () == MATCH_YES) ? MATCH_YES : MATCH_NO;\n+}\n+\n+\n+/* Match the letter range(s) of an IMPLICIT statement.  */\n+\n+static match\n+match_implicit_range (gfc_typespec * ts)\n+{\n+  int c, c1, c2, inner;\n+  locus cur_loc;\n+\n+  cur_loc = gfc_current_locus;\n+\n+  gfc_gobble_whitespace ();\n+  c = gfc_next_char ();\n+  if (c != '(')\n+    {\n+      gfc_error (\"Missing character range in IMPLICIT at %C\");\n+      goto bad;\n+    }\n+\n+  inner = 1;\n+  while (inner)\n+    {\n+      gfc_gobble_whitespace ();\n+      c1 = gfc_next_char ();\n+      if (!ISALPHA (c1))\n+\tgoto bad;\n+\n+      gfc_gobble_whitespace ();\n+      c = gfc_next_char ();\n+\n+      switch (c)\n+\t{\n+\tcase ')':\n+\t  inner = 0;\t\t/* Fall through */\n+\n+\tcase ',':\n+\t  c2 = c1;\n+\t  break;\n+\n+\tcase '-':\n+\t  gfc_gobble_whitespace ();\n+\t  c2 = gfc_next_char ();\n+\t  if (!ISALPHA (c2))\n+\t    goto bad;\n+\n+\t  gfc_gobble_whitespace ();\n+\t  c = gfc_next_char ();\n+\n+\t  if ((c != ',') && (c != ')'))\n+\t    goto bad;\n+\t  if (c == ')')\n+\t    inner = 0;\n+\n+\t  break;\n+\n+\tdefault:\n+\t  goto bad;\n+\t}\n+\n+      if (c1 > c2)\n+\t{\n+\t  gfc_error (\"Letters must be in alphabetic order in \"\n+\t\t     \"IMPLICIT statement at %C\");\n+\t  goto bad;\n+\t}\n+\n+      /* See if we can add the newly matched range to the pending\n+         implicits from this IMPLICIT statement.  We do not check for\n+         conflicts with whatever earlier IMPLICIT statements may have\n+         set.  This is done when we've successfully finished matching\n+         the current one.  */\n+      if (gfc_add_new_implicit_range (c1, c2, ts) != SUCCESS)\n+\tgoto bad;\n+    }\n+\n+  return MATCH_YES;\n+\n+bad:\n+  gfc_syntax_error (ST_IMPLICIT);\n+\n+  gfc_current_locus = cur_loc;\n+  return MATCH_ERROR;\n+}\n+\n+\n+/* Match an IMPLICIT statement, storing the types for\n+   gfc_set_implicit() if the statement is accepted by the parser.\n+   There is a strange looking, but legal syntactic construction\n+   possible.  It looks like:\n+\n+     IMPLICIT INTEGER (a-b) (c-d)\n+\n+   This is legal if \"a-b\" is a constant expression that happens to\n+   equal one of the legal kinds for integers.  The real problem\n+   happens with an implicit specification that looks like:\n+\n+     IMPLICIT INTEGER (a-b)\n+\n+   In this case, a typespec matcher that is \"greedy\" (as most of the\n+   matchers are) gobbles the character range as a kindspec, leaving\n+   nothing left.  We therefore have to go a bit more slowly in the\n+   matching process by inhibiting the kindspec checking during\n+   typespec matching and checking for a kind later.  */\n+\n+match\n+gfc_match_implicit (void)\n+{\n+  gfc_typespec ts;\n+  locus cur_loc;\n+  int c;\n+  match m;\n+\n+  /* We don't allow empty implicit statements.  */\n+  if (gfc_match_eos () == MATCH_YES)\n+    {\n+      gfc_error (\"Empty IMPLICIT statement at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  /* First cleanup.  */\n+  gfc_clear_new_implicit ();\n+\n+  do\n+    {\n+      /* A basic type is mandatory here.  */\n+      m = match_type_spec (&ts, 1);\n+      if (m == MATCH_ERROR)\n+\tgoto error;\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+\n+      cur_loc = gfc_current_locus;\n+      m = match_implicit_range (&ts);\n+\n+      if (m != MATCH_YES && ts.type == BT_CHARACTER)\n+\t{\n+\t  /* looks like we are matching CHARACTER (<len>) (<range>)  */\n+\t  m = match_char_spec (&ts);\n+\t}\t  \n+\n+      if (m == MATCH_YES)\n+\t{\n+\t  /* Looks like we have the <TYPE> (<RANGE>).  */\n+\t  gfc_gobble_whitespace ();\n+\t  c = gfc_next_char ();\n+\t  if ((c == '\\n') || (c == ','))\n+\t    continue;\n+\n+\t  gfc_current_locus = cur_loc;\n+\t}\n+\n+      /* Last chance -- check <TYPE> (<KIND>) (<RANGE>).  */\n+      m = gfc_match_kind_spec (&ts);\n+      if (m == MATCH_ERROR)\n+\tgoto error;\n+      if (m == MATCH_NO)\n+\t{\n+\t  m = gfc_match_old_kind_spec (&ts);\n+\t  if (m == MATCH_ERROR)\n+\t    goto error;\n+\t  if (m == MATCH_NO)\n+\t    goto syntax;\n+\t}\n+\n+      m = match_implicit_range (&ts);\n+      if (m == MATCH_ERROR)\n+\tgoto error;\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+\n+      gfc_gobble_whitespace ();\n+      c = gfc_next_char ();\n+      if ((c != '\\n') && (c != ','))\n+\tgoto syntax;\n+\n+    }\n+  while (c == ',');\n+\n+  /* All we need to now is try to merge the new implicit types back\n+     into the existing types.  This will fail if another implicit\n+     type is already defined for a letter.  */\n+  return (gfc_merge_new_implicit () == SUCCESS) ?\n+      MATCH_YES : MATCH_ERROR;\n+\n+syntax:\n+  gfc_syntax_error (ST_IMPLICIT);\n+\n+error:\n+  return MATCH_ERROR;\n+}\n+\n+\n /* Matches an attribute specification including array specs.  If\n    successful, leaves the variables current_attr and current_as\n    holding the specification.  Also sets the colon_seen variable for\n@@ -1242,7 +1449,7 @@ gfc_match_data_decl (void)\n   gfc_symbol *sym;\n   match m;\n \n-  m = gfc_match_type_spec (&current_ts, 1);\n+  m = match_type_spec (&current_ts, 0);\n   if (m != MATCH_YES)\n     return m;\n \n@@ -1332,7 +1539,7 @@ match_prefix (gfc_typespec * ts)\n \n loop:\n   if (!seen_type && ts != NULL\n-      && gfc_match_type_spec (ts, 1) == MATCH_YES\n+      && match_type_spec (ts, 0) == MATCH_YES\n       && gfc_match_space () == MATCH_YES)\n     {\n "}, {"sha": "8d23c908ed03e9684a2acd9838a79b00dc64b6bb", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc9b4531337a13e969472e6a53187b36b73c4aa/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc9b4531337a13e969472e6a53187b36b73c4aa/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=fbc9b4531337a13e969472e6a53187b36b73c4aa", "patch": "@@ -718,6 +718,27 @@ gfc_traverse_user_op (gfc_namespace * ns, void (*func) (gfc_user_op *))\n }\n \n \n+/* Function to display a common block.  */\n+\n+static void\n+show_common (gfc_symtree * st)\n+{\n+  gfc_symbol *s;\n+\n+  show_indent ();\n+  gfc_status (\"common: /%s/ \", st->name);\n+\n+  s = st->n.common->head;\n+  while (s)\n+    {\n+      gfc_status (\"%s\", s->name);\n+      s = s->common_next;\n+      if (s)\n+\tgfc_status (\", \");\n+    }\n+  gfc_status_char ('\\n');\n+}    \n+\n /* Worker function to display the symbol tree.  */\n \n static void\n@@ -1432,6 +1453,8 @@ gfc_show_namespace (gfc_namespace * ns)\n \t}\n \n       gfc_current_ns = ns;\n+      gfc_traverse_symtree (ns->common_root, show_common);\n+\n       gfc_traverse_symtree (ns->sym_root, show_symtree);\n \n       for (op = GFC_INTRINSIC_BEGIN; op != GFC_INTRINSIC_END; op++)"}, {"sha": "9bc1f4fbe634f7a5a9b39e11aaf33f03b61692d2", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 0, "deletions": 198, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc9b4531337a13e969472e6a53187b36b73c4aa/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc9b4531337a13e969472e6a53187b36b73c4aa/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=fbc9b4531337a13e969472e6a53187b36b73c4aa", "patch": "@@ -2048,204 +2048,6 @@ gfc_match_call (void)\n }\n \n \n-/* Match an IMPLICIT NONE statement.  Actually, this statement is\n-   already matched in parse.c, or we would not end up here in the\n-   first place.  So the only thing we need to check, is if there is\n-   trailing garbage.  If not, the match is successful.  */\n-\n-match\n-gfc_match_implicit_none (void)\n-{\n-\n-  return (gfc_match_eos () == MATCH_YES) ? MATCH_YES : MATCH_NO;\n-}\n-\n-\n-/* Match the letter range(s) of an IMPLICIT statement.  */\n-\n-static match\n-match_implicit_range (gfc_typespec * ts)\n-{\n-  int c, c1, c2, inner;\n-  locus cur_loc;\n-\n-  cur_loc = gfc_current_locus;\n-\n-  gfc_gobble_whitespace ();\n-  c = gfc_next_char ();\n-  if (c != '(')\n-    {\n-      gfc_error (\"Missing character range in IMPLICIT at %C\");\n-      goto bad;\n-    }\n-\n-  inner = 1;\n-  while (inner)\n-    {\n-      gfc_gobble_whitespace ();\n-      c1 = gfc_next_char ();\n-      if (!ISALPHA (c1))\n-\tgoto bad;\n-\n-      gfc_gobble_whitespace ();\n-      c = gfc_next_char ();\n-\n-      switch (c)\n-\t{\n-\tcase ')':\n-\t  inner = 0;\t\t/* Fall through */\n-\n-\tcase ',':\n-\t  c2 = c1;\n-\t  break;\n-\n-\tcase '-':\n-\t  gfc_gobble_whitespace ();\n-\t  c2 = gfc_next_char ();\n-\t  if (!ISALPHA (c2))\n-\t    goto bad;\n-\n-\t  gfc_gobble_whitespace ();\n-\t  c = gfc_next_char ();\n-\n-\t  if ((c != ',') && (c != ')'))\n-\t    goto bad;\n-\t  if (c == ')')\n-\t    inner = 0;\n-\n-\t  break;\n-\n-\tdefault:\n-\t  goto bad;\n-\t}\n-\n-      if (c1 > c2)\n-\t{\n-\t  gfc_error (\"Letters must be in alphabetic order in \"\n-\t\t     \"IMPLICIT statement at %C\");\n-\t  goto bad;\n-\t}\n-\n-      /* See if we can add the newly matched range to the pending\n-         implicits from this IMPLICIT statement.  We do not check for\n-         conflicts with whatever earlier IMPLICIT statements may have\n-         set.  This is done when we've successfully finished matching\n-         the current one.  */\n-      if (gfc_add_new_implicit_range (c1, c2, ts) != SUCCESS)\n-\tgoto bad;\n-    }\n-\n-  return MATCH_YES;\n-\n-bad:\n-  gfc_syntax_error (ST_IMPLICIT);\n-\n-  gfc_current_locus = cur_loc;\n-  return MATCH_ERROR;\n-}\n-\n-\n-/* Match an IMPLICIT statement, storing the types for\n-   gfc_set_implicit() if the statement is accepted by the parser.\n-   There is a strange looking, but legal syntactic construction\n-   possible.  It looks like:\n-\n-     IMPLICIT INTEGER (a-b) (c-d)\n-\n-   This is legal if \"a-b\" is a constant expression that happens to\n-   equal one of the legal kinds for integers.  The real problem\n-   happens with an implicit specification that looks like:\n-\n-     IMPLICIT INTEGER (a-b)\n-\n-   In this case, a typespec matcher that is \"greedy\" (as most of the\n-   matchers are) gobbles the character range as a kindspec, leaving\n-   nothing left.  We therefore have to go a bit more slowly in the\n-   matching process by inhibiting the kindspec checking during\n-   typespec matching and checking for a kind later.  */\n-\n-match\n-gfc_match_implicit (void)\n-{\n-  gfc_typespec ts;\n-  locus cur_loc;\n-  int c;\n-  match m;\n-\n-  /* We don't allow empty implicit statements.  */\n-  if (gfc_match_eos () == MATCH_YES)\n-    {\n-      gfc_error (\"Empty IMPLICIT statement at %C\");\n-      return MATCH_ERROR;\n-    }\n-\n-  /* First cleanup.  */\n-  gfc_clear_new_implicit ();\n-\n-  do\n-    {\n-      /* A basic type is mandatory here.  */\n-      m = gfc_match_type_spec (&ts, 0);\n-      if (m == MATCH_ERROR)\n-\tgoto error;\n-      if (m == MATCH_NO)\n-\tgoto syntax;\n-\n-      cur_loc = gfc_current_locus;\n-      m = match_implicit_range (&ts);\n-\n-      if (m == MATCH_YES)\n-\t{\n-\t  /* Looks like we have the <TYPE> (<RANGE>).  */\n-\t  gfc_gobble_whitespace ();\n-\t  c = gfc_next_char ();\n-\t  if ((c == '\\n') || (c == ','))\n-\t    continue;\n-\n-\t  gfc_current_locus = cur_loc;\n-\t}\n-\n-      /* Last chance -- check <TYPE> (<KIND>) (<RANGE>).  */\n-      m = gfc_match_kind_spec (&ts);\n-      if (m == MATCH_ERROR)\n-\tgoto error;\n-      if (m == MATCH_NO)\n-\t{\n-\t  m = gfc_match_old_kind_spec (&ts);\n-\t  if (m == MATCH_ERROR)\n-\t    goto error;\n-\t  if (m == MATCH_NO)\n-\t    goto syntax;\n-\t}\n-\n-      m = match_implicit_range (&ts);\n-      if (m == MATCH_ERROR)\n-\tgoto error;\n-      if (m == MATCH_NO)\n-\tgoto syntax;\n-\n-      gfc_gobble_whitespace ();\n-      c = gfc_next_char ();\n-      if ((c != '\\n') && (c != ','))\n-\tgoto syntax;\n-\n-    }\n-  while (c == ',');\n-\n-  /* All we need to now is try to merge the new implicit types back\n-     into the existing types.  This will fail if another implicit\n-     type is already defined for a letter.  */\n-  return (gfc_merge_new_implicit () == SUCCESS) ?\n-      MATCH_YES : MATCH_ERROR;\n-\n-syntax:\n-  gfc_syntax_error (ST_IMPLICIT);\n-\n-error:\n-  return MATCH_ERROR;\n-}\n-\n-\n /* Given a name, return a pointer to the common head structure,\n    creating it if it does not exist.\n    TODO: Add to global symbol tree.  */"}, {"sha": "4b8f87232ec82676fcc760849789b6d671c81b8f", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbc9b4531337a13e969472e6a53187b36b73c4aa/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbc9b4531337a13e969472e6a53187b36b73c4aa/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=fbc9b4531337a13e969472e6a53187b36b73c4aa", "patch": "@@ -75,8 +75,6 @@ match gfc_match_deallocate (void);\n match gfc_match_return (void);\n match gfc_match_call (void);\n match gfc_match_common (void);\n-match gfc_match_implicit_none (void);\n-match gfc_match_implicit (void);\n match gfc_match_block_data (void);\n match gfc_match_namelist (void);\n match gfc_match_module (void);\n@@ -98,7 +96,6 @@ gfc_common_head *gfc_get_common (char *);\n match gfc_match_null (gfc_expr **);\n match gfc_match_kind_spec (gfc_typespec *);\n match gfc_match_old_kind_spec (gfc_typespec *);\n-match gfc_match_type_spec (gfc_typespec *, int);\n \n match gfc_match_end (gfc_statement *);\n match gfc_match_data_decl (void);\n@@ -108,6 +105,9 @@ match gfc_match_entry (void);\n match gfc_match_subroutine (void);\n match gfc_match_derived_decl (void);\n \n+match gfc_match_implicit_none (void);\n+match gfc_match_implicit (void);\n+\n /* Matchers for attribute declarations */\n match gfc_match_allocatable (void);\n match gfc_match_dimension (void);"}]}