{"sha": "278d4cc485b5d7a133e5ec34022d92d06d7da9c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc4ZDRjYzQ4NWI1ZDdhMTMzZTVlYzM0MDIyZDkyZDA2ZDdkYTljOQ==", "commit": {"author": {"name": "Chris Jefferson", "email": "chris@bubblescope.net", "date": "2004-11-24T06:24:10Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-11-24T06:24:10Z"}, "message": "testsuite_iterators.h: New.\n\n\n2004-11-23  Chris Jefferson  <chris@bubblescope.net>\n\n        * testsuite/testsuite_iterators.h: New.\n        * testsuite/25_algorithms/search_n/iterator.cc: New.\n        * testsuite/performance/25_algorithms/search_n.cc: New.\n\nFrom-SVN: r91139", "tree": {"sha": "bb15cd1e56554261dec5e6f580c569a0b3729b8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb15cd1e56554261dec5e6f580c569a0b3729b8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/278d4cc485b5d7a133e5ec34022d92d06d7da9c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/278d4cc485b5d7a133e5ec34022d92d06d7da9c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/278d4cc485b5d7a133e5ec34022d92d06d7da9c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/278d4cc485b5d7a133e5ec34022d92d06d7da9c9/comments", "author": {"login": "ChrisJefferson", "id": 811527, "node_id": "MDQ6VXNlcjgxMTUyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/811527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisJefferson", "html_url": "https://github.com/ChrisJefferson", "followers_url": "https://api.github.com/users/ChrisJefferson/followers", "following_url": "https://api.github.com/users/ChrisJefferson/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisJefferson/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisJefferson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisJefferson/subscriptions", "organizations_url": "https://api.github.com/users/ChrisJefferson/orgs", "repos_url": "https://api.github.com/users/ChrisJefferson/repos", "events_url": "https://api.github.com/users/ChrisJefferson/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisJefferson/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b27c3c6a145bcd66d006e6ac7834edc8c7fcb89d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b27c3c6a145bcd66d006e6ac7834edc8c7fcb89d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b27c3c6a145bcd66d006e6ac7834edc8c7fcb89d"}], "stats": {"total": 720, "additions": 720, "deletions": 0}, "files": [{"sha": "75fd077bb99006b8311b16312dff195d05636e45", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/278d4cc485b5d7a133e5ec34022d92d06d7da9c9/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/278d4cc485b5d7a133e5ec34022d92d06d7da9c9/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=278d4cc485b5d7a133e5ec34022d92d06d7da9c9", "patch": "@@ -1,3 +1,9 @@\n+2004-11-23  Chris Jefferson  <chris@bubblescope.net>\n+\n+\t* testsuite/testsuite_iterators.h: New.\n+        * testsuite/25_algorithms/search_n/iterator.cc: New.\n+        * testsuite/performance/25_algorithms/search_n.cc: New.\n+\n 2004-11-23  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* testsuite/lib/libstdc++.exp: Use new procs in target-libpath.exp."}, {"sha": "f822745be227b7b7d3f01cbca715417b58d4d523", "filename": "libstdc++-v3/testsuite/25_algorithms/search_n/iterator.cc", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/278d4cc485b5d7a133e5ec34022d92d06d7da9c9/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsearch_n%2Fiterator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/278d4cc485b5d7a133e5ec34022d92d06d7da9c9/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsearch_n%2Fiterator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsearch_n%2Fiterator.cc?ref=278d4cc485b5d7a133e5ec34022d92d06d7da9c9", "patch": "@@ -0,0 +1,103 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 25 algorithms, search_n\n+\n+#include <algorithm>\n+#include <functional>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+#define TEST_DEPTH 14\n+int array1[11] = {0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0};\n+int array2[TEST_DEPTH];\n+\n+bool \n+pred(int i, int j)\n+{\n+  return i == j;\n+}\n+\n+bool\n+lexstep(int* start, int length) \n+{\n+  int i = 0;\n+  int carry = 1;\n+  while(i < length && carry) \n+    {\n+      if(start[i] == 1)\n+\tstart[i] = 0;\n+      else \n+\t{\n+\t  start[i] = 1;\n+\t  carry = 0;\n+\t}\n+      i++;\n+    }\n+  return !carry;\n+}\n+\n+using __gnu_test::test_container;\n+using __gnu_test::random_access_iterator_wrapper;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+int main() {\n+  test_container<int,forward_iterator_wrapper> con(array1,array1 + 10);\n+  VERIFY(search_n(con.end(), con.end(), 0, 1) == con.end());\n+  VERIFY(search_n(con.end(), con.end(), 1, 1) == con.end());\n+  VERIFY(search_n(con.begin(), con.end(), 1, 1).ptr == array1 + 1);\n+  VERIFY(search_n(con.begin(), con.end(), 2, 1).ptr == array1 + 4);\n+  VERIFY(search_n(con.begin(), con.end(), 3, 1).ptr == array1 + 7);\n+  VERIFY(search_n(con.begin(), con.end(), 3, 0) == con.end());\n+\n+  // Now do a brute-force comparison of the different types\n+  for(int i = 0; i < TEST_DEPTH; i++) \n+    {\n+      for(int j = 0; j < i; j++)\n+\tarray2[i] = 0;\n+      do {\n+\tfor(int j = 0; j < i; j++)\n+\t  {\n+\t    test_container<int, forward_iterator_wrapper>\n+\t      forwardcon(array2, array2 + i);\n+\t    test_container<int, bidirectional_iterator_wrapper>\n+\t      randomcon(array2, array2 + i);\n+\t    test_container<int, bidirectional_iterator_wrapper>\n+\t      bidircon(array2, array2 + i);\n+\n+\t    int* t1 = search_n(forwardcon.begin(),\n+\t\t\t       forwardcon.end(), j, 1).ptr;\n+\t    int* t2 = search_n(forwardcon.begin(),\n+\t\t\t       forwardcon.end(), j, 1, pred).ptr;\n+\t    int* t3 = search_n(bidircon.begin(),\n+\t\t\t       bidircon.end(), j, 1).ptr;\n+\t    int* t4 = search_n(bidircon.begin(),\n+\t\t\t       bidircon.end(), j, 1, pred).ptr;\n+\t    int* t5 = search_n(randomcon.begin(),\n+\t\t\t       randomcon.end(), j, 1).ptr;\n+\t    int* t6 = search_n(randomcon.begin(),\n+\t\t\t       randomcon.end(), j, 1, pred).ptr;\n+\t    VERIFY((t1 == t2) && (t2 == t3) && (t3 == t4) &&\n+\t\t   (t4 == t5) && (t5 == t6));\n+\t  }\n+      } \n+      while(lexstep(array2, i));\n+    }\n+  return 0;\n+}"}, {"sha": "6ffa0a9bcaf1f2360b0796671f6e1f77830b84f0", "filename": "libstdc++-v3/testsuite/performance/25_algorithms/search_n.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/278d4cc485b5d7a133e5ec34022d92d06d7da9c9/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Fsearch_n.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/278d4cc485b5d7a133e5ec34022d92d06d7da9c9/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Fsearch_n.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F25_algorithms%2Fsearch_n.cc?ref=278d4cc485b5d7a133e5ec34022d92d06d7da9c9", "patch": "@@ -0,0 +1,72 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#define DISABLE_ITERATOR_DEBUG 1\n+\n+#include<cstdlib>\n+#include<vector>\n+#include<algorithm>\n+\n+#include<sstream>\n+#include<testsuite_performance.h>\n+#include<testsuite_iterators.h>\n+\n+using namespace std;\n+using namespace __gnu_test;\n+\n+const int length = 10000000;\n+const int match_length = 3;\n+int array[length];\n+\n+int\n+main(void)\n+{\n+  time_counter time;\n+  resource_counter resource;\n+  int match = rand() % (match_length - 1);\n+  for(int i = 0; i < length; i++)\n+    {\n+      array[i] = (match != 0) ? 1 : 0;\n+      if(--match < 0) match = rand() % (match_length - 1);\n+    }\n+  test_container<int, forward_iterator_wrapper> fcon(array, array + length);\n+  start_counters(time, resource);\n+  for(int i = 0; i < 100; i++)\n+    search_n(fcon.begin(), fcon.end(), 10, 1);\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"forward iterator\", time, resource);\n+  clear_counters(time, resource);\n+\n+  test_container<int, random_access_iterator_wrapper> rcon(array, array + length);\n+  start_counters(time, resource);\n+  for(int i = 0; i < 100; i++)\n+    search_n(rcon.begin(), rcon.end(), 10, 1);\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"random acess iterator\", time, resource);\n+  clear_counters(time, resource);\n+}\n+"}, {"sha": "435bb1d26b581521766af21bdebd6e2f69c38e95", "filename": "libstdc++-v3/testsuite/testsuite_iterators.h", "status": "added", "additions": 539, "deletions": 0, "changes": 539, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/278d4cc485b5d7a133e5ec34022d92d06d7da9c9/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_iterators.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/278d4cc485b5d7a133e5ec34022d92d06d7da9c9/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_iterators.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_iterators.h?ref=278d4cc485b5d7a133e5ec34022d92d06d7da9c9", "patch": "@@ -0,0 +1,539 @@\n+// -*- C++ -*-\n+// Iterator Wrappers for the C++ library testsuite. \n+//\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+//\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// This file provides the following:\n+//\n+// input_iterator_wrapper, output_iterator_wrapper\n+// forward_iterator_wrapper, bidirectional_iterator_wrapper and\n+// random_access_wrapper, which attempt to exactly perform the requirements\n+// of these types of iterators. These are constructed from the class\n+// test_container, which is given two pointers to T and an iterator type.\n+\n+#include <testsuite_hooks.h>\n+#include <iterator>\n+\n+#ifndef _TESTSUITE_ITERATORS\n+#define _TESTSUITE_ITERATORS\n+\n+#ifdef DISABLE_ITERATOR_DEBUG\n+#define ITERATOR_VERIFY(x)\n+#else\n+#define ITERATOR_VERIFY(x) VERIFY(x)\n+#endif\n+\n+namespace __gnu_test\n+{\n+  /**\n+   * @brief Simple container for holding two pointers.\n+   *\n+   * Note that input_iterator_wrapper changes first to denote\n+   * how the valid range of == , ++, etc. change as the iterators are used.\n+   */\n+  template<typename T>\n+    struct BoundsContainer\n+    {\n+      T* first;\n+      T* last;\n+      BoundsContainer(T* _first, T* _last)\n+\t: first(_first), last(_last)\n+      { }\n+    };\n+\n+  // Simple container for holding state of a set of output iterators.\n+  template<typename T>\n+    struct OutputContainer : public BoundsContainer<T>\n+    {\n+      T* incrementedto;\n+      bool* writtento;\n+      OutputContainer(T* _first, T* _last)\n+\t: BoundsContainer<T>(_first, _last), incrementedto(_first)\n+      {\n+\twrittento = new bool[this->last - this->first];\n+\tfor(int i = 0; i < this->last - this->first; i++)\n+\t  writtento = false;\n+      }\n+\n+      ~OutputContainer()\n+      { delete[] writtento; }\n+    };\n+\n+  // Produced by output_iterator to allow limited writing to pointer\n+  template<class T>\n+    class WritableObject\n+    {\n+      T* ptr;\n+\n+    public:\n+      OutputContainer<T>* SharedInfo;\n+      WritableObject(T* ptr_in,OutputContainer<T>* SharedInfo_in):\n+\tptr(ptr_in), SharedInfo(SharedInfo_in)\n+      { }\n+\n+      void\n+      operator=(T& new_val)\n+      {\n+\tITERATOR_VERIFY(SharedInfo->writtento[ptr - SharedInfo->first] == 0);\n+\tSharedInfo->writtento[ptr - SharedInfo->first] = 1;\n+\tptr = new_val;\n+      }\n+    };\n+\n+  /**\n+   * @brief output_iterator wrapper for pointer\n+   * \n+   * This class takes a pointer and wraps it to provide exactly\n+   * the requirements of a output_iterator. It should not be\n+   * instansiated directly, but generated from a test_container\n+   */\n+  template<class T>\n+  struct output_iterator_wrapper: public std::iterator\n+  <std::output_iterator_tag, T, ptrdiff_t, T*, T&>\n+  {\n+    typedef OutputContainer<T> ContainerType;\n+    T* ptr;\n+    ContainerType* SharedInfo;\n+\n+    output_iterator_wrapper(T* _ptr, ContainerType* SharedInfo_in)\n+      :ptr(_ptr), SharedInfo(SharedInfo_in)\n+    {\n+      ITERATOR_VERIFY(ptr >= SharedInfo->first && ptr <= SharedInfo->last);\n+    }\n+    \n+    output_iterator_wrapper(const output_iterator_wrapper& in)\n+      :ptr(in.ptr), SharedInfo(in.SharedInfo)\n+    { }\n+\n+    WritableObject<T>\n+    operator*() const\n+    {\n+      ITERATOR_VERIFY(ptr < SharedInfo->last);\n+      ITERATOR_VERIFY(SharedInfo->writtento[ptr - SharedInfo->first] == false);\n+      return WritableObject<T>(ptr, SharedInfo);\n+    }\n+    \n+    output_iterator_wrapper&\n+    operator=(const output_iterator_wrapper& in) \n+    {\n+      ptr = in.ptr;\n+      SharedInfo = in.SharedInfo;\n+    }\n+\n+    output_iterator_wrapper&\n+    operator++()\n+    {\n+      ITERATOR_VERIFY(SharedInfo && ptr < SharedInfo->last);\n+      ITERATOR_VERIFY(ptr>=SharedInfo->first);\n+      ptr++;\n+      SharedInfo->first=ptr;\n+      return *this;\n+    }\n+\n+    output_iterator_wrapper\n+    operator++(int)\n+    {\n+      output_iterator_wrapper<T> tmp = *this;\n+      ++*this;\n+      return tmp;\n+    }\n+\n+  };\n+\n+  /**\n+   * @brief input_iterator wrapper for pointer\n+   * \n+   * This class takes a pointer and wraps it to provide exactly\n+   * the requirements of a input_iterator. It should not be\n+   * instansiated directly, but generated from a test_container\n+   */\n+  template<class T>\n+  class input_iterator_wrapper:public std::iterator\n+  <std::input_iterator_tag, T, ptrdiff_t, T*, T&>\n+  {\n+  protected:\n+    input_iterator_wrapper()\n+    { }\n+\n+  public:\n+    typedef BoundsContainer<T> ContainerType;\n+    T* ptr;\n+    ContainerType* SharedInfo;\n+\n+    input_iterator_wrapper(T* _ptr, ContainerType* SharedInfo_in)\n+      : ptr(_ptr), SharedInfo(SharedInfo_in)\n+    { ITERATOR_VERIFY(ptr >= SharedInfo->first && ptr <= SharedInfo->last); }\n+    \n+    input_iterator_wrapper(const input_iterator_wrapper& in)\n+      : ptr(in.ptr), SharedInfo(in.SharedInfo)\n+    { }\n+\n+    bool\n+    operator==(const input_iterator_wrapper& in) const\n+    {\n+      ITERATOR_VERIFY(SharedInfo != NULL && SharedInfo == in.SharedInfo);\n+      ITERATOR_VERIFY(ptr>=SharedInfo->first && in.ptr>=SharedInfo->first);\n+      return ptr == in.ptr;\n+    }\n+\n+    bool\n+    operator!=(const input_iterator_wrapper& in) const\n+    {\n+      return !(*this == in);\n+    }\n+\n+    T&\n+    operator*() const\n+    {\n+      ITERATOR_VERIFY(SharedInfo && ptr < SharedInfo->last);\n+      ITERATOR_VERIFY(ptr >= SharedInfo->first);\n+      return *ptr;\n+    }\n+\n+    T*\n+    operator->() const\n+    {\n+      return &**this;\n+    }\n+\n+    input_iterator_wrapper&\n+    operator=(const input_iterator_wrapper& in)\n+    {\n+      ptr = in.ptr;\n+      SharedInfo = in.SharedInfo;\n+      return *this;\n+    }\n+\n+    input_iterator_wrapper&\n+    operator++()\n+    {\n+      ITERATOR_VERIFY(SharedInfo && ptr < SharedInfo->last);\n+      ITERATOR_VERIFY(ptr>=SharedInfo->first);\n+      ptr++;\n+      SharedInfo->first=ptr;\n+      return *this;\n+    }\n+\n+    void\n+    operator++(int)\n+    {\n+      ++*this;\n+    }\n+  };\n+\n+\n+  /**\n+   * @brief forward_iterator wrapper for pointer\n+   * \n+   * This class takes a pointer and wraps it to provide exactly\n+   * the requirements of a forward_iterator. It should not be\n+   * instansiated directly, but generated from a test_container\n+   */\n+  template<class T>\n+  struct forward_iterator_wrapper:public input_iterator_wrapper<T>\n+  {\n+    typedef BoundsContainer<T> ContainerType;\n+    typedef std::forward_iterator_tag iterator_category;\n+    forward_iterator_wrapper(T* _ptr, ContainerType* SharedInfo_in)\n+      :input_iterator_wrapper<T>(_ptr, SharedInfo_in)\n+    { }\n+    \n+    forward_iterator_wrapper(const forward_iterator_wrapper& in)\n+      :input_iterator_wrapper<T>(in)\n+    { }\n+\n+    forward_iterator_wrapper()\n+    {\n+      this->ptr = NULL;\n+      this->SharedInfo = NULL;\n+    }\n+\n+    T&\n+    operator*() const\n+    {\n+      ITERATOR_VERIFY(this->SharedInfo && this->ptr < this->SharedInfo->last);\n+      return *(this->ptr);\n+    }\n+\n+    T*\n+    operator->() const\n+    { return &**this; }\n+\n+    forward_iterator_wrapper&\n+    operator++()\n+    {\n+      ITERATOR_VERIFY(this->SharedInfo && this->ptr < this->SharedInfo->last);\n+      this->ptr++;\n+      return *this;\n+    }\n+\n+    forward_iterator_wrapper\n+    operator++(int)\n+    {\n+      forward_iterator_wrapper<T> tmp = *this;\n+      ++*this;\n+      return tmp;\n+    }\n+   };\n+\n+  /**\n+   * @brief bidirectional_iterator wrapper for pointer\n+   * \n+   * This class takes a pointer and wraps it to provide exactly\n+   * the requirements of a forward_iterator. It should not be\n+   * instansiated directly, but generated from a test_container\n+   */\n+  template<class T>\n+  struct bidirectional_iterator_wrapper:public forward_iterator_wrapper<T>\n+  {\n+    typedef BoundsContainer<T> ContainerType;\n+    typedef std::bidirectional_iterator_tag iterator_category;\n+    bidirectional_iterator_wrapper(T* _ptr, ContainerType* SharedInfo_in)\n+      :forward_iterator_wrapper<T>(_ptr, SharedInfo_in)\n+    { }\n+\n+    bidirectional_iterator_wrapper(const bidirectional_iterator_wrapper& in)\n+      :forward_iterator_wrapper<T>(in)\n+    { }\n+\n+    bidirectional_iterator_wrapper(): forward_iterator_wrapper<T>()\n+    { }\n+\n+    bidirectional_iterator_wrapper&\n+    operator=(const bidirectional_iterator_wrapper& in)\n+    {\n+      this->ptr = in.ptr;\n+      this->SharedInfo = in.SharedInfo;\n+      return *this;\n+    }\n+   \n+    bidirectional_iterator_wrapper&\n+    operator++()\n+    {\n+      ITERATOR_VERIFY(this->SharedInfo && this->ptr < this->SharedInfo->last);\n+      this->ptr++;\n+      return *this;\n+    }\n+\n+    bidirectional_iterator_wrapper\n+    operator++(int)\n+    {\n+      bidirectional_iterator_wrapper<T> tmp = *this;\n+      ++*this;\n+      return tmp;\n+    }\n+\n+    bidirectional_iterator_wrapper& \n+    operator--()\n+    {\n+      ITERATOR_VERIFY(this->SharedInfo && this->ptr > this->SharedInfo->first);\n+      this->ptr--;\n+      return *this;\n+    }\n+\n+    bidirectional_iterator_wrapper\n+    operator--(int)\n+    { \n+      bidirectional_iterator_wrapper<T> tmp = *this;\n+      --*this;\n+      return tmp;\n+    }\n+   };\n+\n+  /**\n+   * @brief random_access_iterator wrapper for pointer\n+   * \n+   * This class takes a pointer and wraps it to provide exactly\n+   * the requirements of a forward_iterator. It should not be\n+   * instansiated directly, but generated from a test_container\n+   */\n+  template<class T>\n+  struct random_access_iterator_wrapper:public bidirectional_iterator_wrapper<T>\n+  {\n+    typedef BoundsContainer<T> ContainerType;\n+    typedef std::random_access_iterator_tag iterator_category;\n+    random_access_iterator_wrapper(T* _ptr, ContainerType* SharedInfo_in)\n+      : bidirectional_iterator_wrapper<T>(_ptr, SharedInfo_in)\n+    { }\n+\n+    random_access_iterator_wrapper(const random_access_iterator_wrapper<T>& in)\n+      : bidirectional_iterator_wrapper<T>(in)\n+    { }\n+\n+    random_access_iterator_wrapper():bidirectional_iterator_wrapper<T>()\n+    { }\n+\n+    random_access_iterator_wrapper&\n+    operator=(const random_access_iterator_wrapper& in)\n+    {\n+      this->ptr = in.ptr;\n+      this->SharedInfo = in.SharedInfo;\n+    }\n+\n+    random_access_iterator_wrapper&\n+    operator++()\n+    {\n+      ITERATOR_VERIFY(this->SharedInfo && this->ptr < this->SharedInfo->last);\n+      this->ptr++;\n+      return *this;\n+    }\n+\n+    random_access_iterator_wrapper\n+    operator++(int)\n+    {\n+      random_access_iterator_wrapper<T> tmp = *this;\n+      ++*this;\n+      return tmp;\n+    }\n+\n+    random_access_iterator_wrapper&\n+    operator--()\n+    {\n+      ITERATOR_VERIFY(this->SharedInfo && this->ptr > this->SharedInfo->first);\n+      this->ptr--;\n+      return *this;\n+    }\n+\n+    random_access_iterator_wrapper\n+    operator--(int)\n+    {\n+      random_access_iterator_wrapper<T> tmp = *this;\n+      ++*this;\n+      return tmp;\n+    }\n+\n+    random_access_iterator_wrapper&\n+    operator+=(ptrdiff_t n)\n+    {\n+      if(n > 0)\n+\t{\n+\t  ITERATOR_VERIFY(n <= this->SharedInfo->last - this->ptr);\n+\t  this->ptr += n;\n+\t}\n+      else\n+\t{\n+\t  ITERATOR_VERIFY(n <= this->ptr - this->SharedInfo->first);\n+\t  this->ptr += n;\n+\t}\n+      return *this;\n+    }\n+\n+    random_access_iterator_wrapper\n+    operator+(ptrdiff_t n)\n+    {\n+      random_access_iterator_wrapper<T> tmp = *this;\n+      return tmp += n;\n+    }\n+\n+    random_access_iterator_wrapper&\n+    operator-=(ptrdiff_t n)\n+    { return *this += -n; }\n+\n+    random_access_iterator_wrapper\n+    operator-(ptrdiff_t n)\n+    {\n+      random_access_iterator_wrapper<T> tmp = *this;\n+      return tmp -= n;\n+    }\n+\n+    ptrdiff_t\n+    operator-(const random_access_iterator_wrapper<T>& in)\n+    {\n+      ITERATOR_VERIFY(this->SharedInfo == in.SharedInfo);\n+      return this->ptr - in.ptr;\n+    }\n+\n+    T&\n+    operator[](ptrdiff_t n)\n+    { return *(this + n); }\n+\n+    bool\n+    operator<(const random_access_iterator_wrapper<T>& in) const\n+    {\n+      ITERATOR_VERIFY(this->SharedInfo == in.SharedInfo);\n+      return this->ptr < in.ptr;\n+    }\n+\n+    bool\n+    operator>(const random_access_iterator_wrapper<T>& in) const\n+    {\n+      return in < *this;\n+    }\n+\n+    bool\n+    operator>=(const random_access_iterator_wrapper<T>& in) const\n+    {\n+      return !(*this < in);\n+    }\n+\n+    bool \n+    operator<=(const random_access_iterator_wrapper<T>& in) const\n+    {\n+      return !(*this > in);\n+    }\n+   };\n+\n+\n+  /** \n+   * @brief A container-type class for holding iterator wrappers\n+   * test_container takes two parameters, a class T and an iterator\n+   * wrapper templated by T (for example forward_iterator_wrapper<T>.\n+   * It takes two pointers representing a range and presents them as \n+   * a container of iterators.\n+   */\n+  template <class T, template<class T> class ItType>\n+  struct test_container\n+  {\n+    typename ItType<T>::ContainerType bounds;\n+    test_container(T* _first, T* _last):bounds(_first, _last)\n+    { }\n+\n+    ItType<T>\n+    it(int pos)\n+    {\n+      ITERATOR_VERIFY(pos >= 0 && pos <= (bounds.last - bounds.first));\n+      return ItType<T>(bounds.first + pos, &bounds);\n+    }\n+\n+    ItType<T>\n+    it(T* pos)\n+    {\n+      ITERATOR_VERIFY(pos >= bounds.first && pos <= bounds.last);\n+      return ItType<T>(pos, &bounds);\n+    }\n+\n+    ItType<T>\n+    begin()\n+    { return it(bounds.first); }\n+\n+    ItType<T>\n+    end()\n+    { return it(bounds.last); }\n+   };\n+}\n+#endif"}]}