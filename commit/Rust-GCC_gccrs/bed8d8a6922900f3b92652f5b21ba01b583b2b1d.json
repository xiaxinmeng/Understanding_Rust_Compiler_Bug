{"sha": "bed8d8a6922900f3b92652f5b21ba01b583b2b1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVkOGQ4YTY5MjI5MDBmM2I5MjY1MmY1YjIxYmEwMWI1ODNiMmIxZA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2013-02-01T12:52:41Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2013-02-01T12:52:41Z"}, "message": "task.c (GOMP_task, [...]): Comment.\n\n\t* task.c (GOMP_task, GOMP_taskwait): Comment.\n\nFrom-SVN: r195647", "tree": {"sha": "e3c309016d5ae2d12e311b052c30ce5eb676d54c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3c309016d5ae2d12e311b052c30ce5eb676d54c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bed8d8a6922900f3b92652f5b21ba01b583b2b1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bed8d8a6922900f3b92652f5b21ba01b583b2b1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bed8d8a6922900f3b92652f5b21ba01b583b2b1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bed8d8a6922900f3b92652f5b21ba01b583b2b1d/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8c7ca45c9d2641477ceebf30568af8d4c49ff2f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c7ca45c9d2641477ceebf30568af8d4c49ff2f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c7ca45c9d2641477ceebf30568af8d4c49ff2f9"}], "stats": {"total": 19, "additions": 19, "deletions": 0}, "files": [{"sha": "2bbb789c1a49882e2454c4d7a58050f32e12cfe9", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed8d8a6922900f3b92652f5b21ba01b583b2b1d/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed8d8a6922900f3b92652f5b21ba01b583b2b1d/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=bed8d8a6922900f3b92652f5b21ba01b583b2b1d", "patch": "@@ -1,3 +1,7 @@\n+2013-02-01  Alan Modra  <amodra@gmail.com>\n+\n+\t* task.c (GOMP_task, GOMP_taskwait): Comment.\n+\n 2013-01-31  Dmitry Vyukov  <dvyukov@gcc.gnu.org>\n \t    Joost VandeVondele  <Joost.VandeVondele@mat.ethz.ch>\n "}, {"sha": "7de650a43f1457edcf093b1b6c24835a4167b10d", "filename": "libgomp/task.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bed8d8a6922900f3b92652f5b21ba01b583b2b1d/libgomp%2Ftask.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bed8d8a6922900f3b92652f5b21ba01b583b2b1d/libgomp%2Ftask.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftask.c?ref=bed8d8a6922900f3b92652f5b21ba01b583b2b1d", "patch": "@@ -116,6 +116,15 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n \t}\n       else\n \tfn (data);\n+      /* Access to \"children\" is normally done inside a task_lock\n+\t mutex region, but the only way this particular task.children\n+\t can be set is if this thread's task work function (fn)\n+\t creates children.  So since the setter is *this* thread, we\n+\t need no barriers here when testing for non-NULL.  We can have\n+\t task.children set by the current thread then changed by a\n+\t child thread, but seeing a stale non-NULL value is not a\n+\t problem.  Once past the task_lock acquisition, this thread\n+\t will see the real value of task.children.  */\n       if (task.children != NULL)\n \t{\n \t  gomp_mutex_lock (&team->task_lock);\n@@ -296,6 +305,12 @@ GOMP_taskwait (void)\n   struct gomp_task *child_task = NULL;\n   struct gomp_task *to_free = NULL;\n \n+  /* The acquire barrier on load of task->children here synchronizes\n+     with the write of a NULL in gomp_barrier_handle_tasks.  It is\n+     not necessary that we synchronize with other non-NULL writes at\n+     this point, but we must ensure that all writes to memory by a\n+     child thread task work function are seen before we exit from\n+     GOMP_taskwait.  */\n   if (task == NULL\n       || __atomic_load_n (&task->children, MEMMODEL_ACQUIRE) == NULL)\n     return;"}]}