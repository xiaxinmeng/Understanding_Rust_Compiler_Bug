{"sha": "d804ed43d00126b959d19621d7c546463d990e1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgwNGVkNDNkMDAxMjZiOTU5ZDE5NjIxZDdjNTQ2NDYzZDk5MGUxYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-01-19T21:30:48Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-01-19T21:30:48Z"}, "message": "expr.c (do_jump_for_compare): Handle conditional branch expanders emitting multiple jump instructions.\n\n        * expr.c (do_jump_for_compare): Handle conditional branch expanders\n        emitting multiple jump instructions.\n        * jump.c (condjump_label): New function.\n        * rtl.h (condjump_label): Declare it.\n\nFrom-SVN: r24773", "tree": {"sha": "0b661dbf1b43ed00d7384a2ae1d1e8726d2c4dfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b661dbf1b43ed00d7384a2ae1d1e8726d2c4dfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d804ed43d00126b959d19621d7c546463d990e1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d804ed43d00126b959d19621d7c546463d990e1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d804ed43d00126b959d19621d7c546463d990e1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d804ed43d00126b959d19621d7c546463d990e1a/comments", "author": null, "committer": null, "parents": [{"sha": "c14c652997970714f0b92df466ccebdf1e5cddfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c14c652997970714f0b92df466ccebdf1e5cddfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c14c652997970714f0b92df466ccebdf1e5cddfa"}], "stats": {"total": 105, "additions": 84, "deletions": 21}, "files": [{"sha": "572ce6cd7d5f3587eb9ff1dc289113de05602894", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d804ed43d00126b959d19621d7c546463d990e1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d804ed43d00126b959d19621d7c546463d990e1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d804ed43d00126b959d19621d7c546463d990e1a", "patch": "@@ -1,3 +1,10 @@\n+Tue Jan 19 21:20:52 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* expr.c (do_jump_for_compare): Handle conditional branch expanders\n+\temitting multiple jump instructions.\n+\t* jump.c (condjump_label): New function.\n+\t* rtl.h (condjump_label): Declare it.\n+\n Tue Jan 19 21:08:20 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* expr.c (emit_move_insn_1): Revert 17 Dec change.  Don't emit"}, {"sha": "591c82613a10ebf78794596c59ee222d76d46a9f", "filename": "gcc/expr.c", "status": "modified", "additions": 50, "deletions": 21, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d804ed43d00126b959d19621d7c546463d990e1a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d804ed43d00126b959d19621d7c546463d990e1a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d804ed43d00126b959d19621d7c546463d990e1a", "patch": "@@ -11008,7 +11008,8 @@ do_jump_for_compare (comparison, if_false_label, if_true_label)\n   if (if_true_label)\n     {\n       if (bcc_gen_fctn[(int) GET_CODE (comparison)] != 0)\n-\temit_jump_insn ((*bcc_gen_fctn[(int) GET_CODE (comparison)]) (if_true_label));\n+\temit_jump_insn ((*bcc_gen_fctn[(int) GET_CODE (comparison)])\n+\t\t\t  (if_true_label));\n       else\n \tabort ();\n \n@@ -11017,52 +11018,80 @@ do_jump_for_compare (comparison, if_false_label, if_true_label)\n     }\n   else if (if_false_label)\n     {\n-      rtx insn;\n-      rtx prev = get_last_insn ();\n-      rtx branch = 0;\n+      rtx first = get_last_insn (), insn, branch;\n+      int br_count;\n \n       /* Output the branch with the opposite condition.  Then try to invert\n \t what is generated.  If more than one insn is a branch, or if the\n \t branch is not the last insn written, abort. If we can't invert\n \t the branch, emit make a true label, redirect this jump to that,\n \t emit a jump to the false label and define the true label.  */\n+      /* ??? Note that we wouldn't have to do any of this nonsense if\n+\t we passed both labels into a combined compare-and-branch. \n+\t Ah well, jump threading does a good job of repairing the damage.  */\n \n       if (bcc_gen_fctn[(int) GET_CODE (comparison)] != 0)\n-\temit_jump_insn ((*bcc_gen_fctn[(int) GET_CODE (comparison)])(if_false_label));\n+\temit_jump_insn ((*bcc_gen_fctn[(int) GET_CODE (comparison)])\n+\t\t\t  (if_false_label));\n       else\n \tabort ();\n \n-      /* Here we get the first insn that was just emitted.  It used to be  the\n+      /* Here we get the first insn that was just emitted.  It used to be the\n \t case that, on some machines, emitting the branch would discard\n \t the previous compare insn and emit a replacement.  This isn't\n \t done anymore, but abort if we see that PREV is deleted.  */\n \n-      if (prev == 0)\n-\tinsn = get_insns ();\n-      else if (INSN_DELETED_P (prev))\n+      if (first == 0)\n+\tfirst = get_insns ();\n+      else if (INSN_DELETED_P (first))\n \tabort ();\n       else\n-\tinsn = NEXT_INSN (prev);\n+\tfirst = NEXT_INSN (first);\n \n-      for (; insn; insn = NEXT_INSN (insn))\n+      /* Look for multiple branches in this sequence, as might be generated\n+\t for a multi-word integer comparison.  */\n+\n+      br_count = 0;\n+      branch = NULL_RTX;\n+      for (insn = first; insn ; insn = NEXT_INSN (insn))\n \tif (GET_CODE (insn) == JUMP_INSN)\n \t  {\n-\t    if (branch)\n-\t      abort ();\n \t    branch = insn;\n+\t    br_count += 1;\n \t  }\n \n-      if (branch != get_last_insn ())\n-\tabort ();\n+      /* If we've got one branch at the end of the sequence,\n+\t we can try to reverse it.  */\n \n-      JUMP_LABEL (branch) = if_false_label;\n-      if (! invert_jump (branch, if_false_label))\n+      if (br_count == 1 && NEXT_INSN (branch) == NULL_RTX)\n \t{\n-\t  if_true_label = gen_label_rtx ();\n-\t  redirect_jump (branch, if_true_label);\n-\t  emit_jump (if_false_label);\n-\t  emit_label (if_true_label);\n+\t  rtx insn_label;\n+\t  insn_label = XEXP (condjump_label (branch), 0);\n+\t  JUMP_LABEL (branch) = insn_label;\n+\n+\t  if (insn_label != if_false_label)\n+\t    abort ();\n+\n+\t  if (invert_jump (branch, if_false_label))\n+\t    return;\n \t}\n+\n+      /* Multiple branches, or reversion failed.  Convert to branches\n+\t around an unconditional jump.  */\n+\n+      if_true_label = gen_label_rtx ();\n+      for (insn = first; insn; insn = NEXT_INSN (insn))\n+\tif (GET_CODE (insn) == JUMP_INSN)\n+\t  {\n+\t    rtx insn_label;\n+\t    insn_label = XEXP (condjump_label (insn), 0);\n+\t    JUMP_LABEL (insn) = insn_label;\n+\n+\t    if (insn_label == if_false_label)\n+\t      redirect_jump (insn, if_true_label);\n+\t  }\n+\temit_jump (if_false_label);\n+\temit_label (if_true_label);\n     }\n }\n \f"}, {"sha": "47f5fd4cb7f4a011a772b616750791e8c0eaba48", "filename": "gcc/jump.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d804ed43d00126b959d19621d7c546463d990e1a/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d804ed43d00126b959d19621d7c546463d990e1a/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=d804ed43d00126b959d19621d7c546463d990e1a", "patch": "@@ -3402,6 +3402,32 @@ condjump_in_parallel_p (insn)\n   return 0;\n }\n \n+/* Return the label of a conditional jump.  */\n+\n+rtx\n+condjump_label (insn)\n+     rtx insn;\n+{\n+  register rtx x = PATTERN (insn);\n+\n+  if (GET_CODE (x) == PARALLEL)\n+    x = XVECEXP (x, 0, 0);\n+  if (GET_CODE (x) != SET)\n+    return NULL_RTX;\n+  if (GET_CODE (SET_DEST (x)) != PC)\n+    return NULL_RTX;\n+  x = SET_SRC (x);\n+  if (GET_CODE (x) == LABEL_REF)\n+    return x;\n+  if (GET_CODE (x) != IF_THEN_ELSE)\n+    return NULL_RTX;\n+  if (XEXP (x, 2) == pc_rtx && GET_CODE (XEXP (x, 1)) == LABEL_REF)\n+    return XEXP (x, 1);\n+  if (XEXP (x, 1) == pc_rtx && GET_CODE (XEXP (x, 2)) == LABEL_REF)\n+    return XEXP (x, 2);\n+  return NULL_RTX;\n+}\n+\n #ifdef HAVE_cc0\n \n /* Return 1 if X is an RTX that does nothing but set the condition codes"}, {"sha": "76fc6e11263b9021cb549267db6299ea3f1bf7e3", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d804ed43d00126b959d19621d7c546463d990e1a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d804ed43d00126b959d19621d7c546463d990e1a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=d804ed43d00126b959d19621d7c546463d990e1a", "patch": "@@ -1289,6 +1289,7 @@ extern void cse_end_of_basic_block\tPROTO ((rtx,\n /* In jump.c */\n extern int comparison_dominates_p\tPROTO ((enum rtx_code, enum rtx_code));\n extern int condjump_p\t\t\tPROTO ((rtx));\n+extern rtx condjump_label\t\tPROTO ((rtx));\n extern int simplejump_p\t\t\tPROTO ((rtx));\n extern int sets_cc0_p\t\t\tPROTO ((rtx));\n extern int invert_jump\t\t\tPROTO ((rtx, rtx));"}]}