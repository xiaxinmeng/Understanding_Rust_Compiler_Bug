{"sha": "da43a810ca70d16ba1a53e4e28c9701e1708d5ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE0M2E4MTBjYTcwZDE2YmExYTUzZTRlMjhjOTcwMWUxNzA4ZDVlZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-10-08T17:39:10Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-10-08T17:39:10Z"}, "message": "Add functions copy_insn/copy_insn_1; use them in jump.c\n\nFrom-SVN: r29870", "tree": {"sha": "6f2e50114b9e39ec7ea39b504e667a6a0f6631a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f2e50114b9e39ec7ea39b504e667a6a0f6631a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da43a810ca70d16ba1a53e4e28c9701e1708d5ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da43a810ca70d16ba1a53e4e28c9701e1708d5ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da43a810ca70d16ba1a53e4e28c9701e1708d5ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da43a810ca70d16ba1a53e4e28c9701e1708d5ee/comments", "author": null, "committer": null, "parents": [{"sha": "b1afd7f4e03c52ed0b07387ad26e3e3c58595f28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1afd7f4e03c52ed0b07387ad26e3e3c58595f28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1afd7f4e03c52ed0b07387ad26e3e3c58595f28"}], "stats": {"total": 220, "additions": 214, "deletions": 6}, "files": [{"sha": "dfe8f967d996d2c5c35ba69c10b08cbee237ea35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da43a810ca70d16ba1a53e4e28c9701e1708d5ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da43a810ca70d16ba1a53e4e28c9701e1708d5ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da43a810ca70d16ba1a53e4e28c9701e1708d5ee", "patch": "@@ -1,3 +1,14 @@\n+Fri Oct  8 18:46:11 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* jump.c (duplicate_loop_exit_test): Use copy_insn/copy_insn_1\n+\tinstead of copy_rtx.  Accept sequences that contain asm statements.\n+\t* emit_rtl.c (copy_insn_1, copy_insn): New functions.\n+\t(copy_insn_scratch_in, copy_insn_scratch_out, copy_insn_n_scratches,\n+\torig_asm_operands_vector, copy_asm_operands_vector,\n+\torig_asm_constraints_vecotr, copy_asm_constraints_vector): New static\n+\tvariables.\n+\t* rtl.h (copy_insn, copy_insn_1): Declare.\n+\n Fri Oct  8 13:08:12 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Makefile.in (insn-recog.o): Depend on hard-reg-set.h and resource.h."}, {"sha": "9f6819771439b879b99a64ce4c6830f3a4f8e74f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da43a810ca70d16ba1a53e4e28c9701e1708d5ee/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da43a810ca70d16ba1a53e4e28c9701e1708d5ee/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=da43a810ca70d16ba1a53e4e28c9701e1708d5ee", "patch": "@@ -162,6 +162,9 @@ static rtx free_insn;\n #define last_filename (current_function->emit->x_last_filename)\n #define first_label_num (current_function->emit->x_first_label_num)\n \n+/* This is where the pointer to the obstack being used for RTL is stored.  */\n+extern struct obstack *rtl_obstack;\n+\n static rtx make_jump_insn_raw\t\tPROTO((rtx));\n static rtx make_call_insn_raw\t\tPROTO((rtx));\n static rtx find_line_note\t\tPROTO((rtx));\n@@ -3370,6 +3373,199 @@ clear_emit_caches ()\n     sequence_result[i] = 0;\n   free_insn = 0;\n }\n+\f\n+/* Used by copy_insn_1 to avoid copying SCRATCHes more than once.  */\n+static rtx copy_insn_scratch_in[MAX_RECOG_OPERANDS];\n+static rtx copy_insn_scratch_out[MAX_RECOG_OPERANDS];\n+static int copy_insn_n_scratches;\n+\n+/* When an insn is being copied by copy_insn_1, this is nonzero if we have\n+   copied an ASM_OPERANDS.\n+   In that case, it is the original input-operand vector.  */\n+static rtvec orig_asm_operands_vector;\n+\n+/* When an insn is being copied by copy_insn_1, this is nonzero if we have\n+   copied an ASM_OPERANDS.\n+   In that case, it is the copied input-operand vector.  */\n+static rtvec copy_asm_operands_vector;\n+\n+/* Likewise for the constraints vector.  */\n+static rtvec orig_asm_constraints_vector;\n+static rtvec copy_asm_constraints_vector;\n+\n+/* Recursively create a new copy of an rtx for copy_insn.\n+   This function differs from copy_rtx in that it handles SCRATCHes and\n+   ASM_OPERANDs properly.\n+   Normally, this function is not used directly; use copy_insn as front end.\n+   However, you could first copy an insn pattern with copy_insn and then use\n+   this function afterwards to properly copy any REG_NOTEs containing\n+   SCRATCHes.  */\n+\n+rtx\n+copy_insn_1 (orig)\n+     register rtx orig;\n+{\n+  register rtx copy;\n+  register int i, j;\n+  register RTX_CODE code;\n+  register char *format_ptr;\n+\n+  code = GET_CODE (orig);\n+\n+  switch (code)\n+    {\n+    case REG:\n+    case QUEUED:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case CODE_LABEL:\n+    case PC:\n+    case CC0:\n+    case ADDRESSOF:\n+      return orig;\n+\n+    case SCRATCH:\n+      for (i = 0; i < copy_insn_n_scratches; i++)\n+\tif (copy_insn_scratch_in[i] == orig)\n+\t  return copy_insn_scratch_out[i];\n+      break;\n+\n+    case CONST:\n+      /* CONST can be shared if it contains a SYMBOL_REF.  If it contains\n+\t a LABEL_REF, it isn't sharable.  */\n+      if (GET_CODE (XEXP (orig, 0)) == PLUS\n+\t  && GET_CODE (XEXP (XEXP (orig, 0), 0)) == SYMBOL_REF\n+\t  && GET_CODE (XEXP (XEXP (orig, 0), 1)) == CONST_INT)\n+\treturn orig;\n+      break;\n+      \n+      /* A MEM with a constant address is not sharable.  The problem is that\n+\t the constant address may need to be reloaded.  If the mem is shared,\n+\t then reloading one copy of this mem will cause all copies to appear\n+\t to have been reloaded.  */\n+\n+    default:\n+      break;\n+    }\n+\n+  copy = rtx_alloc (code);\n+\n+  /* Copy the various flags, and other information.  We assume that\n+     all fields need copying, and then clear the fields that should\n+     not be copied.  That is the sensible default behavior, and forces\n+     us to explicitly document why we are *not* copying a flag.  */\n+  memcpy (copy, orig, sizeof (struct rtx_def) - sizeof (rtunion));\n+\n+  /* We do not copy the USED flag, which is used as a mark bit during\n+     walks over the RTL.  */\n+  copy->used = 0;\n+\n+  /* We do not copy JUMP, CALL, or FRAME_RELATED for INSNs.  */\n+  if (GET_RTX_CLASS (code) == 'i')\n+    {\n+      copy->jump = 0;\n+      copy->call = 0;\n+      copy->frame_related = 0;\n+    }\n+  \n+  format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n+\n+  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (copy)); i++)\n+    {\n+      switch (*format_ptr++)\n+\t{\n+\tcase 'e':\n+\t  XEXP (copy, i) = XEXP (orig, i);\n+\t  if (XEXP (orig, i) != NULL)\n+\t    XEXP (copy, i) = copy_insn_1 (XEXP (orig, i));\n+\t  break;\n+\n+\tcase '0':\n+\tcase 'u':\n+\t  XEXP (copy, i) = XEXP (orig, i);\n+\t  break;\n+\n+\tcase 'E':\n+\tcase 'V':\n+\t  XVEC (copy, i) = XVEC (orig, i);\n+\t  if (XVEC (orig, i) == orig_asm_constraints_vector)\n+\t    XVEC (copy, i) = copy_asm_constraints_vector;\n+\t  else if (XVEC (orig, i) == orig_asm_operands_vector)\n+\t    XVEC (copy, i) = copy_asm_operands_vector;\n+\t  else if (XVEC (orig, i) != NULL)\n+\t    {\n+\t      XVEC (copy, i) = rtvec_alloc (XVECLEN (orig, i));\n+\t      for (j = 0; j < XVECLEN (copy, i); j++)\n+\t\tXVECEXP (copy, i, j) = copy_insn_1 (XVECEXP (orig, i, j));\n+\t    }\n+\t  break;\n+\n+\tcase 'b':\n+\t  {\n+\t    bitmap new_bits = BITMAP_OBSTACK_ALLOC (rtl_obstack);\n+\t    bitmap_copy (new_bits, XBITMAP (orig, i));\n+\t    XBITMAP (copy, i) = new_bits;\n+\t    break;\n+\t  }\n+\n+\tcase 't':\n+\t  XTREE (copy, i) = XTREE (orig, i);\n+\t  break;\n+\n+\tcase 'w':\n+\t  XWINT (copy, i) = XWINT (orig, i);\n+\t  break;\n+\n+\tcase 'i':\n+\t  XINT (copy, i) = XINT (orig, i);\n+\t  break;\n+\n+\tcase 's':\n+\tcase 'S':\n+\t  XSTR (copy, i) = XSTR (orig, i);\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+\n+  if (code == SCRATCH)\n+    {\n+      i = copy_insn_n_scratches++;\n+      if (i >= MAX_RECOG_OPERANDS)\n+\tabort ();\n+      copy_insn_scratch_in[i] = orig;\n+      copy_insn_scratch_out[i] = copy;\n+    }\n+  else if (code == ASM_OPERANDS)\n+    {\n+      orig_asm_operands_vector = XVEC (orig, 3);\n+      copy_asm_operands_vector = XVEC (copy, 3);\n+      orig_asm_constraints_vector = XVEC (orig, 4);\n+      copy_asm_constraints_vector = XVEC (copy, 4);\n+    }\n+\n+  return copy;\n+}\n+\n+/* Create a new copy of an rtx.\n+   This function differs from copy_rtx in that it handles SCRATCHes and\n+   ASM_OPERANDs properly.\n+   INSN doesn't really have to be a full INSN; it could be just the\n+   pattern.  */\n+rtx\n+copy_insn (insn)\n+     rtx insn;\n+{\n+  copy_insn_n_scratches = 0;\n+  orig_asm_operands_vector = 0;\n+  orig_asm_constraints_vector = 0;\n+  copy_asm_operands_vector = 0;\n+  copy_asm_constraints_vector = 0;\n+  return copy_insn_1 (insn);\n+}\n \n /* Initialize data structures and variables in this file\n    before generating rtl for each function.  */"}, {"sha": "2328d8f069982a1095e16dc860a80521dee9cbcc", "filename": "gcc/jump.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da43a810ca70d16ba1a53e4e28c9701e1708d5ee/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da43a810ca70d16ba1a53e4e28c9701e1708d5ee/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=da43a810ca70d16ba1a53e4e28c9701e1708d5ee", "patch": "@@ -2805,8 +2805,7 @@ duplicate_loop_exit_test (loop_start)\n \t    remove_note (insn, p);\n \t  if (++num_insns > 20\n \t      || find_reg_note (insn, REG_RETVAL, NULL_RTX)\n-\t      || find_reg_note (insn, REG_LIBCALL, NULL_RTX)\n-\t      || asm_noperands (PATTERN (insn)) > 0)\n+\t      || find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n \t    return 0;\n \t  break;\n \tdefault:\n@@ -2869,7 +2868,7 @@ duplicate_loop_exit_test (loop_start)\n \t  break;\n \t  \n \tcase INSN:\n-\t  copy = emit_insn_before (copy_rtx (PATTERN (insn)), loop_start);\n+\t  copy = emit_insn_before (copy_insn (PATTERN (insn)), loop_start);\n \t  if (reg_map)\n \t    replace_regs (PATTERN (copy), reg_map, max_reg, 1);\n \t  \n@@ -2880,21 +2879,21 @@ duplicate_loop_exit_test (loop_start)\n \t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n \t    if (REG_NOTE_KIND (link) != REG_LABEL)\n \t      REG_NOTES (copy)\n-\t\t= copy_rtx (gen_rtx_EXPR_LIST (REG_NOTE_KIND (link),\n+\t\t= copy_insn_1 (gen_rtx_EXPR_LIST (REG_NOTE_KIND (link),\n \t\t\t\t\t       XEXP (link, 0),\n \t\t\t\t\t       REG_NOTES (copy)));\n \t  if (reg_map && REG_NOTES (copy))\n \t    replace_regs (REG_NOTES (copy), reg_map, max_reg, 1);\n \t  break;\n \t  \n \tcase JUMP_INSN:\n-\t  copy = emit_jump_insn_before (copy_rtx (PATTERN (insn)), loop_start);\n+\t  copy = emit_jump_insn_before (copy_insn (PATTERN (insn)), loop_start);\n \t  if (reg_map)\n \t    replace_regs (PATTERN (copy), reg_map, max_reg, 1);\n \t  mark_jump_label (PATTERN (copy), copy, 0);\n \t  if (REG_NOTES (insn))\n \t    {\n-\t      REG_NOTES (copy) = copy_rtx (REG_NOTES (insn));\n+\t      REG_NOTES (copy) = copy_insn_1 (REG_NOTES (insn));\n \t      if (reg_map)\n \t\treplace_regs (REG_NOTES (copy), reg_map, max_reg, 1);\n \t    }"}, {"sha": "5f3e68983dc22b21a812384213aa199b48af6353", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da43a810ca70d16ba1a53e4e28c9701e1708d5ee/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da43a810ca70d16ba1a53e4e28c9701e1708d5ee/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=da43a810ca70d16ba1a53e4e28c9701e1708d5ee", "patch": "@@ -974,6 +974,8 @@ extern char *oballoc\t\t\tPROTO((int));\n extern char *permalloc\t\t\tPROTO((int));\n extern rtx rtx_alloc\t\t\tPROTO((RTX_CODE));\n extern rtvec rtvec_alloc\t\tPROTO((int));\n+extern rtx copy_insn_1\t\t\tPROTO((rtx));\n+extern rtx copy_insn\t\t\tPROTO((rtx));\n extern rtx copy_rtx\t\t\tPROTO((rtx));\n extern rtx copy_rtx_if_shared\t\tPROTO((rtx));\n extern rtx copy_most_rtx\t\tPROTO((rtx, rtx));"}]}