{"sha": "aa2408185d5f199d04096862d061a0671d42b626", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEyNDA4MTg1ZDVmMTk5ZDA0MDk2ODYyZDA2MWEwNjcxZDQyYjYyNg==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@merlin.codesourcery.com", "date": "2001-08-10T15:47:22Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2001-08-10T15:47:22Z"}, "message": "std_limits.h: New file.\n\n2001-08-10  Gabriel Dos Reis  <gdr@merlin.codesourcery.com>\n            Mark Mitchell     <mark@codesourcery.com>\n\n        * include/bits/std_limits.h: New file.\n        * include/Makefile.am (bits_headers): Add std_limits.h\n        (all-local): std_limits.h is no longer built.\n        (${target_builddir}/std_limits.h): Remove.\n        * include/Makefile.in: Regenerate.\n        * src/limits.cc: New file.\n        * src/Makefile.am (sources): Add limits.cc in replacement of\n        limitsMEMBERS.cc.\n        * src/Makefile.in: Regenerate.\n\nFrom-SVN: r44766", "tree": {"sha": "6c5568ee836add8e22773f7faefc897da91af942", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c5568ee836add8e22773f7faefc897da91af942"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa2408185d5f199d04096862d061a0671d42b626", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa2408185d5f199d04096862d061a0671d42b626", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa2408185d5f199d04096862d061a0671d42b626", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa2408185d5f199d04096862d061a0671d42b626/comments", "author": null, "committer": null, "parents": [{"sha": "c914d981974b4c6188035023ff084921d8275031", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c914d981974b4c6188035023ff084921d8275031", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c914d981974b4c6188035023ff084921d8275031"}], "stats": {"total": 2457, "additions": 2427, "deletions": 30}, "files": [{"sha": "2a4b148cb745d183680faf38677646f2f59a2803", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2408185d5f199d04096862d061a0671d42b626/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2408185d5f199d04096862d061a0671d42b626/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=aa2408185d5f199d04096862d061a0671d42b626", "patch": "@@ -1,3 +1,20 @@\n+2001-08-10  Gabriel Dos Reis  <gdr@merlin.codesourcery.com>\n+\n+\t* include/bits/std_limits.h: New file.\n+\t* include/Makefile.am (bits_headers): Add std_limits.h\n+\t(all-local): std_limits.h is no longer built.\n+\t(${target_builddir}/std_limits.h): Remove.\n+\t* include/Makefile.in: Regenerate.\n+\t* src/limits.cc: New file.\n+\t* src/Makefile.am (sources): Add limits.cc in replacement of\n+\tlimitsMEMBERS.cc.\n+\t* src/Makefile.in: Regenerate.\n+\n+\n+2001-08-09  Gabriel Dos Reis  <gdr@merlin.codesourcery.com>\n+\n+\t* src/gen-num-limits.cc (digits10): Fix thinko.\n+\n 2001-08-09  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* po/Makefile.am (check-no): Add."}, {"sha": "91931d3d719b22dded3b5d3e3baac3f1485ca922", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2408185d5f199d04096862d061a0671d42b626/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2408185d5f199d04096862d061a0671d42b626/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=aa2408185d5f199d04096862d061a0671d42b626", "patch": "@@ -21,7 +21,7 @@\n ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n ## USA.\n \n-## $Id: Makefile.am,v 1.1 2001/07/13 16:47:55 pme Exp $\n+## $Id: Makefile.am,v 1.2 2001/08/08 02:48:59 bkoz Exp $\n \n AUTOMAKE_OPTIONS = 1.3 gnits\n MAINT_CHARSET = latin1\n@@ -78,6 +78,7 @@ bits_headers = \\\n \t${bits_srcdir}/std_iostream.h \\\n \t${bits_srcdir}/std_istream.h \\\n \t${bits_srcdir}/std_iterator.h \\\n+\t${bits_srcdir}/std_limits.h \\\n \t${bits_srcdir}/std_list.h \\\n \t${bits_srcdir}/std_locale.h \\\n \t${bits_srcdir}/std_map.h \\\n@@ -305,7 +306,6 @@ CLEANFILES = ${allstamps}\n # Here are the rules for building the headers\n all-local: \\\n \t${target_builddir}/c++config.h \\\n-\t${target_builddir}/std_limits.h \\\n \t${allstamps}\n \n stamp-std: ${std_headers}\n@@ -402,15 +402,6 @@ ${target_builddir}/c++config.h: ${glibcpp_builddir}/config.h \\\n \t    < ${glibcpp_builddir}/config.h >> $@ ;\\\n \techo \"#endif // _CPP_CPPCONFIG_\" >>$@\n \n-# This tool leaves the header in the wrong place, but rather than fix the\n-# tool, the destination get massaged here.\n-${target_builddir}/std_limits.h: ${target_builddir}/c++config.h \\\n-\t\t\t\t stamp-target ${target_builddir}\n-\tCC=\"$(CC) -I${glibcpp_builddir} -I${target_builddir}/..\" \\\n-\t${glibcpp_srcdir}/mknumeric_limits \\\n-\t${glibcpp_builddir} ${glibcpp_srcdir} @GLIBCPP_IS_CROSS_COMPILING@ ;\\\n-\tmv ${glibcpp_builddir}/include/bits/std_limits.h ${target_builddir}\n-\n glibcpp_thread_h = @glibcpp_thread_h@\n uppercase = [ABCDEFGHIJKLMNOPQRSTUVWXYZ_]\n "}, {"sha": "bf72ef58fe5493606d8fb9b34c12f6c2d34bf66a", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2408185d5f199d04096862d061a0671d42b626/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2408185d5f199d04096862d061a0671d42b626/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=aa2408185d5f199d04096862d061a0671d42b626", "patch": "@@ -154,7 +154,7 @@ glibcpp_builddir = @glibcpp_builddir@\n \n bits_srcdir = ${glibcpp_srcdir}/include/bits\n bits_builddir = ./bits\n-bits_headers =  \t${bits_srcdir}/basic_file.h \t${bits_srcdir}/basic_ios.h \t${bits_srcdir}/basic_ios.tcc \t${bits_srcdir}/basic_string.h \t${bits_srcdir}/basic_string.tcc \t${bits_srcdir}/boost_concept_check.h \t${bits_srcdir}/char_traits.h \t${bits_srcdir}/codecvt.h \t${bits_srcdir}/concept_check.h \t${bits_srcdir}/cpp_type_traits.h \t${bits_srcdir}/fpos.h \t${bits_srcdir}/fstream.tcc \t${bits_srcdir}/functexcept.h \t${bits_srcdir}/generic_shadow.h \t${bits_srcdir}/gslice.h \t${bits_srcdir}/gslice_array.h \t${bits_srcdir}/indirect_array.h \t${bits_srcdir}/ios_base.h \t${bits_srcdir}/istream.tcc \t${bits_srcdir}/locale_facets.h \t${bits_srcdir}/locale_facets.tcc \t${bits_srcdir}/localefwd.h \t${bits_srcdir}/mask_array.h \t${bits_srcdir}/ostream.tcc \t${bits_srcdir}/pthread_allocimpl.h \t${bits_srcdir}/stream_iterator.h \t${bits_srcdir}/streambuf_iterator.h \t${bits_srcdir}/slice.h \t${bits_srcdir}/slice_array.h \t${bits_srcdir}/sstream.tcc \t${bits_srcdir}/std_algorithm.h \t${bits_srcdir}/std_bitset.h \t${bits_srcdir}/std_complex.h \t${bits_srcdir}/std_deque.h \t${bits_srcdir}/std_fstream.h \t${bits_srcdir}/std_functional.h \t${bits_srcdir}/std_iomanip.h \t${bits_srcdir}/std_ios.h \t${bits_srcdir}/std_iosfwd.h \t${bits_srcdir}/std_iostream.h \t${bits_srcdir}/std_istream.h \t${bits_srcdir}/std_iterator.h \t${bits_srcdir}/std_list.h \t${bits_srcdir}/std_locale.h \t${bits_srcdir}/std_map.h \t${bits_srcdir}/std_memory.h \t${bits_srcdir}/std_numeric.h \t${bits_srcdir}/std_ostream.h \t${bits_srcdir}/std_queue.h \t${bits_srcdir}/std_set.h \t${bits_srcdir}/std_sstream.h \t${bits_srcdir}/std_stack.h \t${bits_srcdir}/std_stdexcept.h \t${bits_srcdir}/std_streambuf.h \t${bits_srcdir}/std_string.h \t${bits_srcdir}/std_utility.h \t${bits_srcdir}/std_valarray.h \t${bits_srcdir}/std_vector.h \t${bits_srcdir}/stl_algo.h \t${bits_srcdir}/stl_algobase.h \t${bits_srcdir}/stl_alloc.h \t${bits_srcdir}/stl_bvector.h \t${bits_srcdir}/stl_construct.h \t${bits_srcdir}/stl_deque.h \t${bits_srcdir}/stl_function.h \t${bits_srcdir}/stl_heap.h \t${bits_srcdir}/stl_iterator.h \t${bits_srcdir}/stl_iterator_base_funcs.h \t${bits_srcdir}/stl_iterator_base_types.h \t${bits_srcdir}/stl_list.h \t${bits_srcdir}/stl_map.h \t${bits_srcdir}/stl_multimap.h \t${bits_srcdir}/stl_multiset.h \t${bits_srcdir}/stl_numeric.h \t${bits_srcdir}/stl_pair.h \t${bits_srcdir}/stl_pthread_alloc.h \t${bits_srcdir}/stl_queue.h \t${bits_srcdir}/stl_raw_storage_iter.h \t${bits_srcdir}/stl_relops.h \t${bits_srcdir}/stl_set.h \t${bits_srcdir}/stl_stack.h \t${bits_srcdir}/stl_tempbuf.h \t${bits_srcdir}/stl_threads.h \t${bits_srcdir}/stl_tree.h \t${bits_srcdir}/stl_uninitialized.h \t${bits_srcdir}/stl_vector.h \t${bits_srcdir}/streambuf.tcc \t${bits_srcdir}/stringfwd.h \t${bits_srcdir}/type_traits.h \t${bits_srcdir}/valarray_array.h \t${bits_srcdir}/valarray_array.tcc \t${bits_srcdir}/valarray_meta.h\n+bits_headers =  \t${bits_srcdir}/basic_file.h \t${bits_srcdir}/basic_ios.h \t${bits_srcdir}/basic_ios.tcc \t${bits_srcdir}/basic_string.h \t${bits_srcdir}/basic_string.tcc \t${bits_srcdir}/boost_concept_check.h \t${bits_srcdir}/char_traits.h \t${bits_srcdir}/codecvt.h \t${bits_srcdir}/concept_check.h \t${bits_srcdir}/cpp_type_traits.h \t${bits_srcdir}/fpos.h \t${bits_srcdir}/fstream.tcc \t${bits_srcdir}/functexcept.h \t${bits_srcdir}/generic_shadow.h \t${bits_srcdir}/gslice.h \t${bits_srcdir}/gslice_array.h \t${bits_srcdir}/indirect_array.h \t${bits_srcdir}/ios_base.h \t${bits_srcdir}/istream.tcc \t${bits_srcdir}/locale_facets.h \t${bits_srcdir}/locale_facets.tcc \t${bits_srcdir}/localefwd.h \t${bits_srcdir}/mask_array.h \t${bits_srcdir}/ostream.tcc \t${bits_srcdir}/pthread_allocimpl.h \t${bits_srcdir}/stream_iterator.h \t${bits_srcdir}/streambuf_iterator.h \t${bits_srcdir}/slice.h \t${bits_srcdir}/slice_array.h \t${bits_srcdir}/sstream.tcc \t${bits_srcdir}/std_algorithm.h \t${bits_srcdir}/std_bitset.h \t${bits_srcdir}/std_complex.h \t${bits_srcdir}/std_deque.h \t${bits_srcdir}/std_fstream.h \t${bits_srcdir}/std_functional.h \t${bits_srcdir}/std_iomanip.h \t${bits_srcdir}/std_ios.h \t${bits_srcdir}/std_iosfwd.h \t${bits_srcdir}/std_iostream.h \t${bits_srcdir}/std_istream.h \t${bits_srcdir}/std_iterator.h \t${bits_srcdir}/std_limits.h \t${bits_srcdir}/std_list.h \t${bits_srcdir}/std_locale.h \t${bits_srcdir}/std_map.h \t${bits_srcdir}/std_memory.h \t${bits_srcdir}/std_numeric.h \t${bits_srcdir}/std_ostream.h \t${bits_srcdir}/std_queue.h \t${bits_srcdir}/std_set.h \t${bits_srcdir}/std_sstream.h \t${bits_srcdir}/std_stack.h \t${bits_srcdir}/std_stdexcept.h \t${bits_srcdir}/std_streambuf.h \t${bits_srcdir}/std_string.h \t${bits_srcdir}/std_utility.h \t${bits_srcdir}/std_valarray.h \t${bits_srcdir}/std_vector.h \t${bits_srcdir}/stl_algo.h \t${bits_srcdir}/stl_algobase.h \t${bits_srcdir}/stl_alloc.h \t${bits_srcdir}/stl_bvector.h \t${bits_srcdir}/stl_construct.h \t${bits_srcdir}/stl_deque.h \t${bits_srcdir}/stl_function.h \t${bits_srcdir}/stl_heap.h \t${bits_srcdir}/stl_iterator.h \t${bits_srcdir}/stl_iterator_base_funcs.h \t${bits_srcdir}/stl_iterator_base_types.h \t${bits_srcdir}/stl_list.h \t${bits_srcdir}/stl_map.h \t${bits_srcdir}/stl_multimap.h \t${bits_srcdir}/stl_multiset.h \t${bits_srcdir}/stl_numeric.h \t${bits_srcdir}/stl_pair.h \t${bits_srcdir}/stl_pthread_alloc.h \t${bits_srcdir}/stl_queue.h \t${bits_srcdir}/stl_raw_storage_iter.h \t${bits_srcdir}/stl_relops.h \t${bits_srcdir}/stl_set.h \t${bits_srcdir}/stl_stack.h \t${bits_srcdir}/stl_tempbuf.h \t${bits_srcdir}/stl_threads.h \t${bits_srcdir}/stl_tree.h \t${bits_srcdir}/stl_uninitialized.h \t${bits_srcdir}/stl_vector.h \t${bits_srcdir}/streambuf.tcc \t${bits_srcdir}/stringfwd.h \t${bits_srcdir}/type_traits.h \t${bits_srcdir}/valarray_array.h \t${bits_srcdir}/valarray_array.tcc \t${bits_srcdir}/valarray_meta.h\n \n \n backward_srcdir = ${glibcpp_srcdir}/include/backward\n@@ -308,7 +308,6 @@ mostlyclean distclean maintainer-clean\n # Here are the rules for building the headers\n all-local: \\\n \t${target_builddir}/c++config.h \\\n-\t${target_builddir}/std_limits.h \\\n \t${allstamps}\n \n stamp-std: ${std_headers}\n@@ -405,15 +404,6 @@ ${target_builddir}/c++config.h: ${glibcpp_builddir}/config.h \\\n \t    < ${glibcpp_builddir}/config.h >> $@ ;\\\n \techo \"#endif // _CPP_CPPCONFIG_\" >>$@\n \n-# This tool leaves the header in the wrong place, but rather than fix the\n-# tool, the destination get massaged here.\n-${target_builddir}/std_limits.h: ${target_builddir}/c++config.h \\\n-\t\t\t\t stamp-target ${target_builddir}\n-\tCC=\"$(CC) -I${glibcpp_builddir} -I${target_builddir}/..\" \\\n-\t${glibcpp_srcdir}/mknumeric_limits \\\n-\t${glibcpp_builddir} ${glibcpp_srcdir} @GLIBCPP_IS_CROSS_COMPILING@ ;\\\n-\tmv ${glibcpp_builddir}/include/bits/std_limits.h ${target_builddir}\n-\n ${thread_builddir}/gthr.h:\n \tsed -e '/^#/s/\\(${uppercase}${uppercase}*\\)/_GLIBCPP_\\1/g' \\\n \t    -e 's,^#include \"\\(.*\\)\",#include <bits/\\1>,g' \\"}, {"sha": "6c0e5d6521a1e245cd29c8d23828913ea4f5793d", "filename": "libstdc++-v3/include/bits/std_limits.h", "status": "added", "additions": 1970, "deletions": 0, "changes": 1970, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2408185d5f199d04096862d061a0671d42b626/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_limits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2408185d5f199d04096862d061a0671d42b626/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_limits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_limits.h?ref=aa2408185d5f199d04096862d061a0671d42b626", "patch": "@@ -0,0 +1,1970 @@\n+// The template and inlines for the -*- C++ -*- numeric_limits classes.\n+\n+// Copyright (C) 1999-2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Note: this is not a conforming implementation.\n+// Written by Gabriel Dos Reis <gdr@codesourcery.com>\n+\n+//\n+// ISO 14882:1998\n+// 18.2.1\n+//\n+\n+#ifndef _CPP_NUMERIC_LIMITS\n+#define _CPP_NUMERIC_LIMITS 1\n+\n+#pragma GCC system_header\n+\n+#include <bits/c++config.h>\n+\n+//\n+// The numeric_limits<> traits document implementation-defined aspects\n+// of fundamental arithmetic data types (integers and floating points).\n+// From Standard C++ point of view, there are 13 such types:\n+//   * integers\n+//         bool\t\t\t\t\t\t        (1)\n+//         char, signed char, unsigned char\t\t\t(3)\n+//         short, unsigned short\t\t\t\t(2)\n+//         int, unsigned\t\t\t\t\t(2)\n+//         long, unsigned long\t\t\t\t\t(2)\n+//\n+//   * floating points\n+//         float\t\t\t\t\t\t(1)\n+//         double\t\t\t\t\t\t(1)\n+//         long double\t\t\t\t\t\t(1)\n+//\n+// GNU C++ undertstands (where supported by the host C-library) \n+//   * integer\n+//         long long, unsigned long long\t\t\t(2)\n+//\n+// which brings us to 15 fundamental arithmetic data types in GNU C++.\n+//\n+// \n+// Since a numeric_limits<> is a bit tricky to get right, we rely on\n+// an interface composed of macros which should be defined in config/os\n+// or config/cpu when they differ from the generic (read arbitrary)\n+// definitions given here.\n+//\n+\n+// These values can be overridden in the target configuration file.\n+// The default values are appropriate for many 32-bit targets.\n+\n+#ifndef __glibcpp_char_bits\n+#define __glibcpp_char_bits 8\n+#endif\n+#ifndef __glibcpp_plain_char_is_signed\n+#define __glibcpp_plain_char_is_signed true\n+#endif\n+#ifndef __glibcpp_short_bits\n+#define __glibcpp_short_bits 16\n+#endif\n+#ifndef __glibcpp_int_bits\n+#define __glibcpp_int_bits 32\n+#endif\n+#ifndef __glibcpp_long_bits\n+#define __glibcpp_long_bits 32\n+#endif\n+#ifndef __glibcpp_wchar_t_bits\n+#define __glibcpp_wchar_t_bits 32\n+#endif\n+#ifndef __glibcpp_wchar_t_is_signed\n+#define __glibcpp_wchar_t_is_signed __glibcpp_plain_char_is_signed\n+#endif\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+#ifndef __glibcpp_long_long_bits\n+#define __glibcpp_long_long_bits 64\n+#endif\n+#endif\n+#ifndef __glibcpp_float_bits\n+#define __glibcpp_float_bits 32\n+#endif\n+#ifndef __glibcpp_double_bits\n+#define __glibcpp_double_bits 64\n+#endif\n+#ifndef __glibcpp_long_double_bits\n+#define __glibcpp_long_double_bits 128\n+#endif\n+\n+#ifndef __glibcpp_char_traps\n+#define __glibcpp_char_traps true\n+#endif\n+#ifndef __glibcpp_short_traps\n+#define __glibcpp_short_traps true\n+#endif\n+#ifndef __glibcpp_int_traps\n+#define __glibcpp_int_traps true\n+#endif\n+#ifndef __glibcpp_long_traps\n+#define __glibcpp_long_traps true\n+#endif\n+#ifndef __glibcpp_wchar_t_traps\n+#define __glibcpp_wchar_t_traps true\n+#endif\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+#ifndef __glibcpp_long_long_traps\n+#define __glibcpp_long_long_traps true\n+#endif\n+#endif\n+\n+// You should not need to define any macros below this point, unless\n+// you have a machine with non-standard bit-widths.\n+\n+// These values are the minimums and maximums for standard data types\n+// of common widths.\n+\n+#define __glibcpp_s8_max 127\n+#define __glibcpp_s8_min (-__glibcpp_s8_max - 1)\n+#define __glibcpp_s8_digits 7\n+#define __glibcpp_s8_digits10 3\n+#define __glibcpp_u8_min 0U\n+#define __glibcpp_u8_max (__glibcpp_s8_max * 2 + 1)\n+#define __glibcpp_u8_digits 8\n+#define __glibcpp_u8_digits10 3\n+#define __glibcpp_s16_max 32767\n+#define __glibcpp_s16_min (-__glibcpp_s16_max - 1)\n+#define __glibcpp_s16_digits 15\n+#define __glibcpp_s16_digits10 5\n+#define __glibcpp_u16_min 0U\n+#define __glibcpp_u16_max (__glibcpp_s16_max * 2 + 1)\n+#define __glibcpp_u16_digits 16\n+#define __glibcpp_u16_digits10 5\n+#define __glibcpp_s32_max 2147483647L\n+#define __glibcpp_s32_min (-__glibcpp_s32_max - 1)\n+#define __glibcpp_s32_digits 31\n+#define __glibcpp_s32_digits10 10\n+#define __glibcpp_u32_min 0UL\n+#define __glibcpp_u32_max (__glibcpp_s32_max * 2U + 1)\n+#define __glibcpp_u32_digits 32\n+#define __glibcpp_u32_digits10 10\n+#define __glibcpp_s64_max 9223372036854775807LL\n+#define __glibcpp_s64_min (-__glibcpp_s64_max - 1)\n+#define __glibcpp_s64_digits 63\n+#define __glibcpp_s64_digits10 19\n+#define __glibcpp_u64_min 0ULL\n+#define __glibcpp_u64_max (__glibcpp_s64_max * 2ULL + 1)\n+#define __glibcpp_u64_digits 64\n+#define __glibcpp_u64_digits10 19\n+\n+#define __glibcpp_f32_min 1.17549435e-38F\n+#define __glibcpp_f32_max 3.40282347e+38F\n+#define __glibcpp_f32_digits 24\n+#define __glibcpp_f32_digits10 7\n+#define __glibcpp_f32_radix 2\n+#define __glibcpp_f32_epsilon 1.19209290e-07F\n+#define __glibcpp_f32_round_error 1.0F\n+#define __glibcpp_f32_min_exponent -125\n+#define __glibcpp_f32_min_exponent10 -37\n+#define __glibcpp_f32_max_exponent 128\n+#define __glibcpp_f32_max_exponent10 38\n+#define __glibcpp_f64_min 2.2250738585072014e-308\n+#define __glibcpp_f64_max 1.7976931348623157e+308\n+#define __glibcpp_f64_digits 53\n+#define __glibcpp_f64_digits10 15\n+#define __glibcpp_f64_radix 2\n+#define __glibcpp_f64_epsilon 2.2204460492503131e-16\n+#define __glibcpp_f64_round_error 1.0\n+#define __glibcpp_f64_min_exponent -1021\n+#define __glibcpp_f64_min_exponent10 -307\n+#define __glibcpp_f64_max_exponent 1024\n+#define __glibcpp_f64_max_exponent10 308\n+#define __glibcpp_f80_min 3.36210314311209350626e-4932L\n+#define __glibcpp_f80_max 1.18973149535723176502e+4932L\n+#define __glibcpp_f80_digits 64\n+#define __glibcpp_f80_digits10 19\n+#define __glibcpp_f80_radix 2\n+#define __glibcpp_f80_epsilon 1.08420217248550443401e-19L\n+#define __glibcpp_f80_round_error 1.0L\n+#define __glibcpp_f80_min_exponent -16381\n+#define __glibcpp_f80_min_exponent10 -4931\n+#define __glibcpp_f80_max_exponent 16384\n+#define __glibcpp_f80_max_exponent10 4932\n+#define __glibcpp_f128_min 3.362103143112093506262677817321752603E-4932L\n+#define __glibcpp_f128_max 1.189731495357231765085759326628007016E+4932L\n+#define __glibcpp_f128_digits 113\n+#define __glibcpp_f128_digits10 34\n+#define __glibcpp_f128_radix 2\n+#define __glibcpp_f128_epsilon 1.925929944387235853055977942584927319E-34L\n+#define __glibcpp_f128_round_error 1.0L\n+#define __glibcpp_f128_min_exponent -16381\n+#define __glibcpp_f128_min_exponent10 -4931\n+#define __glibcpp_f128_max_exponent 16384\n+#define __glibcpp_f128_max_exponent10 4932\n+\n+// bool-specific hooks:\n+//     __glibcpp_bool_digits  __glibcpp_int_traps __glibcpp_long_traps\n+\n+// This is actually CHAR_BITS because the new ABI says a bool\n+// is one (1) byte wide.\n+\n+#ifndef __glibcpp_bool_digits\n+#define __glibcpp_bool_digits __glibcpp_char_bits\n+#endif\n+\n+// char.\n+\n+#define __glibcpp_plain_char_traps true\n+#define __glibcpp_signed_char_traps true\n+#define __glibcpp_unsigned_char_traps true\n+#if __glibcpp_char_bits == 8\n+#define __glibcpp_signed_char_min __glibcpp_s8_min\n+#define __glibcpp_signed_char_max __glibcpp_s8_max\n+#define __glibcpp_signed_char_digits __glibcpp_s8_digits\n+#define __glibcpp_signed_char_digits10 __glibcpp_s8_digits10\n+#define __glibcpp_unsigned_char_min __glibcpp_u8_min\n+#define __glibcpp_unsigned_char_max __glibcpp_u8_max\n+#define __glibcpp_unsigned_char_digits __glibcpp_u8_digits\n+#define __glibcpp_unsigned_char_digits10 __glibcpp_u8_digits10\n+#elif __glibcpp_char_bits == 16\n+#define __glibcpp_signed_char_min __glibcpp_s16_min\n+#define __glibcpp_signed_char_max __glibcpp_s16_max\n+#define __glibcpp_signed_char_digits __glibcpp_s16_digits\n+#define __glibcpp_signed_char_digits10 __glibcpp_s16_digits10\n+#define __glibcpp_unsigned_char_min __glibcpp_u16_min\n+#define __glibcpp_unsigned_char_max __glibcpp_u16_max\n+#define __glibcpp_unsigned_char_digits __glibcpp_u16_digits\n+#define __glibcpp_unsigned_char_digits10 __glibcpp_u16_digits10\n+#elif __glibcpp_char_bits == 32\n+#define __glibcpp_signed_char_min (signed char)__glibcpp_s32_min\n+#define __glibcpp_signed_char_max (signed char)__glibcpp_s32_max\n+#define __glibcpp_signed_char_digits __glibcpp_s32_digits\n+#define __glibcpp_signed_char_digits10 __glibcpp_s32_digits10\n+#define __glibcpp_unsigned_char_min (unsigned char)__glibcpp_u32_min\n+#define __glibcpp_unsigned_char_max (unsigned char)__glibcpp_u32_max\n+#define __glibcpp_unsigned_char_digits __glibcpp_u32_digits\n+#define __glibcpp_unsigned_char_digits10 __glibcpp_u32_digits10\n+#elif __glibcpp_char_bits == 64\n+#define __glibcpp_signed_char_min (signed char)__glibcpp_s64_min\n+#define __glibcpp_signed_char_max (signed char)__glibcpp_s64_max\n+#define __glibcpp_signed_char_digits __glibcpp_s64_digits\n+#define __glibcpp_signed_char_digits10 __glibcpp_s64_digits10\n+#define __glibcpp_unsigned_char_min (unsigned char)__glibcpp_u64_min\n+#define __glibcpp_unsigned_char_max (unsigned char)__glibcpp_u64_max\n+#define __glibcpp_unsigned_char_digits __glibcpp_u64_digits\n+#define __glibcpp_unsigned_char_digits10 __glibcpp_u64_digits10\n+#else\n+// You must define these macros in the configuration file.\n+#endif\n+\n+#if __glibcpp_plain_char_is_signed\n+#define __glibcpp_char_min (char)__glibcpp_signed_char_min\n+#define __glibcpp_char_max (char)__glibcpp_signed_char_max\n+#define __glibcpp_char_digits __glibcpp_signed_char_digits\n+#define __glibcpp_char_digits10 __glibcpp_signed_char_digits\n+#else\n+#define __glibcpp_char_min (char)__glibcpp_unsigned_char_min\n+#define __glibcpp_char_max (char)__glibcpp_unsigned_char_max\n+#define __glibcpp_char_digits __glibcpp_unsigned_char_digits\n+#define __glibcpp_char_digits10 __glibcpp_unsigned_char_digits\n+#endif\n+\n+// short\n+\n+#define __glibcpp_signed_short_traps true\n+#define __glibcpp_unsigned_short_traps true\n+#if __glibcpp_short_bits == 8\n+#define __glibcpp_signed_short_min __glibcpp_s8_min\n+#define __glibcpp_signed_short_max __glibcpp_s8_max\n+#define __glibcpp_signed_short_digits __glibcpp_s8_digits\n+#define __glibcpp_signed_short_digits10 __glibcpp_s8_digits10\n+#define __glibcpp_unsigned_short_min __glibcpp_u8_min\n+#define __glibcpp_unsigned_short_max __glibcpp_u8_max\n+#define __glibcpp_unsigned_short_digits __glibcpp_u8_digits\n+#define __glibcpp_unsigned_short_digits10 __glibcpp_u8_digits10\n+#elif __glibcpp_short_bits == 16\n+#define __glibcpp_signed_short_min __glibcpp_s16_min\n+#define __glibcpp_signed_short_max __glibcpp_s16_max\n+#define __glibcpp_signed_short_digits __glibcpp_s16_digits\n+#define __glibcpp_signed_short_digits10 __glibcpp_s16_digits10\n+#define __glibcpp_unsigned_short_min __glibcpp_u16_min\n+#define __glibcpp_unsigned_short_max __glibcpp_u16_max\n+#define __glibcpp_unsigned_short_digits __glibcpp_u16_digits\n+#define __glibcpp_unsigned_short_digits10 __glibcpp_u16_digits10\n+#elif __glibcpp_short_bits == 32\n+#define __glibcpp_signed_short_min (short)__glibcpp_s32_min\n+#define __glibcpp_signed_short_max (short)__glibcpp_s32_max\n+#define __glibcpp_signed_short_digits __glibcpp_s32_digits\n+#define __glibcpp_signed_short_digits10 __glibcpp_s32_digits10\n+#define __glibcpp_unsigned_short_min (unsigned short)__glibcpp_u32_min\n+#define __glibcpp_unsigned_short_max (unsigned short)__glibcpp_u32_max\n+#define __glibcpp_unsigned_short_digits __glibcpp_u32_digits\n+#define __glibcpp_unsigned_short_digits10 __glibcpp_u32_digits10\n+#elif __glibcpp_short_bits == 64\n+#define __glibcpp_signed_short_min (short)__glibcpp_s64_min\n+#define __glibcpp_signed_short_max (short)__glibcpp_s64_max\n+#define __glibcpp_signed_short_digits __glibcpp_s64_digits\n+#define __glibcpp_signed_short_digits10 __glibcpp_s64_digits10\n+#define __glibcpp_unsigned_short_min (unsigned short)__glibcpp_u64_min\n+#define __glibcpp_unsigned_short_max (unsigned short)__glibcpp_u64_max\n+#define __glibcpp_unsigned_short_digits __glibcpp_u64_digits\n+#define __glibcpp_unsigned_short_digits10 __glibcpp_u64_digits10\n+#else\n+// You must define these macros in the configuration file.\n+#endif\n+\n+// int\n+\n+#define __glibcpp_signed_int_traps true\n+#define __glibcpp_unsigned_int_traps true\n+#if __glibcpp_int_bits == 8\n+#define __glibcpp_signed_int_min __glibcpp_s8_min\n+#define __glibcpp_signed_int_max __glibcpp_s8_max\n+#define __glibcpp_signed_int_digits __glibcpp_s8_digits\n+#define __glibcpp_signed_int_digits10 __glibcpp_s8_digits10\n+#define __glibcpp_unsigned_int_min __glibcpp_u8_min\n+#define __glibcpp_unsigned_int_max __glibcpp_u8_max\n+#define __glibcpp_unsigned_int_digits __glibcpp_u8_digits\n+#define __glibcpp_unsigned_int_digits10 __glibcpp_u8_digits10\n+#elif __glibcpp_int_bits == 16\n+#define __glibcpp_signed_int_min __glibcpp_s16_min\n+#define __glibcpp_signed_int_max __glibcpp_s16_max\n+#define __glibcpp_signed_int_digits __glibcpp_s16_digits\n+#define __glibcpp_signed_int_digits10 __glibcpp_s16_digits10\n+#define __glibcpp_unsigned_int_min __glibcpp_u16_min\n+#define __glibcpp_unsigned_int_max __glibcpp_u16_max\n+#define __glibcpp_unsigned_int_digits __glibcpp_u16_digits\n+#define __glibcpp_unsigned_int_digits10 __glibcpp_u16_digits10\n+#elif __glibcpp_int_bits == 32\n+#define __glibcpp_signed_int_min (int)__glibcpp_s32_min\n+#define __glibcpp_signed_int_max (int)__glibcpp_s32_max\n+#define __glibcpp_signed_int_digits __glibcpp_s32_digits\n+#define __glibcpp_signed_int_digits10 __glibcpp_s32_digits10\n+#define __glibcpp_unsigned_int_min (unsigned)__glibcpp_u32_min\n+#define __glibcpp_unsigned_int_max (unsigned)__glibcpp_u32_max\n+#define __glibcpp_unsigned_int_digits __glibcpp_u32_digits\n+#define __glibcpp_unsigned_int_digits10 __glibcpp_u32_digits10\n+#elif __glibcpp_int_bits == 64\n+#define __glibcpp_signed_int_min (int)__glibcpp_s64_min\n+#define __glibcpp_signed_int_max (int)__glibcpp_s64_max\n+#define __glibcpp_signed_int_digits __glibcpp_s64_digits\n+#define __glibcpp_signed_int_digits10 __glibcpp_s64_digits10\n+#define __glibcpp_unsigned_int_min (unsigned)__glibcpp_u64_min\n+#define __glibcpp_unsigned_int_max (unsigned)__glibcpp_u64_max\n+#define __glibcpp_unsigned_int_digits __glibcpp_u64_digits\n+#define __glibcpp_unsigned_int_digits10 __glibcpp_u64_digits10\n+#else\n+// You must define these macros in the configuration file.\n+#endif\n+\n+// long\n+\n+#define __glibcpp_signed_long_traps true\n+#define __glibcpp_unsigned_long_traps true\n+#if __glibcpp_long_bits == 8\n+#define __glibcpp_signed_long_min __glibcpp_s8_min\n+#define __glibcpp_signed_long_max __glibcpp_s8_max\n+#define __glibcpp_signed_long_digits __glibcpp_s8_digits\n+#define __glibcpp_signed_long_digits10 __glibcpp_s8_digits10\n+#define __glibcpp_unsigned_long_min __glibcpp_u8_min\n+#define __glibcpp_unsigned_long_max __glibcpp_u8_max\n+#define __glibcpp_unsigned_long_digits __glibcpp_u8_digits\n+#define __glibcpp_unsigned_long_digits10 __glibcpp_u8_digits10\n+#elif __glibcpp_long_bits == 16\n+#define __glibcpp_signed_long_min __glibcpp_s16_min\n+#define __glibcpp_signed_long_max __glibcpp_s16_max\n+#define __glibcpp_signed_long_digits __glibcpp_s16_digits\n+#define __glibcpp_signed_long_digits10 __glibcpp_s16_digits10\n+#define __glibcpp_unsigned_long_min __glibcpp_u16_min\n+#define __glibcpp_unsigned_long_max __glibcpp_u16_max\n+#define __glibcpp_unsigned_long_digits __glibcpp_u16_digits\n+#define __glibcpp_unsigned_long_digits10 __glibcpp_u16_digits10\n+#elif __glibcpp_long_bits == 32\n+#define __glibcpp_signed_long_min __glibcpp_s32_min\n+#define __glibcpp_signed_long_max __glibcpp_s32_max\n+#define __glibcpp_signed_long_digits __glibcpp_s32_digits\n+#define __glibcpp_signed_long_digits10 __glibcpp_s32_digits10\n+#define __glibcpp_unsigned_long_min __glibcpp_u32_min\n+#define __glibcpp_unsigned_long_max __glibcpp_u32_max\n+#define __glibcpp_unsigned_long_digits __glibcpp_u32_digits\n+#define __glibcpp_unsigned_long_digits10 __glibcpp_u32_digits10\n+#elif __glibcpp_long_bits == 64\n+#define __glibcpp_signed_long_min (long)__glibcpp_s64_min\n+#define __glibcpp_signed_long_max (long)__glibcpp_s64_max\n+#define __glibcpp_signed_long_digits __glibcpp_s64_digits\n+#define __glibcpp_signed_long_digits10 __glibcpp_s64_digits10\n+#define __glibcpp_unsigned_long_min (unsigned long)__glibcpp_u64_min\n+#define __glibcpp_unsigned_long_max (unsigned long)__glibcpp_u64_max\n+#define __glibcpp_unsigned_long_digits __glibcpp_u64_digits\n+#define __glibcpp_unsigned_long_digits10 __glibcpp_u64_digits10\n+#else\n+// You must define these macros in the configuration file.\n+#endif\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+\n+// long long\n+\n+#define __glibcpp_signed_long_long_traps true\n+#define __glibcpp_signed_long_long_traps true\n+#if __glibcpp_long_long_bits == 8\n+#define __glibcpp_signed_long_long_min __glibcpp_s8_min\n+#define __glibcpp_signed_long_long_max __glibcpp_s8_max\n+#define __glibcpp_signed_long_long_digits __glibcpp_s8_digits\n+#define __glibcpp_signed_long_long_digits10 __glibcpp_s8_digits10\n+#define __glibcpp_unsigned_long_long_min __glibcpp_u8_min\n+#define __glibcpp_unsigned_long_long_max __glibcpp_u8_max\n+#define __glibcpp_unsigned_long_long_digits __glibcpp_u8_digits\n+#define __glibcpp_unsigned_long_long_digits10 __glibcpp_u8_digits10\n+#elif __glibcpp_long_long_bits == 16\n+#define __glibcpp_signed_long_long_min __glibcpp_s16_min\n+#define __glibcpp_signed_long_long_max __glibcpp_s16_max\n+#define __glibcpp_signed_long_long_digits __glibcpp_s16_digits\n+#define __glibcpp_signed_long_long_digits10 __glibcpp_s16_digits10\n+#define __glibcpp_unsigned_long_long_min __glibcpp_u16_min\n+#define __glibcpp_unsigned_long_long_max __glibcpp_u16_max\n+#define __glibcpp_unsigned_long_long_digits __glibcpp_u16_digits\n+#define __glibcpp_unsigned_long_long_digits10 __glibcpp_u16_digits10\n+#elif __glibcpp_long_long_bits == 32\n+#define __glibcpp_signed_long_long_min __glibcpp_s32_min\n+#define __glibcpp_signed_long_long_max __glibcpp_s32_max\n+#define __glibcpp_signed_long_long_digits __glibcpp_s32_digits\n+#define __glibcpp_signed_long_long_digits10 __glibcpp_s32_digits10\n+#define __glibcpp_unsigned_long_long_min __glibcpp_u32_min\n+#define __glibcpp_unsigned_long_long_max __glibcpp_u32_max\n+#define __glibcpp_unsigned_long_long_digits __glibcpp_u32_digits\n+#define __glibcpp_unsigned_long_long_digits10 __glibcpp_u32_digits10\n+#elif __glibcpp_long_long_bits == 64\n+#define __glibcpp_signed_long_long_min __glibcpp_s64_min\n+#define __glibcpp_signed_long_long_max __glibcpp_s64_max\n+#define __glibcpp_signed_long_long_digits __glibcpp_s64_digits\n+#define __glibcpp_signed_long_long_digits10 __glibcpp_s64_digits10\n+#define __glibcpp_signed_long_long_traps true\n+#define __glibcpp_unsigned_long_long_min __glibcpp_u64_min\n+#define __glibcpp_unsigned_long_long_max __glibcpp_u64_max\n+#define __glibcpp_unsigned_long_long_digits __glibcpp_u64_digits\n+#define __glibcpp_unsigned_long_long_digits10 __glibcpp_u64_digits10\n+#define __glibcpp_unsigned_long_long_traps true\n+#else\n+// You must define these macros in the configuration file.\n+#endif\n+\n+#endif\n+\n+// wchar_t\n+\n+#define __glibcpp_wchar_t_traps true\n+#if __glibcpp_wchar_t_is_signed\n+#if __glibcpp_wchar_t_bits == 8\n+#define __glibcpp_wchar_t_min __glibcpp_s8_min\n+#define __glibcpp_wchar_t_max __glibcpp_s8_max\n+#define __glibcpp_wchar_t_digits __glibcpp_s8_digits\n+#define __glibcpp_wchar_t_digits10 __glibcpp_s8_digits10\n+#elif __glibcpp_wchar_t_bits == 16\n+#define __glibcpp_wchar_t_min __glibcpp_s16_min\n+#define __glibcpp_wchar_t_max __glibcpp_s16_max\n+#define __glibcpp_wchar_t_digits __glibcpp_s16_digits\n+#define __glibcpp_wchar_t_digits10 __glibcpp_s16_digits10\n+#elif __glibcpp_wchar_t_bits == 32\n+#define __glibcpp_wchar_t_min (wchar_t)__glibcpp_s32_min\n+#define __glibcpp_wchar_t_max (wchar_t)__glibcpp_s32_max\n+#define __glibcpp_wchar_t_digits __glibcpp_s32_digits\n+#define __glibcpp_wchar_t_digits10 __glibcpp_s32_digits10\n+#elif __glibcpp_wchar_t_bits == 64\n+#define __glibcpp_wchar_t_min (wchar_t)__glibcpp_s64_min\n+#define __glibcpp_wchar_t_max (wchar_t)__glibcpp_s64_max\n+#define __glibcpp_wchar_t_digits __glibcpp_s64_digits\n+#define __glibcpp_wchar_t_digits10 __glibcpp_s64_digits10\n+#else\n+// You must define these macros in the configuration file.\n+#endif\n+#else\n+#if __glibcpp_wchar_t_bits == 8\n+#define __glibcpp_wchar_t_min __glibcpp_u8_min\n+#define __glibcpp_wchar_t_max __glibcpp_u8_max\n+#define __glibcpp_wchar_t_digits __glibcpp_u8_digits\n+#define __glibcpp_wchar_t_digits10 __glibcpp_u8_digits10\n+#elif __glibcpp_wchar_t_bits == 16\n+#define __glibcpp_wchar_t_min __glibcpp_u16_min\n+#define __glibcpp_wchar_t_max __glibcpp_u16_max\n+#define __glibcpp_wchar_t_digits __glibcpp_u16_digits\n+#define __glibcpp_wchar_t_digits10 __glibcpp_u16_digits10\n+#elif __glibcpp_wchar_t_bits == 32\n+#define __glibcpp_wchar_t_min (wchar_t)__glibcpp_u32_min\n+#define __glibcpp_wchar_t_max (wchar_t)__glibcpp_u32_max\n+#define __glibcpp_wchar_t_digits __glibcpp_u32_digits\n+#define __glibcpp_wchar_t_digits10 __glibcpp_u32_digits10\n+#elif __glibcpp_wchar_t_bits == 64\n+#define __glibcpp_wchar_t_min (wchar_t)__glibcpp_u64_min\n+#define __glibcpp_wchar_t_max (wchar_t)__glibcpp_u64_max\n+#define __glibcpp_wchar_t_digits __glibcpp_u64_digits\n+#define __glibcpp_wchar_t_digits10 __glibcpp_u64_digits10\n+#else\n+// You must define these macros in the configuration file.\n+#endif\n+#endif\n+\n+// float\n+//\n+\n+#if __glibcpp_float_bits == 32\n+#define __glibcpp_float_min __glibcpp_f32_min\n+#define __glibcpp_float_max __glibcpp_f32_max\n+#define __glibcpp_float_digits __glibcpp_f32_digits\n+#define __glibcpp_float_digits10 __glibcpp_f32_digits10\n+#define __glibcpp_float_radix __glibcpp_f32_radix\n+#define __glibcpp_float_epsilon __glibcpp_f32_epsilon\n+#define __glibcpp_float_round_error __glibcpp_f32_round_error\n+#define __glibcpp_float_min_exponent __glibcpp_f32_min_exponent\n+#define __glibcpp_float_min_exponent10 __glibcpp_f32_min_exponent10\n+#define __glibcpp_float_max_exponent __glibcpp_f32_max_exponent\n+#define __glibcpp_float_max_exponent10 __glibcpp_f32_max_exponent10\n+#elif __glibcpp_float_bits == 64\n+#define __glibcpp_float_min __glibcpp_f64_min\n+#define __glibcpp_float_max __glibcpp_f64_max\n+#define __glibcpp_float_digits __glibcpp_f64_digits\n+#define __glibcpp_float_digits10 __glibcpp_f64_digits10\n+#define __glibcpp_float_radix __glibcpp_f64_radix\n+#define __glibcpp_float_epsilon __glibcpp_f64_epsilon\n+#define __glibcpp_float_round_error __glibcpp_f64_round_error\n+#define __glibcpp_float_min_exponent __glibcpp_f64_min_exponent\n+#define __glibcpp_float_min_exponent10 __glibcpp_f64_min_exponent10\n+#define __glibcpp_float_max_exponent __glibcpp_f64_max_exponent\n+#define __glibcpp_float_max_exponent10 __glibcpp_f64_max_exponent10\n+#elif __glibcpp_float_bits == 80\n+#define __glibcpp_float_min __glibcpp_f80_min\n+#define __glibcpp_float_max __glibcpp_f80_max\n+#define __glibcpp_float_digits __glibcpp_f80_digits\n+#define __glibcpp_float_digits10 __glibcpp_f80_digits10\n+#define __glibcpp_float_radix __glibcpp_f80_radix\n+#define __glibcpp_float_epsilon __glibcpp_f80_epsilon\n+#define __glibcpp_float_round_error __glibcpp_f80_round_error\n+#define __glibcpp_float_min_exponent __glibcpp_f80_min_exponent\n+#define __glibcpp_float_min_exponent10 __glibcpp_f80_min_exponent10\n+#define __glibcpp_float_max_exponent __glibcpp_f80_max_exponent\n+#define __glibcpp_float_max_exponent10 __glibcpp_f80_max_exponent10\n+#else\n+// You must define these macros in the configuration file.\n+#endif\n+\n+// FIXME: These are just stubs and inkorrect\n+\n+#ifndef __glibcpp_float_has_infinity\n+#define __glibcpp_float_has_infinity false\n+#endif\n+\n+#ifndef __glibcpp_float_has_quiet_NaM\n+#define __glibcpp_float_has_quiet_NaN false\n+#endif\n+\n+#ifndef __glibcpp_float_has_signaling_NaN\n+#define __glibcpp_float_has_signaling_NaN false\n+#endif\n+\n+#ifndef __glibcpp_float_has_denorm\n+#define __glibcpp_float_has_denorm denorm_absent\n+#endif\n+\n+#ifndef __glibcpp_float_has_denorm_loss\n+#define __glibcpp_float_has_denorm_loss false\n+#endif\n+\n+#ifndef __glibcpp_float_infinity\n+#define __glibcpp_float_infinity 0.0F\n+#endif\n+\n+#ifndef __glibcpp_float_quiet_NaN\n+#define __glibcpp_float_quiet_NaN 0.0F\n+#endif\n+\n+#ifndef __glibcpp_float_signaling_NaN\n+#define __glibcpp_float_signaling_NaN 0.0F\n+#endif\n+\n+#ifndef __glibcpp_float_denorm_min\n+#define __glibcpp_float_denorm_min 0.0F\n+#endif\n+\n+#ifndef __glibcpp_float_is_iec559\n+#define __glibcpp_float_is_iec559 false\n+#endif\n+\n+#ifndef __glibcpp_float_is_bounded\n+#define __glibcpp_float_is_bounded true\n+#endif\n+\n+#ifndef __glibcpp_float_is_modulo\n+#define __glibcpp_float_is_modulo false\n+#endif\n+\n+#ifndef __glibcpp_float_traps\n+#define __glibcpp_float_traps false\n+#endif\n+\n+#ifndef __glibcpp_float_tinyness_before\n+#define __glibcpp_float_tinyness_before false\n+#endif\n+\n+#ifndef __glibcpp_float_round_style\n+#define __glibcpp_float_round_style round_toward_zero\n+#endif\n+\n+// double\n+\n+#if __glibcpp_double_bits == 32\n+#define __glibcpp_double_min __glibcpp_f32_min\n+#define __glibcpp_double_max __glibcpp_f32_max\n+#define __glibcpp_double_digits __glibcpp_f32_digits\n+#define __glibcpp_double_digits10 __glibcpp_f32_digits10\n+#define __glibcpp_double_radix __glibcpp_f32_radix\n+#define __glibcpp_double_epsilon __glibcpp_f32_epsilon\n+#define __glibcpp_double_round_error __glibcpp_f32_round_error\n+#define __glibcpp_double_min_exponent __glibcpp_f32_min_exponent\n+#define __glibcpp_double_min_exponent10 __glibcpp_f32_min_exponent10\n+#define __glibcpp_double_max_exponent __glibcpp_f32_max_exponent\n+#define __glibcpp_double_max_exponent10 __glibcpp_f32_max_exponent10\n+#elif __glibcpp_double_bits == 64\n+#define __glibcpp_double_min __glibcpp_f64_min\n+#define __glibcpp_double_max __glibcpp_f64_max\n+#define __glibcpp_double_digits __glibcpp_f64_digits\n+#define __glibcpp_double_digits10 __glibcpp_f64_digits10\n+#define __glibcpp_double_radix __glibcpp_f64_radix\n+#define __glibcpp_double_epsilon __glibcpp_f64_epsilon\n+#define __glibcpp_double_round_error __glibcpp_f64_round_error\n+#define __glibcpp_double_min_exponent __glibcpp_f64_min_exponent\n+#define __glibcpp_double_min_exponent10 __glibcpp_f64_min_exponent10\n+#define __glibcpp_double_max_exponent __glibcpp_f64_max_exponent\n+#define __glibcpp_double_max_exponent10 __glibcpp_f64_max_exponent10\n+#elif __glibcpp_double_bits == 80\n+#define __glibcpp_double_min __glibcpp_f80_min\n+#define __glibcpp_double_max __glibcpp_f80_max\n+#define __glibcpp_double_digits __glibcpp_f80_digits\n+#define __glibcpp_double_digits10 __glibcpp_f80_digits10\n+#define __glibcpp_double_radix __glibcpp_f80_radix\n+#define __glibcpp_double_epsilon __glibcpp_f80_epsilon\n+#define __glibcpp_double_round_error __glibcpp_f80_round_error\n+#define __glibcpp_double_min_exponent __glibcpp_f80_min_exponent\n+#define __glibcpp_double_min_exponent10 __glibcpp_f80_min_exponent10\n+#define __glibcpp_double_max_exponent __glibcpp_f80_max_exponent\n+#define __glibcpp_double_max_exponent10 __glibcpp_f80_max_exponent10\n+#else\n+// You must define these macros in the configuration file.\n+#endif\n+\n+// FIXME: These are just stubs and inkorrect\n+\n+#ifndef __glibcpp_double_has_infinity\n+#define __glibcpp_double_has_infinity false\n+#endif\n+\n+#ifndef __glibcpp_double_has_quiet_NaM\n+#define __glibcpp_double_has_quiet_NaN false\n+#endif\n+\n+#ifndef __glibcpp_double_has_signaling_NaN\n+#define __glibcpp_double_has_signaling_NaN false\n+#endif\n+\n+#ifndef __glibcpp_double_has_denorm\n+#define __glibcpp_double_has_denorm denorm_absent\n+#endif\n+\n+#ifndef __glibcpp_double_has_denorm_loss\n+#define __glibcpp_double_has_denorm_loss false\n+#endif\n+\n+#ifndef __glibcpp_double_infinity\n+#define __glibcpp_double_infinity 0.0\n+#endif\n+\n+#ifndef __glibcpp_double_quiet_NaN\n+#define __glibcpp_double_quiet_NaN 0.0\n+#endif\n+\n+#ifndef __glibcpp_double_signaling_NaN\n+#define __glibcpp_double_signaling_NaN 0.0\n+#endif\n+\n+#ifndef __glibcpp_double_denorm_min\n+#define __glibcpp_double_denorm_min 0.0\n+#endif\n+\n+#ifndef __glibcpp_double_is_iec559\n+#define __glibcpp_double_is_iec559 false\n+#endif\n+\n+#ifndef __glibcpp_double_is_bounded\n+#define __glibcpp_double_is_bounded true\n+#endif\n+\n+#ifndef __glibcpp_double_is_modulo\n+#define __glibcpp_double_is_modulo false\n+#endif\n+\n+#ifndef __glibcpp_double_traps\n+#define __glibcpp_double_traps false\n+#endif\n+\n+#ifndef __glibcpp_double_tinyness_before\n+#define __glibcpp_double_tinyness_before false\n+#endif\n+\n+#ifndef __glibcpp_double_round_style\n+#define __glibcpp_double_round_style round_toward_zero\n+#endif\n+\n+// long double\n+\n+#if __glibcpp_long_double_bits == 32\n+#define __glibcpp_long_double_min __glibcpp_f32_min\n+#define __glibcpp_long_double_max __glibcpp_f32_max\n+#define __glibcpp_long_double_digits __glibcpp_f32_digits\n+#define __glibcpp_long_double_digits10 __glibcpp_f32_digits10\n+#define __glibcpp_long_double_radix __glibcpp_f32_radix\n+#define __glibcpp_long_double_epsilon __glibcpp_f32_epsilon\n+#define __glibcpp_long_double_round_error __glibcpp_f32_round_error\n+#define __glibcpp_long_double_min_exponent __glibcpp_f32_min_exponent\n+#define __glibcpp_long_double_min_exponent10 __glibcpp_f32_min_exponent10\n+#define __glibcpp_long_double_max_exponent __glibcpp_f32_max_exponent\n+#define __glibcpp_long_double_max_exponent10 __glibcpp_f32_max_exponent10\n+#elif __glibcpp_long_double_bits == 64\n+#define __glibcpp_long_double_min __glibcpp_f64_min\n+#define __glibcpp_long_double_max __glibcpp_f64_max\n+#define __glibcpp_long_double_digits __glibcpp_f64_digits\n+#define __glibcpp_long_double_digits10 __glibcpp_f64_digits10\n+#define __glibcpp_long_double_radix __glibcpp_f64_radix\n+#define __glibcpp_long_double_epsilon __glibcpp_f64_epsilon\n+#define __glibcpp_long_double_round_error __glibcpp_f64_round_error\n+#define __glibcpp_long_double_min_exponent __glibcpp_f64_min_exponent\n+#define __glibcpp_long_double_min_exponent10 __glibcpp_f64_min_exponent10\n+#define __glibcpp_long_double_max_exponent __glibcpp_f64_max_exponent\n+#define __glibcpp_long_double_max_exponent10 __glibcpp_f64_max_exponent10\n+#elif __glibcpp_long_double_bits == 80\n+#define __glibcpp_long_double_min __glibcpp_f80_min\n+#define __glibcpp_long_double_max __glibcpp_f80_max\n+#define __glibcpp_long_double_digits __glibcpp_f80_digits\n+#define __glibcpp_long_double_digits10 __glibcpp_f80_digits10\n+#define __glibcpp_long_double_radix __glibcpp_f80_radix\n+#define __glibcpp_long_double_epsilon __glibcpp_f80_epsilon\n+#define __glibcpp_long_double_round_error __glibcpp_f80_round_error\n+#define __glibcpp_long_double_min_exponent __glibcpp_f80_min_exponent\n+#define __glibcpp_long_double_min_exponent10 __glibcpp_f80_min_exponent10\n+#define __glibcpp_long_double_max_exponent __glibcpp_f80_max_exponent\n+#define __glibcpp_long_double_max_exponent10 __glibcpp_f80_max_exponent10\n+#elif __glibcpp_long_double_bits == 128\n+#define __glibcpp_long_double_min __glibcpp_f128_min\n+#define __glibcpp_long_double_max __glibcpp_f128_max\n+#define __glibcpp_long_double_digits __glibcpp_f128_digits\n+#define __glibcpp_long_double_digits10 __glibcpp_f128_digits10\n+#define __glibcpp_long_double_radix __glibcpp_f128_radix\n+#define __glibcpp_long_double_epsilon __glibcpp_f128_epsilon\n+#define __glibcpp_long_double_round_error __glibcpp_f128_round_error\n+#define __glibcpp_long_double_min_exponent __glibcpp_f128_min_exponent\n+#define __glibcpp_long_double_min_exponent10 __glibcpp_f128_min_exponent10\n+#define __glibcpp_long_double_max_exponent __glibcpp_f128_max_exponent\n+#define __glibcpp_long_double_max_exponent10 __glibcpp_f128_max_exponent10\n+#else\n+// You must define these macros in the configuration file.\n+#endif\n+\n+// FIXME: These are just stubs and inkorrect\n+\n+#ifndef __glibcpp_long_double_has_infinity\n+#define __glibcpp_long_double_has_infinity false\n+#endif\n+\n+#ifndef __glibcpp_long_double_has_quiet_NaN\n+#define __glibcpp_long_double_has_quiet_NaN false\n+#endif\n+\n+#ifndef __glibcpp_long_double_has_signaling_NaN\n+#define __glibcpp_long_double_has_signaling_NaN false\n+#endif\n+\n+#ifndef __glibcpp_long_double_has_denorm\n+#define __glibcpp_long_double_has_denorm denorm_absent\n+#endif\n+\n+#ifndef __glibcpp_long_double_has_denorm_loss\n+#define __glibcpp_long_double_has_denorm_loss false\n+#endif\n+\n+#ifndef __glibcpp_long_double_infinity\n+#define __glibcpp_long_double_infinity 0.0L\n+#endif\n+\n+#ifndef __glibcpp_long_double_quiet_NaN\n+#define __glibcpp_long_double_quiet_NaN 0.0L\n+#endif\n+\n+#ifndef __glibcpp_long_double_signaling_NaN\n+#define __glibcpp_long_double_signaling_NaN 0.0L\n+#endif\n+\n+#ifndef __glibcpp_long_double_denorm_min\n+#define __glibcpp_long_double_denorm_min 0.0L\n+#endif\n+\n+#ifndef __glibcpp_long_double_is_iec559\n+#define __glibcpp_long_double_is_iec559 false\n+#endif\n+\n+#ifndef __glibcpp_long_double_is_bounded\n+#define __glibcpp_long_double_is_bounded false\n+#endif\n+\n+#ifndef __glibcpp_long_double_is_modulo\n+#define __glibcpp_long_double_is_modulo false\n+#endif\n+\n+#ifndef __glibcpp_long_double_traps\n+#define __glibcpp_long_double_traps false\n+#endif\n+\n+#ifndef __glibcpp_long_double_tinyness_before\n+#define __glibcpp_long_double_tinyness_before false\n+#endif\n+\n+#ifndef __glibcpp_long_double_round_style\n+#define __glibcpp_long_double_round_style round_toward_zero\n+#endif\n+\n+\n+namespace std\n+{\n+  enum float_round_style \n+  {\n+    round_indeterminate       = -1,\n+    round_toward_zero         = 0,\n+    round_to_nearest          = 1,\n+    round_toward_infinity     = 2,\n+    round_toward_neg_infinity = 3\n+  };\n+\n+  enum float_denorm_style \n+  {\n+    denorm_indeterminate = -1,\n+    denorm_absent        = 0,\n+    denorm_present       = 1\n+  };\n+\n+  //\n+  // The primary class traits\n+  //\n+  template<typename _Tp> \n+    struct numeric_limits \n+    {\n+      static const bool is_specialized = false;\n+\n+      static _Tp min() throw() { return static_cast<_Tp>(0); }\n+      static _Tp max() throw() { return static_cast<_Tp>(0); }\n+\n+      static const int digits = 0;\n+      static const int digits10 = 0;\n+      static const bool is_signed = false;\n+      static const bool is_integer = false;\n+      static const bool is_exact = false;\n+      static const int radix = 0;\n+\n+      static _Tp epsilon() throw() { return static_cast<_Tp>(0); }\n+      static _Tp round_error() throw() { return static_cast<_Tp>(0); }\n+\n+      static const int min_exponent = 0;\n+      static const int min_exponent10 = 0;\n+      static const int max_exponent = 0;\n+      static const int max_exponent10 = 0;\n+\n+      static const bool has_infinity = false;\n+      static const bool has_quiet_NaN = false;\n+      static const bool has_signaling_NaN = false;\n+      static const float_denorm_style has_denorm = denorm_absent;\n+      static const bool has_denorm_loss = false;\n+\n+      static _Tp infinity() throw()  { return static_cast<_Tp>(0); }\n+      static _Tp quiet_NaN() throw() { return static_cast<_Tp>(0); }\n+      static _Tp signaling_NaN() throw() { return static_cast<_Tp>(0); }\n+      static _Tp denorm_min() throw() { return static_cast<_Tp>(0); }\n+\n+      static const bool is_iec559 = false;\n+      static const bool is_bounded = false;\n+      static const bool is_modulo = false;\n+\n+      static const bool traps = false;\n+      static const bool tinyness_before = false;\n+      static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+  template<typename _Tp> \n+    const bool\n+    numeric_limits<_Tp>::is_specialized;\n+\n+  template<typename _Tp> \n+    const int\n+    numeric_limits<_Tp>::digits;\n+\n+  template<typename _Tp> \n+    const int\n+    numeric_limits<_Tp>::digits10;\n+\n+  template<typename _Tp> \n+    const bool\n+    numeric_limits<_Tp>::is_signed;\n+\n+  template<typename _Tp> \n+    const bool\n+    numeric_limits<_Tp>::is_integer;\n+\n+  template<typename _Tp> \n+    const bool\n+    numeric_limits<_Tp>::is_exact;\n+\n+  template<typename _Tp> \n+    const int\n+    numeric_limits<_Tp>::radix;\n+\n+  template<typename _Tp> \n+    const int\n+    numeric_limits<_Tp>::min_exponent;\n+\n+  template<typename _Tp> \n+    const int\n+    numeric_limits<_Tp>::min_exponent10;\n+\n+  template<typename _Tp> \n+    const int\n+    numeric_limits<_Tp>::max_exponent;\n+\n+  template<typename _Tp> \n+    const int\n+    numeric_limits<_Tp>::max_exponent10;\n+\n+  template<typename _Tp> \n+    const bool\n+    numeric_limits<_Tp>::has_infinity;\n+\n+  template<typename _Tp> \n+    const bool\n+    numeric_limits<_Tp>::has_quiet_NaN;\n+\n+  template<typename _Tp> \n+    const bool\n+    numeric_limits<_Tp>::has_signaling_NaN;\n+\n+  template<typename _Tp> \n+    const float_denorm_style\n+    numeric_limits<_Tp>::has_denorm;\n+\n+  template<typename _Tp> \n+    const bool\n+    numeric_limits<_Tp>::has_denorm_loss;\n+\n+  template<typename _Tp> \n+    const bool\n+    numeric_limits<_Tp>::is_iec559;\n+\n+  template<typename _Tp> \n+    const bool\n+    numeric_limits<_Tp>::is_bounded;\n+\n+  template<typename _Tp> \n+    const bool\n+    numeric_limits<_Tp>::is_modulo;\n+\n+  template<typename _Tp> \n+    const bool\n+    numeric_limits<_Tp>::traps;\n+\n+  template<typename _Tp> \n+    const bool\n+    numeric_limits<_Tp>::tinyness_before;\n+\n+  template<typename _Tp> \n+    const float_round_style\n+    numeric_limits<_Tp>::round_style;\n+\n+  // Now there follow 15 explicit specializations.  Yes, 15.  Make sure\n+  // you get the count right.\n+  \n+  template<>\n+    struct numeric_limits<bool>\n+    {\n+      static const bool is_specialized = true;\n+\n+      static bool min() throw()\n+      { return false; }\n+\n+      static bool max() throw()\n+      { return true; }\n+\n+      static const int digits = __glibcpp_bool_digits;\n+      static const int digits10 = 1;\n+      static const bool is_signed = false;\n+      static const bool is_integer = true;\n+      static const bool is_exact = true;\n+      static const int radix = 2;\n+      static bool epsilon() throw()\n+      { return false; }\n+      static bool round_error() throw()\n+      { return false; }\n+\n+      static const int min_exponent = 0;\n+      static const int min_exponent10 = 0;\n+      static const int max_exponent = 0;\n+      static const int max_exponent10 = 0;\n+\n+      static const bool has_infinity = false;\n+      static const bool has_quiet_NaN = false;\n+      static const bool has_signaling_NaN = false;\n+      static const float_denorm_style has_denorm = denorm_absent;\n+      static const bool has_denorm_loss = false;\n+\n+      static bool infinity() throw()\n+      { return false; }\n+      static bool quiet_NaN() throw()\n+      { return false; }\n+      static bool signaling_NaN() throw()\n+      { return false; }\n+      static bool denorm_min() throw()\n+      { return false; }\n+\n+      static const bool is_iec559 = true;\n+      static const bool is_bounded = true;\n+      static const bool is_modulo = true;\n+\n+      // It is not clear what it means for a boolean type to trap.\n+      // This is a DR on the LWG issue list.  Here, I use integer\n+      // promotion semantics.\n+      static const bool traps = __glibcpp_signed_int_traps\n+               || __glibcpp_signed_long_traps;\n+      static const bool tinyness_before = false;\n+      static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+#undef __glibcpp_bool_digits  \n+  \n+  template<>\n+    struct numeric_limits<char>\n+    {\n+      static const bool is_specialized = true;\n+\n+      static char min() throw()\n+      { return __glibcpp_char_min; }\n+      static char max() throw()\n+      { return __glibcpp_char_max; }\n+\n+      static const int digits = __glibcpp_char_digits;\n+      static const int digits10 = __glibcpp_char_digits10;\n+      static const bool is_signed = __glibcpp_plain_char_is_signed;\n+      static const bool is_integer = true;\n+      static const bool is_exact = true;\n+      static const int radix = 2;\n+      static char epsilon() throw()\n+      { return char(); }\n+      static char round_error() throw()\n+      { return char(); }\n+\n+      static const int min_exponent = 0;\n+      static const int min_exponent10 = 0;\n+      static const int max_exponent = 0;\n+      static const int max_exponent10 = 0;\n+\n+      static const bool has_infinity = false;\n+      static const bool has_quiet_NaN = false;\n+      static const bool has_signaling_NaN = false;\n+      static const float_denorm_style has_denorm = denorm_absent;\n+      static const bool has_denorm_loss = false;\n+\n+      static char infinity() throw()\n+      { return char(); }\n+      static char quiet_NaN() throw()\n+      { return char(); }\n+      static char signaling_NaN() throw()\n+      { return char(); }\n+      static char denorm_min() throw()\n+      { return static_cast<char>(0); }\n+\n+      static const bool is_iec559 = false;\n+      static const bool is_bounded = true;\n+      static const bool is_modulo = false;\n+\n+      static const bool traps = __glibcpp_signed_char_traps;\n+      static const bool tinyness_before = false;\n+      static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+#undef __glibcpp_char_min\n+#undef __glibcpp_char_max  \n+#undef __glibcpp_char_digits\n+#undef __glibcpp_char_digits10\n+#undef __glibcpp_char_is_signed\n+#undef __glibcpp_char_traps\n+\n+\n+  template<>\n+  struct numeric_limits<signed char>\n+    {\n+      static const bool is_specialized = true;\n+\n+      static signed char min() throw()\n+      { return __glibcpp_signed_char_min; }\n+      static signed char max() throw()\n+      { return __glibcpp_signed_char_min; }\n+\n+      static const int digits = __glibcpp_signed_char_digits;\n+      static const int digits10 = __glibcpp_signed_char_digits10;\n+      static const bool is_signed = true;\n+      static const bool is_integer = true;\n+      static const bool is_exact = true;\n+      static const int radix = 2;\n+      static signed char epsilon() throw()\n+      { return 0; }\n+      static signed char round_error() throw()\n+      { return 0; }\n+\n+      static const int min_exponent = 0;\n+      static const int min_exponent10 = 0;\n+      static const int max_exponent = 0;\n+      static const int max_exponent10 = 0;\n+\n+      static const bool has_infinity = false;\n+      static const bool has_quiet_NaN = false;\n+      static const bool has_signaling_NaN = false;\n+      static const float_denorm_style has_denorm = denorm_absent;\n+      static const bool has_denorm_loss = false;\n+\n+      static signed char infinity() throw()\n+      { return static_cast<signed char>(0); }\n+      static signed char quiet_NaN() throw()\n+      { return static_cast<signed char>(0); }\n+      static signed char signaling_NaN() throw()\n+      { return static_cast<signed char>(0); }\n+      static signed char denorm_min() throw()\n+      { return static_cast<signed char>(0); }\n+\n+      static const bool is_iec559 = false;\n+      static const bool is_bounded = true;\n+      static const bool is_modulo = false;\n+\n+      static const bool traps = __glibcpp_signed_char_traps;\n+      static const bool tinyness_before = false;\n+      static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+#undef __glibcpp_signed_char_min\n+#undef __glibcpp_signed_char_max\n+#undef __glibcpp_signed_char_digits\n+#undef __glibcpp_signed_char_digits10\n+#undef __glibcpp_signed_char_traps  \n+\n+  template<>\n+    struct numeric_limits<unsigned char>\n+    {\n+      static const bool is_specialized = true;\n+\n+      static unsigned char min() throw()\n+      { return 0; }\n+      static unsigned char max() throw()\n+      { return __glibcpp_unsigned_char_max; }\n+\n+      static const int digits = __glibcpp_unsigned_char_digits;\n+      static const int digits10 = __glibcpp_unsigned_char_digits10;\n+      static const bool is_signed = false;\n+      static const bool is_integer = true;\n+      static const bool is_exact = true;\n+      static const int radix = 2;\n+      static unsigned char epsilon() throw()\n+      { return 0; }\n+      static unsigned char round_error() throw()\n+      { return 0; }\n+\n+      static const int min_exponent = 0;\n+      static const int min_exponent10 = 0;\n+      static const int max_exponent = 0;\n+      static const int max_exponent10 = 0;\n+\n+      static const bool has_infinity = false;\n+      static const bool has_quiet_NaN = false;\n+      static const bool has_signaling_NaN = false;\n+      static const float_denorm_style has_denorm = denorm_absent;\n+      static const bool has_denorm_loss = false;\n+\n+      static unsigned char infinity() throw()\n+      { return static_cast<unsigned char>(0); }\n+      static unsigned char quiet_NaN() throw()\n+      { return static_cast<unsigned char>(0); }\n+      static unsigned char signaling_NaN() throw()\n+      { return static_cast<unsigned char>(0); }\n+      static unsigned char denorm_min() throw()\n+      { return static_cast<unsigned char>(0); }\n+\n+      static const bool is_iec559 = false;\n+      static const bool is_bounded = true;\n+      static const bool is_modulo = true;\n+\n+      static const bool traps = __glibcpp_unsigned_char_traps;\n+      static const bool tinyness_before = false;\n+      static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+#undef __glibcpp_unsigned_char_max\n+#undef __glibcpp_unsigned_char_digits\n+#undef __glibcpp_unsigned_char_digits10\n+#undef __glibcpp_unsigned_char_traps  \n+\n+  template<>\n+    struct numeric_limits<wchar_t>\n+    {\n+      static const bool is_specialized = true;\n+\n+      static wchar_t min() throw()\n+      { return __glibcpp_wchar_t_min; }\n+      static wchar_t max() throw()\n+      { return __glibcpp_wchar_t_max; }\n+\n+      static const int digits = __glibcpp_wchar_t_digits;\n+      static const int digits10 = __glibcpp_wchar_t_digits10;\n+      static const bool is_signed = __glibcpp_wchar_t_is_signed;\n+      static const bool is_integer = true;\n+      static const bool is_exact = true;\n+      static const int radix = 2;\n+      static wchar_t epsilon() throw()\n+      { return 0; }\n+      static wchar_t round_error() throw()\n+      { return 0; }\n+\n+      static const int min_exponent = 0;\n+      static const int min_exponent10 = 0;\n+      static const int max_exponent = 0;\n+      static const int max_exponent10 = 0;\n+\n+      static const bool has_infinity = false;\n+      static const bool has_quiet_NaN = false;\n+      static const bool has_signaling_NaN = false;\n+      static const float_denorm_style has_denorm = denorm_absent;\n+      static const bool has_denorm_loss = false;\n+\n+      static wchar_t infinity() throw()\n+      { return wchar_t(); }\n+      static wchar_t quiet_NaN() throw()\n+      { return wchar_t(); }\n+      static wchar_t signaling_NaN() throw()\n+      { return wchar_t(); }\n+      static wchar_t denorm_min() throw()\n+      { return wchar_t(); }\n+\n+      static const bool is_iec559 = false;\n+      static const bool is_bounded = true;\n+      static const bool is_modulo = false;\n+\n+      static const bool traps = __glibcpp_wchar_t_traps;\n+      static const bool tinyness_before = false;\n+      static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+#undef __glibcpp_wchar_t_min\n+#undef __glibcpp_wchar_t_max\n+#undef __glibcpp_wchar_t_digits\n+#undef __glibcpp_wchar_t_digits10  \n+#undef __glibcpp_wchar_t_is_signed\n+#undef __glibcpp_wchar_t_traps  \n+  \n+  template<>\n+    struct numeric_limits<short>\n+    {\n+      static const bool is_specialized = true;\n+\n+      static short min() throw()\n+      { return __glibcpp_signed_short_min; }\n+      static short max() throw()\n+      { return __glibcpp_signed_short_max; }\n+\n+      static const int digits = __glibcpp_signed_short_digits;\n+      static const int digits10 = __glibcpp_signed_short_digits10;\n+      static const bool is_signed = true;\n+      static const bool is_integer = true;\n+      static const bool is_exact = true;\n+      static const int radix = 2;\n+      static short epsilon() throw()\n+      { return 0; }\n+      static short round_error() throw()\n+      { return 0; }\n+\n+      static const int min_exponent = 0;\n+      static const int min_exponent10 = 0;\n+      static const int max_exponent = 0;\n+      static const int max_exponent10 = 0;\n+\n+      static const bool has_infinity = false;\n+      static const bool has_quiet_NaN = false;\n+      static const bool has_signaling_NaN = false;\n+      static const float_denorm_style has_denorm = denorm_absent;\n+      static const bool has_denorm_loss = false;\n+\n+      static short infinity() throw()\n+      { return short(); }\n+      static short quiet_NaN() throw()\n+      { return short(); }\n+      static short signaling_NaN() throw()\n+      { return short(); }\n+      static short denorm_min() throw()\n+      { return short(); }\n+\n+      static const bool is_iec559 = true;\n+      static const bool is_bounded = true;\n+      static const bool is_modulo = false;\n+\n+      static const bool traps = __glibcpp_signed_short_traps;\n+      static const bool tinyness_before = false;\n+      static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+#undef __glibcpp_signed_short_min\n+#undef __glibcpp_signed_short_max\n+#undef __glibcpp_signed_short_digits\n+#undef __glibcpp_signed_short_digits10\n+#undef __glibcpp_signed_short_traps  \n+  \n+  template<>\n+    struct numeric_limits<unsigned short>\n+    {\n+      static const bool is_specialized = true;\n+\n+      static unsigned short min() throw()\n+      { return 0; }\n+      static unsigned short max() throw()\n+      { return __glibcpp_unsigned_short_max; }\n+\n+      static const int digits = __glibcpp_unsigned_short_digits;\n+      static const int digits10 = __glibcpp_unsigned_short_digits10;\n+      static const bool is_signed = false;\n+      static const bool is_integer = true;\n+      static const bool is_exact = true;\n+      static const int radix = 2;\n+      static unsigned short epsilon() throw()\n+      { return 0; }\n+      static unsigned short round_error() throw()\n+      { return 0; }\n+\n+      static const int min_exponent = 0;\n+      static const int min_exponent10 = 0;\n+      static const int max_exponent = 0;\n+      static const int max_exponent10 = 0;\n+\n+      static const bool has_infinity = false;\n+      static const bool has_quiet_NaN = false;\n+      static const bool has_signaling_NaN = false;\n+      static const float_denorm_style has_denorm = denorm_absent;\n+      static const bool has_denorm_loss = false;\n+\n+      static unsigned short infinity() throw()\n+      { return static_cast<unsigned short>(0); }\n+      static unsigned short quiet_NaN() throw()\n+      { return static_cast<unsigned short>(0); }\n+      static unsigned short signaling_NaN() throw()\n+      { return static_cast<unsigned short>(0); }\n+      static unsigned short denorm_min() throw()\n+      { return static_cast<unsigned short>(0); }\n+\n+      static const bool is_iec559 = true;\n+      static const bool is_bounded = true;\n+      static const bool is_modulo = true;\n+\n+      static const bool traps = __glibcpp_unsigned_short_traps;\n+      static const bool tinyness_before = false;\n+      static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+#undef __glibcpp_unsigned_short_max\n+#undef __glibcpp_unsigned_short_digits\n+#undef __glibcpp_unsigned_short_digits10\n+#undef __glibcpp_unsigned_short_traps  \n+  \n+  template<>\n+    struct numeric_limits<int>\n+    {\n+      static const bool is_specialized = true;\n+\n+      static int min() throw()\n+      { return __glibcpp_signed_int_min; }\n+      static int max() throw()\n+      { return __glibcpp_signed_int_max; }\n+\n+      static const int digits = __glibcpp_signed_int_digits;\n+      static const int digits10 = __glibcpp_signed_int_digits10;\n+      static const bool is_signed = true;\n+      static const bool is_integer = true;\n+      static const bool is_exact = true;\n+      static const int radix = 2;\n+      static int epsilon() throw()\n+      { return 0; }\n+      static int round_error() throw()\n+      { return 0; }\n+\n+      static const int min_exponent = 0;\n+      static const int min_exponent10 = 0;\n+      static const int max_exponent = 0;\n+      static const int max_exponent10 = 0;\n+\n+      static const bool has_infinity = false;\n+      static const bool has_quiet_NaN = false;\n+      static const bool has_signaling_NaN = false;\n+      static const float_denorm_style has_denorm = denorm_absent;\n+      static const bool has_denorm_loss = false;\n+\n+      static int infinity() throw()\n+      { return static_cast<int>(0); }\n+      static int quiet_NaN() throw()\n+      { return static_cast<int>(0); }\n+      static int signaling_NaN() throw()\n+      { return static_cast<int>(0); }\n+      static int denorm_min() throw()\n+      { return static_cast<int>(0); }\n+\n+      static const bool is_iec559 = true;\n+      static const bool is_bounded = true;\n+      static const bool is_modulo = false;\n+\n+      static const bool traps = __glibcpp_signed_int_traps;\n+      static const bool tinyness_before = false;\n+      static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+#undef __glibcpp_signed_int_min\n+#undef __glibcpp_signed_int_max\n+#undef __glibcpp_signed_int_digits\n+#undef __glibcpp_signed_int_digits10\n+#undef __glibcpp_signed_int_traps  \n+  \n+  template<>\n+    struct numeric_limits<unsigned int>\n+    {\n+      static const bool is_specialized = true;\n+\n+      static unsigned int min() throw()\n+      { return 0; }\n+          static unsigned int max() throw()\n+      { return __glibcpp_unsigned_int_max; }\n+\n+      static const int digits = __glibcpp_unsigned_int_digits;\n+      static const int digits10 = __glibcpp_unsigned_int_digits10;\n+      static const bool is_signed = false;\n+      static const bool is_integer = true;\n+      static const bool is_exact = true;\n+      static const int radix = 2;\n+      static unsigned int epsilon() throw()\n+      { return 0; }\n+      static unsigned int round_error() throw()\n+      { return 0; }\n+\n+      static const int min_exponent = 0;\n+      static const int min_exponent10 = 0;\n+      static const int max_exponent = 0;\n+      static const int max_exponent10 = 0;\n+\n+      static const bool has_infinity = false;\n+      static const bool has_quiet_NaN = false;\n+      static const bool has_signaling_NaN = false;\n+      static const float_denorm_style has_denorm = denorm_absent;\n+      static const bool has_denorm_loss = false;\n+\n+      static unsigned int infinity() throw()\n+      { return static_cast<unsigned int>(0); }\n+      static unsigned int quiet_NaN() throw()\n+      { return static_cast<unsigned int>(0); }\n+      static unsigned int signaling_NaN() throw()\n+      { return static_cast<unsigned int>(0); }\n+      static unsigned int denorm_min() throw()\n+      { return static_cast<unsigned int>(0); }\n+\n+      static const bool is_iec559 = true;\n+      static const bool is_bounded = true;\n+      static const bool is_modulo = true;\n+\n+      static const bool traps = __glibcpp_unsigned_int_traps;\n+      static const bool tinyness_before = false;\n+      static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+#undef __glibcpp_unsigned_int_max\n+#undef __glibcpp_unsigned_int_digits\n+#undef __glibcpp_unsigned_int_digits10\n+#undef __glibcpp_unsigned_int_traps  \n+\n+  template<>\n+    struct numeric_limits<long>\n+    {\n+      static const bool is_specialized = true;\n+\n+      static long min() throw()\n+      { return __glibcpp_signed_long_min; }\n+      static long max() throw()\n+      { return __glibcpp_signed_long_max; }\n+\n+      static const int digits = __glibcpp_signed_long_digits;\n+      static const int digits10 = __glibcpp_signed_long_digits10;\n+      static const bool is_signed = true;\n+      static const bool is_integer = true;\n+      static const bool is_exact = true;\n+      static const int radix = 2;\n+      static long epsilon() throw()\n+      { return 0; }\n+      static long round_error() throw()\n+      { return 0; }\n+\n+      static const int min_exponent = 0;\n+      static const int min_exponent10 = 0;\n+      static const int max_exponent = 0;\n+      static const int max_exponent10 = 0;\n+\n+      static const bool has_infinity = false;\n+      static const bool has_quiet_NaN = false;\n+      static const bool has_signaling_NaN = false;\n+      static const float_denorm_style has_denorm = denorm_absent;\n+      static const bool has_denorm_loss = false;\n+\n+      static long infinity() throw()\n+      { return static_cast<long>(0); }\n+      static long quiet_NaN() throw()\n+      { return static_cast<long>(0); }\n+      static long signaling_NaN() throw()\n+      { return static_cast<long>(0); }\n+      static long denorm_min() throw()\n+      { return static_cast<long>(0); }\n+\n+      static const bool is_iec559 = true;\n+      static const bool is_bounded = true;\n+      static const bool is_modulo = false;\n+\n+      static const bool traps = __glibcpp_signed_long_traps;\n+      static const bool tinyness_before = false;\n+      static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+#undef __glibcpp_signed_long_min\n+#undef __glibcpp_signed_long_max\n+#undef __glibcpp_signed_long_digits\n+#undef __glibcpp_signed_long_digits10\n+#undef __glibcpp_signed_long_traps  \n+  \n+  template<>\n+    struct numeric_limits<unsigned long>\n+    {\n+      static const bool is_specialized = true;\n+\n+      static unsigned long min() throw()\n+      { return 0; }\n+      static unsigned long max() throw()\n+      { return __glibcpp_unsigned_long_max; }\n+\n+      static const int digits = __glibcpp_unsigned_long_digits;\n+      static const int digits10 = __glibcpp_unsigned_long_digits10;\n+      static const bool is_signed = false;\n+      static const bool is_integer = true;\n+      static const bool is_exact = true;\n+      static const int radix = 2;\n+      static unsigned long epsilon() throw()\n+      { return 0; }\n+      static unsigned long round_error() throw()\n+      { return 0; }\n+\n+      static const int min_exponent = 0;\n+      static const int min_exponent10 = 0;\n+      static const int max_exponent = 0;\n+      static const int max_exponent10 = 0;\n+\n+      static const bool has_infinity = false;\n+      static const bool has_quiet_NaN = false;\n+      static const bool has_signaling_NaN = false;\n+      static const float_denorm_style has_denorm = denorm_absent;\n+      static const bool has_denorm_loss = false;\n+\n+      static unsigned long infinity() throw()\n+      { return static_cast<unsigned long>(0); }\n+      static unsigned long quiet_NaN() throw()\n+      { return static_cast<unsigned long>(0); }\n+      static unsigned long signaling_NaN() throw()\n+      { return static_cast<unsigned long>(0); }\n+      static unsigned long denorm_min() throw()\n+      { return static_cast<unsigned long>(0); }\n+\n+      static const bool is_iec559 = true;\n+      static const bool is_bounded = true;\n+      static const bool is_modulo = true;\n+\n+      static const bool traps = __glibcpp_unsigned_long_traps;\n+      static const bool tinyness_before = false;\n+      static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+#undef __glibcpp_unsigned_long_max\n+#undef __glibcpp_unsigned_long_digits\n+#undef __glibcpp_unsigned_long_digits10\n+#undef __glibcpp_unsigned_long_traps  \n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+\n+  template<>\n+    struct numeric_limits<long long>\n+    {\n+      static const bool is_specialized = true;\n+      \n+      static long long min() throw()\n+      { return __glibcpp_signed_long_long_min; }\n+      static long long max() throw()\n+      { return __glibcpp_signed_long_long_max; }\n+      \n+      static const int digits = __glibcpp_signed_long_long_digits;\n+      static const int digits10 = __glibcpp_signed_long_long_digits10;\n+      static const bool is_signed = true;\n+      static const bool is_integer = true;\n+      static const bool is_exact = true;\n+      static const int radix = 2;\n+      static long long epsilon() throw()\n+      { return 0; }\n+      static long long round_error() throw()\n+      { return 0; }\n+      \n+      static const int min_exponent = 0;\n+      static const int min_exponent10 = 0;\n+      static const int max_exponent = 0;\n+      static const int max_exponent10 = 0;\n+      \n+      static const bool has_infinity = false;\n+      static const bool has_quiet_NaN = false;\n+      static const bool has_signaling_NaN = false;\n+      static const float_denorm_style has_denorm = denorm_absent;\n+      static const bool has_denorm_loss = false;\n+      \n+      static long long infinity() throw()\n+      { return static_cast<long long>(0); }\n+      static long long quiet_NaN() throw()\n+      { return static_cast<long long>(0); }\n+      static long long signaling_NaN() throw()\n+      { return static_cast<long long>(0); }\n+      static long long denorm_min() throw()\n+      { return static_cast<long long>(0); }\n+      \n+      static const bool is_iec559 = true;\n+      static const bool is_bounded = true;\n+      static const bool is_modulo = false;\n+\n+      static const bool traps = __glibcpp_signed_long_long_traps;\n+      static const bool tinyness_before = false;\n+      static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+#undef __glibcpp_signed_long_long_min\n+#undef __glibcpp_signed_long_long_max\n+#undef __glibcpp_signed_long_long_digits\n+#undef __glibcpp_signed_long_long_digits10\n+#undef __glibcpp_signed_long_long_traps  \n+  \n+  template<>\n+    struct numeric_limits<unsigned long long>\n+    {\n+      static const bool is_specialized = true;\n+\n+      static unsigned long long min() throw()\n+      { return 0; }\n+      static unsigned long long max() throw()\n+      { return __glibcpp_unsigned_long_long_max; }\n+\n+      static const int digits = __glibcpp_unsigned_long_long_digits;\n+      static const int digits10 = __glibcpp_unsigned_long_long_digits10;\n+      static const bool is_signed = false;\n+      static const bool is_integer = true;\n+      static const bool is_exact = true;\n+      static const int radix = 2;\n+      static unsigned long long epsilon() throw()\n+      { return 0; }\n+      static unsigned long long round_error() throw()\n+      { return 0; }\n+\n+      static const int min_exponent = 0;\n+      static const int min_exponent10 = 0;\n+      static const int max_exponent = 0;\n+      static const int max_exponent10 = 0;\n+\n+      static const bool has_infinity = false;\n+      static const bool has_quiet_NaN = false;\n+      static const bool has_signaling_NaN = false;\n+      static const float_denorm_style has_denorm = denorm_absent;\n+      static const bool has_denorm_loss = false;\n+\n+      static unsigned long long infinity() throw()\n+      { return static_cast<unsigned long long>(0); }\n+      static unsigned long long quiet_NaN() throw()\n+      { return static_cast<unsigned long long>(0); }\n+      static unsigned long long signaling_NaN() throw()\n+      { return static_cast<unsigned long long>(0); }\n+      static unsigned long long denorm_min() throw()\n+      { return static_cast<unsigned long long>(0); }\n+\n+      static const bool is_iec559 = true;\n+      static const bool is_bounded = true;\n+      static const bool is_modulo = true;\n+\n+      static const bool traps = true;\n+      static const bool tinyness_before = false;\n+      static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+#undef __glibcpp_unsigned_long_long_max\n+#undef __glibcpp_unsigned_long_long_digits\n+#undef __glibcpp_unsigned_long_long_digits10\n+#undef __glibcpp_unsigned_long_long_traps  \n+  \n+#endif // _GLIBCPP_USE_LONG_LONG\n+  \n+\n+  template<>\n+    struct numeric_limits<float>\n+    {\n+      static const bool is_specialized = true;\n+\n+      static float min() throw()\n+      { return __glibcpp_float_min; }\n+      static float max() throw()\n+      { return __glibcpp_float_max; }\n+\n+      static const int digits = __glibcpp_float_digits;\n+      static const int digits10 = __glibcpp_float_digits10;\n+      static const bool is_signed = true;\n+      static const bool is_integer = false;\n+      static const bool is_exact = false;\n+      static const int radix = 2;\n+      static float epsilon() throw()\n+      { return __glibcpp_float_radix; }\n+      static float round_error() throw()\n+      { return __glibcpp_float_round_error; }\n+\n+      static const int min_exponent = __glibcpp_float_min_exponent;\n+      static const int min_exponent10 = __glibcpp_float_min_exponent10;\n+      static const int max_exponent = __glibcpp_float_max_exponent;\n+      static const int max_exponent10 = __glibcpp_float_max_exponent10;\n+\n+      static const bool has_infinity = __glibcpp_float_has_infinity;\n+      static const bool has_quiet_NaN = __glibcpp_float_has_quiet_NaN;\n+      static const bool has_signaling_NaN = __glibcpp_float_has_signaling_NaN;\n+      static const float_denorm_style has_denorm = __glibcpp_float_has_denorm;\n+      static const bool has_denorm_loss = __glibcpp_float_has_denorm_loss;\n+\n+      static float infinity() throw()\n+      { return __glibcpp_float_infinity; }\n+      static float quiet_NaN() throw()\n+      { return __glibcpp_float_quiet_NaN; }\n+      static float signaling_NaN() throw()\n+      { return __glibcpp_float_signaling_NaN; }\n+      static float denorm_min() throw()\n+      { return __glibcpp_float_denorm_min; }\n+\n+      static const bool is_iec559 = __glibcpp_float_is_iec559;\n+      static const bool is_bounded = __glibcpp_float_is_bounded;\n+      static const bool is_modulo = __glibcpp_float_is_modulo;\n+\n+      static const bool traps = __glibcpp_float_traps;\n+      static const bool tinyness_before = __glibcpp_float_tinyness_before;\n+      static const float_round_style round_style = __glibcpp_float_round_style;\n+    };\n+\n+#undef __glibcpp_float_min\n+#undef __glibcpp_float_max\n+#undef __glibcpp_float_digits\n+#undef __glibcpp_float_digits10\n+#undef __glibcpp_float_radix\n+#undef __glibcpp_float_round_error\n+#undef __glibcpp_float_min_exponent\n+#undef __glibcpp_float_min_exponent10\n+#undef __glibcpp_float_max_exponent\n+#undef __glibcpp_float_max_exponent10\n+#undef __glibcpp_float_has_infinity\n+#undef __glibcpp_float_has_quiet_NaN\n+#undef __glibcpp_float_has_signaling_NaN\n+#undef __glibcpp_float_has_denorm\n+#undef __glibcpp_float_has_denorm_loss\n+#undef __glibcpp_float_infinity\n+#undef __glibcpp_float_quiet_NaN\n+#undef __glibcpp_float_signaling_NaN\n+#undef __glibcpp_float_denorm_min\n+#undef __glibcpp_float_is_iec559\n+#undef __glibcpp_float_is_bounded\n+#undef __glibcpp_float_is_modulo\n+#undef __glibcpp_float_traps\n+#undef __glibcpp_float_tinyness_before\n+#undef __glibcpp_float_round_style  \n+\n+  template<>\n+    struct numeric_limits<double>\n+    {\n+      static const bool is_specialized = true;\n+\n+      static double min() throw()\n+      { return __glibcpp_double_min; }\n+      static double max() throw()\n+      { return __glibcpp_double_max; }\n+\n+      static const int digits = __glibcpp_double_digits;\n+      static const int digits10 = __glibcpp_double_digits10;\n+      static const bool is_signed = true;\n+      static const bool is_integer = false;\n+      static const bool is_exact = false;\n+      static const int radix = __glibcpp_double_radix;\n+      static double epsilon() throw()\n+      { return __glibcpp_double_epsilon; }\n+      static double round_error() throw()\n+      { return __glibcpp_double_round_error; }\n+\n+      static const int min_exponent = __glibcpp_double_min_exponent;\n+      static const int min_exponent10 = __glibcpp_double_min_exponent10;\n+      static const int max_exponent = __glibcpp_double_max_exponent;\n+      static const int max_exponent10 = __glibcpp_double_max_exponent10;\n+\n+      static const bool has_infinity = __glibcpp_double_has_infinity;\n+      static const bool has_quiet_NaN = __glibcpp_double_has_quiet_NaN;\n+      static const bool has_signaling_NaN = __glibcpp_double_has_signaling_NaN;\n+      static const float_denorm_style has_denorm =\n+              __glibcpp_double_has_denorm;;\n+      static const bool has_denorm_loss = __glibcpp_double_has_denorm_loss;;\n+\n+      static double infinity() throw()\n+      { return __glibcpp_double_infinity; }\n+      static double quiet_NaN() throw()\n+      { return __glibcpp_double_quiet_NaN; }\n+      static double signaling_NaN() throw()\n+      { return __glibcpp_double_signaling_NaN; }\n+      static double denorm_min() throw()\n+      { return __glibcpp_double_denorm_min; }\n+\n+      static const bool is_iec559 = __glibcpp_double_is_iec559;\n+      static const bool is_bounded = __glibcpp_double_is_bounded;\n+      static const bool is_modulo = __glibcpp_double_is_modulo;\n+\n+      static const bool traps = __glibcpp_double_traps;\n+      static const bool tinyness_before = __glibcpp_double_tinyness_before;\n+      static const float_round_style round_style =\n+              __glibcpp_double_round_style;\n+    };\n+\n+#undef __glibcpp_double_min\n+#undef __glibcpp_double_max\n+#undef __glibcpp_double_digits\n+#undef __glibcpp_double_digits10\n+#undef __glibcpp_double_radix\n+#undef __glibcpp_double_round_error\n+#undef __glibcpp_double_min_exponent\n+#undef __glibcpp_double_min_exponent10\n+#undef __glibcpp_double_max_exponent\n+#undef __glibcpp_double_max_exponent10\n+#undef __glibcpp_double_has_infinity\n+#undef __glibcpp_double_has_quiet_NaN\n+#undef __glibcpp_double_has_signaling_NaN\n+#undef __glibcpp_double_has_denorm\n+#undef __glibcpp_double_has_denorm_loss\n+#undef __glibcpp_double_infinity\n+#undef __glibcpp_double_quiet_NaN\n+#undef __glibcpp_double_signaling_NaN\n+#undef __glibcpp_double_denorm_min\n+#undef __glibcpp_double_is_iec559\n+#undef __glibcpp_double_is_bounded\n+#undef __glibcpp_double_is_modulo\n+#undef __glibcpp_double_traps\n+#undef __glibcpp_double_tinyness_before\n+#undef __glibcpp_double_round_style  \n+  \n+  \n+  template<>\n+    struct numeric_limits<long double>\n+    {\n+      static const bool is_specialized = true;\n+\n+      static long double min() throw()\n+      { return __glibcpp_long_double_min; }\n+      static long double max() throw()\n+      { return __glibcpp_long_double_max; }\n+\n+      static const int digits = __glibcpp_long_double_digits;\n+      static const int digits10 = __glibcpp_long_double_digits10;\n+      static const bool is_signed = true;\n+      static const bool is_integer = false;\n+      static const bool is_exact = false;\n+      static const int radix = __glibcpp_long_double_radix;\n+      static long double epsilon() throw()\n+      { return __glibcpp_long_double_epsilon; }\n+      static long double round_error() throw()\n+      { return __glibcpp_long_double_round_error; }\n+\n+      static const int min_exponent = __glibcpp_long_double_min_exponent;\n+      static const int min_exponent10 = __glibcpp_long_double_min_exponent10;\n+      static const int max_exponent = __glibcpp_long_double_max_exponent;\n+      static const int max_exponent10 = __glibcpp_long_double_max_exponent10;\n+\n+      static const bool has_infinity = __glibcpp_long_double_has_infinity;\n+      static const bool has_quiet_NaN = __glibcpp_long_double_has_quiet_NaN;\n+      static const bool has_signaling_NaN =\n+                __glibcpp_long_double_has_signaling_NaN;\n+      static const float_denorm_style has_denorm =\n+                __glibcpp_long_double_has_denorm;\n+      static const bool has_denorm_loss =\n+                __glibcpp_long_double_has_denorm_loss;\n+\n+      static long double infinity() throw()\n+      { return __glibcpp_long_double_infinity; }\n+      static long double quiet_NaN() throw()\n+      { return __glibcpp_long_double_quiet_NaN; }\n+      static long double signaling_NaN() throw()\n+      { return __glibcpp_long_double_signaling_NaN; }\n+      static long double denorm_min() throw()\n+      { return __glibcpp_long_double_denorm_min; }\n+\n+      static const bool is_iec559 = __glibcpp_long_double_is_iec559;\n+      static const bool is_bounded = __glibcpp_long_double_is_bounded;\n+      static const bool is_modulo = __glibcpp_long_double_is_modulo;\n+\n+      static const bool traps = __glibcpp_long_double_traps; \n+      static const bool tinyness_before = __glibcpp_long_double_tinyness_before;\n+      static const float_round_style round_style =\n+                    __glibcpp_long_double_round_style;\n+    };\n+\n+#undef __glibcpp_long_double_min\n+#undef __glibcpp_long_double_max\n+#undef __glibcpp_long_double_digits\n+#undef __glibcpp_long_double_digits10\n+#undef __glibcpp_long_double_radix\n+#undef __glibcpp_long_double_round_error\n+#undef __glibcpp_long_double_min_exponent\n+#undef __glibcpp_long_double_min_exponent10\n+#undef __glibcpp_long_double_max_exponent\n+#undef __glibcpp_long_double_max_exponent10\n+#undef __glibcpp_long_double_has_infinity\n+#undef __glibcpp_long_double_has_quiet_NaN\n+#undef __glibcpp_long_double_has_signaling_NaN\n+#undef __glibcpp_long_double_has_denorm\n+#undef __glibcpp_long_double_has_denorm_loss\n+#undef __glibcpp_long_double_infinity\n+#undef __glibcpp_long_double_quiet_NaN\n+#undef __glibcpp_long_double_signaling_NaN\n+#undef __glibcpp_long_double_denorm_min\n+#undef __glibcpp_long_double_is_iec559\n+#undef __glibcpp_long_double_is_bounded\n+#undef __glibcpp_long_double_is_modulo\n+#undef __glibcpp_long_double_traps\n+#undef __glibcpp_long_double_tinyness_before\n+#undef __glibcpp_long_double_round_style  \n+  \n+} // namespace std\n+\n+#endif // _CPP_NUMERIC_LIMITS"}, {"sha": "fecd7aa1254d2b972ea43b75583e9b042f6dde62", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2408185d5f199d04096862d061a0671d42b626/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2408185d5f199d04096862d061a0671d42b626/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=aa2408185d5f199d04096862d061a0671d42b626", "patch": "@@ -21,7 +21,7 @@\n ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n ## USA.\n \n-## $Id: Makefile.am,v 1.91 2001/08/08 02:49:00 bkoz Exp $\n+## $Id: Makefile.am,v 1.92 2001/08/08 22:39:28 bkoz Exp $\n \n AUTOMAKE_OPTIONS = 1.3 gnits\n MAINT_CHARSET = latin1\n@@ -63,7 +63,7 @@ INCLUDES = \\\n \n sources = \\\n \tbasic_file.cc bitset.cc c++locale.cc cmath.cc codecvt.cc \\\n-\tcomplex_io.cc functexcept.cc globals.cc ios.cc limitsMEMBERS.cc \\\n+\tcomplex_io.cc functexcept.cc globals.cc ios.cc limits.cc \\\n \tlocale.cc locale-inst.cc localename.cc messages_members.cc \\\n \tmisc-inst.cc stdexcept.cc stl-inst.cc string-inst.cc strstream.cc \\\n \tvalarray-inst.cc wstring-inst.cc"}, {"sha": "0839375cf7af0b50d753168b27cdda014c13e6e0", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2408185d5f199d04096862d061a0671d42b626/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2408185d5f199d04096862d061a0671d42b626/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=aa2408185d5f199d04096862d061a0671d42b626", "patch": "@@ -174,7 +174,7 @@ TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n INCLUDES =  \t-nostdinc++ \t$(GLIBCPP_INCLUDES) \t$(LIBSUPCXX_INCLUDES) $(LIBIO_INCLUDES) $(LIBMATH_INCLUDES) \t$(TOPLEVEL_INCLUDES)\n \n \n-sources =  \tbasic_file.cc bitset.cc c++locale.cc cmath.cc codecvt.cc \tcomplex_io.cc functexcept.cc globals.cc ios.cc limitsMEMBERS.cc \tlocale.cc locale-inst.cc localename.cc messages_members.cc \tmisc-inst.cc stdexcept.cc stl-inst.cc string-inst.cc strstream.cc \tvalarray-inst.cc wstring-inst.cc\n+sources =  \tbasic_file.cc bitset.cc c++locale.cc cmath.cc codecvt.cc \tcomplex_io.cc functexcept.cc globals.cc ios.cc limits.cc \tlocale.cc locale-inst.cc localename.cc messages_members.cc \tmisc-inst.cc stdexcept.cc stl-inst.cc string-inst.cc strstream.cc \tvalarray-inst.cc wstring-inst.cc\n \n \n VPATH = $(top_srcdir):$(top_srcdir)/src\n@@ -243,10 +243,10 @@ CPPFLAGS = @CPPFLAGS@\n LDFLAGS = @LDFLAGS@\n LIBS = @LIBS@\n libstdc___la_OBJECTS =  basic_file.lo bitset.lo c++locale.lo cmath.lo \\\n-codecvt.lo complex_io.lo functexcept.lo globals.lo ios.lo \\\n-limitsMEMBERS.lo locale.lo locale-inst.lo localename.lo \\\n-messages_members.lo misc-inst.lo stdexcept.lo stl-inst.lo \\\n-string-inst.lo strstream.lo valarray-inst.lo wstring-inst.lo\n+codecvt.lo complex_io.lo functexcept.lo globals.lo ios.lo limits.lo \\\n+locale.lo locale-inst.lo localename.lo messages_members.lo misc-inst.lo \\\n+stdexcept.lo stl-inst.lo string-inst.lo strstream.lo valarray-inst.lo \\\n+wstring-inst.lo\n CXXFLAGS = @CXXFLAGS@\n CXXCOMPILE = $(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n CXXLD = $(CXX)"}, {"sha": "6fbfdb73fff90332032867b63e57286db69ff013", "filename": "libstdc++-v3/src/gen-num-limits.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2408185d5f199d04096862d061a0671d42b626/libstdc%2B%2B-v3%2Fsrc%2Fgen-num-limits.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2408185d5f199d04096862d061a0671d42b626/libstdc%2B%2B-v3%2Fsrc%2Fgen-num-limits.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fgen-num-limits.cc?ref=aa2408185d5f199d04096862d061a0671d42b626", "patch": "@@ -584,7 +584,7 @@ template<typename T>\n void digits10()\n {\n   printf(\"%s%s = %d;\\n\", tab2, \"static const int digits10\",\n-\t int(log10_of_two * value<T>::digits));\n+\t int(log10_of_two * value<T>::digits) + 1);\n }\n \n template<typename T>"}, {"sha": "bf7c1b0a165c9e22fb78ee5a11567ff43684644f", "filename": "libstdc++-v3/src/limits.cc", "status": "added", "additions": 429, "deletions": 0, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2408185d5f199d04096862d061a0671d42b626/libstdc%2B%2B-v3%2Fsrc%2Flimits.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2408185d5f199d04096862d061a0671d42b626/libstdc%2B%2B-v3%2Fsrc%2Flimits.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flimits.cc?ref=aa2408185d5f199d04096862d061a0671d42b626", "patch": "@@ -0,0 +1,429 @@\n+// Static data members of -*- C++ -*- numeric_limits classes\n+\n+// Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@cmla.ens-cachan.fr>\n+\n+//\n+// ISO C++ 14882:1998\n+// 18.2.1\n+//\n+\n+#include <bits/std_limits.h>\n+namespace std \n+{\n+  // bool\n+  const bool numeric_limits<bool>::is_specialized;\n+  const int  numeric_limits<bool>::digits;\n+  const int  numeric_limits<bool>::digits10;\n+  const bool numeric_limits<bool>::is_signed;\n+  const bool numeric_limits<bool>::is_integer;\n+  const bool numeric_limits<bool>::is_exact;\n+  const int  numeric_limits<bool>::radix;\n+  const int  numeric_limits<bool>::min_exponent;\n+  const int  numeric_limits<bool>::min_exponent10;\n+  const int  numeric_limits<bool>::max_exponent;\n+  const int  numeric_limits<bool>::max_exponent10;\n+  const bool numeric_limits<bool>::has_infinity;\n+  const bool numeric_limits<bool>::has_quiet_NaN;\n+  const bool numeric_limits<bool>::has_signaling_NaN;\n+  const float_denorm_style numeric_limits<bool>::has_denorm;\n+  const bool numeric_limits<bool>::has_denorm_loss;\n+  const bool numeric_limits<bool>::is_iec559;\n+  const bool numeric_limits<bool>::is_bounded;\n+  const bool numeric_limits<bool>::is_modulo;\n+  const bool numeric_limits<bool>::traps;\n+  const bool numeric_limits<bool>::tinyness_before;\n+  const float_round_style numeric_limits<bool>::round_style;\n+\n+  // char\n+  const bool numeric_limits<char>::is_specialized;\n+  const int  numeric_limits<char>::digits;\n+  const int  numeric_limits<char>::digits10;\n+  const bool numeric_limits<char>::is_signed;\n+  const bool numeric_limits<char>::is_integer;\n+  const bool numeric_limits<char>::is_exact;\n+  const int  numeric_limits<char>::radix;\n+  const int  numeric_limits<char>::min_exponent;\n+  const int  numeric_limits<char>::min_exponent10;\n+  const int  numeric_limits<char>::max_exponent;\n+  const int  numeric_limits<char>::max_exponent10;\n+  const bool numeric_limits<char>::has_infinity;\n+  const bool numeric_limits<char>::has_quiet_NaN;\n+  const bool numeric_limits<char>::has_signaling_NaN;\n+  const float_denorm_style numeric_limits<char>::has_denorm;\n+  const bool numeric_limits<char>::has_denorm_loss;\n+  const bool numeric_limits<char>::is_iec559;\n+  const bool numeric_limits<char>::is_bounded;\n+  const bool numeric_limits<char>::is_modulo;\n+  const bool numeric_limits<char>::traps;\n+  const bool numeric_limits<char>::tinyness_before;\n+  const float_round_style numeric_limits<char>::round_style;\n+\n+  // signed char\n+  const bool numeric_limits<signed char>::is_specialized;\n+  const int  numeric_limits<signed char>::digits;\n+  const int  numeric_limits<signed char>::digits10;\n+  const bool numeric_limits<signed char>::is_signed;\n+  const bool numeric_limits<signed char>::is_integer;\n+  const bool numeric_limits<signed char>::is_exact;\n+  const int  numeric_limits<signed char>::radix;\n+  const int  numeric_limits<signed char>::min_exponent;\n+  const int  numeric_limits<signed char>::min_exponent10;\n+  const int  numeric_limits<signed char>::max_exponent;\n+  const int  numeric_limits<signed char>::max_exponent10;\n+  const bool numeric_limits<signed char>::has_infinity;\n+  const bool numeric_limits<signed char>::has_quiet_NaN;\n+  const bool numeric_limits<signed char>::has_signaling_NaN;\n+  const float_denorm_style numeric_limits<signed char>::has_denorm;\n+  const bool numeric_limits<signed char>::has_denorm_loss;\n+  const bool numeric_limits<signed char>::is_iec559;\n+  const bool numeric_limits<signed char>::is_bounded;\n+  const bool numeric_limits<signed char>::is_modulo;\n+  const bool numeric_limits<signed char>::traps;\n+  const bool numeric_limits<signed char>::tinyness_before;\n+  const float_round_style numeric_limits<signed char>::round_style;\n+\n+  // unsigned char\n+  const bool numeric_limits<unsigned char>::is_specialized;\n+  const int  numeric_limits<unsigned char>::digits;\n+  const int  numeric_limits<unsigned char>::digits10;\n+  const bool numeric_limits<unsigned char>::is_signed;\n+  const bool numeric_limits<unsigned char>::is_integer;\n+  const bool numeric_limits<unsigned char>::is_exact;\n+  const int  numeric_limits<unsigned char>::radix;\n+  const int  numeric_limits<unsigned char>::min_exponent;\n+  const int  numeric_limits<unsigned char>::min_exponent10;\n+  const int  numeric_limits<unsigned char>::max_exponent;\n+  const int  numeric_limits<unsigned char>::max_exponent10;\n+  const bool numeric_limits<unsigned char>::has_infinity;\n+  const bool numeric_limits<unsigned char>::has_quiet_NaN;\n+  const bool numeric_limits<unsigned char>::has_signaling_NaN;\n+  const float_denorm_style numeric_limits<unsigned char>::has_denorm;\n+  const bool numeric_limits<unsigned char>::has_denorm_loss;\n+  const bool numeric_limits<unsigned char>::is_iec559;\n+  const bool numeric_limits<unsigned char>::is_bounded;\n+  const bool numeric_limits<unsigned char>::is_modulo;\n+  const bool numeric_limits<unsigned char>::traps;\n+  const bool numeric_limits<unsigned char>::tinyness_before;\n+  const float_round_style numeric_limits<unsigned char>::round_style;\n+\n+  // wchar_t\n+  // This used to be problematic...\n+#ifdef _GLIBCPP_USE_WCHAR_T  \n+  const bool numeric_limits<wchar_t>::is_specialized;\n+  const int  numeric_limits<wchar_t>::digits;\n+  const int  numeric_limits<wchar_t>::digits10;\n+  const bool numeric_limits<wchar_t>::is_signed;\n+  const bool numeric_limits<wchar_t>::is_integer;\n+  const bool numeric_limits<wchar_t>::is_exact;\n+  const int  numeric_limits<wchar_t>::radix;\n+  const int  numeric_limits<wchar_t>::min_exponent;\n+  const int  numeric_limits<wchar_t>::min_exponent10;\n+  const int  numeric_limits<wchar_t>::max_exponent;\n+  const int  numeric_limits<wchar_t>::max_exponent10;\n+  const bool numeric_limits<wchar_t>::has_infinity;\n+  const bool numeric_limits<wchar_t>::has_quiet_NaN;\n+  const bool numeric_limits<wchar_t>::has_signaling_NaN;\n+  const float_denorm_style numeric_limits<wchar_t>::has_denorm;\n+  const bool numeric_limits<wchar_t>::has_denorm_loss;\n+  const bool numeric_limits<wchar_t>::is_iec559;\n+  const bool numeric_limits<wchar_t>::is_bounded;\n+  const bool numeric_limits<wchar_t>::is_modulo;\n+  const bool numeric_limits<wchar_t>::traps;\n+  const bool numeric_limits<wchar_t>::tinyness_before;\n+  const float_round_style numeric_limits<wchar_t>::round_style;\n+#endif // _GLIBCPP_USE_WCHAR_T\n+\n+  // short\n+  const bool numeric_limits<short>::is_specialized;\n+  const int  numeric_limits<short>::digits;\n+  const int  numeric_limits<short>::digits10;\n+  const bool numeric_limits<short>::is_signed;\n+  const bool numeric_limits<short>::is_integer;\n+  const bool numeric_limits<short>::is_exact;\n+  const int  numeric_limits<short>::radix;\n+  const int  numeric_limits<short>::min_exponent;\n+  const int  numeric_limits<short>::min_exponent10;\n+  const int  numeric_limits<short>::max_exponent;\n+  const int  numeric_limits<short>::max_exponent10;\n+  const bool numeric_limits<short>::has_infinity;\n+  const bool numeric_limits<short>::has_quiet_NaN;\n+  const bool numeric_limits<short>::has_signaling_NaN;\n+  const float_denorm_style numeric_limits<short>::has_denorm;\n+  const bool numeric_limits<short>::has_denorm_loss;\n+  const bool numeric_limits<short>::is_iec559;\n+  const bool numeric_limits<short>::is_bounded;\n+  const bool numeric_limits<short>::is_modulo;\n+  const bool numeric_limits<short>::traps;\n+  const bool numeric_limits<short>::tinyness_before;\n+  const float_round_style numeric_limits<short>::round_style;\n+\n+  // unsigned short\n+  const bool numeric_limits<unsigned short>::is_specialized;\n+  const int  numeric_limits<unsigned short>::digits;\n+  const int  numeric_limits<unsigned short>::digits10;\n+  const bool numeric_limits<unsigned short>::is_signed;\n+  const bool numeric_limits<unsigned short>::is_integer;\n+  const bool numeric_limits<unsigned short>::is_exact;\n+  const int  numeric_limits<unsigned short>::radix;\n+  const int  numeric_limits<unsigned short>::min_exponent;\n+  const int  numeric_limits<unsigned short>::min_exponent10;\n+  const int  numeric_limits<unsigned short>::max_exponent;\n+  const int  numeric_limits<unsigned short>::max_exponent10;\n+  const bool numeric_limits<unsigned short>::has_infinity;\n+  const bool numeric_limits<unsigned short>::has_quiet_NaN;\n+  const bool numeric_limits<unsigned short>::has_signaling_NaN;\n+  const float_denorm_style numeric_limits<unsigned short>::has_denorm;\n+  const bool numeric_limits<unsigned short>::has_denorm_loss;\n+  const bool numeric_limits<unsigned short>::is_iec559;\n+  const bool numeric_limits<unsigned short>::is_bounded;\n+  const bool numeric_limits<unsigned short>::is_modulo;\n+  const bool numeric_limits<unsigned short>::traps;\n+  const bool numeric_limits<unsigned short>::tinyness_before;\n+  const float_round_style numeric_limits<unsigned short>::round_style;\n+\n+  // int\n+  const bool numeric_limits<int>::is_specialized;\n+  const int  numeric_limits<int>::digits;\n+  const int  numeric_limits<int>::digits10;\n+  const bool numeric_limits<int>::is_signed;\n+  const bool numeric_limits<int>::is_integer;\n+  const bool numeric_limits<int>::is_exact;\n+  const int  numeric_limits<int>::radix;\n+  const int  numeric_limits<int>::min_exponent;\n+  const int  numeric_limits<int>::min_exponent10;\n+  const int  numeric_limits<int>::max_exponent;\n+  const int  numeric_limits<int>::max_exponent10;\n+  const bool numeric_limits<int>::has_infinity;\n+  const bool numeric_limits<int>::has_quiet_NaN;\n+  const bool numeric_limits<int>::has_signaling_NaN;\n+  const float_denorm_style numeric_limits<int>::has_denorm;\n+  const bool numeric_limits<int>::has_denorm_loss;\n+  const bool numeric_limits<int>::is_iec559;\n+  const bool numeric_limits<int>::is_bounded;\n+  const bool numeric_limits<int>::is_modulo;\n+  const bool numeric_limits<int>::traps;\n+  const bool numeric_limits<int>::tinyness_before;\n+  const float_round_style numeric_limits<int>::round_style;\n+\n+  // unsigned int\n+  const bool numeric_limits<unsigned int>::is_specialized;\n+  const int  numeric_limits<unsigned int>::digits;\n+  const int  numeric_limits<unsigned int>::digits10;\n+  const bool numeric_limits<unsigned int>::is_signed;\n+  const bool numeric_limits<unsigned int>::is_integer;\n+  const bool numeric_limits<unsigned int>::is_exact;\n+  const int  numeric_limits<unsigned int>::radix;\n+  const int  numeric_limits<unsigned int>::min_exponent;\n+  const int  numeric_limits<unsigned int>::min_exponent10;\n+  const int  numeric_limits<unsigned int>::max_exponent;\n+  const int  numeric_limits<unsigned int>::max_exponent10;\n+  const bool numeric_limits<unsigned int>::has_infinity;\n+  const bool numeric_limits<unsigned int>::has_quiet_NaN;\n+  const bool numeric_limits<unsigned int>::has_signaling_NaN;\n+  const float_denorm_style numeric_limits<unsigned int>::has_denorm;\n+  const bool numeric_limits<unsigned int>::has_denorm_loss;\n+  const bool numeric_limits<unsigned int>::is_iec559;\n+  const bool numeric_limits<unsigned int>::is_bounded;\n+  const bool numeric_limits<unsigned int>::is_modulo;\n+  const bool numeric_limits<unsigned int>::traps;\n+  const bool numeric_limits<unsigned int>::tinyness_before;\n+  const float_round_style numeric_limits<unsigned int>::round_style;\n+\n+  // long\n+  const bool numeric_limits<long>::is_specialized;\n+  const int  numeric_limits<long>::digits;\n+  const int  numeric_limits<long>::digits10;\n+  const bool numeric_limits<long>::is_signed;\n+  const bool numeric_limits<long>::is_integer;\n+  const bool numeric_limits<long>::is_exact;\n+  const int  numeric_limits<long>::radix;\n+  const int  numeric_limits<long>::min_exponent;\n+  const int  numeric_limits<long>::min_exponent10;\n+  const int  numeric_limits<long>::max_exponent;\n+  const int  numeric_limits<long>::max_exponent10;\n+  const bool numeric_limits<long>::has_infinity;\n+  const bool numeric_limits<long>::has_quiet_NaN;\n+  const bool numeric_limits<long>::has_signaling_NaN;\n+  const float_denorm_style numeric_limits<long>::has_denorm;\n+  const bool numeric_limits<long>::has_denorm_loss;\n+  const bool numeric_limits<long>::is_iec559;\n+  const bool numeric_limits<long>::is_bounded;\n+  const bool numeric_limits<long>::is_modulo;\n+  const bool numeric_limits<long>::traps;\n+  const bool numeric_limits<long>::tinyness_before;\n+  const float_round_style numeric_limits<long>::round_style;\n+\n+  // unsigned long\n+  const bool numeric_limits<unsigned long>::is_specialized;\n+  const int  numeric_limits<unsigned long>::digits;\n+  const int  numeric_limits<unsigned long>::digits10;\n+  const bool numeric_limits<unsigned long>::is_signed;\n+  const bool numeric_limits<unsigned long>::is_integer;\n+  const bool numeric_limits<unsigned long>::is_exact;\n+  const int  numeric_limits<unsigned long>::radix;\n+  const int  numeric_limits<unsigned long>::min_exponent;\n+  const int  numeric_limits<unsigned long>::min_exponent10;\n+  const int  numeric_limits<unsigned long>::max_exponent;\n+  const int  numeric_limits<unsigned long>::max_exponent10;\n+  const bool numeric_limits<unsigned long>::has_infinity;\n+  const bool numeric_limits<unsigned long>::has_quiet_NaN;\n+  const bool numeric_limits<unsigned long>::has_signaling_NaN;\n+  const float_denorm_style numeric_limits<unsigned long>::has_denorm;\n+  const bool numeric_limits<unsigned long>::has_denorm_loss;\n+  const bool numeric_limits<unsigned long>::is_iec559;\n+  const bool numeric_limits<unsigned long>::is_bounded;\n+  const bool numeric_limits<unsigned long>::is_modulo;\n+  const bool numeric_limits<unsigned long>::traps;\n+  const bool numeric_limits<unsigned long>::tinyness_before;\n+  const float_round_style numeric_limits<unsigned long>::round_style;\n+\n+  // XXX: Extensions\n+#ifdef _GLIBCPP_USE_LONG_LONG  \n+  const bool numeric_limits<long long>::is_specialized;\n+  const int  numeric_limits<long long>::digits;\n+  const int  numeric_limits<long long>::digits10;\n+  const bool numeric_limits<long long>::is_signed;\n+  const bool numeric_limits<long long>::is_integer;\n+  const bool numeric_limits<long long>::is_exact;\n+  const int  numeric_limits<long long>::radix;\n+  const int  numeric_limits<long long>::min_exponent;\n+  const int  numeric_limits<long long>::min_exponent10;\n+  const int  numeric_limits<long long>::max_exponent;\n+  const int  numeric_limits<long long>::max_exponent10;\n+  const bool numeric_limits<long long>::has_infinity;\n+  const bool numeric_limits<long long>::has_quiet_NaN;\n+  const bool numeric_limits<long long>::has_signaling_NaN;\n+  const float_denorm_style numeric_limits<long long>::has_denorm;\n+  const bool numeric_limits<long long>::has_denorm_loss;\n+  const bool numeric_limits<long long>::is_iec559;\n+  const bool numeric_limits<long long>::is_bounded;\n+  const bool numeric_limits<long long>::is_modulo;\n+  const bool numeric_limits<long long>::traps;\n+  const bool numeric_limits<long long>::tinyness_before;\n+  const float_round_style numeric_limits<long long>::round_style;\n+\n+  const bool numeric_limits<unsigned long long>::is_specialized;\n+  const int  numeric_limits<unsigned long long>::digits;\n+  const int  numeric_limits<unsigned long long>::digits10;\n+  const bool numeric_limits<unsigned long long>::is_signed;\n+  const bool numeric_limits<unsigned long long>::is_integer;\n+  const bool numeric_limits<unsigned long long>::is_exact;\n+  const int  numeric_limits<unsigned long long>::radix;\n+  const int  numeric_limits<unsigned long long>::min_exponent;\n+  const int  numeric_limits<unsigned long long>::min_exponent10;\n+  const int  numeric_limits<unsigned long long>::max_exponent;\n+  const int  numeric_limits<unsigned long long>::max_exponent10;\n+  const bool numeric_limits<unsigned long long>::has_infinity;\n+  const bool numeric_limits<unsigned long long>::has_quiet_NaN;\n+  const bool numeric_limits<unsigned long long>::has_signaling_NaN;\n+  const float_denorm_style numeric_limits<unsigned long long>::has_denorm;\n+  const bool numeric_limits<unsigned long long>::has_denorm_loss;\n+  const bool numeric_limits<unsigned long long>::is_iec559;\n+  const bool numeric_limits<unsigned long long>::is_bounded;\n+  const bool numeric_limits<unsigned long long>::is_modulo;\n+  const bool numeric_limits<unsigned long long>::traps;\n+  const bool numeric_limits<unsigned long long>::tinyness_before;\n+  const float_round_style numeric_limits<unsigned long long>::round_style;\n+#endif // _GLIBCPP_USE_LONG_LONG\n+\n+  // float\n+  const bool numeric_limits<float>::is_specialized;\n+  const int  numeric_limits<float>::digits;\n+  const int  numeric_limits<float>::digits10;\n+  const bool numeric_limits<float>::is_signed;\n+  const bool numeric_limits<float>::is_integer;\n+  const bool numeric_limits<float>::is_exact;\n+  const int  numeric_limits<float>::radix;\n+  const int  numeric_limits<float>::min_exponent;\n+  const int  numeric_limits<float>::min_exponent10;\n+  const int  numeric_limits<float>::max_exponent;\n+  const int  numeric_limits<float>::max_exponent10;\n+  const bool numeric_limits<float>::has_infinity;\n+  const bool numeric_limits<float>::has_quiet_NaN;\n+  const bool numeric_limits<float>::has_signaling_NaN;\n+  const float_denorm_style numeric_limits<float>::has_denorm;\n+  const bool numeric_limits<float>::has_denorm_loss;\n+  const bool numeric_limits<float>::is_iec559;\n+  const bool numeric_limits<float>::is_bounded;\n+  const bool numeric_limits<float>::is_modulo;\n+  const bool numeric_limits<float>::traps;\n+  const bool numeric_limits<float>::tinyness_before;\n+  const float_round_style numeric_limits<float>::round_style;\n+\n+  // double\n+  const bool numeric_limits<double>::is_specialized;\n+  const int  numeric_limits<double>::digits;\n+  const int  numeric_limits<double>::digits10;\n+  const bool numeric_limits<double>::is_signed;\n+  const bool numeric_limits<double>::is_integer;\n+  const bool numeric_limits<double>::is_exact;\n+  const int  numeric_limits<double>::radix;\n+  const int  numeric_limits<double>::min_exponent;\n+  const int  numeric_limits<double>::min_exponent10;\n+  const int  numeric_limits<double>::max_exponent;\n+  const int  numeric_limits<double>::max_exponent10;\n+  const bool numeric_limits<double>::has_infinity;\n+  const bool numeric_limits<double>::has_quiet_NaN;\n+  const bool numeric_limits<double>::has_signaling_NaN;\n+  const float_denorm_style numeric_limits<double>::has_denorm;\n+  const bool numeric_limits<double>::has_denorm_loss;\n+  const bool numeric_limits<double>::is_iec559;\n+  const bool numeric_limits<double>::is_bounded;\n+  const bool numeric_limits<double>::is_modulo;\n+  const bool numeric_limits<double>::traps;\n+  const bool numeric_limits<double>::tinyness_before;\n+  const float_round_style numeric_limits<double>::round_style;\n+\n+  // long double\n+  const bool numeric_limits<long double>::is_specialized;\n+  const int  numeric_limits<long double>::digits;\n+  const int  numeric_limits<long double>::digits10;\n+  const bool numeric_limits<long double>::is_signed;\n+  const bool numeric_limits<long double>::is_integer;\n+  const bool numeric_limits<long double>::is_exact;\n+  const int  numeric_limits<long double>::radix;\n+  const int  numeric_limits<long double>::min_exponent;\n+  const int  numeric_limits<long double>::min_exponent10;\n+  const int  numeric_limits<long double>::max_exponent;\n+  const int  numeric_limits<long double>::max_exponent10;\n+  const bool numeric_limits<long double>::has_infinity;\n+  const bool numeric_limits<long double>::has_quiet_NaN;\n+  const bool numeric_limits<long double>::has_signaling_NaN;\n+  const float_denorm_style numeric_limits<long double>::has_denorm;\n+  const bool numeric_limits<long double>::has_denorm_loss;\n+  const bool numeric_limits<long double>::is_iec559;\n+  const bool numeric_limits<long double>::is_bounded;\n+  const bool numeric_limits<long double>::is_modulo;\n+  const bool numeric_limits<long double>::traps;\n+  const bool numeric_limits<long double>::tinyness_before;\n+  const float_round_style numeric_limits<long double>::round_style;\n+} // namespace std\n+\n+"}]}