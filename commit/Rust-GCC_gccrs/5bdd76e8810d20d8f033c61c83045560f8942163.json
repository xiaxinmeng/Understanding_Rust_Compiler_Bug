{"sha": "5bdd76e8810d20d8f033c61c83045560f8942163", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJkZDc2ZTg4MTBkMjBkOGYwMzNjNjFjODMwNDU1NjBmODk0MjE2Mw==", "commit": {"author": {"name": "Emmanuel Briot", "email": "briot@adacore.com", "date": "2007-04-06T09:23:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:23:01Z"}, "message": "g-regpat.adb (Parse_Posix_Character_Class): Fix handling of [[:xdigit:]] character class.\n\n2007-04-06  Emmanuel Briot  <briot@adacore.com>\n\n\t* g-regpat.adb (Parse_Posix_Character_Class): Fix handling of\n\t[[:xdigit:]] character class.\n\tAlso raise an exception when an invalid character class is used.\n\nFrom-SVN: r123577", "tree": {"sha": "abcae115e1d9b9567e089b4652707a51de87605c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abcae115e1d9b9567e089b4652707a51de87605c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bdd76e8810d20d8f033c61c83045560f8942163", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bdd76e8810d20d8f033c61c83045560f8942163", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bdd76e8810d20d8f033c61c83045560f8942163", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bdd76e8810d20d8f033c61c83045560f8942163/comments", "author": {"login": "briot", "id": 42402, "node_id": "MDQ6VXNlcjQyNDAy", "avatar_url": "https://avatars.githubusercontent.com/u/42402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/briot", "html_url": "https://github.com/briot", "followers_url": "https://api.github.com/users/briot/followers", "following_url": "https://api.github.com/users/briot/following{/other_user}", "gists_url": "https://api.github.com/users/briot/gists{/gist_id}", "starred_url": "https://api.github.com/users/briot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/briot/subscriptions", "organizations_url": "https://api.github.com/users/briot/orgs", "repos_url": "https://api.github.com/users/briot/repos", "events_url": "https://api.github.com/users/briot/events{/privacy}", "received_events_url": "https://api.github.com/users/briot/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7616900d855c17029e6395dcaf3db3dac95cdbe3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7616900d855c17029e6395dcaf3db3dac95cdbe3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7616900d855c17029e6395dcaf3db3dac95cdbe3"}], "stats": {"total": 148, "additions": 70, "deletions": 78}, "files": [{"sha": "053ee930d8490e16c625cae2c4f5ed3168bdf0e9", "filename": "gcc/ada/g-regpat.adb", "status": "modified", "additions": 70, "deletions": 78, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdd76e8810d20d8f033c61c83045560f8942163/gcc%2Fada%2Fg-regpat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdd76e8810d20d8f033c61c83045560f8942163/gcc%2Fada%2Fg-regpat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-regpat.adb?ref=5bdd76e8810d20d8f033c61c83045560f8942163", "patch": "@@ -1828,15 +1828,13 @@ package body GNAT.Regpat is\n             --  Check for class names based on first letter\n \n             case Expression (Parse_Pos) is\n-\n                when 'a' =>\n \n                   --  All 'a' classes have the same length (Alnum'Length)\n \n                   if Parse_Pos + Alnum'Length - 1 <= Parse_End then\n-\n-                     if E (Parse_Pos .. Parse_Pos + Alnum'Length - 1) =\n-                                                                      Alnum\n+                     if\n+                       E (Parse_Pos .. Parse_Pos + Alnum'Length - 1) = Alnum\n                      then\n                         if Invert then\n                            Class := ANYOF_NALNUMC;\n@@ -1846,8 +1844,8 @@ package body GNAT.Regpat is\n \n                         Parse_Pos := Parse_Pos + Alnum'Length;\n \n-                     elsif E (Parse_Pos .. Parse_Pos + Alpha'Length - 1) =\n-                                                                      Alpha\n+                     elsif\n+                       E (Parse_Pos .. Parse_Pos + Alpha'Length - 1) = Alpha\n                      then\n                         if Invert then\n                            Class := ANYOF_NALPHA;\n@@ -1867,13 +1865,19 @@ package body GNAT.Regpat is\n                         end if;\n \n                         Parse_Pos := Parse_Pos + Ascii_C'Length;\n+\n+                     else\n+                        Fail (\"Invalid character class: \" & E);\n                      end if;\n+\n+                  else\n+                     Fail (\"Invalid character class: \" & E);\n                   end if;\n \n                when 'c' =>\n                   if Parse_Pos + Cntrl'Length - 1 <= Parse_End\n-                    and then E (Parse_Pos .. Parse_Pos + Cntrl'Length - 1) =\n-                                                                      Cntrl\n+                    and then\n+                      E (Parse_Pos .. Parse_Pos + Cntrl'Length - 1) = Cntrl\n                   then\n                      if Invert then\n                         Class := ANYOF_NCNTRL;\n@@ -1882,12 +1886,15 @@ package body GNAT.Regpat is\n                      end if;\n \n                      Parse_Pos := Parse_Pos + Cntrl'Length;\n+\n+                  else\n+                     Fail (\"Invalid character class: \" & E);\n                   end if;\n \n                when 'd' =>\n                   if Parse_Pos + Digit'Length - 1 <= Parse_End\n-                    and then E (Parse_Pos .. Parse_Pos + Digit'Length - 1) =\n-                                                                      Digit\n+                    and then\n+                      E (Parse_Pos .. Parse_Pos + Digit'Length - 1) = Digit\n                   then\n                      if Invert then\n                         Class := ANYOF_NDIGIT;\n@@ -1900,37 +1907,45 @@ package body GNAT.Regpat is\n \n                when 'g' =>\n                   if Parse_Pos + Graph'Length - 1 <= Parse_End\n-                    and then E (Parse_Pos .. Parse_Pos + Graph'Length - 1) =\n-                                                                      Graph\n+                    and then\n+                      E (Parse_Pos .. Parse_Pos + Graph'Length - 1) = Graph\n                   then\n                      if Invert then\n                         Class := ANYOF_NGRAPH;\n                      else\n                         Class := ANYOF_GRAPH;\n                      end if;\n+\n                      Parse_Pos := Parse_Pos + Graph'Length;\n+\n+                  else\n+                     Fail (\"Invalid character class: \" & E);\n                   end if;\n \n                when 'l' =>\n                   if Parse_Pos + Lower'Length - 1 <= Parse_End\n-                    and then E (Parse_Pos .. Parse_Pos + Lower'Length - 1) =\n-                                                                      Lower\n+                    and then\n+                      E (Parse_Pos .. Parse_Pos + Lower'Length - 1) = Lower\n                   then\n                      if Invert then\n                         Class := ANYOF_NLOWER;\n                      else\n                         Class := ANYOF_LOWER;\n                      end if;\n+\n                      Parse_Pos := Parse_Pos + Lower'Length;\n+\n+                  else\n+                     Fail (\"Invalid character class: \" & E);\n                   end if;\n \n                when 'p' =>\n \n                   --  All 'p' classes have the same length\n \n                   if Parse_Pos + Print'Length - 1 <= Parse_End then\n-                     if E (Parse_Pos .. Parse_Pos + Print'Length - 1) =\n-                                                                      Print\n+                     if\n+                       E (Parse_Pos .. Parse_Pos + Print'Length - 1) = Print\n                      then\n                         if Invert then\n                            Class := ANYOF_NPRINT;\n@@ -1940,8 +1955,8 @@ package body GNAT.Regpat is\n \n                         Parse_Pos := Parse_Pos + Print'Length;\n \n-                     elsif E (Parse_Pos .. Parse_Pos + Punct'Length - 1) =\n-                                                                      Punct\n+                     elsif\n+                       E (Parse_Pos .. Parse_Pos + Punct'Length - 1) = Punct\n                      then\n                         if Invert then\n                            Class := ANYOF_NPUNCT;\n@@ -1950,13 +1965,19 @@ package body GNAT.Regpat is\n                         end if;\n \n                         Parse_Pos := Parse_Pos + Punct'Length;\n+\n+                     else\n+                        Fail (\"Invalid character class: \" & E);\n                      end if;\n+\n+                  else\n+                     Fail (\"Invalid character class: \" & E);\n                   end if;\n \n                when 's' =>\n                   if Parse_Pos + Space'Length - 1 <= Parse_End\n-                    and then E (Parse_Pos .. Parse_Pos + Space'Length - 1) =\n-                                                                      Space\n+                    and then\n+                      E (Parse_Pos .. Parse_Pos + Space'Length - 1) = Space\n                   then\n                      if Invert then\n                         Class := ANYOF_NSPACE;\n@@ -1965,41 +1986,49 @@ package body GNAT.Regpat is\n                      end if;\n \n                      Parse_Pos := Parse_Pos + Space'Length;\n+\n+                  else\n+                     Fail (\"Invalid character class: \" & E);\n                   end if;\n \n                when 'u' =>\n-\n                   if Parse_Pos + Upper'Length - 1 <= Parse_End\n-                    and then E (Parse_Pos .. Parse_Pos + Upper'Length - 1) =\n-                    Upper\n+                    and then\n+                      E (Parse_Pos .. Parse_Pos + Upper'Length - 1) = Upper\n                   then\n                      if Invert then\n                         Class := ANYOF_NUPPER;\n                      else\n                         Class := ANYOF_UPPER;\n                      end if;\n+\n                      Parse_Pos := Parse_Pos + Upper'Length;\n+\n+                  else\n+                     Fail (\"Invalid character class: \" & E);\n                   end if;\n \n                when 'w' =>\n-\n                   if Parse_Pos + Word'Length - 1 <= Parse_End\n-                    and then E (Parse_Pos .. Parse_Pos + Word'Length - 1) =\n-                    Word\n+                    and then\n+                      E (Parse_Pos .. Parse_Pos + Word'Length - 1) = Word\n                   then\n                      if Invert then\n                         Class := ANYOF_NALNUM;\n                      else\n                         Class := ANYOF_ALNUM;\n                      end if;\n+\n                      Parse_Pos := Parse_Pos + Word'Length;\n+\n+                  else\n+                     Fail (\"Invalid character class: \" & E);\n                   end if;\n \n                when 'x' =>\n-\n                   if Parse_Pos + Xdigit'Length - 1 <= Parse_End\n-                    and then E (Parse_Pos .. Parse_Pos + Xdigit'Length - 1)\n-                    = Digit\n+                    and then\n+                      E (Parse_Pos .. Parse_Pos + Xdigit'Length - 1) = Xdigit\n                   then\n                      if Invert then\n                         Class := ANYOF_NXDIGIT;\n@@ -2008,10 +2037,13 @@ package body GNAT.Regpat is\n                      end if;\n \n                      Parse_Pos := Parse_Pos + Xdigit'Length;\n+\n+                  else\n+                     Fail (\"Invalid character class: \" & E);\n                   end if;\n \n                when others =>\n-                  Fail (\"Invalid character class\");\n+                  Fail (\"Invalid character class: \" & E);\n             end case;\n \n          --  Character class not specified\n@@ -2072,7 +2104,6 @@ package body GNAT.Regpat is\n       Flags      : Regexp_Flags := No_Flags)\n    is\n       Size : Program_Size;\n-\n    begin\n       Compile (Matcher, Expression, Size, Flags);\n    end Compile;\n@@ -2082,10 +2113,6 @@ package body GNAT.Regpat is\n    ----------\n \n    procedure Dump (Self : Pattern_Matcher) is\n-\n-      --  Index  : Pointer := Program_First + 1;\n-      --  What is the above line for ???\n-\n       Op      : Opcode;\n       Program : Program_Data renames Self.Program;\n \n@@ -2106,14 +2133,14 @@ package body GNAT.Regpat is\n          Till   : Pointer;\n          Indent : Natural := 0)\n       is\n-         Next : Pointer;\n-         Index : Pointer := Start;\n+         Next         : Pointer;\n+         Index        : Pointer;\n          Local_Indent : Natural := Indent;\n-         Length : Pointer;\n+         Length       : Pointer;\n \n       begin\n+         Index := Start;\n          while Index < Till loop\n-\n             Op := Opcode'Val (Character'Pos ((Self.Program (Index))));\n \n             if Op = CLOSE then\n@@ -2296,7 +2323,6 @@ package body GNAT.Regpat is\n       C      : Character) return Boolean\n    is\n       Value : constant Class_Byte := Character'Pos (C);\n-\n    begin\n       return\n         (Bitmap (Value / 8) and Bit_Conversion (Value mod 8)) /= 0;\n@@ -2308,7 +2334,6 @@ package body GNAT.Regpat is\n \n    function Get_Next (Program : Program_Data; IP : Pointer) return Pointer is\n       Offset : constant Pointer := Get_Next_Offset (Program, IP);\n-\n    begin\n       if Offset = 0 then\n          return 0;\n@@ -2680,8 +2705,8 @@ package body GNAT.Regpat is\n                      Opnd    : Pointer  := String_Operand (Scan);\n                      Current : Positive := Input_Pos;\n \n-                     Last    : constant Pointer :=\n-                                 Opnd + String_Length (Program, Scan);\n+                     Last : constant Pointer :=\n+                              Opnd + String_Length (Program, Scan);\n \n                   begin\n                      while Opnd <= Last loop\n@@ -2697,7 +2722,6 @@ package body GNAT.Regpat is\n                when ANYOF =>\n                   declare\n                      Bitmap : Character_Class;\n-\n                   begin\n                      Bitmap_Operand (Program, Scan, Bitmap);\n                      exit State_Machine when Input_Pos > Last_In_Data\n@@ -2709,7 +2733,6 @@ package body GNAT.Regpat is\n                   declare\n                      No : constant Natural :=\n                             Character'Pos (Program (Operand (Scan)));\n-\n                   begin\n                      Matches_Tmp (No) := Input_Pos;\n                   end;\n@@ -2761,7 +2784,6 @@ package body GNAT.Regpat is\n                when STAR | PLUS | CURLY =>\n                   declare\n                      Greed : constant Boolean := Greedy;\n-\n                   begin\n                      Greedy := True;\n                      return Match_Simple_Operator (Op, Scan, Next, Greed);\n@@ -3492,11 +3514,8 @@ package body GNAT.Regpat is\n    --------------\n \n    procedure Optimize (Self : in out Pattern_Matcher) is\n-      Max_Length  : Program_Size;\n-      This_Length : Program_Size;\n-      Longest     : Pointer;\n-      Scan        : Pointer;\n-      Program     : Program_Data renames Self.Program;\n+      Scan    : Pointer;\n+      Program : Program_Data renames Self.Program;\n \n    begin\n       --  Start with safe defaults (no optimization):\n@@ -3520,33 +3539,6 @@ package body GNAT.Regpat is\n       then\n          Self.Anchored := True;\n       end if;\n-\n-      --  If there's something expensive in the regexp, find the\n-      --  longest literal string that must appear and make it the\n-      --  regmust. Resolve ties in favor of later strings, since\n-      --  the regstart check works with the beginning of the regexp.\n-      --  and avoiding duplication strengthens checking. Not a\n-      --  strong reason, but sufficient in the absence of others.\n-\n-      if False then -- if Flags.SP_Start then ???\n-         Longest := 0;\n-         Max_Length := 0;\n-         while Scan /= 0 loop\n-            if Program (Scan) = EXACT or else Program (Scan) = EXACTF then\n-               This_Length := String_Length (Program, Scan);\n-\n-               if This_Length >= Max_Length then\n-                  Longest := String_Operand (Scan);\n-                  Max_Length := This_Length;\n-               end if;\n-            end if;\n-\n-            Scan := Get_Next (Program, Scan);\n-         end loop;\n-\n-         Self.Must_Have        := Longest;\n-         Self.Must_Have_Length := Natural (Max_Length) + 1;\n-      end if;\n    end Optimize;\n \n    -----------------"}]}