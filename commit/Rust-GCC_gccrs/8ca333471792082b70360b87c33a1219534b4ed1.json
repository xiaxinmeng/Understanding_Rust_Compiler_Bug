{"sha": "8ca333471792082b70360b87c33a1219534b4ed1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNhMzMzNDcxNzkyMDgyYjcwMzYwYjg3YzMzYTEyMTk1MzRiNGVkMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-09-27T19:10:38Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-09-27T19:10:38Z"}, "message": "Implement P0018R3, C++17 lambda capture of *this by value as [=,*this]\n\n\tImplement P0018R3, C++17 lambda capture of *this by value as [=,*this]\n\t* parser.c (cp_parser_lambda_introducer): Formatting fix.  Pass\n\ttrue instead of false as by_reference_p to add_capture for 'this'.\n\tParse '*this' simple-capture.\n\t* lambda.c (build_capture_proxy): Handle '*this' capture by value.\n\t(add_capture): Adjust function comment.  For id == this_identifier,\n\ttreat by_reference_p as capturing '*this' by reference, i.e. 'this'\n\tby value, and !by_reference_p as capturing '*this' by value.\n\t(add_default_capture): For implicit 'this' capture, always pass\n\tby_reference_p true rather than false.\n\n\t* g++.dg/cpp1z/lambda-this1.C: New test.\n\t* g++.dg/cpp1z/lambda-this2.C: New test.\n\nFrom-SVN: r240556", "tree": {"sha": "2ca31d880419a194ebf4e7a0fe6a924476ebc7ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ca31d880419a194ebf4e7a0fe6a924476ebc7ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ca333471792082b70360b87c33a1219534b4ed1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ca333471792082b70360b87c33a1219534b4ed1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ca333471792082b70360b87c33a1219534b4ed1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ca333471792082b70360b87c33a1219534b4ed1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "459bcfb0bec5bb642685e0b54551995ab51fb156", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/459bcfb0bec5bb642685e0b54551995ab51fb156", "html_url": "https://github.com/Rust-GCC/gccrs/commit/459bcfb0bec5bb642685e0b54551995ab51fb156"}], "stats": {"total": 193, "additions": 188, "deletions": 5}, "files": [{"sha": "1a1f186e72665bd9d467df00e3e5c9bcffc2a1e1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca333471792082b70360b87c33a1219534b4ed1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca333471792082b70360b87c33a1219534b4ed1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8ca333471792082b70360b87c33a1219534b4ed1", "patch": "@@ -1,5 +1,16 @@\n 2016-09-27  Jakub Jelinek  <jakub@redhat.com>\n \n+\tImplement P0018R3, C++17 lambda capture of *this by value as [=,*this]\n+\t* parser.c (cp_parser_lambda_introducer): Formatting fix.  Pass\n+\ttrue instead of false as by_reference_p to add_capture for 'this'.\n+\tParse '*this' simple-capture.\n+\t* lambda.c (build_capture_proxy): Handle '*this' capture by value.\n+\t(add_capture): Adjust function comment.  For id == this_identifier,\n+\ttreat by_reference_p as capturing '*this' by reference, i.e. 'this'\n+\tby value, and !by_reference_p as capturing '*this' by value.\n+\t(add_default_capture): For implicit 'this' capture, always pass\n+\tby_reference_p true rather than false.\n+\n \tPR c++/77722\n \t* cp-gimplify.c (cp_ubsan_maybe_instrument_return): Instrument also\n \tfunctions that have just a STATEMENT_LIST instead of BIND_EXPR, or"}, {"sha": "cd322260c349a5dfe4eb7e6d4570369a3ab7b23e", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca333471792082b70360b87c33a1219534b4ed1/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca333471792082b70360b87c33a1219534b4ed1/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=8ca333471792082b70360b87c33a1219534b4ed1", "patch": "@@ -380,6 +380,13 @@ build_capture_proxy (tree member)\n \n   type = lambda_proxy_type (object);\n \n+  if (name == this_identifier && !POINTER_TYPE_P (type))\n+    {\n+      type = build_pointer_type (type);\n+      type = cp_build_qualified_type (type, TYPE_QUAL_CONST);\n+      object = build_fold_addr_expr_with_type (object, type);\n+    }\n+\n   if (DECL_VLA_CAPTURE_P (member))\n     {\n       /* Rebuild the VLA type from the pointer and maxindex.  */\n@@ -440,7 +447,8 @@ vla_capture_type (tree array_type)\n \n /* From an ID and INITIALIZER, create a capture (by reference if\n    BY_REFERENCE_P is true), add it to the capture-list for LAMBDA,\n-   and return it.  */\n+   and return it.  If ID is `this', BY_REFERENCE_P says whether\n+   `*this' is captured by reference.  */\n \n tree\n add_capture (tree lambda, tree id, tree orig_init, bool by_reference_p,\n@@ -499,7 +507,14 @@ add_capture (tree lambda, tree id, tree orig_init, bool by_reference_p,\n       type = lambda_capture_field_type (initializer, explicit_init_p);\n       if (type == error_mark_node)\n \treturn error_mark_node;\n-      if (by_reference_p)\n+      if (id == this_identifier && !by_reference_p)\n+\t{\n+\t  gcc_assert (POINTER_TYPE_P (type));\n+\t  type = TREE_TYPE (type);\n+\t  initializer = cp_build_indirect_ref (initializer, RO_NULL,\n+\t\t\t\t\t       tf_warning_or_error);\n+\t}\n+      if (id != this_identifier && by_reference_p)\n \t{\n \t  type = build_reference_type (type);\n \t  if (!dependent_type_p (type) && !lvalue_p (initializer))\n@@ -628,8 +643,8 @@ add_default_capture (tree lambda_stack, tree id, tree initializer)\n                             id,\n                             initializer,\n                             /*by_reference_p=*/\n-\t\t\t    (!this_capture_p\n-\t\t\t     && (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda)\n+\t\t\t    (this_capture_p\n+\t\t\t     || (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda)\n \t\t\t\t == CPLD_REFERENCE)),\n \t\t\t    /*explicit_init_p=*/false);\n       initializer = convert_from_reference (var);"}, {"sha": "f672b8de18859f65ff60e4f8bc3e6ee68ce9cb4e", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca333471792082b70360b87c33a1219534b4ed1/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca333471792082b70360b87c33a1219534b4ed1/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=8ca333471792082b70360b87c33a1219534b4ed1", "patch": "@@ -9899,7 +9899,25 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n \t  cp_lexer_consume_token (parser->lexer);\n \t  add_capture (lambda_expr,\n \t\t       /*id=*/this_identifier,\n-\t\t       /*initializer=*/finish_this_expr(),\n+\t\t       /*initializer=*/finish_this_expr (),\n+\t\t       /*by_reference_p=*/true,\n+\t\t       explicit_init_p);\n+\t  continue;\n+\t}\n+\n+      /* Possibly capture `*this'.  */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_MULT)\n+\t  && cp_lexer_nth_token_is_keyword (parser->lexer, 2, RID_THIS))\n+\t{\n+\t  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+\t  if (cxx_dialect < cxx1z)\n+\t    pedwarn (loc, 0, \"%<*this%> capture only available with \"\n+\t\t\t     \"-std=c++1z or -std=gnu++1z\");\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  add_capture (lambda_expr,\n+\t\t       /*id=*/this_identifier,\n+\t\t       /*initializer=*/finish_this_expr (),\n \t\t       /*by_reference_p=*/false,\n \t\t       explicit_init_p);\n \t  continue;"}, {"sha": "59e20b7c049807231d1ef49f7f67c55f277190b3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca333471792082b70360b87c33a1219534b4ed1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca333471792082b70360b87c33a1219534b4ed1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8ca333471792082b70360b87c33a1219534b4ed1", "patch": "@@ -1,5 +1,8 @@\n 2016-09-27  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* g++.dg/cpp1z/lambda-this1.C: New test.\n+\t* g++.dg/cpp1z/lambda-this2.C: New test.\n+\n \tPR c++/77722\n \t* g++.dg/ubsan/return-4.C: New test.\n \t* g++.dg/ubsan/return-5.C: New test."}, {"sha": "5a4c5f96b2dda6fe4fd29c83903998db4acf8dc7", "filename": "gcc/testsuite/g++.dg/cpp1z/lambda-this1.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca333471792082b70360b87c33a1219534b4ed1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Flambda-this1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca333471792082b70360b87c33a1219534b4ed1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Flambda-this1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Flambda-this1.C?ref=8ca333471792082b70360b87c33a1219534b4ed1", "patch": "@@ -0,0 +1,68 @@\n+// P0018R3 - C++17 lambda capture of *this\n+// { dg-do compile { target c++11 } }\n+\n+struct A {\n+  int a;\n+  void foo () {\n+    int v = 4;\n+    auto b = [*this, this] {};\t\t// { dg-error \"already captured 'this'\" }\n+\t\t\t\t\t// { dg-error \"'*this' capture only available with\" \"\" { target c++14_down } .-1 }\n+    auto c = [this, *this] {};\t\t// { dg-error \"already captured 'this'\" }\n+\t\t\t\t\t// { dg-error \"'*this' capture only available with\" \"\" { target c++14_down } .-1 }\n+    auto d = [this] { return a; };\n+    auto e = [*this] { return a; };\t// { dg-error \"'*this' capture only available with\" \"\" { target c++14_down } }\n+    auto f = [this] { a++; };\n+    auto g = [*this] { a++; };\t\t// { dg-error \"in read-only object\" }\n+\t\t\t\t\t// { dg-error \"'*this' capture only available with\" \"\" { target c++14_down } .-1 }\n+    auto h = [*this] () mutable { a++; };// { dg-error \"'*this' capture only available with\" \"\" { target c++14_down } }\n+    auto i = [=] { return a; };\n+    auto j = [&] { return a; };\n+    auto k = [=, this] { return a; };// { dg-error \"explicit by-copy capture of 'this' redundant with by-copy capture default\" }\n+    auto l = [&, this] { return a; };\n+    auto m = [=, *this] { return a; };// { dg-error \"'*this' capture only available with\" \"\" { target c++14_down } }\n+    auto n = [&, *this] { return a; };// { dg-error \"'*this' capture only available with\" \"\" { target c++14_down } }\n+    auto o = [*this, &v] { return a + v; };// { dg-error \"'*this' capture only available with\" \"\" { target c++14_down } }\n+    auto p = [*this] { this = 0; };\t// { dg-error \"lvalue required as left operand of assignment\" }\n+\t\t\t\t\t// { dg-error \"'*this' capture only available with\" \"\" { target c++14_down } .-1 }\n+  }\n+};\n+struct B {\n+  double b;\n+  B () : b (.007) {}\n+  double foo () {\n+    return [this]{ return [*this] { return b; }; }()();\t// { dg-error \"'*this' capture only available with\" \"\" { target c++14_down } }\n+  }\n+  double bar () {\n+    auto c = []{ return [*this] { return b; }; };\t// { dg-error \"'this' was not captured for this lambda function\" }\n+  }\t\t\t\t\t\t\t// { dg-error \"invalid use of non-static data member 'B::b'\" \"\" { target *-*-* } .-1 }\n+};\t\t\t\t\t\t\t// { dg-error \"'*this' capture only available with\" \"\" { target c++14_down } .-2 }\n+struct C {\n+  int c;\n+  C (const C &) = delete;\n+  void bar () const;\n+  void foo () {\n+    auto d = [this] { return c; };\n+    auto e = [*this] { return c; };\t// { dg-error \"use of deleted function\" }\n+\t\t\t\t\t// { dg-error \"'*this' capture only available with\" \"\" { target c++14_down } .-1 }\n+    auto f = [=] { return c; };\n+    auto g = [&] { return c; };\n+    auto h = [this] { bar (); };\n+    auto i = [*this] { bar (); };\t// { dg-error \"use of deleted function\" }\n+\t\t\t\t\t// { dg-error \"'*this' capture only available with\" \"\" { target c++14_down } .-1 }\n+  }\n+};\n+struct D {\n+  int d;\n+  ~D () = delete;\n+  void bar () const;\n+  void foo () {\n+    auto e = [this] { return d; };\n+    auto f = [*this] { return d; };\t// { dg-error \"use of deleted function\" }\n+\t\t\t\t\t// { dg-error \"'*this' capture only available with\" \"\" { target c++14_down } .-1 }\n+    auto g = [=] { return d; };\n+    auto h = [&] { return d; };\n+    auto i = [this] { bar (); };\n+    auto j = [*this] { bar (); };\t// { dg-error \"use of deleted function\" }\n+\t\t\t\t\t// { dg-error \"'*this' capture only available with\" \"\" { target c++14_down } .-1 }\n+  }\n+};"}, {"sha": "5a0066d750b01f324b81adb074462c2b16a64b59", "filename": "gcc/testsuite/g++.dg/cpp1z/lambda-this2.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ca333471792082b70360b87c33a1219534b4ed1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Flambda-this2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ca333471792082b70360b87c33a1219534b4ed1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Flambda-this2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Flambda-this2.C?ref=8ca333471792082b70360b87c33a1219534b4ed1", "patch": "@@ -0,0 +1,68 @@\n+// P0018R3 - C++17 lambda capture of *this\n+// { dg-do run { target c++11 } }\n+// { dg-options \"\" }\n+\n+extern \"C\" void abort ();\n+\n+struct A {\n+  int a, z;\n+  A () : a (4), z (0) {}\n+  A (const A &x) : a (x.a), z (1) {}\n+  void foo () {\n+    if (z != 0) abort ();\n+    auto b = [this] { return &a; };\n+    auto c = [*this] { return &a; };\t// { dg-warning \"'*this' capture only available with\" \"\" { target c++14_down } }\n+    auto d = [=] { return &a; };\n+    auto e = [&] { return &a; };\n+    if (b () != &a) abort ();\n+    if (*b () != 4) abort ();\n+    auto f = c ();\n+    if (c () == &a) abort ();\n+    if (c () != f) abort ();\n+    if (*c () != 4) abort ();\n+    if (d () != &a) abort ();\n+    if (e () != &a) abort ();\n+    auto g = [this] { return a + z; };\n+    auto h = [*this] { return a + z; };\t// { dg-warning \"'*this' capture only available with\" \"\" { target c++14_down } }\n+    auto i = [=] { return a + z; };\n+    auto j = [&] { return a + z; };\n+    if (g () != 4 || h () != 5 || i () != 4 || j () != 4) abort ();\n+  }\n+};\n+\n+template <int N>\n+struct B {\n+  int a, z;\n+  B () : a (N), z (0) {}\n+  B (const B &x) : a (x.a), z (1) {}\n+  void foo () {\n+    if (z != 0) abort ();\n+    auto b = [this] { return &a; };\n+    auto c = [*this] { return &a; };\t// { dg-warning \"'*this' capture only available with\" \"\" { target c++14_down } }\n+    auto d = [=] { return &a; };\n+    auto e = [&] { return &a; };\n+    if (b () != &a) abort ();\n+    if (*b () != 9) abort ();\n+    auto f = c ();\n+    if (c () == &a) abort ();\n+    if (c () != f) abort ();\n+    if (*c () != 9) abort ();\n+    if (d () != &a) abort ();\n+    if (e () != &a) abort ();\n+    auto g = [this] { return a + z; };\n+    auto h = [*this] { return a + z; };\t// { dg-warning \"'*this' capture only available with\" \"\" { target c++14_down } }\n+    auto i = [=] { return a + z; };\n+    auto j = [&] { return a + z; };\n+    if (g () != 9 || h () != 10 || i () != 9 || j () != 9) abort ();\n+  }\n+};\n+\n+int\n+main ()\n+{\n+  A a;\n+  a.foo ();\n+  B<9> b;\n+  b.foo ();\n+  return 0;\n+}"}]}