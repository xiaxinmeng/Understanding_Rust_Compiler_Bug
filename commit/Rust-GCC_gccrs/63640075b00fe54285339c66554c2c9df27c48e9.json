{"sha": "63640075b00fe54285339c66554c2c9df27c48e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM2NDAwNzViMDBmZTU0Mjg1MzM5YzY2NTU0YzJjOWRmMjdjNDhlOQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-02-13T07:45:58Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-02-13T07:45:58Z"}, "message": "FileBasedFactory.java, [...]: New files, all merged from classpath.\n\n2003-02-13  Michael Koch  <konqueror@gmx.de>\n\n\t* gnu/java/util/prefs/FileBasedFactory.java,\n\tgnu/java/util/prefs/MemmoryBasedFactory.java,\n\tgnu/java/util/prefs/MemoryBasedPreferences.java,\n\tgnu/java/util/prefs/NodeReader.java,\n\tgnu/java/util/prefs/NodeWriter.java,\n\tjava/util/prefs/AbstractPreferences.java,\n\tjava/util/prefs/BackingStoreException.java,\n\tjava/util/prefs/InvalidPreferencesFormatException.java,\n\tjava/util/prefs/NodeChangeEvent.java,\n\tjava/util/prefs/NodeChangeListener.java,\n\tjava/util/prefs/PreferenceChangeEvent.java,\n\tjava/util/prefs/PreferenceChangeListener.java,\n\tjava/util/prefs/Preferences.java,\n\tjava/util/prefs/PreferencesFactory.java:\n\tNew files, all merged from classpath.\n\t* Makefile.am\n\t(ordinary_java_source_files): Added the following files:\n\tgnu/java/util/prefs/FileBasedFactory.java,\n\tgnu/java/util/prefs/MemmoryBasedFactory.java,\n\tgnu/java/util/prefs/MemoryBasedPreferences.java,\n\tgnu/java/util/prefs/NodeReader.java,\n\tgnu/java/util/prefs/NodeWriter.java,\n\t(core_java_source_files): Added the following files:\n\tjava/util/prefs/AbstractPreferences.java,\n\tjava/util/prefs/BackingStoreException.java,\n\tjava/util/prefs/InvalidPreferencesFormatException.java,\n\tjava/util/prefs/NodeChangeEvent.java,\n\tjava/util/prefs/NodeChangeListener.java,\n\tjava/util/prefs/PreferenceChangeEvent.java,\n\tjava/util/prefs/PreferenceChangeListener.java,\n\tjava/util/prefs/Preferences.java,\n\tjava/util/prefs/PreferencesFactory.java\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r62827", "tree": {"sha": "1f52ec60a1a35a2edd275cfc8f649261d954d0f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f52ec60a1a35a2edd275cfc8f649261d954d0f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63640075b00fe54285339c66554c2c9df27c48e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63640075b00fe54285339c66554c2c9df27c48e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63640075b00fe54285339c66554c2c9df27c48e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63640075b00fe54285339c66554c2c9df27c48e9/comments", "author": null, "committer": null, "parents": [{"sha": "31aef004ee5fd91f341be1bf7ee107b93128e634", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31aef004ee5fd91f341be1bf7ee107b93128e634", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31aef004ee5fd91f341be1bf7ee107b93128e634"}], "stats": {"total": 3411, "additions": 3410, "deletions": 1}, "files": [{"sha": "16491e6d026eef55248aa4027e141c5b86dd0cad", "filename": "libjava/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=63640075b00fe54285339c66554c2c9df27c48e9", "patch": "@@ -1,3 +1,39 @@\n+2003-02-13  Michael Koch  <konqueror@gmx.de>\n+ \n+\t* gnu/java/util/prefs/FileBasedFactory.java,\n+\tgnu/java/util/prefs/MemmoryBasedFactory.java,\n+\tgnu/java/util/prefs/MemoryBasedPreferences.java,\n+\tgnu/java/util/prefs/NodeReader.java,\n+\tgnu/java/util/prefs/NodeWriter.java,\n+\tjava/util/prefs/AbstractPreferences.java,\n+\tjava/util/prefs/BackingStoreException.java,\n+\tjava/util/prefs/InvalidPreferencesFormatException.java,\n+\tjava/util/prefs/NodeChangeEvent.java,\n+\tjava/util/prefs/NodeChangeListener.java,\n+\tjava/util/prefs/PreferenceChangeEvent.java,\n+\tjava/util/prefs/PreferenceChangeListener.java,\n+\tjava/util/prefs/Preferences.java,\n+\tjava/util/prefs/PreferencesFactory.java:\n+\tNew files, all merged from classpath.\n+\t* Makefile.am\n+\t(ordinary_java_source_files): Added the following files:\n+\tgnu/java/util/prefs/FileBasedFactory.java,\n+\tgnu/java/util/prefs/MemmoryBasedFactory.java,\n+\tgnu/java/util/prefs/MemoryBasedPreferences.java,\n+\tgnu/java/util/prefs/NodeReader.java,\n+\tgnu/java/util/prefs/NodeWriter.java,\n+\t(core_java_source_files): Added the following files:\n+\tjava/util/prefs/AbstractPreferences.java,\n+\tjava/util/prefs/BackingStoreException.java,\n+\tjava/util/prefs/InvalidPreferencesFormatException.java,\n+\tjava/util/prefs/NodeChangeEvent.java,\n+\tjava/util/prefs/NodeChangeListener.java,\n+\tjava/util/prefs/PreferenceChangeEvent.java,\n+\tjava/util/prefs/PreferenceChangeListener.java,\n+\tjava/util/prefs/Preferences.java,\n+\tjava/util/prefs/PreferencesFactory.java\n+\t* Makefile.in: Regenerated.\n+ \n 2003-02-13  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/NetPermission.java"}, {"sha": "9b4d23b6074ae981d29b2a38f7d5e55dc0574b5c", "filename": "libjava/Makefile.am", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=63640075b00fe54285339c66554c2c9df27c48e9", "patch": "@@ -1855,6 +1855,15 @@ java/util/TreeSet.java \\\n java/util/TooManyListenersException.java \\\n java/util/Vector.java \\\n java/util/WeakHashMap.java \\\n+java/util/prefs/NodeChangeListener.java \\\n+java/util/prefs/Preferences.java \\\n+java/util/prefs/PreferenceChangeListener.java \\\n+java/util/prefs/NodeChangeEvent.java \\\n+java/util/prefs/InvalidPreferencesFormatException.java \\\n+java/util/prefs/AbstractPreferences.java \\\n+java/util/prefs/BackingStoreException.java \\\n+java/util/prefs/PreferenceChangeEvent.java \\\n+java/util/prefs/PreferencesFactory.java \\\n java/util/regex/Matcher.java \\\n java/util/regex/Pattern.java \\\n java/util/regex/PatternSyntaxException.java\n@@ -2075,6 +2084,11 @@ gnu/java/text/SentenceBreakIterator.java \\\n gnu/java/text/WordBreakIterator.java \\\n gnu/java/util/DoubleEnumeration.java \\\n gnu/java/util/EmptyEnumeration.java \\\n+gnu/java/util/prefs/MemoryBasedFactory.java \\\n+gnu/java/util/prefs/NodeReader.java \\\n+gnu/java/util/prefs/MemoryBasedPreferences.java \\\n+gnu/java/util/prefs/FileBasedFactory.java \\\n+gnu/java/util/prefs/NodeWriter.java \\\n java/lang/ref/PhantomReference.java \\\n java/lang/ref/Reference.java \\\n java/lang/ref/ReferenceQueue.java \\"}, {"sha": "25c333b07a1626a483584267dd84bbf235e41e65", "filename": "libjava/Makefile.in", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=63640075b00fe54285339c66554c2c9df27c48e9", "patch": "@@ -1620,6 +1620,15 @@ java/util/TreeSet.java \\\n java/util/TooManyListenersException.java \\\n java/util/Vector.java \\\n java/util/WeakHashMap.java \\\n+java/util/prefs/NodeChangeListener.java \\\n+java/util/prefs/Preferences.java \\\n+java/util/prefs/PreferenceChangeListener.java \\\n+java/util/prefs/NodeChangeEvent.java \\\n+java/util/prefs/InvalidPreferencesFormatException.java \\\n+java/util/prefs/AbstractPreferences.java \\\n+java/util/prefs/BackingStoreException.java \\\n+java/util/prefs/PreferenceChangeEvent.java \\\n+java/util/prefs/PreferencesFactory.java \\\n java/util/regex/Matcher.java \\\n java/util/regex/Pattern.java \\\n java/util/regex/PatternSyntaxException.java\n@@ -1835,6 +1844,11 @@ gnu/java/text/SentenceBreakIterator.java \\\n gnu/java/text/WordBreakIterator.java \\\n gnu/java/util/DoubleEnumeration.java \\\n gnu/java/util/EmptyEnumeration.java \\\n+gnu/java/util/prefs/MemoryBasedFactory.java \\\n+gnu/java/util/prefs/NodeReader.java \\\n+gnu/java/util/prefs/MemoryBasedPreferences.java \\\n+gnu/java/util/prefs/FileBasedFactory.java \\\n+gnu/java/util/prefs/NodeWriter.java \\\n java/lang/ref/PhantomReference.java \\\n java/lang/ref/Reference.java \\\n java/lang/ref/ReferenceQueue.java \\\n@@ -2912,7 +2926,12 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/text/SentenceBreakIterator.P \\\n .deps/gnu/java/text/WordBreakIterator.P \\\n .deps/gnu/java/util/DoubleEnumeration.P \\\n-.deps/gnu/java/util/EmptyEnumeration.P .deps/interpret.P \\\n+.deps/gnu/java/util/EmptyEnumeration.P \\\n+.deps/gnu/java/util/prefs/FileBasedFactory.P \\\n+.deps/gnu/java/util/prefs/MemoryBasedFactory.P \\\n+.deps/gnu/java/util/prefs/MemoryBasedPreferences.P \\\n+.deps/gnu/java/util/prefs/NodeReader.P \\\n+.deps/gnu/java/util/prefs/NodeWriter.P .deps/interpret.P \\\n .deps/java/applet/Applet.P .deps/java/applet/AppletContext.P \\\n .deps/java/applet/AppletStub.P .deps/java/applet/AudioClip.P \\\n .deps/java/awt/AWTError.P .deps/java/awt/AWTEvent.P \\\n@@ -3604,6 +3623,15 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/util/jar/JarInputStream.P \\\n .deps/java/util/jar/JarOutputStream.P .deps/java/util/jar/Manifest.P \\\n .deps/java/util/natResourceBundle.P .deps/java/util/natTimeZone.P \\\n+.deps/java/util/prefs/AbstractPreferences.P \\\n+.deps/java/util/prefs/BackingStoreException.P \\\n+.deps/java/util/prefs/InvalidPreferencesFormatException.P \\\n+.deps/java/util/prefs/NodeChangeEvent.P \\\n+.deps/java/util/prefs/NodeChangeListener.P \\\n+.deps/java/util/prefs/PreferenceChangeEvent.P \\\n+.deps/java/util/prefs/PreferenceChangeListener.P \\\n+.deps/java/util/prefs/Preferences.P \\\n+.deps/java/util/prefs/PreferencesFactory.P \\\n .deps/java/util/regex/Matcher.P .deps/java/util/regex/Pattern.P \\\n .deps/java/util/regex/PatternSyntaxException.P \\\n .deps/java/util/zip/Adler32.P .deps/java/util/zip/CRC32.P \\"}, {"sha": "fc6085feeb5fa2d030da5cb200a71a2300da0ece", "filename": "libjava/gnu/java/util/prefs/FileBasedFactory.java", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fgnu%2Fjava%2Futil%2Fprefs%2FFileBasedFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fgnu%2Fjava%2Futil%2Fprefs%2FFileBasedFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Futil%2Fprefs%2FFileBasedFactory.java?ref=63640075b00fe54285339c66554c2c9df27c48e9", "patch": "@@ -0,0 +1,57 @@\n+/* FileBasedFactory - Default Classpath implementation of a PreferencesFactory\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.util.prefs;\n+\n+import java.util.prefs.*;\n+\n+/**\n+ * Default Classpath implementation of a PreferencesFactory.\n+ * Returns system and user root Preferences nodes that are read from files.\n+ *\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public class FileBasedFactory implements PreferencesFactory {\n+\n+    public Preferences systemRoot() {\n+        return null;\n+    }\n+\n+    public Preferences userRoot() {\n+        return null;\n+    }\n+}"}, {"sha": "ff21066d393c762d17b1e30e4c760bc98e98c2c7", "filename": "libjava/gnu/java/util/prefs/MemoryBasedFactory.java", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fgnu%2Fjava%2Futil%2Fprefs%2FMemoryBasedFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fgnu%2Fjava%2Futil%2Fprefs%2FMemoryBasedFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Futil%2Fprefs%2FMemoryBasedFactory.java?ref=63640075b00fe54285339c66554c2c9df27c48e9", "patch": "@@ -0,0 +1,64 @@\n+/* MemoryBasedFactory - Memory based PreferencesFactory usefull for testing\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.util.prefs;\n+\n+import java.util.prefs.*;\n+\n+/**\n+ * Memory based PreferencesFactory usefull for testing.\n+ * Returns completely empty Preferences for system and user roots.\n+ * All changes are only backed by the current instances in memory.\n+ *\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public class MemoryBasedFactory implements PreferencesFactory {\n+\n+    // Static fields containing the preferences root nodes\n+    private static final Preferences systemPreferences\n+        = new MemoryBasedPreferences(null, \"\", false);\n+    private static final Preferences userPreferences\n+        = new MemoryBasedPreferences(null, \"\", true);\n+\n+    public Preferences systemRoot() {\n+        return systemPreferences;\n+    }\n+\n+    public Preferences userRoot() {\n+        return userPreferences;\n+    }\n+}"}, {"sha": "c1d59c7b1c9cd6b54f762c9a8a8e57a3c2c75272", "filename": "libjava/gnu/java/util/prefs/MemoryBasedPreferences.java", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fgnu%2Fjava%2Futil%2Fprefs%2FMemoryBasedPreferences.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fgnu%2Fjava%2Futil%2Fprefs%2FMemoryBasedPreferences.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Futil%2Fprefs%2FMemoryBasedPreferences.java?ref=63640075b00fe54285339c66554c2c9df27c48e9", "patch": "@@ -0,0 +1,144 @@\n+/* MemoryBasedPreferences - A Preference node which holds all entries in memory\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.util.prefs;\n+\n+import java.util.HashMap;\n+\n+import java.util.prefs.*;\n+\n+/**\n+ * A Preference node which holds all entries in memory\n+ *\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public class MemoryBasedPreferences extends AbstractPreferences {\n+\n+    /** True if this is a preference node in the user tree, false otherwise. */\n+    private final boolean isUser;\n+\n+    /** Contains all the preference entries of this node. */\n+    private HashMap entries = new HashMap();\n+\n+    /**\n+     * Creates a new preferences node with the given name and parent.\n+     * When isUser is true it will be user node otherwise it will be a system\n+     * node. It will always set the <code>newNode</code> field to true\n+     * since there is no real backing store, so all nodes are new.\n+     */\n+    public MemoryBasedPreferences(MemoryBasedPreferences parent,\n+                                  String name,\n+                                  boolean isUser) {\n+        super(parent, name);\n+        this.isUser = isUser;\n+\n+        // Since we do not have a real backing store all nodes are new\n+        newNode = true;\n+    }\n+\n+    /**\n+     * Returns true if this node was created as a user node.\n+     */\n+    public boolean isUserNode() {\n+        return isUser;\n+    }\n+\n+    /**\n+     * Returns an empty array since all children names are always already\n+     * chached.\n+     */\n+    protected String[] childrenNamesSpi() throws BackingStoreException {\n+        return new String[0];\n+    }\n+\n+    /**\n+     * Returns a new node with the given name with as parent this node and\n+     * with the <code>isUser</code> flag set to the same value as this node.\n+     */\n+    protected AbstractPreferences childSpi(String childName) {\n+       return new MemoryBasedPreferences(this, childName, isUser);\n+    }\n+\n+    /**\n+     * Returns a (possibly empty) array of keys of the preferences entries of\n+     * this node.\n+     */\n+    protected String[] keysSpi() throws BackingStoreException {\n+        return (String[]) entries.keySet().toArray(new String[entries.size()]);\n+    }\n+\n+    /**\n+     * Returns the associated value from this nodes preferences entries or\n+     * null when the key has not been set.\n+     */\n+    protected String getSpi(String key) {\n+        return (String) entries.get(key);\n+    }\n+\n+    /**\n+     * Sets the value for the given key.\n+     */\n+    protected void putSpi(String key, String value) {\n+        entries.put(key, value);\n+    }\n+\n+    /**\n+     * Removes the entry with the given key.\n+     */\n+    protected void removeSpi(String key) {\n+        entries.remove(key);\n+    }\n+\n+    /**\n+     * Does nothing since we do not have any backing store.\n+     */\n+    protected void flushSpi() {\n+    }\n+\n+    /**\n+     * Does nothing since we do not have any backing store.\n+     */\n+    protected void syncSpi() {\n+    }\n+\n+    /**\n+     * Just removes the entries map of this node.\n+     */\n+    protected void removeNodeSpi() {\n+        entries = null;\n+    }\n+}"}, {"sha": "6c9fdc9ec061968d90e1394749d26bd3d6bd097e", "filename": "libjava/gnu/java/util/prefs/NodeReader.java", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fgnu%2Fjava%2Futil%2Fprefs%2FNodeReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fgnu%2Fjava%2Futil%2Fprefs%2FNodeReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Futil%2Fprefs%2FNodeReader.java?ref=63640075b00fe54285339c66554c2c9df27c48e9", "patch": "@@ -0,0 +1,223 @@\n+/* NodeReader - Reads and imports preferences nodes from files\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.util.prefs;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.Reader;\n+\n+import java.util.prefs.*;\n+\n+/**\n+ * Reads and imports preferences nodes from files.\n+ *\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public class NodeReader {\n+\n+    private final BufferedReader br;\n+    private String line = \"\";\n+\n+    private final PreferencesFactory factory;\n+\n+    public NodeReader(Reader r, PreferencesFactory factory) {\n+        if(r instanceof BufferedReader) {\n+            br = (BufferedReader) r;\n+        } else {\n+            br = new BufferedReader(r);\n+        }\n+        this.factory = factory;\n+    }\n+\n+    public NodeReader(InputStream is, PreferencesFactory factory) {\n+        this(new InputStreamReader(is), factory);\n+    }\n+\n+    public void importPreferences()\n+                    throws InvalidPreferencesFormatException, IOException\n+    {\n+        readPreferences();\n+    }\n+\n+    private void readPreferences()\n+                    throws InvalidPreferencesFormatException, IOException\n+    {\n+        // Begin starting tag\n+        skipTill(\"<preferences\");\n+\n+        readRoot();\n+\n+        // Ending tag\n+        skipTill(\"</preferences>\");\n+    }\n+\n+    private void readRoot()\n+                    throws InvalidPreferencesFormatException, IOException\n+    {\n+        // Begin starting tag\n+        skipTill(\"<root\");\n+\n+        // type attribute\n+        skipTill(\"type=\\\"\");\n+        String type = readTill(\"\\\"\");\n+        Preferences root;\n+        if (\"user\".equals(type)) {\n+            root = factory.userRoot();\n+        } else if (\"system\".equals(type)) {\n+            root = factory.systemRoot();\n+        } else {\n+            throw new InvalidPreferencesFormatException(\"Unknown type: \"\n+                                                        + type);\n+        }\n+\n+        // Read root map and subnodes\n+        readMap(root);\n+        readNodes(root);\n+\n+        // Ending tag\n+        skipTill(\"</root>\");\n+    }\n+\n+    private void readNodes(Preferences node)\n+                    throws InvalidPreferencesFormatException, IOException\n+    {\n+        while (\"node\".equals(nextTag())) {\n+            skipTill(\"<node\");\n+            skipTill(\"name=\\\"\");\n+            String name = readTill(\"\\\"\");\n+            Preferences subnode = node.node(name);\n+            System.out.println(\"Found subnode: \" + subnode.absolutePath());\n+            readMap(subnode);\n+            readNodes(subnode);\n+            skipTill(\"</node>\");\n+        }\n+        \n+    }\n+\n+    private void readMap(Preferences node)\n+                    throws InvalidPreferencesFormatException, IOException\n+    {\n+        // Begin map tag\n+        skipTill(\"<map\");\n+\n+        // Empty map?\n+        if (line.startsWith(\"/>\")) {\n+            line = line.substring(2);\n+            return;\n+        }\n+\n+        // Map entries\n+        readEntries(node);\n+\n+        // Ending tag\n+        skipTill(\"</map>\");\n+    }\n+\n+    private void readEntries(Preferences node)\n+                    throws InvalidPreferencesFormatException, IOException\n+    {\n+        while (\"entry\".equals(nextTag())) {\n+            skipTill(\"<entry\");\n+            skipTill(\"key=\\\"\");\n+            String key = readTill(\"\\\"\");\n+            skipTill(\"value=\\\"\");\n+            String value = readTill(\"\\\"\");\n+            System.out.println(\"Key: \" + key + \" Value: \" + value);\n+            node.put(key, value);\n+        }\n+    }\n+\n+    private void skipTill(String s)\n+                    throws InvalidPreferencesFormatException, IOException\n+    {\n+        while(true) {\n+            if (line == null)\n+                throw new InvalidPreferencesFormatException(s + \" not found\");\n+            \n+            int index = line.indexOf(s);\n+            if (index == -1)  {\n+                line = br.readLine();\n+            } else {\n+                line = line.substring(index+s.length());\n+                return;\n+            }\n+        }\n+    }\n+\n+    private String readTill(String s)\n+                    throws InvalidPreferencesFormatException\n+    {\n+        int index = line.indexOf(s);\n+        if (index == -1)\n+                throw new InvalidPreferencesFormatException(s + \" not found\");\n+\n+        String read = line.substring(0, index);\n+        line = line.substring(index+s.length());\n+\n+        return read;\n+    }\n+\n+    private String nextTag()\n+                    throws InvalidPreferencesFormatException, IOException\n+    {\n+        while(true) {\n+            if (line == null)\n+                throw new InvalidPreferencesFormatException(\"unexpected EOF\");\n+            \n+            int start = line.indexOf(\"<\");\n+            if (start == -1)  {\n+                line = br.readLine();\n+            } else {\n+                // Find end of tag\n+                int end = start+1;\n+                while (end != line.length()\n+                       && \" \\t\\r\\n\".indexOf(line.charAt(end)) == -1) {\n+                    end++;\n+                }\n+                // Line now starts at the found tag\n+                String tag = line.substring(start+1,end);\n+                line = line.substring(start);\n+                return tag;\n+            }\n+        }\n+    }\n+\n+}"}, {"sha": "d570d99af60ed08d59735920333dd5f8cf14c296", "filename": "libjava/gnu/java/util/prefs/NodeWriter.java", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fgnu%2Fjava%2Futil%2Fprefs%2FNodeWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fgnu%2Fjava%2Futil%2Fprefs%2FNodeWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Futil%2Fprefs%2FNodeWriter.java?ref=63640075b00fe54285339c66554c2c9df27c48e9", "patch": "@@ -0,0 +1,315 @@\n+/* NodeWriter - Writes and exports preferences nodes to files\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.util.prefs;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.Writer;\n+\n+import java.util.StringTokenizer;\n+\n+import java.util.prefs.*;\n+\n+/**\n+ * Writes and exports preferences nodes to files\n+ *\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public class NodeWriter {\n+\n+    /** The Preferences node to write. */\n+    private final Preferences prefs;\n+\n+    /** The bufferedWriter to write the node to. */\n+    private final BufferedWriter bw;\n+\n+    /**\n+     * True if the complete sub tree should be written,\n+     * false if only the node should be written.\n+     */\n+    private boolean subtree;\n+\n+    /**\n+     * Creates a new NodeWriter for the given preferences node and writer.\n+     */\n+    public NodeWriter(Preferences prefs, Writer w) {\n+        this.prefs = prefs;\n+        if (w instanceof BufferedWriter) {\n+            this.bw = (BufferedWriter) w;\n+        } else {\n+            this.bw = new BufferedWriter(w);\n+        }\n+    }\n+\n+    /**\n+     * Creates a new NodeWriter for the given preferences node and\n+     * outputstream. Creates a new OutputStreamWriter.\n+     */\n+    public NodeWriter(Preferences prefs, OutputStream os) {\n+        this(prefs, new OutputStreamWriter(os));\n+    }\n+\n+    /**\n+     * Writes the preference node plus the complete subtree.\n+     */\n+    public void writePrefsTree() throws BackingStoreException, IOException {\n+        subtree = true;\n+        writeHeader();\n+        writePreferences();\n+        bw.flush();\n+    }\n+\n+    /**\n+     * Writes only the preference node.\n+     */\n+    public void writePrefs() throws BackingStoreException, IOException {\n+        subtree = false;\n+        writeHeader();\n+        writePreferences();\n+        bw.flush();\n+    }\n+\n+    /**\n+     * Writes the standard header.\n+     */\n+    private void writeHeader() throws BackingStoreException, IOException {\n+        bw.write(\"<?xml version=\\\"1.0\\\"?>\");\n+        bw.newLine();\n+        bw.newLine();\n+        bw.write(\"<!-- GNU Classpath java.util.prefs Preferences \");\n+\n+        if (prefs.isUserNode()) {\n+            bw.write(\"user\");\n+        } else {\n+            bw.write(\"system\");\n+        }\n+\n+        // root node?\n+        if (prefs.parent() == null) {\n+            bw.write(\" root\");\n+        }\n+\n+        if (subtree) {\n+            bw.write(\" tree\");\n+        } else {\n+            bw.write(\" node\");\n+        }\n+\n+        // no root?\n+        if (prefs.parent() != null) {\n+            bw.newLine();\n+            bw.write(\"     '\");\n+            bw.write(prefs.absolutePath());\n+            bw.write('\\'');\n+            bw.newLine();\n+        }\n+        bw.write(\" -->\");\n+        bw.newLine();\n+        bw.newLine();\n+    }\n+\n+    /**\n+     * Write the preferences tag and the root.\n+     */\n+    private void writePreferences() throws BackingStoreException, IOException {\n+        bw.write(\"<preferences>\");\n+        bw.newLine();\n+        writeRoot();\n+        bw.write(\"</preferences>\");\n+        bw.newLine();\n+    }\n+\n+    private void writeRoot() throws BackingStoreException, IOException {\n+        bw.write(\"  <root type=\\\"\");\n+        if (prefs.isUserNode()) {\n+            bw.write(\"user\");\n+        } else {\n+            bw.write(\"system\");\n+        }\n+        bw.write(\"\\\"/>\");\n+\n+        writeRootMap();\n+        writeNode();\n+\n+        bw.write(\"  </root>\");\n+        bw.newLine();\n+    }\n+\n+    private void writeRootMap() throws BackingStoreException, IOException {\n+        // Is it a root node?\n+        if(prefs.parent() == null && prefs.keys().length > 0) {\n+            bw.newLine();\n+            writeMap(prefs, 2);\n+        } else {\n+            bw.write(\"<map/>\");\n+            bw.newLine();\n+        }\n+    }\n+\n+    /**\n+     * Writes all the parents of the preferences node without any entries.\n+     * Returns the number of parents written, which has to be used as\n+     * argument to <code>writeCloseParents()</code> after writing the node\n+     * itself.\n+     */\n+    private int writeParents() throws IOException {\n+        int parents;\n+        String path = prefs.absolutePath();\n+        int lastslash = path.lastIndexOf(\"/\");\n+        if (lastslash > 0) {\n+            path = path.substring(1, lastslash);\n+            StringTokenizer st = new StringTokenizer(path);\n+            parents = st.countTokens();\n+\n+            System.out.println(\"path: \" + path);\n+            System.out.println(\"parents: \" + parents);\n+\n+            for (int i=0; i<parents; i++) {\n+                String name = st.nextToken();\n+                indent(i+2);\n+                bw.write(\"<node name=\\\"\" + name + \"\\\">\");\n+                bw.write(\"<map/>\");\n+                bw.write(\"</node>\");\n+                bw.newLine();\n+            }\n+        } else {\n+            parents = 0;\n+        }\n+\n+        return parents;\n+    }\n+\n+    private void writeCloseParents(int parents) throws IOException {\n+        while(parents > 0) {\n+            indent(parents+1);\n+            bw.write(\"</node>\");\n+            bw.newLine();\n+            parents--;\n+        }\n+    }\n+\n+    private void writeNode() throws BackingStoreException, IOException {\n+        int parents = writeParents();\n+        // root?\n+        int indent;\n+        if (prefs.parent() == null) {\n+            indent = parents+1;\n+        } else {\n+            indent = parents+2;\n+        }\n+        writeNode(prefs, indent);\n+        writeCloseParents(parents);\n+    }\n+\n+    private void writeNode(Preferences node, int indent)\n+                                    throws BackingStoreException, IOException\n+    {\n+        // not root?\n+        if (node.parent() != null) {\n+            indent(indent);\n+            bw.write(\"<node name=\\\"\" + node.name() + \"\\\">\");\n+            if (node.keys().length > 0) {\n+                bw.newLine();\n+            }\n+            writeMap(node, indent+1);\n+        }\n+\n+        if (subtree) {\n+            String[] children = node.childrenNames();\n+            for (int i=0; i<children.length; i++) {\n+                Preferences child = node.node(children[i]);\n+                writeNode(child, indent+1);\n+            }\n+        }\n+\n+        // not root?\n+        if (node.parent() != null) {\n+            indent(indent);\n+            bw.write(\"</node>\");\n+            bw.newLine();\n+        }\n+    }\n+\n+    private void writeMap(Preferences node, int indent) \n+                                    throws BackingStoreException, IOException\n+    {\n+        // construct String used for indentation\n+        StringBuffer indentBuffer = new StringBuffer(2*indent);\n+        for (int i=0; i < indent; i++)\n+            indentBuffer.append(\"  \");\n+        String indentString = indentBuffer.toString();\n+\n+        if (node.keys().length > 0) {\n+            bw.write(indentString);\n+            bw.write(\"<map>\");\n+            bw.newLine();\n+            writeEntries(node, indentString + \"  \");\n+            bw.write(indentString);\n+            bw.write(\"</map>\");\n+        } else {\n+            bw.write(\"<map/>\");\n+        }\n+        bw.newLine();\n+    }\n+\n+    private void writeEntries(Preferences node, String indent)\n+                                    throws BackingStoreException, IOException\n+    {\n+        String[] keys = node.keys();\n+        for(int i = 0; i < keys.length; i++) {\n+            String value = node.get(keys[i], null);\n+            if (value == null) {\n+                throw new BackingStoreException(\"null value for key '\"\n+                                                + keys[i] + \"'\");\n+            }\n+\n+            bw.write(indent);\n+            bw.write(\"<entry key=\\\"\" + keys[i] + \"\\\"\"\n+                    + \" value=\\\"\" + value + \"\\\"/>\");\n+            bw.newLine();\n+        }\n+    }\n+\n+    private void indent(int x) throws IOException {\n+        for (int i=0; i<x; i++) {\n+            bw.write(\"  \");\n+        }\n+    }\n+}"}, {"sha": "98e87ebc83a18b47729849f033726fed15d0f6f4", "filename": "libjava/java/util/prefs/AbstractPreferences.java", "status": "added", "additions": 1258, "deletions": 0, "changes": 1258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fjava%2Futil%2Fprefs%2FAbstractPreferences.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fjava%2Futil%2Fprefs%2FAbstractPreferences.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fprefs%2FAbstractPreferences.java?ref=63640075b00fe54285339c66554c2c9df27c48e9", "patch": "@@ -0,0 +1,1258 @@\n+/* AbstractPreferences - Partial implementation of a Preference node\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.util.prefs;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+import java.util.Iterator;\n+import java.util.HashMap;\n+import java.util.TreeSet;\n+\n+import gnu.java.util.prefs.NodeWriter;\n+\n+/**\n+ * Partial implementation of a Preference node.\n+ *\n+ * Methods that still need to be implemented are <code>isUserNode(), XXX\n+ *\n+ * @since 1.4\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public abstract class AbstractPreferences extends Preferences {\n+\n+    // protected fields\n+\n+    /**\n+     * Object used to lock this preference node. Any thread only locks nodes\n+     * downwards when it has the lock on the current node. No method should\n+     * synchronize on the lock of any of its parent nodes while holding the\n+     * lock on the current node.\n+     */\n+    protected final Object lock = new Object();\n+\n+    /**\n+     * Set to true in the contructor if the node did not exist in the backing\n+     * store when this preference node object was created. Should be set in\n+     * the contructor of a subclass. Defaults to false. Used to fire node\n+     * changed events.\n+     */\n+    protected boolean newNode = false;\n+\n+    // private fields\n+\n+    /**\n+     * The parent preferences node or null when this is the root node.\n+     */\n+    private final AbstractPreferences parent;\n+\n+    /**\n+     * The name of this node.\n+     * Only when this is a root node (parent == null) the name is empty.\n+     * It has a maximum of 80 characters and cannot contain any '/' characters.\n+     */\n+    private final String name;\n+\n+    /** True when this node has been remove, false otherwise. */\n+    private boolean removed = false;\n+\n+    /**\n+     * Holds all the child names and nodes of this node that have been\n+     * accessed by earlier <code>getChild()</code> or <code>childSpi()</code>\n+     * invocations and that have not been removed.\n+     */\n+    private HashMap childCache = new HashMap();\n+\n+    // constructor\n+\n+    /**\n+     * Creates a new AbstractPreferences node with the given parent and name.\n+     * \n+     * @param parent the parent of this node or null when this is the root node\n+     * @param name the name of this node, can not be null, only 80 characters\n+     *             maximum, must be empty when parent is null and cannot\n+     *             contain any '/' characters\n+     * @exception IllegalArgumentException when name is null, greater then 80\n+     *            characters, not the empty string but parent is null or\n+     *            contains a '/' character\n+     */\n+    protected AbstractPreferences(AbstractPreferences parent, String name) {\n+        if (  (name == null)                            // name should be given\n+           || (name.length() > MAX_NAME_LENGTH)         // 80 characters max\n+           || (parent == null && name.length() != 0)    // root has no name\n+           || (parent != null && name.length() == 0)    // all other nodes do\n+           || (name.indexOf('/') != -1))                // must not contain '/'\n+            throw new IllegalArgumentException(\"Illegal name argument '\"\n+                                               + name\n+                                               + \"' (parent is \"\n+                                               + parent == null ? \"\" : \"not \"\n+                                               + \"null)\");\n+        this.parent = parent;\n+        this.name = name;\n+    }\n+\n+    // identification methods\n+\n+    /**\n+     * Returns the absolute path name of this preference node.\n+     * The absolute path name of a node is the path name of its parent node\n+     * plus a '/' plus its own name. If the node is the root node and has no\n+     * parent then its path name is \"\" and its absolute path name is \"/\".\n+     */\n+    public String absolutePath() {\n+        if (parent == null)\n+            return \"/\";\n+        else\n+            return parent.path() + '/' + name;\n+    }\n+\n+    /**\n+     * Private helper method for absolutePath. Returns the empty string for a\n+     * root node and otherwise the parentPath of its parent plus a '/'.\n+     */\n+    private String path() {\n+        if (parent == null)\n+            return \"\";\n+        else\n+            return parent.path() + '/' + name;\n+    }\n+\n+    /**\n+     * Returns true if this node comes from the user preferences tree, false\n+     * if it comes from the system preferences tree.\n+     */\n+    abstract public boolean isUserNode();\n+\n+    /**\n+     * Returns the name of this preferences node. The name of the node cannot\n+     * be null, can be mostly 80 characters and cannot contain any '/'\n+     * characters. The root node has as name \"\".\n+     */\n+    public String name() {\n+        return name;\n+    }\n+\n+    /**\n+     * Returns the String given by\n+     * <code>\n+     * (isUserNode() ? \"User\":\"System\") + \" Preference Node: \" + absolutePath()\n+     * </code>\n+     */\n+    public String toString() {\n+        return (isUserNode() ? \"User\":\"System\")\n+               + \" Preference Node: \"\n+               + absolutePath();\n+    }\n+\n+    /**\n+     * Returns all the direct sub nodes of this preferences node.\n+     * Needs access to the backing store to give a meaningfull answer.\n+     * <p>\n+     * This implementation locks this node, checks if the node has not yet\n+     * been removed and throws an <code>IllegalStateException</code> when it\n+     * has been. Then it creates a new <code>TreeSet</code> and adds any\n+     * already cached child nodes names. To get any uncached names it calls\n+     * <code>childrenNamesSpi()</code> and adds the result to the set. Finally\n+     * it calls <code>toArray()</code> on the created set. When the call to\n+     * <code>childrenNamesSpi</code> thows an <code>BackingStoreException</code>\n+     * this method will not catch that exception but propagate the exception\n+     * to the caller.\n+     *\n+     * @exception BackingStoreException when the backing store cannot be\n+     *            reached\n+     * @exception IllegalStateException when this node has been removed\n+     */\n+    public String[] childrenNames() throws BackingStoreException {\n+        synchronized(lock) {\n+            if (isRemoved())\n+                throw new IllegalStateException(\"Node removed\");\n+\n+            TreeSet childrenNames = new TreeSet();\n+\n+            // First get all cached node names\n+            childrenNames.addAll(childCache.keySet());\n+            \n+            // Then add any others\n+            String names[] = childrenNamesSpi();\n+            for (int i = 0; i < names.length; i++) {\n+                childrenNames.add(names[i]);\n+            }\n+\n+            // And return the array of names\n+            String[] children = new String[childrenNames.size()];\n+            childrenNames.toArray(children);\n+            return children;\n+\n+        }\n+    }\n+\n+    /**\n+     * Returns a sub node of this preferences node if the given path is\n+     * relative (does not start with a '/') or a sub node of the root\n+     * if the path is absolute (does start with a '/').\n+     * <p>\n+     * This method first locks this node and checks if the node has not been\n+     * removed, if it has been removed it throws an exception. Then if the\n+     * path is relative (does not start with a '/') it checks if the path is\n+     * legal (does not end with a '/' and has no consecutive '/' characters).\n+     * Then it recursively gets a name from the path, gets the child node\n+     * from the child-cache of this node or calls the <code>childSpi()</code>\n+     * method to create a new child sub node. This is done recursively on the\n+     * newly created sub node with the rest of the path till the path is empty.\n+     * If the path is absolute (starts with a '/') the lock on this node is\n+     * droped and this method is called on the root of the preferences tree\n+     * with as argument the complete path minus the first '/'.\n+     *\n+     * @exception IllegalStateException if this node has been removed\n+     * @exception IllegalArgumentException if the path contains two or more\n+     * consecutive '/' characters, ends with a '/' charactor and is not the\n+     * string \"/\" (indicating the root node) or any name on the path is more\n+     * then 80 characters long\n+     */\n+    public Preferences node(String path) {\n+        synchronized(lock) {\n+            if (isRemoved())\n+                throw new IllegalStateException(\"Node removed\");\n+\n+            // Is it a relative path?\n+            if (!path.startsWith(\"/\")) {\n+\n+                // Check if it is a valid path\n+                if (path.indexOf(\"//\") != -1 || path.endsWith(\"/\"))\n+                    throw new IllegalArgumentException(path);\n+\n+                return getNode(path);\n+            }\n+        }\n+\n+        // path started with a '/' so it is absolute\n+        // we drop the lock and start from the root (omitting the first '/')\n+        Preferences root = isUserNode() ? userRoot() : systemRoot();\n+        return root.node(path.substring(1));\n+\n+    }\n+\n+    /**\n+     * Private helper method for <code>node()</code>. Called with this node\n+     * locked. Returns this node when path is the empty string, if it is not\n+     * empty the next node name is taken from the path (all chars till the\n+     * next '/' or end of path string) and the node is either taken from the\n+     * child-cache of this node or the <code>childSpi()</code> method is called\n+     * on this node with the name as argument. Then this method is called\n+     * recursively on the just constructed child node with the rest of the\n+     * path.\n+     *\n+     * @param path should not end with a '/' character and should not contain\n+     *        consecutive '/' characters\n+     * @exception IllegalArgumentException if path begins with a name that is\n+     *            larger then 80 characters.\n+     */\n+    private Preferences getNode(String path) {\n+        // if mark is dom then goto end\n+\n+        // Empty String \"\" indicates this node\n+        if (path.length() == 0)\n+            return this;\n+\n+        // Calculate child name and rest of path\n+        String childName;\n+        String childPath;\n+        int nextSlash = path.indexOf('/');\n+        if (nextSlash == -1) {\n+            childName = path;\n+            childPath = \"\";\n+        } else {\n+            childName = path.substring(0, nextSlash);\n+            childPath = path.substring(nextSlash+1);\n+        }\n+\n+        // Get the child node\n+        AbstractPreferences child;\n+        child = (AbstractPreferences)childCache.get(childName);\n+        if (child == null) {\n+\n+            if (childName.length() > MAX_NAME_LENGTH)\n+               throw new IllegalArgumentException(childName); \n+\n+            // Not in childCache yet so create a new sub node\n+            child = childSpi(childName);\n+            // XXX - check if node is new\n+            childCache.put(childName, child);\n+        }\n+\n+        // Lock the child and go down\n+        synchronized(child.lock) {\n+            return child.getNode(childPath);\n+        }\n+    }\n+\n+    /**\n+     * Returns true if the node that the path points to exists in memory or\n+     * in the backing store. Otherwise it returns false or an exception is\n+     * thrown. When this node is removed the only valid parameter is the\n+     * empty string (indicating this node), the return value in that case\n+     * will be false.\n+     *\n+     * @exception BackingStoreException when the backing store cannot be\n+     *            reached\n+     * @exception IllegalStateException if this node has been removed\n+     *            and the path is not the empty string (indicating this node)\n+     * @exception IllegalArgumentException if the path contains two or more\n+     * consecutive '/' characters, ends with a '/' charactor and is not the\n+     * string \"/\" (indicating the root node) or any name on the path is more\n+     * then 80 characters long\n+     */\n+    public boolean nodeExists(String path) throws BackingStoreException {\n+        synchronized(lock) {\n+            if (isRemoved() && path.length() != 0)\n+                throw new IllegalStateException(\"Node removed\");\n+\n+            // Is it a relative path?\n+            if (!path.startsWith(\"/\")) {\n+\n+                // Check if it is a valid path\n+                if (path.indexOf(\"//\") != -1 || path.endsWith(\"/\"))\n+                    throw new IllegalArgumentException(path);\n+\n+                return existsNode(path);\n+            }\n+        }\n+\n+        // path started with a '/' so it is absolute\n+        // we drop the lock and start from the root (omitting the first '/')\n+        Preferences root = isUserNode() ? userRoot() : systemRoot();\n+        return root.nodeExists(path.substring(1));\n+\n+    }\n+\n+    private boolean existsNode(String path) throws BackingStoreException {\n+\n+        // Empty String \"\" indicates this node\n+        if (path.length() == 0)\n+            return(!isRemoved());\n+\n+        // Calculate child name and rest of path\n+        String childName;\n+        String childPath;\n+        int nextSlash = path.indexOf('/');\n+        if (nextSlash == -1) {\n+            childName = path;\n+            childPath = \"\";\n+        } else {\n+            childName = path.substring(0, nextSlash);\n+            childPath = path.substring(nextSlash+1);\n+        }\n+\n+        // Get the child node\n+        AbstractPreferences child;\n+        child = (AbstractPreferences)childCache.get(childName);\n+        if (child == null) {\n+\n+            if (childName.length() > MAX_NAME_LENGTH)\n+               throw new IllegalArgumentException(childName);\n+\n+            // Not in childCache yet so create a new sub node\n+            child = getChild(childName);\n+\n+            if (child == null)\n+                return false;\n+\n+            childCache.put(childName, child);\n+        }\n+\n+        // Lock the child and go down\n+        synchronized(child.lock) {\n+            return child.existsNode(childPath);\n+        }\n+    }\n+\n+    /**\n+     * Returns the child sub node if it exists in the backing store or null\n+     * if it does not exist. Called (indirectly) by <code>nodeExists()</code>\n+     * when a child node name can not be found in the cache.\n+     * <p>\n+     * Gets the lock on this node, calls <code>childrenNamesSpi()</code> to\n+     * get an array of all (possibly uncached) children and compares the\n+     * given name with the names in the array. If the name is found in the\n+     * array <code>childSpi()</code> is called to get an instance, otherwise\n+     * null is returned.\n+     *\n+     * @exception BackingStoreException when the backing store cannot be\n+     *            reached\n+     */\n+    protected AbstractPreferences getChild(String name)\n+                                    throws BackingStoreException\n+    {\n+        synchronized(lock) {\n+            // Get all the names (not yet in the cache)\n+            String[] names = childrenNamesSpi();\n+            for (int i=0; i < names.length; i++)\n+                if (name.equals(names[i]))\n+                    return childSpi(name);\n+           \n+            // No child with that name found\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Returns true if this node has been removed with the\n+     * <code>removeNode()</code> method, false otherwise.\n+     * <p>\n+     * Gets the lock on this node and then returns a boolean field set by\n+     * <code>removeNode</code> methods.\n+     */\n+    protected boolean isRemoved() {\n+        synchronized(lock) {\n+            return removed;\n+        }\n+    }\n+\n+    /**\n+     * Returns the parent preferences node of this node or null if this is\n+     * the root of the preferences tree.\n+     * <p>\n+     * Gets the lock on this node, checks that the node has not been removed\n+     * and returns the parent given to the constructor.\n+     *\n+     * @exception IllegalStateException if this node has been removed\n+     */\n+    public Preferences parent() {\n+        synchronized(lock) {\n+            if (isRemoved())\n+                throw new IllegalStateException(\"Node removed\");\n+\n+            return parent;\n+        }\n+    }\n+\n+    // export methods\n+\n+    /**\n+     * XXX\n+     */\n+    public void exportNode(OutputStream os)\n+                                    throws BackingStoreException,\n+                                           IOException\n+    {\n+        NodeWriter nodeWriter = new NodeWriter(this, os);\n+        nodeWriter.writePrefs();\n+    }\n+\n+    /**\n+     * XXX\n+     */\n+    public void exportSubtree(OutputStream os)\n+                                    throws BackingStoreException,\n+                                           IOException\n+    {\n+        NodeWriter nodeWriter = new NodeWriter(this, os);\n+        nodeWriter.writePrefsTree();\n+    }\n+\n+    // preference entry manipulation methods\n+\n+    /**\n+     * Returns an (possibly empty) array with all the keys of the preference\n+     * entries of this node.\n+     * <p>\n+     * This method locks this node and checks if the node has not been\n+     * removed, if it has been removed it throws an exception, then it returns\n+     * the result of calling <code>keysSpi()</code>.\n+     * \n+     * @exception BackingStoreException when the backing store cannot be     \n+     *            reached\n+     * @exception IllegalStateException if this node has been removed\n+     */\n+    public String[] keys() throws BackingStoreException {\n+        synchronized(lock) {\n+            if (isRemoved())\n+                throw new IllegalStateException(\"Node removed\");\n+\n+            return keysSpi();\n+        }\n+    }\n+\n+\n+    /**\n+     * Returns the value associated with the key in this preferences node. If\n+     * the default value of the key cannot be found in the preferences node\n+     * entries or something goes wrong with the backing store the supplied\n+     * default value is returned.\n+     * <p>\n+     * Checks that key is not null and not larger then 80 characters,\n+     * locks this node, and checks that the node has not been removed.\n+     * Then it calls <code>keySpi()</code> and returns\n+     * the result of that method or the given default value if it returned\n+     * null or throwed an exception.\n+     *\n+     * @exception IllegalArgumentException if key is larger then 80 characters\n+     * @exception IllegalStateException if this node has been removed\n+     * @exception NullPointerException if key is null\n+     */\n+    public String get(String key, String defaultVal) {\n+        if (key.length() > MAX_KEY_LENGTH)\n+            throw new IllegalArgumentException(key);\n+\n+        synchronized(lock) {\n+            if (isRemoved())\n+                throw new IllegalStateException(\"Node removed\");\n+\n+            String value;\n+            try {\n+                value = getSpi(key);\n+            } catch (Throwable t) {\n+                value = null;\n+            }\n+\n+            if (value != null) {\n+                return value;\n+            } else {\n+                return defaultVal;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Convenience method for getting the given entry as a boolean.\n+     * When the string representation of the requested entry is either\n+     * \"true\" or \"false\" (ignoring case) then that value is returned,\n+     * otherwise the given default boolean value is returned.\n+     *\n+     * @exception IllegalArgumentException if key is larger then 80 characters\n+     * @exception IllegalStateException if this node has been removed\n+     * @exception NullPointerException if key is null\n+     */\n+    public boolean getBoolean(String key, boolean defaultVal) {\n+        String value = get(key, null);\n+\n+        if (\"true\".equalsIgnoreCase(value))\n+            return true;\n+\n+        if (\"false\".equalsIgnoreCase(value))\n+            return false;\n+        \n+        return defaultVal;\n+    }\n+\n+    /**\n+     * Convenience method for getting the given entry as a byte array.\n+     * When the string representation of the requested entry is a valid\n+     * Base64 encoded string (without any other characters, such as newlines)\n+     * then the decoded Base64 string is returned as byte array,\n+     * otherwise the given default byte array value is returned.\n+     *\n+     * @exception IllegalArgumentException if key is larger then 80 characters\n+     * @exception IllegalStateException if this node has been removed\n+     * @exception NullPointerException if key is null\n+     */\n+    public byte[] getByteArray(String key, byte[] defaultVal) {\n+        String value = get(key, null);\n+\n+        byte[] b = null;\n+        if (value != null) {\n+            b = decode64(value);\n+        }\n+\n+        if (b != null)\n+            return b;\n+        else\n+            return defaultVal;\n+    }\n+    \n+    /**\n+     * Helper method for decoding a Base64 string as an byte array.\n+     * Returns null on encoding error. This method does not allow any other\n+     * characters present in the string then the 65 special base64 chars.\n+     */\n+    private static byte[] decode64(String s) {\n+        ByteArrayOutputStream bs = new ByteArrayOutputStream((s.length()/4)*3);\n+        char[] c = new char[s.length()];\n+        s.getChars(0, s.length(), c, 0);\n+\n+        // Convert from base64 chars\n+        int endchar = -1;\n+        for(int j = 0; j < c.length && endchar == -1; j++) {\n+            if (c[j] >= 'A' && c[j] <= 'Z') {\n+                c[j] -= 'A';\n+            } else if (c[j] >= 'a' && c[j] <= 'z') {\n+                c[j] = (char) (c[j] + 26 - 'a');\n+            } else if (c[j] >= '0' && c[j] <= '9') {\n+                c[j] = (char) (c[j] + 52 - '0');\n+            } else if (c[j] == '+') {\n+                c[j] = 62;\n+            } else if (c[j] == '/') {\n+                c[j] = 63;\n+            } else if (c[j] == '=') {\n+                endchar = j;\n+            } else {\n+                return null; // encoding exception\n+            }\n+        }\n+\n+        int remaining = endchar == -1 ? c.length : endchar;\n+        int i = 0;\n+        while (remaining > 0) {\n+            // Four input chars (6 bits) are decoded as three bytes as\n+            // 000000 001111 111122 222222\n+\n+            byte b0 = (byte) (c[i] << 2);\n+            if (remaining >= 2) {\n+                b0 += (c[i+1] & 0x30) >> 4;\n+            }\n+            bs.write(b0);\n+\n+            if (remaining >= 3) {\n+                byte b1 = (byte) ((c[i+1] & 0x0F) << 4);\n+                b1 += (byte) ((c[i+2] & 0x3C) >> 2);\n+                bs.write(b1);\n+            }\n+\n+            if (remaining >= 4) {\n+                byte b2 = (byte) ((c[i+2] & 0x03) << 6);\n+                b2 += c[i+3];\n+                bs.write(b2);\n+            }\n+\n+            i += 4;\n+            remaining -= 4;\n+        }\n+\n+        return bs.toByteArray();\n+    }\n+\n+    /**\n+     * Convenience method for getting the given entry as a double.\n+     * When the string representation of the requested entry can be decoded\n+     * with <code>Double.parseDouble()</code> then that double is returned,\n+     * otherwise the given default double value is returned.\n+     *\n+     * @exception IllegalArgumentException if key is larger then 80 characters\n+     * @exception IllegalStateException if this node has been removed\n+     * @exception NullPointerException if key is null\n+     */\n+    public double getDouble(String key, double defaultVal) {\n+        String value = get(key, null);\n+\n+        if (value != null) {\n+            try {\n+                return Double.parseDouble(value);\n+            } catch (NumberFormatException nfe) { /* ignore */ }\n+        }\n+\n+        return defaultVal;\n+    }\n+\n+    /**\n+     * Convenience method for getting the given entry as a float.\n+     * When the string representation of the requested entry can be decoded\n+     * with <code>Float.parseFloat()</code> then that float is returned,\n+     * otherwise the given default float value is returned.\n+     *\n+     * @exception IllegalArgumentException if key is larger then 80 characters\n+     * @exception IllegalStateException if this node has been removed\n+     * @exception NullPointerException if key is null\n+     */\n+    public float getFloat(String key, float defaultVal) {\n+        String value = get(key, null);\n+\n+        if (value != null) {\n+            try {\n+                return Float.parseFloat(value);\n+            } catch (NumberFormatException nfe) { /* ignore */ }\n+        }\n+\n+        return defaultVal;\n+    }\n+\n+    /**\n+     * Convenience method for getting the given entry as an integer.\n+     * When the string representation of the requested entry can be decoded\n+     * with <code>Integer.parseInt()</code> then that integer is returned,\n+     * otherwise the given default integer value is returned.\n+     *\n+     * @exception IllegalArgumentException if key is larger then 80 characters\n+     * @exception IllegalStateException if this node has been removed\n+     * @exception NullPointerException if key is null\n+     */\n+    public int getInt(String key, int defaultVal) {\n+        String value = get(key, null);\n+\n+        if (value != null) {\n+            try {\n+                return Integer.parseInt(value);\n+            } catch (NumberFormatException nfe) { /* ignore */ }\n+        }\n+\n+        return defaultVal;\n+    }\n+\n+    /**\n+     * Convenience method for getting the given entry as a long.\n+     * When the string representation of the requested entry can be decoded\n+     * with <code>Long.parseLong()</code> then that long is returned,\n+     * otherwise the given default long value is returned.\n+     *\n+     * @exception IllegalArgumentException if key is larger then 80 characters\n+     * @exception IllegalStateException if this node has been removed\n+     * @exception NullPointerException if key is null\n+     */\n+    public long getLong(String key, long defaultVal) {\n+        String value = get(key, null);\n+\n+        if (value != null) {\n+            try {\n+                return Long.parseLong(value);\n+            } catch (NumberFormatException nfe) { /* ignore */ }\n+        }\n+\n+        return defaultVal;\n+    }\n+\n+    /**\n+     * Sets the value of the given preferences entry for this node.\n+     * Key and value cannot be null, the key cannot exceed 80 characters\n+     * and the value cannot exceed 8192 characters.\n+     * <p>\n+     * The result will be immediatly visible in this VM, but may not be\n+     * immediatly written to the backing store.\n+     * <p>\n+     * Checks that key and value are valid, locks this node, and checks that\n+     * the node has not been removed. Then it calls <code>putSpi()</code>.\n+     *\n+     * @exception NullPointerException if either key or value are null\n+     * @exception IllegalArgumentException if either key or value are to large\n+     * @exception IllegalStateException when this node has been removed\n+     */\n+    public void put(String key, String value) {\n+        if (key.length() > MAX_KEY_LENGTH\n+            || value.length() > MAX_VALUE_LENGTH)\n+            throw new IllegalArgumentException(\"key (\"\n+                                               + key.length() + \")\"\n+                                               + \" or value (\"\n+                                               + value.length() + \")\"\n+                                               + \" to large\");\n+        synchronized(lock) {\n+            if (isRemoved())\n+                throw new IllegalStateException(\"Node removed\");\n+\n+            putSpi(key, value);\n+\n+            // XXX - fire events\n+        }\n+            \n+    }\n+\n+    /**\n+     * Convenience method for setting the given entry as a boolean.\n+     * The boolean is converted with <code>Boolean.toString(value)</code>\n+     * and then stored in the preference entry as that string.\n+     *\n+     * @exception NullPointerException if key is null\n+     * @exception IllegalArgumentException if the key length is to large\n+     * @exception IllegalStateException when this node has been removed\n+     */\n+    public void putBoolean(String key, boolean value) {\n+        put(key, String.valueOf(value));\n+        // XXX - Use when using 1.4 compatible Boolean\n+        // put(key, Boolean.toString(value));\n+    }\n+\n+    /**\n+     * Convenience method for setting the given entry as an array of bytes.\n+     * The byte array is converted to a Base64 encoded string\n+     * and then stored in the preference entry as that string.\n+     * <p>\n+     * Note that a byte array encoded as a Base64 string will be about 1.3\n+     * times larger then the original length of the byte array, which means\n+     * that the byte array may not be larger about 6 KB.\n+     *\n+     * @exception NullPointerException if either key or value are null\n+     * @exception IllegalArgumentException if either key or value are to large\n+     * @exception IllegalStateException when this node has been removed\n+     */\n+    public void putByteArray(String key, byte[] value) {\n+        put(key, encode64(value));\n+    }\n+\n+    /**\n+     * Helper method for encoding an array of bytes as a Base64 String.\n+     */\n+    private static String encode64(byte[] b) {\n+        StringBuffer sb = new StringBuffer((b.length/3)*4);\n+\n+        int i = 0;\n+        int remaining = b.length;\n+        char c[] = new char[4];\n+        while (remaining > 0) {\n+            // Three input bytes are encoded as four chars (6 bits) as\n+            // 00000011 11112222 22333333\n+\n+            c[0] = (char) ((b[i] & 0xFC) >> 2);\n+            c[1] = (char) ((b[i] & 0x03) << 4);\n+            if (remaining >= 2) {\n+                c[1] += (char) ((b[i+1] & 0xF0) >> 4);\n+                c[2] = (char) ((b[i+1] & 0x0F) << 2);\n+                if (remaining >= 3) {\n+                    c[2] += (char) ((b[i+2] & 0xC0) >> 6);\n+                    c[3] = (char) (b[i+2] & 0x3F);\n+                } else {\n+                    c[3] = 64;\n+                }\n+            } else {\n+                c[2] = 64;\n+                c[3] = 64;\n+            }\n+\n+            // Convert to base64 chars\n+            for(int j = 0; j < 4; j++) {\n+                if (c[j] < 26) {\n+                    c[j] += 'A';\n+                } else if (c[j] < 52) {\n+                    c[j] = (char) (c[j] - 26 + 'a');\n+                } else if (c[j] < 62) {\n+                    c[j] = (char) (c[j] - 52 + '0');\n+                } else if (c[j] == 62) {\n+                    c[j] = '+';\n+                } else if (c[j] == 63) {\n+                    c[j] = '/';\n+                } else {\n+                    c[j] = '=';\n+                }\n+            }\n+\n+            sb.append(c);\n+            i += 3;\n+            remaining -= 3;\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Convenience method for setting the given entry as a double.\n+     * The double is converted with <code>Double.toString(double)</code>\n+     * and then stored in the preference entry as that string.\n+     *\n+     * @exception NullPointerException if the key is null\n+     * @exception IllegalArgumentException if the key length is to large\n+     * @exception IllegalStateException when this node has been removed\n+     */\n+    public void putDouble(String key, double value) {\n+        put(key, Double.toString(value));\n+    }\n+\n+    /**\n+     * Convenience method for setting the given entry as a float.\n+     * The float is converted with <code>Float.toString(float)</code>\n+     * and then stored in the preference entry as that string.\n+     *\n+     * @exception NullPointerException if the key is null\n+     * @exception IllegalArgumentException if the key length is to large\n+     * @exception IllegalStateException when this node has been removed\n+     */\n+    public void putFloat(String key, float value) {\n+        put(key, Float.toString(value));\n+    }\n+\n+    /**\n+     * Convenience method for setting the given entry as an integer.\n+     * The integer is converted with <code>Integer.toString(int)</code>\n+     * and then stored in the preference entry as that string.\n+     *\n+     * @exception NullPointerException if the key is null\n+     * @exception IllegalArgumentException if the key length is to large\n+     * @exception IllegalStateException when this node has been removed\n+     */\n+    public void putInt(String key, int value) {\n+        put(key, Integer.toString(value));\n+    }\n+\n+    /**\n+     * Convenience method for setting the given entry as a long.\n+     * The long is converted with <code>Long.toString(long)</code>\n+     * and then stored in the preference entry as that string.\n+     *\n+     * @exception NullPointerException if the key is null\n+     * @exception IllegalArgumentException if the key length is to large\n+     * @exception IllegalStateException when this node has been removed\n+     */\n+    public void putLong(String key, long value) {\n+        put(key, Long.toString(value));\n+    }\n+\n+    /**\n+     * Removes the preferences entry from this preferences node.\n+     * <p>     \n+     * The result will be immediatly visible in this VM, but may not be\n+     * immediatly written to the backing store.\n+     * <p>\n+     * This implementation checks that the key is not larger then 80\n+     * characters, gets the lock of this node, checks that the node has\n+     * not been removed and calls <code>removeSpi</code> with the given key.\n+     *\n+     * @exception NullPointerException if the key is null\n+     * @exception IllegalArgumentException if the key length is to large\n+     * @exception IllegalStateException when this node has been removed\n+     */\n+    public void remove(String key) {\n+        if (key.length() > MAX_KEY_LENGTH)\n+            throw new IllegalArgumentException(key);\n+\n+        synchronized(lock) {\n+            if (isRemoved())\n+                throw new IllegalStateException(\"Node removed\");\n+\n+            removeSpi(key);\n+        }\n+    }\n+\n+    /**\n+     * Removes all entries from this preferences node. May need access to the\n+     * backing store to get and clear all entries.\n+     * <p>\n+     * The result will be immediatly visible in this VM, but may not be\n+     * immediatly written to the backing store.\n+     * <p>\n+     * This implementation locks this node, checks that the node has not been\n+     * removed and calls <code>keys()</code> to get a complete array of keys\n+     * for this node. For every key found <code>removeSpi()</code> is called.\n+     *\n+     * @exception BackingStoreException when the backing store cannot be\n+     *            reached\n+     * @exception IllegalStateException if this node has been removed\n+     */\n+    public void clear() throws BackingStoreException {\n+        synchronized(lock) {\n+            if (isRemoved())\n+                throw new IllegalStateException(\"Node Removed\");\n+\n+            String[] keys = keys();\n+            for (int i = 0; i < keys.length; i++) {\n+                removeSpi(keys[i]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Writes all preference changes on this and any subnode that have not\n+     * yet been written to the backing store. This has no effect on the\n+     * preference entries in this VM, but it makes sure that all changes\n+     * are visible to other programs (other VMs might need to call the\n+     * <code>sync()</code> method to actually see the changes to the backing\n+     * store.\n+     * <p>\n+     * Locks this node, calls the <code>flushSpi()</code> method, gets all\n+     * the (cached - already existing in this VM) subnodes and then calls\n+     * <code>flushSpi()</code> on every subnode with this node unlocked and\n+     * only that particular subnode locked.\n+     *\n+     * @exception BackingStoreException when the backing store cannot be\n+     *            reached\n+     */\n+    public void flush() throws BackingStoreException {\n+        flushNode(false);\n+    }\n+\n+    /**\n+     * Writes and reads all preference changes to and from this and any\n+     * subnodes. This makes sure that all local changes are written to the\n+     * backing store and that all changes to the backing store are visible\n+     * in this preference node (and all subnodes).\n+     * <p>\n+     * Checks that this node is not removed, locks this node, calls the\n+     * <code>syncSpi()</code> method, gets all the subnodes and then calls\n+     * <code>syncSpi()</code> on every subnode with this node unlocked and\n+     * only that particular subnode locked.\n+     *\n+     * @exception BackingStoreException when the backing store cannot be\n+     *            reached\n+     * @exception IllegalStateException if this node has been removed\n+     */\n+    public void sync() throws BackingStoreException {\n+        flushNode(true);\n+    }\n+    \n+\n+    /**\n+     * Private helper method that locks this node and calls either\n+     * <code>flushSpi()</code> if <code>sync</code> is false, or\n+     * <code>flushSpi()</code> if <code>sync</code> is true. Then it gets all\n+     * the currently cached subnodes. For every subnode it calls this method\n+     * recursively with this node no longer locked.\n+     * <p>\n+     * Called by either <code>flush()</code> or <code>sync()</code>\n+     */\n+    private void flushNode(boolean sync) throws BackingStoreException {\n+        String[] keys = null;\n+        synchronized(lock) {\n+            if (sync) {\n+                syncSpi();\n+            } else {\n+                flushSpi();\n+            }\n+            keys = (String[]) childCache.keySet().toArray();\n+        }\n+\n+        if (keys != null) {\n+            for (int i = 0; i < keys.length; i++) {\n+                // Have to lock this node again to access the childCache\n+                AbstractPreferences subNode;\n+                synchronized(this) {\n+                    subNode = (AbstractPreferences) childCache.get(keys[i]);\n+                }\n+\n+                // The child could already have been removed from the cache\n+                if (subNode != null) {\n+                    subNode.flushNode(sync);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Removes this and all subnodes from the backing store and clears all\n+     * entries. After removal this instance will not be useable (except for\n+     * a few methods that don't throw a <code>InvalidStateException</code>),\n+     * even when a new node with the same path name is created this instance\n+     * will not be usable again.\n+     * <p>\n+     * Checks that this is not a root node. If not it locks the parent node,\n+     * then locks this node and checks that the node has not yet been removed.\n+     * Then it makes sure that all subnodes of this node are in the child cache,\n+     * by calling <code>childSpi()</code> on any children not yet in the cache.\n+     * Then for all children it locks the subnode and removes it. After all\n+     * subnodes have been purged the child cache is cleared, this nodes removed\n+     * flag is set and any listeners are called. Finally this node is removed\n+     * from the child cache of the parent node.\n+     *\n+     * @exception BackingStoreException when the backing store cannot be\n+     *            reached\n+     * @exception IllegalStateException if this node has already been removed\n+     * @exception UnsupportedOperationException if this is a root node\n+     */\n+    public void removeNode() throws BackingStoreException {\n+        // Check if it is a root node\n+        if (parent == null)\n+            throw new UnsupportedOperationException(\"Cannot remove root node\");\n+\n+        synchronized(parent) {\n+            synchronized(this) {\n+                if (isRemoved())\n+                    throw new IllegalStateException(\"Node Removed\");\n+\n+                purge();\n+            }\n+            parent.childCache.remove(name);\n+        }\n+    }\n+\n+    /**\n+     * Private helper method used to completely remove this node.\n+     * Called by <code>removeNode</code> with the parent node and this node\n+     * locked.\n+     * <p>\n+     * Makes sure that all subnodes of this node are in the child cache,\n+     * by calling <code>childSpi()</code> on any children not yet in the\n+     * cache. Then for all children it locks the subnode and calls this method\n+     * on that node. After all subnodes have been purged the child cache is\n+     * cleared, this nodes removed flag is set and any listeners are called.\n+     */\n+    private void purge() throws BackingStoreException\n+    {\n+        // Make sure all children have an AbstractPreferences node in cache\n+        String children[] = childrenNamesSpi();\n+        for (int i = 0; i < children.length; i++) {\n+            if (childCache.get(children[i]) == null)\n+                childCache.put(children[i], childSpi(children[i]));\n+        }\n+\n+        // purge all children\n+        Iterator i = childCache.values().iterator();\n+        while (i.hasNext()) {\n+            AbstractPreferences node = (AbstractPreferences) i.next();\n+            synchronized(node) {\n+                node.purge();\n+            }\n+        }\n+\n+        // Cache is empty now\n+        childCache.clear();\n+\n+        // remove this node\n+        removeNodeSpi();\n+        removed = true;\n+\n+        // XXX - check for listeners\n+    }\n+\n+    // listener methods\n+\n+    /**\n+     * XXX\n+     */\n+    public void addNodeChangeListener(NodeChangeListener listener) {\n+        // XXX\n+    }\n+\n+    public void addPreferenceChangeListener(PreferenceChangeListener listener) {\n+        // XXX\n+    }\n+\n+    public void removeNodeChangeListener(NodeChangeListener listener) {\n+        // XXX\n+    }\n+\n+    public void removePreferenceChangeListener\n+                            (PreferenceChangeListener listener)\n+    {\n+        // XXX\n+    }\n+\n+    // abstract spi methods\n+\n+    /**\n+     * Returns the names of the sub nodes of this preference node.\n+     * This method only has to return any not yet cached child names,\n+     * but may return all names if that is easier. It must not return\n+     * null when there are no children, it has to return an empty array\n+     * in that case. Since this method must consult the backing store to\n+     * get all the sub node names it may throw a BackingStoreException.\n+     * <p>\n+     * Called by <code>childrenNames()</code> with this node locked.\n+     */\n+    protected abstract String[] childrenNamesSpi() throws BackingStoreException;\n+\n+    /**\n+     * Returns a child note with the given name.\n+     * This method is called by the <code>node()</code> method (indirectly\n+     * through the <code>getNode()</code> helper method) with this node locked\n+     * if a sub node with this name does not already exist in the child cache.\n+     * If the child node did not aleady exist in the backing store the boolean\n+     * field <code>newNode</code> of the returned node should be set.\n+     * <p>\n+     * Note that this method should even return a non-null child node if the\n+     * backing store is not available since it may not throw a\n+     * <code>BackingStoreException</code>.\n+     */\n+    protected abstract AbstractPreferences childSpi(String name);\n+\n+    /**\n+     * Returns an (possibly empty) array with all the keys of the preference\n+     * entries of this node.\n+     * <p>\n+     * Called by <code>keys()</code> with this node locked if this node has\n+     * not been removed. May throw an exception when the backing store cannot\n+     * be accessed.\n+     *\n+     * @exception BackingStoreException when the backing store cannot be     \n+     *            reached\n+     */\n+    abstract protected String[] keysSpi() throws BackingStoreException;\n+     \n+    /**\n+     * Returns the value associated with the key in this preferences node or\n+     * null when the key does not exist in this preferences node.\n+     * <p>\n+     * Called by <code>key()</code> with this node locked after checking that\n+     * key is valid, not null and that the node has not been removed.\n+     * <code>key()</code> will catch any exceptions that this method throws.\n+     */\n+    abstract protected String getSpi(String key);\n+\n+    /**\n+     * Sets the value of the given preferences entry for this node.\n+     * The implementation is not required to propagate the change to the\n+     * backing store immediatly. It may not throw an exception when it tries\n+     * to write to the backing store and that operation fails, the failure\n+     * should be registered so a later invocation of <code>flush()</code>\n+     * or <code>sync()</code> can signal the failure.\n+     * <p>\n+     * Called by <code>put()</code> with this node locked after checking that\n+     * key and value are valid and non-null.\n+     */\n+    abstract protected void putSpi(String key, String value);\n+\n+    /**\n+     * Removes the given key entry from this preferences node.\n+     * The implementation is not required to propagate the change to the\n+     * backing store immediatly.  It may not throw an exception when it tries\n+     * to write to the backing store and that operation fails, the failure\n+     * should be registered so a later invocation of <code>flush()</code>\n+     * or <code>sync()</code> can signal the failure.\n+     * <p>\n+     * Called by <code>remove()</code> with this node locked after checking\n+     * that the key is valid and non-null.\n+     */\n+    abstract protected void removeSpi(String key);\n+\n+    /**\n+     * Writes all entries of this preferences node that have not yet been\n+     * written to the backing store and possibly creates this node in the\n+     * backing store, if it does not yet exist. Should only write changes to\n+     * this node and not write changes to any subnodes.\n+     * Note that the node can be already removed in this VM. To check if\n+     * that is the case the implementation can call <code>isRemoved()</code>.\n+     * <p>\n+     * Called (indirectly) by <code>flush()</code> with this node locked.\n+     */\n+    abstract protected void flushSpi() throws BackingStoreException;\n+\n+    /**\n+     * Writes all entries of this preferences node that have not yet been\n+     * written to the backing store and reads any entries that have changed\n+     * in the backing store but that are not yet visible in this VM.\n+     * Should only sync this node and not change any of the subnodes.\n+     * Note that the node can be already removed in this VM. To check if\n+     * that is the case the implementation can call <code>isRemoved()</code>.\n+     * <p>\n+     * Called (indirectly) by <code>sync()</code> with this node locked.\n+     */\n+    abstract protected void syncSpi() throws BackingStoreException;\n+\n+    /**\n+     * Clears this node from this VM and removes it from the backing store.\n+     * After this method has been called the node is marked as removed.\n+     * <p>\n+     * Called (indirectly) by <code>removeNode()</code> with this node locked\n+     * after all the sub nodes of this node have already been removed.\n+     */\n+    abstract protected void removeNodeSpi() throws BackingStoreException;\n+}"}, {"sha": "f2c6b4c8b31158937e39be53763c817f27fd6fcd", "filename": "libjava/java/util/prefs/BackingStoreException.java", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fjava%2Futil%2Fprefs%2FBackingStoreException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fjava%2Futil%2Fprefs%2FBackingStoreException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fprefs%2FBackingStoreException.java?ref=63640075b00fe54285339c66554c2c9df27c48e9", "patch": "@@ -0,0 +1,104 @@\n+/* BackingStoreException.java - chained exception thrown when backing store\n+   fails\n+   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.util.prefs;\n+\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.NotSerializableException;\n+\n+/**\n+ * Chained exception thrown when backing store fails. This exception is\n+ * only thrown from methods that actually have to access the backing store,\n+ * such as <code>clear(), keys(), childrenNames(), nodeExists(), removeNode(),\n+ * flush(), sync(), exportNode(), exportSubTree()</code>; normal operations\n+ * do not throw BackingStoreExceptions.\n+ *\n+ * <p>Note that although this class inherits the Serializable interface, an\n+ * attempt to serialize will fail with a <code>NotSerializableException</code>.\n+ *\n+ * @author Mark Wielaard <mark@klomp.org>\n+ * @since 1.4\n+ * @status updated to 1.4\n+ */\n+public class BackingStoreException extends Exception\n+{\n+  static final long serialVersionUID = 859796500401108469L;\n+\n+  /**\n+   * Creates a new exception with a descriptive message.\n+   *\n+   * @param message the message\n+   */\n+  public BackingStoreException(String message)\n+  {\n+    super(message);\n+  }\n+\n+  /**\n+   * Create a new exception with the given cause.\n+   *\n+   * @param cause the cause\n+   */\n+  public BackingStoreException(Throwable cause)\n+  {\n+    super(cause);\n+  }\n+\n+  /**\n+   * This class should not be serialized.\n+   *\n+   * @param o the output stream\n+   */\n+  private void writeObject(ObjectOutputStream o) throws NotSerializableException\n+  {\n+    throw new NotSerializableException\n+      (\"java.util.prefs.BackingStoreException\");\n+  }\n+\n+  /**\n+   * This class should not be serialized.\n+   *\n+   * @param i the input stream\n+   */\n+  private void readObject(ObjectInputStream i) throws NotSerializableException\n+  {\n+    throw new NotSerializableException\n+      (\"java.util.prefs.BackingStoreException\");\n+  }\n+}"}, {"sha": "e375db7ab1f351d24e34502104df860e4697d070", "filename": "libjava/java/util/prefs/InvalidPreferencesFormatException.java", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fjava%2Futil%2Fprefs%2FInvalidPreferencesFormatException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fjava%2Futil%2Fprefs%2FInvalidPreferencesFormatException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fprefs%2FInvalidPreferencesFormatException.java?ref=63640075b00fe54285339c66554c2c9df27c48e9", "patch": "@@ -0,0 +1,115 @@\n+/* InvalidPreferencesFormatException - indicates reading prefs from stream\n+   failed\n+   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.util.prefs;\n+\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.NotSerializableException;\n+\n+/**\n+ * Indicates reading prefs from stream failed. Thrown by the\n+ * <code>importPreferences()</code> method when the supplied input stream\n+ * could not be read because it was not in the correct XML format.\n+ *\n+ * <p>Note that although this class inherits the Serializable interface, an\n+ * attempt to serialize will fail with a <code>NotSerializableException</code>.\n+ *\n+ * @author Mark Wielaard <mark@klomp.org>\n+ * @see Preferences\n+ * @since 1.4\n+ * @status updated to 1.4\n+ */\n+public class InvalidPreferencesFormatException extends Exception\n+{\n+  static final long serialVersionUID = -791715184232119669L;\n+\n+  /**\n+   * Creates a new exception with a descriptive message. The cause remains\n+   * uninitialized.\n+   *\n+   * @param message the message\n+   */\n+  public InvalidPreferencesFormatException(String message)\n+  {\n+    super(message);\n+  }\n+\n+  /**\n+   * Creates a new exception with the given cause.\n+   *\n+   * @param cause the cause\n+   */\n+  public InvalidPreferencesFormatException(Throwable cause)\n+  {\n+    super(cause);\n+  }\n+\n+  /**\n+   * Creates a new exception with a descriptive message and a cause.\n+   *\n+   * @param message the message\n+   * @param cause the cause\n+   */\n+  public InvalidPreferencesFormatException(String message, Throwable cause)\n+  {\n+    super(message, cause);\n+  }\n+\n+  /**\n+   * This class should not be serialized.\n+   *\n+   * @param o the output stream\n+   */\n+  private void writeObject(ObjectOutputStream o) throws NotSerializableException\n+  {\n+    throw new NotSerializableException\n+      (\"java.util.prefs.InvalidPreferencesFormatException\");\n+  }\n+\n+  /**\n+   * This class should not be serialized.\n+   *\n+   * @param i the input stream\n+   */\n+  private void readObject(ObjectInputStream i) throws NotSerializableException\n+  {\n+    throw new NotSerializableException\n+      (\"java.util.prefs.InvalidPreferencesFormatException\");\n+  }\n+}"}, {"sha": "a919c464ab2f638fa079b6770b192f6b466e07dc", "filename": "libjava/java/util/prefs/NodeChangeEvent.java", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fjava%2Futil%2Fprefs%2FNodeChangeEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fjava%2Futil%2Fprefs%2FNodeChangeEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fprefs%2FNodeChangeEvent.java?ref=63640075b00fe54285339c66554c2c9df27c48e9", "patch": "@@ -0,0 +1,91 @@\n+/* NodeChangeEvent - ObjectEvent fired when a Preference node is added/removed\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.util.prefs;\n+\n+import java.util.EventObject;\n+\n+/**\n+ * ObjectEvent fired when a Preference node is added/removed.\n+ * This event is only generated when a new subnode is added or a subnode is\n+ * removed from a preference node. Changes in the entries of a preference node\n+ * are indicated with a <code>PreferenceChangeEvent</code>.\n+ *\n+ * @since 1.4\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public class NodeChangeEvent extends EventObject {\n+\n+  private static final long serialVersionUID =8068949086596572957L; \n+  \n+    /**\n+     * The sub node that was added or removed.\n+     * Defined transient just like <code>EventObject.source</code> since\n+     * this object should be serializable, but Preferences is in general not\n+     * serializable.\n+     */\n+    private final transient Preferences child;\n+\n+    /**\n+     * Creates a new NodeChangeEvent.\n+     *\n+     * @param parentNode The source preference node from which a subnode was\n+     * added or removed\n+     * @param childNode The preference node that was added or removed\n+     */\n+    public NodeChangeEvent(Preferences parentNode, Preferences childNode) {\n+        super(parentNode);\n+        child = childNode;\n+    }\n+\n+    /**\n+     * Returns the source parent preference node from which a subnode was\n+     * added or removed.\n+     */\n+    public Preferences getParent() {\n+        return (Preferences) source;\n+    }\n+\n+    /**\n+     * Returns the child preference subnode that was added or removed.\n+     * To see wether it is still a valid preference node one has to call\n+     * <code>event.getChild().nodeExists(\"\")</code>.\n+     */\n+    public Preferences getChild() {\n+        return child;\n+    }\n+}"}, {"sha": "04e8dc1412e4bd90b39ad707e9e2ea532b3e12f3", "filename": "libjava/java/util/prefs/NodeChangeListener.java", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fjava%2Futil%2Fprefs%2FNodeChangeListener.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fjava%2Futil%2Fprefs%2FNodeChangeListener.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fprefs%2FNodeChangeListener.java?ref=63640075b00fe54285339c66554c2c9df27c48e9", "patch": "@@ -0,0 +1,64 @@\n+/* NodeChangeListener - EventListener for Preferences node addition/removal\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.util.prefs;\n+\n+import java.util.EventListener;\n+\n+/**\n+ * EventListener for Preferences node addition/removal.\n+ * <p>\n+ * Note that these events are only generated for the addition and removal\n+ * of sub nodes from the preference node. Entry changes in the preference\n+ * node can be monitored with a <code>PreferenceChangeListener</code>.\n+ *\n+ * @since 1.4\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public interface NodeChangeListener extends EventListener {\n+\n+    /**\n+     * Fired when a sub node is added to the preference node.\n+     */\n+    void childAdded(NodeChangeEvent event);\n+\n+    /**\n+     * Fired when a sub node is removed from the preference node.\n+     */\n+    void childRemoved(NodeChangeEvent event);\n+\n+}"}, {"sha": "de98dbb31815dfbde41c032e34dc5cd8c1ef984f", "filename": "libjava/java/util/prefs/PreferenceChangeEvent.java", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fjava%2Futil%2Fprefs%2FPreferenceChangeEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fjava%2Futil%2Fprefs%2FPreferenceChangeEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fprefs%2FPreferenceChangeEvent.java?ref=63640075b00fe54285339c66554c2c9df27c48e9", "patch": "@@ -0,0 +1,105 @@\n+/* PreferenceChangeEvent - ObjectEvent fired when a Preferences entry changes\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.util.prefs;\n+\n+import java.util.EventObject;\n+\n+/**\n+ * ObjectEvent fired when a Preferences entry changes.\n+ * This event is generated when a entry is added, changed or removed.\n+ * When an entry is removed then <code>getNewValue</code> will return null.\n+ * <p>\n+ * Preference change events are only generated for entries in one particular\n+ * preference node. Notification of subnode addition/removal is given by a\n+ * <code>NodeChangeEvent</code>.\n+ *\n+ * @since 1.4\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public class PreferenceChangeEvent extends EventObject {\n+\n+  private static final long serialVersionUID = 793724513368024975L;\n+  \n+    /**\n+     * The key of the changed entry.\n+     */\n+    private final String key;\n+\n+    /**\n+     * The new value of the changed entry, or null when the entry was removed.\n+     */\n+    private final String newValue;\n+\n+    /**\n+     * Creates a new PreferenceChangeEvent.\n+     *\n+     * @param node The source preference node for which an entry was added,\n+     * changed or removed\n+     * @param key The key of the entry that was added, changed or removed\n+     * @param value The new value of the entry that was added or changed, or\n+     * null when the entry was removed\n+     */\n+    public PreferenceChangeEvent(Preferences node, String key, String value) {\n+        super(node);\n+        this.key = key;\n+        this.newValue = value;\n+    }\n+\n+    /**\n+     * Returns the source Preference node from which an entry was added,\n+     * changed or removed.\n+     */\n+    public Preferences getNode() {\n+        return (Preferences) source;\n+    }\n+\n+    /**\n+     * Returns the key of the entry that was added, changed or removed.\n+     */\n+    public String getKey() {\n+        return key;\n+    }\n+\n+    /**\n+     * Returns the new value of the entry that was added or changed, or\n+     * returns null when the entry was removed.\n+     */\n+    public String getNewValue() {\n+        return newValue;\n+    }\n+}"}, {"sha": "26e17274cb76d9a389a05023450e10251e6871a6", "filename": "libjava/java/util/prefs/PreferenceChangeListener.java", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fjava%2Futil%2Fprefs%2FPreferenceChangeListener.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fjava%2Futil%2Fprefs%2FPreferenceChangeListener.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fprefs%2FPreferenceChangeListener.java?ref=63640075b00fe54285339c66554c2c9df27c48e9", "patch": "@@ -0,0 +1,60 @@\n+/* PreferenceChangeListener - EventListener for Preferences entry changes\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.util.prefs;\n+\n+import java.util.EventListener;\n+\n+/**\n+ * EventListener for Preferences entry addition, change or removal.\n+ * <p>\n+ * Preference change events are only generated for entries in one particular\n+ * preference node. Notification of subnode addition/removal can be monitored\n+ * with a <code>NodeChangeListener</code>.\n+ *\n+ * @since 1.4\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public interface PreferenceChangeListener extends EventListener {\n+\n+    /**\n+     * Fired when a entry has been added, changed or removed from the\n+     * preference node.\n+     */\n+    void preferenceChange(PreferenceChangeEvent event);\n+\n+}"}, {"sha": "8705b77191cbf52fda9e8df06f41783384911ea1", "filename": "libjava/java/util/prefs/Preferences.java", "status": "added", "additions": 665, "deletions": 0, "changes": 665, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fjava%2Futil%2Fprefs%2FPreferences.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fjava%2Futil%2Fprefs%2FPreferences.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fprefs%2FPreferences.java?ref=63640075b00fe54285339c66554c2c9df27c48e9", "patch": "@@ -0,0 +1,665 @@\n+/* Preferences - Preference node containing key value entries and subnodes\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.util.prefs;\n+\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.IOException;\n+\n+import java.security.AccessController;\n+import java.security.Permission;\n+import java.security.PrivilegedAction;\n+\n+import gnu.java.util.prefs.*;\n+\n+/**\n+ * Preference node containing key value entries and subnodes.\n+ * <p>\n+ * There are two preference node trees, a system tree which can be accessed\n+ * by calling <code>systemRoot()</code> containing system preferences usefull\n+ * for all users, and a user tree that can be accessed by calling\n+ * <code>userRoot()</code> containing preferences that can differ between\n+ * different users. How different users are identified is implementation\n+ * depended. It can be determined by Thread, Access Control Context or Subject.\n+ * <p>\n+ * This implementation uses the \"java.util.prefs.PreferencesFactory\" system\n+ * property to find a class that implement <code>PreferencesFactory</code>\n+ * and initialized that class (if it has a public no arguments contructor)\n+ * to get at the actual system or user root. If the system property is not set,\n+ * or the class cannot be initialized it uses the default implementation\n+ * <code>gnu.java.util.prefs.FileBasedFactory</code>.\n+ * <p>\n+ * Besides the two static method above to get the roots of the system and user\n+ * preference node trees there are also two convenience methods to access the\n+ * default preference node for a particular package an object is in. These are\n+ * <code>userNodeForPackage()</code> and <code>systemNodeForPackage()</code>.\n+ * Both methods take an Object as an argument so accessing preferences values\n+ * can be as easy as calling <code>Preferences.userNodeForPackage(this)</code>.\n+ * <p>\n+ * Note that if a security manager is installed all static methods check for\n+ * <code>RuntimePermission(\"preferences\")</code>. But if this permission is\n+ * given to the code then it can access and change all (user) preference nodes\n+ * and entries. So you should be carefull not to store to sensitive information\n+ * or make security decissions based on preference values since there is no\n+ * more fine grained control over what preference values can be changed once\n+ * code has been given the correct runtime permission.\n+ * <p>\n+ * XXX\n+ *\n+ * @since 1.4\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public abstract class Preferences {\n+\n+    // Static Fields\n+\n+    /**\n+     * Default PreferencesFactory class used when the system property\n+     * \"java.util.prefs.PreferencesFactory\" is not set.\n+\t * <p>\n+\t * XXX - Currently set to MemoryBasedPreferencesFactory, should be changed\n+\t * when FileBasedPreferences backend works.\n+     */\n+    private static final String defaultFactoryClass\n+        = \"gnu.java.util.prefs.MemoryBasedPreferencesFactory\";\n+\n+    /** Permission needed to access system or user root. */\n+    private static final Permission prefsPermission\n+        = new RuntimePermission(\"preferences\");\n+\n+    /**\n+     * The preferences factory object that supplies the system and user root.\n+     * Set and returned by the getFactory() method.\n+     */\n+    private static PreferencesFactory factory;\n+\n+    /** Maximum node name length. 80 characters. */\n+    public static final int MAX_NAME_LENGTH = 80;\n+\n+    /** Maximum entry key length. 80 characters. */\n+    public static final int MAX_KEY_LENGTH = 80;\n+\n+    /** Maximum entry value length. 8192 characters. */\n+    public static final int MAX_VALUE_LENGTH = 8192;\n+\n+    // Constructors\n+\n+    /**\n+     * Creates a new Preferences node. Can only be used by subclasses.\n+     * Empty implementation.\n+     */\n+    protected Preferences() {}\n+\n+    // Static methods\n+\n+    /**\n+     * Returns the system preferences root node containing usefull preferences\n+     * for all users. It is save to cache this value since it should always\n+     * return the same preference node.\n+     *\n+     * @return the root system preference node\n+     * @exception SecurityException when a security manager is installed and\n+     * the caller does not have <code>RuntimePermission(\"preferences\")</code>.\n+     */\n+    public static Preferences systemRoot() throws SecurityException {\n+        // Get the preferences factory and check for permission\n+        PreferencesFactory factory = getFactory();\n+\n+        return factory.systemRoot();\n+    }\n+\n+    /**\n+     * Returns the user preferences root node containing preferences for the\n+     * the current user. How different users are identified is implementation\n+     * depended. It can be determined by Thread, Access Control Context or\n+     * Subject.\n+     *\n+     * @return the root user preference node\n+     * @exception SecurityException when a security manager is installed and\n+     * the caller does not have <code>RuntimePermission(\"preferences\")</code>.\n+     */\n+    public static Preferences userRoot() throws SecurityException {\n+        // Get the preferences factory and check for permission\n+        PreferencesFactory factory = getFactory();\n+        return factory.userRoot();\n+    }\n+\n+    /**\n+     * Private helper method for <code>systemRoot()</code> and\n+     * <code>userRoot()</code>. Checks security permission and instantiates the\n+     * correct factory if it has not yet been set.\n+     * <p>\n+     * When the preferences factory has not yet been set this method first\n+     * tries to get the system propery \"java.util.prefs.PreferencesFactory\"\n+     * and tries to initializes that class. If the system property is not set\n+     * or initialization fails it returns an instance of the default factory\n+     * <code>gnu.java.util.prefs.FileBasedPreferencesFactory</code>.\n+     *\n+     * @return the preferences factory to use\n+     * @exception SecurityException when a security manager is installed and\n+     * the caller does not have <code>RuntimePermission(\"preferences\")</code>.\n+     */\n+    private static PreferencesFactory getFactory() throws SecurityException {\n+\n+        // First check for permission\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            sm.checkPermission(prefsPermission);\n+        }\n+\n+        // Get the factory\n+        if (factory == null) {\n+            // Caller might not have enough permissions\n+            factory = (PreferencesFactory) AccessController.doPrivileged(\n+                        new PrivilegedAction() {\n+                            public Object run() {\n+                                PreferencesFactory pf = null;\n+                                String className = System.getProperty\n+                                    (\"java.util.prefs.PreferencesFactory\");\n+                                if (className != null) {\n+                                    try {\n+                                        Class fc = Class.forName(className);\n+                                        Object o = fc.newInstance();\n+                                        pf = (PreferencesFactory) o;\n+                                    } catch (ClassNotFoundException cnfe)\n+                                        {/*ignore*/}\n+                                    catch (InstantiationException ie)\n+                                        {/*ignore*/}\n+                                    catch (IllegalAccessException iae)\n+                                        {/*ignore*/}\n+                                    catch (ClassCastException cce)\n+                                        {/*ignore*/}\n+                                }\n+                                return pf;\n+                            }\n+                        });\n+\n+            // Still no factory? Use our default.\n+            if (factory == null) {\n+                try {\n+                    Object o = Class.forName(defaultFactoryClass);\n+                    factory = (PreferencesFactory) o;\n+                } catch (ClassNotFoundException cnfe) {\n+                    throw new RuntimeException(\"Couldn't load default factory\"\n+                        + \" '\"+ defaultFactoryClass +\"'\");\n+                    // XXX - when using 1.4 compatible throwables add cause\n+                }\n+            }\n+\n+        }\n+        return factory;\n+    }\n+\n+    /**\n+     * Returns the system preferences node for the package of an object.\n+     * The package node name of the object is determined by dropping the\n+     * class name of the object of the fully quallified class name and\n+     * replacing all '.' to '/' in the package name. If the class of the\n+     * object has no package then the package node name is \"<unnamed>\".\n+     * The returened node is <code>systemRoot().node(packageNodeName)</code>.\n+     *\n+     * @param o Object whose default system preference node is requested\n+     * @returns system preferences node that should be used by object o\n+     * @exception SecurityException when a security manager is installed and\n+     * the caller does not have <code>RuntimePermission(\"preferences\")</code>.\n+     */\n+    public static Preferences systemNodeForPackage(Object o)\n+            throws SecurityException\n+    {\n+        return nodeForPackage(o, systemRoot());\n+    }\n+\n+    /**\n+     * Returns the user preferences node for the package of an object.\n+     * The package node name of the object is determined by dropping the\n+     * class name of the object of the fully quallified class name and\n+     * replacing all '.' to '/' in the package name. If the class of the\n+     * object has no package then the package node name is \"<unnamed>\".\n+     * The returened node is <code>userRoot().node(packageNodeName)</code>.\n+     *\n+     * @param o Object whose default user preference node is requested\n+     * @returns user preferences node that should be used by object o\n+     * @exception SecurityException when a security manager is installed and\n+     * the caller does not have <code>RuntimePermission(\"preferences\")</code>.\n+     */\n+    public static Preferences userNodeForPackage(Object o)\n+            throws SecurityException\n+    {\n+        return nodeForPackage(o, userRoot());\n+    }\n+\n+    /**\n+     * Private helper method for <code>systemNodeForPackage()</code> and\n+     * <code>userNodeForPackage()</code>. Given the correct system or user\n+     * root it returns the correct Preference node for the package node name\n+     * of the given object.\n+     */\n+    private static Preferences nodeForPackage(Object o, Preferences root) {\n+        // Get the package path\n+        String className = o.getClass().getName();\n+        String packagePath;\n+        int index = className.lastIndexOf('.');\n+        if(index == -1) {\n+            packagePath = \"<unnamed>\";\n+        } else {\n+            packagePath = className.substring(0,index).replace('.','/');\n+        }\n+\n+        return root.node(packagePath);\n+    }\n+\n+    /**\n+     * XXX\n+     */\n+    public static void importPreferences(InputStream is) \n+                                    throws InvalidPreferencesFormatException,\n+                                           IOException\n+    {\n+        PreferencesFactory factory = getFactory();\n+        NodeReader reader = new NodeReader(is, factory);\n+        reader.importPreferences();\n+    }\n+\n+    // abstract methods (identification)\n+\n+    /**\n+     * Returns the absolute path name of this preference node.\n+     * The absolute path name of a node is the path name of its parent node \n+     * plus a '/' plus its own name. If the node is the root node and has no\n+     * parent then its name is \"\" and its absolute path name is \"/\".\n+     */\n+    abstract public String absolutePath();\n+\n+    /**\n+     * Returns true if this node comes from the user preferences tree, false\n+     * if it comes from the system preferences tree.\n+     */\n+    abstract public boolean isUserNode();\n+\n+    /**\n+     * Returns the name of this preferences node. The name of the node cannot\n+     * be null, can be mostly 80 characters and cannot contain any '/'\n+     * characters. The root node has as name \"\".\n+     */\n+    abstract public String name();\n+\n+    /**\n+     * Returns the String given by\n+     * <code>\n+     * (isUserNode() ? \"User\":\"System\") + \" Preference Node: \" + absolutePath()\n+     * </code>\n+     */\n+    abstract public String toString();\n+\n+    // abstract methods (navigation)\n+\n+    /**\n+     * Returns all the direct sub nodes of this preferences node.\n+     * Needs access to the backing store to give a meaningfull answer.\n+     *\n+     * @exception BackingStoreException when the backing store cannot be\n+     *            reached\n+     * @exception IllegalStateException when this node has been removed\n+     */\n+    abstract public String[] childrenNames() throws BackingStoreException;\n+\n+    /**\n+     * Returns a sub node of this preferences node if the given path is\n+     * relative (does not start with a '/') or a sub node of the root\n+     * if the path is absolute (does start with a '/').\n+     *\n+     * @exception IllegalStateException if this node has been removed\n+     * @exception IllegalArgumentException if the path contains two or more\n+     * consecutive '/' characters, ends with a '/' charactor and is not the\n+     * string \"/\" (indicating the root node) or any name on the path is more\n+     * then 80 characters long\n+     */\n+    abstract public Preferences node(String path);\n+\n+    /**\n+     * Returns true if the node that the path points to exists in memory or\n+     * in the backing store. Otherwise it returns false or an exception is\n+     * thrown. When this node is removed the only valid parameter is the\n+     * empty string (indicating this node), the return value in that case\n+     * will be false.\n+     *\n+     * @exception BackingStoreException when the backing store cannot be\n+     *            reached\n+     * @exception IllegalStateException if this node has been removed\n+     *            and the path is not the empty string (indicating this node)\n+     * @exception IllegalArgumentException if the path contains two or more\n+     * consecutive '/' characters, ends with a '/' charactor and is not the\n+     * string \"/\" (indicating the root node) or any name on the path is more\n+     * then 80 characters long\n+     */\n+    abstract public boolean nodeExists(String path)\n+                                throws BackingStoreException;\n+\n+    /**\n+     * Returns the parent preferences node of this node or null if this is\n+     * the root of the preferences tree.\n+     *\n+     * @exception IllegalStateException if this node has been removed\n+     */\n+    abstract public Preferences parent();\n+\n+    // abstract methods (export)\n+\n+    /**\n+     * XXX\n+     */\n+    abstract public void exportNode(OutputStream os)\n+                                throws BackingStoreException,\n+                                       IOException;\n+\n+    /**\n+     * XXX\n+     */\n+    abstract public void exportSubtree(OutputStream os)\n+                                throws BackingStoreException,\n+                                       IOException;\n+\n+    // abstract methods (preference entry manipulation)\n+\n+    /**\n+     * Returns an (possibly empty) array with all the keys of the preference\n+     * entries of this node.\n+     *\n+     * @exception BackingStoreException when the backing store cannot be\n+     *            reached\n+     * @exception IllegalStateException if this node has been removed\n+     */\n+    abstract public String[] keys() throws BackingStoreException;\n+\n+    /**\n+     * Returns the value associated with the key in this preferences node. If\n+     * the default value of the key cannot be found in the preferences node\n+     * entries or something goes wrong with the backing store the supplied\n+     * default value is returned.\n+     *\n+     * @exception IllegalArgumentException if key is larger then 80 characters\n+     * @exception IllegalStateException if this node has been removed\n+     * @exception NullPointerException if key is null\n+     */\n+    abstract public String get(String key, String defaultVal);\n+\n+    /**\n+     * Convenience method for getting the given entry as a boolean.\n+     * When the string representation of the requested entry is either\n+     * \"true\" or \"false\" (ignoring case) then that value is returned,\n+     * otherwise the given default boolean value is returned.\n+     *\n+     * @exception IllegalArgumentException if key is larger then 80 characters\n+     * @exception IllegalStateException if this node has been removed\n+     * @exception NullPointerException if key is null\n+     */\n+    abstract public boolean getBoolean(String key, boolean defaultVal);\n+\n+    /**\n+     * Convenience method for getting the given entry as a byte array.\n+     * When the string representation of the requested entry is a valid\n+     * Base64 encoded string (without any other characters, such as newlines)\n+     * then the decoded Base64 string is returned as byte array,\n+     * otherwise the given default byte array value is returned.\n+     *\n+     * @exception IllegalArgumentException if key is larger then 80 characters\n+     * @exception IllegalStateException if this node has been removed\n+     * @exception NullPointerException if key is null\n+     */\n+    abstract public byte[] getByteArray(String key, byte[] defaultVal);\n+\n+    /**\n+     * Convenience method for getting the given entry as a double.\n+     * When the string representation of the requested entry can be decoded\n+     * with <code>Double.parseDouble()</code> then that double is returned,\n+     * otherwise the given default double value is returned.\n+     *\n+     * @exception IllegalArgumentException if key is larger then 80 characters\n+     * @exception IllegalStateException if this node has been removed\n+     * @exception NullPointerException if key is null\n+     */\n+    abstract public double getDouble(String key, double defaultVal);\n+\n+    /**\n+     * Convenience method for getting the given entry as a float.\n+     * When the string representation of the requested entry can be decoded\n+     * with <code>Float.parseFloat()</code> then that float is returned,\n+     * otherwise the given default float value is returned.\n+     *\n+     * @exception IllegalArgumentException if key is larger then 80 characters\n+     * @exception IllegalStateException if this node has been removed\n+     * @exception NullPointerException if key is null\n+     */\n+    abstract public float getFloat(String key, float defaultVal);\n+\n+    /**\n+     * Convenience method for getting the given entry as an integer.\n+     * When the string representation of the requested entry can be decoded\n+     * with <code>Integer.parseInt()</code> then that integer is returned,\n+     * otherwise the given default integer value is returned.\n+     *\n+     * @exception IllegalArgumentException if key is larger then 80 characters\n+     * @exception IllegalStateException if this node has been removed\n+     * @exception NullPointerException if key is null\n+     */\n+    abstract public int getInt(String key, int defaultVal);\n+\n+    /**\n+     * Convenience method for getting the given entry as a long.\n+     * When the string representation of the requested entry can be decoded\n+     * with <code>Long.parseLong()</code> then that long is returned,\n+     * otherwise the given default long value is returned.\n+     *\n+     * @exception IllegalArgumentException if key is larger then 80 characters\n+     * @exception IllegalStateException if this node has been removed\n+     * @exception NullPointerException if key is null\n+     */\n+    abstract public long getLong(String key, long defaultVal);\n+\n+    /**\n+     * Sets the value of the given preferences entry for this node.\n+     * Key and value cannot be null, the key cannot exceed 80 characters\n+     * and the value cannot exceed 8192 characters.\n+     * <p>\n+     * The result will be immediatly visible in this VM, but may not be\n+     * immediatly written to the backing store.\n+     *\n+     * @exception NullPointerException if either key or value are null\n+     * @exception IllegalArgumentException if either key or value are to large\n+     * @exception IllegalStateException when this node has been removed\n+     */\n+    abstract public void put(String key, String value);\n+\n+    /**\n+     * Convenience method for setting the given entry as a boolean.\n+     * The boolean is converted with <code>Boolean.toString(value)</code>\n+     * and then stored in the preference entry as that string.\n+     *\n+     * @exception NullPointerException if key is null\n+     * @exception IllegalArgumentException if the key length is to large\n+     * @exception IllegalStateException when this node has been removed\n+     */\n+    abstract public void putBoolean(String key, boolean value);\n+\n+    /**\n+     * Convenience method for setting the given entry as an array of bytes.\n+     * The byte array is converted to a Base64 encoded string\n+     * and then stored in the preference entry as that string.\n+     * <p>\n+     * Note that a byte array encoded as a Base64 string will be about 1.3\n+     * times larger then the original length of the byte array, which means\n+     * that the byte array may not be larger about 6 KB.\n+     *\n+     * @exception NullPointerException if either key or value are null\n+     * @exception IllegalArgumentException if either key or value are to large\n+     * @exception IllegalStateException when this node has been removed\n+     */\n+    abstract public void putByteArray(String key, byte[] value);\n+\n+    /**\n+     * Convenience method for setting the given entry as a double.\n+     * The double is converted with <code>Double.toString(double)</code>\n+     * and then stored in the preference entry as that string.\n+     *\n+     * @exception NullPointerException if the key is null\n+     * @exception IllegalArgumentException if the key length is to large\n+     * @exception IllegalStateException when this node has been removed\n+     */\n+    abstract public void putDouble(String key, double value);\n+\n+    /**\n+     * Convenience method for setting the given entry as a float.\n+     * The float is converted with <code>Float.toString(float)</code>\n+     * and then stored in the preference entry as that string.\n+     *\n+     * @exception NullPointerException if the key is null\n+     * @exception IllegalArgumentException if the key length is to large\n+     * @exception IllegalStateException when this node has been removed\n+     */\n+    abstract public void putFloat(String key, float value);\n+\n+    /**\n+     * Convenience method for setting the given entry as an integer.\n+     * The integer is converted with <code>Integer.toString(int)</code>\n+     * and then stored in the preference entry as that string.\n+     *\n+     * @exception NullPointerException if the key is null\n+     * @exception IllegalArgumentException if the key length is to large\n+     * @exception IllegalStateException when this node has been removed\n+     */\n+    abstract public void putInt(String key, int value);\n+\n+    /**\n+     * Convenience method for setting the given entry as a long.\n+     * The long is converted with <code>Long.toString(long)</code>\n+     * and then stored in the preference entry as that string.\n+     *\n+     * @exception NullPointerException if the key is null\n+     * @exception IllegalArgumentException if the key length is to large\n+     * @exception IllegalStateException when this node has been removed\n+     */\n+    abstract public void putLong(String key, long value);\n+\n+    /**\n+     * Removes the preferences entry from this preferences node.\n+     * <p>\n+     * The result will be immediatly visible in this VM, but may not be\n+     * immediatly written to the backing store.\n+     *\n+     * @exception NullPointerException if the key is null\n+     * @exception IllegalArgumentException if the key length is to large\n+     * @exception IllegalStateException when this node has been removed\n+     */\n+    abstract public void remove(String key);\n+\n+    // abstract methods (preference node manipulation)\n+\n+    /**\n+     * Removes all entries from this preferences node. May need access to the\n+     * backing store to get and clear all entries.\n+     * <p>\n+     * The result will be immediatly visible in this VM, but may not be\n+     * immediatly written to the backing store.\n+     *\n+     * @exception BackingStoreException when the backing store cannot be\n+     *            reached\n+     * @exception IllegalStateException if this node has been removed\n+     */\n+    abstract public void clear() throws BackingStoreException;\n+\n+    /**\n+     * Writes all preference changes on this and any subnode that have not\n+     * yet been written to the backing store. This has no effect on the\n+     * preference entries in this VM, but it makes sure that all changes\n+     * are visible to other programs (other VMs might need to call the\n+     * <code>sync()</code> method to actually see the changes to the backing\n+     * store.\n+     *\n+     * @exception BackingStoreException when the backing store cannot be\n+     *            reached\n+     * @exception IllegalStateException if this node has been removed\n+     */\n+    abstract public void flush() throws BackingStoreException;\n+\n+    /**\n+     * Writes and reads all preference changes to and from this and any\n+     * subnodes. This makes sure that all local changes are written to the\n+     * backing store and that all changes to the backing store are visible\n+     * in this preference node (and all subnodes).\n+     *\n+     * @exception BackingStoreException when the backing store cannot be\n+     *            reached\n+     * @exception IllegalStateException if this node has been removed\n+     */\n+    abstract public void sync() throws BackingStoreException;\n+\n+    /**\n+     * Removes this and all subnodes from the backing store and clears all\n+     * entries. After removal this instance will not be useable (except for\n+     * a few methods that don't throw a <code>InvalidStateException</code>),\n+     * even when a new node with the same path name is created this instance\n+     * will not be usable again. The root (system or user) may never be removed.\n+     * <p>\n+     * Note that according to the specification an implementation may delay\n+     * removal of the node from the backing store till the <code>flush()</code>\n+     * method is called. But the <code>flush()</code> method may throw a \n+     * <code>IllegalStateException</code> when the node has been removed.\n+     * So most implementations will actually remove the node and any subnodes\n+     * from the backing store immediatly.\n+     *\n+     * @exception BackingStoreException when the backing store cannot be\n+     *            reached\n+     * @exception IllegalStateException if this node has already been removed\n+     * @exception UnsupportedOperationException if this is a root node\n+     */\n+    abstract public void removeNode() throws BackingStoreException;\n+\n+    // abstract methods (listeners)\n+\n+    abstract public void addNodeChangeListener(NodeChangeListener listener);\n+\n+    abstract public void addPreferenceChangeListener\n+                            (PreferenceChangeListener listener);\n+\n+    abstract public void removeNodeChangeListener(NodeChangeListener listener);\n+\n+    abstract public void removePreferenceChangeListener\n+                            (PreferenceChangeListener listener);\n+\n+}\n+"}, {"sha": "f43497894f1e65c853153bd03ecb64f4f4cffdfd", "filename": "libjava/java/util/prefs/PreferencesFactory.java", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fjava%2Futil%2Fprefs%2FPreferencesFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63640075b00fe54285339c66554c2c9df27c48e9/libjava%2Fjava%2Futil%2Fprefs%2FPreferencesFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fprefs%2FPreferencesFactory.java?ref=63640075b00fe54285339c66554c2c9df27c48e9", "patch": "@@ -0,0 +1,66 @@\n+/* PreferencesFactory - Preferences system and user root factory interface\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.util.prefs;\n+\n+import java.util.EventListener;\n+\n+/**\n+ * Preferences system and user root factory interface. Defines how to get\n+ * to the system and user root preferences objects. Should be implemented by\n+ * new preferences backends.\n+ *\n+ * @since 1.4\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public interface PreferencesFactory {\n+\n+    /**\n+     * Returns the system root preferences node. Should always return the\n+     * same object.\n+     */\n+    Preferences systemRoot();\n+\n+    /**\n+     * Returns the user root preferences node. May return different objects\n+     * depending on the user that called this method. The user may for example\n+     * be determined by the current Thread or the Subject associated with the\n+     * current AccessControllContext.\n+     */\n+    Preferences userRoot();\n+\n+}"}]}