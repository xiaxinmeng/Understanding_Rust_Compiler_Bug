{"sha": "27ee75dbe81bb781214c66a9e6a759c08b7deb60", "node_id": "C_kwDOANBUbNoAKDI3ZWU3NWRiZTgxYmI3ODEyMTRjNjZhOWU2YTc1OWMwOGI3ZGViNjA", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-04-29T15:38:15Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-04-29T15:38:41Z"}, "message": "ipa: Release body of clone_of when removing its last clone (PR 100413)\n\nIn the PR, the verifier complains that we did not manage to remove the\nbody of a node and it is right.  The node is kept for materialization\nof two clones but after one is materialized, the other one is removed\nas unneeded (as a part of delete_unreachable_blocks_update_callgraph).\nThe problem is that the node removal does not check for this situation\nand can leave the clone_of node there with a body attached to it even\nthough there is no use for it any more.  This patch does checks for it\nand handles the situation in a simlar way that\ncgraph_node::materialize_clone does it, except that it also has to be\ncareful that the removed node itself does not have any clones, which\nwould still need the clone_of's body.  Failing to do that results in a\nbootstrap failure.\n\ngcc/ChangeLog:\n\n2022-04-27  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/100413\n\t* cgraph.cc (cgraph_node::remove): Release body of the node this\n\tis clone_of if appropriate.\n\ngcc/testsuite/ChangeLog:\n\n2022-04-27  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/100413\n\t* g++.dg/ipa/pr100413.C: New test.", "tree": {"sha": "be7d8a6d76b1bc5e8ae8a1e910d1e8b77d548b42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be7d8a6d76b1bc5e8ae8a1e910d1e8b77d548b42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27ee75dbe81bb781214c66a9e6a759c08b7deb60", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmJsBoEACgkQv2PBvD+k\nNUCwuhAArO3uYSElC+QF+ktkMJWGHyQ7AhXX9TyBgLdCrVFlFXoLoHXW+55rhQUa\npPHeS94LFIKokLD2EY5mMv+oZS09/7WakamSKMuKrFfwh3yCN2Sy77Fvz2cD6pgB\n9MZ6a00jX0iX2eXQaTRwdAKwhohh6edQhtM0LeeckPbGYKNUVvZQR2zrX/dqp/L1\nwQc1J67JEiPFl0zIt8VDc5oHqf1X8LEx5VT2PJMWoVMUHuVawayp2T6tol6vt339\n/fJefgYGNCKoAv93XViO0mlnw6ayHYZKmES3fGCcYAg3QURvMsigZRpi7bt4m3Po\nrDhmHj8p58Fw5yLMlrhWRFDQII0FAkB71nUMnu924rOn/2CLTLKbBctDIrIdGGAY\nSNdkerL0YvqU58ygW7NFu8Tvgl6OBxGE/GR2+Egc1b3iWnOZ+7+xSGHukKy9SFSq\n/qwnbvefpe+8zIN5Ss5kJXlZYAmAV+3nmRXCckfR0A7N4F1kX/p4/ICwzYv9xzlt\nS0iVkWvOdJXmHi8BXUltbZfC9rsLekwOB06mPnQsVsanCY3Q0RspZS9CO3CDxXfI\nenrFdaOozLAvw4TQ/0s0ntz3Pg/y3adGB9ywJjaFfsCjdCJ0nwAUgqq21keVo+Ul\nl0UULVFFMfi0KXMvnqOTwqx30lMQiP21wsuxoK/C7OczDQfsDWs=\n=M7cW\n-----END PGP SIGNATURE-----", "payload": "tree be7d8a6d76b1bc5e8ae8a1e910d1e8b77d548b42\nparent 210cda732832ec589b02c722b2c73f7fa50b97ce\nauthor Martin Jambor <mjambor@suse.cz> 1651246695 +0200\ncommitter Martin Jambor <mjambor@suse.cz> 1651246721 +0200\n\nipa: Release body of clone_of when removing its last clone (PR 100413)\n\nIn the PR, the verifier complains that we did not manage to remove the\nbody of a node and it is right.  The node is kept for materialization\nof two clones but after one is materialized, the other one is removed\nas unneeded (as a part of delete_unreachable_blocks_update_callgraph).\nThe problem is that the node removal does not check for this situation\nand can leave the clone_of node there with a body attached to it even\nthough there is no use for it any more.  This patch does checks for it\nand handles the situation in a simlar way that\ncgraph_node::materialize_clone does it, except that it also has to be\ncareful that the removed node itself does not have any clones, which\nwould still need the clone_of's body.  Failing to do that results in a\nbootstrap failure.\n\ngcc/ChangeLog:\n\n2022-04-27  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/100413\n\t* cgraph.cc (cgraph_node::remove): Release body of the node this\n\tis clone_of if appropriate.\n\ngcc/testsuite/ChangeLog:\n\n2022-04-27  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/100413\n\t* g++.dg/ipa/pr100413.C: New test.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27ee75dbe81bb781214c66a9e6a759c08b7deb60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27ee75dbe81bb781214c66a9e6a759c08b7deb60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27ee75dbe81bb781214c66a9e6a759c08b7deb60/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "210cda732832ec589b02c722b2c73f7fa50b97ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/210cda732832ec589b02c722b2c73f7fa50b97ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/210cda732832ec589b02c722b2c73f7fa50b97ce"}], "stats": {"total": 70, "additions": 69, "deletions": 1}, "files": [{"sha": "4bb9e7ba6af98a85c857d97ff7888fa0f2df81d6", "filename": "gcc/cgraph.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ee75dbe81bb781214c66a9e6a759c08b7deb60/gcc%2Fcgraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ee75dbe81bb781214c66a9e6a759c08b7deb60/gcc%2Fcgraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.cc?ref=27ee75dbe81bb781214c66a9e6a759c08b7deb60", "patch": "@@ -1893,7 +1893,11 @@ cgraph_node::remove (void)\n   if (prev_sibling_clone)\n     prev_sibling_clone->next_sibling_clone = next_sibling_clone;\n   else if (clone_of)\n-    clone_of->clones = next_sibling_clone;\n+    {\n+      clone_of->clones = next_sibling_clone;\n+      if (!clone_of->analyzed && !clone_of->clones && !clones)\n+\tclone_of->release_body ();\n+    }\n   if (next_sibling_clone)\n     next_sibling_clone->prev_sibling_clone = prev_sibling_clone;\n   if (clones)"}, {"sha": "96d71e7cf3533942a822a0ffd231d84a00e8d9a3", "filename": "gcc/testsuite/g++.dg/ipa/pr100413.C", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27ee75dbe81bb781214c66a9e6a759c08b7deb60/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr100413.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27ee75dbe81bb781214c66a9e6a759c08b7deb60/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr100413.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr100413.C?ref=27ee75dbe81bb781214c66a9e6a759c08b7deb60", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c++11 -O2 -fno-guess-branch-probability -fno-inline-functions-called-once -fipa-cp-clone -fipa-pta -fnon-call-exceptions --param=ipa-cp-eval-threshold=0\" } */\n+\n+\n+template <typename> class allocator {\n+public:\n+  ~allocator();\n+};\n+template <typename> struct allocator_traits;\n+template <typename _Tp> struct allocator_traits<allocator<_Tp>> {\n+  using allocator_type = allocator<_Tp>;\n+  template <typename _Up> using rebind_alloc = allocator<_Up>;\n+  static void deallocate(allocator_type);\n+};\n+template <typename _ForwardIterator, typename _Tp>\n+void _Destroy(_ForwardIterator, _ForwardIterator, _Tp);\n+struct __alloc_traits : allocator_traits<allocator<int>> {\n+  struct rebind {\n+    typedef rebind_alloc<int> other;\n+  };\n+};\n+struct _Vector_base {\n+  struct _Vector_impl_data {\n+    int _M_start;\n+    int _M_finish;\n+  };\n+  struct _Vector_impl : __alloc_traits::rebind::other, _Vector_impl_data {};\n+  __alloc_traits::rebind::other _M_get_Tp_allocator();\n+  ~_Vector_base() { _M_deallocate(); }\n+  _Vector_impl _M_impl;\n+  void _M_deallocate() { __alloc_traits::deallocate(_M_impl); }\n+};\n+class vector : _Vector_base {\n+public:\n+  vector() noexcept {\n+    allocator<int> __trans_tmp_1 = _M_get_Tp_allocator();\n+    _Destroy(_M_impl._M_start, _M_impl._M_finish, __trans_tmp_1);\n+  }\n+  void size();\n+};\n+struct HTTPCallback {\n+  virtual void OnFailure();\n+};\n+struct ContentCallback {\n+  virtual void OnDownloadProgress();\n+};\n+class ClientNetworkContentSocketHandler : ContentCallback, HTTPCallback {\n+  vector requested;\n+  vector infos;\n+  vector lastActivity;\n+  void OnFailure();\n+public:\n+  int IDLE_TIMEOUT = 0;\n+  ClientNetworkContentSocketHandler();\n+  void DownloadSelectedContent();\n+} _network_content_client;\n+void ClientNetworkContentSocketHandler::DownloadSelectedContent() {\n+  vector content;\n+  content.size();\n+}\n+void ClientNetworkContentSocketHandler::OnFailure() {\n+  DownloadSelectedContent();\n+}\n+ClientNetworkContentSocketHandler::ClientNetworkContentSocketHandler() {}"}]}