{"sha": "33a9ae4927a417391c01773efa091e748ed5c4d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNhOWFlNDkyN2E0MTczOTFjMDE3NzNlZmEwOTFlNzQ4ZWQ1YzRkMA==", "commit": {"author": {"name": "Thomas Fitzsimmons", "email": "fitzsim@redhat.com", "date": "2005-05-18T15:36:07Z"}, "committer": {"name": "Thomas Fitzsimmons", "email": "fitzsim@gcc.gnu.org", "date": "2005-05-18T15:36:07Z"}, "message": "re PR libgcj/19729 (libgcj DSASignature.java null pointer exception)\n\n2005-05-18  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\tPR libgcj/19729\n\t* gnu/java/security/provider/DSASignature.java: Import updates\n\tfrom GNU Crypto.\n\nFrom-SVN: r99904", "tree": {"sha": "0e197bb237a5e2554417cf27436269efa7545b38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e197bb237a5e2554417cf27436269efa7545b38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33a9ae4927a417391c01773efa091e748ed5c4d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33a9ae4927a417391c01773efa091e748ed5c4d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33a9ae4927a417391c01773efa091e748ed5c4d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33a9ae4927a417391c01773efa091e748ed5c4d0/comments", "author": null, "committer": null, "parents": [{"sha": "9a6411ed3017504e23874b29150e06f9126788a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a6411ed3017504e23874b29150e06f9126788a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a6411ed3017504e23874b29150e06f9126788a5"}], "stats": {"total": 216, "additions": 105, "deletions": 111}, "files": [{"sha": "63d96f8a554e2e3bebadb55fff020f24a57cf4d4", "filename": "libjava/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33a9ae4927a417391c01773efa091e748ed5c4d0/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33a9ae4927a417391c01773efa091e748ed5c4d0/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=33a9ae4927a417391c01773efa091e748ed5c4d0", "patch": "@@ -1,3 +1,9 @@\n+2005-05-18  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\tPR libgcj/19729\n+\t* gnu/java/security/provider/DSASignature.java: Import updates\n+\tfrom GNU Crypto.\n+\n 2005-05-18  Anthony Green  <green@redhat.com>\n \n \t* jni/gtk-peer/gtk_jawt.c (classpath_jawt_object_lock,"}, {"sha": "211cdb8cc3f89f6738d4d42bc1c5ce66f389df2c", "filename": "libjava/gnu/java/security/provider/DSASignature.java", "status": "modified", "additions": 99, "deletions": 111, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33a9ae4927a417391c01773efa091e748ed5c4d0/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FDSASignature.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33a9ae4927a417391c01773efa091e748ed5c4d0/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FDSASignature.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fsecurity%2Fprovider%2FDSASignature.java?ref=33a9ae4927a417391c01773efa091e748ed5c4d0", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -51,7 +51,6 @@\n import java.security.InvalidParameterException;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n-import java.security.NoSuchProviderException;\n import java.security.PrivateKey;\n import java.security.PublicKey;\n import java.security.SecureRandom;\n@@ -67,54 +66,49 @@ public class DSASignature extends SignatureSpi\n {\n   private DSAPublicKey publicKey;\n   private DSAPrivateKey privateKey;\n-  private MessageDigest digest = null;\n+  private final MessageDigest digest;\n+  private final SecureRandom random;\n \n-  public DSASignature()\n-  {}\n+  public DSASignature() throws NoSuchAlgorithmException\n+  {\n+    random = new SecureRandom();\n+    digest = MessageDigest.getInstance (\"SHA1\");\n+  }\n \n   private void init()\n   {\n-    if( digest == null ) {\n-      try {\n-\tdigest = MessageDigest.getInstance( \"SHA1\", \"GNU\" );\n-      } catch ( NoSuchAlgorithmException nsae ) {\n-\tdigest = null;\n-      } catch ( NoSuchProviderException nspe ) {\n-\tdigest = null;\n-      }\n-    }\n     digest.reset();\n   }\n \n-  public void engineInitVerify(PublicKey publicKey)\n+  public void engineInitVerify (PublicKey publicKey)\n     throws InvalidKeyException\n   {\n-    if( publicKey instanceof DSAPublicKey )\n-      this.publicKey = (DSAPublicKey)publicKey;\n+    if (publicKey instanceof DSAPublicKey)\n+      this.publicKey = (DSAPublicKey) publicKey;\n     else\n       throw new InvalidKeyException();\n     init();\n   }\n \n-  public void engineInitSign(PrivateKey privateKey)\n+  public void engineInitSign (PrivateKey privateKey)\n     throws InvalidKeyException\n   {\n-    if( privateKey instanceof DSAPrivateKey )\n-      this.privateKey = (DSAPrivateKey)privateKey;\n+    if (privateKey instanceof DSAPrivateKey)\n+      this.privateKey = (DSAPrivateKey) privateKey;\n     else\n-      throw new InvalidKeyException();\n+      throw new InvalidKeyException (\"not a DSA private key\");\n \n     init();\n   }\n \n-  public void engineInitSign(PrivateKey privateKey, \n-\t\t\t     SecureRandom random)\n+  public void engineInitSign (PrivateKey privateKey,\n+                              SecureRandom random)\n     throws InvalidKeyException\n   {\n-    if( privateKey instanceof DSAPrivateKey )\n-      this.privateKey = (DSAPrivateKey)privateKey;\n+    if (privateKey instanceof DSAPrivateKey)\n+      this.privateKey = (DSAPrivateKey) privateKey;\n     else\n-      throw new InvalidKeyException();\n+      throw new InvalidKeyException (\"not a DSA private key\");\n \n     appRandom = random;\n     init();\n@@ -123,141 +117,135 @@ public void engineInitSign(PrivateKey privateKey,\n   public void engineUpdate(byte b)\n     throws SignatureException\n   {\n-    if( digest == null )\n-      throw new SignatureException();\t\t\n-\n-    digest.update( b );\n+    digest.update (b);\n   }\n \n-  public void engineUpdate(byte[] b, int off, int len)\n+  public void engineUpdate (byte[] b, int off, int len)\n     throws SignatureException\n   {\n-    if( digest == null )\n-      throw new SignatureException();\t\t\n-\n-    digest.update( b, off, len );\n+    digest.update (b, off, len);\n   }\n \n-  public byte[] engineSign()\n-    throws SignatureException\n+  public byte[] engineSign() throws SignatureException\n   {\n-    if( digest == null )\n-      throw new SignatureException();\t\t\n-    if( privateKey == null)\n-      throw new SignatureException();\t\t\n+    if (privateKey == null)\n+      throw new SignatureException (\"not initialized for signing\");\n \n-    try {\n+    try\n+      {\n+        BigInteger g = privateKey.getParams().getG();\n+        BigInteger p = privateKey.getParams().getP();\n+        BigInteger q = privateKey.getParams().getQ();\n \n-      BigInteger g = privateKey.getParams().getG();\n-      BigInteger p = privateKey.getParams().getP();\n-      BigInteger q = privateKey.getParams().getQ();\n+        BigInteger x = privateKey.getX();\n \n-      BigInteger x = privateKey.getX();\n+        BigInteger k = new BigInteger (159, appRandom != null ? appRandom : random);\n \n-      BigInteger k = new BigInteger( 159, (Random)appRandom );\n+        BigInteger r = g.modPow(k, p);\n+        r = r.mod(q);\n \n-      BigInteger r = g.modPow(k, p);\n-      r = r.mod(q);\n+        byte bytes[] = digest.digest();\n+        BigInteger sha = new BigInteger (1, bytes);\n \n-      byte bytes[] = digest.digest();\n-      BigInteger sha = new BigInteger(1, bytes);\n+        BigInteger s = sha.add (x.multiply (r));\n+        s = s.multiply (k.modInverse(q)).mod (q);\n \n-      BigInteger s = sha.add( x.multiply( r ) );\n-      s = s.multiply( k.modInverse(q) ).mod( q );\n-\n-      ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-      ArrayList seq = new ArrayList(2);\n-      seq.set(0, new DERValue(DER.INTEGER, r));\n-      seq.set(1, new DERValue(DER.INTEGER, s));\n-      DERWriter.write(bout, new DERValue(DER.CONSTRUCTED | DER.SEQUENCE, seq));\n-      return bout.toByteArray();\n-    } catch (IOException ioe) {\n-      throw new SignatureException();\n-    } catch ( ArithmeticException ae ) {\n-      throw new SignatureException();\n-    }\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        ArrayList seq = new ArrayList (2);\n+        seq.add(0, new DERValue (DER.INTEGER, r));\n+        seq.add(1, new DERValue (DER.INTEGER, s));\n+        DERWriter.write (bout, new DERValue (DER.CONSTRUCTED | DER.SEQUENCE, seq));\n+        return bout.toByteArray();\n+      }\n+    catch (IOException ioe)\n+      {\n+        SignatureException se = new SignatureException();\n+        se.initCause (ioe);\n+        throw se;\n+      }\n+    catch (ArithmeticException ae)\n+      {\n+        SignatureException se = new SignatureException();\n+        se.initCause (ae);\n+        throw se;\n+      }\n   }\n \n-  public int engineSign(byte[] outbuf, int offset, int len)\n+  public int engineSign (byte[] outbuf, int offset, int len)\n     throws SignatureException\n   {\n     byte tmp[] = engineSign();\n-    if( tmp.length > len )\n-      throw new SignatureException();\n-    System.arraycopy( tmp, 0, outbuf, offset, tmp.length );\n+    if (tmp.length > len)\n+      throw new SignatureException (\"output buffer too short\");\n+    System.arraycopy (tmp, 0, outbuf, offset, tmp.length);\n     return tmp.length;\n   }\n \n-  public boolean engineVerify(byte[] sigBytes)\n+  public boolean engineVerify (byte[] sigBytes)\n     throws SignatureException\n   {\n-    //Decode sigBytes from ASN.1 DER encoding\n-    try {\n-      DERReader in = new DERReader(sigBytes);\n-      DERValue val = in.read();\n-      if (!val.isConstructed())\n-        throw new SignatureException(\"badly formed signature\");\n-      BigInteger r = (BigInteger) in.read().getValue();\n-      BigInteger s = (BigInteger) in.read().getValue();\n+    // Decode sigBytes from ASN.1 DER encoding\n+    try\n+      {\n+        DERReader in = new DERReader (sigBytes);\n+        DERValue val = in.read();\n+        if (!val.isConstructed())\n+          throw new SignatureException (\"badly formed signature\");\n+        BigInteger r = (BigInteger) in.read().getValue();\n+        BigInteger s = (BigInteger) in.read().getValue();\n \n-      BigInteger g = publicKey.getParams().getG();\n-      BigInteger p = publicKey.getParams().getP();\n-      BigInteger q = publicKey.getParams().getQ();\n+        BigInteger g = publicKey.getParams().getG();\n+        BigInteger p = publicKey.getParams().getP();\n+        BigInteger q = publicKey.getParams().getQ();\n \n-      BigInteger y = publicKey.getY();\n+        BigInteger y = publicKey.getY();\n \n-      BigInteger w = s.modInverse( q );\n+        BigInteger w = s.modInverse (q);\n \n-      byte bytes[] = digest.digest();\n-      BigInteger sha = new BigInteger(1, bytes);\n+        byte bytes[] = digest.digest();\n+        BigInteger sha = new BigInteger (1, bytes);\n \n-      BigInteger u1 = w.multiply( sha ).mod( q );\n+        BigInteger u1 = w.multiply (sha).mod ( q );\n \n-      BigInteger u2 = r.multiply( w ).mod( q );\n+        BigInteger u2 = r.multiply (w).mod(q);\n \n-      //This should test the compiler :)\n-      BigInteger v = g.modPow( u1, p ).multiply( y.modPow( u2, p ) ).mod( p ).mod( q );\n+        BigInteger v = g.modPow (u1, p).multiply (y.modPow (u2, p)).mod (p).mod (q);\n \n-      if( v.equals( r ) )\n-\treturn true;\n-      else\n-\treturn false;\n-    } catch (IOException ioe) {\n-      throw new SignatureException(\"badly formed signature\");\n-    }\n+        if (v.equals (r))\n+          return true;\n+        else\n+          return false;\n+      }\n+    catch (IOException ioe)\n+      {\n+        SignatureException se = new SignatureException (\"badly formed signature\");\n+        se.initCause (ioe);\n+        throw se;\n+      }\n   }\n \n-  public void engineSetParameter(String param,\n-\t\t\t\t Object value)\n+  public void engineSetParameter (String param,\n+                                  Object value)\n     throws InvalidParameterException\n   {\n     throw new InvalidParameterException();\n   }\n \n-  public void engineSetParameter(AlgorithmParameterSpec params)\n+  public void engineSetParameter (AlgorithmParameterSpec params)\n     throws InvalidAlgorithmParameterException\n   {\n     throw new InvalidParameterException();\n \n   }\n \n-  public Object engineGetParameter(String param)\n+  public Object engineGetParameter (String param)\n     throws InvalidParameterException\n   {\n     throw new InvalidParameterException();\n   }\n \n-  public Object clone()\n-    //throws CloneNotSupportedException\n-  {\n-    return new DSASignature( this );\n-  }\n-\n-  private DSASignature( DSASignature copy )\n+  public Object clone() throws CloneNotSupportedException\n   {\n-    this();\n-    this.publicKey = copy.publicKey;\n-    this.privateKey = copy.privateKey;\n-    this.digest = copy.digest;\n+    return super.clone();\n   }\n }"}]}