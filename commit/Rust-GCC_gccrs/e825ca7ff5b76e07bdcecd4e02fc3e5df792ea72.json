{"sha": "e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgyNWNhN2ZmNWI3NmUwN2JkY2VjZDRlMDJmYzNlNWRmNzkyZWE3Mg==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2002-12-09T00:04:00Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2002-12-09T00:04:00Z"}, "message": "Connection.java (getJarFile): download and cache remote jar files.\n\n\t* gnu/gcj/protocol/jar/Connection.java (getJarFile): download and\n\tcache remote jar files.\n\t* gnu/gcj/runtime/VMClassLoader.java: Don't construct jar URL, only\n\tadd File.separator to URL when it is a directory.\n\t* java/lang/ClassLoader.java: Add Classpath javadoc.\n\t(parent): final.\n\t(getParent): Add (disabled) security check.\n\t(findLibrary): New default method.\n\t* java/net/JarURLConnection.java (getManifest): Implement.\n\t(getInputStream): Only create InputStream when entry exists.\n\t(getHeaders): Only use jarFileURLConnection or JarEntry to set length\n\twhen they exist.\n\t* java/net/URLClassLoader.java: New/Rewritten version from Classpath.\n\nFrom-SVN: r59949", "tree": {"sha": "6e19dd042b0e115509080d56c741014c959ca437", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e19dd042b0e115509080d56c741014c959ca437"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72/comments", "author": null, "committer": null, "parents": [{"sha": "24632117ce14a2ced57f5ab3fb4551d5c985f04d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24632117ce14a2ced57f5ab3fb4551d5c985f04d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24632117ce14a2ced57f5ab3fb4551d5c985f04d"}], "stats": {"total": 1396, "additions": 1065, "deletions": 331}, "files": [{"sha": "15ce27c61654fac90098aa4d5d55690774d89b4b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72", "patch": "@@ -1,3 +1,19 @@\n+2002-12-08  Mark Wielaard  <mark@klomp.org>\n+\n+\t* gnu/gcj/protocol/jar/Connection.java (getJarFile): download and\n+\tcache remote jar files.\n+\t* gnu/gcj/runtime/VMClassLoader.java: Don't construct jar URL, only\n+\tadd File.separator to URL when it is a directory.\n+\t* java/lang/ClassLoader.java: Add Classpath javadoc.\n+\t(parent): final.\n+\t(getParent): Add (disabled) security check.\n+\t(findLibrary): New default method.\n+\t* java/net/JarURLConnection.java (getManifest): Implement.\n+\t(getInputStream): Only create InputStream when entry exists.\n+\t(getHeaders): Only use jarFileURLConnection or JarEntry to set length\n+\twhen they exist.\n+\t* java/net/URLClassLoader.java: New/Rewritten version from Classpath.\n+\n 2002-12-08  Mark Wielaard  <mark@klomp.org>\n \n \t* java/util/ResourceBundle.java (resourceBundleCache): Not final."}, {"sha": "c9db04997dc2c7d7317583a070d3cf84ee9e5b40", "filename": "libjava/gnu/gcj/protocol/jar/Connection.java", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72/libjava%2Fgnu%2Fgcj%2Fprotocol%2Fjar%2FConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72/libjava%2Fgnu%2Fgcj%2Fprotocol%2Fjar%2FConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fprotocol%2Fjar%2FConnection.java?ref=e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1999  Free Software Foundation\n+/* Copyright (C) 1999, 2002  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -9,19 +9,21 @@\n package gnu.gcj.protocol.jar;\n \n import java.net.URL;\n+import java.net.URLConnection;\n import java.net.JarURLConnection;\n import java.net.URLStreamHandler;\n import java.net.MalformedURLException;\n import java.net.ProtocolException;\n import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n import java.util.jar.JarFile;\n+import java.util.zip.ZipFile;\n import java.util.Hashtable;\n \n /**\n  * Written using on-line Java Platform 1.2 API Specification.\n- * Status: Needs a way to download jar files and store them in the local file\n- * system.  I don't know how to do that in a portable way.  For now, it can only handle \n- * connections to a jar:file: url's.\n  *\n  * @author Kresten Krab Thorup <krab@gnu.org>\n  * @date Aug 10, 1999.\n@@ -70,14 +72,19 @@ public synchronized JarFile getJarFile() throws java.io.IOException\n       }\n     else\n       {\n-\t/*\n-\t  FIXME: Here we need to download and cache the jar\n-\t  file in the local file system!  Stupid design.  Why\n-\t  can't we just create a JarFile from a bag of bytes?\n-\t*/\n-\n-\tthrow new java.io.IOException(\"cannot create jar file from \" +\n-\t\t\t\t      jarFileURL);\n+\tURLConnection urlconn = jarFileURL.openConnection();\n+\tInputStream is = urlconn.getInputStream();\n+\tbyte[] buf = new byte[4*1024];\n+\tFile f = File.createTempFile(\"cache\", \"jar\");\n+\tFileOutputStream fos = new FileOutputStream(f);\n+\tint len = 0;\n+\twhile((len = is.read(buf)) != -1)\n+\t  fos.write(buf, 0, len);\n+        fos.close();\n+\t// Always verify the Manifest, open read only and delete when done.\n+\t// XXX ZipFile.OPEN_DELETE not yet implemented.\n+\t// jf = new JarFile(f, true, ZipFile.OPEN_READ | ZipFile.OPEN_DELETE);\n+\tjarfile = new JarFile(f, true, ZipFile.OPEN_READ);\n       }\n \n     return jarfile;"}, {"sha": "fd0c32c2c57dbb39c271be84efab3ab138d121b4", "filename": "libjava/gnu/gcj/runtime/VMClassLoader.java", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72/libjava%2Fgnu%2Fgcj%2Fruntime%2FVMClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72/libjava%2Fgnu%2Fgcj%2Fruntime%2FVMClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FVMClassLoader.java?ref=e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1999, 2001  Free Software Foundation\n+/* Copyright (C) 1999, 2001, 2002  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -33,23 +33,10 @@ private static URL[] init()\n \tString e = st.nextToken ();\n \ttry\n \t  {\n-\t    if (e.endsWith(\".jar\") || e.endsWith (\".zip\"))\n-\t      {\n-\t\tFile archive = new File (e);\n-\t\ttry {\n-\t\t  p.addElement(new URL(\"jar\", \"\", -1, \"file://\"\n-\t\t\t\t       + archive.getCanonicalPath ()\n-\t\t\t\t       + \"!/\"));\n-\t\t} catch (IOException ex) {\n-\t\t  // empty\n-\t\t}\n-\t      }\n-\t    else if (e.endsWith (\"/\"))\n-\t      p.addElement (new URL(\"file\", \"\", -1, e));\n-\t    else if (new File (e).isDirectory ())\n-\t      p.addElement (new URL(\"file\", \"\", -1, e + \"/\"));\n+\t    if (!e.endsWith (File.separator) && new File (e).isDirectory ())\n+\t      p.addElement (new URL(\"file\", \"\", -1, e + File.separator));\n \t    else\n-\t      /* Ignore path element. */;\n+\t      p.addElement (new URL(\"file\", \"\", -1, e));\n \t  } \n \tcatch (java.net.MalformedURLException x)\n \t  {"}, {"sha": "ea6546cf6ee6b1516a07151cebd2afd389a38484", "filename": "libjava/java/lang/ClassLoader.java", "status": "modified", "additions": 115, "deletions": 9, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72/libjava%2Fjava%2Flang%2FClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72/libjava%2Fjava%2Flang%2FClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClassLoader.java?ref=e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72", "patch": "@@ -13,7 +13,6 @@\n import java.io.InputStream;\n import java.io.IOException;\n import java.net.URL;\n-import java.net.URLConnection;\n import java.security.AllPermission;\n import java.security.CodeSource;\n import java.security.Permission;\n@@ -23,13 +22,68 @@\n import java.util.*;\n \n /**\n- * The class <code>ClassLoader</code> is intended to be subclassed by\n- * applications in order to describe new ways of loading classes,\n- * such as over the network.\n+ * The ClassLoader is a way of customizing the way Java gets its classes\n+ * and loads them into memory.  The verifier and other standard Java things\n+ * still run, but the ClassLoader is allowed great flexibility in determining\n+ * where to get the classfiles and when to load and resolve them. For that\n+ * matter, a custom ClassLoader can perform on-the-fly code generation or\n+ * modification!\n  *\n- * @author  Kresten Krab Thorup\n+ * <p>Every classloader has a parent classloader that is consulted before\n+ * the 'child' classloader when classes or resources should be loaded.   \n+ * This is done to make sure that classes can be loaded from an hierarchy of\n+ * multiple classloaders and classloaders do not accidentially redefine   \n+ * already loaded classes by classloaders higher in the hierarchy.\n+ *   \n+ * <p>The grandparent of all classloaders is the bootstrap classloader, which\n+ * loads all the standard system classes as implemented by GNU Classpath. The\n+ * other special classloader is the system classloader (also called\n+ * application classloader) that loads all classes from the CLASSPATH\n+ * (<code>java.class.path</code> system property). The system classloader\n+ * is responsible for finding the application classes from the classpath,\n+ * and delegates all requests for the standard library classes to its parent\n+ * the bootstrap classloader. Most programs will load all their classes\n+ * through the system classloaders.\n+ *\n+ * <p>The bootstrap classloader in GNU Classpath is implemented as a couple of\n+ * static (native) methods on the package private class\n+ * <code>java.lang.VMClassLoader</code>, the system classloader is an\n+ * instance of <code>gnu.java.lang.SystemClassLoader</code>\n+ * (which is a subclass of <code>java.net.URLClassLoader</code>).\n+ *\n+ * <p>Users of a <code>ClassLoader</code> will normally just use the methods\n+ * <ul>\n+ *  <li> <code>loadClass()</code> to load a class.</li>\n+ *  <li> <code>getResource()</code> or <code>getResourceAsStream()</code>\n+ *       to access a resource.</li>\n+ *  <li> <code>getResources()</code> to get an Enumeration of URLs to all\n+ *       the resources provided by the classloader and its parents with the\n+ *       same name.</li>\n+ * </ul>\n+ *\n+ * <p>Subclasses should implement the methods\n+ * <ul>\n+ *  <li> <code>findClass()</code> which is called by <code>loadClass()</code>\n+ *       when the parent classloader cannot provide a named class.</li>\n+ *  <li> <code>findResource()</code> which is called by\n+ *       <code>getResource()</code> when the parent classloader cannot provide\n+ *       a named resource.</li>\n+ *  <li> <code>findResources()</code> which is called by\n+ *       <code>getResource()</code> to combine all the resources with the\n+ *       same name from the classloader and its parents.</li>\n+ *  <li> <code>findLibrary()</code> which is called by\n+ *       <code>Runtime.loadLibrary()</code> when a class defined by the\n+ *       classloader wants to load a native library.</li>\n+ * </ul>\n+ *\n+ * @author John Keiser\n+ * @author Mark Wielaard\n+ * @author Eric Blake\n+ * @author Kresten Krab Thorup\n+ * @see Class\n+ * @since 1.0\n+ * @status still missing 1.4 functionality\n  */\n-\n public abstract class ClassLoader\n {\n   /**\n@@ -73,12 +127,40 @@\n   // Package visible for use by Class.\n   Map classAssertionStatus;\n \n-  private ClassLoader parent;\n+  /**\n+   * The classloader that is consulted before this classloader.\n+   * If null then the parent is the bootstrap classloader.\n+   */\n+  private final ClassLoader parent;\n+\n+  /**\n+   * All packages defined by this classloader. It is not private in order to\n+   * allow native code (and trusted subclasses) access to this field.\n+   */\n   private HashMap definedPackages = new HashMap();\n \n+  /**\n+   * Returns the parent of this classloader. If the parent of this\n+   * classloader is the bootstrap classloader then this method returns\n+   * <code>null</code>. A security check may be performed on\n+   * <code>RuntimePermission(\"getClassLoader\")</code>.\n+   *\n+   * @throws SecurityException if the security check fails\n+   * @since 1.2\n+   */\n   public final ClassLoader getParent ()\n   {\n-    /* FIXME: security */\n+    // Check if we may return the parent classloader\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      {\n+\t/* FIXME: security, getClassContext() not implemented.\n+\tClass c = VMSecurityManager.getClassContext()[1];\n+\tClassLoader cl = c.getClassLoader();\n+\tif (cl != null && cl != this)\n+\t  sm.checkPermission(new RuntimePermission(\"getClassLoader\"));\n+\t*/\n+      }\n     return parent;\n   }\n \n@@ -449,7 +531,8 @@ static void resolveClass0(Class clazz)\n \t    else\n \t      {\n \t\tInternalError e\n-\t\t  = new InternalError (\"unexpected exception during linking\");\n+\t\t  = new InternalError (\"unexpected exception during linking: \"\n+\t\t\t\t       + clazz.getName());\n \t\te.initCause (x);\n \t\tthrow e;\n \t      }\n@@ -521,6 +604,8 @@ protected Package definePackage(String name,\n    * null when the package is not defined by this classloader or one of its\n    * parents.\n    *\n+   * @param name the package name to find\n+   * @return the package, if defined\n    * @since 1.2\n    */\n   protected Package getPackage(String name)\n@@ -546,6 +631,7 @@ protected Package getPackage(String name)\n   /**\n    * Returns all Package objects defined by this classloader and its parents.\n    *\n+   * @return an array of all defined packages\n    * @since 1.2\n    */\n   protected Package[] getPackages()\n@@ -577,6 +663,26 @@ protected Package[] getPackages()\n     return allPackages;\n   }\n \n+  /**\n+   * Called by <code>Runtime.loadLibrary()</code> to get an absolute path\n+   * to a (system specific) library that was requested by a class loaded\n+   * by this classloader. The default implementation returns\n+   * <code>null</code>. It should be implemented by subclasses when they\n+   * have a way to find the absolute path to a library. If this method\n+   * returns null the library is searched for in the default locations\n+   * (the directories listed in the <code>java.library.path</code> system\n+   * property).\n+   *\n+   * @param name the (system specific) name of the requested library\n+   * @return the full pathname to the requested library, or null\n+   * @see Runtime#loadLibrary()\n+   * @since 1.2\n+   */\n+  protected String findLibrary(String name)\n+  {\n+    return null;\n+  }\n+\n   /** \n    * Returns a class found in a system-specific way, typically\n    * via the <code>java.class.path</code> system property.  Loads the "}, {"sha": "6f4cd1fe7ea3bc5e770fc2bf150036e7a0cfbad6", "filename": "libjava/java/net/JarURLConnection.java", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72/libjava%2Fjava%2Fnet%2FJarURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72/libjava%2Fjava%2Fnet%2FJarURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FJarURLConnection.java?ref=e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72", "patch": "@@ -134,7 +134,11 @@ public InputStream getInputStream() throws IOException\n     if (jarfile != null)\n       {\n \t// this is the easy way...\n-\treturn jarfile.getInputStream (jarfile.getEntry (element));\n+\tZipEntry entry = jarfile.getEntry(element);\n+\tif (entry != null)\n+\t  return jarfile.getInputStream (entry);\n+\telse\n+\t  return null;\n       }\n     else\n       {\n@@ -320,12 +324,17 @@ private void getHeaders() throws IOException\n     // to add others later and for consistency, we'll implement it this way.\n \n     // Add the only header we know about right now:  Content-length.\n-    long len;\n+    long len = -1;\n \n     if (element == null)\n-      len = jarFileURLConnection.getContentLength ();\n+      if (jarFileURLConnection != null)\n+\tlen = jarFileURLConnection.getContentLength ();\n     else\n-      len = getJarEntry ().getSize ();\n+      {\n+\tJarEntry entry = getJarEntry();\n+\tif (entry != null)\n+\t  len = entry.getSize ();\n+      }\n \n     String line = \"Content-length: \" + len;\n     hdrVec.addElement(line);\n@@ -381,7 +390,6 @@ public Manifest getManifest () throws IOException\n   {\n     JarFile file = getJarFile ();\n \n-    // FIXME: implement this\n-    return null;\n+    return (file != null) ? file.getManifest() : null;\n   }\n }"}, {"sha": "e37a81a5021679181cf5ca309558cb3b30ed89aa", "filename": "libjava/java/net/URLClassLoader.java", "status": "modified", "additions": 897, "deletions": 287, "changes": 1184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLClassLoader.java?ref=e825ca7ff5b76e07bdcecd4e02fc3e5df792ea72", "patch": "@@ -1,332 +1,701 @@\n-/* Copyright (C) 1999, 2000, 2002  Free Software Foundation\n+/* URLClassLoader.java --  ClassLoader that loads classes from one or more URLs\n+   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n \n package java.net;\n \n-import java.io.*;\n-import java.util.jar.*;\n-import java.util.Enumeration;\n-import java.util.Vector;\n+import java.io.ByteArrayOutputStream;\n+import java.io.EOFException;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FilterInputStream;\n+import java.io.FilePermission;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.security.AccessController;\n+import java.security.AccessControlContext;\n import java.security.CodeSource;\n import java.security.SecureClassLoader;\n+import java.security.PrivilegedAction;\n import java.security.PermissionCollection;\n import java.security.cert.Certificate;\n+import java.util.Enumeration;\n+import java.util.Vector;\n+import java.util.HashMap;\n+import java.util.jar.Attributes;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.jar.Manifest;\n+import java.util.zip.ZipException;\n \n /**\n+ * A secure class loader that can load classes and resources from\n+ * multiple locations.  Given an array of <code>URL</code>s this class\n+ * loader will retrieve classes and resources by fetching them from\n+ * possible remote locations.  Each <code>URL</code> is searched in\n+ * order in which it was added.  If the file portion of the\n+ * <code>URL</code> ends with a '/' character then it is interpreted\n+ * as a base directory, otherwise it is interpreted as a jar file from\n+ * which the classes/resources are resolved.\n+ *\n+ * <p>New instances can be created by two static\n+ * <code>newInstance()</code> methods or by three public\n+ * contructors. Both ways give the option to supply an initial array\n+ * of <code>URL</code>s and (optionally) a parent classloader (that is\n+ * different from the standard system class loader).</p>\n+ *\n+ * <p>Normally creating a <code>URLClassLoader</code> throws a\n+ * <code>SecurityException</code> if a <code>SecurityManager</code> is\n+ * installed and the <code>checkCreateClassLoader()</code> method does\n+ * not return true.  But the <code>newInstance()</code> methods may be\n+ * used by any code as long as it has permission to acces the given\n+ * <code>URL</code>s.  <code>URLClassLoaders</code> created by the\n+ * <code>newInstance()</code> methods also explicitly call the\n+ * <code>checkPackageAccess()</code> method of\n+ * <code>SecurityManager</code> if one is installed before trying to\n+ * load a class.  Note that only subclasses of\n+ * <code>URLClassLoader</code> can add new URLs after the\n+ * URLClassLoader had been created. But it is always possible to get\n+ * an array of all URLs that the class loader uses to resolve classes\n+ * and resources by way of the <code>getURLs()</code> method.</p>\n+ *\n+ * <p>Open issues:\n+ * <ul>\n+ *\n+ * <li>Should the URLClassLoader actually add the locations found in\n+ * the manifest or is this the responsibility of some other\n+ * loader/(sub)class?  (see <a\n+ * href=\"http://java.sun.com/products/jdk/1.4/docs/guide/extensions/spec.html\">\n+ * Extension Mechanism Architecture - Bundles Extensions</a>)</li>\n+ *\n+ * <li>How does <code>definePackage()</code> and sealing work\n+ * precisely?</li>\n+ *\n+ * <li>We save and use the security context (when a created by\n+ * <code>newInstance()</code> but do we have to use it in more\n+ * places?</li>\n+ *\n+ * <li>The use of <code>URLStreamHandler</code>s has not been tested.</li>\n+ *\n+ * </ul>\n+ * </p>\n+ *\n  * @since 1.2\n+ *\n+ * @author Mark Wielaard (mark@klomp.org)\n+ * @author Wu Gansha (gansha.wu@intel.com)\n  */\n+ \n public class URLClassLoader extends SecureClassLoader\n {\n-  // The URLStreamHandlerFactory\n-  URLStreamHandlerFactory factory = null;\n+  // Class Variables\n \n-  // `path' contains simply the URL's we're using for the searching.\n-  private Vector path; \n+  /**\n+   * A global cache to store mappings between URLLoader and URL,\n+   * so we can avoid do all the homework each time the same URL\n+   * comes.\n+   * XXX - Keeps these loaders forever which prevents garbage collection.\n+   */\n+  private static HashMap urlloaders = new HashMap();\n+    \n+  /**\n+   * A cache to store mappings between handler factory and its\n+   * private protocol handler cache (also a HashMap), so we can avoid\n+   * create handlers each time the same protocol comes.\n+   */\n+  private static HashMap factoryCache = new HashMap(5);\n \n-  // If path[n] is a zip/jar, then this holds a JarURLConnection for\n-  // that thing, otherwise, path[n] is null.\n-  private Vector info; \n+  // Instance variables\n \n-  private URLStreamHandler getHandler0 (String protocol)\n-  {\n-    if (factory != null)\n-      return factory.createURLStreamHandler(protocol);\n-    else\n-      return null;\n-  }\n+  /** Locations to load classes from */\n+  private final Vector urls = new Vector();\n \n   /**\n-   * Createa a new URL class loader object\n-   *\n-   * @exception SecurityException If a security manager exists and its\n-   * checkCreateClassLoader method doesn't allow creation of a class loader\n+   * Store pre-parsed information for each url into this vector \n+   * each element is a URL loader, corresponding to the URL of \n+   * the same index in \"urls\"\n    */\n-  public URLClassLoader (URL[] urls)\n-  { \n-    this (urls, null, null);\n-  }\n- \n+  private final Vector urlinfos = new Vector();\n+    \n+  /** Factory used to get the protocol handlers of the URLs */\n+  private final URLStreamHandlerFactory factory;\n+\n   /**\n-   * Createa a new URL class loader object\n-   *\n-   * @exception SecurityException If a security manager exists and its\n-   * checkCreateClassLoader method doesn't allow creation of a class loader\n+   * The security context when created from <code>newInstance()</code>\n+   * or null when created through a normal constructor or when no\n+   * <code>SecurityManager</code> was installed.\n    */\n-  public URLClassLoader (URL[] urls, ClassLoader parent)\n-  { \n-    this (urls, parent, null);\n-  }\n+  private final AccessControlContext securityContext;\n \n-  // A File URL may actually be a Jar URL.  Convert if possible.\n-  private URL jarFileize (URL url)\n+  // Helper classes\n+ \n+  /** \n+   * A <code>URLLoader</code> contains all logic to load resources from a\n+   * given base <code>URL</code>.\n+   */\n+  static abstract class URLLoader\n   {\n-    if (! url.getProtocol ().equals (\"jar\"))\n-      {\n-\tString f = url.getFile ();\n+    /**\n+     * Our classloader to get info from if needed.\n+     */\n+    final URLClassLoader classloader;\n \n-\t// If it ends with '/' we'll take it for a directory,\n-\t// otherwise it's a jar file.  This is how JDK 1.2 defines\n-\t// it, so we will not try to be smart here.\n-\tif (f.charAt (f.length ()-1) != '/')\n-\t  {\n-\t    try\n-\t      {\n-\t\turl = new URL (\"jar\", \"\", -1, (url.toExternalForm ())+\"!/\", \n-\t\t\t       getHandler0 (\"jar\"));\n-\t      } \n-\t    catch (MalformedURLException x)\n-\t      {\n-\t\t/* ignore */\n-\t      }\n-\t  }\n-      }\n-    return url;\n-  }\n+    /**\n+     * The base URL from which all resources are loaded.\n+     */\n+    final URL baseURL;\n \n-  protected void addURL (URL url)\n-  {\n-    JarURLConnection conn = null;\n+    /**\n+     * A <code>CodeSource</code> without any associated certificates.\n+     * It is common for classes to not have certificates associated\n+     * with them.  If they come from the same <code>URLLoader</code>\n+     * then it is safe to share the associated <code>CodeSource</code>\n+     * between them since <code>CodeSource</code> is immutable.\n+     */\n+    final CodeSource noCertCodeSource;\n+\n+    URLLoader(URLClassLoader classloader, URL baseURL)\n+    {\n+      this.classloader = classloader;\n+      this.baseURL = baseURL;\n+      this.noCertCodeSource = new CodeSource(baseURL, null);\n+    }\n+\n+    /**\n+     * Returns a <code>Resource</code> loaded by this\n+     * <code>URLLoader</code>, or <code>null</code> when no\n+     * <code>Resource</code> with the given name exists.\n+     */\n+    abstract Resource getResource(String s);\n+\n+    /**\n+     * Returns the <code>Manifest</code> associated with the\n+     * <code>Resource</code>s loaded by this <code>URLLoader</code> or\n+     * <code>null</code> there is no such <code>Manifest</code>.\n+     */\n+    Manifest getManifest()\n+    {\n+      return null;\n+    }\n+  }\n     \n-    // Convert a Jar File URL into Jar URL if possible.\n-    url = jarFileize (url);\n+  /** \n+   * A <code>Resource</code> represents a resource in some\n+   * <code>URLLoader</code>. It also contains all information (e.g.,\n+   * <code>URL</code>, <code>CodeSource</code>, <code>Manifest</code> and\n+   * <code>InputStream</code>) that is necessary for loading resources\n+   * and creating classes from a <code>URL</code>.\n+   */\n+  static abstract class Resource\n+  {\n+    final URLLoader loader;\n+    final String name;\n \n-    path.addElement (url);\n+    Resource(URLLoader loader, String name)\n+    {\n+      this.loader = loader;\n+      this.name = name;\n+    }\n \n-    if (url.getProtocol ().equals (\"jar\"))\n-      {\n-\ttry\n-\t  {\n-\t    conn = (JarURLConnection) url.openConnection ();\n-\t  }\n-\tcatch (java.io.IOException x)\n-\t  {\n-\t    /* ignore */\n-\t  }\n-      }\n+    /**\n+     * Returns the non-null <code>CodeSource</code> associated with\n+     * this resource.\n+     */\n+    CodeSource getCodeSource()\n+    {\n+      Certificate[] certs = getCertificates();\n+      if (certs != null)\n+\treturn loader.noCertCodeSource;\n+      else\n+\treturn new CodeSource(loader.baseURL, certs);\n+    }\n+\n+    /**\n+     * Returns <code>Certificates</code> associated with this\n+     * resource, or null when there are none.\n+     */\n+    Certificate[] getCertificates()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * Return a <code>URL</code> that can be used to access this resource.\n+     */\n+    abstract URL getURL();\n \n-    info.addElement (conn);\n+    /**\n+     * Returns the size of this <code>Resource</code> in bytes or\n+     * <code>-1</code> when unknown.\n+     */\n+    abstract int getLength();\n+\n+    /**\n+     * Returns the non-null <code>InputStream</code> through which\n+     * this resource can be loaded.\n+     */\n+    abstract InputStream getInputStream() throws IOException;\n   }\n \n   /**\n-   * Createa a new URL class loader object\n-   *\n-   * @exception SecurityException If a security manager exists and its\n-   * checkCreateClassLoader method doesn't allow creation of a class loader\n+   * A <code>JarURLLoader</code> is a type of <code>URLLoader</code>\n+   * only loading from jar url.\n    */\n-  public URLClassLoader (URL[] urls, ClassLoader parent,\n-\t\t\t URLStreamHandlerFactory fac)\n-  { \n-    super (parent);\n-\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkCreateClassLoader();\n-\n-    factory = fac;\n+  final static class JarURLLoader extends URLLoader\n+  {\n+    final JarFile jarfile; // The canonical jar file for this url\n+    final URL baseJarURL;  // Base jar: url for all resources loaded from jar\n \n-    if (urls == null || urls.length == 0)\n-      {\n-\tpath = new Vector (1);\n-\tinfo = new Vector (1);\n-\treturn;\n-      }\n+    public JarURLLoader(URLClassLoader classloader, URL baseURL)\n+    {\n+      super(classloader, baseURL);\n+        \n+      // cache url prefix for all resources in this jar url\n+      String external = baseURL.toExternalForm();\n+      StringBuffer sb = new StringBuffer(external.length() + 6);\n+      sb.append(\"jar:\");\n+      sb.append(external);\n+      sb.append(\"!/\");\n+      String jarURL = sb.toString();\n \n-    path = new Vector (urls.length);\n-    info = new Vector (urls.length);\n+      URL baseJarURL = null;\n+      JarFile jarfile = null;\n+      try\n+\t{\n+\t  baseJarURL\n+\t    = new URL(null, jarURL, classloader.getURLStreamHandler(\"jar\"));\n+\t  jarfile\n+\t    = ((JarURLConnection) baseJarURL.openConnection()).getJarFile();\n+\t}\n+      catch (IOException ioe) { /* ignored */ }\n \n-    for (int i = 0; i < urls.length; i++)\n-      {\n-\t// Convert a Jar File URL into a Jar URL if possible.\n-\tURL u = jarFileize(urls[i]);\n+      this.baseJarURL = baseJarURL;\n+      this.jarfile = jarfile;\n+    }\n+    \n+    /** get resource with the name \"name\" in the jar url */\n+    Resource getResource(String name)\n+    {\n+      if (jarfile == null)\n+\treturn null;\n \n-\tpath.addElement (u);\n+      JarEntry je = jarfile.getJarEntry(name);\n+      if(je != null)\n+\treturn new JarURLResource(this, name, je);\n+      else\n+\treturn null;\n+    }\n \n-\tif (u.getProtocol ().equals (\"jar\"))\n-\t  {\n-\t    JarURLConnection conn = null;\n-\t    try\n-\t      {\n-\t\tconn = (JarURLConnection) u.openConnection ();\n-\t      }\n-\t    catch (java.io.IOException x)\n-\t      {\n-\t\t/* ignore */\n-\t      }\n-\t    info.addElement (conn);\n-\t  }\n-\telse\n-\t  {\n-\t    info.addElement (null);\n-\t  }\n-      }\n+    Manifest getManifest()\n+    {\n+      try\n+\t{\n+\t  return (jarfile == null) ? null : jarfile.getManifest();\n+\t}\n+      catch (IOException ioe)\n+\t{\n+\t  return null;\n+\t}\n+    }\n+      \n   }\n \n-  public URL[] getURLs ()\n+  final static class JarURLResource extends Resource\n   {\n-    URL[] urls = new URL[path.size()];\n-    path.copyInto (urls);\n-    return urls;\n+    private final JarEntry entry;\n+\n+    JarURLResource(JarURLLoader loader, String name, JarEntry entry)\n+    {\n+      super(loader, name);\n+      this.entry = entry;\n+    }\n+\n+    InputStream getInputStream() throws IOException\n+    {\n+      return ((JarURLLoader)loader).jarfile.getInputStream(entry);\n+    }\n+\n+    int getLength()\n+    {\n+      return (int)entry.getSize();\n+    }\n+\n+    Certificate[] getCertificates()\n+    {\n+      return entry.getCertificates();\n+    }\n+                \n+    URL getURL()\n+    {\n+      try\n+\t{\n+\t  return new URL(((JarURLLoader)loader).baseJarURL, name,\n+\t\t\t loader.classloader.getURLStreamHandler(\"jar\"));\n+\t}\n+      catch(MalformedURLException e)\n+\t{\n+\t  throw new InternalError(e.toString());\n+\t}\n+    }\n   }\n- \n+\n   /**\n-   * Returns an Enumeration of URLs representing all of the resources on the\n-   * URL search path having the specified name\n-   *\n-   * @exception IOException If an error occurs\n+   * Loader for remote directories.\n    */\n-  public Enumeration findResources (String name)\n+  final static class RemoteURLLoader extends URLLoader\n   {\n-    Vector results = new Vector ();\n+    final private String protocol;\n \n-    for (int i = 0; i < path.size(); i++)\n-      {\n-\tURL u = (URL)path.elementAt (i);\n-\t\t\n-\ttry {\n-\t  JarURLConnection conn = (JarURLConnection) info.elementAt (i);\n-\t  \n-\t  if (conn != null)\n+    RemoteURLLoader(URLClassLoader classloader, URL url)\n+    {\n+      super(classloader, url);\n+      protocol = url.getProtocol();\n+    }\n+\n+    /**\n+     * Get a remote resource.\n+     * Returns null if no such resource exists.\n+     */\n+    Resource getResource(String name)\n+    {\n+      try\n+\t{\n+\t  URL url = new URL(baseURL, name,\n+\t\t\t    classloader.getURLStreamHandler(protocol));\n+\t  URLConnection connection = url.openConnection();\n+\n+\t  // Open the connection and check the stream\n+\t  // just to be sure it exists.\n+\t  int length = connection.getContentLength();\n+\t  InputStream stream = connection.getInputStream();\n+\n+\t  // We can do some extra checking if it is a http request\n+\t  if (connection instanceof HttpURLConnection)\n \t    {\n-\t      if (conn.getJarFile().getJarEntry (name) != null)\n-\t\tresults.addElement (new URL(u, name,\n-\t\t\t\t\tgetHandler0 (u.getProtocol())));\n+\t      int response\n+\t\t= ((HttpURLConnection)connection).getResponseCode();\n+\t      if (response/100 != 2)\n+\t\treturn null;\n \t    }\n+\n+\t  if (stream != null)\n+\t    return new RemoteResource(this, name, url, stream, length);\n \t  else\n-\t    {\n-\t      URL p = new URL (u, name, getHandler0 (u.getProtocol()));\n-\t\t\t    \n-\t      InputStream is = p.openStream();\n-\t      if (is != null)\n-\t\t{\n-\t\t  is.close();\n-\t\t  results.addElement (p);\n-\t\t}\n-\t    }\n-\t\t    \n-\t  // if we get an exception ... try the next path element\n-\t} catch (IOException x) {\n-\t  continue;\n+\t    return null;\n \t}\n-      }\n-\t\n-    return results.elements ();\n+      catch (IOException ioe)\n+\t{\n+\t  return null;\n+\t}\n+    }\n   }\n \n-  public URL findResource (String name)\n+  /**\n+   * A resource from some remote location.\n+   */\n+  final static class RemoteResource extends Resource\n   {\n-    for (int i = 0; i < path.size(); i++)\n-      {\n-\tURL u = (URL)path.elementAt (i);\n-\t\n-\ttry {\n-\t  JarURLConnection conn = (JarURLConnection) info.elementAt (i);\n- \t  \n-\t  if (conn != null)\n-\t    {\n-\t      if (conn.getJarFile().getJarEntry (name) != null)\n-\t\treturn new URL(u, name, getHandler0 (u.getProtocol()));\n-\t    }\n-\t  else\n-\t    {\n-\t      URL p = new URL (u, name, getHandler0 (u.getProtocol()));\n+    final private URL url;\n+    final private InputStream stream;\n+    final private int length;\n \n-\t      InputStream is = p.openStream();\n-\t      if (is != null)\n-\t\t{\n-\t\t  is.close();\n-\t\t  return p;\n-\t\t}\n-\t    }\n-\t\n-\t  // if we get an exception ... try the next path element\n-\t} catch (IOException x) {\n-\t  continue;\n+    RemoteResource(RemoteURLLoader loader, String name, URL url,\n+\t\t   InputStream stream, int length)\n+    {\n+      super(loader, name);\n+      this.url = url;\n+      this.stream = stream;\n+      this.length = length;\n+    }\n+\n+    InputStream getInputStream() throws IOException\n+    {\n+      return stream;\n+    }\n+                        \n+    public int getLength()\n+    {\n+      return length;\n+    }\n+                \n+    public URL getURL()\n+    {\n+      return url;\n+    }\n+  }\n+\n+  /**\n+   * A <code>FileURLLoader</code> is a type of <code>URLLoader</code>\n+   * only loading from file url.\n+   */\n+  final static class FileURLLoader extends URLLoader\n+  {\n+    File dir;   //the canonical file for this file url\n+\n+    FileURLLoader(URLClassLoader classloader, URL url)\n+    {\n+      super(classloader, url);\n+      // Note that this must be a \"file\" protocol URL.\n+      dir = new File(url.getFile());\n+    }\n+    \n+    /** get resource with the name \"name\" in the file url */\n+    Resource getResource(String name)\n+    {\n+      File file = new File(dir, name);\n+      if (file.exists() && !file.isDirectory())\n+\treturn new FileResource(this, name, file);\n+      else\n+\treturn null;\n+    }\n+  }\n+\n+  final static class FileResource extends Resource\n+  {\n+    final File file;\n+\n+    FileResource(FileURLLoader loader, String name, File file)\n+    {\n+      super(loader, name);\n+      this.file = file;\n+    }\n+\n+    InputStream getInputStream() throws IOException\n+    {\n+      return new FileInputStream(file);\n+    }\n+                        \n+    public int getLength()\n+    {\n+      return (int)file.length();\n+    }\n+                \n+    public URL getURL()\n+    {\n+      try\n+\t{\n+\t  return new URL(loader.baseURL, name,\n+\t\t\t loader.classloader.getURLStreamHandler(\"file\"));\n \t}\n-      }\n+      catch(MalformedURLException e)\n+\t{\n+\t  throw new InternalError(e.toString());\n+\t}\n+    }\n+  }\n+    \n+  // Constructors\n \n-    return null;\n+  /**\n+   * Creates a URLClassLoader that gets classes from the supplied URLs.\n+   * To determine if this classloader may be created the constructor of\n+   * the super class (<code>SecureClassLoader</code>) is called first, which\n+   * can throw a SecurityException. Then the supplied URLs are added\n+   * in the order given to the URLClassLoader which uses these URLs to\n+   * load classes and resources (after using the default parent ClassLoader).\n+   *\n+   * @exception SecurityException if the SecurityManager disallows the\n+   * creation of a ClassLoader.\n+   * @param urls Locations that should be searched by this ClassLoader when\n+   * resolving Classes or Resources.\n+   * @see SecureClassLoader\n+   */\n+  public URLClassLoader(URL[] urls) throws SecurityException\n+  {\n+    super();\n+    this.factory = null;\n+    this.securityContext = null;\n+    addURLs(urls);\n   }\n \n   /**\n-   * Finds and loads the class with the specified name from the\n-   * URL search path\n+   * Private constructor used by the static\n+   * <code>newInstance(URL[])</code> method.  Creates an\n+   * <code>URLClassLoader</code> without any <code>URL</code>s\n+   * yet. This is used to bypass the normal security check for\n+   * creating classloaders, but remembers the security context which\n+   * will be used when defining classes.  The <code>URL</code>s to\n+   * load from must be added by the <code>newInstance()</code> method\n+   * in the security context of the caller.\n    *\n-   * @exception ClassNotFoundException If the class could not be found\n+   * @param securityContext the security context of the unprivileged code.\n    */\n-  protected Class findClass (String name)\n-    throws ClassNotFoundException\n+  private URLClassLoader(AccessControlContext securityContext)\n   {\n-    if (name == null)\n-      throw new ClassNotFoundException (\"null\");\n+    super();\n+    this.factory = null;\n+    this.securityContext = securityContext;\n+  }\n \n-    try \n-      {\n-\tURL url = getResource (name.replace ('.', '/') + \".class\");\n+  /**\n+   * Creates a <code>URLClassLoader</code> that gets classes from the supplied\n+   * <code>URL</code>s.\n+   * To determine if this classloader may be created the constructor of\n+   * the super class (<code>SecureClassLoader</code>) is called first, which\n+   * can throw a SecurityException. Then the supplied URLs are added\n+   * in the order given to the URLClassLoader which uses these URLs to\n+   * load classes and resources (after using the supplied parent ClassLoader).\n+   * @exception SecurityException if the SecurityManager disallows the\n+   * creation of a ClassLoader.\n+   * @exception SecurityException \n+   * @param urls Locations that should be searched by this ClassLoader when\n+   * resolving Classes or Resources.\n+   * @param parent The parent class loader used before trying this class\n+   * loader.\n+   * @see SecureClassLoader\n+   */\n+  public URLClassLoader(URL[] urls, ClassLoader parent)\n+    throws SecurityException\n+  {\n+    super(parent);\n+    this.factory = null;\n+    this.securityContext = null;\n+    addURLs(urls);\n+  }\n \n-\tif (url == null)\n-\t  throw new ClassNotFoundException (name);\n+  /**\n+   * Private constructor used by the static\n+   * <code>newInstance(URL[])</code> method.  Creates an\n+   * <code>URLClassLoader</code> with the given parent but without any\n+   * <code>URL</code>s yet. This is used to bypass the normal security\n+   * check for creating classloaders, but remembers the security\n+   * context which will be used when defining classes.  The\n+   * <code>URL</code>s to load from must be added by the\n+   * <code>newInstance()</code> method in the security context of the\n+   * caller.\n+   *\n+   * @param securityContext the security context of the unprivileged code.\n+   */\n+  private URLClassLoader(ClassLoader parent,\n+\t\t\t AccessControlContext securityContext)\n+  {\n+    super(parent);\n+    this.factory = null;\n+    this.securityContext = securityContext;\n+  }\n \n-\tURLConnection connection = url.openConnection ();\n-\tInputStream is = connection.getInputStream ();\n+  /**\n+   * Creates a URLClassLoader that gets classes from the supplied URLs.\n+   * To determine if this classloader may be created the constructor of\n+   * the super class (<CODE>SecureClassLoader</CODE>) is called first, which\n+   * can throw a SecurityException. Then the supplied URLs are added\n+   * in the order given to the URLClassLoader which uses these URLs to\n+   * load classes and resources (after using the supplied parent ClassLoader).\n+   * It will use the supplied <CODE>URLStreamHandlerFactory</CODE> to get the\n+   * protocol handlers of the supplied URLs.\n+   * @exception SecurityException if the SecurityManager disallows the\n+   * creation of a ClassLoader.\n+   * @exception SecurityException \n+   * @param urls Locations that should be searched by this ClassLoader when\n+   * resolving Classes or Resources.\n+   * @param parent The parent class loader used before trying this class\n+   * loader.\n+   * @param factory Used to get the protocol handler for the URLs.\n+   * @see SecureClassLoader\n+   */\n+  public URLClassLoader(URL[] urls,\n+\t\t\tClassLoader parent,\n+\t\t\tURLStreamHandlerFactory factory)\n+    throws SecurityException\n+  {\n+    super(parent);\n+    this.securityContext = null;\n+    this.factory = factory;\n+    addURLs(urls);\n \n-\tint len = connection.getContentLength ();\n-\tbyte[] data = new byte[len];\n+    // If this factory is still not in factoryCache, add it,\n+    //   since we only support three protocols so far, 5 is enough \n+    //   for cache initial size\n+    synchronized(factoryCache)\n+      {\n+\tif(factory != null && factoryCache.get(factory) == null)\n+\t  factoryCache.put(factory, new HashMap(5));\n+      }\n+  }\n \n-\tint left = len;\n-\tint off  = 0;\n-\twhile (left > 0)\n-\t  {\n-\t    int c = is.read (data, off, len-off);\n-\t    if (c == -1 || c == 0)\n-\t      throw new InternalError (\"premature end of file\");\n-\t    left -= c;\n-\t    off += c;\n-\t  }\n+  // Methods\n \n-\t// Now construct the CodeSource (if loaded from a jar file)\n-\tCodeSource source = null;\n-\tif (url.getProtocol().equals(\"jar\"))\n-\t  {\n-\t    Certificate[] certificates =\n-\t      ((JarURLConnection) connection).getCertificates();\n-\t    String u = url.toExternalForm ();\n-\t    u = u.substring (4); //skip \"jar:\"\n-\t    int i = u.indexOf ('!');\n-\t    if (i >= 0)\n-\t      u = u.substring (0, i);\n-\t    url = new URL(u);\n-\n-\t    source = new CodeSource(url, certificates);\n-\t  }\n-\telse if (url.getProtocol().equals(\"file\"))\n+  /**\n+   * Adds a new location to the end of the internal URL store.\n+   * @param newUrl the location to add\n+   */\n+  protected void addURL(URL newUrl)\n+  {\n+    synchronized(urlloaders)\n+      {\n+\tif (newUrl == null)\n+\t  return; // Silently ignore...\n+        \n+\t// check global cache to see if there're already url loader\n+\t// for this url\n+\tURLLoader loader = (URLLoader)urlloaders.get(newUrl);\n+\tif (loader == null)\n \t  {\n-\t    try\n-\t      {\n-\t\tString u = url.toExternalForm();\n-\t\t// Skip \"file:\" and then get canonical directory name.\n-\t\tFile f = new File(u.substring(5));\n-\t\tf = f.getCanonicalFile();\n-\t\turl = new URL(\"file\", \"\", f.getParent());\n-\t\tsource = new CodeSource (url, null);\n-\t      }\n-\t    catch (IOException ignore)\n-\t      {\n-\t      }\n+\t    String file = newUrl.getFile();\n+\t    // Check that it is not a directory\n+\t    if (!(file.endsWith(\"/\") || file.endsWith(File.separator)))\n+\t      loader = new JarURLLoader(this, newUrl);\n+\t    else // it's a url that point to a jar file\n+\t      if (\"file\".equals(newUrl.getProtocol()))\n+\t\tloader = new FileURLLoader(this, newUrl);\n+\t      else\n+\t\tloader = new RemoteURLLoader(this, newUrl);\n+\n+\t    // cache it\n+\t    urlloaders.put(newUrl, loader);\n \t  }\n \n-\treturn defineClass (name, data, 0, len, source);\n-      } \n-    catch (java.io.IOException x)\n-      {\n-\tthrow new ClassNotFoundException(name);\n+\turls.add(newUrl);\n+\turlinfos.add(loader);\n       }\n   }\n \n+  /**\n+   * Adds an array of new locations to the end of the internal URL store.\n+   * @param newUrls the locations to add\n+   */\n+  private void addURLs(URL[] newUrls)\n+  {\n+    for (int i = 0; i < newUrls.length; i++)\n+    {\n+      addURL(newUrls[i]);\n+    }\n+  }\n+\n   /** \n    * Defines a Package based on the given name and the supplied manifest\n    * information. The manifest indicates the tile, version and\n@@ -362,36 +731,231 @@ protected Package definePackage(String name, Manifest manifest, URL url)\n     // Look if the Manifest indicates that this package is sealed\n     // XXX - most likely not completely correct!\n     // Shouldn't we also check the sealed attribute of the complete jar?\n-    // http://java.sun.com/products/jdk/1.3/docs/guide/extensions/spec.html#bundled\n+    // http://java.sun.com/products/jdk/1.4/docs/guide/extensions/spec.html#bundled\n     // But how do we get that jar manifest here?\n     String sealed = attr.getValue(Attributes.Name.SEALED);\n     if (\"false\".equals(sealed))\n-      {\n-\t// Make sure that the URL is null so the package is not\n-\t// sealed.\n-\turl = null;\n-      }\n+    {\n+      // make sure that the URL is null so the package is not sealed\n+      url = null;\n+    }\n \n     return definePackage(name, specTitle, specVersion, specVendor,\n \t\t\t implTitle, implVersion, implVendor, url);\n   }\n \n   /**\n-   * Returns the permissions needed to access a particular code source.\n-   * These permissions includes those returned by\n-   * <CODE>SecureClassLoader.getPermissions</CODE> and the actual permissions\n-   * to access the objects referenced by the URL of the code source.\n-   * The extra permissions added depend on the protocol and file portion of\n-   * the URL in the code source. If the URL has the \"file\" protocol ends with\n-   * a / character then it must be a directory and a file Permission to read\n-   * everthing in that directory and all subdirectories is added. If the URL\n-   * had the \"file\" protocol and doesn't end with a / character then it must\n-   * be a normal file and a file permission to read that file is added. If the\n-   * URL has any other protocol then a socket permission to connect and accept\n-   * connections from the host portion of the URL is added.\n+   * Finds (the first) class by name from one of the locations. The locations\n+   * are searched in the order they were added to the URLClassLoader.\n+   *\n+   * @param className the classname to find\n+   * @exception ClassNotFoundException when the class could not be found or\n+   * loaded\n+   * @return a Class object representing the found class\n+   */\n+  protected Class findClass(final String className)\n+    throws ClassNotFoundException\n+  {\n+    // Just try to find the resource by the (almost) same name\n+    String resourceName = className.replace('.', '/') + \".class\";\n+    Resource resource = findURLResource(resourceName);\n+    if (resource == null)\n+      throw new ClassNotFoundException(className + \" not found in \" + urls);\n+\n+    // Try to read the class data, create the CodeSource, Package and\n+    // construct the class (and watch out for those nasty IOExceptions)\n+    try\n+      {\n+\tbyte [] data;\n+\tInputStream in = resource.getInputStream();\n+\tint length = resource.getLength();\n+\tif (length != -1)\n+\t  {\n+\t    // We know the length of the data.\n+\t    // Just try to read it in all at once\n+\t    data = new byte[length];\n+\t    int pos = 0;\n+\t    while(length - pos > 0)\n+\t      {\n+\t\tint len = in.read(data, pos, length - pos);\n+\t\tif (len == -1)\n+\t\t  throw new EOFException(\"Not enough data reading from: \"\n+\t\t\t\t\t + in);\n+\t\tpos += len;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    // We don't know the data length.\n+\t    // Have to read it in chunks.\n+\t    ByteArrayOutputStream out = new ByteArrayOutputStream(4096);\n+\t    byte b[] = new byte[4096];\n+\t    int l = 0;\n+\t    while (l != -1)\n+\t      {\n+\t\tl = in.read(b);\n+\t\tif (l != -1)\n+\t\t  out.write(b, 0, l);\n+\t      }\n+\t    data = out.toByteArray();\n+\t  }\n+\tfinal byte[] classData = data;\n+\n+\t// Now get the CodeSource\n+\tfinal CodeSource source = resource.getCodeSource();\n+\t\n+\t// Find out package name\n+\tString packageName = null;\n+\tint lastDot = className.lastIndexOf('.');\n+\tif (lastDot != -1)\n+\t  packageName = className.substring(0, lastDot);\n+\t\n+\tif (packageName != null && getPackage(packageName) == null)\n+\t  {\n+\t    // define the package\n+\t    Manifest manifest = resource.loader.getManifest();\n+\t    if (manifest == null)\n+\t      definePackage(packageName,\n+\t\t\t    null, null, null, null, null, null, null);\n+\t    else\n+\t      definePackage(packageName, manifest, resource.loader.baseURL);\n+\t  }\n+\t\n+\t// And finally construct the class!\n+\tSecurityManager sm = System.getSecurityManager();\n+\tif (sm != null && securityContext != null)\n+\t  {\n+\t    return (Class)AccessController.doPrivileged\n+\t      (new PrivilegedAction()\n+\t\t{\n+\t\t  public Object run()\n+\t\t  {\n+\t\t    return defineClass(className, classData,\n+\t\t\t\t       0, classData.length,\n+\t\t\t\t       source);\n+\t\t  }\n+\t\t}, securityContext);\n+\t  }\n+\telse\n+\t  return defineClass(className, classData,\n+\t\t\t     0, classData.length,\n+\t\t\t     source);\n+      }\n+    catch (IOException ioe)\n+      {\n+\tthrow new ClassNotFoundException(className, ioe);\n+      }\n+  }\n+\n+  /**\n+   * Finds the first occurrence of a resource that can be found. The locations\n+   * are searched in the order they were added to the URLClassLoader.\n+   *\n+   * @param resourceName the resource name to look for\n+   * @return the URLResource for the resource if found, null otherwise\n+   */\n+  private Resource findURLResource(String resourceName)\n+  {\n+    int max = urls.size();\n+    for (int i = 0; i < max; i++)\n+      {\n+\tURLLoader loader = (URLLoader)urlinfos.elementAt(i);\n+\tif (loader == null)\n+\t  continue;\n+\t\n+\tResource resource = loader.getResource(resourceName);\n+\tif (resource != null)\n+\t  return resource;\n+      }\n+    return null;\n+  }\n+\n+  /**\n+   * Finds the first occurrence of a resource that can be found.\n+   *\n+   * @param resourceName the resource name to look for\n+   * @return the URL if found, null otherwise\n+   */\n+  public URL findResource(String resourceName)\n+  {\n+    Resource resource = findURLResource(resourceName);\n+    if (resource != null)\n+      return resource.getURL();\n+    \n+    // Resource not found\n+    return null;\n+  }\n+\n+  /**\n+   * If the URLStreamHandlerFactory has been set this return the appropriate\n+   * URLStreamHandler for the given protocol, if not set returns null.\n+   *\n+   * @param protocol the protocol for which we need a URLStreamHandler\n+   * @return the appropriate URLStreamHandler or null\n+   */\n+  URLStreamHandler getURLStreamHandler(String protocol)\n+  {\n+    if (factory == null)\n+      return null;\n+\n+    URLStreamHandler handler;\n+    synchronized (factoryCache)\n+      {\n+\t// check if there're handler for the same protocol in cache\n+\tHashMap cache = (HashMap)factoryCache.get(factory);\n+\thandler = (URLStreamHandler)cache.get(protocol);\n+\tif(handler == null)\n+\t  {\n+\t    // add it to cache\n+\t    handler = factory.createURLStreamHandler(protocol);\n+\t    cache.put(protocol, handler);\n+\t  }\n+      }\n+    return handler;\n+  }\n+\n+  /**\n+   * Finds all the resources with a particular name from all the locations.\n+   *\n+   * @exception IOException when an error occurs accessing one of the\n+   * locations\n+   * @param resourceName the name of the resource to lookup\n+   * @return a (possible empty) enumeration of URLs where the resource can be\n+   * found\n+   */\n+  public Enumeration findResources(String resourceName) throws IOException\n+  {\n+    Vector resources = new Vector();\n+    int max = urls.size();\n+    for (int i = 0; i < max; i++)\n+      {\n+\tURLLoader loader = (URLLoader)urlinfos.elementAt(i);\n+\tResource resource = loader.getResource(resourceName);\n+\tif (resource != null)\n+\t  resources.add(resource.getURL());\n+      }\n+    return resources.elements();\n+  }\n+\n+  /**\n+   * Returns the permissions needed to access a particular code\n+   * source.  These permissions includes those returned by\n+   * <code>SecureClassLoader.getPermissions()</code> and the actual\n+   * permissions to access the objects referenced by the URL of the\n+   * code source.  The extra permissions added depend on the protocol\n+   * and file portion of the URL in the code source. If the URL has\n+   * the \"file\" protocol ends with a '/' character then it must be a\n+   * directory and a file Permission to read everything in that\n+   * directory and all subdirectories is added. If the URL had the\n+   * \"file\" protocol and doesn't end with a '/' character then it must\n+   * be a normal file and a file permission to read that file is\n+   * added. If the <code>URL</code> has any other protocol then a\n+   * socket permission to connect and accept connections from the host\n+   * portion of the URL is added.\n+   *\n    * @param source The codesource that needs the permissions to be accessed\n    * @return the collection of permissions needed to access the code resource\n-   * @see SecureClassLoader.getPermissions()\n+   * @see java.security.SecureClassLoader#getPermissions()\n    */\n   protected PermissionCollection getPermissions(CodeSource source)\n   {\n@@ -408,7 +972,7 @@ protected PermissionCollection getPermissions(CodeSource source)\n       {\n \tString file = url.getFile();\n \t// If the file end in / it must be an directory\n-\tif (file.endsWith(\"/\"))\n+\tif (file.endsWith(\"/\") || file.endsWith(File.separator))\n \t  {\n \t    // Grant permission to read everything in that directory and\n \t    // all subdirectories\n@@ -424,35 +988,81 @@ protected PermissionCollection getPermissions(CodeSource source)\n     else\n       {\n \t// Grant permission to connect to and accept connections from host\n-\t  String host = url.getHost();\n+\tString host = url.getHost();\n+\tif (host != null)\n \t  permissions.add(new SocketPermission(host, \"connect,accept\"));\n       }\n \n     return permissions;\n   }\n+    \n+  /**\n+   * Returns all the locations that this class loader currently uses the\n+   * resolve classes and resource. This includes both the initially supplied\n+   * URLs as any URLs added later by the loader.\n+   * @return All the currently used URLs\n+   */\n+  public URL[] getURLs()\n+  {\n+    return (URL[]) urls.toArray(new URL[urls.size()]);\n+  }\n \n   /**\n-   * Creates a new instance of a URLClassLoader that gets classes from the\n-   * supplied URLs. This class loader will have as parent the standard\n-   * system class loader.\n-   * @param urls the initial URLs used to resolve classes and resources\n+   * Creates a new instance of a <code>URLClassLoader</code> that gets\n+   * classes from the supplied <code>URL</code>s. This class loader\n+   * will have as parent the standard system class loader.\n+   *\n+   * @param urls the initial URLs used to resolve classes and\n+   * resources\n+   *\n+   * @exception SecurityException when the calling code does not have\n+   * permission to access the given <code>URL</code>s\n    */\n-  public static URLClassLoader newInstance(URL[] urls) throws\n-    SecurityException\n+  public static URLClassLoader newInstance(URL urls[])\n+    throws SecurityException\n   {\n-    return new URLClassLoader(urls);\n+    return newInstance(urls, null);\n   }\n \n   /**\n-   * Creates a new instance of a URLClassLoader that gets classes from the\n-   * supplied URLs and with the supplied loader as parent class loader.\n-   * @param urls the initial URLs used to resolve classes and resources\n+   * Creates a new instance of a <code>URLClassLoader</code> that gets\n+   * classes from the supplied <code>URL</code>s and with the supplied\n+   * loader as parent class loader.\n+   *\n+   * @param urls the initial URLs used to resolve classes and\n+   * resources\n    * @param parent the parent class loader\n+   *\n+   * @exception SecurityException when the calling code does not have\n+   * permission to access the given <code>URL</code>s\n    */\n-  public static URLClassLoader newInstance(URL[] urls,\n-\t\t\t\t\t   ClassLoader parent)\n+  public static URLClassLoader newInstance(URL urls[],\n+\t\t\t\t\t   final ClassLoader parent)\n     throws SecurityException\n   {\n-    return new URLClassLoader(urls, parent);\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm == null)\n+      return new URLClassLoader(urls, parent);\n+    else\n+      {\n+\tfinal Object securityContext = sm.getSecurityContext();\n+\t// XXX - What to do with anything else then an AccessControlContext?\n+\tif (!(securityContext instanceof AccessControlContext))\n+\t  throw new SecurityException\n+\t    (\"securityContext must be AccessControlContext: \"\n+\t     + securityContext);\n+\t\n+\tURLClassLoader loader =\n+\t  (URLClassLoader)AccessController.doPrivileged(new PrivilegedAction()\n+\t    {\n+\t      public Object run()\n+\t      {\n+\t\treturn new URLClassLoader\n+\t\t  (parent, (AccessControlContext)securityContext);\n+\t      }\n+\t    });\n+\tloader.addURLs(urls);\n+\treturn loader;\n+      }\n   }\n }"}]}