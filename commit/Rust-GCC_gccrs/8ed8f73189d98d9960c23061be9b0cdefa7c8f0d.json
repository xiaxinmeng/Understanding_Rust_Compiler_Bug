{"sha": "8ed8f73189d98d9960c23061be9b0cdefa7c8f0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVkOGY3MzE4OWQ5OGQ5OTYwYzIzMDYxYmU5YjBjZGVmYTdjOGYwZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-04-22T19:26:19Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-04-22T19:26:19Z"}, "message": "re PR fortran/6138 (Incorrect access of integer*1 variables on PA)\n\n\tPR f/6138.\n\t* function.c (fixup_memory_subreg): Add promoted_mode parameter.\n\t(walk_fixup_memory_subreg): Likewise.\n\t(fixup_var_refs_insn): Adjust accordingly.\n\t(fixup_var_refs_1): Likewise.\n\nFrom-SVN: r52631", "tree": {"sha": "898af6988a88f160710755e9b4a121324c754dcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/898af6988a88f160710755e9b4a121324c754dcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ed8f73189d98d9960c23061be9b0cdefa7c8f0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ed8f73189d98d9960c23061be9b0cdefa7c8f0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ed8f73189d98d9960c23061be9b0cdefa7c8f0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ed8f73189d98d9960c23061be9b0cdefa7c8f0d/comments", "author": null, "committer": null, "parents": [{"sha": "b2e4f4fda73c761ee3d7f817378241d04f11a936", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2e4f4fda73c761ee3d7f817378241d04f11a936", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2e4f4fda73c761ee3d7f817378241d04f11a936"}], "stats": {"total": 92, "additions": 62, "deletions": 30}, "files": [{"sha": "ab675e09b0c735464cd66d70d57a15774897d85f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ed8f73189d98d9960c23061be9b0cdefa7c8f0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ed8f73189d98d9960c23061be9b0cdefa7c8f0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ed8f73189d98d9960c23061be9b0cdefa7c8f0d", "patch": "@@ -1,3 +1,11 @@\n+2002-04-21  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR f/6138.\n+\t* function.c (fixup_memory_subreg): Add promoted_mode parameter.\n+\t(walk_fixup_memory_subreg): Likewise.\n+\t(fixup_var_refs_insn): Adjust accordingly.\n+\t(fixup_var_refs_1): Likewise.\n+\n 2002-04-22  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/linux.h: (LIBPATH_SPEC, LIBPATH_ARCH31_SPEC,"}, {"sha": "5904919a85d73fb0e0cd0088b93b333466d2b507", "filename": "gcc/function.c", "status": "modified", "additions": 54, "deletions": 30, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ed8f73189d98d9960c23061be9b0cdefa7c8f0d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ed8f73189d98d9960c23061be9b0cdefa7c8f0d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=8ed8f73189d98d9960c23061be9b0cdefa7c8f0d", "patch": "@@ -246,8 +246,9 @@ static void fixup_var_refs_insn PARAMS ((rtx, rtx, enum machine_mode,\n \t\t\t\t\t int, int, rtx));\n static void fixup_var_refs_1\tPARAMS ((rtx, enum machine_mode, rtx *, rtx,\n \t\t\t\t\t struct fixup_replacement **, rtx));\n-static rtx fixup_memory_subreg\tPARAMS ((rtx, rtx, int));\n-static rtx walk_fixup_memory_subreg  PARAMS ((rtx, rtx, int));\n+static rtx fixup_memory_subreg\tPARAMS ((rtx, rtx, enum machine_mode, int));\n+static rtx walk_fixup_memory_subreg  PARAMS ((rtx, rtx, enum machine_mode, \n+\t\t\t\t\t      int));\n static rtx fixup_stack_1\tPARAMS ((rtx, rtx));\n static void optimize_bit_field\tPARAMS ((rtx, rtx, rtx *));\n static void instantiate_decls\tPARAMS ((tree, int));\n@@ -1859,7 +1860,8 @@ fixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel, no_share)\n \t      /* OLD might be a (subreg (mem)).  */\n \t      if (GET_CODE (replacements->old) == SUBREG)\n \t\treplacements->old\n-\t\t  = fixup_memory_subreg (replacements->old, insn, 0);\n+\t\t  = fixup_memory_subreg (replacements->old, insn, \n+\t\t\t\t\t promoted_mode, 0);\n \t      else\n \t\treplacements->old\n \t\t  = fixup_stack_1 (replacements->old, insn);\n@@ -1899,7 +1901,8 @@ fixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel, no_share)\n     {\n       if (GET_CODE (note) != INSN_LIST)\n \tXEXP (note, 0)\n-\t  = walk_fixup_memory_subreg (XEXP (note, 0), insn, 1);\n+\t  = walk_fixup_memory_subreg (XEXP (note, 0), insn,\n+\t\t\t\t      promoted_mode, 1);\n       note = XEXP (note, 1);\n     }\n }\n@@ -2070,7 +2073,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n \t\t  return;\n \t\t}\n \t      else\n-\t\ttem = fixup_memory_subreg (tem, insn, 0);\n+\t\ttem = fixup_memory_subreg (tem, insn, promoted_mode, 0);\n \t    }\n \t  else\n \t    tem = fixup_stack_1 (tem, insn);\n@@ -2185,7 +2188,8 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n \t      return;\n \t    }\n \n-\t  replacement->new = *loc = fixup_memory_subreg (x, insn, 0);\n+\t  replacement->new = *loc = fixup_memory_subreg (x, insn, \n+\t\t\t\t\t\t\t promoted_mode, 0);\n \n \t  INSN_CODE (insn) = -1;\n \t  if (! flag_force_mem && recog_memoized (insn) >= 0)\n@@ -2276,7 +2280,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n \t       This was legitimate when the MEM was a REG.  */\n \t    if (GET_CODE (tem) == SUBREG\n \t\t&& SUBREG_REG (tem) == var)\n-\t      tem = fixup_memory_subreg (tem, insn, 0);\n+\t      tem = fixup_memory_subreg (tem, insn, promoted_mode, 0);\n \t    else\n \t      tem = fixup_stack_1 (tem, insn);\n \n@@ -2378,7 +2382,8 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n \t\t  SET_SRC (x) = replacement->new;\n \t\telse if (GET_CODE (SET_SRC (x)) == SUBREG)\n \t\t  SET_SRC (x) = replacement->new\n-\t\t    = fixup_memory_subreg (SET_SRC (x), insn, 0);\n+\t\t    = fixup_memory_subreg (SET_SRC (x), insn, promoted_mode,\n+\t\t\t\t\t   0);\n \t\telse\n \t\t  SET_SRC (x) = replacement->new\n \t\t    = fixup_stack_1 (SET_SRC (x), insn);\n@@ -2431,7 +2436,8 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n \t    rtx pat, last;\n \n \t    if (GET_CODE (SET_DEST (x)) == SUBREG)\n-\t      SET_DEST (x) = fixup_memory_subreg (SET_DEST (x), insn, 0);\n+\t      SET_DEST (x) = fixup_memory_subreg (SET_DEST (x), insn, \n+\t\t\t\t\t\t  promoted_mode, 0);\n \t    else\n \t      SET_DEST (x) = fixup_stack_1 (SET_DEST (x), insn);\n \n@@ -2476,20 +2482,25 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n \t  {\n \t    rtx temp;\n \t    rtx fixeddest = SET_DEST (x);\n+\t    enum machine_mode temp_mode;\n \n \t    /* STRICT_LOW_PART can be discarded, around a MEM.  */\n \t    if (GET_CODE (fixeddest) == STRICT_LOW_PART)\n \t      fixeddest = XEXP (fixeddest, 0);\n \t    /* Convert (SUBREG (MEM)) to a MEM in a changed mode.  */\n \t    if (GET_CODE (fixeddest) == SUBREG)\n \t      {\n-\t\tfixeddest = fixup_memory_subreg (fixeddest, insn, 0);\n-\t\tpromoted_mode = GET_MODE (fixeddest);\n+\t\tfixeddest = fixup_memory_subreg (fixeddest, insn, \n+\t\t\t\t\t\t promoted_mode, 0);\n+\t\ttemp_mode = GET_MODE (fixeddest);\n \t      }\n \t    else\n-\t      fixeddest = fixup_stack_1 (fixeddest, insn);\n+\t      {\n+\t\tfixeddest = fixup_stack_1 (fixeddest, insn);\n+\t\ttemp_mode = promoted_mode;\n+\t      }\n \n-\t    temp = gen_reg_rtx (promoted_mode);\n+\t    temp = gen_reg_rtx (temp_mode);\n \n \t    emit_insn_after (gen_move_insn (fixeddest,\n \t\t\t\t\t    gen_lowpart (GET_MODE (fixeddest),\n@@ -2522,36 +2533,47 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements, no_share)\n     }\n }\n \f\n-/* Given X, an rtx of the form (SUBREG:m1 (MEM:m2 addr)),\n-   return an rtx (MEM:m1 newaddr) which is equivalent.\n-   If any insns must be emitted to compute NEWADDR, put them before INSN.\n+/* Previously, X had the form (SUBREG:m1 (REG:PROMOTED_MODE ...)).\n+   The REG  was placed on the stack, so X now has the form (SUBREG:m1\n+   (MEM:m2 ...)). \n+\n+   Return an rtx (MEM:m1 newaddr) which is equivalent.  If any insns\n+   must be emitted to compute NEWADDR, put them before INSN.\n \n    UNCRITICAL nonzero means accept paradoxical subregs.\n    This is used for subregs found inside REG_NOTES.  */\n \n static rtx\n-fixup_memory_subreg (x, insn, uncritical)\n+fixup_memory_subreg (x, insn, promoted_mode, uncritical)\n      rtx x;\n      rtx insn;\n+     enum machine_mode promoted_mode;\n      int uncritical;\n {\n-  int offset = SUBREG_BYTE (x);\n-  rtx addr = XEXP (SUBREG_REG (x), 0);\n+  int offset;\n+  rtx mem = SUBREG_REG (x);\n+  rtx addr = XEXP (mem, 0);\n   enum machine_mode mode = GET_MODE (x);\n   rtx result;\n \n   /* Paradoxical SUBREGs are usually invalid during RTL generation.  */\n-  if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))\n-      && ! uncritical)\n+  if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (mem)) && ! uncritical)\n     abort ();\n \n+  offset = SUBREG_BYTE (x);\n+  if (BYTES_BIG_ENDIAN)\n+    /* If the PROMOTED_MODE is wider than the mode of the MEM, adjust\n+       the offset so that it points to the right location within the\n+       MEM. */\n+    offset -= (GET_MODE_SIZE (promoted_mode) - GET_MODE_SIZE (GET_MODE (mem)));\n+\n   if (!flag_force_addr\n       && memory_address_p (mode, plus_constant (addr, offset)))\n     /* Shortcut if no insns need be emitted.  */\n-    return adjust_address (SUBREG_REG (x), mode, offset);\n+    return adjust_address (mem, mode, offset);\n \n   start_sequence ();\n-  result = adjust_address (SUBREG_REG (x), mode, offset);\n+  result = adjust_address (mem, mode, offset);\n   emit_insn_before (gen_sequence (), insn);\n   end_sequence ();\n   return result;\n@@ -2562,14 +2584,14 @@ fixup_memory_subreg (x, insn, uncritical)\n    If X itself is a (SUBREG (MEM ...) ...), return the replacement expression.\n    Otherwise return X, with its contents possibly altered.\n \n-   If any insns must be emitted to compute NEWADDR, put them before INSN.\n-\n-   UNCRITICAL is as in fixup_memory_subreg.  */\n+   INSN, PROMOTED_MODE and UNCRITICAL are as for \n+   fixup_memory_subreg.  */\n \n static rtx\n-walk_fixup_memory_subreg (x, insn, uncritical)\n+walk_fixup_memory_subreg (x, insn, promoted_mode, uncritical)\n      rtx x;\n      rtx insn;\n+     enum machine_mode promoted_mode;\n      int uncritical;\n {\n   enum rtx_code code;\n@@ -2582,21 +2604,23 @@ walk_fixup_memory_subreg (x, insn, uncritical)\n   code = GET_CODE (x);\n \n   if (code == SUBREG && GET_CODE (SUBREG_REG (x)) == MEM)\n-    return fixup_memory_subreg (x, insn, uncritical);\n+    return fixup_memory_subreg (x, insn, promoted_mode, uncritical);\n \n   /* Nothing special about this RTX; fix its operands.  */\n \n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tXEXP (x, i) = walk_fixup_memory_subreg (XEXP (x, i), insn, uncritical);\n+\tXEXP (x, i) = walk_fixup_memory_subreg (XEXP (x, i), insn, \n+\t\t\t\t\t\tpromoted_mode, uncritical);\n       else if (fmt[i] == 'E')\n \t{\n \t  int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    XVECEXP (x, i, j)\n-\t      = walk_fixup_memory_subreg (XVECEXP (x, i, j), insn, uncritical);\n+\t      = walk_fixup_memory_subreg (XVECEXP (x, i, j), insn, \n+\t\t\t\t\t  promoted_mode, uncritical);\n \t}\n     }\n   return x;"}]}