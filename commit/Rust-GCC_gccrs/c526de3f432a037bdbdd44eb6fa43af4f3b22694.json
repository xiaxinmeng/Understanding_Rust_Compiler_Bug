{"sha": "c526de3f432a037bdbdd44eb6fa43af4f3b22694", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUyNmRlM2Y0MzJhMDM3YmRiZGQ0NGViNmZhNDNhZjRmM2IyMjY5NA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-17T17:35:10Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-22T12:11:45Z"}, "message": "Add relations between LHS and op1/op2 for PLUS_EXPR.\n\n\t* range-op.cc (operator_plus::lhs_op1_relation): New.\n\t(operator_plus::lhs_op2_relation): New.", "tree": {"sha": "961ae1b7eebb2d9ca3658c19f977b84713d80dee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/961ae1b7eebb2d9ca3658c19f977b84713d80dee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c526de3f432a037bdbdd44eb6fa43af4f3b22694", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c526de3f432a037bdbdd44eb6fa43af4f3b22694", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c526de3f432a037bdbdd44eb6fa43af4f3b22694", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c526de3f432a037bdbdd44eb6fa43af4f3b22694/comments", "author": null, "committer": null, "parents": [{"sha": "a2c9173331914eff3d728c07afaeee71892689ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2c9173331914eff3d728c07afaeee71892689ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2c9173331914eff3d728c07afaeee71892689ba"}], "stats": {"total": 80, "additions": 80, "deletions": 0}, "files": [{"sha": "a7698f21b0d1ad9dd1bf360956ffe1420e22a5fe", "filename": "gcc/range-op.cc", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c526de3f432a037bdbdd44eb6fa43af4f3b22694/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c526de3f432a037bdbdd44eb6fa43af4f3b22694/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=c526de3f432a037bdbdd44eb6fa43af4f3b22694", "patch": "@@ -1150,8 +1150,88 @@ class operator_plus : public range_operator\n \t\t        const wide_int &lh_ub,\n \t\t        const wide_int &rh_lb,\n \t\t        const wide_int &rh_ub) const;\n+  virtual enum tree_code lhs_op1_relation (const irange &lhs, const irange &op1,\n+\t\t\t\t\t   const irange &op2) const;\n+  virtual enum tree_code lhs_op2_relation (const irange &lhs, const irange &op1,\n+\t\t\t\t\t   const irange &op2) const;\n } op_plus;\n \n+// Check to see if the range of OP2 indicates anything about the relation\n+// between LHS and OP1.\n+\n+enum tree_code\n+operator_plus::lhs_op1_relation (const irange &lhs,\n+\t\t\t\t const irange &op1,\n+\t\t\t\t const irange &op2) const\n+{\n+  if (lhs.undefined_p () || op1.undefined_p () || op2.undefined_p ())\n+    return VREL_NONE;\n+\n+  tree type = lhs.type ();\n+  unsigned prec = TYPE_PRECISION (type);\n+  wi::overflow_type ovf1, ovf2;\n+  signop sign = TYPE_SIGN (type);\n+\n+  // LHS = OP1 + 0  indicates LHS == OP1.\n+  if (op2.zero_p ())\n+    return EQ_EXPR;\n+\n+  if (TYPE_OVERFLOW_WRAPS (type))\n+    {\n+      wi::add (op1.lower_bound (), op2.lower_bound (), sign, &ovf1);\n+      wi::add (op1.upper_bound (), op2.upper_bound (), sign, &ovf2);\n+    }\n+  else\n+    ovf1 = ovf2 = wi::OVF_NONE;\n+\n+  // Never wrapping additions.\n+  if (!ovf1 && !ovf2)\n+    {\n+      // Positive op2 means lhs > op1.\n+      if (wi::gt_p (op2.lower_bound (), wi::zero (prec), sign))\n+\treturn GT_EXPR;\n+      if (wi::ge_p (op2.lower_bound (), wi::zero (prec), sign))\n+\treturn GE_EXPR;\n+\n+      // Negative op2 means lhs < op1.\n+      if (wi::lt_p (op2.upper_bound (), wi::zero (prec), sign))\n+\treturn LT_EXPR;\n+      if (wi::le_p (op2.upper_bound (), wi::zero (prec), sign))\n+\treturn LE_EXPR;\n+    }\n+  // Always wrapping additions.\n+  else if (ovf1 && ovf1 == ovf2)\n+    {\n+      // Positive op2 means lhs < op1.\n+      if (wi::gt_p (op2.lower_bound (), wi::zero (prec), sign))\n+\treturn LT_EXPR;\n+      if (wi::ge_p (op2.lower_bound (), wi::zero (prec), sign))\n+\treturn LE_EXPR;\n+\n+      // Negative op2 means lhs > op1.\n+      if (wi::lt_p (op2.upper_bound (), wi::zero (prec), sign))\n+\treturn GT_EXPR;\n+      if (wi::le_p (op2.upper_bound (), wi::zero (prec), sign))\n+\treturn GE_EXPR;\n+    }\n+\n+  // If op2 does not contain 0, then LHS and OP1 can never be equal.\n+  if (!range_includes_zero_p (&op2))\n+    return NE_EXPR;\n+\n+  return VREL_NONE;\n+}\n+\n+// PLUS is symmetrical, so we can simply call lhs_op1_relation with reversed\n+// operands.\n+\n+enum tree_code\n+operator_plus::lhs_op2_relation (const irange &lhs, const irange &op1,\n+\t\t\t\t const irange &op2) const\n+{\n+  return lhs_op1_relation (lhs, op2, op1);\n+}\n+\n void\n operator_plus::wi_fold (irange &r, tree type,\n \t\t\tconst wide_int &lh_lb, const wide_int &lh_ub,"}]}