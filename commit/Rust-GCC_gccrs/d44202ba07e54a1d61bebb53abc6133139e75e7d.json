{"sha": "d44202ba07e54a1d61bebb53abc6133139e75e7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ0MjAyYmEwN2U1NGExZDYxYmViYjUzYWJjNjEzMzEzOWU3NWU3ZA==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2008-07-30T15:53:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-07-30T15:53:21Z"}, "message": "einfo.adb: Flag245 is now used.\n\n2008-07-30  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb: Flag245 is now used.\n\t(Is_Primitive_Wrapper, Set_Is_Primitive_Wrapper): Relax the assertion\n\tcheck to include functions.\n\t(Is_Private_Primitive, Set_Is_Private_Primitive): New subprograms.\n\t(Wrapped_Entity, Set_Wrapped_Entity): Relax the assertion check to\n\tinclude functions.\n\t(Write_Entity_Flags): Move flag Is_Primitive, add Is_Private_Primitive\n\tto the list of displayed flags.\n\n\t* einfo.ads: Update comment on the usage of Is_Primitive_Wrapper and\n\tWrapped_Entity. These two flags are now present in functions.\n\tNew flag Is_Private_Primitive.\n\t(Is_Private_Primitive, Set_Is_Private_Primitive): New subprograms.\n\n\t* exp_ch9.adb:\n\t(Build_Wrapper_Bodies): New subprogram.\n\t(Build_Wrapper_Body): The spec and body have been moved to in\n\tBuild_Wrapper_ Bodies. Code cleanup.\n\t(Build_Wrapper_Spec): Moved to the spec of Exp_Ch9. Code cleanup.\n\tWrappers are now generated for primitives declared between the private\n\tand full view of a concurrent type that implements an interface.\n\t(Build_Wrapper_Specs): New subprogram.\n\t(Expand_N_Protected_Body): Code reformatting. Replace the wrapper body\n\tcreation mechanism with a call to Build_Wrapper_Bodies.\n\t(Expand_N_Protected_Type_Declaration): Code reformatting. Replace the\n\twrapper spec creation mechanism with a call to Build_Wrapper_Specs.\n\t(Expand_N_Task_Body): Replace the wrapper body creation\n\tmechanism with a call to Build_Wrapper_Bodies.\n\t(Expand_N_Task_Type_Declaration): Replace the wrapper spec\n\tcreation mechanism with a call to Build_Wrapper_Specs.\n\t(Is_Private_Primitive_Subprogram): New subprogram.\n\t(Overriding_Possible): Code cleanup.\n\t(Replicate_Entry_Formals): Renamed to Replicate_Formals, code cleanup.\n\n\t* exp_ch9.ads (Build_Wrapper_Spec): Moved from the body of Exp_Ch9.\n\n\t* sem_ch3.adb: Add with and use clause for Exp_Ch9.\n\t(Process_Full_View): Build wrapper specs for all primitives\n\tthat belong to a private view completed by a concurrent type\n\timplementing an interface.\n\t\n\t* sem_ch6.adb (Analyze_Subprogram_Body): When the current subprogram\n\tis a primitive of a\n\tconcurrent type with a private view that implements an interface, try to\n\tfind the proper spec.\n\t(Analyze_Subprogram_Declaration): Mark a subprogram as a private\n\tprimitive if the type of its first parameter is a non-generic tagged\n\tprivate type.\n\t(Analyze_Subprogram_Specification): Code reformatting.\n\t(Disambiguate_Spec): New routine.\n\t(Find_Corresponding_Spec): Add a flag to controll the output of errors.\n\t(Is_Private_Concurrent_Primitive): New routine.\n\n\t* sem_ch6.ads:\n\t(Find_Corresponding_Spec): Add a formal to control the output of errors.\n\nFrom-SVN: r138324", "tree": {"sha": "c7852aef0cf22d5feadc587c44e306ffefd2bfe5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7852aef0cf22d5feadc587c44e306ffefd2bfe5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d44202ba07e54a1d61bebb53abc6133139e75e7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d44202ba07e54a1d61bebb53abc6133139e75e7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d44202ba07e54a1d61bebb53abc6133139e75e7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d44202ba07e54a1d61bebb53abc6133139e75e7d/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dc829590914f5ae29de5f246319f5c37127c8ccd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc829590914f5ae29de5f246319f5c37127c8ccd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc829590914f5ae29de5f246319f5c37127c8ccd"}], "stats": {"total": 1442, "additions": 849, "deletions": 593}, "files": [{"sha": "01d384ec4f6371e819b5a8cc7e3b02571c238919", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d44202ba07e54a1d61bebb53abc6133139e75e7d/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d44202ba07e54a1d61bebb53abc6133139e75e7d/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=d44202ba07e54a1d61bebb53abc6133139e75e7d", "patch": "@@ -504,9 +504,8 @@ package body Einfo is\n    --    Optimize_Alignment_Time         Flag242\n    --    Overlays_Constant               Flag243\n    --    Is_RACW_Stub_Type               Flag244\n+   --    Is_Private_Primitive            Flag245\n \n-   --    (unused)                        Flag169\n-   --    (unused)                        Flag245\n    --    (unused)                        Flag246\n    --    (unused)                        Flag247\n \n@@ -1929,7 +1928,8 @@ package body Einfo is\n \n    function Is_Primitive_Wrapper (Id : E) return B is\n    begin\n-      pragma Assert (Ekind (Id) = E_Procedure);\n+      pragma Assert (Ekind (Id) = E_Function\n+        or else Ekind (Id) = E_Procedure);\n       return Flag195 (Id);\n    end Is_Primitive_Wrapper;\n \n@@ -1944,6 +1944,13 @@ package body Einfo is\n       return Flag53 (Id);\n    end Is_Private_Descendant;\n \n+   function Is_Private_Primitive (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Function\n+        or else Ekind (Id) = E_Procedure);\n+      return Flag245 (Id);\n+   end Is_Private_Primitive;\n+\n    function Is_Protected_Interface (Id : E) return B is\n    begin\n       pragma Assert (Is_Interface (Id));\n@@ -2702,8 +2709,9 @@ package body Einfo is\n \n    function Wrapped_Entity (Id : E) return E is\n    begin\n-      pragma Assert (Ekind (Id) = E_Procedure\n-                       and then Is_Primitive_Wrapper (Id));\n+      pragma Assert ((Ekind (Id) = E_Function\n+          or else Ekind (Id) = E_Procedure)\n+        and then Is_Primitive_Wrapper (Id));\n       return Node27 (Id);\n    end Wrapped_Entity;\n \n@@ -4372,7 +4380,8 @@ package body Einfo is\n \n    procedure Set_Is_Primitive_Wrapper (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Ekind (Id) = E_Procedure);\n+      pragma Assert (Ekind (Id) = E_Function\n+        or else Ekind (Id) = E_Procedure);\n       Set_Flag195 (Id, V);\n    end Set_Is_Primitive_Wrapper;\n \n@@ -4387,6 +4396,13 @@ package body Einfo is\n       Set_Flag53 (Id, V);\n    end Set_Is_Private_Descendant;\n \n+   procedure Set_Is_Private_Primitive (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Function\n+        or else Ekind (Id) = E_Procedure);\n+      Set_Flag245 (Id, V);\n+   end Set_Is_Private_Primitive;\n+\n    procedure Set_Is_Protected_Interface (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Interface (Id));\n@@ -5168,8 +5184,9 @@ package body Einfo is\n \n    procedure Set_Wrapped_Entity (Id : E; V : E) is\n    begin\n-      pragma Assert (Ekind (Id) = E_Procedure\n-                       and then Is_Primitive_Wrapper (Id));\n+      pragma Assert ((Ekind (Id) = E_Function\n+          or else Ekind (Id) = E_Procedure)\n+        and then Is_Primitive_Wrapper (Id));\n       Set_Node27 (Id, V);\n    end Set_Wrapped_Entity;\n \n@@ -7597,9 +7614,11 @@ package body Einfo is\n       W (\"Is_Packed_Array_Type\",            Flag138 (Id));\n       W (\"Is_Potentially_Use_Visible\",      Flag9   (Id));\n       W (\"Is_Preelaborated\",                Flag59  (Id));\n+      W (\"Is_Primitive\",                    Flag218 (Id));\n       W (\"Is_Primitive_Wrapper\",            Flag195 (Id));\n       W (\"Is_Private_Composite\",            Flag107 (Id));\n       W (\"Is_Private_Descendant\",           Flag53  (Id));\n+      W (\"Is_Private_Primitive\",            Flag245 (Id));\n       W (\"Is_Protected_Interface\",          Flag198 (Id));\n       W (\"Is_Public\",                       Flag10  (Id));\n       W (\"Is_Pure\",                         Flag44  (Id));\n@@ -7666,7 +7685,6 @@ package body Einfo is\n       W (\"Suppress_Init_Proc\",              Flag105 (Id));\n       W (\"Suppress_Style_Checks\",           Flag165 (Id));\n       W (\"Suppress_Value_Tracking_On_Call\", Flag217 (Id));\n-      W (\"Is_Primitive\",                    Flag218 (Id));\n       W (\"Treat_As_Volatile\",               Flag41  (Id));\n       W (\"Universal_Aliasing\",              Flag216 (Id));\n       W (\"Used_As_Generic_Actual\",          Flag222 (Id));"}, {"sha": "8316a68018afd0894abcf3d7be07e0c15fc4763a", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d44202ba07e54a1d61bebb53abc6133139e75e7d/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d44202ba07e54a1d61bebb53abc6133139e75e7d/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=d44202ba07e54a1d61bebb53abc6133139e75e7d", "patch": "@@ -2513,9 +2513,9 @@ package Einfo is\n --       indicators in bodies.\n \n --    Is_Primitive_Wrapper (Flag195)\n---       Present in all entities. Set for procedure entries that are used as\n---       primitive wrappers. which are generated by the expander to wrap\n---       entries of protected or task types implementing a limited interface.\n+--       Present in functions and procedures created by the expander to serve\n+--       as an indirection mechanism to overriding primitives of concurrent\n+--       types, entries and protected procedures.\n \n --    Is_Prival (synthesized)\n --       Applies to all entities, true for renamings of private protected\n@@ -2533,6 +2533,10 @@ package Einfo is\n --       functions, procedures). Set if the library unit is itself a private\n --       child unit, or if it is the descendent of a private child unit.\n \n+--    Is_Private_Primitive (Flag245)\n+--       Present in subprograms. Set if the first parameter of the subprogram\n+--       is of concurrent tagged type with a private view.\n+\n --    Is_Private_Type (synthesized)\n --       Applies to all entities, true for private types and subtypes,\n --       as well as for record with private types as subtypes\n@@ -3723,8 +3727,8 @@ package Einfo is\n --       attribute when the limited-view is installed (Ada 2005: AI-217).\n \n --    Wrapped_Entity (Node27)\n---       Present in an E_Procedure classified as an Is_Primitive_Wrapper. Set\n---       to the entity that is being wrapped.\n+--       Present in functions and procedures which have been classified as\n+--       Is_Primitive_Wrapper. Set to the entity being wrapper.\n \n    ------------------\n    -- Access Kinds --\n@@ -5013,6 +5017,7 @@ package Einfo is\n    --    Protection_Object                   (Node23)   (for concurrent kind)\n    --    Interface_Alias                     (Node25)\n    --    Overridden_Operation                (Node26)\n+   --    Wrapped_Entity                      (Node27)   (non-generic case only)\n    --    Extra_Formals                       (Node28)\n    --    Body_Needed_For_SAL                 (Flag40)\n    --    Elaboration_Entity_Required         (Flag174)\n@@ -5039,7 +5044,9 @@ package Einfo is\n    --    Is_Machine_Code_Subprogram          (Flag137)  (non-generic case only)\n    --    Is_Overriding_Operation             (Flag39)   (non-generic case only)\n    --    Is_Primitive                        (Flag218)\n+   --    Is_Primitive_Wrapper                (Flag195)  (non-generic case only)\n    --    Is_Private_Descendant               (Flag53)\n+   --    Is_Private_Primitive                (Flag245)  (non-generic case only)\n    --    Is_Pure                             (Flag44)\n    --    Is_Thunk                            (Flag225)\n    --    Is_Visible_Child_Unit               (Flag116)\n@@ -5305,6 +5312,7 @@ package Einfo is\n    --    Is_Primitive                        (Flag218)\n    --    Is_Primitive_Wrapper                (Flag195)  (non-generic case only)\n    --    Is_Private_Descendant               (Flag53)\n+   --    Is_Private_Primitive                (Flag245)  (non-generic case only)\n    --    Is_Pure                             (Flag44)\n    --    Is_Thunk                            (Flag225)\n    --    Is_Valued_Procedure                 (Flag127)\n@@ -5974,6 +5982,7 @@ package Einfo is\n    function Is_Primitive_Wrapper                (Id : E) return B;\n    function Is_Private_Composite                (Id : E) return B;\n    function Is_Private_Descendant               (Id : E) return B;\n+   function Is_Private_Primitive                (Id : E) return B;\n    function Is_Protected_Interface              (Id : E) return B;\n    function Is_Public                           (Id : E) return B;\n    function Is_Pure                             (Id : E) return B;\n@@ -6538,6 +6547,7 @@ package Einfo is\n    procedure Set_Is_Primitive_Wrapper            (Id : E; V : B := True);\n    procedure Set_Is_Private_Composite            (Id : E; V : B := True);\n    procedure Set_Is_Private_Descendant           (Id : E; V : B := True);\n+   procedure Set_Is_Private_Primitive            (Id : E; V : B := True);\n    procedure Set_Is_Protected_Interface          (Id : E; V : B := True);\n    procedure Set_Is_Public                       (Id : E; V : B := True);\n    procedure Set_Is_Pure                         (Id : E; V : B := True);\n@@ -7216,6 +7226,7 @@ package Einfo is\n    pragma Inline (Is_Primitive_Wrapper);\n    pragma Inline (Is_Private_Composite);\n    pragma Inline (Is_Private_Descendant);\n+   pragma Inline (Is_Private_Primitive);\n    pragma Inline (Is_Private_Type);\n    pragma Inline (Is_Protected_Interface);\n    pragma Inline (Is_Protected_Type);\n@@ -7609,6 +7620,7 @@ package Einfo is\n    pragma Inline (Set_Is_Primitive_Wrapper);\n    pragma Inline (Set_Is_Private_Composite);\n    pragma Inline (Set_Is_Private_Descendant);\n+   pragma Inline (Set_Is_Private_Primitive);\n    pragma Inline (Set_Is_Protected_Interface);\n    pragma Inline (Set_Is_Public);\n    pragma Inline (Set_Is_Pure);"}, {"sha": "d040f00a6cf174e6d82d1d710ad8a2ab2f8c257a", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 500, "deletions": 520, "changes": 1020, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d44202ba07e54a1d61bebb53abc6133139e75e7d/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d44202ba07e54a1d61bebb53abc6133139e75e7d/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=d44202ba07e54a1d61bebb53abc6133139e75e7d", "patch": "@@ -152,29 +152,25 @@ package body Exp_Ch9 is\n    --       <formalN> : AnnN;\n    --    end record;\n \n-   function Build_Wrapper_Body\n-     (Loc      : Source_Ptr;\n-      Proc_Nam : Entity_Id;\n-      Obj_Typ  : Entity_Id;\n-      Formals  : List_Id) return Node_Id;\n-   --  Ada 2005 (AI-345): Build the body that wraps a primitive operation\n-   --  associated with a protected or task type. This is required to implement\n-   --  dispatching calls through interfaces. Proc_Nam is the entry name to be\n-   --  wrapped, Obj_Typ is the type of the newly added formal parameter to\n-   --  handle object notation, Formals are the original entry formals that will\n-   --  be explicitly replicated.\n-\n-   function Build_Wrapper_Spec\n-     (Loc      : Source_Ptr;\n-      Proc_Nam : Entity_Id;\n-      Obj_Typ  : Entity_Id;\n-      Formals  : List_Id) return Node_Id;\n-   --  Ada 2005 (AI-345): Build the specification of a primitive operation\n-   --  associated with a protected or task type. This is required implement\n-   --  dispatching calls through interfaces. Proc_Nam is the entry name to be\n-   --  wrapped, Obj_Typ is the type of the newly added formal parameter to\n-   --  handle object notation, Formals are the original entry formals that will\n-   --  be explicitly replicated.\n+   procedure Build_Wrapper_Bodies\n+     (Loc : Source_Ptr;\n+      Typ : Entity_Id;\n+      N   : Node_Id);\n+   --  Ada 2005 (AI-345): Typ is either a concurrent type or the corresponding\n+   --  record of a concurrent type. N is the insertion node where all bodies\n+   --  will be placed. This routine builds the bodies of the subprograms which\n+   --  serve as an indirection mechanism to overriding primitives of concurrent\n+   --  types, entries and protected procedures. Any new body is analyzed.\n+\n+   procedure Build_Wrapper_Specs\n+     (Loc : Source_Ptr;\n+      Typ : Entity_Id;\n+      N   : in out Node_Id);\n+   --  Ada 2005 (AI-345): Typ is either a concurrent type or the corresponding\n+   --  record of a concurrent type. N is the insertion node where all specs\n+   --  will be placed. This routine builds the specs of the subprograms which\n+   --  serve as an indirection mechanism to overriding primitives of concurrent\n+   --  types, entries and protected procedures. Any new spec is analyzed.\n \n    function Build_Find_Body_Index (Typ : Entity_Id) return Node_Id;\n    --  Build the function that translates the entry index in the call\n@@ -359,6 +355,10 @@ package body Exp_Ch9 is\n       Lo         : Node_Id;\n       Hi         : Node_Id) return Boolean;\n \n+   function Is_Private_Primitive_Subprogram (Id : Entity_Id) return Boolean;\n+   --  Determine whether Id is a function or a procedure and is marked as a\n+   --  private primitive.\n+\n    function Null_Statements (Stats : List_Id) return Boolean;\n    --  Used to check DO-END sequence. Checks for equivalent of DO NULL; END.\n    --  Allows labels, and pragma Warnings/Unreferenced in the sequence as\n@@ -1541,144 +1541,241 @@ package body Exp_Ch9 is\n       return Rec_Nam;\n    end Build_Parameter_Block;\n \n-   ------------------------\n-   -- Build_Wrapper_Body --\n-   ------------------------\n+   --------------------------\n+   -- Build_Wrapper_Bodies --\n+   --------------------------\n \n-   function Build_Wrapper_Body\n-     (Loc      : Source_Ptr;\n-      Proc_Nam : Entity_Id;\n-      Obj_Typ  : Entity_Id;\n-      Formals  : List_Id) return Node_Id\n+   procedure Build_Wrapper_Bodies\n+     (Loc : Source_Ptr;\n+      Typ : Entity_Id;\n+      N   : Node_Id)\n    is\n-      Actuals      : List_Id := No_List;\n-      Body_Spec    : Node_Id;\n-      Conv_Id      : Node_Id;\n-      First_Formal : Node_Id;\n-      Formal       : Node_Id;\n-\n-   begin\n-      Body_Spec := Build_Wrapper_Spec (Loc, Proc_Nam, Obj_Typ, Formals);\n+      Rec_Typ : Entity_Id;\n \n-      --  If we did not generate the specification do have nothing else to do\n+      function Build_Wrapper_Body\n+        (Loc     : Source_Ptr;\n+         Subp_Id : Entity_Id;\n+         Obj_Typ : Entity_Id;\n+         Formals : List_Id) return Node_Id;\n+      --  Ada 2005 (AI-345): Build the body that wraps a primitive operation\n+      --  associated with a protected or task type. Subp_Id is the subprogram\n+      --  name which will be wrapped. Obj_Typ is the type of the new formal\n+      --  parameter which handles dispatching and object notation. Formals are\n+      --  the original formals of Subp_Id which will be explicitly replicated.\n+\n+      ------------------------\n+      -- Build_Wrapper_Body --\n+      ------------------------\n+\n+      function Build_Wrapper_Body\n+        (Loc     : Source_Ptr;\n+         Subp_Id : Entity_Id;\n+         Obj_Typ : Entity_Id;\n+         Formals : List_Id) return Node_Id\n+      is\n+         Body_Spec : Node_Id;\n \n-      if Body_Spec = Empty then\n-         return Empty;\n-      end if;\n+      begin\n+         Body_Spec := Build_Wrapper_Spec (Loc, Subp_Id, Obj_Typ, Formals);\n \n-      --  Map formals to actuals. Use the list built for the wrapper spec,\n-      --  skipping the object notation parameter.\n+         --  The subprogram is not overriding or is not a primitive declared\n+         --  between two views.\n \n-      First_Formal := First (Parameter_Specifications (Body_Spec));\n+         if No (Body_Spec) then\n+            return Empty;\n+         end if;\n \n-      Formal := First_Formal;\n-      Next (Formal);\n+         declare\n+            Actuals      : List_Id := No_List;\n+            Conv_Id      : Node_Id;\n+            First_Formal : Node_Id;\n+            Formal       : Node_Id;\n+            Nam          : Node_Id;\n \n-      if Present (Formal) then\n-         Actuals := New_List;\n+         begin\n+            --  Map formals to actuals. Use the list built for the wrapper\n+            --  spec, skipping the object notation parameter.\n \n-         while Present (Formal) loop\n-            Append_To (Actuals,\n-              Make_Identifier (Loc, Chars =>\n-                Chars (Defining_Identifier (Formal))));\n+            First_Formal := First (Parameter_Specifications (Body_Spec));\n \n+            Formal := First_Formal;\n             Next (Formal);\n-         end loop;\n-      end if;\n \n-      --  An access-to-variable first parameter will require an explicit\n-      --  dereference in the unchecked conversion. This case occurs when\n-      --  a protected entry wrapper must override an interface-level\n-      --  procedure with interface access as first parameter.\n+            if Present (Formal) then\n+               Actuals := New_List;\n \n-      --     SubprgName (O.all).Proc_Nam (Formal_1 .. Formal_N)\n+               while Present (Formal) loop\n+                  Append_To (Actuals,\n+                    Make_Identifier (Loc, Chars =>\n+                      Chars (Defining_Identifier (Formal))));\n \n-      if Nkind (Parameter_Type (First_Formal)) = N_Access_Definition then\n-         Conv_Id :=\n-           Make_Explicit_Dereference (Loc,\n-             Prefix =>\n-               Make_Identifier (Loc, Chars => Name_uO));\n+                  Next (Formal);\n+               end loop;\n+            end if;\n+\n+            --  Special processing for primitives declared between a private\n+            --  type and its completion.\n+\n+            if Is_Private_Primitive_Subprogram (Subp_Id) then\n+               if No (Actuals) then\n+                  Actuals := New_List;\n+               end if;\n+\n+               Prepend_To (Actuals,\n+                 Unchecked_Convert_To (\n+                   Corresponding_Concurrent_Type (Obj_Typ),\n+                   Make_Identifier (Loc, Name_uO)));\n+\n+               Nam := New_Reference_To (Subp_Id, Loc);\n+\n+            else\n+               --  An access-to-variable object parameter requires an explicit\n+               --  dereference in the unchecked conversion. This case occurs\n+               --  when a protected entry wrapper must override an interface\n+               --  level procedure with interface access as first parameter.\n+\n+               --     O.all.Subp_Id (Formal_1 .. Formal_N)\n+\n+               if Nkind (Parameter_Type (First_Formal)) =\n+                    N_Access_Definition\n+               then\n+                  Conv_Id :=\n+                    Make_Explicit_Dereference (Loc,\n+                      Prefix => Make_Identifier (Loc, Name_uO));\n+               else\n+                  Conv_Id := Make_Identifier (Loc, Name_uO);\n+               end if;\n+\n+               Nam :=\n+                 Make_Selected_Component (Loc,\n+                   Prefix =>\n+                     Unchecked_Convert_To (\n+                       Corresponding_Concurrent_Type (Obj_Typ),\n+                       Conv_Id),\n+                   Selector_Name =>\n+                     New_Reference_To (Subp_Id, Loc));\n+            end if;\n+\n+            --  Create the subprogram body\n+\n+            if Ekind (Subp_Id) = E_Function then\n+               return\n+                 Make_Subprogram_Body (Loc,\n+                   Specification => Body_Spec,\n+                   Declarations => Empty_List,\n+                   Handled_Statement_Sequence =>\n+                     Make_Handled_Sequence_Of_Statements (Loc,\n+                       Statements => New_List (\n+                         Make_Simple_Return_Statement (Loc,\n+                           Make_Function_Call (Loc,\n+                             Name => Nam,\n+                             Parameter_Associations => Actuals)))));\n+\n+            else\n+               return\n+                 Make_Subprogram_Body (Loc,\n+                   Specification => Body_Spec,\n+                   Declarations => Empty_List,\n+                   Handled_Statement_Sequence =>\n+                     Make_Handled_Sequence_Of_Statements (Loc,\n+                       Statements => New_List (\n+                         Make_Procedure_Call_Statement (Loc,\n+                           Name => Nam,\n+                           Parameter_Associations => Actuals))));\n+            end if;\n+         end;\n+      end Build_Wrapper_Body;\n+\n+   --  Start of processing for Build_Wrapper_Bodies\n+\n+   begin\n+      if Is_Concurrent_Type (Typ) then\n+         Rec_Typ := Corresponding_Record_Type (Typ);\n       else\n-         Conv_Id :=\n-           Make_Identifier (Loc, Chars => Name_uO);\n+         Rec_Typ := Typ;\n       end if;\n \n-      if Ekind (Proc_Nam) = E_Function then\n-         return\n-           Make_Subprogram_Body (Loc,\n-             Specification => Body_Spec,\n-             Declarations  => Empty_List,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements =>\n-                   New_List (\n-                     Make_Simple_Return_Statement (Loc,\n-                        Make_Function_Call (Loc,\n-                          Name =>\n-                            Make_Selected_Component (Loc,\n-                              Prefix =>\n-                                Unchecked_Convert_To (\n-                                  Corresponding_Concurrent_Type (Obj_Typ),\n-                                  Conv_Id),\n-                              Selector_Name =>\n-                                New_Reference_To (Proc_Nam, Loc)),\n-                          Parameter_Associations => Actuals)))));\n-      else\n-         return\n-           Make_Subprogram_Body (Loc,\n-             Specification => Body_Spec,\n-             Declarations  => Empty_List,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements =>\n-                   New_List (\n-                     Make_Procedure_Call_Statement (Loc,\n-                       Name =>\n-                         Make_Selected_Component (Loc,\n-                           Prefix =>\n-                             Unchecked_Convert_To (\n-                               Corresponding_Concurrent_Type (Obj_Typ),\n-                               Conv_Id),\n-                           Selector_Name =>\n-                             New_Reference_To (Proc_Nam, Loc)),\n-                       Parameter_Associations => Actuals))));\n+      --  Generate wrapper bodies for a concurrent type which implements an\n+      --  interface.\n+\n+      if Present (Interfaces (Rec_Typ)) then\n+         declare\n+            Insert_Nod : Node_Id;\n+            Prim       : Entity_Id;\n+            Prim_Elmt  : Elmt_Id;\n+            Prim_Decl  : Node_Id;\n+            Subp       : Entity_Id;\n+            Wrap_Body  : Node_Id;\n+            Wrap_Id    : Entity_Id;\n+\n+         begin\n+            Insert_Nod := N;\n+\n+            --  Examine all primitive operations of the corresponding record\n+            --  type, looking for wrapper specs. Generate bodies in order to\n+            --  complete them.\n+\n+            Prim_Elmt := First_Elmt (Primitive_Operations (Rec_Typ));\n+            while Present (Prim_Elmt) loop\n+               Prim := Node (Prim_Elmt);\n+\n+               if (Ekind (Prim) = E_Function\n+                     or else Ekind (Prim) = E_Procedure)\n+                 and then Is_Primitive_Wrapper (Prim)\n+               then\n+                  Subp := Wrapped_Entity (Prim);\n+                  Prim_Decl := Parent (Parent (Prim));\n+\n+                  Wrap_Body :=\n+                    Build_Wrapper_Body (Loc,\n+                      Subp_Id => Subp,\n+                      Obj_Typ => Rec_Typ,\n+                      Formals => Parameter_Specifications (Parent (Subp)));\n+                  Wrap_Id := Defining_Unit_Name (Specification (Wrap_Body));\n+\n+                  Set_Corresponding_Spec (Wrap_Body, Prim);\n+                  Set_Corresponding_Body (Prim_Decl, Wrap_Id);\n+\n+                  Insert_After (Insert_Nod, Wrap_Body);\n+                  Insert_Nod := Wrap_Body;\n+\n+                  Analyze (Wrap_Body);\n+               end if;\n+\n+               Next_Elmt (Prim_Elmt);\n+            end loop;\n+         end;\n       end if;\n-   end Build_Wrapper_Body;\n+   end Build_Wrapper_Bodies;\n \n    ------------------------\n    -- Build_Wrapper_Spec --\n    ------------------------\n \n    function Build_Wrapper_Spec\n-     (Loc      : Source_Ptr;\n-      Proc_Nam : Entity_Id;\n-      Obj_Typ  : Entity_Id;\n-      Formals  : List_Id) return Node_Id\n+     (Loc     : Source_Ptr;\n+      Subp_Id : Entity_Id;\n+      Obj_Typ : Entity_Id;\n+      Formals : List_Id) return Node_Id\n    is\n-      New_Name_Id : constant Entity_Id :=\n-                      Make_Defining_Identifier (Loc, Chars (Proc_Nam));\n-\n-      First_Param        : Node_Id := Empty;\n-      Iface              : Entity_Id;\n-      Iface_Elmt         : Elmt_Id := No_Elmt;\n-      New_Formals        : List_Id;\n-      Obj_Param          : Node_Id;\n-      Obj_Param_Typ      : Node_Id;\n-      Iface_Prim_Op      : Entity_Id;\n-      Iface_Prim_Op_Elmt : Elmt_Id;\n+      First_Param   : Node_Id;\n+      Iface         : Entity_Id;\n+      Iface_Elmt    : Elmt_Id;\n+      Iface_Op      : Entity_Id;\n+      Iface_Op_Elmt : Elmt_Id;\n \n       function Overriding_Possible\n-        (Iface_Prim_Op : Entity_Id;\n-         Proc_Nam      : Entity_Id) return Boolean;\n-      --  Determine whether a primitive operation can be overridden by the\n-      --  wrapper. Iface_Prim_Op is the candidate primitive operation of an\n-      --  abstract interface type, Proc_Nam is the generated entry wrapper.\n+        (Iface_Op : Entity_Id;\n+         Wrapper  : Entity_Id) return Boolean;\n+      --  Determine whether a primitive operation can be overridden by Wrapper.\n+      --  Iface_Op is the candidate primitive operation of an interface type,\n+      --  Wrapper is the generated entry wrapper.\n \n-      function Replicate_Entry_Formals\n+      function Replicate_Formals\n         (Loc     : Source_Ptr;\n          Formals : List_Id) return List_Id;\n-      --  An explicit parameter replication is required due to the\n-      --  Is_Entry_Formal flag being set for all the formals. The explicit\n+      --  An explicit parameter replication is required due to the Is_Entry_\n+      --  Formal flag being set for all the formals of an entry. The explicit\n       --  replication removes the flag that would otherwise cause a different\n       --  path of analysis.\n \n@@ -1687,18 +1784,15 @@ package body Exp_Ch9 is\n       -------------------------\n \n       function Overriding_Possible\n-        (Iface_Prim_Op : Entity_Id;\n-         Proc_Nam      : Entity_Id) return Boolean\n+        (Iface_Op : Entity_Id;\n+         Wrapper  : Entity_Id) return Boolean\n       is\n-         Prim_Op_Spec  : constant Node_Id := Parent (Iface_Prim_Op);\n-         Proc_Spec     : constant Node_Id := Parent (Proc_Nam);\n-\n-         Is_Access_To_Variable : Boolean;\n-         Is_Out_Present        : Boolean;\n+         Iface_Op_Spec : constant Node_Id := Parent (Iface_Op);\n+         Wrapper_Spec  : constant Node_Id := Parent (Wrapper);\n \n          function Type_Conformant_Parameters\n-           (Prim_Op_Param_Specs : List_Id;\n-            Proc_Param_Specs    : List_Id) return Boolean;\n+           (Iface_Op_Params : List_Id;\n+            Wrapper_Params  : List_Id) return Boolean;\n          --  Determine whether the parameters of the generated entry wrapper\n          --  and those of a primitive operation are type conformant. During\n          --  this check, the first parameter of the primitive operation is\n@@ -1709,40 +1803,40 @@ package body Exp_Ch9 is\n          --------------------------------\n \n          function Type_Conformant_Parameters\n-           (Prim_Op_Param_Specs : List_Id;\n-            Proc_Param_Specs    : List_Id) return Boolean\n+           (Iface_Op_Params : List_Id;\n+            Wrapper_Params  : List_Id) return Boolean\n          is\n-            Prim_Op_Param : Node_Id;\n-            Prim_Op_Typ   : Entity_Id;\n-            Proc_Param    : Node_Id;\n-            Proc_Typ      : Entity_Id;\n+            Iface_Op_Param : Node_Id;\n+            Iface_Op_Typ   : Entity_Id;\n+            Wrapper_Param  : Node_Id;\n+            Wrapper_Typ    : Entity_Id;\n \n          begin\n             --  Skip the first parameter of the primitive operation\n \n-            Prim_Op_Param := Next (First (Prim_Op_Param_Specs));\n-            Proc_Param    := First (Proc_Param_Specs);\n-            while Present (Prim_Op_Param)\n-              and then Present (Proc_Param)\n+            Iface_Op_Param := Next (First (Iface_Op_Params));\n+            Wrapper_Param  := First (Wrapper_Params);\n+            while Present (Iface_Op_Param)\n+              and then Present (Wrapper_Param)\n             loop\n-               Prim_Op_Typ := Find_Parameter_Type (Prim_Op_Param);\n-               Proc_Typ    := Find_Parameter_Type (Proc_Param);\n+               Iface_Op_Typ := Find_Parameter_Type (Iface_Op_Param);\n+               Wrapper_Typ  := Find_Parameter_Type (Wrapper_Param);\n \n                --  The two parameters must be mode conformant\n \n                if not Conforming_Types\n-                        (Prim_Op_Typ, Proc_Typ, Mode_Conformant)\n+                        (Iface_Op_Typ, Wrapper_Typ, Mode_Conformant)\n                then\n                   return False;\n                end if;\n \n-               Next (Prim_Op_Param);\n-               Next (Proc_Param);\n+               Next (Iface_Op_Param);\n+               Next (Wrapper_Param);\n             end loop;\n \n             --  One of the lists is longer than the other\n \n-            if Present (Prim_Op_Param) or else Present (Proc_Param) then\n+            if Present (Iface_Op_Param) or else Present (Wrapper_Param) then\n                return False;\n             end if;\n \n@@ -1752,47 +1846,42 @@ package body Exp_Ch9 is\n       --  Start of processing for Overriding_Possible\n \n       begin\n-         if Chars (Iface_Prim_Op) /= Chars (Proc_Nam) then\n+         if Chars (Iface_Op) /= Chars (Wrapper) then\n             return False;\n          end if;\n \n-         --  Special check for protected procedures: If an inherited subprogram\n-         --  is implemented by a protected procedure or an entry, then the\n-         --  first parameter of the inherited subprogram shall be of mode OUT\n-         --  or IN OUT, or an access-to-variable parameter.\n-\n-         if Ekind (Iface_Prim_Op) = E_Procedure then\n+         --  If an inherited subprogram is implemented by a protected procedure\n+         --  or an entry, then the first parameter of the inherited subprogram\n+         --  shall be of mode OUT or IN OUT, or access-to-variable parameter.\n \n-            Is_Out_Present :=\n-              Present (Parameter_Specifications (Prim_Op_Spec))\n-                and then\n-              Out_Present (First (Parameter_Specifications (Prim_Op_Spec)));\n-\n-            Is_Access_To_Variable :=\n-              Present (Parameter_Specifications (Prim_Op_Spec))\n-                and then\n-              Nkind (Parameter_Type\n-                      (First\n-                        (Parameter_Specifications (Prim_Op_Spec)))) =\n-                                                          N_Access_Definition;\n+         if Ekind (Iface_Op) = E_Procedure\n+           and then Present (Parameter_Specifications (Iface_Op_Spec))\n+         then\n+            declare\n+               Obj_Param : constant Node_Id :=\n+                             First (Parameter_Specifications (Iface_Op_Spec));\n \n-            if not Is_Out_Present\n-              and then not Is_Access_To_Variable\n-            then\n-               return False;\n-            end if;\n+            begin\n+               if not Out_Present (Obj_Param)\n+                 and then Nkind (Parameter_Type (Obj_Param)) /=\n+                            N_Access_Definition\n+               then\n+                  return False;\n+               end if;\n+            end;\n          end if;\n \n-         return Type_Conformant_Parameters (\n-           Parameter_Specifications (Prim_Op_Spec),\n-           Parameter_Specifications (Proc_Spec));\n+         return\n+           Type_Conformant_Parameters (\n+             Parameter_Specifications (Iface_Op_Spec),\n+             Parameter_Specifications (Wrapper_Spec));\n       end Overriding_Possible;\n \n-      -----------------------------\n-      -- Replicate_Entry_Formals --\n-      -----------------------------\n+      -----------------------\n+      -- Replicate_Formals --\n+      -----------------------\n \n-      function Replicate_Entry_Formals\n+      function Replicate_Formals\n         (Loc     : Source_Ptr;\n          Formals : List_Id) return List_Id\n       is\n@@ -1802,6 +1891,14 @@ package body Exp_Ch9 is\n \n       begin\n          Formal := First (Formals);\n+\n+         --  Skip the object parameter when dealing with primitives declared\n+         --  between two views.\n+\n+         if Is_Private_Primitive_Subprogram (Subp_Id) then\n+            Formal := Next (Formal);\n+         end if;\n+\n          while Present (Formal) loop\n \n             --  Create an explicit copy of the entry parameter\n@@ -1835,166 +1932,228 @@ package body Exp_Ch9 is\n          end loop;\n \n          return New_Formals;\n-      end Replicate_Entry_Formals;\n+      end Replicate_Formals;\n \n    --  Start of processing for Build_Wrapper_Spec\n \n    begin\n-      --  The mode is determined by the first parameter of the interface-level\n-      --  procedure that the current entry is trying to override.\n-\n-      pragma Assert (Is_Non_Empty_List (Abstract_Interface_List (Obj_Typ)));\n-\n-      --  We must examine all the protected operations of the implemented\n-      --  interfaces in order to discover a possible overriding candidate.\n-\n-      Iface := Etype (First (Abstract_Interface_List (Obj_Typ)));\n-\n-      Examine_Parents : loop\n-         if Present (Primitive_Operations (Iface)) then\n-            Iface_Prim_Op_Elmt := First_Elmt (Primitive_Operations (Iface));\n-            while Present (Iface_Prim_Op_Elmt) loop\n-               Iface_Prim_Op := Node (Iface_Prim_Op_Elmt);\n+      --  There is no point in building wrappers for non-tagged concurrent\n+      --  types.\n \n-               if not Is_Predefined_Dispatching_Operation (Iface_Prim_Op) then\n-                  while Present (Alias (Iface_Prim_Op)) loop\n-                     Iface_Prim_Op := Alias (Iface_Prim_Op);\n-                  end loop;\n+      pragma Assert (Is_Tagged_Type (Obj_Typ));\n \n-                  --  The current primitive operation can be overridden by the\n-                  --  generated entry wrapper.\n+      --  An entry or a protected procedure can override a routine where the\n+      --  controlling formal is either IN OUT, OUT or is of access-to-variable\n+      --  type. Since the wrapper must have the exact same signature as that of\n+      --  the overridden subprogram, we try to find the overriding candidate\n+      --  and use its controlling formal.\n \n-                  if Overriding_Possible (Iface_Prim_Op, Proc_Nam) then\n-                     First_Param := First  (Parameter_Specifications\n-                                             (Parent (Iface_Prim_Op)));\n+      First_Param := Empty;\n \n-                     goto Found;\n-                  end if;\n-               end if;\n+      --  Check every implemented interface\n \n-               Next_Elmt (Iface_Prim_Op_Elmt);\n-            end loop;\n-         end if;\n-\n-         exit Examine_Parents when Etype (Iface) = Iface;\n-\n-         Iface := Etype (Iface);\n-      end loop Examine_Parents;\n-\n-      if Present (Interfaces\n-                   (Corresponding_Record_Type (Scope (Proc_Nam))))\n-      then\n-         Iface_Elmt := First_Elmt\n-                         (Interfaces\n-                           (Corresponding_Record_Type (Scope (Proc_Nam))));\n-         Examine_Interfaces : while Present (Iface_Elmt) loop\n+      if Present (Interfaces (Obj_Typ)) then\n+         Iface_Elmt := First_Elmt (Interfaces (Obj_Typ));\n+         Search : while Present (Iface_Elmt) loop\n             Iface := Node (Iface_Elmt);\n \n+            --  Check every interface primitive\n+\n             if Present (Primitive_Operations (Iface)) then\n-               Iface_Prim_Op_Elmt := First_Elmt (Primitive_Operations (Iface));\n-               while Present (Iface_Prim_Op_Elmt) loop\n-                  Iface_Prim_Op := Node (Iface_Prim_Op_Elmt);\n+               Iface_Op_Elmt := First_Elmt (Primitive_Operations (Iface));\n+               while Present (Iface_Op_Elmt) loop\n+                  Iface_Op := Node (Iface_Op_Elmt);\n \n-                  if not Is_Predefined_Dispatching_Operation\n-                           (Iface_Prim_Op)\n-                  then\n-                     while Present (Alias (Iface_Prim_Op)) loop\n-                        Iface_Prim_Op := Alias (Iface_Prim_Op);\n-                     end loop;\n+                  --  Ignore predefined primitives\n+\n+                  if not Is_Predefined_Dispatching_Operation (Iface_Op) then\n+                     Iface_Op := Ultimate_Alias (Iface_Op);\n \n                      --  The current primitive operation can be overridden by\n                      --  the generated entry wrapper.\n \n-                     if Overriding_Possible (Iface_Prim_Op, Proc_Nam) then\n-                        First_Param := First (Parameter_Specifications\n-                                               (Parent (Iface_Prim_Op)));\n+                     if Overriding_Possible (Iface_Op, Subp_Id) then\n+                        First_Param :=\n+                          First (Parameter_Specifications (Parent (Iface_Op)));\n \n-                        goto Found;\n+                        exit Search;\n                      end if;\n                   end if;\n \n-                  Next_Elmt (Iface_Prim_Op_Elmt);\n+                  Next_Elmt (Iface_Op_Elmt);\n                end loop;\n             end if;\n \n             Next_Elmt (Iface_Elmt);\n-         end loop Examine_Interfaces;\n+         end loop Search;\n+      end if;\n+\n+      --  If the subprogram to be wrapped is not overriding anything or is not\n+      --  a primitive declared between two views, do not produce anything. This\n+      --  avoids spurious errors involving overriding.\n+\n+      if No (First_Param)\n+        and then not Is_Private_Primitive_Subprogram (Subp_Id)\n+      then\n+         return Empty;\n       end if;\n \n-      --  Return if no interface primitive can be overridden\n+      declare\n+         Wrapper_Id    : constant Entity_Id :=\n+                           Make_Defining_Identifier (Loc, Chars (Subp_Id));\n+         New_Formals   : List_Id;\n+         Obj_Param     : Node_Id;\n+         Obj_Param_Typ : Entity_Id;\n+\n+      begin\n+         --  Minimum decoration is needed to catch the entity in\n+         --  Sem_Ch6.Override_Dispatching_Operation.\n \n-      return Empty;\n+         if Ekind (Subp_Id) = E_Function then\n+            Set_Ekind (Wrapper_Id, E_Function);\n+         else\n+            Set_Ekind (Wrapper_Id, E_Procedure);\n+         end if;\n \n-      <<Found>>\n+         Set_Is_Primitive_Wrapper (Wrapper_Id);\n+         Set_Wrapped_Entity       (Wrapper_Id, Subp_Id);\n+         Set_Is_Private_Primitive (Wrapper_Id,\n+           Is_Private_Primitive_Subprogram (Subp_Id));\n \n-      New_Formals := Replicate_Entry_Formals (Loc, Formals);\n+         --  Process the formals\n \n-      --  ??? Certain source packages contain protected or task types that do\n-      --  not implement any interfaces and are compiled with the -gnat05\n-      --  switch.  In this case, a default first parameter is created.\n+         New_Formals := Replicate_Formals (Loc, Formals);\n \n-      --  If the interface operation has an access parameter, create a copy\n-      --  of it, with the same null exclusion indicator if present.\n+         --  Routine Subp_Id has been found to override an interface primitive.\n+         --  If the interface operation has an access parameter, create a copy\n+         --  of it, with the same null exclusion indicator if present.\n \n-      if Present (First_Param) then\n-         if Nkind (Parameter_Type (First_Param)) = N_Access_Definition then\n-            Obj_Param_Typ :=\n-              Make_Access_Definition (Loc,\n-                Subtype_Mark =>\n-                  New_Reference_To (Obj_Typ, Loc));\n-            Set_Null_Exclusion_Present (Obj_Param_Typ,\n-               Null_Exclusion_Present (Parameter_Type (First_Param)));\n+         if Present (First_Param) then\n+            if Nkind (Parameter_Type (First_Param)) = N_Access_Definition then\n+               Obj_Param_Typ :=\n+                 Make_Access_Definition (Loc,\n+                   Subtype_Mark =>\n+                     New_Reference_To (Obj_Typ, Loc));\n+               Set_Null_Exclusion_Present (Obj_Param_Typ,\n+                 Null_Exclusion_Present (Parameter_Type (First_Param)));\n \n+            else\n+               Obj_Param_Typ := New_Reference_To (Obj_Typ, Loc);\n+            end if;\n+\n+            Obj_Param :=\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc, Name_uO),\n+                In_Present  => In_Present  (First_Param),\n+                Out_Present => Out_Present (First_Param),\n+                Parameter_Type => Obj_Param_Typ);\n+\n+         --  If we are dealing with a primitive declared between two views,\n+         --  create a default parameter.\n+\n+         else pragma Assert (Is_Private_Primitive_Subprogram (Subp_Id));\n+            Obj_Param :=\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc, Name_uO),\n+                In_Present => True,\n+                Out_Present => Ekind (Subp_Id) /= E_Function,\n+                  Parameter_Type => New_Reference_To (Obj_Typ, Loc));\n+         end if;\n+\n+         Prepend_To (New_Formals, Obj_Param);\n+\n+         --  Build the final spec\n+\n+         if Ekind (Subp_Id) = E_Function then\n+            return\n+              Make_Function_Specification (Loc,\n+                Defining_Unit_Name => Wrapper_Id,\n+                Parameter_Specifications => New_Formals,\n+                Result_Definition =>\n+                  New_Copy (Result_Definition (Parent (Subp_Id))));\n          else\n-            Obj_Param_Typ := New_Reference_To (Obj_Typ, Loc);\n+            return\n+              Make_Procedure_Specification (Loc,\n+                Defining_Unit_Name => Wrapper_Id,\n+                Parameter_Specifications => New_Formals);\n          end if;\n+      end;\n+   end Build_Wrapper_Spec;\n \n-         Obj_Param :=\n-           Make_Parameter_Specification (Loc,\n-             Defining_Identifier =>\n-               Make_Defining_Identifier (Loc, Name_uO),\n-             In_Present  => In_Present  (First_Param),\n-             Out_Present => Out_Present (First_Param),\n-             Parameter_Type => Obj_Param_Typ);\n+   -------------------------\n+   -- Build_Wrapper_Specs --\n+   -------------------------\n \n-      else\n-         Obj_Param :=\n-           Make_Parameter_Specification (Loc,\n-             Defining_Identifier =>\n-               Make_Defining_Identifier (Loc, Name_uO),\n-             In_Present  => True,\n-             Out_Present => True,\n-               Parameter_Type => New_Reference_To (Obj_Typ, Loc));\n+   procedure Build_Wrapper_Specs\n+     (Loc : Source_Ptr;\n+      Typ : Entity_Id;\n+      N   : in out Node_Id)\n+   is\n+      Def     : Node_Id;\n+      Rec_Typ : Entity_Id;\n+\n+   begin\n+      if Is_Protected_Type (Typ) then\n+         Def := Protected_Definition (Parent (Typ));\n+      else pragma Assert (Is_Task_Type (Typ));\n+         Def := Task_Definition (Parent (Typ));\n       end if;\n \n-      Prepend_To (New_Formals, Obj_Param);\n+      Rec_Typ := Corresponding_Record_Type (Typ);\n \n-      --  Minimum decoration needed to catch the entity in\n-      --  Sem_Ch6.Override_Dispatching_Operation\n+      --  Generate wrapper specs for a concurrent type which implements an\n+      --  interface and has visible entries and/or protected procedures.\n \n-      if Ekind (Proc_Nam) = E_Procedure\n-        or else Ekind (Proc_Nam) = E_Entry\n+      if Present (Interfaces (Rec_Typ))\n+        and then Present (Def)\n+        and then Present (Visible_Declarations (Def))\n       then\n-         Set_Ekind                (New_Name_Id, E_Procedure);\n-         Set_Is_Primitive_Wrapper (New_Name_Id);\n-         Set_Wrapped_Entity       (New_Name_Id, Proc_Nam);\n+         declare\n+            Decl      : Node_Id;\n+            Wrap_Decl : Node_Id;\n+            Wrap_Spec : Node_Id;\n \n-         return\n-           Make_Procedure_Specification (Loc,\n-             Defining_Unit_Name => New_Name_Id,\n-             Parameter_Specifications => New_Formals);\n+         begin\n+            Decl := First (Visible_Declarations (Def));\n+            while Present (Decl) loop\n+               Wrap_Spec := Empty;\n \n-      else pragma Assert (Ekind (Proc_Nam) = E_Function);\n-         Set_Ekind (New_Name_Id, E_Function);\n+               if Nkind (Decl) = N_Entry_Declaration\n+                 and then Ekind (Defining_Identifier (Decl)) = E_Entry\n+               then\n+                  Wrap_Spec :=\n+                    Build_Wrapper_Spec (Loc,\n+                      Subp_Id => Defining_Identifier (Decl),\n+                      Obj_Typ => Rec_Typ,\n+                      Formals => Parameter_Specifications (Decl));\n \n-         return\n-           Make_Function_Specification (Loc,\n-             Defining_Unit_Name => New_Name_Id,\n-             Parameter_Specifications => New_Formals,\n-             Result_Definition =>\n-               New_Copy (Result_Definition (Parent (Proc_Nam))));\n+               elsif Nkind (Decl) = N_Subprogram_Declaration then\n+                  Wrap_Spec :=\n+                    Build_Wrapper_Spec (Loc,\n+                      Subp_Id => Defining_Unit_Name (Specification (Decl)),\n+                      Obj_Typ => Rec_Typ,\n+                      Formals =>\n+                        Parameter_Specifications (Specification (Decl)));\n+               end if;\n+\n+               if Present (Wrap_Spec) then\n+                  Wrap_Decl :=\n+                    Make_Subprogram_Declaration (Loc,\n+                      Specification => Wrap_Spec);\n+\n+                  Insert_After (N, Wrap_Decl);\n+                  N := Wrap_Decl;\n+\n+                  Analyze (Wrap_Decl);\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+         end;\n       end if;\n-   end Build_Wrapper_Spec;\n+   end Build_Wrapper_Specs;\n \n    ---------------------------\n    -- Build_Find_Body_Index --\n@@ -6903,13 +7062,13 @@ package body Exp_Ch9 is\n    procedure Expand_N_Protected_Body (N : Node_Id) is\n       Loc          : constant Source_Ptr := Sloc (N);\n       Pid          : constant Entity_Id  := Corresponding_Spec (N);\n-      Op_Body      : Node_Id;\n-      Op_Decl      : Node_Id;\n-      Op_Id        : Entity_Id;\n+      Current_Node : Node_Id;\n       Disp_Op_Body : Node_Id;\n       New_Op_Body  : Node_Id;\n-      Current_Node : Node_Id;\n       Num_Entries  : Natural := 0;\n+      Op_Body      : Node_Id;\n+      Op_Decl      : Node_Id;\n+      Op_Id        : Entity_Id;\n \n       function Build_Dispatching_Subprogram_Body\n         (N        : Node_Id;\n@@ -7002,14 +7161,12 @@ package body Exp_Ch9 is\n          return;\n       end if;\n \n-      if Nkind (Parent (N)) = N_Subunit then\n-\n-         --  This is the proper body corresponding to a stub. The declarations\n-         --  must be inserted at the point of the stub, which is in the decla-\n-         --  rative part of the parent unit.\n+      --  This is the proper body corresponding to a stub. The declarations\n+      --  must be inserted at the point of the stub, which in turn is in the\n+      --  declarative part of the parent unit.\n \n+      if Nkind (Parent (N)) = N_Subunit then\n          Current_Node := Corresponding_Stub (Parent (N));\n-\n       else\n          Current_Node := N;\n       end if;\n@@ -7171,63 +7328,12 @@ package body Exp_Ch9 is\n          Analyze (New_Op_Body);\n       end if;\n \n-      --  Ada 2005 (AI-345): Construct the primitive entry wrapper bodies after\n-      --  the protected body. At this point the entry specs have been created,\n+      --  Ada 2005 (AI-345): Construct the primitive wrapper bodies after the\n+      --  protected body. At this point all wrapper specs have been created,\n       --  frozen and included in the dispatch table for the protected type.\n \n-      pragma Assert (Present (Corresponding_Record_Type (Pid)));\n-\n-      if Ada_Version >= Ada_05\n-        and then Present (Protected_Definition (Parent (Pid)))\n-        and then Present (Interfaces (Corresponding_Record_Type (Pid)))\n-      then\n-         declare\n-            Vis_Decl  : Node_Id :=\n-                          First (Visible_Declarations\n-                                  (Protected_Definition (Parent (Pid))));\n-            Wrap_Body : Node_Id;\n-\n-         begin\n-            --  Examine the visible declarations of the protected type, looking\n-            --  for an entry declaration. We do not consider entry families\n-            --  since they cannot have dispatching operations, thus they do not\n-            --  need entry wrappers.\n-\n-            while Present (Vis_Decl) loop\n-               if Nkind (Vis_Decl) = N_Entry_Declaration then\n-                  Wrap_Body :=\n-                    Build_Wrapper_Body (Loc,\n-                      Proc_Nam => Defining_Identifier (Vis_Decl),\n-                      Obj_Typ  => Corresponding_Record_Type (Pid),\n-                      Formals  => Parameter_Specifications (Vis_Decl));\n-\n-                  if Wrap_Body /= Empty then\n-                     Insert_After (Current_Node, Wrap_Body);\n-                     Current_Node := Wrap_Body;\n-\n-                     Analyze (Wrap_Body);\n-                  end if;\n-\n-               elsif Nkind (Vis_Decl) = N_Subprogram_Declaration then\n-                  Wrap_Body :=\n-                    Build_Wrapper_Body (Loc,\n-                      Proc_Nam => Defining_Unit_Name\n-                                        (Specification (Vis_Decl)),\n-                      Obj_Typ  => Corresponding_Record_Type (Pid),\n-                      Formals  => Parameter_Specifications\n-                                        (Specification (Vis_Decl)));\n-\n-                  if Wrap_Body /= Empty then\n-                     Insert_After (Current_Node, Wrap_Body);\n-                     Current_Node := Wrap_Body;\n-\n-                     Analyze (Wrap_Body);\n-                  end if;\n-               end if;\n-\n-               Next (Vis_Decl);\n-            end loop;\n-         end;\n+      if Ada_Version >= Ada_05 then\n+         Build_Wrapper_Bodies (Loc, Pid, Current_Node);\n       end if;\n    end Expand_N_Protected_Body;\n \n@@ -7625,67 +7731,11 @@ package body Exp_Ch9 is\n       Analyze (Rec_Decl, Suppress => All_Checks);\n \n       --  Ada 2005 (AI-345): Construct the primitive entry wrappers before\n-      --  the corresponding record is frozen\n-\n-      if Ada_Version >= Ada_05\n-        and then Present (Visible_Declarations (Pdef))\n-        and then Present (Corresponding_Record_Type\n-                           (Defining_Identifier (Parent (Pdef))))\n-        and then Present (Interfaces\n-                           (Corresponding_Record_Type\n-                             (Defining_Identifier (Parent (Pdef)))))\n-      then\n-         declare\n-            Current_Node : Node_Id := Rec_Decl;\n-            Vis_Decl     : Node_Id;\n-            Wrap_Spec    : Node_Id;\n-            New_N        : Node_Id;\n-\n-         begin\n-            --  Examine the visible declarations of the protected type, looking\n-            --  for declarations of entries, and subprograms. We do not\n-            --  consider entry families since they cannot have dispatching\n-            --  operations, thus they do not need entry wrappers.\n-\n-            Vis_Decl := First (Visible_Declarations (Pdef));\n-\n-            while Present (Vis_Decl) loop\n-\n-               Wrap_Spec := Empty;\n-\n-               if Nkind (Vis_Decl) = N_Entry_Declaration\n-                 and then No (Discrete_Subtype_Definition (Vis_Decl))\n-               then\n-                  Wrap_Spec :=\n-                    Build_Wrapper_Spec (Loc,\n-                      Proc_Nam => Defining_Identifier (Vis_Decl),\n-                      Obj_Typ  => Defining_Identifier (Rec_Decl),\n-                      Formals  => Parameter_Specifications (Vis_Decl));\n-\n-               elsif Nkind (Vis_Decl) = N_Subprogram_Declaration then\n-                  Wrap_Spec :=\n-                    Build_Wrapper_Spec (Loc,\n-                      Proc_Nam => Defining_Unit_Name\n-                                    (Specification (Vis_Decl)),\n-                      Obj_Typ  => Defining_Identifier (Rec_Decl),\n-                      Formals  => Parameter_Specifications\n-                                    (Specification (Vis_Decl)));\n-\n-               end if;\n-\n-               if Wrap_Spec /= Empty then\n-                  New_N := Make_Subprogram_Declaration (Loc,\n-                             Specification => Wrap_Spec);\n-\n-                  Insert_After (Current_Node, New_N);\n-                  Current_Node := New_N;\n-\n-                  Analyze (New_N);\n-               end if;\n+      --  the corresponding record is frozen. If any wrappers are generated,\n+      --  Current_Node is updated accordingly.\n \n-               Next (Vis_Decl);\n-            end loop;\n-         end;\n+      if Ada_Version >= Ada_05 then\n+         Build_Wrapper_Specs (Loc, Prot_Typ, Current_Node);\n       end if;\n \n       --  Collect pointers to entry bodies and their barriers, to be placed\n@@ -7694,9 +7744,7 @@ package body Exp_Ch9 is\n       --  this array. The array is declared after all protected subprograms.\n \n       if Has_Entries (Prot_Typ) then\n-         Entries_Aggr :=\n-           Make_Aggregate (Loc, Expressions => New_List);\n-\n+         Entries_Aggr := Make_Aggregate (Loc, Expressions => New_List);\n       else\n          Entries_Aggr := Empty;\n       end if;\n@@ -9461,6 +9509,9 @@ package body Exp_Ch9 is\n       Call  : Node_Id;\n       New_N : Node_Id;\n \n+      Insert_Nod : Node_Id;\n+      --  Used to determine the proper location of wrapper body insertions\n+\n    begin\n       --  Add renaming declarations for discriminals and a declaration for the\n       --  entry family index (if applicable).\n@@ -9527,56 +9578,17 @@ package body Exp_Ch9 is\n       end if;\n \n       --  Ada 2005 (AI-345): Construct the primitive entry wrapper bodies after\n-      --  the task body. At this point the entry specs have been created,\n+      --  the task body. At this point all wrapper specs have been created,\n       --  frozen and included in the dispatch table for the task type.\n \n-      pragma Assert (Present (Corresponding_Record_Type (Ttyp)));\n-\n-      if Ada_Version >= Ada_05\n-        and then Present (Task_Definition (Parent (Ttyp)))\n-        and then Present (Interfaces (Corresponding_Record_Type (Ttyp)))\n-      then\n-         declare\n-            Current_Node : Node_Id;\n-            Vis_Decl     : Node_Id :=\n-              First (Visible_Declarations (Task_Definition (Parent (Ttyp))));\n-            Wrap_Body    : Node_Id;\n-\n-         begin\n-            if Nkind (Parent (N)) = N_Subunit then\n-               Current_Node := Corresponding_Stub (Parent (N));\n-            else\n-               Current_Node := N;\n-            end if;\n-\n-            --  Examine the visible declarations of the task type, looking for\n-            --  an entry declaration. We do not consider entry families since\n-            --  they cannot have dispatching operations, thus they do not need\n-            --  entry wrappers.\n-\n-            while Present (Vis_Decl) loop\n-               if Nkind (Vis_Decl) = N_Entry_Declaration\n-                 and then Ekind (Defining_Identifier (Vis_Decl)) = E_Entry\n-               then\n-                  --  Create the specification of the wrapper\n-\n-                  Wrap_Body :=\n-                    Build_Wrapper_Body (Loc,\n-                      Proc_Nam => Defining_Identifier (Vis_Decl),\n-                      Obj_Typ  => Corresponding_Record_Type (Ttyp),\n-                      Formals  => Parameter_Specifications (Vis_Decl));\n-\n-                  if Wrap_Body /= Empty then\n-                     Insert_After (Current_Node, Wrap_Body);\n-                     Current_Node := Wrap_Body;\n-\n-                     Analyze (Wrap_Body);\n-                  end if;\n-               end if;\n+      if Ada_Version >= Ada_05 then\n+         if Nkind (Parent (N)) = N_Subunit then\n+            Insert_Nod := Corresponding_Stub (Parent (N));\n+         else\n+            Insert_Nod := N;\n+         end if;\n \n-               Next (Vis_Decl);\n-            end loop;\n-         end;\n+         Build_Wrapper_Bodies (Loc, Ttyp, Insert_Nod);\n       end if;\n    end Expand_N_Task_Body;\n \n@@ -10025,51 +10037,8 @@ package body Exp_Ch9 is\n       --  Ada 2005 (AI-345): Construct the primitive entry wrapper specs before\n       --  the corresponding record has been frozen.\n \n-      if Ada_Version >= Ada_05\n-        and then Present (Taskdef)\n-        and then Present (Corresponding_Record_Type\n-                           (Defining_Identifier (Parent (Taskdef))))\n-        and then Present (Interfaces\n-                           (Corresponding_Record_Type\n-                             (Defining_Identifier (Parent (Taskdef)))))\n-      then\n-         declare\n-            Current_Node : Node_Id := Rec_Decl;\n-            Vis_Decl     : Node_Id := First (Visible_Declarations (Taskdef));\n-            Wrap_Spec    : Node_Id;\n-            New_N        : Node_Id;\n-\n-         begin\n-            --  Examine the visible declarations of the task type, looking for\n-            --  an entry declaration. We do not consider entry families since\n-            --  they cannot have dispatching operations, thus they do not need\n-            --  entry wrappers.\n-\n-            while Present (Vis_Decl) loop\n-               if Nkind (Vis_Decl) = N_Entry_Declaration\n-                 and then Ekind (Defining_Identifier (Vis_Decl)) = E_Entry\n-               then\n-                  Wrap_Spec :=\n-                    Build_Wrapper_Spec (Loc,\n-                      Proc_Nam => Defining_Identifier (Vis_Decl),\n-                      Obj_Typ  => Etype (Rec_Ent),\n-                      Formals  => Parameter_Specifications (Vis_Decl));\n-\n-                  if Wrap_Spec /= Empty then\n-                     New_N :=\n-                       Make_Subprogram_Declaration (Loc,\n-                         Specification => Wrap_Spec);\n-\n-                     Insert_After (Current_Node, New_N);\n-                     Current_Node := New_N;\n-\n-                     Analyze (New_N);\n-                  end if;\n-               end if;\n-\n-               Next (Vis_Decl);\n-            end loop;\n-         end;\n+      if Ada_Version >= Ada_05 then\n+         Build_Wrapper_Specs (Loc, Tasktyp, Rec_Decl);\n       end if;\n \n       --  Ada 2005 (AI-345): We must defer freezing to allow further\n@@ -11408,6 +11377,17 @@ package body Exp_Ch9 is\n             or else Denotes_Discriminant (Hi, True));\n    end Is_Potentially_Large_Family;\n \n+   -------------------------------------\n+   -- Is_Private_Primitive_Subprogram --\n+   -------------------------------------\n+\n+   function Is_Private_Primitive_Subprogram (Id : Entity_Id) return Boolean is\n+   begin\n+      return\n+        (Ekind (Id) = E_Function or else Ekind (Id) = E_Procedure)\n+           and then Is_Private_Primitive (Id);\n+   end Is_Private_Primitive_Subprogram;\n+\n    ------------------\n    -- Index_Object --\n    ------------------"}, {"sha": "1cfa74d3635e06c6f4c3263fa7489c172f620aba", "filename": "gcc/ada/exp_ch9.ads", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d44202ba07e54a1d61bebb53abc6133139e75e7d/gcc%2Fada%2Fexp_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d44202ba07e54a1d61bebb53abc6133139e75e7d/gcc%2Fada%2Fexp_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.ads?ref=d44202ba07e54a1d61bebb53abc6133139e75e7d", "patch": "@@ -153,6 +153,18 @@ package Exp_Ch9 is\n    --  aggregate. It replaces the call to Init (Args) done by\n    --  Build_Task_Allocate_Block.\n \n+   function Build_Wrapper_Spec\n+     (Loc     : Source_Ptr;\n+      Subp_Id : Entity_Id;\n+      Obj_Typ : Entity_Id;\n+      Formals : List_Id) return Node_Id;\n+   --  Ada 2005 (AI-345): Build the specification of a primitive operation\n+   --  associated with a protected or task type. This is required to implement\n+   --  dispatching calls through interfaces. Subp_Id is the primitive to be\n+   --  wrapped, Obj_Typ is the type of the newly added formal parameter to\n+   --  handle object notation, Formals are the original entry formals that\n+   --  will be explicitly replicated.\n+\n    function Concurrent_Ref (N : Node_Id) return Node_Id;\n    --  Given the name of a concurrent object (task or protected object), or\n    --  the name of an access to a concurrent object, this function returns an"}, {"sha": "f67d34d60f8d7ff5173739870d01c75a057948f1", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 99, "deletions": 30, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d44202ba07e54a1d61bebb53abc6133139e75e7d/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d44202ba07e54a1d61bebb53abc6133139e75e7d/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d44202ba07e54a1d61bebb53abc6133139e75e7d", "patch": "@@ -31,6 +31,7 @@ with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Eval_Fat; use Eval_Fat;\n with Exp_Ch3;  use Exp_Ch3;\n+with Exp_Ch9;  use Exp_Ch9;\n with Exp_Disp; use Exp_Disp;\n with Exp_Dist; use Exp_Dist;\n with Exp_Tss;  use Exp_Tss;\n@@ -15811,48 +15812,117 @@ package body Sem_Ch3 is\n       --  If the private view was tagged, copy the new primitive operations\n       --  from the private view to the full view.\n \n-      --  Note: Subprograms covering interface primitives were previously\n-      --  propagated to the full view by Derive_Progenitor_Primitives\n-\n-      if Is_Tagged_Type (Full_T)\n-        and then not Is_Concurrent_Type (Full_T)\n-      then\n+      if Is_Tagged_Type (Full_T) then\n          declare\n-            Priv_List : Elist_Id;\n-            Full_List : constant Elist_Id := Primitive_Operations (Full_T);\n-            P1, P2    : Elmt_Id;\n+            Disp_Typ  : Entity_Id;\n+            Full_List : Elist_Id;\n             Prim      : Entity_Id;\n-            D_Type    : Entity_Id;\n+            Prim_Elmt : Elmt_Id;\n+            Priv_List : Elist_Id;\n+\n+            function Contains\n+              (E : Entity_Id;\n+               L : Elist_Id) return Boolean;\n+            --  Determine whether list L contains element E\n+\n+            --------------\n+            -- Contains --\n+            --------------\n+\n+            function Contains\n+              (E : Entity_Id;\n+               L : Elist_Id) return Boolean\n+            is\n+               List_Elmt : Elmt_Id;\n+\n+            begin\n+               List_Elmt := First_Elmt (L);\n+               while Present (List_Elmt) loop\n+                  if Node (List_Elmt) = E then\n+                     return True;\n+                  end if;\n+\n+                  Next_Elmt (List_Elmt);\n+               end loop;\n+\n+               return False;\n+            end Contains;\n+\n+         --  Start of processing\n \n          begin\n             if Is_Tagged_Type (Priv_T) then\n                Priv_List := Primitive_Operations (Priv_T);\n+               Prim_Elmt := First_Elmt (Priv_List);\n+\n+               --  In the case of a concurrent type completing a private tagged\n+               --  type, primivies may have been declared in between the two\n+               --  views. These subprograms need to be wrapped the same way\n+               --  entries and protected procedures are handled because they\n+               --  cannot be directly shared by the two views.\n+\n+               if Is_Concurrent_Type (Full_T) then\n+                  declare\n+                     Conc_Typ  : constant Entity_Id :=\n+                                   Corresponding_Record_Type (Full_T);\n+                     Loc       : constant Source_Ptr := Sloc (Conc_Typ);\n+                     Curr_Nod  : Node_Id := Parent (Conc_Typ);\n+                     Wrap_Spec : Node_Id;\n \n-               P1 := First_Elmt (Priv_List);\n-               while Present (P1) loop\n-                  Prim := Node (P1);\n+                  begin\n+                     while Present (Prim_Elmt) loop\n+                        Prim := Node (Prim_Elmt);\n \n-                  --  Transfer explicit primitives, not those inherited from\n-                  --  parent of partial view, which will be re-inherited on\n-                  --  the full view.\n+                        if Comes_From_Source (Prim)\n+                          and then not Is_Abstract_Subprogram (Prim)\n+                        then\n+                           Wrap_Spec :=\n+                             Make_Subprogram_Declaration (Loc,\n+                               Specification =>\n+                                 Build_Wrapper_Spec (Loc,\n+                                   Subp_Id => Prim,\n+                                   Obj_Typ => Conc_Typ,\n+                                   Formals =>\n+                                     Parameter_Specifications (\n+                                       Parent (Prim))));\n+\n+                           Insert_After (Curr_Nod, Wrap_Spec);\n+                           Curr_Nod := Wrap_Spec;\n+\n+                           Analyze (Wrap_Spec);\n+                        end if;\n \n-                  if Comes_From_Source (Prim) then\n-                     P2 := First_Elmt (Full_List);\n-                     while Present (P2) and then Node (P2) /= Prim loop\n-                        Next_Elmt (P2);\n+                        Next_Elmt (Prim_Elmt);\n                      end loop;\n \n-                     --  If not found, that is a new one\n+                     return;\n+                  end;\n+\n+               --  For non-concurrent types, transfer explicit primitives, but\n+               --  omit those inherited from the parent of the private view\n+               --  since they will be re-inherited later on.\n+\n+               else\n+                  Full_List := Primitive_Operations (Full_T);\n+\n+                  while Present (Prim_Elmt) loop\n+                     Prim := Node (Prim_Elmt);\n \n-                     if No (P2) then\n+                     if Comes_From_Source (Prim)\n+                       and then not Contains (Prim, Full_List)\n+                     then\n                         Append_Elmt (Prim, Full_List);\n                      end if;\n-                  end if;\n \n-                  Next_Elmt (P1);\n-               end loop;\n+                     Next_Elmt (Prim_Elmt);\n+                  end loop;\n+               end if;\n+\n+            --  Untagged private view\n \n             else\n+               Full_List := Primitive_Operations (Full_T);\n+\n                --  In this case the partial view is untagged, so here we locate\n                --  all of the earlier primitives that need to be treated as\n                --  dispatching (those that appear between the two views). Note\n@@ -15871,10 +15941,9 @@ package body Sem_Ch3 is\n                        or else\n                      Ekind (Prim) = E_Function\n                   then\n+                     Disp_Typ := Find_Dispatching_Type (Prim);\n \n-                     D_Type := Find_Dispatching_Type (Prim);\n-\n-                     if D_Type = Full_T\n+                     if Disp_Typ = Full_T\n                        and then (Chars (Prim) /= Name_Op_Ne\n                                   or else Comes_From_Source (Prim))\n                      then\n@@ -15887,13 +15956,13 @@ package body Sem_Ch3 is\n                         end if;\n \n                      elsif Is_Dispatching_Operation (Prim)\n-                       and then D_Type  /= Full_T\n+                       and then Disp_Typ  /= Full_T\n                      then\n \n                         --  Verify that it is not otherwise controlled by a\n                         --  formal or a return value of type T.\n \n-                        Check_Controlling_Formals (D_Type, Prim);\n+                        Check_Controlling_Formals (Disp_Typ, Prim);\n                      end if;\n                   end if;\n "}, {"sha": "04413a19602461c3e7149759481be7f057cbd8b7", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 189, "deletions": 26, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d44202ba07e54a1d61bebb53abc6133139e75e7d/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d44202ba07e54a1d61bebb53abc6133139e75e7d/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=d44202ba07e54a1d61bebb53abc6133139e75e7d", "patch": "@@ -1306,6 +1306,17 @@ package body Sem_Ch6 is\n       --  If pragma does not appear after the body, check whether there is\n       --  an inline pragma before any local declarations.\n \n+      function Disambiguate_Spec return Entity_Id;\n+      --  When a primitive is declared between the private view and the full\n+      --  view of a concurrent type which implements an interface, a special\n+      --  mechanism is used to find the corresponding spec of the primitive\n+      --  body.\n+\n+      function Is_Private_Concurrent_Primitive\n+        (Subp_Id : Entity_Id) return Boolean;\n+      --  Determine whether subprogram Subp_Id is a primitive of a concurrent\n+      --  type that implements an interface and has a private view.\n+\n       procedure Set_Trivial_Subprogram (N : Node_Id);\n       --  Sets the Is_Trivial_Subprogram flag in both spec and body of the\n       --  subprogram whose body is being analyzed. N is the statement node\n@@ -1457,6 +1468,128 @@ package body Sem_Ch6 is\n          end if;\n       end Check_Inline_Pragma;\n \n+      -----------------------\n+      -- Disambiguate_Spec --\n+      -----------------------\n+\n+      function Disambiguate_Spec return Entity_Id is\n+         Priv_Spec : Entity_Id;\n+         Spec_N    : Entity_Id;\n+\n+         procedure Replace_Types (To_Corresponding : Boolean);\n+         --  Depending on the flag, replace the type of formal parameters of\n+         --  Body_Id if it is a concurrent type implementing interfaces with\n+         --  the corresponding record type or the other way around.\n+\n+         procedure Replace_Types (To_Corresponding : Boolean) is\n+            Formal     : Entity_Id;\n+            Formal_Typ : Entity_Id;\n+\n+         begin\n+            Formal := First_Formal (Body_Id);\n+            while Present (Formal) loop\n+               Formal_Typ := Etype (Formal);\n+\n+               --  From concurrent type to corresponding record\n+\n+               if To_Corresponding then\n+                  if Is_Concurrent_Type (Formal_Typ)\n+                    and then Present (Corresponding_Record_Type (Formal_Typ))\n+                    and then Present (Interfaces (\n+                               Corresponding_Record_Type (Formal_Typ)))\n+                  then\n+                     Set_Etype (Formal,\n+                       Corresponding_Record_Type (Formal_Typ));\n+                  end if;\n+\n+               --  From corresponding record to concurrent type\n+\n+               else\n+                  if Is_Concurrent_Record_Type (Formal_Typ)\n+                    and then Present (Interfaces (Formal_Typ))\n+                  then\n+                     Set_Etype (Formal,\n+                       Corresponding_Concurrent_Type (Formal_Typ));\n+                  end if;\n+               end if;\n+\n+               Next_Formal (Formal);\n+            end loop;\n+         end Replace_Types;\n+\n+      --  Start of processing for Disambiguate_Spec\n+\n+      begin\n+         --  Try to retrieve the specification of the body as is. All error\n+         --  messages are suppressed because the body may not have a spec in\n+         --  its current state.\n+\n+         Spec_N := Find_Corresponding_Spec (N, False);\n+\n+         --  It is possible that this is the body of a primitive declared\n+         --  between a private and a full view of a concurrent type. The\n+         --  controlling parameter of the spec carries the concurrent type,\n+         --  not the corresponding record type as transformed by Analyze_\n+         --  Subprogram_Specification. In such cases, we undo the change\n+         --  made by the analysis of the specification and try to find the\n+         --  spec again.\n+\n+         if No (Spec_N) then\n+\n+            --  Restore all references of corresponding record types to the\n+            --  original concurrent types.\n+\n+            Replace_Types (To_Corresponding => False);\n+            Priv_Spec := Find_Corresponding_Spec (N, False);\n+\n+            --  The current body truly belongs to a primitive declared between\n+            --  a private and a full view. We leave the modified body as is,\n+            --  and return the true spec.\n+\n+            if Present (Priv_Spec)\n+              and then Is_Private_Primitive (Priv_Spec)\n+            then\n+               return Priv_Spec;\n+            end if;\n+\n+            --  In case that this is some sort of error, restore the original\n+            --  state of the body.\n+\n+            Replace_Types (To_Corresponding => True);\n+         end if;\n+\n+         return Spec_N;\n+      end Disambiguate_Spec;\n+\n+      -------------------------------------\n+      -- Is_Private_Concurrent_Primitive --\n+      -------------------------------------\n+\n+      function Is_Private_Concurrent_Primitive\n+        (Subp_Id : Entity_Id) return Boolean\n+      is\n+         Formal_Typ : Entity_Id;\n+\n+      begin\n+         if Present (First_Formal (Subp_Id)) then\n+            Formal_Typ := Etype (First_Formal (Subp_Id));\n+\n+            if Is_Concurrent_Record_Type (Formal_Typ) then\n+               Formal_Typ := Corresponding_Concurrent_Type (Formal_Typ);\n+            end if;\n+\n+            --  The type of the first formal is a concurrent tagged type with\n+            --  a private view.\n+\n+            return\n+              Is_Concurrent_Type (Formal_Typ)\n+                and then Is_Tagged_Type (Formal_Typ)\n+                and then Has_Private_Declaration (Formal_Typ);\n+         end if;\n+\n+         return False;\n+      end Is_Private_Concurrent_Primitive;\n+\n       ----------------------------\n       -- Set_Trivial_Subprogram --\n       ----------------------------\n@@ -1581,7 +1714,11 @@ package body Sem_Ch6 is\n          if Nkind (N) = N_Subprogram_Body_Stub\n            or else No (Corresponding_Spec (N))\n          then\n-            Spec_Id := Find_Corresponding_Spec (N);\n+            if Is_Private_Concurrent_Primitive (Body_Id) then\n+               Spec_Id := Disambiguate_Spec;\n+            else\n+               Spec_Id := Find_Corresponding_Spec (N);\n+            end if;\n \n             --  If this is a duplicate body, no point in analyzing it\n \n@@ -2322,6 +2459,22 @@ package body Sem_Ch6 is\n       New_Overloaded_Entity (Designator);\n       Check_Delayed_Subprogram (Designator);\n \n+      --  If the type of the first formal of the current subprogram is a non\n+      --  generic tagged private type , mark the subprogram as being a private\n+      --  primitive.\n+\n+      if Present (First_Formal (Designator)) then\n+         declare\n+            Formal_Typ : constant Entity_Id :=\n+                           Etype (First_Formal (Designator));\n+         begin\n+            Set_Is_Private_Primitive (Designator,\n+              Is_Tagged_Type (Formal_Typ)\n+                and then Is_Private_Type (Formal_Typ)\n+                and then not Is_Generic_Actual_Type (Formal_Typ));\n+         end;\n+      end if;\n+\n       --  Ada 2005 (AI-251): Abstract interface primitives must be abstract\n       --  or null.\n \n@@ -2435,8 +2588,6 @@ package body Sem_Ch6 is\n    function Analyze_Subprogram_Specification (N : Node_Id) return Entity_Id is\n       Designator : constant Entity_Id := Defining_Entity (N);\n       Formals    : constant List_Id   := Parameter_Specifications (N);\n-      Formal     : Entity_Id;\n-      Formal_Typ : Entity_Id;\n \n    --  Start of processing for Analyze_Subprogram_Specification\n \n@@ -2466,21 +2617,29 @@ package body Sem_Ch6 is\n          --  record, to match the proper signature of an overriding operation.\n \n          if Ada_Version >= Ada_05 then\n-            Formal := First_Formal (Designator);\n-            while Present (Formal) loop\n-               Formal_Typ := Etype (Formal);\n+            declare\n+               Formal     : Entity_Id;\n+               Formal_Typ : Entity_Id;\n+               Rec_Typ    : Entity_Id;\n \n-               if Is_Concurrent_Type (Formal_Typ)\n-                 and then Present (Corresponding_Record_Type (Formal_Typ))\n-                 and then Present (Interfaces\n-                                    (Corresponding_Record_Type (Formal_Typ)))\n-               then\n-                  Set_Etype (Formal,\n-                    Corresponding_Record_Type (Formal_Typ));\n-               end if;\n+            begin\n+               Formal := First_Formal (Designator);\n+               while Present (Formal) loop\n+                  Formal_Typ := Etype (Formal);\n \n-               Formal := Next_Formal (Formal);\n-            end loop;\n+                  if Is_Concurrent_Type (Formal_Typ)\n+                    and then Present (Corresponding_Record_Type (Formal_Typ))\n+                  then\n+                     Rec_Typ := Corresponding_Record_Type (Formal_Typ);\n+\n+                     if Present (Interfaces (Rec_Typ)) then\n+                        Set_Etype (Formal, Rec_Typ);\n+                     end if;\n+                  end if;\n+\n+                  Next_Formal (Formal);\n+               end loop;\n+            end;\n          end if;\n \n          End_Scope;\n@@ -5161,7 +5320,10 @@ package body Sem_Ch6 is\n    -- Find_Corresponding_Spec --\n    -----------------------------\n \n-   function Find_Corresponding_Spec (N : Node_Id) return Entity_Id is\n+   function Find_Corresponding_Spec\n+     (N          : Node_Id;\n+      Post_Error : Boolean := True) return Entity_Id\n+   is\n       Spec       : constant Node_Id   := Specification (N);\n       Designator : constant Entity_Id := Defining_Entity (Spec);\n \n@@ -5205,7 +5367,6 @@ package body Sem_Ch6 is\n                end if;\n \n                if not Has_Completion (E) then\n-\n                   if Nkind (N) /= N_Subprogram_Body_Stub then\n                      Set_Corresponding_Spec (N, E);\n                   end if;\n@@ -5250,14 +5411,15 @@ package body Sem_Ch6 is\n                      return Empty;\n                   end if;\n \n-               --  If body already exists, this is an error unless the\n-               --  previous declaration is the implicit declaration of\n-               --  a derived subprogram, or this is a spurious overloading\n-               --  in an instance.\n+               --  If the body already exists, then this is an error unless\n+               --  the previous declaration is the implicit declaration of a\n+               --  derived subprogram, or this is a spurious overloading in an\n+               --  instance.\n \n                elsif No (Alias (E))\n                  and then not Is_Intrinsic_Subprogram (E)\n                  and then not In_Instance\n+                 and then Post_Error\n                then\n                   Error_Msg_Sloc := Sloc (E);\n                   if Is_Imported (E) then\n@@ -5269,16 +5431,17 @@ package body Sem_Ch6 is\n                   end if;\n                end if;\n \n+            --  Child units cannot be overloaded, so a conformance mismatch\n+            --  between body and a previous spec is an error.\n+\n             elsif Is_Child_Unit (E)\n               and then\n                 Nkind (Unit_Declaration_Node (Designator)) = N_Subprogram_Body\n               and then\n                 Nkind (Parent (Unit_Declaration_Node (Designator))) =\n-                                                             N_Compilation_Unit\n+                  N_Compilation_Unit\n+              and then Post_Error\n             then\n-               --  Child units cannot be overloaded, so a conformance mismatch\n-               --  between body and a previous spec is an error.\n-\n                Error_Msg_N\n                  (\"body of child unit does not match previous declaration\", N);\n             end if;"}, {"sha": "e54c1e1117c1892a0d79d9b89fcb539e03a4f357", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d44202ba07e54a1d61bebb53abc6133139e75e7d/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d44202ba07e54a1d61bebb53abc6133139e75e7d/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=d44202ba07e54a1d61bebb53abc6133139e75e7d", "patch": "@@ -136,8 +136,8 @@ package Sem_Ch6 is\n       Get_Inst : Boolean := False) return Boolean;\n    --  Check that the types of two formal parameters are conforming. In most\n    --  cases this is just a name comparison, but within an instance it involves\n-   --  generic actual types, and in the presence of anonymous access types\n-   --  it must examine the designated types.\n+   --  generic actual types, and in the presence of anonymous access types it\n+   --  must examine the designated types.\n \n    procedure Create_Extra_Formals (E : Entity_Id);\n    --  For each parameter of a subprogram or entry that requires an additional\n@@ -147,7 +147,9 @@ package Sem_Ch6 is\n    --  the end of Subp's parameter list (with each subsequent extra formal\n    --  being attached to the preceding extra formal).\n \n-   function Find_Corresponding_Spec (N : Node_Id) return Entity_Id;\n+   function Find_Corresponding_Spec\n+     (N          : Node_Id;\n+      Post_Error : Boolean := True) return Entity_Id;\n    --  Use the subprogram specification in the body to retrieve the previous\n    --  subprogram declaration, if any.\n "}]}