{"sha": "61da01772a3dff61cf23ba2ffba33bccb68d1063", "node_id": "C_kwDOANBUbNoAKDYxZGEwMTc3MmEzZGZmNjFjZjIzYmEyZmZiYTMzYmNjYjY4ZDEwNjM", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2023-01-06T18:39:14Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2023-01-06T20:56:43Z"}, "message": "libstdc++: Refactor time_zone::_Impl::rules_counter [PR108235]\n\nAbstract the atomic counter used to synchronize access to time_zone\ninfos behind a Lockable class API, and use atomic_signed_lock_free\ninstead of atomic<int_least32_t>, as that should be the most efficient\ntype. (For futex-supporting targets it makes no difference, but might\nbenefit other targets in future.)\n\nThe new API allows the calling code to be simpler, without needing to\nrepeat the same error prone preprocessor conditions in multiple places.\nIt also allows using template metaprogramming to decide whether to use\nthe atomic or a mutex, which gives us more flexibility than only using\npreprocessor conditions. That allows us to choose the mutex\nimplementation for targets such as hppa-hp-hpux11.11 where 32-bit\natomics are not lock-free and so would introduce an unwanted dependency\non libatomic.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/108235\n\t* src/c++20/tzdb.cc (time_zone::_Impl::RulesCounter): New class\n\ttemplate and partial specialization for synchronizing access to\n\ttime_zone::_Impl::infos.\n\t(time_zone::_M_get_sys_info, reload_tzdb): Adjust uses of\n\trules_counter.", "tree": {"sha": "fe41530662b6fea6c1819485c2bc3663f126961a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe41530662b6fea6c1819485c2bc3663f126961a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61da01772a3dff61cf23ba2ffba33bccb68d1063", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61da01772a3dff61cf23ba2ffba33bccb68d1063", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61da01772a3dff61cf23ba2ffba33bccb68d1063", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61da01772a3dff61cf23ba2ffba33bccb68d1063/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b68fb47bd24abc2e6a65e5617f586d1c1b81d4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b68fb47bd24abc2e6a65e5617f586d1c1b81d4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b68fb47bd24abc2e6a65e5617f586d1c1b81d4e"}], "stats": {"total": 137, "additions": 84, "deletions": 53}, "files": [{"sha": "fa4f4c7a30c03f44694fd330d9aff17e490c9ed3", "filename": "libstdc++-v3/src/c++20/tzdb.cc", "status": "modified", "additions": 84, "deletions": 53, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61da01772a3dff61cf23ba2ffba33bccb68d1063/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2Ftzdb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61da01772a3dff61cf23ba2ffba33bccb68d1063/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2Ftzdb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2Ftzdb.cc?ref=61da01772a3dff61cf23ba2ffba33bccb68d1063", "patch": "@@ -29,7 +29,7 @@\n #include <fstream>    // ifstream\n #include <sstream>    // istringstream\n #include <algorithm>  // ranges::upper_bound, ranges::lower_bound, ranges::sort\n-#include <atomic>     // atomic<T*>, atomic<int_least32_t>\n+#include <atomic>     // atomic<T*>, atomic<int>\n #include <memory>     // atomic<shared_ptr<T>>\n #include <mutex>      // mutex\n #include <filesystem> // filesystem::read_symlink\n@@ -598,13 +598,86 @@ namespace std::chrono\n     // Needed to access the list of rules for the time zones.\n     weak_ptr<tzdb_list::_Node> node;\n \n-#ifndef __GTHREADS\n-    // Don't need synchronization for accessing the infos vector.\n-#elif __cpp_lib_atomic_wait\n-    atomic<int_least32_t> rules_counter;\n-#else\n-    mutex infos_mutex;\n+    // In the simple case, we don't actual keep count. No concurrent access\n+    // to the infos vector is possible, even if all infos are expanded.\n+    template<typename _Tp>\n+      struct RulesCounter\n+      {\n+\t// Called for each rule-based ZoneInfo added to the infos vector.\n+\t// Called when the time_zone::_Impl is created, so no concurrent calls.\n+\tvoid increment() { }\n+\t// Called when a rule-based ZoneInfo is expanded.\n+\t// The caller must have called lock() for exclusive access to infos.\n+\tvoid decrement() { }\n+\n+\t// Use a mutex to synchronize all access to the infos vector.\n+\tmutex infos_mutex;\n+\n+\tvoid lock() { infos_mutex.lock(); }\n+\tvoid unlock() { infos_mutex.unlock(); }\n+      };\n+\n+#if defined __GTHREADS && __cpp_lib_atomic_wait\n+    // Atomic count of unexpanded ZoneInfo objects in the infos vector.\n+    // Concurrent access is allowed when all objects have been expanded.\n+    // Only use an atomic counter if it would not require libatomic,\n+    // because we don't want libstdc++.so to depend on libatomic.\n+    template<typename _Tp> requires _Tp::is_always_lock_free\n+      struct RulesCounter<_Tp>\n+      {\n+\tatomic_signed_lock_free counter{0};\n+\n+\tvoid\n+\tincrement()\n+\t{ counter.fetch_add(1, memory_order::relaxed); }\n+\n+\tvoid\n+\tdecrement()\n+\t{\n+\t  // The current thread holds the lock, so the counter is negative\n+\t  // and so we need to increment it to decrement it!\n+\t  // If the count reaches zero then there are no more unexpanded infos,\n+\t  // so notify all waiting threads that they can access the infos.\n+\t  // We must do this here, because unlock() is a no-op if counter==0.\n+\t  if (++counter == 0)\n+\t    counter.notify_all();\n+\t}\n+\n+\tvoid\n+\tlock()\n+\t{\n+\t  // If counter is zero then concurrent access is allowed, so lock()\n+\t  // and unlock() are no-ops and multiple threads can \"lock\" at once.\n+\t  // If counter is non-zero then the contents of the infos vector might\n+\t  // need to be changed, so only one thread is allowed to access it.\n+\t  for (auto c = counter.load(memory_order::relaxed); c != 0;)\n+\t    {\n+\t      // Setting counter to negative means this thread has the lock.\n+\t      if (c > 0 && counter.compare_exchange_strong(c, -c))\n+\t\treturn;\n+\n+\t      if (c < 0)\n+\t\t{\n+\t\t  // Counter is negative, another thread already has the lock.\n+\t\t  counter.wait(c);\n+\t\t  c = counter.load();\n+\t\t}\n+\t    }\n+\t}\n+\n+\tvoid\n+\tunlock()\n+\t{\n+\t  if (auto c = counter.load(memory_order::relaxed); c < 0)\n+\t  {\n+\t    counter.store(-c, memory_order::release);\n+\t    counter.notify_one();\n+\t  }\n+\t}\n+      };\n #endif\n+\n+    RulesCounter<atomic_signed_lock_free> rules_counter;\n   };\n \n   namespace\n@@ -666,46 +739,8 @@ namespace std::chrono\n     const auto node = _M_impl->node.lock();\n     auto& infos = _M_impl->infos;\n \n-#ifndef __GTHREADS\n-#elif __cpp_lib_atomic_wait\n     // Prevent concurrent access to _M_impl->infos if it might need to change.\n-    struct Lock\n-    {\n-      Lock(atomic<int_least32_t>& counter) : counter(counter)\n-      {\n-\t// If counter is non-zero then the contents of _M_impl->info might\n-\t// need to be changed, so only one thread is allowed to access it.\n-\tfor (auto c = counter.load(memory_order::relaxed); c != 0;)\n-\t  {\n-\t    // Setting counter to negative means this thread has the lock.\n-\t    if (c > 0 && counter.compare_exchange_strong(c, -c))\n-\t      return;\n-\n-\t    if (c < 0)\n-\t      {\n-\t\t// Counter is negative, another thread already has the lock.\n-\t\tcounter.wait(c);\n-\t\tc = counter.load();\n-\t      }\n-\t  }\n-      }\n-\n-      ~Lock()\n-      {\n-\tif (auto c = counter.load(memory_order::relaxed); c < 0)\n-\t  {\n-\t    counter.store(-c, memory_order::release);\n-\t    counter.notify_one();\n-\t  }\n-      }\n-\n-      atomic<int_least32_t>& counter;\n-    };\n-    Lock lock{_M_impl->rules_counter};\n-#else\n-    // Keep it simple, just use a mutex for all access.\n-    lock_guard<mutex> lock(_M_impl->infos_mutex);\n-#endif\n+    lock_guard lock(_M_impl->rules_counter);\n \n     // Find the transition info for the time point.\n     auto i = ranges::upper_bound(infos, tp, ranges::less{}, &ZoneInfo::until);\n@@ -894,10 +929,8 @@ namespace std::chrono\n \tstd::rotate(infos.begin() + result_index + 1, i, infos.end());\n \t// Then replace the original rules_info object with new_infos.front():\n \tinfos[result_index] = ZoneInfo(new_infos.front());\n-#if defined __GTHREADS && __cpp_lib_atomic_wait\n-\tif (++_M_impl->rules_counter == 0) // No more unexpanded infos.\n-\t  _M_impl->rules_counter.notify_all();\n-#endif\n+\t// Decrement count of rule-based infos (might also release lock).\n+\t_M_impl->rules_counter.decrement();\n       }\n \n     return info;\n@@ -1339,11 +1372,9 @@ namespace std::chrono\n \t\tZoneInfo& info = impl.infos.emplace_back();\n \t\tis >> info;\n \n-#if defined __GTHREADS && __cpp_lib_atomic_wait\n \t\t// Keep count of ZoneInfo objects that refer to named Rules.\n \t\tif (!info.rules().empty())\n-\t\t    impl.rules_counter.fetch_add(1, memory_order::relaxed);\n-#endif\n+\t\t  impl.rules_counter.increment();\n \t      }\n \t    }\n \t  }"}]}