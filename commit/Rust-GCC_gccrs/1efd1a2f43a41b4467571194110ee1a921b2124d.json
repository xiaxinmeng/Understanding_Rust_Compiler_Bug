{"sha": "1efd1a2f43a41b4467571194110ee1a921b2124d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVmZDFhMmY0M2E0MWI0NDY3NTcxMTk0MTEwZWUxYTkyMWIyMTI0ZA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-03-22T18:37:16Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-03-22T18:37:16Z"}, "message": "re PR fortran/31193 ([4.2 only] ICE on non-constant character tranfert)\n\n2006-03-22  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31193\n\t* trans-intrinsic.c (gfc_size_in_bytes): Remove function.\n\t(gfc_conv_intrinsic_array_transfer): Remove calls to previous.\n\tExplicitly extract TREE_TYPEs for source and mold.  Use these\n\tto calculate length of source and mold, except for characters,\n\twhere the se string_length is used.  For mold, the TREE_TYPE is\n\trecalculated using gfc_get_character_type_len so that the\n\tresult is correctly cast for character literals and substrings.\n\tDo not use gfc_typenode_for_spec for the final cast.\n\n2006-03-22  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31193\n\t* gfortran.dg/transfer_array_intrinsic_3.f90: New test.\n\nFrom-SVN: r123131", "tree": {"sha": "c581df9acdcd56fb46d26e938987f567e36afb1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c581df9acdcd56fb46d26e938987f567e36afb1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1efd1a2f43a41b4467571194110ee1a921b2124d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1efd1a2f43a41b4467571194110ee1a921b2124d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1efd1a2f43a41b4467571194110ee1a921b2124d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1efd1a2f43a41b4467571194110ee1a921b2124d/comments", "author": null, "committer": null, "parents": [{"sha": "803f183a9464aeba39bc369c2d39ca3b9a986e78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/803f183a9464aeba39bc369c2d39ca3b9a986e78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/803f183a9464aeba39bc369c2d39ca3b9a986e78"}], "stats": {"total": 125, "additions": 88, "deletions": 37}, "files": [{"sha": "4e366aa0274f6f5719c91c886536805d36c18fd0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1efd1a2f43a41b4467571194110ee1a921b2124d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1efd1a2f43a41b4467571194110ee1a921b2124d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1efd1a2f43a41b4467571194110ee1a921b2124d", "patch": "@@ -1,3 +1,15 @@\n+2006-03-22  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31193\n+\t* trans-intrinsic.c (gfc_size_in_bytes): Remove function.\n+\t(gfc_conv_intrinsic_array_transfer): Remove calls to previous.\n+\tExplicitly extract TREE_TYPEs for source and mold.  Use these\n+\tto calculate length of source and mold, except for characters,\n+\twhere the se string_length is used.  For mold, the TREE_TYPE is\n+\trecalculated using gfc_get_character_type_len so that the\n+\tresult is correctly cast for character literals and substrings.\n+\tDo not use gfc_typenode_for_spec for the final cast.\n+\n 2007-03-22  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n \n \tPR fortran/20897"}, {"sha": "4465030ab5ef1fd14849e31cde92fc20fad61891", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1efd1a2f43a41b4467571194110ee1a921b2124d/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1efd1a2f43a41b4467571194110ee1a921b2124d/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=1efd1a2f43a41b4467571194110ee1a921b2124d", "patch": "@@ -2790,30 +2790,6 @@ gfc_conv_intrinsic_adjust (gfc_se * se, gfc_expr * expr, tree fndecl)\n }\n \n \n-/* A helper function for gfc_conv_intrinsic_array_transfer to compute\n-   the size of tree expressions in bytes.  */\n-static tree\n-gfc_size_in_bytes (gfc_se *se, gfc_expr *e)\n-{\n-  tree tmp;\n-\n-  if (e->ts.type == BT_CHARACTER)\n-    tmp = se->string_length;\n-  else\n-    {\n-      if (e->rank)\n-\t{\n-\t  tmp = gfc_get_element_type (TREE_TYPE (se->expr));\n-\t  tmp = size_in_bytes (tmp);\n-\t}\n-      else\n-\ttmp = size_in_bytes (TREE_TYPE (TREE_TYPE (se->expr)));\n-    }\n-\n-  return fold_convert (gfc_array_index_type, tmp);\n-}\n-\n-\n /* Array transfer statement.\n      DEST(1:N) = TRANSFER (SOURCE, MOLD[, SIZE])\n    where:\n@@ -2828,7 +2804,9 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n   tree tmp;\n   tree extent;\n   tree source;\n+  tree source_type;\n   tree source_bytes;\n+  tree mold_type;\n   tree dest_word_len;\n   tree size_words;\n   tree size_bytes;\n@@ -2861,15 +2839,22 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n       gfc_conv_expr_reference (&argse, arg->expr);\n       source = argse.expr;\n \n+      source_type = TREE_TYPE (build_fold_indirect_ref (argse.expr));\n+\n       /* Obtain the source word length.  */\n-      tmp = gfc_size_in_bytes (&argse, arg->expr);\n+      if (arg->expr->ts.type == BT_CHARACTER)\n+\ttmp = fold_convert (gfc_array_index_type, argse.string_length);\n+      else\n+\ttmp = fold_convert (gfc_array_index_type,\n+\t\t\t    size_in_bytes (source_type)); \n     }\n   else\n     {\n       gfc_init_se (&argse, NULL);\n       argse.want_pointer = 0;\n       gfc_conv_expr_descriptor (&argse, arg->expr, ss);\n       source = gfc_conv_descriptor_data_get (argse.expr);\n+      source_type = gfc_get_element_type (TREE_TYPE (argse.expr));\n \n       /* Repack the source if not a full variable array.  */\n       if (!(arg->expr->expr_type == EXPR_VARIABLE\n@@ -2898,7 +2883,11 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n \t}\n \n       /* Obtain the source word length.  */\n-      tmp = gfc_size_in_bytes (&argse, arg->expr);\n+      if (arg->expr->ts.type == BT_CHARACTER)\n+\ttmp = fold_convert (gfc_array_index_type, argse.string_length);\n+      else\n+\ttmp = fold_convert (gfc_array_index_type,\n+\t\t\t    size_in_bytes (source_type)); \n \n       /* Obtain the size of the array in bytes.  */\n       extent = gfc_create_var (gfc_array_index_type, NULL);\n@@ -2924,7 +2913,8 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n   gfc_add_block_to_block (&se->pre, &argse.pre);\n   gfc_add_block_to_block (&se->post, &argse.post);\n \n-  /* Now convert MOLD.  The sole output is:\n+  /* Now convert MOLD.  The outputs are:\n+\tmold_type = the TREE type of MOLD\n \tdest_word_len = destination word length in bytes.  */\n   arg = arg->next;\n \n@@ -2934,20 +2924,25 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n   if (ss == gfc_ss_terminator)\n     {\n       gfc_conv_expr_reference (&argse, arg->expr);\n-\n-      /* Obtain the source word length.  */\n-      tmp = gfc_size_in_bytes (&argse, arg->expr);\n+      mold_type = TREE_TYPE (build_fold_indirect_ref (argse.expr));\n     }\n   else\n     {\n       gfc_init_se (&argse, NULL);\n       argse.want_pointer = 0;\n       gfc_conv_expr_descriptor (&argse, arg->expr, ss);\n-\n-      /* Obtain the source word length.  */\n-      tmp = gfc_size_in_bytes (&argse, arg->expr);\n+      mold_type = gfc_get_element_type (TREE_TYPE (argse.expr));\n     }\n \n+  if (arg->expr->ts.type == BT_CHARACTER)\n+    {\n+      tmp = fold_convert (gfc_array_index_type, argse.string_length);\n+      mold_type = gfc_get_character_type_len (arg->expr->ts.kind, tmp);\n+    }\n+  else\n+    tmp = fold_convert (gfc_array_index_type,\n+\t\t\tsize_in_bytes (mold_type)); \n+ \n   dest_word_len = gfc_create_var (gfc_array_index_type, NULL);\n   gfc_add_modify_expr (&se->pre, dest_word_len, tmp);\n \n@@ -3016,15 +3011,18 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n   /* Build a destination descriptor, using the pointer, source, as the\n      data field.  This is already allocated so set callee_alloc.\n      FIXME callee_alloc is not set!  */\n- \n-  tmp = gfc_typenode_for_spec (&expr->ts);\n+\n   gfc_trans_create_temp_array (&se->pre, &se->post, se->loop,\n-\t\t\t       info, tmp, false, true, false);\n+\t\t\t       info, mold_type, false, true, false);\n+\n+  /* Cast the pointer to the result.  */\n+  tmp = gfc_conv_descriptor_data_get (info->descriptor);\n+  tmp = fold_convert (pvoid_type_node, tmp);\n \n   /* Use memcpy to do the transfer.  */\n   tmp = build_call_expr (built_in_decls[BUILT_IN_MEMCPY],\n \t\t\t 3,\n-\t\t\t gfc_conv_descriptor_data_get (info->descriptor),\n+\t\t\t tmp,\n \t\t\t fold_convert (pvoid_type_node, source),\n \t\t\t size_bytes);\n   gfc_add_expr_to_block (&se->pre, tmp);"}, {"sha": "6f551d028dc88d3d41ef875cfbbab269ec001c0e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1efd1a2f43a41b4467571194110ee1a921b2124d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1efd1a2f43a41b4467571194110ee1a921b2124d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1efd1a2f43a41b4467571194110ee1a921b2124d", "patch": "@@ -1,3 +1,8 @@\n+2006-03-22  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31193\n+\t* gfortran.dg/transfer_array_intrinsic_3.f90: New test.\n+\n 2007-03-22  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n \n \tPR fortran/20897"}, {"sha": "b97e840a468b5e14557354adb7446f825019bb07", "filename": "gcc/testsuite/gfortran.dg/transfer_array_intrinsic_3.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1efd1a2f43a41b4467571194110ee1a921b2124d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_array_intrinsic_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1efd1a2f43a41b4467571194110ee1a921b2124d/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_array_intrinsic_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_array_intrinsic_3.f90?ref=1efd1a2f43a41b4467571194110ee1a921b2124d", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do run }\r\n+! Tests fix for PR31193, in which the character length for MOLD in\r\n+! case 1 below was not being translated correctly for character\r\n+! constants and an ICE ensued.  The further cases are either checks\r\n+! or new bugs that were found in the course of development cases 3 & 5.\r\n+!\r\n+! Contributed by Brooks Moses <brooks@gcc.gnu.org>\r\n+!\r\n+function NumOccurances (string, chr, isel) result(n)\r\n+  character(*),intent(in) :: string\r\n+  character(1),intent(in) :: chr\r\n+  integer :: isel\r\n+!\r\n+! return number of occurances of character in given string\r\n+!\r\n+    select case (isel)\r\n+      case (1)\r\n+      n=count(transfer(string, char(1), len(string))==chr)\r\n+      case (2)\r\n+      n=count(transfer(string, chr, len(string))==chr)\r\n+      case (3)\r\n+      n=count(transfer(string, \"a\", len(string))==chr)\r\n+      case (4)\r\n+      n=count(transfer(string, (/\"a\",\"b\"/), len(string))==chr)\r\n+      case (5)\r\n+      n=count(transfer(string, string(1:1), len(string))==chr)\r\n+    end select\r\n+  return\r\n+end\r\n+\r\n+  if (NumOccurances(\"abacadae\", \"a\", 1) .ne. 4) call abort ()\r\n+  if (NumOccurances(\"abacadae\", \"a\", 2) .ne. 4) call abort ()\r\n+  if (NumOccurances(\"abacadae\", \"a\", 3) .ne. 4) call abort ()\r\n+  if (NumOccurances(\"abacadae\", \"a\", 4) .ne. 4) call abort ()\r\n+  if (NumOccurances(\"abacadae\", \"a\", 5) .ne. 4) call abort ()\r\n+end\r"}]}