{"sha": "db22a743fc777137c3d26fba9642dee8eab97eab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIyMmE3NDNmYzc3NzEzN2MzZDI2ZmJhOTY0MmRlZThlYWI5N2VhYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-01-07T23:35:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-01-07T23:35:08Z"}, "message": "re PR tree-optimization/51680 (g++ 4.7 fails to inline trivial template stuff)\n\n\n\tPR tree-optimization/51680\n\t* ipa-inline.c (want_inline_small_function_p): Be more lax on functions\n\twhose inlining reduce unit size.\n\nFrom-SVN: r182983", "tree": {"sha": "5a2cf1b3029c089f24f53c39f669d1c5d9579e03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a2cf1b3029c089f24f53c39f669d1c5d9579e03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db22a743fc777137c3d26fba9642dee8eab97eab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db22a743fc777137c3d26fba9642dee8eab97eab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db22a743fc777137c3d26fba9642dee8eab97eab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db22a743fc777137c3d26fba9642dee8eab97eab/comments", "author": null, "committer": null, "parents": [{"sha": "faead9f73f57ebd6bbdad81b33656e81d35af654", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faead9f73f57ebd6bbdad81b33656e81d35af654", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faead9f73f57ebd6bbdad81b33656e81d35af654"}], "stats": {"total": 75, "additions": 44, "deletions": 31}, "files": [{"sha": "cbe134f88330fd0abdbf6d2f828754fd2816b1af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db22a743fc777137c3d26fba9642dee8eab97eab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db22a743fc777137c3d26fba9642dee8eab97eab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db22a743fc777137c3d26fba9642dee8eab97eab", "patch": "@@ -1,3 +1,9 @@\n+2012-01-07  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimization/51680\n+\t* ipa-inline.c (want_inline_small_function_p): Be more lax on functions\n+\twhose inlining reduce unit size.\n+\n 2012-01-07  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR bootstrap/51725"}, {"sha": "b5c1db0932b797227d32601b2be28f529555b47f", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 38, "deletions": 31, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db22a743fc777137c3d26fba9642dee8eab97eab/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db22a743fc777137c3d26fba9642dee8eab97eab/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=db22a743fc777137c3d26fba9642dee8eab97eab", "patch": "@@ -482,6 +482,42 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n           e->inline_failed = CIF_MAX_INLINE_INSNS_SINGLE_LIMIT;\n \t  want_inline = false;\n \t}\n+      /* Before giving up based on fact that caller size will grow, allow\n+         functions that are called few times and eliminating the offline\n+\t copy will lead to overall code size reduction.\n+\t Not all of these will be handled by subsequent inlining of functions\n+\t called once: in particular weak functions are not handled or funcitons\n+\t that inline to multiple calls but a lot of bodies is optimized out.\n+\t Finally we want to inline earlier to allow inlining of callbacks.\n+\n+\t This is slightly wrong on aggressive side:  it is entirely possible\n+\t that function is called many times with a context where inlining\n+\t reduces code size and few times with a context where inlining increase\n+\t code size.  Resoluting growth estimate will be negative even if it\n+\t would make more sense to keep offline copy and do not inline into the\n+\t call sites that makes the code size grow.  \n+\n+\t When badness orders the calls in a way that code reducing calls come\n+\t first, this situation is not a problem at all: after inlining all\n+\t \"good\" calls, we will realize that keeping the function around is\n+\t better.  */\n+      else if (growth <= MAX_INLINE_INSNS_SINGLE\n+\t       /* Unlike for functions called once, we play unsafe with\n+\t\t  COMDATs.  We can allow that since we know functions\n+\t\t  in consideration are small (and thus risk is small) and\n+\t\t  moreover grow estimates already accounts that COMDAT\n+\t\t  functions may or may not disappear when eliminated from\n+\t\t  current unit. With good probability making aggressive\n+\t\t  choice in all units is going to make overall program\n+\t\t  smaller.\n+\n+\t\t  Consequently we ask cgraph_can_remove_if_no_direct_calls_p\n+\t\t  instead of\n+\t\t  cgraph_will_be_removed_from_program_if_no_direct_calls  */\n+\t        && !DECL_EXTERNAL (callee->decl)\n+\t\t&& cgraph_can_remove_if_no_direct_calls_p (callee)\n+\t\t&& estimate_growth (callee) <= 0)\n+\t;\n       else if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t       && !flag_inline_functions)\n \t{\n@@ -494,39 +530,10 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n           e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n \t  want_inline = false;\n \t}\n-      /* If call is cold, do not inline when function body would grow.\n-\t Still inline when the overall unit size will shrink because the offline\n-\t copy of function being eliminated.\n+      /* If call is cold, do not inline when function body would grow. */\n+      else if (!cgraph_maybe_hot_edge_p (e))\n \n-\t This is slightly wrong on aggressive side:  it is entirely possible\n-\t that function is called many times with a context where inlining\n-\t reduces code size and few times with a context where inlining increase\n-\t code size.  Resoluting growth estimate will be negative even if it\n-\t would make more sense to keep offline copy and do not inline into the\n-\t call sites that makes the code size grow.  \n \n-\t When badness orders the calls in a way that code reducing calls come\n-\t first, this situation is not a problem at all: after inlining all\n-\t \"good\" calls, we will realize that keeping the function around is\n-\t better.  */\n-      else if (!cgraph_maybe_hot_edge_p (e)\n-\t       && (DECL_EXTERNAL (callee->decl)\n-\n-\t\t   /* Unlike for functions called once, we play unsafe with\n-\t\t      COMDATs.  We can allow that since we know functions\n-\t\t      in consideration are small (and thus risk is small) and\n-\t\t      moreover grow estimates already accounts that COMDAT\n-\t\t      functions may or may not disappear when eliminated from\n-\t\t      current unit. With good probability making aggressive\n-\t\t      choice in all units is going to make overall program\n-\t\t      smaller.\n-\n-\t\t      Consequently we ask cgraph_can_remove_if_no_direct_calls_p\n-\t\t      instead of\n-\t\t      cgraph_will_be_removed_from_program_if_no_direct_calls  */\n-\n-\t\t   || !cgraph_can_remove_if_no_direct_calls_p (callee)\n-\t\t   || estimate_growth (callee) > 0))\n \t{\n           e->inline_failed = CIF_UNLIKELY_CALL;\n \t  want_inline = false;"}]}