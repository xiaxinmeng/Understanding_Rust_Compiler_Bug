{"sha": "575eb8f58b06657c9cadfe6f7ddfd9e530fe5dea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc1ZWI4ZjU4YjA2NjU3YzljYWRmZTZmN2RkZmQ5ZTUzMGZlNWRlYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-01-07T20:12:39Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-01-07T20:12:39Z"}, "message": "runtime: in getTraceback, set gp->m before gogo\n    \n    Currently, when collecting a traceback for another goroutine,\n    getTraceback calls gogo(gp) switching to gp, which will resume in\n    mcall, which will call gtraceback, which will set up gp->m. There\n    is a gap between setting the current running g to gp and setting\n    gp->m. If a profiling signal arrives in between, sigtramp will\n    see a non-nil gp with a nil m, and will seg fault. Fix this by\n    setting up gp->m first.\n    \n    Fixes golang/go#29448.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/156038\n\nFrom-SVN: r267658", "tree": {"sha": "ce0dcd8fecef8174761dfaa26962f241b47d9606", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce0dcd8fecef8174761dfaa26962f241b47d9606"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/575eb8f58b06657c9cadfe6f7ddfd9e530fe5dea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/575eb8f58b06657c9cadfe6f7ddfd9e530fe5dea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/575eb8f58b06657c9cadfe6f7ddfd9e530fe5dea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/575eb8f58b06657c9cadfe6f7ddfd9e530fe5dea/comments", "author": null, "committer": null, "parents": [{"sha": "419af57c134f3b068530ea51179c220e52623067", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/419af57c134f3b068530ea51179c220e52623067", "html_url": "https://github.com/Rust-GCC/gccrs/commit/419af57c134f3b068530ea51179c220e52623067"}], "stats": {"total": 50, "additions": 43, "deletions": 7}, "files": [{"sha": "d6fe5f6afb969fb478311d436d849f37e98b0d10", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575eb8f58b06657c9cadfe6f7ddfd9e530fe5dea/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575eb8f58b06657c9cadfe6f7ddfd9e530fe5dea/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=575eb8f58b06657c9cadfe6f7ddfd9e530fe5dea", "patch": "@@ -1,4 +1,4 @@\n-2ce291eaee427799bfcde256929dab89e0ab61eb\n+c257303eaef143663216e483857d5b259e05753f\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "fd05a049b5a11bf020e03a28cb43ca4e854df4de", "filename": "libgo/go/runtime/pprof/pprof_test.go", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575eb8f58b06657c9cadfe6f7ddfd9e530fe5dea/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575eb8f58b06657c9cadfe6f7ddfd9e530fe5dea/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go?ref=575eb8f58b06657c9cadfe6f7ddfd9e530fe5dea", "patch": "@@ -946,3 +946,38 @@ func TestAtomicLoadStore64(t *testing.T) {\n \tatomic.StoreUint64(&flag, 1)\n \t<-done\n }\n+\n+func TestTracebackAll(t *testing.T) {\n+\t// With gccgo, if a profiling signal arrives at the wrong time\n+\t// during traceback, it may crash or hang. See issue #29448.\n+\tf, err := ioutil.TempFile(\"\", \"proftraceback\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"TempFile: %v\", err)\n+\t}\n+\tdefer os.Remove(f.Name())\n+\tdefer f.Close()\n+\n+\tif err := StartCPUProfile(f); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer StopCPUProfile()\n+\n+\tch := make(chan int)\n+\tdefer close(ch)\n+\n+\tcount := 10\n+\tfor i := 0; i < count; i++ {\n+\t\tgo func() {\n+\t\t\t<-ch // block\n+\t\t}()\n+\t}\n+\n+\tN := 10000\n+\tif testing.Short() {\n+\t\tN = 500\n+\t}\n+\tbuf := make([]byte, 10*1024)\n+\tfor i := 0; i < N; i++ {\n+\t\truntime.Stack(buf, true)\n+\t}\n+}"}, {"sha": "4004df48612d6e1f5f4e12fac161b7855e54326b", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/575eb8f58b06657c9cadfe6f7ddfd9e530fe5dea/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/575eb8f58b06657c9cadfe6f7ddfd9e530fe5dea/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=575eb8f58b06657c9cadfe6f7ddfd9e530fe5dea", "patch": "@@ -442,6 +442,11 @@ void getTraceback(G*, G*) __asm__(GOSYM_PREFIX \"runtime.getTraceback\");\n // goroutine stored in the traceback field, which is me.\n void getTraceback(G* me, G* gp)\n {\n+\tM* holdm;\n+\n+\tholdm = gp->m;\n+\tgp->m = me->m;\n+\n #ifdef USING_SPLIT_STACK\n \t__splitstack_getcontext((void*)(&me->stackcontext[0]));\n #endif\n@@ -450,6 +455,8 @@ void getTraceback(G* me, G* gp)\n \tif (gp->traceback != 0) {\n \t\truntime_gogo(gp);\n \t}\n+\n+\tgp->m = holdm;\n }\n \n // Do a stack trace of gp, and then restore the context to\n@@ -459,17 +466,11 @@ void\n gtraceback(G* gp)\n {\n \tTraceback* traceback;\n-\tM* holdm;\n \n \ttraceback = (Traceback*)gp->traceback;\n \tgp->traceback = 0;\n-\tholdm = gp->m;\n-\tif(holdm != nil && holdm != g->m)\n-\t\truntime_throw(\"gtraceback: m is not nil\");\n-\tgp->m = traceback->gp->m;\n \ttraceback->c = runtime_callers(1, traceback->locbuf,\n \t\tsizeof traceback->locbuf / sizeof traceback->locbuf[0], false);\n-\tgp->m = holdm;\n \truntime_gogo(traceback->gp);\n }\n "}]}