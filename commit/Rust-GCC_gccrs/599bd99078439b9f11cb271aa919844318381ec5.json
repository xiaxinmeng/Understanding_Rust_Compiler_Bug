{"sha": "599bd99078439b9f11cb271aa919844318381ec5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk5YmQ5OTA3ODQzOWI5ZjExY2IyNzFhYTkxOTg0NDMxODM4MWVjNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-11T19:43:52Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-11T19:43:52Z"}, "message": "Fix SLP downward group access classification (PR92420)\n\nThis PR was caused by the SLP handling in get_group_load_store_type\nreturning VMAT_CONTIGUOUS rather than VMAT_CONTIGUOUS_REVERSE for\ndownward groups.\n\nA more elaborate fix would be to try to combine the reverse permutation\ninto SLP_TREE_LOAD_PERMUTATION for loads, but that's really a follow-on\noptimisation and not backport material.  It might also not necessarily\nbe a win, if the target supports (say) reversing and odd/even swaps\nas independent permutes but doesn't recognise the combined form.\n\n2019-11-11  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\tPR tree-optimization/92420\n\t* tree-vect-stmts.c (get_negative_load_store_type): Move further\n\tup file.\n\t(get_group_load_store_type): Use it for reversed SLP accesses.\n\ngcc/testsuite/\n\t* gcc.dg/vect/pr92420.c: New test.\n\nFrom-SVN: r278064", "tree": {"sha": "43e915fe087ef94d41149983ad0b8fba1b8547ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43e915fe087ef94d41149983ad0b8fba1b8547ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/599bd99078439b9f11cb271aa919844318381ec5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/599bd99078439b9f11cb271aa919844318381ec5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/599bd99078439b9f11cb271aa919844318381ec5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/599bd99078439b9f11cb271aa919844318381ec5/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "98aad294705ac35aec058e020867d736d841dad0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98aad294705ac35aec058e020867d736d841dad0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98aad294705ac35aec058e020867d736d841dad0"}], "stats": {"total": 169, "additions": 118, "deletions": 51}, "files": [{"sha": "329d107a765a1480ca6abea71f55c2d6aa7d38a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599bd99078439b9f11cb271aa919844318381ec5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599bd99078439b9f11cb271aa919844318381ec5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=599bd99078439b9f11cb271aa919844318381ec5", "patch": "@@ -1,3 +1,10 @@\n+2019-11-11  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/92420\n+\t* tree-vect-stmts.c (get_negative_load_store_type): Move further\n+\tup file.\n+\t(get_group_load_store_type): Use it for reversed SLP accesses.\n+\n 2019-11-11  Jan Hubicka  <hubcika@ucw.cz>\n \n \t* ipa-prop.c (ipa_propagate_indirect_call_infos): Remove ipcp"}, {"sha": "88088fafe6b8583ef05e3ac3a22f1de384a5fcde", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599bd99078439b9f11cb271aa919844318381ec5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599bd99078439b9f11cb271aa919844318381ec5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=599bd99078439b9f11cb271aa919844318381ec5", "patch": "@@ -1,3 +1,7 @@\n+2019-11-11  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/vect/pr92420.c: New test.\n+\n 2019-11-11  Claudiu Zissulescu <claziss@gmail.com>\n \n \t* gcc.target/arc/delay-slot-limm.c: New test."}, {"sha": "e43539fbbd7202b3ae2e9f71bfd82a3fcdf8bde3", "filename": "gcc/testsuite/gcc.dg/vect/pr92420.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599bd99078439b9f11cb271aa919844318381ec5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr92420.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599bd99078439b9f11cb271aa919844318381ec5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr92420.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr92420.c?ref=599bd99078439b9f11cb271aa919844318381ec5", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-additional-options \"-mavx2\" { target avx_runtime } } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+struct C { int r, i; };\n+struct C a[N], b[N], c[N], d[N], e[N];\n+\n+__attribute__((noipa)) static void\n+foo (struct C *__restrict x, struct C *__restrict y, struct C *__restrict z, int w)\n+{\n+  int i;\n+  for (int i = 0; i < w; i++)\n+    {\n+      z[i].r = x[i].r * y[-1 - i].r - x[i].i * y[-1 - i].i;\n+      z[i].i = x[i].i * y[-1 - i].r + x[i].r * y[-1 - i].i;\n+    }\n+}\n+\n+__attribute__((noipa)) static void\n+bar (struct C *__restrict x, struct C *__restrict y, struct C *__restrict z, int w)\n+{\n+  int i;\n+  for (int i = 0; i < w; i++)\n+    {\n+      z[i].r = x[i].r * y[i].r - x[i].i * y[i].i;\n+      z[i].i = x[i].i * y[i].r + x[i].r * y[i].i;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  check_vect ();\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    {\n+      a[i].r = N - i; a[i].i = i - N;\n+      b[i].r = i - N; b[i].i = i + N;\n+      c[i].r = -1 - i; c[i].i = 2 * N - 1 - i;\n+    }\n+  foo (a, b + N, d, N);\n+  bar (a, c, e, N);\n+  for (i = 0; i < N; ++i)\n+    if (d[i].r != e[i].r || d[i].i != e[i].i)\n+      __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "1da949a7070294ca43c623fcd2916180f8a7e28f", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 59, "deletions": 51, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599bd99078439b9f11cb271aa919844318381ec5/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599bd99078439b9f11cb271aa919844318381ec5/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=599bd99078439b9f11cb271aa919844318381ec5", "patch": "@@ -2147,6 +2147,56 @@ perm_mask_for_reverse (tree vectype)\n   return vect_gen_perm_mask_checked (vectype, indices);\n }\n \n+/* A subroutine of get_load_store_type, with a subset of the same\n+   arguments.  Handle the case where STMT_INFO is a load or store that\n+   accesses consecutive elements with a negative step.  */\n+\n+static vect_memory_access_type\n+get_negative_load_store_type (stmt_vec_info stmt_info, tree vectype,\n+\t\t\t      vec_load_store_type vls_type,\n+\t\t\t      unsigned int ncopies)\n+{\n+  dr_vec_info *dr_info = STMT_VINFO_DR_INFO (stmt_info);\n+  dr_alignment_support alignment_support_scheme;\n+\n+  if (ncopies > 1)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"multiple types with negative step.\\n\");\n+      return VMAT_ELEMENTWISE;\n+    }\n+\n+  alignment_support_scheme = vect_supportable_dr_alignment (dr_info, false);\n+  if (alignment_support_scheme != dr_aligned\n+      && alignment_support_scheme != dr_unaligned_supported)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"negative step but alignment required.\\n\");\n+      return VMAT_ELEMENTWISE;\n+    }\n+\n+  if (vls_type == VLS_STORE_INVARIANT)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"negative step with invariant source;\"\n+\t\t\t \" no permute needed.\\n\");\n+      return VMAT_CONTIGUOUS_DOWN;\n+    }\n+\n+  if (!perm_mask_for_reverse (vectype))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"negative step and reversing not supported.\\n\");\n+      return VMAT_ELEMENTWISE;\n+    }\n+\n+  return VMAT_CONTIGUOUS_REVERSE;\n+}\n+\n /* STMT_INFO is either a masked or unconditional store.  Return the value\n    being stored.  */\n \n@@ -2273,7 +2323,15 @@ get_group_load_store_type (stmt_vec_info stmt_info, tree vectype, bool slp,\n \t\t\t\t \"Peeling for outer loop is not supported\\n\");\n \t      return false;\n \t    }\n-\t  *memory_access_type = VMAT_CONTIGUOUS;\n+\t  int cmp = compare_step_with_zero (stmt_info);\n+\t  if (cmp < 0)\n+\t    *memory_access_type = get_negative_load_store_type\n+\t      (stmt_info, vectype, vls_type, 1);\n+\t  else\n+\t    {\n+\t      gcc_assert (!loop_vinfo || cmp > 0);\n+\t      *memory_access_type = VMAT_CONTIGUOUS;\n+\t    }\n \t}\n     }\n   else\n@@ -2375,56 +2433,6 @@ get_group_load_store_type (stmt_vec_info stmt_info, tree vectype, bool slp,\n   return true;\n }\n \n-/* A subroutine of get_load_store_type, with a subset of the same\n-   arguments.  Handle the case where STMT_INFO is a load or store that\n-   accesses consecutive elements with a negative step.  */\n-\n-static vect_memory_access_type\n-get_negative_load_store_type (stmt_vec_info stmt_info, tree vectype,\n-\t\t\t      vec_load_store_type vls_type,\n-\t\t\t      unsigned int ncopies)\n-{\n-  dr_vec_info *dr_info = STMT_VINFO_DR_INFO (stmt_info);\n-  dr_alignment_support alignment_support_scheme;\n-\n-  if (ncopies > 1)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"multiple types with negative step.\\n\");\n-      return VMAT_ELEMENTWISE;\n-    }\n-\n-  alignment_support_scheme = vect_supportable_dr_alignment (dr_info, false);\n-  if (alignment_support_scheme != dr_aligned\n-      && alignment_support_scheme != dr_unaligned_supported)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"negative step but alignment required.\\n\");\n-      return VMAT_ELEMENTWISE;\n-    }\n-\n-  if (vls_type == VLS_STORE_INVARIANT)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"negative step with invariant source;\"\n-\t\t\t \" no permute needed.\\n\");\n-      return VMAT_CONTIGUOUS_DOWN;\n-    }\n-\n-  if (!perm_mask_for_reverse (vectype))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"negative step and reversing not supported.\\n\");\n-      return VMAT_ELEMENTWISE;\n-    }\n-\n-  return VMAT_CONTIGUOUS_REVERSE;\n-}\n-\n /* Analyze load or store statement STMT_INFO of type VLS_TYPE.  Return true\n    if there is a memory access type that the vectorized form can use,\n    storing it in *MEMORY_ACCESS_TYPE if so.  If we decide to use gathers"}]}