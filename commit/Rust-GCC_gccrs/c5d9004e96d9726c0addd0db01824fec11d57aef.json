{"sha": "c5d9004e96d9726c0addd0db01824fec11d57aef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVkOTAwNGU5NmQ5NzI2YzBhZGRkMGRiMDE4MjRmZWMxMWQ1N2FlZg==", "commit": {"author": {"name": "Bruce Korb", "email": "bkorb@gnu.org", "date": "2000-07-11T15:51:18Z"}, "committer": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "2000-07-11T15:51:18Z"}, "message": "Remove obsolete fix tests\n\nFrom-SVN: r34960", "tree": {"sha": "e8afe144d4e3609c18470ce6d6ad6e151a228e7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8afe144d4e3609c18470ce6d6ad6e151a228e7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5d9004e96d9726c0addd0db01824fec11d57aef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5d9004e96d9726c0addd0db01824fec11d57aef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5d9004e96d9726c0addd0db01824fec11d57aef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5d9004e96d9726c0addd0db01824fec11d57aef/comments", "author": {"login": "brkorb", "id": 1242936, "node_id": "MDQ6VXNlcjEyNDI5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1242936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brkorb", "html_url": "https://github.com/brkorb", "followers_url": "https://api.github.com/users/brkorb/followers", "following_url": "https://api.github.com/users/brkorb/following{/other_user}", "gists_url": "https://api.github.com/users/brkorb/gists{/gist_id}", "starred_url": "https://api.github.com/users/brkorb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brkorb/subscriptions", "organizations_url": "https://api.github.com/users/brkorb/orgs", "repos_url": "https://api.github.com/users/brkorb/repos", "events_url": "https://api.github.com/users/brkorb/events{/privacy}", "received_events_url": "https://api.github.com/users/brkorb/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b449f23a14fde7c4adc1117ac0a18efc5824b7bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b449f23a14fde7c4adc1117ac0a18efc5824b7bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b449f23a14fde7c4adc1117ac0a18efc5824b7bc"}], "stats": {"total": 208, "additions": 5, "deletions": 203}, "files": [{"sha": "b1c92f92c2b78ce6e4bfe2b875e708e6f8e2d183", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d9004e96d9726c0addd0db01824fec11d57aef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d9004e96d9726c0addd0db01824fec11d57aef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5d9004e96d9726c0addd0db01824fec11d57aef", "patch": "@@ -1,3 +1,8 @@\n+2000-07-11  Bruce Korb  <bkorb@gnu.org>\n+\n+\t* fixinc/fixtests.c(double_slash): obsolete\n+\t(else_endif_label): likewise\n+\n 2000-07-11  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* cpplex.c (T, I, S, C, N): Avoid non-constant initializers."}, {"sha": "36dd6553b14e09539fbe795c6a3fc38a3054a3f8", "filename": "gcc/fixinc/fixtests.c", "status": "modified", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d9004e96d9726c0addd0db01824fec11d57aef/gcc%2Ffixinc%2Ffixtests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d9004e96d9726c0addd0db01824fec11d57aef/gcc%2Ffixinc%2Ffixtests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixtests.c?ref=c5d9004e96d9726c0addd0db01824fec11d57aef", "patch": "@@ -56,8 +56,6 @@ typedef struct {\n } test_entry_t;\n \n #define FIX_TEST_TABLE \\\n-  _FT_( \"double_slash\",     double_slash_test ) \\\n-  _FT_( \"else_endif_label\", else_endif_label_test ) \\\n   _FT_( \"machine_name\",     machine_name_test )\n \n \n@@ -66,207 +64,6 @@ static apply_fix_p_t test ( fname, text ) \\\n     tCC* fname; \\\n     tCC* text;\n \n-/*\n- *  Skip over a quoted string.  Single quote strings may\n- *  contain multiple characters if the first character is\n- *  a backslash.  Especially a backslash followed by octal digits.\n- *  We are not doing a correctness syntax check here.\n- */\n-static tCC*\n-skip_quote( q, text )\n-  char  q;\n-  char* text;\n-{\n-  for (;;)\n-    {\n-      char ch = *(text++);\n-      switch (ch)\n-        {\n-        case '\\\\':\n-          text++; /* skip over whatever character follows */\n-          break;\n-\n-        case '\"':\n-        case '\\'':\n-          if (ch != q)\n-            break;\n-          /*FALLTHROUGH*/\n-\n-        case '\\n':\n-        case NUL:\n-          goto skip_done;\n-        }\n-    } skip_done:;\n-\n-  return text;\n-}\n-\n-\n-TEST_FOR_FIX_PROC_HEAD( double_slash_test )\n-{\n-  if (is_cxx_header (fname, text))\n-    return SKIP_FIX;\n-\n-  /*  Now look for the comment markers in the text */\n-  for (;;)\n-    {\n-      char ch = *(text++);\n-      switch (ch)\n-        {\n-        case '/':\n-          switch (*text) /* do not advance `text' here */\n-            {\n-            case '/':\n-              /*\n-                We found a \"//\" pair in open text.\n-                The fix must be applied\n-              */\n-              return APPLY_FIX;\n-\n-            case '*':\n-              /* We found a C-style comment.  Skip forward to the end */\n-              text = strstr( text+1, \"*/\" );\n-              if (text == (char*)NULL)\n-                goto test_done;\n-              text += 2;\n-            }\n-          break;\n-\n-        case NUL:\n-          goto test_done;\n-\n-        case '\"':\n-        case '\\'':\n-          text = skip_quote( ch, text );\n-        }\n-\n-    } test_done:;\n-\n-  return SKIP_FIX;\n-}\n-\n-\n-TEST_FOR_FIX_PROC_HEAD( else_endif_label_test )\n-{\n-  static int compiled = 0;\n-  tSCC label_pat[] = \"^[ \\t]*#[ \\t]*(else|endif)\";\n-  static regex_t label_re;\n-\n-  char ch;\n-  tCC* pz_next;\n-  tCC* all_text = text;\n-  regmatch_t match[2];\n-\n-  /*\n-     This routine may be run many times within a single execution.\n-     Do the compile once only in that case.  In the standalone case,\n-     we waste 10 bytes of memory and a test, branch and increment delay.  */\n-  if (! compiled)\n-    {\n-      compiled++;\n-      compile_re (label_pat, &label_re, 1,\n-\t\t  \"label pattern\", \"else_endif_label_test\");\n-    }\n-\n-  for (;;) /* entire file */\n-    {\n-      /* Find the next else or endif in the file.  */\n-      if (regexec (&label_re, text, 2, match, 0) != 0)\n-\tbreak;\n-      pz_next = text + match[0].rm_eo;\n-\n-      /* Scan from where we are up to that position, to make sure\n-\t we didn't find something in a string or comment.  */\n-      while (pz_next > text)\n-        {\n-          /*\n-            Advance the scanning pointer.  If we are at the start\n-            of a quoted string or a comment, then skip the entire unit */\n-          ch = *(text++);\n-\n-          switch (ch)\n-            {\n-            case '/':\n-              /*\n-                Skip comments */\n-              if (*text == '*')\n-                {\n-                  text = strstr( text+1, \"*/\" );\n-                  if (text == (char*)NULL)\n-                    return SKIP_FIX;\n-                  text += 2;\n-                  continue;\n-                }\n-              break;\n-\n-            case '\"':\n-            case '\\'':\n-              text = skip_quote( ch, text );\n-              break;\n-            }\n-        }\n-      if (pz_next < text)\n-\tcontinue;\n-\n-      /* We're at the end of a real directive.  Check for bogons here.  */\n-      for (;;)\n-        {\n-          char ch = *(pz_next++);\n-\t  switch (ch)\n-\t    {\n-\t    case '\\n':\n-\t      /* It is clean.  No bogons on this directive.  */\n-\t      goto next_directive;\n-\n-            case '\\\\':\n-              /* Skip escaped newlines.  Otherwise, we have a bogon.  */\n-              if (*pz_next != '\\n')\n-                return APPLY_FIX;\n-\n-              pz_next++;\n-              break;\n-\n-            case '/':\n-              /* Skip comments.  Otherwise, we have a bogon */\n-\t      switch (*pz_next)\n-\t\t{\n-\t\tcase '/':\n-\t\t  /* // in a C header is a bogon.  */\n-                  if (! is_cxx_header( fname, all_text ))\n-                    return APPLY_FIX;\n-\n-                  /* C++ comment is allowed in a C++ header.\n-\t\t     Skip to newline and continue. */\n-                  pz_next = strchr( pz_next+1, '\\n' );\n-                  if (pz_next == (char*)NULL)\n-                    return SKIP_FIX;\n-                  pz_next++;\n-                  goto next_directive;\n-\n-\t\tcase '*':\n-                  /* A comment for either C++ or C.  Skip over it. */\n-                  pz_next = strstr( pz_next+1, \"*/\" );\n-                  if (pz_next == (char*)NULL)\n-                    return SKIP_FIX;\n-                  pz_next += 2;\n-\t\t  break;\n-\n-\t\tdefault:\n-\t\t  return APPLY_FIX;\n-\t\t}\n-\t      break;\n-\n-            default:\n-\t      if (!isspace (ch))\n-\t\treturn APPLY_FIX;\n-            } /* switch (ch) */\n-        } /* for (bogon check loop) */\n-    next_directive:;\n-      text = pz_next;\n-    } /* for (entire file) loop */\n-\n-  return SKIP_FIX;\n-}\n \n TEST_FOR_FIX_PROC_HEAD( machine_name_test )\n {"}]}