{"sha": "18744d9b72b028b5612e250966f9d165a40ae9d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg3NDRkOWI3MmIwMjhiNTYxMmUyNTA5NjZmOWQxNjVhNDBhZTlkOA==", "commit": {"author": {"name": "Bryce McKinlay", "email": "mckinlay@redhat.com", "date": "2005-03-10T19:02:21Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2005-03-10T19:02:21Z"}, "message": "New Stack Trace infrastructure.\n\n2005-03-10  Bryce McKinlay  <mckinlay@redhat.com>\n\n\tNew Stack Trace infrastructure.\n\t* Makefile.am (libgcj0_convenience_la_SOURCES): Add stacktrace.cc.\n\t(gnu/gcj/runtime/StackTrace.lo): Removed.\n\t(ordinary_java_source_files): Remove obsolete files.\n\t(nat_source_files): Remove obsolete files. Add natVMThrowable.cc.\n\t* configure.host (fallback_backtrace_h): Set backtrace header\n\tfor mingw and cygwin targets.\n\t* configure.ac: Make symlink for fallback backtrace headers.\n\t* Makefile.in, configure: Rebuilt.\n\t* defineclass.cc (_Jv_ClassReader::read_one_code_attribute):\n\tRead 'LineNumberTable' attribute.\n\t(_Jv_ClassReader::read_one_class_attribute): Read 'SourceFile'\n\tattribute.\n\t(_Jv_ClassReader::handleCodeAttribute): Initialize method line\n\ttable fields.\n\t* exception.cc: Remove unused include.\n\t* interpret.cc (DIRECT_THREADED, insn_slot): Moved to java-interp.h.\n\t(SAVE_PC): New macro. Save current PC in the interpreter frame.\n\t(NULLCHECK, NULLARRAYCHECK): Use SAVE_PC.\n\t(_Jv_InterpMethod::compile): Translate bytecode PC values in the line\n\ttable to direct threaded instruction values.\n\t(_Jv_StartOfInterpreter, _Jv_EndOfInterpreter): Removed.\n\t(_Jv_InterpMethod::run): No longer member function. All\n\tcallers updated. Remove _Unwind calls. Call SAVE_PC whenever a call\n\tis made or where an instruction could throw.\n\t(_Jv_InterpMethod::get_source_line): New. Look up source line numbers\n\tin line_table.\n\t* prims.cc (catch_segv): Construct exception after MAKE_THROW_FRAME.\n\t(catch_fpe): Likewise.\n\t* stacktrace.cc: New file. Stack trace code now here.\n\t* gnu/gcj/runtime/MethodRef.java:\n\t* gnu/gcj/runtime/NameFinder.java: Mostly reimplemented. Now simply\n\tcalls addr2line to look up PC addresses in a given binary or shared\n\tlibrary.\n\t* gnu/gcj/runtime/StackTrace.java, gnu/gcj/runtime/natNameFinder.cc,\n\tgnu/gcj/runtime/natStackTrace.cc: Removed.\n\t* gnu/java/lang/MainThread.java (call_main): Add comment warning that\n\tthis function name is specially recognised by the stack trace code\n\tand shouldn't be changed.\n\t* include/java-interp.h (DIRECT_THREADED, insn_slot): Moved here.\n\t(struct  _Jv_LineTableEntry, line_table, line_table_len): New.\n\t(_Jv_InterpMethod::run): Update declaration.\n\t(_Jv_StackTrace_): New friend. NameFinder and StackTrace no longer\n\tfriends.\n\t(_Jv_InterpFrame): Renamed from _Jv_MethodChain. Add PC field.\n\t* include/java-stack.h: New file. Declarations for stack tracing.\n\t* include/jvm.h (_Jv_Frame_info): Removed.\n\t* java/lang/Class.h: Update friend declarations.\n\t* java/lang/VMClassLoader.java (getSystemClassLoader): Simplify\n\texception message.\n\t* java/lang/VMThrowable.java (fillInStackTrace): Now native.\n\t(getStackTrace): Now native.\n\t(data): New RawDataManaged field.\n\t* java/lang/natClass.cc: Update includes.\n\t(forName): Use _Jv_StackTrace::GetCallingClass for\n\tcalling-classloader check.\n\t(getClassLoader): Likewise.\n\t* java/lang/natRuntime.cc: Update includes.\n\t(_load): Use _Jv_StackTrace::GetFirstNonSystemClassLoader.\n\t* java/lang/natVMSecurityManager.cc: Update includes.\n\t(getClassContext): Use _Jv_StackTrace::GetClassContext.\n\t* java/lang/natVMThrowable.cc: New file. Native methods for\n\tVMThrowable.\n\t* java/lang/reflect/natArray.cc: Update includes.\n\t(newInstance): Use _Jv_StackTrace::GetCallingClass to implement\n\taccessibility check.\n\t* java/lang/reflect/natConstructor.cc: Update includes.\n\t(newInstance): Use _Jv_StackTrace::GetCallingClass to implement\n\taccessibility check.\n\t* java/lang/reflect/natField.cc: Update includes.\n\t(getAddr): Use _Jv_StackTrace::GetCallingClass to implement\n\taccessibility check.\n\t* java/lang/reflect/natMethod.cc: Update includes.\n\t(invoke): Use _Jv_StackTrace::GetCallingClass to implement\n\taccessibility check.\n\t* java/util/natResourceBundle.cc: Update includes.\n\t(getCallingClassLoader): Use _Jv_StackTrace::GetCallingClass.\n\t* java/util/logging/natLogger.cc: Update includes. Use\n\t_Jv_StackTrace::GetCallerInfo to get call-site info.\n\t* sysdep/generic/backtrace.h: Fallback backtrace code. Stub\n\timplementation.\n\t* sysdep/i386/backtrace.h: New. Fallback backtrace code. i386\n\timplementation.\n\nFrom-SVN: r96253", "tree": {"sha": "7b6e8c5a43f4dcb0d8d4ac926f4562a978e11786", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b6e8c5a43f4dcb0d8d4ac926f4562a978e11786"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18744d9b72b028b5612e250966f9d165a40ae9d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18744d9b72b028b5612e250966f9d165a40ae9d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18744d9b72b028b5612e250966f9d165a40ae9d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18744d9b72b028b5612e250966f9d165a40ae9d8/comments", "author": null, "committer": null, "parents": [{"sha": "ca1593fda439eef1997ac28568337b52bf32460c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca1593fda439eef1997ac28568337b52bf32460c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca1593fda439eef1997ac28568337b52bf32460c"}], "stats": {"total": 1986, "additions": 1164, "deletions": 822}, "files": [{"sha": "b92bf687e695029ca0cff7685086ff0843f236de", "filename": "libjava/ChangeLog", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -1,3 +1,89 @@\n+2005-03-10  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\tNew Stack Trace infrastructure.\n+\t* Makefile.am (libgcj0_convenience_la_SOURCES): Add stacktrace.cc.\n+\t(gnu/gcj/runtime/StackTrace.lo): Removed.\n+\t(ordinary_java_source_files): Remove obsolete files.\n+\t(nat_source_files): Remove obsolete files. Add natVMThrowable.cc.\n+\t* configure.host (fallback_backtrace_h): Set backtrace header\n+\tfor mingw and cygwin targets. \n+\t* configure.ac: Make symlink for fallback backtrace headers.\n+\t* Makefile.in, configure: Rebuilt.\n+\t* defineclass.cc (_Jv_ClassReader::read_one_code_attribute):\n+\tRead 'LineNumberTable' attribute.\n+\t(_Jv_ClassReader::read_one_class_attribute): Read 'SourceFile'\n+\tattribute.\n+\t(_Jv_ClassReader::handleCodeAttribute): Initialize method line \n+\ttable fields.\n+\t* exception.cc: Remove unused include.\n+\t* interpret.cc (DIRECT_THREADED, insn_slot): Moved to java-interp.h.\n+\t(SAVE_PC): New macro. Save current PC in the interpreter frame.\n+\t(NULLCHECK, NULLARRAYCHECK): Use SAVE_PC.\n+\t(_Jv_InterpMethod::compile): Translate bytecode PC values in the line\n+\ttable to direct threaded instruction values.\n+\t(_Jv_StartOfInterpreter, _Jv_EndOfInterpreter): Removed.\n+\t(_Jv_InterpMethod::run): No longer member function. All \n+\tcallers updated. Remove _Unwind calls. Call SAVE_PC whenever a call\n+\tis made or where an instruction could throw.\n+\t(_Jv_InterpMethod::get_source_line): New. Look up source line numbers\n+\tin line_table.\n+\t* prims.cc (catch_segv): Construct exception after MAKE_THROW_FRAME.\n+\t(catch_fpe): Likewise.\n+\t* stacktrace.cc: New file. Stack trace code now here.\n+\t* gnu/gcj/runtime/MethodRef.java: \n+\t* gnu/gcj/runtime/NameFinder.java: Mostly reimplemented. Now simply\n+\tcalls addr2line to look up PC addresses in a given binary or shared\n+\tlibrary.\n+\t* gnu/gcj/runtime/StackTrace.java, gnu/gcj/runtime/natNameFinder.cc,\n+\tgnu/gcj/runtime/natStackTrace.cc: Removed.\n+\t* gnu/java/lang/MainThread.java (call_main): Add comment warning that\n+\tthis function name is specially recognised by the stack trace code\n+\tand shouldn't be changed.\n+\t* include/java-interp.h (DIRECT_THREADED, insn_slot): Moved here.\n+\t(struct  _Jv_LineTableEntry, line_table, line_table_len): New.\n+\t(_Jv_InterpMethod::run): Update declaration.\n+\t(_Jv_StackTrace_): New friend. NameFinder and StackTrace no longer\n+\tfriends.\n+\t(_Jv_InterpFrame): Renamed from _Jv_MethodChain. Add PC field.\n+\t* include/java-stack.h: New file. Declarations for stack tracing.\n+\t* include/jvm.h (_Jv_Frame_info): Removed.\n+\t* java/lang/Class.h: Update friend declarations.\t\n+\t* java/lang/VMClassLoader.java (getSystemClassLoader): Simplify\n+\texception message.\n+\t* java/lang/VMThrowable.java (fillInStackTrace): Now native.\n+\t(getStackTrace): Now native.\n+\t(data): New RawDataManaged field.\n+\t* java/lang/natClass.cc: Update includes. \n+\t(forName): Use _Jv_StackTrace::GetCallingClass for \n+\tcalling-classloader check.\n+\t(getClassLoader): Likewise.\n+\t* java/lang/natRuntime.cc: Update includes.\n+\t(_load): Use _Jv_StackTrace::GetFirstNonSystemClassLoader.\n+\t* java/lang/natVMSecurityManager.cc: Update includes.\n+\t(getClassContext): Use _Jv_StackTrace::GetClassContext.\n+\t* java/lang/natVMThrowable.cc: New file. Native methods for \n+\tVMThrowable.\n+\t* java/lang/reflect/natArray.cc: Update includes.\n+\t(newInstance): Use _Jv_StackTrace::GetCallingClass to implement\n+\taccessibility check.\n+\t* java/lang/reflect/natConstructor.cc: Update includes.\n+\t(newInstance): Use _Jv_StackTrace::GetCallingClass to implement\n+\taccessibility check.\n+\t* java/lang/reflect/natField.cc: Update includes.\n+\t(getAddr): Use _Jv_StackTrace::GetCallingClass to implement\n+\taccessibility check.\n+\t* java/lang/reflect/natMethod.cc: Update includes.\n+\t(invoke): Use _Jv_StackTrace::GetCallingClass to implement\n+\taccessibility check.\n+\t* java/util/natResourceBundle.cc: Update includes.\n+\t(getCallingClassLoader): Use _Jv_StackTrace::GetCallingClass.\t\n+\t* java/util/logging/natLogger.cc: Update includes. Use \n+\t_Jv_StackTrace::GetCallerInfo to get call-site info.\t\n+\t* sysdep/generic/backtrace.h: Fallback backtrace code. Stub\n+\timplementation.\n+\t* sysdep/i386/backtrace.h: New. Fallback backtrace code. i386\n+\timplementation.\n+\n 2005-03-10  Ranjit Mathew  <rmathew@hotmail.com>\n \n \t* testsuite/libjava.compile/PR20312.java: New file."}, {"sha": "920b05bd9af2eb8234b9c0d85f78293cfa986aa6", "filename": "libjava/Makefile.am", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -217,7 +217,7 @@ libgij_la_LDFLAGS = -rpath $(toolexeclibdir) \\\n # convenience library suddenly invokes the --whole-archive path instead.\n # This allows the build to succeed for targets that allocate multiple got\n # subsections in the linker, such as Alpha and MIPS.\n-libgcj0_convenience_la_SOURCES = prims.cc jni.cc exception.cc \\\n+libgcj0_convenience_la_SOURCES = prims.cc jni.cc exception.cc stacktrace.cc \\\n \tlink.cc defineclass.cc interpret.cc verify.cc \\\n \t$(nat_source_files) $(math_c_source_files) $(java_source_files) \\\n \t$(gnu_xml_source_files) $(built_java_source_files) \\\n@@ -588,20 +588,12 @@ clean-nat:\n \n SUFFIXES = .class .java .h .properties\n \n-## Note: we omit StackTrace here, since it has an explicit rule a bit\n-## later, and GNU make will warn in this case.\n-$(filter-out gnu/gcj/runtime/StackTrace.lo, $(javao_files)) $(xlib_javao_files): %.lo: %.java\n+$(javao_files) $(xlib_javao_files): %.lo: %.java\n \t$(LTGCJCOMPILE) -o $@ -c $<\n \n $(gtk_awt_peer_sources:.java=.lo) $(gnu_xml_source_files:.java=.lo): %.lo: %.java\n \t$(LTGCJCOMPILE) -fjni -o $@ -c $<\n \n-## A special case.  The sibcall optimization can change the number of\n-## frames on the stack, and StackTrace makes assumptions about this\n-## number.\n-gnu/gcj/runtime/StackTrace.lo: gnu/gcj/runtime/StackTrace.java\n-\t$(LTGCJCOMPILE) -fno-optimize-sibling-calls -o $@ -c $<\n-\n ## Pass the list of object files to libtool in a temporary file to\n ## avoid tripping platform command line length limits.\n libgcj.la: $(libgcj_la_OBJECTS) $(libgcj_la_DEPENDENCIES)\n@@ -2911,12 +2903,10 @@ gnu/gcj/io/SimpleSHSStream.java\t\\\n gnu/gcj/runtime/FileDeleter.java \\\n gnu/gcj/runtime/FinalizerThread.java \\\n gnu/gcj/runtime/JNIWeakRef.java \\\n-gnu/gcj/runtime/MethodRef.java \\\n gnu/gcj/runtime/NameFinder.java \\\n gnu/gcj/runtime/PersistentByteMap.java \\\n gnu/gcj/runtime/SharedLibHelper.java \\\n gnu/gcj/runtime/SharedLibLoader.java \\\n-gnu/gcj/runtime/StackTrace.java \\\n gnu/gcj/runtime/StringBuffer.java \\\n gnu/gcj/runtime/SystemClassLoader.java \\\n gnu/gcj/runtime/VMClassLoader.java \\\n@@ -3676,9 +3666,7 @@ gnu/gcj/convert/natOutput_SJIS.cc \\\n gnu/gcj/io/natSimpleSHSStream.cc \\\n gnu/gcj/io/shs.cc \\\n gnu/gcj/runtime/natFinalizerThread.cc \\\n-gnu/gcj/runtime/natNameFinder.cc \\\n gnu/gcj/runtime/natSharedLibLoader.cc \\\n-gnu/gcj/runtime/natStackTrace.cc \\\n gnu/gcj/runtime/natStringBuffer.cc \\\n gnu/gcj/runtime/natVMClassLoader.cc \\\n gnu/gcj/util/natDebug.cc \\\n@@ -3708,6 +3696,7 @@ java/lang/natSystem.cc \\\n java/lang/natThread.cc \\\n java/lang/natVMClassLoader.cc \\\n java/lang/natVMSecurityManager.cc \\\n+java/lang/natVMThrowable.cc \\\n java/lang/ref/natReference.cc \\\n java/lang/reflect/natArray.cc \\\n java/lang/reflect/natConstructor.cc \\"}, {"sha": "4be41130c88a2ce71a4c38f56b817696b5d94cd6", "filename": "libjava/Makefile.in", "status": "modified", "additions": 23, "deletions": 48, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -84,7 +84,8 @@ CONFIG_CLEAN_FILES = libgcj.pc libgcj.spec libgcj-test.spec \\\n \tgnu/java/net/natPlainSocketImpl.cc \\\n \tgnu/java/net/natPlainDatagramSocketImpl.cc \\\n \tgnu/java/nio/natPipeImpl.cc gnu/java/nio/natSelectorImpl.cc \\\n-\tgnu/java/nio/channels/natFileChannelImpl.cc sysdep/locks.h\n+\tgnu/java/nio/channels/natFileChannelImpl.cc sysdep/locks.h \\\n+\tsysdep/backtrace.h\n am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n am__vpath_adj = case $$p in \\\n     $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n@@ -331,7 +332,7 @@ am_libgcj_la_OBJECTS =\n libgcj_la_OBJECTS = $(am_libgcj_la_OBJECTS)\n libgcj0_convenience_la_LIBADD =\n am__libgcj0_convenience_la_SOURCES_DIST = prims.cc jni.cc exception.cc \\\n-\tlink.cc defineclass.cc interpret.cc verify.cc \\\n+\tstacktrace.cc link.cc defineclass.cc interpret.cc verify.cc \\\n \tgnu/gcj/natCore.cc gnu/gcj/convert/JIS0208_to_Unicode.cc \\\n \tgnu/gcj/convert/JIS0212_to_Unicode.cc \\\n \tgnu/gcj/convert/Unicode_to_JIS.cc gnu/gcj/convert/natIconv.cc \\\n@@ -341,9 +342,7 @@ am__libgcj0_convenience_la_SOURCES_DIST = prims.cc jni.cc exception.cc \\\n \tgnu/gcj/convert/natOutput_SJIS.cc \\\n \tgnu/gcj/io/natSimpleSHSStream.cc gnu/gcj/io/shs.cc \\\n \tgnu/gcj/runtime/natFinalizerThread.cc \\\n-\tgnu/gcj/runtime/natNameFinder.cc \\\n \tgnu/gcj/runtime/natSharedLibLoader.cc \\\n-\tgnu/gcj/runtime/natStackTrace.cc \\\n \tgnu/gcj/runtime/natStringBuffer.cc \\\n \tgnu/gcj/runtime/natVMClassLoader.cc gnu/gcj/util/natDebug.cc \\\n \tgnu/java/lang/natMainThread.cc \\\n@@ -362,7 +361,7 @@ am__libgcj0_convenience_la_SOURCES_DIST = prims.cc jni.cc exception.cc \\\n \tjava/lang/natString.cc java/lang/natStringBuffer.cc \\\n \tjava/lang/natSystem.cc java/lang/natThread.cc \\\n \tjava/lang/natVMClassLoader.cc \\\n-\tjava/lang/natVMSecurityManager.cc \\\n+\tjava/lang/natVMSecurityManager.cc java/lang/natVMThrowable.cc \\\n \tjava/lang/ref/natReference.cc java/lang/reflect/natArray.cc \\\n \tjava/lang/reflect/natConstructor.cc \\\n \tjava/lang/reflect/natField.cc java/lang/reflect/natMethod.cc \\\n@@ -555,12 +554,11 @@ am__libgcj0_convenience_la_SOURCES_DIST = prims.cc jni.cc exception.cc \\\n \tgnu/gcj/io/MimeTypes.java gnu/gcj/io/SimpleSHSStream.java \\\n \tgnu/gcj/runtime/FileDeleter.java \\\n \tgnu/gcj/runtime/FinalizerThread.java \\\n-\tgnu/gcj/runtime/JNIWeakRef.java gnu/gcj/runtime/MethodRef.java \\\n+\tgnu/gcj/runtime/JNIWeakRef.java \\\n \tgnu/gcj/runtime/NameFinder.java \\\n \tgnu/gcj/runtime/PersistentByteMap.java \\\n \tgnu/gcj/runtime/SharedLibHelper.java \\\n \tgnu/gcj/runtime/SharedLibLoader.java \\\n-\tgnu/gcj/runtime/StackTrace.java \\\n \tgnu/gcj/runtime/StringBuffer.java \\\n \tgnu/gcj/runtime/SystemClassLoader.java \\\n \tgnu/gcj/runtime/VMClassLoader.java gnu/gcj/util/Debug.java \\\n@@ -2615,9 +2613,7 @@ am__objects_6 = gnu/gcj/natCore.lo \\\n \tgnu/gcj/convert/natOutput_SJIS.lo \\\n \tgnu/gcj/io/natSimpleSHSStream.lo gnu/gcj/io/shs.lo \\\n \tgnu/gcj/runtime/natFinalizerThread.lo \\\n-\tgnu/gcj/runtime/natNameFinder.lo \\\n \tgnu/gcj/runtime/natSharedLibLoader.lo \\\n-\tgnu/gcj/runtime/natStackTrace.lo \\\n \tgnu/gcj/runtime/natStringBuffer.lo \\\n \tgnu/gcj/runtime/natVMClassLoader.lo gnu/gcj/util/natDebug.lo \\\n \tgnu/java/lang/natMainThread.lo \\\n@@ -2636,7 +2632,7 @@ am__objects_6 = gnu/gcj/natCore.lo \\\n \tjava/lang/natString.lo java/lang/natStringBuffer.lo \\\n \tjava/lang/natSystem.lo java/lang/natThread.lo \\\n \tjava/lang/natVMClassLoader.lo \\\n-\tjava/lang/natVMSecurityManager.lo \\\n+\tjava/lang/natVMSecurityManager.lo java/lang/natVMThrowable.lo \\\n \tjava/lang/ref/natReference.lo java/lang/reflect/natArray.lo \\\n \tjava/lang/reflect/natConstructor.lo \\\n \tjava/lang/reflect/natField.lo java/lang/reflect/natMethod.lo \\\n@@ -3996,12 +3992,11 @@ am__objects_15 = $(am__objects_9) gnu/classpath/ServiceFactory.lo \\\n \tgnu/gcj/io/DefaultMimeTypes.lo gnu/gcj/io/MimeTypes.lo \\\n \tgnu/gcj/io/SimpleSHSStream.lo gnu/gcj/runtime/FileDeleter.lo \\\n \tgnu/gcj/runtime/FinalizerThread.lo \\\n-\tgnu/gcj/runtime/JNIWeakRef.lo gnu/gcj/runtime/MethodRef.lo \\\n-\tgnu/gcj/runtime/NameFinder.lo \\\n+\tgnu/gcj/runtime/JNIWeakRef.lo gnu/gcj/runtime/NameFinder.lo \\\n \tgnu/gcj/runtime/PersistentByteMap.lo \\\n \tgnu/gcj/runtime/SharedLibHelper.lo \\\n \tgnu/gcj/runtime/SharedLibLoader.lo \\\n-\tgnu/gcj/runtime/StackTrace.lo gnu/gcj/runtime/StringBuffer.lo \\\n+\tgnu/gcj/runtime/StringBuffer.lo \\\n \tgnu/gcj/runtime/SystemClassLoader.lo \\\n \tgnu/gcj/runtime/VMClassLoader.lo gnu/gcj/util/Debug.lo \\\n \tgnu/java/io/ASN1ParsingException.lo \\\n@@ -4746,12 +4741,12 @@ am__objects_18 = java/lang/ConcreteProcess.lo \\\n @USING_WIN32_THREADS_TRUE@am__objects_27 = win32-threads.lo\n @USING_NO_THREADS_TRUE@am__objects_28 = no-threads.lo\n am_libgcj0_convenience_la_OBJECTS = prims.lo jni.lo exception.lo \\\n-\tlink.lo defineclass.lo interpret.lo verify.lo $(am__objects_6) \\\n-\t$(am__objects_7) $(am__objects_16) $(am__objects_17) \\\n-\t$(am__objects_18) $(am__objects_19) $(am__objects_20) \\\n-\t$(am__objects_21) $(am__objects_22) $(am__objects_23) \\\n-\t$(am__objects_24) $(am__objects_25) $(am__objects_26) \\\n-\t$(am__objects_27) $(am__objects_28)\n+\tstacktrace.lo link.lo defineclass.lo interpret.lo verify.lo \\\n+\t$(am__objects_6) $(am__objects_7) $(am__objects_16) \\\n+\t$(am__objects_17) $(am__objects_18) $(am__objects_19) \\\n+\t$(am__objects_20) $(am__objects_21) $(am__objects_22) \\\n+\t$(am__objects_23) $(am__objects_24) $(am__objects_25) \\\n+\t$(am__objects_26) $(am__objects_27) $(am__objects_28)\n libgcj0_convenience_la_OBJECTS = $(am_libgcj0_convenience_la_OBJECTS)\n am_libgij_la_OBJECTS = gij.lo\n libgij_la_OBJECTS = $(am_libgij_la_OBJECTS)\n@@ -5163,7 +5158,7 @@ libgij_la_LDFLAGS = -rpath $(toolexeclibdir) \\\n # convenience library suddenly invokes the --whole-archive path instead.\n # This allows the build to succeed for targets that allocate multiple got\n # subsections in the linker, such as Alpha and MIPS.\n-libgcj0_convenience_la_SOURCES = prims.cc jni.cc exception.cc \\\n+libgcj0_convenience_la_SOURCES = prims.cc jni.cc exception.cc stacktrace.cc \\\n \tlink.cc defineclass.cc interpret.cc verify.cc \\\n \t$(nat_source_files) $(math_c_source_files) $(java_source_files) \\\n \t$(gnu_xml_source_files) $(built_java_source_files) \\\n@@ -7306,12 +7301,10 @@ gnu/gcj/io/SimpleSHSStream.java\t\\\n gnu/gcj/runtime/FileDeleter.java \\\n gnu/gcj/runtime/FinalizerThread.java \\\n gnu/gcj/runtime/JNIWeakRef.java \\\n-gnu/gcj/runtime/MethodRef.java \\\n gnu/gcj/runtime/NameFinder.java \\\n gnu/gcj/runtime/PersistentByteMap.java \\\n gnu/gcj/runtime/SharedLibHelper.java \\\n gnu/gcj/runtime/SharedLibLoader.java \\\n-gnu/gcj/runtime/StackTrace.java \\\n gnu/gcj/runtime/StringBuffer.java \\\n gnu/gcj/runtime/SystemClassLoader.java \\\n gnu/gcj/runtime/VMClassLoader.java \\\n@@ -8066,9 +8059,7 @@ gnu/gcj/convert/natOutput_SJIS.cc \\\n gnu/gcj/io/natSimpleSHSStream.cc \\\n gnu/gcj/io/shs.cc \\\n gnu/gcj/runtime/natFinalizerThread.cc \\\n-gnu/gcj/runtime/natNameFinder.cc \\\n gnu/gcj/runtime/natSharedLibLoader.cc \\\n-gnu/gcj/runtime/natStackTrace.cc \\\n gnu/gcj/runtime/natStringBuffer.cc \\\n gnu/gcj/runtime/natVMClassLoader.cc \\\n gnu/gcj/util/natDebug.cc \\\n@@ -8098,6 +8089,7 @@ java/lang/natSystem.cc \\\n java/lang/natThread.cc \\\n java/lang/natVMClassLoader.cc \\\n java/lang/natVMSecurityManager.cc \\\n+java/lang/natVMThrowable.cc \\\n java/lang/ref/natReference.cc \\\n java/lang/reflect/natArray.cc \\\n java/lang/reflect/natConstructor.cc \\\n@@ -8783,13 +8775,9 @@ gnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp):\n gnu/gcj/runtime/natFinalizerThread.lo:  \\\n \tgnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n-gnu/gcj/runtime/natNameFinder.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n-\tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n gnu/gcj/runtime/natSharedLibLoader.lo:  \\\n \tgnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n-gnu/gcj/runtime/natStackTrace.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n-\tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n gnu/gcj/runtime/natStringBuffer.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n gnu/gcj/runtime/natVMClassLoader.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n@@ -8899,6 +8887,8 @@ java/lang/natVMClassLoader.lo: java/lang/$(am__dirstamp) \\\n \tjava/lang/$(DEPDIR)/$(am__dirstamp)\n java/lang/natVMSecurityManager.lo: java/lang/$(am__dirstamp) \\\n \tjava/lang/$(DEPDIR)/$(am__dirstamp)\n+java/lang/natVMThrowable.lo: java/lang/$(am__dirstamp) \\\n+\tjava/lang/$(DEPDIR)/$(am__dirstamp)\n java/lang/ref/$(am__dirstamp):\n \t@$(mkdir_p) java/lang/ref\n \t@: > java/lang/ref/$(am__dirstamp)\n@@ -9612,8 +9602,6 @@ gnu/gcj/runtime/FinalizerThread.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n gnu/gcj/runtime/JNIWeakRef.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n-gnu/gcj/runtime/MethodRef.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n-\tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n gnu/gcj/runtime/NameFinder.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n gnu/gcj/runtime/PersistentByteMap.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n@@ -9622,8 +9610,6 @@ gnu/gcj/runtime/SharedLibHelper.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n gnu/gcj/runtime/SharedLibLoader.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n-gnu/gcj/runtime/StackTrace.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n-\tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n gnu/gcj/runtime/StringBuffer.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n gnu/gcj/runtime/SystemClassLoader.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n@@ -16363,8 +16349,6 @@ mostlyclean-compile:\n \t-rm -f gnu/gcj/runtime/FinalizerThread.lo\n \t-rm -f gnu/gcj/runtime/JNIWeakRef.$(OBJEXT)\n \t-rm -f gnu/gcj/runtime/JNIWeakRef.lo\n-\t-rm -f gnu/gcj/runtime/MethodRef.$(OBJEXT)\n-\t-rm -f gnu/gcj/runtime/MethodRef.lo\n \t-rm -f gnu/gcj/runtime/NameFinder.$(OBJEXT)\n \t-rm -f gnu/gcj/runtime/NameFinder.lo\n \t-rm -f gnu/gcj/runtime/PersistentByteMap.$(OBJEXT)\n@@ -16373,8 +16357,6 @@ mostlyclean-compile:\n \t-rm -f gnu/gcj/runtime/SharedLibHelper.lo\n \t-rm -f gnu/gcj/runtime/SharedLibLoader.$(OBJEXT)\n \t-rm -f gnu/gcj/runtime/SharedLibLoader.lo\n-\t-rm -f gnu/gcj/runtime/StackTrace.$(OBJEXT)\n-\t-rm -f gnu/gcj/runtime/StackTrace.lo\n \t-rm -f gnu/gcj/runtime/StringBuffer.$(OBJEXT)\n \t-rm -f gnu/gcj/runtime/StringBuffer.lo\n \t-rm -f gnu/gcj/runtime/SystemClassLoader.$(OBJEXT)\n@@ -16383,12 +16365,8 @@ mostlyclean-compile:\n \t-rm -f gnu/gcj/runtime/VMClassLoader.lo\n \t-rm -f gnu/gcj/runtime/natFinalizerThread.$(OBJEXT)\n \t-rm -f gnu/gcj/runtime/natFinalizerThread.lo\n-\t-rm -f gnu/gcj/runtime/natNameFinder.$(OBJEXT)\n-\t-rm -f gnu/gcj/runtime/natNameFinder.lo\n \t-rm -f gnu/gcj/runtime/natSharedLibLoader.$(OBJEXT)\n \t-rm -f gnu/gcj/runtime/natSharedLibLoader.lo\n-\t-rm -f gnu/gcj/runtime/natStackTrace.$(OBJEXT)\n-\t-rm -f gnu/gcj/runtime/natStackTrace.lo\n \t-rm -f gnu/gcj/runtime/natStringBuffer.$(OBJEXT)\n \t-rm -f gnu/gcj/runtime/natStringBuffer.lo\n \t-rm -f gnu/gcj/runtime/natVMClassLoader.$(OBJEXT)\n@@ -19002,6 +18980,8 @@ mostlyclean-compile:\n \t-rm -f java/lang/natVMClassLoader.lo\n \t-rm -f java/lang/natVMSecurityManager.$(OBJEXT)\n \t-rm -f java/lang/natVMSecurityManager.lo\n+\t-rm -f java/lang/natVMThrowable.$(OBJEXT)\n+\t-rm -f java/lang/natVMThrowable.lo\n \t-rm -f java/lang/ref/PhantomReference.$(OBJEXT)\n \t-rm -f java/lang/ref/PhantomReference.lo\n \t-rm -f java/lang/ref/Reference.$(OBJEXT)\n@@ -21926,6 +21906,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/posix-threads.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/posix.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/prims.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/stacktrace.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/verify.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/win32-threads.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/win32.Plo@am__quote@\n@@ -21992,19 +21973,15 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/FileDeleter.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/FinalizerThread.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/JNIWeakRef.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/MethodRef.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/NameFinder.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/PersistentByteMap.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/SharedLibHelper.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/SharedLibLoader.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/StackTrace.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/StringBuffer.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/SystemClassLoader.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/VMClassLoader.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/natFinalizerThread.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/natNameFinder.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/natSharedLibLoader.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/natStackTrace.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/natStringBuffer.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/natVMClassLoader.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/tools/gcj_dbtool/$(DEPDIR)/Main.Po@am__quote@\n@@ -23312,6 +23289,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/natThread.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/natVMClassLoader.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/natVMSecurityManager.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/natVMThrowable.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/s_atan.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/s_ceil.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/s_copysign.Plo@am__quote@\n@@ -26677,15 +26655,12 @@ distclean-local:\n clean-nat:\n \trm -f $(nat_files) $(xlib_nat_files)\n \n-$(filter-out gnu/gcj/runtime/StackTrace.lo, $(javao_files)) $(xlib_javao_files): %.lo: %.java\n+$(javao_files) $(xlib_javao_files): %.lo: %.java\n \t$(LTGCJCOMPILE) -o $@ -c $<\n \n $(gtk_awt_peer_sources:.java=.lo) $(gnu_xml_source_files:.java=.lo): %.lo: %.java\n \t$(LTGCJCOMPILE) -fjni -o $@ -c $<\n \n-gnu/gcj/runtime/StackTrace.lo: gnu/gcj/runtime/StackTrace.java\n-\t$(LTGCJCOMPILE) -fno-optimize-sibling-calls -o $@ -c $<\n-\n libgcj.la: $(libgcj_la_OBJECTS) $(libgcj_la_DEPENDENCIES)\n \t@echo Creating list of files to link...\n \t@: $(call write_entries_to_file,$(libgcj_la_OBJECTS),libgcj.objectlist)"}, {"sha": "980f4a4e567760900ef526e6b81e8aef4985f97b", "filename": "libjava/configure", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -8454,6 +8454,8 @@ fi\n if test -d sysdep; then true; else mkdir sysdep; fi\n           ac_config_links=\"$ac_config_links sysdep/locks.h:sysdep/$sysdeps_dir/locks.h\"\n \n+          ac_config_links=\"$ac_config_links sysdep/backtrace.h:$fallback_backtrace_h\"\n+\n \n HASH_SYNC_SPEC=\n # Hash synchronization is only useful with posix threads right now.\n@@ -16482,6 +16484,7 @@ do\n   \"include/java-gc.h\" ) CONFIG_LINKS=\"$CONFIG_LINKS include/java-gc.h:include/$GCHDR\" ;;\n   \"include/java-threads.h\" ) CONFIG_LINKS=\"$CONFIG_LINKS include/java-threads.h:include/$THREADH\" ;;\n   \"sysdep/locks.h\" ) CONFIG_LINKS=\"$CONFIG_LINKS sysdep/locks.h:sysdep/$sysdeps_dir/locks.h\" ;;\n+  \"sysdep/backtrace.h\" ) CONFIG_LINKS=\"$CONFIG_LINKS sysdep/backtrace.h:$fallback_backtrace_h\" ;;\n   \"include/java-signal.h\" ) CONFIG_LINKS=\"$CONFIG_LINKS include/java-signal.h:$SIGNAL_HANDLER\" ;;\n   \"include/java-signal-aux.h\" ) CONFIG_LINKS=\"$CONFIG_LINKS include/java-signal-aux.h:$SIGNAL_HANDLER_AUX\" ;;\n   \"depfiles\" ) CONFIG_COMMANDS=\"$CONFIG_COMMANDS depfiles\" ;;"}, {"sha": "2e40268038a24d35cce39a4ae03d985b4b72de5c", "filename": "libjava/configure.ac", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.ac?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -710,6 +710,7 @@ AM_CONDITIONAL(USING_NO_THREADS, test \"$THREADS\" = none)\n \n if test -d sysdep; then true; else mkdir sysdep; fi\n AC_CONFIG_LINKS(sysdep/locks.h:sysdep/$sysdeps_dir/locks.h)\n+AC_CONFIG_LINKS(sysdep/backtrace.h:$fallback_backtrace_h)\n \n HASH_SYNC_SPEC=\n # Hash synchronization is only useful with posix threads right now."}, {"sha": "4d4c6e311bfabc7e0f12eaf77e30c95be26dd3c3", "filename": "libjava/configure.host", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.host?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -30,6 +30,8 @@\n #\t\t\tfrom a signal handler.\n #   disable_dladdr      Set to \"yes\" if dladdr should not be used\n #                       (i.e it is broken).\n+#   fallback_backtrace_h  Header to use for fallback backtrace implementation\n+#\t\t\t  (only for targets that don't support DWARF2 unwind)\n \n libgcj_flags=\n libgcj_cflags=\n@@ -42,6 +44,7 @@ sysdeps_dir=generic\n slow_pthread_self=\n can_unwind_signal=no\n disable_dladdr=\n+fallback_backtrace_h=sysdep/generic/backtrace.h\n \n case \"${target_optspace}:${host}\" in\n   yes:*)\n@@ -258,6 +261,13 @@ EOF\n \t;;\n esac\n \n+case \"${host}\" in\n+  *-cygwin* | *-mingw*)\n+\tfallback_backtrace_h=sysdep/i386/backtrace.h  \n+  ;;\n+esac\n+\n+\n libgcj_cflags=\"${libgcj_cflags} ${libgcj_flags}\"\n libgcj_cxxflags=\"${libgcj_cxxflags} ${libgcj_flags}\"\n libgcj_javaflags=\"${libgcj_javaflags} ${libgcj_flags}\""}, {"sha": "111b1fb2ca2fb83120b23cdb293c8f4531783524", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 45, "deletions": 13, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -229,6 +229,7 @@ struct _Jv_ClassReader {\n     len    = length;\n     pos    = 0;\n     def    = klass;\n+\n     def->size_in_bytes = -1;\n     def->vtable_method_count = -1;\n     def->engine = &_Jv_soleInterpreterEngine;\n@@ -613,26 +614,54 @@ void _Jv_ClassReader::read_one_method_attribute (int method_index)\n     }\n }\n \n-void _Jv_ClassReader::read_one_code_attribute (int /*method*/) \n+void _Jv_ClassReader::read_one_code_attribute (int method_index) \n {\n-  /* ignore for now, ... later we may want to pick up\n-     line number information, for debugging purposes;\n-     in fact, the whole debugger issue is open!  */\n-\n-  /* int name = */ read2u ();\n+  int name = read2u ();\n   int length = read4 ();\n-  skip (length);\n-\n+  if (is_attribute_name (name, \"LineNumberTable\"))\n+    {\n+      _Jv_InterpMethod *method = reinterpret_cast<_Jv_InterpMethod *>\n+\t(def_interp->interpreted_methods[method_index]);\n+      if (method->line_table != NULL)\n+\tthrow_class_format_error (\"Method already has LineNumberTable\");\n+\n+      int table_len = read2u ();\n+      _Jv_LineTableEntry* table\n+\t= (_Jv_LineTableEntry *) JvAllocBytes (table_len\n+\t\t\t\t\t    * sizeof (_Jv_LineTableEntry));\n+      for (int i = 0; i < table_len; i++)\n+       {\n+\t table[i].bytecode_pc = read2u ();\n+\t table[i].line = read2u ();\n+       }\n+      method->line_table_len = table_len;\n+      method->line_table = table;\n+    }\n+  else\n+    {\n+      /* ignore unknown code attributes */\n+      skip (length);\n+    }\n }\n \n void _Jv_ClassReader::read_one_class_attribute () \n {\n-  /* we also ignore the class attributes, ...\n-     some day we'll add inner-classes support. */\n-\n-  /* int name = */ read2u ();\n+  int name = read2u ();\n   int length = read4 ();\n-  skip (length);\n+  if (is_attribute_name (name, \"SourceFile\"))\n+    {\n+      int source_index = read2u ();\n+      check_tag (source_index, JV_CONSTANT_Utf8);\n+      prepare_pool_entry (source_index, JV_CONSTANT_Utf8);\n+      def_interp->source_file_name = _Jv_NewStringUtf8Const\n+\t(def->constants.data[source_index].utf8);\n+    }\n+  else\n+    {\n+      /* Currently, we ignore most class attributes.\n+         FIXME: Add inner-classes attributes support. */\n+     skip (length);\n+    }\n }\n \n \n@@ -1279,6 +1308,9 @@ void _Jv_ClassReader::handleCodeAttribute\n   method->defining_class = def;\n   method->self           = &def->methods[method_index];\n   method->prepared       = NULL;\n+  method->line_table_len = 0;\n+  method->line_table     = NULL;\n+\n \n   // grab the byte code!\n   memcpy ((void*) method->bytecode (),"}, {"sha": "ef7292c3bf755d5b6e8583f7f7b7458fe89a1f85", "filename": "libjava/exception.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fexception.cc?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -15,7 +15,6 @@ details.  */\n \n #include <java/lang/Class.h>\n #include <java/lang/NullPointerException.h>\n-#include <gnu/gcj/runtime/StackTrace.h> \n #include <gnu/gcj/runtime/MethodRef.h> \n #include <gnu/gcj/RawData.h> \n #include <gcj/cni.h>"}, {"sha": "68d9a4782610e69e42355d98e236f17882eb8325", "filename": "libjava/gnu/classpath/Configuration.java.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fgnu%2Fclasspath%2FConfiguration.java.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fgnu%2Fclasspath%2FConfiguration.java.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fclasspath%2FConfiguration.java.in?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -52,7 +52,7 @@ public interface Configuration\n   // For libgcj we never load the JNI libraries.\n   boolean INIT_LOAD_LIBRARY = false;\n \t\n-  // For libgcj we have native methods for proxy support....\n+  // For libgcj we have native methods for dynamic proxy support....\n   boolean HAVE_NATIVE_GET_PROXY_DATA = false;\n   boolean HAVE_NATIVE_GET_PROXY_CLASS = false;\n   boolean HAVE_NATIVE_GENERATE_PROXY_CLASS = false;"}, {"sha": "5469f08168d6bd8979908176a52ad707d8d0efbd", "filename": "libjava/gnu/gcj/runtime/NameFinder.java", "status": "modified", "additions": 108, "deletions": 414, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fgnu%2Fgcj%2Fruntime%2FNameFinder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fgnu%2Fgcj%2Fruntime%2FNameFinder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FNameFinder.java?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -9,6 +9,7 @@\n \n package gnu.gcj.runtime;\n \n+import gnu.classpath.Configuration;\n import gnu.gcj.RawData;\n \n import java.lang.StringBuffer;\n@@ -19,456 +20,156 @@\n import java.io.OutputStreamWriter;\n import java.io.IOException;\n import java.io.File;\n+import java.util.Iterator;\n+import java.util.HashMap;\n+\n \n /**\n- * Helper class that translates addresses (represented as longs) to a\n- * StackTraceElement array.\n+ * Lookup addresses (represented as longs) to find source & line number info.\n  *\n- * There are a couple of system properties that can be set to manipulate the\n- * result (all default to true):\n+ * The following system property is available (defaults to true):\n  * <li>\n- * <ul><code>gnu.gcj.runtime.NameFinder.demangle</code>\n- *     Whether names should be demangled.</ul>\n- * <ul><code>gnu.gcj.runtime.NameFinder.sanitize</code></ul>\n- *     Whether calls to initialize exceptions and starting the runtime system\n- *     should be removed from the stack trace. Only done when names are\n- *     demangled.</ul>\n- * <ul><code>gnu.gcj.runtime.NameFinder.remove_unknown</code>\n- *     Whether calls to unknown functions (class and method names are unknown)\n- *     should be removed from the stack trace. Only done when the stack is\n- *     sanitized.</ul>\n- * <ul><code>gnu.gcj.runtime.NameFinder.remove_internal</code>\n- *     Whether runtime internal calls (methods in the internal _Jv_* classes\n- *     and functions starting with 'ffi_') should be removed from the stack\n- *     trace. Only done when the stack is sanitized.</ul>\n  * <ul><code>gnu.gcj.runtime.NameFinder.use_addr2line</code>\n- *     Whether an external process (addr2line or addr2name.awk) should be used\n- *     as fallback to convert the addresses to function names when the runtime\n- *     is unable to do it through <code>dladdr</code>.</ul>\n+ *     Whether an external process, addr2line, should be used to look up\n+ *     source file and line number info. Throwable.printStackTrace() will\n+ *     be faster if this property is set to 'false'.\n+ * </ul>\n  * </li>\n  *\n  * <code>close()</code> should be called to get rid of all resources.\n  *\n  * This class is used from <code>java.lang.VMThrowable</code>.\n  *\n- * Currently the <code>lookup(long[])</code> method is not thread safe.\n- * It can easily be made thread safe by synchronizing access to all external\n- * processes when used.\n- *   \n  * @author Mark Wielaard (mark@klomp.org)\n  */\n public class NameFinder\n {\n-  // Set these to false when not needed.\n-  private static final boolean demangle\n-\t  = Boolean.valueOf(System.getProperty\n-\t\t(\"gnu.gcj.runtime.NameFinder.demangle\", \"true\")\n-\t    ).booleanValue();\n-  private static final boolean sanitize\n-\t  = Boolean.valueOf(System.getProperty\n-\t\t(\"gnu.gcj.runtime.NameFinder.sanitize\", \"true\")\n-\t    ).booleanValue();\n-  private static final boolean remove_unknown\n-\t  = Boolean.valueOf(System.getProperty\n-\t\t(\"gnu.gcj.runtime.NameFinder.remove_unknown\", \"true\")\n-\t    ).booleanValue();\n-\n-  // The remove_interpreter name is an old 3.3/3.4 (deprecated) synonym.\n-  private static final boolean remove_internal\n-\t  = (Boolean.valueOf(System.getProperty\n-\t\t(\"gnu.gcj.runtime.NameFinder.remove_internal\", \"true\")\n-\t\t\t     ).booleanValue()\n-\t     ||\n-\t     Boolean.valueOf(System.getProperty\n-\t\t(\"gnu.gcj.runtime.NameFinder.remove_interpreter\", \"true\")\n-                             ).booleanValue()\n-\t     );\n-\n-  private static final boolean use_addr2line\n-\t  = Boolean.valueOf(System.getProperty\n-\t\t(\"gnu.gcj.runtime.NameFinder.use_addr2line\", \"true\")\n-\t    ).booleanValue();\n-\n-  /**\n-   * The name of the currently running executable.\n-   */\n-  private final String executable;\n-\n-  /**\n-   * Process used for demangling names.\n-   */\n-  private Process cppfilt;\n-\n-  private BufferedWriter cppfiltOut;\n-  private BufferedReader cppfiltIn;\n-\n   /**\n-   * Process used for translating addresses to function/file names.\n+   * The name of the binary to look up.\n    */\n-  private Process addr2line;\n+  private String binaryFile;\n+  private String sourceFile;\n+  private int lineNum;\n+  private HashMap procs = new HashMap();\n \n-  private BufferedWriter addr2lineOut;\n-  private BufferedReader addr2lineIn;\n-\n-  /**\n-   * Flag set if using addr2name.awk instead of addr2line from binutils.\n-   */\n-  private boolean usingAddr2name = false;\n+  private static final boolean use_addr2line\n+          = Boolean.valueOf(System.getProperty\n+                (\"gnu.gcj.runtime.NameFinder.use_addr2line\", \"true\")\n+            ).booleanValue();\n \n-  /**\n-   * Creates a new NameFinder. Call close to get rid of any resources\n-   * created while using the <code>lookup</code> methods.\n-   */\n-  public NameFinder()\n+  class Addr2Line\n   {\n-    executable = getExecutable();\n-    Runtime runtime = Runtime.getRuntime();\n-    if (demangle)\n+    Process proc;\n+    BufferedWriter out;\n+    BufferedReader in;\n+\n+    Addr2Line(String binaryFile)\n     {\n       try\n-\t{\n-\t  String[] exec = new String[] {\"c++filt\", \"-s\", \"java\"};\n-\t  cppfilt = runtime.exec(exec);\n-\t  cppfiltIn = new BufferedReader\n-\t\t\t(new InputStreamReader(cppfilt.getInputStream()));\n-\t  cppfiltOut = new BufferedWriter\n-\t\t\t(new OutputStreamWriter(cppfilt.getOutputStream()));\n-\t}\n+      {\n+\tString[] exec = new String[] {\"addr2line\", \"-e\", binaryFile};\n+\tRuntime runtime = Runtime.getRuntime();\n+\tproc = runtime.exec(exec);\n+      }\n       catch (IOException ioe)\n-        {\n-\t  if (cppfilt != null)\n-\t    cppfilt.destroy();\n-\t  cppfilt = null;\n-\t}\n-    }\n-\n-    if (use_addr2line)\n       {\n-\ttry\n-\t  {\n-\t    String[] exec = new String[] {\"addr2line\", \"-f\", \"-e\", executable};\n-\t    addr2line = runtime.exec(exec);\n-\t  }\n-\tcatch (IOException ioe)\n-\t  {\n-\t    try\n-\t      {\n-\t\tString[] exec = new String[] {\"addr2name.awk\", executable};\n-\t\taddr2line = runtime.exec(exec);\n-\t\tusingAddr2name = true;\n-\t      }\n-\t    catch (IOException ioe2) { addr2line = null; }\n-\t  }\n-\n-\tif (addr2line != null)\n-\t  {\n-\t    addr2lineIn = new BufferedReader\n-\t      (new InputStreamReader(addr2line.getInputStream()));\n-\t    addr2lineOut = new BufferedWriter\n-\t      (new OutputStreamWriter(addr2line.getOutputStream()));\n-\t  }\n       }\n-  }\n-\n-  /**\n-   * Returns the name of the currently running process.\n-   */\n-  native private static String getExecutable();\n-\n-  /**\n-   * Tries to use dladdr to create the nth StackTraceElement from the given\n-   * addresses. Returns null on failure.\n-   */\n-  native private StackTraceElement dladdrLookup(RawData addrs, int n);\n-\n-  /**\n-   * Returns the nth element from the stack as a hex encoded String.\n-   */\n-  native private String getAddrAsString(RawData addrs, int n);\n-\n-  /**\n-   * Returns the label that is exported for the given method name.\n-   */\n-  native private String getExternalLabel(String name);\n-\n-  /**\n-   * If nth element of stack is an interpreted frame, return the\n-   * element representing the method being interpreted.\n-   */\n-  native private StackTraceElement lookupInterp(RawData addrs, int n);\n \n-  /**\n-   * Creates the nth StackTraceElement from the given native stacktrace.\n-   */\n-  private StackTraceElement lookup(RawData addrs, int n)\n-  {\n-    StackTraceElement result;\n-\n-    result = lookupInterp(addrs, n);\n-    if (result == null)\n-      result = dladdrLookup(addrs, n);\n-    if (result == null)\n+      if (proc != null)\n       {\n-\tString name = null;\n-\tString file = null;\n-\n-\tString hex = getAddrAsString(addrs, n);\n-\t\n-\tif (addr2line != null)\n-\t  {\n-\t    try\n-\t      {\n-\t\taddr2lineOut.write(hex);\n-\t\taddr2lineOut.newLine();\n-\t\taddr2lineOut.flush();\n-\t\tname = addr2lineIn.readLine();\n-\t\tfile = addr2lineIn.readLine();\n-\n-                // addr2line uses symbolic debugging information instead\n-                // of the actually exported labels as addr2name.awk does.\n-                // This name might need some modification, depending on \n-                // the system, to make it a label like that returned \n-                // by addr2name.awk or dladdr.\n-                if (! usingAddr2name)\n-                  if (name != null && ! \"??\".equals (name))\n-                    name = getExternalLabel (name);\n-\t      }\n-\t    catch (IOException ioe) { addr2line = null; }\n-\t  }\n-\n-\tif (name == null || \"??\".equals(name))\n-\t  name = hex;\n-\n-\tresult = createStackTraceElement(name, file);\n+\tin = new BufferedReader(new InputStreamReader(proc.getInputStream()));\n+\tout = new BufferedWriter(new OutputStreamWriter(proc.getOutputStream()));\n+      }\n+    }\n+    \n+    void close()\n+    {\n+      try\n+      {\n+\tin.close();\n+\tout.close();\n       }\n+      catch (IOException x) {}\n \n-    return result;\n+      proc.destroy();\n+    }\n   }\n \n   /**\n-   * Given an Throwable and a native stacktrace returns an array of\n-   * StackTraceElement containing class, method, file and linenumbers.\n+   * Create a new NameFinder to lookup names in binaryFile. Call close to get rid of any \n+   * resources created while using the <code>lookup</code> methods.\n    */\n-  public StackTraceElement[] lookup(Throwable t, StackTrace trace)\n+  public NameFinder()\n   {\n-    RawData addrs = trace.stackTraceAddrs();\n-    int length = trace.length();\n-\n-    StackTraceElement[] elements = new StackTraceElement[length];\n-    for (int i=0; i < length; i++)\n-      elements[i] = lookup(addrs, i);\n-\n-    if (demangle && sanitize)\n-      return sanitizeStack(elements, t);\n-    else\n-      return elements;\n   }\n \n-  \n   /**\n-   * Removes calls to initialize exceptions and the runtime system from\n-   * the stack trace including stack frames of which nothing usefull is known.\n-   * Throw away the top of the stack till we find the constructor(s)\n-   * of this Throwable or at least the contructors of java.lang.Throwable\n-   * or the actual fillInStackTrace call.\n-   * Also throw away from the top everything before and including a runtime\n-   * _Jv_Throw call.\n+   * Returns the source file name if lookup() was successful. If the source file could not be \n+   * determined, the binary name will be returned instead.\n    */\n-  private static StackTraceElement[] sanitizeStack(StackTraceElement[] elements,\n-\t\t\t\t\t\t   Throwable t)\n+  public String getSourceFile()\n   {\n-    StackTraceElement[] stack;\n-\n-    String className = t.getClass().getName();\n-    String consName;\n-    int lastDot = className.lastIndexOf('.');\n-    if (lastDot == -1)\n-      consName = className + '(';\n+    String file;\n+    if (sourceFile != null)\n+      file = sourceFile;\n     else\n-      consName = className.substring(lastDot + 1) + '(';\n-\n-    int unknown = 0;\n-    int internal = 0;\n-    int last_throw = -1;\n-    int length = elements.length;\n-    int end = length-1;\n-    for (int i = 0; i < length; i++)\n-      {\n-\tString CName = elements[i].getClassName();\n-\tString MName = elements[i].getMethodName();\n-\tif ((CName == null && MName != null && MName.startsWith(\"_Jv_Throw\"))\n-\t  ||\n-\t   (CName != null\n-\t    && (CName.equals(className)\n-\t\t|| CName.equals(\"java.lang.Throwable\")\n-\t\t|| CName.equals(\"java.lang.VMThrowable\"))\n-\t    && MName != null\n-\t    && (MName.startsWith(consName)\n-\t\t|| MName.startsWith(\"Throwable(\")\n-\t\t|| MName.startsWith(\"fillInStackTrace(\"))))\n-\t  {\n-\t    last_throw = i;\n-\t    // Reset counting of unknown and internal frames.\n-\t    unknown = 0;\n-\t    internal = 0;\n-\t  }\n-\telse if (remove_unknown && CName == null \n-\t\t && (MName == null || MName.startsWith(\"0x\")))\n-\t  unknown++;\n-\telse if (remove_internal\n-\t\t && ((CName == null\n-\t\t      && MName != null && MName.startsWith(\"ffi_\"))\n-\t\t     || (CName != null && CName.startsWith(\"_Jv_\"))\n-\t\t     || (CName == null && MName != null\n-\t\t\t && MName.startsWith(\"_Jv_\"))))\n-\t  internal++;\n-\telse if ((\"java.lang.Thread\".equals(CName)\n-\t\t  || \"gnu.java.lang.MainThread\".equals(CName))\n-\t\t && \"run()\".equals(MName))\n-\t  {\n-\t    end = i;\n-\t    break;\n-\t  }\n-      }\n-    int begin = last_throw+1;\n-\n-    // Now filter out everything at the start and the end that is not part\n-    // of the \"normal\" user program including any elements that are internal\n-    // calls or have no usefull information whatsoever.\n-    // Unless that means we filter out all info.\n-    int nr_elements = end - begin - unknown - internal + 1;\n-    if ((begin > 0 || end < length-1 || unknown > 0 || internal > 0)\n-\t&& nr_elements > 0)\n-      {\n-\tstack = new StackTraceElement[nr_elements];\n-\tint pos =0;\n-\tfor (int i=begin; i<=end; i++)\n-\t  {\n-\t    String MName = elements[i].getMethodName();\n-\t    String CName = elements[i].getClassName();\n-\t    if (remove_unknown && CName == null \n-\t\t && (MName == null || MName.startsWith(\"0x\")))\n-\t      ; // Skip unknown frame\n-\t    else if (remove_internal\n-\t\t     && ((CName == null\n-\t\t\t  && MName != null && MName.startsWith(\"ffi_\"))\n-\t\t\t || (CName != null && CName.startsWith(\"_Jv_\"))\n-\t\t\t || (CName == null && MName != null\n-\t\t\t     && MName.startsWith(\"_Jv_\"))))\n-\t      ; // Skip internal runtime frame\n-\t    else\n-\t      {\n-\t\t// Null Class or Method name in elements are not allowed.\n-\t\tif (MName == null || CName == null)\n-\t\t  {\n-\t\t    MName = MName == null ? \"\" : MName;\n-\t\t    CName = CName == null ? \"\" : CName;\n-\t\t    stack[pos] = newElement(elements[i].getFileName(),\n-\t\t\t\t\t    elements[i].getLineNumber(),\n-\t\t\t\t\t    CName, MName,\n-\t\t\t\t\t    elements[i].isNativeMethod());\n-\t\t  }\n-\t\telse\n-\t\t  stack[pos] = elements[i];\n-\t\tpos++;\n-\t      }\n-\t  }\n-      }\n-    else\n-      stack = elements;\n-\n-    return stack;\n+      file = binaryFile;\n+    \n+    return file.substring(file.lastIndexOf(File.separator) + 1, file.length());\n   }\n \n   /**\n-   * Native helper method to create a StackTraceElement. Needed to work\n-   * around normal Java access restrictions.\n-   */\n-  native static private StackTraceElement newElement(String fileName,\n-\t\t\t\t\t\t     int lineNumber,\n-\t\t\t\t\t\t     String className,\n-\t\t\t\t\t\t     String methName,\n-\t\t\t\t\t\t     boolean isNative);\n-\n-  /**\n-   * Creates a StackTraceElement given a string and a filename.\n-   * Splits the given string into the class and method part.\n-   * The string name will be a demangled to a fully qualified java method\n-   * string. The string file will be decomposed into a file name and possibly\n-   * a line number. The name should never be null, but the file may be if it\n-   * is unknown.\n-   */\n-  private StackTraceElement createStackTraceElement(String name, String file)\n+   * If lookup() was successful, returns the line number of addr. If the line number could not\n+   * be determined, -1 is returned.\n+   */  \n+  public int getLineNum()\n   {\n-    if (!demangle)\n-      return newElement(file, -1, null, name, false);\n-\n-    String s = demangleName(name);\n-    String methodName = s;\n-    String className = null;\n-    int bracket = s.indexOf('(');\n-    if (bracket > 0)\n+    return lineNum;\n+  }\n+  \n+  public void lookup (String file, long addr)\n+  {\n+    binaryFile = file;\n+    sourceFile = null;\n+    lineNum = -1;\n+    \n+    if (! use_addr2line)\n+      return;\n+    Addr2Line addr2line = (Addr2Line) procs.get(file);\n+    if (addr2line == null)\n       {\n-\tint dot = s.lastIndexOf('.', bracket);\n-\tif (dot > 0)\n-\t  {\n-\t    className = s.substring(0, dot);\n-\t    methodName = s.substring(dot+1, s.length());\n-\t  }\n+      addr2line = new Addr2Line(file);\n+      procs.put(file, addr2line);\n       }\n-\n-    String fileName = file;\n-    int line = -1;\n-    if (fileName != null)\n+    \n+    if (addr2line.proc == null)      \n+      return;\n+    \n+    String hexAddr = \"0x\" + Long.toHexString(addr);\n+    String name;\n+\n+    try\n       {\n-\tint colon = file.lastIndexOf(':');\n-\tif (colon > 0)\n-\t  {\n-\t    fileName = file.substring(0, colon);\n-\t    try\n-\t      {\n-\t\tline = Integer.parseInt(file.substring(colon+1, file.length()));\n-\t      }\n-\t    catch (NumberFormatException nfe) { /* ignore */ }\n-\t  }\n+      addr2line.out.write(hexAddr);\n+      addr2line.out.newLine();\n+      addr2line.out.flush();\n+      String result = addr2line.in.readLine();\n \n-\tif (line == 0)\n-\t  line =-1;\n-\n-\tif (\"\".equals(fileName) || \"??\".equals(fileName))\n-\t  fileName = null;\n-\telse if (fileName != null)\n-\t  {\n-\t    try\n-\t      {\n-\t\tfileName = new File(fileName).getCanonicalPath();\n-\t      }\n-\t    catch (IOException ioe) { /* ignore */ }\n-\t  }\n-      }\n-\n-    return newElement(fileName, line, className, methodName, false);\n-  }\n-\n-  /**\n-   * Demangles the given String if possible. Returns the demangled String or\n-   * the original string if demangling is impossible.\n-   */\n-  private String demangleName(String s)\n-  {\n-    if (cppfilt != null)\n-    {\n-      try\n+      if (result.indexOf(\"??\") == -1)\n \t{\n-\t  cppfiltOut.write(s);\n-\t  cppfiltOut.newLine();\n-\t  cppfiltOut.flush();\n-\t  return cppfiltIn.readLine();\n+\t  int split = result.lastIndexOf(':');\n+\t  sourceFile = result.substring(0, split);\n+\t  String lineNumStr = result.substring(split + 1, result.length());\n+\t  lineNum = Integer.parseInt (lineNumStr);\n \t}\n-      catch (IOException ioe) { cppfilt.destroy(); cppfilt = null; }\n-    }\n-\n-    return s;\n+      }\n+    catch (IOException ioe)\n+      {\n+      addr2line = null;\n+      }\n+    catch (NumberFormatException x)\n+      {\n+      }\n   }\n \n   /**\n@@ -508,7 +209,7 @@ public static String demangleInterpreterMethod(String m, String cn)\n     // Demangle the type arguments\n     int arrayDepth = 0;\n     char c = (index < length) ? m.charAt(index) : ')';\n-    while (c != ')')\n+    while (c != ')')      \n       {\n \tString type;\n \tswitch(c)\n@@ -581,18 +282,11 @@ public static String demangleInterpreterMethod(String m, String cn)\n    */\n   public void close()\n   {\n-    if (cppfilt != null)\n-      cppfilt.destroy();\n-\n-    if (addr2line != null)\n-      addr2line.destroy();\n-  }\n-\n-  /**\n-   * Calls close to get rid of all resources.\n-   */\n-  protected void finalize()\n-  {\n-    close();\n+    Iterator itr = procs.values().iterator();\n+    while (itr.hasNext())\n+      {\n+        Addr2Line proc = (Addr2Line) itr.next();\n+        proc.close();\n+      }\n   }\n }"}, {"sha": "44c20ff94d25cd42d6445f159ee2fec35d10349d", "filename": "libjava/gnu/java/lang/MainThread.java", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fgnu%2Fjava%2Flang%2FMainThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fgnu%2Fjava%2Flang%2FMainThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flang%2FMainThread.java?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -127,5 +127,7 @@ private String getMain(String name)\n     return mainName;\n   }\n \n+  // Note: this function name is known to the stack tracing code.\n+  // You shouldn't change this without also updating stacktrace.cc.\n   private native void call_main();\n }"}, {"sha": "569286116ee5c4be1522f4e8990aee69301bd8f2", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 63, "deletions": 13, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -23,6 +23,11 @@ details.  */\n #include <java/lang/ClassLoader.h>\n #include <java/lang/reflect/Modifier.h>\n \n+// Define this to get the direct-threaded interpreter.  If undefined,\n+// we revert to a basic bytecode interpreter.  The former is faster\n+// but uses more memory.\n+#define DIRECT_THREADED\n+\n extern \"C\" {\n #include <ffi.h>\n }\n@@ -95,6 +100,41 @@ class _Jv_MethodBase\n   }\n };\n \n+// The type of the PC depends on whether we're doing direct threading\n+// or a more ordinary bytecode interpreter.\n+#ifdef DIRECT_THREADED\n+// Slot in the \"compiled\" form of the bytecode.\n+union insn_slot\n+{\n+  // Address of code.\n+  void *insn;\n+  // An integer value used by an instruction.\n+  jint int_val;\n+  // A pointer value used by an instruction.\n+  void *datum;\n+};\n+\n+typedef insn_slot *pc_t;\n+#else\n+typedef unsigned char *pc_t;\n+#endif\n+\n+\n+// This structure holds the bytecode pc and corresponding source code\n+// line number.  An array (plus length field) of this structure is put\n+// in each _Jv_InterpMethod and used to resolve the (internal) program\n+// counter of the interpreted method to an actual java source file\n+// line.\n+struct  _Jv_LineTableEntry\n+{\n+  union\n+  {\n+    pc_t pc;\n+    int bytecode_pc;\n+  };\n+  int line;\n+};\n+\n class _Jv_InterpMethod : public _Jv_MethodBase\n {\n   _Jv_ushort       max_stack;\n@@ -103,6 +143,10 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n \n   _Jv_ushort       exc_count;\n \n+  // Length of the line_table - when this is zero then line_table is NULL.\n+  int line_table_len;  \n+  _Jv_LineTableEntry *line_table;\n+\n   void *prepared;\n \n   unsigned char* bytecode () \n@@ -135,17 +179,19 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n   static void run_class (ffi_cif*, void*, ffi_raw*, void*);\n   static void run_synch_class (ffi_cif*, void*, ffi_raw*, void*);\n \n-  void run (void*, ffi_raw *);\n+  static void run (void*, ffi_raw *, _Jv_InterpMethod *);\n+\n+  // Returns source file line number for given PC value, or -1 if line\n+  // number info is unavailable.\n+  int get_source_line(pc_t mpc);\n \n  public:\n   static void dump_object(jobject o);\n \n   friend class _Jv_ClassReader;\n   friend class _Jv_BytecodeVerifier;\n-  friend class gnu::gcj::runtime::NameFinder;\n-  friend class gnu::gcj::runtime::StackTrace;\n+  friend class _Jv_StackTrace;\n   friend class _Jv_InterpreterEngine;\n-  \n \n #ifdef JV_MARKOBJ_DECL\n   friend JV_MARKOBJ_DECL;\n@@ -155,11 +201,14 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n class _Jv_InterpClass\n {\n   _Jv_MethodBase **interpreted_methods;\n-  _Jv_ushort        *field_initializers;\n+  _Jv_ushort     *field_initializers;\n+  jstring source_file_name;\n \n   friend class _Jv_ClassReader;\n   friend class _Jv_InterpMethod;\n+  friend class _Jv_StackTrace;\n   friend class _Jv_InterpreterEngine;\n+\n   friend void  _Jv_InitField (jobject, jclass, int);\n #ifdef JV_MARKOBJ_DECL\n   friend JV_MARKOBJ_DECL;\n@@ -219,23 +268,24 @@ class _Jv_JNIMethod : public _Jv_MethodBase\n   }\n };\n \n-// A structure of this type is used to link together interpreter\n-// invocations on the stack.\n-struct _Jv_MethodChain\n+// The interpreted call stack, represented by a linked list of frames.\n+struct _Jv_InterpFrame\n {\n-  const _Jv_InterpMethod *self;\n-  _Jv_MethodChain **ptr;\n-  _Jv_MethodChain *next;\n+  _Jv_InterpMethod *self;\n+  _Jv_InterpFrame **ptr;\n+  _Jv_InterpFrame *next;\n+  pc_t pc;\n \n-  _Jv_MethodChain (const _Jv_InterpMethod *s, _Jv_MethodChain **n)\n+  _Jv_InterpFrame (_Jv_InterpMethod *s, _Jv_InterpFrame **n)\n   {\n     self = s;\n     ptr = n;\n     next = *n;\n     *n = this;\n+    pc = NULL;\n   }\n \n-  ~_Jv_MethodChain ()\n+  ~_Jv_InterpFrame ()\n   {\n     *ptr = next;\n   }"}, {"sha": "2d914cb9ba73d5461dd25eb6509ce8a2806a4c26", "filename": "libjava/include/java-stack.h", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Finclude%2Fjava-stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Finclude%2Fjava-stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-stack.h?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -1,6 +1,6 @@\n // java-stack.h - Definitions for unwinding & inspecting the call stack.\n \n-/* Copyright (C) 2003  Free Software Foundation\n+/* Copyright (C) 2005  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -21,10 +21,12 @@ details.  */\n #include <java/lang/Class.h>\n #include <java/lang/StackTraceElement.h>\n #include <java/lang/Throwable.h>\n+#include <java/lang/Thread.h>\n \n #include <gnu/gcj/runtime/NameFinder.h>\n \n using namespace gnu::gcj::runtime;\n+using namespace java::lang;\n \n enum _Jv_FrameType\n {\n@@ -51,34 +53,73 @@ struct _Jv_StackFrame\n #ifdef INTERPRETER\n     _Jv_InterpFrameInfo interp;\n #endif\n-    void *ip;  \n+    struct {\n+      void *ip;\n+      void *start_ip;\n+    };\n   };\n //  _Jv_FrameInfo info;   /* Frame-type specific data.  */\n   jclass klass;\n   _Jv_Method *meth;\n };\n \n+typedef struct _Jv_UnwindState;\n+typedef _Unwind_Reason_Code (*_Jv_TraceFn) (_Jv_UnwindState *);\n+\n+struct _Jv_UnwindState\n+{\n+  jint length;                   // length of FRAMES\n+  jint pos;                      // current position in FRAMES\n+  _Jv_StackFrame *frames;        // array of stack frame data to be filled.\n+  _Jv_InterpFrame *interp_frame; // current frame in the interpreter stack.\n+  _Jv_TraceFn trace_function;    // function to call back after each frame\n+  \t\t\t\t // is enumerated. May be NULL.\n+  void *trace_data;\t\t // additional state data for trace_function.\n+  \n+  _Jv_UnwindState (jint ln)\n+    {\n+      length = ln;\n+      pos = 0;\n+      frames = NULL;\n+      Thread *thread = Thread::currentThread();\n+      // Check for NULL currentThread(), in case an exception is created \n+      // very early during the runtime startup.\n+      if (thread)\n+\tinterp_frame = (_Jv_InterpFrame *) thread->interp_frame;\n+      trace_function = NULL;\n+      trace_data = NULL;\n+    }\n+};\n+\n class _Jv_StackTrace\n {\n private:\n   int length;\n   _Jv_StackFrame frames[];\n \n   static void UpdateNCodeMap ();\n-  static jclass ClassForIP (void *ip, void **ncode);\n+  static jclass ClassForFrame (_Jv_StackFrame *frame);\n   static void FillInFrameInfo (_Jv_StackFrame *frame);\n   static void getLineNumberForFrame(_Jv_StackFrame *frame, NameFinder *finder, \n \t\t\t     jstring *sourceFileName, jint *lineNum);\n   \n   static _Unwind_Reason_Code UnwindTraceFn (struct _Unwind_Context *context, \n     void *state_ptr);\n+    \n+  static _Unwind_Reason_Code calling_class_trace_fn (_Jv_UnwindState *state);\n+  static _Unwind_Reason_Code non_system_trace_fn (_Jv_UnwindState *state);\n \n public:\n   static _Jv_StackTrace *GetStackTrace (void);\n   static JArray< ::java::lang::StackTraceElement *>*\n     GetStackTraceElements (_Jv_StackTrace *trace, \n     java::lang::Throwable *throwable);\n-  static jclass GetCallingClass (void);\n+  static jclass GetCallingClass (jclass);\n+  static void GetCallerInfo (jclass checkClass, jclass *, _Jv_Method **);\n+  static JArray<jclass> *GetClassContext (jclass checkClass);\n+  static ClassLoader *GetFirstNonSystemClassLoader (void);\n+  \n };\n \n+\n #endif /* __JV_STACKTRACE_H__ */"}, {"sha": "4dfdb4d3767641a1f9e5d28733cde7cdfd043c83", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -120,20 +120,6 @@ union _Jv_value\n   jobject object_value;\n };\n \n-// An instance of this type is used to represent a single frame in a\n-// backtrace.  If the interpreter has been built, we also include\n-// information about the interpreted method.\n-struct _Jv_frame_info\n-{\n-  // PC value.\n-  void *addr;\n-#ifdef INTERPRETER\n-  // Actually a _Jv_InterpMethod, but we don't want to include\n-  // java-interp.h everywhere.\n-  void *interp;\n-#endif // INTERPRETER\n-};\n-\n /* Extract a character from a Java-style Utf8 string.\n  * PTR points to the current character.\n  * LIMIT points to the end of the Utf8 string."}, {"sha": "a2bcbb84084bd5937ee90ca56ac0a66790b64c70", "filename": "libjava/interpret.cc", "status": "modified", "additions": 81, "deletions": 78, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -13,11 +13,6 @@ details.  */\n #include <config.h>\n #include <platform.h>\n \n-// Define this to get the direct-threaded interpreter.  If undefined,\n-// we revert to a basic bytecode interpreter.  The former is faster\n-// but uses more memory.\n-#define DIRECT_THREADED\n-\n #pragma implementation \"java-interp.h\"\n \n #include <jvm.h>\n@@ -83,26 +78,6 @@ void _Jv_InitInterpreter() {}\n \n extern \"C\" double __ieee754_fmod (double,double);\n \n-// This represents a single slot in the \"compiled\" form of the\n-// bytecode.\n-union insn_slot\n-{\n-  // Address of code.\n-  void *insn;\n-  // An integer value used by an instruction.\n-  jint int_val;\n-  // A pointer value used by an instruction.\n-  void *datum;\n-};\n-\n-// The type of the PC depends on whether we're doing direct threading\n-// or a more ordinary bytecode interpreter.\n-#ifdef DIRECT_THREADED\n-typedef insn_slot *pc_t;\n-#else\n-typedef unsigned char *pc_t;\n-#endif\n-\n static inline void dupx (_Jv_word *sp, int n, int x)\n {\n   // first \"slide\" n+x elements n to the right\n@@ -117,7 +92,6 @@ static inline void dupx (_Jv_word *sp, int n, int x)\n     {\n       sp[top-(n+x)-i] = sp[top-i];\n     }\n-  \n }\n \n // Used to convert from floating types to integral types.\n@@ -248,15 +222,16 @@ static jint get4(unsigned char* loc) {\n        | (((jint)(loc[3])) << 0);\n }\n \n+#define SAVE_PC() frame_desc.pc = pc\n \n #ifdef HANDLE_SEGV\n-#define NULLCHECK(X) \n-#define NULLARRAYCHECK(X)\n+#define NULLCHECK(X) SAVE_PC()\n+#define NULLARRAYCHECK(X) SAVE_PC()\n #else\n #define NULLCHECK(X) \\\n-  do { if ((X)==NULL) throw_null_pointer_exception (); } while (0)\n+  do { SAVE_PC(); if ((X)==NULL) throw_null_pointer_exception (); } while (0)\n #define NULLARRAYCHECK(X) \\\n-  do { if ((X)==NULL) { throw_null_pointer_exception (); } } while (0)\n+  do { SAVE_PC(); if ((X)==NULL) { throw_null_pointer_exception (); } } while (0)\n #endif\n \n #define ARRAYBOUNDSCHECK(array, index)\t\t\t\t\t      \\\n@@ -274,7 +249,7 @@ _Jv_InterpMethod::run_normal (ffi_cif *,\n \t\t\t      void* __this)\n {\n   _Jv_InterpMethod *_this = (_Jv_InterpMethod *) __this;\n-  _this->run (ret, args);\n+  run (ret, args, _this);\n }\n \n void\n@@ -288,7 +263,7 @@ _Jv_InterpMethod::run_synch_object (ffi_cif *,\n   jobject rcv = (jobject) args[0].ptr;\n   JvSynchronize mutex (rcv);\n \n-  _this->run (ret, args);\n+  run (ret, args, _this);\n }\n \n void\n@@ -299,7 +274,7 @@ _Jv_InterpMethod::run_class (ffi_cif *,\n {\n   _Jv_InterpMethod *_this = (_Jv_InterpMethod *) __this;\n   _Jv_InitClass (_this->defining_class);\n-  _this->run (ret, args);\n+  run (ret, args, _this);\n }\n \n void\n@@ -314,7 +289,7 @@ _Jv_InterpMethod::run_synch_class (ffi_cif *,\n   _Jv_InitClass (sync);\n   JvSynchronize mutex (sync);\n \n-  _this->run (ret, args);\n+  run (ret, args, _this);\n }\n \n #ifdef DIRECT_THREADED\n@@ -783,50 +758,44 @@ _Jv_InterpMethod::compile (const void * const *insn_targets)\n       exc[i].handler_type.p = handler;\n     }\n \n+  // Translate entries in the LineNumberTable from bytecode PC's to direct\n+  // threaded interpreter instruction values.\n+  for (int i = 0; i < line_table_len; i++)\n+    {\n+      int byte_pc = line_table[i].bytecode_pc;\n+      line_table[i].pc = &insns[pc_mapping[byte_pc]];\n+    }  \n+\n   prepared = insns;\n }\n #endif /* DIRECT_THREADED */\n \n-// These exist so that the stack-tracing code can find the boundaries\n-// of the interpreter.\n-void *_Jv_StartOfInterpreter;\n-void *_Jv_EndOfInterpreter;\n-extern \"C\" void *_Unwind_FindEnclosingFunction (void *pc);\n-\n void\n-_Jv_InterpMethod::run (void *retp, ffi_raw *args)\n+_Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n {\n   using namespace java::lang::reflect;\n \n-  // Record the address of the start of this member function in\n-  // _Jv_StartOfInterpreter.  Such a write to a global variable\n-  // without acquiring a lock is correct iff reads and writes of words\n-  // in memory are atomic, but Java requires that anyway.\n- foo:\n-  if (_Jv_StartOfInterpreter == NULL)\n-    _Jv_StartOfInterpreter = _Unwind_FindEnclosingFunction (&&foo);\n-\n   // FRAME_DESC registers this particular invocation as the top-most\n   // interpreter frame.  This lets the stack tracing code (for\n   // Throwable) print information about the method being interpreted\n   // rather than about the interpreter itself.  FRAME_DESC has a\n   // destructor so it cleans up automatically when the interpreter\n   // returns.\n   java::lang::Thread *thread = java::lang::Thread::currentThread();\n-  _Jv_MethodChain frame_desc (this,\n-\t\t\t      (_Jv_MethodChain **) &thread->interp_frame);\n+  _Jv_InterpFrame frame_desc (meth,\n+\t\t\t      (_Jv_InterpFrame **) &thread->interp_frame);\n \n-  _Jv_word stack[max_stack];\n+  _Jv_word stack[meth->max_stack];\n   _Jv_word *sp = stack;\n \n-  _Jv_word locals[max_locals];\n+  _Jv_word locals[meth->max_locals];\n \n   /* Go straight at it!  the ffi raw format matches the internal\n      stack representation exactly.  At least, that's the idea.\n   */\n-  memcpy ((void*) locals, (void*) args, args_raw_size);\n+  memcpy ((void*) locals, (void*) args, meth->args_raw_size);\n \n-  _Jv_word *pool_data = defining_class->constants.data;\n+  _Jv_word *pool_data = meth->defining_class->constants.data;\n \n   /* These three are temporaries for common code used by several\n      instructions.  */\n@@ -1068,14 +1037,14 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n #define AMPAMP(label) &&label\n \n   // Compile if we must. NOTE: Double-check locking.\n-  if (prepared == NULL)\n+  if (meth->prepared == NULL)\n     {\n       _Jv_MutexLock (&compile_mutex);\n-      if (prepared == NULL)\n-\tcompile (insn_target);\n+      if (meth->prepared == NULL)\n+\tmeth->compile (insn_target);\n       _Jv_MutexUnlock (&compile_mutex);\n     }\n-  pc = (insn_slot *) prepared;\n+  pc = (insn_slot *) meth->prepared;\n \n #else\n \n@@ -1132,15 +1101,19 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n \t * the corresponding bit JV_CONSTANT_ResolvedFlag in the tag\n \t * directly.  For now, I don't think it is worth it.  */\n \n-\trmeth = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\tSAVE_PC();\n+\trmeth = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n \t\t\t\t\t\t   index)).rmethod;\n \n \tsp -= rmeth->stack_item_count;\n \t// We don't use NULLCHECK here because we can't rely on that\n \t// working if the method is final.  So instead we do an\n \t// explicit test.\n \tif (! sp[0].o)\n-\t  throw new java::lang::NullPointerException;\n+\t  {\n+\t    //printf(\"invokevirtual pc = %p/%i\\n\", pc, meth->get_pc_val(pc));\n+\t    throw new java::lang::NullPointerException;\n+\t  }\n \n \tif (rmeth->vtable_index == -1)\n \t  {\n@@ -1173,7 +1146,10 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n \t// working if the method is final.  So instead we do an\n \t// explicit test.\n \tif (! sp[0].o)\n-\t  throw new java::lang::NullPointerException;\n+\t  {\n+\t    SAVE_PC();\n+\t    throw new java::lang::NullPointerException;\n+\t  }\n \n \tif (rmeth->vtable_index == -1)\n \t  {\n@@ -1193,6 +1169,8 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n \n     perform_invoke:\n       {\n+        SAVE_PC();\n+\t\n \t/* here goes the magic again... */\n \tffi_cif *cif = &rmeth->cif;\n \tffi_raw *raw = (ffi_raw*) sp;\n@@ -2423,7 +2401,8 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n     insn_getstatic:\n       {\n \tjint fieldref_index = GET2U ();\n-\t_Jv_Linker::resolve_pool_entry (defining_class, fieldref_index);\n+        SAVE_PC(); // Constant pool resolution could throw.\n+\t_Jv_Linker::resolve_pool_entry (meth->defining_class, fieldref_index);\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \n \tif ((field->flags & Modifier::STATIC) == 0)\n@@ -2510,7 +2489,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n     insn_getfield:\n       {\n \tjint fieldref_index = GET2U ();\n-\t_Jv_Linker::resolve_pool_entry (defining_class, fieldref_index);\n+\t_Jv_Linker::resolve_pool_entry (meth->defining_class, fieldref_index);\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \n \tif ((field->flags & Modifier::STATIC) != 0)\n@@ -2626,7 +2605,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n     insn_putstatic:\n       {\n \tjint fieldref_index = GET2U ();\n-\t_Jv_Linker::resolve_pool_entry (defining_class, fieldref_index);\n+\t_Jv_Linker::resolve_pool_entry (meth->defining_class, fieldref_index);\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \n \tjclass type = field->type;\n@@ -2713,7 +2692,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n     insn_putfield:\n       {\n \tjint fieldref_index = GET2U ();\n-\t_Jv_Linker::resolve_pool_entry (defining_class, fieldref_index);\n+\t_Jv_Linker::resolve_pool_entry (meth->defining_class, fieldref_index);\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \n \tjclass type = field->type;\n@@ -2839,15 +2818,18 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n       {\n \tint index = GET2U ();\n \n-\trmeth = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\trmeth = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n \t\t\t\t\t\t   index)).rmethod;\n \n \tsp -= rmeth->stack_item_count;\n \n \t// We don't use NULLCHECK here because we can't rely on that\n \t// working for <init>.  So instead we do an explicit test.\n \tif (! sp[0].o)\n-\t  throw new java::lang::NullPointerException;\n+\t  {\n+\t    SAVE_PC();\n+\t    throw new java::lang::NullPointerException;\n+\t  }\n \n \tfun = (void (*)()) rmeth->method->ncode;\n \n@@ -2868,7 +2850,10 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n \t// We don't use NULLCHECK here because we can't rely on that\n \t// working for <init>.  So instead we do an explicit test.\n \tif (! sp[0].o)\n-\t  throw new java::lang::NullPointerException;\n+\t  {\n+\t    SAVE_PC();\n+\t    throw new java::lang::NullPointerException;\n+\t  }\n \tfun = (void (*)()) rmeth->method->ncode;\n       }\n       goto perform_invoke;\n@@ -2878,7 +2863,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n       {\n \tint index = GET2U ();\n \n-\trmeth = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\trmeth = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n \t\t\t\t\t\t   index)).rmethod;\n \n \tsp -= rmeth->stack_item_count;\n@@ -2908,7 +2893,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n       {\n \tint index = GET2U ();\n \n-\trmeth = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\trmeth = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n \t\t\t\t\t\t   index)).rmethod;\n \n \tsp -= rmeth->stack_item_count;\n@@ -2952,7 +2937,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n     insn_new:\n       {\n \tint index = GET2U ();\n-\tjclass klass = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\tjclass klass = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n \t\t\t\t\t\t\t  index)).clazz;\n \tjobject res = _Jv_AllocObject (klass);\n \tPUSHA (res);\n@@ -2986,7 +2971,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n     insn_anewarray:\n       {\n \tint index = GET2U ();\n-\tjclass klass = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\tjclass klass = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n \t\t\t\t\t\t\t  index)).clazz;\n \tint size  = POPI();\n \tjobject result = _Jv_NewObjectArray (size, klass, 0);\n@@ -3027,9 +3012,10 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n \n     insn_checkcast:\n       {\n+        SAVE_PC();\n \tjobject value = POPA();\n \tjint index = GET2U ();\n-\tjclass to = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\tjclass to = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n \t\t\t\t\t\t       index)).clazz;\n \n \tif (value != NULL && ! to->isInstance (value))\n@@ -3047,6 +3033,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n #ifdef DIRECT_THREADED\n     checkcast_resolved:\n       {\n+        SAVE_PC();\n \tjobject value = POPA ();\n \tjclass to = (jclass) AVAL ();\n \tif (value != NULL && ! to->isInstance (value))\n@@ -3058,9 +3045,10 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n \n     insn_instanceof:\n       {\n+        SAVE_PC();\n \tjobject value = POPA();\n \tjint index = GET2U ();\n-\tjclass to = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\tjclass to = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n \t\t\t\t\t\t       index)).clazz;\n \tPUSHI (to->isInstance (value));\n \n@@ -3123,7 +3111,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n \tint dim        = GET1U ();\n \n \tjclass type    \n-\t  = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\t  = (_Jv_Linker::resolve_pool_entry (meth->defining_class,\n \t\t\t\t\t       kind_index)).clazz;\n \tjint *sizes    = (jint*) __builtin_alloca (sizeof (jint)*dim);\n \n@@ -3212,10 +3200,10 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n #else\n       int logical_pc = pc - 1 - bytecode ();\n #endif\n-      _Jv_InterpException *exc = exceptions ();\n+      _Jv_InterpException *exc = meth->exceptions ();\n       jclass exc_class = ex->getClass ();\n \n-      for (int i = 0; i < exc_count; i++)\n+      for (int i = 0; i < meth->exc_count; i++)\n \t{\n \t  if (PCVAL (exc[i].start_pc) <= logical_pc\n \t      && logical_pc < PCVAL (exc[i].end_pc))\n@@ -3272,6 +3260,21 @@ throw_null_pointer_exception ()\n }\n #endif\n \n+/* Look up source code line number for given bytecode (or direct threaded\n+   interpreter) PC. */\n+int\n+_Jv_InterpMethod::get_source_line(pc_t mpc)\n+{\n+  int line = line_table_len > 0 ? line_table[0].line : -1;\n+  for (int i = 1; i < line_table_len; i++)\n+    if (line_table[i].pc > mpc)\n+      break;\n+    else\n+      line = line_table[i].line;\n+\n+  return line;\n+}\n+\n /** Do static initialization for fields with a constant initializer */\n void\n _Jv_InitField (jobject obj, jclass klass, int index)"}, {"sha": "46feff6280c2783928df8afdcf087202dabe7820", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -21,7 +21,6 @@ details.  */\n #include <java/lang/reflect/Modifier.h>\n #include <java/security/ProtectionDomain.h>\n #include <java/lang/Package.h>\n-#include <gnu/gcj/runtime/StackTrace.h>\n \n // We declare these here to avoid including gcj/cni.h.\n extern \"C\" void _Jv_InitClass (jclass klass);\n@@ -238,13 +237,13 @@ jclass _Jv_GetArrayClass (jclass klass, java::lang::ClassLoader *loader);\n jboolean _Jv_IsInterpretedClass (jclass);\n void _Jv_InitField (jobject, jclass, int);\n \n-class _Jv_ClassReader;\t\n+class _Jv_ClassReader;\n class _Jv_InterpClass;\n class _Jv_InterpMethod;\n #endif\n \n+class _Jv_StackTrace;\n class _Jv_BytecodeVerifier;\n-class gnu::gcj::runtime::StackTrace;\n class java::io::VMObjectStreamClass;\n \n void _Jv_sharedlib_register_hook (jclass klass);\n@@ -473,14 +472,14 @@ class java::lang::Class : public java::lang::Object\n   friend class ::_Jv_ClassReader;\t\n   friend class ::_Jv_InterpClass;\n   friend class ::_Jv_InterpMethod;\n+  friend class ::_Jv_StackTrace;\n #endif\n \n #ifdef JV_MARKOBJ_DECL\n   friend JV_MARKOBJ_DECL;\n #endif\n \n   friend class ::_Jv_BytecodeVerifier;\n-  friend class gnu::gcj::runtime::StackTrace;\n   friend class java::io::VMObjectStreamClass;\n \n   friend class ::_Jv_Linker;"}, {"sha": "c0739ba7e7ccbaf52a9824f430214678866212d6", "filename": "libjava/java/lang/VMClassLoader.java", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2FVMClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2FVMClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FVMClassLoader.java?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -304,12 +304,10 @@ static ClassLoader getSystemClassLoader()\n \t    default_sys\n \t      = (ClassLoader) c.newInstance(new Object[] { default_sys });\n \t  }\n-\tcatch (Exception e)\n+\tcatch (Exception ex)\n \t  {\n-\t    System.err.println(\"Requested system classloader \"\n-\t\t\t       + loader + \" failed, using \"\n-\t\t\t       + \"gnu.gcj.runtime.VMClassLoader\");\n-\t    e.printStackTrace();\n+\t    throw new Error(\"Failed to load requested system classloader \"\n+\t\t\t       + loader, ex);\n \t  }\n       }\n     return default_sys;"}, {"sha": "f3b079a566ebfe1fbe399f1db6953be427f67740", "filename": "libjava/java/lang/VMThrowable.java", "status": "modified", "additions": 9, "deletions": 35, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2FVMThrowable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2FVMThrowable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FVMThrowable.java?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -1,5 +1,5 @@\n /* java.lang.VMThrowable -- VM support methods for Throwable.\n-   Copyright (C) 1998, 1999, 2002, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2002, 2004, 2005 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,8 +37,7 @@\n \n package java.lang;\n \n-import gnu.gcj.runtime.NameFinder;\n-import gnu.gcj.runtime.StackTrace;\n+import gnu.gcj.RawDataManaged;\n \n /**\n  * VM dependent state and support methods Throwable.\n@@ -51,10 +50,8 @@\n  */\n final class VMThrowable\n {\n-  private gnu.gcj.runtime.StackTrace trace;\n-\n   /**\n-   * Private contructor, create VMThrowables with fillInStackTrace();\n+   * Private contructor, create VMThrowables with StackTrace();\n    */\n   private VMThrowable() { }\n \n@@ -67,20 +64,7 @@ private VMThrowable() { }\n    * @return a new VMThrowable containing the current execution stack trace.\n    * @see Throwable#fillInStackTrace()\n    */\n-  static VMThrowable fillInStackTrace(Throwable t)\n-  {\n-    VMThrowable state = null;\n-    \n-    /* FIXME: size of the stack trace is limited to 128 elements.\n-       It's undoubtedly sensible to limit the stack trace, but 128 is\n-       rather arbitrary.  It may be better to configure this.  */\n-    if (trace_enabled)\n-      {\n-\tstate = new VMThrowable ();\n-\tstate.trace = new gnu.gcj.runtime.StackTrace(128);\n-      }\n-    return state;\n-  }\n+  static native VMThrowable fillInStackTrace(Throwable t);\n \n   /**\n    * Returns an <code>StackTraceElement</code> array based on the execution\n@@ -90,21 +74,11 @@ static VMThrowable fillInStackTrace(Throwable t)\n    * @return a non-null but possible zero length array of StackTraceElement.\n    * @see Throwable#getStackTrace()\n    */\n-  StackTraceElement[] getStackTrace(Throwable t)\n-  {\n-    StackTraceElement[] result;\n-    if (trace != null)\n-      {\n-\tNameFinder nameFinder = new NameFinder();\n-\tresult = nameFinder.lookup(t, trace);\n-\tnameFinder.close();\n-      }\n-    else\n-      result = new StackTraceElement[0];\n-\n-    return result;\n-  }\n-\n+  native StackTraceElement[] getStackTrace(Throwable t);\n+  \n   // Setting this flag to false prevents fillInStackTrace() from running.\n   static boolean trace_enabled = true;\n+  \n+  // Native stack data.\n+  private RawDataManaged data;\n }"}, {"sha": "25343e38b056945b78184b76f2b5b26d7817ac37", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -53,7 +53,6 @@ details.  */\n #include <java/lang/SecurityManager.h>\n #include <java/lang/StringBuffer.h>\n #include <java/lang/VMClassLoader.h>\n-#include <gnu/gcj/runtime/StackTrace.h>\n #include <gcj/method.h>\n #include <gnu/gcj/runtime/MethodRef.h>\n #include <gnu/gcj/RawData.h>\n@@ -62,6 +61,7 @@ details.  */\n #include <java-cpool.h>\n #include <java-interp.h>\n #include <java-assert.h>\n+#include <java-stack.h>\n #include <execution.h>\n \n \f\n@@ -101,20 +101,10 @@ jclass\n java::lang::Class::forName (jstring className)\n {\n   java::lang::ClassLoader *loader = NULL;\n-  gnu::gcj::runtime::StackTrace *t \n-    = new gnu::gcj::runtime::StackTrace(4);\n-  java::lang::Class *klass = NULL;\n-  try\n-    {\n-      for (int i = 1; !klass; i++)\n-\t{\n-\t  klass = t->classAt (i);\n-\t}\n-      loader = klass->getClassLoaderInternal();\n-    }\n-  catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n-    {\n-    }\n+\n+  jclass caller = _Jv_StackTrace::GetCallingClass (&Class::class$);\n+  if (caller)\n+    loader = caller->getClassLoaderInternal();\n \n   return forName (className, true, loader);\n }\n@@ -125,21 +115,10 @@ java::lang::Class::getClassLoader (void)\n   java::lang::SecurityManager *s = java::lang::System::getSecurityManager();\n   if (s != NULL)\n     {\n-      gnu::gcj::runtime::StackTrace *t \n-\t= new gnu::gcj::runtime::StackTrace(4);\n-      Class *caller = NULL;\n+      jclass caller = _Jv_StackTrace::GetCallingClass (&Class::class$);\n       ClassLoader *caller_loader = NULL;\n-      try\n-\t{\n-\t  for (int i = 1; !caller; i++)\n-\t    {\n-\t      caller = t->classAt (i);\n-\t    }\n-\t  caller_loader = caller->getClassLoaderInternal();\n-\t}\n-      catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n-\t{\n-\t}\n+      if (caller)\n+\tcaller_loader = caller->getClassLoaderInternal();\n \n       // If the caller has a non-null class loader, and that loader\n       // is not this class' loader or an ancestor thereof, then do a"}, {"sha": "d013878834dca5b0895ba2b95535d01eb848885a", "filename": "libjava/java/lang/natRuntime.cc", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2FnatRuntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2FnatRuntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatRuntime.cc?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -16,6 +16,7 @@ details.  */\n #include <gcj/cni.h>\n #include <jvm.h>\n #include <java-props.h>\n+#include <java-stack.h>\n #include <java/lang/Long.h>\n #include <java/lang/Runtime.h>\n #include <java/lang/UnknownError.h>\n@@ -29,8 +30,6 @@ details.  */\n #include <java/lang/Process.h>\n #include <java/lang/ConcreteProcess.h>\n #include <java/lang/ClassLoader.h>\n-#include <gnu/gcj/runtime/StackTrace.h>\n-#include <java/lang/ArrayIndexOutOfBoundsException.h>\n \n #include <jni.h>\n \n@@ -164,27 +163,7 @@ java::lang::Runtime::_load (jstring path, jboolean do_search)\n   if (do_search)\n     {\n       ClassLoader *sys = ClassLoader::systemClassLoader;\n-      ClassLoader *look = NULL;\n-      gnu::gcj::runtime::StackTrace *t = new gnu::gcj::runtime::StackTrace(10);\n-      try\n-      \t{\n-\t  for (int i = 0; i < 10; ++i)\n-\t    {\n-\t      jclass klass = t->classAt(i);\n-\t      if (klass != NULL)\n-\t\t{\n-\t\t  ClassLoader *loader = klass->getClassLoaderInternal();\n-\t\t  if (loader != NULL && loader != sys)\n-\t\t    {\n-\t\t      look = loader;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-      catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n-\t{\n-\t}\n+      ClassLoader *look = _Jv_StackTrace::GetFirstNonSystemClassLoader ();\n \n       if (look != NULL)\n \t{"}, {"sha": "d55b7a54c3a938e5f2513aed49d8462fd69f0436", "filename": "libjava/java/lang/natVMSecurityManager.cc", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2FnatVMSecurityManager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2FnatVMSecurityManager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatVMSecurityManager.cc?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -12,43 +12,18 @@ details.  */\n \n #include <gcj/cni.h>\n #include <jvm.h>\n+#include <java-stack.h>\n+\n #include <java/lang/VMSecurityManager.h>\n #include <java/lang/SecurityManager.h>\n #include <java/lang/ClassLoader.h>\n #include <java/lang/Class.h>\n-#include <gnu/gcj/runtime/StackTrace.h>\n \n JArray<jclass> *\n java::lang::VMSecurityManager::getClassContext ()\n {\n-  JArray<jclass> *result = NULL;\n-  gnu::gcj::runtime::StackTrace *t = new gnu::gcj::runtime::StackTrace();\n-  if (t)\n-    {\n-      int maxlen = t->length();\n-\n-      int len = 0;\n-      for (int i=0; i<maxlen; i++)\n-\t{\n-\t  jclass klass = t->classAt(i);\n-\t  if (klass != NULL && klass != &java::lang::VMSecurityManager::class$\n-\t      && klass != &java::lang::SecurityManager::class$)\n-\t    ++len;\n-\t}\n-\n-      result =\n-\t(JArray<jclass> *) _Jv_NewObjectArray (len, &java::lang::Class::class$,\n-\t\t\t\t\t       NULL);\n-\n-      len = 0;\n-      for (int i=0; i<maxlen; i++)\n-\t{\n-\t  jclass klass = t->classAt(i);\n-\t  if (klass != NULL && klass != &java::lang::VMSecurityManager::class$\n-\t      && klass != &java::lang::SecurityManager::class$)\n-\t    elements(result)[len++] = klass;\n-\t}\n-    }\n+  JArray<jclass> *result = \n+    _Jv_StackTrace::GetClassContext (&SecurityManager::class$);\n \n   return result;\n }"}, {"sha": "6db1a1fd56d0a85fb1c4ddc4f3db4507a4f3fbbe", "filename": "libjava/java/lang/natVMThrowable.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2FnatVMThrowable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2FnatVMThrowable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatVMThrowable.cc?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -0,0 +1,45 @@\n+// natVMThrowable.cc - Native part of VMThrowable class.\n+\n+/* Copyright (C) 2003  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <stdlib.h>\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+#include <java-stack.h>\n+\n+#include <java/lang/Throwable.h>\n+#include <java/lang/VMThrowable.h>\n+\n+using namespace gnu::gcj;\n+\n+java::lang::VMThrowable *\n+java::lang::VMThrowable::fillInStackTrace (java::lang::Throwable *)\n+{\n+  using namespace java::lang;\n+\n+  // Don't trace stack during initialization of the runtime.\n+  if (! trace_enabled)\n+    return NULL;\n+  \n+  _Jv_StackTrace *trace = _Jv_StackTrace::GetStackTrace ();\n+  VMThrowable *vmthrowable = new VMThrowable ();\n+  vmthrowable->data = (RawDataManaged *) trace;\n+  return vmthrowable;\n+}\n+\n+\n+JArray< ::java::lang::StackTraceElement *> *\n+java::lang::VMThrowable::getStackTrace (java::lang::Throwable *throwable)\n+{\n+  _Jv_StackTrace *trace = reinterpret_cast <_Jv_StackTrace *> (data);\n+  return _Jv_StackTrace::GetStackTraceElements (trace, throwable);\n+}"}, {"sha": "b7bc8beff88fada8ceaaa0aae211af53bad46d48", "filename": "libjava/java/lang/reflect/natArray.cc", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2Freflect%2FnatArray.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2Freflect%2FnatArray.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatArray.cc?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -14,6 +14,7 @@ details.  */\n \n #include <jvm.h>\n #include <gcj/cni.h>\n+#include <java-stack.h>\n #include <java/lang/reflect/Array.h>\n #include <java/lang/ArrayIndexOutOfBoundsException.h>\n #include <java/lang/IllegalArgumentException.h>\n@@ -54,21 +55,10 @@ java::lang::reflect::Array::newInstance (jclass componentType,\n   if (ndims == 1)\n     return newInstance (componentType, dims[0]);\n \n-  gnu::gcj::runtime::StackTrace *t \n-    = new gnu::gcj::runtime::StackTrace(4);\n-  Class *caller = NULL;\n+  Class *caller = _Jv_StackTrace::GetCallingClass (&Array::class$);\n   ClassLoader *caller_loader = NULL;\n-  try\n-    {\n-      for (int i = 1; !caller; i++)\n-\t{\n-\t  caller = t->classAt (i);\n-\t}\n-      caller_loader = caller->getClassLoaderInternal();\n-    }\n-  catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n-    {\n-    }\n+  if (caller)\n+    caller_loader = caller->getClassLoaderInternal();\n \n   jclass arrayType = componentType;\n   for (int i = 0;  i < ndims;  i++)"}, {"sha": "f4d95905bfc1a980d502c92b01783ae4180d3c57", "filename": "libjava/java/lang/reflect/natConstructor.cc", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2Freflect%2FnatConstructor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2Freflect%2FnatConstructor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatConstructor.cc?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -12,6 +12,7 @@ details.  */\n \n #include <gcj/cni.h>\n #include <jvm.h>\n+#include <java-stack.h>\n \n #include <java/lang/ArrayIndexOutOfBoundsException.h>\n #include <java/lang/IllegalAccessException.h>\n@@ -55,20 +56,7 @@ java::lang::reflect::Constructor::newInstance (jobjectArray args)\n   // Check accessibility, if required.\n   if (! (Modifier::isPublic (meth->accflags) || this->isAccessible()))\n     {\n-      gnu::gcj::runtime::StackTrace *t \n-\t= new gnu::gcj::runtime::StackTrace(4);\n-      Class *caller = NULL;\n-      try\n-\t{\n-\t  for (int i = 1; !caller; i++)\n-\t    {\n-\t      caller = t->classAt (i);\n-\t    }\n-\t}\n-      catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n-\t{\n-\t}\n-\n+      Class *caller = _Jv_StackTrace::GetCallingClass (&Constructor::class$);\n       if (! _Jv_CheckAccess(caller, declaringClass, meth->accflags))\n \tthrow new IllegalAccessException;\n     }"}, {"sha": "33a5717f4b3805b05775f9ec30c1f83536cf51d1", "filename": "libjava/java/lang/reflect/natField.cc", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -13,6 +13,7 @@ details.  */\n #include <stdlib.h>\n \n #include <jvm.h>\n+#include <java-stack.h>\n #include <java/lang/reflect/Field.h>\n #include <java/lang/reflect/Modifier.h>\n #include <java/lang/ArrayIndexOutOfBoundsException.h>\n@@ -78,18 +79,7 @@ getAddr (java::lang::reflect::Field* field, jclass caller, jobject obj,\n   // Check accessibility, if required.\n   if (! (Modifier::isPublic (flags) || field->isAccessible()))\n     {\n-      gnu::gcj::runtime::StackTrace *t \n-\t= new gnu::gcj::runtime::StackTrace(7);\n-      try\n-\t{\n-\t  // We want to skip all the frames on the stack from this class.\n-\t  for (int i = 1; !caller || caller == &Field::class$; i++)\n-\t    caller = t->classAt (i);\n-\t}\n-      catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n-\t{\n-\t}\n-\n+      caller = _Jv_StackTrace::GetCallingClass (&Field::class$);\n       if (! _Jv_CheckAccess (caller, field->getDeclaringClass(), flags))\n \tthrow new java::lang::IllegalAccessException;\n     }"}, {"sha": "4329443146cd270dd685e4fac77ec8bbd4361b70", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -13,6 +13,7 @@ details.  */\n #include <gcj/cni.h>\n #include <jvm.h>\n #include <jni.h>\n+#include <java-stack.h>\n \n #include <java/lang/reflect/Method.h>\n #include <java/lang/reflect/Constructor.h>\n@@ -168,20 +169,7 @@ java::lang::reflect::Method::invoke (jobject obj, jobjectArray args)\n   // Check accessibility, if required.\n   if (! (Modifier::isPublic (meth->accflags) || this->isAccessible()))\n     {\n-      gnu::gcj::runtime::StackTrace *t \n-\t= new gnu::gcj::runtime::StackTrace(4);\n-      Class *caller = NULL;\n-      try\n-\t{\n-\t  for (int i = 1; !caller; i++)\n-\t    {\n-\t      caller = t->classAt (i);\n-\t    }\n-\t}\n-      catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n-\t{\n-\t}\n-\n+      Class *caller = _Jv_StackTrace::GetCallingClass (&Method::class$);\n       if (! _Jv_CheckAccess(caller, declaringClass, meth->accflags))\n \tthrow new IllegalAccessException;\n     }"}, {"sha": "e92c487c66f387c8a8566cc7cf4edf9c398180c6", "filename": "libjava/java/util/logging/natLogger.cc", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Futil%2Flogging%2FnatLogger.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Futil%2Flogging%2FnatLogger.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FnatLogger.cc?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -17,39 +17,27 @@ details.  */\n \n #include <gcj/cni.h>\n #include <jvm.h>\n-\n+#include <java-stack.h>\n \n #include <java/lang/Object.h>\n #include <java/lang/Class.h>\n #include <java/util/logging/Logger.h>\n #include <java/lang/StackTraceElement.h>\n #include <java/lang/ArrayIndexOutOfBoundsException.h>\n \n+using namespace java::util::logging;\n+\n java::lang::StackTraceElement* \n java::util::logging::Logger::getCallerStackFrame ()\n {\n-  gnu::gcj::runtime::StackTrace *t \n-    = new gnu::gcj::runtime::StackTrace(4);\n-  java::lang::Class *klass = NULL;\n-  int i = 2;\n-  try\n-    {\n-      // skip until this class\n-      while ((klass = t->classAt (i)) != getClass())\n-\ti++;\n-      // skip the stackentries of this class\n-      while ((klass = t->classAt (i)) == getClass() || klass == NULL)\n-\ti++;\n-    }\n-  catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n-    {\n-      // FIXME: RuntimeError\n-    }\n+  jclass klass = NULL;\n+  _Jv_Method *meth = NULL;\n+  _Jv_StackTrace::GetCallerInfo (&Logger::class$, &klass, &meth);\n \n   java::lang::StackTraceElement *e \n     = new java::lang::StackTraceElement\n     (JvNewStringUTF (\"\"), 0, \n-     klass->getName(), t->methodAt(i), false);\n+     klass->getName(), _Jv_NewStringUtf8Const (meth->name), false);\n \n   return e;\n }"}, {"sha": "e8d4fb4fd43a30a1f5bc23e69ffad17047f6a3c4", "filename": "libjava/java/util/natResourceBundle.cc", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Futil%2FnatResourceBundle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fjava%2Futil%2FnatResourceBundle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FnatResourceBundle.cc?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2002, 2003  Free Software Foundation\n+/* Copyright (C) 2002, 2003, 2005  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -12,31 +12,18 @@ details.  */\n \n #include <gcj/cni.h>\n #include <jvm.h>\n+#include <java-stack.h>\n #include <java/util/ResourceBundle.h>\n-#include <java/lang/SecurityManager.h>\n #include <java/lang/ClassLoader.h>\n #include <java/lang/Class.h>\n-#include <java/lang/ArrayIndexOutOfBoundsException.h>\n-#include <gnu/gcj/runtime/StackTrace.h>\n+\n+using namespace java::lang;\n \n java::lang::ClassLoader *\n java::util::ResourceBundle::getCallingClassLoader ()\n {\n-  gnu::gcj::runtime::StackTrace *t = new gnu::gcj::runtime::StackTrace(6);\n-  try\n-    {\n-      /* Frame 0 is this method, frame 1 is getBundle, so starting at\n-\t frame 2 we might see the user's class.  FIXME: should account\n-\t for reflection, JNI, etc, here.  */\n-      for (int i = 2; ; ++i)\n-\t{\n-\t  jclass klass = t->classAt(i);\n-\t  if (klass != NULL)\n-\t    return klass->getClassLoaderInternal();\n-\t}\n-    }\n-  catch (::java::lang::ArrayIndexOutOfBoundsException *e)\n-    {\n-    }\n+  jclass caller = _Jv_StackTrace::GetCallingClass (&ResourceBundle::class$);\n+  if (caller)\n+    return caller->getClassLoaderInternal();\n   return NULL;\n }"}, {"sha": "9281711ae89ca025f46d044a5b9ecb1ec1b24fdd", "filename": "libjava/prims.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -147,25 +147,25 @@ unblock_signal (int signum __attribute__ ((__unused__)))\n #ifdef HANDLE_SEGV\n SIGNAL_HANDLER (catch_segv)\n {\n-  java::lang::NullPointerException *nullp \n-    = new java::lang::NullPointerException;\n   unblock_signal (SIGSEGV);\n   MAKE_THROW_FRAME (nullp);\n+  java::lang::NullPointerException *nullp \n+    = new java::lang::NullPointerException;\n   throw nullp;\n }\n #endif\n \n #ifdef HANDLE_FPE\n SIGNAL_HANDLER (catch_fpe)\n {\n-  java::lang::ArithmeticException *arithexception \n-    = new java::lang::ArithmeticException (JvNewStringLatin1 (\"/ by zero\"));\n   unblock_signal (SIGFPE);\n #ifdef HANDLE_DIVIDE_OVERFLOW\n   HANDLE_DIVIDE_OVERFLOW;\n #else\n   MAKE_THROW_FRAME (arithexception);\n #endif\n+  java::lang::ArithmeticException *arithexception \n+    = new java::lang::ArithmeticException (JvNewStringLatin1 (\"/ by zero\"));\n   throw arithexception;\n }\n #endif"}, {"sha": "0777d903a2173fa48dedd18252f6ee0761f0aa99", "filename": "libjava/stacktrace.cc", "status": "added", "additions": 527, "deletions": 0, "changes": 527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fstacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fstacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fstacktrace.cc?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -0,0 +1,527 @@\n+// stacktrace.cc - Functions for unwinding & inspecting the call stack.\n+\n+/* Copyright (C) 2005  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <jvm.h>\n+#include <gcj/cni.h>\n+#include <java-interp.h>\n+#include <java-stack.h>\n+\n+#ifdef HAVE_DLFCN_H\n+#include <dlfcn.h>\n+#endif\n+\n+#include <stdio.h>\n+\n+#include <java/lang/Class.h>\n+#include <java/lang/Long.h>\n+#include <java/util/ArrayList.h>\n+#include <java/util/IdentityHashMap.h>\n+#include <gnu/java/lang/MainThread.h>\n+#include <gnu/gcj/runtime/NameFinder.h>\n+\n+#include <sysdep/backtrace.h>\n+\n+using namespace java::lang;\n+using namespace java::lang::reflect;\n+using namespace java::util;\n+using namespace gnu::gcj::runtime;\n+\n+struct _Jv_FindCallingClassState: _Jv_UnwindState\n+{\n+  jclass result;\n+};\n+\n+// Maps ncode values to their containing native class.\n+// NOTE: Currently this Map contradicts class GC for native classes. This map\n+// (and the \"new class stack\") will need to use WeakReferences in order to \n+// enable native class GC.\n+static java::util::IdentityHashMap *ncodeMap;\n+\n+// Check the \"class stack\" for any classes initialized since we were last \n+// called, and add them to ncodeMap.\n+void \n+_Jv_StackTrace::UpdateNCodeMap ()\n+{\n+  // The Map should be large enough so that a typical Java app doesn't cause \n+  // it to rehash, without using too much memory. ~5000 entries should be \n+  // enough.\n+  if (ncodeMap == NULL)\n+    ncodeMap = new java::util::IdentityHashMap (5087);\n+  \n+  jclass klass;\n+  while ((klass = _Jv_PopClass ()))\n+    {\n+      //printf (\"got %s\\n\", klass->name->data);\n+#ifdef INTERPRETER\n+      JvAssert (! _Jv_IsInterpretedClass (klass));\n+#endif\n+      for (int i=0; i < klass->method_count; i++)\n+        {\n+\t  _Jv_Method *method = &klass->methods[i];\n+\t  // Add non-abstract methods to ncodeMap.\n+\t  if (method->ncode)\n+\t    {\n+\t      //printf(\"map->put 0x%x / %s.%s\\n\", method->ncode, klass->name->data,\n+\t      //  method->name->data);\n+\t      ncodeMap->put ((java::lang::Object *) method->ncode, klass);\n+\t    }\n+\t}\n+    }\n+}\n+\n+// Given a native frame, return the class which this code belongs \n+// to. Returns NULL if this IP is not associated with a native Java class.\n+// If NCODE is supplied, it will be set with the ip for the entry point of the \n+// enclosing method.\n+jclass\n+_Jv_StackTrace::ClassForFrame (_Jv_StackFrame *frame)\n+{\n+  JvAssert (frame->type == frame_native);\n+  jclass klass = NULL;\n+  // use _Unwind_FindEnclosingFunction to find start of method\n+  //void *entryPoint = _Unwind_FindEnclosingFunction (ip);\n+\n+  // look it up in ncodeMap\n+  if (frame->start_ip)\n+    klass = (jclass) ncodeMap->get ((jobject) frame->start_ip);\n+\n+  return klass;\n+}\n+\n+_Unwind_Reason_Code\n+_Jv_StackTrace::UnwindTraceFn (struct _Unwind_Context *context, void *state_ptr)\n+{\n+  _Jv_UnwindState *state = (_Jv_UnwindState *) state_ptr;\n+  jint pos = state->pos;\n+\n+  // Check if the trace buffer needs to be extended.\n+  if (pos == state->length)\n+    {\n+      int newLength = state->length *= 2;\n+      void *newFrames = _Jv_AllocBytes (newLength * sizeof(_Jv_StackFrame));\n+      memcpy (newFrames, state->frames, state->length * sizeof(_Jv_StackFrame));      \n+      state->frames = (_Jv_StackFrame *) newFrames;\n+      state->length = newLength;\n+    }\n+  \n+  _Unwind_Ptr func_addr = _Unwind_GetRegionStart (context);\n+  \n+  // If we see the interpreter's main function, \"pop\" an entry off the \n+  // interpreter stack and use that instead, so that the trace goes through \n+  // the java code and not the interpreter itself. This assumes a 1:1 \n+  // correspondance between call frames in the interpreted stack and occurances\n+  // of _Jv_InterpMethod::run() on the native stack.\n+  if (func_addr == (_Unwind_Ptr) &_Jv_InterpMethod::run)\n+    {\n+      state->frames[pos].type = frame_interpreter;\n+      state->frames[pos].interp.meth = state->interp_frame->self;\n+      state->frames[pos].interp.pc = state->interp_frame->pc;\n+      state->interp_frame = state->interp_frame->next;\n+    }\n+  else\n+    {\n+      state->frames[pos].type = frame_native;\n+      state->frames[pos].ip = (void *) _Unwind_GetIP (context);\n+      state->frames[pos].start_ip = (void *) func_addr;\n+    }\n+\n+  //printf (\"unwind ip: %p\\n\", _Unwind_GetIP (context));\n+\n+  _Unwind_Reason_Code result = _URC_NO_REASON;\n+  if (state->trace_function != NULL)\n+    result = (state->trace_function) (state);\n+  state->pos++;\n+  return result;\n+}\n+\n+// Return a raw stack trace from the current point of execution. The raw \n+// trace will include all functions that have unwind info.\n+_Jv_StackTrace *\n+_Jv_StackTrace::GetStackTrace(void)\n+{\n+  int trace_size = 100;\n+  _Jv_StackFrame frames[trace_size];\n+  _Jv_UnwindState state (trace_size);\n+  state.frames = (_Jv_StackFrame *) &frames;\n+\n+#ifdef SJLJ_EXCEPTIONS\n+  // The Unwind interface doesn't work with the SJLJ exception model.\n+  // Fall back to a platform-specific unwinder.\n+  fallback_backtrace (&state);\n+#else /* SJLJ_EXCEPTIONS */  \n+  _Unwind_Backtrace (UnwindTraceFn, &state);\n+#endif /* SJLJ_EXCEPTIONS */\n+  \n+  // Copy the trace and return it.\n+  int traceSize = sizeof (_Jv_StackTrace) + \n+    (sizeof (_Jv_StackFrame) * state.pos);\n+  _Jv_StackTrace *trace = (_Jv_StackTrace *) _Jv_AllocBytes (traceSize);\n+  trace->length = state.pos;\n+  memcpy (trace->frames, state.frames, sizeof (_Jv_StackFrame) * state.pos);  \n+  return trace;\n+}\n+\n+void\n+_Jv_StackTrace::getLineNumberForFrame(_Jv_StackFrame *frame, NameFinder *finder, \n+\t\t jstring *sourceFileName, jint *lineNum)\n+{\n+  if (frame->type == frame_interpreter)\n+    {\n+      _Jv_InterpMethod *interp_meth = frame->interp.meth;\n+      _Jv_InterpClass *interp_class = \n+\t (_Jv_InterpClass *) interp_meth->defining_class->aux_info;\n+      *sourceFileName = interp_class->source_file_name;\n+      *lineNum = interp_meth->get_source_line(frame->interp.pc);\n+      return;\n+    }\n+  // Use dladdr() to determine in which binary the address IP resides.\n+#if defined (HAVE_DLFCN_H) && defined (HAVE_DLADDR)\n+  extern char **_Jv_argv;\n+  Dl_info info;\n+  jstring binaryName = NULL;\n+\n+  void *ip = frame->ip;\n+  _Unwind_Ptr offset = 0;\n+  \n+  if (dladdr (ip, &info))\n+    {\n+      if (info.dli_fname)\n+\tbinaryName = JvNewStringUTF (info.dli_fname);\n+      else\n+        return;\n+\n+      // addr2line expects relative addresses for shared libraries.\n+      if (strcmp (info.dli_fname, _Jv_argv[0]) == 0)\n+        offset = (_Unwind_Ptr) ip;\n+      else\n+        offset = (_Unwind_Ptr) ip - (_Unwind_Ptr) info.dli_fbase;\n+\n+      //printf (\"linenum ip: %p\\n\", ip);\n+      //printf (\"%s: 0x%x\\n\", info.dli_fname, offset);\n+      //offset -= sizeof(void *);\n+      \n+      // The unwinder gives us the return address. In order to get the right\n+      // line number for the stack trace, roll it back a little.\n+      offset -= 1;\n+\n+      // printf (\"%s: 0x%x\\n\", info.dli_fname, offset);\n+      \n+      finder->lookup (binaryName, (jlong) offset);\n+      *sourceFileName = finder->getSourceFile();\n+      *lineNum = finder->getLineNum();\n+    }\n+#endif\n+}\n+\n+// Look up class and method info for the given stack frame, setting \n+// frame->klass and frame->meth if they are known.\n+void\n+_Jv_StackTrace::FillInFrameInfo (_Jv_StackFrame *frame)\n+{\n+  jclass klass = NULL;\n+  _Jv_Method *meth = NULL;\n+  \n+  if (frame->type == frame_native)\n+    {\n+      klass = _Jv_StackTrace::ClassForFrame (frame);\n+\n+      if (klass != NULL)\n+\t// Find method in class\n+\tfor (int j = 0; j < klass->method_count; j++)\n+\t  {\n+\t    if (klass->methods[j].ncode == frame->start_ip)\n+\t      {\n+\t\tmeth = &klass->methods[j];\n+\t\tbreak;\n+\t      }\n+\t  }\n+    }\n+  else if (frame->type == frame_interpreter)\n+    {\n+      _Jv_InterpMethod *interp_meth = frame->interp.meth;\n+      klass = interp_meth->defining_class;\n+      meth = interp_meth->self;\n+    }\n+  else\n+    JvFail (\"Unknown frame type\");\n+  \n+  frame->klass = klass;\n+  frame->meth = meth;\n+}\n+\n+// Convert raw stack frames to a Java array of StackTraceElement objects.\n+JArray< ::java::lang::StackTraceElement *>*\n+_Jv_StackTrace::GetStackTraceElements (_Jv_StackTrace *trace, \n+  Throwable *throwable __attribute__((unused)))\n+{\n+  ArrayList *list = new ArrayList ();\n+\n+#ifdef SJLJ_EXCEPTIONS\n+  // We can't use the nCodeMap without unwinder support. Instead,\n+  // fake the method name by giving the IP in hex - better than nothing.  \n+  jstring hex = JvNewStringUTF (\"0x\");\n+\n+  for (int i = 0; i < trace->length; i++)\n+    {\n+      jstring sourceFileName = NULL;\n+      jint lineNum = -1;\n+      _Jv_StackFrame *frame = &trace->frames[i];\n+      \n+      jstring className = NULL;\n+      jstring methodName = hex->concat (Long::toHexString ((jlong) frame->ip));\n+\n+      StackTraceElement *element = new StackTraceElement (sourceFileName, \n+\tlineNum, className, methodName, 0);    \n+      list->add (element);\n+    }\n+\n+#else /* SJLJ_EXCEPTIONS */\n+\n+  //JvSynchronized (ncodeMap);\n+  UpdateNCodeMap ();\n+\n+  NameFinder *finder = new NameFinder();\n+  int start_idx = 0;\n+  int end_idx = trace->length - 1;\n+\n+  // First pass: strip superfluous frames from beginning and end of the trace.  \n+  for (int i = 0; i < trace->length; i++)\n+    {\n+      _Jv_StackFrame *frame = &trace->frames[i];\n+      FillInFrameInfo (frame);\n+\n+      if (!frame->klass || !frame->meth)\n+        // Not a Java frame.\n+        continue;\n+\n+      // Throw away the top of the stack till we see:\n+      //  - the constructor(s) of this Throwable, or\n+      //  - the Throwable.fillInStackTrace call.\n+      if (frame->klass == throwable->getClass()\n+          && strcmp (frame->meth->name->chars(), \"<init>\") == 0)\n+        start_idx = i + 1;\n+\n+      if (frame->klass == &Throwable::class$\n+          && strcmp (frame->meth->name->chars(), \"fillInStackTrace\") == 0)\n+\tstart_idx = i + 1;\n+\n+      // End the trace at the application's main() method if we see call_main.\n+      if (frame->klass == &gnu::java::lang::MainThread::class$\n+          && strcmp (frame->meth->name->chars(), \"call_main\") == 0)\n+\tend_idx = i - 1;\n+    }\n+  \n+  // Second pass: Look up line-number info for remaining frames.\n+  for (int i = start_idx; i <= end_idx; i++)\n+    {\n+      _Jv_StackFrame *frame = &trace->frames[i];\n+      \n+      if (frame->klass == NULL)\n+        // Not a Java frame.\n+\tcontinue;\n+      \n+      jstring className = frame->klass->getName ();\n+      jstring methodName = NULL;\n+      if (frame->meth)\n+        methodName = JvNewStringUTF (frame->meth->name->chars());\n+      \n+      jstring sourceFileName = NULL;\n+      jint lineNum = -1;\n+      \n+      getLineNumberForFrame(frame, finder, &sourceFileName, &lineNum);\n+      \n+      StackTraceElement *element = new StackTraceElement (sourceFileName, lineNum,\n+        className, methodName, 0);\n+      list->add (element);\n+    }\n+  \n+  finder->close();\n+#endif /* SJLJ_EXCEPTIONS */\n+\n+  JArray<Object *> *array = JvNewObjectArray (list->size (), \n+    &StackTraceElement::class$, NULL);\n+\n+  return (JArray<StackTraceElement *>*) list->toArray (array);\n+}\n+\n+struct CallingClassTraceData\n+{\n+  jclass checkClass;    \n+  jclass foundClass;\n+  _Jv_Method *foundMeth;\n+  bool seen_checkClass;\n+};\n+\n+_Unwind_Reason_Code\n+_Jv_StackTrace::calling_class_trace_fn (_Jv_UnwindState *state)\n+{\n+  CallingClassTraceData *trace_data = (CallingClassTraceData *)\n+    state->trace_data;\n+  _Jv_StackFrame *frame = &state->frames[state->pos];\n+  FillInFrameInfo (frame);\n+\n+  if (trace_data->seen_checkClass\n+      && frame->klass\n+      && frame->klass != trace_data->checkClass)\n+    {\n+      trace_data->foundClass = frame->klass;\n+      trace_data->foundMeth = frame->meth;\n+      return _URC_NORMAL_STOP;\n+    }\n+  \n+  if (frame->klass == trace_data->checkClass)\n+    trace_data->seen_checkClass = true;\n+    \n+  return _URC_NO_REASON;\n+}\n+\n+// Find the class immediately above the given class on the call stack. Any \n+// intermediate non-Java \n+// frames are ignored. If the calling class could not be determined (eg because \n+// the unwinder is not supported on this platform), NULL is returned.\n+// This function is used to implement calling-classloader checks and reflection\n+// accessibility checks.\n+// CHECKCLASS is typically the class calling GetCallingClass. The first class\n+// above CHECKCLASS on the call stack will be returned.\n+jclass\n+_Jv_StackTrace::GetCallingClass (jclass checkClass)\n+{\n+  jclass result = NULL;\n+  GetCallerInfo (checkClass, &result, NULL);\n+  return result;\n+}\n+\n+void\n+_Jv_StackTrace::GetCallerInfo (jclass checkClass, jclass *caller_class,\n+  _Jv_Method **caller_meth)\n+{\n+#ifndef SJLJ_EXCEPTIONS\n+  int trace_size = 20;\n+  _Jv_StackFrame frames[trace_size];\n+  _Jv_UnwindState state (trace_size);\n+  state.frames = (_Jv_StackFrame *) &frames;\n+\n+  CallingClassTraceData trace_data;\n+  trace_data.checkClass = checkClass;\n+  trace_data.seen_checkClass = false;\n+  trace_data.foundClass = NULL;\n+  trace_data.foundMeth = NULL;\n+\n+  state.trace_function = calling_class_trace_fn;\n+  state.trace_data = (void *) &trace_data;\n+\n+  //JvSynchronized (ncodeMap);\n+  UpdateNCodeMap ();\n+\n+  _Unwind_Backtrace (UnwindTraceFn, &state);\n+  \n+  if (caller_class)\n+    *caller_class = trace_data.foundClass;\n+  if (caller_meth)\n+    *caller_meth = trace_data.foundMeth;\n+#else\n+  return NULL;\n+#endif\n+}\n+\n+// Return a java array containing the Java classes on the stack above CHECKCLASS.\n+JArray<jclass> *\n+_Jv_StackTrace::GetClassContext (jclass checkClass)\n+{\n+  JArray<jclass> *result = NULL;\n+\n+  int trace_size = 100;\n+  _Jv_StackFrame frames[trace_size];\n+  _Jv_UnwindState state (trace_size);\n+  state.frames = (_Jv_StackFrame *) &frames;\n+\n+  //JvSynchronized (ncodeMap);\n+  UpdateNCodeMap ();\n+\n+  _Unwind_Backtrace (UnwindTraceFn, &state);\n+\n+  // Count the number of Java frames on the stack.\n+  int jframe_count = 0;\n+  bool seen_checkClass = false;\n+  int start_pos = -1;\n+  for (int i = 0; i < state.pos; i++)\n+    {\n+      _Jv_StackFrame *frame = &state.frames[i];\n+      FillInFrameInfo (frame);\n+      \n+      if (seen_checkClass\n+          && frame->klass\n+\t  && frame->klass != checkClass)\n+\t{\n+          jframe_count++;\n+\t  if (start_pos == -1)\n+\t    start_pos = i;\n+\t}\n+\n+      if (!seen_checkClass\n+          && frame->klass\n+          && frame->klass == checkClass)\n+        seen_checkClass = true;\n+    }\n+  result = (JArray<jclass> *) _Jv_NewObjectArray (jframe_count, &Class::class$, NULL);\n+  int pos = 0;\n+  \n+  for (int i = start_pos; i < state.pos; i++)\n+    {\n+      _Jv_StackFrame *frame = &state.frames[i];\n+      if (frame->klass)\n+        elements(result)[pos++] = frame->klass;\n+    }\n+  return result;\n+}\n+\n+_Unwind_Reason_Code\n+_Jv_StackTrace::non_system_trace_fn (_Jv_UnwindState *state)\n+{\n+  _Jv_StackFrame *frame = &state->frames[state->pos];\n+  FillInFrameInfo (frame);\n+  \n+  ClassLoader *classLoader = NULL;\n+\n+  if (frame->klass)\n+    {\n+      classLoader = frame->klass->getClassLoaderInternal();\n+      if (classLoader != NULL && classLoader != ClassLoader::systemClassLoader)\n+        {\n+          state->trace_data = (void *) classLoader;\n+\t  return _URC_NORMAL_STOP;\n+\t}\n+    }\n+\n+  return _URC_NO_REASON;\n+}\n+\n+ClassLoader *\n+_Jv_StackTrace::GetFirstNonSystemClassLoader ()\n+{\n+  int trace_size = 32;\n+  _Jv_StackFrame frames[trace_size];\n+  _Jv_UnwindState state (trace_size);\n+  state.frames = (_Jv_StackFrame *) &frames;\n+  state.trace_function = non_system_trace_fn;\n+  state.trace_data = NULL;\n+\n+  //JvSynchronized (ncodeMap);\n+  UpdateNCodeMap ();\n+  \n+  _Unwind_Backtrace (UnwindTraceFn, &state);\n+\n+  if (state.trace_data)\n+    return (ClassLoader *) state.trace_data;\n+  \n+  return NULL;\n+}"}, {"sha": "fe9d68f1b70b732dcbb7d33b59ee639a7663f026", "filename": "libjava/sysdep/generic/backtrace.h", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fsysdep%2Fgeneric%2Fbacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fsysdep%2Fgeneric%2Fbacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fgeneric%2Fbacktrace.h?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -0,0 +1,22 @@\n+// backtrace.h - Fallback backtrace implementation. default implementation.\n+\n+/* Copyright (C) 2005  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __SYSDEP_BACKTRACE_H__\n+#define __SYSDEP_BACKTRACE_H__\n+\n+#include <java-stack.h>\n+\n+/* Store return addresses of the current program stack in\n+   STATE and return the exact number of values stored.  */\n+void\n+fallback_backtrace (_Jv_UnwindState *)\n+{\n+}\n+#endif"}, {"sha": "b10840213a4448d2bdb12a7418c9197ef832fc4a", "filename": "libjava/sysdep/i386/backtrace.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fsysdep%2Fi386%2Fbacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18744d9b72b028b5612e250966f9d165a40ae9d8/libjava%2Fsysdep%2Fi386%2Fbacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fi386%2Fbacktrace.h?ref=18744d9b72b028b5612e250966f9d165a40ae9d8", "patch": "@@ -0,0 +1,42 @@\n+// backtrace.h - Fallback backtrace implementation. i386 implementation.\n+\n+/* Copyright (C) 2005  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __SYSDEP_BACKTRACE_H__\n+#define __SYSDEP_BACKTRACE_H__\n+\n+#include <java-stack.h>\n+\n+#define HAVE_FALLBACK_BACKTRACE\n+\n+/* Store return addresses of the current program stack in\n+   STATE and return the exact number of values stored.  */\n+void\n+fallback_backtrace (_Jv_UnwindState *state)\n+{\n+  register void *_ebp __asm__ (\"ebp\");\n+  register void *_esp __asm__ (\"esp\");\n+  unsigned int *rfp;\n+\n+  int i = state->pos;\n+  for (rfp = *(unsigned int**)_ebp;\n+       rfp && i < state->length;\n+       rfp = *(unsigned int **)rfp)\n+    {\n+      int diff = *rfp - (unsigned int)rfp;\n+      if ((void*)rfp < _esp || diff > 4 * 1024 || diff < 0)\n+        break;\n+\n+      state->frames[i].type = frame_native;\n+      state->frames[i].ip = (void*)(rfp[1]-4);\n+      i++;\n+    }\n+  state->pos = i;\n+}\n+#endif"}]}