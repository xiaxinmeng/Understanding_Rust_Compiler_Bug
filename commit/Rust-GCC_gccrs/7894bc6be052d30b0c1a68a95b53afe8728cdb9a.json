{"sha": "7894bc6be052d30b0c1a68a95b53afe8728cdb9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg5NGJjNmJlMDUyZDMwYjBjMWE2OGE5NWI1M2FmZTg3MjhjZGI5YQ==", "commit": {"author": {"name": "Joern Rennecke", "email": "joern.rennecke@embecosm.com", "date": "2013-05-27T10:39:01Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2013-05-27T10:39:01Z"}, "message": "re PR rtl-optimization/56833 (Valid register is over written by postreload pass)\n\n        PR rtl-optimization/56833\n        * postreload.c (move2add_record_mode): New function.\n        (move2add_record_sym_value, move2add_valid_value_p): Likewise.\n        (move2add_use_add2_insn): Use move2add_record_sym_value.\n        (move2add_use_add3_insn): Likewise.\n        (reload_cse_move2add): Use move2add_valid_value_p and\n        move2add_record_mode.  Invalidate call-clobbered and REG_INC\n        affected regs by setting reg_mode to VOIDmode.\n        (move2add_note_store): Don't pretend the inside of a SUBREG is\n        the actual destination.  Invalidate single/leading registers by\n        setting reg_mode to VOIDmode.\n        Use move2add_record_sym_value, move2add_valid_value_p and\n        move2add_record_mode.\n\nFrom-SVN: r199353", "tree": {"sha": "d24a495dc651ed8a16b16f66521c967c0731060a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d24a495dc651ed8a16b16f66521c967c0731060a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7894bc6be052d30b0c1a68a95b53afe8728cdb9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7894bc6be052d30b0c1a68a95b53afe8728cdb9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7894bc6be052d30b0c1a68a95b53afe8728cdb9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7894bc6be052d30b0c1a68a95b53afe8728cdb9a/comments", "author": {"login": "amylaar", "id": 1663475, "node_id": "MDQ6VXNlcjE2NjM0NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/1663475?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amylaar", "html_url": "https://github.com/amylaar", "followers_url": "https://api.github.com/users/amylaar/followers", "following_url": "https://api.github.com/users/amylaar/following{/other_user}", "gists_url": "https://api.github.com/users/amylaar/gists{/gist_id}", "starred_url": "https://api.github.com/users/amylaar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amylaar/subscriptions", "organizations_url": "https://api.github.com/users/amylaar/orgs", "repos_url": "https://api.github.com/users/amylaar/repos", "events_url": "https://api.github.com/users/amylaar/events{/privacy}", "received_events_url": "https://api.github.com/users/amylaar/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4fed6b2544d5b6678ff139e3f1e1fd993747fc83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fed6b2544d5b6678ff139e3f1e1fd993747fc83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fed6b2544d5b6678ff139e3f1e1fd993747fc83"}], "stats": {"total": 211, "additions": 125, "deletions": 86}, "files": [{"sha": "a8c366b608682b4921addab0661d12ed112f8f47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7894bc6be052d30b0c1a68a95b53afe8728cdb9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7894bc6be052d30b0c1a68a95b53afe8728cdb9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7894bc6be052d30b0c1a68a95b53afe8728cdb9a", "patch": "@@ -1,3 +1,19 @@\n+2013-05-27  Joern Rennecke <joern.rennecke@embecosm.com>\n+\n+\tPR rtl-optimization/56833\n+\t* postreload.c (move2add_record_mode): New function.\n+\t(move2add_record_sym_value, move2add_valid_value_p): Likewise.\n+\t(move2add_use_add2_insn): Use move2add_record_sym_value.\n+\t(move2add_use_add3_insn): Likewise.\n+\t(reload_cse_move2add): Use move2add_valid_value_p and\n+\tmove2add_record_mode.  Invalidate call-clobbered and REG_INC\n+\taffected regs by setting reg_mode to VOIDmode.\n+\t(move2add_note_store): Don't pretend the inside of a SUBREG is\n+\tthe actual destination.  Invalidate single/leading registers by\n+\tsetting reg_mode to VOIDmode.\n+\tUse move2add_record_sym_value, move2add_valid_value_p and\n+\tmove2add_record_mode.\n+\n 2013-05-27  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/57396"}, {"sha": "3d75eaf4fef0cded3cfcf5a0aeee341475546533", "filename": "gcc/postreload.c", "status": "modified", "additions": 109, "deletions": 86, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7894bc6be052d30b0c1a68a95b53afe8728cdb9a/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7894bc6be052d30b0c1a68a95b53afe8728cdb9a/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=7894bc6be052d30b0c1a68a95b53afe8728cdb9a", "patch": "@@ -1645,14 +1645,22 @@ reload_combine_note_use (rtx *xp, rtx insn, int ruid, rtx containing_mem)\n    later disable any optimization that would cross it.\n    reg_offset[n] / reg_base_reg[n] / reg_symbol_ref[n] / reg_mode[n]\n    are only valid if reg_set_luid[n] is greater than\n-   move2add_last_label_luid.  */\n+   move2add_last_label_luid.\n+   For a set that established a new (potential) base register with\n+   non-constant value, we use move2add_luid from the place where the\n+   setting insn is encountered; registers based off that base then\n+   get the same reg_set_luid.  Constants all get\n+   move2add_last_label_luid + 1 as their reg_set_luid.  */\n static int reg_set_luid[FIRST_PSEUDO_REGISTER];\n \n /* If reg_base_reg[n] is negative, register n has been set to\n    reg_offset[n] or reg_symbol_ref[n] + reg_offset[n] in mode reg_mode[n].\n    If reg_base_reg[n] is non-negative, register n has been set to the\n    sum of reg_offset[n] and the value of register reg_base_reg[n]\n-   before reg_set_luid[n], calculated in mode reg_mode[n] .  */\n+   before reg_set_luid[n], calculated in mode reg_mode[n] .\n+   For multi-hard-register registers, all but the first one are\n+   recorded as BLKmode in reg_mode.  Setting reg_mode to VOIDmode\n+   marks it as invalid.  */\n static HOST_WIDE_INT reg_offset[FIRST_PSEUDO_REGISTER];\n static int reg_base_reg[FIRST_PSEUDO_REGISTER];\n static rtx reg_symbol_ref[FIRST_PSEUDO_REGISTER];\n@@ -1674,6 +1682,60 @@ static int move2add_last_label_luid;\n    || (GET_MODE_SIZE (OUTMODE) <= GET_MODE_SIZE (INMODE) \\\n        && TRULY_NOOP_TRUNCATION_MODES_P (OUTMODE, INMODE)))\n \n+/* Record that REG is being set to a value with the mode of REG.  */\n+\n+static void\n+move2add_record_mode (rtx reg)\n+{\n+  int regno, nregs;\n+  enum machine_mode mode = GET_MODE (reg);\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    {\n+      regno = subreg_regno (reg);\n+      nregs = subreg_nregs (reg);\n+    }\n+  else if (REG_P (reg))\n+    {\n+      regno = REGNO (reg);\n+      nregs = hard_regno_nregs[regno][mode];\n+    }\n+  else\n+    gcc_unreachable ();\n+  for (int i = nregs - 1; i > 0; i--)\n+    reg_mode[regno + i] = BLKmode;\n+  reg_mode[regno] = mode;\n+}\n+\n+/* Record that REG is being set to the sum of SYM and OFF.  */\n+\n+static void\n+move2add_record_sym_value (rtx reg, rtx sym, rtx off)\n+{\n+  int regno = REGNO (reg);\n+\n+  move2add_record_mode (reg);\n+  reg_set_luid[regno] = move2add_luid;\n+  reg_base_reg[regno] = -1;\n+  reg_symbol_ref[regno] = sym;\n+  reg_offset[regno] = INTVAL (off);\n+}\n+\n+/* Check if REGNO contains a valid value in MODE.  */\n+\n+static bool\n+move2add_valid_value_p (int regno, enum machine_mode mode)\n+{\n+  if (reg_set_luid[regno] <= move2add_last_label_luid\n+      || !MODES_OK_FOR_MOVE2ADD (mode, reg_mode[regno]))\n+    return false;\n+\n+  for (int i = hard_regno_nregs[regno][mode] - 1; i > 0; i--)\n+    if (reg_mode[regno + i] != BLKmode)\n+      return false;\n+  return true;\n+}\n+\n /* This function is called with INSN that sets REG to (SYM + OFF),\n    while REG is known to already have value (SYM + offset).\n    This function tries to change INSN into an add instruction\n@@ -1749,11 +1811,7 @@ move2add_use_add2_insn (rtx reg, rtx sym, rtx off, rtx insn)\n \t    }\n \t}\n     }\n-  reg_set_luid[regno] = move2add_luid;\n-  reg_base_reg[regno] = -1;\n-  reg_mode[regno] = GET_MODE (reg);\n-  reg_symbol_ref[regno] = sym;\n-  reg_offset[regno] = INTVAL (off);\n+  move2add_record_sym_value (reg, sym, off);\n   return changed;\n }\n \n@@ -1787,8 +1845,7 @@ move2add_use_add3_insn (rtx reg, rtx sym, rtx off, rtx insn)\n   SET_SRC (pat) = plus_expr;\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (reg_set_luid[i] > move2add_last_label_luid\n-\t&& reg_mode[i] == GET_MODE (reg)\n+    if (move2add_valid_value_p (i, GET_MODE (reg))\n \t&& reg_base_reg[i] < 0\n \t&& reg_symbol_ref[i] != NULL_RTX\n \t&& rtx_equal_p (sym, reg_symbol_ref[i]))\n@@ -1836,10 +1893,7 @@ move2add_use_add3_insn (rtx reg, rtx sym, rtx off, rtx insn)\n \tchanged = true;\n     }\n   reg_set_luid[regno] = move2add_luid;\n-  reg_base_reg[regno] = -1;\n-  reg_mode[regno] = GET_MODE (reg);\n-  reg_symbol_ref[regno] = sym;\n-  reg_offset[regno] = INTVAL (off);\n+  move2add_record_sym_value (reg, sym, off);\n   return changed;\n }\n \n@@ -1890,8 +1944,7 @@ reload_cse_move2add (rtx first)\n \n \t  /* Check if we have valid information on the contents of this\n \t     register in the mode of REG.  */\n-\t  if (reg_set_luid[regno] > move2add_last_label_luid\n-\t      && MODES_OK_FOR_MOVE2ADD (GET_MODE (reg), reg_mode[regno])\n+\t  if (move2add_valid_value_p (regno, GET_MODE (reg))\n               && dbg_cnt (cse2_move2add))\n \t    {\n \t      /* Try to transform (set (REGX) (CONST_INT A))\n@@ -1928,8 +1981,7 @@ reload_cse_move2add (rtx first)\n \t      else if (REG_P (src)\n \t\t       && reg_set_luid[regno] == reg_set_luid[REGNO (src)]\n \t\t       && reg_base_reg[regno] == reg_base_reg[REGNO (src)]\n-\t\t       && MODES_OK_FOR_MOVE2ADD (GET_MODE (reg),\n-\t\t\t\t\t\t reg_mode[REGNO (src)]))\n+\t\t       && move2add_valid_value_p (REGNO (src), GET_MODE (reg)))\n \t\t{\n \t\t  rtx next = next_nonnote_nondebug_insn (insn);\n \t\t  rtx set = NULL_RTX;\n@@ -1982,10 +2034,10 @@ reload_cse_move2add (rtx first)\n \t\t\tdelete_insn (insn);\n \t\t      changed |= success;\n \t\t      insn = next;\n-\t\t      reg_mode[regno] = GET_MODE (reg);\n-\t\t      reg_offset[regno] =\n-\t\t\ttrunc_int_for_mode (added_offset + base_offset,\n-\t\t\t\t\t    GET_MODE (reg));\n+\t\t      move2add_record_mode (reg);\n+\t\t      reg_offset[regno]\n+\t\t\t= trunc_int_for_mode (added_offset + base_offset,\n+\t\t\t\t\t      GET_MODE (reg));\n \t\t      continue;\n \t\t    }\n \t\t}\n@@ -2021,8 +2073,7 @@ reload_cse_move2add (rtx first)\n \n \t      /* If the reg already contains the value which is sum of\n \t\t sym and some constant value, we can use an add2 insn.  */\n-\t      if (reg_set_luid[regno] > move2add_last_label_luid\n-\t\t  && MODES_OK_FOR_MOVE2ADD (GET_MODE (reg), reg_mode[regno])\n+\t      if (move2add_valid_value_p (regno, GET_MODE (reg))\n \t\t  && reg_base_reg[regno] < 0\n \t\t  && reg_symbol_ref[regno] != NULL_RTX\n \t\t  && rtx_equal_p (sym, reg_symbol_ref[regno]))\n@@ -2045,7 +2096,10 @@ reload_cse_move2add (rtx first)\n \t      /* Reset the information about this register.  */\n \t      int regno = REGNO (XEXP (note, 0));\n \t      if (regno < FIRST_PSEUDO_REGISTER)\n-\t\treg_set_luid[regno] = 0;\n+\t\t{\n+\t\t  move2add_record_mode (XEXP (note, 0));\n+\t\t  reg_mode[regno] = VOIDmode;\n+\t\t}\n \t    }\n \t}\n       note_stores (PATTERN (insn), move2add_note_store, insn);\n@@ -2082,7 +2136,7 @@ reload_cse_move2add (rtx first)\n \t    {\n \t      if (call_used_regs[i])\n \t\t/* Reset the information about this register.  */\n-\t\treg_set_luid[i] = 0;\n+\t\treg_mode[i] = VOIDmode;\n \t    }\n \t}\n     }\n@@ -2099,81 +2153,63 @@ move2add_note_store (rtx dst, const_rtx set, void *data)\n {\n   rtx insn = (rtx) data;\n   unsigned int regno = 0;\n-  unsigned int nregs = 0;\n-  unsigned int i;\n   enum machine_mode mode = GET_MODE (dst);\n \n-  if (GET_CODE (dst) == SUBREG)\n-    {\n-      regno = subreg_regno_offset (REGNO (SUBREG_REG (dst)),\n-\t\t\t\t   GET_MODE (SUBREG_REG (dst)),\n-\t\t\t\t   SUBREG_BYTE (dst),\n-\t\t\t\t   GET_MODE (dst));\n-      nregs = subreg_nregs (dst);\n-      dst = SUBREG_REG (dst);\n-    }\n-\n   /* Some targets do argument pushes without adding REG_INC notes.  */\n \n   if (MEM_P (dst))\n     {\n       dst = XEXP (dst, 0);\n       if (GET_CODE (dst) == PRE_INC || GET_CODE (dst) == POST_INC\n \t  || GET_CODE (dst) == PRE_DEC || GET_CODE (dst) == POST_DEC)\n-\treg_set_luid[REGNO (XEXP (dst, 0))] = 0;\n+\treg_mode[REGNO (XEXP (dst, 0))] = VOIDmode;\n       return;\n     }\n-  if (!REG_P (dst))\n-    return;\n \n-  regno += REGNO (dst);\n-  if (!nregs)\n-    nregs = hard_regno_nregs[regno][mode];\n+  if (GET_CODE (dst) == SUBREG)\n+    regno = subreg_regno (dst);\n+  else if (REG_P (dst))\n+    regno = REGNO (dst);\n+  else\n+    return;\n \n-  if (SCALAR_INT_MODE_P (GET_MODE (dst))\n-      && nregs == 1 && GET_CODE (set) == SET)\n+  if (SCALAR_INT_MODE_P (mode)\n+      && GET_CODE (set) == SET)\n     {\n       rtx note, sym = NULL_RTX;\n-      HOST_WIDE_INT off;\n+      rtx off;\n \n       note = find_reg_equal_equiv_note (insn);\n       if (note && GET_CODE (XEXP (note, 0)) == SYMBOL_REF)\n \t{\n \t  sym = XEXP (note, 0);\n-\t  off = 0;\n+\t  off = const0_rtx;\n \t}\n       else if (note && GET_CODE (XEXP (note, 0)) == CONST\n \t       && GET_CODE (XEXP (XEXP (note, 0), 0)) == PLUS\n \t       && GET_CODE (XEXP (XEXP (XEXP (note, 0), 0), 0)) == SYMBOL_REF\n \t       && CONST_INT_P (XEXP (XEXP (XEXP (note, 0), 0), 1)))\n \t{\n \t  sym = XEXP (XEXP (XEXP (note, 0), 0), 0);\n-\t  off = INTVAL (XEXP (XEXP (XEXP (note, 0), 0), 1));\n+\t  off = XEXP (XEXP (XEXP (note, 0), 0), 1);\n \t}\n \n       if (sym != NULL_RTX)\n \t{\n-\t  reg_base_reg[regno] = -1;\n-\t  reg_symbol_ref[regno] = sym;\n-\t  reg_offset[regno] = off;\n-\t  reg_mode[regno] = mode;\n-\t  reg_set_luid[regno] = move2add_luid;\n+\t  move2add_record_sym_value (dst, sym, off);\n \t  return;\n \t}\n     }\n \n-  if (SCALAR_INT_MODE_P (GET_MODE (dst))\n-      && nregs == 1 && GET_CODE (set) == SET\n+  if (SCALAR_INT_MODE_P (mode)\n+      && GET_CODE (set) == SET\n       && GET_CODE (SET_DEST (set)) != ZERO_EXTRACT\n       && GET_CODE (SET_DEST (set)) != STRICT_LOW_PART)\n     {\n       rtx src = SET_SRC (set);\n       rtx base_reg;\n       HOST_WIDE_INT offset;\n       int base_regno;\n-      /* This may be different from mode, if SET_DEST (set) is a\n-\t SUBREG.  */\n-      enum machine_mode dst_mode = GET_MODE (dst);\n \n       switch (GET_CODE (src))\n \t{\n@@ -2185,20 +2221,14 @@ move2add_note_store (rtx dst, const_rtx set, void *data)\n \t      if (CONST_INT_P (XEXP (src, 1)))\n \t\toffset = INTVAL (XEXP (src, 1));\n \t      else if (REG_P (XEXP (src, 1))\n-\t\t       && (reg_set_luid[REGNO (XEXP (src, 1))]\n-\t\t\t   > move2add_last_label_luid)\n-\t\t       && (MODES_OK_FOR_MOVE2ADD\n-\t\t\t   (dst_mode, reg_mode[REGNO (XEXP (src, 1))])))\n+\t\t       && move2add_valid_value_p (REGNO (XEXP (src, 1)), mode))\n \t\t{\n \t\t  if (reg_base_reg[REGNO (XEXP (src, 1))] < 0\n \t\t      && reg_symbol_ref[REGNO (XEXP (src, 1))] == NULL_RTX)\n \t\t    offset = reg_offset[REGNO (XEXP (src, 1))];\n \t\t  /* Maybe the first register is known to be a\n \t\t     constant.  */\n-\t\t  else if (reg_set_luid[REGNO (base_reg)]\n-\t\t\t   > move2add_last_label_luid\n-\t\t\t   && (MODES_OK_FOR_MOVE2ADD\n-\t\t\t       (dst_mode, reg_mode[REGNO (base_reg)]))\n+\t\t  else if (move2add_valid_value_p (REGNO (base_reg), mode)\n \t\t\t   && reg_base_reg[REGNO (base_reg)] < 0\n \t\t\t   && reg_symbol_ref[REGNO (base_reg)] == NULL_RTX)\n \t\t    {\n@@ -2228,51 +2258,44 @@ move2add_note_store (rtx dst, const_rtx set, void *data)\n \t  reg_offset[regno] = INTVAL (SET_SRC (set));\n \t  /* We assign the same luid to all registers set to constants.  */\n \t  reg_set_luid[regno] = move2add_last_label_luid + 1;\n-\t  reg_mode[regno] = mode;\n+\t  move2add_record_mode (dst);\n \t  return;\n \n \tdefault:\n-\tinvalidate:\n-\t  /* Invalidate the contents of the register.  */\n-\t  reg_set_luid[regno] = 0;\n-\t  return;\n+\t  goto invalidate;\n \t}\n \n       base_regno = REGNO (base_reg);\n       /* If information about the base register is not valid, set it\n \t up as a new base register, pretending its value is known\n \t starting from the current insn.  */\n-      if (reg_set_luid[base_regno] <= move2add_last_label_luid)\n+      if (!move2add_valid_value_p (base_regno, mode))\n \t{\n \t  reg_base_reg[base_regno] = base_regno;\n \t  reg_symbol_ref[base_regno] = NULL_RTX;\n \t  reg_offset[base_regno] = 0;\n \t  reg_set_luid[base_regno] = move2add_luid;\n-\t  reg_mode[base_regno] = mode;\n+\t  gcc_assert (GET_MODE (base_reg) == mode);\n+\t  move2add_record_mode (base_reg);\n \t}\n-      else if (! MODES_OK_FOR_MOVE2ADD (dst_mode,\n-\t\t\t\t\treg_mode[base_regno]))\n-\tgoto invalidate;\n-\n-      reg_mode[regno] = mode;\n \n       /* Copy base information from our base register.  */\n       reg_set_luid[regno] = reg_set_luid[base_regno];\n       reg_base_reg[regno] = reg_base_reg[base_regno];\n       reg_symbol_ref[regno] = reg_symbol_ref[base_regno];\n \n       /* Compute the sum of the offsets or constants.  */\n-      reg_offset[regno] = trunc_int_for_mode (offset\n-\t\t\t\t\t      + reg_offset[base_regno],\n-\t\t\t\t\t      dst_mode);\n+      reg_offset[regno]\n+\t= trunc_int_for_mode (offset + reg_offset[base_regno], mode);\n+\n+      move2add_record_mode (dst);\n     }\n   else\n     {\n-      unsigned int endregno = regno + nregs;\n-\n-      for (i = regno; i < endregno; i++)\n-\t/* Reset the information about this register.  */\n-\treg_set_luid[i] = 0;\n+    invalidate:\n+      /* Invalidate the contents of the register.  */\n+      move2add_record_mode (dst);\n+      reg_mode[regno] = VOIDmode;\n     }\n }\n \f"}]}