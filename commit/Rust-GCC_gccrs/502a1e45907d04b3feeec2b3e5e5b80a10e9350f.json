{"sha": "502a1e45907d04b3feeec2b3e5e5b80a10e9350f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTAyYTFlNDU5MDdkMDRiM2ZlZWVjMmIzZTVlNWI4MGExMGU5MzUwZg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2009-09-22T18:31:26Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2009-09-22T18:31:26Z"}, "message": "re PR debug/41295 (gfortran.dg/loc_2.f90 -O3 -g fails on SH with orphaned debug_insn)\n\ngcc/ChangeLog:\nPR debug/41295\n* reload1.c (reload): Reset debug insns with pseudos without\nequivalences.\ngcc/testsuite/ChangeLog:\nPR debug/41295\n* gcc.dg/pr41295.c: New.\n\nFrom-SVN: r152040", "tree": {"sha": "9dde6d6dc8a7b6817d099f383f6f5f1bc6362a4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9dde6d6dc8a7b6817d099f383f6f5f1bc6362a4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/502a1e45907d04b3feeec2b3e5e5b80a10e9350f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/502a1e45907d04b3feeec2b3e5e5b80a10e9350f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/502a1e45907d04b3feeec2b3e5e5b80a10e9350f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/502a1e45907d04b3feeec2b3e5e5b80a10e9350f/comments", "author": null, "committer": null, "parents": [{"sha": "ae6032ea4880e135775d84297e37a44891a343d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae6032ea4880e135775d84297e37a44891a343d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae6032ea4880e135775d84297e37a44891a343d7"}], "stats": {"total": 160, "additions": 138, "deletions": 22}, "files": [{"sha": "2565cb9a7b3c5b3d642cfd0330f242e0fcb139a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502a1e45907d04b3feeec2b3e5e5b80a10e9350f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502a1e45907d04b3feeec2b3e5e5b80a10e9350f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=502a1e45907d04b3feeec2b3e5e5b80a10e9350f", "patch": "@@ -1,3 +1,9 @@\n+2009-09-22  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/41295\n+\t* reload1.c (reload): Reset debug insns with pseudos without\n+\tequivalences.\n+\n 2009-09-22  Neil Vachharajani  <nvachhar@google.com>\n \n \t* testsuite/gcc.dg/pr40209.c: Add test case."}, {"sha": "5581cd6608377f796730a0d4fba7acf018f40b8a", "filename": "gcc/reload1.c", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502a1e45907d04b3feeec2b3e5e5b80a10e9350f/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502a1e45907d04b3feeec2b3e5e5b80a10e9350f/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=502a1e45907d04b3feeec2b3e5e5b80a10e9350f", "patch": "@@ -1241,40 +1241,54 @@ reload (rtx first, int global)\n \t{\n \t  rtx reg = regno_reg_rtx[i];\n \t  rtx equiv = 0;\n-\t  df_ref use;\n+\t  df_ref use, next;\n \n \t  if (reg_equiv_constant[i])\n \t    equiv = reg_equiv_constant[i];\n \t  else if (reg_equiv_invariant[i])\n \t    equiv = reg_equiv_invariant[i];\n \t  else if (reg && MEM_P (reg))\n-\t    {\n-\t      equiv = targetm.delegitimize_address (reg);\n-\t      if (equiv == reg)\n-\t\tequiv = 0;\n-\t    }\n+\t    equiv = targetm.delegitimize_address (reg);\n \t  else if (reg && REG_P (reg) && (int)REGNO (reg) != i)\n \t    equiv = reg;\n \n-\t  if (equiv)\n-\t    for (use = DF_REG_USE_CHAIN (i); use;\n-\t\t use = DF_REF_NEXT_REG (use))\n-\t      if (DEBUG_INSN_P (DF_REF_INSN (use)))\n+\t  if (equiv == reg)\n+\t    continue;\n+\n+\t  for (use = DF_REG_USE_CHAIN (i); use; use = next)\n+\t    {\n+\t      rtx *loc = DF_REF_LOC (use);\n+\t      rtx x = *loc;\n+\n+\t      insn = DF_REF_INSN (use);\n+\t      next = DF_REF_NEXT_REG (use);\n+\n+\t      if (DEBUG_INSN_P (insn))\n \t\t{\n-\t\t  rtx *loc = DF_REF_LOC (use);\n-\t\t  rtx x = *loc;\n-\n-\t\t  if (x == reg)\n-\t\t    *loc = copy_rtx (equiv);\n-\t\t  else if (GET_CODE (x) == SUBREG\n-\t\t\t   && SUBREG_REG (x) == reg)\n-\t\t    *loc = simplify_gen_subreg (GET_MODE (x), equiv,\n-\t\t\t\t\t\tGET_MODE (reg),\n-\t\t\t\t\t\tSUBREG_BYTE (x));\n+\t\t  gcc_assert (x == reg\n+\t\t\t      || (GET_CODE (x) == SUBREG\n+\t\t\t\t  && SUBREG_REG (x) == reg));\n+\n+\t\t  if (!equiv)\n+\t\t    {\n+\t\t      INSN_VAR_LOCATION_LOC (insn) = gen_rtx_UNKNOWN_VAR_LOC ();\n+\t\t      df_insn_rescan_debug_internal (insn);\n+\t\t    }\n \t\t  else\n-\t\t    gcc_unreachable ();\n-\t\t  *loc = wrap_constant (GET_MODE (x), *loc);\n+\t\t    {\n+\t\t      if (x == reg)\n+\t\t\t*loc = copy_rtx (equiv);\n+\t\t      else if (GET_CODE (x) == SUBREG\n+\t\t\t       && SUBREG_REG (x) == reg)\n+\t\t\t*loc = simplify_gen_subreg (GET_MODE (x), equiv,\n+\t\t\t\t\t\t    GET_MODE (reg),\n+\t\t\t\t\t\t    SUBREG_BYTE (x));\n+\t\t      else\n+\t\t\tgcc_unreachable ();\n+\t\t    *loc = wrap_constant (GET_MODE (x), *loc);\n+\t\t    }\n \t\t}\n+\t    }\n \t}\n     }\n "}, {"sha": "fd26fb24639de695c316845b3629c77bb0678497", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502a1e45907d04b3feeec2b3e5e5b80a10e9350f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502a1e45907d04b3feeec2b3e5e5b80a10e9350f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=502a1e45907d04b3feeec2b3e5e5b80a10e9350f", "patch": "@@ -1,3 +1,8 @@\n+2009-09-22  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/41295\n+\t* gcc.dg/pr41295.c: New.\n+\n 2009-09-22  Adam Nemet  <anemet@caviumnetworks.com>\n \n \t* gcc.target/mips/code-readable-1.c: Change \\. to \\\\. when"}, {"sha": "fabff63c923dc89df4ab4d2b48b8e7fb97c3b02e", "filename": "gcc/testsuite/gcc.dg/pr41295.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502a1e45907d04b3feeec2b3e5e5b80a10e9350f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41295.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502a1e45907d04b3feeec2b3e5e5b80a10e9350f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41295.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41295.c?ref=502a1e45907d04b3feeec2b3e5e5b80a10e9350f", "patch": "@@ -0,0 +1,91 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -g\" } */\n+\n+enum reg_class\n+{\n+  BASE_REGS,\n+  GENERAL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+static __inline__ unsigned char\n+hard_reg_set_subset_p (const unsigned long x[4], const unsigned long y[4])\n+{\n+  return ((x[0] & ~y[0]) == 0\n+          && (x[1] & ~y[1]) == 0\n+          && (x[2] & ~y[2]) == 0\n+\t  && (x[3] & ~y[3]) == 0);\n+}\n+\n+static __inline__ unsigned char\n+hard_reg_set_equal_p (const unsigned long x[4], const unsigned long y[4])\n+{\n+  return x[0] == y[0]\n+         && x[1] == y[1]\n+         && x[2] == y[2]\n+         && x[3] == y[3];\n+}\n+\n+extern unsigned long reg_class_contents[(int) LIM_REG_CLASSES][4];\n+extern int ira_important_classes_num;\n+extern enum reg_class ira_important_classes[(int) LIM_REG_CLASSES];\n+extern enum reg_class ira_reg_class_intersect[(int) LIM_REG_CLASSES][(int)\n+\t\t\t\t\t\t\t\t     LIM_REG_CLASSES];\n+extern unsigned char ira_reg_classes_intersect_p[(int) LIM_REG_CLASSES][(int)\n+\t\t\t\t\t\t\t\t\tLIM_REG_CLASSES];\n+extern enum reg_class ira_reg_class_super_classes[(int) LIM_REG_CLASSES][(int)\n+\t\t\t\t\t\t\t\t\t LIM_REG_CLASSES];\n+static unsigned long temp_hard_regset[4];\n+\n+static void\n+setup_reg_class_relations (void)\n+{\n+  int i, cl1, cl2, cl3;\n+  unsigned long temp_set2[4];\n+  for (cl1 = 0; cl1 < (int) LIM_REG_CLASSES; cl1++)\n+    {\n+      ira_reg_class_super_classes[cl1][0] = LIM_REG_CLASSES;\n+      for (cl2 = 0; cl2 < (int) LIM_REG_CLASSES; cl2++)\n+\t{\n+\t  ira_reg_classes_intersect_p[cl1][cl2] = 0;\n+\t  {\n+\t    unsigned long *scan_tp_ = (temp_set2), *scan_fp_ =\n+\t      (reg_class_contents[cl2]);\n+\t    scan_tp_[1] = scan_fp_[1];\n+\t    scan_tp_[2] = scan_fp_[2];\n+\t    scan_tp_[3] = scan_fp_[3];\n+\t  }\n+\t  for (i = 0; i < ira_important_classes_num; i++)\n+\t    {\n+\t      cl3 = ira_important_classes[i];\n+\t      {\n+\t\tunsigned long *scan_tp_ = (temp_hard_regset), *scan_fp_ =\n+\t\t  (reg_class_contents[cl3]);\n+\t\tscan_tp_[0] = scan_fp_[0];\n+\t\tscan_tp_[1] = scan_fp_[1];\n+\t\tscan_tp_[3] = scan_fp_[3];\n+\t      }\n+\t      if (!hard_reg_set_subset_p (temp_hard_regset, temp_set2)\n+\t\t  || (hard_reg_set_equal_p (temp_hard_regset, temp_set2)\n+\t\t      && hard_reg_set_subset_p (reg_class_contents[cl3],\n+\t\t\t\t\t\treg_class_contents[(int)\n+\t\t\t\t\t\t\t\t   ira_reg_class_intersect\n+\t\t\t\t\t\t\t\t   [cl1]\n+\t\t\t\t\t\t\t\t   [cl2]])))\n+\t\tira_reg_class_intersect[cl1][cl2] = (enum reg_class) cl3;\n+\t    }\n+\t}\n+    }\n+}\n+\n+static void\n+find_reg_class_closure (void)\n+{\n+  setup_reg_class_relations ();\n+}\n+\n+void\n+ira_init (void)\n+{\n+  find_reg_class_closure ();\n+}"}]}