{"sha": "4b96d3861e74b8df1032f4317230408248e4bf09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI5NmQzODYxZTc0YjhkZjEwMzJmNDMxNzIzMDQwODI0OGU0YmYwOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-08-14T09:52:15Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-08-14T09:52:15Z"}, "message": "[Ada] Compiler speedup with inlining across units\n\nThis change is aimed at speeding up the inlining across units done by\nthe Ada compiler when -gnatn is specified and in the presence of units\ninstantiating a lot of generic packages.\n\nThe current implementation is as follows: when a generic package is\nbeing instantiated, the compiler scans its spec for the presence of\nsubprograms with an aspect/pragma Inline and, upon finding one,\nschedules the instantiation of its body.  That's not very efficient\nbecause the compiler doesn't know yet if one of those inlined\nsubprograms will eventually be called from the main unit.\n\nThe new implementation arranges for the compiler to instantiate the body\non demand, i.e. when it encounters a call to one of the inlined\nsubprograms.  That's still not optimal because, at this point, the\ncompiler has not yet computed whether the call itself is reachable from\nthe main unit (it will do this computation at the very end of the\nprocessing, just before sending the inlined units to the code generator)\nbut that's nevertheless a net progress.\n\nThe patch also enhances the -gnatd.j option to make it output the list\nof instances \"inlined\" this way.  The following package is a simple\nexample:\n\nwith Q;\n\nprocedure P is\nbegin\n  Q.Proc;\nend;\n\npackage Q is\n\n  procedure Proc;\n  pragma Inline (Proc);\n\nend Q;\n\nwith G;\n\npackage body Q is\n\n  package My_G is new G (1);\n\n  procedure Proc is\n    Val : constant Integer := My_G.Func;\n  begin\n    if Val /= 1 then\n      raise Program_Error;\n    end if;\n  end;\n\nend Q;\n\ngeneric\n\n  Value : Integer;\n\npackage G is\n\n  function Func return Integer;\n  pragma Inline (Func);\n\nend G;\n\npackage body G is\n\n  function Func return Integer is\n  begin\n    return Value;\n  end;\n\nend G;\n\n2019-08-14  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* einfo.ads (Is_Called): Document new usage on E_Package\n\tentities.\n\t* einfo.adb (Is_Called): Accept E_Package entities.\n\t(Set_Is_Called): Likewise.\n\t* exp_ch6.adb (Expand_Call_Helper): Move code dealing with\n\tinstances for back-end inlining to Add_Inlined_Body.\n\t* inline.ads: Remove with clauses for Alloc and Table.\n\t(Pending_Instantiations): Move to...\n\t* inline.adb: Add with clauses for Alloc, Uintp, Table and\n\tGNAT.HTable.\n\t(Backend_Instances): New variable.\n\t(Pending_Instantiations): ...here.\n\t(Called_Pending_Instantiations): New table.\n\t(Node_Table_Size): New constant.\n\t(Node_Header_Num): New subtype.\n\t(Node_Hash): New function.\n\t(To_Pending_Instantiations): New hash table.\n\t(Add_Inlined_Body): Bail out early for subprograms in the main\n\tunit or subunit.  Likewise if the Is_Called flag is set.  If the\n\tsubprogram is an instance, invoke Add_Inlined_Instance.  Call\n\tSet_Is_Called earlier.  If the subrogram is within an instance,\n\tinvoke Add_Inlined_Instance.  Also deal with the case where the\n\tcall itself is within an instance.\n\t(Add_Inlined_Instance): New procedure.\n\t(Add_Inlined_Subprogram): Remove conditions always fulfilled.\n\t(Add_Pending_Instantiation): Move the defence against ludicruous\n\tnumber of instantiations to here. When back-end inlining is\n\tenabled, associate an instantiation with its index in table and\n\tmark a few selected kinds of instantiations as always needed.\n\t(Initialize): Set Backend_Instances to No_Elist.\n\t(Instantiate_Body): New procedure doing the work extracted\n\tfrom...\n\t(Instantiate_Bodies): ...here.  When back-end inlining is\n\tenabled, loop over Called_Pending_Instantiations instead of\n\tPending_Instantiations.\n\t(Is_Nested): Minor tweak.\n\t(List_Inlining_Info): Also list the contents of\n\tBackend_Instances.\n\t* sem_ch12.adb (Might_Inline_Subp): Return early if Is_Inlined\n\tis set and otherwise set it before returning true.\n\t(Analyze_Package_Instantiation): Remove the defence against\n\tludicruous number of instantiations.  Invoke\n\tRemove_Dead_Instance instead of doing the removal manually if\n\tthere is a guaranteed ABE.\n\nFrom-SVN: r274465", "tree": {"sha": "fbcdc10f2092f73da537788d02b6fc5d18e05425", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbcdc10f2092f73da537788d02b6fc5d18e05425"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b96d3861e74b8df1032f4317230408248e4bf09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b96d3861e74b8df1032f4317230408248e4bf09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b96d3861e74b8df1032f4317230408248e4bf09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b96d3861e74b8df1032f4317230408248e4bf09/comments", "author": null, "committer": null, "parents": [{"sha": "72e324b6d8cb43b07eb3927f7d150b93105d1add", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72e324b6d8cb43b07eb3927f7d150b93105d1add", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72e324b6d8cb43b07eb3927f7d150b93105d1add"}], "stats": {"total": 515, "additions": 385, "deletions": 130}, "files": [{"sha": "6cabf2626d4b9ae63b5abb8d35b11dc608162fb6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b96d3861e74b8df1032f4317230408248e4bf09/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b96d3861e74b8df1032f4317230408248e4bf09/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4b96d3861e74b8df1032f4317230408248e4bf09", "patch": "@@ -1,3 +1,50 @@\n+2019-08-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* einfo.ads (Is_Called): Document new usage on E_Package\n+\tentities.\n+\t* einfo.adb (Is_Called): Accept E_Package entities.\n+\t(Set_Is_Called): Likewise.\n+\t* exp_ch6.adb (Expand_Call_Helper): Move code dealing with\n+\tinstances for back-end inlining to Add_Inlined_Body.\n+\t* inline.ads: Remove with clauses for Alloc and Table.\n+\t(Pending_Instantiations): Move to...\n+\t* inline.adb: Add with clauses for Alloc, Uintp, Table and\n+\tGNAT.HTable.\n+\t(Backend_Instances): New variable.\n+\t(Pending_Instantiations): ...here.\n+\t(Called_Pending_Instantiations): New table.\n+\t(Node_Table_Size): New constant.\n+\t(Node_Header_Num): New subtype.\n+\t(Node_Hash): New function.\n+\t(To_Pending_Instantiations): New hash table.\n+\t(Add_Inlined_Body): Bail out early for subprograms in the main\n+\tunit or subunit.  Likewise if the Is_Called flag is set.  If the\n+\tsubprogram is an instance, invoke Add_Inlined_Instance.  Call\n+\tSet_Is_Called earlier.  If the subrogram is within an instance,\n+\tinvoke Add_Inlined_Instance.  Also deal with the case where the\n+\tcall itself is within an instance.\n+\t(Add_Inlined_Instance): New procedure.\n+\t(Add_Inlined_Subprogram): Remove conditions always fulfilled.\n+\t(Add_Pending_Instantiation): Move the defence against ludicruous\n+\tnumber of instantiations to here. When back-end inlining is\n+\tenabled, associate an instantiation with its index in table and\n+\tmark a few selected kinds of instantiations as always needed.\n+\t(Initialize): Set Backend_Instances to No_Elist.\n+\t(Instantiate_Body): New procedure doing the work extracted\n+\tfrom...\n+\t(Instantiate_Bodies): ...here.  When back-end inlining is\n+\tenabled, loop over Called_Pending_Instantiations instead of\n+\tPending_Instantiations.\n+\t(Is_Nested): Minor tweak.\n+\t(List_Inlining_Info): Also list the contents of\n+\tBackend_Instances.\n+\t* sem_ch12.adb (Might_Inline_Subp): Return early if Is_Inlined\n+\tis set and otherwise set it before returning true.\n+\t(Analyze_Package_Instantiation): Remove the defence against\n+\tludicruous number of instantiations.  Invoke\n+\tRemove_Dead_Instance instead of doing the removal manually if\n+\tthere is a guaranteed ABE.\n+\n 2019-08-14  Gary Dismukes  <dismukes@adacore.com>\n \n \t* exp_ch3.adb (Predef_Spec_Or_Body): For an equality operation"}, {"sha": "957bfe6e4cbb7139e4e798c2704847c8bb19ed96", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b96d3861e74b8df1032f4317230408248e4bf09/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b96d3861e74b8df1032f4317230408248e4bf09/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=4b96d3861e74b8df1032f4317230408248e4bf09", "patch": "@@ -2140,7 +2140,7 @@ package body Einfo is\n \n    function Is_Called (Id : E) return B is\n    begin\n-      pragma Assert (Ekind_In (Id, E_Procedure, E_Function));\n+      pragma Assert (Ekind_In (Id, E_Procedure, E_Function, E_Package));\n       return Flag102 (Id);\n    end Is_Called;\n \n@@ -5344,7 +5344,7 @@ package body Einfo is\n \n    procedure Set_Is_Called (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Ekind_In (Id, E_Procedure, E_Function));\n+      pragma Assert (Ekind_In (Id, E_Procedure, E_Function, E_Package));\n       Set_Flag102 (Id, V);\n    end Set_Is_Called;\n "}, {"sha": "b879753558d7ce4733290540a041b1ac8c2ecfb9", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b96d3861e74b8df1032f4317230408248e4bf09/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b96d3861e74b8df1032f4317230408248e4bf09/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=4b96d3861e74b8df1032f4317230408248e4bf09", "patch": "@@ -2366,9 +2366,9 @@ package Einfo is\n --       i.e. Standard.Boolean and all types ultimately derived from it.\n \n --    Is_Called (Flag102)\n---       Defined in subprograms. Returns true if the subprogram is called\n---       in the unit being compiled or in a unit in the context. Used for\n---       inlining.\n+--       Defined in subprograms and packages. Set if a subprogram is called\n+--       from the unit being compiled or a unit in the closure. Also set for\n+--       a package that contains called subprograms. Used only for inlining.\n \n --    Is_Character_Type (Flag63)\n --       Defined in all entities. Set for character types and subtypes,\n@@ -6406,12 +6406,13 @@ package Einfo is\n    --    Has_Master_Entity                   (Flag21)\n    --    Has_RACW                            (Flag214)  (non-generic case only)\n    --    Ignore_SPARK_Mode_Pragmas           (Flag301)\n-   --    In_Package_Body                     (Flag48)\n-   --    In_Use                              (Flag8)\n+   --    Is_Called                           (Flag102)  (non-generic case only)\n    --    Is_Elaboration_Checks_OK_Id         (Flag148)\n    --    Is_Elaboration_Warnings_OK_Id       (Flag304)\n    --    Is_Instantiated                     (Flag126)\n+   --    In_Package_Body                     (Flag48)\n    --    Is_Private_Descendant               (Flag53)\n+   --    In_Use                              (Flag8)\n    --    Is_Visible_Lib_Unit                 (Flag116)\n    --    Renamed_In_Spec                     (Flag231)  (non-generic case only)\n    --    SPARK_Aux_Pragma_Inherited          (Flag266)"}, {"sha": "c182072ea9f26bfe4ccc414a4339b5cccb0b2fab", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b96d3861e74b8df1032f4317230408248e4bf09/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b96d3861e74b8df1032f4317230408248e4bf09/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=4b96d3861e74b8df1032f4317230408248e4bf09", "patch": "@@ -4443,62 +4443,6 @@ package body Exp_Ch6 is\n            or else Has_Pragma_Inline_Always (Subp)\n          then\n             Add_Inlined_Body (Subp, Call_Node);\n-\n-            --  If the inlined call appears within an instance, then ensure\n-            --  that the enclosing instance body is available so the back end\n-            --  can actually perform the inlining.\n-\n-            if In_Instance and then Comes_From_Source (Subp) then\n-               declare\n-                  Decl      : Node_Id;\n-                  Inst      : Entity_Id;\n-                  Inst_Node : Node_Id;\n-\n-               begin\n-                  Inst := Scope (Subp);\n-\n-                  --  Find enclosing instance\n-\n-                  while Present (Inst) and then Inst /= Standard_Standard loop\n-                     exit when Is_Generic_Instance (Inst);\n-                     Inst := Scope (Inst);\n-                  end loop;\n-\n-                  if Present (Inst)\n-                    and then Is_Generic_Instance (Inst)\n-                    and then not Is_Inlined (Inst)\n-                  then\n-                     Set_Is_Inlined (Inst);\n-                     Decl := Unit_Declaration_Node (Inst);\n-\n-                     --  Do not add a pending instantiation if the body exits\n-                     --  already, or if the instance is a compilation unit, or\n-                     --  the instance node is missing.\n-\n-                     if Present (Corresponding_Body (Decl))\n-                       or else Nkind (Parent (Decl)) = N_Compilation_Unit\n-                       or else No (Next (Decl))\n-                     then\n-                        null;\n-\n-                     else\n-                        --  The instantiation node usually follows the package\n-                        --  declaration for the instance. If the generic unit\n-                        --  has aspect specifications, they are transformed\n-                        --  into pragmas in the instance, and the instance node\n-                        --  appears after them.\n-\n-                        Inst_Node := Next (Decl);\n-\n-                        while Nkind (Inst_Node) /= N_Package_Instantiation loop\n-                           Inst_Node := Next (Inst_Node);\n-                        end loop;\n-\n-                        Add_Pending_Instantiation (Inst_Node, Decl);\n-                     end if;\n-                  end if;\n-               end;\n-            end if;\n          end if;\n       end if;\n "}, {"sha": "05830e1a629fe8067bc21ebf60ea2eba05bae76d", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 322, "deletions": 44, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b96d3861e74b8df1032f4317230408248e4bf09/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b96d3861e74b8df1032f4317230408248e4bf09/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=4b96d3861e74b8df1032f4317230408248e4bf09", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Alloc;\n with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Debug;    use Debug;\n@@ -51,8 +52,12 @@ with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;\n-with Uname;    use Uname;\n+with Table;\n with Tbuild;   use Tbuild;\n+with Uintp;    use Uintp;\n+with Uname;    use Uname;\n+\n+with GNAT.HTable;\n \n package body Inline is\n \n@@ -82,12 +87,83 @@ package body Inline is\n    Backend_Calls : Elist_Id;\n    --  List of inline calls passed to the backend\n \n+   Backend_Instances : Elist_Id;\n+   --  List of instances inlined for the backend\n+\n    Backend_Inlined_Subps : Elist_Id;\n    --  List of subprograms inlined by the backend\n \n    Backend_Not_Inlined_Subps : Elist_Id;\n    --  List of subprograms that cannot be inlined by the backend\n \n+   -----------------------------\n+   --  Pending_Instantiations --\n+   -----------------------------\n+\n+   --  We make entries in this table for the pending instantiations of generic\n+   --  bodies that are created during semantic analysis. After the analysis is\n+   --  complete, calling Instantiate_Bodies performs the actual instantiations.\n+\n+   package Pending_Instantiations is new Table.Table (\n+     Table_Component_Type => Pending_Body_Info,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 0,\n+     Table_Initial        => Alloc.Pending_Instantiations_Initial,\n+     Table_Increment      => Alloc.Pending_Instantiations_Increment,\n+     Table_Name           => \"Pending_Instantiations\");\n+\n+   -------------------------------------\n+   --  Called_Pending_Instantiations  --\n+   -------------------------------------\n+\n+   --  With back-end inlining, the pending instantiations that are not in the\n+   --  main unit or subunit are performed only after a call to the subprogram\n+   --  instance, or to a subprogram within the package instance, is inlined.\n+   --  Since such a call can be within a subsequent pending instantiation,\n+   --  we make entries in this table that stores the index of these \"called\"\n+   --  pending instantiations and perform them when the table is populated.\n+\n+   package Called_Pending_Instantiations is new Table.Table (\n+     Table_Component_Type => Int,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 0,\n+     Table_Initial        => Alloc.Pending_Instantiations_Initial,\n+     Table_Increment      => Alloc.Pending_Instantiations_Increment,\n+     Table_Name           => \"Called_Pending_Instantiations\");\n+\n+   ---------------------------------\n+   --  To_Pending_Instantiations  --\n+   ---------------------------------\n+\n+   --  With back-end inlining, we also need to have a map from the pending\n+   --  instantiations to their index in the Pending_Instantiations table.\n+\n+   Node_Table_Size : constant := 257;\n+   --  Number of headers in hash table\n+\n+   subtype Node_Header_Num is Integer range 0 .. Node_Table_Size - 1;\n+   --  Range of headers in hash table\n+\n+   function Node_Hash (Id : Node_Id) return Node_Header_Num;\n+   --  Simple hash function for Node_Ids\n+\n+   package To_Pending_Instantiations is new GNAT.Htable.Simple_HTable\n+     (Header_Num => Node_Header_Num,\n+      Element    => Int,\n+      No_Element => -1,\n+      Key        => Node_Id,\n+      Hash       => Node_Hash,\n+      Equal      => \"=\");\n+\n+   -----------------\n+   -- Node_Hash --\n+   -----------------\n+\n+   function Node_Hash (Id : Node_Id) return Node_Header_Num is\n+   begin\n+      return Node_Header_Num (Id mod Node_Table_Size);\n+   end Node_Hash;\n+\n    --------------------\n    -- Inlined Bodies --\n    --------------------\n@@ -179,8 +255,11 @@ package body Inline is\n    --  called, and for the inlined subprogram that contains the call. If\n    --  the call is in the main compilation unit, Caller is Empty.\n \n+   procedure Add_Inlined_Instance (E : Entity_Id);\n+   --  Add instance E to the list of of inlined instances for the unit\n+\n    procedure Add_Inlined_Subprogram (E : Entity_Id);\n-   --  Add subprogram E to the list of inlined subprogram for the unit\n+   --  Add subprogram E to the list of inlined subprograms for the unit\n \n    function Add_Subp (E : Entity_Id) return Subp_Index;\n    --  Make entry in Inlined table for subprogram E, or return table index\n@@ -429,17 +508,22 @@ package body Inline is\n          return Dont_Inline;\n       end Must_Inline;\n \n-      Level : Inline_Level_Type;\n+      Inst      : Entity_Id;\n+      Inst_Decl : Node_Id;\n+      Inst_Node : Node_Id;\n+      Level     : Inline_Level_Type;\n \n    --  Start of processing for Add_Inlined_Body\n \n    begin\n       Append_New_Elmt (N, To => Backend_Calls);\n \n-      --  Skip subprograms that cannot be inlined outside their unit\n+      --  Skip subprograms that cannot or need not be inlined outside their\n+      --  unit or parent subprogram.\n \n       if Is_Abstract_Subprogram (E)\n         or else Convention (E) = Convention_Protected\n+        or else In_Main_Unit_Or_Subunit (E)\n         or else Is_Nested (E)\n       then\n          return;\n@@ -456,6 +540,22 @@ package body Inline is\n          return;\n       end if;\n \n+      --  If a previous call to the subprogram has been inlined, nothing to do\n+\n+      if Is_Called (E) then\n+         return;\n+      end if;\n+\n+      --  If the subprogram is an instance, then inline the instance\n+\n+      if Is_Generic_Instance (E) then\n+         Add_Inlined_Instance (E);\n+      end if;\n+\n+      --  Mark the subprogram as called\n+\n+      Set_Is_Called (E);\n+\n       --  If the call was generated by the compiler and is to a subprogram in\n       --  a run-time unit, we need to suppress debugging information for it,\n       --  so that the code that is eventually inlined will not affect the\n@@ -476,7 +576,6 @@ package body Inline is\n       --  in the spec.\n \n       if Is_Non_Loading_Expression_Function (E) then\n-         Set_Is_Called (E);\n          return;\n       end if;\n \n@@ -489,15 +588,67 @@ package body Inline is\n          Pack : constant Entity_Id := Get_Code_Unit_Entity (E);\n \n       begin\n-         Set_Is_Called (E);\n-\n          if Pack = E then\n             Inlined_Bodies.Increment_Last;\n             Inlined_Bodies.Table (Inlined_Bodies.Last) := E;\n \n          else\n             pragma Assert (Ekind (Pack) = E_Package);\n \n+            --  If the subprogram is within an instance, inline the instance\n+\n+            if Comes_From_Source (E) then\n+               Inst := Scope (E);\n+\n+               while Present (Inst) and then Inst /= Standard_Standard loop\n+                  exit when Is_Generic_Instance (Inst);\n+                  Inst := Scope (Inst);\n+               end loop;\n+\n+               if Present (Inst)\n+                 and then Is_Generic_Instance (Inst)\n+                 and then not Is_Called (Inst)\n+               then\n+                  --  Do not add a pending instantiation if the body exits\n+                  --  already, or if the instance is a compilation unit, or\n+                  --  the instance node is missing.\n+\n+                  Inst_Decl := Unit_Declaration_Node (Inst);\n+                  if Present (Corresponding_Body (Inst_Decl))\n+                    or else Nkind (Parent (Inst_Decl)) = N_Compilation_Unit\n+                    or else No (Next (Inst_Decl))\n+                  then\n+                     Set_Is_Called (Inst);\n+\n+                  else\n+                     --  If the inlined call itself appears within an instance,\n+                     --  ensure that the enclosing instance body is available.\n+                     --  This is necessary because Sem_Ch12.Might_Inline_Subp\n+                     --  does not recurse into nested instantiations.\n+\n+                     if not Is_Inlined (Inst) and then In_Instance then\n+                        Set_Is_Inlined (Inst);\n+\n+                        --  The instantiation node usually follows the package\n+                        --  declaration for the instance. If the generic unit\n+                        --  has aspect specifications, they are transformed\n+                        --  into pragmas in the instance, and the instance node\n+                        --  appears after them.\n+\n+                        Inst_Node := Next (Inst_Decl);\n+\n+                        while Nkind (Inst_Node) /= N_Package_Instantiation loop\n+                           Inst_Node := Next (Inst_Node);\n+                        end loop;\n+\n+                        Add_Pending_Instantiation (Inst_Node, Inst_Decl);\n+                     end if;\n+\n+                     Add_Inlined_Instance (Inst);\n+                  end if;\n+               end if;\n+            end if;\n+\n             --  If the unit containing E is an instance, then the instance body\n             --  will be analyzed in any case, see Sem_Ch12.Might_Inline_Subp.\n \n@@ -534,6 +685,39 @@ package body Inline is\n       end;\n    end Add_Inlined_Body;\n \n+   --------------------------\n+   -- Add_Inlined_Instance --\n+   --------------------------\n+\n+   procedure Add_Inlined_Instance (E : Entity_Id) is\n+      Decl_Node : constant Node_Id := Unit_Declaration_Node (E);\n+      Index     : Int;\n+\n+   begin\n+      --  This machinery is only used with back-end inlining\n+\n+      if not Back_End_Inlining then\n+         return;\n+      end if;\n+\n+      --  Register the instance in the list\n+\n+      Append_New_Elmt (Decl_Node, To => Backend_Instances);\n+\n+      --  Retrieve the index of its corresponding pending instantiation\n+      --  and mark this corresponding pending instantiation as needed.\n+\n+      Index := To_Pending_Instantiations.Get (Decl_Node);\n+      if Index >= 0 then\n+         Called_Pending_Instantiations.Append (Index);\n+      else\n+         pragma Assert (False);\n+         null;\n+      end if;\n+\n+      Set_Is_Called (E);\n+   end Add_Inlined_Instance;\n+\n    ----------------------------\n    -- Add_Inlined_Subprogram --\n    ----------------------------\n@@ -570,21 +754,17 @@ package body Inline is\n    --  Start of processing for Add_Inlined_Subprogram\n \n    begin\n-      --  If the subprogram is to be inlined, and if its unit is known to be\n-      --  inlined or is an instance whose body will be analyzed anyway or the\n-      --  subprogram was generated as a body by the compiler (for example an\n-      --  initialization procedure) or its declaration was provided along with\n-      --  the body (for example an expression function), and if it is declared\n-      --  at the library level not in the main unit, and if it can be inlined\n-      --  by the back-end, then insert it in the list of inlined subprograms.\n-\n-      if Is_Inlined (E)\n-        and then (Is_Inlined (Pack)\n-                   or else Is_Generic_Instance (Pack)\n-                   or else Nkind (Decl) = N_Subprogram_Body\n-                   or else Present (Corresponding_Body (Decl)))\n-        and then not In_Main_Unit_Or_Subunit (E)\n-        and then not Is_Nested (E)\n+      --  We can inline the subprogram if its unit is known to be inlined or is\n+      --  an instance whose body will be analyzed anyway or the subprogram was\n+      --  generated as a body by the compiler (for example an initialization\n+      --  procedure) or its declaration was provided along with the body (for\n+      --  example an expression function) and it does not declare types with\n+      --  nontrivial initialization procedures.\n+\n+      if (Is_Inlined (Pack)\n+           or else Is_Generic_Instance (Pack)\n+           or else Nkind (Decl) = N_Subprogram_Body\n+           or else Present (Corresponding_Body (Decl)))\n         and then not Has_Initialized_Type (E)\n       then\n          Register_Backend_Inlined_Subprogram (E);\n@@ -607,7 +787,20 @@ package body Inline is\n    --------------------------------\n \n    procedure Add_Pending_Instantiation (Inst : Node_Id; Act_Decl : Node_Id) is\n+      Act_Decl_Id : Entity_Id;\n+      Index       : Int;\n+\n    begin\n+      --  Here is a defense against a ludicrous number of instantiations\n+      --  caused by a circular set of instantiation attempts.\n+\n+      if Pending_Instantiations.Last > Maximum_Instantiations then\n+         Error_Msg_Uint_1 := UI_From_Int (Maximum_Instantiations);\n+         Error_Msg_N (\"too many instantiations, exceeds max of^\", Inst);\n+         Error_Msg_N (\"\\limit can be changed using -gnateinn switch\", Inst);\n+         raise Unrecoverable_Error;\n+      end if;\n+\n       --  Capture the body of the generic instantiation along with its context\n       --  for later processing by Instantiate_Bodies.\n \n@@ -620,6 +813,30 @@ package body Inline is\n           Local_Suppress_Stack_Top => Local_Suppress_Stack_Top,\n           Scope_Suppress           => Scope_Suppress,\n           Warnings                 => Save_Warnings));\n+\n+      --  With back-end inlining, also associate the index to the instantiation\n+\n+      if Back_End_Inlining then\n+         Act_Decl_Id := Defining_Entity (Act_Decl);\n+         Index := Pending_Instantiations.Last;\n+\n+         To_Pending_Instantiations.Set (Act_Decl, Index);\n+\n+         --  If an instantiation is either a compilation unit or is in the main\n+         --  unit or subunit or is a nested subprogram, then its body is needed\n+         --  as per the analysis already done in Analyze_Package_Instantiation\n+         --  and Analyze_Subprogram_Instantiation.\n+\n+         if Nkind (Parent (Inst)) = N_Compilation_Unit\n+           or else In_Main_Unit_Or_Subunit (Act_Decl_Id)\n+           or else (Is_Subprogram (Act_Decl_Id)\n+                     and then Is_Nested (Act_Decl_Id))\n+         then\n+            Called_Pending_Instantiations.Append (Index);\n+\n+            Set_Is_Called (Act_Decl_Id);\n+         end if;\n+      end if;\n    end Add_Pending_Instantiation;\n \n    ------------------------\n@@ -4220,6 +4437,7 @@ package body Inline is\n \n       Inlined_Calls := No_Elist;\n       Backend_Calls := No_Elist;\n+      Backend_Instances := No_Elist;\n       Backend_Inlined_Subps := No_Elist;\n       Backend_Not_Inlined_Subps := No_Elist;\n    end Initialize;\n@@ -4236,9 +4454,36 @@ package body Inline is\n    --  the body is an internal error.\n \n    procedure Instantiate_Bodies is\n-      J    : Nat;\n+\n+      procedure Instantiate_Body (Info : Pending_Body_Info);\n+      --  Instantiate a pending body\n+\n+      ------------------------\n+      --  Instantiate_Body  --\n+      ------------------------\n+\n+      procedure Instantiate_Body (Info : Pending_Body_Info) is\n+      begin\n+         --  If the instantiation node is absent, it has been removed as part\n+         --  of unreachable code.\n+\n+         if No (Info.Inst_Node) then\n+            null;\n+\n+         elsif Nkind (Info.Act_Decl) = N_Package_Declaration then\n+            Instantiate_Package_Body (Info);\n+            Add_Scope_To_Clean (Defining_Entity (Info.Act_Decl));\n+\n+         else\n+            Instantiate_Subprogram_Body (Info);\n+         end if;\n+      end Instantiate_Body;\n+\n+      J, K  : Nat;\n       Info : Pending_Body_Info;\n \n+   --  Start of processing for Instantiate_Bodies\n+\n    begin\n       if Serious_Errors_Detected = 0 then\n          Expander_Active := (Operating_Mode = Opt.Generate_Code);\n@@ -4251,36 +4496,41 @@ package body Inline is\n \n          --  A body instantiation may generate additional instantiations, so\n          --  the following loop must scan to the end of a possibly expanding\n-         --  set (that's why we can't simply use a FOR loop here).\n+         --  set (that's why we cannot simply use a FOR loop here). We must\n+         --  also capture the element lest the set be entirely reallocated.\n \n          J := 0;\n-         while J <= Pending_Instantiations.Last\n-           and then Serious_Errors_Detected = 0\n-         loop\n-            Info := Pending_Instantiations.Table (J);\n-\n-            --  If the instantiation node is absent, it has been removed\n-            --  as part of unreachable code.\n-\n-            if No (Info.Inst_Node) then\n-               null;\n+         if Back_End_Inlining then\n+            while J <= Called_Pending_Instantiations.Last\n+              and then Serious_Errors_Detected = 0\n+            loop\n+               K := Called_Pending_Instantiations.Table (J);\n+               Info := Pending_Instantiations.Table (K);\n+               Instantiate_Body (Info);\n \n-            elsif Nkind (Info.Act_Decl) = N_Package_Declaration then\n-               Instantiate_Package_Body (Info);\n-               Add_Scope_To_Clean (Defining_Entity (Info.Act_Decl));\n+               J := J + 1;\n+            end loop;\n \n-            else\n-               Instantiate_Subprogram_Body (Info);\n-            end if;\n+         else\n+            while J <= Pending_Instantiations.Last\n+              and then Serious_Errors_Detected = 0\n+            loop\n+               Info := Pending_Instantiations.Table (J);\n+               Instantiate_Body (Info);\n \n-            J := J + 1;\n-         end loop;\n+               J := J + 1;\n+            end loop;\n+         end if;\n \n          --  Reset the table of instantiations. Additional instantiations\n          --  may be added through inlining, when additional bodies are\n          --  analyzed.\n \n-         Pending_Instantiations.Init;\n+         if Back_End_Inlining then\n+            Called_Pending_Instantiations.Init;\n+         else\n+            Pending_Instantiations.Init;\n+         end if;\n \n          --  We can now complete the cleanup actions of scopes that contain\n          --  pending instantiations (skipped for generic units, since we\n@@ -4308,7 +4558,7 @@ package body Inline is\n    begin\n       Scop := Scope (E);\n       while Scop /= Standard_Standard loop\n-         if Ekind (Scop) in Subprogram_Kind then\n+         if Is_Subprogram (Scop) then\n             return True;\n \n          elsif Ekind (Scop) = E_Task_Type\n@@ -4394,6 +4644,34 @@ package body Inline is\n          end loop;\n       end if;\n \n+      --  Generate listing of instances inlined for the backend\n+\n+      if Present (Backend_Instances) then\n+         Count := 0;\n+\n+         Elmt := First_Elmt (Backend_Instances);\n+         while Present (Elmt) loop\n+            Nod := Node (Elmt);\n+\n+            if not In_Internal_Unit (Nod) then\n+               Count := Count + 1;\n+\n+               if Count = 1 then\n+                  Write_Str (\"List of instances inlined for the backend\");\n+                  Write_Eol;\n+               end if;\n+\n+               Write_Str (\"  \");\n+               Write_Int (Count);\n+               Write_Str (\":\");\n+               Write_Location (Sloc (Nod));\n+               Output.Write_Eol;\n+            end if;\n+\n+            Next_Elmt (Elmt);\n+         end loop;\n+      end if;\n+\n       --  Generate listing of subprograms passed to the backend\n \n       if Present (Backend_Inlined_Subps) and then Back_End_Inlining then"}, {"sha": "ed342f58438aa27e0d1374e7d2d51eaf543786ba", "filename": "gcc/ada/inline.ads", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b96d3861e74b8df1032f4317230408248e4bf09/gcc%2Fada%2Finline.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b96d3861e74b8df1032f4317230408248e4bf09/gcc%2Fada%2Finline.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.ads?ref=4b96d3861e74b8df1032f4317230408248e4bf09", "patch": "@@ -42,10 +42,8 @@\n --  Inline_Always subprograms, but there are fewer restrictions on the source\n --  of subprograms.\n \n-with Alloc;\n with Opt;    use Opt;\n with Sem;    use Sem;\n-with Table;\n with Types;  use Types;\n with Warnsw; use Warnsw;\n \n@@ -100,14 +98,6 @@ package Inline is\n       --  Capture values of warning flags\n    end record;\n \n-   package Pending_Instantiations is new Table.Table (\n-     Table_Component_Type => Pending_Body_Info,\n-     Table_Index_Type     => Int,\n-     Table_Low_Bound      => 0,\n-     Table_Initial        => Alloc.Pending_Instantiations_Initial,\n-     Table_Increment      => Alloc.Pending_Instantiations_Increment,\n-     Table_Name           => \"Pending_Instantiations\");\n-\n    -----------------\n    -- Subprograms --\n    -----------------"}, {"sha": "dffec1443bd8305f96358af55d611250431ca354", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b96d3861e74b8df1032f4317230408248e4bf09/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b96d3861e74b8df1032f4317230408248e4bf09/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=4b96d3861e74b8df1032f4317230408248e4bf09", "patch": "@@ -3861,6 +3861,12 @@ package body Sem_Ch12 is\n \n       begin\n          if Inline_Processing_Required then\n+            --  No need to recompute the answer if we know it is positive\n+\n+            if Is_Inlined (Gen_Unit) then\n+               return True;\n+            end if;\n+\n             E := First_Entity (Gen_Unit);\n             while Present (E) loop\n                if Is_Subprogram (E) and then Is_Inlined (E) then\n@@ -3870,6 +3876,7 @@ package body Sem_Ch12 is\n                      Has_Inline_Always := True;\n                   end if;\n \n+                  Set_Is_Inlined (Gen_Unit);\n                   return True;\n                end if;\n \n@@ -4425,17 +4432,6 @@ package body Sem_Ch12 is\n          end if;\n \n          if Needs_Body then\n-\n-            --  Here is a defence against a ludicrous number of instantiations\n-            --  caused by a circular set of instantiation attempts.\n-\n-            if Pending_Instantiations.Last > Maximum_Instantiations then\n-               Error_Msg_Uint_1 := UI_From_Int (Maximum_Instantiations);\n-               Error_Msg_N (\"too many instantiations, exceeds max of^\", N);\n-               Error_Msg_N (\"\\limit can be changed using -gnateinn switch\", N);\n-               raise Unrecoverable_Error;\n-            end if;\n-\n             --  Indicate that the enclosing scopes contain an instantiation,\n             --  and that cleanup actions should be delayed until after the\n             --  instance body is expanded.\n@@ -4633,11 +4629,10 @@ package body Sem_Ch12 is\n          --  The instantiation results in a guaranteed ABE\n \n          if Is_Known_Guaranteed_ABE (N) and then Needs_Body then\n-\n             --  Do not instantiate the corresponding body because gigi cannot\n             --  handle certain types of premature instantiations.\n \n-            Pending_Instantiations.Decrement_Last;\n+            Remove_Dead_Instance (N);\n \n             --  Create completing bodies for all subprogram declarations since\n             --  their real bodies will not be instantiated."}]}