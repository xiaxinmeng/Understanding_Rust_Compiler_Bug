{"sha": "e9b7093a9f2c1125a3c0adc8f2a8d77f562631ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTliNzA5M2E5ZjJjMTEyNWEzYzBhZGM4ZjJhOGQ3N2Y1NjI2MzFmZg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-22T18:29:43Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-22T18:29:43Z"}, "message": "(combine_temp_slots): Handle deletion properly.\n\nFree the RTL that is allocated.\n\nFrom-SVN: r5401", "tree": {"sha": "c849f423fab0fec4dc2dd8d45929eeaba832cbec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c849f423fab0fec4dc2dd8d45929eeaba832cbec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9b7093a9f2c1125a3c0adc8f2a8d77f562631ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9b7093a9f2c1125a3c0adc8f2a8d77f562631ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9b7093a9f2c1125a3c0adc8f2a8d77f562631ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9b7093a9f2c1125a3c0adc8f2a8d77f562631ff/comments", "author": null, "committer": null, "parents": [{"sha": "635b1dad854b47d35904cbed864193e6345b91ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/635b1dad854b47d35904cbed864193e6345b91ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/635b1dad854b47d35904cbed864193e6345b91ea"}], "stats": {"total": 62, "additions": 43, "deletions": 19}, "files": [{"sha": "b75e4969938ac334e9865d6ccce9848033ed6e05", "filename": "gcc/function.c", "status": "modified", "additions": 43, "deletions": 19, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9b7093a9f2c1125a3c0adc8f2a8d77f562631ff/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9b7093a9f2c1125a3c0adc8f2a8d77f562631ff/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=e9b7093a9f2c1125a3c0adc8f2a8d77f562631ff", "patch": "@@ -782,30 +782,54 @@ combine_temp_slots ()\n {\n   struct temp_slot *p, *q;\n   struct temp_slot *prev_p, *prev_q;\n+  /* Determine where to free back to after this function.  */\n+  rtx free_pointer = rtx_alloc (CONST_INT);\n \n-  for (p = temp_slots, prev_p = 0; p; prev_p = p, p = p->next)\n-    if (! p->in_use && GET_MODE (p->slot) == BLKmode)\n-      for (q = p->next, prev_q = p; q; prev_q = q, q = q->next)\n-\tif (! q->in_use && GET_MODE (q->slot) == BLKmode)\n+  for (p = temp_slots, prev_p = 0; p; p = prev_p ? prev_p->next : temp_slots)\n+    {\n+      int delete_p = 0;\n+      if (! p->in_use && GET_MODE (p->slot) == BLKmode)\n+\tfor (q = p->next, prev_q = p; q; q = prev_q->next)\n \t  {\n-\t    if (rtx_equal_p (plus_constant (XEXP (p->slot, 0), p->size),\n-\t\t\t     XEXP (q->slot, 0)))\n-\t      {\n-\t\t/* Combine q into p.  */\n-\t\tp->size += q->size;\n-\t\tprev_q->next = q->next;\n-\t      }\n-\t    else if (rtx_equal_p (plus_constant (XEXP (q->slot, 0), q->size),\n-\t\t\t\t  XEXP (p->slot, 0)))\n+\t    int delete_q = 0;\n+\t    if (! q->in_use && GET_MODE (q->slot) == BLKmode)\n \t      {\n-\t\t/* Combine p into q.  */\n-\t\tq->size += p->size;\n-\t\tif (prev_p)\n-\t\t  prev_p->next = p->next;\n-\t\telse\n-\t\t  temp_slots = p->next;\n+\t\tif (rtx_equal_p (plus_constant (XEXP (p->slot, 0), p->size),\n+\t\t\t\t XEXP (q->slot, 0)))\n+\t\t  {\n+\t\t    /* Q comes after P; combine Q into P.  */\n+\t\t    p->size += q->size;\n+\t\t    delete_q = 1;\n+\t\t  }\n+\t\telse if (rtx_equal_p (plus_constant (XEXP (q->slot, 0), q->size),\n+\t\t\t\t      XEXP (p->slot, 0)))\n+\t\t  {\n+\t\t    /* P comes after Q; combine P into Q.  */\n+\t\t    q->size += p->size;\n+\t\t    delete_p = 1;\n+\t\t    break;\n+\t\t  }\n \t      }\n+\t    /* Either delete Q or advance past it.  */\n+\t    if (delete_q)\n+\t      prev_q->next = q->next;\n+\t    else\n+\t      prev_q = q;\n \t  }\n+      /* Either delete P or advance past it.  */\n+      if (delete_p)\n+\t{\n+\t  if (prev_p)\n+\t    prev_p->next = p->next;\n+\t  else\n+\t    temp_slots = p->next;\n+\t}\n+      else\n+\tprev_p = p;\n+    }\n+\n+  /* Free all the RTL made by plus_constant.  */ \n+  rtx_free (free_pointer);\n }\n \f\n /* If X could be a reference to a temporary slot, mark that slot as belonging"}]}