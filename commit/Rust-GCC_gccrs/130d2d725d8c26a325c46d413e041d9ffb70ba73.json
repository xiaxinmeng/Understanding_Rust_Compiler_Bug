{"sha": "130d2d725d8c26a325c46d413e041d9ffb70ba73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTMwZDJkNzI1ZDhjMjZhMzI1YzQ2ZDQxM2UwNDFkOWZmYjcwYmE3Mw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-02-10T21:12:20Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-02-10T21:12:20Z"}, "message": "(ASM_OUTPUT_LOOP_ALIGN): Enable, now that assembler fixed.\n\n(SLOW_UNALIGNED_ACCESS): Define as 1.\n(ARG_POINTER_REGNUM): Use register number 31 as an arg pointer.\n(FRAME_GROWS_DOWNWARD): Do not define.\n(STARTING_FRAME_OFFSET): Now is outgoing args size.\n(FIRST_PARM_OFFSET): Now 0.\n(ELIMINABLE_REGS, etc.): Cannot eliminate gp, but do eliminate AP in favor\nof either SP or FP.\n(RETURN_IN_MEMORY): All structs or integers larger than 64 bits get returned\nvia memory.\n(SETUP_INCOMING_VARARGS): Use homed arglist mechanism.\n(ASM_DECLARE_FUNCTION_NAME): Use proper second arg to .ent.\n(ASM_FILE_START): Call alpha_write_verstamp.\n(ENCODE_SECTION_INFO): Record when a decl is for a function in the current\nfile.\n\nFrom-SVN: r3457", "tree": {"sha": "3bc443d87f01ac951037429a2403ab72f0e26485", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bc443d87f01ac951037429a2403ab72f0e26485"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/130d2d725d8c26a325c46d413e041d9ffb70ba73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/130d2d725d8c26a325c46d413e041d9ffb70ba73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/130d2d725d8c26a325c46d413e041d9ffb70ba73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/130d2d725d8c26a325c46d413e041d9ffb70ba73/comments", "author": null, "committer": null, "parents": [{"sha": "63a05e281836c2b6ef47306f20b00d810a4b53f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63a05e281836c2b6ef47306f20b00d810a4b53f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63a05e281836c2b6ef47306f20b00d810a4b53f8"}], "stats": {"total": 137, "additions": 102, "deletions": 35}, "files": [{"sha": "8de0adc37ec9a3bae310132459c5bb97afcf31d6", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 102, "deletions": 35, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/130d2d725d8c26a325c46d413e041d9ffb70ba73/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/130d2d725d8c26a325c46d413e041d9ffb70ba73/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=130d2d725d8c26a325c46d413e041d9ffb70ba73", "patch": "@@ -206,16 +206,15 @@ extern int target_flags;\n /* A bitfield declared as `int' forces `int' alignment for the struct.  */\n #define PCC_BITFIELD_TYPE_MATTERS 1\n \n-/* Align loop starts for optimal branching. \n+/* Align loop starts for optimal branching.  */\n \n-   Don't do this until they fix the assembler.  */\n-\n-/* #define ASM_OUTPUT_LOOP_ALIGN(FILE) \\\n-  ASM_OUTPUT_ALIGN (FILE, 5)  */\n+#define ASM_OUTPUT_LOOP_ALIGN(FILE) \\\n+  ASM_OUTPUT_ALIGN (FILE, 5) \n \n /* This is how to align an instruction for optimal branching.\n    On Alpha we'll get better performance by aligning on a quadword\n    boundary.  */\n+\n #define ASM_OUTPUT_ALIGN_CODE(FILE)\t\\\n   ASM_OUTPUT_ALIGN ((FILE), 4)\n \n@@ -243,7 +242,8 @@ extern int target_flags;\n /* Set this non-zero if unaligned move instructions are extremely slow.\n \n    On the Alpha, they trap.  */\n-/* #define SLOW_UNALIGNED_ACCESS 1  */\n+\n+#define SLOW_UNALIGNED_ACCESS 1\n \f\n /* Standard register usage.  */\n \n@@ -256,7 +256,12 @@ extern int target_flags;\n    We define all 32 integer registers, even though $31 is always zero,\n    and all 32 floating-point registers, even though $f31 is also\n    always zero.  We do not bother defining the FP status register and\n-   there are no other registers.  */\n+   there are no other registers. \n+\n+   Since $31 is always zero, we will use register number 31 as the\n+   argument pointer.  It will never appear in the generated code\n+   because we will always be eliminating it in favor of the stack\n+   poointer or frame pointer.  */\n \n #define FIRST_PSEUDO_REGISTER 64\n \n@@ -301,7 +306,7 @@ extern int target_flags;\n    $26\t\t\t(return PC)\n    $15\t\t\t(frame pointer)\n    $29\t\t\t(global pointer)\n-   $30, $31, $f31\t(stack pointer and always zero)  */\n+   $30, $31, $f31\t(stack pointer and always zero/ap)  */\n \n #define REG_ALLOC_ORDER\t\t\\\n   {33,\t\t\t\t\t\\\n@@ -365,7 +370,7 @@ extern int target_flags;\n #define FRAME_POINTER_REQUIRED 0\n \n /* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM 15\n+#define ARG_POINTER_REGNUM 31\n \n /* Register in which static-chain is passed to a function. \n \n@@ -563,14 +568,14 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n    is at the high-address end of the local variables;\n    that is, each additional local variable allocated\n    goes at a more negative offset in the frame.  */\n-#define FRAME_GROWS_DOWNWARD\n+/* #define FRAME_GROWS_DOWNWARD */\n \n /* Offset within stack frame to start allocating local variables at.\n    If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n    first local allocated.  Otherwise, it is the offset to the BEGINNING\n    of the first local allocated.  */\n \n-#define STARTING_FRAME_OFFSET (- current_function_pretend_args_size)\n+#define STARTING_FRAME_OFFSET current_function_outgoing_args_size\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.\n@@ -584,43 +589,39 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n \n /* Offset of first parameter from the argument pointer register value.  */\n \n-#define FIRST_PARM_OFFSET(FNDECL) (- current_function_pretend_args_size)\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n \n /* Definitions for register eliminations.\n \n-   We have one register that can be eliminated on the Alpha.  The\n+   We have two registers that can be eliminated on the i386.  First, the\n    frame pointer register can often be eliminated in favor of the stack\n-   pointer register.\n-\n-   In addition, we use the elimination mechanism to see if gp (r29) is needed.\n-   Initially we assume that it isn't.  If it is, we spill it.  This is done\n-   by making it an eliminable register.  It doesn't matter what we replace\n-   it with, since it will never occur in the rtl at this point.  */\n+   pointer register.  Secondly, the argument pointer register can always be\n+   eliminated; it is replaced with either the stack or frame pointer. */\n \n /* This is an array of structures.  Each structure initializes one pair\n    of eliminable registers.  The \"from\" register number is given first,\n    followed by \"to\".  Eliminations of the same \"from\" register are listed\n    in order of preference.  */\n \n #define ELIMINABLE_REGS\t\t\t\t\\\n-{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n- { 29, 0}}\n+{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n+ { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},   \\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n \n /* Given FROM and TO register numbers, say whether this elimination is allowed.\n    Frame pointer elimination is automatically handled.\n \n-   We need gp (r29) if we have calls or load symbols\n-   (tested in alpha_need_gp).\n-\n-   All other eliminations are valid since the cases where FP can't be\n+   All eliminations are valid since the cases where FP can't be\n    eliminated are already handled.  */\n \n-#define CAN_ELIMINATE(FROM, TO) ((FROM) == 29 ? ! alpha_need_gp () : 1)\n+#define CAN_ELIMINATE(FROM, TO) 1\n \n /* Define the offset between two registers, one to be eliminated, and the other\n    its replacement, at the start of a routine.  */\n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n { if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n+    (OFFSET) = 0;\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n     (OFFSET) = (get_frame_size () + current_function_outgoing_args_size \\\n \t\t+ current_function_pretend_args_size\t\t\t\\\n \t\t+ alpha_sa_size () + 15) & ~ 15;\t\t\t\\\n@@ -665,6 +666,16 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n    gen_rtx (REG, MODE,\t\t\\\n \t    TARGET_FPREGS && GET_MODE_CLASS (MODE) == MODE_FLOAT ? 32 : 0)\n \n+/* The definition of this macro implies that there are cases where\n+   a scalar value cannot be returned in registers.\n+\n+   For the Alpha, any structure or union type is returned in memory, as\n+   are integers whose size is larger than 64 bits.  */\n+\n+#define RETURN_IN_MEMORY(TYPE) \\\n+  (TREE_CODE (TYPE) == RECORD_TYPE || TREE_CODE (TYPE) == UNION_TYPE  \\\n+   || (TREE_CODE (TYPE) == INTEGER_TYPE && TYPE_PRECISION (TYPE) > 64))\n+\n /* 1 if N is a possible register number for a function value\n    as seen by the caller.  */\n \n@@ -749,6 +760,50 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n ((CUM) < 6 && 6 < (CUM) + ALPHA_ARG_SIZE (MODE, TYPE, NAMED)\t\\\n  ? 6 - (CUM) : 0)\n \n+/* Perform any needed actions needed for a function that is receiving a\n+   variable number of arguments. \n+\n+   CUM is as above.\n+\n+   MODE and TYPE are the mode and type of the current parameter.\n+\n+   PRETEND_SIZE is a variable that should be set to the amount of stack\n+   that must be pushed by the prolog to pretend that our caller pushed\n+   it.\n+\n+   Normally, this macro will push all remaining incoming registers on the\n+   stack and set PRETEND_SIZE to the length of the registers pushed. \n+\n+   On the Alpha, we allocate space for all 12 arg registers, but only\n+   push those that are remaining.\n+\n+   However, if NO registers need to be saved, don't allocate any space.\n+   This is not only because we won't need the space, but because AP includes\n+   the current_pretend_args_size and we don't want to mess up any\n+   ap-relative addresses already made.  */\n+\n+#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n+{ if ((CUM) < 6)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (! (NO_RTL))\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  move_block_from_reg\t\t\t\t\t\t\\\n+\t    (16 + CUM,\t\t\t\t\t\t\t\\\n+\t     gen_rtx (MEM, BLKmode,\t\t\t\t\t\\\n+\t\t      plus_constant (virtual_incoming_args_rtx,\t\t\\\n+\t\t\t\t     ((CUM) - 6) * UNITS_PER_WORD)),\t\\\n+\t     6 - (CUM));\t\t\t\t\t\t\\\n+\t  move_block_from_reg\t\t\t\t\t\t\\\n+\t    (16 + 32 + CUM,\t\t\t\t\t\t\\\n+\t     gen_rtx (MEM, BLKmode,\t\t\t\t\t\\\n+\t\t      plus_constant (virtual_incoming_args_rtx,\t\t\\\n+\t\t\t\t     ((CUM) - 12) * UNITS_PER_WORD)),\t\\\n+\t     6 - (CUM));\t\t\t\t\t\t\\\n+\t }\t\t\t\t\t\t\t\t\\\n+      PRETEND_SIZE = 12 * UNITS_PER_WORD;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n /* Generate necessary RTL for __builtin_saveregs().\n    ARGLIST is the argument list; see expr.c.  */\n extern struct rtx_def *alpha_builtin_saveregs ();\n@@ -762,12 +817,17 @@ extern struct rtx_def *alpha_compare_op0, *alpha_compare_op1;\n extern int alpha_compare_fp_p;\n \n /* This macro produces the initial definition of a function name.  On the\n-   29k, we need to save the function name for the epilogue.  */\n+   Alpha, we need to save the function name for the epilogue.  */\n \n extern char *alpha_function_name;\n \n #define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL)\t\\\n- { fprintf (FILE, \"\\t.ent %s 2\\n\", NAME);\t\t\\\n+ { int _level;\t\t\t\t\t\t\\\n+   tree _context;\t\t\t\t\t\\\n+   for (_level = -1, _context = (DECL); _context;\t\\\n+\t_context = DECL_CONTEXT (_context), _level++) \\\n+     ;\t\t\t\t\t\t\t\\\n+   fprintf (FILE, \"\\t.ent %s %d\\n\", NAME, _level);\t\\\n    ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\\\n    alpha_function_name = NAME;\t\t\t\t\\\n }\n@@ -1253,13 +1313,10 @@ extern char *current_function_name;\n /* Output at beginning of assembler file.  */\n \n #define ASM_FILE_START(FILE)\t\t\t\t\t\\\n-{ extern char *version_string;\t\t\t\t\t\\\n-  char *p, *after_dir = main_input_filename;\t\t\t\\\n+{ char *p, *after_dir = main_input_filename;\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.verstamp 10 0 \");\t\t\t\t\\\n-  for (p = version_string; *p != ' ' && *p != 0; p++)\t\t\\\n-    fprintf (FILE, \"%c\", *p == '.' ? ' ' : *p);\t\t\t\\\n-  fprintf (FILE, \"\\n\\t.set noreorder\\n\");\t\t\t\\\n+  alpha_write_verstamp (FILE);\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.set noreorder\\n\");\t\t\t\t\\\n   fprintf (FILE, \"\\t.set noat\\n\");\t\t\t\t\\\n   for (p = main_input_filename; *p; p++)\t\t\t\\\n     if (*p == '/')\t\t\t\t\t\t\\\n@@ -1305,14 +1362,24 @@ literal_section ()\t\t\t\t\t\t\\\n \n #define READONLY_DATA_SECTION\tliteral_section\n \n+/* If we are referencing a function that is static or is known to be\n+   in this file, make the SYMBOL_REF special.  We can use this to see\n+   indicate that we can branch to this function without setting PV or\n+   restoring GP.  */\n+\n+#define ENCODE_SECTION_INFO(DECL)  \\\n+  if (TREE_CODE (DECL) == FUNCTION_DECL\t\t\t\\\n+      && (TREE_ASM_WRITTEN (DECL) || ! TREE_PUBLIC (DECL))) \\\n+    SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\n+\n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n \n #define REGISTER_NAMES\t\t\t\t\t\t\\\n {\"$0\", \"$1\", \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\",\t\t\\\n  \"$9\", \"$10\", \"$11\", \"$12\", \"$13\", \"$14\", \"$15\",\t\t\\\n  \"$16\", \"$17\", \"$18\", \"$19\", \"$20\", \"$21\", \"$22\", \"$23\",\t\\\n- \"$24\", \"$25\", \"$26\", \"$27\", \"$28\", \"$29\", \"$30\", \"$31\",\t\\\n+ \"$24\", \"$25\", \"$26\", \"$27\", \"$28\", \"$29\", \"$30\", \"AP\",\t\t\\\n  \"$f0\", \"$f1\", \"$f2\", \"$f3\", \"$f4\", \"$f5\", \"$f6\", \"$f7\", \"$f8\",\t\\\n  \"$f9\", \"$f10\", \"$f11\", \"$f12\", \"$f13\", \"$f14\", \"$f15\",\t\t\\\n  \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\\"}]}