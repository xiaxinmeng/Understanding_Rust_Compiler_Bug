{"sha": "5e2869e6b473100b35b3e0808c0a5a471ffdb9be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUyODY5ZTZiNDczMTAwYjM1YjNlMDgwOGMwYTVhNDcxZmZkYjliZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-23T13:10:05Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-23T13:10:05Z"}, "message": "Don't include gvarargs.h.\n\n(emit_library_call, emit_library_call_value): Delete from here.\n\nFrom-SVN: r3849", "tree": {"sha": "a2c837eb4904d046ea0c386f492f1db490963ff5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2c837eb4904d046ea0c386f492f1db490963ff5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e2869e6b473100b35b3e0808c0a5a471ffdb9be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e2869e6b473100b35b3e0808c0a5a471ffdb9be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e2869e6b473100b35b3e0808c0a5a471ffdb9be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e2869e6b473100b35b3e0808c0a5a471ffdb9be/comments", "author": null, "committer": null, "parents": [{"sha": "322e3e342039ed1f1aa8a53cd3948ed9313b87c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/322e3e342039ed1f1aa8a53cd3948ed9313b87c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/322e3e342039ed1f1aa8a53cd3948ed9313b87c5"}], "stats": {"total": 599, "additions": 0, "deletions": 599}, "files": [{"sha": "0f2885cb10435bffcdb3dfbcbfd2d911be5cfb42", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 599, "changes": 599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2869e6b473100b35b3e0808c0a5a471ffdb9be/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2869e6b473100b35b3e0808c0a5a471ffdb9be/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5e2869e6b473100b35b3e0808c0a5a471ffdb9be", "patch": "@@ -29,7 +29,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"insn-config.h\"\n #include \"recog.h\"\n #include \"output.h\"\n-#include \"gvarargs.h\"\n #include \"typeclass.h\"\n \n #define CEIL(x,y) (((x) + (y) - 1) / (y))\n@@ -2125,604 +2124,6 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n     anti_adjust_stack (GEN_INT (extra));\n }\n \f\n-/* Output a library call to function FUN (a SYMBOL_REF rtx)\n-   (emitting the queue unless NO_QUEUE is nonzero),\n-   for a value of mode OUTMODE,\n-   with NARGS different arguments, passed as alternating rtx values\n-   and machine_modes to convert them to.\n-   The rtx values should have been passed through protect_from_queue already.\n-\n-   NO_QUEUE will be true if and only if the library call is a `const' call\n-   which will be enclosed in REG_LIBCALL/REG_RETVAL notes; it is equivalent\n-   to the variable is_const in expand_call.\n-\n-   NO_QUEUE must be true for const calls, because if it isn't, then\n-   any pending increment will be emitted between REG_LIBCALL/REG_RETVAL notes,\n-   and will be lost if the libcall sequence is optimized away.\n-\n-   NO_QUEUE must be false for non-const calls, because if it isn't, the\n-   call insn will have its CONST_CALL_P bit set, and it will be incorrectly\n-   optimized.  For instance, the instruction scheduler may incorrectly\n-   move memory references across the non-const call.  */\n-\n-void\n-emit_library_call (va_alist)\n-     va_dcl\n-{\n-  va_list p;\n-  /* Total size in bytes of all the stack-parms scanned so far.  */\n-  struct args_size args_size;\n-  /* Size of arguments before any adjustments (such as rounding).  */\n-  struct args_size original_args_size;\n-  register int argnum;\n-  enum machine_mode outmode;\n-  int nargs;\n-  rtx fun;\n-  rtx orgfun;\n-  int inc;\n-  int count;\n-  rtx argblock = 0;\n-  CUMULATIVE_ARGS args_so_far;\n-  struct arg { rtx value; enum machine_mode mode; rtx reg; int partial;\n-\t       struct args_size offset; struct args_size size; };\n-  struct arg *argvec;\n-  int old_inhibit_defer_pop = inhibit_defer_pop;\n-  int no_queue = 0;\n-  rtx use_insns;\n-\n-  va_start (p);\n-  orgfun = fun = va_arg (p, rtx);\n-  no_queue = va_arg (p, int);\n-  outmode = va_arg (p, enum machine_mode);\n-  nargs = va_arg (p, int);\n-\n-  /* Copy all the libcall-arguments out of the varargs data\n-     and into a vector ARGVEC.\n-\n-     Compute how to pass each argument.  We only support a very small subset\n-     of the full argument passing conventions to limit complexity here since\n-     library functions shouldn't have many args.  */\n-\n-  argvec = (struct arg *) alloca (nargs * sizeof (struct arg));\n-\n-  INIT_CUMULATIVE_ARGS (args_so_far, NULL_TREE, fun);\n-\n-  args_size.constant = 0;\n-  args_size.var = 0;\n-\n-  for (count = 0; count < nargs; count++)\n-    {\n-      rtx val = va_arg (p, rtx);\n-      enum machine_mode mode = va_arg (p, enum machine_mode);\n-\n-      /* We cannot convert the arg value to the mode the library wants here;\n-\t must do it earlier where we know the signedness of the arg.  */\n-      if (mode == BLKmode\n-\t  || (GET_MODE (val) != mode && GET_MODE (val) != VOIDmode))\n-\tabort ();\n-\n-      /* On some machines, there's no way to pass a float to a library fcn.\n-\t Pass it as a double instead.  */\n-#ifdef LIBGCC_NEEDS_DOUBLE\n-      if (LIBGCC_NEEDS_DOUBLE && mode == SFmode)\n-\tval = convert_to_mode (DFmode, val, 0), mode = DFmode;\n-#endif\n-\n-      /* There's no need to call protect_from_queue, because\n-\t either emit_move_insn or emit_push_insn will do that.  */\n-\n-      /* Make sure it is a reasonable operand for a move or push insn.  */\n-      if (GET_CODE (val) != REG && GET_CODE (val) != MEM\n-\t  && ! (CONSTANT_P (val) && LEGITIMATE_CONSTANT_P (val)))\n-\tval = force_operand (val, NULL_RTX);\n-\n-      argvec[count].value = val;\n-      argvec[count].mode = mode;\n-\n-#ifdef FUNCTION_ARG_PASS_BY_REFERENCE\n-      if (FUNCTION_ARG_PASS_BY_REFERENCE (args_so_far, mode, NULL_TREE, 1))\n-\tabort ();\n-#endif\n-\n-      argvec[count].reg = FUNCTION_ARG (args_so_far, mode, NULL_TREE, 1);\n-      if (argvec[count].reg && GET_CODE (argvec[count].reg) == EXPR_LIST)\n-\tabort ();\n-#ifdef FUNCTION_ARG_PARTIAL_NREGS\n-      argvec[count].partial\n-\t= FUNCTION_ARG_PARTIAL_NREGS (args_so_far, mode, NULL_TREE, 1);\n-#else\n-      argvec[count].partial = 0;\n-#endif\n-\n-      locate_and_pad_parm (mode, NULL_TREE,\n-\t\t\t   argvec[count].reg && argvec[count].partial == 0,\n-\t\t\t   NULL_TREE, &args_size, &argvec[count].offset,\n-\t\t\t   &argvec[count].size);\n-\n-      if (argvec[count].size.var)\n-\tabort ();\n-\n-#ifndef REG_PARM_STACK_SPACE\n-      if (argvec[count].partial)\n-\targvec[count].size.constant -= argvec[count].partial * UNITS_PER_WORD;\n-#endif\n-\n-      if (argvec[count].reg == 0 || argvec[count].partial != 0\n-#ifdef REG_PARM_STACK_SPACE\n-\t  || 1\n-#endif\n-\t  )\n-\targs_size.constant += argvec[count].size.constant;\n-\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-      /* If this arg is actually passed on the stack, it might be\n-\t clobbering something we already put there (this library call might\n-\t be inside the evaluation of an argument to a function whose call\n-\t requires the stack).  This will only occur when the library call\n-\t has sufficient args to run out of argument registers.  Abort in\n-\t this case; if this ever occurs, code must be added to save and\n-\t restore the arg slot.  */\n-\n-      if (argvec[count].reg == 0 || argvec[count].partial != 0)\n-\tabort ();\n-#endif\n-\n-      FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree)0, 1);\n-    }\n-  va_end (p);\n-\n-  /* If this machine requires an external definition for library\n-     functions, write one out.  */\n-  assemble_external_libcall (fun);\n-\n-  original_args_size = args_size;\n-#ifdef STACK_BOUNDARY\n-  args_size.constant = (((args_size.constant + (STACK_BYTES - 1))\n-\t\t\t / STACK_BYTES) * STACK_BYTES);\n-#endif\n-\n-#ifdef REG_PARM_STACK_SPACE\n-  args_size.constant = MAX (args_size.constant,\n-\t\t\t    REG_PARM_STACK_SPACE (NULL_TREE));\n-#ifndef OUTGOING_REG_PARM_STACK_SPACE\n-  args_size.constant -= REG_PARM_STACK_SPACE (NULL_TREE);\n-#endif\n-#endif\n-\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-  if (args_size.constant > current_function_outgoing_args_size)\n-    current_function_outgoing_args_size = args_size.constant;\n-  args_size.constant = 0;\n-#endif\n-\n-#ifndef PUSH_ROUNDING\n-  argblock = push_block (GEN_INT (args_size.constant), 0, 0);\n-#endif\n-\n-#ifdef PUSH_ARGS_REVERSED\n-#ifdef STACK_BOUNDARY\n-  /* If we push args individually in reverse order, perform stack alignment\n-     before the first push (the last arg).  */\n-  if (argblock == 0)\n-    anti_adjust_stack (GEN_INT (args_size.constant\n-\t\t\t\t- original_args_size.constant));\n-#endif\n-#endif\n-\n-#ifdef PUSH_ARGS_REVERSED\n-  inc = -1;\n-  argnum = nargs - 1;\n-#else\n-  inc = 1;\n-  argnum = 0;\n-#endif\n-\n-  /* Push the args that need to be pushed.  */\n-\n-  for (count = 0; count < nargs; count++, argnum += inc)\n-    {\n-      register enum machine_mode mode = argvec[argnum].mode;\n-      register rtx val = argvec[argnum].value;\n-      rtx reg = argvec[argnum].reg;\n-      int partial = argvec[argnum].partial;\n-\n-      if (! (reg != 0 && partial == 0))\n-\temit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n-\t\t\targblock, GEN_INT (argvec[count].offset.constant));\n-      NO_DEFER_POP;\n-    }\n-\n-#ifndef PUSH_ARGS_REVERSED\n-#ifdef STACK_BOUNDARY\n-  /* If we pushed args in forward order, perform stack alignment\n-     after pushing the last arg.  */\n-  if (argblock == 0)\n-    anti_adjust_stack (GEN_INT (args_size.constant\n-\t\t\t\t- original_args_size.constant));\n-#endif\n-#endif\n-\n-#ifdef PUSH_ARGS_REVERSED\n-  argnum = nargs - 1;\n-#else\n-  argnum = 0;\n-#endif\n-\n-  /* Now load any reg parms into their regs.  */\n-\n-  for (count = 0; count < nargs; count++, argnum += inc)\n-    {\n-      register enum machine_mode mode = argvec[argnum].mode;\n-      register rtx val = argvec[argnum].value;\n-      rtx reg = argvec[argnum].reg;\n-      int partial = argvec[argnum].partial;\n-\n-      if (reg != 0 && partial == 0)\n-\temit_move_insn (reg, val);\n-      NO_DEFER_POP;\n-    }\n-\n-  /* For version 1.37, try deleting this entirely.  */\n-  if (! no_queue)\n-    emit_queue ();\n-\n-  /* Any regs containing parms remain in use through the call.  */\n-  start_sequence ();\n-  for (count = 0; count < nargs; count++)\n-    if (argvec[count].reg != 0)\n-      emit_insn (gen_rtx (USE, VOIDmode, argvec[count].reg));\n-\n-  use_insns = get_insns ();\n-  end_sequence ();\n-\n-  fun = prepare_call_address (fun, NULL_TREE, &use_insns);\n-\n-  /* Don't allow popping to be deferred, since then\n-     cse'ing of library calls could delete a call and leave the pop.  */\n-  NO_DEFER_POP;\n-\n-  /* We pass the old value of inhibit_defer_pop + 1 to emit_call_1, which\n-     will set inhibit_defer_pop to that value.  */\n-\n-  emit_call_1 (fun, get_identifier (XSTR (orgfun, 0)), args_size.constant, 0,\n-\t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n-\t       outmode != VOIDmode ? hard_libcall_value (outmode) : NULL_RTX,\n-\t       old_inhibit_defer_pop + 1, use_insns, no_queue);\n-\n-  /* Now restore inhibit_defer_pop to its actual original value.  */\n-  OK_DEFER_POP;\n-}\n-\f\n-/* Like emit_library_call except that an extra argument, VALUE,\n-   comes second and says where to store the result.\n-   (If VALUE is zero, the result comes in the function value register.)  */\n-\n-void\n-emit_library_call_value (va_alist)\n-     va_dcl\n-{\n-  va_list p;\n-  /* Total size in bytes of all the stack-parms scanned so far.  */\n-  struct args_size args_size;\n-  /* Size of arguments before any adjustments (such as rounding).  */\n-  struct args_size original_args_size;\n-  register int argnum;\n-  enum machine_mode outmode;\n-  int nargs;\n-  rtx fun;\n-  rtx orgfun;\n-  int inc;\n-  int count;\n-  rtx argblock = 0;\n-  CUMULATIVE_ARGS args_so_far;\n-  struct arg { rtx value; enum machine_mode mode; rtx reg; int partial;\n-\t       struct args_size offset; struct args_size size; };\n-  struct arg *argvec;\n-  int old_inhibit_defer_pop = inhibit_defer_pop;\n-  int no_queue = 0;\n-  rtx use_insns;\n-  rtx value;\n-  rtx mem_value = 0;\n-\n-  va_start (p);\n-  orgfun = fun = va_arg (p, rtx);\n-  value = va_arg (p, rtx);\n-  no_queue = va_arg (p, int);\n-  outmode = va_arg (p, enum machine_mode);\n-  nargs = va_arg (p, int);\n-\n-  /* If this kind of value comes back in memory,\n-     decide where in memory it should come back.  */\n-  if (RETURN_IN_MEMORY (type_for_mode (outmode, 0)))\n-    {\n-      if (GET_CODE (value) == MEM)\n-\tmem_value = value;\n-      else\n-\tmem_value = assign_stack_temp (outmode, GET_MODE_SIZE (outmode), 0);\n-    }\n-\n-  /* ??? Unfinished: must pass the memory address as an argument.  */\n-\n-  /* Copy all the libcall-arguments out of the varargs data\n-     and into a vector ARGVEC.\n-\n-     Compute how to pass each argument.  We only support a very small subset\n-     of the full argument passing conventions to limit complexity here since\n-     library functions shouldn't have many args.  */\n-\n-  argvec = (struct arg *) alloca ((nargs + 1) * sizeof (struct arg));\n-\n-  INIT_CUMULATIVE_ARGS (args_so_far, NULL_TREE, fun);\n-\n-  args_size.constant = 0;\n-  args_size.var = 0;\n-\n-  count = 0;\n-\n-  /* If there's a structure value address to be passed,\n-     either pass it in the special place, or pass it as an extra argument.  */\n-  if (mem_value)\n-    {\n-      rtx addr = XEXP (mem_value, 0);\n-\n-      if (! struct_value_rtx)\n-\t{\n-\t  nargs++;\n-\n-\t  /* Make sure it is a reasonable operand for a move or push insn.  */\n-\t  if (GET_CODE (addr) != REG && GET_CODE (addr) != MEM\n-\t      && ! (CONSTANT_P (addr) && LEGITIMATE_CONSTANT_P (addr)))\n-\t    addr = force_operand (addr, NULL_RTX);\n-\n-\t  argvec[count].value = addr;\n-\t  argvec[count].mode = outmode;\n-\t  argvec[count].partial = 0;\n-\n-\t  argvec[count].reg = FUNCTION_ARG (args_so_far, outmode, NULL_TREE, 1);\n-#ifdef FUNCTION_ARG_PARTIAL_NREGS\n-\t  if (FUNCTION_ARG_PARTIAL_NREGS (args_so_far, outmode, NULL_TREE, 1))\n-\t    abort ();\n-#endif\n-\n-\t  locate_and_pad_parm (outmode, NULL_TREE,\n-\t\t\t       argvec[count].reg && argvec[count].partial == 0,\n-\t\t\t       NULL_TREE, &args_size, &argvec[count].offset,\n-\t\t\t       &argvec[count].size);\n-\n-\n-\t  if (argvec[count].reg == 0 || argvec[count].partial != 0\n-#ifdef REG_PARM_STACK_SPACE\n-\t      || 1\n-#endif\n-\t      )\n-\t    args_size.constant += argvec[count].size.constant;\n-\n-\t  FUNCTION_ARG_ADVANCE (args_so_far, outmode, (tree)0, 1);\n-\t}\n-    }\n-\n-  for (; count < nargs; count++)\n-    {\n-      rtx val = va_arg (p, rtx);\n-      enum machine_mode mode = va_arg (p, enum machine_mode);\n-\n-      /* We cannot convert the arg value to the mode the library wants here;\n-\t must do it earlier where we know the signedness of the arg.  */\n-      if (mode == BLKmode\n-\t  || (GET_MODE (val) != mode && GET_MODE (val) != VOIDmode))\n-\tabort ();\n-\n-      /* On some machines, there's no way to pass a float to a library fcn.\n-\t Pass it as a double instead.  */\n-#ifdef LIBGCC_NEEDS_DOUBLE\n-      if (LIBGCC_NEEDS_DOUBLE && mode == SFmode)\n-\tval = convert_to_mode (DFmode, val, 0), mode = DFmode;\n-#endif\n-\n-      /* There's no need to call protect_from_queue, because\n-\t either emit_move_insn or emit_push_insn will do that.  */\n-\n-      /* Make sure it is a reasonable operand for a move or push insn.  */\n-      if (GET_CODE (val) != REG && GET_CODE (val) != MEM\n-\t  && ! (CONSTANT_P (val) && LEGITIMATE_CONSTANT_P (val)))\n-\tval = force_operand (val, NULL_RTX);\n-\n-      argvec[count].value = val;\n-      argvec[count].mode = mode;\n-\n-#ifdef FUNCTION_ARG_PASS_BY_REFERENCE\n-      if (FUNCTION_ARG_PASS_BY_REFERENCE (args_so_far, mode, NULL_TREE, 1))\n-\tabort ();\n-#endif\n-\n-      argvec[count].reg = FUNCTION_ARG (args_so_far, mode, NULL_TREE, 1);\n-      if (argvec[count].reg && GET_CODE (argvec[count].reg) == EXPR_LIST)\n-\tabort ();\n-#ifdef FUNCTION_ARG_PARTIAL_NREGS\n-      argvec[count].partial\n-\t= FUNCTION_ARG_PARTIAL_NREGS (args_so_far, mode, NULL_TREE, 1);\n-#else\n-      argvec[count].partial = 0;\n-#endif\n-\n-      locate_and_pad_parm (mode, NULL_TREE,\n-\t\t\t   argvec[count].reg && argvec[count].partial == 0,\n-\t\t\t   NULL_TREE, &args_size, &argvec[count].offset,\n-\t\t\t   &argvec[count].size);\n-\n-      if (argvec[count].size.var)\n-\tabort ();\n-\n-#ifndef REG_PARM_STACK_SPACE\n-      if (argvec[count].partial)\n-\targvec[count].size.constant -= argvec[count].partial * UNITS_PER_WORD;\n-#endif\n-\n-      if (argvec[count].reg == 0 || argvec[count].partial != 0\n-#ifdef REG_PARM_STACK_SPACE\n-\t  || 1\n-#endif\n-\t  )\n-\targs_size.constant += argvec[count].size.constant;\n-\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-      /* If this arg is actually passed on the stack, it might be\n-\t clobbering something we already put there (this library call might\n-\t be inside the evaluation of an argument to a function whose call\n-\t requires the stack).  This will only occur when the library call\n-\t has sufficient args to run out of argument registers.  Abort in\n-\t this case; if this ever occurs, code must be added to save and\n-\t restore the arg slot.  */\n-\n-      if (argvec[count].reg == 0 || argvec[count].partial != 0)\n-\tabort ();\n-#endif\n-\n-      FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree)0, 1);\n-    }\n-  va_end (p);\n-\n-  /* If this machine requires an external definition for library\n-     functions, write one out.  */\n-  assemble_external_libcall (fun);\n-\n-  original_args_size = args_size;\n-#ifdef STACK_BOUNDARY\n-  args_size.constant = (((args_size.constant + (STACK_BYTES - 1))\n-\t\t\t / STACK_BYTES) * STACK_BYTES);\n-#endif\n-\n-#ifdef REG_PARM_STACK_SPACE\n-  args_size.constant = MAX (args_size.constant,\n-\t\t\t    REG_PARM_STACK_SPACE (NULL_TREE));\n-#ifndef OUTGOING_REG_PARM_STACK_SPACE\n-  args_size.constant -= REG_PARM_STACK_SPACE (NULL_TREE);\n-#endif\n-#endif\n-\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-  if (args_size.constant > current_function_outgoing_args_size)\n-    current_function_outgoing_args_size = args_size.constant;\n-  args_size.constant = 0;\n-#endif\n-\n-#ifndef PUSH_ROUNDING\n-  argblock = push_block (GEN_INT (args_size.constant), 0, 0);\n-#endif\n-\n-#ifdef PUSH_ARGS_REVERSED\n-#ifdef STACK_BOUNDARY\n-  /* If we push args individually in reverse order, perform stack alignment\n-     before the first push (the last arg).  */\n-  if (argblock == 0)\n-    anti_adjust_stack (GEN_INT (args_size.constant\n-\t\t\t\t- original_args_size.constant));\n-#endif\n-#endif\n-\n-#ifdef PUSH_ARGS_REVERSED\n-  inc = -1;\n-  argnum = nargs - 1;\n-#else\n-  inc = 1;\n-  argnum = 0;\n-#endif\n-\n-  /* Push the args that need to be pushed.  */\n-\n-  for (count = 0; count < nargs; count++, argnum += inc)\n-    {\n-      register enum machine_mode mode = argvec[argnum].mode;\n-      register rtx val = argvec[argnum].value;\n-      rtx reg = argvec[argnum].reg;\n-      int partial = argvec[argnum].partial;\n-\n-      if (! (reg != 0 && partial == 0))\n-\temit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n-\t\t\targblock, GEN_INT (argvec[count].offset.constant));\n-      NO_DEFER_POP;\n-    }\n-\n-#ifndef PUSH_ARGS_REVERSED\n-#ifdef STACK_BOUNDARY\n-  /* If we pushed args in forward order, perform stack alignment\n-     after pushing the last arg.  */\n-  if (argblock == 0)\n-    anti_adjust_stack (GEN_INT (args_size.constant\n-\t\t\t\t- original_args_size.constant));\n-#endif\n-#endif\n-\n-#ifdef PUSH_ARGS_REVERSED\n-  argnum = nargs - 1;\n-#else\n-  argnum = 0;\n-#endif\n-\n-  /* Now load any reg parms into their regs.  */\n-\n-  if (mem_value != 0 && struct_value_rtx != 0)\n-    emit_move_insn (struct_value_rtx, XEXP (mem_value, 0));\n-\n-  for (count = 0; count < nargs; count++, argnum += inc)\n-    {\n-      register enum machine_mode mode = argvec[argnum].mode;\n-      register rtx val = argvec[argnum].value;\n-      rtx reg = argvec[argnum].reg;\n-      int partial = argvec[argnum].partial;\n-\n-      if (reg != 0 && partial == 0)\n-\temit_move_insn (reg, val);\n-      NO_DEFER_POP;\n-    }\n-\n-#if 0\n-  /* For version 1.37, try deleting this entirely.  */\n-  if (! no_queue)\n-    emit_queue ();\n-#endif\n-\n-  /* Any regs containing parms remain in use through the call.  */\n-  start_sequence ();\n-  for (count = 0; count < nargs; count++)\n-    if (argvec[count].reg != 0)\n-      emit_insn (gen_rtx (USE, VOIDmode, argvec[count].reg));\n-\n-  use_insns = get_insns ();\n-  end_sequence ();\n-\n-  fun = prepare_call_address (fun, NULL_TREE, &use_insns);\n-\n-  /* Don't allow popping to be deferred, since then\n-     cse'ing of library calls could delete a call and leave the pop.  */\n-  NO_DEFER_POP;\n-\n-  /* We pass the old value of inhibit_defer_pop + 1 to emit_call_1, which\n-     will set inhibit_defer_pop to that value.  */\n-\n-  emit_call_1 (fun, get_identifier (XSTR (orgfun, 0)), args_size.constant, 0,\n-\t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n-\t       outmode != VOIDmode ? hard_libcall_value (outmode) : NULL_RTX,\n-\t       old_inhibit_defer_pop + 1, use_insns, no_queue);\n-\n-  /* Now restore inhibit_defer_pop to its actual original value.  */\n-  OK_DEFER_POP;\n-\n-  /* Copy the value to the right place.  */\n-  if (outmode != VOIDmode)\n-    {\n-      if (mem_value)\n-\t{\n-\t  if (value == 0)\n-\t    value = hard_libcall_value (outmode);\n-\t  if (value != mem_value)\n-\t    emit_move_insn (value, mem_value);\n-\t}\n-      else if (value != 0)\n-\temit_move_insn (value, hard_libcall_value (outmode));\n-    }\n-}\n-\f\n /* Expand an assignment that stores the value of FROM into TO.\n    If WANT_VALUE is nonzero, return an rtx for the value of TO.\n    (This may contain a QUEUED rtx.)"}]}