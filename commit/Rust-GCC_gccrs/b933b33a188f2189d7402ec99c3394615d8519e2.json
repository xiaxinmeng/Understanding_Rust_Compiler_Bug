{"sha": "b933b33a188f2189d7402ec99c3394615d8519e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjkzM2IzM2ExODhmMjE4OWQ3NDAyZWM5OWMzMzk0NjE1ZDg1MTllMg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2010-06-10T16:43:46Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2010-06-10T16:43:46Z"}, "message": "re PR debug/41371 (var-tracking is slow and memory hungry)\n\nPR debug/41371\n* var-tracking.c (find_loc_in_1pdv): Remove recursion, only\ntail-recurse into canonical node.  Fast-forward over\nnon-canonical VALUEs.\n\nFrom-SVN: r160559", "tree": {"sha": "df4f7344999e19b077da0b07217c6166a9a2402f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df4f7344999e19b077da0b07217c6166a9a2402f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b933b33a188f2189d7402ec99c3394615d8519e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b933b33a188f2189d7402ec99c3394615d8519e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b933b33a188f2189d7402ec99c3394615d8519e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b933b33a188f2189d7402ec99c3394615d8519e2/comments", "author": null, "committer": null, "parents": [{"sha": "0c179631b21d149074ed2606201fe0cede6bf412", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c179631b21d149074ed2606201fe0cede6bf412", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c179631b21d149074ed2606201fe0cede6bf412"}], "stats": {"total": 119, "additions": 44, "deletions": 75}, "files": [{"sha": "685a346211ad0540c8e94d2eb7b4b85ae6f52314", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b933b33a188f2189d7402ec99c3394615d8519e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b933b33a188f2189d7402ec99c3394615d8519e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b933b33a188f2189d7402ec99c3394615d8519e2", "patch": "@@ -1,3 +1,10 @@\n+2010-06-10  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/41371\n+\t* var-tracking.c (find_loc_in_1pdv): Remove recursion, only\n+\ttail-recurse into canonical node.  Fast-forward over\n+\tnon-canonical VALUEs.\n+\n 2010-06-10  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR boostrap/44470"}, {"sha": "57405583e58404616af3476e78a7d8b6fe1bd65d", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 37, "deletions": 75, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b933b33a188f2189d7402ec99c3394615d8519e2/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b933b33a188f2189d7402ec99c3394615d8519e2/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=b933b33a188f2189d7402ec99c3394615d8519e2", "patch": "@@ -2479,125 +2479,81 @@ dv_changed_p (decl_or_value dv)\n \n /* Return a location list node whose loc is rtx_equal to LOC, in the\n    location list of a one-part variable or value VAR, or in that of\n-   any values recursively mentioned in the location lists.  */\n+   any values recursively mentioned in the location lists.  VARS must\n+   be in star-canonical form.  */\n \n static location_chain\n find_loc_in_1pdv (rtx loc, variable var, htab_t vars)\n {\n   location_chain node;\n   enum rtx_code loc_code;\n-  location_chain ret = NULL;\n-  int unmark_self = 0;\n-#ifdef ENABLE_CHECKING\n-  static int mark_count;\n-#endif\n \n   if (!var)\n-    return ret;\n+    return NULL;\n \n #ifdef ENABLE_CHECKING\n   gcc_assert (dv_onepart_p (var->dv));\n #endif\n \n   if (!var->n_var_parts)\n-    return ret;\n+    return NULL;\n \n #ifdef ENABLE_CHECKING\n   gcc_assert (var->var_part[0].offset == 0);\n+  gcc_assert (loc != dv_as_opaque (var->dv));\n #endif\n \n   loc_code = GET_CODE (loc);\n   for (node = var->var_part[0].loc_chain; node; node = node->next)\n     {\n+      decl_or_value dv;\n+      variable rvar;\n+\n       if (GET_CODE (node->loc) != loc_code)\n \t{\n \t  if (GET_CODE (node->loc) != VALUE)\n \t    continue;\n \t}\n       else if (loc == node->loc)\n-\t{\n-\t  ret = node;\n-\t  break;\n-\t}\n+\treturn node;\n       else if (loc_code != VALUE)\n \t{\n \t  if (rtx_equal_p (loc, node->loc))\n-\t    {\n-\t      ret = node;\n-\t      break;\n-\t    }\n+\t    return node;\n \t  continue;\n \t}\n-      if (!VALUE_RECURSED_INTO (node->loc))\n-\t{\n-\t  decl_or_value dv = dv_from_value (node->loc);\n-\t  variable rvar = (variable)\n-\t    htab_find_with_hash (vars, dv, dv_htab_hash (dv));\n \n-\t  if (rvar)\n+      /* Since we're in star-canonical form, we don't need to visit\n+\t non-canonical nodes: one-part variables and non-canonical\n+\t values would only point back to the canonical node.  */\n+      if (dv_is_value_p (var->dv)\n+\t  && !canon_value_cmp (node->loc, dv_as_value (var->dv)))\n+\t{\n+\t  /* Skip all subsequent VALUEs.  */\n+\t  while (node->next && GET_CODE (node->next->loc) == VALUE)\n \t    {\n-\t      location_chain where;\n-\n-\t      if (!unmark_self)\n-\t\t{\n-\t\t  if (dv_is_value_p (var->dv)\n-\t\t      && !VALUE_RECURSED_INTO (dv_as_value (var->dv)))\n-\t\t    {\n-\t\t      unmark_self = 1;\n+\t      node = node->next;\n #ifdef ENABLE_CHECKING\n-\t\t      mark_count++;\n-#endif\n-\t\t      VALUE_RECURSED_INTO (dv_as_value (var->dv)) = true;\n-\t\t    }\n-\t\t  else\n-\t\t    unmark_self = -1;\n-\t\t}\n-\n-#ifdef ENABLE_CHECKING\n-\t      mark_count++;\n-\t      /* The recursion count is bounded because we're\n-\t\t searching in a star-canonicalized set, i.e., each\n-\t\t equivalence set of values is arranged so that the\n-\t\t canonical value has all locations and equivalent\n-\t\t values, whereas equivalent values only point back to\n-\t\t the canonical.  So, if we start at the canonical\n-\t\t value, we'll recurse at most into each sibling, so\n-\t\t the recurse limit will be 2.  If we start at a\n-\t\t non-canonical value, we'll recurse into the\n-\t\t canonical, and from there to other siblings, so\n-\t\t recurse limit will be 3.  If we start at a one-part\n-\t\t variable, we add one level of recursion, but we don't\n-\t\t count it.  */\n-\t      gcc_assert (mark_count <= 3);\n-#endif\n-\t      VALUE_RECURSED_INTO (node->loc) = true;\n-\t      if ((where = find_loc_in_1pdv (loc, rvar, vars)))\n-\t\t{\n-#ifdef ENABLE_CHECKING\n-\t\t  mark_count--;\n-#endif\n-\t\t  VALUE_RECURSED_INTO (node->loc) = false;\n-\t\t  ret = where;\n-\t\t  break;\n-\t\t}\n-\t      VALUE_RECURSED_INTO (node->loc) = false;\n-#ifdef ENABLE_CHECKING\n-\t      mark_count--;\n+\t      gcc_assert (!canon_value_cmp (node->loc,\n+\t\t\t\t\t    dv_as_value (var->dv)));\n #endif\n+\t      if (loc == node->loc)\n+\t\treturn node;\n \t    }\n+\t  continue;\n \t}\n-    }\n \n-  if (unmark_self > 0)\n-    {\n-      VALUE_RECURSED_INTO (dv_as_value (var->dv)) = false;\n #ifdef ENABLE_CHECKING\n-      mark_count--;\n-      gcc_assert (mark_count == 0);\n+      gcc_assert (node == var->var_part[0].loc_chain);\n+      gcc_assert (!node->next);\n #endif\n+\n+      dv = dv_from_value (node->loc);\n+      rvar = (variable) htab_find_with_hash (vars, dv, dv_htab_hash (dv));\n+      return find_loc_in_1pdv (loc, rvar, vars);\n     }\n \n-  return ret;\n+  return NULL;\n }\n \n /* Hash table iteration argument passed to variable_merge.  */\n@@ -4031,6 +3987,12 @@ variable_post_merge_perm_vals (void **pslot, void *info)\n   var = shared_hash_find (set->vars, dv);\n   if (var)\n     {\n+      /* Although variable_post_merge_new_vals may have made decls\n+\t non-star-canonical, values that pre-existed in canonical form\n+\t remain canonical, and newly-created values reference a single\n+\t REG, so they are canonical as well.  Since VAR has the\n+\t location list for a VALUE, using find_loc_in_1pdv for it is\n+\t fine, since VALUEs don't map back to DECLs.  */\n       if (find_loc_in_1pdv (pnode->loc, var, shared_hash_htab (set->vars)))\n \treturn 1;\n       val_reset (set, dv);"}]}