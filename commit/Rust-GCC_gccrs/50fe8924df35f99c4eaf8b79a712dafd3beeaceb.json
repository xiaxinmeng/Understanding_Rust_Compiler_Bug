{"sha": "50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBmZTg5MjRkZjM1Zjk5YzRlYWY4Yjc5YTcxMmRhZmQzYmVlYWNlYg==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-02-03T20:06:01Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-02-03T20:06:01Z"}, "message": "divtab.c: Fix formatting and comments throughout the file.\n\n\t* config/sh/divtab.c: Fix formatting and comments throughout the file.\n\t* config/sh/sh4-300.md: Likewise.\n\t* config/sh/sh4a.md: Likewise.\n\t* config/sh/constraints.md: Likewise.\n\t* config/sh/sh.md: Likewise.\n\t* config/sh/netbsd-elf.h: Likewise.\n\t* config/sh/predicates.md: Likewise.\n\t* config/sh/sh-protos.h: Likewise.\n\t* config/sh/ushmedia.h: Likewise.\n\t* config/sh/linux.h: Likewise.\n\t* config/sh/sh.c: Likewise.\n\t* config/sh/superh.h: Likewise.\n\t* config/sh/elf.h: Likewise.\n\t* config/sh/sh4.md: Likewise.\n\t* config/sh/sh.h: Likewise.\n\nFrom-SVN: r195703", "tree": {"sha": "457a1626baf08bc82ee290b2bf6b9fe3edbf5b31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/457a1626baf08bc82ee290b2bf6b9fe3edbf5b31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/comments", "author": null, "committer": null, "parents": [{"sha": "1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a04ac2bc8e3e3dc3fa09364c60d5e165a0c858b"}], "stats": {"total": 1540, "additions": 690, "deletions": 850}, "files": [{"sha": "31a7ec676dc3eeecb63d095abde42ba106ea87d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "patch": "@@ -1,3 +1,21 @@\n+2013-02-03  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* config/sh/divtab.c: Fix formatting and comments throughout the file.\n+\t* config/sh/sh4-300.md: Likewise.\n+\t* config/sh/sh4a.md: Likewise.\n+\t* config/sh/constraints.md: Likewise.\n+\t* config/sh/sh.md: Likewise.\n+\t* config/sh/netbsd-elf.h: Likewise.\n+\t* config/sh/predicates.md: Likewise.\n+\t* config/sh/sh-protos.h: Likewise.\n+\t* config/sh/ushmedia.h: Likewise.\n+\t* config/sh/linux.h: Likewise.\n+\t* config/sh/sh.c: Likewise.\n+\t* config/sh/superh.h: Likewise.\n+\t* config/sh/elf.h: Likewise.\n+\t* config/sh/sh4.md: Likewise.\n+\t* config/sh/sh.h: Likewise.\n+\n 2013-02-03  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* config/pa/constraints.md: Adjust unused letters.  Change \"T\""}, {"sha": "59bf6b5addf72f687743fdceefdb8a898679c905", "filename": "gcc/config/sh/constraints.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fconstraints.md?ref=50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "patch": "@@ -26,7 +26,7 @@\n ;;  Csu: unsigned 16-bit constant, literal or symbolic\n ;;  Csy: label or symbol\n ;;  Cpg: non-explicit constants that can be directly loaded into a general\n-;;       purpose register in PIC code.  like 's' except we don't allow\n+;;       purpose register in PIC code.  Like 's' except we don't allow\n ;;       PIC_ADDR_P\n ;; IJKLMNOP: CONT_INT constants\n ;;  Ixx: signed xx bit\n@@ -315,7 +315,7 @@\n        (match_test \"satisfies_constraint_K12 (XEXP (XEXP (op, 0), 1))\")))\n \n (define_memory_constraint \"Sra\"\n-  \"A memory reference that uses a simple register addressing.\"\n+  \"A memory reference that uses simple register addressing.\"\n   (and (match_test \"MEM_P (op)\")\n        (match_test \"REG_P (XEXP (op, 0))\")))\n "}, {"sha": "f5f0bb436c8a8dcbfef86055e45911bd685f0dc2", "filename": "gcc/config/sh/divtab.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fdivtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fdivtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fdivtab.c?ref=50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "patch": "@@ -53,7 +53,8 @@ double max_defect3 = 0.;\n double max_defect3_x;\n int max_defect3_val;\n \n-static double note_defect3 (int val, double d2, double y2d, double x)\n+static double\n+note_defect3 (int val, double d2, double y2d, double x)\n {\n   int cutoff_val = val >> CUTOFF_BITS;\n   double cutoff;\n@@ -172,8 +173,10 @@ main ()\n     printf (\"   Min defect: %e at %e\\n\", min_defect, min_defect_x);\n     printf (\"   Max 2nd step defect: %e at %e\\n\", max_defect2, max_defect2_x);\n     printf (\"   Min 2nd step defect: %e at %e\\n\", min_defect2, min_defect2_x);\n-    printf (\"   Max div defect: %e at %d:%e\\n\", max_defect3, max_defect3_val, max_defect3_x);\n-    printf (\"   Min div defect: %e at %d:%e\\n\", min_defect3, min_defect3_val, min_defect3_x);\n+    printf (\"   Max div defect: %e at %d:%e\\n\", max_defect3, max_defect3_val,\n+\t\t\t\t\t\tmax_defect3_x);\n+    printf (\"   Min div defect: %e at %d:%e\\n\", min_defect3, min_defect3_val,\n+\t\t\t\t\t\tmin_defect3_x);\n     printf (\"   Defect at 1: %e\\n\",\n \t    calc_defect (1., constants[0], factors[0]));\n     printf (\"   Defect at -2: %e */\\n\","}, {"sha": "253cc8805b68a95c1d81d0ade81dcb19ff501c2e", "filename": "gcc/config/sh/elf.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Felf.h?ref=50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "patch": "@@ -22,25 +22,24 @@ along with GCC; see the file COPYING3.  If not see\n #undef TARGET_ELF\n #define TARGET_ELF 1\n \n-/* Generate DWARF2 debugging information and make it the default */\n+/* Generate DWARF2 debugging information and make it the default.  */\n #define DWARF2_DEBUGGING_INFO 1\n \n #undef PREFERRED_DEBUGGING_TYPE\n #define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n \n-/* use a more compact format for line information */\n+/* Use a more compact format for line information.  */\n #define DWARF2_ASM_LINE_DEBUG_INFO 1\n \n #undef WCHAR_TYPE\n-/* #define WCHAR_TYPE (TARGET_SH5 ? \"int\" : \"long int\") */\n+/* #define WCHAR_TYPE (TARGET_SH5 ? \"int\" : \"long int\")  */\n #define WCHAR_TYPE SH_ELF_WCHAR_TYPE\n    \n #undef WCHAR_TYPE_SIZE\n #define WCHAR_TYPE_SIZE 32\n \n \n /* The prefix to add to user-visible assembler symbols.  */\n-\n #undef LOCAL_LABEL_PREFIX\n #define LOCAL_LABEL_PREFIX \".\"\n "}, {"sha": "8bc7de83ab089bf7aecd968ce1dfc7b92e03450b", "filename": "gcc/config/sh/linux.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Flinux.h?ref=50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "patch": "@@ -57,7 +57,6 @@ along with GCC; see the file COPYING3.  If not see\n    %{static:-static}\"\n \n /* Output assembler code to STREAM to call the profiler.  */\n-\n #undef FUNCTION_PROFILER\n #define FUNCTION_PROFILER(STREAM,LABELNO)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\"}, {"sha": "a390f40feead9d169d4c3f0a383af59821f4abbe", "filename": "gcc/config/sh/netbsd-elf.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fnetbsd-elf.h?ref=50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "patch": "@@ -41,7 +41,6 @@ along with GCC; see the file COPYING3.  If not see\n    NetBSD ELF LINK_SPEC.  */\n \n /* LINK_EMUL_PREFIX from sh/elf.h */\n-\n #undef SUBTARGET_LINK_EMUL_SUFFIX\n #define SUBTARGET_LINK_EMUL_SUFFIX \"_nbsd\"\n "}, {"sha": "dcbd75bb890983fa05d88b9185db1f6ff7b82609", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 70, "deletions": 108, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "patch": "@@ -18,7 +18,6 @@\n ;; <http://www.gnu.org/licenses/>.\n \n ;; TODO: Add a comment here.\n-\n (define_predicate \"trapping_target_operand\"\n   (match_code \"if_then_else\")\n {\n@@ -58,8 +57,7 @@\n \t  && INTVAL (XEXP (cond, 1)) == 3);\n })\n \n-;; TODO: Add a comment here.\n-\n+;; A logical operand that can be used in an shmedia and insn.\n (define_predicate \"and_operand\"\n   (match_code \"subreg,reg,const_int\")\n {\n@@ -77,7 +75,6 @@\n \n ;; Like arith_reg_dest, but this predicate is defined with\n ;; define_special_predicate, not define_predicate.\n-\n (define_special_predicate \"any_arith_reg_dest\"\n   (match_code \"subreg,reg\")\n {\n@@ -86,15 +83,13 @@\n \n ;; Like register_operand, but this predicate is defined with\n ;; define_special_predicate, not define_predicate.\n-\n (define_special_predicate \"any_register_operand\"\n   (match_code \"subreg,reg\")\n {\n   return register_operand (op, mode);\n })\n \n ;; Returns 1 if OP is a valid source operand for an arithmetic insn.\n-\n (define_predicate \"arith_operand\"\n   (match_code \"subreg,reg,const_int,truncate\")\n {\n@@ -132,7 +127,6 @@\n ;; Like above, but for DImode destinations: forbid paradoxical DImode\n ;; subregs, because this would lead to missing sign extensions when\n ;; truncating from DImode to SImode.\n-\n (define_predicate \"arith_reg_dest\"\n   (match_code \"subreg,reg\")\n {\n@@ -144,7 +138,6 @@\n })\n \n ;; Returns 1 if OP is a normal arithmetic register.\n-\n (define_predicate \"arith_reg_operand\"\n   (match_code \"subreg,reg,sign_extend\")\n {\n@@ -190,7 +183,6 @@\n })\n \n ;; Returns 1 if OP is a valid source operand for a compare insn.\n-\n (define_predicate \"arith_reg_or_0_operand\"\n   (match_code \"subreg,reg,const_int,const_vector\")\n {\n@@ -203,21 +195,18 @@\n   return 0;\n })\n \n-;; TODO: Add a comment here.\n-\n+;; Returns 1 if OP is a floating point operator with two operands.\n (define_predicate \"binary_float_operator\"\n   (and (match_code \"plus,minus,mult,div\")\n        (match_test \"GET_MODE (op) == mode\")))\n \n-;; TODO: Add a comment here.\n-\n+;; Returns 1 if OP is a logical operator with two operands.\n (define_predicate \"binary_logical_operator\"\n   (and (match_code \"and,ior,xor\")\n        (match_test \"GET_MODE (op) == mode\")))\n \n-;; Return 1 of OP is an address suitable for a cache manipulation operation.\n+;; Return 1 if OP is an address suitable for a cache manipulation operation.\n ;; MODE has the meaning as in address_operand.\n-\n (define_special_predicate \"cache_address_operand\"\n   (match_code \"plus,reg\")\n {\n@@ -234,8 +223,7 @@\n   return address_operand (op, mode);\n })\n \n-;; Return 1 if OP is a valid source operand for shmedia cmpgt / cmpgtu.\n-\n+;; Returns 1 if OP is a valid source operand for shmedia cmpgt / cmpgtu.\n (define_predicate \"cmp_operand\"\n   (match_code \"subreg,reg,const_int\")\n {\n@@ -248,8 +236,8 @@\n   return arith_reg_operand (op, mode);\n })\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is an operand that can be used as the first operand in\n+;; the cstoresi4 expander pattern.\n (define_predicate \"cmpsi_operand\"\n   (match_code \"subreg,reg,const_int\")\n {\n@@ -260,19 +248,18 @@\n   return arith_operand (op, mode);\n })\n \n-;; TODO: Add a comment here.\n-\n-(define_predicate \"commutative_float_operator\"\n-  (and (match_code \"plus,mult\")\n-       (match_test \"GET_MODE (op) == mode\")))\n-\n-;; TODO: Add a comment here.\n+;; Returns true if OP is a comutative float operator.\n+;; This predicate is currently unused.\n+;;(define_predicate \"commutative_float_operator\"\n+;;  (and (match_code \"plus,mult\")\n+;;       (match_test \"GET_MODE (op) == mode\")))\n \n+;; Returns true if OP is a equal or not equal operator.\n (define_predicate \"equality_comparison_operator\"\n   (match_code \"eq,ne\"))\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is an arithmetic operand that is zero extended during\n+;; an operation.\n (define_predicate \"extend_reg_operand\"\n   (match_code \"subreg,reg,truncate\")\n {\n@@ -281,8 +268,7 @@\n \t  : arith_reg_operand) (op, mode);\n })\n \n-;; TODO: Add a comment here.\n-\n+;; Like extend_reg_operand, but also allow a constant 0.\n (define_predicate \"extend_reg_or_0_operand\"\n   (match_code \"subreg,reg,truncate,const_int\")\n {\n@@ -292,15 +278,14 @@\n })\n \n ;; Like arith_reg_operand, but this predicate does not accept SIGN_EXTEND.\n-\n (define_predicate \"ext_dest_operand\"\n   (match_code \"subreg,reg\")\n {\n   return arith_reg_operand (op, mode);\n })\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP can be used as a destination register for shmedia floating\n+;; point to integer conversions.\n (define_predicate \"fp_arith_reg_dest\"\n   (match_code \"subreg,reg\")\n {\n@@ -310,8 +295,8 @@\n   return fp_arith_reg_operand (op, mode);\n })\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is a floating point register that can be used in floating\n+;; point arithmetic operations.\n (define_predicate \"fp_arith_reg_operand\"\n   (match_code \"subreg,reg\")\n {\n@@ -332,8 +317,7 @@\n   return 0;\n })\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is the FPSCR.\n (define_predicate \"fpscr_operand\"\n   (match_code \"reg\")\n {\n@@ -382,8 +366,7 @@\n   (and (match_code \"const_double\")\n        (match_test \"op == sh_fsca_int2sf ()\")))\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is an operand that is zero extended during an operation.\n (define_predicate \"general_extend_operand\"\n   (match_code \"subreg,reg,mem,truncate\")\n {\n@@ -423,9 +406,9 @@\n ;; Returns 1 if OP can be source of a simple move operation. Same as\n ;; general_operand, but a LABEL_REF is valid, PRE_DEC is invalid as\n ;; are subregs of system registers.\n-\n (define_predicate \"general_movsrc_operand\"\n-  (match_code \"subreg,reg,const_int,const_double,mem,symbol_ref,label_ref,const,const_vector\")\n+  (match_code \"subreg,reg,const_int,const_double,mem,symbol_ref,label_ref,\n+\t       const,const_vector\")\n {\n   if (t_reg_operand (op, mode))\n     return 0;\n@@ -482,7 +465,6 @@\n })\n \n ;; Returns 1 if OP is a MEM that does not use displacement addressing.\n-\n (define_predicate \"movsrc_no_disp_mem_operand\"\n   (match_code \"mem\")\n {\n@@ -491,7 +473,6 @@\n \n ;; Returns 1 if OP can be a destination of a move. Same as\n ;; general_operand, but no preinc allowed.\n-\n (define_predicate \"general_movdst_operand\"\n   (match_code \"subreg,reg,mem\")\n {\n@@ -534,7 +515,6 @@\n })\n \n ;; Returns 1 if OP is a POST_INC on stack pointer register.\n-\n (define_predicate \"sh_no_delay_pop_operand\"\n   (match_code \"mem\")\n {\n@@ -551,7 +531,6 @@\n })\n \n ;; Returns 1 if OP is a MEM that can be source of a simple move operation.\n-\n (define_predicate \"unaligned_load_operand\"\n   (match_code \"mem\")\n {\n@@ -599,13 +578,12 @@\n \t && sh_legitimate_index_p (mode, XEXP (plus0_rtx, 1), TARGET_SH2A, true);\n })\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is some kind of greater comparision.\n (define_predicate \"greater_comparison_operator\"\n   (match_code \"gt,ge,gtu,geu\"))\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is an operand suitable for shmedia reload_inqi and\n+;; reload_inhi insns.\n (define_predicate \"inqhi_operand\"\n   (match_code \"truncate\")\n {\n@@ -617,28 +595,26 @@\n   return REG_P (op) && FP_REGISTER_P (REGNO (op));\n })\n \n-;; TODO: Add a comment here.\n-\n-(define_special_predicate \"int_gpr_dest\"\n-  (match_code \"subreg,reg\")\n-{\n-  enum machine_mode op_mode = GET_MODE (op);\n-\n-  if (GET_MODE_CLASS (op_mode) != MODE_INT\n-      || GET_MODE_SIZE (op_mode) >= UNITS_PER_WORD)\n-    return 0;\n-  if (! reload_completed)\n-    return 0;\n-  return true_regnum (op) <= LAST_GENERAL_REG;\n-})\n-\n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is a general purpose integer register.\n+;; This predicate is currently unused.\n+;;(define_special_predicate \"int_gpr_dest\"\n+;;  (match_code \"subreg,reg\")\n+;;{\n+;;  enum machine_mode op_mode = GET_MODE (op);\n+;;\n+;;  if (GET_MODE_CLASS (op_mode) != MODE_INT\n+;;      || GET_MODE_SIZE (op_mode) >= UNITS_PER_WORD)\n+;;    return 0;\n+;;  if (! reload_completed)\n+;;    return 0;\n+;;  return true_regnum (op) <= LAST_GENERAL_REG;\n+;;})\n+\n+;; Returns true if OP is some kind of less comparison.\n (define_predicate \"less_comparison_operator\"\n   (match_code \"lt,le,ltu,leu\"))\n \n ;; Returns 1 if OP is a valid source operand for a logical operation.\n-\n (define_predicate \"logical_operand\"\n   (match_code \"subreg,reg,const_int\")\n {\n@@ -678,14 +654,12 @@\n   return 0;\n })\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is a logical operator.\n (define_predicate \"logical_operator\"\n   (match_code \"and,ior,xor\"))\n \n ;; Like arith_reg_operand, but for register source operands of narrow\n ;; logical SHMEDIA operations: forbid subregs of DImode / TImode regs.\n-\n (define_predicate \"logical_reg_operand\"\n   (match_code \"subreg,reg\")\n {\n@@ -697,8 +671,7 @@\n   return arith_reg_operand (op, mode);\n })\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is a valid bit offset value for the shmedia mextr insns.\n (define_predicate \"mextr_bit_offset\"\n   (match_code \"const_int\")\n {\n@@ -710,19 +683,19 @@\n   return i >= 1 * 8 && i <= 7 * 8 && (i & 7) == 0;\n })\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is a constant -1, 0 or an zero extended register that\n+;; can be used as an operator in the *subsi3_media insn.\n (define_predicate \"minuend_operand\"\n   (match_code \"subreg,reg,truncate,const_int\")\n {\n   return op == constm1_rtx || extend_reg_or_0_operand (op, mode);\n })\n \n-;; TODO: Add a comment here.\n-\n-(define_predicate \"noncommutative_float_operator\"\n-  (and (match_code \"minus,div\")\n-       (match_test \"GET_MODE (op) == mode\")))\n+;; Returns true if OP is a noncommutative floating point operator.\n+;; This predicate is currently unused.\n+;;(define_predicate \"noncommutative_float_operator\"\n+;;  (and (match_code \"minus,div\")\n+;;       (match_test \"GET_MODE (op) == mode\")))\n \n ;; UNORDERED is only supported on SHMEDIA.\n \n@@ -735,8 +708,7 @@\n   (ior (match_operand 0 \"equality_comparison_operator\")\n        (match_operand 0 \"greater_comparison_operator\")))\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is a constant vector.\n (define_predicate \"sh_const_vec\"\n   (match_code \"const_vector\")\n {\n@@ -755,7 +727,6 @@\n ;; Determine if OP is a constant vector matching MODE with only one\n ;; element that is not a sign extension.  Two byte-sized elements\n ;; count as one.\n-\n (define_predicate \"sh_1el_vec\"\n   (match_code \"const_vector\")\n {\n@@ -789,7 +760,6 @@\n \n ;; Like register_operand, but take into account that SHMEDIA can use\n ;; the constant zero like a general register.\n-\n (define_predicate \"sh_register_operand\"\n   (match_code \"reg,subreg,const_int,const_double\")\n {\n@@ -798,8 +768,8 @@\n   return register_operand (op, mode);\n })\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is a vector which is composed of one element that is\n+;; repeated.\n (define_predicate \"sh_rep_vec\"\n   (match_code \"const_vector,parallel\")\n {\n@@ -826,10 +796,10 @@\n   return 1;\n })\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is a valid shift count operand for shift operations.\n (define_predicate \"shift_count_operand\"\n-  (match_code \"const_int,const_double,const,symbol_ref,label_ref,subreg,reg,zero_extend,sign_extend\")\n+  (match_code \"const_int,const_double,const,symbol_ref,label_ref,subreg,reg,\n+\t       zero_extend,sign_extend\")\n {\n   /* Allow T_REG as shift count for dynamic shifts, although it is not\n      really possible.  It will then be copied to a general purpose reg.  */\n@@ -844,8 +814,8 @@\n \t  : shift_count_reg_operand (op, mode));\n })\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is a valid shift count operand in a register which can\n+;; be used by shmedia shift insns.\n (define_predicate \"shift_count_reg_operand\"\n   (match_code \"subreg,reg,zero_extend,sign_extend\")\n {\n@@ -890,19 +860,16 @@\n        (ior (match_test \"! satisfies_constraint_P27 (op)\")\n \t    (match_test \"satisfies_constraint_M (op)\"))))\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is some kind of a shift operator.\n (define_predicate \"shift_operator\"\n   (match_code \"ashift,ashiftrt,lshiftrt\"))\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is a symbol reference.\n (define_predicate \"symbol_ref_operand\"\n   (match_code \"symbol_ref\"))\n \n ;; Same as target_reg_operand, except that label_refs and symbol_refs\n ;; are accepted before reload.\n-\n (define_special_predicate \"target_operand\"\n   (match_code \"subreg,reg,label_ref,symbol_ref,const,unspec\")\n {\n@@ -916,8 +883,7 @@\n   return target_reg_operand (op, mode);\n })\n \n-;; Accept pseudos and branch target registers.\n-\n+;; A predicate that accepts pseudos and branch target registers.\n (define_special_predicate \"target_reg_operand\"\n   (match_code \"subreg,reg\")\n {\n@@ -942,8 +908,7 @@\n   return 0;\n })\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is a valid operand for the shmedia mperm.w insn.\n (define_special_predicate \"trunc_hi_operand\"\n   (match_code \"subreg,reg,truncate\")\n {\n@@ -955,8 +920,8 @@\n   return extend_reg_operand (op, mode);\n })\n \n-;; Return 1 of OP is an address suitable for an unaligned access instruction.\n-\n+;; Returns true if OP is an address suitable for an unaligned access\n+;; instruction.\n (define_special_predicate \"ua_address_operand\"\n   (match_code \"subreg,reg,plus\")\n {\n@@ -966,22 +931,19 @@\n   return address_operand (op, QImode);\n })\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is a valid offset for an unaligned memory address.\n (define_predicate \"ua_offset\"\n   (match_code \"const_int\")\n {\n   return satisfies_constraint_I06 (op);\n })\n \n-;; TODO: Add a comment here.\n-\n+;; Returns true if OP is a floating point operator with one operand.\n (define_predicate \"unary_float_operator\"\n   (and (match_code \"abs,neg,sqrt\")\n        (match_test \"GET_MODE (op) == mode\")))\n \n ;; Return 1 if OP is a valid source operand for xor.\n-\n (define_predicate \"xor_operand\"\n   (match_code \"subreg,reg,const_int\")\n {\n@@ -1080,7 +1042,7 @@\n   return sh_eval_treg_value (op) >= 0;\n })\n \n-;; Returns true of OP is arith_reg_operand or t_reg_operand.\n+;; Returns true if OP is arith_reg_operand or t_reg_operand.\n (define_predicate \"arith_reg_or_t_reg_operand\"\n   (ior (match_operand 0 \"arith_reg_operand\")\n        (match_operand 0 \"t_reg_operand\")))\n@@ -1124,7 +1086,7 @@\n })\n \n ;; A predicate that determines whether a given constant is a valid\n-;; displacement for a gbr load/store of the specified mode.\n+;; displacement for a GBR load/store of the specified mode.\n (define_predicate \"gbr_displacement\"\n   (match_code \"const_int\")\n {"}, {"sha": "4671c5499cc8a071e2bd31a87c92138fd03ebfa7", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "patch": "@@ -212,7 +212,8 @@ extern void sh_pr_nosave_low_regs (struct cpp_reader *);\n extern rtx function_symbol (rtx, const char *, enum sh_function_kind);\n extern rtx sh_get_pr_initial_val (void);\n \n-extern void sh_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, signed int, enum machine_mode);\n+extern void sh_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree,\n+\t\t\t\t     signed int, enum machine_mode);\n extern rtx sh_dwarf_register_span (rtx);\n \n extern rtx replace_n_hard_rtx (rtx, rtx *, int , int);"}, {"sha": "be49e46bc4d0b250fc5766fb322aafdaf60b3147", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 206, "deletions": 288, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "patch": "@@ -112,7 +112,7 @@ static int r0_life_regions;\n /* If true, skip cycles for Q -> R movement.  */\n static int skip_cycles = 0;\n \n-/* Cached value of can_issue_more. This is cached in sh_variable_issue hook\n+/* Cached value of can_issue_more.  This is cached in sh_variable_issue hook\n    and returned from sh_reorder2.  */\n static short cached_can_issue_more;\n \n@@ -121,7 +121,6 @@ static unsigned int unspec_bbr_uid = 1;\n \n /* Provides the class number of the smallest class containing\n    reg number.  */\n-\n enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER] =\n {\n   R0_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n@@ -198,7 +197,8 @@ static int calc_live_regs (HARD_REG_SET *);\n static HOST_WIDE_INT rounded_frame_size (int);\n static bool sh_frame_pointer_required (void);\n static rtx mark_constant_pool_use (rtx);\n-static tree sh_handle_interrupt_handler_attribute (tree *, tree, tree, int, bool *);\n+static tree sh_handle_interrupt_handler_attribute (tree *, tree, tree,\n+\t\t\t\t\t\t   int, bool *);\n static tree sh_handle_resbank_handler_attribute (tree *, tree,\n \t\t\t\t\t\t tree, int, bool *);\n static tree sh2a_handle_function_vector_handler_attribute (tree *, tree,\n@@ -242,7 +242,8 @@ static bool sh_ms_bitfield_layout_p (const_tree);\n static void sh_init_builtins (void);\n static tree sh_builtin_decl (unsigned, bool);\n static rtx sh_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n-static void sh_output_mi_thunk (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree);\n+static void sh_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n+\t\t\t\tHOST_WIDE_INT, tree);\n static void sh_file_start (void);\n static bool flow_dependent_p (rtx, rtx);\n static void flow_dependent_p_1 (rtx, const_rtx, void *);\n@@ -277,7 +278,8 @@ static bool sh_function_value_regno_p (const unsigned int);\n static rtx sh_libcall_value (enum machine_mode, const_rtx);\n static bool sh_return_in_memory (const_tree, const_tree);\n static rtx sh_builtin_saveregs (void);\n-static void sh_setup_incoming_varargs (cumulative_args_t, enum machine_mode, tree, int *, int);\n+static void sh_setup_incoming_varargs (cumulative_args_t, enum machine_mode,\n+\t\t\t\t       tree, int *, int);\n static bool sh_strict_argument_naming (cumulative_args_t);\n static bool sh_pretend_outgoing_varargs_named (cumulative_args_t);\n static tree sh_build_builtin_va_list (void);\n@@ -376,7 +378,8 @@ static const struct attribute_spec sh_attribute_table[] =\n #define TARGET_ASM_OUTPUT_MI_THUNK sh_output_mi_thunk\n \n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n-#define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_const_tree_hwi_hwi_const_tree_true\n+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK \\\n+  hook_bool_const_tree_hwi_hwi_const_tree_true\n \n #undef TARGET_ASM_FILE_START\n #define TARGET_ASM_FILE_START sh_file_start\n@@ -463,7 +466,7 @@ static const struct attribute_spec sh_attribute_table[] =\n #define TARGET_BRANCH_TARGET_REGISTER_CLASS sh_target_reg_class\n #undef TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED\n #define TARGET_BRANCH_TARGET_REGISTER_CALLEE_SAVED \\\n- sh_optimize_target_register_callee_saved\n+  sh_optimize_target_register_callee_saved\n \n #undef TARGET_MS_BITFIELD_LAYOUT_P\n #define TARGET_MS_BITFIELD_LAYOUT_P sh_ms_bitfield_layout_p\n@@ -591,7 +594,7 @@ static const struct attribute_spec sh_attribute_table[] =\n #define TARGET_CANONICALIZE_COMPARISON\tsh_canonicalize_comparison\n \n /* Machine-specific symbol_ref flags.  */\n-#define SYMBOL_FLAG_FUNCVEC_FUNCTION    (SYMBOL_FLAG_MACH_DEP << 0)\n+#define SYMBOL_FLAG_FUNCVEC_FUNCTION\t(SYMBOL_FLAG_MACH_DEP << 0)\n \n /* The tas.b instruction sets the 7th bit in the byte, i.e. 0x80.  This value\n    is used by optabs.c atomic op expansion code as well as in sync.md.  */\n@@ -681,7 +684,7 @@ got_mode_name:;\n \t}\n       else\n \terr_ret (\"unknown parameter \\\"%s\\\" in atomic model option\",\n-\t         tokens[i].c_str ());\n+\t\t tokens[i].c_str ());\n     }\n \n   /* Check that the selection makes sense.  */\n@@ -835,7 +838,7 @@ sh_option_override (void)\n \t/* ??? Should we use the integer SHmedia function instead?  */\n \telse if (TARGET_SHCOMPACT && TARGET_FPU_ANY)\n \t  sh_div_strategy = SH_DIV_CALL_FP;\n-        /* SH1 .. SH3 cores often go into small-footprint systems, so\n+\t/* SH1 .. SH3 cores often go into small-footprint systems, so\n \t   default to the smallest implementation available.  */\n \telse if (TARGET_SH2)\t/* ??? EXPERIMENTAL */\n \t  sh_div_strategy = SH_DIV_CALL_TABLE;\n@@ -881,7 +884,7 @@ sh_option_override (void)\n       || (TARGET_SHMEDIA && !TARGET_PT_FIXED))\n     flag_no_function_cse = 1;\n \n-  if (targetm.small_register_classes_for_mode_p (VOIDmode))\t\t\\\n+  if (targetm.small_register_classes_for_mode_p (VOIDmode))\n     {\n       /* Never run scheduling before reload, since that can\n \t break global alloc, and generates slower code anyway due\n@@ -891,16 +894,17 @@ sh_option_override (void)\n \t the target hooks if pressure is high.  We can not do this for\n \t PIC, SH3 and lower as they give spill failures for R0.  */\n       if (!TARGET_HARD_SH4 || flag_pic)\n-        flag_schedule_insns = 0;\n+\tflag_schedule_insns = 0;\n       /* ??? Current exception handling places basic block boundaries\n \t after call_insns.  It causes the high pressure on R0 and gives\n \t spill failures for R0 in reload.  See PR 22553 and the thread\n \t on gcc-patches\n-         <http://gcc.gnu.org/ml/gcc-patches/2005-10/msg00816.html>.  */\n+\t <http://gcc.gnu.org/ml/gcc-patches/2005-10/msg00816.html>.  */\n       else if (flag_exceptions)\n \t{\n \t  if (flag_schedule_insns && global_options_set.x_flag_schedule_insns)\n-\t    warning (0, \"ignoring -fschedule-insns because of exception handling bug\");\n+\t    warning (0, \"ignoring -fschedule-insns because of exception \"\n+\t\t\t\"handling bug\");\n \t  flag_schedule_insns = 0;\n \t}\n       else if (flag_schedule_insns\n@@ -985,10 +989,9 @@ sh_option_override (void)\n      compilation unit.  */\n   if (TARGET_RELAX)\n     {\n-      int min_align\n-\t= align_loops > align_jumps ? align_loops : align_jumps;\n+      int min_align = align_loops > align_jumps ? align_loops : align_jumps;\n \n-      /* Also take possible .long constants / mova tables int account.\t*/\n+      /* Also take possible .long constants / mova tables into account.\t*/\n       if (min_align < 4)\n \tmin_align = 4;\n       if (align_functions < min_align)\n@@ -1031,7 +1034,6 @@ sh_option_override (void)\n }\n \f\n /* Print the operand address in x to the stream.  */\n-\n static void\n sh_print_operand_address (FILE *stream, rtx x)\n {\n@@ -1110,7 +1112,6 @@ sh_print_operand_address (FILE *stream, rtx x)\n    't'  print a memory address which is a register.\n    'u'  prints the lowest 16 bits of CONST_INT, as an unsigned value.\n    'o'  output an operator.  */\n-\n static void\n sh_print_operand (FILE *stream, rtx x, int code)\n {\n@@ -1134,7 +1135,7 @@ sh_print_operand (FILE *stream, rtx x, int code)\n       trapa_attr = lookup_attribute (\"trap_exit\",\n \t\t\t\t      DECL_ATTRIBUTES (current_function_decl));\n       if (trapa_attr)\n-\tfprintf (stream, \"trapa #%ld\",\n+\tfprintf (stream, \"trapa\t#%ld\",\n \t\t (long) TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (trapa_attr))));\n       else if (sh_cfun_interrupt_handler_p ())\n \t{\n@@ -1469,11 +1470,10 @@ static bool\n sh_print_operand_punct_valid_p (unsigned char code)\n {\n   return (code == '.' || code == '#' || code == '@' || code == ','\n-          || code == '$' || code == '\\'' || code == '>');\n+\t  || code == '$' || code == '\\'' || code == '>');\n }\n \n /* Implement TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA.  */\n-\n static bool\n sh_asm_output_addr_const_extra (FILE *file, rtx x)\n {\n@@ -1535,9 +1535,9 @@ sh_asm_output_addr_const_extra (FILE *file, rtx x)\n \t    shift = XVECEXP (x, 0, 1);\n \t    fputc ('(', file);\n \t    if (shift != const0_rtx)\n-\t        fputc ('(', file);\n+\t\tfputc ('(', file);\n \t    if (GET_CODE (val) == CONST\n-\t        || GET_RTX_CLASS (GET_CODE (val)) != RTX_OBJ)\n+\t\t|| GET_RTX_CLASS (GET_CODE (val)) != RTX_OBJ)\n \t      {\n \t\tfputc ('(', file);\n \t\toutput_addr_const (file, val);\n@@ -1581,7 +1581,6 @@ sh_asm_output_addr_const_extra (FILE *file, rtx x)\n     return false;\n }\n \f\n-\n /* Encode symbol attributes of a SYMBOL_REF into its\n    SYMBOL_REF_FLAGS.  */\n static void\n@@ -1609,7 +1608,6 @@ force_into (rtx value, rtx target)\n    OPERANDS[1] is the source.\n    OPERANDS[2] is the size.\n    OPERANDS[3] is the alignment safe to use.  */\n-\n bool\n expand_block_move (rtx *operands)\n {\n@@ -1748,7 +1746,6 @@ expand_block_move (rtx *operands)\n \n /* Prepare operands for a move define_expand; specifically, one of the\n    operands must be in a register.  */\n-\n void\n prepare_move_operands (rtx operands[], enum machine_mode mode)\n {\n@@ -1947,9 +1944,9 @@ sh_canonicalize_comparison (enum rtx_code& cmp, rtx& op0, rtx& op1,\n   if (CONST_INT_P (op1))\n     {\n       /* Try to adjust the constant operand in such a way that available\n-         comparison insns can be utilized better and the constant can be\n-         loaded with a 'mov #imm,Rm' insn.  This avoids a load from the\n-         constant pool.  */\n+\t comparison insns can be utilized better and the constant can be\n+\t loaded with a 'mov #imm,Rm' insn.  This avoids a load from the\n+\t constant pool.  */\n       const HOST_WIDE_INT val = INTVAL (op1);\n \n       /* x > -1\t\t  --> x >= 0\n@@ -2027,6 +2024,7 @@ sh_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n \t\t\t      VOIDmode, op0_preserve_value);\n   *code = (int)tmp_code;\n }\n+\n enum rtx_code\n prepare_cbranch_operands (rtx *operands, enum machine_mode mode,\n \t\t\t  enum rtx_code comparison)\n@@ -2089,8 +2087,8 @@ expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int probability)\n     default: ;\n     }\n   emit_insn (gen_rtx_SET (VOIDmode, get_t_reg_rtx (),\n-                          gen_rtx_fmt_ee (comparison, SImode,\n-                                          operands[1], operands[2])));\n+\t\t\t  gen_rtx_fmt_ee (comparison, SImode,\n+\t\t\t\t\t  operands[1], operands[2])));\n   rtx jump = emit_jump_insn (branch_expander (operands[3]));\n   if (probability >= 0)\n     add_reg_note (jump, REG_BR_PROB, GEN_INT (probability));\n@@ -2113,7 +2111,6 @@ expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int probability)\n      the same.  Thus, we can't really tell anything here;\n      assuming random distribution is at least simple.\n  */\n-\n bool\n expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n {\n@@ -2346,7 +2343,7 @@ sh_emit_set_t_insn (rtx insn, enum machine_mode mode)\n   if ((TARGET_SH4 || TARGET_SH2A) && GET_MODE_CLASS (mode) == MODE_FLOAT)\n     {\n       insn = gen_rtx_PARALLEL (VOIDmode,\n-\t               gen_rtvec (2, insn,\n+\t\t       gen_rtvec (2, insn,\n \t\t\t          gen_rtx_USE (VOIDmode, get_fpscr_rtx ())));\n       (mode == SFmode ? emit_sf_insn : emit_df_insn) (insn);\n     }\n@@ -2463,7 +2460,6 @@ sh_emit_cheap_store_flag (enum machine_mode mode, enum rtx_code code,\n }\n \n /* Called from the md file, set up the operands of a compare instruction.  */\n-\n void\n sh_emit_compare_and_branch (rtx *operands, enum machine_mode mode)\n {\n@@ -2482,10 +2478,10 @@ sh_emit_compare_and_branch (rtx *operands, enum machine_mode mode)\n   else\n     {\n       if (code != EQ || mode == DImode)\n-        {\n-          /* Force args into regs, since we can't use constants here.  */\n-          op0 = force_reg (mode, op0);\n-          if (op1 != const0_rtx || code == GTU  || code == GEU)\n+\t{\n+\t  /* Force args into regs, since we can't use constants here.  */\n+\t  op0 = force_reg (mode, op0);\n+\t  if (op1 != const0_rtx || code == GTU  || code == GEU)\n \t    op1 = force_reg (mode, op1);\n         }\n     }\n@@ -2504,7 +2500,7 @@ sh_emit_compare_and_branch (rtx *operands, enum machine_mode mode)\n       if (code == GE)\n \t{\n \t  gcc_assert (TARGET_IEEE && TARGET_SH2E);\n-          need_ccmpeq = true;\n+\t  need_ccmpeq = true;\n \t  code = GT;\n \t}\n \n@@ -2573,20 +2569,20 @@ sh_emit_compare_and_set (rtx *operands, enum machine_mode mode)\n \t  tem = op0, op0 = op1, op1 = tem;\n \t}\n       if (code == GE)\n-        {\n-          if (TARGET_IEEE)\n-            {\n-              lab = gen_label_rtx ();\n-              sh_emit_scc_to_t (EQ, op0, op1);\n-              emit_jump_insn (gen_branch_true (lab));\n-              code = GT;\n-           }\n-          else\n-            {\n-              code = LT;\n-              invert = true;\n+\t{\n+\t  if (TARGET_IEEE)\n+\t    {\n+\t      lab = gen_label_rtx ();\n+\t      sh_emit_scc_to_t (EQ, op0, op1);\n+\t      emit_jump_insn (gen_branch_true (lab));\n+\t      code = GT;\n+\t   }\n+\t  else\n+\t    {\n+\t      code = LT;\n+\t      invert = true;\n \t    }\n-        }\n+\t}\n     }\n \n   if (code == NE)\n@@ -2610,7 +2606,6 @@ sh_emit_compare_and_set (rtx *operands, enum machine_mode mode)\n \n    Since the SH cannot move a DI or DF in one instruction, we have\n    to take care when we see overlapping source and dest registers.  */\n-\n const char *\n output_movedouble (rtx insn ATTRIBUTE_UNUSED, rtx operands[],\n \t\t   enum machine_mode mode)\n@@ -2632,7 +2627,6 @@ output_movedouble (rtx insn ATTRIBUTE_UNUSED, rtx operands[],\n \n       /* When mov.d r1,r2 do r2->r3 then r1->r2;\n          when mov.d r1,r0 do r1->r0 then r2->r1.  */\n-\n       if (REGNO (src) + 1 == REGNO (dst))\n \treturn         \"mov\t%T1,%T0\" \"\\n\"\n \t       \"\tmov\t%1,%0\";\n@@ -2700,7 +2694,6 @@ output_movedouble (rtx insn ATTRIBUTE_UNUSED, rtx operands[],\n /* Print an instruction which would have gone into a delay slot after\n    another instruction, but couldn't because the other instruction expanded\n    into a sequence where putting the slot insn at the end wouldn't work.  */\n-\n static void\n print_slot (rtx insn)\n {\n@@ -2811,11 +2804,9 @@ output_far_jump (rtx insn, rtx op)\n \n /* Local label counter, used for constants in the pool and inside\n    pattern branches.  */\n-\n static int lf = 100;\n \n /* Output code for ordinary branches.  */\n-\n const char *\n output_branch (int logic, rtx insn, rtx *operands)\n {\n@@ -2829,7 +2820,6 @@ output_branch (int logic, rtx insn, rtx *operands)\n \t It can also happen when other condbranches hoist delay slot insn\n \t from their destination, thus leading to code size increase.\n \t But the branch will still be in the range -4092..+4098 bytes.  */\n-\n       if (! TARGET_RELAX)\n \t{\n \t  int label = lf++;\n@@ -2958,7 +2948,6 @@ output_ieee_ccmpeq (rtx insn, rtx *operands)\n }\n \f\n /* Output the start of the assembler file.  */\n-\n static void\n sh_file_start (void)\n {\n@@ -2992,7 +2981,6 @@ sh_file_start (void)\n }\n \f\n /* Check if PAT includes UNSPEC_CALLER unspec pattern.  */\n-\n static bool\n unspec_caller_rtx_p (rtx pat)\n {\n@@ -3013,7 +3001,6 @@ unspec_caller_rtx_p (rtx pat)\n \n /* Indicate that INSN cannot be duplicated.  This is true for insn\n    that generates a unique label.  */\n-\n static bool\n sh_cannot_copy_insn_p (rtx insn)\n {\n@@ -3156,6 +3143,8 @@ sh_ashlsi_clobbers_t_reg_p (rtx shift_amount)\n \t  & ASHL_CLOBBERS_T) != 0;\n }\n \n+/* Return true if a logical right shift consisting of 1/2/8/16 shift\n+   instructions will clobber the T bit.  */\n bool\n sh_lshrsi_clobbers_t_reg_p (rtx shift_amount)\n {\n@@ -3194,12 +3183,12 @@ sh_dynamicalize_shift_p (rtx count)\n }\n \n /* Assuming we have a value that has been sign-extended by at least one bit,\n-   can we use the ext_shift_amounts with the last shift turned to an arithmetic shift\n-   to shift it by N without data loss, and quicker than by other means?  */\n+   can we use the ext_shift_amounts with the last shift turned to an\n+   arithmetic shift to shift it by N without data loss, and quicker than by\n+   other means?  */\n #define EXT_SHIFT_SIGNED(n) (((n) | 8) == 15)\n \n /* Return the cost of a shift.  */\n-\n static inline int\n shiftcosts (rtx x)\n {\n@@ -3240,7 +3229,6 @@ shiftcosts (rtx x)\n }\n \n /* Return the cost of an AND/XOR/IOR operation.  */\n-\n static inline int\n and_xor_ior_costs (rtx x, int code)\n {\n@@ -3284,7 +3272,6 @@ and_xor_ior_costs (rtx x, int code)\n }\n \n /* Return the cost of an addition or a subtraction.  */\n-\n static inline int\n addsubcosts (rtx x)\n {\n@@ -3314,7 +3301,7 @@ addsubcosts (rtx x)\n \n       case CONST_INT:\n \tif (CONST_OK_FOR_I16 (INTVAL (XEXP (x, 1))))\n-          return 2;\n+\t  return 2;\n \telse if (CONST_OK_FOR_I16 (INTVAL (XEXP (x, 1)) >> 16))\n \t  return 3;\n \telse if (CONST_OK_FOR_I16 ((INTVAL (XEXP (x, 1)) >> 16) >> 16))\n@@ -3368,7 +3355,6 @@ multcosts (rtx x ATTRIBUTE_UNUSED)\n /* Compute a (partial) cost for rtx X.  Return true if the complete\n    cost has been computed, and false if subexpressions should be\n    scanned.  In either case, *TOTAL contains the cost result.  */\n-\n static bool\n sh_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t      int *total, bool speed ATTRIBUTE_UNUSED)\n@@ -3470,7 +3456,7 @@ sh_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \n     case CONST_INT:\n       if (TARGET_SHMEDIA)\n-        {\n+\t{\n \t  if (INTVAL (x) == 0)\n \t    *total = 0;\n \t  else if (outer_code == AND && and_operand ((x), DImode))\n@@ -3480,15 +3466,15 @@ sh_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \t\t   && CONST_OK_FOR_I10 (INTVAL (x)))\n \t    *total = 0;\n \t  else if (CONST_OK_FOR_I16 (INTVAL (x)))\n-            *total = COSTS_N_INSNS (outer_code != SET);\n+\t    *total = COSTS_N_INSNS (outer_code != SET);\n \t  else if (CONST_OK_FOR_I16 (INTVAL (x) >> 16))\n \t    *total = COSTS_N_INSNS ((outer_code != SET) + 1);\n \t  else if (CONST_OK_FOR_I16 ((INTVAL (x) >> 16) >> 16))\n \t    *total = COSTS_N_INSNS ((outer_code != SET) + 2);\n-          else\n+\t  else\n \t    *total = COSTS_N_INSNS ((outer_code != SET) + 3);\n \t  return true;\n-        }\n+\t}\n       if (CONST_OK_FOR_I08 (INTVAL (x)))\n         *total = 0;\n       else if ((outer_code == AND || outer_code == IOR || outer_code == XOR)\n@@ -3525,23 +3511,23 @@ sh_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n     case LABEL_REF:\n     case SYMBOL_REF:\n       if (TARGET_SHMEDIA64)\n-        *total = COSTS_N_INSNS (4);\n+\t*total = COSTS_N_INSNS (4);\n       else if (TARGET_SHMEDIA32)\n-        *total = COSTS_N_INSNS (2);\n+\t*total = COSTS_N_INSNS (2);\n       else\n \t*total = 5;\n       return true;\n \n     case CONST_DOUBLE:\n       if (TARGET_SHMEDIA)\n-        *total = COSTS_N_INSNS (4);\n+\t*total = COSTS_N_INSNS (4);\n       /* prepare_cmp_insn will force costly constants int registers before\n \t the cbranchdi4 pattern can see them, so preserve potentially\n \t interesting ones.  */\n       else if (outer_code == COMPARE && GET_MODE (x) == DImode)\n-        *total = 1;\n+\t*total = 1;\n       else\n-        *total = 10;\n+\t*total = 10;\n       return true;\n \n     case CONST_VECTOR:\n@@ -3626,7 +3612,6 @@ sh_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n \n /* Determine the size of the fundamental move insn that will be used\n    for the specified mode.  */\n-\n static inline int\n mov_insn_size (enum machine_mode mode, bool consider_sh2a)\n {\n@@ -3646,7 +3631,6 @@ mov_insn_size (enum machine_mode mode, bool consider_sh2a)\n \n /* Determine the maximum possible displacement for a move insn for the\n    specified mode.  */\n-\n static int\n max_mov_insn_displacement (enum machine_mode mode, bool consider_sh2a)\n {\n@@ -3676,7 +3660,6 @@ max_mov_insn_displacement (enum machine_mode mode, bool consider_sh2a)\n \n /* Determine the alignment mask for a move insn of the\n    specified mode.  */\n-\n static inline int\n mov_insn_alignment_mask (enum machine_mode mode, bool consider_sh2a)\n {\n@@ -3685,7 +3668,6 @@ mov_insn_alignment_mask (enum machine_mode mode, bool consider_sh2a)\n }\n \n /* Return the displacement value of a displacement address.  */\n-\n static inline HOST_WIDE_INT\n disp_addr_displacement (rtx x)\n {\n@@ -3694,7 +3676,6 @@ disp_addr_displacement (rtx x)\n }\n \n /* Compute the cost of an address.  */\n-\n static int\n sh_address_cost (rtx x, enum machine_mode mode,\n \t\t addr_space_t as ATTRIBUTE_UNUSED, bool speed ATTRIBUTE_UNUSED)\n@@ -3749,7 +3730,6 @@ sh_address_cost (rtx x, enum machine_mode mode,\n }\n \n /* Code to expand a shift.  */\n-\n static void\n gen_ashift (int type, int n, rtx reg)\n {\n@@ -3775,7 +3755,7 @@ gen_ashift (int type, int n, rtx reg)\n       break;\n     case LSHIFTRT:\n       if (n == 1)\n-        emit_insn (gen_shlr (reg, reg));\n+\temit_insn (gen_shlr (reg, reg));\n       else\n \temit_insn (gen_lshrsi3_k (reg, reg, n_rtx));\n       break;\n@@ -3787,7 +3767,7 @@ gen_ashift (int type, int n, rtx reg)\n     }\n }\n \n-/* Same for HImode */\n+/* Code to expand a HImode shift.  */\n static void\n gen_ashift_hi (int type, int n, rtx reg)\n {\n@@ -3828,7 +3808,6 @@ gen_ashift_hi (int type, int n, rtx reg)\n \n /* Output RTL to split a constant shift into its component SH constant\n    shift instructions.  */\n-\n void\n gen_shifty_op (int code, rtx *operands)\n {\n@@ -3872,9 +3851,8 @@ gen_shifty_op (int code, rtx *operands)\n     gen_ashift (code, ashl_lshr_seq[value].amount[i], operands[0]);\n }\n \n-/* Same as above, but optimized for values where the topmost bits don't\n-   matter.  */\n-\n+/* Same as gen_shifty_op, but optimized for values where the topmost bits\n+   don't matter.  */\n void\n gen_shifty_hi_op (int code, rtx *operands)\n {\n@@ -3905,10 +3883,8 @@ gen_shifty_hi_op (int code, rtx *operands)\n       gen_fun (code, ext_ashl_lshr_seq[value].amount[i], operands[0]);\n }\n \n-/* Output RTL for an arithmetic right shift.  */\n-\n-/* ??? Rewrite to use super-optimizer sequences.  */\n-\n+/* Output RTL for an arithmetic right shift.\n+   ??? Rewrite to use super-optimizer sequences.  */\n bool\n expand_ashiftrt (rtx *operands)\n {\n@@ -4144,7 +4120,6 @@ shl_and_length (rtx insn)\n }\n \n /* This is used in length attribute of the and_shl_scratch instruction.  */\n-\n int\n shl_and_scr_length (rtx insn)\n {\n@@ -4158,7 +4133,6 @@ shl_and_scr_length (rtx insn)\n \n /* Generate rtl for instructions for which shl_and_kind advised a particular\n    method of generating them, i.e. returned zero.  */\n-\n bool\n gen_shl_and (rtx dest, rtx left_rtx, rtx mask_rtx, rtx source)\n {\n@@ -4289,7 +4263,6 @@ gen_shl_and (rtx dest, rtx left_rtx, rtx mask_rtx, rtx source)\n   return 6 for < 8 bit sign extend / left shift.\n   return 7 for < 8 bit sign extend / left shift / single right shift.\n   If COSTP is nonzero, assign the calculated cost to *COSTP.  */\n-\n int\n shl_sext_kind (rtx left_rtx, rtx size_rtx, int *costp)\n {\n@@ -4387,7 +4360,6 @@ shl_sext_kind (rtx left_rtx, rtx size_rtx, int *costp)\n \n /* Function to be used in the length attribute of the instructions\n    implementing this pattern.  */\n-\n int\n shl_sext_length (rtx insn)\n {\n@@ -4402,7 +4374,6 @@ shl_sext_length (rtx insn)\n }\n \n /* Generate rtl for this pattern */\n-\n bool\n gen_shl_sext (rtx dest, rtx left_rtx, rtx size_rtx, rtx source)\n {\n@@ -4523,7 +4494,6 @@ gen_shl_sext (rtx dest, rtx left_rtx, rtx size_rtx, rtx source)\n }\n \n /* Prefix a symbol_ref name with \"datalabel\".  */\n-\n rtx\n gen_datalabel_ref (rtx sym)\n {\n@@ -4643,7 +4613,6 @@ static int max_labelno_before_reorg;\n    necessary.  */\n \n /* Add a constant to the pool and return its label.  */\n-\n static rtx\n add_constant (rtx x, enum machine_mode mode, rtx last_value)\n {\n@@ -4722,7 +4691,6 @@ add_constant (rtx x, enum machine_mode mode, rtx last_value)\n    casesi_worker_2 instruction; We have to emit the operand3 labels from\n    these insns at a 4-byte  aligned position.  BARRIER is the barrier\n    after which we are to place the table.  */\n-\n static void\n dump_table (rtx start, rtx barrier)\n {\n@@ -4912,7 +4880,6 @@ dump_table (rtx start, rtx barrier)\n /* ??? For a DImode/DFmode moves, we don't need to fix it if each half of the\n    CONST_DOUBLE input value is CONST_OK_FOR_I08.  For a SFmode move, we don't\n    need to fix it if the input value is CONST_OK_FOR_I08.  */\n-\n static bool\n broken_move (rtx insn)\n {\n@@ -4936,7 +4903,8 @@ broken_move (rtx insn)\n \t\t&& GET_CODE (SET_SRC (pat)) == CONST_DOUBLE\n \t\t&& (fp_zero_operand (SET_SRC (pat))\n \t\t    || fp_one_operand (SET_SRC (pat)))\n-\t\t/* In general we don't know the current setting of fpscr, so disable fldi.\n+\t\t/* In general we don't know the current setting of fpscr, so\n+\t\t   disable fldi.\n \t\t   There is an exception if this was a register-register move\n \t\t   before reload - and hence it was ascertained that we have\n \t\t   single precision setting - and in a post-reload optimization\n@@ -4958,6 +4926,7 @@ broken_move (rtx insn)\n   return false;\n }\n \n+/* Return true if the specified insn is a mova insn.  */\n static bool\n mova_p (rtx insn)\n {\n@@ -5064,7 +5033,6 @@ untangle_mova (int *num_mova, rtx *first_mova, rtx new_mova)\n /* Find the last barrier from insn FROM which is close enough to hold the\n    constant pool.  If we can't find one, then create one near the end of\n    the range.  */\n-\n static rtx\n find_barrier (int num_mova, rtx mova, rtx from)\n {\n@@ -5179,10 +5147,10 @@ find_barrier (int num_mova, rtx mova, rtx from)\n \t     mov.l\t.L8,r12\n \t     instructions.  (plus add r0,r12).\n \t     Remember if we see one without the other.  */\n-          if (GET_CODE (src) == UNSPEC && PIC_ADDR_P (XVECEXP (src, 0, 0)))\n-            last_got = last_got ? NULL_RTX : from;\n-          else if (PIC_ADDR_P (src))\n-            last_got = last_got ? NULL_RTX : from;\n+\t  if (GET_CODE (src) == UNSPEC && PIC_ADDR_P (XVECEXP (src, 0, 0)))\n+\t    last_got = last_got ? NULL_RTX : from;\n+\t  else if (PIC_ADDR_P (src))\n+\t    last_got = last_got ? NULL_RTX : from;\n \n \t  /* We must explicitly check the mode, because sometimes the\n \t     front end will generate code to load unsigned constants into\n@@ -5442,7 +5410,6 @@ sfunc_uses_reg (rtx insn)\n /* See if the only way in which INSN uses REG is by calling it, or by\n    setting it while calling it.  Set *SET to a SET rtx if the register\n    is set by INSN.  */\n-\n static bool\n noncall_uses_reg (rtx reg, rtx insn, rtx *set)\n {\n@@ -5504,7 +5471,7 @@ noncall_uses_reg (rtx reg, rtx insn, rtx *set)\n       if (reg_mentioned_p (reg, SET_DEST (pattern)))\n \t{\n \t  /* We don't use rtx_equal_p, because we don't care if the\n-             mode is different.  */\n+\t     mode is different.  */\n \t  if (!REG_P (SET_DEST (pattern))\n \t      || REGNO (reg) != REGNO (SET_DEST (pattern)))\n \t    return true;\n@@ -5603,7 +5570,6 @@ regs_used (rtx x, int is_dest)\n    pass 1.  Pass 2 if a definite blocking insn is needed.\n    -1 is used internally to avoid deep recursion.\n    If a blocking instruction is made or recognized, return it.  */\n-\n static rtx\n gen_block_redirect (rtx jump, int addr, int need_block)\n {\n@@ -6019,7 +5985,6 @@ sh_loop_align (rtx label)\n \n /* Do a final pass over the function, just before delayed branch\n    scheduling.  */\n-\n static void\n sh_reorg (void)\n {\n@@ -6104,13 +6069,13 @@ sh_reorg (void)\n \t       scan = PREV_INSN (scan))\n \t    {\n \t      if (! INSN_P (scan))\n-\t        continue;\n+\t\tcontinue;\n \n \t      if (! reg_mentioned_p (reg, scan))\n-\t        continue;\n+\t\tcontinue;\n \n \t      if (noncall_uses_reg (reg, scan, &set))\n-\t        break;\n+\t\tbreak;\n \n \t      if (set)\n \t\t{\n@@ -6125,16 +6090,16 @@ sh_reorg (void)\n \t  /* The register is set at LINK.  */\n \n \t  /* We can only optimize the function call if the register is\n-             being set to a symbol.  In theory, we could sometimes\n-             optimize calls to a constant location, but the assembler\n-             and linker do not support that at present.  */\n+\t     being set to a symbol.  In theory, we could sometimes\n+\t     optimize calls to a constant location, but the assembler\n+\t     and linker do not support that at present.  */\n \t  if (GET_CODE (SET_SRC (set)) != SYMBOL_REF\n \t      && GET_CODE (SET_SRC (set)) != LABEL_REF)\n \t    continue;\n \n \t  /* Scan forward from LINK to the place where REG dies, and\n-             make sure that the only insns which use REG are\n-             themselves function calls.  */\n+\t     make sure that the only insns which use REG are\n+\t     themselves function calls.  */\n \n \t  /* ??? This doesn't work for call targets that were allocated\n \t     by reload, since there may not be a REG_DEAD note for the\n@@ -6159,8 +6124,8 @@ sh_reorg (void)\n \t\tcontinue;\n \n \t      /* Don't try to trace forward past a JUMP.  To optimize\n-                 safely, we would have to check that all the\n-                 instructions at the jump destination did not use REG.  */\n+\t\t safely, we would have to check that all the\n+\t\t instructions at the jump destination did not use REG.  */\n \n \t      if (JUMP_P (scan))\n \t\tbreak;\n@@ -6178,8 +6143,8 @@ sh_reorg (void)\n \t\t  && (CALL_P (scan) || sfunc_uses_reg (scan)))\n \t\t{\n \t\t  /* There is a function call to this register other\n-                     than the one we are checking.  If we optimize\n-                     this call, we need to rescan again below.  */\n+\t\t     than the one we are checking.  If we optimize\n+\t\t     this call, we need to rescan again below.  */\n \t\t  rescan = 1;\n \t\t}\n \n@@ -6209,15 +6174,15 @@ sh_reorg (void)\n \t  if (! dies)\n \t    {\n \t      /* Either there was a branch, or some insn used REG\n-                 other than as a function call address.  */\n+\t\t other than as a function call address.  */\n \t      continue;\n \t    }\n \n \t  /* Create a code label, and put it in a REG_LABEL_OPERAND note\n-             on the insn which sets the register, and on each call insn\n-             which uses the register.  In final_prescan_insn we look for\n-             the REG_LABEL_OPERAND notes, and output the appropriate label\n-             or pseudo-op.  */\n+\t     on the insn which sets the register, and on each call insn\n+\t     which uses the register.  In final_prescan_insn we look for\n+\t     the REG_LABEL_OPERAND notes, and output the appropriate label\n+\t     or pseudo-op.  */\n \n \t  label = gen_label_rtx ();\n \t  add_reg_note (link, REG_LABEL_OPERAND, label);\n@@ -6480,6 +6445,7 @@ sh_reorg (void)\n   mdep_reorg_phase = SH_AFTER_MDEP_REORG;\n }\n \n+/* Return the UID of the insn that follows the specified label.  */\n int\n get_dest_uid (rtx label, int max_uid)\n {\n@@ -6508,7 +6474,6 @@ get_dest_uid (rtx label, int max_uid)\n    We do this before delay slot scheduling, so that it can take our\n    newly created instructions into account.  It also allows us to\n    find branches with common targets more easily.  */\n-\n static void\n split_branches (rtx first)\n {\n@@ -6727,13 +6692,12 @@ split_branches (rtx first)\n    constant pool table stuff.\n \n    If relaxing, output the label and pseudo-ops used to link together\n-   calls and the instruction which set the registers.  */\n+   calls and the instruction which set the registers.\n \n-/* ??? The addresses printed by this routine for insns are nonsense for\n+   ??? The addresses printed by this routine for insns are nonsense for\n    insns which are inside of a sequence where none of the inner insns have\n    variable length.  This is because the second pass of shorten_branches\n    does not bother to update them.  */\n-\n void\n final_prescan_insn (rtx insn, rtx *opvec ATTRIBUTE_UNUSED,\n \t\t    int noperands ATTRIBUTE_UNUSED)\n@@ -6778,7 +6742,6 @@ final_prescan_insn (rtx insn, rtx *opvec ATTRIBUTE_UNUSED,\n \n /* Dump out any constants accumulated in the final pass.  These will\n    only be labels.  */\n-\n const char *\n output_jump_label_table (void)\n {\n@@ -6818,17 +6781,16 @@ output_jump_label_table (void)\n    local-n\n    ..\n    local-1\n-   local-0        <- fp points here.  */\n+   local-0        <- fp points here.\n \n-/* Number of bytes pushed for anonymous args, used to pass information\n-   between expand_prologue and expand_epilogue.  */\n+   Number of bytes pushed for anonymous args, used to pass information\n+   between expand_prologue and expand_epilogue.\n \n-/* Adjust the stack by SIZE bytes.  REG holds the rtl of the register to be\n+   Adjust the stack by SIZE bytes.  REG holds the rtl of the register to be\n    adjusted.  If epilogue_p is zero, this is for a prologue; otherwise, it's\n    for an epilogue and a negative value means that it's for a sibcall\n    epilogue.  If LIVE_REGS_MASK is nonzero, it points to a HARD_REG_SET of\n    all the registers that are about to be restored, and hence dead.  */\n-\n static void\n output_stack_adjust (int size, rtx reg, int epilogue_p,\n \t\t     HARD_REG_SET *live_regs_mask, bool frame_p)\n@@ -6991,6 +6953,8 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,\n     }\n }\n \n+/* Emit the specified insn and mark it as frame related.\n+   FIXME: Rename this to emit_frame_insn.  */\n static rtx\n frame_insn (rtx x)\n {\n@@ -7000,7 +6964,6 @@ frame_insn (rtx x)\n }\n \n /* Output RTL to push register RN onto the stack.  */\n-\n static rtx\n push (int rn)\n {\n@@ -7009,8 +6972,8 @@ push (int rn)\n     x = gen_push_fpul ();\n   else if (rn == FPSCR_REG)\n     x = gen_push_fpscr ();\n-  else if ((TARGET_SH4 || TARGET_SH2A_DOUBLE) && TARGET_FMOVD && ! TARGET_FPU_SINGLE\n-\t   && FP_OR_XD_REGISTER_P (rn))\n+  else if ((TARGET_SH4 || TARGET_SH2A_DOUBLE) && TARGET_FMOVD\n+\t   && ! TARGET_FPU_SINGLE && FP_OR_XD_REGISTER_P (rn))\n     {\n       if (FP_REGISTER_P (rn) && (rn - FIRST_FP_REG) & 1)\n \treturn NULL_RTX;\n@@ -7027,7 +6990,6 @@ push (int rn)\n }\n \n /* Output RTL to pop register RN from the stack.  */\n-\n static void\n pop (int rn)\n {\n@@ -7036,8 +6998,8 @@ pop (int rn)\n     x = gen_pop_fpul ();\n   else if (rn == FPSCR_REG)\n     x = gen_pop_fpscr ();\n-  else if ((TARGET_SH4 || TARGET_SH2A_DOUBLE) && TARGET_FMOVD && ! TARGET_FPU_SINGLE\n-\t   && FP_OR_XD_REGISTER_P (rn))\n+  else if ((TARGET_SH4 || TARGET_SH2A_DOUBLE) && TARGET_FMOVD\n+\t   && ! TARGET_FPU_SINGLE && FP_OR_XD_REGISTER_P (rn))\n     {\n       if (FP_REGISTER_P (rn) && (rn - FIRST_FP_REG) & 1)\n \treturn;\n@@ -7064,7 +7026,6 @@ pop (int rn)\n }\n \n /* Generate code to push the regs specified in the mask.  */\n-\n static void\n push_regs (HARD_REG_SET *mask, int interrupt_handler)\n {\n@@ -7092,16 +7053,16 @@ push_regs (HARD_REG_SET *mask, int interrupt_handler)\n       if (i != PR_REG\n \t  && (i != FPSCR_REG || ! skip_fpscr)\n \t  && TEST_HARD_REG_BIT (*mask, i))\n-           {\n-  \t/* If the ISR has RESBANK attribute assigned, don't push any of\n-   \t   the following registers - R0-R14, MACH, MACL and GBR.  */\n+\t{\n+\t/* If the ISR has RESBANK attribute assigned, don't push any of\n+\t   the following registers - R0-R14, MACH, MACL and GBR.  */\n       if (! (sh_cfun_resbank_handler_p ()\n \t     && ((i >= FIRST_GENERAL_REG && i < LAST_GENERAL_REG)\n \t\t || i == MACH_REG\n \t\t || i == MACL_REG\n \t\t || i == GBR_REG)))\n \t  push (i);\n-  \t}\n+\t}\n     }\n \n   /* Push banked registers last to improve delay slot opportunities.  */\n@@ -7162,7 +7123,6 @@ push_regs (HARD_REG_SET *mask, int interrupt_handler)\n /* Calculate how much extra space is needed to save all callee-saved\n    target registers.\n    LIVE_REGS_MASK is the register mask calculated by calc_live_regs.  */\n-\n static int\n shmedia_target_regs_stack_space (HARD_REG_SET *live_regs_mask)\n {\n@@ -7172,7 +7132,7 @@ shmedia_target_regs_stack_space (HARD_REG_SET *live_regs_mask)\n \n   for (reg = LAST_TARGET_REG; reg >= FIRST_TARGET_REG; reg--)\n     if ((! call_really_used_regs[reg] || interrupt_handler)\n-        && ! TEST_HARD_REG_BIT (*live_regs_mask, reg))\n+\t&& ! TEST_HARD_REG_BIT (*live_regs_mask, reg))\n       /* Leave space to save this target register on the stack,\n \t in case target register allocation wants to use it.  */\n       stack_space += GET_MODE_SIZE (REGISTER_NATURAL_MODE (reg));\n@@ -7183,7 +7143,6 @@ shmedia_target_regs_stack_space (HARD_REG_SET *live_regs_mask)\n    in case target register allocation wants to use them.  REGS_SAVED is\n    the space, in bytes, that is already required for register saves.\n    LIVE_REGS_MASK is the register mask calculated by calc_live_regs.  */\n-\n static int\n shmedia_reserve_space_for_target_registers_p (int regs_saved,\n \t\t\t\t\t      HARD_REG_SET *live_regs_mask)\n@@ -7196,7 +7155,6 @@ shmedia_reserve_space_for_target_registers_p (int regs_saved,\n /* Decide how much space to reserve for callee-save target registers\n    in case target register allocation wants to use them.\n    LIVE_REGS_MASK is the register mask calculated by calc_live_regs.  */\n-\n static int\n shmedia_target_regs_stack_adjust (HARD_REG_SET *live_regs_mask)\n {\n@@ -7212,7 +7170,6 @@ shmedia_target_regs_stack_adjust (HARD_REG_SET *live_regs_mask)\n    If doing a pragma interrupt function, then push all regs used by the\n    function, and if we call another function (we can tell by looking at PR),\n    make sure that all the regs it clobbers are safe too.  */\n-\n static int\n calc_live_regs (HARD_REG_SET *live_regs_mask)\n {\n@@ -7234,7 +7191,8 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n       && df_regs_ever_live_p (FPSCR_REG))\n     target_flags &= ~MASK_FPU_SINGLE;\n   /* If we can save a lot of saves by switching to double mode, do that.  */\n-  else if ((TARGET_SH4 || TARGET_SH2A_DOUBLE) && TARGET_FMOVD && TARGET_FPU_SINGLE)\n+  else if ((TARGET_SH4 || TARGET_SH2A_DOUBLE) && TARGET_FMOVD\n+\t   && TARGET_FPU_SINGLE)\n     for (count = 0, reg = FIRST_FP_REG; reg <= LAST_FP_REG; reg += 2)\n       if (df_regs_ever_live_p (reg) && df_regs_ever_live_p (reg+1)\n \t  && (! call_really_used_regs[reg]\n@@ -7438,7 +7396,6 @@ typedef struct save_schedule_s\n    use reverse order.  Returns the last entry written to (not counting\n    the delimiter).  OFFSET_BASE is a number to be added to all offset\n    entries.  */\n-\n static save_entry *\n sh5_schedule_saves (HARD_REG_SET *live_regs_mask, save_schedule *schedule,\n \t\t    int offset_base)\n@@ -7532,6 +7489,7 @@ sh5_schedule_saves (HARD_REG_SET *live_regs_mask, save_schedule *schedule,\n   return entry - 1;\n }\n \n+/* Expand code for the function prologue.  */\n void\n sh_expand_prologue (void)\n {\n@@ -7893,6 +7851,7 @@ sh_expand_prologue (void)\n     current_function_static_stack_size = stack_usage;\n }\n \n+/* Expand code for the function epilogue.  */\n void\n sh_expand_epilogue (bool sibcall_p)\n {\n@@ -7915,8 +7874,8 @@ sh_expand_epilogue (bool sibcall_p)\n       int tregs_space = shmedia_target_regs_stack_adjust (&live_regs_mask);\n       int total_size;\n       if (d % (STACK_BOUNDARY / BITS_PER_UNIT))\n-      d_rounding = ((STACK_BOUNDARY / BITS_PER_UNIT)\n-\t\t    - d % (STACK_BOUNDARY / BITS_PER_UNIT));\n+\td_rounding = ((STACK_BOUNDARY / BITS_PER_UNIT)\n+\t\t      - d % (STACK_BOUNDARY / BITS_PER_UNIT));\n \n       total_size = d + tregs_space;\n       total_size += rounded_frame_size (total_size);\n@@ -8196,7 +8155,6 @@ sh_expand_epilogue (bool sibcall_p)\n \n /* Emit code to change the current function's return address to RA.\n    TEMP is available as a scratch register, if needed.  */\n-\n void\n sh_set_return_address (rtx ra, rtx tmp)\n {\n@@ -8268,7 +8226,6 @@ sh_set_return_address (rtx ra, rtx tmp)\n }\n \n /* Clear variables at function end.  */\n-\n static void\n sh_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n \t\t\t     HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n@@ -8424,7 +8381,6 @@ sh_builtin_saveregs (void)\n }\n \n /* Define the `__builtin_va_list' type for the ABI.  */\n-\n static tree\n sh_build_builtin_va_list (void)\n {\n@@ -8477,7 +8433,6 @@ sh_build_builtin_va_list (void)\n }\n \n /* Implement `va_start' for varargs and stdarg.  */\n-\n static void\n sh_va_start (tree valist, rtx nextarg)\n {\n@@ -8575,8 +8530,8 @@ find_sole_member (tree type)\n     }\n   return member;\n }\n-/* Implement `va_arg'.  */\n \n+/* Implement `va_arg'.  */\n static tree\n sh_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n \t\t\t gimple_seq *post_p ATTRIBUTE_UNUSED)\n@@ -8619,7 +8574,7 @@ sh_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n       next_o_limit = build3 (COMPONENT_REF, TREE_TYPE (f_next_o_limit),\n \t\t\t     valist, f_next_o_limit, NULL_TREE);\n       next_fp = build3 (COMPONENT_REF, TREE_TYPE (f_next_fp),\n-\t\t        valist, f_next_fp, NULL_TREE);\n+\t\t\tvalist, f_next_fp, NULL_TREE);\n       next_fp_limit = build3 (COMPONENT_REF, TREE_TYPE (f_next_fp_limit),\n \t\t\t      valist, f_next_fp_limit, NULL_TREE);\n       next_stack = build3 (COMPONENT_REF, TREE_TYPE (f_next_stack),\n@@ -8793,7 +8748,7 @@ sh_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n }\n \n /* 64 bit floating points memory transfers are paired single precision loads\n-   or store. So DWARF information needs fixing in little endian (unless\n+   or store.  So DWARF information needs fixing in little endian (unless\n    PR=SZ=1 in FPSCR).  */\n rtx\n sh_dwarf_register_span (rtx reg)\n@@ -8836,7 +8791,6 @@ sh_promote_prototypes (const_tree type)\n    pretend arguments wider than 32-bits that would have been passed in\n    registers are passed by reference, so that an SHmedia trampoline\n    loads them into the full 64-bits registers.  */\n-\n static int\n shcompact_byref (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t const_tree type, bool named)\n@@ -8939,7 +8893,6 @@ sh_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n    and the rest are pushed.  Any arg that starts within the first\n    NPARM_REGS words is at least partially passed in a register unless\n    its data type forbids.  */\n-\n static rtx\n sh_function_arg (cumulative_args_t ca_v, enum machine_mode mode,\n \t\t const_tree type, bool named)\n@@ -9029,7 +8982,6 @@ sh_function_arg (cumulative_args_t ca_v, enum machine_mode mode,\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be\n    available.)  */\n-\n static void\n sh_function_arg_advance (cumulative_args_t ca_v, enum machine_mode mode,\n \t\t\t const_tree type, bool named)\n@@ -9192,9 +9144,8 @@ sh_struct_value_rtx (tree fndecl, int incoming ATTRIBUTE_UNUSED)\n    For the SH, this is like LIBCALL_VALUE, except that we must change the\n    mode like PROMOTE_MODE does.\n    ??? PROMOTE_MODE is ignored for non-scalar types.  The set of types\n-   tested here has to be kept in sync with the one in explow.c:promote_mode.\n-*/\n-\n+   tested here has to be kept in sync with the one in\n+   explow.c:promote_mode.  */\n static rtx\n sh_function_value (const_tree valtype,\n \t\t   const_tree fn_decl_or_type,\n@@ -9218,15 +9169,13 @@ sh_function_value (const_tree valtype,\n }\n \n /* Worker function for TARGET_LIBCALL_VALUE.  */\n-\n static rtx\n sh_libcall_value (enum machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n {\n   return gen_rtx_REG (mode, BASE_RETURN_VALUE_REG (mode));\n }\n \n /* Return true if N is a possible register number of function value.  */\n-\n static bool\n sh_function_value_regno_p (const unsigned int regno)\n {\n@@ -9236,7 +9185,6 @@ sh_function_value_regno_p (const unsigned int regno)\n }\n \n /* Worker function for TARGET_RETURN_IN_MEMORY.  */\n-\n static bool\n sh_return_in_memory (const_tree type, const_tree fndecl)\n {\n@@ -9299,7 +9247,6 @@ sh_pretend_outgoing_varargs_named (cumulative_args_t ca_v)\n \n /* Define the offset between two registers, one to be eliminated, and\n    the other its replacement, at the start of a routine.  */\n-\n int\n initial_elimination_offset (int from, int to)\n {\n@@ -9333,11 +9280,11 @@ initial_elimination_offset (int from, int to)\n \n   if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n     return total_saved_regs_space + total_auto_space\n-      + crtl->args.info.byref_regs * 8;\n+\t   + crtl->args.info.byref_regs * 8;\n \n   if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n     return total_saved_regs_space + total_auto_space\n-      + crtl->args.info.byref_regs * 8;\n+\t   + crtl->args.info.byref_regs * 8;\n \n   /* Initial gap between fp and sp is 0.  */\n   if (from == HARD_FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n@@ -9358,15 +9305,15 @@ initial_elimination_offset (int from, int to)\n       int pr_reg = TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG;\n       save_schedule schedule;\n       save_entry *entry;\n-      \n+\n       n += total_auto_space;\n-      \n+\n       /* If it wasn't saved, there's not much we can do.  */\n       if (! TEST_HARD_REG_BIT (live_regs_mask, pr_reg))\n \treturn n;\n-      \n+\n       target_flags = copy_flags;\n-      \n+\n       sh5_schedule_saves (&live_regs_mask, &schedule, n);\n       for (entry = &schedule.entries[1]; entry->mode != VOIDmode; entry++)\n \tif (entry->reg == pr_reg)\n@@ -9386,16 +9333,16 @@ sh_fix_range (const char *const_str)\n {\n   int i, first, last;\n   char *str, *dash, *comma;\n-  \n+\n   /* str must be of the form REG1'-'REG2{,REG1'-'REG} where REG1 and\n      REG2 are either register names or register numbers.  The effect\n      of this option is to mark the registers in the range from REG1 to\n      REG2 as ``fixed'' so they won't be used by the compiler.  */\n-  \n+\n   i = strlen (const_str);\n   str = (char *) alloca (i + 1);\n   memcpy (str, const_str, i + 1);\n-  \n+\n   while (1)\n     {\n       dash = strchr (str, '-');\n@@ -9408,29 +9355,29 @@ sh_fix_range (const char *const_str)\n       comma = strchr (dash + 1, ',');\n       if (comma)\n \t*comma = '\\0';\n-      \n+\n       first = decode_reg_name (str);\n       if (first < 0)\n \t{\n \t  warning (0, \"unknown register name: %s\", str);\n \t  return;\n \t}\n-      \n+\n       last = decode_reg_name (dash + 1);\n       if (last < 0)\n \t{\n \t  warning (0, \"unknown register name: %s\", dash + 1);\n \t  return;\n \t}\n-      \n+\n       *dash = '-';\n-      \n+\n       if (first > last)\n \t{\n \t  warning (0, \"%s-%s is an empty range\", str, dash + 1);\n \t  return;\n \t}\n-      \n+\n       for (i = first; i <= last; ++i)\n \tfixed_regs[i] = call_used_regs[i] = 1;\n \n@@ -9553,20 +9500,20 @@ sh_insert_attributes (tree node, tree *attributes)\n /* Handle a 'resbank' attribute.  */\n static tree\n sh_handle_resbank_handler_attribute (tree * node, tree name,\n-                                     tree args ATTRIBUTE_UNUSED,\n-                                     int flags ATTRIBUTE_UNUSED,\n-                                     bool * no_add_attrs)\n+\t\t\t\t     tree args ATTRIBUTE_UNUSED,\n+\t\t\t\t     int flags ATTRIBUTE_UNUSED,\n+\t\t\t\t     bool * no_add_attrs)\n {\n   if (!TARGET_SH2A)\n     {\n       warning (OPT_Wattributes, \"%qE attribute is supported only for SH2A\",\n-               name);\n+\t       name);\n       *no_add_attrs = true;\n     }\n   if (TREE_CODE (*node) != FUNCTION_DECL)\n     {\n       warning (OPT_Wattributes, \"%qE attribute only applies to functions\",\n-               name);\n+\t       name);\n       *no_add_attrs = true;\n     }\n \n@@ -9577,14 +9524,14 @@ sh_handle_resbank_handler_attribute (tree * node, tree name,\n    struct attribute_spec.handler.  */\n static tree\n sh_handle_interrupt_handler_attribute (tree *node, tree name,\n-                                       tree args ATTRIBUTE_UNUSED,\n-                                       int flags ATTRIBUTE_UNUSED,\n-                                       bool *no_add_attrs)\n+\t\t\t\t       tree args ATTRIBUTE_UNUSED,\n+\t\t\t\t       int flags ATTRIBUTE_UNUSED,\n+\t\t\t\t       bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) != FUNCTION_DECL)\n     {\n       warning (OPT_Wattributes, \"%qE attribute only applies to functions\",\n-               name);\n+\t       name);\n       *no_add_attrs = true;\n     }\n   else if (TARGET_SHCOMPACT)\n@@ -9600,36 +9547,36 @@ sh_handle_interrupt_handler_attribute (tree *node, tree name,\n    struct attribute_spec.handler.  */\n static tree\n sh2a_handle_function_vector_handler_attribute (tree * node, tree name,\n-                                               tree args ATTRIBUTE_UNUSED,\n-                                               int flags ATTRIBUTE_UNUSED,\n-                                               bool * no_add_attrs)\n+\t\t\t\t\t       tree args ATTRIBUTE_UNUSED,\n+\t\t\t\t\t       int flags ATTRIBUTE_UNUSED,\n+\t\t\t\t\t       bool * no_add_attrs)\n {\n   if (!TARGET_SH2A)\n     {\n       warning (OPT_Wattributes, \"%qE attribute only applies to SH2A\",\n-               name);\n+\t       name);\n       *no_add_attrs = true;\n     }\n   else if (TREE_CODE (*node) != FUNCTION_DECL)\n     {\n       warning (OPT_Wattributes, \"%qE attribute only applies to functions\",\n-               name);\n+\t       name);\n       *no_add_attrs = true;\n     }\n   else if (TREE_CODE (TREE_VALUE (args)) != INTEGER_CST)\n     {\n       /* The argument must be a constant integer.  */\n       warning (OPT_Wattributes,\n-               \"%qE attribute argument not an integer constant\",\n-               name);\n+\t       \"%qE attribute argument not an integer constant\",\n+\t       name);\n       *no_add_attrs = true;\n     }\n   else if (TREE_INT_CST_LOW (TREE_VALUE (args)) > 255)\n     {\n       /* The argument value must be between 0 to 255.  */\n       warning (OPT_Wattributes,\n-               \"%qE attribute argument should be between 0 to 255\",\n-               name);\n+\t       \"%qE attribute argument should be between 0 to 255\",\n+\t       name);\n       *no_add_attrs = true;\n     }\n   return NULL_TREE;\n@@ -9666,19 +9613,19 @@ sh2a_get_function_vector_number (rtx x)\n       t = SYMBOL_REF_DECL (x);\n \n       if (TREE_CODE (t) != FUNCTION_DECL)\n-        return 0;\n+\treturn 0;\n \n       list = SH_ATTRIBUTES (t);\n       while (list)\n-        {\n-          if (is_attribute_p (\"function_vector\", TREE_PURPOSE (list)))\n-            {\n-              num = TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (list)));\n-              return num;\n-            }\n+\t{\n+\t  if (is_attribute_p (\"function_vector\", TREE_PURPOSE (list)))\n+\t    {\n+\t      num = TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (list)));\n+\t      return num;\n+\t    }\n \n-          list = TREE_CHAIN (list);\n-        }\n+\t  list = TREE_CHAIN (list);\n+\t}\n \n       return 0;\n     }\n@@ -9768,6 +9715,8 @@ sh_cfun_attr_renesas_p (void)\n   return sh_attr_renesas_p (current_function_decl);\n }\n \n+/* Returns true if the current function has the \"interrupt_handler\"\n+   attribute set.  */\n bool\n sh_cfun_interrupt_handler_p (void)\n {\n@@ -9789,28 +9738,26 @@ sh2a_function_vector_p (tree func)\n   while (list)\n     {\n       if (is_attribute_p (\"function_vector\", TREE_PURPOSE (list)))\n-        return true;\n+\treturn true;\n \n       list = TREE_CHAIN (list);\n     }\n   return false;\n }\n \n-/* Returns TRUE if given tree has the \"resbank\" attribute.  */\n-\n+/* Returns true if given tree has the \"resbank\" attribute set.  */\n bool\n sh_cfun_resbank_handler_p (void)\n {\n   return ((lookup_attribute (\"resbank\",\n-                             DECL_ATTRIBUTES (current_function_decl))\n-           != NULL_TREE)\n-          && (lookup_attribute (\"interrupt_handler\",\n-                                DECL_ATTRIBUTES (current_function_decl))\n-              != NULL_TREE) && TARGET_SH2A);\n+\t\t\t     DECL_ATTRIBUTES (current_function_decl))\n+\t  != NULL_TREE)\n+\t  && (lookup_attribute (\"interrupt_handler\",\n+\t\t\t\tDECL_ATTRIBUTES (current_function_decl))\n+\t      != NULL_TREE) && TARGET_SH2A);\n }\n \n /* Returns true if the current function has a \"trap_exit\" attribute set.  */\n-\n bool\n sh_cfun_trap_exit_p (void)\n {\n@@ -9819,7 +9766,6 @@ sh_cfun_trap_exit_p (void)\n }\n \n /* Implement TARGET_CHECK_PCH_TARGET_FLAGS.  */\n-\n static const char *\n sh_check_pch_target_flags (int old_flags)\n {\n@@ -9838,7 +9784,6 @@ sh_check_pch_target_flags (int old_flags)\n \n /* Returns true if OP is MACL, MACH or PR.  The input must be a REG rtx.\n    Used only in general_movsrc_operand.  */\n-\n bool\n system_reg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n@@ -9853,7 +9798,6 @@ system_reg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n }\n \n /* Returns true if OP is a floating point value with value 0.0.  */\n-\n bool\n fp_zero_operand (rtx op)\n {\n@@ -9867,7 +9811,6 @@ fp_zero_operand (rtx op)\n }\n \n /* Returns true if OP is a floating point value with value 1.0.  */\n-\n bool\n fp_one_operand (rtx op)\n {\n@@ -9893,7 +9836,7 @@ fldi_ok (void)\n   return true;\n }\n \n-/* Return the TLS type for TLS symbols, 0 for otherwise.  */\n+/* Return the TLS type for TLS symbols.  */\n enum tls_model\n tls_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n@@ -9903,7 +9846,6 @@ tls_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n }\n \f\n /* Return the destination address of a branch.  */\n-\n static int\n branch_dest (rtx branch)\n {\n@@ -10130,7 +10072,6 @@ __complex__ long long f (double d) { if (d == 0) return 2; else return 3; }\n    register to a pseudo and using that register, the return value is not\n    live before or after this block, yet we we'll insert our insns right in\n    the middle.  */\n-\n static rtx\n get_free_reg (HARD_REG_SET regs_live)\n {\n@@ -10257,7 +10198,6 @@ sh_insn_length_adjustment (rtx insn)\n \f\n /* Return TRUE for a valid displacement for the REG+disp addressing\n    with MODE.  */\n-\n bool\n sh_legitimate_index_p (enum machine_mode mode, rtx op, bool consider_sh2a,\n \t\t       bool allow_zero)\n@@ -10307,7 +10247,6 @@ sh_legitimate_index_p (enum machine_mode mode, rtx op, bool consider_sh2a,\n \t  --REG\n \t  GBR\n \t  GBR+disp  */\n-\n static bool\n sh_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n@@ -10453,7 +10392,6 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n    does not look at other present displacement addressings around it.\n    In some cases this can create more base address adjustments than would\n    actually be necessary.  */\n-\n struct disp_adjust\n {\n   rtx offset_adjust;\n@@ -10499,7 +10437,6 @@ sh_find_mov_disp_adjust (enum machine_mode mode, HOST_WIDE_INT offset)\n /* Try to modify an illegitimate address and make it legitimate.\n    If we find one, return the new, valid address.\n    Otherwise, return the original address.  */\n-\n static rtx\n sh_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n {\n@@ -10535,7 +10472,6 @@ sh_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n    a valid memory address for an operand of mode MODE.\n    Like for sh_legitimize_address, for the SH we try to get a normal form\n    of the address.  That will allow inheritance of the address reloads.  */\n-\n bool\n sh_legitimize_reload_address (rtx *p, enum machine_mode mode, int opnum,\n \t\t\t      int itype)\n@@ -10611,7 +10547,6 @@ sh_legitimize_reload_address (rtx *p, enum machine_mode mode, int opnum,\n /* In the name of slightly smaller debug output, and to cater to\n    general assembler lossage, recognize various UNSPEC sequences\n    and turn them back into a direct symbol reference.  */\n-\n static rtx\n sh_delegitimize_address (rtx orig_x)\n {\n@@ -10766,7 +10701,6 @@ sh_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n   /* Interrupt functions can only use registers that have already been\n      saved by the prologue, even if they would normally be\n      call-clobbered.  */\n-\n   if (sh_cfun_interrupt_handler_p () && !df_regs_ever_live_p (new_reg))\n     return false;\n \n@@ -11235,7 +11169,6 @@ sh_md_init_global (FILE *dump ATTRIBUTE_UNUSED,\n \n   CURR_REGMODE_PRESSURE (SImode) = 0;\n   CURR_REGMODE_PRESSURE (SFmode) = 0;\n-\n }\n \n /* Cleanup.  */\n@@ -11445,7 +11378,6 @@ sh_ms_bitfield_layout_p (const_tree record_type ATTRIBUTE_UNUSED)\n /* Emit RTL insns to initialize the variable parts of a trampoline.\n    FNADDR is an RTX for the address of the function's pure code.\n    CXT is an RTX for the static chain value for the function.  */\n-\n static void\n sh_trampoline_init (rtx tramp_mem, tree fndecl, rtx cxt)\n {\n@@ -11463,8 +11395,8 @@ sh_trampoline_init (rtx tramp_mem, tree fndecl, rtx cxt)\n \n       /* The following trampoline works within a +- 128 KB range for cxt:\n \t ptb/u cxt,tr1; movi fnaddr >> 48,r0; shori fnaddr >> 32,r0;\n-         shori fnaddr >> 16,r0; shori fnaddr,r0; ptabs/l r0,tr0\n-         gettr tr1,r1; blink tr0,r63  */\n+\t shori fnaddr >> 16,r0; shori fnaddr,r0; ptabs/l r0,tr0\n+\t gettr tr1,r1; blink tr0,r63  */\n       /* Address rounding makes it hard to compute the exact bounds of the\n \t offset for this trampoline, but we have a rather generous offset\n \t range, so frame_offset should do fine as an upper bound.  */\n@@ -11597,7 +11529,6 @@ sh_trampoline_init (rtx tramp_mem, tree fndecl, rtx cxt)\n }\n \n /* On SH5, trampolines are SHmedia code, so add 1 to the address.  */\n-\n static rtx\n sh_trampoline_adjust_address (rtx tramp)\n {\n@@ -11994,7 +11925,6 @@ sh_dwarf_calling_convention (const_tree func)\n }\n \n /* Returns the sh builtin decl for CODE.  */\n-\n static tree\n sh_builtin_decl (unsigned code, bool initialize_p ATTRIBUTE_UNUSED)\n {\n@@ -12012,7 +11942,6 @@ sh_builtin_decl (unsigned code, bool initialize_p ATTRIBUTE_UNUSED)\n    (and in mode MODE if that's convenient).\n    SUBTARGET may be used as the target for computing one of EXP's operands.\n    IGNORE is nonzero if the value is to be ignored.  */\n-\n static rtx\n sh_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \t\t   enum machine_mode mode ATTRIBUTE_UNUSED, int ignore)\n@@ -12129,7 +12058,6 @@ sh_expand_binop_v2sf (enum rtx_code code, rtx op0, rtx op1, rtx op2)\n \n    We want to allow TImode FP regs so that when V4SFmode is loaded as TImode,\n    it won't be ferried through GP registers first.  */\n-\n bool\n sh_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n {\n@@ -12250,7 +12178,6 @@ sh_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n \n /* Return true if registers in machine mode MODE will likely be\n    allocated to registers in small register classes.  */\n-\n bool\n sh_small_register_classes_for_mode_p (enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n@@ -12259,7 +12186,6 @@ sh_small_register_classes_for_mode_p (enum machine_mode mode ATTRIBUTE_UNUSED)\n \n /* If ADDRESS refers to a CODE_LABEL, add NUSES to the number of times\n    that label is used.  */\n-\n void\n sh_mark_label (rtx address, int nuses)\n {\n@@ -12277,12 +12203,11 @@ sh_mark_label (rtx address, int nuses)\n }\n \n /* Compute extra cost of moving data between one register class\n-   and another.  */\n+   and another.\n \n-/* If SECONDARY*_RELOAD_CLASS says something about the src/dst pair, regclass\n+   If SECONDARY*_RELOAD_CLASS says something about the src/dst pair, regclass\n    uses this information.  Hence, the general register <-> floating point\n    register information here is not used for SFmode.  */\n-\n static int\n sh_register_move_cost (enum machine_mode mode,\n \t\t       reg_class_t srcclass, reg_class_t dstclass)\n@@ -12479,7 +12404,7 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t  /* scratch0 != scratch1, and we have indexed loads.  Get better\n \t     schedule by loading the offset into r1 and using an indexed\n \t     load - then the load of r1 can issue before the load from\n-             (this_rtx + delta) finishes.  */\n+\t     (this_rtx + delta) finishes.  */\n \t  emit_move_insn (scratch1, GEN_INT (vcall_offset));\n \t  offset_addr = gen_rtx_PLUS (Pmode, scratch0, scratch1);\n \t}\n@@ -12589,7 +12514,7 @@ function_symbol (rtx target, const char *name, enum sh_function_kind kind)\n       case SFUNC_STATIC:\n \t{\n \t  /* ??? To allow cse to work, we use GOTOFF relocations.\n-\t     we could add combiner patterns to transform this into\n+\t     We could add combiner patterns to transform this into\n \t     straight pc-relative calls with sym2PIC / bsrf when\n \t     label load and function call are still 1:1 and in the\n \t     same basic block during combine.  */\n@@ -12767,13 +12692,12 @@ sh_fsca_int2sf (void)\n }\n \n /* Initialize the CUMULATIVE_ARGS structure.  */\n-\n void\n sh_init_cumulative_args (CUMULATIVE_ARGS *  pcum,\n-\t\t\t tree               fntype,\n+\t\t\t tree\t\t    fntype,\n \t\t\t rtx\t\t    libname ATTRIBUTE_UNUSED,\n-\t\t\t tree               fndecl,\n-\t\t\t signed int         n_named_args,\n+\t\t\t tree\t\t    fndecl,\n+\t\t\t signed int\t    n_named_args,\n \t\t\t enum machine_mode  mode)\n {\n   pcum->arg_count [(int) SH_ARG_FLOAT] = 0;\n@@ -12851,7 +12775,6 @@ sh_init_cumulative_args (CUMULATIVE_ARGS *  pcum,\n \n    If MODIFY is zero, don't modify any rtl in place,\n    just return zero or nonzero for failure / success.  */\n-\n rtx\n replace_n_hard_rtx (rtx x, rtx *replacements, int n_replacements, int modify)\n {\n@@ -13002,7 +12925,7 @@ sh_gen_truncate (enum machine_mode mode, rtx x, int need_sign_ext)\n   return gen_rtx_fmt_e (code, mode, x);\n }\n \n-/* called via for_each_rtx after reload, to clean up truncates of\n+/* Called via for_each_rtx after reload, to clean up truncates of\n    registers that span multiple actual hard registers.  */\n int\n shmedia_cleanup_truncate (rtx *p, void *n_changes)\n@@ -13026,9 +12949,9 @@ shmedia_cleanup_truncate (rtx *p, void *n_changes)\n /* Load and store depend on the highpart of the address.  However,\n    set_attr_alternative does not give well-defined results before reload,\n    so we must look at the rtl ourselves to see if any of the feeding\n-   registers is used in a memref.  */\n+   registers is used in a memref.\n \n-/* Called by sh_contains_memref_p via for_each_rtx.  */\n+   Called by sh_contains_memref_p via for_each_rtx.  */\n static int\n sh_contains_memref_p_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n {\n@@ -13105,7 +13028,6 @@ shmedia_prepare_call_address (rtx fnaddr, int is_sibcall)\n }\n \n /* Implement TARGET_PREFERRED_RELOAD_CLASS.  */\n-\n static reg_class_t\n sh_preferred_reload_class (rtx x, reg_class_t rclass)\n {\n@@ -13120,7 +13042,6 @@ sh_preferred_reload_class (rtx x, reg_class_t rclass)\n }\n \n /* Implement TARGET_SECONDARY_RELOAD.  */\n-\n static reg_class_t\n sh_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \t\t     enum machine_mode mode, secondary_reload_info *sri)\n@@ -13161,11 +13082,10 @@ sh_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \t    abort ();\n \t  }\n       if (rclass == FPUL_REGS\n-          && ((REG_P (x)\n-               && (REGNO (x) == MACL_REG || REGNO (x) == MACH_REG\n-                   || REGNO (x) == T_REG))\n-              || GET_CODE (x) == PLUS))\n-        return GENERAL_REGS;\n+\t  && ((REG_P (x) && (REGNO (x) == MACL_REG || REGNO (x) == MACH_REG\n+\t\t\t     || REGNO (x) == T_REG))\n+\t      || GET_CODE (x) == PLUS))\n+\treturn GENERAL_REGS;\n       if (rclass == FPUL_REGS && immediate_operand (x, mode))\n \t{\n \t  if (satisfies_constraint_I08 (x) || fp_zero_operand (x))\n@@ -13176,25 +13096,25 @@ sh_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \t  return NO_REGS;\n \t}\n       if (rclass == FPSCR_REGS\n-          && ((REG_P (x) && REGNO (x) >= FIRST_PSEUDO_REGISTER)\n-              || (MEM_P (x) && GET_CODE (XEXP (x, 0)) == PLUS)))\n+\t  && ((REG_P (x) && REGNO (x) >= FIRST_PSEUDO_REGISTER)\n+\t      || (MEM_P (x) && GET_CODE (XEXP (x, 0)) == PLUS)))\n         return GENERAL_REGS;\n       if (REGCLASS_HAS_FP_REG (rclass)\n-          && TARGET_SHMEDIA\n-          && immediate_operand (x, mode)\n-          && x != CONST0_RTX (GET_MODE (x))\n-          && GET_MODE (x) != V4SFmode)\n-        return GENERAL_REGS;\n+\t  && TARGET_SHMEDIA\n+\t  && immediate_operand (x, mode)\n+\t  && x != CONST0_RTX (GET_MODE (x))\n+\t  && GET_MODE (x) != V4SFmode)\n+\treturn GENERAL_REGS;\n       if ((mode == QImode || mode == HImode)\n-          && TARGET_SHMEDIA && inqhi_operand (x, mode))\n+\t  && TARGET_SHMEDIA && inqhi_operand (x, mode))\n \t{\n \t  sri->icode = ((mode == QImode)\n \t\t\t? CODE_FOR_reload_inqi : CODE_FOR_reload_inhi);\n \t  return NO_REGS;\n \t}\n       if (TARGET_SHMEDIA && rclass == GENERAL_REGS\n-          && (GET_CODE (x) == LABEL_REF || PIC_ADDR_P (x)))\n-        return TARGET_REGS;\n+\t  && (GET_CODE (x) == LABEL_REF || PIC_ADDR_P (x)))\n+\treturn TARGET_REGS;\n     } /* end of input-only processing.  */\n \n   if (((REGCLASS_HAS_FP_REG (rclass)\n@@ -13210,12 +13130,12 @@ sh_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n     return FPUL_REGS;\n   if ((rclass == FPUL_REGS\n        || (REGCLASS_HAS_FP_REG (rclass)\n-           && ! TARGET_SHMEDIA && mode == SImode))\n+\t   && ! TARGET_SHMEDIA && mode == SImode))\n       && (MEM_P (x)\n-          || (REG_P (x)\n-              && (REGNO (x) >= FIRST_PSEUDO_REGISTER\n-                  || REGNO (x) == T_REG\n-                  || system_reg_operand (x, VOIDmode)))))\n+\t  || (REG_P (x)\n+\t      && (REGNO (x) >= FIRST_PSEUDO_REGISTER\n+\t\t  || REGNO (x) == T_REG\n+\t\t  || system_reg_operand (x, VOIDmode)))))\n     {\n       if (rclass == FPUL_REGS)\n \treturn GENERAL_REGS;\n@@ -13315,7 +13235,6 @@ sh_conditional_register_usage (void)\n /* Implement TARGET_LEGITIMATE_CONSTANT_P\n \n    can_store_by_pieces constructs VOIDmode CONST_DOUBLEs.  */\n-\n static bool\n sh_legitimate_constant_p (enum machine_mode mode, rtx x)\n {\n@@ -13339,7 +13258,6 @@ sh_init_sync_libfuncs (void)\n \n /* Return true if it is appropriate to emit `ret' instructions in the\n    body of a function.  */\n-\n bool\n sh_can_use_simple_return_p (void)\n {"}, {"sha": "ecd6c17e553cc57bdd18564b6c70430f6cdf420f", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 87, "deletions": 116, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "patch": "@@ -129,35 +129,35 @@ extern int code_for_indirect_jump_scratch;\n #define TARGET_DIVIDE_CALL_FP (sh_div_strategy == SH_DIV_CALL_FP)\n #define TARGET_DIVIDE_CALL_TABLE (sh_div_strategy == SH_DIV_CALL_TABLE)\n \n-#define SELECT_SH1               (MASK_SH1)\n-#define SELECT_SH2               (MASK_SH2 | SELECT_SH1)\n-#define SELECT_SH2E              (MASK_SH_E | MASK_SH2 | MASK_SH1 \\\n+#define SELECT_SH1\t\t (MASK_SH1)\n+#define SELECT_SH2\t\t (MASK_SH2 | SELECT_SH1)\n+#define SELECT_SH2E\t\t (MASK_SH_E | MASK_SH2 | MASK_SH1 \\\n \t\t\t\t  | MASK_FPU_SINGLE)\n-#define SELECT_SH2A              (MASK_SH_E | MASK_HARD_SH2A \\\n+#define SELECT_SH2A\t\t (MASK_SH_E | MASK_HARD_SH2A \\\n \t\t\t\t  | MASK_HARD_SH2A_DOUBLE \\\n \t\t\t\t  | MASK_SH2 | MASK_SH1)\n-#define SELECT_SH2A_NOFPU        (MASK_HARD_SH2A | MASK_SH2 | MASK_SH1)\n+#define SELECT_SH2A_NOFPU\t (MASK_HARD_SH2A | MASK_SH2 | MASK_SH1)\n #define SELECT_SH2A_SINGLE_ONLY  (MASK_SH_E | MASK_HARD_SH2A | MASK_SH2 \\\n \t\t\t\t  | MASK_SH1 | MASK_FPU_SINGLE)\n-#define SELECT_SH2A_SINGLE       (MASK_SH_E | MASK_HARD_SH2A \\\n+#define SELECT_SH2A_SINGLE\t (MASK_SH_E | MASK_HARD_SH2A \\\n \t\t\t\t  | MASK_FPU_SINGLE | MASK_HARD_SH2A_DOUBLE \\\n \t\t\t\t  | MASK_SH2 | MASK_SH1)\n-#define SELECT_SH3               (MASK_SH3 | SELECT_SH2)\n-#define SELECT_SH3E              (MASK_SH_E | MASK_FPU_SINGLE | SELECT_SH3)\n-#define SELECT_SH4_NOFPU         (MASK_HARD_SH4 | SELECT_SH3)\n-#define SELECT_SH4_SINGLE_ONLY   (MASK_HARD_SH4 | SELECT_SH3E)\n-#define SELECT_SH4               (MASK_SH4 | MASK_SH_E | MASK_HARD_SH4 \\\n+#define SELECT_SH3\t\t (MASK_SH3 | SELECT_SH2)\n+#define SELECT_SH3E\t\t (MASK_SH_E | MASK_FPU_SINGLE | SELECT_SH3)\n+#define SELECT_SH4_NOFPU\t (MASK_HARD_SH4 | SELECT_SH3)\n+#define SELECT_SH4_SINGLE_ONLY\t (MASK_HARD_SH4 | SELECT_SH3E)\n+#define SELECT_SH4\t\t (MASK_SH4 | MASK_SH_E | MASK_HARD_SH4 \\\n \t\t\t\t  | SELECT_SH3)\n-#define SELECT_SH4_SINGLE        (MASK_FPU_SINGLE | SELECT_SH4)\n-#define SELECT_SH4A_NOFPU        (MASK_SH4A | SELECT_SH4_NOFPU)\n+#define SELECT_SH4_SINGLE\t (MASK_FPU_SINGLE | SELECT_SH4)\n+#define SELECT_SH4A_NOFPU\t (MASK_SH4A | SELECT_SH4_NOFPU)\n #define SELECT_SH4A_SINGLE_ONLY  (MASK_SH4A | SELECT_SH4_SINGLE_ONLY)\n-#define SELECT_SH4A              (MASK_SH4A | SELECT_SH4)\n-#define SELECT_SH4A_SINGLE       (MASK_SH4A | SELECT_SH4_SINGLE)\n-#define SELECT_SH5_64MEDIA       (MASK_SH5 | MASK_SH4)\n+#define SELECT_SH4A\t\t (MASK_SH4A | SELECT_SH4)\n+#define SELECT_SH4A_SINGLE\t (MASK_SH4A | SELECT_SH4_SINGLE)\n+#define SELECT_SH5_64MEDIA\t (MASK_SH5 | MASK_SH4)\n #define SELECT_SH5_64MEDIA_NOFPU (MASK_SH5)\n-#define SELECT_SH5_32MEDIA       (MASK_SH5 | MASK_SH4 | MASK_SH_E)\n+#define SELECT_SH5_32MEDIA\t (MASK_SH5 | MASK_SH4 | MASK_SH_E)\n #define SELECT_SH5_32MEDIA_NOFPU (MASK_SH5 | MASK_SH_E)\n-#define SELECT_SH5_COMPACT       (MASK_SH5 | MASK_SH4 | SELECT_SH3E)\n+#define SELECT_SH5_COMPACT\t (MASK_SH5 | MASK_SH4 | SELECT_SH3E)\n #define SELECT_SH5_COMPACT_NOFPU (MASK_SH5 | SELECT_SH3)\n \n #if SUPPORT_SH1\n@@ -404,7 +404,6 @@ extern enum sh_divide_strategy_e sh_div_strategy;\n \n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.  */\n-\n #define BITS_BIG_ENDIAN  0\n \n /* Define this if most significant byte of a word is the lowest numbered.  */\n@@ -537,15 +536,15 @@ extern enum sh_divide_strategy_e sh_div_strategy;\n \n /* Register allocation for the Renesas calling convention:\n \n-        r0\t\targ return\n-\tr1..r3          scratch\n+\tr0\t\targ return\n+\tr1..r3\t\tscratch\n \tr4..r7\t\targs in\n \tr8..r13\t\tcall saved\n \tr14\t\tframe pointer/call saved\n \tr15\t\tstack pointer\n \tap\t\targ pointer (doesn't really exist, always eliminated)\n \tpr\t\tsubroutine return address\n-\tt               t bit\n+\tt\t\tt bit\n \tmach\t\tmultiply/accumulate result, high part\n \tmacl\t\tmultiply/accumulate result, low part.\n \tfpul\t\tfp/int communication register\n@@ -559,7 +558,7 @@ extern enum sh_divide_strategy_e sh_div_strategy;\n extern char sh_register_names[][MAX_REGISTER_NAME_LENGTH + 1];\n \n #define SH_REGISTER_NAMES_INITIALIZER\t\t\t\t\t\\\n-{\t\t\t\t                   \t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n   \"r0\",   \"r1\",   \"r2\",   \"r3\",   \"r4\",   \"r5\",   \"r6\",   \"r7\", \t\\\n   \"r8\",   \"r9\",   \"r10\",  \"r11\",  \"r12\",  \"r13\",  \"r14\",  \"r15\",\t\\\n   \"r16\",  \"r17\",  \"r18\",  \"r19\",  \"r20\",  \"r21\",  \"r22\",  \"r23\",\t\\\n@@ -661,12 +660,11 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n #define LAST_TARGET_REG  (FIRST_TARGET_REG + (TARGET_SHMEDIA ? 7 : -1))\n \n /* Registers that can be accessed through bank0 or bank1 depending on sr.md.  */\n-\n #define FIRST_BANKED_REG R0_REG\n #define LAST_BANKED_REG R7_REG\n \n-#define BANKED_REGISTER_P(REGNO)                       \\\n-  IN_RANGE ((REGNO),                                   \\\n+#define BANKED_REGISTER_P(REGNO) \\\n+  IN_RANGE ((REGNO), \\\n \t    (unsigned HOST_WIDE_INT) FIRST_BANKED_REG, \\\n \t    (unsigned HOST_WIDE_INT) LAST_BANKED_REG)\n \n@@ -676,7 +674,7 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n \t    (unsigned HOST_WIDE_INT) LAST_GENERAL_REG)\n \n #define GENERAL_OR_AP_REGISTER_P(REGNO) \\\n-  (GENERAL_REGISTER_P (REGNO) || ((REGNO) == AP_REG)\t\\\n+  (GENERAL_REGISTER_P (REGNO) || ((REGNO) == AP_REG) \\\n    || ((REGNO) == FRAME_POINTER_REGNUM))\n \n #define FP_REGISTER_P(REGNO) \\\n@@ -730,9 +728,8 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n \n    Mach register is fixed 'cause it's only 10 bits wide for SH1.\n    It is 32 bits wide for SH2.  */\n-\n-#define FIXED_REGISTERS  \t\t\t\t\t\t\\\n-{\t\t\t\t                   \t\t\t\\\n+#define FIXED_REGISTERS\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n /* Regular registers.  */\t\t\t\t\t\t\\\n   0,      0,      0,      0,      0,      0,      0,      0,\t\t\\\n   0,      0,      0,      0,      0,      0,      0,      1,\t\t\\\n@@ -770,9 +767,8 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n    The latter must include the registers where values are returned\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.  */\n-\n-#define CALL_USED_REGISTERS  \t\t\t\t\t\t\\\n-{\t\t\t\t                   \t\t\t\\\n+#define CALL_USED_REGISTERS\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n /* Regular registers.  */\t\t\t\t\t\t\\\n   1,      1,      1,      1,      1,      1,      1,      1,\t\t\\\n   /* R8 and R9 are call-clobbered on SH5, but not on earlier SH ABIs.\t\\\n@@ -817,7 +813,7 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n   (TARGET_SHMEDIA32 \\\n    && GET_MODE_SIZE (MODE) > 4 \\\n    && (((REGNO) >= FIRST_GENERAL_REG + 10 \\\n-        && (REGNO) <= FIRST_GENERAL_REG + 15) \\\n+\t&& (REGNO) <= FIRST_GENERAL_REG + 15) \\\n        || TARGET_REGISTER_P (REGNO) \\\n        || (REGNO) == PR_MEDIA_REG))\n \n@@ -827,7 +823,6 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n    but can be less for certain modes in special long registers.\n \n    On the SH all but the XD regs are UNITS_PER_WORD bits wide.  */\n-\n #define HARD_REGNO_NREGS(REGNO, MODE) \\\n    (XD_REGISTER_P (REGNO) \\\n     ? ((GET_MODE_SIZE (MODE) + (2*UNITS_PER_WORD - 1)) / (2*UNITS_PER_WORD)) \\\n@@ -836,8 +831,7 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n     : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\\\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\\\n   sh_hard_regno_mode_ok ((REGNO), (MODE))\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n@@ -847,7 +841,6 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n    That's the case for xd registers: we don't hold SFmode values in\n    them, so we can't tie an SFmode pseudos with one in another\n    floating-point mode.  */\n-\n #define MODES_TIEABLE_P(MODE1, MODE2) \\\n   ((MODE1) == (MODE2) \\\n    || (TARGET_SHMEDIA \\\n@@ -860,7 +853,6 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n \n /* A C expression that is nonzero if hard register NEW_REG can be\n    considered for use as a rename register for OLD_REG register */\n-\n #define HARD_REGNO_RENAME_OK(OLD_REG, NEW_REG) \\\n    sh_hard_regno_rename_ok (OLD_REG, NEW_REG)\n \n@@ -896,22 +888,21 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n    pointer register.  Secondly, the argument pointer register can always be\n    eliminated; it is replaced with either the stack or frame pointer.\n    Third, there is the return address pointer, which can also be replaced\n-   with either the stack or the frame pointer.  */\n+   with either the stack or the frame pointer.\n \n-/* This is an array of structures.  Each structure initializes one pair\n+   This is an array of structures.  Each structure initializes one pair\n    of eliminable registers.  The \"from\" register number is given first,\n    followed by \"to\".  Eliminations of the same \"from\" register are listed\n-   in order of preference.  */\n+   in order of preference.\n \n-/* If you add any registers here that are not actually hard registers,\n+   If you add any registers here that are not actually hard registers,\n    and that have any alternative of elimination that doesn't always\n    apply, you need to amend calc_live_regs to exclude it, because\n    reload spills all eliminable registers where it sees an\n    can_eliminate == 0 entry, thus making them 'live' .\n    If you add any hard registers that can be eliminated in different\n    ways, you have to patch reload to spill them only when all alternatives\n    of elimination fail.  */\n-\n #define ELIMINABLE_REGS\t\t\t\t\t\t\\\n {{ HARD_FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n  { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\t\\\n@@ -923,7 +914,6 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n \n /* Define the offset between two registers, one to be eliminated, and the other\n    its replacement, at the start of a routine.  */\n-\n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n   OFFSET = initial_elimination_offset ((FROM), (TO))\n \n@@ -936,7 +926,6 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n /* Don't default to pcc-struct-return, because we have already specified\n    exactly how to return structures in the TARGET_RETURN_IN_MEMORY\n    target hook.  */\n-\n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n #define SHMEDIA_REGS_STACK_ADJUST() \\\n@@ -964,21 +953,21 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n    in a smaller-numbered class.\n \n    For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n+   class that represents their union.\n \n-/* The SH has two sorts of general registers, R0 and the rest.  R0 can\n+   The SH has two sorts of general registers, R0 and the rest.  R0 can\n    be used as the destination of some of the arithmetic ops. There are\n    also some special purpose registers; the T bit register, the\n-   Procedure Return Register and the Multiply Accumulate Registers.  */\n-/* Place GENERAL_REGS after FPUL_REGS so that it will be preferred by\n+   Procedure Return Register and the Multiply Accumulate Registers.\n+\n+   Place GENERAL_REGS after FPUL_REGS so that it will be preferred by\n    reg_class_subunion.  We don't want to have an actual union class\n    of these, because it would only be used when both classes are calculated\n    to give the same cost, but there is only one FPUL register.\n    Besides, regclass fails to notice the different REGISTER_MOVE_COSTS\n    applying to the actual instruction alternative considered.  E.g., the\n    y/r alternative of movsi_ie is considered to have no more cost that\n    the r/r alternative, which is patently untrue.  */\n-\n enum reg_class\n {\n   NO_REGS,\n@@ -1030,7 +1019,6 @@ enum reg_class\n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n-\n #define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n /* NO_REGS:  */\t\t\t\t\t\t\t\t\\\n@@ -1055,7 +1043,7 @@ enum reg_class\n   { 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000 },\t\\\n /* FP_REGS:  */\t\t\t\t\t\t\t\t\\\n   { 0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0x00000000 },\t\\\n-/* DF_HI_REGS:  Initialized in TARGET_CONDITIONAL_REGISTER_USAGE.  */\t\t\\\n+/* DF_HI_REGS:  Initialized in TARGET_CONDITIONAL_REGISTER_USAGE.  */\t\\\n   { 0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0x0000ff00 },\t\\\n /* DF_REGS:  */\t\t\t\t\t\t\t\t\\\n   { 0x00000000, 0x00000000, 0xffffffff, 0xffffffff, 0x0000ff00 },\t\\\n@@ -1075,7 +1063,6 @@ enum reg_class\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n-\n extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n #define REGNO_REG_CLASS(REGNO) regno_reg_class[(REGNO)]\n \n@@ -1155,23 +1142,22 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n      : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* If defined, gives a class of registers that cannot be used as the\n-   operand of a SUBREG that changes the mode of the object illegally.  */\n-/* ??? We need to renumber the internal numbers for the frnn registers\n+   operand of a SUBREG that changes the mode of the object illegally.\n+   ??? We need to renumber the internal numbers for the frnn registers\n    when in little endian in order to allow mode size changes.  */\n-\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \t\t\t    \\\n+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\\n   sh_cannot_change_mode_class (FROM, TO, CLASS)\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n /* Define the number of registers that can hold parameters.\n    These macros are used only in other macro definitions below.  */\n-\n #define NPARM_REGS(MODE) \\\n   (TARGET_FPU_ANY && (MODE) == SFmode \\\n    ? (TARGET_SH5 ? 12 : 8) \\\n-   : (TARGET_SH4 || TARGET_SH2A_DOUBLE) && (GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n-\t\t    || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT) \\\n+   : (TARGET_SH4 || TARGET_SH2A_DOUBLE) \\\n+     && (GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n+\t || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT) \\\n    ? (TARGET_SH5 ? 12 : 8) \\\n    : (TARGET_SH5 ? 8 : 4))\n \n@@ -1215,9 +1201,9 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n /* Some subroutine macros specific to this machine.  */\n \n #define BASE_RETURN_VALUE_REG(MODE) \\\n-  ((TARGET_FPU_ANY && ((MODE) == SFmode))\t\t\t\\\n+  ((TARGET_FPU_ANY && ((MODE) == SFmode))\t\t\\\n    ? FIRST_FP_RET_REG\t\t\t\t\t\\\n-   : TARGET_FPU_ANY && (MODE) == SCmode\t\t\\\n+   : TARGET_FPU_ANY && (MODE) == SCmode\t\t\t\\\n    ? FIRST_FP_RET_REG\t\t\t\t\t\\\n    : (TARGET_FPU_DOUBLE\t\t\t\t\t\\\n       && ((MODE) == DFmode || (MODE) == SFmode\t\t\\\n@@ -1239,7 +1225,7 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n #define FUNCTION_ARG_REGNO_P(REGNO) \\\n   (((unsigned) (REGNO) >= (unsigned) FIRST_PARM_REG\t\t\t\\\n     && (unsigned) (REGNO) < (unsigned) (FIRST_PARM_REG + NPARM_REGS (SImode)))\\\n-   || (TARGET_FPU_ANY                                                   \\\n+   || (TARGET_FPU_ANY\t\t\t\t\t\t\t\\\n        && (unsigned) (REGNO) >= (unsigned) FIRST_FP_PARM_REG\t\t\\\n        && (unsigned) (REGNO) < (unsigned) (FIRST_FP_PARM_REG\t\t\\\n \t\t\t\t\t   + NPARM_REGS (SFmode))))\n@@ -1254,7 +1240,6 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n    of arguments scanned so far (including the invisible argument,\n    if any, which holds the structure-value-address).\n    Thus NARGREGS or more means all following args should go on the stack.  */\n-\n enum sh_arg_class { SH_ARG_INT = 0, SH_ARG_FLOAT = 1 };\n struct sh_args {\n     int arg_count[2];\n@@ -1380,14 +1365,14 @@ struct sh_args {\n \n    The SH doesn't care about double alignment, so we only\n    round doubles to even regs when asked to explicitly.  */\n-\n #define ROUND_REG(CUM, MODE) \\\n-   (((TARGET_ALIGN_DOUBLE\t\t\t\t\t\\\n-      || ((TARGET_SH4 || TARGET_SH2A_DOUBLE) && ((MODE) == DFmode || (MODE) == DCmode)\t\\\n-\t  && (CUM).arg_count[(int) SH_ARG_FLOAT] < NPARM_REGS (MODE)))\\\n-     && GET_MODE_UNIT_SIZE ((MODE)) > UNITS_PER_WORD)\t\t\\\n-    ? ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)]\t\t\\\n-       + ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)] & 1))\t\\\n+   (((TARGET_ALIGN_DOUBLE\t\t\t\t\t\t\\\n+      || ((TARGET_SH4 || TARGET_SH2A_DOUBLE) \t\t\t\t\\\n+\t  && ((MODE) == DFmode || (MODE) == DCmode)\t\t\t\\\n+\t  && (CUM).arg_count[(int) SH_ARG_FLOAT] < NPARM_REGS (MODE)))\t\\\n+     && GET_MODE_UNIT_SIZE ((MODE)) > UNITS_PER_WORD)\t\t\t\\\n+    ? ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)]\t\t\t\\\n+       + ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)] & 1))\t\t\\\n     : (CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)])\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n@@ -1398,16 +1383,15 @@ struct sh_args {\n    the same reg for a given argument class.\n \n    For TARGET_HITACHI, the structure value pointer is passed in memory.  */\n-\n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \\\n-  sh_init_cumulative_args (& (CUM), (FNTYPE), (LIBNAME), (FNDECL), (N_NAMED_ARGS), VOIDmode)\n+  sh_init_cumulative_args (& (CUM), (FNTYPE), (LIBNAME), (FNDECL),\\\n+\t\t\t   (N_NAMED_ARGS), VOIDmode)\n \n #define INIT_CUMULATIVE_LIBCALL_ARGS(CUM, MODE, LIBNAME) \\\n   sh_init_cumulative_args (& (CUM), NULL_TREE, (LIBNAME), NULL_TREE, 0, (MODE))\n \n /* Return boolean indicating arg of mode MODE will be passed in a reg.\n    This macro is only used in this file.  */\n-\n #define PASS_IN_REG_P(CUM, MODE, TYPE) \\\n   (((TYPE) == 0 \\\n     || (! TREE_ADDRESSABLE ((TYPE)) \\\n@@ -1441,7 +1425,7 @@ struct sh_args {\n    foo (double); a: fr5,fr4\n    foo (float a, float b); a: fr5 b: fr4\n    foo (__complex float a); a.real fr4 a.imag: fr5 - for consistency,\n-                            this should be the other way round...\n+\t\t\t    this should be the other way round...\n    foo (float a, __complex float b); a: fr5 b.real: fr4 b.imag: fr7  */\n #define FUNCTION_ARG_SCmode_WART 1\n \n@@ -1524,7 +1508,6 @@ struct sh_args {\n    We use two .aligns, so as to make sure that both the .long is aligned\n    on a 4 byte boundary, and that the .long is a fixed distance (2 bytes)\n    from the trapa instruction.  */\n-\n #define FUNCTION_PROFILER(STREAM,LABELNO)\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n   if (TARGET_SHMEDIA)\t\t\t\t\t\t\\\n@@ -1545,22 +1528,20 @@ struct sh_args {\n /* Define this macro if the code for function profiling should come\n    before the function prologue.  Normally, the profiling code comes\n    after.  */\n-\n #define PROFILE_BEFORE_PROLOGUE\n \n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in\n    functions that have frame pointers.\n    No definition is equivalent to always zero.  */\n-\n #define EXIT_IGNORE_STACK 1\n \n /*\n    On the SH, the trampoline looks like\n-   2 0002 D202     \t   \tmov.l\tl2,r2\n-   1 0000 D301     \t\tmov.l\tl1,r3\n-   3 0004 422B     \t\tjmp\t@r2\n-   4 0006 0009     \t\tnop\n+   2 0002 D202\t\t\tmov.l\tl2,r2\n+   1 0000 D301\t\t\tmov.l\tl1,r3\n+   3 0004 422B\t\t\tjmp\t@r2\n+   4 0006 0009\t\t\tnop\n    5 0008 00000000 \tl1:  \t.long   area\n    6 000c 00000000 \tl2:\t.long   function  */\n \n@@ -1577,7 +1558,6 @@ struct sh_args {\n    address for the frame COUNT steps up from the current frame.\n    FRAMEADDR is already the frame pointer of the COUNT frame, so we\n    can ignore COUNT.  */\n-\n #define RETURN_ADDR_RTX(COUNT, FRAME)\t\\\n   (((COUNT) == 0) ? sh_get_pr_initial_val () : NULL_RTX)\n \n@@ -1594,11 +1574,11 @@ struct sh_args {\n #define HAVE_PRE_DECREMENT   TARGET_SH1\n \n #define USE_LOAD_POST_INCREMENT(mode)    ((mode == SImode || mode == DImode) \\\n-                                           ? 0 : TARGET_SH1)\n+\t\t\t\t\t  ? 0 : TARGET_SH1)\n #define USE_LOAD_PRE_DECREMENT(mode)     0\n #define USE_STORE_POST_INCREMENT(mode)   0\n #define USE_STORE_PRE_DECREMENT(mode)    ((mode == SImode || mode == DImode) \\\n-                                           ? 0 : TARGET_SH1)\n+\t\t\t\t\t  ? 0 : TARGET_SH1)\n \n #define MOVE_BY_PIECES_P(SIZE, ALIGN) \\\n   (move_by_pieces_ninsns (SIZE, ALIGN, MOVE_MAX_PIECES + 1) \\\n@@ -1618,7 +1598,6 @@ struct sh_args {\n    Since they use reg_renumber, they are safe only once reg_renumber\n    has been allocated, which happens in reginfo.c during register\n    allocation.  */\n-\n #define REGNO_OK_FOR_BASE_P(REGNO) \\\n   (GENERAL_OR_AP_REGISTER_P (REGNO) \\\n    || GENERAL_OR_AP_REGISTER_P (reg_renumber[(REGNO)]))\n@@ -1630,11 +1609,9 @@ struct sh_args {\n \n /* Maximum number of registers that can appear in a valid memory\n    address.  */\n-\n #define MAX_REGS_PER_ADDRESS 2\n \n /* Recognize any constant value that is a valid address.  */\n-\n #define CONSTANT_ADDRESS_P(X)\t(GET_CODE (X) == LABEL_REF)\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n@@ -1661,7 +1638,7 @@ struct sh_args {\n \n /* Macros for extra constraints.  */\n \n-#define IS_PC_RELATIVE_LOAD_ADDR_P(OP)                          \t\\\n+#define IS_PC_RELATIVE_LOAD_ADDR_P(OP)\t\t\t\t\t\\\n   ((GET_CODE ((OP)) == LABEL_REF)\t\t\t\t\t\\\n    || (GET_CODE ((OP)) == CONST\t\t\t\t\t\t\\\n        && GET_CODE (XEXP ((OP), 0)) == PLUS\t\t\t\t\\\n@@ -1670,7 +1647,7 @@ struct sh_args {\n \n #define IS_NON_EXPLICIT_CONSTANT_P(OP)\t\t\t\t\t\\\n   (CONSTANT_P (OP)\t\t\t\t\t\t\t\\\n-   && !CONST_INT_P (OP)\t\t\t\t\t\\\n+   && !CONST_INT_P (OP)\t\t\t\t\t\t\t\\\n    && GET_CODE (OP) != CONST_DOUBLE\t\t\t\t\t\\\n    && (!flag_pic\t\t\t\t\t\t\t\\\n        || (LEGITIMATE_PIC_OPERAND_P (OP)\t\t\t\t\\\n@@ -1699,7 +1676,7 @@ struct sh_args {\n   (GET_CODE (OP) == CONST \\\n    && (UNSPEC_GOTOFF_P (XEXP ((OP), 0)) \\\n        || (GET_CODE (XEXP ((OP), 0)) == PLUS \\\n-           && UNSPEC_GOTOFF_P (XEXP (XEXP ((OP), 0), 0)) \\\n+\t   && UNSPEC_GOTOFF_P (XEXP (XEXP ((OP), 0), 0)) \\\n \t   && CONST_INT_P (XEXP (XEXP ((OP), 0), 1)))))\n \n #define PIC_ADDR_P(OP) \\\n@@ -1766,7 +1743,6 @@ struct sh_args {\n /* A C compound statement that attempts to replace X, which is an address\n    that needs reloading, with a valid memory address for an operand of\n    mode MODE.  WIN is a C statement label elsewhere in the code.  */\n-\n #define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     if (sh_legitimize_reload_address (&(X), (MODE), (OPNUM), (TYPE)))\t\\\n@@ -1796,7 +1772,8 @@ struct sh_args {\n \n /* Since the SH2e has only `float' support, it is desirable to make all\n    floating point types equivalent to `float'.  */\n-#define DOUBLE_TYPE_SIZE ((TARGET_SH2E && ! TARGET_SH4 && ! TARGET_SH2A_DOUBLE) ? 32 : 64)\n+#define DOUBLE_TYPE_SIZE ((TARGET_SH2E && ! TARGET_SH4 && ! TARGET_SH2A_DOUBLE)\\\n+\t\t\t  ? 32 : 64)\n \n /* 'char' is signed by default.  */\n #define DEFAULT_SIGNED_CHAR  1\n@@ -1831,9 +1808,9 @@ struct sh_args {\n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should\n    be the code that says which one of the two operations is implicitly\n-   done, UNKNOWN if none.  */\n-/* For SHmedia, we can truncate to QImode easier using zero extension.  */\n-/* FP registers can load SImode values, but don't implicitly sign-extend\n+   done, UNKNOWN if none.\n+   For SHmedia, we can truncate to QImode easier using zero extension.\n+   FP registers can load SImode values, but don't implicitly sign-extend\n    them to DImode.  */\n #define LOAD_EXTEND_OP(MODE) \\\n  (((MODE) == QImode  && TARGET_SHMEDIA) ? ZERO_EXTEND \\\n@@ -1901,14 +1878,14 @@ struct sh_args {\n    in particular.  */\n \n #define INSN_SETS_ARE_DELAYED(X) \t\t\\\n-  ((NONJUMP_INSN_P (X)\t\t\t\\\n+  ((NONJUMP_INSN_P (X)\t\t\t\t\\\n     && GET_CODE (PATTERN (X)) != SEQUENCE\t\\\n     && GET_CODE (PATTERN (X)) != USE\t\t\\\n     && GET_CODE (PATTERN (X)) != CLOBBER\t\\\n     && get_attr_is_sfunc (X)))\n \n #define INSN_REFERENCES_ARE_DELAYED(X) \t\t\\\n-  ((NONJUMP_INSN_P (X)\t\t\t\\\n+  ((NONJUMP_INSN_P (X)\t\t\t\t\\\n     && GET_CODE (PATTERN (X)) != SEQUENCE\t\\\n     && GET_CODE (PATTERN (X)) != USE\t\t\\\n     && GET_CODE (PATTERN (X)) != CLOBBER\t\\\n@@ -1936,7 +1913,6 @@ struct sh_args {\n /* If SECONDARY*_RELOAD_CLASS says something about the src/dst pair, regclass\n    uses this information.  Hence, the general register <-> floating point\n    register information here is not used for SFmode.  */\n-\n #define REGCLASS_HAS_GENERAL_REG(CLASS) \\\n   ((CLASS) == GENERAL_REGS || (CLASS) == R0_REGS || (CLASS) == NON_SP_REGS \\\n     || (! TARGET_SHMEDIA && (CLASS) == SIBCALL_REGS))\n@@ -1966,9 +1942,10 @@ struct sh_args {\n #define SET_ASM_OP\t\t\"\\t.set\\t\"\n \n /* How to change between sections.  */\n-\n-#define TEXT_SECTION_ASM_OP  \t\t(TARGET_SHMEDIA32 ? \"\\t.section\\t.text..SHmedia32,\\\"ax\\\"\" : \"\\t.text\")\n-#define DATA_SECTION_ASM_OP  \t\t\"\\t.data\"\n+#define TEXT_SECTION_ASM_OP\t(TARGET_SHMEDIA32 \\\n+\t\t\t\t? \"\\t.section\\t.text..SHmedia32,\\\"ax\\\"\" \\\n+\t\t\t\t: \"\\t.text\")\n+#define DATA_SECTION_ASM_OP\t\"\\t.data\"\n \n #if defined CRT_BEGIN || defined CRT_END\n /* Arrange for TEXT_SECTION_ASM_OP to be a compile-time constant.  */\n@@ -2060,7 +2037,7 @@ struct sh_args {\n \t     (unsigned HOST_WIDE_INT) FIRST_GENERAL_REG, \\\n \t     FIRST_GENERAL_REG + (TARGET_SH5 ? 63U :15U)) \\\n    ? ((unsigned) (REGNO) - FIRST_GENERAL_REG) \\\n-  : ((int) (REGNO) >= FIRST_FP_REG \\\n+   : ((int) (REGNO) >= FIRST_FP_REG \\\n      && ((int) (REGNO) \\\n \t <= (FIRST_FP_REG + \\\n \t     ((TARGET_SH5 && TARGET_FPU_ANY) ? 63 : TARGET_SH2E ? 15 : -1)))) \\\n@@ -2110,11 +2087,10 @@ struct sh_args {\n /* Globalizing directive for a label.  */\n #define GLOBAL_ASM_OP \"\\t.global\\t\"\n \n-/* #define ASM_OUTPUT_CASE_END(STREAM,NUM,TABLE)\t    */\n+/* #define ASM_OUTPUT_CASE_END(STREAM,NUM,TABLE)  */\n \n /* Output a relative address table.  */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,BODY,VALUE,REL)  \t\t\\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,BODY,VALUE,REL)\t\t\t\\\n   switch (GET_MODE (BODY))\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n     case SImode:\t\t\t\t\t\t\t\\\n@@ -2149,7 +2125,6 @@ struct sh_args {\n     }\n \n /* Output an absolute table element.  */\n-\n #define ASM_OUTPUT_ADDR_VEC_ELT(STREAM,VALUE)  \t\t\t\t\\\n   if (! optimize || TARGET_BIGTABLE)\t\t\t\t\t\\\n     asm_fprintf ((STREAM), \"\\t.long\\t%LL%d\\n\", (VALUE)); \t\t\\\n@@ -2167,7 +2142,6 @@ struct sh_args {\n    The contents of this vector are what will be used to convert the insn\n    template into assembler code, so you can change the assembler output\n    by changing the contents of the vector.  */\n-\n #define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) \\\n   final_prescan_insn ((INSN), (OPVEC), (NOPERANDS))\n \n@@ -2177,7 +2151,6 @@ extern rtx sh_compare_op1;\n \n /* Which processor to schedule for.  The elements of the enumeration must\n    match exactly the cpu attribute in the sh.md file.  */\n-\n enum processor_type {\n   PROCESSOR_SH1,\n   PROCESSOR_SH2,\n@@ -2216,14 +2189,12 @@ extern tree sh_deferred_function_attributes;\n extern tree *sh_deferred_function_attributes_tail;\n \n /* Set when processing a function with interrupt attribute.  */\n-\n extern int current_function_interrupt;\n \n \f\n /* Instructions with unfilled delay slots take up an\n    extra two bytes for the nop in the delay slot.\n    sh-dsp parallel processing insns are four bytes long.  */\n-\n #define ADJUST_INSN_LENGTH(X, LENGTH)\t\t\t\t\\\n   (LENGTH) += sh_insn_length_adjustment (X);\n \f\n@@ -2266,8 +2237,8 @@ extern int current_function_interrupt;\n #define MODE_EXIT(ENTITY) \\\n   (sh_cfun_attr_renesas_p () ? FP_MODE_NONE : NORMAL_MODE (ENTITY))\n \n-#define EPILOGUE_USES(REGNO)       ((TARGET_SH2E || TARGET_SH4)\t\t\\\n-\t\t\t\t    && (REGNO) == FPSCR_REG)\n+#define EPILOGUE_USES(REGNO) ((TARGET_SH2E || TARGET_SH4) \\\n+\t\t\t      && (REGNO) == FPSCR_REG)\n \n #define MODE_NEEDED(ENTITY, INSN)\t\t\t\t\t\\\n   (recog_memoized (INSN) >= 0\t\t\t\t\t\t\\\n@@ -2277,8 +2248,8 @@ extern int current_function_interrupt;\n #define MODE_AFTER(ENTITY, MODE, INSN)\t\t\\\n      (TARGET_HITACHI\t\t\t\t\\\n       && recog_memoized (INSN) >= 0\t\t\\\n-      && get_attr_fp_set (INSN) != FP_SET_NONE  \\\n-      ? (int) get_attr_fp_set (INSN)            \\\n+      && get_attr_fp_set (INSN) != FP_SET_NONE\t\\\n+      ? (int) get_attr_fp_set (INSN)\t\t\\\n       : (MODE))\n \n #define MODE_PRIORITY_TO_MODE(ENTITY, N) \\"}, {"sha": "75b102c3fa7472f29f6d285aa669cfee713572f6", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 276, "deletions": 270, "changes": 546, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "patch": "@@ -195,7 +195,7 @@\n ;; Indicate if the default fpu mode is single precision.\n (define_attr \"fpu_single\" \"yes,no\"\n   (const (if_then_else (symbol_ref \"TARGET_FPU_SINGLE\")\n-                         (const_string \"yes\") (const_string \"no\"))))\n+\t\t       (const_string \"yes\") (const_string \"no\"))))\n \n (define_attr \"fmovd\" \"yes,no\"\n   (const (if_then_else (symbol_ref \"TARGET_FMOVD\")\n@@ -282,7 +282,16 @@\n ;; nil\t\tno-op move, will be deleted.\n \n (define_attr \"type\"\n- \"mt_group,cbranch,jump,jump_ind,arith,arith3,arith3b,dyn_shift,load,load_si,fload,store,fstore,move,movi8,fmove,smpy,dmpy,return,pload,prset,pstore,prget,pcload,pcload_si,pcfload,rte,sfunc,call,fp,fpscr_toggle,fdiv,ftrc_s,dfp_arith,dfp_mul,fp_cmp,dfp_cmp,dfp_conv,dfdiv,gp_fpul,fpul_gp,mac_gp,gp_mac,mac_mem,mem_mac,mem_fpscr,gp_fpscr,cwb,movua,fsrra,fsca,tls_load,arith_media,cbranch_media,cmp_media,dfdiv_media,dfmul_media,dfparith_media,dfpconv_media,dmpy_media,fcmp_media,fdiv_media,fload_media,fmove_media,fparith_media,fpconv_media,fstore_media,gettr_media,invalidate_line_media,jump_media,load_media,pt_media,ptabs_media,store_media,mcmp_media,mac_media,d2mpy_media,atrans_media,ustore_media,nil,other\"\n+ \"mt_group,cbranch,jump,jump_ind,arith,arith3,arith3b,dyn_shift,load,load_si,\n+  fload,store,fstore,move,movi8,fmove,smpy,dmpy,return,pload,prset,pstore,\n+  prget,pcload,pcload_si,pcfload,rte,sfunc,call,fp,fpscr_toggle,fdiv,ftrc_s,\n+  dfp_arith,dfp_mul,fp_cmp,dfp_cmp,dfp_conv,dfdiv,gp_fpul,fpul_gp,mac_gp,\n+  gp_mac,mac_mem,mem_mac,mem_fpscr,gp_fpscr,cwb,movua,fsrra,fsca,tls_load,\n+  arith_media,cbranch_media,cmp_media,dfdiv_media,dfmul_media,dfparith_media,\n+  dfpconv_media,dmpy_media,fcmp_media,fdiv_media,fload_media,fmove_media,\n+  fparith_media,fpconv_media,fstore_media,gettr_media,invalidate_line_media,\n+  jump_media,load_media,pt_media,ptabs_media,store_media,mcmp_media,mac_media,\n+  d2mpy_media,atrans_media,ustore_media,nil,other\"\n   (const_string \"other\"))\n \n ;; We define a new attribute namely \"insn_class\".We use\n@@ -294,23 +303,25 @@\n ;;\n ;; ls_group      SH4 \"ls\" group instructions.\n ;;\n-\n (define_attr \"insn_class\"\n   \"mt_group,ex_group,ls_group,br_group,fe_group,co_group,none\"\n   (cond [(eq_attr \"type\" \"move,mt_group\") (const_string \"mt_group\")\n-         (eq_attr \"type\" \"movi8,arith,dyn_shift\") (const_string \"ex_group\")\n-\t (eq_attr \"type\" \"fmove,load,pcload,load_si,pcload_si,fload,pcfload,store,fstore,gp_fpul,fpul_gp\") (const_string \"ls_group\")\n+\t (eq_attr \"type\" \"movi8,arith,dyn_shift\") (const_string \"ex_group\")\n+\t (eq_attr \"type\" \"fmove,load,pcload,load_si,pcload_si,fload,pcfload,\n+\t\t\t  store,fstore,gp_fpul,fpul_gp\") (const_string \"ls_group\")\n \t (eq_attr \"type\" \"cbranch,jump\") (const_string \"br_group\")\n \t (eq_attr \"type\" \"fp,fp_cmp,fdiv,ftrc_s,dfp_arith,dfp_mul,dfp_conv,dfdiv\")\n \t   (const_string \"fe_group\")\n-\t (eq_attr \"type\" \"jump_ind,smpy,dmpy,mac_gp,return,pload,prset,pstore,prget,rte,sfunc,call,dfp_cmp,mem_fpscr,gp_fpscr,cwb,gp_mac,mac_mem,mem_mac\") (const_string \"co_group\")]\n+\t (eq_attr \"type\" \"jump_ind,smpy,dmpy,mac_gp,return,pload,prset,pstore,\n+\t\t\t  prget,rte,sfunc,call,dfp_cmp,mem_fpscr,gp_fpscr,cwb,\n+\t\t\t  gp_mac,mac_mem,mem_mac\") (const_string \"co_group\")]\n \t(const_string \"none\")))\n+\n ;; nil are zero instructions, and arith3 / arith3b are multiple instructions,\n ;; so these do not belong in an insn group, although they are modeled\n ;; with their own define_insn_reservations.\n \n ;; Indicate what precision must be selected in fpscr for this insn, if any.\n-\n (define_attr \"fp_mode\" \"single,double,none\" (const_string \"none\"))\n \n ;; Indicate if the fpu mode is set by this instruction\n@@ -355,7 +366,7 @@\n \t (const_string \"no\")\n \t (leu (plus (minus (match_dup 0) (pc)) (const_int 252)) (const_int 508))\n \t (const_string \"yes\")\n-         ] (const_string \"no\")))\n+\t ] (const_string \"no\")))\n \n (define_attr \"med_branch_p\" \"no,yes\"\n   (cond [(leu (plus (minus (match_dup 0) (pc)) (const_int 990))\n@@ -405,14 +416,14 @@\n \t (const_string \"yes\")\n \t ] (const_string \"no\")))\n \n-; An unconditional jump in the range -4092..4098 can be 2 bytes long.\n-; For wider ranges, we need a combination of a code and a data part.\n-; If we can get a scratch register for a long range jump, the code\n-; part can be 4 bytes long; otherwise, it must be 8 bytes long.\n-; If the jump is in the range -32764..32770, the data part can be 2 bytes\n-; long; otherwise, it must be 6 bytes long.\n+;; An unconditional jump in the range -4092..4098 can be 2 bytes long.\n+;; For wider ranges, we need a combination of a code and a data part.\n+;; If we can get a scratch register for a long range jump, the code\n+;; part can be 4 bytes long; otherwise, it must be 8 bytes long.\n+;; If the jump is in the range -32764..32770, the data part can be 2 bytes\n+;; long; otherwise, it must be 6 bytes long.\n \n-; All other instructions are two bytes long by default.\n+;; All other instructions are two bytes long by default.\n \n ;; ??? This should use something like *branch_p (minus (match_dup 0) (pc)),\n ;; but getattrtab doesn't understand this.\n@@ -434,14 +445,16 @@\n \t (cond [(eq_attr \"med_branch_p\" \"yes\")\n \t\t(const_int 2)\n \t\t(and (match_test \"prev_nonnote_insn (insn)\")\n-\t\t     (and (eq (symbol_ref \"GET_CODE (prev_nonnote_insn (insn))\")\t\t\t      (symbol_ref \"INSN\"))\n-\t\t\t  (eq (symbol_ref \"INSN_CODE (prev_nonnote_insn (insn))\")\t\t\t      (symbol_ref \"code_for_indirect_jump_scratch\"))))\n-                (cond [(eq_attr \"braf_branch_p\" \"yes\")\n-                       (const_int 6)\n-                       (not (match_test \"flag_pic\"))\n-                       (const_int 10)\n-                       (match_test \"TARGET_SH2\")\n-                       (const_int 10)] (const_int 18))\n+\t\t     (and (eq (symbol_ref \"GET_CODE (prev_nonnote_insn (insn))\")\n+\t\t\t      (symbol_ref \"INSN\"))\n+\t\t\t  (eq (symbol_ref \"INSN_CODE (prev_nonnote_insn (insn))\")\n+\t\t\t      (symbol_ref \"code_for_indirect_jump_scratch\"))))\n+\t\t(cond [(eq_attr \"braf_branch_p\" \"yes\")\n+\t\t       (const_int 6)\n+\t\t       (not (match_test \"flag_pic\"))\n+\t\t       (const_int 10)\n+\t\t       (match_test \"TARGET_SH2\")\n+\t\t       (const_int 10)] (const_int 18))\n \t\t(eq_attr \"braf_branch_p\" \"yes\")\n \t\t(const_int 10)\n ;; ??? using pc is not computed transitively.\n@@ -596,7 +609,6 @@\n ;; Usual TST #imm, R0 patterns for SI, HI and QI\n ;; This is usually used for bit patterns other than contiguous bits \n ;; and single bits.\n-\n (define_insn \"tstsi_t\"\n   [(set (reg:SI T_REG)\n \t(eq:SI (and:SI (match_operand:SI 0 \"logical_operand\" \"%z,r\")\n@@ -632,7 +644,6 @@\n \n ;; Test low QI subreg against zero.\n ;; This avoids unnecessary zero extension before the test.\n-\n (define_insn \"*tstqi_t_zero\"\n   [(set (reg:SI T_REG)\n \t(eq:SI (match_operand:QI 0 \"logical_operand\" \"z\") (const_int 0)))]\n@@ -667,7 +678,6 @@\n   [(set_attr \"type\" \"mt_group\")])\n \n ;; Extract LSB, negate and store in T bit.\n-\n (define_insn \"tstsi_t_and_not\"\n   [(set (reg:SI T_REG)\n \t (and:SI (not:SI (match_operand:SI 0 \"logical_operand\" \"z\"))\n@@ -677,13 +687,12 @@\n   [(set_attr \"type\" \"mt_group\")])\n \n ;; Extract contiguous bits and compare them against zero.\n-\n (define_insn \"tstsi_t_zero_extract_eq\"\n   [(set (reg:SI T_REG)\n \t(eq:SI (zero_extract:SI (match_operand 0 \"logical_operand\" \"z\")\n-\t\t(match_operand:SI 1 \"const_int_operand\")\n-\t\t(match_operand:SI 2 \"const_int_operand\"))\n-         (const_int 0)))]\n+\t\t\t\t(match_operand:SI 1 \"const_int_operand\")\n+\t\t\t\t(match_operand:SI 2 \"const_int_operand\"))\n+\t       (const_int 0)))]\n   \"TARGET_SH1\n    && CONST_OK_FOR_K08 (ZERO_EXTRACT_ANDMASK (operands[1], operands[2]))\"\n {\n@@ -693,15 +702,15 @@\n   [(set_attr \"type\" \"mt_group\")])\n \n ;; This split is required when testing bits in a QI subreg.\n-\n (define_split\n   [(set (reg:SI T_REG)\n-   (eq:SI (if_then_else:SI (zero_extract:SI\n-\t\t\t    (match_operand 0 \"logical_operand\" \"\")\n-\t\t\t    (match_operand 1 \"const_int_operand\")\n-\t\t\t    (match_operand 2 \"const_int_operand\"))\n-\t\t\t   (match_operand 3 \"const_int_operand\")\n-\t\t\t   (const_int 0))\n+\t(eq:SI\n+\t  (if_then_else:SI\n+\t    (zero_extract:SI (match_operand 0 \"logical_operand\")\n+\t\t\t     (match_operand 1 \"const_int_operand\")\n+\t\t\t     (match_operand 2 \"const_int_operand\"))\n+\t    (match_operand 3 \"const_int_operand\")\n+\t    (const_int 0))\n \t  (const_int 0)))]\n   \"TARGET_SH1\n    && ZERO_EXTRACT_ANDMASK (operands[1], operands[2]) == INTVAL (operands[3])\n@@ -715,11 +724,10 @@\n \n ;; Extract single bit, negate and store it in the T bit.\n ;; Not used for SH4A.\n-\n (define_insn \"tstsi_t_zero_extract_xor\"\n   [(set (reg:SI T_REG)\n \t(zero_extract:SI (xor:SI (match_operand:SI 0 \"logical_operand\" \"z\")\n-\t\t\t  (match_operand:SI 3 \"const_int_operand\"))\n+\t\t\t\t (match_operand:SI 3 \"const_int_operand\"))\n \t\t\t (match_operand:SI 1 \"const_int_operand\")\n \t\t\t (match_operand:SI 2 \"const_int_operand\")))]\n   \"TARGET_SH1\n@@ -730,7 +738,6 @@\n \n ;; Extract single bit, negate and store it in the T bit.\n ;; Used for SH4A little endian.\n-\n (define_insn \"tstsi_t_zero_extract_subreg_xor_little\"\n   [(set (reg:SI T_REG)\n \t(zero_extract:SI\n@@ -750,7 +757,6 @@\n \n ;; Extract single bit, negate and store it in the T bit.\n ;; Used for SH4A big endian.\n-\n (define_insn \"tstsi_t_zero_extract_subreg_xor_big\"\n   [(set (reg:SI T_REG)\n \t(zero_extract:SI\n@@ -890,7 +896,6 @@\n \t\t\t      (const_int 0)))\n    (set (reg:SI T_REG) (xor:SI (reg:SI T_REG) (const_int 1)))])\n \n-\n ;; -------------------------------------------------------------------------\n ;; SImode compare and branch\n ;; -------------------------------------------------------------------------\n@@ -918,7 +923,6 @@\n ;; don't have actual comparison insns.  These patterns are used in cases\n ;; which appear after the initial cbranchsi expansion, which also does\n ;; some condition inversion.\n-\n (define_split\n   [(set (pc)\n \t(if_then_else (ne (match_operand:SI 0 \"arith_reg_operand\" \"\")\n@@ -1093,13 +1097,11 @@\n   \"TARGET_SH1\"\n   \"cmp/hi\t%1,%0\"\n   [(set_attr \"type\" \"mt_group\")])\n-\n \f\n ;; -------------------------------------------------------------------------\n ;; DImode compare and branch\n ;; -------------------------------------------------------------------------\n \n-\n ;; arith3 patterns don't work well with the sh4-300 branch prediction mechanism.\n ;; Therefore, we aim to have a set of three branches that go straight to the\n ;; destination, i.e. only one of them is taken at any one time.\n@@ -1124,13 +1126,11 @@\n \t\t\t\t\t     operands[2], operands[3]));\n       DONE;\n     }\n-\n   else if (!TARGET_CBRANCHDI4)\n     {\n       sh_emit_compare_and_branch (operands, DImode);\n       DONE;\n     }\n-\n   else\n     {\n       if (expand_cbranchdi4 (operands, LAST_AND_UNUSED_RTX_CODE))\n@@ -1139,8 +1139,8 @@\n       comparison = prepare_cbranch_operands (operands, DImode,\n \t\t\t\t\t     LAST_AND_UNUSED_RTX_CODE);\n       if (comparison != GET_CODE (operands[0]))\n-        operands[0]\n-          = gen_rtx_fmt_ee (comparison, VOIDmode, operands[1], operands[2]);\n+\toperands[0]\n+\t  = gen_rtx_fmt_ee (comparison, VOIDmode, operands[1], operands[2]);\n        operands[4] = gen_rtx_SCRATCH (SImode);\n     }\n })\n@@ -1440,7 +1440,7 @@\n       operands[1] = sh_emit_cheap_store_flag (GET_MODE (operands[0]),\n \t\t\t\t\t      GET_CODE (operands[1]),\n \t\t\t\t\t      XEXP (operands[1], 0),\n-\t                                      XEXP (operands[1], 1));\n+\t\t\t\t\t      XEXP (operands[1], 1));\n       if (!operands[1])\n \tFAIL;\n     }\n@@ -1681,7 +1681,7 @@\n       operands[1] = sh_emit_cheap_store_flag (GET_MODE (operands[0]),\n \t\t\t\t\t      GET_CODE (operands[1]),\n \t\t\t\t\t      XEXP (operands[1], 0),\n-\t                                      XEXP (operands[1], 1));\n+\t\t\t\t\t      XEXP (operands[1], 1));\n       if (!operands[1])\n \tFAIL;\n     }\n@@ -1714,7 +1714,7 @@\n   if (TARGET_SH1)\n     {\n       if (!can_create_pseudo_p () && ! arith_reg_operand (operands[2], DImode))\n-        FAIL;\n+\tFAIL;\n       operands[2] = force_reg (DImode, operands[2]);\n       emit_insn (gen_adddi3_compact (operands[0], operands[1], operands[2]));\n       DONE;\n@@ -2078,11 +2078,18 @@\n   [(set (match_dup 0) (zero_extend:SI (match_dup 1)))\n    (set (match_dup 0) (xor:SI (match_dup 0) (const_int 255)))]\n   \"\")\n-;; Convert `constant - reg' to `neg rX; add rX, #const' since this\n-;; will sometimes save one instruction.  Otherwise we might get\n-;; `mov #const, rY; sub rY,rX; mov rX, rY' if the source and dest regs\n-;; are the same.\n \n+;; Convert\n+;;\tconstant - reg\n+;; to\n+;;\tneg reg\n+;;\tadd reg, #const\n+;; since this will sometimes save one instruction.\n+;; Otherwise we might get a sequence like\n+;;\tmov #const, rY\n+;;\tsub rY, rX\n+;;\tmov rX, rY\n+;; if the source and dest regs are the same.\n (define_expand \"subsi3\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t(minus:SI (match_operand:SI 1 \"arith_operand\" \"\")\n@@ -2140,7 +2147,6 @@\n ;; there is nothing to prevent reload from using r0 to reload the address.\n ;; This reload would clobber the value in r0 we are trying to store.\n ;; If we let reload allocate r0, then this problem can never happen.\n-\n (define_insn \"udivsi3_i1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=z\")\n \t(udiv:SI (reg:SI R4_REG) (reg:SI R5_REG)))\n@@ -2678,7 +2684,6 @@\n ;; These are unspecs because we could generate an indexed addressing mode\n ;; even if -m5-32media, where INDEX_REG_CLASS == NO_REGS, and this would\n ;; confuse reload.  See PR27117.\n-\n (define_insn \"divsi_inv_qitable\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI (unspec:QI [(match_operand:DI 1 \"register_operand\" \"r\")\n@@ -3199,7 +3204,6 @@ label:\n \n ;; mulsi3 on the SH2 can be done in one instruction, on the SH1 we generate\n ;; a call to a routine which clobbers known registers.\n-\n (define_insn \"\"\n   [(set (match_operand:SI 1 \"register_operand\" \"=z\")\n \t(mult:SI (reg:SI R4_REG) (reg:SI R5_REG)))\n@@ -3525,7 +3529,6 @@ label:\n   emit_insn (gen_adddi3 (operands[0], operands[4], operands[0]));\n   DONE;\n })\n-\n \f\n ;; -------------------------------------------------------------------------\n ;; Logical operations\n@@ -5343,9 +5346,9 @@ label:\n \t      (const_string \"14\")))\n     (set_attr \"type\" \"arith\")])\n \n-;; These patterns are found in expansions of DImode shifts by 16, and\n-;; allow the xtrct instruction to be generated from C source.\n-\n+;; The xtrct_left and xtrct_right patterns are used in expansions of DImode\n+;; shifts by 16, and allow the xtrct instruction to be generated from C\n+;; source.\n (define_insn \"xtrct_left\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n         (ior:SI (ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n@@ -5552,7 +5555,6 @@ label:\n ;; Actually the instruction scheduling should decide whether to use a\n ;; zero-offset branch or not for any generic case involving a single\n ;; instruction on SH4 202.\n-\n (define_insn_and_split \"negsi_cond\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,r\")\n \t(if_then_else\n@@ -5727,7 +5729,6 @@ label:\n \t\t\t\t(const_int 65280))\n \t\t\t(and:SI (ashiftrt:SI (match_dup 1) (const_int 8))\n \t\t\t\t(const_int 255)))))])\n-\n \f\n ;; -------------------------------------------------------------------------\n ;; Zero extension instructions\n@@ -5805,9 +5806,9 @@ label:\n {\n   /* Sometimes combine fails to combine a T bit or negated T bit store to a\n      reg with a following zero extension.  In the split pass after combine,\n-     try to figure the extended reg was set.  If it originated from the T\n-     bit we can replace the zero extension with a reg move, which will be\n-     eliminated.  Notice that this also helps the *cbranch_t splitter when\n+     try to figure out how the extended reg was set.  If it originated from\n+     the T bit we can replace the zero extension with a reg move, which will\n+     be eliminated.  Notice that this also helps the *cbranch_t splitter when\n      it tries to post-combine tests and conditional branches, as it does not\n      check for zero extensions.  */\n   operands[2] = sh_try_omit_signzero_extend (operands[1], curr_insn);\n@@ -6155,7 +6156,8 @@ label:\n \tfmov.ls\t%1, %0\n \tfmov.sl\t%T1, %0\n \tfmov.s\t%T1, %0\"\n-  [(set_attr \"type\"   \"arith_media,store_media,fstore_media,fload_media,fpconv_media,fmove_media\")\n+  [(set_attr \"type\" \"arith_media,store_media,fstore_media,fload_media,\n+\t\t     fpconv_media,fmove_media\")\n    (set (attr \"highpart\")\n \t(cond [(match_test \"sh_contains_memref_p (insn)\")\n \t       (const_string \"user\")]\n@@ -6197,14 +6199,14 @@ label:\n \t(cond [(match_test \"sh_contains_memref_p (insn)\")\n \t       (const_string \"user\")]\n \t      (const_string \"extend\")))])\n+\n ;; -------------------------------------------------------------------------\n ;; Move instructions\n ;; -------------------------------------------------------------------------\n \n ;; define push and pop so it is easy for sh.c\n ;; We can't use push and pop on SHcompact because the stack must always\n ;; be 8-byte aligned.\n-\n (define_expand \"push\"\n   [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n \t(match_operand:SI 0 \"register_operand\" \"r,l,x\"))]\n@@ -6298,7 +6300,6 @@ label:\n ;; When DImode operations that use the T reg as carry/borrow are split into\n ;; individual SImode operations, the T reg is usually cleared before the\n ;; first SImode insn.\n-\n (define_insn \"clrt\"\n   [(set (reg:SI T_REG) (const_int 0))]\n   \"TARGET_SH1\"\n@@ -6460,7 +6461,8 @@ label:\n \tlds.l\t%1,%0\n \tlds.l\t%1,%0\n \tfake\t%1,%0\"\n-  [(set_attr \"type\" \"pcload_si,move,movi8,load_si,mac_gp,prget,store,mac_mem,pstore,gp_mac,prset,mem_mac,pload,pcload_si\")\n+  [(set_attr \"type\" \"pcload_si,move,movi8,load_si,mac_gp,prget,store,mac_mem,\n+\t\t     pstore,gp_mac,prset,mem_mac,pload,pcload_si\")\n    (set_attr \"length\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*\")])\n \n ;; t/r must come after r/r, lest reload will try to reload stuff like\n@@ -6502,7 +6504,9 @@ label:\n \tflds\t%1,fpul\n \tfmov\t%1,%0\n \t! move optimized away\"\n-  [(set_attr \"type\" \"pcload_si,move,movi8,move,move,load_si,mac_gp,prget,store,mac_mem,pstore,gp_mac,prset,mem_mac,pload,load,fstore,pcload_si,gp_fpul,fpul_gp,fmove,fmove,fmove,nil\")\n+  [(set_attr \"type\" \"pcload_si,move,movi8,move,move,load_si,mac_gp,prget,store,\n+\t\t     mac_mem,pstore,gp_mac,prset,mem_mac,pload,load,fstore,\n+\t\t     pcload_si,gp_fpul,fpul_gp,fmove,fmove,fmove,nil\")\n    (set_attr \"late_fp_use\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,yes,*,*,yes,*,*,*,*\")\n    (set_attr_alternative \"length\"\n      [(const_int 2)\n@@ -6535,7 +6539,8 @@ label:\n       (const_int 0)])])\n \n (define_insn \"movsi_i_lowpart\"\n-  [(set (strict_low_part (match_operand:SI 0 \"general_movdst_operand\" \"+r,r,r,r,r,r,m,r\"))\n+  [(set (strict_low_part\n+\t  (match_operand:SI 0 \"general_movdst_operand\" \"+r,r,r,r,r,r,m,r\"))\n \t(match_operand:SI 1 \"general_movsrc_operand\" \"Q,r,I08,mr,x,l,r,i\"))]\n    \"TARGET_SH1\n     && (register_operand (operands[0], SImode)\n@@ -6589,7 +6594,9 @@ label:\n \tptabs\t%1, %0\n \tgettr\t%1, %0\n \tpt\t%1, %0\"\n-  [(set_attr \"type\"   \"arith_media,arith_media,*,load_media,store_media,fload_media,fstore_media,fload_media,fpconv_media,fmove_media,ptabs_media,gettr_media,pt_media\")\n+  [(set_attr \"type\"   \"arith_media,arith_media,*,load_media,store_media,\n+\t\t       fload_media,fstore_media,fload_media,fpconv_media,\n+\t\t       fmove_media,ptabs_media,gettr_media,pt_media\")\n    (set_attr \"length\" \"4,4,8,4,4,4,4,4,4,4,4,4,12\")\n    (set (attr \"highpart\")\n \t(cond [(match_test \"sh_contains_memref_p (insn)\")\n@@ -6614,7 +6621,8 @@ label:\n \tptabs\t%1, %0\n \tgettr\t%1, %0\n \tpt\t%1, %0\"\n-  [(set_attr \"type\"   \"arith_media,arith_media,*,load_media,store_media,ptabs_media,gettr_media,pt_media\")\n+  [(set_attr \"type\" \"arith_media,arith_media,*,load_media,store_media,\n+\t\t     ptabs_media,gettr_media,pt_media\")\n    (set_attr \"length\" \"4,4,8,4,4,4,4,12\")\n    (set (attr \"highpart\")\n \t(cond [(match_test \"sh_contains_memref_p (insn)\")\n@@ -7015,7 +7023,6 @@ label:\n \n ;; If the output is a register and the input is memory or a register, we have\n ;; to be careful and see which word needs to be loaded first.\n-\n (define_split\n   [(set (match_operand:DI 0 \"general_movdst_operand\" \"\")\n \t(match_operand:DI 1 \"general_movsrc_operand\" \"\"))]\n@@ -7092,7 +7099,9 @@ label:\n \tptabs\t%1, %0\n \tgettr\t%1, %0\n \tpt\t%1, %0\"\n-  [(set_attr \"type\"   \"arith_media,arith_media,*,load_media,store_media,fload_media,fstore_media,fload_media,dfpconv_media,fmove_media,ptabs_media,gettr_media,pt_media\")\n+  [(set_attr \"type\" \"arith_media,arith_media,*,load_media,store_media,\n+\t\t     fload_media,fstore_media,fload_media,dfpconv_media,\n+\t\t     fmove_media,ptabs_media,gettr_media,pt_media\")\n    (set_attr \"length\" \"4,4,16,4,4,4,4,4,4,4,4,4,*\")])\n \n (define_insn \"*movdi_media_nofpu\"\n@@ -7110,7 +7119,8 @@ label:\n \tptabs\t%1, %0\n \tgettr\t%1, %0\n \tpt\t%1, %0\"\n-  [(set_attr \"type\"   \"arith_media,arith_media,*,load_media,store_media,ptabs_media,gettr_media,pt_media\")\n+  [(set_attr \"type\" \"arith_media,arith_media,*,load_media,store_media,\n+\t\t     ptabs_media,gettr_media,pt_media\")\n    (set_attr \"length\" \"4,4,16,4,4,4,4,*\")])\n \n (define_insn \"*movdi_media_I16\"\n@@ -7369,7 +7379,8 @@ label:\n \tfst%M0.d\t%m0, %1\n \tld%M1.q\t%m1, %0\n \tst%M0.q\t%m0, %N1\"\n-  [(set_attr \"type\" \"fmove_media,fload_media,dfpconv_media,arith_media,*,fload_media,fstore_media,load_media,store_media\")])\n+  [(set_attr \"type\" \"fmove_media,fload_media,dfpconv_media,arith_media,*,\n+\t\t     fload_media,fstore_media,load_media,store_media\")])\n \n (define_insn \"movdf_media_nofpu\"\n   [(set (match_operand:DF 0 \"general_movdst_operand\" \"=r,r,r,m\")\n@@ -7411,8 +7422,7 @@ label:\n   operands[3] = gen_rtx_REG (DImode, true_regnum (operands[0]));\n })\n \n-;; ??? This should be a define expand.\n-\n+;; FIXME: This should be a define_insn_and_split.\n (define_insn \"movdf_k\"\n   [(set (match_operand:DF 0 \"general_movdst_operand\" \"=r,r,r,m\")\n \t(match_operand:DF 1 \"general_movsrc_operand\" \"r,FQ,m,r\"))]\n@@ -7708,38 +7718,39 @@ label:\n     {\n     case REG:\n       /* This is complicated.  If the register is an arithmetic register\n-         we can just fall through to the REG+DISP case below.  Otherwise\n+\t we can just fall through to the REG+DISP case below.  Otherwise\n \t we have to use a combination of POST_INC and REG addressing...  */\n       if (! arith_reg_operand (operands[1], SFmode))\n-        {\n-          XEXP (mem2, 0) = addr = gen_rtx_POST_INC (SImode, addr);\n-          insn = emit_insn (gen_movsf_ie (reg0, mem2, operands[2]));\n-          add_reg_note (insn, REG_INC, XEXP (addr, 0));\n+\t{\n+\t  XEXP (mem2, 0) = addr = gen_rtx_POST_INC (SImode, addr);\n+\t  insn = emit_insn (gen_movsf_ie (reg0, mem2, operands[2]));\n+\t  add_reg_note (insn, REG_INC, XEXP (addr, 0));\n \t  \n \t  emit_insn (gen_movsf_ie (reg1, operands[1], operands[2]));\n \n-          /* If we have modified the stack pointer, the value that we have\n-  \t     read with post-increment might be modified by an interrupt,\n+\t  /* If we have modified the stack pointer, the value that we have\n+\t     read with post-increment might be modified by an interrupt,\n \t     so write it back.  */\n-          if (REGNO (XEXP (addr, 0)) == STACK_POINTER_REGNUM)\n+\t  if (REGNO (XEXP (addr, 0)) == STACK_POINTER_REGNUM)\n \t    emit_insn (gen_push_e (reg0));\n-          else\n-\t    emit_insn (gen_addsi3 (XEXP (operands[1], 0), XEXP (operands[1], 0), GEN_INT (-4)));\n+\t  else\n+\t    emit_insn (gen_addsi3 (XEXP (operands[1], 0), XEXP (operands[1], 0),\n+\t\t\t\t   GEN_INT (-4)));\n \t  break;\n-        }\n+\t}\n       /* Fall through.  */\n-\t \n+\n     case PLUS:\n       emit_insn (gen_movsf_ie (reg0, operands[1], operands[2]));\n       operands[1] = copy_rtx (operands[1]);\n       XEXP (operands[1], 0) = plus_constant (Pmode, addr, 4);\n       emit_insn (gen_movsf_ie (reg1, operands[1], operands[2]));\n       break;\n-      \n+\n     case POST_INC:\n       insn = emit_insn (gen_movsf_ie (reg0, operands[1], operands[2]));\n       add_reg_note (insn, REG_INC, XEXP (addr, 0));\n-    \n+\n       insn = emit_insn (gen_movsf_ie (reg1, operands[1], operands[2]));\n       add_reg_note (insn, REG_INC, XEXP (addr, 0));\n       break;\n@@ -7774,25 +7785,25 @@ label:\n     {\n     case REG:\n       /* This is complicated.  If the register is an arithmetic register\n-         we can just fall through to the REG+DISP case below.  Otherwise\n+\t we can just fall through to the REG+DISP case below.  Otherwise\n \t we have to use a combination of REG and PRE_DEC addressing...  */\n       if (! arith_reg_operand (operands[0], SFmode))\n-        {\n+\t{\n \t  emit_insn (gen_addsi3 (addr, addr, GEN_INT (4)));\n-          emit_insn (gen_movsf_ie (operands[0], reg1, operands[2]));\n+\t  emit_insn (gen_movsf_ie (operands[0], reg1, operands[2]));\n \n \t  operands[0] = copy_rtx (operands[0]);\n-          XEXP (operands[0], 0) = addr = gen_rtx_PRE_DEC (SImode, addr);\n+\t  XEXP (operands[0], 0) = addr = gen_rtx_PRE_DEC (SImode, addr);\n \t  \n-          insn = emit_insn (gen_movsf_ie (operands[0], reg0, operands[2]));\n-          add_reg_note (insn, REG_INC, XEXP (addr, 0));\n+\t  insn = emit_insn (gen_movsf_ie (operands[0], reg0, operands[2]));\n+\t  add_reg_note (insn, REG_INC, XEXP (addr, 0));\n \t  break;\n-        }\n+\t}\n       /* Fall through.  */\n-      \n+\n     case PLUS:\n       /* Since REG+DISP addressing has already been decided upon by gcc\n-         we can rely upon it having chosen an arithmetic register as the\n+\t we can rely upon it having chosen an arithmetic register as the\n \t register component of the address.  Just emit the lower numbered\n \t register first, to the lower address, then the higher numbered\n \t register to the higher address.  */\n@@ -7801,9 +7812,9 @@ label:\n       operands[0] = copy_rtx (operands[0]);\n       XEXP (operands[0], 0) = plus_constant (Pmode, addr, 4);\n \n-      emit_insn (gen_movsf_ie (operands[0], reg1, operands[2]));\t \n+      emit_insn (gen_movsf_ie (operands[0], reg1, operands[2]));\n       break;\n-      \n+\n     case PRE_DEC:\n       /* This is easy.  Output the word to go to the higher address\n          first (ie the word in the higher numbered register) then the\n@@ -7815,7 +7826,7 @@ label:\n       insn = emit_insn (gen_movsf_ie (operands[0], reg0, operands[2]));\n       add_reg_note (insn, REG_INC, XEXP (addr, 0));\n       break;\n-      \n+\n     default:\n       /* FAIL; */\n       debug_rtx (addr);\n@@ -7827,7 +7838,6 @@ label:\n \n ;; If the output is a register and the input is memory or a register, we have\n ;; to be careful and see which word needs to be loaded first.\n-\n (define_split\n   [(set (match_operand:DF 0 \"general_movdst_operand\" \"\")\n \t(match_operand:DF 1 \"general_movsrc_operand\" \"\"))]\n@@ -7912,7 +7922,6 @@ label:\n ;;\tfld%M1.p\t%m1, %0\n ;;\tfst%M0.p\t%m0, %1\"\n ;;  [(set_attr \"type\" \"*,fload_media,fstore_media\")])\n-\n (define_insn_and_split \"movv2sf_i\"\n   [(set (match_operand:V2SF 0 \"general_movdst_operand\" \"=f,rf,r,m,mf\")\n \t(match_operand:V2SF 1 \"general_operand\" \"fm,rfm?,F?,f,rfZ?\"))]\n@@ -7981,9 +7990,7 @@ label:\n   \"&& reload_completed\"\n   [(const_int 0)]\n {\n-  int i;\n-\n-  for (i = 0; i < 4/2; i++)\n+  for (int i = 0; i < 4/2; i++)\n     {\n       rtx x, y;\n \n@@ -8022,11 +8029,9 @@ label:\n   \"&& reload_completed\"\n   [(const_int 0)]\n {\n-  int i;\n-\n-  for (i = 0; i < 16/2; i++)\n+  for (int i = 0; i < 16/2; i++)\n     {\n-      rtx x,y;\n+      rtx x, y;\n \n       if (MEM_P (operands[0]))\n \tx = adjust_address (operands[0], V2SFmode,\n@@ -8177,7 +8182,8 @@ label:\n \tsts.l\t%1,%0\n \tlds.l\t%1,%0\n \t! move optimized away\"\n-  [(set_attr \"type\" \"fmove,move,fmove,fmove,pcfload,fload,fstore,pcload,load,store,fmove,fmove,load,*,fpul_gp,gp_fpul,fstore,load,nil\")\n+  [(set_attr \"type\" \"fmove,move,fmove,fmove,pcfload,fload,fstore,pcload,load,\n+\t\t     store,fmove,fmove,load,*,fpul_gp,gp_fpul,fstore,load,nil\")\n    (set_attr \"late_fp_use\" \"*,*,*,*,*,*,yes,*,*,*,*,*,*,*,yes,*,yes,*,*\")\n    (set_attr_alternative \"length\"\n      [(const_int 2)\n@@ -8446,7 +8452,7 @@ label:\n \t  operands[2] = NULL_RTX;\n \n \tbreak;\n-      }\n+    }\n \n   if (operands[2] == NULL_RTX)\n     FAIL;\n@@ -8645,12 +8651,11 @@ label:\n   [(set (pc)\n \t(if_then_else\n \t  (match_operator 3 \"equality_comparison_operator\"\n-\t    [(subreg:SI (zero_extract:DI (subreg:DI (match_operand:SI 1\n-\t\t\t\t\t\t      \"extend_reg_operand\" \"\")\n-\t\t\t\t\t\t    0)\n-\t\t\t\t\t (const_int 1)\n-\t\t\t\t\t (match_operand 2\n-\t\t\t\t\t  \"const_int_operand\" \"\")) 0)\n+\t    [(subreg:SI\n+\t       (zero_extract:DI\n+\t\t (subreg:DI (match_operand:SI 1 \"extend_reg_operand\" \"\") 0)\n+\t\t (const_int 1)\n+\t\t (match_operand 2 \"const_int_operand\" \"\")) 0)\n \t     (const_int 0)])\n \t  (match_operand 0 \"target_operand\" \"\")\n \t  (pc)))\n@@ -8670,13 +8675,12 @@ label:\n ; operand 2 is the maximum number of loop iterations\n ; operand 3 is the number of levels of enclosed loops\n ; operand 4 is the label to jump to at the top of the loop\n-\n (define_expand \"doloop_end\"\n-  [(parallel [(set (pc) (if_then_else\n-\t\t\t  (ne:SI (match_operand:SI 0 \"\" \"\")\n-\t\t\t      (const_int 1))\n-\t\t\t  (label_ref (match_operand 4 \"\" \"\"))\n-\t\t\t  (pc)))\n+  [(parallel [(set (pc)\n+\t\t   (if_then_else (ne:SI (match_operand:SI 0 \"\" \"\")\n+\t\t\t\t        (const_int 1))\n+\t\t\t\t (label_ref (match_operand 4 \"\" \"\"))\n+\t\t\t\t (pc)))\n \t      (set (match_dup 0)\n \t\t   (plus:SI (match_dup 0) (const_int -1)))\n \t      (clobber (reg:SI T_REG))])\n@@ -8691,8 +8695,8 @@ label:\n \n (define_insn_and_split \"doloop_end_split\"\n   [(set (pc)\n-\t(if_then_else (ne:SI  (match_operand:SI 2 \"arith_reg_dest\" \"0\")\n-\t\t\t  (const_int 1))\n+\t(if_then_else (ne:SI (match_operand:SI 2 \"arith_reg_dest\" \"0\")\n+\t\t\t     (const_int 1))\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))\n    (set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n@@ -8708,8 +8712,7 @@ label:\n \t\t\t   (label_ref (match_dup 1))\n \t\t\t   (pc)))]\n   \"\"\n-   [(set_attr \"type\" \"cbranch\")])\n-\n+  [(set_attr \"type\" \"cbranch\")])\n \f\n ;; ------------------------------------------------------------------------\n ;; Jump and linkage insns\n@@ -8760,8 +8763,7 @@ label:\n     {\n       if (reload_in_progress || reload_completed)\n \tFAIL;\n-      emit_jump_insn (gen_jump_media (gen_rtx_LABEL_REF (Pmode,\n-\t\t\t\t\t\t\t operands[0])));\n+      emit_jump_insn (gen_jump_media (gen_rtx_LABEL_REF (Pmode, operands[0])));\n     }\n   DONE;\n })\n@@ -8795,9 +8797,8 @@ label:\n    (set_attr \"fp_set\" \"unknown\")])\n \n ;; This is TBR relative jump instruction for SH2A architecture.\n-;; Its use is enabled assigning an attribute \"function_vector\"\n+;; Its use is enabled by assigning an attribute \"function_vector\"\n ;; and the vector number to a function during its declaration.\n-\n (define_insn \"calli_tbr_rel\"\n   [(call (mem (match_operand:SI 0 \"symbol_ref_operand\" \"\"))\n \t (match_operand 1 \"\" \"\"))\n@@ -8819,7 +8820,6 @@ label:\n    (set_attr \"fp_set\" \"unknown\")])\n \n ;; This is a pc-rel call, using bsrf, for use with PIC.\n-\n (define_insn \"calli_pcrel\"\n   [(call (mem:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n \t (match_operand 1 \"\" \"\"))\n@@ -8931,7 +8931,6 @@ label:\n ;; This is TBR relative jump instruction for SH2A architecture.\n ;; Its use is enabled by assigning an attribute \"function_vector\"\n ;; and the vector number to a function during its declaration.\n-\n (define_insn \"call_valuei_tbr_rel\"\n   [(set (match_operand 0 \"\" \"=rf\")\n \t(call (mem:SI (match_operand:SI 1 \"symbol_ref_operand\" \"\"))\n@@ -9200,13 +9199,13 @@ label:\n   if (flag_pic)\n     {\n       if (GET_CODE (func) == SYMBOL_REF && ! SYMBOL_REF_LOCAL_P (func))\n-        {\n+\t{\n \t  rtx reg = gen_reg_rtx (Pmode);\n \t  emit_insn (gen_symGOTPLT2reg (reg, func));\n \t  func = reg;\n \t}\n       else\n-        func = legitimize_pic_address (func, Pmode, 0);\n+\tfunc = legitimize_pic_address (func, Pmode, 0);\n     }\n \n   r0 = gen_rtx_REG (SImode, R0_REG);\n@@ -9798,14 +9797,14 @@ label:\n   if (flag_pic)\n     {\n       if (GET_CODE (func) == SYMBOL_REF && ! SYMBOL_REF_LOCAL_P (func))\n-        {\n-          rtx reg = gen_reg_rtx (Pmode);\n+\t{\n+\t  rtx reg = gen_reg_rtx (Pmode);\n \n \t  emit_insn (gen_symGOTPLT2reg (reg, func));\n-          func = reg;\n-        }\n+\t  func = reg;\n+\t}\n       else\n-        func = legitimize_pic_address (func, Pmode, 0);\n+\tfunc = legitimize_pic_address (func, Pmode, 0);\n     }\n \n   r0 = gen_rtx_REG (SImode, R0_REG);\n@@ -9893,7 +9892,7 @@ label:\n \t(match_operand:SI 0 \"register_operand\" \"r\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"TARGET_SH1\"\n-  \"jmp  @%0%#\"\n+  \"jmp\t@%0%#\"\n   [(set_attr \"needs_delay_slot\" \"yes\")\n    (set_attr \"type\" \"jump_ind\")])\n \n@@ -9917,19 +9916,16 @@ label:\n \n ;; Call subroutine returning any type.\n ;; ??? This probably doesn't work.\n-\n (define_expand \"untyped_call\"\n   [(parallel [(call (match_operand 0 \"\" \"\")\n \t\t    (const_int 0))\n \t      (match_operand 1 \"\" \"\")\n \t      (match_operand 2 \"\" \"\")])]\n   \"(TARGET_SH2E || TARGET_SH2A) || TARGET_SHMEDIA\"\n {\n-  int i;\n-\n   emit_call_insn (gen_call (operands[0], const0_rtx, const0_rtx));\n \n-  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+  for (int i = 0; i < XVECLEN (operands[2], 0); i++)\n     {\n       rtx set = XVECEXP (operands[2], 0, i);\n       emit_move_insn (SET_DEST (set), SET_SRC (set));\n@@ -9965,8 +9961,7 @@ label:\n ;; Load address of a label. This is only generated by the casesi expand,\n ;; and by machine_dependent_reorg (fixing up fp moves).\n ;; This must use unspec, because this only works for labels that are\n-;; within range,\n-\n+;; within range.\n (define_insn \"mova\"\n   [(set (reg:SI R0_REG)\n \t(unspec:SI [(label_ref (match_operand 0 \"\" \"\"))] UNSPEC_MOVA))]\n@@ -10036,7 +10031,6 @@ label:\n \n ;; A helper for GOTaddr2picreg to finish up the initialization of the\n ;; PIC register.\n-\n (define_expand \"vxworks_picreg\"\n   [(set (reg:SI PIC_REG)\n \t(const:SI (unspec:SI [(match_operand:SI 0 \"\" \"\")] UNSPEC_PIC)))\n@@ -10096,7 +10090,6 @@ label:\n \n ;; op0 = op1 + r12 but hide it before reload completed.  See the comment\n ;; in symGOT_load expand.\n-\n (define_insn_and_split \"chk_guard_add\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n \t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"r\")\n@@ -10262,8 +10255,11 @@ label:\n   \"\"\n   \"\")\n \n+;; -------------------------------------------------------------------------\n ;; TLS code generation.\n-;; ??? this should be a define_insn_and_split\n+\n+;; FIXME: The multi-insn asm blocks should be converted to use\n+;; define_insn_and_split.\n ;; See the thread [PATCH/RFA] SH TLS support on gcc-patches\n ;; <http://gcc.gnu.org/ml/gcc-patches/2003-02/msg01898.html>\n ;; for details.\n@@ -10588,12 +10584,11 @@ label:\n ;;------------------------------------------------------------------------------\n ;; case instruction for switch statements.\n \n-;; Operand 0 is index\n+;; operand 0 is index\n ;; operand 1 is the minimum bound\n ;; operand 2 is the maximum bound - minimum bound + 1\n ;; operand 3 is CODE_LABEL for the table;\n ;; operand 4 is the CODE_LABEL to go to if index out of range.\n-\n (define_expand \"casesi\"\n   [(match_operand:SI 0 \"arith_reg_operand\" \"\")\n    (match_operand:SI 1 \"arith_reg_operand\" \"\")\n@@ -10617,7 +10612,8 @@ label:\n       operands[2] = convert_modes (DImode, SImode, operands[2], 1);\n \n       test = gen_rtx_GT (VOIDmode, operands[1], operands[0]);\n-      emit_jump_insn (gen_cbranchdi4 (test, operands[1], operands[0], operands[4]));\n+      emit_jump_insn (gen_cbranchdi4 (test, operands[1], operands[0],\n+\t\t\t\t      operands[4]));\n       emit_move_insn (reg, gen_rtx_MINUS (DImode, operands[0], operands[1]));\n       test = gen_rtx_GTU (VOIDmode, reg, operands[2]);\n       emit_jump_insn (gen_cbranchdi4 (test, reg, operands[2], operands[4]));\n@@ -10675,7 +10671,6 @@ label:\n ;; ??? reload might clobber r0 if we use it explicitly in the RTL before\n ;; reload; using a R0_REGS pseudo reg is likely to give poor code.\n ;; So we keep the use of r0 hidden in a R0_REGS clobber until after reload.\n-\n (define_insn \"casesi_worker_0\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"0,r\")\n@@ -10823,8 +10818,8 @@ label:\n (define_insn \"casesi_load_media\"\n   [(set (match_operand 0 \"any_arith_reg_dest\" \"=r\")\n \t(mem (unspec [(match_operand:DI 1 \"arith_reg_operand\" \"r\")\n-\t\t\t (match_operand:DI 2 \"arith_reg_operand\" \"r\")\n-\t\t\t (label_ref:DI (match_operand 3 \"\" \"\"))] UNSPEC_CASESI)))]\n+\t\t      (match_operand:DI 2 \"arith_reg_operand\" \"r\")\n+\t\t      (label_ref:DI (match_operand 3 \"\" \"\"))] UNSPEC_CASESI)))]\n   \"TARGET_SHMEDIA\"\n {\n   rtx diff_vec = PATTERN (next_real_insn (operands[3]));\n@@ -11263,7 +11258,6 @@ label:\n ;; around it.  On the other hand, if a function returns the complement of\n ;; a previous comparison result in the T bit, the xor #1,r0 approach might\n ;; lead to better code.\n-\n (define_expand \"movnegt\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n \t(xor:SI (match_operand:SI 1 \"t_reg_operand\" \"\") (const_int 1)))]\n@@ -11419,7 +11413,7 @@ label:\n \n ;; Store negated T bit as all zeros or ones in a reg.\n ;; Use the following sequence:\n-;; \tsubc\tRn,Rn\t! Rn = Rn - Rn - T; T = T\n+;;\tsubc\tRn,Rn\t! Rn = Rn - Rn - T; T = T\n ;;\tnot\tRn,Rn\t! Rn = 0 - Rn\n (define_split\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n@@ -11437,6 +11431,11 @@ label:\n   \"\"\n   [(const_int 0)])\n \n+;; Invert the T bit.\n+;; On SH2A we can use the nott insn.  On anything else this must be done with\n+;; multiple insns like:\n+;;\tmovt\tRn\n+;;\ttst\tRn,Rn\n (define_insn_and_split \"nott\"\n   [(set (reg:SI T_REG)\n \t(xor:SI (match_operand:SI 0 \"t_reg_operand\" \"\") (const_int 1)))]\n@@ -11500,7 +11499,9 @@ label:\n })\n \n ;; The *cset_zero patterns convert optimizations such as\n-;;\t\"if (test) x = 0;\" to \"x &= -(test == 0);\"\n+;;\t\"if (test) x = 0;\"\n+;; to\n+;;\t\"x &= -(test == 0);\"\n ;; back to conditional branch sequences if zero-displacement branches\n ;; are enabled.\n ;; FIXME: These patterns can be removed when conditional execution patterns\n@@ -11580,8 +11581,7 @@ label:\n ;; Instructions to cope with inline literal tables\n ;; -------------------------------------------------------------------------\n \n-; 2 byte integer in line\n-\n+;; 2 byte integer in line\n (define_insn \"consttable_2\"\n  [(unspec_volatile [(match_operand:SI 0 \"general_operand\" \"=g\")\n \t\t    (match_operand 1 \"\" \"\")]\n@@ -11595,8 +11595,7 @@ label:\n  [(set_attr \"length\" \"2\")\n  (set_attr \"in_delay_slot\" \"no\")])\n \n-; 4 byte integer in line\n-\n+;; 4 byte integer in line\n (define_insn \"consttable_4\"\n  [(unspec_volatile [(match_operand:SI 0 \"general_operand\" \"=g\")\n \t\t    (match_operand 1 \"\" \"\")]\n@@ -11613,8 +11612,7 @@ label:\n  [(set_attr \"length\" \"4\")\n   (set_attr \"in_delay_slot\" \"no\")])\n \n-; 8 byte integer in line\n-\n+;; 8 byte integer in line\n (define_insn \"consttable_8\"\n  [(unspec_volatile [(match_operand:SI 0 \"general_operand\" \"=g\")\n \t\t    (match_operand 1 \"\" \"\")]\n@@ -11628,8 +11626,7 @@ label:\n  [(set_attr \"length\" \"8\")\n   (set_attr \"in_delay_slot\" \"no\")])\n \n-; 4 byte floating point\n-\n+;; 4 byte floating point\n (define_insn \"consttable_sf\"\n  [(unspec_volatile [(match_operand:SF 0 \"general_operand\" \"=g\")\n \t\t    (match_operand 1 \"\" \"\")]\n@@ -11647,8 +11644,7 @@ label:\n  [(set_attr \"length\" \"4\")\n   (set_attr \"in_delay_slot\" \"no\")])\n \n-; 8 byte floating point\n-\n+;; 8 byte floating point\n (define_insn \"consttable_df\"\n  [(unspec_volatile [(match_operand:DF 0 \"general_operand\" \"=g\")\n \t\t    (match_operand 1 \"\" \"\")]\n@@ -11672,34 +11668,30 @@ label:\n ;; alignment based on the value of INSN_CURRENT_ADDRESS; the approach used\n ;; here is too conservative.\n \n-; align to a two byte boundary\n-\n+;; align to a two byte boundary\n (define_expand \"align_2\"\n  [(unspec_volatile [(const_int 1)] UNSPECV_ALIGN)]\n  \"\"\n  \"\")\n \n-; align to a four byte boundary\n+;; Align to a four byte boundary.\n ;; align_4 and align_log are instructions for the starts of loops, or\n ;; after unconditional branches, which may take up extra room.\n-\n (define_expand \"align_4\"\n  [(unspec_volatile [(const_int 2)] UNSPECV_ALIGN)]\n  \"\"\n  \"\")\n \n-; align to a cache line boundary\n-\n+;; Align to a cache line boundary.\n (define_insn \"align_log\"\n  [(unspec_volatile [(match_operand 0 \"const_int_operand\" \"\")] UNSPECV_ALIGN)]\n  \"\"\n  \"\"\n  [(set_attr \"length\" \"0\")\n   (set_attr \"in_delay_slot\" \"no\")])\n \n-; emitted at the end of the literal table, used to emit the\n-; 32bit branch labels if needed.\n-\n+;; Emitted at the end of the literal table, used to emit the\n+;; 32bit branch labels if needed.\n (define_insn \"consttable_end\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_CONST_END)]\n   \"\"\n@@ -11708,8 +11700,7 @@ label:\n }\n   [(set_attr \"in_delay_slot\" \"no\")])\n \n-; emitted at the end of the window in the literal table.\n-\n+;; Emitted at the end of the window in the literal table.\n (define_insn \"consttable_window_end\"\n   [(unspec_volatile [(match_operand 0 \"\" \"\")] UNSPECV_WINDOW_END)]\n   \"\"\n@@ -11836,7 +11827,8 @@ label:\n \tsts\tfpscr,%0\n \tsts.l\tfpscr,%0\"\n   [(set_attr \"length\" \"0,2,2,4,2,2,2,2,2\")\n-   (set_attr \"type\" \"nil,mem_fpscr,load,mem_fpscr,gp_fpscr,move,store,mac_gp,fstore\")])\n+   (set_attr \"type\" \"nil,mem_fpscr,load,mem_fpscr,gp_fpscr,move,store,\n+\t\t     mac_gp,fstore\")])\n \n (define_peephole2\n   [(set (reg:PSI FPSCR_REG)\n@@ -12158,7 +12150,8 @@ label:\n {\n   if (TARGET_SH4 || TARGET_SH2A_SINGLE)\n     {\n-      emit_sf_insn (gen_floatsisf2_i4 (operands[0], operands[1], get_fpscr_rtx ()));\n+      emit_sf_insn (gen_floatsisf2_i4 (operands[0], operands[1],\n+\t\t\t\t       get_fpscr_rtx ()));\n       DONE;\n     }\n })\n@@ -12200,7 +12193,8 @@ label:\n {\n   if (TARGET_SH4 || TARGET_SH2A_SINGLE)\n     {\n-      emit_sf_insn (gen_fix_truncsfsi2_i4 (operands[0], operands[1], get_fpscr_rtx ()));\n+      emit_sf_insn (gen_fix_truncsfsi2_i4 (operands[0], operands[1],\n+\t\t\t\t\t   get_fpscr_rtx ()));\n       DONE;\n     }\n })\n@@ -12958,8 +12952,12 @@ label:\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_mode\" \"double\")])\n \f\n-;; Bit field extract patterns.  These give better code for packed bitfields,\n-;; because they allow auto-increment addresses to be generated.\n+;; -------------------------------------------------------------------------\n+;; Bit field extract patterns.\n+;; -------------------------------------------------------------------------\n+\n+;; These give better code for packed bitfields,  because they allow\n+;; auto-increment addresses to be generated.\n \n (define_expand \"insv\"\n   [(set (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"\")\n@@ -13356,7 +13354,6 @@ label:\n   return alt[which_alternative];\n }\n   [(set_attr \"length\" \"6,6\")])\n-\n \f\n ;; -------------------------------------------------------------------------\n ;; Peepholes\n@@ -13374,8 +13371,7 @@ label:\n    && satisfies_constraint_Pso (operands[2])\n    && REGNO (operands[0]) == REGNO (operands[3])\"\n   [(set (match_dup 1)\n-        (ior:QI (match_dup 1)\n-                (match_dup 2)))]\n+        (ior:QI (match_dup 1) (match_dup 2)))]\n   \"\")\n \n ;; This matches cases where the bit in a memory location is cleared.\n@@ -13391,13 +13387,11 @@ label:\n    && satisfies_constraint_Psz (operands[2])\n    && REGNO (operands[0]) == REGNO (operands[3])\"\n   [(set (match_dup 1)\n-        (and:QI (match_dup 1)\n-                (match_dup 2)))]\n+        (and:QI (match_dup 1) (match_dup 2)))]\n   \"\")\n \n ;; This matches cases where a stack pointer increment at the start of the\n ;; epilogue combines with a stack slot read loading the return value.\n-\n (define_peephole\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t(mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")))\n@@ -13406,14 +13400,12 @@ label:\n   \"mov.l\t@%1+,%0\")\n \n ;; See the comment on the dt combiner pattern above.\n-\n (define_peephole\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(plus:SI (match_dup 0)\n \t\t (const_int -1)))\n    (set (reg:SI T_REG)\n-\t(eq:SI (match_dup 0)\n-\t       (const_int 0)))]\n+\t(eq:SI (match_dup 0) (const_int 0)))]\n   \"TARGET_SH2\"\n   \"dt\t%0\")\n \n@@ -13615,7 +13607,9 @@ label:\n }\n   [(set_attr \"length\" \"4\")])\n \n+;; -------------------------------------------------------------------------\n ;; Integer vector moves\n+;; -------------------------------------------------------------------------\n \n (define_expand \"movv8qi\"\n   [(set (match_operand:V8QI 0 \"general_movdst_operand\" \"\")\n@@ -13784,7 +13778,9 @@ label:\n    (set_attr \"length\" \"4,4,16,4,4\")\n    (set_attr \"highpart\" \"depend\")])\n \n+;; -------------------------------------------------------------------------\n ;; Multimedia Intrinsics\n+;; -------------------------------------------------------------------------\n \n (define_insn \"absv2si2\"\n   [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n@@ -13870,53 +13866,59 @@ label:\n \n (define_insn \"negcmpeqv8qi\"\n   [(set (match_operand:V8QI 0 \"arith_reg_dest\" \"=r\")\n-\t(neg:V8QI (eq:V8QI (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"%rZ\")\n-\t\t\t   (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rZ\"))))]\n+\t(neg:V8QI (eq:V8QI\n+\t\t    (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"%rZ\")\n+\t\t    (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rZ\"))))]\n   \"TARGET_SHMEDIA\"\n   \"mcmpeq.b\t%N1, %N2, %0\"\n   [(set_attr \"type\" \"mcmp_media\")\n    (set_attr \"highpart\" \"depend\")])\n \n (define_insn \"negcmpeqv2si\"\n   [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n-\t(neg:V2SI (eq:V2SI (match_operand:V2SI 1 \"arith_reg_or_0_operand\" \"%rZ\")\n-\t\t\t   (match_operand:V2SI 2 \"arith_reg_or_0_operand\" \"rZ\"))))]\n+\t(neg:V2SI (eq:V2SI\n+\t\t    (match_operand:V2SI 1 \"arith_reg_or_0_operand\" \"%rZ\")\n+\t\t    (match_operand:V2SI 2 \"arith_reg_or_0_operand\" \"rZ\"))))]\n   \"TARGET_SHMEDIA\"\n   \"mcmpeq.l\t%N1, %N2, %0\"\n   [(set_attr \"type\" \"mcmp_media\")\n    (set_attr \"highpart\" \"depend\")])\n \n (define_insn \"negcmpeqv4hi\"\n   [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n-\t(neg:V4HI (eq:V4HI (match_operand:V4HI 1 \"arith_reg_or_0_operand\" \"%rZ\")\n-\t\t\t   (match_operand:V4HI 2 \"arith_reg_or_0_operand\" \"rZ\"))))]\n+\t(neg:V4HI (eq:V4HI\n+\t\t    (match_operand:V4HI 1 \"arith_reg_or_0_operand\" \"%rZ\")\n+\t\t    (match_operand:V4HI 2 \"arith_reg_or_0_operand\" \"rZ\"))))]\n   \"TARGET_SHMEDIA\"\n   \"mcmpeq.w\t%N1, %N2, %0\"\n   [(set_attr \"type\" \"mcmp_media\")\n    (set_attr \"highpart\" \"depend\")])\n \n (define_insn \"negcmpgtuv8qi\"\n   [(set (match_operand:V8QI 0 \"arith_reg_dest\" \"=r\")\n-\t(neg:V8QI (gtu:V8QI (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"%rZ\")\n-\t\t\t    (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rZ\"))))]\n+\t(neg:V8QI (gtu:V8QI\n+\t\t    (match_operand:V8QI 1 \"arith_reg_or_0_operand\" \"%rZ\")\n+\t\t    (match_operand:V8QI 2 \"arith_reg_or_0_operand\" \"rZ\"))))]\n   \"TARGET_SHMEDIA\"\n   \"mcmpgt.ub\t%N1, %N2, %0\"\n   [(set_attr \"type\" \"mcmp_media\")\n    (set_attr \"highpart\" \"depend\")])\n \n (define_insn \"negcmpgtv2si\"\n   [(set (match_operand:V2SI 0 \"arith_reg_dest\" \"=r\")\n-\t(neg:V2SI (gt:V2SI (match_operand:V2SI 1 \"arith_reg_or_0_operand\" \"%rZ\")\n-\t\t\t   (match_operand:V2SI 2 \"arith_reg_or_0_operand\" \"rZ\"))))]\n+\t(neg:V2SI (gt:V2SI\n+\t\t    (match_operand:V2SI 1 \"arith_reg_or_0_operand\" \"%rZ\")\n+\t\t    (match_operand:V2SI 2 \"arith_reg_or_0_operand\" \"rZ\"))))]\n   \"TARGET_SHMEDIA\"\n   \"mcmpgt.l\t%N1, %N2, %0\"\n   [(set_attr \"type\" \"mcmp_media\")\n    (set_attr \"highpart\" \"depend\")])\n \n (define_insn \"negcmpgtv4hi\"\n   [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n-\t(neg:V4HI (gt:V4HI (match_operand:V4HI 1 \"arith_reg_or_0_operand\" \"%rZ\")\n-\t\t\t   (match_operand:V4HI 2 \"arith_reg_or_0_operand\" \"rZ\"))))]\n+\t(neg:V4HI (gt:V4HI\n+\t\t    (match_operand:V4HI 1 \"arith_reg_or_0_operand\" \"%rZ\")\n+\t\t    (match_operand:V4HI 2 \"arith_reg_or_0_operand\" \"rZ\"))))]\n   \"TARGET_SHMEDIA\"\n   \"mcmpgt.w\t%N1, %N2, %0\"\n   [(set_attr \"type\" \"mcmp_media\")\n@@ -13937,7 +13939,8 @@ label:\n   [(set (match_operand:V4HI 0 \"arith_reg_dest\" \"=r\")\n \t(vec_concat:V4HI\n \t (ss_truncate:V2HI (match_operand:V2SI 1 \"arith_reg_or_0_operand\" \"rZ\"))\n-\t (ss_truncate:V2HI (match_operand:V2SI 2 \"arith_reg_or_0_operand\" \"rZ\"))))]\n+\t (ss_truncate:V2HI\n+\t   (match_operand:V2SI 2 \"arith_reg_or_0_operand\" \"rZ\"))))]\n   \"TARGET_SHMEDIA\"\n   \"mcnvs.lw\t%N1, %N2, %0\"\n   [(set_attr \"type\" \"mcmp_media\")])\n@@ -13946,7 +13949,8 @@ label:\n   [(set (match_operand:V8QI 0 \"arith_reg_dest\" \"=r\")\n \t(vec_concat:V8QI\n \t (ss_truncate:V4QI (match_operand:V4HI 1 \"arith_reg_or_0_operand\" \"rZ\"))\n-\t (ss_truncate:V4QI (match_operand:V4HI 2 \"arith_reg_or_0_operand\" \"rZ\"))))]\n+\t (ss_truncate:V4QI\n+\t   (match_operand:V4HI 2 \"arith_reg_or_0_operand\" \"rZ\"))))]\n   \"TARGET_SHMEDIA\"\n   \"mcnvs.wb\t%N1, %N2, %0\"\n   [(set_attr \"type\" \"mcmp_media\")])\n@@ -13955,7 +13959,8 @@ label:\n   [(set (match_operand:V8QI 0 \"arith_reg_dest\" \"=r\")\n \t(vec_concat:V8QI\n \t (us_truncate:V4QI (match_operand:V4HI 1 \"arith_reg_or_0_operand\" \"rZ\"))\n-\t (us_truncate:V4QI (match_operand:V4HI 2 \"arith_reg_or_0_operand\" \"rZ\"))))]\n+\t (us_truncate:V4QI\n+\t   (match_operand:V4HI 2 \"arith_reg_or_0_operand\" \"rZ\"))))]\n   \"TARGET_SHMEDIA\"\n   \"mcnvs.wub\t%N1, %N2, %0\"\n   [(set_attr \"type\" \"mcmp_media\")])\n@@ -13964,8 +13969,8 @@ label:\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n \t(ior:DI (lshiftrt:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rZ\")\n \t\t\t     (match_operand:HI 3 \"mextr_bit_offset\" \"i\"))\n-\t       (ashift:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rZ\")\n-\t\t\t  (match_operand:HI 4 \"mextr_bit_offset\" \"i\"))))]\n+\t\t(ashift:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rZ\")\n+\t\t\t   (match_operand:HI 4 \"mextr_bit_offset\" \"i\"))))]\n   \"TARGET_SHMEDIA && INTVAL (operands[3]) + INTVAL (operands[4]) == 64\"\n {\n   static char templ[21];\n@@ -13979,8 +13984,8 @@ label:\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n \t(ior:DI (ashift:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rZ\")\n \t\t\t   (match_operand:HI 3 \"mextr_bit_offset\" \"i\"))\n-\t       (lshiftrt:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rZ\")\n-\t\t\t    (match_operand:HI 4 \"mextr_bit_offset\" \"i\"))))]\n+\t\t(lshiftrt:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rZ\")\n+\t\t\t     (match_operand:HI 4 \"mextr_bit_offset\" \"i\"))))]\n   \"TARGET_SHMEDIA && INTVAL (operands[3]) + INTVAL (operands[4]) == 64\"\n {\n   static char templ[21];\n@@ -14627,7 +14632,7 @@ label:\n (define_insn_and_split \"mshfhi_l_di\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r,f\")\n \t(ior:DI (lshiftrt:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rZ,f\")\n-                             (const_int 32))\n+\t\t\t     (const_int 32))\n \t\t(and:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rZ,?f\")\n \t\t\t(const_int -4294967296))))]\n   \"TARGET_SHMEDIA\"\n@@ -14651,7 +14656,7 @@ label:\n \t(ior:DI (and:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rZ\")\n \t\t\t(const_int -4294967296))\n \t\t(lshiftrt:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rZ\")\n-                             (const_int 32))))]\n+\t\t\t     (const_int 32))))]\n   \"TARGET_SHMEDIA\"\n   \"mshfhi.l\t%N2, %N1, %0\"\n   [(set_attr \"type\" \"arith_media\")])\n@@ -14679,7 +14684,7 @@ label:\n \t(ior:DI (and:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rZ\")\n \t\t\t(const_int 4294967295))\n \t\t(ashift:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rZ\")\n-                           (const_int 32))))]\n+\t\t\t   (const_int 32))))]\n \n   \"TARGET_SHMEDIA\"\n   \"mshflo.l\t%N1, %N2, %0\"\n@@ -14689,7 +14694,7 @@ label:\n (define_insn \"*mshflo_l_di_rev\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n \t(ior:DI (ashift:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rZ\")\n-                           (const_int 32))\n+\t\t\t   (const_int 32))\n \t\t(and:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rZ\")\n \t\t\t(const_int 4294967295))))]\n \n@@ -14702,7 +14707,7 @@ label:\n (define_insn_and_split \"*double_shori\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n \t(ior:DI (ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n-                           (const_int 32))\n+\t\t\t   (const_int 32))\n \t\t(match_operand:DI 2 \"const_int_operand\" \"n\")))]\n   \"TARGET_SHMEDIA\n    && ! (INTVAL (operands[2]) & ~(unsigned HOST_WIDE_INT) 0xffffffffUL)\"\n@@ -14718,14 +14723,12 @@ label:\n }\n   [(set_attr \"highpart\" \"ignore\")])\n \n-\n (define_insn \"*mshflo_l_di_x\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n \t(ior:DI (zero_extend:DI (match_operand:SI 1 \"extend_reg_or_0_operand\"\n \t\t\t\t \"rZ\"))\n \t\t(ashift:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rZ\")\n-                           (const_int 32))))]\n-\n+\t\t\t   (const_int 32))))]\n   \"TARGET_SHMEDIA\"\n   \"mshflo.l\t%N1, %N2, %0\"\n   [(set_attr \"type\" \"arith_media\")\n@@ -14736,7 +14739,6 @@ label:\n ;;\t(vec_concat:V2SF (match_operand:SF 1 \"register_operand\" \"rZ,0,f\")\n \t(vec_concat:V2SF (match_operand:SF 1 \"register_operand\" \"rZ,f,f\")\n \t\t\t (match_operand:SF 2 \"register_operand\" \"rZ,f,f\")))]\n-\n   \"TARGET_SHMEDIA\"\n   \"@\n \tmshflo.l\t%N1, %N2, %0\n@@ -14756,9 +14758,9 @@ label:\n (define_insn \"*mshflo_l_di_x_rev\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n \t(ior:DI (ashift:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rZ\")\n-                           (const_int 32))\n-\t\t(zero_extend:DI (match_operand:SI 2 \"extend_reg_or_0_operand\" \"rZ\"))))]\n-\n+\t\t\t   (const_int 32))\n+\t\t(zero_extend:DI\n+\t\t  (match_operand:SI 2 \"extend_reg_or_0_operand\" \"rZ\"))))]\n   \"TARGET_SHMEDIA\"\n   \"mshflo.l\t%N2, %N1, %0\"\n   [(set_attr \"type\" \"arith_media\")\n@@ -14888,7 +14890,9 @@ label:\n   [(set_attr \"type\" \"mcmp_media\")\n    (set_attr \"highpart\" \"depend\")])\n \n+;; -------------------------------------------------------------------------\n ;; Floating Point Intrinsics\n+;; -------------------------------------------------------------------------\n \n (define_insn \"fcosa_s\"\n   [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"=f\")\n@@ -14993,10 +14997,9 @@ label:\n (define_insn_and_split \"*ldhi_q_comb0\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n \t(zero_extract:DI\n-\t (mem:DI (plus:SI (ior:SI (plus:SI (match_operand:SI 1\n-\t\t\t\t\t    \"register_operand\" \"r\")\n-\t\t\t\t\t   (match_operand:SI 2\n-\t\t\t\t\t    \"ua_offset\" \"I06\"))\n+\t (mem:DI (plus:SI (ior:SI (plus:SI\n+\t\t\t\t    (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t    (match_operand:SI 2 \"ua_offset\" \"I06\"))\n \t\t\t\t  (const_int 7))\n \t\t\t  (const_int -7)))\n \t (plus:SI (and:SI (match_dup 1) (const_int 7))\n@@ -15015,14 +15018,13 @@ label:\n (define_insn_and_split \"*ldhi_q_comb1\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n \t(zero_extract:DI\n-\t (mem:DI (plus:SI (ior:SI (plus:SI (match_operand:SI 1\n-\t\t\t\t\t    \"register_operand\" \"r\")\n-\t\t\t\t\t   (match_operand:SI 2\n-\t\t\t\t\t    \"ua_offset\" \"I06\"))\n+\t (mem:DI (plus:SI (ior:SI (plus:SI\n+\t\t\t\t    (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t    (match_operand:SI 2 \"ua_offset\" \"I06\"))\n \t\t\t\t  (const_int 7))\n \t\t\t  (const_int -7)))\n-\t (plus:SI (and:SI (plus:SI (match_dup 1)  (match_operand:SI 3\n-\t\t\t\t\t\t   \"ua_offset\" \"I06\"))\n+\t (plus:SI (and:SI (plus:SI (match_dup 1)\n+\t\t\t\t   (match_operand:SI 3 \"ua_offset\" \"I06\"))\n \t\t\t  (const_int 7))\n \t\t  (const_int 1))\n \t (const_int 0)))]\n@@ -15129,10 +15131,9 @@ label:\n \n (define_insn_and_split \"*sthi_q_comb0\"\n   [(set (zero_extract:DI\n-\t (mem:DI (plus:SI (ior:SI (plus:SI (match_operand:SI 0\n-\t\t\t\t\t    \"register_operand\" \"r\")\n-\t\t\t\t\t   (match_operand:SI 1 \"ua_offset\"\n-\t\t\t\t\t    \"I06\"))\n+\t (mem:DI (plus:SI (ior:SI (plus:SI\n+\t\t\t\t    (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t    (match_operand:SI 1 \"ua_offset\" \"I06\"))\n \t\t\t\t  (const_int 7))\n \t\t\t  (const_int -7)))\n \t (plus:SI (and:SI (match_dup 0) (const_int 7)) (const_int 1))\n@@ -15150,10 +15151,9 @@ label:\n \n (define_insn_and_split \"*sthi_q_comb1\"\n   [(set (zero_extract:DI\n-\t (mem:DI (plus:SI (ior:SI (plus:SI (match_operand:SI 0\n-\t\t\t\t\t    \"register_operand\" \"r\")\n-\t\t\t\t\t   (match_operand:SI 1 \"ua_offset\"\n-\t\t\t\t\t    \"I06\"))\n+\t (mem:DI (plus:SI (ior:SI (plus:SI\n+\t\t\t\t    (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t    (match_operand:SI 1 \"ua_offset\" \"I06\"))\n \t\t\t\t  (const_int 7))\n \t\t\t  (const_int -7)))\n \t (plus:SI (and:SI (plus:SI (match_dup 0)\n@@ -15219,10 +15219,10 @@ label:\n \t (mem:DI (and:SI (plus:SI (match_operand:SI 0 \"register_operand\" \"r\")\n \t\t\t\t  (match_operand:SI 1 \"ua_offset\" \"I06\"))\n \t\t\t (const_int -8)))\n-\t (minus:SI (const_int 8) (and:SI (plus:SI (match_dup 0)\n-\t\t\t\t\t\t  (match_operand:SI 2\n-\t\t\t\t\t\t   \"ua_offset\" \"I06\"))\n-\t\t\t\t\t (const_int 7)))\n+\t (minus:SI (const_int 8)\n+\t\t   (and:SI (plus:SI (match_dup 0)\n+\t\t\t\t    (match_operand:SI 2 \"ua_offset\" \"I06\"))\n+\t\t\t   (const_int 7)))\n \t (and:SI (plus:SI (match_dup 0) (match_dup 2)) (const_int 7)))\n \t(match_operand:DI 3 \"arith_reg_operand\" \"r\"))]\n   \"TARGET_SHMEDIA32 && (INTVAL (operands[1]) & 7) == INTVAL (operands[2])\"\n@@ -15411,8 +15411,8 @@ label:\n ;; implementation of __builtin_prefetch for VxWorks RTPs.\n (define_expand \"prefetch\"\n   [(prefetch (match_operand 0 \"address_operand\" \"\")\n-             (match_operand:SI 1 \"const_int_operand\" \"\")\n-             (match_operand:SI 2 \"const_int_operand\" \"\"))]\n+\t     (match_operand:SI 1 \"const_int_operand\" \"\")\n+\t     (match_operand:SI 2 \"const_int_operand\" \"\"))]\n   \"(TARGET_SH2A || TARGET_SH3 || TARGET_SH5)\n    && (TARGET_SHMEDIA || ! TARGET_VXWORKS_RTP)\")\n \n@@ -15426,12 +15426,12 @@ label:\n \n (define_insn \"*prefetch_media\"\n   [(prefetch (match_operand:QI 0 \"address_operand\" \"p\")\n-             (match_operand:SI 1 \"const_int_operand\" \"n\")\n-             (match_operand:SI 2 \"const_int_operand\" \"n\"))]\n+\t     (match_operand:SI 1 \"const_int_operand\" \"n\")\n+\t     (match_operand:SI 2 \"const_int_operand\" \"n\"))]\n   \"TARGET_SHMEDIA\"\n {\n   operands[0] = gen_rtx_MEM (QImode, operands[0]);\n-  output_asm_insn (\"ld%M0.b    %m0,r63\", operands);\n+  output_asm_insn (\"ld%M0.b\t%m0,r63\", operands);\n   return \"\";\n }\n   [(set_attr \"type\" \"other\")])\n@@ -15453,7 +15453,7 @@ label:\n       xops[0] = operands[0];\n       xops[1] = const0_rtx;\n     }\n-  output_asm_insn (\"alloco   %0, %1\", xops);\n+  output_asm_insn (\"alloco\t%0, %1\", xops);\n   return \"\";\n }\n   [(set_attr \"type\" \"other\")])\n@@ -15471,7 +15471,9 @@ label:\n     FAIL;\n })\n \n-; Stack Protector Patterns\n+;; -------------------------------------------------------------------------\n+;; Stack Protector Patterns\n+;; -------------------------------------------------------------------------\n \n (define_expand \"stack_protect_set\"\n   [(set (match_operand 0 \"memory_operand\" \"\")\n@@ -15493,7 +15495,7 @@ label:\n \n (define_insn \"stack_protect_set_si\"\n   [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n-        (unspec:SI [(match_operand:SI 1 \"memory_operand\" \"m\")] UNSPEC_SP_SET))\n+\t(unspec:SI [(match_operand:SI 1 \"memory_operand\" \"m\")] UNSPEC_SP_SET))\n    (set (match_scratch:SI 2 \"=&r\") (const_int 0))]\n   \"!TARGET_SHMEDIA\"\n {\n@@ -15506,7 +15508,7 @@ label:\n \n (define_insn \"stack_protect_set_si_media\"\n   [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n-        (unspec:SI [(match_operand:SI 1 \"memory_operand\" \"m\")] UNSPEC_SP_SET))\n+\t(unspec:SI [(match_operand:SI 1 \"memory_operand\" \"m\")] UNSPEC_SP_SET))\n    (set (match_scratch:SI 2 \"=&r\") (const_int 0))]\n   \"TARGET_SHMEDIA\"\n {\n@@ -15519,7 +15521,7 @@ label:\n \n (define_insn \"stack_protect_set_di_media\"\n   [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n-        (unspec:DI [(match_operand:DI 1 \"memory_operand\" \"m\")] UNSPEC_SP_SET))\n+\t(unspec:DI [(match_operand:DI 1 \"memory_operand\" \"m\")] UNSPEC_SP_SET))\n    (set (match_scratch:DI 2 \"=&r\") (const_int 0))]\n   \"TARGET_SHMEDIA64\"\n {\n@@ -15546,13 +15548,13 @@ label:\n \t{\n \t  emit_insn (gen_stack_protect_test_di_media (tmp, operands[0],\n \t\t\t\t\t\t      operands[1]));\n-          emit_jump_insn (gen_cbranchdi4 (test, tmp, const0_rtx, operands[2]));\n+\t  emit_jump_insn (gen_cbranchdi4 (test, tmp, const0_rtx, operands[2]));\n \t}\n       else\n \t{\n \t  emit_insn (gen_stack_protect_test_si_media (tmp, operands[0],\n \t\t\t\t\t\t      operands[1]));\n-          emit_jump_insn (gen_cbranchsi4 (test, tmp, const0_rtx, operands[2]));\n+\t  emit_jump_insn (gen_cbranchsi4 (test, tmp, const0_rtx, operands[2]));\n \t}\n     }\n   else\n@@ -15566,7 +15568,7 @@ label:\n \n (define_insn \"stack_protect_test_si\"\n   [(set (reg:SI T_REG)\n-        (unspec:SI [(match_operand:SI 0 \"memory_operand\" \"m\")\n+\t(unspec:SI [(match_operand:SI 0 \"memory_operand\" \"m\")\n \t\t    (match_operand:SI 1 \"memory_operand\" \"m\")]\n \t\t   UNSPEC_SP_TEST))\n   (set (match_scratch:SI 2 \"=&r\") (const_int 0))\n@@ -15584,7 +15586,7 @@ label:\n \n (define_insn \"stack_protect_test_si_media\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n-        (unspec:SI [(match_operand:SI 1 \"memory_operand\" \"m\")\n+\t(unspec:SI [(match_operand:SI 1 \"memory_operand\" \"m\")\n \t\t    (match_operand:SI 2 \"memory_operand\" \"m\")]\n \t\t   UNSPEC_SP_TEST))\n   (set (match_scratch:SI 3 \"=&r\") (const_int 0))]\n@@ -15600,7 +15602,7 @@ label:\n \n (define_insn \"stack_protect_test_di_media\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n-        (unspec:DI [(match_operand:DI 1 \"memory_operand\" \"m\")\n+\t(unspec:DI [(match_operand:DI 1 \"memory_operand\" \"m\")\n \t\t    (match_operand:DI 2 \"memory_operand\" \"m\")]\n \t\t   UNSPEC_SP_TEST))\n   (set (match_scratch:DI 3 \"=&r\") (const_int 0))]\n@@ -15614,4 +15616,8 @@ label:\n   [(set_attr \"type\" \"other\")\n    (set_attr \"length\" \"16\")])\n \n+;; -------------------------------------------------------------------------\n+;; Atomic operations\n+;; -------------------------------------------------------------------------\n+\n (include \"sync.md\")"}, {"sha": "05edb1b08ef5a06bf70e0075de3345922a3f04d2", "filename": "gcc/config/sh/sh4-300.md", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fsh4-300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fsh4-300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh4-300.md?ref=50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "patch": "@@ -35,26 +35,21 @@\n ;; Since SH4 is a dual issue machine,it is as if there are two\n ;; units so that any insn can be processed by either one\n ;; of the decoding unit.\n-\n (define_cpu_unit \"sh4_300_pipe_01,sh4_300_pipe_02\" \"sh4_300_inst_pipeline\")\n \n ;; The floating point units.\n-\n (define_cpu_unit \"sh4_300_fpt,sh4_300_fpu,sh4_300_fds\" \"sh4_300_fpu_pipe\")\n \n ;; integer multiplier unit\n-\n (define_cpu_unit \"sh4_300_mul\" \"sh4_300_inst_pipeline\")\n \n ;; LS unit\n-\n (define_cpu_unit \"sh4_300_ls\" \"sh4_300_inst_pipeline\")\n \n ;; The address calculator used for branch instructions.\n ;; This will be reserved after \"issue\" of branch instructions\n ;; and this is to make sure that no two branch instructions\n ;; can be issued in parallel.\n-\n (define_cpu_unit \"sh4_300_br\" \"sh4_300_inst_pipeline\")\n \n ;; ----------------------------------------------------\n@@ -85,7 +80,6 @@\n   \"sh4_300_issue+sh4_300_mul\")\n \n ;; Instructions without specific resource requirements with latency 1.\n-\n (define_insn_reservation \"sh4_300_simple_arith\" 1\n   (and (eq_attr \"pipe_model\" \"sh4_300\")\n        (eq_attr \"type\" \"mt_group,arith,dyn_shift,prset\"))\n@@ -153,7 +147,6 @@\n ;; or likely and likely not predicted, we might want to fill the delay slot.\n ;; However, there appears to be no machinery to make the compiler\n ;; recognize these scenarios.\n-\n (define_insn_reservation \"sh4_300_branch\"  1\n   (and (eq_attr \"pipe_model\" \"sh4_300\")\n        (eq_attr \"type\" \"cbranch,jump,return,jump_ind\"))\n@@ -169,8 +162,11 @@\n ;; Group:\tCO\n ;; Latency: \t1-5\n ;; Issue Rate: \t1\n-\n-;; cwb is used for the sequence ocbwb @%0; extu.w %0,%2; or %1,%2; mov.l %0,@%2\n+;; cwb is used for the sequence\n+;;\tocbwb  @%0\n+;;\textu.w %0,%2\n+;;\tor     %1,%2\n+;;\tmov.l  %0,@%2\n ;; This description is likely inexact, but this pattern should not actually\n ;; appear when compiling for sh4-300; we should use isbi instead.\n ;; If a -mtune option is added later, we should use the icache array\n@@ -197,7 +193,6 @@\n ;; since there are no instructions that contend for memory access early.\n ;; We could, of course, provide exact scheduling information for specific\n ;; sfuncs, if that should prove useful.\n-\n (define_insn_reservation \"sh4_300_call\" 16\n   (and (eq_attr \"pipe_model\" \"sh4_300\")\n        (eq_attr \"type\" \"call,sfunc\"))\n@@ -265,7 +260,6 @@\n        (eq_attr \"type\" \"dfdiv\"))\n   \"sh4_300_issue+sh4_300_fpu+sh4_300_fds,sh4_300_fds*31\")\n \n-\n ;; ??? We don't really want these for sh4-300.\n ;; this pattern itself is likely to finish in 3 cycles, but also\n ;; to disrupt branch prediction for taken branches for the following"}, {"sha": "a979d415d24b45de362baf3baa5c94cc06b7f105", "filename": "gcc/config/sh/sh4.md", "status": "modified", "additions": 5, "deletions": 37, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fsh4.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fsh4.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh4.md?ref=50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "patch": "@@ -41,35 +41,29 @@\n \n ;; Two automata are defined to reduce number of states\n ;; which a single large automaton will have. (Factoring)\n-\n (define_automaton \"inst_pipeline,fpu_pipe\")\n \n ;; This unit is basically the decode unit of the processor.\n ;; Since SH4 is a dual issue machine,it is as if there are two\n ;; units so that any insn can be processed by either one\n ;; of the decoding unit.\n-\n (define_cpu_unit \"pipe_01,pipe_02\" \"inst_pipeline\")\n \n \n ;; The fixed point arithmetic calculator(?? EX Unit).\n-\n (define_cpu_unit  \"int\" \"inst_pipeline\")\n \n ;; f1_1 and f1_2 are floating point units.Actually there is\n ;; a f1 unit which can overlap with other f1 unit but\n ;; not another F1 unit.It is as though there were two\n ;; f1 units.\n-\n (define_cpu_unit \"f1_1,f1_2\" \"fpu_pipe\")\n \n ;; The floating point units (except FS - F2 always precedes it.)\n-\n (define_cpu_unit \"F0,F1,F2,F3\" \"fpu_pipe\")\n \n ;; This is basically the MA unit of SH4\n ;; used in LOAD/STORE pipeline.\n-\n (define_cpu_unit \"memory\" \"inst_pipeline\")\n \n ;; However, there are LS group insns that don't use it, even ones that\n@@ -85,25 +79,21 @@\n \n ;; ----------------------------------------------------\n ;; This reservation is to simplify the dual issue description.\n-\n (define_reservation  \"issue\"  \"pipe_01|pipe_02\")\n \n ;; This is to express the locking of D stage.\n ;; Note that the issue of a CO group insn also effectively locks the D stage.\n-\n (define_reservation  \"d_lock\" \"pipe_01+pipe_02\")\n \n ;; Every FE instruction but fipr / ftrv starts with issue and this.\n (define_reservation \"F01\" \"F0+F1\")\n \n ;; This is to simplify description where F1,F2,FS\n ;; are used simultaneously.\n-\n (define_reservation \"fpu\" \"F1+F2\")\n \n ;; This is to highlight the fact that f1\n ;; cannot overlap with F1.\n-\n (exclusion_set  \"f1_1,f1_2\" \"F1\")\n \n (define_insn_reservation \"nil\" 0 (eq_attr \"type\" \"nil\") \"nothing\")\n@@ -113,14 +103,12 @@\n ;; for one cycle.\n \n ;; Group:\tMT\n-\n (define_insn_reservation \"reg_mov\" 0\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"move\"))\n   \"issue\")\n \n ;; Group:\tLS\n-\n (define_insn_reservation \"freg_mov\" 0\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"fmove\"))\n@@ -145,7 +133,6 @@\n ;; Group:\tMT\n ;; Latency: \t1\n ;; Issue Rate: \t1\n-\n (define_insn_reservation \"mt\" 1\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"mt_group\"))\n@@ -155,7 +142,6 @@\n ;; Group:\tEX\n ;; Latency: \t1\n ;; Issue Rate: \t1\n-\n (define_insn_reservation \"sh4_simple_arith\" 1\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"insn_class\" \"ex_group\"))\n@@ -178,7 +164,6 @@\n ;; Group:\tLS\n ;; Latency: \t2\n ;; Issue Rate: \t1\n-\n (define_insn_reservation \"sh4_load\" 2\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"load,pcload\"))\n@@ -220,7 +205,6 @@\n ;; Group:\tLS\n ;; Latency: \t1\n ;; Issue Rate: \t1\n-\n (define_insn_reservation \"sh4_gp_fpul\" 1\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"gp_fpul\"))\n@@ -230,7 +214,6 @@\n ;; Group:\tLS\n ;; Latency: \t3\n ;; Issue Rate: \t1\n-\n (define_insn_reservation \"sh4_fpul_gp\" 3\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"fpul_gp\"))\n@@ -246,7 +229,6 @@\n ;; ??? If the branch is likely, we might want to fill the delay slot;\n ;; if the branch is likely, but not very likely, should we pretend to use\n ;; a resource that CO instructions use, to get a pairable delay slot insn?\n-\n (define_insn_reservation \"sh4_branch\"  1\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"cbranch,jump\"))\n@@ -258,7 +240,6 @@\n ;; Issue Rate: \t2\n ;; ??? Scheduling happens before branch shortening, and hence jmp and braf\n ;; can't be distinguished from bra for the \"jump\" pattern.\n-\n (define_insn_reservation \"sh4_return\" 3\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"return,jump_ind\"))\n@@ -270,7 +251,6 @@\n ;; Issue Rate: \t5\n ;; this instruction can be executed in any of the pipelines\n ;; and blocks the pipeline for next 4 stages.\n-\n (define_insn_reservation \"sh4_return_from_exp\" 5\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"rte\"))\n@@ -280,8 +260,11 @@\n ;; Group:\tCO\n ;; Latency: \t1-5\n ;; Issue Rate: \t1\n-\n-;; cwb is used for the sequence ocbwb @%0; extu.w %0,%2; or %1,%2; mov.l %0,@%2\n+;; cwb is used for the sequence\n+;;\tocbwb  @%0\n+;;\textu.w %0,%2\n+;;\tor     %1,%2\n+;;\tmov.l  %0,@%2\n ;; ocbwb on its own would be \"d_lock,nothing,memory*5\"\n (define_insn_reservation \"ocbwb\"  6\n   (and (eq_attr \"pipe_model\" \"sh4\")\n@@ -298,7 +281,6 @@\n ;; or when we are doing a function call - and we don't do inter-function\n ;; scheduling.  For the function call case, it's really best that we end with\n ;; something that models an rts.\n-\n (define_insn_reservation \"sh4_lds_to_pr\" 3\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"prset\") )\n@@ -311,7 +293,6 @@\n ;; since there are no instructions that contend for memory access early.\n ;; We could, of course, provide exact scheduling information for specific\n ;; sfuncs, if that should prove useful.\n-\n (define_insn_reservation \"sh4_call\" 16\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"call,sfunc\"))\n@@ -322,7 +303,6 @@\n ;; Latency: \t3\n ;; Issue Rate: \t2\n ;; The SX unit is blocked for last 2 cycles.\n-\n (define_insn_reservation \"ldsmem_to_pr\"  3\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"pload\"))\n@@ -333,7 +313,6 @@\n ;; Latency: \t2\n ;; Issue Rate: \t2\n ;; The SX unit in second and third cycles.\n-\n (define_insn_reservation \"sts_from_pr\" 2\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"prget\"))\n@@ -343,7 +322,6 @@\n ;; Group:\tCO\n ;; Latency: \t2\n ;; Issue Rate: \t2\n-\n (define_insn_reservation \"sh4_prstore_mem\" 2\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"pstore\"))\n@@ -354,7 +332,6 @@\n ;; Latency: \t4\n ;; Issue Rate: \t1\n ;; F1 is blocked for last three cycles.\n-\n (define_insn_reservation \"fpscr_load\" 4\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"gp_fpscr\"))\n@@ -366,7 +343,6 @@\n ;; Latency to update Rn is 1 and latency to update FPSCR is 4\n ;; Issue Rate: \t1\n ;; F1 is blocked for last three cycles.\n-\n (define_insn_reservation \"fpscr_load_mem\" 4\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\"  \"mem_fpscr\"))\n@@ -377,7 +353,6 @@\n ;; Group:\tCO\n ;; Latency: \t4 / 4\n ;; Issue Rate: \t2\n-\n (define_insn_reservation \"multi\" 4\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"smpy,dmpy\"))\n@@ -387,7 +362,6 @@\n ;; Group:\tCO\n ;; Latency: \t3\n ;; Issue Rate: \t1\n-\n (define_insn_reservation \"sh4_mac_gp\" 3\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"mac_gp,gp_mac,mem_mac\"))\n@@ -399,7 +373,6 @@\n ;; Group:\tFE\n ;; Latency: \t3/4\n ;; Issue Rate: \t1\n-\n (define_insn_reservation \"fp_arith\"  3\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"fp,fp_cmp\"))\n@@ -424,7 +397,6 @@\n ;; Latency: \t12/13 (FDIV); 11/12 (FSQRT)\n ;; Issue Rate: \t1\n ;; We describe fdiv here; fsqrt is actually one cycle faster.\n-\n (define_insn_reservation \"fp_div\" 12\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"fdiv\"))\n@@ -435,7 +407,6 @@\n ;; Group:\tFE\n ;; Latency: \t(3,4)/5\n ;; Issue Rate: \t1\n-\n (define_insn_reservation \"dp_float\" 4\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"dfp_conv\"))\n@@ -445,7 +416,6 @@\n ;; Group:\tFE\n ;; Latency: \t(7,8)/9\n ;; Issue Rate: \t1\n-\n (define_insn_reservation \"fp_double_arith\" 8\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"dfp_arith,dfp_mul\"))\n@@ -455,7 +425,6 @@\n ;; Group:\tCO\n ;; Latency: \t3/5\n ;; Issue Rate: \t2\n-\n (define_insn_reservation \"fp_double_cmp\" 3\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"dfp_cmp\"))\n@@ -465,7 +434,6 @@\n ;; Group:\tFE\n ;; Latency: \t(24,25)/26\n ;; Issue Rate: \t1\n-\n (define_insn_reservation \"dp_div\" 25\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"dfdiv\"))"}, {"sha": "b6fff92916b59629846c2bdce5c34f29508068cc", "filename": "gcc/config/sh/sh4a.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fsh4a.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fsh4a.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh4a.md?ref=50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "patch": "@@ -19,7 +19,6 @@\n \n ;; The following description models the SH4A pipeline\n ;; using the DFA based scheduler.\n-\n (define_automaton \"sh4a\")\n \n (define_cpu_unit \"sh4a_ex\"   \"sh4a\")\n@@ -35,7 +34,6 @@\n (define_reservation \"ID_or\" \"sh4a_ex|sh4a_ls\")\n (define_reservation \"ID_and\" \"sh4a_ex+sh4a_ls\")\n \n-\n ;; =======================================================\n ;; Locking Descriptions\n "}, {"sha": "6b8b43e46fe0f9ea4cbca5d21c1c2ada439fc652", "filename": "gcc/config/sh/superh.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fsuperh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fsuperh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsuperh.h?ref=50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "patch": "@@ -29,7 +29,6 @@ along with GCC; see the file COPYING3.  If not see\n \n    This file is intended to override sh.h.  */\n \n-\n #ifndef _SUPERH_H\n #define _SUPERH_H\n #endif\n@@ -55,7 +54,8 @@ along with GCC; see the file COPYING3.  If not see\n #endif\n \n \n-/* This is used by the link spec if the boardspecs file is not used (for whatever reason).\n+/* This is used by the link spec if the boardspecs file is not used\n+   (for whatever reason).\n    If the boardspecs file overrides this then an alternative can be used. */\n #undef SUBTARGET_EXTRA_SPECS\n #define SUBTARGET_EXTRA_SPECS \\"}, {"sha": "cdbab0d2b05de029272b3b58ec3dc6c39fa23760", "filename": "gcc/config/sh/ushmedia.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fushmedia.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50fe8924df35f99c4eaf8b79a712dafd3beeaceb/gcc%2Fconfig%2Fsh%2Fushmedia.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fushmedia.h?ref=50fe8924df35f99c4eaf8b79a712dafd3beeaceb", "patch": "@@ -1010,15 +1010,17 @@ sh_media_FMTRXSUB_S (const void *mtrxg, const void *mtrxh, void *mtrxf)\n \n __inline__ static\n void\n-sh_media_FTRVADD_S (const void *mtrxg, const void *fvh, const void *fvi, void *fvf)\n+sh_media_FTRVADD_S (const void *mtrxg, const void *fvh, const void *fvi,\n+\t\t    void *fvf)\n {\n   sh_media_FTRV_S (mtrxg, fvh, fvf);\n   sh_media_FVADD_S (fvf, fvi, fvf);\n }\n \n __inline__ static\n void\n-sh_media_FTRVSUB_S (const void *mtrxg, const void *fvh, const void *fvi, void *fvf)\n+sh_media_FTRVSUB_S (const void *mtrxg, const void *fvh, const void *fvi,\n+\t\t    void *fvf)\n {\n   sh_media_FTRV_S (mtrxg, fvh, fvf);\n   sh_media_FVSUB_S (fvf, fvi, fvf);\n@@ -1045,7 +1047,8 @@ sh_media_FMTRXMUL_S (const void *mtrxg, const void *mtrxh, void *mtrxf)\n \n __inline__ static\n void\n-sh_media_FMTRXMULADD_S (const void *mtrxg, const void *mtrxh, const void *mtrxi, void *mtrxf)\n+sh_media_FMTRXMULADD_S (const void *mtrxg, const void *mtrxh,\n+\t\t\tconst void *mtrxi, void *mtrxf)\n {\n   const __GCC_FV *g = mtrxg, *i = mtrxi;\n   __GCC_FV *f = mtrxf;\n@@ -1064,7 +1067,8 @@ sh_media_FMTRXMULADD_S (const void *mtrxg, const void *mtrxh, const void *mtrxi,\n \n __inline__ static\n void\n-sh_media_FMTRXMULSUB_S (const void *mtrxg, const void *mtrxh, const void *mtrxi, void *mtrxf)\n+sh_media_FMTRXMULSUB_S (const void *mtrxg, const void *mtrxh,\n+\t\t\tconst void *mtrxi, void *mtrxf)\n {\n   const __GCC_FV *g = mtrxg, *i = mtrxi;\n   __GCC_FV *f = mtrxf;"}]}