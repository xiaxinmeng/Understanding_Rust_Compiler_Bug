{"sha": "63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNjOWExOTA1M2IzN2RhYzYxMjlmNmQzZjllOGFjMWUzZDkzMDc5OA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-04-11T22:59:57Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-04-11T22:59:57Z"}, "message": "re PR c++/26122 (Pure specifiers for templates causing trouble)\n\n\t* g++.dg/parse/dtor7.C: New test.\n\t* g++.dg/parse/new1.C: Add error marker.\n\t* g++.dg/template/new3.C: New test.\n\n\tPR c++/26122\n\t* g++.dg/template/pure1.C: New test.\n\n\tPR c++/26295\n\t* g++.dg/parse/ptrmem4.C: New test.\n\nFrom-SVN: r112869", "tree": {"sha": "576c6a06a32b6a01b24c797b6728e740da468621", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/576c6a06a32b6a01b24c797b6728e740da468621"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/comments", "author": null, "committer": null, "parents": [{"sha": "ba9d67765afcde479d0e77b43e08ae1d54c6144a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba9d67765afcde479d0e77b43e08ae1d54c6144a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba9d67765afcde479d0e77b43e08ae1d54c6144a"}], "stats": {"total": 586, "additions": 370, "deletions": 216}, "files": [{"sha": "a292155f839aa22f00a60294086218cb25609515", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "patch": "@@ -1,3 +1,38 @@\n+2006-04-11  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (build_operator_new_call): Adjust prototype.\n+\t(build_new_method_call): Likewise.\n+\t(build_op_delete_call): Likewise.\n+\t* init.c (build_raw_new_expr): New function.\n+\t(build_new_1): Pass information as parameters, rather than\n+\tbundling it into a NEW_EXPR.\n+\t(build_new): Adjust accordingly.\n+\t(build_vec_delete_1): Adjust for changes to build_op_delete_call.\n+\t(build_delete): Likewise.\n+\t* decl.c (finish_destructor_body): Likewise.\n+\t* call.c (build_operator_new_call): Return the allocation function\n+\tused.\n+\t(build_op_delete_call): Take allocation function as parameter.\n+\t(build_special_member_call): Adjust call to build_new_method_call.\n+\t(build_new_method_call): Return function called.\n+\t* pt.c (tsubst_copy_and_build): Adjust call to\n+\tbuild_new_method_call.\n+\t* semantics.c (finish_call_expr): Likewise.\n+\t* parser.c (cp_parser_postfix_expression): Likewise.\n+\t* typeck2.c (cxx_incomplete_type_diagnostic): Refer to\n+\t\"incomplete\", not \"undefined\", types. \n+\n+\tPR c++/26295\n+\t* decl.c (grokdeclarator): Remove namespace-handling code for\n+\tpointers-to-members.  \n+\t* parser.c (cp_parser_ptr_operator): Check for qualified names\n+\tusing namespaces.\n+\n+\tPR c++/26122\n+\t* parser.c (cp_parser_init_declarator): Adjust logic for deciding\n+\twhether or not to look for a pure-specifier.\n+\t(cp_parser_member_declaration): Likewise.\n+\n 2006-04-08  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* decl2.c, pt.c, semantics.c: Fix comment typos."}, {"sha": "b79d03b2be979b6f2594918f39c27a6a257fe3b7", "filename": "gcc/cp/call.c", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "patch": "@@ -2817,16 +2817,21 @@ build_new_function_call (tree fn, tree args, bool koenig_p)\n    required by the allocation, and is updated if that is changed here.\n    *COOKIE_SIZE is non-NULL if a cookie should be used.  If this\n    function determines that no cookie should be used, after all,\n-   *COOKIE_SIZE is set to NULL_TREE.  */\n+   *COOKIE_SIZE is set to NULL_TREE.  If FN is non-NULL, it will be\n+   set, upon return, to the allocation function called.  */\n \n tree\n-build_operator_new_call (tree fnname, tree args, tree *size, tree *cookie_size)\n+build_operator_new_call (tree fnname, tree args, \n+\t\t\t tree *size, tree *cookie_size,\n+\t\t\t tree *fn)\n {\n   tree fns;\n   struct z_candidate *candidates;\n   struct z_candidate *cand;\n   bool any_viable_p;\n \n+  if (fn)\n+    *fn = NULL_TREE;\n   args = tree_cons (NULL_TREE, *size, args);\n   args = resolve_args (args);\n   if (args == error_mark_node)\n@@ -2904,6 +2909,10 @@ build_operator_new_call (tree fnname, tree args, tree *size, tree *cookie_size)\n \t *cookie_size = NULL_TREE;\n      }\n \n+   /* Tell our caller which function we decided to call.  */\n+   if (fn)\n+     *fn = cand->fn;\n+\n    /* Build the CALL_EXPR.  */\n    return build_over_call (cand, LOOKUP_NORMAL);\n }\n@@ -3930,11 +3939,14 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n    SIZE is the size of the memory block to be deleted.\n    GLOBAL_P is true if the delete-expression should not consider\n    class-specific delete operators.\n-   PLACEMENT is the corresponding placement new call, or NULL_TREE.  */\n+   PLACEMENT is the corresponding placement new call, or NULL_TREE.\n+   If PLACEMENT is non-NULL, then ALLOC_FN is the allocation function\n+   called to perform the placement new.  */\n \n tree\n build_op_delete_call (enum tree_code code, tree addr, tree size,\n-\t\t      bool global_p, tree placement)\n+\t\t      bool global_p, tree placement,\n+\t\t      tree alloc_fn)\n {\n   tree fn = NULL_TREE;\n   tree fns, fnname, argtypes, args, type;\n@@ -3970,18 +3982,12 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \n   if (placement)\n     {\n-      tree alloc_fn;\n-      tree call_expr;\n-\n-      /* Find the allocation function that is being called.  */\n-      call_expr = placement;\n-      /* Extract the function.  */\n-      alloc_fn = get_callee_fndecl (call_expr);\n+      /* Get the parmaeter types for the allocation function that is\n+\t being called.  */\n       gcc_assert (alloc_fn != NULL_TREE);\n-      /* Then the second parm type.  */\n       argtypes = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (alloc_fn)));\n       /* Also the second argument.  */\n-      args = TREE_CHAIN (TREE_OPERAND (call_expr, 1));\n+      args = TREE_CHAIN (TREE_OPERAND (placement, 1));\n     }\n   else\n     {\n@@ -5181,7 +5187,7 @@ build_special_member_call (tree instance, tree name, tree args,\n \n   return build_new_method_call (instance, fns, args,\n \t\t\t\tTYPE_BINFO (BINFO_TYPE (binfo)),\n-\t\t\t\tflags);\n+\t\t\t\tflags, /*fn=*/NULL);\n }\n \n /* Return the NAME, as a C string.  The NAME indicates a function that\n@@ -5229,11 +5235,13 @@ name_as_c_string (tree name, tree type, bool *free_p)\n   return pretty_name;\n }\n \n-/* Build a call to \"INSTANCE.FN (ARGS)\".  */\n+/* Build a call to \"INSTANCE.FN (ARGS)\".  If FN_P is non-NULL, it will\n+   be set, upon return, to the function called.  */\n \n tree\n build_new_method_call (tree instance, tree fns, tree args,\n-\t\t       tree conversion_path, int flags)\n+\t\t       tree conversion_path, int flags,\n+\t\t       tree *fn_p)\n {\n   struct z_candidate *candidates = 0, *cand;\n   tree explicit_targs = NULL_TREE;\n@@ -5255,6 +5263,10 @@ build_new_method_call (tree instance, tree fns, tree args,\n \n   gcc_assert (instance != NULL_TREE);\n \n+  /* We don't know what function we're going to call, yet.  */\n+  if (fn_p)\n+    *fn_p = NULL_TREE;\n+\n   if (error_operand_p (instance)\n       || error_operand_p (fns)\n       || args == error_mark_node)\n@@ -5411,8 +5423,10 @@ build_new_method_call (tree instance, tree fns, tree args,\n \t}\n       else\n \t{\n+\t  fn = cand->fn;\n+\n \t  if (!(flags & LOOKUP_NONVIRTUAL)\n-\t      && DECL_PURE_VIRTUAL_P (cand->fn)\n+\t      && DECL_PURE_VIRTUAL_P (fn)\n \t      && instance == current_class_ref\n \t      && (DECL_CONSTRUCTOR_P (current_function_decl)\n \t\t  || DECL_DESTRUCTOR_P (current_function_decl)))\n@@ -5421,27 +5435,29 @@ build_new_method_call (tree instance, tree fns, tree args,\n \t    warning (0, (DECL_CONSTRUCTOR_P (current_function_decl) ?\n \t\t      \"abstract virtual %q#D called from constructor\"\n \t\t      : \"abstract virtual %q#D called from destructor\"),\n-\t\t     cand->fn);\n+\t\t     fn);\n \n-\t  if (TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE\n+\t  if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE\n \t      && is_dummy_object (instance_ptr))\n \t    {\n \t      error (\"cannot call member function %qD without object\",\n-\t\t     cand->fn);\n+\t\t     fn);\n \t      call = error_mark_node;\n \t    }\n \t  else\n \t    {\n-\t      if (DECL_VINDEX (cand->fn) && ! (flags & LOOKUP_NONVIRTUAL)\n+\t      if (DECL_VINDEX (fn) && ! (flags & LOOKUP_NONVIRTUAL)\n \t\t  && resolves_to_fixed_type_p (instance, 0))\n \t\tflags |= LOOKUP_NONVIRTUAL;\n-\n+\t      /* Now we know what function is being called.  */\n+\t      if (fn_p)\n+\t\t*fn_p = fn;\n+\t      /* Build the actuall CALL_EXPR.  */\n \t      call = build_over_call (cand, flags);\n-\n \t      /* In an expression of the form `a->f()' where `f' turns\n \t\t out to be a static member function, `a' is\n \t\t none-the-less evaluated.  */\n-\t      if (TREE_CODE (TREE_TYPE (cand->fn)) != METHOD_TYPE\n+\t      if (TREE_CODE (TREE_TYPE (fn)) != METHOD_TYPE\n \t\t  && !is_dummy_object (instance_ptr)\n \t\t  && TREE_SIDE_EFFECTS (instance))\n \t\tcall = build2 (COMPOUND_EXPR, TREE_TYPE (call),"}, {"sha": "b488be62789104ab8d5888231869106e18b1d9d9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "patch": "@@ -3710,11 +3710,13 @@ extern bool sufficient_parms_p\t\t\t(tree);\n extern tree type_decays_to\t\t\t(tree);\n extern tree build_user_type_conversion\t\t(tree, tree, int);\n extern tree build_new_function_call\t\t(tree, tree, bool);\n-extern tree build_operator_new_call\t\t(tree, tree, tree *, tree *);\n-extern tree build_new_method_call\t\t(tree, tree, tree, tree, int);\n+extern tree build_operator_new_call\t\t(tree, tree, tree *, tree *,\n+\t\t\t\t\t\t tree *);\n+extern tree build_new_method_call\t\t(tree, tree, tree, tree, int,\n+\t\t\t\t\t\t tree *);\n extern tree build_special_member_call\t\t(tree, tree, tree, tree, int);\n extern tree build_new_op\t\t\t(enum tree_code, int, tree, tree, tree, bool *);\n-extern tree build_op_delete_call\t\t(enum tree_code, tree, tree, bool, tree);\n+extern tree build_op_delete_call\t\t(enum tree_code, tree, tree, bool, tree, tree);\n extern bool can_convert\t\t\t\t(tree, tree);\n extern bool can_convert_arg\t\t\t(tree, tree, tree, int);\n extern bool can_convert_arg_bad\t\t\t(tree, tree, tree);"}, {"sha": "3d8c2f84ba34e2f4ff8d7c886b619f526a706c45", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "patch": "@@ -7619,15 +7619,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t    type = build_ptrmemfunc_type (build_pointer_type (type));\n \t  else if (declarator->kind == cdk_ptrmem)\n \t    {\n-\t      /* We might have parsed a namespace as the class type.  */\n-\t      if (TREE_CODE (declarator->u.pointer.class_type)\n-\t\t  == NAMESPACE_DECL)\n-\t\t{\n-\t\t  error (\"%qD is a namespace\",\n-\t\t\t declarator->u.pointer.class_type);\n-\t\t  type = build_pointer_type (type);\n-\t\t}\n-\t      else if (declarator->u.pointer.class_type == error_mark_node)\n+\t      gcc_assert (TREE_CODE (declarator->u.pointer.class_type)\n+\t\t\t  != NAMESPACE_DECL);\n+\t      if (declarator->u.pointer.class_type == error_mark_node)\n \t\t/* We will already have complained.  */\n \t\ttype = error_mark_node;\n \t      else\n@@ -10801,9 +10795,11 @@ finish_destructor_body (void)\n       an implicit definition), non-placement operator delete shall\n       be looked up in the scope of the destructor's class and if\n       found shall be accessible and unambiguous.  */\n-      exprstmt = build_op_delete_call\n-\t(DELETE_EXPR, current_class_ptr, virtual_size,\n-\t /*global_p=*/false, NULL_TREE);\n+      exprstmt = build_op_delete_call(DELETE_EXPR, current_class_ptr, \n+\t\t\t\t      virtual_size,\n+\t\t\t\t      /*global_p=*/false, \n+\t\t\t\t      /*placement=*/NULL_TREE, \n+\t\t\t\t      /*alloc_fn=*/NULL_TREE);\n \n       if_stmt = begin_if_stmt ();\n       finish_if_stmt_cond (build2 (BIT_AND_EXPR, integer_type_node,"}, {"sha": "0439e92209a9a7dde00d30b6dffdf3a5ccf5a5e6", "filename": "gcc/cp/init.c", "status": "modified", "additions": 185, "deletions": 148, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "patch": "@@ -52,7 +52,6 @@ static void expand_cleanup_for_base (tree, tree);\n static tree get_temp_regvar (tree, tree);\n static tree dfs_initialize_vtbl_ptrs (tree, void *);\n static tree build_default_init (tree, tree);\n-static tree build_new_1\t(tree);\n static tree build_dtor_call (tree, special_function_kind, int);\n static tree build_field_list (tree, tree, int *);\n static tree build_vtbl_address (tree);\n@@ -1560,127 +1559,38 @@ build_builtin_delete_call (tree addr)\n   return build_call (global_delete_fndecl, build_tree_list (NULL_TREE, addr));\n }\n \f\n-/* Generate a representation for a C++ \"new\" expression.  PLACEMENT is\n-   a TREE_LIST of placement-new arguments (or NULL_TREE if none).  If\n-   NELTS is NULL, TYPE is the type of the storage to be allocated.  If\n-   NELTS is not NULL, then this is an array-new allocation; TYPE is\n-   the type of the elements in the array and NELTS is the number of\n-   elements in the array.  INIT, if non-NULL, is the initializer for\n-   the new object.  If USE_GLOBAL_NEW is true, then the user\n-   explicitly wrote \"::new\" rather than just \"new\".  */\n-\n-tree\n-build_new (tree placement, tree type, tree nelts, tree init,\n-\t   int use_global_new)\n-{\n-  tree rval;\n-\n-  if (type == error_mark_node)\n-    return error_mark_node;\n-\n-  if (processing_template_decl)\n-    {\n-      rval = build_min (NEW_EXPR, build_pointer_type (type),\n-\t\t\tplacement, type, nelts, init);\n-      NEW_EXPR_USE_GLOBAL (rval) = use_global_new;\n-      TREE_SIDE_EFFECTS (rval) = 1;\n-      return rval;\n-    }\n-\n-  if (nelts)\n-    {\n-      if (!build_expr_type_conversion (WANT_INT | WANT_ENUM, nelts, false))\n-\tpedwarn (\"size in array new must have integral type\");\n-      nelts = save_expr (cp_convert (sizetype, nelts));\n-      if (nelts == integer_zero_node)\n-\twarning (0, \"zero size array reserves no space\");\n-    }\n-\n-  /* ``A reference cannot be created by the new operator.  A reference\n-     is not an object (8.2.2, 8.4.3), so a pointer to it could not be\n-     returned by new.'' ARM 5.3.3 */\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    {\n-      error (\"new cannot be applied to a reference type\");\n-      type = TREE_TYPE (type);\n-    }\n-\n-  if (TREE_CODE (type) == FUNCTION_TYPE)\n-    {\n-      error (\"new cannot be applied to a function type\");\n-      return error_mark_node;\n-    }\n-\n-  rval = build4 (NEW_EXPR, build_pointer_type (type), placement, type,\n-\t\t nelts, init);\n-  NEW_EXPR_USE_GLOBAL (rval) = use_global_new;\n-  TREE_SIDE_EFFECTS (rval) = 1;\n-  rval = build_new_1 (rval);\n-  if (rval == error_mark_node)\n-    return error_mark_node;\n-\n-  /* Wrap it in a NOP_EXPR so warn_if_unused_value doesn't complain.  */\n-  rval = build1 (NOP_EXPR, TREE_TYPE (rval), rval);\n-  TREE_NO_WARNING (rval) = 1;\n-\n-  return rval;\n-}\n+/* Build and return a NEW_EXPR.  If NELTS is non-NULL, TYPE[NELTS] is\n+   the type of the object being allocated; otherwise, it's just TYPE.\n+   INIT is the initializer, if any.  USE_GLOBAL_NEW is true if the\n+   user explicitly wrote \"::operator new\".  PLACEMENT, if non-NULL, is\n+   the TREE_LIST of arguments to be provided as arguments to a\n+   placement new operator.  This routine performs no semantic checks;\n+   it just creates and returns a NEW_EXPR.  */\n \n-/* Given a Java class, return a decl for the corresponding java.lang.Class.  */\n-\n-tree\n-build_java_class_ref (tree type)\n+static tree\n+build_raw_new_expr (tree placement, tree type, tree nelts, tree init,\n+\t\t    int use_global_new)\n {\n-  tree name = NULL_TREE, class_decl;\n-  static tree CL_suffix = NULL_TREE;\n-  if (CL_suffix == NULL_TREE)\n-    CL_suffix = get_identifier(\"class$\");\n-  if (jclass_node == NULL_TREE)\n-    {\n-      jclass_node = IDENTIFIER_GLOBAL_VALUE (get_identifier (\"jclass\"));\n-      if (jclass_node == NULL_TREE)\n-\tfatal_error (\"call to Java constructor, while %<jclass%> undefined\");\n-\n-      jclass_node = TREE_TYPE (jclass_node);\n-    }\n-\n-  /* Mangle the class$ field.  */\n-  {\n-    tree field;\n-    for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-      if (DECL_NAME (field) == CL_suffix)\n-\t{\n-\t  mangle_decl (field);\n-\t  name = DECL_ASSEMBLER_NAME (field);\n-\t  break;\n-\t}\n-    if (!field)\n-      internal_error (\"can't find class$\");\n-    }\n-\n-  class_decl = IDENTIFIER_GLOBAL_VALUE (name);\n-  if (class_decl == NULL_TREE)\n-    {\n-      class_decl = build_decl (VAR_DECL, name, TREE_TYPE (jclass_node));\n-      TREE_STATIC (class_decl) = 1;\n-      DECL_EXTERNAL (class_decl) = 1;\n-      TREE_PUBLIC (class_decl) = 1;\n-      DECL_ARTIFICIAL (class_decl) = 1;\n-      DECL_IGNORED_P (class_decl) = 1;\n-      pushdecl_top_level (class_decl);\n-      make_decl_rtl (class_decl);\n-    }\n-  return class_decl;\n+  tree new_expr;\n+  \n+  new_expr = build4 (NEW_EXPR, build_pointer_type (type), placement, type, \n+\t\t     nelts, init); \n+  NEW_EXPR_USE_GLOBAL (new_expr) = use_global_new;\n+  TREE_SIDE_EFFECTS (new_expr) = 1;\n+\n+  return new_expr;\n }\n \n-\n-/* Called from cplus_expand_expr when expanding a NEW_EXPR.  The return\n-   value is immediately handed to expand_expr.  */\n+/* Generate code for a new-expression, including calling the \"operator\n+   new\" function, initializing the object, and, if an exception occurs\n+   during construction, cleaning up.  The arguments are as for\n+   build_raw_new_expr.  */\n \n static tree\n-build_new_1 (tree exp)\n+build_new_1 (tree placement, tree type, tree nelts, tree init,\n+\t     bool globally_qualified_p)\n+\t     \n {\n-  tree placement, init;\n   tree size, rval;\n   /* True iff this is a call to \"operator new[]\" instead of just\n      \"operator new\".  */\n@@ -1700,23 +1610,16 @@ build_new_1 (tree exp)\n   /* The type of the new-expression.  (This type is always a pointer\n      type.)  */\n   tree pointer_type;\n-  /* The type pointed to by POINTER_TYPE.  This type may be different\n-     from ELT_TYPE for a multi-dimensional array; ELT_TYPE is never an\n-     ARRAY_TYPE, but TYPE may be an ARRAY_TYPE.  */\n-  tree type;\n   /* A pointer type pointing to the FULL_TYPE.  */\n   tree full_pointer_type;\n   tree outer_nelts = NULL_TREE;\n-  tree nelts = NULL_TREE;\n   tree alloc_call, alloc_expr;\n   /* The address returned by the call to \"operator new\".  This node is\n      a VAR_DECL and is therefore reusable.  */\n   tree alloc_node;\n   tree alloc_fn;\n   tree cookie_expr, init_expr;\n   int nothrow, check_new;\n-  /* Nonzero if the user wrote `::new' rather than just `new'.  */\n-  int globally_qualified_p;\n   int use_java_new = 0;\n   /* If non-NULL, the number of extra bytes to allocate at the\n      beginning of the storage allocated for an array-new expression in\n@@ -1736,12 +1639,6 @@ build_new_1 (tree exp)\n   tree data_addr;\n   tree init_preeval_expr = NULL_TREE;\n \n-  placement = TREE_OPERAND (exp, 0);\n-  type = TREE_OPERAND (exp, 1);\n-  nelts = TREE_OPERAND (exp, 2);\n-  init = TREE_OPERAND (exp, 3);\n-  globally_qualified_p = NEW_EXPR_USE_GLOBAL (exp);\n-\n   if (nelts)\n     {\n       tree index;\n@@ -1770,7 +1667,7 @@ build_new_1 (tree exp)\n \t}\n     }\n \n-  if (!complete_type_or_else (type, exp))\n+  if (!complete_type_or_else (type, NULL_TREE))\n     return error_mark_node;\n \n   /* If our base type is an array, then make sure we know how many elements\n@@ -1815,30 +1712,31 @@ build_new_1 (tree exp)\n \t}\n     }\n \n+  alloc_fn = NULL_TREE;\n+\n   /* Allocate the object.  */\n   if (! placement && TYPE_FOR_JAVA (elt_type))\n     {\n-      tree class_addr, alloc_decl;\n+      tree class_addr;\n       tree class_decl = build_java_class_ref (elt_type);\n       static const char alloc_name[] = \"_Jv_AllocObject\";\n \n       use_java_new = 1;\n-      alloc_decl = NULL;\n       if (!get_global_value_if_present (get_identifier (alloc_name),\n-\t\t\t\t\t&alloc_decl))\n+\t\t\t\t\t&alloc_fn))\n \t{\n \t  error (\"call to Java constructor with %qs undefined\", alloc_name);\n \t  return error_mark_node;\n \t}\n-      else if (really_overloaded_fn (alloc_decl))\n+      else if (really_overloaded_fn (alloc_fn))\n \t{\n-\t  error (\"%qD should never be overloaded\", alloc_decl);\n+\t  error (\"%qD should never be overloaded\", alloc_fn);\n \t  return error_mark_node;\n \t}\n-      alloc_decl = OVL_CURRENT (alloc_decl);\n+      alloc_fn = OVL_CURRENT (alloc_fn);\n       class_addr = build1 (ADDR_EXPR, jclass_node, class_decl);\n       alloc_call = (build_function_call\n-\t\t    (alloc_decl,\n+\t\t    (alloc_fn,\n \t\t     build_tree_list (NULL_TREE, class_addr)));\n     }\n   else\n@@ -1879,7 +1777,8 @@ build_new_1 (tree exp)\n \t  alloc_call = build_new_method_call (build_dummy_object (elt_type),\n \t\t\t\t\t      fns, args,\n \t\t\t\t\t      /*conversion_path=*/NULL_TREE,\n-\t\t\t\t\t      LOOKUP_NORMAL);\n+\t\t\t\t\t      LOOKUP_NORMAL,\n+\t\t\t\t\t      &alloc_fn);\n \t}\n       else\n \t{\n@@ -1891,13 +1790,16 @@ build_new_1 (tree exp)\n \t    cookie_size = NULL_TREE;\n \n \t  alloc_call = build_operator_new_call (fnname, placement,\n-\t\t\t\t\t\t&size, &cookie_size);\n+\t\t\t\t\t\t&size, &cookie_size,\n+\t\t\t\t\t\t&alloc_fn);\n \t}\n     }\n \n   if (alloc_call == error_mark_node)\n     return error_mark_node;\n \n+  gcc_assert (alloc_fn != NULL_TREE);\n+\n   /* In the simple case, we can stop now.  */\n   pointer_type = build_pointer_type (type);\n   if (!cookie_size && !is_initialized)\n@@ -1913,8 +1815,6 @@ build_new_1 (tree exp)\n   /* Strip any COMPOUND_EXPRs from ALLOC_CALL.  */\n   while (TREE_CODE (alloc_call) == COMPOUND_EXPR)\n     alloc_call = TREE_OPERAND (alloc_call, 1);\n-  alloc_fn = get_callee_fndecl (alloc_call);\n-  gcc_assert (alloc_fn != NULL_TREE);\n \n   /* Now, check to see if this function is actually a placement\n      allocation function.  This can happen even when PLACEMENT is NULL\n@@ -2079,7 +1979,9 @@ build_new_1 (tree exp)\n \t  cleanup = build_op_delete_call (dcode, alloc_node, size,\n \t\t\t\t\t  globally_qualified_p,\n \t\t\t\t\t  (placement_allocation_fn_p\n-\t\t\t\t\t   ? alloc_call : NULL_TREE));\n+\t\t\t\t\t   ? alloc_call : NULL_TREE),\n+\t\t\t\t\t  (placement_allocation_fn_p\n+\t\t\t\t\t   ? alloc_fn : NULL_TREE));\n \n \t  if (!cleanup)\n \t    /* We're done.  */;\n@@ -2163,6 +2065,134 @@ build_new_1 (tree exp)\n \n   return rval;\n }\n+\n+/* Generate a representation for a C++ \"new\" expression.  PLACEMENT is\n+   a TREE_LIST of placement-new arguments (or NULL_TREE if none).  If\n+   NELTS is NULL, TYPE is the type of the storage to be allocated.  If\n+   NELTS is not NULL, then this is an array-new allocation; TYPE is\n+   the type of the elements in the array and NELTS is the number of\n+   elements in the array.  INIT, if non-NULL, is the initializer for\n+   the new object, or void_zero_node to indicate an initializer of\n+   \"()\".  If USE_GLOBAL_NEW is true, then the user explicitly wrote\n+   \"::new\" rather than just \"new\".  */\n+\n+tree\n+build_new (tree placement, tree type, tree nelts, tree init,\n+\t   int use_global_new)\n+{\n+  tree rval;\n+  tree orig_placement;\n+  tree orig_nelts;\n+  tree orig_init;\n+\n+  if (type == error_mark_node)\n+    return error_mark_node;\n+\n+  orig_placement = placement;\n+  orig_nelts = nelts;\n+  orig_init = init;\n+\n+  if (processing_template_decl)\n+    {\n+      if (dependent_type_p (type)\n+\t  || any_type_dependent_arguments_p (placement)\n+\t  || (nelts && type_dependent_expression_p (nelts))\n+\t  || (init != void_zero_node\n+\t      && any_type_dependent_arguments_p (init)))\n+\treturn build_raw_new_expr (placement, type, nelts, init,\n+\t\t\t\t   use_global_new);\n+      placement = build_non_dependent_args (placement);\n+      if (nelts)\n+\tnelts = build_non_dependent_expr (nelts);\n+      if (init != void_zero_node)\n+\tinit = build_non_dependent_args (init);\n+    }\n+\n+  if (nelts)\n+    {\n+      if (!build_expr_type_conversion (WANT_INT | WANT_ENUM, nelts, false))\n+\tpedwarn (\"size in array new must have integral type\");\n+      nelts = save_expr (cp_convert (sizetype, nelts));\n+      if (nelts == integer_zero_node)\n+\twarning (0, \"zero size array reserves no space\");\n+    }\n+\n+  /* ``A reference cannot be created by the new operator.  A reference\n+     is not an object (8.2.2, 8.4.3), so a pointer to it could not be\n+     returned by new.'' ARM 5.3.3 */\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    {\n+      error (\"new cannot be applied to a reference type\");\n+      type = TREE_TYPE (type);\n+    }\n+\n+  if (TREE_CODE (type) == FUNCTION_TYPE)\n+    {\n+      error (\"new cannot be applied to a function type\");\n+      return error_mark_node;\n+    }\n+\n+  rval = build_new_1 (placement, type, nelts, init, use_global_new);\n+  if (rval == error_mark_node)\n+    return error_mark_node;\n+\n+  if (processing_template_decl)\n+    return build_raw_new_expr (orig_placement, type, orig_nelts, orig_init,\n+\t\t\t       use_global_new);\n+\n+  /* Wrap it in a NOP_EXPR so warn_if_unused_value doesn't complain.  */\n+  rval = build1 (NOP_EXPR, TREE_TYPE (rval), rval);\n+  TREE_NO_WARNING (rval) = 1;\n+\n+  return rval;\n+}\n+\n+/* Given a Java class, return a decl for the corresponding java.lang.Class.  */\n+\n+tree\n+build_java_class_ref (tree type)\n+{\n+  tree name = NULL_TREE, class_decl;\n+  static tree CL_suffix = NULL_TREE;\n+  if (CL_suffix == NULL_TREE)\n+    CL_suffix = get_identifier(\"class$\");\n+  if (jclass_node == NULL_TREE)\n+    {\n+      jclass_node = IDENTIFIER_GLOBAL_VALUE (get_identifier (\"jclass\"));\n+      if (jclass_node == NULL_TREE)\n+\tfatal_error (\"call to Java constructor, while %<jclass%> undefined\");\n+\n+      jclass_node = TREE_TYPE (jclass_node);\n+    }\n+\n+  /* Mangle the class$ field.  */\n+  {\n+    tree field;\n+    for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+      if (DECL_NAME (field) == CL_suffix)\n+\t{\n+\t  mangle_decl (field);\n+\t  name = DECL_ASSEMBLER_NAME (field);\n+\t  break;\n+\t}\n+    if (!field)\n+      internal_error (\"can't find class$\");\n+    }\n+\n+  class_decl = IDENTIFIER_GLOBAL_VALUE (name);\n+  if (class_decl == NULL_TREE)\n+    {\n+      class_decl = build_decl (VAR_DECL, name, TREE_TYPE (jclass_node));\n+      TREE_STATIC (class_decl) = 1;\n+      DECL_EXTERNAL (class_decl) = 1;\n+      TREE_PUBLIC (class_decl) = 1;\n+      DECL_ARTIFICIAL (class_decl) = 1;\n+      DECL_IGNORED_P (class_decl) = 1;\n+      pushdecl_top_level (class_decl);\n+      make_decl_rtl (class_decl);\n+    }\n+  return class_decl;\n+}\n \f\n static tree\n build_vec_delete_1 (tree base, tree maxindex, tree type,\n@@ -2257,7 +2287,8 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \tdeallocate_expr = build_op_delete_call (VEC_DELETE_EXPR,\n \t\t\t\t\t\tbase_tbd, virtual_size,\n \t\t\t\t\t\tuse_global_delete & 1,\n-\t\t\t\t\t\tNULL_TREE);\n+\t\t\t\t\t\t/*placement=*/NULL_TREE, \n+\t\t\t\t\t\t/*alloc_fn=*/NULL_TREE);\n     }\n \n   body = loop;\n@@ -2646,7 +2677,8 @@ build_dtor_call (tree exp, special_function_kind dtor_kind, int flags)\n   return build_new_method_call (exp, fn,\n \t\t\t\t/*args=*/NULL_TREE,\n \t\t\t\t/*conversion_path=*/NULL_TREE,\n-\t\t\t\tflags);\n+\t\t\t\tflags,\n+\t\t\t\t/*fn_p=*/NULL);\n }\n \n /* Generate a call to a destructor. TYPE is the type to cast ADDR to.\n@@ -2742,9 +2774,11 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n       if (auto_delete != sfk_deleting_destructor)\n \treturn void_zero_node;\n \n-      return build_op_delete_call\n-\t(DELETE_EXPR, addr, cxx_sizeof_nowarn (type), use_global_delete,\n-\t NULL_TREE);\n+      return build_op_delete_call (DELETE_EXPR, addr, \n+\t\t\t\t   cxx_sizeof_nowarn (type), \n+\t\t\t\t   use_global_delete,\n+\t\t\t\t   /*placement=*/NULL_TREE,\n+\t\t\t\t   /*alloc_fn=*/NULL_TREE);\n     }\n   else\n     {\n@@ -2780,7 +2814,8 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \t\t\t\t\t    addr,\n \t\t\t\t\t    cxx_sizeof_nowarn (type),\n \t\t\t\t\t    /*global_p=*/false,\n-\t\t\t\t\t    NULL_TREE);\n+\t\t\t\t\t    /*placement=*/NULL_TREE,\n+\t\t\t\t\t    /*alloc_fn=*/NULL_TREE);\n \t  /* Call the complete object destructor.  */\n \t  auto_delete = sfk_complete_destructor;\n \t}\n@@ -2790,7 +2825,9 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \t  /* Make sure we have access to the member op delete, even though\n \t     we'll actually be calling it from the destructor.  */\n \t  build_op_delete_call (DELETE_EXPR, addr, cxx_sizeof_nowarn (type),\n-\t\t\t\t/*global_p=*/false, NULL_TREE);\n+\t\t\t\t/*global_p=*/false, \n+\t\t\t\t/*placement=*/NULL_TREE,\n+\t\t\t\t/*alloc_fn=*/NULL_TREE);\n \t}\n \n       expr = build_dtor_call (build_indirect_ref (addr, NULL),"}, {"sha": "4c0678439bba817359b69c42975ca1a49cb11d57", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 50, "deletions": 23, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "patch": "@@ -4262,7 +4262,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t\t    = (build_new_method_call\n \t\t       (instance, fn, args, NULL_TREE,\n \t\t\t(idk == CP_ID_KIND_QUALIFIED\n-\t\t\t ? LOOKUP_NONVIRTUAL : LOOKUP_NORMAL)));\n+\t\t\t ? LOOKUP_NONVIRTUAL : LOOKUP_NORMAL),\n+\t\t\t/*fn_p=*/NULL));\n \t\telse\n \t\t  postfix_expression\n \t\t    = finish_call_expr (postfix_expression, args,\n@@ -10887,6 +10888,10 @@ cp_parser_init_declarator (cp_parser* parser,\n   tree decl = NULL_TREE;\n   tree scope;\n   bool is_initialized;\n+  /* Only valid if IS_INITIALIZED is true.  In that case, CPP_EQ if\n+     initialized with \"= ..\", CPP_OPEN_PAREN if initialized with\n+     \"(...)\".  */\n+  enum cpp_ttype initialization_kind;\n   bool is_parenthesized_init;\n   bool is_non_constant_init;\n   int ctor_dtor_or_conv_p;\n@@ -11001,16 +11006,24 @@ cp_parser_init_declarator (cp_parser* parser,\n     }\n \n   /* An `=' or an `(' indicates an initializer.  */\n-  is_initialized = (token->type == CPP_EQ\n-\t\t     || token->type == CPP_OPEN_PAREN);\n-  /* If the init-declarator isn't initialized and isn't followed by a\n-     `,' or `;', it's not a valid init-declarator.  */\n-  if (!is_initialized\n-      && token->type != CPP_COMMA\n-      && token->type != CPP_SEMICOLON)\n+  if (token->type == CPP_EQ\n+      || token->type == CPP_OPEN_PAREN)\n     {\n-      cp_parser_error (parser, \"expected initializer\");\n-      return error_mark_node;\n+      is_initialized = true;\n+      initialization_kind = token->type;\n+    }\n+  else\n+    {\n+      /* If the init-declarator isn't initialized and isn't followed by a\n+\t `,' or `;', it's not a valid init-declarator.  */\n+      if (token->type != CPP_COMMA\n+\t  && token->type != CPP_SEMICOLON)\n+\t{\n+\t  cp_parser_error (parser, \"expected initializer\");\n+\t  return error_mark_node;\n+\t}\n+      is_initialized = false;\n+      initialization_kind = CPP_EOF;\n     }\n \n   /* Because start_decl has side-effects, we should only call it if we\n@@ -11081,9 +11094,16 @@ cp_parser_init_declarator (cp_parser* parser,\n \n   /* Parse the initializer.  */\n   if (is_initialized)\n-    initializer = cp_parser_initializer (parser,\n-\t\t\t\t\t &is_parenthesized_init,\n-\t\t\t\t\t &is_non_constant_init);\n+    {\n+      if (declarator->kind == cdk_function\n+\t  && declarator->declarator->kind == cdk_id\n+\t  && initialization_kind == CPP_EQ)\n+\tinitializer = cp_parser_pure_specifier (parser);\n+      else\n+\tinitializer = cp_parser_initializer (parser,\n+\t\t\t\t\t     &is_parenthesized_init,\n+\t\t\t\t\t     &is_non_constant_init);\n+    }\n   else\n     {\n       initializer = NULL_TREE;\n@@ -11730,17 +11750,23 @@ cp_parser_ptr_operator (cp_parser* parser,\n       if (!cp_parser_error_occurred (parser)\n \t  && cp_parser_require (parser, CPP_MULT, \"`*'\"))\n \t{\n-\t  /* The type of which the member is a member is given by the\n-\t     current SCOPE.  */\n-\t  *type = parser->scope;\n-\t  /* The next name will not be qualified.  */\n-\t  parser->scope = NULL_TREE;\n-\t  parser->qualifying_scope = NULL_TREE;\n-\t  parser->object_scope = NULL_TREE;\n \t  /* Indicate that the `*' operator was used.  */\n \t  code = INDIRECT_REF;\n-\t  /* Look for the optional cv-qualifier-seq.  */\n-\t  *cv_quals = cp_parser_cv_qualifier_seq_opt (parser);\n+\n+\t  if (TREE_CODE (parser->scope) == NAMESPACE_DECL)\n+\t    error (\"%qD is a namespace\", parser->scope);\n+\t  else\n+\t    {\n+\t      /* The type of which the member is a member is given by the\n+\t\t current SCOPE.  */\n+\t      *type = parser->scope;\n+\t      /* The next name will not be qualified.  */\n+\t      parser->scope = NULL_TREE;\n+\t      parser->qualifying_scope = NULL_TREE;\n+\t      parser->object_scope = NULL_TREE;\n+\t      /* Look for the optional cv-qualifier-seq.  */\n+\t      *cv_quals = cp_parser_cv_qualifier_seq_opt (parser);\n+\t    }\n \t}\n       /* If that didn't work we don't have a ptr-operator.  */\n       if (!cp_parser_parse_definitely (parser))\n@@ -13710,7 +13736,8 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t     for a pure-specifier; otherwise, we look for a\n \t\t     constant-initializer.  When we call `grokfield', it will\n \t\t     perform more stringent semantics checks.  */\n-\t\t  if (declarator->kind == cdk_function)\n+\t\t  if (declarator->kind == cdk_function\n+\t\t      && declarator->declarator->kind == cdk_id)\n \t\t    initializer = cp_parser_pure_specifier (parser);\n \t\t  else\n \t\t    /* Parse the initializer.  */"}, {"sha": "b0650bfc33320037d6e82c72ddd8d3dc05ca2c65", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "patch": "@@ -8896,7 +8896,8 @@ tsubst_copy_and_build (tree t,\n \t\t      (TREE_OPERAND (function, 0),\n \t\t       TREE_OPERAND (function, 1),\n \t\t       call_args, NULL_TREE,\n-\t\t       qualified_p ? LOOKUP_NONVIRTUAL : LOOKUP_NORMAL));\n+\t\t       qualified_p ? LOOKUP_NONVIRTUAL : LOOKUP_NORMAL,\n+\t\t       /*fn_p=*/NULL));\n \t  }\n \treturn finish_call_expr (function, call_args,\n \t\t\t\t /*disallow_virtual=*/qualified_p,"}, {"sha": "23ab2d8a132da86a7aa1aa1f91dee2aef2bed90f", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "patch": "@@ -1844,7 +1844,8 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n \n       result = build_new_method_call (object, fn, args, NULL_TREE,\n \t\t\t\t      (disallow_virtual\n-\t\t\t\t       ? LOOKUP_NONVIRTUAL : 0));\n+\t\t\t\t       ? LOOKUP_NONVIRTUAL : 0),\n+\t\t\t\t      /*fn_p=*/NULL);\n     }\n   else if (is_overloaded_fn (fn))\n     {"}, {"sha": "8227a54cd6656f483538ca268dabe60ab5917812", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "patch": "@@ -377,7 +377,7 @@ cxx_incomplete_type_diagnostic (tree value, tree type, int diag_type)\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n       if (!decl)\n-\tp_msg (\"invalid use of undefined type %q#T\", type);\n+\tp_msg (\"invalid use of incomplete type %q#T\", type);\n       if (!TYPE_TEMPLATE_INFO (type))\n \tp_msg (\"forward declaration of %q+#T\", type);\n       else"}, {"sha": "565b64e8bbdee896e9372c3c56c8d204be50eece", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "patch": "@@ -1,3 +1,15 @@\n+2006-04-11  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/parse/dtor7.C: New test.\n+\t* g++.dg/parse/new1.C: Add error marker.\n+\t* g++.dg/template/new3.C: New test.\n+\n+\tPR c++/26122\n+\t* g++.dg/template/pure1.C: New test.\n+\n+\tPR c++/26295\n+\t* g++.dg/parse/ptrmem4.C: New test.\n+\n 2006-04-10  Jeff Law  <law@redhat.com>\n \n \tPR/27087"}, {"sha": "a8095126667f8836ca65ac2fc24aab1cfc1244fe", "filename": "gcc/testsuite/g++.dg/parse/dtor7.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdtor7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdtor7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdtor7.C?ref=63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "patch": "@@ -1,4 +1,4 @@\n // PR c++/25856\n \n struct A; // { dg-error \"forward\" } \n-A::~A() {} // { dg-error \"undefined\" }\n+A::~A() {} // { dg-error \"incomplete\" }"}, {"sha": "d61c44633cef2c3747663a1415b1c23ff013bf83", "filename": "gcc/testsuite/g++.dg/parse/new1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fnew1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fnew1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fnew1.C?ref=63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "patch": "@@ -1,7 +1,7 @@\n-struct T;\n+struct T; // { dg-error \"forward\" }\n T* manage(T* t);\n template <class Obj> struct ObjectSlot0_ {\n   void create() {\n-    void* tmp = manage(new T());\n+    void* tmp = manage(new T()); // { dg-error \"incomplete\" }\n   }\n };"}, {"sha": "fea08f2060963f859b67727e467596085a0eae98", "filename": "gcc/testsuite/g++.dg/parse/ptrmem4.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fptrmem4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fptrmem4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fptrmem4.C?ref=63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "patch": "@@ -0,0 +1,4 @@\n+// PR c++/26295\n+\n+namespace A {}\n+int (A::*B)(); // { dg-error \"namespace\" }"}, {"sha": "c6c108903e179c89419916db98a31cd59698f6e7", "filename": "gcc/testsuite/g++.dg/template/new3.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnew3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnew3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnew3.C?ref=63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "patch": "@@ -0,0 +1,17 @@\n+extern void *operator new(__SIZE_TYPE__); // { dg-error \"candidate\" }\n+\n+template <class T >\n+struct C\n+{\n+  void f() {\n+    int* node;\n+    new (&node) int(0); // { dg-error \"new\" }\n+  }\n+};\n+\n+void* operator new(__SIZE_TYPE__, void* __p);\n+\n+void g() {\n+  C<int> c;\n+  c.f();\n+} "}, {"sha": "ca9b94e00b790384bf2ef335356a5f258974314f", "filename": "gcc/testsuite/g++.dg/template/pure1.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpure1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c9a19053b37dac6129f6d3f9e8ac1e3d930798/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpure1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpure1.C?ref=63c9a19053b37dac6129f6d3f9e8ac1e3d930798", "patch": "@@ -0,0 +1,6 @@\n+// PR c++/26122\n+\n+struct A\n+{\n+  template<int> void foo() = 1; // { dg-error \"pure\" }\n+};"}]}