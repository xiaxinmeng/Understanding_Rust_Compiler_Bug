{"sha": "0bb87e8a83d3b9e0d56e1cddb4dad667eaa6e195", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJiODdlOGE4M2QzYjllMGQ1NmUxY2RkYjRkYWQ2NjdlYWE2ZTE5NQ==", "commit": {"author": {"name": "Ajit Agarwal", "email": "ajitkum@xilinx.com", "date": "2015-05-05T01:07:26Z"}, "committer": {"name": "Michael Eager", "email": "eager@gcc.gnu.org", "date": "2015-05-05T01:07:26Z"}, "message": "The changes are made in the patch for optimized usage of fint instruction.\n\nThe sequence of fint/cond_branch is replaced with fcmp/cond_branch. The\nfint instruction takes 6/7 cycles as compared to fcmp instruction which\ntakes 1 cycles. The conversion from float to int with fint instruction\nis not required and can directly compared with fcmp instruction which\ntakes 1 cycle as compared to 6/7 cycles with fint instruction.\n\nChangeLog:\n2015-03-04  Ajit Agarwal  <ajitkum@xilinx.com>\n\n\t* config/microblaze/microblaze.md (peephole2): New.\n\nFrom-SVN: r222790", "tree": {"sha": "6316503f963ae5cd05c04b199351daba3723c3cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6316503f963ae5cd05c04b199351daba3723c3cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bb87e8a83d3b9e0d56e1cddb4dad667eaa6e195", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bb87e8a83d3b9e0d56e1cddb4dad667eaa6e195", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bb87e8a83d3b9e0d56e1cddb4dad667eaa6e195", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bb87e8a83d3b9e0d56e1cddb4dad667eaa6e195/comments", "author": null, "committer": null, "parents": [{"sha": "2277469bc81de637bfcfacd9b211b9df1c0f16d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2277469bc81de637bfcfacd9b211b9df1c0f16d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2277469bc81de637bfcfacd9b211b9df1c0f16d5"}], "stats": {"total": 37, "additions": 33, "deletions": 4}, "files": [{"sha": "278e6180e956ea6cc1e6adeabbce2fe7808c403a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bb87e8a83d3b9e0d56e1cddb4dad667eaa6e195/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bb87e8a83d3b9e0d56e1cddb4dad667eaa6e195/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0bb87e8a83d3b9e0d56e1cddb4dad667eaa6e195", "patch": "@@ -1,12 +1,16 @@\n+2015-05-04  Ajit Agarwal  <ajitkum@xilinx.com>\n+\n+\t* config/microblaze/microblaze.md (peephole2): New.\n+\n 2015-05-04  Jeff Law  <law@redhat.com>\n \n \tRevert:\n \t2015-05-04  Jeff Law  <law@redhat.com>\n \n-        * match.pd (bit_and (plus/minus (convert @0) (convert @1) mask): New\n-        simplifier to narrow arithmetic.\n-        * generic-match-head.c: (types_match, single_use): New functions.\n-        * gimple-match-head.c: (types_match, single_use): New functions.\n+\t* match.pd (bit_and (plus/minus (convert @0) (convert @1) mask): New\n+\tsimplifier to narrow arithmetic.\n+\t* generic-match-head.c: (types_match, single_use): New functions.\n+\t* gimple-match-head.c: (types_match, single_use): New functions.\n \n 2015-05-04  Kaz Kojima  <kkojima@gcc.gnu.org>\n "}, {"sha": "ad97ca69fa9ef2bfef639470f25d933909c01cda", "filename": "gcc/config/microblaze/microblaze.md", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bb87e8a83d3b9e0d56e1cddb4dad667eaa6e195/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bb87e8a83d3b9e0d56e1cddb4dad667eaa6e195/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.md?ref=0bb87e8a83d3b9e0d56e1cddb4dad667eaa6e195", "patch": "@@ -663,6 +663,31 @@\n   (set_attr \"mode\"\t\"SI\")\n   (set_attr \"length\"\t\"4\")])\n \n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\")\n+        (fix:SI (match_operand:SF 1 \"register_operand\")))\n+   (set (pc)\n+        (if_then_else (match_operator 2 \"ordered_comparison_operator\"\n+                       [(match_operand:SI 3 \"register_operand\")\n+                        (match_operand:SI 4 \"arith_operand\")])\n+                      (label_ref (match_operand 5))\n+                      (pc)))]\n+   \"TARGET_HARD_FLOAT\"\n+   [(set (match_dup 1) (match_dup 3))]\n+\n+  {\n+    rtx condition;\n+    rtx cmp_op0 = operands[3];\n+    rtx cmp_op1 = operands[4];\n+    rtx comp_reg =  gen_rtx_REG (SImode, MB_ABI_ASM_TEMP_REGNUM);\n+\n+    emit_insn (gen_cstoresf4 (comp_reg, operands[2],\n+                              gen_rtx_REG (SFmode, REGNO (cmp_op0)),\n+                              gen_rtx_REG (SFmode, REGNO (cmp_op1))));\n+    condition = gen_rtx_NE (SImode, comp_reg, const0_rtx);\n+    emit_jump_insn (gen_condjump (condition, operands[5]));\n+  }\n+)\n \n ;;----------------------------------------------------------------\n ;; Negation and one's complement"}]}