{"sha": "c28d91bf23ad5767265a1298be6fef0caa0a85f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI4ZDkxYmYyM2FkNTc2NzI2NWExMjk4YmU2ZmVmMGNhYTBhODVmMA==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-10-06T17:47:26Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-10-10T16:28:04Z"}, "message": "Objective-C, Darwin : Pick up super refs directly.\n\nThe current code assumed that super refs could be computed\nindirectly, i.e. that the metadata generated by the compiler\nwas immutable by the runtime. This does not always hold\n(it depends on the NeXT runtime version).  So, compute super\nrefs directly.\n\ngcc/objc/ChangeLog:\n\n\t* objc-next-runtime-abi-02.c\n\t(objc_get_superclass_ref_decl): Split this code out.\n\t(next_runtime_abi_02_get_class_super_ref): Compute\n\tsuper refs using the objc_get_superclass_ref_decl().\n\t(next_runtime_abi_02_get_category_super_ref): Likewise.", "tree": {"sha": "5b1ab182daaf83d572b742853a360e9739f17214", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b1ab182daaf83d572b742853a360e9739f17214"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c28d91bf23ad5767265a1298be6fef0caa0a85f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c28d91bf23ad5767265a1298be6fef0caa0a85f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c28d91bf23ad5767265a1298be6fef0caa0a85f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c28d91bf23ad5767265a1298be6fef0caa0a85f0/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb675539ba2f661c6bfab258847b41798a449432", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb675539ba2f661c6bfab258847b41798a449432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb675539ba2f661c6bfab258847b41798a449432"}], "stats": {"total": 76, "additions": 38, "deletions": 38}, "files": [{"sha": "57604255065638f2ad22fe9c0294bcfda53cff1b", "filename": "gcc/objc/objc-next-runtime-abi-02.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c28d91bf23ad5767265a1298be6fef0caa0a85f0/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c28d91bf23ad5767265a1298be6fef0caa0a85f0/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c?ref=c28d91bf23ad5767265a1298be6fef0caa0a85f0", "patch": "@@ -1439,13 +1439,12 @@ build_v2_superclass_ref_decl (tree ident, bool inst)\n static GTY (()) vec<ident_data_tuple, va_gc> *class_super_refs;\n static GTY (()) vec<ident_data_tuple, va_gc> *metaclass_super_refs;\n \n+/* Find or build a superclass reference decl for class NAME.  */\n+\n static tree\n-next_runtime_abi_02_get_class_super_ref (location_t loc ATTRIBUTE_UNUSED,\n-\t\t\t\t\t struct imp_entry *imp, bool inst_meth)\n+objc_get_superclass_ref_decl (tree name, bool inst_meth)\n {\n   tree decl;\n-  ident_data_tuple e;\n-  tree id = CLASS_NAME (imp->imp_context);\n   vec<ident_data_tuple, va_gc> *list = inst_meth  ? class_super_refs\n \t\t\t\t\t\t: metaclass_super_refs;\n \n@@ -1455,10 +1454,10 @@ next_runtime_abi_02_get_class_super_ref (location_t loc ATTRIBUTE_UNUSED,\n       ident_data_tuple *ref;\n       FOR_EACH_VEC_ELT (*list, count, ref)\n \t{\n-\t  if (ref->ident == id)\n+\t  if (ref->ident == name)\n \t    {\n \t      if (!ref->data)\n-\t\tref->data = build_v2_superclass_ref_decl (id, inst_meth);\n+\t\tref->data = build_v2_superclass_ref_decl (name, inst_meth);\n \t      return ref->data;\n \t    }\n \t}\n@@ -1479,48 +1478,49 @@ next_runtime_abi_02_get_class_super_ref (location_t loc ATTRIBUTE_UNUSED,\n     }\n   /* We come here if we don't find the entry - or if the table was yet\n      to be created.  */\n-  decl = build_v2_superclass_ref_decl (id, inst_meth);\n-  e.ident = id;\n+  decl = build_v2_superclass_ref_decl (name, inst_meth);\n+  ident_data_tuple e;\n+  e.ident = name;\n   e.data = decl;\n   vec_safe_push (list, e);\n   return decl;\n }\n \n+/* Get a reference to the superclass for IMP.  */\n+\n static tree\n-next_runtime_abi_02_get_category_super_ref (location_t loc ATTRIBUTE_UNUSED,\n-\t\t\t\t\t   struct imp_entry *imp, bool inst_meth)\n+next_runtime_abi_02_get_class_super_ref (location_t loc ATTRIBUTE_UNUSED,\n+\t\t\t\t\t struct imp_entry *imp, bool inst_meth)\n {\n-  /* ??? is this OK when zero-link = true?  */\n-  tree super_name = CLASS_SUPER_NAME (imp->imp_template);\n-  tree super_class;\n+  tree name = CLASS_NAME (imp->imp_context);\n+  return objc_get_superclass_ref_decl (name, inst_meth);\n+}\n \n-  if (!flag_zero_link)\n+/* Get a reference to the superclass for category IMP.  */\n+\n+static tree\n+next_runtime_abi_02_get_category_super_ref (location_t loc ATTRIBUTE_UNUSED,\n+\t\t\t\t\t    struct imp_entry *imp,\n+\t\t\t\t\t    bool inst_meth)\n+{\n+  if (flag_zero_link)\n     {\n-      super_class = objc_get_class_reference (CLASS_NAME (imp->imp_template));\n-\n-      if (!inst_meth)\n-\n-\t/* If we are in a class method, we must retrieve the\n-\t   _metaclass_ for the current class, pointed at by the\n-\t   class's \"isa\" pointer.  The following assumes that \"isa\" is\n-\t   the first ivar in a class (which it must be).  */\n-\t   super_class =\n-\t\tbuild_indirect_ref (input_location,\n-\t\t\t\t    build_c_cast (input_location,\n-\t\t\t\t\tbuild_pointer_type (objc_class_type),\n-\t\t\t\t\tsuper_class),\n-\t\t\t\t    RO_UNARY_STAR);\n-      return super_class;\n+      /* Do it the slow way.  */\n+      tree get_cl_fn = inst_meth ? objc_get_class_decl\n+\t\t\t\t : objc_get_meta_class_decl;\n+      tree super_name = CLASS_SUPER_NAME (imp->imp_template);\n+      super_name = my_build_string_pointer (IDENTIFIER_LENGTH (super_name) + 1,\n+\t\t\t\t\t    IDENTIFIER_POINTER (super_name));\n+      /* super_class = objc_get{Meta}Class(\"CLASS_SUPER_NAME\"); */\n+      return build_function_call (input_location, get_cl_fn,\n+\t\t\t\t  build_tree_list (NULL_TREE, super_name));\n     }\n-  /* ??? Do we need to add the class ref anway for zero-link?  */\n-  /* else do it the slow way.  */\n-  super_class = (inst_meth ? objc_get_class_decl : objc_get_meta_class_decl);\n-  super_name = my_build_string_pointer (IDENTIFIER_LENGTH (super_name) + 1,\n-\t\t\t\t\tIDENTIFIER_POINTER (super_name));\n-  /* super_class = objc_get{Meta}Class(\"CLASS_SUPER_NAME\"); */\n-  return build_function_call (input_location,\n-\t\t\t      super_class,\n-\t\t\t      build_tree_list (NULL_TREE, super_name));\n+\n+  /* This is the 'usual' path.  */\n+  tree cls_name = CLASS_NAME (imp->imp_template);\n+  if (!inst_meth)\n+    return objc_get_superclass_ref_decl (cls_name, inst_meth);\n+  return objc_get_class_reference (cls_name);\n }\n \n static tree"}]}