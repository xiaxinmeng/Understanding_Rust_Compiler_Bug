{"sha": "952589178550158f3c4897fd75de5ae5c3b439f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTUyNTg5MTc4NTUwMTU4ZjNjNDg5N2ZkNzVkZTVhZTVjM2I0MzlmNA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-05-09T23:41:42Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-05-09T23:41:42Z"}, "message": "ResourceBundle.java: New version from Classpath.\n\n\t* java/util/ResourceBundle.java: New version from Classpath.\n\t* java/util/Locale.java: Likewise.\n\nFrom-SVN: r53351", "tree": {"sha": "57618dcad965b4ccce97c99b06078c302ae09a1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57618dcad965b4ccce97c99b06078c302ae09a1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/952589178550158f3c4897fd75de5ae5c3b439f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/952589178550158f3c4897fd75de5ae5c3b439f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/952589178550158f3c4897fd75de5ae5c3b439f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/952589178550158f3c4897fd75de5ae5c3b439f4/comments", "author": null, "committer": null, "parents": [{"sha": "af2728a4b41b45ab6d24a4142070a8cf620c1ebc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af2728a4b41b45ab6d24a4142070a8cf620c1ebc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af2728a4b41b45ab6d24a4142070a8cf620c1ebc"}], "stats": {"total": 1414, "additions": 770, "deletions": 644}, "files": [{"sha": "de368dcf85b33b43f3bb381c649fd762c802d316", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/952589178550158f3c4897fd75de5ae5c3b439f4/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/952589178550158f3c4897fd75de5ae5c3b439f4/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=952589178550158f3c4897fd75de5ae5c3b439f4", "patch": "@@ -1,3 +1,8 @@\n+2002-05-09  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/util/ResourceBundle.java: New version from Classpath.\n+\t* java/util/Locale.java: Likewise.\n+\n 2002-05-09  Jakub Jelinek  <jakub@redhat.com>\n \n \t* testsuite/lib/libjava.exp (libjava_arguments): Append all"}, {"sha": "df5dac15b375aa6f9b3b84bf778c2752b4fe42da", "filename": "libjava/java/util/Locale.java", "status": "modified", "additions": 389, "deletions": 339, "changes": 728, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/952589178550158f3c4897fd75de5ae5c3b439f4/libjava%2Fjava%2Futil%2FLocale.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/952589178550158f3c4897fd75de5ae5c3b439f4/libjava%2Fjava%2Futil%2FLocale.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FLocale.java?ref=952589178550158f3c4897fd75de5ae5c3b439f4", "patch": "@@ -1,23 +1,23 @@\n-/* java.util.Locale\n-   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n- \n+/* Locale.java -- i18n locales\n+   Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.\n+\n This file is part of GNU Classpath.\n- \n+\n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n General Public License for more details.\n- \n+\n You should have received a copy of the GNU General Public License\n along with GNU Classpath; see the file COPYING.  If not, write to the\n Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n 02111-1307 USA.\n- \n+\n Linking this library statically or dynamically with other modules is\n making a combined work based on this library.  Thus, the terms and\n conditions of the GNU General Public License cover the whole\n@@ -37,231 +37,279 @@\n \n package java.util;\n \n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n /**\n- * Locales represent a specific country and culture.\n- * <br><br>\n- * Classes which can be passed a Locale object tailor their information \n- * for a given locale.  For instance, currency number formatting is \n- * handled differently for the USA and France.\n- * <br><br>\n- * Locales are made up of a language code, a country code, and an optional\n- * set of variant strings.\n- * <br><br>\n- * Language codes are represented by\n- * <a href=\"http://www.indigo.ie/egt/standards/iso639/iso639-1-en.html\">ISO 639:1988</a>\n- * w/ additions from ISO 639/RA Newsletter No. 1/1989\n- * and a decision of the Advisory Committee of ISO/TC39 on\n- * August 8, 1997.\n- * <br><br>\n- * Country codes are represented by \n- * <a href=\"ftp://ftp.ripe.net/iso3166-countrycodes\">ISO 3166</a>.\n- * <br><br>\n- * Variant strings are vendor and browser specific.  Standard variant\n- * strings include \"POSIX\" for POSIX, \"WIN\" for MS-Windows, and \"MAC\" for\n- * Macintosh.  When there is more than one variant string, they must\n+ * Locales represent a specific country and culture. Classes which can be\n+ * passed a Locale object tailor their information for a given locale. For\n+ * instance, currency number formatting is handled differently for the USA\n+ * and France.\n+ *\n+ * <p>Locales are made up of a language code, a country code, and an optional\n+ * set of variant strings. Language codes are represented by\n+ * <a href=\"http://www.ics.uci.edu/pub/ietf/http/related/iso639.txt\">\n+ * ISO 639:1988</a> w/ additions from ISO 639/RA Newsletter No. 1/1989\n+ * and a decision of the Advisory Committee of ISO/TC39 on August 8, 1997.\n+ *\n+ * <p>Country codes are represented by\n+ * <a href=\"http://www.chemie.fu-berlin.de/diverse/doc/ISO_3166.html\">\n+ * ISO 3166</a>. Variant strings are vendor and browser specific. Standard\n+ * variant strings include \"POSIX\" for POSIX, \"WIN\" for MS-Windows, and\n+ * \"MAC\" for Macintosh. When there is more than one variant string, they must\n  * be separated by an underscore (U+005F).\n- * <br><br>\n- * The default locale is determined by the values of the system properties\n- * user.language, user.region, and user.variant.\n+ *\n+ * <p>The default locale is determined by the values of the system properties\n+ * user.language, user.region, and user.variant, defaulting to \"en\". Note that\n+ * the locale does NOT contain the conversion and formatting capabilities (for\n+ * that, use ResourceBundle and java.text). Rather, it is an immutable tag\n+ * object for identifying a given locale, which is referenced by these other\n+ * classes when they must make locale-dependent decisions.\n+ *\n  * @see ResourceBundle\n  * @see java.text.Format\n  * @see java.text.NumberFormat\n  * @see java.text.Collator\n  * @author Jochen Hoenicke\n  * @author Paul Fisher\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.1\n+ * @status updated to 1.4\n  */\n-public final class Locale implements java.io.Serializable, Cloneable\n+public final class Locale implements Serializable, Cloneable\n {\n-  /**\n-   * Locale which represents the English language.\n-   */\n-  public static final Locale ENGLISH = new Locale(\"en\", \"\");\n-  /**\n-   * Locale which represents the English language.\n-   */\n-  public static final Locale FRENCH = new Locale(\"fr\", \"\");\n-  /**\n-   * Locale which represents the German language.\n-   */\n-  public static final Locale GERMAN = new Locale(\"de\", \"\");\n-  /**\n-   * Locale which represents the Italian language.\n-   */\n-  public static final Locale ITALIAN = new Locale(\"it\", \"\");\n-  /**\n-   * Locale which represents the Japanese language.\n-   */\n-  public static final Locale JAPANESE = new Locale(\"ja\", \"\");\n-  /**\n-   * Locale which represents the Korean language.\n-   */\n-  public static final Locale KOREAN = new Locale(\"ko\", \"\");\n-  /**\n-   * Locale which represents the Chinese language.\n-   */\n-  public static final Locale CHINESE = new Locale(\"zh\", \"\");\n-  /**\n-   * Locale which represents the Chinese language as used in China.\n-   */\n+  /** Locale which represents the English language. */\n+  public static final Locale ENGLISH = new Locale(\"en\");\n+\n+  /** Locale which represents the French language. */\n+  public static final Locale FRENCH = new Locale(\"fr\");\n+\n+  /** Locale which represents the German language. */\n+  public static final Locale GERMAN = new Locale(\"de\");\n+\n+  /** Locale which represents the Italian language. */\n+  public static final Locale ITALIAN = new Locale(\"it\");\n+\n+  /** Locale which represents the Japanese language. */\n+  public static final Locale JAPANESE = new Locale(\"ja\");\n+\n+  /** Locale which represents the Korean language. */\n+  public static final Locale KOREAN = new Locale(\"ko\");\n+\n+  /** Locale which represents the Chinese language. */\n+  public static final Locale CHINESE = new Locale(\"zh\");\n+\n+  /** Locale which represents the Chinese language as used in China. */\n   public static final Locale SIMPLIFIED_CHINESE = new Locale(\"zh\", \"CN\");\n+\n   /**\n    * Locale which represents the Chinese language as used in Taiwan.\n    * Same as TAIWAN Locale.\n    */\n   public static final Locale TRADITIONAL_CHINESE = new Locale(\"zh\", \"TW\");\n-  /**\n-   * Locale which represents France.\n-   */\n+\n+  /** Locale which represents France. */\n   public static final Locale FRANCE = new Locale(\"fr\", \"FR\");\n-  /**\n-   * Locale which represents Germany.\n-   */\n+\n+  /** Locale which represents Germany. */\n   public static final Locale GERMANY = new Locale(\"de\", \"DE\");\n-  /**\n-   * Locale which represents Italy.\n-   */\n+\n+  /** Locale which represents Italy. */\n   public static final Locale ITALY = new Locale(\"it\", \"IT\");\n-  /**\n-   * Locale which represents Japan.\n-   */\n+\n+  /** Locale which represents Japan. */\n   public static final Locale JAPAN = new Locale(\"ja\", \"JP\");\n-  /**\n-   * Locale which represents Korea.\n-   */\n+\n+  /** Locale which represents Korea. */\n   public static final Locale KOREA = new Locale(\"ko\", \"KR\");\n+\n   /**\n    * Locale which represents China.\n    * Same as SIMPLIFIED_CHINESE Locale.\n    */\n   public static final Locale CHINA = SIMPLIFIED_CHINESE;\n+\n   /**\n    * Locale which represents the People's Republic of China.\n    * Same as CHINA Locale.\n    */\n   public static final Locale PRC = CHINA;\n+\n   /**\n    * Locale which represents Taiwan.\n    * Same as TRADITIONAL_CHINESE Locale.\n    */\n   public static final Locale TAIWAN = TRADITIONAL_CHINESE;\n-  /**\n-   * Locale which represents the United Kingdom.\n-   */\n+\n+  /** Locale which represents the United Kingdom. */\n   public static final Locale UK = new Locale(\"en\", \"GB\");\n-  /**\n-   * Locale which represents the United States.\n-   */\n+\n+  /** Locale which represents the United States. */\n   public static final Locale US = new Locale(\"en\", \"US\");\n-  /**\n-   * Locale which represents the English speaking portion of Canada.\n-   */\n+\n+  /** Locale which represents the English speaking portion of Canada. */\n   public static final Locale CANADA = new Locale(\"en\", \"CA\");\n-  /**\n-   * Locale which represents the French speaking portion of Canada.\n-   */\n+\n+  /** Locale which represents the French speaking portion of Canada. */\n   public static final Locale CANADA_FRENCH = new Locale(\"fr\", \"CA\");\n \n   /**\n-   * We are compatible to sun's Locale.\n+   * Compatible with JDK 1.1+.\n    */\n-  static final long serialVersionUID = 9149081749638150636L;\n+  private static final long serialVersionUID = 9149081749638150636L;\n \n   /**\n    * The language code, as returned by getLanguage().\n-   * @serial\n+   *\n+   * @serial the languange, possibly \"\"\n    */\n   private String language;\n+\n   /**\n    * The country code, as returned by getCountry().\n-   * @serial\n+   *\n+   * @serial the country, possibly \"\"\n    */\n   private String country;\n+\n   /**\n    * The variant code, as returned by getVariant().\n-   * @serial\n+   *\n+   * @serial the variant, possibly \"\"\n    */\n   private String variant;\n+\n   /**\n-   * This is the cached hashcode.  When writing to stream, we write -1.\n-   * @serial\n+   * This is the cached hashcode. When writing to stream, we write -1.\n+   *\n+   * @serial should be -1 in serial streams\n    */\n   private int hashcode;\n \n   /**\n-   * Convert old iso639 codes to the new ones.\n+   * The default locale. Except for during bootstrapping, this should never be\n+   * null. Note the logic in the main constructor, to detect when\n+   * bootstrapping has completed.\n+   */\n+  private static Locale defaultLocale =\n+    new Locale(System.getProperty(\"user.language\", \"en\"),\n+               System.getProperty(\"user.region\", \"\"),\n+               System.getProperty(\"user.variant\", \"\"));\n+\n+  /**\n+   * Convert new iso639 codes to the old ones.\n+   *\n+   * @param language the language to check\n+   * @return the appropriate code\n    */\n   private String convertLanguage(String language)\n   {\n     if (language.equals(\"\"))\n       return language;\n-\n     language = language.toLowerCase();\n-    int index = \"iw,in,ji\".indexOf(language);\n+    int index = \"he,id,yi\".indexOf(language);\n     if (index != -1)\n-      return \"he,id,yi\".substring(index, index + 2);\n+      return \"iw,in,ji\".substring(index, index + 2);\n     return language;\n   }\n \n   /**\n    * Creates a new locale for the given language and country.\n-   * @param language lowercase two-letter ISO-639 A2 language code.\n-   * @param country uppercase two-letter ISO-3166 A2 contry code.\n-   * @param variant vendor and browser specific.\n+   *\n+   * @param language lowercase two-letter ISO-639 A2 language code\n+   * @param country uppercase two-letter ISO-3166 A2 contry code\n+   * @param variant vendor and browser specific\n+   * @throws NullPointerException if any argument is null\n    */\n   public Locale(String language, String country, String variant)\n   {\n-    this.language = convertLanguage(language);\n-    this.country = country.toUpperCase();\n-    this.variant = variant.toUpperCase();\n-    this.hashcode = (this.language.hashCode() ^ this.country.hashCode()\n-\t\t     ^ this.variant.hashCode());\n+    // During bootstrap, we already know the strings being passed in are\n+    // the correct capitalization, and not null. We can't call\n+    // String.toUpperCase during this time, since that depends on the\n+    // default locale.\n+    if (defaultLocale != null)\n+      {\n+        language = convertLanguage(language);\n+        country = country.toUpperCase();\n+        variant = variant.toUpperCase();\n+      }\n+    this.language = language;\n+    this.country = country;\n+    this.variant = variant;\n+    hashcode = language.hashCode() ^ country.hashCode() ^ variant.hashCode();\n   }\n \n   /**\n    * Creates a new locale for the given language and country.\n-   * @param language lowercase two-letter ISO-639 A2 language code.\n-   * @param country uppercase two-letter ISO-3166 A2 country code.\n+   *\n+   * @param language lowercase two-letter ISO-639 A2 language code\n+   * @param country uppercase two-letter ISO-3166 A2 country code\n+   * @throws NullPointerException if either argument is null\n    */\n   public Locale(String language, String country)\n   {\n     this(language, country, \"\");\n   }\n \n-  private static Locale defaultLocale =\n-    new Locale(System.getProperty(\"user.language\", \"\"),\n-\t       System.getProperty(\"user.region\", \"\"),\n-\t       System.getProperty(\"user.variant\", \"\"));\n+  /**\n+   * Creates a new locale for a language.\n+   *\n+   * @param language lowercase two-letter ISO-639 A2 language code\n+   * @throws NullPointerException if either argument is null\n+   * @since 1.4\n+   */\n+  public Locale(String language)\n+  {\n+    this(language, \"\", \"\");\n+  }\n \n   /**\n-   * Returns the default Locale.  The default locale is generally\n-   * once set on start up and then never changed.  Normally you \n-   * should use this locale for everywhere you need a locale.\n-   * The initial setting matches the default locale, the user has\n-   * chosen.\n+   * Returns the default Locale. The default locale is generally once set\n+   * on start up and then never changed. Normally you should use this locale\n+   * for everywhere you need a locale. The initial setting matches the\n+   * default locale, the user has chosen.\n+   *\n+   * @return the default locale for this virtual machine\n    */\n   public static Locale getDefault()\n   {\n     return defaultLocale;\n   }\n \n   /**\n-   * Changes the default locale.  Normally only called on program\n-   * start up.  Note that this doesn't change the locale for other\n-   * programs.  \n+   * Changes the default locale. Normally only called on program start up.\n+   * Note that this doesn't change the locale for other programs. This has\n+   * a security check,\n+   * <code>PropertyPermission(\"user.language\", \"write\")</code>, because of\n+   * its potential impact to running code.\n+   *\n+   * @param newLocale the new default locale\n+   * @throws NullPointerException if newLocale is null\n+   * @throws SecurityException if permission is denied\n    */\n   public static void setDefault(Locale newLocale)\n   {\n+    if (newLocale == null)\n+      throw new NullPointerException();\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkPermission(new PropertyPermission(\"user.language\", \"write\"));\n     defaultLocale = newLocale;\n   }\n \n   /**\n    * Returns the list of available locales.\n+   *\n+   * @return the installed locales\n    */\n   public static Locale[] getAvailableLocales()\n   {\n     /* I only return those for which localized language\n      * or country information exists.\n-     * XXX - remove hard coded list.\n+     * XXX - remove hard coded list, and implement more locales (Sun's JDK 1.4\n+     * has 148 installed locales!).\n      */\n     return new Locale[]\n     {\n@@ -271,71 +319,68 @@ ENGLISH, FRENCH, GERMAN, new Locale(\"ga\", \"\")\n \n   /**\n    * Returns a list of all 2-letter uppercase country codes as defined\n-   * in ISO 3166\n+   * in ISO 3166.\n+   *\n+   * @return a list of acceptible country codes\n    */\n   public static String[] getISOCountries()\n   {\n     return new String[]\n     {\n-       \"AF\", \"AL\", \"DZ\", \"AS\", \"AD\", \"AO\", \"AI\", \"AQ\", \"AG\",\n-       \"AR\", \"AM\", \"AW\", \"AU\", \"AT\", \"AZ\", \"BS\", \"BH\", \"BD\",\n-       \"BB\", \"BY\", \"BE\", \"BZ\", \"BJ\", \"BM\", \"BT\", \"BO\", \"BA\",\n-       \"BW\", \"BV\", \"BR\", \"IO\", \"BN\", \"BG\", \"BF\", \"BI\", \"KH\",\n-       \"CM\", \"CA\", \"CV\", \"KY\", \"CF\", \"TD\", \"CL\", \"CN\", \"CX\",\n-       \"CC\", \"CO\", \"KM\", \"CG\", \"CK\", \"CR\", \"CI\", \"HR\", \"CU\",\n-       \"CY\", \"CZ\", \"DK\", \"DJ\", \"DM\", \"DO\", \"TP\", \"EC\", \"EG\",\n-       \"SV\", \"GQ\", \"ER\", \"EE\", \"ET\", \"FK\", \"FO\", \"FJ\", \"FI\",\n-       \"FR\", \"FX\", \"GF\", \"PF\", \"TF\", \"GA\", \"GM\", \"GE\", \"DE\",\n-       \"GH\", \"GI\", \"GR\", \"GL\", \"GD\", \"GP\", \"GU\", \"GT\", \"GN\",\n-       \"GW\", \"GY\", \"HT\", \"HM\", \"HN\", \"HK\", \"HU\", \"IS\", \"IN\",\n-       \"ID\", \"IR\", \"IQ\", \"IE\", \"IL\", \"IT\", \"JM\", \"JP\", \"JO\",\n-       \"KZ\", \"KE\", \"KI\", \"KP\", \"KR\", \"KW\", \"KG\", \"LA\", \"LV\",\n-       \"LB\", \"LS\", \"LR\", \"LY\", \"LI\", \"LT\", \"LU\", \"MO\", \"MK\",\n-       \"MG\", \"MW\", \"MY\", \"MV\", \"ML\", \"MT\", \"MH\", \"MQ\", \"MR\",\n-       \"MU\", \"YT\", \"MX\", \"FM\", \"MD\", \"MC\", \"MN\", \"MS\", \"MA\",\n-       \"MZ\", \"MM\", \"NA\", \"NR\", \"NP\", \"NL\", \"AN\", \"NC\", \"NZ\",\n-       \"NI\", \"NE\", \"NG\", \"NU\", \"NF\", \"MP\", \"NO\", \"OM\", \"PK\",\n-       \"PW\", \"PA\", \"PG\", \"PY\", \"PE\", \"PH\", \"PN\", \"PL\", \"PT\",\n-       \"PR\", \"QA\", \"RE\", \"RO\", \"RU\", \"RW\", \"KN\", \"LC\", \"VC\",\n-       \"WS\", \"SM\", \"ST\", \"SA\", \"SN\", \"SC\", \"SL\", \"SG\", \"SK\",\n-       \"SI\", \"SB\", \"SO\", \"ZA\", \"GS\", \"ES\", \"LK\", \"SH\", \"PM\",\n-       \"SD\", \"SR\", \"SJ\", \"SZ\", \"SE\", \"CH\", \"SY\", \"TW\", \"TJ\",\n-       \"TZ\", \"TH\", \"TG\", \"TK\", \"TO\", \"TT\", \"TN\", \"TR\", \"TM\",\n-       \"TC\", \"TV\", \"UG\", \"UA\", \"AE\", \"GB\", \"US\", \"UM\", \"UY\",\n-       \"UZ\", \"VU\", \"VA\", \"VE\", \"VN\", \"VG\", \"VI\", \"WF\", \"EH\",\n-       \"YE\", \"YU\", \"ZR\", \"ZM\", \"ZW\"};\n+      \"AD\", \"AE\", \"AF\", \"AG\", \"AI\", \"AL\", \"AM\", \"AN\", \"AO\", \"AQ\", \"AR\", \"AS\",\n+      \"AT\", \"AU\", \"AW\", \"AZ\", \"BA\", \"BB\", \"BD\", \"BE\", \"BF\", \"BG\", \"BH\", \"BI\",\n+      \"BJ\", \"BM\", \"BN\", \"BO\", \"BR\", \"BS\", \"BT\", \"BV\", \"BW\", \"BY\", \"BZ\", \"CA\",\n+      \"CC\", \"CF\", \"CG\", \"CH\", \"CI\", \"CK\", \"CL\", \"CM\", \"CN\", \"CO\", \"CR\", \"CU\",\n+      \"CV\", \"CX\", \"CY\", \"CZ\", \"DE\", \"DJ\", \"DK\", \"DM\", \"DO\", \"DZ\", \"EC\", \"EE\",\n+      \"EG\", \"EH\", \"ER\", \"ES\", \"ET\", \"FI\", \"FJ\", \"FK\", \"FM\", \"FO\", \"FR\", \"FX\",\n+      \"GA\", \"GB\", \"GD\", \"GE\", \"GF\", \"GH\", \"GI\", \"GL\", \"GM\", \"GN\", \"GP\", \"GQ\",\n+      \"GR\", \"GS\", \"GT\", \"GU\", \"GW\", \"GY\", \"HK\", \"HM\", \"HN\", \"HR\", \"HT\", \"HU\",\n+      \"ID\", \"IE\", \"IL\", \"IN\", \"IO\", \"IQ\", \"IR\", \"IS\", \"IT\", \"JM\", \"JO\", \"JP\",\n+      \"KE\", \"KG\", \"KH\", \"KI\", \"KM\", \"KN\", \"KP\", \"KR\", \"KW\", \"KY\", \"KZ\", \"LA\",\n+      \"LB\", \"LC\", \"LI\", \"LK\", \"LR\", \"LS\", \"LT\", \"LU\", \"LV\", \"LY\", \"MA\", \"MC\",\n+      \"MD\", \"MG\", \"MH\", \"MK\", \"ML\", \"MM\", \"MN\", \"MO\", \"MP\", \"MQ\", \"MR\", \"MS\",\n+      \"MT\", \"MU\", \"MV\", \"MW\", \"MX\", \"MY\", \"MZ\", \"NA\", \"NC\", \"NE\", \"NF\", \"NG\",\n+      \"NI\", \"NL\", \"NO\", \"NP\", \"NR\", \"NU\", \"NZ\", \"OM\", \"PA\", \"PE\", \"PF\", \"PG\",\n+      \"PH\", \"PK\", \"PL\", \"PM\", \"PN\", \"PR\", \"PT\", \"PW\", \"PY\", \"QA\", \"RE\", \"RO\",\n+      \"RU\", \"RW\", \"SA\", \"SB\", \"SC\", \"SD\", \"SE\", \"SG\", \"SH\", \"SI\", \"SJ\", \"SK\",\n+      \"SL\", \"SM\", \"SN\", \"SO\", \"SR\", \"ST\", \"SV\", \"SY\", \"SZ\", \"TC\", \"TD\", \"TF\",\n+      \"TG\", \"TH\", \"TJ\", \"TK\", \"TM\", \"TN\", \"TO\", \"TP\", \"TR\", \"TT\", \"TV\", \"TW\",\n+      \"TZ\", \"UA\", \"UG\", \"UM\", \"US\", \"UY\", \"UZ\", \"VA\", \"VC\", \"VE\", \"VG\", \"VI\",\n+      \"VN\", \"VU\", \"WF\", \"WS\", \"YE\", \"YT\", \"YU\", \"ZA\", \"ZM\", \"ZR\", \"ZW\"\n+    };\n   }\n \n   /**\n    * Returns a list of all 2-letter lowercase language codes as defined\n    * in ISO 639 (both old and new variant).\n+   *\n+   * @return a list of acceptable language codes\n    */\n   public static String[] getISOLanguages()\n   {\n     return new String[]\n     {\n-\t\"aa\", \"ab\", \"af\", \"am\", \"ar\", \"as\", \"ay\", \"az\", \"ba\",\n-\t\"be\", \"bg\", \"bh\", \"bi\", \"bn\", \"bo\", \"br\", \"ca\", \"co\",\n-\t\"cs\", \"cy\", \"da\", \"de\", \"dz\", \"el\", \"en\", \"eo\", \"es\",\n-\t\"et\", \"eu\", \"fa\", \"fi\", \"fj\", \"fo\", \"fr\", \"fy\", \"ga\",\n-\t\"gd\", \"gl\", \"gn\", \"gu\", \"ha\", \"iw\", \"he\", \"hi\", \"hr\",\n-\t\"hu\", \"hy\", \"ia\", \"in\", \"id\", \"ie\", \"ik\", \"is\", \"it\",\n-\t\"iu\", \"ja\", \"jw\", \"ka\", \"kk\", \"kl\", \"km\", \"kn\", \"ko\",\n-\t\"ks\", \"ku\", \"ky\", \"la\", \"ln\", \"lo\", \"lt\", \"lv\", \"mg\",\n-\t\"mi\", \"mk\", \"ml\", \"mn\", \"mo\", \"mr\", \"ms\", \"mt\", \"my\",\n-\t\"na\", \"ne\", \"nl\", \"no\", \"oc\", \"om\", \"or\", \"pa\", \"pl\",\n-\t\"ps\", \"pt\", \"qu\", \"rm\", \"rn\", \"ro\", \"ru\", \"rw\", \"sa\",\n-\t\"sd\", \"sg\", \"sh\", \"si\", \"sk\", \"sl\", \"sm\", \"sn\", \"so\",\n-\t\"sq\", \"sr\", \"ss\", \"st\", \"su\", \"sv\", \"sw\", \"ta\", \"te\",\n-\t\"tg\", \"th\", \"ti\", \"tk\", \"tl\", \"tn\", \"to\", \"tr\", \"ts\",\n-\t\"tt\", \"tw\", \"ug\", \"uk\", \"ur\", \"uz\", \"vi\", \"vo\", \"wo\",\n-\t\"xh\", \"ji\", \"yi\", \"yo\", \"za\", \"zh\", \"zu\"};\n+      \"aa\", \"ab\", \"af\", \"am\", \"ar\", \"as\", \"ay\", \"az\", \"ba\", \"be\", \"bg\", \"bh\",\n+      \"bi\", \"bn\", \"bo\", \"br\", \"ca\", \"co\", \"cs\", \"cy\", \"da\", \"de\", \"dz\", \"el\",\n+      \"en\", \"eo\", \"es\", \"et\", \"eu\", \"fa\", \"fi\", \"fj\", \"fo\", \"fr\", \"fy\", \"ga\",\n+      \"gd\", \"gl\", \"gn\", \"gu\", \"ha\", \"he\", \"hi\", \"hr\", \"hu\", \"hy\", \"ia\", \"id\",\n+      \"ie\", \"ik\", \"in\", \"is\", \"it\", \"iu\", \"iw\", \"ja\", \"ji\", \"jw\", \"ka\", \"kk\",\n+      \"kl\", \"km\", \"kn\", \"ko\", \"ks\", \"ku\", \"ky\", \"la\", \"ln\", \"lo\", \"lt\", \"lv\",\n+      \"mg\", \"mi\", \"mk\", \"ml\", \"mn\", \"mo\", \"mr\", \"ms\", \"mt\", \"my\", \"na\", \"ne\",\n+      \"nl\", \"no\", \"oc\", \"om\", \"or\", \"pa\", \"pl\", \"ps\", \"pt\", \"qu\", \"rm\", \"rn\",\n+      \"ro\", \"ru\", \"rw\", \"sa\", \"sd\", \"sg\", \"sh\", \"si\", \"sk\", \"sl\", \"sm\", \"sn\",\n+      \"so\", \"sq\", \"sr\", \"ss\", \"st\", \"su\", \"sv\", \"sw\", \"ta\", \"te\", \"tg\", \"th\",\n+      \"ti\", \"tk\", \"tl\", \"tn\", \"to\", \"tr\", \"ts\", \"tt\", \"tw\", \"ug\", \"uk\", \"ur\",\n+      \"uz\", \"vi\", \"vo\", \"wo\", \"xh\", \"yi\", \"yo\", \"za\", \"zh\", \"zu\"\n+    };\n   }\n \n   /**\n-   * Returns the language code of this locale.\n-   * @return language code portion of this locale, or an empty String if\n-   * none exists\n+   * Returns the language code of this locale. Some language codes have changed\n+   * as ISO 639 has evolved; this returns the old name, even if you built\n+   * the locale with the new one.\n+   *\n+   * @return language code portion of this locale, or an empty String\n    */\n   public String getLanguage()\n   {\n@@ -344,8 +389,8 @@ public String getLanguage()\n \n   /**\n    * Returns the country code of this locale.\n-   * @return country code portion of this locale, or an empty String if\n-   * none exists\n+   *\n+   * @return country code portion of this locale, or an empty String\n    */\n   public String getCountry()\n   {\n@@ -354,221 +399,228 @@ public String getCountry()\n \n   /**\n    * Returns the variant code of this locale.\n+   *\n+   * @return the variant code portion of this locale, or an empty String\n    */\n   public String getVariant()\n   {\n     return variant;\n   }\n \n   /**\n-   * Gets the string representation of the current locale.  This\n-   * consists of the language, the country, and the variant,\n-   * separated by an underscore.  If one of this three component is\n-   * missing the underscore will also disappear.  \n-   * @return the string representation of this Locale.\n+   * Gets the string representation of the current locale. This consists of\n+   * the language, the country, and the variant, separated by an underscore.\n+   * The variant is listed only if there is a language or country. Examples:\n+   * \"en\", \"de_DE\", \"_GB\", \"en_US_WIN\", \"de__POSIX\", \"fr__MAC\".\n+   *\n+   * @return the string representation of this Locale\n+   * @see #getDisplayName()\n    */\n   public final String toString()\n   {\n+    if (language.length() == 0 && country.length() == 0)\n+      return \"\";\n     StringBuffer result = new StringBuffer(language);\n-    String underscore = \"\";\n-    if (language.length() != 0)\n-      underscore = \"_\";\n-    if (country.length() != 0)\n-      {\n-\tresult.append(underscore);\n-\tresult.append(country);\n-\tunderscore = \"_\";\n-      }\n+    result.append('_').append(country);\n     if (variant.length() != 0)\n-      {\n-\tresult.append(underscore);\n-\tresult.append(variant);\n-      }\n+      result.append('_').append(variant);\n     return result.toString();\n   }\n \n   /**\n    * Returns the three-letter ISO language abbrevation of this locale.\n-   * @exception MissingResourceException if the three-letter code is not\n-   * known.  \n+   *\n+   * @throws MissingResourceException if the three-letter code is not known\n    */\n-  public String getISO3Language() throws MissingResourceException\n+  public String getISO3Language()\n   {\n-    int index =\n-      (\"aa,ab,af,am,ar,as,ay,az,ba,be,bg,bh,bi,bn,bo,br,ca,co,cs,cy,\" +\n-       \"da,de,dz,el,en,eo,es,et,eu,fa,fi,fj,fo,fr,fy,ga,gd,gl,gn,gu,\" +\n-       \"gv,ha,hi,hr,hu,hy,ia,ie,ik,id,is,it,iu,he,ja,yi,jw,ka,kk,kl,\" +\n-       \"km,kn,ko,ks,ku,kw,ky,la,lb,ln,lo,lt,lv,mg,mi,mk,ml,mn,mo,mr,\" +\n-       \"ms,mt,my,na,ne,nl,no,oc,om,or,pa,pl,ps,pt,qu,rm,rn,ro,ru,rw,\" +\n-       \"sa,sd,se,sg,sh,si,sk,sl,sm,sn,so,sq,sr,ss,st,su,sv,sw,ta,te,\" +\n-       \"tg,th,ti,tk,tl,tn,to,tr,ts,tt,tw,ug,uk,ur,uz,vi,vo,wo,xh,yo,\" +\n-       \"za,zh,zu,\").indexOf(language + \",\");\n-       \n-    if (index == -1 || language.length() != 2)\n+    if (\"\".equals(language))\n+      return \"\";\n+    int index\n+      = (\"aa,ab,af,am,ar,as,ay,az,ba,be,bg,bh,bi,bn,bo,br,ca,co,cs,cy,da,\"\n+         + \"de,dz,el,en,eo,es,et,eu,fa,fi,fj,fo,fr,fy,ga,gd,gl,gn,gu,ha,iw,\"\n+         + \"hi,hr,hu,hy,ia,in,ie,ik,in,is,it,iu,iw,ja,ji,jw,ka,kk,kl,km,kn,\"\n+         + \"ko,ks,ku,ky,la,ln,lo,lt,lv,mg,mi,mk,ml,mn,mo,mr,ms,mt,my,na,ne,\"\n+         + \"nl,no,oc,om,or,pa,pl,ps,pt,qu,rm,rn,ro,ru,rw,sa,sd,sg,sh,si,sk,\"\n+         + \"sl,sm,sn,so,sq,sr,ss,st,su,sv,sw,ta,te,tg,th,ti,tk,tl,tn,to,tr,\"\n+         + \"ts,tt,tw,ug,uk,ur,uz,vi,vo,wo,xh,ji,yo,za,zh,zu\")\n+      .indexOf(language);\n+\n+    if (index % 3 != 0 || language.length() != 2)\n       throw new MissingResourceException\n-\t(\"Can't find ISO3 language for \" + language,\n-\t \"java.util.Locale\", language);\n+        (\"Can't find ISO3 language for \" + language,\n+         \"java.util.Locale\", language);\n \n-    /* Don't read this aloud.  This are the three letter language codes\n-     */\n+    // Don't read this aloud. These are the three letter language codes.\n     return\n-      (\"aarabkaframharaasmaymazebakbelbulbihbisbenbodbrecatcoscescym\" +\n-       \"dandeudzoellengepospaesteusfasfinfijfaofrafrygaigdhglggrnguj\" +\n-       \"maxhauhinhrvhunhyeinaileipkindislitaikuhebjpnyidjawkatkazkal\" +\n-       \"khmkankorkaskurcorkirlatltzlinlaolitlavmlgmrimkdmalmonmolmar\" +\n-       \"msamltmyanaunepnldnorociormoripanpolpusporquerohrunronruskin\" +\n-       \"sansndsmisagsrpsinslkslvsmosnasomsqisrpsswsotsunsweswatamtel\" +\n-       \"tgkthatirtuktgltsntonturtsotattwiuigukrurduzbvievolwolxhoyor\" +\n-       \"zhazhozul\").substring(index, index + 3);\n+      (\"aarabkaframharaasmaymazebakbelbulbihbisbenbodbrecatcoscescymdandeu\"\n+       + \"dzoellengepospaesteusfasfinfijfaofrafrygaigdhglggrngujhauhebhinhrv\"\n+       + \"hunhyeinaindileipkindislitaikuhebjpnyidjawkatkazkalkhmkankorkaskur\"\n+       + \"kirlatlinlaolitlavmlgmrimkdmalmonmolmarmsamltmyanaunepnldnorociorm\"\n+       + \"oripanpolpusporquerohrunronruskinsansndsagsrpsinslkslvsmosnasomsqi\"\n+       + \"srpsswsotsunsweswatamteltgkthatirtuktgltsntonturtsotattwiuigukrurd\"\n+       + \"uzbvievolwolxhoyidyorzhazhozul\")\n+      .substring(index, index + 3);\n   }\n \n   /**\n    * Returns the three-letter ISO country abbrevation of the locale.\n-   * @exception MissingResourceException if the three-letter code is not\n-   * known.\n+   *\n+   * @throws MissingResourceException if the three-letter code is not known\n    */\n-  public String getISO3Country() throws MissingResourceException\n+  public String getISO3Country()\n   {\n-    int index =\n-      (\"AF,AL,DZ,AS,AD,AO,AI,AQ,AG,AR,AM,AW,AU,AT,AZ,BS,BH,BD,BB,BY,BE,\" +\n-       \"BZ,BJ,BM,BT,BO,BA,BW,BV,BR,IO,BN,BG,BF,BI,KH,CM,CA,CV,KY,CF,TD,\" +\n-       \"CL,CN,CX,CC,CO,KM,CG,CD,CK,CR,CI,HR,CU,CY,CZ,DK,DJ,DM,DO,TP,EC,\" +\n-       \"EG,SV,GQ,ER,EE,ET,FK,FO,FJ,FI,FR,FX,GF,PF,TF,GA,GM,GE,DE,GH,GI,\" +\n-       \"GR,GL,GD,GP,GU,GT,GN,GW,GY,HT,HM,VA,HN,HK,HU,IS,IN,ID,IR,IQ,IE,\" +\n-       \"IL,IT,JM,JP,JO,KZ,KE,KI,KP,KR,KW,KG,LA,LV,LB,LS,LR,LY,LI,LT,LU,\" +\n-       \"MO,MK,MG,MW,MY,MV,ML,MT,MH,MQ,MR,MU,YT,MX,FM,MD,MC,MN,MS,MA,MZ,\" +\n-       \"MM,NA,NR,NP,NL,AN,NC,NZ,NI,NE,NG,NU,NF,MP,NO,OM,PK,PW,PA,PG,PY,\" +\n-       \"PE,PH,PN,PL,PT,PR,QA,RE,RO,RU,RW,KN,LC,VC,WS,SM,ST,SA,SN,SC,SL,\" +\n-       \"SG,SK,SI,SB,SO,ZA,GS,ES,LK,SH,PM,SD,SR,SJ,SZ,SE,CH,SY,TW,TJ,TZ,\" +\n-       \"TH,TG,TK,TO,TT,TN,TR,TM,TC,TV,UG,UA,AE,GB,US,UM,UY,UZ,VU,VE,VN,\" +\n-       \"VG,VI,WF,EH,YE,YU,ZM,ZW,\").indexOf(country + \",\");\n-       \n-    if (index == -1 || language.length() != 2)\n+    if (\"\".equals(country))\n+      return \"\";\n+    int index\n+      = (\"AD,AE,AF,AG,AI,AL,AM,AN,AO,AQ,AR,AS,AT,AU,AW,AZ,BA,BB,BD,BE,BF,\"\n+         + \"BG,BH,BI,BJ,BM,BN,BO,BR,BS,BT,BV,BW,BY,BZ,CA,CC,CF,CG,CH,CI,CK,\"\n+         + \"CL,CM,CN,CO,CR,CU,CV,CX,CY,CZ,DE,DJ,DK,DM,DO,DZ,EC,EE,EG,EH,ER,\"\n+         + \"ES,ET,FI,FJ,FK,FM,FO,FR,FX,GA,GB,GD,GE,GF,GH,GI,GL,GM,GN,GP,GQ,\"\n+         + \"GR,GS,GT,GU,GW,GY,HK,HM,HN,HR,HT,HU,ID,IE,IL,IN,IO,IQ,IR,IS,IT,\"\n+         + \"JM,JO,JP,KE,KG,KH,KI,KM,KN,KP,KR,KW,KY,KZ,LA,LB,LC,LI,LK,LR,LS,\"\n+         + \"LT,LU,LV,LY,MA,MC,MD,MG,MH,MK,ML,MM,MN,MO,MP,MQ,MR,MS,MT,MU,MV,\"\n+         + \"MW,MX,MY,MZ,NA,NC,NE,NF,NG,NI,NL,NO,NP,NR,NU,NZ,OM,PA,PE,PF,PG,\"\n+         + \"PH,PK,PL,PM,PN,PR,PT,PW,PY,QA,RE,RO,RU,RW,SA,SB,SC,SD,SE,SG,SH,\"\n+         + \"SI,SJ,SK,SL,SM,SN,SO,SR,ST,SV,SY,SZ,TC,TD,TF,TG,TH,TJ,TK,TM,TN,\"\n+         + \"TO,TP,TR,TT,TV,TW,TZ,UA,UG,UM,US,UY,UZ,VA,VC,VE,VG,VI,VN,VU,WF,\"\n+         + \"WS,YE,YT,YU,ZA,ZM,ZR,ZW\")\n+      .indexOf(country);\n+\n+    if (index % 3 != 0 || language.length() != 2)\n       throw new MissingResourceException\n-\t(\"Can't find ISO3 country for \" + country,\n-\t \"java.util.Locale\", country);\n+        (\"Can't find ISO3 country for \" + country,\n+         \"java.util.Locale\", country);\n \n-    /* Don't read this aloud.  This are the three letter country codes\n-     */\n+    // Don't read this aloud. These are the three letter country codes.\n     return\n-      (\"AFGALBDZAASMANDAGOAIAATAATGARGARMABWAUSAUTAZEBHSBHRBGDBRBBLRBEL\" +\n-       \"BLZBENBMUBTNBOLBIHBWABVTBRAIOTBRNBGRBFABDIKHMCMRCANCPVCYMCAFTCD\" +\n-       \"CHLCHNCXRCCKCOLCOMCOGCODCOKCRICIVHRVCUBCYPCZEDNKDJIDMADOMTMPECU\" +\n-       \"EGYSLVGNQERIESTETHFLKFROFJIFINFRAFXXGUFPYFATFGABGMBGEODEUGHAGIB\" +\n-       \"GRCGRLGRDGLPGUMGTMGINGNBGUYHTIHMDVATHNDHKGHUNISLINDIDNIRNIRQIRL\" +\n-       \"ISRITAJAMJPNJORKAZKENKIRPRKKORKWTKGZLAOLVALBNLSOLBRLBYLIELTULUX\" +\n-       \"MACMKDMDGMWIMYSMDVMLIMLTMHLMTQMRTMUSMYTMEXFSMMDAMCOMNGMSRMARMOZ\" +\n-       \"MMRNAMNRUNPLNLDANTNCLNZLNICNERNGANIUNFKMNPNOROMNPAKPLWPANPNGPRY\" +\n-       \"PERPHLPCNPOLPRTPRIQATREUROMRUSRWAKNALCAVCTWSMSMRSTPSAUSENSYCSLE\" +\n-       \"SGPSVKSVNSLBSOMZAFSGSESPLKASHNSPMSDNSURSJMSWZSWECHESYRTWNTJKTZA\" +\n-       \"THATGOTKLTONTTOTUNTURTKMTCATUVUGAUKRAREGBRUSAUMIURYUZBVUTVENVNM\" +\n-       \"VGBVIRWLFESHYEMYUGZMBZWE\").substring(index, index + 3);\n+      (\"ANDAREAFGATGAIAALBARMANTAGOATAARGASMAUTAUSABWAZEBIHBRBBGDBELBFABGR\"\n+       + \"BHRBDIBENBMUBRNBOLBRABHSBTNBVTBWABLRBLZCANCCKCAFCOGCHECIVCOKCHLCMR\"\n+       + \"CHNCOLCRICUBCPVCXRCYPCZEDEUDJIDNKDMADOMDZAECUESTEGYESHERIESPETHFIN\"\n+       + \"FJIFLKFSMFROFRAFXXGABGBRGRDGEOGUFGHAGIBGRLGMBGINGLPGNQGRCSGSGTMGUM\"\n+       + \"GNBGUYHKGHMDHNDHRVHTIHUNIDNIRLISRINDIOTIRQIRNISLITAJAMJORJPNKENKGZ\"\n+       + \"KHMKIRCOMKNAPRKKORKWTCYMKAZLAOLBNLCALIELKALBRLSOLTULUXLVALBYMARMCO\"\n+       + \"MDAMDGMHLMKDMLIMMRMNGMACMNPMTQMRTMSRMLTMUSMDVMWIMEXMYSMOZNAMNCLNER\"\n+       + \"NFKNGANICNLDNORNPLNRUNIUNZLOMNPANPERPYFPNGPHLPAKPOLSPMPCNPRIPRTPLW\"\n+       + \"PRYQATREUROMRUSRWASAUSLBSYCSDNSWESGPSHNSVNSJMSVKSLESMRSENSOMSURSTP\"\n+       + \"SLVSYRSWZTCATCDATFTGOTHATJKTKLTKMTUNTONTMPTURTTOTUVTWNTZAUKRUGAUMI\"\n+       + \"USAURYUZBVATVCTVENVGBVIRVNMVUTWLFWSMYEMMYTYUGZAFZMBZARZWE\")\n+      .substring(index, index + 3);\n   }\n \n-  /** \n+  /**\n    * Gets the country name suitable for display to the user, formatted\n    * for the default locale.  This has the same effect as\n    * <pre>\n    * getDisplayLanguage(Locale.getDefault());\n    * </pre>\n    *\n-   * @return the language name of this locale localized to the\n-   * default locale.  If the localized is not found, the ISO code\n-   * is returned.\n+   * @return the language name of this locale localized to the default locale,\n+   *         with the ISO code as backup\n    */\n   public String getDisplayLanguage()\n   {\n-    return getDisplayLanguage(getDefault());\n+    return getDisplayLanguage(defaultLocale);\n   }\n \n-  /** \n+  /**\n    * Gets the language name suitable for display to the user, formatted\n    * for a specified locale.\n+   *\n    * @param locale locale to use for formatting\n-   * @return the language name of this locale localized to the\n-   * given locale.  If the localized is not found, the ISO code\n-   * is returned.\n+   * @return the language name of this locale localized to the given locale,\n+   *         with the ISO code as backup\n    */\n   public String getDisplayLanguage(Locale locale)\n   {\n     try\n       {\n-\tResourceBundle bundle\n-\t  = ResourceBundle.getBundle(\"gnu.java.locale.iso639\", locale);\n-\treturn bundle.getString(language);\n+        ResourceBundle bundle\n+          = ResourceBundle.getBundle(\"gnu.java.locale.iso639\", locale);\n+        return bundle.getString(language);\n       }\n     catch (MissingResourceException ex)\n       {\n-\treturn language;\n+        return language;\n       }\n   }\n \n-  /** \n+  /**\n    * Returns the country name of this locale localized to the\n-   * default locale.  If the localized is not found, the ISO code\n-   * is returned.  This has the same effect as\n+   * default locale. If the localized is not found, the ISO code\n+   * is returned. This has the same effect as\n    * <pre>\n    * getDisplayCountry(Locale.getDefault());\n    * </pre>\n+   *\n+   * @return the country name of this locale localized to the given locale,\n+   *         with the ISO code as backup\n    */\n   public String getDisplayCountry()\n   {\n-    return getDisplayCountry(getDefault());\n+    return getDisplayCountry(defaultLocale);\n   }\n \n-  /** \n+  /**\n    * Gets the country name suitable for display to the user, formatted\n    * for a specified locale.\n    *\n    * @param locale locale to use for formatting\n-   * @return the country name of this locale localized to the given\n-   * locale.  If the localized is not found, the ISO country code is\n-   * returned.  */\n+   * @return the country name of this locale localized to the given locale,\n+   *         with the ISO code as backup\n+   */\n   public String getDisplayCountry(Locale locale)\n   {\n     try\n       {\n-\tResourceBundle bundle =\n-\t  ResourceBundle.getBundle(\"gnu.java.locale.iso3166\", locale);\n-\treturn bundle.getString(country);\n+        ResourceBundle bundle =\n+          ResourceBundle.getBundle(\"gnu.java.locale.iso3166\", locale);\n+        return bundle.getString(country);\n       }\n     catch (MissingResourceException ex)\n       {\n-\treturn country;\n+        return country;\n       }\n   }\n \n-  /** \n+  /**\n    * Returns the variant name of this locale localized to the\n-   * default locale.  If the localized is not found, the variant code\n-   * itself is returned.  This has the same effect as\n+   * default locale. If the localized is not found, the variant code\n+   * itself is returned. This has the same effect as\n    * <pre>\n    * getDisplayVariant(Locale.getDefault());\n    * </pre>\n+   *\n+   * @return the variant code of this locale localized to the given locale,\n+   *         with the ISO code as backup\n    */\n   public String getDisplayVariant()\n   {\n-    return getDisplayVariant(getDefault());\n+    return getDisplayVariant(defaultLocale);\n   }\n \n-  /** \n+  /**\n    * Returns the variant name of this locale localized to the\n-   * given locale.  If the localized is not found, the variant code\n+   * given locale. If the localized is not found, the variant code\n    * itself is returned.\n+   *\n+   * @param locale locale to use for formatting\n+   * @return the variant code of this locale localized to the given locale,\n+   *         with the ISO code as backup\n    */\n   public String getDisplayVariant(Locale locale)\n   {\n-    /*XXX - load a bundle? */\n+    // XXX - load a bundle?\n     return variant;\n   }\n \n   /**\n    * Gets all local components suitable for display to the user, formatted\n-   * for the default locale.  For the language component, getDisplayLanguage\n-   * is called.  For the country component, getDisplayCountry is called.\n+   * for the default locale. For the language component, getDisplayLanguage\n+   * is called. For the country component, getDisplayCountry is called.\n    * For the variant set component, getDisplayVariant is called.\n-   * <br><br>\n-   * The returned String will be one of the following forms:<br>\n+   *\n+   * <p>The returned String will be one of the following forms:<br>\n    * <pre>\n    * language (country, variant)\n    * language (country)\n@@ -578,22 +630,22 @@ public String getDisplayVariant(Locale locale)\n    * country\n    * variant\n    * </pre>\n-   * @return String version of this locale, suitable for display to the\n-   * user.\n+   *\n+   * @return String version of this locale, suitable for display to the user\n    */\n   public String getDisplayName()\n   {\n-    return getDisplayName(getDefault());\n+    return getDisplayName(defaultLocale);\n   }\n \n   /**\n    * Gets all local components suitable for display to the user, formatted\n-   * for a specified locale.  For the language component, \n-   * getDisplayLanguage(Locale) is called.  For the country component, \n-   * getDisplayCountry(Locale) is called.  For the variant set component, \n+   * for a specified locale. For the language component,\n+   * getDisplayLanguage(Locale) is called. For the country component,\n+   * getDisplayCountry(Locale) is called. For the variant set component,\n    * getDisplayVariant(Locale) is called.\n-   * <br><br>\n-   * The returned String will be one of the following forms:<br>\n+   *\n+   * <p>The returned String will be one of the following forms:<br>\n    * <pre>\n    * language (country, variant)\n    * language (country)\n@@ -605,63 +657,53 @@ public String getDisplayName()\n    * </pre>\n    *\n    * @param locale locale to use for formatting\n-   *\n-   * @return String version of this locale, suitable for display to the\n-   * user.\n+   * @return String version of this locale, suitable for display to the user\n    */\n   public String getDisplayName(Locale locale)\n   {\n     StringBuffer result = new StringBuffer();\n     int count = 0;\n     String[] delimiters = {\"\", \" (\", \",\"};\n-    \n     if (language.length() != 0)\n       {\n-\tresult.append(delimiters[count++]);\n-\tresult.append(getDisplayLanguage(locale));\n+        result.append(delimiters[count++]);\n+        result.append(getDisplayLanguage(locale));\n       }\n-\n     if (country.length() != 0)\n       {\n-\tresult.append(delimiters[count++]);\n-\tresult.append(getDisplayCountry(locale));\n+        result.append(delimiters[count++]);\n+        result.append(getDisplayCountry(locale));\n       }\n-\n     if (variant.length() != 0)\n       {\n-\tresult.append(delimiters[count++]);\n-\tresult.append(getDisplayVariant(locale));\n+        result.append(delimiters[count++]);\n+        result.append(getDisplayVariant(locale));\n       }\n-\n     if (count > 1)\n       result.append(\")\");\n-      \n     return result.toString();\n   }\n \n   /**\n    * Does the same as <code>Object.clone()</code> but does not throw\n-   * an <code>CloneNotSupportedException</code>.  Why anyone would\n-   * use this method is a secret to me, since this class is\n-   * immutable.  \n+   * a <code>CloneNotSupportedException</code>. Why anyone would\n+   * use this method is a secret to me, since this class is immutable.\n+   *\n+   * @return the clone\n    */\n   public Object clone()\n   {\n-    try\n-      {\n-\treturn super.clone();\n-      }\n-    catch (CloneNotSupportedException ex)\n-      {\n-\treturn null;\n-      }\n+    // This class is final, so no need to use native super.clone().\n+    return new Locale(language, country, variant);\n   }\n \n   /**\n-   * Return the hash code for this locale.  The hashcode is the logical\n+   * Return the hash code for this locale. The hashcode is the logical\n    * xor of the hash codes of the language, the country and the variant.\n    * The hash code is precomputed, since <code>Locale</code>s are often\n    * used in hash tables.\n+   *\n+   * @return the hashcode\n    */\n   public synchronized int hashCode()\n   {\n@@ -671,44 +713,52 @@ public synchronized int hashCode()\n   }\n \n   /**\n-   * Compares two locales.\n-   * @param obj the other locale.\n-   * @return true, if obj is a Locale with the same language, country, and\n-   * variant code as this locale, otherwise false.\n+   * Compares two locales. To be equal, obj must be a Locale with the same\n+   * language, country, and variant code.\n+   *\n+   * @param obj the other locale\n+   * @return true if obj is equal to this\n    */\n   public boolean equals(Object obj)\n   {\n-    if (this == obj)\n-      return true;\n-    if (!(obj instanceof Locale))\n+    if (! (obj instanceof Locale))\n       return false;\n     Locale l = (Locale) obj;\n     return (language.equals(l.language)\n-\t    && country.equals(l.country)\n-\t    && variant.equals(l.variant));\n+            && country.equals(l.country)\n+            && variant.equals(l.variant));\n   }\n \n   /**\n-   * @serialdata According to jdk1.2 the hashcode should always be \n-   * written as -1; \n+   * Write the locale to an object stream.\n+   *\n+   * @param output the stream to write to\n+   * @throws IOException if the write fails\n+   * @serialData the hashcode should always be written as -1, and recomputed\n+   *      when reading it back\n    */\n-  private synchronized void writeObject(java.io.ObjectOutputStream output)\n-    throws java.io.IOException\n+  private synchronized void writeObject(ObjectOutputStream output)\n+    throws IOException\n   {\n+    // Synchronized so that hashCode() doesn't get wrong value.\n     int tmpHashcode = hashcode;\n     hashcode = -1;\n     output.defaultWriteObject();\n     hashcode = tmpHashcode;\n   }\n \n   /**\n-   * @serialdata  According to jdk1.2 the hashCode is always invalid\n-   * and must be recomputed.\n+   * Reads a locale from the input stream.\n+   *\n+   * @param input the stream to read from\n+   * @throws IOException if reading fails\n+   * @throws ClassNotFoundException if reading fails\n+   * @serialData the hashCode is always invalid and must be recomputed\n    */\n-  private void readObject(java.io.ObjectInputStream input)\n-    throws java.io.IOException, ClassNotFoundException\n+  private void readObject(ObjectInputStream input)\n+    throws IOException, ClassNotFoundException\n   {\n     input.defaultReadObject();\n     hashcode = language.hashCode() ^ country.hashCode() ^ variant.hashCode();\n   }\n-}\n+} // class Locale"}, {"sha": "150a01bf44f5e6a5a7c13cc7d8a2778b1e70ab4f", "filename": "libjava/java/util/ResourceBundle.java", "status": "modified", "additions": 376, "deletions": 305, "changes": 681, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/952589178550158f3c4897fd75de5ae5c3b439f4/libjava%2Fjava%2Futil%2FResourceBundle.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/952589178550158f3c4897fd75de5ae5c3b439f4/libjava%2Fjava%2Futil%2FResourceBundle.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FResourceBundle.java?ref=952589178550158f3c4897fd75de5ae5c3b439f4", "patch": "@@ -1,5 +1,5 @@\n-/* java.util.ResourceBundle\n-   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+/* ResourceBundle -- aids in loading resource bundles\n+   Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,93 +37,106 @@\n \n \n package java.util;\n+\n import java.lang.ref.Reference;\n import java.lang.ref.SoftReference;\n+import java.io.InputStream;\n+import java.io.IOException;\n import java.security.AccessController;\n import java.security.PrivilegedAction;\n import gnu.classpath.Configuration;\n \n /**\n- * A resource bundle contains locale-specific data.  If you need\n- * localized data, you can load a resource bundle that matches the\n- * locale with <code>getBundle</code>.  Now you can get your object by\n- * calling <code>getObject</code> or <code>getString</code> on that\n- * bundle.\n- * <br>\n- * When a bundle is demanded for a specific locale, the ResourceBundle\n- * is searched in following order (<i>def. language code<i> stands for\n- * the two letter ISO language code of the default locale (see\n+ * A resource bundle contains locale-specific data. If you need localized\n+ * data, you can load a resource bundle that matches the locale with\n+ * <code>getBundle</code>. Now you can get your object by calling\n+ * <code>getObject</code> or <code>getString</code> on that bundle.\n+ *\n+ * <p>When a bundle is demanded for a specific locale, the ResourceBundle\n+ * is searched in following order (<i>def. language<i> stands for the\n+ * two letter ISO language code of the default locale (see\n  * <code>Locale.getDefault()</code>).\n- * <pre>\n- * baseName_<i>language code</i>_<i>country code</i>_<i>variant</i>\n- * baseName_<i>language code</i>_<i>country code</i>\n- * baseName_<i>language code</i>\n- * baseName_<i>def. language code</i>_<i>def. country code</i>_<i>def. variant</i>\n- * baseName_<i>def. language code</i>_<i>def. country code</i>\n- * baseName_<i>def. language code</i>\n- * baseName\n- * </pre>\n  *\n- * A bundle is backed up, by less specific bundle (omiting variant,\n- * country or language). But it is not backed up by the default\n- * language locale.\n- * <br>\n- * If you provide a bundle for a given locale, say\n+<pre>baseName_<i>language code</i>_<i>country code</i>_<i>variant</i>\n+baseName_<i>language code</i>_<i>country code</i>\n+baseName_<i>language code</i>\n+baseName_<i>def. language</i>_<i>def. country</i>_<i>def. variant</i>\n+baseName_<i>def. language</i>_<i>def. country</i>\n+baseName_<i>def. language</i>\n+baseName</pre>\n+ *\n+ * <p>A bundle is backed up by less specific bundles (omiting variant, country\n+ * or language). But it is not backed up by the default language locale.\n+ *\n+ * <p>If you provide a bundle for a given locale, say\n  * <code>Bundle_en_UK_POSIX</code>, you must also provide a bundle for\n  * all sub locales, ie. <code>Bundle_en_UK</code>, <code>Bundle_en</code>, and\n  * <code>Bundle</code>.\n- * <br>\n- * When a bundle is searched, we look first for a class with\n- * the given name and if that is not found for a file with\n- * <code>.properties</code> extension in the classpath.  The name\n- * must be a fully qualified classname (with dots as path separators).  \n- * <br>\n- * (Note: This implementation always backs up the class with a\n- * properties file if that is existing, but you shouldn't rely on\n- * this, if you want to be compatible to the standard JDK.)\n  *\n+ * <p>When a bundle is searched, we look first for a class with the given\n+ * name, then for a file with <code>.properties</code> extension in the\n+ * classpath. The name must be a fully qualified classname (with dots as\n+ * path separators).\n+ *\n+ * <p>(Note: This implementation always backs up the class with a properties\n+ * file if that is existing, but you shouldn't rely on this, if you want to\n+ * be compatible to the standard JDK.)\n+ *\n+ * @author Jochen Hoenicke\n+ * @author Eric Blake (ebb9@email.byu.edu)\n  * @see Locale\n+ * @see ListResourceBundle\n  * @see PropertyResourceBundle\n- * @author Jochen Hoenicke */\n+ * @since 1.1\n+ * @status updated to 1.4\n+ */\n public abstract class ResourceBundle\n {\n   /**\n-   * The parent bundle.  This is consulted when you call getObject\n-   * and there is no such resource in the current bundle.  This\n-   * field may be null.  \n+   * The parent bundle. This is consulted when you call getObject and there\n+   * is no such resource in the current bundle. This field may be null.\n    */\n   protected ResourceBundle parent;\n \n   /**\n-   * The locale of this resource bundle.  You can read this with\n+   * The locale of this resource bundle. You can read this with\n    * <code>getLocale</code> and it is automatically set in\n-   * <code>getBundle</code>.  \n+   * <code>getBundle</code>.\n    */\n   private Locale locale;\n \n   /**\n-   * We override SecurityManager in order to access getClassContext(). \n+   * We override SecurityManager in order to access getClassContext().\n    */\n-  static class Security extends SecurityManager\n+  private static final class Security extends SecurityManager\n   {\n-    /** Return the ClassLoader of the class which called into this\n-        ResourceBundle, or null if it cannot be determined. */\n+    /**\n+     * Avoid accessor method of private constructor.\n+     */\n+    Security()\n+    {\n+    }\n+\n+    /**\n+     * Return the ClassLoader of the class which called into this\n+     * ResourceBundle, or null if it cannot be determined.\n+     */\n     ClassLoader getCallingClassLoader()\n     {\n-      Class[] stack = super.getClassContext();\n+      Class[] stack = getClassContext();\n       for (int i = 0; i < stack.length; i++)\n         if (stack[i] != Security.class && stack[i] != ResourceBundle.class)\n-\t  return stack[i].getClassLoader();\n+          return stack[i].getClassLoader();\n       return null;\n     }\n   }\n-  \n-  // This will always work since java.util classes have (all) system\n-  // permissions.\n-  static Security security = (Security) AccessController.doPrivileged\n-    (\n-      new PrivilegedAction()\n+\n+  /** A security context for grabbing the correct class loader. */\n+  private static final Security security\n+    = (Security) AccessController.doPrivileged(new PrivilegedAction()\n       {\n+        // This will always work since java.util classes have (all) system\n+        // permissions.\n         public Object run()\n         {\n           return new Security();\n@@ -132,343 +145,401 @@ public Object run()\n     );\n \n   /**\n-   * The constructor.  It does nothing special.\n+   * The resource bundle cache. This is a two-level hash map: The key\n+   * is the class loader, the value is a new HashMap. The key of this\n+   * second hash map is the localized name, the value is a soft\n+   * references to the resource bundle.\n+   */\n+  private static final Map resourceBundleCache = new HashMap();\n+\n+  /**\n+   * The `empty' locale is created once in order to optimize\n+   * tryBundle().\n+   */\n+  private static final Locale emptyLocale = new Locale(\"\");\n+\n+  /**\n+   * The constructor. It does nothing special.\n    */\n   public ResourceBundle()\n   {\n   }\n \n   /**\n-   * Get a String from this resource bundle.  Since most localized\n-   * Objects are Strings, this method provides a convenient way to get\n-   * them without casting.\n-   * @param key the name of the resource.\n-   * @exception MissingResourceException\n-   *   if that particular object could not be found in this bundle nor\n-   *   the parent bundle.\n+   * Get a String from this resource bundle. Since most localized Objects\n+   * are Strings, this method provides a convenient way to get them without\n+   * casting.\n+   *\n+   * @param key the name of the resource\n+   * @throws MissingResourceException if the resource can't be found\n+   * @throws NullPointerException if key is null\n+   * @throws ClassCastException if resource is not a string\n    */\n-  public final String getString(String key) throws MissingResourceException\n+  public final String getString(String key)\n   {\n     return (String) getObject(key);\n   }\n \n   /**\n-   * Get an array of Strings from this resource bundle.  This method\n+   * Get an array of Strings from this resource bundle. This method\n    * provides a convenient way to get it without casting.\n-   * @param key the name of the resource.\n-   * @exception MissingResourceException\n-   *   if that particular object could not be found in this bundle nor\n-   *   the parent bundle.\n+   *\n+   * @param key the name of the resource\n+   * @throws MissingResourceException if the resource can't be found\n+   * @throws NullPointerException if key is null\n+   * @throws ClassCastException if resource is not a string\n    */\n   public final String[] getStringArray(String key)\n-    throws MissingResourceException\n   {\n     return (String[]) getObject(key);\n   }\n \n   /**\n-   * Get an object from this resource bundle.\n-   * @param key the name of the resource.\n-   * @exception MissingResourceException\n-   *   if that particular object could not be found in this bundle nor\n-   *   the parent bundle.\n+   * Get an object from this resource bundle. This will call\n+   * <code>handleGetObject</code> for this resource and all of its parents,\n+   * until it finds a non-null resource.\n+   *\n+   * @param key the name of the resource\n+   * @throws MissingResourceException if the resource can't be found\n+   * @throws NullPointerException if key is null\n    */\n-  public final Object getObject(String key) throws MissingResourceException\n+  public final Object getObject(String key)\n   {\n     for (ResourceBundle bundle = this; bundle != null; bundle = bundle.parent)\n-      {\n-\ttry\n-\t  {\n-\t    Object o = bundle.handleGetObject(key);\n-\t    if (o != null)\n-\t      return o;\n-\t  }\n-\tcatch (MissingResourceException ex)\n-\t  {\n-\t  }\n-      }\n-    throw new MissingResourceException\n-      (\"Key not found\", getClass().getName(), key);\n+      try\n+        {\n+          Object o = bundle.handleGetObject(key);\n+          if (o != null)\n+            return o;\n+        }\n+      catch (MissingResourceException ex)\n+        {\n+        }\n+    throw new MissingResourceException(\"Key not found\",\n+                                       getClass().getName(), key);\n   }\n \n   /**\n-   * Get the appropriate ResourceBundle for the default locale.  \n-   * @param baseName the name of the ResourceBundle.  This should be\n-   * a name of a Class or a properties-File.  See the class\n-   * description for details.  \n-   * @return the desired resource bundle\n-   * @exception MissingResourceException \n-   *    if the resource bundle couldn't be found.  \n+   * Return the actual locale of this bundle. You can use it after calling\n+   * getBundle, to know if the bundle for the desired locale was loaded or\n+   * if the fall back was used.\n+   *\n+   * @return the bundle's locale\n    */\n-  public static final ResourceBundle getBundle(String baseName)\n-    throws MissingResourceException\n+  public Locale getLocale()\n   {\n-    return getBundle(baseName, Locale.getDefault(),\n-\t\t     security.getCallingClassLoader());\n+    return locale;\n   }\n \n   /**\n-   * Get the appropriate ResourceBundle for the given locale.  \n-   * @param baseName the name of the ResourceBundle.  This should be\n-   * a name of a Class or a properties-File.  See the class\n-   * description for details.  \n-   * @param locale A locale.\n-   * @return the desired resource bundle\n-   * @exception MissingResourceException \n-   *    if the resource bundle couldn't be found.\n+   * Set the parent of this bundle. The parent is consulted when you call\n+   * getObject and there is no such resource in the current bundle.\n+   *\n+   * @param parent the parent of this bundle\n    */\n-  public static final ResourceBundle getBundle(String baseName,\n-\t\t\t\t\t       Locale locale)\n-    throws MissingResourceException\n+  protected void setParent(ResourceBundle parent)\n   {\n-    return getBundle(baseName, locale, security.getCallingClassLoader());\n+    // Shall we ignore the old parent?\n+    this.parent = parent;\n   }\n \n   /**\n-   * The resource bundle cache.  This is a two-level hash map: The key\n-   * is the class loader, the value is a new HashMap.  The key of this\n-   * second hash map is the localized name, the value is a soft\n-   * references to the resource bundle.  */\n-  private static Map resourceBundleCache = new HashMap();\n-\n-  /**\n-   * The `empty' locale is created once in order to optimize\n-   * tryBundle().  \n-   */\n-  private static final Locale emptyLocale = new Locale (\"\", \"\");\n-\n-  /**\n-   * Tries to load a class or a property file with the specified name.\n-   * @param localizedName the name.\n-   * @param locale the locale, that must be used exactly.\n-   * @param classloader the classloader.\n-   * @param bundle the back up (parent) bundle\n-   * @return the resource bundle if that could be loaded, otherwise \n-   * <code>bundle</code>.\n+   * Get the appropriate ResourceBundle for the default locale. This is like\n+   * calling <code>getBundle(baseName, Locale.getDefault(),\n+   * getClass().getClassLoader()</code>, except that any security check of\n+   * getClassLoader won't fail.\n+   *\n+   * @param baseName the name of the ResourceBundle\n+   * @return the desired resource bundle\n+   * @throws MissingResourceException if the resource bundle can't be found\n+   * @throws NullPointerException if baseName is null\n    */\n-  private static final ResourceBundle tryBundle(String localizedName,\n-\t\t\t\t\t\tLocale locale,\n-\t\t\t\t\t\tClassLoader classloader,\n-\t\t\t\t\t\tResourceBundle bundle,\n-\t\t\t\t\t\tHashMap cache)\n+  public static final ResourceBundle getBundle(String baseName)\n   {\n-    {\n-      // First look into the cache.\n-      // XXX We should remove cleared references from the cache.\n-      Reference ref = (Reference) cache.get(localizedName);\n-      if (ref != null)\n-\t{\n-\t  ResourceBundle rb = (ResourceBundle) ref.get();\n-\t  if (rb != null)\n-\t    // rb should already have the right parent, except if\n-\t    // something very strange happened.\n-\t    return rb;\n-\t}\n-    }\n-\n-    // foundBundle holds exact matches for the localizedName resource\n-    // bundle, which may later be cached.\n-    ResourceBundle foundBundle = null;\n-\n-    try\n-      {\n-\tjava.io.InputStream is;\n-\tfinal String resourceName =\n-\t  localizedName.replace('.', '/') + \".properties\";\n-\tif (classloader == null)\n-\t  is = ClassLoader.getSystemResourceAsStream (resourceName);\n-\telse\n-\t  is = classloader.getResourceAsStream (resourceName);\n-\tif (is != null)\n-\t  {\n-\t    foundBundle = new PropertyResourceBundle(is);\n-\t    foundBundle.parent = bundle;\n-\t    foundBundle.locale = locale;\n-\t  }\n-      }\n-    catch (java.io.IOException ex)\n-      {\n-      }\n-\n-    try\n-      {\n-\tClass rbClass;\n-\tif (classloader == null)\n-\t  rbClass = Class.forName(localizedName);\n-\telse\n-\t  rbClass = classloader.loadClass(localizedName);\n-\tfoundBundle = (ResourceBundle) rbClass.newInstance();\n-\tfoundBundle.parent = bundle;\n-\tfoundBundle.locale = locale;\n-      }\n-    catch (ClassNotFoundException ex)\n-      {\n-      }\n-    catch (IllegalAccessException ex)\n-      {\n-      }\n-    catch (InstantiationException ex)\n-      {\n-\t// ignore them all\n-\t// XXX should we also ignore ClassCastException?\n-      }\n-\n-    if (foundBundle != null)\n-      cache.put(localizedName, new SoftReference(foundBundle));\n-\n-    return foundBundle != null ? foundBundle : bundle;\n+    return getBundle(baseName, Locale.getDefault(),\n+                     security.getCallingClassLoader());\n   }\n \n   /**\n-   * Tries to load a the bundle for a given locale, also loads the backup\n-   * locales with the same language.\n+   * Get the appropriate ResourceBundle for the given locale. This is like\n+   * calling <code>getBundle(baseName, locale,\n+   * getClass().getClassLoader()</code>, except that any security check of\n+   * getClassLoader won't fail.\n    *\n-   * @param name the name.\n-   * @param locale the locale, that must be used exactly.\n-   * @param classloader the classloader.\n-   * @param bundle the back up (parent) bundle\n-   * @return the resource bundle if that could be loaded, otherwise \n-   * <code>bundle</code>.\n+   * @param baseName the name of the ResourceBundle\n+   * @param locale A locale\n+   * @return the desired resource bundle\n+   * @throws MissingResourceException if the resource bundle can't be found\n+   * @throws NullPointerException if baseName or locale is null\n    */\n-  private static final ResourceBundle tryLocalBundle(String baseName,\n-\t\t\t\t\t\t     Locale locale,\n-\t\t\t\t\t\t     ClassLoader classloader,\n-\t\t\t\t\t\t     ResourceBundle bundle,\n-\t\t\t\t\t\t     HashMap cache)\n+  public static final ResourceBundle getBundle(String baseName,\n+                                               Locale locale)\n   {\n-    final String language = locale.getLanguage();\n-\n-    if (language.length() > 0)\n-      {\n-\tfinal String country = locale.getCountry();\n-\tString name = baseName + \"_\" + language;\n-\n-\tif (country.length() != 0)\n-\t  {\n-\t    bundle = tryBundle(name,\n-\t\t\t       new Locale(language, \"\"),\n-\t\t\t       classloader, bundle, cache);\n-\n-\t    name += \"_\" + country;\n-\n-\t    final String variant = locale.getVariant();\n-\n-\t    if (variant.length() != 0)\n-\t      {\n-\t\tbundle = tryBundle(name,\n-\t\t\t\t   new Locale(language,\n-\t\t\t\t\t      country),\n-\t\t\t\t   classloader, bundle, cache);\n-\n-\t\tname += \"_\" + variant;\n-\t      }\n-\t  }\n-\tbundle = tryBundle(name, locale, classloader, bundle, cache);\n-      }\n-    return bundle;\n+    return getBundle(baseName, locale, security.getCallingClassLoader());\n   }\n \n   /**\n-   * Get the appropriate ResourceBundle for the given locale.  \n-   * @param baseName the name of the ResourceBundle.  This should be\n-   * a name of a Class or a properties file.  See the class\n-   * description for details.  \n-   * @param locale A locale.\n-   * @param classloader a ClassLoader.\n+   * Get the appropriate ResourceBundle for the given locale. The following\n+   * strategy is used:\n+   *\n+   * <p>A sequence of candidate bundle names are generated, and tested in\n+   * this order, where the suffix 1 means the string from the specified\n+   * locale, and the suffix 2 means the string from the default locale:<ul>\n+   * <li>baseName + \"_\" + language1 + \"_\" + country1 + \"_\" + variant1</li>\n+   * <li>baseName + \"_\" + language1 + \"_\" + country1</li>\n+   * <li>baseName + \"_\" + language1</li>\n+   * <li>baseName + \"_\" + language2 + \"_\" + country2 + \"_\" + variant2</li>\n+   * <li>baseName + \"_\" + language2 + \"_\" + country2</li>\n+   * <li>baseName + \"_\" + language2<li>\n+   * <li>baseName</li>\n+   * </ul>\n+   *\n+   * <p>In the sequence, entries with an empty string are ignored. Next,\n+   * <code>getBundle</code> tries to instantiate the resource bundle:<ul>\n+   * <li>First, an attempt is made to load a class in the specified classloader\n+   * which is a subclass of ResourceBundle, and which has a public constructor\n+   * with no arguments, via reflection.</li>\n+   * <li>Next, a search is made for a property resource file, by replacing\n+   * '.' with '/' and appending \".properties\", and using\n+   * ClassLoader.getResource(). If a file is found, then a\n+   * PropertyResourceBundle is created from the file's contents.</li>\n+   * </ul>\n+   * If no resource bundle was found, a MissingResourceException is thrown.\n+   *\n+   * <p>Next, the parent chain is implemented. The remaining candidate names\n+   * in the above sequence are tested in a similar manner, and if any results\n+   * in a resource bundle, it is assigned as the parent of the first bundle\n+   * using the <code>setParent</code> method (unless the first bundle already\n+   * has a parent).\n+   *\n+   * <p>For example, suppose the following class and property files are\n+   * provided: MyResources.class, MyResources_fr_CH.properties,\n+   * MyResources_fr_CH.class, MyResources_fr.properties,\n+   * MyResources_en.properties, and MyResources_es_ES.class. The contents of\n+   * all files are valid (that is, public non-abstract subclasses of\n+   * ResourceBundle with public nullary constructors for the \".class\" files,\n+   * syntactically correct \".properties\" files). The default locale is\n+   * Locale(\"en\", \"UK\").\n+   *\n+   * <p>Calling getBundle with the shown locale argument values instantiates\n+   * resource bundles from the following sources:<ul>\n+   * <li>Locale(\"fr\", \"CH\"): result MyResources_fr_CH.class, parent\n+   *   MyResources_fr.properties, parent MyResources.class</li>\n+   * <li>Locale(\"fr\", \"FR\"): result MyResources_fr.properties, parent\n+   *   MyResources.class</li>\n+   * <li>Locale(\"de\", \"DE\"): result MyResources_en.properties, parent\n+   *   MyResources.class</li>\n+   * <li>Locale(\"en\", \"US\"): result MyResources_en.properties, parent\n+   *   MyResources.class</li>\n+   * <li>Locale(\"es\", \"ES\"): result MyResources_es_ES.class, parent\n+   *   MyResources.class</li>\n+   * </ul>\n+   * The file MyResources_fr_CH.properties is never used because it is hidden\n+   * by MyResources_fr_CH.class.\n+   *\n+   * @param baseName the name of the ResourceBundle\n+   * @param locale A locale\n+   * @param classloader a ClassLoader\n    * @return the desired resource bundle\n-   * @exception MissingResourceException \n-   *    if the resource bundle couldn't be found.\n+   * @throws MissingResourceException if the resource bundle can't be found\n+   * @throws NullPointerException if any argument is null\n+   * @since 1.2\n    */\n   // This method is synchronized so that the cache is properly\n   // handled.\n-  public static final synchronized ResourceBundle getBundle(String baseName,\n-\t\t\t\t\t\t\t    Locale locale,\n-\t\t\t\t\t\t\t    ClassLoader classLoader)\n-    throws MissingResourceException\n+  public static final synchronized ResourceBundle getBundle\n+    (String baseName, Locale locale, ClassLoader classLoader)\n   {\n     // This implementation searches the bundle in the reverse direction\n     // and builds the parent chain on the fly.\n-\n     HashMap cache = (HashMap) resourceBundleCache.get(classLoader);\n+    StringBuffer sb = new StringBuffer(60);\n+    sb.append(baseName).append('_').append(locale);\n+    String name = sb.toString();\n+\n     if (cache == null)\n       {\n-\tcache = new HashMap();\n-\tresourceBundleCache.put(classLoader, cache);\n+        cache = new HashMap();\n+        resourceBundleCache.put(classLoader, cache);\n       }\n     else\n       {\n-\t// Fast path: If baseName + \"_\" + locale is in cache use it.\n-\tString name = baseName + \"_\" + locale.toString();\n-\tReference ref = (Reference) cache.get(name);\n-\tif (ref != null)\n-\t  {\n-\t    ResourceBundle rb = (ResourceBundle) ref.get();\n-\t    if (rb != null)\n-\t      // rb should already have the right parent, except if\n-\t      // something very strange happened.\n-\t      return rb;\n-\t  }\n+        Reference ref = (Reference) cache.get(name);\n+        if (ref != null)\n+          {\n+            ResourceBundle rb = (ResourceBundle) ref.get();\n+            if (rb != null)\n+              // rb should already have the right parent, except if\n+              // something very strange happened.\n+              return rb;\n+          }\n       }\n \n     ResourceBundle baseBundle = tryBundle(baseName, emptyLocale,\n-\t\t\t\t\t  classLoader, null, cache);\n+                                          classLoader, null, cache);\n     if (baseBundle == null)\n       // JDK says, that if one provides a bundle base_en_UK, one\n       // must also provide the bundles base_en and base.\n       // This implies that if there is no bundle for base, there\n       // is no bundle at all.\n-      throw new MissingResourceException(\"Bundle \" + baseName + \" not found\", baseName, \"\");\n+      throw new MissingResourceException(\"Bundle \" + baseName + \" not found\",\n+                                         baseName, \"\");\n \n     // Now use the default locale.\n     ResourceBundle bundle = tryLocalBundle(baseName, locale,\n-\t\t\t\t\t   classLoader, baseBundle, cache);\n+                                           classLoader, baseBundle, cache);\n     if (bundle == baseBundle && !locale.equals(Locale.getDefault()))\n-      {\n-\tbundle = tryLocalBundle(baseName, Locale.getDefault(),\n-\t\t\t\tclassLoader, baseBundle, cache);\n-      }\n+      bundle = tryLocalBundle(baseName, Locale.getDefault(),\n+                              classLoader, baseBundle, cache);\n+\n+    // Check whether baseName_locale has been loaded; if not, map the\n+    // \"baseName\" bundle to \"baseName_locale\" to avoid retrying to load\n+    // baseName_locale.\n+    Reference ref = (Reference) cache.get(name);\n+    if (ref == null)\n+      cache.put(name, new SoftReference(bundle));\n+\n     return bundle;\n   }\n \n   /**\n-   * Return the actual locale of this bundle.  You can use it after\n-   * calling getBundle, to know if the bundle for the desired locale\n-   * was loaded or if the fall back was used.\n+   * Override this method to provide the resource for a keys. This gets\n+   * called by <code>getObject</code>. If you don't have a resource\n+   * for the given key, you should return null instead throwing a\n+   * MissingResourceException. You don't have to ask the parent, getObject()\n+   * already does this; nor should you throw a MissingResourceException.\n+   *\n+   * @param key the key of the resource\n+   * @return the resource for the key, or null if not in bundle\n+   * @throws NullPointerException if key is null\n    */\n-  public Locale getLocale()\n-  {\n-    return locale;\n-  }\n+  protected abstract Object handleGetObject(String key);\n \n   /**\n-   * Set the parent of this bundle. This is consulted when you call\n-   * getObject and there is no such resource in the current bundle.\n-   * @param parent the parent of this bundle.\n+   * This method should return all keys for which a resource exists; you\n+   * should include the enumeration of any parent's keys, after filtering out\n+   * duplicates.\n+   *\n+   * @return an enumeration of the keys\n    */\n-  protected void setParent(ResourceBundle parent)\n-  {\n-    // Shall we ignore the old parent?\n-    this.parent = parent;\n-  }\n+  public abstract Enumeration getKeys();\n \n   /**\n-   * Override this method to provide the resource for a keys.  This gets\n-   * called by <code>getObject</code>.  If you don't have a resource\n-   * for the given key, you should return null instead throwing a\n-   * MissingResourceException.   You don't have to ask the parent, \n-   * getObject() already does this.\n+   * Tries to load a class or a property file with the specified name.\n    *\n-   * @param key The key of the resource.\n-   * @return The resource for the key, or null if not in bundle.\n-   * @exception MissingResourceException\n-   *   you shouldn't throw this.\n+   * @param localizedName the name\n+   * @param locale the locale, that must be used exactly\n+   * @param classloader the classloader\n+   * @param bundle the backup (parent) bundle\n+   * @return the resource bundle if it was loaded, otherwise the backup\n    */\n-  protected abstract Object handleGetObject(String key)\n-    throws MissingResourceException;\n+  private static final ResourceBundle tryBundle(String localizedName,\n+                                                Locale locale,\n+                                                ClassLoader classloader,\n+                                                ResourceBundle bundle,\n+                                                HashMap cache)\n+  {\n+    // First look into the cache.\n+    // XXX We should remove cleared references from the cache.\n+    Reference ref = (Reference) cache.get(localizedName);\n+    if (ref != null)\n+      {\n+        ResourceBundle rb = (ResourceBundle) ref.get();\n+        if (rb != null)\n+          // rb should already have the right parent, except if\n+          // something very strange happened.\n+          return rb;\n+      }\n+\n+    // foundBundle holds exact matches for the localizedName resource\n+    // bundle, which may later be cached.\n+    ResourceBundle foundBundle = null;\n+    try\n+      {\n+        Class rbClass;\n+        if (classloader == null)\n+          rbClass = Class.forName(localizedName);\n+        else\n+          rbClass = classloader.loadClass(localizedName);\n+        foundBundle = (ResourceBundle) rbClass.newInstance();\n+        foundBundle.parent = bundle;\n+        foundBundle.locale = locale;\n+      }\n+    catch (Exception ex)\n+      {\n+        // ignore them all\n+      }\n+    if (foundBundle == null)\n+      try\n+        {\n+          InputStream is;\n+          final String resourceName\n+            = localizedName.replace('.', '/') + \".properties\";\n+          if (classloader == null)\n+            is = ClassLoader.getSystemResourceAsStream(resourceName);\n+          else\n+            is = classloader.getResourceAsStream(resourceName);\n+          if (is != null)\n+            {\n+              foundBundle = new PropertyResourceBundle(is);\n+              foundBundle.parent = bundle;\n+              foundBundle.locale = locale;\n+            }\n+        }\n+      catch (IOException ex)\n+        {\n+        }\n+\n+    if (foundBundle != null)\n+      cache.put(localizedName, new SoftReference(foundBundle));\n+\n+    return foundBundle != null ? foundBundle : bundle;\n+  }\n \n   /**\n-   * This method should return all keys for which a resource exists.\n-   * @return An enumeration of the keys.\n+   * Tries to load a the bundle for a given locale, also loads the backup\n+   * locales with the same language.\n+   *\n+   * @param name the name\n+   * @param locale the locale, that must be used exactly\n+   * @param classloader the classloader\n+   * @param bundle the backup (parent) bundle\n+   * @return the resource bundle if it was loaded, otherwise the backup\n    */\n-  public abstract Enumeration getKeys();\n-}\n+  private static final ResourceBundle tryLocalBundle(String baseName,\n+                                                     Locale locale,\n+                                                     ClassLoader classloader,\n+                                                     ResourceBundle bundle,\n+                                                     HashMap cache)\n+  {\n+    final String language = locale.getLanguage();\n+    StringBuffer sb = new StringBuffer(60);\n+\n+    if (language.length() > 0)\n+      {\n+        final String country = locale.getCountry();\n+        sb.append(baseName).append('_').append(language);\n+        String name = sb.toString();\n+\n+        if (country.length() != 0)\n+          {\n+            bundle = tryBundle(name, new Locale(language),\n+                               classloader, bundle, cache);\n+            sb.append('_').append(country);\n+            name = sb.toString();\n+\n+            final String variant = locale.getVariant();\n+\n+            if (variant.length() != 0)\n+              {\n+                bundle = tryBundle(name, new Locale(language, country),\n+                                   classloader, bundle, cache);\n+                sb.append('_').append(variant);\n+                name = sb.toString();\n+              }\n+          }\n+        bundle = tryBundle(name, locale, classloader, bundle, cache);\n+      }\n+    return bundle;\n+  }\n+} // class ResourceBundle"}]}