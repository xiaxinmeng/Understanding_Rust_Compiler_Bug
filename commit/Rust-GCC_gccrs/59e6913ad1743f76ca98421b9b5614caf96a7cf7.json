{"sha": "59e6913ad1743f76ca98421b9b5614caf96a7cf7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTllNjkxM2FkMTc0M2Y3NmNhOTg0MjFiOWI1NjE0Y2FmOTZhN2NmNw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-04-29T15:56:12Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-04-29T15:56:12Z"}, "message": "tree-ssa-alias.c (finalize_ref_all_pointers): Remove.\n\n2008-04-29  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-alias.c (finalize_ref_all_pointers): Remove.\n\t(compute_may_aliases): Do not call finalize_ref_all_pointers.\n\t(compute_flow_insensitive_aliasing): Do not treat\n\tPTR_IS_REF_ALL pointers special.\n\t(get_smt_for): Likewise.\n\t(may_alias_p): Re-structure.\n\t(is_escape_site): A ref-all pointer conversion is not an escape site.\n\t* tree-ssa-structalias.c (find_what_p_points_to): Do not treat\n\tPTR_IS_REF_ALL pointers special.\n\t* tree-ssa-structalias.h (struct alias_info): Remove\n\tref_all_symbol_mem_tag field.\n\t(PTR_IS_REF_ALL): Remove.\n\nFrom-SVN: r134797", "tree": {"sha": "d7f4b389f0e4359e979111ba4e01da270894f66c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7f4b389f0e4359e979111ba4e01da270894f66c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59e6913ad1743f76ca98421b9b5614caf96a7cf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59e6913ad1743f76ca98421b9b5614caf96a7cf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59e6913ad1743f76ca98421b9b5614caf96a7cf7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59e6913ad1743f76ca98421b9b5614caf96a7cf7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c4e82de92ef875c57294b908d8cf185e931d841d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4e82de92ef875c57294b908d8cf185e931d841d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4e82de92ef875c57294b908d8cf185e931d841d"}], "stats": {"total": 237, "additions": 82, "deletions": 155}, "files": [{"sha": "e261305f13f6b3cc5e42dce86417fa883e275972", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59e6913ad1743f76ca98421b9b5614caf96a7cf7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59e6913ad1743f76ca98421b9b5614caf96a7cf7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=59e6913ad1743f76ca98421b9b5614caf96a7cf7", "patch": "@@ -1,3 +1,18 @@\n+2008-04-29  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-alias.c (finalize_ref_all_pointers): Remove.\n+\t(compute_may_aliases): Do not call finalize_ref_all_pointers.\n+\t(compute_flow_insensitive_aliasing): Do not treat\n+\tPTR_IS_REF_ALL pointers special.\n+\t(get_smt_for): Likewise.\n+\t(may_alias_p): Re-structure.\n+\t(is_escape_site): A ref-all pointer conversion is not an escape site.\n+\t* tree-ssa-structalias.c (find_what_p_points_to): Do not treat\n+\tPTR_IS_REF_ALL pointers special.\n+\t* tree-ssa-structalias.h (struct alias_info): Remove\n+\tref_all_symbol_mem_tag field.\n+\t(PTR_IS_REF_ALL): Remove.\n+\n 2008-04-29  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/36077"}, {"sha": "c52d75e633ba87ea3f4d679953b8b4c39fadf5c2", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 66, "deletions": 140, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59e6913ad1743f76ca98421b9b5614caf96a7cf7/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59e6913ad1743f76ca98421b9b5614caf96a7cf7/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=59e6913ad1743f76ca98421b9b5614caf96a7cf7", "patch": "@@ -196,7 +196,6 @@ static bitmap_obstack alias_bitmap_obstack;\n \n /* Local functions.  */\n static void compute_flow_insensitive_aliasing (struct alias_info *);\n-static void finalize_ref_all_pointers (struct alias_info *);\n static void dump_alias_stats (FILE *);\n static bool may_alias_p (tree, alias_set_type, tree, alias_set_type, bool);\n static tree create_memory_tag (tree type, bool is_type_tag);\n@@ -1800,12 +1799,6 @@ compute_may_aliases (void)\n      avoid invalid transformations on them.  */\n   maybe_create_global_var ();\n \n-  /* If the program contains ref-all pointers, finalize may-alias information\n-     for them.  This pass needs to be run after call-clobbering information\n-     has been computed.  */\n-  if (ai->ref_all_symbol_mem_tag)\n-    finalize_ref_all_pointers (ai);\n-\n   /* Compute memory partitions for every memory variable.  */\n   compute_memory_partitions ();\n \n@@ -2408,10 +2401,6 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n       tree tag = symbol_mem_tag (p_map->var);\n       tree var;\n \n-      /* Call-clobbering information is not finalized yet at this point.  */\n-      if (PTR_IS_REF_ALL (p_map->var))\n-\tcontinue;\n-\n       for (j = 0; j < ai->num_addressable_vars; j++)\n \t{\n \t  struct alias_map_d *v_map;\n@@ -2473,9 +2462,6 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n       tree tag1 = symbol_mem_tag (p_map1->var);\n       bitmap may_aliases1 = MTAG_ALIASES (tag1);\n \n-      if (PTR_IS_REF_ALL (p_map1->var))\n-\tcontinue;\n-\n       for (j = 0; j < ai->num_pointers; j++)\n \t{\n \t  struct alias_map_d *p_map2 = ai->pointers[j];\n@@ -2486,9 +2472,6 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n \t  if (tag1 == tag2)\n \t    continue;\n \n-\t  if (PTR_IS_REF_ALL (p_map2->var))\n-\t    continue;\n-\n \t  /* If the pointers may not point to each other, do nothing.  */\n \t  if (!may_alias_p (p_map1->var, p_map1->set, tag2, p_map2->set, true))\n \t    continue;\n@@ -2505,49 +2488,6 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n }\n \n \n-/* Finalize may-alias information for ref-all pointers.  Traverse all\n-   the addressable variables found in setup_pointers_and_addressables.\n-\n-   If flow-sensitive alias analysis has attached a name memory tag to\n-   a ref-all pointer, we will use it for the dereferences because that\n-   will have more precise aliasing information.  But if there is no\n-   name tag, we will use a special symbol tag that aliases all the\n-   call-clobbered addressable variables.  */\n-\n-static void\n-finalize_ref_all_pointers (struct alias_info *ai)\n-{\n-  size_t i;\n-\n-  /* First add the real call-clobbered variables.  */\n-  for (i = 0; i < ai->num_addressable_vars; i++)\n-    {\n-      tree var = ai->addressable_vars[i]->var;\n-      if (is_call_clobbered (var))\n-\tadd_may_alias (ai->ref_all_symbol_mem_tag, var);\n-    }\n-\n-  /* Then add the call-clobbered pointer memory tags.  See\n-     compute_flow_insensitive_aliasing for the rationale.  */\n-  for (i = 0; i < ai->num_pointers; i++)\n-    {\n-      tree ptr = ai->pointers[i]->var, tag;\n-      /* Avoid adding to self and clean up.  */\n-      if (PTR_IS_REF_ALL (ptr))\n-\t{\n-\t  struct ptr_info_def *pi = get_ptr_info (ptr);\n-\t  if (pi->is_dereferenced)\n-\t    pi->pt_anything = 0;\n-\t  continue;\n-\t}\n-      tag = symbol_mem_tag (ptr);\n-      if (is_call_clobbered (tag))\n-\tadd_may_alias (ai->ref_all_symbol_mem_tag, tag);\n-    }\n-\n-}\n-\n-\n /* Create a new alias set entry for VAR in AI->ADDRESSABLE_VARS.  */\n \n static void\n@@ -2842,85 +2782,85 @@ may_alias_p (tree ptr, alias_set_type mem_alias_set,\n       return false;\n     }\n \n-  gcc_assert (TREE_CODE (mem) == SYMBOL_MEMORY_TAG);\n-\n-  if (!DECL_NO_TBAA_P (ptr))\n+  /* If the pointed to memory has alias set zero, or the pointer\n+     is ref-all, or the pointer decl is marked that no TBAA is to\n+     be applied, the MEM can alias VAR.  */\n+  if (mem_alias_set == 0\n+      || DECL_POINTER_ALIAS_SET (ptr) == 0\n+      || TYPE_REF_CAN_ALIAS_ALL (TREE_TYPE (ptr))\n+      || DECL_NO_TBAA_P (ptr))\n     {\n-      alias_stats.tbaa_queries++;\n+      alias_stats.alias_mayalias++;\n+      alias_stats.simple_resolved++;\n+      return true;\n+    }\n \n-      /* If the pointed to memory has alias set zero or the pointer\n-\t is ref-all, the MEM can alias VAR.  */\n-      if (mem_alias_set == 0\n-\t  || PTR_IS_REF_ALL (ptr))\n-\t{\n-\t  alias_stats.alias_mayalias++;\n-\t  alias_stats.tbaa_resolved++;\n-\t  return true;\n-\t}\n+  gcc_assert (TREE_CODE (mem) == SYMBOL_MEMORY_TAG);\n \n-      /* If the alias sets don't conflict then MEM cannot alias VAR.  */\n-      if (mem_alias_set != var_alias_set\n-\t  && !alias_set_subset_of (mem_alias_set, var_alias_set))\n-\t{\n-\t  alias_stats.alias_noalias++;\n-\t  alias_stats.tbaa_resolved++;\n-\t  return false;\n-\t}\n+  alias_stats.tbaa_queries++;\n \n-      /* If VAR is a record or union type, PTR cannot point into VAR\n-\t unless there is some explicit address operation in the\n-\t program that can reference a field of the type pointed-to by\n-\t PTR.  This also assumes that the types of both VAR and PTR\n-\t are contained within the compilation unit, and that there is\n-\t no fancy addressing arithmetic associated with any of the\n-\t types involved.  */\n-      if (mem_alias_set != 0 && var_alias_set != 0)\n-\t{\n-\t  tree ptr_type = TREE_TYPE (ptr);\n-\t  tree var_type = TREE_TYPE (var);\n+  /* If the alias sets don't conflict then MEM cannot alias VAR.  */\n+  if (mem_alias_set != var_alias_set\n+      && !alias_set_subset_of (mem_alias_set, var_alias_set))\n+    {\n+      alias_stats.alias_noalias++;\n+      alias_stats.tbaa_resolved++;\n+      return false;\n+    }\n+\n+  /* If VAR is a record or union type, PTR cannot point into VAR\n+     unless there is some explicit address operation in the\n+     program that can reference a field of the type pointed-to by\n+     PTR.  This also assumes that the types of both VAR and PTR\n+     are contained within the compilation unit, and that there is\n+     no fancy addressing arithmetic associated with any of the\n+     types involved.  */\n+  if (mem_alias_set != 0 && var_alias_set != 0)\n+    {\n+      tree ptr_type = TREE_TYPE (ptr);\n+      tree var_type = TREE_TYPE (var);\n       \n-\t  /* The star count is -1 if the type at the end of the\n-\t     pointer_to chain is not a record or union type. */ \n-\t  if ((!alias_set_only) && \n-\t      ipa_type_escape_star_count_of_interesting_type (var_type) >= 0)\n-\t    {\n-\t      int ptr_star_count = 0;\n+      /* The star count is -1 if the type at the end of the\n+\t pointer_to chain is not a record or union type. */ \n+      if (!alias_set_only\n+\t  && ipa_type_escape_star_count_of_interesting_type (var_type) >= 0)\n+\t{\n+\t  int ptr_star_count = 0;\n \t  \n-\t      /* ipa_type_escape_star_count_of_interesting_type is a\n-\t\t little too restrictive for the pointer type, need to\n-\t\t allow pointers to primitive types as long as those\n-\t\t types cannot be pointers to everything.  */\n-\t      while (POINTER_TYPE_P (ptr_type))\n-\t\t{\n-\t\t  /* Strip the *s off.  */ \n-\t\t  ptr_type = TREE_TYPE (ptr_type);\n-\t\t  ptr_star_count++;\n-\t\t}\n+\t  /* ipa_type_escape_star_count_of_interesting_type is a\n+\t     little too restrictive for the pointer type, need to\n+\t     allow pointers to primitive types as long as those\n+\t     types cannot be pointers to everything.  */\n+\t  while (POINTER_TYPE_P (ptr_type))\n+\t    {\n+\t      /* Strip the *s off.  */ \n+\t      ptr_type = TREE_TYPE (ptr_type);\n+\t      ptr_star_count++;\n+\t    }\n \t  \n-\t      /* There does not appear to be a better test to see if\n-\t\t the pointer type was one of the pointer to everything\n-\t\t types.  */\n-\t      if (ptr_star_count > 0)\n-\t\t{\n-\t\t  alias_stats.structnoaddress_queries++;\n-\t\t  if (ipa_type_escape_field_does_not_clobber_p (var_type, \n-\t\t\t\t\t\t\t\tTREE_TYPE (ptr)))\n-\t\t    {\n-\t\t      alias_stats.structnoaddress_resolved++;\n-\t\t      alias_stats.alias_noalias++;\n-\t\t      return false;\n-\t\t    }\n-\t\t}\n-\t      else if (ptr_star_count == 0)\n+\t  /* There does not appear to be a better test to see if\n+\t     the pointer type was one of the pointer to everything\n+\t     types.  */\n+\t  if (ptr_star_count > 0)\n+\t    {\n+\t      alias_stats.structnoaddress_queries++;\n+\t      if (ipa_type_escape_field_does_not_clobber_p (var_type, \n+\t\t\t\t\t\t\t    TREE_TYPE (ptr)))\n \t\t{\n-\t\t  /* If PTR_TYPE was not really a pointer to type, it cannot \n-\t\t     alias.  */ \n-\t\t  alias_stats.structnoaddress_queries++;\n \t\t  alias_stats.structnoaddress_resolved++;\n \t\t  alias_stats.alias_noalias++;\n \t\t  return false;\n \t\t}\n \t    }\n+\t  else if (ptr_star_count == 0)\n+\t    {\n+\t      /* If PTR_TYPE was not really a pointer to type, it cannot \n+\t\t alias.  */ \n+\t      alias_stats.structnoaddress_queries++;\n+\t      alias_stats.structnoaddress_resolved++;\n+\t      alias_stats.alias_noalias++;\n+\t      return false;\n+\t    }\n \t}\n     }\n \n@@ -3026,12 +2966,6 @@ is_escape_site (tree stmt)\n \t     pointer escapes since we can't track the integer.  */\n \t  if (POINTER_TYPE_P (from) && !POINTER_TYPE_P (to))\n \t    return ESCAPE_BAD_CAST;\n-\n-\t  /* Same if the RHS is a conversion between a regular pointer and a\n-\t     ref-all pointer since we can't track the SMT of the former.  */\n-\t  if (POINTER_TYPE_P (from) && !TYPE_REF_CAN_ALIAS_ALL (from)\n-\t      && POINTER_TYPE_P (to) && TYPE_REF_CAN_ALIAS_ALL (to))\n-\t    return ESCAPE_BAD_CAST;\n \t}\n \n       /* If the LHS is an SSA name, it can't possibly represent a non-local\n@@ -3137,14 +3071,6 @@ get_smt_for (tree ptr, struct alias_info *ai)\n   tree tag_type = TREE_TYPE (TREE_TYPE (ptr));\n   alias_set_type tag_set = get_alias_set (tag_type);\n \n-  /* We use a unique memory tag for all the ref-all pointers.  */\n-  if (PTR_IS_REF_ALL (ptr))\n-    {\n-      if (!ai->ref_all_symbol_mem_tag)\n-\tai->ref_all_symbol_mem_tag = create_memory_tag (void_type_node, true);\n-      return ai->ref_all_symbol_mem_tag;\n-    }\n-\n   /* To avoid creating unnecessary memory tags, only create one memory tag\n      per alias set class.  Note that it may be tempting to group\n      memory tags based on conflicting alias sets instead of"}, {"sha": "ddcf4982690dae9be710bbe058f8de08dc475cd6", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59e6913ad1743f76ca98421b9b5614caf96a7cf7/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59e6913ad1743f76ca98421b9b5614caf96a7cf7/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=59e6913ad1743f76ca98421b9b5614caf96a7cf7", "patch": "@@ -4969,17 +4969,9 @@ find_what_p_points_to (tree p)\n \n \t  /* Instead of using pt_anything, we merge in the SMT aliases\n \t     for the underlying SMT.  In addition, if they could have\n-\t     pointed to anything, they could point to global memory.\n-\t     But we cannot do that for ref-all pointers because these\n-\t     aliases have not been computed yet.  */\n+\t     pointed to anything, they could point to global memory.  */\n \t  if (was_pt_anything)\n \t    {\n-\t      if (PTR_IS_REF_ALL (p))\n-\t\t{\n-\t\t  pi->pt_anything = 1;\n-\t\t  return false;\n-\t\t}\n-\n \t      merge_smts_into (p, finished_solution);\n \t      pi->pt_global_mem = 1;\n \t    }"}, {"sha": "737135bdc873d6dc1d613d2ae3f4723e9cc563c0", "filename": "gcc/tree-ssa-structalias.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59e6913ad1743f76ca98421b9b5614caf96a7cf7/gcc%2Ftree-ssa-structalias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59e6913ad1743f76ca98421b9b5614caf96a7cf7/gcc%2Ftree-ssa-structalias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.h?ref=59e6913ad1743f76ca98421b9b5614caf96a7cf7", "patch": "@@ -21,9 +21,6 @@\n #ifndef TREE_SSA_STRUCTALIAS_H\n #define TREE_SSA_STRUCTALIAS_H\n \n-/* True if the data pointed to by PTR can alias anything.  */\n-#define PTR_IS_REF_ALL(PTR) TYPE_REF_CAN_ALIAS_ALL (TREE_TYPE (PTR))\n-\n struct constraint;\n typedef struct constraint *constraint_t;\n \n@@ -57,9 +54,6 @@ struct alias_info\n \n   /* Pointers that have been used in an indirect load operation.  */\n   struct pointer_set_t *dereferenced_ptrs_load;\n-\n-  /* Memory tag for all the PTR_IS_REF_ALL pointers.  */\n-  tree ref_all_symbol_mem_tag;\n };\n \n /* In tree-ssa-alias.c.  */"}]}