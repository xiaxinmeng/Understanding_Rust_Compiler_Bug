{"sha": "d2f8402a0886db2b2d33ed09e51cf27cc85db5e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJmODQwMmEwODg2ZGIyYjJkMzNlZDA5ZTUxY2YyN2NjODVkYjVlNA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-11-22T16:39:37Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-11-22T16:39:37Z"}, "message": "PR tree-optimization/92501 - strncmp with constant unterminated arrays not folded\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/92501\n\t* gcc.dg/strcmpopt_7.c: New test.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/92501\n\t* gimple-fold.c ((gimple_fold_builtin_string_compare): Let strncmp\n\thandle unterminated arrays.  Rename local variables for clarity.\n\nFrom-SVN: r278621", "tree": {"sha": "e3ef393eca7df548503d7fd5232b88831573fd91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3ef393eca7df548503d7fd5232b88831573fd91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2f8402a0886db2b2d33ed09e51cf27cc85db5e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2f8402a0886db2b2d33ed09e51cf27cc85db5e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2f8402a0886db2b2d33ed09e51cf27cc85db5e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2f8402a0886db2b2d33ed09e51cf27cc85db5e4/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aa84ec8415bd413b693e5ea0610e98f3b6216ad5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa84ec8415bd413b693e5ea0610e98f3b6216ad5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa84ec8415bd413b693e5ea0610e98f3b6216ad5"}], "stats": {"total": 222, "additions": 195, "deletions": 27}, "files": [{"sha": "9fbe728baf0150ecaab8dbb329e600cc86b8ab36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2f8402a0886db2b2d33ed09e51cf27cc85db5e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2f8402a0886db2b2d33ed09e51cf27cc85db5e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2f8402a0886db2b2d33ed09e51cf27cc85db5e4", "patch": "@@ -1,3 +1,9 @@\n+2019-11-22  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/92501\n+\t* gimple-fold.c ((gimple_fold_builtin_string_compare): Let strncmp\n+\thandle unterminated arrays.  Rename local variables for clarity.\n+\n 2019-11-22  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* config/gcn/gcn.c (gcn_hsa_declare_function_name): Calculate"}, {"sha": "cfae9db60432a6f914c6195eda7003d84d927445", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 65, "deletions": 27, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2f8402a0886db2b2d33ed09e51cf27cc85db5e4/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2f8402a0886db2b2d33ed09e51cf27cc85db5e4/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=d2f8402a0886db2b2d33ed09e51cf27cc85db5e4", "patch": "@@ -2323,8 +2323,7 @@ gimple_load_first_char (location_t loc, tree str, gimple_seq *stmts)\n   return var;\n }\n \n-/* Fold a call to the str{n}{case}cmp builtin pointed by GSI iterator.\n-   FCODE is the name of the builtin.  */\n+/* Fold a call to the str{n}{case}cmp builtin pointed by GSI iterator.  */\n \n static bool\n gimple_fold_builtin_string_compare (gimple_stmt_iterator *gsi)\n@@ -2337,18 +2336,19 @@ gimple_fold_builtin_string_compare (gimple_stmt_iterator *gsi)\n   tree str1 = gimple_call_arg (stmt, 0);\n   tree str2 = gimple_call_arg (stmt, 1);\n   tree lhs = gimple_call_lhs (stmt);\n-  HOST_WIDE_INT length = -1;\n+  tree len = NULL_TREE;\n+  unsigned HOST_WIDE_INT bound = HOST_WIDE_INT_M1U;\n \n   /* Handle strncmp and strncasecmp functions.  */\n   if (gimple_call_num_args (stmt) == 3)\n     {\n-      tree len = gimple_call_arg (stmt, 2);\n+      len = gimple_call_arg (stmt, 2);\n       if (tree_fits_uhwi_p (len))\n-\tlength = tree_to_uhwi (len);\n+\tbound = tree_to_uhwi (len);\n     }\n \n   /* If the LEN parameter is zero, return zero.  */\n-  if (length == 0)\n+  if (bound == 0)\n     {\n       replace_call_with_value (gsi, integer_zero_node);\n       return true;\n@@ -2361,8 +2361,32 @@ gimple_fold_builtin_string_compare (gimple_stmt_iterator *gsi)\n       return true;\n     }\n \n-  const char *p1 = c_getstr (str1);\n-  const char *p2 = c_getstr (str2);\n+  /* Initially set to the number of characters, including the terminating\n+     nul if each array has one.   LENx == strnlen (Sx, LENx) implies that\n+     the array Sx is not terminated by a nul.\n+     For nul-terminated strings then adjusted to their length so that\n+     LENx == NULPOSx holds.  */\n+  unsigned HOST_WIDE_INT len1 = HOST_WIDE_INT_MAX, len2 = len1;\n+  const char *p1 = c_getstr (str1, &len1);\n+  const char *p2 = c_getstr (str2, &len2);\n+\n+  /* The position of the terminating nul character if one exists, otherwise\n+     a value greater than LENx.  */\n+  unsigned HOST_WIDE_INT nulpos1 = HOST_WIDE_INT_MAX, nulpos2 = nulpos1;\n+\n+  if (p1)\n+    {\n+      size_t n = strnlen (p1, len1);\n+      if (n < len1)\n+\tlen1 = nulpos1 = n;\n+    }\n+\n+  if (p2)\n+    {\n+      size_t n = strnlen (p2, len2);\n+      if (n < len2)\n+\tlen2 = nulpos2 = n;\n+    }\n \n   /* For known strings, return an immediate value.  */\n   if (p1 && p2)\n@@ -2374,17 +2398,30 @@ gimple_fold_builtin_string_compare (gimple_stmt_iterator *gsi)\n \t{\n \tcase BUILT_IN_STRCMP:\n \tcase BUILT_IN_STRCMP_EQ:\n-\t  {\n-\t    r = strcmp (p1, p2);\n-\t    known_result = true;\n+\t  if (len1 != nulpos1 || len2 != nulpos2)\n \t    break;\n-\t  }\n+\n+\t  r = strcmp (p1, p2);\n+\t  known_result = true;\n+\t  break;\n+\n \tcase BUILT_IN_STRNCMP:\n \tcase BUILT_IN_STRNCMP_EQ:\n \t  {\n-\t    if (length == -1)\n+\t    /* Reduce the bound to be no more than the length\n+\t       of the shorter of the two strings, or the sizes\n+\t       of the unterminated arrays.  */\n+\t    unsigned HOST_WIDE_INT n = bound;\n+\n+\t    if (len1 == nulpos1 && len1 < n)\n+\t      n = len1 + 1;\n+\t    if (len2 == nulpos2 && len2 < n)\n+\t      n = len2 + 1;\n+\n+\t    if (MIN (nulpos1, nulpos2) + 1 < n)\n \t      break;\n-\t    r = strncmp (p1, p2, length);\n+\n+\t    r = strncmp (p1, p2, n);\n \t    known_result = true;\n \t    break;\n \t  }\n@@ -2394,9 +2431,9 @@ gimple_fold_builtin_string_compare (gimple_stmt_iterator *gsi)\n \t  break;\n \tcase BUILT_IN_STRNCASECMP:\n \t  {\n-\t    if (length == -1)\n+\t    if (bound == HOST_WIDE_INT_M1U)\n \t      break;\n-\t    r = strncmp (p1, p2, length);\n+\t    r = strncmp (p1, p2, bound);\n \t    if (r == 0)\n \t      known_result = true;\n \t    break;\n@@ -2412,15 +2449,15 @@ gimple_fold_builtin_string_compare (gimple_stmt_iterator *gsi)\n \t}\n     }\n \n-  bool nonzero_length = length >= 1\n+  bool nonzero_bound = (bound >= 1 && bound < HOST_WIDE_INT_M1U)\n     || fcode == BUILT_IN_STRCMP\n     || fcode == BUILT_IN_STRCMP_EQ\n     || fcode == BUILT_IN_STRCASECMP;\n \n   location_t loc = gimple_location (stmt);\n \n   /* If the second arg is \"\", return *(const unsigned char*)arg1.  */\n-  if (p2 && *p2 == '\\0' && nonzero_length)\n+  if (p2 && *p2 == '\\0' && nonzero_bound)\n     {\n       gimple_seq stmts = NULL;\n       tree var = gimple_load_first_char (loc, str1, &stmts);\n@@ -2435,7 +2472,7 @@ gimple_fold_builtin_string_compare (gimple_stmt_iterator *gsi)\n     }\n \n   /* If the first arg is \"\", return -*(const unsigned char*)arg2.  */\n-  if (p1 && *p1 == '\\0' && nonzero_length)\n+  if (p1 && *p1 == '\\0' && nonzero_bound)\n     {\n       gimple_seq stmts = NULL;\n       tree var = gimple_load_first_char (loc, str2, &stmts);\n@@ -2454,9 +2491,9 @@ gimple_fold_builtin_string_compare (gimple_stmt_iterator *gsi)\n       return true;\n     }\n \n-  /* If len parameter is one, return an expression corresponding to\n+  /* If BOUND is one, return an expression corresponding to\n      (*(const unsigned char*)arg2 - *(const unsigned char*)arg1).  */\n-  if (fcode == BUILT_IN_STRNCMP && length == 1)\n+  if (fcode == BUILT_IN_STRNCMP && bound == 1)\n     {\n       gimple_seq stmts = NULL;\n       tree temp1 = gimple_load_first_char (loc, str1, &stmts);\n@@ -2480,12 +2517,13 @@ gimple_fold_builtin_string_compare (gimple_stmt_iterator *gsi)\n       return true;\n     }\n \n-  /* If length is larger than the length of one constant string, \n-     replace strncmp with corresponding strcmp */ \n-  if (fcode == BUILT_IN_STRNCMP \n-      && length > 0\n-      && ((p2 && (size_t) length > strlen (p2)) \n-          || (p1 && (size_t) length > strlen (p1))))\n+  /* If BOUND is greater than the length of one constant string,\n+     and the other argument is also a nul-terminated string, replace\n+     strncmp with strcmp.  */\n+  if (fcode == BUILT_IN_STRNCMP\n+      && bound > 0 && bound < HOST_WIDE_INT_M1U\n+      && ((p2 && len2 < bound && len2 == nulpos2)\n+\t  || (p1 && len1 < bound && len1 == nulpos1)))\n     {\n       tree fn = builtin_decl_implicit (BUILT_IN_STRCMP);\n       if (!fn)"}, {"sha": "f602c9b27ad7242584c15315bafd2453fbd68d71", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2f8402a0886db2b2d33ed09e51cf27cc85db5e4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2f8402a0886db2b2d33ed09e51cf27cc85db5e4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d2f8402a0886db2b2d33ed09e51cf27cc85db5e4", "patch": "@@ -1,3 +1,8 @@\n+2019-11-22  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/92501\n+\t* gcc.dg/strcmpopt_7.c: New test.\n+\n 2019-11-22  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.dg/vect/vect-widen-mult-u8.c: Disable epilogue loop"}, {"sha": "5e713170e6fc425a8a636394699c96443cf5eebf", "filename": "gcc/testsuite/gcc.dg/strcmpopt_7.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2f8402a0886db2b2d33ed09e51cf27cc85db5e4/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2f8402a0886db2b2d33ed09e51cf27cc85db5e4/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_7.c?ref=d2f8402a0886db2b2d33ed09e51cf27cc85db5e4", "patch": "@@ -0,0 +1,119 @@\n+/* PR tree-optimization/92501 - strncmp with constant unterminated arrays\n+   not folded\n+   { dg-do compile }\n+   { dg-options \"-O1 -Wall -fdump-tree-forwprop1\" } */\n+\n+/* Unterminated arrays of the size encoded in name.  */\n+const char a1[] = { '1' };\n+const char a12[] = { '1', '2' };\n+const char a112[] = { '1', '1', '2' };\n+const char a123[] = { '1', '2', '3' };\n+\n+/* Nul-terminated strings of the length encoded in name.  */\n+const char s[] = \"\";\n+const char s1[] = \"1\";\n+const char s12[] = \"12\";\n+const char s112[] = \"112\";\n+const char s123[] = \"123\";\n+\n+extern void failure_on_line (int);\n+\n+/* Verify that the test in 'if (EQL strncmp (S, T, N))' is folded.  */\n+#define T(eql, s, t, n) do {\t\t\t\\\n+    if (!(eql __builtin_strncmp (s, t, n)))\t\\\n+      failure_on_line (__LINE__);\t\t\\\n+  } while (0)\n+\n+\n+void test (void)\n+{\n+  /* Mixed array and string.  */\n+  T (0 ==, a1, \"\", 0);\n+  T (0 ==, a1, s, 0);\n+  T (0 !=, a1, \"\", 1);\n+  T (0 !=, a1, s, 1);\n+\n+  /* The following two are safe to fold because while strncmp compares\n+     at most N bytes it doesn't compare any bytes past the first nul.  */\n+  T (0 !=, a1, \"\", 9);\n+  T (0 !=, a1, s, 9);\n+\n+  T (0 ==, a1, \"1\", 0);\n+  T (0 ==, a1, s1, 0);\n+  T (0 ==, a1, \"1\", 1);\n+  T (0 ==, a1, s1, 1);\n+  T (0 ==, a1, \"12\", 1);\n+  T (0 ==, a1, s12, 1);\n+\n+     /* As above, the following three are also safe to fold.  */\n+  T (0 !=, a1, s12 + 1, 1);\n+  T (0 !=, a1, s12 + 1, 2);\n+  T (0 !=, a1, s12 + 1, 9);\n+\n+  T (0 ==, a12, s, 0);\n+  T (0 ==, a12, \"\", 0);\n+  T (0 ==, a12, s1, 0);\n+  T (0 ==, a12, \"1\", 0);\n+  T (0 ==, a12, s1, 1);\n+  T (0 ==, a12, \"1\", 1);\n+  T (0 !=, a12, s1, 2);\n+  T (0 !=, a12, \"1\", 2);\n+  T (0 ==, a12, s12, 0);\n+  T (0 ==, a12, \"12\", 0);\n+  T (0 ==, a12, s12, 1);\n+  T (0 ==, a12, \"12\", 1);\n+  T (0 ==, a12, s12, 2);\n+  T (0 ==, a12, \"12\", 2);\n+  T (0 ==, a12, s123, 2);\n+  T (0 ==, a12, \"123\", 2);\n+\n+  T (0 ==, a12 + 0, s123 + 1, 0);\n+  T (0 !=, a12 + 0, s123 + 1, 1);\n+  T (0 !=, a12 + 0, s123 + 1, 2);\n+  T (0 ==, a12 + 1, s123 + 0, 0);\n+  T (0 !=, a12 + 1, s123 + 0, 1);\n+  T (0 !=, a12 + 1, s123 + 0, 2);\n+  T (0 ==, a12 + 1, s123 + 1, 1);\n+  T (0 !=, a12 + 1, s123 + 2, 1);\n+  T (0 !=, a12 + 1, s123 + 3, 1);\n+\n+  T (0 ==, a12 + 1, \"123\" + 1, 1);\n+  T (0 !=, a12 + 1, \"123\" + 2, 1);\n+  T (0 !=, a12 + 1, \"123\" + 3, 1);\n+  T (0 !=, a12 + 1, \"123\" + 3, 9);\n+\n+  /* Both arguments arrays.  */\n+  T (0 ==, a112 + 0, a1, 1);\n+  T (0 ==, a112 + 1, a1, 1);\n+  T (0 !=, a112 + 2, a1, 1);\n+\n+  T (0 ==, a1, a112 + 0, 1);\n+  T (0 ==, a1, a112 + 1, 1);\n+  T (0 !=, a1, a112 + 2, 1);\n+\n+  T (0 ==, a112 + 0, a12, 0);\n+  T (0 ==, a112 + 0, a12, 1);\n+  T (0 !=, a112 + 0, a12, 2);\n+\n+  T (0 ==, a112 + 1, a12, 2);\n+  T (0 !=, a112 + 1, a12 + 1, 1);\n+  T (0 ==, a112 + 2, a12 + 1, 1);\n+\n+  /* Mixed array and string.  */\n+  T (0 ==, s112 + 0, a12, 0);\n+  T (0 ==, s112 + 0, a12, 1);\n+  T (0 !=, s112 + 0, a12, 2);\n+\n+  T (0 ==, s112 + 1, a12, 0);\n+  T (0 ==, s112 + 1, a12, 1);\n+  T (0 ==, s112 + 1, a12, 2);\n+  T (0 !=, s112 + 2, a12, 2);\n+\n+  T (0 ==, a112 + 0, s1, 1);\n+  T (0 ==, a112 + 1, s1, 1);\n+  T (0 !=, a112 + 2, s1, 1);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"strcmp\" \"forwprop1\" } }\n+   { dg-final { scan-tree-dump-not \"strncmp\" \"forwprop1\" } }\n+   { dg-final { scan-tree-dump-not \"failure_on_line_\" \"forwprop1\" } } */"}]}