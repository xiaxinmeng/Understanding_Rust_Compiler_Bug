{"sha": "72c6da8a74f1ab9974649a16140db1c046c12ec8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJjNmRhOGE3NGYxYWI5OTc0NjQ5YTE2MTQwZGIxYzA0NmMxMmVjOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-02-03T00:39:00Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-02-03T00:39:00Z"}, "message": "Replace call to abort or __objc_fatal functions with call to objc_error function throughout the complete file.\n\nReplace call to abort or __objc_fatal functions with call to\nobjc_error function throughout the complete file.\n(__objc_finish_read_root_object): Use hash table instead of list.\n\nFrom-SVN: r13585", "tree": {"sha": "afd8362fbb6ab61e1f68b0435c381ff439154d3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afd8362fbb6ab61e1f68b0435c381ff439154d3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72c6da8a74f1ab9974649a16140db1c046c12ec8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72c6da8a74f1ab9974649a16140db1c046c12ec8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72c6da8a74f1ab9974649a16140db1c046c12ec8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72c6da8a74f1ab9974649a16140db1c046c12ec8/comments", "author": null, "committer": null, "parents": [{"sha": "5b9b7438f39e810e638b56a3b5ce89c4de8e77a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b9b7438f39e810e638b56a3b5ce89c4de8e77a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b9b7438f39e810e638b56a3b5ce89c4de8e77a0"}], "stats": {"total": 110, "additions": 63, "deletions": 47}, "files": [{"sha": "2edb056acbac1ed61163e167cc736a6bd9bf46cb", "filename": "gcc/objc/archive.c", "status": "modified", "additions": 63, "deletions": 47, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72c6da8a74f1ab9974649a16140db1c046c12ec8/gcc%2Fobjc%2Farchive.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72c6da8a74f1ab9974649a16140db1c046c12ec8/gcc%2Fobjc%2Farchive.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Farchive.c?ref=72c6da8a74f1ab9974649a16140db1c046c12ec8", "patch": "@@ -1,5 +1,5 @@\n /* GNU Objective C Runtime archiving\n-   Copyright (C) 1993, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Kresten Krab Thorup\n \n This file is part of GNU CC.\n@@ -37,11 +37,6 @@ extern int fflush(FILE*);\n #define PTR2LONG(P) (((char*)(P))-(char*)0)\n #define LONG2PTR(L) (((char*)0)+(L))\n \n-#define __objc_fatal(format, args...) \\\n- { fprintf(stderr, \"archiving: \"); \\\n-   fprintf(stderr, format, ## args); \\\n-   fprintf(stderr, \"\\n\"); abort(); }\n-\n /* Declare some functions... */\n \n static int\n@@ -362,7 +357,8 @@ __objc_write_extension (struct objc_typed_stream* stream, unsigned char code)\n       return (*stream->write)(stream->physical, &buf, 1);\n     }\n   else \n-    abort();\n+    objc_error(nil, OBJC_ERR_BAD_OPCODE,\n+\t       \"__objc_write_extension: bad opcode %c\\n\", code);\n }\n \n __inline__ int\n@@ -397,7 +393,8 @@ objc_write_root_object (struct objc_typed_stream* stream, id object)\n {\n   int len;\n   if (stream->writing_root_p)\n-    __objc_fatal (\"objc_write_root_object called recursively\")\n+    objc_error (nil, OBJC_ERR_RECURSE_ROOT, \n+\t\t\"objc_write_root_object called recursively\");\n   else\n     {\n       stream->writing_root_p = 1;\n@@ -524,8 +521,9 @@ objc_read_char (struct objc_typed_stream* stream, char* val)\n \t}\n \n       else\n-\t__objc_fatal(\"expected 8bit signed int, got %dbit int\",\n-\t\t     (int)(buf&_B_NUMBER)*8);\n+\tobjc_error(nil, OBJC_ERR_BAD_DATA,\n+\t\t   \"expected 8bit signed int, got %dbit int\",\n+\t\t   (int)(buf&_B_NUMBER)*8);\n     }\n   return len;\n }\n@@ -545,8 +543,9 @@ objc_read_unsigned_char (struct objc_typed_stream* stream, unsigned char* val)\n \tlen = (*stream->read)(stream->physical, val, 1);\n \n       else\n-\t__objc_fatal(\"expected 8bit unsigned int, got %dbit int\",\n-\t\t     (int)(buf&_B_NUMBER)*8);\n+\tobjc_error(nil, OBJC_ERR_BAD_DATA,\n+\t\t   \"expected 8bit unsigned int, got %dbit int\",\n+\t\t   (int)(buf&_B_NUMBER)*8);\n     }\n   return len;\n }\n@@ -566,7 +565,8 @@ objc_read_short (struct objc_typed_stream* stream, short* value)\n \t  int pos = 1;\n \t  int nbytes = buf[0] & _B_NUMBER;\n \t  if (nbytes > sizeof (short))\n-\t    __objc_fatal(\"expected short, got bigger (%dbits)\", nbytes*8);\n+\t    objc_error(nil, OBJC_ERR_BAD_DATA,\n+\t\t       \"expected short, got bigger (%dbits)\", nbytes*8);\n \t  len = (*stream->read)(stream->physical, buf+1, nbytes);\n \t  (*value) = 0;\n \t  while (pos <= nbytes)\n@@ -594,7 +594,8 @@ objc_read_unsigned_short (struct objc_typed_stream* stream,\n \t  int pos = 1;\n \t  int nbytes = buf[0] & _B_NUMBER;\n \t  if (nbytes > sizeof (short))\n-\t    __objc_fatal(\"expected short, got int or bigger\");\n+\t    objc_error(nil, OBJC_ERR_BAD_DATA,\n+\t\t       \"expected short, got int or bigger\");\n \t  len = (*stream->read)(stream->physical, buf+1, nbytes);\n \t  (*value) = 0;\n \t  while (pos <= nbytes)\n@@ -620,7 +621,7 @@ objc_read_int (struct objc_typed_stream* stream, int* value)\n \t  int pos = 1;\n \t  int nbytes = buf[0] & _B_NUMBER;\n \t  if (nbytes > sizeof (int))\n-\t    __objc_fatal(\"expected int, got bigger\");\n+\t    objc_error(nil, OBJC_ERR_BAD_DATA, \"expected int, got bigger\");\n \t  len = (*stream->read)(stream->physical, buf+1, nbytes);\n \t  (*value) = 0;\n \t  while (pos <= nbytes)\n@@ -647,7 +648,7 @@ objc_read_long (struct objc_typed_stream* stream, long* value)\n \t  int pos = 1;\n \t  int nbytes = buf[0] & _B_NUMBER;\n \t  if (nbytes > sizeof (long))\n-\t    __objc_fatal(\"expected long, got bigger\");\n+\t    objc_error(nil, OBJC_ERR_BAD_DATA, \"expected long, got bigger\");\n \t  len = (*stream->read)(stream->physical, buf+1, nbytes);\n \t  (*value) = 0;\n \t  while (pos <= nbytes)\n@@ -667,7 +668,7 @@ __objc_read_nbyte_uint (struct objc_typed_stream* stream,\n   unsigned char buf[sizeof(unsigned int)+1];\n \n   if (nbytes > sizeof (int))\n-    __objc_fatal(\"expected int, got bigger\");\n+    objc_error(nil, OBJC_ERR_BAD_DATA, \"expected int, got bigger\");\n \n   len = (*stream->read)(stream->physical, buf, nbytes);\n   (*val) = 0;\n@@ -703,7 +704,7 @@ __objc_read_nbyte_ulong (struct objc_typed_stream* stream,\n   unsigned char buf[sizeof(unsigned long)+1];\n \n   if (nbytes > sizeof (long))\n-    __objc_fatal(\"expected long, got bigger\");\n+    objc_error(nil, OBJC_ERR_BAD_DATA, \"expected long, got bigger\");\n \n   len = (*stream->read)(stream->physical, buf, nbytes);\n   (*val) = 0;\n@@ -784,7 +785,8 @@ objc_read_string (struct objc_typed_stream* stream,\n \tbreak;\n \t\n       default:\n-\t__objc_fatal(\"expected string, got opcode %c\\n\", (buf[0]&_B_CODE));\n+\tobjc_error(nil, OBJC_ERR_BAD_DATA,\n+\t\t   \"expected string, got opcode %c\\n\", (buf[0]&_B_CODE));\n       }\n     }\n \n@@ -829,13 +831,14 @@ objc_read_object (struct objc_typed_stream* stream, id* object)\n \t  /* check null-byte */\n \t  len = (*stream->read)(stream->physical, buf, 1);\n \t  if (buf[0] != '\\0')\n-\t    __objc_fatal(\"expected null-byte, got opcode %c\", buf[0]);\n+\t    objc_error(nil, OBJC_ERR_BAD_DATA,\n+\t\t       \"expected null-byte, got opcode %c\", buf[0]);\n \t}\n \n       else if ((buf[0]&_B_CODE) == _B_UCOMM)\n \t{\n \t  if (key)\n-\t    __objc_fatal(\"cannot register use upcode...\");\n+\t    objc_error(nil, OBJC_ERR_BAD_KEY, \"cannot register use upcode...\");\n \t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n \t  (*object) = hash_value_for_key (stream->object_table, LONG2PTR(key));\n \t}\n@@ -853,13 +856,15 @@ objc_read_object (struct objc_typed_stream* stream, id* object)\n       else if (buf[0] == (_B_EXT | _BX_OBJROOT)) /* a root object */\n \t{\n \t  if (key)\n-\t    __objc_fatal(\"cannot register root object...\");\n+\t    objc_error(nil, OBJC_ERR_BAD_KEY,\n+\t\t       \"cannot register root object...\");\n \t  len = objc_read_object (stream, object);\n \t  __objc_finish_read_root_object (stream);\n \t}\n \n       else\n-\t__objc_fatal(\"expected object, got opcode %c\", buf[0]);\n+\tobjc_error(nil, OBJC_ERR_BAD_DATA,\n+\t\t   \"expected object, got opcode %c\", buf[0]);\n     }\n   return len;\n }\n@@ -900,15 +905,17 @@ objc_read_class (struct objc_typed_stream* stream, Class* class)\n       else if ((buf[0]&_B_CODE) == _B_UCOMM)\n \t{\n \t  if (key)\n-\t    __objc_fatal(\"cannot register use upcode...\");\n+\t    objc_error(nil, OBJC_ERR_BAD_KEY, \"cannot register use upcode...\");\n \t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n \t  (*class) = hash_value_for_key (stream->stream_table, LONG2PTR(key));\n \t  if (!*class)\n-\t    __objc_fatal(\"cannot find class for key %lu\", key);\n+\t    objc_error(nil, OBJC_ERR_BAD_CLASS,\n+\t\t       \"cannot find class for key %lu\", key);\n \t}\n \n       else\n-\t__objc_fatal(\"expected class, got opcode %c\", buf[0]);\n+\tobjc_error(nil, OBJC_ERR_BAD_DATA,\n+\t\t   \"expected class, got opcode %c\", buf[0]);\n     }\n   return len;\n }\n@@ -952,14 +959,15 @@ objc_read_selector (struct objc_typed_stream* stream, SEL* selector)\n       else if ((buf[0]&_B_CODE) == _B_UCOMM)\n \t{\n \t  if (key)\n-\t    __objc_fatal(\"cannot register use upcode...\");\n+\t    objc_error(nil, OBJC_ERR_BAD_KEY, \"cannot register use upcode...\");\n \t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n \t  (*selector) = hash_value_for_key (stream->stream_table, \n \t\t\t\t\t    LONG2PTR(key));\n \t}\n \n       else\n-\t__objc_fatal(\"expected selector, got opcode %c\", buf[0]);\n+\tobjc_error(nil, OBJC_ERR_BAD_DATA,\n+\t\t   \"expected selector, got opcode %c\", buf[0]);\n     }\n   return len;\n }\n@@ -1057,8 +1065,8 @@ objc_write_type(TypedStream* stream, const char* type, const void* data)\n     }\n \n   default:\n-    fprintf(stderr, \"objc_write_type: cannot parse typespec: %s\\n\", type);\n-    abort();\n+    objc_error(nil, OBJC_ERR_BAD_TYPE,\n+\t       \"objc_write_type: cannot parse typespec: %s\\n\", type);\n   }\n }\n \n@@ -1150,8 +1158,8 @@ objc_read_type(TypedStream* stream, const char* type, void* data)\n     }\n \n   default:\n-    fprintf(stderr, \"objc_read_type: cannot parse typespec: %s\\n\", type);\n-    abort();\n+    objc_error(nil, OBJC_ERR_BAD_TYPE,\n+\t       \"objc_read_type: cannot parse typespec: %s\\n\", type);\n   }\n }\n \n@@ -1246,13 +1254,13 @@ objc_write_types (TypedStream* stream, const char* type, ...)\n \t  res = objc_write_array (stream, t, len, va_arg(args, void*));\n \t  t = objc_skip_typespec (t);\n \t  if (*t != _C_ARY_E)\n-\t    __objc_fatal(\"expected `]', got: %s\", t);\n+\t    objc_error(nil, OBJC_ERR_BAD_TYPE, \"expected `]', got: %s\", t);\n \t}\n \tbreak; \n \t\n       default:\n-\tfprintf(stderr, \"objc_write_types: cannot parse typespec: %s\\n\", type);\n-\tabort();\n+\tobjc_error(nil, OBJC_ERR_BAD_TYPE, \n+\t\t   \"objc_write_types: cannot parse typespec: %s\\n\", type);\n       }\n     }\n   va_end(args);\n@@ -1338,13 +1346,13 @@ objc_read_types(TypedStream* stream, const char* type, ...)\n \t  res = objc_read_array (stream, t, len, va_arg(args, void*));\n \t  t = objc_skip_typespec (t);\n \t  if (*t != _C_ARY_E)\n-\t    __objc_fatal(\"expected `]', got: %s\", t);\n+\t    objc_error(nil, OBJC_ERR_BAD_TYPE, \"expected `]', got: %s\", t);\n \t}\n \tbreak; \n \t\n       default:\n-\tfprintf(stderr, \"objc_read_types: cannot parse typespec: %s\\n\", type);\n-\tabort();\n+\tobjc_error(nil, OBJC_ERR_BAD_TYPE, \n+\t\t   \"objc_read_types: cannot parse typespec: %s\\n\", type);\n       }\n     }\n   va_end(args);\n@@ -1414,13 +1422,13 @@ __objc_feof(FILE* file)\n static int \n __objc_no_write(FILE* file, char* data, int len)\n {\n-  __objc_fatal (\"TypedStream not open for writing\");\n+  objc_error (nil, OBJC_ERR_NO_WRITE, \"TypedStream not open for writing\");\n }\n \n static int \n __objc_no_read(FILE* file, char* data, int len)\n {\n-  __objc_fatal (\"TypedStream not open for reading\");\n+  objc_error (nil, OBJC_ERR_NO_READ, \"TypedStream not open for reading\");\n }\n \n static int\n@@ -1434,7 +1442,8 @@ __objc_read_typed_stream_signature (TypedStream* stream)\n     ;\n   sscanf (buffer, \"GNU TypedStream %d\", &stream->version);\n   if (stream->version != OBJC_TYPED_STREAM_VERSION)\n-    __objc_fatal (\"cannot handle TypedStream version %d\", stream->version);\n+    objc_error (nil, OBJC_ERR_STREAM_VERSION,\n+\t\t\"cannot handle TypedStream version %d\", stream->version);\n   return 1;\n }\n \n@@ -1459,11 +1468,12 @@ static void __objc_finish_write_root_object(struct objc_typed_stream* stream)\n static void __objc_finish_read_root_object(struct objc_typed_stream* stream)\n {\n   node_ptr node;\n-  struct objc_list* free_list;\n   SEL awake_sel = sel_get_any_uid (\"awake\");\n+  cache_ptr free_list = hash_new (64,\n+\t\t\t\t  (hash_func_type) hash_ptr,\n+\t\t\t\t  (compare_func_type) compare_ptrs);\n \n   /* resolve object forward references */\n-  free_list = list_cons(NULL, NULL);\n   for (node = hash_next (stream->object_refs, NULL); node;\n        node = hash_next (stream->object_refs, node))\n     {\n@@ -1473,13 +1483,19 @@ static void __objc_finish_read_root_object(struct objc_typed_stream* stream)\n       while(reflist)\n \t{\n \t  *((id*)reflist->head) = object;\n-          if (list_find(&free_list, reflist) == NULL)\n-\t    free_list = list_cons (reflist, free_list);\n+\t  if (hash_value_for_key (free_list,reflist) == NULL)\n+\t    hash_add (&free_list,reflist,reflist);\n+\n \t  reflist = reflist->tail;\n \t}\n     }\n-  list_mapcar (free_list, objc_free);\n-  list_free (free_list);\n+    \n+  /* apply __objc_free to all objects stored in free_list */\n+  for (node = hash_next (free_list, NULL); node;\n+       node = hash_next (free_list, node))\n+    objc_free ((void *) node->key);\n+\n+  hash_delete (free_list);\n \n   /* empty object reference table */\n   hash_delete (stream->object_refs);"}]}