{"sha": "012b51cf21538e0695cbcc6b725f1140655c86b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEyYjUxY2YyMTUzOGUwNjk1Y2JjYzZiNzI1ZjExNDA2NTVjODZiNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2018-11-20T18:06:03Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-11-20T18:06:03Z"}, "message": "ipa-devirt.c (add_type_duplicate): Do not ICE on incomplete enums.\n\n\n\t* ipa-devirt.c (add_type_duplicate): Do not ICE on incomplete enums.\n\t* tree.c (build_array_type_1): Forward declare.\n\t(fld_type_variant_equal_p): Add INNER_TYPE parameter.\n\t(fld_type_variant): Likewise.\n\t(fld_simplified_types): New hash.\n\t(fld_process_array_type): New function.\n\t(fld_incomplete_type_of): Handle array and enumeration types.\n\t(fld_simplified_type): Handle simplification of arrays.\n\t(free_lang_data): Allocate and free simplified types hash.\n\nFrom-SVN: r266325", "tree": {"sha": "98c92a2a0473ed1540cf5709e17d2b5aef56bcaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98c92a2a0473ed1540cf5709e17d2b5aef56bcaf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/012b51cf21538e0695cbcc6b725f1140655c86b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/012b51cf21538e0695cbcc6b725f1140655c86b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/012b51cf21538e0695cbcc6b725f1140655c86b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/012b51cf21538e0695cbcc6b725f1140655c86b7/comments", "author": null, "committer": null, "parents": [{"sha": "5702bb9494497fb09aff5b7e52fb013723bfe423", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5702bb9494497fb09aff5b7e52fb013723bfe423", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5702bb9494497fb09aff5b7e52fb013723bfe423"}], "stats": {"total": 98, "additions": 83, "deletions": 15}, "files": [{"sha": "116e4b1f19dcda4201da0fa1f0480bf885cc6631", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012b51cf21538e0695cbcc6b725f1140655c86b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012b51cf21538e0695cbcc6b725f1140655c86b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=012b51cf21538e0695cbcc6b725f1140655c86b7", "patch": "@@ -1,3 +1,15 @@\n+2018-11-20  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-devirt.c (add_type_duplicate): Do not ICE on incomplete enums.\n+\t* tree.c (build_array_type_1): Forward declare.\n+\t(fld_type_variant_equal_p): Add INNER_TYPE parameter.\n+\t(fld_type_variant): Likewise.\n+\t(fld_simplified_types): New hash.\n+\t(fld_process_array_type): New function.\n+\t(fld_incomplete_type_of): Handle array and enumeration types.\n+\t(fld_simplified_type): Handle simplification of arrays.\n+\t(free_lang_data): Allocate and free simplified types hash.\n+\n 2018-11-20  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR lto/87957"}, {"sha": "229eebcb65f1068215fbc273f0786bb956ce1667", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012b51cf21538e0695cbcc6b725f1140655c86b7/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012b51cf21538e0695cbcc6b725f1140655c86b7/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=012b51cf21538e0695cbcc6b725f1140655c86b7", "patch": "@@ -1720,7 +1720,8 @@ add_type_duplicate (odr_type val, tree type)\n   else if (!COMPLETE_TYPE_P (val->type) && COMPLETE_TYPE_P (type))\n     {\n       prevail = true;\n-      build_bases = TYPE_BINFO (type);\n+      if (TREE_CODE (type) == RECORD_TYPE)\n+        build_bases = TYPE_BINFO (type);\n     }\n   else if (COMPLETE_TYPE_P (val->type) && !COMPLETE_TYPE_P (type))\n     ;"}, {"sha": "50c4cd0e4a16d40460ea9c6067747b0196996ce2", "filename": "gcc/tree.c", "status": "modified", "additions": 69, "deletions": 14, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012b51cf21538e0695cbcc6b725f1140655c86b7/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012b51cf21538e0695cbcc6b725f1140655c86b7/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=012b51cf21538e0695cbcc6b725f1140655c86b7", "patch": "@@ -265,6 +265,8 @@ static void print_type_hash_statistics (void);\n static void print_debug_expr_statistics (void);\n static void print_value_expr_statistics (void);\n \n+static tree build_array_type_1 (tree, tree, bool, bool);\n+\n tree global_trees[TI_MAX];\n tree integer_types[itk_none];\n \n@@ -5109,10 +5111,11 @@ fld_simplified_type_name (tree type)\n \n /* Do same comparsion as check_qualified_type skipping lang part of type\n    and be more permissive about type names: we only care that names are\n-   same (for diagnostics) and that ODR names are the same.  */\n+   same (for diagnostics) and that ODR names are the same.\n+   If INNER_TYPE is non-NULL, be sure that TREE_TYPE match it.  */\n \n static bool\n-fld_type_variant_equal_p (tree t, tree v)\n+fld_type_variant_equal_p (tree t, tree v, tree inner_type)\n {\n   if (TYPE_QUALS (t) != TYPE_QUALS (v)\n       /* We want to match incomplete variants with complete types.\n@@ -5122,21 +5125,24 @@ fld_type_variant_equal_p (tree t, tree v)\n \t      || TYPE_USER_ALIGN (t) != TYPE_USER_ALIGN (v)))\n       || fld_simplified_type_name (t) != fld_simplified_type_name (v)\n       || !attribute_list_equal (TYPE_ATTRIBUTES (t),\n-\t\t\t        TYPE_ATTRIBUTES (v)))\n+\t\t\t        TYPE_ATTRIBUTES (v))\n+      || (inner_type && TREE_TYPE (v) != inner_type))\n     return false;\n- \n+\n   return true;\n }\n \n-/* Find variant of FIRST that match T and create new one if necessary.  */\n+/* Find variant of FIRST that match T and create new one if necessary.\n+   Set TREE_TYPE to INNER_TYPE if non-NULL.  */\n \n static tree\n-fld_type_variant (tree first, tree t, struct free_lang_data_d *fld)\n+fld_type_variant (tree first, tree t, struct free_lang_data_d *fld,\n+\t\t  tree inner_type = NULL)\n {\n   if (first == TYPE_MAIN_VARIANT (t))\n     return t;\n   for (tree v = first; v; v = TYPE_NEXT_VARIANT (v))\n-    if (fld_type_variant_equal_p (t, v))\n+    if (fld_type_variant_equal_p (t, v, inner_type))\n       return v;\n   tree v = build_variant_type_copy (first);\n   TYPE_READONLY (v) = TYPE_READONLY (t);\n@@ -5154,7 +5160,9 @@ fld_type_variant (tree first, tree t, struct free_lang_data_d *fld)\n       SET_TYPE_ALIGN (v, TYPE_ALIGN (t));\n       TYPE_USER_ALIGN (v) = TYPE_USER_ALIGN (t);\n     }\n-  gcc_checking_assert (fld_type_variant_equal_p (t,v));\n+  if (inner_type)\n+    TREE_TYPE (v) = inner_type;\n+  gcc_checking_assert (fld_type_variant_equal_p (t,v, inner_type));\n   add_tree_to_fld_list (v, fld);\n   return v;\n }\n@@ -5163,6 +5171,41 @@ fld_type_variant (tree first, tree t, struct free_lang_data_d *fld)\n \n static hash_map<tree, tree> *fld_incomplete_types;\n \n+/* Map types to simplified types.  */\n+\n+static hash_map<tree, tree> *fld_simplified_types;\n+\n+/* Produce variant of T whose TREE_TYPE is T2. If it is main variant,\n+   use MAP to prevent duplicates.  */\n+\n+static tree\n+fld_process_array_type (tree t, tree t2, hash_map<tree, tree> *map,\n+\t\t\tstruct free_lang_data_d *fld)\n+{\n+  if (TREE_TYPE (t) == t2)\n+    return t;\n+\n+  if (TYPE_MAIN_VARIANT (t) != t)\n+    {\n+      return fld_type_variant\n+\t       (fld_process_array_type (TYPE_MAIN_VARIANT (t),\n+\t\t\t\t\tTYPE_MAIN_VARIANT (t2), map, fld),\n+\t\tt, fld, t2);\n+    }\n+\n+  bool existed;\n+  tree &array\n+     = map->get_or_insert (t, &existed);\n+  if (!existed)\n+    {\n+      array = build_array_type_1 (t2, TYPE_DOMAIN (t),\n+\t\t\t\t  TYPE_TYPELESS_STORAGE (t), false);\n+      TYPE_CANONICAL (array) = TYPE_CANONICAL (t);\n+      add_tree_to_fld_list (array, fld);\n+    }\n+  return array;\n+}\n+\n /* For T being aggregate type try to turn it into a incomplete variant.\n    Return T if no simplification is possible.  */\n \n@@ -5190,7 +5233,12 @@ fld_incomplete_type_of (tree t, struct free_lang_data_d *fld)\n \t}\n       return t;\n     }\n-  if (!RECORD_OR_UNION_TYPE_P (t) || !COMPLETE_TYPE_P (t))\n+  if (TREE_CODE (t) == ARRAY_TYPE)\n+    return fld_process_array_type (t,\n+\t\t\t\t   fld_incomplete_type_of (TREE_TYPE (t), fld),\n+\t\t\t\t   fld_incomplete_types, fld);\n+  if ((!RECORD_OR_UNION_TYPE_P (t) && TREE_CODE (t) != ENUMERAL_TYPE)\n+      || !COMPLETE_TYPE_P (t))\n     return t;\n   if (TYPE_MAIN_VARIANT (t) == t)\n     {\n@@ -5202,18 +5250,18 @@ fld_incomplete_type_of (tree t, struct free_lang_data_d *fld)\n \t{\n \t  copy = build_distinct_type_copy (t);\n \n-\t  /* It is possible type was not seen by free_lang_data yet.  */\n+\t  /* It is possible that type was not seen by free_lang_data yet.  */\n \t  add_tree_to_fld_list (copy, fld);\n \t  TYPE_SIZE (copy) = NULL;\n-\t  SET_TYPE_MODE (copy, VOIDmode);\n-\t  SET_TYPE_ALIGN (copy, BITS_PER_UNIT);\n \t  TYPE_USER_ALIGN (copy) = 0;\n \t  TYPE_SIZE_UNIT (copy) = NULL;\n \t  TYPE_CANONICAL (copy) = TYPE_CANONICAL (t);\n-\t  TYPE_TYPELESS_STORAGE (copy) = 0;\n \t  TREE_ADDRESSABLE (copy) = 0;\n \t  if (AGGREGATE_TYPE_P (t))\n \t    {\n+\t      SET_TYPE_MODE (copy, VOIDmode);\n+\t      SET_TYPE_ALIGN (copy, BITS_PER_UNIT);\n+\t      TYPE_TYPELESS_STORAGE (copy) = 0;\n \t      TYPE_FIELDS (copy) = NULL;\n \t      TYPE_BINFO (copy) = NULL;\n \t    }\n@@ -5232,8 +5280,13 @@ fld_incomplete_type_of (tree t, struct free_lang_data_d *fld)\n static tree\n fld_simplified_type (tree t, struct free_lang_data_d *fld)\n {\n-  if (t && POINTER_TYPE_P (t))\n+  if (!t)\n+    return t;\n+  if (POINTER_TYPE_P (t))\n     return fld_incomplete_type_of (t, fld);\n+  if (TREE_CODE (t) == ARRAY_TYPE)\n+    return fld_process_array_type (t, fld_simplified_type (TREE_TYPE (t), fld),\n+\t\t\t\t   fld_simplified_types, fld);\n   return t;\n }\n \n@@ -6070,6 +6123,7 @@ free_lang_data (void)\n     return 0;\n \n   fld_incomplete_types = new hash_map<tree, tree>;\n+  fld_simplified_types = new hash_map<tree, tree>;\n \n   /* Provide a dummy TRANSLATION_UNIT_DECL if the FE failed to provide one.  */\n   if (vec_safe_is_empty (all_translation_units))\n@@ -6126,6 +6180,7 @@ free_lang_data (void)\n   rebuild_type_inheritance_graph ();\n \n   delete fld_incomplete_types;\n+  delete fld_simplified_types;\n \n   return 0;\n }"}]}